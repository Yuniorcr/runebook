<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="qt">
    <body>
      <group id="qt">
        <trans-unit id="adf54fd7881b01dd5fbb317fe0878e5876b7ee5a" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;qvulkanwindow#supportsGrab&quot;&gt;supportsGrab&lt;/a&gt;() returns true, &lt;a href=&quot;qvulkanwindow&quot;&gt;QVulkanWindow&lt;/a&gt; can perform readbacks from the color buffer into a &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt;. &lt;a href=&quot;qvulkanwindow#grab&quot;&gt;grab&lt;/a&gt;() is a slow and inefficient operation, so frequent usage should be avoided. It is nonetheless valuable since it allows applications to take screenshots, or tools and tests to process and verify the output of the GPU rendering.</source>
          <target state="translated">경우 &lt;a href=&quot;qvulkanwindow#supportsGrab&quot;&gt;supportsGrab가&lt;/a&gt; true를 반환 &lt;a href=&quot;qvulkanwindow&quot;&gt;QVulkanWindow은&lt;/a&gt; (A) 내로 컬러 버퍼로부터 readbacks를 수행 &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt; . &lt;a href=&quot;qvulkanwindow#grab&quot;&gt;grab&lt;/a&gt; ()는 느리고 비효율적 인 작업이므로 자주 사용하지 않아야합니다. 그럼에도 불구하고 응용 프로그램이 스크린 샷 또는 도구 및 테스트를 수행하여 GPU 렌더링의 출력을 처리하고 확인할 수 있기 때문에 가치가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a855aaf2660d645fa9b8949d66a891591b9ae74f" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;qvulkanwindow#supportsGrab&quot;&gt;supportsGrab&lt;/a&gt;() returns true, QVulkanWindow can perform readbacks from the color buffer into a &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt;. &lt;a href=&quot;qvulkanwindow#grab&quot;&gt;grab&lt;/a&gt;() is a slow and inefficient operation, so frequent usage should be avoided. It is nonetheless valuable since it allows applications to take screenshots, or tools and tests to process and verify the output of the GPU rendering.</source>
          <target state="translated">When &lt;a href=&quot;qvulkanwindow#supportsGrab&quot;&gt;supportsGrab&lt;/a&gt;() returns true, QVulkanWindow can perform readbacks from the color buffer into a &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt;. &lt;a href=&quot;qvulkanwindow#grab&quot;&gt;grab&lt;/a&gt;() is a slow and inefficient operation, so frequent usage should be avoided. It is nonetheless valuable since it allows applications to take screenshots, or tools and tests to process and verify the output of the GPU rendering.</target>
        </trans-unit>
        <trans-unit id="6823f0c205033d4ea128122af4b97d19b1b0c274" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;qxmlquery&quot;&gt;QXmlQuery&lt;/a&gt; accesses resources (e.g., calling &lt;code&gt;fn:doc()&lt;/code&gt; to load a file, or accessing a device via a bound variable), the event loop is used, which means events will be processed. To avoid processing events when &lt;a href=&quot;qxmlquery&quot;&gt;QXmlQuery&lt;/a&gt; accesses resources, create your &lt;a href=&quot;qxmlquery&quot;&gt;QXmlQuery&lt;/a&gt; instance in a separate thread.</source>
          <target state="translated">&lt;a href=&quot;qxmlquery&quot;&gt;QXmlQuery가&lt;/a&gt; 리소스에 액세스 할 때 (예 &lt;code&gt;fn:doc()&lt;/code&gt; 를 호출 하여 파일을로드하거나 바운드 변수를 통해 장치에 액세스) 이벤트 루프가 사용되므로 이벤트가 처리됩니다. &lt;a href=&quot;qxmlquery&quot;&gt;QXmlQuery가&lt;/a&gt; 자원에 액세스 할 때 이벤트 처리를 피하려면 별도의 스레드에서 &lt;a href=&quot;qxmlquery&quot;&gt;QXmlQuery&lt;/a&gt; 인스턴스를 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="5a4303763eb160478daacc616e1e09a84ccb3fd3" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;qxmlquery&quot;&gt;QXmlQuery&lt;/a&gt; calls &lt;a href=&quot;qabstractmessagehandler#message&quot;&gt;QAbstractMessageHandler::message&lt;/a&gt;(), the arguments are as follows:</source>
          <target state="translated">&lt;a href=&quot;qxmlquery&quot;&gt;QXmlQuery&lt;/a&gt; 가 &lt;a href=&quot;qabstractmessagehandler#message&quot;&gt;QAbstractMessageHandler :: message&lt;/a&gt; ()를 호출 할 때 인수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2414e2eb1638148ea5acad1b6c425e2a2fa8d639" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;qxmlquery#setQuery&quot;&gt;setQuery&lt;/a&gt;() is called, the query text is compiled into an internal data structure and optimized. The optimized form can then be reused for multiple evaluations of the query. Since the compile-and-optimize process can be expensive, repeating it for the same query should be avoided by using a separate instance of &lt;a href=&quot;qxmlquery&quot;&gt;QXmlQuery&lt;/a&gt; for each query text.</source>
          <target state="translated">경우 &lt;a href=&quot;qxmlquery#setQuery&quot;&gt;setQuery는&lt;/a&gt; ()가 호출되면, 쿼리 텍스트는 내부 데이터 구조로 컴파일되고 최적화된다. 그런 다음 쿼리의 여러 평가에 최적화 된 양식을 재사용 할 수 있습니다. 컴파일 및 최적화 프로세스는 비용이 많이들 수 있으므로 각 쿼리 텍스트에 대해 별도의 &lt;a href=&quot;qxmlquery&quot;&gt;QXmlQuery&lt;/a&gt; 인스턴스를 사용하여 동일한 쿼리에 대해 반복하는 과정을 피해야 합니다.</target>
        </trans-unit>
        <trans-unit id="df60f13705bccbfb1ebe641d5980c4f255529f48" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;qxmlquery#setQuery&quot;&gt;setQuery&lt;/a&gt;() is called, the query text is compiled into an internal data structure and optimized. The optimized form can then be reused for multiple evaluations of the query. Since the compile-and-optimize process can be expensive, repeating it for the same query should be avoided by using a separate instance of QXmlQuery for each query text.</source>
          <target state="translated">When &lt;a href=&quot;qxmlquery#setQuery&quot;&gt;setQuery&lt;/a&gt;() is called, the query text is compiled into an internal data structure and optimized. The optimized form can then be reused for multiple evaluations of the query. Since the compile-and-optimize process can be expensive, repeating it for the same query should be avoided by using a separate instance of QXmlQuery for each query text.</target>
        </trans-unit>
        <trans-unit id="8f0e33d48640a9980a60399682ba53ff818618de" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;qxmlschema&quot;&gt;QXmlSchema&lt;/a&gt; calls &lt;a href=&quot;qabstractmessagehandler#message&quot;&gt;QAbstractMessageHandler::message&lt;/a&gt;(), the arguments are as follows:</source>
          <target state="translated">&lt;a href=&quot;qxmlschema&quot;&gt;QXmlSchema&lt;/a&gt; 가 &lt;a href=&quot;qabstractmessagehandler#message&quot;&gt;QAbstractMessageHandler :: message&lt;/a&gt; ()를 호출 할 때 인수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="34a36de9f3978a9dc52660020f38e10757c3b33a" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;qxmlschemavalidator&quot;&gt;QXmlSchemaValidator&lt;/a&gt; calls &lt;a href=&quot;qabstractmessagehandler#message&quot;&gt;QAbstractMessageHandler::message&lt;/a&gt;(), the arguments are as follows:</source>
          <target state="translated">&lt;a href=&quot;qxmlschemavalidator&quot;&gt;QXmlSchemaValidator&lt;/a&gt; 가 &lt;a href=&quot;qabstractmessagehandler#message&quot;&gt;QAbstractMessageHandler :: message&lt;/a&gt; ()를 호출 할 때 인수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="abc180cdaa67db2334bc9aec8221bc677db91dc0" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&amp;lt;param&amp;gt;&lt;/code&gt; elements are used in the &lt;code&gt;&amp;lt;send&amp;gt;&lt;/code&gt; element, the data will contain a &lt;a href=&quot;qvariant#QVariantMap-typedef&quot;&gt;QVariantMap&lt;/a&gt; where the key is the</source>
          <target state="translated">경우 &lt;code&gt;&amp;lt;param&amp;gt;&lt;/code&gt; 에서 사용되는 요소 &lt;code&gt;&amp;lt;send&amp;gt;&lt;/code&gt; 소자, 포함될 데이터 &lt;a href=&quot;qvariant#QVariantMap-typedef&quot;&gt;QVariantMap는&lt;/a&gt; 키가되는 위치</target>
        </trans-unit>
        <trans-unit id="a06133ee79a232acbfba343775e247dd1fc22db2" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;GL_ARB_framebuffer_sRGB&lt;/code&gt; or &lt;code&gt;GL_EXT_framebuffer_sRGB&lt;/code&gt; is supported by the platform and this value is set, the window will be created with an sRGB-capable default framebuffer. Note that some platforms may return windows with a sRGB-capable default framebuffer even when not requested explicitly.</source>
          <target state="translated">때 &lt;code&gt;GL_ARB_framebuffer_sRGB&lt;/code&gt; 또는 &lt;code&gt;GL_EXT_framebuffer_sRGB&lt;/code&gt; 이 플랫폼에서 지원되며,이 값을 설정, 윈도우는 sRGB를 지원 기본 프레임 버퍼에 생성됩니다. 일부 플랫폼에서는 명시 적으로 요청하지 않은 경우에도 sRGB 가능 기본 프레임 버퍼가있는 창을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa3913ff2ab5c3e811ba7c183222c6fcac1a3447" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;QT_OPENGL_BUGLIST&lt;/code&gt; is not specified, a built-in list will be used. This typically includes some older, less-capable graphics cards with &lt;code&gt;disable_desktopgl&lt;/code&gt; set, in order to prevent Qt from using their unstable desktop OpenGL implementations and instead fall back to ANGLE right away.</source>
          <target state="translated">When &lt;code&gt;QT_OPENGL_BUGLIST&lt;/code&gt; is not specified, a built-in list will be used. This typically includes some older, less-capable graphics cards with &lt;code&gt;disable_desktopgl&lt;/code&gt; set, in order to prevent Qt from using their unstable desktop OpenGL implementations and instead fall back to ANGLE right away.</target>
        </trans-unit>
        <trans-unit id="ed4d9b70602719a6967792783570916cdfb715ef" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;button&lt;/code&gt; is clicked, the machine will transition into state &lt;code&gt;s2&lt;/code&gt;, which will set the geometry of the button, and then pop up a message box to alert the user that the geometry has been changed.</source>
          <target state="translated">때 &lt;code&gt;button&lt;/code&gt; 클릭, 기계 상태로 전환됩니다 &lt;code&gt;s2&lt;/code&gt; 버튼의 형상을 설정하고 형상이 변경되었음을 사용자에게 경고하는 메시지 상자가 나타납니다한다.</target>
        </trans-unit>
        <trans-unit id="2388f2e21addac6210aabde322ea581bb6afffb1" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;mode&lt;/code&gt; is not defined, the mode that is reported as preferred by the system is chosen. The accepted values for &lt;code&gt;mode&lt;/code&gt; are: &lt;code&gt;off&lt;/code&gt;, &lt;code&gt;current&lt;/code&gt;, &lt;code&gt;preferred&lt;/code&gt;, &lt;code&gt;skip&lt;/code&gt;, width&lt;code&gt;x&lt;/code&gt;height, width&lt;code&gt;x&lt;/code&gt;height&lt;code&gt;@&lt;/code&gt;vrefresh, or a modeline string.</source>
          <target state="translated">시 &lt;code&gt;mode&lt;/code&gt; 정의되어 있지 않은, 시스템이 바람직한 것으로보고 모드가 선택된다. &lt;code&gt;mode&lt;/code&gt; 에 허용되는 값 은 &lt;code&gt;off&lt;/code&gt; , &lt;code&gt;current&lt;/code&gt; , &lt;code&gt;preferred&lt;/code&gt; , &lt;code&gt;skip&lt;/code&gt; , width &lt;code&gt;x&lt;/code&gt; height, width &lt;code&gt;x&lt;/code&gt; height &lt;code&gt;@&lt;/code&gt; vrefresh 또는 modeline string입니다.</target>
        </trans-unit>
        <trans-unit id="ad2de4e55d4aebd9b4557d94a6cf5c7e0065f8b8" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;mode&lt;/code&gt; is not defined, the system's preferred mode is chosen. The accepted values for &lt;code&gt;mode&lt;/code&gt; are: &lt;code&gt;off&lt;/code&gt;, &lt;code&gt;current&lt;/code&gt;, &lt;code&gt;preferred&lt;/code&gt;, &lt;code&gt;skip&lt;/code&gt;, width&lt;code&gt;x&lt;/code&gt;height, width&lt;code&gt;x&lt;/code&gt;height&lt;code&gt;@&lt;/code&gt;vrefresh, or a modeline string.</source>
          <target state="translated">When &lt;code&gt;mode&lt;/code&gt; is not defined, the system's preferred mode is chosen. The accepted values for &lt;code&gt;mode&lt;/code&gt; are: &lt;code&gt;off&lt;/code&gt; , &lt;code&gt;current&lt;/code&gt; , &lt;code&gt;preferred&lt;/code&gt; , &lt;code&gt;skip&lt;/code&gt; , width &lt;code&gt;x&lt;/code&gt; height, width &lt;code&gt;x&lt;/code&gt; height &lt;code&gt;@&lt;/code&gt; vrefresh, or a modeline string.</target>
        </trans-unit>
        <trans-unit id="bebb2b33e2691fc3d175656c1b70af1ee1b6346d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;reanchorToRight&lt;/code&gt; is called, the function first sets the right anchor. At that point, both left and right anchors are set, and the item will be stretched horizontally to fill its parent. When the left anchor is unset, the new width will remain. Thus when updating anchors within JavaScript, you should first unset any anchors that are no longer required, and only then set any new anchors that are required, as shown below:</source>
          <target state="translated">&lt;code&gt;reanchorToRight&lt;/code&gt; 때 호출 함수는 먼저 오른쪽 앵커를 설정한다. 이 시점에서 왼쪽 및 오른쪽 앵커가 모두 설정되고 항목이 부모를 채우기 위해 가로로 늘어납니다. 왼쪽 앵커를 설정하지 않으면 새 너비가 유지됩니다. 따라서 JavaScript 내에서 앵커를 업데이트 할 때는 먼저 더 이상 필요하지 않은 앵커를 설정 해제 한 다음 아래에 표시된대로 필요한 새 앵커 만 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="8825f7725f1dc91940c2a034ec29bd99db520ddf" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;s1&lt;/code&gt; 's final state is entered, &lt;code&gt;s1&lt;/code&gt; will automatically emit &lt;a href=&quot;qml-qtqml-statemachine-state#finished-signal&quot;&gt;finished&lt;/a&gt;. We use a signal transition to cause this event to trigger a state change:</source>
          <target state="translated">시 &lt;code&gt;s1&lt;/code&gt; 의 최종 상태를 입력 할 때, &lt;code&gt;s1&lt;/code&gt; 자동으로 내 보냅니다 &lt;a href=&quot;qml-qtqml-statemachine-state#finished-signal&quot;&gt;완료&lt;/a&gt; . 이 이벤트가 상태 변경을 트리거하도록 신호 전이를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="a068e7c1d71be79be1747b295f8d0bdf7d0f76ad" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;s1&lt;/code&gt; 's final state is entered, &lt;code&gt;s1&lt;/code&gt; will automatically emit &lt;a href=&quot;qstate#finished&quot;&gt;finished()&lt;/a&gt;. We use a signal transition to cause this event to trigger a state change:</source>
          <target state="translated">하면 &lt;code&gt;s1&lt;/code&gt; 의 최종 상태가 입력된다 &lt;code&gt;s1&lt;/code&gt; 자동으로 발광한다 &lt;a href=&quot;qstate#finished&quot;&gt;완료 ()&lt;/a&gt; . 이 이벤트가 상태 변경을 트리거하도록 신호 전이를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="7c85d7dd31dd96c49b09a16e731e181b35179393" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;text&lt;/code&gt; changes, the C++ property &lt;code&gt;enteredText&lt;/code&gt; will update automatically.</source>
          <target state="translated">때 &lt;code&gt;text&lt;/code&gt; 변경의 C ++ 특성 &lt;code&gt;enteredText&lt;/code&gt; 가 자동으로 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="274f974610c7463228dfb5154f647e8c8a8ccdcb" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;true&lt;/code&gt;, all generated numbers appearing in various series and axis labels will be localized using the &lt;a href=&quot;qlocale&quot;&gt;QLocale&lt;/a&gt; set with the &lt;a href=&quot;qchart#locale-prop&quot;&gt;locale&lt;/a&gt; property. When &lt;code&gt;false&lt;/code&gt;, the</source>
          <target state="translated">때 &lt;code&gt;true&lt;/code&gt; , 모든 생성 된 다양한 시리즈에 나오는 숫자와 축 라벨은 사용 현지화됩니다 &lt;a href=&quot;qlocale&quot;&gt;QLocale의&lt;/a&gt; 설정 &lt;a href=&quot;qchart#locale-prop&quot;&gt;로케일&lt;/a&gt; 속성을. 때 &lt;code&gt;false&lt;/code&gt; 의</target>
        </trans-unit>
        <trans-unit id="36e568b70799170c0d96b90a8147537bfc741c8b" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;true&lt;/code&gt;, all generated numbers appearing in various series and axis labels will be localized using the &lt;a href=&quot;qlocale&quot;&gt;QLocale&lt;/a&gt; set with the &lt;a href=&quot;qml-qtcharts-chartview#locale-prop&quot;&gt;locale&lt;/a&gt; property. When &lt;code&gt;false&lt;/code&gt;, the</source>
          <target state="translated">때 &lt;code&gt;true&lt;/code&gt; , 모든 생성 된 다양한 시리즈에 나오는 숫자와 축 라벨은 사용 현지화됩니다 &lt;a href=&quot;qlocale&quot;&gt;QLocale의&lt;/a&gt; 설정 &lt;a href=&quot;qml-qtcharts-chartview#locale-prop&quot;&gt;로케일&lt;/a&gt; 속성을. 때 &lt;code&gt;false&lt;/code&gt; 의</target>
        </trans-unit>
        <trans-unit id="3e953b3a9be5222efb277759886bb97613fdfda7" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;true&lt;/code&gt;, the style should underline the menu item's label mnemonic.</source>
          <target state="translated">때 &lt;code&gt;true&lt;/code&gt; , 스타일이 메뉴 항목의 라벨이 니모닉 강조한다.</target>
        </trans-unit>
        <trans-unit id="3172ee2682029786deccd528a524db012a091668" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;virtualIndex&lt;/code&gt; is not sufficient, the &lt;code&gt;virtualPos&lt;/code&gt; property can be used to explicitly specify the top-left position of the screen in question. Taking the previous example and assuming a resolution of 1080p for HDMI1, the following code snippet places a second HDMI-based screen below the first one:</source>
          <target state="translated">When &lt;code&gt;virtualIndex&lt;/code&gt; is not sufficient, the &lt;code&gt;virtualPos&lt;/code&gt; property can be used to explicitly specify the top-left position of the screen in question. Taking the previous example and assuming a resolution of 1080p for HDMI1, the following code snippet places a second HDMI-based screen below the first one:</target>
        </trans-unit>
        <trans-unit id="21a5b61887b0cac6a56dd588dce0ad7f3bbdb837" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;virtualIndex&lt;/code&gt; is not sufficient, the property &lt;code&gt;virtualPos&lt;/code&gt; can be used to explicitly specify the top-left position of the screen in question. Taking the previous example and assuming a resolution of 1080p for HDMI1, the following places a second HDMI-based screen below the first one:</source>
          <target state="translated">때 &lt;code&gt;virtualIndex&lt;/code&gt; 가 충분하지 않습니다, 속성 &lt;code&gt;virtualPos&lt;/code&gt; 은 명시 적으로 문제가되는 화면의 왼쪽 상단 위치를 지정할 수 있습니다. 앞의 예를보고 HDMI1의 1080p 해상도를 가정하면 다음은 첫 번째 화면 아래에 두 번째 HDMI 기반 화면을 배치합니다.</target>
        </trans-unit>
        <trans-unit id="ce9c2c5e673edc4df91dd9cd97b16eb59ee71073" translate="yes" xml:space="preserve">
          <source>When DPI scaling is used by the system, the logical surface size, which is used by mouse events, and the actual 'physical' size of the surface can differ. The &lt;a href=&quot;qml-qt3d-render-rendersurfaceselector#surfacePixelRatio-prop&quot;&gt;surfacePixelRatio&lt;/a&gt; is the factor to convert the logical size to the physical size.</source>
          <target state="translated">시스템에서 DPI 스케일링을 사용하는 경우 마우스 이벤트에 사용되는 논리적 표면 크기와 표면의 실제 '물리적'크기가 다를 수 있습니다. &lt;a href=&quot;qml-qt3d-render-rendersurfaceselector#surfacePixelRatio-prop&quot;&gt;surfacePixelRatio은&lt;/a&gt; 물리적 크기에 논리적 크기를 변환 할 수있는 요인이다.</target>
        </trans-unit>
        <trans-unit id="67b4917a54c5a1f83822bb816252770e66fe2a99" translate="yes" xml:space="preserve">
          <source>When DPI scaling is used by the system, the logical surface size, which is used by mouse events, and the actual 'physical' size of the surface can differ. The &lt;a href=&quot;qt3drender-qrendersurfaceselector#surfacePixelRatio-prop&quot;&gt;surfacePixelRatio&lt;/a&gt; is the factor to convert the logical size to the physical size.</source>
          <target state="translated">시스템에서 DPI 스케일링을 사용하는 경우 마우스 이벤트에 사용되는 논리적 표면 크기와 표면의 실제 '물리적'크기가 다를 수 있습니다. &lt;a href=&quot;qt3drender-qrendersurfaceselector#surfacePixelRatio-prop&quot;&gt;surfacePixelRatio은&lt;/a&gt; 물리적 크기에 논리적 크기를 변환 할 수있는 요인이다.</target>
        </trans-unit>
        <trans-unit id="f1b60dd5dc0ba61c9eadb5e24ff7b6a22b038279" translate="yes" xml:space="preserve">
          <source>When FPS measuring is enabled, the results for the last second are stored in this read-only property. It takes at least a second before this value updates after measuring is activated.</source>
          <target state="translated">FPS 측정이 활성화되면 마지막 초에 대한 결과가이 읽기 전용 속성에 저장됩니다. 측정이 활성화 된 후이 값이 업데이트 되려면 최소한 1 초가 걸립니다.</target>
        </trans-unit>
        <trans-unit id="c6d97e48bea8d713090e390fc1224dfc4ec5d0cc" translate="yes" xml:space="preserve">
          <source>When HSTS is enabled, for each HTTP response containing HSTS header and received over a secure transport, &lt;a href=&quot;qnetworkaccessmanager&quot;&gt;QNetworkAccessManager&lt;/a&gt; will update its HSTS cache, either remembering a host with a valid policy or removing a host with an expired or disabled HSTS policy.</source>
          <target state="translated">HSTS가 활성화되면 HSTS 헤더를 포함하고 보안 전송을 통해 수신 된 각 HTTP 응답에 대해 &lt;a href=&quot;qnetworkaccessmanager&quot;&gt;QNetworkAccessManager&lt;/a&gt; 는 HSTS 캐시를 업데이트하여 유효한 정책이있는 호스트를 기억하거나 HSTS 정책이 만료되었거나 비활성화 된 호스트를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="c813b063d1c6a422bc40a6bf5d97ec4ee0b41451" translate="yes" xml:space="preserve">
          <source>When HTML markup is used for text, Qt follows the rules defined by the &lt;a href=&quot;http://www.w3.org/TR/html401/&quot;&gt;HTML 4&lt;/a&gt; specification. This includes default properties for text layout, such as the direction of the text flow (left-to-right) which can be changed by applying the &lt;a href=&quot;#block-attributes&quot;&gt;&lt;code&gt;dir&lt;/code&gt;&lt;/a&gt; attribute to blocks of text.</source>
          <target state="translated">HTML 마크 업이 텍스트에 사용되는 경우 Qt는 &lt;a href=&quot;http://www.w3.org/TR/html401/&quot;&gt;HTML 4&lt;/a&gt; 사양에 정의 된 규칙을 따릅니다 . 여기에는 &lt;a href=&quot;#block-attributes&quot;&gt; &lt;code&gt;dir&lt;/code&gt; &lt;/a&gt; 속성을 텍스트 블록 에 적용하여 변경할 수있는 텍스트 흐름 방향 (왼쪽에서 오른쪽으로)과 같은 텍스트 레이아웃의 기본 속성이 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="19e584a3c410cba7dfa95ae08639cd95d012b6b9" translate="yes" xml:space="preserve">
          <source>When HTML markup is used for text, Qt follows the rules defined by the &lt;a href=&quot;http://www.w3.org/TR/html401/&quot;&gt;HTML 4&lt;/a&gt; specification. This includes default properties for text layout, such as the direction of the text flow (left-to-right) which can be changed by applying the &lt;a href=&quot;richtext-html-subset#block-attributes&quot;&gt;&lt;code&gt;dir&lt;/code&gt;&lt;/a&gt; attribute to blocks of text.</source>
          <target state="translated">When HTML markup is used for text, Qt follows the rules defined by the &lt;a href=&quot;http://www.w3.org/TR/html401/&quot;&gt;HTML 4&lt;/a&gt; specification. This includes default properties for text layout, such as the direction of the text flow (left-to-right) which can be changed by applying the &lt;a href=&quot;richtext-html-subset#block-attributes&quot;&gt; &lt;code&gt;dir&lt;/code&gt; &lt;/a&gt; attribute to blocks of text.</target>
        </trans-unit>
        <trans-unit id="d031a5aad62e51b34085c95c6997afabca63874d" translate="yes" xml:space="preserve">
          <source>When LayoutDirectionAuto is used in conjunction with text layouting, it will imply that the text directionality is determined from the content of the string to be layouted.</source>
          <target state="translated">LayoutDirectionAuto를 텍스트 레이아웃과 함께 사용하면 레이아웃 할 문자열의 내용에서 텍스트 방향이 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="66418f264bb909da3c52c062e8ec0fb65ed558c8" translate="yes" xml:space="preserve">
          <source>When QDoc generates documentation for a project, it will also generate an &lt;code&gt;.index&lt;/code&gt; file containing URLs to each linkable entity in the project. Each dependency is a (lowercase) name of a project. This name must match with the base name of the index file generated for that project.</source>
          <target state="translated">When QDoc generates documentation for a project, it will also generate an &lt;code&gt;.index&lt;/code&gt; file containing URLs to each linkable entity in the project. Each dependency is a (lowercase) name of a project. This name must match with the base name of the index file generated for that project.</target>
        </trans-unit>
        <trans-unit id="7dc427b9427e3f31178f1302dfba94644ceb86f8" translate="yes" xml:space="preserve">
          <source>When QML types produce logging messages, it improves traceability if they include the QML file and line number on which the particular instance was instantiated.</source>
          <target state="translated">QML 유형이 로깅 메시지를 생성 할 때 특정 인스턴스가 인스턴스화 된 QML 파일 및 행 번호를 포함하면 추적 성이 향상됩니다.</target>
        </trans-unit>
        <trans-unit id="28bd2e83bcbfe95859e587b4383125510038621a" translate="yes" xml:space="preserve">
          <source>When QPickingSettings::pickMode() is set to &lt;a href=&quot;qt3drender-qpickingsettings#PickMethod-enum&quot;&gt;QPickingSettings::TrianglePicking&lt;/a&gt;, the signals on &lt;a href=&quot;qt3drender-qobjectpicker&quot;&gt;QObjectPicker&lt;/a&gt; will carry an instance of &lt;a href=&quot;qt3drender-qpicktriangleevent&quot;&gt;QPickTriangleEvent&lt;/a&gt;.</source>
          <target state="translated">QPickingSettings :: pickMode ()가 &lt;a href=&quot;qt3drender-qpickingsettings#PickMethod-enum&quot;&gt;QPickingSettings :: TrianglePicking으로&lt;/a&gt; 설정되면 QObjectPicker 의 신호는 &lt;a href=&quot;qt3drender-qobjectpicker&quot;&gt;QPickTriangleEvent&lt;/a&gt; 인스턴스를 &lt;a href=&quot;qt3drender-qpicktriangleevent&quot;&gt;전달&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="df9dd3cc9e117bbee05447ec8831a1da2303f862" translate="yes" xml:space="preserve">
          <source>When QPickingSettings::pickMode() is set to &lt;a href=&quot;qt3drender-qpickingsettings#PickMethod-enum&quot;&gt;QPickingSettings::TrianglePicking&lt;/a&gt;, the signals on &lt;a href=&quot;qt3drender-qobjectpicker&quot;&gt;QObjectPicker&lt;/a&gt; will carry an instance of QPickTriangleEvent.</source>
          <target state="translated">When QPickingSettings::pickMode() is set to &lt;a href=&quot;qt3drender-qpickingsettings#PickMethod-enum&quot;&gt;QPickingSettings::TrianglePicking&lt;/a&gt;, the signals on &lt;a href=&quot;qt3drender-qobjectpicker&quot;&gt;QObjectPicker&lt;/a&gt; will carry an instance of QPickTriangleEvent.</target>
        </trans-unit>
        <trans-unit id="457be61d0f002d025c887c713d51fbbfadff17ad" translate="yes" xml:space="preserve">
          <source>When QPickingSettings::pickMode() is set to QPickingSettings::TrianglePicking, the signals on QObjectPicker will carry an instance of QPickTriangleEvent.</source>
          <target state="translated">QPickingSettings :: pickMode ()가 QPickingSettings :: TrianglePicking으로 설정되면 QObjectPicker의 신호는 QPickTriangleEvent의 인스턴스를 전달합니다.</target>
        </trans-unit>
        <trans-unit id="508f9df752233b565bb26370c5a26e20603658ac" translate="yes" xml:space="preserve">
          <source>When QPlainTextEdit is used read-only the key bindings are limited to navigation, and text may only be selected with the mouse:</source>
          <target state="translated">When QPlainTextEdit is used read-only the key bindings are limited to navigation, and text may only be selected with the mouse:</target>
        </trans-unit>
        <trans-unit id="2b3dce7cb91174e257ba7a5b773f5733c0ba5ef8" translate="yes" xml:space="preserve">
          <source>When QRegExpValidator determines whether a string is &lt;a href=&quot;qvalidator#State-enum&quot;&gt;Acceptable&lt;/a&gt; or not, the regexp is treated as if it begins with the start of string assertion (&lt;b&gt;^&lt;/b&gt;) and ends with the end of string assertion (&lt;b&gt;$&lt;/b&gt;); the match is against the entire input string, or from the given position if a start position greater than zero is given.</source>
          <target state="translated">When QRegExpValidator determines whether a string is &lt;a href=&quot;qvalidator#State-enum&quot;&gt;Acceptable&lt;/a&gt; or not, the regexp is treated as if it begins with the start of string assertion (&lt;b&gt;^&lt;/b&gt;) and ends with the end of string assertion (&lt;b&gt;$&lt;/b&gt;); the match is against the entire input string, or from the given position if a start position greater than zero is given.</target>
        </trans-unit>
        <trans-unit id="44b35bfd10db30a7d0a3ac39d2072ec92e99876a" translate="yes" xml:space="preserve">
          <source>When QTextEdit is used read-only the key bindings are limited to navigation, and text may only be selected with the mouse:</source>
          <target state="translated">When QTextEdit is used read-only the key bindings are limited to navigation, and text may only be selected with the mouse:</target>
        </trans-unit>
        <trans-unit id="b100506a7296cf4856e2d55c43642a514b0d282b" translate="yes" xml:space="preserve">
          <source>When QXmlQuery accesses resources (e.g., calling &lt;code&gt;fn:doc()&lt;/code&gt; to load a file, or accessing a device via a bound variable), the event loop is used, which means events will be processed. To avoid processing events when QXmlQuery accesses resources, create your QXmlQuery instance in a separate thread.</source>
          <target state="translated">When QXmlQuery accesses resources (e.g., calling &lt;code&gt;fn:doc()&lt;/code&gt; to load a file, or accessing a device via a bound variable), the event loop is used, which means events will be processed. To avoid processing events when QXmlQuery accesses resources, create your QXmlQuery instance in a separate thread.</target>
        </trans-unit>
        <trans-unit id="228d842e43fc176fb1a2d3aa0180185c47dc88bd" translate="yes" xml:space="preserve">
          <source>When Qt XML Patterns calls &lt;a href=&quot;qabstracturiresolver#resolve&quot;&gt;QAbstractUriResolver::resolve&lt;/a&gt;() the absolute URI is the URI mandated by the &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt; language, and the relative URI is the URI specified by the user.</source>
          <target state="translated">When Qt XML Patterns calls &lt;a href=&quot;qabstracturiresolver#resolve&quot;&gt;QAbstractUriResolver::resolve&lt;/a&gt;() the absolute URI is the URI mandated by the &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt; language, and the relative URI is the URI specified by the user.</target>
        </trans-unit>
        <trans-unit id="e7ad967bec3128bd4f1fd05f2c5749f62466760b" translate="yes" xml:space="preserve">
          <source>When Qt XML Patterns calls &lt;a href=&quot;qabstracturiresolver#resolve&quot;&gt;QAbstractUriResolver::resolve&lt;/a&gt;() the absolute URI is the URI mandated by the &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt; language, and the relative URI is the URI specified by the user.</source>
          <target state="translated">Qt XML 패턴이 &lt;a href=&quot;qabstracturiresolver#resolve&quot;&gt;QAbstractUriResolver :: resolve&lt;/a&gt; ()를 호출 할 때 절대 URI는 &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt; 언어에 의해 지정된 URI이고 상대 URI는 사용자가 지정한 URI입니다.</target>
        </trans-unit>
        <trans-unit id="f47f9cfcc0372f2d7543bfb2e549c724e778aa90" translate="yes" xml:space="preserve">
          <source>When Qt XML Patterns calls &lt;a href=&quot;qabstracturiresolver#resolve&quot;&gt;QAbstractUriResolver::resolve&lt;/a&gt;() the absolute URI is the URI mandated by the schema specification, and the relative URI is the URI specified by the user.</source>
          <target state="translated">Qt XML Patterns가 &lt;a href=&quot;qabstracturiresolver#resolve&quot;&gt;QAbstractUriResolver :: resolve&lt;/a&gt; ()를 호출 할 때 절대 URI는 스키마 스펙에 의해 지정된 URI이고 상대 URI는 사용자가 지정한 URI입니다.</target>
        </trans-unit>
        <trans-unit id="b7e889092d153ecf78cedbfcbcb9a5e6e6e850e1" translate="yes" xml:space="preserve">
          <source>When Qt XML Patterns evaluate path expressions, it emulate them through a combination of calls with &lt;a href=&quot;qabstractxmlnodemodel#SimpleAxis-enum&quot;&gt;QSimpleXmlNodeModel::SimpleAxis&lt;/a&gt; values. Therefore, the implementation of this function must return the node, if any, that appears on the</source>
          <target state="translated">Qt XML 패턴은 경로 표현식을 평가할 때 &lt;a href=&quot;qabstractxmlnodemodel#SimpleAxis-enum&quot;&gt;QSimpleXmlNodeModel :: SimpleAxis&lt;/a&gt; 값 과의 호출 조합을 통해 경로 표현식을 에뮬레이트합니다 . 따라서이 함수를 구현하면 해당 노드에있는 노드가 있으면이를 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="e87346c400d28fb6331382be4402bbe0f7b9fc30" translate="yes" xml:space="preserve">
          <source>When Qt XML Patterns loads an XML resource, e.g., using the &lt;code&gt;fn:doc()&lt;/code&gt; function, the following schemes are supported:</source>
          <target state="translated">Qt XML 패턴이 예를 들어 &lt;code&gt;fn:doc()&lt;/code&gt; 함수를 사용하여 XML 리소스를로드 할 때 다음 체계가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="8d2df247c302bc0aef9cb5b8701b3ccf2c5556f3" translate="yes" xml:space="preserve">
          <source>When Qt XML Patterns loads and queries XML files and produces XML output, it can always load the XML data into its default XML node model, where it can be traversed efficiently. The &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt; below traverses the product orders found in the XML file</source>
          <target state="translated">When Qt XML Patterns loads and queries XML files and produces XML output, it can always load the XML data into its default XML node model, where it can be traversed efficiently. The &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt; below traverses the product orders found in the XML file</target>
        </trans-unit>
        <trans-unit id="fbd1af30e0b1f7879d2e090097ce1ee9bc1b1e77" translate="yes" xml:space="preserve">
          <source>When Qt XML Patterns loads and queries XML files and produces XML output, it can always load the XML data into its default XML node model, where it can be traversed efficiently. The XQuery below traverses the product orders found in the XML file</source>
          <target state="translated">Qt XML 패턴이 XML 파일을로드 및 쿼리하고 XML 출력을 생성하면 항상 XML 데이터를 기본 XML 노드 모델로로드하여 효율적으로 순회 할 수 있습니다. 아래 XQuery는 XML 파일에서 찾은 제품 주문을 순회합니다.</target>
        </trans-unit>
        <trans-unit id="27bec0f91bee9a8e04a2b33675d236e7ab402351" translate="yes" xml:space="preserve">
          <source>When Qt's translation tool, &lt;a href=&quot;https://doc.qt.io/qt-5.13/linguist-manager.html#using-lupdate&quot;&gt;lupdate&lt;/a&gt;, is used to process a set of source files, the text wrapped in tr() calls is stored in a section of the translation file that corresponds to its translation context.</source>
          <target state="translated">Qt의 번역 도구 인 &lt;a href=&quot;https://doc.qt.io/qt-5.13/linguist-manager.html#using-lupdate&quot;&gt;lupdate&lt;/a&gt; 가 소스 파일 세트를 처리하는 데 사용될 때 tr () 호출로 랩핑 된 텍스트는 번역 컨텍스트에 해당하는 번역 파일의 섹션에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="785ca6db3b40442948e6e7e14bdd25ed39799f88" translate="yes" xml:space="preserve">
          <source>When Qt's translation tool, &lt;a href=&quot;https://doc.qt.io/qt-5.15/linguist-manager.html#using-lupdate&quot;&gt;lupdate&lt;/a&gt;, is used to process a set of source files, the text wrapped in tr() calls is stored in a section of the translation file that corresponds to its translation context.</source>
          <target state="translated">When Qt's translation tool, &lt;a href=&quot;https://doc.qt.io/qt-5.15/linguist-manager.html#using-lupdate&quot;&gt;lupdate&lt;/a&gt;, is used to process a set of source files, the text wrapped in tr() calls is stored in a section of the translation file that corresponds to its translation context.</target>
        </trans-unit>
        <trans-unit id="d716f69d72489992d975e006d6741d1a3935bbd6" translate="yes" xml:space="preserve">
          <source>When Qt5 came along, Qt was divided into modules. Since then, many new modules have been added to Qt. As of version 5.5, there are over 40 separate modules in Qt5, each with its own documentation that links to (depends on) the documentation of other Qt modules.</source>
          <target state="translated">Qt5가 등장하자 Qt는 모듈로 나뉘어졌습니다. 그 이후로 많은 새로운 모듈이 Qt에 추가되었습니다. 버전 5.5부터 Qt5에는 40 개가 넘는 개별 모듈이 있으며, 각 모듈에는 다른 Qt 모듈의 문서에 연결되는 문서가 있습니다.</target>
        </trans-unit>
        <trans-unit id="f177dcbb96dea9d408ace28c5d859883092740d9" translate="yes" xml:space="preserve">
          <source>When ScrollBar is attached &lt;a href=&quot;qml-qtquick-controls2-scrollbar#vertical-attached-prop&quot;&gt;vertically&lt;/a&gt; or &lt;a href=&quot;qml-qtquick-controls2-scrollbar#horizontal-attached-prop&quot;&gt;horizontally&lt;/a&gt; to a Flickable, its geometry and the following properties are automatically set and updated as appropriate:</source>
          <target state="translated">When ScrollBar is attached &lt;a href=&quot;qml-qtquick-controls2-scrollbar#vertical-attached-prop&quot;&gt;vertically&lt;/a&gt; or &lt;a href=&quot;qml-qtquick-controls2-scrollbar#horizontal-attached-prop&quot;&gt;horizontally&lt;/a&gt; to a Flickable, its geometry and the following properties are automatically set and updated as appropriate:</target>
        </trans-unit>
        <trans-unit id="709f09eba453dec3aff9d67b6d37f765373bd46f" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qfile&quot;&gt;QFile&lt;/a&gt; is opened using this function, behaviour of &lt;a href=&quot;qfiledevice#close&quot;&gt;close&lt;/a&gt;() is controlled by the &lt;a href=&quot;qfiledevice#FileHandleFlag-enum&quot;&gt;AutoCloseHandle&lt;/a&gt; flag. If &lt;a href=&quot;qfiledevice#FileHandleFlag-enum&quot;&gt;AutoCloseHandle&lt;/a&gt; is specified, and this function succeeds, then calling &lt;a href=&quot;qfiledevice#close&quot;&gt;close&lt;/a&gt;() closes the adopted handle. Otherwise, &lt;a href=&quot;qfiledevice#close&quot;&gt;close&lt;/a&gt;() does not actually close the file, but only flushes it.</source>
          <target state="translated">때 &lt;a href=&quot;qfile&quot;&gt;Qfile을는&lt;/a&gt; 이 함수의 동작하여 개방 &lt;a href=&quot;qfiledevice#close&quot;&gt;가까이&lt;/a&gt; 에 의해 제어되는 () &lt;a href=&quot;qfiledevice#FileHandleFlag-enum&quot;&gt;AutoCloseHandle의&lt;/a&gt; 플래그. 경우 &lt;a href=&quot;qfiledevice#FileHandleFlag-enum&quot;&gt;AutoCloseHandle가&lt;/a&gt; 지정되고,이 기능에 성공, 다음 호출 &lt;a href=&quot;qfiledevice#close&quot;&gt;가까운&lt;/a&gt; () 채택 된 핸들을 닫습니다. 그렇지 않으면 &lt;a href=&quot;qfiledevice#close&quot;&gt;close&lt;/a&gt; ()는 실제로 파일을 닫지 않고 플러시 만합니다.</target>
        </trans-unit>
        <trans-unit id="cb1e3502bc0fff8a5da1c27970f713a4cbcb877b" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; receives Qt mouse, keyboard, and drag and drop events (&lt;a href=&quot;qmouseevent&quot;&gt;QMouseEvent&lt;/a&gt;, &lt;a href=&quot;qkeyevent&quot;&gt;QKeyEvent&lt;/a&gt;, QDragEvent, etc.), it translates them into instances of &lt;a href=&quot;qgraphicssceneevent&quot;&gt;QGraphicsSceneEvent&lt;/a&gt; subclasses and forwards them to the &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; it displays. The scene then forwards the events to the relevant items.</source>
          <target state="translated">때 &lt;a href=&quot;qgraphicsview&quot;&gt;를 QGraphicsView는&lt;/a&gt; Qt는 마우스, 키보드 및 드래그 앤 드롭 이벤트 (수신 &lt;a href=&quot;qmouseevent&quot;&gt;QMouseEvent&lt;/a&gt; , &lt;a href=&quot;qkeyevent&quot;&gt;QKeyEvent&lt;/a&gt; 등 QDragEvent을), 그것은의 인스턴스로 변환 &lt;a href=&quot;qgraphicssceneevent&quot;&gt;QGraphicsSceneEvent의&lt;/a&gt; 서브 클래스와 앞으로 그들에게로 &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; 이 표시됩니다. 그런 다음 장면은 이벤트를 관련 항목으로 전달합니다.</target>
        </trans-unit>
        <trans-unit id="5554f9846d1af01927d9497ed433e3fe74b4e0e1" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; receives Qt mouse, keyboard, and drag and drop events (&lt;a href=&quot;qmouseevent&quot;&gt;QMouseEvent&lt;/a&gt;, &lt;a href=&quot;qkeyevent&quot;&gt;QKeyEvent&lt;/a&gt;, QDragEvent, etc.), it translates them into instances of QGraphicsSceneEvent subclasses and forwards them to the &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; it displays. The scene then forwards the events to the relevant items.</source>
          <target state="translated">When a &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; receives Qt mouse, keyboard, and drag and drop events (&lt;a href=&quot;qmouseevent&quot;&gt;QMouseEvent&lt;/a&gt;, &lt;a href=&quot;qkeyevent&quot;&gt;QKeyEvent&lt;/a&gt;, QDragEvent, etc.), it translates them into instances of QGraphicsSceneEvent subclasses and forwards them to the &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; it displays. The scene then forwards the events to the relevant items.</target>
        </trans-unit>
        <trans-unit id="7ca650c784a62d89aa1bd61df5a5c661ba25f79c" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; receives a &lt;a href=&quot;qevent&quot;&gt;QEvent&lt;/a&gt; of type &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent::ToolTip&lt;/a&gt;, it creates a &lt;a href=&quot;qgraphicsscenehelpevent&quot;&gt;QGraphicsSceneHelpEvent&lt;/a&gt;, which is forwarded to the scene. You can set a tooltip on a &lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt; with &lt;a href=&quot;qgraphicsitem#setToolTip&quot;&gt;setToolTip()&lt;/a&gt;; by default &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; displays the tooltip of the &lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt; with the highest z-value (i.e, the top-most item) under the mouse position.</source>
          <target state="translated">때 &lt;a href=&quot;qgraphicsview&quot;&gt;를 QGraphicsView가&lt;/a&gt; 수신 &lt;a href=&quot;qevent&quot;&gt;QEvent&lt;/a&gt; 형의 &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent : 도구 설명&lt;/a&gt; , 그것은 생성 &lt;a href=&quot;qgraphicsscenehelpevent&quot;&gt;QGraphicsSceneHelpEvent&lt;/a&gt; 현장에 전달됩니다. 당신은에 툴팁 설정할 수 있습니다 &lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt; 와 &lt;a href=&quot;qgraphicsitem#setToolTip&quot;&gt;setToolTip를 ()&lt;/a&gt; ; 기본적으로 &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; 은 마우스 위치 아래에 z 값이 가장 높은 (즉, 최상위 항목) &lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt; 의 툴팁을 표시합니다 .</target>
        </trans-unit>
        <trans-unit id="405906d74ba9d56a4a09585d6f6ec8dd6144ef07" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; receives a &lt;a href=&quot;qevent&quot;&gt;QEvent&lt;/a&gt; of type &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent::ToolTip&lt;/a&gt;, it creates a QGraphicsSceneHelpEvent, which is forwarded to the scene. You can set a tooltip on a &lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt; with &lt;a href=&quot;qgraphicsitem#setToolTip&quot;&gt;setToolTip()&lt;/a&gt;; by default &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; displays the tooltip of the &lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt; with the highest z-value (i.e, the top-most item) under the mouse position.</source>
          <target state="translated">When a &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; receives a &lt;a href=&quot;qevent&quot;&gt;QEvent&lt;/a&gt; of type &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent::ToolTip&lt;/a&gt;, it creates a QGraphicsSceneHelpEvent, which is forwarded to the scene. You can set a tooltip on a &lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt; with &lt;a href=&quot;qgraphicsitem#setToolTip&quot;&gt;setToolTip()&lt;/a&gt;; by default &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; displays the tooltip of the &lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt; with the highest z-value (i.e, the top-most item) under the mouse position.</target>
        </trans-unit>
        <trans-unit id="393e354c9ea9f2a89f579509e189a24bb7a827a0" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; receives a &lt;a href=&quot;qhoverevent&quot;&gt;QHoverEvent&lt;/a&gt; event, it translates it into &lt;a href=&quot;qgraphicsscenehoverevent&quot;&gt;QGraphicsSceneHoverEvent&lt;/a&gt;. The event is then forwarded to the &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; associated with the view.</source>
          <target state="translated">경우 &lt;a href=&quot;qgraphicsview&quot;&gt;를 QGraphicsView가&lt;/a&gt; 수신 &lt;a href=&quot;qhoverevent&quot;&gt;QHoverEvent의&lt;/a&gt; 이벤트, 그것으로 변환 &lt;a href=&quot;qgraphicsscenehoverevent&quot;&gt;QGraphicsSceneHoverEvent&lt;/a&gt; . 그런 다음 이벤트는 보기와 연관된 &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene으로&lt;/a&gt; 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="3ae68b18a5e42b2ce917dd23d94ec19620288dec" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; receives a &lt;a href=&quot;qhoverevent&quot;&gt;QHoverEvent&lt;/a&gt; event, it translates it into QGraphicsSceneHoverEvent. The event is then forwarded to the &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; associated with the view.</source>
          <target state="translated">When a &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; receives a &lt;a href=&quot;qhoverevent&quot;&gt;QHoverEvent&lt;/a&gt; event, it translates it into QGraphicsSceneHoverEvent. The event is then forwarded to the &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; associated with the view.</target>
        </trans-unit>
        <trans-unit id="beba9444d0901cd09b88793cbb92e83a0fb0a4c8" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; receives a &lt;a href=&quot;qmouseevent&quot;&gt;QMouseEvent&lt;/a&gt;, it translates it to a &lt;a href=&quot;qgraphicsscenemouseevent&quot;&gt;QGraphicsSceneMouseEvent&lt;/a&gt;. The event is then forwarded to the &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; associated with the view. If the event is not handled by the scene, the view may use it, e.g., for the &lt;a href=&quot;qgraphicsview#DragMode-enum&quot;&gt;DragMode&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;a href=&quot;qgraphicsview&quot;&gt;를 QGraphicsView가&lt;/a&gt; 수신 &lt;a href=&quot;qmouseevent&quot;&gt;QMouseEvent를&lt;/a&gt; , 그것은로 변환 &lt;a href=&quot;qgraphicsscenemouseevent&quot;&gt;QGraphicsSceneMouseEvent&lt;/a&gt; . 그런 다음 이벤트는 보기와 연관된 &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene으로&lt;/a&gt; 전달됩니다 . 이벤트가 장면에 의해 처리되지 않으면 뷰는 예를 들어 &lt;a href=&quot;qgraphicsview#DragMode-enum&quot;&gt;DragMode 등&lt;/a&gt; 의 이벤트를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0d58e00a0b32556ea464156ee58eaa63878af86f" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; receives a &lt;a href=&quot;qmouseevent&quot;&gt;QMouseEvent&lt;/a&gt;, it translates it to a QGraphicsSceneMouseEvent. The event is then forwarded to the &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; associated with the view. If the event is not handled by the scene, the view may use it, e.g., for the &lt;a href=&quot;qgraphicsview#DragMode-enum&quot;&gt;DragMode&lt;/a&gt;.</source>
          <target state="translated">When a &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; receives a &lt;a href=&quot;qmouseevent&quot;&gt;QMouseEvent&lt;/a&gt;, it translates it to a QGraphicsSceneMouseEvent. The event is then forwarded to the &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; associated with the view. If the event is not handled by the scene, the view may use it, e.g., for the &lt;a href=&quot;qgraphicsview#DragMode-enum&quot;&gt;DragMode&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="b1aa704cf88adf38927fd01a2a14f929a34849e2" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qml-qt3d-render-nodraw&quot;&gt;NoDraw&lt;/a&gt; node is present in a FrameGraph branch, this prevents the renderer from rendering any primitive. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">때 &lt;a href=&quot;qml-qt3d-render-nodraw&quot;&gt;NoDraw의&lt;/a&gt; 노드가 FrameGraph 지점에 존재하는이 방지 모든 프리미티브를 렌더링하는 렌더러에서. &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d712cc482a400f11481ce544723b23f89d2fced9" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; calls &lt;a href=&quot;https://doc.qt.io/qt-5.13/qaccessible-obsolete.html#updateAccessibility&quot;&gt;updateAccessibility()&lt;/a&gt;, clients that are listening to events are notified of the change. The function is used to post events to the assistive technology, and accessible &lt;a href=&quot;qaccessible#Event-enum&quot;&gt;events&lt;/a&gt; are posted by &lt;a href=&quot;https://doc.qt.io/qt-5.13/qaccessible-obsolete.html#updateAccessibility&quot;&gt;updateAccessibility()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 가 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qaccessible-obsolete.html#updateAccessibility&quot;&gt;updateAccessibility ()를&lt;/a&gt; 호출 하면 이벤트를 수신하는 클라이언트에게 변경 사항이 통지됩니다. 이 함수는 보조 기술에 이벤트를 게시하는 데 사용되며 액세스 가능한 &lt;a href=&quot;qaccessible#Event-enum&quot;&gt;이벤트&lt;/a&gt; 는 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qaccessible-obsolete.html#updateAccessibility&quot;&gt;updateAccessibility ()&lt;/a&gt; 에 의해 게시됩니다 .</target>
        </trans-unit>
        <trans-unit id="a44c30b5bf2354f4fd8f996e028fe8735a8ada05" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; calls &lt;a href=&quot;https://doc.qt.io/qt-5.15/qaccessible-obsolete.html#updateAccessibility&quot;&gt;updateAccessibility()&lt;/a&gt;, clients that are listening to events are notified of the change. The function is used to post events to the assistive technology, and accessible &lt;a href=&quot;qaccessible#Event-enum&quot;&gt;events&lt;/a&gt; are posted by &lt;a href=&quot;https://doc.qt.io/qt-5.15/qaccessible-obsolete.html#updateAccessibility&quot;&gt;updateAccessibility()&lt;/a&gt;.</source>
          <target state="translated">When a &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; calls &lt;a href=&quot;https://doc.qt.io/qt-5.15/qaccessible-obsolete.html#updateAccessibility&quot;&gt;updateAccessibility()&lt;/a&gt;, clients that are listening to events are notified of the change. The function is used to post events to the assistive technology, and accessible &lt;a href=&quot;qaccessible#Event-enum&quot;&gt;events&lt;/a&gt; are posted by &lt;a href=&quot;https://doc.qt.io/qt-5.15/qaccessible-obsolete.html#updateAccessibility&quot;&gt;updateAccessibility()&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="bc5c853e12ceaddd145dd8068a3f01709b57c0cc" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; is deleted, it emits this &lt;a href=&quot;qobject#destroyed&quot;&gt;QObject::destroyed&lt;/a&gt;() signal. We want to catch this signal, wherever we might have a dangling reference to the deleted &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;, so we can clean it up. A suitable slot signature might be:</source>
          <target state="translated">때 &lt;a href=&quot;qobject&quot;&gt;QObject를가&lt;/a&gt; 삭제되고,이 방출 &lt;a href=&quot;qobject#destroyed&quot;&gt;QObject를 :: 파괴&lt;/a&gt; () 신호를. 삭제 된 &lt;a href=&quot;qobject&quot;&gt;QObject에&lt;/a&gt; 매달려있는 참조가있을 때마다이 신호를 포착하여 정리할 수 있습니다. 적합한 슬롯 서명은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d5dd864966ee74351524f25c84e86e7278c96ac6" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; is moved to another thread, all its children will be automatically moved too.</source>
          <target state="translated">때 &lt;a href=&quot;qobject&quot;&gt;QObject를이&lt;/a&gt; 다른 스레드로 이동, 모든 아이들은 자동으로 너무 이동합니다.</target>
        </trans-unit>
        <trans-unit id="5954371cae64cc8ee9901844bd7778dc5d52aaf5" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; is passed to the &lt;a href=&quot;qjsengine#newQObject&quot;&gt;QJSEngine::newQObject&lt;/a&gt;() function, a Qt Script wrapper object is created that can be used to make the &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;'s signals, slots, properties, and child objects available to scripts.</source>
          <target state="translated">때 &lt;a href=&quot;qobject&quot;&gt;QObject를가&lt;/a&gt; 받는 전달 &lt;a href=&quot;qjsengine#newQObject&quot;&gt;QJSEngine :: newQObject&lt;/a&gt; () 함수, Qt는 스크립트 객체 랩퍼가이 확인하는 데 사용할 수 있습니다 생성 &lt;a href=&quot;qobject&quot;&gt;QObject를&lt;/a&gt; 의 신호, 슬롯, 속성, 그리고 아이는 스크립트를 사용할 객체.</target>
        </trans-unit>
        <trans-unit id="3af90ba954a525651c11676587fb2037323acba5" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt; instance is deliberately hidden with &lt;a href=&quot;qwindow#hide&quot;&gt;hide&lt;/a&gt;() or &lt;a href=&quot;qwindow#visible-prop&quot;&gt;setVisible&lt;/a&gt;(false), it will stop rendering and its scene graph and graphics context might be released. The &lt;a href=&quot;qquickwindow#sceneGraphInvalidated&quot;&gt;sceneGraphInvalidated&lt;/a&gt;() signal will be emitted when this happens.</source>
          <target state="translated">때 &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow의&lt;/a&gt; 인스턴스가 의도적으로 숨겨 &lt;a href=&quot;qwindow#hide&quot;&gt;숨기기&lt;/a&gt; () 또는 &lt;a href=&quot;qwindow#visible-prop&quot;&gt;는, setVisible&lt;/a&gt; (false)를, 그것은 렌더링을 중지하고 장면 그래프 및 그래픽 컨텍스트가 해제 될 수 있습니다. 이 경우 &lt;a href=&quot;qquickwindow#sceneGraphInvalidated&quot;&gt;sceneGraphInvalidated&lt;/a&gt; () 신호가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5554553d845c524ddee2156401f7cea7ba23f3a7" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qt3drender-qmemorybarrier&quot;&gt;QMemoryBarrier&lt;/a&gt; node is found in a FrameGraph branch, the barrier will be enforced prior to any draw or compute command even if these are defined deeper in the branch.</source>
          <target state="translated">&lt;a href=&quot;qt3drender-qmemorybarrier&quot;&gt;QMemoryBarrier&lt;/a&gt; 노드가 FrameGraph 브랜치에서 발견 되면, 브랜치에서 더 깊이 정의 된 경우에도 그리기 또는 계산 명령 전에 장벽이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="ba17b5ca58006cf8654bdb06b74fa570795c9e22" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qt3drender-qnodraw&quot;&gt;Qt3DRender::QNoDraw&lt;/a&gt; node is present in a FrameGraph branch, this prevents the renderer from rendering any primitive. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">때 &lt;a href=&quot;qt3drender-qnodraw&quot;&gt;Qt3DRender :: QNoDraw의&lt;/a&gt; 노드가 FrameGraph 지점에 존재하는이 방지 모든 프리미티브를 렌더링하는 렌더러에서. &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="548a84d157a52956b642a6c79fa3b16cff4cbb88" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qt3drender-qnodraw&quot;&gt;Qt3DRender::QNoDraw&lt;/a&gt; node is present in a FrameGraph branch, this prevents the renderer from rendering any primitive. &lt;a href=&quot;qt3drender-qnodraw#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">때 &lt;a href=&quot;qt3drender-qnodraw&quot;&gt;Qt3DRender :: QNoDraw의&lt;/a&gt; 노드가 FrameGraph 지점에 존재하는이 방지 모든 프리미티브를 렌더링하는 렌더러에서. &lt;a href=&quot;qt3drender-qnodraw#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3cd19e17aad321610c519687f38dc05666afdeec" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qt3drender-qnopicking&quot;&gt;Qt3DRender::QNoPicking&lt;/a&gt; node is present in a FrameGraph branch, this prevents the render aspect from performing picking selection for the given branch. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">When a &lt;a href=&quot;qt3drender-qnopicking&quot;&gt;Qt3DRender::QNoPicking&lt;/a&gt; node is present in a FrameGraph branch, this prevents the render aspect from performing picking selection for the given branch. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="48029ceeb2e178ce68055405481fb634ea787fe6" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qt3drender-qnopicking&quot;&gt;Qt3DRender::QNoPicking&lt;/a&gt; node is present in a FrameGraph branch, this prevents the render aspect from performing picking selection for the given branch. &lt;a href=&quot;qt3drender-qnopicking#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">When a &lt;a href=&quot;qt3drender-qnopicking&quot;&gt;Qt3DRender::QNoPicking&lt;/a&gt; node is present in a FrameGraph branch, this prevents the render aspect from performing picking selection for the given branch. &lt;a href=&quot;qt3drender-qnopicking#details&quot;&gt;More...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="88153895f9568d781c480af110178d98fc9ac494" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qtoolbar&quot;&gt;QToolBar&lt;/a&gt; is not a child of a &lt;a href=&quot;qmainwindow&quot;&gt;QMainWindow&lt;/a&gt;, it loses the ability to populate the extension pop up with widgets added to the toolbar using &lt;a href=&quot;qtoolbar#addWidget&quot;&gt;addWidget&lt;/a&gt;(). Please use widget actions created by inheriting &lt;a href=&quot;qwidgetaction&quot;&gt;QWidgetAction&lt;/a&gt; and implementing &lt;a href=&quot;qwidgetaction#createWidget&quot;&gt;QWidgetAction::createWidget&lt;/a&gt;() instead.</source>
          <target state="translated">때 &lt;a href=&quot;qtoolbar&quot;&gt;QToolBar이&lt;/a&gt; 의 아이가 아닌 &lt;a href=&quot;qmainwindow&quot;&gt;QMainWindow&lt;/a&gt; , 그것은 확장 사용하여 도구 모음에 추가 위젯 팝업 채울 수있는 능력 상실 &lt;a href=&quot;qtoolbar#addWidget&quot;&gt;개의 addWidget을&lt;/a&gt; (). &lt;a href=&quot;qwidgetaction&quot;&gt;QWidgetAction&lt;/a&gt; 을 상속 하고 대신 &lt;a href=&quot;qwidgetaction#createWidget&quot;&gt;QWidgetAction :: createWidget&lt;/a&gt; ()을 구현 하여 작성된 위젯 조치를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="ea339d196247f8a4535ab539b791214e5503ae1d" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qwizardpage#subTitle-prop&quot;&gt;subTitle&lt;/a&gt; is set, &lt;a href=&quot;qwizard&quot;&gt;QWizard&lt;/a&gt; displays it in a header, in which case it also uses the &lt;a href=&quot;qwizard#WizardPixmap-enum&quot;&gt;BannerPixmap&lt;/a&gt; and the &lt;a href=&quot;qwizard#WizardPixmap-enum&quot;&gt;LogoPixmap&lt;/a&gt; to decorate the header. The &lt;a href=&quot;qwizard#WizardPixmap-enum&quot;&gt;WatermarkPixmap&lt;/a&gt; is displayed on the left side, below the header. At the bottom, there is a row of buttons allowing the user to navigate through the pages.</source>
          <target state="translated">때 &lt;a href=&quot;qwizardpage#subTitle-prop&quot;&gt;자막이&lt;/a&gt; 설정된다 &lt;a href=&quot;qwizard&quot;&gt;QWizard의&lt;/a&gt; 그것도 사용하는 경우의 헤더에 표시를하여 &lt;a href=&quot;qwizard#WizardPixmap-enum&quot;&gt;BannerPixmap&lt;/a&gt; 및 &lt;a href=&quot;qwizard#WizardPixmap-enum&quot;&gt;LogoPixmap를&lt;/a&gt; 헤더 장식. &lt;a href=&quot;qwizard#WizardPixmap-enum&quot;&gt;WatermarkPixmap는&lt;/a&gt; 헤더 아래 왼쪽에 표시된다. 맨 아래에는 사용자가 페이지를 탐색 할 수있는 일련의 단추가 있습니다.</target>
        </trans-unit>
        <trans-unit id="399d5e73a4a8b06dd36c1720633609c913f08193" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qwizardpage#subTitle-prop&quot;&gt;subTitle&lt;/a&gt; is set, QWizard displays it in a header, in which case it also uses the &lt;a href=&quot;qwizard#WizardPixmap-enum&quot;&gt;BannerPixmap&lt;/a&gt; and the &lt;a href=&quot;qwizard#WizardPixmap-enum&quot;&gt;LogoPixmap&lt;/a&gt; to decorate the header. The &lt;a href=&quot;qwizard#WizardPixmap-enum&quot;&gt;WatermarkPixmap&lt;/a&gt; is displayed on the left side, below the header. At the bottom, there is a row of buttons allowing the user to navigate through the pages.</source>
          <target state="translated">When a &lt;a href=&quot;qwizardpage#subTitle-prop&quot;&gt;subTitle&lt;/a&gt; is set, QWizard displays it in a header, in which case it also uses the &lt;a href=&quot;qwizard#WizardPixmap-enum&quot;&gt;BannerPixmap&lt;/a&gt; and the &lt;a href=&quot;qwizard#WizardPixmap-enum&quot;&gt;LogoPixmap&lt;/a&gt; to decorate the header. The &lt;a href=&quot;qwizard#WizardPixmap-enum&quot;&gt;WatermarkPixmap&lt;/a&gt; is displayed on the left side, below the header. At the bottom, there is a row of buttons allowing the user to navigate through the pages.</target>
        </trans-unit>
        <trans-unit id="7322771e8958658ead503160124f934fb65197f8" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;&amp;lt;content&amp;gt;&lt;/code&gt; element is used, the data will contain a single item with either the value of the</source>
          <target state="translated">때 &lt;code&gt;&amp;lt;content&amp;gt;&lt;/code&gt; 요소가 사용되며, 데이터는 하나의 값과 하나의 항목을 포함</target>
        </trans-unit>
        <trans-unit id="2672663ccea1c72ceff571e1774f7c56bc159e61" translate="yes" xml:space="preserve">
          <source>When a D-Bus function returns a D-Bus variant, it can be retrieved as follows:</source>
          <target state="translated">D-Bus 함수가 D-Bus 변형을 반환하면 다음과 같이 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1017702957d7db1428d00195f1759c2c2ce9ca31" translate="yes" xml:space="preserve">
          <source>When a JavaScript file is imported this way, it is imported with a qualifier. The functions in that file are then accessible from the importing script via the qualifier (that is, as &lt;code&gt;Qualifier.functionName(params)&lt;/code&gt;).</source>
          <target state="translated">이 방법으로 JavaScript 파일을 가져 오면 한정자를 사용하여 가져옵니다. 그런 다음 규정자를 통해 가져 오기 스크립트에서 해당 파일의 함수에 액세스 할 수 있습니다 (즉, &lt;code&gt;Qualifier.functionName(params)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="8955c961f4e03b5b4c423d7e27242490dcc367cd" translate="yes" xml:space="preserve">
          <source>When a NoDraw node is present in a FrameGraph branch, this prevents the renderer from rendering any primitive. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">When a NoDraw node is present in a FrameGraph branch, this prevents the renderer from rendering any primitive. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9346322a98372696210b54e5c6837cb02553ab5b" translate="yes" xml:space="preserve">
          <source>When a NoPicking node is present in a FrameGraph branch, this prevents the render aspect from performing picking selection for the given branch. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">When a NoPicking node is present in a FrameGraph branch, this prevents the render aspect from performing picking selection for the given branch. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b5239011b0ce80a40d0520fced8dbad82a40aa0a" translate="yes" xml:space="preserve">
          <source>When a Plugin object is created, it is &quot;detached&quot; and not associated with any actual service plugin. Once it has received information via setting its &lt;a href=&quot;qml-qtlocation-plugin#name-prop&quot;&gt;name&lt;/a&gt;, &lt;a href=&quot;qml-qtlocation-plugin#preferred-prop&quot;&gt;preferred&lt;/a&gt;, or &lt;a href=&quot;qml-qtlocation-plugin#required-prop&quot;&gt;required&lt;/a&gt; properties, it will choose an appropriate service plugin to attach to. Plugin objects can only be attached once; to use multiple plugins, create multiple Plugin objects.</source>
          <target state="translated">플러그인 오브젝트가 작성되면 &quot;분리&quot;되며 실제 서비스 플러그인과 연관되지 않습니다. &lt;a href=&quot;qml-qtlocation-plugin#name-prop&quot;&gt;name&lt;/a&gt; , &lt;a href=&quot;qml-qtlocation-plugin#preferred-prop&quot;&gt;preferred&lt;/a&gt; 또는 &lt;a href=&quot;qml-qtlocation-plugin#required-prop&quot;&gt;required&lt;/a&gt; 특성 을 설정하여 정보를 수신 하면 첨부 할 적절한 서비스 플러그인을 선택합니다. 플러그인 객체는 한 번만 첨부 할 수 있습니다. 여러 플러그인을 사용하려면 여러 플러그인 오브젝트를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="b6f220e6e802d62e7eddcb10a35ca79f2887d75d" translate="yes" xml:space="preserve">
          <source>When a QML &lt;a href=&quot;qml-qtquick-item&quot;&gt;Item&lt;/a&gt; explicitly relinquishes focus (by setting its &lt;code&gt;focus&lt;/code&gt; property to &lt;code&gt;false&lt;/code&gt; while it has active focus), the system does not automatically select another type to receive focus. That is, it is possible for there to be no currently active focus.</source>
          <target state="translated">QML &lt;a href=&quot;qml-qtquick-item&quot;&gt;항목&lt;/a&gt; 이 &lt;code&gt;focus&lt;/code&gt; 를 활성 상태 인 동안 포커스 속성을 &lt;code&gt;false&lt;/code&gt; 로 설정하여 포커스를 명시 적으로 포기 하면 시스템은 포커스를받을 다른 유형을 자동으로 선택하지 않습니다. 즉, 현재 활성화 된 초점이 없을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7001a12de2df6c574e67e9da9ad3f2fc320aad4f" translate="yes" xml:space="preserve">
          <source>When a QML object type is used as a signal parameter, the parameter should use &lt;a href=&quot;qml-var&quot;&gt;var&lt;/a&gt; as the type, and the value should be received in C++ using the &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; type:</source>
          <target state="translated">QML 오브젝트 유형이 신호 매개 변수로 사용되는 경우 매개 변수는 &lt;a href=&quot;qml-var&quot;&gt;var&lt;/a&gt; 를 유형으로 사용 하고 값은 &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; 유형을 사용하여 C ++로 수신해야합니다 .</target>
        </trans-unit>
        <trans-unit id="15f000278e72ce7b8d6c307887252da7193e1ede" translate="yes" xml:space="preserve">
          <source>When a QMemoryBarrier node is found in a FrameGraph branch, the barrier will be enforced prior to any draw or compute command even if these are defined deeper in the branch.</source>
          <target state="translated">QMemoryBarrier 노드가 FrameGraph 브랜치에서 발견되면, 브랜치에서 더 깊이 정의 된 경우에도 그리기 또는 계산 명령 전에 장벽이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="d860d62ecdfb8b15dcaa97f6730ceece19277c00" translate="yes" xml:space="preserve">
          <source>When a QObject is moved to another thread, all its children will be automatically moved too.</source>
          <target state="translated">When a QObject is moved to another thread, all its children will be automatically moved too.</target>
        </trans-unit>
        <trans-unit id="9bcadc0cb5a7c58faa28e7459e38798e9f6a2b6b" translate="yes" xml:space="preserve">
          <source>When a QQuickWindow instance is deliberately hidden with &lt;a href=&quot;qwindow#hide&quot;&gt;hide&lt;/a&gt;() or &lt;a href=&quot;qwindow#visible-prop&quot;&gt;setVisible&lt;/a&gt;(false), it will stop rendering and its scene graph and graphics context might be released. The &lt;a href=&quot;qquickwindow#sceneGraphInvalidated&quot;&gt;sceneGraphInvalidated&lt;/a&gt;() signal will be emitted when this happens.</source>
          <target state="translated">When a QQuickWindow instance is deliberately hidden with &lt;a href=&quot;qwindow#hide&quot;&gt;hide&lt;/a&gt;() or &lt;a href=&quot;qwindow#visible-prop&quot;&gt;setVisible&lt;/a&gt;(false), it will stop rendering and its scene graph and graphics context might be released. The &lt;a href=&quot;qquickwindow#sceneGraphInvalidated&quot;&gt;sceneGraphInvalidated&lt;/a&gt;() signal will be emitted when this happens.</target>
        </trans-unit>
        <trans-unit id="fc28ed271581b3aeebbcb657c64d87496cc2b2e9" translate="yes" xml:space="preserve">
          <source>When a QToolBar is not a child of a &lt;a href=&quot;qmainwindow&quot;&gt;QMainWindow&lt;/a&gt;, it loses the ability to populate the extension pop up with widgets added to the toolbar using &lt;a href=&quot;qtoolbar#addWidget&quot;&gt;addWidget&lt;/a&gt;(). Please use widget actions created by inheriting &lt;a href=&quot;qwidgetaction&quot;&gt;QWidgetAction&lt;/a&gt; and implementing &lt;a href=&quot;qwidgetaction#createWidget&quot;&gt;QWidgetAction::createWidget&lt;/a&gt;() instead.</source>
          <target state="translated">When a QToolBar is not a child of a &lt;a href=&quot;qmainwindow&quot;&gt;QMainWindow&lt;/a&gt;, it loses the ability to populate the extension pop up with widgets added to the toolbar using &lt;a href=&quot;qtoolbar#addWidget&quot;&gt;addWidget&lt;/a&gt;(). Please use widget actions created by inheriting &lt;a href=&quot;qwidgetaction&quot;&gt;QWidgetAction&lt;/a&gt; and implementing &lt;a href=&quot;qwidgetaction#createWidget&quot;&gt;QWidgetAction::createWidget&lt;/a&gt;() instead.</target>
        </trans-unit>
        <trans-unit id="f8aa88cb70cc32f83b8553c1a39321db3fc1b25e" translate="yes" xml:space="preserve">
          <source>When a Qt3DRender::QNoDraw node is present in a FrameGraph branch, this prevents the renderer from rendering any primitive</source>
          <target state="translated">Qt3DRender :: QNoDraw 노드가 FrameGraph 브랜치에 있으면 렌더러가 프리미티브를 렌더링하지 못합니다</target>
        </trans-unit>
        <trans-unit id="7f62ed373c0ee65b35bdb2fc2d57ef6032e4e244" translate="yes" xml:space="preserve">
          <source>When a Qt3DRender::QNoPicking node is present in a FrameGraph branch, this prevents the render aspect from performing picking selection for the given branch</source>
          <target state="translated">When a Qt3DRender::QNoPicking node is present in a FrameGraph branch, this prevents the render aspect from performing picking selection for the given branch</target>
        </trans-unit>
        <trans-unit id="40263f24ec17a09841c1926737df4393300f3b67" translate="yes" xml:space="preserve">
          <source>When a button is clicked in the button box, the &lt;a href=&quot;qdialogbuttonbox#clicked&quot;&gt;clicked&lt;/a&gt;() signal is emitted for the actual button is that is pressed. For convenience, if the button has an &lt;a href=&quot;qdialogbuttonbox#ButtonRole-enum&quot;&gt;AcceptRole&lt;/a&gt;, &lt;a href=&quot;qdialogbuttonbox#ButtonRole-enum&quot;&gt;RejectRole&lt;/a&gt;, or &lt;a href=&quot;qdialogbuttonbox#ButtonRole-enum&quot;&gt;HelpRole&lt;/a&gt;, the &lt;a href=&quot;qdialogbuttonbox#accepted&quot;&gt;accepted&lt;/a&gt;(), &lt;a href=&quot;qdialogbuttonbox#rejected&quot;&gt;rejected&lt;/a&gt;(), or &lt;a href=&quot;qdialogbuttonbox#helpRequested&quot;&gt;helpRequested&lt;/a&gt;() signals are emitted respectively.</source>
          <target state="translated">버튼 상자에서 버튼을 클릭하면 실제 버튼에 대한 &lt;a href=&quot;qdialogbuttonbox#clicked&quot;&gt;클릭 된&lt;/a&gt; () 신호가 출력됩니다. 편의상 버튼에 &lt;a href=&quot;qdialogbuttonbox#ButtonRole-enum&quot;&gt;AcceptRole&lt;/a&gt; , &lt;a href=&quot;qdialogbuttonbox#ButtonRole-enum&quot;&gt;RejectRole&lt;/a&gt; 또는 &lt;a href=&quot;qdialogbuttonbox#ButtonRole-enum&quot;&gt;HelpRole&lt;/a&gt; 이있는 경우 &lt;a href=&quot;qdialogbuttonbox#accepted&quot;&gt;accept&lt;/a&gt; (), &lt;a href=&quot;qdialogbuttonbox#rejected&quot;&gt;rejected&lt;/a&gt; () 또는 &lt;a href=&quot;qdialogbuttonbox#helpRequested&quot;&gt;helpRequested&lt;/a&gt; () 신호가 각각 방출됩니다.</target>
        </trans-unit>
        <trans-unit id="3391d8c7ccaaea73a623e4d861dba6f56e546160" translate="yes" xml:space="preserve">
          <source>When a button is clicked in the button box, the &lt;a href=&quot;qml-qtquick-controls2-dialogbuttonbox#clicked-signal&quot;&gt;clicked()&lt;/a&gt; signal is emitted for the actual button that is pressed. In addition, the following signals are automatically emitted when a button with the respective role(s) is pressed:</source>
          <target state="translated">버튼 상자에서 버튼을 클릭하면 누른 실제 버튼에 대해 &lt;a href=&quot;qml-qtquick-controls2-dialogbuttonbox#clicked-signal&quot;&gt;clicked ()&lt;/a&gt; 신호가 발생합니다. 또한 각 역할이있는 버튼을 누르면 다음 신호가 자동으로 방출됩니다.</target>
        </trans-unit>
        <trans-unit id="06c02f6a9dbac4345d72fdb9bb347db0a2b3bcdc" translate="yes" xml:space="preserve">
          <source>When a category is removed, the &lt;a href=&quot;qplacemanager&quot;&gt;QPlaceManager&lt;/a&gt; may emit the &lt;a href=&quot;qplacemanager#categoryRemoved&quot;&gt;QPlaceManager::categoryRemoved&lt;/a&gt;() signal. Whether a manager does so is provider specific. Managers accessing places from a web service will typically not emit these signals, while managers accessing places stored locally generally will.</source>
          <target state="translated">카테고리가 제거되면 &lt;a href=&quot;qplacemanager&quot;&gt;QPlaceManager&lt;/a&gt; 가 &lt;a href=&quot;qplacemanager#categoryRemoved&quot;&gt;QPlaceManager :: categoryRemoved&lt;/a&gt; () 신호를 방출 할 수 있습니다 . 관리자가 그렇게하는지 여부는 공급자마다 다릅니다. 웹 서비스에서 장소에 액세스하는 관리자는 일반적으로 이러한 신호를 내 보내지 않지만 로컬에 저장된 장소에 액세스하는 관리자는 일반적으로 신호를 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="2153d9fed3f02a16b6a6ca1c21681db29241b851" translate="yes" xml:space="preserve">
          <source>When a category is saved, the &lt;a href=&quot;qplacemanager&quot;&gt;QPlaceManager&lt;/a&gt; may emit &lt;a href=&quot;qplacemanager#categoryAdded&quot;&gt;QPlaceManager::categoryAdded&lt;/a&gt;() or &lt;a href=&quot;qplacemanager#categoryUpdated&quot;&gt;QPlaceManager::categoryUpdated&lt;/a&gt;() signals. However whether a manager does so or not is provider specific, managers accessing places from a web service will typically not emit these signals while managers accessing places locally stored generally will.</source>
          <target state="translated">카테고리가 저장되면 &lt;a href=&quot;qplacemanager&quot;&gt;QPlaceManager&lt;/a&gt; 가 &lt;a href=&quot;qplacemanager#categoryAdded&quot;&gt;QPlaceManager :: categoryAdded&lt;/a&gt; () 또는 &lt;a href=&quot;qplacemanager#categoryUpdated&quot;&gt;QPlaceManager :: categoryUpdated&lt;/a&gt; () 신호를 방출 할 수 있습니다 . 그러나, 관리자가 제공하는지 여부는 공급자마다 다르지만, 웹 서비스에서 장소에 액세스하는 관리자는 일반적으로 이러한 신호를 방출하지 않지만 일반적으로 로컬에 저장된 장소에 액세스하는 관리자는 신호를 방출하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="74e1cabc1808cac1af0ca6415a34d8121f46bf6d" translate="yes" xml:space="preserve">
          <source>When a certain configuration is requested explicitly, no checks are done at application startup, that is, the system-provided opengl32.dll will not be examined.</source>
          <target state="translated">When a certain configuration is requested explicitly, no checks are done at application startup, that is, the system-provided opengl32.dll will not be examined.</target>
        </trans-unit>
        <trans-unit id="0d7ef2995bb1b9278679a4db6eb4f1c8a80df088" translate="yes" xml:space="preserve">
          <source>When a child layout object is selected, its parent layout object can be selected by pressing down the &lt;b&gt;Shift&lt;/b&gt; key while clicking on it. This makes it possible to select a specific layout in a hierarchy, which is otherwise difficult due to the small frame.</source>
          <target state="translated">자식 레이아웃 개체를 선택한 경우 &lt;b&gt;Shift&lt;/b&gt; 키를 누른 채로 클릭하면 부모 레이아웃 개체를 선택할 수 있습니다 . 따라서 계층 구조에서 특정 레이아웃을 선택할 수 있습니다. 그렇지 않으면 작은 프레임으로 인해 어려워집니다.</target>
        </trans-unit>
        <trans-unit id="4d44facce222efbda291b9b00896c00605e23c4d" translate="yes" xml:space="preserve">
          <source>When a class is marked &lt;a href=&quot;#reentrant-command&quot;&gt;\reentrant&lt;/a&gt; or &lt;a href=&quot;#threadsafe-command&quot;&gt;\threadsafe&lt;/a&gt;, functions in that class can be marked &lt;code&gt;nonreentrant&lt;/code&gt; using the &lt;a href=&quot;#nonreentrant-command&quot;&gt;\nonreentrant&lt;/a&gt; command.</source>
          <target state="translated">클래스가 &lt;a href=&quot;#reentrant-command&quot;&gt;\ reentrant&lt;/a&gt; 또는 &lt;a href=&quot;#threadsafe-command&quot;&gt;\ threadsafe&lt;/a&gt; 로 표시 되면 &lt;a href=&quot;#nonreentrant-command&quot;&gt;\ nonreentrant&lt;/a&gt; 명령을 사용하여 해당 클래스의 함수를 &lt;code&gt;nonreentrant&lt;/code&gt; 으로 표시 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0630e10d812ca6a44e69948c6fbb1d3fde2d9e6c" translate="yes" xml:space="preserve">
          <source>When a class is marked &lt;a href=&quot;#reentrant-command&quot;&gt;\reentrant&lt;/a&gt; or &lt;a href=&quot;#threadsafe-command&quot;&gt;\threadsafe&lt;/a&gt;, functions in that class can be marked &lt;code&gt;nonreentrant&lt;/code&gt; using this command in the &lt;a href=&quot;https://doc.qt.io/qt-5.13/13-qdoc-commands-topics.html#fn-command&quot;&gt;\fn&lt;/a&gt; comment of the functions to be excluded.</source>
          <target state="translated">클래스가 &lt;a href=&quot;#reentrant-command&quot;&gt;\ reentrant&lt;/a&gt; 또는 &lt;a href=&quot;#threadsafe-command&quot;&gt;\ threadsafe&lt;/a&gt; 로 표시 되면 제외 할 함수 의 &lt;a href=&quot;https://doc.qt.io/qt-5.13/13-qdoc-commands-topics.html#fn-command&quot;&gt;\ fn&lt;/a&gt; 주석 에서이 명령을 사용하여 해당 클래스의 함수를 &lt;code&gt;nonreentrant&lt;/code&gt; 것으로 표시 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2cd634a18329e27eaf5d023e852ce4e96a7d4f77" translate="yes" xml:space="preserve">
          <source>When a class is marked &lt;a href=&quot;17-qdoc-commands-thread#reentrant-command&quot;&gt;\reentrant&lt;/a&gt; or &lt;a href=&quot;17-qdoc-commands-thread#threadsafe-command&quot;&gt;\threadsafe&lt;/a&gt;, functions in that class can be marked &lt;code&gt;nonreentrant&lt;/code&gt; using the &lt;a href=&quot;17-qdoc-commands-thread#nonreentrant-command&quot;&gt;\nonreentrant&lt;/a&gt; command.</source>
          <target state="translated">When a class is marked &lt;a href=&quot;17-qdoc-commands-thread#reentrant-command&quot;&gt;\reentrant&lt;/a&gt; or &lt;a href=&quot;17-qdoc-commands-thread#threadsafe-command&quot;&gt;\threadsafe&lt;/a&gt;, functions in that class can be marked &lt;code&gt;nonreentrant&lt;/code&gt; using the &lt;a href=&quot;17-qdoc-commands-thread#nonreentrant-command&quot;&gt;\nonreentrant&lt;/a&gt; command.</target>
        </trans-unit>
        <trans-unit id="c7d7a9372711646e9a74f31e8f75f68b4197251e" translate="yes" xml:space="preserve">
          <source>When a class is marked &lt;a href=&quot;17-qdoc-commands-thread#reentrant-command&quot;&gt;\reentrant&lt;/a&gt; or &lt;a href=&quot;17-qdoc-commands-thread#threadsafe-command&quot;&gt;\threadsafe&lt;/a&gt;, functions in that class can be marked &lt;code&gt;nonreentrant&lt;/code&gt; using this command in the &lt;a href=&quot;https://doc.qt.io/qt-5.15/13-qdoc-commands-topics.html#fn-command&quot;&gt;\fn&lt;/a&gt; comment of the functions to be excluded.</source>
          <target state="translated">When a class is marked &lt;a href=&quot;17-qdoc-commands-thread#reentrant-command&quot;&gt;\reentrant&lt;/a&gt; or &lt;a href=&quot;17-qdoc-commands-thread#threadsafe-command&quot;&gt;\threadsafe&lt;/a&gt;, functions in that class can be marked &lt;code&gt;nonreentrant&lt;/code&gt; using this command in the &lt;a href=&quot;https://doc.qt.io/qt-5.15/13-qdoc-commands-topics.html#fn-command&quot;&gt;\fn&lt;/a&gt; comment of the functions to be excluded.</target>
        </trans-unit>
        <trans-unit id="cb8493d30c9e50739fc7b9788b39ac10cc03ca43" translate="yes" xml:space="preserve">
          <source>When a composition mode is set it applies to all painting operator, pens, brushes, gradients and pixmap/image drawing.</source>
          <target state="translated">컴포지션 모드가 설정되면 모든 페인팅 연산자, 펜, 브러쉬, 그라디언트 및 픽스맵 / 이미지 드로잉에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="38b6f0bc81c40f221944d8b87c8853be0ed28449" translate="yes" xml:space="preserve">
          <source>When a container extension is required,</source>
          <target state="translated">컨테이너 확장이 필요한 경우</target>
        </trans-unit>
        <trans-unit id="0e4a24a47776590b3614eff94072d51c15c8244d" translate="yes" xml:space="preserve">
          <source>When a custom valueBar is defined, its &lt;a href=&quot;qml-qtquick-item#implicitWidth-prop&quot;&gt;implicitWidth&lt;/a&gt; property must be set.</source>
          <target state="translated">사용자 정의 valueBar가 정의되면 &lt;a href=&quot;qml-qtquick-item#implicitWidth-prop&quot;&gt;implicitWidth&lt;/a&gt; 속성을 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="6c4b40a6fbd23b160b7fe00aefbf0818b8bf8785" translate="yes" xml:space="preserve">
          <source>When a data stream operates on an asynchronous device, the chunks of data can arrive at arbitrary points in time. The &lt;a href=&quot;qdatastream&quot;&gt;QDataStream&lt;/a&gt; class implements a transaction mechanism that provides the ability to read the data atomically with a series of stream operators. As an example, you can handle incomplete reads from a socket by using a transaction in a slot connected to the readyRead() signal:</source>
          <target state="translated">데이터 스트림이 비동기 장치에서 작동하면 데이터 청크가 임의의 시점에 도달 할 수 있습니다. &lt;a href=&quot;qdatastream&quot;&gt;QDataStream의&lt;/a&gt; 클래스가 구현하는 스트림 사업자의 일련의 원자 적 데이터를 읽을 수있는 기능을 제공하는 거래 메커니즘. 예를 들어 readyRead () 신호에 연결된 슬롯에서 트랜잭션을 사용하여 소켓에서 불완전한 읽기를 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="2309abfd6e3825de006d2babd2f4bdd6e5bf7873" translate="yes" xml:space="preserve">
          <source>When a data stream operates on an asynchronous device, the chunks of data can arrive at arbitrary points in time. The QDataStream class implements a transaction mechanism that provides the ability to read the data atomically with a series of stream operators. As an example, you can handle incomplete reads from a socket by using a transaction in a slot connected to the readyRead() signal:</source>
          <target state="translated">When a data stream operates on an asynchronous device, the chunks of data can arrive at arbitrary points in time. The QDataStream class implements a transaction mechanism that provides the ability to read the data atomically with a series of stream operators. As an example, you can handle incomplete reads from a socket by using a transaction in a slot connected to the readyRead() signal:</target>
        </trans-unit>
        <trans-unit id="2b820cde4dc4a7341cb53aee76f1d46245199229" translate="yes" xml:space="preserve">
          <source>When a delay is set, the event will be queued for delivery after the timeout has passed. The state machine takes ownership of</source>
          <target state="translated">지연이 설정되면 시간 초과가 지나면 이벤트가 배달 대기 상태가됩니다. 상태 머신은</target>
        </trans-unit>
        <trans-unit id="23bd60283b08b2b77caeefa53fd2bdd658b2b566" translate="yes" xml:space="preserve">
          <source>When a delay is set, the event will be queued for delivery after the timeout has passed. The state machine takes ownership of the event and deletes it after processing.</source>
          <target state="translated">지연이 설정되면 시간 초과가 지나면 이벤트가 배달 대기 상태가됩니다. 상태 머신은 이벤트의 소유권을 가져 와서 처리 후 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="d09fa2d377e5a85c50e883812625f0a7a5fde3e3" translate="yes" xml:space="preserve">
          <source>When a dock widget or tool bar is dragged over the main window, the main window adjusts its contents to indicate where the dock widget or tool bar will be docked if it is dropped. Setting this property causes &lt;a href=&quot;qmainwindow&quot;&gt;QMainWindow&lt;/a&gt; to move its contents in a smooth animation. Clearing this property causes the contents to snap into their new positions.</source>
          <target state="translated">도크 위젯 또는 도구 모음을 기본 창 위로 끌면 기본 창은 도크 위젯 또는 도구 모음을 떨어 뜨린 경우 도킹 될 위치를 표시하도록 컨텐츠를 조정합니다. 이 속성을 설정하면 &lt;a href=&quot;qmainwindow&quot;&gt;QMainWindow&lt;/a&gt; 가 내용을 부드러운 애니메이션으로 이동시킵니다. 이 속성을 지우면 내용이 새 위치로 스냅됩니다.</target>
        </trans-unit>
        <trans-unit id="da9490d3c1f9946041e7eb1512b2be2ffa63a1b3" translate="yes" xml:space="preserve">
          <source>When a drag and drop operation is performed over a view, the underlying model is queried to determine which types of operation it supports and the MIME types it can accept. This information is provided by the &lt;a href=&quot;qabstractitemmodel#supportedDropActions&quot;&gt;QAbstractItemModel::supportedDropActions&lt;/a&gt;() and &lt;a href=&quot;qabstractitemmodel#mimeTypes&quot;&gt;QAbstractItemModel::mimeTypes&lt;/a&gt;() functions. Models that do not override the implementations provided by &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; support copy operations and the default internal MIME type for items.</source>
          <target state="translated">보기에 대해 끌어서 놓기 작업을 수행하면 기본 모델이 쿼리되어 지원하는 작업 유형과 허용 가능한 MIME 유형을 결정합니다. 이 정보는 &lt;a href=&quot;qabstractitemmodel#supportedDropActions&quot;&gt;QAbstractItemModel :: supportedDropActions&lt;/a&gt; () 및 &lt;a href=&quot;qabstractitemmodel#mimeTypes&quot;&gt;QAbstractItemModel :: mimeTypes&lt;/a&gt; () 함수에 의해 제공됩니다 . &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel에서&lt;/a&gt; 제공하는 구현을 대체하지 않는 모델은 복사 조작 및 항목의 기본 내부 MIME 유형을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="e9b8c9681d5d37404723c8f5a9ebfc9d97539a77" translate="yes" xml:space="preserve">
          <source>When a drag is &lt;a href=&quot;qml-qtquick-drag#active-attached-prop&quot;&gt;active&lt;/a&gt; on an item, any change in that item's position will generate a drag event that will be sent to any &lt;a href=&quot;qml-qtquick-droparea&quot;&gt;DropArea&lt;/a&gt; that intersects with the new position of the item. Other items which implement drag and drop event handlers can also receive these events.</source>
          <target state="translated">항목에서 끌기가 &lt;a href=&quot;qml-qtquick-drag#active-attached-prop&quot;&gt;활성화&lt;/a&gt; 되면 해당 항목의 위치가 변경되면 항목의 새 위치와 교차 하는 &lt;a href=&quot;qml-qtquick-droparea&quot;&gt;DropArea&lt;/a&gt; 로 전송되는 끌기 이벤트가 생성됩니다 . 끌어서 놓기 이벤트 핸들러를 구현하는 다른 항목도 이러한 이벤트를 수신 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c95a54f3a1918c06f2cbe85cf290554fb693d8ac" translate="yes" xml:space="preserve">
          <source>When a drag is not active this property holds the object that accepted the drop event that ended the drag, if no object accepted the drop or the drag was canceled the target will then be null.</source>
          <target state="translated">드래그가 활성화되어 있지 않으면이 속성은 드래그를 종료 한 드롭 이벤트를 수락 한 객체를 유지합니다. 객체가 드롭을 수락하지 않았거나 드래그가 취소 된 경우 대상은 null입니다.</target>
        </trans-unit>
        <trans-unit id="8dd9d07c03937978798b7bb1627270a6ea3c810d" translate="yes" xml:space="preserve">
          <source>When a drop occurs elsewhere in the view, and the row number is unusable, we append items to the top level of the model.</source>
          <target state="translated">뷰의 다른 곳에서 드롭이 발생하고 행 번호를 사용할 수없는 경우 모델의 최상위 레벨에 항목을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="f51c41bb148e0dd3152b4f6f3f9915d8028fe189" translate="yes" xml:space="preserve">
          <source>When a drop occurs in the widget, the dropEvent() handler function is called, and we can deal with each possible action in turn. First, we deal with drag and drop operations within the same widget:</source>
          <target state="translated">위젯에서 드롭이 발생하면 dropEvent () 핸들러 함수가 호출되고 가능한 각 조치를 차례로 처리 할 수 ​​있습니다. 먼저 동일한 위젯 내에서 끌어서 놓기 작업을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="b42ee2ab5c63e4e31745c7c35ebc8cf0bcf255bd" translate="yes" xml:space="preserve">
          <source>When a drop occurs, the model index corresponding to the parent item will either be valid, indicating that the drop occurred on an item, or it will be invalid, indicating that the drop occurred somewhere in the view that corresponds to top level of the model.</source>
          <target state="translated">삭제가 발생하면 상위 항목에 해당하는 모델 색인이 유효하여 항목에서 삭제가 발생했음을 표시하거나 유효하지 않아 모델의 최상위 레벨에 해당하는보기에서 삭제가 발생했음을 표시합니다. .</target>
        </trans-unit>
        <trans-unit id="fa514711ce33d2215ed2e3d6a6f7e5ed0189a13b" translate="yes" xml:space="preserve">
          <source>When a focus scope receives active focus, the contained type with &lt;code&gt;focus&lt;/code&gt; set (if any) also gets the active focus. If this type is also a &lt;a href=&quot;qml-qtquick-focusscope&quot;&gt;FocusScope&lt;/a&gt;, the proxying behavior continues. Both the focus scope and the sub-focused item will have the &lt;code&gt;activeFocus&lt;/code&gt; property set.</source>
          <target state="translated">포커스 범위가 활성 포커스를 받으면 &lt;code&gt;focus&lt;/code&gt; 설정된 포함 된 유형 (있는 경우)도 활성 포커스를 얻습니다. 이 유형이 &lt;a href=&quot;qml-qtquick-focusscope&quot;&gt;FocusScope&lt;/a&gt; 인 경우 프록시 동작이 계속됩니다. 초점 범위와 하위 초점 항목 모두 &lt;code&gt;activeFocus&lt;/code&gt; 속성이 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="9e613a8bc60ebbcd1e9e0949919a88ee9070005d" translate="yes" xml:space="preserve">
          <source>When a formatter is attached to a value axis, the axis range cannot include negative values or the zero.</source>
          <target state="translated">포맷터가 값 축에 연결된 경우 축 범위는 음수 값 또는 0을 포함 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6f6b92c6c88b8efb6145fe6bc4f3bfc2d29e118a" translate="yes" xml:space="preserve">
          <source>When a gesture is canceled, the &lt;a href=&quot;qgesturerecognizer#reset&quot;&gt;reset&lt;/a&gt;() function is called, giving the recognizer the chance to update the appropriate properties in the corresponding &lt;a href=&quot;qgesture&quot;&gt;QGesture&lt;/a&gt; object.</source>
          <target state="translated">제스처가 취소되면 &lt;a href=&quot;qgesturerecognizer#reset&quot;&gt;reset&lt;/a&gt; () 함수가 호출되어 인식자가 해당 &lt;a href=&quot;qgesture&quot;&gt;QGesture&lt;/a&gt; 객체 의 적절한 속성을 업데이트 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="428d7789009cbf1fc7ea52cad52f4379b3aabfc7" translate="yes" xml:space="preserve">
          <source>When a highlighted item is activated, the popup is closed, &lt;a href=&quot;qml-qtquick-controls2-combobox#currentIndex-prop&quot;&gt;currentIndex&lt;/a&gt; is set to &lt;code&gt;highlightedIndex&lt;/code&gt;, and the value of this property is reset to &lt;code&gt;-1&lt;/code&gt;, as there is no longer a highlighted item.</source>
          <target state="translated">강조 표시된 항목이 활성화되면 팝업이 닫히고 &lt;a href=&quot;qml-qtquick-controls2-combobox#currentIndex-prop&quot;&gt;currentIndex&lt;/a&gt; 가 &lt;code&gt;highlightedIndex&lt;/code&gt; 로 설정되고 더 이상 강조 표시된 항목 이 없으므로이 속성 값이 &lt;code&gt;-1&lt;/code&gt; 로 재설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="4eebccda1013bfd9e4d9b4103626dd2994ae925f" translate="yes" xml:space="preserve">
          <source>When a key is pressed or released, a key event is generated and delivered to the focused Qt Quick &lt;a href=&quot;qml-qtquick-item&quot;&gt;Item&lt;/a&gt;. To facilitate the construction of reusable components and to address some of the cases unique to fluid user interfaces, the Qt Quick items add a scope based extension to Qt's traditional keyboard focus model.</source>
          <target state="translated">키를 누르거나 놓으면 키 이벤트가 생성되어 포커스 된 Qt Quick &lt;a href=&quot;qml-qtquick-item&quot;&gt;Item에&lt;/a&gt; 전달됩니다 . 재사용 가능한 컴포넌트의 구성을 용이하게하고 유동적 인 사용자 인터페이스 고유의 일부 사례를 처리하기 위해 Qt Quick 항목은 Qt의 기존 키보드 포커스 모델에 범위 기반 확장을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="5280aa5c73ecda9d4fb3b4f001bfc13d6e4c77a0" translate="yes" xml:space="preserve">
          <source>When a key sequence is being typed at the keyboard, it is said to be ambiguous as long as it matches the start of more than one shortcut.</source>
          <target state="translated">키보드에서 키 시퀀스를 입력 할 때 하나 이상의 단축키 시작과 일치하는 한 모호하다고합니다.</target>
        </trans-unit>
        <trans-unit id="332bb39a2cb3399af84efd51d32cde06e1b10d08" translate="yes" xml:space="preserve">
          <source>When a language/country pair is specified in the constructor, one of three things can happen:</source>
          <target state="translated">생성자에서 언어 / 국가 쌍을 지정하면 다음 세 가지 중 하나가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c010514fe89fada083c82bb7ef5814f38b6c278" translate="yes" xml:space="preserve">
          <source>When a layout is resized, items may grow or shrink. Due to this, items have a &lt;a href=&quot;qml-qtquick-layouts-layout#minimumWidth-attached-prop&quot;&gt;minimum size&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-layouts-layout#preferredWidth-attached-prop&quot;&gt;preferred size&lt;/a&gt; and a &lt;a href=&quot;qml-qtquick-layouts-layout#maximumWidth-attached-prop&quot;&gt;maximum size&lt;/a&gt;.</source>
          <target state="translated">레이아웃 크기를 조정하면 항목이 커지거나 줄어들 수 있습니다. 이로 인해 항목의 &lt;a href=&quot;qml-qtquick-layouts-layout#minimumWidth-attached-prop&quot;&gt;최소 크기&lt;/a&gt; , &lt;a href=&quot;qml-qtquick-layouts-layout#preferredWidth-attached-prop&quot;&gt;기본 크기&lt;/a&gt; 및 &lt;a href=&quot;qml-qtquick-layouts-layout#maximumWidth-attached-prop&quot;&gt;최대 크기가 다릅니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2aaeb9d71f67c32d894e19f355e445af1f673900" translate="yes" xml:space="preserve">
          <source>When a low-level graphics API is in use, the scenegraph will make sure there is a CPU-side wait for the GPU to complete all work submitted to the scenegraph's graphics command queue before the scenegraph's nodes are deleted. Therefore there is no need to issue additional waits here, unless the &lt;a href=&quot;qsgrendernode#render&quot;&gt;render&lt;/a&gt;() implementation is using additional command queues.</source>
          <target state="translated">저수준 그래픽 API를 사용하는 경우 장면 그래프는 장면 그래프의 노드가 삭제되기 전에 GPU가 장면 그래프의 그래픽 명령 대기열에 제출 된 모든 작업을 완료 할 때까지 CPU 측 대기 시간이 있는지 확인합니다. 따라서 &lt;a href=&quot;qsgrendernode#render&quot;&gt;render&lt;/a&gt; () 구현이 추가 명령 큐를 사용 하지 않는 한 여기에서 추가 대기를 발행 할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="c845af89f01e419749914b45895c1bb235d5ce01" translate="yes" xml:space="preserve">
          <source>When a menu is torn off a second menu is shown to display the menu contents in a new window. When the menu is in this mode and the menu is visible returns &lt;code&gt;true&lt;/code&gt;; otherwise false.</source>
          <target state="translated">메뉴가 해제되면 메뉴 내용이 새 창에 표시되는 두 번째 메뉴가 표시됩니다. 메뉴가이 모드에 있고 메뉴가 표시되면 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 . 그렇지 않으면 거짓.</target>
        </trans-unit>
        <trans-unit id="728dd6daea54bbbc47c1c0afd43ec24383ab26a3" translate="yes" xml:space="preserve">
          <source>When a model is reset it means that any previous data reported from the model is now invalid and has to be queried for again. This also means that the current item and any selected items will become invalid.</source>
          <target state="translated">모델이 재설정되면 모델에서보고 된 이전 데이터가 이제 유효하지 않으며 다시 쿼리해야 함을 의미합니다. 또한 현재 항목과 선택한 항목이 유효하지 않게됩니다.</target>
        </trans-unit>
        <trans-unit id="5f301e5dc3d747cffb379d30922ea2160d2c0277" translate="yes" xml:space="preserve">
          <source>When a model radically changes its data it can sometimes be easier to just call this function rather than emit &lt;a href=&quot;qabstractitemmodel#dataChanged&quot;&gt;dataChanged&lt;/a&gt;() to inform other components when the underlying data source, or its structure, has changed.</source>
          <target state="translated">모델이 데이터를 근본적으로 변경하는 경우 기본 데이터 소스 또는 구조가 변경되었을 때 다른 구성 요소에 알리기 위해 &lt;a href=&quot;qabstractitemmodel#dataChanged&quot;&gt;dataChanged&lt;/a&gt; ()를 내보내는 대신이 함수를 호출하는 것이 더 쉬운 경우가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="798d38793d411f71af72b3a052c51c022e51937d" translate="yes" xml:space="preserve">
          <source>When a module name is used as the</source>
          <target state="translated">모듈 이름이</target>
        </trans-unit>
        <trans-unit id="c8bb4a36e1cc58b9d2f69c2e0e1701bc5743d489" translate="yes" xml:space="preserve">
          <source>When a new &lt;a href=&quot;q3dcamera&quot;&gt;Q3DCamera&lt;/a&gt; object is set, it is automatically added as child of the scene.</source>
          <target state="translated">새로운 &lt;a href=&quot;q3dcamera&quot;&gt;Q3DCamera&lt;/a&gt; 객체가 설정되면 장면의 자식으로 자동 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="8b455ee9f46ef6792f12c0936577f332d927c927" translate="yes" xml:space="preserve">
          <source>When a new &lt;a href=&quot;q3dlight&quot;&gt;Q3DLight&lt;/a&gt; objects is set, it is automatically added as child of the scene.</source>
          <target state="translated">새로운 &lt;a href=&quot;q3dlight&quot;&gt;Q3DLight&lt;/a&gt; 객체가 설정되면 장면의 자식으로 자동 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="92c136ff15dc3f6e6eb98af265af4b77642b9592" translate="yes" xml:space="preserve">
          <source>When a new column is flicked into view, &lt;a href=&quot;qml-qtquick-tableview&quot;&gt;TableView&lt;/a&gt; will determine its width by calling the &lt;a href=&quot;qml-qtquick-tableview#columnWidthProvider-prop&quot;&gt;columnWidthProvider&lt;/a&gt; function. &lt;a href=&quot;qml-qtquick-tableview&quot;&gt;TableView&lt;/a&gt; itself will never store row height or column width, as it's designed to support large models containing any number of rows and columns. Instead, it will ask the application whenever it needs to know.</source>
          <target state="translated">새 열을 뷰로 &lt;a href=&quot;qml-qtquick-tableview&quot;&gt;넘기면 TableView&lt;/a&gt; 는 &lt;a href=&quot;qml-qtquick-tableview#columnWidthProvider-prop&quot;&gt;columnWidthProvider&lt;/a&gt; 함수 를 호출하여 너비를 결정 합니다. &lt;a href=&quot;qml-qtquick-tableview&quot;&gt;TableView&lt;/a&gt; 자체는 행 높이 또는 열 너비를 저장하지 않습니다. 행과 열을 포함하는 큰 모델을 지원하도록 설계 되었기 때문입니다. 대신, 필요할 때마다 응용 프로그램에 요청합니다.</target>
        </trans-unit>
        <trans-unit id="bd3977fd3b9d0fff4ce92833839e9fd254909e52" translate="yes" xml:space="preserve">
          <source>When a new column is flicked into view, TableView will determine its width by calling the &lt;a href=&quot;qml-qtquick-tableview#columnWidthProvider-prop&quot;&gt;columnWidthProvider&lt;/a&gt; function. TableView does not store row height or column width, as it's designed to support large models containing any number of rows and columns. Instead, it will ask the application whenever it needs to know.</source>
          <target state="translated">When a new column is flicked into view, TableView will determine its width by calling the &lt;a href=&quot;qml-qtquick-tableview#columnWidthProvider-prop&quot;&gt;columnWidthProvider&lt;/a&gt; function. TableView does not store row height or column width, as it's designed to support large models containing any number of rows and columns. Instead, it will ask the application whenever it needs to know.</target>
        </trans-unit>
        <trans-unit id="be74d7e819d89ccb9b1b730a61146409cce1e842" translate="yes" xml:space="preserve">
          <source>When a new connection is received, the client &lt;a href=&quot;qwebsocket&quot;&gt;QWebSocket&lt;/a&gt; is retrieved (`nextPendingConnection()`), and the signals we are interested in are connected to our slots (`textMessageReceived()`, `binaryMessageReceived()` and `disconnected()`). The client socket is remembered in a list, in case we would like to use it later (in this example, nothing is done with it).</source>
          <target state="translated">새로운 연결이 수신되면 클라이언트 &lt;a href=&quot;qwebsocket&quot;&gt;QWebSocket&lt;/a&gt; 이 검색되고 (`nextPendingConnection ()`) 관심있는 신호가 슬롯 (`textMessageReceived ()`,`binaryMessageReceived ()`및`disconnected ()`에 연결됩니다. ). 클라이언트 소켓은 나중에 사용하려는 경우를 위해 목록에 기억됩니다 (이 예에서는 아무 것도 수행되지 않음).</target>
        </trans-unit>
        <trans-unit id="bda773011b553996318d1ca0425ceb0218190f09" translate="yes" xml:space="preserve">
          <source>When a new group is pushed onto the debug groups stack, it will inherit the configuration of the group that was previously on the top of the stack. Vice versa, popping a debug group will restore the configuration of the debug group that becomes the new top.</source>
          <target state="translated">새 그룹을 디버그 그룹 스택으로 푸시하면 이전에 스택 맨 위에 있던 그룹의 구성이 상속됩니다. 반대로 디버그 그룹을 팝업하면 새로운 최상위가되는 디버그 그룹의 구성이 복원됩니다.</target>
        </trans-unit>
        <trans-unit id="ec32af560002a3f2954d27992ea538e7e19a3001" translate="yes" xml:space="preserve">
          <source>When a node acquires a replica for a known source, it sends a request for that source to the host node. Upon receipt of this request, the host will create a reply packet with the current values of all properties of the source. If the requested replica is dynamic, it will include the API definition for the source. The replica's node will be included in the list of connections that receive changes to that source from then on.</source>
          <target state="translated">노드는 알려진 소스의 복제본을 획득하면 해당 소스에 대한 요청을 호스트 노드로 보냅니다. 이 요청을 수신하면 호스트는 소스의 모든 속성에 대한 현재 값으로 응답 패킷을 만듭니다. 요청 된 복제본이 동적 인 경우 소스에 대한 API 정의가 포함됩니다. 복제본의 노드는 그때부터 해당 소스에 대한 변경 사항을 수신하는 연결 목록에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="2f9bbe722b869b83db0e2263dc70c8abde11f7e3" translate="yes" xml:space="preserve">
          <source>When a node acquires a replica for a known source, it sends a request for that source to the host node. Upon receiving this request, the host creates a reply packet with the current values for all properties of that source. If the requested replica is &lt;a href=&quot;qremoteobjectdynamicreplica&quot;&gt;dynamic&lt;/a&gt;, the reply packet includes the API definition for the source. From then on, the replica's node will be included in the list of connections that receive changes to that source.</source>
          <target state="translated">When a node acquires a replica for a known source, it sends a request for that source to the host node. Upon receiving this request, the host creates a reply packet with the current values for all properties of that source. If the requested replica is &lt;a href=&quot;qremoteobjectdynamicreplica&quot;&gt;dynamic&lt;/a&gt;, the reply packet includes the API definition for the source. From then on, the replica's node will be included in the list of connections that receive changes to that source.</target>
        </trans-unit>
        <trans-unit id="d63ba8e6603b8cbc973323b39127ee0bc0ad55ba" translate="yes" xml:space="preserve">
          <source>When a page is about to be shown, &lt;a href=&quot;qwizard&quot;&gt;QWizard&lt;/a&gt; calls &lt;a href=&quot;qwizard#initializePage&quot;&gt;initializePage&lt;/a&gt;() (which in turn calls &lt;a href=&quot;qwizardpage#initializePage&quot;&gt;QWizardPage::initializePage&lt;/a&gt;()) to fill the page with default values. By default, this function does nothing, but it can be reimplemented to initialize the page's contents based on other pages' fields (see the &lt;a href=&quot;qwizard#initialize-page&quot;&gt;example above&lt;/a&gt;).</source>
          <target state="translated">페이지가 표시하려고 할 때, &lt;a href=&quot;qwizard&quot;&gt;QWizard는&lt;/a&gt; 호출 &lt;a href=&quot;qwizard#initializePage&quot;&gt;initializePage&lt;/a&gt; () (차례로 호출하는 &lt;a href=&quot;qwizardpage#initializePage&quot;&gt;QWizardPage :: initializePage가&lt;/a&gt; 기본 값으로 페이지를 채우기 위해 ()). 기본적으로이 함수는 아무 작업도 수행하지 않지만 다른 페이지의 필드를 기반으로 페이지의 내용을 초기화하도록 다시 구현할 수 있습니다 (&lt;a href=&quot;qwizard#initialize-page&quot;&gt; 위 예 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="52b8a1c2a004bc4ae73bcc37ab97f637d0e15877" translate="yes" xml:space="preserve">
          <source>When a page is about to be shown, QWizard calls &lt;a href=&quot;qwizard#initializePage&quot;&gt;initializePage&lt;/a&gt;() (which in turn calls &lt;a href=&quot;qwizardpage#initializePage&quot;&gt;QWizardPage::initializePage&lt;/a&gt;()) to fill the page with default values. By default, this function does nothing, but it can be reimplemented to initialize the page's contents based on other pages' fields (see the &lt;a href=&quot;qwizard#initialize-page&quot;&gt;example above&lt;/a&gt;).</source>
          <target state="translated">When a page is about to be shown, QWizard calls &lt;a href=&quot;qwizard#initializePage&quot;&gt;initializePage&lt;/a&gt;() (which in turn calls &lt;a href=&quot;qwizardpage#initializePage&quot;&gt;QWizardPage::initializePage&lt;/a&gt;()) to fill the page with default values. By default, this function does nothing, but it can be reimplemented to initialize the page's contents based on other pages' fields (see the &lt;a href=&quot;qwizard#initialize-page&quot;&gt;example above&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="c63e8b4686c2ce6ea480da0dde82d96ac157403d" translate="yes" xml:space="preserve">
          <source>When a parallel state group is entered, all its child states will be simultaneously entered. Transitions within the individual child states operate normally. However, any of the child states may take a transition which exits the parent state. When this happens, the parent state and all of its child states are exited.</source>
          <target state="translated">병렬 상태 그룹이 입력되면 모든 하위 상태가 동시에 입력됩니다. 개별 하위 상태 내에서의 전환은 정상적으로 작동합니다. 그러나 모든 하위 상태는 상위 상태를 종료하는 전환을 수행 할 수 있습니다. 이 경우 상위 상태 및 모든 하위 상태가 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="f1b2b5f7aefbb0cb0ec4ae4792cb7356d5cdee30" translate="yes" xml:space="preserve">
          <source>When a partial match is found, no captured substrings are returned, and the (implicit) capturing group 0 corresponding to the whole match captures the partially matched substring of the subject string.</source>
          <target state="translated">부분 일치가 발견되면 캡처 된 하위 문자열이 리턴되지 않고 전체 일치에 해당하는 (암시 적) 캡처 그룹 0이 주제 문자열의 부분 일치 하위 문자열을 캡처합니다.</target>
        </trans-unit>
        <trans-unit id="949ea8688bbfcd915778d80bb9ad32883794d483" translate="yes" xml:space="preserve">
          <source>When a pinch gesture is started, the rotation is &lt;code&gt;0.0&lt;/code&gt;.</source>
          <target state="translated">핀치 제스처가 시작되면 회전은 &lt;code&gt;0.0&lt;/code&gt; 입니다 입니다.</target>
        </trans-unit>
        <trans-unit id="6eeed75e83f5493322e8f521ba32040bf1a5bd87" translate="yes" xml:space="preserve">
          <source>When a pinch gesture is started, the scale is &lt;code&gt;1.0&lt;/code&gt;.</source>
          <target state="translated">핀치 제스처가 시작되면 배율은 &lt;code&gt;1.0&lt;/code&gt; 입니다. 입니다.</target>
        </trans-unit>
        <trans-unit id="3947f323d774ee42a9f53aab29ffa36c8280798a" translate="yes" xml:space="preserve">
          <source>When a pixmap is inserted and the cache is about to exceed its limit, it removes pixmaps until there is enough room for the pixmap to be inserted.</source>
          <target state="translated">픽스맵이 삽입되고 캐시가 한계를 초과하려고하면 픽스맵을 삽입 할 공간이 충분해질 때까지 픽스맵을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="14e43d5273a0f220d3f6cca0d60985a5d4b8fc21" translate="yes" xml:space="preserve">
          <source>When a place is removed, the &lt;a href=&quot;qplacemanager&quot;&gt;QPlaceManager&lt;/a&gt; may emit the &lt;a href=&quot;qplacemanager#placeRemoved&quot;&gt;QPlaceManager::placeRemoved&lt;/a&gt;() signal. Whether a manager does so is provider specific. Managers accessing places from a web service will typically not emit these signals, while managers accessing places stored locally generally will.</source>
          <target state="translated">장소가 제거되면 &lt;a href=&quot;qplacemanager&quot;&gt;QPlaceManager&lt;/a&gt; 가 &lt;a href=&quot;qplacemanager#placeRemoved&quot;&gt;QPlaceManager :: placeRemoved를&lt;/a&gt; 방출 할 수 있습니다. () 신호를 . 관리자가 그렇게하는지 여부는 공급자마다 다릅니다. 웹 서비스에서 장소에 액세스하는 관리자는 일반적으로 이러한 신호를 내 보내지 않지만 로컬에 저장된 장소에 액세스하는 관리자는 일반적으로 신호를 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="955b392e62b44331ff658695f8bca3787dde24b9" translate="yes" xml:space="preserve">
          <source>When a place is saved, the &lt;a href=&quot;qplacemanager&quot;&gt;QPlaceManager&lt;/a&gt; may emit QPlaceManager::placedAdded() or &lt;a href=&quot;qplacemanager#placeUpdated&quot;&gt;QPlaceManager::placeUpdated&lt;/a&gt;() signals. However whether a manager does so or not is provider specific, managers accessing places from a web service will typically not emit these signals while managers accessing places locally stored generally will.</source>
          <target state="translated">장소가 저장되면 &lt;a href=&quot;qplacemanager&quot;&gt;QPlaceManager&lt;/a&gt; 가 QPlaceManager :: placedAdded () 또는 &lt;a href=&quot;qplacemanager#placeUpdated&quot;&gt;QPlaceManager :: placeUpdated&lt;/a&gt; () 신호를 방출 할 수 있습니다 . 그러나, 관리자가 제공하는지 여부는 공급자별로 다르지만, 웹 서비스에서 장소에 액세스하는 관리자는 일반적으로 이러한 신호를 방출하지 않지만 일반적으로 로컬에 저장된 장소에 액세스하는 관리자는 신호를 방출하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bb76ccab6b6330b8216b91871b1f1a7518967e70" translate="yes" xml:space="preserve">
          <source>When a preprocessor symbol is specified using the &lt;code&gt;defines&lt;/code&gt; variable, you can also use the &lt;a href=&quot;12-0-qdoc-commands-miscellaneous#if-command&quot;&gt;\if&lt;/a&gt; command to enclose documentation that only will be included if the preprocessor symbol is defined.</source>
          <target state="translated">&lt;code&gt;defines&lt;/code&gt; 변수를 사용하여 전 처리기 기호를 지정 하면 &lt;a href=&quot;12-0-qdoc-commands-miscellaneous#if-command&quot;&gt;\ if&lt;/a&gt; 명령을 사용 하여 전 처리기 기호가 정의 된 경우에만 포함되는 설명서를 묶을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f785beae5730b83f41acbcf90ef75b7556aac2f1" translate="yes" xml:space="preserve">
          <source>When a press event occurs, each instance of &lt;a href=&quot;qml-qtquick-pointhandler&quot;&gt;PointHandler&lt;/a&gt; chooses a single point which is not yet &quot;taken&quot; at that moment: if the press occurs within the bounds of the &lt;a href=&quot;qml-qtquick-pointhandler#parent-prop&quot;&gt;PointerHandler::parent&lt;/a&gt;, and no sibling &lt;a href=&quot;qml-qtquick-pointhandler&quot;&gt;PointHandler&lt;/a&gt; within the same &lt;a href=&quot;qml-qtquick-pointhandler#parent-prop&quot;&gt;PointerHandler::parent&lt;/a&gt; has yet acquired a passive grab on that point, and if the other constraints such as &lt;a href=&quot;qml-qtquick-pointhandler#acceptedButtons-prop&quot;&gt;acceptedButtons&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-pointhandler#acceptedDevices-prop&quot;&gt;acceptedDevices&lt;/a&gt; etc. are satisfied, it's eligible, and the &lt;a href=&quot;qml-qtquick-pointhandler&quot;&gt;PointHandler&lt;/a&gt; then acquires a passive grab. In this way, the &lt;a href=&quot;qml-qtquick-pointhandler#parent-prop&quot;&gt;PointerHandler::parent&lt;/a&gt; acts like an exclusive group: there can be multiple instances of &lt;a href=&quot;qml-qtquick-pointhandler&quot;&gt;PointHandler&lt;/a&gt;, and the set of pressed touchpoints will be distributed among them. Each &lt;a href=&quot;qml-qtquick-pointhandler&quot;&gt;PointHandler&lt;/a&gt; which has chosen a point to track has its &lt;a href=&quot;stylesheet-reference#active&quot;&gt;active&lt;/a&gt; property &lt;code&gt;true&lt;/code&gt;. It then continues to track its chosen point until release: the properties of the &lt;a href=&quot;qml-point&quot;&gt;point&lt;/a&gt; will be kept up-to-date. Any Item can bind to these properties, and thereby follow the point's movements.</source>
          <target state="translated">프레스 이벤트가 발생하면 &lt;a href=&quot;qml-qtquick-pointhandler&quot;&gt;PointHandler의&lt;/a&gt; 각 인스턴스는 해당 시점에 아직 &quot;취득되지 않은&quot;단일 포인트를 선택합니다. 프레스가 &lt;a href=&quot;qml-qtquick-pointhandler#parent-prop&quot;&gt;PointerHandler :: parent&lt;/a&gt; 범위 내에서 발생 하고 동일한 &lt;a href=&quot;qml-qtquick-pointhandler#parent-prop&quot;&gt;PointerHandler :: parent&lt;/a&gt; 내에 형제 &lt;a href=&quot;qml-qtquick-pointhandler&quot;&gt;PointHandler가&lt;/a&gt; 없는 경우 그러나이 시점에서 수동 손잡이를 취득하고, 같은 경우, 다른 제약있다 &lt;a href=&quot;qml-qtquick-pointhandler#acceptedButtons-prop&quot;&gt;acceptedButtons&lt;/a&gt; , &lt;a href=&quot;qml-qtquick-pointhandler#acceptedDevices-prop&quot;&gt;acceptedDevices&lt;/a&gt; 등이 충족되고, 그것의 자격과 &lt;a href=&quot;qml-qtquick-pointhandler&quot;&gt;PointHandler는&lt;/a&gt; 다음 수동 손잡이를 취득한다. 이러한 방법으로, &lt;a href=&quot;qml-qtquick-pointhandler#parent-prop&quot;&gt;PointerHandler :: 부모는&lt;/a&gt; 독점 그룹 같은 역할 :의 여러 인스턴스가있을 수 &lt;a href=&quot;qml-qtquick-pointhandler&quot;&gt;PointHandler&lt;/a&gt;을 누르면 일련의 눌린 터치 포인트가 그 사이에 분배됩니다. 추적 할 지점을 선택한 각 &lt;a href=&quot;qml-qtquick-pointhandler&quot;&gt;PointHandler&lt;/a&gt; 의 &lt;a href=&quot;stylesheet-reference#active&quot;&gt;활성&lt;/a&gt; 속성은 &lt;code&gt;true&lt;/code&gt; 입니다. 그런 다음 릴리스 때까지 선택 점을 계속 추적 :의 특성 &lt;a href=&quot;qml-point&quot;&gt;포인트가&lt;/a&gt; 최신 상태로 유지됩니다. 모든 아이템은 이러한 속성에 바인딩되어 포인트의 움직임을 따를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="10016a67871d70f0506ab0f762c8c06369cdb0ed" translate="yes" xml:space="preserve">
          <source>When a press event occurs, each instance of PointHandler chooses a single point which is not yet &quot;taken&quot; at that moment: if the press occurs within the bounds of the &lt;a href=&quot;qml-qtquick-pointhandler#parent-prop&quot;&gt;PointerHandler::parent&lt;/a&gt;, and no sibling PointHandler within the same &lt;a href=&quot;qml-qtquick-pointhandler#parent-prop&quot;&gt;PointerHandler::parent&lt;/a&gt; has yet acquired a passive grab on that point, and if the other constraints such as &lt;a href=&quot;qml-qtquick-pointhandler#acceptedButtons-prop&quot;&gt;acceptedButtons&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-pointhandler#acceptedDevices-prop&quot;&gt;acceptedDevices&lt;/a&gt; etc. are satisfied, it's eligible, and the PointHandler then acquires a passive grab. In this way, the &lt;a href=&quot;qml-qtquick-pointhandler#parent-prop&quot;&gt;PointerHandler::parent&lt;/a&gt; acts like an exclusive group: there can be multiple instances of PointHandler, and the set of pressed touchpoints will be distributed among them. Each PointHandler which has chosen a point to track has its &lt;a href=&quot;stylesheet-reference#active&quot;&gt;active&lt;/a&gt; property &lt;code&gt;true&lt;/code&gt;. It then continues to track its chosen point until release: the properties of the &lt;a href=&quot;qml-point&quot;&gt;point&lt;/a&gt; will be kept up-to-date. Any Item can bind to these properties, and thereby follow the point's movements.</source>
          <target state="translated">When a press event occurs, each instance of PointHandler chooses a single point which is not yet &quot;taken&quot; at that moment: if the press occurs within the bounds of the &lt;a href=&quot;qml-qtquick-pointhandler#parent-prop&quot;&gt;PointerHandler::parent&lt;/a&gt;, and no sibling PointHandler within the same &lt;a href=&quot;qml-qtquick-pointhandler#parent-prop&quot;&gt;PointerHandler::parent&lt;/a&gt; has yet acquired a passive grab on that point, and if the other constraints such as &lt;a href=&quot;qml-qtquick-pointhandler#acceptedButtons-prop&quot;&gt;acceptedButtons&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-pointhandler#acceptedDevices-prop&quot;&gt;acceptedDevices&lt;/a&gt; etc. are satisfied, it's eligible, and the PointHandler then acquires a passive grab. In this way, the &lt;a href=&quot;qml-qtquick-pointhandler#parent-prop&quot;&gt;PointerHandler::parent&lt;/a&gt; acts like an exclusive group: there can be multiple instances of PointHandler, and the set of pressed touchpoints will be distributed among them. Each PointHandler which has chosen a point to track has its &lt;a href=&quot;stylesheet-reference#active&quot;&gt;active&lt;/a&gt; property &lt;code&gt;true&lt;/code&gt; . It then continues to track its chosen point until release: the properties of the &lt;a href=&quot;qml-point&quot;&gt;point&lt;/a&gt; will be kept up-to-date. Any Item can bind to these properties, and thereby follow the point's movements.</target>
        </trans-unit>
        <trans-unit id="cfbfb0ebbd6646025b981fa339de3293519a353e" translate="yes" xml:space="preserve">
          <source>When a print request is accepted, the printer status would change, triggering a change in the status property. This would then be reported to all Replicas.</source>
          <target state="translated">인쇄 요청이 수락되면 프린터 상태가 변경되어 상태 속성이 변경됩니다. 그런 다음 모든 복제본에보고됩니다.</target>
        </trans-unit>
        <trans-unit id="666537301706b87af8a406d9ea46793d0d017481" translate="yes" xml:space="preserve">
          <source>When a process using &lt;a href=&quot;qsystemsemaphore&quot;&gt;QSystemSemaphore&lt;/a&gt; terminates for any reason, Unix automatically reverses the effect of all acquire operations that were not released. Thus if the process acquires a resource and then exits without releasing it, Unix will release that resource.</source>
          <target state="translated">어떤 이유로 든 &lt;a href=&quot;qsystemsemaphore&quot;&gt;QSystemSemaphore를&lt;/a&gt; 사용하는 프로세스가 종료되면 Unix는 릴리스되지 않은 모든 획득 작업의 효과를 자동으로 되돌립니다. 따라서 프로세스가 자원을 확보 한 후 해제하지 않고 종료하면 Unix는 해당 자원을 해제합니다.</target>
        </trans-unit>
        <trans-unit id="df1a65bbb3d9b167018ca0c5cdabe5195c1a5eea" translate="yes" xml:space="preserve">
          <source>When a process using QSystemSemaphore terminates for any reason, Unix automatically reverses the effect of all acquire operations that were not released. Thus if the process acquires a resource and then exits without releasing it, Unix will release that resource.</source>
          <target state="translated">When a process using QSystemSemaphore terminates for any reason, Unix automatically reverses the effect of all acquire operations that were not released. Thus if the process acquires a resource and then exits without releasing it, Unix will release that resource.</target>
        </trans-unit>
        <trans-unit id="3fb2e9f6ef5f613c87a38c8fd666c38c8b51fe6f" translate="yes" xml:space="preserve">
          <source>When a property sheet extension is required,</source>
          <target state="translated">속성 시트 확장이 필요한 경우</target>
        </trans-unit>
        <trans-unit id="a0431b9169541b5942ac50072a09a56ca2303178" translate="yes" xml:space="preserve">
          <source>When a property value source object is assigned to a property, QML first tries to assign it normally, as though it were a regular QML type. Only if this assignment fails does the engine call the &lt;a href=&quot;qqmlpropertyvaluesource#setTarget&quot;&gt;setTarget()&lt;/a&gt; method. This allows the type to also be used in contexts other than just as a value source.</source>
          <target state="translated">특성 값 소스 오브젝트가 특성에 지정되면 QML은 먼저 일반 QML 유형 인 것처럼 정상적으로 지정하려고합니다. 이 지정이 실패한 경우에만 엔진이 &lt;a href=&quot;qqmlpropertyvaluesource#setTarget&quot;&gt;setTarget ()&lt;/a&gt; 메소드를 호출합니다 . 따라서 유형을 값 소스가 아닌 다른 컨텍스트에서도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c0c5db3829a8327c7d24036abbfab378bf7a77f" translate="yes" xml:space="preserve">
          <source>When a query is run on XML data, as in the snippet above, the &lt;code&gt;doc()&lt;/code&gt; function returns the node in the built-in data model where the query evaluation will begin. But when a query is run on a custom node model containing non-XML data, one of the &lt;a href=&quot;qxmlquery#bindVariable&quot;&gt;bindVariable&lt;/a&gt;() functions must be called to bind a variable name to a starting node in the custom model. A $variable reference is used in the &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt; text to access the starting node in the custom model. It is not necessary to declare the variable name external in the query. See the example in the documentation for &lt;a href=&quot;qabstractxmlnodemodel&quot;&gt;QAbstractXmlNodeModel&lt;/a&gt;.</source>
          <target state="translated">When a query is run on XML data, as in the snippet above, the &lt;code&gt;doc()&lt;/code&gt; function returns the node in the built-in data model where the query evaluation will begin. But when a query is run on a custom node model containing non-XML data, one of the &lt;a href=&quot;qxmlquery#bindVariable&quot;&gt;bindVariable&lt;/a&gt;() functions must be called to bind a variable name to a starting node in the custom model. A $variable reference is used in the &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt; text to access the starting node in the custom model. It is not necessary to declare the variable name external in the query. See the example in the documentation for &lt;a href=&quot;qabstractxmlnodemodel&quot;&gt;QAbstractXmlNodeModel&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="865208c91375893b92d822994a4204209a37ba98" translate="yes" xml:space="preserve">
          <source>When a query is run on XML data, as in the snippet above, the &lt;code&gt;doc()&lt;/code&gt; function returns the node in the built-in data model where the query evaluation will begin. But when a query is run on a custom node model containing non-XML data, one of the &lt;a href=&quot;qxmlquery#bindVariable&quot;&gt;bindVariable&lt;/a&gt;() functions must be called to bind a variable name to a starting node in the custom model. A $variable reference is used in the &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt; text to access the starting node in the custom model. It is not necessary to declare the variable name external in the query. See the example in the documentation for &lt;a href=&quot;qabstractxmlnodemodel&quot;&gt;QAbstractXmlNodeModel&lt;/a&gt;.</source>
          <target state="translated">위의 스 니펫에서와 같이 XML 데이터에서 쿼리를 실행하면 &lt;code&gt;doc()&lt;/code&gt; 함수는 쿼리 평가가 시작될 내장 데이터 모델의 노드를 반환합니다. 그러나 XML이 아닌 데이터가 포함 된 사용자 정의 노드 모델에서 쿼리를 실행할 때 변수 이름을 사용자 정의 모델의 시작 노드에 바인딩하려면 &lt;a href=&quot;qxmlquery#bindVariable&quot;&gt;bindVariable&lt;/a&gt; () 함수 중 하나를 호출해야합니다. $ 변수 참조는 &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt; 텍스트에서 사용자 정의 모델의 시작 노드에 액세스하는 데 사용됩니다 . 쿼리에서 변수 이름을 외부로 선언 할 필요는 없습니다. &lt;a href=&quot;qabstractxmlnodemodel&quot;&gt;QAbstractXmlNodeModel&lt;/a&gt; 문서의 예제를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4b9712c67436ef44e2898fc4063b230c597593f7" translate="yes" xml:space="preserve">
          <source>When a query runs, it parses documents, allocating internal data structures to hold them, and it may load other resources over the network. It reuses these allocated resources when possible, to avoid having to reload and reparse them.</source>
          <target state="translated">쿼리가 실행될 때 문서를 구문 분석하고이를 보유하기 위해 내부 데이터 구조를 할당하며 네트워크를 통해 다른 리소스를로드 할 수 있습니다. 재 할당 및 재분석을 피하기 위해 가능하면 이러한 할당 된 자원을 재사용합니다.</target>
        </trans-unit>
        <trans-unit id="8a593010a6662d2b59e4a72e57582a95f2f8033f" translate="yes" xml:space="preserve">
          <source>When a rectangular clip is set in combination with &lt;a href=&quot;qsgclipnode#setIsRectangular&quot;&gt;setIsRectangular&lt;/a&gt; the renderer may in some cases use a more optimal clip method.</source>
          <target state="translated">직사각형 클립을 &lt;a href=&quot;qsgclipnode#setIsRectangular&quot;&gt;setIsRectangular&lt;/a&gt; 와 함께 설정 하면 렌더러가 더 최적의 클립 방법을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="65c8e122245f9ff6c381bb4990517a1724e6f958" translate="yes" xml:space="preserve">
          <source>When a relative URL is written to a &lt;code&gt;url&lt;/code&gt; type property, it is converted into a URL object, so &lt;b&gt;matching the URL value against the input string value will fail&lt;/b&gt;. Instead, convert the string to a URL using Qt.resolvedUrl() for means of comparison, and use &lt;code&gt;toString()&lt;/code&gt; to get the contents of the URL:</source>
          <target state="translated">상대 URL이 &lt;code&gt;url&lt;/code&gt; 유형 특성에 기록되면 URL 오브젝트로 변환되므로 &lt;b&gt;URL 값을 입력 문자열 값과 일치시키는 데 실패&lt;/b&gt; 합니다. 대신 비교를 위해 Qt.resolvedUrl ()을 사용하여 문자열을 URL로 변환하고 &lt;code&gt;toString()&lt;/code&gt; 을 사용 하여 URL의 컨텐츠를 가져 오십시오.</target>
        </trans-unit>
        <trans-unit id="fccc71619fd1248dd374a7ce2288a8bbb7a01715" translate="yes" xml:space="preserve">
          <source>When a scene is set on a view, the &lt;a href=&quot;qgraphicsscene#changed&quot;&gt;QGraphicsScene::changed&lt;/a&gt;() signal is automatically connected to this view's &lt;a href=&quot;qgraphicsview#updateScene&quot;&gt;updateScene&lt;/a&gt;() slot, and the view's scroll bars are adjusted to fit the size of the scene.</source>
          <target state="translated">장면에 뷰가 설정되면 &lt;a href=&quot;qgraphicsscene#changed&quot;&gt;QGraphicsScene :: changed&lt;/a&gt; () 신호가이 뷰의 &lt;a href=&quot;qgraphicsview#updateScene&quot;&gt;updateScene&lt;/a&gt; () 슬롯에 자동으로 연결되고 뷰의 스크롤 막대가 장면의 크기에 맞게 조정됩니다.</target>
        </trans-unit>
        <trans-unit id="a9d5b266152d0f4cd9bb69c2a4c651cf03cd822b" translate="yes" xml:space="preserve">
          <source>When a shared object is created, it sets the reference count to 1. The reference count is incremented whenever a new object references the shared data, and decremented when the object dereferences the shared data. The shared data is deleted when the reference count becomes zero.</source>
          <target state="translated">공유 객체는 생성 될 때 참조 카운트를 1로 설정합니다. 참조 카운트는 새 객체가 공유 데이터를 참조 할 때마다 증가하고 객체가 공유 데이터를 역 참조 할 때 감소합니다. 참조 횟수가 0이되면 공유 데이터가 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="cc3649a6da4b8adb60932067105d0642a4d24c46" translate="yes" xml:space="preserve">
          <source>When a shortcut's key sequence is completed, activatedAmbiguously() is emitted if the key sequence is still ambiguous (i.e., it is the start of one or more other shortcuts). The &lt;a href=&quot;qshortcut#activated&quot;&gt;activated&lt;/a&gt;() signal is not emitted in this case.</source>
          <target state="translated">바로 가기 키 시퀀스가 ​​완료되면 키 시퀀스가 ​​여전히 모호한 경우 (즉, 하나 이상의 다른 바로 가기의 시작 인 경우) activateAmbiguously ()가 발생합니다. 이 &lt;a href=&quot;qshortcut#activated&quot;&gt;경우 활성화 된&lt;/a&gt; () 신호가 방출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6332ae030a9135a45f7906377ec58084cbfab446" translate="yes" xml:space="preserve">
          <source>When a signal is emitted, the slots connected to it are usually executed immediately, just like a normal function call. When this happens, the signals and slots mechanism is totally independent of any GUI event loop. Execution of the code following the &lt;code&gt;emit&lt;/code&gt; statement will occur once all slots have returned. The situation is slightly different when using &lt;a href=&quot;qt#ConnectionType-enum&quot;&gt;queued connections&lt;/a&gt;; in such a case, the code following the &lt;code&gt;emit&lt;/code&gt; keyword will continue immediately, and the slots will be executed later.</source>
          <target state="translated">신호가 방출되면 연결된 함수는 보통 일반 함수 호출과 마찬가지로 즉시 실행됩니다. 이 경우 신호 및 슬롯 메커니즘은 GUI 이벤트 루프와 완전히 독립적입니다. 모든 슬롯이 반환되면 &lt;code&gt;emit&lt;/code&gt; 문 다음에 나오는 코드가 실행 됩니다. &lt;a href=&quot;qt#ConnectionType-enum&quot;&gt;대기 연결을&lt;/a&gt; 사용할 때 상황이 약간 다릅니다 . 이 경우 &lt;code&gt;emit&lt;/code&gt; 키워드 다음에 오는 코드 는 즉시 계속되고 슬롯은 나중에 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="9ddb05e9c434f565919399ed11ae59e44adc1a53" translate="yes" xml:space="preserve">
          <source>When a slot is called in an object due to a signal delivery or due to a remote method call, it is sometimes necessary to know the context in which that happened. In particular, if the slot determines that it wants to send the reply at a later opportunity or if it wants to reply with an error, the context is needed.</source>
          <target state="translated">신호 전달 또는 원격 메소드 호출로 인해 오브젝트에서 슬롯이 호출 될 때 발생하는 컨텍스트를 알아야하는 경우가 있습니다. 특히, 슬롯이 나중에 기회에 응답을 보내려고한다고 판단하거나 오류로 응답하려면 컨텍스트가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="b82f70b447a179232f4e12d074947bc0969bd039" translate="yes" xml:space="preserve">
          <source>When a split handle is dragged, the &lt;code&gt;SplitView.preferredWidth&lt;/code&gt; or &lt;code&gt;SplitView.preferredHeight&lt;/code&gt; property is overwritten, depending on the &lt;a href=&quot;qml-qtquick-controls2-splitview#orientation-prop&quot;&gt;orientation&lt;/a&gt; of the view.</source>
          <target state="translated">분할 핸들을 끌면 뷰 의 &lt;a href=&quot;qml-qtquick-controls2-splitview#orientation-prop&quot;&gt;방향&lt;/a&gt; 에 따라 &lt;code&gt;SplitView.preferredWidth&lt;/code&gt; 또는 &lt;code&gt;SplitView.preferredHeight&lt;/code&gt; 속성을 덮어 씁니다 .</target>
        </trans-unit>
        <trans-unit id="7d4d5ea445229544da0d5338a305894b8698bdd0" translate="yes" xml:space="preserve">
          <source>When a split item is resized, the preferredHeight will be set in order to keep track of the new size.</source>
          <target state="translated">분할 항목의 크기를 조정하면 새 크기를 추적하기 위해 preferredHeight가 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="161235a5aac72fca97ccfb11b438ac5fe662b266" translate="yes" xml:space="preserve">
          <source>When a split item is resized, the preferredWidth will be set in order to keep track of the new size.</source>
          <target state="translated">분할 항목의 크기가 조정되면 새 크기를 추적하기 위해 preferredWidth가 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="2a09b738b648e2f453338d46763c1dca7735230f" translate="yes" xml:space="preserve">
          <source>When a stack is added to a group using &lt;a href=&quot;qundogroup#addStack&quot;&gt;addStack&lt;/a&gt;(), the group does not take ownership of the stack. This means the stack has to be deleted separately from the group. When a stack is deleted, it is automatically removed from a group. A stack may belong to only one group. Adding it to another group will cause it to be removed from the previous group.</source>
          <target state="translated">&lt;a href=&quot;qundogroup#addStack&quot;&gt;addStack&lt;/a&gt; ()을 사용하여 스택을 그룹에 추가 하면 그룹은 스택의 소유권을 갖지 않습니다. 이는 스택을 그룹과 별도로 삭제해야 함을 의미합니다. 스택이 삭제되면 그룹에서 자동으로 제거됩니다. 스택은 하나의 그룹에만 속할 수 있습니다. 다른 그룹에 추가하면 이전 그룹에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="3d6e4a2b53c50f2891abb48a8f6f6cc25d79ab52" translate="yes" xml:space="preserve">
          <source>When a state extends another state, it inherits all the changes of that state.</source>
          <target state="translated">상태가 다른 상태를 확장하면 해당 상태의 모든 변경 사항이 상속됩니다.</target>
        </trans-unit>
        <trans-unit id="6a4a099453c8a8d91cb5a5c167ee9f1538c09b8c" translate="yes" xml:space="preserve">
          <source>When a state is active, all its parent states are active by definition. When</source>
          <target state="translated">상태가 활성화되면 모든 상위 상태가 정의에 따라 활성화됩니다. 언제</target>
        </trans-unit>
        <trans-unit id="ba9d99ab4b7d6deb7d6417df3035d1441aabe91d" translate="yes" xml:space="preserve">
          <source>When a state is exited prior to the animation finishing, the behavior of the state machine depends on the target state of the transition. If the target state explicitly assigns a value to the property, no additional action will be taken. The property will be assigned the value defined by the target state.</source>
          <target state="translated">애니메이션 마무리 전에 상태가 종료되면 상태 머신의 동작은 전환의 대상 상태에 따라 다릅니다. 대상 상태가 명시 적으로 속성에 값을 할당하면 추가 작업이 수행되지 않습니다. 속성에 대상 상태에 의해 정의 된 값이 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="537b863aa4165206f1678fd45b68c897e7e5bb32" translate="yes" xml:space="preserve">
          <source>When a string is surrounded by slashes, it is interpreted as a &lt;a href=&quot;qregularexpression&quot;&gt;regular expression&lt;/a&gt;.</source>
          <target state="translated">문자열을 슬래시로 묶으면 &lt;a href=&quot;qregularexpression&quot;&gt;정규식으로&lt;/a&gt; 해석됩니다 .</target>
        </trans-unit>
        <trans-unit id="f4d38a1eefb6595f564c6b5c58858271837243de" translate="yes" xml:space="preserve">
          <source>When a style sheet is active, the &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt; returned by &lt;a href=&quot;qwidget#style&quot;&gt;QWidget::style&lt;/a&gt;() is a wrapper &quot;style sheet&quot; style,</source>
          <target state="translated">스타일 시트가 활성화되면 &lt;a href=&quot;qwidget#style&quot;&gt;QWidget :: style&lt;/a&gt; ()에 의해 리턴 된 &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt; 은 랩퍼 &quot;스타일 시트&quot;스타일입니다.</target>
        </trans-unit>
        <trans-unit id="e7f2cf6a190dccb2e1846d702f8b4fdcc1492b48" translate="yes" xml:space="preserve">
          <source>When a task menu extension is required,</source>
          <target state="translated">작업 메뉴 확장이 필요한 경우</target>
        </trans-unit>
        <trans-unit id="b2160c5e21033a9cae7267b16da76e63faf558c9" translate="yes" xml:space="preserve">
          <source>When a texture is sub-sampled, fewer pixels than in the original are displayed, resulting in undesirable artifacts based on which pixels are chosen. This effect is worsened when the model is moving, as different pixels are chosen at different times. In the image below, notice how the line between E3 and F3 is missing, strongly present between G3 and H3, then gone for the next 5 columns, and so on.</source>
          <target state="translated">When a texture is sub-sampled, fewer pixels than in the original are displayed, resulting in undesirable artifacts based on which pixels are chosen. This effect is worsened when the model is moving, as different pixels are chosen at different times. In the image below, notice how the line between E3 and F3 is missing, strongly present between G3 and H3, then gone for the next 5 columns, and so on.</target>
        </trans-unit>
        <trans-unit id="67462236b92450150e95164abdc0c9f99abaed6b" translate="yes" xml:space="preserve">
          <source>When a timer is started, the first trigger is usually after the specified interval has elapsed. It is sometimes desirable to trigger immediately when the timer is started; for example, to establish an initial state.</source>
          <target state="translated">타이머가 시작되면 첫 번째 트리거는 일반적으로 지정된 간격이 경과 한 후입니다. 때로는 타이머가 시작될 때 즉시 트리거하는 것이 바람직합니다. 예를 들어 초기 상태를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="af89fc9ae90b687bd3803dfbbaa74da9d0b068bb" translate="yes" xml:space="preserve">
          <source>When a toolbar is resized in such a way that it is too small to show all the items it contains, an extension button will appear as the last item in the toolbar. Pressing the extension button will pop up a menu containing the items that do not currently fit in the toolbar.</source>
          <target state="translated">툴바의 크기가 너무 작아 툴바에 포함 된 모든 항목을 표시 할 수없는 경우 툴바의 마지막 항목으로 확장 버튼이 나타납니다. 확장 버튼을 누르면 현재 툴바에 맞지 않는 항목이 포함 된 메뉴가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="fd7d3a341e5fbdb2b1a43242fcba495d019b0218" translate="yes" xml:space="preserve">
          <source>When a validator is set, the text field will only accept input which leaves the text property in an intermediate state. The &lt;a href=&quot;qml-qtquick-controls2-combobox#accepted-signal&quot;&gt;accepted&lt;/a&gt; signal will only be emitted if the text is in an acceptable state when the &lt;b&gt;Return&lt;/b&gt; or &lt;b&gt;Enter&lt;/b&gt; key is pressed.</source>
          <target state="translated">유효성 검사기가 설정되면 텍스트 필드는 텍스트 속성을 중간 상태로 유지하는 입력 만 허용합니다. &lt;a href=&quot;qml-qtquick-controls2-combobox#accepted-signal&quot;&gt;받아&lt;/a&gt; 때 텍스트가 허용 상태에있는 경우에만 신호를 방출한다 &lt;b&gt;반환&lt;/b&gt; 또는이 &lt;b&gt;입력합니다&lt;/b&gt; 키가 눌려진다.</target>
        </trans-unit>
        <trans-unit id="9881f5360fc059aa0376cd9d05bbf2f898c14217" translate="yes" xml:space="preserve">
          <source>When a variable or property holds a basic type and it is assigned to another variable or property, then a copy of the value is made. In JavaScript, this value is called a primitive value.</source>
          <target state="translated">변수 나 속성에 기본 유형이 있고 다른 변수 나 속성에 할당되면 값의 복사본이 만들어집니다. JavaScript에서이 값을 기본 값이라고합니다.</target>
        </trans-unit>
        <trans-unit id="c53c2d5ff931b774b8c26a43310ae5dc80383c71" translate="yes" xml:space="preserve">
          <source>When a version number is specified (using the &lt;code&gt;&lt;a href=&quot;#version&quot;&gt;version&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#versionsym&quot;&gt;versionsym&lt;/a&gt;&lt;/code&gt; variables in a &lt;code&gt;.qdocconf&lt;/code&gt; file), it is accessible through the corresponding \version command for use in the documentation.</source>
          <target state="translated">&lt;code&gt;.qdocconf&lt;/code&gt; 파일 에서 &lt;code&gt;&lt;a href=&quot;#version&quot;&gt;version&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#versionsym&quot;&gt;versionsym&lt;/a&gt;&lt;/code&gt; 변수를 사용하여 버전 번호를 지정 하면 해당 \ version 명령을 통해 문서에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="684ca00eacddf983276d3d465bca149ba5b62e18" translate="yes" xml:space="preserve">
          <source>When a version number is specified (using the &lt;code&gt;&lt;a href=&quot;22-qdoc-configuration-generalvariables#version&quot;&gt;version&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;22-qdoc-configuration-generalvariables#versionsym&quot;&gt;versionsym&lt;/a&gt;&lt;/code&gt; variables in a &lt;code&gt;.qdocconf&lt;/code&gt; file), it is accessible through the corresponding \version command for use in the documentation.</source>
          <target state="translated">When a version number is specified (using the &lt;code&gt;&lt;a href=&quot;22-qdoc-configuration-generalvariables#version&quot;&gt;version&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;22-qdoc-configuration-generalvariables#versionsym&quot;&gt;versionsym&lt;/a&gt;&lt;/code&gt; variables in a &lt;code&gt;.qdocconf&lt;/code&gt; file), it is accessible through the corresponding \version command for use in the documentation.</target>
        </trans-unit>
        <trans-unit id="1aed6e59537ae181997a746ca0c8b7b7d30d9468" translate="yes" xml:space="preserve">
          <source>When a view transition is initialized, any property bindings that refer to the &lt;a href=&quot;qml-qtquick-viewtransition&quot;&gt;ViewTransition&lt;/a&gt; attached property are evaluated in preparation for the transition. Due to the nature of the internal construction of a view transition, the attributes of the &lt;a href=&quot;qml-qtquick-viewtransition&quot;&gt;ViewTransition&lt;/a&gt; attached property are only valid for the relevant item when the transition is initialized, and may not be valid when the transition is actually run.</source>
          <target state="translated">뷰 전환이 초기화되면 &lt;a href=&quot;qml-qtquick-viewtransition&quot;&gt;ViewTransition&lt;/a&gt; 연결 속성 을 참조하는 모든 속성 바인딩이 전환 준비 과정에서 평가됩니다. 뷰 전환의 내부 구성 특성으로 인해 &lt;a href=&quot;qml-qtquick-viewtransition&quot;&gt;ViewTransition&lt;/a&gt; 첨부 속성의 속성은 전환이 초기화 될 때 관련 항목에만 유효하며 전환이 실제로 실행될 때는 유효하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f1582c86a02339dce081b982fa7bf2aabd7e9cf" translate="yes" xml:space="preserve">
          <source>When a view transition is initialized, any property bindings that refer to the ViewTransition attached property are evaluated in preparation for the transition. Due to the nature of the internal construction of a view transition, the attributes of the ViewTransition attached property are only valid for the relevant item when the transition is initialized, and may not be valid when the transition is actually run.</source>
          <target state="translated">When a view transition is initialized, any property bindings that refer to the ViewTransition attached property are evaluated in preparation for the transition. Due to the nature of the internal construction of a view transition, the attributes of the ViewTransition attached property are only valid for the relevant item when the transition is initialized, and may not be valid when the transition is actually run.</target>
        </trans-unit>
        <trans-unit id="079663e19f7c1ba992af80c0570d23237432e8c5" translate="yes" xml:space="preserve">
          <source>When a web site requests an SSL client certificate, and one or more certificates are found in the system's client certificate store, this class provides access to the certificates to choose from, as well as a method for selecting one.</source>
          <target state="translated">웹 사이트가 SSL 클라이언트 인증서를 요청하고 시스템의 클라이언트 인증서 저장소에서 하나 이상의 인증서가 발견되면이 클래스는 선택할 인증서에 대한 액세스 권한과 인증서 선택 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="47f6110b5cfc30bcf437b8673336a30eccbb3a9e" translate="yes" xml:space="preserve">
          <source>When a web site requests an SSL client certificate, and one or more certificates are found in the system's client certificate store, this type provides access to the certificates to choose from, as well as a method for selecting one.</source>
          <target state="translated">웹 사이트가 SSL 클라이언트 인증서를 요청하고 시스템의 클라이언트 인증서 저장소에 하나 이상의 인증서가있는 경우이 유형은 선택할 인증서에 대한 액세스 권한과 인증서 선택 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="1a0abde4adaf9ada28bc188c310ca57b1baed315" translate="yes" xml:space="preserve">
          <source>When a widget &lt;a href=&quot;qwidget#acceptDrops-prop&quot;&gt;accepts drop events&lt;/a&gt;, it will receive this event if it has accepted the most recent &lt;a href=&quot;qdragenterevent&quot;&gt;QDragEnterEvent&lt;/a&gt; or &lt;a href=&quot;qdragmoveevent&quot;&gt;QDragMoveEvent&lt;/a&gt; sent to it.</source>
          <target state="translated">위젯 &lt;a href=&quot;qwidget#acceptDrops-prop&quot;&gt;이 드롭 이벤트&lt;/a&gt; 를 승인하면 가장 최근에 전송 된 &lt;a href=&quot;qdragenterevent&quot;&gt;QDragEnterEvent&lt;/a&gt; 또는 &lt;a href=&quot;qdragmoveevent&quot;&gt;QDragMoveEvent를&lt;/a&gt; 승인 한 경우이 이벤트를 수신 합니다.</target>
        </trans-unit>
        <trans-unit id="460e4079ae7809950eebb7e9e8f3fa669aaa1958" translate="yes" xml:space="preserve">
          <source>When a widget asks a style to draw an element, it provides the style with a &lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption&lt;/a&gt;, which is a class that contains the information necessary for drawing. Thanks to &lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption&lt;/a&gt;, it is possible to make &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt; draw widgets without linking in any code for the widget. This makes it possible to use &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt;'s draw functions on any paint device, i.e., you can draw a combobox on any widget, not just on a &lt;a href=&quot;qcombobox&quot;&gt;QComboBox&lt;/a&gt;.</source>
          <target state="translated">위젯이 스타일을 요청하여 요소를 그리면 스타일에 &lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption을&lt;/a&gt; 제공합니다. QStyleOption 은 그리기에 필요한 정보가 포함 된 클래스입니다. 덕분에 &lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption&lt;/a&gt; , 할 수 &lt;a href=&quot;qstyle&quot;&gt;QStyle이&lt;/a&gt; 위젯 코드에 연결하지 않고 위젯을 그립니다. 따라서 모든 페인트 장치에서 &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt; 의 그리기 기능을 사용할 수 있습니다. 즉, &lt;a href=&quot;qcombobox&quot;&gt;QComboBox&lt;/a&gt; 뿐만 아니라 모든 위젯에서 콤보 박스를 그릴 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e6f3f2c1aa86e2bdbf72b92865fad22cdf8f8992" translate="yes" xml:space="preserve">
          <source>When a widget is selected, normal clipboard operations such as cut, copy, and paste can be performed on it. All of these operations can be done and undone, as necessary.</source>
          <target state="translated">위젯을 선택하면 잘라 내기, 복사 및 붙여 넣기와 같은 일반적인 클립 보드 작업을 수행 할 수 있습니다. 필요에 따라 이러한 모든 작업을 수행하고 취소 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="32939db177a40f178792d1ab4a3586964a02a117" translate="yes" xml:space="preserve">
          <source>When a widget is used as a container to group a number of child widgets, it is known as a composite widget. These can be created by constructing a widget with the required visual properties - a &lt;a href=&quot;qframe&quot;&gt;QFrame&lt;/a&gt;, for example - and adding child widgets to it, usually managed by a layout. The above diagram shows such a composite widget that was created using Qt Designer.</source>
          <target state="translated">위젯을 여러 하위 위젯을 그룹화하기위한 컨테이너로 사용하는 경우이를 복합 위젯이라고합니다. 필요한 시각적 속성 ( 예 : &lt;a href=&quot;qframe&quot;&gt;QFrame&lt;/a&gt; )으로 위젯을 구성하고 일반적으로 레이아웃으로 관리되는 하위 위젯을 추가 하여 작성할 수 있습니다. 위의 다이어그램은 Qt Designer를 사용하여 작성된 복합 위젯을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="752f1a934fb7040e2a75e0adc0d7c4e3b00e3529" translate="yes" xml:space="preserve">
          <source>When a widget's font changes, it resolves its entries against its parent widget. If the widget does not have a parent widget, it resolves its entries against the scene. The widget then sends itself a &lt;a href=&quot;qevent#Type-enum&quot;&gt;FontChange&lt;/a&gt; event and notifies all its descendants so that they can resolve their fonts as well.</source>
          <target state="translated">위젯의 글꼴이 변경되면 해당 위젯이 상위 위젯에 대해 해당 항목을 해결합니다. 위젯에 상위 위젯이 없으면 장면에 대한 항목을 분석합니다. 그런 다음 위젯은 자체적으로 &lt;a href=&quot;qevent#Type-enum&quot;&gt;FontChange&lt;/a&gt; 이벤트 를 전송하고 모든 하위 항목에 통지하여 글꼴을 확인할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="8a4c47081bd0d78ce71a943dd5b9dd67bf60e6f3" translate="yes" xml:space="preserve">
          <source>When a widget's palette changes, it resolves its entries against its parent widget, or if it doesn't have a parent widget, it resolves against the scene. It then sends itself a &lt;a href=&quot;qevent#Type-enum&quot;&gt;PaletteChange&lt;/a&gt; event, and notifies all its descendants so they can resolve their palettes as well.</source>
          <target state="translated">위젯의 팔레트가 변경되면 상위 위젯에 대한 항목을 분석하거나 상위 위젯이없는 경우 장면에 대해 분석됩니다. 그런 다음 자신에게 &lt;a href=&quot;qevent#Type-enum&quot;&gt;PaletteChange&lt;/a&gt; 이벤트 를 보내고 모든 후손에게 알릴 수 있도록 팔레트를 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c935a584189a93e055ba79f2173aba07e5d505b" translate="yes" xml:space="preserve">
          <source>When a window is not visible its visibility is Hidden, and setting visibility to &lt;a href=&quot;qwindow#Visibility-enum&quot;&gt;Hidden&lt;/a&gt; is the same as setting &lt;a href=&quot;qml-qtquick-window-window#visible-prop&quot;&gt;visible&lt;/a&gt; to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">윈도우가 보이지 않으면 가시성은 숨겨지고 &lt;a href=&quot;qwindow#Visibility-enum&quot;&gt;숨김&lt;/a&gt; 으로 가시성을 설정하는 것은 &lt;a href=&quot;qml-qtquick-window-window#visible-prop&quot;&gt;visible&lt;/a&gt; 을 &lt;code&gt;false&lt;/code&gt; 로 설정하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="328cfe9dc26b3602c3dd93834eca6371ca53bcbc" translate="yes" xml:space="preserve">
          <source>When a window is using an OpenGL based surface and is appearing in full screen mode, problems can occur with other top-level windows which are part of the application. Due to limitations of the Windows DWM, compositing is not handled correctly for OpenGL based windows when going into full screen mode. As a result, other top-level windows are not placed on top of the full screen window when they are made visible. For example, menus may not appear correctly, or dialogs fail to show up.</source>
          <target state="translated">창에서 OpenGL 기반 표면을 사용하고 전체 화면 모드로 표시되는 경우 응용 프로그램의 일부인 다른 최상위 창에서 문제가 발생할 수 있습니다. Windows DWM의 제한으로 인해 전체 화면 모드로 전환 할 때 OpenGL 기반 창에 대해 합성이 올바르게 처리되지 않습니다. 결과적으로 다른 최상위 창은 표시 될 때 전체 화면 창 위에 배치되지 않습니다. 예를 들어, 메뉴가 올바르게 나타나지 않거나 대화 상자가 표시되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e6e925bbf3d90d27901234a3378310aa8ca76a99" translate="yes" xml:space="preserve">
          <source>When absolutely necessary, this limitation can be overcome by setting the &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt::WA_AlwaysStackOnTop&lt;/a&gt; attribute on the &lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt;. Be aware however that this breaks stacking order, for example it will not be possible to have other widgets on top of the &lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt;, so it should only be used in situations where a semi-transparent &lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt; with other widgets visible underneath is required.</source>
          <target state="translated">절대적으로 필요한 경우,이 제한은 설정하여 극복 할 수 &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt는 :: WA_AlwaysStackOnTop의&lt;/a&gt; 온 속성 &lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget을&lt;/a&gt; . 그러나 이것은 스택 순서를 &lt;a href=&quot;qopenglwidget&quot;&gt;깨뜨립니다.&lt;/a&gt; 예를 들어 QOpenGLWidget 위에 다른 위젯을 가질 수 없으므로 아래에 다른 위젯이 보이는 반투명 &lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt; 이 필요한 상황에서만 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="b6f91c3f1d20bbeecc7d389e5ae573aae0f28831" translate="yes" xml:space="preserve">
          <source>When absolutely necessary, this limitation can be overcome by setting the &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt::WA_AlwaysStackOnTop&lt;/a&gt; attribute on the &lt;a href=&quot;qquickwidget&quot;&gt;QQuickWidget&lt;/a&gt;. Be aware, however that this breaks stacking order. For example it will not be possible to have other widgets on top of the &lt;a href=&quot;qquickwidget&quot;&gt;QQuickWidget&lt;/a&gt;, so it should only be used in situations where a semi-transparent &lt;a href=&quot;qquickwidget&quot;&gt;QQuickWidget&lt;/a&gt; with other widgets visible underneath is required.</source>
          <target state="translated">절대적으로 필요한 경우,이 제한은 설정하여 극복 할 수 &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt는 :: WA_AlwaysStackOnTop의&lt;/a&gt; 온 속성 &lt;a href=&quot;qquickwidget&quot;&gt;QQuickWidget을&lt;/a&gt; . 그러나 이렇게하면 쌓임 순서가 깨집니다. 예를 들어, &lt;a href=&quot;qquickwidget&quot;&gt;QQuickWidget&lt;/a&gt; 위에 다른 위젯을 가질 수 &lt;a href=&quot;qquickwidget&quot;&gt;없으므로&lt;/a&gt; 다른 위젯이 보이는 반투명 QQuickWidget 이 필요한 상황에서만 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="dd97e50e2c67a4ead279bf8d8832fc9a85185034" translate="yes" xml:space="preserve">
          <source>When absolutely necessary, this limitation can be overcome by setting the &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt::WA_AlwaysStackOnTop&lt;/a&gt; attribute on the QOpenGLWidget. Be aware however that this breaks stacking order, for example it will not be possible to have other widgets on top of the QOpenGLWidget, so it should only be used in situations where a semi-transparent QOpenGLWidget with other widgets visible underneath is required.</source>
          <target state="translated">When absolutely necessary, this limitation can be overcome by setting the &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt::WA_AlwaysStackOnTop&lt;/a&gt; attribute on the QOpenGLWidget. Be aware however that this breaks stacking order, for example it will not be possible to have other widgets on top of the QOpenGLWidget, so it should only be used in situations where a semi-transparent QOpenGLWidget with other widgets visible underneath is required.</target>
        </trans-unit>
        <trans-unit id="e79a7fffcc2719cd295404f96fe561b573e17000" translate="yes" xml:space="preserve">
          <source>When absolutely necessary, this limitation can be overcome by setting the &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt::WA_AlwaysStackOnTop&lt;/a&gt; attribute on the QQuickWidget. Be aware, however that this breaks stacking order. For example it will not be possible to have other widgets on top of the QQuickWidget, so it should only be used in situations where a semi-transparent QQuickWidget with other widgets visible underneath is required.</source>
          <target state="translated">When absolutely necessary, this limitation can be overcome by setting the &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt::WA_AlwaysStackOnTop&lt;/a&gt; attribute on the QQuickWidget. Be aware, however that this breaks stacking order. For example it will not be possible to have other widgets on top of the QQuickWidget, so it should only be used in situations where a semi-transparent QQuickWidget with other widgets visible underneath is required.</target>
        </trans-unit>
        <trans-unit id="9df5199ed73ebbcc06766d6511a4572850a19641" translate="yes" xml:space="preserve">
          <source>When access to the data is no longer needed be sure to call the &lt;a href=&quot;qabstractvideobuffer#unmap&quot;&gt;unmap&lt;/a&gt;() function to release the mapped memory and possibly update the buffer contents.</source>
          <target state="translated">더 이상 데이터에 액세스 할 필요가 없으면 &lt;a href=&quot;qabstractvideobuffer#unmap&quot;&gt;매핑 해제&lt;/a&gt; 메모리를 해제하고 버퍼 내용을 업데이트하기 위해 unmap () 함수를 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="7f19c431a0d32b110924683908433279ea139496" translate="yes" xml:space="preserve">
          <source>When access to the data is no longer needed, be sure to call the &lt;a href=&quot;qvideoframe#unmap&quot;&gt;unmap&lt;/a&gt;() function to release the mapped memory and possibly update the video frame contents.</source>
          <target state="translated">더 이상 데이터에 액세스 할 필요가 없으면 &lt;a href=&quot;qvideoframe#unmap&quot;&gt;unmap&lt;/a&gt; () 함수를 호출 하여 매핑 된 메모리를 해제하고 비디오 프레임 내용을 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="76c2596888d85f6b2c006508a41b7c104d68f3e1" translate="yes" xml:space="preserve">
          <source>When active is &lt;code&gt;true&lt;/code&gt;, and the delegate component is ready, the Instantiator will create objects according to the model. When active is &lt;code&gt;false&lt;/code&gt;, no objects will be created and any previously created objects will be destroyed.</source>
          <target state="translated">active가 &lt;code&gt;true&lt;/code&gt; 이고 델리게이트 구성 요소가 준비되면 Instantiator는 모델에 따라 객체를 만듭니다. active가 &lt;code&gt;false&lt;/code&gt; 인 경우 오브젝트가 작성되지 않으며 이전에 작성된 오브젝트가 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="12b8ae889e8cb41399d2e7e574fc759816dcd949" translate="yes" xml:space="preserve">
          <source>When active is true, and the delegate component is ready, the Instantiator will create objects according to the model. When active is false, no objects will be created and any previously created objects will be destroyed.</source>
          <target state="translated">active가 true이고 델리게이트 구성 요소가 준비되면 Instantiator는 모델에 따라 객체를 만듭니다. active가 false이면 오브젝트가 작성되지 않으며 이전에 작성된 오브젝트가 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="bb891bbb3b1590bf7288c70b1d889bb5699abbfb" translate="yes" xml:space="preserve">
          <source>When adding or removing intervals from the time range, existing intervals within the range may be expanded, trimmed, deleted, merged or split to ensure that all intervals within the time range remain distinct and disjoint. As a consequence, all intervals added or removed from a time range must be &lt;a href=&quot;qmediatimeinterval#isNormal&quot;&gt;normal&lt;/a&gt;.</source>
          <target state="translated">시간 범위에서 간격을 추가하거나 제거 할 때 시간 범위 내의 모든 간격이 명확하고 분리되지 않도록 범위 내의 기존 간격을 확장, 다듬기, 삭제, 병합 또는 분할 할 수 있습니다. 결과적으로 시간 범위에서 추가 또는 제거 된 모든 간격은 &lt;a href=&quot;qmediatimeinterval#isNormal&quot;&gt;정상&lt;/a&gt; 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="0d4f3812ee3ea698da8238994dd265c1c75c9c45" translate="yes" xml:space="preserve">
          <source>When adding text to a text edit, it is an advantage to add it in an edit block (see example below). The result is that the text edit does not need to build the entire document structure at once.</source>
          <target state="translated">텍스트 편집에 텍스트를 추가 할 때 편집 블록에 추가하는 것이 유리합니다 (아래 예 참조). 결과적으로 텍스트 편집으로 전체 문서 구조를 한 번에 만들 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="bb84371278c0809ff19ae10f5e09e0a84286da38" translate="yes" xml:space="preserve">
          <source>When adding touch events to the sequence,</source>
          <target state="translated">터치 이벤트를 시퀀스에 추가 할 때</target>
        </trans-unit>
        <trans-unit id="f1538eed1aaf041d2e66701f8146b1df9ccdc51d" translate="yes" xml:space="preserve">
          <source>When additional touch points are detected, Qt first looks to see if there are any active touch points on any ancestor or descendent of the widget under the new touch point. If there are, the new touch point is grouped with the first, and the new touch point will be sent in a single &lt;a href=&quot;qtouchevent&quot;&gt;QTouchEvent&lt;/a&gt; to the widget that handled the first touch point. (The widget under the new touch point will not receive an event).</source>
          <target state="translated">추가 터치 포인트가 감지되면 Qt는 먼저 새 터치 포인트 아래 위젯의 상위 또는 하위 항목에 활성 터치 포인트가 있는지 확인합니다. 있는 경우 새 터치 포인트가 첫 번째 터치 포인트와 그룹화되고 새 터치 포인트가 단일 &lt;a href=&quot;qtouchevent&quot;&gt;QTouchEvent&lt;/a&gt; 에서 첫 번째 터치 포인트를 처리 한 위젯 으로 전송됩니다 . (새로운 터치 포인트 아래의 위젯은 이벤트를받지 않습니다).</target>
        </trans-unit>
        <trans-unit id="e556c9c43b8715d0148015f22447dd2e38354307" translate="yes" xml:space="preserve">
          <source>When additional touch points are detected, Qt first looks to see if there are any active touch points on any ancestor or descendent of the widget under the new touch point. If there are, the new touch point is grouped with the first, and the new touch point will be sent in a single QTouchEvent to the widget that handled the first touch point. (The widget under the new touch point will not receive an event).</source>
          <target state="translated">When additional touch points are detected, Qt first looks to see if there are any active touch points on any ancestor or descendent of the widget under the new touch point. If there are, the new touch point is grouped with the first, and the new touch point will be sent in a single QTouchEvent to the widget that handled the first touch point. (The widget under the new touch point will not receive an event).</target>
        </trans-unit>
        <trans-unit id="7e4c9f17f04f10fedd1f9fd887395ad46b2aa135" translate="yes" xml:space="preserve">
          <source>When all content of the scene has stopped moving, the camera is jiggled very slightly between frames, and the result of each new frame is blended with the previous frames. The more frames you accumulate, the better looking the result.</source>
          <target state="translated">When all content of the scene has stopped moving, the camera is jiggled very slightly between frames, and the result of each new frame is blended with the previous frames. The more frames you accumulate, the better looking the result.</target>
        </trans-unit>
        <trans-unit id="e831f4eb7ef019746768c98e62442552c2eec2dc" translate="yes" xml:space="preserve">
          <source>When all the class attribute values are defined as they are in the style.css file that is used for rendering the Qt documentation, the above example is rendered as:</source>
          <target state="translated">Qt 문서를 렌더링하는 데 사용되는 style.css 파일에서와 같이 모든 클래스 속성 값이 정의되면 위 예제는 다음과 같이 렌더링됩니다.</target>
        </trans-unit>
        <trans-unit id="bddff14c450c718712b8166ec8a19a179f1d175d" translate="yes" xml:space="preserve">
          <source>When an &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtqml-modules-identifiedmodules.html#&quot;&gt;identified module&lt;/a&gt; is imported, the QML engine searches the</source>
          <target state="translated">때 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtqml-modules-identifiedmodules.html#&quot;&gt;식별 모듈이&lt;/a&gt; 수입되면, QML 엔진 검색한다</target>
        </trans-unit>
        <trans-unit id="9add852e9635e48ec41c6e958905759815f12454" translate="yes" xml:space="preserve">
          <source>When an &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtqml-modules-identifiedmodules.html&quot;&gt;identified module&lt;/a&gt; is imported, the QML engine searches the</source>
          <target state="translated">When an &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtqml-modules-identifiedmodules.html&quot;&gt;identified module&lt;/a&gt; is imported, the QML engine searches the</target>
        </trans-unit>
        <trans-unit id="0cb0af928cd358589c97b0ea36760a95bf56bf0a" translate="yes" xml:space="preserve">
          <source>When an &lt;a href=&quot;qml-qtquick-anchoranimation&quot;&gt;AnchorAnimation&lt;/a&gt; is used in a &lt;a href=&quot;https://doc.qt.io/qt-5.13/qmlexampletoggleswitch.html#transition&quot;&gt;Transition&lt;/a&gt;, it will animate any &lt;a href=&quot;qml-qtquick-anchorchanges&quot;&gt;AnchorChanges&lt;/a&gt; that have occurred during the state change. This can be overridden by setting a specific target item using the &lt;a href=&quot;qml-qtquick-anchorchanges#target-prop&quot;&gt;AnchorChanges.target&lt;/a&gt; property.</source>
          <target state="translated">때 &lt;a href=&quot;qml-qtquick-anchoranimation&quot;&gt;AnchorAnimation는&lt;/a&gt; (A)에 사용되는 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qmlexampletoggleswitch.html#transition&quot;&gt;전환&lt;/a&gt; , 어떤 애니메이션 것이다 &lt;a href=&quot;qml-qtquick-anchorchanges&quot;&gt;AnchorChanges&lt;/a&gt; 상태 변화시 발생. &lt;a href=&quot;qml-qtquick-anchorchanges#target-prop&quot;&gt;AnchorChanges.target&lt;/a&gt; 속성을 사용하여 특정 대상 항목을 설정하여이를 재정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f7ee3afe1168f0981bdb0b13f0d2799a8598f876" translate="yes" xml:space="preserve">
          <source>When an AnchorAnimation is used in a &lt;a href=&quot;https://doc.qt.io/qt-5.15/qmlexampletoggleswitch.html#transition&quot;&gt;Transition&lt;/a&gt;, it will animate any &lt;a href=&quot;qml-qtquick-anchorchanges&quot;&gt;AnchorChanges&lt;/a&gt; that have occurred during the state change. This can be overridden by setting a specific target item using the &lt;a href=&quot;qml-qtquick-anchorchanges#target-prop&quot;&gt;AnchorChanges.target&lt;/a&gt; property.</source>
          <target state="translated">When an AnchorAnimation is used in a &lt;a href=&quot;https://doc.qt.io/qt-5.15/qmlexampletoggleswitch.html#transition&quot;&gt;Transition&lt;/a&gt;, it will animate any &lt;a href=&quot;qml-qtquick-anchorchanges&quot;&gt;AnchorChanges&lt;/a&gt; that have occurred during the state change. This can be overridden by setting a specific target item using the &lt;a href=&quot;qml-qtquick-anchorchanges#target-prop&quot;&gt;AnchorChanges.target&lt;/a&gt; property.</target>
        </trans-unit>
        <trans-unit id="3ba28642fdd34030f92c386fbe056673579dd0c3" translate="yes" xml:space="preserve">
          <source>When an accessible object is changed in a way that users need to know about, it notifies clients of the change by sending them an event via the accessible interface. This is how &lt;a href=&quot;qslider&quot;&gt;QSlider&lt;/a&gt; calls &lt;a href=&quot;https://doc.qt.io/qt-5.13/qaccessible-obsolete.html#updateAccessibility&quot;&gt;updateAccessibility()&lt;/a&gt; to indicate that its value has changed:</source>
          <target state="translated">사용자가 알아야 할 방식으로 액세스 가능한 객체가 변경되면 액세스 가능한 인터페이스를 통해 이벤트를 보내 클라이언트에게 변경 사항을 알립니다. 방법이다 &lt;a href=&quot;qslider&quot;&gt;QSlider가&lt;/a&gt; 호출 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qaccessible-obsolete.html#updateAccessibility&quot;&gt;updateAccessibility을 ()&lt;/a&gt; 값이 변경된 것을 나타냅니다 :</target>
        </trans-unit>
        <trans-unit id="b37fb5dbdfd3c126b6bb96b69ea36eec43900147" translate="yes" xml:space="preserve">
          <source>When an accessible object is changed in a way that users need to know about, it notifies clients of the change by sending them an event via the accessible interface. This is how &lt;a href=&quot;qslider&quot;&gt;QSlider&lt;/a&gt; calls &lt;a href=&quot;https://doc.qt.io/qt-5.15/qaccessible-obsolete.html#updateAccessibility&quot;&gt;updateAccessibility()&lt;/a&gt; to indicate that its value has changed:</source>
          <target state="translated">When an accessible object is changed in a way that users need to know about, it notifies clients of the change by sending them an event via the accessible interface. This is how &lt;a href=&quot;qslider&quot;&gt;QSlider&lt;/a&gt; calls &lt;a href=&quot;https://doc.qt.io/qt-5.15/qaccessible-obsolete.html#updateAccessibility&quot;&gt;updateAccessibility()&lt;/a&gt; to indicate that its value has changed:</target>
        </trans-unit>
        <trans-unit id="6576db350133d85ab8ecdf7d5ae903317f8a0480" translate="yes" xml:space="preserve">
          <source>When an action is paired with buttons and menu items, the &lt;code&gt;enabled&lt;/code&gt;, &lt;code&gt;checkable&lt;/code&gt;, and &lt;code&gt;checked&lt;/code&gt; states are synced automatically. For example, in a word processor, if the user clicks a &quot;Bold&quot; toolbar button, the &quot;Bold&quot; menu item will automatically be checked. Buttons and menu items get their &lt;code&gt;text&lt;/code&gt; and &lt;code&gt;icon&lt;/code&gt; from the action by default. An action-specific &lt;code&gt;text&lt;/code&gt; or &lt;code&gt;icon&lt;/code&gt; can be overridden for a specific control by specifying &lt;code&gt;text&lt;/code&gt; or &lt;code&gt;icon&lt;/code&gt; directly on the control.</source>
          <target state="translated">동작이 버튼 및 메뉴 항목과 쌍을 이루면 &lt;code&gt;enabled&lt;/code&gt; , &lt;code&gt;checkable&lt;/code&gt; 가능 및 &lt;code&gt;checked&lt;/code&gt; 상태가 자동으로 동기화됩니다. 예를 들어 워드 프로세서에서 사용자가 &quot;굵게&quot;도구 모음 단추를 클릭하면 &quot;굵게&quot;메뉴 항목이 자동으로 확인됩니다. 버튼과 메뉴 항목은 기본적으로 작업에서 &lt;code&gt;text&lt;/code&gt; 와 &lt;code&gt;icon&lt;/code&gt; 을 가져옵니다 . 컨트롤에 직접 &lt;code&gt;text&lt;/code&gt; 또는 &lt;code&gt;icon&lt;/code&gt; 을 지정하여 특정 컨트롤에 대해 작업 별 &lt;code&gt;text&lt;/code&gt; 또는 &lt;code&gt;icon&lt;/code&gt; 을 재정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="afbbfa71a43b518eb49ebc7fe0e3a201130db196" translate="yes" xml:space="preserve">
          <source>When an animation is used as a value source or in a Behavior, the default target and property name to be animated can both be inferred.</source>
          <target state="translated">애니메이션을 값 소스 또는 동작으로 사용하는 경우 애니메이션을 적용 할 기본 대상 및 속성 이름을 모두 유추 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="336fbed65cc485dcf3185a5f916cafb70ff1cbed" translate="yes" xml:space="preserve">
          <source>When an animation is used standalone, both the target and property need to be explicitly specified.</source>
          <target state="translated">애니메이션을 독립형으로 사용하는 경우 대상과 속성을 명시 적으로 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="3e063384f01e7cc982fe175643205033a89ac5c6" translate="yes" xml:space="preserve">
          <source>When an application modal dialog is opened, the user must finish interacting with the dialog and close it before they can access any other window in the application. Window modal dialogs only block access to the window associated with the dialog, allowing the user to continue to use other windows in an application.</source>
          <target state="translated">응용 프로그램 모달 대화 상자가 열리면 사용자는 응용 프로그램의 다른 창에 액세스하기 전에 대화 상자와 상호 작용하고 대화 상자를 닫아야합니다. 창 모달 대화 상자는 대화 상자와 관련된 창에 대한 액세스 만 차단하므로 사용자는 응용 프로그램에서 다른 창을 계속 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="03f1ac029efa0e89898412a8bc3f237fc158d829" translate="yes" xml:space="preserve">
          <source>When an error occurs during a transaction (including an inner transaction failing), reading from the data stream is suspended (all subsequent read operations return empty/zero values) and subsequent inner transactions are forced to fail. Starting a new outermost transaction recovers from this state. This behavior makes it unnecessary to error-check every read operation separately.</source>
          <target state="translated">트랜잭션 (내부 트랜잭션 실패 포함) 중에 오류가 발생하면 데이터 스트림으로부터의 읽기가 일시 중지되고 (모든 후속 읽기 작업이 비어 있거나 0을 반환 함) 후속 내부 트랜잭션이 강제로 실패합니다. 새로운 최 외곽 트랜잭션을 시작하면이 상태에서 복구됩니다. 이 동작으로 인해 모든 읽기 작업을 개별적으로 오류 점검 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="d4d4dd6c5a276f9a88210865c11ad3239fc05498" translate="yes" xml:space="preserve">
          <source>When an escape button can't be determined using these rules, pressing &lt;b&gt;Esc&lt;/b&gt; has no effect.</source>
          <target state="translated">이 규칙을 사용하여 이스케이프 버튼을 확인할 수없는 경우 &lt;b&gt;Esc를&lt;/b&gt; 누릅니다.&lt;b&gt;&lt;/b&gt; 를 아무 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="88e91d6c3ac2f70e9dc327611729bb3fc23462f4" translate="yes" xml:space="preserve">
          <source>When an escape button could not be automatically detected, pressing &lt;b&gt;Esc&lt;/b&gt; has no effect.</source>
          <target state="translated">이스케이프 버튼을 자동으로 감지 할 수 없으면 &lt;b&gt;Esc를&lt;/b&gt; 누릅니다.&lt;b&gt;&lt;/b&gt; 를 아무런 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="60deb4d5ec6470a1989d6f1aae50fd37df3fb27a" translate="yes" xml:space="preserve">
          <source>When an event notification identified by</source>
          <target state="translated">이벤트 알림이</target>
        </trans-unit>
        <trans-unit id="cc1c8c604562d809abc5eea2fc6d1c3875525ea6" translate="yes" xml:space="preserve">
          <source>When an event occurs, Qt creates an event object to represent it by constructing an instance of the appropriate &lt;a href=&quot;qevent&quot;&gt;QEvent&lt;/a&gt; subclass, and delivers it to a particular instance of &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; (or one of its subclasses) by calling its &lt;a href=&quot;qobject#event&quot;&gt;event()&lt;/a&gt; function.</source>
          <target state="translated">이벤트가 발생하면 Qt는 적절한 &lt;a href=&quot;qevent&quot;&gt;QEvent&lt;/a&gt; 서브 클래스 의 인스턴스를 생성하여 이벤트 객체를 생성하고 이벤트 ()를 호출하여 &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 의 특정 인스턴스 (또는 서브 클래스 중 하나 &lt;a href=&quot;qobject#event&quot;&gt;)에 전달합니다.&lt;/a&gt; 함수를 합니다.</target>
        </trans-unit>
        <trans-unit id="de6f46d25c54bf3f5ae53599544aff515fdc8c6f" translate="yes" xml:space="preserve">
          <source>When an extension is requested,</source>
          <target state="translated">확장이 요청되면</target>
        </trans-unit>
        <trans-unit id="82176d3ebc0806a90e56a238f12634352670b5cd" translate="yes" xml:space="preserve">
          <source>When an extension is required,</source>
          <target state="translated">확장이 필요한 경우</target>
        </trans-unit>
        <trans-unit id="15891740de686f6443de37f1b681bce112b87311" translate="yes" xml:space="preserve">
          <source>When an input mask is set, the &lt;a href=&quot;qlineedit#text-prop&quot;&gt;text&lt;/a&gt;() method returns a modified copy of the line edit content where all the</source>
          <target state="translated">When an input mask is set, the &lt;a href=&quot;qlineedit#text-prop&quot;&gt;text&lt;/a&gt;() method returns a modified copy of the line edit content where all the</target>
        </trans-unit>
        <trans-unit id="e58900421752248eb5fa9c7e1a8662c806ac6e45" translate="yes" xml:space="preserve">
          <source>When an item becomes the child of another item:</source>
          <target state="translated">항목이 다른 항목의 자식이되는 경우 :</target>
        </trans-unit>
        <trans-unit id="6de19d2590d4fe0fe6e06630c40b5632e67df7b0" translate="yes" xml:space="preserve">
          <source>When an item gains the keyboard grab, it receives a &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent::GrabKeyboard&lt;/a&gt; event. When it loses the keyboard grab, it receives a &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent::UngrabKeyboard&lt;/a&gt; event. These events can be used to detect when your item gains or loses the keyboard grab through other means than gaining input focus.</source>
          <target state="translated">항목이 키보드 잡기를 &lt;a href=&quot;qevent#Type-enum&quot;&gt;얻으면 QEvent :: GrabKeyboard&lt;/a&gt; 이벤트가 수신 됩니다. 키보드 잡기를 잃으면 &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent :: UngrabKeyboard를받습니다.&lt;/a&gt; 이벤트를 . 이 이벤트는 항목이 입력 포커스를 얻는 것 이외의 다른 방법을 통해 키보드를 잡거나 잃을 때를 감지하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="64c535dc14ed7e2aa62d21df9de2e71bdefba665" translate="yes" xml:space="preserve">
          <source>When an item gains the mouse grab, it receives a &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent::GrabMouse&lt;/a&gt; event. When it loses the mouse grab, it receives a &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent::UngrabMouse&lt;/a&gt; event. These events can be used to detect when your item gains or loses the mouse grab through other means than receiving mouse button events.</source>
          <target state="translated">항목이 마우스를 가져 &lt;a href=&quot;qevent#Type-enum&quot;&gt;오면 QEvent :: GrabMouse&lt;/a&gt; 이벤트를 받습니다 . 마우스 잡기를 잃으면 &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent :: UngrabMouse&lt;/a&gt; 이벤트를 받습니다 . 이 이벤트는 항목이 마우스 버튼 이벤트를받는 것 이외의 다른 수단을 통해 마우스를 가져 오거나 잃는시기를 감지하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f8dc2c7ef923f949343da800eb159af2c1dde1c" translate="yes" xml:space="preserve">
          <source>When an item in an item view is selected, also highlight the branch or other decoration.</source>
          <target state="translated">항목보기에서 항목을 선택하면 분기 또는 다른 장식도 강조 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="fcc2ea9c9f7cae3dd849abe3ca69b4158eef37eb" translate="yes" xml:space="preserve">
          <source>When an item is disabled, it is not possible to trigger it through its &lt;a href=&quot;qml-qt-labs-platform-menuitem#shortcut-prop&quot;&gt;shortcut&lt;/a&gt;.</source>
          <target state="translated">항목이 비활성화되면 &lt;a href=&quot;qml-qt-labs-platform-menuitem#shortcut-prop&quot;&gt;바로 가기를&lt;/a&gt; 통해 트리거 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="452a0cf012b3cb9c186457a25f7cb1b1b7718e16" translate="yes" xml:space="preserve">
          <source>When an item is editable (and enabled), the user can edit the item by invoking one of the view's edit triggers; see &lt;a href=&quot;qabstractitemview#editTriggers-prop&quot;&gt;QAbstractItemView::editTriggers&lt;/a&gt;.</source>
          <target state="translated">항목을 편집 할 수 있고 활성화 한 경우 사용자는보기의 편집 트리거 중 하나를 호출하여 항목을 편집 할 수 있습니다. &lt;a href=&quot;qabstractitemview#editTriggers-prop&quot;&gt;QAbstractItemView :: editTriggers를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="53f7062365ff27f397c1a00527a4d2f3130aae95" translate="yes" xml:space="preserve">
          <source>When an item is enabled, the user can interact with it. The possible types of interaction are specified by the other item flags, such as &lt;a href=&quot;qstandarditem#isEditable&quot;&gt;isEditable&lt;/a&gt;() and &lt;a href=&quot;qstandarditem#isSelectable&quot;&gt;isSelectable&lt;/a&gt;().</source>
          <target state="translated">항목이 활성화되면 사용자는 해당 항목과 상호 작용할 수 있습니다. 가능한 상호 작용 유형은 &lt;a href=&quot;qstandarditem#isEditable&quot;&gt;isEditable&lt;/a&gt; () 및 &lt;a href=&quot;qstandarditem#isSelectable&quot;&gt;isSelectable&lt;/a&gt; () 과 같은 다른 항목 플래그로 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="cc78ed51b3f4dd69fbf5c809ac07b2202ac93036" translate="yes" xml:space="preserve">
          <source>When an item is flicked out, it moves to the</source>
          <target state="translated">항목을 쓸어 내면</target>
        </trans-unit>
        <trans-unit id="edf649890497fe5584e977a2ddf9e845a6d9adbb" translate="yes" xml:space="preserve">
          <source>When an item's layer is enabled, the scene graph will allocate memory in the GPU equal to &lt;code&gt;width x height x 4&lt;/code&gt;. In memory constrained configurations, large layers should be used with care.</source>
          <target state="translated">아이템의 레이어가 활성화되면 장면 그래프는 &lt;code&gt;width x height x 4&lt;/code&gt; 같은 GPU의 메모리를 할당합니다 . 메모리 제한 구성에서는 큰 계층을주의해서 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="01223f794ced4ae7d5d61d347c9ab920ed50ad46" translate="yes" xml:space="preserve">
          <source>When an object is deleted, it emits a &lt;a href=&quot;qobject#destroyed&quot;&gt;destroyed&lt;/a&gt;() signal. You can catch this signal to avoid dangling references to QObjects.</source>
          <target state="translated">객체가 삭제되면 &lt;a href=&quot;qobject#destroyed&quot;&gt;파괴됩니다.&lt;/a&gt; () 신호가 발생합니다. QObject에 대한 참조가 매달려 있지 않도록이 신호를 포착 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b5486876fa77fcc351c0468b0f817e3d9df8a75d" translate="yes" xml:space="preserve">
          <source>When and whether you actually</source>
          <target state="translated">언제 그리고 실제로</target>
        </trans-unit>
        <trans-unit id="9d01348a9aece3a4b6e828d26241b1bbac417b30" translate="yes" xml:space="preserve">
          <source>When animations are used to assign properties, a state no longer defines the exact values that a property will have when the machine is in the given state. While the animation is running, the property can potentially have any value, depending on the animation.</source>
          <target state="translated">애니메이션을 사용하여 속성을 할당 할 때 상태는 더 이상 기계가 지정된 상태에있을 때 속성의 정확한 값을 정의하지 않습니다. 애니메이션이 실행되는 동안 속성은 애니메이션에 따라 임의의 값을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2fc21797749a0f52070944bd489489ff6abab01" translate="yes" xml:space="preserve">
          <source>When any item is added, moved or removed within the above view, the items below it are displaced, causing them to move down (or sideways, if horizontally orientated) within the view. As this displacement occurs, the items' movement to their new x,y positions within the view will be animated by a &lt;a href=&quot;qml-qtquick-numberanimation&quot;&gt;NumberAnimation&lt;/a&gt; over one second, as specified.</source>
          <target state="translated">위의보기에서 항목을 추가, 이동 또는 제거하면 그 아래 항목이 이동하여보기 내에서 아래로 (또는 가로 방향 인 경우 옆으로) 이동합니다. 이 변위가 발생하면 뷰 내에서 새로운 x, y 위치로의 항목 이동 은 지정된대로 1 초 동안 &lt;a href=&quot;qml-qtquick-numberanimation&quot;&gt;NumberAnimation&lt;/a&gt; 에 의해 애니메이션됩니다 .</target>
        </trans-unit>
        <trans-unit id="6ad254e9576e1f6e7ddb5f7d88c66a573a0635ac" translate="yes" xml:space="preserve">
          <source>When any of the states is entered, the label's text will be changed accordingly.</source>
          <target state="translated">상태를 입력하면 레이블의 텍스트가 그에 따라 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="92871574343d3169789071570bca986c9cf96ef4" translate="yes" xml:space="preserve">
          <source>When any of these are needed, the Connections type can be used instead.</source>
          <target state="translated">이들 중 하나가 필요한 경우 연결 유형을 대신 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="684810257cd0aed1db1716426f1de0a6c11c6d93" translate="yes" xml:space="preserve">
          <source>When any visible part of the scene changes or is reexposed, &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; will update the entire viewport. This approach is fastest when &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; spends more time figuring out what to draw than it would spend drawing (e.g., when very many small items are repeatedly updated). This is the preferred update mode for viewports that do not support partial updates, such as &lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt;, and for viewports that need to disable scroll optimization.</source>
          <target state="translated">When any visible part of the scene changes or is reexposed, &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; will update the entire viewport. This approach is fastest when &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; spends more time figuring out what to draw than it would spend drawing (e.g., when very many small items are repeatedly updated). This is the preferred update mode for viewports that do not support partial updates, such as &lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt;, and for viewports that need to disable scroll optimization.</target>
        </trans-unit>
        <trans-unit id="217cf31f7ecab879e6aeaf0c5c92b52eaff625db" translate="yes" xml:space="preserve">
          <source>When any visible part of the scene changes or is reexposed, &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; will update the entire viewport. This approach is fastest when &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; spends more time figuring out what to draw than it would spend drawing (e.g., when very many small items are repeatedly updated). This is the preferred update mode for viewports that do not support partial updates, such as QGLWidget, and for viewports that need to disable scroll optimization.</source>
          <target state="translated">장면의 보이는 부분이 변경되거나 다시 노출되면 &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; 가 전체 뷰포트를 업데이트합니다. 이 방법은 &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; 가 그림을 그리는 것보다 무엇을 그리는지 알아내는 데 더 많은 시간을 소비 할 때 가장 빠릅니다 (예 : 매우 많은 작은 항목이 반복적으로 업데이트되는 경우). 이는 QGLWidget과 같은 부분 업데이트를 지원하지 않는 뷰포트 및 스크롤 최적화를 비활성화해야하는 뷰포트의 기본 업데이트 모드입니다.</target>
        </trans-unit>
        <trans-unit id="a06bc6d7390ca623b0217a85f5d3800a53cff310" translate="yes" xml:space="preserve">
          <source>When applying &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtquick-effects-topic.html#opacity&quot;&gt;opacity&lt;/a&gt; to an item hierarchy the opacity is applied to each item individually. This can lead to undesired visual results when the opacity is applied to a subtree. Consider the following example:</source>
          <target state="translated">&lt;a href=&quot;https://doc.qt.io/qt-5.13/qtquick-effects-topic.html#opacity&quot;&gt;불투명도를&lt;/a&gt; 적용 할 때 항목 계층 불투명도가 각 항목을 개별적으로 적용된다. 이로 인해 불투명도가 하위 트리에 적용될 때 원하지 않는 시각적 결과가 발생할 수 있습니다. 다음 예제를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="5a74e7e50f43c1fdec3974065e7b6a9d890d2418" translate="yes" xml:space="preserve">
          <source>When applying &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtquick-effects-topic.html#opacity&quot;&gt;opacity&lt;/a&gt; to an item hierarchy the opacity is applied to each item individually. This can lead to undesired visual results when the opacity is applied to a subtree. Consider the following example:</source>
          <target state="translated">When applying &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtquick-effects-topic.html#opacity&quot;&gt;opacity&lt;/a&gt; to an item hierarchy the opacity is applied to each item individually. This can lead to undesired visual results when the opacity is applied to a subtree. Consider the following example:</target>
        </trans-unit>
        <trans-unit id="03f4da2f8d439defdd9e3b555f171b3b3c94fa9c" translate="yes" xml:space="preserve">
          <source>When applying a clip to a subtree, that subtree needs to be rendered with a unique OpenGL state. This means that when &lt;a href=&quot;qml-qtquick-item#clip-prop&quot;&gt;Item::clip&lt;/a&gt; is true, batching of that item is limited to its children. When there are many children, like a &lt;a href=&quot;qml-qtquick-listview&quot;&gt;ListView&lt;/a&gt; or &lt;a href=&quot;qml-qtquick-gridview&quot;&gt;GridView&lt;/a&gt;, or complex children, like a &lt;a href=&quot;qml-qtquick-controls-textarea&quot;&gt;TextArea&lt;/a&gt;, this is fine. One should, however, use clip on smaller items with caution as it prevents batching. This includes button label, text field or list delegate and table cells.</source>
          <target state="translated">서브 트리에 클립을 적용 할 때 해당 서브 트리는 고유 한 OpenGL 상태로 렌더링되어야합니다. 이는 &lt;a href=&quot;qml-qtquick-item#clip-prop&quot;&gt;Item :: clip&lt;/a&gt; 이 true 일 때 해당 항목의 배치가 하위 항목으로 제한됨을 의미합니다. &lt;a href=&quot;qml-qtquick-listview&quot;&gt;ListView&lt;/a&gt; 또는 &lt;a href=&quot;qml-qtquick-gridview&quot;&gt;GridView&lt;/a&gt; 와 같은 많은 자식 이나 &lt;a href=&quot;qml-qtquick-controls-textarea&quot;&gt;TextArea&lt;/a&gt; 와 같은 복잡한 자식 이 있으면 괜찮습니다. 그러나 작은 항목에 클립을 사용하면 배치가 방지되므로주의해서 사용해야합니다. 여기에는 버튼 레이블, 텍스트 필드 또는 목록 대리자 및 테이블 셀이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="74f4063795ab227fe7ae24a79df545f1ccc36474" translate="yes" xml:space="preserve">
          <source>When applying a clip to a subtree, that subtree needs to be rendered with a unique OpenGL state. This means that when &lt;a href=&quot;qml-qtquick-item#clip-prop&quot;&gt;Item::clip&lt;/a&gt; is true, batching of that item is limited to its children. When there are many children, like a &lt;a href=&quot;qml-qtquick-listview&quot;&gt;ListView&lt;/a&gt; or &lt;a href=&quot;qml-qtquick-gridview&quot;&gt;GridView&lt;/a&gt;, or complex children, like a &lt;a href=&quot;qml-qtquick-controls2-textarea&quot;&gt;TextArea&lt;/a&gt;, this is fine. One should, however, use clip on smaller items with caution as it prevents batching. This includes button label, text field or list delegate and table cells.</source>
          <target state="translated">When applying a clip to a subtree, that subtree needs to be rendered with a unique OpenGL state. This means that when &lt;a href=&quot;qml-qtquick-item#clip-prop&quot;&gt;Item::clip&lt;/a&gt; is true, batching of that item is limited to its children. When there are many children, like a &lt;a href=&quot;qml-qtquick-listview&quot;&gt;ListView&lt;/a&gt; or &lt;a href=&quot;qml-qtquick-gridview&quot;&gt;GridView&lt;/a&gt;, or complex children, like a &lt;a href=&quot;qml-qtquick-controls2-textarea&quot;&gt;TextArea&lt;/a&gt;, this is fine. One should, however, use clip on smaller items with caution as it prevents batching. This includes button label, text field or list delegate and table cells.</target>
        </trans-unit>
        <trans-unit id="b46cb236869034e639f5c98ef59e6e0dc79b743e" translate="yes" xml:space="preserve">
          <source>When assigning values to properties in QML, any layouting the item must do as a result of the assignment might not take effect immediately, but can instead be postponed until the item is polished. For these cases, you can use this function to ensure that the item has been polished before the execution of the test continues. For example:</source>
          <target state="translated">QML에서 속성에 값을 할당 할 때 할당 결과로 아이템을 배치해야하는 레이아웃은 즉시 적용되지 않을 수 있지만 대신 아이템이 다듬어 질 때까지 연기 될 수 있습니다. 이 경우이 기능을 사용하여 테스트 실행이 계속되기 전에 항목이 연마되었는지 확인할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9aade8d1fb980c82f7d60913e871590165c272dc" translate="yes" xml:space="preserve">
          <source>When asynchronous is true the Instantiator will attempt to create objects asynchronously. This means that objects may not be available immediately, even if active is set to true.</source>
          <target state="translated">비동기가 참이면 Instantiator는 객체를 비동기 적으로 만들려고 시도합니다. 즉, active가 true로 설정되어 있어도 개체를 즉시 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ed095d8711f54124e3343d3e3564a7eefda4e48d" translate="yes" xml:space="preserve">
          <source>When atEnd() and &lt;a href=&quot;qxmlstreamreader#hasError&quot;&gt;hasError&lt;/a&gt;() return true and &lt;a href=&quot;qxmlstreamreader#error&quot;&gt;error&lt;/a&gt;() returns &lt;a href=&quot;qxmlstreamreader#Error-enum&quot;&gt;PrematureEndOfDocumentError&lt;/a&gt;, it means the XML has been well-formed so far, but a complete XML document has not been parsed. The next chunk of XML can be added with &lt;a href=&quot;qxmlstreamreader#addData&quot;&gt;addData&lt;/a&gt;(), if the XML is being read from a &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt;, or by waiting for more data to arrive if the XML is being read from a &lt;a href=&quot;qiodevice&quot;&gt;QIODevice&lt;/a&gt;. Either way, atEnd() will return false once more data is available.</source>
          <target state="translated">atEnd () 및 &lt;a href=&quot;qxmlstreamreader#hasError&quot;&gt;hasError&lt;/a&gt; ()가 true를 리턴하고 &lt;a href=&quot;qxmlstreamreader#error&quot;&gt;error&lt;/a&gt; ()가 &lt;a href=&quot;qxmlstreamreader#Error-enum&quot;&gt;PrematureEndOfDocumentError를&lt;/a&gt; 리턴 하면, XML이 지금까지 제대로 구성되었지만 완전한 XML 문서가 구문 분석되지 않았 음을 의미합니다. XML의 다음 청크로 추가 할 수 &lt;a href=&quot;qxmlstreamreader#addData&quot;&gt;는, addData&lt;/a&gt; 는 XML이에서 읽을 경우, () &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; , 또는 XML이 읽을되는 경우 더 많은 데이터가 도착하기를 기다리고에 의해 &lt;a href=&quot;qiodevice&quot;&gt;QIODevice&lt;/a&gt; . 어느 쪽이든 더 많은 데이터를 사용할 수있게되면 atEnd ()는 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b3157310c43a1e88b9499e85e194d29092d5e110" translate="yes" xml:space="preserve">
          <source>When automatically registering QML types defined in C++, register an additional version of the module using this minor version. Generally, minor versions to be registered are inferred from the meta objects.</source>
          <target state="translated">When automatically registering QML types defined in C++, register an additional version of the module using this minor version. Generally, minor versions to be registered are inferred from the meta objects.</target>
        </trans-unit>
        <trans-unit id="769b89390fbaab8a30caa729005e13bd89dd70b2" translate="yes" xml:space="preserve">
          <source>When both the &lt;a href=&quot;qml-qtpurchasing-product#identifier-prop&quot;&gt;identifier&lt;/a&gt; and type is set, the product is queried from the external market place, and its other properties are updated asynchronously. At this point, the identifier and type can no longer be changed.</source>
          <target state="translated">&lt;a href=&quot;qml-qtpurchasing-product#identifier-prop&quot;&gt;식별자&lt;/a&gt; 와 유형이 모두 설정되면 외부 마켓 플레이스에서 제품이 쿼리되고 다른 속성이 비동기 적으로 업데이트됩니다. 이 시점에서 식별자와 유형을 더 이상 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e66ead871376ec31f6b0bdabc0d22f6168fd30da" translate="yes" xml:space="preserve">
          <source>When both the identifier and &lt;a href=&quot;qml-qtpurchasing-product#type-prop&quot;&gt;type&lt;/a&gt; is set, the product is queried from the external market place, and its other properties are updated asynchronously. At this point, the identifier and type can no longer be changed.</source>
          <target state="translated">식별자와 &lt;a href=&quot;qml-qtpurchasing-product#type-prop&quot;&gt;유형&lt;/a&gt; 이 모두 이 설정되면 외부 시장에서 제품이 쿼리되고 다른 속성이 비동기 적으로 업데이트됩니다. 이 시점에서 식별자와 유형을 더 이상 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a77db60a6597f85a3430717a9225f81f9e8efd43" translate="yes" xml:space="preserve">
          <source>When building Qt from source, the configuration system checks for the presence of the &lt;code&gt;openssl/opensslv.h&lt;/code&gt; header provided by source or developer packages of OpenSSL.</source>
          <target state="translated">소스에서 Qt를 빌드 할 때 구성 시스템 은 OpenSSL의 소스 또는 개발자 패키지에서 제공 하는 &lt;code&gt;openssl/opensslv.h&lt;/code&gt; 헤더가 있는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="481f920a35be00bb71b2fc213b17ba321c9ce91c" translate="yes" xml:space="preserve">
          <source>When building a list or a tree that has only one column, this function provides a convenient way to append a single new</source>
          <target state="translated">하나의 열만있는 목록 또는 트리를 작성할 때이 함수는 하나의 새 항목을 추가하는 편리한 방법을 제공합니다</target>
        </trans-unit>
        <trans-unit id="f4d252c2c2fbed789c886d3ea6d5aac266ab2c26" translate="yes" xml:space="preserve">
          <source>When building a list or a tree that has only one column, this function provides a convenient way to append a single new item.</source>
          <target state="translated">하나의 열만있는 목록 또는 트리를 작성할 때이 기능을 사용하면 하나의 새 항목을 편리하게 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c2ec3d7c6f7c3543ad312c99f702307e4ac89f3b" translate="yes" xml:space="preserve">
          <source>When building a list or a tree that has only one column, this function provides a convenient way to insert a single new item.</source>
          <target state="translated">하나의 열만있는 목록 또는 트리를 작성할 때이 기능을 사용하면 하나의 새 항목을 편리하게 삽입 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c09737d74d2162e6fdbbf52bfd0b26549723d50" translate="yes" xml:space="preserve">
          <source>When building a version of Qt linked against OpenSSL, the build system will attempt to link with libssl and libcrypt libraries located in the default location on the developer's system. This location is configurable: set the &lt;code&gt;OPENSSL_LIBS&lt;/code&gt; environment variable to contain the linker options required to link Qt against the installed library. For example, on a Unix/Linux system:</source>
          <target state="translated">OpenSSL에 링크 된 Qt 버전을 빌드 할 때 빌드 시스템은 개발자 시스템의 기본 위치에있는 libssl 및 libcrypt 라이브러리와의 링크를 시도합니다. 이 위치는 구성 가능합니다. &lt;code&gt;OPENSSL_LIBS&lt;/code&gt; 환경 변수를 설정 하여 설치된 라이브러리와 Qt를 연결하는 데 필요한 링커 옵션을 포함하십시오. 예를 들어, 유닉스 / 리눅스 시스템에서 :</target>
        </trans-unit>
        <trans-unit id="c9861e5ecd8580ac9329bf8a380f56f7c6afce34" translate="yes" xml:space="preserve">
          <source>When building from source, ensure that the</source>
          <target state="translated">When building from source, ensure that the</target>
        </trans-unit>
        <trans-unit id="62819592f1c6df3a87bed54e97d13fd158256db9" translate="yes" xml:space="preserve">
          <source>When building from source, ensure that the &lt;a href=&quot;qtgraphicaleffects-index&quot;&gt;Qt Graphical Effects&lt;/a&gt; module is also built, as Qt Quick Controls 2 requires it.</source>
          <target state="translated">소스에서 빌드 할 때는 Qt Quick Controls 2에서 요구 하는 &lt;a href=&quot;qtgraphicaleffects-index&quot;&gt;Qt 그래픽 효과&lt;/a&gt; 모듈도 빌드해야합니다.</target>
        </trans-unit>
        <trans-unit id="d0d5ad78ee0d3c591ef53c8a838b7b5e7736a74d" translate="yes" xml:space="preserve">
          <source>When building from source, ensure that the &lt;a href=&quot;qtgraphicaleffects-index&quot;&gt;Qt Graphical Effects&lt;/a&gt; module is also built, as Qt Quick Controls requires it.</source>
          <target state="translated">When building from source, ensure that the &lt;a href=&quot;qtgraphicaleffects-index&quot;&gt;Qt Graphical Effects&lt;/a&gt; module is also built, as Qt Quick Controls requires it.</target>
        </trans-unit>
        <trans-unit id="7251f805a1544f17a9559e9785d85be1aae09528" translate="yes" xml:space="preserve">
          <source>When building user interfaces with the &lt;a href=&quot;qtquick-index&quot;&gt;Qt Quick&lt;/a&gt; module, all QML objects that are to be visually rendered must derive from the &lt;a href=&quot;qml-qtquick-item&quot;&gt;Item&lt;/a&gt; type, as it is the base type for all visual objects in &lt;a href=&quot;qtquick-index&quot;&gt;Qt Quick&lt;/a&gt;. This &lt;a href=&quot;qml-qtquick-item&quot;&gt;Item&lt;/a&gt; type is implemented by the &lt;a href=&quot;qquickitem&quot;&gt;QQuickItem&lt;/a&gt; C++ class, which is provided by the &lt;a href=&quot;qtquick-index&quot;&gt;Qt Quick&lt;/a&gt; module. Therefore, this class should be subclassed when it is necessary to implement a visual type in C++ that can be integrated into a QML-based user interface.</source>
          <target state="translated">&lt;a href=&quot;qtquick-index&quot;&gt;Qt Quick&lt;/a&gt; 모듈로 사용자 인터페이스를 구축 할 때 시각적으로 렌더링되는 모든 QML 객체는 &lt;a href=&quot;qtquick-index&quot;&gt;Qt Quick의&lt;/a&gt; 모든 시각적 객체에 대한 기본 유형이므로 &lt;a href=&quot;qml-qtquick-item&quot;&gt;항목&lt;/a&gt; 유형 에서 파생되어야합니다 . 이 &lt;a href=&quot;qml-qtquick-item&quot;&gt;항목&lt;/a&gt; 유형은 &lt;a href=&quot;qtquick-index&quot;&gt;Qt Quick&lt;/a&gt; 모듈 에서 제공 하는 &lt;a href=&quot;qquickitem&quot;&gt;QQuickItem&lt;/a&gt; C ++ 클래스에 의해 구현됩니다 . 따라서이 클래스는 QML 기반 사용자 인터페이스에 통합 될 수있는 C ++에서 비주얼 유형을 구현해야 할 때 서브 클래스 화되어야합니다.</target>
        </trans-unit>
        <trans-unit id="573536b41f02e737bb17c87ec630c4949eebe25a" translate="yes" xml:space="preserve">
          <source>When built, the Qt Image Formats plugins are located as dynamic libraries in the runtime plugin directory (typically &lt;code&gt;plugins/imageformats&lt;/code&gt;), together with the default image format plugins. They may be deployed to the target system in the same way as other plugins, see the &lt;a href=&quot;https://doc.qt.io/qt-5.13/deployment-plugins.html&quot;&gt;Deploying Plugins&lt;/a&gt; documentation.</source>
          <target state="translated">빌드되면 Qt 이미지 형식 플러그인은 기본 이미지 형식 플러그인과 함께 런타임 플러그인 디렉토리 (일반적으로 &lt;code&gt;plugins/imageformats&lt;/code&gt; )에 동적 라이브러리로 위치 합니다. 다른 플러그인과 동일한 방식으로 대상 시스템에 배포 될 수 있습니다 . &lt;a href=&quot;https://doc.qt.io/qt-5.13/deployment-plugins.html&quot;&gt;플러그인 배포&lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1e398ca745e5b7e0d76604dae601be679e6ea3ec" translate="yes" xml:space="preserve">
          <source>When built, the Qt Image Formats plugins are located as dynamic libraries in the runtime plugin directory (typically &lt;code&gt;plugins/imageformats&lt;/code&gt;), together with the default image format plugins. They may be deployed to the target system in the same way as other plugins, see the &lt;a href=&quot;https://doc.qt.io/qt-5.15/deployment-plugins.html&quot;&gt;Deploying Plugins&lt;/a&gt; documentation.</source>
          <target state="translated">When built, the Qt Image Formats plugins are located as dynamic libraries in the runtime plugin directory (typically &lt;code&gt;plugins/imageformats&lt;/code&gt; ), together with the default image format plugins. They may be deployed to the target system in the same way as other plugins, see the &lt;a href=&quot;https://doc.qt.io/qt-5.15/deployment-plugins.html&quot;&gt;Deploying Plugins&lt;/a&gt; documentation.</target>
        </trans-unit>
        <trans-unit id="85c65eea35b46ad9adc8aa9df7e19d248494566d" translate="yes" xml:space="preserve">
          <source>When caching is enabled, &lt;a href=&quot;qfileinfo&quot;&gt;QFileInfo&lt;/a&gt; reads the file information from the file system the first time it's needed, but generally not later.</source>
          <target state="translated">캐싱이 활성화되면 &lt;a href=&quot;qfileinfo&quot;&gt;QFileInfo&lt;/a&gt; 는 파일 시스템에서 파일 정보를 처음 필요할 때 읽지 만 일반적으로 나중에 읽지 않습니다.</target>
        </trans-unit>
        <trans-unit id="63f929311e0c136280261b1674d609c45952f607" translate="yes" xml:space="preserve">
          <source>When caching is enabled, an item's &lt;a href=&quot;qgraphicsitem#paint&quot;&gt;paint&lt;/a&gt;() function will generally draw into an offscreen pixmap cache; for any subsequent repaint requests, the Graphics View framework will redraw from the cache. This approach works particularly well with QGLWidget, which stores all the cache as OpenGL textures.</source>
          <target state="translated">캐싱이 활성화되면 항목의 &lt;a href=&quot;qgraphicsitem#paint&quot;&gt;paint&lt;/a&gt; () 함수는 일반적으로 오프 스크린 픽스맵 캐시로 끌어들입니다. 이후의 다시 그리기 요청에 대해 기하 창 프레임 워크가 캐시에서 다시 그려집니다. 이 접근 방식은 모든 캐시를 OpenGL 텍스처로 저장하는 QGLWidget과 특히 잘 작동합니다.</target>
        </trans-unit>
        <trans-unit id="49d3402980e692757da4d25c7f056cfbcbc4090c" translate="yes" xml:space="preserve">
          <source>When calculating the size hint, &lt;a href=&quot;qgroupbox&quot;&gt;QGroupBox&lt;/a&gt; fetches three pixel metrics from the style: &lt;code&gt;PM_IndicatorWidth&lt;/code&gt;, &lt;code&gt;PM_CheckBoxLabelSpacing&lt;/code&gt;, and &lt;code&gt;PM_IndicatorHeight&lt;/code&gt;. &lt;a href=&quot;qgroupbox&quot;&gt;QGroupBox&lt;/a&gt; has the following style element tree:</source>
          <target state="translated">크기 힌트를 계산할 때, &lt;a href=&quot;qgroupbox&quot;&gt;QGroupBox가&lt;/a&gt; : 스타일에서 세 개의 픽셀의 메트릭 가져 &lt;code&gt;PM_IndicatorWidth&lt;/code&gt; , &lt;code&gt;PM_CheckBoxLabelSpacing&lt;/code&gt; 및 &lt;code&gt;PM_IndicatorHeight&lt;/code&gt; 을 . &lt;a href=&quot;qgroupbox&quot;&gt;QGroupBox&lt;/a&gt; 에는 다음과 같은 스타일 요소 트리가 있습니다.</target>
        </trans-unit>
        <trans-unit id="21b955b352a198452eb600dee09c98ed26feb22d" translate="yes" xml:space="preserve">
          <source>When calculating the slider's size hint, &lt;code&gt;PM_SliderThickness&lt;/code&gt; and &lt;code&gt;PM_SliderLength&lt;/code&gt; are queried from the style. As with scroll bars, the &lt;a href=&quot;qslider&quot;&gt;QSlider&lt;/a&gt; only lets the user move the handle if the mouse is within &lt;code&gt;PM_MaximumDragDistance&lt;/code&gt; from the slider bounds. When it draws itself, it creates the style option and calls &lt;code&gt;drawComplexControl()&lt;/code&gt; with &lt;code&gt;CC_Slider&lt;/code&gt;:</source>
          <target state="translated">슬라이더의 크기 힌트를 계산할 때 스타일에서 &lt;code&gt;PM_SliderThickness&lt;/code&gt; 및 &lt;code&gt;PM_SliderLength&lt;/code&gt; 가 쿼리됩니다. 스크롤 막대와 마찬가지로 &lt;a href=&quot;qslider&quot;&gt;QSlider&lt;/a&gt; 는 마우스가 슬라이더 경계 에서 &lt;code&gt;PM_MaximumDragDistance&lt;/code&gt; 내에있는 경우에만 사용자가 핸들을 이동할 수 있도록 합니다. 스스로 그릴 때 스타일 옵션을 만들고 &lt;code&gt;drawComplexControl()&lt;/code&gt; 하여 &lt;code&gt;CC_Slider&lt;/code&gt; () 을 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="1d40ba7fa0fde8f8ba84bf5f3be3928589a792a0" translate="yes" xml:space="preserve">
          <source>When called as a constructor, a new instance of the class will be created. Only constructors exposed by &lt;a href=&quot;qobject#Q_INVOKABLE&quot;&gt;Q_INVOKABLE&lt;/a&gt; will be visible from the script engine.</source>
          <target state="translated">생성자로 호출되면 클래스의 새 인스턴스가 생성됩니다. &lt;a href=&quot;qobject#Q_INVOKABLE&quot;&gt;Q_INVOKABLE&lt;/a&gt; 에 의해 노출 된 생성자 만 스크립트 엔진에서 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a17521f28b13cf15c64f48b6b71bf71a004d243" translate="yes" xml:space="preserve">
          <source>When called by Qt,</source>
          <target state="translated">Qt에 의해 호출되면</target>
        </trans-unit>
        <trans-unit id="914ad22810e57e0a208c0b39ab77807e77834ddd" translate="yes" xml:space="preserve">
          <source>When calling Java functions that might throw an exception, it is important that you check, handle and clear out the exception before continuing.</source>
          <target state="translated">예외가 발생할 수있는 Java 함수를 호출 할 때는 계속하기 전에 예외를 확인, 처리 및 지우는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="2a2e7ae65f87e90c76479fdc5ff2e4326b27c302" translate="yes" xml:space="preserve">
          <source>When calling this function, you can use the &lt;code&gt;SIGNAL()&lt;/code&gt; macro to pass a specific signal:</source>
          <target state="translated">이 함수를 호출 할 때 &lt;code&gt;SIGNAL()&lt;/code&gt; 매크로를 사용하여 특정 신호를 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="16fd68ecc7c1ca2e0fddbce432b5a471d518bb57" translate="yes" xml:space="preserve">
          <source>When changing properties with values that may be defined within a resource file,</source>
          <target state="translated">리소스 파일 내에 정의 할 수있는 값으로 속성을 변경할 때</target>
        </trans-unit>
        <trans-unit id="10172d955b561d851a1e685787b7d1f3cc20d57f" translate="yes" xml:space="preserve">
          <source>When changing the geometry, the widget, if visible, receives a move event (&lt;a href=&quot;qwidget#moveEvent&quot;&gt;moveEvent&lt;/a&gt;()) and/or a resize event (&lt;a href=&quot;qwidget#resizeEvent&quot;&gt;resizeEvent&lt;/a&gt;()) immediately. If the widget is not currently visible, it is guaranteed to receive appropriate events before it is shown.</source>
          <target state="translated">지오메트리를 변경할 때 위젯은 표시되는 경우 이동 이벤트 ( &lt;a href=&quot;qwidget#moveEvent&quot;&gt;moveEvent&lt;/a&gt; ()) 및 / 또는 크기 조정 이벤트 ( &lt;a href=&quot;qwidget#resizeEvent&quot;&gt;resizeEvent&lt;/a&gt; ())를 즉시받습니다. 위젯이 현재 표시되지 않으면 위젯이 표시되기 전에 적절한 이벤트를 수신하는 것이 보장됩니다.</target>
        </trans-unit>
        <trans-unit id="3dcc6167c4c8ec1a522615dcd2a97bfd046a2f80" translate="yes" xml:space="preserve">
          <source>When changing the position, the widget, if visible, receives a move event (&lt;a href=&quot;qwidget#moveEvent&quot;&gt;moveEvent&lt;/a&gt;()) immediately. If the widget is not currently visible, it is guaranteed to receive an event before it is shown.</source>
          <target state="translated">위치를 변경할 때 위젯이 표시되면 즉시 이동 이벤트 ( &lt;a href=&quot;qwidget#moveEvent&quot;&gt;moveEvent&lt;/a&gt; ())를받습니다. 위젯이 현재 표시되어 있지 않으면 표시되기 전에 이벤트를 수신 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d10e878de0de661440ee8d64ce4885521ddfa38a" translate="yes" xml:space="preserve">
          <source>When checking the signatures of its arguments, &lt;a href=&quot;qobject#connect&quot;&gt;QObject::connect&lt;/a&gt;() compares the data types literally. Thus, &lt;a href=&quot;qt#AlignmentFlag-enum&quot;&gt;Alignment&lt;/a&gt; and &lt;a href=&quot;qt#AlignmentFlag-enum&quot;&gt;Qt::Alignment&lt;/a&gt; are treated as two distinct types. To work around this limitation, make sure to fully qualify the data types when declaring signals and slots, and when establishing connections. For example:</source>
          <target state="translated">인수의 서명을 확인할 때 &lt;a href=&quot;qobject#connect&quot;&gt;QObject :: connect&lt;/a&gt; ()는 데이터 유형을 문자 그대로 비교합니다. 따라서 &lt;a href=&quot;qt#AlignmentFlag-enum&quot;&gt;Alignment&lt;/a&gt; 및 &lt;a href=&quot;qt#AlignmentFlag-enum&quot;&gt;Qt :: Alignment&lt;/a&gt; 는 두 가지 유형으로 처리됩니다. 이 제한 사항을 해결하려면 신호 및 슬롯을 선언 할 때와 연결을 설정할 때 데이터 유형을 완전히 규정하십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6c76cad238f22ed5e500ffc1b09ea0553c302ab3" translate="yes" xml:space="preserve">
          <source>When choosing a widget to use as a placeholder, it is useful to compare the API of the missing widget with those of standard Qt widgets. For specialized widgets that subclass standard classes, the obvious choice of placeholder is the base class of the custom widget; for example, &lt;a href=&quot;qslider&quot;&gt;QSlider&lt;/a&gt; might be used for specialized &lt;a href=&quot;qslider&quot;&gt;QSlider&lt;/a&gt; subclasses.</source>
          <target state="translated">자리 표시 자로 사용할 위젯을 선택할 때 누락 된 위젯의 API를 표준 Qt 위젯의 API와 비교하는 것이 유용합니다. 표준 클래스를 서브 클래스로 분류하는 특수 위젯의 경우 자리 표시 자 선택은 사용자 정의 위젯의 기본 클래스입니다. 예를 들어, &lt;a href=&quot;qslider&quot;&gt;QSlider&lt;/a&gt; 는 특수 &lt;a href=&quot;qslider&quot;&gt;QSlider&lt;/a&gt; 서브 클래스에 사용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="16d44be4536ee05b1e19ae36cfa871d577dd74c9" translate="yes" xml:space="preserve">
          <source>When client code handling the &lt;a href=&quot;qnetworkreply#redirected&quot;&gt;redirected&lt;/a&gt;() signal has verified the new URL, it emits this signal to allow the redirect to go ahead. This protocol applies to network requests whose redirects policy is set to &lt;a href=&quot;qnetworkrequest#RedirectPolicy-enum&quot;&gt;QNetworkRequest::UserVerifiedRedirectPolicy&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;qnetworkreply#redirected&quot;&gt;리디렉션 된&lt;/a&gt; () 신호를 처리하는 클라이언트 코드 가 새 URL을 확인하면이 신호를 내보내 리디렉션을 진행할 수 있습니다. 이 프로토콜은 리디렉션 정책이 &lt;a href=&quot;qnetworkrequest#RedirectPolicy-enum&quot;&gt;QNetworkRequest :: UserVerifiedRedirectPolicy로&lt;/a&gt; 설정된 네트워크 요청에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="a496bd66ef281f3e102e4c15780975eb23b209d8" translate="yes" xml:space="preserve">
          <source>When combined with Subdirectories, this flag enables iterating through all subdirectories of the assigned path, following all symbolic links. Symbolic link loops (e.g., &quot;link&quot; =&amp;gt; &quot;.&quot; or &quot;link&quot; =&amp;gt; &quot;..&quot;) are automatically detected and ignored.</source>
          <target state="translated">서브 디렉토리와 결합 될 때이 플래그를 사용하면 모든 기호 링크를 따라 지정된 경로의 모든 서브 디렉토리를 반복 할 수 있습니다. 심볼릭 링크 루프 (예 : &quot;link&quot;=&amp;gt; &quot;.&quot;또는 &quot;link&quot;=&amp;gt; &quot;..&quot;)는 자동으로 감지되어 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="b152fe7b18bfb7ca1bd752cf950491f1cf2f642f" translate="yes" xml:space="preserve">
          <source>When communicating over a bus, applications obtain what is called a &quot;service name&quot;: it is how that application chooses to be known by other applications on the same bus. The service names are brokered by the D-Bus bus daemon and are used to route messages from one application to another. An analogous concept to service names are IP addresses and hostnames: a computer normally has one IP address and may have one or more hostnames associated with it, according to the services that it provides to the network.</source>
          <target state="translated">버스를 통해 통신 할 때 응용 프로그램은 &quot;서비스 이름&quot;이라는 것을 얻습니다. 동일한 버스의 다른 응용 프로그램이 해당 응용 프로그램을 알도록 선택하는 방법입니다. 서비스 이름은 D-Bus 버스 데몬에 의해 중개되며 한 응용 프로그램에서 다른 응용 프로그램으로 메시지를 라우팅하는 데 사용됩니다. 서비스 이름과 유사한 개념은 IP 주소 및 호스트 이름입니다. 컴퓨터에는 일반적으로 하나의 IP 주소가 있으며 네트워크에 제공하는 서비스에 따라 하나 이상의 IP 주소가 연결될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="504bd4b97e16da478eebaa7d208820d715529e5e" translate="yes" xml:space="preserve">
          <source>When comparing floating-point types (&lt;code&gt;float&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, and &lt;code&gt;qfloat16&lt;/code&gt;), &lt;a href=&quot;qtglobal#qFuzzyCompare&quot;&gt;qFuzzyCompare&lt;/a&gt;() is used for finite values. If &lt;a href=&quot;qtglobal#qFuzzyIsNull&quot;&gt;qFuzzyIsNull&lt;/a&gt;() is true for both values, they are also considered equal. Infinities match if they have the same sign, and any NaN as actual value matches with any NaN as expected value (even though NaN != NaN, even when they're identical).</source>
          <target state="translated">When comparing floating-point types ( &lt;code&gt;float&lt;/code&gt; , &lt;code&gt;double&lt;/code&gt; , and &lt;code&gt;qfloat16&lt;/code&gt; ), &lt;a href=&quot;qtglobal#qFuzzyCompare&quot;&gt;qFuzzyCompare&lt;/a&gt;() is used for finite values. If &lt;a href=&quot;qtglobal#qFuzzyIsNull&quot;&gt;qFuzzyIsNull&lt;/a&gt;() is true for both values, they are also considered equal. Infinities match if they have the same sign, and any NaN as actual value matches with any NaN as expected value (even though NaN != NaN, even when they're identical).</target>
        </trans-unit>
        <trans-unit id="4ae6fe5944e7f5e553d8111bc79c5d3e6ba7dace" translate="yes" xml:space="preserve">
          <source>When complete is &lt;code&gt;true&lt;/code&gt;, any interactive items declared in &lt;code&gt;left&lt;/code&gt;, &lt;code&gt;right&lt;/code&gt;, or &lt;code&gt;behind&lt;/code&gt; will receive mouse events.</source>
          <target state="translated">complete가 &lt;code&gt;true&lt;/code&gt; 인 경우 , &lt;code&gt;left&lt;/code&gt; , &lt;code&gt;right&lt;/code&gt; 또는 &lt;code&gt;behind&lt;/code&gt; 선언 된 모든 대화 형 항목은 마우스 이벤트를 수신합니다.</target>
        </trans-unit>
        <trans-unit id="fbdde588f2333734eac7dbf667c998b588ec285f" translate="yes" xml:space="preserve">
          <source>When configured with &lt;code&gt;-opengl dynamic&lt;/code&gt;, neither Qt nor the applications built using &lt;code&gt;qmake&lt;/code&gt; will link to the opengl32 (standard desktop OpenGL) or QtANGLE libraries. Instead, the appropriate library is chosen at runtime. By default, Qt will determine whether the system's opengl32.dll provides OpenGL 2 functions. If these are present, opengl32.dll is used, otherwise the ANGLE libraries (libEGL.dll and libGLESv2.dll) will be used. In case the ANGLE libraries are missing or initialization fails for some reason, an additional fallback is attempted by trying to load &lt;code&gt;opengl32sw.dll&lt;/code&gt;. See below for details.</source>
          <target state="translated">When configured with &lt;code&gt;-opengl dynamic&lt;/code&gt; , neither Qt nor the applications built using &lt;code&gt;qmake&lt;/code&gt; will link to the opengl32 (standard desktop OpenGL) or QtANGLE libraries. Instead, the appropriate library is chosen at runtime. By default, Qt will determine whether the system's opengl32.dll provides OpenGL 2 functions. If these are present, opengl32.dll is used, otherwise the ANGLE libraries (libEGL.dll and libGLESv2.dll) will be used. In case the ANGLE libraries are missing or initialization fails for some reason, an additional fallback is attempted by trying to load &lt;code&gt;opengl32sw.dll&lt;/code&gt; . See below for details.</target>
        </trans-unit>
        <trans-unit id="1731f47b651e66fd70df77e065cbada56a586326" translate="yes" xml:space="preserve">
          <source>When conflicts arise, the widget's own style sheet is always preferred to any inherited style sheet, irrespective of the specificity of the conflicting rules. Likewise, the parent widget's style sheet is preferred to the grandparent's, etc.</source>
          <target state="translated">충돌이 발생하면 충돌 규칙의 특수성에 관계없이 위젯 자체 스타일 시트가 상속 된 스타일 시트보다 항상 선호됩니다. 마찬가지로 부모 위젯의 스타일 시트는 조부모 등이 선호합니다.</target>
        </trans-unit>
        <trans-unit id="0ee6235e959f1c122804e1ee8f220bac499a0e14" translate="yes" xml:space="preserve">
          <source>When connecting to an ODBC datasource, you should pass the name of the ODBC datasource to the &lt;a href=&quot;qsqldatabase#setDatabaseName&quot;&gt;QSqlDatabase::setDatabaseName&lt;/a&gt;() function, rather than the actual database name.</source>
          <target state="translated">ODBC 데이터 소스에 연결할 때 실제 데이터베이스 이름이 아닌 ODBC 데이터 소스의 이름을 &lt;a href=&quot;qsqldatabase#setDatabaseName&quot;&gt;QSqlDatabase :: setDatabaseName&lt;/a&gt; () 함수에 전달해야합니다 .</target>
        </trans-unit>
        <trans-unit id="2f2cbe1c8aedff9ebebfb5ee6584df1a788d8183" translate="yes" xml:space="preserve">
          <source>When connecting to signals in QML, the usual way is to create an &quot;on&amp;lt;Signal&amp;gt;&quot; handler that reacts when a signal is received, like this:</source>
          <target state="translated">QML에서 신호에 연결할 때 일반적인 방법은 다음과 같이 신호가 수신 될 때 반응하는 &quot;on &amp;lt;Signal&amp;gt;&quot;핸들러를 작성하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="50ad6900d430167293c28de8c15b55b92afdb96d" translate="yes" xml:space="preserve">
          <source>When considering the above example, there are several parties involved:</source>
          <target state="translated">위의 예를 고려할 때 관련된 여러 당사자가 있습니다.</target>
        </trans-unit>
        <trans-unit id="490cc9bd30b6bceb26457d2a8efbb90a6b3f5fe5" translate="yes" xml:space="preserve">
          <source>When control returns to the main event loop, all events that are stored in the queue will be sent using the &lt;a href=&quot;qcoreapplication#notify&quot;&gt;notify&lt;/a&gt;() function.</source>
          <target state="translated">제어가 기본 이벤트 루프로 리턴되면 대기 행렬에 저장된 모든 이벤트는 &lt;a href=&quot;qcoreapplication#notify&quot;&gt;notify&lt;/a&gt; () 기능을 사용하여 전송 됩니다.</target>
        </trans-unit>
        <trans-unit id="a617205988b57dea8c2826ac4ae64f29a514cd0a" translate="yes" xml:space="preserve">
          <source>When created or cleared, the line edit will be filled with a copy of the input mask string where the meta characters have been removed, and the mask characters have been replaced with the</source>
          <target state="translated">When created or cleared, the line edit will be filled with a copy of the input mask string where the meta characters have been removed, and the mask characters have been replaced with the</target>
        </trans-unit>
        <trans-unit id="0aae57f52813e54337f9b3ba12b5d957d0e7706b" translate="yes" xml:space="preserve">
          <source>When creating a &lt;a href=&quot;qpagesize&quot;&gt;QPageSize&lt;/a&gt; using a custom &lt;a href=&quot;qsize&quot;&gt;QSize&lt;/a&gt; you can choose if you want &lt;a href=&quot;qpagesize&quot;&gt;QPageSize&lt;/a&gt; to try match the size to a standard page size. By default QPaperSize uses a &lt;a href=&quot;qpagesize#SizeMatchPolicy-enum&quot;&gt;FuzzyMatch&lt;/a&gt; mode where it will match a given page size to a standard page size if it falls within 3 postscript points of a defined standard size. You can override this to request only an exact match but this is not recommended as conversions between units can easily lose 3 points and result in incorrect page sizes.</source>
          <target state="translated">사용자 정의 &lt;a href=&quot;qsize&quot;&gt;QSize&lt;/a&gt; 를 사용하여 &lt;a href=&quot;qpagesize&quot;&gt;QPageSize&lt;/a&gt; 를 생성 할 때 QPageSize 가 표준 페이지 크기와 크기를 일치 &lt;a href=&quot;qpagesize&quot;&gt;시키&lt;/a&gt; 도록 선택할 수 있습니다 . 기본적으로 QPaperSize는 지정된 페이지 크기가 정의 된 표준 크기의 3 개의 포스트 스크립트 포인트 내에있는 경우 지정된 페이지 크기를 표준 페이지 크기와 일치 시키는 &lt;a href=&quot;qpagesize#SizeMatchPolicy-enum&quot;&gt;FuzzyMatch&lt;/a&gt; 모드를 사용합니다 . 이 옵션을 재정의하면 정확히 일치하는 항목 만 요청할 수 있지만 단위 간 변환시 쉽게 3 점을 잃고 페이지 크기가 잘못 될 수 있으므로 권장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9ac98a689f6faf1b4d4a231d05990beaabb87945" translate="yes" xml:space="preserve">
          <source>When creating a &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; object, you must pass the name of your company or organization as well as the name of your application. For example, if your product is called Star Runner and your company is called MySoft, you would construct the &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; object as follows:</source>
          <target state="translated">&lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; 객체를 생성 할 때는 회사 또는 조직의 이름과 응용 프로그램의 이름을 전달해야합니다. 예를 들어, 제품 이름이 Star Runner이고 회사 이름이 MySoft 인 경우 다음과 같이 &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; 객체를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="acdb8c3cb9399aef996527a1d8f6a87298ec82bb" translate="yes" xml:space="preserve">
          <source>When creating a &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; to contain a URL from a &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; or a char*, always use &lt;a href=&quot;qstring#fromUtf8&quot;&gt;QString::fromUtf8&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; 또는 char * 의 URL을 포함 하도록 &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; 을 작성할 때는 항상 &lt;a href=&quot;qstring#fromUtf8&quot;&gt;QString :: fromUtf8&lt;/a&gt; ()을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="bbe42e39685b882db1d3c259aea5067777985606" translate="yes" xml:space="preserve">
          <source>When creating a QPageSize using a custom &lt;a href=&quot;qsize&quot;&gt;QSize&lt;/a&gt; you can choose if you want QPageSize to try match the size to a standard page size. By default QPaperSize uses a &lt;a href=&quot;qpagesize#SizeMatchPolicy-enum&quot;&gt;FuzzyMatch&lt;/a&gt; mode where it will match a given page size to a standard page size if it falls within 3 postscript points of a defined standard size. You can override this to request only an exact match but this is not recommended as conversions between units can easily lose 3 points and result in incorrect page sizes.</source>
          <target state="translated">When creating a QPageSize using a custom &lt;a href=&quot;qsize&quot;&gt;QSize&lt;/a&gt; you can choose if you want QPageSize to try match the size to a standard page size. By default QPaperSize uses a &lt;a href=&quot;qpagesize#SizeMatchPolicy-enum&quot;&gt;FuzzyMatch&lt;/a&gt; mode where it will match a given page size to a standard page size if it falls within 3 postscript points of a defined standard size. You can override this to request only an exact match but this is not recommended as conversions between units can easily lose 3 points and result in incorrect page sizes.</target>
        </trans-unit>
        <trans-unit id="2f4afccd147883bbee26d5e202b95e0e3a068c0b" translate="yes" xml:space="preserve">
          <source>When creating a QSettings object, you must pass the name of your company or organization as well as the name of your application. For example, if your product is called Star Runner and your company is called MySoft, you would construct the QSettings object as follows:</source>
          <target state="translated">When creating a QSettings object, you must pass the name of your company or organization as well as the name of your application. For example, if your product is called Star Runner and your company is called MySoft, you would construct the QSettings object as follows:</target>
        </trans-unit>
        <trans-unit id="5d773d0579d473100a4c07b005ea00f7960a8020" translate="yes" xml:space="preserve">
          <source>When creating a custom help viewer the viewer can be configured by writing a custom collection file which could contain various keywords to be used to configure the help engine. These keywords and values and their meaning can be found in the help information for &lt;a href=&quot;https://doc.qt.io/qt-5.13/assistant-custom-help-viewer.html&quot;&gt;creating a custom help collection file&lt;/a&gt; for Assistant.</source>
          <target state="translated">사용자 정의 도움말 뷰어를 작성할 때 도움말 엔진을 구성하는 데 사용할 다양한 키워드를 포함 할 수있는 사용자 정의 콜렉션 파일을 작성하여 뷰어를 구성 할 수 있습니다. 이러한 키워드와 값 및 의미는 Assistant &lt;a href=&quot;https://doc.qt.io/qt-5.13/assistant-custom-help-viewer.html&quot;&gt;의 사용자 정의 도움말 콜렉션 파일 작성을&lt;/a&gt; 위한 도움말 정보에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ed02b2b618cca08d2bfb9bef8750c41344446144" translate="yes" xml:space="preserve">
          <source>When creating a custom help viewer the viewer can be configured by writing a custom collection file which could contain various keywords to be used to configure the help engine. These keywords and values and their meaning can be found in the help information for &lt;a href=&quot;https://doc.qt.io/qt-5.15/assistant-custom-help-viewer.html&quot;&gt;creating a custom help collection file&lt;/a&gt; for Assistant.</source>
          <target state="translated">When creating a custom help viewer the viewer can be configured by writing a custom collection file which could contain various keywords to be used to configure the help engine. These keywords and values and their meaning can be found in the help information for &lt;a href=&quot;https://doc.qt.io/qt-5.15/assistant-custom-help-viewer.html&quot;&gt;creating a custom help collection file&lt;/a&gt; for Assistant.</target>
        </trans-unit>
        <trans-unit id="65bcfdb381290d9bee6e16ff1d2353f984f24d0f" translate="yes" xml:space="preserve">
          <source>When creating a custom item, item coordinates are all you need to worry about; &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; and &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; will perform all transformations for you. This makes it very easy to implement custom items. For example, if you receive a mouse press or a drag enter event, the event position is given in item coordinates. The &lt;a href=&quot;qgraphicsitem#contains&quot;&gt;QGraphicsItem::contains&lt;/a&gt;() virtual function, which returns &lt;code&gt;true&lt;/code&gt; if a certain point is inside your item, and false otherwise, takes a point argument in item coordinates. Similarly, an item's bounding rect and shape are in item coordinates.</source>
          <target state="translated">커스텀 아이템을 생성 할 때, 아이템 좌표 만 걱정하면됩니다. &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; 및 &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; 가 모든 변환을 수행합니다. 따라서 사용자 정의 항목을 매우 쉽게 구현할 수 있습니다. 예를 들어, 마우스 누르기 또는 드래그 입력 이벤트가 수신되면 이벤트 위치가 항목 좌표로 제공됩니다. &lt;a href=&quot;qgraphicsitem#contains&quot;&gt;QGraphicsItem :: 포함&lt;/a&gt; () 가상 반환 기능, &lt;code&gt;true&lt;/code&gt; 특정 지점이 당신의 품목 내부에있는 경우와 그렇지 않은 경우는 false 항목의 좌표로 포인트 인수를합니다. 마찬가지로 항목의 경계 사각형과 모양은 항목 좌표에 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e08552b85a95188c1665a4dafe6b362ee82355f" translate="yes" xml:space="preserve">
          <source>When creating a map from sorted data inserting the largest key first with &lt;a href=&quot;qmap#constBegin&quot;&gt;constBegin&lt;/a&gt;() is faster than inserting in sorted order with &lt;a href=&quot;qmap#constEnd&quot;&gt;constEnd&lt;/a&gt;(), since &lt;a href=&quot;qmap#constEnd&quot;&gt;constEnd&lt;/a&gt;() - 1 (which is needed to check if the hint is valid) needs &lt;a href=&quot;containers#logarithmic-time&quot;&gt;logarithmic time&lt;/a&gt;.</source>
          <target state="translated">먼저 가장 큰 키를 삽입 소트 데이터로부터지도를 작성할 때 &lt;a href=&quot;qmap#constBegin&quot;&gt;constBegin하면&lt;/a&gt; () 속도로 정렬 된 순서로 삽입보다 &lt;a href=&quot;qmap#constEnd&quot;&gt;constEnd&lt;/a&gt; 때문에, () &lt;a href=&quot;qmap#constEnd&quot;&gt;constEnd&lt;/a&gt; (힌트가 유효한지 확인하기 위해 필요한 1)의 요구 (-) &lt;a href=&quot;containers#logarithmic-time&quot;&gt;대수 시간&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="da378fc2f1f498e22d7abb9c20072ff5f0d3d3c4" translate="yes" xml:space="preserve">
          <source>When creating a new model for an existing data structure, it is important to consider which type of model should be used to provide an interface onto the data. If the data structure can be represented as a list or table of items, you can subclass &lt;a href=&quot;qabstractlistmodel&quot;&gt;QAbstractListModel&lt;/a&gt; or &lt;a href=&quot;qabstracttablemodel&quot;&gt;QAbstractTableModel&lt;/a&gt; since these classes provide suitable default implementations for many functions.</source>
          <target state="translated">기존 데이터 구조에 대한 새 모델을 작성할 때 데이터에 대한 인터페이스를 제공하기 위해 사용해야하는 모델 유형을 고려해야합니다. 데이터 구조를 항목 목록 또는 테이블로 표시 할 수있는 경우, &lt;a href=&quot;qabstractlistmodel&quot;&gt;QAbstractListModel&lt;/a&gt; 또는 &lt;a href=&quot;qabstracttablemodel&quot;&gt;QAbstractTableModel을&lt;/a&gt; 서브 클래스로 작성할 수 있습니다. 이러한 클래스는 많은 함수에 적합한 기본 구현을 제공하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="8500b569b9e4d2538da567830ca173bb7a100287" translate="yes" xml:space="preserve">
          <source>When creating a property binding from JavaScript, the &lt;code&gt;this&lt;/code&gt; keyword can be used to refer to the object which receives the binding. This is helpful for resolving ambiguities with property names.</source>
          <target state="translated">JavaScript에서 속성 바인딩을 만들 때 &lt;code&gt;this&lt;/code&gt; 키워드를 사용하여 바인딩을받는 객체를 참조 할 수 있습니다. 속성 이름으로 모호성을 해결하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="a4acef9238768bf956778e2a447e1184f2109294" translate="yes" xml:space="preserve">
          <source>When creating an &lt;a href=&quot;qt3drender-qeffect&quot;&gt;QEffect&lt;/a&gt; that targets several versions of a graphics API, it is useful to create several &lt;a href=&quot;qt3drender-qtechnique&quot;&gt;QTechnique&lt;/a&gt; nodes each with a &lt;a href=&quot;qt3drender-qtechnique#graphicsApiFilter-prop&quot;&gt;graphicsApiFilter&lt;/a&gt; set to match one of the targeted GL versions. At runtime, the Qt3D renderer will select the most appropriate &lt;a href=&quot;qt3drender-qtechnique&quot;&gt;QTechnique&lt;/a&gt; based on which graphics API versions are supported and (if specified) the &lt;a href=&quot;qt3drender-qfilterkey&quot;&gt;QFilterKey&lt;/a&gt; nodes that satisfy a given &lt;a href=&quot;qt3drender-qtechniquefilter&quot;&gt;QTechniqueFilter&lt;/a&gt; in the FrameGraph.</source>
          <target state="translated">여러 버전의 그래픽 API를 대상으로 하는 &lt;a href=&quot;qt3drender-qeffect&quot;&gt;QEffect&lt;/a&gt; 를 작성할 때 대상 GL 버전 중 하나와 일치하도록 &lt;a href=&quot;qt3drender-qtechnique#graphicsApiFilter-prop&quot;&gt;graphicsApiFilter가&lt;/a&gt; 각각 설정된 여러 &lt;a href=&quot;qt3drender-qtechnique&quot;&gt;QTechnique&lt;/a&gt; 노드 를 작성하는 것이 유용 합니다 . 런타임시 Qt3D 렌더러 는 지원되는 그래픽 API 버전 및 &lt;a href=&quot;qt3drender-qtechniquefilter&quot;&gt;프레임 그래프&lt;/a&gt; 에서 지정된 QTechniqueFilter 를 만족하는 &lt;a href=&quot;qt3drender-qfilterkey&quot;&gt;QFilterKey&lt;/a&gt; 노드 (지정된 경우)에 따라 가장 적합한 &lt;a href=&quot;qt3drender-qtechnique&quot;&gt;QTechnique를&lt;/a&gt; 선택합니다 .</target>
        </trans-unit>
        <trans-unit id="74fe2d261fd9daef09d6ad1cf9640099d84a6e3f" translate="yes" xml:space="preserve">
          <source>When creating an &lt;a href=&quot;qt3drender-qeffect&quot;&gt;QEffect&lt;/a&gt; that targets several versions of a graphics API, it is useful to create several QTechnique nodes each with a &lt;a href=&quot;qt3drender-qtechnique#graphicsApiFilter-prop&quot;&gt;graphicsApiFilter&lt;/a&gt; set to match one of the targeted GL versions. At runtime, the Qt3D renderer will select the most appropriate QTechnique based on which graphics API versions are supported and (if specified) the &lt;a href=&quot;qt3drender-qfilterkey&quot;&gt;QFilterKey&lt;/a&gt; nodes that satisfy a given &lt;a href=&quot;qt3drender-qtechniquefilter&quot;&gt;QTechniqueFilter&lt;/a&gt; in the FrameGraph.</source>
          <target state="translated">When creating an &lt;a href=&quot;qt3drender-qeffect&quot;&gt;QEffect&lt;/a&gt; that targets several versions of a graphics API, it is useful to create several QTechnique nodes each with a &lt;a href=&quot;qt3drender-qtechnique#graphicsApiFilter-prop&quot;&gt;graphicsApiFilter&lt;/a&gt; set to match one of the targeted GL versions. At runtime, the Qt3D renderer will select the most appropriate QTechnique based on which graphics API versions are supported and (if specified) the &lt;a href=&quot;qt3drender-qfilterkey&quot;&gt;QFilterKey&lt;/a&gt; nodes that satisfy a given &lt;a href=&quot;qt3drender-qtechniquefilter&quot;&gt;QTechniqueFilter&lt;/a&gt; in the FrameGraph.</target>
        </trans-unit>
        <trans-unit id="bd5a5c9f752ad47937d6434e44c62e97758c6944" translate="yes" xml:space="preserve">
          <source>When creating an Effect that targets several versions of a graphics API, it is useful to create several Technique nodes each with a &lt;a href=&quot;qml-qt3d-render-technique#graphicsApiFilter-prop&quot;&gt;graphicsApiFilter&lt;/a&gt; set to match one of the targeted versions. At runtime, the Qt3D renderer will select the most appropriate Technique based on which graphics API versions are supported and (if specified) the &lt;a href=&quot;qml-qt3d-render-filterkey&quot;&gt;FilterKey&lt;/a&gt; nodes that satisfy a given &lt;a href=&quot;qml-qt3d-render-techniquefilter&quot;&gt;TechniqueFilter&lt;/a&gt; in the FrameGraph.</source>
          <target state="translated">여러 버전의 그래픽 API를 대상으로하는 Effect를 만들 때 각각 대상 버전 중 하나와 일치하도록 &lt;a href=&quot;qml-qt3d-render-technique#graphicsApiFilter-prop&quot;&gt;graphicsApiFilter가&lt;/a&gt; 설정된 여러 Technique 노드를 만드는 것이 좋습니다. 런타임시 Qt3D 렌더러는 지원되는 그래픽 API 버전과 프레임 그래프 에서 지정된 &lt;a href=&quot;qml-qt3d-render-techniquefilter&quot;&gt;TechniqueFilter&lt;/a&gt; 를 충족하는 &lt;a href=&quot;qml-qt3d-render-filterkey&quot;&gt;FilterKey&lt;/a&gt; 노드 (지정된 경우)를 기반으로 가장 적합한 기법을 선택합니다 .</target>
        </trans-unit>
        <trans-unit id="f722c75ee9a2de387fc8f2d451fedcecaaa57d68" translate="yes" xml:space="preserve">
          <source>When creating custom items, use the new &lt;a href=&quot;qsgrectanglenode&quot;&gt;QSGRectangleNode&lt;/a&gt; and &lt;a href=&quot;qsgimagenode&quot;&gt;QSGImageNode&lt;/a&gt; classes. These replace the now deprecated QSGSimpleRectNode and QSGSimpleTextureNode. Unlike their predecessors, these new classes are interfaces, and implementations are created via the &lt;a href=&quot;qquickwindow#createRectangleNode&quot;&gt;QQuickWindow::createRectangleNode&lt;/a&gt;() and &lt;a href=&quot;qquickwindow#createImageNode&quot;&gt;QQuickWindow::createImageNode&lt;/a&gt;() factory functions.</source>
          <target state="translated">사용자 정의 항목을 작성할 때 새로운 &lt;a href=&quot;qsgrectanglenode&quot;&gt;QSGRectangleNode&lt;/a&gt; 및 &lt;a href=&quot;qsgimagenode&quot;&gt;QSGImageNode&lt;/a&gt; 클래스를 사용하십시오 . 이것은 더 이상 사용되지 않는 QSGSimpleRectNode 및 QSGSimpleTextureNode를 대체합니다. 이전 모델과 달리,이 새로운 클래스는 인터페이스이며 구현은 &lt;a href=&quot;qquickwindow#createRectangleNode&quot;&gt;QQuickWindow :: createRectangleNode&lt;/a&gt; () 및 &lt;a href=&quot;qquickwindow#createImageNode&quot;&gt;QQuickWindow :: createImageNode&lt;/a&gt; () 팩토리 함수 를 통해 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="ad1ca55154d7a13bb0a82b3ada46b98f3f2fa71a" translate="yes" xml:space="preserve">
          <source>When creating textures via C++ scene graph APIs like &lt;a href=&quot;qquickwindow#createTextureFromImage&quot;&gt;QQuickWindow::createTextureFromImage&lt;/a&gt;(), 32-bit formats won't involve any conversion, they'll map directly to the corresponding &lt;code&gt;R8G8B8A8_UNORM&lt;/code&gt; or &lt;code&gt;B8G8R8A8_UNORM&lt;/code&gt; format. Everything else will trigger a &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt;-based format conversion on the CPU first.</source>
          <target state="translated">&lt;a href=&quot;qquickwindow#createTextureFromImage&quot;&gt;QQuickWindow :: createTextureFromImage&lt;/a&gt; () 와 같은 C ++ 장면 그래프 API를 통해 텍스처를 만들 때 32 비트 형식은 변환이 필요하지 않으며 해당 &lt;code&gt;R8G8B8A8_UNORM&lt;/code&gt; 또는 &lt;code&gt;B8G8R8A8_UNORM&lt;/code&gt; 형식으로 직접 매핑 됩니다. 다른 모든 것은 먼저 CPU에서 &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt; 기반 형식 변환을 트리거합니다 .</target>
        </trans-unit>
        <trans-unit id="ac8c6318f0656d7823865940204d8f34b4f9e2dc" translate="yes" xml:space="preserve">
          <source>When creating user interfaces with Qt, particularly those with specialized controls and features, developers sometimes need to create new data types that can be used alongside or in place of Qt's existing set of value types.</source>
          <target state="translated">Qt로 사용자 인터페이스, 특히 특수한 컨트롤과 기능이있는 사용자 인터페이스를 만들 때 개발자는 Qt의 기존 값 유형과 함께 또는 대신 사용할 수있는 새로운 데이터 유형을 만들어야하는 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c5cad017177801067fb33fec32abbde43a2a0a2" translate="yes" xml:space="preserve">
          <source>When creating visual scenes with Qt Quick, it is important to understand the concept of the</source>
          <target state="translated">Qt Quick을 사용하여 시각적 장면을 만들 때 개념을 이해하는 것이 중요합니다</target>
        </trans-unit>
        <trans-unit id="d8deccb0e684f6ccb3eb82d7b6672c38b9e7d190" translate="yes" xml:space="preserve">
          <source>When data is transferred from C++ to QML, the ownership of the data always remains with C++. The exception to this rule is when a &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; is returned from an explicit C++ method call: in this case, the QML engine assumes ownership of the object, unless the ownership of the object has explicitly been set to remain with C++ by invoking &lt;a href=&quot;qqmlengine#setObjectOwnership&quot;&gt;QQmlEngine::setObjectOwnership&lt;/a&gt;() with &lt;a href=&quot;qqmlengine#ObjectOwnership-enum&quot;&gt;QQmlEngine::CppOwnership&lt;/a&gt; specified.</source>
          <target state="translated">데이터가 C ++에서 QML로 전송 될 때 데이터 소유권은 항상 C ++로 유지됩니다. 이 규칙의 예외 는 명시 적 C ++ 메소드 호출에서 &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 가 리턴되는 경우입니다.이 경우 &lt;a href=&quot;qqmlengine#setObjectOwnership&quot;&gt;QQmlEngine ::&lt;/a&gt; 을 호출하여 오브젝트의 소유권이 명시 적으로 C ++로 유지되도록 설정되지 않은 한 QML 엔진은 오브젝트의 소유권을 가정합니다. &lt;a href=&quot;qqmlengine#ObjectOwnership-enum&quot;&gt;QQmlEngine :: CppOwnership이&lt;/a&gt; 지정된 setObjectOwnership () .</target>
        </trans-unit>
        <trans-unit id="833825b15200463ac0253e002ab1f7246eda7871" translate="yes" xml:space="preserve">
          <source>When data values are exchanged between QML and C++, they are converted by the QML engine to have the correct data types as appropriate for use in QML or C++. This requires the exchanged data to be of a type that is recognizable by the engine.</source>
          <target state="translated">QML과 C ++간에 데이터 값이 교환되면 QML 엔진에서 QML 또는 C ++에 사용하기에 적합한 데이터 유형을 갖도록 변환합니다. 이를 위해서는 교환 된 데이터가 엔진이 인식 할 수있는 유형이어야합니다.</target>
        </trans-unit>
        <trans-unit id="88de44478b8ed2bd120794db0b7d5b455c64de25" translate="yes" xml:space="preserve">
          <source>When dealing with shared objects, there are two ways of copying an object. We usually speak about</source>
          <target state="translated">공유 객체를 처리 할 때 객체를 복사하는 두 가지 방법이 있습니다. 우리는 보통</target>
        </trans-unit>
        <trans-unit id="880f2e372d228c68b46fdc809205b92833a51398" translate="yes" xml:space="preserve">
          <source>When dealing with the D-Bus bus service or with remote applications over D-Bus, a number of error conditions can happen. This error conditions are sometimes signalled by a returned error value or by a &lt;a href=&quot;qdbuserror&quot;&gt;QDBusError&lt;/a&gt;.</source>
          <target state="translated">D-Bus 버스 서비스 또는 D-Bus를 통한 원격 애플리케이션을 처리 할 때 여러 가지 오류 조건이 발생할 수 있습니다. 이 오류 조건은 때때로 리턴 된 오류 값 또는 &lt;a href=&quot;qdbuserror&quot;&gt;QDBusError에&lt;/a&gt; 의해 표시 됩니다.</target>
        </trans-unit>
        <trans-unit id="74f0ca37c9cc12fbb98f9f5310dd3caadcb27473" translate="yes" xml:space="preserve">
          <source>When dealing with the D-Bus bus service or with remote applications over D-Bus, a number of error conditions can happen. This error conditions are sometimes signalled by a returned error value or by a QDBusError.</source>
          <target state="translated">When dealing with the D-Bus bus service or with remote applications over D-Bus, a number of error conditions can happen. This error conditions are sometimes signalled by a returned error value or by a QDBusError.</target>
        </trans-unit>
        <trans-unit id="37e1660403429a1797eb4c0aeb989abc574ce656" translate="yes" xml:space="preserve">
          <source>When declaring properties in QML, it's easy and convenient to use the &quot;var&quot; type:</source>
          <target state="translated">QML에서 속성을 선언 할 때 &quot;var&quot;유형을 사용하는 것이 쉽고 편리합니다.</target>
        </trans-unit>
        <trans-unit id="499464bd993035896d274262364a35979c761cc8" translate="yes" xml:space="preserve">
          <source>When decoding Base64-encoded data, ignores errors in the input; invalid characters are simply skipped. This enum value has been added in Qt 5.15.</source>
          <target state="translated">When decoding Base64-encoded data, ignores errors in the input; invalid characters are simply skipped. This enum value has been added in Qt 5.15.</target>
        </trans-unit>
        <trans-unit id="ee82abeedacfd233e0f6aece53f4beda554b1af8" translate="yes" xml:space="preserve">
          <source>When decoding Base64-encoded data, stops at the first decoding error. This enum value has been added in Qt 5.15.</source>
          <target state="translated">When decoding Base64-encoded data, stops at the first decoding error. This enum value has been added in Qt 5.15.</target>
        </trans-unit>
        <trans-unit id="f6c7b9b1412f471c238127a4b55f7698c8fb1c87" translate="yes" xml:space="preserve">
          <source>When defining your own needle component, the only properties that the style requires you to set are the &lt;a href=&quot;qml-qtquick-item#implicitWidth-prop&quot;&gt;implicitWidth&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-item#implicitHeight-prop&quot;&gt;implicitHeight&lt;/a&gt;.</source>
          <target state="translated">자체 바늘 구성 요소를 정의 할 때 스타일에서 설정해야하는 유일한 속성은 &lt;a href=&quot;qml-qtquick-item#implicitWidth-prop&quot;&gt;implicitWidth&lt;/a&gt; 및 &lt;a href=&quot;qml-qtquick-item#implicitHeight-prop&quot;&gt;implicitHeight&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a11f2000ac0edf67c2b20ae00acff6fb70863dbe" translate="yes" xml:space="preserve">
          <source>When deploying Qt applications built using Visual Studio 2005, or later, make sure that the manifest file that was created when the application was linked is handled correctly. This is handled automatically for projects that generate DLLs.</source>
          <target state="translated">Visual Studio 2005 이상을 사용하여 빌드 된 Qt 응용 프로그램을 배포 할 때는 응용 프로그램을 연결할 때 만들어진 매니페스트 파일이 올바르게 처리되는지 확인하십시오. 이것은 DLL을 생성하는 프로젝트에서 자동으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="e3f2fc2611c302aed3276f1510a9d174ba6db392" translate="yes" xml:space="preserve">
          <source>When deploying the app, the compression is typically handled on the server side. We recommend to compress the wasm binaries because this typically reduces the size of the binary by 50 %.</source>
          <target state="translated">When deploying the app, the compression is typically handled on the server side. We recommend to compress the wasm binaries because this typically reduces the size of the binary by 50 %.</target>
        </trans-unit>
        <trans-unit id="fc8ea9ac8ca6cf4cf6b3b5f4d012ccb4493d9e28" translate="yes" xml:space="preserve">
          <source>When developing applications that use D-Bus, it is sometimes useful to be able to see information about the messages that are sent and received across the bus by each application.</source>
          <target state="translated">D-Bus를 사용하는 응용 프로그램을 개발할 때 각 응용 프로그램이 버스를 통해 보내고받는 메시지에 대한 정보를 볼 수있는 것이 때때로 유용합니다.</target>
        </trans-unit>
        <trans-unit id="1a1c1be356204dfd455ba7ec0d01e973b146ec67" translate="yes" xml:space="preserve">
          <source>When disabled, a &lt;a href=&quot;qml-qt3d-render-nodraw&quot;&gt;NoDraw&lt;/a&gt; node won't prevent the scene from being rendered. Toggling the enabled property is therefore a way to make a &lt;a href=&quot;qml-qt3d-render-nodraw&quot;&gt;NoDraw&lt;/a&gt; active or inactive.</source>
          <target state="translated">비활성화하면 &lt;a href=&quot;qml-qt3d-render-nodraw&quot;&gt;NoDraw&lt;/a&gt; 노드는 장면이 렌더링되는 것을 막지 않습니다. 따라서 enabled 속성을 전환하면 &lt;a href=&quot;qml-qt3d-render-nodraw&quot;&gt;NoDraw를&lt;/a&gt; 활성화하거나 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="857e0ffe6bd1478d0544df44c2c658d65e015926" translate="yes" xml:space="preserve">
          <source>When disabled, a &lt;a href=&quot;qt3drender-qnodraw&quot;&gt;Qt3DRender::QNoDraw&lt;/a&gt; node won't prevent the scene from being rendered. Toggling the enabled property is therefore a way to make a &lt;a href=&quot;qt3drender-qnodraw&quot;&gt;Qt3DRender::QNoDraw&lt;/a&gt; active or inactive.</source>
          <target state="translated">비활성화되면 &lt;a href=&quot;qt3drender-qnodraw&quot;&gt;Qt3DRender :: QNoDraw&lt;/a&gt; 노드는 장면이 렌더링되는 것을 막지 않습니다. 따라서 enabled 속성을 전환하면 &lt;a href=&quot;qt3drender-qnodraw&quot;&gt;Qt3DRender :: QNoDraw를&lt;/a&gt; 활성화 또는 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a705f9e79dc5e0d4da74710091ca3394fb3c8ff6" translate="yes" xml:space="preserve">
          <source>When disabled, a &lt;a href=&quot;qt3drender-qnopicking&quot;&gt;Qt3DRender::QNoPicking&lt;/a&gt; node won't prevent picking from being performed. Toggling the enabled property is therefore a way to make a &lt;a href=&quot;qt3drender-qnopicking&quot;&gt;Qt3DRender::QNoPicking&lt;/a&gt; active or inactive.</source>
          <target state="translated">When disabled, a &lt;a href=&quot;qt3drender-qnopicking&quot;&gt;Qt3DRender::QNoPicking&lt;/a&gt; node won't prevent picking from being performed. Toggling the enabled property is therefore a way to make a &lt;a href=&quot;qt3drender-qnopicking&quot;&gt;Qt3DRender::QNoPicking&lt;/a&gt; active or inactive.</target>
        </trans-unit>
        <trans-unit id="c03a7230ca07cd92ed1e2c5c76edb68253bdb253" translate="yes" xml:space="preserve">
          <source>When disabled, a NoDraw node won't prevent the scene from being rendered. Toggling the enabled property is therefore a way to make a NoDraw active or inactive.</source>
          <target state="translated">비활성화되면 NoDraw 노드가 장면이 렌더링되는 것을 막지 않습니다. 따라서 활성화 된 속성을 토글하는 것은 NoDraw를 활성화 또는 비활성화하는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="7e738f36ac893e8cd586e71209d223aa4927c0d5" translate="yes" xml:space="preserve">
          <source>When disabled, a NoPicking node won't prevent picking from being performed. Toggling the enabled property is therefore a way to make a NoPicking active or inactive.</source>
          <target state="translated">비활성화되면 NoPicking 노드가 선택이 수행되는 것을 막지 않습니다. 따라서 enabled 속성을 토글하는 것은 NoPicking을 활성화 또는 비활성화하는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="382c790d1bb1d0cf3f278efbd5066d3785f4f5c9" translate="yes" xml:space="preserve">
          <source>When disabled, the &lt;a href=&quot;qml-qtquick3d-sceneenvironment#depthTestEnabled-prop&quot;&gt;depthTestEnabled&lt;/a&gt; property can be used to simultaneously override depth testing and the order of rendering the objects. The operation of this property is not as obvious as many of the other properties in the system so this page offers some insight into when, where, and why this property can be used.</source>
          <target state="translated">비활성화되면 &lt;a href=&quot;qml-qtquick3d-sceneenvironment#depthTestEnabled-prop&quot;&gt;depthTestEnabled&lt;/a&gt; 속성을 사용하여 깊이 테스트와 객체 렌더링 순서를 동시에 재정의 할 수 있습니다. 이 속성의 작동은 시스템의 다른 속성만큼 명확하지 않으므로이 페이지는이 속성을 언제, 어디서, 왜 사용할 수 있는지에 대한 통찰력을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="bc1e687319c686b682a905da3e6616cd03084a73" translate="yes" xml:space="preserve">
          <source>When disabled, the normals on the surface are interpolated making the edges look round. When enabled, the normals are kept the same on a triangle making the color of the triangle solid. This makes the data more readable from the model.</source>
          <target state="translated">비활성화하면 표면의 법선이 보간되어 가장자리가 둥글게 보입니다. 활성화하면 삼각형의 색상이 단색으로 만들어지는 삼각형에서 법선이 동일하게 유지됩니다. 이는 모델에서 데이터를 더 읽기 쉽게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="24f4c0f2f49fed31d9cd8577cea9ab05b39be5e3" translate="yes" xml:space="preserve">
          <source>When displaying data from models in Qt item views, e.g., a &lt;a href=&quot;qtableview&quot;&gt;QTableView&lt;/a&gt;, the individual items are drawn by a delegate. Also, when an item is edited, it provides an editor widget, which is placed on top of the item view while editing takes place. &lt;a href=&quot;qstyleditemdelegate&quot;&gt;QStyledItemDelegate&lt;/a&gt; is the default delegate for all Qt item views, and is installed upon them when they are created.</source>
          <target state="translated">&lt;a href=&quot;qtableview&quot;&gt;QtItem&lt;/a&gt; 보기 (예 : QTableView) 에서 모델의 데이터를 표시 할 때 개별 항목은 대리자가 가져옵니다. 또한 항목을 편집 할 때 편집이 수행되는 동안 항목보기 위에 배치되는 편집기 위젯을 제공합니다. &lt;a href=&quot;qstyleditemdelegate&quot;&gt;QStyledItemDelegate&lt;/a&gt; 는 모든 Qt 항목보기의 기본 대리자이며, 생성 될 때 설치됩니다.</target>
        </trans-unit>
        <trans-unit id="e6e55cf5ea63dc5db3857d7ad604b687dae8d030" translate="yes" xml:space="preserve">
          <source>When displaying data from models in Qt item views, e.g., a &lt;a href=&quot;qtableview&quot;&gt;QTableView&lt;/a&gt;, the individual items are drawn by a delegate. Also, when an item is edited, it provides an editor widget, which is placed on top of the item view while editing takes place. QStyledItemDelegate is the default delegate for all Qt item views, and is installed upon them when they are created.</source>
          <target state="translated">Qt 항목보기 (예 : &lt;a href=&quot;qtableview&quot;&gt;QTableView)&lt;/a&gt; 에서 모델의 데이터를 표시 할 때 개별 항목은 델리게이트에 의해 그려집니다. 또한 항목이 편집되면 편집이 진행되는 동안 항목보기 상단에 배치되는 편집기 위젯을 제공합니다. QStyledItemDelegate는 모든 Qt 항목보기에 대한 기본 대리자이며 작성시 설치됩니다.</target>
        </trans-unit>
        <trans-unit id="0352c49318cb9d0b30ba555050217480183cb03e" translate="yes" xml:space="preserve">
          <source>When displaying items from a custom model in a standard view, it is often sufficient to simply ensure that the model returns appropriate data for each of the &lt;a href=&quot;qt#ItemDataRole-enum&quot;&gt;roles&lt;/a&gt; that determine the appearance of items in views. The default delegate used by Qt's standard views uses this role information to display items in most of the common forms expected by users. However, it is sometimes necessary to have even more control over the appearance of items than the default delegate can provide.</source>
          <target state="translated">표준보기에서 사용자 지정 모델의 항목을 표시 할 때보기에서 항목의 모양을 결정하는 각 &lt;a href=&quot;qt#ItemDataRole-enum&quot;&gt;역할&lt;/a&gt; 에 대해 모델이 적절한 데이터를 반환하도록하는 것만으로도 충분합니다 . Qt의 표준보기에서 사용되는 기본 대리자는이 역할 정보를 사용하여 사용자가 기대하는 대부분의 일반적인 양식으로 항목을 표시합니다. 그러나 기본 대리자가 제공 할 수있는 것보다 항목의 모양을 훨씬 더 잘 제어해야하는 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="159720c88af83f5ac94a174365550a72f0765067" translate="yes" xml:space="preserve">
          <source>When documenting a QML type in a</source>
          <target state="translated">QML 유형을 문서화 할 때</target>
        </trans-unit>
        <trans-unit id="b7e55292b4abae3e9e4e7263b6533ed85abbb41e" translate="yes" xml:space="preserve">
          <source>When documenting a QML type in the</source>
          <target state="translated">QML 유형을 문서화 할 때</target>
        </trans-unit>
        <trans-unit id="fd4be1f4d3d4fe684047540a2b498b3e14a564e5" translate="yes" xml:space="preserve">
          <source>When doing replacement the area of the preedit string is ignored, thus a replacement starting at -1 with a length of 2 will remove the last character before the preedit string and the first character afterwards, and insert the commit string directly before the preedit string.</source>
          <target state="translated">대체를 수행 할 때 사전 편집 문자열의 영역이 무시되므로 길이가 2 인 -1에서 시작하면 사전 편집 문자열 앞의 마지막 문자와 이후의 첫 문자가 제거되고 커미트 문자열이 사전 편집 문자열의 바로 앞에 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="7b591bbff5ab07d40d7612a73ab5fcdc537e41fa" translate="yes" xml:space="preserve">
          <source>When doubleclicking an item, the item will first receive a mouse press event, followed by a release event (i.e., a click), then a doubleclick event, and finally a release event.</source>
          <target state="translated">아이템을 더블 클릭하면, 아이템은 먼저 마우스 프레스 이벤트를 수신 한 다음, 릴리즈 이벤트 (즉, 클릭), 더블 클릭 이벤트 및 마지막으로 릴리즈 이벤트를 수신합니다.</target>
        </trans-unit>
        <trans-unit id="a02484f5ce286a79ae6a871b9106f5799cb1d5dc" translate="yes" xml:space="preserve">
          <source>When dragging the titlebar of a dock, all the tabs that are tabbed with it are going to be dragged. Implies AllowTabbedDocks. Does not work well if some QDockWidgets have restrictions in which area they are allowed. (This enum value was added in Qt 5.6.)</source>
          <target state="translated">도크의 제목 표시 줄을 드래그하면 탭이있는 모든 탭이 드래그됩니다. AllowTabbedDocks를 의미합니다. 일부 QDockWidget에 허용되는 영역에 제한이있는 경우 제대로 작동하지 않습니다. (이 열거 형 값은 Qt 5.6에서 추가되었습니다.)</target>
        </trans-unit>
        <trans-unit id="19649a7c3fc63002d50d3cb1460af355d223d55e" translate="yes" xml:space="preserve">
          <source>When drawStaticText() is called, the layout of the &lt;a href=&quot;qstatictext&quot;&gt;QStaticText&lt;/a&gt; will be recalculated if any part of the &lt;a href=&quot;qstatictext&quot;&gt;QStaticText&lt;/a&gt; object has changed since the last time it was drawn. It will also be recalculated if the painter's font is not the same as when the &lt;a href=&quot;qstatictext&quot;&gt;QStaticText&lt;/a&gt; was last drawn, or, on any other paint engine than the OpenGL2 engine, if the painter's matrix has been altered since the static text was last drawn.</source>
          <target state="translated">drawStaticText ()가 호출 될 때의 레이아웃 &lt;a href=&quot;qstatictext&quot;&gt;QStaticText는&lt;/a&gt; 의 어떤 부분 경우 다시 계산됩니다 &lt;a href=&quot;qstatictext&quot;&gt;QStaticText의&lt;/a&gt; 객체가 그려진 마지막 시간 이후 변경되었습니다. 또한 페인터의 글꼴이 &lt;a href=&quot;qstatictext&quot;&gt;QStaticText&lt;/a&gt; 가 마지막으로 그려졌 을 때와 같지 않거나 OpenGL2 엔진 이외의 다른 페인트 엔진에서 정적 텍스트가 마지막으로 그려진 이후에 페인터의 행렬이 변경된 경우에도 다시 계산됩니다 .</target>
        </trans-unit>
        <trans-unit id="bb13eb36af2066f03f57ae49bb001cd98eedd84c" translate="yes" xml:space="preserve">
          <source>When drawing text, the font is specified using the &lt;a href=&quot;qfont&quot;&gt;QFont&lt;/a&gt; class. Qt will use the font with the specified attributes, or if no matching font exists, Qt will use the closest matching installed font. The attributes of the font that is actually used can be retrieved using the &lt;a href=&quot;qfontinfo&quot;&gt;QFontInfo&lt;/a&gt; class. In addition, the &lt;a href=&quot;qfontmetrics&quot;&gt;QFontMetrics&lt;/a&gt; class provides the font measurements, and the &lt;a href=&quot;qfontdatabase&quot;&gt;QFontDatabase&lt;/a&gt; class provides information about the fonts available in the underlying window system.</source>
          <target state="translated">텍스트를 그릴 때 글꼴은 &lt;a href=&quot;qfont&quot;&gt;QFont&lt;/a&gt; 클래스를 사용하여 지정됩니다 . Qt는 지정된 속성을 가진 글꼴을 사용하거나 일치하는 글꼴이 없으면 가장 가까운 일치하는 설치된 글꼴을 사용합니다. 실제로 사용되는 글꼴의 속성은 &lt;a href=&quot;qfontinfo&quot;&gt;QFontInfo&lt;/a&gt; 클래스를 사용하여 검색 할 수 있습니다 . 또한 &lt;a href=&quot;qfontmetrics&quot;&gt;QFontMetrics&lt;/a&gt; 클래스는 글꼴 측정을 제공하고 &lt;a href=&quot;qfontdatabase&quot;&gt;QFontDatabase&lt;/a&gt; 클래스는 기본 윈도우 시스템에서 사용 가능한 글꼴에 대한 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="2b8fa7bd4261a029b6f3fdf343d1e4a3de0c8942" translate="yes" xml:space="preserve">
          <source>When drawing with &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt;, we specify points using logical coordinates which then are converted into the physical coordinates of the paint device.</source>
          <target state="translated">&lt;a href=&quot;qpainter&quot;&gt;QPainter로&lt;/a&gt; 그릴 때 논리 좌표를 사용하여 점을 지정하면 페인트 장치의 물리적 좌표로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="410e5ecacd6f13933f5b02a517c03bf075b15730" translate="yes" xml:space="preserve">
          <source>When drawing with &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt;, we specify points using logical coordinates which then are converted into the physical coordinates of the paint device. The mapping of the logical coordinates to the physical coordinates are handled by &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt;'s &lt;a href=&quot;qpainter#combinedTransform&quot;&gt;combinedTransform&lt;/a&gt;(), a combination of &lt;a href=&quot;qpainter#viewport&quot;&gt;viewport&lt;/a&gt;() and &lt;a href=&quot;qpainter#window&quot;&gt;window&lt;/a&gt;() and &lt;a href=&quot;qpainter#worldTransform&quot;&gt;worldTransform&lt;/a&gt;(). The &lt;a href=&quot;qpainter#viewport&quot;&gt;viewport&lt;/a&gt;() represents the physical coordinates specifying an arbitrary rectangle, the &lt;a href=&quot;qpainter#window&quot;&gt;window&lt;/a&gt;() describes the same rectangle in logical coordinates, and the &lt;a href=&quot;qpainter#worldTransform&quot;&gt;worldTransform&lt;/a&gt;() is identical with the transformation matrix.</source>
          <target state="translated">&lt;a href=&quot;qpainter&quot;&gt;QPainter로&lt;/a&gt; 그릴 때 논리 좌표를 사용하여 점을 지정하면 페인트 장치의 물리적 좌표로 변환됩니다. 논리 좌표를 물리 좌표에 맵핑하는 것은 &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; 의 &lt;a href=&quot;qpainter#combinedTransform&quot;&gt;CombinedTransform&lt;/a&gt; (), &lt;a href=&quot;qpainter#viewport&quot;&gt;뷰포트&lt;/a&gt; ()와 &lt;a href=&quot;qpainter#window&quot;&gt;창&lt;/a&gt; () 및 &lt;a href=&quot;qpainter#worldTransform&quot;&gt;worldTransform&lt;/a&gt; () 의 조합에 의해 처리됩니다 . &lt;a href=&quot;qpainter#viewport&quot;&gt;뷰포트&lt;/a&gt; () 임의의 직사각형을 특정 물리 좌표를 상기 대표 &lt;a href=&quot;qpainter#window&quot;&gt;창&lt;/a&gt; () 논리 좌표 동일한 사각형을 설명하고 &lt;a href=&quot;qpainter#worldTransform&quot;&gt;worldTransform는&lt;/a&gt; () 변환 행렬과 동일하다.</target>
        </trans-unit>
        <trans-unit id="fa068ff4a5704af2221f41b1b4da90e1a41df12c" translate="yes" xml:space="preserve">
          <source>When drawing with QPainter, we specify points using logical coordinates which then are converted into the physical coordinates of the paint device. The mapping of the logical coordinates to the physical coordinates are handled by QPainter's &lt;a href=&quot;qpainter#combinedTransform&quot;&gt;combinedTransform&lt;/a&gt;(), a combination of &lt;a href=&quot;qpainter#viewport&quot;&gt;viewport&lt;/a&gt;() and &lt;a href=&quot;qpainter#window&quot;&gt;window&lt;/a&gt;() and &lt;a href=&quot;qpainter#worldTransform&quot;&gt;worldTransform&lt;/a&gt;(). The &lt;a href=&quot;qpainter#viewport&quot;&gt;viewport&lt;/a&gt;() represents the physical coordinates specifying an arbitrary rectangle, the &lt;a href=&quot;qpainter#window&quot;&gt;window&lt;/a&gt;() describes the same rectangle in logical coordinates, and the &lt;a href=&quot;qpainter#worldTransform&quot;&gt;worldTransform&lt;/a&gt;() is identical with the transformation matrix.</source>
          <target state="translated">QPainter로 그릴 때 논리적 좌표를 사용하여 점을 지정하고 페인트 장치의 물리적 좌표로 변환합니다. 논리적 좌표와 물리적 좌표의 매핑은 QPainter의 &lt;a href=&quot;qpainter#combinedTransform&quot;&gt;CombinedTransform&lt;/a&gt; (), &lt;a href=&quot;qpainter#viewport&quot;&gt;뷰포트&lt;/a&gt; ()와 &lt;a href=&quot;qpainter#window&quot;&gt;창&lt;/a&gt; () 및 &lt;a href=&quot;qpainter#worldTransform&quot;&gt;worldTransform&lt;/a&gt; () 의 조합에 의해 처리됩니다 . &lt;a href=&quot;qpainter#viewport&quot;&gt;뷰포트&lt;/a&gt; () 임의의 직사각형을 특정 물리 좌표를 상기 대표 &lt;a href=&quot;qpainter#window&quot;&gt;창&lt;/a&gt; () 논리 좌표 동일한 사각형을 설명하고 &lt;a href=&quot;qpainter#worldTransform&quot;&gt;worldTransform는&lt;/a&gt; () 변환 행렬과 동일하다.</target>
        </trans-unit>
        <trans-unit id="c5ed330ed405cc570c36b8d34b32b0e9f282124b" translate="yes" xml:space="preserve">
          <source>When drawing, the pixel rendering is controlled by the &lt;a href=&quot;qpainter#RenderHint-enum&quot;&gt;QPainter::Antialiasing&lt;/a&gt; render hint.</source>
          <target state="translated">그릴 때 픽셀 렌더링은 &lt;a href=&quot;qpainter#RenderHint-enum&quot;&gt;QPainter :: Antialiasing&lt;/a&gt; 렌더 힌트에 의해 제어됩니다 .</target>
        </trans-unit>
        <trans-unit id="d15b0d71322e99bde4953dbe90c85c3ef7baf9a0" translate="yes" xml:space="preserve">
          <source>When drawing, the pixel rendering is controlled by the &lt;a href=&quot;qpainter#RenderHint-enum&quot;&gt;QPainter::Antialiasing&lt;/a&gt; render hint. The &lt;a href=&quot;qpainter#RenderHint-enum&quot;&gt;QPainter::RenderHint&lt;/a&gt; enum is used to specify flags to &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; that may or may not be respected by any given engine.</source>
          <target state="translated">그릴 때 픽셀 렌더링은 &lt;a href=&quot;qpainter#RenderHint-enum&quot;&gt;QPainter :: Antialiasing&lt;/a&gt; 렌더 힌트에 의해 제어됩니다 . &lt;a href=&quot;qpainter#RenderHint-enum&quot;&gt;QPainter를 :: RenderHint의&lt;/a&gt; 열거가에 플래그를 지정하는 데 사용됩니다 &lt;a href=&quot;qpainter&quot;&gt;QPainter를&lt;/a&gt; 또는 특정 엔진에 의해 존중 될 수도 있고 그렇지 않을 수도있다.</target>
        </trans-unit>
        <trans-unit id="6ebdf8b96fea44b5a3aed78415b3fda3d62aa0c1" translate="yes" xml:space="preserve">
          <source>When driving animations, this function should be called once after drawing has completed. Calling this function multiple times will result in a single event being delivered to the window.</source>
          <target state="translated">애니메이션을 구동 할 때 그리기가 완료된 후에이 함수를 한 번 호출해야합니다. 이 함수를 여러 번 호출하면 단일 이벤트가 창에 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="1ce5dba37bb8921ab742160f013368e5f3259059" translate="yes" xml:space="preserve">
          <source>When duplicate skipping is enabled, successive readings with the same or very similar values are omitted. This helps reducing the amount of processing done, as less sensor readings are made available. As a consequence, readings arrive at an irregular interval.</source>
          <target state="translated">중복 건너 뛰기를 사용하면 동일하거나 매우 유사한 값을 가진 연속 판독 값이 생략됩니다. 이는 적은 센서 판독 값이 제공되므로 처리량을 줄이는 데 도움이됩니다. 결과적으로 판독 값이 불규칙적으로 도착합니다.</target>
        </trans-unit>
        <trans-unit id="d5e3a8786c0102ae5523b4a9dad7cca51f61d1c8" translate="yes" xml:space="preserve">
          <source>When each primitive is large, this overhead is negligible, but in the case of a typical UI, there are many small items which add up to a considerable overhead.</source>
          <target state="translated">각 프리미티브가 크면이 오버 헤드는 무시할 수 있지만 일반적인 UI의 경우 많은 오버 헤드를 추가하는 작은 항목이 많이 있습니다.</target>
        </trans-unit>
        <trans-unit id="cbc38d0da8ee345ba2fd00eef535419aae91f344" translate="yes" xml:space="preserve">
          <source>When editing data in an item view, &lt;a href=&quot;qitemdelegate&quot;&gt;QItemDelegate&lt;/a&gt; provides an editor widget, which is a widget that is placed on top of the view while editing takes place. Editors are created with a &lt;a href=&quot;qitemeditorfactory&quot;&gt;QItemEditorFactory&lt;/a&gt;; a default static instance provided by &lt;a href=&quot;qitemeditorfactory&quot;&gt;QItemEditorFactory&lt;/a&gt; is installed on all item delegates. You can set a custom factory using &lt;a href=&quot;qitemdelegate#setItemEditorFactory&quot;&gt;setItemEditorFactory&lt;/a&gt;() or set a new default factory with &lt;a href=&quot;qitemeditorfactory#setDefaultFactory&quot;&gt;QItemEditorFactory::setDefaultFactory&lt;/a&gt;(). It is the data stored in the item model with the &lt;a href=&quot;qt#ItemDataRole-enum&quot;&gt;Qt::EditRole&lt;/a&gt; that is edited.</source>
          <target state="translated">항목보기에서 데이터를 편집 할 때 &lt;a href=&quot;qitemdelegate&quot;&gt;QItemDelegate&lt;/a&gt; 는 편집이 수행되는 동안보기 위에 배치되는 위젯 인 편집기 위젯을 제공합니다. 에디터는 &lt;a href=&quot;qitemeditorfactory&quot;&gt;QItemEditorFactory&lt;/a&gt; 로 작성됩니다 . &lt;a href=&quot;qitemeditorfactory&quot;&gt;QItemEditorFactory&lt;/a&gt; 가 제공하는 기본 정적 인스턴스 는 모든 항목 대리자에 설치됩니다. &lt;a href=&quot;qitemdelegate#setItemEditorFactory&quot;&gt;setItemEditorFactory&lt;/a&gt; ()를 사용하여 사용자 정의 팩토리를 설정하거나 &lt;a href=&quot;qitemeditorfactory#setDefaultFactory&quot;&gt;QItemEditorFactory :: setDefaultFactory&lt;/a&gt; ()를 사용하여 새 기본 팩토리를 설정할 수 있습니다 . 편집 된 &lt;a href=&quot;qt#ItemDataRole-enum&quot;&gt;Qt :: EditRole&lt;/a&gt; 과 함께 항목 모델에 저장된 데이터 입니다.</target>
        </trans-unit>
        <trans-unit id="e3121493bb1879d53220fddb4bd4e0247d179ffd" translate="yes" xml:space="preserve">
          <source>When editing data in an item view, QItemDelegate provides an editor widget, which is a widget that is placed on top of the view while editing takes place. Editors are created with a &lt;a href=&quot;qitemeditorfactory&quot;&gt;QItemEditorFactory&lt;/a&gt;; a default static instance provided by &lt;a href=&quot;qitemeditorfactory&quot;&gt;QItemEditorFactory&lt;/a&gt; is installed on all item delegates. You can set a custom factory using &lt;a href=&quot;qitemdelegate#setItemEditorFactory&quot;&gt;setItemEditorFactory&lt;/a&gt;() or set a new default factory with &lt;a href=&quot;qitemeditorfactory#setDefaultFactory&quot;&gt;QItemEditorFactory::setDefaultFactory&lt;/a&gt;(). It is the data stored in the item model with the &lt;a href=&quot;qt#ItemDataRole-enum&quot;&gt;Qt::EditRole&lt;/a&gt; that is edited.</source>
          <target state="translated">항목보기에서 데이터를 편집 할 때 QItemDelegate는 편집이 수행되는 동안보기 위에 배치되는 위젯 인 편집기 위젯을 제공합니다. 편집기는 &lt;a href=&quot;qitemeditorfactory&quot;&gt;QItemEditorFactory&lt;/a&gt; 로 생성됩니다 . &lt;a href=&quot;qitemeditorfactory&quot;&gt;QItemEditorFactory에서&lt;/a&gt; 제공하는 기본 정적 인스턴스 는 모든 항목 델리게이트에 설치됩니다. &lt;a href=&quot;qitemdelegate#setItemEditorFactory&quot;&gt;setItemEditorFactory&lt;/a&gt; ()를 사용하여 사용자 정의 팩토리를 설정하거나 &lt;a href=&quot;qitemeditorfactory#setDefaultFactory&quot;&gt;QItemEditorFactory :: setDefaultFactory&lt;/a&gt; ()를 사용하여 새 기본 팩토리를 설정할 수 있습니다 . 편집되는 것은 &lt;a href=&quot;qt#ItemDataRole-enum&quot;&gt;Qt :: EditRole&lt;/a&gt; 과 함께 항목 모델에 저장된 데이터 입니다.</target>
        </trans-unit>
        <trans-unit id="6f6344a0186d030dc605de997efbebf65f1b9a99" translate="yes" xml:space="preserve">
          <source>When editing data in an item view, editors are created and displayed by a delegate. &lt;a href=&quot;qstyleditemdelegate&quot;&gt;QStyledItemDelegate&lt;/a&gt;, which is the delegate by default installed on Qt's item views, uses a &lt;a href=&quot;qitemeditorfactory&quot;&gt;QItemEditorFactory&lt;/a&gt; to create editors for it. A default unique instance provided by &lt;a href=&quot;qitemeditorfactory&quot;&gt;QItemEditorFactory&lt;/a&gt; is used by all item delegates. If you set a new default factory with &lt;a href=&quot;qitemeditorfactory#setDefaultFactory&quot;&gt;setDefaultFactory&lt;/a&gt;(), the new factory will be used by existing and new delegates.</source>
          <target state="translated">항목보기에서 데이터를 편집하면 대리자가 편집기를 작성하고 표시합니다. &lt;a href=&quot;qstyleditemdelegate&quot;&gt;QStyledItemDelegate&lt;/a&gt; Qt의 아이템 뷰에 설치 기본적으로 위임이다,하는 사용 &lt;a href=&quot;qitemeditorfactory&quot;&gt;QItemEditorFactory&lt;/a&gt; 그것을 위해 에디터를 만들 수 있습니다. &lt;a href=&quot;qitemeditorfactory&quot;&gt;QItemEditorFactory&lt;/a&gt; 가 제공하는 기본 고유 인스턴스 는 모든 항목 대리자가 사용합니다. &lt;a href=&quot;qitemeditorfactory#setDefaultFactory&quot;&gt;setDefaultFactory&lt;/a&gt; () 를 사용하여 새 기본 팩토리를 설정하면 기존 및 새 대리자가 새 팩토리를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="4e2f4a385e37cf62cf1b97e80df94ad25fd55a99" translate="yes" xml:space="preserve">
          <source>When editing data in an item view, editors are created and displayed by a delegate. &lt;a href=&quot;qstyleditemdelegate&quot;&gt;QStyledItemDelegate&lt;/a&gt;, which is the delegate by default installed on Qt's item views, uses a QItemEditorFactory to create editors for it. A default unique instance provided by QItemEditorFactory is used by all item delegates. If you set a new default factory with &lt;a href=&quot;qitemeditorfactory#setDefaultFactory&quot;&gt;setDefaultFactory&lt;/a&gt;(), the new factory will be used by existing and new delegates.</source>
          <target state="translated">항목보기에서 데이터를 편집 할 때 편집자는 대리인이 만들고 표시합니다. &lt;a href=&quot;qstyleditemdelegate&quot;&gt;QStyledItemDelegate&lt;/a&gt; Qt의 아이템 뷰에 설치 기본적으로 위임하고, 그것을 위해 에디터를 제작하는 QItemEditorFactory를 사용합니다. QItemEditorFactory에서 제공하는 기본 고유 인스턴스는 모든 항목 대리자가 사용합니다. &lt;a href=&quot;qitemeditorfactory#setDefaultFactory&quot;&gt;setDefaultFactory&lt;/a&gt; () 로 새 기본 팩토리를 설정하면 기존 및 새 델리게이트가 새 팩토리를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="c0e7a6ec88186d061ca22e9701050d741f30a191" translate="yes" xml:space="preserve">
          <source>When editing is finished, either because the line edit lost focus or Return/Enter is pressed the &lt;a href=&quot;qlineedit#editingFinished&quot;&gt;editingFinished&lt;/a&gt;() signal is emitted.</source>
          <target state="translated">편집이 완료되면, 라인 편집 상실 포커스 또는 Return / Enter를 눌렀을 때 &lt;a href=&quot;qlineedit#editingFinished&quot;&gt;editingFinished&lt;/a&gt; () 신호가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d66bfe606de9465976bab385d92db6b5ec57c788" translate="yes" xml:space="preserve">
          <source>When editing of an item starts, this function is called with the</source>
          <target state="translated">항목 편집이 시작되면이 함수는</target>
        </trans-unit>
        <trans-unit id="b9a4a24a7b2e2cf96998146b51d4cf55a3e5c82a" translate="yes" xml:space="preserve">
          <source>When enabled and the label shows a pixmap, it will scale the pixmap to fill the available space.</source>
          <target state="translated">활성화되고 레이블에 픽스맵이 표시되면 사용 가능한 공간을 채우도록 픽스맵의 크기가 조정됩니다.</target>
        </trans-unit>
        <trans-unit id="809e3c2e92b5437339d00438d8ac5682f3c1094a" translate="yes" xml:space="preserve">
          <source>When enabled, making a Shape visible will not wait for the content to become available. Instead, the gui/main thread is not blocked and the results of the path rendering are shown only when all the asynchronous work has been finished.</source>
          <target state="translated">활성화하면 모양을 표시해도 내용을 사용할 수있을 때까지 기다리지 않습니다. 대신 gui / main 스레드는 차단되지 않으며 모든 비동기 작업이 완료된 경우에만 경로 렌더링 결과가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="fee807f59e511b5dcbfdf0c512929f1021ab0586" translate="yes" xml:space="preserve">
          <source>When enabled, the renderer performs a Z-prepass for opaque objects, meaning it renders them with a simple shader and color write disabled in order to get the depth buffer pre-filled before issuing draw calls for the main rendering passes.</source>
          <target state="translated">활성화되면 렌더러는 불투명 한 객체에 대해 Z- 프리 패스를 수행합니다. 즉, 기본 렌더링 패스에 대한 드로 콜을 실행하기 전에 깊이 버퍼를 미리 채울 수 있도록 간단한 셰이더 및 색상 쓰기 비활성화로 렌더링합니다.</target>
        </trans-unit>
        <trans-unit id="fef9dffa012fb5631fc857fa121adc562514620b" translate="yes" xml:space="preserve">
          <source>When enabled, this attribute disables the delivery of mouse events to the widget and its children. Mouse events are delivered to other widgets as if the widget and its children were not present in the widget hierarchy; mouse clicks and other events effectively &quot;pass through&quot; them. This attribute is disabled by default.</source>
          <target state="translated">사용 가능한 경우이 속성은 마우스 이벤트를 위젯 및 해당 하위로 전달할 수 없게합니다. 위젯 및 해당 하위가 위젯 계층 구조에없는 것처럼 마우스 이벤트가 다른 위젯으로 전달됩니다. 마우스 클릭 및 기타 이벤트는 효과적으로 &quot;통과&quot;합니다. 이 속성은 기본적으로 비활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="482662a30996d40d4a1c18a3374e7b2c360e9d38" translate="yes" xml:space="preserve">
          <source>When entering &quot;What's This?&quot; mode, a &lt;a href=&quot;qevent&quot;&gt;QEvent&lt;/a&gt; of type Qt::EnterWhatsThisMode is sent to all toplevel widgets.</source>
          <target state="translated">&quot;무엇입니까?&quot;를 입력 할 때 모드, &lt;a href=&quot;qevent&quot;&gt;QEvent&lt;/a&gt; 유형 Qt는 :: EnterWhatsThisMode의 모든 최상위 위젯으로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="6190eb6bb23c0ba0b8cd55075c9df2ea7f1a0eef" translate="yes" xml:space="preserve">
          <source>When executed together with the source-side example, the output is identical to &lt;a href=&quot;#qtro-example1&quot;&gt;Example 1&lt;/a&gt;.</source>
          <target state="translated">소스 측 예제와 함께 실행하면 출력은 &lt;a href=&quot;#qtro-example1&quot;&gt;예제 1&lt;/a&gt; 과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="c6558b3205936d1c2767fe9741a81481ab905734" translate="yes" xml:space="preserve">
          <source>When executed, QDoc will exclude the listed directories from further consideration. Files in these directories will not be read by QDoc.</source>
          <target state="translated">실행되면 QDoc은 나열된 디렉토리를 추가 고려 사항에서 제외합니다. 이 디렉토리의 파일은 QDoc에서 읽지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c9a96d672de3f61af853bd3fb2b4ddb09401c17a" translate="yes" xml:space="preserve">
          <source>When executed, QDoc will exclude the listed directories from further consideration. Files in these directories will not be read by qdoc.</source>
          <target state="translated">실행되면 QDoc은 나열된 디렉토리를 추가 고려 대상에서 제외합니다. 이 디렉토리의 파일은 qdoc에서 읽을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f0b8e30c664f1e368519b1a60f634e4ae26e999b" translate="yes" xml:space="preserve">
          <source>When executed, QDoc will ignore the directories listed. &lt;b&gt;See also&lt;/b&gt;: &lt;a href=&quot;22-qdoc-configuration-generalvariables#excludefiles&quot;&gt;excludefiles&lt;/a&gt;.</source>
          <target state="translated">실행되면 QDoc은 나열된 디렉토리를 무시합니다. &lt;b&gt;참고&lt;/b&gt; : &lt;a href=&quot;22-qdoc-configuration-generalvariables#excludefiles&quot;&gt;excludefiles&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ca04becdda83845f40b583b367041236f99a3f37" translate="yes" xml:space="preserve">
          <source>When executed, the first thing QDoc will do is to read through the headers specified in the &lt;a href=&quot;#headers&quot;&gt;&lt;code&gt;headers&lt;/code&gt;&lt;/a&gt; variable, and the ones located in the directories specified in the &lt;code&gt;headerdir&lt;/code&gt; variable (including all subdirectories), building an internal structure of the classes and their functions.</source>
          <target state="translated">QDoc이 실행될 때 가장 먼저 할 일은 &lt;a href=&quot;#headers&quot;&gt; &lt;code&gt;headers&lt;/code&gt; &lt;/a&gt; 변수에 지정된 헤더 와 &lt;code&gt;headerdir&lt;/code&gt; 변수에 지정된 디렉토리 (모든 서브 디렉토리 포함)에있는 클래스를 읽고 클래스의 내부 구조와 함수를 빌드하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="5cb7e1f93541ac06ba092ca034af95b10f030b3f" translate="yes" xml:space="preserve">
          <source>When executed, the first thing QDoc will do is to read through the headers specified in the &lt;a href=&quot;10-qdoc-commands-tablesandlists#header-command&quot;&gt;&lt;code&gt;header&lt;/code&gt;&lt;/a&gt; variable, and the ones located in the directories specified in the &lt;code&gt;headerdir&lt;/code&gt; variable (including all subdirectories), building an internal structure of the classes and their functions.</source>
          <target state="translated">QDoc이 실행될 때 가장 먼저 할 일은 &lt;a href=&quot;10-qdoc-commands-tablesandlists#header-command&quot;&gt; &lt;code&gt;header&lt;/code&gt; &lt;/a&gt; 변수에 지정된 헤더 와 &lt;code&gt;headerdir&lt;/code&gt; 변수에 지정된 디렉토리 (모든 서브 디렉토리 포함)에있는 클래스를 읽고 클래스의 내부 구조와 함수를 빌드하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="6f35fb24ec304ed2925435889439bd5ef8cff940" translate="yes" xml:space="preserve">
          <source>When executed, the first thing QDoc will do is to read through the headers specified in the &lt;a href=&quot;22-qdoc-configuration-generalvariables#headers&quot;&gt;&lt;code&gt;headers&lt;/code&gt;&lt;/a&gt; variable, and the ones located in the directories specified in the &lt;code&gt;headerdir&lt;/code&gt; variable (including all subdirectories), building an internal structure of the classes and their functions.</source>
          <target state="translated">실행될 때 QDoc이 가장 먼저 할 일은 &lt;a href=&quot;22-qdoc-configuration-generalvariables#headers&quot;&gt; &lt;code&gt;headers&lt;/code&gt; &lt;/a&gt; 변수에 지정된 헤더 와 &lt;code&gt;headerdir&lt;/code&gt; 변수에 지정된 디렉토리 (모든 하위 디렉터리 포함) 에있는 헤더 를 읽고 클래스와 해당 함수의 내부 구조를 구축하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="09ffff96391333a52eee7a9ad80e057863c3ba11" translate="yes" xml:space="preserve">
          <source>When expanding is true &lt;a href=&quot;qtabbar&quot;&gt;QTabBar&lt;/a&gt; will expand the tabs to use the empty space.</source>
          <target state="translated">확장이 true 일 때 &lt;a href=&quot;qtabbar&quot;&gt;QTabBar&lt;/a&gt; 는 탭을 확장하여 빈 공간을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="2620b86db1234798b63f39503859611b9649e059" translate="yes" xml:space="preserve">
          <source>When exporting 9-patch images in several DPI variants (&lt;code&gt;@2x&lt;/code&gt;, &lt;code&gt;@3x&lt;/code&gt;, etc.), the 9-patch lines will typically be scaled up along with the image. There are several ways to fix this, but perhaps the simplest approach is to use &lt;a href=&quot;https://www.imagemagick.org/script/mogrify.php&quot;&gt;ImageMagick's mogrify&lt;/a&gt; tool. The tool has a &lt;code&gt;-shave&lt;/code&gt; feature that can be used to crop the image to reduce the thickness of the 9-patch lines:</source>
          <target state="translated">여러 DPI 변형 ( &lt;code&gt;@2x&lt;/code&gt; , &lt;code&gt;@3x&lt;/code&gt; 등)으로 9 패치 이미지를 내 보내면 일반적으로 9 패치 라인이 이미지와 함께 확대됩니다. 이 문제를 해결하는 방법에는 여러 가지가 있지만 가장 간단한 방법은 &lt;a href=&quot;https://www.imagemagick.org/script/mogrify.php&quot;&gt;ImageMagick의 mogrify&lt;/a&gt; 도구 를 사용하는 것 입니다. 이 도구에는 9 패치 라인의 두께를 줄이기 위해 이미지를 자르는 데 사용할 수 있는 &lt;code&gt;-shave&lt;/code&gt; 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="70acf7a58788a901870142345c474b753e5c2cea" translate="yes" xml:space="preserve">
          <source>When extending &lt;code&gt;QtService&lt;/code&gt;, you need to declare other items for loading all the necessary libs required for Qt, mainly the same items as in &lt;code&gt;&amp;lt;activity&amp;gt;&lt;/code&gt; section for &lt;code&gt;QtActivity&lt;/code&gt;. Add the following:</source>
          <target state="translated">&lt;code&gt;QtService&lt;/code&gt; 를 확장 할 때 Qt에 필요한 모든 라이브러리를로드하기 위해 다른 항목을 선언해야합니다. 주로 &lt;code&gt;QtActivity&lt;/code&gt; 의 &lt;code&gt;&amp;lt;activity&amp;gt;&lt;/code&gt; 섹션 과 동일한 항목 입니다. 다음을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="e5abd3482bf0f9993496037be30182385378e5e2" translate="yes" xml:space="preserve">
          <source>When extending &lt;code&gt;Service&lt;/code&gt;, just declare the service section as a normal Android service. Add the following inside the &lt;code&gt;&amp;lt;application&amp;gt;&lt;/code&gt; section:</source>
          <target state="translated">&lt;code&gt;Service&lt;/code&gt; 를 확장 할 때 서비스 섹션을 일반 Android 서비스로 선언하기 만하면됩니다. &lt;code&gt;&amp;lt;application&amp;gt;&lt;/code&gt; 섹션에 다음을 추가 하십시오.</target>
        </trans-unit>
        <trans-unit id="dd92947bef2cbe270c8052641e8c3450b891b43e" translate="yes" xml:space="preserve">
          <source>When extending QML with C++ code, a C++ class can be registered with the QML type system to enable the class to be used as a data type within QML code. While the properties, methods and signals of any &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;-derived class are accessible from QML, as discussed in &lt;a href=&quot;qtqml-cppintegration-exposecppattributes&quot;&gt;Exposing Attributes of C++ Types to QML&lt;/a&gt;, such a class cannot be used as a data type from QML until it is registered with the type system. Additionally registration can provide other features, such as allowing a class to be used as an instantiable &lt;a href=&quot;qtqml-typesystem-objecttypes&quot;&gt;QML object type&lt;/a&gt; from QML, or enabling a singleton instance of the class to be imported and used from QML.</source>
          <target state="translated">C ++ 코드로 QML을 확장 할 때 C ++ 클래스를 QML 유형 시스템에 등록하여 해당 클래스를 QML 코드 내에서 데이터 유형으로 사용할 수 있습니다. &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 파생 클래스 의 속성, 메서드 및 신호는 QML &lt;a href=&quot;qtqml-cppintegration-exposecppattributes&quot;&gt;에 C ++ 유형의 속성 노출&lt;/a&gt; 에서 논의 된 것처럼 QML에서 액세스 할 수 있지만 이러한 클래스는 유형 시스템에 등록 될 때까지 QML의 데이터 유형으로 사용할 수 없습니다. 추가로 등록은 &lt;a href=&quot;qtqml-typesystem-objecttypes&quot;&gt;QML&lt;/a&gt; 에서 인스턴스화 가능한 QML 객체 유형 으로 클래스를 사용할 수 있도록 허용 하거나 QML에서 클래스의 단일 인스턴스를 가져 와서 사용할 수 있도록하는 등의 다른 기능을 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="426d2b133ccf9d0aab48e582602ba3229910acac" translate="yes" xml:space="preserve">
          <source>When extending QML with C++ code, a C++ class can be registered with the QML type system to enable the class to be used as a data type within QML code. While the properties, methods and signals of any &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;-derived class are accessible from QML, as discussed in &lt;a href=&quot;qtqml-cppintegration-exposecppattributes#&quot;&gt;Exposing Attributes of C++ Types to QML&lt;/a&gt;, such a class cannot be used as a data type from QML until it is registered with the type system. Additionally registration can provide other features, such as allowing a class to be used as an instantiable &lt;a href=&quot;qtqml-typesystem-objecttypes#&quot;&gt;QML object type&lt;/a&gt; from QML, or enabling a singleton instance of the class to be imported and used from QML.</source>
          <target state="translated">C ++ 코드를 사용하여 QML을 확장 할 때 C ++ 클래스를 QML 유형 시스템에 등록하여 클래스를 QML 코드 내에서 데이터 유형으로 사용할 수 있습니다. &lt;a href=&quot;qtqml-cppintegration-exposecppattributes#&quot;&gt;C ++ 유형의 속성을 QML&lt;/a&gt; 에 노출 에서 설명한대로 &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 파생 클래스 의 특성, 메소드 및 신호에 액세스 할 수 있지만 이러한 클래스는 유형 시스템에 등록 될 때까지 QML의 데이터 유형으로 사용할 수 없습니다. 또한 등록을 통해 &lt;a href=&quot;qtqml-typesystem-objecttypes#&quot;&gt;QML&lt;/a&gt; 에서 클래스를 인스턴스화 가능한 QML 객체 유형 으로 사용 하거나 클래스의 단일 인스턴스를 가져 와서 QML에서 사용할 수 있도록하는 등의 다른 기능을 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9db3502d0d4498df3a64124b7eb7242bd03e84ad" translate="yes" xml:space="preserve">
          <source>When generating DITA XML, qdoc outputs the nested</source>
          <target state="translated">DITA XML을 생성 할 때 qdoc는 중첩을 출력합니다.</target>
        </trans-unit>
        <trans-unit id="6359268011bd2e23ea07a88afa77e4d08fbb1147" translate="yes" xml:space="preserve">
          <source>When generating the reference documentation for a class, QDoc will create and link to a separate page documenting its obsolete functions. Usually an equivalent function is provided as an alternative.</source>
          <target state="translated">클래스에 대한 참조 문서를 생성 할 때 QDoc은 더 이상 사용되지 않는 기능을 설명하는 별도의 페이지를 작성하고 링크합니다. 대체로 동등한 기능이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="71f447939a909dfa27ce949444c9508a3a7d93da" translate="yes" xml:space="preserve">
          <source>When getting started with developing on a given embedded device, it is often necessary to verify the behavior of the device and drivers, and that the connected displays are working as they should. One easy way is to use the hellowindow example. Launching it with &lt;code&gt;-platform eglfs --multiscreen --timeout&lt;/code&gt; arguments shows a rotating Qt logo on each connected screen for a few seconds.</source>
          <target state="translated">주어진 임베디드 장치에서 개발을 시작할 때 종종 장치와 드라이버의 동작을 확인하고 연결된 디스플레이가 정상적으로 작동하는지 확인해야합니다. 한 가지 쉬운 방법은 hellowindow 예제를 사용하는 것입니다. &lt;code&gt;-platform eglfs --multiscreen --timeout&lt;/code&gt; 인수를 사용 하여 시작하면 연결된 각 화면에 몇 초 동안 회전하는 Qt 로고가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="b8ddc3778afe40355df31ec30ad7ce29680583ba" translate="yes" xml:space="preserve">
          <source>When handling the signal with &lt;code&gt;onLoadingChanged&lt;/code&gt;, various read-only parameters are available on the &lt;a href=&quot;qml-qtwebengine-webengineloadrequest&quot;&gt;WebEngineLoadRequest&lt;/a&gt; specified by</source>
          <target state="translated">로 신호 처리하면 &lt;code&gt;onLoadingChanged&lt;/code&gt; 를 다양한 읽기 전용 변수는에 사용할 &lt;a href=&quot;qml-qtwebengine-webengineloadrequest&quot;&gt;WebEngineLoadRequest가&lt;/a&gt; 의해 지정된</target>
        </trans-unit>
        <trans-unit id="dd3376f42ea41d22705767c518b03411a09688ef" translate="yes" xml:space="preserve">
          <source>When handling this signal, changing the &lt;a href=&quot;qml-qtquick-mouseevent#accepted-prop&quot;&gt;accepted&lt;/a&gt; property of the</source>
          <target state="translated">이 신호를 처리 할 때, 변경 &lt;a href=&quot;qml-qtquick-mouseevent#accepted-prop&quot;&gt;수락&lt;/a&gt; 의 속성</target>
        </trans-unit>
        <trans-unit id="6609fd77e98998e1210abc85df3c2fabea25a8b3" translate="yes" xml:space="preserve">
          <source>When handling this signal, if the &lt;a href=&quot;qml-qtquick-mouseevent#accepted-prop&quot;&gt;accepted&lt;/a&gt; property of the</source>
          <target state="translated">이 신호 처리, 만약 &lt;a href=&quot;qml-qtquick-mouseevent#accepted-prop&quot;&gt;수락&lt;/a&gt; 의 속성</target>
        </trans-unit>
        <trans-unit id="b478004d57f010bec2ae3794bb546849c254693f" translate="yes" xml:space="preserve">
          <source>When handling this signal, use the &lt;a href=&quot;qml-qtquick-mouseevent#accepted-prop&quot;&gt;accepted&lt;/a&gt; property of the</source>
          <target state="translated">이 신호를 처리 할 때 사용 &lt;a href=&quot;qml-qtquick-mouseevent#accepted-prop&quot;&gt;허용&lt;/a&gt; 의 속성을</target>
        </trans-unit>
        <trans-unit id="6295b7b616f0d9112be806cf906b2998b3813947" translate="yes" xml:space="preserve">
          <source>When having multiple displays connected, the level of support for targeting one or more of these from one single Qt application varies between the platform plugins and often depends on the device and its graphics stack.</source>
          <target state="translated">여러 개의 디스플레이가 연결된 경우 하나의 단일 Qt 애플리케이션에서 하나 이상의 대상을 대상으로하는 지원 수준은 플랫폼 플러그인마다 다르며 종종 장치와 그래픽 스택에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="33cb76c34e5dfbfadb36579df2b883f159a00960" translate="yes" xml:space="preserve">
          <source>When implemented, this function is responsible for checking the paint engine's current</source>
          <target state="translated">구현시이 기능은 페인트 엔진의 전류를 확인합니다.</target>
        </trans-unit>
        <trans-unit id="cb84a9cfef6f8292ec44602b7462e414abc9870a" translate="yes" xml:space="preserve">
          <source>When implementing a custom extension class, you must use Q_DECLARE_EXTENSION_INTERFACE() to enable usage of the &lt;a href=&quot;qextensionmanager#qt_extension&quot;&gt;qt_extension&lt;/a&gt;() function. The macro is normally located right after the class definition for</source>
          <target state="translated">사용자 정의 확장 클래스를 구현할 때 &lt;a href=&quot;qextensionmanager#qt_extension&quot;&gt;qt_extension&lt;/a&gt; () 함수 를 사용하려면 Q_DECLARE_EXTENSION_INTERFACE ()를 사용해야합니다 . 매크로는 일반적으로 클래스 정의 바로 뒤에 있습니다.</target>
        </trans-unit>
        <trans-unit id="84772bea2f59837a3da39c7af78975341f21eb2b" translate="yes" xml:space="preserve">
          <source>When implementing a custom style, you cannot assume that the widget is a &lt;a href=&quot;qspinbox&quot;&gt;QSpinBox&lt;/a&gt; just because the enum value is called &lt;a href=&quot;qstyle#PrimitiveElement-enum&quot;&gt;PE_IndicatorSpinUp&lt;/a&gt; or &lt;a href=&quot;qstyle#PrimitiveElement-enum&quot;&gt;PE_IndicatorSpinDown&lt;/a&gt;.</source>
          <target state="translated">사용자 정의 스타일을 구현할 때 열거 형 값이 &lt;a href=&quot;qstyle#PrimitiveElement-enum&quot;&gt;PE_IndicatorSpinUp&lt;/a&gt; 또는 &lt;a href=&quot;qstyle#PrimitiveElement-enum&quot;&gt;PE_IndicatorSpinDown&lt;/a&gt; 이라고 해서 위젯이 &lt;a href=&quot;qspinbox&quot;&gt;QSpinBox&lt;/a&gt; 라고 가정 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="869ecc6a6e96e1eee7be87f15ad29e53d15bface" translate="yes" xml:space="preserve">
          <source>When implementing a custom widget plugin, a pointer to</source>
          <target state="translated">사용자 정의 위젯 플러그인을 구현할 때</target>
        </trans-unit>
        <trans-unit id="b5e58b90ddc89647665b1bcd29b18d24dcef1559" translate="yes" xml:space="preserve">
          <source>When implementing a custom widget plugin, you build it as a separate library. If you want to include several custom widget plugins in the same library, you must in addition subclass &lt;a href=&quot;qdesignercustomwidgetcollectioninterface&quot;&gt;QDesignerCustomWidgetCollectionInterface&lt;/a&gt;.</source>
          <target state="translated">사용자 정의 위젯 플러그인을 구현할 때 별도의 라이브러리로 빌드하십시오. 동일한 라이브러리에 여러 개의 사용자 정의 위젯 플러그인을 포함 시키려면 또한 하위 클래스 &lt;a href=&quot;qdesignercustomwidgetcollectioninterface&quot;&gt;QDesignerCustomWidgetCollectionInterface&lt;/a&gt; 를 추가해야합니다 .</target>
        </trans-unit>
        <trans-unit id="5ea9264234b2724850203d32239a91745a3b4bcd" translate="yes" xml:space="preserve">
          <source>When implementing a custom widget plugin, you build it as a separate library. If you want to include several custom widget plugins in the same library, you must in addition subclass QDesignerCustomWidgetCollectionInterface.</source>
          <target state="translated">사용자 정의 위젯 플러그인을 구현할 때 별도의 라이브러리로 빌드합니다. 동일한 라이브러리에 여러 사용자 정의 위젯 플러그인을 포함하려면 추가로 QDesignerCustomWidgetCollectionInterface를 서브 클래스해야합니다.</target>
        </trans-unit>
        <trans-unit id="4c647a12112d8ed46e7c8ca84107c20d588614b0" translate="yes" xml:space="preserve">
          <source>When implementing a custom widget plugin, you must subclass the &lt;a href=&quot;qdesignercustomwidgetinterface&quot;&gt;QDesignerCustomWidgetInterface&lt;/a&gt; to expose your plugin to</source>
          <target state="translated">사용자 정의 위젯 플러그인을 구현할 때 플러그인 을 노출 시키려면 &lt;a href=&quot;qdesignercustomwidgetinterface&quot;&gt;QDesignerCustomWidgetInterface&lt;/a&gt; 를 서브 클래스해야합니다.</target>
        </trans-unit>
        <trans-unit id="91021ae6ff5dfe6164732e25da258734b737eb88" translate="yes" xml:space="preserve">
          <source>When implementing a custom widget you must subclass &lt;a href=&quot;qdesignercustomwidgetinterface&quot;&gt;QDesignerCustomWidgetInterface&lt;/a&gt; to expose your widget to</source>
          <target state="translated">사용자 정의 위젯을 구현할 때 위젯 을 노출 하려면 &lt;a href=&quot;qdesignercustomwidgetinterface&quot;&gt;QDesignerCustomWidgetInterface&lt;/a&gt; 를 서브 클래스해야합니다.</target>
        </trans-unit>
        <trans-unit id="98de48237e2610b3ed96ebfc3b4b3e1647ecb00b" translate="yes" xml:space="preserve">
          <source>When implementing a custom widget you must subclass QDesignerCustomWidgetInterface to expose your widget to</source>
          <target state="translated">사용자 정의 위젯을 구현할 때 위젯을 노출하려면 QDesignerCustomWidgetInterface를 하위 클래스로 만들어야합니다.</target>
        </trans-unit>
        <trans-unit id="595ba0ecf978bd65b6513cd7266fa82465645c81" translate="yes" xml:space="preserve">
          <source>When implementing a model it is important to remember that &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; does not store any data itself, it merely presents an interface that the views use to access the data. For a minimal read-only model it is only necessary to implement a few functions as there are default implementations for most of the interface. The class declaration is as follows:</source>
          <target state="translated">모델을 구현할 때 &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; 은 데이터 자체를 저장하지 않으며 뷰가 데이터에 액세스하는 데 사용하는 인터페이스 만 제공 한다는 점을 기억해야 합니다. 최소 읽기 전용 모델의 경우 대부분의 인터페이스에 대한 기본 구현이 있으므로 몇 가지 기능 만 구현하면됩니다. 클래스 선언은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="445cd07d2a0506cd16ff907563ea7c0e381a4ac2" translate="yes" xml:space="preserve">
          <source>When implementing a new widget, it is almost always useful to reimplement &lt;a href=&quot;qwidget#sizeHint-prop&quot;&gt;sizeHint&lt;/a&gt;() to provide a reasonable default size for the widget and to set the correct size policy with &lt;a href=&quot;qwidget#sizePolicy-prop&quot;&gt;setSizePolicy&lt;/a&gt;().</source>
          <target state="translated">새 위젯을 구현할 때 &lt;a href=&quot;qwidget#sizeHint-prop&quot;&gt;sizeHint&lt;/a&gt; () 를 다시 구현 하여 위젯에 적절한 기본 크기를 제공하고 &lt;a href=&quot;qwidget#sizePolicy-prop&quot;&gt;setSizePolicy&lt;/a&gt; () 를 사용하여 올바른 크기 정책을 설정하는 것이 거의 항상 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="4c9d446fde723c06b31550398f72ba270ba5a90c" translate="yes" xml:space="preserve">
          <source>When implementing a subclass of this interface, there are only a handful of functions to implement, broken down into two classes:</source>
          <target state="translated">이 인터페이스의 서브 클래스를 구현할 때 구현할 소수의 함수 만 두 가지 클래스로 나뉩니다.</target>
        </trans-unit>
        <trans-unit id="d65384984581a6d6fbb1f4f4bccbb7923f82cdc1" translate="yes" xml:space="preserve">
          <source>When implementing a subclass, you must call this function</source>
          <target state="translated">서브 클래스를 구현할 때이 함수를 호출해야합니다</target>
        </trans-unit>
        <trans-unit id="7c18f33bf2a59c6087f18cc24038056a308ad7f2" translate="yes" xml:space="preserve">
          <source>When implementing an accessibility interface for widgets, one would as a rule inherit &lt;a href=&quot;qaccessiblewidget&quot;&gt;QAccessibleWidget&lt;/a&gt;, which is a convenience class for widgets. Another available convenience class, which is inherited by &lt;a href=&quot;qaccessiblewidget&quot;&gt;QAccessibleWidget&lt;/a&gt;, is the &lt;a href=&quot;qaccessibleobject&quot;&gt;QAccessibleObject&lt;/a&gt;, which implements part of the interface for QObjects.</source>
          <target state="translated">위젯에 대한 액세스 가능성 인터페이스를 구현할 때, 위젯 의 편의 클래스 인 &lt;a href=&quot;qaccessiblewidget&quot;&gt;QAccessibleWidget을&lt;/a&gt; 상속 합니다. &lt;a href=&quot;qaccessiblewidget&quot;&gt;QAccessibleWidget&lt;/a&gt; 에 의해 상속되는 또 다른 사용 가능한 편의 클래스 는 &lt;a href=&quot;qaccessibleobject&quot;&gt;QObjects&lt;/a&gt; 인터페이스의 일부를 구현 하는 QAccessibleObject 입니다.</target>
        </trans-unit>
        <trans-unit id="4e43675b73f85281cf7ffd4c9feb92576f97c666" translate="yes" xml:space="preserve">
          <source>When implementing an item model (that is, a concrete &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; subclass) one must abide to a very strict set of rules that ensure consistency for users of the model (views, proxy models, and so on).</source>
          <target state="translated">아이템 모델 (구체적인 &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; 서브 클래스)을 구현할 때는 모델 사용자 (뷰, 프록시 모델 등)의 일관성을 보장하는 매우 엄격한 규칙을 준수해야합니다.</target>
        </trans-unit>
        <trans-unit id="71c25ae80d1eb821bd312d0369953f3099005788" translate="yes" xml:space="preserve">
          <source>When implementing drag and drop support in a custom model, if you will return data in formats other than the default internal MIME type, reimplement this function to return your list of MIME types.</source>
          <target state="translated">사용자 정의 모델에서 끌어서 놓기 지원을 구현할 때 기본 내부 MIME 유형 이외의 형식으로 데이터를 리턴하는 경우이 함수를 다시 구현하여 MIME 유형 목록을 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="3e1de2caa20c3401ccd297583ca14adb9e36f89e" translate="yes" xml:space="preserve">
          <source>When implementing drag and drop support in a custom model, it is possible to export items of data in specialized formats by reimplementing the following function:</source>
          <target state="translated">사용자 정의 모델에서 끌어서 놓기 지원을 구현할 때 다음 기능을 다시 구현하여 특수 형식으로 데이터 항목을 내보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="891ebe7dedc591934a24e2e5c92f98ba49623d2e" translate="yes" xml:space="preserve">
          <source>When implementing styles, it is necessary to look through the code of the widgets and code of the base class and its ancestors. This is because the widgets use the style differently, because the implementation in the different styles' virtual functions can affect the state of the drawing (e.g., by altering the &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; state without restoring it and drawing some elements without using the appropriate pixel metrics and sub elements).</source>
          <target state="translated">스타일을 구현할 때는 위젯 코드와 기본 클래스 및 상위 클래스의 코드를 살펴 봐야합니다. 이는 다른 스타일의 가상 함수에서의 구현이 드로잉의 상태에 영향을 줄 수 있기 때문에 위젯이 스타일을 다르게 사용하기 때문입니다 (예 : 적절한 픽셀 메트릭 및 하위를 사용하지 않고 &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; 상태를 복원하지 않고 변경하고 일부 요소를 드로잉하여) 집단).</target>
        </trans-unit>
        <trans-unit id="1c4d91075815fdbbae33aba2b667fd4633c4c3da" translate="yes" xml:space="preserve">
          <source>When implementing the property write function, use &lt;a href=&quot;qaxbindable#requestPropertyChange&quot;&gt;requestPropertyChange&lt;/a&gt;() to get permission from the ActiveX client application to change this property. When the property changes, call &lt;a href=&quot;qaxbindable#propertyChanged&quot;&gt;propertyChanged&lt;/a&gt;() to notify the ActiveX client application about the change. If a fatal error occurs in the control, use the static &lt;a href=&quot;qaxbindable#reportError&quot;&gt;reportError&lt;/a&gt;() function to notify the client.</source>
          <target state="translated">속성 쓰기 기능을 구현할 때 &lt;a href=&quot;qaxbindable#requestPropertyChange&quot;&gt;requestPropertyChange&lt;/a&gt; ()를 사용하여 ActiveX 클라이언트 응용 프로그램에서이 속성을 변경할 수있는 권한을 얻습니다. 속성이 변경되면 &lt;a href=&quot;qaxbindable#propertyChanged&quot;&gt;propertyChanged&lt;/a&gt; ()를 호출 하여 ActiveX 클라이언트 응용 프로그램에 변경 내용을 알립니다. 컨트롤에서 치명적인 오류가 발생하면 정적 &lt;a href=&quot;qaxbindable#reportError&quot;&gt;reportError&lt;/a&gt; () 함수를 사용하여 클라이언트에 알립니다.</target>
        </trans-unit>
        <trans-unit id="5c75a646668a787fcace5c55f81aa7bf0b70d1c6" translate="yes" xml:space="preserve">
          <source>When implementing the property write functions, use the &lt;a href=&quot;qaxbindable&quot;&gt;QAxBindable&lt;/a&gt; class's requestPropertyChange() and propertyChanged() functions to allow ActiveX clients to bind to the control properties.</source>
          <target state="translated">속성 쓰기 함수를 구현할 때 &lt;a href=&quot;qaxbindable&quot;&gt;QAxBindable&lt;/a&gt; 클래스의 requestPropertyChange () 및 propertyChanged () 함수를 사용하여 ActiveX 클라이언트가 컨트롤 속성에 바인딩 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b41031e55866a68b8184e142ce7198e2e1fe7ec" translate="yes" xml:space="preserve">
          <source>When implementing this function in subclasses of this class, you must construct and return new editor widgets with the parent widget specified.</source>
          <target state="translated">이 클래스의 서브 클래스에서이 함수를 구현할 때 지정된 상위 위젯으로 새 편집기 위젯을 구성하고 리턴해야합니다.</target>
        </trans-unit>
        <trans-unit id="1591d2c3ab41219fe3e148cfbb0593be15c3c678" translate="yes" xml:space="preserve">
          <source>When implementing this function in subclasses, you must ensure that the editor widget's property specified by this function can accept the type the creator is registered for. For example, a creator which constructs &lt;a href=&quot;qcheckbox&quot;&gt;QCheckBox&lt;/a&gt; widgets to edit boolean values would return the &lt;a href=&quot;qabstractbutton#checkable-prop&quot;&gt;checkable&lt;/a&gt; property name from this function, and must be registered in the item editor factory for the QVariant::Bool type.</source>
          <target state="translated">서브 클래스에서이 함수를 구현할 때이 함수로 지정된 편집기 위젯의 특성이 작성자가 등록 된 유형을 승인 할 수 있는지 확인해야합니다. 예를 들어, 부울 값을 편집하기 위해 &lt;a href=&quot;qcheckbox&quot;&gt;QCheckBox&lt;/a&gt; 위젯을 구성하는 작성자 는이 함수에서 &lt;a href=&quot;qabstractbutton#checkable-prop&quot;&gt;확인할 수있는&lt;/a&gt; 특성 이름을 리턴 하며 QVariant :: Bool 유형의 항목 편집기 팩토리에 등록해야합니다.</target>
        </trans-unit>
        <trans-unit id="8ce39d7538e9c5292578832459d332de3effbff1" translate="yes" xml:space="preserve">
          <source>When implementing this interface you will almost certainly also want to implement &lt;a href=&quot;qaccessibletextinterface&quot;&gt;QAccessibleTextInterface&lt;/a&gt;.</source>
          <target state="translated">이 인터페이스를 구현할 때 거의 확실하게 &lt;a href=&quot;qaccessibletextinterface&quot;&gt;QAccessibleTextInterface&lt;/a&gt; 구현을 원할 것 입니다.</target>
        </trans-unit>
        <trans-unit id="6268d96d04a4d653a0acc9732f0ac32216ce55c6" translate="yes" xml:space="preserve">
          <source>When implementing you own custom graphics transform, you must call this function every time you change a parameter, to let &lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt; know that its transformation needs to be updated.</source>
          <target state="translated">사용자 정의 그래픽 변환을 구현할 때 매개 변수를 변경할 때마다이 함수를 호출하여 &lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt; 에 변환이 업데이트 되어야 함을 알려야합니다 .</target>
        </trans-unit>
        <trans-unit id="e0faa4d1d0c8b9ed5d373ba76a73de237e335d71" translate="yes" xml:space="preserve">
          <source>When implementing your own implicitly shared classes, use the &lt;a href=&quot;qshareddata&quot;&gt;QSharedData&lt;/a&gt; and &lt;a href=&quot;qshareddatapointer&quot;&gt;QSharedDataPointer&lt;/a&gt; classes.</source>
          <target state="translated">내재적으로 공유 된 클래스를 구현할 때는 &lt;a href=&quot;qshareddata&quot;&gt;QSharedData&lt;/a&gt; 및 &lt;a href=&quot;qshareddatapointer&quot;&gt;QSharedDataPointer&lt;/a&gt; 클래스를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="ed089988e57c5a0f9eb64a54af80f4e4cc7da5be" translate="yes" xml:space="preserve">
          <source>When implementing your own itemview setSelection should call &lt;a href=&quot;qabstractitemview#selectionModel&quot;&gt;selectionModel&lt;/a&gt;()-&amp;gt;select(selection, flags) where selection is either an empty &lt;a href=&quot;qmodelindex&quot;&gt;QModelIndex&lt;/a&gt; or a &lt;a href=&quot;qitemselection&quot;&gt;QItemSelection&lt;/a&gt; that contains all items that are contained in</source>
          <target state="translated">자신의 itemview를 구현할 때 setSelection은 &lt;a href=&quot;qabstractitemview#selectionModel&quot;&gt;selectionModel&lt;/a&gt; ()-&amp;gt; select (selection, flags)를 호출해야합니다. 여기서 selection은 빈 &lt;a href=&quot;qmodelindex&quot;&gt;QModelIndex&lt;/a&gt; 또는에 포함 된 모든 항목을 포함 하는 &lt;a href=&quot;qitemselection&quot;&gt;QItemSelection&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="90d1ebe5eabb55f03ec9c6da6079f40a2ff77a3d" translate="yes" xml:space="preserve">
          <source>When implementing your own style and customizing controls, there are some points to keep in mind to ensure that your application is as performant as possible.</source>
          <target state="translated">고유 한 스타일을 구현하고 컨트롤을 사용자 지정할 때 응용 프로그램이 가능한 한 성능을 발휘할 수 있도록 몇 가지 유의해야 할 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b13759dc0478b7385db4120f936b29bbec97142e" translate="yes" xml:space="preserve">
          <source>When importing a &lt;a href=&quot;qtqml-typesystem-objecttypes&quot;&gt;QML object type&lt;/a&gt; with a property alias in the root object, however, the property appear as a regular Qt property and consequently can be used in alias references.</source>
          <target state="translated">그러나 루트 객체에서 속성 별칭이 있는 &lt;a href=&quot;qtqml-typesystem-objecttypes&quot;&gt;QML 객체 유형&lt;/a&gt; 을 가져올 때 속성은 일반 Qt 속성으로 나타나고 결과적으로 별칭 참조에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d2c6cac0080194cff24d54acaddace27ee77592" translate="yes" xml:space="preserve">
          <source>When importing a &lt;a href=&quot;qtqml-typesystem-objecttypes#&quot;&gt;QML object type&lt;/a&gt; with a property alias in the root object, however, the property appear as a regular Qt property and consequently can be used in alias references.</source>
          <target state="translated">그러나 루트 오브젝트에서 특성 별명을 가진 &lt;a href=&quot;qtqml-typesystem-objecttypes#&quot;&gt;QML 오브젝트 유형&lt;/a&gt; 을 가져올 때 , 특성은 일반 Qt 특성으로 나타나므로 별명 참조에 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="63972382ca72bfae9a1039f20443d3527d3f328d" translate="yes" xml:space="preserve">
          <source>When in Running state, &lt;a href=&quot;qtimeline&quot;&gt;QTimeLine&lt;/a&gt; also emits the &lt;a href=&quot;qtimeline#frameChanged&quot;&gt;frameChanged&lt;/a&gt;() signal when the frame changes.</source>
          <target state="translated">Running 상태 일 때 &lt;a href=&quot;qtimeline&quot;&gt;QTimeLine&lt;/a&gt; 은 프레임이 변경 될 때 &lt;a href=&quot;qtimeline#frameChanged&quot;&gt;frameChanged&lt;/a&gt; () 신호 도 방출합니다 .</target>
        </trans-unit>
        <trans-unit id="ef3e888a5ecf29cb8462a72debc447a17e27543a" translate="yes" xml:space="preserve">
          <source>When in StrictMode, if a parsing error is found, &lt;a href=&quot;qurl#isValid&quot;&gt;isValid&lt;/a&gt;() will return &lt;code&gt;false&lt;/code&gt; and &lt;a href=&quot;qurl#errorString&quot;&gt;errorString&lt;/a&gt;() will return a message describing the error. If more than one error is detected, it is undefined which error gets reported.</source>
          <target state="translated">StrictMode에있을 때 구문 분석 오류가 발견되면 &lt;a href=&quot;qurl#isValid&quot;&gt;isValid&lt;/a&gt; ()는 &lt;code&gt;false&lt;/code&gt; 를 반환 하고 &lt;a href=&quot;qurl#errorString&quot;&gt;errorString&lt;/a&gt; ()은 오류를 설명하는 메시지를 반환합니다. 둘 이상의 오류가 감지되면 어떤 오류가보고되는지 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3456c56afa83ec7dbd61d985f62e50c29f6549e1" translate="yes" xml:space="preserve">
          <source>When in keyboard-interactive mode, you can use the arrow and page keys to either move or resize the window. This property controls the arrow keys. The common way to enter keyboard interactive mode is to enter the subwindow menu, and select either &quot;resize&quot; or &quot;move&quot;.</source>
          <target state="translated">키보드 대화 형 모드에서 화살표 및 페이지 키를 사용하여 창을 이동하거나 크기를 조정할 수 있습니다. 이 속성은 화살표 키를 제어합니다. 키보드 대화식 모드로 들어가는 일반적인 방법은 하위 창 메뉴로 들어가서 &quot;크기 조정&quot;또는 &quot;이동&quot;을 선택하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="3fb322ebc9c9cd2d657c0fb9d224a6635a538d7d" translate="yes" xml:space="preserve">
          <source>When in keyboard-interactive mode, you can use the arrow and page keys to either move or resize the window. This property controls the page keys. The common way to enter keyboard interactive mode is to enter the subwindow menu, and select either &quot;resize&quot; or &quot;move&quot;.</source>
          <target state="translated">키보드 대화 형 모드에서 화살표 및 페이지 키를 사용하여 창을 이동하거나 크기를 조정할 수 있습니다. 이 속성은 페이지 키를 제어합니다. 키보드 대화식 모드로 들어가는 일반적인 방법은 하위 창 메뉴로 들어가서 &quot;크기 조정&quot;또는 &quot;이동&quot;을 선택하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="2c08753db2a8aa137364ee7093529568335fe121" translate="yes" xml:space="preserve">
          <source>When inheriting &lt;a href=&quot;qabstractscrollarea&quot;&gt;QAbstractScrollArea&lt;/a&gt;, you need to do the following:</source>
          <target state="translated">&lt;a href=&quot;qabstractscrollarea&quot;&gt;QAbstractScrollArea를&lt;/a&gt; 상속 할 때 다음을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="9110d9a8dc385178c6df16681bf45970bc611881" translate="yes" xml:space="preserve">
          <source>When inheriting QAbstractScrollArea, you need to do the following:</source>
          <target state="translated">QAbstractScrollArea를 상속 할 때 다음을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="ef5ec1307e1565c3ba533b6306e4c4fb6e84f432" translate="yes" xml:space="preserve">
          <source>When inserting action items you usually specify a receiver and a slot. The receiver will be notifed whenever the item is &lt;a href=&quot;qaction#triggered&quot;&gt;triggered()&lt;/a&gt;. In addition, &lt;a href=&quot;qmenu&quot;&gt;QMenu&lt;/a&gt; provides two signals, &lt;a href=&quot;qmenu#triggered&quot;&gt;triggered&lt;/a&gt;() and &lt;a href=&quot;qmenu#hovered&quot;&gt;hovered&lt;/a&gt;(), which signal the &lt;a href=&quot;qaction&quot;&gt;QAction&lt;/a&gt; that was triggered from the menu.</source>
          <target state="translated">동작 항목을 삽입 할 때 일반적으로 수신기와 슬롯을 지정합니다. 항목이 &lt;a href=&quot;qaction#triggered&quot;&gt;트리거&lt;/a&gt; 될 때마다 수신자에게 통지됩니다 () . 또한 &lt;a href=&quot;qmenu&quot;&gt;QMenu를이&lt;/a&gt; 두 신호 제공 &lt;a href=&quot;qmenu#triggered&quot;&gt;트리거&lt;/a&gt; () 및 &lt;a href=&quot;qmenu#hovered&quot;&gt;맴돌고&lt;/a&gt; 신호 () &lt;a href=&quot;qaction&quot;&gt;QAction&lt;/a&gt; 메뉴에서 유발 하였다.</target>
        </trans-unit>
        <trans-unit id="b0a12f123004137273217a41fe960ac1382b53f8" translate="yes" xml:space="preserve">
          <source>When inserting action items you usually specify a receiver and a slot. The receiver will be notifed whenever the item is &lt;a href=&quot;qaction#triggered&quot;&gt;triggered()&lt;/a&gt;. In addition, QMenu provides two signals, &lt;a href=&quot;qmenu#triggered&quot;&gt;triggered&lt;/a&gt;() and &lt;a href=&quot;qmenu#hovered&quot;&gt;hovered&lt;/a&gt;(), which signal the &lt;a href=&quot;qaction&quot;&gt;QAction&lt;/a&gt; that was triggered from the menu.</source>
          <target state="translated">작업 항목을 삽입 할 때 일반적으로 수신기와 슬롯을 지정합니다. 수신자는 항목이 &lt;a href=&quot;qaction#triggered&quot;&gt;triggered ()&lt;/a&gt; 될 때마다 알림을받습니다 . 또한 QMenu는 메뉴에서 트리거 된 &lt;a href=&quot;qaction&quot;&gt;QAction&lt;/a&gt; 을 알리는 &lt;a href=&quot;qmenu#triggered&quot;&gt;트리거&lt;/a&gt; () 및 &lt;a href=&quot;qmenu#hovered&quot;&gt;hovered&lt;/a&gt; ()의 두 신호를 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="864005fb46a1674119933552576b5eb471667e9c" translate="yes" xml:space="preserve">
          <source>When inserting multiple records, you only need to call &lt;a href=&quot;qsqlquery#prepare&quot;&gt;QSqlQuery::prepare&lt;/a&gt;() once. Then you call &lt;a href=&quot;qsqlquery#bindValue&quot;&gt;bindValue()&lt;/a&gt; or &lt;a href=&quot;qsqlquery#addBindValue&quot;&gt;addBindValue()&lt;/a&gt; followed by &lt;a href=&quot;qsqlquery#exec-1&quot;&gt;exec()&lt;/a&gt; as many times as necessary.</source>
          <target state="translated">여러 레코드를 삽입 할 때는 &lt;a href=&quot;qsqlquery#prepare&quot;&gt;QSqlQuery :: prepare&lt;/a&gt; ()를 한 번만 호출 하면됩니다. 그런 다음 &lt;a href=&quot;qsqlquery#bindValue&quot;&gt;bindValue ()&lt;/a&gt; 또는 &lt;a href=&quot;qsqlquery#addBindValue&quot;&gt;addBindValue ()&lt;/a&gt; 와 &lt;a href=&quot;qsqlquery#exec-1&quot;&gt;exec ()&lt;/a&gt; 를 필요한 횟수만큼 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="f4a6a2c17602b8ef1614b658343d290c1bd56516" translate="yes" xml:space="preserve">
          <source>When inserting such a fragment into a &lt;a href=&quot;qtextdocument&quot;&gt;QTextDocument&lt;/a&gt; the current char format of the &lt;a href=&quot;qtextcursor&quot;&gt;QTextCursor&lt;/a&gt; used for insertion is used as format for the text.</source>
          <target state="translated">(A) 내로 이러한 단편을 삽입 할 때 &lt;a href=&quot;qtextdocument&quot;&gt;QTextDocument&lt;/a&gt; 의 현재 문자 형식 &lt;a href=&quot;qtextcursor&quot;&gt;QTextCursor&lt;/a&gt; 삽입 사용이 텍스트 형식으로 사용된다.</target>
        </trans-unit>
        <trans-unit id="6ee49651f87fc18143f2662752cc1cf4e9cb8b10" translate="yes" xml:space="preserve">
          <source>When integrating existing classes and technology into QML, APIs will often need tweaking to fit better into the declarative environment. Although the best results are usually obtained by modifying the original classes directly, if this is either not possible or is complicated by some other concerns, extension objects allow limited extension possibilities without direct modifications.</source>
          <target state="translated">기존 클래스와 기술을 QML에 통합 할 때 선언 환경에 더 잘 맞도록 API를 조정해야하는 경우가 종종 있습니다. 일반적으로 원래 클래스를 직접 수정하여 최상의 결과를 얻을 수 있지만 이것이 불가능하거나 다른 문제로 인해 복잡 할 경우 확장 개체는 직접 수정하지 않고도 확장 가능성을 제한 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="46cd534349e4b4409b3a901102a23c1cbd1d64c6" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qcolor&quot;&gt;QColor&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;color&lt;/code&gt; value, and vice-versa.</source>
          <target state="translated">C ++와 통합 할 때 C ++에서 &lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;QML로 전달 된 &lt;/a&gt;&lt;a href=&quot;qcolor&quot;&gt;QColor&lt;/a&gt; 값 은 자동으로 &lt;code&gt;color&lt;/code&gt; 값 으로 변환되며 그 반대도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="59e07d9cc2cac329614b7169422187bba763b0d8" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt; or &lt;a href=&quot;qdatetime&quot;&gt;QDateTime&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;date&lt;/code&gt; value, and vice-versa. Note, however, that converting a &lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt; will result in UTC's start of the day, which falls on a different date in some other time-zones. It is usually more robust to convert the &lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt; via a &lt;a href=&quot;qdatetime&quot;&gt;QDateTime&lt;/a&gt; explicitly, specifying local-time or a relevant time-zone and selecting a time of day (such as noon) that reliably exists (daylight-savings transitions skip an hour, near one end or the other of a day).</source>
          <target state="translated">C ++와 통합 할 때 C ++에서 &lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;QML로 전달 된&lt;/a&gt; 모든 &lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt; 또는 &lt;a href=&quot;qdatetime&quot;&gt;QDateTime&lt;/a&gt; 값 은 자동으로 &lt;code&gt;date&lt;/code&gt; 값 으로 변환되며 그 반대의 경우도 마찬가지입니다. 그러나 &lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt; 를 변환하면 UTC의 하루가 시작되며 다른 시간대에서는 다른 날짜에 해당합니다. 변환 일반적으로 더 강력 &lt;a href=&quot;qdate&quot;&gt;QDate을&lt;/a&gt; 비아 &lt;a href=&quot;qdatetime&quot;&gt;QDateTime&lt;/a&gt; (예 : 정오)를 안정적으로 존재 (일광 절약 전환 한 끝 부분에서, 시간을 건너 뛸 현지 시간 또는 해당 시간대를 지정하고 하루의 시간을 선택, 명시 적으로 또는 다른 하루).</target>
        </trans-unit>
        <trans-unit id="94f4f40b3918cac601587862fbf8acc3e95d325a" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt; or &lt;a href=&quot;qdatetime&quot;&gt;QDateTime&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;date&lt;/code&gt; value, and vice-versa. Note, however, that converting a &lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt; will result in UTC's start of the day, which falls on a different date in some other time-zones. It is usually more robust to convert the &lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt; via a &lt;a href=&quot;qdatetime&quot;&gt;QDateTime&lt;/a&gt; explicitly, specifying local-time or a relevant time-zone and selecting a time of day (such as noon) that reliably exists (daylight-savings transitions skip an hour, near one end or the other of a day).</source>
          <target state="translated">C ++와 통합 할 때 C ++에서 &lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;QML로 전달 된 &lt;/a&gt;&lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt; 또는 &lt;a href=&quot;qdatetime&quot;&gt;QDateTime&lt;/a&gt; 값 은 자동으로 &lt;code&gt;date&lt;/code&gt; 값 으로 변환되며 그 반대도 마찬가지입니다. 그러나 &lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt; 를 변환하면 UTC가 시작되어 다른 시간대의 다른 날짜로 표시됩니다. 일반적으로 현지 시간 또는 관련 시간대를 지정하고 안정적으로 존재하는 시간 (정오와 같은)을 선택하여 (일광 절약 전환이 한 쪽 끝에서 한 시간 건너 뛰기) &lt;a href=&quot;qdate&quot;&gt;QDateTime을&lt;/a&gt; 통해 &lt;a href=&quot;qdatetime&quot;&gt;QDate를&lt;/a&gt; 명시 적으로 변환하는 것이 더 강력 합니다. 또는 다른 날).</target>
        </trans-unit>
        <trans-unit id="2a3e9ea44f85bb16e221814f180ac27358c1f643" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qfont&quot;&gt;QFont&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;font&lt;/code&gt; value, and vice-versa.</source>
          <target state="translated">C ++와 통합 할 때 C ++에서 &lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;QML로 전달 된 &lt;/a&gt;&lt;a href=&quot;qfont&quot;&gt;QFont&lt;/a&gt; 값 은 자동으로 &lt;code&gt;font&lt;/code&gt; 값 으로 변환되며 그 반대도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="c80b7cd162c43b0104ef58b6d7d770bb2b3dc0c9" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qgeocircle&quot;&gt;QGeoCircle&lt;/a&gt; value passed into QML from C++ is automatically converted into a &lt;code&gt;geocircle&lt;/code&gt; value, and vise-versa.</source>
          <target state="translated">C ++과 통합 할 때 C ++에서 QML로 전달 된 &lt;a href=&quot;qgeocircle&quot;&gt;QGeoCircle&lt;/a&gt; 값은 자동으로 &lt;code&gt;geocircle&lt;/code&gt; 값 으로 변환되며 그 반대도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="f90dc519be0e60fb444dc1c5260f47cc6cd907ee" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qgeocoordinate&quot;&gt;QGeoCoordinate&lt;/a&gt; value passed into QML from C++ is automatically converted into a &lt;code&gt;coordinate&lt;/code&gt; value, and vice-versa.</source>
          <target state="translated">C ++와 통합 할 때 C ++에서 QML로 전달 된 &lt;a href=&quot;qgeocoordinate&quot;&gt;QGeoCoordinate&lt;/a&gt; 값은 자동으로 &lt;code&gt;coordinate&lt;/code&gt; 값 으로 변환되며 그 반대도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="c5bbf6333d877f577a96dba2b55b5c884f293ae5" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qgeopath&quot;&gt;QGeoPath&lt;/a&gt; value passed into QML from C++ is automatically converted into a &lt;code&gt;geopath&lt;/code&gt; value, and vice versa.</source>
          <target state="translated">C ++와 통합 할 때 C ++에서 QML로 전달 된 &lt;a href=&quot;qgeopath&quot;&gt;QGeoPath&lt;/a&gt; 값은 자동으로 &lt;code&gt;geopath&lt;/code&gt; 값 으로 변환되며 그 반대도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="fc4029c75e55b88c42d4329274584c8e9c0128eb" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qgeopolygon&quot;&gt;QGeoPolygon&lt;/a&gt; value passed into QML is automatically converted into a &lt;code&gt;geopolygon&lt;/code&gt;, and vice versa.</source>
          <target state="translated">C ++와 통합 할 때 QML로 전달 된 &lt;a href=&quot;qgeopolygon&quot;&gt;QGeoPolygon&lt;/a&gt; 값은 자동으로 &lt;code&gt;geopolygon&lt;/code&gt; 으로 변환되며 그 반대도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="a7dba58612710895f3116ae91ec3e71bc80778eb" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qgeorectangle&quot;&gt;QGeoRectangle&lt;/a&gt; value passed into QML from C++ is automatically converted into a &lt;code&gt;georectangle&lt;/code&gt; value, and vice-versa.</source>
          <target state="translated">C ++와 통합 할 때 C ++에서 QML로 전달 된 &lt;a href=&quot;qgeorectangle&quot;&gt;QGeoRectangle&lt;/a&gt; 값은 자동으로 &lt;code&gt;georectangle&lt;/code&gt; 값 으로 변환되며 그 반대도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="4d5c3d73097853ceb2db3f5a71a11d6fad5cb8d2" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qgeoshape&quot;&gt;QGeoShape&lt;/a&gt; value passed into QML from C++ is automatically converted into a &lt;code&gt;geoshape&lt;/code&gt; value, and vice-versa.</source>
          <target state="translated">C ++와 통합 할 때 C ++에서 QML로 전달 된 &lt;a href=&quot;qgeoshape&quot;&gt;QGeoShape&lt;/a&gt; 값은 자동으로 &lt;code&gt;geoshape&lt;/code&gt; 값 으로 변환되며 그 반대도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="babd158b5780227850bc5ed9c758d5d58d7cd1f2" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qpoint&quot;&gt;QPoint&lt;/a&gt; or &lt;a href=&quot;qpointf&quot;&gt;QPointF&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;point&lt;/code&gt; value. When a &lt;code&gt;point&lt;/code&gt; value is passed to C++, it is automatically converted into a &lt;a href=&quot;qpointf&quot;&gt;QPointF&lt;/a&gt; value.</source>
          <target state="translated">C ++와 통합 할 때 C ++에서 &lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;QML로 전달 된&lt;/a&gt; 모든 &lt;a href=&quot;qpoint&quot;&gt;QPoint&lt;/a&gt; 또는 &lt;a href=&quot;qpointf&quot;&gt;QPointF&lt;/a&gt; 값 은 자동으로 &lt;code&gt;point&lt;/code&gt; 값 으로 변환됩니다 . &lt;code&gt;point&lt;/code&gt; 값이 C ++로 전달 되면 자동으로 &lt;a href=&quot;qpointf&quot;&gt;QPointF&lt;/a&gt; 값 으로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="06f6b135e98805bdd8065da59a778cd9f4c5215e" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qpoint&quot;&gt;QPoint&lt;/a&gt; or &lt;a href=&quot;qpointf&quot;&gt;QPointF&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;point&lt;/code&gt; value. When a &lt;code&gt;point&lt;/code&gt; value is passed to C++, it is automatically converted into a &lt;a href=&quot;qpointf&quot;&gt;QPointF&lt;/a&gt; value.</source>
          <target state="translated">C ++와 통합 할 때 C ++에서 &lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;QML로 전달 된 &lt;/a&gt;&lt;a href=&quot;qpoint&quot;&gt;QPoint&lt;/a&gt; 또는 &lt;a href=&quot;qpointf&quot;&gt;QPointF&lt;/a&gt; 값 은 자동으로 &lt;code&gt;point&lt;/code&gt; 값 으로 변환됩니다 . &lt;code&gt;point&lt;/code&gt; 값이 C ++로 전달 되면 자동으로 &lt;a href=&quot;qpointf&quot;&gt;QPointF&lt;/a&gt; 값 으로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="a84623eea3626c41bb0f62625b89382e6a0884d2" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qqmllistproperty&quot;&gt;QQmlListProperty&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;list&lt;/code&gt; value, and vice-versa.</source>
          <target state="translated">C ++와 통합 할 때 C ++에서 &lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;QML로 전달 된&lt;/a&gt; 모든 &lt;a href=&quot;qqmllistproperty&quot;&gt;QQmlListProperty&lt;/a&gt; 값 은 자동으로 &lt;code&gt;list&lt;/code&gt; 값 으로 변환되며 그 반대의 경우도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="4537d2f61ed5eb33aa48c28e4d1f2cbe5739fee6" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qqmllistproperty&quot;&gt;QQmlListProperty&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;list&lt;/code&gt; value, and vice-versa.</source>
          <target state="translated">C ++와 통합 할 때 C ++에서 &lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;QML로 전달 된 &lt;/a&gt;&lt;a href=&quot;qqmllistproperty&quot;&gt;QQmlListProperty&lt;/a&gt; 값 은 자동으로 &lt;code&gt;list&lt;/code&gt; 값 으로 변환되며 그 반대도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="892030f32ca7d95430d43e3adb51ab41646ac62c" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt; or &lt;a href=&quot;qrectf&quot;&gt;QRectF&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;rect&lt;/code&gt; value, and vice-versa. When a &lt;code&gt;rect&lt;/code&gt; value is passed to C++, it is automatically converted into a &lt;a href=&quot;qrectf&quot;&gt;QRectF&lt;/a&gt; value.</source>
          <target state="translated">C ++와 통합 할 때 C ++에서 &lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;QML로 전달 된&lt;/a&gt; 모든 &lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt; 또는 &lt;a href=&quot;qrectf&quot;&gt;QRectF&lt;/a&gt; 값 은 자동으로 &lt;code&gt;rect&lt;/code&gt; 값 으로 변환되며 그 반대의 경우도 마찬가지입니다. &lt;code&gt;rect&lt;/code&gt; 값이 C ++로 전달 되면 자동으로 &lt;a href=&quot;qrectf&quot;&gt;QRectF&lt;/a&gt; 값 으로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="bde76fc240f3c1a3b45734a6b9372df275b0771e" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt; or &lt;a href=&quot;qrectf&quot;&gt;QRectF&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;rect&lt;/code&gt; value, and vice-versa. When a &lt;code&gt;rect&lt;/code&gt; value is passed to C++, it is automatically converted into a &lt;a href=&quot;qrectf&quot;&gt;QRectF&lt;/a&gt; value.</source>
          <target state="translated">C ++와 통합 할 때 C ++에서 &lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;QML로 전달 된 &lt;/a&gt;&lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt; 또는 &lt;a href=&quot;qrectf&quot;&gt;QRectF&lt;/a&gt; 값 은 자동으로 &lt;code&gt;rect&lt;/code&gt; 값 으로 변환되며 그 반대도 마찬가지입니다. &lt;code&gt;rect&lt;/code&gt; 값이 C ++에 전달 되면 자동으로 &lt;a href=&quot;qrectf&quot;&gt;QRectF&lt;/a&gt; 값 으로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="e7418f4bf29ec0eb129b2a465879400da12bc2de" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qsize&quot;&gt;QSize&lt;/a&gt; or &lt;a href=&quot;qsizef&quot;&gt;QSizeF&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;size&lt;/code&gt; value, and vice-versa. When a &lt;code&gt;size&lt;/code&gt; value is passed to C++, it is automatically converted into a &lt;a href=&quot;qsizef&quot;&gt;QSizeF&lt;/a&gt; value.</source>
          <target state="translated">C ++와 통합 할 때 C ++에서 &lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;QML로 전달 된&lt;/a&gt; 모든 &lt;a href=&quot;qsize&quot;&gt;QSize&lt;/a&gt; 또는 &lt;a href=&quot;qsizef&quot;&gt;QSizeF&lt;/a&gt; 값 은 자동으로 &lt;code&gt;size&lt;/code&gt; 값 으로 변환되며 그 반대의 경우도 마찬가지입니다. &lt;code&gt;size&lt;/code&gt; 값이 C ++로 전달 되면 자동으로 &lt;a href=&quot;qsizef&quot;&gt;QSizeF&lt;/a&gt; 값 으로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="efe91bec14c646d63c8cb49b132911ca4fb70cf2" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qsize&quot;&gt;QSize&lt;/a&gt; or &lt;a href=&quot;qsizef&quot;&gt;QSizeF&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;size&lt;/code&gt; value, and vice-versa. When a &lt;code&gt;size&lt;/code&gt; value is passed to C++, it is automatically converted into a &lt;a href=&quot;qsizef&quot;&gt;QSizeF&lt;/a&gt; value.</source>
          <target state="translated">C ++와 통합 할 때 C ++에서 &lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;QML로 전달 된 &lt;/a&gt;&lt;a href=&quot;qsize&quot;&gt;QSize&lt;/a&gt; 또는 &lt;a href=&quot;qsizef&quot;&gt;QSizeF&lt;/a&gt; 값 은 자동으로 &lt;code&gt;size&lt;/code&gt; 값 으로 변환되며 그 반대도 마찬가지입니다. &lt;code&gt;size&lt;/code&gt; 값이 C ++로 전달 되면 자동으로 &lt;a href=&quot;qsizef&quot;&gt;QSizeF&lt;/a&gt; 값 으로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="3ce59b6a0f0b4b392e20d60442b247d4ac83798d" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;string&lt;/code&gt; value, and vice-versa.</source>
          <target state="translated">C ++와 통합 할 때 C ++에서 &lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;QML로 전달 된&lt;/a&gt; 모든 &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; 값 은 자동으로 &lt;code&gt;string&lt;/code&gt; 값 으로 변환되며 그 반대의 경우도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="7fd4e1a3e2c35dda93f104508cebf19c9ae03217" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;string&lt;/code&gt; value, and vice-versa.</source>
          <target state="translated">C ++와 통합 할 때 C ++에서 &lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;QML로 전달 된 &lt;/a&gt;&lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; 값 은 자동으로 &lt;code&gt;string&lt;/code&gt; 값 으로 변환되며 그 반대도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="c9d28617421e54fcce89cbef003fdb53a193660b" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qurl&quot;&gt;QUrl&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;url&lt;/code&gt; value, and vice-versa.</source>
          <target state="translated">C ++와 통합 할 때 C ++에서 &lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;QML로 전달 된&lt;/a&gt; 모든 &lt;a href=&quot;qurl&quot;&gt;QUrl&lt;/a&gt; 값 은 자동으로 &lt;code&gt;url&lt;/code&gt; 값 으로 변환되며 그 반대의 경우도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="b5784d74b9c118ae7229636ff92faf312a5dfe71" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qurl&quot;&gt;QUrl&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;url&lt;/code&gt; value, and vice-versa.</source>
          <target state="translated">C ++와 통합 할 때 C ++에서 &lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;QML로 전달 된 &lt;/a&gt;&lt;a href=&quot;qurl&quot;&gt;QUrl&lt;/a&gt; 값 은 자동으로 &lt;code&gt;url&lt;/code&gt; 값 으로 변환되며 그 반대도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="ed02fd90e62a507cb5dc19431423e1b9374d396b" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;variant&lt;/code&gt; value, and vice-versa.</source>
          <target state="translated">C ++와 통합 할 때 C ++에서 &lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;QML로 전달 된&lt;/a&gt; 모든 &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; 값 은 자동으로 &lt;code&gt;variant&lt;/code&gt; 값 으로 변환되며 그 반대의 경우도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="4782c07688335b98c18e7337dd4cb33a506d5caa" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;variant&lt;/code&gt; value, and vice-versa.</source>
          <target state="translated">C ++와 통합 할 때 C ++에서 &lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;QML로 전달 된 &lt;/a&gt;&lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; 값 은 자동으로 &lt;code&gt;variant&lt;/code&gt; 값 으로 변환되며 그 반대도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="0f08c295ab9d317506d3417a8c5ed2ce92dffe9c" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qvector3d&quot;&gt;QVector3D&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;vector3d&lt;/code&gt; value, and vice-versa.</source>
          <target state="translated">C ++와 통합 할 때 C ++에서 &lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;QML로 전달 된 &lt;/a&gt;&lt;a href=&quot;qvector3d&quot;&gt;QVector3D&lt;/a&gt; 값 은 자동으로 &lt;code&gt;vector3d&lt;/code&gt; 값 으로 변환되며 그 반대도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="91da3853e2ebc605267bec0ae228daafb92fc978" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;code&gt;enum&lt;/code&gt; value &lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into an &lt;code&gt;enumeration&lt;/code&gt; value, and vice-versa.</source>
          <target state="translated">C ++와 통합 할 때 C ++에서 &lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;QML로 전달 된&lt;/a&gt; 모든 &lt;code&gt;enum&lt;/code&gt; 값 은 자동으로 &lt;code&gt;enumeration&lt;/code&gt; 값 으로 변환되며 그 반대의 경우도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="174229e59467abdea54b7e746d86e6764e7d6c9d" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;code&gt;enum&lt;/code&gt; value &lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into an &lt;code&gt;enumeration&lt;/code&gt; value, and vice-versa.</source>
          <target state="translated">C와 통합 할 때 ++, 기록이있는 것을 &lt;code&gt;enum&lt;/code&gt; 값 &lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;C ++에서 QML로 전달이&lt;/a&gt; 자동으로 변환됩니다 &lt;code&gt;enumeration&lt;/code&gt; 값, 그 반대의 경우도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="f7482e71bbdd52848ddeffbe95fcd0b8e2b5663e" translate="yes" xml:space="preserve">
          <source>When interacted with a mouse device, flicking is disabled and the scroll bars are interactive.</source>
          <target state="translated">마우스 장치와 상호 작용할 때 깜박임이 비활성화되고 스크롤 막대가 대화 형입니다.</target>
        </trans-unit>
        <trans-unit id="8777d7fa43f475169d9e2b3537e4248eaedbf1d8" translate="yes" xml:space="preserve">
          <source>When intermixing &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; and OpenGL, it is important to notify &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; that the OpenGL state may have been cluttered so it can restore its internal state. This is achieved by calling &lt;a href=&quot;qpainter#beginNativePainting&quot;&gt;QPainter::beginNativePainting&lt;/a&gt;() before starting the OpenGL rendering and calling &lt;a href=&quot;qpainter#endNativePainting&quot;&gt;QPainter::endNativePainting&lt;/a&gt;() after finishing.</source>
          <target state="translated">&lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; 와 OpenGL을 혼합 할 때 OpenGL 상태가 어수선 해 내부 상태를 복원 할 수 있음을 &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; 에 알리는 것이 중요합니다 . 이 호출에 의해 달성된다 &lt;a href=&quot;qpainter#beginNativePainting&quot;&gt;QPainter를 :: beginNativePainting을&lt;/a&gt; OpenGL을 렌더링을 시작하고 호출하기 전에 () &lt;a href=&quot;qpainter#endNativePainting&quot;&gt;QPainter를을 :: endNativePainting&lt;/a&gt; 마무리 한 후 ().</target>
        </trans-unit>
        <trans-unit id="3c3351ce7fa4daf3d510e3944f9c0b1cd89614d0" translate="yes" xml:space="preserve">
          <source>When interoperating with another graphics engine, it may be necessary to get a QRhi instance that uses the same Metal device. This can be achieved by passing a pointer to a &lt;a href=&quot;qrhimetalnativehandles&quot;&gt;QRhiMetalNativeHandles&lt;/a&gt; to &lt;a href=&quot;qrhi#create&quot;&gt;QRhi::create&lt;/a&gt;(). The device must be set to a non-null value then. Optionally, a command queue object can be specified as well.</source>
          <target state="translated">다른 그래픽 엔진과 상호 운용 할 때 동일한 Metal 장치를 사용하는 QRhi 인스턴스를 가져와야 할 수 있습니다. &lt;a href=&quot;qrhimetalnativehandles&quot;&gt;QRhiMetalNativeHandles&lt;/a&gt; 에 대한 포인터 를 &lt;a href=&quot;qrhi#create&quot;&gt;QRhi :: create&lt;/a&gt; () 에 전달하면 됩니다. 그러면 장치는 널이 아닌 값으로 설정되어야합니다. 선택적으로 명령 대기열 객체도 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="61bd4cd2f160b9517401ee938d1cc345306ee16b" translate="yes" xml:space="preserve">
          <source>When invoking QDoc on a project that has dependencies and uses the &lt;code&gt;depends&lt;/code&gt; variable, one or more &lt;code&gt;-indexdir&lt;/code&gt; path(s) must be passed as command line option(s). QDoc uses these paths to search for the dependencies' index files.</source>
          <target state="translated">종속성을 가지고 있으며이 사용하는 프로젝트에 QDOC를 호출 할 때 &lt;code&gt;depends&lt;/code&gt; , 하나 또는 그 이상의 변수를 &lt;code&gt;-indexdir&lt;/code&gt; 경로 (들)을 명령 줄 옵션 (들)로 전달해야합니다. QDoc은 이러한 경로를 사용하여 종속성의 색인 파일을 검색합니다.</target>
        </trans-unit>
        <trans-unit id="19950d97cb8c934f1e5c65f401298cb13bebd643" translate="yes" xml:space="preserve">
          <source>When invoking one of these options, or when an error happens (for instance an unknown option was passed), the current process will then stop, using the exit() function.</source>
          <target state="translated">이러한 옵션 중 하나를 호출하거나 오류 (예 : 알 수없는 옵션이 전달 된 경우)가 발생하면 exit () 함수를 사용하여 현재 프로세스가 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="071c0d6d52ee604f468daeb0ab63c0a2099e201d" translate="yes" xml:space="preserve">
          <source>When it comes to more complex controls, it is sometimes better to split them up into separate building blocks. As an example, the complex &lt;a href=&quot;qml-qtquick-controls2-scrollview&quot;&gt;ScrollView&lt;/a&gt; control:</source>
          <target state="translated">더 복잡한 컨트롤에 관해서는, 때로는 별도의 빌딩 블록으로 나누는 것이 좋습니다. 예를 들어 복잡한 &lt;a href=&quot;qml-qtquick-controls2-scrollview&quot;&gt;ScrollView&lt;/a&gt; 컨트롤은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8e8c72fd29bc00795105647d117aa1d234784718" translate="yes" xml:space="preserve">
          <source>When it comes to rendering, deferred rendering is a different beast in terms of renderer configuration compared to forward rendering. Instead of drawing each mesh and applying a shader effect to shade it, deferred rendering adopts a</source>
          <target state="translated">렌더링의 경우 지연 렌더링은 정방향 렌더링과 비교하여 렌더러 구성 측면에서 다른 짐승입니다. 각 메시를 그리고 셰이더 효과를 적용하여 음영 처리하는 대신 지연 렌더링은</target>
        </trans-unit>
        <trans-unit id="626ed890d480d0a4b856052f27b67e8d0b322b1a" translate="yes" xml:space="preserve">
          <source>When it comes to texture support, the &lt;a href=&quot;qt3drender-qparameter&quot;&gt;QParameter&lt;/a&gt; value should be set to the appropriate &lt;a href=&quot;qt3drender-qabstracttexture&quot;&gt;QAbstractTexture&lt;/a&gt; subclass that matches the sampler type of the shader uniform.</source>
          <target state="translated">텍스처 지원과 관련하여 &lt;a href=&quot;qt3drender-qparameter&quot;&gt;QParameter&lt;/a&gt; 값은 쉐이더 유니폼의 샘플러 유형과 일치하는 적절한 &lt;a href=&quot;qt3drender-qabstracttexture&quot;&gt;QAbstractTexture&lt;/a&gt; 서브 클래스 로 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="5979b40af94b30c33380148b42cb7fe798d86843" translate="yes" xml:space="preserve">
          <source>When it comes to texture support, the Parameter value should be set to the appropriate &lt;a href=&quot;qt3drender-qabstracttexture&quot;&gt;texture&lt;/a&gt; subclass that matches the sampler type of the shader uniform.</source>
          <target state="translated">텍스처 지원과 관련하여 Parameter 값은 쉐이더 유니폼의 샘플러 유형과 일치하는 적절한 &lt;a href=&quot;qt3drender-qabstracttexture&quot;&gt;텍스처&lt;/a&gt; 서브 클래스 로 설정되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="71c851f5c2d819a86267b67c443581d3b3d61a3e" translate="yes" xml:space="preserve">
          <source>When it comes to texture support, the QParameter value should be set to the appropriate &lt;a href=&quot;qt3drender-qabstracttexture&quot;&gt;QAbstractTexture&lt;/a&gt; subclass that matches the sampler type of the shader uniform.</source>
          <target state="translated">텍스처 지원과 관련하여 QParameter 값은 셰이더 유니폼의 샘플러 유형과 일치하는 적절한 &lt;a href=&quot;qt3drender-qabstracttexture&quot;&gt;QAbstractTexture&lt;/a&gt; 하위 클래스 로 설정되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="ac390c6893275dbab12f259c5a78a8285bc68bc5" translate="yes" xml:space="preserve">
          <source>When it does not call &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt;, Shape interacts with &lt;a href=&quot;qframe#Shadow-enum&quot;&gt;QFrame::Shadow&lt;/a&gt;, the &lt;a href=&quot;qframe#lineWidth-prop&quot;&gt;lineWidth&lt;/a&gt;() and the &lt;a href=&quot;qframe#midLineWidth-prop&quot;&gt;midLineWidth&lt;/a&gt;() to create the total result. See the picture of the frames in the main class documentation.</source>
          <target state="translated">&lt;a href=&quot;qstyle&quot;&gt;QStyle을&lt;/a&gt; 호출하지 않으면 Shape는 &lt;a href=&quot;qframe#Shadow-enum&quot;&gt;QFrame :: Shadow&lt;/a&gt; , &lt;a href=&quot;qframe#lineWidth-prop&quot;&gt;lineWidth&lt;/a&gt; () 및 &lt;a href=&quot;qframe#midLineWidth-prop&quot;&gt;midLineWidth&lt;/a&gt; () 와 상호 작용 하여 총 결과를 만듭니다. 메인 클래스 문서의 프레임 그림을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4261303376e29e827bb3d9ad715c1736160cb00b" translate="yes" xml:space="preserve">
          <source>When it is necessary to reimplement the &lt;a href=&quot;qaccessibleinterface#child&quot;&gt;QAccessibleInterface::child&lt;/a&gt;() function and returning the child after constructing it, this function needs to be called.</source>
          <target state="translated">&lt;a href=&quot;qaccessibleinterface#child&quot;&gt;QAccessibleInterface :: child&lt;/a&gt; () 함수 를 다시 구현하고 생성 후 자식을 리턴해야하는 경우이 함수를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="638905df9b46e03441949d29b36f66dcb7394603" translate="yes" xml:space="preserve">
          <source>When items of data are exported from a model in a drag and drop operation, they are encoded into an appropriate format corresponding to one or more MIME types. Models declare the MIME types that they can use to supply items by reimplementing the &lt;a href=&quot;qabstractitemmodel#mimeTypes&quot;&gt;QAbstractItemModel::mimeTypes&lt;/a&gt;() function, returning a list of standard MIME types.</source>
          <target state="translated">끌어서 놓기 조작으로 모델에서 데이터 항목을 내 보내면 하나 이상의 MIME 유형에 해당하는 적절한 형식으로 인코딩됩니다. 모델은 &lt;a href=&quot;qabstractitemmodel#mimeTypes&quot;&gt;QAbstractItemModel :: mimeTypes&lt;/a&gt; () 함수 를 다시 구현하여 표준 MIME 유형 목록을 반환하여 항목을 제공하는 데 사용할 수있는 MIME 유형을 선언합니다 .</target>
        </trans-unit>
        <trans-unit id="3d596a81dc328e917e2efe8c14460f7b21b5e36e" translate="yes" xml:space="preserve">
          <source>When iterating from 0 and up, it will return the items in the visual arranged order.</source>
          <target state="translated">0 이상에서 반복하면 항목이 시각적으로 정렬 된 순서로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="f808486c7714b611743ef8e1139711cba9bfa51a" translate="yes" xml:space="preserve">
          <source>When iterating over a &lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt;, the items are arbitrarily ordered. With &lt;a href=&quot;qmap&quot;&gt;QMap&lt;/a&gt;, the items are always sorted by key.</source>
          <target state="translated">&lt;a href=&quot;qhash#qhash&quot;&gt;QHash를&lt;/a&gt; 반복 하면 항목이 임의로 주문됩니다. 로 &lt;a href=&quot;qmap&quot;&gt;QMap&lt;/a&gt; , 항목은 항상 핵심으로 분류되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c6bd39523d6a042b14b93d88385549366872e15" translate="yes" xml:space="preserve">
          <source>When iterating over a &lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt;, the items are arbitrarily ordered. With QMap, the items are always sorted by key.</source>
          <target state="translated">&lt;a href=&quot;qhash#qhash&quot;&gt;QHash를&lt;/a&gt; 반복 할 때 항목은 임의로 정렬됩니다. QMap을 사용하면 항목이 항상 키별로 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="c8708ebbe834470a66afd3e678569b47f4a25996" translate="yes" xml:space="preserve">
          <source>When iterating over a &lt;a href=&quot;qmap&quot;&gt;QMap&lt;/a&gt;, the items are always sorted by key. With &lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt;, the items are arbitrarily ordered.</source>
          <target state="translated">&lt;a href=&quot;qmap&quot;&gt;QMap을&lt;/a&gt; 반복 할 때 항목은 항상 키별로 정렬됩니다. 로 &lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt; , 항목 임의로 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="908bbde912a8e2a5301227f6ea15bedbeee803e0" translate="yes" xml:space="preserve">
          <source>When iterating over a &lt;a href=&quot;qmap&quot;&gt;QMap&lt;/a&gt;, the items are always sorted by key. With QHash, the items are arbitrarily ordered.</source>
          <target state="translated">&lt;a href=&quot;qmap&quot;&gt;QMap을&lt;/a&gt; 반복 할 때 항목은 항상 키별로 정렬됩니다. QHash를 사용하면 항목이 임의로 주문됩니다.</target>
        </trans-unit>
        <trans-unit id="9a98982cb360d3887455667bec14b4371ac7fe09" translate="yes" xml:space="preserve">
          <source>When kerning is enabled, glyph metrics do not add up anymore, even for Latin text. In other words, the assumption that width('a') + width('b') is equal to width(&quot;ab&quot;) is not neccesairly true.</source>
          <target state="translated">커닝이 활성화되면 라틴 텍스트의 경우에도 글리프 메트릭이 더 이상 추가되지 않습니다. 즉, width ( 'a') + width ( 'b')가 width ( &quot;ab&quot;)와 같다는 가정은 절대적으로 사실이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="c7c90cd5b86c3de4a86dbc5bca9301f0623600e2" translate="yes" xml:space="preserve">
          <source>When kerning is enabled, glyph metrics do not add up anymore, even for Latin text. In other words, the assumption that width('a') + width('b') is equal to width(&quot;ab&quot;) is not necessarily true.</source>
          <target state="translated">커닝이 활성화되면 라틴 텍스트의 경우에도 글리프 메트릭이 더 이상 추가되지 않습니다. 다시 말해, width ( 'a') + width ( 'b')가 width ( &quot;ab&quot;)와 같다는 가정이 반드시 참인 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="1a521e51c1250eb56a9a96122f4249b5a5690e59" translate="yes" xml:space="preserve">
          <source>When keyboard tracking is disabled, changes are only signalled when focus leaves the text field after edits have modified the content. This allows the user to edit via an invalid date-time to reach a valid one.</source>
          <target state="translated">키보드 추적이 비활성화되면 편집 내용이 내용을 수정 한 후 포커스가 텍스트 필드를 벗어날 때만 변경 사항이 표시됩니다. 이를 통해 사용자는 유효하지 않은 날짜-시간을 통해 편집하여 유효한 날짜에 도달 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4935f0a00031f4e75a93ae9dcce7afc6159f9c52" translate="yes" xml:space="preserve">
          <source>When leaving &quot;What's This?&quot; mode, a &lt;a href=&quot;qevent&quot;&gt;QEvent&lt;/a&gt; of type Qt::LeaveWhatsThisMode is sent to all toplevel widgets.</source>
          <target state="translated">&quot;무엇입니까?&quot;를 떠날 때 모드는하는 &lt;a href=&quot;qevent&quot;&gt;QEvent&lt;/a&gt; 유형 Qt는 :: LeaveWhatsThisMode의 모든 최상위 위젯으로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="68c47022708d018c6f6b21000a13611ed6e90869" translate="yes" xml:space="preserve">
          <source>When linking a library, qmake relies on the underlying platform to know what other libraries this library links against. However, if linking statically, qmake will not get this information unless we use the following &lt;code&gt;CONFIG&lt;/code&gt; options:</source>
          <target state="translated">라이브러리를 링크 할 때 qmake는 기본 플랫폼을 사용하여이 라이브러리가 링크하는 다른 라이브러리를 확인합니다. 그러나 정적으로 링크하는 경우 qmake는 다음 &lt;code&gt;CONFIG&lt;/code&gt; 옵션을 사용하지 않으면이 정보를 얻지 못합니다 .</target>
        </trans-unit>
        <trans-unit id="a540dbd6e20238800d7ddd333a082e8843bed862" translate="yes" xml:space="preserve">
          <source>When listening for connections, the address and port on which the server is listening are available as &lt;a href=&quot;qtcpserver#serverAddress&quot;&gt;serverAddress&lt;/a&gt;() and &lt;a href=&quot;qtcpserver#serverPort&quot;&gt;serverPort&lt;/a&gt;().</source>
          <target state="translated">연결을 청취 할 때 서버가 청취하는 주소 및 포트는 &lt;a href=&quot;qtcpserver#serverAddress&quot;&gt;serverAddress&lt;/a&gt; () 및 &lt;a href=&quot;qtcpserver#serverPort&quot;&gt;serverPort&lt;/a&gt; ()로 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="e0c7db0652d32fbb04e043b9bb98640d9fdf9268" translate="yes" xml:space="preserve">
          <source>When listening for connections, the address and port on which the server is listening are available as &lt;a href=&quot;qwebsocketserver#serverAddress&quot;&gt;serverAddress&lt;/a&gt;() and &lt;a href=&quot;qwebsocketserver#serverPort&quot;&gt;serverPort&lt;/a&gt;().</source>
          <target state="translated">연결을 청취 할 때 서버가 청취하는 주소 및 포트는 &lt;a href=&quot;qwebsocketserver#serverAddress&quot;&gt;serverAddress&lt;/a&gt; () 및 &lt;a href=&quot;qwebsocketserver#serverPort&quot;&gt;serverPort&lt;/a&gt; ()로 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="31ca6375539521ce018e40aba55ef1cfd8ac0a7b" translate="yes" xml:space="preserve">
          <source>When listening for connections, the name which the server is listening on is available through &lt;a href=&quot;qlocalserver#serverName&quot;&gt;serverName&lt;/a&gt;().</source>
          <target state="translated">연결을 청취 할 때 서버가 청취중인 이름은 &lt;a href=&quot;qlocalserver#serverName&quot;&gt;serverName&lt;/a&gt; ()을 통해 사용 가능합니다 .</target>
        </trans-unit>
        <trans-unit id="f562b333fc7588768d7b731fad5e57e2bf351983" translate="yes" xml:space="preserve">
          <source>When loading a QML object into a C++ application, it can be useful to directly embed some C++ data that can be used from within the QML code. This makes it possible, for example, to invoke a C++ method on the embedded object, or use a C++ object instance as a data model for a QML view.</source>
          <target state="translated">QML 오브젝트를 C ++ 애플리케이션으로로드 할 때 QML 코드 내에서 사용할 수있는 일부 C ++ 데이터를 직접 임베드하는 것이 유용 할 수 있습니다. 예를 들어 임베디드 오브젝트에서 C ++ 메소드를 호출하거나 C ++ 오브젝트 인스턴스를 QML보기의 데이터 모델로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5937553b7180f604506425e217e2f3d3eb8c1b4d" translate="yes" xml:space="preserve">
          <source>When loading the library, &lt;a href=&quot;qlibrary&quot;&gt;QLibrary&lt;/a&gt; searches in all system-specific library locations (for example, &lt;code&gt;LD_LIBRARY_PATH&lt;/code&gt; on Unix), unless the file name has an absolute path. After loading the library successfully, fileName() returns the fully-qualified file name of the library, including the full path to the library if one was given in the constructor or passed to setFileName().</source>
          <target state="translated">라이브러리를로드 할 때 &lt;a href=&quot;qlibrary&quot;&gt;QLibrary&lt;/a&gt; 는 파일 이름에 절대 경로가 없으면 모든 시스템 별 라이브러리 위치 (예 : Unix의 &lt;code&gt;LD_LIBRARY_PATH&lt;/code&gt; )를 검색합니다. 라이브러리를 성공적으로로드 한 후, fileName ()은 라이브러리에 대한 전체 경로를 포함하여 라이브러리에 대한 완전한 파일 이름을 포함하여 라이브러리의 완전한 파일 이름을 리턴합니다 (파일이 setFileName ()에 전달 된 경우).</target>
        </trans-unit>
        <trans-unit id="90725888073e38b3afa3349da5a1b31dfd6e2335" translate="yes" xml:space="preserve">
          <source>When loading the plugin, &lt;a href=&quot;qpluginloader&quot;&gt;QPluginLoader&lt;/a&gt; searches in all plugin locations specified by &lt;a href=&quot;qcoreapplication#libraryPaths&quot;&gt;QCoreApplication::libraryPaths&lt;/a&gt;(), unless the file name has an absolute path. After loading the plugin successfully, fileName() returns the fully-qualified file name of the plugin, including the full path to the plugin if one was given in the constructor or passed to setFileName().</source>
          <target state="translated">플러그인을로드 할 때 &lt;a href=&quot;qpluginloader&quot;&gt;QPluginLoader&lt;/a&gt; 는 파일 이름에 절대 경로가없는 경우 &lt;a href=&quot;qcoreapplication#libraryPaths&quot;&gt;QCoreApplication :: libraryPaths&lt;/a&gt; ()에 지정된 모든 플러그인 위치에서 검색 합니다. 플러그인을 성공적으로로드 한 후 fileName ()은 플러그인이 생성자에 주어 졌거나 setFileName ()에 전달 된 경우 플러그인의 전체 경로를 포함하여 플러그인의 정규화 된 파일 이름을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="07f1533b7f9a425f6f190f84dd677e6063996b77" translate="yes" xml:space="preserve">
          <source>When loading the plugin, &lt;a href=&quot;qpluginloader&quot;&gt;QPluginLoader&lt;/a&gt; searches in the current directory and in all plugin locations specified by &lt;a href=&quot;qcoreapplication#libraryPaths&quot;&gt;QCoreApplication::libraryPaths&lt;/a&gt;(), unless the file name has an absolute path. After loading the plugin successfully, fileName() returns the fully-qualified file name of the plugin, including the full path to the plugin if one was given in the constructor or passed to setFileName().</source>
          <target state="translated">플러그인을로드 할 때 &lt;a href=&quot;qpluginloader&quot;&gt;QPluginLoader&lt;/a&gt; 는 파일 이름에 절대 경로가 없으면 현재 디렉토리 및 &lt;a href=&quot;qcoreapplication#libraryPaths&quot;&gt;QCoreApplication :: libraryPaths&lt;/a&gt; ()로 지정된 모든 플러그인 위치에서 검색 합니다. 플러그인을 성공적으로로드 한 후 fileName ()은 플러그인에 대한 완전한 경로를 포함하여 플러그인의 완전한 파일 이름을 포함하여 플러그인의 완전한 파일 이름을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="fed00e705cb06cd3fa7ef9acd6a2a5b4614acebf" translate="yes" xml:space="preserve">
          <source>When making OpenGL function calls, it is strongly recommended to avoid calling the functions directly. Instead, prefer using &lt;a href=&quot;https://doc.qt.io/qt-5.13/qopenglfunctions.html&quot;&gt;QOpenGLFunctions&lt;/a&gt; (when making portable applications) or the versioned variants (for example, &lt;a href=&quot;https://doc.qt.io/qt-5.13/qopenglfunctions-3-2-core.html&quot;&gt;QOpenGLFunctions_3_2_Core&lt;/a&gt; and similar, when targeting modern, desktop-only OpenGL). This way the application will work correctly in all Qt build configurations, including the ones that perform dynamic OpenGL implementation loading which means applications are not directly linking to an GL implementation and thus direct function calls are not feasible.</source>
          <target state="translated">OpenGL 함수 호출을 수행 할 때는 함수를 직접 호출하지 않는 것이 좋습니다. 대신, &lt;a href=&quot;https://doc.qt.io/qt-5.13/qopenglfunctions.html&quot;&gt;QOpenGLFunctions&lt;/a&gt; (휴대용 응용 프로그램을 작성할 때) 또는 버전 변형 (예 : 최신 데스크탑 전용 OpenGL을 대상으로하는 경우 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qopenglfunctions-3-2-core.html&quot;&gt;QOpenGLFunctions_3_2_Core&lt;/a&gt; 등)을 사용하십시오. 이런 식으로 응용 프로그램은 동적 OpenGL 구현 로딩을 수행하는 구성을 포함하여 모든 Qt 빌드 구성에서 올바르게 작동합니다. 즉, 응용 프로그램이 GL 구현에 직접 연결되어 있지 않으므로 직접 함수 호출을 수행 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f276cbbad1d8799cadf78ef781192531dc7ead31" translate="yes" xml:space="preserve">
          <source>When making OpenGL function calls, it is strongly recommended to avoid calling the functions directly. Instead, prefer using &lt;a href=&quot;https://doc.qt.io/qt-5.15/qopenglfunctions.html&quot;&gt;QOpenGLFunctions&lt;/a&gt; (when making portable applications) or the versioned variants (for example, &lt;a href=&quot;https://doc.qt.io/qt-5.15/qopenglfunctions-3-2-core.html&quot;&gt;QOpenGLFunctions_3_2_Core&lt;/a&gt; and similar, when targeting modern, desktop-only OpenGL). This way the application will work correctly in all Qt build configurations, including the ones that perform dynamic OpenGL implementation loading which means applications are not directly linking to an GL implementation and thus direct function calls are not feasible.</source>
          <target state="translated">OpenGL 함수를 호출 할 때 함수를 직접 호출하지 않는 것이 좋습니다. 대신 &lt;a href=&quot;https://doc.qt.io/qt-5.15/qopenglfunctions.html&quot;&gt;QOpenGLFunctions&lt;/a&gt; (이동형 애플리케이션을 만들 때) 또는 버전이 지정된 변형 (예 : 최신 데스크톱 전용 OpenGL을 대상으로하는 경우 &lt;a href=&quot;https://doc.qt.io/qt-5.15/qopenglfunctions-3-2-core.html&quot;&gt;QOpenGLFunctions_3_2_Core&lt;/a&gt; 등)을 사용하는 것이 좋습니다. 이렇게하면 응용 프로그램이 동적 OpenGL 구현로드를 수행하는 구성을 포함하여 모든 Qt 빌드 구성에서 올바르게 작동합니다. 즉, 응용 프로그램이 GL 구현에 직접 연결되지 않으므로 직접 함수 호출이 가능하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d7812b8e5267196ba2ad8e65b065aaa80e3d29f0" translate="yes" xml:space="preserve">
          <source>When making a context current using &lt;a href=&quot;qopenglcontext&quot;&gt;QOpenGLContext&lt;/a&gt;, do not check that the &lt;a href=&quot;qobject#thread-affinity&quot;&gt;QObject thread affinity&lt;/a&gt; of the &lt;a href=&quot;qopenglcontext&quot;&gt;QOpenGLContext&lt;/a&gt; object is the same thread calling &lt;a href=&quot;qopenglcontext#makeCurrent&quot;&gt;makeCurrent()&lt;/a&gt;. This value was added in Qt 5.8.</source>
          <target state="translated">&lt;a href=&quot;qopenglcontext&quot;&gt;QOpenGLContext를&lt;/a&gt; 사용하여 컨텍스트를 현재로 만들 때 &lt;a href=&quot;qopenglcontext&quot;&gt;QOpenGLContext&lt;/a&gt; 객체 의 &lt;a href=&quot;qobject#thread-affinity&quot;&gt;QObject 스레드 선호도&lt;/a&gt; 가 &lt;a href=&quot;qopenglcontext#makeCurrent&quot;&gt;makeCurrent ()를&lt;/a&gt; 호출하는 동일한 스레드 인지 확인하지 마십시오 . 이 값은 Qt 5.8에서 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="3d457ffc5179988c0d911e245311c267b3667157" translate="yes" xml:space="preserve">
          <source>When making the temporary credentials request, the client authenticates using only the client credentials. When making the token request, the client authenticates using the client credentials as well as the temporary credentials. Once the client receives and stores the token credentials, it can proceed to access protected resources on behalf of the resource owner by making authenticated requests using the client credentials together with the token credentials received.</source>
          <target state="translated">임시 자격 증명 요청을 할 때 클라이언트는 클라이언트 자격 증명 만 사용하여 인증합니다. 토큰 요청을 할 때 클라이언트는 클라이언트 자격 증명과 임시 자격 증명을 사용하여 인증합니다. 클라이언트가 토큰 자격 증명을 수신하고 저장하면 클라이언트 자격 증명과 수신 된 토큰 자격 증명을 사용하여 인증 된 요청을 수행하여 리소스 소유자 대신 보호 된 리소스에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="810316d46e7d600660a66af0e59fa7e02d7433b6" translate="yes" xml:space="preserve">
          <source>When managing dynamically created objects, you must ensure the creation context outlives the created object. Otherwise, if the creation context is destroyed first, the bindings and signal handlers in the dynamic object will no longer work.</source>
          <target state="translated">동적으로 생성 된 객체를 관리 할 때는 생성 컨텍스트가 생성 된 객체보다 오래 지속되도록해야합니다. 그렇지 않으면 생성 컨텍스트가 먼저 파괴되면 동적 객체의 바인딩 및 신호 처리기가 더 이상 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b19286d402c202adf58ff1b66a30b97e15b4a785" translate="yes" xml:space="preserve">
          <source>When manipulating selections, it is often helpful to think of &lt;a href=&quot;qitemselectionmodel&quot;&gt;QItemSelectionModel&lt;/a&gt; as a record of the selection state of all the items in an item model. Once a selection model is set up, collections of items can be selected, deselected, or their selection states can be toggled without the need to know which items are already selected. The indexes of all selected items can be retrieved at any time, and other components can be informed of changes to the selection model via the signals and slots mechanism.</source>
          <target state="translated">선택을 조작 할 때 &lt;a href=&quot;qitemselectionmodel&quot;&gt;QItemSelectionModel&lt;/a&gt; 을 항목 모델에있는 모든 항목의 선택 상태 레코드로 생각하면 도움이됩니다 . 선택 모델이 설정되면 어떤 항목이 이미 선택되어 있는지 알 필요없이 항목 모음을 선택하거나 선택 해제하거나 선택 상태를 전환 할 수 있습니다. 선택한 모든 항목의 색인을 언제든지 검색 할 수 있으며 신호 및 슬롯 메커니즘을 통해 다른 구성 요소에 선택 모델의 변경 사항을 알릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4fe612b6914bd28d3a91c181ce17418b66edda3f" translate="yes" xml:space="preserve">
          <source>When mirroring the layout using either the attached property &lt;a href=&quot;qml-qtquick-layoutmirroring#enabled-prop&quot;&gt;LayoutMirroring::enabled&lt;/a&gt; or by setting the &lt;a href=&quot;qml-qtquick-grid#layoutDirection-prop&quot;&gt;layoutDirection&lt;/a&gt;, the horizontal alignment of items will be mirrored as well. However, the property &lt;code&gt;horizontalItemAlignment&lt;/code&gt; will remain unchanged. To query the effective horizontal alignment of items, use the read-only property &lt;code&gt;effectiveHorizontalItemAlignment&lt;/code&gt;.</source>
          <target state="translated">연결된 속성 &lt;a href=&quot;qml-qtquick-layoutmirroring#enabled-prop&quot;&gt;LayoutMirroring :: enabled를 사용&lt;/a&gt; 하거나 &lt;a href=&quot;qml-qtquick-grid#layoutDirection-prop&quot;&gt;layoutDirection&lt;/a&gt; 을 설정 하여 레이아웃을 미러링 할 때 항목의 가로 정렬도 미러링됩니다. 그러나 &lt;code&gt;horizontalItemAlignment&lt;/code&gt; 속성 은 변경되지 않습니다. 항목의 효과적인 가로 정렬을 쿼리하려면 읽기 전용 속성 인 &lt;code&gt;effectiveHorizontalItemAlignment&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="e9debebd9aa12f2d598528bbeb0d545c66987f90" translate="yes" xml:space="preserve">
          <source>When mixing raw graphics (OpenGL, Vulkan, Metal, etc.) commands with scene graph rendering, it is necessary to call this function after recording commands to the command buffer used by the scene graph to render its main render pass. This is to avoid clobbering state.</source>
          <target state="translated">원시 그래픽 (OpenGL, Vulkan, Metal 등) 명령을 장면 그래프 렌더링과 혼합 할 때, 주 렌더링 패스를 렌더링하기 위해 장면 그래프에서 사용하는 명령 버퍼에 명령을 기록한 후이 함수를 호출해야합니다. 이것은 막힘 상태를 피하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="48e30ffa6a01f7853331128d4cf7b56aeea01dcd" translate="yes" xml:space="preserve">
          <source>When mixing raw graphics (OpenGL, Vulkan, Metal, etc.) commands with scene graph rendering, it is necessary to call this function before recording commands to the command buffer used by the scene graph to render its main render pass. This is to avoid clobbering state.</source>
          <target state="translated">원시 그래픽 (OpenGL, Vulkan, Metal 등) 명령을 장면 그래프 렌더링과 혼합 할 때, 주 렌더링 패스를 렌더링하기 위해 장면 그래프에서 사용하는 명령 버퍼에 명령을 기록하기 전에이 함수를 호출해야합니다. 이것은 막힘 상태를 피하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="98292e6a711c0a97d142c6900df0dd3a1198f215" translate="yes" xml:space="preserve">
          <source>When model is not explicitly set, it will be synchronized with &lt;a href=&quot;qml-qtquick-controls2-verticalheaderview#syncView-prop&quot;&gt;syncView&lt;/a&gt;'s model once &lt;a href=&quot;qml-qtquick-controls2-verticalheaderview#syncView-prop&quot;&gt;syncView&lt;/a&gt; is set.</source>
          <target state="translated">모델이 명시 적으로 설정하지 않은 경우, 그것은으로 동기화됩니다 &lt;a href=&quot;qml-qtquick-controls2-verticalheaderview#syncView-prop&quot;&gt;syncView&lt;/a&gt; 일단의 모델 &lt;a href=&quot;qml-qtquick-controls2-verticalheaderview#syncView-prop&quot;&gt;syncView이&lt;/a&gt; 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="67c4954bd29b0a4fd959263898f6a26791b7a7d0" translate="yes" xml:space="preserve">
          <source>When model is not explicitly set, the header will use the &lt;a href=&quot;qml-qtquick-controls2-horizontalheaderview#syncView-prop&quot;&gt;syncView&lt;/a&gt;'s model once &lt;a href=&quot;qml-qtquick-controls2-horizontalheaderview#syncView-prop&quot;&gt;syncView&lt;/a&gt; is set.</source>
          <target state="translated">모델이 명시 적으로 설정되지 않은 경우 &lt;a href=&quot;qml-qtquick-controls2-horizontalheaderview#syncView-prop&quot;&gt;syncView&lt;/a&gt; 가 설정 되면 헤더는 &lt;a href=&quot;qml-qtquick-controls2-horizontalheaderview#syncView-prop&quot;&gt;syncView&lt;/a&gt; 의 모델을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="b20aa7e6cd799e3bf7fad3e47e4d5468b0303506" translate="yes" xml:space="preserve">
          <source>When multiple QOpenGLWidgets are added as children to the same top-level widget, their contexts will share with each other. This does not apply for &lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt; instances that belong to different windows.</source>
          <target state="translated">여러 개의 QOpenGLWidget이 동일한 최상위 레벨 위젯에 하위로 추가되면 해당 컨텍스트가 서로 공유됩니다. 다른 창에 속하는 &lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt; 인스턴스 에는 적용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="a052e77d465746dc1474a9b2e904f81e2b5f4c64" translate="yes" xml:space="preserve">
          <source>When multiple QOpenGLWidgets are added as children to the same top-level widget, their contexts will share with each other. This does not apply for QOpenGLWidget instances that belong to different windows.</source>
          <target state="translated">여러 QOpenGLWidget이 동일한 최상위 위젯에 자식으로 추가되면 해당 컨텍스트가 서로 공유됩니다. 이것은 다른 창에 속하는 QOpenGLWidget 인스턴스에는 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="be71f48901e09c1cafec1c8d3da6f3f42996e8be" translate="yes" xml:space="preserve">
          <source>When multiple render targets are in use,</source>
          <target state="translated">여러 렌더 타겟이 사용중인 경우</target>
        </trans-unit>
        <trans-unit id="cca7faed1dcf3acb3787eb6ed52f3e078b4e846e" translate="yes" xml:space="preserve">
          <source>When multiple selectors could be applied to the same file, the first matching selector is chosen. The order selectors are checked in are:</source>
          <target state="translated">여러 개의 선택기를 동일한 파일에 적용 할 수 있으면 첫 번째 일치하는 선택기가 선택됩니다. 체크인 된 주문 선택기는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a2d60a792f80124c96dcd07ddb164770dfe0ca59" translate="yes" xml:space="preserve">
          <source>When multiple series are added to a graph, selecting an item in one of them will clear the selection on other series.</source>
          <target state="translated">그래프에 여러 계열이 추가되면 그 중 하나에서 항목을 선택하면 다른 계열의 선택이 지워집니다.</target>
        </trans-unit>
        <trans-unit id="b98c31c0b36eccbc7c80561d52175a75bcc24aef" translate="yes" xml:space="preserve">
          <source>When multiple textures are attached, the return value is the ID of the first one.</source>
          <target state="translated">여러 텍스처가 연결되면 반환 값은 첫 번째 텍스처의 ID입니다.</target>
        </trans-unit>
        <trans-unit id="5ea247c1f56cf273fe99668ba49d31b1b499bfbe" translate="yes" xml:space="preserve">
          <source>When multisample antialiasing is used, content rendered into framebuffer objects need additional extensions to support multisampling of framebuffers. Typically &lt;code&gt;GL_EXT_framebuffer_multisample&lt;/code&gt; and &lt;code&gt;GL_EXT_framebuffer_blit&lt;/code&gt;. Most desktop chips have these extensions present, but they are less common in embedded chips. When framebuffer multisampling is not available in the hardware, content rendered into framebuffer objects will not be antialiased, including the content of a &lt;a href=&quot;qml-qtquick-shadereffectsource&quot;&gt;ShaderEffectSource&lt;/a&gt;.</source>
          <target state="translated">멀티 샘플 앤티 앨리어싱을 사용하는 경우 프레임 버퍼 객체로 렌더링되는 내용에는 프레임 버퍼의 멀티 샘플링을 지원하기 위해 추가 확장이 필요합니다. 일반적으로 &lt;code&gt;GL_EXT_framebuffer_multisample&lt;/code&gt; 및 &lt;code&gt;GL_EXT_framebuffer_blit&lt;/code&gt; 입니다. 대부분의 데스크탑 칩에는 이러한 확장 기능이 있지만 임베디드 칩에서는 일반적이지 않습니다. 하드웨어에서 프레임 버퍼 멀티 샘플링을 사용할 수없는 경우 &lt;a href=&quot;qml-qtquick-shadereffectsource&quot;&gt;ShaderEffectSource&lt;/a&gt; 의 내용을 포함하여 프레임 버퍼 객체로 렌더링 된 내용은 앤티 앨리어싱되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="fccefc8901100b2f82142ca7d8bb3223d24d7501" translate="yes" xml:space="preserve">
          <source>When navigating the document structure, it is useful to begin at the root frame because it provides access to the entire document structure.</source>
          <target state="translated">문서 구조를 탐색 할 때 전체 문서 구조에 대한 액세스를 제공하므로 루트 프레임에서 시작하는 것이 유용합니다.</target>
        </trans-unit>
        <trans-unit id="3e0a254e08acf9d6be4fd4d7a634988147b26055" translate="yes" xml:space="preserve">
          <source>When nested opacity gets below a certain threshold, the subtree might be marked as blocked, causing &lt;a href=&quot;qsgnode#isSubtreeBlocked&quot;&gt;isSubtreeBlocked&lt;/a&gt;() to return true. This is done for performance reasons.</source>
          <target state="translated">중첩 된 불투명도가 특정 임계 값 아래로 떨어지면 하위 트리가 차단 된 것으로 표시되어 &lt;a href=&quot;qsgnode#isSubtreeBlocked&quot;&gt;isSubtreeBlocked&lt;/a&gt; ()가 true를 반환 할 수 있습니다. 이것은 성능상의 이유로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="4d85ccf2069fc6eae18e11975d88bfe1fadc019f" translate="yes" xml:space="preserve">
          <source>When no windowing system is present, the mouse, keyboard and touch input are read directly via &lt;code&gt;evdev&lt;/code&gt;. Note that this requires that devices nodes &lt;code&gt;/input/event*&lt;/code&gt; are readable by the user. eglfs and vxworksfb has all the evdev input handling code built-in.</source>
          <target state="translated">윈도우 시스템이 없으면 마우스, 키보드 및 터치 입력을 &lt;code&gt;evdev&lt;/code&gt; 를 통해 직접 읽습니다 . 이를 위해서는 사용자가 장치 노드 &lt;code&gt;/input/event*&lt;/code&gt; 를 읽을 수 있어야합니다. eglfs 및 vxworksfb에는 모든 evdev 입력 처리 코드가 내장되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b0f164920aba9354f027a11efdb935f7ff22e14" translate="yes" xml:space="preserve">
          <source>When no windowing system is present, the mouse, keyboard, and touch input are read directly via &lt;code&gt;evdev&lt;/code&gt; or using helper libraries such as &lt;code&gt;libinput&lt;/code&gt; or &lt;code&gt;tslib&lt;/code&gt;. Note that this requires that device nodes &lt;code&gt;/dev/input/event*&lt;/code&gt; are readable by the user. &lt;code&gt;eglfs&lt;/code&gt; and &lt;code&gt;linuxfb&lt;/code&gt; have all the input handling code compiled-in.</source>
          <target state="translated">윈도우 시스템이 없으면 마우스, 키보드 및 터치 입력을 &lt;code&gt;evdev&lt;/code&gt; 를 통해 또는 &lt;code&gt;libinput&lt;/code&gt; 또는 &lt;code&gt;tslib&lt;/code&gt; 와 같은 도우미 라이브러리를 사용하여 직접 읽습니다 . 이를 위해서는 사용자가 장치 노드 &lt;code&gt;/dev/input/event*&lt;/code&gt; 를 읽을 수 있어야합니다. &lt;code&gt;eglfs&lt;/code&gt; 와 &lt;code&gt;linuxfb&lt;/code&gt; 에는 모든 입력 처리 코드가 컴파일되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="18d39e71149ec53d71da5bdfa496288bb4064e73" translate="yes" xml:space="preserve">
          <source>When not running with the RHI (and using OpenGL directly), the signal is emitted after the renderer has cleared the render target. This makes it possible to create applications that function identically both with and without the RHI.</source>
          <target state="translated">RHI로 실행하지 않고 OpenGL을 직접 사용하는 경우 렌더러가 렌더 대상을 지운 ​​후에 신호가 방출됩니다. 이를 통해 RHI 유무에 관계없이 동일하게 작동하는 응용 프로그램을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a0721c385a99233431f8667a3ee0ae4fedf149b4" translate="yes" xml:space="preserve">
          <source>When not running with the RHI (and using OpenGL directly), the signal is emitted after the renderer has finished its rendering, but before &lt;a href=&quot;qquickwindow#afterRendering&quot;&gt;afterRendering&lt;/a&gt;(). This makes it possible to create applications that function identically both with and without the RHI.</source>
          <target state="translated">RHI로 실행하지 않고 OpenGL을 직접 사용하는 경우 렌더러가 렌더링을 완료 한 후 &lt;a href=&quot;qquickwindow#afterRendering&quot;&gt;afterRendering&lt;/a&gt; () 전에 신호가 방출 됩니다. 이를 통해 RHI 유무에 관계없이 동일하게 작동하는 응용 프로그램을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dca5d911ae2265eef32ee4fee8077e25696a9db8" translate="yes" xml:space="preserve">
          <source>When one of the statements is a non-select statement a count of affected rows may be available instead of a result set.</source>
          <target state="translated">명령문 중 하나가 비 선택 명령문 인 경우 결과 세트 대신 영향을받는 행 수를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e9136aaa0ef09df9e9f07e3241b2a9f838fd494d" translate="yes" xml:space="preserve">
          <source>When operating in deterministic mode, &lt;a href=&quot;qrandomgenerator&quot;&gt;QRandomGenerator&lt;/a&gt; may be used for bulk data generation. In fact, applications that do not need cryptographically-secure or true random data are advised to use a regular &lt;a href=&quot;qrandomgenerator&quot;&gt;QRandomGenerator&lt;/a&gt; instead of &lt;a href=&quot;qrandomgenerator#system&quot;&gt;QRandomGenerator::system&lt;/a&gt;() for their random data needs.</source>
          <target state="translated">결정적 모드에서 작동하는 경우 &lt;a href=&quot;qrandomgenerator&quot;&gt;QRandomGenerator&lt;/a&gt; 를 대량 데이터 생성에 사용할 수 있습니다. 실제로 암호화 보안 또는 실제 임의 데이터가 필요없는 애플리케이션은 임의 데이터 요구 에 &lt;a href=&quot;qrandomgenerator#system&quot;&gt;QRandomGenerator :: system&lt;/a&gt; () 대신 일반 &lt;a href=&quot;qrandomgenerator&quot;&gt;QRandomGenerator&lt;/a&gt; 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="601025c900ae42d4debb597407723c06012bd462" translate="yes" xml:space="preserve">
          <source>When operating in deterministic mode, QRandomGenerator may be used for bulk data generation. In fact, applications that do not need cryptographically-secure or true random data are advised to use a regular QRandomGenerator instead of &lt;a href=&quot;qrandomgenerator#system&quot;&gt;QRandomGenerator::system&lt;/a&gt;() for their random data needs.</source>
          <target state="translated">결정 론적 모드에서 작동 할 때 QRandomGenerator를 대량 데이터 생성에 사용할 수 있습니다. 실제로 암호화 보안 또는 실제 임의 데이터가 필요하지 않은 응용 프로그램은 임의 데이터 요구에 대해 &lt;a href=&quot;qrandomgenerator#system&quot;&gt;QRandomGenerator :: system&lt;/a&gt; () 대신 일반 QRandomGenerator를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="ca0c853a6a3df272210d1c9d0c36c813572cdfe7" translate="yes" xml:space="preserve">
          <source>When operating on managed objects in normal C++ code, a little extra care must be taken because of the CLR's garbage collection. A normal pointer variable should not</source>
          <target state="translated">일반 C ++ 코드로 관리 객체에서 작업 할 때는 CLR의 가비지 수집 때문에 약간의주의가 필요합니다. 일반적인 포인터 변수는</target>
        </trans-unit>
        <trans-unit id="ea7e897063825784978303959c1455b5d44412c2" translate="yes" xml:space="preserve">
          <source>When options can be grouped, you can use a partially checked &lt;a href=&quot;qml-qtquick-controls2-checkbox&quot;&gt;CheckBox&lt;/a&gt; to represent the whole group. Use the checkbox's &lt;a href=&quot;qml-qtquick-controls2-checkbox#checkState-prop&quot;&gt;partially checked state&lt;/a&gt; when a user selects some, but not all, sub-items in the group.</source>
          <target state="translated">옵션을 그룹화 할 수 있으면 부분적으로 선택된 &lt;a href=&quot;qml-qtquick-controls2-checkbox&quot;&gt;CheckBox&lt;/a&gt; 를 사용 하여 전체 그룹을 나타낼 수 있습니다 . 사용자가 그룹의 일부 하위 항목을 선택 하면 확인란의 &lt;a href=&quot;qml-qtquick-controls2-checkbox#checkState-prop&quot;&gt;부분적으로 선택된 상태를&lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="fe4c38cfe45b7ff5d5ad3092c911b19539b422d2" translate="yes" xml:space="preserve">
          <source>When painting to a &lt;a href=&quot;qopenglpaintdevice&quot;&gt;QOpenGLPaintDevice&lt;/a&gt; using &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt;, the state of the current OpenGL context will be altered by the paint engine to reflect its needs. Applications should not rely upon the OpenGL state being reset to its original conditions, particularly the current shader program, OpenGL viewport, texture units, and drawing modes.</source>
          <target state="translated">&lt;a href=&quot;qpainter&quot;&gt;QPainter를&lt;/a&gt; 사용하여 &lt;a href=&quot;qopenglpaintdevice&quot;&gt;QOpenGLPaintDevice에&lt;/a&gt; 페인트 할 때 페인트 엔진에 의해 현재 OpenGL 컨텍스트의 상태가 변경되어 요구를 반영합니다. 응용 프로그램은 OpenGL 상태가 원래 조건, 특히 현재 셰이더 프로그램, OpenGL 뷰포트, 텍스처 단위 및 드로잉 모드로 재설정되는 것에 의존해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="76720392a96856f8c1e5f2c5c0b848262c8e8089" translate="yes" xml:space="preserve">
          <source>When painting to a QOpenGLPaintDevice using &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt;, the state of the current OpenGL context will be altered by the paint engine to reflect its needs. Applications should not rely upon the OpenGL state being reset to its original conditions, particularly the current shader program, OpenGL viewport, texture units, and drawing modes.</source>
          <target state="translated">&lt;a href=&quot;qpainter&quot;&gt;QPainter를&lt;/a&gt; 사용하여 QOpenGLPaintDevice에 페인팅 할 때 현재 OpenGL 컨텍스트의 상태는 필요를 반영하기 위해 페인트 엔진에 의해 변경됩니다. 응용 프로그램은 OpenGL 상태, 특히 현재 셰이더 프로그램, OpenGL 뷰포트, 텍스처 단위 및 그리기 모드로 재설정되는 OpenGL 상태에 의존해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="8e4b844ee7e4c5be1b0dab1bbe7aaa712b977db0" translate="yes" xml:space="preserve">
          <source>When paused, the current frame can be advanced manually by setting this property or calling &lt;a href=&quot;qml-qtquick-animatedsprite#advance-method&quot;&gt;advance()&lt;/a&gt;.</source>
          <target state="translated">일시 중지되면이 속성을 설정하거나 &lt;a href=&quot;qml-qtquick-animatedsprite#advance-method&quot;&gt;advance ()를&lt;/a&gt; 호출하여 현재 프레임을 수동으로 진행시킬 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="36bc00e334ac8aa1eea3755d12934f7608da4dea" translate="yes" xml:space="preserve">
          <source>When paused, the current frame can be advanced manually.</source>
          <target state="translated">일시 정지하면 현재 프레임을 수동으로 진행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="40753593df1bbb77361dbb8a61ae51ec564eb417" translate="yes" xml:space="preserve">
          <source>When performing a lookup on a service, zero or more records will be returned. Each record is represented by a &lt;a href=&quot;qdnsmailexchangerecord&quot;&gt;QDnsMailExchangeRecord&lt;/a&gt; instance.</source>
          <target state="translated">서비스에서 조회를 수행 할 때 0 개 이상의 레코드가 리턴됩니다. 각 레코드는 &lt;a href=&quot;qdnsmailexchangerecord&quot;&gt;QDnsMailExchangeRecord&lt;/a&gt; 인스턴스로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="745159504ea8964595662dfda6ea6803520cab14" translate="yes" xml:space="preserve">
          <source>When performing a lookup on a service, zero or more records will be returned. Each record is represented by a &lt;a href=&quot;qdnsservicerecord&quot;&gt;QDnsServiceRecord&lt;/a&gt; instance.</source>
          <target state="translated">서비스에서 조회를 수행 할 때 0 개 이상의 레코드가 리턴됩니다. 각 레코드는 &lt;a href=&quot;qdnsservicerecord&quot;&gt;QDnsServiceRecord&lt;/a&gt; 인스턴스로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="6d6001a94eae9d4e4679d672b10ebf1476ba4b97" translate="yes" xml:space="preserve">
          <source>When performing a lookup on a service, zero or more records will be returned. Each record is represented by a QDnsMailExchangeRecord instance.</source>
          <target state="translated">서비스에 대한 조회를 수행 할 때 0 개 이상의 레코드가 반환됩니다. 각 레코드는 QDnsMailExchangeRecord 인스턴스로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="183c9e6bf9945fe2d7c4f1ece374cc4634d591ca" translate="yes" xml:space="preserve">
          <source>When performing a lookup on a service, zero or more records will be returned. Each record is represented by a QDnsServiceRecord instance.</source>
          <target state="translated">서비스에 대한 조회를 수행 할 때 0 개 이상의 레코드가 반환됩니다. 각 레코드는 QDnsServiceRecord 인스턴스로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="89b6dd291204471e81a34c81e897e2eae987238a" translate="yes" xml:space="preserve">
          <source>When performing a name server lookup, zero or more records will be returned. Each record is represented by a &lt;a href=&quot;qdnsdomainnamerecord&quot;&gt;QDnsDomainNameRecord&lt;/a&gt; instance.</source>
          <target state="translated">이름 서버 조회를 수행 할 때 0 개 이상의 레코드가 리턴됩니다. 각 레코드는 &lt;a href=&quot;qdnsdomainnamerecord&quot;&gt;QDnsDomainNameRecord&lt;/a&gt; 인스턴스로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="d31385d56b863dd8dbd104e645dc9977d21a36cc" translate="yes" xml:space="preserve">
          <source>When performing a name server lookup, zero or more records will be returned. Each record is represented by a QDnsDomainNameRecord instance.</source>
          <target state="translated">이름 서버 조회를 수행 할 때 0 개 이상의 레코드가 반환됩니다. 각 레코드는 QDnsDomainNameRecord 인스턴스로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="3612e920959430b2f4633a7ed7ecb7c74231f462" translate="yes" xml:space="preserve">
          <source>When performing a text lookup, zero or more records will be returned. Each record is represented by a &lt;a href=&quot;qdnstextrecord&quot;&gt;QDnsTextRecord&lt;/a&gt; instance.</source>
          <target state="translated">텍스트 조회를 수행 할 때 0 개 이상의 레코드가 반환됩니다. 각 레코드는 &lt;a href=&quot;qdnstextrecord&quot;&gt;QDnsTextRecord&lt;/a&gt; 인스턴스로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="909f4885c9471951ef724c0551ca405b8644c385" translate="yes" xml:space="preserve">
          <source>When performing a text lookup, zero or more records will be returned. Each record is represented by a QDnsTextRecord instance.</source>
          <target state="translated">텍스트 조회를 수행 할 때 0 개 이상의 레코드가 반환됩니다. 각 레코드는 QDnsTextRecord 인스턴스로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="711a9f71466771c6e4aade7928b9960c7cefd54f" translate="yes" xml:space="preserve">
          <source>When performing an address lookup, zero or more records will be returned. Each record is represented by a &lt;a href=&quot;qdnshostaddressrecord&quot;&gt;QDnsHostAddressRecord&lt;/a&gt; instance.</source>
          <target state="translated">주소 조회를 수행 할 때 0 개 이상의 레코드가 반환됩니다. 각 레코드는 &lt;a href=&quot;qdnshostaddressrecord&quot;&gt;QDnsHostAddressRecord&lt;/a&gt; 인스턴스로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="be3ad2654f5fa7ba6e1f52aec206ab62cc47cc26" translate="yes" xml:space="preserve">
          <source>When performing an address lookup, zero or more records will be returned. Each record is represented by a QDnsHostAddressRecord instance.</source>
          <target state="translated">주소 조회를 수행 할 때 0 개 이상의 레코드가 반환됩니다. 각 레코드는 QDnsHostAddressRecord 인스턴스로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="63db06c50e58a3513cea1497dec1ed7741831f0b" translate="yes" xml:space="preserve">
          <source>When performing drawing using &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; only, it is also possible to perform the painting like it is done for ordinary widgets: by reimplementing &lt;a href=&quot;qopenglwidget#paintEvent&quot;&gt;paintEvent&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; 만 사용하여 그리기를 수행 할 때 &lt;a href=&quot;qopenglwidget#paintEvent&quot;&gt;paintEvent&lt;/a&gt; () 를 다시 구현하여 일반 위젯에서와 같이 페인팅을 수행 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4873852a94448fd952353de01e74e6bb7112405f" translate="yes" xml:space="preserve">
          <source>When performing verification steps in an autotest using &lt;a href=&quot;qtest#QCOMPARE&quot;&gt;QCOMPARE&lt;/a&gt;(), &lt;a href=&quot;qtest#QVERIFY&quot;&gt;QVERIFY&lt;/a&gt;(), and so on, side-effects should be avoided. Side-effects in verification steps can make a test difficult to understand. Also, they can easily break a test in ways that are difficult to diagnose when the test is changed to use &lt;a href=&quot;qtest#QTRY_VERIFY&quot;&gt;QTRY_VERIFY&lt;/a&gt;(), &lt;a href=&quot;qtest#QTRY_COMPARE&quot;&gt;QTRY_COMPARE&lt;/a&gt;() or &lt;a href=&quot;qtest#QBENCHMARK&quot;&gt;QBENCHMARK&lt;/a&gt;(). These can execute the passed expression multiple times, thus repeating any side-effects.</source>
          <target state="translated">&lt;a href=&quot;qtest#QCOMPARE&quot;&gt;QCOMPARE&lt;/a&gt; (), &lt;a href=&quot;qtest#QVERIFY&quot;&gt;QVERIFY&lt;/a&gt; () 등을 사용하여 자동 테스트 에서 검증 단계를 수행 할 때 부작용을 피해야합니다. 검증 단계의 부작용은 테스트를 이해하기 어렵게 만들 수 있습니다. 또한 &lt;a href=&quot;qtest#QTRY_VERIFY&quot;&gt;QTRY_VERIFY&lt;/a&gt; (), &lt;a href=&quot;qtest#QTRY_COMPARE&quot;&gt;QTRY_COMPARE&lt;/a&gt; () 또는 &lt;a href=&quot;qtest#QBENCHMARK&quot;&gt;QBENCHMARK&lt;/a&gt; () 를 사용하도록 테스트를 변경하면 진단하기 어려운 방식으로 테스트를 쉽게 깨뜨릴 수 있습니다 . 이들은 전달 된 표현식을 여러 번 실행하여 부작용을 반복 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="38db5be01962103a3cc7ed36e0dd26d7c49283ec" translate="yes" xml:space="preserve">
          <source>When placed into a &lt;code&gt;.qml&lt;/code&gt; file and loaded by the QML engine, the above code creates a &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt; object using the &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt; type supplied by the &lt;code&gt;QtQuick&lt;/code&gt; module:</source>
          <target state="translated">&lt;code&gt;.qml&lt;/code&gt; 파일에 배치 하고 QML 엔진에 의해로드되면 위 코드 는 &lt;code&gt;QtQuick&lt;/code&gt; 모듈에서 제공 하는 &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt; 유형을 사용하여 &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt; 객체를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="6927c0eac9201c4bf4c31b692534ebe1bbcfa831" translate="yes" xml:space="preserve">
          <source>When populating a layout, the widgets are added to an internal list. The &lt;a href=&quot;qlayout#indexOf&quot;&gt;indexOf&lt;/a&gt;() function returns the index of a widget in that list. The widgets can either be added to the end of the list using the &lt;a href=&quot;qstackedlayout#addWidget&quot;&gt;addWidget&lt;/a&gt;() function, or inserted at a given index using the &lt;a href=&quot;qstackedlayout#insertWidget&quot;&gt;insertWidget&lt;/a&gt;() function. The &lt;a href=&quot;qlayout#removeWidget&quot;&gt;removeWidget&lt;/a&gt;() function removes the widget at the given index from the layout. The number of widgets contained in the layout, can be obtained using the &lt;a href=&quot;qstackedlayout#count-prop&quot;&gt;count&lt;/a&gt;() function.</source>
          <target state="translated">레이아웃을 채울 때 위젯이 내부 목록에 추가됩니다. &lt;a href=&quot;qlayout#indexOf&quot;&gt;같이 IndexOf&lt;/a&gt; () 함수는 목록에서 위젯의 인덱스를 반환합니다. 위젯은 &lt;a href=&quot;qstackedlayout#addWidget&quot;&gt;addWidget&lt;/a&gt; () 함수를 사용하여 목록의 끝에 추가 하거나 &lt;a href=&quot;qstackedlayout#insertWidget&quot;&gt;insertWidget&lt;/a&gt; () 함수를 사용하여 지정된 색인에 삽입 할 수 있습니다. &lt;a href=&quot;qlayout#removeWidget&quot;&gt;removeWidget&lt;/a&gt; () 함수는 레이아웃에서 지정된 인덱스 위젯을 제거한다. 레이아웃에 포함 된 위젯 수는 &lt;a href=&quot;qstackedlayout#count-prop&quot;&gt;count&lt;/a&gt; () 함수를 사용하여 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9c28b221f7e83baed059e2a307e039e7c948b005" translate="yes" xml:space="preserve">
          <source>When populating a stacked widget, the widgets are added to an internal list. The &lt;a href=&quot;qstackedwidget#indexOf&quot;&gt;indexOf&lt;/a&gt;() function returns the index of a widget in that list. The widgets can either be added to the end of the list using the &lt;a href=&quot;qstackedwidget#addWidget&quot;&gt;addWidget&lt;/a&gt;() function, or inserted at a given index using the &lt;a href=&quot;qstackedwidget#insertWidget&quot;&gt;insertWidget&lt;/a&gt;() function. The &lt;a href=&quot;qstackedwidget#removeWidget&quot;&gt;removeWidget&lt;/a&gt;() function removes a widget from the stacked widget. The number of widgets contained in the stacked widget can be obtained using the &lt;a href=&quot;qstackedwidget#count-prop&quot;&gt;count&lt;/a&gt;() function.</source>
          <target state="translated">누적 위젯을 채울 때 위젯이 내부 목록에 추가됩니다. &lt;a href=&quot;qstackedwidget#indexOf&quot;&gt;같이 IndexOf&lt;/a&gt; () 함수는 목록에서 위젯의 인덱스를 반환합니다. 위젯은 &lt;a href=&quot;qstackedwidget#addWidget&quot;&gt;addWidget&lt;/a&gt; () 함수를 사용하여 목록 끝에 추가 하거나 &lt;a href=&quot;qstackedwidget#insertWidget&quot;&gt;insertWidget&lt;/a&gt; () 함수를 사용하여 지정된 색인에 삽입 할 수 있습니다. &lt;a href=&quot;qstackedwidget#removeWidget&quot;&gt;removeWidget&lt;/a&gt; () 함수는 누적 된 위젯에서 위젯을 제거한다. 누적 된 위젯에 포함 된 위젯 수는 &lt;a href=&quot;qstackedwidget#count-prop&quot;&gt;count&lt;/a&gt; () 함수를 사용하여 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="543155192f84c64b5b7246452a09145b18b3004c" translate="yes" xml:space="preserve">
          <source>When popup windows are visible, this property is &lt;code&gt;true&lt;/code&gt; for both the active window</source>
          <target state="translated">팝업 창이 표시되면이 속성은 활성 창 모두에 대해 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="bf9f03d6670f0731b056deb6a40d087fcc1eaf19" translate="yes" xml:space="preserve">
          <source>When positioning a menu with &lt;a href=&quot;qmenu#exec&quot;&gt;exec&lt;/a&gt;() or &lt;a href=&quot;qmenu#popup&quot;&gt;popup&lt;/a&gt;(), bear in mind that you cannot rely on the menu's current &lt;a href=&quot;qwidget#size-prop&quot;&gt;size&lt;/a&gt;(). For performance reasons, the menu adapts its size only when necessary. So in many cases, the size before and after the show is different. Instead, use &lt;a href=&quot;qmenu#sizeHint&quot;&gt;sizeHint&lt;/a&gt;() which calculates the proper size depending on the menu's current contents.</source>
          <target state="translated">&lt;a href=&quot;qmenu#exec&quot;&gt;exec&lt;/a&gt; () 또는 &lt;a href=&quot;qmenu#popup&quot;&gt;popup&lt;/a&gt; ()을 사용 하여 메뉴를 배치 할 때 메뉴의 현재 &lt;a href=&quot;qwidget#size-prop&quot;&gt;크기&lt;/a&gt; () 에 의존 할 수 없다는 점을 명심하십시오 . 성능상의 이유로 메뉴는 필요한 경우에만 크기를 조정합니다. 따라서 많은 경우 쇼 전후의 크기가 다릅니다. 대신 메뉴의 현재 내용에 따라 적절한 크기를 계산하는 &lt;a href=&quot;qmenu#sizeHint&quot;&gt;sizeHint&lt;/a&gt; ()를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="d446cf9e4868843729e697b92b7ac122b7540da1" translate="yes" xml:space="preserve">
          <source>When positioning a menu with &lt;a href=&quot;qmenu#exec&quot;&gt;exec&lt;/a&gt;() or popup(), bear in mind that you cannot rely on the menu's current &lt;a href=&quot;qwidget#size-prop&quot;&gt;size&lt;/a&gt;(). For performance reasons, the menu adapts its size only when necessary, so in many cases, the size before and after the show is different. Instead, use &lt;a href=&quot;qmenu#sizeHint&quot;&gt;sizeHint&lt;/a&gt;() which calculates the proper size depending on the menu's current contents.</source>
          <target state="translated">&lt;a href=&quot;qmenu#exec&quot;&gt;exec&lt;/a&gt; () 또는 popup () 으로 메뉴를 배치 할 때 메뉴의 현재 &lt;a href=&quot;qwidget#size-prop&quot;&gt;크기&lt;/a&gt; () 에 의존 할 수 없다는 점을 명심하십시오 . 성능상의 이유로 메뉴는 필요한 경우에만 크기를 조정하므로 대부분의 경우 쇼 전후 크기가 다릅니다. 대신 메뉴의 현재 내용에 따라 적절한 크기를 계산하는 &lt;a href=&quot;qmenu#sizeHint&quot;&gt;sizeHint&lt;/a&gt; ()를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="7029c6cc034ef3f728d2bd0679222f0a517d5042" translate="yes" xml:space="preserve">
          <source>When positioning a menu with exec() or &lt;a href=&quot;qmenu#popup&quot;&gt;popup&lt;/a&gt;(), bear in mind that you cannot rely on the menu's current &lt;a href=&quot;qwidget#size-prop&quot;&gt;size&lt;/a&gt;(). For performance reasons, the menu adapts its size only when necessary. So in many cases, the size before and after the show is different. Instead, use &lt;a href=&quot;qmenu#sizeHint&quot;&gt;sizeHint&lt;/a&gt;() which calculates the proper size depending on the menu's current contents.</source>
          <target state="translated">exec () 또는 &lt;a href=&quot;qmenu#popup&quot;&gt;popup&lt;/a&gt; ()을 사용 하여 메뉴를 배치 할 때 메뉴의 현재 &lt;a href=&quot;qwidget#size-prop&quot;&gt;크기&lt;/a&gt; () 에 의존 할 수 없다는 점에 유의하십시오 . 성능상의 이유로 메뉴는 필요한 경우에만 크기를 조정합니다. 그래서 많은 경우 쇼 전후의 크기가 다릅니다. 대신 메뉴의 현재 내용에 따라 적절한 크기를 계산하는 &lt;a href=&quot;qmenu#sizeHint&quot;&gt;sizeHint&lt;/a&gt; ()를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b83e6f455038d9e44dcc627b24af2f87bdc39ec9" translate="yes" xml:space="preserve">
          <source>When possible, it is usually better style to disable the &lt;b&gt;Next&lt;/b&gt; or &lt;b&gt;Finish&lt;/b&gt; button (by specifying &lt;a href=&quot;qwizard#mandatory-fields&quot;&gt;mandatory fields&lt;/a&gt; or by reimplementing &lt;a href=&quot;qwizardpage#isComplete&quot;&gt;QWizardPage::isComplete&lt;/a&gt;()) than to reimplement validateCurrentPage().</source>
          <target state="translated">가능한 경우 validateCurrentPage ()를 다시 구현하는 것보다 &lt;a href=&quot;qwizard#mandatory-fields&quot;&gt;필수 필드&lt;/a&gt; 를 지정 하거나 &lt;a href=&quot;qwizardpage#isComplete&quot;&gt;QWizardPage :: isComplete&lt;/a&gt; ()를 다시 구현 하여 &lt;b&gt;Next&lt;/b&gt; 또는 &lt;b&gt;Finish&lt;/b&gt; 버튼 을 비활성화하는 것이 일반적으로 더 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="73d1c2ff7aa2a64e8d25144a78e96a2f710b582a" translate="yes" xml:space="preserve">
          <source>When possible, it is usually better style to disable the &lt;b&gt;Next&lt;/b&gt; or &lt;b&gt;Finish&lt;/b&gt; button (by specifying &lt;a href=&quot;qwizard#mandatory-fields&quot;&gt;mandatory fields&lt;/a&gt; or reimplementing &lt;a href=&quot;qwizardpage#isComplete&quot;&gt;isComplete&lt;/a&gt;()) than to reimplement validatePage().</source>
          <target state="translated">가능한 경우 validatePage ()를 다시 구현하는 것보다 ( &lt;a href=&quot;qwizard#mandatory-fields&quot;&gt;필수 필드&lt;/a&gt; 를 지정 하거나 &lt;a href=&quot;qwizardpage#isComplete&quot;&gt;isComplete&lt;/a&gt; ()을 다시 구현 하여) &lt;b&gt;다음&lt;/b&gt; 또는 &lt;b&gt;완료&lt;/b&gt; 버튼 을 비활성화하는 것이 일반적으로 더 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="4c25870dd84e6151f006f88996bd899f2da5153f" translate="yes" xml:space="preserve">
          <source>When possible, this static function will use the native file dialog and not a &lt;a href=&quot;qfiledialog&quot;&gt;QFileDialog&lt;/a&gt;. On platforms which don't support selecting remote files, Qt will allow to select only local files.</source>
          <target state="translated">가능하면이 정적 함수는 &lt;a href=&quot;qfiledialog&quot;&gt;QFileDialog가&lt;/a&gt; 아닌 기본 파일 대화 상자를 사용합니다 . 원격 파일 선택을 지원하지 않는 플랫폼에서 Qt는 로컬 파일 만 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b489fbd5401aea28516b412c3104164f51acbe1" translate="yes" xml:space="preserve">
          <source>When posting a custom event to the state machine, you typically also have one or more custom transitions that can be triggered from events of that type. To create such a transition, you subclass &lt;a href=&quot;qabstracttransition&quot;&gt;QAbstractTransition&lt;/a&gt; and reimplement &lt;a href=&quot;qabstracttransition#eventTest&quot;&gt;QAbstractTransition::eventTest&lt;/a&gt;(), where you check if an event matches your event type (and optionally other criteria, e.g. attributes of the event object).</source>
          <target state="translated">상태 시스템에 사용자 지정 이벤트를 게시 할 때 일반적으로 해당 유형의 이벤트에서 트리거 될 수있는 하나 이상의 사용자 지정 전환이 있습니다. 이러한 전환을 만들려면 &lt;a href=&quot;qabstracttransition&quot;&gt;QAbstractTransition&lt;/a&gt; 을 서브 클래 싱 하고 &lt;a href=&quot;qabstracttransition#eventTest&quot;&gt;QAbstractTransition :: eventTest&lt;/a&gt; ()를 다시 구현 하여 이벤트가 이벤트 유형 (및 선택적으로 다른 기준, 예를 들어 이벤트 객체의 속성)과 일치하는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="c0626bfe8658560f4b9456379db258ae7347f2e4" translate="yes" xml:space="preserve">
          <source>When present in a state set, enables the seamless cubemap texture filtering as provided by the GL_ARB_seamless_cubemap extension (if available).</source>
          <target state="translated">상태 세트에있는 경우 GL_ARB_seamless_cubemap 확장 (제공되는 경우)에서 제공하는 심리스 큐브 맵 텍스처 필터링을 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="dd42c97f91ca6cd533ba12641c6d6512a8021b98" translate="yes" xml:space="preserve">
          <source>When pressing the &quot;Pick Screen Color&quot; button, the cursor changes to a haircross and the colors on the screen are scanned. The user can pick up one by clicking the mouse or the Enter button. Pressing Escape restores the last color selected before entering this mode.</source>
          <target state="translated">&quot;화면 색상 선택&quot;버튼을 누르면 커서가 머리카락 모양으로 바뀌고 화면 색상이 스캔됩니다. 사용자는 마우스 또는 Enter 버튼을 클릭하여 하나를 선택할 수 있습니다. Esc 키를 누르면이 모드로 들어가기 전에 마지막으로 선택한 색상이 복원됩니다.</target>
        </trans-unit>
        <trans-unit id="365ed507c80ed465082d4faf723c11a4f4a529f9" translate="yes" xml:space="preserve">
          <source>When printing directly to a printer on Windows or &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt;, &lt;a href=&quot;qprinter&quot;&gt;QPrinter&lt;/a&gt; uses the built-in printer drivers. On X11, &lt;a href=&quot;qprinter&quot;&gt;QPrinter&lt;/a&gt; uses the &lt;a href=&quot;http://www.cups.org/&quot;&gt;Common Unix Printing System (CUPS)&lt;/a&gt; to send PDF output to the printer. As an alternative, the &lt;a href=&quot;qprinter#printProgram&quot;&gt;printProgram&lt;/a&gt;() function can be used to specify the command or utility to use instead of the system default.</source>
          <target state="translated">Windows 또는 &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; 에서 프린터로 직접 인쇄 할 때 &lt;a href=&quot;qprinter&quot;&gt;QPrinter&lt;/a&gt; 는 내장 프린터 드라이버를 사용합니다. X11에서 &lt;a href=&quot;qprinter&quot;&gt;QPrinter&lt;/a&gt; 는 &lt;a href=&quot;http://www.cups.org/&quot;&gt;CUPS (Common Unix Printing System)&lt;/a&gt; 를 사용하여 PDF 출력을 프린터로 보냅니다. 다른 방법으로, &lt;a href=&quot;qprinter#printProgram&quot;&gt;printProgram&lt;/a&gt; () 함수를 사용하여 시스템 기본값 대신 사용할 명령 또는 유틸리티를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9cee561b8e10ced76ed482af9619144ea4d1c14b" translate="yes" xml:space="preserve">
          <source>When printing directly to a printer on Windows or macOS, QPrinter uses the built-in printer drivers. On X11, QPrinter uses the &lt;a href=&quot;http://www.cups.org/&quot;&gt;Common Unix Printing System (CUPS)&lt;/a&gt; to send PDF output to the printer. As an alternative, the &lt;a href=&quot;qprinter#printProgram&quot;&gt;printProgram&lt;/a&gt;() function can be used to specify the command or utility to use instead of the system default.</source>
          <target state="translated">Windows 또는 macOS에서 프린터로 직접 인쇄 할 때 QPrinter는 내장 프린터 드라이버를 사용합니다. X11에서 QPrinter는 &lt;a href=&quot;http://www.cups.org/&quot;&gt;CUPS (Common Unix Printing System)&lt;/a&gt; 를 사용하여 PDF 출력을 프린터로 보냅니다. 대안으로, &lt;a href=&quot;qprinter#printProgram&quot;&gt;printProgram&lt;/a&gt; () 함수를 사용하여 시스템 기본값 대신 사용할 명령 또는 유틸리티를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7baf1526ab727030bb94d023b433c10155cb76be" translate="yes" xml:space="preserve">
          <source>When processing</source>
          <target state="translated">처리 할 때</target>
        </trans-unit>
        <trans-unit id="6d2106bb45d40ac84dd2228f91e6e53dfdbe85fe" translate="yes" xml:space="preserve">
          <source>When processing any of the \code, &lt;a href=&quot;#newcode-command&quot;&gt;\newcode&lt;/a&gt; or &lt;a href=&quot;#oldcode-command&quot;&gt;\oldcode&lt;/a&gt; commands, QDoc removes all indentation that is common for the verbatim code blocks within a &lt;code&gt;/&lt;/code&gt;&lt;code&gt;*!&lt;/code&gt; ... &lt;code&gt;*&lt;/code&gt;&lt;code&gt;/&lt;/code&gt; comment before it adds the standard indentation.</source>
          <target state="translated">\ code, &lt;a href=&quot;#newcode-command&quot;&gt;\ newcode&lt;/a&gt; 또는 &lt;a href=&quot;#oldcode-command&quot;&gt;\ oldcode&lt;/a&gt; 명령을 처리 할 때 QDoc은 &lt;code&gt;/&lt;/code&gt; &lt;code&gt;*!&lt;/code&gt; ... &lt;code&gt;*&lt;/code&gt; &lt;code&gt;/&lt;/code&gt; 의견은 표준 들여 쓰기를 추가하기 전에.</target>
        </trans-unit>
        <trans-unit id="8ac017cc68b793557123c9ce971931fa3dec416c" translate="yes" xml:space="preserve">
          <source>When processing any of the \code, &lt;a href=&quot;06-qdoc-commands-includecodeinline#newcode-command&quot;&gt;\newcode&lt;/a&gt; or &lt;a href=&quot;06-qdoc-commands-includecodeinline#oldcode-command&quot;&gt;\oldcode&lt;/a&gt; commands, QDoc removes all indentation that is common for the verbatim code blocks within a &lt;code&gt;/&lt;/code&gt;&lt;code&gt;*!&lt;/code&gt; ... &lt;code&gt;*&lt;/code&gt;&lt;code&gt;/&lt;/code&gt; comment before it adds the standard indentation.</source>
          <target state="translated">\ code, &lt;a href=&quot;06-qdoc-commands-includecodeinline#newcode-command&quot;&gt;\ newcode&lt;/a&gt; 또는 &lt;a href=&quot;06-qdoc-commands-includecodeinline#oldcode-command&quot;&gt;\ oldcode&lt;/a&gt; 명령을 처리 할 때 QDoc은 &lt;code&gt;/&lt;/code&gt; &lt;code&gt;*!&lt;/code&gt; ... &lt;code&gt;*&lt;/code&gt; &lt;code&gt;/&lt;/code&gt; 표준 들여 쓰기를 추가하기 전에 주석.</target>
        </trans-unit>
        <trans-unit id="0cc162586167c5dda9673822a3e347c76baa904e" translate="yes" xml:space="preserve">
          <source>When processing the &lt;code&gt;headers&lt;/code&gt; variable, QDoc behaves in the same way as it does when processing the &lt;a href=&quot;#headerdirs&quot;&gt;&lt;code&gt;headerdirs&lt;/code&gt;&lt;/a&gt; variable. For more information, see the &lt;a href=&quot;#headerdirs&quot;&gt;&lt;code&gt;headerdirs&lt;/code&gt;&lt;/a&gt; variable.</source>
          <target state="translated">&lt;code&gt;headers&lt;/code&gt; 변수를 처리 할 때 QDoc은 &lt;a href=&quot;#headerdirs&quot;&gt; &lt;code&gt;headerdirs&lt;/code&gt; &lt;/a&gt; 변수를 처리 할 때와 동일한 방식으로 작동 합니다. 자세한 정보는 &lt;a href=&quot;#headerdirs&quot;&gt; &lt;code&gt;headerdirs&lt;/code&gt; &lt;/a&gt; 변수를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9f6649e82a5699a0360075ae40dd46b9e5c7a464" translate="yes" xml:space="preserve">
          <source>When processing the &lt;code&gt;headers&lt;/code&gt; variable, QDoc behaves in the same way as it does when processing the &lt;a href=&quot;22-qdoc-configuration-generalvariables#headerdirs&quot;&gt;&lt;code&gt;headerdirs&lt;/code&gt;&lt;/a&gt; variable. For more information, see the &lt;a href=&quot;22-qdoc-configuration-generalvariables#headerdirs&quot;&gt;&lt;code&gt;headerdirs&lt;/code&gt;&lt;/a&gt; variable.</source>
          <target state="translated">&lt;code&gt;headers&lt;/code&gt; 변수를 처리 할 때 QDoc은 &lt;a href=&quot;22-qdoc-configuration-generalvariables#headerdirs&quot;&gt; &lt;code&gt;headerdirs&lt;/code&gt; &lt;/a&gt; 변수를 처리 할 때와 동일한 방식으로 작동 합니다. 자세한 정보는 &lt;a href=&quot;22-qdoc-configuration-generalvariables#headerdirs&quot;&gt; &lt;code&gt;headerdirs&lt;/code&gt; &lt;/a&gt; 변수를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8485caf25338b1f76aa184669dce3005f004482c" translate="yes" xml:space="preserve">
          <source>When processing the &lt;code&gt;images&lt;/code&gt; variable, QDoc behaves in the same way as it does when processing the &lt;a href=&quot;#imagedirs&quot;&gt;&lt;code&gt;imagedirs&lt;/code&gt;&lt;/a&gt; variable. For more information, see the &lt;a href=&quot;#imagedirs&quot;&gt;&lt;code&gt;imagedirs&lt;/code&gt;&lt;/a&gt; variable.</source>
          <target state="translated">&lt;code&gt;images&lt;/code&gt; 변수를 처리 할 때 QDoc은 &lt;a href=&quot;#imagedirs&quot;&gt; &lt;code&gt;imagedirs&lt;/code&gt; &lt;/a&gt; 변수를 처리 할 때와 동일한 방식으로 작동 합니다. 자세한 정보는 &lt;a href=&quot;#imagedirs&quot;&gt; &lt;code&gt;imagedirs&lt;/code&gt; &lt;/a&gt; 변수를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="83b7b87983b264f92514be824ef568bf74fc4531" translate="yes" xml:space="preserve">
          <source>When processing the &lt;code&gt;images&lt;/code&gt; variable, QDoc behaves in the same way as it does when processing the &lt;a href=&quot;22-qdoc-configuration-generalvariables#imagedirs&quot;&gt;&lt;code&gt;imagedirs&lt;/code&gt;&lt;/a&gt; variable. For more information, see the &lt;a href=&quot;22-qdoc-configuration-generalvariables#imagedirs&quot;&gt;&lt;code&gt;imagedirs&lt;/code&gt;&lt;/a&gt; variable.</source>
          <target state="translated">&lt;code&gt;images&lt;/code&gt; 변수를 처리 할 때 QDoc은 &lt;a href=&quot;22-qdoc-configuration-generalvariables#imagedirs&quot;&gt; &lt;code&gt;imagedirs&lt;/code&gt; &lt;/a&gt; 변수를 처리 할 때와 동일한 방식으로 작동 합니다. 자세한 정보는 &lt;a href=&quot;22-qdoc-configuration-generalvariables#imagedirs&quot;&gt; &lt;code&gt;imagedirs&lt;/code&gt; &lt;/a&gt; 변수를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="02ac4cb127779361e46edccdd9715135c772a6b4" translate="yes" xml:space="preserve">
          <source>When processing the &lt;code&gt;sources&lt;/code&gt; variable, QDoc behaves in the same way as it does when processing the &lt;a href=&quot;#sourcedirs-variable&quot;&gt;sourcedirs&lt;/a&gt; variable. For more information, see the &lt;a href=&quot;#sourcedirs-variable&quot;&gt;sourcedirs&lt;/a&gt; variable.</source>
          <target state="translated">&lt;code&gt;sources&lt;/code&gt; 변수를 처리 할 때 QDoc은 &lt;a href=&quot;#sourcedirs-variable&quot;&gt;sourcedirs&lt;/a&gt; 변수를 처리 할 때와 동일한 방식으로 작동 합니다. 자세한 정보는 &lt;a href=&quot;#sourcedirs-variable&quot;&gt;sourcedirs&lt;/a&gt; 변수를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cad134d8c8f7cf34f150e5381504660ade1079a5" translate="yes" xml:space="preserve">
          <source>When processing the &lt;code&gt;sources&lt;/code&gt; variable, QDoc behaves in the same way as it does when processing the &lt;a href=&quot;22-qdoc-configuration-generalvariables#sourcedirs-variable&quot;&gt;sourcedirs&lt;/a&gt; variable. For more information, see the &lt;a href=&quot;22-qdoc-configuration-generalvariables#sourcedirs-variable&quot;&gt;sourcedirs&lt;/a&gt; variable.</source>
          <target state="translated">&lt;code&gt;sources&lt;/code&gt; 변수를 처리 할 때 QDoc은 &lt;a href=&quot;22-qdoc-configuration-generalvariables#sourcedirs-variable&quot;&gt;sourcedirs&lt;/a&gt; 변수를 처리 할 때와 동일한 방식으로 작동 합니다. 자세한 정보는 &lt;a href=&quot;22-qdoc-configuration-generalvariables#sourcedirs-variable&quot;&gt;sourcedirs&lt;/a&gt; 변수를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d2f6258fc95387a5c4367b7340551e8c1e093ed8" translate="yes" xml:space="preserve">
          <source>When processing the header files specified in the &lt;a href=&quot;#headerdirs&quot;&gt;&lt;code&gt;headerdirs&lt;/code&gt;&lt;/a&gt; variable, QDoc will only read the files with the fileextensions specified in the &lt;code&gt;headers.fileextensions&lt;/code&gt; variable. In this way QDoc avoids spending time reading irrelevant files.</source>
          <target state="translated">에 지정된 헤더 파일을 처리 할 때 &lt;a href=&quot;#headerdirs&quot;&gt; &lt;code&gt;headerdirs&lt;/code&gt; 의&lt;/a&gt; 변수를 QDOC 만에 지정된 fileextensions와 파일을 읽을 &lt;code&gt;headers.fileextensions&lt;/code&gt; 의 변수를. 이런 식으로 QDoc은 관련없는 파일을 읽는 데 시간을 소비하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e6e737bd0bca30837e70dbf0ba50e38a69eda1ae" translate="yes" xml:space="preserve">
          <source>When processing the header files specified in the &lt;a href=&quot;22-qdoc-configuration-generalvariables#headerdirs&quot;&gt;&lt;code&gt;headerdirs&lt;/code&gt;&lt;/a&gt; variable, QDoc will only read the files with the fileextensions specified in the &lt;code&gt;headers.fileextensions&lt;/code&gt; variable. In this way QDoc avoids spending time reading irrelevant files.</source>
          <target state="translated">에 지정된 헤더 파일을 처리 할 때 &lt;a href=&quot;22-qdoc-configuration-generalvariables#headerdirs&quot;&gt; &lt;code&gt;headerdirs&lt;/code&gt; 의&lt;/a&gt; 변수를 QDOC 만에 지정된 fileextensions와 파일을 읽을 &lt;code&gt;headers.fileextensions&lt;/code&gt; 의 변수를. 이러한 방식으로 QDoc은 관련없는 파일을 읽는 데 시간을 소비하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4ed979007a1c43ad6e1c65933f5ff78d1bf33f42" translate="yes" xml:space="preserve">
          <source>When processing the source files specified in the &lt;a href=&quot;#sourcedirs&quot;&gt;&lt;code&gt;sourcedirs&lt;/code&gt;&lt;/a&gt; variable, QDoc will only read the files with the fileextensions specified in the &lt;code&gt;sources.fileextensions&lt;/code&gt; variable. In this way QDoc avoid spending time reading irrelevant files.</source>
          <target state="translated">&lt;a href=&quot;#sourcedirs&quot;&gt; &lt;code&gt;sourcedirs&lt;/code&gt; &lt;/a&gt; 변수에 지정된 소스 파일을 처리 할 때 QDoc은 &lt;code&gt;sources.fileextensions&lt;/code&gt; 변수에 지정된 파일 확장자를 가진 파일 만 읽습니다 . 이런 식으로 QDoc은 관련없는 파일을 읽는 데 시간을 소비하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cfdcd3052995a6aaff22f71ef5141edb96daddb2" translate="yes" xml:space="preserve">
          <source>When processing the source files specified in the &lt;a href=&quot;22-qdoc-configuration-generalvariables#sourcedirs&quot;&gt;&lt;code&gt;sourcedirs&lt;/code&gt;&lt;/a&gt; variable, QDoc will only read the files with the fileextensions specified in the &lt;code&gt;sources.fileextensions&lt;/code&gt; variable. In this way QDoc avoid spending time reading irrelevant files.</source>
          <target state="translated">&lt;a href=&quot;22-qdoc-configuration-generalvariables#sourcedirs&quot;&gt; &lt;code&gt;sourcedirs&lt;/code&gt; &lt;/a&gt; 변수에 지정된 소스 파일을 처리 할 때 QDoc은 &lt;code&gt;sources.fileextensions&lt;/code&gt; 변수에 지정된 파일 확장자가있는 파일 만 읽습니다 . 이런 식으로 QDoc은 관련없는 파일을 읽는 데 시간을 소비하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f3b3725626f2e2c1e184c3a3386769f3ccdb3009" translate="yes" xml:space="preserve">
          <source>When properties are defined on a &lt;a href=&quot;qt3dcore-qnode&quot;&gt;QNode&lt;/a&gt; subclass, their NOTIFY signal will automatically generate notifications that the Qt3D backend aspects will receive.</source>
          <target state="translated">속성이 &lt;a href=&quot;qt3dcore-qnode&quot;&gt;QNode&lt;/a&gt; 서브 클래스 에 정의되면 , NOTIFY 신호는 Qt3D 백엔드 측면이 수신한다는 알림을 자동으로 생성합니다.</target>
        </trans-unit>
        <trans-unit id="c17f593088b99a91dc585e42d8e3fdd068f8c76c" translate="yes" xml:space="preserve">
          <source>When properties are defined on a QNode subclass, their NOTIFY signal will automatically generate notifications that the Qt3D backend aspects will receive.</source>
          <target state="translated">속성이 QNode 하위 클래스에 정의되면 해당 NOTIFY 신호가 Qt3D 백엔드 측면이 수신 할 알림을 자동으로 생성합니다.</target>
        </trans-unit>
        <trans-unit id="22650f203b3bc55d65cd8bcc3c197b3e1ae94f80" translate="yes" xml:space="preserve">
          <source>When protecting for a short-term operation, it is acceptable to call &lt;a href=&quot;qlockfile#lock&quot;&gt;lock&lt;/a&gt;() and wait until any running operation finishes. When protecting a resource over a long time, however, the application should always call &lt;a href=&quot;qlockfile#setStaleLockTime&quot;&gt;setStaleLockTime&lt;/a&gt;(0) and then &lt;a href=&quot;qlockfile#tryLock&quot;&gt;tryLock&lt;/a&gt;() with a short timeout, in order to warn the user that the resource is locked.</source>
          <target state="translated">단기 작업을 보호 할 때는 &lt;a href=&quot;qlockfile#lock&quot;&gt;잠금&lt;/a&gt; () 을 호출 하고 실행중인 작업이 끝날 때까지 기다릴 수 있습니다. 그러나 오랜 시간 동안 리소스를 보호 할 때 응용 프로그램은 리소스가 잠겨 있음을 사용자에게 경고하기 위해 항상 &lt;a href=&quot;qlockfile#setStaleLockTime&quot;&gt;setStaleLockTime&lt;/a&gt; (0)을 &lt;a href=&quot;qlockfile#tryLock&quot;&gt;호출&lt;/a&gt; 한 다음 짧은 시간 초과 로 tryLock () 을 호출 해야합니다.</target>
        </trans-unit>
        <trans-unit id="12b6bb01343a6f269ac19359f22a3d9b836dd641" translate="yes" xml:space="preserve">
          <source>When providing your own attributes, it may make sense to name your attribute using helpers such as &lt;a href=&quot;qt3drender-qattribute#defaultPositionAttributeName&quot;&gt;QAttribute::defaultPositionAttributeName&lt;/a&gt;() as that will ensure your geometry will be compatible with picking and the various materials provided in the &lt;a href=&quot;https://doc.qt.io/qt-5.13/qt3dextras-module.html&quot;&gt;Qt3DExtras&lt;/a&gt; module.</source>
          <target state="translated">고유 한 속성을 제공 할 때 &lt;a href=&quot;qt3drender-qattribute#defaultPositionAttributeName&quot;&gt;QAttribute :: defaultPositionAttributeName&lt;/a&gt; () 과 같은 도우미 를 사용하여 지오메트리가 선택 및 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qt3dextras-module.html&quot;&gt;Qt3DExtras&lt;/a&gt; 모듈 에서 제공되는 다양한 재료와 호환되도록 속성을 명명 하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="1c5031580380ec45abd2184625b064726bd7956e" translate="yes" xml:space="preserve">
          <source>When providing your own attributes, it may make sense to name your attribute using helpers such as &lt;a href=&quot;qt3drender-qattribute#defaultPositionAttributeName&quot;&gt;QAttribute::defaultPositionAttributeName&lt;/a&gt;() as that will ensure your geometry will be compatible with picking and the various materials provided in the &lt;a href=&quot;https://doc.qt.io/qt-5.15/qt3dextras-module.html&quot;&gt;Qt3DExtras&lt;/a&gt; module.</source>
          <target state="translated">고유 한 속성을 제공 할 때 &lt;a href=&quot;qt3drender-qattribute#defaultPositionAttributeName&quot;&gt;QAttribute :: defaultPositionAttributeName&lt;/a&gt; () 과 같은 도우미를 사용하여 속성의 이름을 지정 하면 지오메트리가 선택 및 &lt;a href=&quot;https://doc.qt.io/qt-5.15/qt3dextras-module.html&quot;&gt;Qt3DExtras&lt;/a&gt; 모듈 에서 제공되는 다양한 재료와 호환되도록 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="83204666112336ac2cd938437ecd85c2c9e42c43" translate="yes" xml:space="preserve">
          <source>When providing your own attributes, it may make sense to name your attribute using helpers such as QAttribute::defaultPositionAttributeName() as that will ensure your geometry will be compatible with picking and the various materials provided in the &lt;a href=&quot;https://doc.qt.io/qt-5.13/qt3dextras-module.html&quot;&gt;Qt3DExtras&lt;/a&gt; module.</source>
          <target state="translated">고유 한 속성을 제공 할 때 QAttribute :: defaultPositionAttributeName ()과 같은 도우미를 사용하여 지오메트리가 선택 및 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qt3dextras-module.html&quot;&gt;Qt3DExtras&lt;/a&gt; 모듈 에서 제공되는 다양한 재료와 호환되도록 속성을 명명하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="7f0b771b8b6122f451fd39a4eec632c95f8abf9c" translate="yes" xml:space="preserve">
          <source>When providing your own attributes, it may make sense to name your attribute using helpers such as QAttribute::defaultPositionAttributeName() as that will ensure your geometry will be compatible with picking and the various materials provided in the &lt;a href=&quot;https://doc.qt.io/qt-5.15/qt3dextras-module.html&quot;&gt;Qt3DExtras&lt;/a&gt; module.</source>
          <target state="translated">고유 한 속성을 제공 할 때 QAttribute :: defaultPositionAttributeName ()과 같은 도우미를 사용하여 속성의 이름을 지정하는 것이 합리적 일 수 있습니다. 그러면 지오메트리가 &lt;a href=&quot;https://doc.qt.io/qt-5.15/qt3dextras-module.html&quot;&gt;Qt3DExtras&lt;/a&gt; 모듈 에서 제공되는 다양한 재료 및 선택과 호환 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7be4e2868f53c5c712c37033765565589dd9a696" translate="yes" xml:space="preserve">
          <source>When qmake is run, an &lt;code&gt;Info.plist&lt;/code&gt; file is generated with appropriate default values.</source>
          <target state="translated">qmake가 실행되면 &lt;code&gt;Info.plist&lt;/code&gt; 파일이 적절한 기본값으로 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="deaab1579f95ca0cb54a7c45e2f6602842f9bf55" translate="yes" xml:space="preserve">
          <source>When qmake processes the project file, it will generate a Makefile rule to allow the project to be built in both modes. This can be invoked in the following way:</source>
          <target state="translated">qmake가 프로젝트 파일을 처리 할 때 Makefile 규칙을 생성하여 프로젝트를 두 모드로 빌드 할 수 있습니다. 다음과 같은 방법으로 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="433bf4e26978749cad77ae5bdc38533c0acb441e" translate="yes" xml:space="preserve">
          <source>When queries are generated to be executed on the database only those fields for which &lt;a href=&quot;qsqlrecord#isGenerated&quot;&gt;isGenerated&lt;/a&gt;() is true are included in the generated SQL.</source>
          <target state="translated">데이터베이스에서 실행되도록 쿼리가 생성되면 &lt;a href=&quot;qsqlrecord#isGenerated&quot;&gt;isGenerated&lt;/a&gt; ()가 true 인 필드 만 생성 된 SQL에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="9333afa0fced835478399e93823c406d22de675b" translate="yes" xml:space="preserve">
          <source>When quoting is disabled, these types are printed without quotation characters and without escaping of non-printable characters.</source>
          <target state="translated">인용을 사용하지 않으면 이러한 유형은 따옴표없이 인쇄 할 수없는 문자를 이스케이프하지 않고 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="2e3a5904501c88a29777d21a5ea08bedba058dd9" translate="yes" xml:space="preserve">
          <source>When reading from QByteArray(), the &lt;a href=&quot;qcborstreamreader#addData&quot;&gt;addData&lt;/a&gt;() function automatically calls this function. Calling it when the reading had not failed is a no-op.</source>
          <target state="translated">QByteArray ()에서 읽을 때 &lt;a href=&quot;qcborstreamreader#addData&quot;&gt;addData&lt;/a&gt; () 함수는이 함수를 자동으로 호출합니다. 읽기가 실패하지 않은 상태에서 호출하는 것은 아무 문제가 없습니다.</target>
        </trans-unit>
        <trans-unit id="2961583e309be088817f7af5160b0e7c63f99641" translate="yes" xml:space="preserve">
          <source>When reading, the end-of-line terminators are translated to '\n'. When writing, the end-of-line terminators are translated to the local encoding, for example '\r\n' for Win32.</source>
          <target state="translated">읽을 때 줄 끝 종결자는 '\ n'으로 변환됩니다. 쓸 때 줄 끝 종결자는 로컬 인코딩으로 변환됩니다 (예 : Win32의 경우 '\ r \ n').</target>
        </trans-unit>
        <trans-unit id="0178fb06130fa3ace5f0116314a30ba2905b8155" translate="yes" xml:space="preserve">
          <source>When receiving an input method event, the text widget has to performs the following steps:</source>
          <target state="translated">입력 메소드 이벤트를 수신 할 때 텍스트 위젯은 다음 단계를 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="bc54aed1354ce805c861b084074c4b15f2941b02" translate="yes" xml:space="preserve">
          <source>When registered with QML in this way, they can be used as property types:</source>
          <target state="translated">이런 방식으로 QML에 등록하면 속성 유형으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6de85969ab467e39090e43789eb7746771150552" translate="yes" xml:space="preserve">
          <source>When registered with the QML engine in this way, they can be used as property types:</source>
          <target state="translated">이런 방식으로 QML 엔진에 등록하면 다음과 같은 속성 유형으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="658aa3d331e786b5cf19cdc003900fc565a01ebd" translate="yes" xml:space="preserve">
          <source>When reimplementing &lt;a href=&quot;qabstractitemmodel#insertColumns&quot;&gt;insertColumns&lt;/a&gt;() in a subclass, you must call this function</source>
          <target state="translated">서브 클래스에서 &lt;a href=&quot;qabstractitemmodel#insertColumns&quot;&gt;insertColumns&lt;/a&gt; ()를 다시 구현할 때이 함수를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="4c93d0d6698e3e63d88035f6f5efca5fb6102f1c" translate="yes" xml:space="preserve">
          <source>When reimplementing &lt;a href=&quot;qabstractitemmodel#insertRows&quot;&gt;insertRows&lt;/a&gt;() in a subclass, you must call this function</source>
          <target state="translated">서브 클래스에서 &lt;a href=&quot;qabstractitemmodel#insertRows&quot;&gt;insertRows&lt;/a&gt; ()를 다시 구현할 때이 함수를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="85d1f3aba6b52c7b19fa00f7d1afc309113e34b8" translate="yes" xml:space="preserve">
          <source>When reimplementing &lt;a href=&quot;qabstractitemmodel#removeColumns&quot;&gt;removeColumns&lt;/a&gt;() in a subclass, you must call this function</source>
          <target state="translated">서브 클래스에서 &lt;a href=&quot;qabstractitemmodel#removeColumns&quot;&gt;removeColumns&lt;/a&gt; ()를 다시 구현할 때이 함수를 호출해야합니다</target>
        </trans-unit>
        <trans-unit id="f37a182e5a69ec7aec2bf70e9e8e6c7db8177d59" translate="yes" xml:space="preserve">
          <source>When reimplementing &lt;a href=&quot;qabstractitemmodel#removeRows&quot;&gt;removeRows&lt;/a&gt;() in a subclass, you must call this function</source>
          <target state="translated">서브 클래스에서 &lt;a href=&quot;qabstractitemmodel#removeRows&quot;&gt;removeRows&lt;/a&gt; ()를 다시 구현할 때이 함수를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="9b0330becdc29ff2c73cb6957330004540cba4dd" translate="yes" xml:space="preserve">
          <source>When reimplementing &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt; functions that take a &lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption&lt;/a&gt; parameter, you often need to cast the &lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption&lt;/a&gt; to a subclass (e.g., &lt;a href=&quot;qstyleoptionfocusrect&quot;&gt;QStyleOptionFocusRect&lt;/a&gt;). For safety, you can use &lt;a href=&quot;qstyleoption#qstyleoption_cast&quot;&gt;qstyleoption_cast&lt;/a&gt;() to ensure that the pointer type is correct. If the object isn't of the right type, &lt;a href=&quot;qstyleoption#qstyleoption_cast&quot;&gt;qstyleoption_cast&lt;/a&gt;() returns &lt;code&gt;nullptr&lt;/code&gt;. For example:</source>
          <target state="translated">&lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption&lt;/a&gt; 매개 변수 를 사용하는 &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt; 함수를 다시 구현할 때 종종 &lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption&lt;/a&gt; 을 서브 클래스 (예 : &lt;a href=&quot;qstyleoptionfocusrect&quot;&gt;QStyleOptionFocusRect&lt;/a&gt; ) 로 캐스트해야합니다 . 안전 을 위해 &lt;a href=&quot;qstyleoption#qstyleoption_cast&quot;&gt;qstyleoption_cast&lt;/a&gt; ()를 사용하여 포인터 유형이 올바른지 확인할 수 있습니다. 객체가 올바른 유형이 아닌 경우 &lt;a href=&quot;qstyleoption#qstyleoption_cast&quot;&gt;qstyleoption_cast&lt;/a&gt; ()는 &lt;code&gt;nullptr&lt;/code&gt; 을 반환합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9dfc851c4dac23e39db3f903a4238131999a47c4" translate="yes" xml:space="preserve">
          <source>When reimplementing &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt; functions that take a &lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption&lt;/a&gt; parameter, you often need to cast the &lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption&lt;/a&gt; to a subclass. For safety, you can use &lt;a href=&quot;qstyleoption#qstyleoption_cast&quot;&gt;qstyleoption_cast&lt;/a&gt;() to ensure that the pointer type is correct. For example:</source>
          <target state="translated">&lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption&lt;/a&gt; 매개 변수 를 사용하는 &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt; 함수를 다시 구현할 때 종종 &lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption&lt;/a&gt; 을 서브 클래스 로 캐스트해야합니다 . 안전 을 위해 &lt;a href=&quot;qstyleoption#qstyleoption_cast&quot;&gt;qstyleoption_cast&lt;/a&gt; ()를 사용하여 포인터 유형이 올바른지 확인할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7c3a36cf890d4e609cd3054eba937187efb84074" translate="yes" xml:space="preserve">
          <source>When reimplementing &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt; functions that take a QStyleOption parameter, you often need to cast the QStyleOption to a subclass. For safety, you can use &lt;a href=&quot;qstyleoption#qstyleoption_cast&quot;&gt;qstyleoption_cast&lt;/a&gt;() to ensure that the pointer type is correct. For example:</source>
          <target state="translated">QStyleOption 매개 변수를 사용하는 &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt; 함수를 다시 구현할 때 종종 QStyleOption을 하위 클래스로 캐스팅해야합니다. 안전 을 위해 &lt;a href=&quot;qstyleoption#qstyleoption_cast&quot;&gt;qstyleoption_cast&lt;/a&gt; ()를 사용하여 포인터 유형이 올바른지 확인할 수 있습니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="ec235ac06dbbca492dcbe4cfde2eff2f73ed2863" translate="yes" xml:space="preserve">
          <source>When reimplementing &lt;a href=&quot;qstyleditemdelegate#paint&quot;&gt;paint&lt;/a&gt;(), one would typically handle the datatypes one would like to draw and use the superclass implementation for other types.</source>
          <target state="translated">&lt;a href=&quot;qstyleditemdelegate#paint&quot;&gt;paint&lt;/a&gt; ()를 다시 구현할 때 일반적으로 다른 유형에 대해 슈퍼 클래스 구현을 그리거나 사용하려는 데이터 유형을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="fb3e42362330e9b7392e5e0ebae5fafed9a1a17a" translate="yes" xml:space="preserve">
          <source>When reimplementing a subclass, this method simplifies moving entities in your model. This method is responsible for moving persistent indexes in the model, which you would otherwise be required to do yourself. Using beginMoveColumns and &lt;a href=&quot;qabstractitemmodel#endMoveColumns&quot;&gt;endMoveColumns&lt;/a&gt; is an alternative to emitting &lt;a href=&quot;qabstractitemmodel#layoutAboutToBeChanged&quot;&gt;layoutAboutToBeChanged&lt;/a&gt; and &lt;a href=&quot;qabstractitemmodel#layoutChanged&quot;&gt;layoutChanged&lt;/a&gt; directly along with &lt;a href=&quot;qabstractitemmodel#changePersistentIndex&quot;&gt;changePersistentIndex&lt;/a&gt;.</source>
          <target state="translated">서브 클래스를 다시 구현할 때이 메소드는 모델에서 엔티티 이동을 단순화합니다. 이 방법은 모델에서 지속적 인덱스를 이동시키는 역할을하며, 그렇지 않으면 직접 수행해야합니다. beginMoveColumns 및 사용 &lt;a href=&quot;qabstractitemmodel#endMoveColumns&quot;&gt;endMoveColumns하면&lt;/a&gt; 출사의 대안 &lt;a href=&quot;qabstractitemmodel#layoutAboutToBeChanged&quot;&gt;layoutAboutToBeChanged을&lt;/a&gt; 하고 &lt;a href=&quot;qabstractitemmodel#layoutChanged&quot;&gt;layoutChanged&lt;/a&gt; 직접 따라 함께 &lt;a href=&quot;qabstractitemmodel#changePersistentIndex&quot;&gt;changePersistentIndex&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="37d54556abfd5846d3b883b6100f1fa44ae8b968" translate="yes" xml:space="preserve">
          <source>When reimplementing a subclass, this method simplifies moving entities in your model. This method is responsible for moving persistent indexes in the model, which you would otherwise be required to do yourself. Using beginMoveRows and &lt;a href=&quot;qabstractitemmodel#endMoveRows&quot;&gt;endMoveRows&lt;/a&gt; is an alternative to emitting &lt;a href=&quot;qabstractitemmodel#layoutAboutToBeChanged&quot;&gt;layoutAboutToBeChanged&lt;/a&gt; and &lt;a href=&quot;qabstractitemmodel#layoutChanged&quot;&gt;layoutChanged&lt;/a&gt; directly along with &lt;a href=&quot;qabstractitemmodel#changePersistentIndex&quot;&gt;changePersistentIndex&lt;/a&gt;.</source>
          <target state="translated">서브 클래스를 다시 구현할 때이 메소드는 모델에서 엔티티 이동을 단순화합니다. 이 방법은 모델에서 지속적 인덱스를 이동시키는 역할을하며, 그렇지 않으면 직접 수행해야합니다. beginMoveRows 및 사용 &lt;a href=&quot;qabstractitemmodel#endMoveRows&quot;&gt;endMoveRows하면&lt;/a&gt; 출사의 대안 &lt;a href=&quot;qabstractitemmodel#layoutAboutToBeChanged&quot;&gt;layoutAboutToBeChanged을&lt;/a&gt; 하고 &lt;a href=&quot;qabstractitemmodel#layoutChanged&quot;&gt;layoutChanged&lt;/a&gt; 직접 따라 함께 &lt;a href=&quot;qabstractitemmodel#changePersistentIndex&quot;&gt;changePersistentIndex&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ca95dc0c0eb787c2eeed20255a0cb245f62492af" translate="yes" xml:space="preserve">
          <source>When reimplementing canRead(), make sure that the I/O device (&lt;a href=&quot;qimageiohandler#device&quot;&gt;device&lt;/a&gt;()) is left in its original state (e.g., by using peek() rather than &lt;a href=&quot;qimageiohandler#read&quot;&gt;read&lt;/a&gt;()).</source>
          <target state="translated">canRead ()를 다시 구현할 때 I / O 장치 ( &lt;a href=&quot;qimageiohandler#device&quot;&gt;장치&lt;/a&gt; ())가 원래 상태로 남아 있는지 확인하십시오 (예 : &lt;a href=&quot;qimageiohandler#read&quot;&gt;읽기&lt;/a&gt; () 대신 peek () 사용 ).</target>
        </trans-unit>
        <trans-unit id="028d93193544c8ed47ad98dfeadb939c5667b03b" translate="yes" xml:space="preserve">
          <source>When reimplementing paint in a subclass. Use the &lt;a href=&quot;qstyleditemdelegate#initStyleOption&quot;&gt;initStyleOption&lt;/a&gt;() to set up the</source>
          <target state="translated">서브 클래스에서 페인트를 다시 구현할 때. 사용 &lt;a href=&quot;qstyleditemdelegate#initStyleOption&quot;&gt;initStyleOption를&lt;/a&gt; 설정 ()을</target>
        </trans-unit>
        <trans-unit id="df7f5f683e515c4160cc8d6065b4b4913422655c" translate="yes" xml:space="preserve">
          <source>When reimplementing the &lt;a href=&quot;qabstractitemmodel#setData&quot;&gt;setData&lt;/a&gt;() function, this signal must be emitted explicitly.</source>
          <target state="translated">&lt;a href=&quot;qabstractitemmodel#setData&quot;&gt;setData&lt;/a&gt; () 함수를 다시 구현할 때이 신호를 명시 적으로 방출해야합니다.</target>
        </trans-unit>
        <trans-unit id="6f516d38e016de108e31954fe638b31e63f64384" translate="yes" xml:space="preserve">
          <source>When reimplementing the &lt;a href=&quot;qabstractitemmodel#setHeaderData&quot;&gt;setHeaderData&lt;/a&gt;() function, this signal must be emitted explicitly.</source>
          <target state="translated">&lt;a href=&quot;qabstractitemmodel#setHeaderData&quot;&gt;setHeaderData&lt;/a&gt; () 함수를 다시 구현할 때이 신호가 명시 적으로 방출되어야합니다.</target>
        </trans-unit>
        <trans-unit id="8bb42c54f45079c9c25f1595264e446c8f5dae51" translate="yes" xml:space="preserve">
          <source>When reimplementing the &lt;a href=&quot;qeventtransition#eventTest&quot;&gt;eventTest&lt;/a&gt;() function, you should first call the base implementation to verify that the event is a &lt;a href=&quot;qstatemachine-wrappedevent&quot;&gt;QStateMachine::WrappedEvent&lt;/a&gt; for the proper object and event type. You may then cast the event to a &lt;a href=&quot;qstatemachine-wrappedevent&quot;&gt;QStateMachine::WrappedEvent&lt;/a&gt; and get the original event by calling &lt;a href=&quot;qstatemachine-wrappedevent#event&quot;&gt;QStateMachine::WrappedEvent::event&lt;/a&gt;(), and perform additional checks on that object.</source>
          <target state="translated">&lt;a href=&quot;qeventtransition#eventTest&quot;&gt;eventTest&lt;/a&gt; () 함수를 다시 구현할 때는 먼저 기본 구현을 호출하여 이벤트가 올바른 객체 및 이벤트 유형에 대한 &lt;a href=&quot;qstatemachine-wrappedevent&quot;&gt;QStateMachine :: WrappedEvent인지&lt;/a&gt; 확인해야합니다 . 그런 다음 이벤트를 &lt;a href=&quot;qstatemachine-wrappedevent&quot;&gt;QStateMachine :: WrappedEvent&lt;/a&gt; 로 캐스트하고 &lt;a href=&quot;qstatemachine-wrappedevent#event&quot;&gt;QStateMachine :: WrappedEvent :: event&lt;/a&gt; () 를 호출하여 원래 이벤트를 가져 오고 해당 오브젝트에 대한 추가 점검을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b124ac10b911b199139a9b1396e9a53e131374c7" translate="yes" xml:space="preserve">
          <source>When reimplementing this class, take care to return at least one element.</source>
          <target state="translated">이 클래스를 다시 구현할 때 하나 이상의 요소를 반환하도록주의하십시오.</target>
        </trans-unit>
        <trans-unit id="55e2b93bd22d4647e3de872d6613c4f4629fae05" translate="yes" xml:space="preserve">
          <source>When reimplementing this function in a subclass, be careful to avoid calling &lt;a href=&quot;qmodelindex&quot;&gt;QModelIndex&lt;/a&gt; member functions, such as &lt;a href=&quot;qmodelindex#parent&quot;&gt;QModelIndex::parent&lt;/a&gt;(), since indexes belonging to your model will simply call your implementation, leading to infinite recursion.</source>
          <target state="translated">서브 클래스에서이 함수를 다시 구현할 때는 모델에 속하는 인덱스가 단순히 구현을 호출하여 무한 재귀를 유발 하므로 &lt;a href=&quot;qmodelindex#parent&quot;&gt;QModelIndex :: parent&lt;/a&gt; () 와 같은 &lt;a href=&quot;qmodelindex&quot;&gt;QModelIndex&lt;/a&gt; 멤버 함수를 호출하지 않도록주의 하십시오.</target>
        </trans-unit>
        <trans-unit id="70e5caa7bbddd6d74b4efb7d8a7005f9825d497b" translate="yes" xml:space="preserve">
          <source>When reimplementing this function in a subclass, call &lt;a href=&quot;qabstractitemmodel#createIndex&quot;&gt;createIndex&lt;/a&gt;() to generate model indexes that other components can use to refer to items in your model.</source>
          <target state="translated">서브 클래스에서이 함수를 다시 구현할 때 &lt;a href=&quot;qabstractitemmodel#createIndex&quot;&gt;createIndex&lt;/a&gt; ()를 호출 하여 다른 컴포넌트가 모델의 항목을 참조하는 데 사용할 수있는 모델 색인을 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="ba7f9d147f366305cacefe9a55e635566170bc6d" translate="yes" xml:space="preserve">
          <source>When reimplementing this function in a subclass, you should update the area held by the option's &lt;a href=&quot;qstyleoption#rect-var&quot;&gt;rect&lt;/a&gt; variable, using the option's &lt;a href=&quot;qstyleoption#state-var&quot;&gt;state&lt;/a&gt; variable to determine the state of the item to be displayed, and adjust the way it is painted accordingly.</source>
          <target state="translated">서브 클래스에서이 함수를 다시 구현할 때 옵션의 &lt;a href=&quot;qstyleoption#state-var&quot;&gt;상태&lt;/a&gt; 변수를 사용하여 옵션의 &lt;a href=&quot;qstyleoption#rect-var&quot;&gt;rect&lt;/a&gt; 변수가 보유한 영역을 업데이트하여 표시 할 항목의 상태를 판별하고 그에 따라 페인트 방법을 조정해야합니다.</target>
        </trans-unit>
        <trans-unit id="4e2d2f89b79fefee58d5613beec7b9bd5dde6fb5" translate="yes" xml:space="preserve">
          <source>When reimplementing this function it is important that this function reads all the required data before returning. This is required in order for &lt;a href=&quot;qdatastream&quot;&gt;QDataStream&lt;/a&gt; to be able to operate on the class. &lt;a href=&quot;qdatastream&quot;&gt;QDataStream&lt;/a&gt; assumes all the requested information was read and therefore does not retry reading if there was a problem.</source>
          <target state="translated">이 함수를 다시 구현할 때이 함수는 리턴하기 전에 필요한 모든 데이터를 읽는 것이 중요합니다. 이것은 &lt;a href=&quot;qdatastream&quot;&gt;QDataStream&lt;/a&gt; 이 클래스에서 작동 할 수 있도록 하기 위해 필요합니다 . &lt;a href=&quot;qdatastream&quot;&gt;QDataStream&lt;/a&gt; 은 요청 된 모든 정보를 읽은 것으로 가정하므로 문제가있는 경우 다시 읽지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e93d19bd100346fac19905c7b4a51959378ca55b" translate="yes" xml:space="preserve">
          <source>When reimplementing this function it is important that this function writes all the data available before returning. This is required in order for &lt;a href=&quot;qdatastream&quot;&gt;QDataStream&lt;/a&gt; to be able to operate on the class. &lt;a href=&quot;qdatastream&quot;&gt;QDataStream&lt;/a&gt; assumes all the information was written and therefore does not retry writing if there was a problem.</source>
          <target state="translated">이 함수를 다시 구현할 때이 함수는 반환하기 전에 사용 가능한 모든 데이터를 기록해야합니다. 이것은 &lt;a href=&quot;qdatastream&quot;&gt;QDataStream&lt;/a&gt; 이 클래스에서 작동 할 수 있도록 하기 위해 필요합니다 . &lt;a href=&quot;qdatastream&quot;&gt;QDataStream&lt;/a&gt; 은 모든 정보가 기록되었다고 가정하므로 문제가 발생한 경우 다시 쓰지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dbe06314296a3392519e885c147e88b10b0594de" translate="yes" xml:space="preserve">
          <source>When reimplementing this function, note that in case of text items, &lt;a href=&quot;qitemdelegate&quot;&gt;QItemDelegate&lt;/a&gt; adds a margin (i.e. 2 * &lt;a href=&quot;qstyle#PixelMetric-enum&quot;&gt;QStyle::PM_FocusFrameHMargin&lt;/a&gt;) to the length of the text.</source>
          <target state="translated">이 함수를 다시 구현할 때 텍스트 항목의 경우 &lt;a href=&quot;qitemdelegate&quot;&gt;QItemDelegate&lt;/a&gt; 는 텍스트 길이에 여백 (예 : 2 * &lt;a href=&quot;qstyle#PixelMetric-enum&quot;&gt;QStyle :: PM_FocusFrameHMargin&lt;/a&gt; )을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="197ccf9da55fd735f9643d4ab74a6bddeec9dfb0" translate="yes" xml:space="preserve">
          <source>When reimplementing this function, the &lt;a href=&quot;qabstractitemmodel#headerDataChanged&quot;&gt;headerDataChanged&lt;/a&gt;() signal must be emitted explicitly.</source>
          <target state="translated">이 함수를 다시 구현할 때 &lt;a href=&quot;qabstractitemmodel#headerDataChanged&quot;&gt;headerDataChanged&lt;/a&gt; () 신호가 명시 적으로 방출되어야합니다.</target>
        </trans-unit>
        <trans-unit id="89a145bd42509fd307493a0a0013f21ce6e0557c" translate="yes" xml:space="preserve">
          <source>When relative paths are specified, qmake will mangle them into a form understood by the dynamic linker to be relative to the location of the referring executable or library. This is supported only by some platforms (currently Linux and Darwin-based ones) and is detectable by checking whether &lt;a href=&quot;#qmake-rel-rpath-base&quot;&gt;QMAKE_REL_RPATH_BASE&lt;/a&gt; is set.</source>
          <target state="translated">상대 경로가 지정되면 qmake는 동적 링커가 참조 실행 파일 또는 라이브러리의 위치를 ​​기준으로 이해하는 형식으로 경로를 변환합니다. 이는 일부 플랫폼 (현재 Linux 및 Darwin 기반 플랫폼)에서만 지원되며 &lt;a href=&quot;#qmake-rel-rpath-base&quot;&gt;QMAKE_REL_RPATH_BASE의&lt;/a&gt; 설정 여부를 확인하여 감지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c2230aceb836e5f2b704deb69243134974a878df" translate="yes" xml:space="preserve">
          <source>When relative paths are specified, qmake will mangle them into a form understood by the dynamic linker to be relative to the location of the referring executable or library. This is supported only by some platforms (currently Linux and Darwin-based ones) and is detectable by checking whether &lt;a href=&quot;qmake-variable-reference#qmake-rel-rpath-base&quot;&gt;QMAKE_REL_RPATH_BASE&lt;/a&gt; is set.</source>
          <target state="translated">상대 경로가 지정되면 qmake는이를 참조 실행 파일 또는 라이브러리의 위치에 상대적인 것으로 동적 링커가 이해하는 형식으로 엉망으로 만듭니다. 이것은 일부 플랫폼 (현재 Linux 및 Darwin 기반 플랫폼)에서만 지원되며 &lt;a href=&quot;qmake-variable-reference#qmake-rel-rpath-base&quot;&gt;QMAKE_REL_RPATH_BASE&lt;/a&gt; 설정 여부를 확인하여 감지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b737ba18762f9d815ad8cc904c2c8daeaec43e4b" translate="yes" xml:space="preserve">
          <source>When rendering graphics, the matrix defines the transformations but the actual transformation is performed by the drawing routines in &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt;.</source>
          <target state="translated">그래픽을 렌더링 할 때 매트릭스는 변환을 정의하지만 실제 변환은 &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; 의 그리기 루틴에 의해 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="7c5109171a737854a9ba5a71e30fd9bd78572ca4" translate="yes" xml:space="preserve">
          <source>When rendering with a pen with an even number of pixels, the pixels will be rendered symetrically around the mathematical defined points, while rendering with a pen with an odd number of pixels, the spare pixel will be rendered to the right and below the mathematical point as in the one pixel case. See the &lt;a href=&quot;qrectf&quot;&gt;QRectF&lt;/a&gt; diagrams below for concrete examples.</source>
          <target state="translated">짝수의 픽셀을 가진 펜으로 렌더링 할 때, 픽셀은 수학적으로 정의 된 점을 중심으로 대칭 적으로 렌더링되고, 홀수의 픽셀을 가진 펜으로 렌더링 할 때, 여분의 픽셀은 수학 포인트의 오른쪽 아래로 렌더링됩니다 한 픽셀의 경우처럼. 구체적인 예는 아래 &lt;a href=&quot;qrectf&quot;&gt;QRectF&lt;/a&gt; 다이어그램을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f6bb9fd28f420249ac748ef0297e189cfdea3c23" translate="yes" xml:space="preserve">
          <source>When rendering with a two pixels wide pen the boundary line will be split in the middle by the mathematical rectangle. This will be the case whenever the pen is set to an even number of pixels, while rendering with a pen with an odd number of pixels, the spare pixel will be rendered to the right and below the mathematical rectangle as in the one pixel case.</source>
          <target state="translated">너비가 2 픽셀 인 펜으로 렌더링 할 때 경계선은 수학 사각형에 의해 가운데에서 분할됩니다. 펜이 짝수의 픽셀로 설정 될 때마다 홀수의 픽셀로 펜으로 렌더링하는 동안 여분의 픽셀은 한 픽셀의 경우와 같이 수학 사각형의 오른쪽 아래로 렌더링됩니다.</target>
        </trans-unit>
        <trans-unit id="d7e0077b12f54b280554348b8d31ed612bede88e" translate="yes" xml:space="preserve">
          <source>When rendering, &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; protects the painter state (see &lt;a href=&quot;qpainter#save&quot;&gt;QPainter::save&lt;/a&gt;()) when rendering the background or foreground, and when rendering each item. This allows you to leave the painter in an altered state (i.e., you can call &lt;a href=&quot;qpainter#setPen&quot;&gt;QPainter::setPen&lt;/a&gt;() or &lt;a href=&quot;qpainter#setBrush&quot;&gt;QPainter::setBrush&lt;/a&gt;() without restoring the state after painting). However, if the items consistently do restore the state, you should enable this flag to prevent &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; from doing the same.</source>
          <target state="translated">렌더링 할 때 &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; 는 배경 또는 전경을 렌더링 할 때와 각 항목을 렌더링 할 때 페인터 상태 ( &lt;a href=&quot;qpainter#save&quot;&gt;QPainter :: save&lt;/a&gt; () 참조)를 보호합니다 . 따라서 페인터를 변경된 상태로 &lt;a href=&quot;qpainter#setPen&quot;&gt;유지할&lt;/a&gt; 수 있습니다 (즉, 페인팅 후 상태를 복원하지 않고 QPainter :: setPen () 또는 &lt;a href=&quot;qpainter#setBrush&quot;&gt;QPainter :: setBrush&lt;/a&gt; ()를 호출 할 수 있음 ). 그러나 항목이 지속적으로 상태를 복원하는 경우 &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; 가 동일한 작업을 수행 하지 못하게하려면이 플래그를 사용으로 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="d51a24d95c26c19a346a37f3dd7e864ef01ea9d8" translate="yes" xml:space="preserve">
          <source>When rendering, Graphics View's scene coordinates correspond to &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt;'s</source>
          <target state="translated">렌더링 할 때 Graphics View의 장면 좌표는 &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; 의</target>
        </trans-unit>
        <trans-unit id="b351cd57358f6774989d1cb0e0f8f4b5f818e8c3" translate="yes" xml:space="preserve">
          <source>When requesting an index for a model item, we must provide some information about the item's parent. Outside the model, the only way to refer to an item is through a model index, so a parent model index must also be given:</source>
          <target state="translated">모델 아이템에 대한 인덱스를 요청할 때 아이템의 부모에 대한 정보를 제공해야합니다. 모델 외부에서 항목을 참조하는 유일한 방법은 모델 색인을 통하는 것이므로 상위 모델 색인도 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="e3462b37efc9ed9435b6be891fff238475c5b943" translate="yes" xml:space="preserve">
          <source>When resizeEvent() is called, the viewport already has its new geometry: Its new size is accessible through the &lt;a href=&quot;qresizeevent#size&quot;&gt;QResizeEvent::size&lt;/a&gt;() function, and the old size through &lt;a href=&quot;qresizeevent#oldSize&quot;&gt;QResizeEvent::oldSize&lt;/a&gt;().</source>
          <target state="translated">resizeEvent ()가 호출되면 뷰포트에 이미 새로운 지오메트리가 있습니다. 새로운 크기는 &lt;a href=&quot;qresizeevent#size&quot;&gt;QResizeEvent :: size&lt;/a&gt; () 함수를 통해 액세스 할 수 있고 이전 크기는 &lt;a href=&quot;qresizeevent#oldSize&quot;&gt;QResizeEvent :: oldSize&lt;/a&gt; ()를 통해 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="459145d7e5e0a2dddcfe14e374a8a522472aa332" translate="yes" xml:space="preserve">
          <source>When returning from C++, the engine will interrupt the normal flow of execution and call the the next pre-registered exception handler with an error object that contains the given</source>
          <target state="translated">C ++에서 돌아올 때 엔진은 정상적인 실행 흐름을 중단하고 주어진 다음을 포함하는 오류 객체와 함께 다음으로 사전 등록 된 예외 핸들러를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="90d305ada35629da8b28508d253830cb3271219a" translate="yes" xml:space="preserve">
          <source>When rubberband selection ends this signal will be emitted with null vales.</source>
          <target state="translated">고무 밴드 선택이 끝나면이 신호는 null vales와 함께 방출됩니다.</target>
        </trans-unit>
        <trans-unit id="d7d3ba7b84a869b7ec4d6428c30a1e381f521d40" translate="yes" xml:space="preserve">
          <source>When run in a Norwegian locale, this code could for instance display &quot;Price is kr 6,00&quot; for a one-dollar product.</source>
          <target state="translated">노르웨이어 로케일에서 실행될 때이 코드는 예를 들어 1 달러 제품에 대해 &quot;가격은 kr 6,00&quot;으로 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f4b4ea8160e44027a1643f73bd2b4fc24a630c0f" translate="yes" xml:space="preserve">
          <source>When running QDoc to generate HTML, the example above will have no effect on the generated output, but if you run QDoc to generate DITA XML, the example will generate the following:</source>
          <target state="translated">QDoc을 실행하여 HTML을 생성 할 때 위의 예제는 생성 된 출력에 영향을 미치지 않지만 QDoc을 실행하여 DITA XML을 생성하면 예제는 다음을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="313916658b849b20eb8b38c2b36d5a604ba7482c" translate="yes" xml:space="preserve">
          <source>When running QDoc to generate HTML, the example above will have no effect on the generated output.</source>
          <target state="translated">HTML을 생성하기 위해 QDoc을 실행할 때 위의 예는 생성 된 출력에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="68eca509dfd034e35a8f7fa47ec0779beae30c64" translate="yes" xml:space="preserve">
          <source>When running Qt Web Engine examples in a Docker container and browsing content-heavy sites, BUS errors (SIGBUS) might be reported. Typically, this is caused by Docker running a container with a too small memory space (such as 64MB). To fix this problem, increase the memory space size.</source>
          <target state="translated">Docker 컨테이너에서 Qt Web Engine 예제를 실행하고 콘텐츠가 많은 사이트를 검색 할 때 BUS 오류 (SIGBUS)가보고 될 수 있습니다. 일반적으로 이는 Docker가 너무 작은 메모리 공간 (예 : 64MB)이있는 컨테이너를 실행하기 때문에 발생합니다. 이 문제를 해결하려면 메모리 공간 크기를 늘리십시오.</target>
        </trans-unit>
        <trans-unit id="ba74a44a4fe513e0e864500ccf8b7805d12bdf2c" translate="yes" xml:space="preserve">
          <source>When running the advertising procedure, a number of parameters can be configured, such as how fast to advertise or which clients, if any, can connect to the advertising device. These parameters are set via this class, and their values will be used when advertising is started by calling &lt;a href=&quot;qlowenergycontroller#startAdvertising&quot;&gt;QLowEnergyController::startAdvertising&lt;/a&gt;().</source>
          <target state="translated">광고 절차를 실행할 때 광고 속도 또는 광고 장치에 연결할 수있는 클라이언트와 같은 여러 매개 변수를 구성 할 수 있습니다. 이 매개 변수는이 클래스를 통해 설정되며 &lt;a href=&quot;qlowenergycontroller#startAdvertising&quot;&gt;QLowEnergyController :: startAdvertising&lt;/a&gt; () 을 호출하여 광고가 시작될 때 해당 값이 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="1e481bcca4c1c2d1651c8ca7889240a246da99ad" translate="yes" xml:space="preserve">
          <source>When running with the OpenGL backend of Qt Quick, both the generic, triangulation-based and the NVIDIA-specific &lt;code&gt;GL_NV_path_rendering&lt;/code&gt; methods are available. By default only the generic approach is used. Setting Shape.&lt;a href=&quot;qml-qtquick-shapes-shape#vendorExtensionsEnabled-prop&quot;&gt;vendorExtensionsEnabled&lt;/a&gt; property to &lt;code&gt;true&lt;/code&gt; leads to using NV_path_rendering on NVIDIA systems when running directly on OpenGL, and the generic method on others. When OpenGL is not used directly by the scene graph, for example because it is using the graphics abstraction layer (QRhi), only the generic shape renderer is available.</source>
          <target state="translated">Qt Quick의 OpenGL 백엔드로 실행할 때 일반 삼각 측량 기반 및 NVIDIA 특정 &lt;code&gt;GL_NV_path_rendering&lt;/code&gt; 방법을 모두 사용할 수 있습니다. 기본적으로 일반 접근 방식 만 사용됩니다. 모양 설정. &lt;a href=&quot;qml-qtquick-shapes-shape#vendorExtensionsEnabled-prop&quot;&gt;vendorExtensionsEnabled&lt;/a&gt; 속성을 &lt;code&gt;true&lt;/code&gt; 로 설정하면 OpenGL에서 직접 실행할 때 NVIDIA 시스템에서 NV_path_rendering을 사용하고 다른 시스템에서는 일반 메서드를 사용합니다. OpenGL이 그래픽 추상화 레이어 (QRhi)를 사용하기 때문에 장면 그래프에서 직접 사용되지 않는 경우 일반 모양 렌더러 만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="419ca242c0e809f26e319a45853b06288d62f271" translate="yes" xml:space="preserve">
          <source>When running with the OpenGL backend of the scene graph, &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt; offers the possibility to disable persistent OpenGL contexts as well. This setting is currently ignored by &lt;a href=&quot;qquickwidget&quot;&gt;QQuickWidget&lt;/a&gt; and the context is always persistent. The OpenGL context is thus not destroyed when hiding the widget. The context is destroyed only when the widget is destroyed or when the widget gets reparented into another top-level widget's child hierarchy. However, some applications, in particular those that have their own graphics resources due to performing custom OpenGL rendering in the Qt Quick scene, may wish to disable the latter since they may not be prepared to handle the loss of the context when moving a &lt;a href=&quot;qquickwidget&quot;&gt;QQuickWidget&lt;/a&gt; into another window. Such applications can set the QCoreApplication::AA_ShareOpenGLContexts attribute. For a discussion on the details of resource initialization and cleanup, refer to the &lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt; documentation.</source>
          <target state="translated">장면 그래프의 OpenGL 백엔드로 실행할 때 &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt; 는 지속적인 OpenGL 컨텍스트를 비활성화 할 수도 있습니다. 이 설정은 현재 &lt;a href=&quot;qquickwidget&quot;&gt;QQuickWidget에&lt;/a&gt; 의해 무시되며 컨텍스트는 항상 영구적입니다. 따라서 위젯을 숨길 때 OpenGL 컨텍스트가 손상되지 않습니다. 위젯이 삭제되거나 위젯이 다른 최상위 위젯의 하위 계층 구조로 재 부착되는 경우에만 컨텍스트가 삭제됩니다. 그러나 일부 응용 프로그램, 특히 Qt Quick 장면에서 사용자 정의 OpenGL 렌더링을 수행하여 자체 그래픽 리소스가있는 응용 프로그램은 &lt;a href=&quot;qquickwidget&quot;&gt;QQuickWidget을&lt;/a&gt; 이동할 때 컨텍스트 손실을 처리 할 준비가되지 않기 때문에이를 비활성화 할 수 있습니다.다른 창으로. 이러한 애플리케이션은 QCoreApplication :: AA_ShareOpenGLContexts 속성을 설정할 수 있습니다. 자원 초기화 및 정리에 대한 자세한 내용은 &lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt; 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="31fa69229e2655989faeea8c24fbc639c55aaf43" translate="yes" xml:space="preserve">
          <source>When running with the OpenGL backend of the scene graph, &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt; offers the possibility to disable persistent OpenGL contexts as well. This setting is currently ignored by QQuickWidget and the context is always persistent. The OpenGL context is thus not destroyed when hiding the widget. The context is destroyed only when the widget is destroyed or when the widget gets reparented into another top-level widget's child hierarchy. However, some applications, in particular those that have their own graphics resources due to performing custom OpenGL rendering in the Qt Quick scene, may wish to disable the latter since they may not be prepared to handle the loss of the context when moving a QQuickWidget into another window. Such applications can set the QCoreApplication::AA_ShareOpenGLContexts attribute. For a discussion on the details of resource initialization and cleanup, refer to the &lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt; documentation.</source>
          <target state="translated">장면 그래프의 OpenGL 백엔드로 실행할 때 &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt;영구 OpenGL 컨텍스트를 비활성화 할 수도 있습니다. 이 설정은 현재 QQuickWidget에서 무시되며 컨텍스트는 항상 영구적입니다. 따라서 OpenGL 컨텍스트는 위젯을 숨길 때 파괴되지 않습니다. 컨텍스트는 위젯이 파괴되거나 위젯이 다른 최상위 위젯의 하위 계층으로 다시 부모가 될 때만 파괴됩니다. 그러나 일부 응용 프로그램, 특히 Qt Quick 장면에서 사용자 정의 OpenGL 렌더링을 수행하기 때문에 자체 그래픽 리소스가있는 응용 프로그램은 QQuickWidget을 이동할 때 컨텍스트 손실을 처리 할 준비가되어 있지 않을 수 있기 때문에 다른 창. 이러한 애플리케이션은 QCoreApplication :: AA_ShareOpenGLContexts 속성을 설정할 수 있습니다. 리소스 초기화 및 정리에 대한 자세한 내용은 다음을 참조하십시오.&lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt; 문서.</target>
        </trans-unit>
        <trans-unit id="4180cc40e3670129f26ab3b8aa7583731a04bc4b" translate="yes" xml:space="preserve">
          <source>When running with the default, OpenGL backend of Qt Quick, both the generic, triangulation-based and the NVIDIA-specific &lt;code&gt;GL_NV_path_rendering&lt;/code&gt; methods are available. By default only the generic approach is used. Setting Shape.&lt;a href=&quot;qml-qtquick-shapes-shape#vendorExtensionsEnabled-prop&quot;&gt;vendorExtensionsEnabled&lt;/a&gt; property to &lt;code&gt;true&lt;/code&gt; leads to using NV_path_rendering on NVIDIA systems, and the generic method on others.</source>
          <target state="translated">Qt Quick의 기본 OpenGL 백엔드로 실행하는 경우 일반 삼각 측량 기반 및 NVIDIA 고유 &lt;code&gt;GL_NV_path_rendering&lt;/code&gt; 방법을 모두 사용할 수 있습니다. 기본적으로 일반적인 접근 방식 만 사용됩니다. 모양 설정. &lt;a href=&quot;qml-qtquick-shapes-shape#vendorExtensionsEnabled-prop&quot;&gt;vendorExtensionsEnabled&lt;/a&gt; 속성을 &lt;code&gt;true&lt;/code&gt; 로 설정하면 NVIDIA 시스템에서 NV_path_rendering을 사용하고 다른 시스템에서는 일반적인 방법을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="22c17b7b950b81783fdb923684eedfd560adcd81" translate="yes" xml:space="preserve">
          <source>When runtime compilation is not in use and the shader properties refer to files with bytecode, the status is always Compiled. The contents of the shader is not examined (apart from basic reflection to discover vertex input elements and constant buffer data) until later in the rendering pipeline so potential errors (like layout or root signature mismatches) will only be detected at a later point.</source>
          <target state="translated">런타임 컴파일을 사용하지 않고 셰이더 속성이 바이트 코드가있는 파일을 참조하면 상태는 항상 컴파일됩니다. 셰이더의 내용은 렌더링 파이프 라인에서 나중에까지 기본 반사와 정점 입력 요소 및 상수 버퍼 데이터를 찾기 위해 검사되지 않으므로 잠재적 오류 (예 : 레이아웃 또는 루트 서명 불일치)는 나중에 만 감지됩니다.</target>
        </trans-unit>
        <trans-unit id="1cf799c203f3447ab5ee733162b36bb8365e9dec" translate="yes" xml:space="preserve">
          <source>When saving a form in</source>
          <target state="translated">양식을 저장할 때</target>
        </trans-unit>
        <trans-unit id="1e9c03991883db6f31187fbe5c35791a719629dc" translate="yes" xml:space="preserve">
          <source>When saving places between managers, there are a few things to be aware of. Some fields of a place such as the id, categories and icons are manager specific entities for example the categories in one manager may not be recognized in another. Therefore trying to save a place directly from one manager to another is not possible.</source>
          <target state="translated">관리자간에 장소를 저장할 때 알아야 할 몇 가지 사항이 있습니다. ID, 카테고리 및 아이콘과 같은 장소의 일부 필드는 관리자 별 엔티티입니다. 예를 들어 한 관리자의 카테고리는 다른 관리자에서 인식되지 않을 수 있습니다. 따라서 한 관리자에서 다른 관리자에게 직접 장소를 저장하려고 시도 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="65dee2f6abcd14dfb6ffc451b8eef9d4e59664a3" translate="yes" xml:space="preserve">
          <source>When saving places between plugins, there are a few things to be aware of. Some fields of a place such as the id, categories and icons are plugin specific entities. For example the categories in one manager may not be recognised in another. Therefore trying to save a place directly from one plugin to another is not possible.</source>
          <target state="translated">플러그인 사이에 장소를 저장할 때 알아 두어야 할 것이 몇 가지 있습니다. ID, 카테고리 및 아이콘과 같은 장소의 일부 필드는 플러그인 특정 엔티티입니다. 예를 들어 한 관리자의 범주는 다른 관리자에서 인식되지 않을 수 있습니다. 따라서 한 플러그인에서 다른 플러그인으로 직접 장소를 저장하려고 시도 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="16335d2940c0a9a4d44f0bf7877e3be7c7a4c25b" translate="yes" xml:space="preserve">
          <source>When scheduling cleanup of graphics resources using &lt;a href=&quot;qquickwindow#scheduleRenderJob&quot;&gt;QQuickWindow::scheduleRenderJob&lt;/a&gt;(), one should use either &lt;a href=&quot;qquickwindow#RenderStage-enum&quot;&gt;QQuickWindow::BeforeSynchronizingStage&lt;/a&gt; or &lt;a href=&quot;qquickwindow#RenderStage-enum&quot;&gt;QQuickWindow::AfterSynchronizingStage&lt;/a&gt;. The &lt;a href=&quot;qtquick-visualcanvas-scenegraph#scene-graph-and-rendering&quot;&gt;synchronization stage&lt;/a&gt; is where the scene graph is changed as a result of changes to the QML tree. If cleanup is scheduled at any other time, it may result in other parts of the scene graph referencing the newly deleted objects as these parts have not been updated.</source>
          <target state="translated">&lt;a href=&quot;qquickwindow#scheduleRenderJob&quot;&gt;QQuickWindow :: scheduleRenderJob&lt;/a&gt; ()을 사용하여 그래픽 리소스 정리를 예약 할 때는 &lt;a href=&quot;qquickwindow#RenderStage-enum&quot;&gt;QQuickWindow :: BeBeSynchronizingStage&lt;/a&gt; 또는 &lt;a href=&quot;qquickwindow#RenderStage-enum&quot;&gt;QQuickWindow :: AfterSynchronizingStage를 사용해야&lt;/a&gt; 합니다. &lt;a href=&quot;qtquick-visualcanvas-scenegraph#scene-graph-and-rendering&quot;&gt;동기화 단계는&lt;/a&gt; 상기 장면 그래프는 QML 트리의 변경으로 인해 변경되는 경우이다. 정리가 다른 시간에 예약되면 장면 그래프의 다른 부분이 업데이트되지 않았으므로 새로 삭제 된 객체를 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0470cdb483508ebc7b70959dbd94540db4bc9c18" translate="yes" xml:space="preserve">
          <source>When sections are used, the first section command should be &lt;code&gt;section1&lt;/code&gt;.</source>
          <target state="translated">섹션을 사용할 때 첫 번째 섹션 명령은 &lt;code&gt;section1&lt;/code&gt; 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="f5eedde8058556feb6cb3beeca59e7888ae6ece9" translate="yes" xml:space="preserve">
          <source>When selection is changed by clicking on the graph</source>
          <target state="translated">그래프를 클릭하여 선택을 변경 한 경우</target>
        </trans-unit>
        <trans-unit id="00867511fe8868752b9e077a7707775ae9c1971d" translate="yes" xml:space="preserve">
          <source>When selection is changed explicitly via series API to a visible item</source>
          <target state="translated">선택 사항이 시리즈 API를 통해 명시 적으로 표시되는 항목으로 변경되는 경우</target>
        </trans-unit>
        <trans-unit id="2e1af7d1ebff8ce0a52ad99867add45c86a6ae89" translate="yes" xml:space="preserve">
          <source>When sending CAN FD frames, this flag is automatically set by the CAN FD hardware. &lt;code&gt;QCanBusFrame::setErrorStateIndicator()&lt;/code&gt; should only be used for application testing, e.g. on virtual CAN FD busses.</source>
          <target state="translated">CAN FD 프레임을 전송할 때이 플래그는 CAN FD 하드웨어에 의해 자동으로 설정됩니다. &lt;code&gt;QCanBusFrame::setErrorStateIndicator()&lt;/code&gt; 는 어플리케이션 테스트 (예 : 가상 CAN FD 버스 ) 에만 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="357729db045ad04ca40ebade91b854125d77106d" translate="yes" xml:space="preserve">
          <source>When sending CAN bus frames with &lt;a href=&quot;qcanbusdevice#ConfigurationKey-enum&quot;&gt;QCanBusDevice::ReceiveOwnKey&lt;/a&gt; enabled, all successfully sent frames are echoed to the receive queue and marked as local echo frames. &lt;code&gt;QCanBusFrame::setLocalEcho&lt;/code&gt; should therefore only be used for application testing, e.g. on virtual CAN busses.</source>
          <target state="translated">&lt;a href=&quot;qcanbusdevice#ConfigurationKey-enum&quot;&gt;QCanBusDevice :: ReceiveOwnKey가&lt;/a&gt; 활성화 된 상태에서 CAN 버스 프레임을 전송하면 성공적으로 전송 된 모든 프레임이 수신 큐에 에코되고 로컬 에코 프레임으로 표시됩니다. 따라서 &lt;code&gt;QCanBusFrame::setLocalEcho&lt;/code&gt; 는 애플리케이션 테스트 (예 : 가상 CAN 버스)에만 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="8bae5e50b5bdda4bb33ef7b2b1936a5c7112c234" translate="yes" xml:space="preserve">
          <source>When sending requests, to control the preference of when to use the cache and when to use the network, consider the following:</source>
          <target state="translated">요청을 보낼 때 캐시 사용시기 및 네트워크 사용시기에 대한 기본 설정을 제어하려면 다음을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="73e7c0c4bd2ed4ad850a956107fc733151db2cb3" translate="yes" xml:space="preserve">
          <source>When sending, the &lt;a href=&quot;qnetworkdatagram#senderAddress&quot;&gt;senderAddress&lt;/a&gt;() and &lt;a href=&quot;qnetworkdatagram#senderPort&quot;&gt;senderPort&lt;/a&gt;() should contain the local address to be used when sending. The sender address must be an address that is assigned to this machine, which can be obtained using &lt;a href=&quot;qnetworkinterface&quot;&gt;QNetworkInterface&lt;/a&gt;, and the port number must be the port number that the socket is bound to. Either field can be left unset and will be filled in by the operating system with default values. The &lt;a href=&quot;qnetworkdatagram#destinationAddress&quot;&gt;destinationAddress&lt;/a&gt;() and &lt;a href=&quot;qnetworkdatagram#destinationPort&quot;&gt;destinationPort&lt;/a&gt;() fields may be set to a target address different from the one the UDP socket is currently associated with.</source>
          <target state="translated">송신시 &lt;a href=&quot;qnetworkdatagram#senderAddress&quot;&gt;senderAddress&lt;/a&gt; () 및 &lt;a href=&quot;qnetworkdatagram#senderPort&quot;&gt;senderPort&lt;/a&gt; ()에는 송신시 사용될 로컬 주소가 포함되어야합니다. 송신자 주소는 &lt;a href=&quot;qnetworkinterface&quot;&gt;QNetworkInterface&lt;/a&gt; 를 사용하여 얻을 수있는이 기계에 지정된 주소 여야하며 포트 번호는 소켓이 바인드 된 포트 번호 여야합니다. 필드는 설정하지 않은 상태로 둘 수 있으며 운영 체제가 기본값으로 채 웁니다. &lt;a href=&quot;qnetworkdatagram#destinationAddress&quot;&gt;destinationAddress&lt;/a&gt; () 및 &lt;a href=&quot;qnetworkdatagram#destinationPort&quot;&gt;destinationPort&lt;/a&gt; () 필드는 UDP 소켓 현재 연결된 하나로부터 타겟 어드레스 가지로 설정 될 수있다.</target>
        </trans-unit>
        <trans-unit id="bbc34b6972fd5a95f0e17a1bedd0814ddeba5170" translate="yes" xml:space="preserve">
          <source>When serialized item data is dropped onto a view, the data is inserted into the current model using its implementation of &lt;a href=&quot;qabstractitemmodel#dropMimeData&quot;&gt;QAbstractItemModel::dropMimeData&lt;/a&gt;(). The default implementation of this function will never overwrite any data in the model; instead, it tries to insert the items of data either as siblings of an item, or as children of that item.</source>
          <target state="translated">직렬화 된 항목 데이터가 뷰에 삭제되면 &lt;a href=&quot;qabstractitemmodel#dropMimeData&quot;&gt;QAbstractItemModel :: dropMimeData&lt;/a&gt; () 의 구현을 사용하여 데이터가 현재 모델에 삽입됩니다 . 이 함수의 기본 구현은 모델의 데이터를 덮어 쓰지 않습니다. 대신 데이터의 항목을 항목의 형제 또는 해당 항목의 하위 항목으로 삽입하려고합니다.</target>
        </trans-unit>
        <trans-unit id="beb64bc37ef9e620c83f8575bbe6997166c3df77" translate="yes" xml:space="preserve">
          <source>When set on the characterFormat of a selection, the whole width of the text will be shown selected.</source>
          <target state="translated">선택의 characterFormat에 설정하면 텍스트의 전체 너비가 선택된 것으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="270afeac1ae23334323cbd52bdb23f45e70ed478" translate="yes" xml:space="preserve">
          <source>When set to &lt;a href=&quot;qsensor#AxesOrientationMode-enum&quot;&gt;AutomaticOrientation&lt;/a&gt;, the reading values are automatically rotated when the screen orientation changes. In effect, the screen orientation is canceled out.</source>
          <target state="translated">&lt;a href=&quot;qsensor#AxesOrientationMode-enum&quot;&gt;AutomaticOrientation으로&lt;/a&gt; 설정 하면 화면 방향이 변경 될 때 판독 값이 자동으로 회전합니다. 실제로 화면 방향이 취소됩니다.</target>
        </trans-unit>
        <trans-unit id="e194e2df3cef00cb337af8c19d0b1fb4566ff905" translate="yes" xml:space="preserve">
          <source>When set to &lt;a href=&quot;qsensor#AxesOrientationMode-enum&quot;&gt;FixedOrientation&lt;/a&gt;, which is the default mode, no automatic rotation is applied to the reading. This is the only mode available for backends that do not support the &lt;a href=&quot;qsensor#Feature-enum&quot;&gt;QSensor::AxesOrientation&lt;/a&gt; feature.</source>
          <target state="translated">기본 모드 인 &lt;a href=&quot;qsensor#AxesOrientationMode-enum&quot;&gt;FixedOrientation으로&lt;/a&gt; 설정 하면 판독 값에 자동 회전이 적용되지 않습니다. &lt;a href=&quot;qsensor#Feature-enum&quot;&gt;QSensor :: AxesOrientation&lt;/a&gt; 기능을 지원하지 않는 백엔드에 사용할 수있는 유일한 모드 입니다.</target>
        </trans-unit>
        <trans-unit id="f8c2be01f19679d844258975f1b00add910e8c48" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;1&lt;/code&gt;, Qt grabs the device for exclusive use.</source>
          <target state="translated">&lt;code&gt;1&lt;/code&gt; 로 설정되면 Qt는 독점 사용을 위해 장치를 잡습니다.</target>
        </trans-unit>
        <trans-unit id="35fbd74909144bf9e11c35c0ff6fab64956af13b" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;false&lt;/code&gt;, rendering is done in single pass. In this mode the depth buffer is not used at all, and all objects are rendered in a single back to front pass.</source>
          <target state="translated">&lt;code&gt;false&lt;/code&gt; 로 설정하면 렌더링이 단일 패스로 수행됩니다. 이 모드에서는 깊이 버퍼가 전혀 사용되지 않으며 모든 오브젝트가 단일 백 투 프론트 패스로 렌더링됩니다.</target>
        </trans-unit>
        <trans-unit id="f1c4e86e296a0003f811fe8398c8194c0172e276" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;transparent&lt;/code&gt;, no filling occurs.</source>
          <target state="translated">&lt;code&gt;transparent&lt;/code&gt; 로 설정하면 충전이 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a494091a2d78c1c83239a6f4b1f78cd17e064c58" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;transparent&lt;/code&gt;, no stroking occurs.</source>
          <target state="translated">&lt;code&gt;transparent&lt;/code&gt; 로 설정하면 쓰 로킹이 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d01263f2091d195480c96c2d03450e33391dffb1" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;true&lt;/code&gt;, the exterior of the item is padded with a 1 pixel wide transparent edge, making sampling outside the source texture use transparency instead of the edge pixels. Without this property, an image which has opaque edges will not get a blurred shadow.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 로 설정 하면 항목 외부에 1 픽셀 너비의 투명 가장자리가 채워져 소스 텍스처 외부의 샘플링에 가장자리 픽셀 대신 투명도가 사용됩니다. 이 속성이 없으면 가장자리가 불투명 한 이미지에 그림자가 흐려지지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b450467a36089b6e8cc7c9384688033053a7e1e0" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;true&lt;/code&gt;, the exterior of the item is padded with a transparent edge, making sampling outside the source texture use transparency instead of the edge pixels. Without this property, an image which has opaque edges will not get a blurred edge.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 로 설정 하면 항목 외부에 투명한 가장자리가 채워 지므로 소스 텍스처 외부에서 샘플링 할 때 가장자리 픽셀 대신 투명도가 사용됩니다. 이 속성이 없으면 가장자리가 불투명 한 이미지는 가장자리가 흐려지지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e4147d132167beace31a7c2f2898d532610dfada" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;true&lt;/code&gt;, the mapping ignores any explicitly set column categories and overwrites them with automatically generated ones whenever the data from model is resolved. Defaults to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 로 설정되면 매핑은 명시 적으로 설정된 열 범주를 무시하고 모델의 데이터가 분석 될 때마다 자동으로 생성 된 열 범주로 덮어 씁니다. 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="36e27ee6dcb20f63a267c063b5f0dd2344ea8112" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;true&lt;/code&gt;, the mapping ignores any explicitly set column categories and overwrites them with automatically generated ones whenever the data from the model is resolved. Defaults to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 로 설정되면 매핑은 명시 적으로 설정된 열 범주를 무시하고 모델의 데이터가 분석 될 때마다 자동으로 생성 된 열 범주로 덮어 씁니다. 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="aeaf1add3a3c03b3752ea390e4de636b57ce02e7" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;true&lt;/code&gt;, the mapping ignores any explicitly set column categories and overwrites them with automatically generated ones whenever the data from the model is resolved. Proxy minimum and maximum column values are also autogenerated from the data when this is set to &lt;code&gt;true&lt;/code&gt;. Defaults to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 로 설정되면 매핑은 명시 적으로 설정된 열 범주를 무시하고 모델의 데이터가 분석 될 때마다 자동으로 생성 된 열 범주로 덮어 씁니다. 이 값이 &lt;code&gt;true&lt;/code&gt; 로 설정되면 프록시 최소 및 최대 열 값도 데이터에서 자동 생성됩니다 . 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c86619e8213d5bed1738d02c582750355d6522a4" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;true&lt;/code&gt;, the mapping ignores any explicitly set row categories and overwrites them with automatically generated ones whenever the data from model is resolved. Defaults to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 로 설정되면 맵핑은 명시 적으로 설정된 행 카테고리를 무시하고 모델의 데이터가 분석 될 때마다 자동으로 생성 된 카테고리를 겹쳐 씁니다. 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d11c86fa7ccfd6ba9e683cd50f0c094403577ac1" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;true&lt;/code&gt;, the mapping ignores any explicitly set row categories and overwrites them with automatically generated ones whenever the data from the model is resolved. Defaults to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 로 설정되면 맵핑은 명시 적으로 설정된 행 카테고리를 무시하고 모델의 데이터가 분석 될 때마다 자동으로 생성 된 카테고리를 겹쳐 씁니다. 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1301757ff1650814b570b349ec4348010d05817d" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;true&lt;/code&gt;, the mapping ignores any explicitly set row categories and overwrites them with automatically generated ones whenever the data from the model is resolved. Proxy minimum and maximum row values are also autogenerated from the data when this is set to &lt;code&gt;true&lt;/code&gt;. Defaults to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 로 설정되면 맵핑은 명시 적으로 설정된 행 카테고리를 무시하고 모델의 데이터가 분석 될 때마다 자동으로 생성 된 카테고리를 겹쳐 씁니다. 이 값이 &lt;code&gt;true&lt;/code&gt; 로 설정되면 프록시 최소 및 최대 행 값도 데이터에서 자동 생성됩니다 . 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7acc0959296f9d8e8c2e2b6cb1d3a66719167a16" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;true&lt;/code&gt;, the mapping ignores row and column roles and categories, and uses the rows and columns from the model instead. Defaults to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 로 설정되면 매핑은 행 및 열 역할 및 범주를 무시하고 대신 모델의 행 및 열을 사용합니다. 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5f951719e1af643c50c67762d555cf0e850cebdd" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;true&lt;/code&gt;, the mapping ignores row and column roles and categories, and uses the rows and columns from the model instead. Row and column headers are used for row and column labels. Defaults to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 로 설정되면 매핑은 행 및 열 역할 및 범주를 무시하고 대신 모델의 행 및 열을 사용합니다. 행 및 열 머리글은 행 및 열 레이블에 사용됩니다. 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3496a774f53b66ac5b73d84b633a1d9d7d924d85" translate="yes" xml:space="preserve">
          <source>When set to a negative value, no stroking occurs.</source>
          <target state="translated">음수 값으로 설정하면 스트로크가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4e4ee14f2ec2d88c31367b1d93f593e8267881e4" translate="yes" xml:space="preserve">
          <source>When set to an empty string, the default label of the underlying platform is used. The default label is typically &lt;b&gt;Cancel&lt;/b&gt;.</source>
          <target state="translated">빈 문자열로 설정하면 기본 플랫폼의 기본 레이블이 사용됩니다. 기본 레이블은 일반적으로 &lt;b&gt;취소&lt;/b&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="71b7a30cacf1f3a3ee6a4172e8fb4bd21a402ed0" translate="yes" xml:space="preserve">
          <source>When set to an empty string, the default label of the underlying platform is used. The default label is typically &lt;b&gt;Open&lt;/b&gt; or &lt;b&gt;Save&lt;/b&gt; depending on which &lt;a href=&quot;qml-qt-labs-platform-filedialog#fileMode-prop&quot;&gt;fileMode&lt;/a&gt; the dialog is used in.</source>
          <target state="translated">빈 문자열로 설정하면 기본 플랫폼의 기본 레이블이 사용됩니다. 기본 레이블은 일반적으로 &lt;b&gt;열기&lt;/b&gt; 또는 &lt;b&gt;저장&lt;/b&gt; 에 따라 &lt;a href=&quot;qml-qt-labs-platform-filedialog#fileMode-prop&quot;&gt;대한 fileMode&lt;/a&gt; 대화 상자가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="fa9215824a888cc448b2b5104b3e0edb6ca3f827" translate="yes" xml:space="preserve">
          <source>When set to an empty string, the default label of the underlying platform is used. The default label is typically &lt;b&gt;Open&lt;/b&gt;.</source>
          <target state="translated">빈 문자열로 설정하면 기본 플랫폼의 기본 레이블이 사용됩니다. 기본 레이블은 일반적으로 &lt;b&gt;Open&lt;/b&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="da31d475a6141d1527e3930e3b780117133be781" translate="yes" xml:space="preserve">
          <source>When set to true, a connection is made to the server with the given url. When set to false, the connection is closed. The default value is false.</source>
          <target state="translated">true로 설정하면 지정된 URL을 사용하여 서버에 연결됩니다. false로 설정하면 연결이 닫힙니다. 기본값은 false입니다.</target>
        </trans-unit>
        <trans-unit id="d356d95380e0a7be709c939454d729283fff95fe" translate="yes" xml:space="preserve">
          <source>When set to true, updates are blocked and remote clients will not be notified about property changes.</source>
          <target state="translated">true로 설정하면 업데이트가 차단되고 속성 변경에 대한 원격 클라이언트에 알림이 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9070c24af14ff16b55ce450d03070776a1d63544" translate="yes" xml:space="preserve">
          <source>When set, &lt;a href=&quot;qml-qtquick-shapes-shapepath&quot;&gt;ShapePath&lt;/a&gt;.&lt;a href=&quot;qml-qtquick-shapes-shapepath#fillColor-prop&quot;&gt;fillColor&lt;/a&gt; is ignored and filling is done using one of the &lt;a href=&quot;qml-qtquick-shapes-shapegradient&quot;&gt;ShapeGradient&lt;/a&gt; subtypes.</source>
          <target state="translated">설정하면 &lt;a href=&quot;qml-qtquick-shapes-shapepath&quot;&gt;ShapePath&lt;/a&gt; 입니다. &lt;a href=&quot;qml-qtquick-shapes-shapepath#fillColor-prop&quot;&gt;fillColor&lt;/a&gt; 는 무시되고 &lt;a href=&quot;qml-qtquick-shapes-shapegradient&quot;&gt;ShapeGradient&lt;/a&gt; 하위 유형 중 하나를 사용하여 채우기가 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="1d5a93253ef1915d6faa59a1fad7ff2aba883814" translate="yes" xml:space="preserve">
          <source>When set, &lt;code&gt;eglfs&lt;/code&gt; requests &lt;code&gt;FBIO_WAITFORVSYNC&lt;/code&gt; on the framebuffer device after each call to eglSwapBuffers(). This variable is only relevant for backends relying on the legacy Linux &lt;code&gt;fbdev&lt;/code&gt; subsystem. Normally, with a default swap interval of 1, Qt assumes that calling eglSwapBuffers() takes care of vsync; if it doesn't (for example, due to driver bugs), try setting &lt;code&gt;QT_QPA_EGLFS_FORCEVSYNC&lt;/code&gt; to a non-zero value.</source>
          <target state="translated">세트 때 &lt;code&gt;eglfs&lt;/code&gt; 가 요청 &lt;code&gt;FBIO_WAITFORVSYNC&lt;/code&gt; 을 eglSwapBuffers 각 호출 이후 프레임 버퍼 장치 (). 이 변수는 레거시 Linux &lt;code&gt;fbdev&lt;/code&gt; 하위 시스템 에 의존하는 백엔드에만 해당됩니다 . 일반적으로 기본 스왑 간격이 1 인 Qt는 eglSwapBuffers () 호출이 vsync를 처리한다고 가정합니다. 그렇지 않은 경우 (예를 들어 드라이버 버그로 인해) &lt;code&gt;QT_QPA_EGLFS_FORCEVSYNC&lt;/code&gt; 를 0이 아닌 값으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="9744299b5e8df688636dffff69d9ac6cfe828468" translate="yes" xml:space="preserve">
          <source>When set, a search and replace is done on the value mapped by column role before it is used as a column category. This property specifies the regular expression to find the portion of the mapped value to replace and &lt;a href=&quot;qml-qtdatavisualization-itemmodelbardataproxy#columnRoleReplace-prop&quot;&gt;columnRoleReplace&lt;/a&gt; property contains the replacement string. This is useful for example in parsing row and column categories from a single timestamp field in the item model.</source>
          <target state="translated">설정되면, 검색 및 바꾸기는 열 카테고리로 사용되기 전에 열 역할에 의해 맵핑 된 값에 대해 수행됩니다. 이 특성은 대체 할 맵핑 된 값의 부분을 찾기 위해 정규식을 지정하고 &lt;a href=&quot;qml-qtdatavisualization-itemmodelbardataproxy#columnRoleReplace-prop&quot;&gt;columnRoleReplace&lt;/a&gt; 특성은 대체 문자열을 포함합니다. 예를 들어 항목 모델의 단일 타임 스탬프 필드에서 행 및 열 범주를 구문 분석 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="8a131bdf52627ee3b863efe9743b906a421ee8f9" translate="yes" xml:space="preserve">
          <source>When set, a search and replace is done on the value mapped by rotation role before it is used as a bar rotation angle. This property specifies the regular expression to find the portion of the mapped value to replace and &lt;a href=&quot;qml-qtdatavisualization-itemmodelbardataproxy#rotationRoleReplace-prop&quot;&gt;rotationRoleReplace&lt;/a&gt; property contains the replacement string.</source>
          <target state="translated">설정된 경우 검색 및 바꾸기는 회전 각도로 매핑되기 전에 회전 역할로 매핑 된 값에서 수행됩니다. 이 속성은 대체 할 매핑 된 값 부분을 찾기 위해 정규식을 지정하고 &lt;a href=&quot;qml-qtdatavisualization-itemmodelbardataproxy#rotationRoleReplace-prop&quot;&gt;rotationRoleReplace&lt;/a&gt; 속성에는 대체 문자열이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="9108433232a1c54c0f0add6d2c59552f382b7483" translate="yes" xml:space="preserve">
          <source>When set, a search and replace is done on the value mapped by row role before it is used as a row category. This property specifies the regular expression to find the portion of the mapped value to replace and &lt;a href=&quot;qml-qtdatavisualization-itemmodelbardataproxy#rowRoleReplace-prop&quot;&gt;rowRoleReplace&lt;/a&gt; property contains the replacement string. This is useful for example in parsing row and column categories from a single timestamp field in the item model.</source>
          <target state="translated">설정되면, 검색 및 바꾸기는 행 카테고리로 사용되기 전에 행 역할로 맵핑 된 값에서 수행됩니다. 이 특성은 대체 할 맵핑 된 값의 부분을 찾기 위해 정규식을 지정하고 &lt;a href=&quot;qml-qtdatavisualization-itemmodelbardataproxy#rowRoleReplace-prop&quot;&gt;rowRoleReplace&lt;/a&gt; 특성은 대체 문자열을 포함합니다. 예를 들어 항목 모델의 단일 타임 스탬프 필드에서 행 및 열 범주를 구문 분석 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="bc9c1cbcb787214aaefb29b1ef7ac7fde2064a50" translate="yes" xml:space="preserve">
          <source>When set, a search and replace is done on the value mapped by the column role before it is used as a column category. This property specifies the regular expression to find the portion of the mapped value to replace and the &lt;a href=&quot;qml-qtdatavisualization-itemmodelsurfacedataproxy#columnRoleReplace-prop&quot;&gt;columnRoleReplace&lt;/a&gt; property contains the replacement string.</source>
          <target state="translated">설정되면 검색 및 바꾸기는 열 카테고리로 사용되기 전에 열 역할에 의해 맵핑 된 값에서 수행됩니다. 이 특성은 대체 할 맵핑 된 값의 부분을 찾기 위해 정규식을 지정하고 &lt;a href=&quot;qml-qtdatavisualization-itemmodelsurfacedataproxy#columnRoleReplace-prop&quot;&gt;columnRoleReplace&lt;/a&gt; 특성은 대체 문자열을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="6c6f75996ea55b81eb144da97f4ddbf1f7b8d2df" translate="yes" xml:space="preserve">
          <source>When set, a search and replace is done on the value mapped by the rotation role before it is used as item rotation. This property specifies the regular expression to find the portion of the mapped value to replace and &lt;a href=&quot;qml-qtdatavisualization-itemmodelscatterdataproxy#rotationRoleReplace-prop&quot;&gt;rotationRoleReplace&lt;/a&gt; property contains the replacement string.</source>
          <target state="translated">설정되면 검색 및 바꾸기는 항목 회전으로 사용되기 전에 회전 역할에 의해 매핑 된 값에서 수행됩니다. 이 속성은 대체 할 매핑 된 값 부분을 찾기 위해 정규식을 지정하고 &lt;a href=&quot;qml-qtdatavisualization-itemmodelscatterdataproxy#rotationRoleReplace-prop&quot;&gt;rotationRoleReplace&lt;/a&gt; 속성에는 대체 문자열이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="4d7bce4ff7100e6fa830173aafe199aab62b818f" translate="yes" xml:space="preserve">
          <source>When set, a search and replace is done on the value mapped by the row role before it is used as a row category. This property specifies the regular expression to find the portion of the mapped value to replace and the &lt;a href=&quot;qml-qtdatavisualization-itemmodelsurfacedataproxy#rowRoleReplace-prop&quot;&gt;rowRoleReplace&lt;/a&gt; property contains the replacement string.</source>
          <target state="translated">설정되면 행 범주로 사용되기 전에 행 역할에 의해 맵핑 된 값에 대해 검색 및 바꾸기가 수행됩니다. 이 특성은 대체 할 맵핑 된 값의 부분을 찾기 위해 정규식을 지정하고 &lt;a href=&quot;qml-qtdatavisualization-itemmodelsurfacedataproxy#rowRoleReplace-prop&quot;&gt;rowRoleReplace&lt;/a&gt; 특성은 대체 문자열을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="885cf3aa8085356e119ac0af240743c4239afe83" translate="yes" xml:space="preserve">
          <source>When set, a search and replace is done on the value mapped by the x position role before it is used as an item position value. This property specifies the regular expression to find the portion of the mapped value to replace and &lt;a href=&quot;qml-qtdatavisualization-itemmodelscatterdataproxy#xPosRoleReplace-prop&quot;&gt;xPosRoleReplace&lt;/a&gt; property contains the replacement string.</source>
          <target state="translated">설정되면 x 위치 역할에 의해 맵핑 된 값에서 항목 위치 값으로 사용되기 전에 검색 및 바꾸기가 수행됩니다. 이 특성은 대체 할 맵핑 된 값의 부분을 찾기 위해 정규식을 지정하고 &lt;a href=&quot;qml-qtdatavisualization-itemmodelscatterdataproxy#xPosRoleReplace-prop&quot;&gt;xPosRoleReplace&lt;/a&gt; 특성은 대체 문자열을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="66303afda7fe28b42306b119120f8c9d8ffe13b2" translate="yes" xml:space="preserve">
          <source>When set, a search and replace is done on the value mapped by the x position role before it is used as an item position value. This property specifies the regular expression to find the portion of the mapped value to replace and the &lt;a href=&quot;qml-qtdatavisualization-itemmodelsurfacedataproxy#xPosRoleReplace-prop&quot;&gt;xPosRoleReplace&lt;/a&gt; property contains the replacement string.</source>
          <target state="translated">설정되면 x 위치 역할에 의해 맵핑 된 값에서 항목 위치 값으로 사용되기 전에 검색 및 바꾸기가 수행됩니다. 이 특성은 대체 할 맵핑 된 값의 부분을 찾기 위해 정규식을 지정하고 &lt;a href=&quot;qml-qtdatavisualization-itemmodelsurfacedataproxy#xPosRoleReplace-prop&quot;&gt;xPosRoleReplace&lt;/a&gt; 특성은 대체 문자열을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="177b7625ed57441e9caab15b1ba52de1056c1697" translate="yes" xml:space="preserve">
          <source>When set, a search and replace is done on the value mapped by the y position role before it is used as an item position value. This property specifies the regular expression to find the portion of the mapped value to replace and &lt;a href=&quot;qml-qtdatavisualization-itemmodelscatterdataproxy#yPosRoleReplace-prop&quot;&gt;yPosRoleReplace&lt;/a&gt; property contains the replacement string.</source>
          <target state="translated">설정되면, 검색 및 바꾸기는 항목 위치 값으로 사용되기 전에 y 위치 역할에 의해 맵핑 된 값에서 수행됩니다. 이 특성은 대체 할 맵핑 된 값의 부분을 찾기 위해 정규식을 지정하고 &lt;a href=&quot;qml-qtdatavisualization-itemmodelscatterdataproxy#yPosRoleReplace-prop&quot;&gt;yPosRoleReplace&lt;/a&gt; 특성은 대체 문자열을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="4cd4628ea893e9ef8db7b0e103b8b8eb84582ee7" translate="yes" xml:space="preserve">
          <source>When set, a search and replace is done on the value mapped by the y position role before it is used as an item position value. This property specifies the regular expression to find the portion of the mapped value to replace and the &lt;a href=&quot;qml-qtdatavisualization-itemmodelsurfacedataproxy#yPosRoleReplace-prop&quot;&gt;yPosRoleReplace&lt;/a&gt; property contains the replacement string.</source>
          <target state="translated">설정되면, 검색 및 바꾸기는 항목 위치 값으로 사용되기 전에 y 위치 역할에 의해 맵핑 된 값에서 수행됩니다. 이 특성은 대체 할 맵핑 된 값의 부분과 &lt;a href=&quot;qml-qtdatavisualization-itemmodelsurfacedataproxy#yPosRoleReplace-prop&quot;&gt;yPosRoleReplace&lt;/a&gt; 를 찾기위한 정규식을 지정합니다. 특성은 대체 문자열을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="e690058b1d8c0f0ea729f77975b58803689a29ce" translate="yes" xml:space="preserve">
          <source>When set, a search and replace is done on the value mapped by the z position role before it is used as an item position value. This property specifies the regular expression to find the portion of the mapped value to replace and &lt;a href=&quot;qml-qtdatavisualization-itemmodelscatterdataproxy#zPosRoleReplace-prop&quot;&gt;zPosRoleReplace&lt;/a&gt; property contains the replacement string.</source>
          <target state="translated">설정되면, 검색 및 바꾸기는 항목 위치 값으로 사용되기 전에 z 위치 역할에 의해 맵핑 된 값에서 수행됩니다. 이 특성은 대체 할 맵핑 된 값의 부분을 찾기 위해 정규식을 지정하고 &lt;a href=&quot;qml-qtdatavisualization-itemmodelscatterdataproxy#zPosRoleReplace-prop&quot;&gt;zPosRoleReplace&lt;/a&gt; 특성은 대체 문자열을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="8a50a48a136eb418621caa5d9975fa8698821525" translate="yes" xml:space="preserve">
          <source>When set, a search and replace is done on the value mapped by the z position role before it is used as an item position value. This property specifies the regular expression to find the portion of the mapped value to replace and the &lt;a href=&quot;qml-qtdatavisualization-itemmodelsurfacedataproxy#zPosRoleReplace-prop&quot;&gt;zPosRoleReplace&lt;/a&gt; property contains the replacement string.</source>
          <target state="translated">설정되면, 검색 및 바꾸기는 z 위치 역할이 맵핑 한 값에서 항목 위치 값으로 사용되기 전에 수행됩니다. 이 특성은 대체 할 맵핑 된 값의 부분을 찾기 위해 정규식을 지정하고 &lt;a href=&quot;qml-qtdatavisualization-itemmodelsurfacedataproxy#zPosRoleReplace-prop&quot;&gt;zPosRoleReplace&lt;/a&gt; 특성은 대체 문자열을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="9e6e26fa69d41d9769f5fde960eb52cd2c8473db" translate="yes" xml:space="preserve">
          <source>When set, a search and replace is done on the value mapped by value role before it is used as a bar value. This property specifies the regular expression to find the portion of the mapped value to replace and &lt;a href=&quot;qml-qtdatavisualization-itemmodelbardataproxy#valueRoleReplace-prop&quot;&gt;valueRoleReplace&lt;/a&gt; property contains the replacement string.</source>
          <target state="translated">설정된 경우 검색 및 바꾸기는 막대 값으로 사용되기 전에 값 역할에 의해 매핑 된 값에서 수행됩니다. 이 특성은 대체 할 맵핑 된 값의 부분을 찾기 위해 정규식을 지정하고 &lt;a href=&quot;qml-qtdatavisualization-itemmodelbardataproxy#valueRoleReplace-prop&quot;&gt;valueRoleReplace&lt;/a&gt; 특성은 대체 문자열을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="57e671691d58c18370650113c81b9894428ab1c0" translate="yes" xml:space="preserve">
          <source>When set, some debugging information is printed on the debug output. For example, the input &lt;a href=&quot;qsurfaceformat&quot;&gt;QSurfaceFormat&lt;/a&gt; and the properties of the chosen EGL configuration are printed while creating a new context. When used together with Qt Quick's &lt;code&gt;QSG_INFO&lt;/code&gt; variable, you can get useful information for troubleshooting issues related to the EGL configuration.</source>
          <target state="translated">설정하면 일부 디버깅 정보가 디버그 출력에 인쇄됩니다. 예를 들어, 새 컨텍스트를 작성하는 동안 입력 &lt;a href=&quot;qsurfaceformat&quot;&gt;QSurfaceFormat&lt;/a&gt; 및 선택한 EGL 구성의 특성이 인쇄됩니다. Qt Quick의 &lt;code&gt;QSG_INFO&lt;/code&gt; 변수 와 함께 사용 하면 EGL 구성과 관련된 문제 해결에 유용한 정보를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c63ec68c079a9bce145854c06f681928a4a99fb9" translate="yes" xml:space="preserve">
          <source>When set, the red, green, and blue color channel sizes are ignored when &lt;code&gt;eglfs&lt;/code&gt; creates a new context, window or offscreen surface. Instead, the plugin requests a configuration with 8 bits per channel. This can be helpful on devices where configurations with less than 32 or 24 bits per pixel (for example, 5-6-5 or 4-4-4) are chosen by default despite knowing they are not ideal, for example, due to banding effects. Instead of changing application code, this variable provides a shortcut to force 24 or 32 bpp configurations.</source>
          <target state="translated">설정하면 &lt;code&gt;eglfs&lt;/code&gt; 가 새로운 컨텍스트, 창 또는 화면 외부 표면을 만들 때 빨강, 녹색 및 파랑 채널 크기가 무시됩니다 . 대신, 플러그인은 채널당 8 비트로 구성을 요청합니다. 이는 예를 들어 밴딩으로 인해 이상적이지 않다는 사실에도 불구하고 픽셀 당 32 또는 24 비트 미만의 구성 (예 : 5-6-5 또는 4-4-4)을 선택하는 장치에서 유용 할 수 있습니다. 효과. 응용 프로그램 코드를 변경하는 대신이 변수는 24 또는 32bpp 구성을 강제 실행하는 바로 가기를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="33b3bd9431a5daf3aec6eea2743d997f576dc8d8" translate="yes" xml:space="preserve">
          <source>When setting &lt;a href=&quot;qml-qtquick-item#clip-prop&quot;&gt;Item::clip&lt;/a&gt; to true, it will create a &lt;a href=&quot;qsgclipnode&quot;&gt;QSGClipNode&lt;/a&gt; with a rectangle in its geometry. The default renderer will apply this clip by using scissoring in OpenGL. If the item is rotated by a non-90-degree angle, the OpenGL's stencil buffer is used. Qt Quick Item only supports setting a rectangle as clip through QML, but the scene graph API and the default renderer can use any shape for clipping.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-item#clip-prop&quot;&gt;Item :: clip&lt;/a&gt; 을 true로 설정하면 기하학에 사각형이 있는 &lt;a href=&quot;qsgclipnode&quot;&gt;QSGClipNode&lt;/a&gt; 가 작성됩니다 . 기본 렌더러는 OpenGL에서 가위를 사용하여이 클립을 적용합니다. 항목이 90 도가 아닌 각도로 회전하면 OpenGL의 스텐실 버퍼가 사용됩니다. Qt Quick Item은 QML을 통해 사각형을 클립으로 설정하는 것만 지원하지만 장면 그래프 API와 기본 렌더러는 클리핑에 모든 모양을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a5ed62e892daca59bcdf47a39598aaed448ddccb" translate="yes" xml:space="preserve">
          <source>When setting a maximum date, the &lt;a href=&quot;qcalendarwidget#minimumDate-prop&quot;&gt;minimumDate&lt;/a&gt; and &lt;a href=&quot;qcalendarwidget#selectedDate-prop&quot;&gt;selectedDate&lt;/a&gt; properties are adjusted if the selection range becomes invalid. If the provided date is not a valid &lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt; object, the setMaximumDate() function does nothing.</source>
          <target state="translated">최대 날짜를 설정할 때 선택 범위가 유효하지 않으면 &lt;a href=&quot;qcalendarwidget#minimumDate-prop&quot;&gt;minimumDate&lt;/a&gt; 및 &lt;a href=&quot;qcalendarwidget#selectedDate-prop&quot;&gt;selectedDate&lt;/a&gt; 속성이 조정됩니다. 제공된 날짜가 유효한 &lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt; 오브젝트 가 아닌 경우 setMaximumDate () 함수는 아무 것도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c4ae2d023320be5119694dfde25d7c2125941c8d" translate="yes" xml:space="preserve">
          <source>When setting a minimum date, the &lt;a href=&quot;qcalendarwidget#maximumDate-prop&quot;&gt;maximumDate&lt;/a&gt; and &lt;a href=&quot;qcalendarwidget#selectedDate-prop&quot;&gt;selectedDate&lt;/a&gt; properties are adjusted if the selection range becomes invalid. If the provided date is not a valid &lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt; object, the setMinimumDate() function does nothing.</source>
          <target state="translated">최소 날짜를 설정할 때 선택 범위가 유효하지 않으면 &lt;a href=&quot;qcalendarwidget#maximumDate-prop&quot;&gt;maximumDate&lt;/a&gt; 및 &lt;a href=&quot;qcalendarwidget#selectedDate-prop&quot;&gt;selectedDate&lt;/a&gt; 속성이 조정됩니다. 제공된 날짜가 유효한 &lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt; 오브젝트 가 아닌 경우 setMinimumDate () 함수는 아무 것도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6eeb8a01ae2a0c99098eee6b5e541fd874b03835" translate="yes" xml:space="preserve">
          <source>When setting the fragment or vertex shader source code, the status will become Uncompiled. The first time the &lt;a href=&quot;qml-qtquick-shadereffect&quot;&gt;ShaderEffect&lt;/a&gt; is rendered with new shader source code, the shaders are compiled and linked, and the status is updated to Compiled or Error.</source>
          <target state="translated">프래그먼트 또는 버텍스 셰이더 소스 코드를 설정하면 상태가 컴파일되지 않은 상태가됩니다. 처음 &lt;a href=&quot;qml-qtquick-shadereffect&quot;&gt;ShaderEffect이&lt;/a&gt; 새로운 쉐이더 소스 코드와 함께 렌더링은, 쉐이더 컴파일 및 링크, 그리고 상태가 컴파일 또는 오류로 업데이트된다.</target>
        </trans-unit>
        <trans-unit id="12bc8cc3889504df656aec89fdae8d32b48b48bd" translate="yes" xml:space="preserve">
          <source>When setting the pick method to &lt;a href=&quot;qt3drender-qpickingsettings#PickResultMode-enum&quot;&gt;AllPicks&lt;/a&gt;, events will be triggered for all the entities with a &lt;a href=&quot;qt3drender-qobjectpicker&quot;&gt;QObjectPicker&lt;/a&gt; along the ray.</source>
          <target state="translated">pick 메소드를 &lt;a href=&quot;qt3drender-qpickingsettings#PickResultMode-enum&quot;&gt;AllPicks로&lt;/a&gt; 설정 하면 광선을 따라 &lt;a href=&quot;qt3drender-qobjectpicker&quot;&gt;QObjectPicker&lt;/a&gt; 가있는 모든 엔티티에 대해 이벤트가 트리거됩니다 .</target>
        </trans-unit>
        <trans-unit id="faf0f4e80eb610da479dd49899491179142a9cfd" translate="yes" xml:space="preserve">
          <source>When setting the pick method to &lt;a href=&quot;qt3drender-qpickingsettings#PickResultMode-enum&quot;&gt;NearestPriorityPick&lt;/a&gt;, events will be triggered for the nearest highest priority picker. This can be used when a given element should always be selected even if others are in front of it.</source>
          <target state="translated">pick 메소드를 &lt;a href=&quot;qt3drender-qpickingsettings#PickResultMode-enum&quot;&gt;NearestPriorityPick으로&lt;/a&gt; 설정하면 가장 가까운 우선 순위가 높은 피커에 대해 이벤트가 트리거됩니다. 다른 요소가 앞에있는 경우에도 주어진 요소를 항상 선택해야 할 때 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="46eaad0ccb2bedbfcbdda653384c06947cbb2dbb" translate="yes" xml:space="preserve">
          <source>When setting the year using the Date constructor or set(UTC)FullYear(), the convention set by ISO 8601 is used and 0 is a valid year. This means negative years set with the constructor or set(UTC)FullYear() are zero-based and thus offset by one year from what is printed with toString() and friends. Parsing the output of any of the to*String() methods will yield the same date value you printed from. Date.parse() will recognize the different formats and their convention on the existence of year 0.</source>
          <target state="translated">Date 생성자 또는 set (UTC) FullYear ()를 사용하여 연도를 설정할 때는 ISO 8601에서 설정 한 규칙이 사용되며 0은 유효한 연도입니다. 이것은 생성자 또는 set (UTC) FullYear ()로 설정된 음의 연도는 0부터 시작하므로 toString () 및 friends로 인쇄 된 것으로부터 1 년 단위로 상쇄됩니다. to * String () 메소드의 출력을 구문 분석하면 인쇄 한 날짜 값과 동일한 값이 생성됩니다. Date.parse ()는 0 년의 존재에 대한 다양한 형식과 규칙을 인식합니다.</target>
        </trans-unit>
        <trans-unit id="99af14a2050e900c54b4cf4320044307dba2671c" translate="yes" xml:space="preserve">
          <source>When setting this property &lt;a href=&quot;qtextbrowser&quot;&gt;QTextBrowser&lt;/a&gt; tries to find a document with the specified name in the paths of the &lt;a href=&quot;qtextbrowser#searchPaths-prop&quot;&gt;searchPaths&lt;/a&gt; property and directory of the current source, unless the value is an absolute file path. It also checks for optional anchors and scrolls the document accordingly</source>
          <target state="translated">이 속성을 설정할 때 &lt;a href=&quot;qtextbrowser&quot;&gt;QTextBrowser&lt;/a&gt; 는 값이 절대 파일 경로가 아닌 한 &lt;a href=&quot;qtextbrowser#searchPaths-prop&quot;&gt;searchPaths&lt;/a&gt; 속성 의 경로 및 현재 소스의 디렉토리 에서 지정된 이름의 문서를 찾으려고합니다 . 또한 옵션 앵커를 확인하고 그에 따라 문서를 스크롤합니다.</target>
        </trans-unit>
        <trans-unit id="fce20a64ddb9efcd0a6072a5a5807d0354c99c5b" translate="yes" xml:space="preserve">
          <source>When setting this property the &lt;a href=&quot;qdatetimeedit#maximumDate-prop&quot;&gt;maximumDate&lt;/a&gt; is adjusted if necessary, to ensure that the range remains valid. If the date is not a valid &lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt; object, this function does nothing.</source>
          <target state="translated">이 속성을 설정할 때 필요한 경우 범위가 유효한지 확인하기 위해 &lt;a href=&quot;qdatetimeedit#maximumDate-prop&quot;&gt;maximumDate&lt;/a&gt; 가 조정됩니다. 날짜가 유효한 &lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt; 객체 가 아닌 경우이 함수는 아무 작업도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f3536a246a03f23af815f636527d6ffa980281bd" translate="yes" xml:space="preserve">
          <source>When setting this property the &lt;a href=&quot;qdatetimeedit#maximumDateTime-prop&quot;&gt;maximumDateTime&lt;/a&gt;() is adjusted if necessary to ensure that the range remains valid. If the datetime is not a valid &lt;a href=&quot;qdatetime&quot;&gt;QDateTime&lt;/a&gt; object, this function does nothing.</source>
          <target state="translated">이 속성을 설정할 때 필요한 경우 범위가 유효한지 확인하기 위해 &lt;a href=&quot;qdatetimeedit#maximumDateTime-prop&quot;&gt;maximumDateTime&lt;/a&gt; ()이 조정됩니다. 날짜 시간이 유효한 &lt;a href=&quot;qdatetime&quot;&gt;QDateTime&lt;/a&gt; 오브젝트 가 아닌 경우이 함수는 아무 작업도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1d3985b1214032de5548d5f37a050ce05224466f" translate="yes" xml:space="preserve">
          <source>When setting this property the &lt;a href=&quot;qdatetimeedit#maximumTime-prop&quot;&gt;maximumTime&lt;/a&gt; is adjusted if necessary, to ensure that the range remains valid. If the time is not a valid &lt;a href=&quot;qtime&quot;&gt;QTime&lt;/a&gt; object, this function does nothing.</source>
          <target state="translated">이 속성을 설정할 때 필요한 경우 range가 유효한지 확인하기 위해 &lt;a href=&quot;qdatetimeedit#maximumTime-prop&quot;&gt;maximumTime&lt;/a&gt; 이 조정됩니다. 시간이 유효한 &lt;a href=&quot;qtime&quot;&gt;QTime&lt;/a&gt; 객체 가 아닌 경우이 함수는 아무 작업도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3a94d8175867d402a4937ec027013411408a4199" translate="yes" xml:space="preserve">
          <source>When setting this property the &lt;a href=&quot;qdatetimeedit#minimumDate-prop&quot;&gt;minimumDate&lt;/a&gt; is adjusted if necessary to ensure that the range remains valid. If the date is not a valid &lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt; object, this function does nothing.</source>
          <target state="translated">이 속성을 설정할 때 필요한 경우 범위가 유효한지 확인하기 위해 &lt;a href=&quot;qdatetimeedit#minimumDate-prop&quot;&gt;minimumDate&lt;/a&gt; 가 조정됩니다. 날짜가 유효한 &lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt; 객체 가 아닌 경우이 함수는 아무 작업도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d00e3ae41e62b165ec366eabf69c76f997cb71bc" translate="yes" xml:space="preserve">
          <source>When setting this property the &lt;a href=&quot;qdatetimeedit#minimumDateTime-prop&quot;&gt;minimumDateTime&lt;/a&gt;() is adjusted if necessary to ensure that the range remains valid. If the datetime is not a valid &lt;a href=&quot;qdatetime&quot;&gt;QDateTime&lt;/a&gt; object, this function does nothing.</source>
          <target state="translated">이 속성을 설정할 때 필요한 경우 범위가 유효한지 확인하기 위해 &lt;a href=&quot;qdatetimeedit#minimumDateTime-prop&quot;&gt;minimumDateTime&lt;/a&gt; ()이 조정됩니다. 날짜 시간이 유효한 &lt;a href=&quot;qdatetime&quot;&gt;QDateTime&lt;/a&gt; 오브젝트 가 아닌 경우이 함수는 아무 작업도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fd101378453eccdf2e848a4824798dd5c0a85b7e" translate="yes" xml:space="preserve">
          <source>When setting this property the &lt;a href=&quot;qdoublespinbox#maximum-prop&quot;&gt;maximum&lt;/a&gt; is adjusted if necessary to ensure that the range remains valid.</source>
          <target state="translated">이 속성을 설정할 때 필요한 경우 범위가 유효한지 확인하기 위해 &lt;a href=&quot;qdoublespinbox#maximum-prop&quot;&gt;최대 값&lt;/a&gt; 이 조정됩니다.</target>
        </trans-unit>
        <trans-unit id="d52e2cb44d7f2ae6749696edb496d673ee39757f" translate="yes" xml:space="preserve">
          <source>When setting this property the &lt;a href=&quot;qdoublespinbox#minimum-prop&quot;&gt;minimum&lt;/a&gt; is adjusted if necessary, to ensure that the range remains valid.</source>
          <target state="translated">이 속성을 설정할 때 필요한 경우 &lt;a href=&quot;qdoublespinbox#minimum-prop&quot;&gt;최소값&lt;/a&gt; 이 조정되어 범위가 유효하게 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="47cfedf6ef21c709f13ba69a81ab6789fc8a9fd1" translate="yes" xml:space="preserve">
          <source>When setting this property the &lt;a href=&quot;qspinbox#maximum-prop&quot;&gt;maximum&lt;/a&gt; is adjusted if necessary to ensure that the range remains valid.</source>
          <target state="translated">이 속성을 설정할 때 필요한 경우 범위가 유효한지 확인하기 위해 &lt;a href=&quot;qspinbox#maximum-prop&quot;&gt;최대 값&lt;/a&gt; 이 조정됩니다.</target>
        </trans-unit>
        <trans-unit id="9b3aa09d9d597d2ccc6d81186f12b9dee43bde16" translate="yes" xml:space="preserve">
          <source>When setting this property the corresponding maximum value is adjusted if necessary, to ensure that the range remains valid.</source>
          <target state="translated">이 속성을 설정할 때 필요한 경우 해당 최대 값이 조정되어 범위가 유효하게 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="ed5abb02b8b1a236c42c80272c5d4f7b5e792484" translate="yes" xml:space="preserve">
          <source>When setting this property the corresponding minimum value is adjusted if necessary, to ensure that the range remains valid.</source>
          <target state="translated">이 속성을 설정할 때 필요한 경우 해당 최소값이 조정되어 범위가 유효하게 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="0e2d22ffaa8c87cce0769e98c3a06583fa170f8d" translate="yes" xml:space="preserve">
          <source>When setting this property the minimum is adjusted if necessary, to ensure that the range remains valid.</source>
          <target state="translated">이 속성을 설정할 때 필요한 경우 최소값이 조정되어 범위가 유효하게 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="10bbb03412564a8a76a7faa470981f3e92871bb0" translate="yes" xml:space="preserve">
          <source>When setting this property the timespec of the &lt;a href=&quot;qdatetimeedit&quot;&gt;QDateTimeEdit&lt;/a&gt; remains the same and the timespec of the new &lt;a href=&quot;qdatetime&quot;&gt;QDateTime&lt;/a&gt; is ignored.</source>
          <target state="translated">이 속성을 설정할 때 &lt;a href=&quot;qdatetimeedit&quot;&gt;QDateTimeEdit&lt;/a&gt; 의 시간 사양 은 동일하게 유지되며 새 &lt;a href=&quot;qdatetime&quot;&gt;QDateTime의 시간 사양&lt;/a&gt; 은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="2375a6809ff71a69632c1ba6bc4411bcbd56175e" translate="yes" xml:space="preserve">
          <source>When setting this property to a list of waypoints, each waypoint can be either a &lt;a href=&quot;qml-coordinate&quot;&gt;coordinate&lt;/a&gt; or a &lt;a href=&quot;qml-qtlocation-waypoint&quot;&gt;Waypoint&lt;/a&gt;, interchangeably. If a &lt;a href=&quot;qml-coordinate&quot;&gt;coordinate&lt;/a&gt; is passed, it will be internally converted to a &lt;a href=&quot;qml-qtlocation-waypoint&quot;&gt;Waypoint&lt;/a&gt;.</source>
          <target state="translated">경유지 목록이 속성을 설정하는 경우, 각각의 웨이 중 하나가 될 수 &lt;a href=&quot;qml-coordinate&quot;&gt;좌표&lt;/a&gt; 또는 &lt;a href=&quot;qml-qtlocation-waypoint&quot;&gt;경유지&lt;/a&gt; 혼용. A는 경우 &lt;a href=&quot;qml-coordinate&quot;&gt;좌표&lt;/a&gt; 전달, 그것은 내부적으로 변환됩니다 &lt;a href=&quot;qml-qtlocation-waypoint&quot;&gt;웨이 포인트&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8c08c05c4f9a6cc8ebd2fa6d3ff3659b0e8d5359" translate="yes" xml:space="preserve">
          <source>When setting this property, the &lt;a href=&quot;qabstractslider#maximum-prop&quot;&gt;maximum&lt;/a&gt; is adjusted if necessary to ensure that the range remains valid. Also the slider's current value is adjusted to be within the new range.</source>
          <target state="translated">이 속성을 설정할 때 필요한 경우 범위가 유효한지 확인하기 위해 &lt;a href=&quot;qabstractslider#maximum-prop&quot;&gt;최대 값&lt;/a&gt; 이 조정됩니다. 또한 슬라이더의 현재 값이 새 범위 내에 있도록 조정됩니다.</target>
        </trans-unit>
        <trans-unit id="083344e77b31d85a0b5a8a8283eca8fda3876952" translate="yes" xml:space="preserve">
          <source>When setting this property, the &lt;a href=&quot;qabstractslider#minimum-prop&quot;&gt;minimum&lt;/a&gt; is adjusted if necessary to ensure that the range remains valid. Also the slider's current value is adjusted to be within the new range.</source>
          <target state="translated">이 속성을 설정할 때 필요한 경우 &lt;a href=&quot;qabstractslider#minimum-prop&quot;&gt;최소값&lt;/a&gt; 이 조정되어 범위가 유효하게 유지됩니다. 또한 슬라이더의 현재 값이 새 범위 내에 있도록 조정됩니다.</target>
        </trans-unit>
        <trans-unit id="890b98dfbcb1358977a7219adcd63ac2cd2c0980" translate="yes" xml:space="preserve">
          <source>When setting this property, the &lt;a href=&quot;qdatetimeedit#minimumTime-prop&quot;&gt;minimumTime&lt;/a&gt; is adjusted if necessary to ensure that the range remains valid. If the time is not a valid &lt;a href=&quot;qtime&quot;&gt;QTime&lt;/a&gt; object, this function does nothing.</source>
          <target state="translated">이 속성을 설정할 때 필요한 경우 &lt;a href=&quot;qdatetimeedit#minimumTime-prop&quot;&gt;rangeTime&lt;/a&gt; 이 유효한지 확인하기 위해 minimumTime 이 조정됩니다. 시간이 유효한 &lt;a href=&quot;qtime&quot;&gt;QTime&lt;/a&gt; 객체 가 아닌 경우이 함수는 아무 작업도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fa2c9bb906ff3305eef76e88d6b8655a32b982f4" translate="yes" xml:space="preserve">
          <source>When setting this property, the &lt;a href=&quot;qml-qtcharts-pieseries#holeSize-prop&quot;&gt;holeSize&lt;/a&gt; property is adjusted if necessary, to ensure that the hole size is not greater than the pie size.</source>
          <target state="translated">이 속성을 설정할 때 구멍 크기가 파이 크기보다 크지 않도록 필요한 경우 &lt;a href=&quot;qml-qtcharts-pieseries#holeSize-prop&quot;&gt;holeSize&lt;/a&gt; 속성이 조정됩니다.</target>
        </trans-unit>
        <trans-unit id="f435a68f9316a9aad8d0bd9214e3829a97c2384f" translate="yes" xml:space="preserve">
          <source>When setting this property, the &lt;a href=&quot;qml-qtcharts-pieseries#size-prop&quot;&gt;size&lt;/a&gt; property is adjusted if necessary, to ensure that the hole size is not greater than the pie size.</source>
          <target state="translated">이 속성을 설정할 때 구멍 크기가 파이 크기보다 크지 않도록 필요한 경우 &lt;a href=&quot;qml-qtcharts-pieseries#size-prop&quot;&gt;크기&lt;/a&gt; 속성이 조정됩니다.</target>
        </trans-unit>
        <trans-unit id="2614229e0748ff7798a30ec6c9a32c8bd564129c" translate="yes" xml:space="preserve">
          <source>When setting this property, the &lt;a href=&quot;qpieseries#holeSize-prop&quot;&gt;holeSize&lt;/a&gt; property is adjusted if necessary, to ensure that the hole size is not greater than the pie size.</source>
          <target state="translated">이 속성을 설정할 때 구멍 크기가 파이 크기보다 크지 않도록 필요한 경우 &lt;a href=&quot;qpieseries#holeSize-prop&quot;&gt;holeSize&lt;/a&gt; 속성이 조정됩니다.</target>
        </trans-unit>
        <trans-unit id="9676bb4e1b94754c72406b0dd8f30c9729452b6c" translate="yes" xml:space="preserve">
          <source>When setting this property, the &lt;a href=&quot;qpieseries#size-prop&quot;&gt;size&lt;/a&gt; property is adjusted if necessary, to ensure that the hole size is not greater than the pie size.</source>
          <target state="translated">이 속성을 설정할 때 구멍 크기가 파이 크기보다 크지 않도록 필요한 경우 &lt;a href=&quot;qpieseries#size-prop&quot;&gt;크기&lt;/a&gt; 속성이 조정됩니다.</target>
        </trans-unit>
        <trans-unit id="5c4c814181687e53992d25bc4a345c8885416475" translate="yes" xml:space="preserve">
          <source>When setting this property, the &lt;a href=&quot;qprogressbar#maximum-prop&quot;&gt;maximum&lt;/a&gt; is adjusted if necessary to ensure that the range remains valid. If the current value falls outside the new range, the progress bar is reset with &lt;a href=&quot;qprogressbar#reset&quot;&gt;reset&lt;/a&gt;().</source>
          <target state="translated">이 속성을 설정할 때 필요한 경우 범위가 유효한지 확인하기 위해 &lt;a href=&quot;qprogressbar#maximum-prop&quot;&gt;최대 값&lt;/a&gt; 이 조정됩니다. 현재 값이 새 범위를 벗어나면 진행률 표시 줄이 &lt;a href=&quot;qprogressbar#reset&quot;&gt;재설정&lt;/a&gt; () 으로 재설정 됩니다.</target>
        </trans-unit>
        <trans-unit id="d10bb2cee1aba8ceaf054055bf90ceea6821e2bc" translate="yes" xml:space="preserve">
          <source>When setting this property, the &lt;a href=&quot;qprogressbar#minimum-prop&quot;&gt;minimum&lt;/a&gt; is adjusted if necessary to ensure that the range remains valid. If the current value falls outside the new range, the progress bar is reset with &lt;a href=&quot;qprogressbar#reset&quot;&gt;reset&lt;/a&gt;().</source>
          <target state="translated">이 속성을 설정할 때 필요한 경우 &lt;a href=&quot;qprogressbar#minimum-prop&quot;&gt;최소값&lt;/a&gt; 이 조정되어 범위가 유효하게 유지됩니다. 현재 값이 새 범위를 벗어나면 진행률 표시 줄이 &lt;a href=&quot;qprogressbar#reset&quot;&gt;재설정&lt;/a&gt; () 으로 재설정 됩니다.</target>
        </trans-unit>
        <trans-unit id="32aea66ca6d6da71cb41f4c7cc9dc10b08e8577f" translate="yes" xml:space="preserve">
          <source>When setting this property, the maximum value is adjusted if necessary, to ensure that the range remains valid.</source>
          <target state="translated">이 속성을 설정할 때 필요한 경우 최대 값이 조정되어 범위가 유효하게 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="b951c983b0aee73e158712980739ff70f149887e" translate="yes" xml:space="preserve">
          <source>When setting this property, the maximum value is adjusted if necessary, to ensure that the range remains valid. The value has to be greater than 0.</source>
          <target state="translated">이 속성을 설정할 때 필요한 경우 최대 값이 조정되어 범위가 유효하게 유지됩니다. 값은 0보다 커야합니다.</target>
        </trans-unit>
        <trans-unit id="7a55bcbc9be43eedc7805bdbb3ee9e54f14990ff" translate="yes" xml:space="preserve">
          <source>When setting this property, the minimum value is adjusted if necessary, to ensure that the range remains valid.</source>
          <target state="translated">이 속성을 설정할 때 필요한 경우 최소값이 조정되어 범위가 유효하게 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="c7876cf5d914de6fdd878ac65bed31fe69eb59c2" translate="yes" xml:space="preserve">
          <source>When setting this property, the minimum value is adjusted if necessary, to ensure that the range remains valid. The value has to be greater than 0.</source>
          <target state="translated">이 속성을 설정할 때 필요한 경우 최소값이 조정되어 범위가 유효하게 유지됩니다. 값은 0보다 커야합니다.</target>
        </trans-unit>
        <trans-unit id="5de4dc53f812589029ed9067e97355562cb0e1d3" translate="yes" xml:space="preserve">
          <source>When setting up the rendering pipeline, call &lt;a href=&quot;qvulkanwindow#sampleCountFlagBits&quot;&gt;sampleCountFlagBits&lt;/a&gt;() to query the active sample count as a &lt;code&gt;VkSampleCountFlagBits&lt;/code&gt; value.</source>
          <target state="translated">렌더링 파이프 라인을 설정할 때 &lt;a href=&quot;qvulkanwindow#sampleCountFlagBits&quot;&gt;sampleCountFlagBits&lt;/a&gt; ()를 호출 하여 활성 샘플 수를 &lt;code&gt;VkSampleCountFlagBits&lt;/code&gt; 값 으로 쿼리하십시오 .</target>
        </trans-unit>
        <trans-unit id="dfcd5a5c296c55f96b9ee5da99d93a616d2b11fc" translate="yes" xml:space="preserve">
          <source>When shaders were added to this program via &lt;a href=&quot;qopenglshaderprogram#addCacheableShaderFromSourceCode&quot;&gt;addCacheableShaderFromSourceCode&lt;/a&gt;() or &lt;a href=&quot;qopenglshaderprogram#addCacheableShaderFromSourceFile&quot;&gt;addCacheableShaderFromSourceFile&lt;/a&gt;(), program binaries are supported, and a cached binary is available on disk, actual compilation and linking are skipped. Instead, link() will initialize the program with the binary blob via glProgramBinary(). If there is no cached version of the program or it was generated with a different driver version, the shaders will be compiled from source and the program will get linked normally. This allows seamless upgrading of the graphics drivers, without having to worry about potentially incompatible binary formats.</source>
          <target state="translated">&lt;a href=&quot;qopenglshaderprogram#addCacheableShaderFromSourceCode&quot;&gt;addCacheableShaderFromSourceCode&lt;/a&gt; () 또는 &lt;a href=&quot;qopenglshaderprogram#addCacheableShaderFromSourceFile&quot;&gt;addCacheableShaderFromSourceFile&lt;/a&gt; () 을 통해이 프로그램에 셰이더를 추가하면 프로그램 바이너리가 지원되며 캐시 된 바이너리는 디스크에서 사용할 수 있으며 실제 컴파일 및 링크는 건너 뜁니다. 대신 link ()는 glProgramBinary ()를 통해 이진 Blob으로 프로그램을 초기화합니다. 프로그램의 캐시 된 버전이 없거나 다른 드라이버 버전으로 생성 된 경우 셰이더는 소스에서 컴파일되고 프로그램은 정상적으로 연결됩니다. 따라서 호환되지 않는 이진 형식에 대해 걱정할 필요없이 그래픽 드라이버를 완벽하게 업그레이드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="87d3d39130885f5e5c6a9174de6513c3d33b6b27" translate="yes" xml:space="preserve">
          <source>When side-effects are unavoidable, ensure that the prior state is restored at the end of the test function, even if the test fails. This commonly requires use of an RAII (resource acquisition is initialization) class that restores state when the function returns, or a &lt;code&gt;cleanup()&lt;/code&gt; method. Do not simply put the restoration code at the end of the test. If part of the test fails, such code will be skipped and the prior state will not be restored.</source>
          <target state="translated">부작용이 피할 수없는 경우 테스트가 실패하더라도 테스트 기능이 끝날 때 이전 상태가 복원되는지 확인합니다. 이를 위해서는 일반적으로 함수가 반환 될 때 상태를 복원하는 RAII (리소스 획득은 초기화) 클래스 또는 &lt;code&gt;cleanup()&lt;/code&gt; 메서드를 사용해야합니다 . 단순히 테스트 끝에 복원 코드를 입력하지 마십시오. 테스트의 일부가 실패하면 해당 코드를 건너 뛰고 이전 상태가 복원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="64b2c21463a05b372aacfedaa2026900f87448ca" translate="yes" xml:space="preserve">
          <source>When subclassing &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; or &lt;a href=&quot;qabstractproxymodel&quot;&gt;QAbstractProxyModel&lt;/a&gt;, ensure that you emit &lt;a href=&quot;qabstractitemmodel#layoutAboutToBeChanged&quot;&gt;layoutAboutToBeChanged&lt;/a&gt;() before changing the order of items or altering the structure of the data you expose to views, and emit layoutChanged() after changing the layout.</source>
          <target state="translated">서브 클래스 때 &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; 또는 &lt;a href=&quot;qabstractproxymodel&quot;&gt;QAbstractProxyModel를&lt;/a&gt; 하면 출사되도록 &lt;a href=&quot;qabstractitemmodel#layoutAboutToBeChanged&quot;&gt;layoutAboutToBeChanged를&lt;/a&gt; 레이아웃을 변경 한 후 () 항목의 순서를 변경하거나보기에 노출 된 데이터의 구조를 변경하기 전에 () 및 발광은 layoutChanged.</target>
        </trans-unit>
        <trans-unit id="29ad4f995056d1ccd3dcee88f2d1086d0349dbfd" translate="yes" xml:space="preserve">
          <source>When subclassing &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt;, at the very least you must implement &lt;a href=&quot;qabstractitemmodel#index&quot;&gt;index&lt;/a&gt;(), &lt;a href=&quot;qabstractitemmodel#parent&quot;&gt;parent&lt;/a&gt;(), &lt;a href=&quot;qabstractitemmodel#rowCount&quot;&gt;rowCount&lt;/a&gt;(), &lt;a href=&quot;qabstractitemmodel#columnCount&quot;&gt;columnCount&lt;/a&gt;(), and &lt;a href=&quot;qabstractitemmodel#data&quot;&gt;data&lt;/a&gt;(). These functions are used in all read-only models, and form the basis of editable models.</source>
          <target state="translated">&lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel을&lt;/a&gt; 서브 클래 싱 할 때는 최소한 &lt;a href=&quot;qabstractitemmodel#index&quot;&gt;index&lt;/a&gt; (), &lt;a href=&quot;qabstractitemmodel#parent&quot;&gt;parent&lt;/a&gt; (), &lt;a href=&quot;qabstractitemmodel#rowCount&quot;&gt;rowCount&lt;/a&gt; (), &lt;a href=&quot;qabstractitemmodel#columnCount&quot;&gt;columnCount&lt;/a&gt; () 및 &lt;a href=&quot;qabstractitemmodel#data&quot;&gt;data&lt;/a&gt; ()를 구현해야합니다 . 이 기능은 모든 읽기 전용 모델에 사용되며 편집 가능한 모델의 기초를 형성합니다.</target>
        </trans-unit>
        <trans-unit id="a191eed727edc2ae03b2ab93852a02163a6c05e0" translate="yes" xml:space="preserve">
          <source>When subclassing &lt;a href=&quot;qabstractlistmodel&quot;&gt;QAbstractListModel&lt;/a&gt;, you must provide implementations of the &lt;a href=&quot;qabstractitemmodel#rowCount&quot;&gt;rowCount&lt;/a&gt;() and &lt;a href=&quot;qabstractitemmodel#data&quot;&gt;data&lt;/a&gt;() functions. Well behaved models also provide a &lt;a href=&quot;qabstractitemmodel#headerData&quot;&gt;headerData&lt;/a&gt;() implementation.</source>
          <target state="translated">&lt;a href=&quot;qabstractlistmodel&quot;&gt;QAbstractListModel을&lt;/a&gt; 서브 클래 싱 할 때 구현을 제공해야합니다.&lt;a href=&quot;qabstractitemmodel#rowCount&quot;&gt; rowCount&lt;/a&gt; () 및 &lt;a href=&quot;qabstractitemmodel#data&quot;&gt;data&lt;/a&gt; () 함수의 . 잘 동작하는 모델은 &lt;a href=&quot;qabstractitemmodel#headerData&quot;&gt;headerData&lt;/a&gt; () 구현 도 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="34ee94bbac1ecea4e8ddb454d400be8aae1e7968" translate="yes" xml:space="preserve">
          <source>When subclassing &lt;a href=&quot;qabstracttablemodel&quot;&gt;QAbstractTableModel&lt;/a&gt;, you must implement &lt;a href=&quot;qabstractitemmodel#rowCount&quot;&gt;rowCount&lt;/a&gt;(), &lt;a href=&quot;qabstractitemmodel#columnCount&quot;&gt;columnCount&lt;/a&gt;(), and &lt;a href=&quot;qabstractitemmodel#data&quot;&gt;data&lt;/a&gt;(). Default implementations of the &lt;a href=&quot;qabstracttablemodel#index&quot;&gt;index&lt;/a&gt;() and &lt;a href=&quot;qabstractitemmodel#parent&quot;&gt;parent&lt;/a&gt;() functions are provided by &lt;a href=&quot;qabstracttablemodel&quot;&gt;QAbstractTableModel&lt;/a&gt;. Well behaved models will also implement &lt;a href=&quot;qabstractitemmodel#headerData&quot;&gt;headerData&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qabstracttablemodel&quot;&gt;QAbstractTableModel을&lt;/a&gt; 서브 클래 싱 할 때는 &lt;a href=&quot;qabstractitemmodel#rowCount&quot;&gt;rowCount&lt;/a&gt; (), &lt;a href=&quot;qabstractitemmodel#columnCount&quot;&gt;columnCount&lt;/a&gt; () 및 &lt;a href=&quot;qabstractitemmodel#data&quot;&gt;data&lt;/a&gt; ()를 구현해야합니다 . &lt;a href=&quot;qabstracttablemodel#index&quot;&gt;인덱스&lt;/a&gt; ()와 &lt;a href=&quot;qabstractitemmodel#parent&quot;&gt;부모&lt;/a&gt; 의 기본 구현 () 함수&lt;a href=&quot;qabstracttablemodel&quot;&gt; QAbstractTableModel&lt;/a&gt; 에 의해 제공됩니다 . 잘 동작하는 모델은 &lt;a href=&quot;qabstractitemmodel#headerData&quot;&gt;headerData&lt;/a&gt; () 도 구현 합니다.</target>
        </trans-unit>
        <trans-unit id="bc5ed4ae258b22a232b577325d7a45d5a74a6ae6" translate="yes" xml:space="preserve">
          <source>When subclassing &lt;a href=&quot;qaccessibleactioninterface&quot;&gt;QAccessibleActionInterface&lt;/a&gt; you need to provide a list of &lt;a href=&quot;qaccessibleactioninterface#actionNames&quot;&gt;actionNames&lt;/a&gt; which is the primary means to discover the available actions. Action names are never localized. In order to present actions to the user there are two functions that need to return localized versions of the name and give a description of the action. For the predefined action names use &lt;a href=&quot;qaccessibleactioninterface#localizedActionName&quot;&gt;QAccessibleActionInterface::localizedActionName&lt;/a&gt;() and &lt;a href=&quot;qaccessibleactioninterface#localizedActionDescription&quot;&gt;QAccessibleActionInterface::localizedActionDescription&lt;/a&gt;() to return their localized counterparts.</source>
          <target state="translated">&lt;a href=&quot;qaccessibleactioninterface&quot;&gt;QAccessibleActionInterface&lt;/a&gt; 를 서브 클래 싱 할 때 &lt;a href=&quot;qaccessibleactioninterface#actionNames&quot;&gt;actionName&lt;/a&gt; 목록을 제공해야합니다. 사용 가능한 조치를 발견하는 기본 수단 . 활동 이름은 현지화되지 않습니다. 사용자에게 조치를 제시하기 위해 현지화 된 버전의 이름을 리턴하고 조치에 대한 설명을 제공해야하는 두 가지 기능이 있습니다. 사전 정의 된 조치 이름의 경우 &lt;a href=&quot;qaccessibleactioninterface#localizedActionName&quot;&gt;QAccessibleActionInterface :: localizedActionName&lt;/a&gt; () 및 &lt;a href=&quot;qaccessibleactioninterface#localizedActionDescription&quot;&gt;QAccessibleActionInterface :: localizedActionDescription&lt;/a&gt; ()을 사용하여 현지화 된 대응 항목을 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="a25edef8cc00a94f017f1d9cbc6945550b8bf450" translate="yes" xml:space="preserve">
          <source>When subclassing &lt;a href=&quot;qiodevice&quot;&gt;QIODevice&lt;/a&gt;, you must call QIODevice::seek() at the start of your function to ensure integrity with &lt;a href=&quot;qiodevice&quot;&gt;QIODevice&lt;/a&gt;'s built-in buffer.</source>
          <target state="translated">서브 클래 싱 할 때 &lt;a href=&quot;qiodevice&quot;&gt; QIODevice을&lt;/a&gt; , 당신과 무결성을 보장하기 위해 함수의 시작 () QIODevice이 :: 추구 호출해야합니다 &lt;a href=&quot;qiodevice&quot;&gt;QIODevice&lt;/a&gt; 의 내장에서 버퍼를.</target>
        </trans-unit>
        <trans-unit id="d195ef9dc4d6a9738e6783d4bc0696c9278d4ef4" translate="yes" xml:space="preserve">
          <source>When subclassing &lt;a href=&quot;qitemdelegate&quot;&gt;QItemDelegate&lt;/a&gt; to create a delegate that displays items using a custom renderer, it is important to ensure that the delegate can render items suitably for all the required states; e.g. selected, disabled, checked. The documentation for the &lt;a href=&quot;qitemdelegate#paint&quot;&gt;paint&lt;/a&gt;() function contains some hints to show how this can be achieved.</source>
          <target state="translated">서브 클래 싱 할 때 &lt;a href=&quot;qitemdelegate&quot;&gt;QItemDelegate&lt;/a&gt; 를 하여 커스텀 렌더러를 사용하여 아이템을 표시하는 델리게이트를 생성 , 델리게이트가 필요한 모든 상태에 맞게 아이템을 렌더링 할 수 있어야합니다. 예 : 선택, 비활성화, 확인 &lt;a href=&quot;qitemdelegate#paint&quot;&gt;paint&lt;/a&gt; () 함수에 대한 문서 에는 이것이 어떻게 달성 될 수 있는지 보여주는 힌트가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="bdfab8a00f506ea4624c5ba05bcfdffa0be88abb" translate="yes" xml:space="preserve">
          <source>When subclassing &lt;a href=&quot;qlistwidgetitem&quot;&gt;QListWidgetItem&lt;/a&gt; to provide custom items, it is possible to define new types for them enabling them to be distinguished from standard items. For subclasses that require this feature, ensure that you call the base class constructor with a new type value equal to or greater than &lt;a href=&quot;qlistwidgetitem#ItemType-enum&quot;&gt;UserType&lt;/a&gt;, within</source>
          <target state="translated">&lt;a href=&quot;qlistwidgetitem&quot;&gt;QListWidgetItem을&lt;/a&gt; 서브 클래 싱 할 때 을 하여 사용자 정의 항목을 제공 표준 항목과 구별 할 수 있도록 새 유형을 정의 할 수 있습니다. 이 기능이 필요 서브 클래스, 당신이 같거나보다 큰 새로운 유형의 값으로 기본 클래스 생성자를 호출 할 수 있도록 &lt;a href=&quot;qlistwidgetitem#ItemType-enum&quot;&gt;UserType을&lt;/a&gt; 내,</target>
        </trans-unit>
        <trans-unit id="25983c5d275d61a5768d14102127d7627a6f2db7" translate="yes" xml:space="preserve">
          <source>When subclassing &lt;a href=&quot;qstandarditem&quot;&gt;QStandardItem&lt;/a&gt; to provide custom items, it is possible to define new types for them so that they can be distinguished from the base class. The &lt;a href=&quot;qstandarditem#type&quot;&gt;type&lt;/a&gt;() function should be reimplemented to return a new type value equal to or greater than &lt;a href=&quot;qstandarditem#ItemType-enum&quot;&gt;UserType&lt;/a&gt;.</source>
          <target state="translated">커스텀 아이템을 제공하기 위해 &lt;a href=&quot;qstandarditem&quot;&gt;QStandardItem&lt;/a&gt; 을 서브 클래 싱 할 때 , 기본 클래스와 구별 될 수 있도록 새로운 타입을 정의 할 수 있습니다. &lt;a href=&quot;qstandarditem#type&quot;&gt;유형&lt;/a&gt; () 함수에 또는 이상 같은 새로운 타입의 값을 반환 다시 구현되어야 &lt;a href=&quot;qstandarditem#ItemType-enum&quot;&gt;UserType을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e6fbf6fe9133647e06d0faf1437cba6ca2cedd98" translate="yes" xml:space="preserve">
          <source>When subclassing &lt;a href=&quot;qstandarditem&quot;&gt;QStandardItem&lt;/a&gt;, you can reimplement this function to provide &lt;a href=&quot;qstandarditemmodel&quot;&gt;QStandardItemModel&lt;/a&gt; with a factory that it can use to create new items on demand.</source>
          <target state="translated">&lt;a href=&quot;qstandarditem&quot;&gt;QStandardItem을&lt;/a&gt; 서브 클래 싱 할 때 할 때이 함수를 다시 구현 하여 필요에 따라 새 항목을 작성하는 데 사용할 수있는 팩토리를 &lt;a href=&quot;qstandarditemmodel&quot;&gt;QStandardItemModel&lt;/a&gt; 에 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f2286413d50d08d040929b6ec39c68a3dddaf3c0" translate="yes" xml:space="preserve">
          <source>When subclassing &lt;a href=&quot;qtablewidgetitem&quot;&gt;QTableWidgetItem&lt;/a&gt; to provide custom items, it is possible to define new types for them so that they can be distinguished from standard items. The constructors for subclasses that require this feature need to call the base class constructor with a new type value equal to or greater than &lt;a href=&quot;qtablewidgetitem#ItemType-enum&quot;&gt;UserType&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qtablewidgetitem&quot;&gt;QTableWidgetItem을&lt;/a&gt; 서브 클래 싱 할 때 을 하여 사용자 정의 항목을 제공 표준 항목과 구별 할 수 있도록 새 유형을 정의 할 수 있습니다. 이 기능이 필요한 서브 클래스의 생성자는 &lt;a href=&quot;qtablewidgetitem#ItemType-enum&quot;&gt;UserType&lt;/a&gt; 이상의 새 유형 값으로 기본 클래스 생성자를 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="1002dc2f9f72071b49f3bc6989364ec60eb22d54" translate="yes" xml:space="preserve">
          <source>When subclassing &lt;a href=&quot;qtreewidgetitem&quot;&gt;QTreeWidgetItem&lt;/a&gt; to provide custom items, it is possible to define new types for them so that they can be distinguished from standard items. The constructors for subclasses that require this feature need to call the base class constructor with a new type value equal to or greater than &lt;a href=&quot;qtreewidgetitem#ItemType-enum&quot;&gt;UserType&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qtreewidgetitem&quot;&gt;QTreeWidgetItem&lt;/a&gt; 을 서브 클래 싱 하여 사용자 정의 항목을 제공 할 때 표준 항목과 구별 할 수 있도록 새 유형을 정의 할 수 있습니다. 이 기능이 필요한 서브 클래스의 생성자는 새 유형 값 이상인 기본 클래스 생성자를 호출해야합니다.&lt;a href=&quot;qtreewidgetitem#ItemType-enum&quot;&gt; UserType&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="59520faecedf14305609ce71b43c92f419907198" translate="yes" xml:space="preserve">
          <source>When subclassing QAbstractItemModel, at the very least you must implement &lt;a href=&quot;qabstractitemmodel#index&quot;&gt;index&lt;/a&gt;(), &lt;a href=&quot;qabstractitemmodel#parent&quot;&gt;parent&lt;/a&gt;(), &lt;a href=&quot;qabstractitemmodel#rowCount&quot;&gt;rowCount&lt;/a&gt;(), &lt;a href=&quot;qabstractitemmodel#columnCount&quot;&gt;columnCount&lt;/a&gt;(), and &lt;a href=&quot;qabstractitemmodel#data&quot;&gt;data&lt;/a&gt;(). These functions are used in all read-only models, and form the basis of editable models.</source>
          <target state="translated">QAbstractItemModel을 서브 클래 싱 할 때 최소한 &lt;a href=&quot;qabstractitemmodel#index&quot;&gt;index&lt;/a&gt; (), &lt;a href=&quot;qabstractitemmodel#parent&quot;&gt;parent&lt;/a&gt; (), &lt;a href=&quot;qabstractitemmodel#rowCount&quot;&gt;rowCount&lt;/a&gt; (), &lt;a href=&quot;qabstractitemmodel#columnCount&quot;&gt;columnCount&lt;/a&gt; () 및 &lt;a href=&quot;qabstractitemmodel#data&quot;&gt;data&lt;/a&gt; ()를 구현해야합니다 . 이러한 기능은 모든 읽기 전용 모델에서 사용되며 편집 가능한 모델의 기반을 형성합니다.</target>
        </trans-unit>
        <trans-unit id="3699b269f018546bac2b237f4b1ba2d9ba58cd5a" translate="yes" xml:space="preserve">
          <source>When subclassing QAbstractListModel, you must provide implementations of the &lt;a href=&quot;qabstractitemmodel#rowCount&quot;&gt;rowCount&lt;/a&gt;() and &lt;a href=&quot;qabstractitemmodel#data&quot;&gt;data&lt;/a&gt;() functions. Well behaved models also provide a &lt;a href=&quot;qabstractitemmodel#headerData&quot;&gt;headerData&lt;/a&gt;() implementation.</source>
          <target state="translated">QAbstractListModel을 서브 클래 싱 할 때 &lt;a href=&quot;qabstractitemmodel#rowCount&quot;&gt;rowCount&lt;/a&gt; () 및 &lt;a href=&quot;qabstractitemmodel#data&quot;&gt;데이터&lt;/a&gt; () 함수의 구현을 제공해야합니다 . 잘 작동하는 모델은 &lt;a href=&quot;qabstractitemmodel#headerData&quot;&gt;headerData&lt;/a&gt; () 구현 도 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="b1062aef636e41c878017026955b733a82f0e58d" translate="yes" xml:space="preserve">
          <source>When subclassing QAbstractTableModel, you must implement &lt;a href=&quot;qabstractitemmodel#rowCount&quot;&gt;rowCount&lt;/a&gt;(), &lt;a href=&quot;qabstractitemmodel#columnCount&quot;&gt;columnCount&lt;/a&gt;(), and &lt;a href=&quot;qabstractitemmodel#data&quot;&gt;data&lt;/a&gt;(). Default implementations of the &lt;a href=&quot;qabstracttablemodel#index&quot;&gt;index&lt;/a&gt;() and &lt;a href=&quot;qabstractitemmodel#parent&quot;&gt;parent&lt;/a&gt;() functions are provided by QAbstractTableModel. Well behaved models will also implement &lt;a href=&quot;qabstractitemmodel#headerData&quot;&gt;headerData&lt;/a&gt;().</source>
          <target state="translated">QAbstractTableModel을 서브 클래 싱 할 때 &lt;a href=&quot;qabstractitemmodel#rowCount&quot;&gt;rowCount&lt;/a&gt; (), &lt;a href=&quot;qabstractitemmodel#columnCount&quot;&gt;columnCount&lt;/a&gt; () 및 &lt;a href=&quot;qabstractitemmodel#data&quot;&gt;data&lt;/a&gt; ()를 구현해야합니다 . &lt;a href=&quot;qabstracttablemodel#index&quot;&gt;index&lt;/a&gt; () 및 &lt;a href=&quot;qabstractitemmodel#parent&quot;&gt;parent&lt;/a&gt; () 함수 의 기본 구현은 QAbstractTableModel에서 제공합니다. 잘 작동하는 모델은 &lt;a href=&quot;qabstractitemmodel#headerData&quot;&gt;headerData&lt;/a&gt; () 도 구현 합니다.</target>
        </trans-unit>
        <trans-unit id="26b79d67e5a46121dc5b166539f6602a7e665200" translate="yes" xml:space="preserve">
          <source>When subclassing QAccessibleActionInterface you need to provide a list of &lt;a href=&quot;qaccessibleactioninterface#actionNames&quot;&gt;actionNames&lt;/a&gt; which is the primary means to discover the available actions. Action names are never localized. In order to present actions to the user there are two functions that need to return localized versions of the name and give a description of the action. For the predefined action names use &lt;a href=&quot;qaccessibleactioninterface#localizedActionName&quot;&gt;QAccessibleActionInterface::localizedActionName&lt;/a&gt;() and &lt;a href=&quot;qaccessibleactioninterface#localizedActionDescription&quot;&gt;QAccessibleActionInterface::localizedActionDescription&lt;/a&gt;() to return their localized counterparts.</source>
          <target state="translated">QAccessibleActionInterface를 서브 클래 싱 할 때 사용 가능한 작업을 검색하는 기본 수단 인 &lt;a href=&quot;qaccessibleactioninterface#actionNames&quot;&gt;actionNames&lt;/a&gt; 목록을 제공해야합니다 . 작업 이름은 현지화되지 않습니다. 사용자에게 작업을 제공하기 위해 지역화 된 버전의 이름을 반환하고 작업에 대한 설명을 제공해야하는 두 가지 함수가 있습니다. 사전 정의 된 작업 이름의 경우 &lt;a href=&quot;qaccessibleactioninterface#localizedActionName&quot;&gt;QAccessibleActionInterface :: localizedActionName&lt;/a&gt; () 및 &lt;a href=&quot;qaccessibleactioninterface#localizedActionDescription&quot;&gt;QAccessibleActionInterface :: localizedActionDescription&lt;/a&gt; ()을 사용하여 현지화 된 대응 항목을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1fd6e4c37e600fd73592fb3b27ecd0ad7ca47a17" translate="yes" xml:space="preserve">
          <source>When subclassing QItemDelegate to create a delegate that displays items using a custom renderer, it is important to ensure that the delegate can render items suitably for all the required states; e.g. selected, disabled, checked. The documentation for the &lt;a href=&quot;qitemdelegate#paint&quot;&gt;paint&lt;/a&gt;() function contains some hints to show how this can be achieved.</source>
          <target state="translated">사용자 지정 렌더러를 사용하여 항목을 표시하는 델리게이트를 생성하기 위해 QItemDelegate를 서브 클래 싱 할 때, 델리게이트가 모든 필수 상태에 적합하게 항목을 렌더링 할 수 있는지 확인하는 것이 중요합니다. 예 : 선택됨, 비활성화 됨, 선택됨. &lt;a href=&quot;qitemdelegate#paint&quot;&gt;paint&lt;/a&gt; () 함수에 대한 문서 에는이를 달성하는 방법을 보여주는 몇 가지 힌트가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e0f5aa88b44938c261cc9eef6f6e4a41afa7675" translate="yes" xml:space="preserve">
          <source>When subclassing QListWidgetItem to provide custom items, it is possible to define new types for them enabling them to be distinguished from standard items. For subclasses that require this feature, ensure that you call the base class constructor with a new type value equal to or greater than &lt;a href=&quot;qlistwidgetitem#ItemType-enum&quot;&gt;UserType&lt;/a&gt;, within</source>
          <target state="translated">사용자 정의 항목을 제공하기 위해 QListWidgetItem을 서브 클래 싱 할 때 표준 항목과 구별 할 수 있도록 새 유형을 정의 할 수 있습니다. 이 기능이 필요 서브 클래스, 당신이 같거나보다 큰 새로운 유형의 값으로 기본 클래스 생성자를 호출 할 수 있도록 &lt;a href=&quot;qlistwidgetitem#ItemType-enum&quot;&gt;UserType을&lt;/a&gt; 내,</target>
        </trans-unit>
        <trans-unit id="72aca5e914ed9fefcaccb35499bea805b895d281" translate="yes" xml:space="preserve">
          <source>When subclassing QStandardItem to provide custom items, it is possible to define new types for them so that they can be distinguished from the base class. The &lt;a href=&quot;qstandarditem#type&quot;&gt;type&lt;/a&gt;() function should be reimplemented to return a new type value equal to or greater than &lt;a href=&quot;qstandarditem#ItemType-enum&quot;&gt;UserType&lt;/a&gt;.</source>
          <target state="translated">사용자 지정 항목을 제공하기 위해 QStandardItem을 하위 클래스화할 때 기본 클래스와 구별 될 수 있도록 새 유형을 정의 할 수 있습니다. &lt;a href=&quot;qstandarditem#type&quot;&gt;형&lt;/a&gt; () 함수에 또는 이상 같은 새로운 타입의 값을 반환 다시 구현되어야 &lt;a href=&quot;qstandarditem#ItemType-enum&quot;&gt;UserType을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="42b0b4032d93d4857496512b038b0674cfd26f89" translate="yes" xml:space="preserve">
          <source>When subclassing QTableWidgetItem to provide custom items, it is possible to define new types for them so that they can be distinguished from standard items. The constructors for subclasses that require this feature need to call the base class constructor with a new type value equal to or greater than &lt;a href=&quot;qtablewidgetitem#ItemType-enum&quot;&gt;UserType&lt;/a&gt;.</source>
          <target state="translated">사용자 정의 항목을 제공하기 위해 QTableWidgetItem을 서브 클래 싱 할 때 표준 항목과 구별 될 수 있도록 새 유형을 정의 할 수 있습니다. 이 기능이 필요한 서브 클래스의 생성자는 &lt;a href=&quot;qtablewidgetitem#ItemType-enum&quot;&gt;UserType&lt;/a&gt; 보다 크거나 같은 새 유형 값으로 기본 클래스 생성자를 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="3a47ebf3a47f4b0b127eba34804babe9e0cf37bc" translate="yes" xml:space="preserve">
          <source>When subclassing QTreeWidgetItem to provide custom items, it is possible to define new types for them so that they can be distinguished from standard items. The constructors for subclasses that require this feature need to call the base class constructor with a new type value equal to or greater than &lt;a href=&quot;qtreewidgetitem#ItemType-enum&quot;&gt;UserType&lt;/a&gt;.</source>
          <target state="translated">사용자 정의 항목을 제공하기 위해 QTreeWidgetItem을 서브 클래 싱 할 때 표준 항목과 구별 될 수 있도록 새 유형을 정의 할 수 있습니다. 이 기능이 필요한 서브 클래스의 생성자는 &lt;a href=&quot;qtreewidgetitem#ItemType-enum&quot;&gt;UserType&lt;/a&gt; 보다 크거나 같은 새 유형 값으로 기본 클래스 생성자를 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="706f7b1df0260af3c55347db3db3d7c9292cb895" translate="yes" xml:space="preserve">
          <source>When successful, the pointer to this &lt;a href=&quot;qvulkaninstance&quot;&gt;QVulkanInstance&lt;/a&gt; is retrievable via the static function current().</source>
          <target state="translated">성공하면 이것에 대한 포인터 &lt;a href=&quot;qvulkaninstance&quot;&gt;&lt;/a&gt; 하면 정적 함수 current () QVulkanInstance에 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="52f02029e2dd95fea6c58bc7c6dd438e3036694c" translate="yes" xml:space="preserve">
          <source>When successful, the returned pointer is either a direct pointer to an interface (and can be cast, for example, to &lt;code&gt;ID3D12Device *&lt;/code&gt;) or a pointer to an opaque handle that needs to be dereferenced first (for example, &lt;code&gt;VkDevice dev = *static_cast&amp;lt;VkDevice *&amp;gt;(result)&lt;/code&gt;). The latter is necessary since such handles may have sizes different from a pointer.</source>
          <target state="translated">성공하면 반환 된 포인터는 인터페이스에 대한 직접 포인터이며 (예 : &lt;code&gt;ID3D12Device *&lt;/code&gt; 로 캐스트 될 수 있음 ) 먼저 참조 해제해야하는 불투명 한 핸들에 대한 포인터입니다 (예 : &lt;code&gt;VkDevice dev = *static_cast&amp;lt;VkDevice *&amp;gt;(result)&lt;/code&gt; ). 후자는 그러한 핸들이 포인터와 다른 크기를 가질 수 있기 때문에 필요하다.</target>
        </trans-unit>
        <trans-unit id="b61533f5bfe4f41a281b6739619bbe40223b42c1" translate="yes" xml:space="preserve">
          <source>When supported, the spot metering point is the (normalized) position of the point of the image where exposure metering will be performed. This is typically used to indicate an &quot;interesting&quot; area of the image that should be exposed properly.</source>
          <target state="translated">지원되는 경우 스팟 측광 지점은 노출 측광이 수행 될 이미지 지점의 (정규화 된) 위치입니다. 이것은 일반적으로 올바르게 노출되어야하는 이미지의 &quot;흥미로운&quot;영역을 나타내는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5f88abce90e32dce271b35e9107fb601ec017c62" translate="yes" xml:space="preserve">
          <source>When switching application styles, the color palette is set back to the initial colors or the system defaults. This is necessary since certain styles have to adapt the color palette to be fully style-guide compliant.</source>
          <target state="translated">응용 프로그램 스타일을 전환하면 색상 팔레트가 초기 색상이나 시스템 기본값으로 다시 설정됩니다. 특정 스타일은 색상 표를 스타일 가이드와 완전히 일치하도록 조정해야하기 때문에 필요합니다.</target>
        </trans-unit>
        <trans-unit id="67873ce37a5513b0e5ae88b75e6f033ba8bb99f4" translate="yes" xml:space="preserve">
          <source>When tabsClosable is set to true a close button will appear on the tab on either the left or right hand side depending upon the style. When the button is clicked the tab the signal &lt;a href=&quot;qtabbar#tabCloseRequested&quot;&gt;tabCloseRequested&lt;/a&gt; will be emitted.</source>
          <target state="translated">tabsClosable이 true로 설정되면 스타일에 따라 왼쪽 또는 오른쪽의 탭에 닫기 단추가 나타납니다. 버튼을 클릭하면 &lt;a href=&quot;qtabbar#tabCloseRequested&quot;&gt;tabCloseRequested&lt;/a&gt; 신호 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="edd34e00a0649a39928db867a61af0bdd3698a54" translate="yes" xml:space="preserve">
          <source>When talking about version support on macOS, it's important to distinguish between the &lt;a href=&quot;#build-environment&quot;&gt;build environment&lt;/a&gt;; the platform you're building on or with, and the &lt;a href=&quot;#target-platforms&quot;&gt;target platforms&lt;/a&gt;; the platforms you are building for. The following macOS versions are supported.</source>
          <target state="translated">macOS에서 버전 지원에 관해 이야기 할 때 &lt;a href=&quot;#build-environment&quot;&gt;빌드 환경&lt;/a&gt; 을 구별하는 것이 중요 합니다 . 귀하가 구축하고있는 &lt;a href=&quot;#target-platforms&quot;&gt;플랫폼&lt;/a&gt; 및 대상 플랫폼 ; 구축하려는 플랫폼. 다음과 같은 macOS 버전이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="46e5a0bd94336c26034fab948fd2202518bbe3a7" translate="yes" xml:space="preserve">
          <source>When talking about version support on macOS, it's important to distinguish between the &lt;a href=&quot;macos#build-environment&quot;&gt;build environment&lt;/a&gt;; the platform you're building on or with, and the &lt;a href=&quot;macos#target-platforms&quot;&gt;target platforms&lt;/a&gt;; the platforms you are building for. The following macOS versions are supported.</source>
          <target state="translated">macOS에서 버전 지원에 대해 이야기 할 때 &lt;a href=&quot;macos#build-environment&quot;&gt;빌드 환경&lt;/a&gt; 을 구별하는 것이 중요 합니다 . 당신이 나 건물있는 플랫폼과 &lt;a href=&quot;macos#target-platforms&quot;&gt;타겟 플랫폼&lt;/a&gt; ; 당신이 구축하는 플랫폼. 다음 macOS 버전이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="12b09dba91f90a77f1c0f316bc1593767614f52d" translate="yes" xml:space="preserve">
          <source>When targeting the default render target, the &lt;code&gt;rasterizationSamples&lt;/code&gt; field of &lt;code&gt;VkPipelineMultisampleStateCreateInfo&lt;/code&gt; must be set to this value.</source>
          <target state="translated">기본 렌더 타겟을 대상으로 할 때 &lt;code&gt;VkPipelineMultisampleStateCreateInfo&lt;/code&gt; 의 &lt;code&gt;rasterizationSamples&lt;/code&gt; 샘플 필드 를이 값으로 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="01a0c4cf5ca0b1b36842c832e9f49ed747142008" translate="yes" xml:space="preserve">
          <source>When testing classes that change their state based on timer events, the timer-based behavior needs to be taken into account when performing verification steps. Due to the variety of timing-dependent behavior, there is no single generic solution to this testing problem.</source>
          <target state="translated">타이머 이벤트를 기반으로 상태를 변경하는 클래스를 테스트 할 때 확인 단계를 수행 할 때 타이머 기반 동작을 고려해야합니다. 다양한 타이밍 종속 동작으로 인해이 테스트 문제에 대한 단일 일반 솔루션은 없습니다.</target>
        </trans-unit>
        <trans-unit id="977796166650ef7b381034a2e5ab66d22d9fde20" translate="yes" xml:space="preserve">
          <source>When text is selected this signal will be emitted with</source>
          <target state="translated">텍스트를 선택하면이 신호가</target>
        </trans-unit>
        <trans-unit id="55f3e3f1e06a97818ce0ffb33865599309fb29ae" translate="yes" xml:space="preserve">
          <source>When the</source>
          <target state="translated">때</target>
        </trans-unit>
        <trans-unit id="277e96c69a29982435c9191c9b7dc60d6543c8df" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qcombobox&quot;&gt;QComboBox&lt;/a&gt; is editable, use &lt;a href=&quot;qlineedit#placeholderText-prop&quot;&gt;QLineEdit::setPlaceholderText&lt;/a&gt;() instead.</source>
          <target state="translated">때 &lt;a href=&quot;qcombobox&quot;&gt;QComboBox가&lt;/a&gt; 편집 할 수, 사용 &lt;a href=&quot;qlineedit#placeholderText-prop&quot;&gt;QLineEdit :: setPlaceholderText&lt;/a&gt; () 대신.</target>
        </trans-unit>
        <trans-unit id="96148eaf4c167de1a5cc9cb151bbca87c607e4e7" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qlogvalue3daxisformatter#base-prop&quot;&gt;base&lt;/a&gt; property value is non-zero, the whole axis range is often not equally divided into segments. The first and last segments are often smaller than the other segments. In extreme cases, this can lead to overlapping labels on the first and last two grid lines. By setting this property to &lt;code&gt;false&lt;/code&gt;, you can suppress showing the minimum and maximum labels for the axis in cases where the segments do not exactly fit the axis. Defaults to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">때 &lt;a href=&quot;qlogvalue3daxisformatter#base-prop&quot;&gt;기본&lt;/a&gt; 속성 값이 0이고, 모든 축 범위들은 동일 세그먼트로 분할 아니다. 첫 번째 세그먼트와 마지막 세그먼트는 종종 다른 세그먼트보다 작습니다. 극단적 인 경우 첫 번째 및 마지막 두 그리드 선에서 레이블이 겹칠 수 있습니다. 이 속성을 &lt;code&gt;false&lt;/code&gt; 로 설정 하면 세그먼트가 축에 정확히 맞지 않는 경우 축의 최소 및 최대 레이블 표시를 억제 할 수 있습니다. 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="fcebf5705064ce0455ad2b9bec751e51c083ccf2" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qml-qt3d-render-pointsize#sizeMode-prop&quot;&gt;sizeMode&lt;/a&gt; property is set to SizeMode::Fixed, the value is set using glPointSize(), if available. When using SizeMode::Programmable, gl_PointSize must be set within shader programs, the value provided to this &lt;a href=&quot;qml-qt3d-render-renderstate&quot;&gt;RenderState&lt;/a&gt; is ignored in that case.</source>
          <target state="translated">때 &lt;a href=&quot;qml-qt3d-render-pointsize#sizeMode-prop&quot;&gt;sizeMode의&lt;/a&gt; 속성이 SizeMode로 설정 :: 가능한 경우 값이 정해주고 싶다면 glPointSize 명령 ()를 사용하여 설정, 수정했습니다. SizeMode :: Programmable을 사용하는 경우 gl_PointSize는 셰이더 프로그램 내에서 설정되어야하며이 경우이 &lt;a href=&quot;qml-qt3d-render-renderstate&quot;&gt;RenderState에&lt;/a&gt; 제공된 값 은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="01c131bddcc8fa92f9f3b0a589fa47980eb2d439" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qml-qt3d-render-pointsize#sizeMode-prop&quot;&gt;sizeMode&lt;/a&gt; property is set to SizeMode::Fixed, the value is set using glPointSize(), if available. When using SizeMode::Programmable, gl_PointSize must be set within shader programs, the value provided to this &lt;a href=&quot;qml-renderstate&quot;&gt;RenderState&lt;/a&gt; is ignored in that case.</source>
          <target state="translated">때 &lt;a href=&quot;qml-qt3d-render-pointsize#sizeMode-prop&quot;&gt;sizeMode의&lt;/a&gt; 속성이 SizeMode로 설정 :: 가능한 경우 값이 정해주고 싶다면 glPointSize 명령 ()를 사용하여 설정, 수정했습니다. SizeMode :: Programmable을 사용할 때 gl_PointSize는이 &lt;a href=&quot;qml-renderstate&quot;&gt;RenderState에&lt;/a&gt; 제공된 값인 셰이더 프로그램 내에서 설정되어야합니다. 은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="31b0eaa228f2b88891ce3db774ff73a70a98110c" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qml-qtdatavisualization-logvalueaxis3dformatter#base-prop&quot;&gt;base&lt;/a&gt; property value is non-zero, the whole axis range is often not equally divided into segments. The first and last segments are often smaller than the other segments. In extreme cases, this can lead to overlapping labels on the first and last two grid lines. By setting this property to &lt;code&gt;false&lt;/code&gt;, you can suppress showing the minimum and maximum labels for the axis in cases where the segments do not exactly fit the axis. Defaults to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">때 &lt;a href=&quot;qml-qtdatavisualization-logvalueaxis3dformatter#base-prop&quot;&gt;기본&lt;/a&gt; 속성 값이 0이고, 모든 축 범위들은 동일 세그먼트로 분할 아니다. 첫 번째 세그먼트와 마지막 세그먼트는 종종 다른 세그먼트보다 작습니다. 극단적 인 경우 첫 번째 및 마지막 두 그리드 선에서 레이블이 겹칠 수 있습니다. 이 속성을 &lt;code&gt;false&lt;/code&gt; 로 설정 하면 세그먼트가 축에 정확히 맞지 않는 경우 축의 최소 및 최대 레이블 표시를 억제 할 수 있습니다. 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="987fec2f0c2c258849a742c9e14f0174fef55ec2" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qml-qtpositioning-positionsource&quot;&gt;PositionSource&lt;/a&gt; is active, position updates can be retrieved either by simply using the &lt;a href=&quot;qml-qtpositioning-positionsource#position-prop&quot;&gt;position&lt;/a&gt; property in a binding (as the value of another item's property), or by providing an implementation of the &lt;code&gt;onPositionChanged&lt;/code&gt; signal-handler.</source>
          <target state="translated">때 &lt;a href=&quot;qml-qtpositioning-positionsource&quot;&gt;PositionSource가&lt;/a&gt; 활성화되어, 위치 업데이트는 단순히 이용하거나 검색 할 수있는 &lt;a href=&quot;qml-qtpositioning-positionsource#position-prop&quot;&gt;위치에&lt;/a&gt; 결합 (다른 아이템의 속성 값으로서), 또는 구현 제공에 속성 &lt;code&gt;onPositionChanged&lt;/code&gt; 신호 처리기.</target>
        </trans-unit>
        <trans-unit id="d6b06a8b392f311abc92743e16b8eaf852385858" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qml-qtquick-controls-stackview&quot;&gt;StackView&lt;/a&gt; needs a new transition, it first calls &lt;a href=&quot;qml-qtquick-controls-stackviewdelegate#getTransition-method&quot;&gt;StackViewDelegate.getTransition()&lt;/a&gt;. The base implementation of this function just looks for a property named &lt;code&gt;properties.name&lt;/code&gt; inside itself (root), which is how it finds &lt;code&gt;property Component pushTransition&lt;/code&gt; in the examples above.</source>
          <target state="translated">때 &lt;a href=&quot;qml-qtquick-controls-stackview&quot;&gt;StackView이&lt;/a&gt; 새로운 전환을 필요로 먼저 호출 &lt;a href=&quot;qml-qtquick-controls-stackviewdelegate#getTransition-method&quot;&gt;() StackViewDelegate.getTransition를&lt;/a&gt; . 이 함수의 기본 구현은 그 자체 (root) 내 에서 properties.name이라는 &lt;code&gt;properties.name&lt;/code&gt; 을 찾습니다 . 위의 예제에서 &lt;code&gt;property Component pushTransition&lt;/code&gt; 을 찾는 방법 입니다.</target>
        </trans-unit>
        <trans-unit id="13b2463be39cc72e16c7d4ca58b0c4d0edaade26" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qml-qtquick-flickable#boundsMovement-prop&quot;&gt;boundsMovement&lt;/a&gt; is &lt;code&gt;Flickable.FollowBoundsBehavior&lt;/code&gt;, a value other than &lt;code&gt;Flickable.StopAtBounds&lt;/code&gt; will give a feeling that the edges of the view are soft, rather than a hard physical boundary.</source>
          <target state="translated">때 &lt;a href=&quot;qml-qtquick-flickable#boundsMovement-prop&quot;&gt;boundsMovement가&lt;/a&gt; 있다 &lt;code&gt;Flickable.FollowBoundsBehavior&lt;/code&gt; , 이외의 값 &lt;code&gt;Flickable.StopAtBounds&lt;/code&gt; 오히려 하드 물리적 경계보다 뷰의 가장자리가 부드러운 있다는 느낌을 줄 것이다.</target>
        </trans-unit>
        <trans-unit id="bdd086e0b6a8d49e2b2713bf9ea24b942d740d18" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qml-qtquick-mousearea&quot;&gt;MouseArea&lt;/a&gt; is clicked, &lt;code&gt;fruitModel&lt;/code&gt; will have two roles,</source>
          <target state="translated">때 &lt;a href=&quot;qml-qtquick-mousearea&quot;&gt;MouseArea를&lt;/a&gt; 클릭, &lt;code&gt;fruitModel&lt;/code&gt; 는 , 두 가지 역할을해야합니다</target>
        </trans-unit>
        <trans-unit id="531648fe487a96145ce0801a6bc88b47ddc3d5fa" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qml-qtquick-text&quot;&gt;Text&lt;/a&gt; object refers to its &lt;a href=&quot;qml-qtquick-item#parent-prop&quot;&gt;parent&lt;/a&gt; value in the above code, it is referring to its</source>
          <target state="translated">경우 &lt;a href=&quot;qml-qtquick-text&quot;&gt;텍스트&lt;/a&gt; 객체가 지칭 &lt;a href=&quot;qml-qtquick-item#parent-prop&quot;&gt;부모&lt;/a&gt; 상기 코드 값, 그것을 참조하여 해당</target>
        </trans-unit>
        <trans-unit id="cfbd43c514e575cbd44c06a9f1befeb8fbc6aa47" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qml-qtquick-virtualkeyboard-keyboardlayoutloader&quot;&gt;KeyboardLayoutLoader&lt;/a&gt; is used as a root item of a keyboard layout, the actual keyboard layouts are wrapped inside Component elements. The keyboard layout is activated by assigning the id of an active component to the sourceComponent property.</source>
          <target state="translated">때 &lt;a href=&quot;qml-qtquick-virtualkeyboard-keyboardlayoutloader&quot;&gt;KeyboardLayoutLoader가&lt;/a&gt; 키보드 레이아웃의 루트 항목으로 사용되며, 실제 키보드 레이아웃은 요소 요소 내부에 싸여있다. 키보드 레이아웃은 활성 구성 요소의 id를 sourceComponent 속성에 할당하여 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="f043241c3f7cc581207444dcc1dc86dbdeb3ef7b" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qpushbutton&quot;&gt;QPushButton&lt;/a&gt; is clicked, the console prints,</source>
          <target state="translated">때 &lt;a href=&quot;qpushbutton&quot;&gt;QPushButton을가&lt;/a&gt; 클릭, 콘솔 인쇄,</target>
        </trans-unit>
        <trans-unit id="d450f4ff62c8dd3eda6ad3d118faffcc34e07662" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qqmlengine&quot;&gt;QQmlEngine&lt;/a&gt; instantiates a &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;, the context is set automatically.</source>
          <target state="translated">때 &lt;a href=&quot;qqmlengine&quot;&gt;QQmlEngine이&lt;/a&gt; 인스턴스화 &lt;a href=&quot;qobject&quot;&gt;있는 QObject를&lt;/a&gt; , 상황이 자동으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="1a3ec88b091fae5c593926fbff02a507863cf15b" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qsensor#axesOrientationMode-prop&quot;&gt;axesOrientationMode&lt;/a&gt; property is set to &lt;a href=&quot;qsensor#AxesOrientationMode-enum&quot;&gt;UserOrientation&lt;/a&gt;, the angle for rotating the reading values is taken from this property. In other modes, the property has no effect.</source>
          <target state="translated">때 &lt;a href=&quot;qsensor#axesOrientationMode-prop&quot;&gt;axesOrientationMode의&lt;/a&gt; 속성으로 설정되어 &lt;a href=&quot;qsensor#AxesOrientationMode-enum&quot;&gt;UserOrientation&lt;/a&gt; , 판독 값을 회전시키는 각도는,이 속성으로부터 취해진 다. 다른 모드에서는 속성이 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f8b6764b784c8d16407b8358832df499fd592a45" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qsgmaterial&quot;&gt;QSGMaterial&lt;/a&gt; reports &lt;a href=&quot;qsgmaterial#Flag-enum&quot;&gt;SupportsRhiShader&lt;/a&gt; in &lt;a href=&quot;qsgmaterial#flags&quot;&gt;flags&lt;/a&gt;(), the scene graph may request a &lt;a href=&quot;qsgmaterialrhishader&quot;&gt;QSGMaterialRhiShader&lt;/a&gt; instead of &lt;a href=&quot;qsgmaterialshader&quot;&gt;QSGMaterialShader&lt;/a&gt;. This is indicated by having the &lt;a href=&quot;qsgmaterial#Flag-enum&quot;&gt;RhiShaderWanted&lt;/a&gt; flag set. In this case the return value must be a QSGRhiMaterialShader subclass.</source>
          <target state="translated">때 &lt;a href=&quot;qsgmaterial&quot;&gt;QSGMaterial가&lt;/a&gt; 보고 &lt;a href=&quot;qsgmaterial#Flag-enum&quot;&gt;SupportsRhiShader&lt;/a&gt; 에서 &lt;a href=&quot;qsgmaterial#flags&quot;&gt;플래그&lt;/a&gt; (), 장면 그래프는 요청할 수 &lt;a href=&quot;qsgmaterialrhishader&quot;&gt;QSGMaterialRhiShader&lt;/a&gt; 대신 &lt;a href=&quot;qsgmaterialshader&quot;&gt;QSGMaterialShader을&lt;/a&gt; . 이는 &lt;a href=&quot;qsgmaterial#Flag-enum&quot;&gt;RhiShaderWanted&lt;/a&gt; 플래그가 설정되어 있음을 나타냅니다 . 이 경우 반환 값은 QSGRhiMaterialShader 하위 클래스 여야합니다.</target>
        </trans-unit>
        <trans-unit id="3ec06e7607af8f8760e7b965130ca0af1c7c4afa" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qt#PenJoinStyle-enum&quot;&gt;Qt::MiterJoin&lt;/a&gt; style is applied, it is possible to use the &lt;a href=&quot;qpen#setMiterLimit&quot;&gt;setMiterLimit&lt;/a&gt;() function to specify how far the miter join can extend from the join point. The &lt;a href=&quot;qpen#miterLimit&quot;&gt;miterLimit&lt;/a&gt;() is used to reduce artifacts between line joins where the lines are close to parallel.</source>
          <target state="translated">때 &lt;a href=&quot;qt#PenJoinStyle-enum&quot;&gt;Qt는 :: MiterJoin의&lt;/a&gt; 스타일이 적용되고, 사용할 수 있습니다 &lt;a href=&quot;qpen#setMiterLimit&quot;&gt;setMiterLimit&lt;/a&gt; 이음이 (가) 조인 포인트에서 확장 할 수있는 참여 정도를 지정 () 함수를. &lt;a href=&quot;qpen#miterLimit&quot;&gt;이음 제한은&lt;/a&gt; () 선이 평행에 가까운 라인 사이의 결합 아티팩트를 감소 시키는데 사용된다.</target>
        </trans-unit>
        <trans-unit id="8cff9e77f59469425f8797ff7538a94cb9830def" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qt3drender-qpointsize#sizeMode-prop&quot;&gt;sizeMode&lt;/a&gt; property is set to SizeMode::Fixed, the value is set using glPointSize(), if available. When using SizeMode::Programmable, gl_PointSize must be set within shader programs, the value provided to this &lt;a href=&quot;qml-qt3d-render-renderstate&quot;&gt;RenderState&lt;/a&gt; is ignored in that case.</source>
          <target state="translated">때 &lt;a href=&quot;qt3drender-qpointsize#sizeMode-prop&quot;&gt;sizeMode의&lt;/a&gt; 속성이 SizeMode로 설정 :: 가능한 경우 값이 정해주고 싶다면 glPointSize 명령 ()를 사용하여 설정, 수정했습니다. SizeMode :: Programmable을 사용하는 경우 gl_PointSize는 셰이더 프로그램 내에서 설정되어야하며이 경우이 &lt;a href=&quot;qml-qt3d-render-renderstate&quot;&gt;RenderState에&lt;/a&gt; 제공된 값 은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="8109269e175dc39675b846ed563d3f286803d82a" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qt3drender-qpointsize#sizeMode-prop&quot;&gt;sizeMode&lt;/a&gt; property is set to SizeMode::Fixed, the value is set using glPointSize(), if available. When using SizeMode::Programmable, gl_PointSize must be set within shader programs, the value provided to this &lt;a href=&quot;qml-renderstate&quot;&gt;RenderState&lt;/a&gt; is ignored in that case.</source>
          <target state="translated">때 &lt;a href=&quot;qt3drender-qpointsize#sizeMode-prop&quot;&gt;sizeMode의&lt;/a&gt; 속성이 SizeMode로 설정 :: 가능한 경우 값이 정해주고 싶다면 glPointSize 명령 ()를 사용하여 설정, 수정했습니다. SizeMode :: Programmable을 사용하는 경우 gl_PointSize를 셰이더 프로그램 내에서 설정해야하며이 경우이 &lt;a href=&quot;qml-renderstate&quot;&gt;RenderState에&lt;/a&gt; 제공된 값 은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="ef51d747b8fb0e1aaf24623fb2724ee2f97056ec" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qtoolbutton&quot;&gt;QToolButton&lt;/a&gt; displays arrows, the &lt;a href=&quot;#up-arrow-sub&quot;&gt;::up-arrow&lt;/a&gt;, &lt;a href=&quot;#down-arrow-sub&quot;&gt;::down-arrow&lt;/a&gt;, &lt;a href=&quot;#left-arrow-sub&quot;&gt;::left-arrow&lt;/a&gt; and &lt;a href=&quot;#right-arrow-sub&quot;&gt;::right-arrow&lt;/a&gt; subcontrols are used.</source>
          <target state="translated">&lt;a href=&quot;qtoolbutton&quot;&gt;QToolButton에&lt;/a&gt; 화살표가 표시 되면 &lt;a href=&quot;#up-arrow-sub&quot;&gt;:: 위쪽 화살표&lt;/a&gt; , &lt;a href=&quot;#down-arrow-sub&quot;&gt;:: 아래쪽 화살표&lt;/a&gt; , &lt;a href=&quot;#left-arrow-sub&quot;&gt;:: 왼쪽 화살표&lt;/a&gt; 및 &lt;a href=&quot;#right-arrow-sub&quot;&gt;:: 오른쪽 &lt;/a&gt;화살표 하위 컨트롤 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="233835321d7949264542584e5872cf0f2ee5c9ad" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;qtoolbutton&quot;&gt;QToolButton&lt;/a&gt; displays arrows, the &lt;a href=&quot;stylesheet-reference#up-arrow-sub&quot;&gt;::up-arrow&lt;/a&gt;, &lt;a href=&quot;stylesheet-reference#down-arrow-sub&quot;&gt;::down-arrow&lt;/a&gt;, &lt;a href=&quot;stylesheet-reference#left-arrow-sub&quot;&gt;::left-arrow&lt;/a&gt; and &lt;a href=&quot;stylesheet-reference#right-arrow-sub&quot;&gt;::right-arrow&lt;/a&gt; subcontrols are used.</source>
          <target state="translated">&lt;a href=&quot;qtoolbutton&quot;&gt;QToolButton에&lt;/a&gt; 화살표가 표시 되면 &lt;a href=&quot;stylesheet-reference#up-arrow-sub&quot;&gt;:: up-arrow&lt;/a&gt; , &lt;a href=&quot;stylesheet-reference#down-arrow-sub&quot;&gt;:: down-arrow&lt;/a&gt; , &lt;a href=&quot;stylesheet-reference#left-arrow-sub&quot;&gt;:: left-arrow&lt;/a&gt; 및 &lt;a href=&quot;stylesheet-reference#right-arrow-sub&quot;&gt;:: right-arrow &lt;/a&gt;하위 컨트롤 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a1a6fb9f01b0846bb260ddb329a9c95bfca49b3e" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;subdirs&lt;/code&gt; template is used, qmake generates a Makefile to examine each specified subdirectory, process any project file it finds there, and run the platform's &lt;code&gt;make&lt;/code&gt; tool on the newly-created Makefile. The &lt;code&gt;SUBDIRS&lt;/code&gt; variable is used to contain a list of all the subdirectories to be processed.</source>
          <target state="translated">때 &lt;code&gt;subdirs&lt;/code&gt; 템플릿을 사용, 지정된 각 하위 디렉토리를 조사 거기를 찾은 프로젝트 파일을 처리하고, 플랫폼의 실행 Makefile을 qmake를 생성 &lt;code&gt;make&lt;/code&gt; 새로 만든 메이크 도구를. &lt;code&gt;SUBDIRS&lt;/code&gt; 의 변수는 처리되는 모든 하위 목록을 포함하기 위해 사용된다.</target>
        </trans-unit>
        <trans-unit id="5b64d4e10455a073c6c16a2676284bd8b55dc704" translate="yes" xml:space="preserve">
          <source>When the KMS/DRM backend is in use, EGLFS reports all available screens in &lt;a href=&quot;qguiapplication#screens&quot;&gt;QGuiApplication::screens&lt;/a&gt;(). Applications can target different screens with different windows via &lt;a href=&quot;qwindow#setScreen&quot;&gt;QWindow::setScreen&lt;/a&gt;().</source>
          <target state="translated">KMS / DRM 백엔드가 사용중인 경우 EGLFS는 &lt;a href=&quot;qguiapplication#screens&quot;&gt;QGuiApplication :: screens&lt;/a&gt; () 에서 사용 가능한 모든 화면을보고합니다 . 애플리케이션은 &lt;a href=&quot;qwindow#setScreen&quot;&gt;QWindow :: setScreen&lt;/a&gt; ()을 통해 다른 창을 가진 다른 화면을 대상으로 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="13cb608250173ac51a45d65525231f711e5ba267" translate="yes" xml:space="preserve">
          <source>When the KMS/DRM backend is in use, eglfs reports all available screens in &lt;a href=&quot;qguiapplication#screens&quot;&gt;QGuiApplication::screens&lt;/a&gt;(). Applications can target different screens with different windows via &lt;a href=&quot;qwindow#setScreen&quot;&gt;QWindow::setScreen&lt;/a&gt;().</source>
          <target state="translated">KMS / DRM 백엔드를 사용중인 경우 eglfs는 &lt;a href=&quot;qguiapplication#screens&quot;&gt;QGuiApplication :: screens&lt;/a&gt; () 에서 사용 가능한 모든 화면을보고합니다 . 응용 프로그램은 &lt;a href=&quot;qwindow#setScreen&quot;&gt;QWindow :: setScreen&lt;/a&gt; ()을 통해 다른 창으로 다른 화면을 대상으로 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e9c697bf2c44fd91eecd755192f28a6e88860c7e" translate="yes" xml:space="preserve">
          <source>When the PositionSource is active, position updates can be retrieved either by simply using the &lt;a href=&quot;qml-qtpositioning-positionsource#position-prop&quot;&gt;position&lt;/a&gt; property in a binding (as the value of another item's property), or by providing an implementation of the &lt;code&gt;onPositionChanged&lt;/code&gt; signal-handler.</source>
          <target state="translated">PositionSource가 활성화되면 단순히 바인딩 의 &lt;a href=&quot;qml-qtpositioning-positionsource#position-prop&quot;&gt;position&lt;/a&gt; 속성을 사용하거나 (다른 항목의 속성 값으로) &lt;code&gt;onPositionChanged&lt;/code&gt; 신호 처리기 의 구현을 제공하여 위치 업데이트를 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="590e6b713b7124a325673c8560f716815fb45204" translate="yes" xml:space="preserve">
          <source>When the QML engine encounters a use of &lt;code&gt;RandomNumberGenerator&lt;/code&gt; as a property value source, it invokes &lt;code&gt;RandomNumberGenerator::setTarget()&lt;/code&gt; to provide the type with the property to which the value source has been applied. When the internal timer in &lt;code&gt;RandomNumberGenerator&lt;/code&gt; triggers every 500 milliseconds, it will write a new number value to that specified property.</source>
          <target state="translated">QML 엔진이 &lt;code&gt;RandomNumberGenerator&lt;/code&gt; 를 특성 값 소스로 사용하면 &lt;code&gt;RandomNumberGenerator::setTarget()&lt;/code&gt; 을 호출 하여 값 소스가 적용된 특성을 유형에 제공합니다. &lt;code&gt;RandomNumberGenerator&lt;/code&gt; 의 내부 타이머가 500 밀리 초마다 트리거되면 지정된 속성에 새 숫자 값을 씁니다.</target>
        </trans-unit>
        <trans-unit id="55bdd73045f54c63cca63284c91153ecc1e0e57c" translate="yes" xml:space="preserve">
          <source>When the QML engine processes this code, it creates a single instance of the</source>
          <target state="translated">QML 엔진은이 코드를 처리 할 때</target>
        </trans-unit>
        <trans-unit id="2200e5bee9d5bde2ef75b92345abdbbd47de48d7" translate="yes" xml:space="preserve">
          <source>When the Space key is pressed, the &lt;a href=&quot;qml-qtquick-item#visible-prop&quot;&gt;visible&lt;/a&gt; value of the green &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt; is toggled. As it appears and disappears, the blue &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt; moves within the Column, and the &lt;a href=&quot;qml-qtquick-column#move-prop&quot;&gt;move&lt;/a&gt; transition is automatically applied to the blue &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt;:</source>
          <target state="translated">스페이스 키를 누르면 녹색 &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;사각형&lt;/a&gt; 의 &lt;a href=&quot;qml-qtquick-item#visible-prop&quot;&gt;보이는&lt;/a&gt; 값 이 토글됩니다. 이 나타나고, 파란색 사라으로 &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;사각형&lt;/a&gt; 열 내에서 이동하고, &lt;a href=&quot;qml-qtquick-column#move-prop&quot;&gt;이동&lt;/a&gt; 전환이 자동으로 파란색에 적용되는 &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;사각형&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="9c6490ecb547781d0dc7402f03b49e5ff063c783" translate="yes" xml:space="preserve">
          <source>When the StackView needs a new transition, it first calls &lt;a href=&quot;qml-qtquick-controls-stackviewdelegate#getTransition-method&quot;&gt;StackViewDelegate.getTransition()&lt;/a&gt;. The base implementation of this function just looks for a property named &lt;code&gt;properties.name&lt;/code&gt; inside itself (root), which is how it finds &lt;code&gt;property Component pushTransition&lt;/code&gt; in the examples above.</source>
          <target state="translated">StackView에 새 전환이 필요한 경우 먼저 &lt;a href=&quot;qml-qtquick-controls-stackviewdelegate#getTransition-method&quot;&gt;StackViewDelegate.getTransition ()을&lt;/a&gt; 호출합니다 . 이 함수의 기본 구현은 자체 (루트) 내부 에서 properties.name이라는 &lt;code&gt;properties.name&lt;/code&gt; 을 찾습니다 . 위의 예제에서 &lt;code&gt;property Component pushTransition&lt;/code&gt; 을 찾는 방법 입니다.</target>
        </trans-unit>
        <trans-unit id="6a3ce649d4099a8096022c6c669c9176b6fc57ee" translate="yes" xml:space="preserve">
          <source>When the \brief command is used to describe a class, we recommend using a complete sentence like this:</source>
          <target state="translated">\ brief 명령을 사용하여 클래스를 설명 할 때는 다음과 같은 완전한 문장을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="557b6338e75a33d13fe088abb975f18a855ab911" translate="yes" xml:space="preserve">
          <source>When the \brief command is used to describe a property or a variable, the brief text must be a sentence fragment starting with &quot;whether&quot; (for a boolean property or variable) or starting with &quot;the&quot; (for any other property or variable).</source>
          <target state="translated">\ brief 명령을 사용하여 속성 또는 변수를 설명하는 경우 간단한 텍스트는 &quot;whether&quot;(부울 속성 또는 변수)로 시작하거나 &quot;the&quot;(다른 속성 또는 변수)로 시작하는 문장 조각이어야합니다. .</target>
        </trans-unit>
        <trans-unit id="68de879942c076ccf49dec3b35482feaabb2b36a" translate="yes" xml:space="preserve">
          <source>When the above view is flicked beyond its bounds, it will return to its bounds using the transition specified:</source>
          <target state="translated">위의 뷰가 경계를 넘어 넘어지면 지정된 전환을 사용하여 경계로 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="589227a0f3172c2f19894c29348f6198f079bcbc" translate="yes" xml:space="preserve">
          <source>When the active subwindow is maximized, the default behavior is to maximize the next subwindow that is activated. Set this option if you do not want this behavior.</source>
          <target state="translated">활성 하위 창을 최대화하면 기본 동작은 활성화 된 다음 하위 창을 최대화하는 것입니다. 이 동작을 원하지 않으면이 옵션을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="ab36dbc74560565de3f4f93285f3477fd906523a" translate="yes" xml:space="preserve">
          <source>When the allowed &lt;a href=&quot;qdatetimeedit#setDateTimeRange&quot;&gt;range&lt;/a&gt; is narrower than some time interval whose end it straddles, keyboard tracking prevents the user editing the date or time to access the later part of the interval. For example, for a range from 29.04.2020 to 02.05.2020 and an initial date of 30.04.2020, the user can change neither the month (May 30th is outside the range) nor the day (April 2nd is outside the range).</source>
          <target state="translated">허용 된 &lt;a href=&quot;qdatetimeedit#setDateTimeRange&quot;&gt;범위&lt;/a&gt; 가 끝이있는 시간 간격보다 좁 으면 키보드 추적을 통해 사용자가 날짜 또는 시간을 편집하여 간격의 후반 부분에 액세스 할 수 없습니다. 예를 들어 2020 년 4 월 29 일부터 2020 년 2 월 5 일까지의 범위와 2020 년 4 월 30 일의 초기 날짜의 경우 사용자는 월 (5 월 30 일이 범위를 벗어남)이나 일 (4 월 2 일이 범위를 벗어남)을 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="5a7ce62c114b1cc52094be5a1851abc5fc7f2e64" translate="yes" xml:space="preserve">
          <source>When the alpha channel is enabled either via &lt;a href=&quot;qquickwindow#setDefaultAlphaBuffer&quot;&gt;QQuickWindow::setDefaultAlphaBuffer&lt;/a&gt;() or by setting alphaBufferSize to a non-zero value in the window's &lt;a href=&quot;qsurfaceformat&quot;&gt;QSurfaceFormat&lt;/a&gt; or in the global format managed by &lt;a href=&quot;qsurfaceformat#setDefaultFormat&quot;&gt;QSurfaceFormat::setDefaultFormat&lt;/a&gt;(), the D3D12 backend will create a swapchain for composition and go through DirectComposition. This is necessary, because the mandatory flip model swapchain wouldn't support transparency otherwise.</source>
          <target state="translated">알파 채널이 &lt;a href=&quot;qquickwindow#setDefaultAlphaBuffer&quot;&gt;QQuickWindow :: setDefaultAlphaBuffer&lt;/a&gt; () 를 통해 활성화되거나 창의 &lt;a href=&quot;qsurfaceformat&quot;&gt;QSurfaceFormat&lt;/a&gt; 또는 &lt;a href=&quot;qsurfaceformat#setDefaultFormat&quot;&gt;QSurfaceFormat :: setDefaultFormat&lt;/a&gt; ()에 의해 관리되는 전역 형식에서 alphaBufferSize를 0이 아닌 값으로 설정 하여 D3D12 백엔드는 스왑 체인을 생성합니다. 구성하고 DirectComposition을 진행하십시오. 필수 플립 모델 스왑 체인은 그렇지 않으면 투명성을 지원하지 않기 때문에 이것이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="9a1e6809f3ea75f0ed2e58d51575459791e1afbc" translate="yes" xml:space="preserve">
          <source>When the animation finishes it returns to the initial frame. This is the default behavior.</source>
          <target state="translated">애니메이션이 끝나면 초기 프레임으로 돌아갑니다. 이것이 기본 동작입니다.</target>
        </trans-unit>
        <trans-unit id="c2c6e776224aaea188a4e49fe2b71d9eeacafa46" translate="yes" xml:space="preserve">
          <source>When the animation finishes it stays on the final frame.</source>
          <target state="translated">애니메이션이 완료되면 최종 프레임에 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="abead2ff8ba68473ab0f073d1c6b50c8ad980ea5" translate="yes" xml:space="preserve">
          <source>When the application is running with the generic, triangulation-based Shape implementation, the geometry generation happens entirely on the CPU. This is potentially expensive. Changing the set of path elements, changing the properties of these elements, or changing certain properties of the Shape itself all lead to retriangulation of the affected paths on every change. Therefore, applying animation to such properties can affect performance on less powerful systems.</source>
          <target state="translated">응용 프로그램이 일반 삼각 측량 기반 Shape 구현으로 실행될 때 지오메트리 생성은 전적으로 CPU에서 발생합니다. 이것은 잠재적으로 비싸다. 패스 요소 집합을 변경하거나, 이러한 요소의 속성을 변경하거나, 셰이프 자체의 특정 속성을 변경하면 모든 변경에 영향을받는 경로가 다시 삼각형 화됩니다. 따라서 이러한 속성에 애니메이션을 적용하면 성능이 떨어지는 시스템의 성능에 영향을 줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2dc59efa2f06087183eee0fb11a7e9582ff61062" translate="yes" xml:space="preserve">
          <source>When the application is running, an IDE or a tool that implements the binary protocol can connect to the open port.</source>
          <target state="translated">응용 프로그램이 실행 중이면 바이너리 프로토콜을 구현하는 IDE 또는 도구가 열린 포트에 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c469e679911aae260b7551ead885271015ff56e7" translate="yes" xml:space="preserve">
          <source>When the application is started it has to register an message handler with &lt;a href=&quot;qnearfieldmanager#registerNdefMessageHandler&quot;&gt;registerNdefMessageHandler()&lt;/a&gt; The first NDEF message arriving in the handler is the message that started the application. See the &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtnfc-corkboard-example.html#&quot;&gt;CorkBoard&lt;/a&gt; application for an example.</source>
          <target state="translated">응용 프로그램이 시작되면 &lt;a href=&quot;qnearfieldmanager#registerNdefMessageHandler&quot;&gt;registerNdefMessageHandler ()&lt;/a&gt; 로 메시지 처리기를 등록해야합니다. 처리기에 도착하는 첫 번째 NDEF 메시지는 응용 프로그램을 시작한 메시지입니다. 예제 는 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtnfc-corkboard-example.html#&quot;&gt;CorkBoard&lt;/a&gt; 애플리케이션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bf9811db4bca65a70c4bf17f4e8c83205ce8fbdb" translate="yes" xml:space="preserve">
          <source>When the application is started it has to register an message handler with &lt;a href=&quot;qnearfieldmanager#registerNdefMessageHandler&quot;&gt;registerNdefMessageHandler()&lt;/a&gt; The first NDEF message arriving in the handler is the message that started the application. See the &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtnfc-corkboard-example.html&quot;&gt;CorkBoard&lt;/a&gt; application for an example.</source>
          <target state="translated">애플리케이션이 시작되면 &lt;a href=&quot;qnearfieldmanager#registerNdefMessageHandler&quot;&gt;registerNdefMessageHandler ()&lt;/a&gt; 로 메시지 핸들러를 등록해야합니다. 핸들러에 도착하는 첫 번째 NDEF 메시지는 애플리케이션을 시작한 메시지입니다. 예제 는 &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtnfc-corkboard-example.html&quot;&gt;CorkBoard&lt;/a&gt; 응용 프로그램을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="50a549dc65fe725b80a97de046a5a0dc3b6c6fb6" translate="yes" xml:space="preserve">
          <source>When the binding becomes inactive again, any direct bindings that were previously set on the property will be restored.</source>
          <target state="translated">바인딩이 다시 비활성화되면 속성에 이전에 설정된 모든 직접 바인딩이 복원됩니다.</target>
        </trans-unit>
        <trans-unit id="447dd45f7b45ede6829150c673fe906621c3daff" translate="yes" xml:space="preserve">
          <source>When the button is clicked, the purchase process is started. At some point in the future, either the &lt;a href=&quot;qml-qtpurchasing-product#onPurchaseFailed-signal&quot;&gt;onPurchaseFailed&lt;/a&gt; handler will be called (for example if the user cancels the transaction), or the &lt;a href=&quot;qml-qtpurchasing-product#onPurchaseSucceeded-signal&quot;&gt;onPurchaseSucceeded&lt;/a&gt; handler will be called.</source>
          <target state="translated">버튼을 클릭하면 구매 프로세스가 시작됩니다. 나중에 &lt;a href=&quot;qml-qtpurchasing-product#onPurchaseFailed-signal&quot;&gt;언젠가&lt;/a&gt; 는 onPurchaseFailed 핸들러가 호출 되거나 (예 : 사용자가 트랜잭션을 취소 한 경우) &lt;a href=&quot;qml-qtpurchasing-product#onPurchaseSucceeded-signal&quot;&gt;onPurchaseSucceeded&lt;/a&gt; 핸들러가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="4ebbf8f547dd292e8432493d1f5c0d39a31ffd9b" translate="yes" xml:space="preserve">
          <source>When the client is connected successfully, we connect to the `onTextMessageReceived()` signal, and send out &quot;Hello, world!&quot;. If connected with the EchoServer, we will receive the same message back.</source>
          <target state="translated">클라이언트가 성공적으로 연결되면, 우리는`onTextMessageReceived ()`신호에 연결하고 &quot;Hello, world!&quot;를 보냅니다. EchoServer와 연결되면 동일한 메시지가 다시 나타납니다.</target>
        </trans-unit>
        <trans-unit id="5d66decd4409859b0e6cc5ba70ca923d5222b329" translate="yes" xml:space="preserve">
          <source>When the connection to the &lt;a href=&quot;qtremoteobjects-source#source&quot;&gt;Source&lt;/a&gt; object is made, the initialization step passes the current property values (see &lt;a href=&quot;qtremoteobjects-replica#replica-initialization&quot;&gt;Replica Initialization&lt;/a&gt;). In a DynamicReplica, the property/signal/slot details are also sent, allowing the replica object to be created on-the-fly. This can be conventient in QML or scripting, but has two primary disadvantages. First, the object is in effect &quot;empty&quot; until it is successfully initialized by the &lt;a href=&quot;qtremoteobjects-source#source&quot;&gt;Source&lt;/a&gt;. Second, in C++, calls must be made using &lt;a href=&quot;qmetaobject#invokeMethod&quot;&gt;QMetaObject::invokeMethod&lt;/a&gt;(), as the moc generated lookup will not be available.</source>
          <target state="translated">&lt;a href=&quot;qtremoteobjects-source#source&quot;&gt;Source&lt;/a&gt; 객체에 연결되면 초기화 단계에서 현재 속성 값을 전달합니다 ( &lt;a href=&quot;qtremoteobjects-replica#replica-initialization&quot;&gt;복제본 초기화&lt;/a&gt; 참조 ). DynamicReplica에서는 속성 / 신호 / 슬롯 세부 정보도 전송되어 복제본 개체를 즉석에서 만들 수 있습니다. 이는 QML 또는 스크립팅에서 편리 할 수 ​​있지만 두 가지 주요 단점이 있습니다. 먼저, 객체는 &lt;a href=&quot;qtremoteobjects-source#source&quot;&gt;Source에&lt;/a&gt; 의해 성공적으로 초기화 될 때까지 &quot;빈&quot;상태 입니다. 두 번째로, C ++에서는 moc로 생성 된 조회를 사용할 수 없으므로 &lt;a href=&quot;qmetaobject#invokeMethod&quot;&gt;QMetaObject :: invokeMethod&lt;/a&gt; ()를 사용하여 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="08ec6e33eebed26c7c57c8ed22fb0ac60abd982e" translate="yes" xml:space="preserve">
          <source>When the content is changed using any of these functions, any previous content is cleared.</source>
          <target state="translated">이러한 기능 중 하나를 사용하여 내용을 변경하면 이전 내용이 지워집니다.</target>
        </trans-unit>
        <trans-unit id="098eff2cee4bb06ded290defca5ca43aedeb73b3" translate="yes" xml:space="preserve">
          <source>When the current element is a map, you may also call &lt;a href=&quot;qcborstreamreader#isLengthKnown&quot;&gt;isLengthKnown&lt;/a&gt;() to find out if the map's size is explicit in the CBOR stream. If it is, that size can be obtained by calling &lt;a href=&quot;qcborstreamreader#length&quot;&gt;length&lt;/a&gt;().</source>
          <target state="translated">현재 요소가지도 인 경우 &lt;a href=&quot;qcborstreamreader#isLengthKnown&quot;&gt;isLengthKnown&lt;/a&gt; ()을 호출 하여지도 크기가 CBOR 스트림에서 명시 적인지 확인할 수도 있습니다 . 그렇다면 &lt;a href=&quot;qcborstreamreader#length&quot;&gt;길이&lt;/a&gt; () 를 호출하여 해당 크기를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bea6a9143e97cc060ee75f79678b23a7773047e8" translate="yes" xml:space="preserve">
          <source>When the current element is an array, you may also call &lt;a href=&quot;qcborstreamreader#isLengthKnown&quot;&gt;isLengthKnown&lt;/a&gt;() to find out if the array's size is explicit in the CBOR stream. If it is, that size can be obtained by calling &lt;a href=&quot;qcborstreamreader#length&quot;&gt;length&lt;/a&gt;().</source>
          <target state="translated">현재 요소가 배열 인 경우 &lt;a href=&quot;qcborstreamreader#isLengthKnown&quot;&gt;isLengthKnown&lt;/a&gt; ()을 호출 하여 CBOR 스트림에서 배열의 크기가 명시 적인지 확인할 수도 있습니다 . 그렇다면 &lt;a href=&quot;qcborstreamreader#length&quot;&gt;길이&lt;/a&gt; () 를 호출하여 해당 크기를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f84400c746d8fc0a5a48647d3e3c7ab1cfd364c9" translate="yes" xml:space="preserve">
          <source>When the current file changes for local operations, this signal is emitted with the new file name as the</source>
          <target state="translated">현재 파일이 로컬 작업을 위해 변경되면이 신호는 새 파일 이름으로</target>
        </trans-unit>
        <trans-unit id="0a86295fc3e43e6a47bc831aed3e39216c7b217d" translate="yes" xml:space="preserve">
          <source>When the current file changes, this signal is emitted with the new file URL as the</source>
          <target state="translated">현재 파일이 변경되면이 신호는 새 파일 URL과 함께</target>
        </trans-unit>
        <trans-unit id="8d02ddfa1e09fd4df4941f2aea01335858653f59" translate="yes" xml:space="preserve">
          <source>When the current loop changes, &lt;a href=&quot;qabstractanimation&quot;&gt;QAbstractAnimation&lt;/a&gt; emits the &lt;a href=&quot;qabstractanimation#currentLoopChanged&quot;&gt;currentLoopChanged&lt;/a&gt;() signal.</source>
          <target state="translated">현재 루프가 변경되면 &lt;a href=&quot;qabstractanimation&quot;&gt;QAbstractAnimation&lt;/a&gt; 은 &lt;a href=&quot;qabstractanimation#currentLoopChanged&quot;&gt;currentLoopChanged&lt;/a&gt; () 신호를 방출합니다 .</target>
        </trans-unit>
        <trans-unit id="0cfe43b8f234528af4d27981c91186f3fac30622" translate="yes" xml:space="preserve">
          <source>When the current size of the cache is greater than the &lt;a href=&quot;qnetworkdiskcache#maximumCacheSize&quot;&gt;maximumCacheSize&lt;/a&gt;() older cache files are removed until the total size is less then 90% of &lt;a href=&quot;qnetworkdiskcache#maximumCacheSize&quot;&gt;maximumCacheSize&lt;/a&gt;() starting with the oldest ones first using the file creation date to determine how old a cache file is.</source>
          <target state="translated">캐시의 현재 크기가 &lt;a href=&quot;qnetworkdiskcache#maximumCacheSize&quot;&gt;maximumCacheSize&lt;/a&gt; () 보다 큰 경우 총 크기가 파일 생성 날짜를 사용하여 가장 오래된 파일부터 시작하여 &lt;a href=&quot;qnetworkdiskcache#maximumCacheSize&quot;&gt;maximumCacheSize&lt;/a&gt; () 의 90 %보다 작을 때까지 이전 캐시 파일이 제거되어 캐시 파일의 수 를 결정합니다. 입니다.</target>
        </trans-unit>
        <trans-unit id="3e61c9290a3e31fccfacad9bcadb7f0ab37cb158" translate="yes" xml:space="preserve">
          <source>When the cursor is moved and the underlying formatting attributes change, the &lt;a href=&quot;qtextedit#currentCharFormatChanged&quot;&gt;currentCharFormatChanged&lt;/a&gt;() signal is emitted to reflect the new attributes at the new cursor position.</source>
          <target state="translated">커서가 이동하고 기본 형식 속성이 변경되면 &lt;a href=&quot;qtextedit#currentCharFormatChanged&quot;&gt;currentCharFormatChanged&lt;/a&gt; () 신호가 생성되어 새 커서 위치에서 새 속성이 반영됩니다.</target>
        </trans-unit>
        <trans-unit id="0bcf3c2857361e33820b911b748bda8d3e8f2499" translate="yes" xml:space="preserve">
          <source>When the cursor is over an object that can be used in a connection, the object will be highlighted.</source>
          <target state="translated">커서가 연결에 사용될 수있는 객체 위에 있으면 객체가 강조 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="d5828b4053e945be1fe64d76bbf73ddc4acecf13" translate="yes" xml:space="preserve">
          <source>When the dark theme is in use, different &lt;a href=&quot;#pre-defined-shades&quot;&gt;shades&lt;/a&gt; of the pre-defined colors are used by default:</source>
          <target state="translated">어두운 테마 를 사용하는 경우 기본적으로 미리 정의 된 색상의 다른 &lt;a href=&quot;#pre-defined-shades&quot;&gt;음영&lt;/a&gt; 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3e63c161b63a9e90882d13f563f0753fdc02220f" translate="yes" xml:space="preserve">
          <source>When the dark theme is in use, different &lt;a href=&quot;qtquickcontrols2-material#pre-defined-shades&quot;&gt;shades&lt;/a&gt; of the pre-defined colors are used by default:</source>
          <target state="translated">어두운 테마 를 사용하는 경우 기본적으로 미리 정의 된 색상의 다른 &lt;a href=&quot;qtquickcontrols2-material#pre-defined-shades&quot;&gt;음영&lt;/a&gt; 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="aa15325522b12e3e10e05b6e7845de4c15cc9516" translate="yes" xml:space="preserve">
          <source>When the data has been set, the model must let the views know that some data has changed. This is done by emitting the &lt;a href=&quot;qabstractitemmodel#dataChanged&quot;&gt;dataChanged()&lt;/a&gt; signal. Since only one item of data has changed, the range of items specified in the signal is limited to just one model index.</source>
          <target state="translated">데이터가 설정되면 모델은 일부 데이터가 변경되었음을 뷰에 알려야합니다. 이것은 &lt;a href=&quot;qabstractitemmodel#dataChanged&quot;&gt;dataChanged ()&lt;/a&gt; 신호 를 방출하여 수행됩니다 . 하나의 데이터 항목 만 변경되었으므로 신호에 지정된 항목 범위는 하나의 모델 색인으로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="268c6bc406e79834c8bfc145b96838dee4c8962b" translate="yes" xml:space="preserve">
          <source>When the default OpenGL &lt;a href=&quot;qtquick-visualcanvas-scenegraph&quot;&gt;scene graph&lt;/a&gt; backend is in use, images can also be supplied in compressed texture files. The content must be a simple RGB(A) format 2D texture. Supported compression schemes are only limited by the underlying OpenGL driver and GPU. The following container file formats are supported:</source>
          <target state="translated">기본 OpenGL &lt;a href=&quot;qtquick-visualcanvas-scenegraph&quot;&gt;장면 그래프&lt;/a&gt; 백엔드를 사용하는 경우 압축 된 텍스처 파일로 이미지를 제공 할 수도 있습니다. 콘텐츠는 단순한 RGB (A) 형식 2D 텍스처 여야합니다. 지원되는 압축 체계는 기본 OpenGL 드라이버 및 GPU에 의해서만 제한됩니다. 다음 컨테이너 파일 형식이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="39d841b77292d3e68d73048948b5c24756c32f98" translate="yes" xml:space="preserve">
          <source>When the default OpenGL &lt;a href=&quot;qtquick-visualcanvas-scenegraph#&quot;&gt;scene graph&lt;/a&gt; backend is in use, images can also be supplied in compressed texture files. The content must be a simple RGB(A) format 2D texture. Supported compression schemes are only limited by the underlying OpenGL driver and GPU. The following container file formats are supported:</source>
          <target state="translated">기본 OpenGL &lt;a href=&quot;qtquick-visualcanvas-scenegraph#&quot;&gt;장면 그래프&lt;/a&gt; 백엔드를 사용중인 경우 이미지를 압축 된 텍스처 파일로 제공 할 수도 있습니다. 내용은 간단한 RGB (A) 형식 2D 텍스처 여야합니다. 지원되는 압축 방식은 기본 OpenGL 드라이버 및 GPU에 의해서만 제한됩니다. 다음과 같은 컨테이너 파일 형식이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="64564ede097c86de33c3d219ff3f4d6b55c9c533" translate="yes" xml:space="preserve">
          <source>When the dialog needs to generate a set of preview pages, the &lt;a href=&quot;qprintpreviewdialog#paintRequested&quot;&gt;paintRequested&lt;/a&gt;() signal will be emitted. You can use the exact same code for the actual printing as for having the preview generated, including calling &lt;a href=&quot;qprinter#newPage&quot;&gt;QPrinter::newPage&lt;/a&gt;() to start a new page in the preview. Connect a slot to the &lt;a href=&quot;qprintpreviewdialog#paintRequested&quot;&gt;paintRequested&lt;/a&gt;() signal, where you draw onto the &lt;a href=&quot;qprinter&quot;&gt;QPrinter&lt;/a&gt; object that is passed into the slot.</source>
          <target state="translated">대화 상자에서 미리보기 페이지 세트를 생성 &lt;a href=&quot;qprintpreviewdialog#paintRequested&quot;&gt;해야하는&lt;/a&gt; 경우 paintRequested () 신호가 생성됩니다. &lt;a href=&quot;qprinter#newPage&quot;&gt;QPrinter :: newPage&lt;/a&gt; ()를 호출 하여 미리보기에서 새 페이지를 시작하는 것을 포함하여 미리보기를 생성 할 때와 동일한 코드를 실제 인쇄에 사용할 수 있습니다 . 슬롯을 &lt;a href=&quot;qprintpreviewdialog#paintRequested&quot;&gt;paintRequested&lt;/a&gt; () 신호에 연결합니다. 여기서 슬롯으로 전달되는 &lt;a href=&quot;qprinter&quot;&gt;QPrinter&lt;/a&gt; 객체를 그 립니다 .</target>
        </trans-unit>
        <trans-unit id="442b26fe36b5b6b28e8fee4c93f0f0f9179a4be0" translate="yes" xml:space="preserve">
          <source>When the disk cache is disabled, via &lt;a href=&quot;qt#ApplicationAttribute-enum&quot;&gt;Qt::AA_DisableShaderDiskCache&lt;/a&gt; for example, or the OpenGL context has no support for context binaries, calling this function is equivalent to &lt;a href=&quot;qopenglshaderprogram#addShaderFromSourceCode&quot;&gt;addShaderFromSourceCode&lt;/a&gt;().</source>
          <target state="translated">예를 들어 &lt;a href=&quot;qt#ApplicationAttribute-enum&quot;&gt;Qt :: AA_DisableShaderDiskCache&lt;/a&gt; 를 통해 디스크 캐시가 비활성화 되거나 OpenGL 컨텍스트가 컨텍스트 바이너리를 지원하지 않는 경우이 함수를 호출하는 것은 &lt;a href=&quot;qopenglshaderprogram#addShaderFromSourceCode&quot;&gt;addShaderFromSourceCode&lt;/a&gt; () 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="9a274b9868a858f6451036974bc85cd45ebacc98" translate="yes" xml:space="preserve">
          <source>When the disk cache is disabled, via &lt;a href=&quot;qt#ApplicationAttribute-enum&quot;&gt;Qt::AA_DisableShaderDiskCache&lt;/a&gt; for example, or the OpenGL context has no support for context binaries, calling this function is equivalent to &lt;a href=&quot;qopenglshaderprogram#addShaderFromSourceFile&quot;&gt;addShaderFromSourceFile&lt;/a&gt;().</source>
          <target state="translated">예를 들어 &lt;a href=&quot;qt#ApplicationAttribute-enum&quot;&gt;Qt :: AA_DisableShaderDiskCache&lt;/a&gt; 를 통해 디스크 캐시를 비활성화 하거나 OpenGL 컨텍스트에서 컨텍스트 바이너리를 지원하지 않는 경우이 함수를 호출하는 것은 &lt;a href=&quot;qopenglshaderprogram#addShaderFromSourceFile&quot;&gt;addShaderFromSourceFile&lt;/a&gt; () 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="cfc128bc4fe84e02bab33b87cc2068b75786b6b9" translate="yes" xml:space="preserve">
          <source>When the dock widget lays out its contents it asks the style for these pixel metrics: &lt;code&gt;PM_DockWidgetSeparatorExtent&lt;/code&gt;, &lt;code&gt;PM_DockWidgetTitleBarButtonMargin&lt;/code&gt;, &lt;code&gt;PM_DockWidgetFrameWidth&lt;/code&gt;, and &lt;code&gt;PM_DockWidgetTitleMargin&lt;/code&gt;. It also calculates the bounding rectangles of the float and close buttons with &lt;code&gt;SE_DockWidgetCloseButton&lt;/code&gt; and &lt;code&gt;SE_DockWidgetFloatButton&lt;/code&gt;.</source>
          <target state="translated">도크 위젯은 내용을 배치 할 때 &lt;code&gt;PM_DockWidgetSeparatorExtent&lt;/code&gt; , &lt;code&gt;PM_DockWidgetTitleBarButtonMargin&lt;/code&gt; , &lt;code&gt;PM_DockWidgetFrameWidth&lt;/code&gt; 및 &lt;code&gt;PM_DockWidgetTitleMargin&lt;/code&gt; 픽셀 스타일의 스타일을 묻습니다 . 또한 &lt;code&gt;SE_DockWidgetCloseButton&lt;/code&gt; 및 &lt;code&gt;SE_DockWidgetFloatButton&lt;/code&gt; 을 사용하여 float 및 close 버튼의 경계 사각형을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="dc07829ed23956686aa2110b6aa13a3a31695d82" translate="yes" xml:space="preserve">
          <source>When the edit strategy is &lt;a href=&quot;qsqltablemodel#EditStrategy-enum&quot;&gt;OnManualSubmit&lt;/a&gt;, deletion of rows from the database is delayed until &lt;a href=&quot;qsqltablemodel#submitAll&quot;&gt;submitAll&lt;/a&gt;() is called.</source>
          <target state="translated">편집 전략이 &lt;a href=&quot;qsqltablemodel#EditStrategy-enum&quot;&gt;OnManualSubmit&lt;/a&gt; 인 경우 데이터베이스에서 행 삭제는 &lt;a href=&quot;qsqltablemodel#submitAll&quot;&gt;submitAll&lt;/a&gt; ()이 호출 될 때까지 지연 됩니다.</target>
        </trans-unit>
        <trans-unit id="69d60b285999f455929d7c354ec16df415cf791e" translate="yes" xml:space="preserve">
          <source>When the error occurs in code that uses the &lt;a href=&quot;qaxfactory#QAXCLASS&quot;&gt;QAXCLASS&lt;/a&gt;() or QAXFACTORY_DEFAULT() macro, the widget class had no constructor that can be used by the default factory. Either add a standard widget constructor or implement a custom factory that doesn't require one.</source>
          <target state="translated">&lt;a href=&quot;qaxfactory#QAXCLASS&quot;&gt;QAXCLASS&lt;/a&gt; () 또는 QAXFACTORY_DEFAULT () 매크로 를 사용하는 코드에서 오류가 발생 하면 위젯 클래스에 기본 팩토리에서 사용할 수있는 생성자가 없습니다. 표준 위젯 생성자를 추가하거나 필요하지 않은 사용자 정의 팩토리를 구현하십시오.</target>
        </trans-unit>
        <trans-unit id="5ce533133f051ef361f68d445640b0f45e1ae0bd" translate="yes" xml:space="preserve">
          <source>When the error occurs in code that uses the &lt;a href=&quot;qaxfactory#QAXFACTORY_DEFAULT&quot;&gt;QAXFACTORY_DEFAULT&lt;/a&gt;() macro, the widget class had no constructor that can be used by the default factory. Either add a standard widget constructor or implement a custom factory that doesn't require one.</source>
          <target state="translated">&lt;a href=&quot;qaxfactory#QAXFACTORY_DEFAULT&quot;&gt;QAXFACTORY_DEFAULT&lt;/a&gt; () 매크로 를 사용하는 코드에서 오류가 발생 하면 위젯 클래스에 기본 팩토리에서 사용할 수있는 생성자가 없었습니다. 표준 위젯 생성자를 추가하거나 필요하지 않은 사용자 정의 팩토리를 구현하십시오.</target>
        </trans-unit>
        <trans-unit id="67528e55cc72382a76299d4a29a6d404185ca633" translate="yes" xml:space="preserve">
          <source>When the error occurs in code that uses the &lt;a href=&quot;qaxfactory#QAXFACTORY_EXPORT&quot;&gt;QAXFACTORY_EXPORT&lt;/a&gt;() macro, the &lt;a href=&quot;qaxfactory&quot;&gt;QAxFactory&lt;/a&gt; subclass had no appropriate constructor. Provide a public class constructor like</source>
          <target state="translated">&lt;a href=&quot;qaxfactory#QAXFACTORY_EXPORT&quot;&gt;QAXFACTORY_EXPORT&lt;/a&gt; () 매크로 를 사용하는 코드에서 오류가 발생 하면 &lt;a href=&quot;qaxfactory&quot;&gt;QAxFactory&lt;/a&gt; 서브 클래스에 적절한 생성자가 없습니다. 다음과 같은 공개 클래스 생성자를 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="667bcb82ac840306758fe028ef02a3142d64c33c" translate="yes" xml:space="preserve">
          <source>When the file was created (may not be not supported on UNIX).</source>
          <target state="translated">파일이 작성된시기 (UNIX에서는 지원되지 않을 수 있음).</target>
        </trans-unit>
        <trans-unit id="b25b4b7cadd51d3809c6192d30e9736fd31ceee0" translate="yes" xml:space="preserve">
          <source>When the file was most recently accessed (e.g. read or written to).</source>
          <target state="translated">파일이 가장 최근에 액세스 된시기 (예 : 읽기 또는 쓰기)</target>
        </trans-unit>
        <trans-unit id="4c27bd30e3a44efb1b186d178c93f6ceaf40ce32" translate="yes" xml:space="preserve">
          <source>When the file was most recently modified.</source>
          <target state="translated">파일이 가장 최근에 수정 된시기</target>
        </trans-unit>
        <trans-unit id="d5d340431973f92573daf9a19dcdb9fd00b81737" translate="yes" xml:space="preserve">
          <source>When the file's metadata was last changed.</source>
          <target state="translated">파일의 메타 데이터가 마지막으로 변경된시기</target>
        </trans-unit>
        <trans-unit id="0ed30361bc54f69e5900b60fbcec5e46b66fc62b" translate="yes" xml:space="preserve">
          <source>When the filter object's &lt;a href=&quot;qobject#eventFilter&quot;&gt;eventFilter()&lt;/a&gt; implementation is called, it can accept or reject the event, and allow or deny further processing of the event. If all the event filters allow further processing of an event (by each returning &lt;code&gt;false&lt;/code&gt;), the event is sent to the target object itself. If one of them stops processing (by returning &lt;code&gt;true&lt;/code&gt;), the target and any later event filters do not get to see the event at all.</source>
          <target state="translated">필터 객체의 &lt;a href=&quot;qobject#eventFilter&quot;&gt;eventFilter ()&lt;/a&gt; 구현이 호출되면 이벤트를 수락 또는 거부하고 추가 이벤트 처리를 허용하거나 거부 할 수 있습니다. 모든 이벤트 필터가 이벤트의 추가 처리를 허용하면 (각각 &lt;code&gt;false&lt;/code&gt; 를 리턴 하여) 이벤트가 대상 오브젝트 자체로 전송됩니다. 이들 중 하나가 처리를 중지하면 ( &lt;code&gt;true&lt;/code&gt; 를 리턴 하여) 대상 및 이후의 이벤트 필터가 이벤트를 전혀 보지 못하게됩니다.</target>
        </trans-unit>
        <trans-unit id="837b081290388ef24310dab55793156db9eb9dfc" translate="yes" xml:space="preserve">
          <source>When the first touch point is detected, the destination widget is determined firstly by the location on screen and secondly by the propagation rules.</source>
          <target state="translated">제 1 터치 포인트가 검출 될 때, 목적지 위젯은 먼저 스크린상의 위치에 의해 그리고 두번째는 전파 규칙에 의해 결정된다.</target>
        </trans-unit>
        <trans-unit id="da3ee5de937f78331baaaed7a12ec8f5b5ae3e7b" translate="yes" xml:space="preserve">
          <source>When the format is extended and a</source>
          <target state="translated">형식이 확장되고</target>
        </trans-unit>
        <trans-unit id="60ff0e9974e90a3bb46faadb679db78b2703c023" translate="yes" xml:space="preserve">
          <source>When the format is not explicitly set via this function, the format returned by &lt;a href=&quot;qsurfaceformat#defaultFormat&quot;&gt;QSurfaceFormat::defaultFormat&lt;/a&gt;() will be used. This means that when having multiple OpenGL widgets, individual calls to this function can be replaced by one single call to &lt;a href=&quot;qsurfaceformat#setDefaultFormat&quot;&gt;QSurfaceFormat::setDefaultFormat&lt;/a&gt;() before creating the first widget.</source>
          <target state="translated">이 함수를 통해 형식을 명시 적으로 설정하지 않으면 &lt;a href=&quot;qsurfaceformat#defaultFormat&quot;&gt;QSurfaceFormat :: defaultFormat&lt;/a&gt; ()에서 반환 한 형식 이 사용됩니다. 이는 여러 OpenGL 위젯이 있는 경우 첫 번째 위젯을 작성하기 &lt;a href=&quot;qsurfaceformat#setDefaultFormat&quot;&gt;전에이&lt;/a&gt; 함수에 대한 개별 호출을 QSurfaceFormat :: setDefaultFormat ()에 대한 단일 호출로 대체 할 수 있음을 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="2beb1fd6e4f28222293604d7f4d897a896d350d1" translate="yes" xml:space="preserve">
          <source>When the format is not explicitly set via this function, the format returned by &lt;a href=&quot;qsurfaceformat#defaultFormat&quot;&gt;QSurfaceFormat::defaultFormat&lt;/a&gt;() will be used. This means that when having multiple contexts, individual calls to this function can be replaced by one single call to &lt;a href=&quot;qsurfaceformat#setDefaultFormat&quot;&gt;QSurfaceFormat::setDefaultFormat&lt;/a&gt;() before creating the first context.</source>
          <target state="translated">이 함수를 통해 형식을 명시 적으로 설정하지 않으면 &lt;a href=&quot;qsurfaceformat#defaultFormat&quot;&gt;QSurfaceFormat :: defaultFormat&lt;/a&gt; ()에서 반환 한 형식 이 사용됩니다. 이는 여러 컨텍스트가있는 경우 첫 번째 컨텍스트를 작성하기 &lt;a href=&quot;qsurfaceformat#setDefaultFormat&quot;&gt;전에이&lt;/a&gt; 함수에 대한 개별 호출을 QSurfaceFormat :: setDefaultFormat ()에 대한 단일 호출로 대체 할 수 있음을 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="00713dadf93099ecb982ada3e77d69bdabc871f2" translate="yes" xml:space="preserve">
          <source>When the format is not explicitly set via this function, the format returned by &lt;a href=&quot;qsurfaceformat#defaultFormat&quot;&gt;QSurfaceFormat::defaultFormat&lt;/a&gt;() will be used. This means that when having multiple windows, individual calls to this function can be replaced by one single call to &lt;a href=&quot;qsurfaceformat#setDefaultFormat&quot;&gt;QSurfaceFormat::setDefaultFormat&lt;/a&gt;() before creating the first window.</source>
          <target state="translated">이 함수를 통해 형식을 명시 적으로 설정하지 않으면 &lt;a href=&quot;qsurfaceformat#defaultFormat&quot;&gt;QSurfaceFormat :: defaultFormat&lt;/a&gt; ()에서 반환 한 형식 이 사용됩니다. 이는 여러 개의 창이있을 때 첫 번째 창을 만들기 &lt;a href=&quot;qsurfaceformat#setDefaultFormat&quot;&gt;전에이&lt;/a&gt; 함수에 대한 개별 호출을 QSurfaceFormat :: setDefaultFormat ()에 대한 단일 호출로 대체 할 수 있음을 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="25d8d569194c95628c8a9af91c9b0f5b8ee86128" translate="yes" xml:space="preserve">
          <source>When the given</source>
          <target state="translated">주어진 때</target>
        </trans-unit>
        <trans-unit id="a84c5e22d39ffceb346211bc14286a14c79f8784" translate="yes" xml:space="preserve">
          <source>When the horizontal alignment of a text item is not explicitly set, the text element is automatically aligned to the natural reading direction of the text. By default left-to-right text like English is aligned to the left side of the text area, and right-to-left text like Arabic is aligned to the right side of the text area. The alignment of a text element with empty text takes its alignment cue from &lt;a href=&quot;qinputmethod#inputDirection-prop&quot;&gt;QInputMethod::inputDirection&lt;/a&gt;(), which is based on the active system locale.</source>
          <target state="translated">텍스트 항목의 가로 정렬이 명시 적으로 설정되지 않은 경우 텍스트 요소는 텍스트의 자연스러운 읽기 방향에 자동으로 정렬됩니다. 기본적으로 영어와 같은 왼쪽에서 오른쪽 텍스트는 텍스트 영역의 왼쪽에 정렬되고 아랍어와 같은 오른쪽에서 왼쪽 텍스트는 텍스트 영역의 오른쪽에 정렬됩니다. 빈 텍스트를 가진 텍스트 요소의 정렬 은 활성 시스템 로케일을 기반으로하는 &lt;a href=&quot;qinputmethod#inputDirection-prop&quot;&gt;QInputMethod :: inputDirection&lt;/a&gt; () 에서 정렬 큐를 가져 옵니다.</target>
        </trans-unit>
        <trans-unit id="2f163bb4526ffce4c5d0c97da01d544fc9ab7648" translate="yes" xml:space="preserve">
          <source>When the image is ready, &lt;a href=&quot;qml-qtquick-canvas#imageLoaded-signal&quot;&gt;imageLoaded&lt;/a&gt; will be emitted. The loaded image can be unloaded by the &lt;a href=&quot;qml-qtquick-canvas#unloadImage-method&quot;&gt;unloadImage()&lt;/a&gt; method.</source>
          <target state="translated">이미지가 준비되면 &lt;a href=&quot;qml-qtquick-canvas#imageLoaded-signal&quot;&gt;imageLoaded&lt;/a&gt; 가 방출됩니다. 로드 된 이미지는 &lt;a href=&quot;qml-qtquick-canvas#unloadImage-method&quot;&gt;unloadImage ()&lt;/a&gt; 메소드 로 언로드 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4722dd5405336bb1dc515fbc7e7e1db0a5d91ef2" translate="yes" xml:space="preserve">
          <source>When the image is scaled, regions of the source image are scaled or tiled to create the displayed border image in the following way:</source>
          <target state="translated">이미지의 크기가 조정되면 소스 이미지의 영역이 다음과 같은 방식으로 표시된 테두리 이미지를 만들기 위해 크기가 조정되거나 바둑판 식으로 배열됩니다.</target>
        </trans-unit>
        <trans-unit id="cb1a5c40c986de8b7e66b324c82e0775e3788bc6" translate="yes" xml:space="preserve">
          <source>When the image is used, the color table must be large enough to have entries for all the pixel/index values present in the image, otherwise the results are undefined.</source>
          <target state="translated">이미지를 사용하는 경우 색상 표는 이미지에있는 모든 픽셀 / 인덱스 값에 대한 항목을 가질 수있을 정도로 커야합니다. 그렇지 않으면 결과가 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a62a0ab3afb30df54c7a307954a51b28f0879b31" translate="yes" xml:space="preserve">
          <source>When the indexing process has finished, the search engine can be used to search through the index for a given term using the search() function. When the search input is passed to the search engine, the &lt;a href=&quot;qhelpsearchengine#searchingStarted&quot;&gt;searchingStarted&lt;/a&gt;() signal is emitted. When the search finishes, the &lt;a href=&quot;qhelpsearchengine#searchingFinished&quot;&gt;searchingFinished&lt;/a&gt;() signal is emitted. The search process can be stopped by calling &lt;a href=&quot;qhelpsearchengine#cancelSearching&quot;&gt;cancelSearching&lt;/a&gt;().</source>
          <target state="translated">색인 작성 프로세스가 완료되면 검색 엔진을 사용하여 search () 함수를 사용하여 주어진 용어에 대한 색인을 검색 할 수 있습니다. 검색 입력이 검색 엔진에 전달되면 &lt;a href=&quot;qhelpsearchengine#searchingStarted&quot;&gt;searchingStarted&lt;/a&gt; () 신호가 발생합니다. 검색이 완료되면 &lt;a href=&quot;qhelpsearchengine#searchingFinished&quot;&gt;searchingFinished&lt;/a&gt; () 신호가 발생합니다. &lt;a href=&quot;qhelpsearchengine#cancelSearching&quot;&gt;cancelSearching&lt;/a&gt; () 을 호출하여 검색 프로세스를 중지 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="abed85d30a721e876a4399c7b26aa9eed3e46ead" translate="yes" xml:space="preserve">
          <source>When the input method requires the UI to update the contents of a selection list, it will emit the &lt;a href=&quot;qml-qtquick-virtualkeyboard-inputmethod#selectionListChanged-signal&quot;&gt;InputMethod::selectionListChanged&lt;/a&gt; signal. Likewise, if the input method requires the UI to highlight an item in the list, it will emit the &lt;a href=&quot;qml-qtquick-virtualkeyboard-inputmethod#selectionListActiveItemChanged-signal&quot;&gt;InputMethod::selectionListActiveItemChanged&lt;/a&gt; signal.</source>
          <target state="translated">입력 방법에서 UI가 선택 목록의 내용을 업데이트해야하는 경우 &lt;a href=&quot;qml-qtquick-virtualkeyboard-inputmethod#selectionListChanged-signal&quot;&gt;InputMethod :: selectionListChanged&lt;/a&gt; 신호를 생성합니다. 마찬가지로 입력 방법이 UI에서 목록의 항목을 강조 표시해야하는 경우 &lt;a href=&quot;qml-qtquick-virtualkeyboard-inputmethod#selectionListActiveItemChanged-signal&quot;&gt;InputMethod :: selectionListActiveItemChanged&lt;/a&gt; 신호를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="af13632c6936ddc6476f8bec001c16d3ccdb1b88" translate="yes" xml:space="preserve">
          <source>When the interaction is completed we strongly recommend releasing the user interaction semaphore with a call to &lt;a href=&quot;qsessionmanager#release&quot;&gt;release&lt;/a&gt;(). This way, other applications may get the chance to interact with the user while your application is still busy saving data. (The semaphore is implicitly released when the application exits.)</source>
          <target state="translated">상호 작용이 완료되면 &lt;a href=&quot;qsessionmanager#release&quot;&gt;릴리스&lt;/a&gt; ()를 호출하여 사용자 상호 작용 세마포어를 해제하는 것이 좋습니다 . 이런 식으로, 다른 응용 프로그램은 응용 프로그램이 여전히 데이터를 저장하는 동안 사용자와 상호 작용할 수 있습니다. (세마포는 응용 프로그램이 종료 될 때 암시 적으로 해제됩니다.)</target>
        </trans-unit>
        <trans-unit id="a08dbc79fd5ced7fe929c3d064e1b645b21d39b2" translate="yes" xml:space="preserve">
          <source>When the labels are editable the user will be able to change the range of the axis conveniently by editing any of the labels. This feature is only supported for the &lt;a href=&quot;qvalueaxis&quot;&gt;QValueAxis&lt;/a&gt; and the &lt;a href=&quot;qdatetimeaxis&quot;&gt;QDateTimeAxis&lt;/a&gt;.</source>
          <target state="translated">라벨을 편집 할 수 있으면 라벨을 편집하여 축의 범위를 편리하게 변경할 수 있습니다. 이 기능은 지원됩니다 &lt;a href=&quot;qvalueaxis&quot;&gt;QValueAxis&lt;/a&gt; 와 &lt;a href=&quot;qdatetimeaxis&quot;&gt;QDateTimeAxis&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="16aac338dd8507181525a913639f185cb93e3d46" translate="yes" xml:space="preserve">
          <source>When the layout direction is set on a widget, it will propagate to the widget's children, but not to a child that is a window and not to a child for which setLayoutDirection() has been explicitly called. Also, child widgets added</source>
          <target state="translated">레이아웃 방향이 위젯에 설정되면 위젯의 자식으로 전파되지만 setLayoutDirection ()이 명시 적으로 호출 된 자식이 아닌 창인 자식에는 전달되지 않습니다. 또한 하위 위젯이 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="757e208faf34bd91da1b625ef70871bbc740552e" translate="yes" xml:space="preserve">
          <source>When the layout's geometry changes, &lt;a href=&quot;graphicsview#qgraphicslayout&quot;&gt;QGraphicsLayout&lt;/a&gt; immediately rearranges all of its managed items by calling &lt;a href=&quot;qgraphicslayoutitem#setGeometry&quot;&gt;setGeometry&lt;/a&gt;() on each item. This rearrangement is called</source>
          <target state="translated">레이아웃의 지오메트리가 변경되면 &lt;a href=&quot;graphicsview#qgraphicslayout&quot;&gt;QGraphicsLayout&lt;/a&gt; 은 각 항목에서 &lt;a href=&quot;qgraphicslayoutitem#setGeometry&quot;&gt;setGeometry&lt;/a&gt; ()를 호출하여 모든 관리되는 항목을 즉시 재정렬합니다 . 이 재 배열을</target>
        </trans-unit>
        <trans-unit id="14d52274c262e663bee4bb6936d376e01f9d9786" translate="yes" xml:space="preserve">
          <source>When the layout's geometry changes, QGraphicsLayout immediately rearranges all of its managed items by calling &lt;a href=&quot;qgraphicslayoutitem#setGeometry&quot;&gt;setGeometry&lt;/a&gt;() on each item. This rearrangement is called</source>
          <target state="translated">레이아웃의 지오메트리가 변경되면 QGraphicsLayout 은 각 항목에 대해 &lt;a href=&quot;qgraphicslayoutitem#setGeometry&quot;&gt;setGeometry&lt;/a&gt; ()를 호출하여 관리되는 모든 항목을 즉시 재정렬합니다 . 이 재 배열을</target>
        </trans-unit>
        <trans-unit id="a4868cf3fc8227fd58f7cf326e3d937144f921d5" translate="yes" xml:space="preserve">
          <source>When the locale is not specified, the default system locale is used instead.</source>
          <target state="translated">로케일을 지정하지 않으면 기본 시스템 로케일이 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d8c8da609611d53dcc5b14869c74793f679093e3" translate="yes" xml:space="preserve">
          <source>When the machine is in state &lt;code&gt;s2&lt;/code&gt;, the machine will play the default animation for the property &lt;code&gt;fooBar&lt;/code&gt; since this property is assigned by &lt;code&gt;s2&lt;/code&gt;.</source>
          <target state="translated">머신이 &lt;code&gt;s2&lt;/code&gt; 상태 인 경우, 이 프로퍼티는 &lt;code&gt;s2&lt;/code&gt; 에 의해 지정되므로 머신은 &lt;code&gt;fooBar&lt;/code&gt; 프로퍼티에 대한 기본 애니메이션을 재생합니다 .</target>
        </trans-unit>
        <trans-unit id="e08c3bd224be28ab8da0d15a3e80244ae34b5521" translate="yes" xml:space="preserve">
          <source>When the map is displayed, each possible geographic coordinate that is visible will map to some pixel X and Y coordinate on the screen. To perform conversions between these two, Map provides the &lt;a href=&quot;qml-qtlocation-map#toCoordinate-method&quot;&gt;toCoordinate&lt;/a&gt; and &lt;a href=&quot;qml-qtlocation-map#fromCoordinate-method&quot;&gt;fromCoordinate&lt;/a&gt; functions, which are of general utility.</source>
          <target state="translated">지도가 표시되면 보이는 각 지리적 좌표가 화면의 일부 픽셀 X 및 Y 좌표에 매핑됩니다. 이 둘 사이의 변환을 수행하기 위해 Map은 일반적으로 유용한 &lt;a href=&quot;qml-qtlocation-map#toCoordinate-method&quot;&gt;toCoordinate&lt;/a&gt; 및 &lt;a href=&quot;qml-qtlocation-map#fromCoordinate-method&quot;&gt;fromCoordinate&lt;/a&gt; 기능을 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="c5d7b44152d91a8b1270640c20696e9ece89a8be" translate="yes" xml:space="preserve">
          <source>When the mode changes, &lt;a href=&quot;qsslsocket&quot;&gt;QSslSocket&lt;/a&gt; emits &lt;a href=&quot;qsslsocket#modeChanged&quot;&gt;modeChanged&lt;/a&gt;()</source>
          <target state="translated">모드가 변경되면 &lt;a href=&quot;qsslsocket&quot;&gt;QSslSocket&lt;/a&gt; 은 &lt;a href=&quot;qsslsocket#modeChanged&quot;&gt;modeChanged&lt;/a&gt; ()를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="f34a87a12fe283ceded3dd1abbd77031338a6cd0" translate="yes" xml:space="preserve">
          <source>When the model has multiple roles, &lt;code&gt;textRole&lt;/code&gt; can be set to determine which role should be displayed.</source>
          <target state="translated">모델에 여러 역할이있는 경우 &lt;code&gt;textRole&lt;/code&gt; 을 설정하여 표시 할 역할을 결정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="da9a781aefd18e2834be4ea55a33a7e98b410511" translate="yes" xml:space="preserve">
          <source>When the model has multiple roles, textRole can be set to determine which role should be displayed.</source>
          <target state="translated">모델에 여러 역할이있는 경우 textRole을 설정하여 표시 할 역할을 결정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="422c5c92ca52eb6e2a6538c002cc9123999cfea0" translate="yes" xml:space="preserve">
          <source>When the mouse is pressed, the &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt; changes to the</source>
          <target state="translated">마우스를 누르면 &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;사각형&lt;/a&gt; 이</target>
        </trans-unit>
        <trans-unit id="5657ede20e143f6d442db18b090e618d804d1de7" translate="yes" xml:space="preserve">
          <source>When the mouse moves over the item,</source>
          <target state="translated">마우스가 항목 위로 이동하면</target>
        </trans-unit>
        <trans-unit id="91af59e60e5984086456c7ad2a2054d514962b50" translate="yes" xml:space="preserve">
          <source>When the number of commands on a stack exceedes the stack's undoLimit, commands are deleted from the bottom of the stack. Macro commands (commands with child commands) are treated as one command. The default value is 0, which means that there is no limit.</source>
          <target state="translated">스택의 명령 수가 스택의 undoLimit를 초과하면 스택의 맨 아래에서 명령이 삭제됩니다. 매크로 명령 (자식 명령이있는 명령)은 하나의 명령으로 취급됩니다. 기본값은 0이며, 이는 제한이 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="001d63f0ced7bf39910f29efe7f6f5fd05b477ff" translate="yes" xml:space="preserve">
          <source>When the number of matches cannot be determined in advance, a common idiom is to use &lt;a href=&quot;qregexp#cap&quot;&gt;cap&lt;/a&gt;() in a loop. For example:</source>
          <target state="translated">일치 횟수를 미리 결정할 수없는 경우 일반적인 관용구는 루프에서 &lt;a href=&quot;qregexp#cap&quot;&gt;cap&lt;/a&gt; () 을 사용 하는 것입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="19d271264efc628bb86bca221e850d0c5cb77458" translate="yes" xml:space="preserve">
          <source>When the object supports multiple selections (e.g. in a word processor), this adds a new selection, otherwise it replaces the previous selection.</source>
          <target state="translated">객체가 다중 선택을 지원할 때 (예 : 워드 프로세서에서), 이것은 새로운 선택을 추가하고, 그렇지 않으면 이전 선택을 대체합니다.</target>
        </trans-unit>
        <trans-unit id="73cf6131f4a582c72bc9f9330edcb48af4fcc81f" translate="yes" xml:space="preserve">
          <source>When the page is inserted into a wizard using &lt;a href=&quot;qwizard#addPage&quot;&gt;QWizard::addPage&lt;/a&gt;() or &lt;a href=&quot;qwizard#setPage&quot;&gt;QWizard::setPage&lt;/a&gt;(), the parent is automatically set to be the wizard.</source>
          <target state="translated">&lt;a href=&quot;qwizard#addPage&quot;&gt;QWizard :: addPage&lt;/a&gt; () 또는 &lt;a href=&quot;qwizard#setPage&quot;&gt;QWizard :: setPage&lt;/a&gt; ()를 사용하여 페이지를 마법사에 삽입 하면 상위가 자동으로 마법사로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="35fc6c728ad882d547072f431eb37b1425e9f468" translate="yes" xml:space="preserve">
          <source>When the paint event occurs, the update region has normally been erased, so you are painting on the widget's background.</source>
          <target state="translated">페인트 이벤트가 발생하면 일반적으로 업데이트 영역이 지워 지므로 위젯 배경에 페인팅됩니다.</target>
        </trans-unit>
        <trans-unit id="f30c7c3f40f1a872547881cd7951c22cee36c1cd" translate="yes" xml:space="preserve">
          <source>When the parameter is set to &lt;a href=&quot;qopengltexture#DepthStencilMode-enum&quot;&gt;DepthMode&lt;/a&gt;, then accessing it from the shader will access the depth component as a single float, as normal. But when the parameter is set to &lt;a href=&quot;qopengltexture#DepthStencilMode-enum&quot;&gt;StencilMode&lt;/a&gt;, the shader will access the stencil component.</source>
          <target state="translated">매개 변수가 &lt;a href=&quot;qopengltexture#DepthStencilMode-enum&quot;&gt;DepthMode&lt;/a&gt; 로 설정 되면 셰이더에서 매개 변수에 액세스하면 평소 와 같이 깊이 구성 요소에 단일 부동 소수점으로 액세스합니다. 그러나 매개 변수가 &lt;a href=&quot;qopengltexture#DepthStencilMode-enum&quot;&gt;StencilMode&lt;/a&gt; 로 설정 되면 셰이더는 스텐실 구성 요소에 액세스합니다.</target>
        </trans-unit>
        <trans-unit id="2375fc19af6a76757eb823a66fb6127ba87e61c2" translate="yes" xml:space="preserve">
          <source>When the parser encounters an error, it signals the event by making &lt;a href=&quot;qurl#isValid&quot;&gt;isValid&lt;/a&gt;() return false and &lt;a href=&quot;qurl#toString&quot;&gt;toString&lt;/a&gt;() / &lt;a href=&quot;qurl#toEncoded&quot;&gt;toEncoded&lt;/a&gt;() return an empty string. If it is necessary to show the user the reason why the URL failed to parse, the error condition can be obtained from &lt;a href=&quot;qurl&quot;&gt;QUrl&lt;/a&gt; by calling &lt;a href=&quot;qurl#errorString&quot;&gt;errorString&lt;/a&gt;(). Note that this message is highly technical and may not make sense to end-users.</source>
          <target state="translated">파서에 오류가 발생하면 &lt;a href=&quot;qurl#isValid&quot;&gt;isValid&lt;/a&gt; ()가 false를 반환하고 &lt;a href=&quot;qurl#toString&quot;&gt;toString&lt;/a&gt; () / &lt;a href=&quot;qurl#toEncoded&quot;&gt;toEncoded&lt;/a&gt; ()가 빈 문자열을 반환하도록 하여 이벤트를 알립니다 . URL 구문 분석에 실패한 이유를 사용자에게 표시 &lt;a href=&quot;qurl&quot;&gt;해야하는 경우 &lt;/a&gt;&lt;a href=&quot;qurl#errorString&quot;&gt;errorString&lt;/a&gt; () 을 호출 하여 QUrl 에서 오류 조건을 얻을 수 있습니다 . 이 메시지는 매우 기술적이며 최종 사용자에게는 의미가 없을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="811d686f479044d2209c2819d361efa6d361ce38" translate="yes" xml:space="preserve">
          <source>When the parser encounters an error, it signals the event by making &lt;a href=&quot;qurl#isValid&quot;&gt;isValid&lt;/a&gt;() return false and &lt;a href=&quot;qurl#toString&quot;&gt;toString&lt;/a&gt;() / &lt;a href=&quot;qurl#toEncoded&quot;&gt;toEncoded&lt;/a&gt;() return an empty string. If it is necessary to show the user the reason why the URL failed to parse, the error condition can be obtained from QUrl by calling &lt;a href=&quot;qurl#errorString&quot;&gt;errorString&lt;/a&gt;(). Note that this message is highly technical and may not make sense to end-users.</source>
          <target state="translated">파서에 오류가 발생하면 &lt;a href=&quot;qurl#isValid&quot;&gt;isValid&lt;/a&gt; ()가 false를 반환하고 &lt;a href=&quot;qurl#toString&quot;&gt;toString&lt;/a&gt; () / &lt;a href=&quot;qurl#toEncoded&quot;&gt;toEncoded&lt;/a&gt; ()가 빈 문자열을 반환하도록 하여 이벤트에 신호를 보냅니다 . 사용자에게 URL이 구문 분석에 실패한 이유를 표시해야하는 경우 &lt;a href=&quot;qurl#errorString&quot;&gt;errorString&lt;/a&gt; () 을 호출하여 QUrl에서 오류 조건을 얻을 수 있습니다 . 이 메시지는 매우 기술적이며 최종 사용자에게는 이해가되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="50ba901eeb2daca251dbecc6e227457e431d3835" translate="yes" xml:space="preserve">
          <source>When the player object is buffering; this property holds the percentage of the temporary buffer that is filled. The buffer will need to reach 100% filled before playback can start or resume, at which time &lt;a href=&quot;qmediaplayer#mediaStatus-prop&quot;&gt;mediaStatus&lt;/a&gt;() will return &lt;a href=&quot;qmediaplayer#MediaStatus-enum&quot;&gt;BufferedMedia&lt;/a&gt; or &lt;a href=&quot;qmediaplayer#MediaStatus-enum&quot;&gt;BufferingMedia&lt;/a&gt;. If the value is anything lower than &lt;code&gt;100&lt;/code&gt;, &lt;a href=&quot;qmediaplayer#mediaStatus-prop&quot;&gt;mediaStatus&lt;/a&gt;() will return &lt;a href=&quot;qmediaplayer#MediaStatus-enum&quot;&gt;StalledMedia&lt;/a&gt;.</source>
          <target state="translated">플레이어 객체가 버퍼링 될 때; 이 특성은 채워진 임시 버퍼의 백분율을 보유합니다. 재생을 시작하거나 다시 시작하기 전에 버퍼가 100 % 채워져 있어야하며, 이때 &lt;a href=&quot;qmediaplayer#mediaStatus-prop&quot;&gt;mediaStatus&lt;/a&gt; ()는 &lt;a href=&quot;qmediaplayer#MediaStatus-enum&quot;&gt;BufferedMedia&lt;/a&gt; 또는 &lt;a href=&quot;qmediaplayer#MediaStatus-enum&quot;&gt;BufferingMedia를&lt;/a&gt; 반환 합니다. 값이 무엇보다 낮은 경우 &lt;code&gt;100&lt;/code&gt; , &lt;a href=&quot;qmediaplayer#mediaStatus-prop&quot;&gt;mediaStatus는&lt;/a&gt; () 반환합니다 &lt;a href=&quot;qmediaplayer#MediaStatus-enum&quot;&gt;StalledMedia을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="da64dfb7cefdbeef317abcd7e43d7b305a5ee3ab" translate="yes" xml:space="preserve">
          <source>When the popup actually receives focus, &lt;a href=&quot;qml-qtquick-controls2-popup#activeFocus-prop&quot;&gt;activeFocus&lt;/a&gt; will be &lt;code&gt;true&lt;/code&gt;. For more information, see &lt;a href=&quot;qtquick-input-focus&quot;&gt;Keyboard Focus in Qt Quick&lt;/a&gt;.</source>
          <target state="translated">팝업이 실제로 포커스를 받으면 &lt;a href=&quot;qml-qtquick-controls2-popup#activeFocus-prop&quot;&gt;activeFocus&lt;/a&gt; 가 &lt;code&gt;true&lt;/code&gt; 입니다. 자세한 내용 &lt;a href=&quot;qtquick-input-focus&quot;&gt;은 Qt Quick의 키보드 포커스를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d6f2faeb8b71e0aaa953aece87da658ef327fd51" translate="yes" xml:space="preserve">
          <source>When the popup actually receives focus, activeFocus will be &lt;code&gt;true&lt;/code&gt;. For more information, see &lt;a href=&quot;qtquick-input-focus&quot;&gt;Keyboard Focus in Qt Quick&lt;/a&gt;.</source>
          <target state="translated">팝업이 실제로 포커스를 받으면 activeFocus가 &lt;code&gt;true&lt;/code&gt; 입니다. 자세한 내용 &lt;a href=&quot;qtquick-input-focus&quot;&gt;은 Qt Quick의 키보드 포커스를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c1bac0637a72484b23805b1cfc6b209249217f5b" translate="yes" xml:space="preserve">
          <source>When the process exits, &lt;a href=&quot;qprocess&quot;&gt;QProcess&lt;/a&gt; reenters the &lt;a href=&quot;qprocess#ProcessState-enum&quot;&gt;NotRunning&lt;/a&gt; state (the initial state), and emits &lt;a href=&quot;qprocess#finished&quot;&gt;finished&lt;/a&gt;().</source>
          <target state="translated">프로세스가 종료되면 &lt;a href=&quot;qprocess&quot;&gt;QProcess&lt;/a&gt; 는 &lt;a href=&quot;qprocess#ProcessState-enum&quot;&gt;NotRunning&lt;/a&gt; 상태 (초기 상태)로 다시 들어가 &lt;a href=&quot;qprocess#finished&quot;&gt;종료&lt;/a&gt; () 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="166deb4e86216777686c8338ec5e1b04fbb74123" translate="yes" xml:space="preserve">
          <source>When the process exits, QProcess reenters the &lt;a href=&quot;qprocess#ProcessState-enum&quot;&gt;NotRunning&lt;/a&gt; state (the initial state), and emits &lt;a href=&quot;qprocess#finished&quot;&gt;finished&lt;/a&gt;().</source>
          <target state="translated">프로세스가 종료되면 QProcess는 &lt;a href=&quot;qprocess#ProcessState-enum&quot;&gt;NotRunning&lt;/a&gt; 상태 (초기 상태)로 다시 들어가고 &lt;a href=&quot;qprocess#finished&quot;&gt;완료 됨&lt;/a&gt; ()을 내 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="48359f3ebe88aa74d829db24de3e755c6a235ddd" translate="yes" xml:space="preserve">
          <source>When the property is &lt;a href=&quot;qt#CursorMoveStyle-enum&quot;&gt;Qt::LogicalMoveStyle&lt;/a&gt; (the default), within a LTR text block, increase cursor position when pressing left arrow key, decrease cursor position when pressing the right arrow key. If the text block is right to left, the opposite behavior applies.</source>
          <target state="translated">속성이 &lt;a href=&quot;qt#CursorMoveStyle-enum&quot;&gt;Qt :: LogicalMoveStyle&lt;/a&gt; (기본값) 인 경우 LTR 텍스트 블록 내에서 왼쪽 화살표 키를 누르면 커서 위치가 증가하고 오른쪽 화살표 키를 누르면 커서 위치가 감소합니다. 텍스트 블록이 오른쪽에서 왼쪽이면 반대 동작이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="8bce9d7a133b3737e2c5d22d038d7b3c4e7911f8" translate="yes" xml:space="preserve">
          <source>When the property is set to &lt;a href=&quot;qcalendarwidget#SelectionMode-enum&quot;&gt;NoSelection&lt;/a&gt;, the user will be unable to select dates, but they can still be selected programmatically. Note that the date that is selected when the property is set to &lt;a href=&quot;qcalendarwidget#SelectionMode-enum&quot;&gt;NoSelection&lt;/a&gt; will still be the selected date of the calendar.</source>
          <target state="translated">속성이 &lt;a href=&quot;qcalendarwidget#SelectionMode-enum&quot;&gt;NoSelection&lt;/a&gt; 으로 설정 되면 사용자는 날짜를 선택할 수 없지만 프로그래밍 방식으로 선택할 수는 있습니다. 속성이 &lt;a href=&quot;qcalendarwidget#SelectionMode-enum&quot;&gt;NoSelection&lt;/a&gt; 으로 설정 될 때 선택된 날짜는 여전히 달력의 선택된 날짜입니다.</target>
        </trans-unit>
        <trans-unit id="1fdcbc355a573b53369d224635c5476baea07222" translate="yes" xml:space="preserve">
          <source>When the property is set to false, these controls are hidden.</source>
          <target state="translated">속성이 false로 설정되면 이러한 컨트롤이 숨겨집니다.</target>
        </trans-unit>
        <trans-unit id="aa8094b9e2a50ed05d31d86aa20fac7cfb61c508" translate="yes" xml:space="preserve">
          <source>When the renderer reaches a leaf node of the framegraph, it collects together all of the state specified by the path from the leaf node to the root node. This defines the state used to render a section of the frame. If you are interested in the internals of Qt 3D, this collection of state is called a</source>
          <target state="translated">렌더러는 프레임 그래프의 리프 노드에 도달하면 리프 노드에서 루트 노드까지의 경로로 지정된 모든 상태를 수집합니다. 프레임의 섹션을 렌더링하는 데 사용되는 상태를 정의합니다. Qt 3D의 내부에 관심이 있다면이 상태 모음을</target>
        </trans-unit>
        <trans-unit id="db214d0296a6a87ece4578bc42783f851f457093" translate="yes" xml:space="preserve">
          <source>When the request is processed and a reply is available, it should be sent using the &lt;code&gt;QDBusMessage&lt;/code&gt; object that was obtained. In our example, the reply code could be something as follows:</source>
          <target state="translated">요청이 처리되고 응답이 사용 가능하면, 획득 한 &lt;code&gt;QDBusMessage&lt;/code&gt; 오브젝트를 사용하여 요청을 보내야 합니다. 이 예에서 응답 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="53d591cc65e5ee2ed7378bddbef5b69a1bcfde7b" translate="yes" xml:space="preserve">
          <source>When the results of an &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt; are returned in a sequence of &lt;a href=&quot;qxmlresultitems&quot;&gt;result items&lt;/a&gt;, atomic values in the sequence are treated as instances of &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt;. Suppose that instead of serializing the results of the &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt; as XML, we process the results programatically. Modify the standard Qt XML Patterns code sequence to call the overload of &lt;a href=&quot;qxmlquery#evaluateTo&quot;&gt;QXmlQuery::evaluateTo&lt;/a&gt;() that populates a sequence of &lt;a href=&quot;qxmlresultitems&quot;&gt;result items&lt;/a&gt; with the &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt; results:</source>
          <target state="translated">결과 때 &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery에이&lt;/a&gt; 시퀀스에서 반환되는 &lt;a href=&quot;qxmlresultitems&quot;&gt;결과 항목&lt;/a&gt; 의 순서로 원자 값은 인스턴스로 취급 &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; . &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt; 의 결과 를 XML로 직렬화하는 대신 결과를 프로그래밍 방식으로 처리 한다고 가정합니다 . 의 과부하 호출하는 표준 Qt는 XML 패턴 코드 시퀀스를 수정 &lt;a href=&quot;qxmlquery#evaluateTo&quot;&gt;QXmlQuery :: evaluateTo&lt;/a&gt; 의 순서 웁니다 () &lt;a href=&quot;qxmlresultitems&quot;&gt;결과 항목&lt;/a&gt; 와 &lt;a href=&quot;xmlprocessing&quot;&gt;는 XQuery&lt;/a&gt; 결과 :</target>
        </trans-unit>
        <trans-unit id="351834125e0c92d0f208676bc4e74950d662675c" translate="yes" xml:space="preserve">
          <source>When the results of an XQuery are returned in a sequence of &lt;a href=&quot;qxmlresultitems&quot;&gt;result items&lt;/a&gt;, atomic values in the sequence are treated as instances of &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt;. Suppose that instead of serializing the results of the XQuery as XML, we process the results programatically. Modify the standard Qt XML Patterns code sequence to call the overload of &lt;a href=&quot;qxmlquery#evaluateTo&quot;&gt;QXmlQuery::evaluateTo&lt;/a&gt;() that populates a sequence of &lt;a href=&quot;qxmlresultitems&quot;&gt;result items&lt;/a&gt; with the XQuery results:</source>
          <target state="translated">XQuery의 &lt;a href=&quot;qxmlresultitems&quot;&gt;결과&lt;/a&gt; 가 일련의 결과 항목 으로 리턴되면 순서의 원자 값이 &lt;a href=&quot;qvariant&quot;&gt;QVariant의&lt;/a&gt; 인스턴스로 처리됩니다 . XQuery의 결과를 XML로 직렬화하는 대신 결과를 프로그래밍 방식으로 처리한다고 가정하십시오. 일련의 &lt;a href=&quot;qxmlresultitems&quot;&gt;결과 항목&lt;/a&gt; 을 XQuery 결과로 채우는 &lt;a href=&quot;qxmlquery#evaluateTo&quot;&gt;QXmlQuery :: evaluateTo&lt;/a&gt; () 의 오버로드를 호출하도록 표준 Qt XML 패턴 코드 시퀀스를 수정하십시오 .</target>
        </trans-unit>
        <trans-unit id="763552f30b01b66449cf8883bed75293d360c6fc" translate="yes" xml:space="preserve">
          <source>When the return value is &lt;code&gt;false&lt;/code&gt;, vertex array object support is not available. This is not an error: on systems with OpenGL 2.x or OpenGL ES 2.0 vertex array objects may not be supported. The application is free to continue execution in this case, but it then has to be prepared to operate in a VAO-less manner too. This means that instead of merely calling &lt;a href=&quot;qopenglvertexarrayobject#bind&quot;&gt;bind&lt;/a&gt;(), the value of &lt;a href=&quot;qopenglvertexarrayobject#isCreated&quot;&gt;isCreated&lt;/a&gt;() must be checked and the vertex arrays has to be initialized in the traditional way when there is no vertex array object present.</source>
          <target state="translated">반환 값이 &lt;code&gt;false&lt;/code&gt; 인 경우 정점 배열 객체 지원을 사용할 수 없습니다. 이것은 오류가 아닙니다. OpenGL 2.x 또는 OpenGL ES 2.0 정점 배열 객체가있는 시스템에서는 지원되지 않을 수 있습니다. 이 경우 응용 프로그램을 계속 실행할 수 있지만 VAO없는 방식으로 작동 할 수 있도록 준비해야합니다. 즉 , &lt;a href=&quot;qopenglvertexarrayobject#bind&quot;&gt;bind&lt;/a&gt; ()를 호출하는 대신 &lt;a href=&quot;qopenglvertexarrayobject#isCreated&quot;&gt;isCreated&lt;/a&gt; () 의 값을 확인하고 정점 배열 객체가 없을 때 정점 배열을 전통적인 방식으로 초기화해야합니다.</target>
        </trans-unit>
        <trans-unit id="446681578342ec9dac4cdce0d061b46969bca33b" translate="yes" xml:space="preserve">
          <source>When the run type is set to Manual, calling trigger will make the compute command be executed for the next</source>
          <target state="translated">실행 유형이 수동으로 설정되면 트리거를 호출하면 다음에 계산 명령이 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="cbc6fc235d0cf1450284a0b09b674e76a1fb4c28" translate="yes" xml:space="preserve">
          <source>When the sample count is greater than 1, &lt;a href=&quot;qvulkanwindow&quot;&gt;QVulkanWindow&lt;/a&gt; will create a multisample color buffer instead of simply targeting the swapchain's images. The rendering in the multisample buffer will get resolved into the non-multisample buffers at the end of each frame.</source>
          <target state="translated">샘플 카운트가 1보다 크면 &lt;a href=&quot;qvulkanwindow&quot;&gt;QVulkanWindow&lt;/a&gt; 는 단순히 스왑 체인 이미지를 대상으로하는 대신 멀티 샘플 컬러 버퍼를 생성합니다. 멀티 샘플 버퍼의 렌더링은 각 프레임의 끝에서 비 멀티 샘플 버퍼로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="a0108434fca29b4ba915f772a93d81ad894fc73c" translate="yes" xml:space="preserve">
          <source>When the scene graph processes the request, it will call &lt;a href=&quot;qquickitem#updatePolish&quot;&gt;updatePolish&lt;/a&gt;() on this item.</source>
          <target state="translated">장면 그래프가 요청을 처리 할 때이 항목에 대해 &lt;a href=&quot;qquickitem#updatePolish&quot;&gt;updatePolish&lt;/a&gt; ()를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="79ad0782b661b14989a03456b369b188f17379b0" translate="yes" xml:space="preserve">
          <source>When the scene is active, this functions returns the scene's current focus item, or &lt;code&gt;nullptr&lt;/code&gt; if no item currently has focus. When the scene is inactive, this functions returns the item that will gain input focus when the scene becomes active.</source>
          <target state="translated">장면이 활성화되면이 함수는 장면의 현재 초점 항목을 반환하거나 현재 초점이있는 항목 이 없으면 &lt;code&gt;nullptr&lt;/code&gt; 을 반환합니다 . 장면이 비활성화되면이 기능은 장면이 활성화 될 때 입력 초점을 얻는 항목을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9df9de9d839910e5f63e81af88c3113617106dce" translate="yes" xml:space="preserve">
          <source>When the scene is rendered, any item whose width or height, transformed to the target view, is smaller that minimumRenderSize(), will not be rendered. If an item is not rendered and it clips its children items they will also not be rendered. Set this value to speed up rendering of scenes with many objects rendered on a zoomed out view.</source>
          <target state="translated">장면을 렌더링 할 때 대상 뷰로 변환 된 너비 또는 높이가 minimumRenderSize ()보다 작은 항목은 렌더링되지 않습니다. 항목이 렌더링되지 않고 하위 항목을 자르면 렌더링되지 않습니다. 축소 된 뷰에서 렌더링되는 많은 객체가있는 장면의 렌더링 속도를 높이려면이 값을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="0a43ef95854a2f8ebe7bf8d74d52b1e7933022c7" translate="yes" xml:space="preserve">
          <source>When the script has been executed,</source>
          <target state="translated">스크립트가 실행되면</target>
        </trans-unit>
        <trans-unit id="d413663e989f70315f8c202cae18ed2f762ace07" translate="yes" xml:space="preserve">
          <source>When the scroll bars change value, we need to update the widget position, i.e., find the part of the widget that is to be drawn in the viewport:</source>
          <target state="translated">스크롤 바의 값이 변경되면 위젯 위치를 업데이트해야합니다. 즉, 뷰포트에서 그릴 위젯 부분을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="7e550de4fcd183b4278cd6cc624e2d0424a701cc" translate="yes" xml:space="preserve">
          <source>When the selected test users that you have added to your alpha or beta program purchase in-app products in your application, they will make actual purchases and will be charged for them. For testing purchases, you can register the e-mail addresses that should have testing access, under &lt;b&gt;Settings&lt;/b&gt; in the developer console. The users with these e-mail addresses can purchase your in-app products without being charged for the purchase, and the transaction is canceled automatically at a later stage.</source>
          <target state="translated">알파 또는 베타 프로그램에 추가 한 선택한 테스트 사용자가 응용 프로그램에서 인앱 제품을 구매하면 실제 구매가 이루어지고 비용이 청구됩니다. 구매 테스트의 경우 개발자 콘솔의 &lt;b&gt;설정&lt;/b&gt; 에서 테스트 액세스 권한이 있어야하는 이메일 주소를 등록 할 수 있습니다 . 이러한 전자 메일 주소를 가진 사용자는 구매 비용이 청구되지 않고 인앱 제품을 구매할 수 있으며 나중에 거래가 자동으로 취소됩니다.</target>
        </trans-unit>
        <trans-unit id="afec543fcd1da24c4160336959d91fe3f583bac8" translate="yes" xml:space="preserve">
          <source>When the selection changes and the dialog is accepted, this signal is emitted with the (possibly empty) list of selected</source>
          <target state="translated">선택이 변경되고 대화 상자가 승인되면이 신호는 선택된 (비어 있음) 목록과 함께 방출됩니다.</target>
        </trans-unit>
        <trans-unit id="904758544b0861950c3ab2beb21af5f0d9b36272" translate="yes" xml:space="preserve">
          <source>When the selection changes and the dialog is accepted, this signal is emitted with the (possibly empty) selected</source>
          <target state="translated">선택이 변경되고 대화 상자가 승인되면이 신호는 (비어있을 수 있음)이 선택된 상태로 방출됩니다.</target>
        </trans-unit>
        <trans-unit id="e7de7d16009452344b6e4636a059a260b420895c" translate="yes" xml:space="preserve">
          <source>When the selection changes for local operations and the dialog is accepted, this signal is emitted with the (possibly empty) list of</source>
          <target state="translated">로컬 작업에 대한 선택이 변경되고 대화 상자가 승인되면이 신호는 (비어있을 수 있음) 목록으로 방출됩니다.</target>
        </trans-unit>
        <trans-unit id="f75edcab2adacd739be3bdebfa6bfa280edf2de0" translate="yes" xml:space="preserve">
          <source>When the selection changes for local operations and the dialog is accepted, this signal is emitted with the (possibly empty) selected</source>
          <target state="translated">로컬 작업에 대한 선택이 변경되고 대화 상자가 승인되면이 신호는 (비어있을 수 있음)이 선택된 상태로 방출됩니다.</target>
        </trans-unit>
        <trans-unit id="5131d672b1bc3aac6ebdcf6c8b2ac57826b0e767" translate="yes" xml:space="preserve">
          <source>When the selection mode changes and the selected item is visible</source>
          <target state="translated">선택 모드가 변경되고 선택한 항목이 보이는 경우</target>
        </trans-unit>
        <trans-unit id="31520c42359fb2cf1348100dd78b79ebb3e7ffdd" translate="yes" xml:space="preserve">
          <source>When the sensor is started with buffering option, values are collected from that moment onwards. There is no pre-existing buffer that can be utilized.</source>
          <target state="translated">버퍼링 옵션으로 센서를 시작하면 그 순간부터 값이 수집됩니다. 사용할 수있는 기존 버퍼가 없습니다.</target>
        </trans-unit>
        <trans-unit id="ce0fb53c6b17959f1dc8d1d19b6e99cbdbd76451" translate="yes" xml:space="preserve">
          <source>When the server receives the ClientHello message with a cookie, it generates a new cookie as described above. This new cookie is compared to the one found in the ClientHello message.</source>
          <target state="translated">서버는 쿠키와 함께 ClientHello 메시지를 받으면 위에서 설명한대로 새 쿠키를 생성합니다. 이 새로운 쿠키는 ClientHello 메시지에있는 쿠키와 비교됩니다.</target>
        </trans-unit>
        <trans-unit id="f10b8edd85c55e75835eb4536f6583dfa1033451" translate="yes" xml:space="preserve">
          <source>When the service that this method call is sent to is already running, the method call is sent to it. If the service is not running yet, the D-Bus daemon is requested to autostart the service that is assigned to this service name. This is handled by .service files that are placed in a directory known to the D-Bus server. These files then each contain a service name and the path to a program that should be executed when this service name is requested.</source>
          <target state="translated">이 메소드 호출이 전송 된 서비스가 이미 실행 중이면 메소드 호출이 전송됩니다. 서비스가 아직 실행되고 있지 않으면이 서비스 이름에 할당 된 서비스를 자동 시작하도록 D-Bus 데몬이 요청됩니다. 이것은 D-Bus 서버에 알려진 디렉토리에있는 .service 파일에 의해 처리됩니다. 이 파일들은 각각 서비스 이름과이 서비스 이름이 요청 될 때 실행되어야하는 프로그램 경로를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="c0cd1279176cf81f0c6aca038bccf60c5d81a29f" translate="yes" xml:space="preserve">
          <source>When the shader program is used normally, the shader program's id will be created on demand.</source>
          <target state="translated">셰이더 프로그램이 정상적으로 사용될 때 셰이더 프로그램의 ID는 요청시 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="a62f09dbef147b4bf1f669c8ce754ebe864f003f" translate="yes" xml:space="preserve">
          <source>When the signal associated with this signal transition is emitted the guard condition is evaluated. In the guard condition the arguments of the signal can be used as demonstrated in the example below.</source>
          <target state="translated">이 신호 전이와 관련된 신호가 방출되면 보호 조건이 평가됩니다. 보호 조건에서 신호의 인수는 아래 예에서 설명 된대로 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="558725310a73c041dc3d4a5f9bb58e65f3b99606" translate="yes" xml:space="preserve">
          <source>When the signal is emitted, the &lt;a href=&quot;qabstractslider#sliderPosition-prop&quot;&gt;sliderPosition&lt;/a&gt; has been adjusted according to the action, but the &lt;a href=&quot;qabstractslider#value-prop&quot;&gt;value&lt;/a&gt; has not yet been propagated (meaning the &lt;a href=&quot;qabstractslider#valueChanged&quot;&gt;valueChanged&lt;/a&gt;() signal was not yet emitted), and the visual display has not been updated. In slots connected to this signal you can thus safely adjust any action by calling &lt;a href=&quot;qabstractslider#sliderPosition-prop&quot;&gt;setSliderPosition&lt;/a&gt;() yourself, based on both the action and the slider's value.</source>
          <target state="translated">신호가 방출 될 때 &lt;a href=&quot;qabstractslider#sliderPosition-prop&quot;&gt;슬라이더 위치&lt;/a&gt; 가 조치에 따라 조정되었지만 &lt;a href=&quot;qabstractslider#value-prop&quot;&gt;값&lt;/a&gt; 이 아직 전파되지 않았으며 ( &lt;a href=&quot;qabstractslider#valueChanged&quot;&gt;valueChanged&lt;/a&gt; () 신호가 아직 방출되지 않았 음을 의미 함 ) 시각적 표시가 업데이트되지 않았습니다. 이 신호에 연결된 슬롯 에서 액션과 슬라이더의 값에 따라 &lt;a href=&quot;qabstractslider#sliderPosition-prop&quot;&gt;setSliderPosition&lt;/a&gt; ()을 직접 호출하여 액션을 안전하게 조정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="908f9032f0a18c7bfa32894d77bc808328603452" translate="yes" xml:space="preserve">
          <source>When the source and target areas' sizes do not match, the source contents are stretched to fit into the target area. By passing a &lt;a href=&quot;qt#AspectRatioMode-enum&quot;&gt;Qt::AspectRatioMode&lt;/a&gt; to the rendering function you are using, you can choose to maintain or ignore the aspect ratio of the scene when the contents are stretched.</source>
          <target state="translated">소스와 대상 영역의 크기가 일치하지 않으면 소스 내용이 대상 영역에 맞게 늘어납니다. &lt;a href=&quot;qt#AspectRatioMode-enum&quot;&gt;Qt :: AspectRatioMode&lt;/a&gt; 를 사용중인 렌더링 기능에 전달 하면 내용이 늘어날 때 장면의 종횡비를 유지하거나 무시하도록 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b00e9d3dd0cfb3eafd24644444bab1097364474" translate="yes" xml:space="preserve">
          <source>When the source is static, the &lt;a href=&quot;qml-qtgraphicaleffects-dropshadow#cached-prop&quot;&gt;cached&lt;/a&gt; property can be set to allocate another buffer to avoid performing the blur every time it is drawn.</source>
          <target state="translated">소스가 정적 일 때 &lt;a href=&quot;qml-qtgraphicaleffects-dropshadow#cached-prop&quot;&gt;캐시 된&lt;/a&gt; 속성은 그릴 때마다 블러를 수행하지 않도록 다른 버퍼를 할당하도록 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ad8f5ada47559d8d884af8a03a452189fd6075c" translate="yes" xml:space="preserve">
          <source>When the space key is pressed, adding an item to the model, the new item will fade in and increase in scale over 400 milliseconds as it is added to the view. Also, any item that is displaced by the addition of a new item will animate to its new position in the view over 400 milliseconds, as specified by the &lt;code&gt;displaced&lt;/code&gt; transition.</source>
          <target state="translated">스페이스 키를 누르면 모델에 항목을 추가하면 새 항목이 사라지고 뷰에 추가 될 때 400 밀리 초 이상으로 스케일이 증가합니다. 또한, 새로운 아이템의 추가에 의해 변위 된 아이템은 &lt;code&gt;displaced&lt;/code&gt; 전이에 의해 지정된 바와 같이 400 밀리 초 이상 뷰에서 새로운 위치로 애니메이션 될 것이다 .</target>
        </trans-unit>
        <trans-unit id="a9fca68b12abe757685e2f8e3f26bf8a64e1d4fe" translate="yes" xml:space="preserve">
          <source>When the space key is pressed, three items are moved from index 5 to index 1. For each moved item, the &lt;code&gt;moveTransition&lt;/code&gt; sequence presumably animates the item's color to &quot;yellow&quot;, then animates it to its final position, then changes the item color back to &quot;lightsteelblue&quot; using a &lt;a href=&quot;qml-qtquick-scriptaction&quot;&gt;ScriptAction&lt;/a&gt;. However, when run, the transition does not produce the intended result:</source>
          <target state="translated">스페이스 키를 누르면 3 개의 항목이 인덱스 5에서 인덱스 1로 이동합니다. 각각의 이동 된 항목에 대해 &lt;code&gt;moveTransition&lt;/code&gt; 시퀀스는 항목의 색상을 &quot;노란색&quot;으로 애니메이션 한 다음 최종 위치로 애니메이션 한 다음 항목 색상을 다시 변경합니다. &quot;lightsteelblue&quot;는 사용하는 &lt;a href=&quot;qml-qtquick-scriptaction&quot;&gt;ScriptAction을&lt;/a&gt; . 그러나 실행시 전이로 인해 의도 한 결과가 생성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="aed377e3125e7efb3e464b02103995ebd5fa07a4" translate="yes" xml:space="preserve">
          <source>When the string is not already a valid URL, a best guess is performed, making various web related assumptions.</source>
          <target state="translated">문자열이 유효한 URL이 아닌 경우 다양한 웹 관련 가정을 수행하여 최선의 추측이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="8b456c366b0bedadf7f4c24ff98787915a0f574f" translate="yes" xml:space="preserve">
          <source>When the text changes the &lt;a href=&quot;qlineedit#textChanged&quot;&gt;textChanged&lt;/a&gt;() signal is emitted; when the text changes other than by calling &lt;a href=&quot;qlineedit#text-prop&quot;&gt;setText&lt;/a&gt;() the &lt;a href=&quot;qlineedit#textEdited&quot;&gt;textEdited&lt;/a&gt;() signal is emitted; when the cursor is moved the &lt;a href=&quot;qlineedit#cursorPositionChanged&quot;&gt;cursorPositionChanged&lt;/a&gt;() signal is emitted; and when the Return or Enter key is pressed the &lt;a href=&quot;qlineedit#returnPressed&quot;&gt;returnPressed&lt;/a&gt;() signal is emitted.</source>
          <target state="translated">텍스트가 변경되면 &lt;a href=&quot;qlineedit#textChanged&quot;&gt;textChanged&lt;/a&gt; () 신호가 방출됩니다. &lt;a href=&quot;qlineedit#text-prop&quot;&gt;setText&lt;/a&gt; () 를 호출하는 것 외에 텍스트가 변경 되면 &lt;a href=&quot;qlineedit#textEdited&quot;&gt;textEdited&lt;/a&gt; () 신호가 방출됩니다. 커서를 움직이면 &lt;a href=&quot;qlineedit#cursorPositionChanged&quot;&gt;cursorPositionChanged&lt;/a&gt; () 신호가 방출됩니다. Return 또는 Enter 키를 누르면 &lt;a href=&quot;qlineedit#returnPressed&quot;&gt;returnPressed&lt;/a&gt; () 신호가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="76aa286a7763afdcffbd10ec6e5b9d39bd8e0eec" translate="yes" xml:space="preserve">
          <source>When the texture coordinate is even, only the fractional part is used. When odd, the texture coordinate is set to &lt;code&gt;1 - fractional part&lt;/code&gt;. This value has been introduced in Qt 5.10.</source>
          <target state="translated">텍스처 좌표가 짝수이면 소수 부분 만 사용됩니다. 홀수 인 경우 텍스처 좌표는 &lt;code&gt;1 - fractional part&lt;/code&gt; 설정됩니다 . 이 값은 Qt 5.10에서 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="4630c4b073fe0b95c546ea9b15793119393a3a9b" translate="yes" xml:space="preserve">
          <source>When the thread is terminated, all threads waiting for the thread to finish will be woken up.</source>
          <target state="translated">스레드가 종료되면 스레드가 완료되기를 기다리는 모든 스레드가 깨어납니다.</target>
        </trans-unit>
        <trans-unit id="87fd2e26c464b557c4a3c28bad0e013a2a60bdaf" translate="yes" xml:space="preserve">
          <source>When the timeline is disabled, all items will have their regular values. When the timeline is enabled, the values of items are determined by the current frame and the keyframes.</source>
          <target state="translated">타임 라인이 비활성화되면 모든 항목이 일반 값을 갖게됩니다. 타임 라인이 활성화 된 경우 항목 값은 현재 프레임과 키 프레임에 의해 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="d8b9c7726d3aff7845aa848c6697f0885c506e1a" translate="yes" xml:space="preserve">
          <source>When the title bar is vertical, the &lt;a href=&quot;#vertical-ps&quot;&gt;:vertical&lt;/a&gt; pseudo class is set. In addition, depending on &lt;a href=&quot;qdockwidget#DockWidgetFeature-enum&quot;&gt;QDockWidget::DockWidgetFeature&lt;/a&gt;, the &lt;a href=&quot;#closable-ps&quot;&gt;:closable&lt;/a&gt;, &lt;a href=&quot;#floatable-ps&quot;&gt;:floatable&lt;/a&gt; and &lt;a href=&quot;#movable-ps&quot;&gt;:movable&lt;/a&gt; pseudo states are set.</source>
          <target state="translated">제목 표시 줄이 수직이면 &lt;a href=&quot;#vertical-ps&quot;&gt;: 수직&lt;/a&gt; 의사 클래스가 설정됩니다. 또한 &lt;a href=&quot;qdockwidget#DockWidgetFeature-enum&quot;&gt;QDockWidget :: DockWidgetFeature&lt;/a&gt; 에 따라 &lt;a href=&quot;#closable-ps&quot;&gt;: closable&lt;/a&gt; , &lt;a href=&quot;#floatable-ps&quot;&gt;: floatable&lt;/a&gt; 및 &lt;a href=&quot;#movable-ps&quot;&gt;: movable&lt;/a&gt; 의사 상태가 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="dcbf714b2e65ae5994ea2abb0210ddd12a11925f" translate="yes" xml:space="preserve">
          <source>When the title bar is vertical, the &lt;a href=&quot;stylesheet-reference#vertical-ps&quot;&gt;:vertical&lt;/a&gt; pseudo class is set. In addition, depending on &lt;a href=&quot;qdockwidget#DockWidgetFeature-enum&quot;&gt;QDockWidget::DockWidgetFeature&lt;/a&gt;, the &lt;a href=&quot;stylesheet-reference#closable-ps&quot;&gt;:closable&lt;/a&gt;, &lt;a href=&quot;stylesheet-reference#floatable-ps&quot;&gt;:floatable&lt;/a&gt; and &lt;a href=&quot;stylesheet-reference#movable-ps&quot;&gt;:movable&lt;/a&gt; pseudo states are set.</source>
          <target state="translated">제목 표시 줄이 세로이면 &lt;a href=&quot;stylesheet-reference#vertical-ps&quot;&gt;: vertical&lt;/a&gt; 의사 클래스가 설정됩니다. 또한 &lt;a href=&quot;qdockwidget#DockWidgetFeature-enum&quot;&gt;QDockWidget :: DockWidgetFeature&lt;/a&gt; 에 따라 &lt;a href=&quot;stylesheet-reference#closable-ps&quot;&gt;: closable&lt;/a&gt; , &lt;a href=&quot;stylesheet-reference#floatable-ps&quot;&gt;: floatable&lt;/a&gt; 및 &lt;a href=&quot;stylesheet-reference#movable-ps&quot;&gt;: movable&lt;/a&gt; 의사 상태가 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="cf6a38dec8a46a3efde082aa9bb646234ab5665d" translate="yes" xml:space="preserve">
          <source>When the traceEnd method is called, the input method may begin processing of the data contained in the trace object. After processing the data, the input method should destroy the object. This also removes the trace rendered to the screen.</source>
          <target state="translated">traceEnd 메소드가 호출되면 입력 메소드가 추적 오브젝트에 포함 된 데이터 처리를 시작할 수 있습니다. 데이터를 처리 한 후 입력 방법은 객체를 파괴해야합니다. 또한 화면에 렌더링 된 추적을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="5ed406ff23fcc29a091f1169edcf6e63e1f2b5ea" translate="yes" xml:space="preserve">
          <source>When the transition is initialized, the &lt;a href=&quot;qml-qtquick-propertyaction&quot;&gt;PropertyAction&lt;/a&gt;&lt;code&gt;target&lt;/code&gt; will be set to the respective &lt;a href=&quot;qml-qtquick-viewtransition&quot;&gt;ViewTransition&lt;/a&gt;.item for the transition and will later run with the correct item target as expected.</source>
          <target state="translated">전환이 초기화되면 &lt;a href=&quot;qml-qtquick-propertyaction&quot;&gt;PropertyAction &lt;/a&gt; &lt;code&gt;target&lt;/code&gt; 이 전환에 대한 해당 &lt;a href=&quot;qml-qtquick-viewtransition&quot;&gt;ViewTransition&lt;/a&gt; .item 으로 설정되고 나중에 예상대로 올바른 항목 대상으로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="a112026d8a84f01ac36a7325fb20f0691ad743ce" translate="yes" xml:space="preserve">
          <source>When the transition is initialized, the &lt;a href=&quot;qml-qtquick-propertyaction&quot;&gt;PropertyAction&lt;/a&gt;&lt;code&gt;target&lt;/code&gt; will be set to the respective ViewTransition.item for the transition and will later run with the correct item target as expected.</source>
          <target state="translated">전환이 초기화되면 &lt;a href=&quot;qml-qtquick-propertyaction&quot;&gt;PropertyAction &lt;/a&gt; &lt;code&gt;target&lt;/code&gt; 은 전환에 대한 각 ViewTransition.item으로 설정되고 나중에 예상대로 올바른 항목 대상으로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="61999efc5174872ead16b86264178dba1fb54b01" translate="yes" xml:space="preserve">
          <source>When the transition starts, the &lt;a href=&quot;qml-qtquick-controls-stackview&quot;&gt;StackView&lt;/a&gt; will search for a transition that matches the operation executed. There are three transitions to choose from: &lt;a href=&quot;qml-qtquick-controls-stackviewdelegate#pushTransition-prop&quot;&gt;pushTransition&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-controls-stackviewdelegate#popTransition-prop&quot;&gt;popTransition&lt;/a&gt;, and &lt;a href=&quot;qml-qtquick-controls-stackviewdelegate#replaceTransition-prop&quot;&gt;replaceTransition&lt;/a&gt;. Each implements how &lt;code&gt;enterItem&lt;/code&gt; should animate in, and &lt;code&gt;exitItem&lt;/code&gt; out. The transitions are collected inside a &lt;a href=&quot;qml-qtquick-controls-stackviewdelegate&quot;&gt;StackViewDelegate&lt;/a&gt; object assigned to &lt;a href=&quot;qml-qtquick-controls-stackview#delegate-prop&quot;&gt;delegate&lt;/a&gt;. By default, popTransition and replaceTransition will be the same as pushTransition, unless you set them to something else.</source>
          <target state="translated">전환이 시작되면 &lt;a href=&quot;qml-qtquick-controls-stackview&quot;&gt;StackView&lt;/a&gt; 는 실행 된 작업과 일치하는 전환을 검색합니다. &lt;a href=&quot;qml-qtquick-controls-stackviewdelegate#pushTransition-prop&quot;&gt;pushTransition&lt;/a&gt; , &lt;a href=&quot;qml-qtquick-controls-stackviewdelegate#popTransition-prop&quot;&gt;popTransition&lt;/a&gt; 및 &lt;a href=&quot;qml-qtquick-controls-stackviewdelegate#replaceTransition-prop&quot;&gt;replaceTransition의&lt;/a&gt; 세 가지 전환 중에서 선택할 수 있습니다 . 각각은 &lt;code&gt;enterItem&lt;/code&gt; 에 애니메이션을 적용하고 &lt;code&gt;exitItem&lt;/code&gt; 을 종료 하는 방법을 구현합니다 . 전환은 &lt;a href=&quot;qml-qtquick-controls-stackview#delegate-prop&quot;&gt;delegate에&lt;/a&gt; 할당 된 &lt;a href=&quot;qml-qtquick-controls-stackviewdelegate&quot;&gt;StackViewDelegate&lt;/a&gt; 객체 내에서 수집됩니다 . 기본적으로 popTransition 및 replaceTransition은 다른 것으로 설정하지 않는 한 pushTransition과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="b481fca32b65e43470c3c94e4e0c2377f104c54a" translate="yes" xml:space="preserve">
          <source>When the transition starts, the StackView will search for a transition that matches the operation executed. There are three transitions to choose from: &lt;a href=&quot;qml-qtquick-controls-stackviewdelegate#pushTransition-prop&quot;&gt;pushTransition&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-controls-stackviewdelegate#popTransition-prop&quot;&gt;popTransition&lt;/a&gt;, and &lt;a href=&quot;qml-qtquick-controls-stackviewdelegate#replaceTransition-prop&quot;&gt;replaceTransition&lt;/a&gt;. Each implements how &lt;code&gt;enterItem&lt;/code&gt; should animate in, and &lt;code&gt;exitItem&lt;/code&gt; out. The transitions are collected inside a &lt;a href=&quot;qml-qtquick-controls-stackviewdelegate&quot;&gt;StackViewDelegate&lt;/a&gt; object assigned to &lt;a href=&quot;qml-qtquick-controls-stackview#delegate-prop&quot;&gt;delegate&lt;/a&gt;. By default, popTransition and replaceTransition will be the same as pushTransition, unless you set them to something else.</source>
          <target state="translated">전환이 시작되면 StackView는 실행 된 작업과 일치하는 전환을 검색합니다. 선택할 수있는 전환에는 &lt;a href=&quot;qml-qtquick-controls-stackviewdelegate#pushTransition-prop&quot;&gt;pushTransition&lt;/a&gt; , &lt;a href=&quot;qml-qtquick-controls-stackviewdelegate#popTransition-prop&quot;&gt;popTransition&lt;/a&gt; , &lt;a href=&quot;qml-qtquick-controls-stackviewdelegate#replaceTransition-prop&quot;&gt;replaceTransition&lt;/a&gt; 세 가지가 있습니다 . 각각은 &lt;code&gt;enterItem&lt;/code&gt; 이 애니메이션으로 &lt;code&gt;exitItem&lt;/code&gt; 나가는 방법을 구현합니다 . 전환은 &lt;a href=&quot;qml-qtquick-controls-stackview#delegate-prop&quot;&gt;delegate에&lt;/a&gt; 할당 된 &lt;a href=&quot;qml-qtquick-controls-stackviewdelegate&quot;&gt;StackViewDelegate&lt;/a&gt; 객체 내부에 수집됩니다 . 기본적으로 popTransition 및 replaceTransition은 다른 것으로 설정하지 않는 한 pushTransition과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="89b086c5ef03dd1208f5e9b3c1c02fa2b6600cb5" translate="yes" xml:space="preserve">
          <source>When the type is &lt;code&gt;LineString&lt;/code&gt; the data ia a &lt;a href=&quot;qgeopath&quot;&gt;QGeoPath&lt;/a&gt;.</source>
          <target state="translated">유형이 &lt;code&gt;LineString&lt;/code&gt; 인 경우 데이터 ia a &lt;a href=&quot;qgeopath&quot;&gt;QGeoPath&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6627a2ffbe714cf5363a2179e7f88f8aa52c1d77" translate="yes" xml:space="preserve">
          <source>When the type is &lt;code&gt;MultiLineString&lt;/code&gt;, the data is a List of LineStrings.</source>
          <target state="translated">유형이 &lt;code&gt;MultiLineString&lt;/code&gt; 이면 데이터는 LineStrings 목록입니다.</target>
        </trans-unit>
        <trans-unit id="f684debed13b1e187fdab34246a351f68171025c" translate="yes" xml:space="preserve">
          <source>When the type is &lt;code&gt;MultiPoint&lt;/code&gt;, the data is a List of Points.</source>
          <target state="translated">유형이 &lt;code&gt;MultiPoint&lt;/code&gt; 이면 데이터는 포인트 목록입니다.</target>
        </trans-unit>
        <trans-unit id="65efa0e33ec24ae86c53c350f1ee9d661694a7b1" translate="yes" xml:space="preserve">
          <source>When the type is &lt;code&gt;MultiPolygon&lt;/code&gt;, the data is a List of Polygons.</source>
          <target state="translated">유형이 &lt;code&gt;MultiPolygon&lt;/code&gt; 이면 데이터는 다각형 목록입니다.</target>
        </trans-unit>
        <trans-unit id="dbc2b0b0072c28b487940a65dedc17930539d2ec" translate="yes" xml:space="preserve">
          <source>When the type is &lt;code&gt;Point&lt;/code&gt;, the data is a &lt;a href=&quot;qgeocircle&quot;&gt;QGeoCircle&lt;/a&gt; with the point coordinates stored in the center property.</source>
          <target state="translated">유형이 &lt;code&gt;Point&lt;/code&gt; 이면 데이터는 중심 속성에 점 좌표가 저장된 &lt;a href=&quot;qgeocircle&quot;&gt;QGeoCircle&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="23332dc4a0d7fb448b924e422877dc966cb8e77a" translate="yes" xml:space="preserve">
          <source>When the type is &lt;code&gt;Polygon&lt;/code&gt;, the data is a &lt;a href=&quot;qgeopolygon&quot;&gt;QGeoPolygon&lt;/a&gt; (holes are supported).</source>
          <target state="translated">유형이 &lt;code&gt;Polygon&lt;/code&gt; 이면 데이터는 &lt;a href=&quot;qgeopolygon&quot;&gt;QGeoPolygon입니다&lt;/a&gt; (구멍이 지원됨).</target>
        </trans-unit>
        <trans-unit id="37e47c478e8b7cde10b9e2d57a87561d517265a6" translate="yes" xml:space="preserve">
          <source>When the underlying rendering API is OpenGL, this function should return a mask where each bit represents graphics states changed by the &lt;a href=&quot;qsgrendernode#render&quot;&gt;render&lt;/a&gt;() function:</source>
          <target state="translated">기본 렌더링 API가 OpenGL 인 경우이 함수는 각 비트가 &lt;a href=&quot;qsgrendernode#render&quot;&gt;render&lt;/a&gt; () 함수에 의해 변경된 그래픽 상태를 나타내는 마스크를 반환해야 합니다.</target>
        </trans-unit>
        <trans-unit id="3151bd80e155cc711d1dfb4c28d12fa02d1b602b" translate="yes" xml:space="preserve">
          <source>When the update behavior is set to &lt;code&gt;NoPartialUpdate&lt;/code&gt;, there is no separate framebuffer object. In this case the returned value is the ID of the default framebuffer.</source>
          <target state="translated">업데이트 동작이 &lt;code&gt;NoPartialUpdate&lt;/code&gt; 로 설정되면 별도의 프레임 버퍼 객체가 없습니다. 이 경우 반환되는 값은 기본 프레임 버퍼의 ID입니다.</target>
        </trans-unit>
        <trans-unit id="38a70a3f9388a6d25db9221a160c7eb74efac68f" translate="yes" xml:space="preserve">
          <source>When the update mode is set to &lt;a href=&quot;qopenglwindow#UpdateBehavior-enum&quot;&gt;NoPartialUpdate&lt;/a&gt;, there is no difference between this function and &lt;a href=&quot;qopenglwindow#paintGL&quot;&gt;paintGL&lt;/a&gt;(), performing rendering in either of them leads to the same result.</source>
          <target state="translated">업데이트 모드가 &lt;a href=&quot;qopenglwindow#UpdateBehavior-enum&quot;&gt;NoPartialUpdate&lt;/a&gt; 로 설정되어 있으면 이 함수와 &lt;a href=&quot;qopenglwindow#paintGL&quot;&gt;paintGL&lt;/a&gt; () 사이에 차이가 없으며 둘 중 하나에서 렌더링을 수행하면 동일한 결과가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="90a4d8b7976d6357d0d51104a651d5693a247b6e" translate="yes" xml:space="preserve">
          <source>When the update mode is set to &lt;code&gt;NoPartialUpdate&lt;/code&gt;, there is no difference between this function and &lt;a href=&quot;qopenglwindow#paintGL&quot;&gt;paintGL&lt;/a&gt;(), performing rendering in either of them leads to the same result.</source>
          <target state="translated">업데이트 모드가 &lt;code&gt;NoPartialUpdate&lt;/code&gt; 로 설정되어 있으면 이 함수와 &lt;a href=&quot;qopenglwindow#paintGL&quot;&gt;paintGL&lt;/a&gt; () 사이에 차이가 없으며 둘 중 하나에서 렌더링을 수행하면 동일한 결과가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7fbf049a32dd0640f6dd43ed769625f8cee33a4d" translate="yes" xml:space="preserve">
          <source>When the user attempts to close a window, the &lt;a href=&quot;qml-qtquick-window-window#closing-signal&quot;&gt;closing&lt;/a&gt; signal will be emitted. You can force the window to stay open (for example to prompt the user to save changes) by writing an &lt;code&gt;onClosing&lt;/code&gt; handler and setting &lt;code&gt;close.accepted = false&lt;/code&gt;.</source>
          <target state="translated">사용자가 창을 닫으려고하면 &lt;a href=&quot;qml-qtquick-window-window#closing-signal&quot;&gt;닫는&lt;/a&gt; 신호가 발생합니다. &lt;code&gt;onClosing&lt;/code&gt; 핸들러 를 작성하고 &lt;code&gt;close.accepted = false&lt;/code&gt; 설정 하여 창을 강제로 열 수 있습니다 (예 : 사용자에게 변경 사항을 저장하라는 프롬프트 표시) .</target>
        </trans-unit>
        <trans-unit id="f089242c4828bfa1c4990e6f2f452f8aa6f68fa8" translate="yes" xml:space="preserve">
          <source>When the user clicks anywhere within the rectangle, &lt;code&gt;sendMessage()&lt;/code&gt; is called, triggering the &lt;code&gt;WorkerScript.onMessage()&lt;/code&gt; handler in &lt;code&gt;script.mjs&lt;/code&gt;. This in turn sends a reply message that is then received by the &lt;code&gt;onMessage()&lt;/code&gt; handler of &lt;code&gt;myWorker&lt;/code&gt;.</source>
          <target state="translated">사용자가 사각형 내의 아무 곳이나 클릭하면 &lt;code&gt;sendMessage()&lt;/code&gt; 가 호출되어 &lt;code&gt;WorkerScript.onMessage()&lt;/code&gt; 에서 WorkerScript.onMessage () 핸들러가 &lt;code&gt;script.mjs&lt;/code&gt; 됩니다. 이것은 응답 메시지를 보낸 다음 &lt;code&gt;myWorker&lt;/code&gt; 의 &lt;code&gt;onMessage()&lt;/code&gt; 핸들러에 의해 수신됩니다 .</target>
        </trans-unit>
        <trans-unit id="9e806fe43114f8c1140dcea68026addc98aa8292" translate="yes" xml:space="preserve">
          <source>When the user enters a new string in an editable combobox, the widget may or may not insert it, and it can insert it in several locations. The default policy is &lt;a href=&quot;qcombobox#InsertPolicy-enum&quot;&gt;InsertAtBottom&lt;/a&gt; but you can change this using &lt;a href=&quot;qcombobox#insertPolicy-prop&quot;&gt;setInsertPolicy&lt;/a&gt;().</source>
          <target state="translated">사용자가 편집 가능한 콤보 박스에 새 문자열을 입력하면 위젯이 삽입하거나 삽입하지 않을 수 있으며 여러 위치에 삽입 할 수 있습니다. 기본 정책은 &lt;a href=&quot;qcombobox#InsertPolicy-enum&quot;&gt;InsertAtBottom&lt;/a&gt; 이지만 &lt;a href=&quot;qcombobox#insertPolicy-prop&quot;&gt;setInsertPolicy&lt;/a&gt; ()를 사용하여 이를 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7a33c93bf7f01a0e67730291d39734d96a1a1c84" translate="yes" xml:space="preserve">
          <source>When the user has finished editing the value in the spin box, the view asks the delegate to store the edited value in the model by calling the &lt;a href=&quot;qabstractitemdelegate#setModelData&quot;&gt;setModelData()&lt;/a&gt; function.</source>
          <target state="translated">사용자가 스핀 상자에서 값 편집을 마치면 뷰는 대리자에게 &lt;a href=&quot;qabstractitemdelegate#setModelData&quot;&gt;setModelData ()&lt;/a&gt; 함수를 호출하여 편집 된 값을 모델에 저장하도록 요청합니다 .</target>
        </trans-unit>
        <trans-unit id="92fa0779d8d3b6243f1940a69448d7de41b9ecd3" translate="yes" xml:space="preserve">
          <source>When the user presses or releases a key, the following occurs:</source>
          <target state="translated">사용자가 키를 누르거나 놓으면 다음이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="0593af2ddbf4e80d0b0321de8e5024100fcd08c9" translate="yes" xml:space="preserve">
          <source>When the user presses the first key on a keyboard, an input context is created. This input context will contain a string of the typed characters.</source>
          <target state="translated">사용자가 키보드에서 첫 번째 키를 누르면 입력 컨텍스트가 작성됩니다. 이 입력 컨텍스트에는 유형이 지정된 문자열이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="17b14a687e250bb8ebffd69d26cedf3fe0182667" translate="yes" xml:space="preserve">
          <source>When the user presses the shortcut key indicated by this label, the keyboard focus is transferred to the label's buddy widget.</source>
          <target state="translated">사용자가이 레이블로 표시된 바로 가기 키를 누르면 키보드 포커스가 레이블의 친구 위젯으로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="d8718161543f49d12ebfce2a24d45c7fc9cbd16e" translate="yes" xml:space="preserve">
          <source>When the user resizes the window, the size will move in steps of &lt;a href=&quot;qwindow#sizeIncrement&quot;&gt;sizeIncrement&lt;/a&gt;().&lt;a href=&quot;qwindow#width-prop&quot;&gt;width&lt;/a&gt;() pixels horizontally and &lt;a href=&quot;qwindow#sizeIncrement&quot;&gt;sizeIncrement&lt;/a&gt;().&lt;a href=&quot;qwindow#height-prop&quot;&gt;height&lt;/a&gt;() pixels vertically, with &lt;a href=&quot;qwindow#baseSize&quot;&gt;baseSize&lt;/a&gt;() as the basis.</source>
          <target state="translated">사용자가 창의 크기를 조정하면 크기가 &lt;a href=&quot;qwindow#sizeIncrement&quot;&gt;sizeIncrement&lt;/a&gt; () 단계로 이동합니다 . &lt;a href=&quot;qwindow#width-prop&quot;&gt;가로&lt;/a&gt; () 픽셀 및 &lt;a href=&quot;qwindow#sizeIncrement&quot;&gt;sizeIncrement&lt;/a&gt; (). &lt;a href=&quot;qwindow#baseSize&quot;&gt;baseSize&lt;/a&gt; ()를 기준으로 &lt;a href=&quot;qwindow#height-prop&quot;&gt;높이&lt;/a&gt; () 픽셀 (세로 )</target>
        </trans-unit>
        <trans-unit id="9e453a57cc507da9b2902f79db75133ddc061ac8" translate="yes" xml:space="preserve">
          <source>When the user resizes the window, the size will move in steps of sizeIncrement().&lt;a href=&quot;qwidget#width-prop&quot;&gt;width&lt;/a&gt;() pixels horizontally and sizeIncrement.&lt;a href=&quot;qwidget#height-prop&quot;&gt;height&lt;/a&gt;() pixels vertically, with &lt;a href=&quot;qwidget#baseSize-prop&quot;&gt;baseSize&lt;/a&gt;() as the basis. Preferred widget sizes are for non-negative integers</source>
          <target state="translated">사용자가 창의 크기를 조정하면 크기가 sizeIncrement () 단계로 이동합니다. &lt;a href=&quot;qwidget#width-prop&quot;&gt;가로&lt;/a&gt; () 픽셀 및 sizeIncrement. &lt;a href=&quot;qwidget#baseSize-prop&quot;&gt;baseSize&lt;/a&gt; ()를 기준으로 &lt;a href=&quot;qwidget#height-prop&quot;&gt;높이&lt;/a&gt; () 픽셀 (세로 ) 기본 위젯 크기는 음이 아닌 정수입니다.</target>
        </trans-unit>
        <trans-unit id="e9e23684b39294a601601a344c7bf87e80ee521d" translate="yes" xml:space="preserve">
          <source>When the user selects a new font, the &lt;a href=&quot;qfontcombobox#currentFontChanged&quot;&gt;currentFontChanged&lt;/a&gt;() signal is emitted in addition to &lt;a href=&quot;qcombobox#currentIndexChanged&quot;&gt;currentIndexChanged&lt;/a&gt;().</source>
          <target state="translated">사용자가 새 글꼴을 선택하면 &lt;a href=&quot;qcombobox#currentIndexChanged&quot;&gt;currentIndexChanged&lt;/a&gt; () 외에 &lt;a href=&quot;qfontcombobox#currentFontChanged&quot;&gt;currentFontChanged&lt;/a&gt; () 신호가 생성 됩니다.</target>
        </trans-unit>
        <trans-unit id="4da46bc51fcc82534c06603bbbd59ebe7d50ebb4" translate="yes" xml:space="preserve">
          <source>When the user selects an item in the list, the input method responds to the event in the &lt;a href=&quot;qml-qtquick-virtualkeyboard-inputmethod#selectionListItemSelected-method&quot;&gt;InputMethod::selectionListItemSelected&lt;/a&gt; method callback.</source>
          <target state="translated">사용자가 목록에서 항목을 선택하면 입력 메소드가 &lt;a href=&quot;qml-qtquick-virtualkeyboard-inputmethod#selectionListItemSelected-method&quot;&gt;InputMethod :: selectionListItemSelected&lt;/a&gt; 메소드 콜백 의 이벤트에 응답합니다 .</target>
        </trans-unit>
        <trans-unit id="c109346817c0c000e5fe1e4e0a164874e2cf7eaf" translate="yes" xml:space="preserve">
          <source>When the user selects an item in the usual way, the selection is cleared and the new item selected. However, if the user presses the Ctrl key when clicking on an item, the clicked item gets toggled and all other items are left untouched. If the user presses the Shift key while clicking on an item, all items between the current item and the clicked item are selected or unselected, depending on the state of the clicked item. Multiple items can be selected by dragging the mouse over them.</source>
          <target state="translated">사용자가 일반적인 방식으로 항목을 선택하면 선택이 해제되고 새 항목이 선택됩니다. 그러나 사용자가 항목을 클릭 할 때 Ctrl 키를 누르면 클릭 한 항목이 토글되고 다른 모든 항목은 그대로 유지됩니다. 사용자가 항목을 클릭하는 동안 Shift 키를 누르면 클릭 한 항목의 상태에 따라 현재 항목과 클릭 한 항목 사이의 모든 항목이 선택되거나 선택 해제됩니다. 마우스로 항목을 끌어 여러 항목을 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="239784d9cf52110a5610a0352def4b21651a1ec0" translate="yes" xml:space="preserve">
          <source>When the user selects an item in the usual way, the selection is cleared and the new item selected. However, if the user presses the Shift key while clicking on an item, all items between the current item and the clicked item are selected or unselected, depending on the state of the clicked item.</source>
          <target state="translated">사용자가 일반적인 방식으로 항목을 선택하면 선택이 해제되고 새 항목이 선택됩니다. 그러나 사용자가 항목을 클릭하는 동안 Shift 키를 누르면 클릭 한 항목의 상태에 따라 현재 항목과 클릭 한 항목 사이의 모든 항목이 선택되거나 선택 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="b63a60a0cef1fb52e61ed1b641072b5077221c1a" translate="yes" xml:space="preserve">
          <source>When the user selects an item in the usual way, the selection status of that item is toggled and the other items are left alone. Multiple items can be toggled by dragging the mouse over them.</source>
          <target state="translated">사용자가 일반적인 방식으로 항목을 선택하면 해당 항목의 선택 상태가 전환되고 다른 항목은 그대로 남습니다. 여러 항목을 마우스로 끌어서 토글 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="48e3c32ce598a7fbfd8868c52569756e58fdf828" translate="yes" xml:space="preserve">
          <source>When the user selects an item, any already-selected item becomes unselected. It is possible for the user to deselect the selected item by pressing the Ctrl key when clicking the selected item.</source>
          <target state="translated">사용자가 항목을 선택하면 이미 선택한 항목은 선택 취소됩니다. 사용자가 선택한 항목을 클릭 할 때 Ctrl 키를 눌러 선택한 항목을 선택 취소 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="432b100478d155eb5754fdf1b8519f514ff3bcfa" translate="yes" xml:space="preserve">
          <source>When the user selects an item, any already-selected item becomes unselected. It is possible for the user to deselect the selected item.</source>
          <target state="translated">사용자가 항목을 선택하면 이미 선택된 항목이 선택 해제됩니다. 사용자가 선택한 항목을 선택 해제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="40c8efdfbff08c7bc6b912d42d8681b4819162a6" translate="yes" xml:space="preserve">
          <source>When the user triggers a step whilst holding the &lt;a href=&quot;qt#KeyboardModifier-enum&quot;&gt;Qt::ControlModifier&lt;/a&gt;, &lt;a href=&quot;qabstractspinbox&quot;&gt;QAbstractSpinBox&lt;/a&gt; steps by 10 instead of making a single step. This step modifier affects wheel events, key events and interaction with the spinbox buttons. Note that on &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt;, Control corresponds to the Command key.</source>
          <target state="translated">사용자는 유지하는 동안 단계 트리거 할 때 &lt;a href=&quot;qt#KeyboardModifier-enum&quot;&gt;Qt는 :: ControlModifier&lt;/a&gt; , &lt;a href=&quot;qabstractspinbox&quot;&gt;QAbstractSpinBox의&lt;/a&gt; 10 단계를 대신 한 단계를 만드는. 이 단계 수정자는 휠 이벤트, 주요 이벤트 및 스핀 박스 버튼과의 상호 작용에 영향을줍니다. 에 있습니다 &lt;a href=&quot;internationalization#macos&quot;&gt;맥 OS&lt;/a&gt; , 제어 명령 키에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="34d7335e57478339ba71faccb6f2bf5634476339" translate="yes" xml:space="preserve">
          <source>When the user triggers a step whilst holding the &lt;a href=&quot;qt#KeyboardModifier-enum&quot;&gt;Qt::ControlModifier&lt;/a&gt;, QAbstractSpinBox steps by 10 instead of making a single step. This step modifier affects wheel events, key events and interaction with the spinbox buttons. Note that on macOS, Control corresponds to the Command key.</source>
          <target state="translated">사용자가 &lt;a href=&quot;qt#KeyboardModifier-enum&quot;&gt;Qt :: ControlModifier&lt;/a&gt; 를 누른 상태에서 단계를 트리거하면 QAbstractSpinBox는 한 단계를 수행하는 대신 10 단계 씩 단계를 수행합니다. 이 단계 수정자는 휠 이벤트, 키 이벤트 및 스핀 박스 버튼과의 상호 작용에 영향을줍니다. macOS에서 Control은 Command 키에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="3de1fafb709edfc8e71149ea8ddc3fd104d090bd" translate="yes" xml:space="preserve">
          <source>When the user types the &lt;a href=&quot;qkeysequence&quot;&gt;key sequence&lt;/a&gt; for a given shortcut, the shortcut's &lt;a href=&quot;qshortcut#activated&quot;&gt;activated&lt;/a&gt;() signal is emitted. (In the case of ambiguity, the &lt;a href=&quot;qshortcut#activatedAmbiguously&quot;&gt;activatedAmbiguously&lt;/a&gt;() signal is emitted.) A shortcut is &quot;listened for&quot; by Qt's event loop when the shortcut's parent widget is receiving events.</source>
          <target state="translated">사용자 가 지정된 바로 가기에 대한 &lt;a href=&quot;qkeysequence&quot;&gt;키 시퀀스&lt;/a&gt; 를 입력하면 바로 가기의 &lt;a href=&quot;qshortcut#activated&quot;&gt;활성화&lt;/a&gt; () 신호가 발생합니다. (모호한 경우, &lt;a href=&quot;qshortcut#activatedAmbiguously&quot;&gt;activatedAmbiguously&lt;/a&gt; () 신호가 방출된다.)이 바로 가기 Qt의 이벤트 루프로 바로 상위의 이벤트를 수신 할 때 위젯위한 &quot;경청&quot;이다.</target>
        </trans-unit>
        <trans-unit id="07467a76ec47313778f1640f3f2853d179a4c454" translate="yes" xml:space="preserve">
          <source>When the user uses the arrows to change the spin box's value the value will be incremented/decremented by the amount of the singleStep. The default value is 1. Setting a singleStep value of less than 0 does nothing.</source>
          <target state="translated">사용자가 화살표를 사용하여 스핀 상자 값을 변경하면 단일 단계의 양만큼 값이 증가 / 감소합니다. 기본값은 1입니다. singleStep 값을 0보다 작게 설정하면 아무 작업도 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1a7fbae2e2cb0c5b805b7e0f23104cafdd5b43a3" translate="yes" xml:space="preserve">
          <source>When the user uses the arrows to change the spin box's value the value will be incremented/decremented by the amount of the singleStep. The default value is 1.0. Setting a singleStep value of less than 0 does nothing.</source>
          <target state="translated">사용자가 화살표를 사용하여 스핀 상자 값을 변경하면 단일 단계의 양만큼 값이 증가 / 감소합니다. 기본값은 1.0입니다. singleStep 값을 0보다 작게 설정하면 아무 작업도 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="55b72162369d6d7fefe6c5eeff0d064284c9c1e9" translate="yes" xml:space="preserve">
          <source>When the user wants to purchase a product, call &lt;a href=&quot;qinappproduct#purchase&quot;&gt;QInAppProduct::purchase&lt;/a&gt;() on the product. This launches a platform-specific, asynchronous process to purchase the product, for example by requesting the user's password and confirmation of the purchase. In most cases, you must make sure that the application UI is not accepting input while the purchase request is being processed, as this is not handled automatically on all platforms.</source>
          <target state="translated">사용자가 제품을 구매하려면 제품의 &lt;a href=&quot;qinappproduct#purchase&quot;&gt;QInAppProduct :: purchase&lt;/a&gt; ()로 전화 하십시오. 예를 들어, 사용자 비밀번호를 요청하고 구매를 확인하여 제품을 구매하기위한 플랫폼 별 비동기 프로세스가 시작됩니다. 대부분의 경우 구매 요청이 처리되는 동안 응용 프로그램 UI가 입력을 수락하지 않아야합니다. 이는 모든 플랫폼에서 자동으로 처리되지 않기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="53e007fcb539e15013065a7fcca5f31963711f7f" translate="yes" xml:space="preserve">
          <source>When the view changes, the &lt;code&gt;inputViewChanged&lt;/code&gt; signal is emitted.</source>
          <target state="translated">뷰가 변경되면 &lt;code&gt;inputViewChanged&lt;/code&gt; 신호가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="6bf292009c41ae3996b782ddaf7f2171babcb34d" translate="yes" xml:space="preserve">
          <source>When the view is initialized, the view will create all the necessary items for the view, then animate them to their correct positions within the view over one second.</source>
          <target state="translated">뷰가 초기화되면 뷰는 뷰에 필요한 모든 항목을 생성 한 다음 1 초 동안 뷰 내에서 올바른 위치에 애니메이션을 적용합니다.</target>
        </trans-unit>
        <trans-unit id="bf9267cdf13126ffe2807371579c3234aa2c025f" translate="yes" xml:space="preserve">
          <source>When the widget is embedded, its state (e.g., visible, enabled, geometry, size hints) is copied into the proxy widget. If the embedded widget is explicitly hidden or disabled, the proxy widget will become explicitly hidden or disabled after embedding is complete. The class documentation has a full overview over the shared state.</source>
          <target state="translated">위젯이 임베드되면 상태 (예 : 표시, 사용, 지오메트리, 크기 힌트)가 프록시 위젯으로 복사됩니다. 임베드 된 위젯이 명시 적으로 숨겨 지거나 비활성화 된 경우 임베드가 완료된 후 프록시 위젯이 명시 적으로 숨겨 지거나 비활성화됩니다. 수업 문서에는 공유 상태에 대한 전체 개요가 있습니다.</target>
        </trans-unit>
        <trans-unit id="0eed7c85c5152e46b5d87508ebba22a259d445d6" translate="yes" xml:space="preserve">
          <source>When the widget needs to generate a set of preview pages, a &lt;a href=&quot;qprintpreviewwidget#paintRequested&quot;&gt;paintRequested&lt;/a&gt;() signal will be emitted from the widget. Connect a slot to this signal, and draw onto the &lt;a href=&quot;qprinter&quot;&gt;QPrinter&lt;/a&gt; passed in as a signal parameter. Call &lt;a href=&quot;qprinter#newPage&quot;&gt;QPrinter::newPage&lt;/a&gt;(), to start a new page in the preview.</source>
          <target state="translated">위젯이 미리보기 페이지 세트를 생성해야하는 경우 위젯에서 &lt;a href=&quot;qprintpreviewwidget#paintRequested&quot;&gt;paintRequested&lt;/a&gt; () 신호가 생성됩니다. 이 신호에 슬롯을 연결하고 신호 매개 변수로 전달 된 &lt;a href=&quot;qprinter&quot;&gt;QPrinter&lt;/a&gt; 에 그립니다 . 미리보기에서 새 페이지를 시작하려면 &lt;a href=&quot;qprinter#newPage&quot;&gt;QPrinter :: newPage&lt;/a&gt; ()를 호출 하십시오.</target>
        </trans-unit>
        <trans-unit id="17365a086c8d8f3707090a7d37af79afa83d7862" translate="yes" xml:space="preserve">
          <source>When the widget's window and the related OpenGL resources are not yet initialized, the return value is the format that has been set via &lt;a href=&quot;qopenglwidget#setFormat&quot;&gt;setFormat&lt;/a&gt;().</source>
          <target state="translated">위젯의 창과 관련 OpenGL 리소스가 아직 초기화되지 않은 경우 반환 값은 &lt;a href=&quot;qopenglwidget#setFormat&quot;&gt;setFormat&lt;/a&gt; ()을 통해 설정된 형식입니다 .</target>
        </trans-unit>
        <trans-unit id="43847dedad7e1417643232066e6b313499c2942c" translate="yes" xml:space="preserve">
          <source>When the widget-style font and palette propagation is enabled, font and palette changes made through Qt Style Sheets will behave as though the user had manually called the corresponding &lt;a href=&quot;qwidget#palette-prop&quot;&gt;QWidget::setPalette&lt;/a&gt;() and &lt;a href=&quot;qwidget#font-prop&quot;&gt;QWidget::setFont&lt;/a&gt;() methods on all of the QWidgets targeted by the style sheet. If this would have caused propagation in C++, it will cause propagation in style sheets and vice versa.</source>
          <target state="translated">위젯 스타일의 글꼴 및 팔레트 전파가 활성화되면 Qt 스타일 시트를 통해 &lt;a href=&quot;qwidget#palette-prop&quot;&gt;작성된&lt;/a&gt; 글꼴 및 팔레트 변경 사항은 사용자가 모든 항목에서 해당 QWidget :: setPalette () 및 &lt;a href=&quot;qwidget#font-prop&quot;&gt;QWidget :: setFont&lt;/a&gt; () 메소드를 수동으로 호출 한 것처럼 작동 합니다. 스타일 시트가 대상으로하는 QWidgets. 이로 인해 C ++에서 전파가 발생하면 스타일 시트에서 전파가 발생하고 그 반대도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="d46c08525c4ed676f1a7ccbb248c7080204996de" translate="yes" xml:space="preserve">
          <source>When the window is made visible, the content is updated automatically. Further updates can be requested by calling &lt;a href=&quot;qwindow#requestUpdate&quot;&gt;QWindow::requestUpdate&lt;/a&gt;(). To render continuously, call &lt;a href=&quot;qwindow#requestUpdate&quot;&gt;requestUpdate&lt;/a&gt;() after &lt;a href=&quot;qvulkanwindow#frameReady&quot;&gt;frameReady&lt;/a&gt;().</source>
          <target state="translated">창이 표시되면 내용이 자동으로 업데이트됩니다. &lt;a href=&quot;qwindow#requestUpdate&quot;&gt;QWindow :: requestUpdate&lt;/a&gt; ()를 호출하여 추가 업데이트를 요청할 수 있습니다 . 계속 렌더링하려면 &lt;a href=&quot;qvulkanwindow#frameReady&quot;&gt;frameReady&lt;/a&gt; () 다음에 &lt;a href=&quot;qwindow#requestUpdate&quot;&gt;requestUpdate&lt;/a&gt; ()를 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="d0885d46fa70f463e2de0a22a1a8f497582d4166" translate="yes" xml:space="preserve">
          <source>When the window is not exposed, it is shown by the application but it is still not showing in the windowing system, so the application should minimize rendering and other graphical activities.</source>
          <target state="translated">창이 노출되지 않으면 응용 프로그램에 의해 표시되지만 여전히 윈도우 시스템에는 표시되지 않으므로 응용 프로그램은 렌더링 및 기타 그래픽 활동을 최소화해야합니다.</target>
        </trans-unit>
        <trans-unit id="298ff46be999c313b755a4569e2c0f50522cc6cd" translate="yes" xml:space="preserve">
          <source>When the window state changes, the widget receives a &lt;a href=&quot;qwidget#changeEvent&quot;&gt;changeEvent&lt;/a&gt;() of type &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent::WindowStateChange&lt;/a&gt;.</source>
          <target state="translated">창 상태가 변경되면 위젯은 &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent :: WindowStateChange&lt;/a&gt; 유형 의 &lt;a href=&quot;qwidget#changeEvent&quot;&gt;changeEvent&lt;/a&gt; ()를 수신합니다 .</target>
        </trans-unit>
        <trans-unit id="4430665a811124c03a76c8e73574aa765dc47098" translate="yes" xml:space="preserve">
          <source>When there are too many tabs in a tab bar for its size, the tab bar can either choose to expand its size or to add buttons that allow you to scroll through the tabs.</source>
          <target state="translated">탭 막대에 크기에 비해 탭이 너무 많으면 탭 막대가 크기를 확장하거나 탭을 스크롤 할 수있는 단추를 추가하도록 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="328188d436a703678d89704707e3862740fee438" translate="yes" xml:space="preserve">
          <source>When these images are loaded by QML, it looks for a matching image provider and calls its &lt;a href=&quot;qquickimageprovider#requestImage&quot;&gt;requestImage&lt;/a&gt;() or &lt;a href=&quot;qquickimageprovider#requestPixmap&quot;&gt;requestPixmap&lt;/a&gt;() method (depending on its &lt;a href=&quot;qquickimageprovider#imageType&quot;&gt;imageType&lt;/a&gt;()) to load the image. The method is called with the &lt;code&gt;id&lt;/code&gt; parameter set to &quot;yellow&quot; for the first image, and &quot;red&quot; for the second.</source>
          <target state="translated">이러한 이미지가 QML에 의해로드되면 일치하는 이미지 제공자를 찾고 이미지를로드하기 위해 해당 &lt;a href=&quot;qquickimageprovider#imageType&quot;&gt;imageType&lt;/a&gt; () 에 따라 &lt;a href=&quot;qquickimageprovider#requestImage&quot;&gt;requestImage&lt;/a&gt; () 또는 &lt;a href=&quot;qquickimageprovider#requestPixmap&quot;&gt;requestPixmap&lt;/a&gt; () 메소드를 호출합니다 . 첫 번째 이미지 는 &lt;code&gt;id&lt;/code&gt; 매개 변수를 &quot;yellow&quot;로 설정하고 두 번째 이미지는 &quot;red&quot;로 설정하여 메소드를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="280d1db6d231e9b9540bfc8acf026c5df8031216" translate="yes" xml:space="preserve">
          <source>When this argument is used, a second argument is required, which specifies the module whose classes are to be listed. QDoc generates a table containing those classes. Each class is listed with the text of its &lt;a href=&quot;11-qdoc-commands-specialcontent#brief-command&quot;&gt;\brief&lt;/a&gt; command.</source>
          <target state="translated">이 인수를 사용하면 클래스를 나열 할 모듈을 지정하는 두 번째 인수가 필요합니다. QDoc은 해당 클래스를 포함하는 테이블을 생성합니다. 각 클래스는 &lt;a href=&quot;11-qdoc-commands-specialcontent#brief-command&quot;&gt;\ brief&lt;/a&gt; 명령 의 텍스트와 함께 나열됩니다 .</target>
        </trans-unit>
        <trans-unit id="ed8f319625948db2e4a131ba28a779620a6396b0" translate="yes" xml:space="preserve">
          <source>When this attribute is set, the native on-screen virtual keyboard will not be shown automatically when a text input widget gains focus on a system without a physical keyboard. Currently supported on the Windows platform only. This value was added in 5.15</source>
          <target state="translated">이 속성이 설정되면 텍스트 입력 위젯이 물리적 키보드가없는 시스템에 초점을 맞출 때 기본 온 스크린 가상 키보드가 자동으로 표시되지 않습니다. 현재 Windows 플랫폼에서만 지원됩니다. 이 값은 5.15에서 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="278d7e1255bd96582c739bd15df2833e0be8a868" translate="yes" xml:space="preserve">
          <source>When this code is loaded by the engine, it creates an object tree with a &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt; object at the root; this object has a &lt;a href=&quot;qml-qtquick-gradient&quot;&gt;Gradient&lt;/a&gt; child object, which in turn has two &lt;a href=&quot;qml-qtquick-gradientstop&quot;&gt;GradientStop&lt;/a&gt; children.</source>
          <target state="translated">이 코드는 엔진에 의해로드 될 때 루트에 &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt; 객체 가있는 객체 트리를 만듭니다 . 이 객체에는 &lt;a href=&quot;qml-qtquick-gradient&quot;&gt;Gradient&lt;/a&gt; 하위 객체가 있으며 두 개의 &lt;a href=&quot;qml-qtquick-gradientstop&quot;&gt;GradientStop&lt;/a&gt; 하위 객체가 있습니다.</target>
        </trans-unit>
        <trans-unit id="bef518027d6e82c3441e9a6878947589c6671093" translate="yes" xml:space="preserve">
          <source>When this event occurs it is customary to show a &lt;a href=&quot;qmenu&quot;&gt;QMenu&lt;/a&gt; with a context menu, if this is relevant to the context.</source>
          <target state="translated">이 이벤트가 발생하면 컨텍스트와 관련이있는 경우 컨텍스트 메뉴와 함께 &lt;a href=&quot;qmenu&quot;&gt;QMenu&lt;/a&gt; 를 표시하는 것이 일반적 입니다.</target>
        </trans-unit>
        <trans-unit id="1c5aa92c276833ef89412fc07466f6fcff736ad0" translate="yes" xml:space="preserve">
          <source>When this feature is on (the default is off), clicking on a header section sorts the items according to that column. By clicking repeatedly, the user can alternate between ascending and descending order.</source>
          <target state="translated">이 기능이 켜져 있으면 (기본값은 꺼져 있음) 머리글 섹션을 클릭하면 해당 열에 따라 항목이 정렬됩니다. 반복해서 클릭하면 오름차순과 내림차순을 번갈아 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5aafd154ba0fcb35eccabb15e1a7d96cc39747d6" translate="yes" xml:space="preserve">
          <source>When this function is called after the program has been linked, the program will need to be relinked for the change to take effect.</source>
          <target state="translated">프로그램이 링크 된 후이 함수가 호출되면 변경 사항을 적용하려면 프로그램을 다시 링크해야합니다.</target>
        </trans-unit>
        <trans-unit id="c9186348bdc67fdf223b859066aa3c52ea35863b" translate="yes" xml:space="preserve">
          <source>When this function is called multiple times in quick succession with the same function as its first argument, that function will be called only once.</source>
          <target state="translated">이 함수가 첫 번째 인수와 동일한 함수로 연속해서 빠르게 여러 번 호출되면 해당 함수는 한 번만 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="398a779395d95b160c8ff7f5a1fe0f7602c5e153" translate="yes" xml:space="preserve">
          <source>When this function is called, the purchase process is initiated. At some point during the process, the &lt;a href=&quot;qinappstore#transactionReady&quot;&gt;QInAppStore::transactionReady&lt;/a&gt;() signal is emitted, and the slot registered earlier is called. In this function, you can save data about a successful purchase so that it survives across application runs. After verifying that the data has been stored, finalize the transaction. If the transaction fails, display information about the failure to the user and finalize the transaction.</source>
          <target state="translated">이 기능이 호출되면 구매 프로세스가 시작됩니다. 프로세스 도중 어느 시점에서 &lt;a href=&quot;qinappstore#transactionReady&quot;&gt;QInAppStore :: transactionReady&lt;/a&gt; () 신호가 발생하고 이전에 등록 된 슬롯이 호출됩니다. 이 기능에서는 성공적인 구매에 대한 데이터를 저장하여 애플리케이션 실행시에도 지속될 수 있습니다. 데이터가 저장되었는지 확인한 후 트랜잭션을 완료하십시오. 트랜잭션이 실패하면 사용자에게 실패에 대한 정보를 표시하고 트랜잭션을 완료하십시오.</target>
        </trans-unit>
        <trans-unit id="0a8adea584e450f3c916a9833293ed806c718263" translate="yes" xml:space="preserve">
          <source>When this hint is set and it is applicable, the clip region will be generated from &lt;a href=&quot;qsgclipnode#clipRect&quot;&gt;clipRect&lt;/a&gt;() rather than &lt;a href=&quot;qsgbasicgeometrynode#geometry&quot;&gt;geometry&lt;/a&gt;().</source>
          <target state="translated">이 힌트가 설정되어 적용 가능한 경우, 클립 영역은 &lt;a href=&quot;qsgbasicgeometrynode#geometry&quot;&gt;지오메트리&lt;/a&gt; ()가 아니라 &lt;a href=&quot;qsgclipnode#clipRect&quot;&gt;clipRect&lt;/a&gt; () 에서 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="25c548388c50d22300a6331c81e8413c5cbc46fc" translate="yes" xml:space="preserve">
          <source>When this is enabled, qmake will process all libraries linked to by the application and find their meta-information. qmake will use this to determine the relevant linking information, specifically adding values to the application project file's list of &lt;a href=&quot;qmake-variable-reference#defines&quot;&gt;DEFINES&lt;/a&gt; as well as &lt;a href=&quot;qmake-variable-reference#libs&quot;&gt;LIBS&lt;/a&gt;. Once qmake has processed this file, it will then look through the newly introduced libraries in the &lt;code&gt;LIBS&lt;/code&gt; variable, and find their dependent .prl files, continuing until all libraries have been resolved. At this point, the Makefile is created as usual, and the libraries are linked explicitly against the application.</source>
          <target state="translated">이 기능이 활성화되면 qmake는 응용 프로그램에 연결된 모든 라이브러리를 처리하고 메타 정보를 찾습니다. qmake는이를 사용하여 관련 링크 정보를 결정합니다. 특히 애플리케이션 프로젝트 파일의 &lt;a href=&quot;qmake-variable-reference#defines&quot;&gt;DEFINES&lt;/a&gt; 및 &lt;a href=&quot;qmake-variable-reference#libs&quot;&gt;LIBS&lt;/a&gt; 값에 값을 추가합니다 . qmake가이 파일을 처리하면 &lt;code&gt;LIBS&lt;/code&gt; 변수 에서 새로 도입 된 라이브러리를 살펴보고 모든 라이브러리가 해결 될 때까지 계속해서 종속 .prl 파일을 찾습니다. 이 시점에서 Makefile은 평소와 같이 작성되며 라이브러리는 애플리케이션과 명시 적으로 링크됩니다.</target>
        </trans-unit>
        <trans-unit id="e1c2654888290051c11e8d6edd467ee92c8e7a88" translate="yes" xml:space="preserve">
          <source>When this is repeated for each leaf node in the framegraph, the frame is complete and the renderer calls &lt;a href=&quot;qopenglcontext#swapBuffers&quot;&gt;QOpenGLContext::swapBuffers&lt;/a&gt;() to display the frame.</source>
          <target state="translated">프레임 &lt;a href=&quot;qopenglcontext#swapBuffers&quot;&gt;그래프의&lt;/a&gt; 각 리프 노드에 대해이 작업이 반복되면 프레임이 완료되고 렌더러가 QOpenGLContext :: swapBuffers ()를 호출 하여 프레임을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="ec52fd20354c1402a9e5c8a902314529744bb69a" translate="yes" xml:space="preserve">
          <source>When this method is called it additionally sets either the &lt;a href=&quot;qml-qtquick-controls-textarea#selectionStart-prop&quot;&gt;selectionStart&lt;/a&gt; or the &lt;a href=&quot;qml-qtquick-controls-textarea#selectionEnd-prop&quot;&gt;selectionEnd&lt;/a&gt; (whichever was at the previous cursor position) to the specified position. This allows you to easily extend and contract the selected text range.</source>
          <target state="translated">이 메소드를 호출하면 &lt;a href=&quot;qml-qtquick-controls-textarea#selectionStart-prop&quot;&gt;selectionStart&lt;/a&gt; 또는 &lt;a href=&quot;qml-qtquick-controls-textarea#selectionEnd-prop&quot;&gt;selectionEnd&lt;/a&gt; (이전 커서 위치 중 하나)를 지정된 위치로 추가로 설정합니다 . 선택한 텍스트 범위를 쉽게 확장하고 축소 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b402258b559da375e5607dca734ac8dba2f14ee" translate="yes" xml:space="preserve">
          <source>When this method is called it additionally sets either the &lt;a href=&quot;qml-qtquick-textedit#selectionStart-prop&quot;&gt;selectionStart&lt;/a&gt; or the &lt;a href=&quot;qml-qtquick-textedit#selectionEnd-prop&quot;&gt;selectionEnd&lt;/a&gt; (whichever was at the previous cursor position) to the specified position. This allows you to easily extend and contract the selected text range.</source>
          <target state="translated">이 메소드를 호출하면 &lt;a href=&quot;qml-qtquick-textedit#selectionStart-prop&quot;&gt;selectionStart&lt;/a&gt; 또는 &lt;a href=&quot;qml-qtquick-textedit#selectionEnd-prop&quot;&gt;selectionEnd&lt;/a&gt; (이전 커서 위치 중 하나)를 지정된 위치로 추가로 설정합니다 . 선택한 텍스트 범위를 쉽게 확장하고 축소 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="81183ac8bcf1dd186d0806619cf0a4b7150e1d76" translate="yes" xml:space="preserve">
          <source>When this method is called it additionally sets either the &lt;a href=&quot;qml-qtquick-textinput#selectionStart-prop&quot;&gt;selectionStart&lt;/a&gt; or the &lt;a href=&quot;qml-qtquick-textinput#selectionEnd-prop&quot;&gt;selectionEnd&lt;/a&gt; (whichever was at the previous cursor position) to the specified position. This allows you to easily extend and contract the selected text range.</source>
          <target state="translated">이 메소드를 호출하면 &lt;a href=&quot;qml-qtquick-textinput#selectionStart-prop&quot;&gt;selectionStart&lt;/a&gt; 또는 &lt;a href=&quot;qml-qtquick-textinput#selectionEnd-prop&quot;&gt;selectionEnd&lt;/a&gt; (이전 커서 위치 중 하나)를 지정된 위치로 추가로 설정합니다 . 선택한 텍스트 범위를 쉽게 확장하고 축소 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3be9f15b12fa7586e346464303593068b7d2ddce" translate="yes" xml:space="preserve">
          <source>When this method is called, or when the user tries to close the window by its title bar button, the &lt;a href=&quot;qml-qtquick-window-window#closing-signal&quot;&gt;closing&lt;/a&gt; signal will be emitted. If there is no handler, or the handler does not revoke permission to close, the window will subsequently close. If the &lt;a href=&quot;qguiapplication#quitOnLastWindowClosed-prop&quot;&gt;QGuiApplication::quitOnLastWindowClosed&lt;/a&gt; property is &lt;code&gt;true&lt;/code&gt;, and there are no other windows open, the application will quit.</source>
          <target state="translated">이 메소드가 호출되거나 사용자가 제목 표시 줄 단추로 창을 닫으려고하면 &lt;a href=&quot;qml-qtquick-window-window#closing-signal&quot;&gt;종료&lt;/a&gt; 신호가 발생합니다. 처리기가 없거나 처리기가 닫을 수있는 권한을 취소하지 않으면 창이 닫힙니다. 는 IF &lt;a href=&quot;qguiapplication#quitOnLastWindowClosed-prop&quot;&gt;QGuiApplication :: quitOnLastWindowClosed의&lt;/a&gt; 재산이 &lt;code&gt;true&lt;/code&gt; 과 다른 창을 열 수 없습니다, 응용 프로그램이 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="4ca058932c3f0b4bb0aeaff104b696065bebb8ff" translate="yes" xml:space="preserve">
          <source>When this option is enabled, qmake will process all libraries linked to by the application and find their meta-information (see &lt;a href=&quot;qmake-advanced-usage#libdepend&quot;&gt;Library Dependencies&lt;/a&gt; for more info).</source>
          <target state="translated">이 옵션이 활성화되면 qmake는 응용 프로그램에 연결된 모든 라이브러리를 처리하고 메타 정보를 찾습니다 (자세한 내용은 &lt;a href=&quot;qmake-advanced-usage#libdepend&quot;&gt;라이브러리 종속성&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="e954b1e0533aa197768aa31122dd76fd088a3473" translate="yes" xml:space="preserve">
          <source>When this option is set, &lt;a href=&quot;qtextline#naturalTextWidth&quot;&gt;QTextLine::naturalTextWidth&lt;/a&gt;() and &lt;a href=&quot;qtextline#naturalTextRect&quot;&gt;QTextLine::naturalTextRect&lt;/a&gt;() will return a value that includes the width of trailing spaces in the text; otherwise this width is excluded.</source>
          <target state="translated">이 옵션이 설정되면 &lt;a href=&quot;qtextline#naturalTextWidth&quot;&gt;QTextLine :: naturalTextWidth&lt;/a&gt; () 및 &lt;a href=&quot;qtextline#naturalTextRect&quot;&gt;QTextLine :: naturalTextRect&lt;/a&gt; ()는 텍스트의 후행 공백 너비를 포함하는 값을 리턴합니다. 그렇지 않으면이 너비는 제외됩니다.</target>
        </trans-unit>
        <trans-unit id="7e4b2c0654bf40a5f19574c6810ff26dfd4d2ceb" translate="yes" xml:space="preserve">
          <source>When this option is set, &lt;a href=&quot;qtextline#naturalTextWidth&quot;&gt;QTextLine::naturalTextWidth&lt;/a&gt;() and naturalTextRect() will return a value that includes the width of trailing spaces in the text; otherwise this width is excluded.</source>
          <target state="translated">이 옵션이 설정되면 &lt;a href=&quot;qtextline#naturalTextWidth&quot;&gt;QTextLine :: naturalTextWidth&lt;/a&gt; () 및 naturalTextRect ()는 텍스트의 후행 공백 너비를 포함하는 값을 리턴합니다. 그렇지 않으면이 너비는 제외됩니다.</target>
        </trans-unit>
        <trans-unit id="f271981227ef20d87cc64f0259c4f19f522399df" translate="yes" xml:space="preserve">
          <source>When this property changes, a scrollable view should automatically scroll itself in such a way as to ensure that this region is visible; for example, it could try to position the upper-left corner near the upper-left of its own viewport, subject to the constraints of the scrollable area.</source>
          <target state="translated">이 속성이 변경되면 스크롤 가능보기가 자동으로 스크롤되어이 영역이 표시되도록해야합니다. 예를 들어 스크롤 가능 영역의 제약에 따라 자체 뷰포트의 왼쪽 상단 근처에 왼쪽 상단 모서리를 배치하려고 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c42f5c456658d1e6cc7ae9de66d3b8a114c246a" translate="yes" xml:space="preserve">
          <source>When this property changes, the &lt;code&gt;topLevelChanged()&lt;/code&gt; signal is emitted.</source>
          <target state="translated">이 속성이 변경되면 &lt;code&gt;topLevelChanged()&lt;/code&gt; 신호가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="2e8947f71029eebb8d494bf176ad2f080cf20f26" translate="yes" xml:space="preserve">
          <source>When this property is &lt;code&gt;false&lt;/code&gt;, it's not possible to drag the dial across the from and to values.</source>
          <target state="translated">이 속성이 &lt;code&gt;false&lt;/code&gt; 인 경우 발신인과 발신인간에 다이얼을 드래그 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="2cf377eb087a92958eeac23380aef05f26d062d5" translate="yes" xml:space="preserve">
          <source>When this property is &lt;code&gt;true&lt;/code&gt; (the default), the next month, previous month, month selection, year selection controls are shown on top.</source>
          <target state="translated">이 속성이 &lt;code&gt;true&lt;/code&gt; (기본값)이면 다음 달, 이전 달, 월 선택, 연도 선택 컨트롤이 맨 위에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="e001d3612422e2e98bda1806f3de5d100dc0ffd9" translate="yes" xml:space="preserve">
          <source>When this property is &lt;code&gt;true&lt;/code&gt; and the &lt;a href=&quot;qml-qtquick3d-model#tessellationMode-prop&quot;&gt;tessellationMode&lt;/a&gt; is not Model.NoTessellation, a wireframe is displayed to highlight the additional geometry created by the tessellation generator.</source>
          <target state="translated">이 속성이 &lt;code&gt;true&lt;/code&gt; 이고 &lt;a href=&quot;qml-qtquick3d-model#tessellationMode-prop&quot;&gt;tessellationMode&lt;/a&gt; 가 Model.NoTessellation이 아닌 경우 테셀레이션 생성기에 의해 생성 된 추가 지오메트리를 강조하기 위해 와이어 프레임이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="7c6308ea5aac847e02c97a8f794ffa729d592dd4" translate="yes" xml:space="preserve">
          <source>When this property is &lt;code&gt;true&lt;/code&gt; object outside the frustum will be culled, meaning they will not be rendered. By default this property is set to &lt;code&gt;false&lt;/code&gt;, but for complex scene where a lot of the objects are outside the camera frustum it might be beneficial to enable frustum culling.</source>
          <target state="translated">이 속성이 &lt;code&gt;true&lt;/code&gt; 이면 절두체 외부의 개체가 컬링되어 렌더링되지 않습니다. 기본적으로이 속성은 &lt;code&gt;false&lt;/code&gt; 로 설정 되지만 많은 오브젝트가 카메라 절두체 외부에있는 복잡한 장면의 경우 절두체 컬링을 활성화하는 것이 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c6d22c0bbc6a53d1f13528b30f888d0610b3d76" translate="yes" xml:space="preserve">
          <source>When this property is &lt;code&gt;true&lt;/code&gt;, shadows can be cast onto this item. So the shadow map is applied to this model by the renderer.</source>
          <target state="translated">이 속성이 &lt;code&gt;true&lt;/code&gt; 이면 이 항목에 그림자를 드리울 수 있습니다. 따라서 렌더러가 그림자 맵을이 모델에 적용합니다.</target>
        </trans-unit>
        <trans-unit id="ae3ac6a5c511fb8757d09b3ced0b9ec19d6b694d" translate="yes" xml:space="preserve">
          <source>When this property is &lt;code&gt;true&lt;/code&gt;, the geometry of this model is used when rendering to the shadow maps.</source>
          <target state="translated">이 속성이 &lt;code&gt;true&lt;/code&gt; 이면 그림자 맵으로 렌더링 할 때이 모델의 지오메트리가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5435f7b9bf2979fd82564870b5b12500055a6cde" translate="yes" xml:space="preserve">
          <source>When this property is enabled it scatters the edges of the ambient occlusion shadow bands to improve smoothness (at the risk of sometimes producing obvious patterned artifacts).</source>
          <target state="translated">이 속성을 활성화하면 주변 폐색 섀도 밴드의 가장자리를 분산시켜 부드러움을 향상시킵니다 (때로는 명백한 패턴 아티팩트가 생성 될 위험이 있음).</target>
        </trans-unit>
        <trans-unit id="0e970705b8c985988e06ca43a11e32d86795a38e" translate="yes" xml:space="preserve">
          <source>When this property is enabled more shortcuts are taken to approximate the light contributes of the light probe at the expense of quality.</source>
          <target state="translated">이 속성이 활성화되면 품질을 희생하는 대신 라이트 프로브에 기여하는 라이트를 근사화하기 위해 더 많은 단축키가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7dac3a5e67061b28cd41b0e9edb5be2c4bdef12b" translate="yes" xml:space="preserve">
          <source>When this property is enabled temporal antialiasing will be used.</source>
          <target state="translated">이 속성이 활성화되면 임시 안티 앨리어싱이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3fd821d6a927b06c3741219adce2a495492f9002" translate="yes" xml:space="preserve">
          <source>When this property is enabled, the light will cast shadows. The default value is false.</source>
          <target state="translated">이 속성이 활성화되면 라이트가 그림자를 투사합니다. 기본값은 false입니다.</target>
        </trans-unit>
        <trans-unit id="100dd97a4fb38bb0a31c18fad05f76672fb1531a" translate="yes" xml:space="preserve">
          <source>When this property is enabled, the material will use vertex colors from the mesh. These will be multiplied by any other colors specified for the material.</source>
          <target state="translated">이 속성이 활성화되면 머티리얼은 메시의 버텍스 컬러를 사용합니다. 이것들은 재료에 지정된 다른 색상으로 곱해집니다.</target>
        </trans-unit>
        <trans-unit id="bf43a8d4ad0de35433838bc85feefa148dfa808b" translate="yes" xml:space="preserve">
          <source>When this property is set and the &lt;a href=&quot;qml-qtquick-springanimation#velocity-prop&quot;&gt;velocity&lt;/a&gt; value is greater than 0, the &lt;a href=&quot;qml-qtquick-springanimation#velocity-prop&quot;&gt;velocity&lt;/a&gt; limits the maximum speed.</source>
          <target state="translated">이 속성이 설정되고 &lt;a href=&quot;qml-qtquick-springanimation#velocity-prop&quot;&gt;속도&lt;/a&gt; 값이 0보다 큰 경우 &lt;a href=&quot;qml-qtquick-springanimation#velocity-prop&quot;&gt;속도&lt;/a&gt; 는 최대 속도를 제한합니다.</target>
        </trans-unit>
        <trans-unit id="bf92afa5571a2082abd019a22b3b5e076f89feca" translate="yes" xml:space="preserve">
          <source>When this property is set any current decoding is stopped, and any audio buffers are discarded.</source>
          <target state="translated">이 속성을 설정하면 현재 디코딩이 중지되고 모든 오디오 버퍼가 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="6f37ded37bad8b26d03755297e0d0d1d2d468416" translate="yes" xml:space="preserve">
          <source>When this property is set the tab widget frame is not rendered. This mode is useful for showing document-type pages where the page covers most of the tab widget area.</source>
          <target state="translated">이 속성을 설정하면 탭 위젯 프레임이 렌더링되지 않습니다. 이 모드는 페이지가 탭 위젯 영역의 대부분을 차지하는 문서 유형 페이지를 표시하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="bb1f39d69438f440f90e503c95bb71197010e140" translate="yes" xml:space="preserve">
          <source>When this property is set to &lt;a href=&quot;qcalendarwidget#SelectionMode-enum&quot;&gt;SingleSelection&lt;/a&gt;, the user can select a date within the minimum and maximum allowed dates, using either the mouse or the keyboard.</source>
          <target state="translated">이 특성이 &lt;a href=&quot;qcalendarwidget#SelectionMode-enum&quot;&gt;SingleSelection&lt;/a&gt; 으로 설정 되면 사용자는 마우스 또는 키보드를 사용하여 최소 및 최대 허용 날짜 내에서 날짜를 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4747a4a028b83a9e0e586a4b5157956a8881beee" translate="yes" xml:space="preserve">
          <source>When this property is set to &lt;a href=&quot;qt#CursorMoveStyle-enum&quot;&gt;Qt::VisualMoveStyle&lt;/a&gt;, the line edit will use visual movement style. Pressing the left arrow key will always cause the cursor to move left, regardless of the text's writing direction. The same behavior applies to right arrow key.</source>
          <target state="translated">이 속성을 &lt;a href=&quot;qt#CursorMoveStyle-enum&quot;&gt;Qt :: VisualMoveStyle로&lt;/a&gt; 설정 하면 선 편집시 시각적 이동 스타일이 사용됩니다. 왼쪽 화살표 키를 누르면 텍스트의 쓰기 방향에 관계없이 커서가 항상 왼쪽으로 이동합니다. 오른쪽 화살표 키에도 동일한 동작이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="6350e57b73a741c92757bc74c17a0770b6b20fee" translate="yes" xml:space="preserve">
          <source>When this property is set to &lt;code&gt;false&lt;/code&gt;, the Z-buffer is not used, the depth test is skipped, and all objects, including fully opaque ones, are rendered in one go sorted back to front.</source>
          <target state="translated">이 속성이 &lt;code&gt;false&lt;/code&gt; 로 설정 되면 Z 버퍼가 사용되지 않고 깊이 테스트가 건너 뛰며 완전히 불투명 한 개체를 포함한 모든 개체가 한 번에 렌더링되어 뒤에서 앞으로 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="0edc644e371fc7727ba54cb716093cdd57e0cd9c" translate="yes" xml:space="preserve">
          <source>When this property is set, the given folder will be treated as the root in the file system, so that you can only traverse subfolders within it.</source>
          <target state="translated">이 속성을 설정하면 지정된 폴더가 파일 시스템의 루트로 취급되므로 그 안에있는 하위 폴더 만 통과 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b2d44a4363149f5868c0478951229cd0f684ca40" translate="yes" xml:space="preserve">
          <source>When this property is set, the specified opacity is also applied individually to child items. This may have an unintended effect in some circumstances. For example in the second set of rectangles below, the red rectangle has specified an opacity of 0.5, which affects the opacity of its blue child rectangle even though the child has not specified an opacity.</source>
          <target state="translated">이 속성을 설정하면 지정된 불투명도가 하위 항목에도 개별적으로 적용됩니다. 일부 상황에서는 의도하지 않은 영향을 줄 수 있습니다. 예를 들어 아래 두 번째 사각형 집합에서 빨간색 사각형은 불투명도를 0.5로 지정했습니다. 이는 자식이 불투명도를 지정하지 않은 경우에도 파란색 자식 사각형의 불투명도에 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="1f016f4e737a52e8f462fcd37b82c141a90134d0" translate="yes" xml:space="preserve">
          <source>When this property is true, the Node (and its children) can be visible.</source>
          <target state="translated">이 속성이 true이면 노드 (및 그 자식)가 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d9f5748d3f3423c22760b03f83dc84f38b1f3b1f" translate="yes" xml:space="preserve">
          <source>When this propery is set to false text edit will accept only plain text input from the user. For example through clipboard or drag and drop.</source>
          <target state="translated">이 속성이 false로 설정되면 텍스트 편집은 사용자의 일반 텍스트 입력 만 허용합니다. 예를 들어 클립 보드 또는 드래그 앤 드롭을 통해.</target>
        </trans-unit>
        <trans-unit id="aec3729055d25b18cd030179a5d7fbd186ecaf3f" translate="yes" xml:space="preserve">
          <source>When this restore policy is set, the machine will automatically restore all properties. If it enters a state where a given property is not set, it will first search the hierarchy of ancestors to see if the property is defined there. If it is, the property will be restored to the value defined by the closest ancestor. If not, it will be restored to its initial value (i.e. the value of the property before any property assignments in states were executed.)</source>
          <target state="translated">이 복원 정책이 설정되면 머신은 모든 속성을 자동으로 복원합니다. 주어진 속성이 설정되지 않은 상태가되면 먼저 조상의 계층을 검색하여 속성이 정의되어 있는지 확인합니다. 있는 경우 속성은 가장 가까운 조상에 의해 정의 된 값으로 복원됩니다. 그렇지 않은 경우 초기 값 (즉, 상태의 속성 할당이 실행되기 전의 속성 값)으로 복원됩니다.</target>
        </trans-unit>
        <trans-unit id="2cb4559c1cf0ab4e52e4f01892955e108435ae26" translate="yes" xml:space="preserve">
          <source>When this signal is emitted, the event loop has already stopped running. No more events will be processed in the thread, except for deferred deletion events. This signal can be connected to &lt;a href=&quot;qobject#deleteLater&quot;&gt;QObject::deleteLater&lt;/a&gt;(), to free objects in that thread.</source>
          <target state="translated">이 신호가 발생하면 이벤트 루프가 이미 실행을 중지 한 것입니다. 지연된 삭제 이벤트를 제외하고는 더 이상 이벤트가 스레드에서 처리되지 않습니다. 이 신호는 &lt;a href=&quot;qobject#deleteLater&quot;&gt;QObject :: deleteLater&lt;/a&gt; ()에 연결하여 해당 스레드의 객체를 해제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc470d3a44b5fd1b983e2c2d38610b55df6e2808" translate="yes" xml:space="preserve">
          <source>When this signal is emitted, the socket may not be ready for a reconnect attempt. In that case, attempts to reconnect should be done from the event loop. For example, use a &lt;a href=&quot;qtimer#singleShot&quot;&gt;QTimer::singleShot&lt;/a&gt;() with 0 as the timeout.</source>
          <target state="translated">이 신호가 발생하면 소켓이 다시 연결을 시도 할 수 없습니다. 이 경우 이벤트 루프에서 다시 연결을 시도해야합니다. 예를 들어, &lt;a href=&quot;qtimer#singleShot&quot;&gt;QTimer :: singleShot&lt;/a&gt; ()을 시간 초과로 0으로 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="68f5a54216eb63b6271e28125c316438880cf091" translate="yes" xml:space="preserve">
          <source>When tr() is called, it looks up the translatable string using a &lt;a href=&quot;qtranslator&quot;&gt;QTranslator&lt;/a&gt; object. For translation to work, one or more of these must have been installed on the application object in the way described in &lt;a href=&quot;internationalization#enabling-translation&quot;&gt;Enabling Translation&lt;/a&gt;.</source>
          <target state="translated">tr ()이 호출되면 &lt;a href=&quot;qtranslator&quot;&gt;QTranslator&lt;/a&gt; 객체를 사용하여 번역 가능한 문자열을 찾습니다 . 번역이 작동하려면 번역 &lt;a href=&quot;internationalization#enabling-translation&quot;&gt;사용에&lt;/a&gt; 설명 된 방식으로 응용 프로그램 객체에 하나 이상이 설치되어 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="b9ebf77d443c0f3c1d237e7890cbd696ca28dded" translate="yes" xml:space="preserve">
          <source>When transforming a pixmap using the &lt;a href=&quot;qpixmap#transformed&quot;&gt;transformed&lt;/a&gt;() function, the transformation matrix is internally adjusted to compensate for unwanted translation, i.e. &lt;a href=&quot;qpixmap#transformed&quot;&gt;transformed&lt;/a&gt;() returns the smallest pixmap containing all transformed points of the original pixmap. This function returns the modified matrix, which maps points correctly from the original pixmap into the new pixmap.</source>
          <target state="translated">&lt;a href=&quot;qpixmap#transformed&quot;&gt;변환 된&lt;/a&gt; () 함수를 사용하여 픽스맵을 변환 할 때 변환 매트릭스는 원치 않는 변환을 보상하도록 내부적으로 조정됩니다. 즉, &lt;a href=&quot;qpixmap#transformed&quot;&gt;변환 된&lt;/a&gt; ()은 원래 픽스맵의 모든 변환 된 점을 포함하는 가장 작은 픽스맵을 반환합니다. 이 함수는 수정 된 행렬을 반환합니다.이 행렬은 원래 픽스맵의 포인트를 새로운 픽스맵으로 올바르게 매핑합니다.</target>
        </trans-unit>
        <trans-unit id="e797276249bcc854a69b6e49354f4d62d00c23f8" translate="yes" xml:space="preserve">
          <source>When transforming an embedded widget, Graphics View makes sure that the widget is transformed resolution independently, allowing the fonts and style to stay crisp when zoomed in. (Note that the effect of resolution independence depends on the style.)</source>
          <target state="translated">내장 된 위젯을 변환 할 때 기하 창은 위젯이 독립적으로 해상도를 변환하여 확대 할 때 글꼴과 스타일이 선명하게 유지되도록합니다. (해상도 독립의 영향은 스타일에 따라 다릅니다.)</target>
        </trans-unit>
        <trans-unit id="3aa1fd29b9548bcc37cb012b55271fdb19e2ee54" translate="yes" xml:space="preserve">
          <source>When transforming an image using the &lt;a href=&quot;qimage#transformed&quot;&gt;transformed&lt;/a&gt;() function, the transformation matrix is internally adjusted to compensate for unwanted translation, i.e. &lt;a href=&quot;qimage#transformed&quot;&gt;transformed&lt;/a&gt;() returns the smallest image containing all transformed points of the original image. This function returns the modified matrix, which maps points correctly from the original image into the new image.</source>
          <target state="translated">&lt;a href=&quot;qimage#transformed&quot;&gt;변환 된&lt;/a&gt; () 함수를 사용하여 이미지를 변환 할 때 변환 매트릭스는 원치 않는 변환을 보상하기 위해 내부적으로 조정됩니다. 즉 &lt;a href=&quot;qimage#transformed&quot;&gt;변환 된&lt;/a&gt; ()은 원래 이미지의 모든 변환 된 점을 포함하는 가장 작은 이미지를 반환합니다. 이 함수는 수정 된 행렬을 반환하여 원본 이미지의 포인트를 새 이미지에 올바르게 매핑합니다.</target>
        </trans-unit>
        <trans-unit id="4d6a460eeff2d6a334a698745ed9d8d6a6ebeec9" translate="yes" xml:space="preserve">
          <source>When transforming an image using the transformed() function, the transformation matrix is internally adjusted to compensate for unwanted translation, i.e. transformed() returns the smallest image containing all transformed points of the original image. This function returns the modified matrix, which maps points correctly from the original image into the new image.</source>
          <target state="translated">transformed () 함수를 사용하여 이미지를 변환 할 때 변환 행렬은 원하지 않는 변환을 보상하기 위해 내부적으로 조정됩니다. 즉, transformed ()는 원본 이미지의 모든 변환 된 점을 포함하는 가장 작은 이미지를 반환합니다. 이 함수는 원본 이미지의 점을 새 이미지로 올바르게 매핑하는 수정 된 행렬을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7221d90a96209f3128795a80a97a531cead2f548" translate="yes" xml:space="preserve">
          <source>When transforming from clip to normalized space, a division by the w component of the vector components takes place. To prevent dividing by 0 if w equals to 0, it is set to 1.</source>
          <target state="translated">클립에서 정규화 된 공간으로 변환 할 때 벡터 구성 요소의 w 구성 요소에 의한 나누기가 발생합니다. w가 0 인 경우 0으로 나누지 않도록하기 위해 1로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="fbec62568b02f257db0ec31fbe2b5f21cf0c220e" translate="yes" xml:space="preserve">
          <source>When transforming from clip to normalized space, a division by the w component on the vector components takes place. To prevent dividing by 0 if w equals to 0, it is set to 1.</source>
          <target state="translated">클립에서 정규화 된 공간으로 변환 할 때 벡터 구성 요소에서 w 구성 요소로 나누기가 발생합니다. w가 0 인 경우 0으로 나누지 못하게하려면 1로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="f520f592321df5d529bf39711026e14f01be91fb" translate="yes" xml:space="preserve">
          <source>When true, the menu contains a special tear-off item (often shown as a dashed line at the top of the menu) that creates a copy of the menu when it is triggered.</source>
          <target state="translated">true 인 경우, 메뉴는 트리거 될 때 메뉴 사본을 작성하는 특수 분리 항목 (종종 메뉴 상단에 점선으로 표시됨)을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="a89b60404dcbc2f5c915acfe02c16712d4bb61d2" translate="yes" xml:space="preserve">
          <source>When two manuals are located in the same virtual folder, it is possible to refer to sections of the other manual using relative paths. The virtual folder tag is mandatory and the folder must not contain any '/'.</source>
          <target state="translated">두 개의 매뉴얼이 동일한 가상 폴더에있는 경우 상대 경로를 사용하여 다른 매뉴얼의 섹션을 참조 할 수 있습니다. 가상 폴더 태그는 필수이며 폴더에는 '/'가 포함되지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="611300300598b513a04acdc4158b65a1b90365bd" translate="yes" xml:space="preserve">
          <source>When two widgets are adjacent to each other in a horizontal layout, setting the horizontal stretch factor of the widget on the left to 2 and the factor of widget on the right to 1 will ensure that the widget on the left will always be twice the size of the one on the right.</source>
          <target state="translated">두 개의 위젯이 가로 레이아웃에서 서로 인접한 경우 왼쪽의 위젯의 가로 스트레치 계수를 2로 설정하고 오른쪽의 위젯 계수를 1로 설정하면 왼쪽의 위젯이 항상 두 배 크기가됩니다. 오른쪽에있는</target>
        </trans-unit>
        <trans-unit id="33931b591564c5ce659c5439a00ac167ba2235e2" translate="yes" xml:space="preserve">
          <source>When two widgets are adjacent to each other in a vertical layout, setting the vertical stretch factor of the widget on the top to 2 and the factor of widget on the bottom to 1 will ensure that the widget on the top will always be twice the size of the one on the bottom.</source>
          <target state="translated">두 개의 위젯이 세로 레이아웃에서 서로 인접한 경우 상단의 위젯의 세로 스트레치 팩터를 2로 설정하고 하단의 위젯 팩터를 1로 설정하면 상단의 위젯이 항상 두 배 크기가됩니다. 바닥에있는 것의.</target>
        </trans-unit>
        <trans-unit id="55c03842e144167485cbd5e8643bcbb80f6a7794" translate="yes" xml:space="preserve">
          <source>When unshared (or const version is called), this executes in &lt;a href=&quot;containers#constant-time&quot;&gt;constant time&lt;/a&gt;.</source>
          <target state="translated">비공유 (또는 const 버전이 호출 될 때) &lt;a href=&quot;containers#constant-time&quot;&gt;상수 시간에&lt;/a&gt; 실행됩니다 .</target>
        </trans-unit>
        <trans-unit id="bcc9e75ff489b96d3335be53af67c254b116188b" translate="yes" xml:space="preserve">
          <source>When unshared (or const version is called), this executes in &lt;a href=&quot;containers#logarithmic-time&quot;&gt;logarithmic time&lt;/a&gt;.</source>
          <target state="translated">비공유 (또는 const 버전이 호출 될 때)는 &lt;a href=&quot;containers#logarithmic-time&quot;&gt;로그 시간으로&lt;/a&gt; 실행됩니다 .</target>
        </trans-unit>
        <trans-unit id="991f02e2c91e5a7647479f2f811f8738759e3c87" translate="yes" xml:space="preserve">
          <source>When updating the current time, &lt;a href=&quot;qtimeline&quot;&gt;QTimeLine&lt;/a&gt; will emit &lt;a href=&quot;qtimeline#valueChanged&quot;&gt;valueChanged&lt;/a&gt;() if the current value changed, and &lt;a href=&quot;qtimeline#frameChanged&quot;&gt;frameChanged&lt;/a&gt;() if the frame changed.</source>
          <target state="translated">현재 시간을 업데이트 할 때 &lt;a href=&quot;qtimeline&quot;&gt;QTimeLine&lt;/a&gt; 은 현재 값이 변경된 경우 &lt;a href=&quot;qtimeline#valueChanged&quot;&gt;valueChanged&lt;/a&gt; ()를 , 프레임이 변경된 경우 &lt;a href=&quot;qtimeline#frameChanged&quot;&gt;frameChanged&lt;/a&gt; ()를 방출 합니다.</target>
        </trans-unit>
        <trans-unit id="daf7b6e7fdbba2dfca1eadbe18a1d7de3b720e7b" translate="yes" xml:space="preserve">
          <source>When used as a context menu, the recommended way of opening the menu is to call &lt;a href=&quot;qml-qtquick-controls2-menu#popup-method&quot;&gt;popup()&lt;/a&gt;. Unless a position is explicitly specified, the menu is positioned at the mouse cursor on desktop platforms that have a mouse cursor available, and otherwise centered over its parent item.</source>
          <target state="translated">상황에 맞는 메뉴로 사용되는 경우 메뉴를 여는 권장 방법은 &lt;a href=&quot;qml-qtquick-controls2-menu#popup-method&quot;&gt;popup ()&lt;/a&gt; 을 호출하는 것 입니다. 위치를 명시 적으로 지정하지 않으면 메뉴는 마우스 커서를 사용할 수 있고 상위 항목의 중앙에있는 데스크탑 플랫폼에서 마우스 커서에 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="e42ccc06c2943db340e29e9634bf18dbc9e13468" translate="yes" xml:space="preserve">
          <source>When used as a popup menu, it is easiest to specify the position by specifying the desired &lt;a href=&quot;qml-qtquick-controls2-popup#x-prop&quot;&gt;x&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-controls2-popup#y-prop&quot;&gt;y&lt;/a&gt; coordinates using the respective properties, and call &lt;a href=&quot;qml-qtquick-controls2-popup#open-method&quot;&gt;open()&lt;/a&gt; to open the menu.</source>
          <target state="translated">팝업 메뉴로 사용되는 경우 각 속성을 사용하여 원하는 &lt;a href=&quot;qml-qtquick-controls2-popup#x-prop&quot;&gt;x&lt;/a&gt; 및 &lt;a href=&quot;qml-qtquick-controls2-popup#y-prop&quot;&gt;y&lt;/a&gt; 좌표 를 지정하여 위치를 지정하는 것이 가장 쉬우 &lt;a href=&quot;qml-qtquick-controls2-popup#open-method&quot;&gt;며 open ()&lt;/a&gt; 을 호출 하여 메뉴를 엽니 다.</target>
        </trans-unit>
        <trans-unit id="51c1a4b96d0ac9fe7349345183028fcd340a1cf9" translate="yes" xml:space="preserve">
          <source>When used as a standalone application,</source>
          <target state="translated">독립형 응용 프로그램으로 사용되는 경우</target>
        </trans-unit>
        <trans-unit id="7c8523a9cdaa732605d1c3ca0c57e7327514b32b" translate="yes" xml:space="preserve">
          <source>When used as an interface type, &lt;a href=&quot;qstringview&quot;&gt;QStringView&lt;/a&gt; allows a single function to accept a wide variety of UTF-16 string data sources. One function accepting &lt;a href=&quot;qstringview&quot;&gt;QStringView&lt;/a&gt; thus replaces three function overloads (taking &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;, &lt;a href=&quot;qstringref&quot;&gt;QStringRef&lt;/a&gt;, and &lt;code&gt;(const QChar*, int)&lt;/code&gt;), while at the same time enabling even more string data sources to be passed to the function, such as &lt;code&gt;u&quot;Hello World&quot;&lt;/code&gt;, a &lt;code&gt;char16_t&lt;/code&gt; string literal.</source>
          <target state="translated">인터페이스 유형으로 사용될 때 &lt;a href=&quot;qstringview&quot;&gt;QStringView를&lt;/a&gt; 사용하면 단일 함수가 다양한 UTF-16 문자열 데이터 소스를 승인 할 수 있습니다. 따라서 &lt;a href=&quot;qstringview&quot;&gt;QStringView&lt;/a&gt; 를 수락하는 하나의 함수 는 세 개의 함수 오버로드 ( &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; , &lt;a href=&quot;qstringref&quot;&gt;QStringRef&lt;/a&gt; 및 &lt;code&gt;(const QChar*, int)&lt;/code&gt; ) 를 대체 하는 동시에 &lt;code&gt;u&quot;Hello World&quot;&lt;/code&gt; 와 같이 더 많은 문자열 데이터 소스를 함수에 전달할 수 있습니다. 하는 &lt;code&gt;char16_t&lt;/code&gt; 의 문자열 리터럴.</target>
        </trans-unit>
        <trans-unit id="3d30f2719e4dfd488693920afd51d738514f58fc" translate="yes" xml:space="preserve">
          <source>When used as an interface type, QStringView allows a single function to accept a wide variety of UTF-16 string data sources. One function accepting QStringView thus replaces three function overloads (taking &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;, &lt;a href=&quot;qstringref&quot;&gt;QStringRef&lt;/a&gt;, and &lt;code&gt;(const QChar*, int)&lt;/code&gt;), while at the same time enabling even more string data sources to be passed to the function, such as &lt;code&gt;u&quot;Hello World&quot;&lt;/code&gt;, a &lt;code&gt;char16_t&lt;/code&gt; string literal.</source>
          <target state="translated">인터페이스 유형으로 사용되는 경우 QStringView를 사용하면 단일 함수가 다양한 UTF-16 문자열 데이터 소스를 허용 할 수 있습니다. 따라서 QStringView를 허용하는 하나의 함수는 3 개의 함수 오버로드 ( &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; , &lt;a href=&quot;qstringref&quot;&gt;QStringRef&lt;/a&gt; 및 &lt;code&gt;(const QChar*, int)&lt;/code&gt; ) 를 대체 하는 동시에 &lt;code&gt;u&quot;Hello World&quot;&lt;/code&gt; 와 같은 더 많은 문자열 데이터 소스를 함수에 전달할 수 있습니다. , &lt;code&gt;char16_t&lt;/code&gt; 문자열 리터럴.</target>
        </trans-unit>
        <trans-unit id="2e868d59396f0fc788445bb00690275ea6245ac1" translate="yes" xml:space="preserve">
          <source>When used as flags, enumerators can be combined using the OR operator.</source>
          <target state="translated">플래그로 사용될 때 OR 연산자를 사용하여 열거자를 결합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="06c2c617a12597a994b108366e0d50cfb932d1fd" translate="yes" xml:space="preserve">
          <source>When used as part of a Transition, you can also target a specific &lt;a href=&quot;qml-qtquick-statechangescript&quot;&gt;StateChangeScript&lt;/a&gt; to run using the &lt;code&gt;scriptName&lt;/code&gt; property.</source>
          <target state="translated">전환의 일부로 사용되는 경우 &lt;code&gt;scriptName&lt;/code&gt; 속성을 사용하여 특정 &lt;a href=&quot;qml-qtquick-statechangescript&quot;&gt;StateChangeScript&lt;/a&gt; 를 실행하도록 대상을 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="59f0102a4ce38b4f2ee3e6dec5be09d72963e0c7" translate="yes" xml:space="preserve">
          <source>When used in a &lt;a href=&quot;qml-qtquick-sequentialanimation&quot;&gt;SequentialAnimation&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-pauseanimation&quot;&gt;PauseAnimation&lt;/a&gt; is a step when nothing happens, for a specified duration.</source>
          <target state="translated">A의 사용하는 경우 &lt;a href=&quot;qml-qtquick-sequentialanimation&quot;&gt;SequentialAnimation&lt;/a&gt; , &lt;a href=&quot;qml-qtquick-pauseanimation&quot;&gt;PauseAnimation는&lt;/a&gt; 아무것도 지정된 기간 동안, 일이 없을 때 단계입니다.</target>
        </trans-unit>
        <trans-unit id="32a85cc6f1a776a818b49cfac1cb9534a2a52415" translate="yes" xml:space="preserve">
          <source>When used in a &lt;a href=&quot;qml-qtquick-sequentialanimation&quot;&gt;SequentialAnimation&lt;/a&gt;, PauseAnimation is a step when nothing happens, for a specified duration.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-sequentialanimation&quot;&gt;SequentialAnimation&lt;/a&gt; 에서 사용하면 PauseAnimation은 지정된 기간 동안 아무 일도 일어나지 않는 단계입니다.</target>
        </trans-unit>
        <trans-unit id="a1ec54421dbb8796f81a74d96171dee0c22a448e" translate="yes" xml:space="preserve">
          <source>When used in a transition, a property animation is assumed to match</source>
          <target state="translated">전환에 사용될 때 속성 애니메이션이 일치하는 것으로 가정</target>
        </trans-unit>
        <trans-unit id="c62896cbdfc7c3f4c1df9f239489204e6ebe788a" translate="yes" xml:space="preserve">
          <source>When used in a transition, if no target is specified, all &lt;a href=&quot;qml-qtquick-parentchange&quot;&gt;ParentChange&lt;/a&gt; occurrences are animated by the &lt;a href=&quot;qml-qtquick-parentanimation&quot;&gt;ParentAnimation&lt;/a&gt;.</source>
          <target state="translated">전환에 사용될 때 대상을 지정하지 않으면 모든 &lt;a href=&quot;qml-qtquick-parentchange&quot;&gt;ParentChange&lt;/a&gt; 발생이 &lt;a href=&quot;qml-qtquick-parentanimation&quot;&gt;ParentAnimation에&lt;/a&gt; 의해 애니메이션됩니다 .</target>
        </trans-unit>
        <trans-unit id="28b437395e782784d83371eebd653fd7c3c66b90" translate="yes" xml:space="preserve">
          <source>When used in a transition, the path can be specified without start or end points, for example:</source>
          <target state="translated">전환에 사용될 때 경로는 시작점 또는 끝점없이 지정할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ad15b94076fc6d62e74b16ac21ba031bb2e8713a" translate="yes" xml:space="preserve">
          <source>When used in combination with &lt;a href=&quot;qtreeview&quot;&gt;QTreeView&lt;/a&gt;, the first column is not movable (since it contains the tree structure), by default. You can make it movable with &lt;a href=&quot;qheaderview#firstSectionMovable-prop&quot;&gt;setFirstSectionMovable&lt;/a&gt;(true).</source>
          <target state="translated">&lt;a href=&quot;qtreeview&quot;&gt;QTreeView&lt;/a&gt; 와 함께 사용하면 기본적 으로 첫 번째 열은 이동 가능하지 않습니다 (트리 구조를 포함하므로). &lt;a href=&quot;qheaderview#firstSectionMovable-prop&quot;&gt;setFirstSectionMovable&lt;/a&gt; (true)로 이동 가능하게 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="80921d8c37af7cbb33ff4de031ae482a77195e92" translate="yes" xml:space="preserve">
          <source>When used in conjunction with QTextureWrapMode::Repeat, textureScale provides a simple way to tile a texture across a surface. For example, a texture scale of &lt;code&gt;4.0&lt;/code&gt; would result in 16 (4x4) tiles.</source>
          <target state="translated">QTextureWrapMode :: Repeat와 함께 사용하면 textureScale은 표면에 텍스처를 타일링하는 간단한 방법을 제공합니다. 예를 들어 텍스처 배율이 &lt;code&gt;4.0&lt;/code&gt; 이면 16 (4x4) 타일이됩니다.</target>
        </trans-unit>
        <trans-unit id="8adf2789c382dae59470f104ac31491a01be4c17" translate="yes" xml:space="preserve">
          <source>When used in conjunction with WrapMode.Repeat, textureScale provides a simple way to tile a texture across a surface. For example, a texture scale of &lt;code&gt;4.0&lt;/code&gt; would result in 16 (4x4) tiles.</source>
          <target state="translated">WrapMode.Repeat와 함께 사용할 때 textureScale은 표면에 텍스처를 타일링하는 간단한 방법을 제공합니다. 예를 들어 텍스처 배율이 &lt;code&gt;4.0&lt;/code&gt; 이면 16 (4x4) 타일이됩니다.</target>
        </trans-unit>
        <trans-unit id="004dc51d90326bec6d46cfd29896a25f4617d992" translate="yes" xml:space="preserve">
          <source>When used in conjunction with the &lt;a href=&quot;qml-qtquick-loader#source-prop&quot;&gt;source&lt;/a&gt; property, loading and compilation will also be performed in a background thread.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-loader#source-prop&quot;&gt;source&lt;/a&gt; 속성 과 함께 사용 하면 백그라운드 스레드에서도로드 및 컴파일이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="50af634dadcc9340640490a9af221cd3bbb07199" translate="yes" xml:space="preserve">
          <source>When used in conjunction with the &lt;a href=&quot;qml-qtquick3d-loader3d#source-prop&quot;&gt;source&lt;/a&gt; property, loading and compilation will also be performed in a background thread.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick3d-loader3d#source-prop&quot;&gt;source&lt;/a&gt; 속성 과 함께 사용하면 로드 및 컴파일도 백그라운드 스레드에서 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="4b5ebb2f8eef3c956f23605775c3ca22ba3215b5" translate="yes" xml:space="preserve">
          <source>When used with list models, the first item in the returned list is used for matching.</source>
          <target state="translated">목록 모델과 함께 사용하면 반환 된 목록의 첫 번째 항목이 일치하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2aa79e373766a60d20b2141aeac582a5a8df07d6" translate="yes" xml:space="preserve">
          <source>When user defines a new functor or generator, they need to implement the &lt;a href=&quot;qt3drender-qabstractfunctor#id&quot;&gt;QAbstractFunctor::id&lt;/a&gt;() method, which should be done using the &lt;code&gt;QT3D_FUNCTOR&lt;/code&gt; macro in the class definition.</source>
          <target state="translated">사용자가 새로운 functor 또는 generator를 정의 할 때 클래스 정의에서 &lt;code&gt;QT3D_FUNCTOR&lt;/code&gt; 매크로를 사용하여 수행해야하는 &lt;a href=&quot;qt3drender-qabstractfunctor#id&quot;&gt;QAbstractFunctor :: id&lt;/a&gt; () 메소드 를 구현 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="1426cfebd5b7719f33b6e2b9f2a97f042b4572ab" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;qabstractscrollarea&quot;&gt;QAbstractScrollArea&lt;/a&gt; based widgets, you should enable the &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt::WA_AcceptTouchEvents&lt;/a&gt; attribute on the scroll area's &lt;a href=&quot;qabstractscrollarea#viewport&quot;&gt;viewport&lt;/a&gt;.</source>
          <target state="translated">사용하는 경우 &lt;a href=&quot;qabstractscrollarea&quot;&gt;QAbstractScrollArea&lt;/a&gt; 기반의 위젯을, 당신은 활성화해야 &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt는 :: WA_AcceptTouchEvents의&lt;/a&gt; 스크롤 영역의에 속성 &lt;a href=&quot;qabstractscrollarea#viewport&quot;&gt;뷰포트를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="575c3ca33cbc8c0e49967dd6868de7d0cd46c7ed" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;qfuture&quot;&gt;QFuture&lt;/a&gt;, transferred exceptions will be thrown when calling the following functions:</source>
          <target state="translated">&lt;a href=&quot;qfuture&quot;&gt;QFuture를&lt;/a&gt; 사용 하면 다음 함수를 호출 할 때 전송 된 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6d8f6cec0c5597c992eb3a8a60ec3ad82996acf4" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;qml-qt3d-render-objectpicker&quot;&gt;ObjectPicker&lt;/a&gt; components, picking is triggered by mouse events.</source>
          <target state="translated">&lt;a href=&quot;qml-qt3d-render-objectpicker&quot;&gt;ObjectPicker&lt;/a&gt; 구성 요소를 사용 하는 경우 마우스 이벤트에 의해 피킹이 트리거됩니다.</target>
        </trans-unit>
        <trans-unit id="84a71d92671a35f5e7502b348babb72bc64cf8ed" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;qml-qt3d-render-raycaster&quot;&gt;RayCaster&lt;/a&gt; or &lt;a href=&quot;qml-qt3d-render-screenraycaster&quot;&gt;ScreenRayCaster&lt;/a&gt; components, picking can be explicitly triggered by the application.</source>
          <target state="translated">&lt;a href=&quot;qml-qt3d-render-raycaster&quot;&gt;RayCaster&lt;/a&gt; 또는 &lt;a href=&quot;qml-qt3d-render-screenraycaster&quot;&gt;ScreenRayCaster&lt;/a&gt; 구성 요소를 사용 하는 경우 응용 프로그램에서 피킹을 명시 적으로 트리거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b9d22db787646c3b272fef7eabbedc341942ce2" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;qpointer&quot;&gt;QPointer&lt;/a&gt; on a &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; (or a subclass of &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt;), previously the &lt;a href=&quot;qpointer&quot;&gt;QPointer&lt;/a&gt; would be cleared by the &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; destructor. Now, the &lt;a href=&quot;qpointer&quot;&gt;QPointer&lt;/a&gt; is cleared by the &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; destructor (since this is when &lt;a href=&quot;qweakpointer&quot;&gt;QWeakPointer&lt;/a&gt; objects are cleared). Any QPointers tracking a widget will &lt;b&gt;NOT&lt;/b&gt; be cleared before the &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; destructor destroys the children for the widget being tracked.</source>
          <target state="translated">사용하는 경우 &lt;a href=&quot;qpointer&quot;&gt;QPointer을&lt;/a&gt; A의 &lt;a href=&quot;qwidget&quot;&gt;는 QWidget&lt;/a&gt; (또는 서브 클래스 &lt;a href=&quot;qwidget&quot;&gt;는 QWidget&lt;/a&gt; ), 이전에 &lt;a href=&quot;qpointer&quot;&gt;QPointer는&lt;/a&gt; 에 의해 삭제 될 수 &lt;a href=&quot;qwidget&quot;&gt;는 QWidget의&lt;/a&gt; 소멸자. 이제, &lt;a href=&quot;qpointer&quot;&gt;QPointer는&lt;/a&gt; 에 의해 삭제됩니다 &lt;a href=&quot;qobject&quot;&gt;QObject를의&lt;/a&gt; (때이기 때문에 소멸자 &lt;a href=&quot;qweakpointer&quot;&gt;QWeakPointer의&lt;/a&gt; 객체가 지워집니다). 위젯을 추적하는 QPointer 는 &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; 소멸자가 추적중인 위젯의 하위를 파괴 하기 전에 지워지지 &lt;b&gt;않습니다&lt;/b&gt; .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
