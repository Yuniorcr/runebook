<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="qt">
    <body>
      <group id="qt">
        <trans-unit id="411720087ef746e288e2f05414ea066eb17de5da" translate="yes" xml:space="preserve">
          <source>The value is one of &lt;a href=&quot;qabstract3daxis#AxisOrientation-enum&quot;&gt;AxisOrientation&lt;/a&gt; values.</source>
          <target state="translated">값은 &lt;a href=&quot;qabstract3daxis#AxisOrientation-enum&quot;&gt;AxisOrientation&lt;/a&gt; 값 중 하나입니다 .</target>
        </trans-unit>
        <trans-unit id="b2090875c573bfadfb0dae43b71ee3d1ed7675e5" translate="yes" xml:space="preserve">
          <source>The value is one of &lt;a href=&quot;qabstract3daxis#AxisType-enum&quot;&gt;AxisType&lt;/a&gt; values.</source>
          <target state="translated">값은 &lt;a href=&quot;qabstract3daxis#AxisType-enum&quot;&gt;AxisType&lt;/a&gt; 값 중 하나입니다 .</target>
        </trans-unit>
        <trans-unit id="6da1c1605e2ffefbe783b7426381ed59073f0eb2" translate="yes" xml:space="preserve">
          <source>The value is optional and contains the size in bytes of the object that the URI refers to. It may be used by the device to determine whether it can accommodate the object.</source>
          <target state="translated">값은 선택 사항이며 URI가 참조하는 오브젝트의 크기 (바이트)를 포함합니다. 그것은 장치에 의해 물체를 수용 할 수 있는지를 결정하는데 사용될 수있다.</target>
        </trans-unit>
        <trans-unit id="d618d99e9c5ef83db12df1392f7e7cf6504de542" translate="yes" xml:space="preserve">
          <source>The value is relative to the chart rectangle, so that:</source>
          <target state="translated">값은 차트 사각형을 기준으로하므로 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1c033927067315e95ea5e7ec465d6addbf38d491" translate="yes" xml:space="preserve">
          <source>The value is relative to the contents rect in the &lt;a href=&quot;stylesheet-customizing#the-box-model&quot;&gt;box model&lt;/a&gt;.</source>
          <target state="translated">값은 &lt;a href=&quot;stylesheet-customizing#the-box-model&quot;&gt;상자 모델&lt;/a&gt; 의 내용을 기준으로합니다 .</target>
        </trans-unit>
        <trans-unit id="cdb1649faa4d6c0e5fd2ab71a48ab46c6821fde3" translate="yes" xml:space="preserve">
          <source>The value is reported for both the x and y axis separately by using a &lt;a href=&quot;qpointf&quot;&gt;QPointF&lt;/a&gt;.</source>
          <target state="translated">값은 &lt;a href=&quot;qpointf&quot;&gt;QPointF&lt;/a&gt; 를 사용하여 x 축과 y 축 모두에 대해 별도로보고됩니다 .</target>
        </trans-unit>
        <trans-unit id="f3d898b9490ba0dcf5a3b449afb94ecd5c8919b8" translate="yes" xml:space="preserve">
          <source>The value is taken from the first item in the item model that matches each row/column combination.</source>
          <target state="translated">값은 각 행 / 열 조합과 일치하는 항목 모델의 첫 번째 항목에서 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="b20da44291f992870702c815c90c513e3f36d00a" translate="yes" xml:space="preserve">
          <source>The value is taken from the last item in the item model that matches each row/column combination.</source>
          <target state="translated">각 행 / 열 조합과 일치하는 항목 모델의 마지막 항목에서 값을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="d333a67df3a7b143f6e78a0a7adc00e490c818e6" translate="yes" xml:space="preserve">
          <source>The value is the current playback position, expressed in milliseconds since the beginning of the media. Periodically changes in the position will be indicated with the signal &lt;a href=&quot;qmediaplayer#positionChanged&quot;&gt;positionChanged&lt;/a&gt;(), the interval between updates can be set with &lt;a href=&quot;qmediaobject&quot;&gt;QMediaObject&lt;/a&gt;'s method &lt;a href=&quot;qmediaobject#notifyInterval-prop&quot;&gt;setNotifyInterval&lt;/a&gt;().</source>
          <target state="translated">값은 미디어가 시작된 이후 밀리 초로 표시되는 현재 재생 위치입니다. 주기적 위치 변화를 신호로 표시된다 &lt;a href=&quot;qmediaplayer#positionChanged&quot;&gt;positionChanged&lt;/a&gt; (), 업데이트 간격이 설정 될 수 &lt;a href=&quot;qmediaobject&quot;&gt;QMediaObject&lt;/a&gt; 의 방법 &lt;a href=&quot;qmediaobject#notifyInterval-prop&quot;&gt;setNotifyInterval&lt;/a&gt; ().</target>
        </trans-unit>
        <trans-unit id="4d6961d1fcae57c36c6ef17949fb292aff3ba769" translate="yes" xml:space="preserve">
          <source>The value is the orientation angle (clockwise, in steps of 90 degrees) of the camera sensor in relation to the display in its natural orientation.</source>
          <target state="translated">이 값은 자연스러운 방향의 디스플레이와 관련하여 카메라 센서의 방향 각도 (시계 방향, 90도 단위)입니다.</target>
        </trans-unit>
        <trans-unit id="e384814c6864d6e190314c89c4d40b16e42924e3" translate="yes" xml:space="preserve">
          <source>The value is the total playback time in milliseconds of the current media. The value may change across the life time of the &lt;a href=&quot;qmediaplayer&quot;&gt;QMediaPlayer&lt;/a&gt; object and may not be available when initial playback begins, connect to the &lt;a href=&quot;qmediaplayer#durationChanged&quot;&gt;durationChanged&lt;/a&gt;() signal to receive status notifications.</source>
          <target state="translated">값은 현재 미디어의 총 재생 시간 (밀리 초)입니다. 값은 &lt;a href=&quot;qmediaplayer&quot;&gt;QMediaPlayer&lt;/a&gt; 객체 의 수명 시간 동안 변경 될 수 있으며 초기 재생이 시작될 때 사용할 수없는 경우 &lt;a href=&quot;qmediaplayer#durationChanged&quot;&gt;durationChanged&lt;/a&gt; () 신호에 연결하여 상태 알림을 수신합니다.</target>
        </trans-unit>
        <trans-unit id="54a70aeb3b835ede81221182e92a5e7984bbd24d" translate="yes" xml:space="preserve">
          <source>The value is typically the return value from vkCreateInstance() (when creating a new Vulkan instance instead of adopting an existing one), but may also be &lt;code&gt;VK_NOT_READY&lt;/code&gt; if the platform plugin does not support Vulkan.</source>
          <target state="translated">값은 일반적으로 vkCreateInstance ()의 리턴 값 (기존 인스턴스를 채택하는 대신 새 Vulkan 인스턴스를 작성할 때)이지만 플랫폼 플러그인이 Vulkan을 지원하지 않는 경우 &lt;code&gt;VK_NOT_READY&lt;/code&gt; 일 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9f257a5935d070efe00e68257ebf34582ae3c347" translate="yes" xml:space="preserve">
          <source>The value is undefined. This is usually returned as an error condition, when trying to read an out of bounds value in an array or a non existent key in an object.</source>
          <target state="translated">값이 정의되지 않았습니다. 이것은 일반적으로 배열의 범위를 벗어난 값을 읽거나 객체에 존재하지 않는 키를 읽으려고 할 때 오류 조건으로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="e113c4a8c1f9a88762018d9a8346111e7135c16c" translate="yes" xml:space="preserve">
          <source>The value is used by the &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; class when it is constructed using the empty constructor. This saves having to repeat this information each time a &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; object is created.</source>
          <target state="translated">값은 빈 생성자를 사용하여 생성 될 때 &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; 클래스에서 사용됩니다 . &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; 객체가 생성 될 때 마다이 정보를 반복 할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="55c4aaf3b9415c854bccf32e2e15324cd32ffead" translate="yes" xml:space="preserve">
          <source>The value is written to the local service database. If the contents of</source>
          <target state="translated">값은 로컬 서비스 데이터베이스에 기록됩니다. 내용이</target>
        </trans-unit>
        <trans-unit id="b82edbd713334497fb7bad7d13b29569f455da35" translate="yes" xml:space="preserve">
          <source>The value must be 2, 3, or 4. The default value is 2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b3537cfc23241999d34572b8c5ef038a57c2bbb" translate="yes" xml:space="preserve">
          <source>The value must be a &lt;code&gt;file&lt;/code&gt;: or &lt;code&gt;qrc&lt;/code&gt;: URL, or a relative URL.</source>
          <target state="translated">값은 &lt;code&gt;file&lt;/code&gt; : 또는 &lt;code&gt;qrc&lt;/code&gt; : URL 또는 상대 URL 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="2a34d16e10ee0e05b17930d11b09b51aeec2b5f7" translate="yes" xml:space="preserve">
          <source>The value must be between 0.0 and 50.0. The default value is 50.0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4d2e674e79ae76bcabd00fb743e0910cdb31b58" translate="yes" xml:space="preserve">
          <source>The value must be between &lt;code&gt;0.0f&lt;/code&gt; and &lt;code&gt;1.0f&lt;/code&gt;.</source>
          <target state="translated">값은 &lt;code&gt;0.0f&lt;/code&gt; ~ &lt;code&gt;1.0f&lt;/code&gt; 사이 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="f03e3fe1eb2ef4c116ef9f86a142ea6a4e25a2f9" translate="yes" xml:space="preserve">
          <source>The value must be between &lt;code&gt;0.0f&lt;/code&gt; and &lt;code&gt;10.0f&lt;/code&gt;.</source>
          <target state="translated">값은 &lt;code&gt;0.0f&lt;/code&gt; 와 &lt;code&gt;10.0f&lt;/code&gt; 사이 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="419ba3429f66d50788a136e1ccd84f3cff288834" translate="yes" xml:space="preserve">
          <source>The value must be in the range from &lt;code&gt;-271820&lt;/code&gt; to &lt;code&gt;275759&lt;/code&gt;. The default value is the current year.</source>
          <target state="translated">값의 범위에 있어야합니다 &lt;code&gt;-271820&lt;/code&gt; 에 &lt;code&gt;275759&lt;/code&gt; . 기본값은 현재 연도입니다.</target>
        </trans-unit>
        <trans-unit id="e42d44271b5375ab6e5232f35c866687d8c2495b" translate="yes" xml:space="preserve">
          <source>The value of</source>
          <target state="translated">의 가치</target>
        </trans-unit>
        <trans-unit id="adab2408bf95239fee57ebdd6d86f2f36e800af1" translate="yes" xml:space="preserve">
          <source>The value of &lt;a href=&quot;qgeoroutesegment#nextRouteSegment&quot;&gt;nextRouteSegment&lt;/a&gt;() is not considered in the comparison.</source>
          <target state="translated">&lt;a href=&quot;qgeoroutesegment#nextRouteSegment&quot;&gt;nextRouteSegment&lt;/a&gt; () 의 값은 비교에서 고려되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2b4f2f10ceed2c7ae94232d73cca2dd319d37e31" translate="yes" xml:space="preserve">
          <source>The value of &lt;a href=&quot;qml-qtquick-item#opacity-prop&quot;&gt;Item::opacity&lt;/a&gt; is updated after the animation has finished.</source>
          <target state="translated">애니메이션이 끝나면 &lt;a href=&quot;qml-qtquick-item#opacity-prop&quot;&gt;Item :: opacity&lt;/a&gt; 의 값 이 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="97c06b7b5c473cc8493581eeb8469495abbdbb64" translate="yes" xml:space="preserve">
          <source>The value of &lt;a href=&quot;qml-qtquick-item#rotation-prop&quot;&gt;Item::rotation&lt;/a&gt; is updated after the animation has finished.</source>
          <target state="translated">애니메이션이 끝나면 &lt;a href=&quot;qml-qtquick-item#rotation-prop&quot;&gt;Item :: rotation&lt;/a&gt; 의 값 이 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="db4df7f768ba17c2205fa1703e4da68627adc82b" translate="yes" xml:space="preserve">
          <source>The value of &lt;a href=&quot;qml-qtquick-item#scale-prop&quot;&gt;Item::scale&lt;/a&gt; is updated after the animation has finished.</source>
          <target state="translated">애니메이션이 끝나면 &lt;a href=&quot;qml-qtquick-item#scale-prop&quot;&gt;Item :: scale&lt;/a&gt; 의 값 이 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="59737ef03b98159f03d55a1842176bd8c0c1ebe6" translate="yes" xml:space="preserve">
          <source>The value of &lt;a href=&quot;qml-qtquick-item#x-prop&quot;&gt;Item::x&lt;/a&gt; is updated after the animation has finished.</source>
          <target state="translated">애니메이션이 끝나면 &lt;a href=&quot;qml-qtquick-item#x-prop&quot;&gt;Item :: x&lt;/a&gt; 의 값 이 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="0945a12a52366b50d2376c04a5d754e03be0c984" translate="yes" xml:space="preserve">
          <source>The value of &lt;a href=&quot;qml-qtquick-item#y-prop&quot;&gt;Item::y&lt;/a&gt; is updated after the animation has finished.</source>
          <target state="translated">애니메이션이 끝나면 &lt;a href=&quot;qml-qtquick-item#y-prop&quot;&gt;Item :: y&lt;/a&gt; 의 값 이 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="cbdf070785b998f10473367a81c496c85f131954" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;0.0&lt;/code&gt; indicates automatic scaling according to axis ranges. Defaults to &lt;code&gt;0.0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;0.0&lt;/code&gt; 값은 축 범위에 따른 자동 스케일링을 나타냅니다. 기본값은 &lt;code&gt;0.0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ac46cbbc4d538eaace4779fba11e6e6daec4afbe" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;this&lt;/code&gt; is undefined in QML in the majority of contexts.</source>
          <target state="translated">의 값 &lt;code&gt;this&lt;/code&gt; 상황의 대부분에서 QML에 정의되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4ee920f8790ba2ca4d6a7b520376465780072876" translate="yes" xml:space="preserve">
          <source>The value of a configuration variable can be set using either '=' or '+='. The difference is that '=' overrides the previous value, while '+=' adds a new value to the current one.</source>
          <target state="translated">구성 변수의 값은 '='또는 '+ ='를 사용하여 설정할 수 있습니다. 차이점은 '='가 이전 값보다 우선하고 '+ ='는 현재 값에 새 값을 추가한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="77156a345a2c07cbb96ba21d48452f5101ed180c" translate="yes" xml:space="preserve">
          <source>The value of a keyframe on a timeline.</source>
          <target state="translated">The value of a keyframe on a timeline.</target>
        </trans-unit>
        <trans-unit id="bb1d265a31241e847ba40d9c71bfb10c28b19929" translate="yes" xml:space="preserve">
          <source>The value of a property of an object instance may be specified in two separate ways:</source>
          <target state="translated">객체 인스턴스의 속성 값은 두 가지 방법으로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0395280a6b166e665ff87963df6a40b3d8df84d9" translate="yes" xml:space="preserve">
          <source>The value of altitude in meters above sea level.</source>
          <target state="translated">해발 고도 (미터)입니다.</target>
        </trans-unit>
        <trans-unit id="eac2eeaf90dc64e68173cc547be1dca1b57915fb" translate="yes" xml:space="preserve">
          <source>The value of enabled is persistent. This is the default.</source>
          <target state="translated">The value of enabled is persistent. This is the default.</target>
        </trans-unit>
        <trans-unit id="1e6edd8da5ea6877b06bd238c91a1fd0630412df" translate="yes" xml:space="preserve">
          <source>The value of enabled will last for a single frame and then be reset to false. This might be used for a subtree drawing to an FBO, for example, to only update the FBO when the relevant portions of the scene changed.</source>
          <target state="translated">The value of enabled will last for a single frame and then be reset to false. This might be used for a subtree drawing to an FBO, for example, to only update the FBO when the relevant portions of the scene changed.</target>
        </trans-unit>
        <trans-unit id="d02e5c25f77fc9ea4f913ba3f67b1f1f74c4f837" translate="yes" xml:space="preserve">
          <source>The value of the &lt;code&gt;someNumber&lt;/code&gt; property can be set and read using &lt;a href=&quot;qqmlproperty&quot;&gt;QQmlProperty&lt;/a&gt;, or &lt;a href=&quot;qobject#setProperty&quot;&gt;QObject::setProperty&lt;/a&gt;() and &lt;a href=&quot;qobject#property&quot;&gt;QObject::property&lt;/a&gt;():</source>
          <target state="translated">&lt;code&gt;someNumber&lt;/code&gt; 특성 의 값은 &lt;a href=&quot;qqmlproperty&quot;&gt;QQmlProperty&lt;/a&gt; 또는 &lt;a href=&quot;qobject#setProperty&quot;&gt;QObject :: setProperty&lt;/a&gt; () 및 &lt;a href=&quot;qobject#property&quot;&gt;QObject :: property&lt;/a&gt; ()를 사용하여 설정하고 읽을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fa94417609fbd732285cf20a879d11f2da9c17f3" translate="yes" xml:space="preserve">
          <source>The value of the Accept-Language HTTP request-header field.</source>
          <target state="translated">Accept-Language HTTP 요청 헤더 필드의 값입니다.</target>
        </trans-unit>
        <trans-unit id="ff73bac773d3672871f33d540bd5d36e47319c08" translate="yes" xml:space="preserve">
          <source>The value of the QML property defining the uniform is updated after the animation has finished.</source>
          <target state="translated">유니폼을 정의하는 QML 속성 값은 애니메이션이 완료된 후에 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="25ed8c6af4614a4a8d99a27d46932d661c32dc49" translate="yes" xml:space="preserve">
          <source>The value of the QML property will be updated after the animation has finished. The property is not updated while the animation is running.</source>
          <target state="translated">QML 속성 값은 애니메이션이 완료된 후에 업데이트됩니다. 애니메이션이 실행되는 동안 속성이 업데이트되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b8788afd492d024581b801a2f40050b925c8975a" translate="yes" xml:space="preserve">
          <source>The value of the attribute appears in the Widget box and can be used to strip away namespaces.</source>
          <target state="translated">속성 값이 위젯 상자에 나타나고 네임 스페이스를 제거하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a942e228510a5c4c40d88b8bc460515de22abb8" translate="yes" xml:space="preserve">
          <source>The value of the attribute determines how the property editor will handle them.</source>
          <target state="translated">속성 값은 속성 편집기가 속성을 처리하는 방법을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="2d551f98406523b68e8c3f777f0836e01e9403c4" translate="yes" xml:space="preserve">
          <source>The value of the axis.</source>
          <target state="translated">축의 값입니다.</target>
        </trans-unit>
        <trans-unit id="3ade584d854b8ef5940629dbf3fadaeeb01a45e1" translate="yes" xml:space="preserve">
          <source>The value of the bar</source>
          <target state="translated">막대의 가치</target>
        </trans-unit>
        <trans-unit id="2133bbc002461f65bb05252466f9050ca3e326fc" translate="yes" xml:space="preserve">
          <source>The value of the characteristic is a signed 8 bit integer that has a fixed point exponent of 0.</source>
          <target state="translated">특성의 값은 고정 소수점 지수가 0 인 부호있는 8 비트 정수입니다.</target>
        </trans-unit>
        <trans-unit id="cbad530fcc443aea55a8fa82ee9c78d4943652e4" translate="yes" xml:space="preserve">
          <source>The value of the characteristic is an opaque structure listing various regulatory and/or certification compliance items to which the device claims adherence.</source>
          <target state="translated">특성의 가치는 장치가 준수한다고 주장하는 다양한 규제 및 / 또는 인증 준수 항목을 나열하는 불투명 한 구조입니다.</target>
        </trans-unit>
        <trans-unit id="e6750e60c2f694d8172ed4dfa0d4c606aa7d5acb" translate="yes" xml:space="preserve">
          <source>The value of the dial is set with the &lt;a href=&quot;qml-qtquick-controls2-dial#value-prop&quot;&gt;value&lt;/a&gt; property. The range is set with the &lt;a href=&quot;qml-qtquick-controls2-dial#from-prop&quot;&gt;from&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-controls2-dial#to-prop&quot;&gt;to&lt;/a&gt; properties. To enable or disable wrapping, use the &lt;a href=&quot;qml-qtquick-controls2-dial#wrap-prop&quot;&gt;wrap&lt;/a&gt; property.</source>
          <target state="translated">다이얼 값은 &lt;a href=&quot;qml-qtquick-controls2-dial#value-prop&quot;&gt;value&lt;/a&gt; 속성으로 설정됩니다 . 범위는 &lt;a href=&quot;qml-qtquick-controls2-dial#from-prop&quot;&gt;from&lt;/a&gt; 및 &lt;a href=&quot;qml-qtquick-controls2-dial#to-prop&quot;&gt;to&lt;/a&gt; 속성으로 설정됩니다 . 줄 바꿈을 활성화 또는 비활성화하려면 &lt;a href=&quot;qml-qtquick-controls2-dial#wrap-prop&quot;&gt;wrap&lt;/a&gt; 속성을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="fba715489ab8d7ceedbd8541d54f290d5a18a56b" translate="yes" xml:space="preserve">
          <source>The value of the keyframe.</source>
          <target state="translated">The value of the keyframe.</target>
        </trans-unit>
        <trans-unit id="8dfc05a9e4dfa72686167da637e451e2105592ee" translate="yes" xml:space="preserve">
          <source>The value of the left thumbstick's X axis. The axis values range from -1.0 to 1.0.</source>
          <target state="translated">왼쪽 썸 스틱의 X 축 값입니다. 축 값의 범위는 -1.0에서 1.0입니다.</target>
        </trans-unit>
        <trans-unit id="a6683a9a5a24d8cd9816f5d59b9b671facc95a29" translate="yes" xml:space="preserve">
          <source>The value of the left thumbstick's Y axis. The axis values range from -1.0 to 1.0.</source>
          <target state="translated">왼쪽 썸 스틱의 Y 축 값입니다. 축 값의 범위는 -1.0에서 1.0입니다.</target>
        </trans-unit>
        <trans-unit id="47994566e851c9c6e2962e8828b93b4bc65ecea5" translate="yes" xml:space="preserve">
          <source>The value of the left trigger button. This trigger value ranges from 0.0 when not pressed to 1.0 when pressed completely.</source>
          <target state="translated">왼쪽 트리거 버튼의 값입니다. 이 트리거 값의 범위는 눌리지 않으면 0.0에서 완전히 눌렀을 때 1.0입니다.</target>
        </trans-unit>
        <trans-unit id="697d36ff19fb663f54fcc5d61b7fe5a55c384a66" translate="yes" xml:space="preserve">
          <source>The value of the object.</source>
          <target state="translated">객체의 값입니다.</target>
        </trans-unit>
        <trans-unit id="ca24fe544ffb6a9546873c2ccf49d264aa2ed1c9" translate="yes" xml:space="preserve">
          <source>The value of the property is based on &lt;a href=&quot;qml-qtquick-controls2-spinbox#textFromValue-prop&quot;&gt;textFromValue&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-controls2-control#locale-prop&quot;&gt;locale&lt;/a&gt;, and equal to:</source>
          <target state="translated">속성 값은 &lt;a href=&quot;qml-qtquick-controls2-spinbox#textFromValue-prop&quot;&gt;textFromValue&lt;/a&gt; 및 &lt;a href=&quot;qml-qtquick-controls2-control#locale-prop&quot;&gt;locale을&lt;/a&gt; 기반으로 하며 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="34e6eb39f4fa39f868624ec69bcac7c4d23baff5" translate="yes" xml:space="preserve">
          <source>The value of the property is only used when the thread pool creates new threads. Changing it has no effect for already created or running threads.</source>
          <target state="translated">특성 값은 스레드 풀이 새 스레드를 작성할 때만 사용됩니다. 이를 변경해도 이미 작성되었거나 실행중인 스레드에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="de8b070bc0970bcbfc1b9ec6ba3da78311268bc9" translate="yes" xml:space="preserve">
          <source>The value of the right trigger button. This trigger value ranges from 0.0 when not pressed to 1.0 when pressed completely.</source>
          <target state="translated">오른쪽 트리거 버튼의 값입니다. 이 트리거 값의 범위는 눌리지 않으면 0.0에서 완전히 눌렀을 때 1.0입니다.</target>
        </trans-unit>
        <trans-unit id="eddfadbc983b6c1b4b84c28ac935d4b954da89ba" translate="yes" xml:space="preserve">
          <source>The value of the slice.</source>
          <target state="translated">슬라이스의 값입니다.</target>
        </trans-unit>
        <trans-unit id="e7ccab7ee9b6b4297d66918289041772bddd8880" translate="yes" xml:space="preserve">
          <source>The value of the slider.</source>
          <target state="translated">슬라이더의 값입니다.</target>
        </trans-unit>
        <trans-unit id="8257982b8863f18b15e4930a54da8700ef45058a" translate="yes" xml:space="preserve">
          <source>The value of the uniform must correspond to both a property on the target &lt;a href=&quot;qml-qtquick-shadereffect&quot;&gt;ShaderEffect&lt;/a&gt; and must be a uniform of type &lt;code&gt;float&lt;/code&gt; in the fragment or vertex shader.</source>
          <target state="translated">유니폼의 값은 대상 &lt;a href=&quot;qml-qtquick-shadereffect&quot;&gt;ShaderEffect&lt;/a&gt; 의 속성 모두에 해당 해야하며 조각 또는 정점 셰이더에서 &lt;code&gt;float&lt;/code&gt; 형식의 유니폼이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="35a586a9f96ae34f7d00fd5dbdb62c61d2599516" translate="yes" xml:space="preserve">
          <source>The value of the white list is ignored, that is, no filtering takes place for either scan or connection requests when using undirected advertising.</source>
          <target state="translated">화이트리스트의 값은 무시됩니다. 즉, 무인 광고를 사용할 때 스캔 또는 연결 요청에 대해 필터링이 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9a2ef766aed42056a2e0d687248098addc2e498a" translate="yes" xml:space="preserve">
          <source>The value of these variables is typically handled by qmake or &lt;a href=&quot;#qmakespec&quot;&gt;qmake.conf&lt;/a&gt; and rarely needs to be modified.</source>
          <target state="translated">이러한 변수의 값은 일반적으로 qmake 또는 &lt;a href=&quot;#qmakespec&quot;&gt;qmake.conf에&lt;/a&gt; 의해 처리 되므로 거의 수정하지 않아도 됩니다.</target>
        </trans-unit>
        <trans-unit id="d821aedf55e8af87914fcddb360d7b1c79b14053" translate="yes" xml:space="preserve">
          <source>The value of these variables is typically handled by qmake or &lt;a href=&quot;qmake-variable-reference#qmakespec&quot;&gt;qmake.conf&lt;/a&gt; and rarely needs to be modified.</source>
          <target state="translated">The value of these variables is typically handled by qmake or &lt;a href=&quot;qmake-variable-reference#qmakespec&quot;&gt;qmake.conf&lt;/a&gt; and rarely needs to be modified.</target>
        </trans-unit>
        <trans-unit id="e0f68c7552ef38c578633946edbe57878d653b1e" translate="yes" xml:space="preserve">
          <source>The value of this &lt;a href=&quot;qml-qtquick-controls-spinbox&quot;&gt;SpinBox&lt;/a&gt;, clamped to &lt;a href=&quot;qml-qtquick-controls-spinbox#minimumValue-prop&quot;&gt;minimumValue&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-controls-spinbox#maximumValue-prop&quot;&gt;maximumValue&lt;/a&gt;.</source>
          <target state="translated">이 &lt;a href=&quot;qml-qtquick-controls-spinbox&quot;&gt;SpinBox&lt;/a&gt; 값은 &lt;a href=&quot;qml-qtquick-controls-spinbox#minimumValue-prop&quot;&gt;minimumValue&lt;/a&gt; 및 &lt;a href=&quot;qml-qtquick-controls-spinbox#maximumValue-prop&quot;&gt;maximumValue로&lt;/a&gt; 고정됩니다 .</target>
        </trans-unit>
        <trans-unit id="d3f038562177df93aaf2965427d73d663bf948a5" translate="yes" xml:space="preserve">
          <source>The value of this characteristic is a UTF-8 string representing the firmware revision for the firmware within the device.</source>
          <target state="translated">이 특성의 값은 장치 내 펌웨어의 펌웨어 버전을 나타내는 UTF-8 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="5dc64d2ef3fab75898558684e672e12834a43232" translate="yes" xml:space="preserve">
          <source>The value of this characteristic is a UTF-8 string representing the hardware revision for the hardware within the device.</source>
          <target state="translated">이 특성의 값은 장치 내의 하드웨어에 대한 하드웨어 개정을 나타내는 UTF-8 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="d39447c70eb883277882a18f0a37e96398edbd21" translate="yes" xml:space="preserve">
          <source>The value of this characteristic is a UTF-8 string representing the model number assigned by the device vendor.</source>
          <target state="translated">이 특성의 값은 장치 공급 업체가 할당 한 모델 번호를 나타내는 UTF-8 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="7d014b11681fe2c460f8b8a2a06c6dbcbc660ee9" translate="yes" xml:space="preserve">
          <source>The value of this characteristic is a UTF-8 string representing the name of the manufacturer of the device.</source>
          <target state="translated">이 특성의 값은 장치 제조업체의 이름을 나타내는 UTF-8 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="80d9e5d91c9442b3fefc9388de077207c5423a5e" translate="yes" xml:space="preserve">
          <source>The value of this characteristic is a UTF-8 string representing the software revision for the software within the device.</source>
          <target state="translated">이 특성의 값은 장치 내의 소프트웨어에 대한 소프트웨어 개정을 나타내는 UTF-8 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="946961ef680813028c1ae6ca42bd3976befcc13d" translate="yes" xml:space="preserve">
          <source>The value of this characteristic is a variable-length UTF-8 string representing the serial number for a particular instance of the device.</source>
          <target state="translated">이 특성의 값은 장치의 특정 인스턴스에 대한 일련 번호를 나타내는 가변 길이 UTF-8 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="81b8fdbb197e5845d5ba87e3b2d6b040b1accfc8" translate="yes" xml:space="preserve">
          <source>The value of this characteristic states the temperature in degree Celsius.</source>
          <target state="translated">이 특성의 값은 온도를 섭씨 온도로 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="abc94cf24346ac9c14eab18ed645b00bb46ab5df" translate="yes" xml:space="preserve">
          <source>The value of this property is &lt;code&gt;-1&lt;/code&gt; when &lt;a href=&quot;qml-qtquick-controls2-tumbler#count-prop&quot;&gt;count&lt;/a&gt; is equal to &lt;code&gt;0&lt;/code&gt;. In all other cases, it will be greater than or equal to &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">이 속성의 값은 &lt;code&gt;-1&lt;/code&gt; 때 &lt;a href=&quot;qml-qtquick-controls2-tumbler#count-prop&quot;&gt;카운트&lt;/a&gt; 같다 &lt;code&gt;0&lt;/code&gt; . 다른 모든 경우에는 &lt;code&gt;0&lt;/code&gt; 보다 크거나 같습니다 .</target>
        </trans-unit>
        <trans-unit id="d87c37195519bfed82faac61a500f4e7add6a64f" translate="yes" xml:space="preserve">
          <source>The value of this property is also updated after the dialog is closed.</source>
          <target state="translated">이 속성 값은 대화 상자를 닫은 후에도 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="ac9d073619bad7365dc10940bb5374ec111317e9" translate="yes" xml:space="preserve">
          <source>The value of this property is undefined in documents with tables or frames.</source>
          <target state="translated">이 속성 값은 테이블 또는 프레임이있는 문서에서 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0c0046ae7c1e4cdfb968ac0f20c79b82d797c594" translate="yes" xml:space="preserve">
          <source>The value of this variable is typically handled by qmake or &lt;a href=&quot;#qmakespec&quot;&gt;qmake.conf&lt;/a&gt; and rarely needs to be modified.</source>
          <target state="translated">이 변수의 값은 일반적으로 qmake 또는 &lt;a href=&quot;#qmakespec&quot;&gt;qmake.conf에&lt;/a&gt; 의해 처리 되므로 거의 수정하지 않아도 됩니다.</target>
        </trans-unit>
        <trans-unit id="038daa1eee6c48c06399a2abb182a3d942767551" translate="yes" xml:space="preserve">
          <source>The value of this variable is typically handled by qmake or &lt;a href=&quot;qmake-variable-reference#qmakespec&quot;&gt;qmake.conf&lt;/a&gt; and rarely needs to be modified.</source>
          <target state="translated">The value of this variable is typically handled by qmake or &lt;a href=&quot;qmake-variable-reference#qmakespec&quot;&gt;qmake.conf&lt;/a&gt; and rarely needs to be modified.</target>
        </trans-unit>
        <trans-unit id="85e306d4e8e9bf8f4156e13d25d03e2e13cb807b" translate="yes" xml:space="preserve">
          <source>The value of this variable is, currently, always 1.</source>
          <target state="translated">이 변수의 값은 현재 항상 1입니다.</target>
        </trans-unit>
        <trans-unit id="fd0852be9c9a665f74ebb47fc25de59cf83c16f7" translate="yes" xml:space="preserve">
          <source>The value property is useful for drawing lower and upper limits around the gauge to indicate the recommended value ranges. For example, speeds above 200 kilometers an hour in a car's speedometer could be indicated as dangerous using this property.</source>
          <target state="translated">value 속성은 게이지 주위에 하한 및 상한을 그려 권장 값 범위를 나타내는 데 유용합니다. 예를 들어, 자동차 속도계에서 시속 200km 이상의 속도는이 속성을 사용하여 위험한 것으로 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="67c4eedb6e2b498b2889af4bfaa630f285b8f33b" translate="yes" xml:space="preserve">
          <source>The value range and the label format shown on the axis can be controlled through &lt;a href=&quot;qvalue3daxis&quot;&gt;QValue3DAxis&lt;/a&gt;.</source>
          <target state="translated">축에 표시되는 값 범위 및 레이블 형식은 &lt;a href=&quot;qvalue3daxis&quot;&gt;QValue3DAxis를&lt;/a&gt; 통해 제어 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7d1c8714bf8ef1d813f0f8caab5b334680cdda64" translate="yes" xml:space="preserve">
          <source>The value range of</source>
          <target state="translated">의 값 범위</target>
        </trans-unit>
        <trans-unit id="2a771acd22e70f3ce7a6cbe3eac2fa524a167c02" translate="yes" xml:space="preserve">
          <source>The value ranges from &quot;#00000000&quot; to &quot;#ffffffff&quot;. By default, the property is set to &lt;code&gt;&quot;#00000000&quot;&lt;/code&gt; (no change).</source>
          <target state="translated">값의 범위는 &quot;# 00000000&quot;에서 &quot;#ffffffff&quot;입니다. 기본적 &lt;code&gt;&quot;#00000000&quot;&lt;/code&gt; 속성은 &quot;# 00000000&quot; (변경 사항 없음)으로 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="7406aad557fd777d0504cbbf8505b4085cdec214" translate="yes" xml:space="preserve">
          <source>The value ranges from &quot;#ffffffff&quot; to &quot;#00000000&quot;. By default, the property is set to &lt;code&gt;&quot;#ffffffff&quot;&lt;/code&gt; (no change).</source>
          <target state="translated">값의 범위는 &quot;#ffffffff&quot;에서 &quot;# 00000000&quot;입니다. 기본적 &lt;code&gt;&quot;#ffffffff&quot;&lt;/code&gt; 속성은 &quot;#ffffffff&quot; (변경 사항 없음)로 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c7c500e01ddcbed38ff56158ae561d56c0277d35" translate="yes" xml:space="preserve">
          <source>The value ranges from (no blur) to 16.0 (maximum blur step). By default, the property is set to &lt;code&gt;0.0&lt;/code&gt; (no blur).</source>
          <target state="translated">값의 범위는 (흐리기 없음)에서 16.0 (최대 흐림 단계)입니다. 기본적 &lt;code&gt;0.0&lt;/code&gt; 속성은 0.0 (흐리게 없음)으로 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="055eb2f7c8408c6feacf4178a79fcea0b1c3e419" translate="yes" xml:space="preserve">
          <source>The value ranges from -1.0 (decrease) to 1.0 (increase). By default, the property is set to &lt;code&gt;0.0&lt;/code&gt; (no change).</source>
          <target state="translated">값의 범위는 -1.0 (감소)에서 1.0 (증가)입니다. 기본적 &lt;code&gt;0.0&lt;/code&gt; 속성은 0.0 (변경 없음)으로 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8429732e452eeb54acde180fbc57d3361551d7f" translate="yes" xml:space="preserve">
          <source>The value ranges from -1.0 (decreased) to 1.0 (increased). By default, the property is set to &lt;code&gt;0.0&lt;/code&gt; (no change).</source>
          <target state="translated">값의 범위는 -1.0 (감소)에서 1.0 (증가)입니다. 기본적 &lt;code&gt;0.0&lt;/code&gt; 속성은 0.0 (변경 없음)으로 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="037aa9a845bd7a977d01cef6efbbf5e31d33c1e0" translate="yes" xml:space="preserve">
          <source>The value ranges from -1.0 (inverted maximum shift, according to &lt;a href=&quot;qml-qtgraphicaleffects-displace#displacementSource-prop&quot;&gt;displacementSource&lt;/a&gt;) to 1.0 (maximum shift, according to &lt;a href=&quot;qml-qtgraphicaleffects-displace#displacementSource-prop&quot;&gt;displacementSource&lt;/a&gt;). By default, the property is set to &lt;code&gt;0.0&lt;/code&gt; (no displacement).</source>
          <target state="translated">값의 범위는 -1.0 ( &lt;a href=&quot;qml-qtgraphicaleffects-displace#displacementSource-prop&quot;&gt;변위&lt;/a&gt; 소스에 따른 최대 반전 ) 및 1.0 ( &lt;a href=&quot;qml-qtgraphicaleffects-displace#displacementSource-prop&quot;&gt;변위&lt;/a&gt; 소스에 따른 최대 변동 )입니다. 기본적 &lt;code&gt;0.0&lt;/code&gt; 속성은 0.0 (변위 없음)으로 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="de95fb2090cef441d3d1780aac0d901cf420ccd4" translate="yes" xml:space="preserve">
          <source>The value ranges from -1.0 to 1.0. By default, the property is set to &lt;code&gt;0.0&lt;/code&gt; (no change).</source>
          <target state="translated">값의 범위는 -1.0에서 1.0입니다. 기본적 &lt;code&gt;0.0&lt;/code&gt; 속성은 0.0 (변경 없음)으로 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7824d5c4455216fae613a70ea9330118e686401" translate="yes" xml:space="preserve">
          <source>The value ranges from -180.0 to 180.0. By default the property is set to &lt;code&gt;0.0&lt;/code&gt;.</source>
          <target state="translated">값의 범위는 -180.0에서 180.0입니다. 기본적 &lt;code&gt;0.0&lt;/code&gt; 속성은 0.0 으로 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="63e74025d7bcbeee974942350e067daeeec86a16" translate="yes" xml:space="preserve">
          <source>The value ranges from -inf to inf. By default, &lt;a href=&quot;qml-qtgraphicaleffects-radialgradient#horizontalRadius-prop&quot;&gt;horizontalRadius&lt;/a&gt; is bound to width and verticalRadius is bound to height.</source>
          <target state="translated">값의 범위는 -inf에서 inf입니다. 기본적으로 &lt;a href=&quot;qml-qtgraphicaleffects-radialgradient#horizontalRadius-prop&quot;&gt;horizontalRadius&lt;/a&gt; 는 너비에 바인딩되고 verticalRadius는 높이에 바인딩됩니다.</target>
        </trans-unit>
        <trans-unit id="1486834c84272e6844275d2e8354f6654da06eb2" translate="yes" xml:space="preserve">
          <source>The value ranges from -inf to inf. By default, horizontalRadius is bound to width and &lt;a href=&quot;qml-qtgraphicaleffects-radialgradient#verticalRadius-prop&quot;&gt;verticalRadius&lt;/a&gt; is bound to height.</source>
          <target state="translated">값의 범위는 -inf에서 inf입니다. 기본적으로 horizontalRadius는 너비에 바인딩되고 &lt;a href=&quot;qml-qtgraphicaleffects-radialgradient#verticalRadius-prop&quot;&gt;verticalRadius&lt;/a&gt; 는 높이에 바인딩됩니다.</target>
        </trans-unit>
        <trans-unit id="f92b4708b83a4f2dc967466e0ac899f07ceb64d1" translate="yes" xml:space="preserve">
          <source>The value ranges from -inf to inf. By default, the properties are set to &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">값의 범위는 -inf에서 inf입니다. 기본적으로 특성은 &lt;code&gt;0&lt;/code&gt; 으로 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="7f7bb3be492f12617b011c3d83f3b064d3fa03a7" translate="yes" xml:space="preserve">
          <source>The value ranges from 0 to 32. By default, the property is set to &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">값의 범위는 0-32입니다. 기본적으로이 속성은 &lt;code&gt;0&lt;/code&gt; 으로 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c77ba52394e3bf6278cef1b81f19a7874b91f937" translate="yes" xml:space="preserve">
          <source>The value ranges from 0 to inf. By default, the property is set to &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">값의 범위는 0에서 inf입니다. 기본적으로이 속성은 &lt;code&gt;0&lt;/code&gt; 으로 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="cfb85f137f561f9aaf4577a28b16c8ae2d89c8d1" translate="yes" xml:space="preserve">
          <source>The value ranges from 0.0 (alpha value 0) to 1.0 (alpha value 255). By default, the property is set to &lt;code&gt;0.0&lt;/code&gt;.</source>
          <target state="translated">값의 범위는 0.0 (알파 값 0)에서 1.0 (알파 값 255)입니다. 기본적 &lt;code&gt;0.0&lt;/code&gt; 속성은 0.0 으로 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="99dfa64e1ab551d7058e447821069c59ec1aa776" translate="yes" xml:space="preserve">
          <source>The value ranges from 0.0 (darkest) to inf (lightest). By default, the property is set to &lt;code&gt;1.0&lt;/code&gt; (no change).</source>
          <target state="translated">값의 범위는 0.0 (가장 어둡게)에서 inf (가장 밝음)입니다. 기본적으로이 속성은 &lt;code&gt;1.0&lt;/code&gt; (변경 없음)으로 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="57833c0a81385fb02f11c265b6be290f1a4d0012" translate="yes" xml:space="preserve">
          <source>The value ranges from 0.0 (desaturated) to 1.0 (saturated). By default, the property is set to &lt;code&gt;1.0&lt;/code&gt; (saturated).</source>
          <target state="translated">값의 범위는 0.0 (포화)에서 1.0 (포화)입니다. 기본적으로이 속성은 &lt;code&gt;1.0&lt;/code&gt; (포화)으로 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c8f5b273fdca7b81a5bbfe56e7fcd2121849247f" translate="yes" xml:space="preserve">
          <source>The value ranges from 0.0 (no blur) to inf. By default, the property is set to &lt;code&gt;0.0&lt;/code&gt; (no blur).</source>
          <target state="translated">값의 범위는 0.0 (흐리지 않음)에서 inf입니다. 기본적 &lt;code&gt;0.0&lt;/code&gt; 속성은 0.0 (흐리게 없음)으로 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="5af13615f2fa7dedc8564ff609bdcaacb58d7dcc" translate="yes" xml:space="preserve">
          <source>The value ranges from 0.0 (no blur) to inf. By default, the property is set to &lt;code&gt;floor(samples / 2.0)&lt;/code&gt;.</source>
          <target state="translated">값의 범위는 0.0 (흐리지 않음)에서 inf입니다. 기본적으로이 속성은 &lt;code&gt;floor(samples / 2.0)&lt;/code&gt; 설정되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="75a1201608d7664cfc17cc384698306028831459" translate="yes" xml:space="preserve">
          <source>The value ranges from 0.0 (no blur) to inf. Visual quality of the blur is reduced when radius exceeds value 64. By default, the property is set to &lt;code&gt;0.0&lt;/code&gt; (no blur).</source>
          <target state="translated">값의 범위는 0.0 (흐리지 않음)에서 inf입니다. 반경이 64를 초과하면 흐림의 시각적 품질이 저하됩니다. 기본적으로 속성은 &lt;code&gt;0.0&lt;/code&gt; (흐리게 없음)으로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="e17e72ea3984a730a869fe3e351e6532fda8f46b" translate="yes" xml:space="preserve">
          <source>The value ranges from 0.0 (no change) to 1.0 (desaturated). By default, the property is set to &lt;code&gt;0.0&lt;/code&gt; (no change).</source>
          <target state="translated">값의 범위는 0.0 (변경 없음)에서 1.0 (포화)입니다. 기본적 &lt;code&gt;0.0&lt;/code&gt; 속성은 0.0 (변경 없음)으로 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad7c55e78a3862d6ac865dd4b4fd666a4c8ceb63" translate="yes" xml:space="preserve">
          <source>The value ranges from 0.0 (no deviation) to inf (maximum deviation). By default, devaition is binded to radius. When radius increases, deviation is automatically increased linearly. With the radius value of 8, the deviation default value becomes approximately 2.7034. This value produces a compromise between the blur quality and overall blurriness.</source>
          <target state="translated">값의 범위는 0.0 (편차 없음)에서 inf (최대 편차)입니다. 기본적으로, 편차는 반경에 바인딩됩니다. 반경이 증가하면 편차가 자동으로 선형으로 증가합니다. 반지름 값이 8이면 편차 기본값이 약 2.7034가됩니다. 이 값은 흐림 품질과 전체 흐림 사이에서 절충을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="1aa82d101aa739338cb3da8a97f6dd07c392ebf0" translate="yes" xml:space="preserve">
          <source>The value ranges from 0.0 (no glow) to inf (infinite glow). By default, the property is set to &lt;code&gt;0.0&lt;/code&gt;.</source>
          <target state="translated">값의 범위는 0.0 (글로우 없음)에서 inf (무한 글로우)입니다. 기본적 &lt;code&gt;0.0&lt;/code&gt; 속성은 0.0 으로 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="d33777850e5fd37225735614a026f022e6d53c88" translate="yes" xml:space="preserve">
          <source>The value ranges from 0.0 (no strength increase) to 1.0 (maximum strength increase). By default, the property is set to &lt;code&gt;0.0&lt;/code&gt;.</source>
          <target state="translated">값의 범위는 0.0 (강도 증가 없음)에서 1.0 (최대 강도 증가)입니다. 기본적 &lt;code&gt;0.0&lt;/code&gt; 속성은 0.0 으로 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="fd2a0ffe94c87dd1dcba30f7aaabb1f750d0e92a" translate="yes" xml:space="preserve">
          <source>The value ranges from 0.0 (sharp mask edge) to 1.0 (smooth mask edge). By default, the property is set to &lt;code&gt;0.0&lt;/code&gt;.</source>
          <target state="translated">값의 범위는 0.0 (선명한 마스크 가장자리)에서 1.0 (매끄러운 마스크 가장자리)입니다. 기본적 &lt;code&gt;0.0&lt;/code&gt; 속성은 0.0 으로 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c456a950d6ebfc7c57b51585e20f4aab7f8d4cd9" translate="yes" xml:space="preserve">
          <source>The value ranges from 0.0 to 1.0. By default, the property is set to &lt;code&gt;0.0&lt;/code&gt;, which produces a slightly red color.</source>
          <target state="translated">값의 범위는 0.0에서 1.0입니다. 기본적 &lt;code&gt;0.0&lt;/code&gt; 속성은 0.0 으로 설정되어 약간 붉은 색을냅니다.</target>
        </trans-unit>
        <trans-unit id="af129c39c5b49d71edfb0c46c3e1f62296c24c55" translate="yes" xml:space="preserve">
          <source>The value ranges from 0.0 to 1.0. By default, the property is set to &lt;code&gt;0.0&lt;/code&gt;.</source>
          <target state="translated">값의 범위는 0.0에서 1.0입니다. 기본적 &lt;code&gt;0.0&lt;/code&gt; 속성은 0.0 으로 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="be0de6c3918a0162c03354be445fb79b2dac201b" translate="yes" xml:space="preserve">
          <source>The value ranges from 0.0 to 1.0. By default, the property is set to &lt;code&gt;0.5&lt;/code&gt;.</source>
          <target state="translated">값의 범위는 0.0에서 1.0입니다. 기본적 &lt;code&gt;0.5&lt;/code&gt; 속성은 0.5 로 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4aa8168d6598b31fa8596adaa0766d64a12aa32" translate="yes" xml:space="preserve">
          <source>The value ranges from 0.0 to half of the effective width or height of the glow, whichever is smaller. This can be calculated with: &lt;code&gt;min(width, height) / 2.0 + glowRadius&lt;/code&gt;</source>
          <target state="translated">값의 범위는 글로우의 유효 너비 또는 높이의 0.0에서 절반 중 작은쪽에 해당합니다. &lt;code&gt;min(width, height) / 2.0 + glowRadius&lt;/code&gt; 하여 계산할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="59823d800f97f95c0db721a02168be3abc611f25" translate="yes" xml:space="preserve">
          <source>The value ranges from 0.0 to inf. By default the property is set to &lt;code&gt;0.0&lt;/code&gt; (no blur).</source>
          <target state="translated">값의 범위는 0.0에서 inf입니다. 기본적 &lt;code&gt;0.0&lt;/code&gt; 속성은 0.0 (흐리게 없음)으로 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="00e180c85e91e982a3e15dc5f6b2352ed976154a" translate="yes" xml:space="preserve">
          <source>The value ranges from QtVector3d(0.0, 0.0, 0.0) (darkest) to inf (lightest). By default, the property is set to &lt;code&gt;QtVector3d(1.0, 1.0, 1.0)&lt;/code&gt; (no change).</source>
          <target state="translated">값의 범위는 QtVector3d (0.0, 0.0, 0.0) (가장 어둡게)에서 inf (가장 밝음)까지입니다. 기본적 &lt;code&gt;QtVector3d(1.0, 1.0, 1.0)&lt;/code&gt; 속성은 QtVector3d (1.0, 1.0, 1.0) 로 설정되어 있습니다 ( 변경 없음).</target>
        </trans-unit>
        <trans-unit id="46d6b36970edf6fdc251a606901f9779fe03b07a" translate="yes" xml:space="preserve">
          <source>The value represents the ambient light and comes from &lt;a href=&quot;qambientlightreading#LightLevel-enum&quot;&gt;QAmbientLightReading::LightLevel&lt;/a&gt;.</source>
          <target state="translated">값은 주변 광을 &lt;a href=&quot;qambientlightreading#LightLevel-enum&quot;&gt;나타내며 QAmbientLightReading :: LightLevel&lt;/a&gt; 에서 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="e4381bd0a83ab9b1835fa1a5310011d1458426c4" translate="yes" xml:space="preserve">
          <source>The value returned by a modal dialog.</source>
          <target state="translated">모달 대화 상자에서 반환 한 값입니다.</target>
        </trans-unit>
        <trans-unit id="545cf2c92ed95c8b4bc16c9531e2dd4f154898fa" translate="yes" xml:space="preserve">
          <source>The value returned by the virtual &lt;a href=&quot;qgraphicsellipseitem#type&quot;&gt;type&lt;/a&gt;() function.</source>
          <target state="translated">가상 &lt;a href=&quot;qgraphicsellipseitem#type&quot;&gt;유형&lt;/a&gt; () 함수가 리턴 한 값 입니다.</target>
        </trans-unit>
        <trans-unit id="4d8a6f71e012703b10315e5479df250220bce4f5" translate="yes" xml:space="preserve">
          <source>The value returned by the virtual &lt;a href=&quot;qgraphicsitem#type&quot;&gt;type&lt;/a&gt;() function in standard graphics item classes in Qt. All such standard graphics item classes in Qt are associated with a unique value for Type, e.g. the value returned by &lt;a href=&quot;qgraphicspathitem#type&quot;&gt;QGraphicsPathItem::type&lt;/a&gt;() is 2.</source>
          <target state="translated">Qt의 표준 그래픽 항목 클래스에서 가상 &lt;a href=&quot;qgraphicsitem#type&quot;&gt;유형&lt;/a&gt; () 함수가 리턴 한 값 입니다. Qt의 모든 표준 그래픽 항목 클래스는 Type의 고유 한 값과 연관되어 있습니다. 예를 들어 &lt;a href=&quot;qgraphicspathitem#type&quot;&gt;QGraphicsPathItem :: type&lt;/a&gt; ()에 의해 반환되는 값 은 2입니다.</target>
        </trans-unit>
        <trans-unit id="75b3cdaea65814277564d6207a589791a6e1dffa" translate="yes" xml:space="preserve">
          <source>The value returned by the virtual &lt;a href=&quot;qgraphicsitemgroup#type&quot;&gt;type&lt;/a&gt;() function.</source>
          <target state="translated">가상 &lt;a href=&quot;qgraphicsitemgroup#type&quot;&gt;유형&lt;/a&gt; () 함수가 리턴 한 값 입니다.</target>
        </trans-unit>
        <trans-unit id="6af0610c5238a39a8ddab651d963339bf97e3011" translate="yes" xml:space="preserve">
          <source>The value returned by the virtual &lt;a href=&quot;qgraphicslineitem#type&quot;&gt;type&lt;/a&gt;() function.</source>
          <target state="translated">가상 &lt;a href=&quot;qgraphicslineitem#type&quot;&gt;유형&lt;/a&gt; () 함수가 리턴 한 값 입니다.</target>
        </trans-unit>
        <trans-unit id="a59a21f25a4b47758e429dbe13c1ffce7ca8a418" translate="yes" xml:space="preserve">
          <source>The value returned by the virtual &lt;a href=&quot;qgraphicspathitem#type&quot;&gt;type&lt;/a&gt;() function.</source>
          <target state="translated">가상 &lt;a href=&quot;qgraphicspathitem#type&quot;&gt;유형&lt;/a&gt; () 함수가 리턴 한 값 입니다.</target>
        </trans-unit>
        <trans-unit id="77414a29bcde85e75ce52ed570b43a8aafb9b9a9" translate="yes" xml:space="preserve">
          <source>The value returned by the virtual &lt;a href=&quot;qgraphicspixmapitem#type&quot;&gt;type&lt;/a&gt;() function.</source>
          <target state="translated">가상 &lt;a href=&quot;qgraphicspixmapitem#type&quot;&gt;유형&lt;/a&gt; () 함수가 리턴 한 값 입니다.</target>
        </trans-unit>
        <trans-unit id="ea9fe89c878c4b50eeddfce0d162e160c3e57155" translate="yes" xml:space="preserve">
          <source>The value returned by the virtual &lt;a href=&quot;qgraphicspolygonitem#type&quot;&gt;type&lt;/a&gt;() function.</source>
          <target state="translated">가상 &lt;a href=&quot;qgraphicspolygonitem#type&quot;&gt;유형&lt;/a&gt; () 함수가 리턴 한 값 입니다.</target>
        </trans-unit>
        <trans-unit id="9c9babd7ec78e3684f906dc72a5769bd8dcc33a9" translate="yes" xml:space="preserve">
          <source>The value returned by the virtual &lt;a href=&quot;qgraphicsproxywidget#type&quot;&gt;type&lt;/a&gt;() function.</source>
          <target state="translated">가상 &lt;a href=&quot;qgraphicsproxywidget#type&quot;&gt;유형&lt;/a&gt; () 함수가 리턴 한 값 입니다.</target>
        </trans-unit>
        <trans-unit id="3fe558564420d9368698e94cd112ddb4310dec78" translate="yes" xml:space="preserve">
          <source>The value returned by the virtual &lt;a href=&quot;qgraphicsrectitem#type&quot;&gt;type&lt;/a&gt;() function.</source>
          <target state="translated">가상 &lt;a href=&quot;qgraphicsrectitem#type&quot;&gt;유형&lt;/a&gt; () 함수가 리턴 한 값 입니다.</target>
        </trans-unit>
        <trans-unit id="d3fac44df8b0194992eaeca1dd84eaa5e465add2" translate="yes" xml:space="preserve">
          <source>The value returned by the virtual &lt;a href=&quot;qgraphicssimpletextitem#type&quot;&gt;type&lt;/a&gt;() function.</source>
          <target state="translated">가상 &lt;a href=&quot;qgraphicssimpletextitem#type&quot;&gt;유형&lt;/a&gt; () 함수가 리턴 한 값 입니다.</target>
        </trans-unit>
        <trans-unit id="802a2d59429dc76c5099df014fb18f48dfbe79fc" translate="yes" xml:space="preserve">
          <source>The value returned by the virtual &lt;a href=&quot;qgraphicstextitem#type&quot;&gt;type&lt;/a&gt;() function.</source>
          <target state="translated">가상 &lt;a href=&quot;qgraphicstextitem#type&quot;&gt;유형&lt;/a&gt; () 함수가 리턴 한 값 입니다.</target>
        </trans-unit>
        <trans-unit id="86de4057c0ec4fb1bd24a6b6312bfb5ed18e441f" translate="yes" xml:space="preserve">
          <source>The value returned by the virtual &lt;a href=&quot;qgraphicswidget#type&quot;&gt;type&lt;/a&gt;() function.</source>
          <target state="translated">가상 &lt;a href=&quot;qgraphicswidget#type&quot;&gt;유형&lt;/a&gt; () 함수가 리턴 한 값 입니다.</target>
        </trans-unit>
        <trans-unit id="9c5e38c1432249fc8f4f5d57e3e10c5ab0aae877" translate="yes" xml:space="preserve">
          <source>The value should be in the range of 0.0 to 1.0, where 0.0 is fully transparent and 1.0 is fully opaque.</source>
          <target state="translated">값은 0.0에서 1.0 사이 여야합니다. 여기서 0.0은 완전히 투명하고 1.0은 완전히 불투명합니다.</target>
        </trans-unit>
        <trans-unit id="331168ca62cb250f6a8c6d1fb9d8435b8b9aeb5f" translate="yes" xml:space="preserve">
          <source>The value specified can be used to influence the visual appearance of an item along the path. For example, the following Path specifies an attribute named</source>
          <target state="translated">지정된 값은 경로를 따라 항목의 시각적 모양에 영향을 줄 수 있습니다. 예를 들어 다음 경로는 이름이 지정된 속성을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="0c4a71d5303a8d31e41a06727c735c5e8662250e" translate="yes" xml:space="preserve">
          <source>The value specified using the &lt;code&gt;title&lt;/code&gt; tag is available through &lt;a href=&quot;qtextdocument#metaInformation&quot;&gt;QTextDocument::metaInformation&lt;/a&gt;().</source>
          <target state="translated">&lt;code&gt;title&lt;/code&gt; 태그를 사용하여 지정된 값 은 &lt;a href=&quot;qtextdocument#metaInformation&quot;&gt;QTextDocument :: metaInformation&lt;/a&gt; ()을 통해 사용 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="e7a38679189b43a707f7bf8a603ea537cd85f223" translate="yes" xml:space="preserve">
          <source>The value starts growing slowly, then increases in speed.</source>
          <target state="translated">값이 천천히 증가하기 시작한 다음 속도가 증가합니다.</target>
        </trans-unit>
        <trans-unit id="a9e02838e4c440b7281cbc2d027d2e069a93330f" translate="yes" xml:space="preserve">
          <source>The value starts growing slowly, then runs steadily, then grows slowly again.</source>
          <target state="translated">값이 천천히 증가하기 시작한 다음 꾸준히 실행 된 다음 다시 느리게 증가합니다.</target>
        </trans-unit>
        <trans-unit id="f5a00897cd6ee59b8c876f884392928e814abd6c" translate="yes" xml:space="preserve">
          <source>The value starts growing steadily, then ends slowly.</source>
          <target state="translated">값은 꾸준히 증가하기 시작한 다음 천천히 끝납니다.</target>
        </trans-unit>
        <trans-unit id="8bb4bf1d106d4a8613767e4bde217383f1c8f3e5" translate="yes" xml:space="preserve">
          <source>The value that is returned is also dependent on the given &lt;a href=&quot;qtextformat#Property-enum&quot;&gt;LineHeightType&lt;/a&gt; of the paragraph as well as the &lt;a href=&quot;qtextformat#Property-enum&quot;&gt;LineHeight&lt;/a&gt; setting that has been set for the paragraph.</source>
          <target state="translated">반환되는 값 은 단락 의 지정된 &lt;a href=&quot;qtextformat#Property-enum&quot;&gt;LineHeightType&lt;/a&gt; 과 단락 에 설정된 &lt;a href=&quot;qtextformat#Property-enum&quot;&gt;LineHeight&lt;/a&gt; 설정 에 따라 달라집니다 .</target>
        </trans-unit>
        <trans-unit id="d386e8ee8f4ea760d6b62cc37e2ee0ebcffde16b" translate="yes" xml:space="preserve">
          <source>The value that is stored in this container: a pair of QCborValues</source>
          <target state="translated">이 컨테이너에 저장된 값 : QCborValues ​​쌍</target>
        </trans-unit>
        <trans-unit id="84e36bc01e295977a59f4be50c4cf3de039e43d2" translate="yes" xml:space="preserve">
          <source>The value that this label represents.</source>
          <target state="translated">이 레이블이 나타내는 값입니다.</target>
        </trans-unit>
        <trans-unit id="39fdde888febb73aa8c312c6db40af7bf2aa34df" translate="yes" xml:space="preserve">
          <source>The value that this minor tickmark represents as a position in pixels, with 0 being at the bottom of the gauge.</source>
          <target state="translated">이 작은 눈금은 픽셀 단위의 위치로 나타내며 0은 게이지의 맨 아래에 있습니다.</target>
        </trans-unit>
        <trans-unit id="02a865c14a29a41fadf943c1f47cbcd0999b14dc" translate="yes" xml:space="preserve">
          <source>The value that this minor tickmark represents.</source>
          <target state="translated">이 작은 눈금이 나타내는 값입니다.</target>
        </trans-unit>
        <trans-unit id="836e646a2e67c2c72bec57f72817e6843b7b3705" translate="yes" xml:space="preserve">
          <source>The value that this tickmark represents as a position in pixels, with 0 being at the bottom of the gauge.</source>
          <target state="translated">이 눈금이 픽셀 단위의 위치로 나타내는 값으로, 게이지 하단에 0이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e4d6d3173e0c08dcd354dad2f1ae793965575df1" translate="yes" xml:space="preserve">
          <source>The value that this tickmark represents.</source>
          <target state="translated">이 눈금이 나타내는 값입니다.</target>
        </trans-unit>
        <trans-unit id="fa568bd2b9d23b18077c203674a22a995ee2d977" translate="yes" xml:space="preserve">
          <source>The value to be set on the target object and property. This can be a constant (which isn't very useful), or a bound expression.</source>
          <target state="translated">대상 객체 및 속성에 설정할 값입니다. 상수 (매우 유용하지는 않음)이거나 바운드 식일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0c2c27a159333f37fb523055c6178bcfab373af4" translate="yes" xml:space="preserve">
          <source>The value type of &lt;code&gt;InputIterator&lt;/code&gt; must be convertible to &lt;code&gt;QString&lt;/code&gt;.</source>
          <target state="translated">The value type of &lt;code&gt;InputIterator&lt;/code&gt; must be convertible to &lt;code&gt;QString&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="59a2e3c521147ad486e557b7e4477f2e671bd4a3" translate="yes" xml:space="preserve">
          <source>The value type of &lt;code&gt;InputIterator&lt;/code&gt; must be convertible to &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">The value type of &lt;code&gt;InputIterator&lt;/code&gt; must be convertible to &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="be2211cd39f924e6bb3728042b13e9ba80798ff4" translate="yes" xml:space="preserve">
          <source>The value will be bounded to the range 0 to 1.</source>
          <target state="translated">값은 0에서 1 사이의 범위로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="3a75732ed5fe704380a93f729c61140a54afaff1" translate="yes" xml:space="preserve">
          <source>The value will be true if the playback volume is muted; otherwise false.</source>
          <target state="translated">재생 볼륨이 음소거되면 값이 true가됩니다. 그렇지 않으면 거짓.</target>
        </trans-unit>
        <trans-unit id="8907280e70178ed40fd7f687648e1ed75119bf06" translate="yes" xml:space="preserve">
          <source>The values above may seem a bit strange, but here are the guiding principles:</source>
          <target state="translated">위의 값은 약간 이상하게 보일 수 있지만 다음은 기본 원칙입니다.</target>
        </trans-unit>
        <trans-unit id="0283c470e21d20ece3fa9628c95c03993ff3b2cd" translate="yes" xml:space="preserve">
          <source>The values above may seem a bit strange, but there is a guiding principle. It advances by doubling the size each time. More precisely, it advances to the next power of two, minus 16 bytes. 16 bytes corresponds to eight characters, as &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; uses UTF-16 internally.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="478c2a8a6ebb2e90d04c46fec272a309cc3c3fda" translate="yes" xml:space="preserve">
          <source>The values are fractions of the volume thickness in the same dimension. The values cannot be negative.</source>
          <target state="translated">값은 동일한 치수에서 부피 두께의 분수입니다. 값은 음수 일 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c5154c9626640fadf72f74a82b038294f0f6e807" translate="yes" xml:space="preserve">
          <source>The values are:</source>
          <target state="translated">값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="be0570d7379bdf3219932f1c281111e3a3bf8aab" translate="yes" xml:space="preserve">
          <source>The values correspond to OpenGL enum values like &lt;code&gt;GL_POINTS&lt;/code&gt;, &lt;code&gt;GL_LINES&lt;/code&gt;, etc. &lt;a href=&quot;qsggeometry&quot;&gt;QSGGeometry&lt;/a&gt; provies its own type in order to be able to provide the same API with non-OpenGL backends as well.</source>
          <target state="translated">값은 &lt;code&gt;GL_POINTS&lt;/code&gt; , &lt;code&gt;GL_LINES&lt;/code&gt; 등과 같은 OpenGL 열거 형 값에 해당합니다 . &lt;a href=&quot;qsggeometry&quot;&gt;QSGGeometry&lt;/a&gt; 는 동일한 API에 OpenGL이 아닌 백엔드를 제공 할 수 있도록 자체 유형을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f46ada401d6ff80b44dd18818bfcc47221a99418" translate="yes" xml:space="preserve">
          <source>The values correspond to OpenGL type constants like &lt;code&gt;GL_BYTE&lt;/code&gt;, &lt;code&gt;GL_UNSIGNED_BYTE&lt;/code&gt;, etc. &lt;a href=&quot;qsggeometry&quot;&gt;QSGGeometry&lt;/a&gt; provies its own type in order to be able to provide the same API with non-OpenGL backends as well.</source>
          <target state="translated">값은 &lt;code&gt;GL_BYTE&lt;/code&gt; , &lt;code&gt;GL_UNSIGNED_BYTE&lt;/code&gt; 등과 같은 OpenGL 유형 상수에 해당합니다 . &lt;a href=&quot;qsggeometry&quot;&gt;QSGGeometry&lt;/a&gt; 는 OpenGL이 아닌 백엔드와 동일한 API를 제공 할 수 있도록 자체 유형을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f8a4cb6eb64c27064f7dd46793515b1113681a24" translate="yes" xml:space="preserve">
          <source>The values for this enum are defined to be the same as those defined in the &lt;a href=&quot;http://accessibility.linuxfoundation.org/a11yspecs/ia2/docs/html/_accessible_event_i_d_8idl.html&quot;&gt;IAccessible2&lt;/a&gt; and &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/dd318066.aspx&quot;&gt;MSAA&lt;/a&gt; specifications.</source>
          <target state="translated">이 열거 형의 값은 &lt;a href=&quot;http://accessibility.linuxfoundation.org/a11yspecs/ia2/docs/html/_accessible_event_i_d_8idl.html&quot;&gt;IAccessible2&lt;/a&gt; 및 &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/dd318066.aspx&quot;&gt;MSAA&lt;/a&gt; 사양에 정의 된 값과 동일하게 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="93ab02e543838ef004c5c531bec3a9b7ec7db7f7" translate="yes" xml:space="preserve">
          <source>The values from all items matching each row/column combination are added together and the total is used as the bar value.</source>
          <target state="translated">각 행 / 열 조합과 일치하는 모든 항목의 값이 합산되어 총계가 막대 값으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0fde2bfc48d8d94219d8eda4419467ffb7fade45" translate="yes" xml:space="preserve">
          <source>The values from all items matching each row/column combination are averaged together and the average is used as the bar value.</source>
          <target state="translated">각 행 / 열 조합과 일치하는 모든 항목의 값은 함께 평균화되며 평균은 막대 값으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9cd2090f673cc98252e002b45b255524467d1cc8" translate="yes" xml:space="preserve">
          <source>The values in</source>
          <target state="translated">의 값</target>
        </trans-unit>
        <trans-unit id="87156724368a0fa0ca24de7190319e6ec2d85e29" translate="yes" xml:space="preserve">
          <source>The values of EncodeReserved and DecodeReserved should not be used together in one call. The behavior is undefined if that happens. They are provided as separate values because the behavior of the &quot;pretty mode&quot; with regards to reserved characters is different on certain components and specially on the full URL.</source>
          <target state="translated">EncodeReserved 및 DecodeReserved의 값을 한 번의 호출로 함께 사용하면 안됩니다. 이 경우 동작이 정의되지 않습니다. 예약 된 문자와 관련하여 &quot;pretty 모드&quot;의 동작이 특정 구성 요소와 전체 URL에서 다르기 때문에 별도의 값으로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="18129c38895faf2b4913029560eaefb3bbfc7e26" translate="yes" xml:space="preserve">
          <source>The values of a record's fields can be set by name or position with &lt;a href=&quot;qsqlrecord#setValue&quot;&gt;setValue&lt;/a&gt;(); if you want to set a field to null use &lt;a href=&quot;qsqlrecord#setNull&quot;&gt;setNull&lt;/a&gt;(). To find the position of a field by name use &lt;a href=&quot;qsqlrecord#indexOf&quot;&gt;indexOf&lt;/a&gt;(), and to find the name of a field at a particular position use &lt;a href=&quot;qsqlrecord#fieldName&quot;&gt;fieldName&lt;/a&gt;(). Use &lt;a href=&quot;qsqlrecord#field&quot;&gt;field&lt;/a&gt;() to retrieve a &lt;a href=&quot;qsqlfield&quot;&gt;QSqlField&lt;/a&gt; object for a given field. Use &lt;a href=&quot;qsqlrecord#contains&quot;&gt;contains&lt;/a&gt;() to see if the record contains a particular field name.</source>
          <target state="translated">레코드 필드의 값은 &lt;a href=&quot;qsqlrecord#setValue&quot;&gt;setValue&lt;/a&gt; ()를 사용하여 이름 또는 위치별로 설정할 수 있습니다 . 필드를 null로 설정하려면 &lt;a href=&quot;qsqlrecord#setNull&quot;&gt;setNull&lt;/a&gt; ()을 사용하십시오. 이름으로 필드의 위치를 ​​찾으려면 &lt;a href=&quot;qsqlrecord#indexOf&quot;&gt;indexOf&lt;/a&gt; ()를 사용하고 특정 위치에서 필드의 이름을 찾으려면 &lt;a href=&quot;qsqlrecord#fieldName&quot;&gt;fieldName&lt;/a&gt; ()을 사용하십시오. 주어진 필드에 대한 &lt;a href=&quot;qsqlfield&quot;&gt;QSqlField&lt;/a&gt; 오브젝트 를 검색 하려면 &lt;a href=&quot;qsqlrecord#field&quot;&gt;field&lt;/a&gt; ()를 사용하십시오 . &lt;a href=&quot;qsqlrecord#contains&quot;&gt;contains&lt;/a&gt; ()를 사용 하여 레코드에 특정 필드 이름이 포함되어 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="835e243af793fbb5fe085c908921035b79cf5f22" translate="yes" xml:space="preserve">
          <source>The values of characteristics and descriptors can be retrieved via &lt;a href=&quot;qlowenergycharacteristic&quot;&gt;QLowEnergyCharacteristic&lt;/a&gt; and &lt;a href=&quot;qlowenergydescriptor&quot;&gt;QLowEnergyDescriptor&lt;/a&gt;, respectively. However, direct reading or writing of these attributes requires the service object. The &lt;a href=&quot;qlowenergyservice#readCharacteristic&quot;&gt;readCharacteristic&lt;/a&gt;() function attempts to re-read the value of a characteristic. Although the initial service discovery may have obtained a value already this call may be required in cases where the characteristic value constantly changes without any notifications being provided. An example might be a time characteristic that provides a continuous value. If the read attempt is successful, the &lt;a href=&quot;qlowenergyservice#characteristicRead&quot;&gt;characteristicRead&lt;/a&gt;() signal is emitted. A failure to read the value triggers the &lt;a href=&quot;qlowenergyservice#ServiceError-enum&quot;&gt;CharacteristicReadError&lt;/a&gt;. The &lt;a href=&quot;qlowenergyservice#writeCharacteristic&quot;&gt;writeCharacteristic&lt;/a&gt;() function attempts to write a new value to the given characteristic. If the write attempt is successful, the &lt;a href=&quot;qlowenergyservice#characteristicWritten&quot;&gt;characteristicWritten&lt;/a&gt;() signal is emitted. A failure to write triggers the &lt;a href=&quot;qlowenergyservice#ServiceError-enum&quot;&gt;CharacteristicWriteError&lt;/a&gt;. Reading and writing of descriptors follows the same pattern.</source>
          <target state="translated">특성 및 설명 자의 값은 각각 &lt;a href=&quot;qlowenergycharacteristic&quot;&gt;QLowEnergyCharacteristic&lt;/a&gt; 및 &lt;a href=&quot;qlowenergydescriptor&quot;&gt;QLowEnergyDescriptor&lt;/a&gt; 를 통해 검색 할 수 있습니다 . 그러나 이러한 속성을 직접 읽거나 쓰려면 서비스 개체가 필요합니다. &lt;a href=&quot;qlowenergyservice#readCharacteristic&quot;&gt;readCharacteristic&lt;/a&gt; () 함수 시도 특성 값을 다시 읽어. 초기 서비스 발견이 이미 값을 얻었을 수도 있지만, 통지가 제공되지 않고 특성 값이 지속적으로 변경되는 경우이 호출이 필요할 수 있습니다. 지속적인 가치를 제공하는 시간 특성을 예로들 수 있습니다. 읽기 시도가 성공하면, &lt;a href=&quot;qlowenergyservice#characteristicRead&quot;&gt;특징적인&lt;/a&gt; read () 신호가 방출됩니다. 값을 읽지 못하면 &lt;a href=&quot;qlowenergyservice#ServiceError-enum&quot;&gt;특성&lt;/a&gt; 판독 오류가 트리거됩니다.. &lt;a href=&quot;qlowenergyservice#writeCharacteristic&quot;&gt;writeCharacteristic&lt;/a&gt; () 함수 시도는 주어진 특성에 새로운 값을 기입한다. 쓰기 시도가 성공하면, &lt;a href=&quot;qlowenergyservice#characteristicWritten&quot;&gt;특징적인&lt;/a&gt; 서면 () 신호가 방출됩니다. 쓰기에 실패하면 &lt;a href=&quot;qlowenergyservice#ServiceError-enum&quot;&gt;특색&lt;/a&gt; WriteError가 트리거됩니다 . 디스크립터 읽기 및 쓰기는 동일한 패턴을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="dcfed8ef9500ec211a07e8bc485a2c0879f1141b" translate="yes" xml:space="preserve">
          <source>The values of the bar set. You can set a list of either &lt;a href=&quot;qml-real&quot;&gt;real&lt;/a&gt; or &lt;a href=&quot;qml-point&quot;&gt;point&lt;/a&gt; types as values.</source>
          <target state="translated">막대 세트의 값입니다. &lt;a href=&quot;qml-real&quot;&gt;실수&lt;/a&gt; 또는 &lt;a href=&quot;qml-point&quot;&gt;점&lt;/a&gt; 유형 목록을 값으로 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f8bd08b1e2993260bea03445218bbe1174b78590" translate="yes" xml:space="preserve">
          <source>The values of the box-and-whiskers item. The following enumerations can be used as indexes when accessing the list of values:</source>
          <target state="translated">상자 수염 항목의 값입니다. 값 목록에 액세스 할 때 다음 열거 형을 색인으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fdaac784c13ff926b13a09ded2298f026c631428" translate="yes" xml:space="preserve">
          <source>The values of the variable are regular expressions (see &lt;a href=&quot;qregexp&quot;&gt;QRegExp&lt;/a&gt; for details). By default, no symbol is defined, meaning that code protected with #ifdef...#endif will be ignored.</source>
          <target state="translated">변수의 값은 정규식입니다 (자세한 내용은 &lt;a href=&quot;qregexp&quot;&gt;QRegExp&lt;/a&gt; 참조). 기본적으로 #ifdef ... # endif로 보호 된 코드는 무시됨을 의미하는 기호가 정의되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a4d4a759de9b354cac9e73ea09853dd287f95c98" translate="yes" xml:space="preserve">
          <source>The values of the variable are regular expressions (see &lt;a href=&quot;qregexp&quot;&gt;QRegExp&lt;/a&gt; for details). If this variable is not set for a preprocessor symbol, QDoc assumes its truth value is true. The exception is '0', which is always false.</source>
          <target state="translated">변수의 값은 정규식입니다 (자세한 내용은 &lt;a href=&quot;qregexp&quot;&gt;QRegExp&lt;/a&gt; 참조). 이 변수가 전 처리기 기호로 설정되지 않은 경우 QDoc은 해당 값이 참이라고 가정합니다. 예외는 '0'이며 항상 거짓입니다.</target>
        </trans-unit>
        <trans-unit id="18bad28decfcab70998a88cae38f56111a5796d4" translate="yes" xml:space="preserve">
          <source>The values of the variable are regular expressions (see &lt;a href=&quot;qtcore-changes-qt6#qregularexpression&quot;&gt;QRegularExpression&lt;/a&gt; for details). By default, no symbol is defined, meaning that code protected with #ifdef...#endif will be ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1325a9b76c8cda6021503ecccf8e95257b66833a" translate="yes" xml:space="preserve">
          <source>The values of the variable are regular expressions (see &lt;a href=&quot;qtcore-changes-qt6#qregularexpression&quot;&gt;QRegularExpression&lt;/a&gt; for details). If this variable is not set for a preprocessor symbol, QDoc assumes its truth value is true. The exception is '0', which is always false.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1782dc4bc9b392be6063ffd2efca596f195cbead" translate="yes" xml:space="preserve">
          <source>The values of this enum describe additional information about a touch point.</source>
          <target state="translated">이 열거 형의 값은 터치 포인트에 대한 추가 정보를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="e0e97a5f96b972ec405787688721a306528f635b" translate="yes" xml:space="preserve">
          <source>The values of this enum type match the SSL errors Chromium provides. &lt;a href=&quot;qsslerror#SslError-enum&quot;&gt;QSslError::SslError&lt;/a&gt; values are not used directly, because the Qt error categories cannot be mapped to the Chromium error categories.</source>
          <target state="translated">이 열거 형 유형의 값은 Chromium이 제공하는 SSL 오류와 일치합니다. &lt;a href=&quot;qsslerror#SslError-enum&quot;&gt;Qtsl&lt;/a&gt; 범주를 Chromium 오류 범주에 매핑 할 수 없으므로 QSslError :: SslError 값은 직접 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d8b311cbd04e92b63fefbf8f719ee1b0a868ed30" translate="yes" xml:space="preserve">
          <source>The values range from -inf to inf. By default these properties are set to &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">값의 범위는 -inf에서 inf입니다. 기본적으로 이러한 특성은 &lt;code&gt;0&lt;/code&gt; 으로 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="6322a5851cae3812bd0bffc03f3d66f7caa1b671" translate="yes" xml:space="preserve">
          <source>The values range from -inf to inf. By default, the properties are set to &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">값의 범위는 -inf에서 inf입니다. 기본적으로 특성은 &lt;code&gt;0&lt;/code&gt; 으로 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="e99b1ddbc687816c1211da8d5a0bfdc651d63d14" translate="yes" xml:space="preserve">
          <source>The values range from -inf to inf. By default, these properties are set to &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">값의 범위는 -inf에서 inf입니다. 기본적으로 이러한 특성은 &lt;code&gt;0&lt;/code&gt; 으로 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="76128397604be8627e30fa711e8a343b6fce3dbd" translate="yes" xml:space="preserve">
          <source>The values range from 0.0 (no blur) to maximumRadius (maximum blur). By default, the property is set to 0.0 (no blur).</source>
          <target state="translated">값의 범위는 0.0 (흐리게 없음)에서 maximumRadius (최대 흐려짐)입니다. 기본적으로이 속성은 0.0 (흐리게 없음)으로 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="3b1fc708f38f12ac3f8f7de14983dfab4e9cd9ae" translate="yes" xml:space="preserve">
          <source>The values range from 0.0 to 1.0. By default, the property is set to &lt;code&gt;0.5&lt;/code&gt;.</source>
          <target state="translated">값의 범위는 0.0에서 1.0입니다. 기본적 &lt;code&gt;0.5&lt;/code&gt; 속성은 0.5 로 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c083f75fddfd3596a7fe0a697baa2b6df0090a5" translate="yes" xml:space="preserve">
          <source>The values returned from this function are kept stable as follows: the mandatory components of the result will not change in future versions of Qt, but optional suffixes may be added.</source>
          <target state="translated">이 함수에서 반환 된 값은 다음과 같이 안정적으로 유지됩니다. 결과의 필수 구성 요소는 향후 Qt 버전에서 변경되지 않지만 선택적 접미사가 추가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce52868ea805f05ceb886efcc410a6f17af758ed" translate="yes" xml:space="preserve">
          <source>The values stored in the &lt;a href=&quot;qmake-variable-reference#config&quot;&gt;CONFIG&lt;/a&gt; variable are treated specially by qmake. Each of the possible values can be used as the condition for a scope. For example, the list of values held by &lt;code&gt;CONFIG&lt;/code&gt; can be extended with the &lt;code&gt;opengl&lt;/code&gt; value:</source>
          <target state="translated">&lt;a href=&quot;qmake-variable-reference#config&quot;&gt;CONFIG&lt;/a&gt; 변수에 저장된 값 은 qmake에 의해 특별히 처리됩니다. 가능한 각 값을 범위의 조건으로 사용할 수 있습니다. 예를 들어, &lt;code&gt;CONFIG&lt;/code&gt; 가 보유한 값 목록을 &lt;code&gt;opengl&lt;/code&gt; 값 으로 확장 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4e7d9efa8b1978081469e2170b4eff0be77d37ab" translate="yes" xml:space="preserve">
          <source>The values stored in the various containers can be of any</source>
          <target state="translated">다양한 컨테이너에 저장된 값은</target>
        </trans-unit>
        <trans-unit id="8f18f8aa7390a1cbd1bc79841a3490a3678780ae" translate="yes" xml:space="preserve">
          <source>The values supported by the device for each of these parameters can be fetched with &lt;a href=&quot;qaudiodeviceinfo#supportedByteOrders&quot;&gt;supportedByteOrders&lt;/a&gt;(), &lt;a href=&quot;qaudiodeviceinfo#supportedChannelCounts&quot;&gt;supportedChannelCounts&lt;/a&gt;(), &lt;a href=&quot;qaudiodeviceinfo#supportedCodecs&quot;&gt;supportedCodecs&lt;/a&gt;(), &lt;a href=&quot;qaudiodeviceinfo#supportedSampleRates&quot;&gt;supportedSampleRates&lt;/a&gt;(), &lt;a href=&quot;qaudiodeviceinfo#supportedSampleSizes&quot;&gt;supportedSampleSizes&lt;/a&gt;(), and &lt;a href=&quot;qaudiodeviceinfo#supportedSampleTypes&quot;&gt;supportedSampleTypes&lt;/a&gt;(). The combinations supported are dependent on the platform, audio plugins installed and the audio device capabilities. If you need a specific format, you can check if the device supports it with &lt;a href=&quot;qaudiodeviceinfo#isFormatSupported&quot;&gt;isFormatSupported&lt;/a&gt;(), or fetch a supported format that is as close as possible to the format with &lt;a href=&quot;qaudiodeviceinfo#nearestFormat&quot;&gt;nearestFormat&lt;/a&gt;(). For instance:</source>
          <target state="translated">이러한 각 매개 변수에 대해 디바이스가 지원하는 값은 &lt;a href=&quot;qaudiodeviceinfo#supportedByteOrders&quot;&gt;supportedByteOrders&lt;/a&gt; (), &lt;a href=&quot;qaudiodeviceinfo#supportedChannelCounts&quot;&gt;supportedChannelCounts&lt;/a&gt; (), &lt;a href=&quot;qaudiodeviceinfo#supportedCodecs&quot;&gt;supportedCodecs&lt;/a&gt; (), &lt;a href=&quot;qaudiodeviceinfo#supportedSampleRates&quot;&gt;supportedSampleRates&lt;/a&gt; (), &lt;a href=&quot;qaudiodeviceinfo#supportedSampleSizes&quot;&gt;supportedSampleSizes&lt;/a&gt; () 및 &lt;a href=&quot;qaudiodeviceinfo#supportedSampleTypes&quot;&gt;supportedSampleTypes&lt;/a&gt; ()를 사용 하여 페치 할 수 있습니다 . 지원되는 조합은 플랫폼, 설치된 오디오 플러그인 및 오디오 장치 기능에 따라 다릅니다. 특정 형식이 필요한 경우 장치가 &lt;a href=&quot;qaudiodeviceinfo#isFormatSupported&quot;&gt;isFormatSupported&lt;/a&gt; ()로 지원하는지 확인 하거나 가장 가까운 &lt;a href=&quot;qaudiodeviceinfo#nearestFormat&quot;&gt;Format&lt;/a&gt; () 으로 형식에 최대한 가까운 지원되는 형식을 가져올 수 있습니다 . 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="5e0bd6ed5106653e91358606e35c94f0655f20bc" translate="yes" xml:space="preserve">
          <source>The values will be either a value that matches an entry in the &lt;a href=&quot;qprinter#PaperSource-enum&quot;&gt;QPrinter::PaperSource&lt;/a&gt; enum or a driver spesific value. The driver spesific values are greater than the constant DMBIN_USER declared in wingdi.h.</source>
          <target state="translated">값은 &lt;a href=&quot;qprinter#PaperSource-enum&quot;&gt;QPrinter :: PaperSource&lt;/a&gt; 열거 형 의 항목과 일치하는 값 이거나 드라이버 고유 값입니다. 드라이버 고유 값이 wingdi.h에 선언 된 상수 DMBIN_USER보다 큽니다.</target>
        </trans-unit>
        <trans-unit id="478003345dc7862f2215cc623144886ca0a6f91e" translate="yes" xml:space="preserve">
          <source>The variable is initialized to 0x80.</source>
          <target state="translated">변수는 0x80으로 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="fcd95b67542b68c0aa4ab770ddc4aad556da4e70" translate="yes" xml:space="preserve">
          <source>The variable that specifies the files that should be processed with the custom compiler.</source>
          <target state="translated">사용자 정의 컴파일러로 처리해야하는 파일을 지정하는 변수입니다.</target>
        </trans-unit>
        <trans-unit id="48a8da7c6172a69a8c2a79dadccb44cbbd1971af" translate="yes" xml:space="preserve">
          <source>The variable that the files created from the output should be added to.</source>
          <target state="translated">출력에서 작성된 파일이 추가되어야하는 변수입니다.</target>
        </trans-unit>
        <trans-unit id="254dc2d8840db491323d0a7f51cbc5ac85ebd0b4" translate="yes" xml:space="preserve">
          <source>The variable's value is given as raw HTML code enclosed by quotation marks. Note that if the value spans several lines, each line needs to be enclosed by quotation marks.</source>
          <target state="translated">변수 값은 따옴표로 묶인 원시 HTML 코드로 제공됩니다. 값이 여러 줄에 걸쳐 있으면 각 줄을 따옴표로 묶어야합니다.</target>
        </trans-unit>
        <trans-unit id="4a840ce751b025c33bdcb9787a1baba4b7b05cb5" translate="yes" xml:space="preserve">
          <source>The variable's value is given as raw HTML enclosed by quotation marks. Note that if the value spans several lines, each line needs to be enclosed by quotation marks.</source>
          <target state="translated">변수 값은 따옴표로 묶인 원시 HTML로 제공됩니다. 값이 여러 줄에 걸쳐 있으면 각 줄을 따옴표로 묶어야합니다.</target>
        </trans-unit>
        <trans-unit id="f3acb47c06af0fe184ff04296b35ec2ecf819654" translate="yes" xml:space="preserve">
          <source>The variable's values (the extensions) are given as standard wildcard expressions. The general syntax is: &lt;code&gt;images.fileextensions.&lt;i&gt;format&lt;/i&gt; = *.&lt;i&gt;extension&lt;/i&gt;&lt;/code&gt;.</source>
          <target state="translated">변수 값 (확장자)은 표준 와일드 카드 표현식으로 제공됩니다. 일반적인 구문은 &lt;code&gt;images.fileextensions.&lt;i&gt;format&lt;/i&gt; = *.&lt;i&gt;extension&lt;/i&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3b65afe1523e5ebc65d82221c7c841ea6532383a" translate="yes" xml:space="preserve">
          <source>The variables passed as</source>
          <target state="translated">전달 된 변수</target>
        </trans-unit>
        <trans-unit id="9b21d524db3100478572b85fc04d090f55378b57" translate="yes" xml:space="preserve">
          <source>The variant contains a &lt;a href=&quot;qlocale&quot;&gt;QLocale&lt;/a&gt; object specifying the language of a certain part of the preedit string. There should be at most one language set for every part of the preedit string. If several are specified for any character in the string the behavior is undefined.</source>
          <target state="translated">변형 은 사전 편집 문자열의 특정 부분의 언어를 지정 하는 &lt;a href=&quot;qlocale&quot;&gt;QLocale&lt;/a&gt; 객체를 포함 합니다. 사전 편집 문자열의 모든 부분에 대해 최대 하나의 언어 세트가 있어야합니다. 문자열의 문자에 대해 여러 개가 지정되면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bc9a12c1b97a2b95e2e112e8c30263ae47e8f138" translate="yes" xml:space="preserve">
          <source>The variant element (&lt;a href=&quot;qdbusvariant&quot;&gt;QDBusVariant&lt;/a&gt;)</source>
          <target state="translated">변형 요소 ( &lt;a href=&quot;qdbusvariant&quot;&gt;QDBusVariant&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="e5d742181b0275cb3b41c7cbb4039db5713e76aa" translate="yes" xml:space="preserve">
          <source>The variant which operates on &lt;a href=&quot;qcoreapplication&quot;&gt;QCoreApplication&lt;/a&gt; makes it possible to finish asynchronously running jobs after the last gui window has been closed. This can be useful for example for running a job which uploads data to a network.</source>
          <target state="translated">&lt;a href=&quot;qcoreapplication&quot;&gt;QCoreApplication에서&lt;/a&gt; 작동하는 변형을 사용하면 마지막 GUI 창을 닫은 후 비동기 적으로 실행중인 작업을 완료 할 수 있습니다. 예를 들어 네트워크에 데이터를 업로드하는 작업을 실행하는 데 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b3c2da68246013c7036e5884eb6706f700f8762" translate="yes" xml:space="preserve">
          <source>The variation in the alpha channel between particles.</source>
          <target state="translated">입자 간 알파 채널의 변화입니다.</target>
        </trans-unit>
        <trans-unit id="b041fbde93c2bb5a89933894c65d2660de7c5962" translate="yes" xml:space="preserve">
          <source>The variation in the blue color channel between particles.</source>
          <target state="translated">입자들 사이의 청색 채널의 변화.</target>
        </trans-unit>
        <trans-unit id="56aa52ec742b178a38c876a28c520b7553b50af3" translate="yes" xml:space="preserve">
          <source>The variation in the green color channel between particles.</source>
          <target state="translated">입자들 사이의 녹색 채널의 변화.</target>
        </trans-unit>
        <trans-unit id="a489e02173fe741833eb6b173034662a7a8f68e9" translate="yes" xml:space="preserve">
          <source>The variation in the red color channel between particles.</source>
          <target state="translated">입자들 사이의 붉은 색 채널의 변화.</target>
        </trans-unit>
        <trans-unit id="79450662f7ed124fbae5f0c54429d5fe2bccf555" translate="yes" xml:space="preserve">
          <source>The various border style properties of &lt;a href=&quot;qtexttablecellformat&quot;&gt;QTextTableCellFormat&lt;/a&gt; can be used to customize the grid and have precedence over the border and grid of the table</source>
          <target state="translated">The various border style properties of &lt;a href=&quot;qtexttablecellformat&quot;&gt;QTextTableCellFormat&lt;/a&gt; can be used to customize the grid and have precedence over the border and grid of the table</target>
        </trans-unit>
        <trans-unit id="31423edb0ac1a1769af3f0962555582de6f367b4" translate="yes" xml:space="preserve">
          <source>The various design aspects of the outline are based on the stroker's properties: &lt;a href=&quot;qpainterpathstroker#width&quot;&gt;width&lt;/a&gt;(), &lt;a href=&quot;qpainterpathstroker#capStyle&quot;&gt;capStyle&lt;/a&gt;(), &lt;a href=&quot;qpainterpathstroker#joinStyle&quot;&gt;joinStyle&lt;/a&gt;(), &lt;a href=&quot;qpainterpathstroker#dashPattern&quot;&gt;dashPattern&lt;/a&gt;(), &lt;a href=&quot;qpainterpathstroker#curveThreshold&quot;&gt;curveThreshold&lt;/a&gt;() and &lt;a href=&quot;qpainterpathstroker#miterLimit&quot;&gt;miterLimit&lt;/a&gt;().</source>
          <target state="translated">외곽선의 다양한 디자인 측면은 &lt;a href=&quot;qpainterpathstroker#width&quot;&gt;너비&lt;/a&gt; (), &lt;a href=&quot;qpainterpathstroker#capStyle&quot;&gt;capStyle&lt;/a&gt; (), &lt;a href=&quot;qpainterpathstroker#joinStyle&quot;&gt;joinStyle&lt;/a&gt; (), &lt;a href=&quot;qpainterpathstroker#dashPattern&quot;&gt;dashPattern&lt;/a&gt; (), &lt;a href=&quot;qpainterpathstroker#curveThreshold&quot;&gt;curveThreshold&lt;/a&gt; () 및 &lt;a href=&quot;qpainterpathstroker#miterLimit&quot;&gt;miterLimit&lt;/a&gt; () 와 같은 획의 속성을 기반으로합니다 .</target>
        </trans-unit>
        <trans-unit id="df1061d8cc0845a2f40f3ac7b2305380054b114f" translate="yes" xml:space="preserve">
          <source>The various enums and types for &lt;a href=&quot;qpagesize&quot;&gt;page sizes&lt;/a&gt;, margins, and orientation have been consolidated. &lt;a href=&quot;qprinter&quot;&gt;QPrinter&lt;/a&gt; APIs to set paper sizes and margins explicitly have been removed; use &lt;a href=&quot;qpagedpaintdevice#setPageLayout&quot;&gt;QPagedPaintDevice::setPageLayout&lt;/a&gt;(), &lt;a href=&quot;qpagedpaintdevice#setPageSize&quot;&gt;QPagedPaintDevice::setPageSize&lt;/a&gt;(), &lt;a href=&quot;qpagedpaintdevice#setPageOrientation&quot;&gt;QPagedPaintDevice::setPageOrientation&lt;/a&gt;(), and &lt;a href=&quot;qpagedpaintdevice#setPageMargins&quot;&gt;QPagedPaintDevice::setPageMargins&lt;/a&gt;() instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a4345dcc28902d4baaa1bc7b7998b2cb41e8c0b" translate="yes" xml:space="preserve">
          <source>The various initStyleOption() methods in widget classes are now virtual.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="942eb560f30965424a06f07713abdca46bccf273" translate="yes" xml:space="preserve">
          <source>The various matrix elements can be set when constructing the matrix, or by using the &lt;a href=&quot;qmatrix#setMatrix&quot;&gt;setMatrix&lt;/a&gt;() function later on. They can also be manipulated using the &lt;a href=&quot;qmatrix#translate&quot;&gt;translate&lt;/a&gt;(), &lt;a href=&quot;qmatrix#rotate&quot;&gt;rotate&lt;/a&gt;(), &lt;a href=&quot;qmatrix#scale&quot;&gt;scale&lt;/a&gt;() and &lt;a href=&quot;qmatrix#shear&quot;&gt;shear&lt;/a&gt;() convenience functions, The currently set values can be retrieved using the &lt;a href=&quot;qmatrix#m11&quot;&gt;m11&lt;/a&gt;(), &lt;a href=&quot;qmatrix#m12&quot;&gt;m12&lt;/a&gt;(), &lt;a href=&quot;qmatrix#m21&quot;&gt;m21&lt;/a&gt;(), &lt;a href=&quot;qmatrix#m22&quot;&gt;m22&lt;/a&gt;(), &lt;a href=&quot;qmatrix#dx&quot;&gt;dx&lt;/a&gt;() and &lt;a href=&quot;qmatrix#dy&quot;&gt;dy&lt;/a&gt;() functions.</source>
          <target state="translated">행렬을 구성 할 때 또는 나중에 &lt;a href=&quot;qmatrix#setMatrix&quot;&gt;setMatrix&lt;/a&gt; () 함수를 사용하여 다양한 행렬 요소를 설정할 수 있습니다 . 또한 &lt;a href=&quot;qmatrix#translate&quot;&gt;번역&lt;/a&gt; (), &lt;a href=&quot;qmatrix#rotate&quot;&gt;회전&lt;/a&gt; (), &lt;a href=&quot;qmatrix#scale&quot;&gt;스케일&lt;/a&gt; () 및 &lt;a href=&quot;qmatrix#shear&quot;&gt;전단&lt;/a&gt; () 편의 기능을 사용하여 조작 할 수 있습니다. 현재 설정된 값은 &lt;a href=&quot;qmatrix#m11&quot;&gt;m11&lt;/a&gt; (), &lt;a href=&quot;qmatrix#m12&quot;&gt;m12&lt;/a&gt; (), &lt;a href=&quot;qmatrix#m21&quot;&gt;m21&lt;/a&gt; (), &lt;a href=&quot;qmatrix#m22&quot;&gt;m22&lt;/a&gt; (), &lt;a href=&quot;qmatrix#dx&quot;&gt;dx&lt;/a&gt; () 및 &lt;a href=&quot;qmatrix#dy&quot;&gt;dy&lt;/a&gt; () 함수</target>
        </trans-unit>
        <trans-unit id="776427fc023f0c1fb9cc7206d727fe7dd7fd221d" translate="yes" xml:space="preserve">
          <source>The various matrix elements can be set when constructing the matrix, or by using the &lt;a href=&quot;qtransform#setMatrix&quot;&gt;setMatrix&lt;/a&gt;() function later on. They can also be manipulated using the &lt;a href=&quot;qtransform#translate&quot;&gt;translate&lt;/a&gt;(), &lt;a href=&quot;qtransform#rotate&quot;&gt;rotate&lt;/a&gt;(), &lt;a href=&quot;qtransform#scale&quot;&gt;scale&lt;/a&gt;() and &lt;a href=&quot;qtransform#shear&quot;&gt;shear&lt;/a&gt;() convenience functions. The currently set values can be retrieved using the &lt;a href=&quot;qtransform#m11&quot;&gt;m11&lt;/a&gt;(), &lt;a href=&quot;qtransform#m12&quot;&gt;m12&lt;/a&gt;(), &lt;a href=&quot;qtransform#m13&quot;&gt;m13&lt;/a&gt;(), &lt;a href=&quot;qtransform#m21&quot;&gt;m21&lt;/a&gt;(), &lt;a href=&quot;qtransform#m22&quot;&gt;m22&lt;/a&gt;(), &lt;a href=&quot;qtransform#m23&quot;&gt;m23&lt;/a&gt;(), &lt;a href=&quot;qtransform#m31&quot;&gt;m31&lt;/a&gt;(), &lt;a href=&quot;qtransform#m32&quot;&gt;m32&lt;/a&gt;(), &lt;a href=&quot;qtransform#m33&quot;&gt;m33&lt;/a&gt;(), &lt;a href=&quot;qtransform#dx&quot;&gt;dx&lt;/a&gt;() and &lt;a href=&quot;qtransform#dy&quot;&gt;dy&lt;/a&gt;() functions.</source>
          <target state="translated">행렬을 구성 할 때 또는 나중에 &lt;a href=&quot;qtransform#setMatrix&quot;&gt;setMatrix&lt;/a&gt; () 함수를 사용하여 다양한 행렬 요소를 설정할 수 있습니다 . 또한 &lt;a href=&quot;qtransform#translate&quot;&gt;번역&lt;/a&gt; (), &lt;a href=&quot;qtransform#rotate&quot;&gt;회전&lt;/a&gt; (), &lt;a href=&quot;qtransform#scale&quot;&gt;스케일&lt;/a&gt; () 및 &lt;a href=&quot;qtransform#shear&quot;&gt;전단&lt;/a&gt; () 편의 기능을 사용하여 조작 할 수도 있습니다 . 현재 설정된 값은 &lt;a href=&quot;qtransform#m11&quot;&gt;m11&lt;/a&gt; (), &lt;a href=&quot;qtransform#m12&quot;&gt;m12&lt;/a&gt; (), &lt;a href=&quot;qtransform#m13&quot;&gt;m13&lt;/a&gt; (), &lt;a href=&quot;qtransform#m21&quot;&gt;m21&lt;/a&gt; (), &lt;a href=&quot;qtransform#m22&quot;&gt;m22&lt;/a&gt; (), &lt;a href=&quot;qtransform#m23&quot;&gt;m23&lt;/a&gt; (), &lt;a href=&quot;qtransform#m31&quot;&gt;m31&lt;/a&gt; (), &lt;a href=&quot;qtransform#m32&quot;&gt;m32&lt;/a&gt; (), &lt;a href=&quot;qtransform#m33&quot;&gt;m33&lt;/a&gt; (), &lt;a href=&quot;qtransform#dx&quot;&gt;dx&lt;/a&gt; () 및 &lt;a href=&quot;qtransform#dy&quot;&gt;dy를 사용하여 검색 할 수 있습니다.&lt;/a&gt; () 기능.</target>
        </trans-unit>
        <trans-unit id="49de2e3398ed19c87c945dd351608853ba915318" translate="yes" xml:space="preserve">
          <source>The various settings and functionality of the Camera stack is spread across a few different child properties of Camera.</source>
          <target state="translated">카메라 스택의 다양한 설정 및 기능은 카메라의 몇 가지 다른 하위 속성에 분산되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="082589886f3ad162bcd3f6949e3ebad1a07153ec" translate="yes" xml:space="preserve">
          <source>The various settings can easily be modified using the corresponding &lt;a href=&quot;qpen#setStyle&quot;&gt;setStyle&lt;/a&gt;(), &lt;a href=&quot;qpen#setWidth&quot;&gt;setWidth&lt;/a&gt;(), &lt;a href=&quot;qpen#setBrush&quot;&gt;setBrush&lt;/a&gt;(), &lt;a href=&quot;qpen#setCapStyle&quot;&gt;setCapStyle&lt;/a&gt;() and &lt;a href=&quot;qpen#setJoinStyle&quot;&gt;setJoinStyle&lt;/a&gt;() functions (note that the painter's pen must be reset when altering the pen's properties).</source>
          <target state="translated">해당 &lt;a href=&quot;qpen#setStyle&quot;&gt;setStyle&lt;/a&gt; (), &lt;a href=&quot;qpen#setWidth&quot;&gt;setWidth&lt;/a&gt; (), &lt;a href=&quot;qpen#setBrush&quot;&gt;setBrush&lt;/a&gt; (), &lt;a href=&quot;qpen#setCapStyle&quot;&gt;setCapStyle&lt;/a&gt; () 및 &lt;a href=&quot;qpen#setJoinStyle&quot;&gt;setJoinStyle&lt;/a&gt; () 함수를 사용하여 다양한 설정을 쉽게 수정할 수 있습니다 (펜의 속성을 변경할 때 화가 펜을 재설정해야 함).</target>
        </trans-unit>
        <trans-unit id="10755b3853528d73f41f165169a8fbd3d1a7d940" translate="yes" xml:space="preserve">
          <source>The vector can contain an odd number of elements, in which case the last element will be extended by the length of the first element when the pattern repeats.</source>
          <target state="translated">벡터는 홀수 개의 요소를 포함 할 수 있으며,이 경우 패턴이 반복 될 때 마지막 요소가 첫 번째 요소의 길이만큼 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="a90fbec930b8da01522acfbefd4434fb0642df62" translate="yes" xml:space="preserve">
          <source>The vector of joints this joint has as children.</source>
          <target state="translated">이 관절은 어린이로서 관절의 벡터입니다.</target>
        </trans-unit>
        <trans-unit id="d2870f12265e880dda458c27da646ad853170f2f" translate="yes" xml:space="preserve">
          <source>The vector2d type has the following idempotent functions which can be invoked in QML:</source>
          <target state="translated">vector2d 유형에는 QML에서 호출 할 수있는 다음과 같은 dem 등원 함수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="bd3e0f79e28e79f9feddf74784c92c681f9d0ea1" translate="yes" xml:space="preserve">
          <source>The vector3d type has the following idempotent functions which can be invoked in QML:</source>
          <target state="translated">vector3d 유형에는 QML에서 호출 할 수있는 다음과 같은 dem 등원 함수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec81c3f4fd3e47fec8964c5a90b62760ddfc3bf3" translate="yes" xml:space="preserve">
          <source>The vector4d type has the following idempotent functions which can be invoked in QML:</source>
          <target state="translated">vector4d 유형에는 QML에서 호출 할 수있는 다음과 같은 dem 등원 함수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a13b49792ef79eaed81e6acd849989ba67fdb787" translate="yes" xml:space="preserve">
          <source>The velocity is reported for both the x and y axis separately by using a &lt;a href=&quot;qpointf&quot;&gt;QPointF&lt;/a&gt;.</source>
          <target state="translated">속도는 &lt;a href=&quot;qpointf&quot;&gt;QPointF&lt;/a&gt; 를 사용하여 x 축과 y 축 모두에 대해 별도로보고됩니다 .</target>
        </trans-unit>
        <trans-unit id="dd22b6aff50d785fb2248cdd81a80828588dd4e1" translate="yes" xml:space="preserve">
          <source>The velocity of the device that reported the position</source>
          <target state="translated">위치를보고 한 장치의 속도</target>
        </trans-unit>
        <trans-unit id="cce9ae3ac3fd1731f7c1e995bdbe490eb7ff6cfc" translate="yes" xml:space="preserve">
          <source>The vendor URL of the device.</source>
          <target state="translated">장치의 공급 업체 URL입니다.</target>
        </trans-unit>
        <trans-unit id="792cd46c34e4d40b32829a1f1ef3a5fb8e5ae13f" translate="yes" xml:space="preserve">
          <source>The vendor name of the device.</source>
          <target state="translated">장치의 공급 업체 이름입니다.</target>
        </trans-unit>
        <trans-unit id="74c32d21a08a803062fbb4b9f4270594ad047e65" translate="yes" xml:space="preserve">
          <source>The version has no special meaning for &lt;a href=&quot;qstylehintreturn&quot;&gt;QStyleHintReturn&lt;/a&gt;; it can be used by subclasses to distinguish between different version of the same hint type.</source>
          <target state="translated">버전은 &lt;a href=&quot;qstylehintreturn&quot;&gt;QStyleHintReturn에&lt;/a&gt; 특별한 의미가 없습니다 . 서브 클래스에서 동일한 힌트 유형의 다른 버전을 구별하기 위해 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4202481d2bc641515954365c190f1d92a7f731c" translate="yes" xml:space="preserve">
          <source>The version has no special meaning for &lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption&lt;/a&gt;; it can be used by subclasses to distinguish between different version of the same option type.</source>
          <target state="translated">버전은 &lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption에&lt;/a&gt; 특별한 의미가 없습니다 . 서브 클래스에서 동일한 옵션 유형의 다른 버전을 구별하기 위해 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c4a0c7594ea812fa45acfc27a110d7646b0d98a9" translate="yes" xml:space="preserve">
          <source>The version has no special meaning for QStyleHintReturn; it can be used by subclasses to distinguish between different version of the same hint type.</source>
          <target state="translated">The version has no special meaning for QStyleHintReturn; it can be used by subclasses to distinguish between different version of the same hint type.</target>
        </trans-unit>
        <trans-unit id="68df4c969d62281833eb1925fbf8fbdb25c5a084" translate="yes" xml:space="preserve">
          <source>The version has no special meaning for QStyleOption; it can be used by subclasses to distinguish between different version of the same option type.</source>
          <target state="translated">버전은 QStyleOption에 대해 특별한 의미가 없습니다. 동일한 옵션 유형의 다른 버전을 구별하기 위해 서브 클래스에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f2f11064d7814cb7571d8d0197564320a3b94a48" translate="yes" xml:space="preserve">
          <source>The version is used by &lt;a href=&quot;qstylehintreturn&quot;&gt;QStyleHintReturn&lt;/a&gt; subclasses to implement extensions without breaking compatibility. If you use &lt;a href=&quot;qstylehintreturn#qstyleoption_cast&quot;&gt;qstyleoption_cast&lt;/a&gt;(), you normally do not need to check it.</source>
          <target state="translated">버전은 &lt;a href=&quot;qstylehintreturn&quot;&gt;QStyleHintReturn&lt;/a&gt; 서브 클래스에서 호환성을 유지하면서 확장을 구현 하는 데 사용됩니다 . &lt;a href=&quot;qstylehintreturn#qstyleoption_cast&quot;&gt;qstyleoption_cast&lt;/a&gt; () 를 사용하는 경우 일반적으로 확인할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="5040d0c18c3b3be3fe108a90775ca439754a1981" translate="yes" xml:space="preserve">
          <source>The version is used by &lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption&lt;/a&gt; subclasses to implement extensions without breaking compatibility. If you use &lt;a href=&quot;qstyleoption#qstyleoption_cast&quot;&gt;qstyleoption_cast&lt;/a&gt;(), you normally do not need to check it.</source>
          <target state="translated">버전은 &lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption&lt;/a&gt; 서브 클래스에서 호환성을 유지하면서 확장을 구현 하는 데 사용됩니다 . &lt;a href=&quot;qstyleoption#qstyleoption_cast&quot;&gt;qstyleoption_cast&lt;/a&gt; () 를 사용하는 경우 일반적으로 확인할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="b6851da8982ae5d9f0aeaba1c696b9c8029f5d11" translate="yes" xml:space="preserve">
          <source>The version number of the package. Defaults to &lt;code&gt;1.0.0.0&lt;/code&gt;.</source>
          <target state="translated">패키지의 버전 번호입니다. 기본값은 &lt;code&gt;1.0.0.0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5fd4753f16ed25b93c5456caeb4b3361a4f5d389" translate="yes" xml:space="preserve">
          <source>The version number specified will be used as the version of the type library and of the server when registering.</source>
          <target state="translated">지정된 버전 번호는 등록시 형식 라이브러리 및 서버의 버전으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7dc748465d26c71647754a4a0c51c2337df5e2e0" translate="yes" xml:space="preserve">
          <source>The version of qmake supplied in source packages is configured slightly differently to that supplied in binary packages in that it uses a different feature specification. Where the source package typically uses the &lt;code&gt;macx-g++&lt;/code&gt; specification, the binary package is typically configured to use the &lt;code&gt;macx-xcode&lt;/code&gt; specification.</source>
          <target state="translated">소스 패키지에 제공된 qmake 버전은 다른 기능 사양을 사용한다는 점에서 이진 패키지에 제공된 버전과 약간 다르게 구성됩니다. 소스 패키지가 일반적으로 &lt;code&gt;macx-g++&lt;/code&gt; 사양을 사용하는 경우 이진 패키지는 일반적으로 &lt;code&gt;macx-xcode&lt;/code&gt; 사양 을 사용하도록 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="a3f40135f4012ad93691631ed4cae223724ae748" translate="yes" xml:space="preserve">
          <source>The version of the class (1.0 is default)</source>
          <target state="translated">클래스의 버전 (1.0이 기본값)</target>
        </trans-unit>
        <trans-unit id="defc983c543d1db67325dab10fc0d12a300312f9" translate="yes" xml:space="preserve">
          <source>The versions accepting point and rect are since Qt 5.15.</source>
          <target state="translated">point 및 rect를 허용하는 버전은 Qt 5.15 이후입니다.</target>
        </trans-unit>
        <trans-unit id="560f41270b3417365b79fd87f0f6d0c00fbc9af8" translate="yes" xml:space="preserve">
          <source>The vertex attributes provided as inputs to the vertex shaders are defined by the mesh files. The following vertex attributes are used by default.</source>
          <target state="translated">정점 셰이더에 대한 입력으로 제공되는 정점 속성은 메시 파일에 의해 정의됩니다. 기본적으로 다음 정점 속성이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2e41d070e3e92cc2f4d4a4ce23c803e9d706df28" translate="yes" xml:space="preserve">
          <source>The vertex color material respects both current opacity and current matrix when updating it's rendering state.</source>
          <target state="translated">버텍스 컬러 머티리얼은 렌더링 상태를 업데이트 할 때 현재 불투명도와 현재 매트릭스를 모두 존중합니다.</target>
        </trans-unit>
        <trans-unit id="4eec2ac878a77b5440e5a5d9554d5794d4fbf64b" translate="yes" xml:space="preserve">
          <source>The vertex color material will give each vertex in a geometry a color. Pixels between vertices will be linearly interpolated. The colors can contain transparency.</source>
          <target state="translated">꼭짓점 색상 재질은 도형의 각 꼭짓점에 색상을 부여합니다. 정점 사이의 픽셀은 선형으로 보간됩니다. 색상은 투명도를 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dfd8f3ecb68abd108ad9b34679ec342ad244779d" translate="yes" xml:space="preserve">
          <source>The vertex normal from the input mesh data, or all zeroes if there were no normals provided. As with VERTEX, the shader is free to alter the value as it sees fit. The altered value is then used by the rest of the pipeline, including the lighting calculations in the fragment stage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c82e08bc76f758541ea1f65f517da2642278dcaf" translate="yes" xml:space="preserve">
          <source>The vertex position the shader receives as input. A common use case for vertex shaders in custom materials is to change (displace) the x, y, or z values of this vector, by simply assigning a value to the whole vector, or some of its components.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad2f1f796725159be2302dd7761bbff89ca94f84" translate="yes" xml:space="preserve">
          <source>The vertex shader in an unshaded material still has the typical inputs available: &lt;code&gt;VERTEX&lt;/code&gt;, &lt;code&gt;NORMAL&lt;/code&gt;, &lt;code&gt;MODELVIEWPROJECTION_MATRIX&lt;/code&gt;, etc. and can write to &lt;code&gt;POSITION&lt;/code&gt;. The fragment shader no longer has the similar conveniences available, however: &lt;code&gt;NORMAL&lt;/code&gt;, &lt;code&gt;UV0&lt;/code&gt;, or &lt;code&gt;VAR_WORLD_POSITION&lt;/code&gt; are not available in an unshaded material's fragment shader. Rather, it is now up to the shader code to calculate and pass on using &lt;code&gt;VARYING&lt;/code&gt; everything it needs to determine the final fragment color.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e4898102c5a84f5e4a3d166de4824966d9ef716" translate="yes" xml:space="preserve">
          <source>The vertical direction. Equivalent to GL_TEXTURE_WRAP_T</source>
          <target state="translated">수직 방향. GL_TEXTURE_WRAP_T와 동일</target>
        </trans-unit>
        <trans-unit id="59b552887fbfc1ecb68f54d456a74a2cc2534237" translate="yes" xml:space="preserve">
          <source>The vertical extra space on the top/bottom of a menu.</source>
          <target state="translated">메뉴 상단 / 하단의 수직 추가 공간.</target>
        </trans-unit>
        <trans-unit id="25f5b6703f1b706b13831e53d194254761afcdaa" translate="yes" xml:space="preserve">
          <source>The vertical flags are:</source>
          <target state="translated">수직 플래그는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b1e50773ee969d0ccfb81323990bb29073c84a37" translate="yes" xml:space="preserve">
          <source>The vertical movement x position is cleared automatically when the cursor moves horizontally, and kept unchanged when the cursor moves vertically. The mechanism allows the cursor to move up and down on a visually straight line with proportional fonts, and to gently &quot;jump&quot; over short lines.</source>
          <target state="translated">커서가 가로로 움직이면 세로 이동 x 위치가 자동으로 지워지고 커서가 세로로 움직일 때 변경되지 않습니다. 이 메커니즘을 사용하면 커서가 비례 글꼴이있는 시각적 직선에서 위아래로 이동하고 짧은 선에서 부드럽게 &quot;점프&quot;할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="065eb1eef885acf5174b82542d78195f4ac7615b" translate="yes" xml:space="preserve">
          <source>The vertical position of the &lt;a href=&quot;qml-qtquick-pathtext&quot;&gt;PathText&lt;/a&gt;'s baseline.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-pathtext&quot;&gt;PathText&lt;/a&gt; 기준선 의 수직 위치입니다 .</target>
        </trans-unit>
        <trans-unit id="2bdc5f9e0c8457ba5eb42f8a408dce0676e18c50" translate="yes" xml:space="preserve">
          <source>The vertical position of the pie.</source>
          <target state="translated">파이의 세로 위치입니다.</target>
        </trans-unit>
        <trans-unit id="d241a2c5fee977d22d6e3e35ce51289b0c8d7277" translate="yes" xml:space="preserve">
          <source>The vertical resolution of the device in dots per inch. See also &lt;a href=&quot;qpaintdevice#logicalDpiY&quot;&gt;logicalDpiY&lt;/a&gt;().</source>
          <target state="translated">인치당 도트 수로 표시되는 장치의 수직 해상도입니다. &lt;a href=&quot;qpaintdevice#logicalDpiY&quot;&gt;logicalDpiY&lt;/a&gt; () 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b8f718a36e46273727198996b41a03686ef937c3" translate="yes" xml:space="preserve">
          <source>The vertical resolution of the device in dots per inch. See also &lt;a href=&quot;qpaintdevice#physicalDpiY&quot;&gt;physicalDpiY&lt;/a&gt;().</source>
          <target state="translated">인치당 도트 수로 표시되는 장치의 수직 해상도입니다. &lt;a href=&quot;qpaintdevice#physicalDpiY&quot;&gt;physicalDpiY&lt;/a&gt; () 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3d025d727ca70b4cdba534ee6f3f51c95db26a4c" translate="yes" xml:space="preserve">
          <source>The vertical roughness texture map. Default is a &lt;a href=&quot;qml-qtquick3d-texture&quot;&gt;Texture&lt;/a&gt; with source &lt;code&gt;&quot;maps/brushed_full_contrast.png&quot;&lt;/code&gt;.</source>
          <target state="translated">수직 거칠기 텍스처 맵입니다. 기본값은 소스가 &lt;code&gt;&quot;maps/brushed_full_contrast.png&quot;&lt;/code&gt; 인&lt;a href=&quot;qml-qtquick3d-texture&quot;&gt;텍스처&lt;/a&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="a79f2c1142c446d1954371149c2b20fb5f0ac12c" translate="yes" xml:space="preserve">
          <source>The vertical speed, in meters/sec.</source>
          <target state="translated">수직 속도 (미터 / 초)</target>
        </trans-unit>
        <trans-unit id="8d2842df2f4ea0b8b98062a4c188487424e9a3ae" translate="yes" xml:space="preserve">
          <source>The vertical wrap mode is set on the texture instance just before the texture is bound for rendering.</source>
          <target state="translated">수직 랩 모드는 텍스처가 렌더링을 위해 바인딩되기 직전에 텍스처 인스턴스에서 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="3621fb655616bc1f6a43d7d3c0c60a490ca036f3" translate="yes" xml:space="preserve">
          <source>The video buffer is not mapped to memory.</source>
          <target state="translated">비디오 버퍼가 메모리에 매핑되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="5b51a9903b3210e4610473c5f7c24b9ca64ff7eb" translate="yes" xml:space="preserve">
          <source>The video format most commonly used by DRM services, H.264, requires proprietary audio and video codecs. For more information about enabling the codecs, see &lt;a href=&quot;#audio-and-video-codecs&quot;&gt;Audio and Video Codecs&lt;/a&gt;.</source>
          <target state="translated">DRM 서비스 H.264에서 가장 일반적으로 사용하는 비디오 형식에는 독점적 인 오디오 및 비디오 코덱이 필요합니다. 코덱 활성화에 대한 자세한 내용은 &lt;a href=&quot;#audio-and-video-codecs&quot;&gt;오디오 및 비디오 코덱을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7cd21c1d047796ae1530329749b380213ef6fe78" translate="yes" xml:space="preserve">
          <source>The video format most commonly used by DRM services, H.264, requires proprietary audio and video codecs. For more information about enabling the codecs, see &lt;a href=&quot;qtwebengine-features#audio-and-video-codecs&quot;&gt;Audio and Video Codecs&lt;/a&gt;.</source>
          <target state="translated">DRM 서비스에서 가장 일반적으로 사용되는 비디오 형식 인 H.264에는 독점 오디오 및 비디오 코덱이 필요합니다. 코덱 활성화에 대한 자세한 내용은 &lt;a href=&quot;qtwebengine-features#audio-and-video-codecs&quot;&gt;오디오 및 비디오 코덱을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="65a94c30c401261c1a72494cb28e8ced184e18df" translate="yes" xml:space="preserve">
          <source>The video pixel data in a &lt;a href=&quot;qvideoframe&quot;&gt;QVideoFrame&lt;/a&gt; is encapsulated in a &lt;a href=&quot;qabstractvideobuffer&quot;&gt;QAbstractVideoBuffer&lt;/a&gt;. A &lt;a href=&quot;qvideoframe&quot;&gt;QVideoFrame&lt;/a&gt; may be constructed from any buffer type by subclassing the &lt;a href=&quot;qabstractvideobuffer&quot;&gt;QAbstractVideoBuffer&lt;/a&gt; class.</source>
          <target state="translated">&lt;a href=&quot;qvideoframe&quot;&gt;QVideoFrame&lt;/a&gt; 의 비디오 픽셀 데이터 는 &lt;a href=&quot;qabstractvideobuffer&quot;&gt;QAbstractVideoBuffer에&lt;/a&gt; 캡슐화됩니다 . &lt;a href=&quot;qvideoframe&quot;&gt;QVideoFrame들은&lt;/a&gt; 서브 클래 싱에 의해 어떤 유형의 버퍼로 구성 될 수있다 &lt;a href=&quot;qabstractvideobuffer&quot;&gt;QAbstractVideoBuffer의&lt;/a&gt; 클래스.</target>
        </trans-unit>
        <trans-unit id="7f58bb8049c4178e87d6e3af220734207777ab7b" translate="yes" xml:space="preserve">
          <source>The video pixel data in a QVideoFrame is encapsulated in a &lt;a href=&quot;qabstractvideobuffer&quot;&gt;QAbstractVideoBuffer&lt;/a&gt;. A QVideoFrame may be constructed from any buffer type by subclassing the &lt;a href=&quot;qabstractvideobuffer&quot;&gt;QAbstractVideoBuffer&lt;/a&gt; class.</source>
          <target state="translated">QVideoFrame의 비디오 픽셀 데이터는 &lt;a href=&quot;qabstractvideobuffer&quot;&gt;QAbstractVideoBuffer에&lt;/a&gt; 캡슐화됩니다 . QVideoFrame은 &lt;a href=&quot;qabstractvideobuffer&quot;&gt;QAbstractVideoBuffer&lt;/a&gt; 클래스 를 서브 클래 싱하여 모든 버퍼 유형에서 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="539854333db0054b3bdbb9b4225706f2a1389b60" translate="yes" xml:space="preserve">
          <source>The video player is available to use.</source>
          <target state="translated">비디오 플레이어를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2aa8f9e1deaf1da6f1e45d952671abf334a62ea6" translate="yes" xml:space="preserve">
          <source>The video player is usually available, but some other process is utilizing the hardware necessary to play media.</source>
          <target state="translated">비디오 플레이어는 일반적으로 사용 가능하지만 일부 다른 프로세스는 미디어를 재생하는 데 필요한 하드웨어를 사용하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9a808e51693db0366361c7aad4e5f6449d32f9f" translate="yes" xml:space="preserve">
          <source>The view</source>
          <target state="translated">보기</target>
        </trans-unit>
        <trans-unit id="3e4652b50eb959fc4f679f02ec5f754ea49b6f4c" translate="yes" xml:space="preserve">
          <source>The view accepts drops</source>
          <target state="translated">보기는 방울을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="4b6ca86eec00ab61e8e9d9eedd8075bfbb3656f8" translate="yes" xml:space="preserve">
          <source>The view accepts move (&lt;b&gt;not copy&lt;/b&gt;) operations only from itself.</source>
          <target state="translated">이 뷰는 이동 ( &lt;b&gt;복사&lt;/b&gt; 아님) 작업 만 수행합니다.</target>
        </trans-unit>
        <trans-unit id="b3e9c0b73e8dfdce47a51380fd2b2fb6571fb1be" translate="yes" xml:space="preserve">
          <source>The view classes that inherit &lt;a href=&quot;qabstractitemview&quot;&gt;QAbstractItemView&lt;/a&gt; only need to implement their own view-specific functionality, such as drawing items, returning the geometry of items, finding items, etc.</source>
          <target state="translated">&lt;a href=&quot;qabstractitemview&quot;&gt;QAbstractItemView&lt;/a&gt; 를 상속하는 뷰 클래스는 항목 그리기, 항목의 지오메트리 반환, 항목 찾기 등과 같은 고유 한보 기 특정 기능 만 구현하면됩니다.</target>
        </trans-unit>
        <trans-unit id="5150bb0712befb2ea6264f5b3dd55eb0c0946b7a" translate="yes" xml:space="preserve">
          <source>The view classes that inherit QAbstractItemView only need to implement their own view-specific functionality, such as drawing items, returning the geometry of items, finding items, etc.</source>
          <target state="translated">QAbstractItemView를 상속하는 뷰 클래스는 항목 그리기, 항목의 지오메트리 반환, 항목 찾기 등과 같은 고유 한 뷰 특정 기능 만 구현하면됩니다.</target>
        </trans-unit>
        <trans-unit id="7c563fe21bce57adc54191b3c774f68881a39335" translate="yes" xml:space="preserve">
          <source>The view currently hosting the developer tools for this view. Setting it to a new view will navigate that view to an internal URL with the developer tools, and bind it to this view.</source>
          <target state="translated">현재이보기에 대한 개발자 도구를 호스팅하는보기입니다. 새보기로 설정하면 개발자 도구를 사용하여 해당보기를 내부 URL로 이동하여이보기에 바인딩합니다.</target>
        </trans-unit>
        <trans-unit id="2e99e3c611135650ed00fdb62a83bbb10f5d3197" translate="yes" xml:space="preserve">
          <source>The view does not take ownership of</source>
          <target state="translated">보기에 대한 소유권이 없습니다</target>
        </trans-unit>
        <trans-unit id="7ab381bdd8185779c54c2b75d0074123c8fb5ca9" translate="yes" xml:space="preserve">
          <source>The view ensures that the editor's data and geometry are set correctly by calling functions that we define later for these purposes. We can create different editors depending on the model index supplied by the view. For example, if we have a column of integers and a column of strings we could return either a &lt;code&gt;QSpinBox&lt;/code&gt; or a &lt;code&gt;QLineEdit&lt;/code&gt;, depending on which column is being edited.</source>
          <target state="translated">뷰는 이러한 목적을 위해 나중에 정의한 함수를 호출하여 편집기의 데이터 및 형상이 올바르게 설정되도록합니다. 뷰에서 제공하는 모델 인덱스에 따라 다른 편집기를 만들 수 있습니다. 예를 들어, 정수 열과 문자열 열이 있으면 편집중인 열에 따라 &lt;code&gt;QSpinBox&lt;/code&gt; 또는 &lt;code&gt;QLineEdit&lt;/code&gt; 를 반환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="aa46529d403687269762843efcd50bde2cab24c5" translate="yes" xml:space="preserve">
          <source>The view has a &lt;a href=&quot;qml-qtquick-pathview#model-prop&quot;&gt;model&lt;/a&gt;, which defines the data to be displayed, and a &lt;a href=&quot;qml-qtquick-pathview#delegate-prop&quot;&gt;delegate&lt;/a&gt;, which defines how the data should be displayed. The &lt;a href=&quot;qml-qtquick-pathview#delegate-prop&quot;&gt;delegate&lt;/a&gt; is instantiated for each item on the &lt;a href=&quot;qml-qtquick-pathview#path-prop&quot;&gt;path&lt;/a&gt;. The items may be flicked to move them along the path.</source>
          <target state="translated">뷰에는 표시 할 데이터를 정의 하는 &lt;a href=&quot;qml-qtquick-pathview#model-prop&quot;&gt;model&lt;/a&gt; 과 데이터 표시 방법을 정의하는 &lt;a href=&quot;qml-qtquick-pathview#delegate-prop&quot;&gt;delegate&lt;/a&gt; 가 있습니다. &lt;a href=&quot;qml-qtquick-pathview#delegate-prop&quot;&gt;대리자&lt;/a&gt; 상의 각 항목에 대해 인스턴스화 &lt;a href=&quot;qml-qtquick-pathview#path-prop&quot;&gt;경로&lt;/a&gt; . 경로를 따라 이동하기 위해 항목을 쓸어 넘길 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="34b807f5f0bcb4d0a6af9ecff7d8ac22887dc22c" translate="yes" xml:space="preserve">
          <source>The view is first created</source>
          <target state="translated">뷰가 처음 생성됩니다</target>
        </trans-unit>
        <trans-unit id="a788d622689e00cabf54bf636fdc3f1c656a9a62" translate="yes" xml:space="preserve">
          <source>The view is shown in the normal way:</source>
          <target state="translated">보기는 일반적인 방식으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="4771791feb189995c785125a9b4d059a6b7f5261" translate="yes" xml:space="preserve">
          <source>The view itself does not provide sorting. This has to be done on the model itself. However you can provide sorting on the model, and enable sort indicators on headers.</source>
          <target state="translated">뷰 자체는 정렬을 제공하지 않습니다. 이것은 모델 자체에서 수행되어야합니다. 그러나 모델에서 정렬을 제공하고 헤더에서 정렬 표시기를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ebc21772931a3103ee4215e2ccae46f96241a65" translate="yes" xml:space="preserve">
          <source>The view obtains</source>
          <target state="translated">보기는 얻는다</target>
        </trans-unit>
        <trans-unit id="5c550133a46676767237d149d50c16381ae8500a" translate="yes" xml:space="preserve">
          <source>The view receives input events from the keyboard and mouse, and translates these to scene events (converting the coordinates used to scene coordinates where appropriate), before sending the events to the visualized scene.</source>
          <target state="translated">뷰는 키보드와 마우스로부터 입력 이벤트를 수신하여 이벤트를 시각화 된 장면으로 보내기 전에 장면 이벤트로 변환합니다 (적절한 경우 장면 좌표에 사용 된 좌표를 변환).</target>
        </trans-unit>
        <trans-unit id="5bc896763fcb258005703aa85b1daf792e83a0c3" translate="yes" xml:space="preserve">
          <source>The view renders the contents of a model, accessing data via the model's interface. When the user tries to edit an item, the view uses a default delegate to provide an editor widget.</source>
          <target state="translated">뷰는 모델의 인터페이스를 통해 데이터에 액세스하여 모델의 내용을 렌더링합니다. 사용자가 항목을 편집하려고하면보기는 기본 대리자를 사용하여 편집기 위젯을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="784fca917a858eae34ddd3f658c679b8ac42a202" translate="yes" xml:space="preserve">
          <source>The view resizes with the root item in the QML.</source>
          <target state="translated">QML의 루트 항목으로보기 크기가 조정됩니다.</target>
        </trans-unit>
        <trans-unit id="c7c26fcc67585f8defa024bd3830b8da434950f6" translate="yes" xml:space="preserve">
          <source>The view should use the delegate to open an editor on the next item in the view.</source>
          <target state="translated">뷰는 델리게이트를 사용하여 뷰의 다음 항목에서 편집기를 열어야합니다.</target>
        </trans-unit>
        <trans-unit id="2cb0a4fdd1d04869345416b5bfba2dd19b8a1be9" translate="yes" xml:space="preserve">
          <source>The view should use the delegate to open an editor on the previous item in the view.</source>
          <target state="translated">뷰는 델리게이트를 사용하여 뷰의 이전 항목에서 편집기를 열어야합니다.</target>
        </trans-unit>
        <trans-unit id="ac159f51acaa3ac70171a432ec46a905be4258fd" translate="yes" xml:space="preserve">
          <source>The view supports both dragging and dropping</source>
          <target state="translated">보기는 끌어서 놓기를 모두 지원합니다</target>
        </trans-unit>
        <trans-unit id="99ed4e96cb372b7ae83c63b550b854bc3b55dd0d" translate="yes" xml:space="preserve">
          <source>The view supports dragging of its own items</source>
          <target state="translated">보기는 자체 항목 드래그를 지원합니다</target>
        </trans-unit>
        <trans-unit id="b04328e0c4633e98f265a0d41883d13c50fffe64" translate="yes" xml:space="preserve">
          <source>The view takes ownership over the given</source>
          <target state="translated">뷰가 주어진 소유권을 차지합니다</target>
        </trans-unit>
        <trans-unit id="2094c2fd33a80acfd006c6548a588e4c26e27258" translate="yes" xml:space="preserve">
          <source>The view this view is currently inspecting, if any. Setting it will navigate to an internal URL with the developer tools of the view set.</source>
          <target state="translated">이 뷰가 현재 검사중인 뷰입니다 (있는 경우). 이를 설정하면보기 세트의 개발자 도구를 사용하여 내부 URL로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="bbbcc6fc42ab715ef0a69bcca020162eec381406" translate="yes" xml:space="preserve">
          <source>The view will automatically resize the root item to the size of the view.</source>
          <target state="translated">보기는 루트 항목의 크기를보기 크기로 자동 조정합니다.</target>
        </trans-unit>
        <trans-unit id="eac9318b036cab792126c27e23ad2a4255f6d217" translate="yes" xml:space="preserve">
          <source>The view will create a new delegate for each item in the model. Note that the delegate is able to access the model's &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;portrait&lt;/code&gt; data directly.</source>
          <target state="translated">뷰는 모델의 각 항목에 대해 새 대리자를 만듭니다. 대리인은 모델의 &lt;code&gt;name&lt;/code&gt; 과 &lt;code&gt;portrait&lt;/code&gt; 데이터에 직접 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a46e02f2188efdccade00d08b77492e2a749dc89" translate="yes" xml:space="preserve">
          <source>The view will scroll the contents one item at a time.</source>
          <target state="translated">보기는 한 번에 한 항목 씩 내용을 스크롤합니다.</target>
        </trans-unit>
        <trans-unit id="59139a4c2b442b6dac0b55d18952e556b2836680" translate="yes" xml:space="preserve">
          <source>The view will scroll the contents one pixel at a time.</source>
          <target state="translated">보기는 한 번에 한 픽셀 씩 내용을 스크롤합니다.</target>
        </trans-unit>
        <trans-unit id="596dffef8fb1ec4d84c3139c8371656d1e5237db" translate="yes" xml:space="preserve">
          <source>The view will update itself autmiatically whenever the active stack of the group changes.</source>
          <target state="translated">그룹의 활성 스택이 변경 될 때마다보기가 자동으로 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="525d3302390d245e63c31564c09c183f1944add6" translate="yes" xml:space="preserve">
          <source>The view will update itself automatically whenever the active stack of the group changes.</source>
          <target state="translated">보기는 그룹의 활성 스택이 변경 될 때마다 자동으로 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="137bee31f681a0a6f49ec6b761b4bee1eb797981" translate="yes" xml:space="preserve">
          <source>The view's &lt;a href=&quot;qml-qtquick-gridview#model-prop&quot;&gt;model&lt;/a&gt; changes</source>
          <target state="translated">뷰의 &lt;a href=&quot;qml-qtquick-gridview#model-prop&quot;&gt;모델이&lt;/a&gt; 변경됩니다</target>
        </trans-unit>
        <trans-unit id="1174faa18f00db55c01b782e6e6edd727e024dc6" translate="yes" xml:space="preserve">
          <source>The view's &lt;a href=&quot;qml-qtquick-gridview#model-prop&quot;&gt;model&lt;/a&gt; changes in such a way that the visible delegates are completely replaced</source>
          <target state="translated">보기의 &lt;a href=&quot;qml-qtquick-gridview#model-prop&quot;&gt;모델&lt;/a&gt; 은 보이는 대리자가 완전히 교체되는 방식으로 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="5bd2ce53c92c801a667f237240eca2683d76a7c2" translate="yes" xml:space="preserve">
          <source>The view's &lt;a href=&quot;qml-qtquick-gridview#model-prop&quot;&gt;model&lt;/a&gt; is &lt;a href=&quot;https://doc.qt.io/qt-5.13/qabstractitemmodel-obsolete.html#reset&quot;&gt;reset&lt;/a&gt;, if the model is a &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; subclass</source>
          <target state="translated">모델이 &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; 서브 클래스 인 경우 뷰의 &lt;a href=&quot;qml-qtquick-gridview#model-prop&quot;&gt;모델&lt;/a&gt; 이 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qabstractitemmodel-obsolete.html#reset&quot;&gt;재설정&lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="ee0e1eee5a2acc2f7fd7006d70708873252df801" translate="yes" xml:space="preserve">
          <source>The view's &lt;a href=&quot;qml-qtquick-gridview#model-prop&quot;&gt;model&lt;/a&gt; is &lt;a href=&quot;https://doc.qt.io/qt-5.15/qabstractitemmodel-obsolete.html#reset&quot;&gt;reset&lt;/a&gt;, if the model is a &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; subclass</source>
          <target state="translated">모델이 &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; 하위 클래스 인 경우 뷰의 &lt;a href=&quot;qml-qtquick-gridview#model-prop&quot;&gt;모델&lt;/a&gt; 은 &lt;a href=&quot;https://doc.qt.io/qt-5.15/qabstractitemmodel-obsolete.html#reset&quot;&gt;reset&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="434d07ec7327411fc429aee995b80dc4562c83ef" translate="yes" xml:space="preserve">
          <source>The view's &lt;a href=&quot;qml-qtquick-gridview#model-prop&quot;&gt;model&lt;/a&gt; is &lt;a href=&quot;qabstractitemmodel#beginResetModel&quot;&gt;reset&lt;/a&gt;, if the model is a &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; subclass</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="837c1da3fc3457452f98f9cfc6e0da2b8e3f0aee" translate="yes" xml:space="preserve">
          <source>The view's &lt;a href=&quot;qml-qtquick-listview#model-prop&quot;&gt;model&lt;/a&gt; changes</source>
          <target state="translated">뷰의 &lt;a href=&quot;qml-qtquick-listview#model-prop&quot;&gt;모델이&lt;/a&gt; 변경됩니다</target>
        </trans-unit>
        <trans-unit id="06f7c9ead18efcbebc44b3df50ff0e9aa9173333" translate="yes" xml:space="preserve">
          <source>The view's &lt;a href=&quot;qml-qtquick-listview#model-prop&quot;&gt;model&lt;/a&gt; changes in such a way that the visible delegates are completely replaced</source>
          <target state="translated">보기의 &lt;a href=&quot;qml-qtquick-listview#model-prop&quot;&gt;모델&lt;/a&gt; 은 보이는 대리자가 완전히 교체되는 방식으로 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="fce7d7539cf59ea28781f52a22bff9ad35259d39" translate="yes" xml:space="preserve">
          <source>The view's &lt;a href=&quot;qml-qtquick-listview#model-prop&quot;&gt;model&lt;/a&gt; is &lt;a href=&quot;https://doc.qt.io/qt-5.13/qabstractitemmodel-obsolete.html#reset&quot;&gt;reset&lt;/a&gt;, if the model is a &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; subclass</source>
          <target state="translated">모델이 &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; 서브 클래스 인 경우 뷰의 &lt;a href=&quot;qml-qtquick-listview#model-prop&quot;&gt;모델&lt;/a&gt; 이 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qabstractitemmodel-obsolete.html#reset&quot;&gt;재설정&lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="ea48f2ed2c7f9a7d32151fccbd3cf024d40313e7" translate="yes" xml:space="preserve">
          <source>The view's &lt;a href=&quot;qml-qtquick-listview#model-prop&quot;&gt;model&lt;/a&gt; is &lt;a href=&quot;https://doc.qt.io/qt-5.15/qabstractitemmodel-obsolete.html#reset&quot;&gt;reset&lt;/a&gt;, if the model is a &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; subclass</source>
          <target state="translated">모델이 &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; 하위 클래스 인 경우 뷰의 &lt;a href=&quot;qml-qtquick-listview#model-prop&quot;&gt;모델&lt;/a&gt; 은 &lt;a href=&quot;https://doc.qt.io/qt-5.15/qabstractitemmodel-obsolete.html#reset&quot;&gt;reset&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="20f7a09c77ca85cc358288c47aa39371f1e8bf23" translate="yes" xml:space="preserve">
          <source>The view's &lt;a href=&quot;qml-qtquick-listview#model-prop&quot;&gt;model&lt;/a&gt; is &lt;a href=&quot;qabstractitemmodel#beginResetModel&quot;&gt;reset&lt;/a&gt;, if the model is a &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; subclass</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6b466ee941ed0dcee0f47bd37b2541a24f9fb48" translate="yes" xml:space="preserve">
          <source>The view's root index can be used to control how much of a hierarchical model is displayed. &lt;a href=&quot;qfilesystemmodel&quot;&gt;QFileSystemModel&lt;/a&gt; provides a convenience function that returns a suitable model index for a path to a directory within the model.</source>
          <target state="translated">뷰의 루트 인덱스를 사용하여 얼마나 많은 계층 적 모델이 표시되는지 제어 할 수 있습니다. &lt;a href=&quot;qfilesystemmodel&quot;&gt;QFileSystemModel&lt;/a&gt; 은 모델 내의 디렉토리 경로에 적합한 모델 색인을 리턴하는 편리한 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="5f8ae88c1102fcdd753ecb00ff93d06998e59fec" translate="yes" xml:space="preserve">
          <source>The view's root index can be used to control how much of a hierarchical model is displayed. QFileSystemModel provides a convenience function that returns a suitable model index for a path to a directory within the model.</source>
          <target state="translated">뷰의 루트 인덱스를 사용하여 표시되는 계층 적 모델의 양을 제어 할 수 있습니다. QFileSystemModel은 모델 내의 디렉토리 경로에 적합한 모델 색인을 반환하는 편리한 함수를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="eceb3d5ebf7b008eb2587eb008056f238f9912ff" translate="yes" xml:space="preserve">
          <source>The viewfinder is not active in the loaded state.</source>
          <target state="translated">로드 상태에서 뷰 파인더가 활성화되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="44f8276f7ec827d668f89f4604c017783370d991" translate="yes" xml:space="preserve">
          <source>The viewfinder stream was started (even if not visible)</source>
          <target state="translated">뷰 파인더 스트림이 시작되었습니다 (표시되지 않더라도)</target>
        </trans-unit>
        <trans-unit id="18f22145210ca375319f5007f6b7dd6a7312c3ec" translate="yes" xml:space="preserve">
          <source>The viewfinder stream was stopped</source>
          <target state="translated">뷰 파인더 스트림이 중지되었습니다</target>
        </trans-unit>
        <trans-unit id="d3307fbe1ed5e97409157e65ddff4805fb8c1a9a" translate="yes" xml:space="preserve">
          <source>The viewport determines the current &quot;window&quot; on the &lt;a href=&quot;qml-qtquick-controls-scrollview#contentItem-prop&quot;&gt;contentItem&lt;/a&gt;. In other words, it clips it and the size of the viewport tells you how much of the content area is visible.</source>
          <target state="translated">뷰포트는 &lt;a href=&quot;qml-qtquick-controls-scrollview#contentItem-prop&quot;&gt;contentItem&lt;/a&gt; 의 현재 &quot;창&quot;을 결정합니다 . 다시 말해, 클립을 잘라 내고 뷰포트의 크기는 내용 영역이 얼마나 보이는지를 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="31cccc805c23a3b0f4b718568b4ea65ad317b00d" translate="yes" xml:space="preserve">
          <source>The viewport in which this event originated. A null value means the event originated from a frame graph branch without a &lt;a href=&quot;qt3drender-qviewport&quot;&gt;QViewport&lt;/a&gt;. If a frame graph branch has a Viewport inside a Viewport the property will contain the leaf viewport.</source>
          <target state="translated">이 이벤트가 시작된 뷰포트입니다. null 값은 &lt;a href=&quot;qt3drender-qviewport&quot;&gt;QViewport&lt;/a&gt; 없이 프레임 그래프 분기에서 발생한 이벤트를 의미합니다 . 프레임 그래프 분기에 뷰포트 내부에 뷰포트가있는 경우 속성에는 리프 뷰포트가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="160eb51ff0b20b1a7c7656cb14f9e1787071fc9b" translate="yes" xml:space="preserve">
          <source>The viewport in which this event originated. A null value means the event originated from a frame graph branch without a Viewport. If a frame graph branch has a Viewport inside a Viewport the property will contain the leaf viewport.</source>
          <target state="translated">이 이벤트가 시작된 뷰포트입니다. null 값은 뷰포트가없는 프레임 그래프 분기에서 발생한 이벤트를 의미합니다. 프레임 그래프 분기에 뷰포트 내부에 뷰포트가있는 경우 속성에는 리프 뷰포트가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="1d635bc137021deefd31fef4895f9252e0821fd8" translate="yes" xml:space="preserve">
          <source>The viewport is the region of a video frame that is actually displayed.</source>
          <target state="translated">뷰포트는 실제로 표시되는 비디오 프레임의 영역입니다.</target>
        </trans-unit>
        <trans-unit id="e13f59a65f222e8b6f065f7598955c17519b5eb9" translate="yes" xml:space="preserve">
          <source>The viewport rectangle is part of the view transformation. The viewport specifies the device coordinate system. Its sister, the &lt;a href=&quot;qpainter#window&quot;&gt;window&lt;/a&gt;(), specifies the logical coordinate system.</source>
          <target state="translated">뷰포트 사각형은 뷰 변환의 일부입니다. 뷰포트는 장치 좌표계를 지정합니다. 자매 ( &lt;a href=&quot;qpainter#window&quot;&gt;창&lt;/a&gt; )는 논리 좌표계를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="fada9cfa9d80019b62d09a83976ab06d4c7cc11a" translate="yes" xml:space="preserve">
          <source>The viewport, &quot;window&quot; and transformation matrix determine how logical &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; coordinates map to the paint device's physical coordinates. By default the world transformation matrix is the identity matrix, and the &quot;window&quot; and viewport settings are equivalent to the paint device's settings, i.e. the world, &quot;window&quot; and device coordinate systems are equivalent, but as we have seen, the systems can be manipulated using transformation operations and window-viewport conversion. The illustration above describes the process.</source>
          <target state="translated">뷰포트, &quot;창&quot;및 변환 매트릭스는 논리적 &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; 좌표가 페인트 장치의 물리적 좌표에 매핑되는 방식을 결정합니다 . 기본적으로 월드 변환 매트릭스는 항등 매트릭스이며 &quot;창&quot;및 뷰포트 설정은 페인트 장치의 설정과 동일합니다. 즉, 세계, &quot;창&quot;및 장치 좌표계는 동일하지만 시스템에서 볼 수 있듯이 변환 작업 및 창 뷰포트 변환을 사용하여 조작 할 수 있습니다. 위의 그림은 프로세스를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="281c7c2fbe729e937caa911f675f49d82132f573" translate="yes" xml:space="preserve">
          <source>The views are constructed in the same way as other widgets. Setting up a view to display the items in the model is simply a matter of calling its &lt;a href=&quot;qabstractitemview#setModel&quot;&gt;setModel()&lt;/a&gt; function with the directory model as the argument. We filter the data supplied by the model by calling the &lt;a href=&quot;qabstractitemview#setRootIndex&quot;&gt;setRootIndex()&lt;/a&gt; function on each view, passing a suitable</source>
          <target state="translated">뷰는 다른 위젯과 동일한 방식으로 구성됩니다. 모델에서 항목을 표시하도록보기를 설정하는 것은 디렉토리 모델을 인수로 사용하여 &lt;a href=&quot;qabstractitemview#setModel&quot;&gt;setModel ()&lt;/a&gt; 함수를 호출하는 것 입니다. 각 뷰 에서 &lt;a href=&quot;qabstractitemview#setRootIndex&quot;&gt;setRootIndex ()&lt;/a&gt; 함수를 호출하여 모델이 제공 한 데이터를 필터링하고 적절한</target>
        </trans-unit>
        <trans-unit id="deaa84dac0321441f77f5999a5a2284a0febefa4" translate="yes" xml:space="preserve">
          <source>The views handle dragging and flicking of their content, however they do not handle touch interaction with the individual delegates. In order for the delegates to react to touch input, e.g. to set the &lt;code&gt;currentIndex&lt;/code&gt;, a &lt;a href=&quot;qml-qtquick-mousearea&quot;&gt;MouseArea&lt;/a&gt; with the appropriate touch handling logic must be provided by the delegate.</source>
          <target state="translated">보기는 컨텐츠의 끌어서 놓기를 처리하지만 개별 대리자와의 터치 상호 작용은 처리하지 않습니다. 델리게이트가 터치 입력에 반응하여 (예 : &lt;code&gt;currentIndex&lt;/code&gt; 설정) &lt;a href=&quot;qml-qtquick-mousearea&quot;&gt;델리게이트&lt;/a&gt; 는 적절한 터치 처리 로직이 있는 MouseArea 를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="81587526da9f79bad0c9a66a553b186bd541f48d" translate="yes" xml:space="preserve">
          <source>The virtual &lt;a href=&quot;qobject#timerEvent&quot;&gt;timerEvent&lt;/a&gt;() function is called with the &lt;a href=&quot;qtimerevent&quot;&gt;QTimerEvent&lt;/a&gt; event parameter class when a timer event occurs. Reimplement this function to get timer events.</source>
          <target state="translated">타이머 이벤트가 발생하면 &lt;a href=&quot;qtimerevent&quot;&gt;QTimerEvent&lt;/a&gt; 이벤트 매개 변수 클래스 와 함께 virtual &lt;a href=&quot;qobject#timerEvent&quot;&gt;timerEvent&lt;/a&gt; () 함수가 호출 됩니다. 타이머 이벤트를 얻기 위해이 기능을 다시 구현하십시오.</target>
        </trans-unit>
        <trans-unit id="829980dc63cb2776b2bfb230d649c0d2935f7803" translate="yes" xml:space="preserve">
          <source>The virtual &lt;a href=&quot;qsgnode#isSubtreeBlocked&quot;&gt;isSubtreeBlocked&lt;/a&gt;() function can be used to disable a subtree all together. Nodes in a blocked subtree will not be preprocessed() and not rendered.</source>
          <target state="translated">가상 &lt;a href=&quot;qsgnode#isSubtreeBlocked&quot;&gt;isSubtreeBlocked&lt;/a&gt; () 함수를 사용하여 하위 트리를 모두 비활성화 할 수 있습니다. 차단 된 하위 트리의 노드는 사전 처리되지 않으며 렌더링되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="52a000bd68ab8616c95c4d09fd3c9e9df4c1cb97" translate="yes" xml:space="preserve">
          <source>The virtual &lt;a href=&quot;qwidget#enterEvent&quot;&gt;QWidget::enterEvent&lt;/a&gt;() handler now receives a &lt;a href=&quot;qenterevent&quot;&gt;QEnterEvent&lt;/a&gt;* parameter which has information about the pointer position, rather than a plain &lt;a href=&quot;qevent&quot;&gt;QEvent&lt;/a&gt;*.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ab4bc4111e61a1964e9f43364210a7941443b29" translate="yes" xml:space="preserve">
          <source>The virtual folder tag is mandatory and the folder name must not contain any slashes (/).</source>
          <target state="translated">가상 폴더 태그는 필수이며 폴더 이름에는 슬래시 (/)가 없어야합니다.</target>
        </trans-unit>
        <trans-unit id="105806b0bf4c1e0260eab5284cfa40fd739e9c87" translate="yes" xml:space="preserve">
          <source>The virtual function is called before each invocation of &lt;a href=&quot;qopenglwindow#paintGL&quot;&gt;paintGL&lt;/a&gt;().</source>
          <target state="translated">가상 함수는 &lt;a href=&quot;qopenglwindow#paintGL&quot;&gt;paintGL&lt;/a&gt; ()을 호출하기 전에 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="401e92102e332132e118b85cc2295f0b3e2ba059" translate="yes" xml:space="preserve">
          <source>The virtual keyboard layouts system supports built-in layouts as well as custom layouts. The built-in layouts are embedded as &lt;a href=&quot;resources&quot;&gt;Qt Resources&lt;/a&gt; into the plugin binary. Custom layouts are located in the file system, so that they can be installed without recompiling the virtual keyboard itself, or they can be located in a resource file.</source>
          <target state="translated">가상 키보드 레이아웃 시스템은 사용자 정의 레이아웃뿐만 아니라 내장 레이아웃을 지원합니다. 내장 레이아웃은 플러그인 바이너리에 &lt;a href=&quot;resources&quot;&gt;Qt 리소스&lt;/a&gt; 로 내장되어 있습니다. 사용자 정의 레이아웃은 파일 시스템에 위치하므로 가상 키보드 자체를 다시 컴파일하지 않고 설치하거나 리소스 파일에 배치 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="95e57a21832d3c167db63ec877f7e57f3e8a8d8d" translate="yes" xml:space="preserve">
          <source>The virtual keyboard searches for the keyboard layouts (per language) from a specific path</source>
          <target state="translated">가상 키보드는 특정 경로에서 언어 별 키보드 레이아웃을 검색합니다.</target>
        </trans-unit>
        <trans-unit id="77c61b208f9bf5fba9e10cb926970edccf65f481" translate="yes" xml:space="preserve">
          <source>The virtual keyboard styling system supports built-in styles as well as custom styles. The built-in styles are embedded as Qt Resources into the plugin binary and the custom styles are located in the file system and can be installed without recompiling the virtual keyboard itself.</source>
          <target state="translated">가상 키보드 스타일링 시스템은 사용자 정의 스타일뿐만 아니라 내장 스타일도 지원합니다. 내장 스타일은 플러그인 바이너리에 Qt 리소스로 내장되어 있으며 사용자 정의 스타일은 파일 시스템에 있으며 가상 키보드 자체를 다시 컴파일하지 않고도 설치할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c849e83a44314453508d43d4234edb1e511a277" translate="yes" xml:space="preserve">
          <source>The virtual loopback interface, which is assigned the loopback IP addresses (127.0.0.1, ::1).</source>
          <target state="translated">루프백 IP 주소 (127.0.0.1, :: 1)가 할당 된 가상 루프백 인터페이스</target>
        </trans-unit>
        <trans-unit id="e5c669da3a8d884ffbf84d43149b3aec64a71a16" translate="yes" xml:space="preserve">
          <source>The virtual siblings are the screen instances sharing the same virtual desktop. They share a common coordinate system, and windows can freely be moved or positioned across them without having to be re-created.</source>
          <target state="translated">가상 형제는 동일한 가상 데스크톱을 공유하는 화면 인스턴스입니다. 그것들은 공통 좌표계를 공유하며, 창을 다시 만들지 않고도 자유롭게 창을 이동하거나 배치 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6eee69b4eca2dc43cbe489f23c23a97cc25446b8" translate="yes" xml:space="preserve">
          <source>The virtualkeyboard module must be linked against the plugin:</source>
          <target state="translated">virtualkeyboard 모듈은 플러그인과 연결되어 있어야합니다 :</target>
        </trans-unit>
        <trans-unit id="1fa04d17edce3190f692947deb9f97b631824535" translate="yes" xml:space="preserve">
          <source>The visibility affects both the legend marker label and the icon.</source>
          <target state="translated">가시성은 범례 마커 레이블과 아이콘 모두에 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="8d05de1a3cc34c2b339f4f60921f328bfd1ca107" translate="yes" xml:space="preserve">
          <source>The visibility of axis labels.</source>
          <target state="translated">축 레이블의 가시성.</target>
        </trans-unit>
        <trans-unit id="78310c1f66243a275382e073b2d558d76bc4438f" translate="yes" xml:space="preserve">
          <source>The visibility of data point labels. This property is &lt;code&gt;false&lt;/code&gt; by default.</source>
          <target state="translated">데이터 포인트 레이블의 가시성. 이 속성은 기본적으로 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b331b08cf39fdace3031cd6fcf4d2e829c4a03e8" translate="yes" xml:space="preserve">
          <source>The visibility of the axis line.</source>
          <target state="translated">축선의 가시성.</target>
        </trans-unit>
        <trans-unit id="1216608df441f8d77a828c7f29862fba470ad699" translate="yes" xml:space="preserve">
          <source>The visibility of the axis shades.</source>
          <target state="translated">축 음영의 가시성.</target>
        </trans-unit>
        <trans-unit id="7e2c2ac849ea1d6d30d5dc0d69deff9688d9d493" translate="yes" xml:space="preserve">
          <source>The visibility of the axis title. By default, the value is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">축 제목의 가시성 기본적으로 값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="818c0f60e8c2bbbd83fc4f42c8d7313272d6f537" translate="yes" xml:space="preserve">
          <source>The visibility of the axis.</source>
          <target state="translated">축의 가시성.</target>
        </trans-unit>
        <trans-unit id="bdb90ef7bbdd8c8a27a450d161929656d9c306e8" translate="yes" xml:space="preserve">
          <source>The visibility of the box outline.</source>
          <target state="translated">상자 윤곽선의 가시성.</target>
        </trans-unit>
        <trans-unit id="147f229fba54c0e9e5613a5e8d31da991c7714b6" translate="yes" xml:space="preserve">
          <source>The visibility of the candlestick body outlines.</source>
          <target state="translated">촛대 본체의 가시성.</target>
        </trans-unit>
        <trans-unit id="ae2987ca345d83a02d33e9082f9b5cdda7291b58" translate="yes" xml:space="preserve">
          <source>The visibility of the caps.</source>
          <target state="translated">뚜껑의 가시성.</target>
        </trans-unit>
        <trans-unit id="2d616af8cec67648d22f0a9b54a3a705be16726a" translate="yes" xml:space="preserve">
          <source>The visibility of the category is unspecified. If saving a category, the plugin will automatically set a default visibility to the category saved in the backend. This default is dependent on the plugin implementation.</source>
          <target state="translated">카테고리의 가시성은 지정되지 않았습니다. 카테고리를 저장하면 플러그인은 백엔드에 저장된 카테고리에 대한 기본 가시성을 자동으로 설정합니다. 이 기본값은 플러그인 구현에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="a3e7c03bf8e3eb8272ea7d730e6485dd6ce41279" translate="yes" xml:space="preserve">
          <source>The visibility of the category.</source>
          <target state="translated">카테고리의 가시성.</target>
        </trans-unit>
        <trans-unit id="39979083a6af4a6749c1c49453841da88f840a0b" translate="yes" xml:space="preserve">
          <source>The visibility of the grid lines.</source>
          <target state="translated">격자 선의 가시성.</target>
        </trans-unit>
        <trans-unit id="4ae9bf9ee5de683c4a229df12eb0922777de5e39" translate="yes" xml:space="preserve">
          <source>The visibility of the group affects the visibility of each item in the group, except that explicitly hidden items are not visible even if the group is visible.</source>
          <target state="translated">그룹의 표시 여부는 그룹이 표시 되어도 명시 적으로 숨겨진 항목이 표시되지 않는 것을 제외하고 그룹의 각 항목 표시에 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="15257f89d29c575c71b794c7eb0bb2bb931d5988" translate="yes" xml:space="preserve">
          <source>The visibility of the item. Defaults to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">아이템의 가시성. 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a11b415f818e0cecda0b2ec02bb0f179f336fec6" translate="yes" xml:space="preserve">
          <source>The visibility of the labels in a bar series.</source>
          <target state="translated">바 시리즈에서 레이블의 가시성.</target>
        </trans-unit>
        <trans-unit id="8b621f1ba91aed8320535efac19441033751f86f" translate="yes" xml:space="preserve">
          <source>The visibility of the minor grid lines. Applies only to axes that support minor grid lines.</source>
          <target state="translated">보조 그리드 선의 가시성 작은 그리드 선을 지원하는 축에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="fa15b4f6a1792d77df895436db49ad08bc9c5179" translate="yes" xml:space="preserve">
          <source>The visibility of the place is unspecified, the default visibility of the &lt;a href=&quot;location-places-qml#plugin&quot;&gt;Plugin&lt;/a&gt; will be used.</source>
          <target state="translated">장소의 공개 설정이 지정되어 있지 않은 경우 &lt;a href=&quot;location-places-qml#plugin&quot;&gt;플러그인&lt;/a&gt; 의 기본 공개 설정 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="cb066ca39a51e7be118883421092d2f4e7daf2e1" translate="yes" xml:space="preserve">
          <source>The visibility of the slice label. By default, the label is not visible.</source>
          <target state="translated">슬라이스 레이블의 가시성. 기본적으로 레이블은 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="01a7780c77d645751f08683e279835abefb275d2" translate="yes" xml:space="preserve">
          <source>The visibility of the tab bar</source>
          <target state="translated">탭 막대의 가시성</target>
        </trans-unit>
        <trans-unit id="671bc42b0e7cd4bd0ac07503ebaef5c92a15a5be" translate="yes" xml:space="preserve">
          <source>The visibility of the tab frame around contents</source>
          <target state="translated">내용 주위의 탭 프레임의 가시성</target>
        </trans-unit>
        <trans-unit id="82e04417239f15ce1b0e0670e1dcb9025768fa83" translate="yes" xml:space="preserve">
          <source>The visibility scope can be one of:</source>
          <target state="translated">가시성 범위는 다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5079b8570a30823c81b082d86d98e2033dcdebb6" translate="yes" xml:space="preserve">
          <source>The visible status of the column.</source>
          <target state="translated">열의 표시 상태입니다.</target>
        </trans-unit>
        <trans-unit id="df0f0138b1de1eb96fd51c9b540dc8a18cf1dd97" translate="yes" xml:space="preserve">
          <source>The visual appearance of &lt;a href=&quot;qml-qt-labs-calendar-dayofweekrow&quot;&gt;DayOfWeekRow&lt;/a&gt; can be changed by implementing a &lt;a href=&quot;qml-qt-labs-calendar-dayofweekrow#delegate-prop&quot;&gt;custom delegate&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qml-qt-labs-calendar-dayofweekrow&quot;&gt;DayOfWeekRow&lt;/a&gt; 의 시각적 모양은 &lt;a href=&quot;qml-qt-labs-calendar-dayofweekrow#delegate-prop&quot;&gt;사용자 지정 대리자&lt;/a&gt; 를 구현하여 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1aeeb4284eb60ff29ca68d54056e7adc453ed826" translate="yes" xml:space="preserve">
          <source>The visual appearance of &lt;a href=&quot;qml-qt-labs-calendar-monthgrid&quot;&gt;MonthGrid&lt;/a&gt; can be changed by implementing a &lt;a href=&quot;qml-qt-labs-calendar-monthgrid#delegate-prop&quot;&gt;custom delegate&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qml-qt-labs-calendar-monthgrid#delegate-prop&quot;&gt;사용자 정의 대리자&lt;/a&gt; 를 구현하여 &lt;a href=&quot;qml-qt-labs-calendar-monthgrid&quot;&gt;MonthGrid&lt;/a&gt; 의 시각적 모양을 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="882c40e4c85fb21b339cc5a84ccf860c2b5fc991" translate="yes" xml:space="preserve">
          <source>The visual appearance of &lt;a href=&quot;qml-qt-labs-calendar-weeknumbercolumn&quot;&gt;WeekNumberColumn&lt;/a&gt; can be changed by implementing a &lt;a href=&quot;qml-qt-labs-calendar-weeknumbercolumn#delegate-prop&quot;&gt;custom delegate&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qml-qt-labs-calendar-weeknumbercolumn&quot;&gt;WeekNumberColumn&lt;/a&gt; 의 시각적 모양은 &lt;a href=&quot;qml-qt-labs-calendar-weeknumbercolumn#delegate-prop&quot;&gt;사용자 지정 대리자&lt;/a&gt; 를 구현하여 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b0239ee8e281ef7ada75ef4fdd82ead567929a4d" translate="yes" xml:space="preserve">
          <source>The visual appearance of DayOfWeekRow can be changed by implementing a &lt;a href=&quot;qml-qt-labs-calendar-dayofweekrow#delegate-prop&quot;&gt;custom delegate&lt;/a&gt;.</source>
          <target state="translated">DayOfWeekRow의 시각적 모양은 &lt;a href=&quot;qml-qt-labs-calendar-dayofweekrow#delegate-prop&quot;&gt;사용자 지정 대리자&lt;/a&gt; 를 구현하여 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0b92ea287cef472ab73557f0c7be80243dacba8b" translate="yes" xml:space="preserve">
          <source>The visual appearance of MonthGrid can be changed by implementing a &lt;a href=&quot;qml-qt-labs-calendar-monthgrid#delegate-prop&quot;&gt;custom delegate&lt;/a&gt;.</source>
          <target state="translated">MonthGrid의 시각적 모양은 &lt;a href=&quot;qml-qt-labs-calendar-monthgrid#delegate-prop&quot;&gt;사용자 지정 대리자&lt;/a&gt; 를 구현하여 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="314c87082283fbbd4a992dd43abfdc1c02b32ea6" translate="yes" xml:space="preserve">
          <source>The visual appearance of WeekNumberColumn can be changed by implementing a &lt;a href=&quot;qml-qt-labs-calendar-weeknumbercolumn#delegate-prop&quot;&gt;custom delegate&lt;/a&gt;.</source>
          <target state="translated">WeekNumberColumn의 시각적 모양은 &lt;a href=&quot;qml-qt-labs-calendar-weeknumbercolumn#delegate-prop&quot;&gt;사용자 지정 대리자&lt;/a&gt; 를 구현하여 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="80e88e8c3e3b677ae3474f175e3d156fc6ba4676" translate="yes" xml:space="preserve">
          <source>The visual appearance of the source has changed.</source>
          <target state="translated">소스의 시각적 모양이 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="29d2bc8f0c4377083f96335fbd03f0d80b639b18" translate="yes" xml:space="preserve">
          <source>The visual appearance of the title bar and buttons is dependent on the &lt;a href=&quot;qstyle&quot;&gt;style&lt;/a&gt; in use.</source>
          <target state="translated">제목 표시 줄과 버튼의 시각적 모양은 사용중인 &lt;a href=&quot;qstyle&quot;&gt;스타일&lt;/a&gt; 에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="67db3dc4e7f9b7d4736a9d25c9688170a6cc693d" translate="yes" xml:space="preserve">
          <source>The visual parent of an item may come under consideration in particular circumstances, as described in the sections below.</source>
          <target state="translated">아래 섹션에 설명 된 것처럼 특정 상황에서는 항목의 시각적 부모가 고려 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c8c40c2958948a37612f3b8a9e38a797e1428d95" translate="yes" xml:space="preserve">
          <source>The void* arguments to the various methods are typically created by using a &lt;a href=&quot;qtcore-changes-qt6#qvariant&quot;&gt;QVariant&lt;/a&gt; of the respective container or value type, and calling its &lt;a href=&quot;qvariant#data&quot;&gt;QVariant::data&lt;/a&gt;() or &lt;a href=&quot;qvariant#constData&quot;&gt;QVariant::constData&lt;/a&gt;() methods. However, you can also pass plain pointers to objects of the container or value type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecc7ef3b1a04a7bea7c19017ab5da2f08869e662" translate="yes" xml:space="preserve">
          <source>The volume is scaled linearly from &lt;code&gt;0.0&lt;/code&gt; (silence) to &lt;code&gt;1.0&lt;/code&gt; (full volume). Values outside this range will be clamped.</source>
          <target state="translated">볼륨은 &lt;code&gt;0.0&lt;/code&gt; (침묵)에서 &lt;code&gt;1.0&lt;/code&gt; (풀 볼륨) 까지 선형으로 조정 됩니다. 이 범위 밖의 값은 고정됩니다.</target>
        </trans-unit>
        <trans-unit id="f1c0885779c0d83f0d9b7a280d0bfcce8c6be77f" translate="yes" xml:space="preserve">
          <source>The volume is scaled linearly, ranging from &lt;code&gt;0&lt;/code&gt; (silence) to &lt;code&gt;100&lt;/code&gt; (full volume).</source>
          <target state="translated">볼륨은 &lt;code&gt;0&lt;/code&gt; (사일런스)에서 &lt;code&gt;100&lt;/code&gt; (전체 볼륨) 까지 선형으로 조정 됩니다.</target>
        </trans-unit>
        <trans-unit id="94081a0348c3406e9e99ee3b6038579e56500806" translate="yes" xml:space="preserve">
          <source>The watermark, banner, and logo pixmaps are ignored by the &lt;a href=&quot;qwizard#WizardStyle-enum&quot;&gt;MacStyle&lt;/a&gt;. If the &lt;a href=&quot;qwizard#WizardPixmap-enum&quot;&gt;BackgroundPixmap&lt;/a&gt; is set, it is used as the background for the wizard; otherwise, a default &quot;assistant&quot; image is used.</source>
          <target state="translated">워터 마크, 배너 및 로고 픽스맵은 &lt;a href=&quot;qwizard#WizardStyle-enum&quot;&gt;MacStyle에서&lt;/a&gt; 무시됩니다 . 경우 &lt;a href=&quot;qwizard#WizardPixmap-enum&quot;&gt;BackgroundPixmap가&lt;/a&gt; 설정되어, 그것은 마법사의 배경으로 사용됩니다; 그렇지 않으면 기본 &quot;보조&quot;이미지가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8267f5741ae4214246ca756d17f08c894a67ab3f" translate="yes" xml:space="preserve">
          <source>The way Qt handles this platform difference is by letting widgets move the keyboard focus when the wheel is used. With the right focus policy on each widget, applications can work idiomatically correctly on Windows, &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt;, and X11.</source>
          <target state="translated">Qt가 플랫폼 차이를 처리하는 방식은 휠을 사용할 때 위젯이 키보드 포커스를 이동하게하는 것입니다. 각 위젯에 올바른 초점 정책을 적용하면 Windows, &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; 및 X11 에서 응용 프로그램이 관용적으로 올바르게 작동 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4035bd9b0ea52f6c52c82a6a6b2f34b2b076bcc8" translate="yes" xml:space="preserve">
          <source>The way Qt handles this platform difference is by letting widgets move the keyboard focus when the wheel is used. With the right focus policy on each widget, applications can work idiomatically correctly on Windows, macOS, and X11.</source>
          <target state="translated">Qt가 이러한 플랫폼 차이를 처리하는 방법은 휠을 사용할 때 위젯이 키보드 포커스를 이동하도록하는 것입니다. 각 위젯에 대한 올바른 포커스 정책을 사용하면 애플리케이션이 Windows, macOS 및 X11에서 관용적으로 올바르게 작동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5dcad7b7677f6b4e9883a751bd1cda7572a59f86" translate="yes" xml:space="preserve">
          <source>The way collisions are detected is determined by applying</source>
          <target state="translated">충돌이 감지되는 방식은 다음을 적용하여 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="f51f41359450b0be51a0ed73198b1e99a2749dd0" translate="yes" xml:space="preserve">
          <source>The way items are selected is controlled by the widget's selection mode (&lt;a href=&quot;qabstractitemview#SelectionMode-enum&quot;&gt;QAbstractItemView::SelectionMode&lt;/a&gt;). This property controls whether the user can select one or many items and, in many-item selections, whether the selection must be a continuous range of items. The selection mode works in the same way for all of the above widgets.</source>
          <target state="translated">항목 선택 방법은 위젯의 선택 모드 ( &lt;a href=&quot;qabstractitemview#SelectionMode-enum&quot;&gt;QAbstractItemView :: SelectionMode&lt;/a&gt; )에 의해 제어됩니다 . 이 속성은 사용자가 하나 이상의 항목을 선택할 수 있는지 여부와 많은 항목 선택에서 선택이 연속적인 항목 범위 여야하는지 여부를 제어합니다. 선택 모드는 위의 모든 위젯에 대해 동일한 방식으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="5e34b7b5491ed4e7a69a9439c01a533dc1ebf3aa" translate="yes" xml:space="preserve">
          <source>The way that any given model handles dropped data depends on both its type (list, table, or tree) and the way its contents is likely to be presented to the user. Generally, the approach taken to accommodate dropped data should be the one that most suits the model's underlying data store.</source>
          <target state="translated">주어진 모델이 삭제 된 데이터를 처리하는 방법은 유형 (목록, 테이블 또는 트리)과 해당 내용이 사용자에게 표시 될 수있는 방법에 따라 다릅니다. 일반적으로 삭제 된 데이터를 수용하기위한 접근 방식은 모델의 기본 데이터 저장소에 가장 적합한 방법이어야합니다.</target>
        </trans-unit>
        <trans-unit id="d5f43886911993ca61ca8f5977573fc77dab226d" translate="yes" xml:space="preserve">
          <source>The way the &lt;a href=&quot;qml-qtquick-text#text-prop&quot;&gt;text&lt;/a&gt; property should be displayed.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-text#text-prop&quot;&gt;텍스트&lt;/a&gt; 속성이 표시 되는 방식 입니다.</target>
        </trans-unit>
        <trans-unit id="3d8b38fb8193cc39a5d88d82f3308dfa958d8840" translate="yes" xml:space="preserve">
          <source>The way the &lt;a href=&quot;qml-qtquick-textedit#text-prop&quot;&gt;text&lt;/a&gt; property should be displayed.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-textedit#text-prop&quot;&gt;텍스트&lt;/a&gt; 속성이 표시 되는 방식 입니다.</target>
        </trans-unit>
        <trans-unit id="c1dc2b4d1218c972145bc381ad5cf4b720071af3" translate="yes" xml:space="preserve">
          <source>The way the search is performed is defined by the specified match</source>
          <target state="translated">검색이 수행되는 방식은 지정된 일치로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="508c878269853c4074dd681f7b63f7ba95ec90af" translate="yes" xml:space="preserve">
          <source>The way the text is rendered is independent of whether or not the format has a valid anchor defined. Use &lt;a href=&quot;qtextcharformat#setAnchorHref&quot;&gt;setAnchorHref&lt;/a&gt;(), and optionally &lt;a href=&quot;qtextcharformat#setAnchorNames&quot;&gt;setAnchorNames&lt;/a&gt;() to create a hypertext link.</source>
          <target state="translated">텍스트가 렌더링되는 방식은 형식에 유효한 앵커가 정의되어 있는지 여부와 관계가 없습니다. 하이퍼 텍스트 링크를 작성 하려면 &lt;a href=&quot;qtextcharformat#setAnchorHref&quot;&gt;setAnchorHref&lt;/a&gt; () 및 선택적으로 &lt;a href=&quot;qtextcharformat#setAnchorNames&quot;&gt;setAnchorNames&lt;/a&gt; ()를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="0232d198f38acc9630464d9b7127366a8b4e0615" translate="yes" xml:space="preserve">
          <source>The way the text property should be displayed.</source>
          <target state="translated">텍스트 속성이 표시되는 방식입니다.</target>
        </trans-unit>
        <trans-unit id="e98c13f135b86d2bff14a8689692bb20a17835a4" translate="yes" xml:space="preserve">
          <source>The waypoint metadata. This property is read only. If the waypoint is defined by the user, these can be set by using MapParameters. If the waypoint comes from the engine via signals, or as part of a read-only route query, the waypoint is intended to be read-only.</source>
          <target state="translated">웨이 포인트 메타 데이터. 이 속성은 읽기 전용입니다. 웨이 포인트가 사용자에 의해 정의되면 MapParameters를 사용하여 웨이 포인트를 설정할 수 있습니다. 웨이 포인트가 신호를 통해 또는 읽기 전용 경로 쿼리의 일부로 엔진에서 오는 경우 웨이 포인트는 읽기 전용입니다.</target>
        </trans-unit>
        <trans-unit id="4938736a05ed9ef39eb848c78246b73851d16619" translate="yes" xml:space="preserve">
          <source>The waypoint's coordinate. The default value is undefined.</source>
          <target state="translated">웨이 포인트의 좌표. 기본값은 정의되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="37c6a89089128a34785a87705d037a6ca65787b3" translate="yes" xml:space="preserve">
          <source>The waypoints should be given in order from origin to destination.</source>
          <target state="translated">경유지는 출발지에서 목적지까지 순서대로 제공되어야합니다.</target>
        </trans-unit>
        <trans-unit id="2ed85cda57fd674a6cafc9d9811187df05dbdf8e" translate="yes" xml:space="preserve">
          <source>The web channel instance used by this view. This channel is automatically using the internal &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtwebengine-module.html&quot;&gt;QtWebEngine&lt;/a&gt; transport mechanism over Chromium IPC, and exposed in the javascript context of the page it is rendering as &lt;code&gt;qt.webChannelTransport&lt;/code&gt;. This transport object is used when instantiating the JavaScript counterpart of &lt;a href=&quot;qwebchannel&quot;&gt;QWebChannel&lt;/a&gt; using the &lt;a href=&quot;qtwebchannel-javascript&quot;&gt;Qt WebChannel JavaScript API&lt;/a&gt;.</source>
          <target state="translated">이보기에서 사용되는 웹 채널 인스턴스입니다. 이 채널은 Chromium IPC를 통해 내부 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtwebengine-module.html&quot;&gt;QtWebEngine&lt;/a&gt; 전송 메커니즘을 자동으로 사용 하며 페이지의 자바 스크립트 컨텍스트에 표시되며 &lt;code&gt;qt.webChannelTransport&lt;/code&gt; 로 렌더링됩니다 . 이 전송 객체는 &lt;a href=&quot;qtwebchannel-javascript&quot;&gt;Qt WebChannel JavaScript API를&lt;/a&gt; 사용하여 &lt;a href=&quot;qwebchannel&quot;&gt;QWebChannel&lt;/a&gt; 의 JavaScript 대응 인스턴스를 인스턴스화 할 때 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="a70bb3168f7736fb362829385828a554a4f1ca77" translate="yes" xml:space="preserve">
          <source>The web channel instance used by this view. This channel is automatically using the internal &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtwebengine-module.html&quot;&gt;QtWebEngine&lt;/a&gt; transport mechanism over Chromium IPC, and exposed in the javascript context of the page it is rendering as &lt;code&gt;qt.webChannelTransport&lt;/code&gt;. This transport object is used when instantiating the JavaScript counterpart of &lt;a href=&quot;qwebchannel&quot;&gt;QWebChannel&lt;/a&gt; using the &lt;a href=&quot;qtwebchannel-javascript&quot;&gt;Qt WebChannel JavaScript API&lt;/a&gt;.</source>
          <target state="translated">이보기에서 사용하는 웹 채널 인스턴스입니다. 이 채널은 자동으로 내부 사용 &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtwebengine-module.html&quot;&gt;QtWebEngine의&lt;/a&gt; 크롬 IPC 통해 전송 메커니즘을, 그것이로 렌더링되는 페이지의 스크립트 컨텍스트 노출 &lt;code&gt;qt.webChannelTransport&lt;/code&gt; . 이 전송 객체는 &lt;a href=&quot;qtwebchannel-javascript&quot;&gt;Qt WebChannel JavaScript API를&lt;/a&gt; 사용하여 &lt;a href=&quot;qwebchannel&quot;&gt;QWebChannel&lt;/a&gt; 의 JavaScript 대응 물을 인스턴스화 할 때 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="b9bbf724625f530fc2e9ccfd0ed781a470f84d17" translate="yes" xml:space="preserve">
          <source>The web page is saved to</source>
          <target state="translated">웹 페이지가에 저장됩니다</target>
        </trans-unit>
        <trans-unit id="4e653bdf8b776cbb56112618b7f392ac51c35a0c" translate="yes" xml:space="preserve">
          <source>The week number</source>
          <target state="translated">주 번호</target>
        </trans-unit>
        <trans-unit id="1eb168913d21d540cf2e15ed5dd513e7c8a30e68" translate="yes" xml:space="preserve">
          <source>The weight can be one of:</source>
          <target state="translated">무게는 다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c726b329388d02ed216d441eefebf002b439caf0" translate="yes" xml:space="preserve">
          <source>The weight field specifies a relative weight for entries with the same priority. Entries with higher weights should be selected with a higher probability.</source>
          <target state="translated">가중치 필드는 우선 순위가 동일한 항목에 대한 상대 가중치를 지정합니다. 더 높은 가중치를 가진 항목은 더 높은 확률로 선택해야합니다.</target>
        </trans-unit>
        <trans-unit id="aedd825e6bdb5e520a07a09766ffdcdc455e966b" translate="yes" xml:space="preserve">
          <source>The weight of a font.</source>
          <target state="translated">폰트의 무게.</target>
        </trans-unit>
        <trans-unit id="bf5db6e7e6872da2c397674e28d7aefddd648bdd" translate="yes" xml:space="preserve">
          <source>The weight of the font info that has been resolved for the current font and &lt;a href=&quot;qml-qtquick-text#fontSizeMode-prop&quot;&gt;fontSizeMode&lt;/a&gt;.</source>
          <target state="translated">현재 글꼴 및 &lt;a href=&quot;qml-qtquick-text#fontSizeMode-prop&quot;&gt;fontSizeMode에&lt;/a&gt; 대해 해결 된 글꼴 정보의 가중치입니다 .</target>
        </trans-unit>
        <trans-unit id="bb9c4188af18bd0a188676b3a1d03dc14dbb82e5" translate="yes" xml:space="preserve">
          <source>The weight of the font.</source>
          <target state="translated">글꼴의 무게입니다.</target>
        </trans-unit>
        <trans-unit id="5708817eee2db1bc829b5ed92a25123861836694" translate="yes" xml:space="preserve">
          <source>The weighted list of transitions valid for this group.</source>
          <target state="translated">이 그룹에 유효한 가중치 전환 목록.</target>
        </trans-unit>
        <trans-unit id="b8a1240f062b4ac91a4c5dbadb3a984ef22f58ee" translate="yes" xml:space="preserve">
          <source>The white balance preset.</source>
          <target state="translated">화이트 밸런스 사전 설정.</target>
        </trans-unit>
        <trans-unit id="4279addfdd3f8a2a0e88efdda50c008a6e8c73a4" translate="yes" xml:space="preserve">
          <source>The white colored PointLight here is moved on the Z axis so that it is halfway between the camera and the center of the scene. Unlike &lt;a href=&quot;qml-qtquick3d-directionallight&quot;&gt;DirectionalLight&lt;/a&gt;, the rotation of the PointLight does not matter, whereas its position is significant. The diminishing intensity is visible here, especially on the rectangle mesh in the background.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71aedf1237fd44bf7b62b8e233e7ebaafea0e679" translate="yes" xml:space="preserve">
          <source>The white list is used for both connection and scan requests.</source>
          <target state="translated">화이트리스트는 연결 및 스캔 요청 모두에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c436af4bd3b8fa326a0c2c00fa865620e0fd7879" translate="yes" xml:space="preserve">
          <source>The white list is used when handling connection requests, but is ignored for scan requests.</source>
          <target state="translated">화이트리스트는 연결 요청을 처리 할 때 사용되지만 스캔 요청에는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="0ee8ccce0addf97745b12758368ebfa2460099c0" translate="yes" xml:space="preserve">
          <source>The white list is used when handling scan requests, but is ignored for connection requests.</source>
          <target state="translated">화이트리스트는 스캔 요청을 처리 할 때 사용되지만 연결 요청에는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="570fe160af8d6eabf46c4d66b72f2122b76e4493" translate="yes" xml:space="preserve">
          <source>The white point for the image. There is usually no need to adjust this. Range is &lt;code&gt;[0...1]&lt;/code&gt;. &lt;code&gt;1&lt;/code&gt; by default.</source>
          <target state="translated">이미지의 흰색 점입니다. 일반적으로이를 조정할 필요가 없습니다. 범위는 &lt;code&gt;[0...1]&lt;/code&gt; 입니다. 기본적으로 &lt;code&gt;1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="63d4a7e1718f52c2f84df6b461169c4f1c0697a7" translate="yes" xml:space="preserve">
          <source>The whitespace mode used to display normal word wrapped text in paragraphs.</source>
          <target state="translated">공백 모드는 단락에 일반 단어 줄 바꿈 텍스트를 표시하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1fa5b7ad19f18dd076d4b15b35feacba0c4eba5d" translate="yes" xml:space="preserve">
          <source>The whole application is contained within the &lt;code&gt;main()&lt;/code&gt; function:</source>
          <target state="translated">전체 응용 프로그램은 &lt;code&gt;main()&lt;/code&gt; 함수 내에 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="ab3ece82f2f99e7e36eb1f5ec2f084909d846186" translate="yes" xml:space="preserve">
          <source>The whole connection can be selected by clicking on any of its path segments. Once selected, a connection can be deleted with the &lt;b&gt;Delete&lt;/b&gt; key, ensuring that it will not be set up in the UI file.</source>
          <target state="translated">경로 세그먼트를 클릭하면 전체 연결을 선택할 수 있습니다. 일단 선택되면 &lt;b&gt;Delete&lt;/b&gt; 키를 사용하여 연결을 삭제 하여 UI 파일에 연결되지 않도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f73fbaa41cdb1036228fe26a18842a9549e718f6" translate="yes" xml:space="preserve">
          <source>The whole second, with a leading zero where applicable (00 to 59)</source>
          <target state="translated">적용 가능한 경우 앞에 0이있는 전체 초 (00 ~ 59)</target>
        </trans-unit>
        <trans-unit id="f7411d04da8569a0bb9947d208364466dfedc975" translate="yes" xml:space="preserve">
          <source>The whole second, without any leading zero (0 to 59)</source>
          <target state="translated">앞에 0이없는 전체 초 (0 ~ 59)</target>
        </trans-unit>
        <trans-unit id="5d17555fe66c3c921dfa6670421b0fec63d36d29" translate="yes" xml:space="preserve">
          <source>The widest tickmark will determine the space set aside for all tickmarks. For this reason, the &lt;code&gt;implicitWidth&lt;/code&gt; of each tickmark should be greater than or equal to that of each minor tickmark. If you need minor tickmarks to have greater widths than the major tickmarks, set the larger width in a child item of the &lt;a href=&quot;qml-qtquick-controls-styles-gaugestyle#minorTickmark-prop&quot;&gt;minorTickmark&lt;/a&gt; component.</source>
          <target state="translated">가장 큰 눈금은 모든 눈금에 따로 설정된 공간을 결정합니다. 이러한 이유로 각 눈금 의 &lt;code&gt;implicitWidth&lt;/code&gt; 너비는 각 작은 눈금의 그것보다 크거나 같아야합니다. 작은 눈금 표시가 주요 눈금 표시보다 큰 너비를 갖도록하려면 &lt;a href=&quot;qml-qtquick-controls-styles-gaugestyle#minorTickmark-prop&quot;&gt;minorTickmark&lt;/a&gt; 구성 요소 의 하위 항목에서 더 큰 너비를 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="43fb28787cc8a72bfc359faf8c4850482eb73d5e" translate="yes" xml:space="preserve">
          <source>The widget accepts input method input.</source>
          <target state="translated">위젯은 입력 방법 입력을 승인합니다.</target>
        </trans-unit>
        <trans-unit id="70655bdb4155ccfee6435a269f33c694fde5d118" translate="yes" xml:space="preserve">
          <source>The widget box contains objects in a number of different categories, all of which can be placed on the form as required. The only objects that require a little more preparation are the &lt;b&gt;Container&lt;/b&gt; widgets. These are described in further detail in the &lt;a href=&quot;designer-using-containers&quot;&gt;Using Containers in Qt Designer&lt;/a&gt; chapter.</source>
          <target state="translated">위젯 상자에는 다양한 범주의 개체가 포함되어 있으며 필요에 따라 모두 양식에 배치 할 수 있습니다. 조금 더 준비가 필요한 유일한 개체는 &lt;b&gt;컨테이너&lt;/b&gt; 위젯입니다. 이에 대해서는 &lt;a href=&quot;designer-using-containers&quot;&gt;Qt Designer에서 컨테이너 사용&lt;/a&gt; 장 에서 자세히 설명 합니다.</target>
        </trans-unit>
        <trans-unit id="37e12d9bb0bbbe994dfd9649e13297675422a410" translate="yes" xml:space="preserve">
          <source>The widget box contains objects in a number of different categories, all of which can be placed on the form as required. The only objects that require a little more preparation are the &lt;b&gt;Container&lt;/b&gt; widgets. These are described in further detail in the &lt;a href=&quot;designer-using-containers#&quot;&gt;Using Containers in Qt Designer&lt;/a&gt; chapter.</source>
          <target state="translated">위젯 상자에는 다양한 범주의 객체가 포함되어 있으며 필요에 따라 양식에 배치 할 수 있습니다. 조금 더 준비가 필요한 유일한 객체는 &lt;b&gt;컨테이너&lt;/b&gt; 위젯입니다. 이것들은 &lt;a href=&quot;designer-using-containers#&quot;&gt;Qt Designer에서 컨테이너 사용&lt;/a&gt; 장 에서 더 자세히 설명됩니다 .</target>
        </trans-unit>
        <trans-unit id="0940bbe6c53f6a61b0e5af23136f56ee92b5b517" translate="yes" xml:space="preserve">
          <source>The widget box provides a selection of standard Qt widgets, layouts, and other objects that can be used to create user interfaces on forms. Each of the categories in the widget box contain widgets with similar uses or related features.</source>
          <target state="translated">위젯 상자는 표준 Qt 위젯, 레이아웃 및 양식에서 사용자 인터페이스를 작성하는 데 사용할 수있는 기타 객체를 제공합니다. 위젯 상자의 각 범주에는 유사한 용도 또는 관련 기능이있는 위젯이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a71570c8471027c306bb3d2948a7ec7dde3879b8" translate="yes" xml:space="preserve">
          <source>The widget box provides common widgets and layouts that are used to design components. These are grouped into categories that reflect their uses or features.</source>
          <target state="translated">위젯 상자는 구성 요소를 설계하는 데 사용되는 공통 위젯 및 레이아웃을 제공합니다. 이들은 사용 또는 기능을 반영하는 범주로 그룹화됩니다.</target>
        </trans-unit>
        <trans-unit id="cb7c5b8956ec545814dc3f2dfdc7d4b36265846f" translate="yes" xml:space="preserve">
          <source>The widget can grow beyond its size hint if necessary.</source>
          <target state="translated">필요한 경우 위젯이 크기 힌트보다 커질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="efdaec705bf8e0eb55d7996b601e0aad9b00c5fd" translate="yes" xml:space="preserve">
          <source>The widget can shrink below its size hint if necessary.</source>
          <target state="translated">필요한 경우 위젯이 크기 힌트 아래로 축소 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="067cb44bcdb09ad1d86334b8df852100d5741099" translate="yes" xml:space="preserve">
          <source>The widget cannot be resized to a larger size than the maximum widget size.</source>
          <target state="translated">위젯은 최대 위젯 크기보다 큰 크기로 조정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a0539e826227f1e6ed6bdc6adb48bece1e2a49ac" translate="yes" xml:space="preserve">
          <source>The widget cannot be resized to a smaller size than the minimum widget size. The widget's size is forced to the minimum size if the current size is smaller.</source>
          <target state="translated">위젯은 최소 위젯 크기보다 작은 크기로 크기를 조정할 수 없습니다. 현재 크기가 더 작 으면 위젯 크기가 최소 크기로 강제 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="c60a9caf4004d7f2a59a548a72b576ccda8b3235" translate="yes" xml:space="preserve">
          <source>The widget features a context menu that is tailored to the element at hand, and includes actions useful in a browser. For a custom context menu, or for embedding actions in a menu or toolbar, the individual actions are available via &lt;a href=&quot;qwebengineview#pageAction&quot;&gt;pageAction&lt;/a&gt;(). The web view maintains the state of the returned actions, but allows modification of action properties such as &lt;a href=&quot;qaction#text-prop&quot;&gt;text&lt;/a&gt; or &lt;a href=&quot;qaction#icon-prop&quot;&gt;icon&lt;/a&gt;. The action semantics can also be triggered directly through &lt;a href=&quot;qwebengineview#triggerPageAction&quot;&gt;triggerPageAction&lt;/a&gt;().</source>
          <target state="translated">위젯에는 현재 요소에 맞는 컨텍스트 메뉴가 있으며 브라우저에 유용한 조치가 포함되어 있습니다. 사용자 정의 컨텍스트 메뉴 또는 메뉴 또는 도구 모음에 조치를 임베드하는 경우 &lt;a href=&quot;qwebengineview#pageAction&quot;&gt;pageAction&lt;/a&gt; ()을 통해 개별 조치를 사용할 수 있습니다 . 웹보기는 리턴 된 조치의 상태를 유지하지만 &lt;a href=&quot;qaction#text-prop&quot;&gt;text&lt;/a&gt; 또는 &lt;a href=&quot;qaction#icon-prop&quot;&gt;icon&lt;/a&gt; 과 같은 조치 특성을 수정할 수 있습니다 . 액션 시맨틱은 &lt;a href=&quot;qwebengineview#triggerPageAction&quot;&gt;triggerPageAction&lt;/a&gt; ()을 통해 직접 트리거 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="de495f13f94ef4c7738714147a2b3553951f7b70" translate="yes" xml:space="preserve">
          <source>The widget flags</source>
          <target state="translated">위젯 플래그</target>
        </trans-unit>
        <trans-unit id="fa6bccafbbd7f3fca25990750acf269795b2cbf4" translate="yes" xml:space="preserve">
          <source>The widget flags argument,</source>
          <target state="translated">위젯 플래그 인수</target>
        </trans-unit>
        <trans-unit id="d607ab4452b2134c68d2c9f50d4a5216d9a6bf07" translate="yes" xml:space="preserve">
          <source>The widget independent classes of the Undo/Redo framework have been moved into the &lt;a href=&quot;https://doc.qt.io/qt-6.0/qtgui-module.html&quot;&gt;QtGui&lt;/a&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="362754f93811977c5fffa702873e66736d7ef2b9" translate="yes" xml:space="preserve">
          <source>The widget is a window (i.e top level widget)</source>
          <target state="translated">위젯은 창입니다 (예 : 최상위 위젯)</target>
        </trans-unit>
        <trans-unit id="f2d1c0a85d9ecfe225a1d79d1c32703f865a0a57" translate="yes" xml:space="preserve">
          <source>The widget is already visible by default; you do not have to call &lt;a href=&quot;qgraphicsitem#show&quot;&gt;show&lt;/a&gt;() to display the widget.</source>
          <target state="translated">위젯은 기본적으로 이미 표시되어 있습니다. 위젯을 표시하기 위해 &lt;a href=&quot;qgraphicsitem#show&quot;&gt;show&lt;/a&gt; ()를 호출 할 필요는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="3a7fccbf0d966fb17b5067d1fe41c76ae11f01f0" translate="yes" xml:space="preserve">
          <source>The widget is displayed to the left of the text when using layout direction &lt;code&gt;Qt::LeftToRight&lt;/code&gt; or to the right when using &lt;code&gt;Qt::RightToLeft&lt;/code&gt;, respectively.</source>
          <target state="translated">레이아웃 방향 &lt;code&gt;Qt::LeftToRight&lt;/code&gt; 사용할 때는 위젯이 텍스트 왼쪽에, &lt;code&gt;Qt::RightToLeft&lt;/code&gt; 때는 각각 오른쪽에 위젯이 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="0f658c870f657a01f4d7897ce3c34c9f90cb28e0" translate="yes" xml:space="preserve">
          <source>The widget is displayed to the right of the text when using layout direction &lt;code&gt;Qt::LeftToRight&lt;/code&gt; or to the left when using &lt;code&gt;Qt::RightToLeft&lt;/code&gt;, respectively.</source>
          <target state="translated">레이아웃 방향 &lt;code&gt;Qt::LeftToRight&lt;/code&gt; 사용할 때는 위젯이 텍스트 오른쪽에, &lt;code&gt;Qt::RightToLeft&lt;/code&gt; 사용할 때는 왼쪽에 위젯이 각각 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="43612e99c94a7f719e608ac89cc611e5f9c4b6c6" translate="yes" xml:space="preserve">
          <source>The widget is initialized with the current month and year, and the currently selected date is today.</source>
          <target state="translated">위젯은 현재 월과 연도로 초기화되며 현재 선택된 날짜는 오늘입니다.</target>
        </trans-unit>
        <trans-unit id="96d5cf54f55fcc4a32dba40eed97ab733afe744f" translate="yes" xml:space="preserve">
          <source>The widget is initialized with the current month and year, but &lt;a href=&quot;qcalendarwidget&quot;&gt;QCalendarWidget&lt;/a&gt; provides several public slots to change the year and month that is shown.</source>
          <target state="translated">위젯은 현재 월과 연도로 초기화되지만 &lt;a href=&quot;qcalendarwidget&quot;&gt;QCalendarWidget&lt;/a&gt; 은 표시되는 연도와 월을 변경하기 위해 여러 개의 공개 슬롯을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="9a1a2944cfb2f7114bfc3feb35532328f7012177" translate="yes" xml:space="preserve">
          <source>The widget is initialized with the current month and year, but QCalendarWidget provides several public slots to change the year and month that is shown.</source>
          <target state="translated">위젯은 현재 월과 연도로 초기화되지만 QCalendarWidget은 표시되는 연도와 월을 변경할 수있는 여러 공개 슬롯을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="0692d4ee5436d924129fa28b270430efa324904f" translate="yes" xml:space="preserve">
          <source>The widget is located to the far left of the first permanent widget (see &lt;a href=&quot;qstatusbar#addPermanentWidget&quot;&gt;addPermanentWidget&lt;/a&gt;()) and may be obscured by temporary messages.</source>
          <target state="translated">위젯은 첫 번째 영구 위젯의 가장 왼쪽 ( &lt;a href=&quot;qstatusbar#addPermanentWidget&quot;&gt;addPermanentWidget&lt;/a&gt; () 참조 )에 있으며 임시 메시지에 의해 가려 질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="afbbc99fc96fc0244233939e6204b6ea4fad9920" translate="yes" xml:space="preserve">
          <source>The widget is not constrained.</source>
          <target state="translated">위젯이 제한되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="633057c52f31cc135357d659f3f91ed5af3acd13" translate="yes" xml:space="preserve">
          <source>The widget is passed as the last argument in case the style needs it to perform special effects (such as animated default buttons on &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt;), but it isn't mandatory.</source>
          <target state="translated">스타일에 특수 효과 (예 : &lt;a href=&quot;internationalization#macos&quot;&gt;macOS의&lt;/a&gt; 애니메이션 기본 버튼 ) 를 수행해야하는 경우 위젯이 마지막 인수로 전달 되지만 필수는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="b02126390065180668e0d5d0e747e80c2db76ceb" translate="yes" xml:space="preserve">
          <source>The widget is passed as the last argument in case the style needs it to perform special effects (such as animated default buttons on macOS), but it isn't mandatory.</source>
          <target state="translated">스타일이 특수 효과 (예 : macOS의 애니메이션 기본 버튼)를 수행하는 데 필요한 경우 위젯이 마지막 인수로 전달되지만 필수는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="9e284b91e1dfc1359694b97db9a9a363677395a1" translate="yes" xml:space="preserve">
          <source>The widget is polished.</source>
          <target state="translated">위젯이 연마되었습니다.</target>
        </trans-unit>
        <trans-unit id="d414a0a0707b078dc19ea8f51b25bd2fd49605b9" translate="yes" xml:space="preserve">
          <source>The widget is reparented away from the &lt;a href=&quot;qmenu&quot;&gt;QMenu&lt;/a&gt; to the native menu view. If you show the menu in some other place (e.g. as a popup menu), the widget will not be there.</source>
          <target state="translated">위젯은 &lt;a href=&quot;qmenu&quot;&gt;QMenu&lt;/a&gt; 에서 기본 메뉴보기로 이동합니다. 팝업 메뉴와 같은 다른 위치에 메뉴를 표시하면 위젯이 없습니다.</target>
        </trans-unit>
        <trans-unit id="616b477205f938dcd023166b3e2caf0e493874b7" translate="yes" xml:space="preserve">
          <source>The widget is the atom of the user interface: it receives mouse, keyboard and other events from the window system, and paints a representation of itself on the screen. Every widget is rectangular, and they are sorted in a Z-order. A widget is clipped by its parent and by the widgets in front of it.</source>
          <target state="translated">위젯은 사용자 인터페이스의 핵심 요소입니다. 윈도우 시스템에서 마우스, 키보드 및 기타 이벤트를 수신하고 화면에 자신의 표현을 그립니다. 모든 위젯은 직사각형이며 Z 순서로 정렬됩니다. 위젯은 부모와 그 앞에있는 위젯에 의해 잘립니다.</target>
        </trans-unit>
        <trans-unit id="f136acbdffe42fcff52dcbed7c9c54a9a088a2a6" translate="yes" xml:space="preserve">
          <source>The widget parent has changed.</source>
          <target state="translated">위젯 부모가 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="0459d8cedf1953035596404ecbaf9ef3322e9c1e" translate="yes" xml:space="preserve">
          <source>The widget parent is about to change.</source>
          <target state="translated">위젯 부모가 변경 되려고합니다.</target>
        </trans-unit>
        <trans-unit id="8f82a10e060318dccf2c19f58b283418db2f8dfc" translate="yes" xml:space="preserve">
          <source>The widget should accept the event if it has &quot;What's This?&quot; help (&lt;a href=&quot;qhelpevent&quot;&gt;QHelpEvent&lt;/a&gt;).</source>
          <target state="translated">&quot;What 's This?&quot;가있는 경우 위젯이 이벤트를 승인해야합니다. 도움말 ( &lt;a href=&quot;qhelpevent&quot;&gt;QHelpEvent&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="fd7e17c7c643051996c1245215f826fbd28d0f40" translate="yes" xml:space="preserve">
          <source>The widget should be polished.</source>
          <target state="translated">위젯을 연마해야합니다.</target>
        </trans-unit>
        <trans-unit id="d00ec8f192c57457097e4b31f32750a7fa06bbff" translate="yes" xml:space="preserve">
          <source>The widget should be queued to be repainted at a later time.</source>
          <target state="translated">위젯은 나중에 다시 칠하기 위해 대기해야합니다.</target>
        </trans-unit>
        <trans-unit id="62f9b8beac5e272fb81cc2fd2ac6a292fcf8559c" translate="yes" xml:space="preserve">
          <source>The widget should be repainted.</source>
          <target state="translated">위젯을 다시 칠해야합니다.</target>
        </trans-unit>
        <trans-unit id="b0f44faeb7c5ea449cd050484b3e2282e6a140e5" translate="yes" xml:space="preserve">
          <source>The widget should examine the list of attributes to apply to the preedit string. It has to understand at least the &lt;a href=&quot;qinputmethodevent#AttributeType-enum&quot;&gt;TextFormat&lt;/a&gt; and Cursor attributes and render them as specified.</source>
          <target state="translated">위젯은 사전 편집 문자열에 적용 할 속성 목록을 검사해야합니다. 적어도 &lt;a href=&quot;qinputmethodevent#AttributeType-enum&quot;&gt;TextFormat&lt;/a&gt; 및 Cursor 특성 을 이해하고 지정된대로 렌더링해야합니다.</target>
        </trans-unit>
        <trans-unit id="f74f043b17bfff08a5a39e6a0c9353399deae057" translate="yes" xml:space="preserve">
          <source>The widget should get as much space as possible.</source>
          <target state="translated">위젯은 가능한 한 많은 공간을 확보해야합니다.</target>
        </trans-unit>
        <trans-unit id="fab975624c83dae5562cda7f222146f453856c39" translate="yes" xml:space="preserve">
          <source>The widget should reveal &quot;What's This?&quot; help (&lt;a href=&quot;qhelpevent&quot;&gt;QHelpEvent&lt;/a&gt;).</source>
          <target state="translated">위젯에 &quot;What 's This?&quot;가 표시되어야합니다. 도움말 ( &lt;a href=&quot;qhelpevent&quot;&gt;QHelpEvent&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="04420fa91fa9cf9ae1b4c07b68f8fa73588ad5e4" translate="yes" xml:space="preserve">
          <source>The widget will be erased and receive a paint event immediately after processing the resize event. No drawing need be (or should be) done inside this handler.</source>
          <target state="translated">크기 조정 이벤트를 처리 한 직후 위젯이 지워지고 페인트 이벤트가 수신됩니다. 이 핸들러 내에서 드로잉을 수행 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="f53281f931b4676ce18b89be4d719984f1808080" translate="yes" xml:space="preserve">
          <source>The widget will get an event of type &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent::LayoutRequest&lt;/a&gt; when the layout needs to be recalculated. Reimplement &lt;a href=&quot;qwidget#event&quot;&gt;QWidget::event&lt;/a&gt;() to handle &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent::LayoutRequest&lt;/a&gt; events.</source>
          <target state="translated">위젯은 레이아웃을 다시 계산해야 할 때 &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent :: LayoutRequest&lt;/a&gt; 유형의 이벤트를 받습니다 . &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent :: LayoutRequest&lt;/a&gt; 이벤트 를 처리하기 위해 &lt;a href=&quot;qwidget#event&quot;&gt;QWidget :: event&lt;/a&gt; ()를 다시 구현하십시오 .</target>
        </trans-unit>
        <trans-unit id="58a540829c8bc0980902882b8194f2fbb8ea67f6" translate="yes" xml:space="preserve">
          <source>The widget's &lt;a href=&quot;https://doc.qt.io/qt-5.13/qdesktopwidget-obsolete.html#screenGeometry&quot;&gt;screenGeometry&lt;/a&gt;() function provides information about the geometry of the available screens with. The number of screens available is returned by &lt;a href=&quot;qdesktopwidget#screenCount-prop&quot;&gt;screenCount&lt;/a&gt;, and the &lt;a href=&quot;https://doc.qt.io/qt-5.13/qdesktopwidget-obsolete.html#screenCountChanged&quot;&gt;screenCountChanged&lt;/a&gt;() signal is emitted when screens are added or removed. The screen number that a particular point or widget is located in is returned by &lt;a href=&quot;qdesktopwidget#screenNumber&quot;&gt;screenNumber&lt;/a&gt;().</source>
          <target state="translated">위젯의 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qdesktopwidget-obsolete.html#screenGeometry&quot;&gt;screenGeometry&lt;/a&gt; () 함수는 사용 가능한 화면의 지오메트리에 대한 정보를 제공합니다. 사용 가능한 화면 수는 &lt;a href=&quot;qdesktopwidget#screenCount-prop&quot;&gt;screenCount&lt;/a&gt; 에 의해 반환되며 , 화면을 추가하거나 제거 하면 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qdesktopwidget-obsolete.html#screenCountChanged&quot;&gt;screenCountChanged&lt;/a&gt; () 신호가 발생합니다. 특정 지점이나 위젯이있는 화면 번호는 &lt;a href=&quot;qdesktopwidget#screenNumber&quot;&gt;screenNumber&lt;/a&gt; ()에 의해 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="04bf64cfa1786c29ac74cc467db737c043c7671d" translate="yes" xml:space="preserve">
          <source>The widget's &lt;a href=&quot;https://doc.qt.io/qt-5.15/qdesktopwidget-obsolete.html#screenGeometry&quot;&gt;screenGeometry&lt;/a&gt;() function provides information about the geometry of the available screens with. The number of screens available is returned by &lt;a href=&quot;https://doc.qt.io/qt-5.15/qdesktopwidget-obsolete.html#screenCount-prop&quot;&gt;screenCount&lt;/a&gt;, and the &lt;a href=&quot;https://doc.qt.io/qt-5.15/qdesktopwidget-obsolete.html#screenCountChanged&quot;&gt;screenCountChanged&lt;/a&gt;() signal is emitted when screens are added or removed. The screen number that a particular point or widget is located in is returned by &lt;a href=&quot;qdesktopwidget#screenNumber&quot;&gt;screenNumber&lt;/a&gt;().</source>
          <target state="translated">위젯의 &lt;a href=&quot;https://doc.qt.io/qt-5.15/qdesktopwidget-obsolete.html#screenGeometry&quot;&gt;screenGeometry&lt;/a&gt; () 함수는 사용 가능한 화면의 지오메트리에 대한 정보를 제공합니다. 사용 가능한 화면 수는 &lt;a href=&quot;https://doc.qt.io/qt-5.15/qdesktopwidget-obsolete.html#screenCount-prop&quot;&gt;screenCount&lt;/a&gt; 에 의해 반환되며 &lt;a href=&quot;https://doc.qt.io/qt-5.15/qdesktopwidget-obsolete.html#screenCountChanged&quot;&gt;screenCountChanged&lt;/a&gt; () 신호는 화면이 추가되거나 제거 될 때 내 보냅니다. 특정 지점 또는 위젯이있는 화면 번호는 &lt;a href=&quot;qdesktopwidget#screenNumber&quot;&gt;screenNumber&lt;/a&gt; ()에 의해 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="52a96d84ebe76f431044c41541a1bd2892fb6ed0" translate="yes" xml:space="preserve">
          <source>The widget's &lt;a href=&quot;qwidget#autoFillBackground-prop&quot;&gt;autoFillBackground&lt;/a&gt; property will be set to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">위젯의 &lt;a href=&quot;qwidget#autoFillBackground-prop&quot;&gt;autoFillBackground&lt;/a&gt; 속성이 &lt;code&gt;true&lt;/code&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="95481710623296ca5ba0987e7d3918d9651d3a2e" translate="yes" xml:space="preserve">
          <source>The widget's background rectangle, to use in conjunction with &lt;code&gt;background-position&lt;/code&gt; and &lt;code&gt;background-image&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;background-position&lt;/code&gt; 및 &lt;code&gt;background-image&lt;/code&gt; 와 함께 사용할 위젯의 배경 사각형 입니다.</target>
        </trans-unit>
        <trans-unit id="2a0c3fd04d0f041fcca9cfe43a21354366d56348" translate="yes" xml:space="preserve">
          <source>The widget's bottom margin.</source>
          <target state="translated">위젯의 아래쪽 여백</target>
        </trans-unit>
        <trans-unit id="2ab857af5807c0ee6c9200d7d84448cfc5facaf7" translate="yes" xml:space="preserve">
          <source>The widget's bottom padding.</source>
          <target state="translated">위젯의 하단 패딩.</target>
        </trans-unit>
        <trans-unit id="f2302b801537244df13efb1ec183ef60a49e7dc6" translate="yes" xml:space="preserve">
          <source>The widget's cursor has changed.</source>
          <target state="translated">위젯 커서가 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="d19f7fa9909a37bdfcc948888c7a213eab5bb220" translate="yes" xml:space="preserve">
          <source>The widget's display and the ability to copy or drag the text is affected by this setting.</source>
          <target state="translated">위젯의 표시 및 텍스트를 복사하거나 드래그하는 기능은이 설정의 영향을받습니다.</target>
        </trans-unit>
        <trans-unit id="d60aa2872fd84ab8f13ecc62fb2b6f2b2f6f65f2" translate="yes" xml:space="preserve">
          <source>The widget's dragMoveEvent() can be used to restrict drops to certain parts of the widget by only accepting the proposed drop actions when the cursor is within those areas. For example, the following code accepts any proposed drop actions when the cursor is over a child widget (&lt;code&gt;dropFrame&lt;/code&gt;):</source>
          <target state="translated">위젯의 dragMoveEvent ()는 커서가 해당 영역 내에있을 때 제안 된 놓기 동작 만 수락하여 위젯의 특정 부분으로 방울을 제한하는 데 사용할 수 있습니다. 예를 들어, 다음 코드는 커서가 자식 위젯 ( &lt;code&gt;dropFrame&lt;/code&gt; ) 위에있을 때 제안 된 놓기 조치를 승인합니다 .</target>
        </trans-unit>
        <trans-unit id="1d5b5b0fa3cd2923e59720e180643dcce5d8def2" translate="yes" xml:space="preserve">
          <source>The widget's layout direction determines the order in which the layout manager horizontally arranges subwidgets of this widget. The default value depends on the language and locale of the application, and is typically in the same direction as words are read and written. With &lt;a href=&quot;qt#LayoutDirection-enum&quot;&gt;Qt::LeftToRight&lt;/a&gt;, the layout starts placing subwidgets from the left side of this widget towards the right. &lt;a href=&quot;qt#LayoutDirection-enum&quot;&gt;Qt::RightToLeft&lt;/a&gt; does the opposite - the layout will place widgets starting from the right edge moving towards the left.</source>
          <target state="translated">위젯의 레이아웃 방향은 레이아웃 관리자가이 위젯의 ​​서브 위젯을 수평으로 정렬하는 순서를 결정합니다. 기본값은 응용 프로그램의 언어 및 로캘에 따라 다르며 일반적으로 단어를 읽고 쓰는 것과 같은 방향입니다. 함께 &lt;a href=&quot;qt#LayoutDirection-enum&quot;&gt;Qt는 :: LeftToRight&lt;/a&gt; , 레이아웃은 오른쪽으로이 위젯의 왼쪽에서 subwidgets을 배치 시작합니다. &lt;a href=&quot;qt#LayoutDirection-enum&quot;&gt;Qt :: RightToLeft&lt;/a&gt; 는 반대를 수행합니다. 레이아웃은 오른쪽 가장자리에서 시작하여 왼쪽으로 이동하는 위젯을 배치합니다.</target>
        </trans-unit>
        <trans-unit id="692f3ca542c9a8e86cd1e1c4c89d8efe684d82b7" translate="yes" xml:space="preserve">
          <source>The widget's left margin.</source>
          <target state="translated">위젯의 왼쪽 여백</target>
        </trans-unit>
        <trans-unit id="b2c3d477621096d1ed5c3975e09df872b3b79287" translate="yes" xml:space="preserve">
          <source>The widget's left padding.</source>
          <target state="translated">위젯의 왼쪽 패딩.</target>
        </trans-unit>
        <trans-unit id="ed5f07764745071e91b2937fcb445c2dd80028b8" translate="yes" xml:space="preserve">
          <source>The widget's margins. Equivalent to specifying &lt;code&gt;margin-top&lt;/code&gt;, &lt;code&gt;margin-right&lt;/code&gt;, &lt;code&gt;margin-bottom&lt;/code&gt;, and &lt;code&gt;margin-left&lt;/code&gt;.</source>
          <target state="translated">위젯의 여백. &lt;code&gt;margin-top&lt;/code&gt; , &lt;code&gt;margin-right&lt;/code&gt; , &lt;code&gt;margin-bottom&lt;/code&gt; 및 &lt;code&gt;margin-left&lt;/code&gt; 를 지정하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="d39f266fc3e81df6cbdcd134c7245b2176eace78" translate="yes" xml:space="preserve">
          <source>The widget's or a subcontrol's maximum height.</source>
          <target state="translated">위젯 또는 하위 제어의 최대 높이입니다.</target>
        </trans-unit>
        <trans-unit id="fde2154aa25eb8445d2cef07270537ef8d520651" translate="yes" xml:space="preserve">
          <source>The widget's or a subcontrol's maximum width.</source>
          <target state="translated">위젯 또는 서브 컨트롤의 최대 너비</target>
        </trans-unit>
        <trans-unit id="9b3bd7f72f99922bf972665417c48f24859c2131" translate="yes" xml:space="preserve">
          <source>The widget's or a subcontrol's minimum height.</source>
          <target state="translated">위젯 또는 하위 컨트롤의 최소 높이입니다.</target>
        </trans-unit>
        <trans-unit id="906a9921b3f89fa2430650beda1b6608468ded5a" translate="yes" xml:space="preserve">
          <source>The widget's or a subcontrol's minimum width.</source>
          <target state="translated">위젯 또는 하위 컨트롤의 최소 너비입니다.</target>
        </trans-unit>
        <trans-unit id="95d9b08d790a2020189878640c05dfa866926d94" translate="yes" xml:space="preserve">
          <source>The widget's padding. Equivalent to specifying &lt;code&gt;padding-top&lt;/code&gt;, &lt;code&gt;padding-right&lt;/code&gt;, &lt;code&gt;padding-bottom&lt;/code&gt;, and &lt;code&gt;padding-left&lt;/code&gt;.</source>
          <target state="translated">위젯의 패딩. &lt;code&gt;padding-top&lt;/code&gt; , &lt;code&gt;padding-right&lt;/code&gt; , &lt;code&gt;padding-bottom&lt;/code&gt; 및 &lt;code&gt;padding-left&lt;/code&gt; 를 지정하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="ae528a8cce0b8776aca6f455819ebe0ec7f82811" translate="yes" xml:space="preserve">
          <source>The widget's rectangle, in which the &lt;code&gt;background&lt;/code&gt; is drawn.</source>
          <target state="translated">&lt;code&gt;background&lt;/code&gt; 이 그려지는 위젯의 사각형 .</target>
        </trans-unit>
        <trans-unit id="546445914ba088d2a76221d9cc0e1909b4417092" translate="yes" xml:space="preserve">
          <source>The widget's right margin.</source>
          <target state="translated">위젯의 오른쪽 여백</target>
        </trans-unit>
        <trans-unit id="3e8c85978a5960dd254dbcb2b616d94cf2fbdfd0" translate="yes" xml:space="preserve">
          <source>The widget's right padding.</source>
          <target state="translated">위젯의 오른쪽 패딩.</target>
        </trans-unit>
        <trans-unit id="f94bca806248cd81b1088fa603be95f9155a283d" translate="yes" xml:space="preserve">
          <source>The widget's size hint is ignored. The widget will get as much space as possible.</source>
          <target state="translated">위젯의 크기 힌트는 무시됩니다. 위젯은 가능한 많은 공간을 확보합니다.</target>
        </trans-unit>
        <trans-unit id="b9786cd667ce0263c8609a9bc830fb4e00432568" translate="yes" xml:space="preserve">
          <source>The widget's tooltip has changed.</source>
          <target state="translated">위젯의 툴팁이 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="c17fbebea636acd724d72d399ea31656f050e2c4" translate="yes" xml:space="preserve">
          <source>The widget's top margin.</source>
          <target state="translated">위젯의 상단 여백.</target>
        </trans-unit>
        <trans-unit id="ca36cacbceeae82d2491b4053c92c1a9b6d859bb" translate="yes" xml:space="preserve">
          <source>The widget's top padding.</source>
          <target state="translated">위젯의 상단 패딩.</target>
        </trans-unit>
        <trans-unit id="2f55e88a04c39379ab7ac1ea1ec24b3a9663f881" translate="yes" xml:space="preserve">
          <source>The widget's z-order has changed. This event is never sent to top level windows.</source>
          <target state="translated">위젯의 z 순서가 변경되었습니다. 이 이벤트는 절대 최상위 창으로 보내지지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9c8394f7611dcc4a92b3aebf072a045b1267000a" translate="yes" xml:space="preserve">
          <source>The widgets are populated with with data from the row at</source>
          <target state="translated">위젯은 행의 데이터로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="1fea46cf945d4a8270acd85bc9d5912287bf827a" translate="yes" xml:space="preserve">
          <source>The widgets can be in a number of different states, which are defined by the &lt;a href=&quot;qstyle#StateFlag-enum&quot;&gt;State&lt;/a&gt; enum. Some of the state flags have different meanings depending on the widget, but others are common for all widgets like &lt;code&gt;State_Disabled&lt;/code&gt;. It is &lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption&lt;/a&gt; that sets the common states with &lt;a href=&quot;qstyleoption#initFrom&quot;&gt;QStyleOption::initFrom&lt;/a&gt;(); the rest of the states are set by the individual widgets.</source>
          <target state="translated">위젯은 &lt;a href=&quot;qstyle#StateFlag-enum&quot;&gt;State&lt;/a&gt; 열거 형에 의해 정의되는 여러 가지 다른 상태 일 수 있습니다 . 상태 플래그 중 일부는 위젯에 따라 다른 의미를 &lt;code&gt;State_Disabled&lt;/code&gt; 와 같은 모든 위젯에 공통적 인 것 입니다 . &lt;a href=&quot;qstyleoption#initFrom&quot;&gt;QStyleOption :: initFrom&lt;/a&gt; ()으로 공통 상태를 설정하는 것은 &lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption&lt;/a&gt; 입니다 . 나머지 상태는 개별 위젯에 의해 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="6b3dd0f173d3aa208af6135c924dd87c3034656e" translate="yes" xml:space="preserve">
          <source>The widgets examples show how some of the widgets available in Qt might appear when configured to use the a particular style. Each style is only available on the respective platfom, and provides native look and feel by integrating to the platform theme. Thus, the final appearance varies depending on the active theme.</source>
          <target state="translated">위젯 예제는 특정 스타일을 사용하도록 구성 할 때 Qt에서 사용 가능한 일부 위젯이 표시되는 방법을 보여줍니다. 각 스타일은 해당 플랫폼에서만 사용할 수 있으며 플랫폼 테마에 통합하여 고유 한 모양과 느낌을 제공합니다. 따라서 최종 테마는 활성 테마에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="55bb5d3470575eefc030c948c9af11834cd89e9d" translate="yes" xml:space="preserve">
          <source>The width and color used to draw the border of the rectangle.</source>
          <target state="translated">사각형의 테두리를 그리는 데 사용되는 너비와 색상입니다.</target>
        </trans-unit>
        <trans-unit id="02296365f029e66cdd37eedd7387d5deed695df2" translate="yes" xml:space="preserve">
          <source>The width and height of the icon in a widget.</source>
          <target state="translated">위젯에서 아이콘의 너비와 높이입니다.</target>
        </trans-unit>
        <trans-unit id="6cfb90ccdefa661669552a01cda0619ae8814867" translate="yes" xml:space="preserve">
          <source>The width can be different on different dimensions, so you can for example omit drawing the frames on certain sides of the volume by setting the value for that dimension to zero. The values are fractions of the volume thickness in the same dimension. The values cannot be negative.</source>
          <target state="translated">너비는 치수에 따라 다를 수 있으므로 예를 들어 해당 치수의 값을 0으로 설정하여 볼륨의 특정면에 프레임 그리기를 생략 할 수 있습니다. 값은 동일한 치수에서 부피 두께의 분수입니다. 값은 음수 일 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7bca9aab4fc3b59ee4977a0903ce64c568875bfa" translate="yes" xml:space="preserve">
          <source>The width in pixels the &lt;a href=&quot;qml-qtquick-particles-trailemitter#emitShape-prop&quot;&gt;emitShape&lt;/a&gt; is scaled to. If set to &lt;a href=&quot;qml-qtquick-particles-trailemitter&quot;&gt;TrailEmitter&lt;/a&gt;.ParticleSize, the width will be the current size of the particle being followed.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-particles-trailemitter#emitShape-prop&quot;&gt;emitShape의&lt;/a&gt; 크기가 조정 되는 너비 (픽셀) 입니다. &lt;a href=&quot;qml-qtquick-particles-trailemitter&quot;&gt;TrailEmitter&lt;/a&gt; .ParticleSize로 설정 하면 너비는 따라가는 입자의 현재 크기가됩니다.</target>
        </trans-unit>
        <trans-unit id="c6959597d0c1a705bc0f4d85133f9e7b3124bc1b" translate="yes" xml:space="preserve">
          <source>The width is calculated with the &lt;a href=&quot;qtextdocument&quot;&gt;QTextDocument&lt;/a&gt; that &lt;a href=&quot;qgraphicstextitem&quot;&gt;QGraphicsTextItem&lt;/a&gt; keeps internally.</source>
          <target state="translated">너비는 &lt;a href=&quot;qgraphicstextitem&quot;&gt;QGraphicsTextItem&lt;/a&gt; 이 내부적으로 유지 하는 &lt;a href=&quot;qtextdocument&quot;&gt;QTextDocument&lt;/a&gt; 를 사용하여 계산됩니다 .</target>
        </trans-unit>
        <trans-unit id="e75faf3ee3e27926acacaf090f8737244f1e1ce0" translate="yes" xml:space="preserve">
          <source>The width is in pixels and is independent of the zoom level of the map.</source>
          <target state="translated">너비는 픽셀 단위이며 맵의 확대 / 축소 수준과 무관합니다.</target>
        </trans-unit>
        <trans-unit id="cf08d4d51c03c2d84d78a9a7fc7079a254796811" translate="yes" xml:space="preserve">
          <source>The width is in pixels and is independent of the zoom level of the map. The default values correspond to a black border with a width of 1 pixel.</source>
          <target state="translated">너비는 픽셀 단위이며 맵의 확대 / 축소 수준과 무관합니다. 기본값은 너비가 1 픽셀 인 검은 색 테두리에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="88479f02bbcd3b233e1e5ebc0282c6a1a7516986" translate="yes" xml:space="preserve">
          <source>The width of a horizontal ruler element.</source>
          <target state="translated">가로 눈금자 요소의 너비입니다.</target>
        </trans-unit>
        <trans-unit id="a57738addd929e0c0353392d43911e096886e14a" translate="yes" xml:space="preserve">
          <source>The width of a ripple. Sensible values are in the range &lt;code&gt;[2...100]&lt;/code&gt;. &lt;code&gt;10&lt;/code&gt; by default.</source>
          <target state="translated">잔물결의 너비입니다. 합리적인 값은 &lt;code&gt;[2...100]&lt;/code&gt; 범위에 있습니다. 기본적으로 &lt;code&gt;10&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="35ed29d5297d28d198513e400018cfe8dd0f3485" translate="yes" xml:space="preserve">
          <source>The width of a ripple. Sensible values are in the range &lt;code&gt;[2...100]&lt;/code&gt;. The default value is &lt;code&gt;10&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73814b2851f1bee334482033e41d423c24be41d5" translate="yes" xml:space="preserve">
          <source>The width of a split item with &lt;code&gt;fillWidth&lt;/code&gt; set to &lt;code&gt;true&lt;/code&gt; is still restricted within its &lt;a href=&quot;qml-qtquick-controls2-splitview#minimumWidth-attached-prop&quot;&gt;minimumWidth&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-controls2-splitview#maximumWidth-attached-prop&quot;&gt;maximumWidth&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;fillWidth&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 로 설정된 분할 항목의 너비 는 여전히 &lt;a href=&quot;qml-qtquick-controls2-splitview#minimumWidth-attached-prop&quot;&gt;minimumWidth&lt;/a&gt; 및 &lt;a href=&quot;qml-qtquick-controls2-splitview#maximumWidth-attached-prop&quot;&gt;maximumWidth&lt;/a&gt; 내로 제한됩니다 .</target>
        </trans-unit>
        <trans-unit id="4c9565cd1a822f78b68fa2626f1ed589902dfe36" translate="yes" xml:space="preserve">
          <source>The width of a subcontrol (or a widget in some cases).</source>
          <target state="translated">하위 컨트롤의 너비 (또는 경우에 따라 위젯)</target>
        </trans-unit>
        <trans-unit id="3e2cc121030d39b824e2a5dd6b1f1f60ff039bea" translate="yes" xml:space="preserve">
          <source>The width of the 3D texture defining the volume content in pixels. Defaults to &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">볼륨 내용을 픽셀 단위로 정의하는 3D 텍스처의 너비입니다. 기본값은 &lt;code&gt;0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="cec3a815b8155b3505edd2f16d9c1913b2a1de5d" translate="yes" xml:space="preserve">
          <source>The width of the &lt;a href=&quot;qml-qtquick-controls2-splitview&quot;&gt;SplitView&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-controls2-splitview&quot;&gt;SplitView&lt;/a&gt; 의 너비입니다 .</target>
        </trans-unit>
        <trans-unit id="19cacc32ad4c6623d0f48fe3f3db3fcaf0540675" translate="yes" xml:space="preserve">
          <source>The width of the border line. By default, the width is 2.0.</source>
          <target state="translated">경계선의 너비입니다. 기본적으로 너비는 2.0입니다.</target>
        </trans-unit>
        <trans-unit id="c01b9a55ea11b6189c66c4ac05d97b6b17b70598" translate="yes" xml:space="preserve">
          <source>The width of the border's bottom edge.</source>
          <target state="translated">테두리 아래쪽 가장자리의 너비입니다.</target>
        </trans-unit>
        <trans-unit id="0f129cbd3110086d8de69ade478bdc4d11030ad7" translate="yes" xml:space="preserve">
          <source>The width of the border's left edge.</source>
          <target state="translated">테두리 왼쪽 가장자리의 너비입니다.</target>
        </trans-unit>
        <trans-unit id="6ddc60d0dce571fa7c2e98bdb67987c4fd1f79e2" translate="yes" xml:space="preserve">
          <source>The width of the border's right edge.</source>
          <target state="translated">테두리 오른쪽 가장자리의 너비입니다.</target>
        </trans-unit>
        <trans-unit id="5769eb51156fd88d7d573aaa411d3239cf9f6b08" translate="yes" xml:space="preserve">
          <source>The width of the border's top edge.</source>
          <target state="translated">테두리 위쪽 가장자리의 너비입니다.</target>
        </trans-unit>
        <trans-unit id="b74ead5d24e9a874f0b6654adf07ef2f8aca8808" translate="yes" xml:space="preserve">
          <source>The width of the border. Equivalent to setting &lt;code&gt;border-top-width&lt;/code&gt;, &lt;code&gt;border-right-width&lt;/code&gt;, &lt;code&gt;border-bottom-width&lt;/code&gt;, and &lt;code&gt;border-left-width&lt;/code&gt;.</source>
          <target state="translated">테두리의 너비입니다. 설정하는 것과 &lt;code&gt;border-top-width&lt;/code&gt; , &lt;code&gt;border-right-width&lt;/code&gt; , &lt;code&gt;border-bottom-width&lt;/code&gt; 및 &lt;code&gt;border-left-width&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3bb913b6bc4fae077395d77cd6f194c703c3743f" translate="yes" xml:space="preserve">
          <source>The width of the box-and-whiskers item. The value indicates the relative width of the item within its category. The value can be between 0.0 and 1.0. Negative values are replaced with 0.0 and values greater than 1.0 are replaced with 1.0.</source>
          <target state="translated">상자와 수염 항목의 너비입니다. 값은 범주 내에서 항목의 상대적 너비를 나타냅니다. 값은 0.0과 1.0 사이 일 수 있습니다. 음수 값은 0.0으로 대체되고 1.0보다 큰 값은 1.0으로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="44bfb09d5c6c8b8c251a24d984e4da797488c08b" translate="yes" xml:space="preserve">
          <source>The width of the cursor in a line edit or text edit</source>
          <target state="translated">라인 편집 또는 텍스트 편집에서 커서의 너비</target>
        </trans-unit>
        <trans-unit id="04482867921ab367eaaf726b1a846e5f24c75649" translate="yes" xml:space="preserve">
          <source>The width of the line. By default, the width is 2.0.</source>
          <target state="translated">선의 너비입니다. 기본적으로 너비는 2.0입니다.</target>
        </trans-unit>
        <trans-unit id="5239c3160adee2ffaa8ed061bd3aae3a91fe677e" translate="yes" xml:space="preserve">
          <source>The width of the object is fixed</source>
          <target state="translated">객체의 너비는 고정되어 있습니다</target>
        </trans-unit>
        <trans-unit id="df05c24ec8e81db8b676e0dcaa72da4614369c1e" translate="yes" xml:space="preserve">
          <source>The width of the object is in percentage of the maximum width</source>
          <target state="translated">객체의 너비는 최대 너비의 백분율입니다</target>
        </trans-unit>
        <trans-unit id="61d701c4b071e1ba3750496cccab4372c28ebffa" translate="yes" xml:space="preserve">
          <source>The width of the object is variable</source>
          <target state="translated">객체의 너비는 가변적입니다</target>
        </trans-unit>
        <trans-unit id="d4338b00a0a8fc6cb64745a4341e01e895b93983" translate="yes" xml:space="preserve">
          <source>The width of the paint device in default coordinate system units (e.g. pixels for &lt;a href=&quot;qpixmap&quot;&gt;QPixmap&lt;/a&gt; and &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt;). See also &lt;a href=&quot;qpaintdevice#width&quot;&gt;width&lt;/a&gt;().</source>
          <target state="translated">기본 좌표계 단위의 페인트 장치 너비 (예 : &lt;a href=&quot;qpixmap&quot;&gt;QPixmap&lt;/a&gt; 및 &lt;a href=&quot;qwidget&quot;&gt;QWidget의&lt;/a&gt; 픽셀 ). &lt;a href=&quot;qpaintdevice#width&quot;&gt;너비&lt;/a&gt; () 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="da35e586df402f370fb2b6ac2ddd149dab3f5874" translate="yes" xml:space="preserve">
          <source>The width of the paint device in default coordinate system units (e.g. pixels for &lt;a href=&quot;qpixmap&quot;&gt;QPixmap&lt;/a&gt; and &lt;a href=&quot;widgets-changes-qt6#qwidget&quot;&gt;QWidget&lt;/a&gt;). See also &lt;a href=&quot;qpaintdevice#width&quot;&gt;width&lt;/a&gt;().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17bf8d4b9bdba5f9291effa68537d47a0672b639" translate="yes" xml:space="preserve">
          <source>The width of the paint device in millimeters. See also &lt;a href=&quot;qpaintdevice#widthMM&quot;&gt;widthMM&lt;/a&gt;().</source>
          <target state="translated">페인트 장치의 너비 (밀리미터)입니다. &lt;a href=&quot;qpaintdevice#widthMM&quot;&gt;widthMM&lt;/a&gt; () 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a069596ae138ed6a4d04d13685dd04543849f3b6" translate="yes" xml:space="preserve">
          <source>The width of the slice border. This is a convenience property for modifying the slice pen.</source>
          <target state="translated">슬라이스 경계의 폭입니다. 슬라이스 펜을 수정하기위한 편리한 속성입니다.</target>
        </trans-unit>
        <trans-unit id="fad58778d23bdcc81f43bd4bd66364b885bcf9ab" translate="yes" xml:space="preserve">
          <source>The width of the text content.</source>
          <target state="translated">텍스트 내용의 너비입니다.</target>
        </trans-unit>
        <trans-unit id="9b60b015b797ec217aca6693f69a147e9179c037" translate="yes" xml:space="preserve">
          <source>The width of the tool bar frame.</source>
          <target state="translated">툴바 프레임의 너비입니다.</target>
        </trans-unit>
        <trans-unit id="6e110b460c8f6525e778e70f4605246dad672739" translate="yes" xml:space="preserve">
          <source>The width of the week number column is calculated based on the maximum implicit width of the delegates.</source>
          <target state="translated">주 번호 열의 너비는 대리자의 최대 암시 적 너비를 기반으로 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="16fe7aa5e5a8a80e7634a7ca34b7141126bf8604" translate="yes" xml:space="preserve">
          <source>The width returned is enough for at least one character.</source>
          <target state="translated">반환 된 너비는 하나 이상의 문자에 충분합니다.</target>
        </trans-unit>
        <trans-unit id="a24541d5a94b6d1d8d9e404f0eb6af5c71341ca2" translate="yes" xml:space="preserve">
          <source>The width returned is usually enough for at least one character.</source>
          <target state="translated">반환되는 너비는 일반적으로 적어도 한 문자에 충분합니다.</target>
        </trans-unit>
        <trans-unit id="1c5d9cc19d1a01baeb629a2f8e8e7ba9a8f4af65" translate="yes" xml:space="preserve">
          <source>The width returned, in pixels, is usually enough for about 15 to 20 characters.</source>
          <target state="translated">픽셀 단위로 반환되는 너비는 일반적으로 약 15-20 자 정도입니다.</target>
        </trans-unit>
        <trans-unit id="2540878e84823974bff5fc88cce0117080529a8f" translate="yes" xml:space="preserve">
          <source>The width that the line would naturally occupy based on its contents, not taking into account any modifications made to</source>
          <target state="translated">수정 사항을 고려하지 않고 내용에 따라 선이 자연스럽게 차지하는 너비</target>
        </trans-unit>
        <trans-unit id="96b69320b48e15a588b109a34b51e2616281eb1c" translate="yes" xml:space="preserve">
          <source>The widths of the slice frame. The width can be different on different dimensions, so you can for example omit drawing the frames on certain sides of the volume by setting the value for that dimension to zero. The values are fractions of the volume thickness in the same dimension. The values cannot be negative.</source>
          <target state="translated">슬라이스 프레임의 너비입니다. 너비는 치수마다 다를 수 있으므로 예를 들어 해당 치수의 값을 0으로 설정하여 볼륨의 특정면에 프레임을 그리는 것을 생략 할 수 있습니다. 값은 동일한 치수에서 부피 두께의 분수입니다. 값은 음수 일 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="632738fb3b7ff7eb54232cef66a2d04befce91ac" translate="yes" xml:space="preserve">
          <source>The wildcard &lt;code&gt;'*'&lt;/code&gt; can be used in a name test. To find all the attributes in the cookbook but select only the ones in the &lt;code&gt;xml&lt;/code&gt; namespace, use the &lt;code&gt;xml:&lt;/code&gt; namespace prefix but replace the</source>
          <target state="translated">와일드 카드 &lt;code&gt;'*'&lt;/code&gt; 는 이름 테스트에 사용할 수 있습니다. 요리 책에서 모든 속성을 찾고 &lt;code&gt;xml&lt;/code&gt; 네임 스페이스 의 속성 만 선택 하려면 &lt;code&gt;xml:&lt;/code&gt; namespace 접두사를 사용하지만</target>
        </trans-unit>
        <trans-unit id="e2263a59774e593d61834b2abed33687ed1a62bb" translate="yes" xml:space="preserve">
          <source>The window</source>
          <target state="translated">창</target>
        </trans-unit>
        <trans-unit id="29af3375ff5f55c5aa3ea10b80ed57793992d2f6" translate="yes" xml:space="preserve">
          <source>The window (general background) color of the current color group.</source>
          <target state="translated">현재 색상 그룹의 창 (일반 배경) 색상입니다.</target>
        </trans-unit>
        <trans-unit id="f05a03167fda8cf9b02d3befa3d22ddcf5d6fab2" translate="yes" xml:space="preserve">
          <source>The window attached to this style.</source>
          <target state="translated">이 스타일에 연결된 창입니다.</target>
        </trans-unit>
        <trans-unit id="58bf15dc87c96bbabadf001cfe67248269a4adab" translate="yes" xml:space="preserve">
          <source>The window can be in a combination of several states. For example, if the window is both minimized and maximized, the window will appear minimized, but clicking on the task bar entry will restore it to the maximized state.</source>
          <target state="translated">창은 여러 상태의 조합 일 수 있습니다. 예를 들어, 창이 최소화 및 최대화 된 경우, 창이 최소화 된 것처럼 보이지만 작업 표시 줄 항목을 클릭하면 최대화 된 상태로 복원됩니다.</target>
        </trans-unit>
        <trans-unit id="11b42e89f5d1bc207fceb8556596c37daf0e0d7b" translate="yes" xml:space="preserve">
          <source>The window container has a number of known limitations:</source>
          <target state="translated">창 컨테이너에는 몇 가지 알려진 제한 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e5f278195546a5151706dd27a9eb525d7ef49aa" translate="yes" xml:space="preserve">
          <source>The window container is attached as a native child window to the toplevel window it is a child of. When a window container is used as a child of a &lt;a href=&quot;qabstractscrollarea&quot;&gt;QAbstractScrollArea&lt;/a&gt; or &lt;a href=&quot;qmdiarea&quot;&gt;QMdiArea&lt;/a&gt;, it will create a &lt;a href=&quot;qwidget#native-widgets-vs-alien-widgets&quot;&gt;native window&lt;/a&gt; for every widget in its parent chain to allow for proper stacking and clipping in this use case. Creating a native window for the window container also allows for proper stacking and clipping. This must be done before showing the window container. Applications with many native child windows may suffer from performance issues.</source>
          <target state="translated">창 컨테이너는 자식의 최상위 창에 기본 자식 창으로 연결됩니다. 윈도우 컨테이너가 &lt;a href=&quot;qabstractscrollarea&quot;&gt;QAbstractScrollArea&lt;/a&gt; 또는 &lt;a href=&quot;qmdiarea&quot;&gt;QMdiArea&lt;/a&gt; 의 자식으로 사용되는 경우,이 사용 사례에서 적절한 스택 및 클리핑을 허용하기 위해 상위 체인의 모든 위젯에 대한 &lt;a href=&quot;qwidget#native-widgets-vs-alien-widgets&quot;&gt;기본 윈도우&lt;/a&gt; 를 작성합니다 . 창 컨테이너의 기본 창을 만들면 적절한 스택 및 클리핑이 가능합니다. 창 컨테이너를 표시하기 전에 수행해야합니다. 기본 자식 창이 많은 응용 프로그램에는 성능 문제가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d52b7d8243c616aac1ee2373d370755b1bb2666" translate="yes" xml:space="preserve">
          <source>The window container is created as a child of</source>
          <target state="translated">윈도우 컨테이너는</target>
        </trans-unit>
        <trans-unit id="df0c46d5c32a774f6b0c5868240e527603c53460" translate="yes" xml:space="preserve">
          <source>The window fills the entire screen without any frame around it.</source>
          <target state="translated">창은 주위에 프레임없이 전체 화면을 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="96e0f4b967290e374a6b5f2ec2edf035b384cd00" translate="yes" xml:space="preserve">
          <source>The window flags control the window's appearance in the windowing system, whether it's a dialog, popup, or a regular window, and whether it should have a title bar, etc.</source>
          <target state="translated">윈도우 플래그는 윈도우 시스템에서 윈도우의 모양, 대화 상자, 팝업 또는 일반 윈도우, 제목 표시 줄 등을 제어합니다.</target>
        </trans-unit>
        <trans-unit id="bb0c287d8b187373b708221933b7700b76485ed7" translate="yes" xml:space="preserve">
          <source>The window flags of the window.</source>
          <target state="translated">윈도우의 윈도우 플래그.</target>
        </trans-unit>
        <trans-unit id="7035f43cf705fbccdf8f3cc90c2bac32cdee37a4" translate="yes" xml:space="preserve">
          <source>The window for which this window is a transient pop-up.</source>
          <target state="translated">이 윈도우가 일시적인 팝업 인 윈도우입니다.</target>
        </trans-unit>
        <trans-unit id="dcb5b86cc7efbeea0e6d6d10d9aae258d5853891" translate="yes" xml:space="preserve">
          <source>The window geometry the popup received in the configure event. Relative to the upper left corner of the parent surface.</source>
          <target state="translated">팝업이 구성 이벤트에서 수신 한 창 형상입니다. 부모 서피스의 왼쪽 위 모서리를 기준으로합니다.</target>
        </trans-unit>
        <trans-unit id="5641256b1160d26b5f9d85a6d18caa3af7f6ca0a" translate="yes" xml:space="preserve">
          <source>The window has no state set (in normal state).</source>
          <target state="translated">창에 상태가 설정되어 있지 않습니다 (정상 상태).</target>
        </trans-unit>
        <trans-unit id="8de25f0be83b568dbb8f926206e526cf93088bc3" translate="yes" xml:space="preserve">
          <source>The window icon might be used by the windowing system for example to decorate the window, and/or in the task switcher.</source>
          <target state="translated">창 아이콘은 예를 들어 창 장식 및 / 또는 작업 전환기에 창 시스템에서 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4cc14eb6fd5b1a0c612b3cf2b9b7eb86bb5447f5" translate="yes" xml:space="preserve">
          <source>The window identifier type depends on the underlying window system, see &lt;code&gt;qwindowdefs.h&lt;/code&gt; for the actual definition. If there is no widget with this identifier, &lt;code&gt;nullptr&lt;/code&gt; is returned.</source>
          <target state="translated">윈도우 식별자 유형은 기본 윈도우 시스템에 따라 다릅니다 . 실제 정의는 &lt;code&gt;qwindowdefs.h&lt;/code&gt; 를 참조하십시오 . 이 식별자를 가진 위젯이 없으면 &lt;code&gt;nullptr&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="6886aa540eaf663cb9e6618f850c2ce44f0af2df" translate="yes" xml:space="preserve">
          <source>The window is activated according to the default behavior of the Windows operating system. This means the window will not be activated in some circumstances (most notably when the calling process is not the active process); only the taskbar entry will be flashed.</source>
          <target state="translated">창은 Windows 운영 체제의 기본 동작에 따라 활성화됩니다. 이는 일부 상황에서 (대부분 호출 프로세스가 활성 프로세스가 아닌 경우) 창이 활성화되지 않음을 의미합니다. 작업 표시 줄 항목 만 깜박입니다.</target>
        </trans-unit>
        <trans-unit id="309beb0bb77ddd491dc0b81f5aa1fe1761409d10" translate="yes" xml:space="preserve">
          <source>The window is always activated, even when the calling process is not the active process.</source>
          <target state="translated">호출 프로세스가 활성 프로세스가 아닌 경우에도 창은 항상 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="c94b3f1e13781c6a995d261733c967d43ede03c7" translate="yes" xml:space="preserve">
          <source>The window is blocked by a modal dialog.</source>
          <target state="translated">창은 모달 대화 상자에 의해 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="4973bc715b9665c3da3647454621da74cecd419e" translate="yes" xml:space="preserve">
          <source>The window is maximized with a frame around it.</source>
          <target state="translated">창 주위에 프레임이 최대화됩니다.</target>
        </trans-unit>
        <trans-unit id="29b88fdc665c2d36dcf32599ef1b7f82e86776ca" translate="yes" xml:space="preserve">
          <source>The window is minimized (i.e. iconified).</source>
          <target state="translated">창이 최소화됩니다 (즉, 아이콘 화됨).</target>
        </trans-unit>
        <trans-unit id="535b0d678e931601c13f6ef350e5042a184e6a90" translate="yes" xml:space="preserve">
          <source>The window is modal to a single window hierarchy and blocks input to its parent window, all grandparent windows, and all siblings of its parent and grandparent windows.</source>
          <target state="translated">이 창은 단일 창 계층에 대한 모달이며 부모 창, 모든 조부모 창 및 부모 및 조부모 창의 모든 형제에 대한 입력을 차단합니다.</target>
        </trans-unit>
        <trans-unit id="151048344c9697b128ef2927fa25b01d7ad6e6a8" translate="yes" xml:space="preserve">
          <source>The window is modal to the application and blocks input to all windows.</source>
          <target state="translated">이 창은 응용 프로그램에 대한 모달이며 모든 창에 대한 입력을 차단합니다.</target>
        </trans-unit>
        <trans-unit id="c6e29594c83596bea1b0b1e255f1197a9bc02d39" translate="yes" xml:space="preserve">
          <source>The window is modal to the entire scene and blocks input to all panels.</source>
          <target state="translated">윈도우는 전체 장면에 모달이며 모든 패널에 대한 입력을 차단합니다.</target>
        </trans-unit>
        <trans-unit id="19d0b17747985c37300f30c656d5ed29f31cfe4c" translate="yes" xml:space="preserve">
          <source>The window is needed because the its pixel format will be queried. When the adoption is successful, &lt;a href=&quot;qopenglcontext#format&quot;&gt;QOpenGLContext::format&lt;/a&gt;() will return a &lt;a href=&quot;qsurfaceformat&quot;&gt;QSurfaceFormat&lt;/a&gt; describing this pixel format.</source>
          <target state="translated">픽셀 형식이 쿼리되므로 창이 필요합니다. 채택이 성공하면 &lt;a href=&quot;qopenglcontext#format&quot;&gt;QOpenGLContext :: format&lt;/a&gt; () 은이 픽셀 형식을 설명 하는 &lt;a href=&quot;qsurfaceformat&quot;&gt;QSurfaceFormat&lt;/a&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="3d1f2c59be16b5b21e5bcffb9d3e473ad71459dd" translate="yes" xml:space="preserve">
          <source>The window is not modal and does not block input to other windows.</source>
          <target state="translated">이 창은 모달이 아니며 다른 창으로의 입력을 차단하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="aa642ab6bffef2e9f54fd5e7d9a8cb81a51903bf" translate="yes" xml:space="preserve">
          <source>The window is not shown until &lt;a href=&quot;qwindow#visible-prop&quot;&gt;setVisible&lt;/a&gt;(true), &lt;a href=&quot;qwindow#show&quot;&gt;show&lt;/a&gt;(), or similar is called.</source>
          <target state="translated">&lt;a href=&quot;qwindow#visible-prop&quot;&gt;setVisible&lt;/a&gt; (true), &lt;a href=&quot;qwindow#show&quot;&gt;show&lt;/a&gt; () 또는 이와 유사한 것이 호출 될 때까지 창은 표시되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="b59f4ec9b4ee73aa19076f4f6744be469d745543" translate="yes" xml:space="preserve">
          <source>The window is not visible in any way, however it may remember a latent visibility which can be restored by setting AutomaticVisibility.</source>
          <target state="translated">창은 어떤 방식으로도 보이지 않지만 AutomaticVisibility를 설정하여 복원 할 수있는 잠재 가시성을 기억할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="83151412d6df4c87e32ac9ccb6cf04adbc950043" translate="yes" xml:space="preserve">
          <source>The window is reduced to an entry or icon on the task bar, dock, task list or desktop, depending on how the windowing system handles minimized windows.</source>
          <target state="translated">윈도우 시스템이 최소화 된 윈도우를 처리하는 방식에 따라 윈도우는 작업 표시 줄, 도크, 작업 목록 또는 데스크탑의 항목 또는 아이콘으로 축소됩니다.</target>
        </trans-unit>
        <trans-unit id="7d97650c74bbf95325c05e55e9523a234df1b638" translate="yes" xml:space="preserve">
          <source>The window is the active window, i.e. it has keyboard focus.</source>
          <target state="translated">창은 활성 창입니다. 즉 키보드 포커스가 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e6b80bf89c55848145c0a42cc73c92a0be97939" translate="yes" xml:space="preserve">
          <source>The window is unblocked after a modal dialog exited.</source>
          <target state="translated">모달 대화 상자가 종료 된 후 창이 차단 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="bec244ea0ae04750e681a0c1d4b872987f672766" translate="yes" xml:space="preserve">
          <source>The window manager may or may not choose to display any areas of the window not included in the mask, thus it is the application's responsibility to clear to transparent the areas that are not part of the mask.</source>
          <target state="translated">윈도우 관리자는 마스크에 포함되지 않은 윈도우의 영역을 표시하도록 선택하거나 선택하지 않을 수 있으므로 마스크의 일부가 아닌 영역을 투명하게 표시하는 것은 응용 프로그램의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="453cdf9a827512644bc040f506df051457be1eb3" translate="yes" xml:space="preserve">
          <source>The window occupies one entire screen, and the titlebar is still visible. On most windowing systems this is the state achieved by clicking the maximize button on the toolbar.</source>
          <target state="translated">창은 하나의 전체 화면을 차지하며 제목 표시 줄은 계속 표시됩니다. 대부분의 윈도우 시스템에서 이는 도구 모음에서 최대화 버튼을 클릭하여 달성 된 상태입니다.</target>
        </trans-unit>
        <trans-unit id="88afed69eadd6f92e8d154515f8766e534193c90" translate="yes" xml:space="preserve">
          <source>The window occupies one entire screen, is not resizable, and there is no titlebar. On some platforms which do not support showing multiple simultaneous windows, this can be the usual visibility when the window is not hidden.</source>
          <target state="translated">창은 하나의 전체 화면을 차지하고 크기를 조정할 수 없으며 제목 표시 줄이 없습니다. 여러 개의 동시 창 표시를 지원하지 않는 일부 플랫폼에서는 창이 숨겨져 있지 않을 때 일반적인 가시성이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="24c7580107a0f310e31e1dcb646728a60ca2aaf8" translate="yes" xml:space="preserve">
          <source>The window occupies part of the screen, but not necessarily the entire screen. This state will occur only on windowing systems which support showing multiple windows simultaneously. In this state it is possible for the user to move and resize the window manually, if WindowFlags permit it and if it is supported by the windowing system.</source>
          <target state="translated">창은 화면의 일부를 차지하지만 반드시 전체 화면은 아닙니다. 이 상태는 여러 창을 동시에 표시하는 것을 지원하는 창 시스템에서만 발생합니다. 이 상태에서 WindowFlags가 허용하고 윈도우 시스템에서 지원하는 경우 사용자가 윈도우를 수동으로 이동하고 크기를 조정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="49ae1205db14896507605cc4041a0a600db10455" translate="yes" xml:space="preserve">
          <source>The window rectangle is part of the view transformation. The window specifies the logical coordinate system. Its sister, the &lt;a href=&quot;qpainter#viewport&quot;&gt;viewport&lt;/a&gt;(), specifies the device coordinate system.</source>
          <target state="translated">창 사각형은 뷰 변환의 일부입니다. 이 창은 논리 좌표계를 지정합니다. 자매 ( &lt;a href=&quot;qpainter#viewport&quot;&gt;뷰포트&lt;/a&gt; ())는 장치 좌표계를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="e397c2b05438bde4b4552f139e686d2884765be1" translate="yes" xml:space="preserve">
          <source>The window state before a window state change</source>
          <target state="translated">윈도우 상태가 변경되기 전의 윈도우 상태</target>
        </trans-unit>
        <trans-unit id="0caed26711e4a8794fabcd882fed1a240f27536c" translate="yes" xml:space="preserve">
          <source>The window system identifer for this native widget has changed.</source>
          <target state="translated">이 기본 위젯의 창 시스템 식별자가 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="142ebd2523449805af1dae9822ccb153c3e8cc8d" translate="yes" xml:space="preserve">
          <source>The window system identifier (&lt;code&gt;WId&lt;/code&gt;) can be retrieved using the &lt;a href=&quot;qwidget#winId&quot;&gt;QWidget::winId&lt;/a&gt;() function. The rationale for using a window identifier and not a &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt;, is to enable grabbing of windows that are not part of the application, window system frames, and so on.</source>
          <target state="translated">윈도우 시스템 식별자 ( &lt;code&gt;WId&lt;/code&gt; )는 &lt;a href=&quot;qwidget#winId&quot;&gt;QWidget :: winId&lt;/a&gt; () 함수를 사용하여 검색 할 수 있습니다 . &lt;a href=&quot;qwidget&quot;&gt;QWidget이&lt;/a&gt; 아닌 창 식별자를 사용하는 이론적 근거 는 응용 프로그램, 창 시스템 프레임 등의 일부가 아닌 창을 잡을 수있게하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="148868373d340bb660b4062b42688eb4dd60ce9f" translate="yes" xml:space="preserve">
          <source>The window system identifier (&lt;code&gt;WId&lt;/code&gt;) can be retrieved using the &lt;a href=&quot;qwidget#winId&quot;&gt;QWidget::winId&lt;/a&gt;() function. The rationale for using a window identifier and not a &lt;a href=&quot;widgets-changes-qt6#qwidget&quot;&gt;QWidget&lt;/a&gt;, is to enable grabbing of windows that are not part of the application, window system frames, and so on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b903a81d90f389708be63fea204e5723355810f" translate="yes" xml:space="preserve">
          <source>The window system made this window either active or inactive.</source>
          <target state="translated">창 시스템은이 창을 활성 또는 비활성으로 만들었습니다.</target>
        </trans-unit>
        <trans-unit id="60376b734ce553c02941376725d9436f73f26517" translate="yes" xml:space="preserve">
          <source>The window takes ownership of the returned renderer object.</source>
          <target state="translated">윈도우는 반환 된 렌더러 객체의 소유권을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="df9ba572b0cd0cb34cce0b1bf4ed44f53a801e6f" translate="yes" xml:space="preserve">
          <source>The window takes ownership over</source>
          <target state="translated">창은 소유권을 인수합니다</target>
        </trans-unit>
        <trans-unit id="761bd74a908387aa3e3b6c668b7c96b261690405" translate="yes" xml:space="preserve">
          <source>The window text (general foreground) color of the current color group.</source>
          <target state="translated">현재 색상 그룹의 창 텍스트 (일반 전경색)입니다.</target>
        </trans-unit>
        <trans-unit id="2dd7acfc2f14985fa19f9d0526b0cbeb6a311fd8" translate="yes" xml:space="preserve">
          <source>The window title has changed.</source>
          <target state="translated">창 제목이 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="bf746819828a64dad2b705693ccb24607401e9dd" translate="yes" xml:space="preserve">
          <source>The window title is set to</source>
          <target state="translated">창 제목이</target>
        </trans-unit>
        <trans-unit id="00f43be696d7bf436d50c46183f3d6581f869aca" translate="yes" xml:space="preserve">
          <source>The window title might appear in the title area of the window decorations, depending on the windowing system and the window flags. It might also be used by the windowing system to identify the window in other contexts, such as in the task switcher.</source>
          <target state="translated">창 제목은 창 시스템 및 창 플래그에 따라 창 장식의 제목 영역에 나타날 수 있습니다. 또한 작업 전환기와 같은 다른 컨텍스트에서 창을 식별하기 위해 창 시스템에서 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="1eb3b71f1164dd20d7eeb55b400b4f9df8b05157" translate="yes" xml:space="preserve">
          <source>The window title must contain a &quot;[*]&quot; placeholder, which indicates where the '*' should appear. Normally, it should appear right after the file name (e.g., &quot;document1.txt[*] - Text Editor&quot;). If the window isn't modified, the placeholder is simply removed.</source>
          <target state="translated">창 제목에는 &quot;*&quot;가 나타나는 위치를 나타내는 &quot;[*]&quot;자리 표시자가 포함되어야합니다. 일반적으로 파일 이름 바로 뒤에 나타납니다 (예 : &quot;document1.txt [*]-텍스트 편집기&quot;). 창이 수정되지 않으면 자리 표시자가 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="67f07717672b8dbee97edb27ec86b6271d76dcfa" translate="yes" xml:space="preserve">
          <source>The window will be embedded inside the parent window, its coordinates relative to the parent.</source>
          <target state="translated">창은 부모 창을 기준으로 부모 창에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="5067f7fe1967a2ddaa4ac061cb9b8565765098ef" translate="yes" xml:space="preserve">
          <source>The window's icon has changed.</source>
          <target state="translated">창의 아이콘이 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="c5ed2969f359104115c0b03a805517ce32a4cc31" translate="yes" xml:space="preserve">
          <source>The window's title in the windowing system.</source>
          <target state="translated">윈도우 시스템의 윈도우 제목입니다.</target>
        </trans-unit>
        <trans-unit id="8272dd405a5dc138ce31b30f17361e376115177e" translate="yes" xml:space="preserve">
          <source>The windowing system might not support size increments.</source>
          <target state="translated">윈도우 시스템은 크기 증분을 지원하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="33e3102173104b89fb935304b0c261070fe36734" translate="yes" xml:space="preserve">
          <source>The windowing system might use</source>
          <target state="translated">윈도우 시스템은</target>
        </trans-unit>
        <trans-unit id="b0a386888086770e5641e9538cd6cf2c0d3c1c1a" translate="yes" xml:space="preserve">
          <source>The windows are closed in random order, until one window does not accept the close event. The application quits when the last window was successfully closed, unless &lt;a href=&quot;qguiapplication#quitOnLastWindowClosed-prop&quot;&gt;quitOnLastWindowClosed&lt;/a&gt; is set to false. To trigger application termination from e.g. a menu, use &lt;a href=&quot;qcoreapplication#quit&quot;&gt;QCoreApplication::quit&lt;/a&gt;() instead of this function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6865f0b406c8baf9dab7d37bd95617d4abac65a0" translate="yes" xml:space="preserve">
          <source>The windows are closed in random order, until one window does not accept the close event. The application quits when the last window was successfully closed; this can be turned off by setting &lt;a href=&quot;qguiapplication#quitOnLastWindowClosed-prop&quot;&gt;quitOnLastWindowClosed&lt;/a&gt; to false.</source>
          <target state="translated">한 창에서 닫기 이벤트를 허용하지 않을 때까지 창은 임의 순서로 닫힙니다. 마지막 창이 성공적으로 닫히면 응용 프로그램이 종료됩니다. &lt;a href=&quot;qguiapplication#quitOnLastWindowClosed-prop&quot;&gt;quitOnLastWindowClosed&lt;/a&gt; 를 false 로 설정 하여 끌 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9a1eefe52f90e8c05772cb0e87c98af5c7679769" translate="yes" xml:space="preserve">
          <source>The windows are returned in the order in which they are stacked, with the top-most window being last in the list.</source>
          <target state="translated">창은 쌓인 순서대로 반환되며 맨 위 창은 목록에서 마지막에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="2140c3a129706fad2b79ce83a127fe29bba29b04" translate="yes" xml:space="preserve">
          <source>The windows are returned in the order in which they were activated.</source>
          <target state="translated">창은 활성화 된 순서대로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="608761829b2a5baa82ea8446182b0e16d0b93836" translate="yes" xml:space="preserve">
          <source>The windows are returned in the order of their creation.</source>
          <target state="translated">창은 생성 순서대로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="49ab01dcc301a382807d7e0072a77abad854108d" translate="yes" xml:space="preserve">
          <source>The word ancestor here means a parent widget within the same window.</source>
          <target state="translated">여기서 조상이라는 단어는 같은 창에있는 부모 위젯을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="7b17caf876e6f096d0b12c1773382653161fa08a" translate="yes" xml:space="preserve">
          <source>The word candidate is from the default dictionary.</source>
          <target state="translated">후보 단어는 기본 사전에서 온 것입니다.</target>
        </trans-unit>
        <trans-unit id="c341552830b899b32149339d587f39502a64e63a" translate="yes" xml:space="preserve">
          <source>The word candidate is from the user dictionary.</source>
          <target state="translated">단어 후보는 사용자 사전에서 온 것입니다.</target>
        </trans-unit>
        <trans-unit id="b14c8373fa120e227e15adea77a3ee8928de7a41" translate="yes" xml:space="preserve">
          <source>The workspace should maximize the client area.</source>
          <target state="translated">작업 공간은 클라이언트 영역을 최대화해야합니다.</target>
        </trans-unit>
        <trans-unit id="26c1aaceb205dd4ce3972c599c6e0fd264218a2f" translate="yes" xml:space="preserve">
          <source>The world ID defining which isolated world the script is executed in.</source>
          <target state="translated">스크립트가 실행되는 격리 된 세계를 정의하는 세계 ID입니다.</target>
        </trans-unit>
        <trans-unit id="aabb41add091cf15de901447942400c30b1d77e5" translate="yes" xml:space="preserve">
          <source>The world ID defining which isolated world the script is executed in. Besides these predefined IDs custom IDs can be used, but must be integers between &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;256&lt;/code&gt;.</source>
          <target state="translated">스크립트가 실행되는 분리 된 월드를 정의하는 월드 ID입니다. 이러한 사전 정의 된 ID 외에도 사용자 정의 ID를 사용할 수 있지만 &lt;code&gt;0&lt;/code&gt; 과 &lt;code&gt;256&lt;/code&gt; 사이의 정수 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="bf52dc6728156d39ad119372194a952dc1459bdb" translate="yes" xml:space="preserve">
          <source>The world used by the page's web contents. It can be useful in order to expose custom functionality to web contents in certain scenarios.</source>
          <target state="translated">페이지의 웹 컨텐츠가 사용하는 세계. 특정 시나리오에서 사용자 정의 기능을 웹 컨텐츠에 노출하는 데 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8681153b4e9e0921f12ec297b99957f0d56c0078" translate="yes" xml:space="preserve">
          <source>The write channel is implicitly opened when &lt;a href=&quot;qprocess#start&quot;&gt;start&lt;/a&gt;() is called.</source>
          <target state="translated">&lt;a href=&quot;qprocess#start&quot;&gt;start&lt;/a&gt; ()가 호출 되면 쓰기 채널이 암시 적으로 열립니다 .</target>
        </trans-unit>
        <trans-unit id="630d7a942a22f4255786aa136bbc6ba34a6120df" translate="yes" xml:space="preserve">
          <source>The writer of the media.</source>
          <target state="translated">미디어 작가.</target>
        </trans-unit>
        <trans-unit id="5c84310d8400224102adb32253c11b5eaa84fc68" translate="yes" xml:space="preserve">
          <source>The wrong way is to use the base class constructor:</source>
          <target state="translated">잘못된 방법은 기본 클래스 생성자를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="aaf592be58c6cc81c57435f1ef902a522f6fd43f" translate="yes" xml:space="preserve">
          <source>The x acceleration of the particle at the beginning of its lifetime.</source>
          <target state="translated">수명이 시작될 때 입자의 x 가속.</target>
        </trans-unit>
        <trans-unit id="3aa4c5a381da7d9977c3f8c6561dbfed85896dc8" translate="yes" xml:space="preserve">
          <source>The x component of the deformation vector along the X axis. &lt;a href=&quot;qml-qtquick-particles-imageparticle&quot;&gt;ImageParticle&lt;/a&gt; can draw particles across non-square shapes. It will draw the texture rectangle across the parallelogram drawn with the x and y deformation vectors.</source>
          <target state="translated">X 축을 따라 변형 벡터의 x 구성 요소입니다. &lt;a href=&quot;qml-qtquick-particles-imageparticle&quot;&gt;ImageParticle&lt;/a&gt; 은 사각형이 아닌 모양에 걸쳐 입자를 그릴 수 있습니다. x 및 y 변형 벡터로 그려진 평행 사변형에 걸쳐 텍스처 사각형을 그립니다.</target>
        </trans-unit>
        <trans-unit id="ae252aa78640b498daa2f6ed0a9e4a9be5367ece" translate="yes" xml:space="preserve">
          <source>The x coordinate of the particle at the beginning of its lifetime.</source>
          <target state="translated">수명이 시작될 때 입자의 x 좌표입니다.</target>
        </trans-unit>
        <trans-unit id="3223b0e58068c9edde115a7bf95df71f7bd05be6" translate="yes" xml:space="preserve">
          <source>The x coordinate of the screen within the virtual desktop.</source>
          <target state="translated">가상 데스크톱 내 화면의 x 좌표입니다.</target>
        </trans-unit>
        <trans-unit id="a2a6c818a14e79b8f5e802512c2199de698f0b01" translate="yes" xml:space="preserve">
          <source>The x coordinate of the top-left corner of the requested tooltip.</source>
          <target state="translated">요청 된 도구 설명의 왼쪽 위 모서리에 대한 x 좌표입니다.</target>
        </trans-unit>
        <trans-unit id="6cdd1eec5d5ce96fba817ee7c527c43dab0990e5" translate="yes" xml:space="preserve">
          <source>The x coordinate of the user action from where the context menu request originates.</source>
          <target state="translated">상황에 맞는 메뉴 요청이 시작된 사용자 작업의 x 좌표입니다.</target>
        </trans-unit>
        <trans-unit id="680a34912ef7770c3874ce1d36a8d9f672714afd" translate="yes" xml:space="preserve">
          <source>The x value of the data point</source>
          <target state="translated">데이터 포인트의 x 값</target>
        </trans-unit>
        <trans-unit id="c04162c3ab5affbcc3c3affbe775f09a8342b316" translate="yes" xml:space="preserve">
          <source>The x velocity of the particle at the beginning of its lifetime.</source>
          <target state="translated">수명이 시작될 때 입자의 x 속도.</target>
        </trans-unit>
        <trans-unit id="dc386e94213c1490990d5da556a77ddcc5c60289" translate="yes" xml:space="preserve">
          <source>The x- and y-values of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95947ac4eb61dcd38836549b6ba51dc5c12c16c8" translate="yes" xml:space="preserve">
          <source>The x-axis label.</source>
          <target state="translated">x 축 레이블.</target>
        </trans-unit>
        <trans-unit id="177a7fa92b3b8a385ab5eb6fbd26985a2ce8f764" translate="yes" xml:space="preserve">
          <source>The x-axis of the</source>
          <target state="translated">x 축</target>
        </trans-unit>
        <trans-unit id="ef8a2d11184ecb705fbadef9722b59868aa8c071" translate="yes" xml:space="preserve">
          <source>The x-axis of the series.</source>
          <target state="translated">시리즈의 x 축입니다.</target>
        </trans-unit>
        <trans-unit id="8becab673d4a32da3d2c05122908151a880017d2" translate="yes" xml:space="preserve">
          <source>The x-axis used for the series, drawn on top of the chart view.</source>
          <target state="translated">차트보기 위에 그려진 시리즈에 사용 된 x 축입니다.</target>
        </trans-unit>
        <trans-unit id="f1e247f08727f9e5ed4269a238d2cc19bea431c8" translate="yes" xml:space="preserve">
          <source>The x-axis used for the series. If you leave both axisX and &lt;a href=&quot;qml-qtcharts-abstractbarseries#axisXTop-prop&quot;&gt;axisXTop&lt;/a&gt; undefined, a &lt;a href=&quot;qml-qtcharts-barcategoryaxis&quot;&gt;BarCategoryAxis&lt;/a&gt; is created for the series.</source>
          <target state="translated">시리즈에 사용 된 x 축입니다. axisX와 &lt;a href=&quot;qml-qtcharts-abstractbarseries#axisXTop-prop&quot;&gt;axisXTop을&lt;/a&gt; 모두 정의 하지 않은 경우 계열에 대해 &lt;a href=&quot;qml-qtcharts-barcategoryaxis&quot;&gt;BarCategoryAxis&lt;/a&gt; 가 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="ff153a07b26fef6597c6f3656d3e612584ed1cee" translate="yes" xml:space="preserve">
          <source>The x-axis used for the series. If you leave both axisX and &lt;a href=&quot;qml-qtcharts-areaseries#axisXTop-prop&quot;&gt;axisXTop&lt;/a&gt; undefined, a value axis is created for the series.</source>
          <target state="translated">시리즈에 사용 된 x 축입니다. axisX와 &lt;a href=&quot;qml-qtcharts-areaseries#axisXTop-prop&quot;&gt;axisXTop을&lt;/a&gt; 모두 정의하지 않으면 계열에 대한 값 축이 만들어집니다.</target>
        </trans-unit>
        <trans-unit id="a41b218710b0d85525bd5d6535c71193444d686a" translate="yes" xml:space="preserve">
          <source>The x-axis used for the series. If you leave both axisX and &lt;a href=&quot;qml-qtcharts-boxplotseries#axisXTop-prop&quot;&gt;axisXTop&lt;/a&gt; undefined, a &lt;a href=&quot;qml-qtcharts-barcategoryaxis&quot;&gt;BarCategoryAxis&lt;/a&gt; is created for the series.</source>
          <target state="translated">시리즈에 사용 된 x 축입니다. axisX와 &lt;a href=&quot;qml-qtcharts-boxplotseries#axisXTop-prop&quot;&gt;axisXTop을&lt;/a&gt; 모두 정의 하지 않은 경우 계열에 대해 &lt;a href=&quot;qml-qtcharts-barcategoryaxis&quot;&gt;BarCategoryAxis&lt;/a&gt; 가 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="014f40fb64be14850619c9d8e188684958c07543" translate="yes" xml:space="preserve">
          <source>The x-axis used for the series. If you leave both axisX and &lt;a href=&quot;qml-qtcharts-candlestickseries#axisXTop-prop&quot;&gt;axisXTop&lt;/a&gt; undefined, a value axis is created for the series.</source>
          <target state="translated">시리즈에 사용 된 x 축입니다. axisX와 &lt;a href=&quot;qml-qtcharts-candlestickseries#axisXTop-prop&quot;&gt;axisXTop을&lt;/a&gt; 모두 정의하지 않으면 계열에 대한 값 축이 만들어집니다.</target>
        </trans-unit>
        <trans-unit id="8d3e1e031b0a76c96bad660b4617c47b94c73d9a" translate="yes" xml:space="preserve">
          <source>The x-axis used for the series. If you leave both axisX and &lt;a href=&quot;qml-qtcharts-xyseries#axisXTop-prop&quot;&gt;axisXTop&lt;/a&gt; undefined, a value axis is created for the series.</source>
          <target state="translated">시리즈에 사용 된 x 축입니다. axisX와 &lt;a href=&quot;qml-qtcharts-xyseries#axisXTop-prop&quot;&gt;axisXTop을&lt;/a&gt; 모두 정의하지 않으면 계열에 대한 값 축이 만들어집니다.</target>
        </trans-unit>
        <trans-unit id="eb16d0673f98426a6d373df1113cb002cf6106b0" translate="yes" xml:space="preserve">
          <source>The x-coordinate of the data point.</source>
          <target state="translated">데이터 포인트의 x 좌표입니다.</target>
        </trans-unit>
        <trans-unit id="daddc355c1d85d4e4a96edd9b711f6a22da8e6c3" translate="yes" xml:space="preserve">
          <source>The x-coordinate of the point.</source>
          <target state="translated">점의 x 좌표</target>
        </trans-unit>
        <trans-unit id="21b8e02ad8f593c9ee3c342edcfa3dbcec447089" translate="yes" xml:space="preserve">
          <source>The x-dimension index into the texture data indicating which vertical slice to show. Setting any dimension to negative indicates no slice or slice frame for that dimension is drawn. If all dimensions are negative, no slices or slice frames are drawn and the volume is drawn normally. Defaults to &lt;code&gt;-1&lt;/code&gt;.</source>
          <target state="translated">표시 할 세로 슬라이스를 나타내는 텍스처 데이터의 x 차원 인덱스입니다. 치수를 음수로 설정하면 해당 치수에 대한 슬라이스 또는 슬라이스 프레임이 그려지지 않습니다. 모든 치수가 음수이면 슬라이스 또는 슬라이스 프레임이 그려지지 않고 볼륨이 정상적으로 그려집니다. 기본값은 &lt;code&gt;-1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1a2708dbe7ab866092bf701cbb4a984c3935ab3c" translate="yes" xml:space="preserve">
          <source>The y acceleration of the particle at the beginning of its lifetime.</source>
          <target state="translated">수명이 시작될 때 입자의 y 가속.</target>
        </trans-unit>
        <trans-unit id="8b5e2c3d1444f9b1c9190d0306402f5388bdbbb7" translate="yes" xml:space="preserve">
          <source>The y component of the deformation vector along the X axis. &lt;a href=&quot;qml-qtquick-particles-imageparticle&quot;&gt;ImageParticle&lt;/a&gt; can draw particles across non-square shapes. It will draw the texture rectangle across the parallelogram drawn with the x and y deformation vectors.</source>
          <target state="translated">X 축을 따라 변형 벡터의 y 구성 요소입니다. &lt;a href=&quot;qml-qtquick-particles-imageparticle&quot;&gt;ImageParticle&lt;/a&gt; 은 사각형이 아닌 모양에 걸쳐 입자를 그릴 수 있습니다. x 및 y 변형 벡터로 그려진 평행 사변형에 걸쳐 텍스처 사각형을 그립니다.</target>
        </trans-unit>
        <trans-unit id="5ba26afc2ba46da1fce6ed04bc060570682a1342" translate="yes" xml:space="preserve">
          <source>The y component of the deformation vector along the Y axis. &lt;a href=&quot;qml-qtquick-particles-imageparticle&quot;&gt;ImageParticle&lt;/a&gt; can draw particles across non-square shapes. It will draw the texture rectangle across the parallelogram drawn with the x and y deformation vectors.</source>
          <target state="translated">Y 축을 따라 변형 벡터의 y 구성 요소입니다. &lt;a href=&quot;qml-qtquick-particles-imageparticle&quot;&gt;ImageParticle&lt;/a&gt; 은 사각형이 아닌 모양에 걸쳐 입자를 그릴 수 있습니다. x 및 y 변형 벡터로 그려진 평행 사변형에 걸쳐 텍스처 사각형을 그립니다.</target>
        </trans-unit>
        <trans-unit id="b0ce58e6dd3ade666bc97f0800bb36184c0d7a71" translate="yes" xml:space="preserve">
          <source>The y coordinate of the particle at the beginning of its lifetime.</source>
          <target state="translated">수명이 시작될 때 입자의 y 좌표입니다.</target>
        </trans-unit>
        <trans-unit id="d63c8b2d8419fd618c5c3b4138e652b4c9546818" translate="yes" xml:space="preserve">
          <source>The y coordinate of the screen within the virtual desktop.</source>
          <target state="translated">가상 데스크톱 내 화면의 y 좌표입니다.</target>
        </trans-unit>
        <trans-unit id="fcf9d28949288f83748c2b9a01545bd4f12c82ef" translate="yes" xml:space="preserve">
          <source>The y coordinate of the top-left corner of the requested tooltip.</source>
          <target state="translated">요청 된 도구 설명의 왼쪽 위 모서리에 대한 y 좌표입니다.</target>
        </trans-unit>
        <trans-unit id="33ebc8ea7ce2b727a4b590f540baaddbef30447a" translate="yes" xml:space="preserve">
          <source>The y coordinate of the user action from where the context menu request originates.</source>
          <target state="translated">컨텍스트 메뉴 요청이 시작된 사용자 조치의 y 좌표입니다.</target>
        </trans-unit>
        <trans-unit id="f39f47a9ffce5974e4c4cbad68bd867121542f42" translate="yes" xml:space="preserve">
          <source>The y value of the data point</source>
          <target state="translated">데이터 포인트의 y 값</target>
        </trans-unit>
        <trans-unit id="6588a9942497fbceab622360db01584fafcf4889" translate="yes" xml:space="preserve">
          <source>The y velocity of the particle at the beginning of its lifetime.</source>
          <target state="translated">수명이 시작될 때 입자의 y 속도.</target>
        </trans-unit>
        <trans-unit id="0b47b676c9aa9633cbc86bdd5a22265ccbbabca1" translate="yes" xml:space="preserve">
          <source>The y-axis label.</source>
          <target state="translated">y 축 레이블.</target>
        </trans-unit>
        <trans-unit id="ec05851125397cadf9ca0dc742dcb56029c8d217" translate="yes" xml:space="preserve">
          <source>The y-axis of the</source>
          <target state="translated">Y 축</target>
        </trans-unit>
        <trans-unit id="1da2e9745f86c5ff176beb5de4a86b79d7346d70" translate="yes" xml:space="preserve">
          <source>The y-axis of the series.</source>
          <target state="translated">시리즈의 y 축입니다.</target>
        </trans-unit>
        <trans-unit id="ab817e58f1961df021a6b45f5f97ebb8e998cffa" translate="yes" xml:space="preserve">
          <source>The y-axis used for the series, drawn to the right of the chart view.</source>
          <target state="translated">차트보기의 오른쪽에 그려진 시리즈에 사용 된 y 축.</target>
        </trans-unit>
        <trans-unit id="5accb8750727eb5f5434bab2c53ae555afaac210" translate="yes" xml:space="preserve">
          <source>The y-axis used for the series, drawn to the right on the chart view.</source>
          <target state="translated">차트보기에서 오른쪽에 그려진 시리즈에 사용 된 y 축.</target>
        </trans-unit>
        <trans-unit id="2d68b81f36218871943da44e2dd4bb85d9c984b9" translate="yes" xml:space="preserve">
          <source>The y-axis used for the series. If you leave both axisY and &lt;a href=&quot;qml-qtcharts-abstractbarseries#axisYRight-prop&quot;&gt;axisYRight&lt;/a&gt; undefined, a &lt;a href=&quot;qml-qtcharts-valueaxis&quot;&gt;ValueAxis&lt;/a&gt; is created for the series.</source>
          <target state="translated">시리즈에 사용 된 y 축. axisY와 &lt;a href=&quot;qml-qtcharts-abstractbarseries#axisYRight-prop&quot;&gt;axisYRight를&lt;/a&gt; 모두 정의 하지 않은 경우 계열에 대해 &lt;a href=&quot;qml-qtcharts-valueaxis&quot;&gt;ValueAxis&lt;/a&gt; 가 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="e7c1aaebe50c07328983ca429a8489c0658adefd" translate="yes" xml:space="preserve">
          <source>The y-axis used for the series. If you leave both axisY and &lt;a href=&quot;qml-qtcharts-areaseries#axisYRight-prop&quot;&gt;axisYRight&lt;/a&gt; undefined, a value axis is created for the series.</source>
          <target state="translated">시리즈에 사용 된 y 축. axisY와 &lt;a href=&quot;qml-qtcharts-areaseries#axisYRight-prop&quot;&gt;axisYRight를&lt;/a&gt; 모두 정의하지 않으면 계열에 대해 값 축이 만들어집니다.</target>
        </trans-unit>
        <trans-unit id="35b2f4d3c3d18b01a4894411492a14640b189043" translate="yes" xml:space="preserve">
          <source>The y-axis used for the series. If you leave both axisY and &lt;a href=&quot;qml-qtcharts-boxplotseries#axisYRight-prop&quot;&gt;axisYRight&lt;/a&gt; undefined, a &lt;a href=&quot;qml-qtcharts-valueaxis&quot;&gt;ValueAxis&lt;/a&gt; is created for the series.</source>
          <target state="translated">시리즈에 사용 된 y 축. axisY와 &lt;a href=&quot;qml-qtcharts-boxplotseries#axisYRight-prop&quot;&gt;axisYRight를&lt;/a&gt; 모두 정의 하지 않은 경우 계열에 대해 &lt;a href=&quot;qml-qtcharts-valueaxis&quot;&gt;ValueAxis&lt;/a&gt; 가 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="992d3d742f67732ed0ff9cfce4aa707f8f7610e9" translate="yes" xml:space="preserve">
          <source>The y-axis used for the series. If you leave both axisY and &lt;a href=&quot;qml-qtcharts-candlestickseries#axisYRight-prop&quot;&gt;axisYRight&lt;/a&gt; undefined, a value axis is created for the series.</source>
          <target state="translated">시리즈에 사용 된 y 축. axisY와 &lt;a href=&quot;qml-qtcharts-candlestickseries#axisYRight-prop&quot;&gt;axisYRight를&lt;/a&gt; 모두 정의하지 않으면 계열에 대해 값 축이 만들어집니다.</target>
        </trans-unit>
        <trans-unit id="3f1fa1b80b90bb82939ee0ca5b8a24710a43ef2a" translate="yes" xml:space="preserve">
          <source>The y-axis used for the series. If you leave both axisY and &lt;a href=&quot;qml-qtcharts-xyseries#axisYRight-prop&quot;&gt;axisYRight&lt;/a&gt; undefined, a value axis is created for the series.</source>
          <target state="translated">시리즈에 사용 된 y 축. axisY와 &lt;a href=&quot;qml-qtcharts-xyseries#axisYRight-prop&quot;&gt;axisYRight를&lt;/a&gt; 모두 정의하지 않으면 계열에 대해 값 축이 만들어집니다.</target>
        </trans-unit>
        <trans-unit id="76772e6571c316658e5b1290d816652ca8f1802b" translate="yes" xml:space="preserve">
          <source>The y-coordinate of the data point.</source>
          <target state="translated">데이터 포인트의 y 좌표</target>
        </trans-unit>
        <trans-unit id="d125d2a49e448a2ffa0cc4467c600f308dfb4e90" translate="yes" xml:space="preserve">
          <source>The y-coordinate of the point.</source>
          <target state="translated">점의 y 좌표</target>
        </trans-unit>
        <trans-unit id="e00b09349b74b24e1105bd69d7ee803892aa0ca2" translate="yes" xml:space="preserve">
          <source>The y-dimension index into the texture data indicating which horizontal slice to show. Setting any dimension to negative indicates no slice or slice frame for that dimension is drawn. If all dimensions are negative, no slices or slice frames are drawn and the volume is drawn normally. Defaults to &lt;code&gt;-1&lt;/code&gt;.</source>
          <target state="translated">표시 할 가로 슬라이스를 나타내는 텍스처 데이터에 대한 y- 차원 인덱스입니다. 치수를 음수로 설정하면 해당 치수에 대한 슬라이스 또는 슬라이스 프레임이 그려지지 않습니다. 모든 치수가 음수이면 슬라이스 또는 슬라이스 프레임이 그려지지 않고 볼륨이 정상적으로 그려집니다. 기본값은 &lt;code&gt;-1&lt;/code&gt; 입니다. 입니다.</target>
        </trans-unit>
        <trans-unit id="9f45189e2a0a4e5f2bb7342a2aedaf48225de566" translate="yes" xml:space="preserve">
          <source>The year as a four digit number, possibly plus a leading minus sign for negative years.</source>
          <target state="translated">네 자리 숫자로 된 연도입니다. 음수 연도에 선행 마이너스 부호를 더할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c758b521721873952d5fdc0f9e7855ac32a7bf8b" translate="yes" xml:space="preserve">
          <source>The year as a four digit number. If the year is negative, a minus sign is prepended, making five characters.</source>
          <target state="translated">4 자리 숫자로 된 연도입니다. 연도가 음수이면 마이너스 기호가 앞에 추가되어 5자를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="914505c8d61b4bc830da8e4692e8e8617dfddca8" translate="yes" xml:space="preserve">
          <source>The year as a two digit number (00 to 99)</source>
          <target state="translated">두 자리 숫자로 된 연도 (00-99)</target>
        </trans-unit>
        <trans-unit id="1def7ba56751c831db57ca991967221dea4b984d" translate="yes" xml:space="preserve">
          <source>The year as four digit number. If the year is negative, a minus sign is prepended in addition.</source>
          <target state="translated">4 자리 숫자의 연도입니다. 연도가 음수이면 빼기 부호가 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="2dc9a4d03a398c6f316b09690a5461b52b16b66c" translate="yes" xml:space="preserve">
          <source>The year as two digit number (00 to 99)</source>
          <target state="translated">두 자리 숫자로 된 연도 (00 ~ 99)</target>
        </trans-unit>
        <trans-unit id="45376824575c40c58ea76daa229c945c38532f6b" translate="yes" xml:space="preserve">
          <source>The year of release of the media.</source>
          <target state="translated">미디어 출시 연도.</target>
        </trans-unit>
        <trans-unit id="4c971f07bd60c6bb5e619ef1cba55822e6e00852" translate="yes" xml:space="preserve">
          <source>The you can call it from C++ using the following JNI call:</source>
          <target state="translated">다음 JNI 호출을 사용하여 C ++에서 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="833d8387061d50439942a8596c12cf6a4ccb9cdb" translate="yes" xml:space="preserve">
          <source>The z-axis label.</source>
          <target state="translated">z 축 레이블.</target>
        </trans-unit>
        <trans-unit id="d86373e2f4596359fcbbd9e8f6b9c7f41d2db9b6" translate="yes" xml:space="preserve">
          <source>The z-dimension index into the texture data indicating which vertical slice to show. Setting any dimension to negative indicates no slice or slice frame for that dimension is drawn. If all dimensions are negative, no slices or slice frames are drawn and the volume is drawn normally. Defaults to &lt;code&gt;-1&lt;/code&gt;.</source>
          <target state="translated">표시 할 세로 슬라이스를 나타내는 텍스처 데이터에 대한 z- 차원 인덱스입니다. 치수를 음수로 설정하면 해당 치수에 대한 슬라이스 또는 슬라이스 프레임이 그려지지 않습니다. 모든 치수가 음수이면 슬라이스 또는 슬라이스 프레임이 그려지지 않고 볼륨이 정상적으로 그려집니다. 기본값은 &lt;code&gt;-1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="896fd7a2d0900bab566d199cb6734daa1e1bc493" translate="yes" xml:space="preserve">
          <source>The zoom is set to a custom zoom value.</source>
          <target state="translated">확대 / 축소가 사용자 정의 확대 / 축소 값으로 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="45990648da0df9b9c787156094be6131ca9384fb" translate="yes" xml:space="preserve">
          <source>Theatre exposure mode. Since 5.5</source>
          <target state="translated">극장 노출 모드. 5.5 이후</target>
        </trans-unit>
        <trans-unit id="696bf6d96b03365591a843762a690a97d18982ac" translate="yes" xml:space="preserve">
          <source>Theatre mode. Since 5.5</source>
          <target state="translated">극장 모드. 5.5 이후</target>
        </trans-unit>
        <trans-unit id="f7b9cc3bdc500db727cc854609daff076d6e6311" translate="yes" xml:space="preserve">
          <source>Their usage is much cheaper than e.g. passing a string to &lt;a href=&quot;qcolor&quot;&gt;QColor&lt;/a&gt;'s constructor, as they don't require any parsing of the string, and always result in a valid &lt;a href=&quot;qcolor&quot;&gt;QColor&lt;/a&gt; object:</source>
          <target state="translated">그들의 사용법은 문자열을 구문 분석 할 필요가없고 항상 유효한 &lt;a href=&quot;qcolor&quot;&gt;QColor&lt;/a&gt; 객체를 생성 하기 때문에 &lt;a href=&quot;qcolor&quot;&gt;QColor&lt;/a&gt; 의 생성자에 문자열을 전달하는 것보다 훨씬 저렴 합니다.</target>
        </trans-unit>
        <trans-unit id="df7edbb3e53267676265d7e1f4f6d7e6a333bb2a" translate="yes" xml:space="preserve">
          <source>Theme icons are referenced by a name, and regular icons by a source URL. Both &lt;code&gt;icon.name&lt;/code&gt; and &lt;code&gt;icon.source&lt;/code&gt; can be set to ensure that an icon will always be found. If the icon is found in the theme, it will always be used; even if &lt;code&gt;icon.source&lt;/code&gt; is also set. If the icon is not found in the theme, &lt;code&gt;icon.source&lt;/code&gt; will be used instead.</source>
          <target state="translated">테마 아이콘은 이름으로, 일반 아이콘은 소스 URL로 참조합니다. 두 &lt;code&gt;icon.name&lt;/code&gt; 및 &lt;code&gt;icon.source&lt;/code&gt; 이 아이콘은 항상 찾을 수 있도록 설정할 수 있습니다. 테마에 아이콘이 있으면 항상 사용됩니다. &lt;code&gt;icon.source&lt;/code&gt; 도 설정되어 있어도 테마에 아이콘이 없으면 &lt;code&gt;icon.source&lt;/code&gt; 가 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5ae735fbe3bf25c43e09323d9f5d284b6ff864ab" translate="yes" xml:space="preserve">
          <source>Theme3D</source>
          <target state="translated">Theme3D</target>
        </trans-unit>
        <trans-unit id="4231c0e53251101272331821ce9fd6bd90b107cc" translate="yes" xml:space="preserve">
          <source>Theme3D (QML type)</source>
          <target state="translated">Theme3D (QML 유형)</target>
        </trans-unit>
        <trans-unit id="9aef57aed64f69ba61021e46e8f0dc24d42e77d6" translate="yes" xml:space="preserve">
          <source>Theme3D QML Type</source>
          <target state="translated">Theme3D QML 유형</target>
        </trans-unit>
        <trans-unit id="a71a9a7cce34799f923d5003a0f929fa1cce3b93" translate="yes" xml:space="preserve">
          <source>Theme3D.ambientLightStrength</source>
          <target state="translated">Theme3D.ambientLightStrength</target>
        </trans-unit>
        <trans-unit id="1ee72b0a750cf2f2ee5470dc4eda5306e313e30c" translate="yes" xml:space="preserve">
          <source>Theme3D.backgroundColor</source>
          <target state="translated">Theme3D.backgroundColor</target>
        </trans-unit>
        <trans-unit id="77e38dfb21557c5999944e49b3e27723d7fa7bd2" translate="yes" xml:space="preserve">
          <source>Theme3D.backgroundEnabled</source>
          <target state="translated">Theme3D.backgroundEnabled</target>
        </trans-unit>
        <trans-unit id="189d4c2e3592b9620a9875b6c3d3efabdbaceacc" translate="yes" xml:space="preserve">
          <source>Theme3D.baseColors</source>
          <target state="translated">Theme3D.baseColors</target>
        </trans-unit>
        <trans-unit id="9f3176e1bc86133515e41a64c976080c604c2adb" translate="yes" xml:space="preserve">
          <source>Theme3D.baseGradients</source>
          <target state="translated">Theme3D.baseGradients</target>
        </trans-unit>
        <trans-unit id="ff6cc0d0991b43ced2ece172ebef7da80a015145" translate="yes" xml:space="preserve">
          <source>Theme3D.colorStyle</source>
          <target state="translated">Theme3D.colorStyle</target>
        </trans-unit>
        <trans-unit id="d421b7c88cdc2a0f386735e6c9ae6ae5ef861e06" translate="yes" xml:space="preserve">
          <source>Theme3D.font</source>
          <target state="translated">Theme3D.font</target>
        </trans-unit>
        <trans-unit id="500c5a91e6afaba14d350095693a703cdae0a84c" translate="yes" xml:space="preserve">
          <source>Theme3D.gridEnabled</source>
          <target state="translated">Theme3D.gridEnabled</target>
        </trans-unit>
        <trans-unit id="5bfe26e4664c1870d32745a271fcc7afe3d6779b" translate="yes" xml:space="preserve">
          <source>Theme3D.gridLineColor</source>
          <target state="translated">Theme3D.gridLineColor</target>
        </trans-unit>
        <trans-unit id="36c7f473484f4e5831b1072882ae8cc4d843ac6a" translate="yes" xml:space="preserve">
          <source>Theme3D.highlightLightStrength</source>
          <target state="translated">Theme3D.highlightLightStrength</target>
        </trans-unit>
        <trans-unit id="b29d51a72ecf86c3e7fe840f97049193b11190a4" translate="yes" xml:space="preserve">
          <source>Theme3D.labelBackgroundColor</source>
          <target state="translated">Theme3D.labelBackgroundColor</target>
        </trans-unit>
        <trans-unit id="209462dcbfdec696bd1567f71d8e6c689002f1c0" translate="yes" xml:space="preserve">
          <source>Theme3D.labelBackgroundEnabled</source>
          <target state="translated">Theme3D.labelBackgroundEnabled</target>
        </trans-unit>
        <trans-unit id="1e8b45a06e881f111bdd23699601fb6e6980e135" translate="yes" xml:space="preserve">
          <source>Theme3D.labelBorderEnabled</source>
          <target state="translated">Theme3D.labelBorderEnabled</target>
        </trans-unit>
        <trans-unit id="806782f3d78da5e1a4c4b110e92bc8312bf0cd66" translate="yes" xml:space="preserve">
          <source>Theme3D.labelTextColor</source>
          <target state="translated">Theme3D.labelTextColor</target>
        </trans-unit>
        <trans-unit id="e6126c7ccac1fb4f18043031f1e25a8ed93280bc" translate="yes" xml:space="preserve">
          <source>Theme3D.lightColor</source>
          <target state="translated">Theme3D.lightColor</target>
        </trans-unit>
        <trans-unit id="6fa7c8b7162924183f3ff7dc9d8de5a06d073864" translate="yes" xml:space="preserve">
          <source>Theme3D.lightStrength</source>
          <target state="translated">Theme3D.lightStrength</target>
        </trans-unit>
        <trans-unit id="701a1c13b58876b605b6f1a140417db38abf60c8" translate="yes" xml:space="preserve">
          <source>Theme3D.multiHighlightColor</source>
          <target state="translated">Theme3D.multiHighlightColor</target>
        </trans-unit>
        <trans-unit id="b4aba52ee456878c02417511bc8765055faff3cf" translate="yes" xml:space="preserve">
          <source>Theme3D.multiHighlightGradient</source>
          <target state="translated">Theme3D.multiHighlightGradient</target>
        </trans-unit>
        <trans-unit id="dc14fd31ee58317fdb697965ff2de5cbc01a5442" translate="yes" xml:space="preserve">
          <source>Theme3D.singleHighlightColor</source>
          <target state="translated">Theme3D.singleHighlightColor</target>
        </trans-unit>
        <trans-unit id="c3b2d14cb4e3500503327b7313c93a0065a5c020" translate="yes" xml:space="preserve">
          <source>Theme3D.singleHighlightGradient</source>
          <target state="translated">Theme3D.singleHighlightGradient</target>
        </trans-unit>
        <trans-unit id="cbff38389ce0139669970cb3104e6bf86edf9b1e" translate="yes" xml:space="preserve">
          <source>Theme3D.type</source>
          <target state="translated">Theme3D.type</target>
        </trans-unit>
        <trans-unit id="ada008d972257dbf666c86e350a106c4e1d297d2" translate="yes" xml:space="preserve">
          <source>Theme3D.windowColor</source>
          <target state="translated">Theme3D.windowColor</target>
        </trans-unit>
        <trans-unit id="69ecfa5b732efb8d2d194c734f325ec568ebc913" translate="yes" xml:space="preserve">
          <source>ThemeColor (QML type)</source>
          <target state="translated">ThemeColor (QML 유형)</target>
        </trans-unit>
        <trans-unit id="04451c71c3d36bc783d1fc2aad74fa775ec86a8f" translate="yes" xml:space="preserve">
          <source>ThemeColor QML Type</source>
          <target state="translated">ThemeColor QML 유형</target>
        </trans-unit>
        <trans-unit id="a6459aa98a24abf4a27b3018e1c2a889c09d817f" translate="yes" xml:space="preserve">
          <source>ThemeColor.color</source>
          <target state="translated">ThemeColor.color</target>
        </trans-unit>
        <trans-unit id="3d6f826f75d0ed97cc0aa3b9ca84ea0b48f73994" translate="yes" xml:space="preserve">
          <source>Themes can be created from scratch by using the &lt;a href=&quot;q3dtheme#Theme-enum&quot;&gt;Theme3D.ThemeUserDefined&lt;/a&gt; enum value.</source>
          <target state="translated">&lt;a href=&quot;q3dtheme#Theme-enum&quot;&gt;Theme3D&lt;/a&gt; 를 사용하여 테마를 처음부터 만들 수 있습니다. 열거 형 값 .</target>
        </trans-unit>
        <trans-unit id="1fc38f4b62e12e3d4211b2c94b17264f8e44a3af" translate="yes" xml:space="preserve">
          <source>Themes can be created from scratch using the &lt;a href=&quot;q3dtheme#Theme-enum&quot;&gt;ThemeUserDefined&lt;/a&gt; enum value. Creating a theme using the default constructor produces a new user-defined theme.</source>
          <target state="translated">&lt;a href=&quot;q3dtheme#Theme-enum&quot;&gt;ThemeUserDefined를&lt;/a&gt; 사용하여 처음부터 테마를 작성할 수 있습니다. 열거 형 값을 . 기본 생성자를 사용하여 테마를 만들면 새로운 사용자 정의 테마가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="05f5cf06248ce9809e34ceebb6a571da506b5f3d" translate="yes" xml:space="preserve">
          <source>Then call &lt;a href=&quot;qstaticbytearraymatcher#indexIn&quot;&gt;indexIn&lt;/a&gt;() on the &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; in which you want to search, just like with &lt;a href=&quot;qbytearraymatcher&quot;&gt;QByteArrayMatcher&lt;/a&gt;.</source>
          <target state="translated">그런 다음 &lt;a href=&quot;qstaticbytearraymatcher#indexIn&quot;&gt;QByteArrayMatcher&lt;/a&gt; 와 마찬가지로 검색하려는 &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; 에서 indexIn ()을 호출 &lt;a href=&quot;qbytearraymatcher&quot;&gt;하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="383abdd20e36bb058d92131140767c8a1bef0f8d" translate="yes" xml:space="preserve">
          <source>Then cloning an identity is a more complex operation than copying or assigning a value. We can see what this means in the Qt Object Model.</source>
          <target state="translated">그런 다음 아이덴티티 복제는 값을 복사하거나 할당하는 것보다 더 복잡한 작업입니다. Qt 개체 모델에서 이것이 무엇을 의미하는지 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="05611e9fd5943c1fc4a51cf5dc8b92cf236229dc" translate="yes" xml:space="preserve">
          <source>Then instance can be used to find the available instances of Shape.</source>
          <target state="translated">그런 다음 인스턴스를 사용하여 사용 가능한 Shape 인스턴스를 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f032c0d610f7cabda144a167a350d790ad5bc295" translate="yes" xml:space="preserve">
          <source>Then invoke the &lt;a href=&quot;qml-qtlocation-place#save-method&quot;&gt;save()&lt;/a&gt; method:</source>
          <target state="translated">그런 다음 &lt;a href=&quot;qml-qtlocation-place#save-method&quot;&gt;save ()&lt;/a&gt; 메소드를 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="ba5c3bd717d436fa4fff03217b4edd0e790da89c" translate="yes" xml:space="preserve">
          <source>Then it will read through the sources specified in the &lt;a href=&quot;#sources&quot;&gt;&lt;code&gt;sources&lt;/code&gt;&lt;/a&gt;, and the ones located in the directories specified in the &lt;a href=&quot;#sourcedirs&quot;&gt;&lt;code&gt;sourcedirs&lt;/code&gt;&lt;/a&gt; variable (including all subdirectories), merging the documentation with the structure it retrieved from the header files.</source>
          <target state="translated">그런 다음 source에 지정된 &lt;a href=&quot;#sources&quot;&gt; &lt;code&gt;sources&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;#sourcedirs&quot;&gt; &lt;code&gt;sourcedirs&lt;/code&gt; 에&lt;/a&gt; 지정된 디렉토리 에있는 소스 를 읽습니다. 변수에 (모든 서브 디렉토리 포함) 문서를 헤더 파일에서 검색 한 구조와 병합합니다.</target>
        </trans-unit>
        <trans-unit id="102617e836232138c636f20672e81fc879d34071" translate="yes" xml:space="preserve">
          <source>Then it will read through the sources specified in the &lt;a href=&quot;#sources-variable&quot;&gt;&lt;code&gt;sources&lt;/code&gt;&lt;/a&gt;, and the ones located in the directories specified in the &lt;a href=&quot;#sourcedirs-variable&quot;&gt;&lt;code&gt;sourcedirs&lt;/code&gt;&lt;/a&gt; varible (including all subdirectories), merging the documentation with the structure it retrieved from the header files.</source>
          <target state="translated">그런 다음 source에 지정된 &lt;a href=&quot;#sources-variable&quot;&gt; &lt;code&gt;sources&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;#sourcedirs-variable&quot;&gt; &lt;code&gt;sourcedirs&lt;/code&gt; &lt;/a&gt; varible (모든 서브 디렉토리 포함)에 지정된 디렉토리 에있는 소스 를 읽고 문서를 헤더 파일에서 검색 한 구조와 병합합니다.</target>
        </trans-unit>
        <trans-unit id="a120f507989b81756c054b5d7dcbfba4f0ff97bd" translate="yes" xml:space="preserve">
          <source>Then it will read through the sources specified in the &lt;a href=&quot;22-qdoc-configuration-generalvariables#sources&quot;&gt;&lt;code&gt;sources&lt;/code&gt;&lt;/a&gt;, and the ones located in the directories specified in the &lt;a href=&quot;22-qdoc-configuration-generalvariables#sourcedirs&quot;&gt;&lt;code&gt;sourcedirs&lt;/code&gt;&lt;/a&gt; variable (including all subdirectories), merging the documentation with the structure it retrieved from the header files.</source>
          <target state="translated">그런 다음 sources에 지정된 &lt;a href=&quot;22-qdoc-configuration-generalvariables#sources&quot;&gt; &lt;code&gt;sources&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;22-qdoc-configuration-generalvariables#sourcedirs&quot;&gt; &lt;code&gt;sourcedirs&lt;/code&gt; &lt;/a&gt; 변수 (모든 하위 디렉터리 포함)에 지정된 디렉터리 에있는 소스 를 읽고 헤더 파일에서 검색 한 구조와 문서를 병합합니다.</target>
        </trans-unit>
        <trans-unit id="768798b8d4feaf9d150b3a4f9081cfc08b8a5c2e" translate="yes" xml:space="preserve">
          <source>Then it will read through the sources specified in the &lt;a href=&quot;22-qdoc-configuration-generalvariables#sources-variable&quot;&gt;&lt;code&gt;sources&lt;/code&gt;&lt;/a&gt;, and the ones located in the directories specified in the &lt;a href=&quot;22-qdoc-configuration-generalvariables#sourcedirs-variable&quot;&gt;&lt;code&gt;sourcedirs&lt;/code&gt;&lt;/a&gt; varible (including all subdirectories), merging the documentation with the structure it retrieved from the header files.</source>
          <target state="translated">그런 다음 sources에 지정된 &lt;a href=&quot;22-qdoc-configuration-generalvariables#sources-variable&quot;&gt; &lt;code&gt;sources&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;22-qdoc-configuration-generalvariables#sourcedirs-variable&quot;&gt; &lt;code&gt;sourcedirs&lt;/code&gt; &lt;/a&gt; 변수 (모든 하위 디렉터리 포함)에 지정된 디렉터리 에있는 소스 를 읽고 헤더 파일에서 검색 한 구조와 문서를 병합합니다.</target>
        </trans-unit>
        <trans-unit id="4d4ead9f653fece10439374e1f626e8f33856a06" translate="yes" xml:space="preserve">
          <source>Then make sure the service &lt;code&gt;android.app.lib_name&lt;/code&gt; is the same as the main activity, add the following:</source>
          <target state="translated">그런 다음 &lt;code&gt;android.app.lib_name&lt;/code&gt; 서비스 가 기본 활동과 동일한 지 확인 하고 다음을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="a747f578c0a17b797289c1059f32462a2eccc7c4" translate="yes" xml:space="preserve">
          <source>Then only one thread can modify &lt;code&gt;number&lt;/code&gt; at any given time and the result is correct. This is a trivial example, of course, but applies to any other case where things need to happen in a particular sequence.</source>
          <target state="translated">그러면 주어진 시간에 하나의 스레드 만 &lt;code&gt;number&lt;/code&gt; 를 수정할 수 있으며 결과는 정확합니다. 이것은 물론 사소한 예이지만 특정 순서로 상황이 발생해야하는 다른 모든 경우에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="feb65858c408152200de789e1b368621b12ea133" translate="yes" xml:space="preserve">
          <source>Then read it in with:</source>
          <target state="translated">그런 다음 함께 읽어보십시오.</target>
        </trans-unit>
        <trans-unit id="6c8000bad5674b0f15dbed149655667c236aa09b" translate="yes" xml:space="preserve">
          <source>Then runs through the available window flags, creating a text that contains the names of the flags that matches the flags parameter, displaying the text in the widgets text editor.</source>
          <target state="translated">그런 다음 사용 가능한 창 플래그를 통해 실행하여 flags 매개 변수와 일치하는 플래그 이름이 포함 된 텍스트를 만들고 위젯 텍스트 편집기에 텍스트를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="45781a8a5a099be07e36d8c50c7ec958ffc77e2e" translate="yes" xml:space="preserve">
          <source>Then set the environment variable in your main.ccp file:</source>
          <target state="translated">그런 다음 main.ccp 파일에서 환경 변수를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="d8905dc36c39be294f0118bbac7e531b3b52ebf1" translate="yes" xml:space="preserve">
          <source>Then the</source>
          <target state="translated">그런 다음</target>
        </trans-unit>
        <trans-unit id="45bee226a193a27e5612e8ebf7cdaaefb76cb9d7" translate="yes" xml:space="preserve">
          <source>Then the custom slot can check if the new value is within the range we want when a specified property, belonging to a particular widget, changes:</source>
          <target state="translated">그런 다음 사용자 정의 슬롯은 특정 위젯에 속하는 지정된 특성이 변경 될 때 새 값이 원하는 범위 내에 있는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c96cb10b8ee59f279477c63ab37c2a709c550852" translate="yes" xml:space="preserve">
          <source>Then the list of child nodes for the &quot;body&quot;-element will contain the node created by the &amp;amp;lt;h1&amp;amp;gt; tag and the node created by the &amp;amp;lt;p&amp;amp;gt; tag.</source>
          <target state="translated">&quot;body&quot;-요소에 대한 자식 노드의 목록은 &amp;amp; lt; h1 &amp;amp; gt; 태그 및 &amp;amp; lt; p &amp;amp; gt; 꼬리표.</target>
        </trans-unit>
        <trans-unit id="9f2d99f6b712818bf4ab61dda7d1b297db014a29" translate="yes" xml:space="preserve">
          <source>Then there is the &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt; item. When adding it under a &lt;a href=&quot;qml-qtquick3d-node&quot;&gt;Node&lt;/a&gt;, the boundaries of the 3D and 2D world are crossed internally, but this remains transparent to the application designer. An invisible &lt;code&gt;content item&lt;/code&gt; is generated automatically, allowing the Rectangle to refer to &lt;code&gt;parent&lt;/code&gt; and perform anchoring. The 3D transform from the Node is applied to the entire 2D subtree. In the example this means that the rotation will match the cube's rotation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e9307fc06f292ab35d143feaa41ea450f2536c5" translate="yes" xml:space="preserve">
          <source>Then this model would be automatically loaded into the &lt;a href=&quot;qml-qtquick-listview&quot;&gt;ListView&lt;/a&gt; in the previous document.</source>
          <target state="translated">그런 다음이 모델은 이전 문서 의 &lt;a href=&quot;qml-qtquick-listview&quot;&gt;ListView&lt;/a&gt; 에 자동으로로드됩니다 .</target>
        </trans-unit>
        <trans-unit id="c0a1ee78980c91b3598c79e02a3758e0d522ac07" translate="yes" xml:space="preserve">
          <source>Then use the following line to check if SSL is supported:</source>
          <target state="translated">그런 다음 다음 줄을 사용하여 SSL이 지원되는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="381e7b58503289117d6f14dbd95b1a7f3dd87e78" translate="yes" xml:space="preserve">
          <source>Then we create a &lt;a href=&quot;qpushbutton&quot;&gt;QPushButton&lt;/a&gt;, and give it a reasonable size using the &lt;a href=&quot;qwidget#size-prop&quot;&gt;QWidget::resize&lt;/a&gt;() function.</source>
          <target state="translated">그런 다음 &lt;a href=&quot;qpushbutton&quot;&gt;QPushButton&lt;/a&gt; 을 만들고 &lt;a href=&quot;qwidget#size-prop&quot;&gt;QWidget :: resize&lt;/a&gt; () 함수를 사용하여 적절한 크기를 지정하십시오 .</target>
        </trans-unit>
        <trans-unit id="f2e29ca133b9a055ef29f6568dea5dd583a8f3f0" translate="yes" xml:space="preserve">
          <source>Then we define two functions that iterate over the layout: &lt;code&gt;itemAt()&lt;/code&gt; and &lt;code&gt;takeAt()&lt;/code&gt;. These functions are used internally by the layout system to handle deletion of widgets. They are also available for application programmers.</source>
          <target state="translated">그런 다음 레이아웃을 반복하는 &lt;code&gt;itemAt()&lt;/code&gt; 및 &lt;code&gt;takeAt()&lt;/code&gt; 함수를 정의 합니다. 이러한 기능은 레이아웃 시스템에서 내부적으로 위젯 삭제를 처리하는 데 사용됩니다. 응용 프로그램 프로그래머도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf72ba83bc44c344fde553f82c5448c47ad3915e" translate="yes" xml:space="preserve">
          <source>Then we set a style sheet on a &lt;a href=&quot;qpushbutton&quot;&gt;QPushButton&lt;/a&gt; object:</source>
          <target state="translated">그런 다음 &lt;a href=&quot;qpushbutton&quot;&gt;QPushButton&lt;/a&gt; 객체 에 스타일 시트를 설정 합니다.</target>
        </trans-unit>
        <trans-unit id="55c64ba86aa40bc6dacb1404778b5a576b81e009" translate="yes" xml:space="preserve">
          <source>Then when &lt;a href=&quot;qml-qtquick-xmllistmodel-xmllistmodel#reload-method&quot;&gt;reload()&lt;/a&gt; is called, the model will only add and reload items with a &quot;pubDate&quot; value that is not already present in the model.</source>
          <target state="translated">그런 다음 &lt;a href=&quot;qml-qtquick-xmllistmodel-xmllistmodel#reload-method&quot;&gt;reload ()&lt;/a&gt; 가 호출되면 모델은 아직 모델에없는 &quot;pubDate&quot;값을 가진 항목 만 추가하고 다시로드합니다.</target>
        </trans-unit>
        <trans-unit id="bb29bfa03053b4b8a21d9696e859c24b9a2da52f" translate="yes" xml:space="preserve">
          <source>Then you can instantiate it in QML, like this:</source>
          <target state="translated">그런 다음 QML에서 다음과 같이 인스턴스화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b5e4ac16581efbe06c8574f29ee1d3252fe12637" translate="yes" xml:space="preserve">
          <source>Then you can interact with this class on the JavaScript side like this:</source>
          <target state="translated">그런 다음 다음과 같이 JavaScript 측에서이 클래스와 상호 작용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bed94c33786154697dd76d7fb149a31570e074d1" translate="yes" xml:space="preserve">
          <source>Then you can restore the original contents of the widget box by resetting the file name to the original file and calling &lt;a href=&quot;qdesignerwidgetboxinterface#load&quot;&gt;load&lt;/a&gt;():</source>
          <target state="translated">그런 다음 파일 이름을 원래 파일로 재설정하고 &lt;a href=&quot;qdesignerwidgetboxinterface#load&quot;&gt;load&lt;/a&gt; ()를 호출하여 위젯 상자의 원래 내용을 복원 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ed95b407c6a4c87d5ce9415edc55b2edc6735ef2" translate="yes" xml:space="preserve">
          <source>Then you can swap out files like so:</source>
          <target state="translated">그런 다음 파일을 다음과 같이 바꿀 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ac172ab7f42b021ab249feb2e7c3ee18b690c42" translate="yes" xml:space="preserve">
          <source>Then you can use the two-argument form of the command:</source>
          <target state="translated">그런 다음 두 인수 형식의 명령을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a2e8f855c4b95e73344b2a0aaea3331637441276" translate="yes" xml:space="preserve">
          <source>Then you must create a class derived from &lt;a href=&quot;qwebengineurlschemehandler&quot;&gt;QWebEngineUrlSchemeHandler&lt;/a&gt;, and reimplement the &lt;a href=&quot;qwebengineurlschemehandler#requestStarted&quot;&gt;requestStarted&lt;/a&gt;() method.</source>
          <target state="translated">그런 다음 &lt;a href=&quot;qwebengineurlschemehandler&quot;&gt;QWebEngineUrlSchemeHandler&lt;/a&gt; 에서 파생 된 클래스를 작성 하고 &lt;a href=&quot;qwebengineurlschemehandler#requestStarted&quot;&gt;requestStarted를&lt;/a&gt; 다시 구현해야합니다. () 메소드를 .</target>
        </trans-unit>
        <trans-unit id="3f89048ff5215f6a6acfee6b50d3c3d612ac0f51" translate="yes" xml:space="preserve">
          <source>Then you must create a class derived from QWebEngineUrlSchemeHandler, and reimplement the &lt;a href=&quot;qwebengineurlschemehandler#requestStarted&quot;&gt;requestStarted&lt;/a&gt;() method.</source>
          <target state="translated">그런 다음 QWebEngineUrlSchemeHandler에서 파생 된 클래스를 만들고 &lt;a href=&quot;qwebengineurlschemehandler#requestStarted&quot;&gt;requestStarted&lt;/a&gt; () 메서드를 다시 구현해야합니다 .</target>
        </trans-unit>
        <trans-unit id="6e64180e200a587359a1187547f4a1b71b2129ef" translate="yes" xml:space="preserve">
          <source>Then, &lt;code&gt;20&lt;/code&gt; replaces &lt;code&gt;%2&lt;/code&gt; so the string becomes &lt;code&gt;&quot;Hello%320&quot;&lt;/code&gt;.</source>
          <target state="translated">그런 다음 &lt;code&gt;20&lt;/code&gt; 은 &lt;code&gt;%2&lt;/code&gt; 대체 하여 문자열이 &lt;code&gt;&quot;Hello%320&quot;&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="ef0242d5368d9df2f5b17d7e8e22da817ed94a77" translate="yes" xml:space="preserve">
          <source>Then, add a &lt;code&gt;+Material&lt;/code&gt; subdirectory, and in it, add the Material-specific code into &lt;code&gt;MainWindow.qml&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bfe829cf12f07cb1076f8606a399d2dbe09903c" translate="yes" xml:space="preserve">
          <source>Then, add the &lt;code&gt;.rep&lt;/code&gt; file to both the main application and service &lt;code&gt;.pro&lt;/code&gt; files, in the main application:</source>
          <target state="translated">그런 다음 &lt;code&gt;.rep&lt;/code&gt; 파일을 기본 응용 프로그램의 기본 응용 프로그램과 서비스 &lt;code&gt;.pro&lt;/code&gt; 파일 모두에 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="b103bf6fa87734661dfef29adb32789f1a8f05f9" translate="yes" xml:space="preserve">
          <source>Then, assuming an extra image format plugin</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4eb7e3e5304cb29bec7a34a72f7cf8bb9f8c070d" translate="yes" xml:space="preserve">
          <source>Then, for the following &lt;a href=&quot;https://doc.qt.io/qt-5.13/13-qdoc-commands-topics.html#example-command&quot;&gt;\example&lt;/a&gt; command:</source>
          <target state="translated">그런 다음 다음 &lt;a href=&quot;https://doc.qt.io/qt-5.13/13-qdoc-commands-topics.html#example-command&quot;&gt;\ example&lt;/a&gt; 명령의 경우 :</target>
        </trans-unit>
        <trans-unit id="31d80a32b0ef03e9bcb00ee3d7b1f5bf703ab1e6" translate="yes" xml:space="preserve">
          <source>Then, for the following &lt;a href=&quot;https://doc.qt.io/qt-5.15/13-qdoc-commands-topics.html#example-command&quot;&gt;\example&lt;/a&gt; command:</source>
          <target state="translated">그런 다음 다음 &lt;a href=&quot;https://doc.qt.io/qt-5.15/13-qdoc-commands-topics.html#example-command&quot;&gt;\ example&lt;/a&gt; 명령의 경우 :</target>
        </trans-unit>
        <trans-unit id="8a3425eb27f6b905e74d54282de9a22210baef1e" translate="yes" xml:space="preserve">
          <source>Then, for the following &lt;a href=&quot;https://doc.qt.io/qt-6.0/13-qdoc-commands-topics.html#example-command&quot;&gt;\example&lt;/a&gt; command:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="177f7bec6c5b0df69ef9be0f5e117cce7b95d172" translate="yes" xml:space="preserve">
          <source>Then, in &lt;code&gt;main.qml&lt;/code&gt;:</source>
          <target state="translated">그런 다음 &lt;code&gt;main.qml&lt;/code&gt; 에서 :</target>
        </trans-unit>
        <trans-unit id="488f90927a03379a22d43374fcb3b71cc6c49963" translate="yes" xml:space="preserve">
          <source>Then, in C++, we find that object and connect to its change signal:</source>
          <target state="translated">그런 다음 C ++에서 해당 객체를 찾아 변경 신호에 연결합니다.</target>
        </trans-unit>
        <trans-unit id="058ff83bf433fdce34d17ad46cb30fd2b9c0f837" translate="yes" xml:space="preserve">
          <source>Then, in another terminal:</source>
          <target state="translated">그런 다음 다른 터미널에서 :</target>
        </trans-unit>
        <trans-unit id="0a4651b1e93e4e2c2f75a423af535ce4a5dcebf5" translate="yes" xml:space="preserve">
          <source>Then, in the application's &lt;code&gt;main()&lt;/code&gt; function, connect to source node:</source>
          <target state="translated">그런 다음 애플리케이션의 &lt;code&gt;main()&lt;/code&gt; 함수에서 소스 노드에 연결합니다.</target>
        </trans-unit>
        <trans-unit id="d7c4f5c6d0a3f4e630d67acf5a9feedff23afa7f" translate="yes" xml:space="preserve">
          <source>Then, the &lt;code&gt;author&lt;/code&gt; property could be read from &lt;code&gt;MyItem.qml&lt;/code&gt;:</source>
          <target state="translated">그런 다음 &lt;code&gt;MyItem.qml&lt;/code&gt; 에서 &lt;code&gt;author&lt;/code&gt; 속성을 읽을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a24c0e1107fb504eaceec9ebad7813672f28ed3d" translate="yes" xml:space="preserve">
          <source>Then, the directory could be imported using the URL to the remote &lt;code&gt;mycomponents&lt;/code&gt; directory:</source>
          <target state="translated">그런 다음 URL을 사용하여 원격 &lt;code&gt;mycomponents&lt;/code&gt; 디렉토리로 디렉토리 를 가져올 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a17a30431b11b6dd4530e405cec17b098794e651" translate="yes" xml:space="preserve">
          <source>Then, we create the transitions by using the &lt;a href=&quot;qstate#addTransition&quot;&gt;QState::addTransition&lt;/a&gt;() function:</source>
          <target state="translated">그런 다음 &lt;a href=&quot;qstate#addTransition&quot;&gt;QState :: addTransition&lt;/a&gt; () 함수 를 사용하여 전환을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="54e6d3b8dc328629b4a4db0a4bdd2e42396ddbc1" translate="yes" xml:space="preserve">
          <source>Then, when an extension is required,</source>
          <target state="translated">그런 다음 확장이 필요한 경우</target>
        </trans-unit>
        <trans-unit id="780990f80e200d84317e0947fb598d2388ade5f6" translate="yes" xml:space="preserve">
          <source>Then, when processing the &lt;a href=&quot;09-qdoc-commands-includingimages#image-command&quot;&gt;\image&lt;/a&gt; and &lt;a href=&quot;09-qdoc-commands-includingimages#inlineimage-command&quot;&gt;\inlineimage&lt;/a&gt; commands, QDoc will only search for files with extensions specified in the variable containing the list of output formats.</source>
          <target state="translated">그런 다음 &lt;a href=&quot;09-qdoc-commands-includingimages#image-command&quot;&gt;\ image&lt;/a&gt; 및 &lt;a href=&quot;09-qdoc-commands-includingimages#inlineimage-command&quot;&gt;\ inlineimage를&lt;/a&gt; 처리 할 때 명령을 QDoc은 출력 형식 목록을 포함하는 변수에 지정된 확장자를 가진 파일 만 검색합니다.</target>
        </trans-unit>
        <trans-unit id="c8e45a9cc473f427dd912ef3cb9a3d24ab61414b" translate="yes" xml:space="preserve">
          <source>Then, when rendering with a one pixel wide pen the &lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt;'s boundary line will be rendered to the right and below the mathematical rectangle's boundary line.</source>
          <target state="translated">그런 다음 1 픽셀 너비의 펜으로 렌더링 할 때 &lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt; 의 경계선은 수학 사각형의 경계선의 오른쪽 아래에 렌더링됩니다.</target>
        </trans-unit>
        <trans-unit id="c2a2f2c48622011bec7a6950f391a32e317d5e9c" translate="yes" xml:space="preserve">
          <source>Then, when rendering with a one pixel wide pen the &lt;a href=&quot;qrectf&quot;&gt;QRectF&lt;/a&gt;'s boundary line will be rendered to the right and below the mathematical rectangle's boundary line.</source>
          <target state="translated">그런 다음 1 픽셀 너비의 펜으로 렌더링 할 때 &lt;a href=&quot;qrectf&quot;&gt;QRectF&lt;/a&gt; 의 경계선은 수학 사각형의 경계선의 오른쪽 아래에 렌더링됩니다.</target>
        </trans-unit>
        <trans-unit id="2fd9fbcac0f080f8d790b7369435a7c176a70e5d" translate="yes" xml:space="preserve">
          <source>Then, when rendering with a one pixel wide pen the QRect's boundary line will be rendered to the right and below the mathematical rectangle's boundary line.</source>
          <target state="translated">그런 다음 1 픽셀 너비의 펜으로 렌더링 할 때 QRect의 경계선이 수학 직사각형의 경계선 오른쪽과 아래에 렌더링됩니다.</target>
        </trans-unit>
        <trans-unit id="897a7afe26bc03a752e118a826fd6470694a0556" translate="yes" xml:space="preserve">
          <source>Then, when rendering with a one pixel wide pen the QRectF's boundary line will be rendered to the right and below the mathematical rectangle's boundary line.</source>
          <target state="translated">그런 다음 1 픽셀 너비의 펜으로 렌더링 할 때 QRectF의 경계선이 수학적 사각형의 경계선 오른쪽과 아래에 렌더링됩니다.</target>
        </trans-unit>
        <trans-unit id="3e5ea1fe7564d952271052a7e940759e028bff4a" translate="yes" xml:space="preserve">
          <source>Then, with the above code, if &lt;code&gt;total&lt;/code&gt; is the number &quot;4321.56&quot; (four thousand three hundred and twenty one point fifty six); with English regional settings, (locale) the output is &quot;4,321.56&quot;; with German regional settings, the output is &quot;4.321,56&quot;.</source>
          <target state="translated">그런 다음 위의 코드와, 경우 &lt;code&gt;total&lt;/code&gt; 이 숫자 &quot;4321.56&quot;(4 천 3 백 2 십 1 5 십육) 인 경우; 영어 지역 설정에서 (로케일) 출력은 &quot;4,321.56&quot;입니다. 독일어 지역 설정에서는 &quot;4.321,56&quot;이 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="a1d2f536ebed5283c2abe565102cb24a480f3c46" translate="yes" xml:space="preserve">
          <source>Then, you need to create and register the broadcast receiver from the Qt's main activity. The easiest way is to create a custom class with a method and implement all that logic in Java. In the following example, the service sends a message &lt;code&gt;&quot;simple_string&quot;&lt;/code&gt; to Qt by calling the native method &lt;code&gt;sendToQt()&lt;/code&gt;:</source>
          <target state="translated">그런 다음 Qt의 주요 활동에서 broadcast receiver를 만들고 등록해야합니다. 가장 쉬운 방법은 메서드로 사용자 정의 클래스를 만들고 모든 논리를 Java로 구현하는 것입니다. 다음 예제에서 서비스는 기본 메서드 &lt;code&gt;sendToQt()&lt;/code&gt; 호출하여 &lt;code&gt;&quot;simple_string&quot;&lt;/code&gt; 메시지 를 Qt로 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="957dd9f0875b7f2c42cdbbce3cd75a0508280d4c" translate="yes" xml:space="preserve">
          <source>There also exists a declarative &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtwebchannel-qmlmodule.html&quot;&gt;WebChannel API&lt;/a&gt;.</source>
          <target state="translated">선언적 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtwebchannel-qmlmodule.html&quot;&gt;WebChannel API&lt;/a&gt; 도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ccf864040f29eb8b63edc49c12ab44588a17c9d6" translate="yes" xml:space="preserve">
          <source>There also exists a declarative &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtwebchannel-qmlmodule.html&quot;&gt;WebChannel API&lt;/a&gt;.</source>
          <target state="translated">선언적 &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtwebchannel-qmlmodule.html&quot;&gt;WebChannel API&lt;/a&gt; 도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3df03b5ef3b401f9e8d50dd520b2c80be34ef340" translate="yes" xml:space="preserve">
          <source>There are 20 predefined QColor objects in the &lt;code&gt;QColorConstants&lt;/code&gt; namespace, including black, white, primary and secondary colors, darker versions of these colors, and three shades of gray. Furthermore, the &lt;code&gt;QColorConstants::Svg&lt;/code&gt; namespace defines QColor objects for the standard &lt;a href=&quot;https://www.w3.org/TR/SVG11/types.html#ColorKeywords&quot;&gt;SVG color keyword names&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;QColorConstants&lt;/code&gt; 네임 스페이스에는 검은 색, 흰색, 기본 및 보조 색상, 이러한 색상의 더 어두운 버전, 세 가지 회색 음영을 포함하여 20 개의 미리 정의 된 QColor 개체가 있습니다. 또한 &lt;code&gt;QColorConstants::Svg&lt;/code&gt; 네임 스페이스는 표준 &lt;a href=&quot;https://www.w3.org/TR/SVG11/types.html#ColorKeywords&quot;&gt;SVG 색상 키워드 이름에&lt;/a&gt; 대한 QColor 객체를 정의 합니다 .</target>
        </trans-unit>
        <trans-unit id="f4bce4744a2e3881b5692a18fd6262948f20ebc1" translate="yes" xml:space="preserve">
          <source>There are 20 predefined QColors described by the &lt;a href=&quot;qt#GlobalColor-enum&quot;&gt;Qt::GlobalColor&lt;/a&gt; enum, including black, white, primary and secondary colors, darker versions of these colors and three shades of gray. &lt;a href=&quot;qcolor&quot;&gt;QColor&lt;/a&gt; also recognizes a variety of color names; the static &lt;a href=&quot;qcolor#colorNames&quot;&gt;colorNames&lt;/a&gt;() function returns a &lt;a href=&quot;qstringlist&quot;&gt;QStringList&lt;/a&gt; color names that &lt;a href=&quot;qcolor&quot;&gt;QColor&lt;/a&gt; knows about.</source>
          <target state="translated">&lt;a href=&quot;qt#GlobalColor-enum&quot;&gt;Qt :: GlobalColor&lt;/a&gt; 열거 형 에는 20 가지 사전 정의 된 QColor가 있으며 여기에는 검정, 흰색, 기본 및 보조 색상, 이러한 색상의 어두운 버전 및 세 가지 회색 음영이 포함됩니다. &lt;a href=&quot;qcolor&quot;&gt;QColor&lt;/a&gt; 는 또한 다양한 색상 이름을 인식합니다. 정적 &lt;a href=&quot;qcolor#colorNames&quot;&gt;colorNames&lt;/a&gt; () 함수는 &lt;a href=&quot;qcolor&quot;&gt;QColor&lt;/a&gt; 가 알고 있는 &lt;a href=&quot;qstringlist&quot;&gt;QStringList&lt;/a&gt; 색상 이름을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="02f31e1e48599c9ead66d61d926e00b52e0b62c2" translate="yes" xml:space="preserve">
          <source>There are 3 prerequisites for implementing cross-referencing by alternative identifier. The first is that the origin manager must provide the x_provider attribute with the value being the name of the manager's &lt;a href=&quot;qgeoserviceprovider&quot;&gt;QGeoServiceProvider&lt;/a&gt;. The attribute label should be kept empty, indicating the attribute should not be displayed to users.</source>
          <target state="translated">대체 식별자로 상호 참조를 구현하기위한 3 가지 전제 조건이 있습니다. 첫 번째는 원점 관리자가 x_provider 속성에 관리자의 &lt;a href=&quot;qgeoserviceprovider&quot;&gt;QGeoServiceProvider&lt;/a&gt; 이름 인 값을 제공해야한다는 것입니다 입니다. 속성 레이블은 비워 두어야하며 이는 속성을 사용자에게 표시해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="c235f81dc9bf6663dde8196904733d375d19c23b" translate="yes" xml:space="preserve">
          <source>There are 3 types of attributes.</source>
          <target state="translated">속성에는 3 가지 유형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a92f82ad0f3ffb5b094e5412f1434d9536e07abd" translate="yes" xml:space="preserve">
          <source>There are 4 fetch-and-add functions: &lt;a href=&quot;qatomicinteger#fetchAndAddRelaxed&quot;&gt;fetchAndAddRelaxed&lt;/a&gt;(), &lt;a href=&quot;qatomicinteger#fetchAndAddAcquire&quot;&gt;fetchAndAddAcquire&lt;/a&gt;(), &lt;a href=&quot;qatomicinteger#fetchAndAddRelease&quot;&gt;fetchAndAddRelease&lt;/a&gt;(), and &lt;a href=&quot;qatomicinteger#fetchAndAddOrdered&quot;&gt;fetchAndAddOrdered&lt;/a&gt;(). See above for an explanation of the different memory ordering semantics.</source>
          <target state="translated">&lt;a href=&quot;qatomicinteger#fetchAndAddRelaxed&quot;&gt;fetchAndAddRelaxed&lt;/a&gt; (), &lt;a href=&quot;qatomicinteger#fetchAndAddAcquire&quot;&gt;fetchAndAddAcquire&lt;/a&gt; (), &lt;a href=&quot;qatomicinteger#fetchAndAddRelease&quot;&gt;fetchAndAddRelease&lt;/a&gt; () 및 &lt;a href=&quot;qatomicinteger#fetchAndAddOrdered&quot;&gt;fetchAndAddOrdered&lt;/a&gt; ()의 4 가지 페치 및 추가 기능이 있습니다 . 다른 메모리 순서 의미론에 대한 설명은 위를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1b2f80f09d0b09765258fade21b69c7ffed9b7a6" translate="yes" xml:space="preserve">
          <source>There are 4 fetch-and-add functions: &lt;a href=&quot;qatomicpointer#fetchAndAddRelaxed&quot;&gt;fetchAndAddRelaxed&lt;/a&gt;(), &lt;a href=&quot;qatomicpointer#fetchAndAddAcquire&quot;&gt;fetchAndAddAcquire&lt;/a&gt;(), &lt;a href=&quot;qatomicpointer#fetchAndAddRelease&quot;&gt;fetchAndAddRelease&lt;/a&gt;(), and &lt;a href=&quot;qatomicpointer#fetchAndAddOrdered&quot;&gt;fetchAndAddOrdered&lt;/a&gt;(). See above for an explanation of the different memory ordering semantics.</source>
          <target state="translated">&lt;a href=&quot;qatomicpointer#fetchAndAddRelaxed&quot;&gt;fetchAndAddRelaxed&lt;/a&gt; (), &lt;a href=&quot;qatomicpointer#fetchAndAddAcquire&quot;&gt;fetchAndAddAcquire&lt;/a&gt; (), &lt;a href=&quot;qatomicpointer#fetchAndAddRelease&quot;&gt;fetchAndAddRelease&lt;/a&gt; () 및 &lt;a href=&quot;qatomicpointer#fetchAndAddOrdered&quot;&gt;fetchAndAddOrdered&lt;/a&gt; ()의 4 가지 페치 및 추가 기능이 있습니다 . 다른 메모리 순서 의미론에 대한 설명은 위를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="074aed5de1afea0bf3961699aef087028a43c775" translate="yes" xml:space="preserve">
          <source>There are 4 fetch-and-store functions: &lt;a href=&quot;qatomicinteger#fetchAndStoreRelaxed&quot;&gt;fetchAndStoreRelaxed&lt;/a&gt;(), &lt;a href=&quot;qatomicinteger#fetchAndStoreAcquire&quot;&gt;fetchAndStoreAcquire&lt;/a&gt;(), &lt;a href=&quot;qatomicinteger#fetchAndStoreRelease&quot;&gt;fetchAndStoreRelease&lt;/a&gt;(), and &lt;a href=&quot;qatomicinteger#fetchAndStoreOrdered&quot;&gt;fetchAndStoreOrdered&lt;/a&gt;(). See above for an explanation of the different memory ordering semantics.</source>
          <target state="translated">가져 오기 및 저장 기능에는 4 가지가 있습니다. &lt;a href=&quot;qatomicinteger#fetchAndStoreRelaxed&quot;&gt;fetchAndStoreRelaxed&lt;/a&gt; (), &lt;a href=&quot;qatomicinteger#fetchAndStoreAcquire&quot;&gt;fetchAndStoreAcquire&lt;/a&gt; (), &lt;a href=&quot;qatomicinteger#fetchAndStoreRelease&quot;&gt;fetchAndStoreRelease&lt;/a&gt; () 및 &lt;a href=&quot;qatomicinteger#fetchAndStoreOrdered&quot;&gt;fetchAndStoreOrdered가 있습니다.&lt;/a&gt; ()의 있습니다. 다른 메모리 순서 의미론에 대한 설명은 위를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="96ae555ec507c63fc35f0ecd022c0dda8b34ac05" translate="yes" xml:space="preserve">
          <source>There are 4 fetch-and-store functions: &lt;a href=&quot;qatomicpointer#fetchAndStoreRelaxed&quot;&gt;fetchAndStoreRelaxed&lt;/a&gt;(), &lt;a href=&quot;qatomicpointer#fetchAndStoreAcquire&quot;&gt;fetchAndStoreAcquire&lt;/a&gt;(), &lt;a href=&quot;qatomicpointer#fetchAndStoreRelease&quot;&gt;fetchAndStoreRelease&lt;/a&gt;(), and &lt;a href=&quot;qatomicpointer#fetchAndStoreOrdered&quot;&gt;fetchAndStoreOrdered&lt;/a&gt;(). See above for an explanation of the different memory ordering semantics.</source>
          <target state="translated">가져 오기 및 저장 기능에는 &lt;a href=&quot;qatomicpointer#fetchAndStoreRelaxed&quot;&gt;fetchAndStoreRelaxed&lt;/a&gt; (),&lt;a href=&quot;qatomicpointer#fetchAndStoreAcquire&quot;&gt; fetchAndStoreAcquire&lt;/a&gt; (), &lt;a href=&quot;qatomicpointer#fetchAndStoreRelease&quot;&gt;fetchAndStoreRelease&lt;/a&gt; () 및 &lt;a href=&quot;qatomicpointer#fetchAndStoreOrdered&quot;&gt;fetchAndStoreOrdered&lt;/a&gt; ()의 있습니다. 다른 메모리 순서 의미론에 대한 설명은 위를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6e0cb34571a764b445cea85d06d7a2949204e06d" translate="yes" xml:space="preserve">
          <source>There are 4 test-and-set functions: &lt;a href=&quot;qatomicinteger#testAndSetRelaxed&quot;&gt;testAndSetRelaxed&lt;/a&gt;(), &lt;a href=&quot;qatomicinteger#testAndSetAcquire&quot;&gt;testAndSetAcquire&lt;/a&gt;(), &lt;a href=&quot;qatomicinteger#testAndSetRelease&quot;&gt;testAndSetRelease&lt;/a&gt;(), and &lt;a href=&quot;qatomicinteger#testAndSetOrdered&quot;&gt;testAndSetOrdered&lt;/a&gt;(). See above for an explanation of the different memory ordering semantics.</source>
          <target state="translated">테스트 및 설정 기능에는 &lt;a href=&quot;qatomicinteger#testAndSetRelaxed&quot;&gt;testAndSetRelaxed&lt;/a&gt; (),&lt;a href=&quot;qatomicinteger#testAndSetAcquire&quot;&gt; testAndSetAcquire&lt;/a&gt; (), &lt;a href=&quot;qatomicinteger#testAndSetRelease&quot;&gt;testAndSetRelease&lt;/a&gt; () 및 &lt;a href=&quot;qatomicinteger#testAndSetOrdered&quot;&gt;testAndSetOrdered의&lt;/a&gt; ()의 있습니다. 다른 메모리 순서 의미론에 대한 설명은 위를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e5f730fe3435c0b64678329c6fe957cb18912167" translate="yes" xml:space="preserve">
          <source>There are 4 test-and-set functions: &lt;a href=&quot;qatomicpointer#testAndSetRelaxed&quot;&gt;testAndSetRelaxed&lt;/a&gt;(), &lt;a href=&quot;qatomicpointer#testAndSetAcquire&quot;&gt;testAndSetAcquire&lt;/a&gt;(), &lt;a href=&quot;qatomicpointer#testAndSetRelease&quot;&gt;testAndSetRelease&lt;/a&gt;(), and &lt;a href=&quot;qatomicpointer#testAndSetOrdered&quot;&gt;testAndSetOrdered&lt;/a&gt;(). See above for an explanation of the different memory ordering semantics.</source>
          <target state="translated">테스트 및 설정 기능에는 &lt;a href=&quot;qatomicpointer#testAndSetRelaxed&quot;&gt;testAndSetRelaxed&lt;/a&gt; (),&lt;a href=&quot;qatomicpointer#testAndSetAcquire&quot;&gt; testAndSetAcquire&lt;/a&gt; (), &lt;a href=&quot;qatomicpointer#testAndSetRelease&quot;&gt;testAndSetRelease&lt;/a&gt; () 및 &lt;a href=&quot;qatomicpointer#testAndSetOrdered&quot;&gt;testAndSetOrdered의&lt;/a&gt; ()의 있습니다. 다른 메모리 순서 의미론에 대한 설명은 위를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="cfad1a4d55e155be8eae1bcc1383dd6546c652e5" translate="yes" xml:space="preserve">
          <source>There are a couple of properties to work with the pinout signals namely: &lt;a href=&quot;qserialport#dataTerminalReady-prop&quot;&gt;QSerialPort::dataTerminalReady&lt;/a&gt;, &lt;a href=&quot;qserialport#requestToSend-prop&quot;&gt;QSerialPort::requestToSend&lt;/a&gt;. It is also possible to use the &lt;a href=&quot;qserialport#pinoutSignals&quot;&gt;pinoutSignals&lt;/a&gt;() method to query the current pinout signals set.</source>
          <target state="translated">핀아웃 신호와 함께 작동하는 몇 가지 속성이 있습니다. &lt;a href=&quot;qserialport#dataTerminalReady-prop&quot;&gt; QSerialPort :: dataTerminalReady&lt;/a&gt; , &lt;a href=&quot;qserialport#requestToSend-prop&quot;&gt;QSerialPort :: requestToSend&lt;/a&gt; . &lt;a href=&quot;qserialport#pinoutSignals&quot;&gt;pinoutSignals&lt;/a&gt; 를 사용하는 것도 가능합니다 () 메소드를 사용하여 현재 핀아웃 신호 세트를 쿼리 .</target>
        </trans-unit>
        <trans-unit id="5a188145444bfbe9faaf6e4c14f17e7b3c915587" translate="yes" xml:space="preserve">
          <source>There are a couple ways of using &lt;a href=&quot;qdialogbuttonbox&quot;&gt;QDialogButtonBox&lt;/a&gt;. One ways is to create the buttons (or button texts) yourself and add them to the button box, specifying their role.</source>
          <target state="translated">&lt;a href=&quot;qdialogbuttonbox&quot;&gt;QDialogButtonBox&lt;/a&gt; 를 사용하는 몇 가지 방법이 있습니다. 한 가지 방법은 단추 (또는 단추 텍스트)를 직접 만들고 단추 상자에 역할을 지정하여 추가하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7e96320ecfa48881ec71482be8b00468f00269c7" translate="yes" xml:space="preserve">
          <source>There are a couple ways of using &lt;a href=&quot;qml-qtquick-controls2-dialogbuttonbox&quot;&gt;DialogButtonBox&lt;/a&gt;. One way is to specify the standard buttons (e.g. &lt;b&gt;OK&lt;/b&gt;, &lt;b&gt;Cancel&lt;/b&gt;, &lt;b&gt;Save&lt;/b&gt;) and let the button box setup the buttons.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-controls2-dialogbuttonbox&quot;&gt;DialogButtonBox&lt;/a&gt; 를 사용하는 몇 가지 방법이 있습니다. 한 가지 방법은 표준 버튼을 지정하는 것입니다 (예 : &lt;b&gt;OK&lt;/b&gt; ,&lt;b&gt; 취소&lt;/b&gt; , &lt;b&gt;저장&lt;/b&gt; ) 하고 단추 상자가 단추를 설정하도록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="959f921edbb0c2f6981ea3c291749b483a8ace58" translate="yes" xml:space="preserve">
          <source>There are a couple ways of using DialogButtonBox. One way is to specify the standard buttons (e.g. &lt;b&gt;OK&lt;/b&gt;, &lt;b&gt;Cancel&lt;/b&gt;, &lt;b&gt;Save&lt;/b&gt;) and let the button box setup the buttons.</source>
          <target state="translated">DialogButtonBox를 사용하는 방법에는 두 가지가 있습니다. 한 가지 방법은 표준 버튼 (예 : &lt;b&gt;확인&lt;/b&gt; , &lt;b&gt;취소&lt;/b&gt; , &lt;b&gt;저장&lt;/b&gt; ) 을 지정 하고 버튼 상자에서 버튼을 설정하도록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="2d25e024baa785ab6ab49fef0a0d52c9ad10bf89" translate="yes" xml:space="preserve">
          <source>There are a couple ways of using QDialogButtonBox. One ways is to create the buttons (or button texts) yourself and add them to the button box, specifying their role.</source>
          <target state="translated">QDialogButtonBox를 사용하는 두 가지 방법이 있습니다. 한 가지 방법은 버튼 (또는 버튼 텍스트)을 직접 만들고 버튼 상자에 추가하여 역할을 지정하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="4b113401a611cb1ad620b9f80b29aa75eff324cb" translate="yes" xml:space="preserve">
          <source>There are a few limitations when using Scene3DView:</source>
          <target state="translated">Scene3DView를 사용할 때 몇 가지 제한 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="af168ead1356573b3fb1e54f8805a26ae8daaa1a" translate="yes" xml:space="preserve">
          <source>There are a few similarities between the events &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent::HoverEnter&lt;/a&gt; and &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent::HoverLeave&lt;/a&gt;, and the events &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent::Enter&lt;/a&gt; and &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent::Leave&lt;/a&gt;. However, they are slightly different because we do an update() in the event handler of &lt;a href=&quot;qevent#Type-enum&quot;&gt;HoverEnter&lt;/a&gt; and &lt;a href=&quot;qevent#Type-enum&quot;&gt;HoverLeave&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent :: HoverEnter&lt;/a&gt; 및 &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent :: HoverLeave&lt;/a&gt; 이벤트와 &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent :: Enter&lt;/a&gt; 및 &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent :: Leave&lt;/a&gt; 이벤트 사이에는 몇 가지 유사점이 있습니다 . 그러나 &lt;a href=&quot;qevent#Type-enum&quot;&gt;HoverEnter&lt;/a&gt; 및 &lt;a href=&quot;qevent#Type-enum&quot;&gt;HoverLeave&lt;/a&gt; 의 이벤트 핸들러에서 update ()를 수행하기 때문에 약간 다릅니다. .</target>
        </trans-unit>
        <trans-unit id="d82c5fdaf8c8bd22aa3cb128225a1588306899e4" translate="yes" xml:space="preserve">
          <source>There are a few variations on how to declare services. Some of them are already used in the previous manifest snippet. Depending on your use case, run the service either in the same process as QtActivity or in a separate process.</source>
          <target state="translated">서비스를 선언하는 방법에는 몇 가지 변형이 있습니다. 그들 중 일부는 이전 매니페스트 스 니펫에서 이미 사용되었습니다. 사용 사례에 따라 QtActivity와 동일한 프로세스 또는 별도의 프로세스에서 서비스를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="9ac569437d8df6566ece090b81693a2fbed81874" translate="yes" xml:space="preserve">
          <source>There are a number of item-based features common to each of the convenience classes that are available through the same interfaces in each class. We present these in the following sections with some examples for different widgets. Look at the list of &lt;a href=&quot;#model-view-classes&quot;&gt;Model/View Classes&lt;/a&gt; for each of the widgets for more details about the use of each function used.</source>
          <target state="translated">각 클래스에서 동일한 인터페이스를 통해 사용 가능한 각 편의 클래스에 공통적 인 여러 항목 기반 기능이 있습니다. 다음 섹션에서는 다양한 위젯에 대한 몇 가지 예를 제공합니다. 의 목록을보십시오&lt;a href=&quot;#model-view-classes&quot;&gt;&lt;/a&gt;사용 된 각 함수의 사용에 대한 자세한 내용은 각 위젯 모델 / 뷰 클래스 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="86c1ef32ba94ffcf639633601de1d1f165f913b6" translate="yes" xml:space="preserve">
          <source>There are a number of item-based features common to each of the convenience classes that are available through the same interfaces in each class. We present these in the following sections with some examples for different widgets. Look at the list of &lt;a href=&quot;model-view-programming#model-view-classes&quot;&gt;Model/View Classes&lt;/a&gt; for each of the widgets for more details about the use of each function used.</source>
          <target state="translated">각 클래스의 동일한 인터페이스를 통해 사용할 수있는 각 편의 클래스에 공통된 항목 기반 기능이 많이 있습니다. 다음 섹션에서 다양한 위젯에 대한 몇 가지 예제를 제공합니다. 사용 된 각 기능의 사용에 대한 자세한 내용은 각 위젯 의 &lt;a href=&quot;model-view-programming#model-view-classes&quot;&gt;모델 /보기 클래스&lt;/a&gt; 목록 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d98ec98b458136534e9860aed732fbd303edaf88" translate="yes" xml:space="preserve">
          <source>There are a number of tasks that are often performed by developers when editing and processing text documents using Qt. These include the use of display widgets such as &lt;a href=&quot;qtextbrowser&quot;&gt;QTextBrowser&lt;/a&gt; and &lt;a href=&quot;qtextedit&quot;&gt;QTextEdit&lt;/a&gt;, creation of documents with &lt;a href=&quot;qtextdocument&quot;&gt;QTextDocument&lt;/a&gt;, editing using a &lt;a href=&quot;qtextcursor&quot;&gt;QTextCursor&lt;/a&gt;, and exporting the document structure. This document outlines some of the more common ways of using the rich text classes to perform these tasks, showing convenient patterns that can be reused in your own applications.</source>
          <target state="translated">Qt를 사용하여 텍스트 문서를 편집하고 처리 할 때 개발자가 자주 수행하는 많은 작업이 있습니다. 여기에는 &lt;a href=&quot;qtextbrowser&quot;&gt;QTextBrowser&lt;/a&gt; 및 &lt;a href=&quot;qtextedit&quot;&gt;QTextEdit&lt;/a&gt; 와 같은 디스플레이 위젯 사용 ,&lt;a href=&quot;qtextdocument&quot;&gt; QTextDocument&lt;/a&gt; 사용하여 A 편집 &lt;a href=&quot;qtextcursor&quot;&gt;QTextCursor을&lt;/a&gt; 및 문서 구조 내보내기가 포함됩니다. 이 문서는 리치 텍스트 클래스를 사용하여 이러한 작업을 수행하는 일반적인 방법 중 일부를 설명하며, 자신의 응용 프로그램에서 재사용 할 수있는 편리한 패턴을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="bc6731d218eff9149a2a646b10d3911923ea1c4b" translate="yes" xml:space="preserve">
          <source>There are a variety of different ways to visualize the Earth's surface in a 2-dimensional manner, but all of them involve some kind of projection: a mathematical relationship between the 3D coordinates (latitude, longitude and altitude) and 2D coordinates (X and Y in pixels) on the screen.</source>
          <target state="translated">지구 표면을 2 차원 방식으로 시각화하는 다양한 방법이 있지만 3D 좌표 (위도, 경도 및 고도)와 2D 좌표 (X 및 Y) 사이의 수학적 관계 화면에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="f0f2ba1a4fbed437c1d4d3dd94edd082ff5c301f" translate="yes" xml:space="preserve">
          <source>There are a variety of tools that can be used to produce the cubemaps needed by EnvironmentLight. Some examples include</source>
          <target state="translated">EnvironmentLight에 필요한 큐브 맵을 생성하는 데 사용할 수있는 다양한 도구가 있습니다. 몇 가지 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4ebb7e11733cb2892fea4f7e8b31b4b1ed6ef74c" translate="yes" xml:space="preserve">
          <source>There are a variety of tools that can be used to produce the cubemaps needed by QEnvironmentLight. Some examples include</source>
          <target state="translated">QEnvironmentLight에 필요한 큐브 맵을 생성하는 데 사용할 수있는 다양한 도구가 있습니다. 몇 가지 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="32776f11b4a2d3ade5ed9a41e6ef1e26c1558184" translate="yes" xml:space="preserve">
          <source>There are also a number of flags which you can use to customize the appearance of top-level windows. These have no effect on other windows:</source>
          <target state="translated">최상위 창의 모양을 사용자 정의하는 데 사용할 수있는 여러 플래그도 있습니다. 다른 창에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f66b2ca7ef4ed6362018eb015c2429afc1e2fd5d" translate="yes" xml:space="preserve">
          <source>There are also corresponding &lt;a href=&quot;qpalette#color&quot;&gt;color&lt;/a&gt;() and &lt;a href=&quot;qpalette#brush&quot;&gt;brush&lt;/a&gt;() getters, and a commonly used convenience function to get the &lt;a href=&quot;qpalette#ColorRole-enum&quot;&gt;ColorRole&lt;/a&gt; for the current &lt;a href=&quot;qpalette#ColorGroup-enum&quot;&gt;ColorGroup&lt;/a&gt;: &lt;a href=&quot;qpalette#window&quot;&gt;window&lt;/a&gt;(), &lt;a href=&quot;qpalette#windowText&quot;&gt;windowText&lt;/a&gt;(), &lt;a href=&quot;qpalette#base&quot;&gt;base&lt;/a&gt;(), etc.</source>
          <target state="translated">해당 &lt;a href=&quot;qpalette#color&quot;&gt;색상&lt;/a&gt; () 및 &lt;a href=&quot;qpalette#brush&quot;&gt;브러시&lt;/a&gt; () 게터 가 있으며 현재 &lt;a href=&quot;qpalette#ColorGroup-enum&quot;&gt;ColorGroup에&lt;/a&gt; 대한 &lt;a href=&quot;qpalette#ColorRole-enum&quot;&gt;ColorRole&lt;/a&gt; 을 얻는 데 일반적으로 사용되는 편의 기능이 있습니다 : &lt;a href=&quot;qpalette#window&quot;&gt;window&lt;/a&gt; (), &lt;a href=&quot;qpalette#windowText&quot;&gt;windowText&lt;/a&gt; (),&lt;a href=&quot;qpalette#base&quot;&gt; base&lt;/a&gt; () 등</target>
        </trans-unit>
        <trans-unit id="c72a66018e0df3c3601452607002d288822ff0f1" translate="yes" xml:space="preserve">
          <source>There are also different navigation methods and different controls such as buttons and sliders. The following examples are available from Qt Creator and demonstrate different controls and layouts.</source>
          <target state="translated">탐색 방법과 버튼 및 슬라이더와 같은 다른 컨트롤도 있습니다. 다음 예제는 Qt Creator에서 제공되며 다양한 컨트롤과 레이아웃을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="424a6add0f2c3574f720179ac28e257b1e81db5f" translate="yes" xml:space="preserve">
          <source>There are also functions for changing attributes of an image in-place:</source>
          <target state="translated">내부 이미지 속성을 변경하는 기능도 있습니다 :</target>
        </trans-unit>
        <trans-unit id="11eb8a9651921e9d5c8ef4aff8e9ac6a9b14aacc" translate="yes" xml:space="preserve">
          <source>There are also many other information we are interested in (as application developers), for instance performance issues, or warnings about using deprecated APIs. Those kind of messages are not reported through the ordinary OpenGL error reporting mechanisms.</source>
          <target state="translated">성능 문제 또는 더 이상 사용되지 않는 API 사용에 대한 경고와 같이 우리가 관심을 갖고있는 다른 많은 정보 (예 : 응용 프로그램 개발자)도 있습니다. 이러한 종류의 메시지는 일반적인 OpenGL 오류보고 메커니즘을 통해보고되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ae62211719f6b2f9890588601f52a98d9a37c2a0" translate="yes" xml:space="preserve">
          <source>There are also slots to change the base with &lt;a href=&quot;qlcdnumber#mode-prop&quot;&gt;setMode&lt;/a&gt;() and the decimal point with &lt;a href=&quot;qlcdnumber#smallDecimalPoint-prop&quot;&gt;setSmallDecimalPoint&lt;/a&gt;().</source>
          <target state="translated">또한 &lt;a href=&quot;qlcdnumber#mode-prop&quot;&gt;setMode&lt;/a&gt; () &lt;a href=&quot;qlcdnumber#smallDecimalPoint-prop&quot;&gt;로베이스&lt;/a&gt; 를 변경하고 setSmallDecimalPoint ()로 소수점 을 변경할 수있는 슬롯이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7648f89cecd8bf2a749b64e44c8b67abdcac286b" translate="yes" xml:space="preserve">
          <source>There are also some convenience anchors. anchors.fill is a convenience that is the same as setting the left,right,top and bottom anchors to the left,right,top and bottom of the target item. anchors.centerIn is another convenience anchor, and is the same as setting the verticalCenter and horizontalCenter anchors to the verticalCenter and horizontalCenter of the target item.</source>
          <target state="translated">편의점도 있습니다. anchors.fill은 왼쪽, 오른쪽, 위쪽 및 아래쪽 앵커를 대상 항목의 왼쪽, 오른쪽, 위쪽 및 아래쪽으로 설정하는 것과 동일한 편의입니다. anchors.centerIn은 또 다른 편리한 앵커이며, verticalCenter 및 horizontalCenter 앵커를 대상 항목의 verticalCenter 및 horizontalCenter로 설정하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f5e6130bd0d2e240ef94a55a5130823dd2c03a4c" translate="yes" xml:space="preserve">
          <source>There are also some functions that operate on the set of glyphs in the font: &lt;a href=&quot;qfontmetrics#minLeftBearing&quot;&gt;minLeftBearing&lt;/a&gt;(), &lt;a href=&quot;qfontmetrics#minRightBearing&quot;&gt;minRightBearing&lt;/a&gt;() and &lt;a href=&quot;qfontmetrics#maxWidth&quot;&gt;maxWidth&lt;/a&gt;(). These are by necessity slow, and we recommend avoiding them if possible.</source>
          <target state="translated">글꼴의 글리프 세트에서 작동하는 일부 함수 인 &lt;a href=&quot;qfontmetrics#minLeftBearing&quot;&gt;minLeftBearing&lt;/a&gt; (), &lt;a href=&quot;qfontmetrics#minRightBearing&quot;&gt;minRightBearing&lt;/a&gt; () 및 &lt;a href=&quot;qfontmetrics#maxWidth&quot;&gt;maxWidth&lt;/a&gt; ()도 있습니다. 이들은 느리게 진행되므로 가능하면 피하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="8d59c632d57dcc31554634d43d61de72a1503dab" translate="yes" xml:space="preserve">
          <source>There are also some functions that operate on the set of glyphs in the font: &lt;a href=&quot;qfontmetricsf#minLeftBearing&quot;&gt;minLeftBearing&lt;/a&gt;(), &lt;a href=&quot;qfontmetricsf#minRightBearing&quot;&gt;minRightBearing&lt;/a&gt;() and &lt;a href=&quot;qfontmetricsf#maxWidth&quot;&gt;maxWidth&lt;/a&gt;(). These are by necessity slow, and we recommend avoiding them if possible.</source>
          <target state="translated">글꼴의 글리프 세트에서 작동하는 일부 함수 인 &lt;a href=&quot;qfontmetricsf#minLeftBearing&quot;&gt;minLeftBearing&lt;/a&gt; (), &lt;a href=&quot;qfontmetricsf#minRightBearing&quot;&gt;minRightBearing&lt;/a&gt; () 및 &lt;a href=&quot;qfontmetricsf#maxWidth&quot;&gt;maxWidth&lt;/a&gt; ()도 있습니다. 이들은 느리게 진행되므로 가능하면 피하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="1fe578f4701a7b07fddb0d285b7b14f289360215" translate="yes" xml:space="preserve">
          <source>There are also some rather obscure events described in the documentation for &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent::Type&lt;/a&gt;. To handle these events, you need to reimplement &lt;a href=&quot;qwidget#event&quot;&gt;event&lt;/a&gt;() directly.</source>
          <target state="translated">&lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent :: Type&lt;/a&gt; 문서에 설명되어있는 다소 모호한 이벤트도 있습니다 . 이러한 이벤트를 처리하려면 &lt;a href=&quot;qwidget#event&quot;&gt;이벤트&lt;/a&gt; ()를 직접 다시 구현해야합니다 .</target>
        </trans-unit>
        <trans-unit id="8e4120bd69e0477dd5a824764eb7257fd12677fc" translate="yes" xml:space="preserve">
          <source>There are also string based constructors for these types. See &lt;a href=&quot;qtqml-typesystem-basictypes&quot;&gt;QML Basic Types&lt;/a&gt; for more information.</source>
          <target state="translated">이러한 유형에 대한 문자열 기반 생성자도 있습니다. 자세한 내용은 &lt;a href=&quot;qtqml-typesystem-basictypes&quot;&gt;QML 기본 유형&lt;/a&gt; 을 참조하세요.</target>
        </trans-unit>
        <trans-unit id="00f4cc0f1af21d2762cd2b25b5e95e60fdbe8c6c" translate="yes" xml:space="preserve">
          <source>There are also string based constructors for these types. See &lt;a href=&quot;qtqml-typesystem-basictypes#&quot;&gt;QML Basic Types&lt;/a&gt; for more information.</source>
          <target state="translated">이러한 유형에 대한 문자열 기반 생성자도 있습니다. 자세한 정보는 &lt;a href=&quot;qtqml-typesystem-basictypes#&quot;&gt;QML 기본 유형&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d5b75fce63ac879f2e053184749716887f308e94" translate="yes" xml:space="preserve">
          <source>There are cases however, when allowing the 2D content write to the depth buffer is not ideal. Consider a 3D scene as an &quot;overlay&quot; on top the 2D scene, rendered via Qt Quick 3D using a &lt;a href=&quot;qml-qtquick3d-view3d&quot;&gt;View3D&lt;/a&gt; with &lt;a href=&quot;qml-qtquick3d-view3d#renderMode-prop&quot;&gt;View3D::renderMode&lt;/a&gt;}{renderMode} set to &lt;code&gt;Overlay&lt;/code&gt;. In this case, having the depth buffer filled by 2D content can cause unexpected results. This is because the way the 2D scene graph renderer generates and handles depth values is not necessarily compatible with how a 3D scene works. This may end up in depth value clashes, collisions, and unexpected depth test failures. Therefore, the robust approach here is to call this function with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff232ce9f1c642374599c5b1171f4c5ca7968481" translate="yes" xml:space="preserve">
          <source>There are cases where the alpha channel is used, though, for example for application icon or systray icons. In that case, &lt;code&gt;reinterpretAsFormat(QImage::Format_ARGB32)&lt;/code&gt; should be called on the returned image to ensure the format is correct.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6f4eca68e6fc27bc484aef9541681fd5c12e021" translate="yes" xml:space="preserve">
          <source>There are currently no other defined CBOR simple types. &lt;a href=&quot;qcborvalue&quot;&gt;QCborValue&lt;/a&gt; supports them simply by their number with API like &lt;a href=&quot;qcborvalue#isSimpleType&quot;&gt;isSimpleType&lt;/a&gt;() and &lt;a href=&quot;qcborvalue#toSimpleType&quot;&gt;toSimpleType&lt;/a&gt;(), available for compatibility with future specifications before the Qt API can be updated. Their use before such a specification is discouraged, as other CBOR implementations may not support them fully.</source>
          <target state="translated">현재 정의 된 다른 CBOR 단순 유형이 없습니다. &lt;a href=&quot;qcborvalue&quot;&gt;QCborValue&lt;/a&gt; 는 &lt;a href=&quot;qcborvalue#isSimpleType&quot;&gt;isSimpleType&lt;/a&gt; () 및 &lt;a href=&quot;qcborvalue#toSimpleType&quot;&gt;toSimpleType&lt;/a&gt; () 과 같은 API를 사용하여 숫자로 간단히 지원하므로 Qt API를 업데이트하기 전에 향후 사양과 호환 될 수 있습니다. 다른 CBOR 구현이 완전히 지원하지 않을 수 있으므로 이러한 사양 이전의 사용은 권장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="26c78fd84a11a66cdfd617be5c87635e39281694" translate="yes" xml:space="preserve">
          <source>There are currently no other defined CBOR simple types. QCborValue supports them simply by their number with API like &lt;a href=&quot;qcborvalue#isSimpleType&quot;&gt;isSimpleType&lt;/a&gt;() and &lt;a href=&quot;qcborvalue#toSimpleType&quot;&gt;toSimpleType&lt;/a&gt;(), available for compatibility with future specifications before the Qt API can be updated. Their use before such a specification is discouraged, as other CBOR implementations may not support them fully.</source>
          <target state="translated">현재 다른 정의 된 CBOR 단순 유형은 없습니다. QCborValue는 Qt API가 업데이트되기 전에 향후 사양과의 호환성을 위해 사용할 수있는 &lt;a href=&quot;qcborvalue#isSimpleType&quot;&gt;isSimpleType&lt;/a&gt; () 및 &lt;a href=&quot;qcborvalue#toSimpleType&quot;&gt;toSimpleType&lt;/a&gt; () 과 같은 API를 사용하여 번호로 간단히 지원합니다 . 다른 CBOR 구현은이를 완전히 지원하지 않을 수 있으므로 이러한 사양 이전에 사용하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="442c310436b527412a5e1d63a31916a1a26fd88c" translate="yes" xml:space="preserve">
          <source>There are currently three different materials that can be used with the model item, the &lt;a href=&quot;qml-qtquick3d-principledmaterial&quot;&gt;PrincipledMaterial&lt;/a&gt;, the &lt;a href=&quot;qml-qtquick3d-defaultmaterial&quot;&gt;DefaultMaterial&lt;/a&gt;, and the &lt;a href=&quot;qml-qtquick3d-custommaterial&quot;&gt;CustomMaterial&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6f256462865b917c38577878b542ae4a129aebf" translate="yes" xml:space="preserve">
          <source>There are currently three different materials that can be used with the model item, the &lt;a href=&quot;qml-qtquick3d-principledmaterial&quot;&gt;PrincipledMaterial&lt;/a&gt;, the &lt;a href=&quot;qml-qtquick3d-defaultmaterial&quot;&gt;DefaultMaterial&lt;/a&gt;, and the &lt;a href=&quot;qml-qtquick3d-materials-custommaterial&quot;&gt;CustomMaterial&lt;/a&gt;. In addition the &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtquick3d-materials-qmlmodule.html&quot;&gt;Material Library&lt;/a&gt; provides a set of pre-made materials that can be used.</source>
          <target state="translated">현재 모델 항목과 함께 사용할 수있는 세 가지 재질, &lt;a href=&quot;qml-qtquick3d-principledmaterial&quot;&gt;PrincipledMaterial&lt;/a&gt; , &lt;a href=&quot;qml-qtquick3d-defaultmaterial&quot;&gt;DefaultMaterial&lt;/a&gt; 및 &lt;a href=&quot;qml-qtquick3d-materials-custommaterial&quot;&gt;CustomMaterial이&lt;/a&gt; 있습니다. 또한 &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtquick3d-materials-qmlmodule.html&quot;&gt;재료 라이브러리&lt;/a&gt; 는 사용할 수있는 사전 제작 된 재료 세트를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d7a7697e2f5abdd7d1b5777dab1c130af6f2a8e9" translate="yes" xml:space="preserve">
          <source>There are different date formats with different understandings of negative years. Common human language does not have a year 0. The year after 1BC is 1AD. This understanding is reflected when printing or parsing dates in one of the formats not standardized by ECMAScript. That is: toString(), &lt;a href=&quot;qml-qtqml-date#toLocaleString-method&quot;&gt;toLocaleString()&lt;/a&gt;, toUTCString() and friends. ECMAScript does standardize one format: ISO 8601. This is what you get when you call toISOString(). This format does include a year 0, which is 1BC in other formats. Thus you get different years when printing negative dates with toISOString() and toString().</source>
          <target state="translated">음의 연도에 대한 이해가 다른 여러 날짜 형식이 있습니다. 일반적인 인간 언어에는 0 년이 없습니다. 1BC 이후의 해는 1AD입니다. 이러한 이해는 ECMAScript에서 표준화하지 않은 형식 중 하나로 날짜를 인쇄하거나 구문 분석 할 때 반영됩니다. 즉, toString (), &lt;a href=&quot;qml-qtqml-date#toLocaleString-method&quot;&gt;toLocaleString ()&lt;/a&gt; , toUTCString () 및 친구입니다. ECMAScript는 ISO 8601 형식을 표준화합니다. 이것이 toISOString ()을 호출 할 때 얻게되는 것입니다. 이 형식에는 다른 형식의 1BC 인 0 년이 포함됩니다. 따라서 toISOString () 및 toString ()으로 음수 날짜를 인쇄 할 때 다른 연도를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="07e9b4ffbb092da2e2a0f4e8b7a1465a6e23609c" translate="yes" xml:space="preserve">
          <source>There are different methods to control animations.</source>
          <target state="translated">애니메이션을 제어하는 ​​방법에는 여러 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="07eb82092c7477ebc1f66f368eae52f9b74da3e9" translate="yes" xml:space="preserve">
          <source>There are essentially two kinds of text objects: those that are used with blocks (block formats), and those that are used with characters (character formats). The first kind are derived from &lt;a href=&quot;qtextblockgroup&quot;&gt;QTextBlockGroup&lt;/a&gt;, and the second kind from &lt;a href=&quot;qtextframe&quot;&gt;QTextFrame&lt;/a&gt;.</source>
          <target state="translated">본질적으로 두 가지 종류의 텍스트 개체가 있습니다 : 블록과 함께 사용되는 것 (블록 형식)과 문자와 함께 사용되는 것 (문자 형식). 첫 번째 종류는 &lt;a href=&quot;qtextblockgroup&quot;&gt;QTextBlockGroup&lt;/a&gt; 에서 파생되고 두 번째 종류는 &lt;a href=&quot;qtextframe&quot;&gt;QTextFrame&lt;/a&gt; 에서 파생 됩니다.</target>
        </trans-unit>
        <trans-unit id="eae3cc4596672943f016ebee27ba5a4b61c90913" translate="yes" xml:space="preserve">
          <source>There are five different ways that events can be processed; reimplementing this virtual function is just one of them. All five approaches are listed below:</source>
          <target state="translated">이벤트를 처리 할 수있는 5 가지 방법이 있습니다. 이 가상 기능을 다시 구현하는 것은 그 중 하나 일뿐입니다. 다섯 가지 접근 방식이 모두 아래에 나열되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f9ef8958446abb4410bb9f34879d10095cce2c3" translate="yes" xml:space="preserve">
          <source>There are four available types of extensions in</source>
          <target state="translated">확장에는 4 가지 유형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="58efed182a8757a6f8fb9dbc914a8d0e9f6151d2" translate="yes" xml:space="preserve">
          <source>There are four available types of extensions in Qt Designer: &lt;a href=&quot;qdesignercontainerextension&quot;&gt;QDesignerContainerExtension&lt;/a&gt; , &lt;a href=&quot;https://doc.qt.io/qt-5.13/qdesignermembersheetextension.html&quot;&gt;QDesignerMemberSheetExtension&lt;/a&gt;, &lt;a href=&quot;qdesignerpropertysheetextension&quot;&gt;QDesignerPropertySheetExtension&lt;/a&gt; and &lt;a href=&quot;qdesignertaskmenuextension&quot;&gt;QDesignerTaskMenuExtension&lt;/a&gt;. Qt Designer's behavior is the same whether the requested extension is associated with a multi page container, a member sheet, a property sheet or a task menu.</source>
          <target state="translated">Qt Designer에는 &lt;a href=&quot;qdesignercontainerextension&quot;&gt;QDesignerContainerExtension&lt;/a&gt; , &lt;a href=&quot;https://doc.qt.io/qt-5.13/qdesignermembersheetextension.html&quot;&gt;QDesignerMemberSheetExtension&lt;/a&gt; , &lt;a href=&quot;qdesignerpropertysheetextension&quot;&gt;QDesignerPropertySheetExtension&lt;/a&gt; 및 &lt;a href=&quot;qdesignertaskmenuextension&quot;&gt;QDesignerTaskMenuExtension의&lt;/a&gt; 네 가지 확장 유형이 있습니다 . 요청 된 확장이 다중 페이지 컨테이너, 멤버 시트, 속성 시트 또는 작업 메뉴와 연결되어 있는지 여부에 관계없이 Qt Designer의 동작은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="12584ec9a620a488670daf5b482e0b5c3f6dbbdd" translate="yes" xml:space="preserve">
          <source>There are four available types of extensions in Qt Designer: &lt;a href=&quot;qdesignercontainerextension&quot;&gt;QDesignerContainerExtension&lt;/a&gt; , &lt;a href=&quot;https://doc.qt.io/qt-5.15/qdesignermembersheetextension.html&quot;&gt;QDesignerMemberSheetExtension&lt;/a&gt;, &lt;a href=&quot;qdesignerpropertysheetextension&quot;&gt;QDesignerPropertySheetExtension&lt;/a&gt; and &lt;a href=&quot;qdesignertaskmenuextension&quot;&gt;QDesignerTaskMenuExtension&lt;/a&gt;. Qt Designer's behavior is the same whether the requested extension is associated with a multi page container, a member sheet, a property sheet or a task menu.</source>
          <target state="translated">Qt Designer에서 사용할 수있는 확장 유형에는 &lt;a href=&quot;qdesignercontainerextension&quot;&gt;QDesignerContainerExtension&lt;/a&gt; , &lt;a href=&quot;https://doc.qt.io/qt-5.15/qdesignermembersheetextension.html&quot;&gt;QDesignerMemberSheetExtension&lt;/a&gt; , &lt;a href=&quot;qdesignerpropertysheetextension&quot;&gt;QDesignerPropertySheetExtension&lt;/a&gt; 및 &lt;a href=&quot;qdesignertaskmenuextension&quot;&gt;QDesignerTaskMenuExtension이&lt;/a&gt; 있습니다. Qt Designer의 동작은 요청 된 확장이 다중 페이지 컨테이너, 멤버 시트, 속성 시트 또는 작업 메뉴와 연결되어 있는지에 관계없이 동일합니다.</target>
        </trans-unit>
        <trans-unit id="87354f9520b6d3c85508bde2b3c25fa2a0d16881" translate="yes" xml:space="preserve">
          <source>There are four available types of extensions in Qt Designer: &lt;a href=&quot;qdesignercontainerextension&quot;&gt;QDesignerContainerExtension&lt;/a&gt; , &lt;a href=&quot;https://doc.qt.io/qt-6.0/qdesignermembersheetextension.html&quot;&gt;QDesignerMemberSheetExtension&lt;/a&gt;, &lt;a href=&quot;qdesignerpropertysheetextension&quot;&gt;QDesignerPropertySheetExtension&lt;/a&gt; and &lt;a href=&quot;qdesignertaskmenuextension&quot;&gt;QDesignerTaskMenuExtension&lt;/a&gt;. Qt Designer's behavior is the same whether the requested extension is associated with a multi page container, a member sheet, a property sheet or a task menu.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04f55dc62df3c1e56f91728ca1c8ccaa75167f2e" translate="yes" xml:space="preserve">
          <source>There are four dock widget areas as given by the &lt;a href=&quot;qt#DockWidgetArea-enum&quot;&gt;Qt::DockWidgetArea&lt;/a&gt; enum: left, right, top, and bottom. You can specify which dock widget area that should occupy the corners where the areas overlap with &lt;code&gt;setCorner()&lt;/code&gt;. By default each area can only contain one row (vertical or horizontal) of dock widgets, but if you enable nesting with &lt;code&gt;setDockNestingEnabled()&lt;/code&gt;, dock widgets can be added in either direction.</source>
          <target state="translated">&lt;a href=&quot;qt#DockWidgetArea-enum&quot;&gt;Qt :: DockWidgetArea&lt;/a&gt; enum : 왼쪽, 오른쪽, 위, 아래에 주어진 4 개의 도크 위젯 영역이 있습니다 . 영역이 &lt;code&gt;setCorner()&lt;/code&gt; 와 겹치는 모서리를 차지해야하는 도크 위젯 영역을 지정할 수 있습니다 . 기본적으로 각 영역에는 한 행 (수직 또는 가로)의 독 위젯이 포함될 수 있지만 &lt;code&gt;setDockNestingEnabled()&lt;/code&gt; 중첩을 활성화하면 독 위젯을 어느 방향 으로든 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="21a014320627a46dd71b1e5a58115760d7b1b7c3" translate="yes" xml:space="preserve">
          <source>There are four kinds of action items: separators, actions that show a submenu, widgets, and actions that perform an action. Separators are inserted with &lt;a href=&quot;qmenu#addSeparator&quot;&gt;addSeparator&lt;/a&gt;(), submenus with &lt;a href=&quot;qmenu#addMenu&quot;&gt;addMenu&lt;/a&gt;(), and all other items are considered action items.</source>
          <target state="translated">구분자, 하위 메뉴를 표시하는 조치, 위젯 및 조치를 수행하는 조치의 네 가지 조치 항목이 있습니다. 구분 기호는 &lt;a href=&quot;qmenu#addSeparator&quot;&gt;addSeparator&lt;/a&gt; () 로 삽입되고 &lt;a href=&quot;qmenu#addMenu&quot;&gt;addMenu&lt;/a&gt; ()가있는 하위 메뉴 및 기타 모든 항목은 작업 항목으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="dc183659caaf98151d1355e46affa28ab60a79ec" translate="yes" xml:space="preserve">
          <source>There are four ways to call APIs on the COM object:</source>
          <target state="translated">COM 객체에서 API를 호출하는 방법에는 네 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb43a1eeae7a259f2eab7490a3b86620bf2672ef" translate="yes" xml:space="preserve">
          <source>There are functions to convert between &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt; and &lt;a href=&quot;qpixmap&quot;&gt;QPixmap&lt;/a&gt;. Typically, the &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt; class is used to load an image file, optionally manipulating the image data, before the &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt; object is converted into a &lt;a href=&quot;qpixmap&quot;&gt;QPixmap&lt;/a&gt; to be shown on screen. Alternatively, if no manipulation is desired, the image file can be loaded directly into a &lt;a href=&quot;qpixmap&quot;&gt;QPixmap&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt; 와 &lt;a href=&quot;qpixmap&quot;&gt;QPixmap&lt;/a&gt; 사이를 변환하는 기능이 있습니다 . 일반적으로 &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt; 클래스는 &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt; 객체를 &lt;a href=&quot;qpixmap&quot;&gt;QPixmap&lt;/a&gt; 으로 변환하여 화면에 표시 하기 전에 이미지 파일을로드하고 선택적으로 이미지 데이터를 조작하는 데 사용됩니다 . 또는 조작이 필요없는 경우 이미지 파일을 &lt;a href=&quot;qpixmap&quot;&gt;QPixmap에&lt;/a&gt; 직접로드 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8f4c1bfff81a0bd9913f68e2b5b3408fccfc315b" translate="yes" xml:space="preserve">
          <source>There are functions to convert between &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt; and QPixmap. Typically, the &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt; class is used to load an image file, optionally manipulating the image data, before the &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt; object is converted into a QPixmap to be shown on screen. Alternatively, if no manipulation is desired, the image file can be loaded directly into a QPixmap.</source>
          <target state="translated">&lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt; 와 QPixmap 간에 변환하는 함수가 있습니다 . 일반적으로 &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt; 클래스는 &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt; 객체가 화면에 표시되도록 QPixmap으로 변환 되기 전에 이미지 파일을로드하고 선택적으로 이미지 데이터를 조작하는 데 사용됩니다 . 또는 조작이 필요하지 않은 경우 이미지 파일을 QPixmap에 직접로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bd625878f025614262bcf951ea1085cfdbe0fb3a" translate="yes" xml:space="preserve">
          <source>There are functions to draw pixmaps/images, namely &lt;a href=&quot;qpainter#drawPixmap&quot;&gt;drawPixmap&lt;/a&gt;(), &lt;a href=&quot;qpainter#drawImage&quot;&gt;drawImage&lt;/a&gt;() and &lt;a href=&quot;qpainter#drawTiledPixmap&quot;&gt;drawTiledPixmap&lt;/a&gt;(). Both &lt;a href=&quot;qpainter#drawPixmap&quot;&gt;drawPixmap&lt;/a&gt;() and &lt;a href=&quot;qpainter#drawImage&quot;&gt;drawImage&lt;/a&gt;() produce the same result, except that &lt;a href=&quot;qpainter#drawPixmap&quot;&gt;drawPixmap&lt;/a&gt;() is faster on-screen while &lt;a href=&quot;qpainter#drawImage&quot;&gt;drawImage&lt;/a&gt;() may be faster on a &lt;a href=&quot;qprinter&quot;&gt;QPrinter&lt;/a&gt; or other devices.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="185c709fdfdd2342cedd39fe7a41807a13acb3e9" translate="yes" xml:space="preserve">
          <source>There are functions to draw pixmaps/images, namely &lt;a href=&quot;qpainter#drawPixmap&quot;&gt;drawPixmap&lt;/a&gt;(), &lt;a href=&quot;qpainter#drawImage&quot;&gt;drawImage&lt;/a&gt;() and &lt;a href=&quot;qpainter#drawTiledPixmap&quot;&gt;drawTiledPixmap&lt;/a&gt;(). Both &lt;a href=&quot;qpainter#drawPixmap&quot;&gt;drawPixmap&lt;/a&gt;() and &lt;a href=&quot;qpainter#drawImage&quot;&gt;drawImage&lt;/a&gt;() produce the same result, except that &lt;a href=&quot;qpainter#drawPixmap&quot;&gt;drawPixmap&lt;/a&gt;() is faster on-screen while &lt;a href=&quot;qpainter#drawImage&quot;&gt;drawImage&lt;/a&gt;() may be faster on a QPrinter or other devices.</source>
          <target state="translated">픽스맵 / 이미지를 그리는 함수는 &lt;a href=&quot;qpainter#drawPixmap&quot;&gt;drawPixmap&lt;/a&gt; (), &lt;a href=&quot;qpainter#drawImage&quot;&gt;drawImage&lt;/a&gt; () 및 &lt;a href=&quot;qpainter#drawTiledPixmap&quot;&gt;drawTiledPixmap&lt;/a&gt; ()입니다. 두 &lt;a href=&quot;qpainter#drawPixmap&quot;&gt;drawPixmap&lt;/a&gt; ()과 &lt;a href=&quot;qpainter#drawImage&quot;&gt;의 drawImage&lt;/a&gt; ()을 제외하고 동일한 결과를 생성한다는 &lt;a href=&quot;qpainter#drawPixmap&quot;&gt;drawPixmap는&lt;/a&gt; 동안 () 빠른 화면이다 &lt;a href=&quot;qpainter#drawImage&quot;&gt;의 drawImage는&lt;/a&gt; () 빠르게 QPrinter 또는 다른 장치 일 수있다.</target>
        </trans-unit>
        <trans-unit id="b7ecd887f57f1c1c00ecdd923983972dc5d828f3" translate="yes" xml:space="preserve">
          <source>There are further options to tweak the configurations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="521d8db0536fd765278ae6e2c04f3900d2895da3" translate="yes" xml:space="preserve">
          <source>There are further restrictions for OpenGL-based windows. As of Qt 5.3, eglfs supports a single, fullscreen GL window (for example, an OpenGL-based &lt;a href=&quot;qwindow&quot;&gt;QWindow&lt;/a&gt;, a &lt;a href=&quot;qquickview&quot;&gt;QQuickView&lt;/a&gt; or a QGLWidget). Opening additional OpenGL windows or mixing such windows with &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt;-based content is not supported and will terminate the application with an error message.</source>
          <target state="translated">OpenGL 기반 창에 대한 추가 제한 사항이 있습니다. Qt 5.3부터 eglfs는 단일 전체 화면 GL 창 (예 : OpenGL 기반 &lt;a href=&quot;qwindow&quot;&gt;QWindow&lt;/a&gt; , &lt;a href=&quot;qquickview&quot;&gt;QQuickView&lt;/a&gt; 또는 QGLWidget)을 지원합니다. 추가 OpenGL 창을 열거 나 이러한 창을 &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; 기반 컨텐츠 와 혼합하는 것은 지원되지 않으며 오류 메시지와 함께 응용 프로그램이 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="b663be5c758ae53f84b6799c6b53c2a5d5faa41e" translate="yes" xml:space="preserve">
          <source>There are further restrictions for OpenGL-based windows. EGLFS supports a single single fullscreen GL window (as of Qt 5.3), like OpenGL-based &lt;a href=&quot;qwindow&quot;&gt;QWindow&lt;/a&gt;, a &lt;a href=&quot;qquickview&quot;&gt;QQuickView&lt;/a&gt;, or a &lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt;. Opening additional OpenGL windows or mixing such windows with &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt;-based content isn't supported; Qt terminates the application with an error message.</source>
          <target state="translated">OpenGL 기반 창에 대한 추가 제한 사항이 있습니다. EGLFS는 OpenGL 기반 &lt;a href=&quot;qwindow&quot;&gt;QWindow&lt;/a&gt; , &lt;a href=&quot;qquickview&quot;&gt;QQuickView&lt;/a&gt; 또는 QOpenGLWidget 과 같은 단일 단일 전체 화면 GL 창 (Qt 5.3 현재)을 &lt;a href=&quot;qopenglwidget&quot;&gt;지원&lt;/a&gt; 합니다. 추가 OpenGL 창을 열거 나 이러한 창을 &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; 기반 컨텐츠 와 혼합하는 것은 지원되지 않습니다. Qt는 오류 메시지와 함께 응용 프로그램을 종료합니다.</target>
        </trans-unit>
        <trans-unit id="5b99e5cc118ee703b6b539e3c33032a9f36990d6" translate="yes" xml:space="preserve">
          <source>There are further restrictions for OpenGL-based windows. EGLFS supports a single single fullscreen GL window (as of Qt 5.3), like OpenGL-based &lt;a href=&quot;qwindow&quot;&gt;QWindow&lt;/a&gt;, a &lt;a href=&quot;qquickview&quot;&gt;QQuickView&lt;/a&gt;, or a &lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt;. Opening additional OpenGL windows or mixing such windows with &lt;a href=&quot;widgets-changes-qt6#qwidget&quot;&gt;QWidget&lt;/a&gt;-based content isn't supported; Qt terminates the application with an error message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71f391e47a00b9303f3dde668f46f3df9ce907cc" translate="yes" xml:space="preserve">
          <source>There are generated replicas (replicas having the header files produced by the &lt;a href=&quot;qtremoteobjects-repc&quot;&gt;Replica Compiler&lt;/a&gt;), and dynamic replicas, which are generated on-the-fly. This is the class for the dynamic type of replica.</source>
          <target state="translated">생성 된 복제본 ( &lt;a href=&quot;qtremoteobjects-repc&quot;&gt;Replica Compiler에서&lt;/a&gt; 생성 한 헤더 파일이있는 복제본 )과 즉석에서 생성되는 동적 복제본이 있습니다. 동적 유형의 복제본에 대한 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="3890a66cd2a8305a6c2901485f051e704d25593f" translate="yes" xml:space="preserve">
          <source>There are generated replicas (replicas having the header files produced by the &lt;a href=&quot;qtremoteobjects-repc#&quot;&gt;Replica Compiler&lt;/a&gt;), and dynamic replicas, which are generated on-the-fly. This is the class for the dynamic type of replica.</source>
          <target state="translated">생성 된 복제본 ( &lt;a href=&quot;qtremoteobjects-repc#&quot;&gt;Replication Compiler에서&lt;/a&gt; 생성 한 헤더 파일이있는 복제본 )과 동적 복제본이 있으며, 이는 즉시 생성됩니다. 동적 유형의 복제본 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="5fa8f6502463bcbc5f15ce8f09377bc86f886316" translate="yes" xml:space="preserve">
          <source>There are inherited classes for each supported series type: &lt;a href=&quot;qbar3dseries&quot;&gt;QBar3DSeries&lt;/a&gt;, &lt;a href=&quot;qscatter3dseries&quot;&gt;QScatter3DSeries&lt;/a&gt;, and &lt;a href=&quot;qsurface3dseries&quot;&gt;QSurface3DSeries&lt;/a&gt;.</source>
          <target state="translated">지원되는 각 시리즈 유형 ( &lt;a href=&quot;qbar3dseries&quot;&gt;QBar3DSeries&lt;/a&gt; , &lt;a href=&quot;qscatter3dseries&quot;&gt;QScatter3DSeries&lt;/a&gt; 및 &lt;a href=&quot;qsurface3dseries&quot;&gt;QSurface3DSeries)&lt;/a&gt; 에 대해 상속 된 클래스가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8c7de94969c84be6b162608d604474db112526f2" translate="yes" xml:space="preserve">
          <source>There are many different settings for each part of the recording process (audio, video, and output formats), as well as control over muting and where to store the output file.</source>
          <target state="translated">녹음 과정의 각 부분 (오디오, 비디오 및 출력 형식)에 대한 다양한 설정과 음소거 및 출력 파일을 저장할 위치를 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b109205c5d73bd29af3456e423f73c3fb75b68a6" translate="yes" xml:space="preserve">
          <source>There are many different ways and techniques to unwrap 3D meshes. The most basic way to do it in Blender is described below.</source>
          <target state="translated">3D 메시를 풀기위한 다양한 방법과 기술이 있습니다. Blender에서 가장 기본적인 방법은 아래에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="b902a0c84600654d3b360a1ac3b13eba5ac4ad69" translate="yes" xml:space="preserve">
          <source>There are many more functions and operators defined for &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt; and XPath. They are all &lt;a href=&quot;http://www.w3.org/TR/xpath-functions&quot;&gt;documented in the specification&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt; 및 XPath에 대해 더 많은 함수와 연산자가 정의되어 있습니다. 그것들은 모두 &lt;a href=&quot;http://www.w3.org/TR/xpath-functions&quot;&gt;사양에 문서화되어&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="42b04540a66ad4fa84216e59f87e7bb9b1eaee48" translate="yes" xml:space="preserve">
          <source>There are many more functions and operators defined for &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt; and XPath. They are all &lt;a href=&quot;http://www.w3.org/TR/xpath-functions&quot;&gt;documented in the specification&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt; 및 XPath에 대해 더 많은 함수와 연산자가 정의되어 있습니다. 그것들은 모두 &lt;a href=&quot;http://www.w3.org/TR/xpath-functions&quot;&gt;사양서에 문서화되어&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="f7e7ecc705f5981a61338b695254227515ae3255" translate="yes" xml:space="preserve">
          <source>There are many options that you can add to the query to narrow the criteria. The &lt;a href=&quot;qml-qtlocation-routequery&quot;&gt;RouteQuery&lt;/a&gt; properties can include</source>
          <target state="translated">기준을 좁히기 위해 쿼리에 추가 할 수있는 많은 옵션이 있습니다. &lt;a href=&quot;qml-qtlocation-routequery&quot;&gt;RouteQuery의&lt;/a&gt; 특성을 포함 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="932ef5d83bbb6264fa878988be595bc7f801d0b0" translate="yes" xml:space="preserve">
          <source>There are many ways to construct a &lt;a href=&quot;qsslcertificate&quot;&gt;QSslCertificate&lt;/a&gt;. The most common way is to call &lt;a href=&quot;qsslsocket#peerCertificate&quot;&gt;QSslSocket::peerCertificate&lt;/a&gt;(), which returns a &lt;a href=&quot;qsslcertificate&quot;&gt;QSslCertificate&lt;/a&gt; object, or &lt;a href=&quot;qsslsocket#peerCertificateChain&quot;&gt;QSslSocket::peerCertificateChain&lt;/a&gt;(), which returns a list of them. You can also load certificates from a DER (binary) or PEM (Base64) encoded bundle, typically stored as one or more local files, or in a Qt Resource.</source>
          <target state="translated">&lt;a href=&quot;qsslcertificate&quot;&gt;QSslCertificate&lt;/a&gt; 를 구성하는 방법에는 여러 가지가 있습니다 . 가장 일반적인 방법은 &lt;a href=&quot;qsslsocket#peerCertificate&quot;&gt;QSslSocket :: peerCertificate&lt;/a&gt; () 를 호출 하여 &lt;a href=&quot;qsslcertificate&quot;&gt;QSslCertificate&lt;/a&gt; 객체 를 반환 하거나 &lt;a href=&quot;qsslsocket#peerCertificateChain&quot;&gt;QSslSocket :: peerCertificateChain&lt;/a&gt; ()을 호출 하여 목록을 반환하는 것입니다. 또한 일반적으로 하나 이상의 로컬 파일로 저장되거나 Qt 리소스에 저장된 DER (바이너리) 또는 PEM (Base64) 인코딩 번들에서 인증서를로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9ef9fb7e34fb501e0a412d94c3c3d3ac1acd8837" translate="yes" xml:space="preserve">
          <source>There are many ways to construct a QSslCertificate. The most common way is to call &lt;a href=&quot;qsslsocket#peerCertificate&quot;&gt;QSslSocket::peerCertificate&lt;/a&gt;(), which returns a QSslCertificate object, or &lt;a href=&quot;qsslsocket#peerCertificateChain&quot;&gt;QSslSocket::peerCertificateChain&lt;/a&gt;(), which returns a list of them. You can also load certificates from a DER (binary) or PEM (Base64) encoded bundle, typically stored as one or more local files, or in a Qt Resource.</source>
          <target state="translated">QSslCertificate를 구성하는 방법에는 여러 가지가 있습니다. 가장 일반적인 방법은 호출하는 것입니다 &lt;a href=&quot;qsslsocket#peerCertificate&quot;&gt;QSslSocket :: peerCertificate&lt;/a&gt; QSslCertificate 객체를 반환 (), 또는 &lt;a href=&quot;qsslsocket#peerCertificateChain&quot;&gt;QSslSocket :: peerCertificateChain&lt;/a&gt; 그 목록을 반환 (을). 일반적으로 하나 이상의 로컬 파일로 저장되거나 Qt 리소스에 저장되는 DER (이진) 또는 PEM (Base64) 인코딩 번들에서 인증서를로드 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="796c84ae1ac166450fb706ad8e98fe858c1b55b8" translate="yes" xml:space="preserve">
          <source>There are no changes to the source side as a dynamic &lt;a href=&quot;qtremoteobjects-replica#replica&quot;&gt;Replica&lt;/a&gt; only impacts how the requestor node acquires the replica. The source-side code shown in &lt;a href=&quot;#qtro-example1&quot;&gt;Example 1&lt;/a&gt; will be used.</source>
          <target state="translated">동적 &lt;a href=&quot;qtremoteobjects-replica#replica&quot;&gt;복제본&lt;/a&gt; 은 요청자 노드가 복제본을 획득하는 방법에만 영향을 미치 므로 소스 측에는 변경 사항이 없습니다 . &lt;a href=&quot;#qtro-example1&quot;&gt;예제 1에&lt;/a&gt; 표시된 소스 측 코드 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="19fbd6ff11e94b3343e1f862684027ca17e17412" translate="yes" xml:space="preserve">
          <source>There are no corner widgets</source>
          <target state="translated">코너 위젯이 없습니다</target>
        </trans-unit>
        <trans-unit id="3417cb54c916104fc6041a7759695abf59d6831b" translate="yes" xml:space="preserve">
          <source>There are no environment variables. Qt emulates the functionality by maintaining the values locally, so that &lt;a href=&quot;#qputenv&quot;&gt;qputenv&lt;/a&gt;() and related functions continue to work. All known variables influencing Qt can be set in source code.</source>
          <target state="translated">환경 변수가 없습니다. Qt는 &lt;a href=&quot;#qputenv&quot;&gt;qputenv&lt;/a&gt; () 및 관련 기능이 계속 작동 하도록 값을 로컬로 유지하여 기능을 에뮬레이트합니다 . Qt에 영향을 미치는 모든 알려진 변수는 소스 코드에서 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="477a9d2b45d6cefa6c740299a59db4a17f160b8f" translate="yes" xml:space="preserve">
          <source>There are no environment variables. Qt emulates the functionality by maintaining the values locally, so that &lt;a href=&quot;qtglobal#qputenv&quot;&gt;qputenv&lt;/a&gt;() and related functions continue to work. All known variables influencing Qt can be set in source code.</source>
          <target state="translated">환경 변수가 없습니다. Qt는 값을 로컬로 유지하여 기능을 에뮬레이트하므로 &lt;a href=&quot;qtglobal#qputenv&quot;&gt;qputenv&lt;/a&gt; () 및 관련 함수가 계속 작동합니다. Qt에 영향을 미치는 알려진 모든 변수는 소스 코드에서 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf56461d57638a833a7bfe6f1ef6411f4e3d9149" translate="yes" xml:space="preserve">
          <source>There are no known problems with using Qt on production versions of Linux/x86, Linux/ppc, Linux/amd64 and Linux/ia64 (including Altix(R)).</source>
          <target state="translated">Linux / x86, Linux / ppc, Linux / amd64 및 Linux / ia64 프로덕션 버전 (Altix&amp;reg; 포함)에서 Qt를 사용하는 데있어 알려진 문제는 없습니다.</target>
        </trans-unit>
        <trans-unit id="31c7a1b27ae189369feae0cd376e6c48954ca278" translate="yes" xml:space="preserve">
          <source>There are no predefined materials included in &lt;a href=&quot;https://doc.qt.io/qt-6.0/qtquick3d-qmlmodule.html&quot;&gt;QtQuick3D&lt;/a&gt; 6.0. Any materials added in future releases will probably not be compatible with the old ones. The Materials import does not exist. (The &lt;a href=&quot;qml-qtquick3d-custommaterial&quot;&gt;CustomMaterial&lt;/a&gt; type is moved to the base &lt;a href=&quot;https://doc.qt.io/qt-6.0/qtquick3d-qmlmodule.html&quot;&gt;QtQuick3D&lt;/a&gt; import.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4a8ac08596ce8f63b9121a5223339f7f158f188" translate="yes" xml:space="preserve">
          <source>There are no restricitions on what you do to your own variables, as qmake will ignore them unless it needs to evaluate them when processing a scope.</source>
          <target state="translated">범위를 처리 할 때 변수를 평가할 필요가없는 한 qmake는 변수를 무시하므로 자신의 변수에 대해 수행 한 작업에 대한 제한은 없습니다.</target>
        </trans-unit>
        <trans-unit id="e3fd8901ca6e6c67410ab1387e9fe06d56acf90c" translate="yes" xml:space="preserve">
          <source>There are no restriction on the sharing of elements between different scenes in different Scene3DView instances.</source>
          <target state="translated">서로 다른 Scene3DView 인스턴스의 서로 다른 장면 간의 요소 공유에는 제한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="c13de2fa0619b8ce7ac03eff32c5699ac7c52886" translate="yes" xml:space="preserve">
          <source>There are no source or binary compatibility guarantees for the QPA classes, meaning that a platform plugin is only guaranteed to work with the Qt version it was developed against. API changes will however only be made in minor releases. (5.1, 5.2, and so on.)</source>
          <target state="translated">QPA 클래스에 대한 소스 또는 이진 호환성 보장은 없습니다. 즉, 플랫폼 플러그인은 개발 된 Qt 버전에서만 작동하도록 보장됩니다. 그러나 API 변경은 부 릴리스에서만 이루어집니다. (5.1, 5.2 등)</target>
        </trans-unit>
        <trans-unit id="428363c3f3bdc74ff19cd2ca28f4c2d95ebd5617" translate="yes" xml:space="preserve">
          <source>There are no source or binary compatibility guarantees for the QPA classes, meaning that the API is only guaranteed to work with the Qt version it was developed against. API changes will however only be made in minor releases. (5.1, 5.2, and so on.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bb911d7e0486f49f00be4171ebf250b6677683d" translate="yes" xml:space="preserve">
          <source>There are no source or binary compatibility guarantees for the native interface APIs, meaning that an application using these interfaces is only guaranteed to work with the Qt version it was developed against.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b48293c428a6e649eae68c408dfa8c993b017970" translate="yes" xml:space="preserve">
          <source>There are no special in-string modifiers for formatting dates and times. Instead, you need to query the current locale (geographical region) and use the methods of &lt;a href=&quot;qml-qtqml-date&quot;&gt;Date&lt;/a&gt; to format the string.</source>
          <target state="translated">날짜 및 시간을 형식화하기위한 특수 문자열 내 수정자는 없습니다. 대신 현재 로캘 (지리적 지역)을 쿼리하고 &lt;a href=&quot;qml-qtqml-date&quot;&gt;Date&lt;/a&gt; 메서드 를 사용하여 문자열 형식을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="cbed3e1b0f64090e26b0dfa4ca80fd256f7ece7f" translate="yes" xml:space="preserve">
          <source>There are no subpixels.</source>
          <target state="translated">하위 픽셀이 없습니다.</target>
        </trans-unit>
        <trans-unit id="18a1b6c49641099425c3e89248486e6ac6f810fb" translate="yes" xml:space="preserve">
          <source>There are no supported media playback facilities.</source>
          <target state="translated">지원되는 미디어 재생 기능이 없습니다.</target>
        </trans-unit>
        <trans-unit id="589e132b82fb048d165d6f9be51fd47cee1ca5cc" translate="yes" xml:space="preserve">
          <source>There are no supported video playback facilities.</source>
          <target state="translated">지원되는 비디오 재생 기능이 없습니다.</target>
        </trans-unit>
        <trans-unit id="4777517d32bf78809fbb7fc1cc330731b2df5487" translate="yes" xml:space="preserve">
          <source>There are not the appropriate permissions to play a media resource.</source>
          <target state="translated">미디어 리소스를 재생할 수있는 적절한 권한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="6a3b928810196b34b1955a0231763ee1af3493e1" translate="yes" xml:space="preserve">
          <source>There are pecific requirements and instructions for developing applications on different platforms are covered in the platform pages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ce6e34dbdc96b86444ab991d3f8d5158acf483b" translate="yes" xml:space="preserve">
          <source>There are several advantages to using &lt;a href=&quot;qobject#connect&quot;&gt;QObject::connect&lt;/a&gt;() with function pointers. First, it allows the compiler to check that the signal's arguments are compatible with the slot's arguments. Arguments can also be implicitly converted by the compiler, if needed.</source>
          <target state="translated">함수 포인터와 함께 &lt;a href=&quot;qobject#connect&quot;&gt;QObject :: connect&lt;/a&gt; () 를 사용하면 몇 가지 장점이 있습니다 . 먼저, 컴파일러가 신호의 인수가 슬롯의 인수와 호환되는지 확인할 수 있습니다. 필요한 경우 컴파일러에서 인수를 암시 적으로 변환 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="2720eb6491911c7c04ea56e3b4892594b19ba798" translate="yes" xml:space="preserve">
          <source>There are several authentication systems, including:</source>
          <target state="translated">다음을 포함한 여러 인증 시스템이 있습니다.</target>
        </trans-unit>
        <trans-unit id="5580356cd5d83329110b41486d5a1249a9ae1a57" translate="yes" xml:space="preserve">
          <source>There are several available types of extensions in</source>
          <target state="translated">확장에는 몇 가지 유형의 확장이 있습니다.</target>
        </trans-unit>
        <trans-unit id="2488f13302a7aaeccbdfae2de27ea6429b8b8728" translate="yes" xml:space="preserve">
          <source>There are several changes made to the &lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt;/&lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt; implementation. The &lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt; related one is: insertion at the beginning is optimized (similarly to &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt; in Qt 5). The &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt; related one is: memory layout for the elements is simplified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="399367c35d08ea628b951780a061eefc80aae7c2" translate="yes" xml:space="preserve">
          <source>There are several different &lt;a href=&quot;https://material.google.com/style/color.html#color-color-palette&quot;&gt;shades&lt;/a&gt; of each &lt;a href=&quot;#pre-defined-material-colors&quot;&gt;pre-defined color&lt;/a&gt; that can be passed to the &lt;a href=&quot;#material-color-attached-method&quot;&gt;Material.color()&lt;/a&gt; function:</source>
          <target state="translated">&lt;a href=&quot;#material-color-attached-method&quot;&gt;Material.color ()&lt;/a&gt; 함수에 전달할 수있는 &lt;a href=&quot;#pre-defined-material-colors&quot;&gt;미리 정의 된&lt;/a&gt; 각 &lt;a href=&quot;https://material.google.com/style/color.html#color-color-palette&quot;&gt;색상&lt;/a&gt; 에는 여러 가지 음영 이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0140e651bbe52afecf65f4252b6525969da06c25" translate="yes" xml:space="preserve">
          <source>There are several different &lt;a href=&quot;https://material.google.com/style/color.html#color-color-palette&quot;&gt;shades&lt;/a&gt; of each &lt;a href=&quot;qtquickcontrols2-material#pre-defined-material-colors&quot;&gt;pre-defined color&lt;/a&gt; that can be passed to the &lt;a href=&quot;qtquickcontrols2-material#material-color-attached-method&quot;&gt;Material.color()&lt;/a&gt; function:</source>
          <target state="translated">&lt;a href=&quot;qtquickcontrols2-material#material-color-attached-method&quot;&gt;Material.color ()&lt;/a&gt; 함수에 전달할 수있는 &lt;a href=&quot;qtquickcontrols2-material#pre-defined-material-colors&quot;&gt;미리 정의 된&lt;/a&gt; 각 &lt;a href=&quot;https://material.google.com/style/color.html#color-color-palette&quot;&gt;색상&lt;/a&gt; 의 여러 가지 음영 이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="36e6d02c6e96a265e9e533e99202f12b4576ff88" translate="yes" xml:space="preserve">
          <source>There are several formats the</source>
          <target state="translated">몇 가지 형식이 있습니다</target>
        </trans-unit>
        <trans-unit id="af4a0442e2bc3610644a73a8924b8db324be1404" translate="yes" xml:space="preserve">
          <source>There are several formats the image file can be given in, but if it is not in a directly usable format, a conversion is made.</source>
          <target state="translated">이미지 파일에 몇 가지 형식이 제공 될 수 있지만 직접 사용할 수있는 형식이 아닌 경우 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="b91af185d5a779f526bbf8c8d0b21a6ab197126d" translate="yes" xml:space="preserve">
          <source>There are several functions in &lt;a href=&quot;qgeoroutingmanager&quot;&gt;QGeoRoutingManager&lt;/a&gt; which can be used to check which features are supported with the current provider and authorization level.</source>
          <target state="translated">&lt;a href=&quot;qgeoroutingmanager&quot;&gt;QGeoRoutingManager&lt;/a&gt; 에는 현재 공급자 및 권한 부여 수준에서 지원되는 기능을 확인하는 데 사용할 수있는 몇 가지 기능 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f29f709ac0b918676228d902c7b22d7a906068c9" translate="yes" xml:space="preserve">
          <source>There are several functions that operate on the font: &lt;a href=&quot;qfontmetrics#ascent&quot;&gt;ascent&lt;/a&gt;(), &lt;a href=&quot;qfontmetrics#descent&quot;&gt;descent&lt;/a&gt;(), &lt;a href=&quot;qfontmetrics#height&quot;&gt;height&lt;/a&gt;(), &lt;a href=&quot;qfontmetrics#leading&quot;&gt;leading&lt;/a&gt;() and &lt;a href=&quot;qfontmetrics#lineSpacing&quot;&gt;lineSpacing&lt;/a&gt;() return the basic size properties of the font. The &lt;a href=&quot;qfontmetrics#underlinePos&quot;&gt;underlinePos&lt;/a&gt;(), &lt;a href=&quot;qfontmetrics#overlinePos&quot;&gt;overlinePos&lt;/a&gt;(), &lt;a href=&quot;qfontmetrics#strikeOutPos&quot;&gt;strikeOutPos&lt;/a&gt;() and &lt;a href=&quot;qfontmetrics#lineWidth&quot;&gt;lineWidth&lt;/a&gt;() functions, return the properties of the line that underlines, overlines or strikes out the characters. These functions are all fast.</source>
          <target state="translated">글꼴에서 작동하는 몇 가지 기능이 있습니다. &lt;a href=&quot;qfontmetrics#ascent&quot;&gt;ascent&lt;/a&gt; (), &lt;a href=&quot;qfontmetrics#descent&quot;&gt;descent&lt;/a&gt; (), &lt;a href=&quot;qfontmetrics#height&quot;&gt;height&lt;/a&gt; (), &lt;a href=&quot;qfontmetrics#leading&quot;&gt;Leading&lt;/a&gt; () 및 &lt;a href=&quot;qfontmetrics#lineSpacing&quot;&gt;lineSpacing&lt;/a&gt; ()은 글꼴의 기본 크기 속성을 반환합니다. &lt;a href=&quot;qfontmetrics#underlinePos&quot;&gt;underlinePos&lt;/a&gt; (), &lt;a href=&quot;qfontmetrics#overlinePos&quot;&gt;overlinePos&lt;/a&gt; (), &lt;a href=&quot;qfontmetrics#strikeOutPos&quot;&gt;strikeOutPos&lt;/a&gt; ()와 &lt;a href=&quot;qfontmetrics#lineWidth&quot;&gt;선폭&lt;/a&gt; () 함수는, 라인의 속성을 돌려주는 문자 밖으로 밑줄, overlines 또는 파업. 이 기능은 모두 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="7b7be9d6988c6e4c37d0420c5cca9ff2215a3a62" translate="yes" xml:space="preserve">
          <source>There are several functions that operate on the font: &lt;a href=&quot;qfontmetricsf#ascent&quot;&gt;ascent&lt;/a&gt;(), &lt;a href=&quot;qfontmetricsf#descent&quot;&gt;descent&lt;/a&gt;(), &lt;a href=&quot;qfontmetricsf#height&quot;&gt;height&lt;/a&gt;(), &lt;a href=&quot;qfontmetricsf#leading&quot;&gt;leading&lt;/a&gt;() and &lt;a href=&quot;qfontmetricsf#lineSpacing&quot;&gt;lineSpacing&lt;/a&gt;() return the basic size properties of the font. The &lt;a href=&quot;qfontmetricsf#underlinePos&quot;&gt;underlinePos&lt;/a&gt;(), &lt;a href=&quot;qfontmetricsf#overlinePos&quot;&gt;overlinePos&lt;/a&gt;(), &lt;a href=&quot;qfontmetricsf#strikeOutPos&quot;&gt;strikeOutPos&lt;/a&gt;() and &lt;a href=&quot;qfontmetricsf#lineWidth&quot;&gt;lineWidth&lt;/a&gt;() functions, return the properties of the line that underlines, overlines or strikes out the characters. These functions are all fast.</source>
          <target state="translated">글꼴에서 작동하는 몇 가지 기능이 있습니다. &lt;a href=&quot;qfontmetricsf#ascent&quot;&gt;ascent&lt;/a&gt; (), &lt;a href=&quot;qfontmetricsf#descent&quot;&gt;descent&lt;/a&gt; (), &lt;a href=&quot;qfontmetricsf#height&quot;&gt;height&lt;/a&gt; (), &lt;a href=&quot;qfontmetricsf#leading&quot;&gt;Leading&lt;/a&gt; () 및 &lt;a href=&quot;qfontmetricsf#lineSpacing&quot;&gt;lineSpacing&lt;/a&gt; ()은 글꼴의 기본 크기 속성을 반환합니다. &lt;a href=&quot;qfontmetricsf#underlinePos&quot;&gt;underlinePos&lt;/a&gt; (), &lt;a href=&quot;qfontmetricsf#overlinePos&quot;&gt;overlinePos&lt;/a&gt; (), &lt;a href=&quot;qfontmetricsf#strikeOutPos&quot;&gt;strikeOutPos&lt;/a&gt; ()와 &lt;a href=&quot;qfontmetricsf#lineWidth&quot;&gt;선폭&lt;/a&gt; () 함수는, 라인의 속성을 돌려주는 문자 밖으로 밑줄, overlines 또는 파업. 이 기능은 모두 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="e377382f27f2b337f4496c4e71ffbb66d15b2fc3" translate="yes" xml:space="preserve">
          <source>There are several methods of assigning behavior animations to properties. The &lt;code&gt;Behavior on &amp;lt;property&amp;gt;&lt;/code&gt; declaration is a convenient way of assigning a behavior animation onto a property.</source>
          <target state="translated">비헤이비어 애니메이션을 속성에 할당하는 방법에는 여러 가지가 있습니다. &lt;code&gt;Behavior on &amp;lt;property&amp;gt;&lt;/code&gt; 선언은 속성에 행동 애니메이션을 할당하는 편리한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="77887c46b4d9770049a62e94450dce06a7ed7dc5" translate="yes" xml:space="preserve">
          <source>There are several new &lt;code&gt;View&lt;/code&gt; classes coming with Qt6. There is the already existing &lt;a href=&quot;qtcore-changes-qt6#qstringview&quot;&gt;QStringView&lt;/a&gt;, now accompanied by &lt;a href=&quot;qbytearrayview&quot;&gt;QByteArrayView&lt;/a&gt; and followed by a specialized &lt;a href=&quot;qutf8stringview&quot;&gt;QUtf8StringView&lt;/a&gt; and a more universal &lt;a href=&quot;qanystringview&quot;&gt;QAnyStringView&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9183ff4c5a05ce0180b8c00da5234e1d7a5c1a22" translate="yes" xml:space="preserve">
          <source>There are several other interfaces that should be implemented as required. &lt;a href=&quot;qaccessibletextinterface&quot;&gt;QAccessibleTextInterface&lt;/a&gt; should be used for bigger texts edits such as document views. This interface should not be implemented for labels/single line edits.</source>
          <target state="translated">필요에 따라 구현해야하는 다른 인터페이스가 몇 가지 있습니다. &lt;a href=&quot;qaccessibletextinterface&quot;&gt;QAccessibleTextInterface&lt;/a&gt; 는 문서보기와 같은 더 큰 텍스트 편집에 사용되어야합니다. 이 인터페이스는 레이블 / 한 줄 편집을 위해 구현되지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="1a983948dacf12a7c958034194a27919c9cd47e8" translate="yes" xml:space="preserve">
          <source>There are several other ways to position items in a user interface. In addition to the basic technique of specifying their coordinates directly, they can be positioned relative to other items with &lt;a href=&quot;qtquick-positioning-anchors&quot;&gt;anchors&lt;/a&gt;, or used with &lt;a href=&quot;qtquick-modelviewsdata-modelview#qml-data-models&quot;&gt;QML Data Models&lt;/a&gt; such as &lt;a href=&quot;qtquick-modelviewsdata-modelview#object-model&quot;&gt;Object Model&lt;/a&gt;.</source>
          <target state="translated">사용자 인터페이스에서 항목을 배치하는 몇 가지 다른 방법이 있습니다. 좌표를 직접 지정하는 기본 기술 외에도 &lt;a href=&quot;qtquick-positioning-anchors&quot;&gt;앵커&lt;/a&gt; 가있는 다른 항목에 상대적으로 배치 하거나 &lt;a href=&quot;qtquick-modelviewsdata-modelview#object-model&quot;&gt;객체 &lt;/a&gt;&lt;a href=&quot;qtquick-modelviewsdata-modelview#qml-data-models&quot;&gt;모델&lt;/a&gt; 과 같은 QML 데이터 모델 과 함께 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4d5106a704a965481123346759a42320a9b88519" translate="yes" xml:space="preserve">
          <source>There are several other ways to position items in a user interface. In addition to the basic technique of specifying their coordinates directly, they can be positioned relative to other items with &lt;a href=&quot;qtquick-positioning-anchors#&quot;&gt;anchors&lt;/a&gt;, or used with &lt;a href=&quot;qtquick-modelviewsdata-modelview#qml-data-models&quot;&gt;QML Data Models&lt;/a&gt; such as &lt;a href=&quot;qtquick-modelviewsdata-modelview#object-model&quot;&gt;Object Model&lt;/a&gt;.</source>
          <target state="translated">사용자 인터페이스에 항목을 배치하는 다른 방법이 몇 가지 있습니다. 좌표를 직접 지정하는 기본 기술 외에도 &lt;a href=&quot;qtquick-positioning-anchors#&quot;&gt;앵커&lt;/a&gt; 를 사용 하여 다른 항목을 기준으로 배치 하거나 &lt;a href=&quot;qtquick-modelviewsdata-modelview#object-model&quot;&gt;Object Model&lt;/a&gt; 과 같은 &lt;a href=&quot;qtquick-modelviewsdata-modelview#qml-data-models&quot;&gt;QML 데이터 모델&lt;/a&gt; 과 함께 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1b4b3bbe212ac8668476b33ac7414748eaf7b02f" translate="yes" xml:space="preserve">
          <source>There are several plugin base classes. Derived plugins are stored by default in sub-directories of the standard plugin directory. Qt will not find plugins if they are not stored in the appropriate directory.</source>
          <target state="translated">몇 가지 플러그인 기본 클래스가 있습니다. 파생 플러그인은 기본적으로 표준 플러그인 디렉토리의 하위 디렉토리에 저장됩니다. Qt는 플러그인이 적절한 디렉토리에 저장되어 있지 않으면 플러그인을 찾지 못합니다.</target>
        </trans-unit>
        <trans-unit id="520518be7653b8b406e09e00bb0bf5955942601d" translate="yes" xml:space="preserve">
          <source>There are several possible handlers depending on which &lt;a href=&quot;qml-qtquick-dialogs-messagedialog#standardButtons-prop&quot;&gt;standardButtons&lt;/a&gt; the dialog has and the &lt;a href=&quot;qmessagebox#ButtonRole-enum&quot;&gt;ButtonRole&lt;/a&gt; of each. For example, the &lt;a href=&quot;qml-qtquick-dialogs-messagedialog#rejected-signal&quot;&gt;onRejected&lt;/a&gt; handler will be called if the user presses a &lt;b&gt;Cancel&lt;/b&gt;, &lt;b&gt;Close&lt;/b&gt; or &lt;b&gt;Abort&lt;/b&gt; button.</source>
          <target state="translated">대화 상자 에있는 &lt;a href=&quot;qml-qtquick-dialogs-messagedialog#standardButtons-prop&quot;&gt;standardButton&lt;/a&gt; 과 각각 의 &lt;a href=&quot;qmessagebox#ButtonRole-enum&quot;&gt;ButtonRole&lt;/a&gt; 에 따라 가능한 처리기가 몇 가지 있습니다 . 예를 들어, 사용자가 &lt;b&gt;취소&lt;/b&gt; , &lt;b&gt;닫기&lt;/b&gt; 또는 &lt;b&gt;중단&lt;/b&gt; 버튼을 누르면 &lt;a href=&quot;qml-qtquick-dialogs-messagedialog#rejected-signal&quot;&gt;onRejected&lt;/a&gt; 핸들러가 호출됩니다 .&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="36e1de22b15d91af9843dd86aa2f679baee54b70" translate="yes" xml:space="preserve">
          <source>There are several related non-members: &lt;a href=&quot;qcolor#QRgb-typedef&quot;&gt;QRgb&lt;/a&gt; is a typdef for an unsigned int representing the RGB value triplet (r, g, b). Note that it also can hold a value for the alpha-channel (for more information, see the &lt;a href=&quot;qcolor#alpha-blended-drawing&quot;&gt;Alpha-Blended Drawing&lt;/a&gt; section). The &lt;a href=&quot;qcolor#qRed&quot;&gt;qRed&lt;/a&gt;(), &lt;a href=&quot;qcolor#qBlue&quot;&gt;qBlue&lt;/a&gt;() and &lt;a href=&quot;qcolor#qGreen&quot;&gt;qGreen&lt;/a&gt;() functions return the respective component of the given &lt;a href=&quot;qcolor#QRgb-typedef&quot;&gt;QRgb&lt;/a&gt; value, while the &lt;a href=&quot;qcolor#qRgb&quot;&gt;qRgb&lt;/a&gt;() and &lt;a href=&quot;qcolor#qRgba&quot;&gt;qRgba&lt;/a&gt;() functions create and return the &lt;a href=&quot;qcolor#QRgb-typedef&quot;&gt;QRgb&lt;/a&gt; triplet based on the given component values. Finally, the &lt;a href=&quot;qcolor#qAlpha&quot;&gt;qAlpha&lt;/a&gt;() function returns the alpha component of the provided &lt;a href=&quot;qcolor#QRgb-typedef&quot;&gt;QRgb&lt;/a&gt;, and the &lt;a href=&quot;qcolor#qGray&quot;&gt;qGray&lt;/a&gt;() function calculates and return a gray value based on the given value.</source>
          <target state="translated">몇 가지 관련 비 멤버가 있습니다. &lt;a href=&quot;qcolor#QRgb-typedef&quot;&gt;QRgb&lt;/a&gt; 는 RGB 값 삼중 항 (r, g, b)을 나타내는 부호없는 int에 대한 typdef입니다. 알파 채널에 대한 값을 보유 할 수도 있습니다 (자세한 내용은 &lt;a href=&quot;qcolor#alpha-blended-drawing&quot;&gt;알파 블렌딩 드로잉&lt;/a&gt; 섹션 참조). &lt;a href=&quot;qcolor#qRed&quot;&gt;qRed&lt;/a&gt; () &lt;a href=&quot;qcolor#qBlue&quot;&gt;qBlue&lt;/a&gt; () 및 &lt;a href=&quot;qcolor#qGreen&quot;&gt;qGreen&lt;/a&gt; () 함수는 소정의 각 컴포넌트 반환 &lt;a href=&quot;qcolor#QRgb-typedef&quot;&gt;QRgb의&lt;/a&gt; 그동안, 값 &lt;a href=&quot;qcolor#qRgb&quot;&gt;qRgb&lt;/a&gt; () 및 &lt;a href=&quot;qcolor#qRgba&quot;&gt;qRgba&lt;/a&gt; () 함수를 생성하고 리턴 &lt;a href=&quot;qcolor#QRgb-typedef&quot;&gt;QRgb가&lt;/a&gt; 주어진 성분 값에 기초하여 삼중. 마지막으로 &lt;a href=&quot;qcolor#qAlpha&quot;&gt;qAlpha&lt;/a&gt; () 함수는 제공된 &lt;a href=&quot;qcolor#QRgb-typedef&quot;&gt;QRgb&lt;/a&gt; 의 알파 구성 요소 와 &lt;a href=&quot;qcolor#qGray&quot;&gt;qGray를 리턴합니다.&lt;/a&gt;() 함수는 주어진 값을 기반으로 회색 값을 계산하고 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bc9a92266ce9ead23acd50c161dff2cc71eefc31" translate="yes" xml:space="preserve">
          <source>There are several settings that you can customize to make &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; draw according to your preferences:</source>
          <target state="translated">환경 설정에 따라 &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; 그리기를 사용자 정의 할 수있는 몇 가지 설정이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="982a42d4eed36f25f4969cc01ba6749dc862a6df" translate="yes" xml:space="preserve">
          <source>There are several settings that you can customize to make QPainter draw according to your preferences:</source>
          <target state="translated">기본 설정에 따라 QPainter를 그리기 위해 사용자 지정할 수있는 몇 가지 설정이 있습니다.</target>
        </trans-unit>
        <trans-unit id="563349f6d4f843e2696cf1af7ab944d085a66966" translate="yes" xml:space="preserve">
          <source>There are several tools to help turn a set of images into sprite sheets. Here are some examples:</source>
          <target state="translated">이미지 세트를 스프라이트 시트로 변환하는 데 도움이되는 몇 가지 도구가 있습니다. 여기 몇 가지 예가 있어요.</target>
        </trans-unit>
        <trans-unit id="3959afb5dfa374781d4fbcccc15ee3908025dbac" translate="yes" xml:space="preserve">
          <source>There are several types of predefined documentation</source>
          <target state="translated">사전 정의 된 문서에는 여러 가지 유형이 있습니다</target>
        </trans-unit>
        <trans-unit id="77e237d6f538d8ed00f9a5e4caa3e4cfbf2a047b" translate="yes" xml:space="preserve">
          <source>There are several ways of setting animation to an object.</source>
          <target state="translated">애니메이션을 객체로 설정하는 방법에는 여러 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="50927ecdbcf92bd462e3957256ec455e017ee82f" translate="yes" xml:space="preserve">
          <source>There are several ways of using a custom style in a Qt application. The simplest way is to pass the custom style to the &lt;a href=&quot;qapplication#setStyle&quot;&gt;QApplication::setStyle&lt;/a&gt;() static function before creating the &lt;a href=&quot;qapplication&quot;&gt;QApplication&lt;/a&gt; object:</source>
          <target state="translated">Qt 애플리케이션에서 커스텀 스타일을 사용하는 몇 가지 방법이 있습니다. 가장 간단한 방법은 &lt;a href=&quot;qapplication&quot;&gt;QApplication&lt;/a&gt; 오브젝트 를 작성하기 전에 사용자 정의 스타일을 &lt;a href=&quot;qapplication#setStyle&quot;&gt;QApplication :: setStyle&lt;/a&gt; () 정적 함수에 전달하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="ab9be36891dc850fd42825aac0007a3cf9020e70" translate="yes" xml:space="preserve">
          <source>There are several ways to ensure that &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtquickcontrols-chattutorial-example.html#stackview&quot;&gt;StackView&lt;/a&gt; has a size in this situation:</source>
          <target state="translated">이 상황에서 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtquickcontrols-chattutorial-example.html#stackview&quot;&gt;StackView&lt;/a&gt; 의 크기 를 확인하는 몇 가지 방법 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c23ac9d347cda85e681a5e4e8e9c0f2e5e3632ea" translate="yes" xml:space="preserve">
          <source>There are several ways to ensure that StackView has a size in this situation:</source>
          <target state="translated">이 상황에서 StackView의 크기를 확인하는 방법에는 여러 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="bae549cab005e9e829a65ff2055263d2f3255c3c" translate="yes" xml:space="preserve">
          <source>There are several ways to go about creating your own styles. Below, we'll explain the various approaches.</source>
          <target state="translated">자신 만의 스타일을 만드는 방법에는 여러 가지가 있습니다. 아래에서는 다양한 접근 방식에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="b882f4f7a60444f873c386246e21efc66d3dedbc" translate="yes" xml:space="preserve">
          <source>There are similar features like &lt;a href=&quot;qml-qtmultimedia-video#play-method&quot;&gt;play()&lt;/a&gt; with new features specific to video.</source>
          <target state="translated">비디오와 관련된 새로운 기능을 가진 &lt;a href=&quot;qml-qtmultimedia-video#play-method&quot;&gt;play ()&lt;/a&gt; 와 유사한 기능이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2b684a7ae2767f055469dd776da8b82024474fbd" translate="yes" xml:space="preserve">
          <source>There are six kinds of</source>
          <target state="translated">여섯 종류가 있습니다</target>
        </trans-unit>
        <trans-unit id="511f2c0c9f8e02ae75ce60aeede14b4b911a7529" translate="yes" xml:space="preserve">
          <source>There are some cases where manually invoking the garbage collector is acceptable (and this is explained in greater detail in an upcoming section), but in most cases, invoking the garbage collector is unnecessary and counter-productive.</source>
          <target state="translated">가비지 콜렉터를 수동으로 호출하는 것이 허용되는 경우가 있지만 (이 내용은 다음 섹션에서 자세히 설명) 가비지 콜렉터를 호출하는 것이 불필요하고 비생산적입니다.</target>
        </trans-unit>
        <trans-unit id="ae7fd045768038a7f02f3106ba36087a4ce2988e" translate="yes" xml:space="preserve">
          <source>There are some color roles used mostly for 3D bevel and shadow effects. All of these are normally derived from &lt;code&gt;Window&lt;/code&gt;, and used in ways that depend on that relationship. For example, buttons depend on it to make the bevels look attractive, and Motif scroll bars depend on &lt;code&gt;Mid&lt;/code&gt; to be slightly different from &lt;code&gt;Window&lt;/code&gt;.</source>
          <target state="translated">3D 경사 및 그림자 효과에 주로 사용되는 몇 가지 색상 역할이 있습니다. 이들 모두는 일반적으로 &lt;code&gt;Window&lt;/code&gt; 에서 파생되며 해당 관계에 따라 다른 방식으로 사용됩니다. 예를 들어, 버튼은 경사를보기 좋게하기 위해 버튼에 의존하고, Motif 스크롤 막대는 &lt;code&gt;Mid&lt;/code&gt; 에 의존하여 &lt;code&gt;Window&lt;/code&gt; 와 약간 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="8850648cacb0adf41fd116fbab811d43d49465a0" translate="yes" xml:space="preserve">
          <source>There are some features that &lt;a href=&quot;qgraphicsanchorlayout&quot;&gt;QGraphicsAnchorLayout&lt;/a&gt; currently does not support. This might change in the future, so avoid using these features if you want to avoid any future regressions in behaviour:</source>
          <target state="translated">&lt;a href=&quot;qgraphicsanchorlayout&quot;&gt;QGraphicsAnchorLayout이&lt;/a&gt; 현재 지원하지 않는 일부 기능이 있습니다 . 향후 변경 될 수 있으므로 향후 퇴행을 피하려면 다음 기능을 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="20abb5d1d491d77d259f0c6af28b2f0f053f418f" translate="yes" xml:space="preserve">
          <source>There are some features that QGraphicsAnchorLayout currently does not support. This might change in the future, so avoid using these features if you want to avoid any future regressions in behaviour:</source>
          <target state="translated">QGraphicsAnchorLayout이 현재 지원하지 않는 몇 가지 기능이 있습니다. 이는 향후 변경 될 수 있으므로 향후 동작의 회귀를 피하려면 다음 기능을 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="913c8c9383d86fb4b382b794ac3d277184ba1ac4" translate="yes" xml:space="preserve">
          <source>There are some predefined instantiations of this template for working with common stereo sample depths in a convenient way.</source>
          <target state="translated">편리한 스테레오 샘플 깊이로 작업하기 위해이 템플릿의 사전 정의 된 인스턴스가 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7f670a2e53b26c58d848546b3a83338387cb274" translate="yes" xml:space="preserve">
          <source>There are some special considerations to be made when OpenGL is used. The platform plugin only supports full screen top-level OpenGL windows. This means that even dialogs and popups will be shown as full screen. There may also be drawing errors if you try to stack windows that have animations or otherwise require updating their UI while they are obscured by another window.</source>
          <target state="translated">OpenGL을 사용할 때 고려해야 할 사항이 몇 가지 있습니다. 플랫폼 플러그인은 전체 화면 최상위 OpenGL 창만 지원합니다. 즉, 대화 상자와 팝업조차도 전체 화면으로 표시됩니다. 애니메이션이있는 창을 쌓으려고하거나 다른 창에 의해 가려진 상태에서 UI를 업데이트해야하는 경우 그리기 오류가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2bb07ada37e615a4db7b5e60d9137ae8230ed171" translate="yes" xml:space="preserve">
          <source>There are some subtle differences between &lt;a href=&quot;qtcore-changes-qt6#qregularexpression&quot;&gt;QRegularExpression&lt;/a&gt; and &lt;code&gt;QRegExp&lt;/code&gt; that will be explained by this document to ease the porting effort.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e69d7a3df417d7f226f7295aef4570de6bc39956" translate="yes" xml:space="preserve">
          <source>There are three approaches for storing custom data in a &lt;a href=&quot;qmimedata&quot;&gt;QMimeData&lt;/a&gt; object:</source>
          <target state="translated">&lt;a href=&quot;qmimedata&quot;&gt;QMimeData&lt;/a&gt; 객체 에 커스텀 데이터를 저장하는 방법에는 세 가지가 있습니다 :</target>
        </trans-unit>
        <trans-unit id="2b358b82f98b5d39524d0c5242fc189eab7e0088" translate="yes" xml:space="preserve">
          <source>There are three approaches for storing custom data in a QMimeData object:</source>
          <target state="translated">QMimeData 개체에 사용자 지정 데이터를 저장하는 방법에는 세 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e56d3c59c71af0c92c5d6d602b207bcb06ed9b3e" translate="yes" xml:space="preserve">
          <source>There are three different types of imports. Each import type has a slightly different syntax, and different semantics apply to different import types.</source>
          <target state="translated">수입품에는 세 가지 유형이 있습니다. 각 가져 오기 유형은 구문이 약간 다르며 다른 의미는 다른 가져 오기 유형에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="1e821a7f395e59b9288e42ed564cfedfc307efdb" translate="yes" xml:space="preserve">
          <source>There are three effective coordinate systems in play in Graphics View: Item coordinates, scene coordinates, and view coordinates. To simplify your implementation, Graphics View provides convenience functions that allow you to map between the three coordinate systems.</source>
          <target state="translated">기하 창에는 3 가지 유효 좌표계가 있습니다 : 항목 좌표, 장면 좌표 및 뷰 좌표. 구현을 단순화하기 위해 기하 창은 세 좌표 시스템 사이를 매핑 할 수있는 편리한 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="2606087c48d57a57c3af015394f1aba943f065cf" translate="yes" xml:space="preserve">
          <source>There are three element types: primitive elements, control elements, and complex control elements. The elements are defined by the &lt;a href=&quot;qstyle#ComplexControl-enum&quot;&gt;ComplexControl&lt;/a&gt;, &lt;a href=&quot;qstyle#ControlElement-enum&quot;&gt;ControlElement&lt;/a&gt;, and &lt;a href=&quot;qstyle#PrimitiveElement-enum&quot;&gt;PrimitiveElement&lt;/a&gt; enums. The values of each element enum has a prefix to identify their type: &lt;code&gt;CC_&lt;/code&gt; for complex elements, &lt;code&gt;CE_&lt;/code&gt; for control elements, and &lt;code&gt;PE_&lt;/code&gt; for primitive elements. We will in the following three sections see what defines the different elements and see examples of widgets that use them.</source>
          <target state="translated">기본 요소, 제어 요소 및 복잡한 제어 요소의 세 가지 요소 유형이 있습니다. 요소는 &lt;a href=&quot;qstyle#ComplexControl-enum&quot;&gt;ComplexControl&lt;/a&gt; , &lt;a href=&quot;qstyle#ControlElement-enum&quot;&gt;ControlElement&lt;/a&gt; 및 &lt;a href=&quot;qstyle#PrimitiveElement-enum&quot;&gt;PrimitiveElement&lt;/a&gt; 열거 형 으로 정의됩니다 . 각 요소 열거의 값은 타입 식별하는 프리픽스 갖는다 &lt;code&gt;CC_&lt;/code&gt; 복합 요소, &lt;code&gt;CE_&lt;/code&gt; 제어 요소 및 &lt;code&gt;PE_&lt;/code&gt; 을 기본 요소를. 다음 세 섹션에서는 다양한 요소를 정의하는 요소와이를 사용하는 위젯의 예를 봅니다.</target>
        </trans-unit>
        <trans-unit id="79c545df550c0b60ba113ad1bcbd34e9c6c8cf2e" translate="yes" xml:space="preserve">
          <source>There are three essential materials for generating documentation with QDoc:</source>
          <target state="translated">QDoc으로 문서를 생성하기위한 세 가지 필수 자료가 있습니다.</target>
        </trans-unit>
        <trans-unit id="3810715d0ae6640e0ac248a9e49f68be39a738b9" translate="yes" xml:space="preserve">
          <source>There are three essential materials for generating documentation with qdoc:</source>
          <target state="translated">qdoc로 문서를 생성하는 데 필요한 3 가지 필수 자료가 있습니다.</target>
        </trans-unit>
        <trans-unit id="94de4612bdb1e452f7e5777fc406280df5d92d35" translate="yes" xml:space="preserve">
          <source>There are three general ways to use &lt;a href=&quot;qtextstream&quot;&gt;QTextStream&lt;/a&gt; when reading text files:</source>
          <target state="translated">텍스트 파일을 읽을 때 &lt;a href=&quot;qtextstream&quot;&gt;QTextStream&lt;/a&gt; 을 사용하는 일반적인 세 ​​가지 방법이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c30cb8c0a05e1a36da8ba8d7fd5ac398fee401ba" translate="yes" xml:space="preserve">
          <source>There are three general ways to use QTextStream when reading text files:</source>
          <target state="translated">텍스트 파일을 읽을 때 QTextStream을 사용하는 세 가지 일반적인 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7702b56b060f97ab095dc0516eb296ab9b02796" translate="yes" xml:space="preserve">
          <source>There are three major modes of operation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5775c521db22b64ef7f8d572ef5625a078a4b82b" translate="yes" xml:space="preserve">
          <source>There are three primary navigation operations in &lt;a href=&quot;qml-qtquick-controls-stackview&quot;&gt;StackView&lt;/a&gt;: &lt;a href=&quot;qml-qtquick-controls-stackview#push-method&quot;&gt;push()&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-controls-stackview#pop-method&quot;&gt;pop()&lt;/a&gt;, and replace (replace by specifying argument &lt;code&gt;replace&lt;/code&gt; to &lt;a href=&quot;qml-qtquick-controls-stackview#push-method&quot;&gt;push()&lt;/a&gt;). These correspond to classic stack operations where &quot;push&quot; adds an item to the top of a stack, &quot;pop&quot; removes the top item from the stack, and &quot;replace&quot; is like a pop followed by a push, in that it replaces the topmost item on the stack with a new item (but the applied transtition might be different). The topmost item in the stack corresponds to the one that is &lt;a href=&quot;qml-qtquick-controls-stackview#currentItem-prop&quot;&gt;currently&lt;/a&gt; visible on the screen. That means that &quot;push&quot; is the logical equivalent of navigating forward or deeper into the application, &quot;pop&quot; is the equivalent of navigating back, and &quot;replace&quot; is the equivalent of replacing the current item.</source>
          <target state="translated">세 가지 기본 탐색에서 작업이 있습니다 &lt;a href=&quot;qml-qtquick-controls-stackview&quot;&gt;StackView&lt;/a&gt; : &lt;a href=&quot;qml-qtquick-controls-stackview#push-method&quot;&gt;푸시 ()&lt;/a&gt; , &lt;a href=&quot;qml-qtquick-controls-stackview#pop-method&quot;&gt;() 팝업&lt;/a&gt; 및 교체 (인수가 지정하여 교체 &lt;code&gt;replace&lt;/code&gt; 로 &lt;a href=&quot;qml-qtquick-controls-stackview#push-method&quot;&gt;푸시 ()&lt;/a&gt; ). 이는 &quot;푸시&quot;가 스택 맨 위에 항목을 추가하고 &quot;팝&quot;이 스택에서 맨 위 항목을 제거하며 &quot;바꾸기&quot;는 맨 위를 대체한다는 점에서 팝 다음에 푸시와 같은 클래식 스택 작업에 ​​해당합니다. 새 항목이있는 스택의 항목입니다 (적용된 전환이 다를 수 있음). 스택의 최상위 항목은 &lt;a href=&quot;qml-qtquick-controls-stackview#currentItem-prop&quot;&gt;현재&lt;/a&gt; 있는 항목에 해당합니다.화면에 표시됩니다. 즉, &quot;푸시&quot;는 응용 프로그램을 앞으로 또는 더 깊이 탐색하는 것과 동등한 논리이고 &quot;팝&quot;은 다시 탐색하는 것과 동일하며 &quot;바꾸기&quot;는 현재 항목을 바꾸는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8a4b42a122def2f7e9c9bc79d00fc130aa8f10c8" translate="yes" xml:space="preserve">
          <source>There are three primary navigation operations in StackView: &lt;a href=&quot;qml-qtquick-controls-stackview#push-method&quot;&gt;push()&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-controls-stackview#pop-method&quot;&gt;pop()&lt;/a&gt;, and replace (replace by specifying argument &lt;code&gt;replace&lt;/code&gt; to &lt;a href=&quot;qml-qtquick-controls-stackview#push-method&quot;&gt;push()&lt;/a&gt;). These correspond to classic stack operations where &quot;push&quot; adds an item to the top of a stack, &quot;pop&quot; removes the top item from the stack, and &quot;replace&quot; is like a pop followed by a push, in that it replaces the topmost item on the stack with a new item (but the applied transtition might be different). The topmost item in the stack corresponds to the one that is &lt;a href=&quot;qml-qtquick-controls-stackview#currentItem-prop&quot;&gt;currently&lt;/a&gt; visible on the screen. That means that &quot;push&quot; is the logical equivalent of navigating forward or deeper into the application, &quot;pop&quot; is the equivalent of navigating back, and &quot;replace&quot; is the equivalent of replacing the current item.</source>
          <target state="translated">StackView에는 &lt;a href=&quot;qml-qtquick-controls-stackview#push-method&quot;&gt;push ()&lt;/a&gt; , &lt;a href=&quot;qml-qtquick-controls-stackview#pop-method&quot;&gt;pop ()&lt;/a&gt; 및 replace ( &lt;a href=&quot;qml-qtquick-controls-stackview#push-method&quot;&gt;push ()에&lt;/a&gt; 인수 &lt;code&gt;replace&lt;/code&gt; 를 지정하여 대체 )의 세 가지 기본 탐색 작업이 있습니다. 이는 &quot;push&quot;가 스택의 맨 위에 항목을 추가하고 &quot;pop&quot;이 스택에서 맨 위 항목을 제거하며 &quot;replace&quot;가 맨 위를 대체한다는 점에서 팝 다음에 푸시와 같은 전형적인 스택 작업에 ​​해당합니다. 새 항목이있는 스택의 항목입니다 (하지만 적용된 전환은 다를 수 있음). 스택의 최상위 항목은 &lt;a href=&quot;qml-qtquick-controls-stackview#currentItem-prop&quot;&gt;현재&lt;/a&gt;화면에 표시됩니다. 즉, &quot;push&quot;는 응용 프로그램에서 앞으로 또는 더 깊이 탐색하는 것과 논리적으로 동일하며 &quot;pop&quot;은 뒤로 이동하는 것과 동일하며 &quot;replace&quot;는 현재 항목을 바꾸는 것과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="b04e8dfffdf88223423c8812f71f3aa039a44cee" translate="yes" xml:space="preserve">
          <source>There are three render loop variants available: &lt;code&gt;basic&lt;/code&gt;, &lt;code&gt;windows&lt;/code&gt;, and &lt;code&gt;threaded&lt;/code&gt;. Out of these, &lt;code&gt;basic&lt;/code&gt; and &lt;code&gt;windows&lt;/code&gt; are single-threaded, while &lt;code&gt;threaded&lt;/code&gt; performs scene graph rendering on a dedicated thread. Qt attempts to choose a suitable loop based on the platform and possibly the graphics drivers in use. When this is not satisfactory, or for testing purposes, the environment variable &lt;code&gt;QSG_RENDER_LOOP&lt;/code&gt; can be used to force the usage of a given loop. To verify which render loop is in use, enable the &lt;code&gt;qt.scenegraph.general&lt;/code&gt;&lt;a href=&quot;qloggingcategory&quot;&gt;logging category&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;basic&lt;/code&gt; , &lt;code&gt;windows&lt;/code&gt; 및 &lt;code&gt;threaded&lt;/code&gt; 의 세 가지 렌더 루프 변형이 있습니다 . 이 중 &lt;code&gt;basic&lt;/code&gt; 및 &lt;code&gt;windows&lt;/code&gt; 은 단일 스레드이며 &lt;code&gt;threaded&lt;/code&gt; 는 전용 스레드에서 장면 그래프 렌더링을 수행합니다. Qt는 플랫폼 및 사용중인 그래픽 드라이버를 기반으로 적절한 루프를 선택하려고합니다. 이것이 만족스럽지 않거나 테스트 목적으로 환경 변수 &lt;code&gt;QSG_RENDER_LOOP&lt;/code&gt; 를 사용하여 지정된 루프를 강제로 사용할 수 있습니다. 사용중인 렌더 루프를 확인하려면 &lt;code&gt;qt.scenegraph.general&lt;/code&gt; &lt;a href=&quot;qloggingcategory&quot;&gt;logging category를&lt;/a&gt; 활성화하십시오 .</target>
        </trans-unit>
        <trans-unit id="d20bfab49abb4dff3a013a11260d52fc09470289" translate="yes" xml:space="preserve">
          <source>There are three signals emitted if the current item of a combobox changes, &lt;a href=&quot;qcombobox#currentIndexChanged&quot;&gt;currentIndexChanged&lt;/a&gt;(), &lt;a href=&quot;qcombobox#currentTextChanged&quot;&gt;currentTextChanged&lt;/a&gt;() and &lt;a href=&quot;qcombobox#activated&quot;&gt;activated&lt;/a&gt;(). &lt;a href=&quot;qcombobox#currentIndexChanged&quot;&gt;currentIndexChanged&lt;/a&gt;() and &lt;a href=&quot;qcombobox#currentTextChanged&quot;&gt;currentTextChanged&lt;/a&gt;() are always emitted regardless if the change was done programmatically or by user interaction, while &lt;a href=&quot;qcombobox#activated&quot;&gt;activated&lt;/a&gt;() is only emitted when the change is caused by user interaction. The &lt;a href=&quot;qcombobox#highlighted&quot;&gt;highlighted&lt;/a&gt;() signal is emitted when the user highlights an item in the combobox popup list. All three signals exist in two versions, one with a &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; argument and one with an &lt;code&gt;int&lt;/code&gt; argument. If the user selects or highlights a pixmap, only the &lt;code&gt;int&lt;/code&gt; signals are emitted. Whenever the text of an editable combobox is changed the &lt;a href=&quot;qcombobox#editTextChanged&quot;&gt;editTextChanged&lt;/a&gt;() signal is emitted.</source>
          <target state="translated">콤보 박스의 현재 항목이 변경되면 세 가지 신호가 방출됩니다. &lt;a href=&quot;qcombobox#currentIndexChanged&quot;&gt;currentIndexChanged&lt;/a&gt; (), &lt;a href=&quot;qcombobox#currentTextChanged&quot;&gt;currentTextChanged&lt;/a&gt; () 및 &lt;a href=&quot;qcombobox#activated&quot;&gt;Activated&lt;/a&gt; ()입니다. &lt;a href=&quot;qcombobox#currentIndexChanged&quot;&gt;currentIndexChanged&lt;/a&gt; () 및 &lt;a href=&quot;qcombobox#currentTextChanged&quot;&gt;currentTextChanged&lt;/a&gt; ()는 변경이 프로그래밍 방식 또는 사용자 상호 작용에 의해 수행되었는지 여부에 관계없이 항상 내보내 지지만 &lt;a href=&quot;qcombobox#activated&quot;&gt;활성화&lt;/a&gt; ()는 사용자 상호 작용으로 인해 변경이 발생한 경우에만 내 보냅니다. &lt;a href=&quot;qcombobox#highlighted&quot;&gt;강조&lt;/a&gt; 사용자가 콤보 팝업리스트에서 항목을 강조 할 때 () 신호가 방출된다. 세 가지 신호는 모두 &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; 인수가 있는 버전 과 &lt;code&gt;int&lt;/code&gt; 인수가 있는 버전의 두 가지 버전으로 존재합니다 . 사용자가 픽스맵을 선택하거나 강조 표시하면 &lt;code&gt;int&lt;/code&gt; 신호가 방출됩니다. 편집 가능한 콤보 상자의 텍스트가 변경 될 때마다 &lt;a href=&quot;qcombobox#editTextChanged&quot;&gt;editTextChanged&lt;/a&gt; () 신호가 방출됩니다.</target>
        </trans-unit>
        <trans-unit id="1d33dc5a3e51e1ef48c544cba977eb7bc683f3b2" translate="yes" xml:space="preserve">
          <source>There are three types of socket notifiers: read, write, and exception. The type is described by the &lt;a href=&quot;qsocketnotifier#Type-enum&quot;&gt;Type&lt;/a&gt; enum, and must be specified when constructing the socket notifier. After construction it can be determined using the &lt;a href=&quot;qsocketnotifier#type&quot;&gt;type&lt;/a&gt;() function. Note that if you need to monitor both reads and writes for the same file descriptor, you must create two socket notifiers. Note also that it is not possible to install two socket notifiers of the same type (&lt;a href=&quot;qsocketnotifier#Type-enum&quot;&gt;Read&lt;/a&gt;, &lt;a href=&quot;qsocketnotifier#Type-enum&quot;&gt;Write&lt;/a&gt;, &lt;a href=&quot;qsocketnotifier#Type-enum&quot;&gt;Exception&lt;/a&gt;) on the same socket.</source>
          <target state="translated">소켓 알리미에는 읽기, 쓰기 및 예외의 세 가지 유형이 있습니다. 유형은 &lt;a href=&quot;qsocketnotifier#Type-enum&quot;&gt;Type&lt;/a&gt; 열거 형으로 설명되며 소켓 알리미를 구성 할 때 지정해야합니다. 구성 후 &lt;a href=&quot;qsocketnotifier#type&quot;&gt;type&lt;/a&gt; () 함수를 사용하여 결정할 수 있습니다 . 동일한 파일 디스크립터에 대한 읽기 및 쓰기를 모두 모니터해야하는 경우 두 개의 소켓 알리미를 작성해야합니다. 또한 동일한 소켓에 동일한 유형의 두 개의 소켓 알리미 ( &lt;a href=&quot;qsocketnotifier#Type-enum&quot;&gt;Read&lt;/a&gt; , &lt;a href=&quot;qsocketnotifier#Type-enum&quot;&gt;Write&lt;/a&gt; , &lt;a href=&quot;qsocketnotifier#Type-enum&quot;&gt;Exception&lt;/a&gt; ) 를 설치할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="e07302942ef3a5e51120468ffbdd8d48d6775ac9" translate="yes" xml:space="preserve">
          <source>There are three virtuals that can be overridden. These provide the data, or the logic to generate the data, for uniform buffers, textures, and pipeline state changes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2373a12a3d073e1dbbdb5fadc7bd8fa90cb0dbd" translate="yes" xml:space="preserve">
          <source>There are three ways to create a &lt;a href=&quot;qfontinfo&quot;&gt;QFontInfo&lt;/a&gt; object.</source>
          <target state="translated">&lt;a href=&quot;qfontinfo&quot;&gt;QFontInfo&lt;/a&gt; 오브젝트 를 작성하는 세 가지 방법이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3963e10482be2f9e0e1683641100d2e2e4cb41e2" translate="yes" xml:space="preserve">
          <source>There are three ways to create a QFontInfo object.</source>
          <target state="translated">QFontInfo 개체를 만드는 방법에는 세 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="392a96b32e99f342670e5275fb93143f15037cae" translate="yes" xml:space="preserve">
          <source>There are two Qt APIs that can be used to render content into a window, &lt;a href=&quot;qbackingstore&quot;&gt;QBackingStore&lt;/a&gt; for rendering with a &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; and flushing the contents to a window with type &lt;a href=&quot;qsurface#SurfaceType-enum&quot;&gt;QSurface::RasterSurface&lt;/a&gt;, and &lt;a href=&quot;gui-changes-qt6#qopenglcontext&quot;&gt;QOpenGLContext&lt;/a&gt; for rendering with OpenGL to a window with type &lt;a href=&quot;qsurface#SurfaceType-enum&quot;&gt;QSurface::OpenGLSurface&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38de1e7531e8ed5ba28b1e2ea9bf90cf39a0a3cb" translate="yes" xml:space="preserve">
          <source>There are two Qt APIs that can be used to render content into a window, &lt;a href=&quot;qbackingstore&quot;&gt;QBackingStore&lt;/a&gt; for rendering with a &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; and flushing the contents to a window with type &lt;a href=&quot;qsurface#SurfaceType-enum&quot;&gt;QSurface::RasterSurface&lt;/a&gt;, and &lt;a href=&quot;qopenglcontext&quot;&gt;QOpenGLContext&lt;/a&gt; for rendering with OpenGL to a window with type &lt;a href=&quot;qsurface#SurfaceType-enum&quot;&gt;QSurface::OpenGLSurface&lt;/a&gt;.</source>
          <target state="translated">창에 내용을 렌더링하는 데 사용할 수있는 두 Qt는 API는있다, &lt;a href=&quot;qbackingstore&quot;&gt;QBackingStore&lt;/a&gt; 렌더링에 대한 &lt;a href=&quot;qpainter&quot;&gt;QPainter를&lt;/a&gt; 형과 창에 내용을 및 플러싱 &lt;a href=&quot;qsurface#SurfaceType-enum&quot;&gt;QSurface :: RasterSurface&lt;/a&gt; 및 &lt;a href=&quot;qopenglcontext&quot;&gt;QOpenGLContext을&lt;/a&gt; 형과 창으로 OpenGL은 렌더링을 위해 &lt;a href=&quot;qsurface#SurfaceType-enum&quot;&gt;QSurface :: OpenGLSurface&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8036bb215e3f77e0bc89f0430de6798e4aee23f4" translate="yes" xml:space="preserve">
          <source>There are two approaches to handle this: either write conditional property values based on &lt;a href=&quot;qml-qtquick-graphicsinfo&quot;&gt;GraphicsInfo&lt;/a&gt;.shaderType, or use file selectors. In practice the latter is strongly recommended as it leads to more concise and cleaner application code. The only case it is not suitable is when the source strings are constructed dynamically.</source>
          <target state="translated">이를 처리하는 두 가지 방법이 있습니다. &lt;a href=&quot;qml-qtquick-graphicsinfo&quot;&gt;GraphicsInfo&lt;/a&gt; .shaderType을 기반으로 조건부 속성 값을 쓰거나 파일 선택기를 사용하십시오. 실제로 후자는 응용 프로그램 코드가 더 간결하고 깨끗해 지므로 강력히 권장됩니다. 적합하지 않은 유일한 경우는 소스 문자열이 동적으로 생성 된 경우입니다.</target>
        </trans-unit>
        <trans-unit id="8f5a5cbfa07e08d7c11147f311a3cc7762e0e153" translate="yes" xml:space="preserve">
          <source>There are two color roles related to hyperlinks:</source>
          <target state="translated">하이퍼 링크와 관련된 두 가지 색상 역할이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f520d88cda3bdd47355cbd9b4b21687cba63d7be" translate="yes" xml:space="preserve">
          <source>There are two different kinds of JavaScript resources which are supported in QML: code-behind implementation files, and shared (library) files. Both kinds of JavaScript resource may be &lt;a href=&quot;qtqml-javascript-imports&quot;&gt;imported&lt;/a&gt; by other JavaScript resources, or included in &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtqml-modules-topic.html&quot;&gt;QML modules&lt;/a&gt;.</source>
          <target state="translated">QML에서 지원되는 JavaScript 리소스에는 코드 숨김 구현 파일과 공유 (라이브러리) 파일의 두 가지 종류가 있습니다. 두 종류의 자바 스크립트 리소스는 다른 자바 스크립트 리소스에서 &lt;a href=&quot;qtqml-javascript-imports&quot;&gt;가져 오거나 &lt;/a&gt;&lt;a href=&quot;https://doc.qt.io/qt-5.15/qtqml-modules-topic.html&quot;&gt;QML 모듈에&lt;/a&gt; 포함될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8f8d0f465902f1db642493916c3870125dbe332f" translate="yes" xml:space="preserve">
          <source>There are two different kinds of JavaScript resources which are supported in QML: code-behind implementation files, and shared (library) files. Both kinds of JavaScript resource may be &lt;a href=&quot;qtqml-javascript-imports&quot;&gt;imported&lt;/a&gt; by other JavaScript resources, or included in &lt;a href=&quot;https://doc.qt.io/qt-6.0/qtqml-modules-topic.html&quot;&gt;QML modules&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="247d7c5e199e7008ae4b9279b6b798254fb2f88e" translate="yes" xml:space="preserve">
          <source>There are two different kinds of JavaScript resources which are supported in QML: code-behind implementation files, and shared (library) files. Both kinds of JavaScript resource may be &lt;a href=&quot;qtqml-javascript-imports#&quot;&gt;imported&lt;/a&gt; by other JavaScript resources, or included in &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtqml-modules-topic.html#&quot;&gt;QML modules&lt;/a&gt;.</source>
          <target state="translated">QML에서 지원되는 두 가지 종류의 JavaScript 리소스가 있습니다 : 코드 숨김 구현 파일과 공유 (라이브러리) 파일. 두 가지 JavaScript 자원 모두 다른 JavaScript 자원 으로 &lt;a href=&quot;qtqml-javascript-imports#&quot;&gt;가져 오거나 &lt;/a&gt;&lt;a href=&quot;https://doc.qt.io/qt-5.13/qtqml-modules-topic.html#&quot;&gt;QML 모듈에&lt;/a&gt; 포함될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e0ce3b94cfa083d0d566ec61e76dd20691426e5a" translate="yes" xml:space="preserve">
          <source>There are two exceptions in which detach() must be called explicitly, that is when calling the handle() or the x11PictureHandle() function (only available on X11). Otherwise, any modifications done using system calls, will be performed on the shared data.</source>
          <target state="translated">detach ()를 명시 적으로 호출해야하는 두 가지 예외가 있는데, 즉 handle () 또는 x11PictureHandle () 함수를 호출 할 때 (X11에서만 사용 가능). 그렇지 않으면 시스템 호출을 사용하여 수행 한 모든 수정이 공유 데이터에서 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="296dc3a7fe28f01c1127677faae5b5859008ff4f" translate="yes" xml:space="preserve">
          <source>There are two forms of this template function:</source>
          <target state="translated">이 템플릿 함수에는 두 가지 형태가 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a621b75167d85809433d3394482865a4bd899ad" translate="yes" xml:space="preserve">
          <source>There are two functions that give information about the actions that must return localized strings: &lt;a href=&quot;qaccessibleactioninterface#localizedActionName&quot;&gt;localizedActionName()&lt;/a&gt; and &lt;a href=&quot;qaccessibleactioninterface#localizedActionDescription&quot;&gt;localizedActionDescription()&lt;/a&gt;. These functions can be used by the client to present the actions to the user. In general, the name should be concise and only consist of a single word, such as &quot;press&quot;.</source>
          <target state="translated">현지화 된 문자열을 리턴해야하는 조치에 대한 정보를 제공하는 &lt;a href=&quot;qaccessibleactioninterface#localizedActionName&quot;&gt;localizedActionName ()&lt;/a&gt; 및 &lt;a href=&quot;qaccessibleactioninterface#localizedActionDescription&quot;&gt;localizedActionDescription ()&lt;/a&gt; 두 가지 함수가 있습니다. 이러한 기능은 클라이언트가 사용자에게 조치를 제시하기 위해 사용할 수 있습니다. 일반적으로 이름은 간결해야하며 &quot;press&quot;와 같은 단일 단어로만 구성되어야합니다.</target>
        </trans-unit>
        <trans-unit id="d4e1261489262d4e030b9c6127aa82184058cfe2" translate="yes" xml:space="preserve">
          <source>There are two item flags that affect how the item's opacity is combined with the parent: &lt;a href=&quot;qgraphicsitem#GraphicsItemFlag-enum&quot;&gt;ItemIgnoresParentOpacity&lt;/a&gt; and &lt;a href=&quot;qgraphicsitem#GraphicsItemFlag-enum&quot;&gt;ItemDoesntPropagateOpacityToChildren&lt;/a&gt;.</source>
          <target state="translated">항목의 불투명도가 부모와 결합되는 방식에 영향을주는 항목 플래그는 &lt;a href=&quot;qgraphicsitem#GraphicsItemFlag-enum&quot;&gt;ItemIgnoresParentOpacity&lt;/a&gt; 및 &lt;a href=&quot;qgraphicsitem#GraphicsItemFlag-enum&quot;&gt;ItemDoesntPropagateOpacityToChildren&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5693b903c9958b7342b24992db33125366e3036d" translate="yes" xml:space="preserve">
          <source>There are two kinds of show events: show events caused by the window system (spontaneous), and internal show events. Spontaneous (&lt;a href=&quot;qevent#spontaneous&quot;&gt;QEvent::spontaneous&lt;/a&gt;()) show events are sent just after the window system shows the window; they are also sent when a top-level window is redisplayed after being iconified. Internal show events are delivered just before the widget becomes visible.</source>
          <target state="translated">쇼 시스템에는 두 가지 종류가 있습니다 : 윈도우 시스템으로 인한 쇼 이벤트 (자발적)와 내부 쇼 이벤트. 자발적 ( &lt;a href=&quot;qevent#spontaneous&quot;&gt;QEvent :: spontaneous&lt;/a&gt; ()) 쇼 이벤트는 윈도우 시스템이 윈도우를 표시 한 직후에 전송됩니다. 아이콘 화 후 최상위 창을 다시 표시 할 때도 전송됩니다. 내부 쇼 이벤트는 위젯이 표시되기 직전에 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="21ee47c9776f494e4385dfb8c5f85ca2604ab8e6" translate="yes" xml:space="preserve">
          <source>There are two main types of custom materials. This is specified by the &lt;a href=&quot;qml-qtquick3d-custommaterial#shadingMode-prop&quot;&gt;shadingMode&lt;/a&gt; property. In &lt;a href=&quot;qml-qtquick3d-custommaterial#shadingMode-prop&quot;&gt;unshaded&lt;/a&gt; custom materials the fragment shader outputs a single &lt;code&gt;vec4&lt;/code&gt; color, ignoring lights, light probes, shadowing in the scene. In &lt;a href=&quot;qml-qtquick3d-custommaterial#shadingMode-prop&quot;&gt;shaded&lt;/a&gt; materials the shader is expected to implement certain functions and work with built-in variables to take lighting and shadow contribution into account.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efafb36ff8c62ad2fc09a20df704a5b25bd6f1e4" translate="yes" xml:space="preserve">
          <source>There are two main use-cases for the function: firstly, to apply a property binding imperatively from JavaScript code:</source>
          <target state="translated">함수에는 두 가지 주요 사용 사례가 있습니다. 첫째, JavaScript 코드에서 속성 바인딩을 반드시 적용해야합니다.</target>
        </trans-unit>
        <trans-unit id="5aab1700d8f225e032916f4d730f8e7b38fbe748" translate="yes" xml:space="preserve">
          <source>There are two modes in which to write: using the more compact handwriting panel (as shown above), or &lt;a href=&quot;qml-qtquick-virtualkeyboard-handwritinginputpanel&quot;&gt;fullscreen&lt;/a&gt;.</source>
          <target state="translated">쓰기에는 두 가지 모드가 있습니다. 더 작은 필기 패널 (위 그림 참조) 또는 &lt;a href=&quot;qml-qtquick-virtualkeyboard-handwritinginputpanel&quot;&gt;전체 화면 사용&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fc3aacb2183b3d116eaa71d12100285107718b0c" translate="yes" xml:space="preserve">
          <source>There are two notable differences to be aware of: First, with Vulkan Y points down the screen in clip space, while OpenGL uses an upwards pointing Y axis. Second, the standard OpenGL projection matrix assume a near and far plane values of -1 and 1, while Vulkan prefers 0 and 1.</source>
          <target state="translated">알아야 할 두 가지 차이점이 있습니다. 첫째, Vulkan Y가 클립 공간에서 화면을 아래로 향하고 OpenGL은 위쪽을 가리키는 Y 축을 사용합니다. 둘째, 표준 OpenGL 프로젝션 매트릭스는 -1과 1의 근거리 및 원거리 값을 가정하고 Vulkan은 0과 1을 선호합니다.</target>
        </trans-unit>
        <trans-unit id="568b71f84a4fbb0f19630850b2147bb18b8dd257" translate="yes" xml:space="preserve">
          <source>There are two occasions where a fetch is done implicitly by another function call: during construction (so that the object starts out with some initial data where available), and during a call to &lt;a href=&quot;qxmlinputsource#next&quot;&gt;next&lt;/a&gt;() (if the data had run out).</source>
          <target state="translated">다른 함수 호출에 의해 페치가 내재적으로 수행되는 경우는 두 가지가 있습니다. 구성 중 (객체가 사용 가능한 경우 일부 초기 데이터로 시작) 및 &lt;a href=&quot;qxmlinputsource#next&quot;&gt;다음&lt;/a&gt; ()에 대한 호출 (데이터가 부족한 경우)입니다.</target>
        </trans-unit>
        <trans-unit id="5d76e8a8b7b53fd62139b40d28b311fe0fe43a6d" translate="yes" xml:space="preserve">
          <source>There are two platform plugins that are usable on &lt;a href=&quot;vxworks&quot;&gt;VxWorks&lt;/a&gt;: EGLFS and &lt;a href=&quot;vxworks#vxworksfb&quot;&gt;VxWorksFB&lt;/a&gt;. The availability of these plugins depends on the configuration of Qt. The default platform plugin is also device-specific. For instance, on many boards &lt;code&gt;eglfs&lt;/code&gt; will be chosen as the default one. If the default is not suitable, the &lt;code&gt;QT_QPA_PLATFORM&lt;/code&gt; environment variable parameter can be used to request another plugin. Alternatively, for quick tests, the &lt;code&gt;-platform&lt;/code&gt; command-line option can be used with the same syntax.</source>
          <target state="translated">&lt;a href=&quot;vxworks&quot;&gt;VxWorks에서&lt;/a&gt; 사용할 수있는 두 가지 플랫폼 플러그인은 EGLFS와 &lt;a href=&quot;vxworks#vxworksfb&quot;&gt;VxWorksFB&lt;/a&gt; 입니다. 이러한 플러그인의 가용성은 Qt의 구성에 따라 다릅니다. 기본 플랫폼 플러그인도 장치별로 다릅니다. 예를 들어, 많은 보드에서 &lt;code&gt;eglfs&lt;/code&gt; 가 기본값으로 선택됩니다. 기본값이 적합하지 않은 경우 &lt;code&gt;QT_QPA_PLATFORM&lt;/code&gt; 환경 변수 매개 변수를 사용하여 다른 플러그인을 요청할 수 있습니다. 또는 빠른 테스트 를 위해 동일한 구문으로 &lt;code&gt;-platform&lt;/code&gt; 명령 줄 옵션을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc5993a1cab49954886a27baf18d98bb0d2e0987" translate="yes" xml:space="preserve">
          <source>There are two platform plugins that are usable on VxWorks: EGLFS and &lt;a href=&quot;#vxworksfb&quot;&gt;VxWorksFB&lt;/a&gt;. The availability of these plugins depends on the configuration of Qt. The default platform plugin is also device-specific. For instance, on many boards &lt;code&gt;eglfs&lt;/code&gt; will be chosen as the default one. If the default is not suitable, the &lt;code&gt;QT_QPA_PLATFORM&lt;/code&gt; environment variable parameter can be used to request another plugin. Alternatively, for quick tests, the &lt;code&gt;-platform&lt;/code&gt; command-line option can be used with the same syntax.</source>
          <target state="translated">VxWorks에서 사용할 수있는 플랫폼 플러그인은 EGLFS 및 &lt;a href=&quot;#vxworksfb&quot;&gt;VxWorksFB의&lt;/a&gt; 두 가지 입니다. 이 플러그인의 가용성은 Qt의 구성에 따라 다릅니다. 기본 플랫폼 플러그인도 장치별로 다릅니다. 예를 들어 많은 보드에서 &lt;code&gt;eglfs&lt;/code&gt; 가 기본 보드 로 선택됩니다. 기본값이 적합하지 않은 경우 &lt;code&gt;QT_QPA_PLATFORM&lt;/code&gt; 환경 변수 매개 변수를 사용하여 다른 플러그인을 요청할 수 있습니다. 또는 빠른 테스트를 위해 &lt;code&gt;-platform&lt;/code&gt; 명령 행 옵션을 동일한 구문으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="86b46fd53f36cc7d567d0d36edae4ffb684eba83" translate="yes" xml:space="preserve">
          <source>There are two possible scenarios: the signal has already been emitted when wait() is called, or the signal has not yet been emitted. The wait() function handles the first scenario by immediately returning if the signal has already occurred.</source>
          <target state="translated">가능한 두 가지 시나리오가 있습니다. wait ()가 호출 될 때 신호가 이미 방출되었거나 신호가 아직 방출되지 않았습니다. wait () 함수는 신호가 이미 발생한 경우 즉시 리턴하여 첫 번째 시나리오를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="e54058c06ad9ee3e7d33c16eb9c5dba3da48c435" translate="yes" xml:space="preserve">
          <source>There are two render loop variants available: &lt;code&gt;basic&lt;/code&gt;, and &lt;code&gt;threaded&lt;/code&gt;. &lt;code&gt;basic&lt;/code&gt; is single-threaded, while &lt;code&gt;threaded&lt;/code&gt; performs scene graph rendering on a dedicated thread. Qt attempts to choose a suitable loop based on the platform and possibly the graphics drivers in use. When this is not satisfactory, or for testing purposes, the environment variable &lt;code&gt;QSG_RENDER_LOOP&lt;/code&gt; can be used to force the usage of a given loop. To verify which render loop is in use, enable the &lt;code&gt;qt.scenegraph.general&lt;/code&gt;&lt;a href=&quot;qloggingcategory&quot;&gt;logging category&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b819b7d31229b2a3222afa74ccc536eb1ef1e02a" translate="yes" xml:space="preserve">
          <source>There are two signals emitted if the current item of a combobox changes, &lt;a href=&quot;qcombobox#currentIndexChanged&quot;&gt;currentIndexChanged&lt;/a&gt;() and &lt;a href=&quot;qcombobox#activated&quot;&gt;activated&lt;/a&gt;(). &lt;a href=&quot;qcombobox#currentIndexChanged&quot;&gt;currentIndexChanged&lt;/a&gt;() is always emitted regardless if the change was done programmatically or by user interaction, while &lt;a href=&quot;qcombobox#activated&quot;&gt;activated&lt;/a&gt;() is only emitted when the change is caused by user interaction. The &lt;a href=&quot;qcombobox#highlighted&quot;&gt;highlighted&lt;/a&gt;() signal is emitted when the user highlights an item in the combobox popup list. All three signals exist in two versions, one with a &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; argument and one with an &lt;code&gt;int&lt;/code&gt; argument. If the user selects or highlights a pixmap, only the &lt;code&gt;int&lt;/code&gt; signals are emitted. Whenever the text of an editable combobox is changed the &lt;a href=&quot;qcombobox#editTextChanged&quot;&gt;editTextChanged&lt;/a&gt;() signal is emitted.</source>
          <target state="translated">콤보 변경 현재 항목이 경우 두 신호 출사있다 &lt;a href=&quot;qcombobox#currentIndexChanged&quot;&gt;currentIndexChanged&lt;/a&gt; () 및 &lt;a href=&quot;qcombobox#activated&quot;&gt;활성화는&lt;/a&gt; (). &lt;a href=&quot;qcombobox#currentIndexChanged&quot;&gt;currentIndexChanged&lt;/a&gt; ()는 변경이 프로그래밍 방식으로 수행되었는지 또는 사용자 상호 작용에 의해 수행되었는지에 관계없이 항상 생성되는 반면 &lt;a href=&quot;qcombobox#activated&quot;&gt;활성화&lt;/a&gt; ()는 사용자 상호 작용으로 인해 변경이 발생한 경우에만 생성됩니다. &lt;a href=&quot;qcombobox#highlighted&quot;&gt;강조&lt;/a&gt; 사용자가 콤보 팝업리스트에서 항목을 강조 할 때 () 신호가 방출된다. 세 가지 신호는 모두 &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; 인수가있는 것과 &lt;code&gt;int&lt;/code&gt; 인수가 있는 두 가지 버전으로 존재합니다 . 사용자가 픽스맵을 선택하거나 강조 표시하면 &lt;code&gt;int&lt;/code&gt; 신호 만 방출됩니다. 편집 가능한 콤보 박스의 텍스트가 변경 될 때마다&lt;a href=&quot;qcombobox#editTextChanged&quot;&gt;editTextChanged&lt;/a&gt; () 신호가 방출됩니다.</target>
        </trans-unit>
        <trans-unit id="ff23caebb1a76862a050f2687e5093b534042c4b" translate="yes" xml:space="preserve">
          <source>There are two types of bindings in QML: optimized and non-optimized bindings. It is a good idea to keep binding expressions as simple as possible, since the QML engine makes use of an optimized binding expression evaluator which can evaluate simple binding expressions without needing to switch into a full JavaScript execution environment. These optimized bindings are evaluated far more efficiently than more complex (non-optimized) bindings. The basic requirement for optimization of bindings is that the type information of every symbol accessed must be known at compile time.</source>
          <target state="translated">QML에는 바인딩 및 최적화되지 않은 바인딩의 두 가지 유형의 바인딩이 있습니다. QML 엔진은 완전한 JavaScript 실행 환경으로 전환하지 않고도 간단한 바인딩 표현식을 평가할 수있는 최적화 된 바인딩 표현식 평가기를 사용하므로 바인딩 표현식을 가능한 한 단순하게 유지하는 것이 좋습니다. 이러한 최적화 된 바인딩은보다 복잡한 (최적화되지 않은) 바인딩보다 훨씬 효율적으로 평가됩니다. 바인딩 최적화를위한 기본 요구 사항은 액세스 할 때 모든 심볼의 유형 정보를 컴파일 타임에 알아야한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="4f2b4de722d7db98e6d6a4a72cbdae01c7ff390b" translate="yes" xml:space="preserve">
          <source>There are two types of input to the &lt;a href=&quot;qml-qtquick-shadereffect#vertexShader-prop&quot;&gt;vertexShader&lt;/a&gt;: uniform variables and attributes. Some are predefined:</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-shadereffect#vertexShader-prop&quot;&gt;vertexShader&lt;/a&gt; 에는 두 가지 유형의 입력, 즉 균일 변수와 속성이 있습니다. 일부는 미리 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="2dfc650e8b5cdc03153bbd2630191456cd4c2368" translate="yes" xml:space="preserve">
          <source>There are two types of input to the &lt;a href=&quot;qml-qtquick-shadereffect#vertexShader-prop&quot;&gt;vertexShader&lt;/a&gt;: uniforms and vertex inputs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="543ade297f22021009dad53f032581af992badc1" translate="yes" xml:space="preserve">
          <source>There are two types of proxies that Qt understands: transparent proxies and caching proxies. The first group consists of proxies that can handle any arbitrary data transfer, while the second can only handle specific requests. The caching proxies only make sense for the specific classes where they can be used.</source>
          <target state="translated">Qt가 이해하는 프록시에는 투명 프록시와 캐싱 프록시의 두 가지 유형이 있습니다. 첫 번째 그룹은 임의의 데이터 전송을 처리 할 수있는 프록시로 구성되고 두 번째 그룹은 특정 요청 만 처리 할 수 ​​있습니다. 캐싱 프록시는 사용할 수있는 특정 클래스에만 적합합니다.</target>
        </trans-unit>
        <trans-unit id="e2b1a814b1dd6dc671f1b76e20ec456905c5eb8f" translate="yes" xml:space="preserve">
          <source>There are two types of purchases supported by &lt;a href=&quot;qinappstore&quot;&gt;QInAppStore&lt;/a&gt;: &lt;a href=&quot;qinappproduct#ProductType-enum&quot;&gt;QInAppProduct::Consumable&lt;/a&gt; and &lt;a href=&quot;qinappproduct#ProductType-enum&quot;&gt;QInAppProduct::Unlockable&lt;/a&gt;. The former will be consumed when the transaction is completed and &lt;a href=&quot;qinapptransaction#finalize&quot;&gt;QInAppTransaction::finalize&lt;/a&gt;() is called, meaning that it can be purchased again, any number of times. Unlockable items can only be purchased once.</source>
          <target state="translated">지원 구매의 두 가지 유형이 있습니다 &lt;a href=&quot;qinappstore&quot;&gt;QInAppStore&lt;/a&gt; : &lt;a href=&quot;qinappproduct#ProductType-enum&quot;&gt;QInAppProduct :: 소모품&lt;/a&gt; 및 &lt;a href=&quot;qinappproduct#ProductType-enum&quot;&gt;QInAppProduct :: 잠금 해제는&lt;/a&gt; . 전자는 트랜잭션이 완료되고 &lt;a href=&quot;qinapptransaction#finalize&quot;&gt;QInAppTransaction :: finalize&lt;/a&gt; ()가 호출 될 때 소비됩니다. 즉, 여러 번 다시 구입할 수 있습니다. 잠금 해제 가능한 아이템은 한 번만 구입할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d2b1e3f2b89108a4b65b9b7fbe615d3d2e60bfd" translate="yes" xml:space="preserve">
          <source>There are two types of purchases supported by QInAppStore: &lt;a href=&quot;qinappproduct#ProductType-enum&quot;&gt;QInAppProduct::Consumable&lt;/a&gt; and &lt;a href=&quot;qinappproduct#ProductType-enum&quot;&gt;QInAppProduct::Unlockable&lt;/a&gt;. The former will be consumed when the transaction is completed and &lt;a href=&quot;qinapptransaction#finalize&quot;&gt;QInAppTransaction::finalize&lt;/a&gt;() is called, meaning that it can be purchased again, any number of times. Unlockable items can only be purchased once.</source>
          <target state="translated">QInAppStore에서 지원하는 구매 유형에는 &lt;a href=&quot;qinappproduct#ProductType-enum&quot;&gt;QInAppProduct :: Consumable&lt;/a&gt; 및 &lt;a href=&quot;qinappproduct#ProductType-enum&quot;&gt;QInAppProduct :: Unlockable&lt;/a&gt; 두 가지가 있습니다 . 전자는 트랜잭션이 완료되고 &lt;a href=&quot;qinapptransaction#finalize&quot;&gt;QInAppTransaction :: finalize&lt;/a&gt; ()가 호출 될 때 소비됩니다. 이는 다시 구매할 수 있음을 의미합니다. 잠금 해제 가능한 아이템은 한 번만 구매할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c8186dead278a8a9c7d9abd60c8ba4a7656dbde9" translate="yes" xml:space="preserve">
          <source>There are two types of qmake functions: replace functions and test functions. Replace functions return a value list, while test functions return a boolean result. The functions are implemented in two places: fundamental functionality is offered as built-in functions. More complex functions are implemented in a library of feature files (.prf).</source>
          <target state="translated">qmake 함수에는 교체 함수와 테스트 함수의 두 가지 유형이 있습니다. 바꾸기 함수는 값 목록을 반환하고 테스트 함수는 부울 결과를 반환합니다. 기능은 두 곳에서 구현됩니다. 기본 기능은 내장 기능으로 제공됩니다. 더 복잡한 기능은 기능 파일 라이브러리 (.prf)에서 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="a46c8f8d9dfbcff4fc9df96dc229b32c6bfb8c39" translate="yes" xml:space="preserve">
          <source>There are two ways Qt XML Patterns can be used to evaluate queries. You can run the query engine in your Qt application using the Qt XML Patterns C++ API, or you can run the query engine from the command line using Qt's &lt;code&gt;xmlpatterns&lt;/code&gt; command line utility.</source>
          <target state="translated">Qt XML 패턴을 사용하여 쿼리를 평가할 수있는 두 가지 방법이 있습니다. Qt XML Patterns C ++ API를 사용하여 Qt 애플리케이션에서 쿼리 엔진을 실행하거나 Qt의 &lt;code&gt;xmlpatterns&lt;/code&gt; 명령 행 유틸리티를 사용하여 명령 행에서 쿼리 엔진을 실행할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3506aeef26a67cff0c2b6d2e4d7977ae2077caaf" translate="yes" xml:space="preserve">
          <source>There are two ways Qt XML Patterns can be used to validate schemas: You can use the C++ API in your Qt application using the classes &lt;a href=&quot;qxmlschema&quot;&gt;QXmlSchema&lt;/a&gt; and &lt;a href=&quot;qxmlschemavalidator&quot;&gt;QXmlSchemaValidator&lt;/a&gt;, or you can use the command line utility named xmlpatternsvalidator (located in the &quot;bin&quot; directory of your Qt build).</source>
          <target state="translated">Qt XML 패턴을 사용하여 스키마를 유효성 검증하는 두 가지 방법이 있습니다. &lt;a href=&quot;qxmlschema&quot;&gt;QXmlSchema&lt;/a&gt; 및 &lt;a href=&quot;qxmlschemavalidator&quot;&gt;QXmlSchemaValidator&lt;/a&gt; 클래스를 사용하여 Qt 애플리케이션에서 C ++ API를 사용 하거나 xmlpatternsvalidator ( &quot;bin&quot;디렉토리의 &quot;bin&quot;디렉토리에 있음)라는 명령 행 유틸리티를 사용할 수 있습니다. Qt 빌드).</target>
        </trans-unit>
        <trans-unit id="98cc65ea20ce5f3271b77de994366c531ae5d3f4" translate="yes" xml:space="preserve">
          <source>There are two ways of accessing the data provided by this model, either through the &lt;a href=&quot;qml-qtlocation-placesearchsuggestionmodel#suggestions-prop&quot;&gt;suggestions&lt;/a&gt; property or through views and delegates. The latter is the preferred method.</source>
          <target state="translated">&lt;a href=&quot;qml-qtlocation-placesearchsuggestionmodel#suggestions-prop&quot;&gt;제안&lt;/a&gt; 모델 또는보기 및 대리자 를 통해이 모델이 제공하는 데이터에 액세스하는 방법에는 두 가지가 있습니다. 후자가 선호되는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="9a03528ecb489f9c9c73fc8a0cce2e17a16dc1b2" translate="yes" xml:space="preserve">
          <source>There are two ways of approaching sorting in the model/view architecture; which approach to choose depends on your underlying model.</source>
          <target state="translated">모델 / 뷰 아키텍처에는 정렬에 접근하는 두 가지 방법이 있습니다. 선택할 방법은 기본 모델에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="1bd523e14deef66198ab91d82a71cb6dd9f5a962" translate="yes" xml:space="preserve">
          <source>There are two ways of using &lt;a href=&quot;qprogressdialog&quot;&gt;QProgressDialog&lt;/a&gt;: modal and modeless.</source>
          <target state="translated">&lt;a href=&quot;qprogressdialog&quot;&gt;QProgressDialog&lt;/a&gt; 를 사용하는 방법에는 모달과 모달리스 의 두 가지가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b5c65f232299dd2fd2bfdb05ff84135a8dcd0ba1" translate="yes" xml:space="preserve">
          <source>There are two ways of using QProgressDialog: modal and modeless.</source>
          <target state="translated">QProgressDialog를 사용하는 방법에는 모달과 모덜리스의 두 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b7e3170ece6f5c9731fa746d5b95c4498d0bae1" translate="yes" xml:space="preserve">
          <source>There are two ways of using styles in Qt Quick Controls: run-time style selection and compile-time style selection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="619aaeb1084c646a5675de6862d5077b90541a5e" translate="yes" xml:space="preserve">
          <source>There are two ways that &lt;a href=&quot;qicon&quot;&gt;QIcon&lt;/a&gt; supports &lt;a href=&quot;highdpi#high-dpi-displays&quot;&gt;high DPI&lt;/a&gt; icons: via &lt;a href=&quot;qicon#addFile&quot;&gt;addFile&lt;/a&gt;() and &lt;a href=&quot;qicon#fromTheme&quot;&gt;fromTheme&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qicon&quot;&gt;QIcon&lt;/a&gt; 이 &lt;a href=&quot;highdpi#high-dpi-displays&quot;&gt;높은 DPI&lt;/a&gt; 아이콘을 지원 하는 방법은 &lt;a href=&quot;qicon#addFile&quot;&gt;addFile&lt;/a&gt; ()과 &lt;a href=&quot;qicon#fromTheme&quot;&gt;fromTheme&lt;/a&gt; ()입니다.</target>
        </trans-unit>
        <trans-unit id="1d8e2b59dea2d1dcbbcd21228558fe3b488f0c5b" translate="yes" xml:space="preserve">
          <source>There are two ways that QIcon supports &lt;a href=&quot;highdpi&quot;&gt;high DPI&lt;/a&gt; icons: via &lt;a href=&quot;qicon#addFile&quot;&gt;addFile&lt;/a&gt;() and &lt;a href=&quot;qicon#fromTheme&quot;&gt;fromTheme&lt;/a&gt;().</source>
          <target state="translated">QIcon이 &lt;a href=&quot;highdpi&quot;&gt;높은 DPI&lt;/a&gt; 아이콘을 지원하는 방법에는 &lt;a href=&quot;qicon#addFile&quot;&gt;addFile&lt;/a&gt; ()과 &lt;a href=&quot;qicon#fromTheme&quot;&gt;fromTheme&lt;/a&gt; () 두 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd6f26ef42b0305f941a27bc12dae6c65986ae01" translate="yes" xml:space="preserve">
          <source>There are two ways that QIcon supports &lt;a href=&quot;https://doc.qt.io/qt-6.0/portingguide.html#high-dpi&quot;&gt;high DPI&lt;/a&gt; icons: via &lt;a href=&quot;qicon#addFile&quot;&gt;addFile&lt;/a&gt;() and &lt;a href=&quot;qicon#fromTheme&quot;&gt;fromTheme&lt;/a&gt;().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4c7cc4b90fdb71b9316246816539110eebea221" translate="yes" xml:space="preserve">
          <source>There are two ways to add items to the list: they can be constructed with the list widget as their parent widget, or they can be constructed with no parent widget and added to the list later. If a list widget already exists when the items are constructed, the first method is easier to use:</source>
          <target state="translated">목록에 항목을 추가하는 두 가지 방법이 있습니다. 목록 위젯을 상위 위젯으로 구성하거나 상위 위젯없이 구성하여 나중에 목록에 추가 할 수 있습니다. 항목을 구성 할 때 목록 위젯이 이미 존재하면 첫 번째 방법을 사용하는 것이 더 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="66ba5a2c301c366821e32f891a3f8269ee5439bf" translate="yes" xml:space="preserve">
          <source>There are two ways to affect how &lt;a href=&quot;qvariantanimation&quot;&gt;QVariantAnimation&lt;/a&gt; interpolates the values. You can set an easing curve by calling &lt;a href=&quot;qvariantanimation#easingCurve-prop&quot;&gt;setEasingCurve&lt;/a&gt;(), and configure the duration by calling &lt;a href=&quot;qvariantanimation#duration-prop&quot;&gt;setDuration&lt;/a&gt;(). You can change how the &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt;s are interpolated by creating a subclass of &lt;a href=&quot;qvariantanimation&quot;&gt;QVariantAnimation&lt;/a&gt;, and reimplementing the virtual &lt;a href=&quot;qvariantanimation#interpolated&quot;&gt;interpolated&lt;/a&gt;() function.</source>
          <target state="translated">&lt;a href=&quot;qvariantanimation&quot;&gt;QVariantAnimation&lt;/a&gt; 이 값을 보간 하는 방법에 영향을주는 두 가지 방법 이 있습니다. 당신은 호출하여 완화 곡선을 설정할 수 있습니다 &lt;a href=&quot;qvariantanimation#easingCurve-prop&quot;&gt;setEasingCurve을&lt;/a&gt; ()하고, 호출하여 지속 시간을 구성 &lt;a href=&quot;qvariantanimation#duration-prop&quot;&gt;setDuration을&lt;/a&gt; (). 당신은 어떻게 변경할 수 &lt;a href=&quot;qvariant&quot;&gt;QVariant의&lt;/a&gt; 의는의 서브 클래스 생성하여 보간 &lt;a href=&quot;qvariantanimation&quot;&gt;QVariantAnimation를&lt;/a&gt; , 가상 재 구현 &lt;a href=&quot;qvariantanimation#interpolated&quot;&gt;보간&lt;/a&gt; () 함수를.</target>
        </trans-unit>
        <trans-unit id="ffd4ee49c64d052adf8353ef4ddabd4985e27362" translate="yes" xml:space="preserve">
          <source>There are two ways to affect how QVariantAnimation interpolates the values. You can set an easing curve by calling &lt;a href=&quot;qvariantanimation#easingCurve-prop&quot;&gt;setEasingCurve&lt;/a&gt;(), and configure the duration by calling &lt;a href=&quot;qvariantanimation#duration-prop&quot;&gt;setDuration&lt;/a&gt;(). You can change how the &lt;a href=&quot;qtcore-changes-qt6#qvariant&quot;&gt;QVariant&lt;/a&gt;s are interpolated by creating a subclass of QVariantAnimation, and reimplementing the virtual &lt;a href=&quot;qvariantanimation#interpolated&quot;&gt;interpolated&lt;/a&gt;() function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89945ce9cdfc6a209ae4dea5d088ea5416af4eed" translate="yes" xml:space="preserve">
          <source>There are two ways to affect how QVariantAnimation interpolates the values. You can set an easing curve by calling &lt;a href=&quot;qvariantanimation#easingCurve-prop&quot;&gt;setEasingCurve&lt;/a&gt;(), and configure the duration by calling &lt;a href=&quot;qvariantanimation#duration-prop&quot;&gt;setDuration&lt;/a&gt;(). You can change how the &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt;s are interpolated by creating a subclass of QVariantAnimation, and reimplementing the virtual &lt;a href=&quot;qvariantanimation#interpolated&quot;&gt;interpolated&lt;/a&gt;() function.</source>
          <target state="translated">QVariantAnimation이 값을 보간하는 방식에 영향을 미치는 두 가지 방법이 있습니다. 당신은 호출하여 완화 곡선을 설정할 수 있습니다 &lt;a href=&quot;qvariantanimation#easingCurve-prop&quot;&gt;setEasingCurve을&lt;/a&gt; ()하고, 호출하여 지속 시간을 구성 &lt;a href=&quot;qvariantanimation#duration-prop&quot;&gt;setDuration을&lt;/a&gt; (). &lt;a href=&quot;qvariant&quot;&gt;QVariantAnimation&lt;/a&gt; 의 하위 클래스를 만들고 가상 &lt;a href=&quot;qvariantanimation#interpolated&quot;&gt;보간&lt;/a&gt; () 함수를 다시 구현하여 QVariant가 보간되는 방식을 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="41e5a4f8a8b2112075138b03029984d166be544b" translate="yes" xml:space="preserve">
          <source>There are two ways to construct an item group. The easiest and most common approach is to pass a list of items (e.g., all selected items) to &lt;a href=&quot;qgraphicsscene#createItemGroup&quot;&gt;QGraphicsScene::createItemGroup&lt;/a&gt;(), which returns a new &lt;a href=&quot;qgraphicsitemgroup&quot;&gt;QGraphicsItemGroup&lt;/a&gt; item. The other approach is to manually construct a &lt;a href=&quot;qgraphicsitemgroup&quot;&gt;QGraphicsItemGroup&lt;/a&gt; item, add it to the scene calling &lt;a href=&quot;qgraphicsscene#addItem&quot;&gt;QGraphicsScene::addItem&lt;/a&gt;(), and then add items to the group manually, one at a time by calling &lt;a href=&quot;qgraphicsitemgroup#addToGroup&quot;&gt;addToGroup&lt;/a&gt;(). To dismantle (&quot;ungroup&quot;) an item group, you can either call &lt;a href=&quot;qgraphicsscene#destroyItemGroup&quot;&gt;QGraphicsScene::destroyItemGroup&lt;/a&gt;(), or you can manually remove all items from the group by calling &lt;a href=&quot;qgraphicsitemgroup#removeFromGroup&quot;&gt;removeFromGroup&lt;/a&gt;().</source>
          <target state="translated">품목 그룹을 구성하는 방법에는 두 가지가 있습니다. 가장 쉽고 가장 일반적인 방법은 항목 목록 (예 : 선택한 모든 항목)을 &lt;a href=&quot;qgraphicsscene#createItemGroup&quot;&gt;QGraphicsScene :: createItemGroup&lt;/a&gt; ()으로 전달하여 새 &lt;a href=&quot;qgraphicsitemgroup&quot;&gt;QGraphicsItemGroup&lt;/a&gt; 항목 을 반환하는 것 입니다. 다른 방법은 &lt;a href=&quot;qgraphicsitemgroup&quot;&gt;QGraphicsItemGroup&lt;/a&gt; 항목 을 수동으로 구성하고 QGraphicsScene &lt;a href=&quot;qgraphicsscene#addItem&quot;&gt;:: addItem&lt;/a&gt; ()을 호출하는 장면에 추가 한 다음 &lt;a href=&quot;qgraphicsitemgroup#addToGroup&quot;&gt;addToGroup&lt;/a&gt; () 을 호출하여 한 번에 하나씩 그룹에 항목을 수동으로 추가하는 것 입니다. 항목 그룹을 해체 ( &quot;그룹 해제&quot;)하려면 &lt;a href=&quot;qgraphicsscene#destroyItemGroup&quot;&gt;QGraphicsScene :: destroyItemGroup&lt;/a&gt; ()을 호출 하거나 &lt;a href=&quot;qgraphicsitemgroup#removeFromGroup&quot;&gt;removeFromGroup&lt;/a&gt; () 을 호출하여 그룹에서 모든 항목을 수동으로 제거 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8d55a7ae6dd213ad496e8a22890a66c1daf41378" translate="yes" xml:space="preserve">
          <source>There are two ways to construct an item group. The easiest and most common approach is to pass a list of items (e.g., all selected items) to &lt;a href=&quot;qgraphicsscene#createItemGroup&quot;&gt;QGraphicsScene::createItemGroup&lt;/a&gt;(), which returns a new QGraphicsItemGroup item. The other approach is to manually construct a QGraphicsItemGroup item, add it to the scene calling &lt;a href=&quot;qgraphicsscene#addItem&quot;&gt;QGraphicsScene::addItem&lt;/a&gt;(), and then add items to the group manually, one at a time by calling &lt;a href=&quot;qgraphicsitemgroup#addToGroup&quot;&gt;addToGroup&lt;/a&gt;(). To dismantle (&quot;ungroup&quot;) an item group, you can either call &lt;a href=&quot;qgraphicsscene#destroyItemGroup&quot;&gt;QGraphicsScene::destroyItemGroup&lt;/a&gt;(), or you can manually remove all items from the group by calling &lt;a href=&quot;qgraphicsitemgroup#removeFromGroup&quot;&gt;removeFromGroup&lt;/a&gt;().</source>
          <target state="translated">항목 그룹을 구성하는 방법에는 두 가지가 있습니다. 가장 쉽고 가장 일반적인 방법은 항목 목록 (예 : 선택한 모든 항목)을 &lt;a href=&quot;qgraphicsscene#createItemGroup&quot;&gt;QGraphicsScene :: createItemGroup&lt;/a&gt; ()에 전달하여 새 QGraphicsItemGroup 항목을 반환하는 것입니다. 다른 방법은 QGraphicsItemGroup 항목을 수동으로 구성하고 QGraphicsScene &lt;a href=&quot;qgraphicsscene#addItem&quot;&gt;:: addItem&lt;/a&gt; ()을 호출하는 장면에 추가 한 다음 &lt;a href=&quot;qgraphicsitemgroup#addToGroup&quot;&gt;addToGroup&lt;/a&gt; () 을 호출하여 한 번에 하나씩 수동으로 그룹에 항목을 추가하는 것 입니다. 항목 그룹을 해체 ( &quot;그룹 해제&quot;)하려면 &lt;a href=&quot;qgraphicsscene#destroyItemGroup&quot;&gt;QGraphicsScene :: destroyItemGroup&lt;/a&gt; ()을 호출 하거나 &lt;a href=&quot;qgraphicsitemgroup#removeFromGroup&quot;&gt;removeFromGroup&lt;/a&gt; () 을 호출하여 그룹에서 모든 항목을 수동으로 제거 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0a70fb138b33df172cb4851452595101d6276f81" translate="yes" xml:space="preserve">
          <source>There are two ways to create &lt;a href=&quot;qml-qtaudioengine-soundinstance&quot;&gt;SoundInstance&lt;/a&gt; objects. You can obtain it by calling newInstance method of a &lt;a href=&quot;qml-qtaudioengine-sound&quot;&gt;Sound&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;qml-qtaudioengine-soundinstance&quot;&gt;SoundInstance&lt;/a&gt; 객체 를 만드는 방법에는 두 가지가 있습니다 . &lt;a href=&quot;qml-qtaudioengine-sound&quot;&gt;Sound의&lt;/a&gt; newInstance 메소드를 호출하여 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d681ddece6420a76291039e9f1ebcdee41526821" translate="yes" xml:space="preserve">
          <source>There are two ways to create SoundInstance objects. You can obtain it by calling newInstance method of a &lt;a href=&quot;qml-qtaudioengine-sound&quot;&gt;Sound&lt;/a&gt;:</source>
          <target state="translated">SoundInstance 객체를 만드는 방법에는 두 가지가 있습니다. &lt;a href=&quot;qml-qtaudioengine-sound&quot;&gt;Sound의&lt;/a&gt; newInstance 메서드를 호출하여 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="49aaec2699aac0c26a832804ceb1149838a9b84d" translate="yes" xml:space="preserve">
          <source>There are two ways to create objects dynamically from JavaScript. You can either call &lt;a href=&quot;qml-qtqml-qt#createComponent-method&quot;&gt;Qt.createComponent()&lt;/a&gt; to dynamically create a &lt;a href=&quot;qml-qtqml-component&quot;&gt;Component&lt;/a&gt; object, or use &lt;a href=&quot;qml-qtqml-qt#createQmlObject-method&quot;&gt;Qt.createQmlObject()&lt;/a&gt; to create an object from a string of QML. Creating a component is better if you have an existing component defined in a QML document and you want to dynamically create instances of that component. Otherwise, creating an object from a string of QML is useful when the object QML itself is generated at runtime.</source>
          <target state="translated">JavaScript에서 객체를 동적으로 만드는 방법에는 두 가지가 있습니다. &lt;a href=&quot;qml-qtqml-qt#createComponent-method&quot;&gt;Qt.createComponent ()&lt;/a&gt; 를 호출 하여 동적으로 &lt;a href=&quot;qml-qtqml-component&quot;&gt;Component&lt;/a&gt; 오브젝트 를 작성 하거나 &lt;a href=&quot;qml-qtqml-qt#createQmlObject-method&quot;&gt;Qt.createQmlObject ()&lt;/a&gt; 를 사용하여 QML 문자열에서 오브젝트를 작성할 수 있습니다. QML 문서에 기존 구성 요소가 정의되어 있고 해당 구성 요소의 인스턴스를 동적으로 작성하려는 경우 구성 요소 작성이 더 좋습니다. 그렇지 않으면, QML 문자열에서 오브젝트 작성은 오브젝트 QML 자체가 런타임에 생성 될 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="6abe161066e97b4531fe6ca7f71e47f40da71292" translate="yes" xml:space="preserve">
          <source>There are two ways to define a 3D scene for View3D to view. The first and easiest is to just define a higharchy of &lt;a href=&quot;qml-qtquick3d-node&quot;&gt;Node&lt;/a&gt; based items as children of the View3D. This becomes the implicit scene of the viewport.</source>
          <target state="translated">View3D에서 볼 수 있도록 3D 장면을 정의하는 방법에는 두 가지가 있습니다. 가장 쉬운 방법은 &lt;a href=&quot;qml-qtquick3d-node&quot;&gt;노드&lt;/a&gt; 기반 항목의 상위 구조를 View3D의 자식으로 정의하는 것입니다 . 이것은 뷰포트의 암시 적 장면이됩니다.</target>
        </trans-unit>
        <trans-unit id="3ad0e4fb60a51220ca07fb662a10e0d9c4c9c102" translate="yes" xml:space="preserve">
          <source>There are two ways to define a property binding: the most common one is shown in the example earlier, in a &lt;a href=&quot;qtqml-syntax-objectattributes#value-assignment-on-initialization&quot;&gt;property initialization&lt;/a&gt;. The second (and much rarer) way is to assign the property a function returned from the &lt;a href=&quot;qml-qtqml-qt#binding-method&quot;&gt;Qt.binding()&lt;/a&gt; function, from within imperative JavaScript code, as shown below:</source>
          <target state="translated">속성 바인딩을 정의하는 방법에는 두 가지가 있습니다. 가장 일반적인 방법은 앞의 예제에서 &lt;a href=&quot;qtqml-syntax-objectattributes#value-assignment-on-initialization&quot;&gt;속성 초기화에 나와&lt;/a&gt; 있습니다. 두 번째 (그리고 훨씬 더 드문) 방법은 아래에 표시된 것처럼 필수 JavaScript 코드 내에서 &lt;a href=&quot;qml-qtqml-qt#binding-method&quot;&gt;Qt.binding ()&lt;/a&gt; 함수 에서 반환 된 함수에 속성을 할당하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="159981daec8618cc7424f62827594fa1b7e9d2fd" translate="yes" xml:space="preserve">
          <source>There are two ways to define the 3D scene that is visualized on the View3D: If you define a hierarchy of &lt;a href=&quot;qml-qtquick3d-node&quot;&gt;Node-based&lt;/a&gt; items as children of the View3D directly, then this will become the implicit scene of the View3D.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09ee79d2653e49e4aa7a065cdbdbbb601c72bfa7" translate="yes" xml:space="preserve">
          <source>There are two ways to embed a widget using &lt;a href=&quot;qgraphicsproxywidget&quot;&gt;QGraphicsProxyWidget&lt;/a&gt;. The most common way is to pass a widget pointer to &lt;a href=&quot;qgraphicsscene#addWidget&quot;&gt;QGraphicsScene::addWidget&lt;/a&gt;() together with any relevant &lt;a href=&quot;qt#WindowType-enum&quot;&gt;Qt::WindowFlags&lt;/a&gt;. This function returns a pointer to a &lt;a href=&quot;qgraphicsproxywidget&quot;&gt;QGraphicsProxyWidget&lt;/a&gt;. You can then choose to reparent or position either the proxy, or the embedded widget itself.</source>
          <target state="translated">&lt;a href=&quot;qgraphicsproxywidget&quot;&gt;QGraphicsProxyWidget을&lt;/a&gt; 사용하여 위젯을 임베드하는 두 가지 방법이 있습니다 . 가장 일반적인 방법은 위젯 포인터를 &lt;a href=&quot;qgraphicsscene#addWidget&quot;&gt;QGraphicsScene :: addWidget&lt;/a&gt; ()에 관련 &lt;a href=&quot;qt#WindowType-enum&quot;&gt;Qt :: WindowFlags&lt;/a&gt; 와 함께 전달하는 것 입니다. 이 함수는 &lt;a href=&quot;qgraphicsproxywidget&quot;&gt;QGraphicsProxyWidget에&lt;/a&gt; 대한 포인터를 리턴합니다 . 그런 다음 프록시 또는 임베드 된 위젯 자체를 보호하거나 배치하도록 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8fc038f94630a683fa1f12b50f489cd65c927180" translate="yes" xml:space="preserve">
          <source>There are two ways to embed a widget using QGraphicsProxyWidget. The most common way is to pass a widget pointer to &lt;a href=&quot;qgraphicsscene#addWidget&quot;&gt;QGraphicsScene::addWidget&lt;/a&gt;() together with any relevant &lt;a href=&quot;qt#WindowType-enum&quot;&gt;Qt::WindowFlags&lt;/a&gt;. This function returns a pointer to a QGraphicsProxyWidget. You can then choose to reparent or position either the proxy, or the embedded widget itself.</source>
          <target state="translated">QGraphicsProxyWidget을 사용하여 위젯을 삽입하는 방법에는 두 가지가 있습니다. 가장 일반적인 방법은 관련 &lt;a href=&quot;qt#WindowType-enum&quot;&gt;Qt :: WindowFlags&lt;/a&gt; 와 함께 위젯 포인터를 &lt;a href=&quot;qgraphicsscene#addWidget&quot;&gt;QGraphicsScene :: addWidget&lt;/a&gt; () 에 전달하는 것 입니다. 이 함수는 QGraphicsProxyWidget에 대한 포인터를 반환합니다. 그런 다음 프록시 또는 포함 된 위젯 자체를 상위 또는 위치 지정하도록 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="db0b272752edd3b3a26e0eba4702702d3de025a4" translate="yes" xml:space="preserve">
          <source>There are two ways to install Qt:</source>
          <target state="translated">Qt를 설치하는 방법은 두 가지가 있습니다 :</target>
        </trans-unit>
        <trans-unit id="3604108d4c8766e519bce87f37f59416eb6217da" translate="yes" xml:space="preserve">
          <source>There are two ways to link against the corresponding C++ library. If your test project uses a QML &lt;a href=&quot;qml-qttest-testcase&quot;&gt;TestCase&lt;/a&gt;, you should already have the following line in your project file:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3e8d75c19150ace0e1fed108e21301e69557093" translate="yes" xml:space="preserve">
          <source>There are two ways to populate the input source with data: you can construct it with a &lt;a href=&quot;qiodevice&quot;&gt;QIODevice&lt;/a&gt;* so that the input source reads the data from that device. Or you can set the data explicitly with one of the &lt;a href=&quot;qxmlinputsource#setData&quot;&gt;setData&lt;/a&gt;() functions.</source>
          <target state="translated">입력 소스를 데이터로 채우는 두 가지 방법이 있습니다 . 입력 소스가 해당 디바이스에서 데이터를 읽도록 &lt;a href=&quot;qiodevice&quot;&gt;QIODevice&lt;/a&gt; * 로이를 구성 할 수 있습니다 . 또는 &lt;a href=&quot;qxmlinputsource#setData&quot;&gt;setData&lt;/a&gt; () 함수 중 하나를 사용하여 명시 적으로 데이터를 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8f4bfeab275db72237c720b9da1dd3542460b8b3" translate="yes" xml:space="preserve">
          <source>There are two ways you can access this improved method of string construction. The straightforward way is to include &lt;code&gt;QStringBuilder&lt;/code&gt; wherever you want to use it, and use the &lt;code&gt;'%'&lt;/code&gt; operator instead of &lt;code&gt;'+'&lt;/code&gt; when concatenating strings:</source>
          <target state="translated">이 개선 된 스트링 구성 방법에 액세스 할 수있는 두 가지 방법이 있습니다. 간단한 방법은 &lt;code&gt;QStringBuilder&lt;/code&gt; 를 사용하려는 곳에 QStringBuilder 를 포함 시키고 문자열을 연결할 때 &lt;code&gt;'+'&lt;/code&gt; 대신 &lt;code&gt;'%'&lt;/code&gt; 연산자를 사용하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="496f1dece6a2f67e36a1ab8a6c7e1e4f48339367" translate="yes" xml:space="preserve">
          <source>There can also be alternate ways of dismissing the dialog which may cause destructive results.</source>
          <target state="translated">대화 상자를 닫는 다른 방법으로도 결과가 손상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="93b9f67c23345abba60bcfee767743ea7d6791c2" translate="yes" xml:space="preserve">
          <source>There can be multiple selected items.</source>
          <target state="translated">선택한 항목이 여러 개있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a801b170a8956368ca3dfcaa44f77677b395838" translate="yes" xml:space="preserve">
          <source>There can only be one current item.</source>
          <target state="translated">현재 항목은 하나만있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6630c15d89215bfef2c2ee428c016df641b2b5a3" translate="yes" xml:space="preserve">
          <source>There has to be exactly one &lt;a href=&quot;qapplication&quot;&gt;QApplication&lt;/a&gt; object in every GUI application that uses Qt.</source>
          <target state="translated">Qt를 사용하는 모든 GUI 응용 프로그램에는 정확히 하나의 &lt;a href=&quot;qapplication&quot;&gt;QApplication&lt;/a&gt; 오브젝트가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="3ac144b56b74a3b76825627cd6397ec17017d9da" translate="yes" xml:space="preserve">
          <source>There is a &amp;lt;Type&amp;gt;SimpleSource class defined in the header, which provides basic getter/setter methods for each property and implements data members of the correct property type in the header. Here &quot;&amp;lt;Type&amp;gt;&quot; represents the class name from the .rep file, so if your class is of type &quot;MyType&quot; in the .rep file, there will be a MyTypeSimpleSource class declared in the generated header file. This is a fast way to get started using the API. To use this class, you need to inherit from this class and implement any defined slots (which are pure virtual in the generated header file). Whatever logic is needed to manage the exposed properties and emit signals would be added to the inheriting class as well.</source>
          <target state="translated">헤더에 정의 된 &amp;lt;Type&amp;gt; SimpleSource 클래스가 있습니다.이 클래스는 각 특성에 대한 기본 getter / setter 메소드를 제공하고 헤더에서 올바른 특성 유형의 데이터 멤버를 구현합니다. 여기서 &quot;&amp;lt;Type&amp;gt;&quot;은 .rep 파일의 클래스 이름을 나타내므로 .rep 파일에서 클래스가 &quot;MyType&quot;유형 인 경우 생성 된 헤더 파일에 MyTypeSimpleSource 클래스가 선언됩니다. API를 사용하여 시작하는 가장 빠른 방법입니다. 이 클래스를 사용하려면이 클래스에서 상속하고 정의 된 슬롯 (생성 된 헤더 파일에서 순수한 가상)을 구현해야합니다. 노출 된 속성과 방출 신호를 관리하는 데 필요한 로직은 상속 클래스에도 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="3412489eab2a18c7d1854bb0a2e7e22f2ba209d0" translate="yes" xml:space="preserve">
          <source>There is a &amp;lt;Type&amp;gt;SimpleSource class defined in the header, which provides the basic getter/setter methods for each property and implements data members of the correct property type in the header. &quot;&amp;lt;Type&amp;gt;&quot; here represents the class name from the &lt;code&gt;.rep&lt;/code&gt; file, so if your class is of type &quot;MyType&quot; in the &lt;code&gt;.rep&lt;/code&gt; file, then the generated header file will have a MyTypeSimpleSource class declared. This is a quick way to get started using the API. To use this class, you need to write a class that inherits from it and implement any slots defined, which are marked as pure virtual in the generated header file. You need to add the necessary logic to manage the exposed properties and emit signals, to your class as well.</source>
          <target state="translated">헤더에 정의 된 &amp;lt;Type&amp;gt; SimpleSource 클래스가 있으며, 각 속성에 대한 기본 getter / setter 메서드를 제공하고 헤더에 올바른 속성 유형의 데이터 멤버를 구현합니다. &quot;&amp;lt;유형&amp;gt;&quot;여기에서 클래스 이름을 나타냅니다 &lt;code&gt;.rep&lt;/code&gt; 의 클래스가에서 &quot;합니다 MyType&quot;유형의 그렇다면, 파일을 &lt;code&gt;.rep&lt;/code&gt; 의 파일이 다음 생성 된 헤더 파일은 MyTypeSimpleSource 클래스를 선언해야합니다. 이것은 API 사용을 시작하는 빠른 방법입니다. 이 클래스를 사용하려면 생성 된 헤더 파일에서 순수 가상으로 표시되는 정의 된 슬롯을 상속하고 구현하는 클래스를 작성해야합니다. 노출 된 속성을 관리하고 신호를 내보내는 데 필요한 논리를 클래스에도 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="2313e842244ff8c23805bf7dbeca8b7bd9a964f1" translate="yes" xml:space="preserve">
          <source>There is a &lt;a href=&quot;qpainter#drawPicture&quot;&gt;drawPicture&lt;/a&gt;() function that draws the contents of an entire &lt;a href=&quot;qpicture&quot;&gt;QPicture&lt;/a&gt;. The &lt;a href=&quot;qpainter#drawPicture&quot;&gt;drawPicture&lt;/a&gt;() function is the only function that disregards all the painter's settings as &lt;a href=&quot;qpicture&quot;&gt;QPicture&lt;/a&gt; has its own settings.</source>
          <target state="translated">있습니다 &lt;a href=&quot;qpainter#drawPicture&quot;&gt;drawPicture&lt;/a&gt; 전체의 내용을 그립니다 () 함수 &lt;a href=&quot;qpicture&quot;&gt;QPicture는&lt;/a&gt; . &lt;a href=&quot;qpicture&quot;&gt;QPicture&lt;/a&gt; 에는 자체 설정 이 &lt;a href=&quot;qpainter#drawPicture&quot;&gt;있으므로 drawPicture&lt;/a&gt; () 함수는 모든 화가의 설정을 무시하는 유일한 기능입니다 .</target>
        </trans-unit>
        <trans-unit id="1988826b1f8b0d33a4825e1c6957969129f6082e" translate="yes" xml:space="preserve">
          <source>There is a class of attribute types of the format x_id_&amp;lt;provider&amp;gt; for example x_id_here. This class of attributes is a set of alternative identifiers of the place, from the specified provider's perspective.</source>
          <target state="translated">x_id_ &amp;lt;provider&amp;gt; 형식의 속성 유형 클래스가 있습니다 (예 : x_id_here). 이 속성 클래스는 지정된 제공자의 관점에서 볼 때 장소의 대체 식별자 집합입니다.</target>
        </trans-unit>
        <trans-unit id="d4f59be61eb411d5901a0e3ea0ee7e5c28fe3ce2" translate="yes" xml:space="preserve">
          <source>There is a corresponding &lt;a href=&quot;qxmlcontenthandler#endElement&quot;&gt;endElement&lt;/a&gt;() call when the corresponding end element tag is read. The startElement() and &lt;a href=&quot;qxmlcontenthandler#endElement&quot;&gt;endElement&lt;/a&gt;() calls are always nested correctly. Empty element tags (e.g. &lt;code&gt;&amp;lt;x/&amp;gt;&lt;/code&gt;) cause a startElement() call to be immediately followed by an &lt;a href=&quot;qxmlcontenthandler#endElement&quot;&gt;endElement&lt;/a&gt;() call.</source>
          <target state="translated">해당 종료 요소 태그를 읽을 때 해당 &lt;a href=&quot;qxmlcontenthandler#endElement&quot;&gt;endElement&lt;/a&gt; () 호출이 있습니다. startElement () 및 &lt;a href=&quot;qxmlcontenthandler#endElement&quot;&gt;endElement&lt;/a&gt; () 호출은 항상 올바르게 중첩됩니다. 빈 요소 태그 (예 : &lt;code&gt;&amp;lt;x/&amp;gt;&lt;/code&gt; )는 startElement () 호출 바로 뒤에 &lt;a href=&quot;qxmlcontenthandler#endElement&quot;&gt;endElement&lt;/a&gt; () 호출 이옵니다 .</target>
        </trans-unit>
        <trans-unit id="db777b850d525796dcda0193d7194ac42ddb0f08" translate="yes" xml:space="preserve">
          <source>There is a corresponding &lt;code&gt;disconnect()&lt;/code&gt; method for removing connected signals:</source>
          <target state="translated">연결된 신호를 제거 하는 해당 &lt;code&gt;disconnect()&lt;/code&gt; 메소드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="27df7e66ddad0a4e56d70c5b6360858f077d69b1" translate="yes" xml:space="preserve">
          <source>There is a default connection handshake timeout of 10 seconds to avoid denial of service, which can be customized using &lt;a href=&quot;qwebsocketserver#setHandshakeTimeout&quot;&gt;setHandshakeTimeout&lt;/a&gt;().</source>
          <target state="translated">서비스 거부를 방지하기위한 기본 연결 핸드 셰이크 제한 시간은 10 초이며 &lt;a href=&quot;qwebsocketserver#setHandshakeTimeout&quot;&gt;setHandshakeTimeout&lt;/a&gt; ()을 사용하여 사용자 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dd19dfa8869f5eac4dc19841b2dba63f9642268e" translate="yes" xml:space="preserve">
          <source>There is a delay to showing the menu.</source>
          <target state="translated">메뉴 표시가 지연됩니다.</target>
        </trans-unit>
        <trans-unit id="8d2390adf22ea96a79b2e168d0d8c92a8494e814" translate="yes" xml:space="preserve">
          <source>There is a known issue when running Microsoft NetMeeting, Lotus SameTime, and other applications that require screen grabbing while direct rendering is enabled. Other GL-applications may not work as expected, unless direct rendering is disabled.</source>
          <target state="translated">직접 렌더링이 활성화 된 상태에서 화면 캡처가 필요한 Microsoft NetMeeting, Lotus SameTime 및 기타 응용 프로그램을 실행할 때 알려진 문제가 있습니다. 직접 렌더링을 비활성화하지 않으면 다른 GL 응용 프로그램이 예상대로 작동하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7fdad1047478ff9ba3f72cbb3b0731f2fbb6168f" translate="yes" xml:space="preserve">
          <source>There is a list of standard action names and localizations available that should be used when the action fits. This makes it easier for clients to understand the semantics, and Qt will try to expose them correctly on the different platforms.</source>
          <target state="translated">활동이 적합 할 때 사용해야하는 표준 활동 이름 및 현지화 목록이 있습니다. 이를 통해 클라이언트가 의미를 쉽게 이해할 수 있으며 Qt는 다른 플랫폼에서 올바르게 의미를 노출하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="4239053bded9a4f7a7552be0ec5b4d770c9fcb6c" translate="yes" xml:space="preserve">
          <source>There is a set of environment variables you should set when starting a Qt application. Most of them are actually not specific to QNX Neutrino RTOS. They are still mentioned here, since knowing them just saves a lot of time in case of problems.</source>
          <target state="translated">Qt 애플리케이션을 시작할 때 설정해야하는 환경 변수 세트가 있습니다. 대부분은 실제로 QNX Neutrino RTOS에만 국한되지 않습니다. 그것들을 아는 것은 문제가 발생하면 많은 시간을 절약하기 때문에 여전히 여기에 언급되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="b3c960632e664b7b5f2b3232e4b3b2041540c96a" translate="yes" xml:space="preserve">
          <source>There is a significant performance cost to using a &lt;a href=&quot;qml-qtqml-models-listmodel&quot;&gt;ListModel&lt;/a&gt; with dynamic roles enabled. The cost varies from platform to platform but is typically somewhere between 4-6x slower than using static role types.</source>
          <target state="translated">동적 역할이 활성화 된 &lt;a href=&quot;qml-qtqml-models-listmodel&quot;&gt;ListModel&lt;/a&gt; 을 사용하면 상당한 성능 비용이 발생합니다 . 비용은 플랫폼마다 다르지만 일반적으로 정적 역할 유형을 사용하는 것보다 4-6 배 느립니다.</target>
        </trans-unit>
        <trans-unit id="aa231e8cb7a84a0d05da5d243da65fb967339cca" translate="yes" xml:space="preserve">
          <source>There is a single &lt;a href=&quot;qclipboard&quot;&gt;QClipboard&lt;/a&gt; object in an application, accessible as &lt;a href=&quot;qguiapplication#clipboard&quot;&gt;QGuiApplication::clipboard&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qguiapplication#clipboard&quot;&gt;QGuiApplication :: clipboard&lt;/a&gt; () 로 액세스 할 수 있는 단일 &lt;a href=&quot;qclipboard&quot;&gt;QClipboard&lt;/a&gt; 객체가 응용 프로그램에 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1825bfe22149d33dec07b72a803d162f15160eb5" translate="yes" xml:space="preserve">
          <source>There is a single QClipboard object in an application, accessible as &lt;a href=&quot;qguiapplication#clipboard&quot;&gt;QGuiApplication::clipboard&lt;/a&gt;().</source>
          <target state="translated">응용 프로그램에는 &lt;a href=&quot;qguiapplication#clipboard&quot;&gt;QGuiApplication :: clipboard&lt;/a&gt; () 로 액세스 할 수있는 단일 QClipboard 객체가 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed7d7c3a070e90710bd236c84d68a8103d2733c8" translate="yes" xml:space="preserve">
          <source>There is a strict ordering of the section units:</source>
          <target state="translated">섹션 단위의 엄격한 순서가 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ab176ae73921ee7472b128fd24bc1326ea49e46" translate="yes" xml:space="preserve">
          <source>There is a third constructor that creates a &lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt; using the top-left and bottom-right coordinates, but we recommend that you avoid using it. The rationale is that for historical reasons the values returned by the &lt;a href=&quot;qrect#bottom&quot;&gt;bottom&lt;/a&gt;() and &lt;a href=&quot;qrect#right&quot;&gt;right&lt;/a&gt;() functions deviate from the true bottom-right corner of the rectangle.</source>
          <target state="translated">왼쪽 상단 및 오른쪽 하단 좌표를 사용하여 &lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt; 를 생성하는 세 번째 생성자가 있지만 사용하지 않는 것이 좋습니다. 이론적 근거는 역사적 이유로 &lt;a href=&quot;qrect#bottom&quot;&gt;bottom&lt;/a&gt; () 및 &lt;a href=&quot;qrect#right&quot;&gt;right&lt;/a&gt; () 함수가 반환 한 값 이 사각형의 오른쪽 하단에서 벗어난 것입니다.</target>
        </trans-unit>
        <trans-unit id="8e4cfcab00a8ae30f4c621cea80bc4ce0918d874" translate="yes" xml:space="preserve">
          <source>There is a third constructor that creates a QRect using the top-left and bottom-right coordinates, but we recommend that you avoid using it. The rationale is that for historical reasons the values returned by the &lt;a href=&quot;qrect#bottom&quot;&gt;bottom&lt;/a&gt;() and &lt;a href=&quot;qrect#right&quot;&gt;right&lt;/a&gt;() functions deviate from the true bottom-right corner of the rectangle.</source>
          <target state="translated">왼쪽 상단 및 오른쪽 하단 좌표를 사용하여 QRect를 생성하는 세 번째 생성자가 있지만 사용하지 않는 것이 좋습니다. 이유는 역사적인 이유로 &lt;a href=&quot;qrect#bottom&quot;&gt;아래쪽&lt;/a&gt; () 및 &lt;a href=&quot;qrect#right&quot;&gt;오른쪽&lt;/a&gt; () 함수에서 반환 된 값 이 사각형의 실제 오른쪽 아래 모서리에서 벗어난다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a34d43baf02402f60fb8356a5f224db49f8346a3" translate="yes" xml:space="preserve">
          <source>There is also a &lt;a href=&quot;qhash#value&quot;&gt;value&lt;/a&gt;() overload that uses its second argument as a default value if there is no item with the specified key:</source>
          <target state="translated">지정된 키를 가진 항목이없는 경우 두 번째 인수를 기본값으로 사용 하는 &lt;a href=&quot;qhash#value&quot;&gt;값&lt;/a&gt; () 오버로드 도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9e35049049c739c9b33819a908c67c64d9c24a5c" translate="yes" xml:space="preserve">
          <source>There is also a &lt;a href=&quot;qmap#value&quot;&gt;value&lt;/a&gt;() overload that uses its second argument as a default value if there is no item with the specified key:</source>
          <target state="translated">지정된 키를 가진 항목이없는 경우 두 번째 인수를 기본값으로 사용 하는 &lt;a href=&quot;qmap#value&quot;&gt;값&lt;/a&gt; () 오버로드 도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f6217ec7f20265591e9cc4d24bc3155c67ecb02c" translate="yes" xml:space="preserve">
          <source>There is also a &lt;a href=&quot;qmultimap#value&quot;&gt;value&lt;/a&gt;() overload that uses its second argument as a default value if there is no item with the specified key:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c85d0da264ca6228ff4247b36fca68457635acf2" translate="yes" xml:space="preserve">
          <source>There is also a combination approach where you define both a scene with children nodes, as well as define a scene that is being referenced. In this case you can treat the referenced scene as a sibling of the child scene.</source>
          <target state="translated">또한 하위 노드가있는 장면을 정의하고 참조되는 장면을 정의하는 조합 방식도 있습니다. 이 경우 참조 된 장면을 자식 장면의 형제로 취급 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7becc76637d807cf5958ce8fb022659e8e0be346" translate="yes" xml:space="preserve">
          <source>There is also a command for documenting that a QML type inherits some other QML type.</source>
          <target state="translated">QML 유형이 다른 QML 유형을 상속한다는 문서화 명령도 있습니다.</target>
        </trans-unit>
        <trans-unit id="51e4ce289cce72f1172919dc3dee4350b425c0e2" translate="yes" xml:space="preserve">
          <source>There is also a templatized version of &lt;a href=&quot;qaudiobuffer#data&quot;&gt;data&lt;/a&gt;() allows you to retrieve a specific type of pointer to the data. Note that there is no checking done on the format of the audio buffer - this is simply a convenience function.</source>
          <target state="translated">템플릿 화 된 &lt;a href=&quot;qaudiobuffer#data&quot;&gt;데이터&lt;/a&gt; 버전 ()을 사용하면 데이터에 대한 특정 유형의 포인터를 검색 할 수 있습니다. 오디오 버퍼의 형식에 대한 점검은 없습니다-이것은 단지 편리한 기능입니다.</target>
        </trans-unit>
        <trans-unit id="33913b09fa328ebc278f760543c37f998c9d34b4" translate="yes" xml:space="preserve">
          <source>There is also a templatized version of data() allows you to retrieve a specific type of pointer to the data. Note that there is no checking done on the format of the audio buffer - this is simply a convenience function.</source>
          <target state="translated">data ()의 템플릿 화 된 버전도있어 데이터에 대한 특정 유형의 포인터를 검색 할 수 있습니다. 오디오 버퍼의 형식에 대한 검사는 수행되지 않습니다. 이것은 단순히 편리한 기능입니다.</target>
        </trans-unit>
        <trans-unit id="e96e63838c3f15d115746307284c69a8b6107d14" translate="yes" xml:space="preserve">
          <source>There is also a templatized version of this constData() function that allows you to retrieve a specific type of read-only pointer to the data. Note that there is no checking done on the format of the audio buffer - this is simply a convenience function.</source>
          <target state="translated">이 constData () 함수에는 데이터에 대한 특정 유형의 읽기 전용 포인터를 검색 할 수있는 템플릿 버전도 있습니다. 오디오 버퍼의 형식에 대한 점검은 없습니다-이것은 단지 편리한 기능입니다.</target>
        </trans-unit>
        <trans-unit id="f0493c27d9462d156ddd3dda77071f9ee76927e9" translate="yes" xml:space="preserve">
          <source>There is also a templatized version of this data() function that allows you to retrieve a specific type of read-only pointer to the data. Note that there is no checking done on the format of the audio buffer - this is simply a convenience function.</source>
          <target state="translated">이 data () 함수에는 데이터에 대한 특정 유형의 읽기 전용 포인터를 검색 할 수있는 템플릿 버전도 있습니다. 오디오 버퍼의 형식에 대한 점검은 없습니다-이것은 단지 편리한 기능입니다.</target>
        </trans-unit>
        <trans-unit id="f6766377a2fe3ca45fa80875e15d29323e0e3c4c" translate="yes" xml:space="preserve">
          <source>There is also a third constructor creating a &lt;a href=&quot;qrectf&quot;&gt;QRectF&lt;/a&gt; from a &lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt;, and a corresponding &lt;a href=&quot;qrectf#toRect&quot;&gt;toRect&lt;/a&gt;() function that returns a &lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt; object based on the values of this rectangle (note that the coordinates in the returned rectangle are rounded to the nearest integer).</source>
          <target state="translated">&lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt; 에서 &lt;a href=&quot;qrectf&quot;&gt;QRectF&lt;/a&gt; 를 작성하는 세 번째 생성자 와이 사각형의 값을 기반으로 &lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt; 오브젝트 를 리턴 하는 해당 &lt;a href=&quot;qrectf#toRect&quot;&gt;toRect&lt;/a&gt; () 함수도 있습니다 (반환 된 사각형의 좌표는 가장 가까운 정수로 반올림 됨).</target>
        </trans-unit>
        <trans-unit id="4879ff49c77889854cb6d58380e1ca178196eb96" translate="yes" xml:space="preserve">
          <source>There is also a third constructor creating a QRectF from a &lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt;, and a corresponding &lt;a href=&quot;qrectf#toRect&quot;&gt;toRect&lt;/a&gt;() function that returns a &lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt; object based on the values of this rectangle (note that the coordinates in the returned rectangle are rounded to the nearest integer).</source>
          <target state="translated">&lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt; 에서 QRectF를 만드는 세 번째 생성자 와이 사각형의 값을 기반으로 &lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt; 객체 를 반환 하는 해당 &lt;a href=&quot;qrectf#toRect&quot;&gt;toRect&lt;/a&gt; () 함수도 있습니다 (반환 된 사각형의 좌표는 가장 가까운 정수로 반올림 됨).</target>
        </trans-unit>
        <trans-unit id="5f92f74f5b3160f1cbc547bbae6dc615dc6fae68" translate="yes" xml:space="preserve">
          <source>There is also the &lt;code&gt;|&lt;/code&gt; operator to act like a logical OR operator, joining together a number of conditions, and requiring only one of them to be true.</source>
          <target state="translated">또한 &lt;code&gt;|&lt;/code&gt; 연산자는 논리 OR 연산자처럼 작동하여 여러 조건을 결합하고 그 중 하나만 참이어야합니다.</target>
        </trans-unit>
        <trans-unit id="a09b7f6b5364f0ef161e6960eff8ee9e208fb6a3" translate="yes" xml:space="preserve">
          <source>There is always an attachment at GL_COLOR_ATTACHMENT0. Call this function to set up additional attachments at GL_COLOR_ATTACHMENT1, GL_COLOR_ATTACHMENT2, ...</source>
          <target state="translated">GL_COLOR_ATTACHMENT0에는 항상 첨부 파일이 있습니다. GL_COLOR_ATTACHMENT1, GL_COLOR_ATTACHMENT2에서 추가 첨부 파일을 설정하려면이 함수를 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="5a8e71db9a2bb0c45f7fbcdf6ee52417d0aa96ab" translate="yes" xml:space="preserve">
          <source>There is an assumption that the Earth is spherical for the purpose of this calculation.</source>
          <target state="translated">이 계산을 위해 지구가 구형이라고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="4f5903225736b7fc3854ca9f217bccc9e980f286" translate="yes" xml:space="preserve">
          <source>There is an attached &lt;a href=&quot;qml-qtquick-controls-stack#status-attached-prop&quot;&gt;Stack.status&lt;/a&gt; property that tracks the lifecycle. This property is an enumeration with the following values: &lt;code&gt;Stack.Inactive&lt;/code&gt;, &lt;code&gt;Stack.Activating&lt;/code&gt;, &lt;code&gt;Stack.Active&lt;/code&gt; and &lt;code&gt;Stack.Deactivating&lt;/code&gt;. Combined with the normal &lt;code&gt;Component.onComplete&lt;/code&gt; and &lt;code&gt;Component.onDestruction&lt;/code&gt; signals, the entire lifecycle is thus:</source>
          <target state="translated">수명주기를 추적 하는 연결된 &lt;a href=&quot;qml-qtquick-controls-stack#status-attached-prop&quot;&gt;Stack.status&lt;/a&gt; 속성이 있습니다. 이 속성은 &lt;code&gt;Stack.Inactive&lt;/code&gt; , &lt;code&gt;Stack.Activating&lt;/code&gt; , &lt;code&gt;Stack.Active&lt;/code&gt; 및 &lt;code&gt;Stack.Deactivating&lt;/code&gt; 값으로 열거됩니다 . 일반적인 &lt;code&gt;Component.onComplete&lt;/code&gt; 및 &lt;code&gt;Component.onDestruction&lt;/code&gt; 신호 와 결합 하여 전체 수명주기는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ec3d12f9a0d16d1edfe6d0811ff578c50f4bbbe9" translate="yes" xml:space="preserve">
          <source>There is an instance of an anonymous</source>
          <target state="translated">익명의 인스턴스가 있습니다</target>
        </trans-unit>
        <trans-unit id="8d89c31b6d01afeafbd7ec420b85486d0cd5ad5e" translate="yes" xml:space="preserve">
          <source>There is an intersection if any of the lines making up the rectangle crosses a part of the path or if any part of the rectangle overlaps with any area enclosed by the path. This function respects the current &lt;a href=&quot;qpainterpath#fillRule&quot;&gt;fillRule&lt;/a&gt; to determine what is considered inside the path.</source>
          <target state="translated">사각형을 구성하는 선이 경로의 일부를 교차하거나 사각형의 일부가 경로로 둘러싸인 영역과 겹치는 경우 교차점이 있습니다. 이 함수는 현재 &lt;a href=&quot;qpainterpath#fillRule&quot;&gt;fillRule&lt;/a&gt; 을 존중 하여 경로 내부에서 고려할 사항을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="99098fe43e40dfd5b6d755eeeb555c628cfc0741" translate="yes" xml:space="preserve">
          <source>There is another type of &lt;a href=&quot;qml-qtquick3d-custommaterial&quot;&gt;CustomMaterial&lt;/a&gt;: &lt;code&gt;unshaded&lt;/code&gt; custom materials. All the example so far used &lt;code&gt;shaded&lt;/code&gt; custom materials, with the &lt;a href=&quot;qml-qtquick3d-custommaterial#shadingMode-prop&quot;&gt;shadingMode&lt;/a&gt; property left at its default &lt;a href=&quot;qml-qtquick3d-custommaterial&quot;&gt;CustomMaterial&lt;/a&gt;.Shaded value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6f6a17b45dc8a57be94fe29c5798264866f622d" translate="yes" xml:space="preserve">
          <source>There is currently no &lt;a href=&quot;http://www.zeroconf.org/&quot;&gt;zeroconf&lt;/a&gt; facility included in QtRO. All processes or devices must therefore know beforehand how to connect to each other. A &lt;a href=&quot;qremoteobjectregistry&quot;&gt;QRemoteObjectRegistry&lt;/a&gt; (see below) can be used to simplify the connection process for a network with multiple Host Nodes.</source>
          <target state="translated">QtRO에는 현재 &lt;a href=&quot;http://www.zeroconf.org/&quot;&gt;zeroconf&lt;/a&gt; 기능이 없습니다 . 따라서 모든 프로세스 또는 장치는 서로 연결하는 방법을 미리 알고 있어야합니다. &lt;a href=&quot;qremoteobjectregistry&quot;&gt;QRemoteObjectRegistry는&lt;/a&gt; (아래 참조) 여러 호스트 노드가 네트워크에 대한 접속 절차를 간소화 할 수있다.</target>
        </trans-unit>
        <trans-unit id="ca8d4a9276f021ca1573eb59ad1a3cbeb06474b2" translate="yes" xml:space="preserve">
          <source>There is data to be read.</source>
          <target state="translated">읽을 데이터가 있습니다.</target>
        </trans-unit>
        <trans-unit id="08a5b1b2354874dcc73bf5ee6fef417d28248d18" translate="yes" xml:space="preserve">
          <source>There is much more to the &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt; language than we have presented in this short introduction. We will be adding more here in later releases. In the meantime, playing with the &lt;code&gt;xmlpatterns&lt;/code&gt; utility and making modifications to the &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt; examples provided here will be quite informative. An &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt; textbook will be a good investment.</source>
          <target state="translated">이 짧은 소개에서 소개 한 것보다 &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt; 언어 에는 훨씬 더 많은 것이 있습니다. 우리는 이후 릴리스에서 여기에 더 많은 것을 추가 할 것입니다. 그 동안 &lt;code&gt;xmlpatterns&lt;/code&gt; 유틸리티를 사용하고 여기에 제공된 &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt; 예제를 수정하는 것은 매우 유익 할 것입니다. &lt;a href=&quot;xmlprocessing&quot;&gt;는 XQuery&lt;/a&gt; 교과서는 좋은 투자가 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="4fa4c5a28e4f3b13cd9cd641a46c1d60642dba3e" translate="yes" xml:space="preserve">
          <source>There is much more to the &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt; language than we have presented in this short introduction. We will be adding more here in later releases. In the meantime, playing with the &lt;code&gt;xmlpatterns&lt;/code&gt; utility and making modifications to the &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt; examples provided here will be quite informative. An &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt; textbook will be a good investment.</source>
          <target state="translated">이 짧은 소개에서 제시 한 것보다 &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt; 언어 에는 훨씬 더 많은 것이 있습니다. 이후 릴리스에서 여기에 더 추가 할 예정입니다. 그 동안 &lt;code&gt;xmlpatterns&lt;/code&gt; 유틸리티를 사용하고 여기에 제공된 &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt; 예제를 수정하는 것은 매우 유익합니다. &lt;a href=&quot;xmlprocessing#&quot;&gt;는 XQuery&lt;/a&gt; 교과서는 좋은 투자가 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="d8fccc19ec00fffed72316fd525abc81c6783ef4" translate="yes" xml:space="preserve">
          <source>There is no &quot;raw&quot; representation of an event.</source>
          <target state="translated">이벤트의 &quot;원시&quot;표현은 없습니다.</target>
        </trans-unit>
        <trans-unit id="571bcf2093bf0241a3679abd227deb735dc3c365" translate="yes" xml:space="preserve">
          <source>There is no behavior defined for setting an item which is null.</source>
          <target state="translated">null 인 항목을 설정하기 위해 정의 된 동작이 없습니다.</target>
        </trans-unit>
        <trans-unit id="9524dca5a5ae0709d537604c88bc07cd937a6f8a" translate="yes" xml:space="preserve">
          <source>There is no change involved when it comes to feeding values to uniforms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80df523ce3900cccf9424cf45ef3ce83863c3a3c" translate="yes" xml:space="preserve">
          <source>There is no color model, only alpha is used.</source>
          <target state="translated">색상 모델이 없으며 알파 만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f8381b1018d8748c2e0a5605450ea81142d332b4" translate="yes" xml:space="preserve">
          <source>There is no current error.</source>
          <target state="translated">현재 오류가 없습니다.</target>
        </trans-unit>
        <trans-unit id="9fc902def3d5929ac72d572cd72e179f437aaa23" translate="yes" xml:space="preserve">
          <source>There is no default Bluetooth device to perform the service discovery. The model always uses the local default adapter. Specifying a default adapter is not possible. If that's required, &lt;a href=&quot;qbluetoothservicediscoveryagent&quot;&gt;QBluetoothServiceDiscoveryAgent&lt;/a&gt; should be directly used. This value was introduced by Qt 5.4.</source>
          <target state="translated">서비스 검색을 수행 할 기본 Bluetooth 장치가 없습니다. 모델은 항상 로컬 기본 어댑터를 사용합니다. 기본 어댑터를 지정할 수 없습니다. 필요한 경우 &lt;a href=&quot;qbluetoothservicediscoveryagent&quot;&gt;QBluetoothServiceDiscoveryAgent&lt;/a&gt; 를 직접 사용해야합니다. 이 값은 Qt 5.4에 의해 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="b1eb18de13937450e63ca386dfc922a6515bf8a0" translate="yes" xml:space="preserve">
          <source>There is no default text.</source>
          <target state="translated">기본 텍스트가 없습니다.</target>
        </trans-unit>
        <trans-unit id="fbfd10e8333aa3b989a7b2b5ac5050716c9e7321" translate="yes" xml:space="preserve">
          <source>There is no default title text.</source>
          <target state="translated">기본 제목 텍스트가 없습니다.</target>
        </trans-unit>
        <trans-unit id="f5bdd89928e4e4482ae82a2904787c2535b695be" translate="yes" xml:space="preserve">
          <source>There is no default value.</source>
          <target state="translated">기본값은 없습니다.</target>
        </trans-unit>
        <trans-unit id="a76db881a6c674fbc116b40a4dddb03df223e27e" translate="yes" xml:space="preserve">
          <source>There is no detailed tutorial documentation for writing QPA plugins at this time. However, there are two minimal plugins shipped with Qt 5 for testing and other special purposes that you can use as examples:</source>
          <target state="translated">현재 QPA 플러그인 작성에 대한 자세한 자습서 문서는 없습니다. 그러나 테스트를 위해 Qt 5와 함께 제공되는 두 개의 최소 플러그인과 예제로 사용할 수있는 기타 특수 목적이 있습니다.</target>
        </trans-unit>
        <trans-unit id="61f9502518916312fb828bbd3ebea71d0e30ca93" translate="yes" xml:space="preserve">
          <source>There is no detailed tutorial documentation for writing QPA plugins at this time. However, there are two minimal plugins shipped with Qt for testing and other special purposes that you can use as examples:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30bcb6499b659f449042d7d624339e028c4a503a" translate="yes" xml:space="preserve">
          <source>There is no difference between horizontal and vertical spacing inserted between items, so any additional space must be added within the items themselves.</source>
          <target state="translated">항목 사이에 삽입 된 가로 및 세로 간격에는 차이가 없으므로 항목 자체 내에 추가 공간을 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="80fa486a5d0467d629c0969041cdea62c9e7beaf" translate="yes" xml:space="preserve">
          <source>There is no direct way of changing an item's key through an iterator, although it can be done by calling &lt;a href=&quot;qcbormap#erase&quot;&gt;QCborMap::erase&lt;/a&gt;() followed by &lt;a href=&quot;qcbormap#insert&quot;&gt;QCborMap::insert&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qcbormap#erase&quot;&gt;QCborMap :: erase&lt;/a&gt; () 다음에 &lt;a href=&quot;qcbormap#insert&quot;&gt;QCborMap :: insert&lt;/a&gt; () 를 호출하여 반복자를 통해 항목 키를 변경하는 직접적인 방법은 없습니다 .</target>
        </trans-unit>
        <trans-unit id="697065ae7b1aa2661ab1e7068ef9300d7f73c68b" translate="yes" xml:space="preserve">
          <source>There is no direct way of changing an item's key through an iterator, although it can be done by calling &lt;a href=&quot;qhash#erase&quot;&gt;QHash::erase&lt;/a&gt;() followed by &lt;a href=&quot;qhash#insert&quot;&gt;QHash::insert&lt;/a&gt;() or &lt;a href=&quot;qhash#insertMulti&quot;&gt;QHash::insertMulti&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qhash#erase&quot;&gt;QHash :: erase&lt;/a&gt; () 다음에 &lt;a href=&quot;qhash#insert&quot;&gt;QHash :: insert&lt;/a&gt; () 또는 &lt;a href=&quot;qhash#insertMulti&quot;&gt;QHash :: insertMulti&lt;/a&gt; () 를 호출하여 수행 할 수 있지만 반복자를 통해 항목 키를 직접 변경하는 방법은 없습니다 .</target>
        </trans-unit>
        <trans-unit id="cacf78d3db043235851270d8848d2f5b2b19e310" translate="yes" xml:space="preserve">
          <source>There is no direct way of changing an item's key through an iterator, although it can be done by calling &lt;a href=&quot;qhash#erase&quot;&gt;QHash::erase&lt;/a&gt;() followed by &lt;a href=&quot;qhash#insert&quot;&gt;QHash::insert&lt;/a&gt;().</source>
          <target state="translated">반복자를 통해 항목의 키를 변경하는 직접적인 방법은 없지만 &lt;a href=&quot;qhash#erase&quot;&gt;QHash :: erase&lt;/a&gt; () 다음에 &lt;a href=&quot;qhash#insert&quot;&gt;QHash :: insert&lt;/a&gt; () 를 호출하여 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="57e6903b15a46ae9f5ea86b8e5e1fc3945500089" translate="yes" xml:space="preserve">
          <source>There is no direct way of changing an item's key through an iterator, although it can be done by calling &lt;a href=&quot;qjsonobject#erase&quot;&gt;QJsonObject::erase&lt;/a&gt;() followed by &lt;a href=&quot;qjsonobject#insert&quot;&gt;QJsonObject::insert&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qjsonobject#erase&quot;&gt;QJsonObject :: erase&lt;/a&gt; ()와 &lt;a href=&quot;qjsonobject#insert&quot;&gt;QJsonObject :: insert&lt;/a&gt; ()를 차례로 호출하여 반복자를 통해 항목 키를 직접 변경할 수있는 방법은 없습니다 .</target>
        </trans-unit>
        <trans-unit id="cb36b60408c9f8520843edffa1ecb59c14887ce3" translate="yes" xml:space="preserve">
          <source>There is no direct way of changing an item's key through an iterator, although it can be done by calling &lt;a href=&quot;qmap#erase&quot;&gt;QMap::erase&lt;/a&gt;() followed by &lt;a href=&quot;qmap#insert&quot;&gt;QMap::insert&lt;/a&gt;() or &lt;a href=&quot;qmap#insertMulti&quot;&gt;QMap::insertMulti&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qmap#erase&quot;&gt;QMap :: erase&lt;/a&gt; () 다음에 &lt;a href=&quot;qmap#insert&quot;&gt;QMap :: insert&lt;/a&gt; () 또는 &lt;a href=&quot;qmap#insertMulti&quot;&gt;QMap :: insertMulti&lt;/a&gt; () 를 호출하여 수행 할 수 있지만 반복자를 통해 항목 키를 변경하는 직접적인 방법은 없습니다 .</target>
        </trans-unit>
        <trans-unit id="faf23c3a9a6544012bc6674eb86aaae2dda3817b" translate="yes" xml:space="preserve">
          <source>There is no direct way of changing an item's key through an iterator, although it can be done by calling &lt;a href=&quot;qmap#erase&quot;&gt;QMap::erase&lt;/a&gt;() followed by &lt;a href=&quot;qmap#insert&quot;&gt;QMap::insert&lt;/a&gt;() or QMap::insertMulti().</source>
          <target state="translated">반복기를 통해 항목의 키를 변경하는 직접적인 방법은 없지만 &lt;a href=&quot;qmap#erase&quot;&gt;QMap :: erase&lt;/a&gt; () 다음에 &lt;a href=&quot;qmap#insert&quot;&gt;QMap :: insert&lt;/a&gt; () 또는 QMap :: insertMulti () 를 호출하여 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="96052a23a4fc81fa2957c870da68712814b7c307" translate="yes" xml:space="preserve">
          <source>There is no direct way of changing an item's key through an iterator, although it can be done by calling &lt;a href=&quot;qmap#erase&quot;&gt;QMap::erase&lt;/a&gt;() followed by &lt;a href=&quot;qmap#insert&quot;&gt;QMap::insert&lt;/a&gt;().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0c04c3c511f4e9da344caddb9a3aad05ef27d24" translate="yes" xml:space="preserve">
          <source>There is no direct way of changing an item's key through an iterator, although it can be done by calling &lt;a href=&quot;qmultimap#erase&quot;&gt;QMultiMap::erase&lt;/a&gt;() followed by &lt;a href=&quot;qmultimap#insert&quot;&gt;QMultiMap::insert&lt;/a&gt;().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af663f8a7330dc1eb981196bd20153c91a1f6813" translate="yes" xml:space="preserve">
          <source>There is no direct way of changing an item's key through an iterator, although it can be done by calling QMultiHash::erase() followed by &lt;a href=&quot;qmultihash#insert&quot;&gt;QMultiHash::insert&lt;/a&gt;().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f36dd4bd9d545081d829c3a446407803d572930a" translate="yes" xml:space="preserve">
          <source>There is no direct way to do wildcard matching in &lt;a href=&quot;qregularexpression&quot;&gt;QRegularExpression&lt;/a&gt;. However, the &lt;a href=&quot;qregularexpression#wildcardToRegularExpression&quot;&gt;wildcardToRegularExpression&lt;/a&gt; method is provided to translate glob patterns into a Perl-compatible regular expression that can be used for that purpose.</source>
          <target state="translated">&lt;a href=&quot;qregularexpression&quot;&gt;QRegularExpression&lt;/a&gt; 에는 와일드 카드 일치를 직접 수행 할 수있는 방법이 없습니다 . 그러나 &lt;a href=&quot;qregularexpression#wildcardToRegularExpression&quot;&gt;와일드 카드 ToRegularExpression&lt;/a&gt; 메소드는 glob 패턴을 해당 목적에 사용할 수있는 Perl 호환 정규식으로 변환하기 위해 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="5b6e2a4da02a611820c623409a082f84f269a4c1" translate="yes" xml:space="preserve">
          <source>There is no direct way to do wildcard matching in &lt;a href=&quot;qtcore-changes-qt6#qregularexpression&quot;&gt;QRegularExpression&lt;/a&gt;. However, the &lt;a href=&quot;qregularexpression#wildcardToRegularExpression&quot;&gt;QRegularExpression::wildcardToRegularExpression&lt;/a&gt; method is provided to translate glob patterns into a Perl-compatible regular expression that can be used for that purpose.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2ae45087c81959b79487f542414464aec49fe8e" translate="yes" xml:space="preserve">
          <source>There is no direct way to do wildcard matching in &lt;a href=&quot;qtcore-changes-qt6#qregularexpression&quot;&gt;QRegularExpression&lt;/a&gt;. However, the wildcardToRegularExpression method is provided to translate glob patterns into a Perl-compatible regular expression that can be used for that purpose.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93c95c339c85d432ce9591a579ced7f7151eb17f" translate="yes" xml:space="preserve">
          <source>There is no direct way to do wildcard matching in QRegularExpression. However, the &lt;a href=&quot;qregularexpression#wildcardToRegularExpression&quot;&gt;wildcardToRegularExpression&lt;/a&gt; method is provided to translate glob patterns into a Perl-compatible regular expression that can be used for that purpose.</source>
          <target state="translated">QRegularExpression에서 와일드 카드 일치를 수행하는 직접적인 방법은 없습니다. 그러나 &lt;a href=&quot;qregularexpression#wildcardToRegularExpression&quot;&gt;wildcardToRegularExpression&lt;/a&gt; 메서드는 glob 패턴을 해당 목적에 사용할 수있는 Perl 호환 정규식으로 변환하기 위해 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="6c1c9d886b36571844de565fe60cab20ecac692e" translate="yes" xml:space="preserve">
          <source>There is no direction associated with the instruction text.</source>
          <target state="translated">지시 텍스트와 관련된 지시는 없습니다.</target>
        </trans-unit>
        <trans-unit id="42e8b9554d36c6887e7164904248df1d36b02378" translate="yes" xml:space="preserve">
          <source>There is no explicit size restriction on an offset from UTC, but there is an implicit limit imposed when using the &lt;a href=&quot;qdatetime#toString&quot;&gt;toString&lt;/a&gt;() and &lt;a href=&quot;qdatetime#fromString&quot;&gt;fromString&lt;/a&gt;() methods which use a [+|-]hh:mm format, effectively limiting the range to +/- 99 hours and 59 minutes and whole minutes only. Note that currently no time zone lies outside the range of +/- 14 hours.</source>
          <target state="translated">UTC로부터의 오프셋에 대한 명시적인 크기 제한은 없지만 [+ |-] hh : mm 형식을 사용하는 &lt;a href=&quot;qdatetime#toString&quot;&gt;toString&lt;/a&gt; () 및 &lt;a href=&quot;qdatetime#fromString&quot;&gt;fromString&lt;/a&gt; () 메서드를 사용할 때 적용되는 암시 적 제한은 사실상 + /로 범위를 제한합니다. -99 시간 59 분 및 전체 분만. 현재 시간대는 +/- 14 시간 범위 밖에 없습니다.</target>
        </trans-unit>
        <trans-unit id="33c381378063df2cd2e04373a23a8e0d5a6d87a5" translate="yes" xml:space="preserve">
          <source>There is no minimum or maximum angle for this property, but the default style only supports angles whose absolute range is less than or equal to &lt;code&gt;360&lt;/code&gt; degrees. This is because ranges higher than &lt;code&gt;360&lt;/code&gt; degrees will cause the tickmarks and labels to overlap each other.</source>
          <target state="translated">이 속성에는 최소 또는 최대 각도가 없지만 기본 스타일은 절대 범위가 &lt;code&gt;360&lt;/code&gt; 도 이하인 각도 만 지원합니다 . &lt;code&gt;360&lt;/code&gt; 도보 다 높은 범위 는 눈금과 레이블이 서로 겹치게하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="781595d0468bfc3bfecf44000d66082ec451e59f" translate="yes" xml:space="preserve">
          <source>There is no need to call &lt;a href=&quot;qopenglwidget#makeCurrent&quot;&gt;makeCurrent&lt;/a&gt;() because this has already been done when this function is called.</source>
          <target state="translated">이 함수가 호출 될 때 이미 수행되었으므로 &lt;a href=&quot;qopenglwidget#makeCurrent&quot;&gt;makeCurrent&lt;/a&gt; () 를 호출 할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="191901b693603f999c40cf71e2401b8a6e4e805d" translate="yes" xml:space="preserve">
          <source>There is no need to call &lt;a href=&quot;qopenglwidget#makeCurrent&quot;&gt;makeCurrent&lt;/a&gt;() because this has already been done when this function is called. Additionally, the framebuffer is also bound.</source>
          <target state="translated">이 함수가 호출 될 때 이미 수행되었으므로 &lt;a href=&quot;qopenglwidget#makeCurrent&quot;&gt;makeCurrent&lt;/a&gt; () 를 호출 할 필요가 없습니다 . 또한 프레임 버퍼도 바인딩됩니다.</target>
        </trans-unit>
        <trans-unit id="1d213bd05de130f9b11211b11288ec9f40cd4ab5" translate="yes" xml:space="preserve">
          <source>There is no need to call &lt;a href=&quot;qopenglwidget#makeCurrent&quot;&gt;makeCurrent&lt;/a&gt;() because this has already been done when this function is called. Note however that the framebuffer is not yet available at this stage, so avoid issuing draw calls from here. Defer such calls to &lt;a href=&quot;qopenglwidget#paintGL&quot;&gt;paintGL&lt;/a&gt;() instead.</source>
          <target state="translated">이 함수가 호출 될 때 이미 수행되었으므로 &lt;a href=&quot;qopenglwidget#makeCurrent&quot;&gt;makeCurrent&lt;/a&gt; () 를 호출 할 필요가 없습니다 . 그러나이 단계에서는 아직 프레임 버퍼를 사용할 수 없으므로 여기에서 드로우 콜을 발행하지 마십시오. &lt;a href=&quot;qopenglwidget#paintGL&quot;&gt;paintGL&lt;/a&gt; ()에 대한 호출을 대신 연기하십시오 .</target>
        </trans-unit>
        <trans-unit id="fda2a892158f852497393e4691565de703d47448" translate="yes" xml:space="preserve">
          <source>There is no need to call &lt;a href=&quot;qopenglwindow#makeCurrent&quot;&gt;makeCurrent&lt;/a&gt;() because this has already been done when this function is called.</source>
          <target state="translated">이 함수가 호출 될 때 이미 수행되었으므로 &lt;a href=&quot;qopenglwindow#makeCurrent&quot;&gt;makeCurrent&lt;/a&gt; () 를 호출 할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="36040aa053e65bfdf61dc685961c28d7aacc0e9b" translate="yes" xml:space="preserve">
          <source>There is no need to call &lt;a href=&quot;qopenglwindow#makeCurrent&quot;&gt;makeCurrent&lt;/a&gt;() because this has already been done when this function is called. Note however that the framebuffer, in case partial update mode is used, is not yet available at this stage, so avoid issuing draw calls from here. Defer such calls to &lt;a href=&quot;qopenglwindow#paintGL&quot;&gt;paintGL&lt;/a&gt;() instead.</source>
          <target state="translated">이 함수가 호출 될 때 이미 수행되었으므로 &lt;a href=&quot;qopenglwindow#makeCurrent&quot;&gt;makeCurrent&lt;/a&gt; () 를 호출 할 필요가 없습니다 . 그러나 부분 업데이트 모드를 사용하는 경우이 단계에서는 아직 프레임 버퍼를 사용할 수 없으므로 여기서는 드로우 콜을 발행하지 마십시오. &lt;a href=&quot;qopenglwindow#paintGL&quot;&gt;paintGL&lt;/a&gt; ()에 대한 호출을 대신 연기하십시오 .</target>
        </trans-unit>
        <trans-unit id="2f108aa2a1dff31922661f66df1bc2fbc7681f3d" translate="yes" xml:space="preserve">
          <source>There is no need to call this before destroying the &lt;a href=&quot;qvulkaninstance&quot;&gt;QVulkanInstance&lt;/a&gt; since clean up is then performed automatically.</source>
          <target state="translated">정리가 자동으로 수행되기 때문에 &lt;a href=&quot;qvulkaninstance&quot;&gt;QVulkanInstance를&lt;/a&gt; 제거 하기 전에 이것을 호출 할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="4a5fe31c5c8f49ca71364259bddc3647e2b28009" translate="yes" xml:space="preserve">
          <source>There is no need to lay out a menu bar. It automatically sets its own geometry to the top of the parent widget and changes it appropriately whenever the parent is resized.</source>
          <target state="translated">메뉴 막대를 배치 할 필요가 없습니다. 자체 위젯을 상위 위젯의 맨 위에 자동으로 설정하고 상위 크기를 조정할 때마다 적절하게 변경합니다.</target>
        </trans-unit>
        <trans-unit id="182f02c34cf1d7ab591584a4ae0d499767ae8b74" translate="yes" xml:space="preserve">
          <source>There is no opacity mask by default.</source>
          <target state="translated">기본적으로 불투명 마스크는 없습니다.</target>
        </trans-unit>
        <trans-unit id="1a0fd8ccf10181605405f1b49ef4caf432e79452" translate="yes" xml:space="preserve">
          <source>There is no radio service available.</source>
          <target state="translated">사용 가능한 라디오 서비스가 없습니다.</target>
        </trans-unit>
        <trans-unit id="77bea4b42aab28d26883a18291422b5d3334a497" translate="yes" xml:space="preserve">
          <source>There is no recommended action to be performed.</source>
          <target state="translated">수행 할 권장 조치가 없습니다.</target>
        </trans-unit>
        <trans-unit id="47e4089237f0009b70b3cd4eb2bf3446158ecc25" translate="yes" xml:space="preserve">
          <source>There is no replacement for the &lt;a href=&quot;qregexp#CaretMode-enum&quot;&gt;CaretMode&lt;/a&gt; enumeration. The &lt;a href=&quot;qregularexpression#MatchOption-enum&quot;&gt;QRegularExpression::AnchoredMatchOption&lt;/a&gt; match option can be used to emulate the &lt;a href=&quot;qregexp#CaretMode-enum&quot;&gt;QRegExp::CaretAtOffset&lt;/a&gt; behavior. There is no equivalent for the other &lt;a href=&quot;qregexp#CaretMode-enum&quot;&gt;QRegExp::CaretMode&lt;/a&gt; modes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bda0b702dc431c4b46e9b637f032ac0a1c5fa64" translate="yes" xml:space="preserve">
          <source>There is no risk of deadlocks when using the event system for thread synchronization, unlike using low-level primitives. However, the event system does not enforce mutual exclusion. If invokable methods access shared data, they must still be protected with low-level primitives.</source>
          <target state="translated">저수준 기본 요소를 사용하는 것과 달리 스레드 동기화에 이벤트 시스템을 사용할 때 교착 상태의 위험이 없습니다. 그러나 이벤트 시스템은 상호 배제를 강요하지 않습니다. 호출 가능한 메소드가 공유 데이터에 액세스하는 경우 여전히 하위 레벨 기본 요소로 보호되어야합니다.</target>
        </trans-unit>
        <trans-unit id="da7a58b8f1d88d956e4bd1d1237cfb34a7aaeb5b" translate="yes" xml:space="preserve">
          <source>There is no service available to provide the requested functionality.</source>
          <target state="translated">요청한 기능을 제공하는 데 사용할 수있는 서비스가 없습니다.</target>
        </trans-unit>
        <trans-unit id="8181b0a0708e2a42ba9fc85c858a02e1adb77ba7" translate="yes" xml:space="preserve">
          <source>There is no setter for the node model because instances of &lt;a href=&quot;qxmlnodemodelindex&quot;&gt;QXmlNodeModelIndex&lt;/a&gt; instances are only created with &lt;a href=&quot;qabstractxmlnodemodel#createIndex&quot;&gt;QAbstractXmlNodeModel::createIndex&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qxmlnodemodelindex&quot;&gt;QXmlNodeModelIndex&lt;/a&gt; 인스턴스의 인스턴스는 &lt;a href=&quot;qabstractxmlnodemodel#createIndex&quot;&gt;QAbstractXmlNodeModel :: createIndex&lt;/a&gt; () 로만 작성 되므로 노드 모델에 대한 세터가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="1f82515f78da3bd7f1b9e44216f514516fee3ef0" translate="yes" xml:space="preserve">
          <source>There is no single correct 3D coordinate to match a particular screen position, so to be consistent, the queries are always done against the inner sides of an invisible box surrounding the graph.</source>
          <target state="translated">특정 화면 위치와 일치하는 올바른 3D 좌표가 하나도 없으므로 일관성을 유지하기 위해 쿼리는 항상 그래프를 둘러싼 보이지 않는 상자의 안쪽에 대해 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="bbbd18421c2e5a9fcf43e13a867a61ae0c37e9d6" translate="yes" xml:space="preserve">
          <source>There is no such file to load into the default XML node model, but one can write a subclass of &lt;a href=&quot;qabstractxmlnodemodel&quot;&gt;QAbstractXmlNodeModel&lt;/a&gt; to represent the file system. This custom XML node model, once populated with all the directory and file descriptors obtained directly from the system, presents the complete file system hierarchy to the query engine via the same API used by the default XML node model to present the contents of an XML file. In other words, once the custom XML node model is populated, it presents the file system to the query engine as if a description of it had been loaded into the default XML node model from an XML file like the one shown above.</source>
          <target state="translated">기본 XML 노드 모델로로드 할 파일은 없지만 &lt;a href=&quot;qabstractxmlnodemodel&quot;&gt;QAbstractXmlNodeModel&lt;/a&gt; 의 서브 클래스를 작성 하여 파일 시스템을 나타낼 수 있습니다. 시스템에서 직접 얻은 모든 디렉토리 및 파일 디스크립터로 채워진이 사용자 정의 XML 노드 모델은 XML 파일의 내용을 표시하기 위해 기본 XML 노드 모델에서 사용하는 것과 동일한 API를 통해 전체 파일 시스템 계층을 쿼리 엔진에 제공합니다. . 다시 말해, 사용자 정의 XML 노드 모델이 채워지면 파일 시스템에 대한 설명이 위에 표시된 것과 같은 XML 파일에서 기본 XML 노드 모델로로드 된 것처럼 쿼리 엔진에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="f08ddd396cac5da789e55fcb21f3cecb40e952ab" translate="yes" xml:space="preserve">
          <source>There is no support for describing YUV's macro pixels. Instead a list of YUV formats has been made. When a &lt;a href=&quot;qpixelformat&quot;&gt;QPixelFormat&lt;/a&gt; is describing a YUV format, the &lt;a href=&quot;qpixelformat#bitsPerPixel&quot;&gt;bitsPerPixel&lt;/a&gt; value has been deduced by the YUV Layout enum. Also, the color channels should all be set to zero except the fifth color channel that should store the &lt;a href=&quot;qpixelformat#bitsPerPixel&quot;&gt;bitsPerPixel&lt;/a&gt; value.</source>
          <target state="translated">YUV의 매크로 픽셀을 설명 할 수는 없습니다. 대신 YUV 형식 목록이 작성되었습니다. &lt;a href=&quot;qpixelformat&quot;&gt;QPixelFormat&lt;/a&gt; 이 YUV 형식을 설명 할 때 &lt;a href=&quot;qpixelformat#bitsPerPixel&quot;&gt;bitsPerPixel&lt;/a&gt; 값은 YUV Layout 열거에 의해 추론되었습니다. 또한 &lt;a href=&quot;qpixelformat#bitsPerPixel&quot;&gt;bitsPerPixel&lt;/a&gt; 값을 저장해야하는 다섯 번째 색상 채널을 제외하고 색상 채널을 모두 0으로 설정해야 합니다.</target>
        </trans-unit>
        <trans-unit id="c3ee1ec8f75792d57d1ad69b8fee175d6b8ecc45" translate="yes" xml:space="preserve">
          <source>There is no support for describing YUV's macro pixels. Instead a list of YUV formats has been made. When a QPixelFormat is describing a YUV format, the &lt;a href=&quot;qpixelformat#bitsPerPixel&quot;&gt;bitsPerPixel&lt;/a&gt; value has been deduced by the YUV Layout enum. Also, the color channels should all be set to zero except the fifth color channel that should store the &lt;a href=&quot;qpixelformat#bitsPerPixel&quot;&gt;bitsPerPixel&lt;/a&gt; value.</source>
          <target state="translated">YUV의 매크로 픽셀을 설명하기위한 지원이 없습니다. 대신 YUV 형식 목록이 작성되었습니다. QPixelFormat이 YUV 형식을 설명 할 때 &lt;a href=&quot;qpixelformat#bitsPerPixel&quot;&gt;bitsPerPixel&lt;/a&gt; 값은 YUV 레이아웃 열거 형에 의해 추론됩니다. 또한 색상 채널은 &lt;a href=&quot;qpixelformat#bitsPerPixel&quot;&gt;bitsPerPixel&lt;/a&gt; 값을 저장해야하는 다섯 번째 색상 채널을 제외하고 모두 0으로 설정해야 합니다.</target>
        </trans-unit>
        <trans-unit id="c290218400895d51dc525b9e11d3c133229375ea" translate="yes" xml:space="preserve">
          <source>There is no year 0. Dates in that year are considered invalid. The year -1 is the year &quot;1 before Christ&quot; or &quot;1 before current era.&quot; The day before 1 January 1 CE is 31 December 1 BCE.</source>
          <target state="translated">0 년이 없습니다. 해당 연도의 날짜는 유효하지 않은 것으로 간주됩니다. -1 년은 &quot;그리스도 이전의 1 년&quot;또는 &quot;현재 시대 이전의 1 년&quot;입니다. CE 1 월 1 일 전날은 BCE 12 월 31 일입니다.</target>
        </trans-unit>
        <trans-unit id="8b4b7d4b2cce871be175e6550e1a35b3dba78490" translate="yes" xml:space="preserve">
          <source>There is no year 0. Dates in that year are considered invalid. The year -1 is the year &quot;1 before Christ&quot; or &quot;1 before current era.&quot; The day before 1 January 1 CE, &lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt;(1, 1, 1), is 31 December 1 BCE, &lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt;(-1, 12, 31).</source>
          <target state="translated">0 년이 없습니다. 해당 연도의 날짜는 유효하지 않은 것으로 간주됩니다. -1 년은 &quot;그리스도 이전의 1 년&quot;또는 &quot;현재 시대 이전의 1 년&quot;입니다. &lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt; (1, 1, 1) CE 1 월 1 일 전날은 QDate (12 월 1 일) &lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt; (-1, 12, 31)입니다.</target>
        </trans-unit>
        <trans-unit id="7a09bfd2547c985b82c56e455c40cc0376dfa841" translate="yes" xml:space="preserve">
          <source>There is nothing stopping you from using values for the additiveFacor property outside the 0 to 1 range, but please be aware that the input animation clips may not be authored in such a way for this to make sense.</source>
          <target state="translated">0에서 1까지의 범위를 벗어나면 additiveFacor 속성 값을 사용하는 데 방해가되지 않지만 입력 애니메이션 클립은 이러한 방식으로 제작되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8cd1cb7db3a684105a019d00f36b786eda6256be" translate="yes" xml:space="preserve">
          <source>There is nothing wrong with either of these string constructions, but there are a few hidden inefficiencies. Beginning with Qt 4.6, you can eliminate them.</source>
          <target state="translated">이러한 문자열 구성 중 하나에는 아무런 문제가 없지만 숨겨진 비효율이 있습니다. Qt 4.6부터는 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf6cc282002aa6e4955eab1536b3458fb9864cf9" translate="yes" xml:space="preserve">
          <source>There is one bug that is so common that it deserves mention here: If you include the &lt;a href=&quot;qobject#Q_OBJECT&quot;&gt;Q_OBJECT&lt;/a&gt; macro in a class declaration and run &lt;a href=&quot;moc&quot;&gt;the meta-object compiler&lt;/a&gt; (&lt;code&gt;moc&lt;/code&gt;), but forget to link the &lt;code&gt;moc&lt;/code&gt;-generated object code into your executable, you will get very confusing error messages. Any link error complaining about a lack of &lt;code&gt;vtbl&lt;/code&gt;, &lt;code&gt;_vtbl&lt;/code&gt;, &lt;code&gt;__vtbl&lt;/code&gt; or similar is likely to be a result of this problem.</source>
          <target state="translated">여기에 언급 할 가치가있는 버그가 하나 있습니다. 클래스 선언에 &lt;a href=&quot;qobject#Q_OBJECT&quot;&gt;Q_OBJECT&lt;/a&gt; 매크로 를 포함 &lt;a href=&quot;moc&quot;&gt;하고 메타 개체 컴파일러&lt;/a&gt; ( &lt;code&gt;moc&lt;/code&gt; )를 실행하지만 &lt;code&gt;moc&lt;/code&gt; 생성 개체 코드를 실행 파일 에 연결하는 것을 잊은 경우 매우 혼란스러운 오류 메시지가 표시됩니다. &lt;code&gt;vtbl&lt;/code&gt; , &lt;code&gt;_vtbl&lt;/code&gt; , &lt;code&gt;__vtbl&lt;/code&gt; 또는 이와 유사한 것의 부족에 대해 불평하는 모든 링크 오류 는이 문제의 결과 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fdd670fd14a54fbbdbcb0267744caf09c9c05784" translate="yes" xml:space="preserve">
          <source>There is one bug that is so common that it deserves mention here: If you include the &lt;a href=&quot;qobject#Q_OBJECT&quot;&gt;Q_OBJECT&lt;/a&gt; macro in a class declaration and run &lt;a href=&quot;moc#&quot;&gt;the meta-object compiler&lt;/a&gt; (&lt;code&gt;moc&lt;/code&gt;), but forget to link the &lt;code&gt;moc&lt;/code&gt;-generated object code into your executable, you will get very confusing error messages. Any link error complaining about a lack of &lt;code&gt;vtbl&lt;/code&gt;, &lt;code&gt;_vtbl&lt;/code&gt;, &lt;code&gt;__vtbl&lt;/code&gt; or similar is likely to be a result of this problem.</source>
          <target state="translated">클래스 선언에 &lt;a href=&quot;qobject#Q_OBJECT&quot;&gt;Q_OBJECT&lt;/a&gt; 매크로 를 포함 &lt;a href=&quot;moc#&quot;&gt;하고 메타 객체 컴파일러&lt;/a&gt; ( &lt;code&gt;moc&lt;/code&gt; )를 실행하지만 &lt;code&gt;moc&lt;/code&gt; 생성 객체 코드를 실행 파일 에 연결하는 것을 잊어 버린 경우에는 여기에 언급 할만한 일반적인 버그가 있습니다. 매우 혼란스러운 오류 메시지가 나타납니다. &lt;code&gt;vtbl&lt;/code&gt; , &lt;code&gt;_vtbl&lt;/code&gt; , &lt;code&gt;__vtbl&lt;/code&gt; 또는 이와 유사한 기능이 없다고 불평하는 링크 오류 는이 문제의 결과 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7fef9246ab47b863f507ede160507bc229886459" translate="yes" xml:space="preserve">
          <source>There is one built-in custom geometry implementation: the &lt;a href=&quot;https://doc.qt.io/qt-6.0/qtquick3d-qmlmodule.html&quot;&gt;QtQuick3D&lt;/a&gt;.Helpers module includes a &lt;a href=&quot;qml-qtquick3d-helpers-gridgeometry&quot;&gt;GridGeometry&lt;/a&gt; type. This allows rendering a grid in the scene with line primitives, without having to implement a custom &lt;a href=&quot;qquick3dgeometry&quot;&gt;QQuick3DGeometry&lt;/a&gt; subclass.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca1cb5fae9c8ed9feef9b8164149c8bb9184e2a9" translate="yes" xml:space="preserve">
          <source>There is one or more resources missing, so the media player cannot be used. It may be possible to try again at a later time.</source>
          <target state="translated">누락 된 리소스가 하나 이상 있으므로 미디어 플레이어를 사용할 수 없습니다. 나중에 다시 시도 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2fc0da852ecf29b4b0fecfd929dd24a46baea087" translate="yes" xml:space="preserve">
          <source>There is one or more resources missing, so the radio cannot be used. It may be possible to try again at a later time.</source>
          <target state="translated">하나 이상의 리소스가 누락되어 라디오를 사용할 수 없습니다. 나중에 다시 시도 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="754d0b06837f4a776f4063562284d09de93c56cf" translate="yes" xml:space="preserve">
          <source>There is one or more resources missing, so the radio cannot be used. It may be possible to try again at a later time. This can occur if there is no antenna connected - see the &lt;a href=&quot;qml-qtmultimedia-radio#antennaConnected-prop&quot;&gt;antennaConnected&lt;/a&gt; property as well.</source>
          <target state="translated">하나 이상의 리소스가 누락되어 라디오를 사용할 수 없습니다. 나중에 다시 시도 할 수 있습니다. 연결된 안테나가없는 경우 발생할 수 있습니다 . &lt;a href=&quot;qml-qtmultimedia-radio#antennaConnected-prop&quot;&gt;antennaConnected&lt;/a&gt; 속성도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="375d543648116f32a41a92c3ae61758e7e9873dc" translate="yes" xml:space="preserve">
          <source>There is one or more resources missing, so the video player cannot be used. It may be possible to try again at a later time.</source>
          <target state="translated">하나 이상의 리소스가 누락되어 비디오 플레이어를 사용할 수 없습니다. 나중에 다시 시도 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="202b838181fe78d36611e4556c120db86d5685ba" translate="yes" xml:space="preserve">
          <source>There is only one tab in the toolbox.</source>
          <target state="translated">도구 상자에는 하나의 탭만 있습니다.</target>
        </trans-unit>
        <trans-unit id="6bd9efbbb3eb24869e2de1578d00494df11080d9" translate="yes" xml:space="preserve">
          <source>There is only one toolbar or line. This is the default value of the &lt;a href=&quot;qstyleoptiontoolbar#positionOfLine-var&quot;&gt;positionOfLine&lt;/a&gt; and &lt;a href=&quot;qstyleoptiontoolbar#positionWithinLine-var&quot;&gt;positionWithinLine&lt;/a&gt; variables.</source>
          <target state="translated">도구 모음이나 선이 하나만 있습니다. 이것이 &lt;a href=&quot;qstyleoptiontoolbar#positionOfLine-var&quot;&gt;positionOfLine&lt;/a&gt; 및 &lt;a href=&quot;qstyleoptiontoolbar#positionWithinLine-var&quot;&gt;positionWithinLine&lt;/a&gt; 변수 의 기본값 입니다.</target>
        </trans-unit>
        <trans-unit id="c738449aef63a8d2f3ea4e8e3c0b7aad8527533c" translate="yes" xml:space="preserve">
          <source>There is some redundancy between this property and &lt;a href=&quot;qinputdevice#DeviceType-enum&quot;&gt;QInputDevice::DeviceType&lt;/a&gt;. For example, if a touchscreen is used, then the &lt;code&gt;DeviceType&lt;/code&gt; is &lt;code&gt;TouchScreen&lt;/code&gt; and &lt;code&gt;PointerType&lt;/code&gt; is &lt;code&gt;Finger&lt;/code&gt; (always). But on a graphics tablet, it's often possible for both ends of the stylus to be used, and programs need to distinguish them. Therefore the concept is extended so that every &lt;a href=&quot;qpointerevent&quot;&gt;QPointerEvent&lt;/a&gt; has a PointerType, and it can simplify some event handling code to ignore the &lt;a href=&quot;qinputdevice#DeviceType-enum&quot;&gt;DeviceType&lt;/a&gt; and react differently depending on the PointerType alone.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="469730b114844abfabfa8533b4a7f3e2fea4ae06" translate="yes" xml:space="preserve">
          <source>There is some redundancy between this property and &lt;a href=&quot;qml-qtquick-pointerdevice#type-prop&quot;&gt;PointerDevice::type&lt;/a&gt;. If a tocuchscreen is used, then the device is TouchScreen and pointerType is Finger (always).</source>
          <target state="translated">이 속성과 &lt;a href=&quot;qml-qtquick-pointerdevice#type-prop&quot;&gt;PointerDevice :: type&lt;/a&gt; 사이에는 중복성이 있습니다 . tocuchscreen을 사용하는 경우 장치는 TouchScreen이고 pointerType은 Finger (항상)입니다.</target>
        </trans-unit>
        <trans-unit id="a953bca3c757b117863b4d27a7a64cf37e82a705" translate="yes" xml:space="preserve">
          <source>There is support for Android development in Qt 6. With Qt Creator, you can connect to devices, develop, test, and package Android applications.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d92933fe9e8763c9cae0f191c80d4897fa0cc2bf" translate="yes" xml:space="preserve">
          <source>There is support for various Apple mobile devices such as iPad, iPhone, Apple TV, and Apple Watch. Qt Creator supplements &lt;a href=&quot;http://itunes.apple.com/us/app/xcode/id497799835?ls=1&amp;amp;mt=12&quot;&gt;Xcode&lt;/a&gt; for development and deployment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3eb0805ba34ff98a002102b659064848a3c7c453" translate="yes" xml:space="preserve">
          <source>There is typically no need to perform anything special in this function because &lt;a href=&quot;qvulkanwindow&quot;&gt;QVulkanWindow&lt;/a&gt; will automatically retry to initialize itself after a certain amount of time.</source>
          <target state="translated">&lt;a href=&quot;qvulkanwindow&quot;&gt;QVulkanWindow&lt;/a&gt; 는 특정 시간이 지나면 자체 초기화를 자동으로 다시 시도 하므로 일반적 으로이 기능에서 특별한 작업을 수행 할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="823381dd99076924e0cc3ac3637347bb955017a0" translate="yes" xml:space="preserve">
          <source>There is typically no need to perform anything special in this function. &lt;a href=&quot;qvulkanwindow&quot;&gt;QVulkanWindow&lt;/a&gt; will automatically release all resources (invoking &lt;a href=&quot;qvulkanwindowrenderer#releaseSwapChainResources&quot;&gt;releaseSwapChainResources&lt;/a&gt;() and &lt;a href=&quot;qvulkanwindowrenderer#releaseResources&quot;&gt;releaseResources&lt;/a&gt;() as necessary) and will attempt to reinitialize, acquiring a new device. When the physical device was also lost, this reinitialization attempt may then result in &lt;a href=&quot;qvulkanwindowrenderer#physicalDeviceLost&quot;&gt;physicalDeviceLost&lt;/a&gt;().</source>
          <target state="translated">일반적으로이 기능에서 특별한 작업을 수행 할 필요는 없습니다. &lt;a href=&quot;qvulkanwindow&quot;&gt;QVulkanWindow&lt;/a&gt; 는 모든 자원을 자동으로 해제하고 ( 필요에 따라 &lt;a href=&quot;qvulkanwindowrenderer#releaseSwapChainResources&quot;&gt;releaseSwapChainResources&lt;/a&gt; () 및 &lt;a href=&quot;qvulkanwindowrenderer#releaseResources&quot;&gt;releaseResources&lt;/a&gt; () 호출 ) 새 장치를 확보하여 다시 초기화하려고 시도합니다. 물리적 장치도 손실되면이 다시 초기화 시도로 인해 &lt;a href=&quot;qvulkanwindowrenderer#physicalDeviceLost&quot;&gt;physicalDeviceLost&lt;/a&gt; ()가 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1f6debb2bf1cc2fdf9f055f19b4f323bdf7dfdfd" translate="yes" xml:space="preserve">
          <source>There may be artifacts of uninitialized graphics memory on some Qt Quick Controls 2 components, such as checkboxes.</source>
          <target state="translated">일부 Qt Quick Controls 2 구성 요소 (예 : 확인란)에 초기화되지 않은 그래픽 메모리의 아티팩트가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b85812e6193f58b8e906a6fc051fbb728bb6047" translate="yes" xml:space="preserve">
          <source>There may be at most one integer ID for each sender.</source>
          <target state="translated">각 발신자 당 최대 하나의 정수 ID가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="918c84c09fa7f49ca6e9bbcb7ad1af33dee1f530" translate="yes" xml:space="preserve">
          <source>There may be at most one object for each sender.</source>
          <target state="translated">발신자 당 최대 하나의 개체가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="106b415cba3b75c2bb67670a9af77acb21475e41" translate="yes" xml:space="preserve">
          <source>There may be at most one text for each sender.</source>
          <target state="translated">각 발신자마다 최대 하나의 텍스트가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8bccfac83c325255220c7d36a1155dd9997578f" translate="yes" xml:space="preserve">
          <source>There may be at most one widget for each sender.</source>
          <target state="translated">각 발신자마다 최대 하나의 위젯이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7420f20fc59ffbebd3124bf1308aa8c1853171bf" translate="yes" xml:space="preserve">
          <source>There may be more fine-tuning to the QBig5hkscsCodec to maximize its compatibility with the standard Big5 (2002) mapping as determined by Li18nux Big5 Standard Subgroup. See &lt;a href=&quot;http://www.autrijus.org/xml/&quot;&gt;http://www.autrijus.org/xml/&lt;/a&gt; for the various Big5 CharMapML tables.</source>
          <target state="translated">Li18nux Big5 표준 서브 그룹에 의해 결정된 표준 Big5 (2002) 맵핑과의 호환성을 최대화하기 위해 QBig5hkscsCodec에 더 미세한 조정이있을 수 있습니다. 다양한 Big5 CharMapML 테이블에 대해서는 &lt;a href=&quot;http://www.autrijus.org/xml/&quot;&gt;http://www.autrijus.org/xml/&lt;/a&gt; 을 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="330bde8482e24a027a987b02eab98495dc82169e" translate="yes" xml:space="preserve">
          <source>There may be significant variation in the features supported by different providers of routing information, or even in the features supported by the same provider if different levels of authorization are used.</source>
          <target state="translated">서로 다른 라우팅 정보 제공자가 지원하는 기능 또는 다른 권한 부여 레벨이 사용되는 경우 동일한 제공자가 지원하는 기능에는 상당한 차이가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="37dcc66685924b66ffcb2785fc50c4712584dde5" translate="yes" xml:space="preserve">
          <source>There must be at least one row and one column in the table.</source>
          <target state="translated">테이블에 하나 이상의 행과 하나의 열이 있어야합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
