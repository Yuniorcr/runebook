<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="qt">
    <body>
      <group id="qt">
        <trans-unit id="dfa2233d0dab368dd922888b3389cbe7919a3832" translate="yes" xml:space="preserve">
          <source>Appends the string</source>
          <target state="translated">문자열을 추가합니다</target>
        </trans-unit>
        <trans-unit id="1b7866d8f197c27a75e2eb2a0007443ddb1e9bb3" translate="yes" xml:space="preserve">
          <source>Appends the string reference to</source>
          <target state="translated">문자열 참조를 추가합니다</target>
        </trans-unit>
        <trans-unit id="89dc5b9ae7f6b2b56d8e15489912c0b8d02684f2" translate="yes" xml:space="preserve">
          <source>Appends the string section referenced by</source>
          <target state="translated">참조하는 문자열 섹션을 추가합니다</target>
        </trans-unit>
        <trans-unit id="cf92a4c5803ed5ada24e589e6537019eff2409dc" translate="yes" xml:space="preserve">
          <source>Appends the string view</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3922276f2a447219f8bcffbd68984402c6c40c2" translate="yes" xml:space="preserve">
          <source>Appends the text string</source>
          <target state="translated">텍스트 문자열을 추가합니다</target>
        </trans-unit>
        <trans-unit id="fd680954a13e44ffa9519b367d4079ec2686a8d2" translate="yes" xml:space="preserve">
          <source>Apple Icon Image</source>
          <target state="translated">애플 아이콘 이미지</target>
        </trans-unit>
        <trans-unit id="e200660f3a20124c7833ad7dd9bbe7b44c09aa98" translate="yes" xml:space="preserve">
          <source>Apple Platforms</source>
          <target state="translated">애플 플랫폼</target>
        </trans-unit>
        <trans-unit id="320b0241beb9b46b7a905f6bd423eb892a8ab4d2" translate="yes" xml:space="preserve">
          <source>Apple Platforms - iOS, tvOS, and watchOS</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2686709a69821ae6b7fc89091ab7592b473eab26" translate="yes" xml:space="preserve">
          <source>Apple platforms have a built-in way to express the OS versions that an application supports, which allows older versions of the platforms to automatically display a user friendly error message prompting the user to update their OS, as opposed to crashing and displaying a stack trace.</source>
          <target state="translated">Apple 플랫폼에는 응용 프로그램이 지원하는 OS 버전을 표현하는 기본 제공 방법이 있으므로 이전 버전의 플랫폼은 사용자에게 친숙한 오류 메시지를 자동으로 표시하여 사용자에게 OS를 업데이트하라는 메시지를 표시합니다. .</target>
        </trans-unit>
        <trans-unit id="b291beb8793f4f3308c463951165dad483715a6c" translate="yes" xml:space="preserve">
          <source>Application</source>
          <target state="translated">Application</target>
        </trans-unit>
        <trans-unit id="eb6c683f59e1d264268f24340ac89a8532c9ef4f" translate="yes" xml:space="preserve">
          <source>Application Assets</source>
          <target state="translated">응용 프로그램 자산</target>
        </trans-unit>
        <trans-unit id="3925a6e948fb7872d335532f8d20c939d631d4b3" translate="yes" xml:space="preserve">
          <source>Application Identifiers</source>
          <target state="translated">어플리케이션 식별자</target>
        </trans-unit>
        <trans-unit id="7e40172027d30d86e935e6ff42f79ecaa6d203f8" translate="yes" xml:space="preserve">
          <source>Application Main Window</source>
          <target state="translated">응용 프로그램 메인 창</target>
        </trans-unit>
        <trans-unit id="e7323247f5a7af4bbcd10e86002151d0465b9432" translate="yes" xml:space="preserve">
          <source>Application Menu | About &amp;lt;application name&amp;gt;</source>
          <target state="translated">응용 프로그램 메뉴 | &amp;lt;신청 명&amp;gt;에 대해</target>
        </trans-unit>
        <trans-unit id="ed1be79e8ee065a818733b399c26489b5f4f3890" translate="yes" xml:space="preserve">
          <source>Application Menu | Preferences</source>
          <target state="translated">응용 프로그램 메뉴 | 환경 설정</target>
        </trans-unit>
        <trans-unit id="b80be2254170a3f07b62935e4c6b062e51cc4ff4" translate="yes" xml:space="preserve">
          <source>Application Menu | Quit &amp;lt;application name&amp;gt;</source>
          <target state="translated">응용 프로그램 메뉴 | &amp;lt;애플리케이션 이름&amp;gt; 종료</target>
        </trans-unit>
        <trans-unit id="55ff2241133976524c32f4d2feb3fe63e5446b40" translate="yes" xml:space="preserve">
          <source>Application Package</source>
          <target state="translated">응용 프로그램 패키지</target>
        </trans-unit>
        <trans-unit id="26e36eadcb2a449b1f19d57b5ea5d9acbd25dee9" translate="yes" xml:space="preserve">
          <source>Application Window</source>
          <target state="translated">응용 프로그램 창</target>
        </trans-unit>
        <trans-unit id="ec97012deefee9b415f6ac7443c6b16207ccc9b4" translate="yes" xml:space="preserve">
          <source>Application Windows</source>
          <target state="translated">응용 프로그램 창</target>
        </trans-unit>
        <trans-unit id="24b07d4b0e283482066da7b843356ed2ed30e7d9" translate="yes" xml:space="preserve">
          <source>Application and Library Paths</source>
          <target state="translated">응용 프로그램 및 라이브러리 경로</target>
        </trans-unit>
        <trans-unit id="d662d9592fc02d08b355d05e7553efcf33a09cdf" translate="yes" xml:space="preserve">
          <source>Application and user interface components need to communicate with each other. For example, a button needs to know that the user has clicked on it. The button may change colors to indicate its state or perform some logic. As well, application needs to know whether the user is clicking the button. The application may need to relay this clicking event to other applications.</source>
          <target state="translated">응용 프로그램 및 사용자 인터페이스 구성 요소는 서로 통신해야합니다. 예를 들어, 버튼은 사용자가 버튼을 클릭했음을 알아야합니다. 버튼은 상태를 나타내거나 일부 논리를 수행하기 위해 색상이 변경 될 수 있습니다. 또한 응용 프로그램은 사용자가 버튼을 클릭하는지 여부를 알아야합니다. 응용 프로그램은이 클릭 이벤트를 다른 응용 프로그램으로 릴레이해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c9a8864c4e56a9311281082b309aaba577a102c9" translate="yes" xml:space="preserve">
          <source>Application cursors are stored on an internal stack. setOverrideCursor() pushes the cursor onto the stack, and &lt;a href=&quot;qguiapplication#restoreOverrideCursor&quot;&gt;restoreOverrideCursor&lt;/a&gt;() pops the active cursor off the stack. &lt;a href=&quot;qguiapplication#changeOverrideCursor&quot;&gt;changeOverrideCursor&lt;/a&gt;() changes the curently active application override cursor.</source>
          <target state="translated">응용 프로그램 커서는 내부 스택에 저장됩니다. setOverrideCursor ()는 커서를 스택으로 푸시하고 &lt;a href=&quot;qguiapplication#restoreOverrideCursor&quot;&gt;restoreOverrideCursor&lt;/a&gt; ()는 활성 커서를 스택에서 팝합니다. &lt;a href=&quot;qguiapplication#changeOverrideCursor&quot;&gt;changeOverrideCursor&lt;/a&gt; ()는 현재 활성화 된 응용 프로그램 재정의 커서를 변경합니다.</target>
        </trans-unit>
        <trans-unit id="37f6d0abb946799b96e062063a34b2aa12972844" translate="yes" xml:space="preserve">
          <source>Application developers need not concern themselves with the &lt;a href=&quot;qplacemanagerengine&quot;&gt;QPlaceManagerEngine&lt;/a&gt;. Backend implementers however will need to derive from &lt;a href=&quot;qplacemanagerengine&quot;&gt;QPlaceManagerEngine&lt;/a&gt; and provide implementations for the abstract virtual functions.</source>
          <target state="translated">응용 프로그램 개발자는 &lt;a href=&quot;qplacemanagerengine&quot;&gt;QPlaceManagerEngine에&lt;/a&gt; 대해 걱정할 필요가 없습니다 . 그러나 백엔드 구현 &lt;a href=&quot;qplacemanagerengine&quot;&gt;자는 QPlaceManagerEngine&lt;/a&gt; 에서 파생되어 추상 가상 기능에 대한 구현을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="5363f9cea7ec2695b5d228b1999d7b12865f3705" translate="yes" xml:space="preserve">
          <source>Application developers need not concern themselves with the QPlaceManagerEngine. Backend implementers however will need to derive from QPlaceManagerEngine and provide implementations for the abstract virtual functions.</source>
          <target state="translated">응용 프로그램 개발자는 QPlaceManagerEngine에 대해 걱정할 필요가 없습니다. 그러나 백엔드 구현자는 QPlaceManagerEngine에서 파생되어 추상 가상 기능에 대한 구현을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="aa6a41142efefc222fd638bab6ffbf0d9084878f" translate="yes" xml:space="preserve">
          <source>Application developers typically encounter the need to work with custom shader code in Qt Quick scenes that have:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ead52ddb0ec69d17eee07cf54886c13d415aaec6" translate="yes" xml:space="preserve">
          <source>Application display name and identifier</source>
          <target state="translated">응용 프로그램 표시 이름 및 식별자</target>
        </trans-unit>
        <trans-unit id="8f113ade799bd38f0451572e87264647cc7bb122" translate="yes" xml:space="preserve">
          <source>Application override cursors are intended for showing the user that the application is in a special state, for example during an operation that might take some time.</source>
          <target state="translated">응용 프로그램 재정의 커서는 사용자에게 응용 프로그램이 특수 상태 (예 : 시간이 오래 걸릴 수 있음)에 있음을 표시하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="3fc0e785d1629568c19d71c4b7f71420d00ee4b4" translate="yes" xml:space="preserve">
          <source>Application settings may be divided into logical categories by specifying a category name via the &lt;a href=&quot;qml-qt-labs-settings-settings#category-prop&quot;&gt;category&lt;/a&gt; property. Using logical categories not only provides a cleaner settings structure, but also prevents possible conflicts between setting keys.</source>
          <target state="translated">&lt;a href=&quot;qml-qt-labs-settings-settings#category-prop&quot;&gt;category&lt;/a&gt; 속성을 통해 범주 이름을 지정하여 응용 프로그램 설정을 논리 범주로 나눌 수 있습니다 . 논리적 범주를 사용하면보다 명확한 설정 구조를 제공 할뿐만 아니라 설정 키 간의 충돌 가능성을 방지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="38c72b8d84634fbe058060b21c62e1c9e80f9ff8" translate="yes" xml:space="preserve">
          <source>Application specific settings are identified by providing application &lt;a href=&quot;qcoreapplication#applicationName-prop&quot;&gt;name&lt;/a&gt;, &lt;a href=&quot;qcoreapplication#organizationName-prop&quot;&gt;organization&lt;/a&gt; and &lt;a href=&quot;qcoreapplication#organizationDomain-prop&quot;&gt;domain&lt;/a&gt;, or by specifying &lt;a href=&quot;qml-qt-labs-settings-settings#fileName-prop&quot;&gt;fileName&lt;/a&gt;.</source>
          <target state="translated">응용 프로그램 특정 설정은 응용 프로그램 &lt;a href=&quot;qcoreapplication#applicationName-prop&quot;&gt;이름&lt;/a&gt; , &lt;a href=&quot;qcoreapplication#organizationName-prop&quot;&gt;조직&lt;/a&gt; 및 &lt;a href=&quot;qcoreapplication#organizationDomain-prop&quot;&gt;도메인&lt;/a&gt; 을 제공하거나 &lt;a href=&quot;qml-qt-labs-settings-settings#fileName-prop&quot;&gt;fileName&lt;/a&gt; 을 지정하여 식별됩니다 .</target>
        </trans-unit>
        <trans-unit id="99c2cb698337bc42ffb9296aee16eab2d7bd5775" translate="yes" xml:space="preserve">
          <source>Application-specific directories should be assumed to be unreachable by other applications. Therefore, files placed there might not be readable by other applications, even if run by the same user. On the other hand, generic directories should be assumed to be accessible by all applications run by this user, but should still be assumed to be unreachable by applications by other users.</source>
          <target state="translated">다른 응용 프로그램에서는 응용 프로그램 특정 디렉토리에 도달 할 수없는 것으로 가정해야합니다. 따라서 동일한 사용자가 실행하더라도 다른 응용 프로그램에서 파일을 읽지 못할 수 있습니다. 반면, 일반 디렉토리는이 사용자가 실행하는 모든 응용 프로그램이 액세스 할 수 있다고 가정해야하지만 다른 사용자가 응용 프로그램을 통해 도달 할 수없는 것으로 가정해야합니다.</target>
        </trans-unit>
        <trans-unit id="bb8f045797552418a8690112f95575d587db6060" translate="yes" xml:space="preserve">
          <source>ApplicationWindow</source>
          <target state="translated">ApplicationWindow</target>
        </trans-unit>
        <trans-unit id="c87139b68e490b101ffc0b3eb9df171948283af1" translate="yes" xml:space="preserve">
          <source>ApplicationWindow (QML type)</source>
          <target state="translated">ApplicationWindow (QML 유형)</target>
        </trans-unit>
        <trans-unit id="b95086c6e38bdb25419952e7314b6109566d2d56" translate="yes" xml:space="preserve">
          <source>ApplicationWindow Control</source>
          <target state="translated">ApplicationWindow 컨트롤</target>
        </trans-unit>
        <trans-unit id="9cc56ecd855b87102edd0fd3a6d77254d3a98dce" translate="yes" xml:space="preserve">
          <source>ApplicationWindow QML Type</source>
          <target state="translated">ApplicationWindow QML 유형</target>
        </trans-unit>
        <trans-unit id="09fab4de230b05c9549339cd1589fb47a42703cc" translate="yes" xml:space="preserve">
          <source>ApplicationWindow is a &lt;a href=&quot;https://doc.qt.io/qt-6.0/window2-qmlmodule.html&quot;&gt;Window&lt;/a&gt; which makes it convenient to add a &lt;a href=&quot;qml-qtquick-controls2-applicationwindow#menuBar-attached-prop&quot;&gt;menu bar&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-controls2-applicationwindow#header-attached-prop&quot;&gt;header&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-controls2-applicationwindow#footer-attached-prop&quot;&gt;footer&lt;/a&gt; item to the window.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46265bc9bbfeef9b7faf24edad095eacffb3a323" translate="yes" xml:space="preserve">
          <source>ApplicationWindow is a &lt;a href=&quot;qml-qtquick-window-window&quot;&gt;Window&lt;/a&gt; that adds convenience for positioning items, such as &lt;a href=&quot;qml-qtquick-controls-menubar&quot;&gt;MenuBar&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-controls-toolbar&quot;&gt;ToolBar&lt;/a&gt;, and &lt;a href=&quot;qml-qtquick-controls-statusbar&quot;&gt;StatusBar&lt;/a&gt; in a platform independent manner.</source>
          <target state="translated">ApplicationWindow는 플랫폼 독립적 인 방식 으로 &lt;a href=&quot;qml-qtquick-controls-menubar&quot;&gt;MenuBar&lt;/a&gt; , &lt;a href=&quot;qml-qtquick-controls-toolbar&quot;&gt;ToolBar&lt;/a&gt; 및 &lt;a href=&quot;qml-qtquick-controls-statusbar&quot;&gt;StatusBar&lt;/a&gt; 와 같은 항목을 배치하는 데 편리함을 추가 하는 &lt;a href=&quot;qml-qtquick-window-window&quot;&gt;창&lt;/a&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="141e9fe433538b110edc08db43f93c06e6d0b961" translate="yes" xml:space="preserve">
          <source>ApplicationWindow is a &lt;a href=&quot;qml-qtquick-window-window&quot;&gt;Window&lt;/a&gt; which makes it convenient to add a &lt;a href=&quot;qml-qtquick-controls2-applicationwindow#menuBar-attached-prop&quot;&gt;menu bar&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-controls2-applicationwindow#header-attached-prop&quot;&gt;header&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-controls2-applicationwindow#footer-attached-prop&quot;&gt;footer&lt;/a&gt; item to the window.</source>
          <target state="translated">ApplicationWindow는 것입니다 &lt;a href=&quot;qml-qtquick-window-window&quot;&gt;윈도우&lt;/a&gt; 가 편리 추가 할 수 있습니다 &lt;a href=&quot;qml-qtquick-controls2-applicationwindow#menuBar-attached-prop&quot;&gt;메뉴 모음&lt;/a&gt; , &lt;a href=&quot;qml-qtquick-controls2-applicationwindow#header-attached-prop&quot;&gt;머리글&lt;/a&gt; 과 &lt;a href=&quot;qml-qtquick-controls2-applicationwindow#footer-attached-prop&quot;&gt;바닥 글&lt;/a&gt; 창에 항목을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="914095c44aa4d0b266d848971a54e8fcad0dd136" translate="yes" xml:space="preserve">
          <source>ApplicationWindow provides a set of attached properties that can be used to access the window and its building blocks from places where no direct access to the window is available, without creating a dependency to a certain window &lt;code&gt;id&lt;/code&gt;. A QML component that uses the ApplicationWindow attached properties works in any window regardless of its &lt;code&gt;id&lt;/code&gt;.</source>
          <target state="translated">ApplicationWindow는 특정 창 &lt;code&gt;id&lt;/code&gt; 대한 종속성을 만들지 않고 창에 직접 액세스 할 수없는 위치에서 창 및 해당 빌딩 블록에 액세스하는 데 사용할 수있는 연결된 속성 집합을 제공합니다 . ApplicationWindow 연결 속성을 사용하는 QML 구성 요소는 &lt;code&gt;id&lt;/code&gt; 에 관계없이 모든 창에서 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="888d241fa21d518451d070595340a905c619e2b2" translate="yes" xml:space="preserve">
          <source>ApplicationWindow.ApplicationWindow.activeFocusControl</source>
          <target state="translated">ApplicationWindow.ApplicationWindow.activeFocusControl</target>
        </trans-unit>
        <trans-unit id="1cc95b142b11a5aeb21eb7bedb9aac08fcc1f487" translate="yes" xml:space="preserve">
          <source>ApplicationWindow.ApplicationWindow.contentItem</source>
          <target state="translated">ApplicationWindow.ApplicationWindow.contentItem</target>
        </trans-unit>
        <trans-unit id="89aa83aa2977e2c1cc61c04d32b76a65cc25c987" translate="yes" xml:space="preserve">
          <source>ApplicationWindow.ApplicationWindow.footer</source>
          <target state="translated">ApplicationWindow.ApplicationWindow.footer</target>
        </trans-unit>
        <trans-unit id="dd2a0fbfd577f55dc072597072eb7558116685a3" translate="yes" xml:space="preserve">
          <source>ApplicationWindow.ApplicationWindow.header</source>
          <target state="translated">ApplicationWindow.ApplicationWindow.header</target>
        </trans-unit>
        <trans-unit id="6f988730af7f806beb7f123311d2922a2f18b648" translate="yes" xml:space="preserve">
          <source>ApplicationWindow.ApplicationWindow.menuBar</source>
          <target state="translated">ApplicationWindow.ApplicationWindow.menuBar</target>
        </trans-unit>
        <trans-unit id="ec54ddc1158ba5e16ba27dc0389fde155dd7e8ab" translate="yes" xml:space="preserve">
          <source>ApplicationWindow.ApplicationWindow.window</source>
          <target state="translated">ApplicationWindow.ApplicationWindow.window</target>
        </trans-unit>
        <trans-unit id="6cfde3fcc08dc96da4abd5095a1cd0b4569969a0" translate="yes" xml:space="preserve">
          <source>ApplicationWindow.activeFocusControl</source>
          <target state="translated">ApplicationWindow.activeFocusControl</target>
        </trans-unit>
        <trans-unit id="09fe9cbca9b602e7353c054fc918fa1d4429abbc" translate="yes" xml:space="preserve">
          <source>ApplicationWindow.background</source>
          <target state="translated">ApplicationWindow.background</target>
        </trans-unit>
        <trans-unit id="861ba6559d7bcc0e9a30f2f9165906c7a7260bbe" translate="yes" xml:space="preserve">
          <source>ApplicationWindow.contentData</source>
          <target state="translated">ApplicationWindow.contentData</target>
        </trans-unit>
        <trans-unit id="d692622db50a435b99a17eb17567d54dbad5a58e" translate="yes" xml:space="preserve">
          <source>ApplicationWindow.contentItem</source>
          <target state="translated">ApplicationWindow.contentItem</target>
        </trans-unit>
        <trans-unit id="7383cfc654ff6281b007a4f0bcd4bf368f411cbf" translate="yes" xml:space="preserve">
          <source>ApplicationWindow.font</source>
          <target state="translated">ApplicationWindow.font</target>
        </trans-unit>
        <trans-unit id="6d862d0b9ce6a1725648f04f1f912e049fd5c4b9" translate="yes" xml:space="preserve">
          <source>ApplicationWindow.footer</source>
          <target state="translated">ApplicationWindow.footer</target>
        </trans-unit>
        <trans-unit id="1b9a1ceea5079934160b1f80ca19f833a3c292ac" translate="yes" xml:space="preserve">
          <source>ApplicationWindow.header</source>
          <target state="translated">ApplicationWindow.header</target>
        </trans-unit>
        <trans-unit id="6d15a64960ebc299e13a6f71149ccb206edc6421" translate="yes" xml:space="preserve">
          <source>ApplicationWindow.locale</source>
          <target state="translated">ApplicationWindow.locale</target>
        </trans-unit>
        <trans-unit id="468c197b3f8ebb751e955786acdf2d61664d6feb" translate="yes" xml:space="preserve">
          <source>ApplicationWindow.menuBar</source>
          <target state="translated">ApplicationWindow.menuBar</target>
        </trans-unit>
        <trans-unit id="04b875225bd0bcae0b0d60cee19ec992c976457c" translate="yes" xml:space="preserve">
          <source>ApplicationWindow.palette</source>
          <target state="translated">ApplicationWindow.palette</target>
        </trans-unit>
        <trans-unit id="ad6e44ef2a32b1c37940943d252c5ab781f71c5a" translate="yes" xml:space="preserve">
          <source>ApplicationWindow.statusBar</source>
          <target state="translated">ApplicationWindow.statusBar</target>
        </trans-unit>
        <trans-unit id="c13894c28725e64375ac98bc82fe0581bcfe5748" translate="yes" xml:space="preserve">
          <source>ApplicationWindow.style</source>
          <target state="translated">ApplicationWindow.style</target>
        </trans-unit>
        <trans-unit id="186ff5ca97b7321346cfc2505ec6824e39691249" translate="yes" xml:space="preserve">
          <source>ApplicationWindow.toolBar</source>
          <target state="translated">ApplicationWindow.toolBar</target>
        </trans-unit>
        <trans-unit id="610902bd2173043cf5bf7bc6cecd73bae70b7f4b" translate="yes" xml:space="preserve">
          <source>ApplicationWindowStyle</source>
          <target state="translated">ApplicationWindowStyle</target>
        </trans-unit>
        <trans-unit id="f08f614ed810905ce69136905eeda68e1bf41ca2" translate="yes" xml:space="preserve">
          <source>ApplicationWindowStyle (QML type)</source>
          <target state="translated">ApplicationWindowStyle (QML 유형)</target>
        </trans-unit>
        <trans-unit id="6c67eea9c15549344f9926fc2ee453a3bcd0108c" translate="yes" xml:space="preserve">
          <source>ApplicationWindowStyle QML Type</source>
          <target state="translated">ApplicationWindowStyle QML 유형</target>
        </trans-unit>
        <trans-unit id="b5c3c063a4401b0a04c531790dd15dc65222d83d" translate="yes" xml:space="preserve">
          <source>ApplicationWindowStyle.background</source>
          <target state="translated">ApplicationWindowStyle.background</target>
        </trans-unit>
        <trans-unit id="e8d68389d631dbb69c6e4b41afaa72afe2a65467" translate="yes" xml:space="preserve">
          <source>ApplicationWindowStyle.control</source>
          <target state="translated">ApplicationWindowStyle.control</target>
        </trans-unit>
        <trans-unit id="67a434eb21e1c7f1252ffeb7632d243814ba65a2" translate="yes" xml:space="preserve">
          <source>Applications can access Qt Sensors using QML or C++.</source>
          <target state="translated">애플리케이션은 QML 또는 C ++를 사용하여 Qt 센서에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6079d99f066e0baf888f83c2ba22f55f832eb161" translate="yes" xml:space="preserve">
          <source>Applications can also communicate with each other by putting data on the clipboard. To access this, you need to obtain a &lt;a href=&quot;qclipboard&quot;&gt;QClipboard&lt;/a&gt; object from the &lt;a href=&quot;qapplication&quot;&gt;QApplication&lt;/a&gt; object.</source>
          <target state="translated">응용 프로그램은 클립 보드에 데이터를 넣어 서로 통신 할 수도 있습니다. 이에 액세스하려면 &lt;a href=&quot;qapplication&quot;&gt;QApplication&lt;/a&gt; 오브젝트 에서 &lt;a href=&quot;qclipboard&quot;&gt;QClipboard&lt;/a&gt; 오브젝트 를 확보해야 합니다.</target>
        </trans-unit>
        <trans-unit id="38d31cb1a98a04153cfdddc87dda3d949e2d73e0" translate="yes" xml:space="preserve">
          <source>Applications can connect to the &lt;a href=&quot;qnearfieldmanager#targetDetected&quot;&gt;targetDetected&lt;/a&gt;() and &lt;a href=&quot;qnearfieldmanager#targetLost&quot;&gt;targetLost&lt;/a&gt;() signals to get notified when an NFC Forum Tag enters or leaves proximity. Before these signals are emitted target detection must be started with the &lt;a href=&quot;qnearfieldmanager#startTargetDetection&quot;&gt;startTargetDetection&lt;/a&gt;() function. Target detection can be stopped with the &lt;a href=&quot;qnearfieldmanager#stopTargetDetection&quot;&gt;stopTargetDetection&lt;/a&gt;() function. Before a detected target can be accessed it is necessary to request access rights. This must be done before the target device is touched. The &lt;a href=&quot;qnearfieldmanager#setTargetAccessModes&quot;&gt;setTargetAccessModes&lt;/a&gt;() function is used to set the types of access the application wants to perform on the detected target. When access is no longer required the target access modes should be set to &lt;a href=&quot;qnearfieldmanager#TargetAccessMode-enum&quot;&gt;NoTargetAccess&lt;/a&gt; as other applications may be blocked from accessing targets. The current target access modes can be retried with the &lt;a href=&quot;qnearfieldmanager#targetAccessModes&quot;&gt;targetAccessModes&lt;/a&gt;() function.</source>
          <target state="translated">NFC 포럼 태그가 근접하거나 근접한 경우 응용 프로그램에서 &lt;a href=&quot;qnearfieldmanager#targetDetected&quot;&gt;targetDetected&lt;/a&gt; () 및 &lt;a href=&quot;qnearfieldmanager#targetLost&quot;&gt;targetLost&lt;/a&gt; () 신호에 연결할 수 있습니다 . 이러한 신호가 방출되기 전에 &lt;a href=&quot;qnearfieldmanager#startTargetDetection&quot;&gt;startTargetDetection&lt;/a&gt; () 기능으로 대상 감지를 시작해야합니다 . &lt;a href=&quot;qnearfieldmanager#stopTargetDetection&quot;&gt;stopTargetDetection&lt;/a&gt; () 기능으로 대상 감지를 중지 할 수 있습니다 . 감지 된 대상에 액세스하려면 액세스 권한을 요청해야합니다. 대상 장치를 만지기 전에 수행해야합니다. &lt;a href=&quot;qnearfieldmanager#setTargetAccessModes&quot;&gt;setTargetAccessModes&lt;/a&gt; () 함수는 애플리케이션이 검출 대상에서 수행하고자하는 액세스의 타입을 설정하는데 사용된다. 액세스가 더 이상 필요하지 않은 경우 대상 액세스 모드를 &lt;a href=&quot;qnearfieldmanager#TargetAccessMode-enum&quot;&gt;NoTargetAccess&lt;/a&gt; 로 설정해야합니다.다른 응용 프로그램은 대상에 액세스하지 못하도록 차단 될 수 있습니다. &lt;a href=&quot;qnearfieldmanager#targetAccessModes&quot;&gt;targetAccessModes&lt;/a&gt; () 함수를 사용하여 현재 대상 액세스 모드를 재 시도 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a70d1194e4746360c3ce21e9a8092718d4f4e070" translate="yes" xml:space="preserve">
          <source>Applications can embed a toolbar in the thumbnail of a window, which is shown when hovering over its taskbar icon. A thumbnail toolbar may provide quick access to the commands of a window without requiring the user to restore or activate the window.</source>
          <target state="translated">응용 프로그램은 작업 표시 줄 아이콘 위로 마우스를 가져갈 때 표시되는 도구 모음을 창의 축소판에 포함시킬 수 있습니다. 썸네일 도구 모음은 사용자가 창을 복원하거나 활성화하지 않고도 창의 명령에 빠르게 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="99dd2c54a9a414c1623cd4cada970a3445e64d09" translate="yes" xml:space="preserve">
          <source>Applications can expose actions, which can be invoked by the client. In order to support actions in an object, inherit the &lt;a href=&quot;qaccessibleactioninterface&quot;&gt;QAccessibleActionInterface&lt;/a&gt;.</source>
          <target state="translated">응용 프로그램은 클라이언트가 호출 할 수있는 작업을 노출 할 수 있습니다. 오브젝트에서 조치를 지원하려면 &lt;a href=&quot;qaccessibleactioninterface&quot;&gt;QAccessibleActionInterface를&lt;/a&gt; 상속하십시오 .</target>
        </trans-unit>
        <trans-unit id="d672e8996b07b30355857210c8aef0a1d48da253" translate="yes" xml:space="preserve">
          <source>Applications can prohibit the use of touch events in the following ways:</source>
          <target state="translated">애플리케이션은 다음과 같은 방식으로 터치 이벤트 사용을 금지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b10a9b5fb0eb3c5c12498c82a7e609551d9488f1" translate="yes" xml:space="preserve">
          <source>Applications can respond to these events to know when the underlying platform surface exists.</source>
          <target state="translated">애플리케이션은 이러한 이벤트에 응답하여 기본 플랫폼 표면이 존재하는시기를 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f2fe341b33fdce03cda50b78c1577c4129900c8a" translate="yes" xml:space="preserve">
          <source>Applications can share NDEF data or file content using NFC technology by tapping two NFC-enabled devices together. The &lt;a href=&quot;qnearfieldsharemanager&quot;&gt;QNearFieldShareManager&lt;/a&gt; provides a high level entry point to access this functionality.</source>
          <target state="translated">응용 프로그램은 NFC 지원 장치 두 개를 함께 눌러 NFC 기술을 사용하여 NDEF 데이터 또는 파일 내용을 공유 할 수 있습니다. &lt;a href=&quot;qnearfieldsharemanager&quot;&gt;QNearFieldShareManager는&lt;/a&gt; 이 기능에 액세스 할 수있는 높은 수준의 진입 점을 제공한다.</target>
        </trans-unit>
        <trans-unit id="f128ce1e77dfafee662059e671393ea28eec798d" translate="yes" xml:space="preserve">
          <source>Applications can share NDEF data or file content using NFC technology by tapping two NFC-enabled devices together. The QNearFieldShareManager provides a high level entry point to access this functionality.</source>
          <target state="translated">애플리케이션은 두 개의 NFC 지원 장치를 함께 탭하여 NFC 기술을 사용하여 NDEF 데이터 또는 파일 콘텐츠를 공유 할 수 있습니다. QNearFieldShareManager는이 기능에 액세스 할 수있는 높은 수준의 진입 점을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="900064092b3ec48b518040eb62887303671f6908" translate="yes" xml:space="preserve">
          <source>Applications do not have access to system fonts. Font files must be distributed with the application, for example in Qt resources. Qt for WebAssembly itself embeds one such font.</source>
          <target state="translated">응용 프로그램은 시스템 글꼴에 액세스 할 수 없습니다. 글꼴 파일은 응용 프로그램과 함께 배포해야합니다 (예 : Qt 리소스). WebAssembly 용 Qt 자체에는 이러한 글꼴 중 하나가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="3e7eb307dd76707dc438a8e8f259be110fd0f7ef" translate="yes" xml:space="preserve">
          <source>Applications do not need to instantiate this class, but can read the instances pointed to by &lt;a href=&quot;qinputevent#device&quot;&gt;QInputEvent::device&lt;/a&gt;() and &lt;a href=&quot;qinputdevice#devices&quot;&gt;QInputDevice::devices&lt;/a&gt;().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b614e23b443a76e1a13c29fee410cb259b4948c6" translate="yes" xml:space="preserve">
          <source>Applications may choose a specific &lt;a href=&quot;http://developer.android.com/design/style/themes.html&quot;&gt;Android theme&lt;/a&gt; by specifying it in &lt;a href=&quot;https://doc.qt.io/qt-5.13/deployment-android.html#androidmanifest-xml&quot;&gt;AndroidManifest.xml&lt;/a&gt;.</source>
          <target state="translated">애플리케이션은 &lt;a href=&quot;https://doc.qt.io/qt-5.13/deployment-android.html#androidmanifest-xml&quot;&gt;AndroidManifest.xml&lt;/a&gt; 에 특정 &lt;a href=&quot;http://developer.android.com/design/style/themes.html&quot;&gt;안드로이드 테마&lt;/a&gt; 를 지정하여 선택할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8d808e95c2e096ad2166e6da04a94706a9fd2fdf" translate="yes" xml:space="preserve">
          <source>Applications may choose a specific &lt;a href=&quot;http://developer.android.com/design/style/themes.html&quot;&gt;Android theme&lt;/a&gt; by specifying it in &lt;a href=&quot;https://doc.qt.io/qt-5.15/deployment-android.html#androidmanifest-xml&quot;&gt;AndroidManifest.xml&lt;/a&gt;.</source>
          <target state="translated">애플리케이션은 &lt;a href=&quot;https://doc.qt.io/qt-5.15/deployment-android.html#androidmanifest-xml&quot;&gt;AndroidManifest.xml&lt;/a&gt; 에서 지정 하여 특정 &lt;a href=&quot;http://developer.android.com/design/style/themes.html&quot;&gt;Android 테마&lt;/a&gt; 를 선택할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="670f4431db3fed86bc7c7375afec7853136f2847" translate="yes" xml:space="preserve">
          <source>Applications may connect to the &lt;a href=&quot;qnetworksession#preferredConfigurationChanged&quot;&gt;preferredConfigurationChanged&lt;/a&gt;() signal in order to receive notifications when a more suitable access point becomes available. In response to this signal the application must either initiate the roaming via &lt;a href=&quot;qnetworksession#migrate&quot;&gt;migrate&lt;/a&gt;() or &lt;a href=&quot;qnetworksession#ignore&quot;&gt;ignore&lt;/a&gt;() the new access point. Once the session has roamed the &lt;a href=&quot;qnetworksession#newConfigurationActivated&quot;&gt;newConfigurationActivated&lt;/a&gt;() signal is emitted. The application may now test the carrier and must either &lt;a href=&quot;qnetworksession#accept&quot;&gt;accept&lt;/a&gt;() or &lt;a href=&quot;qnetworksession#reject&quot;&gt;reject&lt;/a&gt;() it. The session will return to the previous access point if the roaming was rejected. The subsequent state diagram depicts the required state transitions.</source>
          <target state="translated">보다 적합한 액세스 포인트를 사용할 수있게되면 알림을 수신하기 위해 응용 프로그램이 &lt;a href=&quot;qnetworksession#preferredConfigurationChanged&quot;&gt;preferredConfigurationChanged&lt;/a&gt; () 신호에 연결할 수 있습니다. 이 신호에 응답하여 응용 프로그램은 &lt;a href=&quot;qnetworksession#migrate&quot;&gt;마이그레이션&lt;/a&gt; ()을 통해 로밍을 시작 하거나 새 액세스 포인트를 &lt;a href=&quot;qnetworksession#ignore&quot;&gt;무시&lt;/a&gt; ()해야합니다. 세션이 로밍되면 &lt;a href=&quot;qnetworksession#newConfigurationActivated&quot;&gt;newConfigurationActivated&lt;/a&gt; () 신호가 생성됩니다. 응용 프로그램은 이제 캐리어를 테스트 할 수 있으며 캐리어를 &lt;a href=&quot;qnetworksession#accept&quot;&gt;수락&lt;/a&gt; ()하거나 &lt;a href=&quot;qnetworksession#reject&quot;&gt;거부&lt;/a&gt; ()해야합니다. 로밍이 거부되면 세션이 이전 액세스 지점으로 돌아갑니다. 후속 상태 다이어그램은 필요한 상태 전환을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="0940283d47a16a6344d8ca45e49cbb8eea19ca4a" translate="yes" xml:space="preserve">
          <source>Applications may use this signal to release resources, but should be prepared to reinstantiated them again fast. The scene graph and the graphics context are not released at this time.</source>
          <target state="translated">응용 프로그램은이 신호를 사용하여 리소스를 해제 할 수 있지만 다시 빠르게 인스턴스화 할 수 있도록 준비해야합니다. 현재 장면 그래프와 그래픽 컨텍스트가 해제되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="33c10cc2fc1360376d79bd2eb89cacb2d0bb94e4" translate="yes" xml:space="preserve">
          <source>Applications mostly work with device independent pixels. Notable exceptions are OpenGL and code that works with raster graphics.</source>
          <target state="translated">응용 프로그램은 대부분 장치 독립적 픽셀에서 작동합니다. 래스터 그래픽과 작동하는 OpenGL 및 코드는 예외입니다.</target>
        </trans-unit>
        <trans-unit id="0aa1eb877fb0a208fad515b23788ec731ad9384c" translate="yes" xml:space="preserve">
          <source>Applications must adapt to situations where users have multiple displays with varying resolution. For example, they might use a 4K monitor for the document window of an image editor and a low resolution monitor for the tool box.</source>
          <target state="translated">응용 프로그램은 사용자가 다양한 해상도의 여러 디스플레이를 사용하는 상황에 적응해야합니다. 예를 들어, 이미지 편집기의 문서 창에는 4K 모니터를 사용하고 도구 상자에는 저해상도 모니터를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bbff14fdf9952d9d1de0b5b17d977cd90f60a7ff" translate="yes" xml:space="preserve">
          <source>Applications run in fullscreen mode only (see &lt;a href=&quot;qstylehints&quot;&gt;QStyleHints&lt;/a&gt;). On desktop, the screen size varies as the application is resized.</source>
          <target state="translated">응용 프로그램은 전체 화면 모드에서만 실행됩니다 ( &lt;a href=&quot;qstylehints&quot;&gt;QStyleHints&lt;/a&gt; 참조 ). 데스크톱에서 화면 크기는 응용 프로그램의 크기가 조정됨에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="9e624b3f0c05be2a737d939d1b457fea3542a177" translate="yes" xml:space="preserve">
          <source>Applications should act on this signal at their own discretion. The data provided by the model could be out of date and so the model should be reupdated sometime, however an immediate reupdate may be disconcerting to users if the categories change without any action on their part.</source>
          <target state="translated">응용 프로그램은이 재량에 따라 자체 재량으로 행동해야합니다. 모델이 제공 한 데이터가 오래되었을 수 있으므로 모델을 언젠가 다시 업데이트해야하지만, 사용자가 아무런 조치를 취하지 않고 범주가 변경되면 즉각적인 업데이트로 인해 사용자에게 당황 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b4283087e120f502c2fff9fbb65d942153b802b3" translate="yes" xml:space="preserve">
          <source>Applications should check this property to determine whether positioning is available and enabled on the runtime platform, and react accordingly.</source>
          <target state="translated">애플리케이션은이 특성을 확인하여 런타임 플랫폼에서 위치 지정이 사용 가능한지 여부를 판별하고 이에 따라 반응해야합니다.</target>
        </trans-unit>
        <trans-unit id="45e84f9b49f31ef4ca100c7417ad56468763e5e9" translate="yes" xml:space="preserve">
          <source>Applications should connect to this signal if they wish to handle errors, like OpenGL context creation failures, in a custom way. When no slot is connected to the signal, the behavior will be different: Quick will print the</source>
          <target state="translated">애플리케이션이 OpenGL 컨텍스트 작성 실패와 같은 오류를 사용자 정의 방식으로 처리하려면이 신호에 연결해야합니다. 신호에 슬롯이 연결되어 있지 않으면 동작이 달라집니다.</target>
        </trans-unit>
        <trans-unit id="1d4348998c86ba193bc58a864ecaa92bbe12d6a7" translate="yes" xml:space="preserve">
          <source>Applications should connect to this signal if they wish to handle errors, like graphics context creation failures, in a custom way. When no slot is connected to the signal, the behavior will be different: Quick will print the</source>
          <target state="translated">그래픽 컨텍스트 생성 실패와 같은 오류를 사용자 정의 방식으로 처리하려면 응용 프로그램이이 신호에 연결해야합니다. 신호에 슬롯이 연결되어 있지 않으면 동작이 달라집니다.</target>
        </trans-unit>
        <trans-unit id="1be63e02443edb75de24d5a1d221f77a1dfd6f7d" translate="yes" xml:space="preserve">
          <source>Applications should not exit programmatically. In particular, calling exit() before the UI is shown causes a crash.</source>
          <target state="translated">응용 프로그램을 프로그래밍 방식으로 종료해서는 안됩니다. 특히 UI가 표시되기 전에 exit ()를 호출하면 충돌이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="078f11fb40841f98a21ebbc9f244eee4d9ec8068" translate="yes" xml:space="preserve">
          <source>Applications should only use further values if a corresponding specification has been published, otherwise interpretation and validation by the remote may fail. Values 24 to 31 are reserved and must not be used.</source>
          <target state="translated">응용 프로그램은 해당 사양이 게시 된 경우에만 추가 값을 사용해야합니다. 그렇지 않으면 리모콘의 해석 및 유효성 검사가 실패 할 수 있습니다. 24에서 31까지의 값은 예약되어 있으므로 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="b9e0d4410ba26ad8270df753b5bd3ada94b1aba4" translate="yes" xml:space="preserve">
          <source>Applications should use the Asynchronous incubation mode to create objects that are not needed immediately. For example, the &lt;a href=&quot;qml-qtquick-listview&quot;&gt;ListView&lt;/a&gt; type uses Asynchronous incubation to create objects that are slightly off screen while the list is being scrolled. If, during asynchronous creation, the object is needed immediately the &lt;a href=&quot;qqmlincubator#forceCompletion&quot;&gt;QQmlIncubator::forceCompletion&lt;/a&gt;() method can be called to complete the creation process synchronously.</source>
          <target state="translated">응용 프로그램은 비동기 인큐베이션 모드를 사용하여 즉시 필요하지 않은 개체를 만들어야합니다. 예를 들어 &lt;a href=&quot;qml-qtquick-listview&quot;&gt;ListView&lt;/a&gt; 유형은 비동기 인큐베이션을 사용하여 목록이 스크롤되는 동안 화면에서 약간 벗어난 개체를 만듭니다. 비동기 작성 중에 오브젝트가 즉시 필요한 경우 &lt;a href=&quot;qqmlincubator#forceCompletion&quot;&gt;QQmlIncubator :: forceCompletion&lt;/a&gt; () 메소드를 호출하여 작성 프로세스를 동 기적으로 완료 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2cbec31f7dd373771a9c631da6a9a11a1d574189" translate="yes" xml:space="preserve">
          <source>Applications submitted to the App Store must be code-signed with the App Sandbox feature enabled. The App Sandbox feature interferes with Chromium's own sandbox initialization, which results in Chromium not being properly initialized. This also ties in with the private API usage. Furthermore, standalone Chromium itself is not officially tested with the App Sandbox enabled, and even if work is done to bypass the App Store's restrictions, that would not guarantee correct behavior of the library.</source>
          <target state="translated">App Store에 제출 된 응용 프로그램은 App Sandbox 기능이 활성화 된 상태에서 코드 서명되어야합니다. 앱 샌드 박스 기능은 Chromium의 자체 샌드 박스 초기화를 방해하여 Chromium이 제대로 초기화되지 않습니다. 이것은 또한 개인 API 사용과 관련이 있습니다. 또한 독립 실행 형 Chromium 자체는 공식적으로 App Sandbox를 사용하도록 테스트되지 않았으며 App Store의 제한을 우회하는 작업을 수행하더라도 라이브러리의 올바른 동작을 보장하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="f6faacfc5e90f64efaa80b1c66302fad7fd5e6e6" translate="yes" xml:space="preserve">
          <source>Applications that define &lt;a href=&quot;qstring#QT_NO_CAST_FROM_ASCII&quot;&gt;QT_NO_CAST_FROM_ASCII&lt;/a&gt; (as explained in the &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; documentation) don't have access to &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;'s &lt;code&gt;const char *&lt;/code&gt; API. To provide an efficient way of specifying constant Latin-1 strings, Qt provides the QLatin1String, which is just a very thin wrapper around a &lt;code&gt;const char *&lt;/code&gt;. Using QLatin1String, the example code above becomes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b3f209f93d2eeb87b946ddc82a7bd59829a0509" translate="yes" xml:space="preserve">
          <source>Applications that define &lt;code&gt;QT_NO_CAST_FROM_ASCII&lt;/code&gt; (as explained in the &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; documentation) don't have access to &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;'s &lt;code&gt;const char *&lt;/code&gt; API. To provide an efficient way of specifying constant Latin-1 strings, Qt provides the &lt;a href=&quot;qlatin1string&quot;&gt;QLatin1String&lt;/a&gt;, which is just a very thin wrapper around a &lt;code&gt;const char *&lt;/code&gt;. Using &lt;a href=&quot;qlatin1string&quot;&gt;QLatin1String&lt;/a&gt;, the example code above becomes</source>
          <target state="translated">&lt;code&gt;QT_NO_CAST_FROM_ASCII&lt;/code&gt; 를 정의하는 응용 프로그램 ( &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; 설명서 에서 설명 )은 &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; 의 &lt;code&gt;const char *&lt;/code&gt; API에 액세스 할 수 없습니다 . 상수 Latin-1 문자열을 지정하는 효율적인 방법을 제공하기 위해 Qt는 &lt;a href=&quot;qlatin1string&quot;&gt;QLatin1String을&lt;/a&gt; 제공합니다. QLatin1String 은 &lt;code&gt;const char *&lt;/code&gt; 주위의 매우 얇은 래퍼 입니다. &lt;a href=&quot;qlatin1string&quot;&gt;QLatin1String을&lt;/a&gt; 사용하면 위의 예제 코드는</target>
        </trans-unit>
        <trans-unit id="9d1d90d59feb0b653df9ec9417b8b0d712306193" translate="yes" xml:space="preserve">
          <source>Applications that define &lt;code&gt;QT_NO_CAST_FROM_ASCII&lt;/code&gt; (as explained in the &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; documentation) don't have access to &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;'s &lt;code&gt;const char *&lt;/code&gt; API. To provide an efficient way of specifying constant Latin-1 strings, Qt provides the QLatin1String, which is just a very thin wrapper around a &lt;code&gt;const char *&lt;/code&gt;. Using QLatin1String, the example code above becomes</source>
          <target state="translated">정의 응용 프로그램 &lt;code&gt;QT_NO_CAST_FROM_ASCII&lt;/code&gt; 을 합니다 (에 설명 된대로 &lt;a href=&quot;qstring&quot;&gt;QString의&lt;/a&gt; 문서)에 대한 액세스 권한이없는 &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; 의 &lt;code&gt;const char *&lt;/code&gt; API를. 상수 Latin-1 문자열을 지정하는 효율적인 방법을 제공하기 위해 Qt는 &lt;code&gt;const char *&lt;/code&gt; 주위의 매우 얇은 래퍼 인 QLatin1String을 제공합니다 . QLatin1String을 사용하면 위의 예제 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8b9abdc603ec5011f6e5179220d8a92a0231a36a" translate="yes" xml:space="preserve">
          <source>Applications that rely on certain reference stability might run into undefined behavior when upgraded to use Qt 6. You should pay extra attention to cases where &lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt; or &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt; with a non C-compatible array layout were used originally.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3730dd0b0eedc7b541372ab0bf269065e8298df" translate="yes" xml:space="preserve">
          <source>Applications that require &lt;a href=&quot;qrandomgenerator&quot;&gt;QRandomGenerator&lt;/a&gt; not to fall back to non-cryptographic quality generators are advised to check their operating system documentation or restrict their deployment to one of the above.</source>
          <target state="translated">&lt;a href=&quot;qrandomgenerator&quot;&gt;QRandomGenerator&lt;/a&gt; 가 비 암호화 품질 생성기 로 폴백 하지 않아야하는 애플리케이션은 운영 체제 문서를 확인하거나 배치 중 하나 이상을 제한하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="1c91583f184f4d0f902b15a9ce3990a4a91e7d44" translate="yes" xml:space="preserve">
          <source>Applications that require QRandomGenerator not to fall back to non-cryptographic quality generators are advised to check their operating system documentation or restrict their deployment to one of the above.</source>
          <target state="translated">QRandomGenerator가 비 암호화 품질 생성기로 대체되지 않도록하는 애플리케이션은 운영 체제 문서를 확인하거나 배포를 위 중 하나로 제한하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="c6531ae459350b8ecff786216e687c7dcb521e06" translate="yes" xml:space="preserve">
          <source>Applications that require a certain OpenGL implementation (for example, desktop OpenGL due to relying on features provided by OpenGL 3.0 or higher) should set the application attributes &lt;code&gt;Qt::AA_UseOpenGLES&lt;/code&gt; or &lt;code&gt;Qt::AA_UseDesktopOpenGL&lt;/code&gt; before instantiating &lt;a href=&quot;qguiapplication&quot;&gt;QGuiApplication&lt;/a&gt; or &lt;a href=&quot;qapplication&quot;&gt;QApplication&lt;/a&gt;. When these attributes are set, no other OpenGL implementations are considered. Additionally, if they wish to, such applications are free to make direct OpenGL function calls by adding opengl32.lib to their .pro project files:</source>
          <target state="translated">특정 OpenGL 구현이 필요한 애플리케이션 (예 : OpenGL 3.0 이상에서 제공하는 기능에 의존하기 때문에 데스크톱 OpenGL)은 &lt;a href=&quot;qguiapplication&quot;&gt;QGuiApplication&lt;/a&gt; 또는 &lt;a href=&quot;qapplication&quot;&gt;QApplication을&lt;/a&gt; 인스턴스화하기 전에 애플리케이션 속성 &lt;code&gt;Qt::AA_UseOpenGLES&lt;/code&gt; 또는 &lt;code&gt;Qt::AA_UseDesktopOpenGL&lt;/code&gt; 설정해야합니다 . 이러한 속성이 설정되면 다른 OpenGL 구현은 고려되지 않습니다. 또한 원하는 경우 이러한 응용 프로그램은 .pro 프로젝트 파일에 opengl32.lib를 추가하여 직접 OpenGL 함수를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="073297d1e5bdb771ff14f2cc14a050dd7dfb9317" translate="yes" xml:space="preserve">
          <source>Applications typically subclass both &lt;a href=&quot;qvulkanwindow&quot;&gt;QVulkanWindow&lt;/a&gt; and &lt;a href=&quot;qvulkanwindowrenderer&quot;&gt;QVulkanWindowRenderer&lt;/a&gt;. The former allows handling events, for example, input, while the latter allows implementing the Vulkan resource management and command buffer building that make up the application's rendering.</source>
          <target state="translated">애플리케이션은 일반적으로 &lt;a href=&quot;qvulkanwindow&quot;&gt;QVulkanWindow&lt;/a&gt; 및 &lt;a href=&quot;qvulkanwindowrenderer&quot;&gt;QVulkanWindowRenderer를&lt;/a&gt; 모두 서브 클래스합니다 . 전자는 이벤트 (예 : 입력)를 처리 할 수있는 반면 후자는 응용 프로그램의 렌더링을 구성하는 Vulkan 자원 관리 및 명령 버퍼 빌드를 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b7f05deebe9bb637822744a5b69bc5080e3f22dd" translate="yes" xml:space="preserve">
          <source>Applications typically subclass both &lt;a href=&quot;qvulkanwindow&quot;&gt;QVulkanWindow&lt;/a&gt; and QVulkanWindowRenderer. The former allows handling events, for example, input, while the latter allows implementing the Vulkan resource management and command buffer building that make up the application's rendering.</source>
          <target state="translated">응용 프로그램은 일반적으로 &lt;a href=&quot;qvulkanwindow&quot;&gt;QVulkanWindow&lt;/a&gt; 와 QVulkanWindowRenderer를 모두 하위 클래스로 만듭니다. 전자는 입력과 같은 이벤트 처리를 허용하는 반면 후자는 애플리케이션의 렌더링을 구성하는 Vulkan 리소스 관리 및 명령 버퍼 구축을 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5dbb644ec321c502bbcdb383add66b0077763218" translate="yes" xml:space="preserve">
          <source>Applications using Qt WebEngine are not compatible with the Mac App Store, because:</source>
          <target state="translated">Qt WebEngine을 사용하는 응용 프로그램은 다음과 같은 이유로 Mac App Store와 호환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="47ddb28194a7d5e0a4f541b14d76165df576b59a" translate="yes" xml:space="preserve">
          <source>Applications using Qt XML Patterns are subject to the same limitations of software as other systems. Generally, these can not be checked. This means Qt XML Patterns does not prevent rogue queries from consuming too many resources. For example, a query could take too much time to execute or try to transfer too much data. A query could also do too much recursion, which could crash the system. XQueries can do these things accidentally, but they can also be done as deliberate denial of service attacks.</source>
          <target state="translated">Qt XML 패턴을 사용하는 응용 프로그램은 다른 시스템과 동일한 소프트웨어 제한 사항이 적용됩니다. 일반적으로 확인할 수 없습니다. 이는 Qt XML 패턴이 불량 쿼리가 너무 많은 리소스를 소비하는 것을 방해하지 않음을 의미합니다. 예를 들어 쿼리를 실행하는 데 시간이 너무 오래 걸리거나 너무 많은 데이터를 전송하려고 할 수 있습니다. 쿼리는 너무 많은 재귀를 수행하여 시스템을 중단시킬 수 있습니다. XQueries는 실수로 이러한 작업을 수행 할 수 있지만 의도적 인 서비스 거부 공격으로 수행 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2a5a2d4c29949b7fe6ee2de6905bb4ee56ab2aa" translate="yes" xml:space="preserve">
          <source>Applications using UI designs with fixed coordinates look small. The combination of font size specification in points and other sizes in pixels is particularly problematic since points are independent of the monitor resolution. For example, a frame of 40x20 pixels around the text &quot;hello&quot; using a 12pt font looks correct on low resolution monitors, but the frame will be too small on high DPI monitors, causing the text to be clipped.</source>
          <target state="translated">고정 좌표로 UI 디자인을 사용하는 응용 프로그램은 작게 보입니다. 포인트의 글꼴 크기 지정과 픽셀의 다른 크기의 조합은 포인트가 모니터 해상도와 무관하므로 특히 문제가됩니다. 예를 들어, 12pt 글꼴을 사용하는 텍스트 &quot;hello&quot;주위의 40x20 픽셀 프레임은 저해상도 모니터에서 올바르게 보이지만 고해상도 DPI 모니터에서는 프레임이 너무 작아서 텍스트가 잘립니다.</target>
        </trans-unit>
        <trans-unit id="380bc95783790db84b1676f9fd59fcdb97de0dd1" translate="yes" xml:space="preserve">
          <source>Applications which uses the &lt;a href=&quot;qml-qtpurchasing-store#restorePurchases-method&quot;&gt;restorePurchases()&lt;/a&gt; function should include this handler in all unlockable products. In the handler, the application should make sure information about the purchase is stored and call &lt;a href=&quot;qml-qtpurchasing-transaction#finalize-method&quot;&gt;finalize()&lt;/a&gt; on the</source>
          <target state="translated">&lt;a href=&quot;qml-qtpurchasing-store#restorePurchases-method&quot;&gt;restorePurchases ()&lt;/a&gt; 함수 를 사용하는 응용 프로그램은 잠금 해제 가능한 모든 제품에이 핸들러를 포함해야합니다. 핸들러에서, 응용 프로그램이 저장되어 구입 및 통화에 대한 확인 정보를 확인해야합니다 &lt;a href=&quot;qml-qtpurchasing-transaction#finalize-method&quot;&gt;마무리 ()&lt;/a&gt; 온을</target>
        </trans-unit>
        <trans-unit id="0521744f52d365e3307bd93bcc82758be330e281" translate="yes" xml:space="preserve">
          <source>Applications which want to define custom MIME types need to install an XML file into the locations searched for MIME definitions. These locations can be queried with</source>
          <target state="translated">사용자 정의 MIME 유형을 정의하려는 응용 프로그램은 MIME 정의를 검색 한 위치에 XML 파일을 설치해야합니다. 이 위치는</target>
        </trans-unit>
        <trans-unit id="643c58c67234f5f4367ed166266328a7e31f29f5" translate="yes" xml:space="preserve">
          <source>Applications will usually have to connect to 4 important signals:</source>
          <target state="translated">응용 프로그램은 일반적으로 4 가지 중요한 신호에 연결해야합니다.</target>
        </trans-unit>
        <trans-unit id="0711de7e63fd4cf8f347d6cb036f7d714a9cf56d" translate="yes" xml:space="preserve">
          <source>Applications wishing to always run with a single given graphics API can request this via the &lt;code&gt;QSG_RHI_BACKEND&lt;/code&gt; enivronment variable, as well as with C++. For example, the following call made early in &lt;code&gt;main()&lt;/code&gt;, before constructing any &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt;, forces the use of Vulkan (and will fail otherwise).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="babf61dac57128eb981dbafd32df81d9ad51d6ff" translate="yes" xml:space="preserve">
          <source>Applications wishing to always run with a single given graphics API, can request this via C++ as well. For example, the following call made early in main(), before constructing any &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt;, forces the use of Vulkan (and will fail otherwise):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e4324a610ae8da50df3c610e78aa18db2c97ff1" translate="yes" xml:space="preserve">
          <source>Applications wishing to always run with a single given graphics API, can request this via C++ as well. For example, the following call made early in main(), before constructing any &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt;, forces the use of Vulkan (and will fail otherwise);</source>
          <target state="translated">항상 주어진 단일 그래픽 API로 실행하려는 애플리케이션은 C ++를 통해이를 요청할 수도 있습니다. 예를 들어, &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt; 를 생성하기 전에 main () 초기에 다음 호출이 수행 되면 Vulkan을 강제로 사용하고 그렇지 않으면 실패합니다.</target>
        </trans-unit>
        <trans-unit id="b35b605509788df3a9d880763122cf2f62fc55a4" translate="yes" xml:space="preserve">
          <source>Applications with a monochrome background should set it using &lt;a href=&quot;qquickwindow#color-prop&quot;&gt;QQuickWindow::setColor&lt;/a&gt;() rather than using a top-level Rectangle item. &lt;a href=&quot;qquickwindow#color-prop&quot;&gt;QQuickWindow::setColor&lt;/a&gt;() will be used in a call to &lt;code&gt;glClear()&lt;/code&gt;, which is potentially faster.</source>
          <target state="translated">단색 배경의 응용 프로그램은 최상위 Rectangle 항목을 사용하는 대신 &lt;a href=&quot;qquickwindow#color-prop&quot;&gt;QQuickWindow :: setColor&lt;/a&gt; ()를 사용하여 설정해야합니다 . &lt;a href=&quot;qquickwindow#color-prop&quot;&gt;QQuickWindow :: setColor&lt;/a&gt; ()는 &lt;code&gt;glClear()&lt;/code&gt; 호출에 사용되며 잠재적으로 더 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="438d6d1831736d014296c8d54a1b862dfdba748d" translate="yes" xml:space="preserve">
          <source>ApplicationsLocation</source>
          <target state="translated">ApplicationsLocation</target>
        </trans-unit>
        <trans-unit id="1d46e73504253261f8b269d5dbc0432ad20874f5" translate="yes" xml:space="preserve">
          <source>Applies</source>
          <target state="translated">Applies</target>
        </trans-unit>
        <trans-unit id="866badc20ca4d7b59d2c8e8252dd02e41bd75f15" translate="yes" xml:space="preserve">
          <source>Applies a blur effect with a varying intesity</source>
          <target state="translated">다양한 인티 티로 흐림 효과를 적용합니다</target>
        </trans-unit>
        <trans-unit id="4fd15aa7f69872ceb66c170f8b521a185f792fdf" translate="yes" xml:space="preserve">
          <source>Applies a blur effect with a varying intesity. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">다양한 인티 저로 흐림 효과를 적용합니다. &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2c0dc4a3e6cf0dcbfd303c3f99a11aa53a0dbcac" translate="yes" xml:space="preserve">
          <source>Applies a change to the document. This function must be implemented in the derived class. Calling &lt;a href=&quot;qundostack#push&quot;&gt;QUndoStack::push&lt;/a&gt;(), &lt;a href=&quot;qundostack#undo&quot;&gt;QUndoStack::undo&lt;/a&gt;() or &lt;a href=&quot;qundostack#redo&quot;&gt;QUndoStack::redo&lt;/a&gt;() from this function leads to undefined beahavior.</source>
          <target state="translated">문서에 변경 사항을 적용합니다. 이 함수는 파생 클래스에서 구현해야합니다. 호출 &lt;a href=&quot;qundostack#push&quot;&gt;QUndoStack :: 푸시&lt;/a&gt; (), &lt;a href=&quot;qundostack#undo&quot;&gt;QUndoStack :: 실행 취소&lt;/a&gt; () 또는 &lt;a href=&quot;qundostack#redo&quot;&gt;QUndoStack :: 리두&lt;/a&gt; 정의되지 않은 beahavior이 기능 리드에서을 ().</target>
        </trans-unit>
        <trans-unit id="130096e9d49176b1a46e06394e6e99004a4b027a" translate="yes" xml:space="preserve">
          <source>Applies a fast blur effect to one or more source items</source>
          <target state="translated">하나 이상의 소스 항목에 빠른 흐림 효과를 적용합니다</target>
        </trans-unit>
        <trans-unit id="35a1caff37bd4683d67fb3d65b6b7d00af7d5f9c" translate="yes" xml:space="preserve">
          <source>Applies a fast blur effect to one or more source items. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">하나 이상의 소스 항목에 빠른 흐림 효과를 적용합니다. &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5ae4ebb1121d0eab057488fbbc33a0f69f24b70d" translate="yes" xml:space="preserve">
          <source>Applies a higher quality blur effect</source>
          <target state="translated">더 높은 품질의 흐림 효과를 적용합니다</target>
        </trans-unit>
        <trans-unit id="ea65603eef710f0893a7d775de55f9147e6d4996" translate="yes" xml:space="preserve">
          <source>Applies a higher quality blur effect. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">더 높은 품질의 흐림 효과를 적용합니다. &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8f684381c852d2c9db98d6a25eff451aee18f09a" translate="yes" xml:space="preserve">
          <source>Applies alterations to the attributes of logical particles at any point in their lifetime. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">수명 중 언제든지 논리 입자의 속성에 변경 사항을 적용합니다. &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0a0f1851b37b25fc017626674dee0c14196cf6a0" translate="yes" xml:space="preserve">
          <source>Applies blur effect to the specified direction</source>
          <target state="translated">지정된 방향으로 흐림 효과를 적용합니다</target>
        </trans-unit>
        <trans-unit id="e9fb2d57667df6bf937b731698c98a99872d16a5" translate="yes" xml:space="preserve">
          <source>Applies blur effect to the specified direction. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">지정된 방향으로 흐림 효과를 적용합니다. &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2375a9296e06ee3ef9a341df4824e9ae9faba052" translate="yes" xml:space="preserve">
          <source>Applies custom shaders to a rectangle. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">커스텀 셰이더를 사각형에 적용합니다. &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f701de2b3385c7371ffd9cb491289012e2f92ee9" translate="yes" xml:space="preserve">
          <source>Applies directional blur effect towards source items center point</source>
          <target state="translated">소스 항목 중심점으로 방향 흐림 효과를 적용합니다</target>
        </trans-unit>
        <trans-unit id="3d53a560cc390357ae0e7ff09ee2b4afad91fcfd" translate="yes" xml:space="preserve">
          <source>Applies directional blur effect towards source items center point. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">소스 항목 중심점을 향한 방향 흐림 효과를 적용합니다. &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0375ce8613278b8810ba2dd94f90724c703fbb59" translate="yes" xml:space="preserve">
          <source>Applies directional blur in a circular direction around the items center point</source>
          <target state="translated">항목 중심점 주위에 원형 방향으로 방향성 흐림 효과를 적용합니다</target>
        </trans-unit>
        <trans-unit id="976ce34010e87136dba4df813878be42eed3763c" translate="yes" xml:space="preserve">
          <source>Applies directional blur in a circular direction around the items center point. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">항목 중심점 주위에 원형 방향으로 방향 흐림을 적용합니다. &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b54e2077e74673a2d0dc0953d8710eaa1e87ffdc" translate="yes" xml:space="preserve">
          <source>Applies only to axes that support minor grid lines.</source>
          <target state="translated">작은 그리드 선을 지원하는 축에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="277870d1f2dd450ab431f72aad0ac4d9b775c11c" translate="yes" xml:space="preserve">
          <source>Applies the &lt;a href=&quot;qregion#intersected&quot;&gt;intersected&lt;/a&gt;() function to this region and</source>
          <target state="translated">이 영역에 &lt;a href=&quot;qregion#intersected&quot;&gt;교차&lt;/a&gt; () 함수를 적용 하고</target>
        </trans-unit>
        <trans-unit id="85f9bb66b0d768a797a0cbe1dd827879ca63fe9a" translate="yes" xml:space="preserve">
          <source>Applies the &lt;a href=&quot;qregion#subtracted&quot;&gt;subtracted&lt;/a&gt;() function to this region and</source>
          <target state="translated">적용 &lt;a href=&quot;qregion#subtracted&quot;&gt;감산&lt;/a&gt; 이 영역 () 함수 및</target>
        </trans-unit>
        <trans-unit id="c9e444215913626b026e8a170e34d8527f76b5dc" translate="yes" xml:space="preserve">
          <source>Applies the &lt;a href=&quot;qregion#united&quot;&gt;united&lt;/a&gt;() function to this region and</source>
          <target state="translated">이 지역에 &lt;a href=&quot;qregion#united&quot;&gt;united&lt;/a&gt; () 함수를 적용 하고</target>
        </trans-unit>
        <trans-unit id="9743edf949aafc1468bf758297f81e0fb0c8a64f" translate="yes" xml:space="preserve">
          <source>Applies the &lt;a href=&quot;qregion#xored&quot;&gt;xored&lt;/a&gt;() function to this region and</source>
          <target state="translated">적용 &lt;a href=&quot;qregion#xored&quot;&gt;XOR 연산&lt;/a&gt; 이 영역 () 함수 및</target>
        </trans-unit>
        <trans-unit id="cef16531f6c2160848c6a1494a7cbd190894a001" translate="yes" xml:space="preserve">
          <source>Applies the color transformation</source>
          <target state="translated">색상 변환을 적용합니다.</target>
        </trans-unit>
        <trans-unit id="753464780ddf2c6825acd60178943280e96d1b75" translate="yes" xml:space="preserve">
          <source>Applies the color transformation on the &lt;a href=&quot;qcolor&quot;&gt;QColor&lt;/a&gt; value</source>
          <target state="translated">&lt;a href=&quot;qcolor&quot;&gt;QColor&lt;/a&gt; 값 에 색상 변환을 적용합니다.</target>
        </trans-unit>
        <trans-unit id="7c0dcb37ae44ee69fd69efc0bf56c630c3eed748" translate="yes" xml:space="preserve">
          <source>Applies the color transformation on the &lt;a href=&quot;qcolor#QRgb-typedef&quot;&gt;QRgb&lt;/a&gt; value</source>
          <target state="translated">&lt;a href=&quot;qcolor#QRgb-typedef&quot;&gt;QRgb&lt;/a&gt; 값 에 색상 변환을 적용합니다.</target>
        </trans-unit>
        <trans-unit id="4c5834df3cd118d6b9c5a7910f67a66ef399297a" translate="yes" xml:space="preserve">
          <source>Applies the color transformation on the &lt;a href=&quot;qrgba64&quot;&gt;QRgba64&lt;/a&gt; value</source>
          <target state="translated">&lt;a href=&quot;qrgba64&quot;&gt;QRgba64&lt;/a&gt; 값 에 색상 변환을 적용합니다.</target>
        </trans-unit>
        <trans-unit id="88c849d9dd2f98b402af18dbc16b9606bda5c474" translate="yes" xml:space="preserve">
          <source>Applies the selection</source>
          <target state="translated">선택을 적용합니다</target>
        </trans-unit>
        <trans-unit id="3e9dec7a713118d0fe5ca4145b6a21f722bf2476" translate="yes" xml:space="preserve">
          <source>Applies to back faces only</source>
          <target state="translated">뒷면에만 적용</target>
        </trans-unit>
        <trans-unit id="fbc53c7806ce9f153b11dc54d231549a4c66e5df" translate="yes" xml:space="preserve">
          <source>Applies to front and back faces</source>
          <target state="translated">앞면과 뒷면에 적용</target>
        </trans-unit>
        <trans-unit id="67fcbacb3275d7f52800551c1d2d7bad6ccf9f66" translate="yes" xml:space="preserve">
          <source>Applies to front faces only</source>
          <target state="translated">앞면에만 적용</target>
        </trans-unit>
        <trans-unit id="cfea419c3b4e8b02ee586e70a28bf846e44cdda4" translate="yes" xml:space="preserve">
          <source>Apply</source>
          <target state="translated">Apply</target>
        </trans-unit>
        <trans-unit id="124d154be5d93423a75f4602bfc8a159c416aeb0" translate="yes" xml:space="preserve">
          <source>Apply Location, Rotation, and Scale</source>
          <target state="translated">위치, 회전 및 배율 적용</target>
        </trans-unit>
        <trans-unit id="16711b6efd8ea96c8782439f671909aa55f27759" translate="yes" xml:space="preserve">
          <source>Apply all automatic formatting. Currently only automatic bullet lists are supported.</source>
          <target state="translated">모든 자동 서식을 적용하십시오. 현재 자동 글 머리 기호 목록 만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="8f05fa95714c5c89e20a4978d13028c3da7f56c4" translate="yes" xml:space="preserve">
          <source>Apply an adjustable bloom effect to very bright areas (like the sun glinting off a car).</source>
          <target state="translated">조정 가능한 블룸 효과를 매우 밝은 영역에 적용합니다 (예 : 자동차에서 햇빛이 반짝임).</target>
        </trans-unit>
        <trans-unit id="9502ac0373000c8701724e89336c56dd0f6df065" translate="yes" xml:space="preserve">
          <source>Apply this macro to declarations of member functions to allow them to be invoked via the meta-object system. The macro is written before the return type, as shown in the following example:</source>
          <target state="translated">이 매크로를 멤버 함수 선언에 적용하여 메타 오브젝트 시스템을 통해 호출 할 수 있도록하십시오. 다음 예제와 같이 매크로는 반환 유형 앞에 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="4cbb382a462106b7b4d33047fe5aaa2c87a3481f" translate="yes" xml:space="preserve">
          <source>Apply this macro to declarations of member functions to tag them with a revision number in the meta-object system. The macro is written before the return type, as shown in the following example:</source>
          <target state="translated">이 매크로를 멤버 함수 선언에 적용하여 메타 오브젝트 시스템에서 수정 번호로 태그를 지정하십시오. 다음 예제와 같이 매크로는 반환 유형 앞에 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="fa0d8b3d88dd6fa3a35289a463840d4c4508d5d0" translate="yes" xml:space="preserve">
          <source>Applying an adjustable bloom effect to bright areas (like the sun glinting off a car).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="476a543e021c8a81c9d9ab17f8fe1dd834f78c91" translate="yes" xml:space="preserve">
          <source>Applying mirroring in this manner does not change the actual value of the relevant anchor, &lt;code&gt;layoutDirection&lt;/code&gt; or &lt;code&gt;horizontalAlignment&lt;/code&gt; properties. The separate read-only property &lt;code&gt;effectiveLayoutDirection&lt;/code&gt; can be used to query the effective layout direction of positioners and model views that takes the mirroring into account. Similarly the &lt;a href=&quot;qml-qtquick-text&quot;&gt;Text&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-textinput&quot;&gt;TextInput&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-textedit&quot;&gt;TextEdit&lt;/a&gt; types have gained the read-only property &lt;code&gt;effectiveHorizontalAlignment&lt;/code&gt; for querying the effective visual alignment of text. For anchors, the read only &lt;a href=&quot;qml-qtquick-item#anchors.top-prop&quot;&gt;anchors.mirrored&lt;/a&gt; property reflects whether anchors have been mirrored.</source>
          <target state="translated">이러한 방식으로 미러링을 적용해도 관련 앵커, &lt;code&gt;layoutDirection&lt;/code&gt; 또는 &lt;code&gt;horizontalAlignment&lt;/code&gt; 속성 의 실제 값은 변경되지 않습니다 . 별도의 읽기 전용 속성 인 &lt;code&gt;effectiveLayoutDirection&lt;/code&gt; 을 사용하여 미러링을 고려한 포지셔너 및 모델 뷰의 효과적인 레이아웃 방향을 쿼리 할 수 ​​있습니다. 마찬가지로 &lt;a href=&quot;qml-qtquick-text&quot;&gt;Text&lt;/a&gt; , &lt;a href=&quot;qml-qtquick-textinput&quot;&gt;TextInput&lt;/a&gt; 및 &lt;a href=&quot;qml-qtquick-textedit&quot;&gt;TextEdit&lt;/a&gt; 형식은 텍스트 의 효과적인 시각적 정렬을 쿼리하기 위해 읽기 전용 속성 인 &lt;code&gt;effectiveHorizontalAlignment&lt;/code&gt; 를 얻었습니다 . 앵커의 경우 읽기 전용 &lt;a href=&quot;qml-qtquick-item#anchors.top-prop&quot;&gt;anchors.mirrored&lt;/a&gt; 속성은 앵커가 미러링되었는지 여부를 반영합니다.</target>
        </trans-unit>
        <trans-unit id="fba446e866948fe090bc99358baa64d4a742d932" translate="yes" xml:space="preserve">
          <source>Applying the &lt;code&gt;[1]&lt;/code&gt; filter to the &lt;code&gt;/span&lt;/code&gt; step returns the first &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; element of each &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; element:</source>
          <target state="translated">&lt;code&gt;[1]&lt;/code&gt; 필터를 &lt;code&gt;/span&lt;/code&gt; 단계에 적용하면 각 &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; 요소 의 첫 번째 &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; 요소가 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="0fb430ba25263f888bcf3248bc77f0367ac365c1" translate="yes" xml:space="preserve">
          <source>Applying transform values resets the object's location, rotation, and scale values. Location and rotation values are changed to 0 while scale values are changed to 1. The object itself does not visually change.</source>
          <target state="translated">변형 값을 적용하면 오브젝트의 위치, 회전 및 배율 값이 재설정됩니다. 위치 및 회전 값은 0으로 변경되고 배율 값은 1로 변경됩니다. 개체 자체는 시각적으로 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="451cefdac5dd0124a1e28cab04fd9c1054424a49" translate="yes" xml:space="preserve">
          <source>Approaches to Binding Values</source>
          <target state="translated">바인딩 값에 대한 접근</target>
        </trans-unit>
        <trans-unit id="69be4bf88eeab6713e92fc9f8e3d6d37f1982528" translate="yes" xml:space="preserve">
          <source>April (3)</source>
          <target state="translated">4 월 (3)</target>
        </trans-unit>
        <trans-unit id="644abaa7258ab02f926a338360e1d1d6895f953c" translate="yes" xml:space="preserve">
          <source>Aqua</source>
          <target state="translated">Aqua</target>
        </trans-unit>
        <trans-unit id="2d91dd4d3929f64eb1b05b72cf83115c9f95c550" translate="yes" xml:space="preserve">
          <source>Aqua is an essential part of the macOS platform. As with Cocoa and Carbon, Qt provides widgets that look like those described in the Human Interface Descriptions. Qt's widgets use HIThemes to implement the look and feel. In other words, we use Apple's own APIs for doing the rendering. More documentation about Aqua is found at the macOS Human Interface Guidelines.</source>
          <target state="translated">아쿠아는 macOS 플랫폼의 필수 부분입니다. 코코아 및 카본과 마찬가지로 Qt는 휴먼 인터페이스 설명에 설명 된 것과 유사한 위젯을 제공합니다. Qt의 위젯은 HIThemes를 사용하여 모양과 느낌을 구현합니다. 즉, 렌더링을 수행하기 위해 Apple의 자체 API를 사용합니다. 아쿠아에 대한 추가 문서는 macOS 휴먼 인터페이스 지침에 있습니다.</target>
        </trans-unit>
        <trans-unit id="af4f4762f9bd3f0f4a10caf5b6e63dc4ce543724" translate="yes" xml:space="preserve">
          <source>Arabic</source>
          <target state="translated">Arabic</target>
        </trans-unit>
        <trans-unit id="d5c9a17b4395c52e43c58e3f041e32d12c8e4497" translate="yes" xml:space="preserve">
          <source>Arabic Layout</source>
          <target state="translated">아랍어 레이아웃</target>
        </trans-unit>
        <trans-unit id="4c41d518fdc3d17322018b87c66d135e50d626a1" translate="yes" xml:space="preserve">
          <source>Arabic input mode.</source>
          <target state="translated">아랍어 입력 모드.</target>
        </trans-unit>
        <trans-unit id="a1fff8708561b49f1a3307ef00025f8d5b7fb8e3" translate="yes" xml:space="preserve">
          <source>Arbitrary data can be represented as properties on the &lt;a href=&quot;qabstractvideofilter&quot;&gt;QAbstractVideoFilter&lt;/a&gt; subclass and on the &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; or &lt;a href=&quot;qjsvalue&quot;&gt;QJSValue&lt;/a&gt; instances passed to its signals. What exactly these properties and signals are, is up to the individual video filters. Completion of the operations can be indicated by signals. Computations that do not result in a modified image will pass the input image through so that subsequent filters can be placed after them.</source>
          <target state="translated">임의의 데이터는 &lt;a href=&quot;qabstractvideofilter&quot;&gt;QAbstractVideoFilter&lt;/a&gt; 서브 클래스 및 해당 신호에 전달 된 &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 또는 &lt;a href=&quot;qjsvalue&quot;&gt;QJSValue&lt;/a&gt; 인스턴스의 특성으로 표시 될 수 있습니다 . 이러한 속성과 신호는 정확히 개별 비디오 필터에 달려 있습니다. 작업 완료는 신호로 표시 될 수 있습니다. 수정 된 이미지를 생성하지 않는 계산은 입력 이미지를 통과하여 후속 필터를 배치 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3067ac0b4e28e4267b730ff7b4cc2aa510ccd43d" translate="yes" xml:space="preserve">
          <source>Arbitrary data can be represented as properties on the QAbstractVideoFilter subclass and on the &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; or &lt;a href=&quot;qjsvalue&quot;&gt;QJSValue&lt;/a&gt; instances passed to its signals. What exactly these properties and signals are, is up to the individual video filters. Completion of the operations can be indicated by signals. Computations that do not result in a modified image will pass the input image through so that subsequent filters can be placed after them.</source>
          <target state="translated">임의 데이터는 QAbstractVideoFilter 하위 클래스와 신호에 전달 된 &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 또는 &lt;a href=&quot;qjsvalue&quot;&gt;QJSValue&lt;/a&gt; 인스턴스의 속성으로 표시 될 수 있습니다 . 이러한 속성과 신호가 정확히 무엇인지는 개별 비디오 필터에 달려 있습니다. 작업 완료는 신호로 표시 할 수 있습니다. 수정 된 이미지를 생성하지 않는 계산은 입력 이미지를 통과하여 후속 필터가 그 뒤에 배치 될 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="fa2701072f67f3cbdf7c24b7d3d52105f4ae3ff2" translate="yes" xml:space="preserve">
          <source>Arbitrary simple values</source>
          <target state="translated">임의의 간단한 값</target>
        </trans-unit>
        <trans-unit id="479ffb29f16c0d45fca6818b1d1543d24f691407" translate="yes" xml:space="preserve">
          <source>ArchData</source>
          <target state="translated">ArchData</target>
        </trans-unit>
        <trans-unit id="b040b4179b8b00702858fdb4c1afec3d6d284509" translate="yes" xml:space="preserve">
          <source>Architecture</source>
          <target state="translated">Architecture</target>
        </trans-unit>
        <trans-unit id="a10f3b5aa08c9646632d8e35bf3374804be6df80" translate="yes" xml:space="preserve">
          <source>Architectures</source>
          <target state="translated">Architectures</target>
        </trans-unit>
        <trans-unit id="2745debaa64a20eedb49d9f14a0b807c87aa2d2a" translate="yes" xml:space="preserve">
          <source>Area</source>
          <target state="translated">Area</target>
        </trans-unit>
        <trans-unit id="535b9a2f1700c0937442185b5600be479b6a9cf4" translate="yes" xml:space="preserve">
          <source>Area containing the label (icon with text or pixmap).</source>
          <target state="translated">레이블이 포함 된 영역 (텍스트 또는 픽스맵이있는 아이콘)</target>
        </trans-unit>
        <trans-unit id="3ec6abab8a9a760983d28530991e834f769f7923" translate="yes" xml:space="preserve">
          <source>Area for a frame's contents using the shape in &lt;a href=&quot;qstyleoptionframe&quot;&gt;QStyleOptionFrame&lt;/a&gt;; see &lt;a href=&quot;qframe&quot;&gt;QFrame&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;qstyleoptionframe&quot;&gt;QStyleOptionFrame&lt;/a&gt; 의 모양을 사용하여 프레임의 내용 영역입니다 . &lt;a href=&quot;qframe&quot;&gt;QFrame&lt;/a&gt; 참조</target>
        </trans-unit>
        <trans-unit id="5bd1fe1ed390abf0c32ec5cff51aefc721d0619c" translate="yes" xml:space="preserve">
          <source>Area for a frame's contents.</source>
          <target state="translated">프레임 내용의 영역입니다.</target>
        </trans-unit>
        <trans-unit id="996cbef1591c035a58ca746148709b27c620fa4c" translate="yes" xml:space="preserve">
          <source>Area for a line edit's contents.</source>
          <target state="translated">라인 편집 내용의 영역입니다.</target>
        </trans-unit>
        <trans-unit id="49d625f2177641e83922107fa8fe0945c1a234ac" translate="yes" xml:space="preserve">
          <source>Area for a toolbox tab's icon and label.</source>
          <target state="translated">도구 상자 탭의 아이콘 및 레이블 영역.</target>
        </trans-unit>
        <trans-unit id="38039cebc9a972903879e00ec75b44c25bcac759" translate="yes" xml:space="preserve">
          <source>Area for a view item's check mark.</source>
          <target state="translated">보기 항목의 확인 표시 영역.</target>
        </trans-unit>
        <trans-unit id="45a206cb54f2e2e7c7088d52bc80d8c3f70d71f2" translate="yes" xml:space="preserve">
          <source>Area for a view item's decoration (icon).</source>
          <target state="translated">보기 항목의 장식 영역 (아이콘).</target>
        </trans-unit>
        <trans-unit id="c15c344347ca6330e5a3e4b9a6a791a3eb072540" translate="yes" xml:space="preserve">
          <source>Area for a view item's focus rect.</source>
          <target state="translated">뷰 항목의 포커스 rect 영역입니다.</target>
        </trans-unit>
        <trans-unit id="a71210b90ac09cb96b804c1b99fce169916fd2e3" translate="yes" xml:space="preserve">
          <source>Area for a view item's text.</source>
          <target state="translated">보기 항목의 텍스트 영역입니다.</target>
        </trans-unit>
        <trans-unit id="c13c2fc8f77c8fac60c5301fb7aff26d7bf46de1" translate="yes" xml:space="preserve">
          <source>Area for a widget on the left side of a tab in a tab bar.</source>
          <target state="translated">탭 막대의 탭 왼쪽에있는 위젯 영역입니다.</target>
        </trans-unit>
        <trans-unit id="d149dee448fb590f234c497fe4a512c07a797416" translate="yes" xml:space="preserve">
          <source>Area for a widget on the right side of a tab in a tab bar.</source>
          <target state="translated">탭 막대의 탭 오른쪽에있는 위젯 영역.</target>
        </trans-unit>
        <trans-unit id="b22560181ca881597d004e6fcb18b916d937f69f" translate="yes" xml:space="preserve">
          <source>Area for the actual disclosure item in a tree branch.</source>
          <target state="translated">트리 분기의 실제 공개 항목 영역.</target>
        </trans-unit>
        <trans-unit id="606a1d29814a7245a7c24bcf223ba372fb9da815" translate="yes" xml:space="preserve">
          <source>Area for the contents of the tab widget.</source>
          <target state="translated">탭 위젯의 컨텐츠 영역.</target>
        </trans-unit>
        <trans-unit id="6fcd28540d30cc262211b77e0c45ed166ba05a4f" translate="yes" xml:space="preserve">
          <source>Area for the focus indicator.</source>
          <target state="translated">초점 표시 영역.</target>
        </trans-unit>
        <trans-unit id="1ecd2bd4ef6aaaa02323b7b4dc790d554c0186af" translate="yes" xml:space="preserve">
          <source>Area for the focus rect (usually larger than the contents rect).</source>
          <target state="translated">초점 rect 영역 (보통 내용 rect보다 큼).</target>
        </trans-unit>
        <trans-unit id="e69799701a78a828138095c10e3057576ccfe936" translate="yes" xml:space="preserve">
          <source>Area for the groove.</source>
          <target state="translated">그루브 영역.</target>
        </trans-unit>
        <trans-unit id="f23c53c39dfb3b6826222d61a5977ae62f20d93d" translate="yes" xml:space="preserve">
          <source>Area for the handle of a tool bar.</source>
          <target state="translated">툴바의 핸들 영역.</target>
        </trans-unit>
        <trans-unit id="c01b59bd91f53365fa18f3a47828f70d86ea3b17" translate="yes" xml:space="preserve">
          <source>Area for the label (text or pixmap).</source>
          <target state="translated">레이블 영역 (텍스트 또는 픽스맵).</target>
        </trans-unit>
        <trans-unit id="ca3bcf5d68aff0bc2816cff2bbf7d5e84ffdc0cd" translate="yes" xml:space="preserve">
          <source>Area for the label in a header.</source>
          <target state="translated">헤더의 레이블 영역입니다.</target>
        </trans-unit>
        <trans-unit id="b65d786b45b3e5f45ec2bf0ccb6678ce3dadad85" translate="yes" xml:space="preserve">
          <source>Area for the label.</source>
          <target state="translated">라벨 영역.</target>
        </trans-unit>
        <trans-unit id="b13ecb0a287b3e2becd310e4ee5944b89c338cc2" translate="yes" xml:space="preserve">
          <source>Area for the left corner widget in a tab widget.</source>
          <target state="translated">탭 위젯에서 왼쪽 모서리 위젯의 영역입니다.</target>
        </trans-unit>
        <trans-unit id="3039dbda981933bcb4504aac23b93c739b39fd93" translate="yes" xml:space="preserve">
          <source>Area for the pane of a tab widget.</source>
          <target state="translated">탭 위젯 창의 영역입니다.</target>
        </trans-unit>
        <trans-unit id="39635be96b35976e4588212659d747676bb9f02d" translate="yes" xml:space="preserve">
          <source>Area for the progress indicator.</source>
          <target state="translated">진행률 표시기 영역.</target>
        </trans-unit>
        <trans-unit id="eeb6285f6cd1d450aa22bf4d4bec5a64af0702bc" translate="yes" xml:space="preserve">
          <source>Area for the right corner widget in a tab widget.</source>
          <target state="translated">탭 위젯의 오른쪽 모서리 위젯 영역입니다.</target>
        </trans-unit>
        <trans-unit id="ae81551ca03dbe2287beccf10b7efb541feea9ea" translate="yes" xml:space="preserve">
          <source>Area for the scroll left button on a tab bar with scroll buttons.</source>
          <target state="translated">스크롤 버튼이있는 탭 막대의 왼쪽 스크롤 버튼 영역입니다.</target>
        </trans-unit>
        <trans-unit id="3d088c29245d46a52e463d46dedf98531b02ecc4" translate="yes" xml:space="preserve">
          <source>Area for the scroll right button on a tab bar with scroll buttons.</source>
          <target state="translated">스크롤 버튼이있는 탭 표시 줄의 오른쪽 스크롤 버튼 영역.</target>
        </trans-unit>
        <trans-unit id="6cf0dbc08aaa6142fa399fca7bf284fdcc8feb99" translate="yes" xml:space="preserve">
          <source>Area for the sort indicator for a header.</source>
          <target state="translated">헤더의 정렬 표시기 영역입니다.</target>
        </trans-unit>
        <trans-unit id="09112dc0806c916e1f33d0927cc5a1ce510d2dea" translate="yes" xml:space="preserve">
          <source>Area for the state indicator (e.g., check mark).</source>
          <target state="translated">상태 표시기 영역 (예 : 확인 표시).</target>
        </trans-unit>
        <trans-unit id="e5920a1ea031d42ebf4c5174cb98e9517ab212d9" translate="yes" xml:space="preserve">
          <source>Area for the state indicator.</source>
          <target state="translated">상태 표시기의 영역.</target>
        </trans-unit>
        <trans-unit id="3f9b7423765460500b6a94cf583dd6ac4766da9e" translate="yes" xml:space="preserve">
          <source>Area for the tab bar widget in a tab widget.</source>
          <target state="translated">탭 위젯에서 탭 막대 위젯의 영역입니다.</target>
        </trans-unit>
        <trans-unit id="cfe80f8b3a44ae2160f72af5c86b6e1f0506540e" translate="yes" xml:space="preserve">
          <source>Area for the tear indicator on the left side of a tab bar with scroll arrows.</source>
          <target state="translated">스크롤 막대가있는 탭 막대의 왼쪽에있는 인열 표시기 영역입니다.</target>
        </trans-unit>
        <trans-unit id="d347bf554c04c8874a811982205338817ec79371" translate="yes" xml:space="preserve">
          <source>Area for the tear indicator on the right side of a tab bar with scroll arrows.</source>
          <target state="translated">스크롤 화살표가있는 탭 막대의 오른쪽에있는 인열 표시기 영역입니다.</target>
        </trans-unit>
        <trans-unit id="998ab79f788929e9b5839a5aed4f09093e3e8720" translate="yes" xml:space="preserve">
          <source>Area for the text label.</source>
          <target state="translated">텍스트 레이블의 영역입니다.</target>
        </trans-unit>
        <trans-unit id="21f689ba2ed61ac45fe27fb3d42434baded3fd85" translate="yes" xml:space="preserve">
          <source>Area for the text on a tab in a tab bar.</source>
          <target state="translated">탭 막대에서 탭의 텍스트 영역입니다.</target>
        </trans-unit>
        <trans-unit id="40d7de0a3812d9abd5c47796a043a6f0e1c85d4e" translate="yes" xml:space="preserve">
          <source>Area in which MDI windows are displayed</source>
          <target state="translated">MDI 창이 표시되는 영역</target>
        </trans-unit>
        <trans-unit id="5a3d757e88061f76b52e980cd1a554f9d06096f3" translate="yes" xml:space="preserve">
          <source>Area that counts for the parent layout.</source>
          <target state="translated">부모 레이아웃으로 계산되는 영역입니다.</target>
        </trans-unit>
        <trans-unit id="b3caa3c8a56c156caa83a295f21743b81c0e7e02" translate="yes" xml:space="preserve">
          <source>AreaLight (QML type)</source>
          <target state="translated">AreaLight (QML 유형)</target>
        </trans-unit>
        <trans-unit id="66c6c7b1c6c5a7e6fd50cacec9fd64cab4be32bd" translate="yes" xml:space="preserve">
          <source>AreaLight QML Type</source>
          <target state="translated">AreaLight QML 유형</target>
        </trans-unit>
        <trans-unit id="2c61171ab67536b90099c14b573d7a00c5ba5ea0" translate="yes" xml:space="preserve">
          <source>AreaLight.height</source>
          <target state="translated">AreaLight.height</target>
        </trans-unit>
        <trans-unit id="24d4b669aa6ff9d8863cd7f980bc571e53641075" translate="yes" xml:space="preserve">
          <source>AreaLight.width</source>
          <target state="translated">AreaLight.width</target>
        </trans-unit>
        <trans-unit id="e93aa9b9e374870c122e716b092248e4e80a303b" translate="yes" xml:space="preserve">
          <source>AreaSeries</source>
          <target state="translated">AreaSeries</target>
        </trans-unit>
        <trans-unit id="b87f5f9f05b6cfc0734e3463fd5f7fb7554362cb" translate="yes" xml:space="preserve">
          <source>AreaSeries (QML type)</source>
          <target state="translated">AreaSeries (QML 유형)</target>
        </trans-unit>
        <trans-unit id="c0cac81aee98155eaf540e28dbf266768a7e253a" translate="yes" xml:space="preserve">
          <source>AreaSeries QML Type</source>
          <target state="translated">AreaSeries QML 유형</target>
        </trans-unit>
        <trans-unit id="082c098d89b3e4390201d833c440f743796b0564" translate="yes" xml:space="preserve">
          <source>AreaSeries.axisAngular</source>
          <target state="translated">AreaSeries.axisAngular</target>
        </trans-unit>
        <trans-unit id="fee028d96d394ff4a51ccff98670410ed21a34d7" translate="yes" xml:space="preserve">
          <source>AreaSeries.axisRadial</source>
          <target state="translated">AreaSeries.axisRadial</target>
        </trans-unit>
        <trans-unit id="efc9c6b7fda89b66e30119f302bd72276c89d3c5" translate="yes" xml:space="preserve">
          <source>AreaSeries.axisX</source>
          <target state="translated">AreaSeries.axisX</target>
        </trans-unit>
        <trans-unit id="2d4c3476487185317a00c9e726baff7dda394cb8" translate="yes" xml:space="preserve">
          <source>AreaSeries.axisXTop</source>
          <target state="translated">AreaSeries.axisXTop</target>
        </trans-unit>
        <trans-unit id="4fa5d1de3ad3d15399e779b058a130d81995955f" translate="yes" xml:space="preserve">
          <source>AreaSeries.axisY</source>
          <target state="translated">AreaSeries.axisY</target>
        </trans-unit>
        <trans-unit id="cdc7d8432bcf7d70579992707186dac42ee475cd" translate="yes" xml:space="preserve">
          <source>AreaSeries.axisYRight</source>
          <target state="translated">AreaSeries.axisYRight</target>
        </trans-unit>
        <trans-unit id="e8ba7c149a49277c3a122eeca497f0d28ab61c32" translate="yes" xml:space="preserve">
          <source>AreaSeries.borderColor</source>
          <target state="translated">AreaSeries.borderColor</target>
        </trans-unit>
        <trans-unit id="1cc7f40779f9908ab2a2e265bc46c8bf15f362a6" translate="yes" xml:space="preserve">
          <source>AreaSeries.borderWidth</source>
          <target state="translated">AreaSeries.borderWidth</target>
        </trans-unit>
        <trans-unit id="6559de9df3daf9b75251aa7a8cf613040cc44fa0" translate="yes" xml:space="preserve">
          <source>AreaSeries.brush</source>
          <target state="translated">AreaSeries.brush</target>
        </trans-unit>
        <trans-unit id="1943573ba843b93576b7fcdea0c4fb11fbd96005" translate="yes" xml:space="preserve">
          <source>AreaSeries.brushFilename</source>
          <target state="translated">AreaSeries.brushFilename</target>
        </trans-unit>
        <trans-unit id="223c5417377c7cbb671cfbbc9d5a9a7ba7ccf83f" translate="yes" xml:space="preserve">
          <source>AreaSeries.clicked()</source>
          <target state="translated">AreaSeries.clicked()</target>
        </trans-unit>
        <trans-unit id="1b2951e0d4d24ce12c15b0f2efcdcfe2a5d0734c" translate="yes" xml:space="preserve">
          <source>AreaSeries.color</source>
          <target state="translated">AreaSeries.color</target>
        </trans-unit>
        <trans-unit id="27f9e34e748082203b16fef220f45bb36d34682b" translate="yes" xml:space="preserve">
          <source>AreaSeries.doubleClicked()</source>
          <target state="translated">AreaSeries.doubleClicked()</target>
        </trans-unit>
        <trans-unit id="19de277cccd3cba00c831f43a504a4f08a05a48a" translate="yes" xml:space="preserve">
          <source>AreaSeries.hovered()</source>
          <target state="translated">AreaSeries.hovered()</target>
        </trans-unit>
        <trans-unit id="9df8002f9f61b9cddbf2f8415dd6d47ca1595c2d" translate="yes" xml:space="preserve">
          <source>AreaSeries.lowerSeries</source>
          <target state="translated">AreaSeries.lowerSeries</target>
        </trans-unit>
        <trans-unit id="eeab19ab0b4b35b1ba4556670d75dcba50c4369b" translate="yes" xml:space="preserve">
          <source>AreaSeries.pointLabelsClipping</source>
          <target state="translated">AreaSeries.pointLabelsClipping</target>
        </trans-unit>
        <trans-unit id="386fc6e15ef1c63c5f220eb802ab892cfce51ff9" translate="yes" xml:space="preserve">
          <source>AreaSeries.pointLabelsColor</source>
          <target state="translated">AreaSeries.pointLabelsColor</target>
        </trans-unit>
        <trans-unit id="9bd6dbac99e9e14fc587b100f99576c092f10c9e" translate="yes" xml:space="preserve">
          <source>AreaSeries.pointLabelsFont</source>
          <target state="translated">AreaSeries.pointLabelsFont</target>
        </trans-unit>
        <trans-unit id="d9178cd1d5a2aff5519dfa119addac0dab96007f" translate="yes" xml:space="preserve">
          <source>AreaSeries.pointLabelsFormat</source>
          <target state="translated">AreaSeries.pointLabelsFormat</target>
        </trans-unit>
        <trans-unit id="7aab9ef51bb0d411fd6cc56a18cdeb40bae301e2" translate="yes" xml:space="preserve">
          <source>AreaSeries.pointLabelsVisible</source>
          <target state="translated">AreaSeries.pointLabelsVisible</target>
        </trans-unit>
        <trans-unit id="0da30bafeb2841f449ced3e210a2820744d84afc" translate="yes" xml:space="preserve">
          <source>AreaSeries.pressed()</source>
          <target state="translated">AreaSeries.pressed()</target>
        </trans-unit>
        <trans-unit id="6cec7cad3d8160a04a80a655326e7bcd23a65709" translate="yes" xml:space="preserve">
          <source>AreaSeries.released()</source>
          <target state="translated">AreaSeries.released()</target>
        </trans-unit>
        <trans-unit id="b2d3449ed77070c1aa0f6b29dd8bef8ff0b1948b" translate="yes" xml:space="preserve">
          <source>AreaSeries.upperSeries</source>
          <target state="translated">AreaSeries.upperSeries</target>
        </trans-unit>
        <trans-unit id="e082e8656ffbbf09ccdc4b5e8c037b9f54130ed3" translate="yes" xml:space="preserve">
          <source>Areas outside this will be transparent.</source>
          <target state="translated">이 영역 외부는 투명합니다.</target>
        </trans-unit>
        <trans-unit id="aab6ebe4bad7044325def8edcab950ba7ccad54d" translate="yes" xml:space="preserve">
          <source>Areas that the route must not cross.</source>
          <target state="translated">경로가 교차하지 않아야하는 영역</target>
        </trans-unit>
        <trans-unit id="ce5e5792e97fe5c7861d6ae9b29cf5a25cc0e70a" translate="yes" xml:space="preserve">
          <source>Argument</source>
          <target state="translated">Argument</target>
        </trans-unit>
        <trans-unit id="d94a8e1cd954b8b843be6463a70504f095a33fa0" translate="yes" xml:space="preserve">
          <source>Argument Formats</source>
          <target state="translated">인수 형식</target>
        </trans-unit>
        <trans-unit id="8d233a99b3c19dc229c1384324fe9612e1e81a99" translate="yes" xml:space="preserve">
          <source>Argument handling is identical to the respective &lt;a href=&quot;qprocess#start&quot;&gt;start&lt;/a&gt;() overload.</source>
          <target state="translated">인수 처리는 각각의 &lt;a href=&quot;qprocess#start&quot;&gt;시작&lt;/a&gt; () 과부하와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="cbb9fa252e60809efa55a7ad83aea5438ef56753" translate="yes" xml:space="preserve">
          <source>Arguments</source>
          <target state="translated">Arguments</target>
        </trans-unit>
        <trans-unit id="3d1ab73d494db068b278339299acc2d36f2e0210" translate="yes" xml:space="preserve">
          <source>Arguments are applied to back-facing polygons.</source>
          <target state="translated">인수는 뒷면 다각형에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="69c7e52bf2c1c5b609c1c72236dc5b854e008ecb" translate="yes" xml:space="preserve">
          <source>Arguments are applied to both front- and back-facing polygons.</source>
          <target state="translated">인수는 앞면 및 뒷면 다각형에 모두 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="59d63ba93e5c76bd18855d603fc091e8b843860d" translate="yes" xml:space="preserve">
          <source>Arguments are applied to front-facing polygons.</source>
          <target state="translated">인수는 전면 다각형에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="492f20b06638cc0bfa76f34df71f7cdfe6ddd9af" translate="yes" xml:space="preserve">
          <source>Arguments containing spaces must be quoted to be correctly supplied to the new process. For example:</source>
          <target state="translated">공백을 포함하는 인수는 새 프로세스에 올바르게 제공되도록 인용해야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="521ad937aa1f53eee397385106d065e03d4fd528" translate="yes" xml:space="preserve">
          <source>Armature</source>
          <target state="translated">Armature</target>
        </trans-unit>
        <trans-unit id="6f5f1e1355dbdb7e2edc9f0b1b8a1ea5f4efb8c8" translate="yes" xml:space="preserve">
          <source>Armature (QML type)</source>
          <target state="translated">전기자 (QML 유형)</target>
        </trans-unit>
        <trans-unit id="55ac82f94a41e19423c5b4c822d6090fdc7cd3b1" translate="yes" xml:space="preserve">
          <source>Armature QML Type</source>
          <target state="translated">전기자 QML 유형</target>
        </trans-unit>
        <trans-unit id="0448d89703712a541edda15d367fd809da8ac1d3" translate="yes" xml:space="preserve">
          <source>Armature.skeleton</source>
          <target state="translated">Armature.skeleton</target>
        </trans-unit>
        <trans-unit id="1a0d21145500640fd3f6136eeba595bfe934d364" translate="yes" xml:space="preserve">
          <source>Armenian</source>
          <target state="translated">Armenian</target>
        </trans-unit>
        <trans-unit id="41127ee8f7ab4f314142f165d2c9bc6558b3e351" translate="yes" xml:space="preserve">
          <source>Arrange elements to adhere to layout guidelines for different platforms.</source>
          <target state="translated">다른 플랫폼에 대한 레이아웃 지침을 준수하도록 요소를 배열하십시오.</target>
        </trans-unit>
        <trans-unit id="49775465a2662efa781833958f1606cec4319e36" translate="yes" xml:space="preserve">
          <source>Arranges all child windows in a tile pattern.</source>
          <target state="translated">모든 자식 창을 타일 패턴으로 정렬합니다.</target>
        </trans-unit>
        <trans-unit id="9ca9725a03114d31504328c6e0f24c2dc4218921" translate="yes" xml:space="preserve">
          <source>Arranges all the child windows in a cascade pattern.</source>
          <target state="translated">모든 자식 창을 계단식 패턴으로 배열합니다.</target>
        </trans-unit>
        <trans-unit id="107004472b7ba4e5e31f3082ee1fb5a1239eec61" translate="yes" xml:space="preserve">
          <source>Array</source>
          <target state="translated">Array</target>
        </trans-unit>
        <trans-unit id="6eb6467e007cb070adc85d58a09cd75d99be0f3c" translate="yes" xml:space="preserve">
          <source>Array Object</source>
          <target state="translated">배열 객체</target>
        </trans-unit>
        <trans-unit id="521d9c30534a654804e203a996e2583803023671" translate="yes" xml:space="preserve">
          <source>Array Objects</source>
          <target state="translated">배열 객체</target>
        </trans-unit>
        <trans-unit id="df1e485a44970093e89d987c652ebc18c9e3e534" translate="yes" xml:space="preserve">
          <source>Array Prototype Object</source>
          <target state="translated">배열 프로토 타입 객체</target>
        </trans-unit>
        <trans-unit id="df5eaaa07a6a7538a98bf3593e431703f3438b78" translate="yes" xml:space="preserve">
          <source>Array of bits</source>
          <target state="translated">비트 배열</target>
        </trans-unit>
        <trans-unit id="d7f9e14823a5f2ef4dcfd880e753267cfc281058" translate="yes" xml:space="preserve">
          <source>Array of bytes</source>
          <target state="translated">바이트 배열</target>
        </trans-unit>
        <trans-unit id="1b6bf23201e44d3b137865089f87083f36883d00" translate="yes" xml:space="preserve">
          <source>Array of range values as float point numbers. The value for the most detailed representation should be specified first.</source>
          <target state="translated">부동 소수점 숫자로 범위 값의 배열입니다. 가장 자세한 표현 값을 먼저 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="0047289ea45c5ac540ffeb8876e5f8bf8c711934" translate="yes" xml:space="preserve">
          <source>Array or Map</source>
          <target state="translated">배열 또는 맵</target>
        </trans-unit>
        <trans-unit id="0fc24b8b8b7122608af5aca9337f1476bfe952d8" translate="yes" xml:space="preserve">
          <source>Array, converted using QCborArray::formJsonArray()</source>
          <target state="translated">QCborArray :: formJsonArray ()를 사용하여 변환 된 배열</target>
        </trans-unit>
        <trans-unit id="2704c6d097885b6494eef2fc12c3cea109979946" translate="yes" xml:space="preserve">
          <source>Array, map and string lengths must be as short as possible. As above, &lt;a href=&quot;qcborstreamwriter&quot;&gt;QCborStreamWriter&lt;/a&gt; automatically does this.</source>
          <target state="translated">배열, 맵 및 문자열 길이는 가능한 짧아야합니다. 위와 같이 &lt;a href=&quot;qcborstreamwriter&quot;&gt;QCborStreamWriter가&lt;/a&gt; 자동으로이를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="d574dbe1420fbc3886d8508328989f5db00f1045" translate="yes" xml:space="preserve">
          <source>Array, map and string lengths must be as short as possible. As above, QCborStreamWriter automatically does this.</source>
          <target state="translated">배열, 맵 및 문자열 길이는 가능한 짧아야합니다. 위와 같이 QCborStreamWriter는이를 자동으로 수행합니다.</target>
        </trans-unit>
        <trans-unit id="95971ea269213b08d09c9553e6421bde178a5ca7" translate="yes" xml:space="preserve">
          <source>ArrayBuffer</source>
          <target state="translated">ArrayBuffer</target>
        </trans-unit>
        <trans-unit id="c3ee4aa92cf96bfba3d79f58e87e55f061989e7e" translate="yes" xml:space="preserve">
          <source>Arrays are sets of zero or more elements of the same type, while structures are a set of a fixed number of elements, each of any type. Maps or dictionaries are implemented as arrays of a pair of elements, so there can be zero or more elements in one map.</source>
          <target state="translated">배열은 동일한 유형의 0 개 이상의 요소 집합이며, 구조는 모든 유형의 고정 된 수의 요소 집합입니다. 지도 또는 사전은 한 쌍의 요소로 구성된 배열로 구현되므로 하나의지도에 0 개 이상의 요소가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="131ede22d0b614ba1e8e1c1d1f9d48cf630840ac" translate="yes" xml:space="preserve">
          <source>Arrays as well as pointers that have been allocated with &lt;code&gt;malloc&lt;/code&gt; must not be deleted using &lt;code&gt;delete&lt;/code&gt;. &lt;a href=&quot;qscopedpointer&quot;&gt;QScopedPointer&lt;/a&gt;'s second template parameter can be used for custom cleanup handlers.</source>
          <target state="translated">&lt;code&gt;malloc&lt;/code&gt; 에 할당 된 포인터와 배열은 &lt;code&gt;delete&lt;/code&gt; 를 사용하여 삭제 해서는 안됩니다 . &lt;a href=&quot;qscopedpointer&quot;&gt;QScopedPointer&lt;/a&gt; 의 두 번째 템플릿 매개 변수는 사용자 정의 정리 핸들러에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2716ed47e05e882afe9e5288abdad8784f3bfbb9" translate="yes" xml:space="preserve">
          <source>Arrays as well as pointers that have been allocated with &lt;code&gt;malloc&lt;/code&gt; must not be deleted using &lt;code&gt;delete&lt;/code&gt;. QScopedPointer's second template parameter can be used for custom cleanup handlers.</source>
          <target state="translated">&lt;code&gt;malloc&lt;/code&gt; 으로 할당 된 포인터와 배열은 &lt;code&gt;delete&lt;/code&gt; 를 사용하여 삭제 하면 안됩니다 . QScopedPointer의 두 번째 템플릿 매개 변수는 사용자 지정 정리 처리기에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b2a8fd3a5efab24761461f71d384408878728213" translate="yes" xml:space="preserve">
          <source>Arrays, Maps</source>
          <target state="translated">배열,지도</target>
        </trans-unit>
        <trans-unit id="900f175af84d0000f64c370336540ee485194334" translate="yes" xml:space="preserve">
          <source>Arrays, maps and strings must use explicit length. &lt;a href=&quot;qcborstreamwriter&quot;&gt;QCborStreamWriter&lt;/a&gt; always does this for strings; for arrays and maps, be sure to call &lt;a href=&quot;qcborstreamwriter#startArray&quot;&gt;startArray&lt;/a&gt;() and &lt;a href=&quot;qcborstreamwriter#startMap&quot;&gt;startMap&lt;/a&gt;() overloads with explicit length.</source>
          <target state="translated">배열, 맵 및 문자열은 명시적인 길이를 사용해야합니다. &lt;a href=&quot;qcborstreamwriter&quot;&gt;QCborStreamWriter는&lt;/a&gt; 항상 문자열에 대해이 작업 을 수행합니다. 배열과 맵의 경우 명시 적 길이로 &lt;a href=&quot;qcborstreamwriter#startArray&quot;&gt;startArray&lt;/a&gt; () 및 &lt;a href=&quot;qcborstreamwriter#startMap&quot;&gt;startMap&lt;/a&gt; () 오버로드 를 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="4726c82d38bd745cfc8bbad7b54e772ecb2e7792" translate="yes" xml:space="preserve">
          <source>Arrays, maps and strings must use explicit length. QCborStreamWriter always does this for strings; for arrays and maps, be sure to call &lt;a href=&quot;qcborstreamwriter#startArray&quot;&gt;startArray&lt;/a&gt;() and &lt;a href=&quot;qcborstreamwriter#startMap&quot;&gt;startMap&lt;/a&gt;() overloads with explicit length.</source>
          <target state="translated">배열, 맵 및 문자열은 명시적인 길이를 사용해야합니다. QCborStreamWriter는 항상 문자열에 대해이 작업을 수행합니다. 배열 및 맵의 경우 명시적인 길이로 &lt;a href=&quot;qcborstreamwriter#startArray&quot;&gt;startArray&lt;/a&gt; () 및 &lt;a href=&quot;qcborstreamwriter#startMap&quot;&gt;startMap&lt;/a&gt; () 오버로드 를 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="e65665c0319750f55e0fe69874130a1cf6d4ed0a" translate="yes" xml:space="preserve">
          <source>Arrow keys</source>
          <target state="translated">화살표 키</target>
        </trans-unit>
        <trans-unit id="3094e340f7ad15ed65f9617c27dee5b6efab8cd1" translate="yes" xml:space="preserve">
          <source>Arrow pointing upwards.</source>
          <target state="translated">위쪽을 가리키는 화살표.</target>
        </trans-unit>
        <trans-unit id="482272bf7ce3a81c43b80e4333215720dc80f919" translate="yes" xml:space="preserve">
          <source>Arrow used to indicate sorting on a list or table header.</source>
          <target state="translated">목록 또는 테이블 헤더에서 정렬을 나타내는 데 사용되는 화살표.</target>
        </trans-unit>
        <trans-unit id="4360c2dcd4af965377499b10a52640af435c9258" translate="yes" xml:space="preserve">
          <source>Article</source>
          <target state="translated">Article</target>
        </trans-unit>
        <trans-unit id="7c422841b7e3951946583038790545c4ed38481b" translate="yes" xml:space="preserve">
          <source>Articles</source>
          <target state="translated">Articles</target>
        </trans-unit>
        <trans-unit id="56a51ffa3fabb3657751bd1808f69bd249d154a1" translate="yes" xml:space="preserve">
          <source>Articles &amp;amp; Overviews</source>
          <target state="translated">기사 및 개요</target>
        </trans-unit>
        <trans-unit id="f76582ba600897c1f50a1ed73084718b7ec73e5f" translate="yes" xml:space="preserve">
          <source>Articles and Guides</source>
          <target state="translated">기사 및 가이드</target>
        </trans-unit>
        <trans-unit id="fba62974dfe83ad2c48a0cacc75fc3b90edbd918" translate="yes" xml:space="preserve">
          <source>Articles and overviews are a style of writing best used for providing summary detail on a topic or concept. It may introduce a technology or discuss how a concept may be applied, but without discussing exact steps in too much detail. However, this type of content could provide the entry point for readers to find instructional and reference materials that do, such as tutorials, examples and class documentation. An example of an overview might be a product page, such as a top level discussion of Qt Quick, individual modules, design principles, or tools.</source>
          <target state="translated">기사와 개요는 주제 나 개념에 대한 요약 세부 정보를 제공하는 데 가장 적합한 글쓰기 스타일입니다. 기술을 소개하거나 개념을 적용하는 방법에 대해 논의 할 수 있지만 정확한 단계를 너무 자세히 설명하지는 않습니다. 그러나이 유형의 컨텐츠는 독자가 학습서, 예제 및 클래스 문서와 같은 학습 및 참조 자료를 찾을 수있는 진입 점을 제공 할 수 있습니다. 개요의 예로 Qt Quick에 대한 최상위 토론, 개별 모듈, 설계 원칙 또는 도구와 같은 제품 페이지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="80da973597b2f2e0cf1af7e0444d2b482c38fa7b" translate="yes" xml:space="preserve">
          <source>Artist-Employed Cheats</source>
          <target state="translated">예술가 고용 요령</target>
        </trans-unit>
        <trans-unit id="9085c0843e20dcda45adaec5f83079e33bef26e6" translate="yes" xml:space="preserve">
          <source>Artistic paper material. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">예술적인 종이 재료. &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a73419ee455e0064e5140958920a9b4ac26eec17" translate="yes" xml:space="preserve">
          <source>As &lt;a href=&quot;activeqt-index&quot;&gt;ActiveQt&lt;/a&gt; introduces three layers at once - the RCW, COM and finally &lt;a href=&quot;activeqt-index&quot;&gt;ActiveQt&lt;/a&gt; itself - the performance penalty when using the generic Qt/&lt;a href=&quot;activeqt-index&quot;&gt;ActiveQt&lt;/a&gt;/COM/RCW/.NET bridge is larger than when using a hand-crafted IJW-wrapper class. The execution speed however is still sufficient for connecting to and modifying interactive elements in a user interface, and as soon as the benefit of using Qt and C++ to implement and compile performance critical algorithms into native code kicks in, &lt;a href=&quot;activeqt-index&quot;&gt;ActiveQt&lt;/a&gt; becomes a valid choice for making even non-visual parts of your application accessible to .NET.</source>
          <target state="translated">으로 &lt;a href=&quot;activeqt-index&quot;&gt;ActiveQt는&lt;/a&gt; RCW에, COM 그리고 마지막으로 - 한 번에 세 개의 층을 소개 &lt;a href=&quot;activeqt-index&quot;&gt;ActiveQt&lt;/a&gt; 자체 - 성능 저하 일반 Qt를 / 사용하는 경우 &lt;a href=&quot;activeqt-index&quot;&gt;ActiveQt&lt;/a&gt; /COM/RCW/.NET의 다리를 손으로 조작 된 IJW - 래퍼 클래스를 사용하는 경우보다 큽니다. 그러나 실행 속도는 여전히 사용자 인터페이스에서 대화 형 요소에 연결하고 수정하는 데 충분하며, Qt 및 C ++를 사용하여 성능에 중요한 알고리즘을 구현하고 네이티브 코드로 컴파일 하는 &lt;a href=&quot;activeqt-index&quot;&gt;이점&lt;/a&gt; 이있는 즉시 ActiveQt 가 올바른 선택이됩니다. .NET에 액세스 할 수있는 응용 프로그램의 비 시각적 부분도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="cb014dddbd39352d4f2501f7cd58d46273b26e54" translate="yes" xml:space="preserve">
          <source>As &lt;a href=&quot;activeqt-index#&quot;&gt;ActiveQt&lt;/a&gt; introduces three layers at once - the RCW, COM and finally &lt;a href=&quot;activeqt-index#&quot;&gt;ActiveQt&lt;/a&gt; itself - the performance penalty when using the generic Qt/&lt;a href=&quot;activeqt-index#&quot;&gt;ActiveQt&lt;/a&gt;/COM/RCW/.NET bridge is larger than when using a hand-crafted IJW-wrapper class. The execution speed however is still sufficient for connecting to and modifying interactive elements in a user interface, and as soon as the benefit of using Qt and C++ to implement and compile performance critical algorithms into native code kicks in, &lt;a href=&quot;activeqt-index#&quot;&gt;ActiveQt&lt;/a&gt; becomes a valid choice for making even non-visual parts of your application accessible to .NET.</source>
          <target state="translated">&lt;a href=&quot;activeqt-index#&quot;&gt;ActiveQt&lt;/a&gt; 가 RCW, COM 및 마지막으로 &lt;a href=&quot;activeqt-index#&quot;&gt;ActiveQt&lt;/a&gt; 자체 라는 세 가지 계층을 한 번에 도입 함에 따라 일반 Qt / &lt;a href=&quot;activeqt-index#&quot;&gt;ActiveQt&lt;/a&gt; /COM/RCW/.NET 브리지를 사용할 때 성능 저하 가 수작업 IJW 래퍼 클래스를 사용할 때보 다 더 큽니다. 그러나 실행 속도는 여전히 사용자 인터페이스에서 대화 형 요소에 연결하고 수정하기에 충분하며, Qt 및 C ++를 사용하여 성능 결정 알고리즘을 네이티브 코드 킥으로 구현 및 컴파일 하는 &lt;a href=&quot;activeqt-index#&quot;&gt;이점&lt;/a&gt; 이 생기면 ActiveQt 는 올바른 선택이됩니다. 응용 프로그램의 비 시각적 부분조차도 .NET에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0488e03b7814927148f633c567527954a0a28b9d" translate="yes" xml:space="preserve">
          <source>As &lt;a href=&quot;qml-qtquick-controls-exclusivegroup&quot;&gt;ExclusiveGroup&lt;/a&gt; only supports &lt;a href=&quot;qml-qtquick-controls-action&quot;&gt;Action&lt;/a&gt; as child items, we need to manually assign the &lt;code&gt;exclusiveGroup&lt;/code&gt; property for other objects.</source>
          <target state="translated">으로 &lt;a href=&quot;qml-qtquick-controls-exclusivegroup&quot;&gt;ExclusiveGroup는&lt;/a&gt; 만 지원 &lt;a href=&quot;qml-qtquick-controls-action&quot;&gt;활동을&lt;/a&gt; 하위 항목으로, 우리는 수동으로 할당해야 &lt;code&gt;exclusiveGroup&lt;/code&gt; 의 다른 개체에 대한 속성을.</target>
        </trans-unit>
        <trans-unit id="ade9c251f0915adc500091aaeaf3e818b6d593e5" translate="yes" xml:space="preserve">
          <source>As &lt;a href=&quot;qml-qtquick-controls-styles-gaugestyle&quot;&gt;GaugeStyle&lt;/a&gt;'s documentation adequately covers common use cases, this tutorial will cover a different scenario: one where the gauge's tickmarks cover the value bar, instead of being aligned to the left or right of it.</source>
          <target state="translated">으로 &lt;a href=&quot;qml-qtquick-controls-styles-gaugestyle&quot;&gt;GaugeStyle&lt;/a&gt; 의 설명서는 적절하게 일반적인 사용 사례를 다루고,이 튜토리얼은 다른 시나리오를 다룰 것입니다 : 게이지의 표시 점의 값이 줄을 포함 하나, 대신 왼쪽 또는 오른쪽 그것의 정렬되는.</target>
        </trans-unit>
        <trans-unit id="a69a651254e342082cc21d33924742d5f778b280" translate="yes" xml:space="preserve">
          <source>As &lt;a href=&quot;supported-platforms#winrt&quot;&gt;WinRT&lt;/a&gt; applications are run in a sandboxed environment, setting the path variable to point to the files required will not work.</source>
          <target state="translated">으로 &lt;a href=&quot;supported-platforms#winrt&quot;&gt;WinRT의&lt;/a&gt; 응용 프로그램이 작동하지 않습니다 필요한 파일을 가리키고 경로 변수를 설정, 샌드 박스 환경에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="d5280d982a17a3e0de0ede57fb2cb960f7534849" translate="yes" xml:space="preserve">
          <source>As &lt;a href=&quot;supported-platforms#winrt&quot;&gt;WinRT&lt;/a&gt; applications run in a sandboxed environment, some restrictions should be taken into account when considering porting or writing cross-platform applications:</source>
          <target state="translated">으로 &lt;a href=&quot;supported-platforms#winrt&quot;&gt;WinRT의&lt;/a&gt; 응용 프로그램이 샌드 박스 환경에서 실행, 몇 가지 제한이 이식 또는 크로스 플랫폼 응용 프로그램을 작성 고려할 때 고려되어야한다 :</target>
        </trans-unit>
        <trans-unit id="179fa0580ebf568a8f4c369b2c3b32a6d10fad25" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;kmap&lt;/code&gt; files are plain-text files, they can also be hand crafted.</source>
          <target state="translated">으로 &lt;code&gt;kmap&lt;/code&gt; 파일은 일반 텍스트 파일, 그들은 또한 손으로 제작 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2da21b520222da95776c0a62a36bbe3df2cf9a45" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;views&lt;/code&gt; do not own the memory they reference, care must be taken to ensure that the referenced data (for example, owned by a &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;) outlives the &lt;code&gt;view&lt;/code&gt; on all code paths.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65734a6653f2a94889fe5a8a39e3c63c4de56dc6" translate="yes" xml:space="preserve">
          <source>As Connection is just a handle, the underlying signal-slot connection is unaffected when Connection is destroyed or reassigned.</source>
          <target state="translated">Connection은 단순한 핸들이므로 Connection이 손상되거나 재 할당 될 때 기본 신호 슬롯 연결에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a369bd6d3c234cb2520478b2ff1cddfb065fe0f3" translate="yes" xml:space="preserve">
          <source>As ExclusiveGroup only supports &lt;a href=&quot;qml-qtquick-controls-action&quot;&gt;Action&lt;/a&gt; as child items, we need to manually assign the &lt;code&gt;exclusiveGroup&lt;/code&gt; property for other objects.</source>
          <target state="translated">ExclusiveGroup은 &lt;a href=&quot;qml-qtquick-controls-action&quot;&gt;Action&lt;/a&gt; 을 자식 항목으로 만 지원하므로 다른 개체에 대해 &lt;code&gt;exclusiveGroup&lt;/code&gt; 속성 을 수동으로 할당해야 합니다.</target>
        </trans-unit>
        <trans-unit id="3d04630e30c94d76c00827289ef0aa28c1a2e1cc" translate="yes" xml:space="preserve">
          <source>As JavaScript's built-in scope mechanism is very simple, QML enhances it to fit more naturally with the QML language extensions.</source>
          <target state="translated">JavaScript의 내장 범위 메커니즘은 매우 간단하므로 QML은 QML 언어 확장에보다 자연스럽게 맞도록 향상시킵니다.</target>
        </trans-unit>
        <trans-unit id="8ea302238182d60e7a1d90aef8ef88a5ebb8e14a" translate="yes" xml:space="preserve">
          <source>As QML uses Qt's meta-type system all of the existing &lt;a href=&quot;qmetaobject&quot;&gt;QMetaObject&lt;/a&gt; classes can be used to introspect and interact with objects created by QML. However, some of the new features provided by QML - such as type safety and attached properties - are most easily used through the &lt;a href=&quot;qqmlproperty&quot;&gt;QQmlProperty&lt;/a&gt; class that simplifies some of their natural complexity.</source>
          <target state="translated">QML이 Qt의 메타 유형 시스템을 &lt;a href=&quot;qmetaobject&quot;&gt;사용함&lt;/a&gt; 에 따라 기존의 모든 QMetaObject 클래스를 사용하여 QML로 생성 된 객체를 검사하고 상호 작용할 수 있습니다. 그러나 형식 안전성 및 첨부 속성과 같은 QML이 제공하는 새로운 기능 중 일부는 자연 복잡성을 단순화 하는 &lt;a href=&quot;qqmlproperty&quot;&gt;QQmlProperty&lt;/a&gt; 클래스를 통해 가장 쉽게 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e17630d37c2ec0c5351dcda822b9490ffcd56874" translate="yes" xml:space="preserve">
          <source>As QML uses Qt's meta-type system all of the existing &lt;a href=&quot;qmetaobject&quot;&gt;QMetaObject&lt;/a&gt; classes can be used to introspect and interact with objects created by QML. However, some of the new features provided by QML - such as type safety and attached properties - are most easily used through the QQmlProperty class that simplifies some of their natural complexity.</source>
          <target state="translated">QML은 Qt의 메타 유형 시스템을 사용하므로 기존 &lt;a href=&quot;qmetaobject&quot;&gt;QMetaObject&lt;/a&gt; 클래스를 모두 사용하여 QML에서 생성 된 객체를 검사하고 상호 작용할 수 있습니다. 그러나 유형 안전성 및 연결된 속성과 같이 QML에서 제공하는 일부 새로운 기능은 자연적인 복잡성을 단순화하는 QQmlProperty 클래스를 통해 가장 쉽게 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7e94113753824a914a1a08aa2154179d51fe5b93" translate="yes" xml:space="preserve">
          <source>As Qt Quick 3D does not initialize rendering or a window on its own, but rather relies on &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt; or &lt;a href=&quot;qquickview&quot;&gt;QQuickView&lt;/a&gt; or the &lt;a href=&quot;https://doc.qt.io/qt-6.0/window-qmlmodule.html&quot;&gt;Window&lt;/a&gt; QML type, everything related to graphics API selection that applies to the &lt;a href=&quot;qtquick-visualcanvas-scenegraph&quot;&gt;Qt Quick Scene Graph&lt;/a&gt; applies to Qt Quick 3D as well. It is possible to control the behavior of the scene graph by setting specific environment variables as listed below:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ede9a9ff336452103fa62ab8634fc76224f1fee" translate="yes" xml:space="preserve">
          <source>As UWP applications are run in a sandboxed environment, setting the path variable to point to the files required will not work.</source>
          <target state="translated">UWP 애플리케이션은 샌드 박스 환경에서 실행되므로 필요한 파일을 가리 키도록 경로 변수를 설정하면 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d26e7459e02067551faa959983bb7a4d10cc98ac" translate="yes" xml:space="preserve">
          <source>As UWP applications run in a sandboxed environment, some restrictions should be taken into account when considering porting or writing cross-platform applications:</source>
          <target state="translated">UWP 응용 프로그램은 샌드 박스 환경에서 실행되므로 플랫폼 간 응용 프로그램을 이식하거나 작성할 때 몇 가지 제한 사항을 고려해야합니다.</target>
        </trans-unit>
        <trans-unit id="8050ae2b35d13151611656688d5708e78d314421" translate="yes" xml:space="preserve">
          <source>As a comparison, the &lt;a href=&quot;qtquick-visualcanvas-scenegraph&quot;&gt;Qt Quick 2 scenegraph renderer&lt;/a&gt; responsible for drawing Qt Quick 2 scenes is hard-wired in C++ to do things like batching of primitives and rendering opaque items followed by rendering of transparent items. In the case of Qt Quick 2 that is perfectly fine as that covers all of the requirements. As you can see from some of the examples listed above, such a hard-wired renderer is not likely to be flexible enough for generic 3D scenes given the multitude of rendering methods available. Or if a renderer could be made flexible enough to cover all such cases, its performance would likely suffer from being too general. To make matters worse, more rendering methods are being researched all of the time. We therefore needed an approach that is</source>
          <target state="translated">이에 비해 &lt;a href=&quot;qtquick-visualcanvas-scenegraph&quot;&gt;Qt Quick 2 장면&lt;/a&gt; 그리기를 담당 하는 Qt Quick 2 장면 그래프 렌더러 는 C ++에서 하드 와이어 방식으로 프리미티브 배치 및 불투명 한 항목 렌더링 및 투명한 항목 렌더링과 같은 작업을 수행합니다. Qt Quick 2의 경우 모든 요구 사항을 완벽하게 충족합니다. 위에 나열된 일부 예제에서 볼 수 있듯이 이러한 고정 배선 렌더러는 사용 가능한 여러 렌더링 방법을 고려할 때 일반적인 3D 장면에 충분히 유연하지 않을 수 있습니다. 또는 이러한 모든 경우를 처리 할 수있을 정도로 렌더러를 유연하게 만들 수 있으면 성능이 너무 일반적 일 수 있습니다. 설상가상으로, 더 많은 렌더링 방법이 항상 연구되고 있습니다. 따라서 우리는 다음과 같은 접근 방식이 필요했습니다</target>
        </trans-unit>
        <trans-unit id="16654ae817ec13afbedfbef208383509128f9788" translate="yes" xml:space="preserve">
          <source>As a concrete example, say you have a set of processes talking to each other on your target hardware using a registry, with the &lt;a href=&quot;qtremoteobjects-registry#registry&quot;&gt;Registry&lt;/a&gt; at &quot;local:registry&quot; and separate processes using a node at &quot;local:MyHost&quot; that holds &lt;a href=&quot;qtremoteobjects-source#source&quot;&gt;Source&lt;/a&gt; objects. If you wanted to access these objects, but over tcp, you could create a new proxyNode like so:</source>
          <target state="translated">구체적인 예로, &lt;a href=&quot;qtremoteobjects-registry#registry&quot;&gt;레지스트리&lt;/a&gt; 가 &quot;local : registry&quot;인 레지스트리 를 사용하여 대상 하드웨어에서 서로 통신하는 일련의 프로세스가 있고 &lt;a href=&quot;qtremoteobjects-source#source&quot;&gt;소스&lt;/a&gt; 오브젝트 를 보유하는 &quot;local : MyHost&quot;의 노드를 사용하는 별도의 프로세스가 있다고 가정하십시오 . tcp를 통해 이러한 객체에 액세스하려면 다음과 같이 새 proxyNode를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3368d8f1d0a796067aaf697916948d78c6cd398f" translate="yes" xml:space="preserve">
          <source>As a concrete, minimal example, the following class would provide geometry for a single triangle:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffead72fbf19f5ddae185bf2691d1eb7b5e5e0c7" translate="yes" xml:space="preserve">
          <source>As a consequence to this signal the application must either start the roaming process by calling &lt;a href=&quot;qnetworksession#migrate&quot;&gt;migrate&lt;/a&gt;() or choose to &lt;a href=&quot;qnetworksession#ignore&quot;&gt;ignore&lt;/a&gt;() the new access point.</source>
          <target state="translated">이 신호의 결과로 응용 프로그램은 &lt;a href=&quot;qnetworksession#migrate&quot;&gt;migrate&lt;/a&gt; () 를 호출하여 로밍 프로세스를 시작 하거나 새 액세스 포인트 를 &lt;a href=&quot;qnetworksession#ignore&quot;&gt;무시&lt;/a&gt; () 하도록 선택해야 합니다.</target>
        </trans-unit>
        <trans-unit id="5876200fc35ab75ebbc30bc52742a18c9b8e9cea" translate="yes" xml:space="preserve">
          <source>As a convenience for the two most common connection types, the &lt;a href=&quot;qdbusconnection#sessionBus&quot;&gt;sessionBus&lt;/a&gt;() and &lt;a href=&quot;qdbusconnection#systemBus&quot;&gt;systemBus&lt;/a&gt;() functions return open connections to the session server daemon and the system server daemon, respectively. Those connections are opened when first used and are closed when the &lt;a href=&quot;qcoreapplication&quot;&gt;QCoreApplication&lt;/a&gt; destructor is run.</source>
          <target state="translated">가장 일반적인 두 가지 연결 유형의 편의를 위해 &lt;a href=&quot;qdbusconnection#sessionBus&quot;&gt;sessionBus&lt;/a&gt; () 및 &lt;a href=&quot;qdbusconnection#systemBus&quot;&gt;systemBus&lt;/a&gt; () 함수는 각각 세션 서버 데몬 및 시스템 서버 데몬에 대한 열린 연결을 반환합니다. 이러한 연결은 처음 사용될 때 열리고 &lt;a href=&quot;qcoreapplication&quot;&gt;QCoreApplication&lt;/a&gt; 소멸자가 실행될 때 닫힙니다 .</target>
        </trans-unit>
        <trans-unit id="b9cd22f5dd9d530194b81069ccce8c4e6570bcd5" translate="yes" xml:space="preserve">
          <source>As a convenience, &lt;a href=&quot;qsslsocket&quot;&gt;QSslSocket&lt;/a&gt; supports &lt;a href=&quot;qtcpsocket&quot;&gt;QTcpSocket&lt;/a&gt;'s blocking functions &lt;a href=&quot;qsslsocket#waitForConnected&quot;&gt;waitForConnected&lt;/a&gt;(), &lt;a href=&quot;qsslsocket#waitForReadyRead&quot;&gt;waitForReadyRead&lt;/a&gt;(), &lt;a href=&quot;qsslsocket#waitForBytesWritten&quot;&gt;waitForBytesWritten&lt;/a&gt;(), and &lt;a href=&quot;qsslsocket#waitForDisconnected&quot;&gt;waitForDisconnected&lt;/a&gt;(). It also provides &lt;a href=&quot;qsslsocket#waitForEncrypted&quot;&gt;waitForEncrypted&lt;/a&gt;(), which will block the calling thread until an encrypted connection has been established.</source>
          <target state="translated">편의상 &lt;a href=&quot;qsslsocket&quot;&gt;QSslSocket&lt;/a&gt; 은 &lt;a href=&quot;qtcpsocket&quot;&gt;QTcpSocket&lt;/a&gt; 의 차단 기능 &lt;a href=&quot;qsslsocket#waitForConnected&quot;&gt;waitForConnected&lt;/a&gt; (), &lt;a href=&quot;qsslsocket#waitForReadyRead&quot;&gt;waitForReadyRead&lt;/a&gt; (), &lt;a href=&quot;qsslsocket#waitForBytesWritten&quot;&gt;waitForBytesWritten&lt;/a&gt; () 및 &lt;a href=&quot;qsslsocket#waitForDisconnected&quot;&gt;waitForDisconnected&lt;/a&gt; ()를 지원합니다. 또한 암호화 된 연결이 설정 될 때까지 호출 스레드를 차단하는 &lt;a href=&quot;qsslsocket#waitForEncrypted&quot;&gt;waitForEncrypted&lt;/a&gt; ()를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="f0e599e06d6db382b738d706fe7713d8137c51c7" translate="yes" xml:space="preserve">
          <source>As a convenience, QSslSocket supports &lt;a href=&quot;qtcpsocket&quot;&gt;QTcpSocket&lt;/a&gt;'s blocking functions &lt;a href=&quot;qsslsocket#waitForConnected&quot;&gt;waitForConnected&lt;/a&gt;(), &lt;a href=&quot;qsslsocket#waitForReadyRead&quot;&gt;waitForReadyRead&lt;/a&gt;(), &lt;a href=&quot;qsslsocket#waitForBytesWritten&quot;&gt;waitForBytesWritten&lt;/a&gt;(), and &lt;a href=&quot;qsslsocket#waitForDisconnected&quot;&gt;waitForDisconnected&lt;/a&gt;(). It also provides &lt;a href=&quot;qsslsocket#waitForEncrypted&quot;&gt;waitForEncrypted&lt;/a&gt;(), which will block the calling thread until an encrypted connection has been established.</source>
          <target state="translated">편의상 QSslSocket은 &lt;a href=&quot;qtcpsocket&quot;&gt;QTcpSocket&lt;/a&gt; 의 차단 함수 &lt;a href=&quot;qsslsocket#waitForConnected&quot;&gt;waitForConnected&lt;/a&gt; (), &lt;a href=&quot;qsslsocket#waitForReadyRead&quot;&gt;waitForReadyRead&lt;/a&gt; (), &lt;a href=&quot;qsslsocket#waitForBytesWritten&quot;&gt;waitForBytesWritten&lt;/a&gt; () 및 &lt;a href=&quot;qsslsocket#waitForDisconnected&quot;&gt;waitForDisconnected&lt;/a&gt; ()를 지원합니다. 또한 암호화 된 연결이 설정 될 때까지 호출 스레드를 차단하는 &lt;a href=&quot;qsslsocket#waitForEncrypted&quot;&gt;waitForEncrypted&lt;/a&gt; () 도 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="6a1088883528471d54845c4626a618c3a3db0753" translate="yes" xml:space="preserve">
          <source>As a convenience, many of these types can be specified in QML by string values, or by a related method provided by the &lt;a href=&quot;qml-qtqml-qt&quot;&gt;QtQml::Qt&lt;/a&gt; object. For example, the &lt;a href=&quot;qml-qtquick-image#sourceSize-prop&quot;&gt;Image::sourceSize&lt;/a&gt; property is of type &lt;a href=&quot;qml-size&quot;&gt;size&lt;/a&gt; (which automatically translates to the &lt;a href=&quot;qsize&quot;&gt;QSize&lt;/a&gt; type) and can be specified by a string value formatted as &quot;width&lt;code&gt;x&lt;/code&gt;height&quot;, or by the Qt.&lt;a href=&quot;qml-qtquick-controls2-stackview#size&quot;&gt;size&lt;/a&gt;() function:</source>
          <target state="translated">편의상 이러한 유형 중 많은 부분을 QML에서 문자열 값 또는 &lt;a href=&quot;qml-qtqml-qt&quot;&gt;QtQml :: Qt&lt;/a&gt; 오브젝트 에서 제공하는 관련 메소드로 지정할 수 있습니다 . 예를 들어 &lt;a href=&quot;qml-qtquick-image#sourceSize-prop&quot;&gt;Image :: sourceSize&lt;/a&gt; 속성은 &lt;a href=&quot;qml-size&quot;&gt;size&lt;/a&gt; 유형 (자동으로 &lt;a href=&quot;qsize&quot;&gt;QSize&lt;/a&gt; 유형 으로 변환 됨 )이며 &quot;width &lt;code&gt;x&lt;/code&gt; height&quot; 형식의 문자열 값 또는 Qt 로 지정할 수 있습니다 . &lt;a href=&quot;qml-qtquick-controls2-stackview#size&quot;&gt;크기&lt;/a&gt; () 기능 :</target>
        </trans-unit>
        <trans-unit id="91dde3df4079d9c3a3343b655d043066679d2b27" translate="yes" xml:space="preserve">
          <source>As a convention the &lt;a href=&quot;qscrollerproperties&quot;&gt;QScrollerProperties&lt;/a&gt; are in physical units (meter, seconds) and are converted by &lt;a href=&quot;qscroller&quot;&gt;QScroller&lt;/a&gt; using the current DPI.</source>
          <target state="translated">일반적으로 &lt;a href=&quot;qscrollerproperties&quot;&gt;QScrollerProperties&lt;/a&gt; 는 실제 단위 (미터, 초)이며 &lt;a href=&quot;qscroller&quot;&gt;QScroller&lt;/a&gt; 가 현재 DPI를 사용하여 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="3cfa3f7f59ad1e468ce30059684074432c33b71b" translate="yes" xml:space="preserve">
          <source>As a convention the QScrollerProperties are in physical units (meter, seconds) and are converted by &lt;a href=&quot;qscroller&quot;&gt;QScroller&lt;/a&gt; using the current DPI.</source>
          <target state="translated">규칙에 따라 QScrollerProperties는 물리적 단위 (미터, 초)이며 현재 DPI를 사용하여 &lt;a href=&quot;qscroller&quot;&gt;QScroller에&lt;/a&gt; 의해 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="8871724b0fde815d1283276bd102e65e68db1482" translate="yes" xml:space="preserve">
          <source>As a countermeasure to these attacks, &lt;a href=&quot;https://tools.ietf.org/html/rfc6347#section-4.2.1&quot;&gt;RFC 6347, section 4.2.1&lt;/a&gt; proposes a stateless cookie technique that a server may deploy:</source>
          <target state="translated">이러한 공격에 대한 대책으로 &lt;a href=&quot;https://tools.ietf.org/html/rfc6347#section-4.2.1&quot;&gt;RFC 6347, 섹션 4.2.1&lt;/a&gt; 은 서버가 배포 할 수있는 상태 비 저장 쿠키 기술을 제안합니다.</target>
        </trans-unit>
        <trans-unit id="d8f8a9c1f819f1f448c84d5bb0f7d67c17b6314e" translate="yes" xml:space="preserve">
          <source>As a general rule, scenes should avoid using separate Shape items when it is not absolutely necessary. Prefer using one Shape item with multiple &lt;a href=&quot;qml-qtquick-shapes-shapepath&quot;&gt;ShapePath&lt;/a&gt; elements over multiple Shape items.</source>
          <target state="translated">일반적으로 장면은 반드시 필요하지 않은 경우 별도의 모양 항목을 사용하지 않아야합니다. 여러 Shape 항목보다 여러 &lt;a href=&quot;qml-qtquick-shapes-shapepath&quot;&gt;ShapePath&lt;/a&gt; 요소가있는 하나의 Shape 항목을 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="8df4a49b6b80ccfd011cef828b5f51f01a304bb6" translate="yes" xml:space="preserve">
          <source>As a general rule, the usage of XCB on embedded devices is not advisable. Plugins like eglfs are likely to provide better performance, and hardware acceleration.</source>
          <target state="translated">일반적으로 임베디드 장치에서 XCB 사용은 권장되지 않습니다. eglfs와 같은 플러그인은 더 나은 성능과 하드웨어 가속을 제공 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="95fa84cd4c7bc5c9851232e73a6f86616a3a3db2" translate="yes" xml:space="preserve">
          <source>As a general rule, use a push button when the application or dialog window performs an action when the user clicks on it (such as Apply, Cancel, Close and Help)</source>
          <target state="translated">일반적으로 사용자가 응용 프로그램 또는 대화 상자를 클릭 할 때 조치 (예 : 적용, 취소, 닫기 및 도움말)를 수행 할 때 누름 단추를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ff23a97d4eec6ad9471102c507cc95562693a902" translate="yes" xml:space="preserve">
          <source>As a last resort it uses the Information icon.</source>
          <target state="translated">최후의 수단으로 정보 아이콘을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="673221f4dc3fc922538641fbc20eb7e8f3a08805" translate="yes" xml:space="preserve">
          <source>As a lower-level alternative to the text rules, you can also implement a custom filter via &lt;a href=&quot;qloggingcategory#installFilter&quot;&gt;installFilter&lt;/a&gt;(). All filter rules are ignored in this case.</source>
          <target state="translated">텍스트 규칙의 하위 수준 대안으로 &lt;a href=&quot;qloggingcategory#installFilter&quot;&gt;installFilter&lt;/a&gt; () 를 통해 사용자 정의 필터를 구현할 수도 있습니다 . 이 경우 모든 필터 규칙이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="4d005db4617a4c9b96e7f3ea999dc0c551615b14" translate="yes" xml:space="preserve">
          <source>As a property value source</source>
          <target state="translated">특성 값 소스로</target>
        </trans-unit>
        <trans-unit id="61cd33ea13e6c171386b3d59bc3397b39825e6ae" translate="yes" xml:space="preserve">
          <source>As a result of calling open() the interface will be started if it is not connected/up yet. Some platforms may not provide support for out-of-process sessions. On such platforms the session counter ignores any sessions held by another process. The platform capabilities can be detected via &lt;a href=&quot;qnetworkconfigurationmanager#capabilities&quot;&gt;QNetworkConfigurationManager::capabilities&lt;/a&gt;().</source>
          <target state="translated">open ()을 호출 한 결과 아직 연결되지 않은 경우 인터페이스가 시작됩니다. 일부 플랫폼은 Out-of-process 세션을 지원하지 않을 수 있습니다. 이러한 플랫폼에서 세션 카운터는 다른 프로세스가 보유한 모든 세션을 무시합니다. 플랫폼 기능은 &lt;a href=&quot;qnetworkconfigurationmanager#capabilities&quot;&gt;QNetworkConfigurationManager :: capabilities&lt;/a&gt; () 를 통해 감지 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fa12ddb8dd10eb2f7246effd2d855748abda0176" translate="yes" xml:space="preserve">
          <source>As a result of calling this function, this item will receive a &lt;a href=&quot;qgraphicsitem#focusInEvent&quot;&gt;focus in event&lt;/a&gt; with</source>
          <target state="translated">이 함수를 호출의 결과,이 항목은받을 &lt;a href=&quot;qgraphicsitem#focusInEvent&quot;&gt;경우에 초점&lt;/a&gt; 과를</target>
        </trans-unit>
        <trans-unit id="12b434ffc79f6483badd201bcc2e7f3041fed375" translate="yes" xml:space="preserve">
          <source>As a result of these changes, some things are done a little differently.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="813e172927aa12e3257604ea837bdba6db263749" translate="yes" xml:space="preserve">
          <source>As a result of this operation, any scopes that test for &lt;code&gt;opengl&lt;/code&gt; will be processed. We can use this feature to give the final executable an appropriate name:</source>
          <target state="translated">이 작업의 결과로 &lt;code&gt;opengl&lt;/code&gt; 을 테스트하는 모든 범위 가 처리됩니다. 이 기능을 사용하여 최종 실행 파일에 적절한 이름을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="03648f1f0e3af66e6698cf463333c191091bdc28" translate="yes" xml:space="preserve">
          <source>As a result, both human-readable strings and hard-coded key codes can both be problematic to use when specifying a key sequence that can be used on a variety of different keyboard layouts. Only the use of &lt;a href=&quot;qkeysequence#StandardKey-enum&quot;&gt;standard shortcuts&lt;/a&gt; guarantees that the user will be able to use the shortcuts that the developer intended.</source>
          <target state="translated">결과적으로, 사람이 읽을 수있는 문자열과 하드 코드 된 키 코드는 모두 다양한 키보드 레이아웃에서 사용할 수있는 키 시퀀스를 지정할 때 사용하기에 문제가 될 수 있습니다. &lt;a href=&quot;qkeysequence#StandardKey-enum&quot;&gt;표준 바로 가기&lt;/a&gt; 만 사용 하면 사용자가 개발자가 의도 한 바로 가기를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="780994c44c6578054e951f95bf10d47aceee09e8" translate="yes" xml:space="preserve">
          <source>As a result, certain kinds of effects may be slower than expected on certain devices. It may be possible to compensate for this performance hit by making optimizations in other areas; for example, by using &lt;a href=&quot;#opengl-rendering&quot;&gt;OpenGL&lt;/a&gt; to render a scene. However, any such optimizations may themselves cause a reduction in performance if they also rely on the presence of floating point hardware.</source>
          <target state="translated">결과적으로 특정 종류의 효과는 특정 장치에서 예상보다 느릴 수 있습니다. 다른 영역에서 최적화를 수행하면 이러한 성능 저하를 보상 할 수 있습니다. 예를 들어 &lt;a href=&quot;#opengl-rendering&quot;&gt;OpenGL&lt;/a&gt; 을 사용하여 장면을 렌더링합니다. 그러나 이러한 최적화는 부동 소수점 하드웨어의 존재에 의존하는 경우 성능 자체를 저하시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="da51ca1f2244c239a88385777013de655249d9a5" translate="yes" xml:space="preserve">
          <source>As a result, certain kinds of effects may be slower than expected on certain devices. It may be possible to compensate for this performance hit by making optimizations in other areas; for example, by using &lt;a href=&quot;graphicsview#opengl-rendering&quot;&gt;OpenGL&lt;/a&gt; to render a scene. However, any such optimizations may themselves cause a reduction in performance if they also rely on the presence of floating point hardware.</source>
          <target state="translated">결과적으로 특정 종류의 효과는 특정 장치에서 예상보다 느려질 수 있습니다. 다른 영역에서 최적화를 수행하여 이러한 성능 저하를 보상 할 수 있습니다. 예를 들어 &lt;a href=&quot;graphicsview#opengl-rendering&quot;&gt;OpenGL&lt;/a&gt; 을 사용하여 장면을 렌더링합니다. 그러나 이러한 최적화는 부동 소수점 하드웨어의 존재에 의존하는 경우 자체적으로 성능 저하를 유발할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="509a5a65045b1dee34a168ea7f6aa09a4d1650be" translate="yes" xml:space="preserve">
          <source>As a result, only the model needs to know how to obtain data, and the type of data managed by the model can be defined fairly generally. Model indexes contain a pointer to the model that created them, and this prevents confusion when working with more than one model.</source>
          <target state="translated">결과적으로 모델 만 데이터를 얻는 방법을 알아야하며 모델이 관리하는 데이터 유형을 상당히 일반적으로 정의 할 수 있습니다. 모델 인덱스에는 모델을 생성 한 모델에 대한 포인터가 포함되어 있으므로 둘 이상의 모델로 작업 할 때 혼동을 방지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b0588ee170f603557321108977e5cdf0bf6f6b9" translate="yes" xml:space="preserve">
          <source>As a result, the value returned by &lt;a href=&quot;qpainter#clipRegion&quot;&gt;QPainter::clipRegion&lt;/a&gt;() on a newly-constructed &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; will not reflect the clip region that is used by the paint system.</source>
          <target state="translated">결과적으로 새로 구성된 &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; 에서 &lt;a href=&quot;qpainter#clipRegion&quot;&gt;QPainter :: clipRegion&lt;/a&gt; ()에 의해 반환 된 값 은 페인트 시스템에서 사용하는 클립 영역을 반영하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7b3270791f82472b94f05bc56acefab960168c90" translate="yes" xml:space="preserve">
          <source>As a screen-space heuristic technique, it can sometimes leave sharp edges that ideally would be anti-aliased.</source>
          <target state="translated">화면 공간 휴리스틱 기술로서 때때로 이상적으로 앤티 앨리어싱되는 날카로운 모서리를 남길 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c30b1d56552477a8af20723738b54ec71f7fd02" translate="yes" xml:space="preserve">
          <source>As a side effect of the item being repainted, other items that overlap the area</source>
          <target state="translated">다시 칠하는 항목의 부작용으로 영역과 겹치는 다른 항목</target>
        </trans-unit>
        <trans-unit id="f40f6b6e595f789cd81a5ed8771290d28126f766" translate="yes" xml:space="preserve">
          <source>As a side effect, if &lt;code&gt;f&lt;/code&gt; is a pointer to a member function, the first argument of &lt;code&gt;args&lt;/code&gt; should be the object for which that member is defined (or a reference, or a pointer to it). So instead of writing:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59f5b87678a94d45fbb3c8eb5c39a72a3e3a8857" translate="yes" xml:space="preserve">
          <source>As a simple example, let's create an effect that combines the scene's content with an image, while further altering the red channel's value in an animated manner:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d5fbf9210ce0832de1c9a2b86d3dae1d5733b7e" translate="yes" xml:space="preserve">
          <source>As a special case &lt;a href=&quot;qlocale#Country-enum&quot;&gt;QLocale::AnyCountry&lt;/a&gt; returns those IANA IDs that do not have any specific country.</source>
          <target state="translated">특별한 경우 &lt;a href=&quot;qlocale#Country-enum&quot;&gt;QLocale :: AnyCountry&lt;/a&gt; 는 특정 국가가없는 IANA ID를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b6a985d0d6324e02d41df5240563842cd4c6b960" translate="yes" xml:space="preserve">
          <source>As a special case, &lt;a href=&quot;qlocale#Country-enum&quot;&gt;QLocale::AnyCountry&lt;/a&gt; returns the default of those IANA IDs that do not have any specific country.</source>
          <target state="translated">특별한 경우, &lt;a href=&quot;qlocale#Country-enum&quot;&gt;QLocale :: AnyCountry&lt;/a&gt; 는 특정 국가가없는 IANA ID의 기본값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d8bb094a8b46620e18ef2cb0247f60e39d120f2e" translate="yes" xml:space="preserve">
          <source>As a special case, a</source>
          <target state="translated">특별한 경우로</target>
        </trans-unit>
        <trans-unit id="67709323f7c64dee226e1200d1040d9c06f23da2" translate="yes" xml:space="preserve">
          <source>As a special case, a &lt;a href=&quot;qtimer&quot;&gt;QTimer&lt;/a&gt; with a timeout of 0 will time out as soon as all the events in the window system's event queue have been processed. This can be used to do heavy work while providing a snappy user interface:</source>
          <target state="translated">특별한 경우로, 시간 종료가 0 인 &lt;a href=&quot;qtimer&quot;&gt;QTimer&lt;/a&gt; 는 윈도우 시스템의 이벤트 큐에있는 모든 이벤트가 처리 되 자마자 시간 종료됩니다. 이것은 빠른 사용자 인터페이스를 제공하면서 많은 작업을 수행하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a9b713bc93435f256b7a354d0bd6c595fd118aa" translate="yes" xml:space="preserve">
          <source>As a special case, a QTimer with a timeout of 0 will time out as soon as possible, though the ordering between zero timers and other sources of events is unspecified. Zero timers can be used to do some work while still providing a snappy user interface:</source>
          <target state="translated">특별한 경우로 타임 아웃이 0 인 QTimer는 제로 타이머와 다른 이벤트 소스 사이의 순서가 지정되지 않았지만 가능한 한 빨리 타임 아웃됩니다. 제로 타이머는 깔끔한 사용자 인터페이스를 제공하면서 일부 작업을 수행하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="67d0f233e23748a57b37d4a76e41c49ed1d4e06a" translate="yes" xml:space="preserve">
          <source>As a special exception, &lt;a href=&quot;qtextstream&quot;&gt;QTextStream&lt;/a&gt; allows the strings &quot;nan&quot; and &quot;inf&quot; to represent NAN and INF floats or doubles.</source>
          <target state="translated">특별한 예외로, &lt;a href=&quot;qtextstream&quot;&gt;QTextStream&lt;/a&gt; 은 문자열 &quot;nan&quot;과 &quot;inf&quot;가 NAN과 INF float 또는 double을 나타내는 것을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="7f326801eacc88fc8812ba4adab1baebb1f102d0" translate="yes" xml:space="preserve">
          <source>As already mentioned, the Qt compressed help file contains all data, so there is no need any longer to ship all the single HTML files. Instead, only the compressed help file and, optionally, the collection file have to be distributed. The collection file is optional since any existing collection file, for example from an older release, could be used.</source>
          <target state="translated">이미 언급했듯이 Qt 압축 도움말 파일에는 모든 데이터가 포함되어 있으므로 더 이상 모든 단일 HTML 파일을 배송 할 필요가 없습니다. 대신 압축 된 도움말 파일 및 선택적으로 콜렉션 파일 만 분배해야합니다. 이전 릴리스와 같은 기존 컬렉션 파일을 사용할 수 있으므로 컬렉션 파일은 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="7dc7b9b08e8bec5164fab76d0c53a03c534d89f4" translate="yes" xml:space="preserve">
          <source>As an alternative to &lt;a href=&quot;qgraphicsitem#transform&quot;&gt;QGraphicsItem::transform&lt;/a&gt;, &lt;a href=&quot;qgraphicstransform&quot;&gt;QGraphicsTransform&lt;/a&gt; lets you create and control advanced transformations that can be configured independently using specialized properties.</source>
          <target state="translated">에 대한 대안으로 &lt;a href=&quot;qgraphicsitem#transform&quot;&gt;QGraphicsItem :: 변환&lt;/a&gt; , &lt;a href=&quot;qgraphicstransform&quot;&gt;QGraphicsTransform가&lt;/a&gt; 만들고 전문 속성을 사용하여 독립적으로 구성 할 수있는 고급 변환을 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9248a88a7e12796a41eaf72f895fbad5eefb5ac" translate="yes" xml:space="preserve">
          <source>As an alternative to &lt;a href=&quot;qgraphicsitem#transform&quot;&gt;QGraphicsItem::transform&lt;/a&gt;, QGraphicsTransform lets you create and control advanced transformations that can be configured independently using specialized properties.</source>
          <target state="translated">&lt;a href=&quot;qgraphicsitem#transform&quot;&gt;QGraphicsItem :: transform&lt;/a&gt; 대신 QGraphicsTransform을 사용하면 특수 속성을 사용하여 독립적으로 구성 할 수있는 고급 변환을 만들고 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0332798e4516d184f064e7a0a7edcfc335541e1" translate="yes" xml:space="preserve">
          <source>As an alternative to manually writing build type conditionals, some variables offer build-specific variants, for example &lt;a href=&quot;#qmake-lflags-release&quot;&gt;QMAKE_LFLAGS_RELEASE&lt;/a&gt; in addition to the general &lt;a href=&quot;#qmake-lflags&quot;&gt;QMAKE_LFLAGS&lt;/a&gt;. These should be used when available.</source>
          <target state="translated">빌드 유형 조건을 수동으로 작성하는 대신 일부 변수는 일반적인 &lt;a href=&quot;#qmake-lflags&quot;&gt;QMAKE_LFLAGS&lt;/a&gt; 외에도 빌드 관련 변형 (예 : &lt;a href=&quot;#qmake-lflags-release&quot;&gt;QMAKE_LFLAGS_RELEASE)&lt;/a&gt; 을 제공합니다 . 가능한 경우 사용되어야합니다.</target>
        </trans-unit>
        <trans-unit id="10dee02d1b9f561858fe14cf6a814f81dafab9f3" translate="yes" xml:space="preserve">
          <source>As an alternative to manually writing build type conditionals, some variables offer build-specific variants, for example &lt;a href=&quot;qmake-variable-reference#qmake-lflags-release&quot;&gt;QMAKE_LFLAGS_RELEASE&lt;/a&gt; in addition to the general &lt;a href=&quot;qmake-variable-reference#qmake-lflags&quot;&gt;QMAKE_LFLAGS&lt;/a&gt;. These should be used when available.</source>
          <target state="translated">빌드 유형 조건문을 수동으로 작성하는 대신 일부 변수는 일반적인 &lt;a href=&quot;qmake-variable-reference#qmake-lflags&quot;&gt;QMAKE_LFLAGS&lt;/a&gt; 외에 &lt;a href=&quot;qmake-variable-reference#qmake-lflags-release&quot;&gt;QMAKE_LFLAGS_RELEASE&lt;/a&gt; 와 같은 빌드 별 변형을 제공합니다 . 가능할 때 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="d811721ede4b79118569ba78597d3d240a70ced0" translate="yes" xml:space="preserve">
          <source>As an application developer, you must strive to allow the rendering engine to achieve a consistent 60 frames-per-second refresh rate. 60 FPS means that there is approximately 16 milliseconds between each frame in which processing can be done, which includes the processing required to upload the draw primitives to the graphics hardware.</source>
          <target state="translated">응용 프로그램 개발자는 렌더링 엔진이 초당 60 프레임의 일관된 새로 고침 빈도를 달성 할 수 있도록 노력해야합니다. 60 FPS는 처리가 수행 될 수있는 각 프레임 사이에 약 16 밀리 초가 있으며, 이는 드로우 프리미티브를 그래픽 하드웨어에 업로드하는 데 필요한 처리를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="61f864e8e873f7b562f3409d72ed59901f914db6" translate="yes" xml:space="preserve">
          <source>As an example consider the following blend tree:</source>
          <target state="translated">예를 들어 다음 블렌드 트리를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="7e354dda0d5380c69ede32dc0a26ec085dfa89f3" translate="yes" xml:space="preserve">
          <source>As an example this might return &lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt;(0, 0, 1280, 1024), or in a virtual desktop setting &lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt;(1280, 0, 1280, 1024).</source>
          <target state="translated">예를 들어 &lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt; (0, 0, 1280, 1024) 또는 가상 데스크톱 설정 &lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt; (1280, 0, 1280, 1024)를 반환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8183283ddc349000b8b8c6cf12886851819490ef" translate="yes" xml:space="preserve">
          <source>As an example, assume the device is rotated by 180 degrees and therefore the screen orientation also is rotated by 180 degrees from the native orientation. Without automatic axes orientation, the reading values would now be changed: Both the X and the Y values would be negated, forcing an application developer to manually cancel out the negation in application code. Automatic axes orientation does this automatically, in this mode the X and Y values would be the same as with the default screen orientation.</source>
          <target state="translated">예를 들어, 장치가 180도 회전되어 화면 방향도 기본 방향에서 180도 회전한다고 가정합니다. 자동 축 방향이 없으면 판독 값이 변경됩니다. X 및 Y 값이 모두 무시되므로 응용 프로그램 개발자는 응용 프로그램 코드의 부정을 수동으로 취소해야합니다. 자동 축 방향이 자동으로 수행되며,이 모드에서 X 및 Y 값은 기본 화면 방향과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="f1ab05c4c6d0b29177a5e1d479a42058bab461eb" translate="yes" xml:space="preserve">
          <source>As an example, consider the above diagram which illustrates the sprites for a hypothetical 2D platform game character. The character starts by displaying the</source>
          <target state="translated">예를 들어, 가상 2D 플랫폼 게임 캐릭터의 스프라이트를 보여주는 위의 다이어그램을 고려하십시오. 캐릭터는</target>
        </trans-unit>
        <trans-unit id="40fe18229a3074802f21205f5b43e2430614638b" translate="yes" xml:space="preserve">
          <source>As an example, consider the case where you have a &lt;a href=&quot;qml-qtlocation-mapcircle&quot;&gt;MapCircle&lt;/a&gt; representing your current position:</source>
          <target state="translated">예를 들어 현재 위치를 나타내는 &lt;a href=&quot;qml-qtlocation-mapcircle&quot;&gt;MapCircle&lt;/a&gt; 이있는 경우를 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="e567e492be073f0e487fa8c7dc2194af4c370a86" translate="yes" xml:space="preserve">
          <source>As an example, consider the following code snippet, which constructs a multipart message containing a text part followed by an image part:</source>
          <target state="translated">예를 들어, 다음 코드 스 니펫을 고려하십시오.이 코드 스 니펫은 텍스트 파트와 이미지 파트가 차례로 포함 된 멀티 파트 메시지를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="6d0108d7b1db298aa7fe12b736a3788ca5637999" translate="yes" xml:space="preserve">
          <source>As an example, discovering all connected screens and creating a &lt;a href=&quot;qquickview&quot;&gt;QQuickView&lt;/a&gt; for each of them can be done like this:</source>
          <target state="translated">예를 들어, 연결된 모든 화면을 검색하고 각각에 대해 &lt;a href=&quot;qquickview&quot;&gt;QQuickView&lt;/a&gt; 를 생성하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="eab774f1c52ff97764e9a982927552907fb69acf" translate="yes" xml:space="preserve">
          <source>As an example, let's add an attached property that controls elevation. Our style will illustrate the elevation with a drop shadow; the higher the elevation, the larger the shadow.</source>
          <target state="translated">예를 들어 고도를 제어하는 ​​부착 된 속성을 추가해 보겠습니다. 우리의 스타일은 그림자로 입면을 보여줍니다. 고도가 높을수록 그림자가 커집니다.</target>
        </trans-unit>
        <trans-unit id="15b72c79fd7cbd16b7128fc10ba6e7a88fc10bc7" translate="yes" xml:space="preserve">
          <source>As an example, take the above image. For now, just consider the black numbers, and assume the squares are 40x40 pixels. Normally, the image is read from the top-left corner. If you specified the frame size as 40x40 pixels, and a frame count of 8, then it would read in the frames as they are numbered. The frame in the top left would be the first frame, the frame in the top right would be the fifth frame, and then it would wrap to the next row (at pixel location 0,40 in the file) to read the sixth frame. It would stop reading after the frame marked 8, and if there was any image data in the square below frame four then it would not be included in the animation.</source>
          <target state="translated">예를 들어 위의 이미지를 보자. 지금은 검은 숫자를 고려하고 정사각형은 40x40 픽셀이라고 가정하십시오. 일반적으로 이미지는 왼쪽 상단에서 읽습니다. 프레임 크기를 40x40 픽셀로 지정하고 프레임 수를 8로 지정하면 번호가 매겨 질 때 프레임에서 읽습니다. 왼쪽 상단의 프레임이 첫 번째 프레임이되고 오른쪽 상단의 프레임이 다섯 번째 프레임이되고 다음 행 (파일의 픽셀 위치 0,40에서)으로 6 번째 프레임을 읽습니다. 8로 표시된 프레임 이후에 읽기가 중단되고 프레임 4 아래의 사각형에 이미지 데이터가 있으면 애니메이션에 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4a52e07f2944d94cd6bc5510f3a8ce976380ac50" translate="yes" xml:space="preserve">
          <source>As an example, this returns 3 for &lt;a href=&quot;qaccelerometerreading&quot;&gt;QAccelerometerReading&lt;/a&gt; because there are 3 properties defined in that class.</source>
          <target state="translated">예를 들어,이 클래스에는 3 개의 속성이 정의되어 있으므로 &lt;a href=&quot;qaccelerometerreading&quot;&gt;QAccelerometerReading에&lt;/a&gt; 대해 3을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="cdf64408548f0df1050011cfd7b5df6929578f01" translate="yes" xml:space="preserve">
          <source>As an example, this time with Direct3D, the typical usage is expected to be the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43532c2564e75716221cce9b86b4d67fa4467927" translate="yes" xml:space="preserve">
          <source>As an example, we use &lt;a href=&quot;qstring#contains&quot;&gt;QString::contains&lt;/a&gt;():</source>
          <target state="translated">예를 들어, &lt;a href=&quot;qstring#contains&quot;&gt;QString :: contains&lt;/a&gt; ()를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="04f5d893a9fde01e7080134a30ff4412381d5ffa" translate="yes" xml:space="preserve">
          <source>As an example, we will examine the styling of check boxes in the Java style. We describe the complete process and print all code in both the Java style and Qt classes involved. In the rest of this document, we will not examine the source code of the individual widgets. Hopefully, this will give you an idea on how to search through the code if you need to check specific implementation details; most widgets follow the same structure as the check boxes. We have edited the &lt;a href=&quot;qcommonstyle&quot;&gt;QCommonStyle&lt;/a&gt; code somewhat to remove code that is not directly relevant for check box styling.</source>
          <target state="translated">예를 들어 Java 스타일의 확인란 스타일을 검사합니다. 전체 프로세스를 설명하고 관련된 Java 스타일 및 Qt 클래스 모두에서 모든 코드를 인쇄합니다. 이 문서의 나머지 부분에서는 개별 위젯의 소스 코드를 검토하지 않습니다. 다행히도 구체적인 구현 세부 사항을 확인해야하는 경우 코드를 검색하는 방법에 대한 아이디어를 얻을 수 있습니다. 대부분의 위젯은 확인란과 동일한 구조를 따릅니다. 확인란 스타일과 직접 관련이없는 코드를 제거하기 위해 &lt;a href=&quot;qcommonstyle&quot;&gt;QCommonStyle&lt;/a&gt; 코드를 약간 편집했습니다 .</target>
        </trans-unit>
        <trans-unit id="85d87f7f4b49efa6c89aeb036846430f905a5ac3" translate="yes" xml:space="preserve">
          <source>As an example, we'll use QImage::scaledToWidth():</source>
          <target state="translated">예를 들어 QImage :: scaledToWidth ()를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="4fdfd1a02b277df422b06ec379cc68cb08dd0752" translate="yes" xml:space="preserve">
          <source>As an example, when targeting the Raspberry Pi with the Broadcom proprietary graphics drivers, the output should contain something like the following:</source>
          <target state="translated">예를 들어 Broadcom 독점 그래픽 드라이버로 Raspberry Pi를 대상으로하는 경우 출력에는 다음과 같은 내용이 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="cd797044ce2f156eecde12a07d51e6cbb7215886" translate="yes" xml:space="preserve">
          <source>As another example, with these attributes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02edf70f6ffe6e19a4c67186b97d306867feb01a" translate="yes" xml:space="preserve">
          <source>As before, this ensures that the resources are linked into the final application binary in the case of static linking, but also triggers loading of the library in the case of dynamic linking, such as plugins.</source>
          <target state="translated">이전과 같이 정적 링크의 경우 리소스가 최종 응용 프로그램 바이너리에 연결되도록하지만 플러그인과 같은 동적 링크의 경우 라이브러리로드가 트리거됩니다.</target>
        </trans-unit>
        <trans-unit id="8833483dbc5045fbad9be9119ba17ef640bab6ec" translate="yes" xml:space="preserve">
          <source>As can be seen from the above snippets, a script is provided to the engine in the form of a string. One common way of loading scripts is by reading the contents of a file and passing it to &lt;a href=&quot;qjsengine#evaluate&quot;&gt;evaluate&lt;/a&gt;():</source>
          <target state="translated">위의 스 니펫에서 볼 수 있듯이 스크립트는 문자열 형태로 엔진에 제공됩니다. 스크립트를로드하는 일반적인 방법 중 하나는 파일의 내용을 읽고 &lt;a href=&quot;qjsengine#evaluate&quot;&gt;평가&lt;/a&gt; () 하기 위해 전달하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="946ff9861327c49a2cf70cb070d95311176abccb" translate="yes" xml:space="preserve">
          <source>As can be seen from the code extract, the common style gets the bounding rectangles of the two sub elements of CE_CheckBox, and then draws them. If the checkbox has focus, the focus frame is also drawn.</source>
          <target state="translated">코드 추출에서 볼 수 있듯이 일반적인 스타일은 CE_CheckBox의 두 하위 요소에 대한 경계 사각형을 가져온 다음 그립니다. 확인란에 포커스가 있으면 포커스 프레임도 그려집니다.</target>
        </trans-unit>
        <trans-unit id="cf38601a1214ad64f7ee0f4545277b4bd4be77dc" translate="yes" xml:space="preserve">
          <source>As can be seen in the example above, &lt;a href=&quot;qdeadlinetimer&quot;&gt;QDeadlineTimer&lt;/a&gt; offers a templated version of &lt;a href=&quot;qdeadlinetimer#remainingTime&quot;&gt;remainingTime&lt;/a&gt;() and &lt;a href=&quot;qdeadlinetimer#deadline&quot;&gt;deadline&lt;/a&gt;() that can be used to return &lt;code&gt;std::chrono&lt;/code&gt; objects.</source>
          <target state="translated">위의 예에서 볼 수 있듯이 &lt;a href=&quot;qdeadlinetimer&quot;&gt;QDeadlineTimer&lt;/a&gt; 는 &lt;code&gt;std::chrono&lt;/code&gt; 객체 를 반환하는 데 사용할 수 있는 템플릿 버전의 &lt;a href=&quot;qdeadlinetimer#remainingTime&quot;&gt;잔존 시간&lt;/a&gt; () 및 &lt;a href=&quot;qdeadlinetimer#deadline&quot;&gt;데드 라인&lt;/a&gt; ()을 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="411aaa3958da791f2721eef12a02d12b879d0150" translate="yes" xml:space="preserve">
          <source>As can be seen in the example above, QDeadlineTimer offers a templated version of &lt;a href=&quot;qdeadlinetimer#remainingTime&quot;&gt;remainingTime&lt;/a&gt;() and &lt;a href=&quot;qdeadlinetimer#deadline&quot;&gt;deadline&lt;/a&gt;() that can be used to return &lt;code&gt;std::chrono&lt;/code&gt; objects.</source>
          <target state="translated">위의 예에서 볼 수 있듯이 QDeadlineTimer는 &lt;code&gt;std::chrono&lt;/code&gt; 객체 를 반환하는 데 사용할 수있는 &lt;a href=&quot;qdeadlinetimer#remainingTime&quot;&gt;남은 시간&lt;/a&gt; () 및 &lt;a href=&quot;qdeadlinetimer#deadline&quot;&gt;기한&lt;/a&gt; () 의 템플릿 버전을 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="9c07713bfee91ea3b4371e0451db99e7799937bd" translate="yes" xml:space="preserve">
          <source>As can be seen in the example, when a delayed reply is in place, the return value(s) from the slot will be ignored by Qt D-Bus. They are used only to determine the slot's signature when communicating the adaptor's description to remote applications, or in case the code in the slot decides not to use a delayed reply.</source>
          <target state="translated">예에서 볼 수 있듯이 지연된 응답이있을 때 Qt D-Bus는 슬롯의 반환 값을 무시합니다. 이들은 어댑터의 설명을 원격 애플리케이션과 통신 할 때 또는 슬롯의 코드가 지연된 응답을 사용하지 않기로 결정한 경우에만 슬롯의 서명을 판별하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a812ce77a7db9b2e16f6e97939903ce7443214ab" translate="yes" xml:space="preserve">
          <source>As data gets decoded, the &lt;a href=&quot;qaudiodecoder#bufferReady&quot;&gt;bufferReady&lt;/a&gt;() signal will be emitted when enough data has been decoded. Calling &lt;a href=&quot;qaudiodecoder#read&quot;&gt;read&lt;/a&gt;() will then return an audio buffer without blocking.</source>
          <target state="translated">데이터가 디코딩 되면 충분한 데이터가 디코딩되면 &lt;a href=&quot;qaudiodecoder#bufferReady&quot;&gt;bufferReady&lt;/a&gt; () 신호가 발생합니다. &lt;a href=&quot;qaudiodecoder#read&quot;&gt;read&lt;/a&gt; ()를 호출 하면 차단하지 않고 오디오 버퍼가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="425c2b50ba4939aafdebc33fae48cd4ebb023d02" translate="yes" xml:space="preserve">
          <source>As demonstrated above, Qt provides different solutions for developing threaded applications. The right solution for a given application depends on the purpose of the new thread and the thread's lifetime. Below is a comparison of Qt's threading technologies, followed by recommended solutions for some example use cases.</source>
          <target state="translated">위에서 설명한 것처럼 Qt는 스레드 응용 프로그램 개발을위한 다양한 솔루션을 제공합니다. 주어진 응용 프로그램에 적합한 솔루션은 새 스레드의 목적과 스레드 수명에 따라 다릅니다. 다음은 Qt의 스레딩 기술을 비교 한 다음 사용 사례에 대한 권장 솔루션입니다.</target>
        </trans-unit>
        <trans-unit id="f68505584f19dff80e668b01f500c3237dc5b9e2" translate="yes" xml:space="preserve">
          <source>As demonstrated in the image for &lt;a href=&quot;quick3d-asset-conditioning-anti-aliasing#reflection-aliasing&quot;&gt;Reflection Aliasing&lt;/a&gt; above, sometimes the simplest fix for problems is to change the artwork. If you are getting distracting specular glints on the corner of your model, ask yourself:</source>
          <target state="translated">위의 &lt;a href=&quot;quick3d-asset-conditioning-anti-aliasing#reflection-aliasing&quot;&gt;Reflection Aliasing&lt;/a&gt; 이미지에서 알 수 있듯이 문제를 해결하는 가장 간단한 방법은 아트웍을 변경하는 것입니다. 모델 모서리에 산만 한 반사광이 생기면 다음과 같이 자문 해보십시오.</target>
        </trans-unit>
        <trans-unit id="4b89a65b7338ce30f6a9398b5ab3e7d2967fde9a" translate="yes" xml:space="preserve">
          <source>As described above, it is simpler and more robust to set the requested format globally so that it applies to all windows and contexts during the lifetime of the application. Below is an example of this:</source>
          <target state="translated">위에서 설명한 것처럼 요청한 형식을 전체적으로 설정하는 것이 응용 프로그램 수명 동안 모든 창과 컨텍스트에 적용되도록하는 것이 더 간단하고 강력합니다. 아래는 이에 대한 예입니다.</target>
        </trans-unit>
        <trans-unit id="c3abb8aa86837a817c87c44a25ceaaef9e950a2c" translate="yes" xml:space="preserve">
          <source>As described above, subclass &lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt; to render pure 3D content in the following way:</source>
          <target state="translated">위에서 설명한 것처럼 &lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt; 서브 클래스 는 다음과 같은 방식으로 순수한 3D 컨텐츠를 렌더링합니다.</target>
        </trans-unit>
        <trans-unit id="66e2d67e62681a5e3c088fd2af2749e5f06d467b" translate="yes" xml:space="preserve">
          <source>As described above, subclass QOpenGLWidget to render pure 3D content in the following way:</source>
          <target state="translated">위에서 설명한대로 QOpenGLWidget을 하위 클래스로 지정하여 다음과 같은 방식으로 순수한 3D 콘텐츠를 렌더링합니다.</target>
        </trans-unit>
        <trans-unit id="246214847c3f39c6ad14d967249998fb5fb2c87b" translate="yes" xml:space="preserve">
          <source>As described earlier, you can add animations to transitions to make sure property assignments in the target state are animated. If you want a specific animation to be used for a given property regardless of which transition is taken, you can add it as a default animation to the state machine. This is in particular useful when the properties assigned (or restored) by specific states is not known when the machine is constructed.</source>
          <target state="translated">앞에서 설명한대로 전환에 애니메이션을 추가하여 대상 상태의 속성 할당에 애니메이션을 적용 할 수 있습니다. 어떤 전환이 수행되는지에 관계없이 특정 속성에 특정 애니메이션을 사용하려면 상태 시스템에 기본 애니메이션으로 추가 할 수 있습니다. 이것은 특정 상태에 의해 할당되거나 복원 된 속성이 기계가 구성 될 때 알려지지 않은 경우 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="78bd01a484cf2b9d5bd79ff5c06bedaecdb7a54f" translate="yes" xml:space="preserve">
          <source>As described in the &lt;a href=&quot;https://doc.qt.io/qt-5.13/qt5-intro.html#multimedia&quot;&gt;Multimedia&lt;/a&gt; overview, Qt Multimedia uses the GStreamer multimedia framework as the backend for audio and video playback on Linux. The minimum required version of GStreamer is 0.10.24. The 1.x series is also supported.</source>
          <target state="translated">&lt;a href=&quot;https://doc.qt.io/qt-5.13/qt5-intro.html#multimedia&quot;&gt;멀티미디어&lt;/a&gt; 개요 에서 설명한 것처럼 Qt Multimedia는 GStreamer multimedia 프레임 워크를 Linux에서 오디오 및 비디오 재생을위한 백엔드로 사용합니다. GStreamer의 최소 필수 버전은 0.10.24입니다. 1.x 시리즈도 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="91518b4cefcc15aae37f56837ddc9baf1eaa942b" translate="yes" xml:space="preserve">
          <source>As described in the &lt;a href=&quot;https://doc.qt.io/qt-5.15/qt5-intro.html#multimedia&quot;&gt;Multimedia&lt;/a&gt; overview, Qt Multimedia uses the GStreamer multimedia framework as the backend for audio and video playback on Linux. The minimum required version of GStreamer is 0.10.24. The 1.x series is also supported.</source>
          <target state="translated">&lt;a href=&quot;https://doc.qt.io/qt-5.15/qt5-intro.html#multimedia&quot;&gt;멀티미디어&lt;/a&gt; 개요 에서 설명한 것처럼 Qt Multimedia는 Linux에서 오디오 및 비디오 재생을위한 백엔드로 GStreamer 멀티미디어 프레임 워크를 사용합니다. GStreamer의 최소 필수 버전은 0.10.24입니다. 1.x 시리즈도 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="907c7ec10d943c9ac0a46e5302735bc14779b04a" translate="yes" xml:space="preserve">
          <source>As different position sources are available on different platforms and devices, these are categorized by their basic type (Satellite, NonSatellite, and AllPositioningMethods). The available methods for the current platform can be enumerated in the &lt;a href=&quot;qml-qtpositioning-positionsource#supportedPositioningMethods-prop&quot;&gt;supportedPositioningMethods&lt;/a&gt; property.</source>
          <target state="translated">서로 다른 플랫폼 및 장치에서 서로 다른 위치 소스를 사용할 수 있으므로 기본 유형 (위성, 비 위성 및 AllPositioningMethods)별로 분류됩니다. 현재 플랫폼에 사용 가능한 메소드는 &lt;a href=&quot;qml-qtpositioning-positionsource#supportedPositioningMethods-prop&quot;&gt;supportedPositioningMethods&lt;/a&gt; 특성에 열거 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d33215b6eb121bc79dc9759565d123bb00349b7d" translate="yes" xml:space="preserve">
          <source>As display resolutions improve, a scalable application UI becomes more and more important. One of the approaches to achieve this is to maintain several copies of the UI for different screen resolutions, and load the appropriate one depending on the available resolution. Although this works pretty well, it adds to the maintenance overhead.</source>
          <target state="translated">디스플레이 해상도가 향상됨에 따라 확장 가능한 응용 프로그램 UI가 점점 더 중요 해지고 있습니다. 이를 달성하기위한 접근 방법 중 하나는 다른 화면 해상도에 대해 여러 개의 UI 사본을 유지하고 사용 가능한 해상도에 따라 적절한 것을로드하는 것입니다. 이것은 잘 작동하지만 유지 관리 오버 헤드가 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="78e7e77c94f602064f7512ab2dd39e931cb8cfa7" translate="yes" xml:space="preserve">
          <source>As documented above, passing arguments is done like this:</source>
          <target state="translated">위에서 설명한 것처럼 인수 전달은 다음과 같이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="6f68e5f667079fcbd12efef41a1536d08e865049" translate="yes" xml:space="preserve">
          <source>As each item is positioned along the path, it will be rotated accordingly: an item at the beginning of the path with be not be rotated, an item at the end of the path will be rotated 90 degrees, and an item mid-way along the path will be rotated 45 degrees.</source>
          <target state="translated">각 항목이 경로를 따라 배치되면 그에 따라 회전합니다. 경로의 시작 부분에있는 항목은 회전하지 않으며, 경로 끝에있는 항목은 90도 회전하고 중간에있는 항목 경로가 45도 회전합니다.</target>
        </trans-unit>
        <trans-unit id="4d8092e5f37be8cb59e1f0172d9b2829973bd770" translate="yes" xml:space="preserve">
          <source>As explained in &lt;a href=&quot;qtquickcontrols2-customize#definition-of-a-style&quot;&gt;Definition of a Style&lt;/a&gt;, when you implement your own style for a control, you start off with the relevant template for that control. For example, a style's &lt;code&gt;Button.qml&lt;/code&gt; will be structured similarly to this:</source>
          <target state="translated">&lt;a href=&quot;qtquickcontrols2-customize#definition-of-a-style&quot;&gt;스타일 정의에&lt;/a&gt; 설명 된대로 컨트롤에 대해 고유 한 스타일을 구현할 때 해당 컨트롤에 대한 관련 템플릿으로 시작합니다. 예를 들어 스타일의 &lt;code&gt;Button.qml&lt;/code&gt; 은 다음과 유사하게 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="861b1e52071780e34475f74bb1740de8a6475295" translate="yes" xml:space="preserve">
          <source>As for ClampToEdge but also blends samples at 0 and 1 with a fixed border color. Equivalent to GL_CLAMP_TO_BORDER</source>
          <target state="translated">ClampToEdge는 0과 1의 샘플을 고정 테두리 색상과 혼합합니다. GL_CLAMP_TO_BORDER와 동일</target>
        </trans-unit>
        <trans-unit id="489756ab6af4bb3f5d866c9af89a60d617a7a7a5" translate="yes" xml:space="preserve">
          <source>As for the OpenGL headers, note that in most cases there will be no need to directly include any headers like GL.h. The OpenGL-related Qt headers will include qopengl.h which will in turn include an appropriate header for the system. This might be an OpenGL ES 3.x or 2.0 header, the highest version that is available, or a system-provided gl.h. In addition, a copy of the extension headers (called glext.h on some systems) is provided as part of Qt both for OpenGL and OpenGL ES. These will get included automatically on platforms where feasible. This means that constants and function pointer typedefs from ARB, EXT, OES extensions are automatically available.</source>
          <target state="translated">OpenGL 헤더는 대부분의 경우 GL.h와 같은 헤더를 직접 포함 할 필요가 없습니다. OpenGL 관련 Qt 헤더에는 qopengl.h가 포함되며 시스템에 적절한 헤더가 포함됩니다. OpenGL ES 3.x 또는 2.0 헤더, 사용 가능한 최고 버전 또는 시스템 제공 gl.h 일 수 있습니다. 또한 확장 헤더 (일부 시스템에서는 glext.h)의 사본이 OpenGL 및 OpenGL ES 모두에 대한 Qt의 일부로 제공됩니다. 이들은 가능한 플랫폼에 자동으로 포함됩니다. 이는 ARB, EXT, OES 확장의 상수 및 함수 포인터 typedef를 자동으로 사용할 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="d50557d0d19a426698ae7938601d4626b0b5ca0f" translate="yes" xml:space="preserve">
          <source>As it can be seen in the example, the main patterns in &lt;a href=&quot;qvulkanwindow&quot;&gt;QVulkanWindow&lt;/a&gt; usage are:</source>
          <target state="translated">예제에서 볼 수 있듯이 &lt;a href=&quot;qvulkanwindow&quot;&gt;QVulkanWindow&lt;/a&gt; 사용법 의 주요 패턴 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a1c844fb55d3078b245dfb37301a6fb1be70ea3c" translate="yes" xml:space="preserve">
          <source>As it can be seen in the example, the main patterns in QVulkanWindow usage are:</source>
          <target state="translated">예제에서 볼 수 있듯이 QVulkanWindow 사용의 주요 패턴은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e2cbb3412cfa11fa400d2042ce868ec63ec4797e" translate="yes" xml:space="preserve">
          <source>As it is inherited from Popup, Menu supports &lt;a href=&quot;qml-qtquick-controls2-popup#margins-prop&quot;&gt;margins&lt;/a&gt;. By default, all of the built-in styles specify &lt;code&gt;0&lt;/code&gt; for Menu's margins to ensure that the menu is kept within the bounds of the window. To allow a menu to go outside of the window (to animate it moving into view, for example), set the margins property to &lt;code&gt;-1&lt;/code&gt;.</source>
          <target state="translated">Popup에서 상속 된 Menu는 &lt;a href=&quot;qml-qtquick-controls2-popup#margins-prop&quot;&gt;여백을&lt;/a&gt; 지원 합니다 . 기본적으로 모든 내장 스타일 은 메뉴가 창 경계 내에 유지되도록 메뉴의 여백에 &lt;code&gt;0&lt;/code&gt; 을 지정 합니다. 메뉴가 창 외부로 이동하도록 허용하려면 (예 :보기로 이동하는 애니메이션) margins 속성을 &lt;code&gt;-1&lt;/code&gt; 로 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="04c2e61ea3a70bcef0b5bcd6d6e0dd251f40caa8" translate="yes" xml:space="preserve">
          <source>As item coordinates are relative to the visual parent, they can be affected by changes to the visual hierarchy. See the &lt;a href=&quot;qtquick-visualcanvas-coordinates&quot;&gt;Visual Coordinates&lt;/a&gt; concept page for more detail.</source>
          <target state="translated">항목 좌표는 시각적 상위 항목에 상대적이므로 시각적 계층 구조의 변경에 의해 영향을받을 수 있습니다. 자세한 내용은 &lt;a href=&quot;qtquick-visualcanvas-coordinates&quot;&gt;시각적 좌표&lt;/a&gt; 개념 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a3804e05753d87efd96930eede46d873ac4b9420" translate="yes" xml:space="preserve">
          <source>As item coordinates are relative to the visual parent, they can be affected by changes to the visual hierarchy. See the &lt;a href=&quot;qtquick-visualcanvas-coordinates#&quot;&gt;Visual Coordinates&lt;/a&gt; concept page for more detail.</source>
          <target state="translated">항목 좌표는 시각적 부모를 기준으로하므로 시각적 계층 구조의 변경으로 인해 영향을받을 수 있습니다. 자세한 내용은 &lt;a href=&quot;qtquick-visualcanvas-coordinates#&quot;&gt;시각 좌표&lt;/a&gt; 개념 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="66d9f61cd79e723319436c749804aa211e9990d0" translate="yes" xml:space="preserve">
          <source>As long as no special locale has been set, this is either the parent's locale or (if this widget is a top level widget), the default locale.</source>
          <target state="translated">특별한 로케일이 설정되어 있지 않는 한, 이것은 부모의 로케일이거나 (이 위젯이 최상위 레벨 위젯 인 경우) 기본 로케일입니다.</target>
        </trans-unit>
        <trans-unit id="0d7562e6e80c6bec5b6cf3c7303cabae888bbc8d" translate="yes" xml:space="preserve">
          <source>As long as one profile has</source>
          <target state="translated">하나의 프로필이있는 한</target>
        </trans-unit>
        <trans-unit id="31771cf7889c576bb0045b26111ec89c137f881e" translate="yes" xml:space="preserve">
          <source>As long as one profile has this option enabled, all other profiles will be able to use it for certificate verification. Only one profile at a time can have this option enabled. It is recommended that the profile has a disk HTTP cache to avoid needlessly re-downloading.</source>
          <target state="translated">한 프로필에이 옵션이 활성화되어 있으면 다른 모든 프로필에서 인증서 확인에 사용할 수 있습니다. 한 번에 하나의 프로필 만이 옵션을 활성화 할 수 있습니다. 불필요하게 다시 다운로드하지 않도록 프로파일에 디스크 HTTP 캐시가있는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="c96c1b2238372f73f620d630a822f0fe4ed71178" translate="yes" xml:space="preserve">
          <source>As mentioned above &lt;a href=&quot;qset&quot;&gt;QSet&lt;/a&gt;'s iterator classes have exactly the same API as &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt;'s. We will now turn to &lt;a href=&quot;qmapiterator&quot;&gt;QMapIterator&lt;/a&gt;, which is somewhat different because it iterates on (key, value) pairs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="002c4e8870afe05bd95ad7ebb6b17435ad918766" translate="yes" xml:space="preserve">
          <source>As mentioned above, &lt;a href=&quot;qlinkedlist&quot;&gt;QLinkedList&lt;/a&gt;'s, &lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt;'s, and &lt;a href=&quot;qset&quot;&gt;QSet&lt;/a&gt;'s iterator classes have exactly the same API as &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt;'s. We will now turn to &lt;a href=&quot;qmapiterator&quot;&gt;QMapIterator&lt;/a&gt;, which is somewhat different because it iterates on (key, value) pairs.</source>
          <target state="translated">위에서 언급했듯이 &lt;a href=&quot;qlinkedlist&quot;&gt;QLinkedList&lt;/a&gt; , &lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt; 및 &lt;a href=&quot;qset&quot;&gt;QSet&lt;/a&gt; 반복자 클래스는 &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt; 와 정확히 동일한 API를 갖습니다 . 이제 &lt;a href=&quot;qmapiterator&quot;&gt;QMapIterator&lt;/a&gt; 로 돌아가서 (키, 값) 쌍을 반복하기 때문에 다소 다릅니다.</target>
        </trans-unit>
        <trans-unit id="81a21b6a2caa3fb1706b7044f9398496bbe4cdbb" translate="yes" xml:space="preserve">
          <source>As mentioned above, &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; provides a lot of functions and operators that make it easy to interoperate with &lt;code&gt;const char *&lt;/code&gt; strings. But this functionality is a double-edged sword: It makes &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; more convenient to use if all strings are US-ASCII or Latin-1, but there is always the risk that an implicit conversion from or to &lt;code&gt;const char *&lt;/code&gt; is done using the wrong 8-bit encoding. To minimize these risks, you can turn off these implicit conversions by defining the following two preprocessor symbols:</source>
          <target state="translated">위에서 언급했듯이 &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; 은 &lt;code&gt;const char *&lt;/code&gt; 문자열 과 쉽게 상호 운용 할 수 있도록 많은 함수와 연산자를 제공합니다 . 그러나이 기능은 양날의 칼입니다. 모든 문자열이 US-ASCII 또는 Latin-1 인 경우 &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; 을 사용하는 것이 더 편리하지만 항상 잘못된 &lt;code&gt;const char *&lt;/code&gt; 사용하여 const char * 로 암시 적으로 변환 할 위험이 있습니다. 8 비트 인코딩. 이러한 위험을 최소화하기 위해 다음 두 개의 전 처리기 기호를 정의하여 이러한 암시 적 변환을 해제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2234adfe08eca0c20b72ebfc9aa79b29023e7600" translate="yes" xml:space="preserve">
          <source>As mentioned above, QLinkedList's, &lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt;'s, and &lt;a href=&quot;qset&quot;&gt;QSet&lt;/a&gt;'s iterator classes have exactly the same API as &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt;'s. We will now turn to &lt;a href=&quot;qmapiterator&quot;&gt;QMapIterator&lt;/a&gt;, which is somewhat different because it iterates on (key, value) pairs.</source>
          <target state="translated">위에서 언급했듯이 QLinkedList, &lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt; 및 &lt;a href=&quot;qset&quot;&gt;QSet&lt;/a&gt; 의 반복기 클래스는 &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt; 와 정확히 동일한 API를 갖습니다 . 이제 (키, 값) 쌍을 반복하기 때문에 다소 다른 &lt;a href=&quot;qmapiterator&quot;&gt;QMapIterator로&lt;/a&gt; 전환합니다 .</target>
        </trans-unit>
        <trans-unit id="ad3c0426db7f481859ae08284fc77ab2d8467e94" translate="yes" xml:space="preserve">
          <source>As mentioned above, QString provides a lot of functions and operators that make it easy to interoperate with &lt;code&gt;const char *&lt;/code&gt; strings. But this functionality is a double-edged sword: It makes QString more convenient to use if all strings are US-ASCII or Latin-1, but there is always the risk that an implicit conversion from or to &lt;code&gt;const char *&lt;/code&gt; is done using the wrong 8-bit encoding. To minimize these risks, you can turn off these implicit conversions by defining some of the following preprocessor symbols:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c889bb24d5bfcb492d0a94a2cbe6ab76a065ac43" translate="yes" xml:space="preserve">
          <source>As mentioned above, QString provides a lot of functions and operators that make it easy to interoperate with &lt;code&gt;const char *&lt;/code&gt; strings. But this functionality is a double-edged sword: It makes QString more convenient to use if all strings are US-ASCII or Latin-1, but there is always the risk that an implicit conversion from or to &lt;code&gt;const char *&lt;/code&gt; is done using the wrong 8-bit encoding. To minimize these risks, you can turn off these implicit conversions by defining the following two preprocessor symbols:</source>
          <target state="translated">위에서 언급했듯이 QString은 &lt;code&gt;const char *&lt;/code&gt; 문자열 과 쉽게 상호 운용 할 수 있도록하는 많은 함수와 연산자를 제공합니다 . 그러나이 기능은 양날의 검입니다. 모든 문자열이 US-ASCII 또는 Latin-1 인 경우 QString을 사용하는 것이 더 편리해 지지만 항상 잘못된 사용 으로 &lt;code&gt;const char *&lt;/code&gt; 로의 암시 적 변환 이 수행 될 위험이 있습니다. 8 비트 인코딩. 이러한 위험을 최소화하려면 다음 두 전 처리기 기호를 정의하여 이러한 암시 적 변환을 해제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb8b100197ae92be540c33ca3c3a18d757a58d0f" translate="yes" xml:space="preserve">
          <source>As mentioned above, enabling touch events means multiple widgets can be receiving touch events simultaneously. Combined with the default &lt;a href=&quot;qwidget#event&quot;&gt;QWidget::event&lt;/a&gt;() handling for QTouchEvents, this gives you great flexibility in designing touch user interfaces. Be aware of the implications. For example, it is possible that the user is moving a &lt;a href=&quot;qslider&quot;&gt;QSlider&lt;/a&gt; with one finger and pressing a &lt;a href=&quot;qpushbutton&quot;&gt;QPushButton&lt;/a&gt; with another. The signals emitted by these widgets will be interleaved.</source>
          <target state="translated">위에서 언급했듯이 터치 이벤트를 활성화하면 여러 위젯이 동시에 터치 이벤트를 수신 할 수 있습니다. QTouchEvents에 대한 기본 &lt;a href=&quot;qwidget#event&quot;&gt;QWidget :: event&lt;/a&gt; () 처리 와 결합하여 터치 사용자 인터페이스를 설계하는 데 큰 유연성을 제공합니다. 그 의미에 유의하십시오. 예를 들어, 사용자가 한 손가락 으로 &lt;a href=&quot;qslider&quot;&gt;QSlider&lt;/a&gt; 를 움직이고 다른 손가락으로 &lt;a href=&quot;qpushbutton&quot;&gt;QPushButton&lt;/a&gt; 을 누를 수 있습니다 . 이 위젯에서 방출 된 신호는 인터리브됩니다.</target>
        </trans-unit>
        <trans-unit id="e27c2c7f1a131f4e8e3e5ba33bedce5cd8cd5bad" translate="yes" xml:space="preserve">
          <source>As mentioned above, it is possible that several widgets can be receiving QTouchEvents at the same time. However, Qt makes sure to never send duplicate &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent::TouchBegin&lt;/a&gt; events to the same widget, which could theoretically happen during propagation if, for example, the user touched 2 separate widgets in a &lt;a href=&quot;qgroupbox&quot;&gt;QGroupBox&lt;/a&gt; and both widgets ignored the &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent::TouchBegin&lt;/a&gt; event.</source>
          <target state="translated">위에서 언급 한 것처럼 여러 위젯이 동시에 QTouchEvents를 수신 할 수 있습니다. 그러나 Qt는 중복 &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent :: TouchBegin&lt;/a&gt; 이벤트를 동일한 위젯으로 보내지 않도록합니다 . 이는 예를 들어 사용자가 &lt;a href=&quot;qgroupbox&quot;&gt;QGroupBox&lt;/a&gt; 에서 두 개의 개별 위젯을 터치 하고 두 위젯이 &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent :: TouchBegin&lt;/a&gt; 이벤트를 무시한 경우 전파 중에 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="842f60ca18c98159f9759ca7612c939b63965419" translate="yes" xml:space="preserve">
          <source>As mentioned earlier, some sequence types are fast (for example, &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt;&amp;lt;int&amp;gt;, &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt;&amp;lt;qreal&amp;gt;, &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt;&amp;lt;bool&amp;gt;, &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt;&amp;lt;&lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;&amp;gt;, &lt;a href=&quot;qstringlist&quot;&gt;QStringList&lt;/a&gt; and &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt;&amp;lt;&lt;a href=&quot;qurl&quot;&gt;QUrl&lt;/a&gt;&amp;gt;) while others will be much slower. Aside from using these types wherever possible instead of slower types, there are some other performance-related semantics you need to be aware of to achieve the best performance.</source>
          <target state="translated">앞에서 언급했듯이 일부 시퀀스 유형은 빠르지 만 (예 : &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt; &amp;lt;int&amp;gt;, &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt; &amp;lt;qreal&amp;gt;, &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt; &amp;lt;bool&amp;gt;, &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt; &amp;lt; &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; &amp;gt;, &lt;a href=&quot;qstringlist&quot;&gt;QStringList&lt;/a&gt; 및 &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt; &amp;lt; &lt;a href=&quot;qurl&quot;&gt;QUrl&lt;/a&gt; &amp;gt;) 다른 시퀀스 유형은 훨씬 느립니다. 느린 유형 대신 가능한 이러한 유형을 사용하는 것 외에도 최상의 성능을 달성하기 위해 알아야 할 다른 성능 관련 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="413f8bb6617d772b733f618e8bca7fd5ef11ac7c" translate="yes" xml:space="preserve">
          <source>As mentioned in the &lt;a href=&quot;qsettings#fallback-mechanism&quot;&gt;Fallback Mechanism&lt;/a&gt; section, &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; stores settings for an application in up to four locations, depending on whether the settings are user-specific or system-wide and whether the settings are application-specific or organization-wide. For simplicity, we're assuming the organization is called MySoft and the application is called Star Runner.</source>
          <target state="translated">&lt;a href=&quot;qsettings#fallback-mechanism&quot;&gt;폴백 메커니즘&lt;/a&gt; 섹션 에서 언급했듯이 &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; 는 설정이 사용자 별인지 시스템 전체인지, 설정이 응용 프로그램 별인지 조직 전체인지에 따라 최대 4 개의 위치에 응용 프로그램의 설정을 저장합니다. 간단히하기 위해 조직을 MySoft라고하고 응용 프로그램을 Star Runner라고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="4a582ccf62f0b3d6d7e220ab3d152e785d0177ab" translate="yes" xml:space="preserve">
          <source>As mentioned in the &lt;a href=&quot;qsettings#fallback-mechanism&quot;&gt;Fallback Mechanism&lt;/a&gt; section, QSettings stores settings for an application in up to four locations, depending on whether the settings are user-specific or system-wide and whether the settings are application-specific or organization-wide. For simplicity, we're assuming the organization is called MySoft and the application is called Star Runner.</source>
          <target state="translated">&lt;a href=&quot;qsettings#fallback-mechanism&quot;&gt;대체 메커니즘&lt;/a&gt; 섹션 에서 언급했듯이 QSettings는 설정이 사용자 별인지 시스템 전체인지 및 설정이 애플리케이션 별인지 조직 전체인지에 따라 최대 4 개의 위치에 애플리케이션에 대한 설정을 저장합니다. 단순화를 위해 조직을 MySoft라고하고 애플리케이션을 Star Runner라고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="59b29575bf97efd6cf0e380e5a427a5042993f47" translate="yes" xml:space="preserve">
          <source>As mentioned in the documentation for &lt;a href=&quot;qml-qtquick-controls-styles-circulargaugestyle&quot;&gt;CircularGaugeStyle&lt;/a&gt;, &lt;code&gt;implicitWidth&lt;/code&gt; and &lt;code&gt;implicitHeight&lt;/code&gt; properties need to be set. This is so that the needle can be positioned properly. We always scale items by the &lt;a href=&quot;qml-qtquick-controls-styles-circulargaugestyle#outerRadius-prop&quot;&gt;outerRadius&lt;/a&gt; property of the style, ensuring the control resizes gracefully.</source>
          <target state="translated">설명서에서 언급 한 바와 같이 &lt;a href=&quot;qml-qtquick-controls-styles-circulargaugestyle&quot;&gt;CircularGaugeStyle&lt;/a&gt; , &lt;code&gt;implicitWidth&lt;/code&gt; 및 &lt;code&gt;implicitHeight&lt;/code&gt; 속성을 설정해야합니다. 바늘을 올바르게 배치 할 수 있습니다. 스타일 의 &lt;a href=&quot;qml-qtquick-controls-styles-circulargaugestyle#outerRadius-prop&quot;&gt;outerRadius&lt;/a&gt; 속성에 따라 항목의 크기를 항상 조정 하여 컨트롤의 크기가 정상적으로 조정되도록합니다.</target>
        </trans-unit>
        <trans-unit id="2c73f69dd3ecef2136f58b17125e12e11ebeaf9a" translate="yes" xml:space="preserve">
          <source>As mentioned in the documentation for &lt;a href=&quot;qml-qtquick-controls-styles-gaugestyle&quot;&gt;GaugeStyle&lt;/a&gt;, &lt;code&gt;implicitWidth&lt;/code&gt; needs to be set when defining your own value bar.</source>
          <target state="translated">설명서에서 언급 한 바와 같이 &lt;a href=&quot;qml-qtquick-controls-styles-gaugestyle&quot;&gt;GaugeStyle&lt;/a&gt; , &lt;code&gt;implicitWidth&lt;/code&gt; 는 자신의 가치 줄을 정의 할 때 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="75374d7df1668bbaacf5dffb82c2b7af658e31eb" translate="yes" xml:space="preserve">
          <source>As mentioned previously, Qt is offering classes that makes it easy to use OpenGL in Qt applications. For example, the &lt;a href=&quot;qopenglpaintdevice&quot;&gt;QOpenGLPaintDevice&lt;/a&gt; enables the OpenGL API for rendering with &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt;.</source>
          <target state="translated">앞에서 언급했듯이 Qt는 Qt 애플리케이션에서 OpenGL을 쉽게 사용할 수있는 클래스를 제공합니다. 예를 들어 &lt;a href=&quot;qopenglpaintdevice&quot;&gt;QOpenGLPaintDevice&lt;/a&gt; 는 OpenGL API가 &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; 로 렌더링 할 수 있도록합니다 .</target>
        </trans-unit>
        <trans-unit id="eb8514c32d9fe77e8e0fe4ca4e6881d7cdd5c555" translate="yes" xml:space="preserve">
          <source>As mentioned previously, the development workflow consists of maintaining a normal &lt;code&gt;.pro&lt;/code&gt; file project and exporting it to Xcode.</source>
          <target state="translated">앞에서 언급했듯이 개발 워크 플로는 일반 &lt;code&gt;.pro&lt;/code&gt; 파일 프로젝트 를 유지 관리하고 Xcode로 내보내는 것으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="0bfbd65474a5e18aa6c766d023047ecf56dbb147" translate="yes" xml:space="preserve">
          <source>As mentioned previously, you must have Xcode installed.</source>
          <target state="translated">앞에서 언급했듯이 Xcode가 설치되어 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="f5efce2190a3fa7f47a42983fe443a3543946698" translate="yes" xml:space="preserve">
          <source>As mentioned, a tree structure is built from the accessible objects of an application. By navigating through the tree, the clients can access all elements in the UI. Object relations give clients information about the UI. For instance, a slider handle is a child of the slider to which it belongs. &lt;a href=&quot;qaccessible#RelationFlag-enum&quot;&gt;QAccessible::Relation&lt;/a&gt; describes the various relationships the clients can ask objects for.</source>
          <target state="translated">언급 한 바와 같이, 트리 구조는 응용 프로그램의 액세스 가능한 객체로 구성됩니다. 클라이언트는 트리를 탐색하여 UI의 모든 요소에 액세스 할 수 있습니다. 객체 관계는 클라이언트에게 UI에 대한 정보를 제공합니다. 예를 들어 슬라이더 핸들은 해당 슬라이더의 자식입니다. &lt;a href=&quot;qaccessible#RelationFlag-enum&quot;&gt;QAccessible :: Relation&lt;/a&gt; 은 클라이언트가 객체를 요청할 수있는 다양한 관계를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="6eb6dfb23cfc2cd2dc5a66c3e1900545bf5c2efd" translate="yes" xml:space="preserve">
          <source>As mentioned, the style calculates the size of the widget's contents, which the widgets calculate their size hints from. In addition, complex controls also use the style to test which sub-controls the mouse is over.</source>
          <target state="translated">언급 한 바와 같이, 스타일은 위젯 컨텐츠의 크기를 계산하며 위젯은 크기 힌트를 계산합니다. 또한 복잡한 컨트롤은 스타일을 사용하여 마우스가 어떤 하위 컨트롤에 있는지 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="86d2ba9ecac6357d5ccfea9fd802209a5c931c21" translate="yes" xml:space="preserve">
          <source>As model manipulation in Qt is done via row and column indices, and because object keys are unordered, each column must be specified via &lt;a href=&quot;qml-qt-labs-qmlmodels-tablemodelcolumn&quot;&gt;TableModelColumn&lt;/a&gt;. This allows mapping Qt's built-in roles to any property in each row object.</source>
          <target state="translated">Qt의 모델 조작은 행 및 열 인덱스를 통해 수행되고 객체 키가 정렬되지 않기 때문에 각 열은 &lt;a href=&quot;qml-qt-labs-qmlmodels-tablemodelcolumn&quot;&gt;TableModelColumn을&lt;/a&gt; 통해 지정해야합니다 . 이를 통해 Qt의 기본 제공 역할을 각 행 개체의 모든 속성에 매핑 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="96ec771177724b9285cdfaacb71d52b1794dce5c" translate="yes" xml:space="preserve">
          <source>As of &lt;code&gt;QtQuick 1.1&lt;/code&gt;, this method accepts an optional</source>
          <target state="translated">현재 &lt;code&gt;QtQuick 1.1&lt;/code&gt; ,이 방법은 선택을 받아</target>
        </trans-unit>
        <trans-unit id="da31871d3911fae6e231bbfb632ec219b2e229e8" translate="yes" xml:space="preserve">
          <source>As of Qt 4.2, the unique ID is the same regardless of the orientation of the pen. Earlier versions would report a different value when using the eraser-end versus the pen-end of the stylus on some OS's.</source>
          <target state="translated">Qt 4.2에서 펜의 방향에 관계없이 고유 ID는 동일합니다. 이전 버전에서는 일부 OS에서 지우개 끝과 스타일러스 펜 끝을 사용할 때 다른 값을보고합니다.</target>
        </trans-unit>
        <trans-unit id="363909d9e3537691b78aebe9f4dc2964d1a5e138" translate="yes" xml:space="preserve">
          <source>As of Qt 5.11, headless mode via DRM render nodes is supported. This allows performing GPU compute (OpenGL compute shaders, OpenCL) or offscreen OpenGL rendering without needing DRM master privileges. In this mode, applications can function even when there is already another process outputting to the screen.</source>
          <target state="translated">Qt 5.11부터 DRM 렌더 노드를 통한 헤드리스 모드가 지원됩니다. 이를 통해 DRM 마스터 권한없이 GPU 컴퓨팅 (OpenGL 컴퓨팅 셰이더, OpenCL) 또는 오프 스크린 OpenGL 렌더링을 수행 할 수 있습니다. 이 모드에서는 이미 다른 프로세스가 화면에 출력되고있는 경우에도 응용 프로그램이 작동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="58d3498b0d26d621ce28ccc9cc34a3013c373163" translate="yes" xml:space="preserve">
          <source>As of Qt 5.11, screen cloning (mirroring) is supported. This is enabled via the &lt;code&gt;clones&lt;/code&gt; property:</source>
          <target state="translated">Qt 5.11부터 화면 복제 (미러링)가 지원됩니다. 이것은 &lt;code&gt;clones&lt;/code&gt; 속성을 통해 활성화됩니다 .</target>
        </trans-unit>
        <trans-unit id="de7cef78c878d264af7cc4518489aacd6eec83dc" translate="yes" xml:space="preserve">
          <source>As of Qt 5.12 Shape.NvprRenderer is disabled by default and a uniform behavior, based on triangulating the path and generating &lt;a href=&quot;qsggeometrynode&quot;&gt;QSGGeometryNode&lt;/a&gt; instances, is used regardless of the graphics card and drivers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e13761e0850786724fe482f4f489d14e8e4b19b" translate="yes" xml:space="preserve">
          <source>As of Qt 5.12 Shape.NvprRenderer is disabled by default and a uniform behavior, based on triangulating the path and generating &lt;a href=&quot;qsggeometrynode&quot;&gt;QSGGeometryNode&lt;/a&gt; instances, is used regardless of the graphics card and drivers. To enable using vendor-specific path rendering approaches set the value to &lt;code&gt;true&lt;/code&gt;. Depending on the platform and content, this can lead to improved performance. Setting the value to &lt;code&gt;true&lt;/code&gt; is safe in any case since rendering falls back to the default method when the vendor-specific approach, such as &lt;code&gt;GL_NV_path_rendering&lt;/code&gt;, is not supported at run time.</source>
          <target state="translated">Qt 5.12부터 Shape.NvprRenderer는 기본적으로 비활성화되어 있으며 경로를 삼각 측량하고 &lt;a href=&quot;qsggeometrynode&quot;&gt;QSGGeometryNode&lt;/a&gt; 인스턴스 생성을 기반으로하는 균일 한 동작 이 그래픽 카드 및 드라이버에 관계없이 사용됩니다. 공급 업체별 경로 렌더링 접근 방식을 사용하려면 값을 &lt;code&gt;true&lt;/code&gt; 로 설정하십시오 . 플랫폼 및 컨텐츠에 따라 성능이 향상 될 수 있습니다. &lt;code&gt;GL_NV_path_rendering&lt;/code&gt; 과 같은 공급 업체별 접근 방식 이 런타임에 지원되지 않으면 렌더링이 기본 메소드로 다시 돌아가므로 값을 &lt;code&gt;true&lt;/code&gt; 로 설정하는 것이 안전 합니다.</target>
        </trans-unit>
        <trans-unit id="6f1949e480a7858c47a022532f290ed611d92635" translate="yes" xml:space="preserve">
          <source>As of Qt 5.7 this backend shares many of its internal implementation with the GBM-based backend. This means that multiple screens and the advanced configuration via &lt;code&gt;QT_QPA_EGLFS_KMS_CONFIG&lt;/code&gt; are supported. Some settings, such as &lt;code&gt;hwcursor&lt;/code&gt; and &lt;code&gt;pbuffers&lt;/code&gt; are not applicable however.</source>
          <target state="translated">Qt 5.7 현재이 백엔드는 많은 내부 구현을 GBM 기반 백엔드와 공유합니다. 이는 여러 화면과 &lt;code&gt;QT_QPA_EGLFS_KMS_CONFIG&lt;/code&gt; 를 통한 고급 구성 이 지원됨을 의미합니다. 그러나 &lt;code&gt;hwcursor&lt;/code&gt; 및 &lt;code&gt;pbuffers&lt;/code&gt; 와 같은 일부 설정 은 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b9e634ae2b6dbe8da9c7dd5c9b7ada24ee6870e8" translate="yes" xml:space="preserve">
          <source>As of Qt 5.9, support for caching program binaries on disk is built in. To enable this, switch to using &lt;a href=&quot;qopenglshaderprogram#addCacheableShaderFromSourceCode&quot;&gt;addCacheableShaderFromSourceCode&lt;/a&gt;() and &lt;a href=&quot;qopenglshaderprogram#addCacheableShaderFromSourceFile&quot;&gt;addCacheableShaderFromSourceFile&lt;/a&gt;(). With an OpenGL ES 3.x context or support for &lt;code&gt;GL_ARB_get_program_binary&lt;/code&gt;, this will transparently cache program binaries under &lt;a href=&quot;qstandardpaths#StandardLocation-enum&quot;&gt;QStandardPaths::GenericCacheLocation&lt;/a&gt; or &lt;a href=&quot;qstandardpaths#StandardLocation-enum&quot;&gt;QStandardPaths::CacheLocation&lt;/a&gt;. When support is not available, calling the cacheable function variants is equivalent to the normal ones.</source>
          <target state="translated">Qt 5.9부터 디스크에 프로그램 바이너리 캐싱 지원이 내장되어 있습니다.이를 가능하게하려면 &lt;a href=&quot;qopenglshaderprogram#addCacheableShaderFromSourceCode&quot;&gt;addCacheableShaderFromSourceCode&lt;/a&gt; () 및 &lt;a href=&quot;qopenglshaderprogram#addCacheableShaderFromSourceFile&quot;&gt;addCacheableShaderFromSourceFile&lt;/a&gt; () 을 사용 하도록 전환하십시오 . OpenGL ES 3.x 컨텍스트 또는 &lt;code&gt;GL_ARB_get_program_binary&lt;/code&gt; 지원으로 QStandardPaths &lt;a href=&quot;qstandardpaths#StandardLocation-enum&quot;&gt;:: GenericCacheLocation&lt;/a&gt; 또는 &lt;a href=&quot;qstandardpaths#StandardLocation-enum&quot;&gt;QStandardPaths :: &lt;/a&gt;CacheLocation 아래에 프로그램 바이너리가 투명하게 캐시됩니다 . 지원을 사용할 수없는 경우 캐시 가능한 함수 변형을 호출하는 것은 일반적인 변형과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="447f717e2266f7759adfc3c89a2edd9d42d79f51" translate="yes" xml:space="preserve">
          <source>As of Qt 5.9, the behavior of EGLFS and &lt;a href=&quot;#linuxfb&quot;&gt;LinuxFB&lt;/a&gt; have been synchronized, with regards to the window sizing policy: the first top-level window is forced to cover the entire screen, with both platform plugins. If this is not desired, set the &lt;code&gt;QT_QPA_FB_FORCE_FULLSCREEN&lt;/code&gt; environment variable to &lt;code&gt;0&lt;/code&gt; to restore the behavior from earlier Qt versions.</source>
          <target state="translated">Qt 5.9에서, 창 크기 조정 정책과 관련하여 EGLFS 및 &lt;a href=&quot;#linuxfb&quot;&gt;LinuxFB&lt;/a&gt; 의 동작 이 동기화되었습니다. 첫 번째 최상위 창은 두 플랫폼 플러그인으로 전체 화면을 강제로 적용합니다. 이를 원하지 않는 경우 &lt;code&gt;QT_QPA_FB_FORCE_FULLSCREEN&lt;/code&gt; 환경 변수를 &lt;code&gt;0&lt;/code&gt; 으로 설정하여 이전 Qt 버전에서 동작을 복원하십시오.</target>
        </trans-unit>
        <trans-unit id="9e696d10283412598864a21f88e8429e27e52880" translate="yes" xml:space="preserve">
          <source>As of Qt 5.9, the behavior of EGLFS and &lt;a href=&quot;embedded-linux#linuxfb&quot;&gt;LinuxFB&lt;/a&gt; have been synchronized, with regards to the window sizing policy: the first top-level window is forced to cover the entire screen, with both platform plugins. If this is not desired, set the &lt;code&gt;QT_QPA_FB_FORCE_FULLSCREEN&lt;/code&gt; environment variable to &lt;code&gt;0&lt;/code&gt; to restore the behavior from earlier Qt versions.</source>
          <target state="translated">Qt 5.9 부터 창 크기 조정 정책과 관련하여 EGLFS 및 &lt;a href=&quot;embedded-linux#linuxfb&quot;&gt;LinuxFB&lt;/a&gt; 의 동작 이 동기화되었습니다. 첫 번째 최상위 창은 두 플랫폼 플러그인을 사용하여 전체 화면을 덮도록 강제됩니다. 원하지 않는 경우 &lt;code&gt;QT_QPA_FB_FORCE_FULLSCREEN&lt;/code&gt; 환경 변수를 &lt;code&gt;0&lt;/code&gt; 으로 설정하여 이전 Qt 버전에서 동작을 복원하십시오.</target>
        </trans-unit>
        <trans-unit id="904fcee57d2478d5cd1542e59e176d420e0e2100" translate="yes" xml:space="preserve">
          <source>As of Qt 6.0 there are no vendor-specific rendering paths implemented.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="258ee3be661e079ac38d15108e2b158f8cdd6f23" translate="yes" xml:space="preserve">
          <source>As of Qt 6.0, keyboard, mouse, and touch input is not passed to the 2D items, so they will be non-interactive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21a4840bd4bdd335e24c48ff02f3fceae88389bc" translate="yes" xml:space="preserve">
          <source>As of Qt 6.0, this flag is not used in practice and is ignored. Native graphics resource ownership is not transferable to the wrapping &lt;a href=&quot;qsgtexture&quot;&gt;QSGTexture&lt;/a&gt;, because Qt Quick may not have the necessary details on how such an object and the associated memory should be freed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fa56734bef7df212a0bdc27bc322ad97adbbe64" translate="yes" xml:space="preserve">
          <source>As of Qt 6.0, this value is ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ed4c1930acaac4e3df87a5ab8afbf50bdaf9cb1" translate="yes" xml:space="preserve">
          <source>As of this writing, there were no cases where combining the two was required.</source>
          <target state="translated">이 글을 쓰는 시점에서 두 가지를 결합 해야하는 경우는 없었습니다.</target>
        </trans-unit>
        <trans-unit id="3786b6dd28873c479134bc216612e0662dfa6008" translate="yes" xml:space="preserve">
          <source>As our solutions were being adopted into new environments, we saw an escalating need for easier integration with a wider range of enterprise applications.</source>
          <target state="translated">우리의 솔루션이 새로운 환경에 도입되면서 우리는보다 광범위한 엔터프라이즈 응용 프로그램과 쉽게 통합 할 필요성이 커졌습니다.</target>
        </trans-unit>
        <trans-unit id="a8c88dd2657894e3cd5fa0851c5cfd125995ca56" translate="yes" xml:space="preserve">
          <source>As particle systems benefit from stochastic control of parameters across a large number of instances, several stochastic helper types are used by the particle system. If you do not wish to have any stochastic variation in these parameters, then do not specify any variation in these types.</source>
          <target state="translated">파티클 시스템은 다수의 인스턴스에서 매개 변수의 확률 론적 제어로부터 이익을 얻으므로, 몇 가지 확률 론적 헬퍼 유형이 파티클 시스템에 의해 사용됩니다. 이러한 매개 변수에서 확률 변동을 원하지 않으면 이러한 유형의 변동을 지정하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="f3b747f45b9296b376c5e37ea21686eb86582d9b" translate="yes" xml:space="preserve">
          <source>As per CAN bus specification, frames of type &lt;a href=&quot;qcanbusframe#FrameType-enum&quot;&gt;remote transfer request (RTR)&lt;/a&gt; do not have a payload, but a length from 0 to 8 (including). This length indicates the expected response payload length from the remote party. Therefore when sending a RTR frame using this function it may still be required to set an arbitrary payload on</source>
          <target state="translated">CAN 버스 사양에 &lt;a href=&quot;qcanbusframe#FrameType-enum&quot;&gt;따라 RTR (원격 전송 요청)&lt;/a&gt; 유형의 프레임 에는 페이로드가 없지만 길이는 0에서 8까지입니다 (포함). 이 길이는 원격 당사자로부터 예상되는 응답 페이로드 길이를 나타냅니다. 따라서이 기능을 사용하여 RTR 프레임을 전송할 때 여전히 임의의 페이로드를 설정해야 할 수도 있습니다</target>
        </trans-unit>
        <trans-unit id="6de6833e69d2bc54ca2bc3632a87ad479c1873cb" translate="yes" xml:space="preserve">
          <source>As previously noted, there are two kinds of values which may be assigned to a property:</source>
          <target state="translated">앞에서 언급했듯이 속성에 할당 할 수있는 두 가지 종류의 값이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f9b6bc239bbcf05a411e51d559f8f7bcd0d149c" translate="yes" xml:space="preserve">
          <source>As seen in the above example, properties is specified as a comma-separated string of property names to animate.</source>
          <target state="translated">위의 예에서 볼 수 있듯이 속성은 애니메이션을 적용 할 속성 이름으로 쉼표로 구분 된 문자열로 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="20d539d8441b5daed332c17747f7a25305dbd2cf" translate="yes" xml:space="preserve">
          <source>As shown above, &lt;a href=&quot;qml-qtquick-controls2-swipeview&quot;&gt;SwipeView&lt;/a&gt; is typically populated with a static set of pages that are defined inline as children of the view. It is also possible to &lt;a href=&quot;qml-qtquick-controls2-container#addItem-method&quot;&gt;add&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-controls2-container#insertItem-method&quot;&gt;insert&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-controls2-container#moveItem-method&quot;&gt;move&lt;/a&gt;, and &lt;a href=&quot;https://doc.qt.io/qt-5.13/qml-qtquick-controls2-container-obsolete.html#removeItem-method&quot;&gt;remove&lt;/a&gt; pages dynamically at run time.</source>
          <target state="translated">위에서 볼 수 있듯이 &lt;a href=&quot;qml-qtquick-controls2-swipeview&quot;&gt;SwipeView&lt;/a&gt; 는 일반적으로보기의 자식으로 인라인으로 정의 된 정적 페이지 세트로 채워집니다. 런타임에 페이지를 동적으로 &lt;a href=&quot;qml-qtquick-controls2-container#addItem-method&quot;&gt;추가&lt;/a&gt; , &lt;a href=&quot;qml-qtquick-controls2-container#insertItem-method&quot;&gt;삽입&lt;/a&gt; , &lt;a href=&quot;qml-qtquick-controls2-container#moveItem-method&quot;&gt;이동&lt;/a&gt; 및 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qml-qtquick-controls2-container-obsolete.html#removeItem-method&quot;&gt;제거 &lt;/a&gt;할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b5daa3387b834f4bd43ffeabf61a8d98e713210b" translate="yes" xml:space="preserve">
          <source>As shown above, &lt;a href=&quot;qtquickcontrols2-navigation#tabbar&quot;&gt;TabBar&lt;/a&gt; is typically populated with a static set of tab buttons that are defined inline as children of the tab bar. It is also possible to &lt;a href=&quot;qml-qtquick-controls2-container#addItem-method&quot;&gt;add&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-controls2-container#insertItem-method&quot;&gt;insert&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-controls2-container#moveItem-method&quot;&gt;move&lt;/a&gt;, and &lt;a href=&quot;https://doc.qt.io/qt-5.13/qml-qtquick-controls2-container-obsolete.html#removeItem-method&quot;&gt;remove&lt;/a&gt; items dynamically at run time. The items can be accessed using &lt;a href=&quot;qml-qtquick-controls2-container#itemAt-method&quot;&gt;itemAt()&lt;/a&gt; or &lt;a href=&quot;qml-qtquick-controls2-container#contentChildren-prop&quot;&gt;contentChildren&lt;/a&gt;.</source>
          <target state="translated">위에 표시된 것처럼 &lt;a href=&quot;qtquickcontrols2-navigation#tabbar&quot;&gt;TabBar&lt;/a&gt; 에는 일반적으로 탭 막대의 자식으로 인라인으로 정의 된 정적 탭 단추 세트가 채워집니다. 할 수도 있습니다 &lt;a href=&quot;qml-qtquick-controls2-container#addItem-method&quot;&gt;추가&lt;/a&gt; , &lt;a href=&quot;qml-qtquick-controls2-container#insertItem-method&quot;&gt;삽입&lt;/a&gt; , &lt;a href=&quot;qml-qtquick-controls2-container#moveItem-method&quot;&gt;이동&lt;/a&gt; 및 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qml-qtquick-controls2-container-obsolete.html#removeItem-method&quot;&gt;제거&lt;/a&gt; 런타임에 동적으로 항목을. &lt;a href=&quot;qml-qtquick-controls2-container#itemAt-method&quot;&gt;itemAt ()&lt;/a&gt; 또는 &lt;a href=&quot;qml-qtquick-controls2-container#contentChildren-prop&quot;&gt;contentChildren을&lt;/a&gt; 사용하여 항목에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6be2028fc8f1c13dd22d7fba6fa40d9781f9d8e4" translate="yes" xml:space="preserve">
          <source>As shown above, QDoc generates a notification when a class is declared reentrant, and lists the exceptions (the declared nonreentrant functions). A link to the general documentation on &lt;a href=&quot;#reentrant&quot;&gt;reentrancy and thread-safety&lt;/a&gt; is included. In addition a warning, &quot;&lt;b&gt;Warning&lt;/b&gt;: This function is not reentrant.&quot;, is generated in the nonreentrant functions' documentation.</source>
          <target state="translated">위에 표시된 것처럼 QDoc은 클래스가 재진입으로 선언 될 때 알림을 생성하고 예외 (선언 된 비 재진입 함수)를 나열합니다. &lt;a href=&quot;#reentrant&quot;&gt;재진입 및 스레드 안전성&lt;/a&gt; 에 대한 일반 문서 링크 가 포함되어 있습니다. 또한 &quot; &lt;b&gt;경고&lt;/b&gt; :이 기능은 재진입 할 ​​수 없습니다.&quot; 라는 &lt;b&gt;경고&lt;/b&gt; 가 재진입 할 ​​수없는 기능 설명서에 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="7249f680fc27ca21b46b243d8861f64dd97a7356" translate="yes" xml:space="preserve">
          <source>As shown above, QDoc generates a notification when a class is declared reentrant, and lists the exceptions (the declared nonreentrant functions). A link to the general documentation on &lt;a href=&quot;17-qdoc-commands-thread#reentrant&quot;&gt;reentrancy and thread-safety&lt;/a&gt; is included. In addition a warning, &quot;&lt;b&gt;Warning&lt;/b&gt;: This function is not reentrant.&quot;, is generated in the nonreentrant functions' documentation.</source>
          <target state="translated">위와 같이 QDoc은 클래스가 재진입으로 선언 될 때 알림을 생성하고 예외 (선언 된 재진입이 아닌 함수)를 나열합니다. &lt;a href=&quot;17-qdoc-commands-thread#reentrant&quot;&gt;재진입 및 스레드 안전성&lt;/a&gt; 에 대한 일반 문서에 대한 링크 가 포함되어 있습니다. 또한 재진입이 아닌 함수의 문서에 &quot; &lt;b&gt;경고&lt;/b&gt; :이 기능은 재진입이 아닙니다.&quot; 라는 &lt;b&gt;경고&lt;/b&gt; 가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="ed7886e92ecc9b719c77ef6df23e37a3502e37fa" translate="yes" xml:space="preserve">
          <source>As shown above, SwipeView is typically populated with a static set of pages that are defined inline as children of the view. It is also possible to &lt;a href=&quot;qml-qtquick-controls2-container#addItem-method&quot;&gt;add&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-controls2-container#insertItem-method&quot;&gt;insert&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-controls2-container#moveItem-method&quot;&gt;move&lt;/a&gt;, and &lt;a href=&quot;https://doc.qt.io/qt-5.15/qml-qtquick-controls2-container-obsolete.html#removeItem-method&quot;&gt;remove&lt;/a&gt; pages dynamically at run time.</source>
          <target state="translated">위에 표시된대로 SwipeView는 일반적으로보기의 하위 항목으로 인라인으로 정의 된 정적 페이지 집합으로 채워집니다. 또한 런타임에 동적으로 페이지 를 &lt;a href=&quot;qml-qtquick-controls2-container#addItem-method&quot;&gt;추가&lt;/a&gt; , &lt;a href=&quot;qml-qtquick-controls2-container#insertItem-method&quot;&gt;삽입&lt;/a&gt; , &lt;a href=&quot;qml-qtquick-controls2-container#moveItem-method&quot;&gt;이동&lt;/a&gt; 및 &lt;a href=&quot;https://doc.qt.io/qt-5.15/qml-qtquick-controls2-container-obsolete.html#removeItem-method&quot;&gt;제거&lt;/a&gt; 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ab1a68db213fceb6d8bf8e905b7f019292e13b93" translate="yes" xml:space="preserve">
          <source>As shown above, SwipeView is typically populated with a static set of pages that are defined inline as children of the view. It is also possible to &lt;a href=&quot;qml-qtquick-controls2-container#addItem-method&quot;&gt;add&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-controls2-container#insertItem-method&quot;&gt;insert&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-controls2-container#moveItem-method&quot;&gt;move&lt;/a&gt;, and &lt;a href=&quot;qml-qtquick-controls2-container#removeItem-method&quot;&gt;remove&lt;/a&gt; pages dynamically at run time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a2e25376fc939e171e52630ba26ceb7cb0f7ea5" translate="yes" xml:space="preserve">
          <source>As shown above, TabBar is typically populated with a static set of tab buttons that are defined inline as children of the tab bar. It is also possible to &lt;a href=&quot;qml-qtquick-controls2-container#addItem-method&quot;&gt;add&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-controls2-container#insertItem-method&quot;&gt;insert&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-controls2-container#moveItem-method&quot;&gt;move&lt;/a&gt;, and &lt;a href=&quot;https://doc.qt.io/qt-5.15/qml-qtquick-controls2-container-obsolete.html#removeItem-method&quot;&gt;remove&lt;/a&gt; items dynamically at run time. The items can be accessed using &lt;a href=&quot;qml-qtquick-controls2-container#itemAt-method&quot;&gt;itemAt()&lt;/a&gt; or &lt;a href=&quot;qml-qtquick-controls2-container#contentChildren-prop&quot;&gt;contentChildren&lt;/a&gt;.</source>
          <target state="translated">위에 표시된대로 TabBar는 일반적으로 탭 표시 줄의 자식으로 인라인으로 정의 된 정적 탭 단추 집합으로 채워집니다. 런타임에 동적으로 항목 을 &lt;a href=&quot;qml-qtquick-controls2-container#addItem-method&quot;&gt;추가&lt;/a&gt; , &lt;a href=&quot;qml-qtquick-controls2-container#insertItem-method&quot;&gt;삽입&lt;/a&gt; , &lt;a href=&quot;qml-qtquick-controls2-container#moveItem-method&quot;&gt;이동&lt;/a&gt; 및 &lt;a href=&quot;https://doc.qt.io/qt-5.15/qml-qtquick-controls2-container-obsolete.html#removeItem-method&quot;&gt;제거 할 수도&lt;/a&gt; 있습니다. &lt;a href=&quot;qml-qtquick-controls2-container#itemAt-method&quot;&gt;itemAt ()&lt;/a&gt; 또는 &lt;a href=&quot;qml-qtquick-controls2-container#contentChildren-prop&quot;&gt;contentChildren을&lt;/a&gt; 사용하여 항목에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="65dad8af3190f937c6565fbc3ef0a28ed41f7a94" translate="yes" xml:space="preserve">
          <source>As shown above, TabBar is typically populated with a static set of tab buttons that are defined inline as children of the tab bar. It is also possible to &lt;a href=&quot;qml-qtquick-controls2-container#addItem-method&quot;&gt;add&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-controls2-container#insertItem-method&quot;&gt;insert&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-controls2-container#moveItem-method&quot;&gt;move&lt;/a&gt;, and &lt;a href=&quot;qml-qtquick-controls2-container#removeItem-method&quot;&gt;remove&lt;/a&gt; items dynamically at run time. The items can be accessed using &lt;a href=&quot;qml-qtquick-controls2-container#itemAt-method&quot;&gt;itemAt()&lt;/a&gt; or &lt;a href=&quot;qml-qtquick-controls2-container#contentChildren-prop&quot;&gt;contentChildren&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7261fb07fb087264244429dac377b9680163ffec" translate="yes" xml:space="preserve">
          <source>As shown above, enumeration types (e.g. &lt;code&gt;TextType&lt;/code&gt;) and values (e.g. &lt;code&gt;Normal&lt;/code&gt;) must begin with an uppercase letter.</source>
          <target state="translated">위에 표시된 것처럼 열거 유형 (예 : &lt;code&gt;TextType&lt;/code&gt; ) 및 값 (예 : &lt;code&gt;Normal&lt;/code&gt; )은 대문자로 시작해야합니다.</target>
        </trans-unit>
        <trans-unit id="e71eeda01f4c477f0b6b57cdf1676f186ab39884" translate="yes" xml:space="preserve">
          <source>As shown here, the end result with an empty MAIN() is exactly the same as before.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7dd921467245a37c355363aea34246456ddfa94" translate="yes" xml:space="preserve">
          <source>As soon as possible. This value was added in Qt 5.6.</source>
          <target state="translated">최대한 빨리. 이 값은 Qt 5.6에서 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="0d3f2e8517421aa15632d4e927c6a0e1bc56aa6b" translate="yes" xml:space="preserve">
          <source>As special cases, the &lt;a href=&quot;qcache&quot;&gt;QCache&lt;/a&gt; and &lt;a href=&quot;qcontiguouscache&quot;&gt;QContiguousCache&lt;/a&gt; classes provide efficient hash-lookup of objects in a limited cache storage.</source>
          <target state="translated">특별한 경우, &lt;a href=&quot;qcache&quot;&gt;QCache&lt;/a&gt; 및 &lt;a href=&quot;qcontiguouscache&quot;&gt;QContiguousCache&lt;/a&gt; 클래스는 제한된 캐시 스토리지에서 오브젝트의 효율적인 해시 조회를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="ef567737800bf5672dae577f1fd2091ed2fcc1fe" translate="yes" xml:space="preserve">
          <source>As stated above, an action group is &lt;a href=&quot;qactiongroup#exclusive-prop&quot;&gt;exclusive&lt;/a&gt; by default; it ensures that only one checkable action is active at any one time. If you want to group checkable actions without making them exclusive, you can turn of exclusiveness by calling &lt;a href=&quot;qactiongroup#exclusive-prop&quot;&gt;setExclusive&lt;/a&gt;(false).</source>
          <target state="translated">위에서 언급했듯이 작업 그룹은 기본적으로 &lt;a href=&quot;qactiongroup#exclusive-prop&quot;&gt;배타적입니다&lt;/a&gt; . 한 번에 하나의 확인 가능한 작업 만 활성화되도록합니다. 검사 가능한 동작을 배타적이지 &lt;a href=&quot;qactiongroup#exclusive-prop&quot;&gt;않게 그룹화하려면 setExclusive&lt;/a&gt; (false)를 호출하여 배타성을 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="eaef981adafeed79c00f3d07110deba7dcd03c66" translate="yes" xml:space="preserve">
          <source>As stated above, an action group is exclusive by default; it ensures that at most only one checkable action is active at any one time. If you want to group checkable actions without making them exclusive, you can turn off exclusiveness by calling &lt;a href=&quot;qactiongroup#setExclusive&quot;&gt;setExclusive&lt;/a&gt;(false).</source>
          <target state="translated">위에서 언급했듯이 작업 그룹은 기본적으로 배타적입니다. 한 번에 최대 하나의 확인 가능한 작업 만 활성화되도록합니다. 검사 가능한 작업을 배타적으로 만들지 않고 그룹화하려면 &lt;a href=&quot;qactiongroup#setExclusive&quot;&gt;setExclusive&lt;/a&gt; (false)를 호출하여 배타성을 끌 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="45a765d5c611c1243bc18a28faa9d3f32e1ce316" translate="yes" xml:space="preserve">
          <source>As stated in the beginning, understanding the finer details of the renderer is not required to get good performance. It is written to optimize for common use cases and will perform quite well under almost any circumstances.</source>
          <target state="translated">처음에 언급 한 바와 같이, 렌더러의 미세한 세부 사항을 이해하는 것이 좋은 성능을 얻는 데 필요하지 않습니다. 일반적인 사용 사례에 맞게 작성되었으며 거의 ​​모든 상황에서 잘 작동합니다.</target>
        </trans-unit>
        <trans-unit id="42d941de4b7fd67188f4223a4a5ebe304ab68022" translate="yes" xml:space="preserve">
          <source>As stated, the various &lt;a href=&quot;qml-qtquick-viewtransition&quot;&gt;ViewTransition&lt;/a&gt; properties provide details specific to the individual item being transitioned as well as the operation that triggered the transition. In the animation above, five items are inserted in succession at index 0. When the fifth and final insertion takes place, adding &quot;Item 4&quot; to the view, the &lt;code&gt;add&lt;/code&gt; transition is run once (for the inserted item) and the &lt;code&gt;displaced&lt;/code&gt; transition is run four times (once for each of the four existing items in the view).</source>
          <target state="translated">언급 한대로 다양한 &lt;a href=&quot;qml-qtquick-viewtransition&quot;&gt;ViewTransition&lt;/a&gt; 속성은 전환중인 개별 항목과 전환을 트리거 한 작업에 대한 세부 정보를 제공합니다. 위의 애니메이션에서 5 개의 항목이 인덱스 0에 연속으로 삽입됩니다. 다섯 번째 및 마지막 삽입이 발생하고 &quot;항목 4&quot;를 뷰에 &lt;code&gt;add&lt;/code&gt; 하면 추가 전환이 한 번 실행되고 (삽입 된 항목에 대해) &lt;code&gt;displaced&lt;/code&gt; 전환이 수행됩니다. 4 번 실행합니다 (보기에있는 4 개의 기존 항목 각각에 대해 한 번씩).</target>
        </trans-unit>
        <trans-unit id="53036297337fde603e8ee4a7974232f6cd5d8fe0" translate="yes" xml:space="preserve">
          <source>As stated, the various ViewTransition properties provide details specific to the individual item being transitioned as well as the operation that triggered the transition. In the animation above, five items are inserted in succession at index 0. When the fifth and final insertion takes place, adding &quot;Item 4&quot; to the view, the &lt;code&gt;add&lt;/code&gt; transition is run once (for the inserted item) and the &lt;code&gt;displaced&lt;/code&gt; transition is run four times (once for each of the four existing items in the view).</source>
          <target state="translated">언급했듯이 다양한 ViewTransition 속성은 전환되는 개별 항목과 전환을 트리거 한 작업에 대한 세부 정보를 제공합니다. 위의 애니메이션에서 5 개의 항목이 인덱스 0에 연속적으로 삽입됩니다. 다섯 번째 및 마지막 삽입이 발생하면 뷰에 &quot;항목 4&quot;를 &lt;code&gt;add&lt;/code&gt; 하면 추가 전환이 한 번 실행되고 (삽입 된 항목에 대해) &lt;code&gt;displaced&lt;/code&gt; 전환은 다음과 같습니다. 4 번 실행합니다 (보기에있는 4 개의 기존 항목 각각에 대해 한 번씩).</target>
        </trans-unit>
        <trans-unit id="14dfb6580dcb33dd351b0c723fa35b4ef316f01b" translate="yes" xml:space="preserve">
          <source>As the &lt;a href=&quot;qml-qtquick-particles-particlepainter&quot;&gt;ParticlePainter&lt;/a&gt; is the QML type visualizing the particles in the scene, it is its Z value which is important when trying to place particles above or below other types visually.</source>
          <target state="translated">애즈 &lt;a href=&quot;qml-qtquick-particles-particlepainter&quot;&gt;ParticlePainter는&lt;/a&gt; 장면에서 입자를 시각화 QML 형이고, 그 위의 시각적 또는 다른 유형의 아래 위치 입자 할 때 중요하다의 Z 값이다.</target>
        </trans-unit>
        <trans-unit id="704669c2da7ddbb1fea7f9a57a96b64eb4b1fa4e" translate="yes" xml:space="preserve">
          <source>As the &lt;code&gt;Foo&lt;/code&gt; type is instantiated in QML, it must be registered with the version of &lt;a href=&quot;https://doc.qt.io/qt-5.15/qqmlengine-obsolete.html#qmlRegisterType-1&quot;&gt;qmlRegisterType&lt;/a&gt;() that takes an element name.</source>
          <target state="translated">애즈 &lt;code&gt;Foo&lt;/code&gt; 유형 QML 인스턴스화되며, 이는 버전 등록해야 &lt;a href=&quot;https://doc.qt.io/qt-5.15/qqmlengine-obsolete.html#qmlRegisterType-1&quot;&gt;qmlRegisterType&lt;/a&gt; 요소 이름을 얻어 ().</target>
        </trans-unit>
        <trans-unit id="8c88a1f5e9d6d0be8078752b1b31c11c809c5b7d" translate="yes" xml:space="preserve">
          <source>As the &lt;code&gt;Foo&lt;/code&gt; type is instantiated in QML, it must be registered with the version of &lt;a href=&quot;qqmlengine#qmlRegisterType&quot;&gt;qmlRegisterType&lt;/a&gt;() that takes an element name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b3d4b2e454ff43962d5206cb68716ddcd8795d8" translate="yes" xml:space="preserve">
          <source>As the &lt;code&gt;Foo&lt;/code&gt; type is instantiated in QML, it must be registered with the version of qmlRegisterType() that takes an import URI.</source>
          <target state="translated">는 AS &lt;code&gt;Foo&lt;/code&gt; 유형이 QML에서 인스턴스화, 그것은 가져 오기 URI 소요 qmlRegisterType (버전)에 등록해야합니다.</target>
        </trans-unit>
        <trans-unit id="30f68cca73e134d1819df7cc9068098e769b59db" translate="yes" xml:space="preserve">
          <source>As the Java style tabs don't overlap, we also present an image of a tab widget in the common style. Note that if you want the tabs to overlap horizontally, you do that when drawing the tabs in &lt;code&gt;CE_TabBarTabShape&lt;/code&gt;; the tabs bounding rectangles will not be altered by the tab bar. The tabs are drawn from left to right in a north tab bar shape, top to bottom in an east tab bar shape, etc. The selected tab is drawn last, so that it is easy to draw it over the other tabs (if it is to be bigger).</source>
          <target state="translated">Java 스타일 탭이 겹치지 않으므로 일반적인 스타일의 탭 위젯 이미지도 제공합니다. 탭을 가로로 겹치려면 &lt;code&gt;CE_TabBarTabShape&lt;/code&gt; 에서 탭을 그릴 때 탭을 겹치게하십시오 . 사각형을 묶는 탭은 탭 표시 줄에 의해 변경되지 않습니다. 탭은 북쪽 탭 막대 모양으로 왼쪽에서 오른쪽으로, 동쪽 탭 막대 모양으로 위에서 아래로 그려집니다. 선택한 탭은 마지막에 그려 지므로 다른 탭 위에 쉽게 그릴 수 있습니다. 더 커야 함).</target>
        </trans-unit>
        <trans-unit id="35d9f09a7455495172aaa1e3fea6f31ddc7c4223" translate="yes" xml:space="preserve">
          <source>As the OpenGL documentation explains; The alpha test discards a fragment conditional on the outcome of a comparison between the incoming fragment's alpha value and a constant reference value.</source>
          <target state="translated">OpenGL 문서가 설명 하듯이; 알파 테스트는 들어오는 조각의 알파 값과 상수 참조 값 사이의 비교 결과에 따라 조건부 조각을 버립니다.</target>
        </trans-unit>
        <trans-unit id="36e4cf675bc1a6be48722226b43f207daba83efa" translate="yes" xml:space="preserve">
          <source>As the SAX2 standard suggests, &lt;a href=&quot;qxmlsimplereader&quot;&gt;QXmlSimpleReader&lt;/a&gt; defaults to having</source>
          <target state="translated">SAX2 표준에서 알 수 있듯이 &lt;a href=&quot;qxmlsimplereader&quot;&gt;QXmlSimpleReader는&lt;/a&gt; 기본적으로</target>
        </trans-unit>
        <trans-unit id="607635cad4dbb481b90ce5525b8a28c88f732a77" translate="yes" xml:space="preserve">
          <source>As the area of a &lt;a href=&quot;qml-qtquick-particles-trailemitter&quot;&gt;TrailEmitter&lt;/a&gt; is the area it follows, a separate shape can be provided to be the shape it emits out of. This shape has width and height specified by &lt;a href=&quot;qml-qtquick-particles-trailemitter#emitWidth-prop&quot;&gt;emitWidth&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-particles-trailemitter#emitHeight-prop&quot;&gt;emitHeight&lt;/a&gt;, and is centered on the followed particle's position.</source>
          <target state="translated">(A)의 영역으로서 &lt;a href=&quot;qml-qtquick-particles-trailemitter&quot;&gt;TrailEmitter는&lt;/a&gt; 그 다음 영역이며, 별도의 형상은 밖으로 방출 형태로 제공 될 수있다. 이 모양은 &lt;a href=&quot;qml-qtquick-particles-trailemitter#emitWidth-prop&quot;&gt;emitWidth&lt;/a&gt; 및 &lt;a href=&quot;qml-qtquick-particles-trailemitter#emitHeight-prop&quot;&gt;emitHeight로&lt;/a&gt; 지정된 폭과 높이를 가지며 그 뒤에 오는 입자의 위치를 ​​중심으로합니다.</target>
        </trans-unit>
        <trans-unit id="c043aa7614cb21ecfaefa2b6117c76eed6fc3dbf" translate="yes" xml:space="preserve">
          <source>As the code snippet above illustrates, you can use this function to avoid emitting a signal that nobody listens to.</source>
          <target state="translated">위의 코드 스 니펫에서 알 수 있듯이이 기능을 사용하면 아무도 듣지 않는 신호를 방출하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3809eb24ca5564266c680c6a21b1c9ad885b5109" translate="yes" xml:space="preserve">
          <source>As the example shows, unlike JSON, CBOR requires no escaping for binary content.</source>
          <target state="translated">예제에서 볼 수 있듯이 JSON과 달리 CBOR은 이진 콘텐츠를 이스케이프 처리 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="ef78968fcd60e74d674f69748efeb24d26ed482b" translate="yes" xml:space="preserve">
          <source>As the expansion is performed after reading in all variables, the order in which they are defined does not matter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d1c6cd29ec3676cd908e2cfa5e493b62ef75677" translate="yes" xml:space="preserve">
          <source>As the expression will not have an associated &lt;a href=&quot;qqmlcontext&quot;&gt;QQmlContext&lt;/a&gt;, this will be a null expression object and its value will always be an invalid &lt;a href=&quot;qtcore-changes-qt6#qvariant&quot;&gt;QVariant&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d9a6743d3c664049f394847711891bd457d293b" translate="yes" xml:space="preserve">
          <source>As the expression will not have an associated &lt;a href=&quot;qqmlcontext&quot;&gt;QQmlContext&lt;/a&gt;, this will be a null expression object and its value will always be an invalid &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt;.</source>
          <target state="translated">표현식에 연관된 &lt;a href=&quot;qqmlcontext&quot;&gt;QQmlContext&lt;/a&gt; 가 없으므로 이는 널 표현식 오브젝트이며 해당 값은 항상 유효하지 않은 &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="142fe1bdd9e1c8ee90637fe482874b9ceefa8f87" translate="yes" xml:space="preserve">
          <source>As the fillWidth item will automatically be resized to fit the extra space, explicit assignments to its width and height properties will be ignored (but &lt;a href=&quot;qml-qtquick-layouts-layout#minimumWidth-attached-prop&quot;&gt;Layout.minimumWidth&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-layouts-layout#maximumWidth-attached-prop&quot;&gt;Layout.maximumWidth&lt;/a&gt; will still be respected). The initial sizes of other items should be set via their width and height properties. Any binding assignment to an item's width or height will be broken as soon as the user drags that item's splitter handle.</source>
          <target state="translated">fillWidth 항목은 추가 공간에 맞게 자동으로 크기가 조정되므로 너비 및 높이 속성에 대한 명시 적 할당은 무시됩니다 (그러나 &lt;a href=&quot;qml-qtquick-layouts-layout#minimumWidth-attached-prop&quot;&gt;Layout.minimumWidth&lt;/a&gt; 및 &lt;a href=&quot;qml-qtquick-layouts-layout#maximumWidth-attached-prop&quot;&gt;Layout.maximumWidth&lt;/a&gt; 는 계속 적용됨 ). 다른 항목의 초기 크기는 너비 및 높이 속성을 통해 설정해야합니다. 사용자가 해당 항목의 스플리터 핸들을 드래그하면 항목의 너비 또는 높이에 대한 바인딩 할당이 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="5aedbe5ab8412a1b9878a1ce22eacc2975f964de" translate="yes" xml:space="preserve">
          <source>As the generic iterators don't actually instantiate a &lt;a href=&quot;qtcore-changes-qt6#qvariant&quot;&gt;QVariant&lt;/a&gt; on each step, they cannot return a reference to one from operator*(). QVariantRef provides the same functionality as an actual reference to a &lt;a href=&quot;qtcore-changes-qt6#qvariant&quot;&gt;QVariant&lt;/a&gt; would, but is backed by a pointer given as template parameter. The template is implemented for pointers of type QSequentialIterator and QAssociativeIterator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db39dc0ad46b7c7ac02fc7af54f97046e0220df1" translate="yes" xml:space="preserve">
          <source>As the life time of &lt;a href=&quot;qmediaplayer&quot;&gt;QMediaPlayer&lt;/a&gt; can be longer than the playback of one &lt;a href=&quot;qmediacontent&quot;&gt;QMediaContent&lt;/a&gt;, this property may change over time, the &lt;a href=&quot;qmediaplayer#audioAvailableChanged&quot;&gt;audioAvailableChanged&lt;/a&gt; signal can be used to monitor it's status.</source>
          <target state="translated">&lt;a href=&quot;qmediaplayer&quot;&gt;QMediaPlayer&lt;/a&gt; 의 수명 이 하나의 &lt;a href=&quot;qmediacontent&quot;&gt;QMediaContent&lt;/a&gt; 재생보다 길 수 있으므로이 속성은 시간이 지남에 따라 변경 될 수 있으며 &lt;a href=&quot;qmediaplayer#audioAvailableChanged&quot;&gt;audioAvailableChanged&lt;/a&gt; 신호를 사용하여 상태를 모니터링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="21836ee22337af62029dd3c7fc36cf40bfca7483" translate="yes" xml:space="preserve">
          <source>As the module is header-only, no further modifications to the .pro files are required to use it.</source>
          <target state="translated">모듈은 헤더 전용이므로 .pro 파일을 더 이상 수정하지 않아도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e099999d6d28eb183765a2684958f47aab736ab" translate="yes" xml:space="preserve">
          <source>As the name implies, &lt;a href=&quot;qml-qt3d-render-sceneloader&quot;&gt;SceneLoader&lt;/a&gt; loads a complete scene subtree. If you wish to load a single piece of geometry, you should rather use the Mesh instead.</source>
          <target state="translated">이름에서 알 수 있듯이 &lt;a href=&quot;qml-qt3d-render-sceneloader&quot;&gt;SceneLoader&lt;/a&gt; 는 완전한 장면 하위 트리를로드합니다. 단일 지오메트리를로드하려면 대신 메시를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="7136d0733258a47b05cdde9d590939f4f8410393" translate="yes" xml:space="preserve">
          <source>As the name implies, &lt;a href=&quot;qt3drender-qsceneloader&quot;&gt;Qt3DRender::QSceneLoader&lt;/a&gt; loads a complete scene subtree. If you wish to load a single piece of geometry, you should rather use the &lt;a href=&quot;qt3drender-qmesh&quot;&gt;Qt3DRender::QMesh&lt;/a&gt; instead.</source>
          <target state="translated">이름에서 알 수 있듯이 &lt;a href=&quot;qt3drender-qsceneloader&quot;&gt;Qt3DRender :: QSceneLoader&lt;/a&gt; 는 완전한 장면 하위 트리를로드합니다. 단일 지오메트리 조각을로드 &lt;a href=&quot;qt3drender-qmesh&quot;&gt;하려면&lt;/a&gt; 대신 Qt3DRender :: QMesh를 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="ba3d7561ccd2bc0b4dae02e3c9b434aaf98d3f1e" translate="yes" xml:space="preserve">
          <source>As the name implies, SceneLoader loads a complete scene subtree. If you wish to load a single piece of geometry, you should rather use the Mesh instead.</source>
          <target state="translated">이름에서 알 수 있듯이 SceneLoader는 전체 장면 하위 트리를로드합니다. 단일 지오메트리 조각을로드하려면 대신 메시를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="8fae417b8e6e7c6c79a79ad589e798e8d93ab936" translate="yes" xml:space="preserve">
          <source>As the name implies, single execution mode uses a single QDoc process to generate all the Qt5 documentation. The single QDoc process still performs a</source>
          <target state="translated">이름에서 알 수 있듯이 단일 실행 모드는 단일 QDoc 프로세스를 사용하여 모든 Qt5 문서를 생성합니다. 단일 QDoc 프로세스는 여전히</target>
        </trans-unit>
        <trans-unit id="9d9dfd95773720c8ec58b4ded4245d5e56e31b8e" translate="yes" xml:space="preserve">
          <source>As the name suggests, required properties must be set when an instance of the object is created. Violation of this rule will result in QML applications not starting if it can be detected statically. In case of dynamically instantiated QML components (for instance via &lt;a href=&quot;qml-qtqml-qt#createComponent-method&quot;&gt;Qt.createComponent()&lt;/a&gt;), violating this rule results in a warning and a null return value.</source>
          <target state="translated">이름에서 알 수 있듯이 개체의 인스턴스를 만들 때 필요한 속성을 설정해야합니다. 이 규칙을 위반하면 QML 애플리케이션이 정적으로 감지 될 수있는 경우 시작되지 않습니다. 동적으로 인스턴스화 된 QML 구성 요소의 경우 (예 : &lt;a href=&quot;qml-qtqml-qt#createComponent-method&quot;&gt;Qt.createComponent ()&lt;/a&gt; 를 통해 )이 규칙을 위반하면 경고 및 null 반환 값이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d431a06e5d5c018cf83e72cb0f2a95d25a6d6902" translate="yes" xml:space="preserve">
          <source>As the names suggest, many of these map to similarly named &lt;a href=&quot;qml-qtquick3d-principledmaterial&quot;&gt;PrincipledMaterial&lt;/a&gt; properties, with the same meaning and semantics, following the &lt;a href=&quot;https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material&quot;&gt;metallic-roughness material model&lt;/a&gt;. It is up the custom material implementation to decide how these values are calculated: for example, a value for &lt;a href=&quot;qml-qtquick3d-principledmaterial#base-color&quot;&gt;BASE_COLOR&lt;/a&gt; can be hard coded in the shader, can be based on sampling a texture, or can be calculated based on QML properties exposed as uniforms or on interpolated data passed along from the vertex shader.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9dca82c4bbf323214060e920f4ec5a34ceff2154" translate="yes" xml:space="preserve">
          <source>As the point of view changes, the &lt;a href=&quot;qml-qt3d-render-levelofdetail#currentIndex-prop&quot;&gt;currentIndex&lt;/a&gt; property will change to reflect matching value in the range array.</source>
          <target state="translated">관점이 변경되면 &lt;a href=&quot;qml-qt3d-render-levelofdetail#currentIndex-prop&quot;&gt;currentIndex&lt;/a&gt; 속성이 범위 배열의 일치하는 값을 반영하도록 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="fccae1bf1134f1e8ca70b6aed0cb2562faa3bb73" translate="yes" xml:space="preserve">
          <source>As the point of view changes, the &lt;a href=&quot;qt3drender-qlevelofdetail#currentIndex-prop&quot;&gt;currentIndex&lt;/a&gt; property will change to reflect matching value in the range array.</source>
          <target state="translated">관점이 변경되면 &lt;a href=&quot;qt3drender-qlevelofdetail#currentIndex-prop&quot;&gt;currentIndex&lt;/a&gt; 속성이 범위 배열의 일치하는 값을 반영하도록 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="c6d138431e812197c3658b0f3420951b3faf7cae" translate="yes" xml:space="preserve">
          <source>As the previous example shows, exposing a texture to the vertex, fragment, or both shaders is very similar to scalar and vector uniform values: a QML property with the type &lt;a href=&quot;qml-qtquick3d-textureinput&quot;&gt;TextureInput&lt;/a&gt; will automatically get associated with a &lt;code&gt;sampler2D&lt;/code&gt; in the shader code. As always, there is no need to declare this sampler in the shader code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="199bec2b4d0145e60a68eb76f60da0f139a80e22" translate="yes" xml:space="preserve">
          <source>As the properties of these frontend objects are updated, one or more backend nodes are created and placed into a scenegraph. Because rendering 3D scenes involves a lot more state than rendering 2D, there is a separate set of specialized scene graph nodes for representing the state of the 3D scene objects. This scene graph is know as the Qt Quick Spatial Scene Graph.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b102bdfcc5003101739adbaa5da053c42574dd7d" translate="yes" xml:space="preserve">
          <source>As the structure of splitters are simple and do not contain any sub elements, we do not include any images of splitters. &lt;code&gt;CE_Splitter&lt;/code&gt; does not use any other elements or metrics.</source>
          <target state="translated">스플리터의 구조는 단순하고 하위 요소를 포함하지 않으므로 스플리터 이미지는 포함하지 않습니다. &lt;code&gt;CE_Splitter&lt;/code&gt; 는 다른 요소 나 메트릭을 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="08b33c3f9f805ff5773e89011e1e3742047b77fb" translate="yes" xml:space="preserve">
          <source>As they are shared, .pragma library files cannot access QML component instance objects or properties directly, although QML values can be passed as function parameters.</source>
          <target state="translated">공유되는 .pragma 라이브러리 파일은 QML 값을 함수 매개 변수로 전달할 수 있지만 QML 컴포넌트 인스턴스 오브젝트 또는 특성에 직접 액세스 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="8a66b9840c4e1c65d580c9e732a661e7fae3671c" translate="yes" xml:space="preserve">
          <source>As this number doesn't include any formatting markup it may not be the same as the length of the string returned by the &lt;a href=&quot;qml-qtquick-textedit#text-prop&quot;&gt;text&lt;/a&gt; property.</source>
          <target state="translated">이 숫자에는 서식 태그가 포함되지 않으므로 &lt;a href=&quot;qml-qtquick-textedit#text-prop&quot;&gt;text&lt;/a&gt; 속성에서 반환하는 문자열의 길이와 같지 않을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8e79eea69d3b2cd9d5971b5f4e6a1d5ed015d15f" translate="yes" xml:space="preserve">
          <source>As this number doesn't include any formatting markup, it may not be the same as the length of the string returned by the &lt;a href=&quot;qml-qtquick-controls-textarea#text-prop&quot;&gt;text&lt;/a&gt; property.</source>
          <target state="translated">이 숫자에는 서식 태그가 포함되지 않으므로 &lt;a href=&quot;qml-qtquick-controls-textarea#text-prop&quot;&gt;text&lt;/a&gt; 속성에서 반환하는 문자열 길이와 같지 않을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e52fb5208dba817370e6574c93bcc33595747ac2" translate="yes" xml:space="preserve">
          <source>As this property only affects the &lt;code&gt;implicitWidth&lt;/code&gt; of the &lt;a href=&quot;qtquickcontrols-changes-qt6#combobox&quot;&gt;ComboBox&lt;/a&gt;, setting an explicit &lt;a href=&quot;qml-qtquick-item#width-prop&quot;&gt;width&lt;/a&gt; can still result in eliding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa583af295097756e03534ef635a42dd0b39aed0" translate="yes" xml:space="preserve">
          <source>As we have seen in the previous section, we can configure the behavior of the reader when it comes to namespace processing. This is done by setting and unsetting the</source>
          <target state="translated">이전 섹션에서 보았 듯이 네임 스페이스 처리와 관련하여 독자의 동작을 구성 할 수 있습니다. 이것은 설정 및 설정 해제로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="b471fdd9426893d17b4d9c7ddae8dfb898565d64" translate="yes" xml:space="preserve">
          <source>As well as presenting data, views handle navigation between items, and some aspects of item selection. The views also implement basic user interface features, such as context menus and drag and drop. A view can provide default editing facilities for items, or it may work with a &lt;a href=&quot;#delegate-classes&quot;&gt;delegate&lt;/a&gt; to provide a custom editor.</source>
          <target state="translated">데이터를 제공 할뿐만 아니라보기는 항목 간 탐색 및 항목 선택의 일부 측면을 처리합니다. 뷰는 또한 상황에 맞는 메뉴 및 끌어서 놓기와 같은 기본 사용자 인터페이스 기능을 구현합니다. 보기는 항목에 대한 기본 편집 기능을 제공하거나 &lt;a href=&quot;#delegate-classes&quot;&gt;대리자&lt;/a&gt; 와 함께 사용자 정의 편집기를 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fd53574b652450b445f79326a136a3859556da47" translate="yes" xml:space="preserve">
          <source>As well as presenting data, views handle navigation between items, and some aspects of item selection. The views also implement basic user interface features, such as context menus and drag and drop. A view can provide default editing facilities for items, or it may work with a &lt;a href=&quot;model-view-programming#delegate-classes&quot;&gt;delegate&lt;/a&gt; to provide a custom editor.</source>
          <target state="translated">보기는 데이터를 표시 할뿐만 아니라 항목 간 탐색 및 항목 선택의 일부 측면을 처리합니다. 보기는 컨텍스트 메뉴 및 끌어서 놓기와 같은 기본 사용자 인터페이스 기능도 구현합니다. 보기는 항목에 대한 기본 편집 기능 을 제공하거나 사용자 지정 편집기를 제공하기 위해 &lt;a href=&quot;model-view-programming#delegate-classes&quot;&gt;대리인&lt;/a&gt; 과 함께 작동 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c7f892a5ec7510a8d63c21666f702f1f96f1c02d" translate="yes" xml:space="preserve">
          <source>As with &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtquick-virtualkeyboard-qmlmodule.html&quot;&gt;all other QML types&lt;/a&gt; provided by the module, the &lt;code&gt;QT_IM_MODULE&lt;/code&gt; environment variable must be set to &lt;code&gt;qtvirtualkeyboard&lt;/code&gt; before using &lt;a href=&quot;qml-qtquick-virtualkeyboard-inputpanel&quot;&gt;InputPanel&lt;/a&gt;. For more information, see &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtvirtualkeyboard-deployment-guide.html#loading-the-plugin&quot;&gt;Loading the Plugin&lt;/a&gt;.</source>
          <target state="translated">모듈이 제공하는 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtquick-virtualkeyboard-qmlmodule.html&quot;&gt;다른 모든 QML 유형&lt;/a&gt; 과 마찬가지로 , &lt;code&gt;QT_IM_MODULE&lt;/code&gt; 환경 변수는 &lt;a href=&quot;qml-qtquick-virtualkeyboard-inputpanel&quot;&gt;InputPanel&lt;/a&gt; 을 사용하기 전에 &lt;code&gt;qtvirtualkeyboard&lt;/code&gt; 로 설정해야합니다 . 자세한 정보 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtvirtualkeyboard-deployment-guide.html#loading-the-plugin&quot;&gt;는 플러그인로드를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3272523de559043750c571d85c31ea16dc1d1f7a" translate="yes" xml:space="preserve">
          <source>As with &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtquick-virtualkeyboard-qmlmodule.html&quot;&gt;all other QML types&lt;/a&gt; provided by the module, the &lt;code&gt;QT_IM_MODULE&lt;/code&gt; environment variable must be set to &lt;code&gt;qtvirtualkeyboard&lt;/code&gt; before using InputPanel. For more information, see &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtvirtualkeyboard-deployment-guide.html#loading-the-plugin&quot;&gt;Loading the Plugin&lt;/a&gt;.</source>
          <target state="translated">모듈에서 제공하는 &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtquick-virtualkeyboard-qmlmodule.html&quot;&gt;다른 모든 QML 유형&lt;/a&gt; 과 마찬가지로 &lt;code&gt;QT_IM_MODULE&lt;/code&gt; 환경 변수는 InputPanel을 사용하기 전에 &lt;code&gt;qtvirtualkeyboard&lt;/code&gt; 로 설정되어야합니다 . 자세한 내용 &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtvirtualkeyboard-deployment-guide.html#loading-the-plugin&quot;&gt;은 플러그인로드를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="70107fd1daa7f285681be3488ef8e841a8073e16" translate="yes" xml:space="preserve">
          <source>As with &lt;a href=&quot;qaxbase#dynamicCall&quot;&gt;dynamicCall&lt;/a&gt; the parameters can directly be embedded in the function string.</source>
          <target state="translated">&lt;a href=&quot;qaxbase#dynamicCall&quot;&gt;dynamicCall&lt;/a&gt; 과 마찬가지로 매개 변수를 함수 문자열에 직접 임베드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad2d2acbf84f81265a143b60cb3999fd31e8e802" translate="yes" xml:space="preserve">
          <source>As with &lt;a href=&quot;qwidget#close&quot;&gt;QWidget::close&lt;/a&gt;(), done() deletes the dialog if the &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt::WA_DeleteOnClose&lt;/a&gt; flag is set. If the dialog is the application's main widget, the application terminates. If the dialog is the last window closed, the &lt;a href=&quot;qguiapplication#lastWindowClosed&quot;&gt;QApplication::lastWindowClosed&lt;/a&gt;() signal is emitted.</source>
          <target state="translated">&lt;a href=&quot;qwidget#close&quot;&gt;QWidget :: close&lt;/a&gt; () 와 마찬가지로 &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt :: WA_DeleteOnClose&lt;/a&gt; 플래그가 설정된 경우 done ()은 대화 상자를 삭제합니다 . 대화 상자가 응용 프로그램의 기본 위젯이면 응용 프로그램이 종료됩니다. 대화 상자가 마지막으로 닫힌 창이면 &lt;a href=&quot;qguiapplication#lastWindowClosed&quot;&gt;QApplication :: lastWindowClosed&lt;/a&gt; () 신호가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="3dca5b4347978e782f2aae49dca48505a34acc8c" translate="yes" xml:space="preserve">
          <source>As with Flickable, there are several things to keep in mind when using &lt;a href=&quot;qml-qtquick-controls2-scrollview&quot;&gt;ScrollView&lt;/a&gt;:</source>
          <target state="translated">Flickable과 마찬가지로 &lt;a href=&quot;qml-qtquick-controls2-scrollview&quot;&gt;ScrollView를&lt;/a&gt; 사용할 때 명심해야 할 몇 가지가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="334a3eef44a246b9b1311bc27d58b2e428bc6a80" translate="yes" xml:space="preserve">
          <source>As with Flickable, there are several things to keep in mind when using ScrollView:</source>
          <target state="translated">Flickable과 마찬가지로 ScrollView를 사용할 때 염두에 두어야 할 몇 가지 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="8dca9237d1f1e146e87a17add20746942e0809ca" translate="yes" xml:space="preserve">
          <source>As with a plain &lt;a href=&quot;qtcpsocket&quot;&gt;QTcpSocket&lt;/a&gt;, &lt;a href=&quot;qsslsocket&quot;&gt;QSslSocket&lt;/a&gt; enters the &lt;a href=&quot;qabstractsocket#SocketState-enum&quot;&gt;HostLookupState&lt;/a&gt;, &lt;a href=&quot;qabstractsocket#SocketState-enum&quot;&gt;ConnectingState&lt;/a&gt;, and finally the &lt;a href=&quot;qabstractsocket#SocketState-enum&quot;&gt;ConnectedState&lt;/a&gt;, if the connection is successful. The handshake then starts automatically, and if it succeeds, the &lt;a href=&quot;qsslsocket#encrypted&quot;&gt;encrypted&lt;/a&gt;() signal is emitted to indicate the socket has entered the encrypted state and is ready for use.</source>
          <target state="translated">일반 &lt;a href=&quot;qtcpsocket&quot;&gt;QTcpSocket&lt;/a&gt; 과 &lt;a href=&quot;qsslsocket&quot;&gt;마찬가지로 QSslSocket&lt;/a&gt; 은 연결에 성공 하면 &lt;a href=&quot;qabstractsocket#SocketState-enum&quot;&gt;HostLookupState&lt;/a&gt; , &lt;a href=&quot;qabstractsocket#SocketState-enum&quot;&gt;ConnectingState&lt;/a&gt; 및 &lt;a href=&quot;qabstractsocket#SocketState-enum&quot;&gt;ConnectedState&lt;/a&gt; 로 들어갑니다 . 그런 다음 핸드 셰이크가 자동으로 시작되고 성공하면 소켓이 암호화 된 상태로 들어가서 사용할 준비가되었음을 나타내는 &lt;a href=&quot;qsslsocket#encrypted&quot;&gt;암호화 된&lt;/a&gt; () 신호가 방출됩니다.</target>
        </trans-unit>
        <trans-unit id="bb6c87093b5a562912ce8816d7f5e0a65875655c" translate="yes" xml:space="preserve">
          <source>As with a plain &lt;a href=&quot;qtcpsocket&quot;&gt;QTcpSocket&lt;/a&gt;, QSslSocket enters the &lt;a href=&quot;qabstractsocket#SocketState-enum&quot;&gt;HostLookupState&lt;/a&gt;, &lt;a href=&quot;qabstractsocket#SocketState-enum&quot;&gt;ConnectingState&lt;/a&gt;, and finally the &lt;a href=&quot;qabstractsocket#SocketState-enum&quot;&gt;ConnectedState&lt;/a&gt;, if the connection is successful. The handshake then starts automatically, and if it succeeds, the &lt;a href=&quot;qsslsocket#encrypted&quot;&gt;encrypted&lt;/a&gt;() signal is emitted to indicate the socket has entered the encrypted state and is ready for use.</source>
          <target state="translated">일반 &lt;a href=&quot;qtcpsocket&quot;&gt;QTcpSocket&lt;/a&gt; 과 마찬가지로 QSslSocket 은 연결이 성공 하면 &lt;a href=&quot;qabstractsocket#SocketState-enum&quot;&gt;HostLookupState&lt;/a&gt; , &lt;a href=&quot;qabstractsocket#SocketState-enum&quot;&gt;ConnectingState&lt;/a&gt; 및 마지막으로 &lt;a href=&quot;qabstractsocket#SocketState-enum&quot;&gt;ConnectedState&lt;/a&gt; 로 들어갑니다 . 그런 다음 핸드 셰이크가 자동으로 시작되고 성공하면 &lt;a href=&quot;qsslsocket#encrypted&quot;&gt;암호화 된&lt;/a&gt; () 신호가 방출되어 소켓이 암호화 된 상태에 들어가 사용할 준비가되었음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="ab7eee76ce23e99a1bb82b5e58bcbabae983998f" translate="yes" xml:space="preserve">
          <source>As with any application accessing other content beyond its control, a QML application should perform appropriate checks on any untrusted data it loads. &lt;b&gt;Do not, for example, use &lt;code&gt;import&lt;/code&gt;, &lt;a href=&quot;qml-qtquick-loader&quot;&gt;Loader&lt;/a&gt; or &lt;a href=&quot;qtqml-javascript-qmlglobalobject#xmlhttprequest&quot;&gt;XMLHttpRequest&lt;/a&gt; to load any untrusted code or content.&lt;/b&gt;</source>
          <target state="translated">제어 할 수없는 다른 컨텐트에 액세스하는 모든 응용 프로그램과 마찬가지로 QML 응용 프로그램은로드 된 신뢰할 수없는 데이터에 대해 적절한 검사를 수행해야합니다. &lt;b&gt;예를 들어, &lt;code&gt;import&lt;/code&gt; , &lt;a href=&quot;qml-qtquick-loader&quot;&gt;Loader&lt;/a&gt; 또는 &lt;a href=&quot;qtqml-javascript-qmlglobalobject#xmlhttprequest&quot;&gt;XMLHttpRequest&lt;/a&gt; 를 사용하여 신뢰할 수없는 코드 나 내용을로드 하지 마십시오 .&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="58fa63db0b17176c614933a229ff302283cae279" translate="yes" xml:space="preserve">
          <source>As with many text editors, the plain text editor widget can be configured to insert or overwrite existing text with new text entered by the user.</source>
          <target state="translated">많은 텍스트 편집기와 마찬가지로 일반 텍스트 편집기 위젯은 사용자가 입력 한 새 텍스트로 기존 텍스트를 삽입하거나 덮어 쓰도록 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf53e840238f62fd7ed7c78c847f3a401bdd1e65" translate="yes" xml:space="preserve">
          <source>As with many text editors, the text editor widget can be configured to insert or overwrite existing text with new text entered by the user.</source>
          <target state="translated">많은 텍스트 편집기와 마찬가지로 텍스트 편집기 위젯은 사용자가 입력 한 새 텍스트로 기존 텍스트를 삽입하거나 덮어 쓰도록 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="488a779e80ab224b087f57e53c24d09fb57b50b3" translate="yes" xml:space="preserve">
          <source>As with other &lt;a href=&quot;qpaintdevice&quot;&gt;QPaintDevice&lt;/a&gt; subclasses, a &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; object is used to paint onto an instance of this class:</source>
          <target state="translated">다른 &lt;a href=&quot;qpaintdevice&quot;&gt;QPaintDevice&lt;/a&gt; 서브 클래스 와 마찬가지로 , &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; 객체는이 클래스의 인스턴스에 페인트하는데 사용됩니다 :</target>
        </trans-unit>
        <trans-unit id="bbd92f9df1e3b0526ecbe7d7bcd25ace5713b3af" translate="yes" xml:space="preserve">
          <source>As with property values and method parameters, a signal parameter must have a type that is supported by the QML engine; see &lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;Data Type Conversion Between QML and C++&lt;/a&gt;. (Using an unregistered type will not generate an error, but the parameter value will not be accessible from the handler.)</source>
          <target state="translated">속성 값 및 메서드 매개 변수와 마찬가지로 신호 매개 변수에는 QML 엔진에서 지원하는 유형이 있어야합니다. &lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;QML과 C ++ 간의 데이터 유형 변환을&lt;/a&gt; 참조하십시오 . (등록되지 않은 유형을 사용하면 오류가 발생하지 않지만 핸들러에서 매개 변수 값에 액세스 할 수 없습니다.)</target>
        </trans-unit>
        <trans-unit id="aa3f8396bda2a8f40ac61cfb94922f811947f41e" translate="yes" xml:space="preserve">
          <source>As with property values and method parameters, a signal parameter must have a type that is supported by the QML engine; see &lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;Data Type Conversion Between QML and C++&lt;/a&gt;. (Using an unregistered type will not generate an error, but the parameter value will not be accessible from the handler.)</source>
          <target state="translated">특성 값 및 메소드 매개 변수와 마찬가지로 신호 매개 변수는 QML 엔진에서 지원하는 유형을 가져야합니다. &lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;QML과 C ++ 간의 데이터 유형 변환을&lt;/a&gt; 참조하십시오 . 등록되지 않은 유형을 사용하면 오류가 발생하지 않지만 처리기에서 매개 변수 값에 액세스 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="09de86e376e3caa9b80f7461aea890fc690e099a" translate="yes" xml:space="preserve">
          <source>As with the &lt;code&gt;left&lt;/code&gt; and &lt;code&gt;right&lt;/code&gt; delegates, it sits behind both &lt;a href=&quot;qml-qtquick-controls2-control#contentItem-prop&quot;&gt;contentItem&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-controls2-control#background-prop&quot;&gt;background&lt;/a&gt;. However, a &lt;a href=&quot;qml-qtquick-controls2-swipedelegate&quot;&gt;SwipeDelegate&lt;/a&gt; whose &lt;code&gt;behind&lt;/code&gt; has been set can be continuously swiped from either side, and will always show the same item.</source>
          <target state="translated">&lt;code&gt;left&lt;/code&gt; 및 &lt;code&gt;right&lt;/code&gt; 대리자 와 마찬가지로 &lt;a href=&quot;qml-qtquick-controls2-control#contentItem-prop&quot;&gt;contentItem&lt;/a&gt; 과 &lt;a href=&quot;qml-qtquick-controls2-control#background-prop&quot;&gt;background&lt;/a&gt; 뒤에 있습니다 . 그러나, &lt;a href=&quot;qml-qtquick-controls2-swipedelegate&quot;&gt;SwipeDelegate&lt;/a&gt; 그 &lt;code&gt;behind&lt;/code&gt; 있었다 세트는 지속적으로 양쪽에서 강타 할 수 있으며, 항상 같은 항목을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="f59cdc42e366c3032c136cba2e0c06c1cb9980a2" translate="yes" xml:space="preserve">
          <source>As with the other Qt OpenGL classes, &lt;a href=&quot;qopengltimerquery&quot;&gt;QOpenGLTimerQuery&lt;/a&gt; has a &lt;a href=&quot;qopengltimerquery#create&quot;&gt;create&lt;/a&gt;() function to create the underlying OpenGL object. This is to allow the developer to ensure that there is a valid current OpenGL context at the time.</source>
          <target state="translated">다른 Qt OpenGL 클래스와 &lt;a href=&quot;qopengltimerquery&quot;&gt;마찬가지로 QOpenGLTimerQuery&lt;/a&gt; 에는 기본 OpenGL 객체를 작성 하는 &lt;a href=&quot;qopengltimerquery#create&quot;&gt;create&lt;/a&gt; () 함수가 있습니다. 이를 통해 개발자는 당시 유효한 현재 OpenGL 컨텍스트가 있는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e5dfdcce60e6c71c9f6f941d80b07dc06e9af38" translate="yes" xml:space="preserve">
          <source>As with the other Qt OpenGL classes, &lt;a href=&quot;qopenglvertexarrayobject&quot;&gt;QOpenGLVertexArrayObject&lt;/a&gt; has a &lt;a href=&quot;qopenglvertexarrayobject#create&quot;&gt;create&lt;/a&gt;() function to create the underlying OpenGL object. This is to allow the developer to ensure that there is a valid current OpenGL context at the time.</source>
          <target state="translated">다른 Qt OpenGL 클래스와 &lt;a href=&quot;qopenglvertexarrayobject&quot;&gt;마찬가지로 QOpenGLVertexArrayObject&lt;/a&gt; 에는 기본 OpenGL 객체를 작성 하는 &lt;a href=&quot;qopenglvertexarrayobject#create&quot;&gt;create&lt;/a&gt; () 함수가 있습니다. 이를 통해 개발자는 당시 유효한 현재 OpenGL 컨텍스트가 있는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f377f1398e30001f5143cdcbe6508b487d3a2163" translate="yes" xml:space="preserve">
          <source>As with the other Qt OpenGL classes, QOpenGLTimerQuery has a &lt;a href=&quot;qopengltimerquery#create&quot;&gt;create&lt;/a&gt;() function to create the underlying OpenGL object. This is to allow the developer to ensure that there is a valid current OpenGL context at the time.</source>
          <target state="translated">다른 Qt OpenGL 클래스와 마찬가지로 QOpenGLTimerQuery에는 기본 OpenGL 객체를 만드는 &lt;a href=&quot;qopengltimerquery#create&quot;&gt;create&lt;/a&gt; () 함수가 있습니다. 이는 개발자가 현재 유효한 OpenGL 컨텍스트가 있는지 확인할 수 있도록하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="1a02a1d747b6ef4d6dcd407895265b3a1da6f0de" translate="yes" xml:space="preserve">
          <source>As with the other Qt OpenGL classes, QOpenGLVertexArrayObject has a &lt;a href=&quot;qopenglvertexarrayobject#create&quot;&gt;create&lt;/a&gt;() function to create the underlying OpenGL object. This is to allow the developer to ensure that there is a valid current OpenGL context at the time.</source>
          <target state="translated">다른 Qt OpenGL 클래스와 마찬가지로 QOpenGLVertexArrayObject에는 기본 OpenGL 객체를 만드는 &lt;a href=&quot;qopenglvertexarrayobject#create&quot;&gt;create&lt;/a&gt; () 함수가 있습니다. 이는 개발자가 현재 유효한 OpenGL 컨텍스트가 있는지 확인할 수 있도록하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="2b5bd7d662263ec597439f8e28d46944ffedd4b2" translate="yes" xml:space="preserve">
          <source>As with the other signals, &lt;code&gt;shortcutOverride&lt;/code&gt; will only be emitted for an item if that item has &lt;a href=&quot;qml-qtquick-item#activeFocus-prop&quot;&gt;activeFocus&lt;/a&gt;.</source>
          <target state="translated">다른 신호와 마찬가지로, 항목에 &lt;a href=&quot;qml-qtquick-item#activeFocus-prop&quot;&gt;activeFocus&lt;/a&gt; 가있는 경우 항목에 대해 &lt;code&gt;shortcutOverride&lt;/code&gt; 가 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="6b44cd4cd61e1932d8fee83c3a383689100258e3" translate="yes" xml:space="preserve">
          <source>As with the sensor classes, these provide convenience wrappers that reduce the need for casting.</source>
          <target state="translated">센서 클래스와 마찬가지로, 이것들은 캐스팅의 필요성을 줄이는 편리한 래퍼를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c72f3abfc1dc38e462f692ce8e762d7d24370882" translate="yes" xml:space="preserve">
          <source>As you can see, there are &lt;a href=&quot;qinappproduct#ProductType-enum&quot;&gt;consumable products&lt;/a&gt; and &lt;a href=&quot;qinappproduct#ProductType-enum&quot;&gt;unlockable products&lt;/a&gt;. The former can be purchased any number of times by the same user, whereas the latter can only be purchased once.</source>
          <target state="translated">보시다시피 &lt;a href=&quot;qinappproduct#ProductType-enum&quot;&gt;소모품&lt;/a&gt; 및 &lt;a href=&quot;qinappproduct#ProductType-enum&quot;&gt;잠금 해제 가능한 제품이&lt;/a&gt; 있습니다. 전자는 동일한 사용자가 여러 번 구매할 수 있지만 후자는 한 번만 구매할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba2cb2309020c1d950c873e2906840fd61f08cae" translate="yes" xml:space="preserve">
          <source>As you can see, there are consumable products and unlockable products. The former can be purchased any number of times by the same user, while the latter can only be purchased once.</source>
          <target state="translated">보시다시피 소모품 및 잠금 해제 가능한 제품이 있습니다. 전자는 동일한 사용자가 여러 번 구매할 수 있지만 후자는 한 번만 구매할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="861b2f34a7dc04111611d1f7b49c485074014484" translate="yes" xml:space="preserve">
          <source>As you can see, this tree has a single leaf and is composed of 3 nodes in total as shown in the following diagram.</source>
          <target state="translated">보시다시피이 트리에는 단일 리프가 있으며 다음 다이어그램과 같이 총 3 개의 노드로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="173b74cb0069711f0207e76fa411aa938fa50851" translate="yes" xml:space="preserve">
          <source>As you change the properties of the DefaultMaterial, behind the scenes new shaders are generated, and the property values are bound. The complexity of a shader depends on a combination of the properties that are set on it, and the context of the scene itself.</source>
          <target state="translated">DefaultMaterial의 속성을 변경하면 백그라운드에서 새 셰이더가 생성되고 속성 값이 바인딩됩니다. 셰이더의 복잡성은 설정된 속성의 조합과 장면 자체의 컨텍스트에 따라 달라집니다.</target>
        </trans-unit>
        <trans-unit id="6ff9c765127879bf0a92f97693d6218332e44511" translate="yes" xml:space="preserve">
          <source>As you change the properties of the PrincipledMaterial, behind the scenes new shaders are generated, and the property values are bound. The complexity of a shader depends on a combination of the properties that are set on it, and the context of the scene itself.</source>
          <target state="translated">PrincipledMaterial의 속성을 변경하면 백그라운드에서 새 셰이더가 생성되고 속성 값이 바인딩됩니다. 셰이더의 복잡성은 설정된 속성의 조합과 장면 자체의 컨텍스트에 따라 달라집니다.</target>
        </trans-unit>
        <trans-unit id="ed99f639d7e9754980d05f7fcc66b785b4e83872" translate="yes" xml:space="preserve">
          <source>As you now have the &lt;code&gt;MyControls&lt;/code&gt; namespace, you can name the controls after their actual counterparts in the Qt Quick Controls 2 module. You can repeat this process for any control that you wish to add.</source>
          <target state="translated">이제 &lt;code&gt;MyControls&lt;/code&gt; 네임 스페이스가 있으므로 Qt Quick Controls 2 모듈에서 실제 대응 물 뒤에 컨트롤 이름을 지정할 수 있습니다. 추가하려는 모든 컨트롤에 대해이 프로세스를 반복 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="69f2204ffb7bb771312c419735367d4900194ebc" translate="yes" xml:space="preserve">
          <source>As you now have the &lt;code&gt;MyControls&lt;/code&gt; namespace, you can name the controls after their actual counterparts in the Qt Quick Controls module. You can repeat this process for any control that you wish to add.</source>
          <target state="translated">이제 &lt;code&gt;MyControls&lt;/code&gt; 네임 스페이스가 있으므로 Qt Quick Controls 모듈에서 실제 대응되는 컨트롤 이름을 따서 컨트롤 이름을 지정할 수 있습니다. 추가하려는 컨트롤에 대해이 프로세스를 반복 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="053b2e8dc6846460106637afa63ece4a2c99e1a0" translate="yes" xml:space="preserve">
          <source>Aside from the primitive types, &lt;a href=&quot;dbus-changes-qt6#qdbusargument&quot;&gt;QDBusArgument&lt;/a&gt; also supports two non-primitive types natively, due to their widespread use in Qt applications: &lt;a href=&quot;qstringlist&quot;&gt;QStringList&lt;/a&gt; and &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17bde0180734ffc3e6fa2aff197971bd9a83cd63" translate="yes" xml:space="preserve">
          <source>Aside from the primitive types, &lt;a href=&quot;qdbusargument&quot;&gt;QDBusArgument&lt;/a&gt; also supports two non-primitive types natively, due to their widespread use in Qt applications: &lt;a href=&quot;qstringlist&quot;&gt;QStringList&lt;/a&gt; and &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt;.</source>
          <target state="translated">기본 유형 외에도, &lt;a href=&quot;qdbusargument&quot;&gt;QDBusArgument&lt;/a&gt; 는 Qt 애플리케이션에서 널리 사용되는 &lt;a href=&quot;qstringlist&quot;&gt;QStringList&lt;/a&gt; 및 &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; 로 인해 기본이 아닌 두 가지 유형을 기본적으로 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="8db1a3abb275f2b110ededaa1b75b2221f595548" translate="yes" xml:space="preserve">
          <source>Aside from the reduced performance of complex bindings (for example, due to having to enter the JavaScript execution context to perform evaluation), they also take up more memory both on the C++ heap and the JavaScript heap than bindings which can be evaluated by QML's optimized binding expression evaluator.</source>
          <target state="translated">복잡한 바인딩의 성능 저하 (예 : 평가를 수행하기 위해 JavaScript 실행 컨텍스트를 입력해야 함) 외에도 QML의 최적화 된 것으로 평가할 수있는 바인딩보다 C ++ 힙 및 JavaScript 힙 모두에서 더 많은 메모리를 차지합니다. 바인딩 식 평가 기.</target>
        </trans-unit>
        <trans-unit id="80bb45b38f22429c8fb2eb1ba83a0c598777f3d1" translate="yes" xml:space="preserve">
          <source>Aside: If you have a signals and slots connection in a tight inner loop of a performance critical task and you identify this connection as the bottleneck, think about using the standard listener-interface pattern rather than signals and slots. In cases where this occurs, you probably only require a 1:1 connection anyway. For example, if you have an object that downloads data from the network, it's a perfectly sensible design to use a signal to indicate that the requested data arrived. But if you need to send out every single byte one by one to a consumer, use a listener interface rather than signals and slots.</source>
          <target state="translated">따로 : 성능이 중요한 작업의 단단한 내부 루프에 신호 및 슬롯 연결이 있고이 연결을 병목 현상으로 식별하는 경우 신호 및 슬롯 대신 표준 리스너 인터페이스 패턴을 사용하는 것을 고려하십시오. 이런 일이 발생하는 경우 어쨌든 1 : 1 연결 만 필요합니다. 예를 들어 네트워크에서 데이터를 다운로드하는 개체가있는 경우 요청 된 데이터가 도착했음을 나타내는 신호를 사용하는 것이 현명한 디자인입니다. 그러나 모든 단일 바이트를 하나씩 소비자에게 보내야하는 경우 신호와 슬롯 대신 리스너 인터페이스를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="209b536ca15064ddafc5f396c336fd0a64402da6" translate="yes" xml:space="preserve">
          <source>Asking for help.</source>
          <target state="translated">도움을 요청.</target>
        </trans-unit>
        <trans-unit id="0080b719b81565725930a595e97832ebc5e3b28f" translate="yes" xml:space="preserve">
          <source>Asks the &lt;a href=&quot;qml-qtquick-particles-itemparticle&quot;&gt;ItemParticle&lt;/a&gt; to take over control of</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-particles-itemparticle&quot;&gt;ItemParticle&lt;/a&gt; 에게 제어권을 요청합니다.</target>
        </trans-unit>
        <trans-unit id="8f9be24e050960d01bf72dca7b04e695ff1206f6" translate="yes" xml:space="preserve">
          <source>Asks the &lt;a href=&quot;qml-qtquick-particles-itemparticle&quot;&gt;ItemParticle&lt;/a&gt; to take over control of item positioning temporarily. It will follow the movement of a logical particle when one is available.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-particles-itemparticle&quot;&gt;ItemParticle&lt;/a&gt; 이 아이템 포지셔닝을 일시적으로 제어하도록 요청합니다 . 논리 입자가 사용 가능할 때 논리 입자의 움직임을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="4e269c910ad2734759be1c2890df8168d487a85f" translate="yes" xml:space="preserve">
          <source>Asks the application to quit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18e27f0cb4e68409aaf923cd0204e0cd2a5d7cf0" translate="yes" xml:space="preserve">
          <source>Asks the session manager for permission to interact with the user. Returns true if interaction is permitted; otherwise returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">세션 관리자에게 사용자와 상호 작용할 수있는 권한을 요청합니다. 상호 작용이 허용되면 true를 리턴합니다. 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="ac6b0bbf61b969fc3b48d7387b5201f68104d2a4" translate="yes" xml:space="preserve">
          <source>Asks the window manager to not give focus to this top level window. This attribute has no effect on non-X11 platforms.</source>
          <target state="translated">창 관리자에게이 최상위 창에 초점을 두지 않도록 요청합니다. 이 속성은 X11 이외의 플랫폼에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2e97d821a923211f1a7fd1122dd8c979af132a13" translate="yes" xml:space="preserve">
          <source>AspectRatio  (surface width / surface height)</source>
          <target state="translated">AspectRatio (표면 너비 / 표면 높이)</target>
        </trans-unit>
        <trans-unit id="92200ee3f6b98bd4979778912a47cd3c07445782" translate="yes" xml:space="preserve">
          <source>AspectType</source>
          <target state="translated">AspectType</target>
        </trans-unit>
        <trans-unit id="5ff162a7839a73dff64f80c8862ffe44d4437e92" translate="yes" xml:space="preserve">
          <source>Aspects of the parsing behavior can be adapted using &lt;a href=&quot;qxmlsimplereader#setFeature&quot;&gt;setFeature&lt;/a&gt;() and &lt;a href=&quot;qxmlsimplereader#setProperty&quot;&gt;setProperty&lt;/a&gt;().</source>
          <target state="translated">구문 분석 동작의 양상은 &lt;a href=&quot;qxmlsimplereader#setFeature&quot;&gt;setFeature&lt;/a&gt; () 및 &lt;a href=&quot;qxmlsimplereader#setProperty&quot;&gt;setProperty&lt;/a&gt; ()를 사용하여 조정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fd32298b4e7c841022a5222fa11f9200a4965151" translate="yes" xml:space="preserve">
          <source>Assemble the Service</source>
          <target state="translated">서비스 조립</target>
        </trans-unit>
        <trans-unit id="4141add45a26459c4bd39909388482311f6fe29a" translate="yes" xml:space="preserve">
          <source>Assert</source>
          <target state="translated">Assert</target>
        </trans-unit>
        <trans-unit id="49bf55dc112eb3597726ba8ecf785a4fae4cbce0" translate="yes" xml:space="preserve">
          <source>Assertions</source>
          <target state="translated">Assertions</target>
        </trans-unit>
        <trans-unit id="0a0e8459185a7da2d3178427da1b3513e2713c82" translate="yes" xml:space="preserve">
          <source>Assertions make some statement about the text at the point where they occur in the regexp but they do not match any characters. In the following list &lt;b&gt;&lt;i&gt;E&lt;/i&gt;&lt;/b&gt; stands for any expression.</source>
          <target state="translated">어설 션은 정규 표현식에서 발생하지만 문자와 일치하지 않는 지점에서 텍스트에 대해 설명합니다. 다음 목록에서 &lt;b&gt;&lt;i&gt;E&lt;/i&gt;&lt;/b&gt; 는 식을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="4426afd90a77a35fb37ebd7110b9989cf7bed224" translate="yes" xml:space="preserve">
          <source>Asset</source>
          <target state="translated">Asset</target>
        </trans-unit>
        <trans-unit id="015074f87e95cf8cc3148a1de74a042445c8931e" translate="yes" xml:space="preserve">
          <source>Asset Conditioning</source>
          <target state="translated">자산 컨디셔닝</target>
        </trans-unit>
        <trans-unit id="b93ea6bc7e684b128703f5ddb35f473f9ccc826b" translate="yes" xml:space="preserve">
          <source>Asset Examples</source>
          <target state="translated">자산 예</target>
        </trans-unit>
        <trans-unit id="7c773084618e65327e77bcf8b8e757a8077d3b4c" translate="yes" xml:space="preserve">
          <source>AssetImporters Plugins</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c448cf7fe03487b8fc745327e1e39ca87845735b" translate="yes" xml:space="preserve">
          <source>Assets File System</source>
          <target state="translated">자산 파일 시스템</target>
        </trans-unit>
        <trans-unit id="2444928438f54ef4414cddff39193096c12629aa" translate="yes" xml:space="preserve">
          <source>Assign</source>
          <target state="translated">Assign</target>
        </trans-unit>
        <trans-unit id="986e599c10041bc8283187d0fc115ad5e6b627d9" translate="yes" xml:space="preserve">
          <source>Assign a &lt;a href=&quot;qml-qtquick-controls-menu&quot;&gt;Menu&lt;/a&gt; to this property to get a pull-down menu button.</source>
          <target state="translated">풀다운 메뉴 버튼을 얻으려면이 속성에 &lt;a href=&quot;qml-qtquick-controls-menu&quot;&gt;메뉴&lt;/a&gt; 를 할당하십시오 .</target>
        </trans-unit>
        <trans-unit id="657b3ebab2cb4a05a9ab4551475f9772cf932de0" translate="yes" xml:space="preserve">
          <source>Assign a topic to a QDoc comment - A comment could be a page, a property documentation, a class documentation, or any of the available &lt;a href=&quot;https://doc.qt.io/qt-5.13/13-qdoc-commands-topics.html#&quot;&gt;topic commands&lt;/a&gt;.</source>
          <target state="translated">QDoc 주석에 주제 지정-주석은 페이지, 특성 문서, 클래스 문서 또는 사용 가능한 &lt;a href=&quot;https://doc.qt.io/qt-5.13/13-qdoc-commands-topics.html#&quot;&gt;주제 명령 일&lt;/a&gt; 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a1c8c8e977f8a71e565cd75c90f75a1e0a902938" translate="yes" xml:space="preserve">
          <source>Assign a topic to a QDoc comment - A comment could be a page, a property documentation, a class documentation, or any of the available &lt;a href=&quot;https://doc.qt.io/qt-5.15/13-qdoc-commands-topics.html&quot;&gt;topic commands&lt;/a&gt;.</source>
          <target state="translated">QDoc 주석에 주제 할당-주석은 페이지, 속성 문서, 클래스 문서 또는 사용 가능한 모든 &lt;a href=&quot;https://doc.qt.io/qt-5.15/13-qdoc-commands-topics.html&quot;&gt;주제 명령 일&lt;/a&gt; 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="21b27b78102bb9df181e31910b95b0f651c47879" translate="yes" xml:space="preserve">
          <source>Assign a topic to a QDoc comment - A comment could be a page, a property documentation, a class documentation, or any of the available &lt;a href=&quot;https://doc.qt.io/qt-6.0/13-qdoc-commands-topics.html&quot;&gt;topic commands&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1441632d366ed3ca636d23b1416a14537fec58fe" translate="yes" xml:space="preserve">
          <source>Assigning Values</source>
          <target state="translated">값 할당</target>
        </trans-unit>
        <trans-unit id="cf9105a23e3c1c0024455d955363ad4a3d5812f2" translate="yes" xml:space="preserve">
          <source>Assigning Values to Property Attributes</source>
          <target state="translated">속성 속성에 값 할당</target>
        </trans-unit>
        <trans-unit id="8f8fa75efce008484085eae902f298db122ee253" translate="yes" xml:space="preserve">
          <source>Assignment operator, assign</source>
          <target state="translated">할당 연산자, 할당</target>
        </trans-unit>
        <trans-unit id="57b7284b53bea6e095fae1d654500ee410048752" translate="yes" xml:space="preserve">
          <source>Assignment operator, assigns</source>
          <target state="translated">할당 연산자, 할당</target>
        </trans-unit>
        <trans-unit id="c60d0d4e8b3c326541217252d2e7f2cf31625cda" translate="yes" xml:space="preserve">
          <source>Assignment operator. Assigns the</source>
          <target state="translated">할당 연산자. 할당</target>
        </trans-unit>
        <trans-unit id="24c910a013b8c5906b1cd9ba41947a56e3a154e6" translate="yes" xml:space="preserve">
          <source>Assignment operator. This guarded pointer will now point to the same object that</source>
          <target state="translated">할당 연산자. 이 보호 포인터는 이제 동일한 객체를 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="07964378a8d1220311421c67d166f9a93a054a08" translate="yes" xml:space="preserve">
          <source>Assignment. Makes a copy of</source>
          <target state="translated">할당. 의 사본을 만듭니다</target>
        </trans-unit>
        <trans-unit id="0376e8f00ecf6d9a805c3ee4d46f35c9cc4bbbdb" translate="yes" xml:space="preserve">
          <source>AssignmentInfo Struct</source>
          <target state="translated">과제 정보 구조</target>
        </trans-unit>
        <trans-unit id="f3648d2f302803cec9a6936b971744757ba50945" translate="yes" xml:space="preserve">
          <source>AssignmentInfo::context</source>
          <target state="translated">AssignmentInfo::context</target>
        </trans-unit>
        <trans-unit id="589ed4a8be86536dbd1aeddad0b32db87ad648e8" translate="yes" xml:space="preserve">
          <source>AssignmentInfo::dest</source>
          <target state="translated">AssignmentInfo::dest</target>
        </trans-unit>
        <trans-unit id="f817060420efee2ff9d1a76c4643994044b01a37" translate="yes" xml:space="preserve">
          <source>AssignmentInfo::expr</source>
          <target state="translated">AssignmentInfo::expr</target>
        </trans-unit>
        <trans-unit id="9f2a0cc5f167ef3113974a9fe34af5506e805041" translate="yes" xml:space="preserve">
          <source>Assigns</source>
          <target state="translated">Assigns</target>
        </trans-unit>
        <trans-unit id="f92e5b99ea2de76eb2c44df249cb0bef49dabc28" translate="yes" xml:space="preserve">
          <source>Assigns a Windows</source>
          <target state="translated">윈도우 할당</target>
        </trans-unit>
        <trans-unit id="d45bdd4bad97015089eba0cf4ce24245724db744" translate="yes" xml:space="preserve">
          <source>Assigns a copy of</source>
          <target state="translated">의 사본을 할당합니다</target>
        </trans-unit>
        <trans-unit id="c380382dc946c6b38c72f9000c2fa642f83370ed" translate="yes" xml:space="preserve">
          <source>Assigns a new</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="214f273d64bf82622948c8930cf9f71cf5a1dba2" translate="yes" xml:space="preserve">
          <source>Assigns a shallow copy of</source>
          <target state="translated">얕은 사본을 할당합니다</target>
        </trans-unit>
        <trans-unit id="fd31892264d57d78eaa612788450f11e1d014de2" translate="yes" xml:space="preserve">
          <source>Assigns a shallow copy of the given</source>
          <target state="translated">주어진 것의 얕은 사본을 할당합니다</target>
        </trans-unit>
        <trans-unit id="40c0762b3589ba836834cf365ef423f9c0d675c3" translate="yes" xml:space="preserve">
          <source>Assigns an</source>
          <target state="translated">할당</target>
        </trans-unit>
        <trans-unit id="85e617352338e9202319f3b82bca196a8c8fc151" translate="yes" xml:space="preserve">
          <source>Assigns another host</source>
          <target state="translated">다른 호스트를 할당</target>
        </trans-unit>
        <trans-unit id="4fa69103ae8cb16e772a9ff85090bbdb5ed3666a" translate="yes" xml:space="preserve">
          <source>Assigns character</source>
          <target state="translated">캐릭터를 할당</target>
        </trans-unit>
        <trans-unit id="f47bdc31d76b5266afbc0c2a14419aab86ba6b9f" translate="yes" xml:space="preserve">
          <source>Assigns picture</source>
          <target state="translated">사진을 할당합니다</target>
        </trans-unit>
        <trans-unit id="f6feee028389ad98aad9d6da8ed93c2722b81c26" translate="yes" xml:space="preserve">
          <source>Assigns the</source>
          <target state="translated">할당</target>
        </trans-unit>
        <trans-unit id="72cf90175289fab0fa061f23cecdbbbc413dd29f" translate="yes" xml:space="preserve">
          <source>Assigns the &lt;a href=&quot;qsslpresharedkeyauthenticator&quot;&gt;QSslPreSharedKeyAuthenticator&lt;/a&gt; object</source>
          <target state="translated">&lt;a href=&quot;qsslpresharedkeyauthenticator&quot;&gt;QSslPreSharedKeyAuthenticator&lt;/a&gt; 객체를 할당 합니다</target>
        </trans-unit>
        <trans-unit id="801a35ae06553e61d456afde92c73023c075b5dc" translate="yes" xml:space="preserve">
          <source>Assigns the Latin-1 string</source>
          <target state="translated">라틴 -1 문자열을 할당합니다</target>
        </trans-unit>
        <trans-unit id="976606da71793c1f834eeeb18a5bcde700d6569c" translate="yes" xml:space="preserve">
          <source>Assigns the collection of values in</source>
          <target state="translated">값 모음을 할당합니다.</target>
        </trans-unit>
        <trans-unit id="1dd05365443bf8bb053b9389faf63030fc3336bb" translate="yes" xml:space="preserve">
          <source>Assigns the content (text and format) of the</source>
          <target state="translated">의 내용 (텍스트 및 형식)을 할당합니다</target>
        </trans-unit>
        <trans-unit id="fb89c254fd932c2786b45f91de6af5c5be0c03a8" translate="yes" xml:space="preserve">
          <source>Assigns the contents of</source>
          <target state="translated">의 내용을 할당</target>
        </trans-unit>
        <trans-unit id="d9d8f0b8c6f445b2fcbb7b3df078810009344b91" translate="yes" xml:space="preserve">
          <source>Assigns the data of</source>
          <target state="translated">의 데이터를 할당합니다</target>
        </trans-unit>
        <trans-unit id="873c8b9f541f0b268a383c6780595ff1af2d75f7" translate="yes" xml:space="preserve">
          <source>Assigns the data of the</source>
          <target state="translated">의 데이터를 할당합니다</target>
        </trans-unit>
        <trans-unit id="f34d479f5d050bccc28029787d65108a47741756" translate="yes" xml:space="preserve">
          <source>Assigns the font info in</source>
          <target state="translated">글꼴 정보를</target>
        </trans-unit>
        <trans-unit id="c05921b1ee7b5acef8bad7c36beb484e359bee74" translate="yes" xml:space="preserve">
          <source>Assigns the font metrics</source>
          <target state="translated">글꼴 메트릭을 할당합니다</target>
        </trans-unit>
        <trans-unit id="2d2e1388da966c4ba36a294a2b5d6bed24b56ef8" translate="yes" xml:space="preserve">
          <source>Assigns the given</source>
          <target state="translated">주어진 할당</target>
        </trans-unit>
        <trans-unit id="5d8210ba4c95c21960d58255001b0d0413154275" translate="yes" xml:space="preserve">
          <source>Assigns the host address</source>
          <target state="translated">호스트 주소를 할당합니다</target>
        </trans-unit>
        <trans-unit id="6aeb06a0e9c4be45c78e41a37b5477ce3da973c6" translate="yes" xml:space="preserve">
          <source>Assigns the iterator</source>
          <target state="translated">반복자를 할당합니다</target>
        </trans-unit>
        <trans-unit id="275941fc7784806d44b9d804a7c339cd785c4ea2" translate="yes" xml:space="preserve">
          <source>Assigns the match result</source>
          <target state="translated">경기 결과를 할당</target>
        </trans-unit>
        <trans-unit id="46071a015167b49375a721f0c938c2362334270a" translate="yes" xml:space="preserve">
          <source>Assigns the message</source>
          <target state="translated">메시지를 할당</target>
        </trans-unit>
        <trans-unit id="8a9a8b84d8009bad8e3bf16c836adc4fd08f1220" translate="yes" xml:space="preserve">
          <source>Assigns the object,</source>
          <target state="translated">객체를 할당하고</target>
        </trans-unit>
        <trans-unit id="34b815d741916882b0098831bd58278b18a74427" translate="yes" xml:space="preserve">
          <source>Assigns the previous value to the managed variable. This is the value at construction time, or at the last call to &lt;a href=&quot;qscopedvaluerollback#commit&quot;&gt;commit&lt;/a&gt;()</source>
          <target state="translated">이전 값을 관리 변수에 지정합니다. 이는 시공시의 값, 또는 최근 통화로하는 &lt;a href=&quot;qscopedvaluerollback#commit&quot;&gt;투입&lt;/a&gt; ) (</target>
        </trans-unit>
        <trans-unit id="5355328eb248f9644497135f1a55f68091ffcff0" translate="yes" xml:space="preserve">
          <source>Assigns the regular expression</source>
          <target state="translated">정규식을 할당합니다</target>
        </trans-unit>
        <trans-unit id="0efa8f59037690c88f785f377faf17baaed1be9a" translate="yes" xml:space="preserve">
          <source>Assigns the special address</source>
          <target state="translated">특별한 주소를 할당</target>
        </trans-unit>
        <trans-unit id="3e58888169c81cf4e97039e4d8f36831d937914b" translate="yes" xml:space="preserve">
          <source>Assigns the specified</source>
          <target state="translated">지정된 것을 할당</target>
        </trans-unit>
        <trans-unit id="40ec6bef35a847b998e9a2da7a21369f71c7f350" translate="yes" xml:space="preserve">
          <source>Assigns the value</source>
          <target state="translated">값을 할당합니다</target>
        </trans-unit>
        <trans-unit id="e77da1cd9a8cbaa3264bfe32aae6f6044b12da48" translate="yes" xml:space="preserve">
          <source>Assigns the value of</source>
          <target state="translated">의 값을 할당합니다</target>
        </trans-unit>
        <trans-unit id="8a33a76b3af75c9e791ff73e77cd3cf43fae27e7" translate="yes" xml:space="preserve">
          <source>Assigns the value of the given</source>
          <target state="translated">주어진 값을 할당</target>
        </trans-unit>
        <trans-unit id="6e076e5f7162ea14899f4ad786f6629ab5297f04" translate="yes" xml:space="preserve">
          <source>Assigns the value of the given Qt</source>
          <target state="translated">주어진 Qt의 값을 할당</target>
        </trans-unit>
        <trans-unit id="e8de2d3f3964cb86c85419b37fdfa623d80a68b5" translate="yes" xml:space="preserve">
          <source>Assigns the value of the network proxy</source>
          <target state="translated">네트워크 프록시의 값을 할당합니다</target>
        </trans-unit>
        <trans-unit id="5af7cc5287cd40cf758ee7c3298d4248d5c63741" translate="yes" xml:space="preserve">
          <source>Assigns the value of the variant</source>
          <target state="translated">변형의 값을 할당합니다</target>
        </trans-unit>
        <trans-unit id="d3f618d95957c5fd7d77847a9ebd87c45f7418de" translate="yes" xml:space="preserve">
          <source>Assigns the value stored in</source>
          <target state="translated">저장된 값을 할당합니다</target>
        </trans-unit>
        <trans-unit id="75ba477098456f34d9a243599bf4849341324961" translate="yes" xml:space="preserve">
          <source>Assigns the values from</source>
          <target state="translated">에서 값을 할당합니다</target>
        </trans-unit>
        <trans-unit id="1de97a6659207c6ba2a1461b47d5df8e6d514fb7" translate="yes" xml:space="preserve">
          <source>Assigns the values of</source>
          <target state="translated">의 값을 할당합니다</target>
        </trans-unit>
        <trans-unit id="6f6ddc5f0c27beba11482455b71b8ff4072f6d2b" translate="yes" xml:space="preserve">
          <source>Assigns the version and profile of</source>
          <target state="translated">의 버전과 프로필을 할당합니다</target>
        </trans-unit>
        <trans-unit id="be2ed2bbffb380de90fe8da01c8a3976377908bf" translate="yes" xml:space="preserve">
          <source>Assigns the weight</source>
          <target state="translated">무게를 할당</target>
        </trans-unit>
        <trans-unit id="00d9b32906c7d1516b9836bdd3a8e3ae699fe3c4" translate="yes" xml:space="preserve">
          <source>Assigns this &lt;a href=&quot;qsourcelocation&quot;&gt;QSourceLocation&lt;/a&gt; instance to</source>
          <target state="translated">이 &lt;a href=&quot;qsourcelocation&quot;&gt;QSourceLocation&lt;/a&gt; 인스턴스를</target>
        </trans-unit>
        <trans-unit id="422196ccf47e7f549778766e36852518c23c436e" translate="yes" xml:space="preserve">
          <source>Assigns this NDEF record to</source>
          <target state="translated">이 NDEF 레코드를</target>
        </trans-unit>
        <trans-unit id="1c9c50403a3e43b1fbff3870a2552d446574206c" translate="yes" xml:space="preserve">
          <source>Assimp - Clipper, version 4.8.8</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4007eea890477200f248dc422599b78f61ce3118" translate="yes" xml:space="preserve">
          <source>Assimp - Open Asset Import Library, version 5.0.1</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f917444fbb88fea6d32ebc295abc538ad9f096ee" translate="yes" xml:space="preserve">
          <source>Assimp - Open3DGC</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06438e1ddae37a0a3992b88abc043dfaaa185a17" translate="yes" xml:space="preserve">
          <source>Assimp - Poly2Tri Polygon Triangulation Library</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b96b3a7eb31a143b44c24d3fcfee33e69b76b5bd" translate="yes" xml:space="preserve">
          <source>Assimp - RapidJSON</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c905922e9f14f868ec6415173b8017fb0960e4cd" translate="yes" xml:space="preserve">
          <source>Assimp - The OpenDDL-Parser</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c96230e9398d61f8a427b37b7babfed955b2587d" translate="yes" xml:space="preserve">
          <source>Assimp - This plugin uses the 3rd party library libAssimp to convert 3D assets in 3D interchange formats to Qt Quick 3D QML components.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15fe588acd18235c77359d1be119856fb785edb0" translate="yes" xml:space="preserve">
          <source>Assimp - Unzip, version 1.01e</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54de2ef2e6c2423109b816afdfe69cda45c899ed" translate="yes" xml:space="preserve">
          <source>Assimp - Utf8Cpp</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4dde02852aac16abd539dbded629e9998dd4edb" translate="yes" xml:space="preserve">
          <source>Assimp - Zip</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e8a2bd344bcf92d34624bc7673a63aeb0c3ece2" translate="yes" xml:space="preserve">
          <source>Assimp - irrXML</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe44901d3bb48248baddb52f33974b44b131d01c" translate="yes" xml:space="preserve">
          <source>Assistive Technology Service Provider Interface</source>
          <target state="translated">보조 기술 서비스 제공 업체 인터페이스</target>
        </trans-unit>
        <trans-unit id="83c5bb632378d9c2fcefdedcba306f845e8efe44" translate="yes" xml:space="preserve">
          <source>Associated Qt3D Parameter name</source>
          <target state="translated">연관된 Qt3D 파라미터 이름</target>
        </trans-unit>
        <trans-unit id="83c5dd7e4ceeb38ad79d04c309dadb647f04f85e" translate="yes" xml:space="preserve">
          <source>Associates a</source>
          <target state="translated">준회원</target>
        </trans-unit>
        <trans-unit id="66c50dde1a468384df54a6cda924049d4d67b444" translate="yes" xml:space="preserve">
          <source>Associates the given</source>
          <target state="translated">주어진 것을 연결합니다</target>
        </trans-unit>
        <trans-unit id="fe9c8d18acae9577e029d79bdb190db244e987ff" translate="yes" xml:space="preserve">
          <source>Associates the popup menu</source>
          <target state="translated">팝업 메뉴를 연결합니다</target>
        </trans-unit>
        <trans-unit id="6a7b362251b812ae9dbb2c734bd5e1e55a8a99e1" translate="yes" xml:space="preserve">
          <source>Associates the value of the aliased property with the provided</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d01cbf9779fefe47bf398cb7040be666a375d1d1" translate="yes" xml:space="preserve">
          <source>Associates the value of the aliased property with the provided functor</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a76c59646355bcc039f1455f930e3ae235b938a5" translate="yes" xml:space="preserve">
          <source>Associates the value of this property with the provided</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d629b4888156f72a74dc84613bb89f7cd0a60e3" translate="yes" xml:space="preserve">
          <source>Associates the value of this property with the provided functor</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b3f4788cf3d3e7c514a41891b9b613c5b1e8115" translate="yes" xml:space="preserve">
          <source>Associates this window with the specified Vulkan</source>
          <target state="translated">이 창을 지정된 Vulkan과 연관시킵니다.</target>
        </trans-unit>
        <trans-unit id="50e08a8fa61e0245e63654f3b4aea82400a2928e" translate="yes" xml:space="preserve">
          <source>Assume nothing about the pipelines and dynamic states bound on the command list/buffer when this function is called.</source>
          <target state="translated">이 함수가 호출 될 때 명령 목록 / 버퍼에 바인딩 된 파이프 라인 및 동적 상태에 대해 아무 것도 가정하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="cd2a119710b8aac523a3a56655ddf1934612958a" translate="yes" xml:space="preserve">
          <source>Assume that you wanted to model a set of mutually exclusive properties of a car in a single state machine. Let's say the properties we are interested in are Clean vs Dirty, and Moving vs Not moving. It would take four mutually exclusive states and eight transitions to be able to represent and freely move between all possible combinations.</source>
          <target state="translated">단일 상태 머신에서 자동차의 상호 배타적 인 특성 세트를 모델링하려고한다고 가정하십시오. 우리가 관심있는 속성은 Clean vs Dirty, Moving vs Not moving라고 가정 해 봅시다. 가능한 모든 조합을 표현하고 자유롭게 이동할 수 있으려면 4 개의 상호 배타적 인 상태와 8 개의 전환이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="0afa1db70d14b16989ef6ff8bb02424bc2d3db32" translate="yes" xml:space="preserve">
          <source>Assume that you wanted to model a set of mutually exclusive properties of a car in a single state machine. Let's say the properties we are interested in are Clean vs Dirty, and Moving vs Not moving. It would take four mutually exclusive states and eight transitions to represent the states and freely move between all possible combinations as shown in the following state chart.</source>
          <target state="translated">단일 상태 머신에서 자동차의 상호 배타적 특성 세트를 모델링하려고한다고 가정하십시오. 우리가 관심있는 속성은 Clean vs Dirty, Moving vs Not moving라고 가정 해 봅시다. 상태를 나타내고 다음 상태 차트에 표시된대로 가능한 모든 조합간에 자유롭게 이동하려면 4 개의 상호 배타적 상태와 8 개의 전환이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="c90ff00b401683da81cdb675dce198cdea833664" translate="yes" xml:space="preserve">
          <source>Assume the existence (and prior registration into the &quot;Qt.example 1.0&quot; namespace) of the following C++ type:</source>
          <target state="translated">다음 C ++ 유형의 존재 (및 &quot;Qt.example 1.0&quot;네임 스페이스에 사전 등록)를 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="da5d7a725c4de440164391d5ffc9b7460b944284" translate="yes" xml:space="preserve">
          <source>Assume the existence (and prior registration into the &quot;Qt.example&quot; namespace) of the following C++ type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f9904dd4cef57f901996862e1f031d1d41fac12" translate="yes" xml:space="preserve">
          <source>Assume the screen has a resolution of 96 DPI rather than using the OS-provided resolution. This will cause font rendering to be consistent in pixels-per-point across devices rather than defining 1 point as 1/72 inch.</source>
          <target state="translated">화면에 OS 제공 해상도를 사용하지 않고 96 DPI의 해상도가 있다고 가정하십시오. 이로 인해 1 포인트를 1/72 인치로 정의하지 않고 디바이스에서 포인트 당 픽셀 단위로 글꼴 렌더링이 일관되게됩니다.</target>
        </trans-unit>
        <trans-unit id="0fd4906cbc89602fa42eafbae11f6af6a69ccf24" translate="yes" xml:space="preserve">
          <source>Assume we wanted the user to be able to quit the application at any time by clicking a Quit button. In order to achieve this, we need to create a final state and make it the target of a transition associated with the Quit button's</source>
          <target state="translated">사용자가 종료 버튼을 클릭하여 언제든지 응용 프로그램을 종료 할 수 있기를 원한다고 가정합니다. 이를 위해서는 최종 상태를 생성하고 Quit 버튼과 관련된 전환 대상으로 만들어야합니다.</target>
        </trans-unit>
        <trans-unit id="851c2f1306ef9513fb28142d28a415cadad31fae" translate="yes" xml:space="preserve">
          <source>Assume we wanted the user to be able to quit the application at any time by clicking a Quit button. In order to achieve this, we need to create a final state and make it the target of a transition associated with the Quit button's &lt;a href=&quot;qabstractbutton#clicked&quot;&gt;clicked()&lt;/a&gt; signal. We could add a transition from each of &lt;code&gt;s1&lt;/code&gt;, &lt;code&gt;s2&lt;/code&gt; and &lt;code&gt;s3&lt;/code&gt;; however, this seems redundant, and one would also have to remember to add such a transition from every new state that is added in the future.</source>
          <target state="translated">사용자가 종료 버튼을 클릭하여 언제든지 응용 프로그램을 종료 할 수 있기를 원한다고 가정합니다. 이를 위해서는 최종 상태를 만들어 Quit 버튼의 &lt;a href=&quot;qabstractbutton#clicked&quot;&gt;clicked ()&lt;/a&gt; 신호 와 관련된 전환 대상으로 만들어야합니다 . &lt;code&gt;s1&lt;/code&gt; , &lt;code&gt;s2&lt;/code&gt; 및 &lt;code&gt;s3&lt;/code&gt; 각각에서 전환을 추가 할 수 있습니다 . 그러나 이것은 중복되는 것처럼 보이고 미래에 추가되는 모든 새로운 상태에서 그러한 전환을 추가해야한다는 것을 기억해야합니다.</target>
        </trans-unit>
        <trans-unit id="7916f28ff08f4e480a5afca8d1bd7571dfa918ce" translate="yes" xml:space="preserve">
          <source>Assumes the command is to be to sent back in reply to itself to the backend node.</source>
          <target state="translated">명령이 자신에게 응답하여 백엔드 노드로 다시 보내 져야한다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="4ff2031d476ca68024442f42c24527548b5dc499" translate="yes" xml:space="preserve">
          <source>Assuming a Qt3DCore::Node needs to override the PropertyTrackingMode on two properties (enabled and displacement), the value should be set as shown below.</source>
          <target state="translated">Qt3DCore :: Node가 두 속성 (활성화 및 변위)에서 PropertyTrackingMode를 재정의해야한다고 가정하면 값은 아래와 같이 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="7b610154aa909ee49cffb67df60a04f72dbae7fa" translate="yes" xml:space="preserve">
          <source>Assuming a test has the following data:</source>
          <target state="translated">테스트에 다음과 같은 데이터가 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="ff43a68f140b51cad42d7e0c95e2d0bab6c68162" translate="yes" xml:space="preserve">
          <source>Assuming that red channel value 1.0 is fully red (0.0 having no red at all), this effect considers pixel component value 0.5 to cause no displacement at all. Values above 0.5 shift pixels to the left, values below 0.5 do the shift to the right. In a similar way, green channel values above 0.5 displace the pixels upwards, and values below 0.5 shift the pixels downwards. The actual amount of displacement in pixels depends on the &lt;a href=&quot;qml-qtgraphicaleffects-displace#displacement-prop&quot;&gt;displacement&lt;/a&gt; property.</source>
          <target state="translated">적색 채널 값 1.0이 완전히 적색이라고 가정하면 (0.0은 전혀 적색이 없음)이 효과는 픽셀 성분 값 0.5를 고려하여 변위가 전혀 발생하지 않도록합니다. 0.5보다 큰 값은 픽셀을 왼쪽으로 이동하고 0.5보다 작은 값은 오른쪽으로 이동합니다. 비슷한 방식으로 0.5보다 큰 녹색 채널 값은 픽셀을 위쪽으로 이동시키고 0.5 미만의 값은 픽셀을 아래쪽으로 이동시킵니다. 픽셀 단위의 실제 변위량은 &lt;a href=&quot;qml-qtgraphicaleffects-displace#displacement-prop&quot;&gt;변위&lt;/a&gt; 특성 에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="e1bf7fc148321e0e237a7bfa56cd2b15579f2f5b" translate="yes" xml:space="preserve">
          <source>Assuming that the &lt;code&gt;a&lt;/code&gt; variable does not exist in the scope chain, the following code is illegal in QML:</source>
          <target state="translated">한다고 가정 변수가 범위 체인에 존재하지 않는, 다음 코드는 QML에서 불법입니다 : &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2def80cafe7c0980ddfcdfba4b78ad5447b0122d" translate="yes" xml:space="preserve">
          <source>Assuming the z values of both items are the same, this will cause</source>
          <target state="translated">두 항목의 z 값이 같다고 가정하면</target>
        </trans-unit>
        <trans-unit id="f329190d0fd15344dac730aabc63c032720e1284" translate="yes" xml:space="preserve">
          <source>Asterisk</source>
          <target state="translated">Asterisk</target>
        </trans-unit>
        <trans-unit id="3d7fac7964f752248f02c5aa61c85fd417dcfbcf" translate="yes" xml:space="preserve">
          <source>Asynchronous</source>
          <target state="translated">Asynchronous</target>
        </trans-unit>
        <trans-unit id="e75be76667be17954eee5355523c5fda27d028e3" translate="yes" xml:space="preserve">
          <source>Asynchronous (default) The creation occurs asynchronously, assuming a QQmlIncubatorController is set on the &lt;a href=&quot;qqmlengine&quot;&gt;QQmlEngine&lt;/a&gt;.</source>
          <target state="translated">비동기 (기본값)은 생성 된 설정 QQmlIncubatorController 가정 비동기 발생 &lt;a href=&quot;qqmlengine&quot;&gt;QQmlEngine&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c1dd52824822a5030bc87301e39aee35067fc4b2" translate="yes" xml:space="preserve">
          <source>Asynchronous Image Loading</source>
          <target state="translated">비동기 이미지 로딩</target>
        </trans-unit>
        <trans-unit id="762cc12f68657e49265d45e6f2f7caab006a5bc3" translate="yes" xml:space="preserve">
          <source>Asynchronous Interface</source>
          <target state="translated">비동기 인터페이스</target>
        </trans-unit>
        <trans-unit id="8a319250e7a62a6449653025f2ab2f88895ac77d" translate="yes" xml:space="preserve">
          <source>Asynchronous Loading</source>
          <target state="translated">비동기식 로딩</target>
        </trans-unit>
        <trans-unit id="bc275ca923ec281351bd9fe315bfe5269d968893" translate="yes" xml:space="preserve">
          <source>Asynchronous Slots</source>
          <target state="translated">비동기식 슬롯</target>
        </trans-unit>
        <trans-unit id="dac38cf1bc068ff6173e6dd303016d2512deaa69" translate="yes" xml:space="preserve">
          <source>Asynchronous image loading for providers of type other than &lt;a href=&quot;qqmlimageproviderbase#ImageType-enum&quot;&gt;ImageResponse&lt;/a&gt; are executed on a single thread per engine basis. That means that a slow image provider will block the loading of any other request. To avoid that we suggest using &lt;a href=&quot;qquickasyncimageprovider&quot;&gt;QQuickAsyncImageProvider&lt;/a&gt; and implement threading on the provider side via a &lt;code&gt;QThreadPool&lt;/code&gt; or similar. See the &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtquick-imageresponseprovider-example.html#&quot;&gt;Image Response Provider Example&lt;/a&gt; for a complete implementation.</source>
          <target state="translated">&lt;a href=&quot;qqmlimageproviderbase#ImageType-enum&quot;&gt;ImageResponse&lt;/a&gt; 이외의 유형의 공급자에 대한 비동기 이미지로드 는 엔진별로 단일 스레드로 실행됩니다. 즉, 느린 이미지 공급자는 다른 요청의로드를 차단합니다. 이를 피하기 위해 &lt;a href=&quot;qquickasyncimageprovider&quot;&gt;QQuickAsyncImageProvider를&lt;/a&gt; 사용 하고 &lt;code&gt;QThreadPool&lt;/code&gt; 또는 이와 유사한 것을 통해 공급자 측에서 스레딩을 구현 하는 것이 좋습니다 . 완전한 구현에 대해서는 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtquick-imageresponseprovider-example.html#&quot;&gt;이미지 응답 제공자 예제&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="80050f2c1d2542358e96b4fe829fa054d4d7e021" translate="yes" xml:space="preserve">
          <source>Asynchronous image loading for providers of type other than &lt;a href=&quot;qqmlimageproviderbase#ImageType-enum&quot;&gt;ImageResponse&lt;/a&gt; are executed on a single thread per engine basis. That means that a slow image provider will block the loading of any other request. To avoid that we suggest using &lt;a href=&quot;qquickasyncimageprovider&quot;&gt;QQuickAsyncImageProvider&lt;/a&gt; and implement threading on the provider side via a &lt;code&gt;QThreadPool&lt;/code&gt; or similar. See the &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtquick-imageresponseprovider-example.html&quot;&gt;Image Response Provider Example&lt;/a&gt; for a complete implementation.</source>
          <target state="translated">&lt;a href=&quot;qqmlimageproviderbase#ImageType-enum&quot;&gt;ImageResponse&lt;/a&gt; 가 아닌 유형의 공급자에 대한 비동기 이미지로드 는 엔진 당 단일 스레드에서 실행됩니다. 즉, 느린 이미지 공급자는 다른 요청의로드를 차단합니다. 이를 방지하려면 &lt;a href=&quot;qquickasyncimageprovider&quot;&gt;QQuickAsyncImageProvider를&lt;/a&gt; 사용 하고 &lt;code&gt;QThreadPool&lt;/code&gt; 또는 이와 유사한 것을 통해 공급자 측에서 스레딩을 구현 하는 것이 좋습니다 . 전체 구현 은 &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtquick-imageresponseprovider-example.html&quot;&gt;이미지 응답 공급자 예제&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2d33bb80737767108e98e576ffd09f9f1dcc5266" translate="yes" xml:space="preserve">
          <source>Asynchronous image loading for providers of type other than &lt;a href=&quot;qqmlimageproviderbase#ImageType-enum&quot;&gt;ImageResponse&lt;/a&gt; are executed on a single thread per engine basis. That means that a slow image provider will block the loading of any other request. To avoid that we suggest using &lt;a href=&quot;qquickasyncimageprovider&quot;&gt;QQuickAsyncImageProvider&lt;/a&gt; and implement threading on the provider side via a &lt;code&gt;QThreadPool&lt;/code&gt; or similar. See the &lt;a href=&quot;https://doc.qt.io/qt-6.0/qtquick-imageresponseprovider-example.html&quot;&gt;Image Response Provider Example&lt;/a&gt; for a complete implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e95084984f1824fd6686f2858d97d77b54112d4d" translate="yes" xml:space="preserve">
          <source>Asynchronous incubators are controlled by a &lt;a href=&quot;qqmlincubationcontroller&quot;&gt;QQmlIncubationController&lt;/a&gt; that is set on the &lt;a href=&quot;qqmlengine&quot;&gt;QQmlEngine&lt;/a&gt;, which lets the engine know when the application is idle and incubating objects should be processed. If an incubation controller is not set on the &lt;a href=&quot;qqmlengine&quot;&gt;QQmlEngine&lt;/a&gt;, &lt;a href=&quot;qqmlincubator&quot;&gt;QQmlIncubator&lt;/a&gt; creates objects synchronously regardless of the specified &lt;a href=&quot;qqmlincubator#IncubationMode-enum&quot;&gt;IncubationMode&lt;/a&gt;.</source>
          <target state="translated">비동기 인큐베이터는에 의해 제어되는 &lt;a href=&quot;qqmlincubationcontroller&quot;&gt;QQmlIncubationController&lt;/a&gt; 온 설정 &lt;a href=&quot;qqmlengine&quot;&gt;QQmlEngine&lt;/a&gt; 응용 프로그램이 유휴 상태와 배양 개체를 처리해야 할 때 엔진 노하우를 할 수 있습니다. 인큐베이션 컨트롤러가 설정되어 있지 않은 경우 &lt;a href=&quot;qqmlengine&quot;&gt;QQmlEngine&lt;/a&gt; , &lt;a href=&quot;qqmlincubator&quot;&gt;QQmlIncubator는&lt;/a&gt; 동기 관계없이 특정의 객체를 생성 &lt;a href=&quot;qqmlincubator#IncubationMode-enum&quot;&gt;IncubationMode&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f828b831a262462f1e5c828272439e66a931b817" translate="yes" xml:space="preserve">
          <source>Asynchronous incubators are controlled by a &lt;a href=&quot;qqmlincubationcontroller&quot;&gt;QQmlIncubationController&lt;/a&gt; that is set on the &lt;a href=&quot;qqmlengine&quot;&gt;QQmlEngine&lt;/a&gt;, which lets the engine know when the application is idle and incubating objects should be processed. If an incubation controller is not set on the &lt;a href=&quot;qqmlengine&quot;&gt;QQmlEngine&lt;/a&gt;, QQmlIncubator creates objects synchronously regardless of the specified &lt;a href=&quot;qqmlincubator#IncubationMode-enum&quot;&gt;IncubationMode&lt;/a&gt;.</source>
          <target state="translated">비동기 인큐베이터는에 의해 제어되는 &lt;a href=&quot;qqmlincubationcontroller&quot;&gt;QQmlIncubationController&lt;/a&gt; 온 설정 &lt;a href=&quot;qqmlengine&quot;&gt;QQmlEngine&lt;/a&gt; 응용 프로그램이 유휴 상태와 배양 개체를 처리해야 할 때 엔진 노하우를 할 수 있습니다. &lt;a href=&quot;qqmlengine&quot;&gt;QQmlEngine&lt;/a&gt; 에 인큐베이션 컨트롤러가 설정되어 있지 않으면 QQmlIncubator 는 지정된 &lt;a href=&quot;qqmlincubator#IncubationMode-enum&quot;&gt;IncubationMode에&lt;/a&gt; 관계없이 동 기적으로 개체를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="d7e47f6482fe4592a09b00832e19487c245576e5" translate="yes" xml:space="preserve">
          <source>Asynchronous loading for image providers that provide &lt;a href=&quot;qpixmap&quot;&gt;QPixmap&lt;/a&gt; is only supported in platforms that have the ThreadedPixmaps feature, in platforms where pixmaps can only be created in the main thread (i.e. ThreadedPixmaps is not supported) if &lt;a href=&quot;qml-qtquick-image#asynchronous-prop&quot;&gt;asynchronous&lt;/a&gt; is set to &lt;code&gt;true&lt;/code&gt;, the value is ignored and the image is loaded synchronously.</source>
          <target state="translated">&lt;a href=&quot;qpixmap&quot;&gt;QPixmap&lt;/a&gt; 을 제공하는 이미지 제공자에 대한 비동기 로딩 은 ThreadedPixmaps 기능이있는 플랫폼에서만 지원됩니다. &lt;a href=&quot;qml-qtquick-image#asynchronous-prop&quot;&gt;비동기식&lt;/a&gt; 이 &lt;code&gt;true&lt;/code&gt; 로 설정된 경우 픽스맵이 기본 스레드에서만 생성 될 수있는 플랫폼 (예 : ThreadedPixmaps가 지원되지 않는 플랫폼) 에서는 값이 무시되고 값이 무시됩니다. 이미지가 동 기적으로로드됩니다.</target>
        </trans-unit>
        <trans-unit id="8815a86ce7e19dae036dc727fc0eb17010cfec26" translate="yes" xml:space="preserve">
          <source>Asynchronous method to retrieve the page's content as HTML, enclosed in HTML and BODY tags. Upon successful completion,</source>
          <target state="translated">HTML 및 BODY 태그로 묶여 페이지 컨텐츠를 HTML로 검색하는 비동기 메소드입니다. 성공적으로 완료되면</target>
        </trans-unit>
        <trans-unit id="fed3108d6db768b79d5656a5db689618d8813893" translate="yes" xml:space="preserve">
          <source>Asynchronous method to retrieve the page's content converted to plain text, completely stripped of all HTML formatting. Upon successful completion,</source>
          <target state="translated">모든 HTML 형식이 완전히 제거 된 일반 텍스트로 변환 된 페이지 컨텐츠를 검색하는 비동기 메소드입니다. 성공적으로 완료되면</target>
        </trans-unit>
        <trans-unit id="ccfb9e9f12588a472c278960afe69aa2f3e59056" translate="yes" xml:space="preserve">
          <source>Asynchronous slots are marked by the keyword &lt;a href=&quot;qdbusabstractadaptor#Q_NOREPLY&quot;&gt;Q_NOREPLY&lt;/a&gt; in the method signature, before the &lt;code&gt;void&lt;/code&gt; return type and the slot name. The &lt;code&gt;quit()&lt;/code&gt; slot in the &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtdbus-complexpingpong-example.html#&quot;&gt;D-Bus Complex Ping Pong Example&lt;/a&gt; is an example of this.</source>
          <target state="translated">&lt;code&gt;void&lt;/code&gt; 슬롯 은 void 서명 유형과 슬롯 이름 앞에 메소드 서명에서 키워드 &lt;a href=&quot;qdbusabstractadaptor#Q_NOREPLY&quot;&gt;Q_NOREPLY&lt;/a&gt; 로 표시됩니다 . &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtdbus-complexpingpong-example.html#&quot;&gt;D- 버스 복합 탁구 예제&lt;/a&gt; 의 &lt;code&gt;quit()&lt;/code&gt; 슬롯 이 이에 대한 예입니다.</target>
        </trans-unit>
        <trans-unit id="71a271550f3a30be9911da1442e7d3755ce8535f" translate="yes" xml:space="preserve">
          <source>Asynchronous slots are marked by the keyword &lt;a href=&quot;qdbusabstractadaptor#Q_NOREPLY&quot;&gt;Q_NOREPLY&lt;/a&gt; in the method signature, before the &lt;code&gt;void&lt;/code&gt; return type and the slot name. The &lt;code&gt;quit()&lt;/code&gt; slot in the &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtdbus-complexpingpong-example.html&quot;&gt;D-Bus Complex Ping Pong Example&lt;/a&gt; is an example of this.</source>
          <target state="translated">비동기 슬롯은 &lt;code&gt;void&lt;/code&gt; 리턴 유형 및 슬롯 이름 앞에 메소드 서명에서 키워드 &lt;a href=&quot;qdbusabstractadaptor#Q_NOREPLY&quot;&gt;Q_NOREPLY&lt;/a&gt; 로 표시됩니다 . &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtdbus-complexpingpong-example.html&quot;&gt;D-Bus Complex Ping Pong 예제&lt;/a&gt; 의 &lt;code&gt;quit()&lt;/code&gt; 슬롯 이 이에 대한 예입니다.</target>
        </trans-unit>
        <trans-unit id="197d9f9f02176a6f23baa00e260050dfa34a3b51" translate="yes" xml:space="preserve">
          <source>Asynchronous slots are marked by the keyword &lt;a href=&quot;qdbusabstractadaptor#Q_NOREPLY&quot;&gt;Q_NOREPLY&lt;/a&gt; in the method signature, before the &lt;code&gt;void&lt;/code&gt; return type and the slot name. The &lt;code&gt;quit()&lt;/code&gt; slot in the &lt;a href=&quot;https://doc.qt.io/qt-6.0/qtdbus-complexpingpong-example.html&quot;&gt;D-Bus Complex Ping Pong Example&lt;/a&gt; is an example of this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad1320a3c8bebbef00d6eebcda7cf893e0add4b9" translate="yes" xml:space="preserve">
          <source>Asynchronous slots are those that do not normally return any reply to the caller. For that reason, they cannot take any output parameters. In most cases, by the time the first line of the slot is run, the caller function has already resumed working.</source>
          <target state="translated">비동기 슬롯은 일반적으로 발신자에게 응답을 반환하지 않는 슬롯입니다. 따라서 출력 매개 변수를 사용할 수 없습니다. 대부분의 경우 슬롯의 첫 번째 라인이 실행될 때마다 호출자 기능이 이미 작동을 재개했습니다.</target>
        </trans-unit>
        <trans-unit id="bf15448916e4418ca84783919398ce5d3bdf56e4" translate="yes" xml:space="preserve">
          <source>Asynchronously requests</source>
          <target state="translated">비동기 적으로 요청</target>
        </trans-unit>
        <trans-unit id="2c1db523efbfd096c7daa87bbf851934bc848638" translate="yes" xml:space="preserve">
          <source>At a high level, you can choose to use a &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; type directly as a source; or you can define the desired API in a &lt;code&gt;.rep&lt;/code&gt; template for use with the &lt;a href=&quot;qtremoteobjects-repc&quot;&gt;repc&lt;/a&gt; compiler.</source>
          <target state="translated">높은 수준에서 &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 유형을 소스로 직접 사용하도록 선택할 수 있습니다 . 또는 &lt;a href=&quot;qtremoteobjects-repc&quot;&gt;repc&lt;/a&gt; 컴파일러 와 함께 사용하기 위해 &lt;code&gt;.rep&lt;/code&gt; 템플릿 에서 원하는 API를 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c9f0075e5c85468a56b797c1d1e50667af529bf8" translate="yes" xml:space="preserve">
          <source>At a high level, you have a choice of using a &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; type directly as a source or defining the desired API in a .rep template for use with the &lt;a href=&quot;qtremoteobjects-repc#&quot;&gt;repc&lt;/a&gt; compiler.</source>
          <target state="translated">높은 수준에서, &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 유형을 소스로 직접 사용 하거나 &lt;a href=&quot;qtremoteobjects-repc#&quot;&gt;repc&lt;/a&gt; 컴파일러 와 함께 사용할 .rep 템플리트에서 원하는 API를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="42809e8d1678586fe4c28a5bfba7143493cf53de" translate="yes" xml:space="preserve">
          <source>At any given time, the &lt;a href=&quot;qaudiooutput&quot;&gt;QAudioOutput&lt;/a&gt; will be in one of four states: active, suspended, stopped, or idle. These states are described by the &lt;a href=&quot;qaudio#State-enum&quot;&gt;QAudio::State&lt;/a&gt; enum. State changes are reported through the &lt;a href=&quot;qaudiooutput#stateChanged&quot;&gt;stateChanged&lt;/a&gt;() signal. You can use this signal to, for instance, update the GUI of the application; the mundane example here being changing the state of a &lt;code&gt;play/pause&lt;/code&gt; button. You request a state change directly with &lt;a href=&quot;qaudiooutput#suspend&quot;&gt;suspend&lt;/a&gt;(), &lt;a href=&quot;qaudiooutput#stop&quot;&gt;stop&lt;/a&gt;(), &lt;a href=&quot;qaudiooutput#reset&quot;&gt;reset&lt;/a&gt;(), &lt;a href=&quot;qaudiooutput#resume&quot;&gt;resume&lt;/a&gt;(), and &lt;a href=&quot;qaudiooutput#start-1&quot;&gt;start&lt;/a&gt;().</source>
          <target state="translated">주어진 시간에 &lt;a href=&quot;qaudiooutput&quot;&gt;QAudioOutput&lt;/a&gt; 은 활성, 일시 중지, 중지 또는 유휴 상태의 4 가지 상태 중 하나입니다. 이 상태는 &lt;a href=&quot;qaudio#State-enum&quot;&gt;QAudio :: State&lt;/a&gt; 열거 형으로 설명됩니다 . 상태 변경은 &lt;a href=&quot;qaudiooutput#stateChanged&quot;&gt;stateChanged&lt;/a&gt; () 신호를 통해보고됩니다 . 예를 들어이 신호를 사용하여 응용 프로그램의 GUI를 업데이트 할 수 있습니다. 여기서 일반적인 예는 &lt;code&gt;play/pause&lt;/code&gt; 버튼 의 상태를 변경하는 것 입니다. &lt;a href=&quot;qaudiooutput#suspend&quot;&gt;일시 중단&lt;/a&gt; (), &lt;a href=&quot;qaudiooutput#stop&quot;&gt;중지&lt;/a&gt; (), &lt;a href=&quot;qaudiooutput#reset&quot;&gt;재설정&lt;/a&gt; (), &lt;a href=&quot;qaudiooutput#resume&quot;&gt;재개&lt;/a&gt; () 및 &lt;a href=&quot;qaudiooutput#start-1&quot;&gt;시작&lt;/a&gt; () 으로 상태 변경을 직접 요청합니다 .</target>
        </trans-unit>
        <trans-unit id="6e90abb23ba90e7991de19e51635a45f8d604895" translate="yes" xml:space="preserve">
          <source>At any given time, the QAudioOutput will be in one of four states: active, suspended, stopped, or idle. These states are described by the &lt;a href=&quot;qaudio#State-enum&quot;&gt;QAudio::State&lt;/a&gt; enum. State changes are reported through the &lt;a href=&quot;qaudiooutput#stateChanged&quot;&gt;stateChanged&lt;/a&gt;() signal. You can use this signal to, for instance, update the GUI of the application; the mundane example here being changing the state of a &lt;code&gt;play/pause&lt;/code&gt; button. You request a state change directly with &lt;a href=&quot;qaudiooutput#suspend&quot;&gt;suspend&lt;/a&gt;(), &lt;a href=&quot;qaudiooutput#stop&quot;&gt;stop&lt;/a&gt;(), &lt;a href=&quot;qaudiooutput#reset&quot;&gt;reset&lt;/a&gt;(), &lt;a href=&quot;qaudiooutput#resume&quot;&gt;resume&lt;/a&gt;(), and &lt;a href=&quot;qaudiooutput#start-1&quot;&gt;start&lt;/a&gt;().</source>
          <target state="translated">주어진 시간에 QAudioOutput은 활성, 일시 중지, 중지 또는 유휴의 네 가지 상태 중 하나입니다. 이러한 상태는 &lt;a href=&quot;qaudio#State-enum&quot;&gt;QAudio :: State&lt;/a&gt; 열거 형으로 설명됩니다 . 상태 변경은 &lt;a href=&quot;qaudiooutput#stateChanged&quot;&gt;stateChanged&lt;/a&gt; () 신호를 통해보고됩니다 . 예를 들어,이 신호를 사용하여 애플리케이션의 GUI를 업데이트 할 수 있습니다. &lt;code&gt;play/pause&lt;/code&gt; 버튼 의 상태를 변경하는 일반적인 예 입니다. &lt;a href=&quot;qaudiooutput#suspend&quot;&gt;suspend&lt;/a&gt; (), &lt;a href=&quot;qaudiooutput#stop&quot;&gt;stop&lt;/a&gt; (), &lt;a href=&quot;qaudiooutput#reset&quot;&gt;reset&lt;/a&gt; (), &lt;a href=&quot;qaudiooutput#resume&quot;&gt;resume&lt;/a&gt; () 및 &lt;a href=&quot;qaudiooutput#start-1&quot;&gt;start&lt;/a&gt; ()를 사용 하여 직접 상태 변경을 요청합니다 .</target>
        </trans-unit>
        <trans-unit id="d66f5a534a2f4e46e7b9aa796d01cd6db3d5263b" translate="yes" xml:space="preserve">
          <source>At any point an animation is in one of three states: &lt;a href=&quot;qabstractanimation#State-enum&quot;&gt;Running&lt;/a&gt;, &lt;a href=&quot;qabstractanimation#State-enum&quot;&gt;Stopped&lt;/a&gt;, or &lt;a href=&quot;qabstractanimation#State-enum&quot;&gt;Paused&lt;/a&gt;--as defined by the &lt;a href=&quot;qabstractanimation#State-enum&quot;&gt;State&lt;/a&gt; enum. The current state can be changed by calling &lt;a href=&quot;qabstractanimation#start&quot;&gt;start&lt;/a&gt;(), &lt;a href=&quot;qabstractanimation#stop&quot;&gt;stop&lt;/a&gt;(), &lt;a href=&quot;qabstractanimation#pause&quot;&gt;pause&lt;/a&gt;(), or &lt;a href=&quot;qabstractanimation#resume&quot;&gt;resume&lt;/a&gt;(). An animation will always reset its &lt;a href=&quot;qabstractanimation#currentTime-prop&quot;&gt;current time&lt;/a&gt; when it is started. If paused, it will continue with the same current time when resumed. When an animation is stopped, it cannot be resumed, but will keep its current time (until started again). &lt;a href=&quot;qabstractanimation&quot;&gt;QAbstractAnimation&lt;/a&gt; will emit &lt;a href=&quot;qabstractanimation#stateChanged&quot;&gt;stateChanged&lt;/a&gt;() whenever its state changes.</source>
          <target state="translated">언제든 애니메이션은 &lt;a href=&quot;qabstractanimation#State-enum&quot;&gt;State&lt;/a&gt; 열거 형에 의해 정의 된 &lt;a href=&quot;qabstractanimation#State-enum&quot;&gt;Running&lt;/a&gt; , &lt;a href=&quot;qabstractanimation#State-enum&quot;&gt;Stopped&lt;/a&gt; 또는 &lt;a href=&quot;qabstractanimation#State-enum&quot;&gt;Paused&lt;/a&gt; 의 3 가지 상태 중 하나입니다 . &lt;a href=&quot;qabstractanimation#start&quot;&gt;start&lt;/a&gt; (), &lt;a href=&quot;qabstractanimation#stop&quot;&gt;stop&lt;/a&gt; (), &lt;a href=&quot;qabstractanimation#pause&quot;&gt;pause&lt;/a&gt; () 또는 &lt;a href=&quot;qabstractanimation#resume&quot;&gt;resume&lt;/a&gt; () 을 호출하여 현재 상태를 변경할 수 있습니다 . 애니메이션 은 시작될 때 항상 &lt;a href=&quot;qabstractanimation#currentTime-prop&quot;&gt;현재 시간을&lt;/a&gt; 재설정합니다 . 일시 중지하면 다시 시작할 때와 동일한 현재 시간으로 계속 진행됩니다. 애니메이션이 중지되면 다시 시작할 수 없지만 현재 시간을 유지합니다 (다시 시작할 때까지). &lt;a href=&quot;qabstractanimation&quot;&gt;QAbstractAnimation&lt;/a&gt; 은 상태가 변경 될 때마다 &lt;a href=&quot;qabstractanimation#stateChanged&quot;&gt;stateChanged&lt;/a&gt; () 를 방출 합니다.</target>
        </trans-unit>
        <trans-unit id="6b903ce82d0c2f440c5289b532cf6af5cd98f040" translate="yes" xml:space="preserve">
          <source>At any point an animation is in one of three states: &lt;a href=&quot;qabstractanimation#State-enum&quot;&gt;Running&lt;/a&gt;, &lt;a href=&quot;qabstractanimation#State-enum&quot;&gt;Stopped&lt;/a&gt;, or &lt;a href=&quot;qabstractanimation#State-enum&quot;&gt;Paused&lt;/a&gt;--as defined by the &lt;a href=&quot;qabstractanimation#State-enum&quot;&gt;State&lt;/a&gt; enum. The current state can be changed by calling &lt;a href=&quot;qabstractanimation#start&quot;&gt;start&lt;/a&gt;(), &lt;a href=&quot;qabstractanimation#stop&quot;&gt;stop&lt;/a&gt;(), &lt;a href=&quot;qabstractanimation#pause&quot;&gt;pause&lt;/a&gt;(), or &lt;a href=&quot;qabstractanimation#resume&quot;&gt;resume&lt;/a&gt;(). An animation will always reset its &lt;a href=&quot;qabstractanimation#currentTime-prop&quot;&gt;current time&lt;/a&gt; when it is started. If paused, it will continue with the same current time when resumed. When an animation is stopped, it cannot be resumed, but will keep its current time (until started again). QAbstractAnimation will emit &lt;a href=&quot;qabstractanimation#stateChanged&quot;&gt;stateChanged&lt;/a&gt;() whenever its state changes.</source>
          <target state="translated">애니메이션은 언제든지 &lt;a href=&quot;qabstractanimation#State-enum&quot;&gt;State&lt;/a&gt; 열거 형에 정의 된대로 &lt;a href=&quot;qabstractanimation#State-enum&quot;&gt;Running&lt;/a&gt; , &lt;a href=&quot;qabstractanimation#State-enum&quot;&gt;Stopped&lt;/a&gt; 또는 &lt;a href=&quot;qabstractanimation#State-enum&quot;&gt;Paused&lt;/a&gt; 의 세 가지 상태 중 하나입니다 . 현재 상태는 &lt;a href=&quot;qabstractanimation#start&quot;&gt;start&lt;/a&gt; (), &lt;a href=&quot;qabstractanimation#stop&quot;&gt;stop&lt;/a&gt; (), &lt;a href=&quot;qabstractanimation#pause&quot;&gt;pause&lt;/a&gt; () 또는 &lt;a href=&quot;qabstractanimation#resume&quot;&gt;resume&lt;/a&gt; () 을 호출하여 변경할 수 있습니다 . 애니메이션 은 시작될 때 항상 &lt;a href=&quot;qabstractanimation#currentTime-prop&quot;&gt;현재 시간을&lt;/a&gt; 재설정합니다 . 일시 중지 된 경우 다시 시작할 때 동일한 현재 시간으로 계속됩니다. 애니메이션이 중지되면 다시 시작할 수 없지만 다시 시작할 때까지 현재 시간을 유지합니다. QAbstractAnimation은 상태가 변경 될 때마다 &lt;a href=&quot;qabstractanimation#stateChanged&quot;&gt;stateChanged&lt;/a&gt; () 를 내 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="97fa7c27e90979774b3a888ca02475f0f53acae3" translate="yes" xml:space="preserve">
          <source>At any point in time, &lt;a href=&quot;qaudioinput&quot;&gt;QAudioInput&lt;/a&gt; will be in one of four states: active, suspended, stopped, or idle. These states are specified by the &lt;a href=&quot;qaudio#State-enum&quot;&gt;QAudio::State&lt;/a&gt; enum. You can request a state change directly through &lt;a href=&quot;qaudioinput#suspend&quot;&gt;suspend&lt;/a&gt;(), &lt;a href=&quot;qaudioinput#resume&quot;&gt;resume&lt;/a&gt;(), &lt;a href=&quot;qaudioinput#stop&quot;&gt;stop&lt;/a&gt;(), &lt;a href=&quot;qaudioinput#reset&quot;&gt;reset&lt;/a&gt;(), and &lt;a href=&quot;qaudioinput#start-1&quot;&gt;start&lt;/a&gt;(). The current state is reported by &lt;a href=&quot;qaudioinput#state&quot;&gt;state&lt;/a&gt;(). &lt;a href=&quot;qaudiooutput&quot;&gt;QAudioOutput&lt;/a&gt; will also signal you when the state changes (&lt;a href=&quot;qaudioinput#stateChanged&quot;&gt;stateChanged&lt;/a&gt;()).</source>
          <target state="translated">어느 시점 &lt;a href=&quot;qaudioinput&quot;&gt;에서든 QAudioInput&lt;/a&gt; 은 활성, 일시 중단, 중지 또는 유휴 상태의 4 가지 상태 중 하나입니다. 이 상태는 &lt;a href=&quot;qaudio#State-enum&quot;&gt;QAudio :: State&lt;/a&gt; 열거 형으로 지정됩니다 . &lt;a href=&quot;qaudioinput#suspend&quot;&gt;일시 중단&lt;/a&gt; (), &lt;a href=&quot;qaudioinput#resume&quot;&gt;다시 시작&lt;/a&gt; (), &lt;a href=&quot;qaudioinput#stop&quot;&gt;중지&lt;/a&gt; (), &lt;a href=&quot;qaudioinput#reset&quot;&gt;재설정&lt;/a&gt; () 및 &lt;a href=&quot;qaudioinput#start-1&quot;&gt;시작&lt;/a&gt; ()을 통해 상태 변경을 직접 요청할 수 있습니다 . 현재 상태는 &lt;a href=&quot;qaudioinput#state&quot;&gt;상태&lt;/a&gt; () 로보고됩니다 . &lt;a href=&quot;qaudiooutput&quot;&gt;QAudioOutput&lt;/a&gt; 은 상태가 변경 될 때도 알려줍니다 ( &lt;a href=&quot;qaudioinput#stateChanged&quot;&gt;stateChanged&lt;/a&gt; ()).</target>
        </trans-unit>
        <trans-unit id="5883099251f0f9c46f7b45e43b71f6cd4ada1809" translate="yes" xml:space="preserve">
          <source>At any point in time, QAudioInput will be in one of four states: active, suspended, stopped, or idle. These states are specified by the &lt;a href=&quot;qaudio#State-enum&quot;&gt;QAudio::State&lt;/a&gt; enum. You can request a state change directly through &lt;a href=&quot;qaudioinput#suspend&quot;&gt;suspend&lt;/a&gt;(), &lt;a href=&quot;qaudioinput#resume&quot;&gt;resume&lt;/a&gt;(), &lt;a href=&quot;qaudioinput#stop&quot;&gt;stop&lt;/a&gt;(), &lt;a href=&quot;qaudioinput#reset&quot;&gt;reset&lt;/a&gt;(), and &lt;a href=&quot;qaudioinput#start-1&quot;&gt;start&lt;/a&gt;(). The current state is reported by &lt;a href=&quot;qaudioinput#state&quot;&gt;state&lt;/a&gt;(). &lt;a href=&quot;qaudiooutput&quot;&gt;QAudioOutput&lt;/a&gt; will also signal you when the state changes (&lt;a href=&quot;qaudioinput#stateChanged&quot;&gt;stateChanged&lt;/a&gt;()).</source>
          <target state="translated">어느 시점에서든 QAudioInput은 활성, 일시 중지, 중지 또는 유휴의 네 가지 상태 중 하나입니다. 이러한 상태는 &lt;a href=&quot;qaudio#State-enum&quot;&gt;QAudio :: State&lt;/a&gt; 열거 형으로 지정됩니다 . &lt;a href=&quot;qaudioinput#suspend&quot;&gt;일시 중단&lt;/a&gt; (), &lt;a href=&quot;qaudioinput#resume&quot;&gt;재개&lt;/a&gt; (), &lt;a href=&quot;qaudioinput#stop&quot;&gt;중지&lt;/a&gt; (), &lt;a href=&quot;qaudioinput#reset&quot;&gt;재설정&lt;/a&gt; () 및 &lt;a href=&quot;qaudioinput#start-1&quot;&gt;시작&lt;/a&gt; ()을 통해 직접 상태 변경을 요청할 수 있습니다 . 현재 상태는 &lt;a href=&quot;qaudioinput#state&quot;&gt;상태&lt;/a&gt; () 로보고됩니다 . &lt;a href=&quot;qaudiooutput&quot;&gt;QAudioOutput&lt;/a&gt; 은 상태가 변경 될 때도 신호를 보냅니다 ( &lt;a href=&quot;qaudioinput#stateChanged&quot;&gt;stateChanged&lt;/a&gt; ()).</target>
        </trans-unit>
        <trans-unit id="3c3ff16dcc213816d038cd51ace782a20de40270" translate="yes" xml:space="preserve">
          <source>At any point, the socket can emit &lt;a href=&quot;qabstractsocket#error&quot;&gt;error&lt;/a&gt;() to signal that an error occurred.</source>
          <target state="translated">언제든지 소켓은 &lt;a href=&quot;qabstractsocket#error&quot;&gt;오류&lt;/a&gt; ()를 발생시켜 오류가 발생했음을 알릴 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f2d1dcef77ef62768ff6ce04ff4c52fee242295d" translate="yes" xml:space="preserve">
          <source>At any point, the socket can emit &lt;a href=&quot;qabstractsocket#errorOccurred&quot;&gt;errorOccurred&lt;/a&gt;() to signal that an error occurred.</source>
          <target state="translated">언제든지 소켓은 &lt;a href=&quot;qabstractsocket#errorOccurred&quot;&gt;errorOccurred&lt;/a&gt; ()를 생성하여 오류가 발생했음을 알릴 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="74d80312364e27da53be514c37db7c915d4f7418" translate="yes" xml:space="preserve">
          <source>At any point, the socket can emit &lt;a href=&quot;qbluetoothsocket#error&quot;&gt;error&lt;/a&gt;() to signal that an error occurred.</source>
          <target state="translated">언제든지 소켓은 &lt;a href=&quot;qbluetoothsocket#error&quot;&gt;오류&lt;/a&gt; ()를 발생시켜 오류가 발생했음을 알릴 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ea6ee628887c98ac2211a407c644d6029a495ab7" translate="yes" xml:space="preserve">
          <source>At any point, you can save your form by selecting the &lt;b&gt;Save From As...&lt;/b&gt; option from the &lt;b&gt;File&lt;/b&gt; menu. The UI files saved by</source>
          <target state="translated">언제든지 &lt;b&gt;파일&lt;/b&gt; 메뉴 &lt;b&gt;에서 다른 이름으로 저장 ...&lt;/b&gt; 옵션을 선택하여 양식을 저장할 수 있습니다. 저장 한 UI 파일&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="fc778a76703643c7e9afe57573b40700efc7e170" translate="yes" xml:space="preserve">
          <source>At any time, &lt;a href=&quot;qabstractsocket&quot;&gt;QAbstractSocket&lt;/a&gt; has a state (returned by &lt;a href=&quot;qabstractsocket#state&quot;&gt;state&lt;/a&gt;()). The initial state is &lt;a href=&quot;qabstractsocket#SocketState-enum&quot;&gt;UnconnectedState&lt;/a&gt;. After calling &lt;a href=&quot;qabstractsocket#connectToHost&quot;&gt;connectToHost&lt;/a&gt;(), the socket first enters &lt;a href=&quot;qabstractsocket#SocketState-enum&quot;&gt;HostLookupState&lt;/a&gt;. If the host is found, &lt;a href=&quot;qabstractsocket&quot;&gt;QAbstractSocket&lt;/a&gt; enters &lt;a href=&quot;qabstractsocket#SocketState-enum&quot;&gt;ConnectingState&lt;/a&gt; and emits the &lt;a href=&quot;qabstractsocket#hostFound&quot;&gt;hostFound&lt;/a&gt;() signal. When the connection has been established, it enters &lt;a href=&quot;qabstractsocket#SocketState-enum&quot;&gt;ConnectedState&lt;/a&gt; and emits &lt;a href=&quot;qabstractsocket#connected&quot;&gt;connected&lt;/a&gt;(). If an error occurs at any stage, &lt;a href=&quot;qabstractsocket#error&quot;&gt;error&lt;/a&gt;() is emitted. Whenever the state changes, &lt;a href=&quot;qabstractsocket#stateChanged&quot;&gt;stateChanged&lt;/a&gt;() is emitted. For convenience, &lt;a href=&quot;qabstractsocket#isValid&quot;&gt;isValid&lt;/a&gt;() returns &lt;code&gt;true&lt;/code&gt; if the socket is ready for reading and writing, but note that the socket's state must be &lt;a href=&quot;qabstractsocket#SocketState-enum&quot;&gt;ConnectedState&lt;/a&gt; before reading and writing can occur.</source>
          <target state="translated">언제든지 &lt;a href=&quot;qabstractsocket&quot;&gt;QAbstractSocket&lt;/a&gt; 은 상태 ( &lt;a href=&quot;qabstractsocket#state&quot;&gt;상태&lt;/a&gt; () 로 반환 됨)를 갖습니다 . 초기 상태는 &lt;a href=&quot;qabstractsocket#SocketState-enum&quot;&gt;UnconnectedState&lt;/a&gt; 입니다. &lt;a href=&quot;qabstractsocket#connectToHost&quot;&gt;connectToHost&lt;/a&gt; ()를 호출 한 후 소켓은 먼저 &lt;a href=&quot;qabstractsocket#SocketState-enum&quot;&gt;HostLookupState&lt;/a&gt; 로 들어 갑니다 . 호스트가 발견 된 경우, &lt;a href=&quot;qabstractsocket&quot;&gt;QAbstractSocket은&lt;/a&gt; 입사 &lt;a href=&quot;qabstractsocket#SocketState-enum&quot;&gt;ConnectingState를&lt;/a&gt; 상기 발광 &lt;a href=&quot;qabstractsocket#hostFound&quot;&gt;hostFound&lt;/a&gt; () 신호. 접속이 확립되면,이 입사 &lt;a href=&quot;qabstractsocket#SocketState-enum&quot;&gt;ConnectedState&lt;/a&gt; 및 방출한다은 &lt;a href=&quot;qabstractsocket#connected&quot;&gt;접속&lt;/a&gt; (). 어떤 단계에서든 오류가 발생하면 &lt;a href=&quot;qabstractsocket#error&quot;&gt;오류&lt;/a&gt; ()가 발생합니다. 상태가 변경 될 때마다 &lt;a href=&quot;qabstractsocket#stateChanged&quot;&gt;stateChanged&lt;/a&gt; ()가 생성됩니다. 편의상 &lt;a href=&quot;qabstractsocket#isValid&quot;&gt;isValid&lt;/a&gt; ()는 &lt;code&gt;true&lt;/code&gt; 소켓은 소켓의 상태가 있어야한다는 읽기와 쓰기,하지만 노트에 대한 준비가되어있는 경우 &lt;a href=&quot;qabstractsocket#SocketState-enum&quot;&gt;ConnectedState&lt;/a&gt; 읽기, 쓰기가 발생할 수 있습니다 전에.</target>
        </trans-unit>
        <trans-unit id="a07c559f9633c8aaacdd7f2a3b35af515bfb8f86" translate="yes" xml:space="preserve">
          <source>At any time, QAbstractSocket has a state (returned by &lt;a href=&quot;qabstractsocket#state&quot;&gt;state&lt;/a&gt;()). The initial state is &lt;a href=&quot;qabstractsocket#SocketState-enum&quot;&gt;UnconnectedState&lt;/a&gt;. After calling &lt;a href=&quot;qabstractsocket#connectToHost&quot;&gt;connectToHost&lt;/a&gt;(), the socket first enters &lt;a href=&quot;qabstractsocket#SocketState-enum&quot;&gt;HostLookupState&lt;/a&gt;. If the host is found, QAbstractSocket enters &lt;a href=&quot;qabstractsocket#SocketState-enum&quot;&gt;ConnectingState&lt;/a&gt; and emits the &lt;a href=&quot;qabstractsocket#hostFound&quot;&gt;hostFound&lt;/a&gt;() signal. When the connection has been established, it enters &lt;a href=&quot;qabstractsocket#SocketState-enum&quot;&gt;ConnectedState&lt;/a&gt; and emits &lt;a href=&quot;qabstractsocket#connected&quot;&gt;connected&lt;/a&gt;(). If an error occurs at any stage, &lt;a href=&quot;qabstractsocket#errorOccurred&quot;&gt;errorOccurred&lt;/a&gt;() is emitted. Whenever the state changes, &lt;a href=&quot;qabstractsocket#stateChanged&quot;&gt;stateChanged&lt;/a&gt;() is emitted. For convenience, &lt;a href=&quot;qabstractsocket#isValid&quot;&gt;isValid&lt;/a&gt;() returns &lt;code&gt;true&lt;/code&gt; if the socket is ready for reading and writing, but note that the socket's state must be &lt;a href=&quot;qabstractsocket#SocketState-enum&quot;&gt;ConnectedState&lt;/a&gt; before reading and writing can occur.</source>
          <target state="translated">언제든지 QAbstractSocket에는 상태 ( &lt;a href=&quot;qabstractsocket#state&quot;&gt;상태&lt;/a&gt; ()에 의해 반환 됨)가 있습니다. 초기 상태는 &lt;a href=&quot;qabstractsocket#SocketState-enum&quot;&gt;UnconnectedState&lt;/a&gt; 입니다. &lt;a href=&quot;qabstractsocket#connectToHost&quot;&gt;connectToHost&lt;/a&gt; ()를 호출 한 후 소켓은 먼저 &lt;a href=&quot;qabstractsocket#SocketState-enum&quot;&gt;HostLookupState&lt;/a&gt; 로 들어 갑니다 . 호스트가 발견 된 경우, QAbstractSocket 들어간다 &lt;a href=&quot;qabstractsocket#SocketState-enum&quot;&gt;ConnectingState를&lt;/a&gt; 상기 발광 &lt;a href=&quot;qabstractsocket#hostFound&quot;&gt;hostFound&lt;/a&gt; () 신호. 연결이 설정되면 &lt;a href=&quot;qabstractsocket#SocketState-enum&quot;&gt;ConnectedState&lt;/a&gt; 로 들어가서 &lt;a href=&quot;qabstractsocket#connected&quot;&gt;connected&lt;/a&gt; ()를 내 보냅니다 . 어느 단계에서든 오류가 발생하면 &lt;a href=&quot;qabstractsocket#errorOccurred&quot;&gt;errorOccurred&lt;/a&gt; ()가 발생합니다. 상태가 변경 될 때마다 &lt;a href=&quot;qabstractsocket#stateChanged&quot;&gt;stateChanged&lt;/a&gt; ()가 생성됩니다. 편의상 &lt;a href=&quot;qabstractsocket#isValid&quot;&gt;isValid&lt;/a&gt; ()는 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다.소켓이 읽기 및 쓰기 준비가되었지만 읽기 및 쓰기가 발생하기 전에 소켓의 상태가 &lt;a href=&quot;qabstractsocket#SocketState-enum&quot;&gt;ConnectedState&lt;/a&gt; 여야 합니다.</target>
        </trans-unit>
        <trans-unit id="a0b9a523686980c5115e2cd28208348628ab266c" translate="yes" xml:space="preserve">
          <source>At any time, you can create a &lt;a href=&quot;qeventloop&quot;&gt;QEventLoop&lt;/a&gt; object and call &lt;a href=&quot;qeventloop#exec&quot;&gt;exec&lt;/a&gt;() on it to start a local event loop. From within the event loop, calling &lt;a href=&quot;qeventloop#exit&quot;&gt;exit&lt;/a&gt;() will force &lt;a href=&quot;qeventloop#exec&quot;&gt;exec&lt;/a&gt;() to return.</source>
          <target state="translated">언제든지 &lt;a href=&quot;qeventloop&quot;&gt;QEventLoop&lt;/a&gt; 객체를 생성하고 &lt;a href=&quot;qeventloop#exec&quot;&gt;exec&lt;/a&gt; ()를 호출 하여 로컬 이벤트 루프를 시작할 수 있습니다. 이벤트 루프 내에서 &lt;a href=&quot;qeventloop#exit&quot;&gt;exit&lt;/a&gt; ()를 호출 하면 &lt;a href=&quot;qeventloop#exec&quot;&gt;exec&lt;/a&gt; () 가 강제 로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="e9b23ef4bfd8d66b004458eb7e27bc5103b2854b" translate="yes" xml:space="preserve">
          <source>At any time, you can create a QEventLoop object and call &lt;a href=&quot;qeventloop#exec&quot;&gt;exec&lt;/a&gt;() on it to start a local event loop. From within the event loop, calling &lt;a href=&quot;qeventloop#exit&quot;&gt;exit&lt;/a&gt;() will force &lt;a href=&quot;qeventloop#exec&quot;&gt;exec&lt;/a&gt;() to return.</source>
          <target state="translated">언제든지 QEventLoop 객체를 만들고 &lt;a href=&quot;qeventloop#exec&quot;&gt;exec&lt;/a&gt; ()를 호출 하여 로컬 이벤트 루프를 시작할 수 있습니다. 이벤트 루프 내에서 &lt;a href=&quot;qeventloop#exit&quot;&gt;exit&lt;/a&gt; ()를 호출 하면 &lt;a href=&quot;qeventloop#exec&quot;&gt;exec&lt;/a&gt; () 가 강제 로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="daa6a58000f8024bb9abb849cd1c6bc5b90cf05f" translate="yes" xml:space="preserve">
          <source>At compile time, the</source>
          <target state="translated">컴파일 타임에</target>
        </trans-unit>
        <trans-unit id="fac0e6dbd5badab8e273f9eada1e5d1b55cf621d" translate="yes" xml:space="preserve">
          <source>At each moment there is at most one animation that is active in the group; it is returned by &lt;a href=&quot;qsequentialanimationgroup#currentAnimation-prop&quot;&gt;currentAnimation&lt;/a&gt;(). An empty group has no current animation.</source>
          <target state="translated">매 순간마다 그룹에서 활성화되는 애니메이션이 최대 하나입니다. &lt;a href=&quot;qsequentialanimationgroup#currentAnimation-prop&quot;&gt;currentAnimation&lt;/a&gt; ()에 의해 리턴됩니다 . 빈 그룹에는 현재 애니메이션이 없습니다.</target>
        </trans-unit>
        <trans-unit id="c48b7d2b99551d3cffcfb32f1f31b3d96a3a8ff2" translate="yes" xml:space="preserve">
          <source>At first application startup, the window gets default dimensions specified as 800x600. Notice that no default position is specified - we let the window manager handle that. Later when the window geometry changes, new values will be automatically stored to the persistent settings. The second application run will get initial values from the persistent settings, bringing the window back to the previous position and size.</source>
          <target state="translated">응용 프로그램을 처음 시작할 때 창에 기본 크기는 800x600으로 지정됩니다. 기본 위치는 지정되어 있지 않습니다. 창 관리자가이를 처리하도록합니다. 나중에 창 지오메트리가 변경되면 새 값이 지속적 설정에 자동으로 저장됩니다. 두 번째 응용 프로그램 실행은 지속 설정에서 초기 값을 가져 와서 창을 이전 위치와 크기로 되돌립니다.</target>
        </trans-unit>
        <trans-unit id="87807290c5074347670303aa4be4a27ce5a5a1d0" translate="yes" xml:space="preserve">
          <source>At item's</source>
          <target state="translated">항목에서</target>
        </trans-unit>
        <trans-unit id="fc9e79d115e6810206d506e1fc484f86bd561f77" translate="yes" xml:space="preserve">
          <source>At its heart, the framegraph is a data-driven method for configuring the Qt 3D renderer. Due to its data-driven nature, we can change configuration at runtime, allow non-C++ developers or designers to change the structure of a frame, and try out new rendering approaches without having to write thousands of lines of boiler plate code.</source>
          <target state="translated">기본적으로 프레임 그래프는 Qt 3D 렌더러를 구성하기위한 데이터 기반 방법입니다. 데이터 중심 특성으로 인해 런타임에 구성을 변경하고 비 C ++ 개발자 또는 디자이너가 프레임 구조를 변경하고 수천 줄의 보일러 플레이트 코드를 작성하지 않고도 새로운 렌더링 방식을 시도 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc401b782cbfc97a28d7a783971e774fd968e343" translate="yes" xml:space="preserve">
          <source>At its simplest, a view transition may just animate an item to its new position following a view operation, just as the &lt;code&gt;displaced&lt;/code&gt; transition does above, or animate some item properties, as in the &lt;code&gt;add&lt;/code&gt; transition above. Additionally, a view transition may make use of the &lt;a href=&quot;qml-qtquick-viewtransition&quot;&gt;ViewTransition&lt;/a&gt; attached property to customize animation behavior for different items. Following are some examples of how this can be achieved.</source>
          <target state="translated">가장 간단하게, 뷰 트랜지션은 &lt;code&gt;displaced&lt;/code&gt; 트랜지션이 위와 같이 뷰 조작 후 항목을 새로운 위치로 애니메이션하거나 위의 &lt;code&gt;add&lt;/code&gt; 트랜지션 에서와 같이 일부 항목 속성에 애니메이션을 적용 할 수 있습니다 . 또한 뷰 전환시 &lt;a href=&quot;qml-qtquick-viewtransition&quot;&gt;ViewTransition&lt;/a&gt; 연결된 속성을 사용 하여 다른 항목에 대한 애니메이션 동작을 사용자 지정할 수 있습니다. 다음은 이것이 어떻게 달성 될 수 있는지에 대한 몇 가지 예입니다.</target>
        </trans-unit>
        <trans-unit id="6f7ed8163895d1af80d4d10ec64234aa6786422d" translate="yes" xml:space="preserve">
          <source>At its simplest, a view transition may just animate an item to its new position following a view operation, just as the &lt;code&gt;displaced&lt;/code&gt; transition does above, or animate some item properties, as in the &lt;code&gt;add&lt;/code&gt; transition above. Additionally, a view transition may make use of the ViewTransition attached property to customize animation behavior for different items. Following are some examples of how this can be achieved.</source>
          <target state="translated">가장 간단하게보기 전환은 위 의 &lt;code&gt;displaced&lt;/code&gt; 전환이 수행하는 것처럼 뷰 작업 후에 항목을 새 위치로 애니메이션하거나 위의 &lt;code&gt;add&lt;/code&gt; 전환 에서와 같이 일부 항목 속성을 애니메이션 할 수 있습니다 . 또한 뷰 전환은 ViewTransition 연결된 속성을 사용하여 다른 항목에 대한 애니메이션 동작을 사용자 지정할 수 있습니다. 다음은이를 달성 할 수있는 방법의 몇 가지 예입니다.</target>
        </trans-unit>
        <trans-unit id="a19c22dff9d4cde9bd2628e6c3d56d2072a7deaf" translate="yes" xml:space="preserve">
          <source>At least one QML file whose name matches a control (for example, &lt;code&gt;Button.qml&lt;/code&gt;) must exist.</source>
          <target state="translated">이름이 컨트롤과 일치하는 이름이 하나 이상의 QML 파일 (예 : &lt;code&gt;Button.qml&lt;/code&gt; )이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="11337d7577501270c01136ae9088ddfe3dcd4e9a" translate="yes" xml:space="preserve">
          <source>At least one SDK platform</source>
          <target state="translated">하나 이상의 SDK 플랫폼</target>
        </trans-unit>
        <trans-unit id="796169bf85aac57a7e0921080487ae6d4a8e086f" translate="yes" xml:space="preserve">
          <source>At minimum the layout directory must contain the files:</source>
          <target state="translated">최소한 레이아웃 디렉토리에는 파일이 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="3d85ab1776cdd148870608e2a1c1a3f96d1e0910" translate="yes" xml:space="preserve">
          <source>At minimum, a custom geometry should have the following specified:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f22d3f606cf8829a4a62d38fe069e71b5e9b14ed" translate="yes" xml:space="preserve">
          <source>At most one action can be checked at any one time. The actions can also be all unchecked.</source>
          <target state="translated">한 번에 최대 하나의 작업을 확인할 수 있습니다. 작업을 모두 선택 취소 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e9d2902edfc287dd7802b4148dde59e40d35ee7" translate="yes" xml:space="preserve">
          <source>At present the &lt;a href=&quot;qplacecontent&quot;&gt;QPlaceContent&lt;/a&gt; class is not extensible by 3rd parties.</source>
          <target state="translated">현재 &lt;a href=&quot;qplacecontent&quot;&gt;QPlaceContent&lt;/a&gt; 클래스는 타사에서 확장 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7ab6c62713d2b849fd7308f7ef17c30401241857" translate="yes" xml:space="preserve">
          <source>At present the QPlaceContent class is not extensible by 3rd parties.</source>
          <target state="translated">현재 QPlaceContent 클래스는 타사에서 확장 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="037e15c7a413b9bf23ac5206f5480d34b46afe7b" translate="yes" xml:space="preserve">
          <source>At present, the Qt 3D Animation module provides the following blend tree node types:</source>
          <target state="translated">현재 Qt 3D 애니메이션 모듈은 다음과 같은 블렌드 트리 노드 유형을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="ab91ac60011e39d43815f16993dec5b68f1f3bc8" translate="yes" xml:space="preserve">
          <source>At render time, for each leaf node of the FrameGraph a base render state is recorded by accumulating states defined by all &lt;a href=&quot;qml-qt3d-render-renderstateset&quot;&gt;RenderStateSet&lt;/a&gt; nodes in the FrameGraph branch. Each &lt;a href=&quot;qml-qt3d-render-renderpass&quot;&gt;RenderPass&lt;/a&gt; can overload this base render state by specifying its own &lt;a href=&quot;qml-renderstate&quot;&gt;RenderState&lt;/a&gt; nodes.</source>
          <target state="translated">렌더링시 FrameGraph의 각 리프 노드에 대해 기본 렌더링 상태는 FrameGraph 분기의 모든 &lt;a href=&quot;qml-qt3d-render-renderstateset&quot;&gt;RenderStateSet&lt;/a&gt; 노드에 의해 정의 된 상태를 누적하여 기록됩니다 . 각 &lt;a href=&quot;qml-qt3d-render-renderpass&quot;&gt;RenderPass&lt;/a&gt; 는 자체 &lt;a href=&quot;qml-renderstate&quot;&gt;RenderState&lt;/a&gt; 노드를 지정하여이 기본 렌더 상태를 오버로드 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c3efa742387c6c784898c8a9b679b9a7cb835f85" translate="yes" xml:space="preserve">
          <source>At render time, for each leaf node of the FrameGraph a base render state is recorded by accumulating states defined by all &lt;a href=&quot;qml-qt3d-render-renderstateset&quot;&gt;RenderStateSet&lt;/a&gt; nodes in the FrameGraph branch. Each RenderPass can overload this base render state by specifying its own &lt;a href=&quot;qml-qt3d-render-renderstate&quot;&gt;RenderState&lt;/a&gt; nodes.</source>
          <target state="translated">렌더링시 FrameGraph의 각 리프 노드에 대해 FrameGraph 분기의 모든 &lt;a href=&quot;qml-qt3d-render-renderstateset&quot;&gt;RenderStateSet&lt;/a&gt; 노드에 의해 정의 된 상태를 누적하여 기본 렌더링 상태가 기록됩니다 . 각 RenderPass는 자체 &lt;a href=&quot;qml-qt3d-render-renderstate&quot;&gt;RenderState&lt;/a&gt; 노드를 지정하여이 기본 렌더링 상태를 오버로드 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4332a429b68b0ac4a41c160e240519e6859b47ee" translate="yes" xml:space="preserve">
          <source>At render time, for each leaf node of the FrameGraph a base render state is recorded by accumulating states defined by all &lt;a href=&quot;qt3drender-qrenderstateset&quot;&gt;QRenderStateSet&lt;/a&gt; nodes in the FrameGraph branch. Each &lt;a href=&quot;qt3drender-qrenderpass&quot;&gt;QRenderPass&lt;/a&gt; can overload this base render state by specifying its own &lt;a href=&quot;qt3drender-qrenderstate&quot;&gt;QRenderState&lt;/a&gt; nodes.</source>
          <target state="translated">렌더링시 FrameGraph의 각 리프 노드에 대해 기본 렌더링 상태는 FrameGraph 분기의 모든 &lt;a href=&quot;qt3drender-qrenderstateset&quot;&gt;QRenderStateSet&lt;/a&gt; 노드에 의해 정의 된 상태를 누적하여 기록됩니다 . 각 &lt;a href=&quot;qt3drender-qrenderpass&quot;&gt;QRenderPass&lt;/a&gt; 는 자체 &lt;a href=&quot;qt3drender-qrenderstate&quot;&gt;QRenderState&lt;/a&gt; 노드를 지정하여이 기본 렌더링 상태를 오버로드 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b3132a6e843feaf04028dc302fab6ee1d03053f0" translate="yes" xml:space="preserve">
          <source>At render time, for each leaf node of the FrameGraph a base render state is recorded by accumulating states defined by all &lt;a href=&quot;qt3drender-qrenderstateset&quot;&gt;QRenderStateSet&lt;/a&gt; nodes in the FrameGraph branch. Each QRenderPass can overload this base render state by specifying its own &lt;a href=&quot;qt3drender-qrenderstate&quot;&gt;QRenderState&lt;/a&gt; nodes.</source>
          <target state="translated">렌더링시 FrameGraph의 각 리프 노드에 대해 FrameGraph 분기의 모든 &lt;a href=&quot;qt3drender-qrenderstateset&quot;&gt;QRenderStateSet&lt;/a&gt; 노드에 의해 정의 된 상태를 누적하여 기본 렌더링 상태가 기록됩니다 . 각 QRenderPass는 자체 &lt;a href=&quot;qt3drender-qrenderstate&quot;&gt;QRenderState&lt;/a&gt; 노드를 지정하여이 기본 렌더링 상태를 오버로드 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="54a81c3421b400f49f9c78d8711420f357d5fc98" translate="yes" xml:space="preserve">
          <source>At runtime, a Qt application recognizes many environment variables, some of which can be helpful for debugging:</source>
          <target state="translated">런타임시 Qt 애플리케이션은 많은 환경 변수를 인식하며 그 중 일부는 디버깅에 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="955c34f87df8ea5caf157532c8a65273ad95cd6b" translate="yes" xml:space="preserve">
          <source>At runtime, the status property will be updated to reflect whether an actual device matching the device name could be created.</source>
          <target state="translated">런타임시 상태 속성이 업데이트되어 장치 이름과 일치하는 실제 장치를 만들 수 있는지 여부를 반영합니다.</target>
        </trans-unit>
        <trans-unit id="dab9d4507e7863cf2519c0cf5e644680a577be4f" translate="yes" xml:space="preserve">
          <source>At some point later on, the &lt;a href=&quot;qinappstore#transactionReady&quot;&gt;transactionReady&lt;/a&gt;() signal will be emitted for the purchase. Check &lt;a href=&quot;qinapptransaction#status-prop&quot;&gt;QInAppTransaction::status&lt;/a&gt;() to see if the purchase was completed successfully. If it was, then you must save the information about the purchase in a safe way, so that the application can restore it later.</source>
          <target state="translated">나중에 어느 시점에서 &lt;a href=&quot;qinappstore#transactionReady&quot;&gt;transactionReady&lt;/a&gt; () 신호가 구매를 위해 방출됩니다. 구매가 성공적으로 완료 되었는지 확인 &lt;a href=&quot;qinapptransaction#status-prop&quot;&gt;하려면 QInAppTransaction :: status&lt;/a&gt; ()를 확인하십시오. 그렇다면, 구매에 대한 정보를 안전한 방법으로 저장하여 응용 프로그램이 나중에이를 복원 할 수 있도록하십시오.</target>
        </trans-unit>
        <trans-unit id="b52512e5061a593208dea53cfb23d89cd05ed9e4" translate="yes" xml:space="preserve">
          <source>At some point, the user will activate a user interface component (perhaps using a particular key) where they can choose from a number of strings matching the text they have typed so far. The user can either confirm their choice cancel the input; in either case the input context will be closed.</source>
          <target state="translated">어떤 시점에서, 사용자는 사용자 인터페이스 구성 요소 (아마도 특정 키를 사용)를 활성화하여 지금까지 입력 한 텍스트와 일치하는 여러 문자열 중에서 선택할 수 있습니다. 사용자는 자신의 선택을 확인하여 입력을 취소 할 수 있습니다. 두 경우 모두 입력 컨텍스트가 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="72ba8cc9ccc86603a2ddc31bcd57b68d34d2c1f5" translate="yes" xml:space="preserve">
          <source>At that point &lt;a href=&quot;qgeocodereply#locations&quot;&gt;QGeoCodeReply::locations&lt;/a&gt;() can be used to retrieve the results, which will consist of a list of &lt;a href=&quot;qgeolocation&quot;&gt;QGeoLocation&lt;/a&gt; objects. These objects represent a combination of coordinate and address data.</source>
          <target state="translated">이 시점에서 &lt;a href=&quot;qgeocodereply#locations&quot;&gt;QGeoCodeReply :: locations&lt;/a&gt; ()를 사용하여 결과를 검색 할 수 있으며, &lt;a href=&quot;qgeolocation&quot;&gt;QGeoLocation&lt;/a&gt; 객체 목록으로 구성 됩니다. 이러한 객체는 좌표 및 주소 데이터의 조합을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="40ccae4b2a43fca0f3cdca72e9f94bb174cad42f" translate="yes" xml:space="preserve">
          <source>At the C++ implementation level, using a Qt module makes its headers available for inclusion and causes it to be linked to the binary.</source>
          <target state="translated">C ++ 구현 레벨에서 Qt 모듈을 사용하면 헤더를 포함 할 수 있으며 바이너리에 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="0d90be54974f6606a3a303e548ddcfeb04f3394e" translate="yes" xml:space="preserve">
          <source>At the beginining of the header</source>
          <target state="translated">헤더가 시작될 때</target>
        </trans-unit>
        <trans-unit id="8ed66d562fe594c7221f115eb44a11475ad2f6ea" translate="yes" xml:space="preserve">
          <source>At the end of a frame we can retrieve the results by calling &lt;a href=&quot;qopengltimerquery#waitForResult&quot;&gt;waitForResult&lt;/a&gt;(). As this function's name implies, it blocks CPU execution until OpenGL notifies that the timer query result is available. To avoid blocking, you can check if the query result is available by calling &lt;a href=&quot;qopengltimerquery#isResultAvailable&quot;&gt;isResultAvailable&lt;/a&gt;(). Note that modern GPUs are deeply pipelined and query results may not become available for between 1-5 frames after they were issued.</source>
          <target state="translated">프레임의 끝에서 &lt;a href=&quot;qopengltimerquery#waitForResult&quot;&gt;waitForResult&lt;/a&gt; () 를 호출하여 결과를 검색 할 수 있습니다 . 이 함수의 이름에서 알 수 있듯이 OpenGL은 타이머 쿼리 결과를 사용할 수 있음을 알릴 때까지 CPU 실행을 차단합니다. 차단을 피하기 위해 &lt;a href=&quot;qopengltimerquery#isResultAvailable&quot;&gt;isResultAvailable&lt;/a&gt; () 을 호출하여 쿼리 결과를 사용할 수 있는지 확인할 수 있습니다 . 최신 GPU는 파이프 라인이 깊으며 쿼리 결과가 발행 된 후 1-5 프레임 사이에서 사용하지 못할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3080d39bec8e79e78fb1923604be5fe6c466e9ba" translate="yes" xml:space="preserve">
          <source>At the end of the header</source>
          <target state="translated">헤더 끝에서</target>
        </trans-unit>
        <trans-unit id="75e8c90ac99703039b88fbc5e0a1beabaa46fbf6" translate="yes" xml:space="preserve">
          <source>At the same time, attention must be paid to the number of Shape elements in the scene, in particular when using this special accelerated approach for &lt;code&gt;GL_NV_path_rendering&lt;/code&gt;. The way such a Shape item is represented in the scene graph is different from an ordinary geometry-based item, and incurs a certain cost when it comes to OpenGL state changes.</source>
          <target state="translated">동시에, 특히 &lt;code&gt;GL_NV_path_rendering&lt;/code&gt; 을 위해이 특별한 가속화 된 접근 방식을 사용할 때 장면의 Shape 요소 수에주의를 기울여야합니다 . 이러한 모양 항목이 장면 그래프에 표시되는 방식은 일반적인 형상 기반 항목과 다르며 OpenGL 상태 변경시 특정 비용이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6923f2cad67b0125f74f99f123f0e7ff80332bb8" translate="yes" xml:space="preserve">
          <source>At the same time, memory layout of the elements is also updated. &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt; now always stores its elements directly in the allocated memory region as opposed to Qt 5, where certain objects were separately allocated on the heap and pointers to the objects were placed into the &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c10f42bbe4080eec805fef67f19baa1dacce0f8" translate="yes" xml:space="preserve">
          <source>At the simplest level, text documents are made up of a string of characters, marked up in some way to represent the block structure of the text within the document. &lt;a href=&quot;qtextcursor&quot;&gt;QTextCursor&lt;/a&gt; provides a cursor-based interface that allows the contents of a &lt;a href=&quot;qtextdocument&quot;&gt;QTextDocument&lt;/a&gt; to be manipulated at the character level. Since the elements (blocks, frames, tables, etc.) are also encoded in the character stream, the document structure can itself be changed by the cursor.</source>
          <target state="translated">가장 간단한 수준에서 텍스트 문서는 문자열로 구성되며 문서 내에서 텍스트의 블록 구조를 나타내는 방식으로 표시됩니다. &lt;a href=&quot;qtextcursor&quot;&gt;QTextCursor은&lt;/a&gt; a의 내용을 수있는 커서 기반 인터페이스를 제공 &lt;a href=&quot;qtextdocument&quot;&gt;QTextDocument는&lt;/a&gt; 문자 수준에서 조작 할 수 있습니다. 요소 (블록, 프레임, 테이블 등)도 문자 스트림으로 인코딩되므로 커서로 문서 구조 자체를 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9dcec02d3d4c2b8f2a55dfb0ebaad329e7acdf90" translate="yes" xml:space="preserve">
          <source>At the time of release (the mouse button is released or the finger is lifted), if the event point is outside the bounds of the &lt;code&gt;parent&lt;/code&gt; Item, a tap gesture is not recognized. This corresponds to typical behavior for button widgets: you can cancel a click by dragging outside the button, and you can also change your mind by dragging back inside the button before release. Note that it's necessary for &lt;a href=&quot;qml-qtquick-taphandler&quot;&gt;TapHandler&lt;/a&gt; take the exclusive grab on press and retain it until release in order to detect this gesture.</source>
          <target state="translated">해제 시점 (마우스 단추를 놓거나 손가락을) 때)에서 이벤트 지점이 &lt;code&gt;parent&lt;/code&gt; 항목 의 경계를 벗어나면 탭 동작이 인식되지 않습니다. 이는 버튼 위젯의 일반적인 동작에 해당합니다. 버튼 외부로 드래그하여 클릭을 취소 할 수 있으며 릴리스 전에 버튼 내부로 다시 드래그하여 마음을 바꿀 수도 있습니다. 것이 필요하다고 주 &lt;a href=&quot;qml-qtquick-taphandler&quot;&gt;TapHandler이&lt;/a&gt; 눌러에 독점 횡령을하고이 제스처를 감지하기 위해 릴리스 때까지 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="8140bc4ff5189ac6bc25fdb8ce759b5bdba0ac67" translate="yes" xml:space="preserve">
          <source>At the time this table was generated, there were six links from &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtcore-module.html&quot;&gt;QtCore&lt;/a&gt; to &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtquick-qmlmodule.html&quot;&gt;QtQuick&lt;/a&gt;. The first column of each table entry contains a link to some link in &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtcore-module.html&quot;&gt;QtCore&lt;/a&gt;. The link text as it appears in &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtcore-module.html&quot;&gt;QtCore&lt;/a&gt; is shown. The second and third columns contain the source file name and line number for where qdoc saw the link in a qdoc comment.</source>
          <target state="translated">이 테이블이 생성 될 때 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtcore-module.html&quot;&gt;QtCore&lt;/a&gt; 에서 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtquick-qmlmodule.html&quot;&gt;QtQuick&lt;/a&gt; 으로의 6 개의 링크가 있었습니다 . 각 테이블 항목의 첫 번째 열에는 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtcore-module.html&quot;&gt;QtCore의&lt;/a&gt; 일부 링크에 대한 링크가 포함 됩니다 . &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtcore-module.html&quot;&gt;QtCore에&lt;/a&gt; 나타나는 링크 텍스트 가 표시됩니다. 두 번째 및 세 번째 열에는 qdoc이 qdoc 주석에서 링크를 본 위치의 소스 파일 이름과 행 번호가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="48ae4572cf4a70fdf5389bb804cde3f953b5c37a" translate="yes" xml:space="preserve">
          <source>At the time this table was generated, there were six links from &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtcore-module.html&quot;&gt;QtCore&lt;/a&gt; to &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtquick-module.html&quot;&gt;QtQuick&lt;/a&gt;. The first column of each table entry contains a link to some link in &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtcore-module.html&quot;&gt;QtCore&lt;/a&gt;. The link text as it appears in &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtcore-module.html&quot;&gt;QtCore&lt;/a&gt; is shown. The second and third columns contain the source file name and line number for where QDoc saw the link in a qdoc comment.</source>
          <target state="translated">이 테이블이 생성되었을 때 &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtcore-module.html&quot;&gt;QtCore&lt;/a&gt; 에서 &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtquick-module.html&quot;&gt;QtQuick&lt;/a&gt; 으로의 6 개의 링크가 있었습니다 . 각 테이블 항목의 첫 번째 열에는 &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtcore-module.html&quot;&gt;QtCore의&lt;/a&gt; 일부 링크에 대한 링크가 포함되어 있습니다 . &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtcore-module.html&quot;&gt;QtCore에&lt;/a&gt; 나타나는 링크 텍스트 가 표시됩니다. 두 번째 및 세 번째 열에는 QDoc이 qdoc 주석에서 링크를 본 위치에 대한 소스 파일 이름과 행 번호가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="b73bf5286ff35474a74c26035c042d81945e9ffc" translate="yes" xml:space="preserve">
          <source>At this point there are two GeoServices plugins packaged with Qt. They are accessible using their provider names:</source>
          <target state="translated">이 시점에서 Qt로 패키지 된 두 개의 GeoServices 플러그인이 있습니다. 제공자 이름을 사용하여 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aff72b9f558b4e97e80f24407ec25f32bf5ed9e7" translate="yes" xml:space="preserve">
          <source>At this point, if we examined the &lt;code&gt;displaced&lt;/code&gt; transition that was run for the bottom displaced item (&quot;Item 0&quot;), the &lt;a href=&quot;qml-qtquick-viewtransition&quot;&gt;ViewTransition&lt;/a&gt; property values provided to this transition would be as follows:</source>
          <target state="translated">이 시점 에서 맨 아래 변위 항목 ( &quot;Item 0&quot;)에 대해 실행 된 &lt;code&gt;displaced&lt;/code&gt; 전환을 검사 한 경우이 전환에 제공된 &lt;a href=&quot;qml-qtquick-viewtransition&quot;&gt;ViewTransition&lt;/a&gt; 속성 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="907672db6f8a41f43812049ae0a6a8dfdcaf9aaa" translate="yes" xml:space="preserve">
          <source>At this point, if we examined the &lt;code&gt;displaced&lt;/code&gt; transition that was run for the bottom displaced item (&quot;Item 0&quot;), the ViewTransition property values provided to this transition would be as follows:</source>
          <target state="translated">이 시점 에서 하단 변위 항목 ( &quot;Item 0&quot;)에 대해 실행 된 &lt;code&gt;displaced&lt;/code&gt; 전환을 조사한 경우이 전환에 제공된 ViewTransition 속성 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="850acecc5742a41db5fb216f29a36550106d1ff8" translate="yes" xml:space="preserve">
          <source>At this point, neither sorting nor filtering is enabled; the original data is displayed in the view. Any changes made through the &lt;a href=&quot;qsortfilterproxymodel&quot;&gt;QSortFilterProxyModel&lt;/a&gt; are applied to the original model.</source>
          <target state="translated">이 시점에서 정렬이나 필터링이 활성화되지 않았습니다. 원래 데이터가보기에 표시됩니다. &lt;a href=&quot;qsortfilterproxymodel&quot;&gt;QSortFilterProxyModel을&lt;/a&gt; 통해 작성된 모든 변경 사항은 원래 모델에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="e39a928aa9f4a74b98452d78dcbd11be08ebbd1f" translate="yes" xml:space="preserve">
          <source>At this point, neither sorting nor filtering is enabled; the original data is displayed in the view. Any changes made through the QSortFilterProxyModel are applied to the original model.</source>
          <target state="translated">이 시점에서는 정렬이나 필터링이 활성화되지 않습니다. 원래 데이터가보기에 표시됩니다. QSortFilterProxyModel을 통해 이루어진 모든 변경 사항은 원래 모델에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="1eb194f1c0f8ecd9fb1f220a29550b7e23cebb5d" translate="yes" xml:space="preserve">
          <source>At this time, drag-and-drop is not yet supported.</source>
          <target state="translated">현재 드래그 앤 드롭은 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3233cbdf60e91444617d3f6d1b887957b7eaf196" translate="yes" xml:space="preserve">
          <source>Atlas based textures are created by passing &lt;a href=&quot;qquickwindow#CreateTextureOption-enum&quot;&gt;QQuickWindow::TextureCanUseAtlas&lt;/a&gt; to the &lt;a href=&quot;qquickwindow#createTextureFromImage&quot;&gt;QQuickWindow::createTextureFromImage&lt;/a&gt;().</source>
          <target state="translated">Atlas 기반 텍스처는 &lt;a href=&quot;qquickwindow#CreateTextureOption-enum&quot;&gt;QQuickWindow :: TextureCanUseAtlas&lt;/a&gt; 를 &lt;a href=&quot;qquickwindow#createTextureFromImage&quot;&gt;QQuickWindow :: createTextureFromImage&lt;/a&gt; () 에 전달하여 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="ca2894d7d5816986441ce1688077b4b58aca9579" translate="yes" xml:space="preserve">
          <source>Atomic API is useful when you application needs to blend content into overlays keeping all the updates within the same vsync. Still not all devices support this API and it could be unavailable on some older devices. KMS backend will by default use the legacy API, but you can enable the DRM atomic API with &lt;code&gt;QT_QPA_EGLFS_KMS_ATOMIC&lt;/code&gt; environment variable set to 1.</source>
          <target state="translated">Atomic API는 애플리케이션이 동일한 vsync 내에 모든 업데이트를 유지하면서 컨텐츠를 오버레이로 혼합해야 할 때 유용합니다. 여전히 모든 장치가이 API를 지원하는 것은 아니며 일부 구형 장치에서는 사용할 수 없습니다. KMS 백엔드는 기본적으로 레거시 API를 사용하지만 &lt;code&gt;QT_QPA_EGLFS_KMS_ATOMIC&lt;/code&gt; 환경 변수를 1로 설정 하여 DRM 아토믹 API를 활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a967c27abdae3c54a1ba2eb46dfef28e4669c220" translate="yes" xml:space="preserve">
          <source>Atomic add-and-fetch.</source>
          <target state="translated">원자 추가 및 가져 오기.</target>
        </trans-unit>
        <trans-unit id="1aca8c389398c9bb150cb22baffa337508a5b375" translate="yes" xml:space="preserve">
          <source>Atomic fetch-and-add.</source>
          <target state="translated">원자 가져 오기 및 추가.</target>
        </trans-unit>
        <trans-unit id="7b4b593a63bdacca7e88ddaa3d460f979d52a59e" translate="yes" xml:space="preserve">
          <source>Atomic fetch-and-and.</source>
          <target state="translated">원자 가져 오기 및.</target>
        </trans-unit>
        <trans-unit id="dc61104378ed6ca8bef017107abe35e79e1d3418" translate="yes" xml:space="preserve">
          <source>Atomic fetch-and-or.</source>
          <target state="translated">원자 가져 오기 및 / 또는</target>
        </trans-unit>
        <trans-unit id="c7830879c704a38b11e5ddd086e77ccef500b74f" translate="yes" xml:space="preserve">
          <source>Atomic fetch-and-store.</source>
          <target state="translated">원자 가져 오기 및 저장</target>
        </trans-unit>
        <trans-unit id="29a0ea35af869894686b5620753669846139975f" translate="yes" xml:space="preserve">
          <source>Atomic fetch-and-sub.</source>
          <target state="translated">원자 가져 오기 및 서브</target>
        </trans-unit>
        <trans-unit id="677000d5ba7c628139cf77380e75ab8c46f01e22" translate="yes" xml:space="preserve">
          <source>Atomic fetch-and-xor.</source>
          <target state="translated">원자 가져 오기 및 xor.</target>
        </trans-unit>
        <trans-unit id="01a71a9c1dd30ce797dff76bda85d82b65e9c8a2" translate="yes" xml:space="preserve">
          <source>Atomic or-and-fetch.</source>
          <target state="translated">원자 또는 가져 오기.</target>
        </trans-unit>
        <trans-unit id="d7c154d6a6458aeda8686536a6877b2d6b01a013" translate="yes" xml:space="preserve">
          <source>Atomic sub-and-fetch.</source>
          <target state="translated">원자 하위 가져 오기.</target>
        </trans-unit>
        <trans-unit id="99da09e996e10b97b93284055241904724848e3b" translate="yes" xml:space="preserve">
          <source>Atomic test-and-set.</source>
          <target state="translated">원자 테스트 및 설정.</target>
        </trans-unit>
        <trans-unit id="da13c4e269f632fb37b75640d8734403073f8480" translate="yes" xml:space="preserve">
          <source>Atomic xor-and-fetch.</source>
          <target state="translated">원자 xor-and-fetch.</target>
        </trans-unit>
        <trans-unit id="8aa451b096cba27c2fae11f428437f2c14de039c" translate="yes" xml:space="preserve">
          <source>Atomically decrements the value of this &lt;a href=&quot;qatomicinteger&quot;&gt;QAtomicInteger&lt;/a&gt;. Returns &lt;code&gt;true&lt;/code&gt; if the new value is non-zero, false otherwise.</source>
          <target state="translated">이 &lt;a href=&quot;qatomicinteger&quot;&gt;QAtomicInteger&lt;/a&gt; 의 값을 원자 적으로 줄 입니다. 반환 &lt;code&gt;true&lt;/code&gt; 새로운 값이 0, 그렇지 않은 경우는 false 인 경우.</target>
        </trans-unit>
        <trans-unit id="8dedf8ab3c76603bbc27d23afca2d137d8064ca9" translate="yes" xml:space="preserve">
          <source>Atomically increments the value of this &lt;a href=&quot;qatomicinteger&quot;&gt;QAtomicInteger&lt;/a&gt;. Returns &lt;code&gt;true&lt;/code&gt; if the new value is non-zero, false otherwise.</source>
          <target state="translated">이 &lt;a href=&quot;qatomicinteger&quot;&gt;QAtomicInteger&lt;/a&gt; 의 값을 원자 적으로 증가 시킵니다 . 반환 &lt;code&gt;true&lt;/code&gt; 새로운 값이 0, 그렇지 않은 경우는 false 인 경우.</target>
        </trans-unit>
        <trans-unit id="89dd8dbf7bb7ee2579be58bf9d204dafabeb1439" translate="yes" xml:space="preserve">
          <source>Atomically loads the value of this &lt;a href=&quot;qatomicinteger&quot;&gt;QAtomicInteger&lt;/a&gt; using a sequentially consistent memory ordering if possible; or &quot;Acquire&quot; ordering if not. The value is not modified in any way, but note that there's no guarantee that it remains so.</source>
          <target state="translated">가능한 경우 순차적으로 일관된 메모리 순서를 사용 하여이 &lt;a href=&quot;qatomicinteger&quot;&gt;QAtomicInteger&lt;/a&gt; 의 값을 원자 적으로로드 합니다. 그렇지 않으면 &quot;취득&quot;주문. 값은 어떤 식 으로든 수정되지 않지만 그 값이 그대로 유지된다는 보장은 없습니다.</target>
        </trans-unit>
        <trans-unit id="69653e3e82a9d9b720b3e7e9b153a85f9a1e4c06" translate="yes" xml:space="preserve">
          <source>Atomically loads the value of this &lt;a href=&quot;qatomicinteger&quot;&gt;QAtomicInteger&lt;/a&gt; using relaxed memory ordering. The value is not modified in any way, but note that there's no guarantee that it remains so.</source>
          <target state="translated">완화 된 메모리 순서를 사용 하여이 &lt;a href=&quot;qatomicinteger&quot;&gt;QAtomicInteger&lt;/a&gt; 의 값을 원자 적으로로드합니다 . 값은 어떤 식 으로든 수정되지 않지만 그 값이 그대로 유지된다는 보장은 없습니다.</target>
        </trans-unit>
        <trans-unit id="3e0d1fd4d5c9735d46867c2448de36a6bc511cb0" translate="yes" xml:space="preserve">
          <source>Atomically loads the value of this &lt;a href=&quot;qatomicinteger&quot;&gt;QAtomicInteger&lt;/a&gt; using the &quot;Acquire&quot; memory ordering. The value is not modified in any way, but note that there's no guarantee that it remains so.</source>
          <target state="translated">&quot;Acquire&quot;메모리 순서를 사용 하여이 &lt;a href=&quot;qatomicinteger&quot;&gt;QAtomicInteger&lt;/a&gt; 의 값을 원자 적으로로드합니다 . 값은 어떤 식 으로든 수정되지 않지만 그 값이 그대로 유지된다는 보장은 없습니다.</target>
        </trans-unit>
        <trans-unit id="f7081ad41a53c8af225230c522a5266c56092e5e" translate="yes" xml:space="preserve">
          <source>Atomically loads the value of this &lt;a href=&quot;qatomicpointer&quot;&gt;QAtomicPointer&lt;/a&gt; using relaxed memory ordering. The value is not modified in any way, but note that there's no guarantee that it remains so.</source>
          <target state="translated">완화 된 메모리 순서를 사용 하여이 &lt;a href=&quot;qatomicpointer&quot;&gt;QAtomicPointer&lt;/a&gt; 의 값을 원자 적으로로드합니다 . 값은 어떤 식 으로든 수정되지 않지만 그 값이 그대로 유지된다는 보장은 없습니다.</target>
        </trans-unit>
        <trans-unit id="130b6d95050e9b7c2405561c3e5d460bb604614b" translate="yes" xml:space="preserve">
          <source>Atomically loads the value of this &lt;a href=&quot;qatomicpointer&quot;&gt;QAtomicPointer&lt;/a&gt; using the &quot;Acquire&quot; memory ordering. The value is not modified in any way, but note that there's no guarantee that it remains so.</source>
          <target state="translated">&quot;Acquire&quot;메모리 순서를 사용 하여이 &lt;a href=&quot;qatomicpointer&quot;&gt;QAtomicPointer&lt;/a&gt; 의 값을 원자 적으로로드합니다 . 값은 어떤 식 으로든 수정되지 않지만 그 값이 그대로 유지된다는 보장은 없습니다.</target>
        </trans-unit>
        <trans-unit id="acb94368cb5719416863f8c2367679c67c6ea331" translate="yes" xml:space="preserve">
          <source>Atomically post-decrements the value of this &lt;a href=&quot;qatomicinteger&quot;&gt;QAtomicInteger&lt;/a&gt;. Returns the old value of this atomic.</source>
          <target state="translated">이 &lt;a href=&quot;qatomicinteger&quot;&gt;QAtomicInteger&lt;/a&gt; 의 값을 원자 적으로 사후 감소시킵니다 . 이 아토믹의 이전 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="793812097d2bfb8c79328c7076cfcdc46657e936" translate="yes" xml:space="preserve">
          <source>Atomically post-increments the value of this &lt;a href=&quot;qatomicinteger&quot;&gt;QAtomicInteger&lt;/a&gt;. Returns the old value of this atomic.</source>
          <target state="translated">이 &lt;a href=&quot;qatomicinteger&quot;&gt;QAtomicInteger&lt;/a&gt; 의 값을 원자 적으로 사후 증가 시킵니다 . 이 아토믹의 이전 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d69ff82cc5d52f41982a8e0e67bfcb57d12a14c4" translate="yes" xml:space="preserve">
          <source>Atomically pre-decrements the value of this &lt;a href=&quot;qatomicinteger&quot;&gt;QAtomicInteger&lt;/a&gt;. Returns the new value of this atomic.</source>
          <target state="translated">이 &lt;a href=&quot;qatomicinteger&quot;&gt;QAtomicInteger&lt;/a&gt; 의 값을 원자 적으로 사전 감소시킵니다 . 이 아토믹의 새로운 값을 돌려줍니다.</target>
        </trans-unit>
        <trans-unit id="3954772cbeafee10706db508a27dcf1f5609cfe8" translate="yes" xml:space="preserve">
          <source>Atomically pre-increments the value of this &lt;a href=&quot;qatomicinteger&quot;&gt;QAtomicInteger&lt;/a&gt;. Returns the new value of this atomic.</source>
          <target state="translated">이 &lt;a href=&quot;qatomicinteger&quot;&gt;QAtomicInteger&lt;/a&gt; 의 값을 원자 적으로 사전 증가 시킵니다 . 이 아토믹의 새로운 값을 돌려줍니다.</target>
        </trans-unit>
        <trans-unit id="64206ad6e584ead7f08fdbf0296423b524ea37a4" translate="yes" xml:space="preserve">
          <source>Atomically stores the</source>
          <target state="translated">원자 적으로</target>
        </trans-unit>
        <trans-unit id="d28e1e1cc0c7d44ae7312f7a38a54f527c3baed2" translate="yes" xml:space="preserve">
          <source>Atomically stores the other value into this atomic type using a sequentially consistent memory ordering if possible; or &quot;Release&quot; ordering if not. This function returns a reference to this object.</source>
          <target state="translated">가능한 경우 순차적으로 일관된 메모리 순서를 사용하여 다른 값을이 원자 유형에 원자 적으로 저장합니다. 그렇지 않으면 &quot;출시&quot;주문. 이 함수는이 객체에 대한 참조를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="22cd0cbd81dee9dcd227285a4fb456261af24ea4" translate="yes" xml:space="preserve">
          <source>Atomics</source>
          <target state="translated">Atomics</target>
        </trans-unit>
        <trans-unit id="5207af8927557bdcee58799743343132b7a7e7d5" translate="yes" xml:space="preserve">
          <source>Attach a &lt;a href=&quot;qgraphicsvideoitem&quot;&gt;QGraphicsVideoItem&lt;/a&gt; video</source>
          <target state="translated">&lt;a href=&quot;qgraphicsvideoitem&quot;&gt;QGraphicsVideoItem&lt;/a&gt; 비디오 첨부</target>
        </trans-unit>
        <trans-unit id="f92e2f9fb2a11868b1807469619b32fb101a2841" translate="yes" xml:space="preserve">
          <source>Attach a &lt;a href=&quot;qvideowidget&quot;&gt;QVideoWidget&lt;/a&gt; video</source>
          <target state="translated">&lt;a href=&quot;qvideowidget&quot;&gt;QVideoWidget&lt;/a&gt; 비디오 첨부</target>
        </trans-unit>
        <trans-unit id="d028067fa5f7a29797abf3e4197287917862fb4d" translate="yes" xml:space="preserve">
          <source>Attach the resulting type library as a binary resource to the server binary (again using the &lt;a href=&quot;activeqt-idc&quot;&gt;idc&lt;/a&gt; tool)</source>
          <target state="translated">결과 유형 라이브러리를 2 진 자원으로 서버 2 진에 첨부하십시오 ( &lt;a href=&quot;activeqt-idc&quot;&gt;idc&lt;/a&gt; 도구를 사용하여 )</target>
        </trans-unit>
        <trans-unit id="c298cc70af343c92bf071f6572d614dfd62dfa08" translate="yes" xml:space="preserve">
          <source>Attached ApplicationWindow Properties</source>
          <target state="translated">첨부 된 ApplicationWindow 속성</target>
        </trans-unit>
        <trans-unit id="9e4fd54e1f2cc2bae6fec6c2a9e32fae40754136" translate="yes" xml:space="preserve">
          <source>Attached Method Documentation</source>
          <target state="translated">첨부 된 방법 문서</target>
        </trans-unit>
        <trans-unit id="150bd1743209960f075ac0a1c57b68376f08c65c" translate="yes" xml:space="preserve">
          <source>Attached Methods</source>
          <target state="translated">첨부 된 방법</target>
        </trans-unit>
        <trans-unit id="3faba1cfe32a7f1b852cba99a63d5fe50092912f" translate="yes" xml:space="preserve">
          <source>Attached Properties</source>
          <target state="translated">첨부 된 속성</target>
        </trans-unit>
        <trans-unit id="80c902d12435291598f929f48b279385ca0a3b0d" translate="yes" xml:space="preserve">
          <source>Attached Properties and Attached Signal Handlers</source>
          <target state="translated">연결된 속성 및 연결된 신호 처리기</target>
        </trans-unit>
        <trans-unit id="bfcbfa74913c6275568001ba926cb2704e3623dd" translate="yes" xml:space="preserve">
          <source>Attached Property Documentation</source>
          <target state="translated">첨부 된 부동산 문서</target>
        </trans-unit>
        <trans-unit id="bb8b9dfdee571ec3e9f3e3ba64654906472d2254" translate="yes" xml:space="preserve">
          <source>Attached Signal Documentation</source>
          <target state="translated">첨부 된 신호 문서</target>
        </trans-unit>
        <trans-unit id="902d56ee4a25e198b3af081354e87bcf103345dd" translate="yes" xml:space="preserve">
          <source>Attached Signals</source>
          <target state="translated">첨부 된 신호</target>
        </trans-unit>
        <trans-unit id="acf29ce1d3e96304b4cb38421631b2162f2216d9" translate="yes" xml:space="preserve">
          <source>Attached Tool Tips</source>
          <target state="translated">첨부 된 툴 팁</target>
        </trans-unit>
        <trans-unit id="388c36c1ff81f7e8e3b22aeb32eba62b658c2e70" translate="yes" xml:space="preserve">
          <source>Attached properties</source>
          <target state="translated">첨부 된 속성</target>
        </trans-unit>
        <trans-unit id="37afe77cd72cd5e6db95e24e548bb2b97dbc77ed" translate="yes" xml:space="preserve">
          <source>Attached signal handlers</source>
          <target state="translated">연결된 신호 처리기</target>
        </trans-unit>
        <trans-unit id="9992fec490f826b162fce6589018884313693832" translate="yes" xml:space="preserve">
          <source>Attached signal handlers allow objects to be notified of particular signals that are significant to each individual object. If there was no &lt;code&gt;Component.onCompleted&lt;/code&gt; attached signal handler, for example, an object could not receive this notification without registering for some special signal from some special object. The</source>
          <target state="translated">연결된 신호 처리기를 사용하면 각 개별 객체에 중요한 특정 신호를 객체에 알릴 수 있습니다. 예를 들어 &lt;code&gt;Component.onCompleted&lt;/code&gt; 연결된 신호 처리기 가없는 경우 개체가 특정 개체의 일부 특수 신호를 등록하지 않으면이 알림을받을 수 없습니다. 그만큼</target>
        </trans-unit>
        <trans-unit id="65c3ae7a961d6d7817235589acc2c7c1bba38581" translate="yes" xml:space="preserve">
          <source>Attaches a cancellation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5ef0fc5310f47a12b45bab40e5c38eeffe0d200" translate="yes" xml:space="preserve">
          <source>Attaches a continuation to this future, allowing to chain multiple asynchronous computations if desired. When the asynchronous computation represented by this future finishes,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8da0eaca4152da7c6cf50c85444b551d8a98ad62" translate="yes" xml:space="preserve">
          <source>Attaches a continuation to this future, allowing to chain multiple asynchronous computations. When the asynchronous computation represented by this future finishes,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8448cfd0eefd78a971137085e8341d0d9b4cebc9" translate="yes" xml:space="preserve">
          <source>Attaches a failure handler to this future, to handle any exceptions that may have been generated. Returns a &lt;a href=&quot;qtcore-changes-qt6#qfuture&quot;&gt;QFuture&lt;/a&gt; of the parent type. The handler will be invoked only in case of an exception, in the same thread as the parent future has been running. If the continuation is attached after the parent has already finished, it will be invoked in the thread where the parent lives.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="303a08095e165219a3a523d9c8272527e650f836" translate="yes" xml:space="preserve">
          <source>Attaches the axis specified by</source>
          <target state="translated">로 지정된 축을 연결합니다</target>
        </trans-unit>
        <trans-unit id="d6147383a9edc19ffbb89414d19965ec36061611" translate="yes" xml:space="preserve">
          <source>Attaches the given</source>
          <target state="translated">주어진 첨부</target>
        </trans-unit>
        <trans-unit id="8ca7c853d5101c3e585dc0c3c844b74cc739c298" translate="yes" xml:space="preserve">
          <source>Attaches the legend to a chart. The chart may adjust the layout of the legend.</source>
          <target state="translated">범례를 차트에 첨부합니다. 차트는 범례의 레이아웃을 조정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f743a992bb1f15351f352fa10936d767f1629c6" translate="yes" xml:space="preserve">
          <source>Attaches the toolbar to</source>
          <target state="translated">툴바를</target>
        </trans-unit>
        <trans-unit id="ad9d9b178174db92c91a2b908169bad8da80b5b7" translate="yes" xml:space="preserve">
          <source>Attaches to the media</source>
          <target state="translated">미디어에 부착</target>
        </trans-unit>
        <trans-unit id="19df2ced91da2b546054955930b5d1c8b0dfa81d" translate="yes" xml:space="preserve">
          <source>Attaching ScrollBar to a Flickable</source>
          <target state="translated">Flickable에 ScrollBar 연결</target>
        </trans-unit>
        <trans-unit id="9b6a70298d0609d1a540e191745cea169e5e464d" translate="yes" xml:space="preserve">
          <source>Attaching ScrollIndicator to a Flickable</source>
          <target state="translated">Flickable에 ScrollIndicator 연결</target>
        </trans-unit>
        <trans-unit id="8dead67aed25f8fd7485d49ecb1f92385f2f1b68" translate="yes" xml:space="preserve">
          <source>Attaching a &lt;a href=&quot;qgraphicsvideoitem&quot;&gt;QGraphicsVideoItem&lt;/a&gt; to a &lt;a href=&quot;qmediaobject&quot;&gt;QMediaObject&lt;/a&gt; allows it to display the video or image output of that media object. A &lt;a href=&quot;qgraphicsvideoitem&quot;&gt;QGraphicsVideoItem&lt;/a&gt; is attached to a media object by passing a pointer to the &lt;a href=&quot;qmediaobject&quot;&gt;QMediaObject&lt;/a&gt; to the &lt;a href=&quot;qmediabindableinterface#setMediaObject&quot;&gt;setMediaObject&lt;/a&gt;() function.</source>
          <target state="translated">&lt;a href=&quot;qgraphicsvideoitem&quot;&gt;QGraphicsVideoItem&lt;/a&gt; 을 &lt;a href=&quot;qmediaobject&quot;&gt;QMediaObject에&lt;/a&gt; 첨부하면 해당 미디어 객체의 비디오 또는 이미지 출력을 표시 할 수 있습니다. &lt;a href=&quot;qgraphicsvideoitem&quot;&gt;QGraphicsVideoItem가&lt;/a&gt; 받는 포인터 전달하여 미디어 객체에 부착 &lt;a href=&quot;qmediaobject&quot;&gt;QMediaObject을&lt;/a&gt; 받는 &lt;a href=&quot;qmediabindableinterface#setMediaObject&quot;&gt;setMediaObject&lt;/a&gt; () 함수.</target>
        </trans-unit>
        <trans-unit id="1ab6ec34b5c35567c9a11420e8c2fe1d4d8f4d71" translate="yes" xml:space="preserve">
          <source>Attaching a &lt;a href=&quot;qvideowidget&quot;&gt;QVideoWidget&lt;/a&gt; to a &lt;a href=&quot;qmediaobject&quot;&gt;QMediaObject&lt;/a&gt; allows it to display the video or image output of that media object. A &lt;a href=&quot;qvideowidget&quot;&gt;QVideoWidget&lt;/a&gt; is attached to media object by passing a pointer to the &lt;a href=&quot;qmediaobject&quot;&gt;QMediaObject&lt;/a&gt; in its constructor, and detached by destroying the &lt;a href=&quot;qvideowidget&quot;&gt;QVideoWidget&lt;/a&gt;.</source>
          <target state="translated">부착 &lt;a href=&quot;qvideowidget&quot;&gt;QVideoWidget를&lt;/a&gt; (A)에 &lt;a href=&quot;qmediaobject&quot;&gt;QMediaObject하는&lt;/a&gt; 것이 그 미디어 객체의 비디오 또는 이미지 출력을 표시 할 수있다. &lt;a href=&quot;qvideowidget&quot;&gt;QVideoWidget가&lt;/a&gt; 받는 포인터를 통과하여 매체 객체에 부착 &lt;a href=&quot;qmediaobject&quot;&gt;QMediaObject&lt;/a&gt; 그 생성자 및 파괴하여 분리 &lt;a href=&quot;qvideowidget&quot;&gt;QVideoWidget를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5ffd44d7179311e7e62b769dda091973b2a7821a" translate="yes" xml:space="preserve">
          <source>Attaching a QGraphicsVideoItem to a &lt;a href=&quot;qmediaobject&quot;&gt;QMediaObject&lt;/a&gt; allows it to display the video or image output of that media object. A QGraphicsVideoItem is attached to a media object by passing a pointer to the &lt;a href=&quot;qmediaobject&quot;&gt;QMediaObject&lt;/a&gt; to the &lt;a href=&quot;qmediabindableinterface#setMediaObject&quot;&gt;setMediaObject&lt;/a&gt;() function.</source>
          <target state="translated">QGraphicsVideoItem을 &lt;a href=&quot;qmediaobject&quot;&gt;QMediaObject에&lt;/a&gt; 연결하면 해당 미디어 개체의 비디오 또는 이미지 출력을 표시 할 수 있습니다. QGraphicsVideoItem은 &lt;a href=&quot;qmediaobject&quot;&gt;QMediaObject&lt;/a&gt; 에 대한 포인터를 &lt;a href=&quot;qmediabindableinterface#setMediaObject&quot;&gt;setMediaObject&lt;/a&gt; () 함수 에 전달하여 미디어 개체에 연결됩니다 .</target>
        </trans-unit>
        <trans-unit id="fbbc565efe42f08bdd122dfaf6e05a1265f7711f" translate="yes" xml:space="preserve">
          <source>Attaching a QVideoWidget to a &lt;a href=&quot;qmediaobject&quot;&gt;QMediaObject&lt;/a&gt; allows it to display the video or image output of that media object. A QVideoWidget is attached to media object by passing a pointer to the &lt;a href=&quot;qmediaobject&quot;&gt;QMediaObject&lt;/a&gt; in its constructor, and detached by destroying the QVideoWidget.</source>
          <target state="translated">에 QVideoWidget 부착 &lt;a href=&quot;qmediaobject&quot;&gt;QMediaObject하는&lt;/a&gt; 것이 그 미디어 객체의 비디오 또는 이미지 출력을 표시 할 수있다. QVideoWidget은 생성자 에서 &lt;a href=&quot;qmediaobject&quot;&gt;QMediaObject&lt;/a&gt; 에 대한 포인터를 전달하여 미디어 개체에 연결되고 QVideoWidget 을 제거하여 분리됩니다.</target>
        </trans-unit>
        <trans-unit id="44226621a09bb5065e011430e6963bfb12de805f" translate="yes" xml:space="preserve">
          <source>Attaching the type library corrupted the server binary. This is a bug in Windows and happens only with release builds.</source>
          <target state="translated">형식 라이브러리를 연결하면 서버 바이너리가 손상되었습니다. 이것은 Windows의 버그이며 릴리스 빌드에서만 발생합니다.</target>
        </trans-unit>
        <trans-unit id="83a56249e5cff48f561d2d725143f1fc2eb3228c" translate="yes" xml:space="preserve">
          <source>Attachment</source>
          <target state="translated">Attachment</target>
        </trans-unit>
        <trans-unit id="c03f026fdabc6f9b4fe12426c35aa115f291994c" translate="yes" xml:space="preserve">
          <source>Attempt to decode as much as possible. For individual components of the URL, this decodes every percent encoding sequence, including control characters (U+0000 to U+001F) and UTF-8 sequences found in percent-encoded form. Use of this mode may cause data loss, see below for more information.</source>
          <target state="translated">가능한 한 디코딩을 시도하십시오. URL의 개별 구성 요소의 경우 제어 문자 (U + 0000 ~ U + 001F) 및 퍼센트 인코딩 형식으로 발견 된 UTF-8 시퀀스를 포함하여 모든 퍼센트 인코딩 시퀀스를 디코딩합니다. 이 모드를 사용하면 데이터가 손실 될 수 있습니다. 자세한 내용은 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6cbd30766494fc0c81dd3665e03daf07ea2f5b9a" translate="yes" xml:space="preserve">
          <source>Attempt to read or write from socket returned an error</source>
          <target state="translated">소켓에서 읽거나 쓰려고 시도 할 때 오류가 발생했습니다</target>
        </trans-unit>
        <trans-unit id="2ca8deb77959d3489a3621ae5b4c85fb80a51a31" translate="yes" xml:space="preserve">
          <source>Attempting to change the current value to one outside the minimum-maximum range has no effect on the current value.</source>
          <target state="translated">현재 값을 최소 최대 범위 밖의 값으로 변경하려고 시도해도 현재 값에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5fc50e04abe6136b0423ada277c77dfdbbdae74f" translate="yes" xml:space="preserve">
          <source>Attempting to declare two methods or signals with the same name in the same type block is an error. However, a new method may reuse the name of an existing method on the type. (This should be done with caution, as the existing method may be hidden and become inaccessible.)</source>
          <target state="translated">같은 타입의 블록에서 같은 이름을 가진 두 개의 메소드 나 신호를 선언하려고하면 오류가 발생합니다. 그러나 새 메소드는 유형에서 기존 메소드의 이름을 재사용 할 수 있습니다. 기존 방법이 숨겨져 서 액세스 할 수 없게되므로주의해서 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="d751bf4cf79d2324b7c47ae29a36cee6fba89adb" translate="yes" xml:space="preserve">
          <source>Attempting to declare two signals or methods with the same name in the same type block is an error. However, a new signal may reuse the name of an existing signal on the type. (This should be done with caution, as the existing signal may be hidden and become inaccessible.)</source>
          <target state="translated">같은 타입의 블록에서 같은 이름을 가진 두 개의 신호 나 메소드를 선언하려고하면 오류가 발생합니다. 그러나 새 신호는 해당 유형의 기존 신호 이름을 재사용 할 수 있습니다. (기존 신호가 숨겨져 서 액세스 할 수 없게되므로주의해서 수행해야합니다.)</target>
        </trans-unit>
        <trans-unit id="c494aed263b98d8bd4e561a02eef380289d346c8" translate="yes" xml:space="preserve">
          <source>Attempting to set the alignment to an illegal flag combination does nothing.</source>
          <target state="translated">정렬을 잘못된 플래그 조합으로 설정하려고 시도해도 아무런 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="e9e83912432691a95cd6de5d400fbd6735883fb9" translate="yes" xml:space="preserve">
          <source>Attempting to unlock a lock that is not locked is an error, and will result in program termination.</source>
          <target state="translated">잠기지 않은 잠금을 잠금 해제하려고하면 오류가 발생하여 프로그램이 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="40cb55c77af0f0fee8442a7bfdc705c6c9fa98ef" translate="yes" xml:space="preserve">
          <source>Attempts to add a new title record with title</source>
          <target state="translated">제목이있는 새 제목 레코드를 추가하려고합니다.</target>
        </trans-unit>
        <trans-unit id="a49a83143477bbe2aaa9b15d293b1789f54894b6" translate="yes" xml:space="preserve">
          <source>Attempts to add a title record</source>
          <target state="translated">타이틀 레코드 추가 시도</target>
        </trans-unit>
        <trans-unit id="75b78f9bfc8e0845fc6d273185083fbc75433f18" translate="yes" xml:space="preserve">
          <source>Attempts to allocate memory for at least</source>
          <target state="translated">최소한 메모리 할당 시도</target>
        </trans-unit>
        <trans-unit id="41717baad4c663f1fc92137bc64da06ff1152682" translate="yes" xml:space="preserve">
          <source>Attempts to attach the process to the shared memory segment identified by the key that was passed to the constructor or to a call to &lt;a href=&quot;qsharedmemory#setKey&quot;&gt;setKey&lt;/a&gt;() or &lt;a href=&quot;qsharedmemory#setNativeKey&quot;&gt;setNativeKey&lt;/a&gt;(). The access</source>
          <target state="translated">생성자에게 전달 된 키 또는 &lt;a href=&quot;qsharedmemory#setKey&quot;&gt;setKey&lt;/a&gt; () 또는 &lt;a href=&quot;qsharedmemory#setNativeKey&quot;&gt;setNativeKey&lt;/a&gt; () 에 대한 호출로 식별 된 공유 메모리 세그먼트에 프로세스를 첨부하려고 합니다 . 액세스</target>
        </trans-unit>
        <trans-unit id="64511e88279ff80ccaed16800d807495ab3d55ba" translate="yes" xml:space="preserve">
          <source>Attempts to close the socket. If there is pending data waiting to be written &lt;a href=&quot;qbluetoothsocket&quot;&gt;QBluetoothSocket&lt;/a&gt; will enter &lt;a href=&quot;qbluetoothsocket#SocketState-enum&quot;&gt;ClosingState&lt;/a&gt; and wait until all data has been written. Eventually, it will enter &lt;a href=&quot;qbluetoothsocket#SocketState-enum&quot;&gt;UnconnectedState&lt;/a&gt; and emit the &lt;a href=&quot;qbluetoothsocket#disconnected&quot;&gt;disconnected&lt;/a&gt;() signal.</source>
          <target state="translated">소켓을 닫으려고합니다. 쓰기 대기중인 데이터가있는 경우 &lt;a href=&quot;qbluetoothsocket&quot;&gt;QBluetoothSocket&lt;/a&gt; 은 &lt;a href=&quot;qbluetoothsocket#SocketState-enum&quot;&gt;ClosingState에&lt;/a&gt; 들어가 모든 데이터가 작성 될 때까지 기다립니다. 결국, 이는 입력한다 &lt;a href=&quot;qbluetoothsocket#SocketState-enum&quot;&gt;UnconnectedState를&lt;/a&gt; 상기 발광 &lt;a href=&quot;qbluetoothsocket#disconnected&quot;&gt;끊긴&lt;/a&gt; () 신호.</target>
        </trans-unit>
        <trans-unit id="b14c101853294961a9915ce2a73be7191c42b775" translate="yes" xml:space="preserve">
          <source>Attempts to close the socket. If there is pending data waiting to be written, &lt;a href=&quot;qabstractsocket&quot;&gt;QAbstractSocket&lt;/a&gt; will enter &lt;a href=&quot;qabstractsocket#SocketState-enum&quot;&gt;ClosingState&lt;/a&gt; and wait until all data has been written. Eventually, it will enter &lt;a href=&quot;qabstractsocket#SocketState-enum&quot;&gt;UnconnectedState&lt;/a&gt; and emit the &lt;a href=&quot;qabstractsocket#disconnected&quot;&gt;disconnected&lt;/a&gt;() signal.</source>
          <target state="translated">소켓을 닫으려고합니다. 쓰기 대기중인 데이터가있는 경우 &lt;a href=&quot;qabstractsocket&quot;&gt;QAbstractSocket&lt;/a&gt; 은 &lt;a href=&quot;qabstractsocket#SocketState-enum&quot;&gt;ClosingState에&lt;/a&gt; 들어가 모든 데이터가 작성 될 때까지 기다립니다. 결국, 이는 입력한다 &lt;a href=&quot;qabstractsocket#SocketState-enum&quot;&gt;UnconnectedState를&lt;/a&gt; 상기 발광 &lt;a href=&quot;qabstractsocket#disconnected&quot;&gt;끊긴&lt;/a&gt; () 신호.</target>
        </trans-unit>
        <trans-unit id="0cd1c41157c1d345e418d08f0ddd434ac79fa257" translate="yes" xml:space="preserve">
          <source>Attempts to close the socket. If there is pending data waiting to be written, &lt;a href=&quot;qlocalsocket&quot;&gt;QLocalSocket&lt;/a&gt; will enter &lt;a href=&quot;qlocalsocket#LocalSocketState-enum&quot;&gt;ClosingState&lt;/a&gt; and wait until all data has been written. Eventually, it will enter &lt;a href=&quot;qlocalsocket#LocalSocketState-enum&quot;&gt;UnconnectedState&lt;/a&gt; and emit the disconnectedFromServer() signal.</source>
          <target state="translated">소켓을 닫으려고합니다. 쓰기 대기중인 데이터가있는 경우 &lt;a href=&quot;qlocalsocket&quot;&gt;QLocalSocket&lt;/a&gt; 은 &lt;a href=&quot;qlocalsocket#LocalSocketState-enum&quot;&gt;ClosingState에&lt;/a&gt; 들어가 모든 데이터가 작성 될 때까지 기다립니다. 결국 &lt;a href=&quot;qlocalsocket#LocalSocketState-enum&quot;&gt;UnconnectedState로&lt;/a&gt; 들어가 disconnectedFromServer () 신호를 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="9916f61f2e95462623791d2de738f69eec08995b" translate="yes" xml:space="preserve">
          <source>Attempts to connect to the service described by</source>
          <target state="translated">에 의해 설명 된 서비스에 연결을 시도합니다</target>
        </trans-unit>
        <trans-unit id="88bd2a20888118107b44b77e054ae21e0dc25925" translate="yes" xml:space="preserve">
          <source>Attempts to create a texture view onto this texture. A texture view is somewhat analogous to a view in SQL in that it presents a restricted or reinterpreted view of the original data. Texture views do not allocate any more server-side storage, insted relying on the storage buffer of the source texture.</source>
          <target state="translated">이 텍스처에 텍스처 뷰를 작성하려고합니다. 텍스처 뷰는 원본 데이터의 제한된 뷰 또는 해석 된 뷰를 제공한다는 점에서 SQL의 뷰와 다소 유사합니다. 텍스처 뷰는 소스 텍스처의 스토리지 버퍼에 의존하여 더 이상 서버 측 스토리지를 할당하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a5135f0e103c8d9400561f2d503910a4bc82cff5" translate="yes" xml:space="preserve">
          <source>Attempts to create the OpenGL context with the current configuration.</source>
          <target state="translated">현재 구성으로 OpenGL 컨텍스트를 작성하려고합니다.</target>
        </trans-unit>
        <trans-unit id="b79e8ad7521f57df617cbd803646947bba56a32b" translate="yes" xml:space="preserve">
          <source>Attempts to create the lock file. This function returns &lt;code&gt;true&lt;/code&gt; if the lock was obtained; otherwise it returns &lt;code&gt;false&lt;/code&gt;. If another process (or another thread) has created the lock file already, this function will wait for at most</source>
          <target state="translated">잠금 파일을 작성하려고합니다. 잠금이 확보되면 이 함수는 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 . 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 . 다른 프로세스 (또는 다른 스레드)가 이미 잠금 파일을 작성한 경우이 함수는 최대 대기합니다.</target>
        </trans-unit>
        <trans-unit id="1007b5514cb8c7a3d4bf7da1cf7389f0861c2fc5" translate="yes" xml:space="preserve">
          <source>Attempts to delete this object's property of the given</source>
          <target state="translated">주어진이 객체의 속성을 삭제하려고 시도</target>
        </trans-unit>
        <trans-unit id="decebf66e3192ac44c25be7fc03e4031b12d88d2" translate="yes" xml:space="preserve">
          <source>Attempts to demarshall the contents of</source>
          <target state="translated">의 내용을 demarshall하려고합니다</target>
        </trans-unit>
        <trans-unit id="e933c7654c609a16b70a849f0259c88d1f226b37" translate="yes" xml:space="preserve">
          <source>Attempts to evaluate the query and returns the results in the</source>
          <target state="translated">검색어 평가를 시도하고 결과를</target>
        </trans-unit>
        <trans-unit id="b93aafd2c488fbd4f7028d8928d462f6f573c83f" translate="yes" xml:space="preserve">
          <source>Attempts to find a match backwards in</source>
          <target state="translated">에서 뒤로 일치하는 항목을 찾으려고합니다</target>
        </trans-unit>
        <trans-unit id="ccea7bbd5134887c359bf2454e1a7bdaf25db03e" translate="yes" xml:space="preserve">
          <source>Attempts to find a match in</source>
          <target state="translated">에서 일치하는 것을 찾으려고 시도</target>
        </trans-unit>
        <trans-unit id="8d399c1dfc647f9aec0390f27281e7ea7daa7a29" translate="yes" xml:space="preserve">
          <source>Attempts to forcefully remove an existing lock file.</source>
          <target state="translated">기존 잠금 파일을 강제로 제거하려고합니다.</target>
        </trans-unit>
        <trans-unit id="7ce1b4b5c465ce608a87c1b2bd26a5811a578030" translate="yes" xml:space="preserve">
          <source>Attempts to get the current position and emit &lt;a href=&quot;qgeopositioninfosource#positionUpdated&quot;&gt;positionUpdated&lt;/a&gt;() with this information. If the current position cannot be found within the given</source>
          <target state="translated">이 정보를 사용 하여 현재 위치를 가져오고 &lt;a href=&quot;qgeopositioninfosource#positionUpdated&quot;&gt;positionUpdated&lt;/a&gt; () 를 내 보냅니다 . 주어진 위치에서 현재 위치를 찾을 수없는 경우</target>
        </trans-unit>
        <trans-unit id="6d134c0b9da77afde32ce31bce2c2918299f81a4" translate="yes" xml:space="preserve">
          <source>Attempts to get the current satellite information and emit &lt;a href=&quot;qgeosatelliteinfosource#satellitesInViewUpdated&quot;&gt;satellitesInViewUpdated&lt;/a&gt;() and &lt;a href=&quot;qgeosatelliteinfosource#satellitesInUseUpdated&quot;&gt;satellitesInUseUpdated&lt;/a&gt;() with this information. If the current satellite information cannot be found within the given</source>
          <target state="translated">이 정보를 사용하여 현재 위성 정보를 가져오고 &lt;a href=&quot;qgeosatelliteinfosource#satellitesInViewUpdated&quot;&gt;satellitesInViewUpdated&lt;/a&gt; () 및 &lt;a href=&quot;qgeosatelliteinfosource#satellitesInUseUpdated&quot;&gt;satellitesInUseUpdated&lt;/a&gt; ()를 방출하려고합니다 . 주어진 위성에서 현재 위성 정보를 찾을 수없는 경우</target>
        </trans-unit>
        <trans-unit id="13496e0a5f0c2d09c9911476f5b19b0694a84d47" translate="yes" xml:space="preserve">
          <source>Attempts to load the document at the given</source>
          <target state="translated">주어진 위치에 문서를로드하려고합니다.</target>
        </trans-unit>
        <trans-unit id="c661d770bd92fabd6239ee47e0bdabc00a179fe5" translate="yes" xml:space="preserve">
          <source>Attempts to lock for reading. If the lock was obtained, this function returns &lt;code&gt;true&lt;/code&gt;, otherwise it returns &lt;code&gt;false&lt;/code&gt; instead of waiting for the lock to become available, i.e. it does not block.</source>
          <target state="translated">읽기 위해 잠금을 시도합니다. 잠금을 얻은 경우이 함수는 &lt;code&gt;true&lt;/code&gt; 를 반환 하고 , 그렇지 않으면 잠금을 사용할 수있을 때까지 기다리지 않고 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="1a88fb80382d1217416d7e840e918cf20b354b6e" translate="yes" xml:space="preserve">
          <source>Attempts to lock for reading. This function returns &lt;code&gt;true&lt;/code&gt; if the lock was obtained; otherwise it returns &lt;code&gt;false&lt;/code&gt;. If another thread has locked for writing, this function will wait for at most</source>
          <target state="translated">읽기 위해 잠금을 시도합니다. 잠금이 확보되면 이 함수는 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 . 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 . 다른 스레드가 쓰기를 위해 잠긴 경우이 함수는 최대 대기합니다</target>
        </trans-unit>
        <trans-unit id="cf2470f484acf6d1012c9c2ef2b5aa8b479942c2" translate="yes" xml:space="preserve">
          <source>Attempts to lock for writing. If the lock was obtained, this function returns &lt;code&gt;true&lt;/code&gt;; otherwise, it returns &lt;code&gt;false&lt;/code&gt; immediately.</source>
          <target state="translated">쓰기 위해 잠금을 시도합니다. 잠금이 확보되면이 함수는 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 . 그렇지 않으면 즉시 &lt;code&gt;false&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="7d129c86a278c6f36b5ce06526519d0734d9305e" translate="yes" xml:space="preserve">
          <source>Attempts to lock for writing. This function returns &lt;code&gt;true&lt;/code&gt; if the lock was obtained; otherwise it returns &lt;code&gt;false&lt;/code&gt;. If another thread has locked for reading or writing, this function will wait for at most</source>
          <target state="translated">쓰기 위해 잠금을 시도합니다. 잠금이 확보되면 이 함수는 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 . 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 . 다른 스레드가 읽기 또는 쓰기를 위해 잠긴 경우이 기능은 최대 대기합니다</target>
        </trans-unit>
        <trans-unit id="9851042db5ee3d962c0e65a9574ee566e3b802f8" translate="yes" xml:space="preserve">
          <source>Attempts to lock the mutex. This function returns &lt;code&gt;true&lt;/code&gt; if the lock was obtained; otherwise it returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">뮤텍스를 잠그려고 시도합니다. 잠금이 확보되면 이 함수는 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 . 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="b54242a9aaaa9390b8315d197dfc5e23adc00c96" translate="yes" xml:space="preserve">
          <source>Attempts to lock the mutex. This function returns &lt;code&gt;true&lt;/code&gt; if the lock was obtained; otherwise it returns &lt;code&gt;false&lt;/code&gt;. If another thread has locked the mutex, this function will wait at least until</source>
          <target state="translated">뮤텍스를 잠그려고 시도합니다. 잠금이 확보되면 이 함수는 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 . 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 . 다른 스레드가 뮤텍스를 잠근 경우이 함수는 최소한</target>
        </trans-unit>
        <trans-unit id="103992881af09741dd2a74bdd8c2881ef04d0de6" translate="yes" xml:space="preserve">
          <source>Attempts to lock the mutex. This function returns &lt;code&gt;true&lt;/code&gt; if the lock was obtained; otherwise it returns &lt;code&gt;false&lt;/code&gt;. If another thread has locked the mutex, this function will wait for at least</source>
          <target state="translated">뮤텍스를 잠그려고 시도합니다. 잠금이 확보되면 이 함수는 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 . 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 . 다른 스레드가 뮤텍스를 잠근 경우이 함수는 최소한 기다립니다.</target>
        </trans-unit>
        <trans-unit id="0c0e3bf6432ce7cc59a4892d1e1402cde84f85c9" translate="yes" xml:space="preserve">
          <source>Attempts to lock the mutex. This function returns &lt;code&gt;true&lt;/code&gt; if the lock was obtained; otherwise it returns &lt;code&gt;false&lt;/code&gt;. If another thread has locked the mutex, this function will wait for at most</source>
          <target state="translated">뮤텍스를 잠그려고 시도합니다. 잠금이 확보되면 이 함수는 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 . 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 . 다른 스레드가 뮤텍스를 잠근 경우이 함수는 최대 대기합니다</target>
        </trans-unit>
        <trans-unit id="e1cb921a9773a0e3cb28330bf381ade1b5f5db2d" translate="yes" xml:space="preserve">
          <source>Attempts to make a connection to</source>
          <target state="translated">에 연결을 시도</target>
        </trans-unit>
        <trans-unit id="99e61f7fb0798c2e70b54a7fb64150be665b1a4d" translate="yes" xml:space="preserve">
          <source>Attempts to make a connection to &lt;a href=&quot;qlocalsocket#serverName&quot;&gt;serverName&lt;/a&gt;(). &lt;a href=&quot;qlocalsocket#setServerName&quot;&gt;setServerName&lt;/a&gt;() must be called before you open the connection. Alternatively you can use connectToServer(const &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; &amp;amp;name, &lt;a href=&quot;qiodevice#OpenModeFlag-enum&quot;&gt;OpenMode&lt;/a&gt;&lt;a href=&quot;qiodevice#openMode&quot;&gt;openMode&lt;/a&gt;);</source>
          <target state="translated">&lt;a href=&quot;qlocalsocket#serverName&quot;&gt;serverName&lt;/a&gt; ()에 연결을 시도합니다 . 연결을 열기 전에 &lt;a href=&quot;qlocalsocket#setServerName&quot;&gt;setServerName&lt;/a&gt; ()을 호출해야합니다. 또는 connectToServer (const &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; &amp;amp; name, &lt;a href=&quot;qiodevice#OpenModeFlag-enum&quot;&gt;OpenMode &lt;/a&gt;&lt;a href=&quot;qiodevice#openMode&quot;&gt;openMode&lt;/a&gt; )를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="03e01069d8b36d9b174aa4290c72a2c4bd99725e" translate="yes" xml:space="preserve">
          <source>Attempts to make a connection to &lt;a href=&quot;qlocalsocket#serverName&quot;&gt;serverName&lt;/a&gt;(). &lt;a href=&quot;qlocalsocket#setServerName&quot;&gt;setServerName&lt;/a&gt;() must be called before you open the connection. Alternatively you can use connectToServer(const &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; &amp;amp;name, &lt;a href=&quot;qiodevicebase#OpenModeFlag-enum&quot;&gt;OpenMode&lt;/a&gt;&lt;a href=&quot;qiodevice#openMode&quot;&gt;openMode&lt;/a&gt;);</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1467e681088cb474f58c2843b2c55e1b6c057e5" translate="yes" xml:space="preserve">
          <source>Attempts to make a connection to the service identified by</source>
          <target state="translated">로 식별 된 서비스에 연결을 시도합니다.</target>
        </trans-unit>
        <trans-unit id="0a29c67e1524a0c689e5acb8ba6c9a244b1553ed" translate="yes" xml:space="preserve">
          <source>Attempts to make a connection with</source>
          <target state="translated">연결 시도</target>
        </trans-unit>
        <trans-unit id="3c9e3f8d7f41891e3dd9b073506b0acef887099f" translate="yes" xml:space="preserve">
          <source>Attempts to match the regular expression against the given</source>
          <target state="translated">주어진 정규 표현식과 정규 표현식을 일치 시키려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="199c89b542aa478a5fa190747ea0f479710986f8" translate="yes" xml:space="preserve">
          <source>Attempts to merge this command with</source>
          <target state="translated">이 명령을</target>
        </trans-unit>
        <trans-unit id="f5ca5e2e9e9711a045a32c07f9152d8ad5139924" translate="yes" xml:space="preserve">
          <source>Attempts to open the specified</source>
          <target state="translated">지정된 열기를 시도합니다.</target>
        </trans-unit>
        <trans-unit id="3f8cb926a2a676e8deb6f8891853236af8c54288" translate="yes" xml:space="preserve">
          <source>Attempts to open the specified &lt;code&gt;target&lt;/code&gt; url in an external application, based on the user's desktop preferences. Returns true if it succeeds, and false otherwise.</source>
          <target state="translated">사용자의 데스크탑 환경 설정에 따라 외부 애플리케이션에서 지정된 &lt;code&gt;target&lt;/code&gt; URL 을 열려고 시도합니다 . 성공하면 true를, 그렇지 않으면 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6b71a6b8e24475e656383f1eb601022febdb5466" translate="yes" xml:space="preserve">
          <source>Attempts to perform a global match of the regular expression against the given</source>
          <target state="translated">주어진 정규 표현식에 대해 전체 정규 일치를 수행하려고합니다.</target>
        </trans-unit>
        <trans-unit id="9e19969ea4102dfc32af2b95d7cfe00304c63846" translate="yes" xml:space="preserve">
          <source>Attempts to read a buffer from the decoder, without blocking. Returns invalid buffer if there are no decoded buffers available, or on error.</source>
          <target state="translated">차단하지 않고 디코더에서 버퍼를 읽으려고 시도합니다. 사용 가능한 디코딩 된 버퍼가 없거나 오류가 발생하면 유효하지 않은 버퍼를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="670d36fb9755e6a0b702b6f1e33679b28e4e6152" translate="yes" xml:space="preserve">
          <source>Attempts to register the</source>
          <target state="translated">등록을 시도합니다</target>
        </trans-unit>
        <trans-unit id="cddf114bca27d7c29aa865e757e1a437c1e25fe6" translate="yes" xml:space="preserve">
          <source>Attempts to register the requested service, but do not try to replace it if another application already has it registered. Instead, simply put this application in queue, until it is given up. The &lt;a href=&quot;qdbusconnectioninterface#serviceRegistered&quot;&gt;serviceRegistered&lt;/a&gt;() signal will be emitted when that happens.</source>
          <target state="translated">요청한 서비스를 등록하려고 시도하지만 다른 응용 프로그램에 이미 등록 된 경우 교체하지 마십시오. 대신,이 응용 프로그램은 포기 될 때까지 대기열에 넣습니다. &lt;a href=&quot;qdbusconnectioninterface#serviceRegistered&quot;&gt;serviceRegistered&lt;/a&gt; 그렇게되면 () 신호를 방출한다.</target>
        </trans-unit>
        <trans-unit id="f2b74e4114e69652b3992fc01f39f461b14f78e5" translate="yes" xml:space="preserve">
          <source>Attempts to remove a title record with locale</source>
          <target state="translated">로케일로 제목 레코드를 제거하려고합니다.</target>
        </trans-unit>
        <trans-unit id="82cbc15d0be68a7a78605443ef53d19a8213c78a" translate="yes" xml:space="preserve">
          <source>Attempts to remove the icon record</source>
          <target state="translated">아이콘 레코드 제거 시도</target>
        </trans-unit>
        <trans-unit id="4cb9a4d74dba9e00fa899b614fac66cc8f2f9bfe" translate="yes" xml:space="preserve">
          <source>Attempts to remove the icon record with type</source>
          <target state="translated">유형이있는 아이콘 레코드를 제거하려고합니다.</target>
        </trans-unit>
        <trans-unit id="0fb0d400d4a26ed57afecebd971943ed09efeb83" translate="yes" xml:space="preserve">
          <source>Attempts to remove the specified</source>
          <target state="translated">지정된 제거 시도</target>
        </trans-unit>
        <trans-unit id="12126a205886d0344e790e10215c18688e51e51f" translate="yes" xml:space="preserve">
          <source>Attempts to remove the title record</source>
          <target state="translated">제목 레코드를 제거하려고합니다</target>
        </trans-unit>
        <trans-unit id="0c33a64cf188b3a0d62ad7fc2529abc93b373402" translate="yes" xml:space="preserve">
          <source>Attempts to reserve a thread to run</source>
          <target state="translated">실행할 스레드 예약을 시도합니다</target>
        </trans-unit>
        <trans-unit id="64f145a00700926a58301a1d1bfc05bfa6c811f9" translate="yes" xml:space="preserve">
          <source>Attempts to terminate the process.</source>
          <target state="translated">프로세스 종료를 시도합니다.</target>
        </trans-unit>
        <trans-unit id="2df234e38b53a6b85ab548b0f180e7f029345963" translate="yes" xml:space="preserve">
          <source>Attenuation factor is calculated as below:</source>
          <target state="translated">감쇠 계수는 다음과 같이 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="09ad0179f653d81ba82ebd5e6c304d2ba9661515" translate="yes" xml:space="preserve">
          <source>AttenuationModelInverse (QML type)</source>
          <target state="translated">AttenuationModelInverse (QML 유형)</target>
        </trans-unit>
        <trans-unit id="ce89ccd0582bca1e1fc517efde91f8aeb75cf3e7" translate="yes" xml:space="preserve">
          <source>AttenuationModelInverse QML Type</source>
          <target state="translated">감쇠 모델 역 QML 유형</target>
        </trans-unit>
        <trans-unit id="442ad9ab30cc31c79e31a7177437263f69ad3daf" translate="yes" xml:space="preserve">
          <source>AttenuationModelInverse must be defined inside &lt;a href=&quot;qml-qtaudioengine-audioengine&quot;&gt;AudioEngine&lt;/a&gt; or be added to it using &lt;a href=&quot;qml-qtaudioengine-audioengine#addAttenuationModel-method&quot;&gt;AudioEngine.addAttenuationModel()&lt;/a&gt; if AttenuationModelInverse is created dynamically.</source>
          <target state="translated">AttenuationModelInverse는 &lt;a href=&quot;qml-qtaudioengine-audioengine&quot;&gt;AudioEngine&lt;/a&gt; 내부에 정의 되거나 AttenuationModelInverse가 동적으로 생성 된 경우 &lt;a href=&quot;qml-qtaudioengine-audioengine#addAttenuationModel-method&quot;&gt;AudioEngine.addAttenuationModel ()을&lt;/a&gt; 사용하여 추가되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="c8d22061e6bb72bae9090fae777f3aea070b6641" translate="yes" xml:space="preserve">
          <source>AttenuationModelInverse.end</source>
          <target state="translated">AttenuationModelInverse.end</target>
        </trans-unit>
        <trans-unit id="266a29a9f12223908aaa4bbd5935ee21a3f41418" translate="yes" xml:space="preserve">
          <source>AttenuationModelInverse.name</source>
          <target state="translated">AttenuationModelInverse.name</target>
        </trans-unit>
        <trans-unit id="d86aea538c0ada6639b238773dead9a47b8fe335" translate="yes" xml:space="preserve">
          <source>AttenuationModelInverse.rolloff</source>
          <target state="translated">AttenuationModelInverse.rolloff</target>
        </trans-unit>
        <trans-unit id="6bb671e72bb2861d1af041541e0b48c8935c54b8" translate="yes" xml:space="preserve">
          <source>AttenuationModelInverse.start</source>
          <target state="translated">AttenuationModelInverse.start</target>
        </trans-unit>
        <trans-unit id="b05e207d203b95883d220de8646e6c56a3d90057" translate="yes" xml:space="preserve">
          <source>AttenuationModelLinear (QML type)</source>
          <target state="translated">AttenuationModelLinear (QML 유형)</target>
        </trans-unit>
        <trans-unit id="60f353471e9c991e94cc0fae75ecd0e90354af2e" translate="yes" xml:space="preserve">
          <source>AttenuationModelLinear QML Type</source>
          <target state="translated">감쇠 모델 선형 QML 유형</target>
        </trans-unit>
        <trans-unit id="577623c3ccfedc54a92eee6a2374849743dae9dd" translate="yes" xml:space="preserve">
          <source>AttenuationModelLinear must be defined inside &lt;a href=&quot;qml-qtaudioengine-audioengine&quot;&gt;AudioEngine&lt;/a&gt; or be added to it using &lt;a href=&quot;qml-qtaudioengine-audioengine#addAttenuationModel-method&quot;&gt;AudioEngine.addAttenuationModel()&lt;/a&gt; if AttenuationModelLinear is created dynamically.</source>
          <target state="translated">AttenuationModelLinear는 &lt;a href=&quot;qml-qtaudioengine-audioengine&quot;&gt;AudioEngine&lt;/a&gt; 내부에 정의 되거나 AttenuationModelLinear가 동적으로 생성 된 경우 &lt;a href=&quot;qml-qtaudioengine-audioengine#addAttenuationModel-method&quot;&gt;AudioEngine.addAttenuationModel ()을&lt;/a&gt; 사용하여 추가되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="82b657d75de2579616f22d7ba172386048e8c8bd" translate="yes" xml:space="preserve">
          <source>AttenuationModelLinear.end</source>
          <target state="translated">AttenuationModelLinear.end</target>
        </trans-unit>
        <trans-unit id="42f4c1e185f05e010f031ba39647493e2323fa4f" translate="yes" xml:space="preserve">
          <source>AttenuationModelLinear.name</source>
          <target state="translated">AttenuationModelLinear.name</target>
        </trans-unit>
        <trans-unit id="1806984104313153d03add27475b3c0f86426d25" translate="yes" xml:space="preserve">
          <source>AttenuationModelLinear.start</source>
          <target state="translated">AttenuationModelLinear.start</target>
        </trans-unit>
        <trans-unit id="30f3de5d0f4d3d3444d01af4ba6d6b47140da0b9" translate="yes" xml:space="preserve">
          <source>Attibute changes when any other service attribute is added, deleted or modified.</source>
          <target state="translated">다른 서비스 속성이 추가, 삭제 또는 수정되면 Attibute가 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="296f046445dbe582b91f5aa136868365544ef00c" translate="yes" xml:space="preserve">
          <source>Attractor (QML type)</source>
          <target state="translated">어 트랙터 (QML 타입)</target>
        </trans-unit>
        <trans-unit id="6424677894dc22d22b25d8d17084b49e81b998ac" translate="yes" xml:space="preserve">
          <source>Attractor QML Type</source>
          <target state="translated">어 트랙터 QML 유형</target>
        </trans-unit>
        <trans-unit id="37e91bdd60c4c6d50a3df710ed09f06a581d07c9" translate="yes" xml:space="preserve">
          <source>Attractor.Acceleration</source>
          <target state="translated">Attractor.Acceleration</target>
        </trans-unit>
        <trans-unit id="3450f62291cb4940a34a0eb2583dda39ee0a8006" translate="yes" xml:space="preserve">
          <source>Attractor.Constant</source>
          <target state="translated">Attractor.Constant</target>
        </trans-unit>
        <trans-unit id="523c31ea9a46e9394e0c97eca30413df375af83b" translate="yes" xml:space="preserve">
          <source>Attractor.InverseLinear</source>
          <target state="translated">Attractor.InverseLinear</target>
        </trans-unit>
        <trans-unit id="550f4308046218c9d3997b7a1095de56a6bef398" translate="yes" xml:space="preserve">
          <source>Attractor.InverseQuadratic</source>
          <target state="translated">Attractor.InverseQuadratic</target>
        </trans-unit>
        <trans-unit id="eef61e37501774843c8a62fd051143c6aaee899b" translate="yes" xml:space="preserve">
          <source>Attractor.Linear</source>
          <target state="translated">Attractor.Linear</target>
        </trans-unit>
        <trans-unit id="b769d90573cbe30f194df15d878d14f75f263699" translate="yes" xml:space="preserve">
          <source>Attractor.Position</source>
          <target state="translated">Attractor.Position</target>
        </trans-unit>
        <trans-unit id="299bf07566b49ce0997d38501136b507e8c16f6e" translate="yes" xml:space="preserve">
          <source>Attractor.Quadratic</source>
          <target state="translated">Attractor.Quadratic</target>
        </trans-unit>
        <trans-unit id="427cc833289066553dd79e0e28d4749ca5bc4070" translate="yes" xml:space="preserve">
          <source>Attractor.Velocity</source>
          <target state="translated">Attractor.Velocity</target>
        </trans-unit>
        <trans-unit id="4c87b9b41fb26d8f52a9706ac5181e6eb8b6b77f" translate="yes" xml:space="preserve">
          <source>Attractor.affectedParameter</source>
          <target state="translated">Attractor.affectedParameter</target>
        </trans-unit>
        <trans-unit id="7a1b7d6854a28d0edaa4635ca87a1f0dade8f683" translate="yes" xml:space="preserve">
          <source>Attractor.proportionalToDistance</source>
          <target state="translated">Attractor.proportionalToDistance</target>
        </trans-unit>
        <trans-unit id="a086d942884a301b827479029ba19c2746237425" translate="yes" xml:space="preserve">
          <source>Attribute</source>
          <target state="translated">Attribute</target>
        </trans-unit>
        <trans-unit id="ccc5cf4a1d9e54a958908f4ae2479773cc555b20" translate="yes" xml:space="preserve">
          <source>Attribute (QML type)</source>
          <target state="translated">속성 (QML 유형)</target>
        </trans-unit>
        <trans-unit id="fe462099fbeb57d289ce57cd51b118b84d30152b" translate="yes" xml:space="preserve">
          <source>Attribute Class</source>
          <target state="translated">속성 클래스</target>
        </trans-unit>
        <trans-unit id="75ea40b4d4d812c5a6cc40ab6740ed2f0ffffecf" translate="yes" xml:space="preserve">
          <source>Attribute Node</source>
          <target state="translated">속성 노드</target>
        </trans-unit>
        <trans-unit id="bb1ec77d2af9d172537986d4c44c207dd6b101fe" translate="yes" xml:space="preserve">
          <source>Attribute Nodes</source>
          <target state="translated">속성 노드</target>
        </trans-unit>
        <trans-unit id="c3b5ca640bea37921e1d4fcc6cfcf47b830e2c76" translate="yes" xml:space="preserve">
          <source>Attribute QML Type</source>
          <target state="translated">속성 QML 유형</target>
        </trans-unit>
        <trans-unit id="b75fbc526e507c536f15818a635fabc424d8bb9f" translate="yes" xml:space="preserve">
          <source>Attribute Struct</source>
          <target state="translated">속성 구조</target>
        </trans-unit>
        <trans-unit id="9f4f7e4e3b34c76cbba2b04d073edb6d2fe857a8" translate="yes" xml:space="preserve">
          <source>Attribute Types</source>
          <target state="translated">속성 유형</target>
        </trans-unit>
        <trans-unit id="c934b9aa0ce3e9181f546dd3f2f1c3c3122aef7f" translate="yes" xml:space="preserve">
          <source>Attribute codes for &lt;a href=&quot;qbluetoothtransferrequest&quot;&gt;QBluetoothTransferRequest&lt;/a&gt; and &lt;a href=&quot;qbluetoothtransferreply&quot;&gt;QBluetoothTransferReply&lt;/a&gt;.</source>
          <target state="translated">에 대한 속성 코드 &lt;a href=&quot;qbluetoothtransferrequest&quot;&gt;QBluetoothTransferRequest&lt;/a&gt; 및 &lt;a href=&quot;qbluetoothtransferreply&quot;&gt;QBluetoothTransferReply&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a0acd5562d8332a5210e9cd9fd1780c7a7e346ef" translate="yes" xml:space="preserve">
          <source>Attribute codes for the &lt;a href=&quot;qnetworkrequest&quot;&gt;QNetworkRequest&lt;/a&gt; and &lt;a href=&quot;qnetworkreply&quot;&gt;QNetworkReply&lt;/a&gt;.</source>
          <target state="translated">에 대한 속성 코드 &lt;a href=&quot;qnetworkrequest&quot;&gt;QNetworkRequest&lt;/a&gt; 및 &lt;a href=&quot;qnetworkreply&quot;&gt;QNetworkReply&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f836508c2fb47e8d7e608a9c9a617b59d23ac7a6" translate="yes" xml:space="preserve">
          <source>Attribute protocol UUID</source>
          <target state="translated">속성 프로토콜 UUID</target>
        </trans-unit>
        <trans-unit id="e8aa585451eaa1f17032c02ff21f96d5a727df6d" translate="yes" xml:space="preserve">
          <source>Attribute values will be normalized. For example &lt;code&gt;&amp;lt;tag attr=&quot; a \n b &quot; /&amp;gt;&lt;/code&gt; will be equivalent to &lt;code&gt;&amp;lt;tag attr=&quot;a b&quot;/&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bdefcbfbf5c315c26fce867e5c029439ea81fd1" translate="yes" xml:space="preserve">
          <source>Attribute::Attribute(&lt;a href=&quot;qinputmethodevent#AttributeType-enum&quot;&gt;AttributeType&lt;/a&gt;</source>
          <target state="translated">Attribute::Attribute(&lt;a href=&quot;qinputmethodevent#AttributeType-enum&quot;&gt;AttributeType&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9bbf89753a05176fba5ab45059f847ee3b49ce26" translate="yes" xml:space="preserve">
          <source>Attribute::create()</source>
          <target state="translated">Attribute::create()</target>
        </trans-unit>
        <trans-unit id="4ec68433220a996a291d7abae73f2f65290d791a" translate="yes" xml:space="preserve">
          <source>Attribute::createWithAttributeType()</source>
          <target state="translated">Attribute::createWithAttributeType()</target>
        </trans-unit>
        <trans-unit id="b75a077312c8345d35851cf8e5f1bd3719959ae8" translate="yes" xml:space="preserve">
          <source>AttributeSet Struct</source>
          <target state="translated">특성 집합 구조</target>
        </trans-unit>
        <trans-unit id="5a918eacf77c88cdbb1cc9b8fa49436644e5a6fc" translate="yes" xml:space="preserve">
          <source>Attributes are extra meta-data that are used to control the behavior of the request and to pass further information from the reply back to the application. Attributes are also extensible, allowing custom implementations to pass custom values.</source>
          <target state="translated">속성은 요청의 동작을 제어하고 추가 정보를 회신에서 애플리케이션으로 다시 전달하는 데 사용되는 추가 메타 데이터입니다. 속성도 확장 가능하므로 사용자 정의 구현이 사용자 정의 값을 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c81d1b952a40253bd4ee2fbac757715587dc33f" translate="yes" xml:space="preserve">
          <source>Attributes are returned by a &lt;a href=&quot;qxmlstreamreader&quot;&gt;QXmlStreamReader&lt;/a&gt; in &lt;a href=&quot;qxmlstreamreader#attributes&quot;&gt;attributes()&lt;/a&gt; when the reader reports a &lt;a href=&quot;qxmlstreamreader#TokenType-enum&quot;&gt;start element&lt;/a&gt;. The class can also be used with a &lt;a href=&quot;qxmlstreamwriter&quot;&gt;QXmlStreamWriter&lt;/a&gt; as an argument to &lt;a href=&quot;qxmlstreamwriter#writeAttributes&quot;&gt;writeAttributes()&lt;/a&gt;.</source>
          <target state="translated">리더가 &lt;a href=&quot;qxmlstreamreader#TokenType-enum&quot;&gt;시작 요소를&lt;/a&gt; 보고 할 때 &lt;a href=&quot;qxmlstreamreader#attributes&quot;&gt;attributes ()&lt;/a&gt; 의 &lt;a href=&quot;qxmlstreamreader&quot;&gt;QXmlStreamReader&lt;/a&gt; 가 속성을 리턴합니다 . 이 클래스는 &lt;a href=&quot;qxmlstreamwriter&quot;&gt;QXmlStreamWriter&lt;/a&gt; 와 함께 &lt;a href=&quot;qxmlstreamwriter#writeAttributes&quot;&gt;writeAttributes ()&lt;/a&gt; 의 인수로 사용될 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fc8f36e82eac647fe22f284d2df1a924c673bc26" translate="yes" xml:space="preserve">
          <source>Attributes for which &lt;a href=&quot;qdomattr#specified&quot;&gt;QDomAttr::specified&lt;/a&gt;() is true are also imported, other attributes are not imported. If</source>
          <target state="translated">하는 속성 &lt;a href=&quot;qdomattr#specified&quot;&gt;QDomAttr이 :: 지정은&lt;/a&gt; ()도 수입 사실, 다른 속성은 가져 오지 않습니다. 만약</target>
        </trans-unit>
        <trans-unit id="9c35b055942db90e595b2a9f7832e56c4fefa4a1" translate="yes" xml:space="preserve">
          <source>Attributes in Object Declarations</source>
          <target state="translated">객체 선언의 속성</target>
        </trans-unit>
        <trans-unit id="42ae1ca911f09da25705c803e802dc66807bb214" translate="yes" xml:space="preserve">
          <source>Attributes of the &lt;code&gt;&amp;lt;ui&amp;gt;&lt;/code&gt; tag:</source>
          <target state="translated">&lt;code&gt;&amp;lt;ui&amp;gt;&lt;/code&gt; 태그 의 속성 :</target>
        </trans-unit>
        <trans-unit id="5d0e697c5f98e73026bf71edfa6226e1708d59ff" translate="yes" xml:space="preserve">
          <source>Attributes that declare namespaces (i.e. the attribute</source>
          <target state="translated">네임 스페이스를 선언하는 속성 (예 : 속성)</target>
        </trans-unit>
        <trans-unit id="0038b89e1b24bd41bd084d172a1fb895246dfe89" translate="yes" xml:space="preserve">
          <source>Attributes which are not specifically set will not affect the font selection algorithm, and default values will be preferred instead.</source>
          <target state="translated">특별히 설정되지 않은 속성은 글꼴 선택 알고리즘에 영향을 미치지 않으며 대신 기본값이 선호됩니다.</target>
        </trans-unit>
        <trans-unit id="a4d81396d4ea19197dfceaa774ef776332674285" translate="yes" xml:space="preserve">
          <source>Attribution</source>
          <target state="translated">Attribution</target>
        </trans-unit>
        <trans-unit id="7b647fe7f6d07531f44e887242ee0bcb549d7597" translate="yes" xml:space="preserve">
          <source>Attribution text which must be displayed when displaying the editorial.</source>
          <target state="translated">광고 문안을 표시 할 때 표시되어야하는 속성 텍스트.</target>
        </trans-unit>
        <trans-unit id="88df49eb25d5fb6c67ccecf800b4a9109a91bfb0" translate="yes" xml:space="preserve">
          <source>Attribution text which must be displayed when displaying the image.</source>
          <target state="translated">이미지를 표시 할 때 표시해야하는 속성 텍스트입니다.</target>
        </trans-unit>
        <trans-unit id="22d2e726f6a53b1a760afeb7573e4972ac54b136" translate="yes" xml:space="preserve">
          <source>Attribution text which must be displayed when displaying the review.</source>
          <target state="translated">리뷰를 표시 할 때 표시해야하는 속성 텍스트입니다.</target>
        </trans-unit>
        <trans-unit id="acdac205f5e24cb75113c4b281a2c13f08b75159" translate="yes" xml:space="preserve">
          <source>Audio</source>
          <target state="translated">Audio</target>
        </trans-unit>
        <trans-unit id="a7dc566772d0eb2736f817b9153166b4af101dc8" translate="yes" xml:space="preserve">
          <source>Audio (QML type)</source>
          <target state="translated">오디오 (QML 유형)</target>
        </trans-unit>
        <trans-unit id="d7016e7c193553ab435a13fc9be640f5aeb430f7" translate="yes" xml:space="preserve">
          <source>Audio Overview</source>
          <target state="translated">오디오 개요</target>
        </trans-unit>
        <trans-unit id="7fef1324817460a4d153dfcd0886fabb6a0e2171" translate="yes" xml:space="preserve">
          <source>Audio QML Type</source>
          <target state="translated">오디오 QML 유형</target>
        </trans-unit>
        <trans-unit id="4c937bc7a554ea29bd7b4e0c8bf6151575f0600c" translate="yes" xml:space="preserve">
          <source>Audio and Video Codecs</source>
          <target state="translated">오디오 및 비디오 코덱</target>
        </trans-unit>
        <trans-unit id="82e35f426c0bee9fdae0ab9c5ae45d32d607f51c" translate="yes" xml:space="preserve">
          <source>Audio attributes</source>
          <target state="translated">오디오 속성</target>
        </trans-unit>
        <trans-unit id="1f6b31f833ca0369e9443bb43e9565fd9219c228" translate="yes" xml:space="preserve">
          <source>Audio capture devices, such as microphones.</source>
          <target state="translated">마이크와 같은 오디오 캡처 장치</target>
        </trans-unit>
        <trans-unit id="5c5c23de36b942469e47171328a4a32d1528d728" translate="yes" xml:space="preserve">
          <source>Audio data is being processed, this state is set after start() is called and while audio data is available to be processed.</source>
          <target state="translated">오디오 데이터가 처리되고 있으며,이 상태는 start ()가 호출 된 후 오디오 데이터를 처리 할 수있는 동안 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="209f6075d5e8e049519ea62f2fe16d087c632489" translate="yes" xml:space="preserve">
          <source>Audio data is not being fed to the audio device at a fast enough rate</source>
          <target state="translated">오디오 데이터가 충분한 속도로 오디오 장치에 공급되지 않습니다</target>
        </trans-unit>
        <trans-unit id="515a711e89f9d57b5922003c3e2fc908c1e1dc29" translate="yes" xml:space="preserve">
          <source>Audio feedback.</source>
          <target state="translated">오디오 피드백.</target>
        </trans-unit>
        <trans-unit id="1426e62896abd1290f70cb3c22e0e6c78f967490" translate="yes" xml:space="preserve">
          <source>Audio output volume: from 0.0 (silent) to 1.0 (maximum)</source>
          <target state="translated">오디오 출력 음량 : 0.0 (자동) ~ 1.0 (최대)</target>
        </trans-unit>
        <trans-unit id="ea96cac1f52cce651db3af56aec8c7df8d5888f0" translate="yes" xml:space="preserve">
          <source>Audio stream.</source>
          <target state="translated">오디오 스트림.</target>
        </trans-unit>
        <trans-unit id="14ae2bc082d57b7bce69bb7383fb22924348c87a" translate="yes" xml:space="preserve">
          <source>Audio.audioRole</source>
          <target state="translated">Audio.audioRole</target>
        </trans-unit>
        <trans-unit id="fe495e1b3a94a274d2f600645542d4ae12896ba5" translate="yes" xml:space="preserve">
          <source>Audio.autoLoad</source>
          <target state="translated">Audio.autoLoad</target>
        </trans-unit>
        <trans-unit id="3f2f5c670f017fd4f2ed0e4b7c73b32da8f82682" translate="yes" xml:space="preserve">
          <source>Audio.autoPlay</source>
          <target state="translated">Audio.autoPlay</target>
        </trans-unit>
        <trans-unit id="cef050f730d6d1ede632fdecad6d6b6c627e5ae6" translate="yes" xml:space="preserve">
          <source>Audio.availability</source>
          <target state="translated">Audio.availability</target>
        </trans-unit>
        <trans-unit id="9e1ae1731b54dbc698a38ae19e7bec41bf3105d6" translate="yes" xml:space="preserve">
          <source>Audio.bufferProgress</source>
          <target state="translated">Audio.bufferProgress</target>
        </trans-unit>
        <trans-unit id="60ff0d2426c87c4717a71a2a6fa331a300006206" translate="yes" xml:space="preserve">
          <source>Audio.customAudioRole</source>
          <target state="translated">Audio.customAudioRole</target>
        </trans-unit>
        <trans-unit id="497123a6ebc816ed877d00ecdf06af2057e8b50b" translate="yes" xml:space="preserve">
          <source>Audio.duration</source>
          <target state="translated">Audio.duration</target>
        </trans-unit>
        <trans-unit id="76d693f55f22c3a69402e1b172872fa2226e7378" translate="yes" xml:space="preserve">
          <source>Audio.error</source>
          <target state="translated">Audio.error</target>
        </trans-unit>
        <trans-unit id="bc259981484e31706e7b5b8022cb1c1b433bb42b" translate="yes" xml:space="preserve">
          <source>Audio.error()</source>
          <target state="translated">Audio.error()</target>
        </trans-unit>
        <trans-unit id="e3cd1d110a5e944233bd361cc299667d0428095b" translate="yes" xml:space="preserve">
          <source>Audio.errorString</source>
          <target state="translated">Audio.errorString</target>
        </trans-unit>
        <trans-unit id="6b7c7838c26f7db5bcae41a4467e0d29b2d24b45" translate="yes" xml:space="preserve">
          <source>Audio.groupmetaData.title</source>
          <target state="translated">Audio.groupmetaData.title</target>
        </trans-unit>
        <trans-unit id="a095be85d0fbec28b81dd99a7be67bca54ae5272" translate="yes" xml:space="preserve">
          <source>Audio.hasAudio</source>
          <target state="translated">Audio.hasAudio</target>
        </trans-unit>
        <trans-unit id="8cfdd4d28ac430708cfb7af93ebf904ec893e562" translate="yes" xml:space="preserve">
          <source>Audio.hasVideo</source>
          <target state="translated">Audio.hasVideo</target>
        </trans-unit>
        <trans-unit id="a9323ba5af8964166a47e5044cd402fbcf082efe" translate="yes" xml:space="preserve">
          <source>Audio.loops</source>
          <target state="translated">Audio.loops</target>
        </trans-unit>
        <trans-unit id="d8309dab28cef9b379ac0d35caf8cf310709bfde" translate="yes" xml:space="preserve">
          <source>Audio.mediaObject</source>
          <target state="translated">Audio.mediaObject</target>
        </trans-unit>
        <trans-unit id="1f55da54a6669f148566661a4db0e039f2d1dcde" translate="yes" xml:space="preserve">
          <source>Audio.metaData.albumArtist</source>
          <target state="translated">Audio.metaData.albumArtist</target>
        </trans-unit>
        <trans-unit id="6c3c72eee168065edaf864e46370dcb11936a4aa" translate="yes" xml:space="preserve">
          <source>Audio.muted</source>
          <target state="translated">Audio.muted</target>
        </trans-unit>
        <trans-unit id="403fcb13f7256e638d63e3715f34eccdfbb8a1fc" translate="yes" xml:space="preserve">
          <source>Audio.notifyInterval</source>
          <target state="translated">Audio.notifyInterval</target>
        </trans-unit>
        <trans-unit id="6d733b889602e22bcf797e5fe2e62acc9feb294f" translate="yes" xml:space="preserve">
          <source>Audio.pause()</source>
          <target state="translated">Audio.pause()</target>
        </trans-unit>
        <trans-unit id="91012afdd13ffc49383aba56847cd400a01a5460" translate="yes" xml:space="preserve">
          <source>Audio.paused()</source>
          <target state="translated">Audio.paused()</target>
        </trans-unit>
        <trans-unit id="663d9b04672f8f13b360ed542e814ab48c1a4a8b" translate="yes" xml:space="preserve">
          <source>Audio.play()</source>
          <target state="translated">Audio.play()</target>
        </trans-unit>
        <trans-unit id="62eb1265d0c18b526c2ffc28c5654f74bc4e1c2e" translate="yes" xml:space="preserve">
          <source>Audio.playbackRate</source>
          <target state="translated">Audio.playbackRate</target>
        </trans-unit>
        <trans-unit id="c6367e644e0d158e8217b287787b424fef5e0859" translate="yes" xml:space="preserve">
          <source>Audio.playbackState</source>
          <target state="translated">Audio.playbackState</target>
        </trans-unit>
        <trans-unit id="933fda413ba480969e06092392531ecec79ca63e" translate="yes" xml:space="preserve">
          <source>Audio.playbackStateChanged()</source>
          <target state="translated">Audio.playbackStateChanged()</target>
        </trans-unit>
        <trans-unit id="e468eecfbee118d6ddb238a67cdc81c48ccf43d9" translate="yes" xml:space="preserve">
          <source>Audio.playing()</source>
          <target state="translated">Audio.playing()</target>
        </trans-unit>
        <trans-unit id="332e525e4e361867a2b8e9ec7cfc3af8feac3419" translate="yes" xml:space="preserve">
          <source>Audio.playlist</source>
          <target state="translated">Audio.playlist</target>
        </trans-unit>
        <trans-unit id="9400c6af650d1dc9c95fcb3e6b57ebb6e3a56d6d" translate="yes" xml:space="preserve">
          <source>Audio.position</source>
          <target state="translated">Audio.position</target>
        </trans-unit>
        <trans-unit id="f66e6ee132fc5015582532632195fd3024f0399a" translate="yes" xml:space="preserve">
          <source>Audio.seek()</source>
          <target state="translated">Audio.seek()</target>
        </trans-unit>
        <trans-unit id="8b58755de12aed29183019d66f70741e14becd26" translate="yes" xml:space="preserve">
          <source>Audio.seekable</source>
          <target state="translated">Audio.seekable</target>
        </trans-unit>
        <trans-unit id="ca14124357a8b3426cba1d9db09bc952f22423ef" translate="yes" xml:space="preserve">
          <source>Audio.source</source>
          <target state="translated">Audio.source</target>
        </trans-unit>
        <trans-unit id="87c7adf361330f5648c3d9c262f2a66ba704665a" translate="yes" xml:space="preserve">
          <source>Audio.status</source>
          <target state="translated">Audio.status</target>
        </trans-unit>
        <trans-unit id="4b8f1b593a1ab764714704ba9ec2fc02d41ab53b" translate="yes" xml:space="preserve">
          <source>Audio.stop()</source>
          <target state="translated">Audio.stop()</target>
        </trans-unit>
        <trans-unit id="afc00b0e6ee90a6c57546caebd257bf586bca56e" translate="yes" xml:space="preserve">
          <source>Audio.stopped()</source>
          <target state="translated">Audio.stopped()</target>
        </trans-unit>
        <trans-unit id="3406df839d5c55d297ef73c7a109cd1c89111ccb" translate="yes" xml:space="preserve">
          <source>Audio.supportedAudioRoles()</source>
          <target state="translated">Audio.supportedAudioRoles()</target>
        </trans-unit>
        <trans-unit id="8f72de47027e6e994034d29fa1b976deb5f08795" translate="yes" xml:space="preserve">
          <source>Audio.volume</source>
          <target state="translated">Audio.volume</target>
        </trans-unit>
        <trans-unit id="5decd06bf8e616e1879544fe44bf97af3fa1e134" translate="yes" xml:space="preserve">
          <source>Audio/Video Control Transport Protocol UUID</source>
          <target state="translated">오디오 / 비디오 제어 전송 프로토콜 UUID</target>
        </trans-unit>
        <trans-unit id="c372d9c594ee32457e409f2794853dcbb973339e" translate="yes" xml:space="preserve">
          <source>Audio/Video Distribution Transport Protocol UUID</source>
          <target state="translated">오디오 / 비디오 배포 전송 프로토콜 UUID</target>
        </trans-unit>
        <trans-unit id="2e0b001b39efb0867dcc0e264a782b0249a2b04d" translate="yes" xml:space="preserve">
          <source>Audio/Video Remote Control Profile (AVRCP) UUID (service &amp;amp; profile)</source>
          <target state="translated">AVRCP (오디오 / 비디오 원격 제어 프로파일) UUID (서비스 및 프로파일)</target>
        </trans-unit>
        <trans-unit id="c3d1e040e6627e4e6ac4cb12a81a24bee1497d4d" translate="yes" xml:space="preserve">
          <source>Audio/Video Remote Control Profile (AVRCP) UUID (service)</source>
          <target state="translated">AVRCP (오디오 / 비디오 원격 제어 프로파일) UUID (서비스)</target>
        </trans-unit>
        <trans-unit id="fc1beb28de9f28bc0356cc58a5545e34f4e529e6" translate="yes" xml:space="preserve">
          <source>Audio/Video Remote Control Profile UUID (service)</source>
          <target state="translated">오디오 / 비디오 원격 제어 프로파일 UUID (서비스)</target>
        </trans-unit>
        <trans-unit id="f161ae61c892d2ea0241e169d612b03d8caeae97" translate="yes" xml:space="preserve">
          <source>AudioBitRate</source>
          <target state="translated">AudioBitRate</target>
        </trans-unit>
        <trans-unit id="7543bfd2e6a4581eaefe18f4555e78df03b4909d" translate="yes" xml:space="preserve">
          <source>AudioCategory (QML type)</source>
          <target state="translated">AudioCategory (QML 유형)</target>
        </trans-unit>
        <trans-unit id="e82123f9c1c5dcac17b93eb442519acb520a6eda" translate="yes" xml:space="preserve">
          <source>AudioCategory QML Type</source>
          <target state="translated">AudioCategory QML 유형</target>
        </trans-unit>
        <trans-unit id="a75f7c37be399131fc95476f6c3840f3be22beef" translate="yes" xml:space="preserve">
          <source>AudioCategory.name</source>
          <target state="translated">AudioCategory.name</target>
        </trans-unit>
        <trans-unit id="edf389023a74b61a6a8c0653c41377765b2b1f3f" translate="yes" xml:space="preserve">
          <source>AudioCategory.pause()</source>
          <target state="translated">AudioCategory.pause()</target>
        </trans-unit>
        <trans-unit id="58d0406145cad48cf9621f31805e3dd1c985670d" translate="yes" xml:space="preserve">
          <source>AudioCategory.stop()</source>
          <target state="translated">AudioCategory.stop()</target>
        </trans-unit>
        <trans-unit id="a7ad9f381c72e09926174fc7c3536f212c18e3da" translate="yes" xml:space="preserve">
          <source>AudioCategory.volume</source>
          <target state="translated">AudioCategory.volume</target>
        </trans-unit>
        <trans-unit id="61272d0a3123930b8bb89226efea6caebd1af833" translate="yes" xml:space="preserve">
          <source>AudioCodec</source>
          <target state="translated">AudioCodec</target>
        </trans-unit>
        <trans-unit id="0eff2798ed4add3fdd44dd8dee04ae036c6ce927" translate="yes" xml:space="preserve">
          <source>AudioEngine (QML type)</source>
          <target state="translated">AudioEngine (QML 유형)</target>
        </trans-unit>
        <trans-unit id="0dd68fc35ce487de94c1e48720e8a7543a05501c" translate="yes" xml:space="preserve">
          <source>AudioEngine QML Type</source>
          <target state="translated">AudioEngine QML 유형</target>
        </trans-unit>
        <trans-unit id="abc3dd7e6cf5ffe0c5e848c0962f82a9bf2c05bb" translate="yes" xml:space="preserve">
          <source>AudioEngine.addAttenuationModel()</source>
          <target state="translated">AudioEngine.addAttenuationModel()</target>
        </trans-unit>
        <trans-unit id="ecda478c8cbbf8acda4ef76c3541c2515967f1c6" translate="yes" xml:space="preserve">
          <source>AudioEngine.addAudioCategory()</source>
          <target state="translated">AudioEngine.addAudioCategory()</target>
        </trans-unit>
        <trans-unit id="b3ed0854576d78bab7cd09ee7377cca3011b9953" translate="yes" xml:space="preserve">
          <source>AudioEngine.addAudioSample()</source>
          <target state="translated">AudioEngine.addAudioSample()</target>
        </trans-unit>
        <trans-unit id="086a2aa1326321e50fee5e7235632c6ec3ad0259" translate="yes" xml:space="preserve">
          <source>AudioEngine.addSound()</source>
          <target state="translated">AudioEngine.addSound()</target>
        </trans-unit>
        <trans-unit id="6809e8476cc16282d512e31445be24933dd4e3af" translate="yes" xml:space="preserve">
          <source>AudioEngine.categories</source>
          <target state="translated">AudioEngine.categories</target>
        </trans-unit>
        <trans-unit id="144c87694d48f04dddbc7e3dc799b96b687f655a" translate="yes" xml:space="preserve">
          <source>AudioEngine.dopplerFactor</source>
          <target state="translated">AudioEngine.dopplerFactor</target>
        </trans-unit>
        <trans-unit id="94c9ac9a2b28948bf88cebb25e4229d6fd47fbde" translate="yes" xml:space="preserve">
          <source>AudioEngine.finishedLoading()</source>
          <target state="translated">AudioEngine.finishedLoading()</target>
        </trans-unit>
        <trans-unit id="64e535a598e2a57ff979161c577e8f5d088efdfb" translate="yes" xml:space="preserve">
          <source>AudioEngine.isLoadingChanged()</source>
          <target state="translated">AudioEngine.isLoadingChanged()</target>
        </trans-unit>
        <trans-unit id="9ca764394a8f2a8a81bd9bb905bf61f61fe0eb68" translate="yes" xml:space="preserve">
          <source>AudioEngine.listener</source>
          <target state="translated">AudioEngine.listener</target>
        </trans-unit>
        <trans-unit id="0db9cde1d7ceb8df8432df7e5f90ef51e961167e" translate="yes" xml:space="preserve">
          <source>AudioEngine.liveInstanceCountChanged()</source>
          <target state="translated">AudioEngine.liveInstanceCountChanged()</target>
        </trans-unit>
        <trans-unit id="a3c780c8685f4ae94cbc366c23da62c5bb21cd0e" translate="yes" xml:space="preserve">
          <source>AudioEngine.liveInstances</source>
          <target state="translated">AudioEngine.liveInstances</target>
        </trans-unit>
        <trans-unit id="88f82e43cbd231a76e4e5e286b7af3fdd2cdc3f8" translate="yes" xml:space="preserve">
          <source>AudioEngine.loading</source>
          <target state="translated">AudioEngine.loading</target>
        </trans-unit>
        <trans-unit id="3eafc6185deae73e78947e584fb199ded6111e2e" translate="yes" xml:space="preserve">
          <source>AudioEngine.ready()</source>
          <target state="translated">AudioEngine.ready()</target>
        </trans-unit>
        <trans-unit id="d18f598be844ac08e14c23bc228f025b11d3784f" translate="yes" xml:space="preserve">
          <source>AudioEngine.samples</source>
          <target state="translated">AudioEngine.samples</target>
        </trans-unit>
        <trans-unit id="e74d8427b95136f8fdea57244e12eca46350d834" translate="yes" xml:space="preserve">
          <source>AudioEngine.sounds</source>
          <target state="translated">AudioEngine.sounds</target>
        </trans-unit>
        <trans-unit id="6b2018c1f51763fb309bd535727e578e9ee03f2e" translate="yes" xml:space="preserve">
          <source>AudioEngine.speedOfSound</source>
          <target state="translated">AudioEngine.speedOfSound</target>
        </trans-unit>
        <trans-unit id="4b682bed9f7b034f73f1a2096eb1f36aff816bc7" translate="yes" xml:space="preserve">
          <source>AudioListener (QML type)</source>
          <target state="translated">AudioListener (QML 유형)</target>
        </trans-unit>
        <trans-unit id="65dc0356ed096e404aafff20c5b87f483ada9c16" translate="yes" xml:space="preserve">
          <source>AudioListener QML Type</source>
          <target state="translated">AudioListener QML 유형</target>
        </trans-unit>
        <trans-unit id="3ff7de5270836331a995c5a9ed1d75c92a48883a" translate="yes" xml:space="preserve">
          <source>AudioListener will have only one global instance and you can either access it through the listener property of &lt;a href=&quot;qml-qtaudioengine-audioengine&quot;&gt;AudioEngine&lt;/a&gt;:</source>
          <target state="translated">AudioListener에는 전역 인스턴스가 하나만 있으며 &lt;a href=&quot;qml-qtaudioengine-audioengine&quot;&gt;AudioEngine&lt;/a&gt; 의 listener 속성을 통해 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="515771c3c41723e245d7d934e9859700951bbfb3" translate="yes" xml:space="preserve">
          <source>AudioListener.direction</source>
          <target state="translated">AudioListener.direction</target>
        </trans-unit>
        <trans-unit id="1000f5b8a2dbc1e11a18ce120efccdd5e340f415" translate="yes" xml:space="preserve">
          <source>AudioListener.engine</source>
          <target state="translated">AudioListener.engine</target>
        </trans-unit>
        <trans-unit id="2770bc287fd302ad98542ee08c00537f67b6616d" translate="yes" xml:space="preserve">
          <source>AudioListener.gain</source>
          <target state="translated">AudioListener.gain</target>
        </trans-unit>
        <trans-unit id="5160714d0b8e93accfc09dccb33c97631b753992" translate="yes" xml:space="preserve">
          <source>AudioListener.position</source>
          <target state="translated">AudioListener.position</target>
        </trans-unit>
        <trans-unit id="fe48b2a64a143dce5a9d0e40f9bdda534b6552f3" translate="yes" xml:space="preserve">
          <source>AudioListener.up</source>
          <target state="translated">AudioListener.up</target>
        </trans-unit>
        <trans-unit id="57796a4b5e5ee9fd4ab4553faaf1bc3736071b27" translate="yes" xml:space="preserve">
          <source>AudioListener.velocity</source>
          <target state="translated">AudioListener.velocity</target>
        </trans-unit>
        <trans-unit id="32458668a2f05309e8729a3f02fb5e76812427a3" translate="yes" xml:space="preserve">
          <source>AudioSample (QML type)</source>
          <target state="translated">오디오 샘플 (QML 유형)</target>
        </trans-unit>
        <trans-unit id="2edbd5fa319b7a4229c9bff88f7111faf89fcc1a" translate="yes" xml:space="preserve">
          <source>AudioSample QML Type</source>
          <target state="translated">오디오 샘플 QML 유형</target>
        </trans-unit>
        <trans-unit id="5cfce10d346107b7e2456f97dc30bd15320b8bbe" translate="yes" xml:space="preserve">
          <source>AudioSample.load()</source>
          <target state="translated">AudioSample.load()</target>
        </trans-unit>
        <trans-unit id="7de1401602ec630ddba05e035e3c05e1a956f893" translate="yes" xml:space="preserve">
          <source>AudioSample.loaded</source>
          <target state="translated">AudioSample.loaded</target>
        </trans-unit>
        <trans-unit id="0050d1df722f31ae5a5a96c8f59ece60d3a166ca" translate="yes" xml:space="preserve">
          <source>AudioSample.loadedChanged()</source>
          <target state="translated">AudioSample.loadedChanged()</target>
        </trans-unit>
        <trans-unit id="603a2b34848e804c9cd847916169ce2d7c5949a9" translate="yes" xml:space="preserve">
          <source>AudioSample.name</source>
          <target state="translated">AudioSample.name</target>
        </trans-unit>
        <trans-unit id="aa74e77095549b2d4d1f1f90bbe143bf3f2f6466" translate="yes" xml:space="preserve">
          <source>AudioSample.preloaded</source>
          <target state="translated">AudioSample.preloaded</target>
        </trans-unit>
        <trans-unit id="3a70b21332f28afcb7ed41a7560047a9284be222" translate="yes" xml:space="preserve">
          <source>AudioSample.source</source>
          <target state="translated">AudioSample.source</target>
        </trans-unit>
        <trans-unit id="06214410aa495b30a65a8c0466cc2b1a67e75659" translate="yes" xml:space="preserve">
          <source>August (7)</source>
          <target state="translated">8 월 (7)</target>
        </trans-unit>
        <trans-unit id="43833b0ea01c6c5d5bae05c4a3af7717056f2b0f" translate="yes" xml:space="preserve">
          <source>Authentication data for pre shared keys (PSK) ciphersuites</source>
          <target state="translated">사전 공유 키 (PSK) 암호 모음의 인증 데이터</target>
        </trans-unit>
        <trans-unit id="9e63fb08fd99ec22d7e865e2889168232a8b8858" translate="yes" xml:space="preserve">
          <source>Authentication details provided to QNetworkAccessManager::authenticationRequired() must be provided immediately, so this signal cannot be connected as a &lt;a href=&quot;qt#ConnectionType-enum&quot;&gt;Qt::QueuedConnection&lt;/a&gt; (or as the default &lt;a href=&quot;qt#ConnectionType-enum&quot;&gt;Qt::AutoConnection&lt;/a&gt; from another thread).</source>
          <target state="translated">QNetworkAccessManager :: authenticationRequired ()에 제공된 인증 세부 사항을 즉시 제공해야하므로이 신호를 &lt;a href=&quot;qt#ConnectionType-enum&quot;&gt;Qt :: QueuedConnection&lt;/a&gt; (또는 다른 스레드 의 기본 &lt;a href=&quot;qt#ConnectionType-enum&quot;&gt;Qt :: AutoConnection)&lt;/a&gt; 으로 연결할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="13b52210e5e437015dcea177d45621ef6f42e51d" translate="yes" xml:space="preserve">
          <source>AuthenticationDialogRequest (QML type)</source>
          <target state="translated">AuthenticationDialogRequest (QML 유형)</target>
        </trans-unit>
        <trans-unit id="cd362f081c9d484cf38a7d7427a60daacdf46e0d" translate="yes" xml:space="preserve">
          <source>AuthenticationDialogRequest QML Type</source>
          <target state="translated">AuthenticationDialogRequest QML 유형</target>
        </trans-unit>
        <trans-unit id="bb137a48fe744b55a6c2e34197e71c9183bea5e7" translate="yes" xml:space="preserve">
          <source>AuthenticationDialogRequest.accepted</source>
          <target state="translated">AuthenticationDialogRequest.accepted</target>
        </trans-unit>
        <trans-unit id="414f809330c35b841039beed59458e6481dcc3d6" translate="yes" xml:space="preserve">
          <source>AuthenticationDialogRequest.dialogAccept()</source>
          <target state="translated">AuthenticationDialogRequest.dialogAccept()</target>
        </trans-unit>
        <trans-unit id="cbcc327266c5795c4cefde5b61be5ee574ff2677" translate="yes" xml:space="preserve">
          <source>AuthenticationDialogRequest.dialogReject()</source>
          <target state="translated">AuthenticationDialogRequest.dialogReject()</target>
        </trans-unit>
        <trans-unit id="2f8b523e2405cfdaeda9591f89ddd33b5f283637" translate="yes" xml:space="preserve">
          <source>AuthenticationDialogRequest.proxyHost</source>
          <target state="translated">AuthenticationDialogRequest.proxyHost</target>
        </trans-unit>
        <trans-unit id="d00ee7f6d99ba97884e0d801ff37dd8f6e4e2eb2" translate="yes" xml:space="preserve">
          <source>AuthenticationDialogRequest.realm</source>
          <target state="translated">AuthenticationDialogRequest.realm</target>
        </trans-unit>
        <trans-unit id="207a688472a8924b905f175de4566f715e2ebe54" translate="yes" xml:space="preserve">
          <source>AuthenticationDialogRequest.type</source>
          <target state="translated">AuthenticationDialogRequest.type</target>
        </trans-unit>
        <trans-unit id="db56b27ba5b48a1725df767f37dc66d353d1696d" translate="yes" xml:space="preserve">
          <source>AuthenticationDialogRequest.url</source>
          <target state="translated">AuthenticationDialogRequest.url</target>
        </trans-unit>
        <trans-unit id="5fda23d62015b99fb2a9f86b38bcdf2bdf7609c8" translate="yes" xml:space="preserve">
          <source>Author</source>
          <target state="translated">Author</target>
        </trans-unit>
        <trans-unit id="54f4165a5563bb8ace4876f41367e6620edc5f00" translate="yes" xml:space="preserve">
          <source>Authorization Server</source>
          <target state="translated">인증 서버</target>
        </trans-unit>
        <trans-unit id="210c2a477516d97a77920658ddd25595b7ce4d5b" translate="yes" xml:space="preserve">
          <source>Authorizes the given</source>
          <target state="translated">주어진 권한을 부여합니다</target>
        </trans-unit>
        <trans-unit id="c614ba7c453cdcd4d21b20e8286c6266c891e0c6" translate="yes" xml:space="preserve">
          <source>Auto</source>
          <target state="translated">Auto</target>
        </trans-unit>
        <trans-unit id="b9473d62b0cf047552f281305949cb419b07f11a" translate="yes" xml:space="preserve">
          <source>Auto white balance mode.</source>
          <target state="translated">자동 화이트 밸런스 모드.</target>
        </trans-unit>
        <trans-unit id="2212e9c51ee569c538028db48e03ff0176bd6b94" translate="yes" xml:space="preserve">
          <source>Auto-Connection</source>
          <target state="translated">Auto-Connection</target>
        </trans-unit>
        <trans-unit id="da247f2a5829d65f7e3b4461795859997fa21e20" translate="yes" xml:space="preserve">
          <source>Auto-completion of incomplete URLs with &lt;a href=&quot;https://www.iana.org/assignments/uri-schemes/prov/view-source&quot;&gt;view-source URI scheme&lt;/a&gt; makes the usage of this feature more comfortable. For example, the following incomplete URL also loads the source view of the qt.io web page:</source>
          <target state="translated">&lt;a href=&quot;https://www.iana.org/assignments/uri-schemes/prov/view-source&quot;&gt;소스보기 URI 체계를&lt;/a&gt; 사용하여 불완전한 URL을 자동 완성 하면이 기능을보다 편안하게 사용할 수 있습니다. 예를 들어, 다음의 불완전한 URL은 qt.io 웹 페이지의 소스보기도로드합니다.</target>
        </trans-unit>
        <trans-unit id="2ea3b13dcb5ecf75d6febc8df9eba601328f7187" translate="yes" xml:space="preserve">
          <source>Auto-completion of incomplete URLs with &lt;a href=&quot;https://www.iana.org/assignments/uri-schemes/prov/view-source#&quot;&gt;view-source URI scheme&lt;/a&gt; makes the usage of this feature more comfortable. For example, the following incomplete URL also loads the source view of the qt.io web page:</source>
          <target state="translated">&lt;a href=&quot;https://www.iana.org/assignments/uri-schemes/prov/view-source#&quot;&gt;뷰 소스 URI 체계를&lt;/a&gt; 사용하여 불완전한 URL을 자동 완성 하면이 기능을보다 편리하게 사용할 수 있습니다. 예를 들어, 다음 불완전한 URL은 qt.io 웹 페이지의 소스 뷰도로드합니다.</target>
        </trans-unit>
        <trans-unit id="de72c7b620b85347a71c7b64d5d79c5e45264a38" translate="yes" xml:space="preserve">
          <source>Auto-deletion is enabled by default.</source>
          <target state="translated">자동 삭제는 기본적으로 활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="52a7249dc999583af21182315f8e31b6d87b0493" translate="yes" xml:space="preserve">
          <source>Auto-remove is on by default.</source>
          <target state="translated">자동 제거는 기본적으로 켜져 있습니다.</target>
        </trans-unit>
        <trans-unit id="e06976bf50d386316359206a19dc4a1d53fcc3c2" translate="yes" xml:space="preserve">
          <source>Auto-repeat interval for spinbox key presses.</source>
          <target state="translated">스핀 박스 키 누름에 대한 자동 반복 간격.</target>
        </trans-unit>
        <trans-unit id="de5122dd1083528e05034f04e22571bb18aa6981" translate="yes" xml:space="preserve">
          <source>Auto-repeat interval for spinbox mouse clicks.</source>
          <target state="translated">스핀 박스 마우스 클릭에 대한 자동 반복 간격.</target>
        </trans-unit>
        <trans-unit id="a8fa189582dfc401e62ab0e0133416e4f3856ab4" translate="yes" xml:space="preserve">
          <source>Auto-repeat or not.</source>
          <target state="translated">자동 반복 여부.</target>
        </trans-unit>
        <trans-unit id="c47797cc87062a821944593a2f1b079d411d9bec" translate="yes" xml:space="preserve">
          <source>Auto-repeat threshold for spinbox mouse clicks.</source>
          <target state="translated">스핀 박스 마우스 클릭에 대한 자동 반복 임계 값.</target>
        </trans-unit>
        <trans-unit id="3462e7ba4f3549f14a0eb0b4da5b86a0b1853779" translate="yes" xml:space="preserve">
          <source>AutoCloseSessionTimeout</source>
          <target state="translated">AutoCloseSessionTimeout</target>
        </trans-unit>
        <trans-unit id="5acc8f895a92298ade69dc724b9e3762325c6c67" translate="yes" xml:space="preserve">
          <source>Autodesk FBX</source>
          <target state="translated">Autodesk FBX</target>
        </trans-unit>
        <trans-unit id="872fb4f5a75e8d811d8f59fa79530fa005f0725b" translate="yes" xml:space="preserve">
          <source>Automatic Clipping</source>
          <target state="translated">자동 클리핑</target>
        </trans-unit>
        <trans-unit id="e813eea5386fdaa0523579c33919a33b23d26dd8" translate="yes" xml:space="preserve">
          <source>Automatic Connections</source>
          <target state="translated">자동 연결</target>
        </trans-unit>
        <trans-unit id="8b947b2d5d02bca2382a545fb478a84922836443" translate="yes" xml:space="preserve">
          <source>Automatic Detection of File Extension</source>
          <target state="translated">파일 확장자 자동 감지</target>
        </trans-unit>
        <trans-unit id="e4d12a00bf7a292934c2f1002bbda1b30db2009c" translate="yes" xml:space="preserve">
          <source>Automatic Replies</source>
          <target state="translated">자동 회신</target>
        </trans-unit>
        <trans-unit id="e6f1d9a359797848c122857ef2907a4d624d7ed3" translate="yes" xml:space="preserve">
          <source>Automatic aspect ratio.</source>
          <target state="translated">자동 종횡비.</target>
        </trans-unit>
        <trans-unit id="6e600b567344ea6c1b9f8d1fe4abcb966f197489" translate="yes" xml:space="preserve">
          <source>Automatic capitalization and space insertion.</source>
          <target state="translated">자동 대문자 및 공간 삽입.</target>
        </trans-unit>
        <trans-unit id="ce4b03898162fc0bdf5e44384a568b0a0d3109e3" translate="yes" xml:space="preserve">
          <source>Automatic connection of signals and slots provides both a standard naming convention and an explicit interface for widget designers to work to. By providing source code that implements a given interface, user interface designers can check that their designs actually work without having to write code themselves.</source>
          <target state="translated">신호와 슬롯의 자동 연결은 표준 명명 규칙과 위젯 디자이너가 작업 할 수있는 명시 적 인터페이스를 모두 제공합니다. 지정된 인터페이스를 구현하는 소스 코드를 제공함으로써 사용자 인터페이스 디자이너는 코드를 직접 작성하지 않고도 디자인이 실제로 작동하는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ce6e3e26548f657e3e1d9fa04d6cb9b43c0af03" translate="yes" xml:space="preserve">
          <source>Automatic flash.</source>
          <target state="translated">자동 플래시.</target>
        </trans-unit>
        <trans-unit id="cb96fed2890659e3549bb2fc82195af5568ddece" translate="yes" xml:space="preserve">
          <source>Automatic layout.</source>
          <target state="translated">자동 레이아웃.</target>
        </trans-unit>
        <trans-unit id="2b4336f3a86d9b8102fd7f79a07cc25449dd5290" translate="yes" xml:space="preserve">
          <source>Automatic mode.</source>
          <target state="translated">자동 모드.</target>
        </trans-unit>
        <trans-unit id="5507e011a644e559471a2d9662d56cbffdde5197" translate="yes" xml:space="preserve">
          <source>Automatic signal relaying consists of signal-to-signal connection of the signals on the parent that have the exact same method signatue in both classes.</source>
          <target state="translated">자동 신호 릴레이는 두 클래스에서 똑같은 방법으로 신호를 보내는 상위 신호의 신호 대 신호 연결로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="3d4cfc57f67fc04d8741f11f6a5c38ee28c6a916" translate="yes" xml:space="preserve">
          <source>Automatic updates when contents change:</source>
          <target state="translated">내용이 변경 될 때 자동 업데이트 :</target>
        </trans-unit>
        <trans-unit id="3098c35578b88787a01b55a75968edf98ca0f139" translate="yes" xml:space="preserve">
          <source>Automatically Cast To</source>
          <target state="translated">자동 전송</target>
        </trans-unit>
        <trans-unit id="e85f278aae9996cb04083ce0d3216ecf201d8711" translate="yes" xml:space="preserve">
          <source>Automatically construct a &lt;a href=&quot;qdbusreply&quot;&gt;QDBusReply&lt;/a&gt; object from the asynchronous pending call</source>
          <target state="translated">비동기식 보류 호출에서 &lt;a href=&quot;qdbusreply&quot;&gt;QDBusReply&lt;/a&gt; 객체 자동 생성</target>
        </trans-unit>
        <trans-unit id="2b2589c241d444d6c120745e7e8ed4429da615d1" translate="yes" xml:space="preserve">
          <source>Automatically construct a &lt;a href=&quot;qdbusreply&quot;&gt;QDBusReply&lt;/a&gt; object from the reply message</source>
          <target state="translated">응답 메시지에서 &lt;a href=&quot;qdbusreply&quot;&gt;QDBusReply&lt;/a&gt; 오브젝트 자동 생성</target>
        </trans-unit>
        <trans-unit id="76574f4f99dcaba248cf3d917f6384d076db80f5" translate="yes" xml:space="preserve">
          <source>Automatically construct a QDBusReply object from the asynchronous pending call</source>
          <target state="translated">비동기 보류 호출에서 자동으로 QDBusReply 객체 생성</target>
        </trans-unit>
        <trans-unit id="d7a35d5c50e95ba152426872fb88cc60675249be" translate="yes" xml:space="preserve">
          <source>Automatically construct a QDBusReply object from the reply message</source>
          <target state="translated">응답 메시지에서 QDBusReply 객체를 자동으로 생성</target>
        </trans-unit>
        <trans-unit id="70f8daca9a271cd83a8721c456f9ceae58dd3461" translate="yes" xml:space="preserve">
          <source>Automatically create bullet lists (e.g. when the user enters an asterisk ('*') in the left most column, or presses Enter in an existing list item.</source>
          <target state="translated">글 머리 기호 목록을 자동으로 작성합니다 (예 : 사용자가 가장 왼쪽 열에 별표 ( '*')를 입력하거나 기존 목록 항목에서 Enter를 누름).</target>
        </trans-unit>
        <trans-unit id="a14ce495b8a6fa6dda9e2a3e82bb316ffbc9a576" translate="yes" xml:space="preserve">
          <source>Automatically creates the service as long as the binding exist. See &lt;a href=&quot;https://developer.android.com/reference/android/content/Context.html#BIND_AUTO_CREATE&quot;&gt;BIND_AUTO_CREATE&lt;/a&gt; documentation for more details.</source>
          <target state="translated">바인딩이 존재하는 한 서비스를 자동으로 만듭니다. 자세한 내용은 &lt;a href=&quot;https://developer.android.com/reference/android/content/Context.html#BIND_AUTO_CREATE&quot;&gt;BIND_AUTO_CREATE&lt;/a&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="45b2afda7ff7daaa7c310e69b42ef71048f0db81" translate="yes" xml:space="preserve">
          <source>Automatically detect if the called function has a reply.</source>
          <target state="translated">호출 된 함수에 응답이 있는지 자동으로 감지합니다.</target>
        </trans-unit>
        <trans-unit id="929982e056bef519acc62a04d6213ba5e7264355" translate="yes" xml:space="preserve">
          <source>Automatically dowloads images for web pages. When this setting is disabled, images are loaded from the cache. Enabled by default.</source>
          <target state="translated">웹 페이지의 이미지를 자동으로 다운로드합니다. 이 설정을 사용하지 않으면 이미지가 캐시에서로드됩니다. 기본적으로 활성화되어 있습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
