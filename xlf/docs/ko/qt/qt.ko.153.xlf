<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="qt">
    <body>
      <group id="qt">
        <trans-unit id="7cf494e5dca771735e6ae5f934819bc0e0e3d522" translate="yes" xml:space="preserve">
          <source>Note that quintptr is unsigned. Use qptrdiff for signed values.</source>
          <target state="translated">quintptr은 부호가 없습니다. 부호있는 값에 qptrdiff를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ac776601bf09c34db17a338c79b397a8439e7a56" translate="yes" xml:space="preserve">
          <source>Note that requesting a 3.2 OpenGL Core Profile is just for the example's purposes; this class is not tied to any specific OpenGL or OpenGL ES version, as it relies on the availability of the &lt;code&gt;GL_KHR_debug&lt;/code&gt; extension (see below).</source>
          <target state="translated">3.2 OpenGL 코어 프로파일을 요청하는 것은 예제를위한 것입니다. 이 클래스는 &lt;code&gt;GL_KHR_debug&lt;/code&gt; 확장 의 가용성에 의존하기 때문에 특정 OpenGL 또는 OpenGL ES 버전과 관련이 없습니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="e93b64536639a15d605e5cc3e5abdbbbc2316a0e" translate="yes" xml:space="preserve">
          <source>Note that requests for function objects of other versions or profiles can fail and in doing so will return &lt;code&gt;nullptr&lt;/code&gt;. Situations in which creation of the functions object can fail are if the request cannot be satisfied due to asking for functions that are not in the version or profile of this context. For example:</source>
          <target state="translated">다른 버전이나 프로파일의 함수 객체에 대한 요청은 실패 할 수 &lt;code&gt;nullptr&lt;/code&gt; 반환 됩니다. 함수 오브젝트 작성에 실패 할 수있는 상황은이 컨텍스트의 버전 또는 프로파일에없는 함수를 요청하여 요청을 충족시킬 수없는 경우입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c7df8cc916184d9f5d3c971c2dec810b104a3419" translate="yes" xml:space="preserve">
          <source>Note that return values in the ranges QVariant::Char through QVariant::RegExp and QVariant::Font through QVariant::Transform correspond to the values in the ranges &lt;a href=&quot;qmetatype#Type-enum&quot;&gt;QMetaType::QChar&lt;/a&gt; through &lt;a href=&quot;qmetatype#Type-enum&quot;&gt;QMetaType::QRegExp&lt;/a&gt; and &lt;a href=&quot;qmetatype#Type-enum&quot;&gt;QMetaType::QFont&lt;/a&gt; through &lt;a href=&quot;qmetatype#Type-enum&quot;&gt;QMetaType::QQuaternion&lt;/a&gt;.</source>
          <target state="translated">QVariant :: Char-QVariant :: RegExp 및 QVariant :: Font-QVariant :: Transform 범위의 값은 &lt;a href=&quot;qmetatype#Type-enum&quot;&gt;QMetaType :: QChar&lt;/a&gt; - &lt;a href=&quot;qmetatype#Type-enum&quot;&gt;QMetaType :: QRegExp&lt;/a&gt; 및 &lt;a href=&quot;qmetatype#Type-enum&quot;&gt;QMetaType :: QFont&lt;/a&gt; - &lt;a href=&quot;qmetatype#Type-enum&quot;&gt;QMetaType&lt;/a&gt; 범위의 값에 해당합니다 . : QQuaternion .</target>
        </trans-unit>
        <trans-unit id="04f7b789b00c09630f3c0f93f48a472ef0defc7f" translate="yes" xml:space="preserve">
          <source>Note that rewinding inserts addition lines in the polygon so the outline of the fill polygon does not match the outline of the path.</source>
          <target state="translated">되감기는 다각형에 추가 선을 삽입하여 채우기 다각형의 윤곽선이 경로의 윤곽선과 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d6236ff0e45f11cd50b6069dd17eb4c2f9dee3e8" translate="yes" xml:space="preserve">
          <source>Note that sensor timestamps from different sensors may not be directly comparable (as they may choose different fixed points for their reference).</source>
          <target state="translated">서로 다른 센서의 센서 타임 스탬프는 직접 비교할 수 없습니다 (참조 용으로 다른 고정 점을 선택할 수 있음).</target>
        </trans-unit>
        <trans-unit id="0e106a19d1b8de17a8919259ee4f7ede563a76fe" translate="yes" xml:space="preserve">
          <source>Note that setHeaderLabels() won't remove existing columns.</source>
          <target state="translated">setHeaderLabels ()는 기존 열을 제거하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7e0332392bca9cd8a557c2c55f3c2b55bf90252f" translate="yes" xml:space="preserve">
          <source>Note that setting</source>
          <target state="translated">설정에 유의하십시오</target>
        </trans-unit>
        <trans-unit id="aa9493d2c234336e3628c6b369d9fb76d6efd0e5" translate="yes" xml:space="preserve">
          <source>Note that setting &lt;a href=&quot;qsvgrenderer&quot;&gt;QSvgRenderer&lt;/a&gt; on a &lt;a href=&quot;qgraphicssvgitem&quot;&gt;QGraphicsSvgItem&lt;/a&gt; doesn't make the item take ownership of the renderer, therefore if using &lt;a href=&quot;qgraphicssvgitem#setSharedRenderer&quot;&gt;setSharedRenderer&lt;/a&gt;() method one has to make sure that the lifetime of the &lt;a href=&quot;qsvgrenderer&quot;&gt;QSvgRenderer&lt;/a&gt; object will be at least as long as that of the &lt;a href=&quot;qgraphicssvgitem&quot;&gt;QGraphicsSvgItem&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qgraphicssvgitem&quot;&gt;QGraphicsSvgItem&lt;/a&gt; 에서 &lt;a href=&quot;qsvgrenderer&quot;&gt;QSvgRenderer&lt;/a&gt; 를 설정 한다고 해서 아이템이 렌더러의 소유권을 &lt;a href=&quot;qgraphicssvgitem#setSharedRenderer&quot;&gt;가지지&lt;/a&gt; 않으므로 setSharedRenderer () 메소드를 사용하는 경우 &lt;a href=&quot;qsvgrenderer&quot;&gt;QSvgRenderer&lt;/a&gt; 객체 의 수명 이 &lt;a href=&quot;qgraphicssvgitem&quot;&gt;QGraphicsSvgItem&lt;/a&gt; 의 수명보다 길어야 합니다 .</target>
        </trans-unit>
        <trans-unit id="7c52b9293e71272fda9324c2f7459bdece892ad5" translate="yes" xml:space="preserve">
          <source>Note that setting &lt;a href=&quot;qsvgrenderer&quot;&gt;QSvgRenderer&lt;/a&gt; on a QGraphicsSvgItem doesn't make the item take ownership of the renderer, therefore if using &lt;a href=&quot;qgraphicssvgitem#setSharedRenderer&quot;&gt;setSharedRenderer&lt;/a&gt;() method one has to make sure that the lifetime of the &lt;a href=&quot;qsvgrenderer&quot;&gt;QSvgRenderer&lt;/a&gt; object will be at least as long as that of the QGraphicsSvgItem.</source>
          <target state="translated">QGraphicsSvgItem에서 &lt;a href=&quot;qsvgrenderer&quot;&gt;QSvgRenderer&lt;/a&gt; 를 설정해도 항목이 렌더러의 소유권을 &lt;a href=&quot;qgraphicssvgitem#setSharedRenderer&quot;&gt;가지지&lt;/a&gt; 않으므로 setSharedRenderer () 메서드를 사용하는 경우 &lt;a href=&quot;qsvgrenderer&quot;&gt;QSvgRenderer&lt;/a&gt; 개체 의 수명이 적어도 QGraphicsSvgItem 의 수명만큼 긴지 확인해야합니다 .</target>
        </trans-unit>
        <trans-unit id="bc4f289addee1e29e92900e5bff7af86f202d643" translate="yes" xml:space="preserve">
          <source>Note that setting a source URL will result in the QML component being instantiated, even if the URL is unchanged from the current value.</source>
          <target state="translated">소스 URL을 설정하면 URL이 현재 값에서 변경되지 않은 경우에도 QML 구성 요소가 인스턴스화됩니다.</target>
        </trans-unit>
        <trans-unit id="06f6aa63927afe2f26a5bcadacae2318e77e5b64" translate="yes" xml:space="preserve">
          <source>Note that setting parameters like paper size and resolution on an invalid printer is undefined. You can use &lt;a href=&quot;qprinter#isValid&quot;&gt;QPrinter::isValid&lt;/a&gt;() to verify this before changing any parameters.</source>
          <target state="translated">유효하지 않은 프린터에서 용지 크기 및 해상도와 같은 매개 변수 설정은 정의되어 있지 않습니다. 매개 변수를 변경하기 전에 &lt;a href=&quot;qprinter#isValid&quot;&gt;QPrinter :: isValid&lt;/a&gt; ()를 사용하여이를 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a456954f29611613fc8d2c4d8b1afdea9ba7d4bc" translate="yes" xml:space="preserve">
          <source>Note that setting preventStealing to &lt;code&gt;true&lt;/code&gt; once an item has started stealing events has no effect until the next press event.</source>
          <target state="translated">항목이 이벤트를 훔치기 시작한 후 preventStealing을 &lt;code&gt;true&lt;/code&gt; 로 설정 하면 다음 프레스 이벤트까지 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="77982ec2935a70e6a0d7c3a6b5c0b0ccd29549f3" translate="yes" xml:space="preserve">
          <source>Note that setting preventStealing to true once an item has started stealing events will have no effect until the next press event.</source>
          <target state="translated">항목이 이벤트를 훔치기 시작한 후 preventStealing을 true로 설정하면 다음 프레스 이벤트까지 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d1c55dd183b4fb5f4c7db4ca94192eaf74ee1f66" translate="yes" xml:space="preserve">
          <source>Note that setting the entire list means removing all previous rules for watching services and adding new ones. This is an expensive operation and should be avoided, if possible. Instead, use &lt;a href=&quot;qdbusservicewatcher#addWatchedService&quot;&gt;addWatchedService&lt;/a&gt;() and &lt;a href=&quot;qdbusservicewatcher#removeWatchedService&quot;&gt;removeWatchedService&lt;/a&gt;() if you can to manipulate entries in the list.</source>
          <target state="translated">전체 목록을 설정한다는 것은 서비스 시청 및 새로운 규칙 추가에 대한 이전 규칙을 모두 제거한다는 것을 의미합니다. 이는 비용이 많이 드는 작업이므로 가능하면 피해야합니다. 대신 목록에서 항목을 조작 할 수있는 경우 &lt;a href=&quot;qdbusservicewatcher#addWatchedService&quot;&gt;addWatchedService&lt;/a&gt; () 및 &lt;a href=&quot;qdbusservicewatcher#removeWatchedService&quot;&gt;removeWatchedService&lt;/a&gt; ()를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="cef3505eb8c6dd3f2cc51b314b711cbd7fc78b39" translate="yes" xml:space="preserve">
          <source>Note that setting this flag does not imply that QGeoAreaMonitorInfoSource supports persistent monitoring. &lt;a href=&quot;qgeoareamonitorsource#supportedAreaMonitorFeatures&quot;&gt;QGeoAreaMonitorSource::supportedAreaMonitorFeatures&lt;/a&gt;() can be used to check for this feature's availability.</source>
          <target state="translated">이 플래그를 설정한다고해서 QGeoAreaMonitorInfoSource가 지속적 모니터링을 지원한다는 것을 의미하지는 않습니다. &lt;a href=&quot;qgeoareamonitorsource#supportedAreaMonitorFeatures&quot;&gt;QGeoAreaMonitorSource :: supportedAreaMonitorFeatures&lt;/a&gt; ()를 사용하여이 기능의 사용 가능 여부를 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7dab1a6bec4aa027a12cd6ede77bc6616aea6683" translate="yes" xml:space="preserve">
          <source>Note that setting this property will apply the limit immediately to the document contents.</source>
          <target state="translated">이 속성을 설정하면 문서 내용에 즉시 제한이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="45f0ea82267e22a7b4f59d0a21212c2ff451d376" translate="yes" xml:space="preserve">
          <source>Note that setting this property will apply the limit immediately to the document contents. Setting this property also disables the undo redo history.</source>
          <target state="translated">이 속성을 설정하면 문서 내용에 즉시 제한이 적용됩니다. 이 속성을 설정하면 실행 취소 재실행 기록도 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="62d2388c4b9ce54d640f3aeff26d90a6427e8f87" translate="yes" xml:space="preserve">
          <source>Note that setting this value to true will not have an immediate effect. Instead, the sensor will be started once the event loop has been reached.</source>
          <target state="translated">이 값을 true로 설정해도 즉각적인 효과는 없습니다. 대신 이벤트 루프에 도달하면 센서가 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="ecca1c5b065be8d76a9186be59630a0ec4f9fd79" translate="yes" xml:space="preserve">
          <source>Note that showMessage() is called to show temporary explanations of tool tip texts, so passing a</source>
          <target state="translated">showMessage ()는 툴팁 텍스트에 대한 임시 설명을 표시하기 위해 호출되므로 a</target>
        </trans-unit>
        <trans-unit id="a94378d5caa1942808d45a572429190e97778fb4" translate="yes" xml:space="preserve">
          <source>Note that signal and slot arguments are not checked by the compiler when using this &lt;a href=&quot;qobject#connect&quot;&gt;QObject::connect&lt;/a&gt;() overload.</source>
          <target state="translated">이 &lt;a href=&quot;qobject#connect&quot;&gt;QObject :: connect를&lt;/a&gt; 사용할 때 컴파일러는 신호 및 슬롯 인수를 확인하지 않습니다. () 오버로드를 .</target>
        </trans-unit>
        <trans-unit id="a4e00f1dbc9dc1ed054cf55123547d54b7f3eae8" translate="yes" xml:space="preserve">
          <source>Note that similarly to other percent methods, the percentage measurement is not linear with regards to the length, if curves are present in the path. When curves are present the percentage argument is mapped to the t parameter of the Bezier equations.</source>
          <target state="translated">경로에 곡선이있는 경우 다른 백분율 방법과 마찬가지로 백분율 측정은 길이와 관련하여 선형이 아닙니다. 곡선이 존재할 때 백분율 인수는 베 지어 방정식의 t 매개 변수에 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="e61192546337e3636dabcd41fceb433b6916268c" translate="yes" xml:space="preserve">
          <source>Note that similarly to the other percent methods, the percentage measurement is not linear with regards to the length if curves are present in the path. When curves are present the percentage argument is mapped to the t parameter of the Bezier equations.</source>
          <target state="translated">다른 퍼센트 방법과 마찬가지로 패스에 곡선이있는 경우 퍼센트 측정은 길이와 관련하여 선형이 아닙니다. 곡선이 존재할 때 백분율 인수는 베 지어 방정식의 t 매개 변수에 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="2c1282d63e40e5426a24a68117aecf20b0352809" translate="yes" xml:space="preserve">
          <source>Note that since the tab order of the</source>
          <target state="translated">탭 순서는</target>
        </trans-unit>
        <trans-unit id="82c941b7785be59e54a1d2aef99ba84315c2582e" translate="yes" xml:space="preserve">
          <source>Note that singleton types do not have an associated &lt;a href=&quot;qqmlcontext&quot;&gt;QQmlContext&lt;/a&gt; as they are shared across all contexts in an engine. &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; singleton type instances are constructed and owned by the &lt;a href=&quot;qqmlengine&quot;&gt;QQmlEngine&lt;/a&gt;, and will be destroyed when the engine is destroyed.</source>
          <target state="translated">싱글 톤 유형 에는 엔진의 모든 컨텍스트에서 공유 되므로 연관된 &lt;a href=&quot;qqmlcontext&quot;&gt;QQmlContext&lt;/a&gt; 가 없습니다 . &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 싱글 톤 타입 인스턴스는 &lt;a href=&quot;qqmlengine&quot;&gt;QQmlEngine에&lt;/a&gt; 의해 구성되고 소유됩니다 엔진이 파괴되면 소멸됩니다.</target>
        </trans-unit>
        <trans-unit id="8cd1ee27bdfea02b3dd15605f90c265515dd6421" translate="yes" xml:space="preserve">
          <source>Note that some databases need to be &lt;a href=&quot;qsqldriver#open&quot;&gt;open&lt;/a&gt;() before this can be determined.</source>
          <target state="translated">이를 결정하기 전에 일부 데이터베이스를 &lt;a href=&quot;qsqldriver#open&quot;&gt;열어야합니다&lt;/a&gt; ().</target>
        </trans-unit>
        <trans-unit id="09783a5c8c8ac6b6fc6a94d3058792a409358b41" translate="yes" xml:space="preserve">
          <source>Note that some databases, i.e. Microsoft SQL Server, requires non-scrollable cursors when working with multiple result sets. Some databases may execute all statements at once while others may delay the execution until the result set is actually accessed, and some databases may have restrictions on which statements are allowed to be used in a SQL batch.</source>
          <target state="translated">Microsoft SQL Server와 같은 일부 데이터베이스는 여러 결과 집합으로 작업 할 때 스크롤 할 수없는 커서가 필요합니다. 일부 데이터베이스는 모든 명령문을 한 번에 실행할 수 있지만 다른 데이터베이스는 결과 세트에 실제로 액세스 할 때까지 실행을 지연시킬 수 있으며 일부 데이터베이스는 SQL 배치에서 사용할 수있는 명령문에 제한이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b4532d0e850703932803484cc9927824f3af73c" translate="yes" xml:space="preserve">
          <source>Note that some of the capturing groups with an index less than lastCapturedIndex() could have not matched, and therefore captured nothing.</source>
          <target state="translated">lastCapturedIndex ()보다 작은 인덱스를 가진 캡처 그룹 중 일부는 일치하지 않았으므로 아무 것도 캡처하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="946b44a084b3caee40fff6ab6dd5112b0c56b163" translate="yes" xml:space="preserve">
          <source>Note that some of these settings mirror settings in some paint devices, e.g. &lt;a href=&quot;qwidget#font-prop&quot;&gt;QWidget::font&lt;/a&gt;(). The &lt;a href=&quot;qpainter#begin&quot;&gt;QPainter::begin&lt;/a&gt;() function (or equivalently the &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; constructor) copies these attributes from the paint device.</source>
          <target state="translated">이러한 설정 중 일부는 &lt;a href=&quot;qwidget#font-prop&quot;&gt;QWidget :: font&lt;/a&gt; () 와 같은 일부 페인트 장치에서 설정을 반영 합니다. &lt;a href=&quot;qpainter#begin&quot;&gt;QPainter를이 :: 시작&lt;/a&gt; () 함수 (또는 동등 &lt;a href=&quot;qpainter&quot;&gt;QPainter가의&lt;/a&gt; 생성자) 복사 페인트 장치에서 이러한 특성을.</target>
        </trans-unit>
        <trans-unit id="9a3544a9151590bf2542e6c820a66df9b0c29643" translate="yes" xml:space="preserve">
          <source>Note that some of these settings mirror settings in some paint devices, e.g. &lt;a href=&quot;qwidget#font-prop&quot;&gt;QWidget::font&lt;/a&gt;(). The &lt;a href=&quot;qpainter#begin&quot;&gt;QPainter::begin&lt;/a&gt;() function (or equivalently the QPainter constructor) copies these attributes from the paint device.</source>
          <target state="translated">이러한 설정 중 일부는 &lt;a href=&quot;qwidget#font-prop&quot;&gt;QWidget :: font&lt;/a&gt; () 와 같은 일부 페인트 장치의 설정을 반영 합니다. &lt;a href=&quot;qpainter#begin&quot;&gt;QPainter를이 :: 시작&lt;/a&gt; () 함수 (또는 동등 QPainter를 생성자) 복사 페인트 장치에서 이러한 특성을.</target>
        </trans-unit>
        <trans-unit id="3f7fa47e4dafaf1a7c45f943621ca5416dcbe7a3" translate="yes" xml:space="preserve">
          <source>Note that some properties, such as &lt;code&gt;enabled&lt;/code&gt;, &lt;code&gt;text&lt;/code&gt;, or &lt;code&gt;iconSource&lt;/code&gt;, only make sense in a particular use case of the menu.</source>
          <target state="translated">&lt;code&gt;enabled&lt;/code&gt; , &lt;code&gt;text&lt;/code&gt; 또는 &lt;code&gt;iconSource&lt;/code&gt; 와 같은 일부 속성 은 메뉴의 특정 사용 사례에서만 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b9ca420865ae8edadf2e02e36a2786161f0a9c59" translate="yes" xml:space="preserve">
          <source>Note that some rounding may occur if</source>
          <target state="translated">다음과 같은 경우 반올림이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="200ebe8ec2356e04f060f86f2a66f22bfd9fe302" translate="yes" xml:space="preserve">
          <source>Note that some standard page sizes are defined with a width larger than their height, hence the orientation is defined relative to the standard page size and not using the relative page dimensions.</source>
          <target state="translated">일부 표준 페이지 크기는 높이보다 큰 너비로 정의되므로 방향은 표준 페이지 크기를 기준으로 정의되며 상대 페이지 크기를 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ae81adf523aee4176e1e1faaab7cb34ecf6a454e" translate="yes" xml:space="preserve">
          <source>Note that some styles might render &lt;a href=&quot;qabstractspinbox#ButtonSymbols-enum&quot;&gt;PlusMinus&lt;/a&gt; and &lt;a href=&quot;qabstractspinbox#ButtonSymbols-enum&quot;&gt;UpDownArrows&lt;/a&gt; identically.</source>
          <target state="translated">일부 스타일은 &lt;a href=&quot;qabstractspinbox#ButtonSymbols-enum&quot;&gt;PlusMinus&lt;/a&gt; 및 &lt;a href=&quot;qabstractspinbox#ButtonSymbols-enum&quot;&gt;UpDownArrows를&lt;/a&gt; 렌더링 할 수 있습니다. 동일하게 .</target>
        </trans-unit>
        <trans-unit id="77ab6bd9653307d36fe8fe4530270de865375ab3" translate="yes" xml:space="preserve">
          <source>Note that specifying a search center can be done by setting a circular search area that has a center but no radius. The default radius is set to -1, which indicates an undefined radius. The provider will interpret this as being free to choose its own default radius.</source>
          <target state="translated">중심은 있지만 반경은없는 원형 검색 영역을 설정하여 검색 센터를 지정할 수 있습니다. 기본 반지름은 -1로 설정되어 정의되지 않은 반지름을 나타냅니다. 제공자는이를 자신의 기본 반경을 자유롭게 선택할 수있는 것으로 해석합니다.</target>
        </trans-unit>
        <trans-unit id="735e7ba1294b8eed1d89f09281a17aa37d326aee" translate="yes" xml:space="preserve">
          <source>Note that specifying the local device to be used for the connection is only possible when using &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtbluetooth-attribution-bluez.html&quot;&gt;BlueZ&lt;/a&gt;. All other platforms do not support this feature.</source>
          <target state="translated">연결에 사용할 로컬 장치를 지정하는 것은 &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtbluetooth-attribution-bluez.html&quot;&gt;BlueZ를&lt;/a&gt; 사용할 때만 가능합니다 . 다른 모든 플랫폼은이 기능을 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0f1008d6d395cde97cdc6c1699c16e6df8a76ac4" translate="yes" xml:space="preserve">
          <source>Note that startPrefixMapping() and &lt;a href=&quot;qxmlcontenthandler#endPrefixMapping&quot;&gt;endPrefixMapping&lt;/a&gt;() calls are not guaranteed to be properly nested relative to each other: all startPrefixMapping() events occur before the corresponding &lt;a href=&quot;qxmlcontenthandler#startElement&quot;&gt;startElement&lt;/a&gt;() event, and all &lt;a href=&quot;qxmlcontenthandler#endPrefixMapping&quot;&gt;endPrefixMapping&lt;/a&gt;() events occur after the corresponding &lt;a href=&quot;qxmlcontenthandler#endElement&quot;&gt;endElement&lt;/a&gt;() event, but their order is not otherwise guaranteed.</source>
          <target state="translated">startPrefixMapping () 및 &lt;a href=&quot;qxmlcontenthandler#endPrefixMapping&quot;&gt;endPrefixMapping&lt;/a&gt; () 호출은 서로에 대해 올바르게 중첩되지 않을 수 있습니다. 모든 startPrefixMapping () 이벤트는 해당 &lt;a href=&quot;qxmlcontenthandler#startElement&quot;&gt;startElement&lt;/a&gt; () 이벤트 전에 발생 하며 모든 &lt;a href=&quot;qxmlcontenthandler#endPrefixMapping&quot;&gt;endPrefixMapping&lt;/a&gt; () 이벤트는 해당 &lt;a href=&quot;qxmlcontenthandler#endElement&quot;&gt;endElement&lt;/a&gt; () 이벤트 후에 발생합니다. 하지만 순서는 보장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0cd6447c94eaf7e1c7a48950387ed79e9d1d840e" translate="yes" xml:space="preserve">
          <source>Note that steps lie between 0.0 and 1.0. It may be necessary to use &lt;a href=&quot;qtimeline#updateInterval-prop&quot;&gt;setUpdateInterval()&lt;/a&gt;. The default update interval is 40 ms. A scheduled transformation cannot be removed when set, so scheduling several transformations of the same kind (e.g., rotations) at the same step is not recommended.</source>
          <target state="translated">단계는 0.0과 1.0 사이에 있습니다. &lt;a href=&quot;qtimeline#updateInterval-prop&quot;&gt;setUpdateInterval ()&lt;/a&gt; 을 사용해야 할 수도 있습니다. . 기본 업데이트 간격은 40ms입니다. 예약 된 변환은 설정시 제거 할 수 없으므로 동일한 단계에서 동일한 종류 (예 : 회전)의 여러 변환 예약은 권장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8da8e95e94dd3114b96d2fef726fcf0d76e1cb1e" translate="yes" xml:space="preserve">
          <source>Note that styles are free to choose any color from the palette. You can modify the palette or set a style sheet if you don't achieve the result you want with setBackgroundRole().</source>
          <target state="translated">스타일은 팔레트에서 색상을 자유롭게 선택할 수 있습니다. setBackgroundRole ()을 사용하여 원하는 결과를 얻지 못하면 팔레트를 수정하거나 스타일 시트를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4ee128161fcbcfb5cf0e8060e60915f2879004b" translate="yes" xml:space="preserve">
          <source>Note that styles are free to choose any color from the palette. You can modify the palette or set a style sheet if you don't achieve the result you want with setForegroundRole().</source>
          <target state="translated">스타일은 팔레트에서 색상을 자유롭게 선택할 수 있습니다. setForegroundRole ()로 원하는 결과를 얻지 못하면 팔레트를 수정하거나 스타일 시트를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc0ca310c25d964ee94b62c4015ffc123fd8d445" translate="yes" xml:space="preserve">
          <source>Note that sub controls are not the same as the control elements described in the previous section. You cannot use the style to draw a sub control; the style will only calculate the bounding rectangle in which the sub control should be drawn. It is common, though, that complex elements use control and primitive elements to draw their sub controls, which is an approach that is frequently used by the built-in styles in Qt and also the Java style. For instance, the Java style uses PE_IndicatorCheckBox to draw the check box in group boxes (which is a sub control of &lt;code&gt;CC_GroupBox&lt;/code&gt;). Some sub controls have an equivalent control element, e.g., the scroll bar slider (&lt;code&gt;SC_SCrollBarSlider&lt;/code&gt; and &lt;code&gt;CE_ScrollBarSlider&lt;/code&gt;).</source>
          <target state="translated">하위 컨트롤은 이전 섹션에서 설명한 컨트롤 요소와 동일하지 않습니다. 하위 컨트롤을 그리는 데 스타일을 사용할 수 없습니다. 스타일은 하위 컨트롤을 그릴 경계 사각형 만 계산합니다. 그러나 복잡한 요소는 컨트롤과 기본 요소를 사용하여 하위 컨트롤을 그리는 것이 일반적입니다. 이는 Qt의 내장 스타일과 Java 스타일에서 자주 사용되는 접근 방식입니다. 예를 들어, 자바 스타일 (의 하위 컨트롤입니다 그룹 상자에서 확인란을 그릴 PE_IndicatorCheckBox를 사용 &lt;code&gt;CC_GroupBox&lt;/code&gt; 을 ). 일부 하위 제어에는 스크롤 막대 슬라이더 ( &lt;code&gt;SC_SCrollBarSlider&lt;/code&gt; 및 &lt;code&gt;CE_ScrollBarSlider&lt;/code&gt; ) 와 동등한 제어 요소가 있습니다. ) 있습니다.</target>
        </trans-unit>
        <trans-unit id="b1ef38fed13b2484b62d214ff64f9cd8a4e2bfac" translate="yes" xml:space="preserve">
          <source>Note that subclasses that reimplement &lt;a href=&quot;qvariant#clear&quot;&gt;clear&lt;/a&gt;() should reimplement the destructor to call &lt;a href=&quot;qvariant#clear&quot;&gt;clear&lt;/a&gt;(). This destructor calls &lt;a href=&quot;qvariant#clear&quot;&gt;clear&lt;/a&gt;(), but because it is the destructor, &lt;a href=&quot;qvariant#clear&quot;&gt;QVariant::clear&lt;/a&gt;() is called rather than a subclass's &lt;a href=&quot;qvariant#clear&quot;&gt;clear&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qvariant#clear&quot;&gt;clear&lt;/a&gt; () 를 다시 구현하는 서브 클래스 는 소멸자를 다시 구현하여 &lt;a href=&quot;qvariant#clear&quot;&gt;clear&lt;/a&gt; () 를 호출해야합니다 . 이 소멸자는 &lt;a href=&quot;qvariant#clear&quot;&gt;clear&lt;/a&gt; ()를 호출 하지만 소멸자이므로 &lt;a href=&quot;qvariant#clear&quot;&gt;QVariant :: clear&lt;/a&gt; ()는 하위 클래스의 &lt;a href=&quot;qvariant#clear&quot;&gt;clear가&lt;/a&gt; 아니라 호출됩니다. ()가 됩니다.</target>
        </trans-unit>
        <trans-unit id="643a90b7cc572aa8f24a2a4aeec18309319e74d7" translate="yes" xml:space="preserve">
          <source>Note that the</source>
          <target state="translated">참고</target>
        </trans-unit>
        <trans-unit id="71f730a30b7ed28a2a3b091faf86c60ceb68df06" translate="yes" xml:space="preserve">
          <source>Note that the &quot;enabled&quot; status for a given message is a property of the (id, source, type, severity) tuple; the message attributes</source>
          <target state="translated">주어진 메시지에 대한 &quot;사용 가능&quot;상태는 (ID, 소스, 유형, 심각도) 튜플의 속성입니다. 메시지 속성</target>
        </trans-unit>
        <trans-unit id="f2bd2451b18a247a530fc233330342f5f316b1ad" translate="yes" xml:space="preserve">
          <source>Note that the -iterations command line argument has no effect on test functions without the QBENCHMARK macro.</source>
          <target state="translated">-iterations 명령 행 인수는 QBENCHMARK 매크로가없는 테스트 기능에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5dfdc3b6cc92124a0773cfeaaec6796010463e1d" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;qapplication&quot;&gt;QApplication&lt;/a&gt; instance must be created before this function is called.</source>
          <target state="translated">점을 유의 &lt;a href=&quot;qapplication&quot;&gt;의 QApplication&lt;/a&gt; 이 함수가 호출되기 전에 인스턴스를 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="1023fd844e5aee23a360aba54cabb15d72df9ea5" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;qfuture#result&quot;&gt;QFuture::result&lt;/a&gt;() function blocks and waits for the result to become available. Use &lt;a href=&quot;qfuturewatcher&quot;&gt;QFutureWatcher&lt;/a&gt; to get notification when the function has finished execution and the result is available.</source>
          <target state="translated">있습니다 &lt;a href=&quot;qfuture#result&quot;&gt;QFuture :: 결과&lt;/a&gt; 결과에 대한 () 함수 블록 및 대기 사용할 수있게 할 수 있습니다. &lt;a href=&quot;qfuturewatcher&quot;&gt;QFutureWatcher&lt;/a&gt; 사용함수가 실행을 완료하고 결과를 사용할 수있을 때 를 하여 알림을받습니다.</target>
        </trans-unit>
        <trans-unit id="dee5acf7be82760b42b43776bbd056dca352dc91" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;qgradient#setSpread&quot;&gt;setSpread&lt;/a&gt;() function has no effect for conical gradients. The reason is that the conical gradient is closed by definition, i.e. the conical gradient fills the entire circle from 0 - 360 degrees, while the boundary of a radial or a linear gradient can be specified through its radius or final stop points, respectively.</source>
          <target state="translated">점을 유의 &lt;a href=&quot;qgradient#setSpread&quot;&gt;setSpread&lt;/a&gt; () 함수 원추 구배에 영향을 미치지 않는다. 그 이유는 원뿔형 그래디언트가 정의에 의해 닫히기 때문입니다. 즉, 원뿔형 그래디언트는 전체 원을 0-360도까지 채우고 방사형 또는 선형 그래디언트의 경계는 각각 반경 또는 최종 정지 점을 통해 지정할 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="7fd27a7f67842eccce40bf3dd5cd033beae43817" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;qgradient#setSpread&quot;&gt;setSpread&lt;/a&gt;() function only has effect for linear and radial gradients. The reason is that the conical gradient is closed by definition, i.e. the</source>
          <target state="translated">참고 것을 &lt;a href=&quot;qgradient#setSpread&quot;&gt;setSpread&lt;/a&gt; () 함수는 선형 및 방사형 그라데이션에 대한 효과를 갖는다. 그 이유는 원뿔형 그래디언트가 정의에 의해 닫혀 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="ab59c6b133d4e06194ec76c374b18d401e0e0cae" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;qguiapplication&quot;&gt;QGuiApplication&lt;/a&gt; instance must be created before this function is called.</source>
          <target state="translated">합니다 &lt;a href=&quot;qguiapplication&quot;&gt;QGuiApplication&lt;/a&gt; 이 함수가 호출되기 전에 인스턴스를 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="05da42d9f9beaf37c52688678852ffc46519055b" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;qheaderview#sectionPressed&quot;&gt;sectionPressed&lt;/a&gt; signal will also be emitted.</source>
          <target state="translated">점을 유의 &lt;a href=&quot;qheaderview#sectionPressed&quot;&gt;sectionPressed&lt;/a&gt; 신호도 방출한다.</target>
        </trans-unit>
        <trans-unit id="a867b8041831ecef49eaed317e995c47b07a1659" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;qheaderview#visualIndex&quot;&gt;visualIndex&lt;/a&gt; is not affected by hidden sections.</source>
          <target state="translated">있습니다 &lt;a href=&quot;qheaderview#visualIndex&quot;&gt;visualIndex가&lt;/a&gt; 숨겨진 섹션의 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a5b097d9ad4de72fe93971c6dce58b47b73cd395" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt; is mirrored vertically to account for the fact that OpenGL and &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt; use opposite directions for the y axis. Another option would be to transform your texture coordinates.</source>
          <target state="translated">점을 유의 &lt;a href=&quot;qimage&quot;&gt;QImage는&lt;/a&gt; OpenGL을하고 있다는 사실을 고려하여 수직 미러링 &lt;a href=&quot;qimage&quot;&gt;QImage은&lt;/a&gt; 은 Y 축에 대해 반대 방향으로 사용한다. 다른 옵션은 텍스처 좌표를 변환하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="81c3cf945a9188a169e31c4b65beb5acda830793" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;qkeysequence#StandardKey-enum&quot;&gt;QKeySequence::StandardKey&lt;/a&gt; sequences will always be based on the same modifier (i.e., &lt;a href=&quot;qkeysequence#StandardKey-enum&quot;&gt;QKeySequence::Copy&lt;/a&gt; will be Command+C regardless of the value set), but what is output for &lt;a href=&quot;qkeysequence#toString&quot;&gt;QKeySequence::toString&lt;/a&gt;() will be different.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e0f671dd9e48393d5a72bafa91195c66750a973" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt; the object should fill has to be provided as an element in the parameter list of &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt;s.</source>
          <target state="translated">객체가 채워야 하는 &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt; 는 &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; 의 파라미터 목록에 요소로 제공되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="4f7737d606f85a800158bc14d6e2b5c25f820104" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;qml-qt-labs-folderlistmodel-folderlistmodel#nameFilters-prop&quot;&gt;nameFilters&lt;/a&gt; are not applied to directories.</source>
          <target state="translated">있습니다 &lt;a href=&quot;qml-qt-labs-folderlistmodel-folderlistmodel#nameFilters-prop&quot;&gt;nameFilters이&lt;/a&gt; 디렉토리에 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="848a7f528cc382a3f57c82fd54587b9b93c2c23f" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;qml-qtquick-controls-statusbar&quot;&gt;StatusBar&lt;/a&gt; does not provide a layout of its own, but requires you to position its contents, for instance by creating a &lt;a href=&quot;qml-qtquick-layouts-rowlayout&quot;&gt;RowLayout&lt;/a&gt;.</source>
          <target state="translated">있습니다 &lt;a href=&quot;qml-qtquick-controls-statusbar&quot;&gt;상태 바는&lt;/a&gt; 자신의 레이아웃을 제공하지만, 만들어 예를 들어, 그 내용을 위치하도록 요구하지 않습니다 &lt;a href=&quot;qml-qtquick-layouts-rowlayout&quot;&gt;RowLayout을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="08da4044255777a68025d93b76f91c05131a9c65" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;qml-qtquick-controls-toolbar&quot;&gt;ToolBar&lt;/a&gt; does not provide a layout of its own, but requires you to position its contents, for instance by creating a &lt;a href=&quot;qml-qtquick-layouts-rowlayout&quot;&gt;RowLayout&lt;/a&gt;.</source>
          <target state="translated">있습니다 &lt;a href=&quot;qml-qtquick-controls-toolbar&quot;&gt;도구 모음이&lt;/a&gt; 자신의 레이아웃을 제공하지만, 만들어 예를 들어, 그 내용을 위치하도록 요구하지 않습니다 &lt;a href=&quot;qml-qtquick-layouts-rowlayout&quot;&gt;RowLayout을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9b8af5841f7807fccfdc20638322e0e20b8e39ba" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;qml-qtquick-pathview&quot;&gt;PathView&lt;/a&gt; will layout the items based on the size of the root item in the delegate.</source>
          <target state="translated">있습니다 &lt;a href=&quot;qml-qtquick-pathview&quot;&gt;PathView은&lt;/a&gt; 대리인의 루트 항목의 크기에 따라 항목을 레이아웃합니다.</target>
        </trans-unit>
        <trans-unit id="883ed88b93a09e8abe33a455a25cd8011e045251" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;qml-qtquick-textedit&quot;&gt;TextEdit&lt;/a&gt; does not implement scrolling, following the cursor, or other behaviors specific to a look-and-feel. For example, to add flickable scrolling that follows the cursor:</source>
          <target state="translated">참고 것을 &lt;a href=&quot;qml-qtquick-textedit&quot;&gt;텍스트 편집기&lt;/a&gt; , 스크롤 모양과 느낌 커서, 또는 다른 행동의 특정에 따라 구현하지 않습니다. 예를 들어 커서 뒤에 긋기 가능한 스크롤을 추가하려면</target>
        </trans-unit>
        <trans-unit id="be1bd7a76bf7571d92956e8b72416f25aa6bdc1d" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;qobject#destroyed&quot;&gt;destroyed&lt;/a&gt;() signal will be emitted even if the signals for this object have been blocked.</source>
          <target state="translated">점을 유의 &lt;a href=&quot;qobject#destroyed&quot;&gt;파괴&lt;/a&gt; () 신호는이 오브젝트의 신호가 차단 된 경우에도 배출된다.</target>
        </trans-unit>
        <trans-unit id="cc33ace551357735af6e7ee6b05d46844bc799b2" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;qpagesize&quot;&gt;QPageSize&lt;/a&gt; is always defined in a Portrait orientation. To obtain a size that takes the set orientation into account you must use &lt;a href=&quot;qpagelayout#fullRect&quot;&gt;fullRect&lt;/a&gt;().</source>
          <target state="translated">있습니다 &lt;a href=&quot;qpagesize&quot;&gt;QPageSize는&lt;/a&gt; 항상 세로 방향으로 정의된다. 설정된 방향을 고려한 크기를 얻으려면 &lt;a href=&quot;qpagelayout#fullRect&quot;&gt;fullRect&lt;/a&gt; () 를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="5789c9cac29296f213e8281aa040208dea709628" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;qpluginloader&quot;&gt;QPluginLoader&lt;/a&gt; cannot be used if your application is statically linked against Qt. In this case, you will also have to link to plugins statically. You can use &lt;a href=&quot;qlibrary&quot;&gt;QLibrary&lt;/a&gt; if you need to load dynamic libraries in a statically linked application.</source>
          <target state="translated">있습니다 &lt;a href=&quot;qpluginloader&quot;&gt;QPluginLoader는&lt;/a&gt; 응용 프로그램이 정적으로 Qt는에 연결되어있는 경우 사용할 수 없습니다. 이 경우 플러그인에 정적으로 연결해야합니다. 정적으로 링크 된 응용 프로그램에서 동적 라이브러리를로드 &lt;a href=&quot;qlibrary&quot;&gt;해야하는&lt;/a&gt; 경우 QLibrary 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3d0c1071fd7ee101d6962994adc4391884e26494" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;qweakpointer&quot;&gt;QWeakPointer&lt;/a&gt;, &lt;a href=&quot;qsharedpointer&quot;&gt;QSharedPointer&lt;/a&gt; and &lt;a href=&quot;qpointer&quot;&gt;QPointer&lt;/a&gt; already have built-in support, and it is not necessary to use this macro with them.</source>
          <target state="translated">있습니다 &lt;a href=&quot;qweakpointer&quot;&gt;QWeakPointer&lt;/a&gt; , &lt;a href=&quot;qsharedpointer&quot;&gt;QSharedPointer&lt;/a&gt; 및 &lt;a href=&quot;qpointer&quot;&gt;QPointer가&lt;/a&gt; 이미 지원 내장 한, 그리고 그들과 함께이 매크로를 사용할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="443da81710d71b6f038a59388f6e320cdf06abfb" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;richtext-html-subset&quot;&gt;Supported HTML Subset&lt;/a&gt; is limited. Also, if the text contains HTML img tags that load remote images, the text is reloaded.</source>
          <target state="translated">있습니다 &lt;a href=&quot;richtext-html-subset&quot;&gt;지원되는 HTML 부분적인&lt;/a&gt; 제한됩니다. 또한 텍스트에 원격 이미지를로드하는 HTML img 태그가 포함 된 경우 텍스트가 다시로드됩니다.</target>
        </trans-unit>
        <trans-unit id="11e804fb15997803c6697cc12984b430a5f8e821" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;&amp;lt;Identifier&amp;gt;&lt;/code&gt; must be unique within a QML document, unlike the local namespace qualifier which can be applied to module imports.</source>
          <target state="translated">참고 그 &lt;code&gt;&amp;lt;Identifier&amp;gt;&lt;/code&gt; 모듈 수입에 적용 할 수있는 로컬 네임 스페이스 한정자는 달리, QML 문서 내에서 고유해야합니다.</target>
        </trans-unit>
        <trans-unit id="847b03b1eadcdf15f1e441daa9906758c0158006" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;GL_KHR_debug&lt;/code&gt; extension</source>
          <target state="translated">참고 그 &lt;code&gt;GL_KHR_debug&lt;/code&gt; 의 확장</target>
        </trans-unit>
        <trans-unit id="dd5320fdb8f9af4dbc0a389b6543464d9e0b799d" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;StringListModel&lt;/code&gt; is declared as a &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt;. This allows us to use the abstract interface to the model, and ensures that the code still works, even if we replace the string list model with a different model.</source>
          <target state="translated">있습니다 &lt;code&gt;StringListModel&lt;/code&gt; 는 A와 선언 &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; . 이를 통해 모델에 대한 추상 인터페이스를 사용할 수 있으며 문자열 목록 모델을 다른 모델로 바꾸어도 코드가 계속 작동합니다.</target>
        </trans-unit>
        <trans-unit id="4bedf3a189cbb6eea784bde270f844c0a127ce96" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;finished&lt;/code&gt; signals should always be emitted when a reply is complete, even if an error has been encountered, that is, if there is an error, both the &lt;code&gt;error&lt;/code&gt; and &lt;code&gt;finished&lt;/code&gt; signals should be emitted while if there is no error, only the &lt;code&gt;finished&lt;/code&gt; signals are emitted.</source>
          <target state="translated">것을 주 &lt;code&gt;finished&lt;/code&gt; 응답이 오류가 오류가있는 경우, 인 모두가, 발생 된 경우에도 완료되면 신호가 항상 발생해야 할 &lt;code&gt;error&lt;/code&gt; 및 &lt;code&gt;finished&lt;/code&gt; 신호가 방출되어야하는 동안 오류 만이없는 경우 &lt;code&gt;finished&lt;/code&gt; 신호가 방출됩니다.</target>
        </trans-unit>
        <trans-unit id="24001e235efaa1ed44fde131d9113fbc3e5060ba" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;import MyStyle 1.0&lt;/code&gt; statement is only necessary because we are using the attached property belonging to &lt;code&gt;MyStyle&lt;/code&gt;. Both buttons will use our custom style, even if we were to remove the import.</source>
          <target state="translated">점을 유의 &lt;code&gt;import MyStyle 1.0&lt;/code&gt; 우리가에 속하는 연결된 속성 사용하기 때문에 문에만 필요 &lt;code&gt;MyStyle&lt;/code&gt; 을 . 가져 오기를 제거하더라도 두 버튼 모두 사용자 정의 스타일을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="169a9baa56231264710348d06dc0240107d42b3b" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;setValue()&lt;/code&gt; function sets the value and emits the signal only if &lt;code&gt;value != m_value&lt;/code&gt;. This prevents infinite looping in the case of cyclic connections (e.g., if &lt;code&gt;b.valueChanged()&lt;/code&gt; were connected to &lt;code&gt;a.setValue()&lt;/code&gt;).</source>
          <target state="translated">점을 유의 &lt;code&gt;setValue()&lt;/code&gt; 함수의 값을 설정하고 신호 인 경우에만 방출 &lt;code&gt;value != m_value&lt;/code&gt; . 이 방지가 연결 고리의 경우에는 무한 루프 (경우, 예 &lt;code&gt;b.valueChanged()&lt;/code&gt; 접속 된 &lt;code&gt;a.setValue()&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="d3427cfdefa7ee4eb458261d9c8225164c95d019" translate="yes" xml:space="preserve">
          <source>Note that the JavaScript &lt;a href=&quot;qwebchannel&quot;&gt;QWebChannel&lt;/a&gt; object should be constructed once the transport object is fully operational. In case of a WebSocket, that means you should create the &lt;a href=&quot;qwebchannel&quot;&gt;QWebChannel&lt;/a&gt; in the socket's &lt;code&gt;onopen&lt;/code&gt; handler. Take a look at the &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtwebchannel-standalone-example.html#&quot;&gt;Qt WebChannel Standalone Example&lt;/a&gt; to see how this is done.</source>
          <target state="translated">전송 오브젝트가 완전히 작동되면 JavaScript &lt;a href=&quot;qwebchannel&quot;&gt;QWebChannel&lt;/a&gt; 오브젝트를 구성해야합니다. WebSocket의 경우 소켓의 &lt;code&gt;onopen&lt;/code&gt; 핸들러 에서 &lt;a href=&quot;qwebchannel&quot;&gt;QWebChannel&lt;/a&gt; 을 작성해야 합니다. 상기 봐 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtwebchannel-standalone-example.html#&quot;&gt;Qt는 WebChannel 독립 예&lt;/a&gt; 이 작업을 수행하는 방법을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ebe56e6c218928ffe8a0fec547089b83f2da4a26" translate="yes" xml:space="preserve">
          <source>Note that the JavaScript &lt;a href=&quot;qwebchannel&quot;&gt;QWebChannel&lt;/a&gt; object should be constructed once the transport object is fully operational. In case of a WebSocket, that means you should create the &lt;a href=&quot;qwebchannel&quot;&gt;QWebChannel&lt;/a&gt; in the socket's &lt;code&gt;onopen&lt;/code&gt; handler. Take a look at the &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtwebchannel-standalone-example.html&quot;&gt;Qt WebChannel Standalone Example&lt;/a&gt; to see how this is done.</source>
          <target state="translated">전송 개체가 완전히 작동 하면 JavaScript &lt;a href=&quot;qwebchannel&quot;&gt;QWebChannel&lt;/a&gt; 개체를 구성해야합니다. WebSocket의 경우 소켓의 &lt;code&gt;onopen&lt;/code&gt; 핸들러에 &lt;a href=&quot;qwebchannel&quot;&gt;QWebChannel&lt;/a&gt; 을 생성해야 합니다. 이것이 어떻게 수행되는지 확인 하려면 &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtwebchannel-standalone-example.html&quot;&gt;Qt WebChannel Standalone 예제&lt;/a&gt; 를 살펴보십시오.</target>
        </trans-unit>
        <trans-unit id="cf4e8eec1eef58c10d358a2a959d8098947d2a66" translate="yes" xml:space="preserve">
          <source>Note that the OLE default verbs (OLEIVERB_SHOW etc) are not included in the list.</source>
          <target state="translated">OLE 기본 동사 (OLEIVERB_SHOW 등)는 목록에 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="471c2bae1360086a883f416e1d2a845a51fe3293" translate="yes" xml:space="preserve">
          <source>Note that the QPluginLoader cannot be used if your application is statically linked against Qt. In this case, you will also have to link to plugins statically. You can use &lt;a href=&quot;qlibrary&quot;&gt;QLibrary&lt;/a&gt; if you need to load dynamic libraries in a statically linked application.</source>
          <target state="translated">애플리케이션이 Qt에 정적으로 링크 된 경우 QPluginLoader를 사용할 수 없습니다. 이 경우 플러그인에 정적으로 링크해야합니다. 정적으로 링크 된 애플리케이션에서 동적 라이브러리를로드 &lt;a href=&quot;qlibrary&quot;&gt;해야하는&lt;/a&gt; 경우 QLibrary 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="229af0d84a09c457b894ddbb9fe4392411055dfa" translate="yes" xml:space="preserve">
          <source>Note that the Qt 5 implementation has several limitations compared to Qt 4:</source>
          <target state="translated">Qt 5 구현에는 Qt 4와 비교하여 몇 가지 제한 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b015451bcc21149858e91a44c06edfabaebff8bb" translate="yes" xml:space="preserve">
          <source>Note that the Screen type is not valid at Component.onCompleted, because the Item or Window has not been displayed on a screen by this time.</source>
          <target state="translated">이때까지 화면에 항목 또는 창이 표시되지 않았으므로 Component.onCompleted에서 화면 유형이 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7eecc87ac27225867547020cb7ef8c712f66b9ca" translate="yes" xml:space="preserve">
          <source>Note that the StatusBar does not provide a layout of its own, but requires you to position its contents, for instance by creating a &lt;a href=&quot;qml-qtquick-layouts-rowlayout&quot;&gt;RowLayout&lt;/a&gt;.</source>
          <target state="translated">StatusBar는 자체 레이아웃을 제공하지 않지만 예를 들어 &lt;a href=&quot;qml-qtquick-layouts-rowlayout&quot;&gt;RowLayout&lt;/a&gt; 을 생성하여 콘텐츠를 배치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="b3e45b125ccf53324483c7018c8e17e4f0f6004c" translate="yes" xml:space="preserve">
          <source>Note that the TextEdit does not implement scrolling, following the cursor, or other behaviors specific to a look and feel. For example, to add flickable scrolling that follows the cursor:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55943947f58862bcfd2f3cce1a34405452a8ae7b" translate="yes" xml:space="preserve">
          <source>Note that the TextEdit does not implement scrolling, following the cursor, or other behaviors specific to a look-and-feel. For example, to add flickable scrolling that follows the cursor:</source>
          <target state="translated">TextEdit는 스크롤, 커서 따라 가기 또는 모양과 느낌에 특정한 다른 동작을 구현하지 않습니다. 예를 들어, 커서를 따라 움직이는 스크롤링을 추가하려면 :</target>
        </trans-unit>
        <trans-unit id="f538fbb99c0424600a4cae0d588f642aaa605f9c" translate="yes" xml:space="preserve">
          <source>Note that the ToolBar does not provide a layout of its own, but requires you to position its contents, for instance by creating a &lt;a href=&quot;qml-qtquick-layouts-rowlayout&quot;&gt;RowLayout&lt;/a&gt;.</source>
          <target state="translated">ToolBar는 자체 레이아웃을 제공하지 않지만 예를 들어 &lt;a href=&quot;qml-qtquick-layouts-rowlayout&quot;&gt;RowLayout&lt;/a&gt; 을 생성하여 콘텐츠를 배치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="3767f8f7183ff0cc865c849df04238b920c0e22a" translate="yes" xml:space="preserve">
          <source>Note that the Windows registry and INI files use case-insensitive keys, whereas the CFPreferences API on &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; and iOS uses case-sensitive keys. To avoid portability problems, see the &lt;a href=&quot;qsettings#section-and-key-syntax&quot;&gt;Section and Key Syntax&lt;/a&gt; rules.</source>
          <target state="translated">Windows 레지스트리 및 INI 파일은 대소 문자를 구분하지 않는 반면 &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; 및 iOS 의 CFPreferences API 는 대소 문자를 구분하는 키를 사용합니다. 이식성 문제를 피하려면 &lt;a href=&quot;qsettings#section-and-key-syntax&quot;&gt;섹션 및 키 구문&lt;/a&gt; 규칙을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="99d0d4d29cdbac0a5b19b385cd1429987d3bb740" translate="yes" xml:space="preserve">
          <source>Note that the Windows registry and INI files use case-insensitive keys, whereas the CFPreferences API on macOS and iOS uses case-sensitive keys. To avoid portability problems, see the &lt;a href=&quot;qsettings#section-and-key-syntax&quot;&gt;Section and Key Syntax&lt;/a&gt; rules.</source>
          <target state="translated">Windows 레지스트리 및 INI 파일은 대소 문자를 구분하지 않는 키를 사용하는 반면 macOS 및 iOS의 CFPreferences API는 대소 문자를 구분하는 키를 사용합니다. 이식성 문제를 방지하려면 &lt;a href=&quot;qsettings#section-and-key-syntax&quot;&gt;섹션 및 키 구문&lt;/a&gt; 규칙을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e54f3c9936e8755c3f611c9e401ab37239057acc" translate="yes" xml:space="preserve">
          <source>Note that the X11 version of Qt may not be able to deliver all combinations of style flags on all systems. This is because on X11, Qt can only ask the window manager, and the window manager can override the application's settings. On Windows, Qt can set whatever flags you want.</source>
          <target state="translated">Qt의 X11 버전은 모든 시스템에서 모든 스타일 플래그 조합을 제공하지 못할 수도 있습니다. X11에서 Qt는 창 관리자에게만 요청할 수 있고 창 관리자는 응용 프로그램의 설정을 무시할 수 있기 때문입니다. Windows에서 Qt는 원하는 플래그를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e0211eb64e32981a758c391a651471c0d36c0ead" translate="yes" xml:space="preserve">
          <source>Note that the abbreviation is not guaranteed to be unique to this time zone and should not be used in place of the ID or display name.</source>
          <target state="translated">약어가이 시간대에 고유 한 것은 아니며 ID 또는 표시 이름 대신 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="852e9cb9c82908ab574059bb5e79e98f6b9c67f6" translate="yes" xml:space="preserve">
          <source>Note that the above table assumes that the &lt;a href=&quot;qabstractitemview#selectionMode-prop&quot;&gt;selection mode&lt;/a&gt; allows the operations. For instance, you cannot select items if the selection mode is &lt;a href=&quot;qabstractitemview#SelectionMode-enum&quot;&gt;QAbstractItemView::NoSelection&lt;/a&gt;.</source>
          <target state="translated">위의 표는 &lt;a href=&quot;qabstractitemview#selectionMode-prop&quot;&gt;선택 모드&lt;/a&gt; 가 조작을 허용 한다고 가정합니다 . 예를 들어, 선택 모드가 &lt;a href=&quot;qabstractitemview#SelectionMode-enum&quot;&gt;QAbstractItemView :: NoSelection 인&lt;/a&gt; 경우 항목을 선택할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="0148c6bd22a3475f62649c7930a47a03263b034e" translate="yes" xml:space="preserve">
          <source>Note that the accuracy depends on the accuracy of the underlying operating system; not all systems provide 1-millisecond accuracy.</source>
          <target state="translated">정확도는 기본 운영 체제의 정확도에 따라 다릅니다. 모든 시스템이 1 밀리 초의 정확도를 제공하는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="ed4d8f71dbffc6db27ffa4bfd59e7fafeaf25102" translate="yes" xml:space="preserve">
          <source>Note that the advance can be negative if the text flows from the right to the left.</source>
          <target state="translated">텍스트가 오른쪽에서 왼쪽으로 흐르면 진행이 음수 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e908d2e98901bfed79aa1ea1f97660b5c5fb40fb" translate="yes" xml:space="preserve">
          <source>Note that the backslash character is, as mentioned, used by &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; to separate subkeys. As a result, you cannot read or write windows registry entries that contain slashes or backslashes; you should use a native windows API if you need to do so.</source>
          <target state="translated">백 슬래시 문자는 언급 한 바와 같이 &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; 에서 하위 키를 분리 하는 데 사용됩니다 . 결과적으로 슬래시 또는 백 슬래시가 포함 된 Windows 레지스트리 항목을 읽거나 쓸 수 없습니다. 필요한 경우 기본 Windows API를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="43447c84aea0fb1d61a32e786087ac323c51aac8" translate="yes" xml:space="preserve">
          <source>Note that the backslash character is, as mentioned, used by QSettings to separate subkeys. As a result, you cannot read or write windows registry entries that contain slashes or backslashes; you should use a native windows API if you need to do so.</source>
          <target state="translated">백 슬래시 문자는 언급했듯이 QSettings에서 하위 키를 구분하는 데 사용됩니다. 결과적으로 슬래시 또는 백 슬래시가 포함 된 Windows 레지스트리 항목을 읽거나 쓸 수 없습니다. 필요한 경우 기본 Windows API를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="eb5e333044381a26153f8928fe1e9daecba13996" translate="yes" xml:space="preserve">
          <source>Note that the bottom-right corner of the rectangle is located at (rectangle.x() + rectangle.width(), rectangle.y() + rectangle.height()).</source>
          <target state="translated">사각형의 오른쪽 아래 모서리는 (rectangle.x () + rectangle.width (), rectangle.y () + rectangle.height ())에 있습니다.</target>
        </trans-unit>
        <trans-unit id="325cbe9d68d58d4d909f61f9a75daf02f3cc0379" translate="yes" xml:space="preserve">
          <source>Note that the bounding rectangle may extend to the left of (0, 0) (e.g., for italicized fonts), and that the text output may cover</source>
          <target state="translated">경계 사각형은 (0, 0)의 왼쪽으로 확장 될 수 있으며 (예를 들어, 기울임 꼴 글꼴의 경우) 텍스트 출력이 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="707914edba182845a169e1627d1004d86729d49d" translate="yes" xml:space="preserve">
          <source>Note that the bounding rectangle may extend to the left of (0, 0), e.g. for italicized fonts, and that the text output may cover</source>
          <target state="translated">경계 사각형은 예를 들어 기울임 꼴 글꼴의 경우 (0, 0) 왼쪽으로 확장 될 수 있으며 텍스트 출력은</target>
        </trans-unit>
        <trans-unit id="2ada6d3e95141beae1d62f703b4e9776c104a285" translate="yes" xml:space="preserve">
          <source>Note that the bounding rectangle may extend to the left of (0, 0), e.g. for italicized fonts, and that the width of the returned rectangle might be different than what the &lt;a href=&quot;qfontmetrics#horizontalAdvance&quot;&gt;horizontalAdvance&lt;/a&gt;() method returns.</source>
          <target state="translated">경계 사각형은 예를 들어 기울임 꼴 글꼴의 경우 (0, 0)의 왼쪽으로 확장 될 수 있으며 반환 된 사각형의 너비는 &lt;a href=&quot;qfontmetrics#horizontalAdvance&quot;&gt;horizontalAdvance&lt;/a&gt; () 메서드가 반환 하는 것과 다를 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="814658f774f26be7e6741ba064acb083d2957642" translate="yes" xml:space="preserve">
          <source>Note that the bounding rectangle may extend to the left of (0, 0), e.g. for italicized fonts, and that the width of the returned rectangle might be different than what the &lt;a href=&quot;qfontmetricsf#horizontalAdvance&quot;&gt;horizontalAdvance&lt;/a&gt;() method returns.</source>
          <target state="translated">경계 사각형은 예를 들어 기울임 꼴 글꼴의 경우 (0, 0)의 왼쪽으로 확장 될 수 있으며 반환 된 사각형의 너비는 &lt;a href=&quot;qfontmetricsf#horizontalAdvance&quot;&gt;horizontalAdvance&lt;/a&gt; () 메서드가 반환 하는 것과 다를 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c771236b7ee696537501c5ca211c26c45a22f21b" translate="yes" xml:space="preserve">
          <source>Note that the bounding rectangle may extend to the left of (0, 0), e.g. for italicized fonts, and that the width of the returned rectangle might be different than what the width() method returns.</source>
          <target state="translated">경계 사각형은 예를 들어 기울임 꼴 글꼴의 경우 (0, 0) 왼쪽으로 확장 될 수 있으며 반환 된 사각형의 너비는 width () 메서드가 반환하는 너비와 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f0f399e60141cfdf7b8e99fce423542727fe9be" translate="yes" xml:space="preserve">
          <source>Note that the bounding rectangle may extend to the left of (0, 0), e.g. for italicized fonts.</source>
          <target state="translated">경계 사각형은 예를 들어 기울임 꼴 글꼴의 경우 (0, 0) 왼쪽으로 확장 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="28b0bbfe6b5f2cc2a394de11dc969d0d3b51ac63" translate="yes" xml:space="preserve">
          <source>Note that the browser will automatically handle navigation to the location specified by</source>
          <target state="translated">브라우저는 자동으로 지정된 위치로 탐색을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="3289388ea3a9a49dc7a89778d94522f9dd785d10" translate="yes" xml:space="preserve">
          <source>Note that the cached</source>
          <target state="translated">캐시 된</target>
        </trans-unit>
        <trans-unit id="314342d4daec76f3494228d982af274c12086a69" translate="yes" xml:space="preserve">
          <source>Note that the call is made after the value of the slider has changed because clients may query the new value immediately after receiving the event.</source>
          <target state="translated">클라이언트는 이벤트를받은 직후 새 값을 쿼리 할 수 ​​있으므로 슬라이더 값이 변경된 후에 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="48ffbe89128006e15be16697870df5f0efcdbd37" translate="yes" xml:space="preserve">
          <source>Note that the case folding rules in &lt;a href=&quot;http://www.rfc-editor.org/rfc/rfc3491.txt&quot;&gt;Nameprep&lt;/a&gt;, which &lt;a href=&quot;qurl&quot;&gt;QUrl&lt;/a&gt; conforms to, require host names to always be converted to lower case, regardless of the Qt::FormattingOptions used.</source>
          <target state="translated">의 규칙 접는 경우주의 &lt;a href=&quot;http://www.rfc-editor.org/rfc/rfc3491.txt&quot;&gt;Nameprep&lt;/a&gt; , &lt;a href=&quot;qurl&quot;&gt;QUrl의&lt;/a&gt; 에 부합는 호스트 이름을 필요가에 관계없이 항상 사용되는 Qt는 :: FormattingOptions의, 소문자로 변환 할.</target>
        </trans-unit>
        <trans-unit id="7682973b3120d58851f9effe32d9a34d1083aeda" translate="yes" xml:space="preserve">
          <source>Note that the cell's row or column span cannot be changed through this function. You have to use &lt;a href=&quot;qtexttable#mergeCells&quot;&gt;QTextTable::mergeCells&lt;/a&gt; and &lt;a href=&quot;qtexttable#splitCell&quot;&gt;QTextTable::splitCell&lt;/a&gt; instead.</source>
          <target state="translated">이 함수를 통해 셀의 행 또는 열 범위를 변경할 수 없습니다. 당신은 사용할 필요가 &lt;a href=&quot;qtexttable#mergeCells&quot;&gt;QTextTable :: mergeCells&lt;/a&gt; 및 &lt;a href=&quot;qtexttable#splitCell&quot;&gt;QTextTable :: splitCell을&lt;/a&gt; 대신.</target>
        </trans-unit>
        <trans-unit id="85d8ab4ac3b37b4c7d021c759097d7469ebaf9c1" translate="yes" xml:space="preserve">
          <source>Note that the class this macro appears on must be default-constructible.</source>
          <target state="translated">이 매크로가 나타나는 클래스는 기본 구성 가능해야합니다.</target>
        </trans-unit>
        <trans-unit id="5064a7dc6e6ea23f708a51a763c18f03d0162e11" translate="yes" xml:space="preserve">
          <source>Note that the client must create a &lt;a href=&quot;qml-qtlocation-plugin&quot;&gt;Plugin&lt;/a&gt; object prior to using a &lt;a href=&quot;qml-qtlocation-geocodemodel&quot;&gt;GeocodeModel&lt;/a&gt; object. This will enable access to geocoding translation services and thus data to display.</source>
          <target state="translated">클라이언트는 &lt;a href=&quot;qml-qtlocation-geocodemodel&quot;&gt;GeocodeModel&lt;/a&gt; 객체 를 사용하기 전에 &lt;a href=&quot;qml-qtlocation-plugin&quot;&gt;플러그인&lt;/a&gt; 객체를 생성해야 합니다. 이를 통해 지오 코딩 번역 서비스에 액세스하여 데이터를 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e8b66c740d15bee812b8551bdcfcab156e5d9aaa" translate="yes" xml:space="preserve">
          <source>Note that the client must create a &lt;a href=&quot;qml-qtlocation-plugin&quot;&gt;Plugin&lt;/a&gt; object prior to using a &lt;a href=&quot;qml-qtlocation-map&quot;&gt;Map&lt;/a&gt; type in order to have access to map data to display.</source>
          <target state="translated">참고 클라이언트가 만들어야합니다 &lt;a href=&quot;qml-qtlocation-plugin&quot;&gt;플러그인&lt;/a&gt; 사용하기 전에 객체 &lt;a href=&quot;qml-qtlocation-map&quot;&gt;지도&lt;/a&gt; 표시에 데이터를 매핑 할 수있는 권한을 부여하기 위해 유형입니다.</target>
        </trans-unit>
        <trans-unit id="ae67cc6a3ab43e5a3869b3f1214618218d4e360c" translate="yes" xml:space="preserve">
          <source>Note that the clip path is specified in logical (painter) coordinates.</source>
          <target state="translated">클립 경로는 논리적 (페인터) 좌표로 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="a38abca040e3cdb6d47138e2b2c3fbb1c0a03b6e" translate="yes" xml:space="preserve">
          <source>Note that the clip rectangle is specified in logical (painter) coordinates.</source>
          <target state="translated">클립 사각형은 논리적 (페인터) 좌표로 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="2d7701a9538ff16a9044f38e4bf6dafef71df804" translate="yes" xml:space="preserve">
          <source>Note that the clip region is given in logical coordinates.</source>
          <target state="translated">클립 영역은 논리 좌표로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="5eea3e8da34c985476b9afdef3fd4e653250f4b1" translate="yes" xml:space="preserve">
          <source>Note that the columns and rows are not equally wide or tall. If you want two columns to have the same width, you must set their minimum widths and stretch factors to be the same yourself. You do this using &lt;a href=&quot;qgridlayout#setColumnMinimumWidth&quot;&gt;setColumnMinimumWidth&lt;/a&gt;() and &lt;a href=&quot;qgridlayout#setColumnStretch&quot;&gt;setColumnStretch&lt;/a&gt;().</source>
          <target state="translated">열과 행의 너비가 같거나 크지 않습니다. 두 열의 너비를 동일하게하려면 최소 너비와 신축 계수를 동일하게 설정해야합니다. &lt;a href=&quot;qgridlayout#setColumnMinimumWidth&quot;&gt;setColumnMinimumWidth&lt;/a&gt; () 및 &lt;a href=&quot;qgridlayout#setColumnStretch&quot;&gt;setColumnStretch&lt;/a&gt; ()를 사용하여이를 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="d39d60e3609de62033a530aed40347b59d63e292" translate="yes" xml:space="preserve">
          <source>Note that the components in the returned margins will be rounded to the nearest integer.</source>
          <target state="translated">반환 된 여백의 구성 요소는 가장 가까운 정수로 반올림됩니다.</target>
        </trans-unit>
        <trans-unit id="0f823aeaa046ecce3ad267e5999091669af618af" translate="yes" xml:space="preserve">
          <source>Note that the coordinates in the returned size will be rounded to the nearest integer.</source>
          <target state="translated">반환 된 크기의 좌표는 가장 가까운 정수로 반올림됩니다.</target>
        </trans-unit>
        <trans-unit id="48374ac232976bb7985981e60071906b684b660d" translate="yes" xml:space="preserve">
          <source>Note that the core profile might still contain functionality that is deprecated and scheduled for removal in a higher version. To get access to the deprecated functionality for the core profile in the set &lt;a href=&quot;qsurfaceformat#RenderableType-enum&quot;&gt;OpenGL&lt;/a&gt; version you can use the &lt;a href=&quot;qsurfaceformat&quot;&gt;QSurfaceFormat&lt;/a&gt; format option &lt;a href=&quot;qsurfaceformat#FormatOption-enum&quot;&gt;QSurfaceFormat::DeprecatedFunctions&lt;/a&gt;.</source>
          <target state="translated">코어 프로파일에는 더 이상 사용되지 않으며 상위 버전에서 제거 될 예정인 기능이 여전히 포함되어있을 수 있습니다. 설정된 &lt;a href=&quot;qsurfaceformat#RenderableType-enum&quot;&gt;OpenGL&lt;/a&gt; 버전 에서 코어 프로파일에 대해 더 이상 사용되지 않는 기능에 액세스하려면 &lt;a href=&quot;qsurfaceformat&quot;&gt;QSurfaceFormat&lt;/a&gt; 형식 옵션 &lt;a href=&quot;qsurfaceformat#FormatOption-enum&quot;&gt;QSurfaceFormat :: DeprecatedFunctions를&lt;/a&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a515b22d94b242dc8217ff13ed910ef9891b3e34" translate="yes" xml:space="preserve">
          <source>Note that the core profile might still contain functionality that is deprecated and scheduled for removal in a higher version. To get access to the deprecated functionality for the core profile in the set OpenGL version you can use the &lt;a href=&quot;qsurfaceformat&quot;&gt;QSurfaceFormat&lt;/a&gt; format option &lt;a href=&quot;qsurfaceformat#FormatOption-enum&quot;&gt;QSurfaceFormat::DeprecatedFunctions&lt;/a&gt;.</source>
          <target state="translated">코어 프로필에는 더 이상 사용되지 않고 더 높은 버전에서 제거 될 예정인 기능이 계속 포함될 수 있습니다. 설정된 OpenGL 버전의 코어 프로필에 대해 사용되지 않는 기능에 액세스하려면 &lt;a href=&quot;qsurfaceformat&quot;&gt;QSurfaceFormat&lt;/a&gt; 형식 옵션 &lt;a href=&quot;qsurfaceformat#FormatOption-enum&quot;&gt;QSurfaceFormat :: DeprecatedFunctions를&lt;/a&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0ae6c1d12d36517de4bb5e0f90708fcb35acb56d" translate="yes" xml:space="preserve">
          <source>Note that the counter wraps to zero 24 hours after the last call to &lt;a href=&quot;qtime#start&quot;&gt;start&lt;/a&gt;() or restart().</source>
          <target state="translated">마지막으로 &lt;a href=&quot;qtime#start&quot;&gt;start&lt;/a&gt; () 또는 restart ()를 호출 한 후 24 시간 후에 카운터가 0으로 줄어 듭니다 .</target>
        </trans-unit>
        <trans-unit id="b6b9d30b05b6d8cf3a8cf9a764cec79541ff9fe5" translate="yes" xml:space="preserve">
          <source>Note that the counter wraps to zero 24 hours after the last call to &lt;a href=&quot;qtime#start&quot;&gt;start&lt;/a&gt;() or restart.</source>
          <target state="translated">마지막 호출 &lt;a href=&quot;qtime#start&quot;&gt;시작&lt;/a&gt; () 또는 다시 시작 후 24 시간 후에 카운터가 0으로 줄어 듭니다 .</target>
        </trans-unit>
        <trans-unit id="bd9402145b1ef822d74b672bfcffb11c0dd774f6" translate="yes" xml:space="preserve">
          <source>Note that the current position after the polygon has been added, is the last point in</source>
          <target state="translated">다각형이 추가 된 후의 현재 위치는</target>
        </trans-unit>
        <trans-unit id="0b794bfe794be254cb14d7e88deadf9756fbbf08" translate="yes" xml:space="preserve">
          <source>Note that the cursor does not have to be moved after each search and replace operation; it is always positioned at the end of the word that was just replaced.</source>
          <target state="translated">각 검색 및 바꾸기 작업 후에 커서를 이동할 필요는 없습니다. 항상 바뀐 단어의 끝에 위치합니다.</target>
        </trans-unit>
        <trans-unit id="2ef3a75ce01f98f39d85fc33db9a342f073aae65" translate="yes" xml:space="preserve">
          <source>Note that the cursor was moved from the start of the first line to the end, but that it retained an anchor at the start of the line. This demonstrates the cursor-based selection facilities of the &lt;a href=&quot;qtextcursor&quot;&gt;QTextCursor&lt;/a&gt; class.</source>
          <target state="translated">커서는 첫 번째 줄의 시작에서 끝으로 이동했지만 줄의 시작 부분에 앵커가 유지되었습니다. &lt;a href=&quot;qtextcursor&quot;&gt;QTextCursor&lt;/a&gt; 클래스 의 커서 기반 선택 기능을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="f4344b0917fe95c30466ba8c90df7e41e15135ec" translate="yes" xml:space="preserve">
          <source>Note that the custom deleter function will be called with a pointer to type &lt;code&gt;X&lt;/code&gt;, even if the &lt;a href=&quot;qsharedpointer&quot;&gt;QSharedPointer&lt;/a&gt; template parameter &lt;code&gt;T&lt;/code&gt; is not the same.</source>
          <target state="translated">&lt;a href=&quot;qsharedpointer&quot;&gt;QSharedPointer&lt;/a&gt; 템플릿 매개 변수 &lt;code&gt;T&lt;/code&gt; 가 동일하지 않더라도 사용자 지정 삭제 기능은 &lt;code&gt;X&lt;/code&gt; 유형에 대한 포인터와 함께 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="34923531a616f93dbb31379abdac4aa16ce67147" translate="yes" xml:space="preserve">
          <source>Note that the custom deleter function will be called with a pointer to type &lt;code&gt;X&lt;/code&gt;, even if the QSharedPointer template parameter &lt;code&gt;T&lt;/code&gt; is not the same.</source>
          <target state="translated">사용자 지정 deleter 함수는 QSharedPointer 템플릿 매개 변수 &lt;code&gt;T&lt;/code&gt; 가 동일하지 않더라도 &lt;code&gt;X&lt;/code&gt; 형식에 대한 포인터와 함께 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="4a65219443f2b873003a4874c7d28cb57269c34c" translate="yes" xml:space="preserve">
          <source>Note that the dash pattern is specified in units of the pens width, e.g. a dash of length 5 in width 10 is 50 pixels long.</source>
          <target state="translated">대시 패턴은 펜 너비 단위로 지정됩니다. 예를 들어 너비 10의 길이 5의 대시 길이는 50 픽셀입니다.</target>
        </trans-unit>
        <trans-unit id="a4fd2b4329f63dd121a447af866e189849bc1933" translate="yes" xml:space="preserve">
          <source>Note that the default cap style is &lt;a href=&quot;qt#PenCapStyle-enum&quot;&gt;Qt::SquareCap&lt;/a&gt;, meaning that a square line end covers the end point and extends beyond it by half the line width.</source>
          <target state="translated">기본 캡 스타일은 &lt;a href=&quot;qt#PenCapStyle-enum&quot;&gt;Qt :: SquareCap&lt;/a&gt; 이며, 사각형 선 끝이 끝점을 덮고 선 너비의 절반으로 연장됩니다.</target>
        </trans-unit>
        <trans-unit id="62d524079313cf9229dd28b3f002e23af3010954" translate="yes" xml:space="preserve">
          <source>Note that the default formatVersion is -1 which signifies the current release, i.e. for Qt 4.0 a formatVersion of 7 is the same as the default formatVersion of -1.</source>
          <target state="translated">기본 formatVersion은 -1이며 현재 릴리스를 나타냅니다. 즉 Qt 4.0의 경우 formatVersion 7은 기본 formatVersion -1과 같습니다.</target>
        </trans-unit>
        <trans-unit id="82fed073baa252e940c1136a19a877053569592f" translate="yes" xml:space="preserve">
          <source>Note that the default implementation does nothing. Reasonable actions in this function might be to call the QWidget::setBackgroundMode() function for the widget. Do not use the function to set, for example, the geometry. Reimplementing this function provides a back-door through which the appearance of a widget can be changed, but with Qt's style engine it is rarely necessary to implement this function; reimplement &lt;a href=&quot;qstyle#drawItemPixmap&quot;&gt;drawItemPixmap&lt;/a&gt;(), &lt;a href=&quot;qstyle#drawItemText&quot;&gt;drawItemText&lt;/a&gt;(), &lt;a href=&quot;qstyle#drawPrimitive&quot;&gt;drawPrimitive&lt;/a&gt;(), etc. instead.</source>
          <target state="translated">기본 구현은 아무 것도 수행하지 않습니다. 이 함수에서 합리적인 조치는 위젯에 대한 QWidget :: setBackgroundMode () 함수를 호출하는 것입니다. 예를 들어 형상을 설정하기 위해이 기능을 사용하지 마십시오. 이 함수를 다시 구현하면 위젯의 모양을 변경할 수있는 백도어가 제공되지만 Qt의 스타일 엔진에서는이 기능을 구현할 필요가 거의 없습니다. &lt;a href=&quot;qstyle#drawItemPixmap&quot;&gt;대신 drawItemPixmap&lt;/a&gt; (), &lt;a href=&quot;qstyle#drawItemText&quot;&gt;drawItemText&lt;/a&gt; (), &lt;a href=&quot;qstyle#drawPrimitive&quot;&gt;drawPrimitive&lt;/a&gt; () 등을 다시 구현 하십시오 .</target>
        </trans-unit>
        <trans-unit id="f7de95b609328e3a8b48fdd1fb4fe5574e9e524c" translate="yes" xml:space="preserve">
          <source>Note that the definition of contentItem is somewhat different to that of a Flickable, where the contentItem is implicitly created.</source>
          <target state="translated">contentItem의 정의는 contentItem이 암시 적으로 생성되는 Flickable의 정의와 다소 다릅니다.</target>
        </trans-unit>
        <trans-unit id="c86a3a07e679a7f62ae8a994fbc370417d3425bd" translate="yes" xml:space="preserve">
          <source>Note that the desired attachments or number of samples per pixels might not be supported by the hardware driver. Call &lt;a href=&quot;qopenglframebufferobject#format&quot;&gt;QOpenGLFramebufferObject::format&lt;/a&gt;() after creating a &lt;a href=&quot;qopenglframebufferobject&quot;&gt;QOpenGLFramebufferObject&lt;/a&gt; to find the exact format that was used to create the frame buffer object.</source>
          <target state="translated">하드웨어 드라이버가 원하는 첨부 파일 또는 픽셀 당 샘플 수를 지원하지 않을 수 있습니다. 전화 &lt;a href=&quot;qopenglframebufferobject#format&quot;&gt;QOpenGLFramebufferObject :: 형식&lt;/a&gt; ()을 만든 후 &lt;a href=&quot;qopenglframebufferobject&quot;&gt;QOpenGLFramebufferObject를&lt;/a&gt; 프레임 버퍼 오브젝트를 만드는 데 사용 된 정확한 형식을 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="67e3f5412a1c3d6dd9308d1bd5ffe67faebceb62" translate="yes" xml:space="preserve">
          <source>Note that the directory separator &quot;/&quot; works for all operating systems supported by Qt.</source>
          <target state="translated">디렉토리 구분 기호 &quot;/&quot;는 Qt가 지원하는 모든 운영 체제에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="f34e042dfddf3714609c625f77139543f539c80f" translate="yes" xml:space="preserve">
          <source>Note that the distinction only matters for decorated top-level widgets. For all child widgets, the frame geometry is equal to the widget's client geometry.</source>
          <target state="translated">이 구별은 장식 된 최상위 위젯에만 중요합니다. 모든 하위 위젯에서 프레임 지오메트리는 위젯의 클라이언트 지오메트리와 같습니다.</target>
        </trans-unit>
        <trans-unit id="819be5c77c822d0cbad93516cd9733af4b97e471" translate="yes" xml:space="preserve">
          <source>Note that the documentation must be in the implementation files such as &lt;code&gt;.cpp&lt;/code&gt;.</source>
          <target state="translated">설명서는 &lt;code&gt;.cpp&lt;/code&gt; 와 같은 구현 파일에 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="0b1782616a78d8ac7424ef4e086a7462fee0635e" translate="yes" xml:space="preserve">
          <source>Note that the domain here may start with a dot, which is not a valid hostname. However, it means this cookie matches all hostnames ending with that domain name.</source>
          <target state="translated">여기서 도메인은 유효한 호스트 이름이 아닌 점으로 시작할 수 있습니다. 그러나이 쿠키는 해당 도메인 이름으로 끝나는 모든 호스트 이름과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="b168e0d47e1f437fb7d5d20f2b63bc27a92b75ac" translate="yes" xml:space="preserve">
          <source>Note that the effect of this property is noticeable when only a part of the scene is visible (i.e., when there are scroll bars). Otherwise, if the whole scene fits in the view, &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; uses the view &lt;a href=&quot;stylesheet-reference#alignment&quot;&gt;alignment&lt;/a&gt; to position the scene in the view.</source>
          <target state="translated">이 속성의 효과는 장면의 일부만 표시 될 때 (즉, 스크롤 막대가있는 경우) 눈에 that니다. 그렇지 않으면 전체 장면이 뷰에 맞는 경우 &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; 은 뷰 &lt;a href=&quot;stylesheet-reference#alignment&quot;&gt;정렬&lt;/a&gt; 을 사용하여 뷰 에 장면을 배치합니다.</target>
        </trans-unit>
        <trans-unit id="67becbf68ca11b5bc8a50699805e2bd85c152252" translate="yes" xml:space="preserve">
          <source>Note that the eventTest method of the</source>
          <target state="translated">의 eventTest 메소드는</target>
        </trans-unit>
        <trans-unit id="e595a3869e4468665555af631a672501ea886e7e" translate="yes" xml:space="preserve">
          <source>Note that the example above is somewhat simplified and will not animate an indeterminate progress bar. The following snippet demonstrates how you can incorporate a custom animation for the indeterminate state as well.</source>
          <target state="translated">위의 예제는 다소 단순화되었으며 결정되지 않은 진행률 표시 줄에 애니메이션을 적용하지 않습니다. 다음 스 니펫은 불확정 상태에 대한 사용자 정의 애니메이션을 통합하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="39ab2934220126d057120154985a67129943c436" translate="yes" xml:space="preserve">
          <source>Note that the exec() function does not block the main event loop.</source>
          <target state="translated">exec () 함수는 기본 이벤트 루프를 차단하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b16783b3a0bb8381ae231b893bc7b8061a5e5a43" translate="yes" xml:space="preserve">
          <source>Note that the file descriptor returned by this function is owned by the &lt;a href=&quot;qdbusunixfiledescriptor&quot;&gt;QDBusUnixFileDescriptor&lt;/a&gt; object and must not be stored past the lifetime of this object. It is ok to use it while this object is valid, but if one wants to store it for longer use, the file descriptor should be cloned using the Unix &lt;code&gt;dup(2)&lt;/code&gt;, &lt;code&gt;dup2(2)&lt;/code&gt; or &lt;code&gt;dup3(2)&lt;/code&gt; functions.</source>
          <target state="translated">이 함수가 리턴 한 파일 디스크립터는 &lt;a href=&quot;qdbusunixfiledescriptor&quot;&gt;QDBusUnixFileDescriptor&lt;/a&gt; 오브젝트 가 소유 하며이 오브젝트의 수명이 지난 후에 저장해서는 안됩니다. 이 객체가 유효한 동안 사용하는 것이 좋지만, 더 오래 사용하기 위해 저장하려면 파일 기술자는 Unix &lt;code&gt;dup(2)&lt;/code&gt; , &lt;code&gt;dup2(2)&lt;/code&gt; 또는 &lt;code&gt;dup3(2)&lt;/code&gt; 함수를 사용하여 복제해야합니다 .</target>
        </trans-unit>
        <trans-unit id="256a897c0b69dfc07308e13a93c590816fa4113b" translate="yes" xml:space="preserve">
          <source>Note that the file name describes the font, for example &lt;code&gt;helvetica_120_50.qpf&lt;/code&gt; is 12 point Helvetica while &lt;code&gt;helvetica_120_50i.qpf&lt;/code&gt; is 12 point Helvetica</source>
          <target state="translated">파일 이름은 글꼴을 나타냅니다. 예를 들어 &lt;code&gt;helvetica_120_50.qpf&lt;/code&gt; 는 12 포인트 Helvetica이고 &lt;code&gt;helvetica_120_50i.qpf&lt;/code&gt; 는 12 포인트 Helvetica입니다.</target>
        </trans-unit>
        <trans-unit id="81113b71aa29f8d0d48997ab8ee0623f76feda81" translate="yes" xml:space="preserve">
          <source>Note that the filter &lt;b&gt;*.*&lt;/b&gt; is not portable, because the historical assumption that the file extension determines the file type is not consistent on every operating system. It is possible to have a file with no dot in its name (for example, &lt;code&gt;Makefile&lt;/code&gt;). In a native Windows file dialog, &lt;b&gt;*.*&lt;/b&gt; will match such files, while in other types of file dialogs it may not. So it is better to use &lt;b&gt;*&lt;/b&gt; if you mean to select any file.</source>
          <target state="translated">파일 확장자가 파일 유형을 결정한다는 이전 가정은 모든 운영 체제에서 일치하지 않기 때문에 &lt;b&gt;*. *&lt;/b&gt; 필터 는 이식성이 없습니다. 이름에 점이없는 파일을 가질 수 있습니다 (예 : &lt;code&gt;Makefile&lt;/code&gt; ). 기본 Windows 파일 대화 상자에서 &lt;b&gt;*. *&lt;/b&gt; 는 이러한 파일과 일치하지만 다른 유형의 파일 대화 상자에서는 그렇지 않을 수 있습니다. 따라서 파일을 선택하려는 경우 &lt;b&gt;*&lt;/b&gt; 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="88b31df53d2843275a4bc52ea67c308d28da48ca" translate="yes" xml:space="preserve">
          <source>Note that the filter you set should always include the &lt;a href=&quot;qdir#Filter-enum&quot;&gt;QDir::AllDirs&lt;/a&gt; enum value, otherwise &lt;a href=&quot;qdirmodel&quot;&gt;QDirModel&lt;/a&gt; won't be able to read the directory structure.</source>
          <target state="translated">설정 한 필터는 항상 &lt;a href=&quot;qdir#Filter-enum&quot;&gt;QDir :: AllDirs&lt;/a&gt; 열거 형 값을 포함해야 합니다. 그렇지 않으면 &lt;a href=&quot;qdirmodel&quot;&gt;QDirModel&lt;/a&gt; 은 디렉토리 구조를 읽을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a35492801d6ab66071be6d1fea554315a969fce9" translate="yes" xml:space="preserve">
          <source>Note that the filter you set should always include the &lt;a href=&quot;qdir#Filter-enum&quot;&gt;QDir::AllDirs&lt;/a&gt; enum value, otherwise &lt;a href=&quot;qfilesystemmodel&quot;&gt;QFileSystemModel&lt;/a&gt; won't be able to read the directory structure.</source>
          <target state="translated">설정 한 필터는 항상 &lt;a href=&quot;qdir#Filter-enum&quot;&gt;QDir :: AllDirs&lt;/a&gt; 열거 형 값을 포함해야 합니다. 그렇지 않으면 &lt;a href=&quot;qfilesystemmodel&quot;&gt;QFileSystemModel&lt;/a&gt; 이 디렉토리 구조를 읽을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="68319831252ba922216f1bb4d48728c857090e12" translate="yes" xml:space="preserve">
          <source>Note that the filtering object must be in the same thread as this object. If</source>
          <target state="translated">필터링 개체는이 개체와 동일한 스레드에 있어야합니다. 만약</target>
        </trans-unit>
        <trans-unit id="6302bec68787b67d2a1cbc343c582c7c263c8585" translate="yes" xml:space="preserve">
          <source>Note that the first position in the sequence is position 1, not 0. We can also select</source>
          <target state="translated">시퀀스의 첫 번째 위치는 0이 아니라 위치 1입니다.</target>
        </trans-unit>
        <trans-unit id="cd581dfb7d8fbe77f96131d6ac68373f3ee6603f" translate="yes" xml:space="preserve">
          <source>Note that the font filtering options might not be supported on some platforms (e.g. Mac). They are always supported by the non native dialog (used on Windows or Linux).</source>
          <target state="translated">일부 플랫폼 (예 : Mac)에서는 글꼴 필터링 옵션이 지원되지 않을 수 있습니다. 비 기본 대화 상자 (Windows 또는 Linux에서 사용)에서 항상 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="1a38e49065048ff8caee838f309af1816aa49a31" translate="yes" xml:space="preserve">
          <source>Note that the frame width depends on the &lt;a href=&quot;qframe#setFrameStyle&quot;&gt;frame style&lt;/a&gt;, not only the line width and the mid-line width. For example, the style specified by &lt;a href=&quot;qframe#Shape-enum&quot;&gt;NoFrame&lt;/a&gt; always has a frame width of 0, whereas the style &lt;a href=&quot;qframe#Shape-enum&quot;&gt;Panel&lt;/a&gt; has a frame width equivalent to the line width.</source>
          <target state="translated">프레임 너비 는 선 너비와 중간 선 너비뿐만 아니라 &lt;a href=&quot;qframe#setFrameStyle&quot;&gt;프레임 스타일&lt;/a&gt; 에 따라 달라집니다 . 예를 들어 &lt;a href=&quot;qframe#Shape-enum&quot;&gt;NoFrame으로&lt;/a&gt; 지정된 스타일 의 프레임 너비는 항상 0 인 반면 스타일 &lt;a href=&quot;qframe#Shape-enum&quot;&gt;패널&lt;/a&gt; 의 프레임 너비는 선 너비와 같습니다.</target>
        </trans-unit>
        <trans-unit id="d148334bb561943c8c6d9555e3ae152be884e1cc" translate="yes" xml:space="preserve">
          <source>Note that the front end must call &lt;a href=&quot;qsensor#active-prop&quot;&gt;QSensor::isActive&lt;/a&gt;() to see if the sensor has stopped. If the sensor has stopped due to an error the &lt;a href=&quot;qsensorbackend#sensorError&quot;&gt;sensorError&lt;/a&gt;() function should be called to notify the class of the error condition.</source>
          <target state="translated">센서가 중지되었는지 확인 하려면 프론트 엔드가 &lt;a href=&quot;qsensor#active-prop&quot;&gt;QSensor :: isActive&lt;/a&gt; ()를 호출해야합니다 . 오류로 인해 센서가 중지 된 경우 오류 조건을 클래스에 알리기 위해 &lt;a href=&quot;qsensorbackend#sensorError&quot;&gt;sensorError&lt;/a&gt; () 함수를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="ae7cee952c4e8e079004277c3b7087eb941bff65" translate="yes" xml:space="preserve">
          <source>Note that the front end must call &lt;a href=&quot;qsensor#busy-prop&quot;&gt;QSensor::isBusy&lt;/a&gt;() to see if the sensor is busy. If the sensor has stopped due to an error the &lt;a href=&quot;qsensorbackend#sensorError&quot;&gt;sensorError&lt;/a&gt;() function should be called to notify the class of the error condition.</source>
          <target state="translated">센서가 사용 중인지 확인 하려면 프론트 엔드가 &lt;a href=&quot;qsensor#busy-prop&quot;&gt;QSensor :: isBusy&lt;/a&gt; ()를 호출해야합니다 . 오류로 인해 센서가 중지 된 경우 오류 조건을 클래스에 알리기 위해 &lt;a href=&quot;qsensorbackend#sensorError&quot;&gt;sensorError&lt;/a&gt; () 함수를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="37ce3668e57b8a855281855a6f74dbb881ed7832" translate="yes" xml:space="preserve">
          <source>Note that the generated flags in</source>
          <target state="translated">생성 된 플래그는</target>
        </trans-unit>
        <trans-unit id="c3c21bdbc746d5bf2a6883286a2e0059eb273650" translate="yes" xml:space="preserve">
          <source>Note that the given starting attributes can be modified at any point in the particle's lifetime by any Affector element in the same &lt;a href=&quot;qml-qtquick-particles-particlesystem&quot;&gt;ParticleSystem&lt;/a&gt;. This includes attributes like lifespan.</source>
          <target state="translated">주어진 시작 속성은 동일한 &lt;a href=&quot;qml-qtquick-particles-particlesystem&quot;&gt;ParticleSystem의&lt;/a&gt; Affector 요소에 의해 입자 수명의 어느 시점에서나 수정 될 수 있습니다 . 여기에는 수명과 같은 속성이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="e805563d665203996dcefd45f7dd2eb482048249" translate="yes" xml:space="preserve">
          <source>Note that the handler will always be called from within the same thread that calls &lt;a href=&quot;qdesktopservices#openUrl&quot;&gt;QDesktopServices::openUrl&lt;/a&gt;().</source>
          <target state="translated">핸들러는 항상 &lt;a href=&quot;qdesktopservices#openUrl&quot;&gt;QDesktopServices :: openUrl&lt;/a&gt; () 을 호출하는 동일한 스레드 내에서 호출 됩니다.</target>
        </trans-unit>
        <trans-unit id="333951bb8fc7fcf7a3291b86521cc9555bada48c" translate="yes" xml:space="preserve">
          <source>Note that the heights shown above may vary based on differences in fonts across platforms.</source>
          <target state="translated">위에 표시된 높이는 플랫폼 간 글꼴 차이에 따라 달라질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6cb2ab9936e43e6fc91819d84a228ba5e5fbc3b" translate="yes" xml:space="preserve">
          <source>Note that the highlight animation also affects the way that the view is scrolled. This is because the view moves to maintain the highlight within the preferred highlight range (or visible viewport).</source>
          <target state="translated">하이라이트 애니메이션은 또한 뷰가 스크롤되는 방식에 영향을줍니다. 뷰가 선호하는 하이라이트 범위 (또는 가시적 뷰포트) 내에서 하이라이트를 유지하기 위해 이동하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="beb3ea60d1fd624060bb2430f37f4fbcb284615b" translate="yes" xml:space="preserve">
          <source>Note that the identifier is filled out automatically when the sensor is connected to a backend. If you want to connect a specific backend, you should call setIdentifier() before &lt;a href=&quot;qsensor#connectToBackend&quot;&gt;connectToBackend&lt;/a&gt;().</source>
          <target state="translated">센서가 백엔드에 연결되면 식별자가 자동으로 채워집니다. 특정 백엔드를 연결하려면 &lt;a href=&quot;qsensor#connectToBackend&quot;&gt;connectToBackend&lt;/a&gt; () 전에 setIdentifier ()를 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="31960ba6052bcfd7f051eecf9cb199501baf00c4" translate="yes" xml:space="preserve">
          <source>Note that the identifiers are case-insensitive, but the rest of the URL will be passed on with preserved case. For example, the below snippet would still specify that the image is loaded by the image provider named &quot;myimageprovider&quot;, but it would request a different image than the above snippet (&quot;Image.png&quot; instead of &quot;image.png&quot;).</source>
          <target state="translated">식별자는 대소 문자를 구분하지 않지만 나머지 URL은 대소 문자를 구분하여 전달됩니다. 예를 들어 아래 스 니펫은 여전히 ​​&quot;myimageprovider&quot;라는 이미지 제공자가 이미지를로드하도록 지정하지만 위 스 니펫 ( &quot;image.png&quot;대신 &quot;Image.png&quot;)과 다른 이미지를 요청합니다.</target>
        </trans-unit>
        <trans-unit id="704bfb5be3b1cbb315853d9a796bb5ebd256033e" translate="yes" xml:space="preserve">
          <source>Note that the images are expected to be tightly packed in the atlas: the width and height of the cursors are decided based on the total image size and the &lt;code&gt;cursorsPerRow&lt;/code&gt; setting. Atlases have to provide an image for all the supported cursors.</source>
          <target state="translated">이미지는 아틀라스에 꽉 채워져 있어야합니다. 커서의 너비와 높이는 총 이미지 크기와 &lt;code&gt;cursorsPerRow&lt;/code&gt; 설정 에 따라 결정 됩니다. Atlases는 지원되는 모든 커서에 대한 이미지를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="fb18ede6c3719d606cbadba97494a9a1dbdce8ad" translate="yes" xml:space="preserve">
          <source>Note that the images are expected to be tightly packed in the atlas; the width and height of the cursors are determined based on the total image size and the &lt;code&gt;cursorsPerRow&lt;/code&gt; setting. Atlases must also provide an image for all of the supported cursors.</source>
          <target state="translated">이미지는 아틀라스에 꽉 차있을 것으로 예상됩니다. 커서의 너비와 높이는 전체 이미지 크기와 &lt;code&gt;cursorsPerRow&lt;/code&gt; 설정 에 따라 결정 됩니다. Atlases는 지원되는 모든 커서에 대한 이미지도 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="b2d65c3a23309150efa0d935b067e1fa65e74969" translate="yes" xml:space="preserve">
          <source>Note that the images are white and semi-transparent, to allow colorization and alpha levels to have maximum effect.</source>
          <target state="translated">이미지는 흰색과 반투명하므로 색상 및 알파 수준이 최대의 효과를 낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b4d5d131fa03e05ee92754ff1468a23aa4a0db7" translate="yes" xml:space="preserve">
          <source>Note that the implementation of the &lt;a href=&quot;qhash#qHashx&quot;&gt;qHash&lt;/a&gt;() overloads offered by Qt may change at any time. You &lt;b&gt;must not&lt;/b&gt; rely on the fact that &lt;a href=&quot;qhash#qHashx&quot;&gt;qHash&lt;/a&gt;() will give the same results (for the same inputs) across different Qt versions.</source>
          <target state="translated">Qt가 제공 하는 &lt;a href=&quot;qhash#qHashx&quot;&gt;qHash&lt;/a&gt; () 과부하 의 구현은 언제든지 변경 될 수 있습니다. 당신은 &lt;b&gt;하지 않아야&lt;/b&gt; 한다는 사실에 의존 &lt;a href=&quot;qhash#qHashx&quot;&gt;qHash은&lt;/a&gt; () 다른 Qt는 버전에서 (같은 입력에 대한) 같은 결과를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c2fdf690e4974b08866589cde3603bf4ac78252" translate="yes" xml:space="preserve">
          <source>Note that the interface index can also be set with &lt;a href=&quot;qhostaddress#setScopeId&quot;&gt;QHostAddress::setScopeId&lt;/a&gt;() for IPv6 destination addresses and then with &lt;a href=&quot;qnetworkdatagram#setDestination&quot;&gt;setDestination&lt;/a&gt;(). If the scope ID set in the destination address and</source>
          <target state="translated">IPv6 대상 주소에 대해 &lt;a href=&quot;qhostaddress#setScopeId&quot;&gt;QHostAddress :: setScopeId&lt;/a&gt; ()를 사용하여 설정 한 다음 &lt;a href=&quot;qnetworkdatagram#setDestination&quot;&gt;setDestination&lt;/a&gt; () 을 사용하여 인터페이스 색인을 설정할 수도 있습니다 . 대상 주소에 범위 ID가 설정된 경우</target>
        </trans-unit>
        <trans-unit id="0218a029c6c604f44424a2c7bafec268ea7ff025" translate="yes" xml:space="preserve">
          <source>Note that the internal array only ever gets bigger over the life of the list. It never shrinks. The internal array is deallocated by the destructor and by the assignment operator, when one list is assigned to another.</source>
          <target state="translated">내부 배열은 목록 수명 기간 동안 만 커집니다. 절대 축소되지 않습니다. 하나의 목록이 다른 목록에 할당되면 내부 배열은 소멸자와 할당 연산자에 의해 할당 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="d1cc7323f624d60f6bc31db7992d6b68e01b242f" translate="yes" xml:space="preserve">
          <source>Note that the item's general visibility is unrelated to whether or not it is actually being visualized by a &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt;.</source>
          <target state="translated">아이템의 일반적인 가시성은 &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView에&lt;/a&gt; 의해 실제로 시각화되는지 여부와 관련이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="f10b38b9083c60116aae4ce7012f384ef2a59176" translate="yes" xml:space="preserve">
          <source>Note that the item's geometry is provided in item coordinates, and its position is initialized to (0, 0).</source>
          <target state="translated">아이템의 지오메트리는 아이템 좌표로 제공되며 위치는 (0, 0)으로 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="85d96b1643c8b96254f3a503cb40bd30c892db9d" translate="yes" xml:space="preserve">
          <source>Note that the item's geometry is provided in item coordinates, and its position is initialized to (0, 0). For example, if a &lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt;(50, 50, 100, 100) is added, its top-left corner will be at (50, 50) relative to the origin in the item's coordinate system.</source>
          <target state="translated">아이템의 지오메트리는 아이템 좌표로 제공되며 위치는 (0, 0)으로 초기화됩니다. 예를 들어, &lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt; (50, 50, 100, 100)가 추가되면 왼쪽 상단 모서리는 항목 좌표계의 원점을 기준으로 (50, 50)이됩니다.</target>
        </trans-unit>
        <trans-unit id="9279308e7388b67030442c563fae37721bdabeb1" translate="yes" xml:space="preserve">
          <source>Note that the items in the list may not be adjacent elements in the document. For example, the top-level items in a multi-level list will be separated by the items in lower levels of the list.</source>
          <target state="translated">목록의 항목이 문서의 요소와 인접하지 않을 수 있습니다. 예를 들어, 다단계 목록의 최상위 항목은 목록의 하위 수준에있는 항목으로 구분됩니다.</target>
        </trans-unit>
        <trans-unit id="c3889a5c562fd1fbdfb4ce91c889791ea1c255cf" translate="yes" xml:space="preserve">
          <source>Note that the iterator selects both frames and blocks, so it is necessary to check which it is referring to. This allows us to navigate the document structure on a frame-by-frame basis yet still access text blocks if required. Both the &lt;a href=&quot;qtextblock-iterator&quot;&gt;QTextBlock::iterator&lt;/a&gt; and &lt;a href=&quot;qtextframe-iterator&quot;&gt;QTextFrame::iterator&lt;/a&gt; classes can be used in complementary ways to extract the required structure from a document.</source>
          <target state="translated">반복자는 프레임과 블록을 모두 선택하므로 참조하는 프레임을 확인해야합니다. 이를 통해 프레임 단위로 문서 구조를 탐색 할 수 있지만 필요한 경우 여전히 텍스트 블록에 액세스 할 수 있습니다. 모두 &lt;a href=&quot;qtextblock-iterator&quot;&gt;QTextBlock는 :: 반복자&lt;/a&gt; 와 &lt;a href=&quot;qtextframe-iterator&quot;&gt;QTextFrame :: 반복자&lt;/a&gt; 클래스는 문서에서 필요한 구조를 추출하는 보완적인 방법으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb8c94b6aca492d17181c22511b158235fd2c8a8" translate="yes" xml:space="preserve">
          <source>Note that the key bindings are platform dependent. The currently bound shortcuts can be queried using &lt;a href=&quot;qkeysequence#keyBindings&quot;&gt;keyBindings&lt;/a&gt;().</source>
          <target state="translated">키 바인딩은 플랫폼에 따라 다릅니다. &lt;a href=&quot;qkeysequence#keyBindings&quot;&gt;keyBindings&lt;/a&gt; ()를 사용하여 현재 바인딩 된 바로 가기를 쿼리 할 수 ​​있습니다 .</target>
        </trans-unit>
        <trans-unit id="67d6161b0119249b6a5634aedd1633772057b541" translate="yes" xml:space="preserve">
          <source>Note that the keys are case-insensitive.</source>
          <target state="translated">키는 대소 문자를 구분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a3b0efa055233d5267baec1379f927ff5798f132" translate="yes" xml:space="preserve">
          <source>Note that the last error for this query is reset when &lt;a href=&quot;qsqlquery#exec-1&quot;&gt;exec&lt;/a&gt;() is called.</source>
          <target state="translated">이 쿼리의 마지막 오류는 &lt;a href=&quot;qsqlquery#exec-1&quot;&gt;exec&lt;/a&gt; ()가 호출 될 때 재설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="5dfa77a4f93c9e20ea3fd1b3f132abfb549a62fb" translate="yes" xml:space="preserve">
          <source>Note that the last error for this query is reset when exec() is called.</source>
          <target state="translated">이 쿼리의 마지막 오류는 exec ()가 호출 될 때 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="86fa4959e32900b77cf71a377ce29fa43c8617f2" translate="yes" xml:space="preserve">
          <source>Note that the latter, in particular, affects large objects. To have Qt 5 behavior, you could wrap your objects into smart pointers and store these smart pointers in &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt; directly. In this case, the type of your &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt; would be &lt;code&gt;QList&amp;lt;MySmartPointer&amp;lt;MyLargeObject&amp;gt;&amp;gt;&lt;/code&gt; as opposed to &lt;code&gt;QList&amp;lt;MyLargeObject&amp;gt;&lt;/code&gt; in Qt 5.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2fd977ead293ddab3666ef0008fc44a8f952306" translate="yes" xml:space="preserve">
          <source>Note that the layout is free to use geometry caching to optimize this process. To forcefully invalidate any such cache, you can call &lt;a href=&quot;qgraphicslayout#invalidate&quot;&gt;invalidate&lt;/a&gt;() before calling activate().</source>
          <target state="translated">레이아웃은이 프로세스를 최적화하기 위해 지오메트리 캐싱을 자유롭게 사용할 수 있습니다. 이러한 캐시를 강제로 무효화하려면 activate ()를 호출하기 전에 &lt;a href=&quot;qgraphicslayout#invalidate&quot;&gt;invalidate&lt;/a&gt; ()를 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="931baa08f18ee5ccb86406378de3268ecd979a3b" translate="yes" xml:space="preserve">
          <source>Note that the list may become outdated if changes are made on the local system or remote print server. Only instantiate required &lt;a href=&quot;qprinterinfo&quot;&gt;QPrinterInfo&lt;/a&gt; instances when needed, and always check for validity before calling.</source>
          <target state="translated">로컬 시스템 또는 원격 인쇄 서버에서 변경을 수행하면 목록이 오래 될 수 있습니다. 필요한 경우 필요한 &lt;a href=&quot;qprinterinfo&quot;&gt;QPrinterInfo&lt;/a&gt; 인스턴스 만 인스턴스화 하고 호출하기 전에 항상 유효성을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="893b3b53fd5d87a7bb9869a297d9d9ba571a5685" translate="yes" xml:space="preserve">
          <source>Note that the list of painter commands is reset on each call to the &lt;a href=&quot;qpainter#begin&quot;&gt;QPainter::begin&lt;/a&gt;() function.</source>
          <target state="translated">&lt;a href=&quot;qpainter#begin&quot;&gt;QPainter :: begin&lt;/a&gt; () 함수를 호출 할 때마다 페인터 명령 목록이 재설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="9ca75aea308b31b231d359fc1fe625bc9960d5c4" translate="yes" xml:space="preserve">
          <source>Note that the list order changes when &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; children are &lt;a href=&quot;qwidget#raise&quot;&gt;raised&lt;/a&gt; or &lt;a href=&quot;qwidget#lower&quot;&gt;lowered&lt;/a&gt;. A widget that is raised becomes the last object in the list, and a widget that is lowered becomes the first object in the list.</source>
          <target state="translated">&lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; 하위 항목을 &lt;a href=&quot;qwidget#raise&quot;&gt;올리&lt;/a&gt; 거나 &lt;a href=&quot;qwidget#lower&quot;&gt;내릴&lt;/a&gt; 때 목록 순서가 변경됩니다 . 올려 진 위젯은 목록의 마지막 객체가되고 내려진 위젯은 목록의 첫 번째 객체가됩니다.</target>
        </trans-unit>
        <trans-unit id="f9f6f333826b754ddac9bff36da55a9ec84375c5" translate="yes" xml:space="preserve">
          <source>Note that the list order changes when &lt;a href=&quot;widgets-changes-qt6#qwidget&quot;&gt;QWidget&lt;/a&gt; children are &lt;a href=&quot;qwidget#raise&quot;&gt;raised&lt;/a&gt; or &lt;a href=&quot;qwidget#lower&quot;&gt;lowered&lt;/a&gt;. A widget that is raised becomes the last object in the list, and a widget that is lowered becomes the first object in the list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="caff9acc77629d2ee604fec7408328aa5b9d276a" translate="yes" xml:space="preserve">
          <source>Note that the local machine ID is not guaranteed to be persistent across boots of the system, so this identifier should not be stored in persistent storage (like the filesystem). It is guaranteed to remain constant only during the lifetime of this boot session.</source>
          <target state="translated">로컬 시스템 ID가 시스템의 부트에서 지속적으로 유지되는 것은 아니므로이 식별자는 파일 시스템과 같은 영구 저장소에 저장해서는 안됩니다. 이 부팅 세션 동안에 만 일정하게 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="e9d432d5fcd6bf668375e90fdebce36d0764472b" translate="yes" xml:space="preserve">
          <source>Note that the model used is &lt;a href=&quot;qfilesystemmodel&quot;&gt;QFileSystemModel&lt;/a&gt;. It has custom item data roles, which is described by the &lt;a href=&quot;qfilesystemmodel#Roles-enum&quot;&gt;Roles&lt;/a&gt; enum. You can use a &lt;a href=&quot;qfileiconprovider&quot;&gt;QFileIconProvider&lt;/a&gt; if you only want custom icons.</source>
          <target state="translated">사용 된 모델은 &lt;a href=&quot;qfilesystemmodel&quot;&gt;QFileSystemModel&lt;/a&gt; 입니다. 그것은에 의해 설명 사용자 정의 항목 데이터 역할이 &lt;a href=&quot;qfilesystemmodel#Roles-enum&quot;&gt;역할&lt;/a&gt; 열거. 사용자 정의 아이콘 만 원하는 경우 &lt;a href=&quot;qfileiconprovider&quot;&gt;QFileIconProvider&lt;/a&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="205d058469d855fc01f0c7b71c3a4fa6c4c7316b" translate="yes" xml:space="preserve">
          <source>Note that the model used needs to provide support for drag and drop operations.</source>
          <target state="translated">사용 된 모델은 끌어서 놓기 작업을 지원해야합니다.</target>
        </trans-unit>
        <trans-unit id="3e70c35138250388f9bbe731cc071e15593bbd98" translate="yes" xml:space="preserve">
          <source>Note that the model will typically need to provide implementations of the &lt;a href=&quot;qabstractitemmodel#insertRows&quot;&gt;QAbstractItemModel::insertRows&lt;/a&gt;() and &lt;a href=&quot;qabstractitemmodel#setData&quot;&gt;QAbstractItemModel::setData&lt;/a&gt;() functions.</source>
          <target state="translated">모델은 일반적으로 &lt;a href=&quot;qabstractitemmodel#insertRows&quot;&gt;QAbstractItemModel :: insertRows&lt;/a&gt; () 및 &lt;a href=&quot;qabstractitemmodel#setData&quot;&gt;QAbstractItemModel :: setData&lt;/a&gt; () 함수의 구현을 제공해야 합니다.</target>
        </trans-unit>
        <trans-unit id="a559cec58514c032b72ce0a0dc9631f2eb428bba" translate="yes" xml:space="preserve">
          <source>Note that the module will not receive additional features anymore. For reading or writing XML documents iteratively (SAX), we recommend using Qt Core's &lt;a href=&quot;qxmlstreamreader&quot;&gt;QXmlStreamReader&lt;/a&gt; and &lt;a href=&quot;qxmlstreamwriter&quot;&gt;QXmlStreamWriter&lt;/a&gt; classes. The classes are both easier to use and more compliant with the XML standard.</source>
          <target state="translated">모듈은 더 이상 추가 기능을받지 않습니다. 반복적으로 XML 문서를 읽거나 쓰 &lt;a href=&quot;qxmlstreamreader&quot;&gt;려면&lt;/a&gt; (SAX) Qt Core의 QXmlStreamReader 및 &lt;a href=&quot;qxmlstreamwriter&quot;&gt;QXmlStreamWriter&lt;/a&gt; 클래스를 사용하는 것이 좋습니다 . 이 클래스는 사용하기 쉽고 XML 표준을 준수합니다.</target>
        </trans-unit>
        <trans-unit id="2df460294ccf94fbf9fc37131626d6cb0f699513" translate="yes" xml:space="preserve">
          <source>Note that the namespaces</source>
          <target state="translated">네임 스페이스는</target>
        </trans-unit>
        <trans-unit id="28bc52218faba957874da52c425e37c4f1e940dd" translate="yes" xml:space="preserve">
          <source>Note that the next block may be in a different frame or table to this block.</source>
          <target state="translated">다음 블록은이 블록과 다른 프레임 또는 테이블에있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a911d0130ca3562b83a19ea3f855a7046573b2fe" translate="yes" xml:space="preserve">
          <source>Note that the only part of the class definition that is specific to this particular custom widget is the class name. In addition, since we are implementing an interface, we must ensure that it's made known to the meta object system using the &lt;a href=&quot;qobject#Q_INTERFACES&quot;&gt;Q_INTERFACES&lt;/a&gt;() macro. This enables</source>
          <target state="translated">이 특정 사용자 정의 위젯과 관련된 클래스 정의의 유일한 부분은 클래스 이름입니다. 또한 인터페이스를 구현하고 있으므로 &lt;a href=&quot;qobject#Q_INTERFACES&quot;&gt;Q_INTERFACES&lt;/a&gt; () 매크로를 사용하여 메타 객체 시스템에 해당 인터페이스가 알려 지도록해야합니다 . 이것은 가능</target>
        </trans-unit>
        <trans-unit id="81097c333b641d5c81571db04df6adab1a8594bd" translate="yes" xml:space="preserve">
          <source>Note that the operating system may impose further limits on applications holding a lot of allocated memory, especially large, contiguous blocks. Such considerations, the configuration of such behavior or any mitigation are outside the scope of the &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; API.</source>
          <target state="translated">운영 체제는 많은 양의 할당 된 메모리, 특히 크고 연속적인 블록을 보유하는 응용 프로그램에 추가 제한을 부과 할 수 있습니다. 이러한 고려 사항, 이러한 동작의 구성 또는 완화는 &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; API 의 범위를 벗어 납니다 .</target>
        </trans-unit>
        <trans-unit id="c286206a64fc0f5a809523dc45af23c405319c92" translate="yes" xml:space="preserve">
          <source>Note that the operating system may impose further limits on applications holding a lot of allocated memory, especially large, contiguous blocks. Such considerations, the configuration of such behavior or any mitigation are outside the scope of the QByteArray API.</source>
          <target state="translated">운영 체제는 많은 할당 된 메모리, 특히 큰 연속 블록을 보유하는 응용 프로그램에 추가 제한을 부과 할 수 있습니다. 이러한 고려 사항, 이러한 동작의 구성 또는 완화는 QByteArray API의 범위를 벗어납니다.</target>
        </trans-unit>
        <trans-unit id="a130196eaa4bc41c84758b11314c27a007b22a72" translate="yes" xml:space="preserve">
          <source>Note that the operating system may impose further limits on applications holding a lot of allocated memory, especially large, contiguous blocks. Such considerations, the configuration of such behavior or any mitigation are outside the scope of the Qt API.</source>
          <target state="translated">운영 체제는 많은 양의 할당 된 메모리, 특히 크고 연속적인 블록을 보유하는 응용 프로그램에 추가 제한을 부과 할 수 있습니다. 이러한 고려 사항, 이러한 동작의 구성 또는 완화는 Qt API의 범위를 벗어납니다.</target>
        </trans-unit>
        <trans-unit id="acf020250b2890dc46dd84ffccf99779ed4bc9b4" translate="yes" xml:space="preserve">
          <source>Note that the optional XML declaration at very beginning of the XML document is not a processing instruction</source>
          <target state="translated">XML 문서의 맨 처음에 선택적 XML 선언은 처리 명령이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="77103f070c9810f63d6027410c5ae4efb748154a" translate="yes" xml:space="preserve">
          <source>Note that the order of the arguments is significant. If order does not matter, use &lt;a href=&quot;qhash#qHashMultiCommutative&quot;&gt;qHashMultiCommutative&lt;/a&gt;() instead. If you are hashing raw memory, use &lt;a href=&quot;qhash#qHashBits&quot;&gt;qHashBits&lt;/a&gt;(); if you are hashing a range, use &lt;a href=&quot;qhash#qHashRange&quot;&gt;qHashRange&lt;/a&gt;().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d1f1f8da8f6dbc87b139601e19f8a1b86d3d283" translate="yes" xml:space="preserve">
          <source>Note that the order we add the parameters is important, because there is dependency between the parameters. Adding a layer before adding a source will create an invalid layer, same goes for adding a paint property for a layer that doesn't exist.</source>
          <target state="translated">매개 변수 사이에 종속성이 있기 때문에 매개 변수를 추가하는 순서가 중요합니다. 소스를 추가하기 전에 레이어를 추가하면 유효하지 않은 레이어가 생성되며, 존재하지 않는 레이어에 페인트 속성을 추가하는 것과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="1cd5f49603f9b1664cd9bf37ae06190cdb8280b1" translate="yes" xml:space="preserve">
          <source>Note that the original image is not changed.</source>
          <target state="translated">원본 이미지는 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f45fafdd6992ce9fec27ab47abd67ccddf91b86a" translate="yes" xml:space="preserve">
          <source>Note that the other notification types will be sent even if the notifications for this object have been blocked.</source>
          <target state="translated">이 객체에 대한 알림이 차단 된 경우에도 다른 알림 유형이 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="c5c3336409d6b975ac6824e4d87c75520931c134" translate="yes" xml:space="preserve">
          <source>Note that the path may not currently exist on the filesystem, so callers wanting to</source>
          <target state="translated">경로는 현재 파일 시스템에 존재하지 않을 수 있으므로 호출자는</target>
        </trans-unit>
        <trans-unit id="f54c75111d02c45cb47257dd956c260ac57e9eed" translate="yes" xml:space="preserve">
          <source>Note that the pixel data in a pixmap is internal and is managed by the underlying window system. Because &lt;a href=&quot;qpixmap&quot;&gt;QPixmap&lt;/a&gt; is a &lt;a href=&quot;qpaintdevice&quot;&gt;QPaintDevice&lt;/a&gt; subclass, &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; can be used to draw directly onto pixmaps. Pixels can only be accessed through &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; functions or by converting the &lt;a href=&quot;qpixmap&quot;&gt;QPixmap&lt;/a&gt; to a &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt;. However, the &lt;a href=&quot;qpixmap#fill&quot;&gt;fill&lt;/a&gt;() function is available for initializing the entire pixmap with a given color.</source>
          <target state="translated">픽스맵의 픽셀 데이터는 내부 데이터이며 기본 윈도우 시스템에 의해 관리됩니다. 때문에 &lt;a href=&quot;qpixmap&quot;&gt;QPixmap는&lt;/a&gt; A는 &lt;a href=&quot;qpaintdevice&quot;&gt;QPaintDevice의&lt;/a&gt; 하위 클래스 &lt;a href=&quot;qpainter&quot;&gt;QPainter를는&lt;/a&gt; 픽스맵에 직접 묘화에 사용된다. 픽셀은 &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; 함수 또는 &lt;a href=&quot;qpixmap&quot;&gt;QPixmap&lt;/a&gt; 을 &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt; 로 변환하여 액세스 할 수 있습니다 . 그러나 &lt;a href=&quot;qpixmap#fill&quot;&gt;fill&lt;/a&gt; () 함수는 주어진 색상으로 전체 픽스맵을 초기화하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="07b02a5eadb9f7ce7f76ed484eed762ff40dc9e6" translate="yes" xml:space="preserve">
          <source>Note that the pixel data in a pixmap is internal and is managed by the underlying window system. Because QPixmap is a &lt;a href=&quot;qpaintdevice&quot;&gt;QPaintDevice&lt;/a&gt; subclass, &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; can be used to draw directly onto pixmaps. Pixels can only be accessed through &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; functions or by converting the QPixmap to a &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt;. However, the &lt;a href=&quot;qpixmap#fill&quot;&gt;fill&lt;/a&gt;() function is available for initializing the entire pixmap with a given color.</source>
          <target state="translated">픽스맵의 픽셀 데이터는 내부적이며 기본 윈도우 시스템에서 관리합니다. QPixmap은 &lt;a href=&quot;qpaintdevice&quot;&gt;QPaintDevice&lt;/a&gt; 서브 클래스 이기 때문에 &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; 를 사용하여 픽스맵에 직접 그릴 수 있습니다. 픽셀은 &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; 함수를 통해서나 QPixmap을 &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt; 로 변환하여 액세스 할 수 있습니다 . 그러나 &lt;a href=&quot;qpixmap#fill&quot;&gt;채우기&lt;/a&gt; () 함수는 주어진 색상으로 전체 픽스맵을 초기화하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="45ac1202da8180aee9bca70eafd878851fe9da61" translate="yes" xml:space="preserve">
          <source>Note that the pointer remains valid only as long as the string is not modified by other means. For read-only access, &lt;a href=&quot;qstring#constData&quot;&gt;constData&lt;/a&gt;() is faster because it never causes a &lt;a href=&quot;implicit-sharing#deep-copy&quot;&gt;deep copy&lt;/a&gt; to occur.</source>
          <target state="translated">포인터가 다른 방법으로 문자열을 수정하지 않는 한 포인터는 계속 유효합니다. 읽기 전용 액세스의 경우 &lt;a href=&quot;qstring#constData&quot;&gt;constData&lt;/a&gt; ()는 &lt;a href=&quot;implicit-sharing#deep-copy&quot;&gt;깊은 복사&lt;/a&gt; 가 발생 하지 않기 때문에 더 빠릅니다 .</target>
        </trans-unit>
        <trans-unit id="95aa67a1b92b5f7eee27369ff131e1c6e15b5f3f" translate="yes" xml:space="preserve">
          <source>Note that the pointer remains valid only as long as the string is not modified.</source>
          <target state="translated">포인터는 문자열이 수정되지 않는 한 유효합니다.</target>
        </trans-unit>
        <trans-unit id="81df146537add4fd8ddb77c1e9428a9f73e5a26c" translate="yes" xml:space="preserve">
          <source>Note that the pointer returned by this function is managed by &lt;a href=&quot;qnetworkaccessmanager&quot;&gt;QNetworkAccessManager&lt;/a&gt; and could be deleted at any time.</source>
          <target state="translated">이 함수에 의해 반환 된 포인터는 &lt;a href=&quot;qnetworkaccessmanager&quot;&gt;QNetworkAccessManager에&lt;/a&gt; 의해 관리되며 언제든지 삭제할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="893d2b0119153b0629f0c8d5d6cda67a29cad856" translate="yes" xml:space="preserve">
          <source>Note that the position of the current item may only be approximate until it becomes visible in the view.</source>
          <target state="translated">현재 항목의 위치는보기에 표시 될 때까지만 대략적 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb7c4bf67b610cc519cfab6332dcc193f038dc14" translate="yes" xml:space="preserve">
          <source>Note that the position source may have a minimum value requirement for update intervals, as returned by &lt;a href=&quot;qgeopositioninfosource#minimumUpdateInterval-prop&quot;&gt;minimumUpdateInterval&lt;/a&gt;().</source>
          <target state="translated">positionUpdate는 &lt;a href=&quot;qgeopositioninfosource#minimumUpdateInterval-prop&quot;&gt;minimumUpdateInterval&lt;/a&gt; ()에 의해 반환되는 업데이트 간격에 대한 최소값 요구 사항을 가질 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3a2cdde6bca3928dc13b2bb1935d23a033461baf" translate="yes" xml:space="preserve">
          <source>Note that the prefix</source>
          <target state="translated">접두사</target>
        </trans-unit>
        <trans-unit id="2f512d6c5b8f9c9b1e84e3590dbe224cef90747f" translate="yes" xml:space="preserve">
          <source>Note that the previous block may be in a different frame or table to this block.</source>
          <target state="translated">이전 블록은이 블록과 다른 프레임 또는 테이블에있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a56afc3eb8a29f00f93427a9c6fb6601c4c3f27c" translate="yes" xml:space="preserve">
          <source>Note that the qmake project of this example includes a resource file &lt;code&gt;testcon.rc&lt;/code&gt; with a version resource. This is required by some ActiveX controls (ie. Shockwave ActiveX Controls), which might crash or misbehave otherwise if such version information is missing.</source>
          <target state="translated">이 예제의 qmake 프로젝트에는 버전 자원 이있는 자원 파일 &lt;code&gt;testcon.rc&lt;/code&gt; 가 포함되어 있습니다. 이는 일부 ActiveX 컨트롤 (예 : Shockwave ActiveX 컨트롤)에 필요합니다. 이러한 버전 정보가 없으면 충돌하거나 오작동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c49f3e3184fc4b46d7786ceb6e5b3bee66dc1b1b" translate="yes" xml:space="preserve">
          <source>Note that the range is not updated until the widget is shown.</source>
          <target state="translated">위젯이 표시 될 때까지 범위가 업데이트되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="11ba26128f120cc8760e6a98042e8cbb59684272" translate="yes" xml:space="preserve">
          <source>Note that the range of values used is independent of the actual size of the scroll bar widget. You do not need to take this into account when you choose values for the range and the page step.</source>
          <target state="translated">사용 된 값의 범위는 스크롤 막대 위젯의 실제 크기와 무관합니다. 범위 및 페이지 단계의 값을 선택할 때이를 고려할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="9c7e1f6ab28601b4c9096ca5eba8c3ce66a37de5" translate="yes" xml:space="preserve">
          <source>Note that the rectangle usually extends both above and below the base line.</source>
          <target state="translated">사각형은 일반적으로 기준선 위와 아래 모두로 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="e7eea4bb109066ee8b24fd3f515648916a0748d3" translate="yes" xml:space="preserve">
          <source>Note that the result is rounded to the nearest integer as points are held as integers. Use &lt;a href=&quot;qpointf&quot;&gt;QPointF&lt;/a&gt; for floating point accuracy.</source>
          <target state="translated">포인트가 정수로 유지되므로 결과는 가장 가까운 정수로 반올림됩니다. 부동 소수점 정확도를 위해 &lt;a href=&quot;qpointf&quot;&gt;QPointF&lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="99998472d79951feb45b036975f38e6cbfc64af9" translate="yes" xml:space="preserve">
          <source>Note that the result is rounded to the nearest integer.</source>
          <target state="translated">결과는 가장 가까운 정수로 반올림됩니다.</target>
        </trans-unit>
        <trans-unit id="a833ac0dac2e3e6650a8acb70524f04e44e042fd" translate="yes" xml:space="preserve">
          <source>Note that the result of comparing two empty &lt;a href=&quot;qfileinfo&quot;&gt;QFileInfo&lt;/a&gt; objects, containing no file references (file paths that do not exist or are empty), is undefined.</source>
          <target state="translated">존재하지 않거나 비어있는 파일 참조가없는 두 개의 빈 &lt;a href=&quot;qfileinfo&quot;&gt;QFileInfo&lt;/a&gt; 객체 를 비교 한 결과 는 정의되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="06553a94231607edc8a83ecbca713402876c46b4" translate="yes" xml:space="preserve">
          <source>Note that the result of comparing two invalid &lt;a href=&quot;qstorageinfo&quot;&gt;QStorageInfo&lt;/a&gt; objects is always positive.</source>
          <target state="translated">유효하지 않은 두 &lt;a href=&quot;qstorageinfo&quot;&gt;QStorageInfo&lt;/a&gt; 오브젝트 를 비교 한 결과 는 항상 긍정적입니다.</target>
        </trans-unit>
        <trans-unit id="9455966e3ddcdd7fd7a8708d925b88285294e062" translate="yes" xml:space="preserve">
          <source>Note that the result types above are not &lt;a href=&quot;qfuture&quot;&gt;QFuture&lt;/a&gt; objects, but real result types (in this case, &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt;&amp;lt;QImage&amp;gt; and QImage).</source>
          <target state="translated">위의 결과 유형은 &lt;a href=&quot;qfuture&quot;&gt;QFuture&lt;/a&gt; 오브젝트가 아니라 실제 결과 유형입니다 (이 경우 &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt; &amp;lt;QImage&amp;gt; 및 QImage).</target>
        </trans-unit>
        <trans-unit id="52404f798007b3ce5bd6a35a3894a63e0fc0c39b" translate="yes" xml:space="preserve">
          <source>Note that the result types above are not &lt;a href=&quot;qfuture&quot;&gt;QFuture&lt;/a&gt; objects, but real result types (in this case, &lt;a href=&quot;qstringlist&quot;&gt;QStringList&lt;/a&gt; and &lt;a href=&quot;qset&quot;&gt;QSet&lt;/a&gt;&amp;lt;&lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;&amp;gt;).</source>
          <target state="translated">위의 결과 유형은 &lt;a href=&quot;qfuture&quot;&gt;QFuture&lt;/a&gt; 오브젝트가 아니라 실제 결과 유형입니다 (이 경우 &lt;a href=&quot;qstringlist&quot;&gt;QStringList&lt;/a&gt; 및 &lt;a href=&quot;qset&quot;&gt;QSet&lt;/a&gt; &amp;lt; &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; &amp;gt;).</target>
        </trans-unit>
        <trans-unit id="67a0b154217bec5756e4815c68920d8d4d0c0c96" translate="yes" xml:space="preserve">
          <source>Note that the result types above are not &lt;a href=&quot;qtcore-changes-qt6#qfuture&quot;&gt;QFuture&lt;/a&gt; objects, but real result types (in this case, &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt;&amp;lt;QImage&amp;gt; and QImage).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab84eea5aaac7a5469cafeb7715cb0d6507745b9" translate="yes" xml:space="preserve">
          <source>Note that the result types above are not &lt;a href=&quot;qtcore-changes-qt6#qfuture&quot;&gt;QFuture&lt;/a&gt; objects, but real result types (in this case, &lt;a href=&quot;qstringlist&quot;&gt;QStringList&lt;/a&gt; and &lt;a href=&quot;qset&quot;&gt;QSet&lt;/a&gt;&amp;lt;&lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;&amp;gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51e19b847dd64845c76b7f5deb5263a19534dcd4" translate="yes" xml:space="preserve">
          <source>Note that the return value and return type of the map function are not used.</source>
          <target state="translated">맵 함수의 반환 값과 반환 유형은 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4ec6a81f2adc2ebc02f7177305ed2da055fdf02b" translate="yes" xml:space="preserve">
          <source>Note that the returned &lt;a href=&quot;qtextlayout&quot;&gt;QTextLayout&lt;/a&gt; object can only be modified from the documentChanged implementation of a &lt;a href=&quot;qabstracttextdocumentlayout&quot;&gt;QAbstractTextDocumentLayout&lt;/a&gt; subclass. Any changes applied from the outside cause undefined behavior.</source>
          <target state="translated">리턴 된 &lt;a href=&quot;qtextlayout&quot;&gt;QTextLayout&lt;/a&gt; 오브젝트는 &lt;a href=&quot;qabstracttextdocumentlayout&quot;&gt;QAbstractTextDocumentLayout&lt;/a&gt; 서브 클래스 의 documentChanged 구현에서만 수정할 수 있습니다 . 외부에서 적용된 변경 사항은 정의되지 않은 동작을 유발합니다.</target>
        </trans-unit>
        <trans-unit id="2357442c445daa102e80db09253868c0ce98a0c9" translate="yes" xml:space="preserve">
          <source>Note that the returned line's start and end points are rounded to the nearest integer.</source>
          <target state="translated">반환 된 줄의 시작 및 끝 지점은 가장 가까운 정수로 반올림됩니다.</target>
        </trans-unit>
        <trans-unit id="20107e5c5cc5b651f84c94f8824b4abcba36917a" translate="yes" xml:space="preserve">
          <source>Note that the returned value is always &lt;a href=&quot;qt#MouseButton-enum&quot;&gt;Qt::NoButton&lt;/a&gt; for &lt;a href=&quot;qevent#Type-enum&quot;&gt;TabletMove&lt;/a&gt;, &lt;a href=&quot;qevent#Type-enum&quot;&gt;TabletEnterProximity&lt;/a&gt; and &lt;a href=&quot;qevent#Type-enum&quot;&gt;TabletLeaveProximity&lt;/a&gt; events.</source>
          <target state="translated">반환 된 값은 &lt;a href=&quot;qevent#Type-enum&quot;&gt;TabletMove&lt;/a&gt; , &lt;a href=&quot;qevent#Type-enum&quot;&gt;TabletEnterProximity&lt;/a&gt; 및 &lt;a href=&quot;qevent#Type-enum&quot;&gt;TabletLeaveProximity&lt;/a&gt; 이벤트에 대해 항상 &lt;a href=&quot;qt#MouseButton-enum&quot;&gt;Qt :: NoButton&lt;/a&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="7d371b14b24c2024581798cedb334d5ace393b33" translate="yes" xml:space="preserve">
          <source>Note that the returned value is always &lt;a href=&quot;qt#MouseButton-enum&quot;&gt;Qt::NoButton&lt;/a&gt; for mouse move events.</source>
          <target state="translated">반환 된 값은 항상 마우스 이동 이벤트에 대한 &lt;a href=&quot;qt#MouseButton-enum&quot;&gt;Qt :: NoButton&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6bb5e32ae5d90393604deef8b29e1a8bd15397cc" translate="yes" xml:space="preserve">
          <source>Note that the root (CA) certificate should not be included in the list to be verified, this will be looked up automatically either using the CA list specified by QSslSocket::defaultCaCertificates() or, if possible, it will be loaded on demand on Unix.</source>
          <target state="translated">루트 (CA) 인증서는 확인할 목록에 포함되지 않아야합니다. 이는 QSslSocket :: defaultCaCertificates ()에 의해 지정된 CA 목록을 사용하여 자동으로 조회되거나 가능하면 요청시로드됩니다. 유닉스.</target>
        </trans-unit>
        <trans-unit id="20e800a4190dc4200571130e6f396d5dfcc4ae1e" translate="yes" xml:space="preserve">
          <source>Note that the root (CA) certificate should not be included in the list to be verified, this will be looked up automatically using the CA list specified in the default &lt;a href=&quot;qsslconfiguration&quot;&gt;QSslConfiguration&lt;/a&gt;, and, in addition, if possible, CA certificates loaded on demand on Unix and Windows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99ef917431487c7252dfc942bc61b5a9d9e59a64" translate="yes" xml:space="preserve">
          <source>Note that the root item of the delegate component must be a &lt;a href=&quot;qquickitem&quot;&gt;QQuickItem&lt;/a&gt; or &lt;a href=&quot;qquickitem&quot;&gt;QQuickItem&lt;/a&gt; derived item.</source>
          <target state="translated">델리게이트 컴포넌트의 루트 아이템은 &lt;a href=&quot;qquickitem&quot;&gt;QQuickItem&lt;/a&gt; 또는 &lt;a href=&quot;qquickitem&quot;&gt;QQuickItem&lt;/a&gt; 파생 아이템 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="7e2e2897f4933d81ab34647ae6658ddc7db509eb" translate="yes" xml:space="preserve">
          <source>Note that the root rectangle in the code above is superfluous as the window is also white, so drawing the rectangle is a waste of resources in this case. Changing it to an Item can give a slight performance boost.</source>
          <target state="translated">위의 코드에서 루트 사각형은 창이 흰색이기 때문에 불필요하므로 사각형을 그리는 것은 리소스 낭비입니다. 아이템으로 변경하면 성능이 약간 향상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a80a7c24c4a56e6370db72fa960575828468a5be" translate="yes" xml:space="preserve">
          <source>Note that the rows and columns in the table begin at zero.</source>
          <target state="translated">테이블의 행과 열은 0에서 시작합니다.</target>
        </trans-unit>
        <trans-unit id="ff4e877559139a523eabc6b48335110b2e5ee5f2" translate="yes" xml:space="preserve">
          <source>Note that the satellite source may have a minimum value requirement for update intervals, as returned by &lt;a href=&quot;qgeosatelliteinfosource#minimumUpdateInterval-prop&quot;&gt;minimumUpdateInterval&lt;/a&gt;().</source>
          <target state="translated">위성 소스는 &lt;a href=&quot;qgeosatelliteinfosource#minimumUpdateInterval-prop&quot;&gt;minimumUpdateInterval&lt;/a&gt; ()에 의해 반환되는 업데이트 간격에 대한 최소값 요구 사항을 가질 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="651ff2c9070e2724d6aa186d1e4c7932eb90910d" translate="yes" xml:space="preserve">
          <source>Note that the size and position of this element affects which particles it affects. The size of the point attracted to is always 0x0, and the location of that point is specified by the pointX and pointY properties.</source>
          <target state="translated">이 요소의 크기와 위치는 영향을받는 입자에 영향을 미칩니다. 끌어 당겨진 점의 크기는 항상 0x0이며 해당 점의 위치는 pointX 및 pointY 속성으로 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="9d1b76f01a2a06eefc62dcb282427d1f676ad0c7" translate="yes" xml:space="preserve">
          <source>Note that the sprite image will be scaled to a square based on the size of the particle being rendered.</source>
          <target state="translated">스프라이트 이미지는 렌더링되는 입자의 크기에 따라 정사각형으로 조정됩니다.</target>
        </trans-unit>
        <trans-unit id="b303990ec67debdc1821bba9fec057af04b6ab6a" translate="yes" xml:space="preserve">
          <source>Note that the standard and DST offsets for a time zone may change over time as countries have changed DST laws or even their standard time offset.</source>
          <target state="translated">국가가 DST 법을 변경하거나 표준 시간 오프셋을 변경함에 따라 시간대에 대한 표준 및 DST 오프셋이 시간이 지남에 따라 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f7a06c1cac4ed4b90be9814753d4e716cf2b8e4b" translate="yes" xml:space="preserve">
          <source>Note that the startup function will run at the end of the &lt;a href=&quot;qcoreapplication&quot;&gt;QCoreApplication&lt;/a&gt; constructor, before any GUI initialization. If GUI code is required in the function, use a timer (or a queued invocation) to perform the initialization later on, from the event loop.</source>
          <target state="translated">시작 기능은 GUI 초기화 전에 &lt;a href=&quot;qcoreapplication&quot;&gt;QCoreApplication&lt;/a&gt; 생성자 의 끝에서 실행됩니다 . 함수에 GUI 코드가 필요한 경우, 타이머 (또는 대기 호출)를 사용하여 나중에 이벤트 루프에서 초기화를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="2ae0a8048633d6feb0a9feab4074993da1369c4a" translate="yes" xml:space="preserve">
          <source>Note that the static function signatures have changed with respect to their button parameters, which are now used to set the &lt;a href=&quot;qmessagebox#standardButtons-prop&quot;&gt;standard buttons&lt;/a&gt; and the &lt;a href=&quot;qmessagebox#defaultButton&quot;&gt;default button&lt;/a&gt;.</source>
          <target state="translated">정적 함수 시그니처는 버튼 매개 변수와 관련하여 변경되었으며, 이제는 &lt;a href=&quot;qmessagebox#standardButtons-prop&quot;&gt;표준 버튼&lt;/a&gt; 및 &lt;a href=&quot;qmessagebox#defaultButton&quot;&gt;기본 버튼&lt;/a&gt; 을 설정하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="e18e5a0128cfc3f65359edcf7cb25167a5e49489" translate="yes" xml:space="preserve">
          <source>Note that the table view uses the horizontal header section positions to determine the positions of columns in the view.</source>
          <target state="translated">테이블 뷰는 가로 머리글 섹션 위치를 사용하여 뷰의 열 위치를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="be19473933101d0885da4c334d43a650b9be5626" translate="yes" xml:space="preserve">
          <source>Note that the table view uses the vertical header section positions to determine the positions of rows in the view.</source>
          <target state="translated">테이블 뷰는 세로 머리글 섹션 위치를 사용하여 뷰에서 행의 위치를 ​​결정합니다.</target>
        </trans-unit>
        <trans-unit id="bc81a14e86fe31a446b40843a68cdb8d683d1c2c" translate="yes" xml:space="preserve">
          <source>Note that the template class type for the &lt;a href=&quot;qqmllistproperty&quot;&gt;QQmlListProperty&lt;/a&gt; &amp;mdash; in this case, &lt;code&gt;Message&lt;/code&gt; &amp;mdash; must be &lt;a href=&quot;qtqml-cppintegration-definetypes#registering-c-types-with-the-qml-type-system&quot;&gt;registered&lt;/a&gt; with the QML type system.</source>
          <target state="translated">&lt;a href=&quot;qqmllistproperty&quot;&gt;QQmlListProperty (&lt;/a&gt; 이 경우 &lt;code&gt;Message&lt;/code&gt; 의 템플리트 클래스 유형 은 QML 유형 시스템에 &lt;a href=&quot;qtqml-cppintegration-definetypes#registering-c-types-with-the-qml-type-system&quot;&gt;등록&lt;/a&gt; 되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="f0fc4bdab6fe1831aeb1f04563de73586616b79b" translate="yes" xml:space="preserve">
          <source>Note that the text format is something like this &quot;Menu text&lt;b&gt;\t&lt;/b&gt;Shortcut&quot;.</source>
          <target state="translated">텍스트 형식은 &quot;메뉴 텍스트 &lt;b&gt;\ t&lt;/b&gt; 바로 가기&quot;와 같습니다.</target>
        </trans-unit>
        <trans-unit id="6556b9323bed5d00b7457fe38928694dd2a05e6f" translate="yes" xml:space="preserve">
          <source>Note that the text properties of most objects are read-only so calling this function might have no effect.</source>
          <target state="translated">대부분의 객체의 텍스트 속성은 읽기 전용이므로이 함수를 호출해도 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="2e9b2c3bb71d1b3f5ee20037a5e64879c5d63154" translate="yes" xml:space="preserve">
          <source>Note that the thread pool takes ownership of the</source>
          <target state="translated">스레드 풀은</target>
        </trans-unit>
        <trans-unit id="f2aa18d58ce4943c60a8b56a407a353f342059c6" translate="yes" xml:space="preserve">
          <source>Note that the time will wrap if it passes midnight.</source>
          <target state="translated">자정이 지나면 시간이 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="420273956af88df07dbd801586088045e0a6dc1e" translate="yes" xml:space="preserve">
          <source>Note that the time will wrap if it passes midnight. See &lt;a href=&quot;qtime#addSecs&quot;&gt;addSecs&lt;/a&gt;() for an example.</source>
          <target state="translated">자정이 지나면 시간이 줄어 듭니다. 예제는 &lt;a href=&quot;qtime#addSecs&quot;&gt;addSecs&lt;/a&gt; ()를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="42327f2a54ecc39ff386bb855a534bde18388027" translate="yes" xml:space="preserve">
          <source>Note that the translator must be created</source>
          <target state="translated">번역기를 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="975794537a0a5c73be368e9c86ade76311d398fe" translate="yes" xml:space="preserve">
          <source>Note that the tree view uses the horizontal header section positions to determine the positions of columns in the view.</source>
          <target state="translated">트리 뷰는 가로 머리글 섹션 위치를 사용하여 뷰에서 열의 위치를 ​​결정합니다.</target>
        </trans-unit>
        <trans-unit id="e240615bc0cf96fae759435ba4ac4f456f96b77f" translate="yes" xml:space="preserve">
          <source>Note that the type of</source>
          <target state="translated">유형이</target>
        </trans-unit>
        <trans-unit id="a4ebcdc172bcde654322ac8440f62c537ba87f6a" translate="yes" xml:space="preserve">
          <source>Note that the validity of a regexp may also depend on the setting of the wildcard flag, for example &lt;b&gt;*.html&lt;/b&gt; is a valid wildcard regexp but an invalid full regexp.</source>
          <target state="translated">정규 표현식의 유효성은 와일드 카드 플래그 설정에 따라 달라질 수 있습니다. 예를 들어 &lt;b&gt;* .html&lt;/b&gt; 은 유효한 와일드 카드 정규 표현식이지만 유효하지 않은 전체 정규 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="721d3f620b4a78dea02a18fe63935c90aa4b92b0" translate="yes" xml:space="preserve">
          <source>Note that the value returned by &lt;a href=&quot;qdbusunixfiledescriptor#fileDescriptor&quot;&gt;fileDescriptor&lt;/a&gt;() will be different from the</source>
          <target state="translated">&lt;a href=&quot;qdbusunixfiledescriptor#fileDescriptor&quot;&gt;fileDescriptor&lt;/a&gt; ()에 의해 반환 된 값 은</target>
        </trans-unit>
        <trans-unit id="a17c6df9942084beec45857776beaf6c234514d2" translate="yes" xml:space="preserve">
          <source>Note that the value returned by rootPath() is the real mount point of a volume, and may not be equal to the value passed to the constructor or &lt;a href=&quot;qstorageinfo#setPath&quot;&gt;setPath&lt;/a&gt;() method. For example, if you have only the root volume in the system, and pass '/directory' to &lt;a href=&quot;qstorageinfo#setPath&quot;&gt;setPath&lt;/a&gt;(), then this method will return '/'.</source>
          <target state="translated">rootPath ()에 의해 리턴 된 값은 볼륨의 실제 마운트 지점이며 생성자 또는 &lt;a href=&quot;qstorageinfo#setPath&quot;&gt;setPath&lt;/a&gt; () 메소드에 전달 된 값과 같지 않을 수 있습니다 . 예를 들어 시스템에 루트 볼륨 만 있고 '/ directory'를 &lt;a href=&quot;qstorageinfo#setPath&quot;&gt;setPath&lt;/a&gt; ()에 전달하면이 메소드는 '/'를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="40d9582f71491edc69eff5d0b8f071c1af5b8f9e" translate="yes" xml:space="preserve">
          <source>Note that the values in the class returned by &lt;a href=&quot;qsensor#reading-prop&quot;&gt;QSensor::reading&lt;/a&gt;() will not be updated until after the filters have been run.</source>
          <target state="translated">&lt;a href=&quot;qsensor#reading-prop&quot;&gt;QSensor :: reading&lt;/a&gt; ()에 의해 리턴 된 클래스의 값 은 필터가 실행될 때까지 업데이트되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d2397ff4f0a783df1111e5727ce2813dabe964bb" translate="yes" xml:space="preserve">
          <source>Note that the values of both</source>
          <target state="translated">두 값 모두</target>
        </trans-unit>
        <trans-unit id="ccde549c6fb3527ec601cff7fcaa23b97d3262a2" translate="yes" xml:space="preserve">
          <source>Note that the width is always &amp;gt;= &lt;a href=&quot;qtextdocument#pageSize-prop&quot;&gt;pageSize&lt;/a&gt;().width().</source>
          <target state="translated">너비는 항상&amp;gt; = &lt;a href=&quot;qtextdocument#pageSize-prop&quot;&gt;pageSize&lt;/a&gt; () .width ()입니다.</target>
        </trans-unit>
        <trans-unit id="ed0a12ae058952dbd4f1a67973fee8b977ec9e20" translate="yes" xml:space="preserve">
          <source>Note that the window-viewport conversion is only a linear transformation, i.e. it does not perform clipping. This means that if you paint outside the currently set &quot;window&quot;, your painting is still transformed to the viewport using the same linear algebraic approach.</source>
          <target state="translated">창-뷰포트 변환은 선형 변환 일뿐입니다. 즉 클리핑을 수행하지 않습니다. 즉, 현재 설정된 &quot;창&quot;외부에서 페인트를해도 동일한 선형 대수 방식을 사용하여 페인팅이 뷰포트로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="cccdddb4fe64f71eb3b9af9e20c245d6f3f25556" translate="yes" xml:space="preserve">
          <source>Note that there are no direct mapping between the Qt &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; tree and the accessible object tree. For instance, scroll bar handles are accessible objects but are not widgets or objects in Qt.</source>
          <target state="translated">Qt &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 트리와 액세스 가능한 객체 트리 사이에는 직접 매핑이 없습니다 . 예를 들어, 스크롤 막대 핸들은 액세스 가능한 객체이지만 Qt의 위젯이나 객체는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="bbf840b78cf5d577c6dec511cee778888c58ba17" translate="yes" xml:space="preserve">
          <source>Note that there are possible values for</source>
          <target state="translated">가능한 값이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e9d9da1d14088b53e7993ba2c54584dcea7c551c" translate="yes" xml:space="preserve">
          <source>Note that there is a special case logic to prevent the generic plugin's backends from becoming the default when another backend is registered for the same type. This logic means that a backend identifier starting with &lt;code&gt;generic.&lt;/code&gt; will only be the default if no other backends have been registered for that type, or if it is specified in &lt;code&gt;Sensors.conf&lt;/code&gt;.</source>
          <target state="translated">다른 유형의 백엔드가 동일한 유형으로 등록 될 때 일반 플러그인의 백엔드가 기본값이되지 않도록하는 특별한 경우 논리가 있습니다. 이 논리는 백엔드 식별자가 &lt;code&gt;generic.&lt;/code&gt; 시작 함을 의미합니다 . 해당 유형에 대해 다른 백엔드가 등록되지 않았거나 &lt;code&gt;Sensors.conf&lt;/code&gt; 에 지정된 경우에만 기본값이됩니다 .</target>
        </trans-unit>
        <trans-unit id="040a29552119cd4cad1314620902431dc83dbc59" translate="yes" xml:space="preserve">
          <source>Note that there is an asymmetry in this library. &lt;a href=&quot;qxmlnamespacesupport#prefix&quot;&gt;prefix&lt;/a&gt;() does not return the default &quot;&quot; prefix, even if you have declared one; to check for a default prefix, you must look it up explicitly using &lt;a href=&quot;qxmlnamespacesupport#uri&quot;&gt;uri&lt;/a&gt;(). This asymmetry exists to make it easier to look up prefixes for attribute names, where the default prefix is not allowed.</source>
          <target state="translated">이 라이브러리에는 비대칭 성이 있습니다. &lt;a href=&quot;qxmlnamespacesupport#prefix&quot;&gt;접두사&lt;/a&gt; ()는 선언 한 경우에도 기본 &quot;&quot;접두사를 반환하지 않습니다. 기본 접두사를 확인하려면 &lt;a href=&quot;qxmlnamespacesupport#uri&quot;&gt;uri&lt;/a&gt; ()를 사용하여 명시 적으로 접두사를 찾아야합니다 . 이 비대칭 성은 기본 접두사가 허용되지 않는 속성 이름의 접 두부를 더 쉽게 찾을 수 있도록하기 위해 존재합니다.</target>
        </trans-unit>
        <trans-unit id="ab5d05366d3d76fb582263c6b34890c1e2011c83" translate="yes" xml:space="preserve">
          <source>Note that there is no mechanism to determine the current data rate in use by the platform.</source>
          <target state="translated">플랫폼에서 사용중인 현재 데이터 속도를 결정하는 메커니즘은 없습니다.</target>
        </trans-unit>
        <trans-unit id="1703c5e411e4055ec09accb43105e8d975198ad6" translate="yes" xml:space="preserve">
          <source>Note that there is no mechanism to determine the current output range in use by the platform.</source>
          <target state="translated">플랫폼에서 사용중인 현재 출력 범위를 결정하는 메커니즘은 없습니다.</target>
        </trans-unit>
        <trans-unit id="3adee1deacd618bc3819337df64f810b69c38e0a" translate="yes" xml:space="preserve">
          <source>Note that there is special case logic to prevent the generic plugin's backends from becoming the default when another backend is registered for the same type. This logic means that a backend identifier starting with &lt;code&gt;generic.&lt;/code&gt; will only be the default if no other backends have been registered for that type or if it is specified in &lt;code&gt;Sensors.conf&lt;/code&gt;.</source>
          <target state="translated">다른 유형의 백엔드가 동일한 유형으로 등록 될 때 일반 플러그인의 백엔드가 기본값이되는 것을 방지하는 특수한 경우 논리가 있습니다. 이 논리는 백엔드 식별자가 &lt;code&gt;generic.&lt;/code&gt; 시작 함을 의미합니다 . 해당 유형에 대해 다른 백엔드가 등록되지 않았거나 &lt;code&gt;Sensors.conf&lt;/code&gt; 에 지정된 경우에만 기본값이됩니다 .</target>
        </trans-unit>
        <trans-unit id="79d0f0e4783ad3fa291caf8291d621303898f0a1" translate="yes" xml:space="preserve">
          <source>Note that these functions will return &lt;code&gt;null&lt;/code&gt; when called inside the constructor of a &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; subclass, as the instance will not yet have a context nor engine.</source>
          <target state="translated">인스턴스에는 컨텍스트 나 엔진이 없기 때문에 &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 서브 클래스 의 생성자 내에서 호출 될 때 이러한 함수는 &lt;code&gt;null&lt;/code&gt; 을 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="07878035598a9016511532cb680fc098a0c1d6b8" translate="yes" xml:space="preserve">
          <source>Note that these only constrain the date time edit's value on, respectively, the &lt;a href=&quot;qdatetimeedit#minimumDate-prop&quot;&gt;minimumDate&lt;/a&gt; and &lt;a href=&quot;qdatetimeedit#maximumDate-prop&quot;&gt;maximumDate&lt;/a&gt;. When these date properties do not coincide, times after</source>
          <target state="translated">이것들은 각각 &lt;a href=&quot;qdatetimeedit#minimumDate-prop&quot;&gt;minimumDate&lt;/a&gt; 및 &lt;a href=&quot;qdatetimeedit#maximumDate-prop&quot;&gt;maximumDate&lt;/a&gt; 에 대한 날짜 시간 편집 값만 제한합니다 . 이러한 날짜 속성이 일치하지 않으면</target>
        </trans-unit>
        <trans-unit id="6d51ddedcb2b26cc5b208f16c00100bcab7420d0" translate="yes" xml:space="preserve">
          <source>Note that these three cases represent exactly the possible states of a &lt;a href=&quot;qvalidator&quot;&gt;QValidator&lt;/a&gt; (see the &lt;a href=&quot;qvalidator#State-enum&quot;&gt;QValidator::State&lt;/a&gt; enum).</source>
          <target state="translated">이 세 가지 경우는 &lt;a href=&quot;qvalidator&quot;&gt;QValidator&lt;/a&gt; 의 가능한 가능한 상태를 나타냅니다 ( &lt;a href=&quot;qvalidator#State-enum&quot;&gt;QValidator :: State&lt;/a&gt; 열거 형 참조).</target>
        </trans-unit>
        <trans-unit id="19d3a179d0e97d72ebe002047be0c91013cb006d" translate="yes" xml:space="preserve">
          <source>Note that these values are provided purely for convenience, since event priorities can be any value between &lt;code&gt;INT_MAX&lt;/code&gt; and &lt;code&gt;INT_MIN&lt;/code&gt;, inclusive. For example, you can define custom priorities as being relative to each other:</source>
          <target state="translated">이벤트 우선 순위는 &lt;code&gt;INT_MAX&lt;/code&gt; ~ &lt;code&gt;INT_MIN&lt;/code&gt; 사이의 값이 될 수 있으므로 편의상 순전히 이러한 값이 제공됩니다 . 예를 들어, 사용자 지정 우선 순위를 서로에 대해 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba5dc00358b33ffe2140d0c00f74b4e08ad8f3f7" translate="yes" xml:space="preserve">
          <source>Note that this API is not currently supported on Android.</source>
          <target state="translated">이 API는 현재 Android에서 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1180934ec881d0b0c75a8e65afa410b2d9b114e4" translate="yes" xml:space="preserve">
          <source>Note that this call is asynchronous. Depending on the outcome of this call the results can be enquired by connecting to the &lt;a href=&quot;qnetworksession#stateChanged&quot;&gt;stateChanged&lt;/a&gt;(), &lt;a href=&quot;qnetworksession#opened&quot;&gt;opened&lt;/a&gt;() or &lt;a href=&quot;qnetworksession#error&quot;&gt;error&lt;/a&gt;() signals.</source>
          <target state="translated">이 호출은 비동기 적입니다. 이 호출의 결과에 따라 &lt;a href=&quot;qnetworksession#stateChanged&quot;&gt;stateChanged&lt;/a&gt; (), &lt;a href=&quot;qnetworksession#opened&quot;&gt;open&lt;/a&gt; () 또는 &lt;a href=&quot;qnetworksession#error&quot;&gt;error&lt;/a&gt; () 신호 에 연결하여 결과를 조회 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7b25cfa6ac2f78e340887d2e69f901eedca52828" translate="yes" xml:space="preserve">
          <source>Note that this class inherits most of its functionality from &lt;a href=&quot;qdropevent&quot;&gt;QDropEvent&lt;/a&gt;.</source>
          <target state="translated">이 클래스는 대부분의 기능을 &lt;a href=&quot;qdropevent&quot;&gt;QDropEvent&lt;/a&gt; 에서 상속 합니다.</target>
        </trans-unit>
        <trans-unit id="34d9544f580bd42fbef7297cb803b1e866df8173" translate="yes" xml:space="preserve">
          <source>Note that this class is now deprecated, please use &lt;a href=&quot;qxmlstreamreader&quot;&gt;QXmlStreamReader&lt;/a&gt; or &lt;a href=&quot;qdomdocument&quot;&gt;QDomDocument&lt;/a&gt; for reading XML files.</source>
          <target state="translated">이 클래스는 이제 더 이상 사용되지 않습니다 . XML 파일을 읽으 려면 &lt;a href=&quot;qxmlstreamreader&quot;&gt;QXmlStreamReader&lt;/a&gt; 또는 &lt;a href=&quot;qdomdocument&quot;&gt;QDomDocument&lt;/a&gt; 를 사용 하십시오.</target>
        </trans-unit>
        <trans-unit id="b81cd2da92ef6a6ef437466a95cf862af9013644" translate="yes" xml:space="preserve">
          <source>Note that this class is now deprecated, please use &lt;a href=&quot;qxmlstreamreader&quot;&gt;QXmlStreamReader&lt;/a&gt; or QDomDocument for reading XML files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16e16dea450e21ea3a9459466570c16f0c854507" translate="yes" xml:space="preserve">
          <source>Note that this constructor is invoked automatically by the &lt;a href=&quot;#Q_PLUGIN_METADATA&quot;&gt;Q_PLUGIN_METADATA&lt;/a&gt;() macro, so there is no need for calling it explicitly.</source>
          <target state="translated">이 생성자는 &lt;a href=&quot;#Q_PLUGIN_METADATA&quot;&gt;Q_PLUGIN_METADATA&lt;/a&gt; () 매크로에 의해 자동으로 호출되므로 명시 적으로 호출 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="c12e45965477a475136d53963ca8f444b7dd36af" translate="yes" xml:space="preserve">
          <source>Note that this constructor is invoked automatically by the &lt;a href=&quot;qtplugin#Q_PLUGIN_METADATA&quot;&gt;Q_PLUGIN_METADATA&lt;/a&gt;() macro, so there is no need for calling it explicitly.</source>
          <target state="translated">이 생성자는 &lt;a href=&quot;qtplugin#Q_PLUGIN_METADATA&quot;&gt;Q_PLUGIN_METADATA&lt;/a&gt; () 매크로에 의해 자동으로 호출되므로 명시 적으로 호출 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="48320daa59d0c8c35465d1e2bf527da51843314d" translate="yes" xml:space="preserve">
          <source>Note that this constructor is invoked automatically by the moc generated code that exports the plugin, so there is no need for calling it explicitly.</source>
          <target state="translated">이 생성자는 플러그인을 내보내는 moc 생성 코드에 의해 자동으로 호출되므로 명시 적으로 호출 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="3eab9e92074ecc51add1bc1d7e7602ccd9f50f4c" translate="yes" xml:space="preserve">
          <source>Note that this does</source>
          <target state="translated">이것은</target>
        </trans-unit>
        <trans-unit id="e0486c4ac66735844ef62dfd0b729e08407e7815" translate="yes" xml:space="preserve">
          <source>Note that this does not apply when there are no other widgets underneath and the intention is to have a semi-transparent window. In that case the traditional approach of setting &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt::WA_TranslucentBackground&lt;/a&gt; on the top-level window is sufficient. Note that if the transparent areas are only desired in the &lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt;, then &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt::WA_NoSystemBackground&lt;/a&gt; will need to be turned back to &lt;code&gt;false&lt;/code&gt; after enabling &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt::WA_TranslucentBackground&lt;/a&gt;. Additionally, requesting an alpha channel for the &lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt;'s context via &lt;a href=&quot;qopenglwidget#setFormat&quot;&gt;setFormat&lt;/a&gt;() may be necessary too, depending on the system.</source>
          <target state="translated">아래에 다른 위젯이없고 반투명 창이있는 경우에는 적용되지 않습니다. 이 경우 최상위 창에서 &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt :: WA_TranslucentBackground&lt;/a&gt; 를 설정하는 전통적인 접근 방식으로 충분합니다. 투명 영역이 &lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt; 에서만 필요한 경우 &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt :: WA_TranslucentBackground&lt;/a&gt; 를 활성화 한 후 &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt :: WA_NoSystemBackground&lt;/a&gt; 를 &lt;code&gt;false&lt;/code&gt; 로 다시 설정해야합니다 . 또한 시스템에 따라 &lt;a href=&quot;qopenglwidget#setFormat&quot;&gt;setFormat&lt;/a&gt; ()을 통해 &lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt; 의 컨텍스트에 대한 알파 채널을 요청 해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e17003ba80fcd86e8fabc32bf154112d58887d80" translate="yes" xml:space="preserve">
          <source>Note that this does not apply when there are no other widgets underneath and the intention is to have a semi-transparent window. In that case the traditional approach of setting &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt::WA_TranslucentBackground&lt;/a&gt; on the top-level window is sufficient. Note that if the transparent areas are only desired in the QOpenGLWidget, then &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt::WA_NoSystemBackground&lt;/a&gt; will need to be turned back to &lt;code&gt;false&lt;/code&gt; after enabling &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt::WA_TranslucentBackground&lt;/a&gt;. Additionally, requesting an alpha channel for the QOpenGLWidget's context via &lt;a href=&quot;qopenglwidget#setFormat&quot;&gt;setFormat&lt;/a&gt;() may be necessary too, depending on the system.</source>
          <target state="translated">아래에 다른 위젯이없고 반투명 창을 사용하려는 경우에는 적용되지 않습니다. 이 경우 최상위 창에서 &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt :: WA_TranslucentBackground&lt;/a&gt; 를 설정하는 기존 방식으로 충분합니다. 투명 영역이 QOpenGLWidget에서만 필요한 경우 &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt :: WA_TranslucentBackground&lt;/a&gt; 를 활성화 한 후 &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt :: WA_NoSystemBackground&lt;/a&gt; 를 &lt;code&gt;false&lt;/code&gt; 로 되돌려 야 합니다. 또한 시스템에 따라 &lt;a href=&quot;qopenglwidget#setFormat&quot;&gt;setFormat&lt;/a&gt; ()을 통해 QOpenGLWidget의 컨텍스트에 대한 알파 채널을 요청 해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b4c42a7dedafafb800b4d16b17b6781de925e1c" translate="yes" xml:space="preserve">
          <source>Note that this does not count properties declared in &lt;a href=&quot;qsensorreading&quot;&gt;QSensorReading&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qsensorreading&quot;&gt;QSensorReading에&lt;/a&gt; 선언 된 특성은 계산되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="9011bff3358b4574e345149dcfa05059d63c5b55" translate="yes" xml:space="preserve">
          <source>Note that this effect can be slow if the region is particularly complex.</source>
          <target state="translated">영역이 특히 복잡한 경우이 효과가 느려질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c9893d988f6e0623f8297b23485e1a94e9cd0847" translate="yes" xml:space="preserve">
          <source>Note that this equivalent to accessing the row directly through the &lt;a href=&quot;qml-qt-labs-qmlmodels-tablemodel#rows-prop&quot;&gt;rows&lt;/a&gt; property:</source>
          <target state="translated">이는 &lt;a href=&quot;qml-qt-labs-qmlmodels-tablemodel#rows-prop&quot;&gt;rows&lt;/a&gt; 속성을 통해 직접 행에 액세스하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="eeca50a1ac969028e42f22bc735cdf14bff03152" translate="yes" xml:space="preserve">
          <source>Note that this flag must be set before calling &lt;a href=&quot;qthreadpool#start&quot;&gt;QThreadPool::start&lt;/a&gt;(). Calling this function after &lt;a href=&quot;qthreadpool#start&quot;&gt;QThreadPool::start&lt;/a&gt;() results in undefined behavior.</source>
          <target state="translated">&lt;a href=&quot;qthreadpool#start&quot;&gt;QThreadPool :: start&lt;/a&gt; ()를 호출하기 전에이 플래그를 설정해야합니다 . &lt;a href=&quot;qthreadpool#start&quot;&gt;QThreadPool :: start&lt;/a&gt; () 이후에이 함수를 호출하면 정의되지 않은 동작이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8c04c9e9b885d198d00eed994ce04031cd282ebc" translate="yes" xml:space="preserve">
          <source>Note that this function can be very slow if the font is large.</source>
          <target state="translated">글꼴이 크면이 기능이 매우 느려질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="82458d2bce322e91c2cd0fa1a38df6706ff8f0a1" translate="yes" xml:space="preserve">
          <source>Note that this function cannot be used to modify values in the database since the model is read-only.</source>
          <target state="translated">모델이 읽기 전용이므로이 함수를 사용하여 데이터베이스의 값을 수정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="89edc73131f01c788f424a3d261c18746067ceda" translate="yes" xml:space="preserve">
          <source>Note that this function cannot be used to obtain values in the full 32-bit range of int. Instead, use &lt;a href=&quot;qrandomgenerator#generate&quot;&gt;generate&lt;/a&gt;() and cast to int.</source>
          <target state="translated">이 함수는 전체 32 비트 범위의 int 값을 얻는 데 사용할 수 없습니다. 대신 &lt;a href=&quot;qrandomgenerator#generate&quot;&gt;generate&lt;/a&gt; ()를 사용 하고 int로 캐스트하십시오.</target>
        </trans-unit>
        <trans-unit id="9f0c9335fe7c72f0cee24568b05e244f2cecdac4" translate="yes" xml:space="preserve">
          <source>Note that this function cannot be used to obtain values in the full 32-bit range of quint32. Instead, use &lt;a href=&quot;qrandomgenerator#generate&quot;&gt;generate&lt;/a&gt;().</source>
          <target state="translated">이 함수는 quint32의 전체 32 비트 범위에서 값을 얻는 데 사용할 수 없습니다. 대신 &lt;a href=&quot;qrandomgenerator#generate&quot;&gt;generate&lt;/a&gt; ()를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="2e7093d0650ae737ec02940f129e6e001ace2696" translate="yes" xml:space="preserve">
          <source>Note that this function cannot be used to obtain values in the full 64-bit range of &lt;code&gt;qint64&lt;/code&gt;. Instead, use &lt;a href=&quot;qrandomgenerator#generate64&quot;&gt;generate64&lt;/a&gt;() and cast to qint64 or instead use the unsigned version of this function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe82d3c23c84bed4013a4f33599304d51e57fe4c" translate="yes" xml:space="preserve">
          <source>Note that this function cannot be used to obtain values in the full 64-bit range of &lt;code&gt;qint64&lt;/code&gt;. Instead, use &lt;a href=&quot;qrandomgenerator#generate64&quot;&gt;generate64&lt;/a&gt;() and cast to qint64.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65ae616e489d5ba9400d5b167d4d8923492dc7e5" translate="yes" xml:space="preserve">
          <source>Note that this function cannot be used to obtain values in the full 64-bit range of &lt;code&gt;quint64&lt;/code&gt;. Instead, use &lt;a href=&quot;qrandomgenerator#generate64&quot;&gt;generate64&lt;/a&gt;().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="957250e6baf69685d666ab5fa364aabd5426b77b" translate="yes" xml:space="preserve">
          <source>Note that this function checks whether the item's shape or bounding rectangle (depending on</source>
          <target state="translated">이 함수는 항목의 모양 또는 경계 사각형을 확인합니다 (</target>
        </trans-unit>
        <trans-unit id="083615ca02fe431778303ad8c6d3377f25091a00" translate="yes" xml:space="preserve">
          <source>Note that this function connects the starting point of the arc to the current position if they are not already connected. After the arc has been added, the current position is the last point in arc. To draw a line back to the first point, use the &lt;a href=&quot;qpainterpath#closeSubpath&quot;&gt;closeSubpath&lt;/a&gt;() function.</source>
          <target state="translated">이 기능은 호의 시작점을 아직 연결하지 않은 경우 현재 위치에 연결합니다. 호가 추가 된 후 현재 위치는 호의 마지막 점입니다. 첫 번째 점으로 선을 다시 그리려면 &lt;a href=&quot;qpainterpath#closeSubpath&quot;&gt;closeSubpath&lt;/a&gt; () 함수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="c6bc07180f3d884a3b1da0f0161da6d872740f4a" translate="yes" xml:space="preserve">
          <source>Note that this function considers URLs with hostnames to be local file paths, even if the eventual file path cannot be opened with &lt;a href=&quot;qfile#open&quot;&gt;QFile::open&lt;/a&gt;().</source>
          <target state="translated">이 함수는 최종 파일 경로를 &lt;a href=&quot;qfile#open&quot;&gt;QFile :: open&lt;/a&gt; () 으로 열 수없는 경우에도 호스트 이름이있는 URL을 로컬 파일 경로로 간주합니다 .</target>
        </trans-unit>
        <trans-unit id="af00839828c1d89382e64d5758333deb9b7bbafb" translate="yes" xml:space="preserve">
          <source>Note that this function considers a TLD to be any domain that allows users to register subdomains under, including many home, dynamic DNS websites and blogging providers. This is useful for determining whether two websites belong to the same infrastructure and communication should be allowed, such as browser cookies: two domains should be considered part of the same website if they share at least one label in addition to the value returned by this function.</source>
          <target state="translated">이 기능은 TLD를 사용자가 많은 홈, 동적 DNS 웹 사이트 및 블로그 제공자를 포함하여 하위 도메인을 등록 할 수있는 임의의 도메인으로 간주합니다. 이 기능은 브라우저 쿠키와 같이 두 개의 웹 사이트가 동일한 인프라에 속하고 통신이 허용되어야하는지 여부를 결정하는 데 유용합니다.이 기능에서 반환 된 값 외에 하나 이상의 레이블을 공유하는 두 도메인은 동일한 웹 사이트의 일부로 간주되어야합니다. .</target>
        </trans-unit>
        <trans-unit id="4a291c967e99485f2b8faf0cde5d8593e5b03b30" translate="yes" xml:space="preserve">
          <source>Note that this function disregards the alpha buffer.</source>
          <target state="translated">이 함수는 알파 버퍼를 무시합니다.</target>
        </trans-unit>
        <trans-unit id="fa65d225bcb30ebd19ec0f94b22dc45327203c89" translate="yes" xml:space="preserve">
          <source>Note that this function does</source>
          <target state="translated">이 기능은</target>
        </trans-unit>
        <trans-unit id="141c9befa85e2763711c49d0174fd625dee24d90" translate="yes" xml:space="preserve">
          <source>Note that this function does not bind the local address of the socket prior to a connection (e.g., &lt;a href=&quot;qabstractsocket#bind&quot;&gt;QAbstractSocket::bind&lt;/a&gt;()).</source>
          <target state="translated">이 함수는 연결 전에 소켓의 로컬 주소를 바인딩하지 않습니다 (예 : &lt;a href=&quot;qabstractsocket#bind&quot;&gt;QAbstractSocket :: bind&lt;/a&gt; ()).</target>
        </trans-unit>
        <trans-unit id="63d1e9654b70ab89e9680818d98d2c751060c069" translate="yes" xml:space="preserve">
          <source>Note that this function does not bind the local port of the socket prior to a connection (e.g., &lt;a href=&quot;qabstractsocket#bind&quot;&gt;QAbstractSocket::bind&lt;/a&gt;()).</source>
          <target state="translated">이 함수는 연결 전에 소켓의 로컬 포트를 바인딩하지 않습니다 (예 : &lt;a href=&quot;qabstractsocket#bind&quot;&gt;QAbstractSocket :: bind&lt;/a&gt; ()).</target>
        </trans-unit>
        <trans-unit id="45af50554875dd7af66a2ec1c6f3b868d3896ecb" translate="yes" xml:space="preserve">
          <source>Note that this function does not change the current index. Since the current index defines the next and previous items to edit, users may find that keyboard navigation does not work as expected. To provide consistent navigation behavior, call &lt;a href=&quot;qabstractitemview#setCurrentIndex&quot;&gt;setCurrentIndex&lt;/a&gt;() before this function with the same model index.</source>
          <target state="translated">이 함수는 현재 색인을 변경하지 않습니다. 현재 색인은 편집 할 다음 및 이전 항목을 정의하므로 사용자는 키보드 탐색이 예상대로 작동하지 않을 수 있습니다. 일관된 탐색 동작을 제공하려면 동일한 모델 인덱스로이 함수 전에 &lt;a href=&quot;qabstractitemview#setCurrentIndex&quot;&gt;setCurrentIndex&lt;/a&gt; ()를 호출 하십시오.</target>
        </trans-unit>
        <trans-unit id="bd5a489f2665d05dd4608f9b9a342e038266136a" translate="yes" xml:space="preserve">
          <source>Note that this function does not perform any special validation of the data; it merely checks if it can be successfully decoded from UTF-16. The data is assumed to be in host byte order; the presence of a BOM is meaningless.</source>
          <target state="translated">이 함수는 데이터에 대한 특별한 유효성 검사를 수행하지 않습니다. 단지 UTF-16에서 성공적으로 디코딩 될 수 있는지 확인합니다. 데이터는 호스트 바이트 순서로 가정됩니다. BOM의 존재는 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="d22ca7e08db6ea85a02dbc7584614f6957705092" translate="yes" xml:space="preserve">
          <source>Note that this function does not return true for an IPv4 network's local broadcast address. For that, please use &lt;a href=&quot;qnetworkinterface&quot;&gt;QNetworkInterface&lt;/a&gt; to obtain the broadcast addresses of the local machine.</source>
          <target state="translated">이 기능은 IPv4 네트워크의 로컬 브로드 캐스트 주소에 대해서는 true를 반환하지 않습니다. 이를 위해 &lt;a href=&quot;qnetworkinterface&quot;&gt;QNetworkInterface&lt;/a&gt; 를 사용 하여 로컬 시스템의 브로드 캐스트 주소를 얻으십시오.</target>
        </trans-unit>
        <trans-unit id="e59a935531d25e7510f0c229964cf4a4bff7d177" translate="yes" xml:space="preserve">
          <source>Note that this function does not return true if you are using the sensor, only if another process is using the sensor.</source>
          <target state="translated">센서를 사용하는 경우 다른 프로세스가 센서를 사용하는 경우에만이 기능이 true를 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="057d0792d9dffb7b54781b3e501e9e7dfd8fc2f4" translate="yes" xml:space="preserve">
          <source>Note that this function does not set</source>
          <target state="translated">이 기능은 설정되지 않습니다</target>
        </trans-unit>
        <trans-unit id="4c045f64ac550e95cb13ef786ecd91b62233eb5f" translate="yes" xml:space="preserve">
          <source>Note that this function is frequently called by &lt;a href=&quot;qtreeview&quot;&gt;QTreeView&lt;/a&gt; and &lt;a href=&quot;qtableview&quot;&gt;QTableView&lt;/a&gt;, so margins must be implemented by &lt;a href=&quot;qabstractscrollarea&quot;&gt;QAbstractScrollArea&lt;/a&gt; subclasses. Also, if the subclasses are to be used in item views, they should not call this function.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;qtreeview&quot;&gt;QTreeView&lt;/a&gt; 및 &lt;a href=&quot;qtableview&quot;&gt;QTableView에&lt;/a&gt; 의해 자주 호출 되므로 마진은 &lt;a href=&quot;qabstractscrollarea&quot;&gt;QAbstractScrollArea&lt;/a&gt; 서브 클래스에 의해 구현되어야합니다 . 또한 서브 클래스가 항목보기에서 사용되는 경우이 함수를 호출하면 안됩니다.</target>
        </trans-unit>
        <trans-unit id="cc0f4f6c5905883cd85a0a9d47e0f19bd54998af" translate="yes" xml:space="preserve">
          <source>Note that this function is slow for images without color table.</source>
          <target state="translated">컬러 테이블이없는 이미지의 경우이 기능이 느려집니다.</target>
        </trans-unit>
        <trans-unit id="49e78598f78ed7d80ead976d700f5244342869a0" translate="yes" xml:space="preserve">
          <source>Note that this function is slower than calling the data function directly.</source>
          <target state="translated">이 함수는 데이터 함수를 직접 호출하는 것보다 느립니다.</target>
        </trans-unit>
        <trans-unit id="bc43af52d64ebd219d03ba6583dc4236dfb6951b" translate="yes" xml:space="preserve">
          <source>Note that this function is usually faster than calling &lt;a href=&quot;qitemselectionmodel#isSelected&quot;&gt;isSelected&lt;/a&gt;() on all items in the same column and that unselectable items are ignored.</source>
          <target state="translated">이 함수는 일반적으로 같은 열의 모든 항목에서 &lt;a href=&quot;qitemselectionmodel#isSelected&quot;&gt;isSelected&lt;/a&gt; ()를 호출하는 것보다 빠르며 선택할 수없는 항목은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="6f8de48235a7a14b697ba38a7ebfd050c2d9566b" translate="yes" xml:space="preserve">
          <source>Note that this function is usually faster than calling &lt;a href=&quot;qitemselectionmodel#isSelected&quot;&gt;isSelected&lt;/a&gt;() on all items in the same row and that unselectable items are ignored.</source>
          <target state="translated">이 함수는 일반적으로 같은 행의 모든 ​​항목에서 &lt;a href=&quot;qitemselectionmodel#isSelected&quot;&gt;isSelected&lt;/a&gt; ()를 호출하는 것보다 빠르며 선택할 수없는 항목은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="53cc6c6ab192e1f99f895008a634225b164961db" translate="yes" xml:space="preserve">
          <source>Note that this function is usually faster than calling &lt;a href=&quot;qml-qtqml-models-itemselectionmodel#isSelected-method&quot;&gt;isSelected()&lt;/a&gt; on all items in the same column, and that unselectable items are ignored.</source>
          <target state="translated">이 함수는 일반적으로 같은 열의 모든 항목에서 &lt;a href=&quot;qml-qtqml-models-itemselectionmodel#isSelected-method&quot;&gt;isSelected ()&lt;/a&gt; 를 호출하는 것보다 빠르며 선택할 수없는 항목은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="8d606da5028cb9a03bb5f3c30784d41fd26a101f" translate="yes" xml:space="preserve">
          <source>Note that this function is usually faster than calling &lt;a href=&quot;qml-qtqml-models-itemselectionmodel#isSelected-method&quot;&gt;isSelected()&lt;/a&gt; on all items in the same row, and that unselectable items are ignored.</source>
          <target state="translated">이 함수는 일반적으로 같은 행의 모든 ​​항목에서 &lt;a href=&quot;qml-qtqml-models-itemselectionmodel#isSelected-method&quot;&gt;isSelected ()&lt;/a&gt; 를 호출하는 것보다 빠르며 선택할 수없는 항목은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="70f63da4a9d9cf58667b6a462ae1c2ef51d57231" translate="yes" xml:space="preserve">
          <source>Note that this function must be called before &lt;a href=&quot;qaxbase#control-prop&quot;&gt;setControl&lt;/a&gt;() to have any effect.</source>
          <target state="translated">&lt;a href=&quot;qaxbase#control-prop&quot;&gt;setControl&lt;/a&gt; () 전에이 함수를 호출해야 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b38da33bd7eff723801bbfd876341bd1b87a8da9" translate="yes" xml:space="preserve">
          <source>Note that this function must be called from the constructor.</source>
          <target state="translated">이 함수는 생성자에서 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="447378543cc02dd5686056ff3d322fef507f63b4" translate="yes" xml:space="preserve">
          <source>Note that this function must be called immediately after construction of the object</source>
          <target state="translated">이 함수는 객체를 생성 한 직후에 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="54d852496abfc649a22c7004518952bec33b922b" translate="yes" xml:space="preserve">
          <source>Note that this function must be called immediately after construction of the object.</source>
          <target state="translated">이 함수는 객체를 생성 한 직후에 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="5137f228aead599d21cbad86c66c22ef1010b098" translate="yes" xml:space="preserve">
          <source>Note that this function must be called or you will not be able to send readings to the front end.</source>
          <target state="translated">이 기능을 호출해야합니다. 그렇지 않으면 프런트 엔드에 판독 값을 보낼 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="8bf37ee82496c2730e2cd5f4bbf7c93b8b7ba862" translate="yes" xml:space="preserve">
          <source>Note that this function only changes state if you call &lt;a href=&quot;qdbuspendingcallwatcher#waitForFinished&quot;&gt;waitForFinished&lt;/a&gt;() or if an external D-Bus event happens, which in general only happens if you return to the event loop execution.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;qdbuspendingcallwatcher#waitForFinished&quot;&gt;waitForFinished&lt;/a&gt; () 를 호출 하거나 외부 D-Bus 이벤트가 발생하는 경우에만 상태를 변경 합니다. 일반적으로 이벤트 루프 실행으로 돌아가는 경우에만 발생합니다.</target>
        </trans-unit>
        <trans-unit id="822df7195b9b0b3600d3c5809e63c294e814391a" translate="yes" xml:space="preserve">
          <source>Note that this function only changes state if you call &lt;a href=&quot;qdbuspendingreply#waitForFinished&quot;&gt;waitForFinished&lt;/a&gt;() or if an external D-Bus event happens, which in general only happens if you return to the event loop execution.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;qdbuspendingreply#waitForFinished&quot;&gt;waitForFinished&lt;/a&gt; () 를 호출 하거나 외부 D-Bus 이벤트가 발생하는 경우에만 상태를 변경 합니다. 일반적으로 이벤트 루프 실행으로 돌아가는 경우에만 발생합니다.</target>
        </trans-unit>
        <trans-unit id="54c0430245420f8fb55606425f1892038c44c66c" translate="yes" xml:space="preserve">
          <source>Note that this function only has effect for linear and radial gradients.</source>
          <target state="translated">이 기능은 선형 및 방사형 그래디언트에만 영향을 미칩니다.</target>
        </trans-unit>
        <trans-unit id="e9e6ffc11a6bbabcbf2fb07e4786bd6b30edd48d" translate="yes" xml:space="preserve">
          <source>Note that this function only makes sense in documents without complex objects such as tables or frames.</source>
          <target state="translated">이 기능은 테이블이나 프레임과 같은 복잡한 개체가없는 문서에서만 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="d3a8df00f4930c6c3aaf586a2c74999cc70ae7b0" translate="yes" xml:space="preserve">
          <source>Note that this function performs no conversion from other types to &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt;.</source>
          <target state="translated">이 함수는 다른 유형에서 &lt;a href=&quot;qbytearray&quot;&gt;QByteArray로&lt;/a&gt; 변환하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="ffbeb033e746c08f045dd704479e3fabdf4464c1" translate="yes" xml:space="preserve">
          <source>Note that this function performs no conversion from other types to &lt;a href=&quot;qcborarray&quot;&gt;QCborArray&lt;/a&gt;.</source>
          <target state="translated">이 함수는 다른 유형에서 &lt;a href=&quot;qcborarray&quot;&gt;QCborArray로&lt;/a&gt; 변환하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="2987e8c3215482d97452eefda289082f350c2209" translate="yes" xml:space="preserve">
          <source>Note that this function performs no conversion from other types to &lt;a href=&quot;qcbormap&quot;&gt;QCborMap&lt;/a&gt;.</source>
          <target state="translated">이 함수는 다른 유형에서 &lt;a href=&quot;qcbormap&quot;&gt;QCborMap으로&lt;/a&gt; 변환하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="9963abd12d14bea702fabc68928b4e049261919e" translate="yes" xml:space="preserve">
          <source>Note that this function performs no conversion from other types to &lt;a href=&quot;qdatetime&quot;&gt;QDateTime&lt;/a&gt;.</source>
          <target state="translated">이 함수는 다른 유형에서 &lt;a href=&quot;qdatetime&quot;&gt;QDateTime으로&lt;/a&gt; 변환하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="3ba5dc24f8d3c66abfc3487a3ace4ce747022589" translate="yes" xml:space="preserve">
          <source>Note that this function performs no conversion from other types to &lt;a href=&quot;qregularexpression&quot;&gt;QRegularExpression&lt;/a&gt;.</source>
          <target state="translated">이 함수는 다른 유형에서 &lt;a href=&quot;qregularexpression&quot;&gt;QRegularExpression으로&lt;/a&gt; 변환하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="50c820531c4b331f4cd429cffeed01c4ec51ae87" translate="yes" xml:space="preserve">
          <source>Note that this function performs no conversion from other types to &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;.</source>
          <target state="translated">이 함수는 다른 유형에서 &lt;a href=&quot;qstring&quot;&gt;QString으로&lt;/a&gt; 변환하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="c3650f85e72a6a1e36fcc99bcf3bbaa0721e2886" translate="yes" xml:space="preserve">
          <source>Note that this function performs no conversion from other types to &lt;a href=&quot;qtcore-changes-qt6#qregularexpression&quot;&gt;QRegularExpression&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2857fe927c06830b76face6ef42288f687e6acd7" translate="yes" xml:space="preserve">
          <source>Note that this function performs no conversion from other types to &lt;a href=&quot;qurl&quot;&gt;QUrl&lt;/a&gt;.</source>
          <target state="translated">이 함수는 다른 유형에서 &lt;a href=&quot;qurl&quot;&gt;QUrl&lt;/a&gt; 로의 변환을 수행하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="5857052c6bf6e66f1d6f53f0f33830a0b30e088f" translate="yes" xml:space="preserve">
          <source>Note that this function performs no conversion from other types to &lt;a href=&quot;quuid&quot;&gt;QUuid&lt;/a&gt;.</source>
          <target state="translated">이 함수는 다른 유형에서 &lt;a href=&quot;quuid&quot;&gt;QUuid&lt;/a&gt; 로의 변환을 수행하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="d95bec0bd2c8dc6c8cad81f09b385de0d88196c7" translate="yes" xml:space="preserve">
          <source>Note that this function replaces the previous values. &lt;a href=&quot;qmatrix&quot;&gt;QMatrix&lt;/a&gt; provide the &lt;a href=&quot;qmatrix#translate&quot;&gt;translate&lt;/a&gt;(), &lt;a href=&quot;qmatrix#rotate&quot;&gt;rotate&lt;/a&gt;(), &lt;a href=&quot;qmatrix#scale&quot;&gt;scale&lt;/a&gt;() and &lt;a href=&quot;qmatrix#shear&quot;&gt;shear&lt;/a&gt;() convenience functions to manipulate the various matrix elements based on the currently defined coordinate system.</source>
          <target state="translated">이 함수는 이전 값을 대체합니다. &lt;a href=&quot;qmatrix&quot;&gt;QMatrix&lt;/a&gt; 는 현재 정의 된 좌표계를 기반으로 다양한 행렬 요소를 조작 할 수있는 &lt;a href=&quot;qmatrix#translate&quot;&gt;변환&lt;/a&gt; (), &lt;a href=&quot;qmatrix#rotate&quot;&gt;회전&lt;/a&gt; (), &lt;a href=&quot;qmatrix#scale&quot;&gt;배율&lt;/a&gt; () 및 &lt;a href=&quot;qmatrix#shear&quot;&gt;전단&lt;/a&gt; () 편의 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="eba4495a7f131de44a4600085c69c301ff65023a" translate="yes" xml:space="preserve">
          <source>Note that this function returns immediately, and therefore may not work if the</source>
          <target state="translated">이 함수는 즉시 반환되므로</target>
        </trans-unit>
        <trans-unit id="e1eff6c5172fe9d07fd526735d5573e2bd79a3b3" translate="yes" xml:space="preserve">
          <source>Note that this function returns the states for all configurations as they are known at the time of this function call. If for instance a configuration of type WLAN is defined the system may have to perform a WLAN scan in order to determine whether it is actually available. To obtain the most accurate state &lt;a href=&quot;qnetworkconfigurationmanager#updateConfigurations&quot;&gt;updateConfigurations&lt;/a&gt;() should be used to update each configuration's state. Note that such an update may require some time. It's completion is signalled by &lt;a href=&quot;qnetworkconfigurationmanager#updateCompleted&quot;&gt;updateCompleted&lt;/a&gt;(). In the absence of a configuration update this function returns the best estimate at the time of the call. Therefore, if WLAN configurations are of interest, it is recommended that &lt;a href=&quot;qnetworkconfigurationmanager#updateConfigurations&quot;&gt;updateConfigurations&lt;/a&gt;() is called once after &lt;a href=&quot;qnetworkconfigurationmanager&quot;&gt;QNetworkConfigurationManager&lt;/a&gt; instantiation (WLAN scans are too time consuming to perform in constructor). After this the data is kept automatically up-to-date as the system reports any changes.</source>
          <target state="translated">이 함수는이 함수 호출시 알려진대로 모든 구성의 상태를 반환합니다. 예를 들어 WLAN 유형의 구성이 정의 된 경우 시스템은 실제로 사용 가능한지 확인하기 위해 WLAN 스캔을 수행해야 할 수도 있습니다. 가장 정확한 상태 얻으려면 &lt;a href=&quot;qnetworkconfigurationmanager#updateConfigurations&quot;&gt;updateConfigurations을&lt;/a&gt; () 각 구성의 상태를 업데이트하는 데 사용되어야한다. 이러한 업데이트에는 다소 시간이 걸릴 수 있습니다. 완료는 &lt;a href=&quot;qnetworkconfigurationmanager#updateCompleted&quot;&gt;updateCompleted&lt;/a&gt; ()에 의해 표시됩니다 . 구성 업데이트가없는 경우이 함수는 통화시 최상의 추정치를 반환합니다. 따라서 WLAN 구성에 관심이있는 경우 &lt;a href=&quot;qnetworkconfigurationmanager&quot;&gt;QNetworkConfigurationManager&lt;/a&gt; 다음에 &lt;a href=&quot;qnetworkconfigurationmanager#updateConfigurations&quot;&gt;updateConfigurations&lt;/a&gt; ()를 한 번 호출 하는 것이 좋습니다.인스턴스화 (WLAN 스캔은 생성자에서 수행하는 데 너무 많은 시간이 걸립니다). 이 후 시스템이 변경 사항을보고함에 따라 데이터가 자동으로 최신 상태로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="61d615f1aef94618c6b62c935a550d7b8803c818" translate="yes" xml:space="preserve">
          <source>Note that this function should be called from the constructor so that the information is available immediately.</source>
          <target state="translated">정보를 즉시 사용할 수 있도록 생성자에서이 함수를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="9fe58e1a23975057e852c22d8374d85738d475f8" translate="yes" xml:space="preserve">
          <source>Note that this function should be called immediately after construction of the object.</source>
          <target state="translated">이 함수는 오브젝트 생성 직후에 호출되어야합니다.</target>
        </trans-unit>
        <trans-unit id="199f4694f60ba4d6a65f15519ec8dcb90f9a4ce5" translate="yes" xml:space="preserve">
          <source>Note that this function should not be called explicitly by the user, since it's meant for reimplementation purposes only. The function is called by Qt internally, and the default implementation may not always return a valid pointer.</source>
          <target state="translated">이 함수는 재 구현 목적으로 만 사용되므로 사용자가 명시 적으로 호출하면 안됩니다. 이 함수는 내부적으로 Qt에 의해 호출되며 기본 구현이 항상 유효한 포인터를 반환하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="e4335eae29ede077ea2c279292d96093c10fc135" translate="yes" xml:space="preserve">
          <source>Note that this function should only be called when the item wants to stop handling further events. There is no need to call this function after a release or cancel event since no future events will be received in any case. No move or release events will be delivered after this function was called.</source>
          <target state="translated">이 함수는 항목이 추가 이벤트 처리를 중지하려는 경우에만 호출해야합니다. 어떤 경우에도 향후 이벤트가 수신되지 않으므로 릴리스 또는 취소 이벤트 후에이 기능을 호출 할 필요가 없습니다. 이 함수가 호출 된 후 이동 또는 해제 이벤트가 전달되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4760c406f66be14439eb6452aefac4fafde58d95" translate="yes" xml:space="preserve">
          <source>Note that this function will lazily create an item for the index (using &lt;a href=&quot;qstandarditemmodel#itemPrototype&quot;&gt;itemPrototype&lt;/a&gt;()), and set it in the parent item's child table, if no item already exists at that index.</source>
          <target state="translated">이 함수는 인덱스에 대한 항목을 느리게 생성하고 ( &lt;a href=&quot;qstandarditemmodel#itemPrototype&quot;&gt;itemPrototype&lt;/a&gt; () 사용) 해당 인덱스에 항목이없는 경우 상위 항목의 자식 테이블에 설정합니다.</target>
        </trans-unit>
        <trans-unit id="bd877185eb4e8cdfd6c8ebf47639900516dfafbf" translate="yes" xml:space="preserve">
          <source>Note that this function will not return until the process is terminated.</source>
          <target state="translated">이 기능은 프로세스가 종료 될 때까지 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4426b1aa6bb3551f8dae2ea65a0077596ce0b206" translate="yes" xml:space="preserve">
          <source>Note that this function, unlike &lt;a href=&quot;qstandarditem#takeRow&quot;&gt;takeRow&lt;/a&gt;() and &lt;a href=&quot;qstandarditem#takeColumn&quot;&gt;takeColumn&lt;/a&gt;(), does not affect the dimensions of the child table.</source>
          <target state="translated">&lt;a href=&quot;qstandarditem#takeRow&quot;&gt;takeRow&lt;/a&gt; () 및 &lt;a href=&quot;qstandarditem#takeColumn&quot;&gt;takeColumn&lt;/a&gt; () 과 달리이 함수 는 자식 테이블의 차원에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="16655533a12f2b63341dce69d7638b419b3e667a" translate="yes" xml:space="preserve">
          <source>Note that this functionality is only available in Qt for Embedded Linux.</source>
          <target state="translated">이 기능은 Embedded Linux 용 Qt에서만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec83ed01a7cb80d0f34f5ba1b11d0baf4ff682c6" translate="yes" xml:space="preserve">
          <source>Note that this gives no indication of whether the character is available in a particular font.</source>
          <target state="translated">이것은 특정 글꼴에서 문자를 사용할 수 있는지 여부를 나타내지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ccbdbea2eafeeb5fcddc3f3c32da52e400e7f8b1" translate="yes" xml:space="preserve">
          <source>Note that this has nothing to do with &lt;a href=&quot;qdatastream#version&quot;&gt;QDataStream::version&lt;/a&gt;().</source>
          <target state="translated">이것은 &lt;a href=&quot;qdatastream#version&quot;&gt;QDataStream :: version&lt;/a&gt; () 과 관련이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="69cf3eab0cffbba8899986854e9d37ed5d2229aa" translate="yes" xml:space="preserve">
          <source>Note that this implicitly adds this graphics item to the scene of the parent. You should not &lt;a href=&quot;qgraphicsscene#addItem&quot;&gt;add&lt;/a&gt; the item to the scene yourself.</source>
          <target state="translated">이렇게하면이 그래픽 항목이 상위 장면에 암시 적으로 추가됩니다. 항목을 장면에 직접 &lt;a href=&quot;qgraphicsscene#addItem&quot;&gt;추가&lt;/a&gt; 해서는 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="d0ea8a2c4a30d8d2a4a9c7a7726808587d58c12d" translate="yes" xml:space="preserve">
          <source>Note that this information is not mandatory as not all sensors have a rate at which they run. In such cases, the list will be empty.</source>
          <target state="translated">모든 센서가 작동 속도를 갖는 것은 아니기 때문에이 정보가 필수는 아닙니다. 이러한 경우 목록이 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec3c7da67cb04f30701e5b4cb700b4b6ab2639a3" translate="yes" xml:space="preserve">
          <source>Note that this information is not mandatory. This information is typically only available for sensors that have selectable output ranges (such as typical accelerometers).</source>
          <target state="translated">이 정보는 필수가 아닙니다. 이 정보는 일반적으로 선택 가능한 출력 범위가있는 센서 (예 : 일반 가속도계)에만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a61b288cfd27d3ace9551d07315b034f18b2e91a" translate="yes" xml:space="preserve">
          <source>Note that this interface includes only those DTD events that the XML recommendation requires processors to report, i.e. notation and unparsed entity declarations using &lt;a href=&quot;qxmldtdhandler#notationDecl&quot;&gt;notationDecl&lt;/a&gt;() and &lt;a href=&quot;qxmldtdhandler#unparsedEntityDecl&quot;&gt;unparsedEntityDecl&lt;/a&gt;() respectively.</source>
          <target state="translated">이 인터페이스에는 XML 권장 사항에서 프로세서가보고해야하는 DTD 이벤트 (예 : &lt;a href=&quot;qxmldtdhandler#notationDecl&quot;&gt;notationDecl&lt;/a&gt; () 및 &lt;a href=&quot;qxmldtdhandler#unparsedEntityDecl&quot;&gt;unparsedEntityDecl&lt;/a&gt; ()를 사용하는 표기법 및 구문 분석되지 않은 엔티티 선언 ) 만 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="cc1cba068eed22b40aac5b628e3eebcf6c19bc5a" translate="yes" xml:space="preserve">
          <source>Note that this is a non-hierarchical model, so we don't have to worry about the parent-child relationships. If our model was hierarchical, we would also have to implement the &lt;a href=&quot;qabstractitemmodel#index&quot;&gt;index()&lt;/a&gt; and &lt;a href=&quot;qabstractitemmodel#parent&quot;&gt;parent()&lt;/a&gt; functions.</source>
          <target state="translated">이것은 비 계층 적 모델이므로 부모-자식 관계에 대해 걱정할 필요가 없습니다. 모델이 계층 적이라면 &lt;a href=&quot;qabstractitemmodel#index&quot;&gt;index ()&lt;/a&gt; 및 &lt;a href=&quot;qabstractitemmodel#parent&quot;&gt;parent ()&lt;/a&gt; 함수 도 구현해야 합니다.</target>
        </trans-unit>
        <trans-unit id="59fbba0d26a249304195a721597a0d19089108dc" translate="yes" xml:space="preserve">
          <source>Note that this is a strict equality, especially for page size where the &lt;a href=&quot;qpagesize&quot;&gt;QPageSize&lt;/a&gt; ID, name and size must exactly match, and the margins where the units must match.</source>
          <target state="translated">이는 특히 &lt;a href=&quot;qpagesize&quot;&gt;QPageSize&lt;/a&gt; ID, 이름 및 크기가 정확히 일치 해야하는 페이지 크기 및 단위가 일치해야하는 여백에 대해 엄격한 평등 입니다.</target>
        </trans-unit>
        <trans-unit id="76e0070e4c3c29abb9dfe8517f9dd92740f9cd6f" translate="yes" xml:space="preserve">
          <source>Note that this is a template function so it should be called with the appropriate type.</source>
          <target state="translated">이것은 템플릿 함수이므로 적절한 유형으로 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="ff329605d834e830b2f08e4d2eba30d0a884f7e6" translate="yes" xml:space="preserve">
          <source>Note that this is not namespace aware. For instance, if this &lt;a href=&quot;qxmlstreamattributes&quot;&gt;QXmlStreamAttributes&lt;/a&gt; contains an attribute whose lexical name is &quot;xlink:href&quot; this doesn't tell that an attribute named &lt;code&gt;href&lt;/code&gt; in the XLink namespace is present, since the &lt;code&gt;xlink&lt;/code&gt; prefix can be bound to any namespace. Use the overload that takes a namespace URI and a local name as parameter, for namespace aware code.</source>
          <target state="translated">이것은 네임 스페이스를 인식하지 않습니다. 예를 들어,이 &lt;a href=&quot;qxmlstreamattributes&quot;&gt;QXmlStreamAttributes&lt;/a&gt; 에 어휘 이름이 &quot;xlink : href&quot;인 속성 이 포함되어 있으면 &lt;code&gt;xlink&lt;/code&gt; 접두어가 모든 네임 스페이스에 바인딩 될 수 있으므로 XLink 네임 스페이스에 &lt;code&gt;href&lt;/code&gt; 라는 속성 이 존재 한다는 것을 나타내지 않습니다 . 네임 스페이스 인식 코드의 경우 네임 스페이스 URI 및 로컬 이름을 매개 변수로 사용하는 오버로드를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="56abcf1f90a668cdf6c04c1288695aa4169a6ade" translate="yes" xml:space="preserve">
          <source>Note that this is the column number relative to a wrapped line, not relative to the block (i.e. the paragraph).</source>
          <target state="translated">이것은 블록 (즉, 단락)에 대한 것이 아니라 줄 바꿈 된 행에 대한 열 번호입니다.</target>
        </trans-unit>
        <trans-unit id="9fb2b9c4ae649e208ea990cd69b40a5d9372e8dc" translate="yes" xml:space="preserve">
          <source>Note that this item is not a visual representation of a gradient. To display a gradient, use a visual item (like &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt;) which supports the use of gradients.</source>
          <target state="translated">이 항목은 그라디언트의 시각적 표현이 아닙니다. 그라디언트를 표시하려면 그라디언트 사용을 지원하는 시각적 항목 (예 : &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt; )을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c4871718f2fb7ad6e203d22311a1271557d57e43" translate="yes" xml:space="preserve">
          <source>Note that this list is not localized. For a localized representation re-implement &lt;a href=&quot;qaccessibleactioninterface#localizedActionName&quot;&gt;localizedActionName&lt;/a&gt;() and &lt;a href=&quot;qaccessibleactioninterface#localizedActionDescription&quot;&gt;localizedActionDescription&lt;/a&gt;()</source>
          <target state="translated">이 목록은 현지화되지 않았습니다. 현지화 된 표현의 경우 &lt;a href=&quot;qaccessibleactioninterface#localizedActionName&quot;&gt;localizedActionName&lt;/a&gt; () 및 &lt;a href=&quot;qaccessibleactioninterface#localizedActionDescription&quot;&gt;localizedActionDescription&lt;/a&gt; ()을 다시 구현하십시오.</target>
        </trans-unit>
        <trans-unit id="90d4c55792121b5e05cfba2c2ad94424362ebefc" translate="yes" xml:space="preserve">
          <source>Note that this macro is only available if using &lt;code&gt;CMake&lt;/code&gt; 2.8.9 or later. This macro is obsolete. Use target_link_libraries with IMPORTED targets instead.</source>
          <target state="translated">이 매크로는 &lt;code&gt;CMake&lt;/code&gt; 2.8.9 이상을 사용하는 경우에만 사용할 수 있습니다 . 이 매크로는 더 이상 사용되지 않습니다. 대신 IMPORTED 대상과 함께 target_link_libraries를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="9a8f10f676bb7036f0180d8d0cb0923380805a54" translate="yes" xml:space="preserve">
          <source>Note that this macro is only available if using &lt;code&gt;CMake&lt;/code&gt; 3.9 or later.</source>
          <target state="translated">이 매크로는 &lt;code&gt;CMake&lt;/code&gt; 3.9 이상을 사용하는 경우에만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0b9ddd4ba220faf72039d76e7bf47e2aebfd11e1" translate="yes" xml:space="preserve">
          <source>Note that this may be 1, in which case the sensor does not support any form of buffering. In that case, &lt;a href=&quot;qsensor#isFeatureSupported&quot;&gt;isFeatureSupported&lt;/a&gt;(&lt;a href=&quot;qsensor#Feature-enum&quot;&gt;QSensor::Buffering&lt;/a&gt;) will also return false.</source>
          <target state="translated">이 값은 1 일 수 있으며,이 경우 센서는 어떤 형태의 버퍼링도 지원하지 않습니다. 이 경우 &lt;a href=&quot;qsensor#isFeatureSupported&quot;&gt;isFeatureSupported&lt;/a&gt; ( QSensor &lt;a href=&quot;qsensor#Feature-enum&quot;&gt;:: Buffering&lt;/a&gt; )도 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="79226c92609e7afe0c661f12833225fdd92988f9" translate="yes" xml:space="preserve">
          <source>Note that this method doesn't have an overload working with iterators, because it invalidates the iterators of the sequence it operates on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddd70a9aad05e50b2724361b223e9cd137d74aae" translate="yes" xml:space="preserve">
          <source>Note that this method is generally used to check whether the item is under the mouse cursor, and for that reason, the implementation of this function should be as light-weight as possible.</source>
          <target state="translated">이 방법은 일반적으로 항목이 마우스 커서 아래에 있는지 확인하는 데 사용되므로이 기능의 구현은 가능한 한 가벼워 야합니다.</target>
        </trans-unit>
        <trans-unit id="65aee6708cb5d30c2f14124c9f14ee6ee58a6947" translate="yes" xml:space="preserve">
          <source>Note that this neither waits nor cancels the asynchronous computation. Use &lt;a href=&quot;qfuture#waitForFinished&quot;&gt;waitForFinished&lt;/a&gt;() or &lt;a href=&quot;qfuturesynchronizer&quot;&gt;QFutureSynchronizer&lt;/a&gt; when you need to ensure that the computation is completed before the future is destroyed.</source>
          <target state="translated">이것은 비동기 계산을 기다리거나 취소하지 않습니다. 미래가 파괴되기 전에 계산이 완료되었는지 확인해야 할 경우 &lt;a href=&quot;qfuture#waitForFinished&quot;&gt;waitForFinished&lt;/a&gt; () 또는 &lt;a href=&quot;qfuturesynchronizer&quot;&gt;QFutureSynchronizer를&lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="47d034e99dd278f42c39dcec005a226b7e7f20cf" translate="yes" xml:space="preserve">
          <source>Note that this only changes when measuring geomagnetic flux density. Raw magnetic flux readings will always have a value of 1.</source>
          <target state="translated">지자기 플럭스 밀도를 측정 할 때만 변경됩니다. 원시 자속 측정 값은 항상 1입니다.</target>
        </trans-unit>
        <trans-unit id="60a56910f468bc8ada1bb2c0aa1416877b2a43e8" translate="yes" xml:space="preserve">
          <source>Note that this only prevents new instance of the backend from being created. It does not invalidate the existing instances of the backend. The backend code should handle the disappearance of the underlying hardware itself.</source>
          <target state="translated">이렇게하면 백엔드의 새 인스턴스가 작성되지 않습니다. 백엔드의 기존 인스턴스를 무효화하지 않습니다. 백엔드 코드는 기본 하드웨어 자체의 소멸을 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="edd7fd8d3370885ba5497b96fafdc4e9101d8f9b" translate="yes" xml:space="preserve">
          <source>Note that this property affects object instantiation only; it is unrelated to loading a component asynchronously via a network.</source>
          <target state="translated">이 속성은 객체 인스턴스화에만 영향을 미칩니다. 네트워크를 통해 컴포넌트를 비동기식으로로드하는 것과는 관련이 없습니다.</target>
        </trans-unit>
        <trans-unit id="5f5aedda3afb2b2fc9690433553361c1a8150ab2" translate="yes" xml:space="preserve">
          <source>Note that this property does not affect the serialization or deserialization of &lt;code&gt;qfloat16&lt;/code&gt; instances.</source>
          <target state="translated">이 속성은 &lt;code&gt;qfloat16&lt;/code&gt; 인스턴스 의 직렬화 또는 역 직렬화에 영향을 미치지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="f9c126376b2267efe6eab51d68ad7c07fc5010e1" translate="yes" xml:space="preserve">
          <source>Note that this property is only valid for images read from the local filesystem. Images loaded via a network resource (e.g. HTTP) are always loaded asynchronously.</source>
          <target state="translated">이 특성은 로컬 파일 시스템에서 읽은 이미지에만 유효합니다. 네트워크 리소스 (예 : HTTP)를 통해로드 된 이미지는 항상 비동기 적으로로드됩니다.</target>
        </trans-unit>
        <trans-unit id="bbcd9cfc1f5508ebfafcf55352460c164fc4972f" translate="yes" xml:space="preserve">
          <source>Note that this property should be a regular expression in JS syntax, e.g /a/ for the regular expression matching &quot;a&quot;.</source>
          <target state="translated">이 속성은 JS 구문의 정규 표현식이어야합니다 (예 : &quot;a&quot;와 일치하는 정규 표현식의 경우 / a /).</target>
        </trans-unit>
        <trans-unit id="7a3ff0bf4a7ad0b0aba3ef822a5bb8929ba75c04" translate="yes" xml:space="preserve">
          <source>Note that this signal is</source>
          <target state="translated">이 신호는</target>
        </trans-unit>
        <trans-unit id="0db174405cf72778e45d0505dc0183a86f18e9e9" translate="yes" xml:space="preserve">
          <source>Note that this signal is also emitted whenever the</source>
          <target state="translated">이 신호는</target>
        </trans-unit>
        <trans-unit id="60883fb603150b15c766c5c0da2e89620569fb30" translate="yes" xml:space="preserve">
          <source>Note that this signal will not be emitted when the item model is reset.</source>
          <target state="translated">이 신호는 아이템 모델이 재설정 될 때 방출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f37e4351285d36785f017ddf98163a1fb539d504" translate="yes" xml:space="preserve">
          <source>Note that this will return 0 until a sensor backend is connected to a backend.</source>
          <target state="translated">센서 백엔드가 백엔드에 연결될 때까지 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="04e5e13e0b61dcfd9d929320c6ba7df6dd3a842b" translate="yes" xml:space="preserve">
          <source>Note that to ensure a valid list of current configurations immediately available, updating is done during construction which causes some delay.</source>
          <target state="translated">현재 사용 가능한 현재 구성의 유효한 목록을 보장하기 위해 구성 중에 업데이트가 수행되어 약간의 지연이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3d721fd17d63462060f2f1f7117b91fae0764107" translate="yes" xml:space="preserve">
          <source>Note that to save an already</source>
          <target state="translated">이미 저장하려면</target>
        </trans-unit>
        <trans-unit id="ff8fde53d6112bd49c1f0e8a55a917dd4574c8b9" translate="yes" xml:space="preserve">
          <source>Note that type information is not preserved when reading settings from INI files; all values will be returned as &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;.</source>
          <target state="translated">INI 파일에서 설정을 읽을 때 유형 정보가 유지되지 않습니다. 모든 값은 &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; 으로 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="553b2b8d297e93b6a6f9077530c7cd8270789282" translate="yes" xml:space="preserve">
          <source>Note that typically the top left corner of this rectangle will be &lt;code&gt;0,0&lt;/code&gt; while the width and height will be the width and height of the input content. Only when the video source has a viewport set, these values will differ.</source>
          <target state="translated">일반적으로이 사각형의 왼쪽 위 모서리는 &lt;code&gt;0,0&lt;/code&gt; 인 반면 너비와 높이는 입력 내용의 너비와 높이입니다. 비디오 소스에 뷰포트가 설정된 경우에만이 값이 달라집니다.</target>
        </trans-unit>
        <trans-unit id="8644872c2e7593f935d7e5b82915d3269ca1c8cc" translate="yes" xml:space="preserve">
          <source>Note that unbound parameters will retain their values.</source>
          <target state="translated">언 바운드 매개 변수는 해당 값을 유지합니다.</target>
        </trans-unit>
        <trans-unit id="1ce93a7eba6868c61b3eb1b6b2391858ea1d8d5e" translate="yes" xml:space="preserve">
          <source>Note that unbuffered devices, which have no way of determining what can be read, always return false.</source>
          <target state="translated">읽을 수있는 것을 결정할 방법이없는 버퍼되지 않은 장치는 항상 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="08783f938b7e6bc16ea07e038c60bd5292cacb9e" translate="yes" xml:space="preserve">
          <source>Note that unlike &lt;a href=&quot;qml-qtquick-propertychanges&quot;&gt;PropertyChanges&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-parentchange&quot;&gt;ParentChange&lt;/a&gt; expects an Item-based target; it will not work with arbitrary objects (for example, you couldn't use it to reparent a Timer).</source>
          <target state="translated">그와는 달리 주 &lt;a href=&quot;qml-qtquick-propertychanges&quot;&gt;PropertyChanges을&lt;/a&gt; , &lt;a href=&quot;qml-qtquick-parentchange&quot;&gt;ParentChange은&lt;/a&gt; 아이템 기반의 타겟이 예상; 임의의 개체에서는 작동하지 않습니다 (예 : 타이머를 다시 설정하는 데 사용할 수 없음).</target>
        </trans-unit>
        <trans-unit id="4960f708de1ac3a43e30257fb776bcdc7b40846e" translate="yes" xml:space="preserve">
          <source>Note that unlike &lt;a href=&quot;qml-qtquick-propertychanges&quot;&gt;PropertyChanges&lt;/a&gt;, ParentChange expects an Item-based target; it will not work with arbitrary objects (for example, you couldn't use it to reparent a Timer).</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-propertychanges&quot;&gt;PropertyChanges&lt;/a&gt; 와 달리 ParentChange는 항목 기반 대상을 예상합니다. 임의의 객체에서는 작동하지 않습니다 (예 : Timer를 다시 부모로 지정하는 데 사용할 수 없음).</target>
        </trans-unit>
        <trans-unit id="a2a6cbecdb93920d99f6b0ba618ddebcb6df3376" translate="yes" xml:space="preserve">
          <source>Note that unlike &lt;a href=&quot;qml-qtquick-spritesequence&quot;&gt;SpriteSequence&lt;/a&gt;, the &lt;a href=&quot;qml-qtquick-animatedsprite&quot;&gt;AnimatedSprite&lt;/a&gt; type does not use &lt;a href=&quot;qml-qtquick-sprite&quot;&gt;Sprite&lt;/a&gt; to define multiple animations, but instead encapsulates a single animation itself.</source>
          <target state="translated">참고 달리 것을 &lt;a href=&quot;qml-qtquick-spritesequence&quot;&gt;SpriteSequence&lt;/a&gt; 의 &lt;a href=&quot;qml-qtquick-animatedsprite&quot;&gt;AnimatedSprite의&lt;/a&gt; 유형은 사용하지 않습니다 &lt;a href=&quot;qml-qtquick-sprite&quot;&gt;스프라이트를&lt;/a&gt; 여러 애니메이션을 정의하는 대신 하나의 애니메이션 자체를 캡슐화합니다.</target>
        </trans-unit>
        <trans-unit id="51fe2fe83737ca3c54b50f7e03b0e6c094d925b1" translate="yes" xml:space="preserve">
          <source>Note that unlike &lt;a href=&quot;qml-qtquick-spritesequence&quot;&gt;SpriteSequence&lt;/a&gt;, the AnimatedSprite type does not use &lt;a href=&quot;qml-qtquick-sprite&quot;&gt;Sprite&lt;/a&gt; to define multiple animations, but instead encapsulates a single animation itself.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-spritesequence&quot;&gt;SpriteSequence&lt;/a&gt; 와 달리 AnimatedSprite 유형은 &lt;a href=&quot;qml-qtquick-sprite&quot;&gt;Sprite&lt;/a&gt; 를 사용 하여 여러 애니메이션을 정의 하지 않고 대신 단일 애니메이션 자체를 캡슐화합니다.</target>
        </trans-unit>
        <trans-unit id="6c892ab9996d9ed132a0caf6c18171f3c4f68e97" translate="yes" xml:space="preserve">
          <source>Note that unlike &lt;a href=&quot;qstring#fromUtf16&quot;&gt;fromUtf16&lt;/a&gt;(), this function does not consider BOMs and possibly differing byte ordering.</source>
          <target state="translated">&lt;a href=&quot;qstring#fromUtf16&quot;&gt;Utf16&lt;/a&gt; () 과 달리이 함수는 BOM 및 다른 바이트 순서를 고려하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ae24a2278244dcc61b9830812aa5f432cca9458b" translate="yes" xml:space="preserve">
          <source>Note that unlike in most other &lt;a href=&quot;qiodevice&quot;&gt;QIODevice&lt;/a&gt; subclasses, open() may not open the device directly. The function return false if the socket was already connected or if the server to connect to was not defined and true in any other case. The &lt;a href=&quot;qlocalsocket#connected&quot;&gt;connected&lt;/a&gt;() or &lt;a href=&quot;qlocalsocket#error&quot;&gt;error&lt;/a&gt;() signals will be emitted once the device is actualy open (or the connection failed).</source>
          <target state="translated">대부분의 다른 &lt;a href=&quot;qiodevice&quot;&gt;QIODevice&lt;/a&gt; 서브 클래스 와 달리 open ()은 장치를 직접 열지 못할 수도 있습니다. 소켓이 이미 연결되었거나 연결할 서버가 정의되지 않은 경우 함수는 false를 리턴하고 다른 경우에는 true를 리턴합니다. &lt;a href=&quot;qlocalsocket#connected&quot;&gt;접속&lt;/a&gt; () 또는 &lt;a href=&quot;qlocalsocket#error&quot;&gt;에러&lt;/a&gt; () 신호 장치 actualy 열리면 출사된다 (또는 접속 실패).</target>
        </trans-unit>
        <trans-unit id="77f1b7eea7d378a6fa97b896da43a1540ea2b26f" translate="yes" xml:space="preserve">
          <source>Note that unlike in most other &lt;a href=&quot;qiodevice&quot;&gt;QIODevice&lt;/a&gt; subclasses, open() may not open the device directly. The function return false if the socket was already connected or if the server to connect to was not defined and true in any other case. The &lt;a href=&quot;qlocalsocket#connected&quot;&gt;connected&lt;/a&gt;() or &lt;a href=&quot;qlocalsocket#errorOccurred&quot;&gt;errorOccurred&lt;/a&gt;() signals will be emitted once the device is actualy open (or the connection failed).</source>
          <target state="translated">대부분의 다른 &lt;a href=&quot;qiodevice&quot;&gt;QIODevice&lt;/a&gt; 하위 클래스 와 달리 open ()은 장치를 직접 열지 못할 수 있습니다. 이 함수는 소켓이 이미 연결되어 있거나 연결할 서버가 정의되지 않은 경우 false를 반환하고 다른 경우에는 true를 반환합니다. &lt;a href=&quot;qlocalsocket#connected&quot;&gt;접속&lt;/a&gt; () 또는 &lt;a href=&quot;qlocalsocket#errorOccurred&quot;&gt;errorOccurred&lt;/a&gt; () 신호 장치 actualy 열리면 출사된다 (또는 접속 실패).</target>
        </trans-unit>
        <trans-unit id="68f2011c273029cd30c8054b677da56953324cf1" translate="yes" xml:space="preserve">
          <source>Note that unlike the &lt;a href=&quot;qpainter#drawPolygon&quot;&gt;drawPolygon&lt;/a&gt;() function the last point is</source>
          <target state="translated">&lt;a href=&quot;qpainter#drawPolygon&quot;&gt;drawPolygon&lt;/a&gt; () 함수 와 달리 마지막 점은</target>
        </trans-unit>
        <trans-unit id="8365323b741f740afcec7ec3e571a74aa8e1a916" translate="yes" xml:space="preserve">
          <source>Note that unlike the C library function of the same name, this function</source>
          <target state="translated">같은 이름의 C 라이브러리 함수와 달리이 함수는</target>
        </trans-unit>
        <trans-unit id="d0f65679007ce3c167a47bc9f313f8f0ac1af8cb" translate="yes" xml:space="preserve">
          <source>Note that unpolish() will only be called if the widget is destroyed. This can cause problems in some cases, e.g, if you remove a widget from the UI, cache it, and then reinsert it after the style has changed; some of Qt's classes cache their widgets.</source>
          <target state="translated">unpolish ()는 위젯이 파괴 된 경우에만 호출됩니다. 예를 들어, UI에서 위젯을 제거하고 캐시 한 다음 스타일이 변경된 후 다시 삽입하는 경우와 같은 경우에 문제가 발생할 수 있습니다. Qt 클래스 중 일부는 위젯을 캐시합니다.</target>
        </trans-unit>
        <trans-unit id="a39415cc0d7d703356c91bc423d6faa2cd83b2b7" translate="yes" xml:space="preserve">
          <source>Note that use of &lt;a href=&quot;qurl#ComponentFormattingOption-enum&quot;&gt;QUrl::FullyDecoded&lt;/a&gt; in queries is discouraged, as queries often contain data that is supposed to remain percent-encoded, including the use of the &quot;%2B&quot; sequence to represent a plus character ('+').</source>
          <target state="translated">쿼리 에는 &lt;a href=&quot;qurl#ComponentFormattingOption-enum&quot;&gt;QUrl :: FullyDecoded&lt;/a&gt; 를 사용 하지 않는 것이 좋습니다. 쿼리에는 더하기 문자 ( '+')를 나타내는 &quot;% 2B&quot;시퀀스 사용을 포함하여 퍼센트 인코딩 된 데이터가 포함되어 있기 때문에 권장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="957750a59d8232daec29f91deeaa41b30a46e219" translate="yes" xml:space="preserve">
          <source>Note that using &lt;a href=&quot;qxmlformatter&quot;&gt;QXmlFormatter&lt;/a&gt; instead of &lt;a href=&quot;qxmlserializer&quot;&gt;QXmlSerializer&lt;/a&gt; will increase computational overhead and document storage size due to the insertion of whitespace.</source>
          <target state="translated">사용하여 참고 &lt;a href=&quot;qxmlformatter&quot;&gt;QXmlFormatter를&lt;/a&gt; 대신 &lt;a href=&quot;qxmlserializer&quot;&gt;QXmlSerializer하기&lt;/a&gt; 때문에 공백의 삽입을 계산 오버 헤드 및 문서 저장 크기를 증가시킬 것이다.</target>
        </trans-unit>
        <trans-unit id="694a65df7e68902fbbfd1a404af2bf0efc8a6a95" translate="yes" xml:space="preserve">
          <source>Note that using QXmlFormatter instead of &lt;a href=&quot;qxmlserializer&quot;&gt;QXmlSerializer&lt;/a&gt; will increase computational overhead and document storage size due to the insertion of whitespace.</source>
          <target state="translated">대신 QXmlFormatter를 사용 유의 &lt;a href=&quot;qxmlserializer&quot;&gt;QXmlSerializer하기&lt;/a&gt; 때문에 공백의 삽입을 계산 오버 헤드 및 문서 저장 크기를 증가시킬 것이다.</target>
        </trans-unit>
        <trans-unit id="115c0d9b0a66a80945ac8e90be9d8a865657eee9" translate="yes" xml:space="preserve">
          <source>Note that using an existing Item property name such as &quot;opacity&quot; as an attribute is allowed. This is because path attributes add a new &lt;a href=&quot;qtqml-syntax-objectattributes#attached-properties-and-attached-signal-handlers&quot;&gt;Attached Property&lt;/a&gt; which in no way clashes with existing properties.</source>
          <target state="translated">&quot;opacity&quot;와 같은 기존 항목 속성 이름을 속성으로 사용할 수 있습니다. 이는 경로 속성 이 기존 속성과 충돌하지 않는 새로운 &lt;a href=&quot;qtqml-syntax-objectattributes#attached-properties-and-attached-signal-handlers&quot;&gt;연결된&lt;/a&gt; 속성을 추가하기 때문 입니다.</target>
        </trans-unit>
        <trans-unit id="5059ce77cdbcd8aedb4188626bb1aa8bf223cb8d" translate="yes" xml:space="preserve">
          <source>Note that using initializer lists requires a defining a helper macro to prevent the preprocessor from interpreting the commas as macro argument delimiters:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3642a9a4a98a482741748b5a5508a30d85dd4e4b" translate="yes" xml:space="preserve">
          <source>Note that using non-const operators and functions can cause &lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt; to do a deep copy of the data. This is due to &lt;a href=&quot;implicit-sharing#&quot;&gt;implicit sharing&lt;/a&gt;.</source>
          <target state="translated">Const가 아닌 연산자와 함수를 사용하면 &lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt; 가 데이터의 딥 카피를 수행 할 수 있습니다 . 이것은 &lt;a href=&quot;implicit-sharing#&quot;&gt;암시 적 공유 때문&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="361d2e0b416cc09f1b24edbf3a724da9fe55b9b9" translate="yes" xml:space="preserve">
          <source>Note that using non-const operators and functions can cause QByteArray to do a deep copy of the data, due to &lt;a href=&quot;implicit-sharing&quot;&gt;implicit sharing&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3ece214df7b4a0954aeadc13f28a47fbc54fcc5" translate="yes" xml:space="preserve">
          <source>Note that using non-const operators and functions can cause QList to do a deep copy of the data. This is due to &lt;a href=&quot;implicit-sharing&quot;&gt;implicit sharing&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19a6e97d140168c030ee578501eef508e897994f" translate="yes" xml:space="preserve">
          <source>Note that using non-const operators and functions can cause QVector to do a deep copy of the data. This is due to &lt;a href=&quot;implicit-sharing&quot;&gt;implicit sharing&lt;/a&gt;.</source>
          <target state="translated">상수가 아닌 연산자와 함수를 사용하면 QVector가 데이터의 전체 복사를 수행 할 수 있습니다. 이는 &lt;a href=&quot;implicit-sharing&quot;&gt;암시 적 공유 때문&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="068e213df7f96545ae195224f0ba1f8d087857f5" translate="yes" xml:space="preserve">
          <source>Note that using non-const operators can cause &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt; to do a deep copy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34a1539ee62953e068b2de8659992eee2bb755ab" translate="yes" xml:space="preserve">
          <source>Note that using non-const operators can cause &lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt; to do a deep copy.</source>
          <target state="translated">&lt;a href=&quot;qvector&quot;&gt;상수&lt;/a&gt; 가 아닌 연산자를 사용하면 QVector 가 딥 카피를 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dd8ff4eaa3f1d06e8a53ffe91b0809009f14ba60" translate="yes" xml:space="preserve">
          <source>Note that value() can only access properties declared with &lt;a href=&quot;qobject#Q_PROPERTY&quot;&gt;Q_PROPERTY&lt;/a&gt;() in sub-classes of &lt;a href=&quot;qsensorreading&quot;&gt;QSensorReading&lt;/a&gt;.</source>
          <target state="translated">value ()는 &lt;a href=&quot;qsensorreading&quot;&gt;QSensorReading의&lt;/a&gt; 하위 클래스에서 &lt;a href=&quot;qobject#Q_PROPERTY&quot;&gt;Q_PROPERTY&lt;/a&gt; ()로 선언 된 속성에만 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3d5ca3da1e07caa2add696f40b3a2b99210bcc2a" translate="yes" xml:space="preserve">
          <source>Note that values in both CBOR Maps and Arrays are converted recursively using this function too and placed in &lt;a href=&quot;qvariant#QVariantMap-typedef&quot;&gt;QVariantMap&lt;/a&gt; and &lt;a href=&quot;qvariant#QVariantList-typedef&quot;&gt;QVariantList&lt;/a&gt; instead. You will not find &lt;a href=&quot;qcbormap&quot;&gt;QCborMap&lt;/a&gt; and &lt;a href=&quot;qcborarray&quot;&gt;QCborArray&lt;/a&gt; stored inside the QVariants.</source>
          <target state="translated">CBOR 맵 및 배열의 ​​값은이 함수를 사용하여 재귀 적으로 변환되어 대신 &lt;a href=&quot;qvariant#QVariantMap-typedef&quot;&gt;QVariantMap&lt;/a&gt; 및 &lt;a href=&quot;qvariant#QVariantList-typedef&quot;&gt;QVariantList에&lt;/a&gt; 배치 됩니다. &lt;a href=&quot;qcborarray&quot;&gt;QVariants&lt;/a&gt; 내에 저장된 &lt;a href=&quot;qcbormap&quot;&gt;QCborMap&lt;/a&gt; 및 QCborArray를 찾을 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="fd262f7ddcb08a370554bb62737f3f90d2bb9d6a" translate="yes" xml:space="preserve">
          <source>Note that views may call multiData() with spans that have been used in previous calls, and therefore may already contain some data. Therefore, it is imperative that if the model cannot return the data for a given role, then it must clear the data in the corresponding &lt;a href=&quot;qmodelroledata&quot;&gt;QModelRoleData&lt;/a&gt; object. This can be done by calling &lt;a href=&quot;qmodelroledata#clearData&quot;&gt;QModelRoleData::clearData&lt;/a&gt;(), or similarly by setting a default constructed &lt;a href=&quot;qtcore-changes-qt6#qvariant&quot;&gt;QVariant&lt;/a&gt;, and so on. Failure to clear the data will result in the view believing that the &quot;old&quot; data is meant to be used for the corresponding role.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f305e5f0c3ceca628244e525c2481ed84b83f74" translate="yes" xml:space="preserve">
          <source>Note that visibility does not affect how &lt;a href=&quot;qml-qtlocation-place&quot;&gt;Place&lt;/a&gt;s associated with the category are displayed in the user-interface of an application on the device. Instead, it defines the sharing semantics of the category.</source>
          <target state="translated">가시성은 카테고리와 관련된 &lt;a href=&quot;qml-qtlocation-place&quot;&gt;장소&lt;/a&gt; 가 기기에서 애플리케이션의 사용자 인터페이스에 표시되는 방식에 영향을주지 않습니다 . 대신 카테고리의 공유 의미를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="02c4844daef034dbcb895efa590ee5a4de491926" translate="yes" xml:space="preserve">
          <source>Note that visibility does not affect how the place is displayed in the user-interface of an application on the device. Instead, it defines the sharing semantics of the place.</source>
          <target state="translated">가시성은 기기에서 애플리케이션의 사용자 인터페이스에 장소가 표시되는 방식에 영향을주지 않습니다. 대신 장소의 공유 의미를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="fe235d870772411b7af7a0db93f392c89305d40f" translate="yes" xml:space="preserve">
          <source>Note that we attempt to convert each node to a text node and use &lt;a href=&quot;qdomelement#text&quot;&gt;text&lt;/a&gt;() rather than using &lt;a href=&quot;qdomnode#firstChild&quot;&gt;firstChild&lt;/a&gt;().&lt;a href=&quot;qdomnode#toText&quot;&gt;toText&lt;/a&gt;().data() or n.&lt;a href=&quot;qdomnode#toText&quot;&gt;toText&lt;/a&gt;().data() directly on the node, because the node may not be a text element.</source>
          <target state="translated">각 노드를 텍스트 노드로 변환하고 &lt;a href=&quot;qdomnode#firstChild&quot;&gt;firstChild&lt;/a&gt; ()를 사용하는 대신 &lt;a href=&quot;qdomelement#text&quot;&gt;text&lt;/a&gt; ()를 사용하려고합니다 . &lt;a href=&quot;qdomnode#toText&quot;&gt;toText&lt;/a&gt; () .data () 또는 n. 노드가 텍스트 요소가 아니기 때문에 노드에서 직접 &lt;a href=&quot;qdomnode#toText&quot;&gt;toText&lt;/a&gt; () .data ().</target>
        </trans-unit>
        <trans-unit id="9cd8f33d3f80c657867e7d1b0a887a59ca4b5a5f" translate="yes" xml:space="preserve">
          <source>Note that we checked for individual drop actions in the above code. As mentioned above in the section on &lt;a href=&quot;#overriding-proposed-actions&quot;&gt;Overriding Proposed Actions&lt;/a&gt;, it is sometimes necessary to override the proposed drop action and choose a different one from the selection of possible drop actions. To do this, you need to check for the presence of each action in the value supplied by the event's &lt;a href=&quot;qdropevent#possibleActions&quot;&gt;possibleActions()&lt;/a&gt;, set the drop action with &lt;a href=&quot;qdropevent#setDropAction&quot;&gt;setDropAction()&lt;/a&gt;, and call &lt;a href=&quot;qevent#accept&quot;&gt;accept()&lt;/a&gt;.</source>
          <target state="translated">위 코드에서 개별 드롭 동작을 확인했습니다. 위에서 &lt;a href=&quot;#overriding-proposed-actions&quot;&gt;제안 된 조치 재정&lt;/a&gt; 의 섹션에서 언급했듯이 제안 된 놓기 조치를 대체하고 가능한 놓기 조치 선택에서 다른 조치를 선택해야하는 경우가 있습니다. 이렇게하려면 이벤트의 &lt;a href=&quot;qdropevent#possibleActions&quot;&gt;possibleActions ()&lt;/a&gt; 에서 제공 한 값에 각 조치가 있는지 확인 하고 &lt;a href=&quot;qdropevent#setDropAction&quot;&gt;setDropAction ()으로&lt;/a&gt; 삭제 조치를 설정 한 후 &lt;a href=&quot;qevent#accept&quot;&gt;accept ()를&lt;/a&gt; 호출해야 합니다.</target>
        </trans-unit>
        <trans-unit id="c438de631421046e682bc58410e289f3b1c52389" translate="yes" xml:space="preserve">
          <source>Note that we checked for individual drop actions in the above code. As mentioned above in the section on &lt;a href=&quot;dnd#overriding-proposed-actions&quot;&gt;Overriding Proposed Actions&lt;/a&gt;, it is sometimes necessary to override the proposed drop action and choose a different one from the selection of possible drop actions. To do this, you need to check for the presence of each action in the value supplied by the event's &lt;a href=&quot;qdropevent#possibleActions&quot;&gt;possibleActions()&lt;/a&gt;, set the drop action with &lt;a href=&quot;qdropevent#setDropAction&quot;&gt;setDropAction()&lt;/a&gt;, and call &lt;a href=&quot;qevent#accept&quot;&gt;accept()&lt;/a&gt;.</source>
          <target state="translated">위 코드에서 개별 드롭 동작을 확인했습니다. 위에 &lt;a href=&quot;dnd#overriding-proposed-actions&quot;&gt;제안 된 작업 재정&lt;/a&gt; 의 섹션에서 언급했듯이 , 제안 된 놓기 작업을 재정의하고 가능한 놓기 작업 선택과 다른 항목을 선택해야하는 경우가 있습니다. 이를 수행하려면 이벤트의 &lt;a href=&quot;qdropevent#possibleActions&quot;&gt;possibleActions ()&lt;/a&gt; 에서 제공하는 값에 각 작업이 있는지 확인 하고 &lt;a href=&quot;qdropevent#setDropAction&quot;&gt;setDropAction ()으로&lt;/a&gt; 드롭 작업을 설정 한 다음 &lt;a href=&quot;qevent#accept&quot;&gt;accept ()를&lt;/a&gt; 호출해야 합니다.</target>
        </trans-unit>
        <trans-unit id="938bf67203630ae1dba7c7d94f5637cc19b47cce" translate="yes" xml:space="preserve">
          <source>Note that we do not have to know how the delegate performs the actual editing process. We only have to provide a way for the delegate to set the data in the model. This is achieved through the &lt;a href=&quot;qabstractitemmodel#setData&quot;&gt;setData()&lt;/a&gt; function:</source>
          <target state="translated">대리인이 실제 편집 프로세스를 수행하는 방법을 알 필요는 없습니다. 델리게이트가 모델에서 데이터를 설정할 수있는 방법 만 제공하면됩니다. 이는 &lt;a href=&quot;qabstractitemmodel#setData&quot;&gt;setData ()&lt;/a&gt; 함수를 통해 달성됩니다 .</target>
        </trans-unit>
        <trans-unit id="b0c679c468039714e141f0cb0af328becd2d2858" translate="yes" xml:space="preserve">
          <source>Note that we do not need to keep a pointer to the editor widget because the view takes responsibility for destroying it when it is no longer needed.</source>
          <target state="translated">뷰가 더 이상 필요하지 않을 때 뷰를 삭제해야하기 때문에 편집기 위젯에 대한 포인터를 유지할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="1752ad60f1835051f69fc65351509b850437c82e" translate="yes" xml:space="preserve">
          <source>Note that we do not use the &lt;code&gt;Link&lt;/code&gt; and &lt;code&gt;LinkVisited&lt;/code&gt; roles when rendering rich text in Qt, and that we recommend that you use CSS and the &lt;a href=&quot;qtextdocument#defaultStyleSheet-prop&quot;&gt;QTextDocument::setDefaultStyleSheet&lt;/a&gt;() function to alter the appearance of links. For example:</source>
          <target state="translated">Qt에서 리치 텍스트를 렌더링 할 때는 &lt;code&gt;Link&lt;/code&gt; 및 &lt;code&gt;LinkVisited&lt;/code&gt; 역할을 사용하지 않으며 CSS 및 &lt;a href=&quot;qtextdocument#defaultStyleSheet-prop&quot;&gt;QTextDocument :: setDefaultStyleSheet&lt;/a&gt; () 함수를 사용하여 링크 모양을 변경하는 것이 좋습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a7a1f27206f045bb46a609c6b28e22496947e598" translate="yes" xml:space="preserve">
          <source>Note that we:</source>
          <target state="translated">우리는 :</target>
        </trans-unit>
        <trans-unit id="50f87f44def10b4e2e5b964350838716998c1128" translate="yes" xml:space="preserve">
          <source>Note that when a file imports a directory over a network, it can only access QML and JavaScript files specified in the &lt;code&gt;qmldir&lt;/code&gt; file located in the directory.</source>
          <target state="translated">파일이 네트워크를 통해 디렉토리를 가져올 때 디렉토리에있는 &lt;code&gt;qmldir&lt;/code&gt; 파일에 지정된 QML 및 JavaScript 파일에만 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bcfccdbac5ec39850fee2a4ab6ecc24c37c2891e" translate="yes" xml:space="preserve">
          <source>Note that when creating content dynamically the set of available properties cannot be changed once set. Whatever properties are first added to the model are the only permitted properties in the model.</source>
          <target state="translated">컨텐츠를 동적으로 작성할 때 사용 가능한 특성 세트를 설정 한 후에는 변경할 수 없습니다. 모델에 처음 추가 된 속성은 모델에서 유일하게 허용되는 속성입니다.</target>
        </trans-unit>
        <trans-unit id="efb6a03594b3761d0198df788001678aa64d4c3e" translate="yes" xml:space="preserve">
          <source>Note that when creating custom text editing widgets, the &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt::WA_InputMethodEnabled&lt;/a&gt; window attribute must be set explicitly (using the &lt;a href=&quot;qwidget#setAttribute&quot;&gt;QWidget::setAttribute&lt;/a&gt;() function) in order to receive input method events.</source>
          <target state="translated">사용자 정의 텍스트 편집 위젯을 작성할 때 입력 메소드 이벤트를 수신 하려면 &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt :: WA_InputMethodEnabled&lt;/a&gt; 창 속성을 명시 적으로 설정해야합니다 ( &lt;a href=&quot;qwidget#setAttribute&quot;&gt;QWidget :: setAttribute&lt;/a&gt; () 함수 사용).</target>
        </trans-unit>
        <trans-unit id="b80870412ce74cb0108a3d9bcdb170ed0ee54a03" translate="yes" xml:space="preserve">
          <source>Note that when creating custom text editing widgets, the &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt::WA_InputMethodEnabled&lt;/a&gt; window attribute must be set explicitly (using the &lt;a href=&quot;qwidget#setAttribute&quot;&gt;setAttribute&lt;/a&gt;() function) in order to receive input method events.</source>
          <target state="translated">사용자 정의 텍스트 편집 위젯을 작성할 때 입력 메소드 이벤트를 수신 하려면 &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt :: WA_InputMethodEnabled&lt;/a&gt; 창 속성을 명시 적으로 설정해야합니다 ( &lt;a href=&quot;qwidget#setAttribute&quot;&gt;setAttribute&lt;/a&gt; () 함수 사용).</target>
        </trans-unit>
        <trans-unit id="0a012ae9f54ba43200ea3d2dc9fdb20107ac8ea5" translate="yes" xml:space="preserve">
          <source>Note that when the progress is 1.0, the XML data has been downloaded, but it is yet to be loaded into the model at this point. Use the status property to find out when the XML data has been read and loaded into the model.</source>
          <target state="translated">진행률이 1.0 인 경우 XML 데이터가 다운로드되었지만이 시점에서 아직 모델로로드되지 않습니다. XML 데이터를 읽고 모델로로드 한시기를 확인하려면 status 특성을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="5b514a2ff1b65477219fe802b2f4a1ed7678a78a" translate="yes" xml:space="preserve">
          <source>Note that when using QML without a &lt;a href=&quot;qguiapplication&quot;&gt;QGuiApplication&lt;/a&gt;, the following properties will be undefined:</source>
          <target state="translated">&lt;a href=&quot;qguiapplication&quot;&gt;QGuiApplication&lt;/a&gt; 없이 QML을 사용하는 경우 다음 특성이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="66b0f2f7efd145a65a8a45ee76189f9b7a82d36e" translate="yes" xml:space="preserve">
          <source>Note that when using QtConcurrent::filteredReduced(), you can mix the use of normal and member functions freely:</source>
          <target state="translated">QtConcurrent :: filteredReduced ()를 사용할 때 일반 함수와 멤버 함수를 자유롭게 혼합하여 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b10d2718938bb514e9f3bde88de9b15476b9d573" translate="yes" xml:space="preserve">
          <source>Note that when using QtConcurrent::mappedReduced(), you can mix the use of normal and member functions freely:</source>
          <target state="translated">QtConcurrent :: mappedReduced ()를 사용할 때 일반 함수와 멤버 함수를 자유롭게 혼합하여 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a42f976a93f69eec1a6d384d3d86cf1f20c685ac" translate="yes" xml:space="preserve">
          <source>Note that when using a &lt;a href=&quot;qtextstream&quot;&gt;QTextStream&lt;/a&gt; on a &lt;a href=&quot;qfile&quot;&gt;QFile&lt;/a&gt;, calling reset() on the &lt;a href=&quot;qfile&quot;&gt;QFile&lt;/a&gt; will not have the expected result because &lt;a href=&quot;qtextstream&quot;&gt;QTextStream&lt;/a&gt; buffers the file. Use the &lt;a href=&quot;qtextstream#seek&quot;&gt;QTextStream::seek&lt;/a&gt;() function instead.</source>
          <target state="translated">주의점 사용하는 경우 그 &lt;a href=&quot;qtextstream&quot;&gt;QTextStream&lt;/a&gt; A의 &lt;a href=&quot;qfile&quot;&gt;Qfile을을&lt;/a&gt; 온 리셋 ()를 호출, &lt;a href=&quot;qfile&quot;&gt;Qfile을을&lt;/a&gt; 하기 때문에 예상 된 결과가되지 않습니다 &lt;a href=&quot;qtextstream&quot;&gt;QTextStream이&lt;/a&gt; 파일을 버퍼링. 사용 &lt;a href=&quot;qtextstream#seek&quot;&gt;QTextStream을 :: 추구하는&lt;/a&gt; 대신에 () 함수를.</target>
        </trans-unit>
        <trans-unit id="b690dd31cc293beecd2ecd7b4f63bd1fa8ba2a22" translate="yes" xml:space="preserve">
          <source>Note that when writing to &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;, &lt;a href=&quot;qxmlstreamwriter&quot;&gt;QXmlStreamWriter&lt;/a&gt; ignores the codec set with &lt;a href=&quot;qxmlstreamwriter#setCodec&quot;&gt;setCodec&lt;/a&gt;(). See that function for more information.</source>
          <target state="translated">기록 할 때 유의 &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; , &lt;a href=&quot;qxmlstreamwriter&quot;&gt;QXmlStreamWriter을&lt;/a&gt; 가진 코덱 세트 무시 &lt;a href=&quot;qxmlstreamwriter#setCodec&quot;&gt;setCodec을&lt;/a&gt; (). 자세한 내용은 해당 기능을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3fd60fb19f09dfff9c671d60f023383b63d72337" translate="yes" xml:space="preserve">
          <source>Note that when writing to &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;, QXmlStreamWriter ignores the codec set with &lt;a href=&quot;qxmlstreamwriter#setCodec&quot;&gt;setCodec&lt;/a&gt;(). See that function for more information.</source>
          <target state="translated">&lt;a href=&quot;qstring&quot;&gt;QString에&lt;/a&gt; 쓸 때 QXmlStreamWriter는 &lt;a href=&quot;qxmlstreamwriter#setCodec&quot;&gt;setCodec&lt;/a&gt; ()로 설정된 코덱을 무시합니다 . 자세한 내용은 해당 기능을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4e6ed38c3b413bf8d69243d4fcf0054406de13a5" translate="yes" xml:space="preserve">
          <source>Note that when x is 90 or -90, values for z and y achieve rotation around the same axis (due to the order of operations). In this case the y rotation will be 0.</source>
          <target state="translated">x가 90 또는 -90 인 경우 z 및 y 값은 작업 순서로 인해 동일한 축을 중심으로 회전합니다. 이 경우 y 회전은 0이됩니다.</target>
        </trans-unit>
        <trans-unit id="a6739ddc60d123db0442b580ca807db2cf338593" translate="yes" xml:space="preserve">
          <source>Note that whether or not the text is drawn is dependent on the style. Currently CleanLooks and Plastique draw the text. Mac, Windows and WindowsVista style do not.</source>
          <target state="translated">텍스트가 그려 지는지 여부는 스타일에 따라 다릅니다. 현재 CleanLooks 및 Plastique는 텍스트를 그립니다. Mac, Windows 및 WindowsVista 스타일은 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b79e7a8373c921825bae13c939fc9e0872681d48" translate="yes" xml:space="preserve">
          <source>Note that while</source>
          <target state="translated">그 동안</target>
        </trans-unit>
        <trans-unit id="524116b44c3e19c62b52f5ded45ff25c9ead2857" translate="yes" xml:space="preserve">
          <source>Note that while the &lt;a href=&quot;qpainter#brushOrigin&quot;&gt;brushOrigin&lt;/a&gt;() was necessary to adopt the parent's background for a widget in Qt 3, this is no longer the case since the Qt 4 painter doesn't paint the background unless you explicitly tell it to do so by setting the widget's &lt;a href=&quot;qwidget#autoFillBackground-prop&quot;&gt;autoFillBackground&lt;/a&gt; property to true.</source>
          <target state="translated">그동안 있습니다 &lt;a href=&quot;qpainter#brushOrigin&quot;&gt;brushOrigin은&lt;/a&gt; () Qt는 3 위젯에 대한 부모의 배경을 채택하는 것이 필요하다고 명시 적으로 위젯의 설정에 의해 그렇게하도록 지시하지 않는 한 Qt는 4 화가 배경을 페인트하지 않기 때문에,이 경우는 더 이상 &lt;a href=&quot;qwidget#autoFillBackground-prop&quot;&gt;autoFillBackground&lt;/a&gt; 속성을 true로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="05556e8158816144304ae51a354d8cfb46223cd1" translate="yes" xml:space="preserve">
          <source>Note that while the Qt QML module provides the language and infrastructure for QML applications, the &lt;a href=&quot;qtquick-index&quot;&gt;Qt Quick&lt;/a&gt; module provides many visual components, model-view support, an animation framework, and much more for building user interfaces.</source>
          <target state="translated">Qt QML 모듈은 QML 애플리케이션을위한 언어 및 인프라를 제공 하지만 &lt;a href=&quot;qtquick-index&quot;&gt;Qt Quick&lt;/a&gt; 모듈은 많은 시각적 구성 요소, 모델 뷰 지원, 애니메이션 프레임 워크 및 사용자 인터페이스 구축을위한 훨씬 더 많은 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="59d12c181dfc8fb72f3a0688f220da7c40bdacb0" translate="yes" xml:space="preserve">
          <source>Note that while you can set the size increment for all widgets, it only affects windows.</source>
          <target state="translated">모든 위젯의 크기 증분을 설정할 수는 있지만 창에만 영향을 미칩니다.</target>
        </trans-unit>
        <trans-unit id="6e947ab70ec35972d4ea21fe004c4844b14e3a78" translate="yes" xml:space="preserve">
          <source>Note that widgets with the &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt::WA_PaintOnScreen&lt;/a&gt; widget attribute set and widgets that wrap an external application or controller are not supported. Examples are &lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt; and QAxWidget.</source>
          <target state="translated">와 위젯 있습니다 &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt는 :: WA_PaintOnScreen&lt;/a&gt; 위젯 속성 세트 및 위젯 랩 외부 응용 프로그램 또는 컨트롤러가 지원되지 않습니다. 예는 &lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt; 및 QAxWidget입니다.</target>
        </trans-unit>
        <trans-unit id="686ae5547e7d5a8612b8b6e6def5872486b8e387" translate="yes" xml:space="preserve">
          <source>Note that widgets with the &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt::WA_PaintOnScreen&lt;/a&gt; widget attribute set and widgets that wrap an external application or controller are not supported. Examples are QGLWidget and QAxWidget.</source>
          <target state="translated">와 위젯 있습니다 &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt는 :: WA_PaintOnScreen&lt;/a&gt; 위젯 속성 세트 및 위젯 랩 외부 응용 프로그램 또는 컨트롤러가 지원되지 않습니다. 예는 QGLWidget 및 QAxWidget입니다.</target>
        </trans-unit>
        <trans-unit id="f4e0a0fd0171b0318907bde5135b52f25ce5c13a" translate="yes" xml:space="preserve">
          <source>Note that widgets with the &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt::WA_PaintOnScreen&lt;/a&gt; widget attribute set and widgets that wrap an external application or controller are not supported. Examples are QOpenGLWidget and QAxWidget.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a6652361cfe19c2f83a54b1e3ad2093af63d9ee" translate="yes" xml:space="preserve">
          <source>Note that widgets with the &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt::WA_PaintOnScreen&lt;/a&gt; widget attribute set and widgets that wrap an external application or controller cannot be embedded. Examples are &lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt; and QAxWidget.</source>
          <target state="translated">위젯으로 유의 &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt는 :: WA_PaintOnScreen&lt;/a&gt; 위젯 속성 세트 및 위젯 랩 외부 애플리케이션 또는 컨트롤러가 내장 될 수있다. 예는 &lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt; 및 QAxWidget입니다.</target>
        </trans-unit>
        <trans-unit id="cd2f718434b9d4b444846b49663bc72dcf7d9eb8" translate="yes" xml:space="preserve">
          <source>Note that widgets with the &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt::WA_PaintOnScreen&lt;/a&gt; widget attribute set and widgets that wrap an external application or controller cannot be embedded. Examples are QGLWidget and QAxWidget.</source>
          <target state="translated">위젯으로 유의 &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt는 :: WA_PaintOnScreen&lt;/a&gt; 위젯 속성 세트 및 위젯 랩 외부 애플리케이션 또는 컨트롤러가 내장 될 수있다. 예는 QGLWidget 및 QAxWidget입니다.</target>
        </trans-unit>
        <trans-unit id="6c62d3c672d1f36ebb6d25136810212c491dc35f" translate="yes" xml:space="preserve">
          <source>Note that widgets with the &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt::WA_PaintOnScreen&lt;/a&gt; widget attribute set and widgets that wrap an external application or controller cannot be embedded. Examples are QOpenGLWidget and QAxWidget.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="744073f480534943de4561e8012efb0f9d3615fa" translate="yes" xml:space="preserve">
          <source>Note that you also need to ensure that drops are enabled in the view; see &lt;a href=&quot;qwidget#acceptDrops-prop&quot;&gt;QWidget::acceptDrops&lt;/a&gt;(); and that the model supports the desired drop actions; see &lt;a href=&quot;qabstractitemmodel#supportedDropActions&quot;&gt;QAbstractItemModel::supportedDropActions&lt;/a&gt;().</source>
          <target state="translated">뷰에서 드랍이 활성화되어 있는지 확인해야합니다. &lt;a href=&quot;qwidget#acceptDrops-prop&quot;&gt;QWidget :: acceptDrops&lt;/a&gt; ();를 참조하십시오 . 모델이 원하는 드롭 동작을 지원한다는 점; &lt;a href=&quot;qabstractitemmodel#supportedDropActions&quot;&gt;QAbstractItemModel :: supportedDropActions&lt;/a&gt; ()를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9a8e3a2baebe430e597e9a928e73f2a49a3ad58b" translate="yes" xml:space="preserve">
          <source>Note that you also need to ensure that item dragging is enabled in the view; see &lt;a href=&quot;qabstractitemview#dragEnabled-prop&quot;&gt;QAbstractItemView::dragEnabled&lt;/a&gt;.</source>
          <target state="translated">뷰에서 항목 드래그가 활성화되어 있는지 확인해야합니다. &lt;a href=&quot;qabstractitemview#dragEnabled-prop&quot;&gt;QAbstractItemView :: dragEnabled를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1868860b6a0dd3a36076dcb6105877e7d3365535" translate="yes" xml:space="preserve">
          <source>Note that you can also pass a &lt;a href=&quot;qpixmap&quot;&gt;QPixmap&lt;/a&gt; object as an icon (thanks to the implicit type conversion provided by C++).</source>
          <target state="translated">&lt;a href=&quot;qpixmap&quot;&gt;QPixmap&lt;/a&gt; 객체를 아이콘으로 전달할 수도 있습니다 (C ++에서 제공하는 암시 적 유형 변환 덕분에).</target>
        </trans-unit>
        <trans-unit id="67a8a734eb5d7dd4a311eb6c65946fb1aaf207a9" translate="yes" xml:space="preserve">
          <source>Note that you can also use the &lt;a href=&quot;https://doc.qt.io/qt-5.13/animation-overview.html&quot;&gt;Animation Framework&lt;/a&gt; for animations.</source>
          <target state="translated">&lt;a href=&quot;https://doc.qt.io/qt-5.13/animation-overview.html&quot;&gt;애니메이션에 애니메이션 프레임 워크&lt;/a&gt; 를 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="455839c97e2d629ad4325d8dfa106f615f333eb7" translate="yes" xml:space="preserve">
          <source>Note that you can also use the &lt;a href=&quot;https://doc.qt.io/qt-5.15/animation-overview.html&quot;&gt;Animation Framework&lt;/a&gt; for animations.</source>
          <target state="translated">&lt;a href=&quot;https://doc.qt.io/qt-5.15/animation-overview.html&quot;&gt;애니메이션에 애니메이션 프레임 워크&lt;/a&gt; 를 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e65a70ef1debe7f21282ca323eed745f844266cb" translate="yes" xml:space="preserve">
          <source>Note that you can also use the &lt;a href=&quot;https://doc.qt.io/qt-6.0/animation-overview.html&quot;&gt;Animation Framework&lt;/a&gt; for animations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fde6c07febf4d73b8d6791ee56e2a30d441806a7" translate="yes" xml:space="preserve">
          <source>Note that you can examine how Qt's widgets implement their accessibility. One major problem with the MSAA standard is that interfaces are often implemented in an inconsistent way. This makes life difficult for clients and often leads to guesswork on object functionality.</source>
          <target state="translated">Qt의 위젯이 접근성을 구현하는 방법을 확인할 수 있습니다. MSAA 표준의 한 가지 주요 문제점은 인터페이스가 종종 일관되지 않은 방식으로 구현된다는 것입니다. 이로 인해 클라이언트의 삶이 어려워지고 종종 개체 기능에 대한 추측이 이루어집니다.</target>
        </trans-unit>
        <trans-unit id="0c19b3775df115ae29c8fe7b3cb800922193fde6" translate="yes" xml:space="preserve">
          <source>Note that you can set the expected certificate in the SSL error: If, for instance, you want to connect to a server that uses a self-signed certificate, consider the following snippet:</source>
          <target state="translated">SSL 오류에서 예상 인증서를 설정할 수 있습니다. 예를 들어 자체 서명 된 인증서를 사용하는 서버에 연결하려는 경우 다음 스 니펫을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="608151c1dbcb5c3cb8f8971aa38868d6b21f8fb7" translate="yes" xml:space="preserve">
          <source>Note that you cannot unregister objects that were not registered with &lt;a href=&quot;qdbusconnection#registerObject&quot;&gt;registerObject&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qdbusconnection#registerObject&quot;&gt;registerObject&lt;/a&gt; () 로 등록 되지 않은 객체는 등록을 취소 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="e0acf29faa59076bd77bbf7b26d0fc14b5bf2dfb" translate="yes" xml:space="preserve">
          <source>Note that you cannot use the setters on the returned object, you must either call the &lt;a href=&quot;qprinter&quot;&gt;QPrinter&lt;/a&gt; methods or &lt;a href=&quot;qprinter#setPageLayout&quot;&gt;setPageLayout&lt;/a&gt;().</source>
          <target state="translated">리턴 된 오브젝트에서 setter를 사용할 수 없으므로 &lt;a href=&quot;qprinter&quot;&gt;QPrinter&lt;/a&gt; 메소드 또는 &lt;a href=&quot;qprinter#setPageLayout&quot;&gt;setPageLayout&lt;/a&gt; ()을 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="b733ecbdc9106805a83582d25b1a2b980c5f648d" translate="yes" xml:space="preserve">
          <source>Note that you cannot use the setters on the returned object, you must either call the individual &lt;a href=&quot;qpagedpaintdevice&quot;&gt;QPagedPaintDevice&lt;/a&gt; setters or use &lt;a href=&quot;qpagedpaintdevice#setPageLayout&quot;&gt;setPageLayout&lt;/a&gt;().</source>
          <target state="translated">반환 된 객체에서 setter를 사용할 수 없으므로 개별 &lt;a href=&quot;qpagedpaintdevice&quot;&gt;QPagedPaintDevice&lt;/a&gt; setter를 호출 하거나 &lt;a href=&quot;qpagedpaintdevice#setPageLayout&quot;&gt;setPageLayout&lt;/a&gt; ()을 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="e941841daa9c42db73774f1c921addfd6cb42cae" translate="yes" xml:space="preserve">
          <source>Note that you cannot use the setters on the returned object, you must either call the individual &lt;a href=&quot;qpdfwriter&quot;&gt;QPdfWriter&lt;/a&gt; methods or use &lt;a href=&quot;qpdfwriter#setPageLayout&quot;&gt;setPageLayout&lt;/a&gt;().</source>
          <target state="translated">리턴 된 오브젝트에서 setter를 사용할 수 없으므로 개별 &lt;a href=&quot;qpdfwriter&quot;&gt;QPdfWriter&lt;/a&gt; 메소드를 호출 하거나 &lt;a href=&quot;qpdfwriter#setPageLayout&quot;&gt;setPageLayout&lt;/a&gt; ()을 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="ef0311d0dc9ee2eb18546a9bfd35ec980dbef9ca" translate="yes" xml:space="preserve">
          <source>Note that you have to pass the address of the variable you want stored.</source>
          <target state="translated">저장하려는 변수의 주소를 전달해야합니다.</target>
        </trans-unit>
        <trans-unit id="096ab7558c079e48d6b79582a3d873cac604ffce" translate="yes" xml:space="preserve">
          <source>Note that you must add the layout of the</source>
          <target state="translated">레이아웃을 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="24ac31da6f2bf93d9d665c284b59993ea746f297" translate="yes" xml:space="preserve">
          <source>Note that you must re-import the project if its setup changes, for example, when adding or removing source files.</source>
          <target state="translated">소스 파일을 추가하거나 제거 할 때와 같이 설정이 변경되면 프로젝트를 다시 가져와야합니다.</target>
        </trans-unit>
        <trans-unit id="5320d14e107b35f930d1f7860ed2217ab12c32b6" translate="yes" xml:space="preserve">
          <source>Note that you should never manually delete objects that were dynamically created by convenience QML object factories (such as &lt;a href=&quot;qml-qtquick-loader&quot;&gt;Loader&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-repeater&quot;&gt;Repeater&lt;/a&gt;). Also, you should avoid deleting objects that you did not dynamically create yourself.</source>
          <target state="translated">편의 QML 객체 팩토리 (예 : &lt;a href=&quot;qml-qtquick-loader&quot;&gt;Loader&lt;/a&gt; 및 &lt;a href=&quot;qml-qtquick-repeater&quot;&gt;Repeater&lt;/a&gt; ) 로 동적으로 작성된 객체를 수동으로 삭제해서는 안됩니다 . 또한 동적으로 자신을 만들지 않은 개체는 삭제하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="68d82da44bb7159d67fa9fb121bdcf8f1425ccb1" translate="yes" xml:space="preserve">
          <source>Note that you should not update the source model through the proxy model when dynamicSortFilter is true. For instance, if you set the proxy model on a &lt;a href=&quot;qcombobox&quot;&gt;QComboBox&lt;/a&gt;, then using functions that update the model, e.g., &lt;a href=&quot;qcombobox#addItem&quot;&gt;addItem()&lt;/a&gt;, will not work as expected. An alternative is to set dynamicSortFilter to false and call &lt;a href=&quot;qsortfilterproxymodel#sort&quot;&gt;sort()&lt;/a&gt; after adding items to the &lt;a href=&quot;qcombobox&quot;&gt;QComboBox&lt;/a&gt;.</source>
          <target state="translated">dynamicSortFilter가 true 인 경우 프록시 모델을 통해 소스 모델을 업데이트하지 않아야합니다. 예를 들어, &lt;a href=&quot;qcombobox&quot;&gt;QComboBox&lt;/a&gt; 에서 프록시 모델을 설정 한 경우 모델 을 업데이트하는 함수 &lt;a href=&quot;qcombobox#addItem&quot;&gt;(&lt;/a&gt; 예 : addItem ()) 를 사용하면 예상대로 작동하지 않습니다. 대안은 dynamicSortFilter를 false로 설정 하고 &lt;a href=&quot;qcombobox&quot;&gt;QComboBox에&lt;/a&gt; 항목을 추가 한 후 &lt;a href=&quot;qsortfilterproxymodel#sort&quot;&gt;sort ()를&lt;/a&gt; 호출 하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="fe727c2fb75cb952a896aa592944c3e02a5eb1d7" translate="yes" xml:space="preserve">
          <source>Note that you should not update the source model through the proxy model when dynamicSortFilter is true. For instance, if you set the proxy model on a &lt;a href=&quot;widgets-changes-qt6#qcombobox&quot;&gt;QComboBox&lt;/a&gt;, then using functions that update the model, e.g., &lt;a href=&quot;qcombobox#addItem&quot;&gt;addItem()&lt;/a&gt;, will not work as expected. An alternative is to set dynamicSortFilter to false and call &lt;a href=&quot;qsortfilterproxymodel#sort&quot;&gt;sort()&lt;/a&gt; after adding items to the &lt;a href=&quot;widgets-changes-qt6#qcombobox&quot;&gt;QComboBox&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="143cb0ce6cbf0482b3766c1673ebdd977ebc68cc" translate="yes" xml:space="preserve">
          <source>Note that you typically do not list header files here. This is different from &lt;a href=&quot;qmake-manual&quot;&gt;qmake&lt;/a&gt;, where header files need to be explicitly listed so that they are processed by the &lt;a href=&quot;moc&quot;&gt;Meta-Object Compiler (moc)&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc1a14cb5833ab8a0c5e76cf2c90d0c94fad6dd0" translate="yes" xml:space="preserve">
          <source>Note that you will need to down-cast to the appropriate type.</source>
          <target state="translated">적절한 유형으로 다운 캐스트해야합니다.</target>
        </trans-unit>
        <trans-unit id="030dcfeb0caa9f3c7e36c9af8eb874b2533d5bda" translate="yes" xml:space="preserve">
          <source>Note that, although the scene supports a virtually unlimited size, the range of the scroll bars will never exceed the range of an integer (INT_MIN, INT_MAX). When the scene is larger than the scroll bars' values, you can choose to use &lt;a href=&quot;qgraphicsview#translate&quot;&gt;translate&lt;/a&gt;() to navigate the scene instead.</source>
          <target state="translated">장면이 사실상 무제한 크기를 지원하지만 스크롤 막대 범위는 정수 범위 (INT_MIN, INT_MAX)를 초과하지 않습니다. 장면이 스크롤 막대의 값보다 큰 경우 &lt;a href=&quot;qgraphicsview#translate&quot;&gt;translate&lt;/a&gt; ()을 사용하여 대신 장면을 탐색 하도록 선택할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f50fcd290240aa9b514c46e4a8c058bc1cf469e7" translate="yes" xml:space="preserve">
          <source>Note that, by default, &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; renders the outline (using the currently set pen) when drawing shapes. Use &lt;a href=&quot;qt#PenStyle-enum&quot;&gt;&lt;code&gt;painter.setPen(Qt::NoPen)&lt;/code&gt;&lt;/a&gt; to disable this behavior.</source>
          <target state="translated">기본적으로 &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; 는 도형을 그릴 때 현재 설정된 펜을 사용하여 윤곽선을 렌더링합니다. 이 동작을 비활성화 하려면 &lt;a href=&quot;qt#PenStyle-enum&quot;&gt; &lt;code&gt;painter.setPen(Qt::NoPen)&lt;/code&gt; &lt;/a&gt; 을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b2ffd69987afcf2e7fbc53f5e3dba5a948749931" translate="yes" xml:space="preserve">
          <source>Note that, by default, QTimeLine uses &lt;a href=&quot;qeasingcurve#Type-enum&quot;&gt;QEasingCurve::InOutSine&lt;/a&gt;, which provides a value that grows slowly, then grows steadily, and finally grows slowly. For a custom timeline, you can reimplement &lt;a href=&quot;qtimeline#valueForTime&quot;&gt;valueForTime&lt;/a&gt;(), in which case QTimeLine's &lt;a href=&quot;qtimeline#easingCurve-prop&quot;&gt;easingCurve&lt;/a&gt; property is ignored.</source>
          <target state="translated">기본적으로 QTimeLine은 &lt;a href=&quot;qeasingcurve#Type-enum&quot;&gt;QEasingCurve :: InOutSine&lt;/a&gt; 을 사용합니다.이 값은 느리게 증가한 다음 꾸준히 증가하고 마침내 느리게 증가하는 값을 제공합니다. 사용자 정의 타임 라인의 경우 &lt;a href=&quot;qtimeline#valueForTime&quot;&gt;valueForTime&lt;/a&gt; ()을 다시 구현할 수 있습니다 .이 경우 QTimeLine의 &lt;a href=&quot;qtimeline#easingCurve-prop&quot;&gt;easingCurve&lt;/a&gt; 속성이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="750fc056d65abdb2cc1cb1b4588b0e1be37d5ba1" translate="yes" xml:space="preserve">
          <source>Note that, due to the nature of weak references, the pointer that &lt;a href=&quot;qweakpointer&quot;&gt;QWeakPointer&lt;/a&gt; references can become &lt;code&gt;nullptr&lt;/code&gt; at any moment, so the value returned from this function can change from false to true from one call to the next.</source>
          <target state="translated">약한 참조의 특성으로 인해 &lt;a href=&quot;qweakpointer&quot;&gt;QWeakPointer가&lt;/a&gt; 참조 하는 포인터 는 언제든지 &lt;code&gt;nullptr&lt;/code&gt; 이 될 수 있으므로이 함수에서 리턴 된 값은 한 호출에서 다음 호출로 false에서 true로 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="91ed0bdf5be6988b871adffb428fe3eeb0cc1bff" translate="yes" xml:space="preserve">
          <source>Note that, due to the nature of weak references, the pointer that &lt;a href=&quot;qweakpointer&quot;&gt;QWeakPointer&lt;/a&gt; references can become &lt;code&gt;nullptr&lt;/code&gt; at any moment, so the value returned from this function can change from true to false from one call to the next.</source>
          <target state="translated">약한 참조의 특성으로 인해 &lt;a href=&quot;qweakpointer&quot;&gt;QWeakPointer가&lt;/a&gt; 참조 하는 포인터 는 언제든지 &lt;code&gt;nullptr&lt;/code&gt; 이 될 수 있으므로이 함수에서 반환 된 값은 한 호출에서 다음 호출로 true에서 false로 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8bf4fc278ab3e3874ae2dfc2664e4d61a182ba9" translate="yes" xml:space="preserve">
          <source>Note that, for letters, the case used in the specification string does not matter. In the above examples, the user does not need to hold down the &lt;b&gt;Shift&lt;/b&gt; key to activate a shortcut specified with &quot;Ctrl+P&quot;. However, for other keys, the use of &lt;b&gt;Shift&lt;/b&gt; as an unspecified extra modifier key can lead to confusion for users of an application whose keyboards have different layouts to those used by the developers. See the &lt;a href=&quot;qkeysequence#keyboard-layout-issues&quot;&gt;Keyboard Layout Issues&lt;/a&gt; section below for more details.</source>
          <target state="translated">문자의 경우 사양 문자열에 사용 된 대소 문자는 중요하지 않습니다. 위의 예에서 사용자는 &quot;Ctrl + P&quot;로 지정된 바로 가기를 활성화하기 위해 &lt;b&gt;Shift&lt;/b&gt; 키를 누르고있을 필요가 없습니다 . 그러나 다른 키의 경우 &lt;b&gt;Shift&lt;/b&gt; 를 지정되지 않은 추가 수정 자 키로 사용하면 키보드가 개발자가 사용하는 키보드와 레이아웃이 다른 응용 프로그램 사용자에게 혼란을 줄 수 있습니다. 자세한 내용은 아래 의 &lt;a href=&quot;qkeysequence#keyboard-layout-issues&quot;&gt;키보드 레이아웃 문제&lt;/a&gt; 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="dda4305e318d998bb0cb9512594383a9dabfa9f1" translate="yes" xml:space="preserve">
          <source>Note that, if the image data comes from a sequential device (e.g. a socket), &lt;a href=&quot;qmovie&quot;&gt;QMovie&lt;/a&gt; can only loop the movie if the &lt;a href=&quot;qmovie#cacheMode-prop&quot;&gt;cacheMode&lt;/a&gt; is set to &lt;a href=&quot;qmovie#CacheMode-enum&quot;&gt;QMovie::CacheAll&lt;/a&gt;.</source>
          <target state="translated">이미지 데이터가 순차적 장치 (예 : 소켓)에서 &lt;a href=&quot;qmovie&quot;&gt;온&lt;/a&gt; 경우 , QMode 는 &lt;a href=&quot;qmovie#cacheMode-prop&quot;&gt;cacheMode&lt;/a&gt; 가 &lt;a href=&quot;qmovie#CacheMode-enum&quot;&gt;QMovie :: CacheAll로&lt;/a&gt; 설정된 경우에만 동영상을 반복 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b7fcaee2ab0f7c4e92ab4a3633b3adaece1fe192" translate="yes" xml:space="preserve">
          <source>Note that, if the reply hasn't arrived, this function causes the calling thread to block until the reply is processed.</source>
          <target state="translated">응답이 도착하지 않은 경우이 함수는 응답이 처리 될 때까지 호출 스레드를 차단합니다.</target>
        </trans-unit>
        <trans-unit id="48dc5f66b4731049c45eef25e6e41c32a1a4ed47" translate="yes" xml:space="preserve">
          <source>Note that, if this &lt;a href=&quot;qfileinfo&quot;&gt;QFileInfo&lt;/a&gt; object is given a path ending in a slash, the name of the file is considered empty and this function will return the entire path.</source>
          <target state="translated">이 &lt;a href=&quot;qfileinfo&quot;&gt;QFileInfo&lt;/a&gt; 객체에 슬래시로 끝나는 경로가 제공되면 파일 이름이 비어있는 것으로 간주 되며이 함수는 전체 경로를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="148a9ce23ba6e02639587b746d0ae63ca972b6ed" translate="yes" xml:space="preserve">
          <source>Note that, if this &lt;a href=&quot;qfileinfo&quot;&gt;QFileInfo&lt;/a&gt; object is given a path ending in a slash, the name of the file is considered empty.</source>
          <target state="translated">이 &lt;a href=&quot;qfileinfo&quot;&gt;QFileInfo&lt;/a&gt; 객체에 슬래시로 끝나는 경로가 제공되면 파일 이름이 비어있는 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="1d5c53949d92ad91cebde6cbc0c4cbb932fceb7f" translate="yes" xml:space="preserve">
          <source>Note that, if this &lt;a href=&quot;qurl&quot;&gt;QUrl&lt;/a&gt; object is given a path ending in a slash, the name of the file is considered empty.</source>
          <target state="translated">이 &lt;a href=&quot;qurl&quot;&gt;QUrl&lt;/a&gt; 오브젝트에 슬래시로 끝나는 경로가 제공되면 파일 이름이 비어있는 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="419867ba7519e67753cb3c989cb4f6ecc96eb080" translate="yes" xml:space="preserve">
          <source>Note that, if you call &lt;a href=&quot;qabstractitemview#setModel&quot;&gt;setModel&lt;/a&gt;() after this function, the given</source>
          <target state="translated">이 함수 다음에 &lt;a href=&quot;qabstractitemview#setModel&quot;&gt;setModel&lt;/a&gt; () 을 호출하면</target>
        </trans-unit>
        <trans-unit id="80a2c96f97d545b9342d569152f9acfc06be8330" translate="yes" xml:space="preserve">
          <source>Note that, if you want to display these error messages to your application's users, they will be displayed in English unless they are explicitly translated.</source>
          <target state="translated">이러한 오류 메시지를 응용 프로그램 사용자에게 표시하려면 명시 적으로 번역하지 않는 한 영어로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="c3621a03746865a7079eee548581b97194a53490" translate="yes" xml:space="preserve">
          <source>Note that, if you want to show tooltips in an item view, the model/view architecture provides functionality to set an item's tool tip; e.g., the &lt;a href=&quot;qtablewidgetitem#setToolTip&quot;&gt;QTableWidgetItem::setToolTip&lt;/a&gt;() function. However, if you want to provide custom tool tips in an item view, you must intercept the help event in the &lt;a href=&quot;qabstractitemview#viewportEvent&quot;&gt;QAbstractItemView::viewportEvent&lt;/a&gt;() function and handle it yourself.</source>
          <target state="translated">항목보기에 도구 설명을 표시하려는 경우 모델 /보기 아키텍처는 항목의 도구 설명을 설정하는 기능을 제공합니다. 예를 들어, &lt;a href=&quot;qtablewidgetitem#setToolTip&quot;&gt;QTableWidgetItem :: setToolTip&lt;/a&gt; () 함수입니다. 그러나 항목보기에서 사용자 정의 도구 팁을 제공하려면 &lt;a href=&quot;qabstractitemview#viewportEvent&quot;&gt;QAbstractItemView :: viewportEvent&lt;/a&gt; () 함수 에서 도움말 이벤트를 가로 채서 직접 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="13ad2d3adfb6e183e38b07db0b442eb30a61260a" translate="yes" xml:space="preserve">
          <source>Note that, in all cases, the result of the parsing must be a valid hostname according to STD 3 rules, as modified by the Internationalized Resource Identifiers specification (RFC 3987). Invalid hostnames are not permitted and will cause &lt;a href=&quot;qurl#isValid&quot;&gt;isValid&lt;/a&gt;() to become false.</source>
          <target state="translated">모든 경우에 구문 분석 결과는 국제화 된 자원 식별자 스펙 (RFC 3987)에 의해 수정 된 STD 3 규칙에 따라 유효한 호스트 이름이어야합니다. 유효하지 않은 호스트 이름은 허용되지 않으며 &lt;a href=&quot;qurl#isValid&quot;&gt;isValid&lt;/a&gt; ()가 false가됩니다.</target>
        </trans-unit>
        <trans-unit id="39697513fb021693d9ac7b41e89bc3f7a4510298" translate="yes" xml:space="preserve">
          <source>Note that, in cases where there are other tables in the font that affect the shaping of the text, the returned glyph indexes will not correctly represent the rendering of the text. To get the correctly shaped text, you can use &lt;a href=&quot;qtextlayout&quot;&gt;QTextLayout&lt;/a&gt; to lay out and shape the text, then call QTextLayout::glyphs() to get the set of glyph index list and &lt;a href=&quot;qrawfont&quot;&gt;QRawFont&lt;/a&gt; pairs.</source>
          <target state="translated">글꼴에 텍스트 모양에 영향을주는 다른 테이블이있는 경우 반환되는 글리프 인덱스는 텍스트 렌더링을 올바르게 나타내지 않습니다. 올바른 모양의 텍스트를 얻으려면 &lt;a href=&quot;qtextlayout&quot;&gt;QTextLayout&lt;/a&gt; 을 사용 하여 텍스트를 배치하고 모양을 지정한 다음 QTextLayout :: glyphs ()를 호출하여 글리프 색인 목록 및 &lt;a href=&quot;qrawfont&quot;&gt;QRawFont&lt;/a&gt; 쌍 세트를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="f6833c9c5d548b81b4f1261878b766216e4610f5" translate="yes" xml:space="preserve">
          <source>Note that, since Column inherits directly from Item, any background color must be added to a parent Rectangle, if desired.</source>
          <target state="translated">Column은 Item에서 직접 상속되므로 원하는 경우 모든 배경색을 부모 Rectangle에 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="9377b94c81bd5e9e0c2b348faf1c52cd5b327c7b" translate="yes" xml:space="preserve">
          <source>Note that, since the &lt;a href=&quot;qml-qtquick-focusscope&quot;&gt;FocusScope&lt;/a&gt; type is not a visual type, the properties of its children need to be exposed to the parent item of the &lt;a href=&quot;qml-qtquick-focusscope&quot;&gt;FocusScope&lt;/a&gt;. Layouts and positioning types will use these visual and styling properties to create the layout. In our example, the &lt;code&gt;Column&lt;/code&gt; type cannot display the two widgets properly because the &lt;a href=&quot;qml-qtquick-focusscope&quot;&gt;FocusScope&lt;/a&gt; lacks visual properties of its own. The MyWidget component directly binds to the &lt;code&gt;rectangle&lt;/code&gt; properties to allow the &lt;code&gt;Column&lt;/code&gt; type to create the layout containing the children of the &lt;a href=&quot;qml-qtquick-focusscope&quot;&gt;FocusScope&lt;/a&gt;.</source>
          <target state="translated">때문에,주의 &lt;a href=&quot;qml-qtquick-focusscope&quot;&gt;FocusScope의&lt;/a&gt; 유형은 시각적 유형이 아닌, 아이의 특성이의 부모 항목에 노출 될 필요가 &lt;a href=&quot;qml-qtquick-focusscope&quot;&gt;FocusScope&lt;/a&gt; . 레이아웃 및 위치 지정 유형은 이러한 시각적 및 스타일 속성을 사용하여 레이아웃을 만듭니다. 이 예 에서 &lt;a href=&quot;qml-qtquick-focusscope&quot;&gt;FocusScope&lt;/a&gt; 에는 자체 시각적 속성이 없기 때문에 &lt;code&gt;Column&lt;/code&gt; 유형이 두 위젯을 올바르게 표시 할 수 없습니다 . MyWidget 구성 요소는 &lt;code&gt;rectangle&lt;/code&gt; 속성에 직접 바인딩되어 &lt;code&gt;Column&lt;/code&gt; 형식이 &lt;a href=&quot;qml-qtquick-focusscope&quot;&gt;FocusScope&lt;/a&gt; 의 자식을 포함하는 레이아웃을 만들 수 있도록합니다 .</target>
        </trans-unit>
        <trans-unit id="a839f37eab469e5c9d8d8739e4c38563d6ee4933" translate="yes" xml:space="preserve">
          <source>Note that, since the key sequences used for the standard shortcuts differ between platforms, you still need to test your shortcuts on each platform to ensure that you do not unintentionally assign the same key sequence to many actions.</source>
          <target state="translated">표준 바로 가기에 사용되는 키 시퀀스는 플랫폼마다 다르기 때문에 실수로 동일한 키 시퀀스를 여러 작업에 할당하지 않도록 각 플랫폼에서 바로 가기를 테스트해야합니다.</target>
        </trans-unit>
        <trans-unit id="9bd7a320ce92353b5113f62cc37ecce8ac345b0e" translate="yes" xml:space="preserve">
          <source>Note the &quot;File|Open&quot; translator comment. It is by no means necessary, but it provides some context for the human translator.</source>
          <target state="translated">&quot;File | Open&quot;번역기 주석을 참고하십시오. 꼭 필요한 것은 아니지만 인간 번역가에게 어떤 맥락을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="0522066d7f03424028785446ce22d3cdef7a0ca4" translate="yes" xml:space="preserve">
          <source>Note the &lt;a href=&quot;qml-var&quot;&gt;var&lt;/a&gt; basic type is a generic placeholder type that can hold any type of value, including lists and objects:</source>
          <target state="translated">메모 &lt;a href=&quot;qml-var&quot;&gt;VAR&lt;/a&gt; 기본 유형의 목록과 객체를 포함하여 모든 유형의 값을 보유 할 수있는 일반적인 자리 표시 자 유형입니다 :</target>
        </trans-unit>
        <trans-unit id="0f17514825465d5f3f0a627fbf90f410ab85e603" translate="yes" xml:space="preserve">
          <source>Note the QML engine may create QNetworkAccessManager instances from multiple threads. Because of this, the implementation of the &lt;a href=&quot;qqmlnetworkaccessmanagerfactory#create&quot;&gt;create&lt;/a&gt;() method must be &lt;a href=&quot;qrandomgenerator#reentrancy-and-thread-safety&quot;&gt;reentrant&lt;/a&gt;. In addition, the developer should be careful if the signals of the object to be returned from &lt;a href=&quot;qqmlnetworkaccessmanagerfactory#create&quot;&gt;create&lt;/a&gt;() are connected to the slots of an object that may be created in a different thread:</source>
          <target state="translated">QML 엔진은 여러 스레드에서 QNetworkAccessManager 인스턴스를 작성할 수 있습니다. 이 때문에 &lt;a href=&quot;qqmlnetworkaccessmanagerfactory#create&quot;&gt;create&lt;/a&gt; () 메소드 의 구현은 &lt;a href=&quot;qrandomgenerator#reentrancy-and-thread-safety&quot;&gt;재진입&lt;/a&gt; 해야 합니다 . 또한 &lt;a href=&quot;qqmlnetworkaccessmanagerfactory#create&quot;&gt;create&lt;/a&gt; () 에서 반환 할 객체의 신호가 다른 스레드에서 생성 될 수있는 객체의 슬롯에 연결되어 있으면 개발자는주의해야합니다 .</target>
        </trans-unit>
        <trans-unit id="457645881dd7a7d5647156a25ba16527f591f1e4" translate="yes" xml:space="preserve">
          <source>Note the call to &lt;a href=&quot;qml-qtqml-models-listmodel#sync-method&quot;&gt;sync()&lt;/a&gt; from the external thread. You must call &lt;a href=&quot;qml-qtqml-models-listmodel#sync-method&quot;&gt;sync()&lt;/a&gt; or else the changes made to the list from that thread will not be reflected in the list model in the main thread.</source>
          <target state="translated">외부 스레드에서 &lt;a href=&quot;qml-qtqml-models-listmodel#sync-method&quot;&gt;sync ()&lt;/a&gt; 를 호출하십시오 . &lt;a href=&quot;qml-qtqml-models-listmodel#sync-method&quot;&gt;sync ()&lt;/a&gt; 를 호출해야합니다. 그렇지 않으면 해당 스레드의 목록에 대한 변경 사항이 기본 스레드의 목록 모델에 반영되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="97a1a170d3e29cfdeb313260e434c32b8faf73b2" translate="yes" xml:space="preserve">
          <source>Note the current brush color will</source>
          <target state="translated">현재 브러시 색상은</target>
        </trans-unit>
        <trans-unit id="0490e9fa13b04981f734ba9d05c2fd1eb2ef9b45" translate="yes" xml:space="preserve">
          <source>Note the difference between Point and DevicePixel. The Point unit is defined to be 1/72th of an inch, while the DevicePixel unit is resolution dependant and is based on the actual pixels, or dots, on the printer.</source>
          <target state="translated">Point와 DevicePixel의 차이점에 유의하십시오. Point 단위는 1/72 인치로 정의되는 반면 DevicePixel 단위는 해상도에 따라 달라지며 프린터의 실제 픽셀 또는 도트를 기준으로합니다.</target>
        </trans-unit>
        <trans-unit id="ea2735b34bd29497a534f65b6c25bab42fad9abb" translate="yes" xml:space="preserve">
          <source>Note the difference between creating a connection and opening it. Creating a connection involves creating an instance of class &lt;a href=&quot;qsqldatabase&quot;&gt;QSqlDatabase&lt;/a&gt;. The connection is not usable until it is opened. The following snippet shows how to create a</source>
          <target state="translated">연결 작성과 열기의 차이점에 유의하십시오. 연결을 작성하려면 &lt;a href=&quot;qsqldatabase&quot;&gt;QSqlDatabase&lt;/a&gt; 클래스의 인스턴스를 작성해야합니다 . 연결을 열 때까지 사용할 수 없습니다. 다음 스 니펫은</target>
        </trans-unit>
        <trans-unit id="8a8c8c62538474298f2d6f89349cb72d3ae4f07a" translate="yes" xml:space="preserve">
          <source>Note the flipping of the V coordinate in the shader. As noted above, custom materials, where there is full programmability on shader level, do not offer the &quot;fixed&quot; features of &lt;a href=&quot;qml-qtquick3d-texture&quot;&gt;Texture&lt;/a&gt; and &lt;a href=&quot;qml-qtquick3d-principledmaterial&quot;&gt;PrincipledMaterial&lt;/a&gt;. This means that any transformations to the UV coordinates will need to be applied by the shader. Here we know that the texture is generated via &lt;a href=&quot;qml-qtquick3d-texture#sourceItem-prop&quot;&gt;Texture::sourceItem&lt;/a&gt; and so V needs to be flipped to get something that matches the UV set of the mesh we are using.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da9f3bac3ce742ff213021cd0efab04299c2552c" translate="yes" xml:space="preserve">
          <source>Note the that the current index changes independently from the selection. Also note that this signal will not be emitted when the item model is reset.</source>
          <target state="translated">현재 색인은 선택 항목과 독립적으로 변경됩니다. 또한이 신호는 아이템 모델이 재설정 될 때 방출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d0f5735466600bd8235811043a155da60eb0311d" translate="yes" xml:space="preserve">
          <source>Note the usage of the non-capturing group in order to preserve the meaning of the branch operator inside the pattern.</source>
          <target state="translated">패턴 내에서 분기 연산자의 의미를 유지하기 위해 캡처하지 않은 그룹의 사용법에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="b94322b70cf060e06a3e1d21be33e75e1a89b650" translate="yes" xml:space="preserve">
          <source>Note the use of &lt;a href=&quot;dbus-changes-qt6#qdbuspendingreply&quot;&gt;QDBusPendingReply&lt;/a&gt; to validate the argument types in the reply. If the reply did not contain exactly two arguments (one string and one &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt;), &lt;a href=&quot;qdbuspendingreply#isError&quot;&gt;QDBusPendingReply::isError&lt;/a&gt;() will return true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2aa94b2a2b33d9741c313fc11c4d1be8ccce509e" translate="yes" xml:space="preserve">
          <source>Note the use of &lt;a href=&quot;qdbuspendingreply&quot;&gt;QDBusPendingReply&lt;/a&gt; to validate the argument types in the reply. If the reply did not contain exactly two arguments (one string and one &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt;), &lt;a href=&quot;qdbuspendingreply#isError&quot;&gt;QDBusPendingReply::isError&lt;/a&gt;() will return true.</source>
          <target state="translated">응답에서 인수 유형의 유효성을 검증하기 위해 &lt;a href=&quot;qdbuspendingreply&quot;&gt;QDBusPendingReply&lt;/a&gt; 를 사용 하십시오. 응답에 정확히 두 개의 인수 (하나의 문자열과 하나의 &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; )가 포함되어 있지 않으면 &lt;a href=&quot;qdbuspendingreply#isError&quot;&gt;QDBusPendingReply :: isError&lt;/a&gt; ()가 true를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="fb3aff543cc3e94b5a9c2307b45b8fb60e8e8a15" translate="yes" xml:space="preserve">
          <source>Note the use of &lt;a href=&quot;qlibraryinfo#location&quot;&gt;QLibraryInfo::location&lt;/a&gt;() to locate the Qt translations. Developers should request the path to the translations at run-time by passing &lt;a href=&quot;qlibraryinfo#LibraryLocation-enum&quot;&gt;QLibraryInfo::TranslationsPath&lt;/a&gt; to this function instead of using the &lt;code&gt;QTDIR&lt;/code&gt; environment variable in their applications.</source>
          <target state="translated">의 사용을 참고 &lt;a href=&quot;qlibraryinfo#location&quot;&gt;QLibraryInfo :: 위치를&lt;/a&gt; Qt의 번역을 찾습니다 (). 개발자는 애플리케이션에서 &lt;code&gt;QTDIR&lt;/code&gt; 환경 변수 를 사용하는 대신 &lt;a href=&quot;qlibraryinfo#LibraryLocation-enum&quot;&gt;QLibraryInfo :: TranslationsPath&lt;/a&gt; 를이 함수 에 전달하여 런타임시 변환 경로를 요청해야 합니다.</target>
        </trans-unit>
        <trans-unit id="3e10129aa30a305341640458143cf780001e0cea" translate="yes" xml:space="preserve">
          <source>Note the use of &lt;code&gt;color&lt;/code&gt; property with qualifier. The properties of the object are not replicated in the &lt;code&gt;model&lt;/code&gt; object, as they are easily available via the &lt;code&gt;modelData&lt;/code&gt; object.</source>
          <target state="translated">한정자와 함께 &lt;code&gt;color&lt;/code&gt; 속성을 사용하십시오 . &lt;code&gt;modelData&lt;/code&gt; 객체 를 통해 쉽게 사용할 수 있으므로 객체의 속성이 &lt;code&gt;model&lt;/code&gt; 객체에 복제되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="f2685686550ede11896f818d026b3d2e975d41ed" translate="yes" xml:space="preserve">
          <source>Note this automatically binds &lt;code&gt;rect.height&lt;/code&gt; to &lt;code&gt;container.height&lt;/code&gt; in the</source>
          <target state="translated">이것은 &lt;code&gt;rect.height&lt;/code&gt; 를 &lt;code&gt;container.height&lt;/code&gt; 에 자동으로 바인딩 합니다.</target>
        </trans-unit>
        <trans-unit id="7018b656be5605f0ddd3254949f47568a2e66ed0" translate="yes" xml:space="preserve">
          <source>Note this property is not updated when the action is disabled.</source>
          <target state="translated">조치가 사용 불가능하면이 특성이 업데이트되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0256e529e1940145606192ebb2fa70115940cdaa" translate="yes" xml:space="preserve">
          <source>Note too that the abbreviation is not guaranteed to be a unique value, i.e. different time zones may have the same abbreviation.</source>
          <target state="translated">약어가 고유 한 값으로 보장되지는 않습니다. 즉, 다른 시간대는 동일한 약어를 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4faa9d3b2625f7fbbe11052162233f2055bb4b14" translate="yes" xml:space="preserve">
          <source>Note when requesting additional graphics queues: Qt itself always requests a graphics queue, you'll need to search queueCreateInfo for the appropriate entry and manipulate it to obtain the additional queue.</source>
          <target state="translated">추가 그래픽 대기열을 요청할 때 참고 : Qt 자체는 항상 그래픽 대기열을 요청하며, 적절한 항목에 대해 queueCreateInfo를 검색하고 추가 대기열을 얻기 위해 조작해야합니다.</target>
        </trans-unit>
        <trans-unit id="4e38c4da838574c6cd034f77421795ed1c17d896" translate="yes" xml:space="preserve">
          <source>Note you have to set the cache directory before it will work.</source>
          <target state="translated">캐시 디렉토리가 작동하기 전에 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="9aa7e3e5f6fa53a2d7fce7c8b8387be69c4d1f27" translate="yes" xml:space="preserve">
          <source>Note, due to limitations of the &lt;a href=&quot;qqmlpropertymap&quot;&gt;QQmlPropertyMap&lt;/a&gt;, it is not possible to declaratively specify the attributes in QML, assignment of attributes keys and values can only be accomplished by JavaScript.</source>
          <target state="translated">&lt;a href=&quot;qqmlpropertymap&quot;&gt;QQmlPropertyMap의&lt;/a&gt; 한계로 인해 QML에서 속성을 선언적으로 지정할 수 없으며 속성 키 및 값 지정은 JavaScript를 통해서만 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f3fddddb658aece21f52afd821c4c0e915aff84e" translate="yes" xml:space="preserve">
          <source>Note, due to limitations of the &lt;a href=&quot;qqmlpropertymap&quot;&gt;QQmlPropertyMap&lt;/a&gt;, it is not possible to declaratively specify the contact details in QML, it can only be accomplished via JavaScript.</source>
          <target state="translated">&lt;a href=&quot;qqmlpropertymap&quot;&gt;QQmlPropertyMap의&lt;/a&gt; 제한으로 인해 QML에서 연락처 세부 사항을 선언적으로 지정할 수 없으며 JavaScript를 통해서만 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="49a37c77c162052dc566987d9605d8eb850d7e55" translate="yes" xml:space="preserve">
          <source>Note, due to limitations of the &lt;a href=&quot;qqmlpropertymap&quot;&gt;QQmlPropertyMap&lt;/a&gt;, it is not possible to declaratively specify the parameters in QML, assignment of parameters keys and values can only be accomplished by JavaScript.</source>
          <target state="translated">&lt;a href=&quot;qqmlpropertymap&quot;&gt;QQmlPropertyMap의&lt;/a&gt; 한계로 인해 QML에서 매개 변수를 선언적으로 지정할 수 없으며 매개 변수 키 및 값 지정은 JavaScript를 통해서만 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e4ad8ae6f2d0015b04551a085b8f299dba5d0c38" translate="yes" xml:space="preserve">
          <source>Note, however, if this object was registered with the &lt;a href=&quot;qdbusconnection#RegisterOption-enum&quot;&gt;ExportChildObjects&lt;/a&gt; option, UnregisterNode will unregister the child objects too.</source>
          <target state="translated">그러나이 객체가 &lt;a href=&quot;qdbusconnection#RegisterOption-enum&quot;&gt;ExportChildObjects&lt;/a&gt; 옵션으로 등록 된 경우 UnregisterNode는 하위 객체도 등록 취소합니다.</target>
        </trans-unit>
        <trans-unit id="48ba44dd910ef14bd3b6e50fccfce5e590e68682" translate="yes" xml:space="preserve">
          <source>Note, however, that it is almost always preferable to define a small struct to hold the result of a function with multiple return values. A struct trivially generalizes to more than two values, and allows more descriptive member names than &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;second&lt;/code&gt;:</source>
          <target state="translated">그러나 여러 반환 값을 가진 함수의 결과를 보유하도록 작은 구조체를 정의하는 것이 거의 항상 바람직합니다. 구조체는 두 개 이상의 값으로 일반화하고 &lt;code&gt;first&lt;/code&gt; 와 &lt;code&gt;second&lt;/code&gt; 보다 더 설명적인 멤버 이름을 허용합니다 .</target>
        </trans-unit>
        <trans-unit id="e035614c6a973e0e3191c7be5d90bcbac8ae2201" translate="yes" xml:space="preserve">
          <source>Note, however, that the pointer tracking feature has limitations on multiple- or virtual-inheritance (that is, in cases where two different pointer addresses can refer to the same object). In that case, if a pointer is cast to a different type and its value changes, &lt;a href=&quot;qsharedpointer&quot;&gt;QSharedPointer&lt;/a&gt;'s pointer tracking mechanism may fail to detect that the object being tracked is the same.</source>
          <target state="translated">그러나 포인터 추적 기능에는 다중 상속 또는 가상 상속 (즉, 두 개의 서로 다른 포인터 주소가 동일한 객체를 참조 할 수있는 경우)에 제한이 있습니다. 이 경우 포인터가 다른 유형으로 캐스트되고 해당 값이 변경되면 &lt;a href=&quot;qsharedpointer&quot;&gt;QSharedPointer&lt;/a&gt; 의 포인터 추적 메커니즘이 추적중인 오브젝트가 동일한 지를 감지하지 못할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="20aa6a902f87883127c530d8bba0ce569f968f10" translate="yes" xml:space="preserve">
          <source>Note, however, that the pointer tracking feature has limitations on multiple- or virtual-inheritance (that is, in cases where two different pointer addresses can refer to the same object). In that case, if a pointer is cast to a different type and its value changes, QSharedPointer's pointer tracking mechanism may fail to detect that the object being tracked is the same.</source>
          <target state="translated">그러나 포인터 추적 기능에는 다중 또는 가상 상속에 대한 제한이 있습니다 (즉, 두 개의 다른 포인터 주소가 동일한 개체를 참조 할 수있는 경우). 이 경우 포인터가 다른 유형으로 캐스트되고 해당 값이 변경되면 QSharedPointer의 포인터 추적 메커니즘이 추적중인 개체가 동일한 지 감지하지 못할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8cabb9c1b9ab246b52d786de4347c7aa3d923fca" translate="yes" xml:space="preserve">
          <source>Note, however, that this is a parent-child relationship in the context of the QML object tree, not in the context of the visual scene. The concept of a parent-child relationship in a visual scene is provided by the &lt;a href=&quot;qml-qtquick-item&quot;&gt;Item&lt;/a&gt; type from the &lt;code&gt;QtQuick&lt;/code&gt; module, which is the base type for most QML types, as most QML objects are intended to be visually rendered. For example, &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-text&quot;&gt;Text&lt;/a&gt; are both &lt;a href=&quot;qml-qtquick-item&quot;&gt;Item&lt;/a&gt;-based types, and below, a &lt;a href=&quot;qml-qtquick-text&quot;&gt;Text&lt;/a&gt; object has been declared as a visual child of a &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt; object:</source>
          <target state="translated">그러나 이는 시각적 장면의 컨텍스트가 아닌 QML 오브젝트 트리의 컨텍스트에서 상위-하위 관계입니다. 시각적 장면에서 부모-자식 관계의 개념은 대부분의 QML 개체가 시각적으로 렌더링되기 때문에 대부분의 QML 유형의 기본 유형 인 &lt;code&gt;QtQuick&lt;/code&gt; 모듈 의 &lt;a href=&quot;qml-qtquick-item&quot;&gt;항목&lt;/a&gt; 유형에 의해 제공 됩니다. 예를 들어 &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt; 및 &lt;a href=&quot;qml-qtquick-text&quot;&gt;Text&lt;/a&gt; 는 모두 &lt;a href=&quot;qml-qtquick-item&quot;&gt;항목&lt;/a&gt; 기반 유형이며 아래에서 &lt;a href=&quot;qml-qtquick-text&quot;&gt;Text&lt;/a&gt; 객체는 &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt; 객체 의 시각적 자식으로 선언되었습니다 .</target>
        </trans-unit>
        <trans-unit id="c1b7fc3b5df1a065d4d3e96ea28ce4b24d2ddfd0" translate="yes" xml:space="preserve">
          <source>Note, however, that when the conditions specified above are not met, each append or insert of a new item requires allocating the new item on the heap, and this per item allocation will make &lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt; a better choice for use cases that do a lot of appending or inserting, because &lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt; can allocate memory for many items in a single heap allocation.</source>
          <target state="translated">그러나 위에서 지정한 조건이 충족되지 않으면 새 항목을 추가하거나 삽입 할 때마다 새 항목을 힙에 할당해야 &lt;a href=&quot;qvector&quot;&gt;하므로이&lt;/a&gt; 항목 당 할당은 QVector 가 많은 작업을 수행하는 사용 사례에 더 적합한 선택입니다. &lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt; 는 단일 힙 할당에서 많은 항목에 메모리를 할당 할 수 있기 때문에 추가 또는 삽입 .</target>
        </trans-unit>
        <trans-unit id="770b60a6a88ffbbcfc132d6a8676ec57063b0975" translate="yes" xml:space="preserve">
          <source>Note, on X11 this will return the true available geometry only on systems with one monitor and if window manager has set _NET_WORKAREA atom. In all other cases this is equal to &lt;a href=&quot;qscreen#geometry-prop&quot;&gt;geometry&lt;/a&gt;(). This is a limitation in X11 window manager specification.</source>
          <target state="translated">X11에서는 모니터가 하나이고 창 관리자가 _NET_WORKAREA 아톰을 설정 한 경우에만 사용 가능한 실제 형상을 리턴합니다. 다른 모든 경우에는 &lt;a href=&quot;qscreen#geometry-prop&quot;&gt;지오메트리&lt;/a&gt; ()와 같습니다. 이것은 X11 창 관리자 사양의 제한 사항입니다.</target>
        </trans-unit>
        <trans-unit id="83423c198b6099edba08f185f940042d5dba3b79" translate="yes" xml:space="preserve">
          <source>Note:</source>
          <target state="translated">Note:</target>
        </trans-unit>
        <trans-unit id="b5e88146894224937f1c7891daece475f0fd271a" translate="yes" xml:space="preserve">
          <source>Note: &lt;a href=&quot;dbus-changes-qt6#qdbusmessage&quot;&gt;QDBusMessage&lt;/a&gt; objects are shared. Modifications made to the copy will affect the original one as well. See &lt;a href=&quot;qdbusmessage#setDelayedReply&quot;&gt;setDelayedReply&lt;/a&gt;() for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84e99dc1a1b1ed9596d4eabae545d285b9d41c5c" translate="yes" xml:space="preserve">
          <source>Note: &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; is an &lt;a href=&quot;implicit-sharing&quot;&gt;implicitly shared&lt;/a&gt; class. Consequently, if you append to an empty byte array, then the byte array will just share the data held in</source>
          <target state="translated">참고 : &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; 는 &lt;a href=&quot;implicit-sharing&quot;&gt;암시 적으로 공유되는&lt;/a&gt; 클래스입니다. 결과적으로 빈 바이트 배열에 추가하면 바이트 배열은</target>
        </trans-unit>
        <trans-unit id="7dae685be908a255924fa208d7daeb8794b00488" translate="yes" xml:space="preserve">
          <source>Note: &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; is an &lt;a href=&quot;implicit-sharing&quot;&gt;implicitly shared&lt;/a&gt; class. Consequently, if you prepend to an empty byte array, then the byte array will just share the data held in</source>
          <target state="translated">참고 : &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; 는 &lt;a href=&quot;implicit-sharing&quot;&gt;암시 적으로 공유되는&lt;/a&gt; 클래스입니다. 결과적으로 빈 바이트 배열 앞에 추가하면 바이트 배열은</target>
        </trans-unit>
        <trans-unit id="d3f2036bea85d88641d598cd424fd745e5e38f71" translate="yes" xml:space="preserve">
          <source>Note: &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; is an &lt;a href=&quot;implicit-sharing#&quot;&gt;implicitly shared&lt;/a&gt; class. Consequently, if you append to an empty byte array, then the byte array will just share the data held in</source>
          <target state="translated">참고 : &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; 는 &lt;a href=&quot;implicit-sharing#&quot;&gt;암시 적으로 공유 된&lt;/a&gt; 클래스입니다. 결과적으로 빈 바이트 배열에 추가하면 바이트 배열에 저장된 데이터 만 공유됩니다.</target>
        </trans-unit>
        <trans-unit id="0714b456fa13e559c341b9b3f0f15039d75a5e39" translate="yes" xml:space="preserve">
          <source>Note: &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; is an &lt;a href=&quot;implicit-sharing#&quot;&gt;implicitly shared&lt;/a&gt; class. Consequently, if you prepend to an empty byte array, then the byte array will just share the data held in</source>
          <target state="translated">참고 : &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; 는 &lt;a href=&quot;implicit-sharing#&quot;&gt;암시 적으로 공유 된&lt;/a&gt; 클래스입니다. 따라서 빈 바이트 배열을 앞에 추가하면 바이트 배열에 저장된 데이터 만 공유됩니다.</target>
        </trans-unit>
        <trans-unit id="59ba4433b3639dcf072786ab193aaf31b9209727" translate="yes" xml:space="preserve">
          <source>Note: &lt;a href=&quot;qdbusmessage&quot;&gt;QDBusMessage&lt;/a&gt; objects are shared. Modifications made to the copy will affect the original one as well. See &lt;a href=&quot;qdbusmessage#setDelayedReply&quot;&gt;setDelayedReply&lt;/a&gt;() for more information.</source>
          <target state="translated">참고 : &lt;a href=&quot;qdbusmessage&quot;&gt;QDBusMessage&lt;/a&gt; 오브젝트는 공유됩니다. 사본을 수정하면 원본에도 영향을 미칩니다. 자세한 내용은 &lt;a href=&quot;qdbusmessage#setDelayedReply&quot;&gt;setDelayedReply&lt;/a&gt; ()를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c0f7347d06c5e67ee13d15459d29a91851a85a7a" translate="yes" xml:space="preserve">
          <source>Note: &lt;a href=&quot;qdoublespinbox&quot;&gt;QDoubleSpinBox&lt;/a&gt; does not call this function for &lt;a href=&quot;qabstractspinbox#specialValueText-prop&quot;&gt;specialValueText&lt;/a&gt;() and that neither &lt;a href=&quot;qdoublespinbox#prefix-prop&quot;&gt;prefix&lt;/a&gt;() nor &lt;a href=&quot;qdoublespinbox#suffix-prop&quot;&gt;suffix&lt;/a&gt;() should be included in the return value.</source>
          <target state="translated">참고 : &lt;a href=&quot;qdoublespinbox&quot;&gt;QDoubleSpinBox&lt;/a&gt; 는 &lt;a href=&quot;qabstractspinbox#specialValueText-prop&quot;&gt;specialValueText&lt;/a&gt; () 에 대해이 함수를 호출하지 않으며 &lt;a href=&quot;qdoublespinbox#prefix-prop&quot;&gt;접두사&lt;/a&gt; () 또는 &lt;a href=&quot;qdoublespinbox#suffix-prop&quot;&gt;접미사&lt;/a&gt; ()를 반환 값에 포함 하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="68578566da4f2e7968adb08a5d6446e309ee8755" translate="yes" xml:space="preserve">
          <source>Note: &lt;a href=&quot;qdoublespinbox&quot;&gt;QDoubleSpinBox&lt;/a&gt; handles &lt;a href=&quot;qabstractspinbox#specialValueText-prop&quot;&gt;specialValueText&lt;/a&gt;() separately; this function is only concerned with the other values.</source>
          <target state="translated">참고 : &lt;a href=&quot;qdoublespinbox&quot;&gt;QDoubleSpinBox&lt;/a&gt; 는 &lt;a href=&quot;qabstractspinbox#specialValueText-prop&quot;&gt;specialValueText&lt;/a&gt; ()를 개별적으로 처리합니다 . 이 기능은 다른 값에만 관련됩니다.</target>
        </trans-unit>
        <trans-unit id="804dca480fe7343afdc7f41ed3b4c1ea7e159fd8" translate="yes" xml:space="preserve">
          <source>Note: &lt;a href=&quot;qdoublespinbox&quot;&gt;QDoubleSpinBox&lt;/a&gt; will round numbers so they can be displayed with the current precision. In a &lt;a href=&quot;qdoublespinbox&quot;&gt;QDoubleSpinBox&lt;/a&gt; with decimals set to 2, calling &lt;a href=&quot;qdoublespinbox#value-prop&quot;&gt;setValue&lt;/a&gt;(2.555) will cause &lt;a href=&quot;qdoublespinbox#value-prop&quot;&gt;value&lt;/a&gt;() to return 2.56.</source>
          <target state="translated">참고 : &lt;a href=&quot;qdoublespinbox&quot;&gt;QDoubleSpinBox&lt;/a&gt; 는 숫자를 반올림하여 현재 정밀도로 표시 할 수 있습니다. A의 &lt;a href=&quot;qdoublespinbox&quot;&gt;QDoubleSpinBox&lt;/a&gt; 호출 2로 설정 소수와 &lt;a href=&quot;qdoublespinbox#value-prop&quot;&gt;의 setValue&lt;/a&gt; (2.555)를 야기한다 &lt;a href=&quot;qdoublespinbox#value-prop&quot;&gt;값&lt;/a&gt; 2.56을 반환을 ().</target>
        </trans-unit>
        <trans-unit id="3ddd3d1f86fbc11aee9f6d9f1f7bb1133700df6a" translate="yes" xml:space="preserve">
          <source>Note: &lt;a href=&quot;qimage#pixel&quot;&gt;QImage::pixel&lt;/a&gt;() returns the color of the pixel at the given coordinates while QColor::pixel() returns the pixel value of the underlying window system (essentially an index value), so normally you will want to use &lt;a href=&quot;qimage#pixel&quot;&gt;QImage::pixel&lt;/a&gt;() to use a color from an existing image or &lt;a href=&quot;qcolor#rgb&quot;&gt;QColor::rgb&lt;/a&gt;() to use a specific color.</source>
          <target state="translated">참고 : &lt;a href=&quot;qimage#pixel&quot;&gt;QImage :: pixel&lt;/a&gt; ()은 주어진 좌표에서 픽셀의 색상을 반환하는 반면 QColor :: pixel ()는 기본 윈도우 시스템의 픽셀 값 (실제로는 인덱스 값)을 반환하므로 일반적으로 &lt;a href=&quot;qimage#pixel&quot;&gt;QImage&lt;/a&gt; 를 사용하려고합니다 . : pixel () 기존 이미지의 색상을 사용하거나 &lt;a href=&quot;qcolor#rgb&quot;&gt;QColor :: rgb&lt;/a&gt; ()를 사용하여 특정 색상을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="e0b0e12917c710964c3fbeb2647c74aa49de6eb3" translate="yes" xml:space="preserve">
          <source>Note: &lt;a href=&quot;qmainwindow&quot;&gt;QMainWindow&lt;/a&gt; takes ownership of the</source>
          <target state="translated">참고 : &lt;a href=&quot;qmainwindow&quot;&gt;QMainWindow&lt;/a&gt; 는</target>
        </trans-unit>
        <trans-unit id="52b9a6116ba142df7c20b2be74fc4ade8a27806b" translate="yes" xml:space="preserve">
          <source>Note: &lt;a href=&quot;qmodbusclient&quot;&gt;QModbusClient&lt;/a&gt; queues the requests it receives. The number of requests executed in parallel is dependent on the protocol. For example, the HTTP protocol on desktop platforms issues 6 requests in parallel for one host/port combination.</source>
          <target state="translated">참고 : &lt;a href=&quot;qmodbusclient&quot;&gt;QModbusClient&lt;/a&gt; 는 수신 한 요청을 대기열에 넣 습니다. 병렬로 실행되는 요청 수는 프로토콜에 따라 다릅니다. 예를 들어, 데스크탑 플랫폼의 HTTP 프로토콜은 하나의 호스트 / 포트 조합에 대해 6 개의 요청을 병렬로 발행합니다.</target>
        </trans-unit>
        <trans-unit id="3b8f20a9b8aa76e53a9dc43cc79dc44045d9cf36" translate="yes" xml:space="preserve">
          <source>Note: &lt;a href=&quot;qopenglbuffer&quot;&gt;QOpenGLBuffer&lt;/a&gt; does not implement copy-on-write semantics, so</source>
          <target state="translated">참고 : &lt;a href=&quot;qopenglbuffer&quot;&gt;QOpenGLBuffer&lt;/a&gt; 는 기록 중 복사 시맨틱을 구현하지 않으므로</target>
        </trans-unit>
        <trans-unit id="b152a796ad90a95cfb1c48fd622b4be38e87963d" translate="yes" xml:space="preserve">
          <source>Note: &lt;a href=&quot;qremoteobjecthostbase#proxy&quot;&gt;proxy&lt;/a&gt;() needs to be called before reverseProxy(), and a</source>
          <target state="translated">참고 : &lt;a href=&quot;qremoteobjecthostbase#proxy&quot;&gt;proxy&lt;/a&gt; ()를 reverseProxy () 전에 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="317d73c8dc5f15815accced3d65ff2fccfc8c61d" translate="yes" xml:space="preserve">
          <source>Note: &lt;a href=&quot;qspinbox&quot;&gt;QSpinBox&lt;/a&gt; does not call this function for &lt;a href=&quot;qabstractspinbox#specialValueText-prop&quot;&gt;specialValueText&lt;/a&gt;() and that neither &lt;a href=&quot;qspinbox#prefix-prop&quot;&gt;prefix&lt;/a&gt;() nor &lt;a href=&quot;qspinbox#suffix-prop&quot;&gt;suffix&lt;/a&gt;() should be included in the return value.</source>
          <target state="translated">참고 : &lt;a href=&quot;qspinbox&quot;&gt;QSpinBox&lt;/a&gt; 는 &lt;a href=&quot;qabstractspinbox#specialValueText-prop&quot;&gt;specialValueText&lt;/a&gt; () 에 대해이 함수를 호출하지 않으며 &lt;a href=&quot;qspinbox#prefix-prop&quot;&gt;접두사&lt;/a&gt; () 또는 &lt;a href=&quot;qspinbox#suffix-prop&quot;&gt;접미사&lt;/a&gt; ()를 반환 값에 포함 하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="e58f8733e51032c9b285e7bea1e6f72ad4bfa47c" translate="yes" xml:space="preserve">
          <source>Note: &lt;a href=&quot;qspinbox&quot;&gt;QSpinBox&lt;/a&gt; handles &lt;a href=&quot;qabstractspinbox#specialValueText-prop&quot;&gt;specialValueText&lt;/a&gt;() separately; this function is only concerned with the other values.</source>
          <target state="translated">참고 : &lt;a href=&quot;qspinbox&quot;&gt;QSpinBox&lt;/a&gt; 는 &lt;a href=&quot;qabstractspinbox#specialValueText-prop&quot;&gt;specialValueText&lt;/a&gt; ()를 개별적으로 처리합니다 . 이 기능은 다른 값에만 관련됩니다.</target>
        </trans-unit>
        <trans-unit id="0b6cd466d32b185eef4ae40ca60e0cd9a9855804" translate="yes" xml:space="preserve">
          <source>Note: &lt;a href=&quot;qwizard#WizardStyle-enum&quot;&gt;AeroStyle&lt;/a&gt; has effect only on a Windows Vista system with alpha compositing enabled. &lt;a href=&quot;qwizard#WizardStyle-enum&quot;&gt;ModernStyle&lt;/a&gt; is used as a fallback when this condition is not met.</source>
          <target state="translated">참고 : &lt;a href=&quot;qwizard#WizardStyle-enum&quot;&gt;AeroStyle&lt;/a&gt; 은 알파 합성이 활성화 된 Windows Vista 시스템에서만 적용됩니다. 이 조건이 충족되지 않으면 &lt;a href=&quot;qwizard#WizardStyle-enum&quot;&gt;ModernStyle&lt;/a&gt; 이 대체로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8c87eb400f2a7e6c4810cfcf04ff4d9053b7d08b" translate="yes" xml:space="preserve">
          <source>Note: A &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; can store any byte values including '\0's, but most functions that take &lt;code&gt;char *&lt;/code&gt; arguments assume that the data ends at the first '\0' they encounter.</source>
          <target state="translated">참고 : &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; 는 '\ 0'을 포함한 모든 바이트 값을 저장할 수 있지만 &lt;code&gt;char *&lt;/code&gt; 인수를 사용 하는 대부분의 함수 는 데이터가 처음 '\ 0'에서 끝나는 것으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="86f09090a72d1292ad2e5847809cc44e6dd6d5b9" translate="yes" xml:space="preserve">
          <source>Note: A widget receives spontaneous show and hide events when its mapping status is changed by the window system, e.g. a spontaneous hide event when the user minimizes the window, and a spontaneous show event when the window is restored again. After receiving a spontaneous hide event, a widget is still considered visible in the sense of &lt;a href=&quot;qwidget#visible-prop&quot;&gt;isVisible&lt;/a&gt;().</source>
          <target state="translated">참고 : 위젯은 맵핑 상태가 창 시스템에 의해 변경 될 때 자발적 표시 및 숨기기 이벤트를 수신합니다 (예 : 사용자가 창을 최소화 할 때의 자발적 숨기기 이벤트 및 창이 다시 복원 될 때의 자발적 표시 이벤트). 자발적인 숨기기 이벤트를 수신 한 후에도 위젯은 여전히 &lt;a href=&quot;qwidget#visible-prop&quot;&gt;isVisible&lt;/a&gt; () 의 의미로 볼 수있는 것으로 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="021bb30ea7e63b156244933c7c6b2f3738726df6" translate="yes" xml:space="preserve">
          <source>Note: Adjustments to the volume will change the volume of this audio stream, not the global volume.</source>
          <target state="translated">참고 : 볼륨을 조정하면 글로벌 볼륨이 아닌이 오디오 스트림의 볼륨이 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="fb652f7988687ef6963c0c8424de9c5a2cb70e0e" translate="yes" xml:space="preserve">
          <source>Note: As the resource initializers generated by rcc are declared in the global namespace, your calls to &lt;a href=&quot;qdir#Q_INIT_RESOURCE&quot;&gt;Q_INIT_RESOURCE&lt;/a&gt;() also need to be done outside of any namespace.</source>
          <target state="translated">참고 : rcc에 의해 생성 된 리소스 이니셜 라이저가 전역 네임 스페이스에서 선언 &lt;a href=&quot;qdir#Q_INIT_RESOURCE&quot;&gt;되므로 Q_INIT_RESOURCE&lt;/a&gt; ()에 대한 호출 도 네임 스페이스 외부에서 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="86be476e1e41f3c33fa39129c864914babee6f38" translate="yes" xml:space="preserve">
          <source>Note: Be careful with calling functions on the &lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt; itself inside &lt;a href=&quot;qgraphicsitem#itemChange&quot;&gt;itemChange&lt;/a&gt;(), as certain function calls can lead to unwanted recursion. For example, you cannot call &lt;a href=&quot;qgraphicsitem#setPos&quot;&gt;setPos&lt;/a&gt;() in &lt;a href=&quot;qgraphicsitem#itemChange&quot;&gt;itemChange&lt;/a&gt;() on an ItemPositionChange notification, as the &lt;a href=&quot;qgraphicsitem#setPos&quot;&gt;setPos&lt;/a&gt;() function will again call &lt;a href=&quot;qgraphicsitem#itemChange&quot;&gt;itemChange&lt;/a&gt;(ItemPositionChange). Instead, you can return the new, adjusted position from &lt;a href=&quot;qgraphicsitem#itemChange&quot;&gt;itemChange&lt;/a&gt;().</source>
          <target state="translated">참고 : 특정 함수 호출로 인해 원하지 않는 재귀가 발생할 수 있으므로 &lt;a href=&quot;qgraphicsitem#itemChange&quot;&gt;itemChange&lt;/a&gt; () 내 에서 &lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt; 자체의 함수 호출에주의하십시오 . 예를 들어, &lt;a href=&quot;qgraphicsitem#setPos&quot;&gt;setPos&lt;/a&gt; () 함수가 다시 &lt;a href=&quot;qgraphicsitem#itemChange&quot;&gt;itemChange&lt;/a&gt; (ItemPositionChange)를 호출 하므로 ItemPositionChange 알림의 &lt;a href=&quot;qgraphicsitem#setPos&quot;&gt;itemChange&lt;/a&gt; ()에서 &lt;a href=&quot;qgraphicsitem#itemChange&quot;&gt;setPos&lt;/a&gt; ()를 호출 할 수 없습니다 . 대신 &lt;a href=&quot;qgraphicsitem#itemChange&quot;&gt;itemChange&lt;/a&gt; () 에서 조정 된 새 위치를 반환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cf3120fe5e3f07fd563d16a77f0ddc4e0d695732" translate="yes" xml:space="preserve">
          <source>Note: Certain &lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt; functions cannot be called in a reimplementation of this function; see the &lt;a href=&quot;qgraphicsitem#GraphicsItemChange-enum&quot;&gt;GraphicsItemChange&lt;/a&gt; documentation for details.</source>
          <target state="translated">참고 : 특정 &lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt; 함수는이 함수를 다시 구현하여 호출 할 수 없습니다. 자세한 내용은 &lt;a href=&quot;qgraphicsitem#GraphicsItemChange-enum&quot;&gt;GraphicsItemChange&lt;/a&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5758b05de346a1a4ebb5a86db1a4cc1008102f59" translate="yes" xml:space="preserve">
          <source>Note: Corner widgets are designed for &lt;a href=&quot;qtabwidget#TabPosition-enum&quot;&gt;North&lt;/a&gt; and &lt;a href=&quot;qtabwidget#TabPosition-enum&quot;&gt;South&lt;/a&gt; tab positions; other orientations are known to not work properly.</source>
          <target state="translated">참고 : 코너 위젯은 &lt;a href=&quot;qtabwidget#TabPosition-enum&quot;&gt;북쪽&lt;/a&gt; 및 &lt;a href=&quot;qtabwidget#TabPosition-enum&quot;&gt;남쪽&lt;/a&gt; 탭 위치를 위해 설계되었습니다 . 다른 방향은 제대로 작동하지 않는 것으로 알려져 있습니다.</target>
        </trans-unit>
        <trans-unit id="d67b1cd3532b5f1abe1363bda15af7287527982e" translate="yes" xml:space="preserve">
          <source>Note: Despite the different actual character heights, the heights of the bounding rectangles of &quot;Yes&quot; and &quot;yes&quot; are the same.</source>
          <target state="translated">참고 : 실제 문자 높이가 다르더라도 &quot;예&quot;와 &quot;예&quot;의 경계 사각형의 높이는 동일합니다.</target>
        </trans-unit>
        <trans-unit id="be7a4b307e37e09bcf5d6c5635cf5c25f0771c2e" translate="yes" xml:space="preserve">
          <source>Note: Do not delete this reply object in the slot connected to this signal. Use &lt;a href=&quot;qobject#deleteLater&quot;&gt;deleteLater&lt;/a&gt;() instead.</source>
          <target state="translated">참고 :이 신호에 연결된 슬롯에서이 응답 객체를 삭제하지 마십시오. 대신 &lt;a href=&quot;qobject#deleteLater&quot;&gt;deleteLater&lt;/a&gt; ()를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="5f2592308a859edb45d114d9672a367ebfdd77f8" translate="yes" xml:space="preserve">
          <source>Note: Drivers that don't support fetching numerical values with low precision will ignore the precision policy. You can use &lt;a href=&quot;qsqldriver#hasFeature&quot;&gt;QSqlDriver::hasFeature&lt;/a&gt;() to find out whether a driver supports this feature.</source>
          <target state="translated">참고 : 정밀도가 낮은 숫자 값 가져 오기를 지원하지 않는 드라이버는 정밀도 정책을 무시합니다. &lt;a href=&quot;qsqldriver#hasFeature&quot;&gt;QSqlDriver :: hasFeature&lt;/a&gt; ()를 사용 하여 드라이버가이 기능을 지원하는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f7b7d1f0f18fd210ecc37af6c13bd4fd680bc8e9" translate="yes" xml:space="preserve">
          <source>Note: Even a non-null icon might not be able to create valid pixmaps, eg. if the file does not exist or cannot be read.</source>
          <target state="translated">참고 : null이 아닌 아이콘이라도 유효한 픽스맵을 생성하지 못할 수 있습니다. 파일이 없거나 읽을 수없는 경우</target>
        </trans-unit>
        <trans-unit id="49a04c87ce30ac189aa7c5f0ae4c848ea287741b" translate="yes" xml:space="preserve">
          <source>Note: Even though &lt;a href=&quot;qlocalserver&quot;&gt;QLocalServer&lt;/a&gt; will stop accepting new connections after it has reached its maximum number of pending connections, the operating system may still keep them in queue which will result in clients signaling that it is connected.</source>
          <target state="translated">참고 : &lt;a href=&quot;qlocalserver&quot;&gt;QLocalServer&lt;/a&gt; 가 보류중인 최대 연결 수에 도달 한 후 새 연결 수락을 중지 하더라도 운영 체제는 여전히 연결을 대기열에 유지하여 클라이언트가 연결되었음을 알리는 결과를 낳을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bedc7da9e37ada9827eb25ca35673c9a483cdd56" translate="yes" xml:space="preserve">
          <source>Note: Even though this type contains a very limited API, the properties and signals of the implementations are named consistently. For example, if you're only using desktop shell extensions in your compositor, it's safe to access properties such as title, maximized, etc. directly on the &lt;a href=&quot;qml-qtwayland-compositor-shellsurface&quot;&gt;ShellSurface&lt;/a&gt;. See the various implementations for additional properties and signals.</source>
          <target state="translated">참고 :이 유형에는 매우 제한된 API가 포함되어 있지만 구현의 특성 및 신호는 일관되게 이름이 지정됩니다. 예를 들어, 컴포 지터에서 데스크톱 셸 확장 만 사용하는 경우 &lt;a href=&quot;qml-qtwayland-compositor-shellsurface&quot;&gt;ShellSurface에서&lt;/a&gt; 직접 제목, 최대화 등의 속성에 액세스하는 것이 안전합니다 . 추가 속성 및 신호에 대해서는 다양한 구현을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2792a3eee3eca3cda3c0a7fef446fa3ce482dfcf" translate="yes" xml:space="preserve">
          <source>Note: Even though this type contains a very limited API, the properties and signals of the implementations are named consistently. For example, if you're only using desktop shell extensions in your compositor, it's safe to access properties such as title, maximized, etc. directly on the ShellSurface. See the various implementations for additional properties and signals.</source>
          <target state="translated">참고 :이 유형에는 매우 제한된 API가 포함되어 있지만 구현의 속성 및 신호는 일관되게 이름이 지정됩니다. 예를 들어 컴포 지터에서 데스크톱 셸 확장 만 사용하는 경우 ShellSurface에서 직접 제목, 최대화 등의 속성에 액세스하는 것이 안전합니다. 추가 속성 및 신호에 대한 다양한 구현을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="354c3d7dddac02b5c014fa08fc1313ff0935ccc0" translate="yes" xml:space="preserve">
          <source>Note: For database models, &lt;a href=&quot;qsqlquerymodel#lastError&quot;&gt;QSqlQueryModel::lastError&lt;/a&gt;() can be used to retrieve the last error.</source>
          <target state="translated">참고 : 데이터베이스 모델의 경우 &lt;a href=&quot;qsqlquerymodel#lastError&quot;&gt;QSqlQueryModel :: lastError&lt;/a&gt; ()를 사용하여 마지막 오류를 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="da661695fa14edbafa0519f745e3586128d02492" translate="yes" xml:space="preserve">
          <source>Note: For shapes that paint an outline / stroke, it is important to include half the pen width in the bounding rect. It is not necessary to compensate for antialiasing, though.</source>
          <target state="translated">참고 : 윤곽선 / 획을 그리는 모양의 경우 경계 사각형에 펜 너비의 절반을 포함시키는 것이 중요합니다. 그러나 앤티 앨리어싱을 보상 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="1fc0472e9b41c40838b64ee4d0ba870488a5ca38" translate="yes" xml:space="preserve">
          <source>Note: If a button is pressed down by a shortcut key, then auto-repeat is enabled and timed by the system and not by this class. The &lt;a href=&quot;qabstractbutton#pressed&quot;&gt;pressed&lt;/a&gt;(), &lt;a href=&quot;qabstractbutton#released&quot;&gt;released&lt;/a&gt;(), and &lt;a href=&quot;qabstractbutton#clicked&quot;&gt;clicked&lt;/a&gt;() signals will be emitted like in the normal case.</source>
          <target state="translated">참고 : 바로 가기 키로 버튼을 누르면이 클래스가 아닌 시스템에서 자동 반복이 활성화되고 시간이 설정됩니다. &lt;a href=&quot;qabstractbutton#pressed&quot;&gt;가압&lt;/a&gt; (), &lt;a href=&quot;qabstractbutton#released&quot;&gt;릴리스&lt;/a&gt; () 및 &lt;a href=&quot;qabstractbutton#clicked&quot;&gt;클릭&lt;/a&gt; () 신호가 정상적인 경우와 같이 방출된다.</target>
        </trans-unit>
        <trans-unit id="04a72e44a1165050780681c84841c057a9e1ccf9" translate="yes" xml:space="preserve">
          <source>Note: If the</source>
          <target state="translated">참고 :</target>
        </trans-unit>
        <trans-unit id="2c18738c3b39ef8cd6ea1c3ce351d9c380c6102b" translate="yes" xml:space="preserve">
          <source>Note: If the directory is a symbolic link to the root directory this function returns &lt;code&gt;false&lt;/code&gt;. If you want to test for this use &lt;a href=&quot;qdir#canonicalPath&quot;&gt;canonicalPath&lt;/a&gt;(), e.g.</source>
          <target state="translated">참고 : 디렉토리가 루트 디렉토리에 대한 심볼릭 링크 인 경우이 함수는 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 . 이 사용을 테스트하려면 &lt;a href=&quot;qdir#canonicalPath&quot;&gt;canonicalPath&lt;/a&gt; ()를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="9c2f7cdfa370d2b0180cab8886c990fdc7cccff4" translate="yes" xml:space="preserve">
          <source>Note: If the valid range consists of just positive doubles (e.g. 0.0 to 100.0) and</source>
          <target state="translated">참고 : 유효한 범위가 양의 이중으로 구성되어있는 경우 (예 : 0.0 ~ 100.0)</target>
        </trans-unit>
        <trans-unit id="0ac47e48621687308848d598eae2e23e4886403c" translate="yes" xml:space="preserve">
          <source>Note: If the valid range consists of just positive doubles (e.g. 0.0 to 100.0) and input is a negative double then it is rejected. If &lt;a href=&quot;qml-qtquick-doublevalidator#notation-prop&quot;&gt;notation&lt;/a&gt; is set to &lt;a href=&quot;qml-qtquick-doublevalidator&quot;&gt;DoubleValidator&lt;/a&gt;.StandardNotation, and the input contains more digits before the decimal point than a double in the valid range may have, it is also rejected. If &lt;a href=&quot;qml-qtquick-doublevalidator#notation-prop&quot;&gt;notation&lt;/a&gt; is &lt;a href=&quot;qml-qtquick-doublevalidator&quot;&gt;DoubleValidator&lt;/a&gt;.ScientificNotation, and the input is not in the valid range, it is accecpted but invalid. The value may yet become valid by changing the exponent.</source>
          <target state="translated">참고 : 유효 범위가 포지티브 더블 (예 : 0.0 ~ 100.0)로 구성되고 입력이 네거티브 더블 인 경우 거부됩니다. 경우 &lt;a href=&quot;qml-qtquick-doublevalidator#notation-prop&quot;&gt;표기&lt;/a&gt; 로 설정 &lt;a href=&quot;qml-qtquick-doublevalidator&quot;&gt;DoubleValidator&lt;/a&gt; .StandardNotation, 입력이 가질 수있는 유효 범위의 두 배 이상 소수점 자리수 전에 더 포함 또한 거절된다. 경우 &lt;a href=&quot;qml-qtquick-doublevalidator#notation-prop&quot;&gt;표기법&lt;/a&gt; 입니다 &lt;a href=&quot;qml-qtquick-doublevalidator&quot;&gt;DoubleValidator&lt;/a&gt; .ScientificNotation, 입력이 유효한 범위에 있지, 그것은 accecpted하지만 잘못되었습니다. 지수를 변경하여 값이 아직 유효해질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e0d1dd764962d3bdd3e469eba2e805af62a8e6a" translate="yes" xml:space="preserve">
          <source>Note: If the valid range consists of just positive doubles (e.g. 0.0 to 100.0) and input is a negative double then it is rejected. If &lt;a href=&quot;qml-qtquick-doublevalidator#notation-prop&quot;&gt;notation&lt;/a&gt; is set to DoubleValidator.StandardNotation, and the input contains more digits before the decimal point than a double in the valid range may have, it is also rejected. If &lt;a href=&quot;qml-qtquick-doublevalidator#notation-prop&quot;&gt;notation&lt;/a&gt; is DoubleValidator.ScientificNotation, and the input is not in the valid range, it is accecpted but invalid. The value may yet become valid by changing the exponent.</source>
          <target state="translated">참고 : 유효 범위가 양의 double (예 : 0.0 ~ 100.0)로만 구성되고 입력이 음의 double이면 거부됩니다. 경우 &lt;a href=&quot;qml-qtquick-doublevalidator#notation-prop&quot;&gt;표기가&lt;/a&gt; DoubleValidator.StandardNotation로 설정하고, 입력이 가질 수있는 유효 범위의 두 배 이상 소수점 전에 이상의 숫자를 포함합니다, 또한 거부됩니다. 경우 &lt;a href=&quot;qml-qtquick-doublevalidator#notation-prop&quot;&gt;표기&lt;/a&gt; DoubleValidator.ScientificNotation하고, 입력이 유효한 범위에 있지, 그것은 accecpted하지만 잘못되었습니다. 지수를 변경하면 값이 유효해질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b48d6af8a062a0a6bb0e228959da3c163cf1ae0" translate="yes" xml:space="preserve">
          <source>Note: If you have set an external model on the combobox this model will still be cleared when calling this function.</source>
          <target state="translated">참고 : 콤보 박스에서 외부 모델을 설정 한 경우이 함수를 호출하면이 모델이 여전히 지워집니다.</target>
        </trans-unit>
        <trans-unit id="171e440d6d7d2bf25433698cfbf1fc1850eaeb98" translate="yes" xml:space="preserve">
          <source>Note: If you want to use the convenience views (like &lt;a href=&quot;qlistwidget&quot;&gt;QListWidget&lt;/a&gt;, &lt;a href=&quot;qtablewidget&quot;&gt;QTableWidget&lt;/a&gt; or &lt;a href=&quot;qtreewidget&quot;&gt;QTreeWidget&lt;/a&gt;), make sure to call &lt;a href=&quot;qcombobox#setModel&quot;&gt;setModel&lt;/a&gt;() on the combobox with the convenience widgets model before calling this function.</source>
          <target state="translated">참고 : 편의 뷰 ( &lt;a href=&quot;qlistwidget&quot;&gt;QListWidget&lt;/a&gt; , &lt;a href=&quot;qtablewidget&quot;&gt;QTableWidget&lt;/a&gt; 또는 &lt;a href=&quot;qtreewidget&quot;&gt;QTreeWidget 등&lt;/a&gt; )를 사용하려면 이 함수를 호출하기 전에 편의 위젯 모델을 사용하여 콤보 박스에서 &lt;a href=&quot;qcombobox#setModel&quot;&gt;setModel&lt;/a&gt; ()을 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="2a445b8d9c852701207c6aa90e3c66647928b41b" translate="yes" xml:space="preserve">
          <source>Note: In &lt;a href=&quot;qsqltablemodel#EditStrategy-enum&quot;&gt;OnManualSubmit&lt;/a&gt; mode, already submitted changes won't be cleared from the cache when submitAll() fails. This allows transactions to be rolled back and resubmitted without losing data.</source>
          <target state="translated">참고 : &lt;a href=&quot;qsqltablemodel#EditStrategy-enum&quot;&gt;OnManualSubmit&lt;/a&gt; 모드 에서는 submitAll ()이 실패 할 때 이미 제출 된 변경 사항이 캐시에서 지워지지 않습니다. 이를 통해 데이터를 유실하지 않고 트랜잭션을 롤백하고 다시 제출할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a1d9426751fbfe5cc063fa7e344f672a149716d7" translate="yes" xml:space="preserve">
          <source>Note: In other regexp documentation, sets of characters are often called &quot;character classes&quot;.</source>
          <target state="translated">참고 : 다른 regexp 문서에서 문자 세트를 종종 &quot;문자 클래스&quot;라고합니다.</target>
        </trans-unit>
        <trans-unit id="5b754118d68f31118db820e9fad445f7dbe26f9d" translate="yes" xml:space="preserve">
          <source>Note: In this case, the &lt;a href=&quot;qquickview&quot;&gt;QQuickView&lt;/a&gt; does not own the given</source>
          <target state="translated">참고 :이 경우 &lt;a href=&quot;qquickview&quot;&gt;QQuickView&lt;/a&gt; 는 지정된 것을 소유하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f719ef71adc5a6d4d2d725af34752053d631f69b" translate="yes" xml:space="preserve">
          <source>Note: In this case, the &lt;a href=&quot;qquickwidget&quot;&gt;QQuickWidget&lt;/a&gt; does not own the given</source>
          <target state="translated">참고 :이 경우 &lt;a href=&quot;qquickwidget&quot;&gt;QQuickWidget&lt;/a&gt; 은 지정된 것을 소유하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="236ff52e94dc936bf745cd34032030e177de1d37" translate="yes" xml:space="preserve">
          <source>Note: In this case, the QQuickView does not own the given</source>
          <target state="translated">참고 :이 경우 QQuickView는 주어진</target>
        </trans-unit>
        <trans-unit id="f88019c2aee277cf7bb90a9b223b681d18d88b1f" translate="yes" xml:space="preserve">
          <source>Note: In this case, the QQuickWidget does not own the given</source>
          <target state="translated">참고 :이 경우 QQuickWidget은 주어진</target>
        </trans-unit>
        <trans-unit id="148179dae7b711996dbc95957d0bd0794372aacc" translate="yes" xml:space="preserve">
          <source>Note: It can be useful to map the whole rectangle covered by the pixel at</source>
          <target state="translated">참고 : 픽셀로 덮여있는 전체 사각형을 매핑하는 것이 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="39e2aefa92fb04934c477094cea5764f2bd342dc" translate="yes" xml:space="preserve">
          <source>Note: On Mac OS/X, this function is not useful, because there is no way to get the scan code from Carbon or Cocoa. The function always returns 1 (or 0 in the case explained above).</source>
          <target state="translated">참고 : Mac OS / X에서는 Carbon 또는 Cocoa에서 스캔 코드를 가져올 방법이 없으므로이 기능은 유용하지 않습니다. 이 함수는 항상 1 (또는 위에서 설명한 경우 0)을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d6bdf9dd483e6270c3661ed3603ded8ec6b55dfd" translate="yes" xml:space="preserve">
          <source>Note: On Windows, all '\n' characters are written as '\r\n' if &lt;a href=&quot;qtextstream&quot;&gt;QTextStream&lt;/a&gt;'s device or string is opened using the &lt;a href=&quot;qiodevice#OpenModeFlag-enum&quot;&gt;QIODevice::Text&lt;/a&gt; flag.</source>
          <target state="translated">참고 : Windows에서 &lt;a href=&quot;qtextstream&quot;&gt;QIOStream &lt;/a&gt;&lt;a href=&quot;qiodevice#OpenModeFlag-enum&quot;&gt;:: Text&lt;/a&gt; 플래그를 사용하여 QTextStream 의 장치 또는 문자열을 열면 모든 '\ n'문자가 '\ r \ n'으로 기록됩니다 .</target>
        </trans-unit>
        <trans-unit id="bc8675c564e9047e5602b03f70af418dd9b59ce0" translate="yes" xml:space="preserve">
          <source>Note: On Windows, all '\n' characters are written as '\r\n' if &lt;a href=&quot;qtextstream&quot;&gt;QTextStream&lt;/a&gt;'s device or string is opened using the &lt;a href=&quot;qiodevicebase#OpenModeFlag-enum&quot;&gt;QIODevice::Text&lt;/a&gt; flag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3829e14ff495f2dde99a835414b57f64ded09457" translate="yes" xml:space="preserve">
          <source>Note: On macOS, this function is not useful, because there is no way to get the scan code from the system APIs. The function always returns 1 (or 0 in the case explained above).</source>
          <target state="translated">참고 : macOS에서는 시스템 API에서 스캔 코드를 가져올 수있는 방법이 없기 때문에이 함수는 유용하지 않습니다. 이 함수는 항상 1 (또는 위에서 설명한 경우 0)을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="73a102cf7f7ba7056ecc1316b29d20bf2980ab62" translate="yes" xml:space="preserve">
          <source>Note: Only loaded images can be painted on the Canvas item.</source>
          <target state="translated">참고 : 불러 온 이미지 만 캔버스 항목에 페인트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c26301c43160d0fc9db88954e0a281cf19a21bb" translate="yes" xml:space="preserve">
          <source>Note: Passing a</source>
          <target state="translated">참고 : 전달</target>
        </trans-unit>
        <trans-unit id="14552beb959cb14fb3667b85e1a0975fdd96f2d1" translate="yes" xml:space="preserve">
          <source>Note: Passing a negative duration as the</source>
          <target state="translated">참고 : 음수 지속 시간을</target>
        </trans-unit>
        <trans-unit id="aeb65c5d8f8f6d1a30b2c6404b995a75b9eee981" translate="yes" xml:space="preserve">
          <source>Note: Passing a negative number as the</source>
          <target state="translated">참고 : 음수를</target>
        </trans-unit>
        <trans-unit id="a6a6676d4f0e11fd816435a7e6b4bcd8129e3036" translate="yes" xml:space="preserve">
          <source>Note: QDBusMessage objects are shared. Modifications made to the copy will affect the original one as well. See &lt;a href=&quot;qdbusmessage#setDelayedReply&quot;&gt;setDelayedReply&lt;/a&gt;() for more information.</source>
          <target state="translated">참고 : QDBusMessage 객체는 공유됩니다. 사본을 수정하면 원본에도 영향을 미칩니다. 자세한 내용은 &lt;a href=&quot;qdbusmessage#setDelayedReply&quot;&gt;setDelayedReply&lt;/a&gt; ()를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="04a34993a304c5af4cdacc6a2485a3ed901c469b" translate="yes" xml:space="preserve">
          <source>Note: QDoubleSpinBox will round numbers so they can be displayed with the current precision. In a QDoubleSpinBox with decimals set to 2, calling &lt;a href=&quot;qdoublespinbox#value-prop&quot;&gt;setValue&lt;/a&gt;(2.555) will cause &lt;a href=&quot;qdoublespinbox#value-prop&quot;&gt;value&lt;/a&gt;() to return 2.56.</source>
          <target state="translated">참고 : QDoubleSpinBox는 현재 정밀도로 표시 될 수 있도록 숫자를 반올림합니다. 소수가 2로 설정된 QDoubleSpinBox에서 &lt;a href=&quot;qdoublespinbox#value-prop&quot;&gt;setValue&lt;/a&gt; (2.555)를 호출 하면 &lt;a href=&quot;qdoublespinbox#value-prop&quot;&gt;값&lt;/a&gt; ()이 2.56을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e792afb3118791e0a22e006c4e07210d925b398b" translate="yes" xml:space="preserve">
          <source>Note: QModbusClient queues the requests it receives. The number of requests executed in parallel is dependent on the protocol. For example, the HTTP protocol on desktop platforms issues 6 requests in parallel for one host/port combination.</source>
          <target state="translated">참고 : QModbusClient는 수신 한 요청을 큐에 넣습니다. 병렬로 실행되는 요청 수는 프로토콜에 따라 다릅니다. 예를 들어 데스크톱 플랫폼의 HTTP 프로토콜은 하나의 호스트 / 포트 조합에 대해 6 개의 요청을 병렬로 발행합니다.</target>
        </trans-unit>
        <trans-unit id="e7596bf8a482a088ed275cb488e31806f29a528c" translate="yes" xml:space="preserve">
          <source>Note: QOpenGLBuffer does not implement copy-on-write semantics, so</source>
          <target state="translated">참고 : QOpenGLBuffer는 쓰기시 복사 의미를 구현하지 않으므로</target>
        </trans-unit>
        <trans-unit id="630014acec0bf249856e001f98d4a55129a5e774" translate="yes" xml:space="preserve">
          <source>Note: Quantifiers are normally &quot;greedy&quot;. They always match as much text as they can. For example, &lt;b&gt;0+&lt;/b&gt; matches the first zero it finds and all the consecutive zeros after the first zero. Applied to '20005', it matches '2&lt;u&gt;000&lt;/u&gt;5'. Quantifiers can be made non-greedy, see &lt;a href=&quot;qregexp#setMinimal&quot;&gt;setMinimal&lt;/a&gt;().</source>
          <target state="translated">참고 : 수량자는 일반적으로 &quot;욕심&quot;입니다. 그들은 항상 가능한 많은 텍스트를 찾습니다. 예를 들어, &lt;b&gt;0+&lt;/b&gt; 는 찾은 첫 번째 0과 첫 번째 0 이후의 모든 연속 0과 일치합니다. 응용은 '20005', 그것은 '2 일치 &lt;u&gt;000&lt;/u&gt; 5'. 정량 &lt;a href=&quot;qregexp#setMinimal&quot;&gt;자는&lt;/a&gt; 탐욕 스럽지 않게 만들 수 있습니다 . setMinimal ()을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b95774b08b2388e43f509b1489213d5f71a64e22" translate="yes" xml:space="preserve">
          <source>Note: See &lt;a href=&quot;qgraphicsscene#items&quot;&gt;items&lt;/a&gt;() for a definition of which items are considered visible by this function.</source>
          <target state="translated">참고 : 이 기능으로 볼 수있는 항목에 대한 정의는 &lt;a href=&quot;qgraphicsscene#items&quot;&gt;항목&lt;/a&gt; ()을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="95e2ccf507b324f5a38e492c35e67dba46ecc818" translate="yes" xml:space="preserve">
          <source>Note: Setting the default precision policy to</source>
          <target state="translated">참고 : 기본 정밀 정책을</target>
        </trans-unit>
        <trans-unit id="5114530e8b439a53c215fe396d4c6b06cfc2864c" translate="yes" xml:space="preserve">
          <source>Note: Setting the precision policy doesn't affect the currently active query. Call &lt;a href=&quot;qsqlquery#exec-1&quot;&gt;exec&lt;/a&gt;(&lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;) or &lt;a href=&quot;qsqlquery#prepare&quot;&gt;prepare&lt;/a&gt;() in order to activate the policy.</source>
          <target state="translated">참고 : 정밀 정책을 설정해도 현재 활성 쿼리에는 영향을 미치지 않습니다. 정책을 활성화하려면 &lt;a href=&quot;qsqlquery#exec-1&quot;&gt;exec&lt;/a&gt; ( &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; )를 호출 하거나 &lt;a href=&quot;qsqlquery#prepare&quot;&gt;준비&lt;/a&gt; ()하십시오.</target>
        </trans-unit>
        <trans-unit id="c1bbfd21dce8ec6d77caaaefd84531fe0278c8ea" translate="yes" xml:space="preserve">
          <source>Note: Since Qt 4.2 the item delegates query the user property of widgets, and only call this function if the widget has no user property. You can override this behavior by reimplementing &lt;a href=&quot;qabstractitemdelegate#setModelData&quot;&gt;QAbstractItemDelegate::setModelData&lt;/a&gt;() and &lt;a href=&quot;qabstractitemdelegate#setEditorData&quot;&gt;QAbstractItemDelegate::setEditorData&lt;/a&gt;().</source>
          <target state="translated">참고 : Qt 4.2부터 항목 대리자는 위젯의 사용자 속성을 쿼리하고 위젯에 사용자 속성이없는 경우에만이 함수를 호출합니다. &lt;a href=&quot;qabstractitemdelegate#setModelData&quot;&gt;QAbstractItemDelegate :: setModelData&lt;/a&gt; () 및 &lt;a href=&quot;qabstractitemdelegate#setEditorData&quot;&gt;QAbstractItemDelegate :: setEditorData&lt;/a&gt; () 를 다시 구현하여이 동작을 대체 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ad761a3041aed8940086c6a8f3c0154c3ae461f7" translate="yes" xml:space="preserve">
          <source>Note: Subclass implementations must call the base implementation of setUpdateInterval() so that updateInterval() returns the correct value.</source>
          <target state="translated">참고 : 서브 클래스 구현은 updateInterval ()이 올바른 값을 리턴하도록 setUpdateInterval ()의 기본 구현을 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="7c3f9f99be97c24caab457ae61a468f4db1eaa08" translate="yes" xml:space="preserve">
          <source>Note: The</source>
          <target state="translated">참고 :</target>
        </trans-unit>
        <trans-unit id="a1516348cc8bab6b2fec5c09367d23c61b7664df" translate="yes" xml:space="preserve">
          <source>Note: The &lt;a href=&quot;qandroidjniobject&quot;&gt;QAndroidJniObject&lt;/a&gt; will create a new reference to the class</source>
          <target state="translated">참고 : &lt;a href=&quot;qandroidjniobject&quot;&gt;QAndroidJniObject&lt;/a&gt; 는 클래스에 대한 새로운 참조를 생성합니다</target>
        </trans-unit>
        <trans-unit id="79beb4ca2e5542606e776eb5cb0910209462770f" translate="yes" xml:space="preserve">
          <source>Note: The &lt;a href=&quot;qandroidjniobject&quot;&gt;QAndroidJniObject&lt;/a&gt; will hold a reference to the Java object</source>
          <target state="translated">참고 : &lt;a href=&quot;qandroidjniobject&quot;&gt;QAndroidJniObject&lt;/a&gt; 는 Java 객체에 대한 참조를 보유합니다.</target>
        </trans-unit>
        <trans-unit id="4696b1155f2e2108a6249aea1f606afc48e15b2b" translate="yes" xml:space="preserve">
          <source>Note: The Places API considers content objects to be 'retrieve-only' objects. Submission of content to a provider is not a supported use case.</source>
          <target state="translated">참고 : Places API는 콘텐츠 개체를 '검색 전용'개체로 간주합니다. 공급자에게 콘텐츠를 제출하는 것은 지원되는 사용 사례가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="6bcd7d2ca2dca375444d31cb042e9dbf50248762" translate="yes" xml:space="preserve">
          <source>Note: The Places API only supports editorials as 'retrieve-only' objects. Submitting editorials to a provider is not a supported use case.</source>
          <target state="translated">참고 : Places API는 '검색 전용'객체로 편집 만 지원합니다. 공급자에게 편집물을 제출하는 것은 지원되는 사용 사례가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="65b915fd425ca56977f3dcc5c34b98baa57fbac3" translate="yes" xml:space="preserve">
          <source>Note: The Places API only supports images as 'retrieve-only' objects. Submitting images to a provider is not a supported use case.</source>
          <target state="translated">참고 : Places API는 이미지를 '검색 전용'객체로만 지원합니다. 공급자에게 이미지를 제출하는 것은 지원되는 사용 사례가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="9c8f14ae62dfa91b985ab5123e37f47f043c93d4" translate="yes" xml:space="preserve">
          <source>Note: The Places API only supports reviews as 'retrieve-only' objects. Submitting reviews to a provider is not a supported use case.</source>
          <target state="translated">참고 : Places API는 '검색 전용'개체로만 검토를 지원합니다. 공급자에게 리뷰를 제출하는 것은 지원되는 사용 사례가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="9b56cb308cc2c0e4d0ea0bd30709ac127a822518" translate="yes" xml:space="preserve">
          <source>Note: The Places API only supports suppliers as 'retrieve-only' objects. Submitting suppliers to a provider is not a supported use case.</source>
          <target state="translated">참고 : Places API는 공급 업체 만 '검색 전용'객체로 지원합니다. 공급 업체에 공급 업체를 제출하는 것은 지원되는 사용 사례가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="ae1f5a3d12819c613f5bb2b3e99f8e7f612312da" translate="yes" xml:space="preserve">
          <source>Note: The QAndroidJniObject will create a new reference to the class</source>
          <target state="translated">참고 : QAndroidJniObject는 클래스에 대한 새 참조를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="c2fcae4dcacd12ff5100719cb762cf063fbb85d2" translate="yes" xml:space="preserve">
          <source>Note: The QAndroidJniObject will hold a reference to the Java object</source>
          <target state="translated">참고 : QAndroidJniObject는 Java 개체에 대한 참조를 보유합니다.</target>
        </trans-unit>
        <trans-unit id="e86db8b9ac04af938f965ba16f93089f22762f61" translate="yes" xml:space="preserve">
          <source>Note: The actual behaviour if an overflow occurs is driver specific. The Oracle database just returns an error in this case.</source>
          <target state="translated">참고 : 오버플로가 발생할 경우 실제 동작은 드라이버마다 다릅니다. 이 경우 Oracle 데이터베이스는 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0ab7b79e1f9a2ddec2fdb06eaa3b14f7b4328a47" translate="yes" xml:space="preserve">
          <source>Note: The empty (default) prefix is never included in this list; to check for the presence of a default namespace, call &lt;a href=&quot;qxmlnamespacesupport#uri&quot;&gt;uri&lt;/a&gt;() with &quot;&quot; as the argument.</source>
          <target state="translated">참고 : 비어있는 (기본) 접두사는이 목록에 포함되지 않습니다. 기본 네임 스페이스가 있는지 확인하려면 &quot;&quot;를 인수로 사용하여 &lt;a href=&quot;qxmlnamespacesupport#uri&quot;&gt;uri&lt;/a&gt; ()를 호출 하십시오.</target>
        </trans-unit>
        <trans-unit id="8e227f0adddcc229f5176586bedcb57ada68d250" translate="yes" xml:space="preserve">
          <source>Note: The maximum and minimum values will be rounded to match the decimals property.</source>
          <target state="translated">참고 : 최대 값과 최소값은 소수 속성과 일치하도록 반올림됩니다.</target>
        </trans-unit>
        <trans-unit id="47301e6c49ee57a0fee090e4d52e916169d7707c" translate="yes" xml:space="preserve">
          <source>Note: The maximum value will be rounded to match the decimals property.</source>
          <target state="translated">참고 : 최대 값은 소수 속성과 일치하도록 반올림됩니다.</target>
        </trans-unit>
        <trans-unit id="5e7268ef6a20efb90b09064ed3f374023645a3f6" translate="yes" xml:space="preserve">
          <source>Note: The maximum, minimum and value might change as a result of changing this property.</source>
          <target state="translated">참고 :이 속성을 변경하면 최대 값, 최소값 및 값이 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd4afcb854f418a9b88e824e9a6e9efb1fe757cb" translate="yes" xml:space="preserve">
          <source>Note: The minimum value will be rounded to match the decimals property.</source>
          <target state="translated">참고 : 최소값은 소수 속성과 일치하도록 반올림됩니다.</target>
        </trans-unit>
        <trans-unit id="1a1f5acb014e678d493d35fc841720eeb02fe4e3" translate="yes" xml:space="preserve">
          <source>Note: The native modifiers may be 0, even if the key event contains extended information.</source>
          <target state="translated">참고 : 키 이벤트에 확장 정보가 포함되어 있어도 기본 수정자는 0 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1eb8d2d5ec422275aec2de509bdada03cb2ad2b9" translate="yes" xml:space="preserve">
          <source>Note: The native scan code may be 0, even if the key event contains extended information.</source>
          <target state="translated">참고 : 키 이벤트에 확장 정보가 포함되어 있어도 기본 스캔 코드는 0 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d10827b158d22b580bf59a846fee4e9a366a4261" translate="yes" xml:space="preserve">
          <source>Note: The native virtual key may be 0, even if the key event contains extended information.</source>
          <target state="translated">참고 : 키 이벤트에 확장 정보가 포함되어 있어도 기본 가상 키는 0 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="907ba64e174a0575f21b9fa584b252518465f2c8" translate="yes" xml:space="preserve">
          <source>Note: The per-thread data stored is not deleted. Any data left in &lt;a href=&quot;qthreadstorage&quot;&gt;QThreadStorage&lt;/a&gt; is leaked. Make sure that all threads using &lt;a href=&quot;qthreadstorage&quot;&gt;QThreadStorage&lt;/a&gt; have exited before deleting the &lt;a href=&quot;qthreadstorage&quot;&gt;QThreadStorage&lt;/a&gt;.</source>
          <target state="translated">참고 : 저장된 스레드 별 데이터는 삭제되지 않습니다. &lt;a href=&quot;qthreadstorage&quot;&gt;QThreadStorage에&lt;/a&gt; 남아있는 모든 데이터 가 누출됩니다. 사용하는 모든 스레드가 있는지 확인 &lt;a href=&quot;qthreadstorage&quot;&gt;QThreadStorage이&lt;/a&gt; 삭제하기 전에 종료 한 &lt;a href=&quot;qthreadstorage&quot;&gt;QThreadStorage을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8299371722751a1e97afecc9d0d681bda59d4fd7" translate="yes" xml:space="preserve">
          <source>Note: The returned &lt;a href=&quot;qwebsocket&quot;&gt;QWebSocket&lt;/a&gt; object cannot be used from another thread.</source>
          <target state="translated">참고 : 리턴 된 &lt;a href=&quot;qwebsocket&quot;&gt;QWebSocket&lt;/a&gt; 오브젝트는 다른 스레드에서 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3b353eb316210c871c2ffd9eb2e9b96e804de2e0" translate="yes" xml:space="preserve">
          <source>Note: The table's primary key may not contain a relation to another table.</source>
          <target state="translated">참고 : 테이블의 기본 키에는 다른 테이블과의 관계가 포함되어 있지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3840dc20cfd5fdc07ea5d746ae2f42e58bf0d0e3" translate="yes" xml:space="preserve">
          <source>Note: The use of &lt;a href=&quot;qdir#Q_INIT_RESOURCE&quot;&gt;Q_INIT_RESOURCE&lt;/a&gt;() and &lt;a href=&quot;qdir#Q_CLEANUP_RESOURCE&quot;&gt;Q_CLEANUP_RESOURCE&lt;/a&gt;() is not necessary when the resource is built as part of the application.</source>
          <target state="translated">참고 : 자원이 애플리케이션의 일부로 빌드 될 때는 &lt;a href=&quot;qdir#Q_INIT_RESOURCE&quot;&gt;Q_INIT_RESOURCE&lt;/a&gt; () 및 &lt;a href=&quot;qdir#Q_CLEANUP_RESOURCE&quot;&gt;Q_CLEANUP_RESOURCE&lt;/a&gt; ()를 사용할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="ec2f1091c5560a3634fa246cf7b1ce10e45a51be" translate="yes" xml:space="preserve">
          <source>Note: The value will be rounded so it can be displayed with the current setting of decimals.</source>
          <target state="translated">참고 : 값은 반올림되므로 현재 10 진수 설정으로 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5231075cd422ce6151d27df74d445e82000bbb1a" translate="yes" xml:space="preserve">
          <source>Note: There are different date formats with different understandings of negative years. Common human language does not have a year 0. The year after 1BC is 1AD. This understanding is reflected when printing or parsing dates in one of the formats not standardized by ECMAScript. That is: toString(), &lt;a href=&quot;qml-qtqml-date#toLocaleString-method&quot;&gt;toLocaleString()&lt;/a&gt;, toUTCString() and friends. ECMAScript does standardize one format: ISO 8601. This is what you get when you call toISOString(). This format does include a year 0, which is 1BC in other formats. Thus you get different years when printing negative dates with toISOString() and toString().</source>
          <target state="translated">참고 : 음의 연도에 대한 이해가 다른 날짜 형식이 있습니다. 일반적인 휴먼 랭귀지에는 0 년이 없습니다. 1BC 이후 1AD는 1AD입니다. ECMAScript에서 표준화하지 않은 형식 중 하나로 날짜를 인쇄하거나 구문 분석 할 때 이러한 이해가 반영됩니다. 즉 : toString (), &lt;a href=&quot;qml-qtqml-date#toLocaleString-method&quot;&gt;toLocaleString ()&lt;/a&gt; , toUTCString () 및 친구들입니다. ECMAScript는 ISO 8601 형식을 표준화합니다. ISOString ()을 호출하면 얻을 수있는 것입니다. 이 형식에는 연도 0이 포함되며 다른 형식에서는 1BC입니다. 따라서 toISOString () 및 toString ()을 사용하여 음수 날짜를 인쇄하면 연도가 달라집니다.</target>
        </trans-unit>
        <trans-unit id="4e7cfff4dd81ab1993ad11501200382a59be3a1c" translate="yes" xml:space="preserve">
          <source>Note: There is no way for the view to know that the contents of a &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt; has changed. If the &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt; changes, it is necessary to reset the model by calling &lt;a href=&quot;qqmlcontext#setContextProperty&quot;&gt;QQmlContext::setContextProperty&lt;/a&gt;() again.</source>
          <target state="translated">참고 : 뷰가 &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt; 의 내용 이 변경 되었음을 알 수있는 방법이 없습니다 . 는 IF &lt;a href=&quot;qlist&quot;&gt;QList이&lt;/a&gt; 변경, 호출하여 모델을 재설정 할 필요가 &lt;a href=&quot;qqmlcontext#setContextProperty&quot;&gt;QQmlContext :: setContextProperty를&lt;/a&gt; ()를 다시.</target>
        </trans-unit>
        <trans-unit id="97feade5825fbdbeff72e97cf8288957cdc5678f" translate="yes" xml:space="preserve">
          <source>Note: This function can be called anytime before &lt;a href=&quot;qaudioinput#start-1&quot;&gt;start&lt;/a&gt;(), calls to this are ignored after &lt;a href=&quot;qaudioinput#start-1&quot;&gt;start&lt;/a&gt;(). It should not be assumed that the buffer size set is the actual buffer size used, calling &lt;a href=&quot;qaudioinput#bufferSize&quot;&gt;bufferSize&lt;/a&gt;() anytime after &lt;a href=&quot;qaudioinput#start-1&quot;&gt;start&lt;/a&gt;() will return the actual buffer size being used.</source>
          <target state="translated">참고 :이 기능은 언제 전에 호출 할 수 있습니다 &lt;a href=&quot;qaudioinput#start-1&quot;&gt;시작&lt;/a&gt; ()이 호출이 후 무시됩니다 &lt;a href=&quot;qaudioinput#start-1&quot;&gt;시작&lt;/a&gt; (). 버퍼 크기 세트가 사용 된 실제 버퍼 크기라고 가정해서는 안되며 &lt;a href=&quot;qaudioinput#start-1&quot;&gt;start&lt;/a&gt; () 이후에 &lt;a href=&quot;qaudioinput#bufferSize&quot;&gt;bufferSize&lt;/a&gt; ()를 호출 하면 사용중인 실제 버퍼 크기가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="eb4ccaa0bae3191f3c09c1335517de218b6fb82c" translate="yes" xml:space="preserve">
          <source>Note: This function is not reentrant, only one test can run at a time. A test that was executed with qExec() can't run another test via qExec() and threads are not allowed to call qExec() simultaneously.</source>
          <target state="translated">참고 :이 기능은 재진입 할 ​​수 없으며 한 번에 하나의 테스트 만 실행할 수 있습니다. qExec ()로 실행 된 테스트는 qExec ()를 통해 다른 테스트를 실행할 수 없으며 스레드는 qExec ()를 동시에 호출 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f30873e34cf4608d4535f9d1f95d913d3a97ae7c" translate="yes" xml:space="preserve">
          <source>Note: This function returns true even if the &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; that this &lt;a href=&quot;qjsvalue&quot;&gt;QJSValue&lt;/a&gt; wraps has been deleted.</source>
          <target state="translated">참고 :이 함수는 이 &lt;a href=&quot;qjsvalue&quot;&gt;QJSValue가&lt;/a&gt; 랩핑 한 &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 가 삭제 된 경우에도 true를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="7165b39115966b2b555efbbb37e2bec9cb2a0687" translate="yes" xml:space="preserve">
          <source>Note: This is not intended to prevent overwriting of items. The model's implementation of flags() should do that by not returning &lt;a href=&quot;qt#ItemFlag-enum&quot;&gt;Qt::ItemIsDropEnabled&lt;/a&gt;.</source>
          <target state="translated">참고 : 이것은 항목 덮어 쓰기를 방지하기위한 것이 아닙니다. 모델의 flags () 구현은 &lt;a href=&quot;qt#ItemFlag-enum&quot;&gt;Qt :: ItemIsDropEnabled를&lt;/a&gt; 반환하지 않음으로써 그렇게해야합니다 .</target>
        </trans-unit>
        <trans-unit id="080c7cf7c251021d23858c561c9e995b1d687906" translate="yes" xml:space="preserve">
          <source>Note: This is platform specific</source>
          <target state="translated">참고 : 이것은 플랫폼에 따라 다릅니다</target>
        </trans-unit>
        <trans-unit id="e901b4e31ede36978c043da18eac84ec3d00d209" translate="yes" xml:space="preserve">
          <source>Note: This is the recommended read size in bytes.</source>
          <target state="translated">참고 : 권장되는 읽기 크기 (바이트)입니다.</target>
        </trans-unit>
        <trans-unit id="eb95e5137414e58398235720b280de0af028b4ba" translate="yes" xml:space="preserve">
          <source>Note: This macro cannot be used in a namespace. It should be called from main(). If that is not possible, the following workaround can be used to init the resource &lt;code&gt;myapp&lt;/code&gt; from the function &lt;code&gt;MyNamespace::myFunction&lt;/code&gt;:</source>
          <target state="translated">참고 :이 매크로는 네임 스페이스에서 사용할 수 없습니다. main ()에서 호출해야합니다. 이것이 가능하지 않은 경우 다음 해결 방법을 사용하여 &lt;code&gt;MyNamespace::myFunction&lt;/code&gt; 함수에서 &lt;code&gt;myapp&lt;/code&gt; 자원을 초기화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="50494017012c56e4e4ab7a8894682a95d9e9590d" translate="yes" xml:space="preserve">
          <source>Note: This macro cannot be used in a namespace. Please see the &lt;a href=&quot;qdir#Q_INIT_RESOURCE&quot;&gt;Q_INIT_RESOURCE&lt;/a&gt; documentation for a workaround.</source>
          <target state="translated">참고 :이 매크로는 네임 스페이스에서 사용할 수 없습니다. 해결 방법 은 &lt;a href=&quot;qdir#Q_INIT_RESOURCE&quot;&gt;Q_INIT_RESOURCE&lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f83db0c7f230e3d8ae99d9afba3bb1040e862518" translate="yes" xml:space="preserve">
          <source>Note: This method should have been called &quot;safePrepare()&quot;.</source>
          <target state="translated">참고 :이 메소드는 &quot;safePrepare ()&quot;라고합니다.</target>
        </trans-unit>
        <trans-unit id="ee0c7780e8b10d097a2d5158c34d5954a87f3561" translate="yes" xml:space="preserve">
          <source>Note: This property makes most sense for sliders and dials. For scroll bars, the visual effect of the scroll bar subcontrols depends on whether or not the styles understand inverted appearance; most styles ignore this property for scroll bars.</source>
          <target state="translated">참고 :이 속성은 슬라이더와 다이얼에 가장 적합합니다. 스크롤 막대의 경우 스크롤 막대 하위 컨트롤의 시각적 효과는 스타일이 반전 된 모양을 이해하는지 여부에 따라 다릅니다. 대부분의 스타일은 스크롤 막대에 대해이 속성을 무시합니다.</target>
        </trans-unit>
        <trans-unit id="f919932338ca62061eae222d54e731bb1bcd6e84" translate="yes" xml:space="preserve">
          <source>Note: This signal will still be emitted in a case where part of the text is accepted but not all of it is. For example, if there is a maximum length set and the clipboard text is longer than the maximum length when it is pasted.</source>
          <target state="translated">참고 :이 신호는 텍스트의 일부는 받아 들여지지 만 일부는 받아 들여지지 않는 경우에도 계속 방출됩니다. 예를 들어, 최대 길이가 설정되어 있고 클립 보드 텍스트가 붙여 넣을 때 최대 길이보다 긴 경우.</target>
        </trans-unit>
        <trans-unit id="1e882cd8a54a25ea565a9e033d4b6a5c0da2f550" translate="yes" xml:space="preserve">
          <source>Note: To prevent inserting only partly initialized rows into the database, &lt;code&gt;OnFieldChange&lt;/code&gt; will behave like &lt;code&gt;OnRowChange&lt;/code&gt; for newly inserted rows.</source>
          <target state="translated">참고 : 데이터베이스에 부분적으로 만 초기화 행을 삽입 방지하려면, &lt;code&gt;OnFieldChange&lt;/code&gt; 는 같이 행동한다 &lt;code&gt;OnRowChange&lt;/code&gt; 새로 삽입 된 행에 대해.</target>
        </trans-unit>
        <trans-unit id="bd6b357731ba6aaa973da2813d4a32eb08e989e0" translate="yes" xml:space="preserve">
          <source>Note: Unlike the &lt;a href=&quot;qpainterpath&quot;&gt;QPainterPath&lt;/a&gt;, the Canvas API uses the winding fill as the default fill rule. The fillRule property is part of the context rendering state.</source>
          <target state="translated">참고 : &lt;a href=&quot;qpainterpath&quot;&gt;QPainterPath&lt;/a&gt; 와 달리 Canvas API는 와인딩 채우기를 기본 채우기 규칙으로 사용합니다. fillRule 속성은 컨텍스트 렌더링 상태의 일부입니다.</target>
        </trans-unit>
        <trans-unit id="ca99011da016b46a9b5232cf15f94cf491807369" translate="yes" xml:space="preserve">
          <source>Note: Using the locale-aware functions to perform date or time formatting can result in incorrectly formatted times, due to an inconsistency in specification between Qt and JS. ECMA-262 specifies that historical dates should be intrepreted by projecting the current rules for daylight-saving onto past years, while Qt uses historical data (where available) to determine whether daylight-saving was in effect for a given date. Therefore, constructing a Date value in JS and converting it to a string using the locale-aware functions can yield a result incorrect by one hour, if DST is currently in effect, while it was not for the time specified, or vice versa.</source>
          <target state="translated">참고 : 로케일 인식 기능을 사용하여 날짜 또는 시간 형식을 수행하면 Qt와 JS의 사양이 일치하지 않아서 형식이 잘못 지정된 시간이 발생할 수 있습니다. ECMA-262는 일광 절약 시간제에 대한 현재 규칙을 지난 몇 년 동안 투영하여 과거 날짜를 해석하지 않도록 지정하고 Qt는 과거 데이터 (사용 가능한 경우)를 사용하여 지정된 날짜에 일광 절약 효과가 적용되는지 여부를 결정합니다. 따라서 JS에서 Date 값을 구성하고 로케일 인식 함수를 사용하여 문자열로 변환하면 DST가 현재 적용되어 있고 지정된 시간이 아니거나 그 반대 인 경우 1 시간이 지나서 결과가 잘못 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="862dcd96643b4ef94796f1175f6a5ce36da56b6a" translate="yes" xml:space="preserve">
          <source>Note: You should use &lt;a href=&quot;qaction#visible-prop&quot;&gt;QAction::setVisible&lt;/a&gt;() to change the visibility of the widget. Using &lt;a href=&quot;qwidget#visible-prop&quot;&gt;QWidget::setVisible&lt;/a&gt;(), &lt;a href=&quot;qwidget#show&quot;&gt;QWidget::show&lt;/a&gt;() and &lt;a href=&quot;qwidget#hide&quot;&gt;QWidget::hide&lt;/a&gt;() does not work.</source>
          <target state="translated">참고 : 위젯의 가시성을 변경 하려면 &lt;a href=&quot;qaction#visible-prop&quot;&gt;QAction :: setVisible&lt;/a&gt; ()을 사용해야합니다 . &lt;a href=&quot;qwidget#visible-prop&quot;&gt;QWidget :: setVisible&lt;/a&gt; ()을 사용하면 QWidget :: &lt;a href=&quot;qwidget#show&quot;&gt;show&lt;/a&gt; () 및 &lt;a href=&quot;qwidget#hide&quot;&gt;QWidget :: hide&lt;/a&gt; ()가 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f9d24af9fea6d8bc9655c52b9af0f055a644bd7f" translate="yes" xml:space="preserve">
          <source>Note: as of Qt 5.14, change messages are deprecated and should not be used, in particular for properties.</source>
          <target state="translated">참고 : Qt 5.14부터 변경 메시지는 더 이상 사용되지 않으며 특히 속성에 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="95b923e4c210c7f9aaed196d6d6837c7d0e73a22" translate="yes" xml:space="preserve">
          <source>Note: because C++ transforms \'s they must be written</source>
          <target state="translated">참고 : C ++는 \를 변환하므로 반드시 작성해야합니다</target>
        </trans-unit>
        <trans-unit id="68e1985ed0edc769c4c732a0346fbdd01601ce55" translate="yes" xml:space="preserve">
          <source>Note: calling this method will force painting the whole canvas, not just the current canvas visible window.</source>
          <target state="translated">참고 :이 메소드를 호출하면 현재 캔버스 표시 창뿐만 아니라 전체 캔버스를 강제로 페인팅합니다.</target>
        </trans-unit>
        <trans-unit id="ac849d8583ef5be2d44dfa3ef506e19e3b6eef7f" translate="yes" xml:space="preserve">
          <source>Note: components derived from &lt;a href=&quot;qml-qt3d-render-abstractraycaster&quot;&gt;AbstractRayCaster&lt;/a&gt; should not be shared amount multiple entities.</source>
          <target state="translated">참고 : &lt;a href=&quot;qml-qt3d-render-abstractraycaster&quot;&gt;AbstractRayCaster&lt;/a&gt; 에서 파생 된 구성 요소 는 여러 개체를 공유 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="04e9883e0f84b55da215fdacdd20e38639cb210a" translate="yes" xml:space="preserve">
          <source>Note: components derived from AbstractRayCaster should not be shared amount multiple entities.</source>
          <target state="translated">참고 : AbstractRayCaster에서 파생 된 구성 요소는 여러 엔터티를 공유해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="5a402f2f8e3f820595297f1a03a1b19f79e568af" translate="yes" xml:space="preserve">
          <source>Note: do not delete the pointer returned by this function or pass it to another function that could delete it, including creating &lt;a href=&quot;qsharedpointer&quot;&gt;QSharedPointer&lt;/a&gt; or &lt;a href=&quot;qweakpointer&quot;&gt;QWeakPointer&lt;/a&gt; objects.</source>
          <target state="translated">참고 : &lt;a href=&quot;qsharedpointer&quot;&gt;QSharedPointer&lt;/a&gt; 또는 &lt;a href=&quot;qweakpointer&quot;&gt;QWeakPointer&lt;/a&gt; 오브젝트 작성을 포함하여이 함수가 리턴 한 포인터를 삭제하거나 삭제할 수있는 다른 함수로 전달하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="52c2b4ac15d8b9b4a612f76f51386d8066e7c7b1" translate="yes" xml:space="preserve">
          <source>Note: do not subclass &lt;a href=&quot;qdbuscontext&quot;&gt;QDBusContext&lt;/a&gt; and &lt;a href=&quot;qdbusabstractadaptor&quot;&gt;QDBusAbstractAdaptor&lt;/a&gt; at the same time. &lt;a href=&quot;qdbuscontext&quot;&gt;QDBusContext&lt;/a&gt; should appear in the real object, not the adaptor. If it's necessary from the adaptor code to determine the context, use a public inheritance and access the functions via &lt;a href=&quot;qobject#parent&quot;&gt;QObject::parent&lt;/a&gt;().</source>
          <target state="translated">참고 : &lt;a href=&quot;qdbuscontext&quot;&gt;QDBusContext&lt;/a&gt; 및 &lt;a href=&quot;qdbusabstractadaptor&quot;&gt;QDBusAbstractAdaptor&lt;/a&gt; 를 동시에 서브 클래스하지 마십시오 . &lt;a href=&quot;qdbuscontext&quot;&gt;QDBusContext&lt;/a&gt; 는 어댑터가 아닌 실제 객체에 나타나야합니다. 컨텍스트를 판별하기 위해 어댑터 코드에서 필요한 경우 공용 상속을 사용하고 &lt;a href=&quot;qobject#parent&quot;&gt;QObject :: parent&lt;/a&gt; () 를 통해 함수에 액세스하십시오 .</target>
        </trans-unit>
        <trans-unit id="370e9e16faf64767f2448b9344b1a33a15eb34d4" translate="yes" xml:space="preserve">
          <source>Note: do not subclass QDBusContext and &lt;a href=&quot;qdbusabstractadaptor&quot;&gt;QDBusAbstractAdaptor&lt;/a&gt; at the same time. QDBusContext should appear in the real object, not the adaptor. If it's necessary from the adaptor code to determine the context, use a public inheritance and access the functions via &lt;a href=&quot;qobject#parent&quot;&gt;QObject::parent&lt;/a&gt;().</source>
          <target state="translated">참고 : QDBusContext 및 &lt;a href=&quot;qdbusabstractadaptor&quot;&gt;QDBusAbstractAdaptor&lt;/a&gt; 를 동시에 하위 클래스 화하지 마십시오 . QDBusContext는 어댑터가 아닌 실제 객체에 나타나야합니다. 컨텍스트를 확인하기 위해 어댑터 코드에서 필요한 경우 공용 상속을 사용하고 &lt;a href=&quot;qobject#parent&quot;&gt;QObject :: parent&lt;/a&gt; () 를 통해 함수에 액세스합니다 .</target>
        </trans-unit>
        <trans-unit id="b265356b6831e6a9e72c3cdb38e5b285251f0d57" translate="yes" xml:space="preserve">
          <source>Note: if &lt;a href=&quot;qprocess#setProcessChannelMode&quot;&gt;setProcessChannelMode&lt;/a&gt;() was called with an argument of &lt;a href=&quot;qprocess#ProcessChannelMode-enum&quot;&gt;QProcess::MergedChannels&lt;/a&gt;, this function has no effect.</source>
          <target state="translated">참고 : &lt;a href=&quot;qprocess#ProcessChannelMode-enum&quot;&gt;QProcess :: MergedChannels&lt;/a&gt; 의 인수로 &lt;a href=&quot;qprocess#setProcessChannelMode&quot;&gt;setProcessChannelMode&lt;/a&gt; ()를 호출 한 경우이 함수는 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ff6c801fb5ecd2c86ff89caf02a8dc54b4757713" translate="yes" xml:space="preserve">
          <source>Note: if the path component of this URL contains a non-UTF-8 binary sequence (such as %80), the behaviour of this function is undefined.</source>
          <target state="translated">참고 :이 URL의 경로 구성 요소에 비 UTF-8 이진 시퀀스 (예 : % 80)가 포함 된 경우이 함수의 동작은 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f61abd2e1b79ab02fae5fe0ef0b76f6dc36d1779" translate="yes" xml:space="preserve">
          <source>Note: returned value is only valid while in &lt;a href=&quot;qaudio#State-enum&quot;&gt;QAudio::ActiveState&lt;/a&gt; or &lt;a href=&quot;qaudio#State-enum&quot;&gt;QAudio::IdleState&lt;/a&gt; state, otherwise returns zero.</source>
          <target state="translated">참고 : 반환 된 값은 &lt;a href=&quot;qaudio#State-enum&quot;&gt;QAudio :: ActiveState&lt;/a&gt; 또는 &lt;a href=&quot;qaudio#State-enum&quot;&gt;QAudio :: IdleState&lt;/a&gt; 상태에있는 동안에 만 유효하며 , 그렇지 않으면 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1b7d3e3f2e581cfd40fa99cf21129360424a976e" translate="yes" xml:space="preserve">
          <source>Note: setting the drag cursor for IgnoreAction may not work on all platforms. X11 and &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; has been tested to work. Windows does not support it.</source>
          <target state="translated">참고 : IgnoreAction에 대해 드래그 커서를 설정하면 일부 플랫폼에서 작동하지 않을 수 있습니다. X11 및 &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; 가 작동하도록 테스트되었습니다. Windows는이를 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5495738edada8af98c914ad646124a067e71c061" translate="yes" xml:space="preserve">
          <source>Note: setting the drag cursor for IgnoreAction may not work on all platforms. X11 and macOS has been tested to work. Windows does not support it.</source>
          <target state="translated">참고 : IgnoreAction에 대한 드래그 커서 설정은 모든 플랫폼에서 작동하지 않을 수 있습니다. X11 및 macOS는 작동하도록 테스트되었습니다. Windows는이를 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f915849c9d13bb240cbebb2628a205376dcb32a1" translate="yes" xml:space="preserve">
          <source>Note: the &lt;a href=&quot;qt#Axis-enum&quot;&gt;Qt::YAxis&lt;/a&gt; rotation for &lt;a href=&quot;qtransform&quot;&gt;QTransform&lt;/a&gt; is inverted from the correct mathematical rotation in 3D space. The &lt;a href=&quot;qgraphicsrotation&quot;&gt;QGraphicsRotation&lt;/a&gt; class implements a correct mathematical rotation. The following two sequences of code will perform the same transformation:</source>
          <target state="translated">참고 : &lt;a href=&quot;qt#Axis-enum&quot;&gt;Qt는 : y 축에&lt;/a&gt; 대한 회전 &lt;a href=&quot;qtransform&quot;&gt;QTransform는&lt;/a&gt; 3D 공간에서 올바른 수학 회전이 반전됩니다. &lt;a href=&quot;qgraphicsrotation&quot;&gt;QGraphicsRotation의&lt;/a&gt; 클래스는 올바른 수학 회전을 구현합니다. 다음 두 코드 시퀀스는 동일한 변환을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="a4fa48ad1e947bc059c3be6c49b0537fe933921d" translate="yes" xml:space="preserve">
          <source>Note: the coordinates will be used for every available render surface as long as they are in the valid range.</source>
          <target state="translated">참고 : 좌표는 유효한 범위에있는 한 사용 가능한 모든 렌더 표면에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="76e45982cb3ecdf2cf3c580a6a13f2bd7e245b20" translate="yes" xml:space="preserve">
          <source>Note: the final rotation is the combined effect of a rotation in 3D space followed by a projection back to 2D. If several rotations are performed in succession, they will not behave as expected unless they were all around the Z axis.</source>
          <target state="translated">참고 : 최종 회전은 3D 공간에서의 회전과 2D 로의 투영의 결합 효과입니다. 여러 회전이 연속적으로 수행되면 모두 Z 축 주위에 있지 않으면 예상대로 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="65876d2ebdc6e5f946603197c0f002209a34cb54" translate="yes" xml:space="preserve">
          <source>Note: the string is not translated. Applications whose interface allow users to parse CBOR streams need to provide their own, translated strings.</source>
          <target state="translated">참고 : 문자열은 번역되지 않습니다. 사용자가 CBOR 스트림을 구문 분석 할 수있는 인터페이스를 가진 응용 프로그램은 번역 된 고유 한 문자열을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="da29b558e382c1e29c7dacdb12ab54b89d89cfaf" translate="yes" xml:space="preserve">
          <source>Note: the template type &lt;code&gt;X&lt;/code&gt; must have the same const and volatile qualifiers as the template of this object, or the cast will fail. Use &lt;a href=&quot;qsharedpointer#constCast&quot;&gt;constCast&lt;/a&gt;() if you need to drop those qualifiers.</source>
          <target state="translated">참고 : 템플릿 유형 &lt;code&gt;X&lt;/code&gt; 에는이 객체의 템플릿과 동일한 const 및 volatile 한정자가 있어야합니다. 그렇지 않으면 캐스트가 실패합니다. 한정자를 삭제해야 할 경우 &lt;a href=&quot;qsharedpointer#constCast&quot;&gt;constCast&lt;/a&gt; ()를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="26ce4a9840bd1302d0e81dffaf937801009bb77a" translate="yes" xml:space="preserve">
          <source>Note: there will always be an &lt;a href=&quot;qml-qtaudioengine-audiocategory&quot;&gt;AudioCategory&lt;/a&gt; named &lt;code&gt;default&lt;/code&gt; whether you explicitly define it or not. If you do not specify any category for a &lt;a href=&quot;qml-qtaudioengine-sound&quot;&gt;Sound&lt;/a&gt;, it will be grouped into the &lt;code&gt;default&lt;/code&gt; category.</source>
          <target state="translated">참고 : 항상있을 것 &lt;a href=&quot;qml-qtaudioengine-audiocategory&quot;&gt;AudioCategory&lt;/a&gt; 라는 이름의 &lt;code&gt;default&lt;/code&gt; 당신이 명시 적으로 정의 여부. &lt;a href=&quot;qml-qtaudioengine-sound&quot;&gt;Sound에&lt;/a&gt; 카테고리를 지정하지 않으면 &lt;code&gt;default&lt;/code&gt; 카테고리 로 그룹화됩니다 .</target>
        </trans-unit>
        <trans-unit id="928f7923179b4eba4c5a07b088fb28d93c48610a" translate="yes" xml:space="preserve">
          <source>Note: there will always be an AudioCategory named &lt;code&gt;default&lt;/code&gt; whether you explicitly define it or not. If you do not specify any category for a &lt;a href=&quot;qml-qtaudioengine-sound&quot;&gt;Sound&lt;/a&gt;, it will be grouped into the &lt;code&gt;default&lt;/code&gt; category.</source>
          <target state="translated">참고 : 항상 AudioCategory 이름이있을 것이다 &lt;code&gt;default&lt;/code&gt; 명시 적으로 정의 여부. &lt;a href=&quot;qml-qtaudioengine-sound&quot;&gt;Sound&lt;/a&gt; 카테고리를 지정하지 않으면 &lt;code&gt;default&lt;/code&gt; 카테고리 로 그룹화됩니다 .</target>
        </trans-unit>
        <trans-unit id="c305bdfff93445e8350fe38014a65da155a61aeb" translate="yes" xml:space="preserve">
          <source>Note: this constructor just creates the &lt;a href=&quot;qopenglbuffer&quot;&gt;QOpenGLBuffer&lt;/a&gt; instance. The actual buffer object in the OpenGL server is not created until &lt;a href=&quot;qopenglbuffer#create&quot;&gt;create&lt;/a&gt;() is called.</source>
          <target state="translated">참고 :이 생성자는 &lt;a href=&quot;qopenglbuffer&quot;&gt;QOpenGLBuffer&lt;/a&gt; 인스턴스를 작성합니다 . &lt;a href=&quot;qopenglbuffer#create&quot;&gt;create&lt;/a&gt; ()가 호출 될 때까지 OpenGL 서버의 실제 버퍼 객체가 생성되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="825e0d321663e7aec105ece0641d433a267bb9d7" translate="yes" xml:space="preserve">
          <source>Note: this constructor just creates the QOpenGLBuffer instance. The actual buffer object in the OpenGL server is not created until &lt;a href=&quot;qopenglbuffer#create&quot;&gt;create&lt;/a&gt;() is called.</source>
          <target state="translated">참고 :이 생성자는 QOpenGLBuffer 인스턴스를 생성합니다. OpenGL 서버의 실제 버퍼 개체는 &lt;a href=&quot;qopenglbuffer#create&quot;&gt;create&lt;/a&gt; ()가 호출 될 때까지 생성 되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="8404a546af066ec1dcae4433df2a21d1b5b1bf4b" translate="yes" xml:space="preserve">
          <source>Note: this function is meant for removing a small application-internal directory (such as a temporary directory), but not user-visible directories. For user-visible operations, it is rather recommended to report errors more precisely to the user, to offer solutions in case of errors, to show progress during the deletion since it could take several minutes, etc.</source>
          <target state="translated">참고 :이 기능은 작은 응용 프로그램 내부 디렉토리 (예 : 임시 디렉토리)는 제거하지만 사용자가 볼 수있는 디렉토리는 제거하지 않습니다. 사용자가 볼 수있는 작업의 경우 오류를보다 정확하게 사용자에게보고하고, 오류가 발생한 경우 솔루션을 제공하고, 삭제하는 동안 몇 분 정도 걸릴 수 있으므로 삭제 진행률을 표시하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="6653079f1063115d641ace31d88de930c5be9ed8" translate="yes" xml:space="preserve">
          <source>Note: this function was part of Qt 3 support in Qt 4.6 and earlier. It has been promoted to official API status in 4.7 to support updating the pixmap's image without creating a new &lt;a href=&quot;qpixmap&quot;&gt;QPixmap&lt;/a&gt; as &lt;a href=&quot;qpixmap#fromImage&quot;&gt;fromImage&lt;/a&gt;() would.</source>
          <target state="translated">참고 :이 기능은 Qt 4.6 이하에서 Qt 3 지원의 일부였습니다. &lt;a href=&quot;qpixmap#fromImage&quot;&gt;fromImage&lt;/a&gt; ()에서 와 같이 새로운 &lt;a href=&quot;qpixmap&quot;&gt;QPixmap&lt;/a&gt; 을 만들지 않고 pixmap의 이미지 업데이트를 지원하기 위해 4.7에서 공식 API 상태로 승격되었습니다 .</target>
        </trans-unit>
        <trans-unit id="7f678a24fcf808a6ae45cd174af7bd26f1c80475" translate="yes" xml:space="preserve">
          <source>Note: this is not the same as the &lt;a href=&quot;qvector3d#crossProduct&quot;&gt;crossProduct&lt;/a&gt;() of</source>
          <target state="translated">참고 : 이것은 &lt;a href=&quot;qvector3d#crossProduct&quot;&gt;교차 제품&lt;/a&gt; ()과 동일하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b6f6e924b699f7006065e1ff6b3e043c83dc9052" translate="yes" xml:space="preserve">
          <source>Note: this is not the same as the &lt;a href=&quot;qvector3d#crossProduct&quot;&gt;crossProduct&lt;/a&gt;() of this vector and</source>
          <target state="translated">참고 : 이것은 이 벡터 의 &lt;a href=&quot;qvector3d#crossProduct&quot;&gt;crossProduct&lt;/a&gt; () 와 같지 않습니다.</target>
        </trans-unit>
        <trans-unit id="32a63c72a58db3c866295ae3e78a540e25076793" translate="yes" xml:space="preserve">
          <source>Note: this method may be called by multiple threads, so ensure the implementation of this method is reentrant.</source>
          <target state="translated">참고 :이 메소드는 여러 스레드에서 호출 할 수 있으므로이 메소드의 구현이 재진입되는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="14272495586217615cc25adeab4b04ae9a865953" translate="yes" xml:space="preserve">
          <source>Note: this method returns true only for elements that can be rendered. Which implies that elements that are considered part of the fill/stroke style properties, e.g. radialGradients even tough marked with &quot;id&quot; attributes will not be found by this method.</source>
          <target state="translated">참고 :이 메서드는 렌더링 할 수있는 요소에 대해서만 true를 반환합니다. 이는 채우기 / 획 스타일 속성의 일부로 간주되는 요소, 예를 들어 &quot;id&quot;속성으로 표시된 방사형 그라디언트는이 방법으로 찾을 수 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="d2df7ff48333ab0e5ac40d21cc942342ad585da5" translate="yes" xml:space="preserve">
          <source>Note: this property's changed() signal is currently emitted only if the whole object changes, not if only the contents of the object change.</source>
          <target state="translated">참고 :이 속성의 changed () 신호는 현재 객체의 내용 만 변경되는 것이 아니라 전체 객체가 변경되는 경우에만 방출됩니다.</target>
        </trans-unit>
        <trans-unit id="7a0b92f2bf074539fdba05ade552b7bd53ca85ff" translate="yes" xml:space="preserve">
          <source>Note: to check for a default prefix, use the &lt;a href=&quot;qxmlnamespacesupport#uri&quot;&gt;uri&lt;/a&gt;() function with an argument of &quot;&quot;.</source>
          <target state="translated">참고 : 기본 접두사를 확인하려면 &lt;a href=&quot;qxmlnamespacesupport#uri&quot;&gt;uri&lt;/a&gt; () 함수를 인수 &quot;&quot;와 함께 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="14ec88f8d6a68fdf9b6f6991bc8d60e334c60463" translate="yes" xml:space="preserve">
          <source>Note: when dealing with remote objects, it is not always possible to determine if it exists when creating a &lt;a href=&quot;qdbusinterface&quot;&gt;QDBusInterface&lt;/a&gt;.</source>
          <target state="translated">참고 : 원격 오브젝트를 처리 할 때 &lt;a href=&quot;qdbusinterface&quot;&gt;QDBusInterface를&lt;/a&gt; 작성할 때 존재하는지 여부를 항상 판별 할 수있는 것은 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="2d608877188f5242e67358cea581b38a5a3bfa95" translate="yes" xml:space="preserve">
          <source>Note:An animation controlled by &lt;a href=&quot;qml-qtquick-animationcontroller&quot;&gt;AnimationController&lt;/a&gt; will always have its &lt;code&gt;running&lt;/code&gt; and &lt;code&gt;paused&lt;/code&gt; properties set to true. It can not be manually started or stopped (much like an animation in a Behavior can not be manually started or stopped).</source>
          <target state="translated">참고 : &lt;a href=&quot;qml-qtquick-animationcontroller&quot;&gt;AnimationController로&lt;/a&gt; 제어되는 애니메이션 은 항상 &lt;code&gt;running&lt;/code&gt; 및 &lt;code&gt;paused&lt;/code&gt; 속성이 true로 설정됩니다. 동작의 애니메이션을 수동으로 시작하거나 중지 할 수없는 것처럼 수동으로 시작하거나 중지 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="b374c1b47330d231078bb4413a030c5c6e9f5525" translate="yes" xml:space="preserve">
          <source>Notes for Perl Users</source>
          <target state="translated">Perl 사용자를위한 참고 사항</target>
        </trans-unit>
        <trans-unit id="4154d75f46826d0d055fd5241282b19935616711" translate="yes" xml:space="preserve">
          <source>Notes for QRegExp Users</source>
          <target state="translated">QRegExp 사용자를위한 참고 사항</target>
        </trans-unit>
        <trans-unit id="932b4cd8d94de09811f785619b04c9d56612ff6d" translate="yes" xml:space="preserve">
          <source>Notes for Universal Windows Platform Users</source>
          <target state="translated">Universal Windows 플랫폼 사용자를위한 참고 사항</target>
        </trans-unit>
        <trans-unit id="9128e4dc19fdcbce3767684f6724986d863634bf" translate="yes" xml:space="preserve">
          <source>Notes for Windows Users</source>
          <target state="translated">Windows 사용자를위한 참고 사항</target>
        </trans-unit>
        <trans-unit id="f8065561874bdf8cf5ca3acfd4a06a024ed512b7" translate="yes" xml:space="preserve">
          <source>Notes for Windows and macOS Users</source>
          <target state="translated">Windows 및 macOS 사용자를위한 참고 사항</target>
        </trans-unit>
        <trans-unit id="15e123abf3898680713e4321c628318d06dc6f4e" translate="yes" xml:space="preserve">
          <source>Notes for X11 Users</source>
          <target state="translated">X11 사용자를위한 참고 사항</target>
        </trans-unit>
        <trans-unit id="f5895a8c3ecb8567fef9e814c81890589257c61a" translate="yes" xml:space="preserve">
          <source>Notes for macOS Users</source>
          <target state="translated">macOS 사용자를위한 참고 사항</target>
        </trans-unit>
        <trans-unit id="2b580f8081df45d58ecf613f9b4e7ae11540fec7" translate="yes" xml:space="preserve">
          <source>Notes on Locale</source>
          <target state="translated">로캘에 대한 참고 사항</target>
        </trans-unit>
        <trans-unit id="f038ea8701df29241a73c1e6e1de3fee1570e938" translate="yes" xml:space="preserve">
          <source>Notes on Possible Issues</source>
          <target state="translated">가능한 문제에 대한 참고 사항</target>
        </trans-unit>
        <trans-unit id="171ac5a3205710042a8cbb0da69a3c49668788cb" translate="yes" xml:space="preserve">
          <source>Notes on Qt Classes</source>
          <target state="translated">Qt 클래스에 대한 참고 사항</target>
        </trans-unit>
        <trans-unit id="74d47d24cb761b24134a09fda747ebc80ed57f58" translate="yes" xml:space="preserve">
          <source>Notes on Use of Notify Signals</source>
          <target state="translated">알림 신호 사용에 대한 참고 사항</target>
        </trans-unit>
        <trans-unit id="026124a1f897d289b0c34a8914fc074da1fea84b" translate="yes" xml:space="preserve">
          <source>Notes on the &lt;code&gt;domXml()&lt;/code&gt; Function</source>
          <target state="translated">&lt;code&gt;domXml()&lt;/code&gt; 함수 에 대한 참고 사항</target>
        </trans-unit>
        <trans-unit id="15a36c675a3fd9923d39fae085bf5c897edc8d7d" translate="yes" xml:space="preserve">
          <source>Notes to Desktop Users</source>
          <target state="translated">데스크톱 사용자를위한 참고 사항</target>
        </trans-unit>
        <trans-unit id="9c3befe7e22c8667bc957541f49b0ee79970b588" translate="yes" xml:space="preserve">
          <source>Notes:</source>
          <target state="translated">Notes:</target>
        </trans-unit>
        <trans-unit id="4481948392a8846400c954e77f58d76cdaa73963" translate="yes" xml:space="preserve">
          <source>Nothing</source>
          <target state="translated">Nothing</target>
        </trans-unit>
        <trans-unit id="b0aa33f02aefe3d763eef2da98aa3d318eb7e0ef" translate="yes" xml:space="preserve">
          <source>Nothing done yet.</source>
          <target state="translated">아직 아무것도하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="87bf71867fcaeaada1d0e2d72f0b00dce542f8de" translate="yes" xml:space="preserve">
          <source>Nothing happens; the mouse event is ignored.</source>
          <target state="translated">아무 반응이 없습니다; 마우스 이벤트는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="98e12c018265814ad4f2c95a2715b3544faeef42" translate="yes" xml:space="preserve">
          <source>Notice how &lt;code&gt;uTime&lt;/code&gt; and &lt;code&gt;uAmplitude&lt;/code&gt; are properties of the CustomMaterial element. They can change values and get animated normally, the values will be exposed to the shaders automatically without any further action from the developer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7ec4abc840bf0e4b54c1deb9d38f9a5936d7d35" translate="yes" xml:space="preserve">
          <source>Notice how the default value is now specified in the persistent setting property, and the actual property is bound to the setting in order to get the initial value from the persistent settings.</source>
          <target state="translated">지속 설정 속성에서 기본값이 어떻게 지정되는지, 지속 설정에서 초기 값을 얻기 위해 실제 속성이 설정에 바인딩됩니다.</target>
        </trans-unit>
        <trans-unit id="bca0eb5fba3b9ccf5248b30bc50d3acb747091bb" translate="yes" xml:space="preserve">
          <source>Notice how the right cylinder ignores the &lt;a href=&quot;qml-qtquick3d-directionallight&quot;&gt;DirectionalLight&lt;/a&gt; in the scene. Its shading knows nothing about scene lighting, the final fragment color is all white.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfe1917f18e5b26391344899687c6a1b328679d1" translate="yes" xml:space="preserve">
          <source>Notice how the sizes of the page items are set by hand. This is because the example uses a plain Container, which does not make any assumptions on the visual layout. It is typically not necessary to specify sizes for items in concrete Container implementations, such as &lt;a href=&quot;qml-qtquick-controls2-swipeview&quot;&gt;SwipeView&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-controls2-tabbar&quot;&gt;TabBar&lt;/a&gt;.</source>
          <target state="translated">페이지 항목의 크기가 어떻게 수동으로 설정되는지 확인하십시오. 이는 예제에서 시각적 레이아웃에 대한 가정을하지 않는 일반 컨테이너를 사용하기 때문입니다. 일반적으로 &lt;a href=&quot;qml-qtquick-controls2-swipeview&quot;&gt;SwipeView&lt;/a&gt; 및 &lt;a href=&quot;qml-qtquick-controls2-tabbar&quot;&gt;TabBar&lt;/a&gt; 와 같은 구체적인 컨테이너 구현에서 항목의 크기를 지정할 필요는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="acfeb5f715ee7224660bc8e6fae8823708d439b7" translate="yes" xml:space="preserve">
          <source>Notice how the sizes of the page items are set by hand. This is because the example uses a plain Container, which does not make any assumptions on the visual layout. It is typically not necessary to specify sizes for items in concrete Container implementations, such as &lt;a href=&quot;qml-qtquick-controls2-swipeview&quot;&gt;SwipeView&lt;/a&gt; and &lt;a href=&quot;qtquickcontrols2-navigation#tabbar&quot;&gt;TabBar&lt;/a&gt;.</source>
          <target state="translated">페이지 항목의 크기가 수동으로 어떻게 설정되는지 확인하십시오. 이는 예제가 일반 컨테이너를 사용하기 때문에 시각적 레이아웃에 대한 가정을하지 않기 때문입니다. 일반적으로 &lt;a href=&quot;qml-qtquick-controls2-swipeview&quot;&gt;SwipeView&lt;/a&gt; 및 &lt;a href=&quot;qtquickcontrols2-navigation#tabbar&quot;&gt;TabBar&lt;/a&gt; 와 같은 구체적인 컨테이너 구현에서 항목의 크기를 지정할 필요는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="051a8a4207d6e90badc250ab22ffb86723eeffe8" translate="yes" xml:space="preserve">
          <source>Notice how the the rounded corners keep their original size, as they are outside the range of the lines.</source>
          <target state="translated">둥근 모서리가 선 범위를 벗어나므로 원래 크기를 유지하는 방법에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="fffb1c32cd0d20c8c8d313553b42beb83ae4b4e7" translate="yes" xml:space="preserve">
          <source>Notice in both instances, &lt;a href=&quot;qml-qtqml-component#createObject-method&quot;&gt;createObject()&lt;/a&gt; is called with &lt;code&gt;appWindow&lt;/code&gt; passed as the parent argument, since the dynamically created object is a visual (Qt Quick) object. The created object will become a child of the &lt;code&gt;appWindow&lt;/code&gt; object in &lt;code&gt;main.qml&lt;/code&gt;, and appear in the scene.</source>
          <target state="translated">동적으로 생성 된 객체는 시각적 (Qt Quick) 객체 이므로 &lt;a href=&quot;qml-qtqml-component#createObject-method&quot;&gt;createObject ()&lt;/a&gt; 는 부모 인수로 전달 된 &lt;code&gt;appWindow&lt;/code&gt; 와 함께 호출됩니다 . 생성 된 객체는의 자식이 될 것이다 &lt;code&gt;appWindow&lt;/code&gt; 의 에서 객체 &lt;code&gt;main.qml&lt;/code&gt; , 장면에 나타납니다.</target>
        </trans-unit>
        <trans-unit id="4cfb568e49b2c6b28b42072911eaf9c2e06d4e5f" translate="yes" xml:space="preserve">
          <source>Notice in the example above that unhandled events are passed to the base class's eventFilter() function, since the base class might have reimplemented eventFilter() for its own internal purposes.</source>
          <target state="translated">위의 예제에서 처리되지 않은 이벤트는 기본 클래스가 자체 내부 목적으로 eventFilter ()를 다시 구현했을 수 있으므로 기본 클래스의 eventFilter () 함수로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="6f333808bd82420a615128b3e13ffe515c8a7857" translate="yes" xml:space="preserve">
          <source>Notice that</source>
          <target state="translated">그것을주의해라</target>
        </trans-unit>
        <trans-unit id="78304d7e8e77b36a776ce2ad135b2bd0f6d967f5" translate="yes" xml:space="preserve">
          <source>Notice that &lt;a href=&quot;https://doc.qt.io/qt-6.0/qtquick-module.html&quot;&gt;QtQuick&lt;/a&gt;.Controls (which is responsible for run-time style selection) is not imported. The fallback style is specified by the qmldir of the style:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e516ae82234af9c4d594398e5101f9fea96882a3" translate="yes" xml:space="preserve">
          <source>Notice that &lt;a href=&quot;qml-qtquick-controls2-scrollbar&quot;&gt;ScrollBar&lt;/a&gt; does not filter key events of the Flickable it is attached to. The following example illustrates how to implement scrolling with up and down keys:</source>
          <target state="translated">것을 알 &lt;a href=&quot;qml-qtquick-controls2-scrollbar&quot;&gt;스크롤 막대&lt;/a&gt; 가 부착되어있는 flickable 한의 키 이벤트를 필터링하지 않습니다. 다음 예제는 위 / 아래 키를 사용하여 스크롤을 구현하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="799db98bca2028bd15e94d904f94e3883d961f62" translate="yes" xml:space="preserve">
          <source>Notice that ScrollBar does not filter key events of the Flickable it is attached to. The following example illustrates how to implement scrolling with up and down keys:</source>
          <target state="translated">ScrollBar는 연결된 Flickable의 키 이벤트를 필터링하지 않습니다. 다음 예제는 위아래 키로 스크롤링을 구현하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="921aed1c6a8c5d44ea24b7d50d64e99e10cb52f9" translate="yes" xml:space="preserve">
          <source>Notice that a URL can be absolute while containing a relative path, and vice versa:</source>
          <target state="translated">상대 경로를 포함하는 동안 URL은 절대적 일 수 있으며 그 반대도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="ef9dfb8cebce27b2d7a89f4af6c3697a06cceef2" translate="yes" xml:space="preserve">
          <source>Notice that all painter settings (&lt;a href=&quot;qpainter#setPen&quot;&gt;setPen&lt;/a&gt;(), &lt;a href=&quot;qpainter#setBrush&quot;&gt;setBrush&lt;/a&gt;() etc.) are reset to default values when begin() is called.</source>
          <target state="translated">begin ()을 호출하면 모든 페인터 설정 ( &lt;a href=&quot;qpainter#setPen&quot;&gt;setPen&lt;/a&gt; (), &lt;a href=&quot;qpainter#setBrush&quot;&gt;setBrush&lt;/a&gt; () 등)이 기본값으로 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="64f6b2e6843e244f70d2e311c4f5a4cad263884c" translate="yes" xml:space="preserve">
          <source>Notice that colorCount() returns 0 for 32-bpp images because these images do not use color tables, but instead encode pixel values as ARGB quadruplets.</source>
          <target state="translated">32bpp 이미지의 경우 colorCount ()는 0을 반환합니다. 이러한 이미지는 색상 표를 사용하지 않고 대신 픽셀 값을 ARGB 4 배로 인코딩합니다.</target>
        </trans-unit>
        <trans-unit id="358a4f242f26241665405b9f9c5590f599c8622a" translate="yes" xml:space="preserve">
          <source>Notice that part of this &lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt; can be outise the visual viewport. It can e.g contain negative values.</source>
          <target state="translated">이 &lt;a href=&quot;qrect&quot;&gt;QRect의&lt;/a&gt; 일부 는 시각적 뷰포트를 능가 할 수 있습니다. 예를 들어 음수 값을 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb3ce21abee2ea6955b6722f2a2f4fe66112f9a6" translate="yes" xml:space="preserve">
          <source>Notice that qDeleteAll() doesn't remove the items from the container; it merely calls &lt;code&gt;delete&lt;/code&gt; on them. In the example above, we call clear() on the container to remove the items.</source>
          <target state="translated">qDeleteAll ()은 컨테이너에서 항목을 제거하지 않습니다. 단지 그것들을 &lt;code&gt;delete&lt;/code&gt; 라고 부릅니다 . 위의 예제에서 컨테이너에서 clear ()를 호출하여 항목을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="e932a7417bbd2e5d5dcf3bdfd0652267becd7808" translate="yes" xml:space="preserve">
          <source>Notice that the &lt;a href=&quot;qml-qtquick-numberanimation&quot;&gt;NumberAnimation&lt;/a&gt; objects above do not need to specify a &lt;code&gt;target&lt;/code&gt; to animate the appropriate item. Also, the &lt;a href=&quot;qml-qtquick-numberanimation&quot;&gt;NumberAnimation&lt;/a&gt; in the &lt;code&gt;addTransition&lt;/code&gt; does not need to specify the &lt;code&gt;to&lt;/code&gt; value to move the item to its correct position in the view. This is because the view implicitly sets the &lt;code&gt;target&lt;/code&gt; and &lt;code&gt;to&lt;/code&gt; values with the correct item and final item position values if these properties are not explicitly defined.</source>
          <target state="translated">위 의 &lt;a href=&quot;qml-qtquick-numberanimation&quot;&gt;NumberAnimation&lt;/a&gt; 객체 는 적절한 항목을 애니메이션하기 위해 &lt;code&gt;target&lt;/code&gt; 을 지정할 필요가 없습니다 . 또한, &lt;a href=&quot;qml-qtquick-numberanimation&quot;&gt;NumberAnimation&lt;/a&gt; 에 &lt;code&gt;addTransition&lt;/code&gt; 는 을 지정할 필요가 없습니다 &lt;code&gt;to&lt;/code&gt; 뷰의 해당 위치로 항목을 이동하는 값. 뷰가 암시 적으로 설정하기 때문입니다 &lt;code&gt;target&lt;/code&gt; 과 &lt;code&gt;to&lt;/code&gt; 이러한 속성이 명시 적으로 정의되지 않은 경우 올바른 항목과 마지막 항목의 위치 값으로 값을.</target>
        </trans-unit>
        <trans-unit id="783a9605d0185646cedd6ee8d4597feda8812ed1" translate="yes" xml:space="preserve">
          <source>Notice that the &lt;a href=&quot;qobject#Q_OBJECT&quot;&gt;Q_OBJECT&lt;/a&gt; macro is mandatory for any object that implements signals, slots or properties. You also need to run the &lt;a href=&quot;moc&quot;&gt;Meta Object Compiler&lt;/a&gt; on the source file. We strongly recommend the use of this macro in all subclasses of &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; regardless of whether or not they actually use signals, slots and properties, since failure to do so may lead certain functions to exhibit strange behavior.</source>
          <target state="translated">있음을 주목 &lt;a href=&quot;qobject#Q_OBJECT&quot;&gt;Q_OBJECT의&lt;/a&gt; 매크로 모든 객체 필수 구현하는 신호들, 슬롯 또는 속성. 소스 파일 에서 &lt;a href=&quot;moc&quot;&gt;Meta Object Compiler도&lt;/a&gt; 실행해야 합니다. 신호, 슬롯 및 속성을 실제로 사용하는지 여부에 관계없이 &lt;a href=&quot;qobject&quot;&gt;QObject의&lt;/a&gt; 모든 서브 클래스에서이 매크로를 사용하는 것이 좋습니다. 그렇지 않으면 특정 기능으로 인해 이상한 동작이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="92220c4bac050d2322c2739024a1d23f844477b4" translate="yes" xml:space="preserve">
          <source>Notice that the &lt;a href=&quot;qobject#Q_OBJECT&quot;&gt;Q_OBJECT&lt;/a&gt; macro is mandatory for any object that implements signals, slots or properties. You also need to run the &lt;a href=&quot;moc&quot;&gt;Meta Object Compiler&lt;/a&gt; on the source file. We strongly recommend the use of this macro in all subclasses of QObject regardless of whether or not they actually use signals, slots and properties, since failure to do so may lead certain functions to exhibit strange behavior.</source>
          <target state="translated">있음을 주목 &lt;a href=&quot;qobject#Q_OBJECT&quot;&gt;Q_OBJECT의&lt;/a&gt; 매크로 모든 객체 필수 구현하는 신호들, 슬롯 또는 속성. 또한 소스 파일 에서 &lt;a href=&quot;moc&quot;&gt;Meta Object Compiler&lt;/a&gt; 를 실행해야 합니다. 실제로 신호, 슬롯 및 속성을 사용하는지 여부에 관계없이 QObject의 모든 하위 클래스에서이 매크로를 사용하는 것이 좋습니다. 그렇게하지 않으면 특정 함수가 이상한 동작을 보일 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="996372cb44362c51c39218414f18924193fffaad" translate="yes" xml:space="preserve">
          <source>Notice that the last conversion returns 1234.0, because '.' is the thousands group separator in the German locale.</source>
          <target state="translated">'.'때문에 마지막 변환은 1234.0을 반환합니다. 독일어 로켈의 천 단위 그룹 구분 기호입니다.</target>
        </trans-unit>
        <trans-unit id="56c0275dae4c44e356cf9be5d26967b463d073ea" translate="yes" xml:space="preserve">
          <source>Notice that the returned item therefore might not belong to this layout, but to a sub-layout.</source>
          <target state="translated">따라서 반환 된 항목은이 레이아웃에 속하지 않고 하위 레이아웃에 속할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a79c1342250a66bcd0681c638ea39ca041d95ce" translate="yes" xml:space="preserve">
          <source>Notice that the value &lt;code&gt;999&lt;/code&gt; returns Intermediate. Values consisting of a number of digits equal to or less than the max value are considered intermediate. This is intended because the digit that prevents a number from being in range is not necessarily the last digit typed. This also means that an intermediate number can have leading zeros.</source>
          <target state="translated">값 &lt;code&gt;999&lt;/code&gt; 는 중간을 반환합니다. 최대 값 이하의 숫자로 구성된 값은 중간으로 간주됩니다. 숫자가 범위 내에 있지 못하도록하는 숫자가 마지막으로 입력 한 숫자가 아니기 때문입니다. 이것은 또한 중간 숫자가 선행 0을 가질 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="8b94f5a054fac52cdc15d198f546c7b6b44609e2" translate="yes" xml:space="preserve">
          <source>Notice that there is no need to implement a copy constructor or an assignment operator for the &lt;code&gt;Employee&lt;/code&gt; class, because the copy constructor and assignment operator provided by the C++ compiler will do the</source>
          <target state="translated">C ++ 컴파일러가 제공하는 복사 생성자 및 할당 연산자 는 &lt;code&gt;Employee&lt;/code&gt; 클래스에 대한 복사 생성자 또는 할당 연산자를 구현할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="9e7eaf1accd82d81afa12a149e8280b58a574ef7" translate="yes" xml:space="preserve">
          <source>Notice that we don't use the &lt;code&gt;widget&lt;/code&gt; argument, except to pass it on to the QWindowStyle::drawPrimitive() function. As mentioned earlier, the information about what is to be drawn and how it should be drawn is specified by a &lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption&lt;/a&gt; object, so there is no need to ask the widget.</source>
          <target state="translated">QWindowStyle :: drawPrimitive () 함수에 전달하는 것 외에는 &lt;code&gt;widget&lt;/code&gt; 인수를 사용하지 않습니다 . 앞에서 언급 한 바와 같이, 무엇을 그리고 어떻게 그려야하는지에 대한 정보는 &lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption&lt;/a&gt; 객체에 의해 지정 되므로 위젯을 요청할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="a4327a529092d6042e6848488acc5a896af35a0e" translate="yes" xml:space="preserve">
          <source>Notice that we use a &lt;a href=&quot;qstyleoptionprogressbar&quot;&gt;QStyleOptionProgressBar&lt;/a&gt; and initialize its members. We can then use the current &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt; to draw it.</source>
          <target state="translated">&lt;a href=&quot;qstyleoptionprogressbar&quot;&gt;QStyleOptionProgressBar를&lt;/a&gt; 사용 하고 멤버를 초기화합니다. 그런 다음 현재 &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt; 을 사용하여 그릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c6ed32a1e528364de2dafc821200655eede755e" translate="yes" xml:space="preserve">
          <source>Notice that when using this &lt;a href=&quot;qtextlayout&quot;&gt;QTextLayout&lt;/a&gt; as part of a &lt;a href=&quot;qtextdocument&quot;&gt;QTextDocument&lt;/a&gt; this method will have no effect.</source>
          <target state="translated">이 사용할 때주의 &lt;a href=&quot;qtextlayout&quot;&gt;QTextLayout을&lt;/a&gt; 의 일환으로 &lt;a href=&quot;qtextdocument&quot;&gt;QTextDocument&lt;/a&gt; 이 방법은 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="36827750343dacc8babe5c6490b79f7e72fedfca" translate="yes" xml:space="preserve">
          <source>Notice that while a &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt; by itself would be automatically rendered and displayed, this is not the case for the above rectangle because it is defined inside a &lt;code&gt;Component&lt;/code&gt;. The component encapsulates the QML types within, as if they were defined in a separate QML file, and is not loaded until requested (in this case, by the two &lt;a href=&quot;qml-qtquick-loader&quot;&gt;Loader&lt;/a&gt; objects). Because Component is not derived from Item, you cannot anchor anything to it.</source>
          <target state="translated">잠시 통지 &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;사각형&lt;/a&gt; 자체가 자동으로 렌더링 및 표시되는 그것이 내부에 정의되어 있기 때문에,이 위의 사각형의 경우에는 해당되지 않습니다 &lt;code&gt;Component&lt;/code&gt; . 컴포넌트는 마치 별도의 QML 파일에 정의 된 것처럼 QML 유형을 캡슐화하고 요청 될 때까지 (이 경우에는 두 개의 &lt;a href=&quot;qml-qtquick-loader&quot;&gt;Loader&lt;/a&gt; 오브젝트에 의해)로드되지 않습니다 . Component는 Item에서 파생되지 않으므로 아무것도 고정 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e9599176e8d8e535c298cec6cc986010a0d0fabd" translate="yes" xml:space="preserve">
          <source>Notice the &lt;a href=&quot;qmetaobject#Q_RETURN_ARG&quot;&gt;Q_RETURN_ARG&lt;/a&gt;() and &lt;a href=&quot;qmetaobject#Q_ARG&quot;&gt;Q_ARG&lt;/a&gt;() arguments for &lt;a href=&quot;qmetaobject#invokeMethod&quot;&gt;QMetaObject::invokeMethod&lt;/a&gt;() must be specified as &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; types, as this is the generic data type used for QML method parameters and return values.</source>
          <target state="translated">통지 &lt;a href=&quot;qmetaobject#Q_RETURN_ARG&quot;&gt;Q_RETURN_ARG&lt;/a&gt; ()와 &lt;a href=&quot;qmetaobject#Q_ARG&quot;&gt;Q_ARG&lt;/a&gt; ()에 인수 &lt;a href=&quot;qmetaobject#invokeMethod&quot;&gt;QMetaObject :: invokeMethod를&lt;/a&gt; ()로 지정해야합니다 &lt;a href=&quot;qvariant&quot;&gt;QVariant의&lt;/a&gt; 이 QML 방법 매개 변수와 반환 값에 사용되는 일반 데이터 유형이 같은 유형.</target>
        </trans-unit>
        <trans-unit id="1acdea36df9b60315c148a5214948c56dc80a427" translate="yes" xml:space="preserve">
          <source>Notice the &lt;a href=&quot;qml-qtquick-rotationanimation&quot;&gt;RotationAnimation&lt;/a&gt; did not need to set a &lt;code&gt;target&lt;/code&gt; value. As a convenience, when used in a transition, &lt;a href=&quot;qml-qtquick-rotationanimation&quot;&gt;RotationAnimation&lt;/a&gt; will rotate all properties named &quot;rotation&quot; or &quot;angle&quot;. You can override this by providing your own properties via &lt;a href=&quot;qml-qtquick-propertyanimation#properties-prop&quot;&gt;properties&lt;/a&gt; or &lt;a href=&quot;qml-qtquick-propertyanimation#property-prop&quot;&gt;property&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-rotationanimation&quot;&gt;RotationAnimation&lt;/a&gt; 이 &lt;code&gt;target&lt;/code&gt; 값 을 설정할 필요가 없었 음을 주목하십시오 . 편의상 전환에 사용될 때 &lt;a href=&quot;qml-qtquick-rotationanimation&quot;&gt;RotationAnimation&lt;/a&gt; 은 &quot;rotation&quot;또는 &quot;angle&quot;이라는 모든 속성을 회전시킵니다. &lt;a href=&quot;qml-qtquick-propertyanimation#properties-prop&quot;&gt;properties&lt;/a&gt; 또는 &lt;a href=&quot;qml-qtquick-propertyanimation#property-prop&quot;&gt;property&lt;/a&gt; 를 통해 고유 한 특성을 제공하여이를 대체 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d88a59b43c1dc89b3dd34dd500db544659a544d4" translate="yes" xml:space="preserve">
          <source>Notice the RotationAnimation did not need to set a &lt;code&gt;target&lt;/code&gt; value. As a convenience, when used in a transition, RotationAnimation will rotate all properties named &quot;rotation&quot; or &quot;angle&quot;. You can override this by providing your own properties via &lt;a href=&quot;qml-qtquick-propertyanimation#properties-prop&quot;&gt;properties&lt;/a&gt; or &lt;a href=&quot;qml-qtquick-propertyanimation#property-prop&quot;&gt;property&lt;/a&gt;.</source>
          <target state="translated">RotationAnimation은 &lt;code&gt;target&lt;/code&gt; 값 을 설정할 필요가 없습니다 . 편의상, 전환에 사용하면 RotationAnimation은 &quot;rotation&quot;또는 &quot;angle&quot;이라는 모든 속성을 회전합니다. &lt;a href=&quot;qml-qtquick-propertyanimation#properties-prop&quot;&gt;속성&lt;/a&gt; 또는 &lt;a href=&quot;qml-qtquick-propertyanimation#property-prop&quot;&gt;속성을&lt;/a&gt; 통해 고유 한 속성을 제공하여이를 재정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f8a0a4d5436d9bd18606a9976301235abace1e6a" translate="yes" xml:space="preserve">
          <source>Notice the default state is referred to using an empty string (&quot;&quot;).</source>
          <target state="translated">기본 상태는 빈 문자열 ( &quot;&quot;)을 사용하여 나타납니다.</target>
        </trans-unit>
        <trans-unit id="09d6f6673cc58f9bbc80d0d53337c40495ad9340" translate="yes" xml:space="preserve">
          <source>Notice the example does not require &lt;a href=&quot;qml-qtquick-propertyanimation#to-prop&quot;&gt;to&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-propertyanimation#from-prop&quot;&gt;from&lt;/a&gt; values for the &lt;a href=&quot;qml-qtquick-numberanimation&quot;&gt;NumberAnimation&lt;/a&gt;. As a convenience, these properties are automatically set to the values of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; before and after the state change; the &lt;code&gt;from&lt;/code&gt; values are provided by the current values of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, and the &lt;code&gt;to&lt;/code&gt; values are provided by the &lt;a href=&quot;qml-qtquick-propertychanges&quot;&gt;PropertyChanges&lt;/a&gt; object. If you wish, you can provide &lt;a href=&quot;qml-qtquick-propertyanimation#to-prop&quot;&gt;to&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-propertyanimation#from-prop&quot;&gt;from&lt;/a&gt; values anyway to override the default values.</source>
          <target state="translated">필요로하지 않는 예를주의 &lt;a href=&quot;qml-qtquick-propertyanimation#to-prop&quot;&gt;로&lt;/a&gt; 와 &lt;a href=&quot;qml-qtquick-propertyanimation#from-prop&quot;&gt;에서&lt;/a&gt; 값 &lt;a href=&quot;qml-qtquick-numberanimation&quot;&gt;NumberAnimation&lt;/a&gt; . 편의상 이러한 속성은 상태 변경 전후 의 &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; 값으로 자동 설정됩니다 . &lt;code&gt;from&lt;/code&gt; 값의 현재 값에 의해 제공되는 &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; , 및 &lt;code&gt;to&lt;/code&gt; 값에 의해 제공된다 &lt;a href=&quot;qml-qtquick-propertychanges&quot;&gt;PropertyChanges의&lt;/a&gt; 개체. 당신이 원한다면, 당신은 제공 할 수 있습니다 &lt;a href=&quot;qml-qtquick-propertyanimation#to-prop&quot;&gt;에&lt;/a&gt; 와 &lt;a href=&quot;qml-qtquick-propertyanimation#from-prop&quot;&gt;에서&lt;/a&gt; 디폴트 값을 대체하기 위하여 어쨌든 값.</target>
        </trans-unit>
        <trans-unit id="a4ed2379c2375a3a4b43ea3203698f5a79e3bb23" translate="yes" xml:space="preserve">
          <source>Notice the parameter and return type specified after the colon. You can use &lt;a href=&quot;qtqml-typesystem-basictypes&quot;&gt;basic types&lt;/a&gt; and &lt;a href=&quot;qtqml-typesystem-objecttypes&quot;&gt;object types&lt;/a&gt; as type names.</source>
          <target state="translated">콜론 뒤에 지정된 매개 변수와 반환 유형을 확인합니다. &lt;a href=&quot;qtqml-typesystem-basictypes&quot;&gt;기본 유형&lt;/a&gt; 및 &lt;a href=&quot;qtqml-typesystem-objecttypes&quot;&gt;객체 유형&lt;/a&gt; 을 유형 이름으로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="301a28dd35706dd94188caf5732576f4fcfd0b24" translate="yes" xml:space="preserve">
          <source>Notice, however, that assigning a &lt;code&gt;currentIndex&lt;/code&gt; value in JavaScript removes the respective binding. In order to retain the bindings, use the following methods to alter the current index:</source>
          <target state="translated">그러나 JavaScript에서 &lt;code&gt;currentIndex&lt;/code&gt; 값 을 할당 하면 각 바인딩이 제거됩니다. 바인딩을 유지하려면 다음 방법을 사용하여 현재 색인을 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="608a0641d7bdd92cb95ef256ba25681da29dffae" translate="yes" xml:space="preserve">
          <source>Notice: this can change the length of the byte array.</source>
          <target state="translated">참고 : 바이트 배열의 길이를 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="30ef0e1394740601cf26701a4ea5795a88609657" translate="yes" xml:space="preserve">
          <source>Noticeable differences between &lt;a href=&quot;graphicsview#qgraphicswidget&quot;&gt;QGraphicsWidget&lt;/a&gt; and &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; are:</source>
          <target state="translated">&lt;a href=&quot;graphicsview#qgraphicswidget&quot;&gt;QGraphicsWidget&lt;/a&gt; 과 &lt;a href=&quot;qwidget&quot;&gt;QWidget의&lt;/a&gt; 현저한 차이점 은 다음 과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9eb2e69230a3f8fb632b4a4beebb6a9094c322ae" translate="yes" xml:space="preserve">
          <source>Noticeable differences between QGraphicsWidget and &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; are:</source>
          <target state="translated">QGraphicsWidget과 &lt;a href=&quot;qwidget&quot;&gt;QWidget의&lt;/a&gt; 눈에 띄는 차이점 은 다음 과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c1520486e4e3179f51fc98c9480023d477bbec2b" translate="yes" xml:space="preserve">
          <source>Noticeable differences between QGraphicsWidget and &lt;a href=&quot;widgets-changes-qt6#qwidget&quot;&gt;QWidget&lt;/a&gt; are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3df8c0589830f636ac9b26d2ab95652cec513937" translate="yes" xml:space="preserve">
          <source>Notification messages</source>
          <target state="translated">알림 메시지</target>
        </trans-unit>
        <trans-unit id="c4510c4d2ce942975c3872cac559615d1262cea6" translate="yes" xml:space="preserve">
          <source>Notification that a &lt;a href=&quot;qml-qtquick-window-window&quot;&gt;Window&lt;/a&gt; is about to be closed. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-window-window&quot;&gt;창&lt;/a&gt; 을 닫으려고 한다는 알림 . &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="57efdaf54afc61de2d504d4ead7821ccde46029e" translate="yes" xml:space="preserve">
          <source>Notification that a &lt;a href=&quot;qml-window&quot;&gt;Window&lt;/a&gt; is about to be closed. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c419caaa36ff0b8fcae8637be5d1503c551b1bda" translate="yes" xml:space="preserve">
          <source>Notification that a window is about to be closed by the windowing system (e.g. the user clicked the title bar close button). The &lt;a href=&quot;qml-qtquick-window-closeevent&quot;&gt;CloseEvent&lt;/a&gt; contains an accepted property which can be set to false to abort closing the window.</source>
          <target state="translated">윈도우 시스템에서 윈도우를 닫으려고한다는 알림 (예 : 사용자가 제목 표시 줄 닫기 버튼을 클릭) &lt;a href=&quot;qml-qtquick-window-closeevent&quot;&gt;CloseEvent은&lt;/a&gt; 창을 닫지 중단 false로 설정할 수있는 허용 속성을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="11984d4a0b103cde0ab28d81e73b46ad89989299" translate="yes" xml:space="preserve">
          <source>Notification that a window is about to be closed by the windowing system (e.g. the user clicked the title bar close button). The CloseEvent contains an accepted property which can be set to false to abort closing the window.</source>
          <target state="translated">윈도우 시스템에 의해 윈도우가 닫힐 것이라는 알림 (예 : 사용자가 제목 표시 줄 닫기 버튼을 클릭 함). CloseEvent에는 창 닫기를 중단하기 위해 false로 설정할 수있는 허용 된 속성이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="b4de0a2ea1f8fb289240f48a6991fd6bcdd41961" translate="yes" xml:space="preserve">
          <source>Notification, such as an incoming e-mail or a chat request</source>
          <target state="translated">수신 이메일 또는 채팅 요청과 같은 알림</target>
        </trans-unit>
        <trans-unit id="a89bdc8b4c76dad33197fd6a72ea0efcb0791742" translate="yes" xml:space="preserve">
          <source>NotificationRole - notification, such as an incoming e-mail or a chat request.</source>
          <target state="translated">NotificationRole-수신 이메일 또는 채팅 요청과 같은 알림</target>
        </trans-unit>
        <trans-unit id="3d07659efe8328b7900d2dbc28d0730d51c73224" translate="yes" xml:space="preserve">
          <source>Notifications for added/removed places/categories</source>
          <target state="translated">추가 / 제거 된 장소 / 카테고리에 대한 알림</target>
        </trans-unit>
        <trans-unit id="db2035ff2dbde4d3fb8a66eefce1115ea04d5af8" translate="yes" xml:space="preserve">
          <source>Notifications of place and category changes is supported.</source>
          <target state="translated">장소 및 카테고리 변경 알림이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="8700e9a6f8044b4edf9a336f37179cf7fcbe215b" translate="yes" xml:space="preserve">
          <source>Notifications on incoming new connections can be received by installing a &lt;a href=&quot;qmodbustcpconnectionobserver&quot;&gt;QModbusTcpConnectionObserver&lt;/a&gt; via &lt;a href=&quot;qmodbustcpserver#installConnectionObserver&quot;&gt;installConnectionObserver&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qmodbustcpserver#installConnectionObserver&quot;&gt;installConnectionObserver&lt;/a&gt; () 를 통해 &lt;a href=&quot;qmodbustcpconnectionobserver&quot;&gt;QModbusTcpConnectionObserver&lt;/a&gt; 를 설치하면 수신되는 새 연결에 대한 알림을받을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0bfacd0e4948553023fe1a031da56e2425dfc2e8" translate="yes" xml:space="preserve">
          <source>Notifies &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; that the scene's scene rect has changed.</source>
          <target state="translated">장면의 장면 사각형이 변경 되었음을 &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; 에 알립니다 .</target>
        </trans-unit>
        <trans-unit id="d3b1348426df0bd9235f66a574bb1d3c08ca3baf" translate="yes" xml:space="preserve">
          <source>Notifies about a change that might be relevant for accessibility clients.</source>
          <target state="translated">내게 필요한 옵션 클라이언트와 관련이있을 수있는 변경 사항을 알립니다.</target>
        </trans-unit>
        <trans-unit id="18f22244c309a222b570b44e6d80617be15c2a84" translate="yes" xml:space="preserve">
          <source>Notifies all connected renderers that the node has dirty</source>
          <target state="translated">연결된 모든 렌더러에게 노드가 더러워 졌음을 알립니다</target>
        </trans-unit>
        <trans-unit id="a5dc10ecc52b17f8bfd34c57fe2f40b608e48771" translate="yes" xml:space="preserve">
          <source>Notifies observers of scene change</source>
          <target state="translated">관찰자에게 장면 변경 알림</target>
        </trans-unit>
        <trans-unit id="96c4c7c784572a4d671015f0ffb45c7578cbe226" translate="yes" xml:space="preserve">
          <source>Notifies that this transform operation has changed its parameters in such a way that &lt;a href=&quot;qgraphicstransform#applyTo&quot;&gt;applyTo&lt;/a&gt;() will return a different result than before.</source>
          <target state="translated">이 변환 조작이 &lt;a href=&quot;qgraphicstransform#applyTo&quot;&gt;applyTo&lt;/a&gt; ()가 이전과 다른 결과를 리턴하는 방식으로 매개 변수를 변경했음을 알립니다 .</target>
        </trans-unit>
        <trans-unit id="fc6cbfb31efc6d1d86482f4b112b2971441ff29c" translate="yes" xml:space="preserve">
          <source>Notifies the attached sensor (if any) that the filter is being destroyed.</source>
          <target state="translated">연결된 센서 (있는 경우)에 필터가 손상되었음을 알립니다.</target>
        </trans-unit>
        <trans-unit id="65b074b3f524475fa0e3b36b0a9240510b37a9d2" translate="yes" xml:space="preserve">
          <source>Notifies the layout system that this widget has changed and may need to change geometry.</source>
          <target state="translated">이 위젯이 변경되었으며 형상을 변경해야 할 수도 있음을 레이아웃 시스템에 알립니다.</target>
        </trans-unit>
        <trans-unit id="0fe668534b0c3627f437220f47c1f4c8486cde95" translate="yes" xml:space="preserve">
          <source>Notifies you when the geometry of the layout is set. You can store the geometry in your own layout class in a reimplementation of this function.</source>
          <target state="translated">레이아웃 지오메트리가 설정되면 알려줍니다. 이 함수를 다시 구현하여 자신의 레이아웃 클래스에 형상을 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f79af4520f90c6792580eda73038648f198214c" translate="yes" xml:space="preserve">
          <source>Notify input method on updated query values if needed.</source>
          <target state="translated">필요한 경우 업데이트 된 쿼리 값에 대한 입력 방법을 통지하십시오.</target>
        </trans-unit>
        <trans-unit id="d5ab18dcc84c48e8636bdced3422891e7427ee35" translate="yes" xml:space="preserve">
          <source>Notify that both &lt;a href=&quot;qt3drender-qblendequationarguments#destinationRgb-prop&quot;&gt;destinationRgb&lt;/a&gt; and &lt;a href=&quot;qt3drender-qblendequationarguments#destinationAlpha-prop&quot;&gt;destinationAlpha&lt;/a&gt; properties have changed to</source>
          <target state="translated">&lt;a href=&quot;qt3drender-qblendequationarguments#destinationRgb-prop&quot;&gt;destinationRgb&lt;/a&gt; 및 &lt;a href=&quot;qt3drender-qblendequationarguments#destinationAlpha-prop&quot;&gt;destinationAlpha&lt;/a&gt; 속성이 모두 로 변경 되었음을 알립니다.</target>
        </trans-unit>
        <trans-unit id="21fbad56849646ffa4eeaadf69c76d517b9fb66e" translate="yes" xml:space="preserve">
          <source>Notify that both &lt;a href=&quot;qt3drender-qblendequationarguments#sourceRgb-prop&quot;&gt;sourceRgb&lt;/a&gt; and &lt;a href=&quot;qt3drender-qblendequationarguments#sourceAlpha-prop&quot;&gt;sourceAlpha&lt;/a&gt; properties have changed to</source>
          <target state="translated">&lt;a href=&quot;qt3drender-qblendequationarguments#sourceRgb-prop&quot;&gt;sourceRgb&lt;/a&gt; 및 &lt;a href=&quot;qt3drender-qblendequationarguments#sourceAlpha-prop&quot;&gt;sourceAlpha&lt;/a&gt; 속성이 모두 다음으로 변경 되었음을 알립니다.</target>
        </trans-unit>
        <trans-unit id="6452884aa35fe617ac701e02fabe909fa0b0cf08" translate="yes" xml:space="preserve">
          <source>Notify the &lt;a href=&quot;qsensor&quot;&gt;QSensor&lt;/a&gt; class that a new reading is available.</source>
          <target state="translated">새로운 판독 값을 사용할 수 있음을 &lt;a href=&quot;qsensor&quot;&gt;QSensor&lt;/a&gt; 클래스에 알립니다 .</target>
        </trans-unit>
        <trans-unit id="8f91bb394c0242cbf37ac2bce6c581dd193d61ea" translate="yes" xml:space="preserve">
          <source>November (10)</source>
          <target state="translated">11 월 (10)</target>
        </trans-unit>
        <trans-unit id="aee655620aa23c92d0397381050cd566a5bbade9" translate="yes" xml:space="preserve">
          <source>Now &lt;a href=&quot;q3dbars&quot;&gt;Q3DBars&lt;/a&gt; is ready to receive data to be rendered. Create a series with one row of 5 values:</source>
          <target state="translated">이제 &lt;a href=&quot;q3dbars&quot;&gt;Q3DBars&lt;/a&gt; 는 렌더링 할 데이터를 수신 할 준비가되었습니다. 한 행의 5 개 값으로 시리즈를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="9be3eba733b149dcecd1825ffa838e3b93c31cc6" translate="yes" xml:space="preserve">
          <source>Now &lt;a href=&quot;q3dscatter&quot;&gt;Q3DScatter&lt;/a&gt; is ready to receive data to be rendered. Add one series of 3 &lt;a href=&quot;qvector3d&quot;&gt;QVector3D&lt;/a&gt; items:</source>
          <target state="translated">이제 &lt;a href=&quot;q3dscatter&quot;&gt;Q3DScatter&lt;/a&gt; 는 렌더링 할 데이터를 수신 할 준비가되었습니다. 일련의 3 가지 &lt;a href=&quot;qvector3d&quot;&gt;QVector3D&lt;/a&gt; 항목 추가 :</target>
        </trans-unit>
        <trans-unit id="331c0db8cef25cfe0cebfe904f7923432bb91b78" translate="yes" xml:space="preserve">
          <source>Now &lt;a href=&quot;q3dsurface&quot;&gt;Q3DSurface&lt;/a&gt; is ready to receive data to be rendered. Create data elements to receive values:</source>
          <target state="translated">이제 &lt;a href=&quot;q3dsurface&quot;&gt;Q3DSurface&lt;/a&gt; 는 렌더링 할 데이터를 수신 할 준비가되었습니다. 값을 수신 할 데이터 요소를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="2db0a3fc9fe56423c21081ea7b6602b05a9ffae8" translate="yes" xml:space="preserve">
          <source>Now &lt;code&gt;delegateItem.ListView.isCurrentItem&lt;/code&gt; correctly refers to the &lt;code&gt;isCurrentItem&lt;/code&gt; attached property of the delegate.</source>
          <target state="translated">이제 &lt;code&gt;delegateItem.ListView.isCurrentItem&lt;/code&gt; 은 대리자 의 &lt;code&gt;isCurrentItem&lt;/code&gt; 연결된 속성을 올바르게 참조합니다 .</target>
        </trans-unit>
        <trans-unit id="8d3217923237246bece6e90e72225f9d002e3b9a" translate="yes" xml:space="preserve">
          <source>Now Q3DBars is ready to receive data to be rendered. Create a series with one row of 5 values:</source>
          <target state="translated">이제 Q3DBars는 렌더링 할 데이터를받을 준비가되었습니다. 5 개 값의 한 행으로 시리즈를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="0613ae27546eb9ba4aef344636b76831be0f30e2" translate="yes" xml:space="preserve">
          <source>Now Q3DScatter is ready to receive data to be rendered. Add one series of 3 &lt;a href=&quot;qvector3d&quot;&gt;QVector3D&lt;/a&gt; items:</source>
          <target state="translated">이제 Q3DScatter는 렌더링 할 데이터를받을 준비가되었습니다. 3 개의 &lt;a href=&quot;qvector3d&quot;&gt;QVector3D&lt;/a&gt; 항목 시리즈를 추가 합니다.</target>
        </trans-unit>
        <trans-unit id="08bbb217e2f7f973ec29a750c5ce955c33b2b2bb" translate="yes" xml:space="preserve">
          <source>Now Q3DSurface is ready to receive data to be rendered. Create data elements to receive values:</source>
          <target state="translated">이제 Q3DSurface는 렌더링 할 데이터를받을 준비가되었습니다. 값을받을 데이터 요소를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="a805c4ae4d8ce078bc70d4e5781b4c02679f5347" translate="yes" xml:space="preserve">
          <source>Now any objects of the &lt;code&gt;SquareButton&lt;/code&gt; can connect to the &lt;code&gt;activated&lt;/code&gt; signal using an &lt;code&gt;onActivated&lt;/code&gt; signal handler:</source>
          <target state="translated">이제 &lt;code&gt;SquareButton&lt;/code&gt; 의 모든 객체 는 &lt;code&gt;onActivated&lt;/code&gt; 신호 처리기를 사용하여 &lt;code&gt;activated&lt;/code&gt; 신호에 연결할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4284fa172b913371a5257f480b33e7d4da6ac738" translate="yes" xml:space="preserve">
          <source>Now it is possible to use named icons from the bundled icon theme without having to specify any fallback source:</source>
          <target state="translated">이제 대체 소스를 지정하지 않고도 번들 아이콘 테마에서 이름이 지정된 아이콘을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d0eeaf04b29ad6881ea544710e6775e2563ac185" translate="yes" xml:space="preserve">
          <source>Now let's apply an affect to the entire scene. More precisely, to the &lt;a href=&quot;qml-qtquick3d-view3d&quot;&gt;View3D&lt;/a&gt;. When there are multiple &lt;a href=&quot;qml-qtquick3d-view3d&quot;&gt;View3D&lt;/a&gt; items in the scene, each has its own &lt;a href=&quot;qml-qtquick3d-sceneenvironment&quot;&gt;SceneEnvironment&lt;/a&gt; and therefore have their own post-processing effect chain. In the example there is one single &lt;a href=&quot;qml-qtquick3d-view3d&quot;&gt;View3D&lt;/a&gt; covering the entire window.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a98c2cb6750505b0d8e04eacbe54cd5621f5726" translate="yes" xml:space="preserve">
          <source>Now let's do the same for the three highest tickmarks:</source>
          <target state="translated">이제 세 개의 가장 높은 눈금에 대해 동일한 작업을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="88d22afd56358965ffb065adc405277c89215e28" translate="yes" xml:space="preserve">
          <source>Now let's make some shaders that apply a height and normal map to the mesh:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3bd59768cce4630daedef4cd8596fa569694128" translate="yes" xml:space="preserve">
          <source>Now strengthen the level of self-illumination a bit:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd339253fdd7193e403f5dc115d2bd057c1cfdfa" translate="yes" xml:space="preserve">
          <source>Now suppose we want to link to the &lt;a href=&quot;qml-qtqml-qt&quot;&gt;Qt QML type&lt;/a&gt;. At the time QDoc generated this HTML page, that link was also correct, but we had to use this link command:</source>
          <target state="translated">이제 &lt;a href=&quot;qml-qtqml-qt&quot;&gt;Qt QML 유형&lt;/a&gt; 에 연결하려고한다고 가정 합니다 . QDoc이이 HTML 페이지를 생성 할 때 해당 링크도 정확했지만 다음 링크 명령을 사용해야했습니다.</target>
        </trans-unit>
        <trans-unit id="f1a405e2933f9a35bab3dc4fb4e4e924e944a6ce" translate="yes" xml:space="preserve">
          <source>Now suppose we want to link to the &lt;a href=&quot;qml-qtqml-qt&quot;&gt;Qt QML type&lt;/a&gt;. At the time qdoc generated this HTML page, that link was also correct, but we had to use this link command:</source>
          <target state="translated">이제 &lt;a href=&quot;qml-qtqml-qt&quot;&gt;Qt QML 타입&lt;/a&gt; 에 링크하려고한다고 가정하자 . qdoc이이 HTML 페이지를 생성 할 때 해당 링크도 정확했지만이 링크 명령을 사용해야했습니다.</target>
        </trans-unit>
        <trans-unit id="91de1f3eb4a34404f3045adc94fd82279760f456" translate="yes" xml:space="preserve">
          <source>Now that everything that needs to be considered for this frame has been determined, the plumbing and dependencies for the main render pass can be addressed. The first thing that is done in this phase is to render any pre-passes that are required for the main pass.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93464ff3c871fa297f8e35cbcbc0b63e65833d0a" translate="yes" xml:space="preserve">
          <source>Now that the hard work of preperation is done, the easy part is running the commands that contribute to the main scene's content. That rendering works in this order:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6fdb4de0b6ede39d9eff2eb2e76b97822cf7b7f" translate="yes" xml:space="preserve">
          <source>Now that the styles are required to be found in the QML engine's import path like any other QML module, it is no longer necessary or possible to support this API.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0b05e9a167be56f4aad9a5d38b085899866ddc6" translate="yes" xml:space="preserve">
          <source>Now that you have IBL set up for your scene, let us have a look at the different properties for the probe. In many cases the default values provide a satisfying result, but you can tweak the following property values depending on the image and desired result:</source>
          <target state="translated">이제 장면에 대한 IBL을 설정 했으므로 프로브의 다양한 속성을 살펴 보겠습니다. 대부분의 경우 기본값은 만족스러운 결과를 제공하지만 이미지 및 원하는 결과에 따라 다음 속성 값을 조정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5a133c99da11e95a417ef7b4d7dfb7dea30049c" translate="yes" xml:space="preserve">
          <source>Now that you have seen QML in action, you are ready to take your next step. The follow page will lead you in your journey with QML.</source>
          <target state="translated">QML이 실제로 작동하는 것을 보았으므로 다음 단계로 넘어갈 준비가되었습니다. 다음 페이지는 QML 여행을 안내합니다.</target>
        </trans-unit>
        <trans-unit id="9bf71c6330f6d223169fb14131fc31d8ba31e68c" translate="yes" xml:space="preserve">
          <source>Now that you have successfully connected the objects for the &quot;RED&quot; component of the RGB Controller, do the same for the &quot;GREEN&quot; and &quot;BLUE&quot; components as well.</source>
          <target state="translated">RGB 컨트롤러의 &quot;RED&quot;컴포넌트에 대한 객체를 성공적으로 연결 했으므로 &quot;GREEN&quot;및 &quot;BLUE&quot;컴포넌트에 대해서도 동일하게 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="e21b96c54bf1c97a402bf9ebbaf1b0d2d9ac037a" translate="yes" xml:space="preserve">
          <source>Now that you know the rules to abide by when writing a framegraph tree, we will go over a few examples and break them down.</source>
          <target state="translated">프레임 그래프 트리를 작성할 때 준수해야 할 규칙을 알고 있으므로 몇 가지 예를 살펴보고 세분화합니다.</target>
        </trans-unit>
        <trans-unit id="751d20c329ec64db069ad0b321dda5ed3f36291e" translate="yes" xml:space="preserve">
          <source>Now the MY_DEFINES variable contains what is in the DEFINES variable at this point in the project file. This is also equivalent to:</source>
          <target state="translated">이제 MY_DEFINES 변수는 프로젝트 파일의이 시점에서 DEFINES 변수에있는 것을 포함합니다. 이것은 또한 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f5c1142a192642e38cc288100f9e53ccc06cc40c" translate="yes" xml:space="preserve">
          <source>Now the images can be successfully loaded in QML:</source>
          <target state="translated">이제 이미지를 QML에 성공적으로로드 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="bf3c4cb2d683a5394d99f167cd56f67908caa78e" translate="yes" xml:space="preserve">
          <source>Now the perhaps surprising question: why is this a bad example?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc4e54c1c64a54da47872c9ae3eefef136b71fb4" translate="yes" xml:space="preserve">
          <source>Now the total key weight of a row is</source>
          <target state="translated">이제 행의 총 키 가중치는</target>
        </trans-unit>
        <trans-unit id="75eea6953174c82ec38c97658560369e148815ab" translate="yes" xml:space="preserve">
          <source>Now we can compile and start the project, which will open a user interface with our two Qt widgets. If we can resize the dialog, the widgets will resize appropriately.</source>
          <target state="translated">이제 프로젝트를 컴파일하고 시작할 수 있습니다. 그러면 두 개의 Qt 위젯으로 사용자 인터페이스가 열립니다. 대화 상자의 크기를 조정할 수 있으면 위젯의 크기가 적절하게 조정됩니다.</target>
        </trans-unit>
        <trans-unit id="d112c9d27092ebd1c813b59a6446a56b2f7ea30e" translate="yes" xml:space="preserve">
          <source>Now we can write an &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt; to find all the XML files and parse them to find the ones that don't contain well-formed XML.</source>
          <target state="translated">이제 &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt; 를 작성하여 모든 XML 파일을 찾고 파싱하여 올바른 형식의 XML이 포함되지 않은 파일을 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e93438e0c47d51130b0c52a38f0a11f498cf21f" translate="yes" xml:space="preserve">
          <source>Now we can write an XQuery to find all the XML files and parse them to find the ones that don't contain well-formed XML.</source>
          <target state="translated">이제 XQuery를 작성하여 모든 XML 파일을 찾고 구문 분석하여 올바른 형식의 XML을 포함하지 않는 파일을 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed9fd3ad5439ee536cffd08491c78b3a1bafcff2" translate="yes" xml:space="preserve">
          <source>Now when we try to run the previous &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt; example, no output is produced! The path expression no longer matches anything in the cookbook file because our &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt; doesn't yet know about the namespace declaration we added to the cookbook document. There are two ways we can declare the namespace in the &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt;. We can give it a</source>
          <target state="translated">이제 이전 &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt; 예제 를 실행하려고하면 출력이 생성되지 않습니다! &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt; 는 요리 책 문서에 추가 한 네임 스페이스 선언에 대해 아직 알지 못 하기 때문에 경로 표현식은 더 이상 요리 책 파일의 어떤 것과도 일치 하지 않습니다. &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt; 에서 네임 스페이스를 선언 할 수있는 두 가지 방법이 있습니다 . 우리는 그것을 줄 수 있습니다</target>
        </trans-unit>
        <trans-unit id="15bc3eb1112afd6bd39d30bffaf552565ec10df9" translate="yes" xml:space="preserve">
          <source>Now when we try to run the previous &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt; example, no output is produced! The path expression no longer matches anything in the cookbook file because our &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt; doesn't yet know about the namespace declaration we added to the cookbook document. There are two ways we can declare the namespace in the &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt;. We can give it a</source>
          <target state="translated">이제 이전 &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt; 예제 를 실행하려고하면 출력이 생성되지 않습니다! &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt; 가 아직 요리 책 문서에 추가 한 네임 스페이스 선언에 대해 알지 못 하므로 경로 표현식이 더 이상 요리 책 파일의 내용과 일치 하지 않습니다. &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt; 에서 네임 스페이스를 선언 할 수있는 두 가지 방법이 있습니다 . 우리는 그것을 줄 수 있습니다</target>
        </trans-unit>
        <trans-unit id="83acf2d897d8eb3643c1d775ce9144f5458cab03" translate="yes" xml:space="preserve">
          <source>Now with a hopefully shorter list of renderables, each of these items need to be updated to reflect the current state of the scene. For each renderable we check that a suitable material is loaded, and if not a new one is created. A material is a combination of shaders and a rendering pipeline, and it is needed for creating a draw call. In addition the renderer makes sure that any resources needed to render a renderable is loaded, for example geometry and textures set on the Model. Resources that are not loaded already are loaded here.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e9bee6f717fbc24994b0890dfd7fd1b16b68177" translate="yes" xml:space="preserve">
          <source>Now you can test your development setup by running the examples shipped with the Qt installation. For more information, see &lt;a href=&quot;https://doc.qt.io/qt-5.15/examples-android.html&quot;&gt;Qt for Android Examples&lt;/a&gt;.</source>
          <target state="translated">이제 Qt 설치와 함께 제공되는 예제를 실행하여 개발 설정을 테스트 할 수 있습니다. 자세한 내용 &lt;a href=&quot;https://doc.qt.io/qt-5.15/examples-android.html&quot;&gt;은 Android 용 Qt 예제를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d8297de5e75bfb0ecd2b46e9c672f750acbb442c" translate="yes" xml:space="preserve">
          <source>Now you can test your development setup by running the examples shipped with the Qt installation. For more information, see &lt;a href=&quot;https://doc.qt.io/qt-6.0/examples-android.html&quot;&gt;Qt for Android Examples&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84a546371797b5748135f1ad79247f1f130c24b1" translate="yes" xml:space="preserve">
          <source>Now you can test your development setup by running the examples that came with the Qt 5 installation. You can browse these examples in Qt Creator &lt;b&gt;Welcome&lt;/b&gt; mode. Use the &lt;code&gt;android&lt;/code&gt; filter in the search field to list all the examples tested on Android.</source>
          <target state="translated">이제 Qt 5 설치와 함께 제공된 예제를 실행하여 개발 설정을 테스트 할 수 있습니다. 당신은 Qt는 창조주에서 이러한 예를 찾아 볼 수 있습니다 &lt;b&gt;환영&lt;/b&gt; 모드. 검색 필드에서 &lt;code&gt;android&lt;/code&gt; 필터를 사용하여 Android 에서 테스트 된 모든 예제를 나열하십시오.</target>
        </trans-unit>
        <trans-unit id="0e9e9fe835b1353248af7280ca779de75d0d1856" translate="yes" xml:space="preserve">
          <source>Now your application is available to other Android device users via Google Play. You can also choose to publish the application to a smaller group, so that you can test and improve the application before publishing it to a larger audience.</source>
          <target state="translated">이제 Google Play를 통해 다른 Android 기기 사용자가 애플리케이션을 사용할 수 있습니다. 응용 프로그램을 더 작은 그룹에 게시하도록 선택할 수도 있으므로 더 많은 사용자에게 응용 프로그램을 게시하기 전에 응용 프로그램을 테스트하고 개선 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f6e1017174f7e2d156a7e546c1b8c19d62236c4" translate="yes" xml:space="preserve">
          <source>Now, a &lt;code&gt;Message&lt;/code&gt; type can access the properties and signals of the attached object type:</source>
          <target state="translated">이제 &lt;code&gt;Message&lt;/code&gt; 유형은 첨부 된 객체 유형의 속성 및 신호에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3764460d9a256bfb9eddc4788d15262cb97b19d0" translate="yes" xml:space="preserve">
          <source>Now, a displaced item will first move to a position of (20, 50) relative to its starting position, and then to its final, correct position in the view:</source>
          <target state="translated">이제 변위 된 항목은 먼저 시작 위치를 기준으로 (20, 50)의 위치로 이동 한 다음 뷰에서 최종 올바른 위치로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="06322c5960762faf21f5be048b2a8e4389c77ea3" translate="yes" xml:space="preserve">
          <source>Now, after the space key is pressed, the rectangle's height will continue auto-updating to always be three times its width.</source>
          <target state="translated">이제 스페이스 키를 누른 후 사각형의 높이는 항상 너비의 3 배가되도록 자동 업데이트를 계속합니다.</target>
        </trans-unit>
        <trans-unit id="38be788c3069493724d4bf27a8d60d3668c3493a" translate="yes" xml:space="preserve">
          <source>Now, all QML types that a style implements must be declared in that style's qmldir file:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb1a3b1d86b592c6c34458ba111e8253522498ef" translate="yes" xml:space="preserve">
          <source>Now, explicitly importing a style does both.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7626e581161b9b33ee067e61fb988c97e96afb5" translate="yes" xml:space="preserve">
          <source>Now, geometry is specified in device independent pixels. This includes widget and item geometry, event geometry, desktop, window and screen geometry, as well as animation velocities. The output is rendered in device pixels, which corresponds to the display resolution. The</source>
          <target state="translated">이제 기하학은 장치 독립 픽셀로 지정됩니다. 여기에는 위젯 및 항목 지오메트리, 이벤트 지오메트리, 데스크탑, 창 및 화면 지오메트리, 애니메이션 속도가 포함됩니다. 출력은 디스플레이 해상도에 해당하는 장치 픽셀로 렌더링됩니다. 그만큼</target>
        </trans-unit>
        <trans-unit id="0d532067038fbb056220a95c58c55f26dc5d05e9" translate="yes" xml:space="preserve">
          <source>Now, if you move the cursor from the top to the bottom in the middle of A, you will get the following &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent::MouseMove&lt;/a&gt; events:</source>
          <target state="translated">이제 A 중간에서 커서를 위에서 아래로 &lt;a href=&quot;qevent#Type-enum&quot;&gt;움직이면&lt;/a&gt; 다음과 같은 QEvent :: MouseMove 이벤트가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e481844fe754938a92b7bad4d082a76299170b34" translate="yes" xml:space="preserve">
          <source>Now, the logical coordinates (-50,-50) correspond to the paint device's physical coordinates (0, 0). Independent of the paint device, your painting code will always operate on the specified logical coordinates.</source>
          <target state="translated">이제 논리 좌표 (-50, -50)는 페인트 장치의 실제 좌표 (0, 0)에 해당합니다. 페인트 장치와 상관없이 페인팅 코드는 항상 지정된 논리 좌표에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="6fd2fc7870ed44d5e0bb30d58d403b9ebf9e0073" translate="yes" xml:space="preserve">
          <source>Now, the mutex will always be unlocked when the &lt;a href=&quot;qmutexlocker&quot;&gt;QMutexLocker&lt;/a&gt; object is destroyed (when the function returns since &lt;code&gt;locker&lt;/code&gt; is an auto variable).</source>
          <target state="translated">이제 &lt;a href=&quot;qmutexlocker&quot;&gt;QMutexLocker&lt;/a&gt; 객체가 파괴 될 때 뮤텍스는 항상 잠금 해제됩니다 ( &lt;code&gt;locker&lt;/code&gt; 가 자동 변수 이므로 함수가 반환 될 때 ).</target>
        </trans-unit>
        <trans-unit id="5ce633495e58b859c74d5362bc4641135a91da6e" translate="yes" xml:space="preserve">
          <source>Now, the mutex will always be unlocked when the QMutexLocker object is destroyed (when the function returns since &lt;code&gt;locker&lt;/code&gt; is an auto variable).</source>
          <target state="translated">이제 뮤텍스는 QMutexLocker 객체가 소멸 될 때 ( &lt;code&gt;locker&lt;/code&gt; 가 자동 변수 이기 때문에 함수가 반환 될 때) 항상 잠금 해제됩니다 .</target>
        </trans-unit>
        <trans-unit id="83855bd860aa914a5c93e57a2cf1745228a1f284" translate="yes" xml:space="preserve">
          <source>Now, we preview your form to see how it would look in your application - press &lt;b&gt;Ctrl + R&lt;/b&gt; or select &lt;b&gt;Preview&lt;/b&gt; from the &lt;b&gt;Form&lt;/b&gt; menu. Try dragging the slider - the spin box will mirror its value too (and vice versa). Also, you can resize it to see how the layouts that are used to manage the child widgets, respond to different window sizes.</source>
          <target state="translated">이제 애플리케이션에서 어떻게 보이는지보기 위해 양식을 미리 봅니다. &lt;b&gt;Ctrl + R을&lt;/b&gt; 누르 거나 &lt;b&gt;양식&lt;/b&gt; 메뉴 에서 &lt;b&gt;미리보기&lt;/b&gt; 를 선택하십시오 . 슬라이더를 드래그 해보십시오. 스핀 상자도 그 값을 반영합니다 (또는 그 반대). 또한 하위 위젯을 관리하는 데 사용되는 레이아웃이 다른 창 크기에 어떻게 반응하는지 확인하기 위해 크기를 조정할 수 있습니다.&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="84b4c11c7fd0cf44538aed74cc1d5928fd4ad0b5" translate="yes" xml:space="preserve">
          <source>Now, when an item's &lt;code&gt;add&lt;/code&gt; transition is interrupted, its opacity and scale are animated to 1.0 upon displacement, avoiding the erroneous visual effects from before:</source>
          <target state="translated">이제 아이템의 &lt;code&gt;add&lt;/code&gt; 전환이 중단되면 변위시 불투명도와 스케일이 1.0으로 애니메이션되어 이전의 잘못된 시각 효과를 피합니다.</target>
        </trans-unit>
        <trans-unit id="0c277108c7c0452add58bf7a5904a7c9e8c2db50" translate="yes" xml:space="preserve">
          <source>Now, when the form's context menu is opened over objects of the base class, the placeholder class will appear in the &lt;b&gt;Promote to&lt;/b&gt; submenu, allowing for convenient promotion of objects to that class.</source>
          <target state="translated">이제 폼의 컨텍스트 메뉴가 기본 클래스의 개체 위에 열리면 자리 표시 자 클래스가 &lt;b&gt;승격&lt;/b&gt; 하위 메뉴에 표시되어 해당 클래스로 개체를 편리하게 승격시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bbcbfce05f3a013dbb7cbbd2902536318fa7a070" translate="yes" xml:space="preserve">
          <source>Now, whenever a QML file is changed, only the QML files have to be recompiled.</source>
          <target state="translated">이제 QML 파일이 변경 될 때마다 QML 파일 만 다시 컴파일해야합니다.</target>
        </trans-unit>
        <trans-unit id="109085beaaa80ac89858b283a64f7c75d7e5bb12" translate="yes" xml:space="preserve">
          <source>Null</source>
          <target state="translated">Null</target>
        </trans-unit>
        <trans-unit id="b7235e0e27be74e88688406044bbefc109c20906" translate="yes" xml:space="preserve">
          <source>Null (no output) via a graphics abstraction layer. This value was introduced in Qt 5.14.</source>
          <target state="translated">그래픽 추상화 계층을 통한 Null (출력 없음). 이 값은 Qt 5.14에서 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="20ce0004d95c8c52d22835e9574d0c0e574dfb78" translate="yes" xml:space="preserve">
          <source>Null documents are documents created through the default constructor.</source>
          <target state="translated">널 문서는 기본 생성자를 통해 작성된 문서입니다.</target>
        </trans-unit>
        <trans-unit id="4950033258cf4d685fedd247a213071440856225" translate="yes" xml:space="preserve">
          <source>Null pointers can be passed for any function, causing the respective function to be synthesized using the others, if possible. QQmlListProperty can synthesize</source>
          <target state="translated">모든 함수에 대해 Null 포인터를 전달할 수 있으므로 가능하면 각 함수가 다른 함수를 사용하여 합성됩니다. QQmlListProperty는 합성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1dcad64095a7e868acb464e3fd1988e4de7532bb" translate="yes" xml:space="preserve">
          <source>Null pointers can be passed for any function. If any null pointers are passed in, the list will be neither designable nor alterable by the debugger. It is recommended to provide valid pointers for all functions.</source>
          <target state="translated">모든 함수에 대해 널 포인터를 전달할 수 있습니다. 널 포인터가 전달되면 디버거가 목록을 디자인하거나 변경할 수 없습니다. 모든 기능에 유효한 포인터를 제공하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="69b632102a3968648a3ed2625df9a730b484b41e" translate="yes" xml:space="preserve">
          <source>Null values are distinct from undefined values and from invalid &lt;a href=&quot;qcborvalue&quot;&gt;QCborValue&lt;/a&gt; objects. The API will not create invalid QCborValues, but they may exist as a result of a parsing error.</source>
          <target state="translated">널값은 정의되지 않은 값 및 유효하지 않은 &lt;a href=&quot;qcborvalue&quot;&gt;QCborValue&lt;/a&gt; 오브젝트 와 다릅니다 . API는 유효하지 않은 QCborValue를 작성하지 않지만 구문 분석 오류로 인해 존재할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a97d7a55d5f211b659e841c16281be6ac207623b" translate="yes" xml:space="preserve">
          <source>Null values are used to indicate that an optional value is not present. In that aspect, it is similar to the C++ Standard Library type &lt;code&gt;std::optional&lt;/code&gt; when that is disengaged. Unlike the C++ type, CBOR nulls are simply of type &quot;Null&quot; and it is not possible to determine what concrete type it is replacing.</source>
          <target state="translated">널값은 선택적 값이 존재하지 않음을 표시하는 데 사용됩니다. 이 측면에서 C ++ 표준 라이브러리 유형 &lt;code&gt;std::optional&lt;/code&gt; 과 비슷합니다 . C ++ 유형과 달리 CBOR 널은 단순히 &quot;Null&quot;유형이며 대체 할 콘크리트 유형을 판별 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c91466faff2764b37f16753046c2c2356df3e1f0" translate="yes" xml:space="preserve">
          <source>Null-terminated character string of the following format: hh.mm.ss</source>
          <target state="translated">다음 형식의 널 종료 문자열 : hh.mm.ss</target>
        </trans-unit>
        <trans-unit id="2e713b74e51091210b48812cf2f20d24d60f843e" translate="yes" xml:space="preserve">
          <source>Null-terminated character string of the following format: yyyy-mm-dd</source>
          <target state="translated">다음 형식의 널 종료 문자열 : yyyy-mm-dd</target>
        </trans-unit>
        <trans-unit id="07e2b31a37b2a1d2aa894c8f05e8168d1a81015a" translate="yes" xml:space="preserve">
          <source>Null-terminated character string of the following format: yyyy-mm-dd-hh.mm.ss.nnnnnn</source>
          <target state="translated">다음 형식의 널 종료 문자열 : yyyy-mm-dd-hh.mm.ss.nnnnnn</target>
        </trans-unit>
        <trans-unit id="0f194d031cfb916fdcaf72438e49dc4cf8085d1a" translate="yes" xml:space="preserve">
          <source>Null-terminated varying length string</source>
          <target state="translated">널 종료 가변 길이 문자열</target>
        </trans-unit>
        <trans-unit id="b7baa1d40c4ea29afc9098732bffee2a861a6c44" translate="yes" xml:space="preserve">
          <source>Number</source>
          <target state="translated">Number</target>
        </trans-unit>
        <trans-unit id="bd04ea4621d658ed1290cccfcdd817d13897b157" translate="yes" xml:space="preserve">
          <source>Number (QML type)</source>
          <target state="translated">번호 (QML 유형)</target>
        </trans-unit>
        <trans-unit id="c113c1ce38ed141fcae0f6b76ce2cd2c5c8f74af" translate="yes" xml:space="preserve">
          <source>Number Objects</source>
          <target state="translated">숫자 객체</target>
        </trans-unit>
        <trans-unit id="82a0aab3003d37def7a9d10fc943d715c4eb34bc" translate="yes" xml:space="preserve">
          <source>Number Prototype Object</source>
          <target state="translated">숫자 프로토 타입 객체</target>
        </trans-unit>
        <trans-unit id="129277b370f66290dc57a1a03c96346bb7d8fc59" translate="yes" xml:space="preserve">
          <source>Number QML Type</source>
          <target state="translated">숫자 QML 유형</target>
        </trans-unit>
        <trans-unit id="f5437120cfcccb28c6a74d9343e189785f9e28d1" translate="yes" xml:space="preserve">
          <source>Number of available cpus</source>
          <target state="translated">사용 가능한 CPU 수</target>
        </trans-unit>
        <trans-unit id="500e2b6bc22efab7164b45852f67b348ff6f65f3" translate="yes" xml:space="preserve">
          <source>Number of channels</source>
          <target state="translated">채널 수</target>
        </trans-unit>
        <trans-unit id="4b43bab8dbd3ca8a21f75cb7a351549dab6e42fa" translate="yes" xml:space="preserve">
          <source>Number of columns.</source>
          <target state="translated">열 수</target>
        </trans-unit>
        <trans-unit id="95aa88f742fec71068ba90c5df3443d7f96acc87" translate="yes" xml:space="preserve">
          <source>Number of frames in this &lt;a href=&quot;qml-qtquick-animatedsprite&quot;&gt;AnimatedSprite&lt;/a&gt;.</source>
          <target state="translated">이 &lt;a href=&quot;qml-qtquick-animatedsprite&quot;&gt;AnimatedSprite&lt;/a&gt; 의 프레임 수입니다 .</target>
        </trans-unit>
        <trans-unit id="f834f20637f46d00335a4672f4cd5855a7e77339" translate="yes" xml:space="preserve">
          <source>Number of frames in this sprite.</source>
          <target state="translated">이 스프라이트의 프레임 수입니다.</target>
        </trans-unit>
        <trans-unit id="953834b4bdb54e1e2b2933c4b60cdaac7c358715" translate="yes" xml:space="preserve">
          <source>Number of lines to scroll by default for each wheel click.</source>
          <target state="translated">각 휠 클릭에 대해 기본적으로 스크롤 할 줄 수입니다.</target>
        </trans-unit>
        <trans-unit id="c4de77416557276d36e983053906df7898a8bb99" translate="yes" xml:space="preserve">
          <source>Number of particles emitted per second.</source>
          <target state="translated">초당 방출되는 입자 수</target>
        </trans-unit>
        <trans-unit id="99784d5348f9c9161b7d0abdfc2978931bde09d7" translate="yes" xml:space="preserve">
          <source>Number of pixels between the top of each key and the bottom of the &lt;a href=&quot;qml-qtquick-virtualkeyboard-styles-keyboardstyle#characterPreviewDelegate-prop&quot;&gt;characterPreviewDelegate&lt;/a&gt;.</source>
          <target state="translated">각 키의 상단과 &lt;a href=&quot;qml-qtquick-virtualkeyboard-styles-keyboardstyle#characterPreviewDelegate-prop&quot;&gt;characterPreviewDelegate&lt;/a&gt; 의 하단 사이의 픽셀 수입니다 .</target>
        </trans-unit>
        <trans-unit id="117b11fe1707172fb3103fd8d37a75c468c0ec15" translate="yes" xml:space="preserve">
          <source>Number of pixels the tab bar overlaps the tab bar base.</source>
          <target state="translated">탭 막대가 탭 막대베이스와 겹치는 픽셀 수입니다.</target>
        </trans-unit>
        <trans-unit id="aa1086817770ad305f4259ede691b45af504dfd9" translate="yes" xml:space="preserve">
          <source>Number of pixels the tabs should overlap. (Currently only used in styles, not inside of &lt;a href=&quot;qtabbar&quot;&gt;QTabBar&lt;/a&gt;)</source>
          <target state="translated">탭이 겹치는 픽셀 수입니다. (현재 &lt;a href=&quot;qtabbar&quot;&gt;QTabBar&lt;/a&gt; 내부가 아닌 스타일에서만 사용됨 )</target>
        </trans-unit>
        <trans-unit id="1c099e65a07762829f7dc4f02bbef87f1902e005" translate="yes" xml:space="preserve">
          <source>Number of rows.</source>
          <target state="translated">행 수</target>
        </trans-unit>
        <trans-unit id="e7310da02777697d15f246cacbdda11278ae3b7e" translate="yes" xml:space="preserve">
          <source>Number of samples per pixels.</source>
          <target state="translated">픽셀 당 샘플 수</target>
        </trans-unit>
        <trans-unit id="345a32be56f183547ba365cbc91a5a42c09f45bf" translate="yes" xml:space="preserve">
          <source>Number of seconds for which the service record is expected to remain valid and unchanged.</source>
          <target state="translated">서비스 레코드가 유효하고 변경되지 않은 것으로 예상되는 시간 (초)입니다.</target>
        </trans-unit>
        <trans-unit id="c4bddeda901b30189cf0eec86b9034f934ce8845" translate="yes" xml:space="preserve">
          <source>Number of the bump bands. Range is &lt;code&gt;[0, 10]&lt;/code&gt;. Default is &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">범프 밴드 수입니다. 범위는 &lt;code&gt;[0, 10]&lt;/code&gt; 입니다. 기본값은 &lt;code&gt;1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="10179913cf23a4c785c56399981d100dee5ea09c" translate="yes" xml:space="preserve">
          <source>Number with a decimal point</source>
          <target state="translated">소수점이있는 숫자</target>
        </trans-unit>
        <trans-unit id="6930ecdabd21ef35de372e2b65c40913aa7fbe51" translate="yes" xml:space="preserve">
          <source>Number with a decimal point, stored in double precision</source>
          <target state="translated">소수점이있는 숫자로 배정 밀도로 저장 됨</target>
        </trans-unit>
        <trans-unit id="61e2eb6c2092496cb709b33bde8b0c1fdb152876" translate="yes" xml:space="preserve">
          <source>Number-String Conversions</source>
          <target state="translated">숫자 스트링 변환</target>
        </trans-unit>
        <trans-unit id="8853b35bfc0b315f9a4aa9f24776f3df91d59844" translate="yes" xml:space="preserve">
          <source>Number.fromLocaleString()</source>
          <target state="translated">Number.fromLocaleString()</target>
        </trans-unit>
        <trans-unit id="0e928443306d0e3608dc13956f467c25354b8134" translate="yes" xml:space="preserve">
          <source>Number.toLocaleCurrencyString()</source>
          <target state="translated">Number.toLocaleCurrencyString()</target>
        </trans-unit>
        <trans-unit id="d1bfceb3f74807a1e09af5f567b5211834fc09fe" translate="yes" xml:space="preserve">
          <source>Number.toLocaleString()</source>
          <target state="translated">Number.toLocaleString()</target>
        </trans-unit>
        <trans-unit id="694f436bf150c20dc3b5d72fd327f6f23a6ec02a" translate="yes" xml:space="preserve">
          <source>NumberAnimation</source>
          <target state="translated">NumberAnimation</target>
        </trans-unit>
        <trans-unit id="eb519c713f65c73fb16c6c3867b306394928735d" translate="yes" xml:space="preserve">
          <source>NumberAnimation (QML type)</source>
          <target state="translated">NumberAnimation (QML 유형)</target>
        </trans-unit>
        <trans-unit id="b294cca2f833e4c8c97789eb72141ab5a01b8d0c" translate="yes" xml:space="preserve">
          <source>NumberAnimation QML Type</source>
          <target state="translated">NumberAnimation QML 유형</target>
        </trans-unit>
        <trans-unit id="df6c00d6aab7677f5d022765f520555b07a53ada" translate="yes" xml:space="preserve">
          <source>NumberAnimation is a specialized &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtquick-animation-example.html#propertyanimation&quot;&gt;PropertyAnimation&lt;/a&gt; that defines an animation to be applied when a numerical value changes.</source>
          <target state="translated">NumberAnimation은 숫자 값이 변경 될 때 적용 할 애니메이션을 정의하는 특수 &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtquick-animation-example.html#propertyanimation&quot;&gt;PropertyAnimation&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1b130009426824aa81a7072af49bf03cf401bb52" translate="yes" xml:space="preserve">
          <source>NumberAnimation is a specialized &lt;a href=&quot;https://doc.qt.io/qt-6.0/qtquick-animation-example.html#propertyanimation&quot;&gt;PropertyAnimation&lt;/a&gt; that defines an animation to be applied when a numerical value changes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65e4e61df8999404b8b5ad166882cb1457e35a93" translate="yes" xml:space="preserve">
          <source>NumberAnimation.from</source>
          <target state="translated">NumberAnimation.from</target>
        </trans-unit>
        <trans-unit id="977d11c79d0ddc0ee6061e53dec292680faa6ebb" translate="yes" xml:space="preserve">
          <source>NumberAnimation.to</source>
          <target state="translated">NumberAnimation.to</target>
        </trans-unit>
        <trans-unit id="35a45152d1ca143684b413835f52129e231f1fc5" translate="yes" xml:space="preserve">
          <source>NumberKey</source>
          <target state="translated">NumberKey</target>
        </trans-unit>
        <trans-unit id="b6727a8e20eef56656ce7cac5201120eb3d8c86a" translate="yes" xml:space="preserve">
          <source>NumberKey (QML type)</source>
          <target state="translated">숫자 키 (QML 유형)</target>
        </trans-unit>
        <trans-unit id="ded1c795537c6d0db49b85fbb4c5d59425e6ba26" translate="yes" xml:space="preserve">
          <source>NumberKey QML Type</source>
          <target state="translated">NumberKey QML 유형</target>
        </trans-unit>
        <trans-unit id="6e50b620a0413cffbe685c98eb3030650833a71f" translate="yes" xml:space="preserve">
          <source>NumberOption : &lt;a href=&quot;qml-enumeration&quot;&gt;enumeration&lt;/a&gt;</source>
          <target state="translated">NumberOption : &lt;a href=&quot;qml-enumeration&quot;&gt;열거&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e249d9031dd18938937b7eec1e67c86b2dfc203a" translate="yes" xml:space="preserve">
          <source>Numbers are preferred (but not required).</source>
          <target state="translated">숫자가 선호되지만 필수는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="2222bd398de7c6adad994baa92e9f4101919ea06" translate="yes" xml:space="preserve">
          <source>Numbers the months of the year starting with 1 for the first. Uses</source>
          <target state="translated">첫 번째는 1부터 시작하여 1 년 중 월에 번호를 매 깁니다. 용도</target>
        </trans-unit>
        <trans-unit id="e7c06a130c65a61ca60fa4f91de0c968043c1eae" translate="yes" xml:space="preserve">
          <source>Numerical representation of sample (typically signed integer, unsigned integer or float)</source>
          <target state="translated">샘플의 숫자 표현 (일반적으로 부호있는 정수, 부호없는 정수 또는 부동 소수점)</target>
        </trans-unit>
        <trans-unit id="bb6f681ce5e6ca483e629f9886404c800d5b2c9c" translate="yes" xml:space="preserve">
          <source>Numerical sorting can be accomplished by zero-padding the values to a fixed length with the help of the &lt;a href=&quot;#format-number&quot;&gt;format_number&lt;/a&gt;() function.</source>
          <target state="translated">&lt;a href=&quot;#format-number&quot;&gt;format_number&lt;/a&gt; () 함수 를 사용하여 고정 길이로 값을 0으로 채워서 숫자 정렬을 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2e53031a03bd763022979a624672f4519a8e34c0" translate="yes" xml:space="preserve">
          <source>Numerical sorting can be accomplished by zero-padding the values to a fixed length with the help of the &lt;a href=&quot;qmake-function-reference#format-number&quot;&gt;format_number&lt;/a&gt;() function.</source>
          <target state="translated">숫자 정렬은 &lt;a href=&quot;qmake-function-reference#format-number&quot;&gt;format_number&lt;/a&gt; () 함수를 사용 하여 값을 고정 길이로 0으로 채워서 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8eaaf3f2e73194df2847d7fd9363869f9713855e" translate="yes" xml:space="preserve">
          <source>Numerical values in a database can have precisions greater than their corresponding C++ types. This enum lists the policies for representing such values in the application.</source>
          <target state="translated">데이터베이스의 숫자 값은 해당 C ++ 유형보다 높은 정밀도를 가질 수 있습니다. 이 열거 형은 응용 프로그램에서 이러한 값을 나타내는 정책을 나열합니다.</target>
        </trans-unit>
        <trans-unit id="d6b659d658bf35b86d5fff3cd0fcc74348fd88a9" translate="yes" xml:space="preserve">
          <source>O G&amp;ecirc;nio e as Rosas</source>
          <target state="translated">O G&amp;ecirc;nio e as Rosas</target>
        </trans-unit>
        <trans-unit id="b77c741d1f9cd669d002e4e86286a37c1adb4f06" translate="yes" xml:space="preserve">
          <source>O(</source>
          <target state="translated">O(</target>
        </trans-unit>
        <trans-unit id="6c69dc5bbeb314ef78589c0047ce04c8e5006432" translate="yes" xml:space="preserve">
          <source>O(1)</source>
          <target state="translated">O(1)</target>
        </trans-unit>
        <trans-unit id="26ec14657697a25c3824a35ea3e5f1e616f8b70c" translate="yes" xml:space="preserve">
          <source>O(log</source>
          <target state="translated">O(log</target>
        </trans-unit>
        <trans-unit id="ebc75cd71fe8ecc45d16e8fbe4ca608d05d1efe0" translate="yes" xml:space="preserve">
          <source>O(n)</source>
          <target state="translated">O(n)</target>
        </trans-unit>
        <trans-unit id="88d917ebe28a4594d8b851667720080155024195" translate="yes" xml:space="preserve">
          <source>OAuth 1</source>
          <target state="translated">OAuth 1</target>
        </trans-unit>
        <trans-unit id="33d4fc04c495fd922d4d5a9639d9d4daad5ef02c" translate="yes" xml:space="preserve">
          <source>OAuth 2</source>
          <target state="translated">OAuth 2</target>
        </trans-unit>
        <trans-unit id="286a9950d8b7439d591175d1477185a445560ee1" translate="yes" xml:space="preserve">
          <source>OAuth specifies three methods for the client to establish its rightful ownership of the credentials: &quot;HMAC-SHA1&quot;, &quot;RSA-SHA1&quot;, and &quot;PLAINTEXT&quot;. Each generates a &quot;signature&quot; with which the request is &quot;signed&quot;; the first two use a digest of the data signed in generating this, though the last does not. The &quot;RSA-SHA1&quot; method is not supported here; it would use an RSA key rather than the shared-secret associated with the client credentials.</source>
          <target state="translated">OAuth는 &quot;HMAC-SHA1&quot;, &quot;RSA-SHA1&quot;및 &quot;PLAINTEXT&quot;와 같이 클라이언트가 자격 증명에 대한 올바른 소유권을 설정하는 세 가지 방법을 지정합니다. 각 요청은 &quot;서명&quot;과 함께 &quot;서명&quot;을 생성합니다. 처음 두 개는 이것을 생성하도록 서명 된 데이터의 다이제스트를 사용하지만 마지막 두 개는 그렇지 않습니다. &quot;RSA-SHA1&quot;방법은 여기서 지원되지 않습니다. 클라이언트 자격 증명과 연결된 공유 암호 대신 RSA 키를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="87f31c8069eb8dad7d5d244f603f0f20b29a8937" translate="yes" xml:space="preserve">
          <source>OAuth-authenticated requests can have two sets of credentials: those passed via the &quot;oauth_consumer_key&quot; parameter and those in the &quot;oauth_token&quot; parameter. In order for the server to verify the authenticity of the request and prevent unauthorized access, the client needs to prove that it is the rightful owner of the credentials. This is accomplished using the shared-secret (or RSA key) part of each set of credentials.</source>
          <target state="translated">OAuth 인증 요청에는 &quot;oauth_consumer_key&quot;매개 변수를 통해 전달 된 것과 &quot;oauth_token&quot;매개 변수를 통해 전달되는 자격 증명이 있습니다. 서버가 요청의 진위 여부를 확인하고 무단 액세스를 방지하려면 클라이언트가 자격 증명의 정당한 소유자임을 증명해야합니다. 이는 각 자격 증명 세트의 공유 비밀 (또는 RSA 키) 부분을 사용하여 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="3fa2004d9c5fb45107e8ba92881d9fc51650ef56" translate="yes" xml:space="preserve">
          <source>OBEX object push service UUID (service &amp;amp; profile)</source>
          <target state="translated">OBEX 객체 푸시 서비스 UUID (서비스 및 프로파일)</target>
        </trans-unit>
        <trans-unit id="30a3ad09b587523d25c7de596e4504c5d2f3dc1e" translate="yes" xml:space="preserve">
          <source>OBEX protocol UUID</source>
          <target state="translated">OBEX 프로토콜 UUID</target>
        </trans-unit>
        <trans-unit id="841711cb0a31c0d559b38249e56010c7811328b8" translate="yes" xml:space="preserve">
          <source>OBJECTIVE_HEADERS</source>
          <target state="translated">OBJECTIVE_HEADERS</target>
        </trans-unit>
        <trans-unit id="04f20aa09e3210fdc27d763821e80a7e7be97cd7" translate="yes" xml:space="preserve">
          <source>OBJECTIVE_SOURCES</source>
          <target state="translated">OBJECTIVE_SOURCES</target>
        </trans-unit>
        <trans-unit id="83ccf14b6fc5001c270b87a25f6dbd0dd2dbdb90" translate="yes" xml:space="preserve">
          <source>OBJECTS</source>
          <target state="translated">OBJECTS</target>
        </trans-unit>
        <trans-unit id="be405de2bfc768c1fbdccb9c1d34d444fb431cbf" translate="yes" xml:space="preserve">
          <source>OBJECTS_DIR</source>
          <target state="translated">OBJECTS_DIR</target>
        </trans-unit>
        <trans-unit id="884fe42d7e2e7bcd001fae8aa79b945821553691" translate="yes" xml:space="preserve">
          <source>OBJECT_PATH</source>
          <target state="translated">OBJECT_PATH</target>
        </trans-unit>
        <trans-unit id="695ae40e746bef24e4df9f63ee368014f1d7e7e4" translate="yes" xml:space="preserve">
          <source>OCI</source>
          <target state="translated">OCI</target>
        </trans-unit>
        <trans-unit id="0d13ae4dd116aec015f36e45386f3e152358d36c" translate="yes" xml:space="preserve">
          <source>OCI BLOB/LOB Support</source>
          <target state="translated">OCI BLOB / LOB 지원</target>
        </trans-unit>
        <trans-unit id="5d450429b3e0e135a15f0dd98a6d3bd981a4aec8" translate="yes" xml:space="preserve">
          <source>OCI User Authentication</source>
          <target state="translated">OCI 사용자 인증</target>
        </trans-unit>
        <trans-unit id="4023014467d78e594d17088f3b828278cac3c54b" translate="yes" xml:space="preserve">
          <source>OCIEnv *environment, OCISvcCtx *serviceContext</source>
          <target state="translated">OCIEnv * 환경, OCISvcCtx * serviceContext</target>
        </trans-unit>
        <trans-unit id="315055fe91d5810cc0cce867d3885759def60c87" translate="yes" xml:space="preserve">
          <source>OCI_ATTR_PREFETCH_MEMORY</source>
          <target state="translated">OCI_ATTR_PREFETCH_MEMORY</target>
        </trans-unit>
        <trans-unit id="208ef5c2b1609274552eee43cd79e96ec0a5d616" translate="yes" xml:space="preserve">
          <source>OCI_ATTR_PREFETCH_ROWS</source>
          <target state="translated">OCI_ATTR_PREFETCH_ROWS</target>
        </trans-unit>
        <trans-unit id="fb91068c51189c866a8e510b38ba4dfebf5d32bc" translate="yes" xml:space="preserve">
          <source>ODBC</source>
          <target state="translated">ODBC</target>
        </trans-unit>
        <trans-unit id="828f47c7b62b20841f0a9fe84c87d0697033c31a" translate="yes" xml:space="preserve">
          <source>ODBC Data Types</source>
          <target state="translated">ODBC 데이터 유형</target>
        </trans-unit>
        <trans-unit id="60f7665529f2f925b978d290b59ba4ff688d3f27" translate="yes" xml:space="preserve">
          <source>ODBC Driver (includes Microsoft SQL Server)</source>
          <target state="translated">ODBC 드라이버 (Microsoft SQL Server 포함)</target>
        </trans-unit>
        <trans-unit id="994c7f90ba717b0252c04ad6c532c4ba66426ca2" translate="yes" xml:space="preserve">
          <source>ODBC Stored Procedure Support</source>
          <target state="translated">ODBC 저장 프로 시저 지원</target>
        </trans-unit>
        <trans-unit id="2057f16fa8465062b88a6e5e145a9dcdd949d419" translate="yes" xml:space="preserve">
          <source>ODBC Unicode Support</source>
          <target state="translated">ODBC 유니 코드 지원</target>
        </trans-unit>
        <trans-unit id="a8fbcef4f5ba09caf931cea9075e77a5e551ffd3" translate="yes" xml:space="preserve">
          <source>ODBC data type</source>
          <target state="translated">ODBC 데이터 유형</target>
        </trans-unit>
        <trans-unit id="e6e72739f18a92d5b218c3d441c28fa23a05bd74" translate="yes" xml:space="preserve">
          <source>ODBC is a general interface that allows you to connect to multiple DBMSs using a common interface. The QODBC driver allows you to connect to an ODBC driver manager and access the available data sources. Note that you also need to install and configure ODBC drivers for the ODBC driver manager that is installed on your system. The QODBC plugin then allows you to use these data sources in your Qt applications.</source>
          <target state="translated">ODBC는 공통 인터페이스를 사용하여 여러 DBMS에 연결할 수있는 일반 인터페이스입니다. QODBC 드라이버를 사용하면 ODBC 드라이버 관리자에 연결하고 사용 가능한 데이터 소스에 액세스 할 수 있습니다. 시스템에 설치된 ODBC 드라이버 관리자에 대한 ODBC 드라이버도 설치하고 구성해야합니다. 그러면 QODBC 플러그인을 통해 Qt 애플리케이션에서 이러한 데이터 소스를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce51f5620f2dc95a3693afb895c3f3b71e1a3af3" translate="yes" xml:space="preserve">
          <source>ODF</source>
          <target state="translated">ODF</target>
        </trans-unit>
        <trans-unit id="4d314276ba61e4f3bc6a1b4a234e301a4e785ad9" translate="yes" xml:space="preserve">
          <source>OID</source>
          <target state="translated">OID</target>
        </trans-unit>
        <trans-unit id="9ce3bd4224c8c1780db56b4125ecf3f24bf748b7" translate="yes" xml:space="preserve">
          <source>OK</source>
          <target state="translated">OK</target>
        </trans-unit>
        <trans-unit id="ef0b695e83be27386b36470c50c7f6aaf76e0c49" translate="yes" xml:space="preserve">
          <source>OLE_COLOR</source>
          <target state="translated">OLE_COLOR</target>
        </trans-unit>
        <trans-unit id="be32a2ba6c79c28539a90a34ead9a2e50ea8d370" translate="yes" xml:space="preserve">
          <source>OPERATION</source>
          <target state="translated">OPERATION</target>
        </trans-unit>
        <trans-unit id="9954b5cb646af3e1d62f8936ee802e399e164efe" translate="yes" xml:space="preserve">
          <source>OS X</source>
          <target state="translated">OS X</target>
        </trans-unit>
        <trans-unit id="7c947ae35976cf5089fc0a26ca59e56d7250514d" translate="yes" xml:space="preserve">
          <source>OUTPUT_SIZE</source>
          <target state="translated">OUTPUT_SIZE</target>
        </trans-unit>
        <trans-unit id="71af95a01f4f17e1db7ce58248c17727d6bccd76" translate="yes" xml:space="preserve">
          <source>OUT_PWD</source>
          <target state="translated">OUT_PWD</target>
        </trans-unit>
        <trans-unit id="2883f191bc5ebfdc16c0813eff659b35363ea69b" translate="yes" xml:space="preserve">
          <source>Object</source>
          <target state="translated">Object</target>
        </trans-unit>
        <trans-unit id="e3805ab06696aa72f9cb17dcaeddd521f5f13046" translate="yes" xml:space="preserve">
          <source>Object Constructor</source>
          <target state="translated">객체 생성자</target>
        </trans-unit>
        <trans-unit id="9cf5c3411eb513b108884e51c19ba17172ea9665" translate="yes" xml:space="preserve">
          <source>Object Declarations</source>
          <target state="translated">객체 선언</target>
        </trans-unit>
        <trans-unit id="3f59301f7416504f287f1f698afb5f3926cb4024" translate="yes" xml:space="preserve">
          <source>Object Instances as Models</source>
          <target state="translated">모델로서의 객체 인스턴스</target>
        </trans-unit>
        <trans-unit id="8e8f73597a618314a275940fda3ddbf67d61ed8c" translate="yes" xml:space="preserve">
          <source>Object Life Cycle</source>
          <target state="translated">객체 수명주기</target>
        </trans-unit>
        <trans-unit id="2190ecef1ae8c952744acc1fe3a0dfc304f621fa" translate="yes" xml:space="preserve">
          <source>Object List Property Attributes</source>
          <target state="translated">객체 목록 속성</target>
        </trans-unit>
        <trans-unit id="aaa80f910817ebd1e9f2fa00be8e23153b3e201b" translate="yes" xml:space="preserve">
          <source>Object ListModel</source>
          <target state="translated">객체리스트 모델</target>
        </trans-unit>
        <trans-unit id="9acd850a30238a54eae733b2ef6db2b68124fe1e" translate="yes" xml:space="preserve">
          <source>Object Model</source>
          <target state="translated">객체 모델</target>
        </trans-unit>
        <trans-unit id="e6720a40de19cc539e25cc2ae1ae5e5f90874501" translate="yes" xml:space="preserve">
          <source>Object Paths</source>
          <target state="translated">객체 경로</target>
        </trans-unit>
        <trans-unit id="16b3286580da806e3257bdff8601d05ac12e4df0" translate="yes" xml:space="preserve">
          <source>Object Prototype</source>
          <target state="translated">객체 프로토 타입</target>
        </trans-unit>
        <trans-unit id="0af502f2ae3dd68173726a626d83522053ce2848" translate="yes" xml:space="preserve">
          <source>Object Trees &amp;amp; Ownership</source>
          <target state="translated">객체 트리 및 소유권</target>
        </trans-unit>
        <trans-unit id="cadc94239cb6d9721bc9abae7ab74549ddda3fbb" translate="yes" xml:space="preserve">
          <source>Object Type</source>
          <target state="translated">객체 유형</target>
        </trans-unit>
        <trans-unit id="6d1ee094001a93ed2e61b87b4d76e3a69bbe1573" translate="yes" xml:space="preserve">
          <source>Object Type Declaration</source>
          <target state="translated">객체 타입 선언</target>
        </trans-unit>
        <trans-unit id="cbf147d445453a6660add525598d56066b954b1c" translate="yes" xml:space="preserve">
          <source>Object Types</source>
          <target state="translated">객체 유형</target>
        </trans-unit>
        <trans-unit id="724abbaa9e50ed8d083e80ecfd6b822312ab888a" translate="yes" xml:space="preserve">
          <source>Object assignment (with operator=()) for implicitly shared objects is implemented using shallow copies.</source>
          <target state="translated">내재적으로 공유 된 객체에 대한 객체 할당 (operator = () 사용)은 단순 복사본을 사용하여 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="7d24a041e67eb9c7378894eed68408469f03a849" translate="yes" xml:space="preserve">
          <source>Object creation requires the specified license key. The key can be empty to require a licensed machine. By default classes are not licensed. Also see the following section.</source>
          <target state="translated">객체 생성에는 지정된 라이센스 키가 필요합니다. 라이센스가있는 머신이 필요하면 키를 비울 수 있습니다. 기본적으로 클래스는 라이센스가 없습니다. 다음 섹션도 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b54ee048c2801ae45779415e6f4e268e23af0319" translate="yes" xml:space="preserve">
          <source>Object instances can be instantiated &quot;lazily&quot; at run-time, to avoid performing unnecessary work until needed. Qt Quick provides the &lt;a href=&quot;qml-qtquick-loader&quot;&gt;Loader&lt;/a&gt; type to make lazy instantiation more convenient.</source>
          <target state="translated">필요할 때까지 불필요한 작업을 수행하지 않기 위해 런타임에 객체 인스턴스를 &quot;지연 적으로&quot;인스턴스화 할 수 있습니다. Qt Quick은 &lt;a href=&quot;qml-qtquick-loader&quot;&gt;로더&lt;/a&gt; 유형을 제공하여 지연 인스턴스화를보다 편리하게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="3cea97df0b740945c7cd547fced0589e4c407d8c" translate="yes" xml:space="preserve">
          <source>Object path</source>
          <target state="translated">객체 경로</target>
        </trans-unit>
        <trans-unit id="203291fcf92cec017d179c96285b0d1e76accb7f" translate="yes" xml:space="preserve">
          <source>Object values have an internal &lt;code&gt;prototype&lt;/code&gt; property, which can be accessed with &lt;a href=&quot;qjsvalue#prototype&quot;&gt;prototype&lt;/a&gt;() and &lt;a href=&quot;qjsvalue#setPrototype&quot;&gt;setPrototype&lt;/a&gt;().</source>
          <target state="translated">객체 값에는 &lt;a href=&quot;qjsvalue#prototype&quot;&gt;프로토 타입&lt;/a&gt; () 및 &lt;a href=&quot;qjsvalue#setPrototype&quot;&gt;setPrototype&lt;/a&gt; () 으로 액세스 할 수 있는 내부 &lt;code&gt;prototype&lt;/code&gt; 속성이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cfd7ce32b18ccc93e091fb9ba1044f2c15579bf2" translate="yes" xml:space="preserve">
          <source>Object values have zero or more properties which are themselves QJSValues. Use &lt;a href=&quot;qjsvalue#setProperty&quot;&gt;setProperty&lt;/a&gt;() to set a property of an object, and call &lt;a href=&quot;qjsvalue#property&quot;&gt;property&lt;/a&gt;() to retrieve the value of a property.</source>
          <target state="translated">오브젝트 값에는 자체 QJSValue 인 0 개 이상의 특성이 있습니다. &lt;a href=&quot;qjsvalue#setProperty&quot;&gt;setProperty&lt;/a&gt; ()를 사용 하여 객체의 속성을 설정하고 &lt;a href=&quot;qjsvalue#property&quot;&gt;property&lt;/a&gt; ()를 호출 하여 속성 값을 검색하십시오.</target>
        </trans-unit>
        <trans-unit id="54b21916ca98dfc8439fcd99e018df80869ced7d" translate="yes" xml:space="preserve">
          <source>Object-type properties are accessible from QML providing that the object type has been appropriately &lt;a href=&quot;qtqml-cppintegration-definetypes#registering-c-types-with-the-qml-type-system&quot;&gt;registered&lt;/a&gt; with the QML type system.</source>
          <target state="translated">QML 유형 시스템에 오브젝트 유형이 적절하게 &lt;a href=&quot;qtqml-cppintegration-definetypes#registering-c-types-with-the-qml-type-system&quot;&gt;등록&lt;/a&gt; 되어 있으면 QML에서 오브젝트 유형 특성에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5cdd7a1d073fcc8d75672b9e907657f7abe1bc7" translate="yes" xml:space="preserve">
          <source>Object3D</source>
          <target state="translated">Object3D</target>
        </trans-unit>
        <trans-unit id="4065a84a78b909b3647f336d16ff01b025b3ebb3" translate="yes" xml:space="preserve">
          <source>Object3D (QML type)</source>
          <target state="translated">Object3D (QML 유형)</target>
        </trans-unit>
        <trans-unit id="27e7e1352e7c7ec29417fce9fa0874608474a0cd" translate="yes" xml:space="preserve">
          <source>Object3D &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick3d-repeater3d#objectAt-method&quot;&gt;objectAt&lt;/a&gt;&lt;/b&gt;&lt;/b&gt;(</source>
          <target state="translated">Object3D &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick3d-repeater3d#objectAt-method&quot;&gt;objectAt&lt;/a&gt;&lt;/b&gt;&lt;/b&gt; (</target>
        </trans-unit>
        <trans-unit id="4785724e157098f2f7c3eaab5a51d123815291b2" translate="yes" xml:space="preserve">
          <source>Object3D QML Type</source>
          <target state="translated">Object3D QML 유형</target>
        </trans-unit>
        <trans-unit id="d314caff5c877da822b4b13829f35073749f763a" translate="yes" xml:space="preserve">
          <source>Object3D is the base class for all Qt Quick 3D types. This includes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64bfa4294b96e3d190e235ed69448a5ad6514d90" translate="yes" xml:space="preserve">
          <source>Object3D.position</source>
          <target state="translated">Object3D.position</target>
        </trans-unit>
        <trans-unit id="32cc615a7b7001e3ff856d52e1c78e6e3e8d014d" translate="yes" xml:space="preserve">
          <source>ObjectModel</source>
          <target state="translated">ObjectModel</target>
        </trans-unit>
        <trans-unit id="aec80b03553ebb7dde91b86f2bc7e88ed514ea8c" translate="yes" xml:space="preserve">
          <source>ObjectModel (QML type)</source>
          <target state="translated">ObjectModel (QML 유형)</target>
        </trans-unit>
        <trans-unit id="9b28895c6bcc7dfa7ec11cd69a80612fce798c5e" translate="yes" xml:space="preserve">
          <source>ObjectModel QML Type</source>
          <target state="translated">ObjectModel QML 유형</target>
        </trans-unit>
        <trans-unit id="dff4370260bd3b6b1d459cf919f71ab1463c3299" translate="yes" xml:space="preserve">
          <source>ObjectModel.ObjectModel.index</source>
          <target state="translated">ObjectModel.ObjectModel.index</target>
        </trans-unit>
        <trans-unit id="bf79171018170163b69ed060410e79b23236ca4a" translate="yes" xml:space="preserve">
          <source>ObjectModel.append()</source>
          <target state="translated">ObjectModel.append()</target>
        </trans-unit>
        <trans-unit id="cb209f0994341e86e077877fbe0b0425e8b750fc" translate="yes" xml:space="preserve">
          <source>ObjectModel.clear()</source>
          <target state="translated">ObjectModel.clear()</target>
        </trans-unit>
        <trans-unit id="3c5a7c047b729c4dfa9d1559dba39e7b29bcb0bc" translate="yes" xml:space="preserve">
          <source>ObjectModel.count</source>
          <target state="translated">ObjectModel.count</target>
        </trans-unit>
        <trans-unit id="644bab37ce157b32cff688f709537ade82a223e7" translate="yes" xml:space="preserve">
          <source>ObjectModel.get()</source>
          <target state="translated">ObjectModel.get()</target>
        </trans-unit>
        <trans-unit id="adb704e5c2bcf604ffa4b3e4a4ad0e6a41f259d0" translate="yes" xml:space="preserve">
          <source>ObjectModel.index : &lt;a href=&quot;qml-int&quot;&gt;int&lt;/a&gt;</source>
          <target state="translated">ObjectModel.index : &lt;a href=&quot;qml-int&quot;&gt;int&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bd346ecc58d13dae770758b38b9d8bc20e15bf46" translate="yes" xml:space="preserve">
          <source>ObjectModel.insert()</source>
          <target state="translated">ObjectModel.insert()</target>
        </trans-unit>
        <trans-unit id="d63148abda2ca84caa62395733da1faeb324e2fb" translate="yes" xml:space="preserve">
          <source>ObjectModel.move()</source>
          <target state="translated">ObjectModel.move()</target>
        </trans-unit>
        <trans-unit id="53439117cd016c1645e4bb61b6fd813149721878" translate="yes" xml:space="preserve">
          <source>ObjectModel.remove()</source>
          <target state="translated">ObjectModel.remove()</target>
        </trans-unit>
        <trans-unit id="f440e660c5232ac31cba1d040ea9f607a471cfd1" translate="yes" xml:space="preserve">
          <source>ObjectOwnership controls whether or not QML automatically destroys the &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; when the corresponding JavaScript object is garbage collected by the engine. The two ownership options are:</source>
          <target state="translated">ObjectOwnership 은 해당 JavaScript 오브젝트가 엔진에 의해 가비지 수집 될 때 QML이 &lt;a href=&quot;qobject&quot;&gt;QObject를&lt;/a&gt; 자동으로 제거하는지 여부를 제어합니다 . 두 가지 소유권 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="36b5e278e211b0b4ce7bfa1f2e73f19c59b3a0a1" translate="yes" xml:space="preserve">
          <source>ObjectOwnership controls whether or not the JavaScript memory manager automatically destroys the &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; when the corresponding JavaScript object is garbage collected by the engine. The two ownership options are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1369c2fee536e9fa8c60ca26d701c6401f9fd9f1" translate="yes" xml:space="preserve">
          <source>ObjectPicker</source>
          <target state="translated">ObjectPicker</target>
        </trans-unit>
        <trans-unit id="0f4891d4118b365ec653e1e4eca5914fa49041e5" translate="yes" xml:space="preserve">
          <source>ObjectPicker (QML type)</source>
          <target state="translated">ObjectPicker (QML 유형)</target>
        </trans-unit>
        <trans-unit id="1758dc9d669c3dae2c2211d5eaf992aacbe591b7" translate="yes" xml:space="preserve">
          <source>ObjectPicker QML Type</source>
          <target state="translated">ObjectPicker QML 유형</target>
        </trans-unit>
        <trans-unit id="507339a348dd2d6b196a98c18b40c02ba4df22a8" translate="yes" xml:space="preserve">
          <source>ObjectPicker.clicked()</source>
          <target state="translated">ObjectPicker.clicked()</target>
        </trans-unit>
        <trans-unit id="27866cd0f6d62f2e339bdee1f0c0230c076380e7" translate="yes" xml:space="preserve">
          <source>ObjectPicker.containsMouse</source>
          <target state="translated">ObjectPicker.containsMouse</target>
        </trans-unit>
        <trans-unit id="300340c1f2a8b92d91339a7eb11dcc6d918752fe" translate="yes" xml:space="preserve">
          <source>ObjectPicker.dragEnabled</source>
          <target state="translated">ObjectPicker.dragEnabled</target>
        </trans-unit>
        <trans-unit id="bb821c4a974ac836f5c749c47eac4234ebd0ba93" translate="yes" xml:space="preserve">
          <source>ObjectPicker.entered()</source>
          <target state="translated">ObjectPicker.entered()</target>
        </trans-unit>
        <trans-unit id="00792cc1be17d67a85c13a0e2a6a6d728e7c9497" translate="yes" xml:space="preserve">
          <source>ObjectPicker.exited()</source>
          <target state="translated">ObjectPicker.exited()</target>
        </trans-unit>
        <trans-unit id="d08009166a3d37ee63723f549b2c4fbb61eef012" translate="yes" xml:space="preserve">
          <source>ObjectPicker.hoverEnabled</source>
          <target state="translated">ObjectPicker.hoverEnabled</target>
        </trans-unit>
        <trans-unit id="bec1be36848c446606c738946083276662813747" translate="yes" xml:space="preserve">
          <source>ObjectPicker.moved()</source>
          <target state="translated">ObjectPicker.moved()</target>
        </trans-unit>
        <trans-unit id="8dd5ea1a0a6304cea13b321baa29a6466829005c" translate="yes" xml:space="preserve">
          <source>ObjectPicker.pressed</source>
          <target state="translated">ObjectPicker.pressed</target>
        </trans-unit>
        <trans-unit id="d4fe5a38f133ca841e86e4776346655604454350" translate="yes" xml:space="preserve">
          <source>ObjectPicker.pressed()</source>
          <target state="translated">ObjectPicker.pressed()</target>
        </trans-unit>
        <trans-unit id="7a14a61287843ea6096b325f76352d77cc498df2" translate="yes" xml:space="preserve">
          <source>ObjectPicker.priority</source>
          <target state="translated">ObjectPicker.priority</target>
        </trans-unit>
        <trans-unit id="5297e8bc5538b08bd4dc7e94f07f455a5c95a6ee" translate="yes" xml:space="preserve">
          <source>ObjectPicker.released()</source>
          <target state="translated">ObjectPicker.released()</target>
        </trans-unit>
        <trans-unit id="242f07e44cae59f9d77439e072977b098b649199" translate="yes" xml:space="preserve">
          <source>ObjectType *</source>
          <target state="translated">객체 유형 *</target>
        </trans-unit>
        <trans-unit id="e46bdd3b3ef0bf18798ba83ac0aa56a0b8c72fce" translate="yes" xml:space="preserve">
          <source>ObjectType *QRemoteObjectNode::acquire(const &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; &amp;amp;</source>
          <target state="translated">ObjectType * QRemoteObjectNode :: acquire (const &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; &amp;amp;</target>
        </trans-unit>
        <trans-unit id="39255a2a89f3ceb835e0d6a0969bd48af940aed0" translate="yes" xml:space="preserve">
          <source>Objects and their properties form the basis of a graphical interface defined in a QML document. The QML language allows properties to be bound to each other in various ways, enabling highly dynamic user interfaces.</source>
          <target state="translated">오브젝트 및 해당 특성은 QML 문서에 정의 된 그래픽 인터페이스의 기초를 형성합니다. QML 언어를 사용하면 속성을 다양한 방식으로 서로 바인딩 할 수 있으므로 매우 동적 인 사용자 인터페이스가 가능합니다.</target>
        </trans-unit>
        <trans-unit id="4a917cd25aa30b58e4896cb03b974abb05e020fd" translate="yes" xml:space="preserve">
          <source>Objects are added to the form by dragging them from the main widget box and dropping them in the desired location on the form. Once there, they can be moved around simply by dragging them, or using the cursor keys. Pressing the &lt;b&gt;Ctrl&lt;/b&gt; key at the same time moves the selected widget pixel by pixel, while using the cursor keys alone make the selected widget snap to the grid when it is moved. Objects can be selected by clicking on them with the left mouse button. You can also use the &lt;b&gt;Tab&lt;/b&gt; key to change the selection.</source>
          <target state="translated">기본 위젯 상자에서 개체를 끌어서 양식의 원하는 위치에 놓으면 개체가 양식에 추가됩니다. 일단 이동하면 커서를 끌거나 커서 키를 사용하여 간단히 이동할 수 있습니다. &lt;b&gt;Ctrl&lt;/b&gt; 키를 동시에 누르면 선택한 위젯이 픽셀 단위로 이동하는 반면 커서 키만 사용하면 선택한 위젯이 이동 될 때 그리드에 스냅됩니다. 마우스 왼쪽 버튼으로 개체를 클릭하여 개체를 선택할 수 있습니다. &lt;b&gt;Tab&lt;/b&gt; 키를 사용하여 선택을 변경할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="778ae058d98e2788188f6cc27919e4753053c228" translate="yes" xml:space="preserve">
          <source>Objects are colored using a full gradient for each object regardless of object height. The gradient used is specified in &lt;a href=&quot;q3dtheme#baseGradients-prop&quot;&gt;baseGradients&lt;/a&gt;, &lt;a href=&quot;q3dtheme#singleHighlightGradient-prop&quot;&gt;singleHighlightGradient&lt;/a&gt; and &lt;a href=&quot;q3dtheme#multiHighlightGradient-prop&quot;&gt;multiHighlightGradient&lt;/a&gt; properties.</source>
          <target state="translated">객체는 객체 높이에 관계없이 각 객체에 대해 전체 그라데이션을 사용하여 색상이 지정됩니다. 사용 된 그라디언트는 &lt;a href=&quot;q3dtheme#baseGradients-prop&quot;&gt;baseGradients&lt;/a&gt; , &lt;a href=&quot;q3dtheme#singleHighlightGradient-prop&quot;&gt;singleHighlightGradient&lt;/a&gt; 및 &lt;a href=&quot;q3dtheme#multiHighlightGradient-prop&quot;&gt;multiHighlightGradient&lt;/a&gt; 속성에 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="c06922c099c931bd955e1c74efd413ccb359bd5f" translate="yes" xml:space="preserve">
          <source>Objects are colored using a portion of the full gradient determined by the object's height and its position on the Y-axis. The gradient used is specified in &lt;a href=&quot;q3dtheme#baseGradients-prop&quot;&gt;baseGradients&lt;/a&gt;, &lt;a href=&quot;q3dtheme#singleHighlightGradient-prop&quot;&gt;singleHighlightGradient&lt;/a&gt; and &lt;a href=&quot;q3dtheme#multiHighlightGradient-prop&quot;&gt;multiHighlightGradient&lt;/a&gt; properties.</source>
          <target state="translated">객체의 높이와 Y 축에서의 위치에 따라 결정된 전체 그라디언트의 일부를 사용하여 객체의 색상이 지정됩니다. 사용 된 그라디언트는 &lt;a href=&quot;q3dtheme#baseGradients-prop&quot;&gt;baseGradients&lt;/a&gt; , &lt;a href=&quot;q3dtheme#singleHighlightGradient-prop&quot;&gt;singleHighlightGradient&lt;/a&gt; 및 &lt;a href=&quot;q3dtheme#multiHighlightGradient-prop&quot;&gt;multiHighlightGradient&lt;/a&gt; 속성에 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="68ba03f4d3ce8e325872eb66deb74b9f22065f4b" translate="yes" xml:space="preserve">
          <source>Objects are rendered in a single color. The color used is specified in &lt;a href=&quot;q3dtheme#baseColors-prop&quot;&gt;baseColors&lt;/a&gt;, &lt;a href=&quot;q3dtheme#singleHighlightColor-prop&quot;&gt;singleHighlightColor&lt;/a&gt; and &lt;a href=&quot;q3dtheme#multiHighlightColor-prop&quot;&gt;multiHighlightColor&lt;/a&gt; properties.</source>
          <target state="translated">객체는 단일 색상으로 렌더링됩니다. 사용되는 색상은 &lt;a href=&quot;q3dtheme#baseColors-prop&quot;&gt;baseColors&lt;/a&gt; , &lt;a href=&quot;q3dtheme#singleHighlightColor-prop&quot;&gt;singleHighlightColor&lt;/a&gt; 및 &lt;a href=&quot;q3dtheme#multiHighlightColor-prop&quot;&gt;multiHighlightColor&lt;/a&gt; 속성에 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="e5c30edaf09673ff06977a35ad3cd677c002aa2e" translate="yes" xml:space="preserve">
          <source>Objects can be inserted into an existing layout by dragging them from their current positions and dropping them at the required location. A blue cursor is displayed in the layout as an object is dragged over it to indicate where the object will be added.</source>
          <target state="translated">객체를 현재 위치에서 드래그하여 필요한 위치에 놓아 기존 레이아웃에 삽입 할 수 있습니다. 객체를 드래그 할 때 레이아웃에 파란색 커서가 표시되어 객체가 추가 될 위치를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="7b0c34712c09d9361a7a0125db02767882015b02" translate="yes" xml:space="preserve">
          <source>Objects created with &lt;a href=&quot;qml-qtqml-qt#createQmlObject-method&quot;&gt;Qt.createQmlObject()&lt;/a&gt; can similarly be destroyed using &lt;code&gt;destroy()&lt;/code&gt;:</source>
          <target state="translated">&lt;a href=&quot;qml-qtqml-qt#createQmlObject-method&quot;&gt;Qt.createQmlObject ()로&lt;/a&gt; 생성 된 객체는 &lt;code&gt;destroy()&lt;/code&gt; 사용하여 비슷하게 파괴 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7124bb3bfd66f83df7d12d9629a94cf43a5fe842" translate="yes" xml:space="preserve">
          <source>Objects created with the default constructor will be invalid and therefore not ready for use.</source>
          <target state="translated">기본 생성자로 작성된 객체는 유효하지 않으므로 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3b72af5140bc7d68db27b2814ddd4bd23c00938e" translate="yes" xml:space="preserve">
          <source>Objects expose functionality of all super-classes up to and including the class name in value. See &lt;a href=&quot;qaxfactory#exposeToSuperClass&quot;&gt;QAxFactory::exposeToSuperClass&lt;/a&gt;()</source>
          <target state="translated">객체는 클래스 이름 이하의 모든 수퍼 클래스의 기능을 가치에 노출시킵니다. 참조 &lt;a href=&quot;qaxfactory#exposeToSuperClass&quot;&gt;QAxFactory :: exposeToSuperClass을&lt;/a&gt; ()</target>
        </trans-unit>
        <trans-unit id="3a48d867388a6607b5f267eb72c29b56840d7548" translate="yes" xml:space="preserve">
          <source>Objects expose stock events if value is &quot;yes&quot;. See &lt;a href=&quot;qaxfactory#hasStockEvents&quot;&gt;QAxFactory::hasStockEvents&lt;/a&gt;()</source>
          <target state="translated">값이 &quot;예&quot;인 경우 개체가 스톡 이벤트를 노출합니다. 참조 &lt;a href=&quot;qaxfactory#hasStockEvents&quot;&gt;QAxFactory :: hasStockEvents을&lt;/a&gt; ()</target>
        </trans-unit>
        <trans-unit id="d9d6a6cf35a0baf2f93a28ee44478c86e73d0ab4" translate="yes" xml:space="preserve">
          <source>Objects not-created by QML have CppOwnership by default. The exception to this are objects returned from C++ method calls; their ownership will be set to JavaScriptOwnership. This applies only to explicit invocations of &lt;a href=&quot;qobject#Q_INVOKABLE&quot;&gt;Q_INVOKABLE&lt;/a&gt; methods or slots, but not to property getter invocations.</source>
          <target state="translated">QML에 의해 생성되지 않은 객체는 기본적으로 CppOwnership을 갖습니다. 이에 대한 예외는 C ++ 메소드 호출에서 리턴 된 오브젝트입니다. 소유권은 JavaScriptOwnership으로 설정됩니다. 이는 &lt;a href=&quot;qobject#Q_INVOKABLE&quot;&gt;Q_INVOKABLE&lt;/a&gt; 메소드 또는 슬롯 의 명시 적 호출에만 적용되며 특성 게터 호출에는 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a5f036acc99b80b309a7d853ada79a4340320d23" translate="yes" xml:space="preserve">
          <source>Objects not-created by the JavaScript memory manager have CppOwnership by default. The exception to this are objects returned from C++ method calls; their ownership will be set to JavaScriptOwnership. This applies only to explicit invocations of &lt;a href=&quot;qobject#Q_INVOKABLE&quot;&gt;Q_INVOKABLE&lt;/a&gt; methods or slots, but not to property getter invocations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4eae5453fa257db78db1751afc2007ad82818e7a" translate="yes" xml:space="preserve">
          <source>Objects of this class can be used to check whether the conversion was successful, and if so, retrieve the decoded &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt;. The conversion operators defined for &lt;a href=&quot;qbytearray-frombase64result&quot;&gt;QByteArray::FromBase64Result&lt;/a&gt; make its usage straightforward:</source>
          <target state="translated">이 클래스의 객체는 변환이 성공했는지 확인하는 데 사용할 수 있으며 성공한 경우 디코딩 된 &lt;a href=&quot;qbytearray&quot;&gt;QByteArray를&lt;/a&gt; 검색합니다 . &lt;a href=&quot;qbytearray-frombase64result&quot;&gt;QByteArray :: FromBase64Result에&lt;/a&gt; 대해 정의 된 변환 연산자 는 사용법을 간단하게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="79bb80c9eec44a6e669dfb4033b27bc4d55d28a1" translate="yes" xml:space="preserve">
          <source>Objects of this class cannot be copied, but can be moved, so you can maintain a list of basic timers by holding them in container that supports move-only types, e.g. std::vector.</source>
          <target state="translated">이 클래스의 객체는 복사 할 수 없지만 이동할 수 있으므로 이동 전용 유형 (예 : std :: vector)을 지원하는 컨테이너에 보관하여 기본 타이머 목록을 유지할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b2ed93aa58cc4d930e4072f860845a2be981a58c" translate="yes" xml:space="preserve">
          <source>Objects of this type are created with the static &lt;a href=&quot;qdbusmessage#createError&quot;&gt;createError&lt;/a&gt;(), &lt;a href=&quot;qdbusmessage#createMethodCall&quot;&gt;createMethodCall&lt;/a&gt;() and &lt;a href=&quot;qdbusmessage#createSignal&quot;&gt;createSignal&lt;/a&gt;() functions. Use the &lt;a href=&quot;qdbusconnection#send&quot;&gt;QDBusConnection::send&lt;/a&gt;() function to send the messages.</source>
          <target state="translated">이 유형의 객체는 정적 &lt;a href=&quot;qdbusmessage#createError&quot;&gt;createError&lt;/a&gt; (), &lt;a href=&quot;qdbusmessage#createMethodCall&quot;&gt;createMethodCall&lt;/a&gt; () 및 &lt;a href=&quot;qdbusmessage#createSignal&quot;&gt;createSignal&lt;/a&gt; () 함수로 생성됩니다. 사용 &lt;a href=&quot;qdbusconnection#send&quot;&gt;QDBusConnection :: 전송&lt;/a&gt; 메시지를 보내 () 함수를.</target>
        </trans-unit>
        <trans-unit id="e5bf01167f885dfa1d79c937e78f82db58954789" translate="yes" xml:space="preserve">
          <source>Objects of type QDBusUnixFileDescriptors can be used also as parameters in signals and slots that get exported to D-Bus by registering with &lt;a href=&quot;qdbusconnection#registerObject&quot;&gt;QDBusConnection::registerObject&lt;/a&gt;.</source>
          <target state="translated">QDBusUnixFileDescriptors 유형의 오브젝트는 &lt;a href=&quot;qdbusconnection#registerObject&quot;&gt;QDBusConnection :: registerObject&lt;/a&gt; 에 등록하여 D-Bus로 내보내는 신호 및 슬롯의 매개 변수로도 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3e357d1ff5ca324987ebd92b7b26ec3eef631c85" translate="yes" xml:space="preserve">
          <source>Objects on the form are selected by clicking on them with the left mouse button. When an object is selected, resize handles are shown at each corner and the midpoint of each side, indicating that it can be resized.</source>
          <target state="translated">마우스 왼쪽 버튼으로 개체를 클릭하면 양식의 개체가 선택됩니다. 객체를 선택하면 크기 조정 핸들이 각 모서리와 중간 점에 표시되어 크기를 조정할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="6294b16895408ae8a18e40be4d509eccd34a9318" translate="yes" xml:space="preserve">
          <source>Objects shared over QtRO use the links (conduits) between nodes for all communication. If you intend to share a &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;, you must create a</source>
          <target state="translated">QtRO를 통해 공유되는 객체는 모든 통신에 노드 간 링크 (도관)를 사용합니다. 당신이 공유하려는 경우 &lt;a href=&quot;qobject&quot;&gt;QObject를을&lt;/a&gt; , 당신은을 만들어야합니다</target>
        </trans-unit>
        <trans-unit id="a11331ff79316dcc1be28a4e229b654ed8e9fecf" translate="yes" xml:space="preserve">
          <source>Objects shared over QtRO use the links (conduits) between nodes for all communication. If you want to share a &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;, you must create a</source>
          <target state="translated">QtRO를 통해 공유되는 객체는 모든 통신을 위해 노드 간의 링크 (도관)를 사용합니다. &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 를 공유 하려면</target>
        </trans-unit>
        <trans-unit id="a85e993cfc7e8518e8693e1cf5eeab7148aa9205" translate="yes" xml:space="preserve">
          <source>Objects within this normalized range of &lt;a href=&quot;qml-qtquick3d-effects-tiltshift#focusPosition-prop&quot;&gt;focusPosition&lt;/a&gt; will be in focus. Range is &lt;code&gt;[0...1]&lt;/code&gt;. &lt;code&gt;0.2&lt;/code&gt; by default.</source>
          <target state="translated">이 정규화 된 &lt;a href=&quot;qml-qtquick3d-effects-tiltshift#focusPosition-prop&quot;&gt;focusPosition&lt;/a&gt; 범위 내에있는 오브젝트 가 초점을 맞 춥니 다. 범위는 &lt;code&gt;[0...1]&lt;/code&gt; 입니다. 기본적으로 &lt;code&gt;0.2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d5419a33da466649584283aaf981083ab4d6ec39" translate="yes" xml:space="preserve">
          <source>Obsolete Commands</source>
          <target state="translated">사용되지 않는 명령</target>
        </trans-unit>
        <trans-unit id="b2bb056990421e57e9424fc4be204dff38320098" translate="yes" xml:space="preserve">
          <source>Obsolete Members for MyClass</source>
          <target state="translated">MyClass에 사용되지 않는 멤버</target>
        </trans-unit>
        <trans-unit id="deb945396e3f8946f4b3a3733ee740d3cc541a8d" translate="yes" xml:space="preserve">
          <source>Obsolete QML Types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31524043a32dcf2421a07c736eab6a15d692673c" translate="yes" xml:space="preserve">
          <source>Obsolete alias for Http2AllowedAttribute.</source>
          <target state="translated">Http2AllowedAttribute의 사용되지 않는 별칭입니다.</target>
        </trans-unit>
        <trans-unit id="0c8719ed9bafd473e78fc384b804da7b79831f42" translate="yes" xml:space="preserve">
          <source>Obsolete alias for Http2WasUsedAttribute.</source>
          <target state="translated">Http2WasUsedAttribute의 사용되지 않는 별칭입니다.</target>
        </trans-unit>
        <trans-unit id="2cf0733798f7a6e2dc88e17de1119d2a935abd66" translate="yes" xml:space="preserve">
          <source>Obsolete and has no effect.</source>
          <target state="translated">구식이며 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="d81ea7373bafcdbcce99144225ab981920b37861" translate="yes" xml:space="preserve">
          <source>Obsolete members</source>
          <target state="translated">더 이상 사용되지 않는 회원</target>
        </trans-unit>
        <trans-unit id="1303b64b626f9862a3ab911f54129595488daeb3" translate="yes" xml:space="preserve">
          <source>Obsolete, means the same as TlsV1_0</source>
          <target state="translated">폐기 됨, TlsV1_0과 동일 함</target>
        </trans-unit>
        <trans-unit id="126f68650a3c883c5966dde77a69da756c5112f6" translate="yes" xml:space="preserve">
          <source>Obsolete, please use Akan</source>
          <target state="translated">단종 된 Akan을 사용하십시오</target>
        </trans-unit>
        <trans-unit id="7cd5dc5dc3d4fcc25cce51fde084d5bc6bae13e3" translate="yes" xml:space="preserve">
          <source>Obsolete, please use Bangla</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5e0c3d6db49a666f23bd44e9e13b4f5177f2dbf" translate="yes" xml:space="preserve">
          <source>Obsolete, please use BanglaScript</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55c870676c833eb851ce2251ea0fb2c660adcef2" translate="yes" xml:space="preserve">
          <source>Obsolete, please use Belarusian</source>
          <target state="translated">구식, 벨로루시 어를 사용하십시오</target>
        </trans-unit>
        <trans-unit id="3d3237ed66a698c472b5e0b9e2a9c3d3dcc120c3" translate="yes" xml:space="preserve">
          <source>Obsolete, please use CentralAtlasTamazight</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3da6cf42e78de4a6316a4146df5315740e38de45" translate="yes" xml:space="preserve">
          <source>Obsolete, please use CongoBrazzaville</source>
          <target state="translated">더 이상 사용되지 않습니다. CongoBrazzaville를 사용하십시오</target>
        </trans-unit>
        <trans-unit id="6d2f24715c910c01cee7a6bdb458cfd85ae37fee" translate="yes" xml:space="preserve">
          <source>Obsolete, please use CongoKinshasa</source>
          <target state="translated">단종 된 콩고 킨 샤사</target>
        </trans-unit>
        <trans-unit id="a8bbfbffc459308085ae7bcbd4ab175bc1514e12" translate="yes" xml:space="preserve">
          <source>Obsolete, please use Dzongkha</source>
          <target state="translated">더 이상 사용하지 마십시오</target>
        </trans-unit>
        <trans-unit id="0700b24d6a0b0f0e3ea0a5836dabf2ac82487ba8" translate="yes" xml:space="preserve">
          <source>Obsolete, please use Filipino</source>
          <target state="translated">더 이상 사용되지 않는 필리핀어를 사용하십시오</target>
        </trans-unit>
        <trans-unit id="1367be3451b62bd3ac41f803a8f3428ecf881a66" translate="yes" xml:space="preserve">
          <source>Obsolete, please use Inupiaq</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b88e84266dd5769dabcf614475ccc3fbf48b7394" translate="yes" xml:space="preserve">
          <source>Obsolete, please use Kalaallisut</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d46ef5f9abcd242fdeb3181e8b45efccbbb82103" translate="yes" xml:space="preserve">
          <source>Obsolete, please use Khmer</source>
          <target state="translated">더 이상 사용되지 않습니다</target>
        </trans-unit>
        <trans-unit id="0442d11ee83db649d8aa59930d94e1f799eed2e4" translate="yes" xml:space="preserve">
          <source>Obsolete, please use Kuanyama</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="302fd1bed47cf04614a91553a5be2449bb8abc9a" translate="yes" xml:space="preserve">
          <source>Obsolete, please use Kyrgyz</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ff018a1d754e1ce47ee01712b04779873ce2b1d" translate="yes" xml:space="preserve">
          <source>Obsolete, please use LatinAmerica</source>
          <target state="translated">더 이상 사용되지 않는 라틴 아메리카를 사용하십시오</target>
        </trans-unit>
        <trans-unit id="df989b0decbe657754e62849c3a879082700b3da" translate="yes" xml:space="preserve">
          <source>Obsolete, please use MendeScript</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec76857cb98913ab838306cedc972cae6feadf32" translate="yes" xml:space="preserve">
          <source>Obsolete, please use Navajo</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b8ccf7bea421707eefa30235f7572ea439a4abb" translate="yes" xml:space="preserve">
          <source>Obsolete, please use NorthKorea</source>
          <target state="translated">단종 된 북한을 사용하십시오</target>
        </trans-unit>
        <trans-unit id="d2d1cb393abd98e3ff6261155d4e607836200851" translate="yes" xml:space="preserve">
          <source>Obsolete, please use Nyanja</source>
          <target state="translated">더 이상 사용되지 않습니다, Nyanja를 사용하십시오</target>
        </trans-unit>
        <trans-unit id="d15da072e2d5b3afdb6f2d0ec5ff2ffb4b671856" translate="yes" xml:space="preserve">
          <source>Obsolete, please use Odia</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8781c7199e49b847fec847c6ad91ff798c138c86" translate="yes" xml:space="preserve">
          <source>Obsolete, please use OdiaScript</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7478563538ec1b6c82c6bb040e62619f99bd2a5" translate="yes" xml:space="preserve">
          <source>Obsolete, please use Oromo</source>
          <target state="translated">더 이상 사용되지 않는 Oromo를 사용하십시오</target>
        </trans-unit>
        <trans-unit id="8b81ecf2c2588da244ebeeb3d81f861589d50007" translate="yes" xml:space="preserve">
          <source>Obsolete, please use Romanian</source>
          <target state="translated">더 이상 사용되지 않는, 루마니아어를 사용하십시오</target>
        </trans-unit>
        <trans-unit id="631c312eb9e58b6681dbd0404f966e48161ad5be" translate="yes" xml:space="preserve">
          <source>Obsolete, please use Romansh</source>
          <target state="translated">더 이상 사용하지 않는 Romansh를 사용하십시오</target>
        </trans-unit>
        <trans-unit id="f1d6ec2cba377ca839f8d0319e22054341e2efbd" translate="yes" xml:space="preserve">
          <source>Obsolete, please use Rundi</source>
          <target state="translated">더 이상 사용되지 않는 Rundi를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="2b5f6472f178dc5c562335121461ec9c54b95f97" translate="yes" xml:space="preserve">
          <source>Obsolete, please use Serbian</source>
          <target state="translated">더 이상 사용되지 않는 세르비아어를 사용하십시오</target>
        </trans-unit>
        <trans-unit id="c3622b3f40bd9d783777119d4d1919f9d42671d3" translate="yes" xml:space="preserve">
          <source>Obsolete, please use SouthKorea</source>
          <target state="translated">더 이상 사용하지 마십시오, 한국을 사용하십시오</target>
        </trans-unit>
        <trans-unit id="1d1a07b7ce475df352aa2224331a00f5c08b365f" translate="yes" xml:space="preserve">
          <source>Obsolete, please use Syria</source>
          <target state="translated">사용되지 않는 시리아를 사용하십시오</target>
        </trans-unit>
        <trans-unit id="405b7c971de173fb7c7cbbde4e414f9e6f78de67" translate="yes" xml:space="preserve">
          <source>Obsolete, please use TokelauCountry</source>
          <target state="translated">더 이상 사용되지 않는 TokelauCountry를 사용하십시오</target>
        </trans-unit>
        <trans-unit id="8fee2ea224ba53f58e94ad98c90e10c5d5366349" translate="yes" xml:space="preserve">
          <source>Obsolete, please use TuvaluCountry</source>
          <target state="translated">더 이상 사용되지 않는 TuvaluCountry를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="91e80585316dcd90e53eff17afd2561970d07bd1" translate="yes" xml:space="preserve">
          <source>Obsolete, please use Uighur</source>
          <target state="translated">구식, 위구르어를 사용하십시오</target>
        </trans-unit>
        <trans-unit id="0efe7f00c1dd84017423210c651a0d5c3ec5e801" translate="yes" xml:space="preserve">
          <source>Obsolete, please use Uyghur</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c06c7ce1a7dafaa8892f54d14a9e995e37f23f1" translate="yes" xml:space="preserve">
          <source>Obsolete, please use Wolaytta</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ecd0e11f525ff13964b8e81b835dcfb7692acfb" translate="yes" xml:space="preserve">
          <source>Obsolete, use &lt;code&gt;BosniaAndHerzegovina&lt;/code&gt; instead</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33bd8ec2eb4574bfab62e1e14c5b236b3c2ac4e7" translate="yes" xml:space="preserve">
          <source>Obsolete, use &lt;code&gt;CongoBrazzaville&lt;/code&gt; instead</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70a34c95f49e670d945ac75269a5ab11766b2419" translate="yes" xml:space="preserve">
          <source>Obsolete, use &lt;code&gt;CongoKinshasa&lt;/code&gt; instead</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82234d249e5963f9641668514af28306b26d476c" translate="yes" xml:space="preserve">
          <source>Obsolete, use &lt;code&gt;Curacao&lt;/code&gt; instead</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="719b30bbb11f87c0fdfbd784981651204ea26a64" translate="yes" xml:space="preserve">
          <source>Obsolete, use &lt;code&gt;Czechia&lt;/code&gt; instead</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f04fb706be56e77ac7157ee94aa04b1c88e99ff" translate="yes" xml:space="preserve">
          <source>Obsolete, use &lt;code&gt;LatinAmerica&lt;/code&gt; instead</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7603fac637bb827106e91e4cc142640b026dd0d" translate="yes" xml:space="preserve">
          <source>Obsolete, use &lt;code&gt;NorthKorea&lt;/code&gt; instead</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d78d396d88a3fb23df80ced587bfcabf5caf28d" translate="yes" xml:space="preserve">
          <source>Obsolete, use &lt;code&gt;SouthKorea&lt;/code&gt; instead</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="756cb3250424c8d704692ff77057a3753b460ec3" translate="yes" xml:space="preserve">
          <source>Obsolete, use &lt;code&gt;Syria&lt;/code&gt; instead</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c05733879e2e00081332ab4303d245049251051f" translate="yes" xml:space="preserve">
          <source>Obsolete. An integer specifying the number of copies. Use PPK_CopyCount instead.</source>
          <target state="translated">더 이상 사용되지 않습니다. 사본 수를 지정하는 정수입니다. PPK_CopyCount를 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="7a5b66ae61a030c47ab12b2f0221016d2bd5445e" translate="yes" xml:space="preserve">
          <source>Obsolete. Use PE_FrameStatusBarItem instead.</source>
          <target state="translated">더 이상 사용되지 않습니다. 대신 PE_FrameStatusBarItem을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="214d5b6c283a8d0e6e4f53ff8d7222ffa0d8e03e" translate="yes" xml:space="preserve">
          <source>Obsolete. Use PM_MdiSubWindowFrameWidth instead.</source>
          <target state="translated">더 이상 사용되지 않습니다. 대신 PM_MdiSubWindowFrameWidth를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="79fb8305b897a9121d3571cf9f3ca69601017cef" translate="yes" xml:space="preserve">
          <source>Obsolete. Use PM_MdiSubWindowMinimizedWidth instead.</source>
          <target state="translated">더 이상 사용되지 않습니다. 대신 PM_MdiSubWindowMinimizedWidth를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="81baebcc9e684d95840e47fc12b98c40734d57de" translate="yes" xml:space="preserve">
          <source>Obsolete. Use PPK_PaperSize instead.</source>
          <target state="translated">더 이상 사용되지 않습니다. 대신 PPK_PaperSize를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f78c6b669563292a61139c7561d8dc5b8adbc604" translate="yes" xml:space="preserve">
          <source>Obsolete. Use SH_Slider_StopMouseOverSlider instead.</source>
          <target state="translated">더 이상 사용되지 않습니다. 대신 SH_Slider_StopMouseOverSlider를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="dfe119493aae9f23597894a4d012c4249abe1f9e" translate="yes" xml:space="preserve">
          <source>Obsolete. Use SpellCheckUnderlineStyle hint in QPlatformTheme instead.</source>
          <target state="translated">더 이상 사용되지 않습니다. 대신 QPlatformTheme에서 SpellCheckUnderlineStyle 힌트를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="29f3ef2bc31211e02b61235b0b8fe8e0c3f3ed6b" translate="yes" xml:space="preserve">
          <source>Obsoletes the action accessors of Qt 4.X.</source>
          <target state="translated">Qt 4.X의 액션 접근자를 폐기합니다.</target>
        </trans-unit>
        <trans-unit id="19ebe07d722b6f7241198edb1da1a709cb2aa6e4" translate="yes" xml:space="preserve">
          <source>Obtaining a Desktop Widget</source>
          <target state="translated">데스크탑 위젯 얻기</target>
        </trans-unit>
        <trans-unit id="e9dad526834de21f7dba68e0aa7bd1a4484997e9" translate="yes" xml:space="preserve">
          <source>Obtaining a QPlaceManager Instance</source>
          <target state="translated">QPlaceManager 인스턴스 얻기</target>
        </trans-unit>
        <trans-unit id="fd579e0f2327bfda15d734738c0594357b10bb01" translate="yes" xml:space="preserve">
          <source>Obviously if you just want to render a simple cube onscreen you may think this is overkill. However, as soon as you want to start doing slightly more complex scenes this comes in handy. For the common cases, Qt 3D provides some example framegraphs that are ready to use out of the box.</source>
          <target state="translated">분명히 간단한 큐브를 화면에 렌더링하려면 이것이 과도하다고 생각할 수 있습니다. 그러나 좀 더 복잡한 장면을 시작하자마자 편리합니다. 일반적인 경우, Qt 3D는 즉시 사용할 수있는 몇 가지 프레임 그래프 예제를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="6f7e3706e45c1109047a51243fd474dbd63ed86d" translate="yes" xml:space="preserve">
          <source>Obviously, the &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt; object declared in this example is very simple indeed, as it defines nothing more than a few property values. To create more useful objects, an object declaration may define many other types of attributes: these are discussed in the &lt;a href=&quot;qtqml-syntax-objectattributes&quot;&gt;QML Object Attributes&lt;/a&gt; documentation. Additionally, an object declaration may define child objects, as discussed below.</source>
          <target state="translated">물론, &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;사각형&lt;/a&gt; 은 몇 가지 속성 값보다 더 아무것도 정의하지 않는다이 예제에서 선언 된 객체는 실제로 매우 간단합니다. 더 유용한 객체를 생성하기 위해 객체 선언은 다른 많은 유형의 속성을 정의 할 수 있습니다. 이러한 속성은 &lt;a href=&quot;qtqml-syntax-objectattributes&quot;&gt;QML 객체 속성&lt;/a&gt; 문서에서 설명합니다. 또한 아래에서 설명하는 것처럼 객체 선언은 자식 객체를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5794e8aaef4df676e90ec4ba52f306c4e4be8bf0" translate="yes" xml:space="preserve">
          <source>Obviously, the &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt; object declared in this example is very simple indeed, as it defines nothing more than a few property values. To create more useful objects, an object declaration may define many other types of attributes: these are discussed in the &lt;a href=&quot;qtqml-syntax-objectattributes#&quot;&gt;QML Object Attributes&lt;/a&gt; documentation. Additionally, an object declaration may define child objects, as discussed below.</source>
          <target state="translated">분명히이 예제에서 선언 된 &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt; 객체는 속성 값이 몇 개에 지나지 않기 때문에 매우 간단합니다. 보다 유용한 객체를 생성하기 위해 객체 선언은 많은 다른 유형의 속성을 정의 할 수 있습니다. 이러한 속성은 &lt;a href=&quot;qtqml-syntax-objectattributes#&quot;&gt;QML 객체 속성&lt;/a&gt; 문서에서 설명합니다. 또한 객체 선언은 아래에 설명 된대로 자식 객체를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7de031c038bfc07c9211f623862c607d8ce2ceb2" translate="yes" xml:space="preserve">
          <source>Occasionally, there isn't such an event-specific function, or the event-specific function isn't sufficient. The most common example involves Tab key presses. Normally, &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; intercepts these to move the keyboard focus, but a few widgets need the Tab key for themselves.</source>
          <target state="translated">경우에 따라 이러한 이벤트 별 기능이 없거나 이벤트 별 기능이 충분하지 않은 경우가 있습니다. 가장 일반적인 예는 Tab 키 누름입니다. 일반적으로 &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; 은 키보드 포커스를 이동하기 위해이를 가로 채지 만 일부 위젯에는 Tab 키가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="d5a8ab18f40ec170b29a41f22588573d24fc353b" translate="yes" xml:space="preserve">
          <source>Occasionally, there isn't such an event-specific function, or the event-specific function isn't sufficient. The most common example involves Tab key presses. Normally, &lt;a href=&quot;widgets-changes-qt6#qwidget&quot;&gt;QWidget&lt;/a&gt; intercepts these to move the keyboard focus, but a few widgets need the Tab key for themselves.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10500e54805775e3d661be35724e87f0b1dbc4c9" translate="yes" xml:space="preserve">
          <source>Octal</source>
          <target state="translated">Octal</target>
        </trans-unit>
        <trans-unit id="006ddfd33a63722690d4c6b3c3135a3cf67e75f1" translate="yes" xml:space="preserve">
          <source>October (9)</source>
          <target state="translated">10 월 (9)</target>
        </trans-unit>
        <trans-unit id="ee1aa86865e42a6f5fe2b3d0dce31a842ab7d9d1" translate="yes" xml:space="preserve">
          <source>Odd-even fill rule.</source>
          <target state="translated">홀수-짝 채우기 규칙.</target>
        </trans-unit>
        <trans-unit id="5a2656ce3572fd6f14dc4d342e513795f4ff9a0a" translate="yes" xml:space="preserve">
          <source>Of course the action also needs a way to be triggered. &lt;a href=&quot;qaccessibleactioninterface#doAction&quot;&gt;doAction()&lt;/a&gt; should invoke the action as advertised by name and description.</source>
          <target state="translated">물론 액션도 트리거 할 수있는 방법이 필요합니다. &lt;a href=&quot;qaccessibleactioninterface#doAction&quot;&gt;doAction ()&lt;/a&gt; 은 이름과 설명으로 알려진 대로 조치를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="539d1ecde8cdd93d82e55c70db69b2f9d0111055" translate="yes" xml:space="preserve">
          <source>Of course, for this case we could have simply used &lt;a href=&quot;qmimedata#setImageData&quot;&gt;setImageData()&lt;/a&gt; instead to supply image data in a variety of formats:</source>
          <target state="translated">물론이 경우 &lt;a href=&quot;qmimedata#setImageData&quot;&gt;setImageData ()를&lt;/a&gt; 사용하여 다양한 형식으로 이미지 데이터를 제공 할 수있었습니다 .</target>
        </trans-unit>
        <trans-unit id="6b2dbf2d303311c5d81f16daba5d932f6b707a9b" translate="yes" xml:space="preserve">
          <source>Of course, in this case, you could (and probably should) have declared &lt;code&gt;s&lt;/code&gt; as &lt;code&gt;const&lt;/code&gt; in the first place:</source>
          <target state="translated">물론,이 경우에, 당신은 &lt;code&gt;s&lt;/code&gt; 를 &lt;code&gt;const&lt;/code&gt; 로 선언 할 수 있었을 것입니다 .</target>
        </trans-unit>
        <trans-unit id="8e698c91a3434a1208848e40d29b43e559271ac6" translate="yes" xml:space="preserve">
          <source>Of course, it is possible to specify more than one file in the &lt;code&gt;generate&lt;/code&gt; or &lt;code&gt;register&lt;/code&gt; section, so any number of compressed help files can be generated and registered in one go.</source>
          <target state="translated">물론 &lt;code&gt;generate&lt;/code&gt; 또는 &lt;code&gt;register&lt;/code&gt; 섹션 에 둘 이상의 파일을 지정할 수 있으므로 압축 도움말 파일을 한 번에 여러 개 생성하고 등록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d1cdbb36314a4a563bd95617e218b9fe7a8b8388" translate="yes" xml:space="preserve">
          <source>Of the list above, only the 32-bit- and pointer-sized instantiations are guaranteed to work on all platforms. Support for other sizes depends on the compiler and processor architecture the code is being compiled for. To test whether the other types are supported, check the macro &lt;code&gt;Q_ATOMIC_INT\e{nn}_IS_SUPPORTED&lt;/code&gt;, where &lt;code&gt;\e{nn}&lt;/code&gt; is the number of bits desired.</source>
          <target state="translated">위 목록 중 32 비트 및 포인터 크기 인스턴스화 만 모든 플랫폼에서 작동하도록 보장됩니다. 다른 크기에 대한 지원은 코드가 컴파일되는 컴파일러 및 프로세서 아키텍처에 따라 다릅니다. 다른 유형이 지원되는지 테스트하려면 매크로 &lt;code&gt;Q_ATOMIC_INT\e{nn}_IS_SUPPORTED&lt;/code&gt; . 여기서 &lt;code&gt;\e{nn}&lt;/code&gt; 은 원하는 비트 수입니다.</target>
        </trans-unit>
        <trans-unit id="cf30ca7a7191899f1004deabb699e242711ae17d" translate="yes" xml:space="preserve">
          <source>Of which module is this class a member ?</source>
          <target state="translated">이 클래스는 어떤 모듈입니까?</target>
        </trans-unit>
        <trans-unit id="0a724efe8def6ee507dde02a8d5ad3ab0a91fb74" translate="yes" xml:space="preserve">
          <source>Of which module is this class a member?</source>
          <target state="translated">이 클래스가 구성원 인 모듈은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="c61f18c6a55522accf7d2771b789abc3c13411d0" translate="yes" xml:space="preserve">
          <source>Off-screen image representation that can be used as a paint device</source>
          <target state="translated">페인트 장치로 사용할 수있는 오프 스크린 이미지 표현</target>
        </trans-unit>
        <trans-unit id="e71af008d7e5aa29d45aeff84d01efd0bd7d1718" translate="yes" xml:space="preserve">
          <source>Offers an API to access and modify QTextDocuments</source>
          <target state="translated">QTextDocuments에 액세스하고 수정할 수있는 API를 제공합니다</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
