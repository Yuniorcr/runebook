<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="qt">
    <body>
      <group id="qt">
        <trans-unit id="52c782ad46d1294574253126cd5c9c5f784d753b" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;a href=&quot;qtqml-typesystem-basictypes#&quot;&gt;QML Basic Types&lt;/a&gt;, the module comes with the following QML object types:</source>
          <target state="translated">&lt;a href=&quot;qtqml-typesystem-basictypes#&quot;&gt;QML 기본 유형&lt;/a&gt; 외에도 모듈에는 다음과 같은 QML 오브젝트 유형이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="417e8f4aadd4e491d8bdc2da3b8079084ab4beec" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;code&gt;index&lt;/code&gt; property, a list of model data roles are available in the context of each delegate:</source>
          <target state="translated">&lt;code&gt;index&lt;/code&gt; 속성 외에도 각 대리인의 컨텍스트에서 모델 데이터 역할 목록을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a3ef24a6177217e50cdd9ee78dfc67377f72be66" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;code&gt;win32&lt;/code&gt;, &lt;code&gt;macx&lt;/code&gt;, and &lt;code&gt;unix&lt;/code&gt; values used in many scope conditions, various other built-in platform and compiler-specific values can be tested with scopes. These are based on platform specifications provided in Qt's &lt;code&gt;mkspecs&lt;/code&gt; directory. For example, the following lines from a project file show the current specification in use and test for the &lt;code&gt;linux-g++&lt;/code&gt; specification:</source>
          <target state="translated">받는 사람 또한 &lt;code&gt;win32&lt;/code&gt; , &lt;code&gt;macx&lt;/code&gt; 및 &lt;code&gt;unix&lt;/code&gt; 많은 범위의 조건에서 사용하는 값, 다양한 내장 플랫폼과 컴파일러 특정 값 범위로 테스트 할 수 있습니다. 이는 Qt의 &lt;code&gt;mkspecs&lt;/code&gt; 디렉토리에 제공된 플랫폼 사양을 기반으로합니다 . 예를 들어, 프로젝트 파일의 다음 줄은 현재 사용중인 사양을 표시하고 &lt;code&gt;linux-g++&lt;/code&gt; 사양을 테스트합니다 .</target>
        </trans-unit>
        <trans-unit id="37e96a7a2b6385ac07699da5e97ccb33da1f4c22" translate="yes" xml:space="preserve">
          <source>In addition to the above types, Object3D can also serve as the parent for &lt;a href=&quot;qml-qtquick-item&quot;&gt;Qt Quick items&lt;/a&gt;, as well as arbitrary &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; instances. For more information on adding 2D items to the 3D scene, refer to &lt;a href=&quot;qtquick3d-2d&quot;&gt;Qt Quick 3D Scenes with 2D Content&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f70defdd2fa2e597cc5666167d05b26cad5bd42" translate="yes" xml:space="preserve">
          <source>In addition to the application developer APIs, Qt also interfaces with the platform when providing the underlying implementations of the cross-platform building blocks in Qt.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfa395ac5b58e499194cf81c46c2f9bd4bb920ce" translate="yes" xml:space="preserve">
          <source>In addition to the base Qt Quick 3D Model, additional functionality is provided by the following module imports:</source>
          <target state="translated">기본 Qt Quick 3D 모델 외에도 다음 모듈 가져 오기를 통해 추가 기능이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="76ea6e9178553b17cdc78a03bf69f88badb843eb" translate="yes" xml:space="preserve">
          <source>In addition to the build time configuration, Qt supports choosing and loading the OpenGL implementation at runtime. To use this mode, pass &lt;code&gt;-opengl dynamic&lt;/code&gt; to the configure script.</source>
          <target state="translated">빌드 시간 구성 외에도 Qt는 런타임에 OpenGL 구현 선택 및로드를 지원합니다. 이 모드를 사용하려면 &lt;code&gt;-opengl dynamic&lt;/code&gt; 을 configure 스크립트에 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="87cfd16fd78c2b465cefa0f4ffa05984e81073df" translate="yes" xml:space="preserve">
          <source>In addition to the camera projection, the camera direction is also calculated as this is necessary for lighting calculations in the shading code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7af3e3298d92ef46918d809b8a96064abbcc8ca4" translate="yes" xml:space="preserve">
          <source>In addition to the checked and unchecked states, there is a third state: partially checked. The partially checked state can be enabled using the &lt;a href=&quot;qml-qtquick-controls2-checkbox#tristate-prop&quot;&gt;tristate&lt;/a&gt; property. This state indicates that the regular checked/unchecked state can not be determined; generally because of other states that affect the checkbox. This state is useful when several child nodes are selected in a treeview, for example.</source>
          <target state="translated">확인 및 확인되지 않은 상태 외에도 세 번째 상태 인 부분 확인이 있습니다. &lt;a href=&quot;qml-qtquick-controls2-checkbox#tristate-prop&quot;&gt;tristate&lt;/a&gt; 속성을 사용하여 부분적으로 검사 된 상태를 활성화 할 수 있습니다 . 이 상태는 일반 점검 / 검사되지 않은 상태를 판별 할 수 없음을 나타냅니다. 일반적으로 확인란에 영향을 미치는 다른 상태 때문입니다. 이 상태는 예를 들어 트 리뷰에서 여러 자식 노드가 선택된 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="30fe8d793a4d1dc565113d3ae097c00698b55f22" translate="yes" xml:space="preserve">
          <source>In addition to the checked and unchecked states, there is a third state: partially checked. The partially checked state can be enabled using the &lt;a href=&quot;qml-qtquick-controls2-checkdelegate#tristate-prop&quot;&gt;tristate&lt;/a&gt; property. This state indicates that the regular checked/unchecked state can not be determined; generally because of other states that affect the check delegate. This state is useful when several child nodes are selected in a treeview, for example.</source>
          <target state="translated">확인 및 확인되지 않은 상태 외에도 세 번째 상태 인 부분 확인이 있습니다. &lt;a href=&quot;qml-qtquick-controls2-checkdelegate#tristate-prop&quot;&gt;tristate&lt;/a&gt; 속성을 사용하여 부분적으로 검사 된 상태를 활성화 할 수 있습니다 . 이 상태는 일반 점검 / 검사되지 않은 상태를 판별 할 수 없음을 나타냅니다. 일반적으로 수표 대리자에게 영향을주는 다른 상태 때문입니다. 이 상태는 예를 들어 트 리뷰에서 여러 자식 노드가 선택된 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="eab7e7dd6c4505763be2492ac8ad26d746b93263" translate="yes" xml:space="preserve">
          <source>In addition to the checked and unchecked states, there is a third state: partially checked. This state indicates that the regular checked/unchecked state can not be determined; generally because of other states that affect the checkbox. This state is useful when several child nodes are selected in a treeview, for example.</source>
          <target state="translated">확인 및 확인되지 않은 상태 외에도 세 번째 상태 인 부분 확인이 있습니다. 이 상태는 일반 점검 / 검사되지 않은 상태를 판별 할 수 없음을 나타냅니다. 일반적으로 확인란에 영향을 미치는 다른 상태 때문입니다. 이 상태는 예를 들어 트 리뷰에서 여러 자식 노드가 선택된 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="6a017e3c2b18cce999dbad22cc20e6564e42134b" translate="yes" xml:space="preserve">
          <source>In addition to the compiled-in</source>
          <target state="translated">컴파일 된 것 외에도</target>
        </trans-unit>
        <trans-unit id="3880f2d8f61ee136dcf0759b666df50668837724" translate="yes" xml:space="preserve">
          <source>In addition to the constraints on the lvalue-this overload, this rvalue-this overload is only available when this &lt;a href=&quot;qstringtokenizer&quot;&gt;QStringTokenizer&lt;/a&gt; does not store the haystack internally, as this could create a container full of dangling references:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9eaf3e7f3dcb62f52f067b4b06b4c1eb3965285c" translate="yes" xml:space="preserve">
          <source>In addition to the encoding, &lt;a href=&quot;qaudioformat&quot;&gt;QAudioFormat&lt;/a&gt; contains other parameters that further specify how the audio sample data is arranged. These are the frequency, the number of channels, the sample size, the sample type, and the byte order. The following table describes these in more detail.</source>
          <target state="translated">인코딩 외에도 &lt;a href=&quot;qaudioformat&quot;&gt;QAudioFormat&lt;/a&gt; 에는 오디오 샘플 데이터의 배열 방식을 추가로 지정하는 다른 매개 변수가 포함되어 있습니다. 주파수, 채널 수, 샘플 크기, 샘플 유형 및 바이트 순서입니다. 다음 표는 이들에 대해 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="9a244ea8bb5b1a8cb06619e7a69bc8d2849c5770" translate="yes" xml:space="preserve">
          <source>In addition to the encoding, QAudioFormat contains other parameters that further specify how the audio sample data is arranged. These are the frequency, the number of channels, the sample size, the sample type, and the byte order. The following table describes these in more detail.</source>
          <target state="translated">인코딩 외에도 QAudioFormat에는 오디오 샘플 데이터가 배열되는 방식을 추가로 지정하는 다른 매개 변수가 포함되어 있습니다. 주파수, 채널 수, 샘플 크기, 샘플 유형 및 바이트 순서입니다. 다음 표에서는 이에 대해 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="df8285b2079bd253f4ffb0db090898de7b186b6e" translate="yes" xml:space="preserve">
          <source>In addition to the expressions, recognized in the format string to represent parts of the date and time, by &lt;a href=&quot;qdate#fromString&quot;&gt;QDate::fromString&lt;/a&gt;() and &lt;a href=&quot;qtime#fromString&quot;&gt;QTime::fromString&lt;/a&gt;(), this method supports:</source>
          <target state="translated">&lt;a href=&quot;qdate#fromString&quot;&gt;QDate :: fromString&lt;/a&gt; () 및 &lt;a href=&quot;qtime#fromString&quot;&gt;QTime :: fromString&lt;/a&gt; ()에 의해 날짜 및 시간의 일부를 나타내는 형식 문자열에서 인식되는 표현식 외에도이 메서드는 다음을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="01161f1235543028af2e64aca9b51ee52eb5c08f" translate="yes" xml:space="preserve">
          <source>In addition to the functions inherited from &lt;a href=&quot;qgradient&quot;&gt;QGradient&lt;/a&gt;, the &lt;a href=&quot;qconicalgradient&quot;&gt;QConicalGradient&lt;/a&gt; class provides the &lt;a href=&quot;qconicalgradient#angle&quot;&gt;angle&lt;/a&gt;() and &lt;a href=&quot;qconicalgradient#center&quot;&gt;center&lt;/a&gt;() functions returning the start angle and center of the gradient.</source>
          <target state="translated">&lt;a href=&quot;qgradient&quot;&gt;QGradient&lt;/a&gt; 에서 상속 된 함수 외에도 &lt;a href=&quot;qconicalgradient&quot;&gt;QConicalGradient&lt;/a&gt; 클래스는 그라디언트의 시작 각도와 중심을 반환하는 &lt;a href=&quot;qconicalgradient#angle&quot;&gt;각도&lt;/a&gt; () 및 &lt;a href=&quot;qconicalgradient#center&quot;&gt;중심&lt;/a&gt; () 함수를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="877fb9f84fc362bbe3e371e803b3b05e197b5c8f" translate="yes" xml:space="preserve">
          <source>In addition to the functions inherited from &lt;a href=&quot;qgradient&quot;&gt;QGradient&lt;/a&gt;, the &lt;a href=&quot;qlineargradient&quot;&gt;QLinearGradient&lt;/a&gt; class provides the &lt;a href=&quot;qlineargradient#finalStop&quot;&gt;finalStop&lt;/a&gt;() function which returns the final stop point of the gradient, and the &lt;a href=&quot;qlineargradient#start&quot;&gt;start&lt;/a&gt;() function returning the start point of the gradient.</source>
          <target state="translated">&lt;a href=&quot;qgradient&quot;&gt;QGradient&lt;/a&gt; 에서 상속 된 함수 외에도 &lt;a href=&quot;qlineargradient&quot;&gt;QLinearGradient&lt;/a&gt; 클래스는 그라디언트의 최종 정지 점을 반환 하는 &lt;a href=&quot;qlineargradient#finalStop&quot;&gt;finalStop&lt;/a&gt; () 함수와 그라디언트의 &lt;a href=&quot;qlineargradient#start&quot;&gt;시작점을&lt;/a&gt; 반환하는 start () 함수를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="ac59c2d44b382d3ea1218ff478b5b46bdb551e68" translate="yes" xml:space="preserve">
          <source>In addition to the functions inherited from &lt;a href=&quot;qgradient&quot;&gt;QGradient&lt;/a&gt;, the &lt;a href=&quot;qradialgradient&quot;&gt;QRadialGradient&lt;/a&gt; class provides the &lt;a href=&quot;qradialgradient#center&quot;&gt;center&lt;/a&gt;(), &lt;a href=&quot;qradialgradient#focalPoint&quot;&gt;focalPoint&lt;/a&gt;() and &lt;a href=&quot;qradialgradient#radius&quot;&gt;radius&lt;/a&gt;() functions returning the gradient's center, focal point and radius respectively.</source>
          <target state="translated">로부터 계승하는 기능 이외에 &lt;a href=&quot;qgradient&quot;&gt;QGradient&lt;/a&gt; 상기 &lt;a href=&quot;qradialgradient&quot;&gt;QRadialGradient의&lt;/a&gt; 클래스가 제공 &lt;a href=&quot;qradialgradient#center&quot;&gt;센터&lt;/a&gt; () &lt;a href=&quot;qradialgradient#focalPoint&quot;&gt;focalPoint&lt;/a&gt; () 및 &lt;a href=&quot;qradialgradient#radius&quot;&gt;반경&lt;/a&gt; () 각각의 경사 중심 초점 반경 복귀 기능.</target>
        </trans-unit>
        <trans-unit id="a9e3f0e289ff08bc7c8585f151a1938dfa82edb9" translate="yes" xml:space="preserve">
          <source>In addition to the functions inherited from &lt;a href=&quot;qgradient&quot;&gt;QGradient&lt;/a&gt;, the QConicalGradient class provides the &lt;a href=&quot;qconicalgradient#angle&quot;&gt;angle&lt;/a&gt;() and &lt;a href=&quot;qconicalgradient#center&quot;&gt;center&lt;/a&gt;() functions returning the start angle and center of the gradient.</source>
          <target state="translated">&lt;a href=&quot;qgradient&quot;&gt;QGradient&lt;/a&gt; 에서 상속 된 함수 외에도 QConicalGradient 클래스는 그라디언트의 시작 각도와 중심을 반환하는 &lt;a href=&quot;qconicalgradient#angle&quot;&gt;angle&lt;/a&gt; () 및 &lt;a href=&quot;qconicalgradient#center&quot;&gt;center&lt;/a&gt; () 함수를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="3b46c23dc12791879a9c6b6742440cc7b8bbe144" translate="yes" xml:space="preserve">
          <source>In addition to the functions inherited from &lt;a href=&quot;qgradient&quot;&gt;QGradient&lt;/a&gt;, the QLinearGradient class provides the &lt;a href=&quot;qlineargradient#finalStop&quot;&gt;finalStop&lt;/a&gt;() function which returns the final stop point of the gradient, and the &lt;a href=&quot;qlineargradient#start&quot;&gt;start&lt;/a&gt;() function returning the start point of the gradient.</source>
          <target state="translated">로부터 계승하는 기능 이외에 &lt;a href=&quot;qgradient&quot;&gt;QGradient&lt;/a&gt; 상기 QLinearGradient 클래스가 제공 &lt;a href=&quot;qlineargradient#finalStop&quot;&gt;finalStop&lt;/a&gt; 그래디언트의 최종 정지 지점을 반환 () 함수, 및 &lt;a href=&quot;qlineargradient#start&quot;&gt;개시&lt;/a&gt; () 함수는 그라데이션의 시작점을 반환.</target>
        </trans-unit>
        <trans-unit id="e77a4943e03b7dc27a7bd182d58b845e6058d12e" translate="yes" xml:space="preserve">
          <source>In addition to the functions inherited from &lt;a href=&quot;qgradient&quot;&gt;QGradient&lt;/a&gt;, the QRadialGradient class provides the &lt;a href=&quot;qradialgradient#center&quot;&gt;center&lt;/a&gt;(), &lt;a href=&quot;qradialgradient#focalPoint&quot;&gt;focalPoint&lt;/a&gt;() and &lt;a href=&quot;qradialgradient#radius&quot;&gt;radius&lt;/a&gt;() functions returning the gradient's center, focal point and radius respectively.</source>
          <target state="translated">&lt;a href=&quot;qgradient&quot;&gt;QGradient&lt;/a&gt; 에서 상속 된 함수 외에도 QRadialGradient 클래스는 그라디언트의 중심, 초점 및 반경을 각각 반환하는 &lt;a href=&quot;qradialgradient#center&quot;&gt;center&lt;/a&gt; (), &lt;a href=&quot;qradialgradient#focalPoint&quot;&gt;focalPoint&lt;/a&gt; () 및 &lt;a href=&quot;qradialgradient#radius&quot;&gt;radius&lt;/a&gt; () 함수를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="1c821cc6fdd1abd00a61f5849aa01361ecb0459e" translate="yes" xml:space="preserve">
          <source>In addition to the functions provided by &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt;, QPolygon provides some point-specific functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="511d4be7f2f1914de36f69a74e5010125659e7b0" translate="yes" xml:space="preserve">
          <source>In addition to the functions provided by &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt;, QPolygonF provides the &lt;a href=&quot;qpolygonf#boundingRect&quot;&gt;boundingRect&lt;/a&gt;() and &lt;a href=&quot;qpolygonf#translate&quot;&gt;translate&lt;/a&gt;() functions for geometry operations. Use the &lt;a href=&quot;qtransform#map&quot;&gt;QTransform::map&lt;/a&gt;() function for more general transformations of QPolygonFs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90cb87a4726b92cf26795c1b0b605c676ee538e3" translate="yes" xml:space="preserve">
          <source>In addition to the functions provided by &lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt;, &lt;a href=&quot;qpolygon&quot;&gt;QPolygon&lt;/a&gt; provides some point-specific functions.</source>
          <target state="translated">&lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt; 에서 제공하는 기능 외에도 &lt;a href=&quot;qpolygon&quot;&gt;QPolygon&lt;/a&gt; 은 일부 점별 기능을 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="0af4b5582ced69e4efe9d71c097c3238d24bc513" translate="yes" xml:space="preserve">
          <source>In addition to the functions provided by &lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt;, &lt;a href=&quot;qpolygonf&quot;&gt;QPolygonF&lt;/a&gt; provides the &lt;a href=&quot;qpolygonf#boundingRect&quot;&gt;boundingRect&lt;/a&gt;() and &lt;a href=&quot;qpolygonf#translate&quot;&gt;translate&lt;/a&gt;() functions for geometry operations. Use the &lt;a href=&quot;qmatrix#map&quot;&gt;QMatrix::map&lt;/a&gt;() function for more general transformations of QPolygonFs.</source>
          <target state="translated">&lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt; 에서 제공하는 함수 외에도 &lt;a href=&quot;qpolygonf&quot;&gt;QPolygonF&lt;/a&gt; 는 지오메트리 작업에 대한 &lt;a href=&quot;qpolygonf#boundingRect&quot;&gt;boundingRect&lt;/a&gt; () 및 &lt;a href=&quot;qpolygonf#translate&quot;&gt;translate&lt;/a&gt; () 함수를 제공합니다. QPolygonF의보다 일반적인 변환 에는 &lt;a href=&quot;qmatrix#map&quot;&gt;QMatrix :: map&lt;/a&gt; () 함수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="b4d5db9f1e31428d2f2cb9ffecaf834a3e9aba83" translate="yes" xml:space="preserve">
          <source>In addition to the functions provided by &lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt;, QPolygon provides some point-specific functions.</source>
          <target state="translated">&lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt; 에서 제공하는 함수 외에도 QPolygon은 몇 가지 포인트 별 함수를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d5675d8d18582185f35a6dc1a0b286add20f7daa" translate="yes" xml:space="preserve">
          <source>In addition to the functions provided by &lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt;, QPolygonF provides the &lt;a href=&quot;qpolygonf#boundingRect&quot;&gt;boundingRect&lt;/a&gt;() and &lt;a href=&quot;qpolygonf#translate&quot;&gt;translate&lt;/a&gt;() functions for geometry operations. Use the &lt;a href=&quot;qtransform#map&quot;&gt;QTransform::map&lt;/a&gt;() function for more general transformations of QPolygonFs.</source>
          <target state="translated">&lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt; 에서 제공하는 함수 외에도 QPolygonF는 기하학 작업을위한 &lt;a href=&quot;qpolygonf#boundingRect&quot;&gt;boundingRect&lt;/a&gt; () 및 &lt;a href=&quot;qpolygonf#translate&quot;&gt;translate&lt;/a&gt; () 함수를 제공합니다. &lt;a href=&quot;qtransform#map&quot;&gt;QPolygonFs의&lt;/a&gt; 보다 일반적인 변환을 위해 QTransform :: map () 함수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="fe5baa5613db9a07f2d362e38916ab845c4f0edf" translate="yes" xml:space="preserve">
          <source>In addition to the locale and collation strategy, several optional flags can be set that influence the result of the collation.</source>
          <target state="translated">로캘 및 데이터 정렬 전략 외에도 데이터 정렬 결과에 영향을주는 몇 가지 선택적 플래그를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8f3f432050e4b246a5ff857a8616045f7e2d660" translate="yes" xml:space="preserve">
          <source>In addition to the more traditional &lt;a href=&quot;qml-qtquick-grid&quot;&gt;Grid&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-row&quot;&gt;Row&lt;/a&gt;, and &lt;a href=&quot;qml-qtquick-column&quot;&gt;Column&lt;/a&gt;, Qt Quick also provides a way to layout items using the concept of</source>
          <target state="translated">Qt Quick은 기존의 &lt;a href=&quot;qml-qtquick-grid&quot;&gt;Grid&lt;/a&gt; , &lt;a href=&quot;qml-qtquick-row&quot;&gt;Row&lt;/a&gt; 및 &lt;a href=&quot;qml-qtquick-column&quot;&gt;Column&lt;/a&gt; 외에도 다음 과 같은 개념을 사용하여 항목을 레이아웃하는 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="bd1769bbaee36477bcc222f28d1b3f1dc4fdbb46" translate="yes" xml:space="preserve">
          <source>In addition to the normal &lt;a href=&quot;qml-qtquick-text&quot;&gt;Text&lt;/a&gt; type, Label follows the font and color scheme of the system. Use the &lt;code&gt;text&lt;/code&gt; property to assign a text to the label. For other properties check &lt;a href=&quot;qml-qtquick-text&quot;&gt;Text&lt;/a&gt;.</source>
          <target state="translated">일반적인 &lt;a href=&quot;qml-qtquick-text&quot;&gt;텍스트&lt;/a&gt; 유형 외에도 Label은 시스템의 글꼴 및 색 구성표를 따릅니다. &lt;code&gt;text&lt;/code&gt; 속성을 사용하여 레이블에 텍스트를 할당하십시오. 다른 속성에 대해서는 &lt;a href=&quot;qml-qtquick-text&quot;&gt;Text를&lt;/a&gt; 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="3241102cc7dd4992b6edb728cbe2a9f013091640" translate="yes" xml:space="preserve">
          <source>In addition to the normal key event data, also contains</source>
          <target state="translated">일반 키 이벤트 데이터 외에도</target>
        </trans-unit>
        <trans-unit id="c5488ff097ad45e29b3b27b5e777318782f47ccb" translate="yes" xml:space="preserve">
          <source>In addition to the original behaviour of &lt;a href=&quot;qsslsocket#connectToHostEncrypted&quot;&gt;connectToHostEncrypted&lt;/a&gt;, this overloaded method enables the usage of a different hostname (</source>
          <target state="translated">&lt;a href=&quot;qsslsocket#connectToHostEncrypted&quot;&gt;connectToHostEncrypted&lt;/a&gt; 의 원래 동작 외에도이 오버로드 된 메소드는 다른 호스트 이름 (</target>
        </trans-unit>
        <trans-unit id="36f5ccbfefe91daac258836641044049f0c56457" translate="yes" xml:space="preserve">
          <source>In addition to the original behaviour of connectToHostEncrypted, this overloaded method enables the usage of a different hostname (</source>
          <target state="translated">connectToHostEncrypted의 원래 동작 외에도이 오버로드 된 메서드를 사용하면 다른 호스트 이름 (</target>
        </trans-unit>
        <trans-unit id="21fb91fa11606656b3adc5dc6835305200665c5d" translate="yes" xml:space="preserve">
          <source>In addition to the overloaded stream operators documented here, any Qt classes that you might want to serialize to a &lt;a href=&quot;qdatastream&quot;&gt;QDataStream&lt;/a&gt; will have appropriate stream operators declared as non-member of the class:</source>
          <target state="translated">여기에 문서화 된 오버로드 된 스트림 연산자 외에도 &lt;a href=&quot;qdatastream&quot;&gt;QDataStream&lt;/a&gt; 으로 직렬화하려는 Qt 클래스 에는 클래스의 비 멤버로 선언 된 적절한 스트림 연산자가 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc01324075577dbbd63ee06845f075d618cb50eb" translate="yes" xml:space="preserve">
          <source>In addition to the overloaded stream operators documented here, any Qt classes that you might want to serialize to a QDataStream will have appropriate stream operators declared as non-member of the class:</source>
          <target state="translated">여기에 설명 된 오버로드 된 스트림 연산자 외에도 QDataStream으로 직렬화하려는 모든 Qt 클래스에는 클래스의 비 구성원으로 선언 된 적절한 스트림 연산자가 있습니다.</target>
        </trans-unit>
        <trans-unit id="82e5ba02ce74bd7c5fa0fb2e1d15e44165d43fb9" translate="yes" xml:space="preserve">
          <source>In addition to the public API, the scene graph has an adaptation layer which opens up the implementation to do hardware specific adaptations. This is an undocumented, internal and private plugin API, which lets hardware adaptation teams make the most of their hardware. It includes:</source>
          <target state="translated">공개 API 외에도 장면 그래프에는 하드웨어 별 적응을 수행하기위한 구현을 여는 적응 레이어가 있습니다. 이것은 문서화되지 않은 내부 및 개인 플러그인 API이며, 하드웨어 적응 팀이 하드웨어를 최대한 활용할 수 있습니다. 다음을 포함합니다 :</target>
        </trans-unit>
        <trans-unit id="6a6c3ce6d985ea5289aaa8da876be075c128e730" translate="yes" xml:space="preserve">
          <source>In addition to the signals and slots shown above, &lt;code&gt;moc&lt;/code&gt; also implements object properties as in the next example. The &lt;a href=&quot;qobject#Q_PROPERTY&quot;&gt;Q_PROPERTY&lt;/a&gt;() macro declares an object property, while &lt;a href=&quot;qobject#Q_ENUM&quot;&gt;Q_ENUM&lt;/a&gt;() declares a list of enumeration types within the class to be usable inside the &lt;a href=&quot;properties&quot;&gt;property system&lt;/a&gt;.</source>
          <target state="translated">위에 표시된 신호 및 슬롯 외에도 &lt;code&gt;moc&lt;/code&gt; 는 다음 예와 같이 객체 속성을 구현합니다. &lt;a href=&quot;qobject#Q_PROPERTY&quot;&gt;Q_PROPERTY&lt;/a&gt; 동안 () 매크로 객체 속성을 선언 &lt;a href=&quot;qobject#Q_ENUM&quot;&gt;Q_ENUM는&lt;/a&gt; () 내에 사용될 수 클래스 내에 열거 된 종류의리스트를 선언 &lt;a href=&quot;properties&quot;&gt;특성 시스템&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0dc3ccf2ba055573f41ffab03bf5059e4c36e6fe" translate="yes" xml:space="preserve">
          <source>In addition to the standard CMYK model, Qt provides an alpha-channel to feature &lt;a href=&quot;qcolor#alpha-blended-drawing&quot;&gt;alpha-blended drawing&lt;/a&gt;.</source>
          <target state="translated">Qt는 표준 CMYK 모델 외에도 &lt;a href=&quot;qcolor#alpha-blended-drawing&quot;&gt;알파 블렌드 드로잉&lt;/a&gt; 기능을 갖춘 알파 채널을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="0be17f054f12e2fb38a6a1f485ac2bf01fa897ed" translate="yes" xml:space="preserve">
          <source>In addition to the standard HSV model, Qt provides an alpha-channel to feature &lt;a href=&quot;qcolor#alpha-blended-drawing&quot;&gt;alpha-blended drawing&lt;/a&gt;.</source>
          <target state="translated">Qt는 표준 HSV 모델 외에도 &lt;a href=&quot;qcolor#alpha-blended-drawing&quot;&gt;알파 블렌드 드로잉&lt;/a&gt; 기능을 갖춘 알파 채널을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="f9c4e1ecc5601fcf9e9447bb69488d9d57d4ef15" translate="yes" xml:space="preserve">
          <source>In addition to the standard toolbar and context menu entries, there is also a set of keyboard shortcuts to apply layouts on widgets.</source>
          <target state="translated">표준 도구 모음 및 상황에 맞는 메뉴 항목 외에도 위젯에 레이아웃을 적용 할 수있는 단축키가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b09afcccf5027fee867e941626ff3448febeaf82" translate="yes" xml:space="preserve">
          <source>In addition to the standard widget styles for each platform, widgets can also be styled according to rules specified in a &lt;a href=&quot;stylesheet&quot;&gt;style sheet&lt;/a&gt;. This feature enables you to customize the appearance of specific widgets to provide visual cues to users about their purpose. For example, a button could be styled in a particular way to indicate that it performs a destructive action.</source>
          <target state="translated">각 플랫폼의 표준 위젯 스타일 외에도 &lt;a href=&quot;stylesheet&quot;&gt;스타일 시트에&lt;/a&gt; 지정된 규칙에 따라 위젯의 스타일을 지정할 수 있습니다 . 이 기능을 사용하면 특정 위젯의 모양을 사용자 지정하여 사용자에게 목적에 대한 시각적 신호를 제공 할 수 있습니다. 예를 들어 버튼은 파괴적인 작업을 수행함을 나타 내기 위해 특정 방식으로 스타일을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6dcbc9ef9242a5ec4e23f73cbc3b577f639b3b87" translate="yes" xml:space="preserve">
          <source>In addition to the standard widget styles for each platform, widgets can also be styled according to rules specified in a &lt;a href=&quot;stylesheet#&quot;&gt;style sheet&lt;/a&gt;. This feature enables you to customize the appearance of specific widgets to provide visual cues to users about their purpose. For example, a button could be styled in a particular way to indicate that it performs a destructive action.</source>
          <target state="translated">각 플랫폼의 표준 위젯 스타일 외에도 &lt;a href=&quot;stylesheet#&quot;&gt;스타일 시트에&lt;/a&gt; 지정된 규칙에 따라 위젯의 스타일을 지정할 수 있습니다 . 이 기능을 사용하면 특정 위젯의 모양을 사용자 정의하여 목적에 대한 시각적 힌트를 사용자에게 제공 할 수 있습니다. 예를 들어, 버튼은 특정 방식으로 스타일을 지정하여 파괴적인 작업을 수행함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9bae76ffe4383123793f13b43b96fced6eb87f9b" translate="yes" xml:space="preserve">
          <source>In addition to the supported extensions above, many other common extensions will be returned in a reasonably structured way. Extensions that the SSL backend has no support for at all will be returned as a &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt;.</source>
          <target state="translated">위의 지원되는 확장 외에도 많은 다른 일반 확장이 합리적으로 구조화 된 방식으로 반환됩니다. SSL 백엔드가 전혀 지원하지 않는 확장은 &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; 로 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="045bbb78e1954a03a7a0c662484fd4300d5c27fc" translate="yes" xml:space="preserve">
          <source>In addition to the username and password required for authentication, a &lt;a href=&quot;qauthenticator&quot;&gt;QAuthenticator&lt;/a&gt; object can also contain additional options. The &lt;a href=&quot;qauthenticator#options&quot;&gt;options&lt;/a&gt;() function can be used to query incoming options sent by the server; the &lt;a href=&quot;qauthenticator#setOption&quot;&gt;setOption&lt;/a&gt;() function can be used to set outgoing options, to be processed by the authenticator calculation. The options accepted and provided depend on the authentication type (see method()).</source>
          <target state="translated">인증에 필요한 사용자 이름 및 비밀번호 외에도 &lt;a href=&quot;qauthenticator&quot;&gt;QAuthenticator&lt;/a&gt; 객체에는 추가 옵션이 포함될 수 있습니다. &lt;a href=&quot;qauthenticator#options&quot;&gt;옵션&lt;/a&gt; () 함수는 서버에 의해 전송 된 질의받는 옵션을 사용할 수있다; &lt;a href=&quot;qauthenticator#setOption&quot;&gt;setOption&lt;/a&gt; () 함수 는 발신자 옵션을 설정하여 인증 자 계산에 의해 처리 될 수 있습니다. 승인 및 제공되는 옵션은 인증 유형에 따라 다릅니다 (method () 참조).</target>
        </trans-unit>
        <trans-unit id="a2b6063dc6e8ba50cdc3adbfbf879598fd578538" translate="yes" xml:space="preserve">
          <source>In addition to the username and password required for authentication, a QAuthenticator object can also contain additional options. The &lt;a href=&quot;qauthenticator#options&quot;&gt;options&lt;/a&gt;() function can be used to query incoming options sent by the server; the &lt;a href=&quot;qauthenticator#setOption&quot;&gt;setOption&lt;/a&gt;() function can be used to set outgoing options, to be processed by the authenticator calculation. The options accepted and provided depend on the authentication type (see method()).</source>
          <target state="translated">인증에 필요한 사용자 이름 및 암호 외에도 QAuthenticator 개체에는 추가 옵션이 포함될 수 있습니다. &lt;a href=&quot;qauthenticator#options&quot;&gt;옵션&lt;/a&gt; () 함수는 서버에 의해 전송 된 질의받는 옵션을 사용할 수있다; &lt;a href=&quot;qauthenticator#setOption&quot;&gt;에서 SetOption&lt;/a&gt; () 함수는 인증 연산에 의해 처리 될 보내는 옵션을 설정하는 데 사용될 수있다. 허용되고 제공되는 옵션은 인증 유형에 따라 다릅니다 (method () 참조).</target>
        </trans-unit>
        <trans-unit id="dae48ceb544b86a9722e1bf250b1c20f5f9e3d04" translate="yes" xml:space="preserve">
          <source>In addition to the usual checked and unchecked states, &lt;a href=&quot;qcheckbox&quot;&gt;QCheckBox&lt;/a&gt; optionally provides a third state to indicate &quot;no change&quot;. This is useful whenever you need to give the user the option of neither checking nor unchecking a checkbox. If you need this third state, enable it with &lt;a href=&quot;qcheckbox#tristate-prop&quot;&gt;setTristate&lt;/a&gt;(), and use &lt;a href=&quot;qcheckbox#checkState&quot;&gt;checkState&lt;/a&gt;() to query the current toggle state.</source>
          <target state="translated">일반적인 확인 및 확인되지 않은 상태 &lt;a href=&quot;qcheckbox&quot;&gt;외에도 QCheckBox는&lt;/a&gt; 선택적으로 &quot;변경 없음&quot;을 나타내는 세 번째 상태를 제공합니다. 이는 사용자에게 확인란을 선택하거나 선택 취소하지 않는 옵션을 제공해야 할 때마다 유용합니다. 이 세 번째 상태가 필요한 경우 &lt;a href=&quot;qcheckbox#tristate-prop&quot;&gt;setTristate&lt;/a&gt; ()로 활성화하고 &lt;a href=&quot;qcheckbox#checkState&quot;&gt;checkState&lt;/a&gt; ()를 사용하여 현재 토글 상태를 쿼리하십시오.</target>
        </trans-unit>
        <trans-unit id="4482092064f941cb7bf1f4780f1f4f1c7aa06a10" translate="yes" xml:space="preserve">
          <source>In addition to the usual checked and unchecked states, QCheckBox optionally provides a third state to indicate &quot;no change&quot;. This is useful whenever you need to give the user the option of neither checking nor unchecking a checkbox. If you need this third state, enable it with &lt;a href=&quot;qcheckbox#tristate-prop&quot;&gt;setTristate&lt;/a&gt;(), and use &lt;a href=&quot;qcheckbox#checkState&quot;&gt;checkState&lt;/a&gt;() to query the current toggle state.</source>
          <target state="translated">일반적인 확인 및 확인되지 않은 상태 외에도 QCheckBox는 &quot;변경 없음&quot;을 나타내는 세 번째 상태를 선택적으로 제공합니다. 이것은 사용자에게 확인란을 선택하거나 선택 취소하지 않는 옵션을 제공해야 할 때 유용합니다. 이 세 번째 상태가 필요한 경우 &lt;a href=&quot;qcheckbox#tristate-prop&quot;&gt;setTristate&lt;/a&gt; ()로 활성화하고 &lt;a href=&quot;qcheckbox#checkState&quot;&gt;checkState&lt;/a&gt; ()를 사용하여 현재 토글 상태를 쿼리합니다.</target>
        </trans-unit>
        <trans-unit id="43521fb550ae8e7c824622aefa4d418ea35da248" translate="yes" xml:space="preserve">
          <source>In addition to the wizard style, there are several options that control the look and feel of the wizard. These can be set using &lt;a href=&quot;qwizard#setOption&quot;&gt;setOption&lt;/a&gt;() or &lt;a href=&quot;qwizard#options-prop&quot;&gt;setOptions&lt;/a&gt;(). For example, &lt;a href=&quot;qwizard#WizardOption-enum&quot;&gt;HaveHelpButton&lt;/a&gt; makes &lt;a href=&quot;qwizard&quot;&gt;QWizard&lt;/a&gt; show a &lt;b&gt;Help&lt;/b&gt; button along with the other wizard buttons.</source>
          <target state="translated">마법사 스타일 외에도 마법사의 모양과 느낌을 제어하는 ​​몇 가지 옵션이 있습니다. 이들은 &lt;a href=&quot;qwizard#setOption&quot;&gt;setOption&lt;/a&gt; () 또는 &lt;a href=&quot;qwizard#options-prop&quot;&gt;setOptions&lt;/a&gt; ()를 사용하여 설정할 수 있습니다 . 예를 들어 &lt;a href=&quot;qwizard#WizardOption-enum&quot;&gt;HaveHelpButton&lt;/a&gt; 은 &lt;a href=&quot;qwizard&quot;&gt;QWizard&lt;/a&gt; 가 다른 마법사 버튼과 함께 &lt;b&gt;도움말&lt;/b&gt; 버튼을 표시하도록 합니다.</target>
        </trans-unit>
        <trans-unit id="23f86e084dc4b0f965e695b5d8e8e250be404e69" translate="yes" xml:space="preserve">
          <source>In addition to the wizard style, there are several options that control the look and feel of the wizard. These can be set using &lt;a href=&quot;qwizard#setOption&quot;&gt;setOption&lt;/a&gt;() or &lt;a href=&quot;qwizard#options-prop&quot;&gt;setOptions&lt;/a&gt;(). For example, &lt;a href=&quot;qwizard#WizardOption-enum&quot;&gt;HaveHelpButton&lt;/a&gt; makes QWizard show a &lt;b&gt;Help&lt;/b&gt; button along with the other wizard buttons.</source>
          <target state="translated">마법사 스타일 외에도 마법사의 모양과 느낌을 제어하는 ​​몇 가지 옵션이 있습니다. &lt;a href=&quot;qwizard#setOption&quot;&gt;setOption&lt;/a&gt; () 또는 &lt;a href=&quot;qwizard#options-prop&quot;&gt;setOptions&lt;/a&gt; ()를 사용하여 설정할 수 있습니다 . 예를 들어, &lt;a href=&quot;qwizard#WizardOption-enum&quot;&gt;HaveHelpButton&lt;/a&gt; 은 QWizard 가 다른 마법사 버튼과 함께 &lt;b&gt;도움말&lt;/b&gt; 버튼을 표시하도록 합니다.</target>
        </trans-unit>
        <trans-unit id="3d9f4713c3814a84441ed7cc08ac012384c4c7c1" translate="yes" xml:space="preserve">
          <source>In addition to types deriving from Node, it is also possible to parent other types to a Node. This includes &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; instances, where the Node merely serves as the &lt;a href=&quot;qobject#parent&quot;&gt;QObject parent&lt;/a&gt;, and &lt;a href=&quot;qtquick3d-2d&quot;&gt;Qt Quick items&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e17331832d0fac1a23987c46547dc1e75ff48651" translate="yes" xml:space="preserve">
          <source>In addition to using static meshes, it is possible to implement a &lt;a href=&quot;qquick3dgeometry&quot;&gt;custom geometry&lt;/a&gt; provider that provides the model with custom vertex data at run-time. See the &lt;a href=&quot;https://doc.qt.io/qt-6.0/qtquick3d-customgeometry-example.html&quot;&gt;Custom Geometry Example&lt;/a&gt; for an example on how to create and use a custom material with your model.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdd18e5b71e6b68fe8f805a94a5e93bdd8b32775" translate="yes" xml:space="preserve">
          <source>In addition you can query the current formatting and user data using the &lt;a href=&quot;qsyntaxhighlighter#format&quot;&gt;format&lt;/a&gt;() and &lt;a href=&quot;qsyntaxhighlighter#currentBlockUserData&quot;&gt;currentBlockUserData&lt;/a&gt;() functions respectively. You can also attach user data to the current text block using the &lt;a href=&quot;qsyntaxhighlighter#setCurrentBlockUserData&quot;&gt;setCurrentBlockUserData&lt;/a&gt;() function. &lt;a href=&quot;qtextblockuserdata&quot;&gt;QTextBlockUserData&lt;/a&gt; can be used to store custom settings. In the case of syntax highlighting, it is in particular interesting as cache storage for information that you may figure out while parsing the paragraph's text. For an example, see the &lt;a href=&quot;qsyntaxhighlighter#setCurrentBlockUserData&quot;&gt;setCurrentBlockUserData&lt;/a&gt;() documentation.</source>
          <target state="translated">또한 &lt;a href=&quot;qsyntaxhighlighter#format&quot;&gt;format&lt;/a&gt; () 및 &lt;a href=&quot;qsyntaxhighlighter#currentBlockUserData&quot;&gt;currentBlockUserData&lt;/a&gt; () 함수를 각각 사용하여 현재 형식 및 사용자 데이터를 쿼리 할 수 ​​있습니다 . &lt;a href=&quot;qsyntaxhighlighter#setCurrentBlockUserData&quot;&gt;setCurrentBlockUserData&lt;/a&gt; () 함수를 사용하여 사용자 데이터를 현재 텍스트 블록에 첨부 할 수도 있습니다 . &lt;a href=&quot;qtextblockuserdata&quot;&gt;QTextBlockUserData&lt;/a&gt; 를 사용하여 사용자 정의 설정을 저장할 수 있습니다. 구문 강조의 경우, 단락 텍스트를 구문 분석하는 동안 알아낼 수있는 정보를위한 캐시 스토리지로 특히 흥미 롭습니다. 예를 보려면 &lt;a href=&quot;qsyntaxhighlighter#setCurrentBlockUserData&quot;&gt;setCurrentBlockUserData&lt;/a&gt; () 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a09089230bafdc9eed0b4278c8a9e46cfe92e906" translate="yes" xml:space="preserve">
          <source>In addition you can specify a curve's threshold, controlling the granularity with which a curve is drawn, using the &lt;a href=&quot;qpainterpathstroker#setCurveThreshold&quot;&gt;setCurveThreshold&lt;/a&gt;() function. The default threshold is a well adjusted value (0.25), and normally you should not need to modify it. However, you can make the curve's appearance smoother by decreasing its value.</source>
          <target state="translated">또한 &lt;a href=&quot;qpainterpathstroker#setCurveThreshold&quot;&gt;setCurveThreshold&lt;/a&gt; () 함수를 사용하여 곡선의 임계 값을 제어하여 곡선의 임계 값을 지정할 수 있습니다 . 기본 임계 값은 잘 조정 된 값 (0.25)이며 일반적으로 수정할 필요가 없습니다. 그러나 값을 줄이면 곡선의 모양이 더 매끄러 워질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="af9d69a85de071c5503c968b6878570e7a051f81" translate="yes" xml:space="preserve">
          <source>In addition,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4babc89dd6c166e0c65f2079d856d20f7a427c69" translate="yes" xml:space="preserve">
          <source>In addition, &lt;a href=&quot;qbuttongroup&quot;&gt;QButtonGroup&lt;/a&gt; can map between integers and buttons. You can assign an integer id to a button with &lt;a href=&quot;qbuttongroup#setId&quot;&gt;setId&lt;/a&gt;(), and retrieve it with &lt;a href=&quot;qbuttongroup#id&quot;&gt;id&lt;/a&gt;(). The id of the currently checked button is available with &lt;a href=&quot;qbuttongroup#checkedId&quot;&gt;checkedId&lt;/a&gt;(), and there is an overloaded signal &lt;a href=&quot;qbuttongroup#buttonClicked&quot;&gt;buttonClicked&lt;/a&gt;() which emits the id of the button. The id &lt;code&gt;-1&lt;/code&gt; is reserved by &lt;a href=&quot;qbuttongroup&quot;&gt;QButtonGroup&lt;/a&gt; to mean &quot;no such button&quot;. The purpose of the mapping mechanism is to simplify the representation of enum values in a user interface.</source>
          <target state="translated">또한 &lt;a href=&quot;qbuttongroup&quot;&gt;QButtonGroup&lt;/a&gt; 은 정수와 버튼을 매핑 할 수 있습니다. 당신이 버튼에 정수 ID를 할당 할 수 &lt;a href=&quot;qbuttongroup#setId&quot;&gt;setId&lt;/a&gt; ()와 함께 검색 &lt;a href=&quot;qbuttongroup#id&quot;&gt;아이디&lt;/a&gt; (). 현재 확인 된 버튼의 id는 &lt;a href=&quot;qbuttongroup#checkedId&quot;&gt;checkedId&lt;/a&gt; () 와 함께 사용할 수 있으며 버튼 의 id를 방출 하는 오버로드 된 신호 &lt;a href=&quot;qbuttongroup#buttonClicked&quot;&gt;buttonClicked&lt;/a&gt; ()가 있습니다. id &lt;code&gt;-1&lt;/code&gt; 은 &lt;a href=&quot;qbuttongroup&quot;&gt;QButtonGroup&lt;/a&gt; 에 의해 예약되어 &quot;이러한 버튼 없음&quot;을 의미합니다. 매핑 메커니즘의 목적은 사용자 인터페이스에서 열거 형 값의 표현을 단순화하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e9800f88f80534b79f93e4fbc116787e4a0a4bc9" translate="yes" xml:space="preserve">
          <source>In addition, &lt;a href=&quot;qdesignerformwindowmanagerinterface&quot;&gt;QDesignerFormWindowManagerInterface&lt;/a&gt; contains a collection of functions that enables you to intervene and control</source>
          <target state="translated">또한 &lt;a href=&quot;qdesignerformwindowmanagerinterface&quot;&gt;QDesignerFormWindowManagerInterface&lt;/a&gt; 에는 사용자가 개입하고 제어 할 수있는 기능 모음이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="7101167786b4f33575c031b3f25584c8316f3307" translate="yes" xml:space="preserve">
          <source>In addition, &lt;a href=&quot;qgraphicsitemgroup&quot;&gt;QGraphicsItemGroup&lt;/a&gt; is a special item that combines child event handling with a useful interface for adding and removing items to and from a group. Adding an item to a &lt;a href=&quot;qgraphicsitemgroup&quot;&gt;QGraphicsItemGroup&lt;/a&gt; will keep the item's original position and transformation, whereas reparenting items in general will cause the child to reposition itself relative to its new parent. For convenience, you can create &lt;a href=&quot;qgraphicsitemgroup&quot;&gt;QGraphicsItemGroup&lt;/a&gt;s through the scene by calling &lt;a href=&quot;qgraphicsscene#createItemGroup&quot;&gt;QGraphicsScene::createItemGroup&lt;/a&gt;().</source>
          <target state="translated">또한 &lt;a href=&quot;qgraphicsitemgroup&quot;&gt;QGraphicsItemGroup&lt;/a&gt; 은 하위 이벤트 처리와 그룹에 항목을 추가 및 제거하기위한 유용한 인터페이스를 결합한 특수 항목입니다. &lt;a href=&quot;qgraphicsitemgroup&quot;&gt;QGraphicsItemGroup에&lt;/a&gt; 항목을 추가하면 항목 의 원래 위치와 변환이 유지되는 반면 일반적으로 항목을 변경하면 자식이 새 부모를 기준으로 자체 위치를 변경하게됩니다. 편의상 &lt;a href=&quot;qgraphicsscene#createItemGroup&quot;&gt;QGraphicsScene :: createItemGroup&lt;/a&gt; () 을 호출하여 장면을 통해 &lt;a href=&quot;qgraphicsitemgroup&quot;&gt;QGraphicsItemGroup&lt;/a&gt; 을 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9932170715abe979bd672a850450f1e95e87f370" translate="yes" xml:space="preserve">
          <source>In addition, &lt;a href=&quot;qml-qtquick-viewtransition&quot;&gt;ViewTransition&lt;/a&gt; provides properties specific to the items which are the target of the operation that triggered the transition:</source>
          <target state="translated">또한 &lt;a href=&quot;qml-qtquick-viewtransition&quot;&gt;ViewTransition&lt;/a&gt; 은 전환을 트리거 한 작업의 대상인 항목과 관련된 속성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f47e93a20e07e14b05f17c112a8284c932cb10fd" translate="yes" xml:space="preserve">
          <source>In addition, &lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt; provides the &lt;a href=&quot;qrect#getCoords&quot;&gt;getCoords&lt;/a&gt;() function which extracts the position of the rectangle's top-left and bottom-right corner, and the &lt;a href=&quot;qrect#getRect&quot;&gt;getRect&lt;/a&gt;() function which extracts the rectangle's top-left corner, width and height. Use the &lt;a href=&quot;qrect#setCoords&quot;&gt;setCoords&lt;/a&gt;() and &lt;a href=&quot;qrect#setRect&quot;&gt;setRect&lt;/a&gt;() function to manipulate the rectangle's coordinates and dimensions in one go.</source>
          <target state="translated">또한 &lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt; 는 사각형의 왼쪽 상단 및 오른쪽 아래 모서리의 위치를 ​​추출 하는 &lt;a href=&quot;qrect#getCoords&quot;&gt;getCoords&lt;/a&gt; () 함수와 사각형의 왼쪽 상단 모서리, 너비 및 높이를 추출하는 &lt;a href=&quot;qrect#getRect&quot;&gt;getRect&lt;/a&gt; () 함수를 제공합니다. 사용 &lt;a href=&quot;qrect#setCoords&quot;&gt;setCoords&lt;/a&gt; ()와 &lt;a href=&quot;qrect#setRect&quot;&gt;setRect&lt;/a&gt; 한 번에 사각형의 좌표와 크기를 조작하는 () 함수를.</target>
        </trans-unit>
        <trans-unit id="28c715c4d611d2eace18dfa7ba865f61b93cdbfb" translate="yes" xml:space="preserve">
          <source>In addition, &lt;a href=&quot;qrectf&quot;&gt;QRectF&lt;/a&gt; provides the &lt;a href=&quot;qrectf#getCoords&quot;&gt;getCoords&lt;/a&gt;() function which extracts the position of the rectangle's top-left and bottom-right corner, and the &lt;a href=&quot;qrectf#getRect&quot;&gt;getRect&lt;/a&gt;() function which extracts the rectangle's top-left corner, width and height. Use the &lt;a href=&quot;qrectf#setCoords&quot;&gt;setCoords&lt;/a&gt;() and &lt;a href=&quot;qrectf#setRect&quot;&gt;setRect&lt;/a&gt;() function to manipulate the rectangle's coordinates and dimensions in one go.</source>
          <target state="translated">또한 &lt;a href=&quot;qrectf&quot;&gt;QRectF&lt;/a&gt; 는 사각형의 왼쪽 상단 및 오른쪽 아래 모서리의 위치를 ​​추출 하는 &lt;a href=&quot;qrectf#getCoords&quot;&gt;getCoords&lt;/a&gt; () 함수와 사각형의 왼쪽 상단 모서리, 너비 및 높이를 추출하는 &lt;a href=&quot;qrectf#getRect&quot;&gt;getRect&lt;/a&gt; () 함수를 제공합니다. 사용 &lt;a href=&quot;qrectf#setCoords&quot;&gt;setCoords&lt;/a&gt; ()와 &lt;a href=&quot;qrectf#setRect&quot;&gt;setRect&lt;/a&gt; 한 번에 사각형의 좌표와 크기를 조작하는 () 함수를.</target>
        </trans-unit>
        <trans-unit id="909743cdef726cab568394ea75f444bd548316d7" translate="yes" xml:space="preserve">
          <source>In addition, &lt;a href=&quot;qregularexpressionmatch&quot;&gt;QRegularExpressionMatch&lt;/a&gt; returns the substrings captured by the capturing groups in the pattern string. The implicit capturing group with index 0 captures the result of the whole match. The &lt;a href=&quot;qregularexpressionmatch#captured&quot;&gt;captured&lt;/a&gt;() function returns each substring captured, either by the capturing group's index or by its name:</source>
          <target state="translated">또한 &lt;a href=&quot;qregularexpressionmatch&quot;&gt;QRegularExpressionMatch&lt;/a&gt; 는 캡처 문자열에 의해 캡처 된 서브 스트링을 패턴 문자열로 리턴합니다. 인덱스가 0 인 암시 적 캡처 그룹은 전체 일치 결과를 캡처합니다. &lt;a href=&quot;qregularexpressionmatch#captured&quot;&gt;캡처&lt;/a&gt; 캡처 그룹의 인덱스 또는 이름 중 하나를 각각의 문자열 캡처 () 함수가 반환 :</target>
        </trans-unit>
        <trans-unit id="dee0d9a370aaadea9a4d185748317b1c06665f7b" translate="yes" xml:space="preserve">
          <source>In addition, BeginNativeGesture and EndNativeGesture are sent before and after gesture event streams:</source>
          <target state="translated">또한 BeginNativeGesture 및 EndNativeGesture는 제스처 이벤트 스트림 전후에 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="ef758b3f8333e9857e8cbd013860ab9e6d7dcdcb" translate="yes" xml:space="preserve">
          <source>In addition, D-Bus defines two well-known buses, called the system bus and the session bus. These buses are special in the sense that they have well-defined semantics: some services are defined to be found in one or both of these buses.</source>
          <target state="translated">또한 D-Bus는 시스템 버스와 세션 버스라는 잘 알려진 두 개의 버스를 정의합니다. 이러한 버스는 의미가 잘 정의되어 있다는 점에서 특별합니다. 일부 서비스는 이러한 버스 중 하나 또는 둘 다에서 발견되도록 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="d56d60278f8be76536f6341fadefef1c9f1e809d" translate="yes" xml:space="preserve">
          <source>In addition, QButtonGroup can map between integers and buttons. You can assign an integer id to a button with &lt;a href=&quot;qbuttongroup#setId&quot;&gt;setId&lt;/a&gt;(), and retrieve it with &lt;a href=&quot;qbuttongroup#id&quot;&gt;id&lt;/a&gt;(). The id of the currently checked button is available with &lt;a href=&quot;qbuttongroup#checkedId&quot;&gt;checkedId&lt;/a&gt;(), and there is an overloaded signal &lt;a href=&quot;qbuttongroup#buttonClicked&quot;&gt;buttonClicked&lt;/a&gt;() which emits the id of the button. The id &lt;code&gt;-1&lt;/code&gt; is reserved by QButtonGroup to mean &quot;no such button&quot;. The purpose of the mapping mechanism is to simplify the representation of enum values in a user interface.</source>
          <target state="translated">또한 QButtonGroup은 정수와 버튼간에 매핑 할 수 있습니다. 당신이 버튼에 정수 ID를 할당 할 수 &lt;a href=&quot;qbuttongroup#setId&quot;&gt;setId&lt;/a&gt; ()와 함께 검색 &lt;a href=&quot;qbuttongroup#id&quot;&gt;아이디&lt;/a&gt; (). 현재 체크 된 버튼의 id는 &lt;a href=&quot;qbuttongroup#checkedId&quot;&gt;checkedId&lt;/a&gt; () 와 함께 사용할 수 있으며 , 버튼의 id를 방출 하는 과부하 신호 &lt;a href=&quot;qbuttongroup#buttonClicked&quot;&gt;buttonClicked&lt;/a&gt; ()가 있습니다. id &lt;code&gt;-1&lt;/code&gt; 은 QButtonGroup에 의해 예약되어 &quot;해당 버튼 없음&quot;을 의미합니다. 매핑 메커니즘의 목적은 사용자 인터페이스에서 열거 형 값의 표현을 단순화하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="b272ac8c70fa82b3823671e5cb7a241a63ebee31" translate="yes" xml:space="preserve">
          <source>In addition, QDesignerFormWindowManagerInterface contains a collection of functions that enables you to intervene and control</source>
          <target state="translated">또한 QDesignerFormWindowManagerInterface에는 개입하고 제어 할 수있는 함수 모음이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="58ee892583deb6d4d41b8c8b843c3b60ef4c1329" translate="yes" xml:space="preserve">
          <source>In addition, QML also extends the behavior of the instanceof function to allow for type checking against QML types. This means that you may use it to verify that a variable is indeed the type you expect, for example:</source>
          <target state="translated">또한 QML은 QML 유형에 대한 유형 검사를 허용하기 위해 instanceof 함수의 동작을 확장합니다. 즉, 변수가 실제로 예상되는 유형인지 확인하는 데 사용할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="77026bc774f019d465cb985bb88e2ef3536b43fb" translate="yes" xml:space="preserve">
          <source>In addition, QML provides several other types useful for animation:</source>
          <target state="translated">또한 QML은 애니메이션에 유용한 몇 가지 다른 유형을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="78909068f57e396d3206a9f3bf48e373f6f281be" translate="yes" xml:space="preserve">
          <source>In addition, QRect provides the &lt;a href=&quot;qrect#getCoords&quot;&gt;getCoords&lt;/a&gt;() function which extracts the position of the rectangle's top-left and bottom-right corner, and the &lt;a href=&quot;qrect#getRect&quot;&gt;getRect&lt;/a&gt;() function which extracts the rectangle's top-left corner, width and height. Use the &lt;a href=&quot;qrect#setCoords&quot;&gt;setCoords&lt;/a&gt;() and &lt;a href=&quot;qrect#setRect&quot;&gt;setRect&lt;/a&gt;() function to manipulate the rectangle's coordinates and dimensions in one go.</source>
          <target state="translated">또한, QRect는 사각형의 왼쪽 상단과 오른쪽 하단 모서리의 위치를 ​​추출 하는 &lt;a href=&quot;qrect#getCoords&quot;&gt;getCoords&lt;/a&gt; () 함수와 사각형의 왼쪽 상단 모서리, 너비 및 높이를 추출하는 &lt;a href=&quot;qrect#getRect&quot;&gt;getRect&lt;/a&gt; () 함수를 제공합니다. 사용 &lt;a href=&quot;qrect#setCoords&quot;&gt;setCoords&lt;/a&gt; ()와 &lt;a href=&quot;qrect#setRect&quot;&gt;setRect&lt;/a&gt; 한 번에 사각형의 좌표와 크기를 조작하는 () 함수를.</target>
        </trans-unit>
        <trans-unit id="5fcb487f588f206f89ed9d6a0a32c7d80fdf204b" translate="yes" xml:space="preserve">
          <source>In addition, QRectF provides the &lt;a href=&quot;qrectf#getCoords&quot;&gt;getCoords&lt;/a&gt;() function which extracts the position of the rectangle's top-left and bottom-right corner, and the &lt;a href=&quot;qrectf#getRect&quot;&gt;getRect&lt;/a&gt;() function which extracts the rectangle's top-left corner, width and height. Use the &lt;a href=&quot;qrectf#setCoords&quot;&gt;setCoords&lt;/a&gt;() and &lt;a href=&quot;qrectf#setRect&quot;&gt;setRect&lt;/a&gt;() function to manipulate the rectangle's coordinates and dimensions in one go.</source>
          <target state="translated">또한 QRectF는 사각형의 좌상단과 우측 하단의 위치를 ​​추출 하는 &lt;a href=&quot;qrectf#getCoords&quot;&gt;getCoords&lt;/a&gt; () 함수와 사각형의 좌상단, 너비, 높이를 추출하는 &lt;a href=&quot;qrectf#getRect&quot;&gt;getRect&lt;/a&gt; () 함수를 제공합니다. 사용 &lt;a href=&quot;qrectf#setCoords&quot;&gt;setCoords&lt;/a&gt; ()와 &lt;a href=&quot;qrectf#setRect&quot;&gt;setRect&lt;/a&gt; 한 번에 사각형의 좌표와 크기를 조작하는 () 함수를.</target>
        </trans-unit>
        <trans-unit id="a45b9993bfcae9c5dba0def58fd31a905dee9509" translate="yes" xml:space="preserve">
          <source>In addition, QRegularExpressionMatch returns the substrings captured by the capturing groups in the pattern string. The implicit capturing group with index 0 captures the result of the whole match. The &lt;a href=&quot;qregularexpressionmatch#captured&quot;&gt;captured&lt;/a&gt;() function returns each substring captured, either by the capturing group's index or by its name:</source>
          <target state="translated">또한 QRegularExpressionMatch는 패턴 문자열의 캡처 그룹에서 캡처 한 하위 문자열을 반환합니다. 인덱스가 0 인 암시 적 캡처 그룹은 전체 일치의 결과를 캡처합니다. &lt;a href=&quot;qregularexpressionmatch#captured&quot;&gt;캡처&lt;/a&gt; 캡처 그룹의 인덱스 또는 이름 중 하나를 각각의 문자열 캡처 () 함수가 반환 :</target>
        </trans-unit>
        <trans-unit id="9cb9a05822f94850d265bd43fe3ad424a0579317" translate="yes" xml:space="preserve">
          <source>In addition, Qt Core provides a platform-independent mechanism for storing binary files in the application's executable.</source>
          <target state="translated">또한 Qt Core는 이진 파일을 응용 프로그램의 실행 파일에 저장하기위한 플랫폼 독립적 메커니즘을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="e6413e0907e17d23446cc05dbd3e37c5fbc5bdc3" translate="yes" xml:space="preserve">
          <source>In addition, Qt Wayland Compositor is available under the &lt;a href=&quot;http://www.gnu.org/licenses/gpl-3.0.html&quot;&gt;GNU General Public License, version 3&lt;/a&gt;, while the Qt Wayland integration plugin is available under the &lt;a href=&quot;http://www.gnu.org/licenses/gpl-3.0.html&quot;&gt;GNU General Public License, version 3&lt;/a&gt; or the &lt;a href=&quot;http://www.gnu.org/licenses/gpl-2.0.html&quot;&gt;GNU General Public License, version 2&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a75f43f682b1fd3051c65a70b2469454aa434705" translate="yes" xml:space="preserve">
          <source>In addition, Qt provides three global manipulators that take a parameter: &lt;a href=&quot;qtextstream#qSetFieldWidth&quot;&gt;qSetFieldWidth&lt;/a&gt;(), &lt;a href=&quot;qtextstream#qSetPadChar&quot;&gt;qSetPadChar&lt;/a&gt;(), and &lt;a href=&quot;qtextstream#qSetRealNumberPrecision&quot;&gt;qSetRealNumberPrecision&lt;/a&gt;().</source>
          <target state="translated">또한 Qt는 &lt;a href=&quot;qtextstream#qSetFieldWidth&quot;&gt;qSetFieldWidth&lt;/a&gt; (), &lt;a href=&quot;qtextstream#qSetPadChar&quot;&gt;qSetPadChar&lt;/a&gt; () 및 &lt;a href=&quot;qtextstream#qSetRealNumberPrecision&quot;&gt;qSetRealNumberPrecision&lt;/a&gt; () 매개 변수를 사용하는 3 개의 전역 조작자를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="ec6ba1dfccefb8ea0bface2588cf2a1aa451cc7f" translate="yes" xml:space="preserve">
          <source>In addition, ViewTransition provides properties specific to the items which are the target of the operation that triggered the transition:</source>
          <target state="translated">또한 ViewTransition은 전환을 트리거 한 작업의 대상인 항목에 특정한 속성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b914c9a13b980209076c664272d3474ddbfaeedf" translate="yes" xml:space="preserve">
          <source>In addition, Windows are always filled with &lt;a href=&quot;qpalette#ColorRole-enum&quot;&gt;QPalette::Window&lt;/a&gt;, unless the WA_OpaquePaintEvent or WA_NoSystemBackground attributes are set.</source>
          <target state="translated">또한 WA_OpaquePaintEvent 또는 WA_NoSystemBackground 속성이 설정되어 있지 않으면 Windows는 항상 &lt;a href=&quot;qpalette#ColorRole-enum&quot;&gt;QPalette :: Window로&lt;/a&gt; 채워집니다 .</target>
        </trans-unit>
        <trans-unit id="d2ad048be8b28912305cac5e9340fbdf557eb523" translate="yes" xml:space="preserve">
          <source>In addition, a &lt;a href=&quot;qinappstore#transactionReady&quot;&gt;transactionReady&lt;/a&gt;() signal may be emitted for any existing transaction which has not yet been finalized. At this point, you should check if the transaction has previously been registered. If it hasn't, register it right away. Finally, call &lt;a href=&quot;qinapptransaction#finalize&quot;&gt;QInAppTransaction::finalize&lt;/a&gt;() on the transaction.</source>
          <target state="translated">또한 아직 완료되지 않은 기존 트랜잭션에 대해 &lt;a href=&quot;qinappstore#transactionReady&quot;&gt;transactionReady&lt;/a&gt; () 신호가 생성 될 수 있습니다. 이 시점에서 트랜잭션이 이전에 등록되었는지 확인해야합니다. 그렇지 않은 경우 즉시 등록하십시오. 마지막으로 트랜잭션에서 &lt;a href=&quot;qinapptransaction#finalize&quot;&gt;QInAppTransaction :: finalize&lt;/a&gt; ()를 호출 하십시오.</target>
        </trans-unit>
        <trans-unit id="298aaf11e6ababff88df1d84101d9d211251a1d1" translate="yes" xml:space="preserve">
          <source>In addition, a &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; that has a parent can become a window by setting the &lt;a href=&quot;qt#WindowType-enum&quot;&gt;Qt::Window&lt;/a&gt; flag. Depending on the window management system such</source>
          <target state="translated">또한 부모가 있는 &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; 은 &lt;a href=&quot;qt#WindowType-enum&quot;&gt;Qt :: Window&lt;/a&gt; 플래그를 설정하여 창이 될 수 있습니다 . 창 관리 시스템에 따라</target>
        </trans-unit>
        <trans-unit id="6c383d87d9ecf4b661ffc1a562764aa9bc4166c8" translate="yes" xml:space="preserve">
          <source>In addition, a &lt;a href=&quot;widgets-changes-qt6#qwidget&quot;&gt;QWidget&lt;/a&gt; that has a parent can become a window by setting the &lt;a href=&quot;qt#WindowType-enum&quot;&gt;Qt::Window&lt;/a&gt; flag. Depending on the window management system such</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83d5a80e1b843b708991828a30680c97b1afbd2b" translate="yes" xml:space="preserve">
          <source>In addition, a json file (&lt;code&gt;mystyleplugin.json&lt;/code&gt;) containing meta data describing the plugin is required for most plugins. For style plugins it simply contains a list of styles that can be created by the plugin:</source>
          <target state="translated">또한 플러그인을 설명하는 메타 데이터가 포함 된 json 파일 ( &lt;code&gt;mystyleplugin.json&lt;/code&gt; )이 대부분의 플러그인에 필요합니다. 스타일 플러그인의 경우 플러그인으로 작성할 수있는 스타일 목록이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="e177f7bdf5fc56ccdaf4497efb44f1eca607df17" translate="yes" xml:space="preserve">
          <source>In addition, a page might also execute scripts added through &lt;a href=&quot;qwebengineprofile#scripts&quot;&gt;QWebEngineProfile::scripts&lt;/a&gt;().</source>
          <target state="translated">또한 페이지는 &lt;a href=&quot;qwebengineprofile#scripts&quot;&gt;QWebEngineProfile :: scripts&lt;/a&gt; ()를 통해 추가 된 스크립트를 실행할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5159fe6cbb8ad71a53796901f6a8fff8c6920b1c" translate="yes" xml:space="preserve">
          <source>In addition, a path can be added to the current path using the &lt;a href=&quot;qpainterpath#connectPath&quot;&gt;connectPath&lt;/a&gt;() function. But note that this function will connect the last element of the current path to the first element of given one by adding a line.</source>
          <target state="translated">또한 &lt;a href=&quot;qpainterpath#connectPath&quot;&gt;connectPath&lt;/a&gt; () 함수를 사용하여 경로를 현재 경로에 추가 할 수 있습니다 . 그러나이 함수는 줄을 추가하여 현재 경로의 마지막 요소를 주어진 요소의 첫 번째 요소에 연결합니다.</target>
        </trans-unit>
        <trans-unit id="82b9975d9e7fe693dc5d865f4967bd299624c8ad" translate="yes" xml:space="preserve">
          <source>In addition, any property that can be mapped to a GLSL type can be made available to the shaders. The following list shows how properties are mapped:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55d3a109895fb8d65710b14af04dc9baaf5b9fcd" translate="yes" xml:space="preserve">
          <source>In addition, any property that can be mapped to an OpenGL Shading Language (GLSL) type is available as a uniform variable. The following list shows how properties are mapped to GLSL uniform variables:</source>
          <target state="translated">또한 GLSL (OpenGL Shading Language) 유형에 매핑 할 수있는 모든 속성을 균일 변수로 사용할 수 있습니다. 다음 목록은 특성이 GLSL 균일 변수에 맵핑되는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="c7e4524fdaa4266008b062613a51b847f8c288da" translate="yes" xml:space="preserve">
          <source>In addition, creating a subclass of &lt;a href=&quot;qabstractvideobuffer&quot;&gt;QAbstractVideoBuffer&lt;/a&gt; will allow you to construct video frames from preallocated or static buffers, in cases where the &lt;a href=&quot;qvideoframe&quot;&gt;QVideoFrame&lt;/a&gt; constructors taking a &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; or a &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt; do not suffice. This may be necessary when implementing a new hardware accelerated video system, for example.</source>
          <target state="translated">또한,의 서브 클래스 생성 &lt;a href=&quot;qabstractvideobuffer&quot;&gt;QAbstractVideoBuffer 것은&lt;/a&gt; 위치를 경우에 사전 할당 또는 정적 버퍼에서 비디오 프레임을 구성 할 수 &lt;a href=&quot;qvideoframe&quot;&gt;QVideoFrame에&lt;/a&gt; 복용하는 생성자 &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; 또는 &lt;a href=&quot;qimage&quot;&gt;QImage이&lt;/a&gt; 충분할를하지 않습니다. 예를 들어, 새로운 하드웨어 가속 비디오 시스템을 구현할 때 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d80ac9fa39f368ebbabb6aa4b9d2a72f870f9b4d" translate="yes" xml:space="preserve">
          <source>In addition, creating a subclass of QAbstractVideoBuffer will allow you to construct video frames from preallocated or static buffers, in cases where the &lt;a href=&quot;qvideoframe&quot;&gt;QVideoFrame&lt;/a&gt; constructors taking a &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; or a &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt; do not suffice. This may be necessary when implementing a new hardware accelerated video system, for example.</source>
          <target state="translated">또한, QAbstractVideoBuffer의 서브 클래스를 만드는 것은 어디 경우에 사전 할당 또는 정적 버퍼에서 비디오 프레임을 구성 할 수 &lt;a href=&quot;qvideoframe&quot;&gt;QVideoFrame에&lt;/a&gt; 복용하는 생성자 &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; 또는 &lt;a href=&quot;qimage&quot;&gt;QImage이&lt;/a&gt; 충분할를하지 않습니다. 예를 들어 새로운 하드웨어 가속 비디오 시스템을 구현할 때 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eade8bb89fa5de3837f420f3a88ab6294e206f2f" translate="yes" xml:space="preserve">
          <source>In addition, each handle has the following read-only attached properties:</source>
          <target state="translated">또한 각 핸들에는 다음과 같은 읽기 전용 연결 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="0204642a4605eb9b9fb8ab0685a3599f114b81d8" translate="yes" xml:space="preserve">
          <source>In addition, examples use the modules &lt;a href=&quot;qtquickcontrols-index&quot;&gt;Qt Quick Controls&lt;/a&gt; and &lt;a href=&quot;qtgraphicaleffects-index&quot;&gt;Qt Graphical Effects&lt;/a&gt; for additional functionality.</source>
          <target state="translated">또한 예제에서는 추가 기능을 위해 &lt;a href=&quot;qtquickcontrols-index&quot;&gt;Qt Quick Controls&lt;/a&gt; 및 &lt;a href=&quot;qtgraphicaleffects-index&quot;&gt;Qt Graphical Effects&lt;/a&gt; 모듈을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="b36b766570493df9a080cb585b48c3dca94dab7d" translate="yes" xml:space="preserve">
          <source>In addition, in order for anything to be rendered in the View3D, the scene needs a &lt;a href=&quot;https://doc.qt.io/qt-6.0/qtquick3d-intro-example.html#camera&quot;&gt;Camera&lt;/a&gt;. If there is only a single &lt;a href=&quot;https://doc.qt.io/qt-6.0/qtquick3d-intro-example.html#camera&quot;&gt;Camera&lt;/a&gt; in the scene, then this will automatically be picked. Otherwise, the &lt;a href=&quot;https://doc.qt.io/qt-6.0/qtquick3d-intro-example.html#camera&quot;&gt;camera&lt;/a&gt; property can be used to select the camera. The &lt;a href=&quot;https://doc.qt.io/qt-6.0/qtquick3d-intro-example.html#camera&quot;&gt;Camera&lt;/a&gt; decides which parts of the scene are visible, and how they are projected onto the 2D surface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dd109b1b85b88138905dd380068e554d860c7ac" translate="yes" xml:space="preserve">
          <source>In addition, it is only emitted for top-level, standalone animations. It will not be emitted for animations in a Behavior or Transition, or animations that are part of an animation group.</source>
          <target state="translated">또한 최상위 독립 실행 형 애니메이션에 대해서만 방출됩니다. 비헤이비어 또는 전환의 애니메이션 또는 애니메이션 그룹의 일부인 애니메이션에 대해서는 생성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2490e3e5a334237da1567a783f01e8009fc9ce74" translate="yes" xml:space="preserve">
          <source>In addition, only affine transformations are supported by drawStaticText(). Calling drawStaticText() on a projected painter will perform slightly worse than using the regular drawText() call, so this should be avoided.</source>
          <target state="translated">또한 drawStaticText ()에서는 아핀 변환 만 지원합니다. 투영 된 페인터에서 drawStaticText ()를 호출하면 일반 drawText () 호출을 사용하는 것보다 약간 더 성능이 저하되므로 피해야합니다.</target>
        </trans-unit>
        <trans-unit id="f211d92c6ab40a26b8f54de18a81d384509a32e9" translate="yes" xml:space="preserve">
          <source>In addition, since the skeleton is an abstract representation, the model need to specify geometry information for the joints. For performance reasons, this is not done by specifying the information directly. Instead, &lt;a href=&quot;qml-qtquick3d-model#inverseBindPoses-prop&quot;&gt;Model.inverseBindPoses&lt;/a&gt; contains the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8bc69ff5c35899fdb2f28fb402ec2dbcb3da958" translate="yes" xml:space="preserve">
          <source>In addition, some of the examples rely on &lt;a href=&quot;qtquickcontrols-index&quot;&gt;Qt Quick Controls&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f19eb41eaf7e0ee26c76e1ac8b4d2b2dc1e7135e" translate="yes" xml:space="preserve">
          <source>In addition, style sheets can be used to provide a distinctive look and feel for your application, without having to subclass &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt;. For example, you can specify arbitrary images for radio buttons and check boxes to make them stand out. Using this technique, you can also achieve minor customizations that would normally require subclassing several style classes, such as specifying a &lt;a href=&quot;qstyle#styleHint&quot;&gt;style hint&lt;/a&gt;. The &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtwidgets-widgets-stylesheet-example.html#&quot;&gt;Style Sheet&lt;/a&gt; example depicted below defines two distinctive style sheets that you can try out and modify at will.</source>
          <target state="translated">또한 스타일 시트를 사용하면 &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt; 을 서브 클래스하지 않고도 애플리케이션에 독특한 모양과 느낌을 제공 할 수 있습니다 . 예를 들어, 라디오 버튼 및 확인란에 대해 임의의 이미지를 지정하여 두드러지게 만들 수 있습니다. 이 기술을 사용하면 일반적으로 &lt;a href=&quot;qstyle#styleHint&quot;&gt;스타일 힌트&lt;/a&gt; 지정과 같은 여러 스타일 클래스를 서브 클래 싱해야하는 사소한 사용자 정의를 수행 할 수 있습니다 . &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtwidgets-widgets-stylesheet-example.html#&quot;&gt;스타일 시트의&lt;/a&gt; 예를 정의 당신이 밖으로 시도하고 마음대로 수정할 수있는 두 개의 독특한 스타일 시트 아래에 묘사했다.</target>
        </trans-unit>
        <trans-unit id="96e9c9128799e1368bad842ffa766e71f000e848" translate="yes" xml:space="preserve">
          <source>In addition, style sheets can be used to provide a distinctive look and feel for your application, without having to subclass &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt;. For example, you can specify arbitrary images for radio buttons and check boxes to make them stand out. Using this technique, you can also achieve minor customizations that would normally require subclassing several style classes, such as specifying a &lt;a href=&quot;qstyle#styleHint&quot;&gt;style hint&lt;/a&gt;. The &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtwidgets-widgets-stylesheet-example.html&quot;&gt;Style Sheet&lt;/a&gt; example depicted below defines two distinctive style sheets that you can try out and modify at will.</source>
          <target state="translated">또한 스타일 시트를 사용하여 &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt; 을 하위 클래스로 분류하지 않고도 애플리케이션에 독특한 모양과 느낌을 제공 할 수 있습니다 . 예를 들어 라디오 버튼 및 확인란에 대해 임의의 이미지를 지정하여 눈에 띄게 만들 수 있습니다. 이 기술을 사용하면 &lt;a href=&quot;qstyle#styleHint&quot;&gt;스타일 힌트&lt;/a&gt; 지정과 같이 일반적으로 여러 스타일 클래스를 서브 클래 싱해야하는 사소한 사용자 정의를 수행 할 수도 있습니다 . &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtwidgets-widgets-stylesheet-example.html&quot;&gt;스타일 시트의&lt;/a&gt; 예를 정의 당신이 밖으로 시도하고 마음대로 수정할 수있는 두 개의 독특한 스타일 시트 아래에 묘사했다.</target>
        </trans-unit>
        <trans-unit id="f9b591986289d0ea4677b5a2e1b88944d95f92c4" translate="yes" xml:space="preserve">
          <source>In addition, style sheets can be used to provide a distinctive look and feel for your application, without having to subclass &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt;. For example, you can specify arbitrary images for radio buttons and check boxes to make them stand out. Using this technique, you can also achieve minor customizations that would normally require subclassing several style classes, such as specifying a &lt;a href=&quot;qstyle#styleHint&quot;&gt;style hint&lt;/a&gt;. The &lt;a href=&quot;https://doc.qt.io/qt-6.0/qtwidgets-widgets-stylesheet-example.html&quot;&gt;Style Sheet&lt;/a&gt; example depicted below defines two distinctive style sheets that you can try out and modify at will.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37770a999540fd15e550dc216ea0b1887914b1b4" translate="yes" xml:space="preserve">
          <source>In addition, the</source>
          <target state="translated">또한</target>
        </trans-unit>
        <trans-unit id="4294cbe29d0a211f41be2675d1170fd01484c757" translate="yes" xml:space="preserve">
          <source>In addition, the &lt;a href=&quot;qpoint&quot;&gt;QPoint&lt;/a&gt; class provides the &lt;a href=&quot;qpoint#manhattanLength&quot;&gt;manhattanLength&lt;/a&gt;() function which gives an inexpensive approximation of the length of the &lt;a href=&quot;qpoint&quot;&gt;QPoint&lt;/a&gt; object interpreted as a vector. Finally, &lt;a href=&quot;qpoint&quot;&gt;QPoint&lt;/a&gt; objects can be streamed as well as compared.</source>
          <target state="translated">또한 &lt;a href=&quot;qpoint&quot;&gt;QPoint&lt;/a&gt; 클래스는 &lt;a href=&quot;qpoint#manhattanLength&quot;&gt;manhattanLength&lt;/a&gt; () 함수를 제공하여 벡터로 해석되는 &lt;a href=&quot;qpoint&quot;&gt;QPoint&lt;/a&gt; 객체 의 길이를 저렴하게 근사화합니다 . 마지막으로 &lt;a href=&quot;qpoint&quot;&gt;QPoint&lt;/a&gt; 객체를 스트리밍하고 비교할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="807bea15a65b9c94213161b391497ccdf492154c" translate="yes" xml:space="preserve">
          <source>In addition, the &lt;a href=&quot;qpointf&quot;&gt;QPointF&lt;/a&gt; class provides a constructor converting a &lt;a href=&quot;qpoint&quot;&gt;QPoint&lt;/a&gt; object into a &lt;a href=&quot;qpointf&quot;&gt;QPointF&lt;/a&gt; object, and a corresponding &lt;a href=&quot;qpointf#toPoint&quot;&gt;toPoint&lt;/a&gt;() function which returns a &lt;a href=&quot;qpoint&quot;&gt;QPoint&lt;/a&gt; copy of</source>
          <target state="translated">또한 &lt;a href=&quot;qpointf&quot;&gt;QPointF의&lt;/a&gt; 클래스는 변환 생성자 제공 &lt;a href=&quot;qpoint&quot;&gt;의 QPoint&lt;/a&gt; (A) 내로 개체 &lt;a href=&quot;qpointf&quot;&gt;QPointF의&lt;/a&gt; 오브젝트와 대응하는 &lt;a href=&quot;qpointf#toPoint&quot;&gt;투 - 포인트&lt;/a&gt; 반환 () 함수 &lt;a href=&quot;qpoint&quot;&gt;의 QPoint가&lt;/a&gt; 의 사본</target>
        </trans-unit>
        <trans-unit id="3637f28f454cec0a1068776d551d93e59bf42145" translate="yes" xml:space="preserve">
          <source>In addition, the &lt;a href=&quot;qstringlist#operator-2b&quot;&gt;operator+&lt;/a&gt;() function allows you to concatenate two string lists into one. To sort a string list, use the &lt;a href=&quot;qstringlist#sort&quot;&gt;sort&lt;/a&gt;() function.</source>
          <target state="translated">또한 &lt;a href=&quot;qstringlist#operator-2b&quot;&gt;operator +&lt;/a&gt; () 함수를 사용하면 두 개의 문자열 목록을 하나로 연결할 수 있습니다. 문자열 목록을 정렬하려면 사용하는 &lt;a href=&quot;qstringlist#sort&quot;&gt;일종의&lt;/a&gt; () 함수를.</target>
        </trans-unit>
        <trans-unit id="66461439f94dba43b25e37e7160162baf0cbc4f5" translate="yes" xml:space="preserve">
          <source>In addition, the &lt;a href=&quot;stylesheet-reference#image-prop&quot;&gt;image&lt;/a&gt; property may be used to draw an image over the border-image. The image specified does not tile or stretch and when its size does not match the size of the widget, its alignment is specified using the &lt;a href=&quot;stylesheet-reference#image-position-prop&quot;&gt;image-position&lt;/a&gt; property. Unlike background-image and border-image, one may specify a SVG in the image property, in which case the image is scaled automatically according to the widget size.</source>
          <target state="translated">또한 &lt;a href=&quot;stylesheet-reference#image-prop&quot;&gt;이미지&lt;/a&gt; 속성을 사용하여 테두리 이미지 위에 이미지를 그릴 수 있습니다. 지정된 이미지는 바둑판 식으로 배열되거나 늘어나지 않으며 크기가 위젯의 크기와 일치하지 않으면 &lt;a href=&quot;stylesheet-reference#image-position-prop&quot;&gt;이미지 위치&lt;/a&gt; 속성을 사용하여 정렬이 지정 됩니다. 배경 이미지 및 테두리 이미지와 달리 이미지 속성에 SVG를 지정할 수 있습니다.이 경우 이미지는 위젯 크기에 따라 자동으로 크기가 조정됩니다.</target>
        </trans-unit>
        <trans-unit id="0be9d3ab130c96780568d37ff0c851e6dbb7a73b" translate="yes" xml:space="preserve">
          <source>In addition, the QPoint class provides the &lt;a href=&quot;qpoint#manhattanLength&quot;&gt;manhattanLength&lt;/a&gt;() function which gives an inexpensive approximation of the length of the QPoint object interpreted as a vector. Finally, QPoint objects can be streamed as well as compared.</source>
          <target state="translated">또한 QPoint 클래스는 벡터로 해석되는 QPoint 객체의 길이에 대한 저렴한 근사값을 제공하는 &lt;a href=&quot;qpoint#manhattanLength&quot;&gt;manhattanLength&lt;/a&gt; () 함수를 제공합니다. 마지막으로 QPoint 개체를 스트리밍하고 비교할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c47ff418cdd400994917113195d181b6b415ec0" translate="yes" xml:space="preserve">
          <source>In addition, the QPointF class provides a constructor converting a &lt;a href=&quot;qpoint&quot;&gt;QPoint&lt;/a&gt; object into a QPointF object, and a corresponding &lt;a href=&quot;qpointf#toPoint&quot;&gt;toPoint&lt;/a&gt;() function which returns a &lt;a href=&quot;qpoint&quot;&gt;QPoint&lt;/a&gt; copy of</source>
          <target state="translated">또한 QPointF 클래스는 &lt;a href=&quot;qpoint&quot;&gt;QPoint&lt;/a&gt; 객체를 QPointF 객체로 변환하는 생성자 와 &lt;a href=&quot;qpoint&quot;&gt;QPoint&lt;/a&gt; 복사본 을 반환하는 해당 &lt;a href=&quot;qpointf#toPoint&quot;&gt;toPoint&lt;/a&gt; () 함수를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="dea77fbe280f92dee21373f59390dc366899517d" translate="yes" xml:space="preserve">
          <source>In addition, the class &lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt; has been moved to a new module, named Qt OpenGL Widgets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0a46630ab43bb00e5b49a5179d16ab40545a5dd" translate="yes" xml:space="preserve">
          <source>In addition, the class provides a couple of enums: The &lt;a href=&quot;qstyleoptiontoolbar#ToolBarFeature-enum&quot;&gt;ToolBarFeature&lt;/a&gt; enum is used to describe whether a toolbar is movable or not, and the &lt;a href=&quot;qstyleoptiontoolbar#ToolBarPosition-enum&quot;&gt;ToolBarPosition&lt;/a&gt; enum is used to describe the position of a toolbar line, as well as the toolbar's position within the line.</source>
          <target state="translated">또한이 클래스는 몇 가지 열거 형을 제공합니다. &lt;a href=&quot;qstyleoptiontoolbar#ToolBarFeature-enum&quot;&gt;ToolBarFeature&lt;/a&gt; 열거 형은 툴바가 움직일 수 있는지 여부 를 설명하는 데 사용되며 &lt;a href=&quot;qstyleoptiontoolbar#ToolBarPosition-enum&quot;&gt;ToolBarPosition&lt;/a&gt; 열거 형은 툴바 선의 위치와 선 내의 툴바 위치를 설명하는 데 사용됩니다. .</target>
        </trans-unit>
        <trans-unit id="2ba86444f7fcc6614720b4640a80b993cf8794df" translate="yes" xml:space="preserve">
          <source>In addition, the conversion to &lt;a href=&quot;qtcore-changes-qt6#qvariant&quot;&gt;QVariant&lt;/a&gt; is not completely lossless. Please see the documentation in &lt;a href=&quot;qcborvalue#toVariant&quot;&gt;QCborValue::toVariant&lt;/a&gt;() for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75d5ff971616d26e5375ef2a0ec1826ba1c540ca" translate="yes" xml:space="preserve">
          <source>In addition, the conversion to &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; is not completely lossless. Please see the documentation in &lt;a href=&quot;qcborvalue#toVariant&quot;&gt;QCborValue::toVariant&lt;/a&gt;() for more information.</source>
          <target state="translated">또한 &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; 로의 변환 은 완전히 무손실이 아닙니다. 자세한 내용은 &lt;a href=&quot;qcborvalue#toVariant&quot;&gt;QCborValue :: toVariant&lt;/a&gt; () 의 설명서 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2c0aad9a5f4d6d3691448b59800e8efecbf2634e" translate="yes" xml:space="preserve">
          <source>In addition, the dialog provides the option of selecting an &lt;b&gt;Icon&lt;/b&gt; for the action, as well as removing the current icon.</source>
          <target state="translated">또한 대화 상자는 현재 아이콘을 제거 할뿐만 아니라 작업에 대한 &lt;b&gt;아이콘&lt;/b&gt; 을 선택하는 옵션을 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="f1e61f5cc2b8a1a7c9fe1993a17a4377dc5970c7" translate="yes" xml:space="preserve">
          <source>In addition, the extensions &quot;nec-vdc&quot;, &quot;ibm-vdc&quot; and &quot;udc&quot; are supported.</source>
          <target state="translated">또한 &quot;nec-vdc&quot;, &quot;ibm-vdc&quot;및 &quot;udc&quot;확장자가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="1ea450e4219d5bab329f2b96ad472f7728b09be1" translate="yes" xml:space="preserve">
          <source>In addition, the following must be decided before configuring:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3154207d78cebec16ad2a44095214e734adfa54b" translate="yes" xml:space="preserve">
          <source>In addition, the following tools are required for building the &lt;a href=&quot;qtwebengine-index&quot;&gt;Qt WebEngine&lt;/a&gt; module:</source>
          <target state="translated">또한 &lt;a href=&quot;qtwebengine-index&quot;&gt;Qt WebEngine&lt;/a&gt; 모듈 을 빌드하려면 다음 도구가 필요 합니다.</target>
        </trans-unit>
        <trans-unit id="334be7c783ae69325d868c8da8d12cde4136c0a0" translate="yes" xml:space="preserve">
          <source>In addition, the following tools are required for building the &lt;a href=&quot;qtwebengine-index#&quot;&gt;Qt WebEngine&lt;/a&gt; module:</source>
          <target state="translated">또한 &lt;a href=&quot;qtwebengine-index#&quot;&gt;Qt WebEngine&lt;/a&gt; 모듈 을 빌드하려면 다음 도구가 필요 합니다.</target>
        </trans-unit>
        <trans-unit id="0453fbf34dc2eba5602d502c98ac28714d17df39" translate="yes" xml:space="preserve">
          <source>In addition, the following types are also supported: &lt;a href=&quot;qchar&quot;&gt;QChar&lt;/a&gt;, &lt;a href=&quot;qlatin1char&quot;&gt;QLatin1Char&lt;/a&gt;.</source>
          <target state="translated">또한 다음 유형도 지원됩니다 : &lt;a href=&quot;qchar&quot;&gt;QChar&lt;/a&gt; , &lt;a href=&quot;qlatin1char&quot;&gt;QLatin1Char&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="259a8a4680ce9ea422a3b43fc3383c00eb6a9891" translate="yes" xml:space="preserve">
          <source>In addition, the menu item &lt;code&gt;triggered()&lt;/code&gt; and &lt;code&gt;toggled()&lt;/code&gt; signals will not be emitted. Instead, the action &lt;code&gt;triggered()&lt;/code&gt; and &lt;code&gt;toggled()&lt;/code&gt; signals will be.</source>
          <target state="translated">또한 메뉴 항목 &lt;code&gt;triggered()&lt;/code&gt; 및 &lt;code&gt;toggled()&lt;/code&gt; 신호가 방출되지 않습니다. 대신 액션 &lt;code&gt;triggered()&lt;/code&gt; 및 &lt;code&gt;toggled()&lt;/code&gt; 신호가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="544e92fffbac4dd68d060c68b488a2fb20754198" translate="yes" xml:space="preserve">
          <source>In addition, the mesh topology (primitive type) must be specified too. For indexed drawing, the data for an index buffer must be provided as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57898156cd4bdc735abe027f8d52c69114c111dd" translate="yes" xml:space="preserve">
          <source>In addition, the property is marked as</source>
          <target state="translated">또한이 속성은</target>
        </trans-unit>
        <trans-unit id="eff9231505151a209a8e5699e0cede17c3ebc5a3" translate="yes" xml:space="preserve">
          <source>In addition, there is now only one valid, case-sensitive form for style names: &quot;Material&quot;, &quot;MyStyle&quot;, and so on. That is: the style name must exactly match the name of the QML module. This also applies to file selectors, where previously, all style names were lower case. For example, where the following was a valid structure for a Qt 5 project:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c256e841e5885018f8d36ae9f87bdc49ef0fa441" translate="yes" xml:space="preserve">
          <source>In addition, true will be returned for shortcuts (&lt;code&gt;*.lnk&lt;/code&gt; files) on Windows. Opening those will open the &lt;code&gt;.lnk&lt;/code&gt; file itself.</source>
          <target state="translated">또한 Windows 에서 단축키 ( &lt;code&gt;*.lnk&lt;/code&gt; 파일)에 대해서는 true가 반환됩니다 . 그것들을 열면 &lt;code&gt;.lnk&lt;/code&gt; 파일 자체 가 열립니다 .</target>
        </trans-unit>
        <trans-unit id="131ab7d55f95ac9c63a0b79d67f59f9c9f514eab" translate="yes" xml:space="preserve">
          <source>In addition, true will be returned for shortcuts (&lt;code&gt;*.lnk&lt;/code&gt; files) on Windows. This behavior is deprecated and will likely change in a future version of Qt. Opening those will open the &lt;code&gt;.lnk&lt;/code&gt; file itself.</source>
          <target state="translated">또한 Windows 에서 바로 가기 ( &lt;code&gt;*.lnk&lt;/code&gt; 파일)에 대해 true가 반환됩니다 . 이 동작은 더 이상 사용되지 않으며 향후 Qt 버전에서 변경 될 수 있습니다. 이 파일 을 열면 &lt;code&gt;.lnk&lt;/code&gt; 파일 자체 가 열립니다 .</target>
        </trans-unit>
        <trans-unit id="b85bf730226efcb8dbba20f8b402be883786be4b" translate="yes" xml:space="preserve">
          <source>In addition, you can customize or create your own user interface by deriving your own loader class.</source>
          <target state="translated">또한 고유 한 로더 클래스를 파생시켜 고유 한 사용자 인터페이스를 사용자 정의하거나 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8775a5f4292c4d5a3d2ec861b0eb5ed5abe3c49" translate="yes" xml:space="preserve">
          <source>In addition, you can use features introduced with Windows 7, such as Aero Peek, Jump Lists, a progress indicator on a taskbar button, or a thumbnail toolbar.</source>
          <target state="translated">또한 Aero Peek, 점프 목록, 작업 표시 줄 단추의 진행률 표시기 또는 축소판 도구 모음과 같이 Windows 7에 도입 된 기능을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="463c64bcc9966c4d69bde36ea74f4415b5444bc3" translate="yes" xml:space="preserve">
          <source>In additional to a copy of the &lt;a href=&quot;qbluetoothtransferrequest&quot;&gt;QBluetoothTransferRequest&lt;/a&gt; object used to create the request, &lt;a href=&quot;qbluetoothtransferreply&quot;&gt;QBluetoothTransferReply&lt;/a&gt; contains the contents of the reply itself.</source>
          <target state="translated">요청을 작성하는 데 사용 된 &lt;a href=&quot;qbluetoothtransferrequest&quot;&gt;QBluetoothTransferRequest&lt;/a&gt; 오브젝트 의 사본 외에 &lt;a href=&quot;qbluetoothtransferreply&quot;&gt;QBluetoothTransferReply&lt;/a&gt; 에는 응답 자체의 컨텐츠가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="7c48fd3cc2f690e861cb313730241881862f1ac2" translate="yes" xml:space="preserve">
          <source>In additional to a copy of the &lt;a href=&quot;qbluetoothtransferrequest&quot;&gt;QBluetoothTransferRequest&lt;/a&gt; object used to create the request, QBluetoothTransferReply contains the contents of the reply itself.</source>
          <target state="translated">요청을 생성하는 데 사용 된 &lt;a href=&quot;qbluetoothtransferrequest&quot;&gt;QBluetoothTransferRequest&lt;/a&gt; 객체 의 복사본 외에도 QBluetoothTransferReply에는 응답 자체의 내용이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="7963ae02d9ae56508ad29960b63dd83d294ccbb8" translate="yes" xml:space="preserve">
          <source>In alert state, the window indicates that it demands attention, for example by flashing or bouncing the taskbar entry.</source>
          <target state="translated">경고 상태에서 창은 예를 들어 작업 표시 줄 항목을 깜박이거나 수신 거부하여주의가 필요함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="4514bd62bce43fb3e470760f2f43559ef1f9a8f1" translate="yes" xml:space="preserve">
          <source>In all cases,</source>
          <target state="translated">모든 경우에,</target>
        </trans-unit>
        <trans-unit id="b2ddeff0647b1e25802a4a6fbff662d14d08cb99" translate="yes" xml:space="preserve">
          <source>In all of the &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; functions that take &lt;code&gt;const char *&lt;/code&gt; parameters, the &lt;code&gt;const char *&lt;/code&gt; is interpreted as a classic C-style '\0'-terminated string encoded in UTF-8. It is legal for the &lt;code&gt;const char *&lt;/code&gt; parameter to be &lt;code&gt;nullptr&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;const char *&lt;/code&gt; 매개 변수를 사용하는 모든 &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; 함수 에서 &lt;code&gt;const char *&lt;/code&gt; 는 UTF-8로 인코딩 된 클래식 C 스타일 '\ 0'으로 끝나는 문자열로 해석됩니다. &lt;code&gt;const char *&lt;/code&gt; 매개 변수가 &lt;code&gt;nullptr&lt;/code&gt; 인 것이 합법적입니다 .</target>
        </trans-unit>
        <trans-unit id="606b894b4e9644bb97a708a2c9e7a6f700495ba6" translate="yes" xml:space="preserve">
          <source>In all of the QString functions that take &lt;code&gt;const char *&lt;/code&gt; parameters, the &lt;code&gt;const char *&lt;/code&gt; is interpreted as a classic C-style '\0'-terminated string encoded in UTF-8. It is legal for the &lt;code&gt;const char *&lt;/code&gt; parameter to be &lt;code&gt;nullptr&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;const char *&lt;/code&gt; 매개 변수를 사용하는 모든 QString 함수 에서 &lt;code&gt;const char *&lt;/code&gt; 는 UTF-8로 인코딩 된 고전적인 C 스타일 '\ 0'종료 문자열로 해석됩니다. &lt;code&gt;const char *&lt;/code&gt; 매개 변수가 &lt;code&gt;nullptr&lt;/code&gt; 인 것은 합법적입니다 .</target>
        </trans-unit>
        <trans-unit id="46185100ddc5fa96ee7b078daa3ff964a2e06d05" translate="yes" xml:space="preserve">
          <source>In all other Unix-type systems, this function always returns &quot;unknown&quot;.</source>
          <target state="translated">다른 모든 유닉스 유형 시스템에서이 함수는 항상 &quot;알 수 없음&quot;을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3d4e3e330fdaf3532958f7d2e3fa664ddbaa42cc" translate="yes" xml:space="preserve">
          <source>In all other aspects, the class is the same. Please refer to &lt;a href=&quot;qrandomgenerator&quot;&gt;QRandomGenerator&lt;/a&gt;'s documentation for more information.</source>
          <target state="translated">다른 모든 측면에서 클래스는 동일합니다. 를 참조하십시오 &lt;a href=&quot;qrandomgenerator&quot;&gt;QRandomGenerator&lt;/a&gt; 자세한 내용의 설명서.</target>
        </trans-unit>
        <trans-unit id="f275549afeb6ce9e54fd32ffe522dc9b4853886d" translate="yes" xml:space="preserve">
          <source>In all other cases</source>
          <target state="translated">다른 모든 경우</target>
        </trans-unit>
        <trans-unit id="47e08556e5e2c760deb39a74b3062bbe01c81e54" translate="yes" xml:space="preserve">
          <source>In all other cases, the new &lt;a href=&quot;qrandomgenerator&quot;&gt;QRandomGenerator&lt;/a&gt; object will start at the same position in the deterministic sequence as the</source>
          <target state="translated">다른 모든 경우에는 새 &lt;a href=&quot;qrandomgenerator&quot;&gt;QRandomGenerator&lt;/a&gt; 오브젝트가 결정 순서에서 동일한 위치에서 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="21d0eac833f7227dea6d012f1d3c6b82b36bcb3b" translate="yes" xml:space="preserve">
          <source>In all other cases, the new QRandomGenerator object will start at the same position in the deterministic sequence as the</source>
          <target state="translated">다른 모든 경우에 새 QRandomGenerator 개체는 결정적 시퀀스의 동일한 위치에서 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="2d52301091442ee7f197c20e330e83b794ca3e19" translate="yes" xml:space="preserve">
          <source>In all other cases, where the source code to the custom widgets is available, we can adapt the custom widget for use with</source>
          <target state="translated">다른 모든 경우에, 사용자 정의 위젯에 대한 소스 코드가 사용 가능한 경우, 사용자 정의 위젯을 다음과 함께 사용하도록 조정할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="cea8912a36ba47c9a555c445dd112d414d9fe8b1" translate="yes" xml:space="preserve">
          <source>In all other respects, property value sources are regular QML types that can have properties, signals methods and so on, but with the added capability that they can be used to change property values using the &lt;code&gt;&amp;lt;PropertyValueSource&amp;gt; on &amp;lt;property&amp;gt;&lt;/code&gt; syntax.</source>
          <target state="translated">다른 모든 측면에서 속성 값 소스는 속성, 신호 방법 등을 가질 수 있지만 &lt;code&gt;&amp;lt;PropertyValueSource&amp;gt; on &amp;lt;property&amp;gt;&lt;/code&gt; 구문 의 &amp;lt;PropertyValueSource&amp;gt;를 사용하여 속성 값을 변경하는 데 사용할 수있는 기능이 추가 된 일반 QML 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="68be1244c692e681b85f7a736975755b80b13362" translate="yes" xml:space="preserve">
          <source>In all the other cases it's possible to start the camera directly from unloaded state.</source>
          <target state="translated">다른 모든 경우에는 언로드 상태에서 카메라를 직접 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea87c3113788a784159fd7dac0b5a0b9556cc440" translate="yes" xml:space="preserve">
          <source>In all the other cases, it's possible to start the camera directly from the unloaded state.</source>
          <target state="translated">다른 모든 경우에는 언로드 된 상태에서 직접 카메라를 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4b9233a51e1e060331ea3b736194c375facb2023" translate="yes" xml:space="preserve">
          <source>In an exclusive group, the user cannot uncheck the currently checked action by triggering it; instead, another action in the group must be triggered to set the new checked action for that group.</source>
          <target state="translated">배타적 그룹에서 사용자는 현재 확인 된 작업을 트리거하여 선택을 취소 할 수 없습니다. 대신, 그룹의 다른 조치를 트리거하여 해당 그룹에 대해 새 점검 조치를 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="690db6b2a51f1eaf775df4d65497a1a51cb723e6" translate="yes" xml:space="preserve">
          <source>In an exclusive group, the user cannot uncheck the currently checked button by clicking on it; instead, another button in the group must be clicked to set the new checked button for that group.</source>
          <target state="translated">독점 그룹에서 사용자는 현재 선택된 단추를 클릭하여 선택을 취소 할 수 없습니다. 대신 그룹의 다른 버튼을 클릭하여 해당 그룹에 대해 새로 선택된 버튼을 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="9336b9cc8f537feeae957a4aefb184706e860089" translate="yes" xml:space="preserve">
          <source>In an exclusive menu item group, only one item can be checked at any time; checking another item automatically unchecks the previously checked one.</source>
          <target state="translated">독점 메뉴 항목 그룹에서는 언제든지 하나의 항목 만 확인할 수 있습니다. 다른 항목을 확인하면 이전에 확인한 항목이 자동으로 선택 취소됩니다.</target>
        </trans-unit>
        <trans-unit id="139759fe936af14ab258217452c17e6bf0d141bf" translate="yes" xml:space="preserve">
          <source>In an image over a title bar in the Java style, we show the bounding rectangles of the sub elements supported by the Java style (all of which are drawn with standard pixmaps). It is usual to draw the button backgrounds using &lt;code&gt;PE_PanelButtonTool&lt;/code&gt;, but it's not mandatory.</source>
          <target state="translated">Java 스타일의 제목 표시 줄 위에있는 이미지에는 Java 스타일이 지원하는 하위 요소의 경계 사각형이 표시됩니다 (모두 표준 픽스맵으로 그려 짐). &lt;code&gt;PE_PanelButtonTool&lt;/code&gt; 을 사용하여 버튼 배경을 그리는 것이 일반적 이지만 필수는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="16e96054603e3b6b045c9475e4054772c913f367" translate="yes" xml:space="preserve">
          <source>In any application which expects to create translucent windows, it's necessary to set this to true before creating the first &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt;. The default value is false.</source>
          <target state="translated">반투명 창을 만들 것으로 예상되는 모든 응용 프로그램에서 첫 번째 &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt; 를 만들기 전에 이것을 true로 설정해야합니다 . 기본값은 false입니다.</target>
        </trans-unit>
        <trans-unit id="692fa6695bdd339718247690e7bfb93f9cd60a4f" translate="yes" xml:space="preserve">
          <source>In applications many common commands can be invoked via menus, toolbar buttons, and keyboard shortcuts. Since the user expects each command to be performed in the same way, regardless of the user interface used, it is useful to represent each command as an</source>
          <target state="translated">응용 프로그램에서는 메뉴, 도구 모음 단추 및 키보드 단축키를 통해 많은 공통 명령을 호출 할 수 있습니다. 사용자는 사용 된 사용자 인터페이스에 관계없이 각 명령이 동일한 방식으로 수행 될 것으로 예상하므로 각 명령을</target>
        </trans-unit>
        <trans-unit id="ec16753f9b169809d5315cca662d85c483c4a9f2" translate="yes" xml:space="preserve">
          <source>In applications, windows provide the screen space upon which the user interface is built. Windows separate applications visually from each other and usually provide a window decoration that allows the user to resize and position the applications according to his preferences. Windows are typically integrated into the desktop environment and to some degree managed by the window management system that the desktop environment provides. For instance, selected windows of an application are represented in the task bar.</source>
          <target state="translated">응용 프로그램에서 창은 사용자 인터페이스가 구축되는 화면 공간을 제공합니다. Windows는 응용 프로그램을 서로 시각적으로 분리하며 일반적으로 사용자가 자신의 취향에 따라 응용 프로그램의 크기를 조정하고 배치 할 수있는 창 장식을 제공합니다. Windows는 일반적으로 데스크톱 환경에 통합되며 데스크톱 환경이 제공하는 창 관리 시스템에 의해 어느 정도 관리됩니다. 예를 들어, 응용 프로그램의 선택된 창은 작업 표시 줄에 나타납니다.</target>
        </trans-unit>
        <trans-unit id="da98e6fbeabb2716d313454293ae17c5537c72bb" translate="yes" xml:space="preserve">
          <source>In areas beyond this image, pixels are set to 0. For 32-bit RGB images, this means black; for 32-bit ARGB images, this means transparent black; for 8-bit images, this means the color with index 0 in the color table which can be anything; for 1-bit images, this means &lt;a href=&quot;qt#GlobalColor-enum&quot;&gt;Qt::color0&lt;/a&gt;.</source>
          <target state="translated">이 이미지 이외의 영역에서는 픽셀이 0으로 설정됩니다. 32 비트 RGB 이미지의 경우 검은 색을 의미합니다. 32 비트 ARGB 이미지의 경우 이는 투명한 검정색을 의미합니다. 8 비트 이미지의 경우 이는 색상 표에서 색인 0의 색상을 의미합니다. 1 비트 이미지의 경우 &lt;a href=&quot;qt#GlobalColor-enum&quot;&gt;Qt :: color0을&lt;/a&gt; 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="c989f99f7fca6bc1c632b6912280beb6031bbad0" translate="yes" xml:space="preserve">
          <source>In automatic focusing modes, the &lt;a href=&quot;qml-qtmultimedia-camerafocus#focusPointMode-prop&quot;&gt;focusPointMode&lt;/a&gt; property and &lt;a href=&quot;qml-qtmultimedia-camerafocus#focusZones-prop&quot;&gt;focusZones&lt;/a&gt; property provide information and control over how automatic focusing is performed.</source>
          <target state="translated">자동 초점 모드에서 &lt;a href=&quot;qml-qtmultimedia-camerafocus#focusPointMode-prop&quot;&gt;focusPointMode&lt;/a&gt; 속성 및 &lt;a href=&quot;qml-qtmultimedia-camerafocus#focusZones-prop&quot;&gt;focusZones&lt;/a&gt; 속성은 정보를 제공하고 자동 초점이 수행되는 방법을 제어합니다.</target>
        </trans-unit>
        <trans-unit id="8317ef30e050c1b2a18c87c257ee398e6393d9ce" translate="yes" xml:space="preserve">
          <source>In bar charts, bars are defined as bar sets that contain one data value for each category. The position of a bar is specified by the category and its height by the data value. Bar series that contain multiple bar sets group together bars that belong to the same category. The way the bars are displayed is determined by the subclass of this class chosen to create the bar chart.</source>
          <target state="translated">막대 차트에서 막대는 각 범주에 대해 하나의 데이터 값을 포함하는 막대 세트로 정의됩니다. 막대의 위치는 카테고리로, 높이는 데이터 값으로 지정됩니다. 여러 막대 세트를 포함하는 막대 시리즈는 동일한 범주에 속하는 막대를 그룹화합니다. 막대가 표시되는 방식은 막대 차트를 작성하기 위해 선택한이 클래스의 서브 클래스에 의해 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="45ee35eebc89a7516006609749715a9cf14e1e70" translate="yes" xml:space="preserve">
          <source>In bar charts, bars are defined as bar sets that contain one data value for each category. The position of a bar is specified by the category and its height by the data value. Bar series that contain multiple bar sets group together bars that belong to the same category. The way the bars are displayed is determined by the type chosen to create the bar chart: &lt;a href=&quot;qml-qtcharts-barseries&quot;&gt;BarSeries&lt;/a&gt;, &lt;a href=&quot;qml-qtcharts-stackedbarseries&quot;&gt;StackedBarSeries&lt;/a&gt;, &lt;a href=&quot;qml-qtcharts-percentbarseries&quot;&gt;PercentBarSeries&lt;/a&gt;, &lt;a href=&quot;qml-qtcharts-horizontalbarseries&quot;&gt;HorizontalBarSeries&lt;/a&gt;, &lt;a href=&quot;qml-qtcharts-horizontalstackedbarseries&quot;&gt;HorizontalStackedBarSeries&lt;/a&gt;, or &lt;a href=&quot;qml-qtcharts-horizontalpercentbarseries&quot;&gt;HorizontalPercentBarSeries&lt;/a&gt;.</source>
          <target state="translated">막대 차트에서 막대는 각 범주에 대해 하나의 데이터 값을 포함하는 막대 세트로 정의됩니다. 막대의 위치는 카테고리로, 높이는 데이터 값으로 지정됩니다. 여러 막대 세트를 포함하는 막대 시리즈는 동일한 범주에 속하는 막대를 그룹화합니다. 막대가 표시되는 방식은 막대 차트를 작성하기 위해 선택한 유형 ( &lt;a href=&quot;qml-qtcharts-barseries&quot;&gt;BarSeries&lt;/a&gt; , &lt;a href=&quot;qml-qtcharts-stackedbarseries&quot;&gt;StackedBarSeries&lt;/a&gt; , &lt;a href=&quot;qml-qtcharts-percentbarseries&quot;&gt;PercentBarSeries&lt;/a&gt; , &lt;a href=&quot;qml-qtcharts-horizontalbarseries&quot;&gt;HorizontalBarSeries&lt;/a&gt; , &lt;a href=&quot;qml-qtcharts-horizontalstackedbarseries&quot;&gt;HorizontalStackedBarSeries&lt;/a&gt; 또는 &lt;a href=&quot;qml-qtcharts-horizontalpercentbarseries&quot;&gt;HorizontalPercentBarSeries)에 따라 결정&lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="1da4b7608499cb4d9199ddde1548bf4d9b453c3d" translate="yes" xml:space="preserve">
          <source>In both cases &lt;a href=&quot;qerrormessage&quot;&gt;QErrorMessage&lt;/a&gt; will queue pending messages and display them in order, with each new message being shown as soon as the user has accepted the previous message. Once the user has specified that a message is not to be shown again it is automatically skipped, and the dialog will show the next appropriate message in the queue.</source>
          <target state="translated">두 경우 모두 &lt;a href=&quot;qerrormessage&quot;&gt;QErrorMessage&lt;/a&gt; 는 보류중인 메시지를 큐에 넣고 순서대로 표시하며 사용자가 이전 메시지를 수락하자마자 각각의 새 메시지가 표시됩니다. 사용자가 메시지를 다시 표시하지 않도록 지정하면 메시지를 자동으로 건너 뛰고 대화 상자에 다음 적절한 메시지가 큐에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="d8a4a925424bbd69b0411894710d9d7a2226dfcf" translate="yes" xml:space="preserve">
          <source>In both cases QErrorMessage will queue pending messages and display them in order, with each new message being shown as soon as the user has accepted the previous message. Once the user has specified that a message is not to be shown again it is automatically skipped, and the dialog will show the next appropriate message in the queue.</source>
          <target state="translated">두 경우 모두 QErrorMessage는 보류중인 메시지를 대기열에 넣고 순서대로 표시하며 사용자가 이전 메시지를 수락하자마자 각각의 새 메시지가 표시됩니다. 사용자가 메시지를 다시 표시하지 않도록 지정하면 자동으로 건너 뛰고 대화 상자에 대기열의 다음 적절한 메시지가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="48727c4f24c1b1bebdfe2449a2dc47ec53057414" translate="yes" xml:space="preserve">
          <source>In both cases the position information is received via the &lt;a href=&quot;qgeopositioninfosource#positionUpdated&quot;&gt;positionUpdated&lt;/a&gt;() signal and the last known position can be accessed with &lt;a href=&quot;qnmeapositioninfosource#lastKnownPosition&quot;&gt;lastKnownPosition&lt;/a&gt;().</source>
          <target state="translated">두 경우 모두 위치 정보는 &lt;a href=&quot;qgeopositioninfosource#positionUpdated&quot;&gt;positionUpdated&lt;/a&gt; () 신호 를 통해 수신되며 &lt;a href=&quot;qnmeapositioninfosource#lastKnownPosition&quot;&gt;lastKnownPosition&lt;/a&gt; ()을 사용 하여 마지막으로 알려진 위치에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b3b23cd22d7aec875c727844783902cf6f75a89a" translate="yes" xml:space="preserve">
          <source>In both cases you can only rely on the child being a &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; (or, if &lt;a href=&quot;qobject#isWidgetType&quot;&gt;QObject::isWidgetType&lt;/a&gt;() returns &lt;code&gt;true&lt;/code&gt;, a &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt;). This is because in the &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent::ChildAdded&lt;/a&gt; case the child is not yet fully constructed; in the &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent::ChildRemoved&lt;/a&gt; case it might have already been destructed.</source>
          <target state="translated">두 경우 모두 &lt;a href=&quot;qobject&quot;&gt;QObject 인&lt;/a&gt; 자식에만 의존 할 수 있습니다 (또는 &lt;a href=&quot;qobject#isWidgetType&quot;&gt;QObject :: isWidgetType&lt;/a&gt; ()이 &lt;code&gt;true&lt;/code&gt; 를 반환 하면 &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; ). &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent :: ChildAdded&lt;/a&gt; 케이스에서 자식이 아직 완전히 구성되지 않았기 때문입니다 . 에 &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent :: ChildRemoved의&lt;/a&gt; 경우 이미 파괴되었을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ac70efc8bd20e8a9b5d71475a37740f026a3ef86" translate="yes" xml:space="preserve">
          <source>In both cases you can only rely on the child being a &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; (or, if &lt;a href=&quot;qobject#isWidgetType&quot;&gt;QObject::isWidgetType&lt;/a&gt;() returns &lt;code&gt;true&lt;/code&gt;, a &lt;a href=&quot;widgets-changes-qt6#qwidget&quot;&gt;QWidget&lt;/a&gt;). This is because in the &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent::ChildAdded&lt;/a&gt; case the child is not yet fully constructed; in the &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent::ChildRemoved&lt;/a&gt; case it might have already been destructed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b47b90c72db98cef0d0517fc03051399c430e8c" translate="yes" xml:space="preserve">
          <source>In both cases, a ray will be cast through the scene to find geometry intersecting the ray.</source>
          <target state="translated">두 경우 모두 광선이 교차하는 형상을 찾기 위해 장면을 통해 캐스트됩니다.</target>
        </trans-unit>
        <trans-unit id="16d0dd1c3efc95f3e6feb7ff726f68584afab600" translate="yes" xml:space="preserve">
          <source>In both cases, the file may either be a local file or in a &lt;a href=&quot;resources&quot;&gt;resource&lt;/a&gt;.</source>
          <target state="translated">두 경우 모두 파일은 로컬 파일이거나 &lt;a href=&quot;resources&quot;&gt;리소스 일 수&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="b4f61469829ccedc96d407de227553d31019c412" translate="yes" xml:space="preserve">
          <source>In both modes the progress dialog may be customized by replacing the child widgets with custom widgets by using &lt;a href=&quot;qprogressdialog#setLabel&quot;&gt;setLabel&lt;/a&gt;(), &lt;a href=&quot;qprogressdialog#setBar&quot;&gt;setBar&lt;/a&gt;(), and &lt;a href=&quot;qprogressdialog#setCancelButton&quot;&gt;setCancelButton&lt;/a&gt;(). The functions &lt;a href=&quot;qprogressdialog#labelText-prop&quot;&gt;setLabelText&lt;/a&gt;() and &lt;a href=&quot;qprogressdialog#setCancelButtonText&quot;&gt;setCancelButtonText&lt;/a&gt;() set the texts shown.</source>
          <target state="translated">두 모드 모두에서 &lt;a href=&quot;qprogressdialog#setLabel&quot;&gt;setLabel&lt;/a&gt; (), &lt;a href=&quot;qprogressdialog#setBar&quot;&gt;setBar&lt;/a&gt; () 및 &lt;a href=&quot;qprogressdialog#setCancelButton&quot;&gt;setCancelButton&lt;/a&gt; () 을 사용하여 하위 위젯을 사용자 정의 위젯으로 교체하여 진행률 대화 상자를 사용자 정의 할 수 있습니다 . &lt;a href=&quot;qprogressdialog#labelText-prop&quot;&gt;setLabelText&lt;/a&gt; () 및 &lt;a href=&quot;qprogressdialog#setCancelButtonText&quot;&gt;setCancelButtonText&lt;/a&gt; () 함수 는 표시된 텍스트를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="6abdd1e00428bd13a38cc59cc27012745da0841f" translate="yes" xml:space="preserve">
          <source>In both scenarios the size of the item and the Loader are identical. This ensures that anchoring to the Loader is equivalent to anchoring to the loaded item.</source>
          <target state="translated">두 시나리오에서 항목의 크기와 로더는 동일합니다. 이렇게하면 로더에 고정하는 것이로드 된 항목에 고정하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3b6410812bb79165260872e790b3aeeacfb98336" translate="yes" xml:space="preserve">
          <source>In both the &lt;a href=&quot;qobject#Q_PROPERTY&quot;&gt;Q_PROPERTY&lt;/a&gt; and return from &lt;a href=&quot;qobject#Q_INVOKABLE&quot;&gt;Q_INVOKABLE&lt;/a&gt; cases, the elements of a std::vector are copied. This copying may be an expensive operation, so std::vector should be used judiciously.</source>
          <target state="translated">양쪽에서 &lt;a href=&quot;qobject#Q_PROPERTY&quot;&gt;Q_PROPERTY&lt;/a&gt; 와의 리턴 &lt;a href=&quot;qobject#Q_INVOKABLE&quot;&gt;Q_INVOKABLE&lt;/a&gt; 경우, 성병 : 벡터의 요소가 복사됩니다. 이 복사는 비용이 많이 드는 작업이므로 std :: vector를 신중하게 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="dda0089d34ad9f159900c7c59a6831aead8730ac" translate="yes" xml:space="preserve">
          <source>In both these cases, we provide</source>
          <target state="translated">이 두 경우 모두</target>
        </trans-unit>
        <trans-unit id="8ba2c56c2973199791cd11f73ae5b03f53ca84eb" translate="yes" xml:space="preserve">
          <source>In case memory allocation fails, &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; will throw a &lt;code&gt;std::bad_alloc&lt;/code&gt; exception. Out of memory conditions in the Qt containers are the only case where Qt will throw exceptions.</source>
          <target state="translated">메모리 할당이 실패하면 &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; 는 &lt;code&gt;std::bad_alloc&lt;/code&gt; 예외를 발생시킵니다. Qt 컨테이너의 메모리 부족 조건은 Qt가 예외를 발생시키는 유일한 경우입니다.</target>
        </trans-unit>
        <trans-unit id="ef15aa7461c89d9fc123f519ddcbd5713e865016" translate="yes" xml:space="preserve">
          <source>In case memory allocation fails, &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; will throw a &lt;code&gt;std::bad_alloc&lt;/code&gt; exception. Out of memory conditions in the Qt containers are the only case where Qt will throw exceptions.</source>
          <target state="translated">메모리 할당이 실패하면 &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; 은 &lt;code&gt;std::bad_alloc&lt;/code&gt; 예외를 발생시킵니다. Qt 컨테이너의 메모리 부족 조건은 Qt가 예외를 발생시키는 유일한 경우입니다.</target>
        </trans-unit>
        <trans-unit id="589322a4fd437840ac5d03458d5e677d518922ad" translate="yes" xml:space="preserve">
          <source>In case memory allocation fails, &lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt; will use the &lt;a href=&quot;qtglobal#Q_CHECK_PTR&quot;&gt;Q_CHECK_PTR&lt;/a&gt; macro, which will throw a &lt;code&gt;std::bad_alloc&lt;/code&gt; exception if the application is being compiled with exception support. If exceptions are disabled, then running out of memory is undefined behavior.</source>
          <target state="translated">메모리 할당이 실패하면 &lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt; 는 &lt;a href=&quot;qtglobal#Q_CHECK_PTR&quot;&gt;Q_CHECK_PTR&lt;/a&gt; 매크로 를 사용 하여 응용 프로그램이 예외 지원으로 컴파일되는 경우 &lt;code&gt;std::bad_alloc&lt;/code&gt; 예외를 발생시킵니다. 예외가 비활성화되면 메모리 부족이 정의되지 않은 동작입니다.</target>
        </trans-unit>
        <trans-unit id="cf793d8ff1bc3843822c95bfed9623d641287e5a" translate="yes" xml:space="preserve">
          <source>In case memory allocation fails, QByteArray will throw a &lt;code&gt;std::bad_alloc&lt;/code&gt; exception. Out of memory conditions in the Qt containers are the only case where Qt will throw exceptions.</source>
          <target state="translated">메모리 할당에 실패하면 QByteArray는 &lt;code&gt;std::bad_alloc&lt;/code&gt; 예외를 발생시킵니다. Qt 컨테이너의 메모리 부족 상태는 Qt가 예외를 발생시키는 유일한 경우입니다.</target>
        </trans-unit>
        <trans-unit id="e114642af1422602eea14007a4e88b10771e860b" translate="yes" xml:space="preserve">
          <source>In case memory allocation fails, QList will use the &lt;a href=&quot;qtglobal#Q_CHECK_PTR&quot;&gt;Q_CHECK_PTR&lt;/a&gt; macro, which will throw a &lt;code&gt;std::bad_alloc&lt;/code&gt; exception if the application is being compiled with exception support. If exceptions are disabled, then running out of memory is undefined behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0c113d67f78f255d83cdf614e2f994647b5d053" translate="yes" xml:space="preserve">
          <source>In case memory allocation fails, QString will throw a &lt;code&gt;std::bad_alloc&lt;/code&gt; exception. Out of memory conditions in the Qt containers are the only case where Qt will throw exceptions.</source>
          <target state="translated">메모리 할당이 실패하면 QString은 &lt;code&gt;std::bad_alloc&lt;/code&gt; 예외를 발생시킵니다. Qt 컨테이너의 메모리 부족 상태는 Qt가 예외를 발생시키는 유일한 경우입니다.</target>
        </trans-unit>
        <trans-unit id="49912a13afca71d82eee411238c0bb595e0cf9a6" translate="yes" xml:space="preserve">
          <source>In case memory allocation fails, QVector will use the &lt;a href=&quot;qtglobal#Q_CHECK_PTR&quot;&gt;Q_CHECK_PTR&lt;/a&gt; macro, which will throw a &lt;code&gt;std::bad_alloc&lt;/code&gt; exception if the application is being compiled with exception support. If exceptions are disabled, then running out of memory is undefined behavior.</source>
          <target state="translated">메모리 할당이 실패하는 경우 QVector는 &lt;a href=&quot;qtglobal#Q_CHECK_PTR&quot;&gt;Q_CHECK_PTR&lt;/a&gt; 매크로 를 사용합니다 .이 매크로 는 애플리케이션이 예외 지원으로 컴파일되는 경우 &lt;code&gt;std::bad_alloc&lt;/code&gt; 예외를 발생시킵니다. 예외가 비활성화되면 메모리 부족은 정의되지 않은 동작입니다.</target>
        </trans-unit>
        <trans-unit id="403f40fd85f4c2cdd8b3e799596aba751f98f07b" translate="yes" xml:space="preserve">
          <source>In case of Direct3D 12, all combinations are supported. If the &lt;a href=&quot;qml-qtquick-shadereffect#vertexShader-prop&quot;&gt;vertexShader&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-shadereffect#fragmentShader-prop&quot;&gt;fragmentShader&lt;/a&gt; properties form a valid URL with the &lt;code&gt;file&lt;/code&gt; or &lt;code&gt;qrc&lt;/code&gt; schema, the bytecode or HLSL source code is read from the specified file. The type of the file contents is detected automatically. Otherwise, the string is treated as HLSL source code and is compiled at runtime, assuming Shader Model 5.0 and an entry point of &lt;code&gt;&quot;main&quot;&lt;/code&gt;. This allows dynamically constructing shader strings. However, whenever the shader source code is static, it is strongly recommended to pre-compile to bytecode using the &lt;code&gt;fxc&lt;/code&gt; tool and refer to these files from QML. This will be a lot more efficient at runtime and allows catching syntax errors in the shaders at compile time.</source>
          <target state="translated">Direct3D 12의 경우 모든 조합이 지원됩니다. 는 IF &lt;a href=&quot;qml-qtquick-shadereffect#vertexShader-prop&quot;&gt;vertexShader&lt;/a&gt; 및 &lt;a href=&quot;qml-qtquick-shadereffect#fragmentShader-prop&quot;&gt;fragmentShader&lt;/a&gt; 속성이있는 유효한 URL 구성 &lt;code&gt;file&lt;/code&gt; 또는 &lt;code&gt;qrc&lt;/code&gt; 스키마를 바이트 코드 또는 HLSL 소스 코드는 지정된 파일에서 읽습니다. 파일 내용의 유형이 자동으로 감지됩니다. 그렇지 않으면 문자열이 HLSL 소스 코드로 처리되고 Shader Model 5.0 및 시작점 &lt;code&gt;&quot;main&quot;&lt;/code&gt; 을 가정하여 런타임에 컴파일됩니다 . 이를 통해 셰이더 문자열을 동적으로 구성 할 수 있습니다. 그러나 셰이더 소스 코드가 정적 일 때마다 &lt;code&gt;fxc&lt;/code&gt; 를 사용하여 바이트 코드로 사전 컴파일하는 것이 좋습니다.QML에서 이러한 파일을 참조하십시오. 런타임에 훨씬 더 효율적이며 컴파일 타임에 쉐이더에서 구문 오류를 잡을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c14cde32faa4da56bd1b22b376c08b53ff772c4" translate="yes" xml:space="preserve">
          <source>In case of a 32-bit image, the &lt;a href=&quot;qimage#setPixel&quot;&gt;setPixel&lt;/a&gt;() function can be used to alter the color of the pixel at the given coordinates to any other color specified as an ARGB quadruplet. To make a suitable &lt;a href=&quot;qcolor#QRgb-typedef&quot;&gt;QRgb&lt;/a&gt; value, use the &lt;a href=&quot;qcolor#qRgb&quot;&gt;qRgb&lt;/a&gt;() (adding a default alpha component to the given RGB values, i.e. creating an opaque color) or &lt;a href=&quot;qcolor#qRgba&quot;&gt;qRgba&lt;/a&gt;() function. For example:</source>
          <target state="translated">32 비트 이미지의 경우 &lt;a href=&quot;qimage#setPixel&quot;&gt;setPixel&lt;/a&gt; () 함수를 사용하여 지정된 좌표의 픽셀 색상을 ARGB 쿼드 러 플릿으로 지정된 다른 색상으로 변경할 수 있습니다. 적절한 &lt;a href=&quot;qcolor#QRgb-typedef&quot;&gt;QRgb&lt;/a&gt; 값 을 만들려면 &lt;a href=&quot;qcolor#qRgb&quot;&gt;qRgb&lt;/a&gt; () (주어진 RGB 값에 기본 알파 구성 요소 추가, 즉 불투명 한 색상 만들기) 또는 &lt;a href=&quot;qcolor#qRgba&quot;&gt;qRgba&lt;/a&gt; () 함수를 사용하십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5d7d5bcfadd6c3fe703c910abf652c70be9ff65b" translate="yes" xml:space="preserve">
          <source>In case of a 8-bit and monchrome images, the pixel value is only an index from the image's color table. So the &lt;a href=&quot;qimage#setPixel&quot;&gt;setPixel&lt;/a&gt;() function can only be used to alter the color of the pixel at the given coordinates to a predefined color from the image's color table, i.e. it can only change the pixel's index value. To alter or add a color to an image's color table, use the &lt;a href=&quot;qimage#setColor&quot;&gt;setColor&lt;/a&gt;() function.</source>
          <target state="translated">8 비트 및 몽 크롬 이미지의 경우 픽셀 값은 이미지의 색상 표의 색인 일뿐입니다. 따라서 &lt;a href=&quot;qimage#setPixel&quot;&gt;setPixel&lt;/a&gt; () 함수는 주어진 좌표에서 픽셀의 색상을 이미지의 색상 표에서 사전 정의 된 색상으로 변경하는 데만 사용할 수 있습니다. 즉, 픽셀의 색인 값만 변경할 수 있습니다. 이미지의 색상 표에 색상을 변경하거나 추가하려면 &lt;a href=&quot;qimage#setColor&quot;&gt;setColor&lt;/a&gt; () 함수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="a851d9fe112db829b09fad6f6917a830554ffe43" translate="yes" xml:space="preserve">
          <source>In case of a synthesized event, for example a mouse event that was generated from a touch event, &lt;code&gt;device()&lt;/code&gt; continues to return the touchscreen device, so that you can tell that it did not come from an actual mouse. Thus &lt;code&gt;mouseEvent.source()-&amp;gt;type() != QInputDevice::DeviceType::Mouse&lt;/code&gt; is one possible replacement for the Qt 5 expression &lt;code&gt;mouseEvent.source() == Qt::MouseEventSynthesizedByQt&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="724cba1dcf313bb869b22da346f5f89258880c94" translate="yes" xml:space="preserve">
          <source>In case of having multiple screens, it is also possible to show the splash screen on a different screen than the primary one. For example:</source>
          <target state="translated">여러 화면이있는 경우 기본 화면과 다른 화면에 스플래시 화면을 표시 할 수도 있습니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="cec00035a1597adbdaa9047833b476dabefb639c" translate="yes" xml:space="preserve">
          <source>In case of monochrome and 8-bit images, the &lt;a href=&quot;qimage#colorCount&quot;&gt;colorCount&lt;/a&gt;() and &lt;a href=&quot;qimage#colorTable&quot;&gt;colorTable&lt;/a&gt;() functions provide information about the color components used to store the image data: The &lt;a href=&quot;qimage#colorTable&quot;&gt;colorTable&lt;/a&gt;() function returns the image's entire color table. To obtain a single entry, use the &lt;a href=&quot;qimage#pixelIndex&quot;&gt;pixelIndex&lt;/a&gt;() function to retrieve the pixel index for a given pair of coordinates, then use the &lt;a href=&quot;qimage#color&quot;&gt;color&lt;/a&gt;() function to retrieve the color. Note that if you create an 8-bit image manually, you have to set a valid color table on the image as well.</source>
          <target state="translated">단색 및 8 비트 이미지의 경우 &lt;a href=&quot;qimage#colorCount&quot;&gt;colorCount&lt;/a&gt; () 및 &lt;a href=&quot;qimage#colorTable&quot;&gt;colorTable&lt;/a&gt; () 함수는 이미지 데이터를 저장하는 데 사용되는 색상 구성 요소에 대한 정보를 제공합니다. &lt;a href=&quot;qimage#colorTable&quot;&gt;colorTable&lt;/a&gt; () 함수는 이미지의 전체 색상 표를 리턴합니다. 단일 항목을 얻으려면 &lt;a href=&quot;qimage#pixelIndex&quot;&gt;pixelIndex&lt;/a&gt; () 함수를 사용하여 주어진 좌표 쌍에 대한 픽셀 인덱스를 검색 한 다음 &lt;a href=&quot;qimage#color&quot;&gt;color&lt;/a&gt; () 함수를 사용하여 색상 을 검색하십시오. 8 비트 이미지를 수동으로 생성하는 경우 이미지에도 유효한 색상 표를 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="9f557a853f9dcfb42e9e7e75aa25bfa12a9a5690" translate="yes" xml:space="preserve">
          <source>In case of monochrome and 8-bit images, the image is first converted to a 32-bit pixmap and then filled with the colors in the color table. If this is too expensive an operation, you can use &lt;a href=&quot;qbitmap#fromImage&quot;&gt;QBitmap::fromImage&lt;/a&gt;() instead.</source>
          <target state="translated">단색 및 8 비트 이미지의 경우 이미지는 먼저 32 비트 픽스맵으로 변환 된 다음 색상 표의 색상으로 채워집니다. 이 작업이 너무 &lt;a href=&quot;qbitmap#fromImage&quot;&gt;비싸면 QBitmap :: fromImage&lt;/a&gt; ()를 대신 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9fa67a1070b08a851e693bbd2542ad775e33396c" translate="yes" xml:space="preserve">
          <source>In case of parsing error, returns an empty &lt;a href=&quot;qpageranges&quot;&gt;QPageRanges&lt;/a&gt; object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8a0296aba6dcfa0a1a1a5597305f635dc74150d" translate="yes" xml:space="preserve">
          <source>In case of scaled image reading, the quality setting may also influence the tradeoff level between visual quality and execution speed of the scaling algorithm.</source>
          <target state="translated">스케일링 된 이미지 판독의 경우, 품질 설정은 또한 시각적 품질과 스케일링 알고리즘의 실행 속도 사이의 트레이드 오프 레벨에 영향을 줄 수있다.</target>
        </trans-unit>
        <trans-unit id="d9f9e57feb9696fefa51cb0a67b9e44cf7890dd7" translate="yes" xml:space="preserve">
          <source>In case of the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ae544507d3486de8b97f48520e17ee0e147c2d6" translate="yes" xml:space="preserve">
          <source>In case the</source>
          <target state="translated">경우에</target>
        </trans-unit>
        <trans-unit id="593f205da1c052290a1493d0e66e6609df894718" translate="yes" xml:space="preserve">
          <source>In case the environment variable is not set, or contains an invalid directory, the virtual keyboard falls back to the default built-in layouts.</source>
          <target state="translated">환경 변수가 설정되지 않았거나 유효하지 않은 디렉토리를 포함하는 경우 가상 키보드는 기본 내장 레이아웃으로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="7fa48d768cf215396ea33c0e816f375dc4a64a2d" translate="yes" xml:space="preserve">
          <source>In case the environment variable is not set, or contains an invalid style name, the virtual keyboard falls back in the default built-in style.</source>
          <target state="translated">환경 변수가 설정되지 않거나 유효하지 않은 스타일 이름이 포함 된 경우 가상 키보드는 기본 내장 스타일로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="062a2e9136354c61add4182e5499e92258fe3943" translate="yes" xml:space="preserve">
          <source>In case the input manifest file should not be processed and only copied to the target directory, the verbatim configuration needs to be set.</source>
          <target state="translated">입력 Manifest 파일을 처리하지 않고 대상 디렉토리로만 복사해야하는 경우, 그대로 구성을 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="b49eabccfb18df9a9fa4a7e77113f4890f8d8cc1" translate="yes" xml:space="preserve">
          <source>In case the old code relied on the specialization of the qLess() functor, then a workaround is explicitly passing an instance of the qLess() class to the STL function, for instance like this:</source>
          <target state="translated">이전 코드가 qLess () functor의 특수화에 의존 한 경우, 해결 방법은 qLess () 클래스의 인스턴스를 STL 함수에 명시 적으로 전달하는 것입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="854bc338fc82cd645a280613c93774b792dc760e" translate="yes" xml:space="preserve">
          <source>In case the peer's identity cannot be validated during the handshake, the application must inspect errors returned by &lt;a href=&quot;qdtls#peerVerificationErrors&quot;&gt;peerVerificationErrors&lt;/a&gt;() and then either ignore errors by calling &lt;a href=&quot;qdtls#ignoreVerificationErrors&quot;&gt;ignoreVerificationErrors&lt;/a&gt;() or abort the handshake by calling &lt;a href=&quot;qdtls#abortHandshake&quot;&gt;abortHandshake&lt;/a&gt;(). If errors were ignored, the handshake can be resumed by calling &lt;a href=&quot;qdtls#resumeHandshake&quot;&gt;resumeHandshake&lt;/a&gt;().</source>
          <target state="translated">경우 피어의 식별 정보는, 오류를 검사해야하는 응용 프로그램에 의해 반환 된 핸드 셰이크 중에 확인할 수 없습니다 &lt;a href=&quot;qdtls#peerVerificationErrors&quot;&gt;peerVerificationErrors&lt;/a&gt; () 다음 중 하나를 호출하여 오류 무시 &lt;a href=&quot;qdtls#ignoreVerificationErrors&quot;&gt;ignoreVerificationErrors을&lt;/a&gt; () 또는 호출하여 악수를 중단 &lt;a href=&quot;qdtls#abortHandshake&quot;&gt;abortHandshake을&lt;/a&gt; (). 오류가 무시 된 경우 &lt;a href=&quot;qdtls#resumeHandshake&quot;&gt;resumeHandshake&lt;/a&gt; () 를 호출하여 핸드 셰이크를 재개 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="443a05df41b9b488c4430ad1a042096a6bb504e9" translate="yes" xml:space="preserve">
          <source>In case the variant contains a type not directly supported by &lt;a href=&quot;dbus-changes-qt6#qdbusargument&quot;&gt;QDBusArgument&lt;/a&gt;, the value of the returned &lt;a href=&quot;qdbusvariant&quot;&gt;QDBusVariant&lt;/a&gt; will contain another &lt;a href=&quot;dbus-changes-qt6#qdbusargument&quot;&gt;QDBusArgument&lt;/a&gt;. It is your responsibility to further demarshall it into another type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="545192acf356e40b2ed271a1b563337b471f4054" translate="yes" xml:space="preserve">
          <source>In case the variant contains a type not directly supported by &lt;a href=&quot;qdbusargument&quot;&gt;QDBusArgument&lt;/a&gt;, the value of the returned &lt;a href=&quot;qdbusvariant&quot;&gt;QDBusVariant&lt;/a&gt; will contain another &lt;a href=&quot;qdbusargument&quot;&gt;QDBusArgument&lt;/a&gt;. It is your responsibility to further demarshall it into another type.</source>
          <target state="translated">변형이 &lt;a href=&quot;qdbusargument&quot;&gt;QDBusArgument가&lt;/a&gt; 직접 지원하지 않는 유형을 포함하는 경우, 리턴 된 &lt;a href=&quot;qdbusvariant&quot;&gt;QDBusVariant&lt;/a&gt; 의 값 에는 다른 &lt;a href=&quot;qdbusargument&quot;&gt;QDBusArgument&lt;/a&gt; 가 포함 됩니다 . 추가로 다른 유형으로 분리하는 것은 귀하의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="0f3e28ef45b6dabf51c46c2a84ed7163d3dba6df" translate="yes" xml:space="preserve">
          <source>In case you already ported your application or library to the &lt;a href=&quot;cmake-manual&quot;&gt;cmake&lt;/a&gt; build system, add the following to your &lt;code&gt;CMakeList.txt&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9dc0e3475dc4358a0868f9b62af555733e8f226e" translate="yes" xml:space="preserve">
          <source>In case you want to pass a result to another asynchronous task, you can use &lt;a href=&quot;qfuture#then&quot;&gt;QFuture::then&lt;/a&gt;() to create a chain of dependent tasks. See the &lt;a href=&quot;qtcore-changes-qt6#qfuture&quot;&gt;QFuture&lt;/a&gt; documentation for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e570868f4356eb6490a48ad675c8dc61891c9112" translate="yes" xml:space="preserve">
          <source>In cases where an atomic operation is only supported in newer generations of the processor, &lt;a href=&quot;qatomicinteger&quot;&gt;QAtomicInteger&lt;/a&gt; also provides a way to check at runtime what your hardware supports with the &lt;a href=&quot;qatomicinteger#isReferenceCountingNative&quot;&gt;isReferenceCountingNative&lt;/a&gt;(), &lt;a href=&quot;qatomicinteger#isTestAndSetNative&quot;&gt;isTestAndSetNative&lt;/a&gt;(), &lt;a href=&quot;qatomicinteger#isFetchAndStoreNative&quot;&gt;isFetchAndStoreNative&lt;/a&gt;(), and &lt;a href=&quot;qatomicinteger#isFetchAndAddNative&quot;&gt;isFetchAndAddNative&lt;/a&gt;() functions. Wait-free implementations can be detected using the &lt;a href=&quot;qatomicinteger#isReferenceCountingWaitFree&quot;&gt;isReferenceCountingWaitFree&lt;/a&gt;(), &lt;a href=&quot;qatomicinteger#isTestAndSetWaitFree&quot;&gt;isTestAndSetWaitFree&lt;/a&gt;(), &lt;a href=&quot;qatomicinteger#isFetchAndStoreWaitFree&quot;&gt;isFetchAndStoreWaitFree&lt;/a&gt;(), and &lt;a href=&quot;qatomicinteger#isFetchAndAddWaitFree&quot;&gt;isFetchAndAddWaitFree&lt;/a&gt;() functions.</source>
          <target state="translated">원자 연산이 최신 세대의 프로세서에서만 지원되는 경우 &lt;a href=&quot;qatomicinteger&quot;&gt;QAtomicInteger&lt;/a&gt; 는 &lt;a href=&quot;qatomicinteger#isReferenceCountingNative&quot;&gt;isReferenceCountingNative&lt;/a&gt; (), &lt;a href=&quot;qatomicinteger#isTestAndSetNative&quot;&gt;isTestAndSetNative&lt;/a&gt; (), &lt;a href=&quot;qatomicinteger#isFetchAndStoreNative&quot;&gt;isFetchAndStoreNative&lt;/a&gt; () 및 &lt;a href=&quot;qatomicinteger#isFetchAndAddNative&quot;&gt;isFetchAndAddNative&lt;/a&gt; () 함수로 하드웨어가 지원하는 것을 런타임에 확인하는 방법도 제공 합니다. &lt;a href=&quot;qatomicinteger#isReferenceCountingWaitFree&quot;&gt;isReferenceCountingWaitFree&lt;/a&gt; (), &lt;a href=&quot;qatomicinteger#isTestAndSetWaitFree&quot;&gt;isTestAndSetWaitFree&lt;/a&gt; (), &lt;a href=&quot;qatomicinteger#isFetchAndStoreWaitFree&quot;&gt;isFetchAndStoreWaitFree&lt;/a&gt; () 및 &lt;a href=&quot;qatomicinteger#isFetchAndAddWaitFree&quot;&gt;isFetchAndAddWaitFree&lt;/a&gt; () 함수를 사용하여 대기없는 구현을 감지 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="90c0466e27e4ab9491979baf07dcdde1a18d3fd9" translate="yes" xml:space="preserve">
          <source>In cases where an atomic operation is only supported in newer generations of the processor, &lt;a href=&quot;qatomicpointer&quot;&gt;QAtomicPointer&lt;/a&gt; also provides a way to check at runtime what your hardware supports with the &lt;a href=&quot;qatomicpointer#isTestAndSetNative&quot;&gt;isTestAndSetNative&lt;/a&gt;(), &lt;a href=&quot;qatomicpointer#isFetchAndStoreNative&quot;&gt;isFetchAndStoreNative&lt;/a&gt;(), and &lt;a href=&quot;qatomicpointer#isFetchAndAddNative&quot;&gt;isFetchAndAddNative&lt;/a&gt;() functions. Wait-free implementations can be detected using the &lt;a href=&quot;qatomicpointer#isTestAndSetWaitFree&quot;&gt;isTestAndSetWaitFree&lt;/a&gt;(), &lt;a href=&quot;qatomicpointer#isFetchAndStoreWaitFree&quot;&gt;isFetchAndStoreWaitFree&lt;/a&gt;(), and &lt;a href=&quot;qatomicpointer#isFetchAndAddWaitFree&quot;&gt;isFetchAndAddWaitFree&lt;/a&gt;() functions.</source>
          <target state="translated">원자 연산이 최신 세대의 프로세서에서만 지원되는 경우 &lt;a href=&quot;qatomicpointer&quot;&gt;QAtomicPointer&lt;/a&gt; 는 런타임에 &lt;a href=&quot;qatomicpointer#isTestAndSetNative&quot;&gt;isTestAndSetNative&lt;/a&gt; (), &lt;a href=&quot;qatomicpointer#isFetchAndStoreNative&quot;&gt;isFetchAndStoreNative&lt;/a&gt; () 및 &lt;a href=&quot;qatomicpointer#isFetchAndAddNative&quot;&gt;isFetchAndAddNative&lt;/a&gt; () 함수로 하드웨어가 지원하는 사항을 런타임에 확인하는 방법도 제공 합니다. &lt;a href=&quot;qatomicpointer#isTestAndSetWaitFree&quot;&gt;isTestAndSetWaitFree&lt;/a&gt; (), &lt;a href=&quot;qatomicpointer#isFetchAndStoreWaitFree&quot;&gt;isFetchAndStoreWaitFree&lt;/a&gt; () 및 &lt;a href=&quot;qatomicpointer#isFetchAndAddWaitFree&quot;&gt;isFetchAndAddWaitFree&lt;/a&gt; () 함수를 사용하여 대기없는 구현을 감지 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0091932713f3d777bcf03a0497e62d487a0b1c30" translate="yes" xml:space="preserve">
          <source>In cases where an atomic operation is only supported in newer generations of the processor, QAtomicInteger also provides a way to check at runtime what your hardware supports with the &lt;a href=&quot;qatomicinteger#isReferenceCountingNative&quot;&gt;isReferenceCountingNative&lt;/a&gt;(), &lt;a href=&quot;qatomicinteger#isTestAndSetNative&quot;&gt;isTestAndSetNative&lt;/a&gt;(), &lt;a href=&quot;qatomicinteger#isFetchAndStoreNative&quot;&gt;isFetchAndStoreNative&lt;/a&gt;(), and &lt;a href=&quot;qatomicinteger#isFetchAndAddNative&quot;&gt;isFetchAndAddNative&lt;/a&gt;() functions. Wait-free implementations can be detected using the &lt;a href=&quot;qatomicinteger#isReferenceCountingWaitFree&quot;&gt;isReferenceCountingWaitFree&lt;/a&gt;(), &lt;a href=&quot;qatomicinteger#isTestAndSetWaitFree&quot;&gt;isTestAndSetWaitFree&lt;/a&gt;(), &lt;a href=&quot;qatomicinteger#isFetchAndStoreWaitFree&quot;&gt;isFetchAndStoreWaitFree&lt;/a&gt;(), and &lt;a href=&quot;qatomicinteger#isFetchAndAddWaitFree&quot;&gt;isFetchAndAddWaitFree&lt;/a&gt;() functions.</source>
          <target state="translated">원자 적 작업이 최신 프로세서 세대에서만 지원되는 경우 QAtomicInteger는 또한 하드웨어가 &lt;a href=&quot;qatomicinteger#isReferenceCountingNative&quot;&gt;isReferenceCountingNative&lt;/a&gt; (), &lt;a href=&quot;qatomicinteger#isTestAndSetNative&quot;&gt;isTestAndSetNative&lt;/a&gt; (), &lt;a href=&quot;qatomicinteger#isFetchAndStoreNative&quot;&gt;isFetchAndStoreNative&lt;/a&gt; () 및 &lt;a href=&quot;qatomicinteger#isFetchAndAddNative&quot;&gt;isFetchAndAddNative&lt;/a&gt; () 함수를 사용하여 지원하는 것을 런타임에 확인할 수있는 방법을 제공 합니다. 대기없는 구현은 &lt;a href=&quot;qatomicinteger#isReferenceCountingWaitFree&quot;&gt;isReferenceCountingWaitFree&lt;/a&gt; (), &lt;a href=&quot;qatomicinteger#isTestAndSetWaitFree&quot;&gt;isTestAndSetWaitFree&lt;/a&gt; (), &lt;a href=&quot;qatomicinteger#isFetchAndStoreWaitFree&quot;&gt;isFetchAndStoreWaitFree&lt;/a&gt; () 및 &lt;a href=&quot;qatomicinteger#isFetchAndAddWaitFree&quot;&gt;isFetchAndAddWaitFree&lt;/a&gt; () 함수를 사용하여 감지 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ce4784f4f9070ba2ed5a2dd2a9c189d338393afc" translate="yes" xml:space="preserve">
          <source>In cases where an atomic operation is only supported in newer generations of the processor, QAtomicPointer also provides a way to check at runtime what your hardware supports with the &lt;a href=&quot;qatomicpointer#isTestAndSetNative&quot;&gt;isTestAndSetNative&lt;/a&gt;(), &lt;a href=&quot;qatomicpointer#isFetchAndStoreNative&quot;&gt;isFetchAndStoreNative&lt;/a&gt;(), and &lt;a href=&quot;qatomicpointer#isFetchAndAddNative&quot;&gt;isFetchAndAddNative&lt;/a&gt;() functions. Wait-free implementations can be detected using the &lt;a href=&quot;qatomicpointer#isTestAndSetWaitFree&quot;&gt;isTestAndSetWaitFree&lt;/a&gt;(), &lt;a href=&quot;qatomicpointer#isFetchAndStoreWaitFree&quot;&gt;isFetchAndStoreWaitFree&lt;/a&gt;(), and &lt;a href=&quot;qatomicpointer#isFetchAndAddWaitFree&quot;&gt;isFetchAndAddWaitFree&lt;/a&gt;() functions.</source>
          <target state="translated">원자 적 작업이 최신 프로세서 세대에서만 지원되는 경우 QAtomicPointer는 &lt;a href=&quot;qatomicpointer#isTestAndSetNative&quot;&gt;isTestAndSetNative&lt;/a&gt; (), &lt;a href=&quot;qatomicpointer#isFetchAndStoreNative&quot;&gt;isFetchAndStoreNative&lt;/a&gt; () 및 &lt;a href=&quot;qatomicpointer#isFetchAndAddNative&quot;&gt;isFetchAndAddNative&lt;/a&gt; () 함수를 사용 하여 하드웨어가 지원하는 사항을 런타임에 확인할 수있는 방법도 제공 합니다. 대기없는 구현은 &lt;a href=&quot;qatomicpointer#isTestAndSetWaitFree&quot;&gt;isTestAndSetWaitFree&lt;/a&gt; (), &lt;a href=&quot;qatomicpointer#isFetchAndStoreWaitFree&quot;&gt;isFetchAndStoreWaitFree&lt;/a&gt; () 및 &lt;a href=&quot;qatomicpointer#isFetchAndAddWaitFree&quot;&gt;isFetchAndAddWaitFree&lt;/a&gt; () 함수를 사용하여 감지 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6cc7cb8f56c52c62b79f7c46c534f50e4b95ffec" translate="yes" xml:space="preserve">
          <source>In cases where anchors are used to match the widths or heights of widgets, it is convenient to use the &lt;a href=&quot;qgraphicsanchorlayout#addAnchors&quot;&gt;addAnchors&lt;/a&gt;() function. As with the other functions for specifying anchors, it can also be used to anchor a widget to a layout.</source>
          <target state="translated">앵커가 위젯의 너비 또는 높이와 일치하는 데 사용되는 경우 &lt;a href=&quot;qgraphicsanchorlayout#addAnchors&quot;&gt;addAnchors&lt;/a&gt; () 함수 를 사용하는 것이 편리 합니다. 앵커를 지정하는 다른 기능과 마찬가지로 위젯을 레이아웃에 앵커하는 데 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="da791f973c7954950e7dec5bd6cbf317ffe952f8" translate="yes" xml:space="preserve">
          <source>In cases where it is not possible to fit the rect plus margins inside the viewport the contents are scrolled so that as much as possible is visible from</source>
          <target state="translated">뷰포트 내부에 rect plus margin을 맞출 수없는 경우 내용이 스크롤되어 최대한 많이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="43cba2c07e1fd54805178ce5d941c420ce760ec6" translate="yes" xml:space="preserve">
          <source>In cases where the favorites plugin does not support matching by alternative identifiers, then the &lt;a href=&quot;qtlocation-index#plugin-references-and-parameters&quot;&gt;plugin documentation&lt;/a&gt; should be consulted to see precisely what key-value parameters to set.</source>
          <target state="translated">즐겨 찾기 플러그인이 대체 식별자에 의한 일치를 지원하지 않는 경우 설정할 키-값 매개 변수를 정확하게 보려면 &lt;a href=&quot;qtlocation-index#plugin-references-and-parameters&quot;&gt;플러그인 문서&lt;/a&gt; 를 참조해야합니다.</target>
        </trans-unit>
        <trans-unit id="5e2f28ed2f5a200d6ff44885dfa169512b420d25" translate="yes" xml:space="preserve">
          <source>In cases where this is not enough, Qt provides access to the delivery of the native events. A global event filter that receives all native events can be installed by using &lt;a href=&quot;qcoreapplication#installNativeEventFilter&quot;&gt;QCoreApplication::installNativeEventFilter&lt;/a&gt;(), while per-window native events can be handled in &lt;a href=&quot;qwindow#nativeEvent&quot;&gt;QWindow::nativeEvent&lt;/a&gt;().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6d71b24ddb6aa8ada2ae25e34032ae1809be895" translate="yes" xml:space="preserve">
          <source>In certain cases the parent layout is put into QLayout::FreeResize mode, meaning that it will not adapt the layout of its contents to fit inside small sized windows, or even prevent the user from making the window too small to be usable. This can be overcome by subclassing the problematic widgets, and implementing suitable &lt;a href=&quot;qwidget#sizeHint-prop&quot;&gt;sizeHint()&lt;/a&gt; and &lt;a href=&quot;qwidget#minimumSizeHint-prop&quot;&gt;minimumSizeHint()&lt;/a&gt; functions.</source>
          <target state="translated">경우에 따라 부모 레이아웃이 QLayout :: FreeResize 모드로 설정됩니다. 즉, 작은 크기의 창에 맞도록 내용의 레이아웃을 조정하지 못하거나 사용자가 창을 너무 작게 사용하지 못하게 할 수도 없습니다. 문제가되는 위젯을 서브 클래 싱하고 적절한 &lt;a href=&quot;qwidget#sizeHint-prop&quot;&gt;sizeHint ()&lt;/a&gt; 및 &lt;a href=&quot;qwidget#minimumSizeHint-prop&quot;&gt;minimumSizeHint ()&lt;/a&gt; 함수를 구현하면이 문제를 해결할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="53994a9c8298728d70b4eada69cf0a9d3d9765fe" translate="yes" xml:space="preserve">
          <source>In certain scenarios, &lt;a href=&quot;qregexp&quot;&gt;QRegExp&lt;/a&gt; was too lenient and accepted patterns that are simply invalid when using QRegularExpression. These are somehow easy to detect, because the QRegularExpression objects built with these patterns are not valid (cf. &lt;a href=&quot;qregularexpression#isValid&quot;&gt;isValid&lt;/a&gt;()).</source>
          <target state="translated">특정 시나리오에서 &lt;a href=&quot;qregexp&quot;&gt;QRegExp&lt;/a&gt; 는 QRegularExpression 을 사용할 때 단순히 유효하지 않은 너무 관대하고 허용 된 패턴이었습니다. 이러한 패턴으로 빌드 된 QRegularExpression 객체는 유효하지 않기 때문에 쉽게 감지 할 수 있습니다 ( &lt;a href=&quot;qregularexpression#isValid&quot;&gt;isValid&lt;/a&gt; () 참조 ).</target>
        </trans-unit>
        <trans-unit id="5e4ed90a8e7487cd6c9be47ef1c07b2ab9c58711" translate="yes" xml:space="preserve">
          <source>In certain scenarios, QRegExp was too lenient and accepted patterns that are simply invalid when using &lt;a href=&quot;qtcore-changes-qt6#qregularexpression&quot;&gt;QRegularExpression&lt;/a&gt;. These are somehow easy to detect, because the &lt;a href=&quot;qtcore-changes-qt6#qregularexpression&quot;&gt;QRegularExpression&lt;/a&gt; objects built with these patterns are not valid (cf. &lt;a href=&quot;qregularexpression#isValid&quot;&gt;QRegularExpression::isValid&lt;/a&gt;()).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a41b4ac3933eda1476b14382ed0a1006fe9f565d" translate="yes" xml:space="preserve">
          <source>In charge of dispatching keyboard events to attached QQKeyboardHandler objects</source>
          <target state="translated">첨부 된 QQKeyboardHandler 오브젝트에 키보드 이벤트 디스패치 담당</target>
        </trans-unit>
        <trans-unit id="62594d9650efc77f9adb66b52aa57691e8a522f0" translate="yes" xml:space="preserve">
          <source>In class &lt;code&gt;Employee&lt;/code&gt;, note the single data member, a</source>
          <target state="translated">&lt;code&gt;Employee&lt;/code&gt; 클래스 에서 단일 데이터 멤버 인</target>
        </trans-unit>
        <trans-unit id="b45d35c7c4a845cb78c51a71a5fffbaf1765a2e0" translate="yes" xml:space="preserve">
          <source>In classic CSS, when font and color of an item is not explicitly set, it gets automatically inherited from the parent. By default, when using Qt Style Sheets, a widget does &lt;b&gt;not&lt;/b&gt; automatically inherit its font and color setting from its parent widget.</source>
          <target state="translated">기본 CSS에서 항목의 글꼴과 색상이 명시 적으로 설정되지 않으면 상위 항목에서 자동으로 상속됩니다. 기본적으로 Qt 스타일 시트를 사용할 때 위젯은 상위 위젯에서 글꼴 및 색상 설정을 자동으로 상속 하지 &lt;b&gt;않습니다&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="5e29793c801fa55b34ee41a3ad89961ce0d845a4" translate="yes" xml:space="preserve">
          <source>In complex wizards, pages are identified by IDs. These IDs are typically defined using an enum. For example:</source>
          <target state="translated">복잡한 마법사에서 페이지는 ID로 식별됩니다. 이 ID는 일반적으로 열거 형을 사용하여 정의됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="231ad4b10b376ab7dd4b4161d3aff190a50bf442" translate="yes" xml:space="preserve">
          <source>In contrast to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2aac7d402261de7266f7684761e23369ae2b9abf" translate="yes" xml:space="preserve">
          <source>In contrast to &lt;a href=&quot;#translations&quot;&gt;TRANSLATIONS&lt;/a&gt;, translation files in &lt;code&gt;EXTRA_TRANSLATIONS&lt;/code&gt; will be processed only by &lt;a href=&quot;https://doc.qt.io/qt-5.13/linguist-manager.html#using-lrelease&quot;&gt;lrelease&lt;/a&gt;, not &lt;a href=&quot;https://doc.qt.io/qt-5.13/linguist-manager.html#using-lupdate&quot;&gt;lupdate&lt;/a&gt;.</source>
          <target state="translated">대조적 &lt;a href=&quot;#translations&quot;&gt;번역본&lt;/a&gt; , 번역 파일 &lt;code&gt;EXTRA_TRANSLATIONS&lt;/code&gt; 는 의해서만 처리 될 &lt;a href=&quot;https://doc.qt.io/qt-5.13/linguist-manager.html#using-lrelease&quot;&gt;lrelease&lt;/a&gt; 하지 &lt;a href=&quot;https://doc.qt.io/qt-5.13/linguist-manager.html#using-lupdate&quot;&gt;lupdate&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e2a196eafe5fec635b2bbdc654a994018eadbf5d" translate="yes" xml:space="preserve">
          <source>In contrast to &lt;a href=&quot;qfileinfo#canonicalPath&quot;&gt;canonicalPath&lt;/a&gt;() symbolic links or redundant &quot;.&quot; or &quot;..&quot; elements are not necessarily removed.</source>
          <target state="translated">&lt;a href=&quot;qfileinfo#canonicalPath&quot;&gt;canonicalPath&lt;/a&gt; () 기호 링크 또는 중복 &quot;.&quot; 과 달리 또는 &quot;..&quot;요소가 반드시 제거되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="d4d4f542dc4b15b17617ba7302c0f4de2245d7b1" translate="yes" xml:space="preserve">
          <source>In contrast to &lt;a href=&quot;qfileinfo#isSymLink&quot;&gt;isSymLink&lt;/a&gt;(), false will be returned for shortcuts (&lt;code&gt;*.lnk&lt;/code&gt; files) on Windows. Use &lt;a href=&quot;qfileinfo#isShortcut&quot;&gt;QFileInfo::isShortcut&lt;/a&gt;() instead.</source>
          <target state="translated">&lt;a href=&quot;qfileinfo#isSymLink&quot;&gt;isSymLink&lt;/a&gt; () 와 달리 Windows 에서는 바로 가기 ( &lt;code&gt;*.lnk&lt;/code&gt; 파일)에 대해 false가 반환됩니다 . 사용 &lt;a href=&quot;qfileinfo#isShortcut&quot;&gt;QFileInfo :: isShortcut&lt;/a&gt; () 대신.</target>
        </trans-unit>
        <trans-unit id="7b00dedbb27975a52293f7f2888b30c2a7fdf0e1" translate="yes" xml:space="preserve">
          <source>In contrast to &lt;a href=&quot;qmake-variable-reference#translations&quot;&gt;TRANSLATIONS&lt;/a&gt;, translation files in &lt;code&gt;EXTRA_TRANSLATIONS&lt;/code&gt; will be processed only by &lt;a href=&quot;https://doc.qt.io/qt-5.15/linguist-manager.html#using-lrelease&quot;&gt;lrelease&lt;/a&gt;, not &lt;a href=&quot;https://doc.qt.io/qt-5.15/linguist-manager.html#using-lupdate&quot;&gt;lupdate&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qmake-variable-reference#translations&quot;&gt;TRANSLATIONS&lt;/a&gt; 와 달리 &lt;code&gt;EXTRA_TRANSLATIONS&lt;/code&gt; 의 번역 파일은 lupdate 가 아닌 &lt;a href=&quot;https://doc.qt.io/qt-5.15/linguist-manager.html#using-lupdate&quot;&gt;lrelease&lt;/a&gt; 에 &lt;a href=&quot;https://doc.qt.io/qt-5.15/linguist-manager.html#using-lrelease&quot;&gt;의해서만&lt;/a&gt; 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="618de9361835eece5e572eaed710bb3d6060cd4e" translate="yes" xml:space="preserve">
          <source>In contrast to &lt;a href=&quot;qmake-variable-reference#translations&quot;&gt;TRANSLATIONS&lt;/a&gt;, translation files in &lt;code&gt;EXTRA_TRANSLATIONS&lt;/code&gt; will be processed only by &lt;a href=&quot;https://doc.qt.io/qt-6.0/linguist-manager.html#using-lrelease&quot;&gt;lrelease&lt;/a&gt;, not &lt;a href=&quot;https://doc.qt.io/qt-6.0/linguist-manager.html#using-lupdate&quot;&gt;lupdate&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40a9fa83d5c4840547d5095aa74f02059ad912f6" translate="yes" xml:space="preserve">
          <source>In contrast to &lt;a href=&quot;qtimeline#start&quot;&gt;start&lt;/a&gt;(), this function does not restart the timeline before it resumes.</source>
          <target state="translated">콘트라스트에 &lt;a href=&quot;qtimeline#start&quot;&gt;시작&lt;/a&gt; ) (이 다시 시작되기 전에,이 기능은 타임 라인을 재시작하지 않는다.</target>
        </trans-unit>
        <trans-unit id="fb7097e105e1037d49889af33e5f80c02e2bd8d7" translate="yes" xml:space="preserve">
          <source>In contrast to event specifications in SCXML documents, spaces are not allowed in the</source>
          <target state="translated">SCXML 문서의 이벤트 사양과 달리 공백은 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4a772d6172888ba23751f095769c3d0f199153a2" translate="yes" xml:space="preserve">
          <source>In contrast to most other layouts, child Items' &lt;a href=&quot;qml-qtquick-layouts-layout#fillWidth-attached-prop&quot;&gt;Layout.fillWidth&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-layouts-layout#fillHeight-attached-prop&quot;&gt;Layout.fillHeight&lt;/a&gt; properties default to &lt;code&gt;true&lt;/code&gt;. As a consequence, child items are by default filled to match the size of the &lt;a href=&quot;qml-qtquick-layouts-stacklayout&quot;&gt;StackLayout&lt;/a&gt; as long as their &lt;a href=&quot;qml-qtquick-layouts-layout#maximumWidth-attached-prop&quot;&gt;Layout.maximumWidth&lt;/a&gt; or &lt;a href=&quot;qml-qtquick-layouts-layout#maximumHeight-attached-prop&quot;&gt;Layout.maximumHeight&lt;/a&gt; does not prevent it.</source>
          <target state="translated">대부분의 다른 레이아웃과 달리 자식 항목의 &lt;a href=&quot;qml-qtquick-layouts-layout#fillWidth-attached-prop&quot;&gt;Layout.fillWidth&lt;/a&gt; 및 &lt;a href=&quot;qml-qtquick-layouts-layout#fillHeight-attached-prop&quot;&gt;Layout.fillHeight&lt;/a&gt; 속성은 기본적으로 &lt;code&gt;true&lt;/code&gt; 입니다. 결과적으로 &lt;a href=&quot;qml-qtquick-layouts-layout#maximumWidth-attached-prop&quot;&gt;Layout.maximumWidth&lt;/a&gt; 또는 &lt;a href=&quot;qml-qtquick-layouts-layout#maximumHeight-attached-prop&quot;&gt;Layout.maximumHeight &lt;/a&gt;&lt;a href=&quot;qml-qtquick-layouts-stacklayout&quot;&gt;가이&lt;/a&gt; 를 방지하지 않는 한 하위 항목은 기본적으로 StackLayout 의 크기와 일치하도록 채워 집니다.</target>
        </trans-unit>
        <trans-unit id="0ec20c859cd3420b2a4413d164250f026415f0bc" translate="yes" xml:space="preserve">
          <source>In contrast to most other layouts, child Items' &lt;a href=&quot;qml-qtquick-layouts-layout#fillWidth-attached-prop&quot;&gt;Layout.fillWidth&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-layouts-layout#fillHeight-attached-prop&quot;&gt;Layout.fillHeight&lt;/a&gt; properties default to &lt;code&gt;true&lt;/code&gt;. As a consequence, child items are by default filled to match the size of the StackLayout as long as their &lt;a href=&quot;qml-qtquick-layouts-layout#maximumWidth-attached-prop&quot;&gt;Layout.maximumWidth&lt;/a&gt; or &lt;a href=&quot;qml-qtquick-layouts-layout#maximumHeight-attached-prop&quot;&gt;Layout.maximumHeight&lt;/a&gt; does not prevent it.</source>
          <target state="translated">대부분의 다른 레이아웃과 달리 자식 Items의 &lt;a href=&quot;qml-qtquick-layouts-layout#fillWidth-attached-prop&quot;&gt;Layout.fillWidth&lt;/a&gt; 및 &lt;a href=&quot;qml-qtquick-layouts-layout#fillHeight-attached-prop&quot;&gt;Layout.fillHeight&lt;/a&gt; 속성은 기본적으로 &lt;code&gt;true&lt;/code&gt; 로 설정됩니다 . 결과적으로 &lt;a href=&quot;qml-qtquick-layouts-layout#maximumWidth-attached-prop&quot;&gt;Layout.maximumWidth&lt;/a&gt; 또는 &lt;a href=&quot;qml-qtquick-layouts-layout#maximumHeight-attached-prop&quot;&gt;Layout.maximumHeight&lt;/a&gt; 가이를 방지하지 않는 한 하위 항목은 기본적으로 StackLayout의 크기와 일치하도록 채워 집니다.</target>
        </trans-unit>
        <trans-unit id="221c871c00778299b08348aca174c31cdde4ac9e" translate="yes" xml:space="preserve">
          <source>In contrast, datagram mode is message-oriented and provides a complete simultaneous transmission of multiple data streams between endpoints. Call &lt;a href=&quot;qsctpserver#nextPendingDatagramConnection&quot;&gt;nextPendingDatagramConnection&lt;/a&gt;() to accept the pending datagram-mode connection as a connected &lt;a href=&quot;qsctpsocket&quot;&gt;QSctpSocket&lt;/a&gt;.</source>
          <target state="translated">반대로, 데이터 그램 모드는 메시지 지향적이며 엔드 포인트간에 여러 데이터 스트림을 완벽하게 동시에 전송합니다. 보류중인 데이터 그램 모드 연결을 연결된 &lt;a href=&quot;qsctpsocket&quot;&gt;QSctpSocket&lt;/a&gt; 으로 승인하려면 &lt;a href=&quot;qsctpserver#nextPendingDatagramConnection&quot;&gt;nextPendingDatagramConnection&lt;/a&gt; ()을 호출 하십시오 .</target>
        </trans-unit>
        <trans-unit id="6e787bef3e57569e1b4e97caaf24bc5f7bf4106d" translate="yes" xml:space="preserve">
          <source>In contrast, functor-based connections are checked by the compiler. The compiler catches errors at compile-time, enables implicit conversions between compatible types, and recognizes different names of the same type.</source>
          <target state="translated">반대로 functor 기반 연결은 컴파일러에서 확인합니다. 컴파일러는 컴파일 타임에 오류를 포착하고 호환 가능한 유형 간 암시 적 변환을 가능하게하며 동일한 유형의 다른 이름을 인식합니다.</target>
        </trans-unit>
        <trans-unit id="f38ef06a2c4def729d64a10c8350bfda693b07db" translate="yes" xml:space="preserve">
          <source>In contrast, properties of an &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtqml-typesystem-topic.html#qml-object-types&quot;&gt;object type&lt;/a&gt; emit their own property change signals, and a property change signal handler for an object-type property is only invoked when the property is reassigned to a different object value.</source>
          <target state="translated">반대로, &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtqml-typesystem-topic.html#qml-object-types&quot;&gt;객체 유형&lt;/a&gt; 의 속성은 자체 속성 변경 신호를 방출하며 , 객체 유형 속성에 대한 속성 변경 신호 핸들러는 속성이 다른 객체 값으로 재 할당 될 때만 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="657c9918ecd776a1aafb08d2b614c01eae78c6f6" translate="yes" xml:space="preserve">
          <source>In contrast, properties of an &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtqml-typesystem-topic.html#qml-object-types&quot;&gt;object type&lt;/a&gt; emit their own property change signals, and a property change signal handler for an object-type property is only invoked when the property is reassigned to a different object value.</source>
          <target state="translated">반대로 &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtqml-typesystem-topic.html#qml-object-types&quot;&gt;객체 유형&lt;/a&gt; 의 속성은 고유 한 속성 변경 신호를 내 보냅니다. 객체 유형 속성에 대한 속성 변경 신호 처리기는 속성이 다른 객체 값에 다시 할당 될 때만 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="73d37f657dea8be040584e138b1df81404e68eae" translate="yes" xml:space="preserve">
          <source>In contrast, properties of an &lt;a href=&quot;https://doc.qt.io/qt-6.0/qtqml-typesystem-topic.html#qml-object-types&quot;&gt;object type&lt;/a&gt; emit their own property change signals, and a property change signal handler for an object-type property is only invoked when the property is reassigned to a different object value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14d70c8987f7df0bae4a098c83c6017992fe13ed" translate="yes" xml:space="preserve">
          <source>In contrast, setting a font and palette using &lt;a href=&quot;qwidget#font-prop&quot;&gt;QWidget::setFont&lt;/a&gt;() and &lt;a href=&quot;qwidget#palette-prop&quot;&gt;QWidget::setPalette&lt;/a&gt;() propagates to child widgets.</source>
          <target state="translated">반대로 &lt;a href=&quot;qwidget#font-prop&quot;&gt;QWidget :: setFont&lt;/a&gt; () 및 &lt;a href=&quot;qwidget#palette-prop&quot;&gt;QWidget :: setPalette&lt;/a&gt; ()를 사용하여 글꼴 및 팔레트를 설정하면 하위 위젯으로 전파됩니다.</target>
        </trans-unit>
        <trans-unit id="7f1fc3d94746b812dc1a973c5e2550874e4f1cf6" translate="yes" xml:space="preserve">
          <source>In contrast, with the functor-based syntax, an overloaded signal or slot must be casted to tell the compiler which instance to use.</source>
          <target state="translated">반대로 functor 기반 구문에서는 컴파일러에게 사용할 인스턴스를 알리기 위해 오버로드 된 신호 또는 슬롯을 캐스트해야합니다.</target>
        </trans-unit>
        <trans-unit id="47704f927094ac2336750dc0c531d2e3723bd0c2" translate="yes" xml:space="preserve">
          <source>In datagram mode, &lt;a href=&quot;qsctpsocket&quot;&gt;QSctpSocket&lt;/a&gt; performs the buffering of datagrams independently for each channel. You can queue a datagram to the buffer of the current channel by calling &lt;a href=&quot;qsctpsocket#writeDatagram&quot;&gt;writeDatagram&lt;/a&gt;() and read a pending datagram by calling &lt;a href=&quot;qsctpsocket#readDatagram&quot;&gt;readDatagram&lt;/a&gt;() respectively.</source>
          <target state="translated">데이터 그램 모드에서 &lt;a href=&quot;qsctpsocket&quot;&gt;QSctpSocket&lt;/a&gt; 은 각 채널에 대해 독립적으로 데이터 그램 버퍼링을 수행합니다. &lt;a href=&quot;qsctpsocket#writeDatagram&quot;&gt;writeDatagram&lt;/a&gt; () 을 호출하여 데이터 그램을 현재 채널의 버퍼에 대기시키고 &lt;a href=&quot;qsctpsocket#readDatagram&quot;&gt;readDatagram&lt;/a&gt; ()을 각각 호출하여 보류중인 데이터 그램을 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e90047f588e8a9c66ec5b2323534c12ac24c09f0" translate="yes" xml:space="preserve">
          <source>In datagram mode, QSctpSocket performs the buffering of datagrams independently for each channel. You can queue a datagram to the buffer of the current channel by calling &lt;a href=&quot;qsctpsocket#writeDatagram&quot;&gt;writeDatagram&lt;/a&gt;() and read a pending datagram by calling &lt;a href=&quot;qsctpsocket#readDatagram&quot;&gt;readDatagram&lt;/a&gt;() respectively.</source>
          <target state="translated">데이터 그램 모드에서 QSctpSocket은 각 채널에 대해 독립적으로 데이터 그램 버퍼링을 수행합니다. &lt;a href=&quot;qsctpsocket#writeDatagram&quot;&gt;writeDatagram&lt;/a&gt; () 을 호출하여 현재 채널의 버퍼에 데이터 그램을 대기열에 넣고 각각 &lt;a href=&quot;qsctpsocket#readDatagram&quot;&gt;readDatagram&lt;/a&gt; () 을 호출하여 보류중인 데이터 그램을 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="07e42511b7abf9bb54e833603926aeb7b222def2" translate="yes" xml:space="preserve">
          <source>In debug builds the condition is enforced by an assert to facilitate debugging.</source>
          <target state="translated">디버그 빌드에서 디버깅을 용이하게하기 위해 어설트가 조건을 시행합니다.</target>
        </trans-unit>
        <trans-unit id="b71abd6efd254a650af3c09142186b5133ce0d87" translate="yes" xml:space="preserve">
          <source>In edit mode, press</source>
          <target state="translated">편집 모드에서</target>
        </trans-unit>
        <trans-unit id="25b9da12cb823d2c1d6a5223dbf28325a3d8baa6" translate="yes" xml:space="preserve">
          <source>In edit mode, select the desired faces. (</source>
          <target state="translated">편집 모드에서 원하는 얼굴을 선택합니다. (</target>
        </trans-unit>
        <trans-unit id="27ca71f516af27079bf83c99568901eec725fb82" translate="yes" xml:space="preserve">
          <source>In editable models, this opens the current item for editing. The Escape key can be used to cancel the editing process and revert any changes to the data displayed.</source>
          <target state="translated">편집 가능한 모델에서는 편집 할 현재 항목이 열립니다. Esc 키를 사용하여 편집 프로세스를 취소하고 표시된 데이터의 변경 사항을 되돌릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="25d14e1ec2b5b306276db7124338a02023a6c82e" translate="yes" xml:space="preserve">
          <source>In effect, when a command is pushed, it becomes the top-most command on the stack.</source>
          <target state="translated">실제로 명령을 누르면 스택에서 최상위 명령이됩니다.</target>
        </trans-unit>
        <trans-unit id="767704cb9fd04546381b49fcfd02b90d83e7c7cb" translate="yes" xml:space="preserve">
          <source>In either case, the value may be either a</source>
          <target state="translated">두 경우 모두 값은 다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5771972b8071936a553417ed46282eae06dbd5e" translate="yes" xml:space="preserve">
          <source>In fact, any JavaScript expression (no matter how complex) may be used in a property binding definition, as long as the result of the expression is a value whose type can be assigned to the property. This includes side effects. However, complex bindings and side effects are discouraged because they can reduce the performance, readability, and maintainability of the code.</source>
          <target state="translated">실제로 표현식의 결과가 유형을 특성에 지정할 수있는 값인 경우 JavaScript 바인딩은 아무리 복잡하더라도 특성 바인딩 정의에 사용될 수 있습니다. 여기에는 부작용이 포함됩니다. 그러나 복잡한 바인딩 및 부작용은 코드의 성능, 가독성 및 유지 관리 성을 저하시킬 수 있으므로 권장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="20030dd4b75e22ef5740f4e7e8489490113c4e84" translate="yes" xml:space="preserve">
          <source>In full, the RenderViews created are:</source>
          <target state="translated">생성 된 RenderView는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bb19f0f7570b0febe9bc2b6bebf1e844928a04ec" translate="yes" xml:space="preserve">
          <source>In fullscreen mode, the virtual keyboard replicates the contents of the focused input field to the fullscreen input field located at the top of the keyboard.</source>
          <target state="translated">전체 화면 모드에서 가상 키보드는 포커스가있는 입력 필드의 내용을 키보드 상단에있는 전체 화면 입력 필드로 복제합니다.</target>
        </trans-unit>
        <trans-unit id="2d5906462ad37b4fc10efbd813a86f2cafbda7f2" translate="yes" xml:space="preserve">
          <source>In general a document structuring command considers everything that follows it until the first line break as its argument. The argument is rendered as the unit's title. If the title needs to be spanned over several lines, make sure that each line (except the last one) is ended with a backslash.</source>
          <target state="translated">일반적으로 문서 구조 명령은 첫 번째 줄 바꿈까지 인수 뒤에 오는 모든 것을 고려합니다. 인수는 단위 제목으로 렌더링됩니다. 제목을 여러 줄로 확장해야하는 경우 각 줄 (마지막 줄 제외)은 백 슬래시로 끝나야합니다.</target>
        </trans-unit>
        <trans-unit id="167a7ef27ae33540c81ee2290a8d3d775d231aad" translate="yes" xml:space="preserve">
          <source>In general an enabled widget handles keyboard and mouse events; a disabled widget does not. An exception is made with &lt;a href=&quot;qabstractbutton&quot;&gt;QAbstractButton&lt;/a&gt;.</source>
          <target state="translated">일반적으로 활성화 된 위젯은 키보드 및 마우스 이벤트를 처리합니다. 비활성화 된 위젯은 그렇지 않습니다. &lt;a href=&quot;qabstractbutton&quot;&gt;QAbstractButton&lt;/a&gt; 은 예외입니다 .</target>
        </trans-unit>
        <trans-unit id="d021729bebd5b79255de19024fac6ea9df2157a6" translate="yes" xml:space="preserve">
          <source>In general an enabled widget handles keyboard and mouse events; a disabled widget does not. An exception is made with &lt;a href=&quot;widgets-changes-qt6#qabstractbutton&quot;&gt;QAbstractButton&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cc625bb55279831e729a96b7ba93ed54e0b4b61" translate="yes" xml:space="preserve">
          <source>In general returns the modal dialog's result code, &lt;code&gt;Accepted&lt;/code&gt; or &lt;code&gt;Rejected&lt;/code&gt;.</source>
          <target state="translated">일반적으로 모달 대화 상자의 결과 코드 인 &lt;code&gt;Accepted&lt;/code&gt; 또는 &lt;code&gt;Rejected&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="e9fd7bb71f823cf713a3ecec34253b92dc6cbfcf" translate="yes" xml:space="preserve">
          <source>In general there are two steps to completing an in-app purchase using the API:</source>
          <target state="translated">일반적으로 API를 사용하여 인앱 구매를 완료하는 두 단계가 있습니다.</target>
        </trans-unit>
        <trans-unit id="30673a5ebb6575bf00ffabd14fa8a0d19b73bc55" translate="yes" xml:space="preserve">
          <source>In general we can implement a default event handler by double clicking on the widget in the form, but the default events for our widgets are right now not defined.</source>
          <target state="translated">일반적으로 폼에서 위젯을 두 번 클릭하여 기본 이벤트 핸들러를 구현할 수 있지만 위젯의 기본 이벤트는 현재 정의되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fc58706396cf19f31560982fb0e3ab7ba9781ad7" translate="yes" xml:space="preserve">
          <source>In general you should use one of the predefined action names, unless describing an action that does not fit these:</source>
          <target state="translated">일반적으로 다음에 맞지 않는 동작을 설명하지 않는 한 미리 정의 된 동작 이름 중 하나를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="7d8cf290113d81f0cede60c757cf3b594dd8539e" translate="yes" xml:space="preserve">
          <source>In general, QDoc will generate &quot;See also&quot; links that interconnect the functions that access the same property. It recognizes four different syntax versions:</source>
          <target state="translated">일반적으로 QDoc은 동일한 속성에 액세스하는 기능을 상호 연결하는 &quot;참조&quot;링크를 생성합니다. 다음 네 가지 구문 버전을 인식합니다.</target>
        </trans-unit>
        <trans-unit id="94ffe95519cbb62c5b86a0ab65f4b339f724b6c1" translate="yes" xml:space="preserve">
          <source>In general, a title command considers everything that follows it until the first line break as its argument. If the title is so long it must span multiple lines, end each line (except the last one) with a backslash.</source>
          <target state="translated">일반적으로 제목 명령은 첫 번째 줄 바꿈까지 그 다음에 오는 모든 것을 인수로 간주합니다. 제목이 너무 길면 여러 줄에 걸쳐 있어야하며 각 줄 (마지막 줄 제외)은 백 슬래시로 끝납니다.</target>
        </trans-unit>
        <trans-unit id="98dd314277e1d0ada247bc3c672aabba6543f947" translate="yes" xml:space="preserve">
          <source>In general, an address is suitable for publication if it is an address this machine will be reached at for an indeterminate amount of time, though it need not be permanent. For example, addresses obtained via DHCP are often eligible, but cryptographically-generated temporary IPv6 addresses are not.</source>
          <target state="translated">일반적으로 주소가 영구적이지 않아도이 기계에 도달 할 수없는 주소 인 경우 주소가 공개에 적합합니다. 예를 들어 DHCP를 통해 얻은 주소는 적격이지만 암호화로 생성 된 임시 IPv6 주소는 적합하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="55acea3c2eb5e73edd7468a7a4dafb1085d723ed" translate="yes" xml:space="preserve">
          <source>In general, animating a property will cause any bindings which reference that property to be re-evaluated. Usually, this is what is desired but in other cases it may be better to disable the binding prior to performing the animation, and then reassign the binding once the animation has completed.</source>
          <target state="translated">일반적으로 속성에 애니메이션을 적용하면 해당 속성을 참조하는 바인딩이 다시 평가됩니다. 일반적으로 이것은 원하는 것이지만 다른 경우에는 애니메이션을 수행하기 전에 바인딩을 비활성화 한 다음 애니메이션이 완료되면 바인딩을 다시 할당하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="d50f64d09939ac18488580b2d7a1face739cfb64" translate="yes" xml:space="preserve">
          <source>In general, creating QObjects before the &lt;a href=&quot;qapplication&quot;&gt;QApplication&lt;/a&gt; is not supported and can lead to weird crashes on exit, depending on the platform. This means static instances of &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; are also not supported. A properly structured single or multi-threaded application should make the &lt;a href=&quot;qapplication&quot;&gt;QApplication&lt;/a&gt; be the first created, and last destroyed &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;.</source>
          <target state="translated">일반적으로 &lt;a href=&quot;qapplication&quot;&gt;QApplication&lt;/a&gt; 전에 QObject를 생성하는 것은 지원되지 않으며 플랫폼에 따라 종료시 이상한 충돌을 일으킬 수 있습니다. 이는 &lt;a href=&quot;qobject&quot;&gt;QObject의&lt;/a&gt; 정적 인스턴스 도 지원되지 않음을 의미 합니다. 올바르게 구조화 된 단일 또는 다중 스레드 응용 프로그램은 &lt;a href=&quot;qapplication&quot;&gt;QApplication을&lt;/a&gt; 처음 생성하고 마지막으로 파괴 한 &lt;a href=&quot;qobject&quot;&gt;QObject로&lt;/a&gt; 만들어야 합니다 .</target>
        </trans-unit>
        <trans-unit id="3163ba6967198fa96a626de9bd8f394ad413b305" translate="yes" xml:space="preserve">
          <source>In general, events come from the underlying window system (&lt;a href=&quot;qevent#spontaneous&quot;&gt;spontaneous&lt;/a&gt;() returns &lt;code&gt;true&lt;/code&gt;), but it is also possible to manually send events using &lt;a href=&quot;qcoreapplication#sendEvent&quot;&gt;QCoreApplication::sendEvent&lt;/a&gt;() and &lt;a href=&quot;qcoreapplication#postEvent&quot;&gt;QCoreApplication::postEvent&lt;/a&gt;() (&lt;a href=&quot;qevent#spontaneous&quot;&gt;spontaneous&lt;/a&gt;() returns &lt;code&gt;false&lt;/code&gt;).</source>
          <target state="translated">일반적으로 이벤트는 기본 윈도우 시스템 에서 발생하지만 ( &lt;a href=&quot;qevent#spontaneous&quot;&gt;spontaneous&lt;/a&gt; ()는 &lt;code&gt;true&lt;/code&gt; 를 리턴 함 ) &lt;a href=&quot;qcoreapplication#sendEvent&quot;&gt;QCoreApplication :: sendEvent&lt;/a&gt; () 및 &lt;a href=&quot;qcoreapplication#postEvent&quot;&gt;QCoreApplication :: postEvent&lt;/a&gt; ()를 사용하여 수동으로 이벤트를 송신 할 수도 있습니다 ( &lt;a href=&quot;qevent#spontaneous&quot;&gt;spontaneous&lt;/a&gt; ()는 &lt;code&gt;false&lt;/code&gt; 를 리턴 함 ).</target>
        </trans-unit>
        <trans-unit id="7e1849f84d16bd0766ea8eb662b93a02850cb20f" translate="yes" xml:space="preserve">
          <source>In general, every Qt code entity such as properties, classes, methods, signals, and enumerations have a corresponding &lt;a href=&quot;qdoc-guide-writing#qdoc-topics&quot;&gt;topic command&lt;/a&gt;. QDoc will associate the documentation to the source using C++ naming rules.</source>
          <target state="translated">일반적으로 속성, 클래스, 메서드, 신호 및 열거와 같은 모든 Qt 코드 엔터티에는 해당하는 &lt;a href=&quot;qdoc-guide-writing#qdoc-topics&quot;&gt;주제 명령이&lt;/a&gt; 있습니다. QDoc은 C ++ 이름 지정 규칙을 사용하여 문서를 소스에 연관시킵니다.</target>
        </trans-unit>
        <trans-unit id="2517cd279222c6f9d8801a3f3219d6fbf5a2de96" translate="yes" xml:space="preserve">
          <source>In general, for visualizing key focus, this property is preferred over &lt;a href=&quot;qml-qtquick-item#activeFocus-prop&quot;&gt;Item::activeFocus&lt;/a&gt;. This ensures that key focus is only visualized when interacting with keys - not when interacting via touch or mouse.</source>
          <target state="translated">일반적으로 키 포커스를 시각화하려면이 속성이 &lt;a href=&quot;qml-qtquick-item#activeFocus-prop&quot;&gt;Item :: activeFocus&lt;/a&gt; 보다 선호 됩니다. 이를 통해 터치 또는 마우스를 통해 상호 작용할 때가 아니라 키와 상호 작용할 때만 키 포커스를 시각화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3cfd9239afb114e51ac0078b1b52a454c1bd0350" translate="yes" xml:space="preserve">
          <source>In general, it is recommended that you are somewhat familiar with MSAA, which Qt's accessibility support originally was built for. You should also study the enum values of &lt;a href=&quot;qaccessible&quot;&gt;QAccessible&lt;/a&gt;, which describe the roles, actions, relationships, and events that you need to consider.</source>
          <target state="translated">일반적으로 Qt의 내게 필요한 옵션 지원은 원래 작성된 MSAA에 어느 정도 익숙한 것이 좋습니다. 또한 &lt;a href=&quot;qaccessible&quot;&gt;고려해야&lt;/a&gt; 할 역할, 조치, 관계 및 이벤트를 설명하는 QAccessible 의 열거 형 값을 연구 해야합니다.</target>
        </trans-unit>
        <trans-unit id="2692f7b2cb6d6d341ef938261c6eb784c6d5859b" translate="yes" xml:space="preserve">
          <source>In general, large and complex Map items such as polygons and polylines with large numbers of vertices can have an adverse effect on UI performance. Further, more detailed notes on this are in the documentation for each map item type.</source>
          <target state="translated">일반적으로 정점이 많은 다각형 및 폴리 라인과 같이 크고 복잡한 맵 항목은 UI 성능에 부정적인 영향을 줄 수 있습니다. 또한 이에 대한 자세한 내용은 각지도 항목 유형의 설명서에 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d4535d3c722b8e58e4d5f10e8bfeafccedbf548" translate="yes" xml:space="preserve">
          <source>In general, sensor data is oriented relative to &lt;a href=&quot;qplatformscreen#nativeOrientation&quot;&gt;QPlatformScreen::nativeOrientation&lt;/a&gt;, that is to the top of the device when the device is held in its natural orientation (normally when the device logo appears the right side up). If values are to be displayed on the screen, the values may need to be transformed so that they match the user interface orientation. A sensor may define its data as being oriented to the UI. This will be noted in the documentation for the sensor.</source>
          <target state="translated">일반적으로 센서 데이터는 &lt;a href=&quot;qplatformscreen#nativeOrientation&quot;&gt;QPlatformScreen :: nativeOrientation을&lt;/a&gt; 기준으로합니다. 즉 , 기기가 자연적인 방향으로 고정되어있을 때 (일반적으로 기기 로고가 오른쪽에 표시 될 때) 기기 상단에 있습니다. 화면에 값을 표시하려면 사용자 인터페이스 방향과 일치하도록 값을 변환해야합니다. 센서는 데이터가 UI를 지향하는 것으로 정의 할 수 있습니다. 이 내용은 센서 설명서에 나와 있습니다.</target>
        </trans-unit>
        <trans-unit id="761d50d515b1823ae30af6b7a8144a8ab3eaa504" translate="yes" xml:space="preserve">
          <source>In general, sensor data is oriented relative to &lt;a href=&quot;qscreen#nativeOrientation-prop&quot;&gt;QScreen::nativeOrientation&lt;/a&gt;, that is to the top of the device when the device is held in its natural orientation (normally when the device logo appears the right side up). If values are to be displayed on the screen, the values may need to be transformed so that they match the user interface orientation. A sensor may define its data as being oriented to the UI. This will be noted in the documentation for the sensor.</source>
          <target state="translated">일반적으로 센서 데이터는 &lt;a href=&quot;qscreen#nativeOrientation-prop&quot;&gt;QScreen :: nativeOrientation을&lt;/a&gt; 기준으로합니다. 즉 , 기기를 자연스러운 방향으로 잡을 때 (일반적으로 기기 로고가 오른쪽을 위로 표시 할 때) 기기 상단을 기준으로합니다. 값을 화면에 표시하려면 사용자 인터페이스 방향과 일치하도록 값을 변환해야 할 수 있습니다. 센서는 데이터를 UI 지향으로 정의 할 수 있습니다. 이것은 센서 문서에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="f2d461ad9e2451af5a014dd5528ca190e7ae0e72" translate="yes" xml:space="preserve">
          <source>In general, simple logic should be defined in-line in the QML file, but more complex logic should be separated into code-behind implementation resources for maintainability and readability.</source>
          <target state="translated">일반적으로 간단한 논리는 QML 파일에서 인라인으로 정의해야하지만 유지 관리 성과 가독성을 위해 더 복잡한 논리를 코드 숨김 구현 리소스로 분리해야합니다.</target>
        </trans-unit>
        <trans-unit id="6849e63b08f87190a4b7fa882e9fc4b5445d543e" translate="yes" xml:space="preserve">
          <source>In general, the pointer will be invalid after the statement in which qUtf16Printable() is used. This is because the pointer may have been obtained from a temporary expression, which will fall out of scope.</source>
          <target state="translated">일반적으로 qUtf16Printable ()이 사용 된 명령문 이후에는 포인터가 유효하지 않습니다. 포인터가 범위를 벗어난 임시 표현식에서 얻은 것일 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="6c622bb388124a5b26778b067a582514ab280201" translate="yes" xml:space="preserve">
          <source>In general, these are accessible from QML regardless of whether a &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;-derived class has been &lt;a href=&quot;qtqml-cppintegration-definetypes#registering-c-types-with-the-qml-type-system&quot;&gt;registered with the QML type system&lt;/a&gt;. However, if a class is to be used in a way that requires the engine to access additional type information &amp;mdash; for example, if the class itself is to be used as a method parameter or property, or if one of its enum types is to be used in this way &amp;mdash; then the class may need to be registered.</source>
          <target state="translated">일반적으로 이들은 &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 파생 클래스가 &lt;a href=&quot;qtqml-cppintegration-definetypes#registering-c-types-with-the-qml-type-system&quot;&gt;QML 유형 시스템에 등록&lt;/a&gt; 되었는지 여부에 관계없이 QML에서 액세스 할 수 있습니다 . 그러나 클래스 자체를 메소드 매개 변수 또는 특성으로 사용하거나 열거 형 중 하나를 사용해야하는 경우와 같이 엔진이 추가 유형 정보에 액세스해야하는 방식으로 클래스를 사용하는 경우 이런 식으로 사용하면 클래스를 등록해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="61d4e33d0bc4ecf054832e4c44c5098f53bdf3c7" translate="yes" xml:space="preserve">
          <source>In general, this uuid is invalid on every platform but &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; and iOS. It is used as a workaround for those two platforms as they do not provide Bluetooth addresses for found Bluetooth Low Energy devices. Every other platform uses &lt;a href=&quot;qbluetoothdeviceinfo#address&quot;&gt;address&lt;/a&gt;() instead.</source>
          <target state="translated">일반적으로이 UUID는 &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; 및 iOS를 제외한 모든 플랫폼에서 유효하지 않습니다 . 이 두 플랫폼은 발견 된 Bluetooth 저에너지 장치에 대한 Bluetooth 주소를 제공하지 않으므로이 두 가지 플랫폼의 해결 방법으로 사용됩니다. 다른 모든 플랫폼은 &lt;a href=&quot;qbluetoothdeviceinfo#address&quot;&gt;주소&lt;/a&gt; ()를 대신 사용합니다.</target>
        </trans-unit>
        <trans-unit id="d3a17f19fd5126f7725d3873fb30280ab6070015" translate="yes" xml:space="preserve">
          <source>In general, this uuid is invalid on every platform but macOS and iOS. It is used as a workaround for those two platforms as they do not provide Bluetooth addresses for found Bluetooth Low Energy devices. Every other platform uses &lt;a href=&quot;qbluetoothdeviceinfo#address&quot;&gt;address&lt;/a&gt;() instead.</source>
          <target state="translated">일반적으로이 uuid는 macOS 및 iOS를 제외한 모든 플랫폼에서 유효하지 않습니다. 발견 된 Bluetooth Low Energy 장치에 대한 Bluetooth 주소를 제공하지 않으므로 두 플랫폼에 대한 해결 방법으로 사용됩니다. 다른 모든 플랫폼은 대신 &lt;a href=&quot;qbluetoothdeviceinfo#address&quot;&gt;주소&lt;/a&gt; ()를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="84ceb92332ee7e2712c382b2842be15ad2b3a3dd" translate="yes" xml:space="preserve">
          <source>In general, we recommend that you create a &lt;a href=&quot;qcoreapplication&quot;&gt;QCoreApplication&lt;/a&gt;, &lt;a href=&quot;qguiapplication&quot;&gt;QGuiApplication&lt;/a&gt; or a &lt;a href=&quot;qapplication&quot;&gt;QApplication&lt;/a&gt; object in your &lt;code&gt;main()&lt;/code&gt; function as early as possible. &lt;a href=&quot;qcoreapplication#exec&quot;&gt;exec&lt;/a&gt;() will not return until the event loop exits; e.g., when &lt;a href=&quot;qcoreapplication#quit&quot;&gt;quit&lt;/a&gt;() is called.</source>
          <target state="translated">일반적으로 &lt;code&gt;main()&lt;/code&gt; 함수 에서 &lt;a href=&quot;qcoreapplication&quot;&gt;QCoreApplication&lt;/a&gt; , &lt;a href=&quot;qguiapplication&quot;&gt;QGuiApplication&lt;/a&gt; 또는 &lt;a href=&quot;qapplication&quot;&gt;QApplication&lt;/a&gt; 객체 를 가능한 빨리 작성하는 것이 좋습니다 . &lt;a href=&quot;qcoreapplication#exec&quot;&gt;exec&lt;/a&gt; ()는 이벤트 루프가 종료 될 때까지 반환되지 않습니다. 예를 들어, &lt;a href=&quot;qcoreapplication#quit&quot;&gt;quit&lt;/a&gt; ()가 호출 될 때 .</target>
        </trans-unit>
        <trans-unit id="5273e641e1af5db67dd313f689d2ae03d3f0dc1c" translate="yes" xml:space="preserve">
          <source>In general, we recommend that you create a QCoreApplication, &lt;a href=&quot;qguiapplication&quot;&gt;QGuiApplication&lt;/a&gt; or a &lt;a href=&quot;qapplication&quot;&gt;QApplication&lt;/a&gt; object in your &lt;code&gt;main()&lt;/code&gt; function as early as possible. &lt;a href=&quot;qcoreapplication#exec&quot;&gt;exec&lt;/a&gt;() will not return until the event loop exits; e.g., when &lt;a href=&quot;qcoreapplication#quit&quot;&gt;quit&lt;/a&gt;() is called.</source>
          <target state="translated">일반적으로 &lt;code&gt;main()&lt;/code&gt; 함수에서 가능한 한 빨리 QCoreApplication, &lt;a href=&quot;qguiapplication&quot;&gt;QGuiApplication&lt;/a&gt; 또는 &lt;a href=&quot;qapplication&quot;&gt;QApplication&lt;/a&gt; 객체 를 생성하는 것이 좋습니다 . &lt;a href=&quot;qcoreapplication#exec&quot;&gt;exec&lt;/a&gt; ()는 이벤트 루프가 종료 될 때까지 반환되지 않습니다. 예 : &lt;a href=&quot;qcoreapplication#quit&quot;&gt;quit&lt;/a&gt; ()가 호출 될 때 .</target>
        </trans-unit>
        <trans-unit id="d9e4277a8585c35d53b91045f546875f4b1b8bc1" translate="yes" xml:space="preserve">
          <source>In general, we recommend that you use &lt;a href=&quot;qhash#contains&quot;&gt;contains&lt;/a&gt;() and &lt;a href=&quot;qhash#value&quot;&gt;value&lt;/a&gt;() rather than operator[]() for looking up a key in a hash. The reason is that operator[]() silently inserts an item into the hash if no item exists with the same key (unless the hash is const). For example, the following code snippet will create 1000 items in memory:</source>
          <target state="translated">일반적으로 해시에서 키를 찾는 데 operator [] () 대신 &lt;a href=&quot;qhash#contains&quot;&gt;contains&lt;/a&gt; () 및 &lt;a href=&quot;qhash#value&quot;&gt;value&lt;/a&gt; () 를 사용하는 것이 좋습니다 . 그 이유는 동일한 키를 가진 항목이없는 경우 연산자 (] ()가 해시에 자동으로 항목을 삽입하기 때문입니다 (해시가 const가 아닌 한). 예를 들어 다음 코드 스 니펫은 메모리에 1000 개의 항목을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="b0007a434f71d259618694822d5bfeba83e1dd00" translate="yes" xml:space="preserve">
          <source>In general, we recommend that you use &lt;a href=&quot;qmap#contains&quot;&gt;contains&lt;/a&gt;() and &lt;a href=&quot;qmap#value&quot;&gt;value&lt;/a&gt;() rather than operator[]() for looking up a key in a map. The reason is that operator[]() silently inserts an item into the map if no item exists with the same key (unless the map is const). For example, the following code snippet will create 1000 items in memory:</source>
          <target state="translated">일반적으로 지도에서 키를 조회 할 때는 operator [] () 대신 &lt;a href=&quot;qmap#contains&quot;&gt;contains&lt;/a&gt; () 및 &lt;a href=&quot;qmap#value&quot;&gt;value&lt;/a&gt; () 를 사용하는 것이 좋습니다 . 그 이유는 동일한 키가있는 항목이없는 경우 (map이 const가 아닌 경우) operator [] ()가 맵에 항목을 자동으로 삽입하기 때문입니다. 예를 들어 다음 코드 스 니펫은 메모리에 1000 개의 항목을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="995231ad234230a9b8a6a0e6e825f932f6c3528a" translate="yes" xml:space="preserve">
          <source>In general, you will rarely ever need to call this function. &lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt;'s internal hash table automatically grows to provide good performance without wasting too much memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc5622e36d535a53db4beeb4bbbfc01f7a4d6e23" translate="yes" xml:space="preserve">
          <source>In general, you will rarely ever need to call this function. &lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt;'s internal hash table automatically shrinks or grows to provide good performance without wasting too much memory.</source>
          <target state="translated">일반적으로이 함수를 호출 할 필요는 거의 없습니다. &lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt; 의 내부 해시 테이블은 너무 많은 메모리를 낭비하지 않고 우수한 성능을 제공하기 위해 자동으로 축소되거나 커집니다.</target>
        </trans-unit>
        <trans-unit id="19a04368af0343289fa3b76e8b7ef2051808deb3" translate="yes" xml:space="preserve">
          <source>In general, you will rarely ever need to call this function. &lt;a href=&quot;qset&quot;&gt;QSet&lt;/a&gt;'s internal hash table automatically shrinks or grows to provide good performance without wasting too much memory.</source>
          <target state="translated">일반적으로이 함수를 호출 할 필요는 거의 없습니다. &lt;a href=&quot;qset&quot;&gt;QSet&lt;/a&gt; 의 내부 해시 테이블은 너무 많은 메모리를 낭비하지 않고 우수한 성능을 제공하기 위해 자동으로 축소되거나 커집니다.</target>
        </trans-unit>
        <trans-unit id="ba9eb27b95af0b2827dafa339ac25524deb224bf" translate="yes" xml:space="preserve">
          <source>In hierarchical models where finding the number of children of a given item is an expensive operation, it is useful to ensure that the model's &lt;a href=&quot;qabstractitemmodel#rowCount&quot;&gt;rowCount()&lt;/a&gt; implementation is only called when necessary. In such cases, the &lt;a href=&quot;qabstractitemmodel#hasChildren&quot;&gt;hasChildren()&lt;/a&gt; function can be reimplemented to provide an inexpensive way for views to check for the presence of children and, in the case of &lt;a href=&quot;qtreeview&quot;&gt;QTreeView&lt;/a&gt;, draw the appropriate decoration for their parent item.</source>
          <target state="translated">주어진 항목의 자식 수를 찾는 것이 비용이 많이 드는 계층 적 모델에서는 모델의 &lt;a href=&quot;qabstractitemmodel#rowCount&quot;&gt;rowCount ()&lt;/a&gt; 구현이 필요할 때만 호출 되도록하는 것이 유용 합니다. 이러한 경우 &lt;a href=&quot;qabstractitemmodel#hasChildren&quot;&gt;hasChildren ()&lt;/a&gt; 함수를 다시 구현하여 뷰가 어린이의 존재를 확인할 수있는 저렴한 방법을 제공하고 &lt;a href=&quot;qtreeview&quot;&gt;QTreeView&lt;/a&gt; 의 경우 부모 항목에 적절한 장식을 그립니다.</target>
        </trans-unit>
        <trans-unit id="cb92e51877c2515aad653fa53a73570269080b5a" translate="yes" xml:space="preserve">
          <source>In hierarchical models, when a drop occurs on an item, it would be better to insert new items into the model as children of that item. In the simple example shown here, the model only has one level, so this approach is not appropriate.</source>
          <target state="translated">계층 적 모델에서 항목에 드롭이 발생하면 해당 항목의 하위 항목으로 모델에 새 항목을 삽입하는 것이 좋습니다. 여기에 표시된 간단한 예에서 모델에는 한 수준 만 있으므로이 방법은 적합하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="00c0cae839ddda624334a2403483c7352f65cd8e" translate="yes" xml:space="preserve">
          <source>In its most basic form, a model can be accessed as a simple table in which items are located by their row and column numbers.</source>
          <target state="translated">가장 기본적인 형태로, 모델은 행과 열 번호로 항목을 찾는 간단한 테이블로 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dbc0cc9cd4253bcc283de2f132ac5c7d434d46b6" translate="yes" xml:space="preserve">
          <source>In its most common form, a key sequence describes a combination of keys that must be used together to perform some action. Key sequences are used with &lt;a href=&quot;qaction&quot;&gt;QAction&lt;/a&gt; objects to specify which keyboard shortcuts can be used to trigger actions.</source>
          <target state="translated">가장 일반적인 형태로 키 시퀀스는 일부 작업을 수행하기 위해 함께 사용해야하는 키 조합을 나타냅니다. 키 시퀀스는 &lt;a href=&quot;qaction&quot;&gt;QAction&lt;/a&gt; 오브젝트 와 함께 사용되어 조치를 트리거하는 데 사용할 수있는 키보드 단축키를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="b667f86f48fc68b85ef71c107d6544fbee938d65" translate="yes" xml:space="preserve">
          <source>In its simplest form, a tree widget can be constructed in the following way:</source>
          <target state="translated">가장 간단한 형태로 트리 위젯은 다음과 같은 방식으로 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7dcd072fc314743db90dadec9d0a600d1ddbed98" translate="yes" xml:space="preserve">
          <source>In itself, a &lt;a href=&quot;qt3drender-qmaterial&quot;&gt;QMaterial&lt;/a&gt; doesn't do anything. It's only when it references a &lt;a href=&quot;qt3drender-qeffect&quot;&gt;QEffect&lt;/a&gt; node that a &lt;a href=&quot;qt3drender-qmaterial&quot;&gt;QMaterial&lt;/a&gt; becomes useful.</source>
          <target state="translated">&lt;a href=&quot;qt3drender-qmaterial&quot;&gt;QMaterial&lt;/a&gt; 자체 는 아무것도하지 않습니다. &lt;a href=&quot;qt3drender-qmaterial&quot;&gt;QMaterial&lt;/a&gt; 이 유용한 &lt;a href=&quot;qt3drender-qeffect&quot;&gt;QEffect&lt;/a&gt; 노드를 참조 할 때만 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="de2cc45bab651e1c7dac8b1681471a3a08848efc" translate="yes" xml:space="preserve">
          <source>In itself, a Material doesn't do anything. It's only when it references an Effect node that a Material becomes useful.</source>
          <target state="translated">머티리얼 자체는 아무것도하지 않습니다. 머티리얼이 유용 해지는 Effect 노드를 참조 할 때만 가능합니다.</target>
        </trans-unit>
        <trans-unit id="e363f703a6970bd71136fc865ce0a88b99a86de3" translate="yes" xml:space="preserve">
          <source>In itself, a QMaterial doesn't do anything. It's only when it references a &lt;a href=&quot;qt3drender-qeffect&quot;&gt;QEffect&lt;/a&gt; node that a QMaterial becomes useful.</source>
          <target state="translated">그 자체로 QMaterial은 아무것도하지 않습니다. QMaterial이 유용 해지는 것은 &lt;a href=&quot;qt3drender-qeffect&quot;&gt;QEffect&lt;/a&gt; 노드를 참조 할 때만 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="f2584c43252a8dc553e4314115f45d5e3c816240" translate="yes" xml:space="preserve">
          <source>In keyboard-interactive mode, the windows are moved and resized with the keyboard. You can enter this mode through the system menu of the window. The &lt;a href=&quot;qmdisubwindow#keyboardSingleStep-prop&quot;&gt;keyboardSingleStep&lt;/a&gt; and &lt;a href=&quot;qmdisubwindow#keyboardPageStep-prop&quot;&gt;keyboardPageStep&lt;/a&gt; properties control the distance the widget is moved or resized for each keypress event. When shift is pressed down page step is used; otherwise single step is used.</source>
          <target state="translated">키보드 대화 형 모드에서 키보드로 창을 이동하고 크기를 조정합니다. 창의 시스템 메뉴를 통해이 모드로 들어갈 수 있습니다. &lt;a href=&quot;qmdisubwindow#keyboardSingleStep-prop&quot;&gt;keyboardSingleStep&lt;/a&gt; 및 &lt;a href=&quot;qmdisubwindow#keyboardPageStep-prop&quot;&gt;keyboardPageStep&lt;/a&gt; 특성 위젯을 이동하거나 키를 누를 때마다 이벤트를 리사이즈 거리를 제어한다. Shift 키를 누르면 페이지 단계가 사용됩니다. 그렇지 않으면 단일 단계가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="019d4a8d63e5cf2686f8b92fdb64afdacb4830e6" translate="yes" xml:space="preserve">
          <source>In line with most implementations today, &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; will assume the INI file is utf-8 encoded. This means that keys and values will be decoded as utf-8 encoded entries and written back as utf-8.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d9dce4b47f86fcc46f9fd0d8b8e3c72cb0bff73" translate="yes" xml:space="preserve">
          <source>In many cases it is sufficient to receive signals through signal handlers rather than using the connect() function. However, using the &lt;code&gt;connect&lt;/code&gt; method allows a signal to be received by multiple methods as shown earlier, which would not be possible with signal handlers as they must be uniquely named. Also, the &lt;code&gt;connect&lt;/code&gt; method is useful when connecting signals to &lt;a href=&quot;qtqml-javascript-dynamicobjectcreation&quot;&gt;dynamically created objects&lt;/a&gt;.</source>
          <target state="translated">대부분의 경우 connect () 함수를 사용하는 것보다 신호 처리기를 통해 신호를 수신하는 것으로 충분합니다. 그러나 &lt;code&gt;connect&lt;/code&gt; 메소드를 사용하면 앞서 표시된 것처럼 여러 메소드에서 신호를 수신 할 수 있습니다. 이는 고유 한 이름을 지정해야하므로 신호 핸들러에서는 불가능합니다. 또한 &lt;code&gt;connect&lt;/code&gt; 메서드는 &lt;a href=&quot;qtqml-javascript-dynamicobjectcreation&quot;&gt;동적으로 생성 된 객체에&lt;/a&gt; 신호를 연결할 때 유용 합니다 .</target>
        </trans-unit>
        <trans-unit id="f4616ef1618967d6d6591d1a4505628dc05ae149" translate="yes" xml:space="preserve">
          <source>In many cases it is sufficient to receive signals through signal handlers rather than using the connect() function. However, using the &lt;code&gt;connect&lt;/code&gt; method allows a signal to be received by multiple methods as shown earlier, which would not be possible with signal handlers as they must be uniquely named. Also, the &lt;code&gt;connect&lt;/code&gt; method is useful when connecting signals to &lt;a href=&quot;qtqml-javascript-dynamicobjectcreation#&quot;&gt;dynamically created objects&lt;/a&gt;.</source>
          <target state="translated">대부분의 경우 connect () 함수를 사용하는 대신 신호 핸들러를 통해 신호를 수신하는 것으로 충분합니다. 그러나 &lt;code&gt;connect&lt;/code&gt; 메소드를 사용하면 앞에서 설명한대로 여러 메소드가 신호를 수신 할 수 있으며, 고유하게 이름을 지정해야하므로 신호 핸들러로는 불가능합니다. 또한 &lt;code&gt;connect&lt;/code&gt; 방법은 신호를 &lt;a href=&quot;qtqml-javascript-dynamicobjectcreation#&quot;&gt;동적으로 생성 된 객체에&lt;/a&gt; 연결할 때 유용 합니다 .</target>
        </trans-unit>
        <trans-unit id="d785d6c000a5fe3467d5ab1dab6fc441daf8ae7d" translate="yes" xml:space="preserve">
          <source>In many cases the torch hardware is shared with camera flash functionality, and might be automatically controlled by the device. You have control over the power level (of course, higher power levels are brighter but reduce battery life significantly).</source>
          <target state="translated">대부분의 경우 토치 하드웨어는 카메라 플래시 기능과 공유되며 장치에 의해 자동으로 제어 될 수 있습니다. 전원 수준을 제어 할 수 있습니다 (물론, 더 높은 전원 수준은 밝지 만 배터리 수명을 크게 줄입니다).</target>
        </trans-unit>
        <trans-unit id="161ae7ee9897550d357db6468a55ca2ca1146c1d" translate="yes" xml:space="preserve">
          <source>In many cases these properties do not need to be explicitly specified, as they can be inferred from the animation framework:</source>
          <target state="translated">대부분의 경우 이러한 속성은 애니메이션 프레임 워크에서 유추 할 수 있으므로 명시 적으로 지정하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="3a7bd39609818c74e82eaebc3b22311f55a717b7" translate="yes" xml:space="preserve">
          <source>In many cases, &lt;a href=&quot;qreadwritelock&quot;&gt;QReadWriteLock&lt;/a&gt; is a direct competitor to &lt;a href=&quot;qmutex&quot;&gt;QMutex&lt;/a&gt;. &lt;a href=&quot;qreadwritelock&quot;&gt;QReadWriteLock&lt;/a&gt; is a good choice if there are many concurrent reads and writing occurs infrequently.</source>
          <target state="translated">많은 경우에, &lt;a href=&quot;qreadwritelock&quot;&gt;QReadWriteLock는&lt;/a&gt; 직접적인 경쟁자 &lt;a href=&quot;qmutex&quot;&gt;QMutex&lt;/a&gt; . &lt;a href=&quot;qreadwritelock&quot;&gt;QReadWriteLock&lt;/a&gt; 은 동시 읽기가 많고 쓰기가 자주 발생하지 않는 경우에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="cdc945eef5b6d0e6d1cd2c4df87c7e141e4f43e5" translate="yes" xml:space="preserve">
          <source>In many cases, QReadWriteLock is a direct competitor to &lt;a href=&quot;qmutex&quot;&gt;QMutex&lt;/a&gt;. QReadWriteLock is a good choice if there are many concurrent reads and writing occurs infrequently.</source>
          <target state="translated">많은 경우에, QReadWriteLock는 직접적인 경쟁자 &lt;a href=&quot;qmutex&quot;&gt;QMutex&lt;/a&gt; . 동시 읽기가 많고 쓰기가 드물게 발생하는 경우 QReadWriteLock이 좋은 선택입니다.</target>
        </trans-unit>
        <trans-unit id="b16bee62c9c48e4c2ca9d8d2c32391aa363b033b" translate="yes" xml:space="preserve">
          <source>In many cases, the internal state of a control can be more efficiently processed in C++. For example, handling input events in C++ makes a difference for controls that would otherwise need to create internal MouseAreas and attached Keys objects.</source>
          <target state="translated">대부분의 경우 컨트롤의 내부 상태는 C ++에서보다 효율적으로 처리 될 수 있습니다. 예를 들어 C ++에서 입력 이벤트를 처리하면 내부 MouseArea 및 연결된 Keys 개체를 만들어야하는 컨트롤이 달라집니다.</target>
        </trans-unit>
        <trans-unit id="f609949c9c12ed4aaeb5e4385fbcad5eaa080388" translate="yes" xml:space="preserve">
          <source>In many project files, the assignment (&lt;code&gt;=&lt;/code&gt;) and append (&lt;code&gt;+=&lt;/code&gt;) operators can be used to include all the information about a project. The typical pattern of use is to assign a list of values to a variable, and append more values depending on the result of various tests. Since qmake defines certain variables using default values, it is sometimes necessary to use the removal (&lt;code&gt;-=&lt;/code&gt;) operator to filter out values that are not required. The following sections describe how to use operators to manipulate the contents of variables.</source>
          <target state="translated">많은 프로젝트 파일에서 할당 ( &lt;code&gt;=&lt;/code&gt; ) 및 추가 ( &lt;code&gt;+=&lt;/code&gt; ) 연산자를 사용하여 프로젝트에 대한 모든 정보를 포함 할 수 있습니다. 일반적인 사용 패턴은 변수에 값 목록을 할당하고 다양한 테스트 결과에 따라 더 많은 값을 추가하는 것입니다. qmake는 기본값을 사용하여 특정 변수를 정의하기 때문에 제거 ( &lt;code&gt;-=&lt;/code&gt; ) 연산자를 사용하여 필요하지 않은 값을 필터링해야하는 경우가 있습니다. 다음 섹션에서는 연산자를 사용하여 변수의 내용을 조작하는 방법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="782917b6030b45e21219e726acc63fe353c72ceb" translate="yes" xml:space="preserve">
          <source>In many user interfaces, it is sufficient to set a visual object's opacity to 0 or to move the visual object off the screen instead of deleting it. If you have lots of dynamically created objects, however, you may receive a worthwhile performance benefit if unused objects are deleted.</source>
          <target state="translated">많은 사용자 인터페이스에서 시각적 개체의 불투명도를 0으로 설정하거나 시각적 개체를 삭제하는 대신 화면 밖으로 옮기는 것으로 충분합니다. 그러나 동적으로 생성 된 개체가 많으면 사용하지 않는 개체를 삭제하면 성능이 향상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="78d9649203441474de67ef8c858231e2a462eb10" translate="yes" xml:space="preserve">
          <source>In many wizards, the contents of a page may affect the default values of the fields of a later page. To make it easy to communicate between pages, &lt;a href=&quot;qwizard&quot;&gt;QWizard&lt;/a&gt; supports a &quot;field&quot; mechanism that allows you to register a field (e.g., a &lt;a href=&quot;qlineedit&quot;&gt;QLineEdit&lt;/a&gt;) on a page and to access its value from any page. It is also possible to specify mandatory fields (i.e., fields that must be filled before the user can advance to the next page).</source>
          <target state="translated">많은 마법사에서 페이지의 내용이 이후 페이지의 필드 기본값에 영향을 줄 수 있습니다. 페이지 간 통신을 쉽게하기 위해 &lt;a href=&quot;qwizard&quot;&gt;QWizard&lt;/a&gt; 는 페이지 에 필드 (예 : &lt;a href=&quot;qlineedit&quot;&gt;QLineEdit&lt;/a&gt; ) 를 등록하고 모든 페이지에서 해당 값에 액세스 할 수있는 &quot;필드&quot;메커니즘을 지원합니다 . 필수 필드 (즉, 사용자가 다음 페이지로 진행하기 전에 채워야하는 필드)를 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="340a548e3daa2a531166f65a82fc421c7864c735" translate="yes" xml:space="preserve">
          <source>In many wizards, the contents of a page may affect the default values of the fields of a later page. To make it easy to communicate between pages, &lt;a href=&quot;qwizard&quot;&gt;QWizard&lt;/a&gt; supports a &lt;a href=&quot;qwizard#registering-and-using-fields&quot;&gt;&quot;field&quot; mechanism&lt;/a&gt; that allows you to register a field (e.g., a &lt;a href=&quot;qlineedit&quot;&gt;QLineEdit&lt;/a&gt;) on a page and to access its value from any page. Fields are global to the entire wizard and make it easy for any single page to access information stored by another page, without having to put all the logic in &lt;a href=&quot;qwizard&quot;&gt;QWizard&lt;/a&gt; or having the pages know explicitly about each other. Fields are registered using &lt;a href=&quot;qwizardpage#registerField&quot;&gt;registerField&lt;/a&gt;() and can be accessed at any time using &lt;a href=&quot;qwizardpage#field&quot;&gt;field&lt;/a&gt;() and &lt;a href=&quot;qwizardpage#setField&quot;&gt;setField&lt;/a&gt;().</source>
          <target state="translated">많은 마법사에서 페이지의 내용이 이후 페이지의 필드 기본값에 영향을 줄 수 있습니다. 페이지 간 통신을 쉽게하기 위해 &lt;a href=&quot;qwizard&quot;&gt;QWizard&lt;/a&gt; 는 페이지 에 필드 (예 : &lt;a href=&quot;qlineedit&quot;&gt;QLineEdit&lt;/a&gt; ) 를 등록하고 모든 페이지에서 해당 값에 액세스 할 수 있는 &lt;a href=&quot;qwizard#registering-and-using-fields&quot;&gt;&quot;필드&quot;메커니즘&lt;/a&gt; 을 지원합니다 . 필드는 전체 마법사 전체에 &lt;a href=&quot;qwizard&quot;&gt;적용&lt;/a&gt; 되며 QWizard 에 모든 논리를 넣거나 페이지가 서로에 대해 명시 적으로 알 필요없이 단일 페이지가 다른 페이지에 저장된 정보에 쉽게 액세스 할 수 있도록합니다 . 필드는 registerField ()를 사용하여 &lt;a href=&quot;qwizardpage#registerField&quot;&gt;등록&lt;/a&gt; 되며 &lt;a href=&quot;qwizardpage#field&quot;&gt;필드&lt;/a&gt; () 및 &lt;a href=&quot;qwizardpage#setField&quot;&gt;setField&lt;/a&gt; ()를 사용하여 언제든지 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="60a36409aef8188573ab3c54d5f01a5a07d5125c" translate="yes" xml:space="preserve">
          <source>In many wizards, the contents of a page may affect the default values of the fields of a later page. To make it easy to communicate between pages, QWizard supports a &quot;field&quot; mechanism that allows you to register a field (e.g., a &lt;a href=&quot;qlineedit&quot;&gt;QLineEdit&lt;/a&gt;) on a page and to access its value from any page. It is also possible to specify mandatory fields (i.e., fields that must be filled before the user can advance to the next page).</source>
          <target state="translated">많은 마법사에서 페이지의 내용은 이후 페이지의 필드 기본값에 영향을 미칠 수 있습니다. 페이지간에 쉽게 통신 할 수 있도록 QWizard는 페이지에 필드 (예 : &lt;a href=&quot;qlineedit&quot;&gt;QLineEdit&lt;/a&gt; ) 를 등록하고 모든 페이지에서 해당 값에 액세스 할 수있는 &quot;필드&quot;메커니즘을 지원합니다 . 필수 필드 (즉, 사용자가 다음 페이지로 진행하기 전에 채워야하는 필드)를 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f18a6c09fd6cb157b1e37176352d7968fbaeebaf" translate="yes" xml:space="preserve">
          <source>In member functions where an argument</source>
          <target state="translated">인수가있는 멤버 함수에서</target>
        </trans-unit>
        <trans-unit id="7d9cbbf03d10a0b89b193fdd16a70bbef05fcda3" translate="yes" xml:space="preserve">
          <source>In memory, resources are represented by a tree of resource objects. The tree is automatically built at startup and used by &lt;a href=&quot;qfile&quot;&gt;QFile&lt;/a&gt; for resolving paths to resources. You can use a &lt;a href=&quot;qdir&quot;&gt;QDir&lt;/a&gt; initialized with &quot;:/&quot; to navigate through the resource tree from the root.</source>
          <target state="translated">메모리에서 리소스는 리소스 개체 트리로 표시됩니다. 트리는 시작시 자동으로 빌드되며 &lt;a href=&quot;qfile&quot;&gt;QFile&lt;/a&gt; 에서 자원 경로를 해석하는 데 사용 합니다. &quot;: /&quot;로 초기화 된 &lt;a href=&quot;qdir&quot;&gt;QDir&lt;/a&gt; 을 사용하여 루트에서 리소스 트리를 탐색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="220a9a22a5e747671c32d0cc7b5fa3d602a8c0a8" translate="yes" xml:space="preserve">
          <source>In most cases it is better to use either &lt;a href=&quot;qcontiguouscache#at&quot;&gt;at&lt;/a&gt;() or &lt;a href=&quot;qcontiguouscache#insert&quot;&gt;insert&lt;/a&gt;().</source>
          <target state="translated">대부분의 경우 &lt;a href=&quot;qcontiguouscache#at&quot;&gt;at&lt;/a&gt; () 또는 &lt;a href=&quot;qcontiguouscache#insert&quot;&gt;insert&lt;/a&gt; () 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="fd8565e7cf43454d4a874faeda6b26b5eab778b5" translate="yes" xml:space="preserve">
          <source>In most cases it is better to use either &lt;a href=&quot;qcontiguouscache#at&quot;&gt;at&lt;/a&gt;() or &lt;a href=&quot;qcontiguouscache#insert-1&quot;&gt;insert&lt;/a&gt;().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73197b5aa23629d2e7100cc32d11106dcdef78e9" translate="yes" xml:space="preserve">
          <source>In most cases the indexes will not exceed 0 to INT_MAX, and &lt;a href=&quot;qcontiguouscache#normalizeIndexes&quot;&gt;normalizeIndexes&lt;/a&gt;() will not need to be used.</source>
          <target state="translated">대부분의 경우 인덱스는 0에서 INT_MAX를 초과하지 않으며 &lt;a href=&quot;qcontiguouscache#normalizeIndexes&quot;&gt;normalizeIndexes&lt;/a&gt; ()를 사용할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="61941430557547c2cafc6d78e6fe67b961b1fdcf" translate="yes" xml:space="preserve">
          <source>In most cases the state chage is caused by &lt;a href=&quot;qcameracontrol#setState&quot;&gt;QCameraControl::setState&lt;/a&gt;(), but if critical error has occurred the state changes to &lt;a href=&quot;qcamera#State-enum&quot;&gt;QCamera::UnloadedState&lt;/a&gt;.</source>
          <target state="translated">대부분의 경우 상태 변경은 &lt;a href=&quot;qcameracontrol#setState&quot;&gt;QCameraControl :: setState&lt;/a&gt; () 에 의해 발생 하지만 심각한 오류가 발생하면 상태가 &lt;a href=&quot;qcamera#State-enum&quot;&gt;QCamera :: UnloadedState로&lt;/a&gt; 변경됩니다 .</target>
        </trans-unit>
        <trans-unit id="c26bd4a4c500ac565eae1b1328dab78467ff1701" translate="yes" xml:space="preserve">
          <source>In most cases this function returns the same string as &lt;a href=&quot;qsqlquery#lastQuery&quot;&gt;lastQuery&lt;/a&gt;(). If a prepared query with placeholders is executed on a DBMS that does not support it, the preparation of this query is emulated. The placeholders in the original query are replaced with their bound values to form a new query. This function returns the modified query. It is mostly useful for debugging purposes.</source>
          <target state="translated">대부분의 경우이 함수는 &lt;a href=&quot;qsqlquery#lastQuery&quot;&gt;lastQuery&lt;/a&gt; () 와 동일한 문자열을 반환합니다 . 플레이스 홀더가있는 준비된 쿼리가이를 지원하지 않는 DBMS에서 실행되면이 쿼리의 준비가 에뮬레이트됩니다. 원래 쿼리의 자리 표시자는 바인딩 된 값으로 바뀌어 새 쿼리를 형성합니다. 이 함수는 수정 된 쿼리를 반환합니다. 디버깅 목적으로 주로 유용합니다.</target>
        </trans-unit>
        <trans-unit id="ccdd1f4dc787718433566c661cac339bc2cf8f74" translate="yes" xml:space="preserve">
          <source>In most cases where you would consider using function pointers as signal or slot parameters, we think inheritance is a better alternative. Here is an example of illegal syntax:</source>
          <target state="translated">함수 포인터를 신호 또는 슬롯 매개 변수로 사용하는 대부분의 경우 상속이 더 나은 대안이라고 생각합니다. 다음은 잘못된 구문의 예입니다.</target>
        </trans-unit>
        <trans-unit id="6034aed0417ebe53af1d84f5a1c61a3e76db55a2" translate="yes" xml:space="preserve">
          <source>In most cases, application developers will not be using the skinning API manually. The normal workflow is to use an external content creation tool to define the skeleton and the skin (this is sometimes also referred to as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8916466ca092f76775d62ec89be7e64ec9658cc" translate="yes" xml:space="preserve">
          <source>In most cases, changes made to a graph are detected by Qt 3D and a new cache entry will be generated. One case were this will not happen is when code snippets included by a graphs are changed. To work around that, clearing the cache directory or setting environment variable QT3D_REBUILD_SHADER_CACHE can be used to force shader code to be generated again.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed458223351dc80f129b8d1e0771b835bd8c9289" translate="yes" xml:space="preserve">
          <source>In most cases, existing layout-aware classes such as &lt;a href=&quot;graphicsview#qgraphicswidget&quot;&gt;QGraphicsWidget&lt;/a&gt; and &lt;a href=&quot;graphicsview#qgraphicslayout&quot;&gt;QGraphicsLayout&lt;/a&gt; already provide the functionality you require. However, subclassing these classes will enable you to create both graphical elements that work well with layouts (&lt;a href=&quot;graphicsview#qgraphicswidget&quot;&gt;QGraphicsWidget&lt;/a&gt;) or custom layouts (&lt;a href=&quot;graphicsview#qgraphicslayout&quot;&gt;QGraphicsLayout&lt;/a&gt;).</source>
          <target state="translated">대부분의 경우 &lt;a href=&quot;graphicsview#qgraphicswidget&quot;&gt;QGraphicsWidget&lt;/a&gt; 및 &lt;a href=&quot;graphicsview#qgraphicslayout&quot;&gt;QGraphicsLayout&lt;/a&gt; 과 같은 기존 레이아웃 인식 클래스는 이미 필요한 기능을 제공합니다. 그러나이 클래스를 서브 클래 싱하면 레이아웃 ( &lt;a href=&quot;graphicsview#qgraphicswidget&quot;&gt;QGraphicsWidget&lt;/a&gt; ) 또는 사용자 정의 레이아웃 ( &lt;a href=&quot;graphicsview#qgraphicslayout&quot;&gt;QGraphicsLayout&lt;/a&gt; )에서 잘 작동하는 그래픽 요소를 모두 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a1f9cd42bca7bf8549d0b7506bf7a2ff5d5b751f" translate="yes" xml:space="preserve">
          <source>In most cases, it is not wise to manually invoke the garbage collector, as it will block the GUI thread for a substantial period of time. This can result in skipped frames and jerky animations, which should be avoided at all costs.</source>
          <target state="translated">대부분의 경우 가비지 수집기를 수동으로 호출하는 것은 현명하지 않습니다. 가비지 수집기는 상당한 시간 동안 GUI 스레드를 차단하기 때문입니다. 이로 인해 프레임이 건너 뛰고 애니메이션이 생길 수 있으므로 모든 비용을 피해야합니다.</target>
        </trans-unit>
        <trans-unit id="927428fec6043727a4df5c30289799179e4307b4" translate="yes" xml:space="preserve">
          <source>In most cases, this is the Unicode representation of the key code.</source>
          <target state="translated">대부분의 경우 이것은 키 코드의 유니 코드 표현입니다.</target>
        </trans-unit>
        <trans-unit id="36881272bd5823b4dc7cf0473854f220400954b3" translate="yes" xml:space="preserve">
          <source>In most cases, using &lt;code&gt;@rpath&lt;/code&gt; is sufficient and recommended:</source>
          <target state="translated">대부분의 경우 &lt;code&gt;@rpath&lt;/code&gt; 를 사용 하면 충분하고 권장됩니다.</target>
        </trans-unit>
        <trans-unit id="29704ffa56b268da56f994cc9b0178b8fc8f5fa5" translate="yes" xml:space="preserve">
          <source>In most cases, you will also implement &lt;a href=&quot;qlayout#minimumSize&quot;&gt;minimumSize()&lt;/a&gt;.</source>
          <target state="translated">대부분의 경우 &lt;a href=&quot;qlayout#minimumSize&quot;&gt;minimumSize ()&lt;/a&gt; 도 구현 합니다.</target>
        </trans-unit>
        <trans-unit id="a720d87c85cb4a3f7abf598e33c014fe235fcfae" translate="yes" xml:space="preserve">
          <source>In most main window style applications you would use the &lt;a href=&quot;qmainwindow#menuBar&quot;&gt;menuBar()&lt;/a&gt; function provided in &lt;a href=&quot;qmainwindow&quot;&gt;QMainWindow&lt;/a&gt;, adding &lt;a href=&quot;qmenu&quot;&gt;QMenu&lt;/a&gt;s to the menu bar and adding &lt;a href=&quot;qaction&quot;&gt;QAction&lt;/a&gt;s to the pop-up menus.</source>
          <target state="translated">대부분의 메인 윈도우 스타일의 응용 프로그램에서 당신은 사용할 것 &lt;a href=&quot;qmainwindow#menuBar&quot;&gt;의 도구 모음 ()&lt;/a&gt; 에서 제공하는 기능 &lt;a href=&quot;qmainwindow&quot;&gt;QMainWindow를&lt;/a&gt; 추가 &lt;a href=&quot;qmenu&quot;&gt;QMenu를&lt;/a&gt; 메뉴 표시 줄에들 및 추가 &lt;a href=&quot;qaction&quot;&gt;QAction&lt;/a&gt; 팝업 메뉴에들.</target>
        </trans-unit>
        <trans-unit id="5eb42ddc37d565d38c3af20b6bc404c9a2eced6e" translate="yes" xml:space="preserve">
          <source>In most programs, the &lt;a href=&quot;qdbuspendingcall&quot;&gt;QDBusPendingCall&lt;/a&gt; class will not be used directly. It can be safely replaced with the template-based &lt;a href=&quot;qdbuspendingreply&quot;&gt;QDBusPendingReply&lt;/a&gt;, in order to access the contents of the reply or wait for it to be complete.</source>
          <target state="translated">대부분의 프로그램에서 &lt;a href=&quot;qdbuspendingcall&quot;&gt;QDBusPendingCall&lt;/a&gt; 클래스는 직접 사용되지 않습니다. 응답 내용에 액세스하거나 완료 될 때까지 대기하기 위해 템플리트 기반 &lt;a href=&quot;qdbuspendingreply&quot;&gt;QDBusPendingReply&lt;/a&gt; 로 안전하게 대체 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="99a6ebb56f474cc9391b16ba27cac80b782b2b1d" translate="yes" xml:space="preserve">
          <source>In most programs, the QDBusPendingCall class will not be used directly. It can be safely replaced with the template-based &lt;a href=&quot;dbus-changes-qt6#qdbuspendingreply&quot;&gt;QDBusPendingReply&lt;/a&gt;, in order to access the contents of the reply or wait for it to be complete.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c815b26a3edbe457cbae84dc60e50ed929f80007" translate="yes" xml:space="preserve">
          <source>In most programs, the QDBusPendingCall class will not be used directly. It can be safely replaced with the template-based &lt;a href=&quot;qdbuspendingreply&quot;&gt;QDBusPendingReply&lt;/a&gt;, in order to access the contents of the reply or wait for it to be complete.</source>
          <target state="translated">대부분의 프로그램에서 QDBusPendingCall 클래스는 직접 사용되지 않습니다. 응답 내용에 액세스하거나 완료 될 때까지 기다리기 위해 템플릿 기반 &lt;a href=&quot;qdbuspendingreply&quot;&gt;QDBusPendingReply&lt;/a&gt; 로 안전하게 대체 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="25ef42d72c72aebdfd6e5f25839b3db569e9d5ca" translate="yes" xml:space="preserve">
          <source>In most scenarios where a QML component wants the appearance of a synchronous instantiation, it should use this mode.</source>
          <target state="translated">QML 구성 요소가 동기 인스턴스화의 모양을 원하는 대부분의 시나리오에서는이 모드를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="3b6e9ee122d981f49721c96d6590322a10156a9b" translate="yes" xml:space="preserve">
          <source>In most script engines the only supported parameter type is &quot;const &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt;&amp;amp;&quot;, for example, to call a JavaScript function</source>
          <target state="translated">대부분의 스크립트 엔진에서 지원되는 매개 변수 유형은 &quot;const &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; &amp;amp;&quot;입니다 (예 : JavaScript 함수 호출).</target>
        </trans-unit>
        <trans-unit id="b9b3ae5449e8c0871d12fd80aa098dc61f16fb2f" translate="yes" xml:space="preserve">
          <source>In most situations you'll want to specify the position yourself, for example, the current mouse position:</source>
          <target state="translated">대부분의 경우 현재 마우스 위치와 같이 위치를 직접 지정하려고합니다.</target>
        </trans-unit>
        <trans-unit id="10adffde2587482f7449d231df99d659614e6ea6" translate="yes" xml:space="preserve">
          <source>In most styles, Active and Inactive look the same.</source>
          <target state="translated">대부분의 스타일에서 활성과 비활성은 동일하게 보입니다.</target>
        </trans-unit>
        <trans-unit id="3a627b1dad187b65f6e604a11cc750e597d9b793" translate="yes" xml:space="preserve">
          <source>In most subclasses, the number of columns is independent of the</source>
          <target state="translated">대부분의 서브 클래스에서 열의 수는</target>
        </trans-unit>
        <trans-unit id="6130a48c765ff0cdefaf8fdfe6cfc6cfe78961ca" translate="yes" xml:space="preserve">
          <source>In multi-window mode, you can arrange each of the tool windows to suit your working style. The main window consists of a menu bar, a tool bar, and a widget box that contains the widgets you can use to create your user interface.</source>
          <target state="translated">다중 창 모드에서는 작업 스타일에 맞게 각 도구 창을 배열 할 수 있습니다. 기본 창은 메뉴 표시 줄, 도구 모음 및 사용자 인터페이스를 작성하는 데 사용할 수있는 위젯이 포함 된 위젯 상자로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="136eb8f687bce846390884eaa3f58e0492d486f4" translate="yes" xml:space="preserve">
          <source>In multithreaded applications, implicit sharing takes place, as explained in &lt;a href=&quot;https://doc.qt.io/qt-5.13/threads-modules.html#threads-and-implicitly-shared-classes&quot;&gt;Threads and Implicitly Shared Classes&lt;/a&gt;.</source>
          <target state="translated">다중 스레드 응용 프로그램에서 &lt;a href=&quot;https://doc.qt.io/qt-5.13/threads-modules.html#threads-and-implicitly-shared-classes&quot;&gt;스레드 및 암시 적 공유 클래스에&lt;/a&gt; 설명 된대로 암시 적 공유가 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="933ee9e77d46ca8e86438896a8675d21f482a5d7" translate="yes" xml:space="preserve">
          <source>In multithreaded applications, implicit sharing takes place, as explained in &lt;a href=&quot;https://doc.qt.io/qt-5.15/threads-modules.html#threads-and-implicitly-shared-classes&quot;&gt;Threads and Implicitly Shared Classes&lt;/a&gt;.</source>
          <target state="translated">다중 스레드 응용 프로그램에서는 &lt;a href=&quot;https://doc.qt.io/qt-5.15/threads-modules.html#threads-and-implicitly-shared-classes&quot;&gt;스레드 및 암시 적 공유 클래스에&lt;/a&gt; 설명 된대로 암시 적 공유가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="a760f55348be40c6a588b0b017e92233afca46cb" translate="yes" xml:space="preserve">
          <source>In multithreaded applications, implicit sharing takes place, as explained in &lt;a href=&quot;https://doc.qt.io/qt-6.0/threads-modules.html#threads-and-implicitly-shared-classes&quot;&gt;Threads and Implicitly Shared Classes&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9dc95d48282ba6c9ac051d25113f7878c32facc8" translate="yes" xml:space="preserve">
          <source>In multithreaded applications, you can use &lt;a href=&quot;qtimer&quot;&gt;QTimer&lt;/a&gt; in any thread that has an event loop. To start an event loop from a non-GUI thread, use &lt;a href=&quot;qthread#exec&quot;&gt;QThread::exec&lt;/a&gt;(). Qt uses the timer's &lt;a href=&quot;qobject#thread&quot;&gt;thread affinity&lt;/a&gt; to determine which thread will emit the &lt;a href=&quot;qtimer#timeout&quot;&gt;timeout()&lt;/a&gt; signal. Because of this, you must start and stop the timer in its thread; it is not possible to start a timer from another thread.</source>
          <target state="translated">다중 스레드 응용 프로그램에서는 이벤트 루프가있는 모든 스레드에서 &lt;a href=&quot;qtimer&quot;&gt;QTimer&lt;/a&gt; 를 사용할 수 있습니다 . 비 GUI 스레드에서 이벤트 루프를 시작하려면 &lt;a href=&quot;qthread#exec&quot;&gt;QThread :: exec&lt;/a&gt; ()를 사용하십시오. Qt는 타이머의 &lt;a href=&quot;qobject#thread&quot;&gt;스레드 선호도&lt;/a&gt; 를 사용하여 &lt;a href=&quot;qtimer#timeout&quot;&gt;timeout ()&lt;/a&gt; 신호를 방출 할 스레드를 결정 합니다. 이 때문에 스레드에서 타이머를 시작하고 중지해야합니다. 다른 스레드에서 타이머를 시작할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="107ef5c0c80ad28ce250b248a591c1a309846695" translate="yes" xml:space="preserve">
          <source>In multithreaded applications, you can use QTimer in any thread that has an event loop. To start an event loop from a non-GUI thread, use &lt;a href=&quot;qthread#exec&quot;&gt;QThread::exec&lt;/a&gt;(). Qt uses the timer's &lt;a href=&quot;qobject#thread&quot;&gt;thread affinity&lt;/a&gt; to determine which thread will emit the &lt;a href=&quot;qtimer#timeout&quot;&gt;timeout()&lt;/a&gt; signal. Because of this, you must start and stop the timer in its thread; it is not possible to start a timer from another thread.</source>
          <target state="translated">다중 스레드 응용 프로그램에서는 이벤트 루프가있는 모든 스레드에서 QTimer를 사용할 수 있습니다. GUI가 아닌 스레드에서 이벤트 루프를 시작하려면 &lt;a href=&quot;qthread#exec&quot;&gt;QThread :: exec&lt;/a&gt; ()를 사용하십시오. Qt는 타이머의 &lt;a href=&quot;qobject#thread&quot;&gt;스레드 선호도&lt;/a&gt; 를 사용하여 &lt;a href=&quot;qtimer#timeout&quot;&gt;timeout ()&lt;/a&gt; 신호를 방출 할 스레드를 결정 합니다. 이 때문에 스레드에서 타이머를 시작하고 중지해야합니다. 다른 스레드에서 타이머를 시작할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="739ac81164da07ab48d8f4814e3fb516cf63658c" translate="yes" xml:space="preserve">
          <source>In multithreaded applications, you can use the timer mechanism in any thread that has an event loop. To start an event loop from a non-GUI thread, use &lt;a href=&quot;qthread#exec&quot;&gt;QThread::exec&lt;/a&gt;(). Qt uses the object's &lt;a href=&quot;qobject#thread&quot;&gt;thread affinity&lt;/a&gt; to determine which thread will deliver the &lt;a href=&quot;qtimerevent&quot;&gt;QTimerEvent&lt;/a&gt;. Because of this, you must start and stop all timers in the object's thread; it is not possible to start timers for objects in another thread.</source>
          <target state="translated">다중 스레드 응용 프로그램에서는 이벤트 루프가있는 모든 스레드에서 타이머 메커니즘을 사용할 수 있습니다. 비 GUI 스레드에서 이벤트 루프를 시작하려면 &lt;a href=&quot;qthread#exec&quot;&gt;QThread :: exec&lt;/a&gt; ()를 사용하십시오. Qt는 객체의 &lt;a href=&quot;qobject#thread&quot;&gt;스레드 선호도&lt;/a&gt; 를 사용하여 &lt;a href=&quot;qtimerevent&quot;&gt;QTimerEvent&lt;/a&gt; 를 전달할 스레드를 결정합니다 . 이 때문에 객체 스레드의 모든 타이머를 시작하고 중지해야합니다. 다른 스레드에서 객체의 타이머를 시작할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3ca4c9a93301656b1f48a6a5915c6b74365aac4f" translate="yes" xml:space="preserve">
          <source>In object mode, select the object.</source>
          <target state="translated">개체 모드에서 개체를 선택합니다.</target>
        </trans-unit>
        <trans-unit id="45ba01ce603721c5c3cdfd5374b21039c18778de" translate="yes" xml:space="preserve">
          <source>In order for &lt;code&gt;find_package&lt;/code&gt; to be successful, Qt 5 must be found below the CMAKE_PREFIX_PATH, or the &lt;code&gt;Qt5_DIR&lt;/code&gt; must be set in the &lt;code&gt;CMake&lt;/code&gt; cache to the location of the &lt;code&gt;Qt5Config.cmake&lt;/code&gt; file. The easiest way to use &lt;code&gt;CMake&lt;/code&gt; is to set the CMAKE_PREFIX_PATH environment variable to the install prefix of Qt 5.</source>
          <target state="translated">위해서는 &lt;code&gt;find_package&lt;/code&gt; 이 성공하려면, Qt는 5 CMAKE_PREFIX_PATH 아래에서 발견해야한다, 또는 &lt;code&gt;Qt5_DIR&lt;/code&gt; 은 설정해야합니다 &lt;code&gt;CMake&lt;/code&gt; 의 의 위치에 캐시 &lt;code&gt;Qt5Config.cmake&lt;/code&gt; 의 파일. &lt;code&gt;CMake&lt;/code&gt; 를 사용하는 가장 쉬운 방법 은 CMAKE_PREFIX_PATH 환경 변수를 Qt 5의 설치 접두어로 설정하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="273d0750c57092ee6ca57a6f1e9a7b1e391e9099" translate="yes" xml:space="preserve">
          <source>In order for Transition to correctly animate state changes, it is sometimes necessary for the engine to fast forward and rewind a state (that is, internally set and unset the state) before it is finally applied. The process is as follows:</source>
          <target state="translated">Transition이 상태 변경에 올바르게 애니메이션을 적용하기 위해 엔진이 최종 적용되기 전에 상태 (즉, 상태를 내부적으로 설정 및 설정 해제)로 빨리 감기 및 되감기해야하는 경우가 있습니다. 과정은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9d29bc5512257f9d56906cc19a69d3155049a056" translate="yes" xml:space="preserve">
          <source>In order for plugins to work correctly on all platforms, you need to ensure that they export the symbols needed by</source>
          <target state="translated">모든 플랫폼에서 플러그인이 올바르게 작동하려면 필요한 심볼을 내 보내야합니다.</target>
        </trans-unit>
        <trans-unit id="0a6f94686f76c9574e69b70f7c1db25e859ad3ce" translate="yes" xml:space="preserve">
          <source>In order for qmllint to work properly, it requires type information. That information is provided by qmltypes files. qmltypes files in the current directory, as well as those for Qt's built-in types, are discovered automatically. For qmltypes files from libraries that reside outside of the current directory, you can provide their path via the -I flag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d5d1e4bafd07a9fac3603a5110c7e5e85f15938" translate="yes" xml:space="preserve">
          <source>In order for the OpenCOLLADA exporter to be active, some options must be enabled or disabled in the &lt;code&gt;Plug-in Manager&lt;/code&gt;. To find it, go to &lt;b&gt;Window &amp;gt; Settings/Preferences &amp;gt; Plug-in Manager&lt;/b&gt;.</source>
          <target state="translated">OpenCOLLADA 내보내기를 활성화하려면 &lt;code&gt;Plug-in Manager&lt;/code&gt; 에서 일부 옵션을 활성화 또는 비활성화해야합니다 . 이를 찾으려면 &lt;b&gt;창&amp;gt; 설정 / 기본 설정&amp;gt; 플러그인 관리자로 이동하십시오&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="751af52cba3c3bdac047322a94b2f47a381b15c0" translate="yes" xml:space="preserve">
          <source>In order for the skeleton to have an effect, the model's &lt;a href=&quot;qml-qtquick3d-model#geometry-prop&quot;&gt;geometry&lt;/a&gt; needs to include skinning information. This is done by including &lt;a href=&quot;qquick3dgeometry#addAttribute&quot;&gt;vertex attributes&lt;/a&gt; with &lt;code&gt;JointSemantic&lt;/code&gt; and &lt;code&gt;WeightSemantic&lt;/code&gt; in the vertex buffer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10b438f20068ac31bda35998838ab5e66398e889" translate="yes" xml:space="preserve">
          <source>In order to &lt;a href=&quot;qremoteobjecthostbase#enableRemoting&quot;&gt;QRemoteObjectHost::enableRemoting&lt;/a&gt;() &lt;a href=&quot;qtremoteobjects-source#source&quot;&gt;Source&lt;/a&gt; objects over &lt;a href=&quot;qtremoteobjects-external-schemas#external-qiodevices&quot;&gt;External QIODevices&lt;/a&gt;, Qt Remote Objects needs access to the communications channel (a &lt;a href=&quot;qiodevice&quot;&gt;QIODevice&lt;/a&gt;) between the respective nodes. It is the addHostSideConnection() call that enables this on the &lt;a href=&quot;qtremoteobjects-source#source&quot;&gt;Source&lt;/a&gt; side, taking the</source>
          <target state="translated">하기 위해 &lt;a href=&quot;qremoteobjecthostbase#enableRemoting&quot;&gt;QRemoteObjectHost :: enableRemoting&lt;/a&gt; () &lt;a href=&quot;qtremoteobjects-source#source&quot;&gt;소스가&lt;/a&gt; 개체 &lt;a href=&quot;qtremoteobjects-external-schemas#external-qiodevices&quot;&gt;외부 QIODevices&lt;/a&gt; , Qt는 원격 통신 채널 (A에 요구 액세스 개체 &lt;a href=&quot;qiodevice&quot;&gt;QIODevice&lt;/a&gt; 각각의 노드 사이를). addHostSideConnection () 호출로 &lt;a href=&quot;qtremoteobjects-source#source&quot;&gt;소스&lt;/a&gt; 측에서 이를 가능하게 합니다.</target>
        </trans-unit>
        <trans-unit id="e9836ec8586dbb95dedd80563985226020c2de07" translate="yes" xml:space="preserve">
          <source>In order to &lt;a href=&quot;qremoteobjectnode#acquire&quot;&gt;QRemoteObjectNode::acquire&lt;/a&gt;() &lt;a href=&quot;qtremoteobjects-replica#replica&quot;&gt;Replica&lt;/a&gt; objects over &lt;a href=&quot;qtremoteobjects-external-schemas#external-qiodevices&quot;&gt;External QIODevices&lt;/a&gt;, Qt Remote Objects needs access to the communications channel (a &lt;a href=&quot;qiodevice&quot;&gt;QIODevice&lt;/a&gt;) between the respective nodes. It is the addClientSideConnection() call that enables this, taking the</source>
          <target state="translated">하기 위해 &lt;a href=&quot;qremoteobjectnode#acquire&quot;&gt;QRemoteObjectNode :: 취득&lt;/a&gt; () &lt;a href=&quot;qtremoteobjects-replica#replica&quot;&gt;복제가&lt;/a&gt; 개체 &lt;a href=&quot;qtremoteobjects-external-schemas#external-qiodevices&quot;&gt;외부 QIODevices&lt;/a&gt; , Qt는 원격 통신 채널 (A에 요구 액세스 개체 &lt;a href=&quot;qiodevice&quot;&gt;QIODevice&lt;/a&gt; 각각의 노드 사이를). 이를 가능하게하는 것은 addClientSideConnection () 호출입니다.</target>
        </trans-unit>
        <trans-unit id="30b280a0f639348b1558b91ca8e0cb63e767d4fa" translate="yes" xml:space="preserve">
          <source>In order to access in-app products from your application, you must register them in Google Play. Go to the &lt;b&gt;In-app products&lt;/b&gt; page and click &lt;b&gt;Add new product&lt;/b&gt;.</source>
          <target state="translated">애플리케이션에서 인앱 제품에 액세스하려면 Google Play에 제품을 등록해야합니다. &lt;b&gt;인앱 제품&lt;/b&gt; 페이지로 이동하여 &lt;b&gt;새 제품 추가를&lt;/b&gt; 클릭 &lt;b&gt;하십시오&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="5233b82e07c82933175c5f09dfc4d0290b374f52" translate="yes" xml:space="preserve">
          <source>In order to access in-app products from your application, you must register them to the Windows Store. Go the the &lt;b&gt;IAPs&lt;/b&gt; page and click &lt;b&gt;Create a new IAP&lt;/b&gt;.</source>
          <target state="translated">응용 프로그램에서 인앱 제품에 액세스하려면 Windows 스토어에 제품을 등록해야합니다. &lt;b&gt;IAP&lt;/b&gt; 페이지로 이동하여 &lt;b&gt;새 IAP 작성을&lt;/b&gt; 클릭 &lt;b&gt;하십시오&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="813cd9e0152da5629452ea757d91e732907fbf24" translate="yes" xml:space="preserve">
          <source>In order to accomplish cross-referencing, there needs to be a link between the original place and the favorited place and this is typically handled via an alternative identifier attribute. The favorited place contains an alternative identifier attribute which has the identifier of the original place.</source>
          <target state="translated">상호 참조를 수행하려면 원래 장소와 즐겨 찾는 장소 사이에 링크가 있어야하며 일반적으로 대체 식별자 속성을 통해 처리됩니다. 즐겨 찾는 장소에는 원래 장소의 식별자가있는 대체 식별자 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7654ffe5f59aa8b415f329e4d2a4f635740bcbc5" translate="yes" xml:space="preserve">
          <source>In order to accurately and quickly apply transformations and effects to items, Graphics View is built with the assumption that the user's hardware is able to provide reasonable performance for floating point instructions.</source>
          <target state="translated">변형 및 효과를 항목에 정확하고 신속하게 적용하기 위해 사용자의 하드웨어가 부동 소수점 명령어에 대해 합리적인 성능을 제공 할 수 있다는 가정하에 기하 창이 구축됩니다.</target>
        </trans-unit>
        <trans-unit id="d107a525685e68af28a5e7ff750440b98cb5f4f7" translate="yes" xml:space="preserve">
          <source>In order to allow in-app purchases in your application, register the products in your application. Start by creating an application-global instance of &lt;a href=&quot;qinappstore&quot;&gt;QInAppStore&lt;/a&gt;, and use the registerProduct() function to register each product.</source>
          <target state="translated">응용 프로그램에서 인앱 구매를 허용하려면 응용 프로그램에 제품을 등록하십시오. &lt;a href=&quot;qinappstore&quot;&gt;QInAppStore&lt;/a&gt; 의 애플리케이션 글로벌 인스턴스를 작성하여 시작 하고 registerProduct () 함수를 사용하여 각 제품을 등록하십시오.</target>
        </trans-unit>
        <trans-unit id="606b2c3b73681df340c8c9cff026d4849c2c1a79" translate="yes" xml:space="preserve">
          <source>In order to allow shader code to be written once in Qt applications and libraries, all shaders are expected to be written in a single language which is then compiled into SPIR-V. This shanding language is Vulkan-compatible GLSL at the moment. This is different from the OpenGL-style GLSL Qt 5.x expects. See the &lt;a href=&quot;https://github.com/KhronosGroup/GLSL/blob/master/extensions/khr/GL_KHR_vulkan_glsl.txt&quot;&gt;GL_KHR_vulkan_glsl specification&lt;/a&gt; for an overview of the differences.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac5886d32c751738229c75dd8e987ff557081068" translate="yes" xml:space="preserve">
          <source>In order to allow users to edit files with write permissions in a directory with restricted permissions, call setDirectWriteFallback() with</source>
          <target state="translated">권한이 제한된 디렉토리에서 사용자가 쓰기 권한이있는 파일을 편집 할 수있게하려면 setDirectWriteFallback ()을 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="10a4870692521fed0a531ef8286ef53c637bbc59" translate="yes" xml:space="preserve">
          <source>In order to append without inserting a new paragraph, call &lt;code&gt;myTextEdit.insert(myTextEdit.length, text)&lt;/code&gt; instead.</source>
          <target state="translated">새 단락을 삽입하지 않고 추가하려면 대신 &lt;code&gt;myTextEdit.insert(myTextEdit.length, text)&lt;/code&gt; 를 호출 하십시오 .</target>
        </trans-unit>
        <trans-unit id="27da4ea99eb2d7dbbc249d146c1f5ce076127b2c" translate="yes" xml:space="preserve">
          <source>In order to apply the values played back from the channels of data in the animation clip, the clip animator needs to have a &lt;a href=&quot;qt3danimation-qchannelmapper&quot;&gt;QChannelMapper&lt;/a&gt; object assigned to the &lt;a href=&quot;qt3danimation-qabstractclipanimator#channelMapper-prop&quot;&gt;channelMapper&lt;/a&gt; property.</source>
          <target state="translated">애니메이션 클립의 데이터 채널에서 재생되는 값을 적용하려면 클립 애니메이터 에 &lt;a href=&quot;qt3danimation-qabstractclipanimator#channelMapper-prop&quot;&gt;channelMapper&lt;/a&gt; 속성에 할당 된 &lt;a href=&quot;qt3danimation-qchannelmapper&quot;&gt;QChannelMapper&lt;/a&gt; 객체가 있어야 합니다.</target>
        </trans-unit>
        <trans-unit id="1b5921d05daeea9767841f5911250cc0691d8e18" translate="yes" xml:space="preserve">
          <source>In order to apply the values played back from the channels of data in the animation clip, the clip animator needs to have a ChannelMapper object assigned to the channelMapper property.</source>
          <target state="translated">애니메이션 클립의 데이터 채널에서 재생되는 값을 적용하려면 클립 애니메이터에 channelMapper 속성에 할당 된 ChannelMapper 객체가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="99b4d150c3515bcf7e23d650b6c2008ed79ae74e" translate="yes" xml:space="preserve">
          <source>In order to apply the values played back from the channels of data in the animation clip, the clip animator needs to have a QChannelMapper object assigned to the &lt;a href=&quot;qt3danimation-qabstractclipanimator#channelMapper-prop&quot;&gt;channelMapper&lt;/a&gt; property.</source>
          <target state="translated">애니메이션 클립의 데이터 채널에서 재생되는 값을 적용하려면 클립 애니메이터에 &lt;a href=&quot;qt3danimation-qabstractclipanimator#channelMapper-prop&quot;&gt;channelMapper&lt;/a&gt; 속성에 QChannelMapper 객체가 할당되어 있어야 합니다.</target>
        </trans-unit>
        <trans-unit id="9eedf5f587698ff08fe02d8f6da9afd8ec0c528d" translate="yes" xml:space="preserve">
          <source>In order to avoid confusion, do not put two groups of radio buttons next to each other.</source>
          <target state="translated">혼동을 피하기 위해 두 그룹의 라디오 버튼을 나란히 두지 마십시오.</target>
        </trans-unit>
        <trans-unit id="e6b2394d0e8025876c5e81fb5fca85edcc30d366" translate="yes" xml:space="preserve">
          <source>In order to avoid this worst-case behavior, the calculation of the hash value done by &lt;a href=&quot;qhash#qHashx&quot;&gt;qHash&lt;/a&gt;() can be salted by a random seed, that nullifies the attack's extent. This seed is automatically generated by &lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt; once per process, and then passed by &lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt; as the second argument of the two-arguments overload of the &lt;a href=&quot;qhash#qHashx&quot;&gt;qHash&lt;/a&gt;() function.</source>
          <target state="translated">이 최악의 동작을 피하기 위해 &lt;a href=&quot;qhash#qHashx&quot;&gt;qHash&lt;/a&gt; ()에 의해 수행 된 해시 값의 계산은 임의의 시드에 의해 염려 될 수 있으며, 이는 공격의 범위를 무효화합니다. 이 시드는 프로세스 당 한 번씩 &lt;a href=&quot;qhash#qhash&quot;&gt;QHash에&lt;/a&gt; 의해 자동으로 생성 된 다음 &lt;a href=&quot;qhash#qHashx&quot;&gt;qHash&lt;/a&gt; () 함수 의 두 인수 과부하의 두 번째 인수로 &lt;a href=&quot;qhash#qhash&quot;&gt;QHash에&lt;/a&gt; 의해 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="926d3cee39fbe558fdc2230dc61692b10c1a5409" translate="yes" xml:space="preserve">
          <source>In order to avoid this worst-case behavior, the calculation of the hash value done by &lt;a href=&quot;qhash#qHashx&quot;&gt;qHash&lt;/a&gt;() can be salted by a random seed, that nullifies the attack's extent. This seed is automatically generated by QHash once per process, and then passed by QHash as the second argument of the two-arguments overload of the &lt;a href=&quot;qhash#qHashx&quot;&gt;qHash&lt;/a&gt;() function.</source>
          <target state="translated">이러한 최악의 행동을 피하기 위해 &lt;a href=&quot;qhash#qHashx&quot;&gt;qHash&lt;/a&gt; ()에 의해 수행 된 해시 값의 계산은 공격 범위를 무효화하는 임의의 시드에 의해 솔트 될 수 있습니다. 이 시드는 프로세스 당 한 번씩 QHash에 의해 자동으로 생성 된 다음 &lt;a href=&quot;qhash#qHashx&quot;&gt;qHash&lt;/a&gt; () 함수 의 두 인수 오버로드의 두 번째 인수로 QHash에 의해 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="bfa17f101dcbd4e9710c799e2b5dc56691a4bdba" translate="yes" xml:space="preserve">
          <source>In order to be able to handle relative paths, this method takes an optional</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd4ac30d665c227ccd3175246c4999850e299e04" translate="yes" xml:space="preserve">
          <source>In order to be considered &quot;canonical&quot;, a CBOR stream must meet the following requirements:</source>
          <target state="translated">&quot;정식&quot;으로 간주 되려면 CBOR 스트림이 다음 요구 사항을 충족해야합니다.</target>
        </trans-unit>
        <trans-unit id="a8773022e28cbabc01911661d6e667737b76af71" translate="yes" xml:space="preserve">
          <source>In order to behave asynchronously and not introduce stutters or freezes in an application, the process of creating objects a QQmlIncubators must be driven only during the application's idle time. &lt;a href=&quot;qqmlincubationcontroller&quot;&gt;QQmlIncubationController&lt;/a&gt; allows the application to control exactly when, how often and for how long this processing occurs.</source>
          <target state="translated">비동기식으로 작동하고 응용 프로그램에서 정지 또는 정지를 일으키지 않기 위해 QQmlIncubators를 생성하는 프로세스는 응용 프로그램의 유휴 시간 동안에 만 구동되어야합니다. &lt;a href=&quot;qqmlincubationcontroller&quot;&gt;QQmlIncubationController를&lt;/a&gt; 사용하면 응용 프로그램에서이 처리가 발생하는시기, 빈도 및 기간을 정확하게 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4392c01d24cac5c444f4f852a738c8c60c7e6bcc" translate="yes" xml:space="preserve">
          <source>In order to behave asynchronously and not introduce stutters or freezes in an application, the process of creating objects a QQmlIncubators must be driven only during the application's idle time. QQmlIncubationController allows the application to control exactly when, how often and for how long this processing occurs.</source>
          <target state="translated">비동기 적으로 동작하고 응용 프로그램에서 끊김이나 멈춤 현상을 일으키지 않으려면 QQmlIncubator를 만드는 개체를 만드는 프로세스는 응용 프로그램의 유휴 시간 동안에 만 구동되어야합니다. QQmlIncubationController를 사용하면 애플리케이션이이 처리가 발생하는시기, 빈도 및 기간을 정확하게 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eab7a0bf94f2e52c8b8a60bc41a1dab7327116a0" translate="yes" xml:space="preserve">
          <source>In order to cause the window to be centered above its transient</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbca8baadc999b96b836a9b38d1b87445b3753f6" translate="yes" xml:space="preserve">
          <source>In order to cause the window to be centered above its transient parent by default, depending on the window manager, it may also be necessary to set the &lt;a href=&quot;qml-qtquick-window-window#flags-prop&quot;&gt;Window::flags&lt;/a&gt; property with a suitable &lt;a href=&quot;qt#WindowType-enum&quot;&gt;Qt::WindowType&lt;/a&gt; (such as &lt;code&gt;Qt::Dialog&lt;/code&gt;).</source>
          <target state="translated">윈도우 관리자에 따라 윈도우가 기본적으로 일시적인 부모 위에 가운데에 &lt;a href=&quot;qt#WindowType-enum&quot;&gt;오게하려면&lt;/a&gt; 적절한 Qt :: WindowType (예 : &lt;code&gt;Qt::Dialog&lt;/code&gt; ) 으로 &lt;a href=&quot;qml-qtquick-window-window#flags-prop&quot;&gt;Window :: flags&lt;/a&gt; 속성 을 설정해야 할 수도 있습니다. .</target>
        </trans-unit>
        <trans-unit id="6ead02df7a2891508aad6cc1deb3cb1f3b8e3594" translate="yes" xml:space="preserve">
          <source>In order to cause the window to be centered above its transient parent by default, depending on the window manager, it may also be necessary to set the &lt;a href=&quot;qml-window#flags-prop&quot;&gt;Window::flags&lt;/a&gt; property with a suitable &lt;a href=&quot;qt#WindowType-enum&quot;&gt;Qt::WindowType&lt;/a&gt; (such as &lt;code&gt;Qt::Dialog&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a52ec2b4f643adf51bba1888c621570cd78b8728" translate="yes" xml:space="preserve">
          <source>In order to cause the window to be centered above its transient parent by default, depending on the window manager, it may also be necessary to set the &lt;a href=&quot;qwindow#flags-prop&quot;&gt;flags&lt;/a&gt; property with a suitable &lt;a href=&quot;qt#WindowType-enum&quot;&gt;Qt::WindowType&lt;/a&gt; (such as &lt;code&gt;Qt::Dialog&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07ac98914dfe8f4e4136c600d1f65ff9c9cfe3e2" translate="yes" xml:space="preserve">
          <source>In order to conform to C/C++ naming conventions &quot;Dir&quot; is prepended to the codes used in the Unicode Standard.</source>
          <target state="translated">C / C ++ 이름 지정 규칙을 준수하기 위해 &quot;Dir&quot;이 유니 코드 표준에서 사용되는 코드 앞에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="9e1e682d0fc9b26f29b52c7416d19029656145ab" translate="yes" xml:space="preserve">
          <source>In order to conform to C/C++ naming conventions &quot;Joining_&quot; is prepended to the codes used in the Unicode Standard.</source>
          <target state="translated">C / C ++ 명명 규칙을 준수하기 위해 &quot;Joining_&quot;이 유니 코드 표준에 사용 된 코드 앞에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="eb270840e76faff8640691680236b1a394ebf5dd" translate="yes" xml:space="preserve">
          <source>In order to conform to C/C++ naming conventions &quot;Script_&quot; is prepended to the codes used in the Unicode Standard.</source>
          <target state="translated">C / C ++ 이름 지정 규칙을 준수하기 위해 &quot;Script_&quot;가 유니 코드 표준에 사용 된 코드 앞에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="9af9f0c87800086847f3e1f36a0a32ac193b32fa" translate="yes" xml:space="preserve">
          <source>In order to construct a correctly functioning framegraph tree, you should know a few rules about how it is traversed and how to feed it to the Qt 3D renderer.</source>
          <target state="translated">올바르게 작동하는 프레임 그래프 트리를 구성하려면 트래버스 방법과이를 Qt 3D 렌더러에 공급하는 방법에 대한 몇 가지 규칙을 알아야합니다.</target>
        </trans-unit>
        <trans-unit id="f18ba4a788703fe91904fb4d556a9b828358a7a0" translate="yes" xml:space="preserve">
          <source>In order to customize an existing style, inherit &lt;a href=&quot;qproxystyle&quot;&gt;QProxyStyle&lt;/a&gt; and reimplement the desired virtual methods. &lt;a href=&quot;qproxystyle&quot;&gt;QProxyStyle&lt;/a&gt; allows one to specify a certain base style, or it will automatically use the application style when the base style is left unspecified. The former gives a full control on the base style and works best if the customization expects a certain style behavior, whereas the latter provides a platform agnostic way to customize the application style that defaults to the native platform style.</source>
          <target state="translated">기존 스타일을 사용자 정의하려면 &lt;a href=&quot;qproxystyle&quot;&gt;QProxyStyle을&lt;/a&gt; 상속 하고 원하는 가상 메소드를 다시 구현하십시오. &lt;a href=&quot;qproxystyle&quot;&gt;QProxyStyle&lt;/a&gt; 을 사용하면 특정 기본 스타일을 지정할 수 있으며 기본 스타일을 지정하지 않은 경우 자동으로 응용 프로그램 스타일을 사용합니다. 전자는 기본 스타일을 완전히 제어하고 사용자 정의가 특정 스타일 동작을 예상하는 경우 가장 잘 작동하는 반면, 후자는 기본 플랫폼 스타일을 기본으로하는 애플리케이션 스타일을 사용자 정의하는 플랫폼에 무관 한 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="7b8e427a12f9166e734e17315c12bed4668cff8d" translate="yes" xml:space="preserve">
          <source>In order to determine what options an image handler supports, Qt will call &lt;a href=&quot;qimageiohandler#supportsOption&quot;&gt;supportsOption&lt;/a&gt;() and &lt;a href=&quot;qimageiohandler#setOption&quot;&gt;setOption&lt;/a&gt;(). Make sure to reimplement these functions if you can provide support for any of the options in the &lt;a href=&quot;qimageiohandler#ImageOption-enum&quot;&gt;ImageOption&lt;/a&gt; enum.</source>
          <target state="translated">이미지 핸들러가 지원하는 옵션을 결정하기 위해 Qt는 &lt;a href=&quot;qimageiohandler#supportsOption&quot;&gt;supportsOption&lt;/a&gt; () 및 &lt;a href=&quot;qimageiohandler#setOption&quot;&gt;setOption&lt;/a&gt; ()을 호출 합니다 . &lt;a href=&quot;qimageiohandler#ImageOption-enum&quot;&gt;ImageOption&lt;/a&gt; 열거 형 의 옵션을 지원할 수있는 경우 이러한 기능을 다시 구현하십시오 .</target>
        </trans-unit>
        <trans-unit id="4cfe698a4ad29b789ea1afc2062ba97f1174b270" translate="yes" xml:space="preserve">
          <source>In order to do so, you can create a &lt;a href=&quot;qopengldebugmessage&quot;&gt;QOpenGLDebugMessage&lt;/a&gt; object by calling &lt;a href=&quot;qopengldebugmessage#createApplicationMessage&quot;&gt;createApplicationMessage()&lt;/a&gt; or &lt;a href=&quot;qopengldebugmessage#createThirdPartyMessage&quot;&gt;createThirdPartyMessage()&lt;/a&gt;, and then inserting it into the log by calling &lt;a href=&quot;qopengldebuglogger#logMessage&quot;&gt;logMessage&lt;/a&gt;():</source>
          <target state="translated">그렇게하려면 &lt;a href=&quot;qopengldebugmessage#createApplicationMessage&quot;&gt;createApplicationMessage ()&lt;/a&gt; 또는 &lt;a href=&quot;qopengldebugmessage#createThirdPartyMessage&quot;&gt;createThirdPartyMessage ()&lt;/a&gt; 를 호출 한 다음 &lt;a href=&quot;qopengldebuglogger#logMessage&quot;&gt;logMessage&lt;/a&gt; () 를 호출하여 로그에 삽입 하여 &lt;a href=&quot;qopengldebugmessage&quot;&gt;QOpenGLDebugMessage&lt;/a&gt; 오브젝트를 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f758463f5cdf5461c20dde0c0676e9f09517772c" translate="yes" xml:space="preserve">
          <source>In order to draw one element from a model, a view (through its delegates) will generally request multiple roles for the same index by calling &lt;code&gt;data()&lt;/code&gt; as many times as needed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3332997d32b1ce89721edcd4aeaeb1d3f5900b42" translate="yes" xml:space="preserve">
          <source>In order to ensure drag operations work properly, it is important to reimplement the following functions that remove data from the model:</source>
          <target state="translated">드래그 작업이 제대로 작동하려면 모델에서 데이터를 제거하는 다음 기능을 다시 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="c171a6fd49179a1e32af671ec262c87073e91ab4" translate="yes" xml:space="preserve">
          <source>In order to ensure that a popup is displayed above other items in the scene, it is recommended to use &lt;a href=&quot;qml-qtquick-controls2-applicationwindow&quot;&gt;ApplicationWindow&lt;/a&gt;. &lt;a href=&quot;qml-qtquick-controls2-applicationwindow&quot;&gt;ApplicationWindow&lt;/a&gt; also provides background dimming effects.</source>
          <target state="translated">장면에서 다른 항목 위에 팝업이 표시되도록하려면 &lt;a href=&quot;qml-qtquick-controls2-applicationwindow&quot;&gt;ApplicationWindow&lt;/a&gt; 를 사용하는 것이 좋습니다 . &lt;a href=&quot;qml-qtquick-controls2-applicationwindow&quot;&gt;ApplicationWindow&lt;/a&gt; 는 배경 디밍 효과도 제공합니다.</target>
        </trans-unit>
        <trans-unit id="1746cfd97b27b008e9ba50f3292417b2a2315d6e" translate="yes" xml:space="preserve">
          <source>In order to ensure that a popup is displayed above other items in the scene, it is recommended to use &lt;a href=&quot;qtquickcontrols-changes-qt6#applicationwindow&quot;&gt;ApplicationWindow&lt;/a&gt;. &lt;a href=&quot;qtquickcontrols-changes-qt6#applicationwindow&quot;&gt;ApplicationWindow&lt;/a&gt; also provides background dimming effects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ff3f293b7985b97460b900c816c723e46801887" translate="yes" xml:space="preserve">
          <source>In order to export as FBX, you must have the FBX export add-on installed and enabled in Blender. With the default installation of Blender, the &lt;code&gt;Import-Export: FBX format&lt;/code&gt; should be installed. If you do not have the option to export as FBX avaialble, ensure that the add-on is enabled by following the steps:</source>
          <target state="translated">FBX로 내보내려면 Blender에서 FBX 내보내기 애드온을 설치하고 활성화해야합니다. 블렌더의 기본 설치로 &lt;code&gt;Import-Export: FBX format&lt;/code&gt; 이 설치되어야합니다. 사용 가능한 FBX로 내보낼 수있는 옵션이없는 경우 다음 단계에 따라 추가 기능이 활성화되어 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="dbbcaa1b4c6c581f9b2c0adf80607868930c75d7" translate="yes" xml:space="preserve">
          <source>In order to facilitate verification of the most common D-Bus errors generated by the D-Bus implementation and by the bus daemon itself, &lt;a href=&quot;qdbuserror&quot;&gt;QDBusError&lt;/a&gt; can be compared to a set of pre-defined values:</source>
          <target state="translated">D-Bus 구현 및 버스 데몬 자체에서 생성 된 가장 일반적인 D-Bus 오류를 &lt;a href=&quot;qdbuserror&quot;&gt;쉽게&lt;/a&gt; 확인할 수 있도록 QDBusError 를 사전 정의 된 값 세트와 비교할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf5422c9a0bf4e432d87ea7ba1d07e96bffd9fbe" translate="yes" xml:space="preserve">
          <source>In order to generate such messages, you need to enable the informational output for the &lt;code&gt;qt.qml.binding.removal&lt;/code&gt; logging category, for instance by calling:</source>
          <target state="translated">이러한 메시지를 생성하려면 다음을 호출 하여 &lt;code&gt;qt.qml.binding.removal&lt;/code&gt; 로깅 범주에 대한 정보 출력을 사용 가능하게해야합니다 .</target>
        </trans-unit>
        <trans-unit id="b0e18dd8d9382b9e4ab6eff01b7ac89dd4470580" translate="yes" xml:space="preserve">
          <source>In order to get an application designed for low DPI values running on a high resolution monitors quickly, consider one of the scaling options (let the application run as</source>
          <target state="translated">고해상도 모니터에서 실행되는 낮은 DPI 값을 위해 설계된 응용 프로그램을 빠르게 얻으려면 확장 옵션 중 하나를 고려하십시오 (응용 프로그램을</target>
        </trans-unit>
        <trans-unit id="05788d09e0bce3911756b506eda62412477e1884" translate="yes" xml:space="preserve">
          <source>In order to help applications migrate from OpenGL-based code without having to flip Y coordinates in the vertex data, and to allow using &lt;a href=&quot;qmatrix4x4&quot;&gt;QMatrix4x4&lt;/a&gt; functions like &lt;a href=&quot;qmatrix4x4#perspective&quot;&gt;QMatrix4x4::perspective&lt;/a&gt;() while keeping the Vulkan viewport's minDepth and maxDepth set to 0 and 1, &lt;a href=&quot;qvulkanwindow&quot;&gt;QVulkanWindow&lt;/a&gt; provides a correction matrix retrievable by calling &lt;a href=&quot;qvulkanwindow#clipCorrectionMatrix&quot;&gt;clipCorrectionMatrix&lt;/a&gt;().</source>
          <target state="translated">정점 데이터에서 Y 좌표를 &lt;a href=&quot;qmatrix4x4&quot;&gt;뒤집지&lt;/a&gt; 않고도 OpenGL 기반 코드에서 응용 프로그램을 마이그레이션 하고 Vulkan 뷰포트의 minDepth 및 maxDepth를 0과 1로 유지하면서 &lt;a href=&quot;qmatrix4x4#perspective&quot;&gt;QMatrix4x4 :: perspective&lt;/a&gt; () 와 같은 QMatrix4x4 함수 를 사용할 수 있도록 &lt;a href=&quot;qvulkanwindow&quot;&gt;QVulkanWindow &lt;/a&gt;&lt;a href=&quot;qvulkanwindow#clipCorrectionMatrix&quot;&gt;clipCorrectionMatrix&lt;/a&gt; () 를 호출하여 검색 가능한 수정 매트릭스를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="c89b568ea317b80810ac6ef26edda8cf60b1bc7d" translate="yes" xml:space="preserve">
          <source>In order to help applications migrate from OpenGL-based code without having to flip Y coordinates in the vertex data, and to allow using &lt;a href=&quot;qmatrix4x4&quot;&gt;QMatrix4x4&lt;/a&gt; functions like &lt;a href=&quot;qmatrix4x4#perspective&quot;&gt;QMatrix4x4::perspective&lt;/a&gt;() while keeping the Vulkan viewport's minDepth and maxDepth set to 0 and 1, QVulkanWindow provides a correction matrix retrievable by calling &lt;a href=&quot;qvulkanwindow#clipCorrectionMatrix&quot;&gt;clipCorrectionMatrix&lt;/a&gt;().</source>
          <target state="translated">Vulkan 뷰포트의 minDepth 및 maxDepth를 0과 1로 설정 한 상태로 유지하면서 정점 데이터에서 Y 좌표를 &lt;a href=&quot;qmatrix4x4&quot;&gt;뒤집지&lt;/a&gt; 않고 OpenGL 기반 코드에서 응용 프로그램을 마이그레이션하고 &lt;a href=&quot;qmatrix4x4#perspective&quot;&gt;QMatrix4x4 :: perspective&lt;/a&gt; () 와 같은 QMatrix4x4 함수 를 사용할 수 있도록하기 위해 QVulkanWindow &lt;a href=&quot;qvulkanwindow#clipCorrectionMatrix&quot;&gt;clipCorrectionMatrix&lt;/a&gt; () 를 호출하여 검색 할 수있는 수정 행렬을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="352f9d1daa19e27628f8adbbf3e6bb3b572f385a" translate="yes" xml:space="preserve">
          <source>In order to improve rendering performance, objects that are very small can be rendered using far fewer details, in geometry or texture.</source>
          <target state="translated">렌더링 성능을 향상시키기 위해 지오메트리 또는 텍스쳐에서 훨씬 작은 디테일을 사용하여 매우 작은 객체를 렌더링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="adf46a9b2ab0abcc4529b05d713981200646ea92" translate="yes" xml:space="preserve">
          <source>In order to invoke the action, &lt;a href=&quot;qaccessibleactioninterface#doAction&quot;&gt;doAction&lt;/a&gt;() is called with an action name.</source>
          <target state="translated">조치를 호출하기 위해 &lt;a href=&quot;qaccessibleactioninterface#doAction&quot;&gt;doAction&lt;/a&gt; ()이 조치 이름으로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="30c723dfd3494d19b1d8256d9a098a1871b1c594" translate="yes" xml:space="preserve">
          <source>In order to make it possible for Qt Quick Controls 2 to find the configuration file, it must be built into application's resources using the &lt;a href=&quot;resources&quot;&gt;The Qt Resource System&lt;/a&gt;. Here's an example &lt;code&gt;.qrc&lt;/code&gt; file:</source>
          <target state="translated">Qt Quick Controls 2가 구성 파일을 찾을 수있게하려면 &lt;a href=&quot;resources&quot;&gt;Qt 자원 시스템을&lt;/a&gt; 사용하여 응용 프로그램의 자원으로 빌드해야합니다 . &lt;code&gt;.qrc&lt;/code&gt; 파일 의 예는 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="109fc8f4542a13adb137e40f040addcd8fe17f42" translate="yes" xml:space="preserve">
          <source>In order to make it possible for Qt Quick Controls to find the configuration file, it must be built into application's resources using the &lt;a href=&quot;resources&quot;&gt;The Qt Resource System&lt;/a&gt;. Here's an example &lt;code&gt;.qrc&lt;/code&gt; file:</source>
          <target state="translated">Qt Quick Controls가 구성 파일을 찾을 수 있도록하려면 &lt;a href=&quot;resources&quot;&gt;The Qt Resource System을&lt;/a&gt; 사용하여 애플리케이션의 리소스에 빌드해야합니다 . 다음은 &lt;code&gt;.qrc&lt;/code&gt; 파일 의 예입니다 .</target>
        </trans-unit>
        <trans-unit id="c293186fef6700bd78044fbc053ecf384b85c4d2" translate="yes" xml:space="preserve">
          <source>In order to modify your dialog's close behavior, you can reimplement the functions &lt;a href=&quot;qdialog#accept&quot;&gt;accept&lt;/a&gt;(), &lt;a href=&quot;qdialog#reject&quot;&gt;reject&lt;/a&gt;() or &lt;a href=&quot;qdialog#done&quot;&gt;done&lt;/a&gt;(). The &lt;a href=&quot;qwidget#closeEvent&quot;&gt;closeEvent()&lt;/a&gt; function should only be reimplemented to preserve the dialog's position or to override the standard close or reject behavior.</source>
          <target state="translated">대화 상자의 닫기 동작을 수정하기 위해 &lt;a href=&quot;qdialog#accept&quot;&gt;accept&lt;/a&gt; (), &lt;a href=&quot;qdialog#reject&quot;&gt;reject&lt;/a&gt; () 또는 &lt;a href=&quot;qdialog#done&quot;&gt;done&lt;/a&gt; () 함수 를 다시 구현할 수 있습니다 . &lt;a href=&quot;qwidget#closeEvent&quot;&gt;closeEvent ()&lt;/a&gt; 함수는 대화 상자의 위치를 유지하기 위해 또는 표준 가까이를 무시하거나 동작을 거부하는 재 구현해야한다.</target>
        </trans-unit>
        <trans-unit id="595db3f0857c6c9533d3516b74fb18708745016c" translate="yes" xml:space="preserve">
          <source>In order to only set a mouse cursor shape for a region without reacting to mouse events set the &lt;a href=&quot;qml-qtquick-mousearea#acceptedButtons-prop&quot;&gt;acceptedButtons&lt;/a&gt; to none:</source>
          <target state="translated">마우스 이벤트에 반응하지 않고 영역의 마우스 커서 모양 만 설정하려면 &lt;a href=&quot;qml-qtquick-mousearea#acceptedButtons-prop&quot;&gt;acceptButtons&lt;/a&gt; 를 none으로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="ed7e7f5f7cec0ce5fe90c693f441ab5123bc40f8" translate="yes" xml:space="preserve">
          <source>In order to parse standalone documents that do use undeclared namespace prefixes, you can turn off namespace processing completely with the &lt;a href=&quot;qxmlstreamreader#namespaceProcessing-prop&quot;&gt;namespaceProcessing&lt;/a&gt; property.</source>
          <target state="translated">In order to parse standalone documents that do use undeclared namespace prefixes, you can turn off namespace processing completely with the &lt;a href=&quot;qxmlstreamreader#namespaceProcessing-prop&quot;&gt;namespaceProcessing&lt;/a&gt; property.</target>
        </trans-unit>
        <trans-unit id="22488f2fb9bc31cc03c8ffece771f6c5dad33dea" translate="yes" xml:space="preserve">
          <source>In order to perform a match you can simply invoke the &lt;a href=&quot;qregularexpression#match&quot;&gt;match&lt;/a&gt;() function passing a string to match against. We refer to this string as the</source>
          <target state="translated">In order to perform a match you can simply invoke the &lt;a href=&quot;qregularexpression#match&quot;&gt;match&lt;/a&gt;() function passing a string to match against. We refer to this string as the</target>
        </trans-unit>
        <trans-unit id="27d9746de5d1bd667c997070120c7089cb319c69" translate="yes" xml:space="preserve">
          <source>In order to perform a search operation we simply create a &lt;a href=&quot;qplacesearchrequest&quot;&gt;QPlaceSearchRequest&lt;/a&gt; and set the desired search parameters, such as a search term and search center.</source>
          <target state="translated">In order to perform a search operation we simply create a &lt;a href=&quot;qplacesearchrequest&quot;&gt;QPlaceSearchRequest&lt;/a&gt; and set the desired search parameters, such as a search term and search center.</target>
        </trans-unit>
        <trans-unit id="990dae2ac10c8c0c0c07be8097513e57dbe9f673" translate="yes" xml:space="preserve">
          <source>In order to perform an action when the value for a particular handle changes, use the following syntax:</source>
          <target state="translated">In order to perform an action when the value for a particular handle changes, use the following syntax:</target>
        </trans-unit>
        <trans-unit id="9d8cc764d2636377c9d350844454983b703891c4" translate="yes" xml:space="preserve">
          <source>In order to perform the matching, we create a &lt;a href=&quot;qplacematchrequest&quot;&gt;QPlaceMatchRequest&lt;/a&gt; and assign it the search results from the origin manager. The &lt;a href=&quot;qplacematchrequest&quot;&gt;QPlaceMatchRequest&lt;/a&gt; will be used on the destination manager to return corresponding places. We also specify matching parameters which are key value pairs. As mentioned previously, this can vary depending on the manager but typically the key is &lt;a href=&quot;qplacematchrequest#AlternativeId-var&quot;&gt;QPlaceMatchRequest::AlternativeId&lt;/a&gt; to indicate we are matching by alternative id, the value in this case would be x_id_here which specifies which alternative identifier attribute we are using to do the matching.</source>
          <target state="translated">일치를 수행하기 위해 &lt;a href=&quot;qplacematchrequest&quot;&gt;QPlaceMatchRequest를&lt;/a&gt; 작성 하고 원점 관리자의 검색 결과를 지정합니다. &lt;a href=&quot;qplacematchrequest&quot;&gt;QPlaceMatchRequest는&lt;/a&gt; 해당 장소를 반환 대상 관리에 사용됩니다. 또한 키 값 쌍인 일치하는 매개 변수를 지정합니다. 앞에서 언급했듯이 이것은 관리자에 따라 다를 수 있지만 일반적으로 키는 대체 ID로 일치하고 있음을 나타 내기 위해 &lt;a href=&quot;qplacematchrequest#AlternativeId-var&quot;&gt;QPlaceMatchRequest :: AlternativeId&lt;/a&gt; 입니다.이 경우 값은 x_id_here이며 일치하는 작업을 수행하는 데 사용하는 대체 식별자 속성을 지정합니다. .</target>
        </trans-unit>
        <trans-unit id="a6dbd5164517c2126a3c5d4152236f8f3118599e" translate="yes" xml:space="preserve">
          <source>In order to preserve the trust of users, QML application developers should not load and execute arbitrary JavaScript or QML resources. For example, consider the QML code below:</source>
          <target state="translated">사용자의 신뢰를 유지하기 위해 QML 애플리케이션 개발자는 임의의 JavaScript 또는 QML 자원을로드하고 실행해서는 안됩니다. 예를 들어 아래 QML 코드를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="b6e99a203dfdb0f33a5655989b6755ddb0403b5a" translate="yes" xml:space="preserve">
          <source>In order to preserve the trust of users, application developers should not evaluate arbitrary JavaScript code. The JavaScript engine's sandbox is only a semantic barrier. The script is evaluated in the same process and with the same privileges as the rest of the application and shares the same memory. As a consequence, C++ objects exposed to scripts are accessible without additional security guards.</source>
          <target state="translated">사용자의 신뢰를 유지하기 위해 응용 프로그램 개발자는 임의의 JavaScript 코드를 평가해서는 안됩니다. JavaScript 엔진의 샌드 박스는 의미 상 장벽 일뿐입니다. 스크립트는 동일한 프로세스에서 나머지 응용 프로그램과 동일한 권한으로 평가되며 동일한 메모리를 공유합니다. 결과적으로 스크립트에 노출 된 C ++ 오브젝트는 추가 보안 담당자없이 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="762fba914ff16b1c9d3cb7722b8c65aee3c0b035" translate="yes" xml:space="preserve">
          <source>In order to purchase a product, call the object's purchase() method. This launches a platform-specific, asynchronous process to purchase the product, for example by requesting the user's password and confirmation of the purchase. In most cases, you should make sure that the application UI is not accepting input while the purchasing request is being processed, as this is not handled automatically on all platforms.</source>
          <target state="translated">제품을 구매하려면 객체의 purchase () 메소드를 호출하십시오. 예를 들어, 사용자 비밀번호를 요청하고 구매를 확인하여 제품을 구매하기위한 플랫폼 별 비동기 프로세스가 시작됩니다. 대부분의 경우 구매 요청이 처리되는 동안 응용 프로그램 UI가 입력을 수락하지 않는지 확인해야합니다. 이는 모든 플랫폼에서 자동으로 처리되지 않기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="58771b56f861325466bbe8868ec03f5ee285687e" translate="yes" xml:space="preserve">
          <source>In order to receive mouse movement events, the preceding mouse press event must be accepted (by overriding &lt;a href=&quot;qquickitem#mousePressEvent&quot;&gt;mousePressEvent&lt;/a&gt;(), for example) and &lt;a href=&quot;qquickitem#acceptedMouseButtons&quot;&gt;acceptedMouseButtons&lt;/a&gt;() must return the relevant mouse button.</source>
          <target state="translated">마우스 이동 이벤트를 수신하기 위해, 앞의 마우스를 눌러 이벤트 (재정 의하여 인정해야 &lt;a href=&quot;qquickitem#mousePressEvent&quot;&gt;mousePressEvent&lt;/a&gt; 및 예 ()) &lt;a href=&quot;qquickitem#acceptedMouseButtons&quot;&gt;acceptedMouseButtons를&lt;/a&gt; 관련 마우스 버튼을 반환해야합니다 ().</target>
        </trans-unit>
        <trans-unit id="944d91ab59ba82d14656dded84e0977b699fdac1" translate="yes" xml:space="preserve">
          <source>In order to receive mouse press events, &lt;a href=&quot;qquickitem#acceptedMouseButtons&quot;&gt;acceptedMouseButtons&lt;/a&gt;() must return the relevant mouse button.</source>
          <target state="translated">마우스 누르기 이벤트를 수신하려면 &lt;a href=&quot;qquickitem#acceptedMouseButtons&quot;&gt;acceptMouseButtons&lt;/a&gt; ()는 관련 마우스 버튼을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="034f4e178ca638e5d3b47e5344b72326da0c9d38" translate="yes" xml:space="preserve">
          <source>In order to receive mouse release events, the preceding mouse press event must be accepted (by overriding &lt;a href=&quot;qquickitem#mousePressEvent&quot;&gt;mousePressEvent&lt;/a&gt;(), for example) and &lt;a href=&quot;qquickitem#acceptedMouseButtons&quot;&gt;acceptedMouseButtons&lt;/a&gt;() must return the relevant mouse button.</source>
          <target state="translated">마우스 놓기 이벤트를 수신하기 위해, 앞의 마우스를 눌러 이벤트 (재정 의하여 인정해야 &lt;a href=&quot;qquickitem#mousePressEvent&quot;&gt;mousePressEvent&lt;/a&gt; 및 예 ()) &lt;a href=&quot;qquickitem#acceptedMouseButtons&quot;&gt;acceptedMouseButtons를&lt;/a&gt; 관련 마우스 버튼을 반환해야합니다 ().</target>
        </trans-unit>
        <trans-unit id="e65580b7a71f4b74e660a49e586e196f6738956f" translate="yes" xml:space="preserve">
          <source>In order to restore and activate a minimized window (while preserving its maximized and/or full-screen state), use the following:</source>
          <target state="translated">최대화 된 및 / 또는 전체 화면 상태를 유지하면서 최소화 된 창을 복원하고 활성화하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="239bc75b82c4d0119111f8e91adb1394d201ce03" translate="yes" xml:space="preserve">
          <source>In order to run an application with a specific style, either configure the style using &lt;a href=&quot;qquickstyle&quot;&gt;QQuickStyle&lt;/a&gt; in C++, pass a command line argument, or set an environment variable. Alternatively, the preferred style and style-specific attributes can be specified in a configuration file.</source>
          <target state="translated">특정 스타일로 응용 프로그램을 실행하려면 C ++에서 &lt;a href=&quot;qquickstyle&quot;&gt;QQuickStyle&lt;/a&gt; 을 사용하여 스타일을 구성 하거나 명령 줄 인수를 전달하거나 환경 변수를 설정하십시오. 또는 기본 설정 스타일 및 스타일 특정 속성을 구성 파일에 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa0d2b13442b7e65fa15e6bf769a48c084a4c415" translate="yes" xml:space="preserve">
          <source>In order to save bandwidth, sometimes a backend will only return places which are partially populated with details. This can be checked with the &lt;a href=&quot;qml-qtlocation-place#detailsFetched-prop&quot;&gt;Place::detailsFetched&lt;/a&gt; property which indicates whether all availalable details have been fetched or not. If not, the &lt;a href=&quot;qml-qtlocation-place#getDetails-method&quot;&gt;Place::getDetails&lt;/a&gt;() method can be invoked to fetch the remaining details.</source>
          <target state="translated">대역폭을 절약하기 위해 때로는 백엔드에서 부분적으로 채워진 장소 만 반환합니다. 사용 가능한 모든 세부 정보를 가져 왔는지 여부를 나타내는 &lt;a href=&quot;qml-qtlocation-place#detailsFetched-prop&quot;&gt;Place :: detailsFetched&lt;/a&gt; 속성을 사용하여 확인할 수 있습니다 . 그렇지 않으면 &lt;a href=&quot;qml-qtlocation-place#getDetails-method&quot;&gt;Place :: getDetails&lt;/a&gt; () 메소드를 호출하여 나머지 세부 사항을 페치 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="33ba98aa49ecb34866969862fdccd9fac01c5199" translate="yes" xml:space="preserve">
          <source>In order to simplify the management of the enabled / disabled statuses, &lt;a href=&quot;qopengldebugmessage&quot;&gt;QOpenGLDebugMessage&lt;/a&gt; also supports the concept of &lt;code&gt;debug groups&lt;/code&gt;. A debug group contains the group of enabled / disabled configurations of debug messages. Moreover, debug groups are organized in a stack: it is possible to push and pop groups by calling &lt;a href=&quot;qopengldebuglogger#pushGroup&quot;&gt;pushGroup&lt;/a&gt;() and &lt;a href=&quot;qopengldebuglogger#popGroup&quot;&gt;popGroup&lt;/a&gt;() respectively. (When an OpenGL context is created, there is already a group in the stack).</source>
          <target state="translated">활성화 / 비활성화 상태의 관리를 단순화하기 위해 &lt;a href=&quot;qopengldebugmessage&quot;&gt;QOpenGLDebugMessage&lt;/a&gt; 는 &lt;code&gt;debug groups&lt;/code&gt; 의 개념도 지원합니다 . 디버그 그룹에는 디버그 메시지의 활성화 / 비활성화 구성 그룹이 포함됩니다. 또한 디버그 그룹은 스택으로 구성됩니다 . 각각 &lt;a href=&quot;qopengldebuglogger#pushGroup&quot;&gt;pushGroup&lt;/a&gt; () 및 &lt;a href=&quot;qopengldebuglogger#popGroup&quot;&gt;popGroup&lt;/a&gt; () 을 호출하여 그룹을 푸시 및 팝할 수 있습니다. OpenGL 컨텍스트가 작성되면 스택에 이미 그룹이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae1b4a169d3419fd6ac0895b85077008ef3fa9e6" translate="yes" xml:space="preserve">
          <source>In order to support future compatibility, QCborValues containing extended Qt types compare equal to the tag type of the same contents. In other words, the following expression is true:</source>
          <target state="translated">향후 호환성을 지원하기 위해 확장 Qt 유형을 포함하는 QCborValue는 동일한 내용의 태그 유형과 동일합니다. 다시 말해, 다음 표현은 사실입니다.</target>
        </trans-unit>
        <trans-unit id="891906f6b832cfd43f7613beff3b18541b8948d3" translate="yes" xml:space="preserve">
          <source>In order to test in-app purchases in your application, you first have to publish it. To limit the users who can access the application before it is ready for production, it can be published as either alpha or beta, in the respective tabs on the &lt;b&gt;APK&lt;/b&gt; page of the developer console. In order to make an alpha or beta application, fill out all the required information about the application, upload the &lt;code&gt;APK&lt;/code&gt; file under the &lt;b&gt;Beta testing&lt;/b&gt; or &lt;b&gt;Alpha testing&lt;/b&gt; tab, and mark the application as &lt;b&gt;published&lt;/b&gt;.</source>
          <target state="translated">응용 프로그램에서 인앱 구매를 테스트하려면 먼저 게시해야합니다. 프로덕션 준비가되기 전에 애플리케이션에 액세스 할 수있는 사용자를 제한하기 위해 개발자 콘솔 의 &lt;b&gt;APK&lt;/b&gt; 페이지 에있는 각 탭에서 알파 또는 베타로 게시 할 수 있습니다 . 알파 또는 베타 애플리케이션을 만들려면 애플리케이션에 대한 모든 필수 정보를 작성 하고 &lt;b&gt;베타 테스트&lt;/b&gt; 또는 &lt;b&gt;알파 테스트&lt;/b&gt; 탭 에서 &lt;code&gt;APK&lt;/code&gt; 파일을 업로드 한 후 애플리케이션을 &lt;b&gt;게시 된&lt;/b&gt; 것으로 표시하십시오 .&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="acfdb1e58048ef1106e285ccf1135aa6a2d1154e" translate="yes" xml:space="preserve">
          <source>In order to test in-app purchases in your application, you first have to publish it. To limit the users who can access the application before it is ready for production, it can be published as either alpha or beta.</source>
          <target state="translated">응용 프로그램에서 인앱 구매를 테스트하려면 먼저 게시해야합니다. 프로덕션 준비가되기 전에 응용 프로그램에 액세스 할 수있는 사용자를 제한하기 위해 알파 또는 베타로 게시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3eac5655794100ecd477fa39e106ff98f98a33f3" translate="yes" xml:space="preserve">
          <source>In order to track scroll bar movements, reimplement the virtual function &lt;a href=&quot;qabstractscrollarea#scrollContentsBy&quot;&gt;scrollContentsBy&lt;/a&gt;(). In order to fine-tune scrolling behavior, connect to a scroll bar's &lt;a href=&quot;qabstractslider#actionTriggered&quot;&gt;QAbstractSlider::actionTriggered&lt;/a&gt;() signal and adjust the &lt;a href=&quot;qabstractslider#sliderPosition-prop&quot;&gt;QAbstractSlider::sliderPosition&lt;/a&gt; as you wish.</source>
          <target state="translated">스크롤 막대 이동을 추적하려면 가상 함수 &lt;a href=&quot;qabstractscrollarea#scrollContentsBy&quot;&gt;scrollContentsBy&lt;/a&gt; ()를 다시 구현하십시오 . 스크롤 동작을 미세 조정하려면 스크롤 막대의 &lt;a href=&quot;qabstractslider#actionTriggered&quot;&gt;QAbstractSlider :: actionTriggered&lt;/a&gt; () 신호에 연결하고 원하는대로 &lt;a href=&quot;qabstractslider#sliderPosition-prop&quot;&gt;QAbstractSlider :: sliderPosition&lt;/a&gt; 을 조정하십시오 .</target>
        </trans-unit>
        <trans-unit id="dbe485a6cb246c26c71c6f42e96a132e7f89a894" translate="yes" xml:space="preserve">
          <source>In order to trigger the event on &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt;, the application must be configured to let the OS know what kind of file(s) it should react on.</source>
          <target state="translated">&lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; 에서 이벤트를 트리거하려면 OS가 어떤 종류의 파일에 반응해야하는지 알려주도록 응용 프로그램을 구성해야합니다.</target>
        </trans-unit>
        <trans-unit id="e1973803c5a405a401322f0652e8808d2699da28" translate="yes" xml:space="preserve">
          <source>In order to trigger the event on macOS, the application must be configured to let the OS know what kind of file(s) it should react on.</source>
          <target state="translated">macOS에서 이벤트를 트리거하려면 어떤 종류의 파일에 반응해야하는지 OS에 알리도록 애플리케이션을 구성해야합니다.</target>
        </trans-unit>
        <trans-unit id="fc215aa01eb248e06d0e4a9dc8f9435c2cc3eed0" translate="yes" xml:space="preserve">
          <source>In order to use &lt;a href=&quot;android&quot;&gt;Qt for Android&lt;/a&gt;, you need the following:</source>
          <target state="translated">&lt;a href=&quot;android&quot;&gt;Android 용 Qt&lt;/a&gt; 를 사용 하려면 다음이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="7e3be75fdce4c59f485783bed52658ee521a7009" translate="yes" xml:space="preserve">
          <source>In order to use &lt;a href=&quot;android#&quot;&gt;Qt for Android&lt;/a&gt;, you need the following:</source>
          <target state="translated">&lt;a href=&quot;android#&quot;&gt;Android 용 Qt&lt;/a&gt; 를 사용 하려면 다음이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="cf9631d352c48b641ff0d7847aa100abb55c5398" translate="yes" xml:space="preserve">
          <source>In order to use an adaptor, one must create a class which inherits &lt;a href=&quot;qdbusabstractadaptor&quot;&gt;QDBusAbstractAdaptor&lt;/a&gt;. Since that is a standard &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;-derived class, the &lt;a href=&quot;qobject#Q_OBJECT&quot;&gt;Q_OBJECT&lt;/a&gt; macro must appear in the declaration and the source file must be processed with the &lt;a href=&quot;moc&quot;&gt;moc&lt;/a&gt; tool. The class must also contain one &lt;a href=&quot;qobject#Q_CLASSINFO&quot;&gt;Q_CLASSINFO&lt;/a&gt; entry with the &lt;code&gt;&quot;D-Bus Interface&quot;&lt;/code&gt; name, declaring which interface it is exporting. Only one entry per class is supported.</source>
          <target state="translated">어댑터를 사용하려면 &lt;a href=&quot;qdbusabstractadaptor&quot;&gt;QDBusAbstractAdaptor&lt;/a&gt; 를 상속하는 클래스를 작성해야합니다 . 이것이 표준 &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 파생 클래스이므로 &lt;a href=&quot;qobject#Q_OBJECT&quot;&gt;Q_OBJECT&lt;/a&gt; 매크로가 선언에 나타나고 소스 파일은 &lt;a href=&quot;moc&quot;&gt;moc&lt;/a&gt; 도구 로 처리되어야합니다 . 또한 클래스에는 &lt;code&gt;&quot;D-Bus Interface&quot;&lt;/code&gt; 이름을 가진 &lt;a href=&quot;qobject#Q_CLASSINFO&quot;&gt;Q_CLASSINFO&lt;/a&gt; 항목이 하나 포함되어야하며 내보내는 인터페이스를 선언해야합니다. 수업 당 하나의 항목 만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="9eabef0817ab7612f568bd2200c9fde22e20789d" translate="yes" xml:space="preserve">
          <source>In order to use an iterator any of the standard algorithms, its iterator traits need to be known. As &lt;a href=&quot;qsequentialiterable&quot;&gt;QSequentialIterable&lt;/a&gt; can work with many different kinds of containers, we cannot declare the traits in the iterator classes themselves. A QTaggedIterator gives you a way to explicitly declare a trait for a concrete instance of an iterator or &lt;a href=&quot;qconstiterator&quot;&gt;QConstIterator&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53b87ac57098715353e27b54a2c69f580646a7c7" translate="yes" xml:space="preserve">
          <source>In order to use one's own type with Qt D-Bus, the type has to be declared as a Qt meta-type with the &lt;a href=&quot;qmetatype#Q_DECLARE_METATYPE&quot;&gt;Q_DECLARE_METATYPE&lt;/a&gt;() macro and registered with the &lt;a href=&quot;qdbusargument#qDBusRegisterMetaType&quot;&gt;qDBusRegisterMetaType&lt;/a&gt;() function. The streaming operators &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; will be automatically found by the registration system.</source>
          <target state="translated">Qt D-Bus와 함께 자체 유형을 사용하려면 &lt;a href=&quot;qmetatype#Q_DECLARE_METATYPE&quot;&gt;Q_DECLARE_METATYPE&lt;/a&gt; () 매크로를 사용하여 유형을 Qt 메타 유형으로 선언 하고 &lt;a href=&quot;qdbusargument#qDBusRegisterMetaType&quot;&gt;qDBusRegisterMetaType&lt;/a&gt; () 함수로 등록해야합니다 . 스트리밍 운영자 &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; 및 &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; 는 등록 시스템에서 자동으로 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="3a4e1b184c4ee4edd48b10c40c92ea172614ec75" translate="yes" xml:space="preserve">
          <source>In order to use the bundled icon theme, an application should call &lt;a href=&quot;qicon#setThemeName&quot;&gt;QIcon::setThemeName&lt;/a&gt;() before loading the main QML file:</source>
          <target state="translated">번들 아이콘 테마를 사용하려면 애플리케이션이 기본 QML 파일을로드하기 전에 &lt;a href=&quot;qicon#setThemeName&quot;&gt;QIcon :: setThemeName&lt;/a&gt; ()을 호출해야 합니다.</target>
        </trans-unit>
        <trans-unit id="cc188245c46a2da5cd37a410602599ed3f979cdc" translate="yes" xml:space="preserve">
          <source>In order to use the registered singleton type in QML, you must import the URI with the corresponding version.</source>
          <target state="translated">QML에서 등록 된 싱글 톤 유형을 사용하려면 해당 버전의 URI를 가져와야합니다.</target>
        </trans-unit>
        <trans-unit id="fb3afc705c4d4bc91938057bcf4fadb835f5a69e" translate="yes" xml:space="preserve">
          <source>In order to use the registered singleton type in QML, you must import the singleton type.</source>
          <target state="translated">QML에서 등록 된 싱글 톤 유형을 사용하려면 싱글 톤 유형을 가져와야합니다.</target>
        </trans-unit>
        <trans-unit id="7d17f70074df889467be626f3995483d2addfbea" translate="yes" xml:space="preserve">
          <source>In other cases you will need to supply the signature yourself, and it is important that the signature matches the function you want to call. The signature structure is &lt;b&gt;(A)R&lt;/b&gt;, where &lt;b&gt;A&lt;/b&gt; is the type of the argument(s) and &lt;b&gt;R&lt;/b&gt; is the return type. Array types in the signature must have the &lt;b&gt;[&lt;/b&gt; suffix and the fully-qualified type names must have the &lt;b&gt;L&lt;/b&gt; prefix and &lt;b&gt;;&lt;/b&gt; suffix.</source>
          <target state="translated">다른 경우에는 서명을 직접 제공해야하며 서명은 호출하려는 기능과 일치해야합니다. 서명 구조는 &lt;b&gt;(A) R&lt;/b&gt; 이며, 여기서 &lt;b&gt;A&lt;/b&gt; 는 인수의 유형이고 &lt;b&gt;R&lt;/b&gt; 은 반환 유형입니다. 서명의 배열 유형에는 &lt;b&gt;[&lt;/b&gt; 접미사 가 있어야하고 정규화 된 유형 이름에는 &lt;b&gt;L&lt;/b&gt; 접두사 가 있어야합니다 &lt;b&gt;. &lt;/b&gt;접미사.</target>
        </trans-unit>
        <trans-unit id="9d455378a76d68ba5bdcdeb2fb9f14642ae276bb" translate="yes" xml:space="preserve">
          <source>In other cases, a pattern ported from &lt;a href=&quot;qregexp&quot;&gt;QRegExp&lt;/a&gt; to QRegularExpression may silently change semantics. Therefore, it is necessary to review the patterns used. The most notable cases of silent incompatibility are:</source>
          <target state="translated">다른 경우에는 &lt;a href=&quot;qregexp&quot;&gt;QRegExp&lt;/a&gt; 에서 QRegularExpression 으로 포팅 된 패턴 이 자동으로 의미를 변경할 수 있습니다. 따라서 사용 된 패턴을 검토 할 필요가 있습니다. 가장 주목할만한 자동 비 호환성 사례는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cff62e08bb0fd53e6c21df78ce74ee64d82ff8a5" translate="yes" xml:space="preserve">
          <source>In other cases, a pattern ported from &lt;code&gt;QRegExp&lt;/code&gt; to &lt;a href=&quot;qtcore-changes-qt6#qregularexpression&quot;&gt;QRegularExpression&lt;/a&gt; may silently change semantics. Therefore, it is necessary to review the patterns used. The most notable cases of silent incompatibility are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d2f1a44792e00db7873e7639289783d168d9c70" translate="yes" xml:space="preserve">
          <source>In other cases, a pattern ported from QRegExp to &lt;a href=&quot;qtcore-changes-qt6#qregularexpression&quot;&gt;QRegularExpression&lt;/a&gt; may silently change semantics. Therefore, it is necessary to review the patterns used. The most notable cases of silent incompatibility are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01527088776ea39b26a63e8592a37443bd83921b" translate="yes" xml:space="preserve">
          <source>In other files, it has to be prefixed with the name of its containing component.</source>
          <target state="translated">다른 파일에서는 포함하는 구성 요소의 이름을 접두사로 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="71c8e793c48baa19e9e861ca2d6a96ac2c587831" translate="yes" xml:space="preserve">
          <source>In other words, the proxy will have all rows of the first source model, followed by all rows of the second source model, and so on.</source>
          <target state="translated">즉, 프록시는 첫 번째 소스 모델의 모든 행과 두 번째 소스 모델의 모든 행 등을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="e3ec810f88d7ad1c4d7d04f694729ec8e79c50d5" translate="yes" xml:space="preserve">
          <source>In our delegate, we can then bind the</source>
          <target state="translated">델리게이트에서</target>
        </trans-unit>
        <trans-unit id="fd757abf8f41bb3e0600f489e8f951fb229f8854" translate="yes" xml:space="preserve">
          <source>In our example, the &lt;code&gt;&quot;healthPotion&quot;&lt;/code&gt; is a consumable product, because the user should be able to buy any number of health potions and add them to their in-game inventory.</source>
          <target state="translated">이 예에서 &lt;code&gt;&quot;healthPotion&quot;&lt;/code&gt; 은 소모품입니다. 사용자는 원하는 수의 체력 물약을 구매하여 게임 내 인벤토리에 추가 할 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="d3269e302be6e28e3c121a9a7e3e7959fa4362c0" translate="yes" xml:space="preserve">
          <source>In our example, the control is a &lt;a href=&quot;qstyle#ControlElement-enum&quot;&gt;QStyle::CE_PushButton&lt;/a&gt;, and according to the &lt;a href=&quot;qstyle#drawControl&quot;&gt;QStyle::drawControl&lt;/a&gt;() documentation the corresponding class is &lt;a href=&quot;qstyleoptionbutton&quot;&gt;QStyleOptionButton&lt;/a&gt;.</source>
          <target state="translated">이 예에서 컨트롤은 &lt;a href=&quot;qstyle#ControlElement-enum&quot;&gt;QStyle :: CE_PushButton&lt;/a&gt; 이며 &lt;a href=&quot;qstyle#drawControl&quot;&gt;QStyle :: drawControl&lt;/a&gt; () 설명서에 따르면 해당 클래스는 &lt;a href=&quot;qstyleoptionbutton&quot;&gt;QStyleOptionButton&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5d7eb38f743704f4a3ec59be92859fb1d77fdb4b" translate="yes" xml:space="preserve">
          <source>In particular calling update whenever the cursor position changes is important as that often causes other query attributes like surrounding text and text selection to change as well. The attributes that often change together with cursor position have been grouped in &lt;a href=&quot;qt#InputMethodQuery-enum&quot;&gt;Qt::ImQueryInput&lt;/a&gt; value for convenience.</source>
          <target state="translated">특히 커서 위치가 변경 될 때마다 update를 호출하면 주변 텍스트 및 텍스트 선택과 같은 다른 쿼리 속성도 변경되기 때문에 중요합니다. 커서 위치와 함께 자주 변경되는 속성 은 편의를 위해 &lt;a href=&quot;qt#InputMethodQuery-enum&quot;&gt;Qt :: ImQueryInput&lt;/a&gt; 값 으로 그룹화되었습니다 .</target>
        </trans-unit>
        <trans-unit id="3c064b8988cc079e71884c37f141206a12483fd0" translate="yes" xml:space="preserve">
          <source>In particular, QML currently supports:</source>
          <target state="translated">특히 QML은 현재 다음을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="f044a192708817302082a9b98b00d91488208886" translate="yes" xml:space="preserve">
          <source>In particular, if</source>
          <target state="translated">특히</target>
        </trans-unit>
        <trans-unit id="6bd2b529749df25d085d0c1d75f528673e0dcc17" translate="yes" xml:space="preserve">
          <source>In particular, in the last case we want the regular expression engine to report a partial match: we are successfully matching the pattern against the subject string but the matching cannot continue because the end of the subject is encountered. Notice, however, that the matching algorithm should continue and try all possibilities, and in case a complete (non-partial) match is found, then this one should be reported, and the input string accepted as fully valid.</source>
          <target state="translated">특히, 마지막 경우 정규식 엔진이 부분 일치를보고하려고합니다. 패턴을 주제 문자열과 성공적으로 일치 시키지만 주제의 끝에 도달하여 일치를 계속할 수 없습니다. 그러나, 일치 알고리즘은 계속해서 모든 가능성을 시도해야하며, 완전 (부분이 아닌) 일치가 발견되면이를보고하고 입력 문자열을 완전히 유효한 것으로 승인해야합니다.</target>
        </trans-unit>
        <trans-unit id="0eacce3b7f64260a935c559f5a26420bb297d1d4" translate="yes" xml:space="preserve">
          <source>In particular, this may be useful in order to access functionality provided via a singleton type; see &lt;a href=&quot;qqmlengine#QML_SINGLETON&quot;&gt;QML_SINGLETON&lt;/a&gt; for more information.</source>
          <target state="translated">특히 이것은 싱글 톤 유형을 통해 제공되는 기능에 액세스하는 데 유용 할 수 있습니다. 자세한 내용 은 &lt;a href=&quot;qqmlengine#QML_SINGLETON&quot;&gt;QML_SINGLETON&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0408c88246551a7cd9cf01a51efa481f9fcb3708" translate="yes" xml:space="preserve">
          <source>In particular, this may be useful in order to access functionality provided via a singleton type; see &lt;a href=&quot;qqmlengine#qmlRegisterSingletonType&quot;&gt;qmlRegisterSingletonType&lt;/a&gt;() for more information.</source>
          <target state="translated">특히, 이것은 싱글 톤 유형을 통해 제공되는 기능에 액세스하기 위해 유용 할 수 있습니다. 자세한 내용은 &lt;a href=&quot;qqmlengine#qmlRegisterSingletonType&quot;&gt;qmlRegisterSingletonType&lt;/a&gt; ()을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5a507e0c95322db4179bf9554016bf5d9ed5ac31" translate="yes" xml:space="preserve">
          <source>In practice the most common combinations are expected to be the following:</source>
          <target state="translated">실제로 가장 일반적인 조합은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a820314cab280acd6b3c5950b5edbd24f5c17f06" translate="yes" xml:space="preserve">
          <source>In practice this configure command is equivalent to the following direct CMake call:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d04a48b74ffeda38d5e4f0534a4eaddd90455fe" translate="yes" xml:space="preserve">
          <source>In practice this function is often called from a slot connected to the &lt;a href=&quot;qquickwindow#beforeRenderPassRecording&quot;&gt;beforeRenderPassRecording&lt;/a&gt;() or &lt;a href=&quot;qquickwindow#afterRenderPassRecording&quot;&gt;afterRenderPassRecording&lt;/a&gt;() signals.</source>
          <target state="translated">&lt;a href=&quot;qquickwindow#afterRenderPassRecording&quot;&gt;실제로이&lt;/a&gt; 함수는 &lt;a href=&quot;qquickwindow#beforeRenderPassRecording&quot;&gt;beforeRenderPassRecording&lt;/a&gt; () 또는 afterRenderPassRecording () 신호에 연결된 슬롯에서 종종 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="e6420d958b52ec74d2f4d416713ffaec58cbba3d" translate="yes" xml:space="preserve">
          <source>In practice, additional error checking needs to be performed on the positional arguments and option values. For example, ranges of numbers should be checked.</source>
          <target state="translated">실제로 위치 인수 및 옵션 값에 대해 추가 오류 검사를 수행해야합니다. 예를 들어 숫자 범위를 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="c9649dc9661cd56dc8690eb9e41d0c267ec90959" translate="yes" xml:space="preserve">
          <source>In practice, it often happens that a single &lt;a href=&quot;qt3drender-qeffect&quot;&gt;QEffect&lt;/a&gt; is being referenced by several &lt;a href=&quot;qt3drender-qmaterial&quot;&gt;QMaterial&lt;/a&gt; components. This allows to only create the effect, techniques, passes and shaders once while allowing to specify the material by adding &lt;a href=&quot;qt3drender-qparameter&quot;&gt;QParameter&lt;/a&gt; instances.</source>
          <target state="translated">실제로, 단일 &lt;a href=&quot;qt3drender-qeffect&quot;&gt;QEffect&lt;/a&gt; 가 여러 &lt;a href=&quot;qt3drender-qmaterial&quot;&gt;QMaterial&lt;/a&gt; 구성 요소에 의해 참조되는 경우가 종종 있습니다. &lt;a href=&quot;qt3drender-qparameter&quot;&gt;QParameter&lt;/a&gt; 인스턴스 를 추가하여 머티리얼을 지정할 수있게하면서 효과, 기법, 패스 및 셰이더를 한 번만 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a9b2cbb6380dc64215d75c749f5b303d4727043c" translate="yes" xml:space="preserve">
          <source>In practice, it often happens that a single &lt;a href=&quot;qt3drender-qeffect&quot;&gt;QEffect&lt;/a&gt; is being referenced by several QMaterial components. This allows to only create the effect, techniques, passes and shaders once while allowing to specify the material by adding &lt;a href=&quot;qt3drender-qparameter&quot;&gt;QParameter&lt;/a&gt; instances.</source>
          <target state="translated">실제로는 단일 &lt;a href=&quot;qt3drender-qeffect&quot;&gt;QEffect&lt;/a&gt; 가 여러 QMaterial 구성 요소에 의해 참조되는 경우가 많습니다 . 이를 통해 &lt;a href=&quot;qt3drender-qparameter&quot;&gt;QParameter&lt;/a&gt; 인스턴스 를 추가하여 재질을 지정할 수있는 동안 효과, 기술, 패스 및 셰이더를 한 번만 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d3aac8815ccf30d39940f820118f556398786c1c" translate="yes" xml:space="preserve">
          <source>In practice, it often happens that a single Effect is being referenced by several Material components. This allows to only create the effect, techniques, passes and shaders once while allowing to specify the material by adding Parameter instances.</source>
          <target state="translated">실제로 여러 머티리얼 컴포넌트가 단일 이펙트를 참조하는 경우가 종종 있습니다. 이것은 Parameter 인스턴스를 추가하여 머티리얼을 지정할 수있게하면서 효과, 테크닉, 패스 및 쉐이더를 한 번만 만들 수있게합니다.</target>
        </trans-unit>
        <trans-unit id="34ece7a22518032100e8b60b803f635ea620c604" translate="yes" xml:space="preserve">
          <source>In practice, the impossibility of using GUI classes in other threads than the main thread can easily be worked around by putting time-consuming operations in a separate worker thread and displaying the results on screen in the main thread when the worker thread is finished. This is the approach used for implementing the &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtcore-threads-mandelbrot-example.html&quot;&gt;Mandelbrot Example&lt;/a&gt; and the &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtnetwork-blockingfortuneclient-example.html&quot;&gt;Blocking Fortune Client Example&lt;/a&gt;.</source>
          <target state="translated">실제로 메인 스레드 이외의 다른 스레드에서 GUI 클래스를 사용할 수 없다는 것은 별도의 작업자 스레드에 시간이 많이 걸리는 작업을 배치하고 작업자 스레드가 완료되면 결과를 기본 스레드에 화면에 표시하여 쉽게 해결할 수 있습니다. 이것이 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtcore-threads-mandelbrot-example.html&quot;&gt;Mandelbrot 예제&lt;/a&gt; 및 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtnetwork-blockingfortuneclient-example.html&quot;&gt;Blocking Fortune 클라이언트 예제&lt;/a&gt; 를 구현하는 데 사용되는 방법 입니다.</target>
        </trans-unit>
        <trans-unit id="46e722d18bec0bd4cf3a8a580be56b2541dcf1a8" translate="yes" xml:space="preserve">
          <source>In practice, the impossibility of using GUI classes in other threads than the main thread can easily be worked around by putting time-consuming operations in a separate worker thread and displaying the results on screen in the main thread when the worker thread is finished. This is the approach used for implementing the &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtcore-threads-mandelbrot-example.html&quot;&gt;Mandelbrot Example&lt;/a&gt; and the &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtnetwork-blockingfortuneclient-example.html&quot;&gt;Blocking Fortune Client Example&lt;/a&gt;.</source>
          <target state="translated">실제로는 시간이 많이 걸리는 작업을 별도의 작업자 스레드에 배치하고 작업자 스레드가 완료되면 화면에 결과를 표시하여 메인 스레드가 아닌 다른 스레드에서 GUI 클래스를 사용할 수없는 문제를 쉽게 해결할 수 있습니다. 이것은 &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtcore-threads-mandelbrot-example.html&quot;&gt;Mandelbrot 예제&lt;/a&gt; 및 &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtnetwork-blockingfortuneclient-example.html&quot;&gt;Blocking Fortune 클라이언트 예제&lt;/a&gt; 를 구현하는 데 사용되는 접근 방식 입니다.</target>
        </trans-unit>
        <trans-unit id="518755929d2774f62f055f37f4572b7830114134" translate="yes" xml:space="preserve">
          <source>In practice, the impossibility of using GUI classes in other threads than the main thread can easily be worked around by putting time-consuming operations in a separate worker thread and displaying the results on screen in the main thread when the worker thread is finished. This is the approach used for implementing the &lt;a href=&quot;https://doc.qt.io/qt-6.0/qtcore-threads-mandelbrot-example.html&quot;&gt;Mandelbrot Example&lt;/a&gt; and the &lt;a href=&quot;https://doc.qt.io/qt-6.0/qtnetwork-blockingfortuneclient-example.html&quot;&gt;Blocking Fortune Client Example&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01bc404839e234ba8ab44abaf332354bdfbe4a5d" translate="yes" xml:space="preserve">
          <source>In practice, this means that the application developer should:</source>
          <target state="translated">실제로 이는 애플리케이션 개발자가 다음을 수행해야 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="584fcaeaa9a00dd83ceb7534ecaf4817a7fe4b00" translate="yes" xml:space="preserve">
          <source>In previous versions of Qt, &lt;a href=&quot;qabstractprintdialog#exec&quot;&gt;exec&lt;/a&gt;() the print dialog would create a sheet by default the dialog was given a parent. This is no longer supported in Qt 4.5. If you want to use sheets, use &lt;a href=&quot;qprintdialog#open&quot;&gt;QPrintDialog::open&lt;/a&gt;() instead.</source>
          <target state="translated">이전 버전의 Qt에서 &lt;a href=&quot;qabstractprintdialog#exec&quot;&gt;exec&lt;/a&gt; () 인쇄 대화 상자는 기본적으로 대화 상자에 부모가 부여 된 시트를 만듭니다. Qt 4.5에서는 더 이상 지원되지 않습니다. 시트를 사용하려면 &lt;a href=&quot;qprintdialog#open&quot;&gt;QPrintDialog :: open&lt;/a&gt; ()을 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="86d4b04056db642bac0638e0c4ffb321e1299f92" translate="yes" xml:space="preserve">
          <source>In previous versions of Qt, &lt;a href=&quot;qdialog#exec&quot;&gt;exec&lt;/a&gt;() the print dialog would create a sheet by default the dialog was given a parent. This is no longer supported in Qt 4.5. If you want to use sheets, use &lt;a href=&quot;qprintdialog#open&quot;&gt;QPrintDialog::open&lt;/a&gt;() instead.</source>
          <target state="translated">이전 버전의 Qt에서 &lt;a href=&quot;qdialog#exec&quot;&gt;exec&lt;/a&gt; () 인쇄 대화 상자는 기본적으로 대화 상자에 부모가 부여 된 시트를 만듭니다. 이것은 Qt 4.5에서 더 이상 지원되지 않습니다. 시트를 사용하려면 대신 &lt;a href=&quot;qprintdialog#open&quot;&gt;QPrintDialog :: open&lt;/a&gt; ()을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="3b5f9c82640ac7c66877027ca298b3995f9f02f4" translate="yes" xml:space="preserve">
          <source>In previous versions of Qt, the static functions would create a sheet by default if the static function was given a parent. This is no longer supported and does nothing in Qt 4.5, The static functions will always be an application modal dialog. If you want to use sheets, use &lt;a href=&quot;qfiledialog#open&quot;&gt;QFileDialog::open&lt;/a&gt;() instead.</source>
          <target state="translated">이전 버전의 Qt에서는 정적 함수에 부모가 제공되면 정적 함수는 기본적으로 시트를 만듭니다. 이것은 더 이상 지원되지 않으며 Qt 4.5에서는 아무 것도 수행하지 않습니다. 정적 함수는 항상 응용 프로그램 모달 대화 상자입니다. 시트를 사용하려면 &lt;a href=&quot;qfiledialog#open&quot;&gt;QFileDialog :: open&lt;/a&gt; ()을 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c6482c6f24bb5a73f6a2f88d95345457a7372a5b" translate="yes" xml:space="preserve">
          <source>In project mode, qmake will generate a project file. Additionally, you may supply the following options in this mode:</source>
          <target state="translated">프로젝트 모드에서 qmake는 프로젝트 파일을 생성합니다. 또한이 모드에서 다음 옵션을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="52eb3773db85903a8f69c6bdfd4e460d11e7a30c" translate="yes" xml:space="preserve">
          <source>In read-only mode, the user can still copy the text to the clipboard, or drag and drop the text (if &lt;a href=&quot;qlineedit#echoMode-prop&quot;&gt;echoMode&lt;/a&gt;() is &lt;a href=&quot;qlineedit#EchoMode-enum&quot;&gt;Normal&lt;/a&gt;), but cannot edit it.</source>
          <target state="translated">읽기 전용 모드에서 사용자는 여전히 텍스트를 클립 보드에 복사하거나 텍스트를 끌어다 &lt;a href=&quot;qlineedit#echoMode-prop&quot;&gt;놓을&lt;/a&gt; 수 있지만 ( echoMode ()가 &lt;a href=&quot;qlineedit#EchoMode-enum&quot;&gt;Normal 인 경우&lt;/a&gt; ) 편집 할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="7ea2966fca2f27a136908152df12da4dd338a57b" translate="yes" xml:space="preserve">
          <source>In read-only mode, the user can still copy the text to the clipboard, or drag and drop the text; but cannot edit it.</source>
          <target state="translated">읽기 전용 모드에서 사용자는 여전히 텍스트를 클립 보드에 복사하거나 텍스트를 끌어서 놓을 수 있습니다. 편집 할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="b56c5145455e3fcd374d1b301c13388031ed45d7" translate="yes" xml:space="preserve">
          <source>In read-only mode, the user can use the help engine with a collection file installed in a read-only location. In this case, some functionality won't be accessible, like registering additional documentation, filter editing, or any action that would require changes to the collection file. Setting it to &lt;code&gt;false&lt;/code&gt; enables the full functionality of the help engine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f370d1bcdf4b02c16a4e490f598de020a265b0b5" translate="yes" xml:space="preserve">
          <source>In real life, chromatic aberration is an optical phenomenon causing color fringes in high contrast areas. These color fringes are caused by different colors refracting at different angels splitting white light into a spectrum. This is called dispersion.</source>
          <target state="translated">실생활에서 색수차는 고 대비 영역에서 색 줄무늬를 일으키는 광학 현상입니다. 이러한 색 변두리는 흰색 빛을 스펙트럼으로 분할하는 다른 천사에서 굴절되는 다른 색상으로 인해 발생합니다. 이것을 분산이라고합니다.</target>
        </trans-unit>
        <trans-unit id="9096d8234b80c472ceb6ba577a7ed7c91d3f250f" translate="yes" xml:space="preserve">
          <source>In render function, for each visual object:</source>
          <target state="translated">렌더링 함수에서 각 시각적 객체에 대해 :</target>
        </trans-unit>
        <trans-unit id="9477c26d43c2a174197428d1b5bfa57d28f0c94f" translate="yes" xml:space="preserve">
          <source>In response to the initial ClientHello message, the server sends a HelloVerifyRequest, which contains a cookie. This cookie is a cryptographic hash and is generated using the client's address, port number, and the server's secret (which is a cryptographically strong pseudo-random sequence of bytes).</source>
          <target state="translated">초기 ClientHello 메시지에 대한 응답으로 서버는 쿠키가 포함 된 HelloVerifyRequest를 보냅니다. 이 쿠키는 암호화 해시이며 클라이언트의 주소, 포트 번호 및 서버의 비밀 (암호 적으로 강력한 의사 랜덤 바이트 시퀀스)을 사용하여 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="27b5f5b55cebbe5ba07d8b7894baf84d3fbea19e" translate="yes" xml:space="preserve">
          <source>In right-to-left language speaking cultures, people naturally scan and read graphic elements and text from the right to left. The general rule of thumb is that content (like photos, videos and maps) is not mirrored, but positioning of the content (like application layouts and the flow of visual elements) is mirrored. For example, photos shown in chronological order should flow from right to left, the low end range of the horizontal sliders should be located at the right side of the slider, and text lines should be aligned to the right side of the available text area. The location of visual elements should not be mirrored when the position is related to a content; for example, when a position marker is shown to indicate a location on a map. Also, there are some special cases you may need to take into account where right-to-left language speakers are used to left-to-right positioning, for example when using number dialers in phones and media play, pause, rewind and forward buttons in music players.</source>
          <target state="translated">오른쪽에서 왼쪽으로 말하는 언어 문화권에서 사람들은 자연스럽게 오른쪽에서 왼쪽으로 그래픽 요소와 텍스트를 스캔하고 읽습니다. 일반적으로 사진, 비디오 및 맵과 같은 컨텐츠는 미러링되지 않지만 컨텐츠 배치 (응용 프로그램 레이아웃 및 시각적 요소의 흐름과 같은)는 미러링됩니다. 예를 들어, 시간 순서대로 표시된 사진은 오른쪽에서 왼쪽으로 흐르고 가로 슬라이더의 하단 범위는 슬라이더의 오른쪽에 있어야하고 텍스트 줄은 사용 가능한 텍스트 영역의 오른쪽에 정렬되어야합니다. 위치가 컨텐츠와 관련 될 때 시각적 요소의 위치는 미러링되지 않아야합니다. 예를 들어, 위치 마커가지도상의 위치를 ​​나타내도록 표시 될 때. 또한,오른쪽에서 왼쪽으로 쓰는 언어 스피커를 사용하여 왼쪽에서 오른쪽으로 배치하는 경우를 고려해야 할 특별한 경우가 있습니다. 선수.</target>
        </trans-unit>
        <trans-unit id="d739643e33524ace5ab6eace22efddca9e20969c" translate="yes" xml:space="preserve">
          <source>In scene initialization function, for each visual object:</source>
          <target state="translated">장면 초기화 기능에서 각 시각적 객체에 대해 :</target>
        </trans-unit>
        <trans-unit id="6f30d77d4100ef4141082397d2a9dab02e6a7059" translate="yes" xml:space="preserve">
          <source>In shell surface integrations, such as QWaylandWlShellIntegration and QWaylandXdgShellV5Integration, maximize and fullscreen requests from the client will only have an effect if the integration has the primary view of the surface.</source>
          <target state="translated">QWaylandWlShellIntegration 및 QWaylandXdgShellV5Integration과 같은 쉘 표면 통합에서 클라이언트의 최대화 및 전체 화면 요청은 통합에 표면의 기본 뷰가있는 경우에만 영향을 미칩니다.</target>
        </trans-unit>
        <trans-unit id="ec0266fa95240508cdb33878f5d0a757c54a7e5c" translate="yes" xml:space="preserve">
          <source>In situations where a feature of the native platform is not exposed in Qt, it can be helpful to access the native handles maintained by Qt, and use those to call the native APIs instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dc9e2b3217e1e07d5cd990ab9fd086112d1b9c5" translate="yes" xml:space="preserve">
          <source>In small to medium sized projects, a build script typically lists all source files and then compiles the executable in one go. This means that the build scripts for the tests must list the needed source files again.</source>
          <target state="translated">중소 규모 프로젝트에서 빌드 스크립트는 일반적으로 모든 소스 파일을 나열한 다음 실행 파일을 한 번에 컴파일합니다. 이는 테스트 용 빌드 스크립트가 필요한 소스 파일을 다시 나열해야 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="2b243fb67a5ea1c66941228cfb17b8a4f4d74cbe" translate="yes" xml:space="preserve">
          <source>In some GUI styles a default button is drawn with an extra frame around it, up to 3 pixels or more. Qt automatically keeps this space free around auto-default buttons, i.e., auto-default buttons may have a slightly larger size hint.</source>
          <target state="translated">일부 GUI 스타일에서는 기본 단추가 최대 3 픽셀 이상의 추가 프레임과 함께 그려집니다. Qt는 자동 기본 버튼 주위에이 공간을 자동으로 유지합니다. 즉, 자동 기본 버튼의 크기 힌트는 약간 더 클 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="416585172015229e64ef426fff8e77481ff2b51b" translate="yes" xml:space="preserve">
          <source>In some applications, it may make sense to have actions with icons in the toolbar, but not in menus. If true, the icon (if valid) is shown in the menu, when it is false, it is not shown.</source>
          <target state="translated">일부 응용 프로그램에서는 도구 모음에는 아이콘이 있지만 메뉴에는없는 작업이있는 것이 좋습니다. true이면 아이콘 (유효한 경우)이 메뉴에 표시되고 false이면 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e7e0698c1ec7fc5eb17dc208e98e215be5d4f0ae" translate="yes" xml:space="preserve">
          <source>In some applications, it may make sense to have actions with shortcuts in context menus. If true, the shortcut (if valid) is shown when the action is shown via a context menu, when it is false, it is not shown.</source>
          <target state="translated">일부 응용 프로그램에서는 상황에 맞는 메뉴에서 바로 가기를 사용하여 작업을 수행하는 것이 좋습니다. true 인 경우 컨텍스트 메뉴를 통해 조치를 표시 할 때 바로 가기 (유효한 경우)가 표시되고 false 인 경우 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="33a8f44653ad7acca962e66bf2bd7bae24b4eb04" translate="yes" xml:space="preserve">
          <source>In some cases (e.g. dropping multiple email attachments), multiple data values are available. They can be accessed by adding an &lt;code&gt;index&lt;/code&gt; value:</source>
          <target state="translated">경우에 따라 (예 : 여러 전자 메일 첨부 파일 삭제) 여러 데이터 값을 사용할 수 있습니다. &lt;code&gt;index&lt;/code&gt; 값 을 추가하여 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2a5f240081b2d373ff2d02be32db6d5de83b7057" translate="yes" xml:space="preserve">
          <source>In some cases an API is too platform specific to be included in the cross platform Qt classes, but is still useful to include. These APIs are available either in the same way as when accessing the underlying native handles, through the &lt;a href=&quot;qopenglcontext#nativeInterface&quot;&gt;nativeInterface()&lt;/a&gt; accessor, or directly as static function in the native interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="843fcdf9edd577ff40518fb8089bc3790d3fa656" translate="yes" xml:space="preserve">
          <source>In some cases and for less frequently used encodings it may be necessary to write your own &lt;a href=&quot;qtextcodec&quot;&gt;QTextCodec&lt;/a&gt; subclass. Depending on the urgency, it may be useful to contact Qt's technical support team or ask on the &lt;code&gt;qt-interest&lt;/code&gt; mailing list to see if someone else is already working on supporting the encoding.</source>
          <target state="translated">경우에 따라 자주 사용하지 않는 인코딩의 경우 자체 &lt;a href=&quot;qtextcodec&quot;&gt;QTextCodec&lt;/a&gt; 서브 클래스 를 작성해야 할 수도 있습니다 . 긴급성에 따라 Qt의 기술 지원 팀에 문의하거나 &lt;code&gt;qt-interest&lt;/code&gt; 메일 링리스트에서 다른 사람이 이미 인코딩 지원을 위해 노력하고 있는지 확인하는 것이 유용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8a92f39184c895256f5a7c6db1217258254daaa5" translate="yes" xml:space="preserve">
          <source>In some cases changing these settings may result in a longer delay before an image is ready.</source>
          <target state="translated">경우에 따라 이러한 설정을 변경하면 이미지가 준비되기 전에 지연 시간이 길어질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f91121f9956527af6306a84bb5613efd97efa8ee" translate="yes" xml:space="preserve">
          <source>In some cases internationalization is simple, for example, making a US application accessible to Australian or British users may require little more than a few spelling corrections. But to make a US application usable by Japanese users, or a Korean application usable by German users, will require that the software operate not only in different languages, but use different input techniques, character encodings and presentation conventions.</source>
          <target state="translated">예를 들어, 호주 또는 영국 사용자가 미국 응용 프로그램에 액세스 할 수있게하려면 국제화가 간단하기 때문에 맞춤법을 약간만 수정하면됩니다. 그러나 일본 사용자가 미국 응용 프로그램을 사용하거나 독일 사용자가 미국 응용 프로그램을 사용할 수있게하려면 소프트웨어가 다른 언어로 작동 할뿐만 아니라 다른 입력 기술, 문자 인코딩 및 표시 규칙을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="183909d14a1f852600e3e34b5ec35b4a844b4013" translate="yes" xml:space="preserve">
          <source>In some cases it can be more beneficial to draw the pixmap to a painter with a scale set rather than scaling the pixmap. This is the case when the painter is for instance based on OpenGL or when the scale factor changes rapidly.</source>
          <target state="translated">어떤 경우에는 픽스맵을 스케일링하는 대신 픽스맵을 스케일링 세트로 페인터에게 그리는 것이 더 유리할 수 있습니다. 화가가 예를 들어 OpenGL을 기반으로하거나 스케일 팩터가 급격히 변하는 경우입니다.</target>
        </trans-unit>
        <trans-unit id="04d1b72091a29a6578327eb1a20d9e3d6683e5cc" translate="yes" xml:space="preserve">
          <source>In some cases it is necessary for a control to have a drop shadow, for example. However, if we were to add a drop shadow to the button above, it would affect its size, which presents problems for both layouting and mouse/touch input boundaries.</source>
          <target state="translated">경우에 따라 컨트롤에 그림자가 필요합니다. 그러나 위의 버튼에 그림자를 추가하면 크기에 영향을 미쳐 레이아웃 및 마우스 / 터치 입력 경계에 문제가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c1053dd709e57e11ff2ff048501cdb1191b39349" translate="yes" xml:space="preserve">
          <source>In some cases it may be desirable to access a signal outside of the object that emits it. For these purposes, the &lt;code&gt;QtQuick&lt;/code&gt; module provides the &lt;a href=&quot;qml-qtqml-connections&quot;&gt;Connections&lt;/a&gt; type for connecting to signals of arbitrary objects. A &lt;a href=&quot;qml-qtqml-connections&quot;&gt;Connections&lt;/a&gt; object can receive any signal from its specified &lt;a href=&quot;qml-qtqml-connections#target-prop&quot;&gt;target&lt;/a&gt;.</source>
          <target state="translated">경우에 따라 신호를 방출하는 객체 외부의 신호에 액세스하는 것이 바람직 할 수 있습니다. 이러한 목적으로 &lt;code&gt;QtQuick&lt;/code&gt; 모듈은 임의의 객체 신호에 연결하기위한 &lt;a href=&quot;qml-qtqml-connections&quot;&gt;연결&lt;/a&gt; 유형을 제공 합니다. &lt;a href=&quot;qml-qtqml-connections&quot;&gt;연결&lt;/a&gt; 객체는 특정의 어떠한 신호도 수신 할 &lt;a href=&quot;qml-qtqml-connections#target-prop&quot;&gt;대상&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="923702524b8a824d82d474e4042381dd4f8db231" translate="yes" xml:space="preserve">
          <source>In some cases it may be necessary to perform a video mode set on application startup even when the screen reports that the desired resolution is already set. This is normally optimized away, but if the screen stays powered down, try setting the environment variable &lt;code&gt;QT_QPA_EGLFS_ALWAYS_SET_MODE&lt;/code&gt; to a non-zero value and relaunch the application.</source>
          <target state="translated">화면에 원하는 해상도가 이미 설정되어 있다고보고 된 경우에도 응용 프로그램 시작시 설정된 비디오 모드를 수행해야 할 수도 있습니다. 이것은 일반적으로 최적화되지만 화면의 전원이 계속 &lt;code&gt;QT_QPA_EGLFS_ALWAYS_SET_MODE&lt;/code&gt; 있으면 환경 변수 QT_QPA_EGLFS_ALWAYS_SET_MODE 를 0이 아닌 값으로 설정하고 응용 프로그램을 다시 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="21ef113bfb1073bca51faf7d55677f9bc895fdb2" translate="yes" xml:space="preserve">
          <source>In some cases it may be required to call &lt;a href=&quot;qnetworkconfigurationmanager#updateConfigurations&quot;&gt;updateConfigurations&lt;/a&gt;() and wait for the &lt;a href=&quot;qnetworkconfigurationmanager#updateCompleted&quot;&gt;updateCompleted&lt;/a&gt;() signal before calling this function.</source>
          <target state="translated">어떤 경우에는 호출해야 할 수 &lt;a href=&quot;qnetworkconfigurationmanager#updateConfigurations&quot;&gt;updateConfigurations을&lt;/a&gt; ()와 기다리는 &lt;a href=&quot;qnetworkconfigurationmanager#updateCompleted&quot;&gt;updateCompleted&lt;/a&gt; 이 함수를 호출하기 전에, () 신호.</target>
        </trans-unit>
        <trans-unit id="4c02984c7cb3ffce7032812aa08442b7bc00527b" translate="yes" xml:space="preserve">
          <source>In some cases it may be undesirable to play a sound effect - for example, when initiating video recording the sound itself may be recorded.</source>
          <target state="translated">경우에 따라 사운드 효과를 재생하는 것이 바람직하지 않을 수 있습니다. 예를 들어 비디오 녹화를 시작할 때 사운드 자체가 녹음 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="620031e38d73b7471c0d4e44825e6139f594aa81" translate="yes" xml:space="preserve">
          <source>In some cases properties contain a logical group of sub-property attributes. These sub-property attributes can be assigned to using either the dot notation or group notation.</source>
          <target state="translated">경우에 따라 속성에는 하위 속성의 논리적 그룹이 포함됩니다. 이러한 하위 속성 속성은 점 표기법 또는 그룹 표기법을 사용하여 할당 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa9926d183a9d7f0c51856d01ecd9e05f58927d0" translate="yes" xml:space="preserve">
          <source>In some cases the automatic querying of the physical screen size via DRM may fail. Normally the &lt;code&gt;QT_QPA_EGLFS_PHYSICAL_WIDTH&lt;/code&gt; and &lt;code&gt;QT_QPA_EGLFS_PHYSICAL_HEIGHT&lt;/code&gt; environment variable would be used to provide the missing values, however this is not suitable anymore when multiple screens are present. Instead, use the &lt;code&gt;physicalWidth&lt;/code&gt; and &lt;code&gt;physicalHeight&lt;/code&gt; properties in the &lt;code&gt;outputs&lt;/code&gt; list to specify the sizes in millimeters.</source>
          <target state="translated">경우에 따라 DRM을 통한 실제 화면 크기의 자동 쿼리가 실패 할 수 있습니다. 일반적으로 &lt;code&gt;QT_QPA_EGLFS_PHYSICAL_WIDTH&lt;/code&gt; 및 &lt;code&gt;QT_QPA_EGLFS_PHYSICAL_HEIGHT&lt;/code&gt; 환경 변수는 결 측값 을 제공하는 데 사용되지만 여러 화면이있는 경우 더 이상 적합하지 않습니다. 대신 &lt;code&gt;outputs&lt;/code&gt; 목록 에서 &lt;code&gt;physicalWidth&lt;/code&gt; 및 &lt;code&gt;physicalHeight&lt;/code&gt; 속성 을 사용하여 크기를 밀리미터로 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="258ccc09ab212e443008a01568e6bceef2ecfa15" translate="yes" xml:space="preserve">
          <source>In some cases the functionality may not be available (for example, if the current operating system or platform does not provide the required functionality), or it may be temporarily unavailable (for example, audio playback during a phone call or similar).</source>
          <target state="translated">경우에 따라 기능을 사용할 수 없거나 (예 : 현재 운영 체제 또는 플랫폼에서 필요한 기능을 제공하지 않는 경우) 일시적으로 사용하지 못할 수 있습니다 (예 : 전화 통화 중 오디오 재생 등).</target>
        </trans-unit>
        <trans-unit id="85a0516966e42e8b8671b423be1faf9b1e34a91b" translate="yes" xml:space="preserve">
          <source>In some cases the peripheral generates value updates which the central is interested in receiving. In order for a characteristic to support such notifications it must have the &lt;a href=&quot;qlowenergycharacteristic#PropertyType-enum&quot;&gt;QLowEnergyCharacteristic::Notify&lt;/a&gt; or &lt;a href=&quot;qlowenergycharacteristic#PropertyType-enum&quot;&gt;QLowEnergyCharacteristic::Indicate&lt;/a&gt; property and a descriptor of type &lt;a href=&quot;qbluetoothuuid#DescriptorType-enum&quot;&gt;QBluetoothUuid::ClientCharacteristicConfiguration&lt;/a&gt;. Provided those conditions are fulfilled notifications can be enabled as shown in the following code segment:</source>
          <target state="translated">어떤 경우에는 주변 장치가 중앙에서 수신하려는 값 업데이트를 생성합니다. 특성이 이러한 알림을 지원하려면 &lt;a href=&quot;qlowenergycharacteristic#PropertyType-enum&quot;&gt;QLowEnergyCharacteristic :: Notify&lt;/a&gt; 또는 &lt;a href=&quot;qlowenergycharacteristic#PropertyType-enum&quot;&gt;QLowEnergyCharacteristic :: Indicate&lt;/a&gt; 특성과 &lt;a href=&quot;qbluetoothuuid#DescriptorType-enum&quot;&gt;QBluetoothUuid :: ClientCharacteristicConfiguration&lt;/a&gt; 유형의 디스크립터가 있어야 합니다. 이러한 조건이 충족되면 다음 코드 세그먼트에 표시된대로 알림을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a268a7e99380f4ea4cd542df2c6410112901b1e9" translate="yes" xml:space="preserve">
          <source>In some cases the source video stream requires a certain orientation to be correct. This includes sources like a camera viewfinder, where the displayed viewfinder should match reality, no matter what rotation the rest of the user interface has.</source>
          <target state="translated">어떤 경우에는 소스 비디오 스트림에 올바른 방향이 필요합니다. 여기에는 카메라 뷰 파인더와 같은 소스가 포함되는데, 여기에는 나머지 사용자 인터페이스의 회전에 관계없이 표시된 뷰 파인더가 실제와 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="48421f7799ae214cef7492b1c1b972a28a837934" translate="yes" xml:space="preserve">
          <source>In some cases the video buffer might be stored in video memory or otherwise inaccessible memory, so it is necessary to map the buffer before accessing the pixel data. This may involve copying the contents around, so avoid mapping and unmapping unless required.</source>
          <target state="translated">어떤 경우에는 비디오 버퍼가 비디오 메모리 또는 액세스 할 수없는 메모리에 저장 될 수 있으므로 픽셀 데이터에 액세스하기 전에 버퍼를 매핑해야합니다. 여기에는 내용을 복사하는 것이 필요할 수 있으므로 필요한 경우가 아니면 매핑 및 매핑 해제를 피하십시오.</target>
        </trans-unit>
        <trans-unit id="dfb5df4808e66665cfcb730202fb1c7050e20123" translate="yes" xml:space="preserve">
          <source>In some cases the video frame data might be stored in video memory or otherwise inaccessible memory, so it is necessary to map a frame before accessing the pixel data. This may involve copying the contents around, so avoid mapping and unmapping unless required.</source>
          <target state="translated">어떤 경우에는 비디오 프레임 데이터가 비디오 메모리 또는 액세스 할 수없는 메모리에 저장 될 수 있으므로 픽셀 데이터에 액세스하기 전에 프레임을 매핑해야합니다. 여기에는 내용을 복사하는 것이 필요할 수 있으므로 필요한 경우가 아니면 매핑 및 매핑 해제를 피하십시오.</target>
        </trans-unit>
        <trans-unit id="14e9a4063cec4c7bef4f5348419948d27bf2ce39" translate="yes" xml:space="preserve">
          <source>In some cases this may cause unintended behavior. For example, a state that changes a view's</source>
          <target state="translated">경우에 따라 의도하지 않은 동작이 발생할 수 있습니다. 예를 들어 뷰의 상태를 변경하는 상태</target>
        </trans-unit>
        <trans-unit id="a550e6990b7577675be06e7842087f41604449fc" translate="yes" xml:space="preserve">
          <source>In some cases this setting may change automatically as a result of temperature or battery conditions.</source>
          <target state="translated">경우에 따라이 설정은 온도 또는 배터리 조건으로 인해 자동으로 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a6bb4d4e22cf5c7bd4c64610c78b9203a0596cc" translate="yes" xml:space="preserve">
          <source>In some cases when application is complex e.g. it's scene graph contains lot's of Items, scene graph can consume more stack memory than what is available by default for the render thread. Default stack memory size is 64KB. Using the environment variable QSG_RENDERTHREAD_STACK_SIZE, it is possible to increase the stack size available for the scene graph render thread.</source>
          <target state="translated">응용 프로그램이 복잡한 경우 (예 : 장면 그래프에 많은 항목이 포함 된 경우) 장면 그래프는 기본적으로 렌더 스레드에 사용 가능한 것보다 많은 스택 메모리를 사용할 수 있습니다. 기본 스택 메모리 크기는 64KB입니다. 환경 변수 QSG_RENDERTHREAD_STACK_SIZE를 사용하면 장면 그래프 렌더 스레드에 사용 가능한 스택 크기를 늘릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d6f8a4824c8690795d32ad499948e9a1f3af1ecd" translate="yes" xml:space="preserve">
          <source>In some cases you may choose to use a Behavior to animate a property change caused by a state change. While this works well for some situations, in other situations it may lead to unexpected behavior.</source>
          <target state="translated">경우에 따라 동작을 사용하여 상태 변경으로 인한 속성 변경에 애니메이션을 적용 할 수도 있습니다. 이는 일부 상황에서는 잘 작동하지만 다른 상황에서는 예기치 않은 동작이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="54c15ac83d44ce37a0189c329d15b4f928be27be" translate="yes" xml:space="preserve">
          <source>In some cases you may want to modify the value of a property when a certain condition is met but leave it unmodified otherwise. Often, it's not possible to do this with direct bindings, as you have to supply values for all possible branches.</source>
          <target state="translated">경우에 따라 특정 조건이 충족 될 때 속성 값을 수정하고 다른 방법으로는 수정하지 않을 수 있습니다. 가능한 모든 분기에 값을 제공해야하므로 직접 바인딩으로는이 작업을 수행 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="2bda29f7e738612273aabfbb087124bd5833039f" translate="yes" xml:space="preserve">
          <source>In some cases you may wish to use a Loader within a view delegate to improve delegate loading performance. This works well in most cases, but there is one important issue to be aware of related to the &lt;a href=&quot;qml-qtqml-component#creation-context&quot;&gt;creation context&lt;/a&gt; of a Component.</source>
          <target state="translated">경우에 따라 뷰 대리자 내에서 로더를 사용하여 대리자로드 성능을 향상시킬 수 있습니다. 이것은 대부분의 경우 잘 작동하지만 구성 요소 의 &lt;a href=&quot;qml-qtqml-component#creation-context&quot;&gt;생성 컨텍스트&lt;/a&gt; 와 관련하여 알아야 할 중요한 문제가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="874c41570555235045f45e49cda6de0c4b8c78af" translate="yes" xml:space="preserve">
          <source>In some cases, a complex application (for example, using a lot of custom QML components) may cause the QML loader thread to consume stack memory more than the 32 KB available by default. Using the environment variable &lt;code&gt;QML_LOADERTHREAD_STACK_SIZE&lt;/code&gt;, it is possible to increase the stack size available for the QML loader thread.</source>
          <target state="translated">경우에 따라 복잡한 응용 프로그램 (예 : 많은 사용자 지정 QML 구성 요소 사용)으로 인해 QML 로더 스레드가 기본적으로 사용 가능한 32KB보다 큰 스택 메모리를 소비 할 수 있습니다. 환경 변수 &lt;code&gt;QML_LOADERTHREAD_STACK_SIZE&lt;/code&gt; 를 사용하면 QML 로더 스레드에 사용 가능한 스택 크기를 늘릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3b9d9f5d1235fa67ccc3f54fbf189565a53279e2" translate="yes" xml:space="preserve">
          <source>In some cases, it can be useful to be able to detect when the property has actually been assigned the value defined by a state.</source>
          <target state="translated">경우에 따라 속성에 실제로 상태에 의해 정의 된 값이 할당 된시기를 감지 할 수 있으면 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b65be868fcbadc305bdc3cdebf4fd7214cd94b94" translate="yes" xml:space="preserve">
          <source>In some cases, it is relevant when a layout is added to a widget. When you set the widget of a &lt;a href=&quot;qdockwidget&quot;&gt;QDockWidget&lt;/a&gt; or a &lt;a href=&quot;qscrollarea&quot;&gt;QScrollArea&lt;/a&gt; (with &lt;a href=&quot;qdockwidget#setWidget&quot;&gt;QDockWidget::setWidget&lt;/a&gt;() and &lt;a href=&quot;qscrollarea#setWidget&quot;&gt;QScrollArea::setWidget&lt;/a&gt;()), the layout must already have been set on the widget. If not, the widget will not be visible.</source>
          <target state="translated">경우에 따라 레이아웃이 위젯에 추가 될 때 관련이 있습니다. 당신은의 위젯 설정하면 &lt;a href=&quot;qdockwidget&quot;&gt;QDockWidget&lt;/a&gt; 또는 &lt;a href=&quot;qscrollarea&quot;&gt;QScrollArea&lt;/a&gt; (와 &lt;a href=&quot;qdockwidget#setWidget&quot;&gt;QDockWidget :: setWidget&lt;/a&gt; ()와 &lt;a href=&quot;qscrollarea#setWidget&quot;&gt;QScrollArea :: setWidget는&lt;/a&gt; , 레이아웃이 이미 위젯 설정되어 있어야합니다 () 참조). 그렇지 않으면 위젯이 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5dfcad5e5edafeb77b0cca023961159f6802708d" translate="yes" xml:space="preserve">
          <source>In some cases, such as when reparenting between items with clipping enabled, it is useful to animate the parent change via another item that does not have clipping enabled. Such an item can be set using the &lt;a href=&quot;qml-qtquick-parentanimation#via-prop&quot;&gt;via&lt;/a&gt; property.</source>
          <target state="translated">클리핑이 활성화 된 항목 사이의 부모를 변경하는 경우와 같이 경우에 따라 클리핑이 활성화되지 않은 다른 항목을 통해 부모 변경에 애니메이션을 적용하는 것이 유용합니다. 이러한 항목은 &lt;a href=&quot;qml-qtquick-parentanimation#via-prop&quot;&gt;via&lt;/a&gt; 속성을 사용하여 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f1bd3abbd5b8e817487ee69c4f7e2e19dee37c4f" translate="yes" xml:space="preserve">
          <source>In some cases, such as with Unix domain sockets on Linux, the access to the socket will be determined by file system permissions, and are created based on the umask. Setting the access flags will overide this and will restrict or permit access as specified.</source>
          <target state="translated">Linux의 Unix 도메인 소켓과 같은 일부 경우 소켓에 대한 액세스는 파일 시스템 권한에 의해 결정되며 umask를 기반으로 작성됩니다. 액세스 플래그를 설정하면이를 무시하고 지정된대로 액세스를 제한하거나 허용합니다.</target>
        </trans-unit>
        <trans-unit id="654ac9421c46d54fbbfa686e76d8aba1cf1a8945" translate="yes" xml:space="preserve">
          <source>In some cases, the content dimensions can be automatically set based on the &lt;a href=&quot;qml-qtquick-item#childrenRect.width-prop&quot;&gt;childrenRect.width&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-item#childrenRect.height-prop&quot;&gt;childrenRect.height&lt;/a&gt; properties of the &lt;a href=&quot;qml-qtquick-flickable#contentItem-prop&quot;&gt;contentItem&lt;/a&gt;. For example, the previous snippet could be rewritten with:</source>
          <target state="translated">경우 에 따라 &lt;a href=&quot;qml-qtquick-flickable#contentItem-prop&quot;&gt;contentItem&lt;/a&gt; 의 &lt;a href=&quot;qml-qtquick-item#childrenRect.width-prop&quot;&gt;childrenRect.width&lt;/a&gt; 및 &lt;a href=&quot;qml-qtquick-item#childrenRect.height-prop&quot;&gt;childrenRect.height&lt;/a&gt; 속성에 따라 내용 크기를 자동으로 설정할 수 있습니다 . 예를 들어, 이전 스 니펫은 다음과 같이 다시 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5434ee63284e7d3858767cee9240a2601f7fb402" translate="yes" xml:space="preserve">
          <source>In some cases, the impact of increased memory pressure can be extreme. In some situations, trading off memory usage for an assumed performance gain can result in increased page-thrash or cache-thrash, causing a huge reduction in performance. It is always necessary to benchmark the impact of trade-offs carefully in order to determine which solution is best in a given situation.</source>
          <target state="translated">경우에 따라 증가 된 메모리 압력의 영향이 극도로 클 수 있습니다. 경우에 따라 성능 향상을 위해 메모리 사용을 줄이면 페이지 스레 쉬 또는 캐시 스래쉬가 증가하여 성능이 크게 저하 될 수 있습니다. 주어진 상황에서 어떤 솔루션이 가장 적합한 지 결정하기 위해 상충 관계의 영향을 신중하게 벤치마킹해야합니다.</target>
        </trans-unit>
        <trans-unit id="4968ba7999c7294d40c547303ad493ab2ba4767a" translate="yes" xml:space="preserve">
          <source>In some circumstances, for special protocols, it's the local port number can also be used with a query of type &lt;a href=&quot;qnetworkproxyquery#QueryType-enum&quot;&gt;QNetworkProxyQuery::TcpSocket&lt;/a&gt;. When that happens, the socket is indicating it wishes to use the port number</source>
          <target state="translated">경우에 따라 특수 프로토콜의 경우 로컬 포트 ​​번호가 &lt;a href=&quot;qnetworkproxyquery#QueryType-enum&quot;&gt;QNetworkProxyQuery :: TcpSocket&lt;/a&gt; 유형의 쿼리와 함께 사용될 수도 있습니다 . 이런 일이 발생하면 소켓은 포트 번호를 사용하고 싶다고 표시합니다.</target>
        </trans-unit>
        <trans-unit id="3523f113c028f04478865a8bb71a266b290cfdb5" translate="yes" xml:space="preserve">
          <source>In some circumstances, the called slot may not be able to process the request immediately. This is frequently the case when the request involves an I/O or networking operation which may block.</source>
          <target state="translated">경우에 따라 호출 된 슬롯이 요청을 즉시 처리하지 못할 수 있습니다. 요청에 차단 될 수있는 I / O 또는 네트워킹 작업이 포함되는 경우가 종종 있습니다.</target>
        </trans-unit>
        <trans-unit id="241a6483756c0179a4c7b61ebbe5bef1af1389f9" translate="yes" xml:space="preserve">
          <source>In some languages the order of arguments may need to change, and this can easily be achieved by changing the order of the % arguments. For example:</source>
          <target state="translated">일부 언어에서는 인수 순서를 변경해야 할 수도 있으며, % 인수의 순서를 변경하면 쉽게 달성 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1fb478c17aaf1c2efe6aa5581ab0395bfd01ce54" translate="yes" xml:space="preserve">
          <source>In some occasions text edits should not allow the user to input tabulators or change indentation using the &lt;b&gt;Tab&lt;/b&gt; key, as this breaks the focus chain. The default is false.</source>
          <target state="translated">경우에 따라 텍스트 편집을 통해 사용자가 &lt;b&gt;Tab&lt;/b&gt; 키를 사용하여 테이블 레이터를 입력하거나 들여 쓰기를 변경해서는 안됩니다 . 포커스 체인이 끊어지기 때문입니다. 기본값은 false입니다.</target>
        </trans-unit>
        <trans-unit id="fc8e9311f6cecac5035d0591006fca709f8aa184" translate="yes" xml:space="preserve">
          <source>In some scenarios, rendering errors may be introduced and/or performance can suffer in this mode. When objects intersect or overlap each other, depth testing and the two pass rendering technique are necessary to achieve the correct results.</source>
          <target state="translated">일부 시나리오에서는 렌더링 오류가 발생하거나이 모드에서 성능이 저하 될 수 있습니다. 개체가 서로 교차하거나 겹치는 경우 올바른 결과를 얻으려면 깊이 테스트와 2 단계 렌더링 기술이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="b800f8d0d60a9c558d98902c62bde05c9459de23" translate="yes" xml:space="preserve">
          <source>In some situations it is useful to group &lt;a href=&quot;qaction&quot;&gt;QAction&lt;/a&gt; objects together. For example, if you have a &lt;b&gt;Left Align&lt;/b&gt; action, a &lt;b&gt;Right Align&lt;/b&gt; action, a &lt;b&gt;Justify&lt;/b&gt; action, and a &lt;b&gt;Center&lt;/b&gt; action, only one of these actions should be active at any one time. One simple way of achieving this is to group the actions together in an action group, inheriting QActionGroup.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6233e700f5658deeeb11e052468b2ab04255843d" translate="yes" xml:space="preserve">
          <source>In some situations it is useful to group &lt;a href=&quot;qaction&quot;&gt;QAction&lt;/a&gt; objects together. For example, if you have a &lt;b&gt;Left Align&lt;/b&gt; action, a &lt;b&gt;Right Align&lt;/b&gt; action, a &lt;b&gt;Justify&lt;/b&gt; action, and a &lt;b&gt;Center&lt;/b&gt; action, only one of these actions should be active at any one time. One simple way of achieving this is to group the actions together in an action group.</source>
          <target state="translated">어떤 상황에서는 &lt;a href=&quot;qaction&quot;&gt;QAction&lt;/a&gt; 객체를 함께 그룹화하는 것이 유용 합니다. 예를 들어 &lt;b&gt;왼쪽 정렬&lt;/b&gt; 동작, &lt;b&gt;오른쪽 정렬&lt;/b&gt; 동작, 자리 &lt;b&gt;맞추기&lt;/b&gt; 동작 및 &lt;b&gt;가운데&lt;/b&gt; 동작이있는 경우 이러한 동작 중 하나만 한 번에 활성화해야합니다. 이를 달성하는 한 가지 간단한 방법은 조치를 조치 그룹으로 그룹화하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ec01e3125218c7aa7e4acb9ff7f7ab1327614746" translate="yes" xml:space="preserve">
          <source>In some situations, it is possible to trade-off increased memory usage for decreased processing time. For example, caching the result of a symbol lookup used in a tight loop to a temporary variable in a JavaScript expression will result in a significant performance improvement when evaluating that expression, but it involves allocating a temporary variable. In some cases, these trade-offs are sensible (such as the case above, which is almost always sensible), but in other cases it may be better to allow processing to take slightly longer in order to avoid increasing the memory pressure on the system.</source>
          <target state="translated">일부 상황에서는 처리 시간 단축을 위해 증가 된 메모리 사용량을 절충 할 수 있습니다. 예를 들어, 긴밀한 루프에 사용 된 심볼 조회 결과를 JavaScript 표현식의 임시 변수에 캐시하면 해당 표현식을 평가할 때 성능이 크게 향상되지만 임시 변수를 할당해야합니다. 경우에 따라 이러한 상충 관계는 합리적이지만 (위의 경우 거의 항상 합리적 임) 다른 경우에는 시스템의 메모리 압력 증가를 피하기 위해 처리 시간이 약간 더 오래 걸리는 것이 좋습니다. .</target>
        </trans-unit>
        <trans-unit id="3a65e171ba344d27c2bc3135a6656497e102c1bf" translate="yes" xml:space="preserve">
          <source>In some situations, it is useful to give a translation context explicitly by fully qualifying the call to tr(); for example:</source>
          <target state="translated">일부 상황에서는 tr ()에 대한 호출을 완전히 규정하여 번역 컨텍스트를 명시 적으로 제공하는 것이 유용합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="975078149e2e7255befaef187ec5cad85153778c" translate="yes" xml:space="preserve">
          <source>In some situations, the state of one toggle action should depend on the state of others. For example, &quot;Left Align&quot;, &quot;Center&quot; and &quot;Right Align&quot; toggle actions are mutually exclusive. To achieve exclusive toggling, add the relevant toggle actions to a &lt;a href=&quot;qactiongroup&quot;&gt;QActionGroup&lt;/a&gt; with the &lt;a href=&quot;qactiongroup#exclusive-prop&quot;&gt;QActionGroup::exclusive&lt;/a&gt; property set to true.</source>
          <target state="translated">어떤 상황에서는 하나의 토글 동작 상태가 다른 상태에 의존해야합니다. 예를 들어 &quot;왼쪽 정렬&quot;, &quot;중앙&quot;및 &quot;오른쪽 정렬&quot;토글 동작은 상호 배타적입니다. 배타적 인 토글을 달성하기 위해,에 관련 토글 작업을 추가 &lt;a href=&quot;qactiongroup&quot;&gt;QActionGroup&lt;/a&gt; 와 &lt;a href=&quot;qactiongroup#exclusive-prop&quot;&gt;QActionGroup :: 배타적 인&lt;/a&gt; 속성을 true로 설정.</target>
        </trans-unit>
        <trans-unit id="323c27f7a345a0e27d2fef8ef7183d984fb16109" translate="yes" xml:space="preserve">
          <source>In some situations, the state of one toggle action should depend on the state of others. For example, &quot;Left Align&quot;, &quot;Center&quot; and &quot;Right Align&quot; toggle actions are mutually exclusive. To achieve exclusive toggling, add the relevant toggle actions to a &lt;a href=&quot;qactiongroup&quot;&gt;QActionGroup&lt;/a&gt; with the QActionGroup::exclusive property set to true.</source>
          <target state="translated">어떤 상황에서는 한 전환 작업의 상태가 다른 작업의 상태에 따라 달라져야합니다. 예를 들어, &quot;왼쪽 정렬&quot;, &quot;가운데&quot;및 &quot;오른쪽 정렬&quot;토글 동작은 상호 배타적입니다. 독점 토글을 수행하려면 QActionGroup :: exclusive 특성을 true로 설정 하여 관련 토글 조치를 &lt;a href=&quot;qactiongroup&quot;&gt;QActionGroup에&lt;/a&gt; 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="da099b7b9b3cf8dd0ef98773710f3f41aa5b9afe" translate="yes" xml:space="preserve">
          <source>In some situations, the width of regions 2 and 8 may not be an exact multiple of the width of the corresponding regions in the source image. Similarly, the height of regions 4 and 6 may not be an exact multiple of the height of the corresponding regions. It can be useful to use &lt;a href=&quot;qml-qtquick-borderimage#horizontalTileMode-prop&quot;&gt;BorderImage.Round&lt;/a&gt; instead of &lt;a href=&quot;qml-qtquick-borderimage#horizontalTileMode-prop&quot;&gt;BorderImage.Repeat&lt;/a&gt; in cases like these.</source>
          <target state="translated">일부 상황에서, 영역 2 및 8의 폭은 소스 이미지에서 대응하는 영역의 폭의 정확한 배수가 아닐 수있다. 유사하게, 영역 4 및 6의 높이는 대응하는 영역의 높이의 정확한 배수가 아닐 수있다. 사용하기 유용 할 수 &lt;a href=&quot;qml-qtquick-borderimage#horizontalTileMode-prop&quot;&gt;BorderImage.Round&lt;/a&gt; 대신 &lt;a href=&quot;qml-qtquick-borderimage#horizontalTileMode-prop&quot;&gt;BorderImage.Repeat을&lt;/a&gt; 이와 같은 경우에.</target>
        </trans-unit>
        <trans-unit id="cccf8fea954dfdae839b9b461ce87885d251e3ef" translate="yes" xml:space="preserve">
          <source>In some special cases it may be necessary to override the Vulkan library name. This can be achieved by setting the &lt;code&gt;QT_VULKAN_LIB&lt;/code&gt; environment variable.</source>
          <target state="translated">일부 특수한 경우 Vulkan 라이브러리 이름을 대체해야 할 수도 있습니다. 이는 &lt;code&gt;QT_VULKAN_LIB&lt;/code&gt; 환경 변수를 설정하여 달성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="597877827cd82985b7564fa6e61767164b61770b" translate="yes" xml:space="preserve">
          <source>In some state machines it can be useful to focus the attention on assigning properties in states, not on restoring them when the state is no longer active. If you know that a property should always be restored to its initial value when the machine enters a state that does not explicitly give the property a value, you can set the global restore policy to &lt;a href=&quot;qstate#RestorePolicy-enum&quot;&gt;QStateMachine::RestoreProperties&lt;/a&gt;.</source>
          <target state="translated">일부 상태 시스템에서는 상태가 더 이상 활성화되지 않은 경우 상태를 복원하는 것이 아니라 상태에 속성을 할당하는 데주의를 기울이는 것이 유용 할 수 있습니다. 시스템이 명시 적으로 특성에 값을 제공하지 않는 상태가 될 때 특성을 항상 초기 값으로 복원해야한다는 것을 알고 있으면 글로벌 복원 정책을 &lt;a href=&quot;qstate#RestorePolicy-enum&quot;&gt;QStateMachine :: RestoreProperties&lt;/a&gt; 로 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ef8acd187a435dd6a714e2f0e2e4336b32bbc6db" translate="yes" xml:space="preserve">
          <source>In some use cases it may be necessary to turn the interface off despite of open sessions. This can be achieved by calling &lt;a href=&quot;qnetworksession#stop&quot;&gt;stop()&lt;/a&gt;. An example use case could be a network manager type of application allowing the user to control the overall state of the devices connectivity.</source>
          <target state="translated">일부 사용 사례에서는 열린 세션에도 불구하고 인터페이스를 꺼야 할 수도 있습니다. 이것은 &lt;a href=&quot;qnetworksession#stop&quot;&gt;stop ()&lt;/a&gt; 을 호출하여 달성 할 수 있습니다 . 사용 사례의 예로는 사용자가 장치 연결의 전체 상태를 제어 할 수있는 네트워크 관리자 유형의 응용 프로그램이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c0bc9e6bd03c67533a62525483e2f23d095adcd" translate="yes" xml:space="preserve">
          <source>In some use cases the horizontal axis grid is mostly covered by the surface, so it can be more useful to display the horizontal axis grid on top of the graph rather than on the bottom. A typical use case for this is showing 2D spectrograms using orthoGraphic projection with a top-down viewpoint.</source>
          <target state="translated">일부 사용 사례에서 가로 축 격자는 대부분 표면으로 덮여 있으므로 가로 축 격자를 아래쪽이 아니라 그래프 위에 표시하는 것이 더 유용 할 수 있습니다. 이를위한 일반적인 사용 사례는 하향식 관점에서 직교 그래픽 투영을 사용하여 2D 스펙트로 그램을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="013226cabeda2af6ef8f227f857dcd13ebf3e1ea" translate="yes" xml:space="preserve">
          <source>In special cases tests may want to disable the processing of the events. This can be achieved by setting</source>
          <target state="translated">특별한 경우 테스트에서 이벤트 처리를 사용하지 않을 수 있습니다. 이것은 설정하여 얻을 수 있습니다</target>
        </trans-unit>
        <trans-unit id="7452d49f64c970393bfd80306f87f3e26f44a0f2" translate="yes" xml:space="preserve">
          <source>In standard views, a</source>
          <target state="translated">표준보기에서</target>
        </trans-unit>
        <trans-unit id="ae4b097ff709c25e429ac49f202a71496bfc7f8a" translate="yes" xml:space="preserve">
          <source>In such Qt builds, many Qt shared libraries, and also Qt applications will have a dependency to opengl32.dll, and therefore using an alternative library is not possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="164a5aefb4e39073a4a04fead6f543c66536fbb1" translate="yes" xml:space="preserve">
          <source>In such cases, the following yields the expected results:</source>
          <target state="translated">이러한 경우 다음 결과가 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="8f544ece13de7f5c398d0ce0f69c0fcaea9d7c95" translate="yes" xml:space="preserve">
          <source>In summary, &lt;a href=&quot;qvarlengtharray&quot;&gt;QVarLengthArray&lt;/a&gt; is a low-level optimization class that only makes sense in very specific cases. It is used a few places inside Qt and was added to Qt's public API for the convenience of advanced users.</source>
          <target state="translated">요약하면, &lt;a href=&quot;qvarlengtharray&quot;&gt;QVarLengthArray&lt;/a&gt; 는 매우 특정한 경우에만 적합한 저수준 최적화 클래스입니다. Qt 내부에서 몇 군데 사용되며 고급 사용자의 편의를 위해 Qt의 공개 API에 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="01404b1665ff5bee8b39009a3dbb648e5cfcb96f" translate="yes" xml:space="preserve">
          <source>In summary, QVarLengthArray is a low-level optimization class that only makes sense in very specific cases. It is used a few places inside Qt and was added to Qt's public API for the convenience of advanced users.</source>
          <target state="translated">요약하면 QVarLengthArray는 매우 특정한 경우에만 의미가있는 저수준 최적화 클래스입니다. Qt 내부 몇 군데에서 사용되며 고급 사용자의 편의를 위해 Qt의 공용 API에 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="f370d8fd1ae76025ade06837edabb5a99c24598d" translate="yes" xml:space="preserve">
          <source>In summary, to set an icon, use</source>
          <target state="translated">요약하면, 아이콘을 설정하려면</target>
        </trans-unit>
        <trans-unit id="fed7d9752b11297f2deeaad7c01533dae2c3f1b9" translate="yes" xml:space="preserve">
          <source>In syntactic terms, a QML object type is one which can be used to declare an object by specifying the</source>
          <target state="translated">구문 용어로, QML 오브젝트 유형은 다음을 지정하여 오브젝트를 선언하는 데 사용할 수있는 유형입니다.</target>
        </trans-unit>
        <trans-unit id="b56fa35038d379699c4022d19966422243f5e330" translate="yes" xml:space="preserve">
          <source>In terms of stacking order, this component is displayed above the delegate and highlight components, but below the foreground component.</source>
          <target state="translated">쌓인 순서와 관련하여이 구성 요소는 델리게이트 및 강조 구성 요소 위에 있지만 전경 구성 요소 아래에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="457e23421e8521cf6f1ded404af0fb789b691073" translate="yes" xml:space="preserve">
          <source>In that case, &lt;a href=&quot;qml-qtcharts-pieseries#at-method&quot;&gt;PieSeries.at()&lt;/a&gt; or &lt;a href=&quot;qml-qtcharts-pieseries#find-method&quot;&gt;PieSeries.find&lt;/a&gt; can be used to access the properties of an individual &lt;a href=&quot;qml-qtcharts-pieslice&quot;&gt;PieSlice&lt;/a&gt; instance.</source>
          <target state="translated">이 경우 &lt;a href=&quot;qml-qtcharts-pieseries#at-method&quot;&gt;PieSeries.at ()&lt;/a&gt; 또는 &lt;a href=&quot;qml-qtcharts-pieseries#find-method&quot;&gt;PieSeries.find&lt;/a&gt; 를 사용하여 개별 &lt;a href=&quot;qml-qtcharts-pieslice&quot;&gt;PieSlice&lt;/a&gt; 인스턴스 의 속성에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9f0c0bbbbb610108981afd9c9bfd9139b4fbbf67" translate="yes" xml:space="preserve">
          <source>In that case, &lt;a href=&quot;qml-qtcharts-pieseries#at-method&quot;&gt;PieSeries.at()&lt;/a&gt; or &lt;a href=&quot;qml-qtcharts-pieseries#find-method&quot;&gt;PieSeries.find&lt;/a&gt; can be used to access the properties of an individual PieSlice instance.</source>
          <target state="translated">이 경우 &lt;a href=&quot;qml-qtcharts-pieseries#at-method&quot;&gt;PieSeries.at ()&lt;/a&gt; 또는 &lt;a href=&quot;qml-qtcharts-pieseries#find-method&quot;&gt;PieSeries.find&lt;/a&gt; 를 사용하여 개별 PieSlice 인스턴스의 속성에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5790208d3978b524af92d93f41391c3573ec2c57" translate="yes" xml:space="preserve">
          <source>In that example, the thread will exit after the run function has returned. There will not be any event loop running in the thread unless you call &lt;a href=&quot;qthread#exec&quot;&gt;exec&lt;/a&gt;().</source>
          <target state="translated">이 예에서, 실행 기능이 리턴 된 후 스레드가 종료됩니다. &lt;a href=&quot;qthread#exec&quot;&gt;exec&lt;/a&gt; () 를 호출하지 않으면 스레드에서 실행중인 이벤트 루프가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="b6abefb0ebc02351d5d08f8505d9c39811bfa807" translate="yes" xml:space="preserve">
          <source>In the</source>
          <target state="translated">에서</target>
        </trans-unit>
        <trans-unit id="0f13869d816e7c62f6a51e2c34e2ea27e0c6e194" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtdbus-complexpingpong-example.html#&quot;&gt;D-Bus Complex Ping Pong Example&lt;/a&gt;, &lt;code&gt;complexpong.h&lt;/code&gt; and &lt;code&gt;complexpong.cpp&lt;/code&gt; show an implementation of &lt;a href=&quot;qdbusabstractadaptor&quot;&gt;QDBusAbstractAdaptor&lt;/a&gt;.</source>
          <target state="translated">에서 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtdbus-complexpingpong-example.html#&quot;&gt;D 버스 복합 핑퐁 예&lt;/a&gt; , &lt;code&gt;complexpong.h&lt;/code&gt; 및 &lt;code&gt;complexpong.cpp&lt;/code&gt; 는 구현 표시 &lt;a href=&quot;qdbusabstractadaptor&quot;&gt;QDBusAbstractAdaptor를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ec35b4a3a60508bb357e68a03513ab97f33987bb" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtdbus-complexpingpong-example.html&quot;&gt;D-Bus Complex Ping Pong Example&lt;/a&gt;, &lt;code&gt;complexpong.h&lt;/code&gt; and &lt;code&gt;complexpong.cpp&lt;/code&gt; show an implementation of &lt;a href=&quot;qdbusabstractadaptor&quot;&gt;QDBusAbstractAdaptor&lt;/a&gt;.</source>
          <target state="translated">에서 &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtdbus-complexpingpong-example.html&quot;&gt;D 버스 복합 핑퐁 예&lt;/a&gt; , &lt;code&gt;complexpong.h&lt;/code&gt; 및 &lt;code&gt;complexpong.cpp&lt;/code&gt; 는 구현 표시 &lt;a href=&quot;qdbusabstractadaptor&quot;&gt;QDBusAbstractAdaptor를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d5aa6e54082c84913b42e7e887fa2cf527cc4e23" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;https://doc.qt.io/qt-6.0/qtdbus-complexpingpong-example.html&quot;&gt;D-Bus Complex Ping Pong Example&lt;/a&gt;, &lt;code&gt;complexpong.h&lt;/code&gt; and &lt;code&gt;complexpong.cpp&lt;/code&gt; show an implementation of &lt;a href=&quot;qdbusabstractadaptor&quot;&gt;QDBusAbstractAdaptor&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="162bc0b4a098f3761ef3249d00dace83612c0945" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;qabstracttransition#eventTest&quot;&gt;eventTest()&lt;/a&gt; reimplementation, we first check if the event type is the desired one; if so, we cast the event to a &lt;code&gt;StringEvent&lt;/code&gt; and perform the string comparison.</source>
          <target state="translated">년 &lt;a href=&quot;qabstracttransition#eventTest&quot;&gt;에 EventTest ()&lt;/a&gt; 이벤트 타입이 하나 다시 구현하고자하는 경우, 먼저 확인; 그렇다면 이벤트를 &lt;code&gt;StringEvent&lt;/code&gt; 로 캐스트 하고 문자열 비교를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="57e431c91e3a785910255234cef24a4c0ecd15c4" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; / &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; world, it is some times favorable to cache complex content in a pixmap, image or texture. In Qt Quick, because of the techniques already applied by the &lt;a href=&quot;qtquick-visualcanvas-scenegraph-renderer#&quot;&gt;scene graph renderer&lt;/a&gt;, this will in most cases not be the case. Excessive draw calls are already reduced because of batching and a cache will in most cases end up blending more pixels than the original content. The overhead of rendering to an offscreen and the blending involved with drawing the resulting texture is therefore often more costly than simply letting the item and its children be drawn normally.</source>
          <target state="translated">에서 &lt;a href=&quot;qpainter&quot;&gt;QPainter를&lt;/a&gt; / &lt;a href=&quot;qwidget&quot;&gt;는 QWidget의&lt;/a&gt; 세계, 그것은 픽스맵, 이미지 또는 질감의 복잡한 내용을 캐시에 유리한 몇 번이다. Qt Quick에서는 &lt;a href=&quot;qtquick-visualcanvas-scenegraph-renderer#&quot;&gt;장면 그래프 렌더러&lt;/a&gt; 에서 이미 적용된 기술로 인해 대부분의 경우 그렇지 않습니다. 일괄 처리로 인해 과도한 그리기 호출이 이미 줄어들 었으며 대부분의 경우 캐시는 원래 콘텐츠보다 많은 픽셀을 혼합하게됩니다. 따라서 오프 스크린으로 렌더링하는 오버 헤드와 결과 텍스처를 그리는 데 관련된 블렌딩은 단순히 항목과 해당 자식을 정상적으로 그리는 것보다 비용이 많이 듭니다.</target>
        </trans-unit>
        <trans-unit id="a2244c8990bf5c7b0af9090a75b57eab78f7c963" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; / &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; world, it is sometimes favorable to cache complex content in a pixmap, image or texture. In Qt Quick, because of the techniques already applied by the &lt;a href=&quot;qtquick-visualcanvas-scenegraph-renderer&quot;&gt;scene graph renderer&lt;/a&gt;, this will in most cases not be the case. Excessive draw calls are already reduced because of batching and a cache will in most cases end up blending more pixels than the original content. The overhead of rendering to an offscreen and the blending involved with drawing the resulting texture is therefore often more costly than simply letting the item and its children be drawn normally.</source>
          <target state="translated">에서 &lt;a href=&quot;qpainter&quot;&gt;QPainter를&lt;/a&gt; / &lt;a href=&quot;qwidget&quot;&gt;는 QWidget의&lt;/a&gt; 세계, 픽스맵, 이미지 또는 질감의 복잡한 내용을 캐시 때때로 유리하다. Qt Quick에서는 &lt;a href=&quot;qtquick-visualcanvas-scenegraph-renderer&quot;&gt;장면 그래프 렌더러&lt;/a&gt; 에서 이미 적용한 기술 때문에 대부분의 경우 그렇지 않습니다. 일괄 처리로 인해 과도한 드로우 콜이 이미 줄어들 었으며 캐시는 대부분의 경우 원본 콘텐츠보다 더 많은 픽셀을 혼합하게됩니다. 따라서 오프 스크린으로 렌더링하는 오버 헤드와 결과 텍스처 그리기와 관련된 블렌딩은 항목과 해당 자식을 정상적으로 그리는 것보다 더 많은 비용이 드는 경우가 많습니다.</target>
        </trans-unit>
        <trans-unit id="eea9e8dff487c0e0fb359df06250577b27da332a" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; / &lt;a href=&quot;widgets-changes-qt6#qwidget&quot;&gt;QWidget&lt;/a&gt; world, it is sometimes favorable to cache complex content in a pixmap, image or texture. In Qt Quick, because of the techniques already applied by the &lt;a href=&quot;qtquick-visualcanvas-scenegraph-renderer&quot;&gt;scene graph renderer&lt;/a&gt;, this will in most cases not be the case. Excessive draw calls are already reduced because of batching and a cache will in most cases end up blending more pixels than the original content. The overhead of rendering to an offscreen and the blending involved with drawing the resulting texture is therefore often more costly than simply letting the item and its children be drawn normally.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37d939b74cde175b71c6be9dd50c53f23af1da98" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;qsensor#AxesOrientationMode-enum&quot;&gt;AutomaticOrientation&lt;/a&gt; mode, the readings are rotated based on the screen orientation, and therefore this property will be equal to the current screen orientation.</source>
          <target state="translated">에서 &lt;a href=&quot;qsensor#AxesOrientationMode-enum&quot;&gt;AutomaticOrientation의&lt;/a&gt; 모드, 수치는 화면 방향에 기초하여 회전되고, 따라서,이 속성은 현재 화면 방향과 동일 할 것이다.</target>
        </trans-unit>
        <trans-unit id="04f88163784997d8102c2cef5150b940a5e480ff" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;qsensor#AxesOrientationMode-enum&quot;&gt;UserOrientation&lt;/a&gt; mode, the readings are rotated based on the &lt;a href=&quot;qsensor#userOrientation-prop&quot;&gt;userOrientation&lt;/a&gt; property, and therefore this property is equal to the &lt;a href=&quot;qsensor#userOrientation-prop&quot;&gt;userOrientation&lt;/a&gt; property.</source>
          <target state="translated">에서 &lt;a href=&quot;qsensor#AxesOrientationMode-enum&quot;&gt;UserOrientation의&lt;/a&gt; 모드에서 판독에 기초하여 회전 &lt;a href=&quot;qsensor#userOrientation-prop&quot;&gt;userOrientation의&lt;/a&gt; 속성 때문에이 특성은 동일하다 &lt;a href=&quot;qsensor#userOrientation-prop&quot;&gt;userOrientation의&lt;/a&gt; 속성.</target>
        </trans-unit>
        <trans-unit id="bdd706a711fa67c209b0d0c2e27f9e33fd367aec" translate="yes" xml:space="preserve">
          <source>In the &lt;b&gt;App IDs&lt;/b&gt; tab of the &lt;b&gt;Developer Certificate, Identifiers, and Profiles&lt;/b&gt; manager, click the &lt;b&gt;+&lt;/b&gt; button to create a New App ID. This will open up the page to register a new iOS App ID.</source>
          <target state="translated">&lt;b&gt;개발자 인증서, 식별자 및 프로필&lt;/b&gt; 관리자 의 &lt;b&gt;앱 ID&lt;/b&gt; 탭 에서 &lt;b&gt;+&lt;/b&gt; 버튼을 클릭하여 새 앱 ID를 만듭니다. 새 iOS 앱 ID를 등록 할 수있는 페이지가 열립니다.&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f5dd03a24aeea45b153e932a3e0af98ee040f6ff" translate="yes" xml:space="preserve">
          <source>In the &lt;b&gt;App Services&lt;/b&gt; area make sure that the &lt;b&gt;In-App Purchases&lt;/b&gt; is checked. Click &lt;b&gt;continue&lt;/b&gt; your to complete the App ID registration.</source>
          <target state="translated">에서 &lt;b&gt;앱 서비스&lt;/b&gt; 영역을 확인 있는지 확인 &lt;b&gt;인앱 구입이&lt;/b&gt; 확인됩니다. &lt;b&gt;계속을&lt;/b&gt; 클릭 하여 앱 ID 등록을 완료하십시오.</target>
        </trans-unit>
        <trans-unit id="87da9cea12fe9772bb40ec9890618272be8747c5" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;.plist&lt;/code&gt; file, you can define some variables which qmake will replace with the relevant values:</source>
          <target state="translated">에서 &lt;code&gt;.plist&lt;/code&gt; 파일, 당신은 qmake에가 관련 값으로 대체합니다 몇 가지 변수를 정의 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="69a9fd76bba1bfb4f2c2688ac8a1fb05feb5a9bb" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;.pro&lt;/code&gt; file for your application, you need the following entry:</source>
          <target state="translated">응용 프로그램 의 &lt;code&gt;.pro&lt;/code&gt; 파일에서 다음 항목이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="fc24789ab06f08f55a0fc23861c4c281824df067" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;service_main.cpp&lt;/code&gt; you could have the following:</source>
          <target state="translated">에서 &lt;code&gt;service_main.cpp&lt;/code&gt; 당신은 다음을 할 수 :</target>
        </trans-unit>
        <trans-unit id="cdbd9ad121de8e48729b5f47fbd44bf610991787" translate="yes" xml:space="preserve">
          <source>In the C++ file:</source>
          <target state="translated">C ++ 파일에서 :</target>
        </trans-unit>
        <trans-unit id="dd084a5753431273388f3e60f04ad68299a55461" translate="yes" xml:space="preserve">
          <source>In the DOM specification, this is the only way to create a non-null document. For historical reasons, Qt also allows to create the document using the default empty constructor. The resulting document is null, but becomes non-null when a factory function, for example &lt;a href=&quot;qdomdocument#createElement&quot;&gt;QDomDocument::createElement&lt;/a&gt;(), is called. The document also becomes non-null when setContent() is called.</source>
          <target state="translated">DOM 스펙에서 이것은 널이 아닌 문서를 작성하는 유일한 방법입니다. 역사적인 이유로 Qt는 기본 빈 생성자를 사용하여 문서를 만들 수도 있습니다. 결과 문서는 널이지만 팩토리 함수 ( 예 &lt;a href=&quot;qdomdocument#createElement&quot;&gt;: QDomDocument :: createElement&lt;/a&gt; ())가 호출 되면 널이 아닙니다 . setContent ()가 호출 될 때 문서도 널이되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5b680088f957473689841e354e1bde6dde64d84e" translate="yes" xml:space="preserve">
          <source>In the Gregorian calendar, there is no year 0. Dates in that year are considered invalid. The year -1 is the year &quot;1 before Christ&quot; or &quot;1 before common era.&quot; The day before 1 January 1 CE, QDate(1, 1, 1), is 31 December 1 BCE, QDate(-1, 12, 31). Various other calendars behave similarly; see &lt;a href=&quot;qcalendar#hasYearZero&quot;&gt;QCalendar::hasYearZero&lt;/a&gt;().</source>
          <target state="translated">그레고리력에는 0 년이 없습니다. 해당 연도의 날짜는 유효하지 않은 것으로 간주됩니다. -1 년은 &quot;그리스도 전 1&quot;또는 &quot;평범한 시대 전 1&quot;입니다. 1 월 1 일 CE, QDate (1, 1, 1) 전날은 BCE 12 월 31 일, QDate (-1, 12, 31)입니다. 다른 다양한 달력도 비슷하게 작동합니다. &lt;a href=&quot;qcalendar#hasYearZero&quot;&gt;QCalendar :: hasYearZero&lt;/a&gt; ()를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d4d9f0a10c4c9a854dec147039223243e7e0b574" translate="yes" xml:space="preserve">
          <source>In the Idle state it's allowed to query camera capabilities, set capture resolution, codecs, etc.</source>
          <target state="translated">유휴 상태에서는 카메라 기능을 쿼리하고 캡처 해상도, 코덱 등을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8bb5ed0dca5213d6a5fe8fbcc42e41cf037c8b58" translate="yes" xml:space="preserve">
          <source>In the Idle state you can query camera capabilities, set capture resolution, codecs, and so on.</source>
          <target state="translated">유휴 상태에서는 카메라 기능을 쿼리하고 캡처 해상도, 코덱 등을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f1db5d804394981f915e76bc91755412488c5ac5" translate="yes" xml:space="preserve">
          <source>In the Java style, the tab bar shape and label have the same bounding rectangle as &lt;code&gt;CE_TabBarTab&lt;/code&gt;. Notice that the tabs overlap with the tab widget frame. The base of the tab bar (if drawn) is the area where the tabs and frame overlap.</source>
          <target state="translated">Java 스타일에서 탭 막대 모양 및 레이블은 &lt;code&gt;CE_TabBarTab&lt;/code&gt; 과 동일한 경계 사각형을 갖습니다 . 탭이 탭 위젯 프레임과 겹칩니다. 탭 막대의 밑면 (그리면)은 탭과 프레임이 겹치는 영역입니다.</target>
        </trans-unit>
        <trans-unit id="7b4ece440c8d95e4496540cedfce41fe09a8d424" translate="yes" xml:space="preserve">
          <source>In the QML language syntax, there is a notion of &lt;a href=&quot;qtqml-syntax-objectattributes#attached-properties-and-attached-signal-handlers&quot;&gt;&lt;i&gt;attached properties&lt;/i&gt; and &lt;i&gt;attached signal handlers&lt;/i&gt;&lt;/a&gt;, which are additional attributes that are attached to an object. Essentially, such attributes are implemented and provided by an</source>
          <target state="translated">QML 언어 구문 에는 오브젝트에 첨부 된 추가 속성 인 &lt;a href=&quot;qtqml-syntax-objectattributes#attached-properties-and-attached-signal-handlers&quot;&gt;&lt;i&gt;첨부 된 특성&lt;/i&gt; 및 &lt;i&gt;첨부 된 신호 핸들러&lt;/i&gt;&lt;/a&gt; 개념이 있습니다. 본질적으로 이러한 속성은</target>
        </trans-unit>
        <trans-unit id="9de994ae7065ff0629ef8698d52fae0aa9afa8c5" translate="yes" xml:space="preserve">
          <source>In the Unix/X11 AT-SPI implementation, applications become accessible when two conditions are met:</source>
          <target state="translated">Unix / X11 AT-SPI 구현에서 두 가지 조건이 충족되면 애플리케이션에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee9e81d8cc3e8a4adfc5e0c7748b208cfc6fe7c0" translate="yes" xml:space="preserve">
          <source>In the WHERE statement, each non-null field of</source>
          <target state="translated">WHERE 문에서 널이 아닌 각 필드는</target>
        </trans-unit>
        <trans-unit id="6f6f7ad4674c4c4505b592190446eb701f994122" translate="yes" xml:space="preserve">
          <source>In the Widget Editing Mode, objects can be dragged from the main window's widget box to a form, edited, resized, dragged around on the form, and even dragged between forms. Object properties can be modified interactively, so that changes can be seen immediately. The editing interface is intuitive for simple operations, yet it still supports Qt's powerful layout facilities.</source>
          <target state="translated">위젯 편집 모드에서는 객체를 기본 창의 위젯 상자에서 폼으로 드래그, 편집, 크기 조정, 폼에서 드래그 및 폼간에 드래그 할 수 있습니다. 객체 속성을 대화식으로 수정하여 변경 사항을 즉시 볼 수 있습니다. 편집 인터페이스는 간단한 조작을 위해 직관적이지만 여전히 Qt의 강력한 레이아웃 기능을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="67556c80897d5a3a2c3176910f8fb2db8eb1c615" translate="yes" xml:space="preserve">
          <source>In the above assignment, the value of &lt;code&gt;PWD&lt;/code&gt; is read immediately when the project file is processed, but &lt;code&gt;$(PWD)&lt;/code&gt; is assigned to &lt;code&gt;DESTDIR&lt;/code&gt; in the generated Makefile. This makes the build process more flexible as long as the environment variable is set correctly when the Makefile is processed.</source>
          <target state="translated">위 지정 에서 프로젝트 파일이 처리되면 &lt;code&gt;PWD&lt;/code&gt; 값을 즉시 읽지 만 &lt;code&gt;$(PWD)&lt;/code&gt; 는 생성 된 Makefile의 &lt;code&gt;DESTDIR&lt;/code&gt; 에 지정됩니다 . 따라서 Makefile을 처리 할 때 환경 변수가 올바르게 설정되어 있으면 빌드 프로세스가보다 유연 해집니다.</target>
        </trans-unit>
        <trans-unit id="b3a0e96d852ac671feaa2b81ca3ff3c7721420ca" translate="yes" xml:space="preserve">
          <source>In the above assignment, the value of the &lt;code&gt;PWD&lt;/code&gt; environment variable is read when the project file is processed.</source>
          <target state="translated">위의 할당 에서 프로젝트 파일이 처리 될 때 &lt;code&gt;PWD&lt;/code&gt; 환경 변수 의 값을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="4849f955a25344dd83e2b80d8df33bfd22e7919d" translate="yes" xml:space="preserve">
          <source>In the above case, the path start will be the item's current position, and the path end will be the item's target position in the target state.</source>
          <target state="translated">위의 경우 경로 시작은 항목의 현재 위치가되고 경로 끝은 대상 상태의 항목의 대상 위치가됩니다.</target>
        </trans-unit>
        <trans-unit id="791c8130e8761a8f3bf03bea7cbc7d087cb6621a" translate="yes" xml:space="preserve">
          <source>In the above code, a whole word is selected using this method. &lt;a href=&quot;qtextcursor&quot;&gt;QTextCursor&lt;/a&gt; provides a number of common move operations for selecting individual characters, words, lines, and whole blocks.</source>
          <target state="translated">위 코드에서이 방법을 사용하여 전체 단어를 선택합니다. &lt;a href=&quot;qtextcursor&quot;&gt;QTextCursor&lt;/a&gt; 는 개별 문자, 단어, 줄 및 전체 블록을 선택하기위한 여러 가지 일반적인 이동 작업을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="92adf25594982f9941ca5d04e0e063244190206a" translate="yes" xml:space="preserve">
          <source>In the above code, since the model is derived from &lt;a href=&quot;qstringlistmodel&quot;&gt;QStringListModel&lt;/a&gt;, we obtain a default set of flags by calling its implementation of the flags() function.</source>
          <target state="translated">위 코드에서 모델은 &lt;a href=&quot;qstringlistmodel&quot;&gt;QStringListModel&lt;/a&gt; 에서 파생 되었으므로 flags () 함수의 구현을 호출하여 기본 플래그 세트를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="23f203a1c2478fd4ea15e9a8717f6fa6de040c82" translate="yes" xml:space="preserve">
          <source>In the above diagram, a semi-transparent rectangular child widget with an area removed is constructed and added to a parent widget (a &lt;a href=&quot;qlabel&quot;&gt;QLabel&lt;/a&gt; showing a pixmap). Then, different properties and widget attributes are set to achieve different effects:</source>
          <target state="translated">위의 다이어그램에서, 영역이 제거 된 반투명 사각형 자식 위젯이 구성되고 부모 위젯 ( pixmap을 표시하는 &lt;a href=&quot;qlabel&quot;&gt;QLabel&lt;/a&gt; )에 추가됩니다. 그런 다음 다른 속성과 위젯 속성이 다른 효과를 얻도록 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="dea94ee650dbb2f98833468075bf1634d06c70c9" translate="yes" xml:space="preserve">
          <source>In the above example the &lt;a href=&quot;qbytearray#replace&quot;&gt;replace&lt;/a&gt;() function's first two arguments are the position from which to start replacing and the number of bytes that should be replaced.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0faa87e2786bc7816634decf32116ffc37e6509" translate="yes" xml:space="preserve">
          <source>In the above example we circumvent the last rule by adding a</source>
          <target state="translated">위의 예에서 우리는 마지막 규칙을 우회하여</target>
        </trans-unit>
        <trans-unit id="4fce397b35eb53fa7404ef938c55c61d0545cc0b" translate="yes" xml:space="preserve">
          <source>In the above example, a modal &lt;a href=&quot;qfiledialog&quot;&gt;QFileDialog&lt;/a&gt; is created using a static function. The dialog initially displays the contents of the &quot;/home/jana&quot; directory, and displays files matching the patterns given in the string &quot;Image Files (*.png *.jpg *.bmp)&quot;. The parent of the file dialog is set to</source>
          <target state="translated">위의 예제에서, 모달 &lt;a href=&quot;qfiledialog&quot;&gt;QFileDialog&lt;/a&gt; 는 정적 함수를 사용하여 작성됩니다. 이 대화 상자는 처음에 &quot;/ home / jana&quot;디렉토리의 내용을 표시하고 &quot;Image Files (* .png * .jpg * .bmp)&quot;문자열에 지정된 패턴과 일치하는 파일을 표시합니다. 파일 대화 상자의 부모가</target>
        </trans-unit>
        <trans-unit id="90fff16b05f63307cc41cfbf8deedb141ddc8f7e" translate="yes" xml:space="preserve">
          <source>In the above example, a modal QFileDialog is created using a static function. The dialog initially displays the contents of the &quot;/home/jana&quot; directory, and displays files matching the patterns given in the string &quot;Image Files (*.png *.jpg *.bmp)&quot;. The parent of the file dialog is set to</source>
          <target state="translated">위의 예에서 모달 QFileDialog는 정적 함수를 사용하여 생성됩니다. 대화 상자는 처음에 &quot;/ home / jana&quot;디렉토리의 내용을 표시하고 &quot;Image Files (* .png * .jpg * .bmp)&quot;문자열에 지정된 패턴과 일치하는 파일을 표시합니다. 파일 대화 상자의 상위는 다음으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="f78b1d34265001ff2f332358ede088f23c5d6826" translate="yes" xml:space="preserve">
          <source>In the above example, a modal file dialog is created and shown. If the user clicked OK, the file they selected is put in &lt;code&gt;fileName&lt;/code&gt;.</source>
          <target state="translated">위의 예에서 모달 파일 대화 상자가 작성되어 표시됩니다. 사용자가 확인을 클릭하면 선택한 파일이 &lt;code&gt;fileName&lt;/code&gt; 에 저장 됩니다.</target>
        </trans-unit>
        <trans-unit id="7389b1f6fcb0075b550d83cc787a3c13c282650e" translate="yes" xml:space="preserve">
          <source>In the above example, only the intermediate binding will be re-evaluated each time, resulting in a significant performance increase.</source>
          <target state="translated">위의 예에서는 매번 중간 바인딩 만 다시 평가되므로 성능이 크게 향상됩니다.</target>
        </trans-unit>
        <trans-unit id="4a8fae03a2b0cb2191c66f647b2733f1def1468b" translate="yes" xml:space="preserve">
          <source>In the above example, the &lt;a href=&quot;qml-qtquick-text&quot;&gt;Text&lt;/a&gt; object will have normal opacity, since the line opacity: 0.5 has been turned into a comment.</source>
          <target state="translated">위의 예제에서, &lt;a href=&quot;qml-qtquick-text&quot;&gt;텍스트&lt;/a&gt; 불투명도는 선 불투명도 : 0.5가 주석으로 바뀌었기 때문에 정상적인 불투명도를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="26fd98790deaa5f699734de43a63c6fbe8293d1d" translate="yes" xml:space="preserve">
          <source>In the above example, the associated NOTIFY signal for the &lt;code&gt;author&lt;/code&gt; property is &lt;code&gt;authorChanged&lt;/code&gt;, as specified in the &lt;a href=&quot;qobject#Q_PROPERTY&quot;&gt;Q_PROPERTY&lt;/a&gt;() macro call. This means that whenever the signal is emitted &amp;mdash; as it is when the author changes in Message::setAuthor() &amp;mdash; this notifies the QML engine that any bindings involving the &lt;code&gt;author&lt;/code&gt; property must be updated, and in turn, the engine will update the &lt;code&gt;text&lt;/code&gt; property by calling &lt;code&gt;Message::author()&lt;/code&gt; again.</source>
          <target state="translated">위의 예 에서 &lt;a href=&quot;qobject#Q_PROPERTY&quot;&gt;Q_PROPERTY&lt;/a&gt; () 매크로 호출에 지정된 것처럼 &lt;code&gt;author&lt;/code&gt; 속성에 대한 관련 NOTIFY 신호 는 &lt;code&gt;authorChanged&lt;/code&gt; 입니다. 즉, 작성자가 Message :: setAuthor ()를 변경할 때와 같이 신호가 발생할 때마다 &lt;code&gt;author&lt;/code&gt; 속성 과 관련된 모든 바인딩을 업데이트해야하고 엔진이 &lt;code&gt;text&lt;/code&gt; 를 업데이트 함을 QML 엔진에 알립니다. &lt;code&gt;Message::author()&lt;/code&gt; 다시 호출하여 속성 .</target>
        </trans-unit>
        <trans-unit id="52035459085e014010da31cbbf38d8144f6c306d" translate="yes" xml:space="preserve">
          <source>In the above example, the filter is set to &lt;code&gt;&quot;Images (*.png *.xpm *.jpg)&quot;&lt;/code&gt;, this means that only files with the extension &lt;code&gt;png&lt;/code&gt;, &lt;code&gt;xpm&lt;/code&gt;, or &lt;code&gt;jpg&lt;/code&gt; will be shown in the &lt;a href=&quot;qfiledialog&quot;&gt;QFileDialog&lt;/a&gt;. You can apply several filters by using &lt;a href=&quot;qfiledialog#setNameFilters&quot;&gt;setNameFilters&lt;/a&gt;(). Use &lt;a href=&quot;qfiledialog#selectNameFilter&quot;&gt;selectNameFilter&lt;/a&gt;() to select one of the filters you've given as the file dialog's default filter.</source>
          <target state="translated">상기 예에서, 필터로 설정 &lt;code&gt;&quot;Images (*.png *.xpm *.jpg)&quot;&lt;/code&gt; , 확장 파일 만이 수단 &lt;code&gt;png&lt;/code&gt; , &lt;code&gt;xpm&lt;/code&gt; 또는 &lt;code&gt;jpg&lt;/code&gt; 에 도시한다 &lt;a href=&quot;qfiledialog&quot;&gt;QFileDialog&lt;/a&gt; . &lt;a href=&quot;qfiledialog#setNameFilters&quot;&gt;setNameFilters&lt;/a&gt; () 를 사용하여 여러 필터를 적용 할 수 있습니다 . &lt;a href=&quot;qfiledialog#selectNameFilter&quot;&gt;selectNameFilter&lt;/a&gt; ()를 사용 하여 파일 대화 상자의 기본 필터로 제공 한 필터 중 하나를 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="2c260ca6f2ba9dc4897ca2ad41e51ef6d948db05" translate="yes" xml:space="preserve">
          <source>In the above example, the filter is set to &lt;code&gt;&quot;Images (*.png *.xpm *.jpg)&quot;&lt;/code&gt;, this means that only files with the extension &lt;code&gt;png&lt;/code&gt;, &lt;code&gt;xpm&lt;/code&gt;, or &lt;code&gt;jpg&lt;/code&gt; will be shown in the QFileDialog. You can apply several filters by using &lt;a href=&quot;qfiledialog#setNameFilters&quot;&gt;setNameFilters&lt;/a&gt;(). Use &lt;a href=&quot;qfiledialog#selectNameFilter&quot;&gt;selectNameFilter&lt;/a&gt;() to select one of the filters you've given as the file dialog's default filter.</source>
          <target state="translated">위의 예에서 필터는 &lt;code&gt;&quot;Images (*.png *.xpm *.jpg)&quot;&lt;/code&gt; 되어 있습니다. 이는 확장자가 &lt;code&gt;png&lt;/code&gt; , &lt;code&gt;xpm&lt;/code&gt; 또는 &lt;code&gt;jpg&lt;/code&gt; 인 파일 만 QFileDialog 에 표시됨을 의미합니다. &lt;a href=&quot;qfiledialog#setNameFilters&quot;&gt;setNameFilters&lt;/a&gt; () 를 사용하여 여러 필터를 적용 할 수 있습니다 . &lt;a href=&quot;qfiledialog#selectNameFilter&quot;&gt;selectNameFilter&lt;/a&gt; ()를 사용 하여 파일 대화 상자의 기본 필터로 지정한 필터 중 하나를 선택합니다.</target>
        </trans-unit>
        <trans-unit id="1cd88730ef838fc8d07abd4cb0faf90585717feb" translate="yes" xml:space="preserve">
          <source>In the above example, the input method allocates the word candidate list for its use.</source>
          <target state="translated">위의 예제에서 입력 방법은 단어 후보 목록을 사용하도록 할당합니다.</target>
        </trans-unit>
        <trans-unit id="e7955e5c64c92ff547f3d25a340bd97077f23556" translate="yes" xml:space="preserve">
          <source>In the above example, the key size is inherited from parent elements in this order:</source>
          <target state="translated">위의 예에서 키 크기는 다음 순서로 상위 요소에서 상속됩니다.</target>
        </trans-unit>
        <trans-unit id="ac1bec79b26271f29bc1213cc9adbd94afa09587" translate="yes" xml:space="preserve">
          <source>In the above example, the mode of the file dialog is set to &lt;a href=&quot;qfiledialog#FileMode-enum&quot;&gt;AnyFile&lt;/a&gt;, meaning that the user can select any file, or even specify a file that doesn't exist. This mode is useful for creating a &quot;Save As&quot; file dialog. Use &lt;a href=&quot;qfiledialog#FileMode-enum&quot;&gt;ExistingFile&lt;/a&gt; if the user must select an existing file, or &lt;a href=&quot;qfiledialog#FileMode-enum&quot;&gt;Directory&lt;/a&gt; if only a directory may be selected. See the &lt;a href=&quot;qfiledialog#FileMode-enum&quot;&gt;QFileDialog::FileMode&lt;/a&gt; enum for the complete list of modes.</source>
          <target state="translated">위의 예제에서 파일 대화 상자의 모드는 &lt;a href=&quot;qfiledialog#FileMode-enum&quot;&gt;AnyFile&lt;/a&gt; 로 설정되어 있습니다 . 즉, 사용자는 파일을 선택하거나 존재하지 않는 파일을 지정할 수 있습니다. 이 모드는 &quot;다른 이름으로 저장&quot;파일 대화 상자를 만드는 데 유용합니다. 사용자가 기존 파일을 선택해야하는 경우 &lt;a href=&quot;qfiledialog#FileMode-enum&quot;&gt;ExistingFile을&lt;/a&gt; 사용 하고 디렉토리 만 선택할 수있는 경우 &lt;a href=&quot;qfiledialog#FileMode-enum&quot;&gt;Directory를 사용&lt;/a&gt; 하십시오. 전체 모드 목록은 &lt;a href=&quot;qfiledialog#FileMode-enum&quot;&gt;QFileDialog :: FileMode&lt;/a&gt; 열거 형을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="05a2caab0c0536df310b455d81063c38cd4bc01e" translate="yes" xml:space="preserve">
          <source>In the above example, the red rectangle has a high z value, but is still stacked below the blue rectangle. This is because it is a child of the green rectangle, and the green rectangle is a sibling of the blue rectangle. The z value of the green rectangle is lower than that of the blue rectangle, so the green rectangle and all children will be stacked beneath the blue rectangle.</source>
          <target state="translated">위의 예에서 빨간색 사각형은 z 값이 높지만 여전히 파란색 사각형 아래에 쌓입니다. 녹색 사각형의 자식이고 녹색 사각형은 파란색 사각형의 형제이기 때문입니다. 녹색 사각형의 z 값이 파란색 사각형의 z 값보다 낮으므로 녹색 사각형과 모든 자식이 파란색 사각형 아래에 쌓입니다.</target>
        </trans-unit>
        <trans-unit id="480656f8f31f766a08f232700e80b063b2db8ab7" translate="yes" xml:space="preserve">
          <source>In the above example, we conceptually scale the SVG graphic to 1024x1024 first, and then cut out a region of interest that is 512x512 pixels from a location 100 pixels from the top and left edges. Thus &lt;code&gt;sourceSize&lt;/code&gt; determines the scale, but the actual output image is 512x512 pixels.</source>
          <target state="translated">위의 예에서는 개념적으로 먼저 SVG 그래픽을 1024x1024로 조정 한 다음 상단 및 왼쪽 가장자리에서 100 픽셀 떨어진 위치에서 512x512 픽셀 인 관심 영역을 잘라냅니다. 따라서 &lt;code&gt;sourceSize&lt;/code&gt; 는 배율을 결정하지만 실제 출력 이미지는 512x512 픽셀입니다.</target>
        </trans-unit>
        <trans-unit id="8440511dfdd68e429a1da7d100d7f5e5fd084b5e" translate="yes" xml:space="preserve">
          <source>In the above example, we neglected to mention how to handle selections of items. This subject is covered in more detail in the section about &lt;a href=&quot;#handling-selections-in-item-views&quot;&gt;Handling Selections in Item Views&lt;/a&gt;.</source>
          <target state="translated">위의 예에서는 항목 선택을 처리하는 방법에 대해서는 언급하지 않았습니다. 이 주제는 &lt;a href=&quot;#handling-selections-in-item-views&quot;&gt;항목보기에서 선택 처리&lt;/a&gt; 섹션에 자세히 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd2a0168bbb8b7584494cd4b55c1db29b01fcb56" translate="yes" xml:space="preserve">
          <source>In the above example, we neglected to mention how to handle selections of items. This subject is covered in more detail in the section about &lt;a href=&quot;model-view-programming#handling-selections-in-item-views&quot;&gt;Handling Selections in Item Views&lt;/a&gt;.</source>
          <target state="translated">위의 예에서는 항목 선택을 처리하는 방법을 언급하지 않았습니다. 이 주제는 &lt;a href=&quot;model-view-programming#handling-selections-in-item-views&quot;&gt;항목보기에서 선택 항목 처리&lt;/a&gt; 에 대한 섹션에서 자세히 다룹니다 .</target>
        </trans-unit>
        <trans-unit id="78c6c3c91133829773409779fa43cb0deacc4aa9" translate="yes" xml:space="preserve">
          <source>In the above examples, the &lt;code&gt;Console&lt;/code&gt; edition only includes the contents of four modules. Only the classes from these modules will be used when the &lt;a href=&quot;12-0-qdoc-commands-miscellaneous#generatelist-command&quot;&gt;generatelist&lt;/a&gt; command is used to generate a list of classes for this edition:</source>
          <target state="translated">위의 예에서 &lt;code&gt;Console&lt;/code&gt; 에디션에는 네 개의 모듈 내용 만 포함됩니다. &lt;a href=&quot;12-0-qdoc-commands-miscellaneous#generatelist-command&quot;&gt;generatelist&lt;/a&gt; 명령을 사용하여이 에디션의 클래스 목록을 생성 할 때이 모듈의 클래스 만 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="bf1b26c8502de9e92ebe525817b41cfcc7fb9699" translate="yes" xml:space="preserve">
          <source>In the above line, &lt;code&gt;USE_MY_STUFF&lt;/code&gt; will only be added to the list of pre-processor defines if it is not already defined. Note that the &lt;a href=&quot;qmake-function-reference#unique&quot;&gt;unique()&lt;/a&gt; function can also be used to ensure that a variable only contains one instance of each value.</source>
          <target state="translated">위의 행에서 &lt;code&gt;USE_MY_STUFF&lt;/code&gt; 는 아직 정의되지 않은 경우 전 처리기 정의 목록에만 추가됩니다. 점을 유의 &lt;a href=&quot;qmake-function-reference#unique&quot;&gt;고유 ()&lt;/a&gt; 함수는 변수가 각 값의 하나 개의 인스턴스를 포함하도록 사용될 수있다.</target>
        </trans-unit>
        <trans-unit id="91b2f7e3a7379d60e71e8a0ad9b4ca0f4baf86d9" translate="yes" xml:space="preserve">
          <source>In the above line, any values in the list that start with &lt;code&gt;QT_D&lt;/code&gt; or &lt;code&gt;QT_T&lt;/code&gt; are replaced with &lt;code&gt;QT&lt;/code&gt;.</source>
          <target state="translated">위의 행에서 &lt;code&gt;QT_D&lt;/code&gt; 또는 &lt;code&gt;QT_T&lt;/code&gt; 로 시작하는 목록의 값은 &lt;code&gt;QT&lt;/code&gt; 로 바뀝니다 .</target>
        </trans-unit>
        <trans-unit id="12e32dff5085b20cc64db7542e7c40356df3d9db" translate="yes" xml:space="preserve">
          <source>In the above lines, qmake knows what needs to be copied, and will handle the installation process automatically.</source>
          <target state="translated">위의 줄에서 qmake는 복사해야 할 것을 알고 설치 프로세스를 자동으로 처리합니다.</target>
        </trans-unit>
        <trans-unit id="35d1c4d14308bc4fdef8eec5b71409fc3d9adc9e" translate="yes" xml:space="preserve">
          <source>In the above sample the sound effect will be played when the &lt;a href=&quot;qml-qtquick-mousearea&quot;&gt;MouseArea&lt;/a&gt; is clicked.</source>
          <target state="translated">위 샘플에서 &lt;a href=&quot;qml-qtquick-mousearea&quot;&gt;MouseArea&lt;/a&gt; 를 클릭하면 사운드 효과가 재생됩니다 .</target>
        </trans-unit>
        <trans-unit id="08573c6b11eb5aa9f9479849a235a368e8127e62" translate="yes" xml:space="preserve">
          <source>In the above sample when the parent of &lt;a href=&quot;qml-qtquick-mousearea&quot;&gt;MouseArea&lt;/a&gt; is clicked, an area of 800x600 pixels with an id of 'video', the source &quot;video.avi&quot; will play in that area. Notice also that signals for the &lt;a href=&quot;qml-qtquick-keys&quot;&gt;Keys&lt;/a&gt; have been defined so that a spacebar will toggle the pause button; the left arrow will move the current position in the video to 5 seconds previously; and the right arrow will advance the current position in the video by 5 seconds.</source>
          <target state="translated">위의 샘플에서 &lt;a href=&quot;qml-qtquick-mousearea&quot;&gt;MouseArea&lt;/a&gt; 의 부모를 클릭하면 ID가 'video'인 800x600 픽셀의 영역 인 소스 &quot;video.avi&quot;가 해당 영역에서 재생됩니다. 스페이스 바가 일시 정지 버튼을 토글하도록 &lt;a href=&quot;qml-qtquick-keys&quot;&gt;키에&lt;/a&gt; 대한 신호 가 정의되었습니다. 왼쪽 화살표는 비디오의 현재 위치를 이전 5 초로 이동합니다. 오른쪽 화살표는 비디오의 현재 위치를 5 초 앞 당깁니다.</target>
        </trans-unit>
        <trans-unit id="d447248144f69b8bf3f953183e709a74a32b386f" translate="yes" xml:space="preserve">
          <source>In the above situations, it is still possible to design forms with the aim of using custom widgets in the application. To achieve this, we can use the widget promotion feature of</source>
          <target state="translated">위의 상황에서 응용 프로그램에서 사용자 정의 위젯을 사용하기 위해 양식을 디자인 할 수 있습니다. 이를 위해 위젯 프로모션 기능을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3331e798ca3ace3a215a35ec6c8dcd768c49a723" translate="yes" xml:space="preserve">
          <source>In the above snippet the cursor will still become visible when the &lt;a href=&quot;qml-qtquick-textinput&quot;&gt;TextInput&lt;/a&gt; gains active focus.</source>
          <target state="translated">위의 코드 조각에서 &lt;a href=&quot;qml-qtquick-textinput&quot;&gt;TextInput&lt;/a&gt; 이 활성 포커스를 가져 오면 커서가 계속 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="f4a373056767122ef26106979322c003bb04fcf6" translate="yes" xml:space="preserve">
          <source>In the above snippet, &lt;a href=&quot;qmetaobject#property&quot;&gt;QMetaObject::property&lt;/a&gt;() is used to get &lt;a href=&quot;qmetaproperty&quot;&gt;metadata&lt;/a&gt; about each property defined in some unknown class. The property name is fetched from the metadata and passed to &lt;a href=&quot;qobject#property&quot;&gt;QObject::property&lt;/a&gt;() to get the &lt;a href=&quot;qtcore-changes-qt6#qvariant&quot;&gt;value&lt;/a&gt; of the property in the current &lt;a href=&quot;qobject&quot;&gt;object&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="778d5c49efcd63b405579dd6f8e7514a08305900" translate="yes" xml:space="preserve">
          <source>In the above snippet, &lt;a href=&quot;qmetaobject#property&quot;&gt;QMetaObject::property&lt;/a&gt;() is used to get &lt;a href=&quot;qmetaproperty&quot;&gt;metadata&lt;/a&gt; about each property defined in some unknown class. The property name is fetched from the metadata and passed to &lt;a href=&quot;qobject#property&quot;&gt;QObject::property&lt;/a&gt;() to get the &lt;a href=&quot;qvariant&quot;&gt;value&lt;/a&gt; of the property in the current &lt;a href=&quot;qobject&quot;&gt;object&lt;/a&gt;.</source>
          <target state="translated">위의 스 니펫에서 &lt;a href=&quot;qmetaobject#property&quot;&gt;QMetaObject :: property&lt;/a&gt; ()는 알 수없는 클래스에 정의 된 각 속성에 대한 &lt;a href=&quot;qmetaproperty&quot;&gt;메타 데이터&lt;/a&gt; 를 가져 오는 데 사용됩니다 . 속성 이름은 메타 데이터에서 가져와 &lt;a href=&quot;qobject#property&quot;&gt;QObject :: property&lt;/a&gt; ()로 전달되어 현재 &lt;a href=&quot;qobject&quot;&gt;객체&lt;/a&gt; 의 속성 &lt;a href=&quot;qvariant&quot;&gt;값&lt;/a&gt; 을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="e12ff91a301a5754bfc26c58b618a6895b33b177" translate="yes" xml:space="preserve">
          <source>In the above style rule, &lt;code&gt;QPushButton&lt;/code&gt; is the selector and &lt;code&gt;{ color: red }&lt;/code&gt; is the declaration. The rule specifies that &lt;a href=&quot;qpushbutton&quot;&gt;QPushButton&lt;/a&gt; and its subclasses (e.g., &lt;code&gt;MyPushButton&lt;/code&gt;) should use red as their foreground color.</source>
          <target state="translated">위의 스타일 규칙에서 &lt;code&gt;QPushButton&lt;/code&gt; 은 선택기이고 &lt;code&gt;{ color: red }&lt;/code&gt; 는 선언입니다. 이 규칙은 &lt;a href=&quot;qpushbutton&quot;&gt;QPushButton&lt;/a&gt; 및 해당 서브 클래스 (예 : &lt;code&gt;MyPushButton&lt;/code&gt; )가 전경색으로 빨간색을 사용하도록 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="b5491dea569a48c821c5d3cc5fa871d9841d9b0b" translate="yes" xml:space="preserve">
          <source>In the active state as soon as camera is started the viewfinder displays video frames and the camera is ready for capture.</source>
          <target state="translated">카메라가 시작 되 자마자 활성 상태에서 뷰 파인더는 비디오 프레임을 표시하고 카메라는 캡처 준비가되었습니다.</target>
        </trans-unit>
        <trans-unit id="4105802f7fa87d449178ae4278075b284b6abb9b" translate="yes" xml:space="preserve">
          <source>In the active state the viewfinder frames are available and the camera is ready for capture.</source>
          <target state="translated">활성 상태에서는 뷰 파인더 프레임을 사용할 수 있으며 카메라를 캡처 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="98f3ab4e1391da0c7cbc31b26b2019df50318e14" translate="yes" xml:space="preserve">
          <source>In the active state, the viewfinder frames are available and the camera is ready for capture.</source>
          <target state="translated">활성 상태에서 뷰 파인더 프레임을 사용할 수 있고 카메라를 캡처 할 준비가됩니다.</target>
        </trans-unit>
        <trans-unit id="6fe43ce054c52dd0645bc2d81f31513eb5520e68" translate="yes" xml:space="preserve">
          <source>In the animation below, the first checkbox is tri-state:</source>
          <target state="translated">아래 애니메이션에서 첫 번째 확인란은 3 상태입니다.</target>
        </trans-unit>
        <trans-unit id="a06074144e41dec3d566205f517c989ed933d003" translate="yes" xml:space="preserve">
          <source>In the animation below, the first checkdelegate is tri-state:</source>
          <target state="translated">아래 애니메이션에서 첫 번째 체크 델리게이트는 tri-state입니다.</target>
        </trans-unit>
        <trans-unit id="1ce44d5844cf9c7d884181be6345d42674e7ab6a" translate="yes" xml:space="preserve">
          <source>In the application's &lt;a href=&quot;qml-qtquick-virtualkeyboard-inputpanel&quot;&gt;InputPanel&lt;/a&gt;, add the following code:</source>
          <target state="translated">응용 프로그램의 &lt;a href=&quot;qml-qtquick-virtualkeyboard-inputpanel&quot;&gt;InputPanel&lt;/a&gt; 에서 다음 코드를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="11529092a568d2ebed4559cd5b0c3132a36a0dba" translate="yes" xml:space="preserve">
          <source>In the application, resource paths can be used in most places instead of ordinary file system paths. In particular, you can pass a resource path instead of a file name to the &lt;a href=&quot;qicon&quot;&gt;QIcon&lt;/a&gt;, &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt;, or &lt;a href=&quot;qpixmap&quot;&gt;QPixmap&lt;/a&gt; constructor:</source>
          <target state="translated">응용 프로그램에서 자원 경로는 일반 파일 시스템 경로 대신 대부분의 장소에서 사용될 수 있습니다. 특히 파일 이름 대신 리소스 경로를 &lt;a href=&quot;qicon&quot;&gt;QIcon&lt;/a&gt; , &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt; 또는 &lt;a href=&quot;qpixmap&quot;&gt;QPixmap&lt;/a&gt; 생성자에 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="093794bd305ddfae860139dd84bba3a916168ac6" translate="yes" xml:space="preserve">
          <source>In the application, this resource would be registered with code like this:</source>
          <target state="translated">응용 프로그램에서이 리소스는 다음과 같은 코드로 등록됩니다.</target>
        </trans-unit>
        <trans-unit id="5aa9db2337634be8f880cb78c2fffea3cd290535" translate="yes" xml:space="preserve">
          <source>In the base class this is a pure virtual function.</source>
          <target state="translated">기본 클래스에서 이것은 순수한 가상 함수입니다.</target>
        </trans-unit>
        <trans-unit id="f7cd5a68e95a94289db1ac56a4a3d86a14733425" translate="yes" xml:space="preserve">
          <source>In the below sections we will present a toolchain file that can be used in many cases, with minimal customization. It is based on the approach presented in &lt;a href=&quot;https://www.qt.io/blog/standalone-boot2qt-/-yocto-sdk-cmake-toolchain&quot;&gt;this blog post&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5103749357b6394f7985e837d39c213852f1028" translate="yes" xml:space="preserve">
          <source>In the branch delegate you have access to the following special properties:</source>
          <target state="translated">지점 대리인에서는 다음과 같은 특수 속성에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="52854a801e231867b5e93209f75904f0423e5d7b" translate="yes" xml:space="preserve">
          <source>In the case of &lt;b&gt;Tab&lt;/b&gt;, &lt;b&gt;Backtab&lt;/b&gt;, &lt;b&gt;Enter&lt;/b&gt; and &lt;b&gt;Return&lt;/b&gt; key press events, the</source>
          <target state="translated">의 경우 &lt;b&gt;탭&lt;/b&gt; , &lt;b&gt;뒤로 탭&lt;/b&gt; , &lt;b&gt;입력&lt;/b&gt; 하고 &lt;b&gt;리턴&lt;/b&gt; 키를 눌러 이벤트의를</target>
        </trans-unit>
        <trans-unit id="0780880e8284aeee383317793fd94a1ca17307f9" translate="yes" xml:space="preserve">
          <source>In the case of &lt;code&gt;fn:doc()&lt;/code&gt;, the absolute URI is the base URI in the static context (which most likely is the location of the query). Rather than use the URI the user specified, the return value of &lt;a href=&quot;qabstracturiresolver#resolve&quot;&gt;QAbstractUriResolver::resolve&lt;/a&gt;() will be used.</source>
          <target state="translated">의 경우 &lt;code&gt;fn:doc()&lt;/code&gt; , 절대 URI는 (거의 확실하게 쿼리의 위치) 정적 콘텍스트 내의베이스 URI이다. 사용자가 지정한 URI를 사용하는 대신 &lt;a href=&quot;qabstracturiresolver#resolve&quot;&gt;QAbstractUriResolver :: resolve&lt;/a&gt; () 의 반환 값 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="476df6664814d3170809cfc84a7a9d225a742f8a" translate="yes" xml:space="preserve">
          <source>In the case of a checkable &lt;a href=&quot;qgroupbox&quot;&gt;QGroupBox&lt;/a&gt;, the title includes the check indicator. The indicator is styled using the &lt;a href=&quot;#indicator-sub&quot;&gt;::indicator&lt;/a&gt; subcontrol. The &lt;a href=&quot;#spacing-prop&quot;&gt;spacing&lt;/a&gt; property can be used to control the spacing between the text and indicator.</source>
          <target state="translated">확인 가능한 &lt;a href=&quot;qgroupbox&quot;&gt;QGroupBox&lt;/a&gt; 의 경우 제목에 확인 표시기가 포함됩니다. 표시기는 &lt;a href=&quot;#indicator-sub&quot;&gt;:: indicator&lt;/a&gt; 하위 제어를 사용하여 스타일이 지정됩니다 . &lt;a href=&quot;#spacing-prop&quot;&gt;간격&lt;/a&gt; 속성은 텍스트와 지표 사이의 간격을 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc6403ce8320f0badfc0d3ff944bd06c2869984f" translate="yes" xml:space="preserve">
          <source>In the case of a checkable &lt;a href=&quot;qgroupbox&quot;&gt;QGroupBox&lt;/a&gt;, the title includes the check indicator. The indicator is styled using the &lt;a href=&quot;stylesheet-reference#indicator-sub&quot;&gt;::indicator&lt;/a&gt; subcontrol. The &lt;a href=&quot;stylesheet-reference#spacing-prop&quot;&gt;spacing&lt;/a&gt; property can be used to control the spacing between the text and indicator.</source>
          <target state="translated">확인 가능한 &lt;a href=&quot;qgroupbox&quot;&gt;QGroupBox&lt;/a&gt; 의 경우 제목에 확인 표시기가 포함됩니다. 표시기는 &lt;a href=&quot;stylesheet-reference#indicator-sub&quot;&gt;:: indicator&lt;/a&gt; 하위 제어를 사용하여 스타일이 지정됩니다 . &lt;a href=&quot;stylesheet-reference#spacing-prop&quot;&gt;간격&lt;/a&gt; 속성은 텍스트와 지표 사이의 간격을 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c841a239b1f23504d92454f01a42039f4003cb72" translate="yes" xml:space="preserve">
          <source>In the case of an error, a &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtscript-index.html&quot;&gt;Qt Script&lt;/a&gt; Error object is thrown. This object has an additional property, &lt;code&gt;qmlErrors&lt;/code&gt;, which is an array of the errors encountered. Each object in this array has the members &lt;code&gt;lineNumber&lt;/code&gt;, &lt;code&gt;columnNumber&lt;/code&gt;, &lt;code&gt;fileName&lt;/code&gt; and &lt;code&gt;message&lt;/code&gt;. For example, if the above snippet had misspelled color as 'colro' then the array would contain an object like the following: { &quot;lineNumber&quot; : 1, &quot;columnNumber&quot; : 32, &quot;fileName&quot; : &quot;dynamicSnippet1&quot;, &quot;message&quot; : &quot;Cannot assign to non-existent property &quot;colro&quot;&quot;}.</source>
          <target state="translated">오류가 발생 하면 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtscript-index.html&quot;&gt;Qt Script&lt;/a&gt; Error 객체가 발생합니다. 이 객체에는 발생한 오류의 배열 인 추가 속성 &lt;code&gt;qmlErrors&lt;/code&gt; 가 있습니다. 이 배열의 각 객체에는 &lt;code&gt;lineNumber&lt;/code&gt; , &lt;code&gt;columnNumber&lt;/code&gt; , &lt;code&gt;fileName&lt;/code&gt; 및 &lt;code&gt;message&lt;/code&gt; 멤버 가 있습니다. 예를 들어, 위의 스 니펫에 'colro'로 색상 철자가 틀린 경우 배열에는 다음과 같은 객체가 포함됩니다. { &quot;lineNumber&quot;: 1, &quot;columnNumber&quot;: 32, &quot;fileName&quot;: &quot;dynamicSnippet1&quot;, &quot;message&quot;: &quot;존재하지 않는 속성&quot;colro &quot;에 할당 할 수 없습니다&quot;}.</target>
        </trans-unit>
        <trans-unit id="1f41c8b939c4a62952483b3e29fe7b69d9d43cba" translate="yes" xml:space="preserve">
          <source>In the case of an error, a &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtscript-index.html&quot;&gt;Qt Script&lt;/a&gt; Error object is thrown. This object has an additional property, &lt;code&gt;qmlErrors&lt;/code&gt;, which is an array of the errors encountered. Each object in this array has the members &lt;code&gt;lineNumber&lt;/code&gt;, &lt;code&gt;columnNumber&lt;/code&gt;, &lt;code&gt;fileName&lt;/code&gt; and &lt;code&gt;message&lt;/code&gt;. For example, if the above snippet had misspelled color as 'colro' then the array would contain an object like the following: { &quot;lineNumber&quot; : 1, &quot;columnNumber&quot; : 32, &quot;fileName&quot; : &quot;dynamicSnippet1&quot;, &quot;message&quot; : &quot;Cannot assign to non-existent property &quot;colro&quot;&quot;}.</source>
          <target state="translated">오류가 발생 하면 &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtscript-index.html&quot;&gt;Qt Script&lt;/a&gt; Error 객체가 발생합니다. 이 객체에는 발생한 오류의 배열 인 추가 속성 &lt;code&gt;qmlErrors&lt;/code&gt; 가 있습니다. 이 배열의 각 객체에는 &lt;code&gt;lineNumber&lt;/code&gt; , &lt;code&gt;columnNumber&lt;/code&gt; , &lt;code&gt;fileName&lt;/code&gt; 및 &lt;code&gt;message&lt;/code&gt; 멤버 가 있습니다. 예를 들어, 위의 스 니펫에 'colro'로 색상 철자가 틀린 경우 배열에는 다음과 같은 객체가 포함됩니다. { &quot;lineNumber&quot;: 1, &quot;columnNumber&quot;: 32, &quot;fileName&quot;: &quot;dynamicSnippet1&quot;, &quot;message&quot;: &quot;존재하지 않는 속성&quot;colro &quot;에 할당 할 수 없습니다&quot;}.</target>
        </trans-unit>
        <trans-unit id="37e65a36db5f9e7ce2b957d78aaa84d6ff90e336" translate="yes" xml:space="preserve">
          <source>In the case of an error, a &lt;a href=&quot;qqmlerror&quot;&gt;QQmlError&lt;/a&gt; object is thrown. This object has an additional property, &lt;code&gt;qmlErrors&lt;/code&gt;, which is an array of the errors encountered. Each object in this array has the members &lt;code&gt;lineNumber&lt;/code&gt;, &lt;code&gt;columnNumber&lt;/code&gt;, &lt;code&gt;fileName&lt;/code&gt; and &lt;code&gt;message&lt;/code&gt;. For example, if the above snippet had misspelled color as 'colro' then the array would contain an object like the following: { &quot;lineNumber&quot; : 1, &quot;columnNumber&quot; : 32, &quot;fileName&quot; : &quot;dynamicSnippet1&quot;, &quot;message&quot; : &quot;Cannot assign to non-existent property &quot;colro&quot;&quot;}.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0824274244abdbd52bff471c964c47cedfe5858d" translate="yes" xml:space="preserve">
          <source>In the case of comparing floats and doubles, &lt;a href=&quot;#qFuzzyCompare&quot;&gt;qFuzzyCompare&lt;/a&gt;() is used for comparing. This means that comparing to 0 will likely fail. One solution to this is to compare to 1, and add 1 to the produced output.</source>
          <target state="translated">float와 double을 비교하는 경우 &lt;a href=&quot;#qFuzzyCompare&quot;&gt;qFuzzyCompare&lt;/a&gt; ()를 사용하여 비교합니다. 이것은 0과의 비교가 실패 할 가능성이 있음을 의미합니다. 이에 대한 한 가지 해결책은 1과 비교하고 생성 된 출력에 1을 더하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="8bc6b3262f626e98377a151d42e98ada92bdb9aa" translate="yes" xml:space="preserve">
          <source>In the case of queries of type &lt;a href=&quot;qnetworkproxyquery#QueryType-enum&quot;&gt;QNetworkProxyQuery::UrlRequest&lt;/a&gt;, this function returns the value of the scheme component of the URL.</source>
          <target state="translated">&lt;a href=&quot;qnetworkproxyquery#QueryType-enum&quot;&gt;QNetworkProxyQuery :: UrlRequest&lt;/a&gt; 유형의 쿼리의 경우이 함수는 URL의 스키마 구성 요소 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="180620aebe5082c9a9db3b49a73f0451d604fbee" translate="yes" xml:space="preserve">
          <source>In the case of the default OpenGL adaptation the context of this window will be bound when this function is called. The only exception is if the native OpenGL has been destroyed outside Qt's control, for instance through EGL_CONTEXT_LOST.</source>
          <target state="translated">기본 OpenGL 적응의 경우이 함수가 호출 될 때이 창의 컨텍스트가 바인딩됩니다. 유일한 예외는 기본 OpenGL이 예를 들어 EGL_CONTEXT_LOST를 통해 Qt의 제어 외부에서 파괴 된 경우입니다.</target>
        </trans-unit>
        <trans-unit id="302b4a1de7fc10868e07089fb5eb6a54d9241902" translate="yes" xml:space="preserve">
          <source>In the case the string corresponds to a valid file path on the system, a file:// URL is constructed, using &lt;a href=&quot;qurl#fromLocalFile&quot;&gt;QUrl::fromLocalFile&lt;/a&gt;().</source>
          <target state="translated">문자열이 시스템의 유효한 파일 경로에 해당하는 경우 &lt;a href=&quot;qurl#fromLocalFile&quot;&gt;QUrl :: fromLocalFile&lt;/a&gt; ()을 사용하여 file : // URL이 생성 됩니다.</target>
        </trans-unit>
        <trans-unit id="b8917b869fce1b4f2373fc587ff1159fcd5aaaf0" translate="yes" xml:space="preserve">
          <source>In the case where a file contains multiple animations, it is possible to select which animation should be loaded by way of query parameters on the source url. The accepted query parameters are animationIndex and animationName. If both are specified, animationName is ignored.</source>
          <target state="translated">파일에 여러 애니메이션이 포함 된 경우 소스 URL의 쿼리 매개 변수를 통해로드 할 애니메이션을 선택할 수 있습니다. 허용되는 쿼리 매개 변수는 animationIndex 및 animationName입니다. 둘 다 지정하면 animationName이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="9970ca9194b59467b4465baf132eacc1ea8cd7a7" translate="yes" xml:space="preserve">
          <source>In the case where an icon can only possibly have one image URL, the parameter key of &lt;code&gt;&quot;singleUrl&quot;&lt;/code&gt; can be used with a &lt;a href=&quot;qurl&quot;&gt;QUrl&lt;/a&gt; value. Any Icon with this parameter will always return the specified URL regardless of the requested icon size and not defer to any Plugin.</source>
          <target state="translated">아이콘이 하나의 이미지 URL 만 가질 수있는 경우 &lt;code&gt;&quot;singleUrl&quot;&lt;/code&gt; 의 매개 변수 키를 &lt;a href=&quot;qurl&quot;&gt;QUrl&lt;/a&gt; 값 과 함께 사용할 수 있습니다 . 이 매개 변수가있는 모든 아이콘은 요청 된 아이콘 크기에 관계없이 항상 지정된 URL을 반환하며 플러그인을 따르지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b6dafd1675255377501babc739c62dd031c0b87c" translate="yes" xml:space="preserve">
          <source>In the class constructor you add the interfaces to your custom widgets to the list which you return in the &lt;a href=&quot;qdesignercustomwidgetcollectioninterface#customWidgets&quot;&gt;customWidgets&lt;/a&gt;() function:</source>
          <target state="translated">클래스 생성자에서 &lt;a href=&quot;qdesignercustomwidgetcollectioninterface#customWidgets&quot;&gt;customWidgets&lt;/a&gt; () 함수 에서 반환하는 목록에 사용자 정의 위젯에 대한 인터페이스를 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="2f985c4af31f9b16cab55135f47c6d6e919b4114" translate="yes" xml:space="preserve">
          <source>In the clipboard model, the user can</source>
          <target state="translated">클립 보드 모델에서 사용자는</target>
        </trans-unit>
        <trans-unit id="cbba5f50ddea3356e28a3b0772fb4d3dfe4616af" translate="yes" xml:space="preserve">
          <source>In the code snippets so far, we used the unary &lt;code&gt;*&lt;/code&gt; operator to retrieve the item (of type &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;) stored at a certain iterator position, and we then called &lt;a href=&quot;qstring#toLower&quot;&gt;QString::toLower&lt;/a&gt;() on it. Most C++ compilers also allow us to write &lt;code&gt;i-&amp;gt;toLower()&lt;/code&gt;, but some don't.</source>
          <target state="translated">지금까지 코드 스 니펫에서 우리는 단항 &lt;code&gt;*&lt;/code&gt; 연산자를 사용하여 특정 반복기 위치에 저장된 항목 ( &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; 유형 ) 을 검색 한 다음 &lt;a href=&quot;qstring#toLower&quot;&gt;QString :: toLower&lt;/a&gt; () 를 호출 했습니다. 대부분의 C ++ 컴파일러는 &lt;code&gt;i-&amp;gt;toLower()&lt;/code&gt; 를 작성할 수도 있지만 일부는 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="124e39d73adbb34143a94895eae6f328439ba3eb" translate="yes" xml:space="preserve">
          <source>In the common case of interleaved linear PCM data, the codec will be &quot;audio/pcm&quot;, and the samples for all channels will be interleaved. One sample for each channel for the same instant in time is referred to as a frame in Qt Multimedia (and other places).</source>
          <target state="translated">인터리브 된 선형 PCM 데이터의 일반적인 경우 코덱은 &quot;audio / pcm&quot;이고 모든 채널의 샘플은 인터리브됩니다. 동일한 순간에 대한 각 채널에 대한 하나의 샘플을 Qt Multimedia (및 기타 장소)의 프레임이라고합니다.</target>
        </trans-unit>
        <trans-unit id="8a4d1bdb49c84c11153ae631579c2138e30d7956" translate="yes" xml:space="preserve">
          <source>In the common case of simply using a &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt; as the source of texture pixel data most of the above steps are performed automatically.</source>
          <target state="translated">단순히 &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt; 를 텍스처 픽셀 데이터의 소스로 사용하는 일반적인 경우에는 대부분의 위 단계가 자동으로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="8da8e3805b741a984ea93a66a1272a507e49e1ef" translate="yes" xml:space="preserve">
          <source>In the common case, it is useful to call the &lt;a href=&quot;qtglobal#qDebugx&quot;&gt;qDebug&lt;/a&gt;() function to obtain a default &lt;a href=&quot;qdebug&quot;&gt;QDebug&lt;/a&gt; object to use for writing debugging information.</source>
          <target state="translated">일반적인 경우, 디버깅 정보를 작성하는 데 사용할 기본 &lt;a href=&quot;qdebug&quot;&gt;QDebug&lt;/a&gt; 객체를 얻기 위해 &lt;a href=&quot;qtglobal#qDebugx&quot;&gt;qDebug&lt;/a&gt; () 함수를 호출하는 것이 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="479d43eb5e8df23ffbbea2419251a42341ff82ab" translate="yes" xml:space="preserve">
          <source>In the common case, it is useful to call the &lt;a href=&quot;qtglobal#qDebugx&quot;&gt;qDebug&lt;/a&gt;() function to obtain a default QDebug object to use for writing debugging information.</source>
          <target state="translated">일반적인 경우, 디버깅 정보를 작성하는 데 사용할 기본 QDebug 객체를 얻기 위해 &lt;a href=&quot;qtglobal#qDebugx&quot;&gt;qDebug&lt;/a&gt; () 함수를 호출하는 것이 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="b17c300f21b0e795728fffc213f58fce115ab850" translate="yes" xml:space="preserve">
          <source>In the cookies are equal, the client is considered to be real, and the server can continue with a TLS handshake procedure.</source>
          <target state="translated">쿠키가 같음에서 클라이언트는 실제로 간주되며 서버는 TLS 핸드 셰이크 절차를 계속할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b036303f55d614ffcf9a344777119a33d88c19ae" translate="yes" xml:space="preserve">
          <source>In the course of this section, we will look at the style elements, the style options, and the functions of &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt;. Finally, we describe how the palette is used.</source>
          <target state="translated">이 섹션의 과정에서 스타일 요소, ​​스타일 옵션 및 &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt; 의 기능을 살펴 보겠습니다 . 마지막으로 팔레트 사용 방법을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="8c9da98054ac779e0d109342bf29b26e8998dac9" translate="yes" xml:space="preserve">
          <source>In the current implementation the Qt XML classes follow the definition that the prefix</source>
          <target state="translated">현재 구현에서 Qt XML 클래스는 접두사가</target>
        </trans-unit>
        <trans-unit id="0a2e7cc57f6d075df2486f0ea3fdf26afb4ee0e3" translate="yes" xml:space="preserve">
          <source>In the default &lt;a href=&quot;qpagelayout#Mode-enum&quot;&gt;StandardMode&lt;/a&gt; the current margins and minimum margins are always taken into account. The paintable rectangle is the full page rectangle less the current margins, and the current margins can only be set to values between the minimum margins and the maximum margins allowed by the full page size.</source>
          <target state="translated">기본 &lt;a href=&quot;qpagelayout#Mode-enum&quot;&gt;표준 모드&lt;/a&gt; 에서는 현재 여백과 최소 여백이 항상 고려됩니다. 페인트 가능한 사각형은 전체 페이지 사각형에서 현재 여백을 뺀 것이며 현재 여백은 전체 페이지 크기에서 허용하는 최소 여백과 최대 여백 사이의 값으로 만 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0af4f12a2438da5389e981b2a43981e2330d13c2" translate="yes" xml:space="preserve">
          <source>In the default implementation, supportsGeocoding() and supportsReverseGeocoding() returns false while &lt;a href=&quot;qgeocodingmanagerengine#geocode&quot;&gt;geocode&lt;/a&gt;() and &lt;a href=&quot;qgeocodingmanagerengine#reverseGeocode&quot;&gt;reverseGeocode&lt;/a&gt;() cause &lt;a href=&quot;qgeocodereply#Error-enum&quot;&gt;QGeoCodeReply::UnsupportedOptionError&lt;/a&gt; to occur.</source>
          <target state="translated">기본 구현에서 supportsGeocoding () 및 supportsReverseGeocoding ()은 false를 반환하는 반면 &lt;a href=&quot;qgeocodingmanagerengine#geocode&quot;&gt;지오 코드&lt;/a&gt; () 및 &lt;a href=&quot;qgeocodingmanagerengine#reverseGeocode&quot;&gt;reverseGeocode&lt;/a&gt; ()는 &lt;a href=&quot;qgeocodereply#Error-enum&quot;&gt;QGeoCodeReply :: UnsupportedOptionError&lt;/a&gt; 를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="2bd8170ef8a59ecadee40ae365f975fcf7870a37" translate="yes" xml:space="preserve">
          <source>In the default implementation, supportsRouteUpdates() returns false and &lt;a href=&quot;qgeoroutingmanagerengine#updateRoute&quot;&gt;updateRoute&lt;/a&gt;() returns a &lt;a href=&quot;qgeoroutereply&quot;&gt;QGeoRouteReply&lt;/a&gt; object containing a &lt;a href=&quot;qgeoroutereply#Error-enum&quot;&gt;QGeoRouteReply::UnsupportedOptionError&lt;/a&gt;.</source>
          <target state="translated">기본 구현에서, supportsRouteUpdates는 ()가 false를 반환합니다 &lt;a href=&quot;qgeoroutingmanagerengine#updateRoute&quot;&gt;updateRoute가&lt;/a&gt; ) (A 반환 &lt;a href=&quot;qgeoroutereply&quot;&gt;QGeoRouteReply의&lt;/a&gt; 포함하는 객체 &lt;a href=&quot;qgeoroutereply#Error-enum&quot;&gt;QGeoRouteReply :: UnsupportedOptionError을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5b97b88d857abd592cc5a47911673c45f447de45" translate="yes" xml:space="preserve">
          <source>In the default implementation, the search is reset if</source>
          <target state="translated">기본 구현에서 검색은 다음과 같은 경우 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="0478285b5fc700b8ba538808a471d5f384467f73" translate="yes" xml:space="preserve">
          <source>In the default implementation, the text either contains a percentage value that indicates the progress so far, or it is blank because the progress bar is in the reset state.</source>
          <target state="translated">기본 구현에서 텍스트는 지금까지의 진행률을 나타내는 백분율 값을 포함하거나 진행률 표시 줄이 재설정 상태이므로 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6798e6ffde70f7209f8a6967c59bde077018721" translate="yes" xml:space="preserve">
          <source>In the default mode, &lt;a href=&quot;qsensor#AxesOrientationMode-enum&quot;&gt;QSensor::FixedOrientation&lt;/a&gt;, the reading values remain unaffected by the orientation. In the &lt;a href=&quot;qsensor#AxesOrientationMode-enum&quot;&gt;QSensor::AutomaticOrientation&lt;/a&gt; mode, the reading values are automatically rotated by taking the current screen orientation into account. And finally, in the &lt;a href=&quot;qsensor#AxesOrientationMode-enum&quot;&gt;QSensor::UserOrientation&lt;/a&gt; mode, the reading values are rotated according to a user-specified orientation.</source>
          <target state="translated">기본 모드 인 &lt;a href=&quot;qsensor#AxesOrientationMode-enum&quot;&gt;QSensor :: FixedOrientation&lt;/a&gt; 에서 판독 값은 방향의 영향을받지 않습니다. 에서 &lt;a href=&quot;qsensor#AxesOrientationMode-enum&quot;&gt;QSensor :: AutomaticOrientation의&lt;/a&gt; 모드, 읽기 값이 자동으로 계정에 현재 화면 방향을 복용에 의해 회전된다. 마지막으로 &lt;a href=&quot;qsensor#AxesOrientationMode-enum&quot;&gt;QSensor :: UserOrientation&lt;/a&gt; 모드에서 판독 값은 사용자가 지정한 방향에 따라 회전합니다.</target>
        </trans-unit>
        <trans-unit id="ad6929bbae910ceee52ca84922a13b3920781577" translate="yes" xml:space="preserve">
          <source>In the delegate you have access to the following special properties:</source>
          <target state="translated">위임에서 다음과 같은 특수 속성에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b2534f4f89a188c5999ea508d895176982cc0b73" translate="yes" xml:space="preserve">
          <source>In the dialog's constructor we set up the widgets as before, and connect the &lt;b&gt;Cancel&lt;/b&gt; button's &lt;a href=&quot;qabstractbutton#clicked&quot;&gt;clicked()&lt;/a&gt; signal to the dialog's reject() slot. We also disable the &lt;a href=&quot;qpushbutton#autoDefault-prop&quot;&gt;autoDefault&lt;/a&gt; property in both buttons to ensure that the dialog does not interfere with the way that the line edit handles return key events:</source>
          <target state="translated">대화 상자의 생성자에서 이전과 같이 위젯을 설정하고 &lt;b&gt;취소&lt;/b&gt; 버튼의 &lt;a href=&quot;qabstractbutton#clicked&quot;&gt;clicked ()&lt;/a&gt; 신호를 대화 상자의 reject () 슬롯에 연결합니다. 또한 대화 상자가 라인 편집이 리턴 키 이벤트를 처리하는 방식을 방해하지 않도록 두 버튼 모두 에서 &lt;a href=&quot;qpushbutton#autoDefault-prop&quot;&gt;autoDefault&lt;/a&gt; 속성을 비활성화 합니다.</target>
        </trans-unit>
        <trans-unit id="82c71c0d4f75f98f48b8d5cd419f95c14a047975" translate="yes" xml:space="preserve">
          <source>In the drop down list, select &lt;b&gt;Triangulate&lt;/b&gt;.</source>
          <target state="translated">드롭 다운 목록에서 &lt;b&gt;삼각 측량을&lt;/b&gt; 선택 합니다.</target>
        </trans-unit>
        <trans-unit id="08bf3c71618a2603cedc205b0af171f24a51a82b" translate="yes" xml:space="preserve">
          <source>In the end we must remember to make &lt;code&gt;main()&lt;/code&gt; pass the control to Qt. &lt;a href=&quot;qcoreapplication#exec&quot;&gt;QCoreApplication::exec&lt;/a&gt;() will return when the application exits...</source>
          <target state="translated">결국 우리는 &lt;code&gt;main()&lt;/code&gt; 이 Qt에 컨트롤을 넘겨 주도록하는 것을 기억해야합니다 . &lt;a href=&quot;qcoreapplication#exec&quot;&gt;QCoreApplication :: exec&lt;/a&gt; ()는 응용 프로그램이 종료되면 반환됩니다 ...</target>
        </trans-unit>
        <trans-unit id="58420c6de2ba679e27caab480527f70881be2502" translate="yes" xml:space="preserve">
          <source>In the event that you are running a local loop which calls this function continuously, without an event loop, the &lt;a href=&quot;qevent#Type-enum&quot;&gt;DeferredDelete&lt;/a&gt; events will not be processed. This can affect the behaviour of widgets, e.g. &lt;a href=&quot;qtooltip&quot;&gt;QToolTip&lt;/a&gt;, that rely on &lt;a href=&quot;qevent#Type-enum&quot;&gt;DeferredDelete&lt;/a&gt; events to function properly. An alternative would be to call &lt;a href=&quot;qcoreapplication#sendPostedEvents&quot;&gt;sendPostedEvents()&lt;/a&gt; from within that local loop.</source>
          <target state="translated">이벤트 루프없이이 함수를 계속 호출하는 로컬 루프를 실행하는 경우 &lt;a href=&quot;qevent#Type-enum&quot;&gt;DeferredDelete&lt;/a&gt; 이벤트가 처리되지 않습니다. 이는 &lt;a href=&quot;qevent#Type-enum&quot;&gt;DeferredDelete&lt;/a&gt; 이벤트에 의존하여 올바르게 작동하는 위젯 (예 : &lt;a href=&quot;qtooltip&quot;&gt;QToolTip)&lt;/a&gt; 의 동작에 영향을 줄 수 있습니다 . 대안은 해당 로컬 루프 내에서 &lt;a href=&quot;qcoreapplication#sendPostedEvents&quot;&gt;sendPostedEvents ()&lt;/a&gt; 를 호출하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="3ddf9748fa9fb248455e59b7f0f5621900cafef1" translate="yes" xml:space="preserve">
          <source>In the example &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt; above, the second and third steps are both axis steps. Both apply the &lt;code&gt;element(name)&lt;/code&gt; node test to nodes encountered while traversing along some axis. But in this example, the two axis steps are written in a &lt;a href=&quot;xquery-introduction#shorthand-form&quot;&gt;shorthand form&lt;/a&gt;, where the axis specifier and the node test are not written explicitly but are implied. XQueries are normally written in this shorthand form, but they can also be written in the longhand form. If we rewrite the &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt; in the longhand form, it looks like this:</source>
          <target state="translated">위의 &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt; 예제 에서 두 번째 및 세 번째 단계는 모두 축 단계입니다. 둘 다 &lt;code&gt;element(name)&lt;/code&gt; 노드 테스트를 일부 축을 따라 이동하는 동안 발견 된 노드에 적용합니다 . 그러나이 예에서 두 축 단계는 축 지정자 및 노드 테스트가 명시 적으로 작성되지 않고 암시 된 &lt;a href=&quot;xquery-introduction#shorthand-form&quot;&gt;축약 형식&lt;/a&gt; 으로 작성됩니다. XQueries는 일반적으로이 속기 형식으로 작성되지만 긴 형식으로 작성 될 수도 있습니다. &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt; 를 긴 형식으로 다시 작성하면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="72cdfe261c710f3bc0661c21f511997cedee110e" translate="yes" xml:space="preserve">
          <source>In the example &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt; above, the second and third steps are both axis steps. Both apply the &lt;code&gt;element(name)&lt;/code&gt; node test to nodes encountered while traversing along some axis. But in this example, the two axis steps are written in a &lt;a href=&quot;#shorthand-form&quot;&gt;shorthand form&lt;/a&gt;, where the axis specifier and the node test are not written explicitly but are implied. XQueries are normally written in this shorthand form, but they can also be written in the longhand form. If we rewrite the &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt; in the longhand form, it looks like this:</source>
          <target state="translated">위의 &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt; 예제 에서 두 번째 및 세 번째 단계는 모두 축 단계입니다. 둘 다 &lt;code&gt;element(name)&lt;/code&gt; 노드 테스트를 일부 축을 따라 이동하는 동안 발견 된 노드에 적용합니다 . 그러나이 예에서 두 축 단계는 축 지정자 및 노드 테스트가 명시 적으로 작성되지 않고 암시 된 &lt;a href=&quot;#shorthand-form&quot;&gt;축약 형식&lt;/a&gt; 으로 작성됩니다. XQueries는 일반적으로이 속기 형식으로 작성되지만 긴 형식으로 작성 될 수도 있습니다. &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt; 를 긴 형식으로 다시 작성하면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1540e0ba5a23ab6ecdac5ae38326c96fae2b3570" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;a href=&quot;qvarlengtharray&quot;&gt;QVarLengthArray&lt;/a&gt; will preallocate 1024 elements on the stack and use them unless &lt;code&gt;n + 1&lt;/code&gt; is greater than 1024. If you omit the second template argument, &lt;a href=&quot;qvarlengtharray&quot;&gt;QVarLengthArray&lt;/a&gt;'s default of 256 is used.</source>
          <target state="translated">위의 예에서 &lt;a href=&quot;qvarlengtharray&quot;&gt;QVarLengthArray&lt;/a&gt; 는 스택에 1024 개의 요소를 미리 할당하고 &lt;code&gt;n + 1&lt;/code&gt; 이 1024보다 크지 않으면이를 사용합니다. 두 번째 템플릿 인수를 생략하면 &lt;a href=&quot;qvarlengtharray&quot;&gt;QVarLengthArray&lt;/a&gt; 의 기본값 인 256이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="aba7caa3cf341198fe242e78d0bd2c61020d4ba4" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;b&gt;Alt+U&lt;/b&gt; moves the keyboard focus to the group box. See the &lt;a href=&quot;qshortcut#mnemonic&quot;&gt;QShortcut&lt;/a&gt; documentation for details (to display an actual ampersand, use '&amp;amp;&amp;amp;').</source>
          <target state="translated">위의 예에서 &lt;b&gt;Alt + U&lt;/b&gt; 는 키보드 포커스를 그룹 상자로 이동합니다. 자세한 내용은 &lt;a href=&quot;qshortcut#mnemonic&quot;&gt;QShortcut&lt;/a&gt; 문서를 참조하십시오 (실제 앰퍼샌드를 표시하려면 '&amp;amp;&amp;amp;'사용).</target>
        </trans-unit>
        <trans-unit id="c5c177374468ed6ec2a7627bc2bfbadc8a7cc42c" translate="yes" xml:space="preserve">
          <source>In the example above, QVarLengthArray will preallocate 1024 elements on the stack and use them unless &lt;code&gt;n + 1&lt;/code&gt; is greater than 1024. If you omit the second template argument, QVarLengthArray's default of 256 is used.</source>
          <target state="translated">위의 예에서 QVarLengthArray는 스택에 1024 개의 요소를 미리 할당하고 &lt;code&gt;n + 1&lt;/code&gt; 이 1024보다 크지 않으면이를 사용합니다. 두 번째 템플릿 인수를 생략하면 QVarLengthArray의 기본값 인 256이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5a29e3743977f058b9b27432244e6b5e6ae14312" translate="yes" xml:space="preserve">
          <source>In the example above, an expected fail will be written into the test output if the variable &lt;code&gt;i&lt;/code&gt; is not 42. If the variable &lt;code&gt;i&lt;/code&gt; is 42, an unexpected pass is written instead. The QEXPECT_FAIL() has no influence on the second &lt;a href=&quot;qtest#QCOMPARE&quot;&gt;QCOMPARE&lt;/a&gt;() statement in the example.</source>
          <target state="translated">위의 예에서 변수 &lt;code&gt;i&lt;/code&gt; 가 42가 아니면 예상 실패가 테스트 출력 에 기록됩니다. 변수 &lt;code&gt;i&lt;/code&gt; 가 42이면 예상치 못한 통과가 대신 기록됩니다. QEXPECT_FAIL ()은 예제에서 두 번째 &lt;a href=&quot;qtest#QCOMPARE&quot;&gt;QCOMPARE&lt;/a&gt; () 문에 영향을주지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="ec77cc8baea6451f3b9f84d6cf09cc3bcc9f4dce" translate="yes" xml:space="preserve">
          <source>In the example above, the template specialization for the clone() function calls the</source>
          <target state="translated">위의 예에서 clone () 함수에 대한 템플릿 전문화는</target>
        </trans-unit>
        <trans-unit id="ec9bdbb3a3c66b35fb808b0997f8cc411d66fe9d" translate="yes" xml:space="preserve">
          <source>In the example above, we first set the current block state to 0. Then, if the previous block ended within a comment, we highlight from the beginning of the current block (&lt;code&gt;startIndex = 0&lt;/code&gt;). Otherwise, we search for the given start expression. If the specified end expression cannot be found in the text block, we change the current block state by calling &lt;a href=&quot;qsyntaxhighlighter#setCurrentBlockState&quot;&gt;setCurrentBlockState&lt;/a&gt;(), and make sure that the rest of the block is highlighted.</source>
          <target state="translated">위의 예에서 먼저 현재 블록 상태를 0으로 설정합니다. 그런 다음 이전 블록이 주석 내에서 종료되면 현재 블록의 시작 부분부터 강조 표시합니다 ( &lt;code&gt;startIndex = 0&lt;/code&gt; ). 그렇지 않으면 주어진 시작 표현식을 검색합니다. 지정된 끝 표현식을 텍스트 블록에서 찾을 수없는 경우 &lt;a href=&quot;qsyntaxhighlighter#setCurrentBlockState&quot;&gt;setCurrentBlockState&lt;/a&gt; () 를 호출하여 현재 블록 상태를 변경 하고 나머지 블록이 강조 표시되었는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="d7d55174bb91d92336e0eb3339b393cc4ebbfbb0" translate="yes" xml:space="preserve">
          <source>In the example above, we set a context property on the root context to expose the C++ object to QML. This means that the property is available to every component loaded by the engine. Context properties are useful for objects that must be available as soon as the QML is loaded and cannot be instantiated in QML.</source>
          <target state="translated">위의 예에서는 루트 컨텍스트에 컨텍스트 속성을 설정하여 C ++ 객체를 QML에 노출합니다. 이는 엔진에 의해로드 된 모든 구성 요소에서 속성을 사용할 수 있음을 의미합니다. 컨텍스트 속성은 QML이로드되는 즉시 사용할 수 있어야하고 QML에서 인스턴스화 할 수없는 객체에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="c97c3d6b593559336f77d8a689881d7bab00fc1a" translate="yes" xml:space="preserve">
          <source>In the example above, we've relied on Qt's global &lt;a href=&quot;qhash#qhash&quot;&gt;qHash&lt;/a&gt;(const &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; &amp;amp;, uint) to give us a hash value for the employee's name, and XOR'ed this with the day they were born to help produce unique hashes for people with the same name.</source>
          <target state="translated">위의 예에서 우리는 Qt의 글로벌 &lt;a href=&quot;qhash#qhash&quot;&gt;qHash&lt;/a&gt; (const &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; &amp;amp;, uint)를 사용하여 직원 이름에 대한 해시 값을 제공했으며, XOR은 다음을 가진 사람들을 위해 고유 한 해시를 생성하는 데 도움이되도록 태어난 날에 이것을 XOR했습니다. 같은 이름.</target>
        </trans-unit>
        <trans-unit id="2aaa6d773c67d90aa07fa3feda293306b8b6dd45" translate="yes" xml:space="preserve">
          <source>In the example above, we've relied on Qt's own implementation of &lt;a href=&quot;qhash#qHashx&quot;&gt;qHash&lt;/a&gt;() for &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; and &lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt; to give us a hash value for the employee's name and date of birth respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dc7adeac1b277e34300fd5d178489f2de0df0e3" translate="yes" xml:space="preserve">
          <source>In the example below, custom &lt;a href=&quot;qml-qtquick-controls2-rangeslider#from-prop&quot;&gt;from&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-controls2-rangeslider#to-prop&quot;&gt;to&lt;/a&gt; values are set, and the initial positions of the &lt;a href=&quot;qml-qtquick-controls2-rangeslider#first-prop&quot;&gt;first&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-controls2-rangeslider#second-prop&quot;&gt;second&lt;/a&gt; handles are set:</source>
          <target state="translated">아래의 예에서, 사용자 &lt;a href=&quot;qml-qtquick-controls2-rangeslider#from-prop&quot;&gt;로부터의&lt;/a&gt; 및 &lt;a href=&quot;qml-qtquick-controls2-rangeslider#to-prop&quot;&gt;에&lt;/a&gt; 값을 설정하고, 초기 위치의 &lt;a href=&quot;qml-qtquick-controls2-rangeslider#first-prop&quot;&gt;첫번째&lt;/a&gt; 및 &lt;a href=&quot;qml-qtquick-controls2-rangeslider#second-prop&quot;&gt;두번째&lt;/a&gt; 핸들이 설정된다 :</target>
        </trans-unit>
        <trans-unit id="901772f1ce46e7dc0d3342b5491786e828a59716" translate="yes" xml:space="preserve">
          <source>In the example below, custom &lt;a href=&quot;qml-qtquick-controls2-slider#from-prop&quot;&gt;from&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-controls2-slider#value-prop&quot;&gt;value&lt;/a&gt;, and &lt;a href=&quot;qml-qtquick-controls2-slider#to-prop&quot;&gt;to&lt;/a&gt; values are set:</source>
          <target state="translated">아래 예에서 사용자 정의 &lt;a href=&quot;qml-qtquick-controls2-slider#from-prop&quot;&gt;from&lt;/a&gt; , &lt;a href=&quot;qml-qtquick-controls2-slider#value-prop&quot;&gt;value&lt;/a&gt; 및 &lt;a href=&quot;qml-qtquick-controls2-slider#to-prop&quot;&gt;to&lt;/a&gt; 값이 설정되었습니다.</target>
        </trans-unit>
        <trans-unit id="a5739a38d2823101c1d59a80724de1929c397f87" translate="yes" xml:space="preserve">
          <source>In the example below, we decrease the height of the tickmarks:</source>
          <target state="translated">아래 예에서는 눈금의 높이를 줄입니다.</target>
        </trans-unit>
        <trans-unit id="0de9861b09f5f9e5be6874d4c2a2189a0b482e52" translate="yes" xml:space="preserve">
          <source>In the example below, we decrease the width of the minor tickmarks:</source>
          <target state="translated">아래 예에서는 보조 눈금의 너비를 줄입니다.</target>
        </trans-unit>
        <trans-unit id="090d1a166df46385d8f217eaa03d77850b67b346" translate="yes" xml:space="preserve">
          <source>In the example output, several values have been set using default values obtained from the QDoc configuration file. See &lt;a href=&quot;21-3-qt-dita-xml-output#&quot;&gt;Generating DITA XML Output&lt;/a&gt; for details.</source>
          <target state="translated">예제 출력에서는 QDoc 구성 파일에서 가져온 기본값을 사용하여 여러 값이 설정되었습니다. 자세한 내용은 &lt;a href=&quot;21-3-qt-dita-xml-output#&quot;&gt;DITA XML 출력 생성&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9b6c383bdd9c7199a5ac185ee9a8e4187a4a3dca" translate="yes" xml:space="preserve">
          <source>In the example shown above, two views of the same type were used to display the same model's data. However, if two different types of view were used, the selected items may be represented very differently in each view; for example, a contiguous selection in a table view can be represented as a fragmented set of highlighted items in a tree view.</source>
          <target state="translated">위에 표시된 예에서는 동일한 유형의 두보기를 사용하여 동일한 모델의 데이터를 표시했습니다. 그러나 두 가지 유형의보기가 사용 된 경우 선택한 항목이 각보기에서 매우 다르게 표시 될 수 있습니다. 예를 들어, 테이블보기의 연속 선택은 트리보기에서 강조 표시된 항목의 조각화 된 세트로 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d0f623a8e91b09e473d555a9d32f4433e146d31b" translate="yes" xml:space="preserve">
          <source>In the example we are going to use a Raspberry Pi 4 SDK (toolchain+sysroot) generated via Yocto, but the instructions here are completely generic, with no dependency on Yocto. The steps are the same with any other toolchain and sysroot, once the toolchain file is updated with the correct cross compiler and other paths.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22b5a17f90422db2a83ff1da975aaf10a658ac71" translate="yes" xml:space="preserve">
          <source>In the example, QDoc didn't need a</source>
          <target state="translated">이 예에서 QDoc은</target>
        </trans-unit>
        <trans-unit id="2d4c74b90ed7327c871e7c9db2b832ce09857c20" translate="yes" xml:space="preserve">
          <source>In the example, for the US we would leave the translation of &quot;AMPM&quot; as it is and thereby use the 12-hour clock branch; but in Europe we would translate it as something else to make the code use the 24-hour clock branch.</source>
          <target state="translated">예에서 미국의 경우 &quot;AMPM&quot;의 번역을 그대로두고 12 시간 시계 분기를 사용합니다. 그러나 유럽에서는 코드가 24 시간 시계 분기를 사용하도록하기 위해 다른 것으로 번역합니다.</target>
        </trans-unit>
        <trans-unit id="2082b270ec671febf3797e8598da895ab18ed2d9" translate="yes" xml:space="preserve">
          <source>In the example, qdoc didn't need a</source>
          <target state="translated">이 예에서 qdoc에는</target>
        </trans-unit>
        <trans-unit id="23bccdaa8a9c34d06b49ce3a473c4efab01cafc8" translate="yes" xml:space="preserve">
          <source>In the example, the enumeration type that is the property type is declared in MyClass and registered with the &lt;a href=&quot;metaobjects&quot;&gt;Meta-Object System&lt;/a&gt; using the &lt;a href=&quot;qobject#Q_ENUM&quot;&gt;Q_ENUM&lt;/a&gt;() macro. This makes the enumeration values available as strings for use as in the call to &lt;a href=&quot;qobject#setProperty&quot;&gt;setProperty()&lt;/a&gt;. Had the enumeration type been declared in another class, its fully qualified name (i.e., OtherClass::Priority) would be required, and that other class would also have to inherit &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; and register the enumeration type there using the &lt;a href=&quot;qobject#Q_ENUM&quot;&gt;Q_ENUM&lt;/a&gt;() macro.</source>
          <target state="translated">예제에서는 속성 형인 열거 형을 MyClass에 선언 하고 &lt;a href=&quot;qobject#Q_ENUM&quot;&gt;Q_ENUM&lt;/a&gt; () 매크로를 이용하여 &lt;a href=&quot;metaobjects&quot;&gt;Meta-Object System에&lt;/a&gt; 등록한다 . 이렇게하면 &lt;a href=&quot;qobject#setProperty&quot;&gt;setProperty ()를&lt;/a&gt; 호출 할 때처럼 열거 형 값을 문자열로 사용할 수 있습니다 . 열거 형이 다른 클래스에서 선언 된 경우에는 정규화 된 이름 (예 : OtherClass :: Priority)이 필요하며 다른 클래스도 &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 를 상속 하고 &lt;a href=&quot;qobject#Q_ENUM&quot;&gt;Q_ENUM&lt;/a&gt; () 매크로를 사용하여 열거 형을 등록해야합니다 .</target>
        </trans-unit>
        <trans-unit id="96ac981619b2e22ed5047ee2df0edf2a33aff18b" translate="yes" xml:space="preserve">
          <source>In the example, the enumeration type that is the property type is declared in MyClass and registered with the &lt;a href=&quot;metaobjects#&quot;&gt;Meta-Object System&lt;/a&gt; using the &lt;a href=&quot;qobject#Q_ENUM&quot;&gt;Q_ENUM&lt;/a&gt;() macro. This makes the enumeration values available as strings for use as in the call to &lt;a href=&quot;qobject#setProperty&quot;&gt;setProperty()&lt;/a&gt;. Had the enumeration type been declared in another class, its fully qualified name (i.e., OtherClass::Priority) would be required, and that other class would also have to inherit &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; and register the enumeration type there using the &lt;a href=&quot;qobject#Q_ENUM&quot;&gt;Q_ENUM&lt;/a&gt;() macro.</source>
          <target state="translated">예제에서는 속성 형인 열거 형을 MyClass에 선언 하고 &lt;a href=&quot;qobject#Q_ENUM&quot;&gt;Q_ENUM&lt;/a&gt; () 매크로를 이용하여 &lt;a href=&quot;metaobjects#&quot;&gt;Meta-Object System에&lt;/a&gt; 등록한다 . 이렇게하면 &lt;a href=&quot;qobject#setProperty&quot;&gt;setProperty ()를&lt;/a&gt; 호출 할 때처럼 열거 형 값을 문자열로 사용할 수 있습니다 . 열거 형이 다른 클래스에서 선언 된 경우에는 정규화 된 이름 (예 : OtherClass :: Priority)이 필요하며 다른 클래스도 &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 를 상속 하고 &lt;a href=&quot;qobject#Q_ENUM&quot;&gt;Q_ENUM&lt;/a&gt; () 매크로를 사용하여 열거 형을 등록해야합니다 .</target>
        </trans-unit>
        <trans-unit id="871e54560c81446ae41e8e37228eeb0158495db1" translate="yes" xml:space="preserve">
          <source>In the example, we start by comparing the employees' names. If they're equal, we compare their dates of birth to break the tie.</source>
          <target state="translated">이 예에서는 직원의 이름을 비교하는 것으로 시작합니다. 같으면 생년월일을 비교하여 동점을 끊습니다.</target>
        </trans-unit>
        <trans-unit id="2439ff4140aeb1647e04fd550853ab6492c67be3" translate="yes" xml:space="preserve">
          <source>In the first line in snippet above, a file URL is constructed from a local, relative path. A file URL with a relative path only makes sense if there is a base URL to resolve it against. For example:</source>
          <target state="translated">위의 스 니펫의 첫 번째 줄에서 파일 URL은 로컬 상대 경로에서 구성됩니다. 상대 경로가있는 파일 URL은이를 해결할 기본 URL이있는 경우에만 의미가 있습니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="3ee8fb560994f8b7d0e722e67bce2dd4772d32aa" translate="yes" xml:space="preserve">
          <source>In the following animation, three &lt;a href=&quot;qml-qtquick-controls2-label&quot;&gt;Label&lt;/a&gt; controls are pushed onto a stack view with the &lt;a href=&quot;qml-qtquick-controls2-stackview#push-method&quot;&gt;push()&lt;/a&gt; function:</source>
          <target state="translated">다음 애니메이션에서는 &lt;a href=&quot;qml-qtquick-controls2-stackview#push-method&quot;&gt;push ()&lt;/a&gt; 함수를 사용하여 3 개의 &lt;a href=&quot;qml-qtquick-controls2-label&quot;&gt;Label&lt;/a&gt; 컨트롤이 스택 뷰에 푸시 됩니다.</target>
        </trans-unit>
        <trans-unit id="f96e261c4933f8bc1a17cd985490c34b14f89ec1" translate="yes" xml:space="preserve">
          <source>In the following animation, we &lt;a href=&quot;qml-qtquick-controls2-stackview#replace-method&quot;&gt;replace&lt;/a&gt; the topmost item with &lt;code&gt;D&lt;/code&gt;:</source>
          <target state="translated">다음 애니메이션에서, 우리는 &lt;a href=&quot;qml-qtquick-controls2-stackview#replace-method&quot;&gt;대체&lt;/a&gt; 와 맨 위의 항목 &lt;code&gt;D&lt;/code&gt; 를 :</target>
        </trans-unit>
        <trans-unit id="111f6d9c712f2c81a8b4aeeaa01bfbe30557a196" translate="yes" xml:space="preserve">
          <source>In the following animation, we unwind the stack to the first item by calling &lt;code&gt;pop(null)&lt;/code&gt;:</source>
          <target state="translated">다음 애니메이션에서 &lt;code&gt;pop(null)&lt;/code&gt; 을 호출하여 스택을 첫 번째 항목으로 해제합니다 .</target>
        </trans-unit>
        <trans-unit id="9fa72b336529fd5b4a41073264aba34f6f0d897b" translate="yes" xml:space="preserve">
          <source>In the following code snippet, the &lt;code&gt;not front&lt;/code&gt; text is an id to differentiate this &quot;Back&quot; text from the backstepping &quot;Back&quot; text:</source>
          <target state="translated">다음 코드 스 니펫에서 &lt;code&gt;not front&lt;/code&gt; 이 아닌 텍스트는이 &quot;뒤로&quot;텍스트를 백스텝 &quot;뒤로&quot;텍스트와 구별하기위한 ID입니다.</target>
        </trans-unit>
        <trans-unit id="b757eb68596d90025f293b4adcdf944d51a2a5c5" translate="yes" xml:space="preserve">
          <source>In the following code snippet, the text on the &lt;code&gt;//:&lt;/code&gt; line is the main comment for the translator.</source>
          <target state="translated">다음 코드 스 니펫에서 &lt;code&gt;//:&lt;/code&gt; 행 의 텍스트 는 번역사에 대한 기본 주석입니다.</target>
        </trans-unit>
        <trans-unit id="f04c01f4e036fa31cb18e1431e24927d2351e913" translate="yes" xml:space="preserve">
          <source>In the following code snippet, we create two &lt;code&gt;Counter&lt;/code&gt; objects and connect the first object's &lt;code&gt;valueChanged()&lt;/code&gt; signal to the second object's &lt;code&gt;setValue()&lt;/code&gt; slot using &lt;a href=&quot;qobject#connect&quot;&gt;QObject::connect&lt;/a&gt;():</source>
          <target state="translated">다음 코드 스 니펫에서는 두 개의 &lt;code&gt;Counter&lt;/code&gt; 객체를 만들고 &lt;a href=&quot;qobject#connect&quot;&gt;QObject :: connect&lt;/a&gt; ()를 사용하여 첫 번째 객체의 &lt;code&gt;valueChanged()&lt;/code&gt; 신호를 두 번째 객체의 &lt;code&gt;setValue()&lt;/code&gt; 슬롯에 연결합니다 .</target>
        </trans-unit>
        <trans-unit id="622414a8cf4fe591df097a16a7643cd447aabede" translate="yes" xml:space="preserve">
          <source>In the following code, the text supplied in the event is passed to a &lt;a href=&quot;qtextbrowser&quot;&gt;QTextBrowser&lt;/a&gt; and a &lt;a href=&quot;qcombobox&quot;&gt;QComboBox&lt;/a&gt; is filled with the list of MIME types that are used to describe the data:</source>
          <target state="translated">다음 코드, 이벤트에 제공된 텍스트는에 전달 &lt;a href=&quot;qtextbrowser&quot;&gt;QTextBrowser&lt;/a&gt; 및 &lt;a href=&quot;qcombobox&quot;&gt;QComboBox는&lt;/a&gt; 데이터를 설명하는 데 사용되는 MIME 타입의리스트로 채워진다 :</target>
        </trans-unit>
        <trans-unit id="be429f577f9c2139d1960bc0d57d38abce60ba31" translate="yes" xml:space="preserve">
          <source>In the following code, the text supplied in the event is passed to a &lt;a href=&quot;qtextbrowser&quot;&gt;QTextBrowser&lt;/a&gt; and a &lt;a href=&quot;widgets-changes-qt6#qcombobox&quot;&gt;QComboBox&lt;/a&gt; is filled with the list of MIME types that are used to describe the data:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61c53712c1afd7973830d6f8bfc31e688b36ad36" translate="yes" xml:space="preserve">
          <source>In the following code, we provide a slot that receives the &lt;a href=&quot;qitemselectionmodel#currentChanged&quot;&gt;currentChanged()&lt;/a&gt; signal, and uses the information provided to update the status bar of a &lt;a href=&quot;qmainwindow&quot;&gt;QMainWindow&lt;/a&gt;:</source>
          <target state="translated">다음 코드에서는 &lt;a href=&quot;qitemselectionmodel#currentChanged&quot;&gt;currentChanged ()&lt;/a&gt; 신호 를 수신하는 슬롯을 제공하고 제공된 정보를 사용하여 &lt;a href=&quot;qmainwindow&quot;&gt;QMainWindow&lt;/a&gt; 의 상태 표시 줄을 업데이트합니다 .</target>
        </trans-unit>
        <trans-unit id="8c2b035c6b28162fbba78ca6c3317891d2e87bbe" translate="yes" xml:space="preserve">
          <source>In the following code, we provide a slot that receives the &lt;a href=&quot;qitemselectionmodel#selectionChanged&quot;&gt;selectionChanged()&lt;/a&gt; signal, fills in the selected items with a string, and clears the contents of the deselected items.</source>
          <target state="translated">다음 코드에서는 &lt;a href=&quot;qitemselectionmodel#selectionChanged&quot;&gt;selectionChanged ()&lt;/a&gt; 신호 를 수신 하고 선택한 항목을 문자열로 채우고 선택 해제 된 항목의 내용을 지우는 슬롯을 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="6cf9cf0e5068f95ce7e06ded2831757552ec865a" translate="yes" xml:space="preserve">
          <source>In the following example a C++ method in</source>
          <target state="translated">다음 예제에서 C ++ 메서드는</target>
        </trans-unit>
        <trans-unit id="4d02ddec645db505d3eeebeeee290af798ebf119" translate="yes" xml:space="preserve">
          <source>In the following example a default &lt;a href=&quot;qml-qtlocation-routequery&quot;&gt;RouteQuery&lt;/a&gt; is declared within &lt;a href=&quot;qml-qtlocation-routemodel&quot;&gt;RouteModel&lt;/a&gt;.</source>
          <target state="translated">다음 예제에서 기본 &lt;a href=&quot;qml-qtlocation-routequery&quot;&gt;RouteQuery&lt;/a&gt; 는 &lt;a href=&quot;qml-qtlocation-routemodel&quot;&gt;RouteModel&lt;/a&gt; 내에서 선언됩니다 .</target>
        </trans-unit>
        <trans-unit id="4da163d57149813e89ffa98f14de916b00f75660" translate="yes" xml:space="preserve">
          <source>In the following example both continuations will run in a new thread (but in the same one).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae4de3b3b05758ef20d101a54f004d4086d000e7" translate="yes" xml:space="preserve">
          <source>In the following example both continuations will run in new threads using the same thread pool.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f33f02aaa6910c3a74694a37c79f2598ee20b84" translate="yes" xml:space="preserve">
          <source>In the following example the line join style changes automatically based on the value of joinStyleIndex:</source>
          <target state="translated">다음 예제에서 선 결합 스타일은 joinStyleIndex 값에 따라 자동으로 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="67c5696202e36e70eaaadaa8cd25a2e81bdf9faf" translate="yes" xml:space="preserve">
          <source>In the following example we change the top and bottom anchors of an item using &lt;a href=&quot;qml-qtquick-anchorchanges&quot;&gt;AnchorChanges&lt;/a&gt;, and the top and bottom anchor margins using &lt;a href=&quot;qml-qtquick-propertychanges&quot;&gt;PropertyChanges&lt;/a&gt;:</source>
          <target state="translated">다음 예제에서는 &lt;a href=&quot;qml-qtquick-anchorchanges&quot;&gt;AnchorChanges를&lt;/a&gt; 사용하여 항목의 상단 및 하단 앵커를 변경하고 &lt;a href=&quot;qml-qtquick-propertychanges&quot;&gt;PropertyChanges를&lt;/a&gt; 사용하여 상단 및 하단 앵커 여백을 변경합니다 .</target>
        </trans-unit>
        <trans-unit id="aa7fa50ed60568451f8e6f286366848ba1f74169" translate="yes" xml:space="preserve">
          <source>In the following example we change the top and bottom anchors of an item using AnchorChanges, and the top and bottom anchor margins using &lt;a href=&quot;qml-qtquick-propertychanges&quot;&gt;PropertyChanges&lt;/a&gt;:</source>
          <target state="translated">다음 예제에서는 AnchorChanges를 사용하여 항목의 상단 및 하단 앵커를 변경하고 &lt;a href=&quot;qml-qtquick-propertychanges&quot;&gt;PropertyChanges를&lt;/a&gt; 사용하여 상단 및 하단 앵커 여백을 변경합니다 .</target>
        </trans-unit>
        <trans-unit id="f56fa458d5b1f88eb4269cd4d72db1416e61f851" translate="yes" xml:space="preserve">
          <source>In the following example we have a Path made up of three PathLines. Normally, the items of the &lt;a href=&quot;qml-qtquick-pathview&quot;&gt;PathView&lt;/a&gt; would be laid out equally along this path, with an equal number of items per line segment. &lt;a href=&quot;qml-qtquick-pathpercent&quot;&gt;PathPercent&lt;/a&gt; allows us to specify that the first and third lines should each hold 10% of the laid out items, while the second line should hold the remaining 80%.</source>
          <target state="translated">다음 예제에는 세 개의 PathLine으로 구성된 Path가 있습니다. 일반적으로 &lt;a href=&quot;qml-qtquick-pathview&quot;&gt;PathView&lt;/a&gt; 의 항목은 이 경로를 따라 동일하게 배치되며 선 분당 항목 수는 동일합니다. &lt;a href=&quot;qml-qtquick-pathpercent&quot;&gt;PathPercent를&lt;/a&gt; 사용하면 첫 번째와 세 번째 줄이 각각 레이아웃 항목의 10 %를 유지하고 두 번째 줄은 나머지 80 %를 유지하도록 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a885bd6f57711148c7e8669240ed3c5ae6de2749" translate="yes" xml:space="preserve">
          <source>In the following example we match strings containing 'mail' or 'letter' or 'correspondence' but only match whole words i.e. not 'email'</source>
          <target state="translated">다음 예에서는 'mail', 'letter'또는 'corespondence'를 포함하는 문자열과 일치하지만 'email'이 아닌 전체 단어 만 일치합니다.</target>
        </trans-unit>
        <trans-unit id="f76ca5184fc13ae062befac58afa357bfb179a95" translate="yes" xml:space="preserve">
          <source>In the following example we use &lt;a href=&quot;qml-qtquick-rotationanimation&quot;&gt;RotationAnimation&lt;/a&gt; to animate the rotation between states via the shortest path:</source>
          <target state="translated">다음 예제에서는 &lt;a href=&quot;qml-qtquick-rotationanimation&quot;&gt;RotationAnimation&lt;/a&gt; 을 사용하여 최단 경로를 통해 상태 간 회전 에 애니메이션을 적용합니다.</target>
        </trans-unit>
        <trans-unit id="e6288836c7adceaf47dc63b39d0159627821da0d" translate="yes" xml:space="preserve">
          <source>In the following example we use RotationAnimation to animate the rotation between states via the shortest path:</source>
          <target state="translated">다음 예제에서는 RotationAnimation을 사용하여 최단 경로를 통해 상태 간 회전에 애니메이션을 적용합니다.</target>
        </trans-unit>
        <trans-unit id="41c909003b7e0631788266c02806d165f54fcc92" translate="yes" xml:space="preserve">
          <source>In the following example, &lt;a href=&quot;qml-qtquick-controls2-swipedelegate&quot;&gt;SwipeDelegate&lt;/a&gt; is used in a &lt;a href=&quot;qml-qtquick-listview&quot;&gt;ListView&lt;/a&gt; to allow items to be removed from it by swiping to the left:</source>
          <target state="translated">다음 예제에서는 &lt;a href=&quot;qml-qtquick-controls2-swipedelegate&quot;&gt;SwipeDelegate&lt;/a&gt; 가 &lt;a href=&quot;qml-qtquick-listview&quot;&gt;ListView&lt;/a&gt; 에서 사용되어 왼쪽으로 스 와이프하여 항목을 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="beb2ca750883ba0f209500d0bde04ade441db658" translate="yes" xml:space="preserve">
          <source>In the following example, &lt;code&gt;comp1&lt;/code&gt; is created within the root context of MyItem.qml, and any objects instantiated from this component will have access to the ids and properties within that context, such as &lt;code&gt;internalSettings.color&lt;/code&gt;. When &lt;code&gt;comp1&lt;/code&gt; is used as a &lt;a href=&quot;qml-qtquick-listview&quot;&gt;ListView&lt;/a&gt; delegate in another context (as in main.qml below), it will continue to have access to the properties of its creation context (which would otherwise be private to external users).</source>
          <target state="translated">다음 예제에서 &lt;code&gt;comp1&lt;/code&gt; 은 MyItem.qml의 루트 컨텍스트 내에서 생성되고이 구성 요소에서 인스턴스화 된 모든 개체는 해당 컨텍스트 내의 id 및 속성 (예 : &lt;code&gt;internalSettings.color&lt;/code&gt; )에 액세스 할 수 있습니다 . 때 &lt;code&gt;comp1&lt;/code&gt; A와 사용 &lt;a href=&quot;qml-qtquick-listview&quot;&gt;의 ListView&lt;/a&gt; (아래 main.qml 같이) 다른 맥락에서 위임, 그것은 (그렇지 않으면 외부 사용자 개인 것)의 생성 컨텍스트의 속성에 계속 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f5b697e314fcc8c0c2a77f8d2cea534fbcdd860b" translate="yes" xml:space="preserve">
          <source>In the following example, &lt;code&gt;input&lt;/code&gt; will be given active focus when &lt;code&gt;scope&lt;/code&gt; gains active focus:</source>
          <target state="translated">다음 예에서는 &lt;code&gt;scope&lt;/code&gt; 가 활성 초점을 얻을 때 &lt;code&gt;input&lt;/code&gt; 활성 초점이 주어집니다 .</target>
        </trans-unit>
        <trans-unit id="4e0819da2dbd645615c889341498dfb2518bb623" translate="yes" xml:space="preserve">
          <source>In the following example, SwipeDelegate is used in a &lt;a href=&quot;qml-qtquick-listview&quot;&gt;ListView&lt;/a&gt; to allow items to be removed from it by swiping to the left:</source>
          <target state="translated">다음 예제에서는 SwipeDelegate가 &lt;a href=&quot;qml-qtquick-listview&quot;&gt;ListView&lt;/a&gt; 에서 사용되어 왼쪽으로 스 와이프하여 항목을 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="58c896bb0118fd4b17c3e17913bd0f14d13381d1" translate="yes" xml:space="preserve">
          <source>In the following example, a &lt;a href=&quot;qml-qttest-signalspy&quot;&gt;SignalSpy&lt;/a&gt; is installed to watch the &quot;clicked&quot; signal on a user-defined Button type. When the signal is emitted, the &lt;a href=&quot;qml-qttest-signalspy#count-prop&quot;&gt;count&lt;/a&gt; property on the spy will be increased.</source>
          <target state="translated">다음 예제에서는 사용자 정의 버튼 유형에서 &quot;클릭 된&quot;신호를 감시하기 위해 &lt;a href=&quot;qml-qttest-signalspy&quot;&gt;SignalSpy&lt;/a&gt; 가 설치됩니다. 신호가 방출되면 스파이 의 &lt;a href=&quot;qml-qttest-signalspy#count-prop&quot;&gt;카운트&lt;/a&gt; 속성이 증가합니다.</target>
        </trans-unit>
        <trans-unit id="22378d815a5bf559d36ea737919d7de134256242" translate="yes" xml:space="preserve">
          <source>In the following example, a &lt;a href=&quot;qml-signalspy&quot;&gt;SignalSpy&lt;/a&gt; is installed to watch the &quot;clicked&quot; signal on a user-defined Button type. When the signal is emitted, the &lt;a href=&quot;qml-signalspy#count-prop&quot;&gt;count&lt;/a&gt; property on the spy will be increased.</source>
          <target state="translated">다음 예제에서는 사용자 정의 버튼 유형에서 &quot;클릭 된&quot;신호를 감시하기 위해 &lt;a href=&quot;qml-signalspy&quot;&gt;SignalSpy&lt;/a&gt; 가 설치됩니다. 신호가 방출되면 스파이 의 &lt;a href=&quot;qml-signalspy#count-prop&quot;&gt;카운트&lt;/a&gt; 속성이 증가합니다.</target>
        </trans-unit>
        <trans-unit id="9bd283878d95b8e8b04ed49b21027ac0175cb50a" translate="yes" xml:space="preserve">
          <source>In the following example, a &lt;code&gt;SELECT * FROM&lt;/code&gt; query is executed. Since the order of the columns is not defined, &lt;a href=&quot;qsqlrecord#indexOf&quot;&gt;QSqlRecord::indexOf&lt;/a&gt;() is used to obtain the index of a column.</source>
          <target state="translated">다음 예에서는 &lt;code&gt;SELECT * FROM&lt;/code&gt; 쿼리가 실행됩니다. 열의 순서가 정의되어 있지 않기 때문에 &lt;a href=&quot;qsqlrecord#indexOf&quot;&gt;QSqlRecord :: indexOf&lt;/a&gt; ()를 사용하여 열의 인덱스를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="b574e2ffddb2a728a47d6e0edfc1d4407d42d92f" translate="yes" xml:space="preserve">
          <source>In the following example, a SignalSpy is installed to watch the &quot;clicked&quot; signal on a user-defined Button type. When the signal is emitted, the &lt;a href=&quot;qml-qttest-signalspy#count-prop&quot;&gt;count&lt;/a&gt; property on the spy will be increased.</source>
          <target state="translated">다음 예제에서는 사용자 정의 버튼 유형에서 &quot;클릭 된&quot;신호를 감시하기 위해 SignalSpy가 설치됩니다. 신호가 방출되면 스파이 의 &lt;a href=&quot;qml-qttest-signalspy#count-prop&quot;&gt;카운트&lt;/a&gt; 속성이 증가합니다.</target>
        </trans-unit>
        <trans-unit id="c691a15610ea578a567805e044a101f496f9194a" translate="yes" xml:space="preserve">
          <source>In the following example, clicking on the QML object makes the C++ object print a message, and vice-versa. Here is the QML type (in &lt;code&gt;QmlGui.qml&lt;/code&gt;):</source>
          <target state="translated">다음 예제에서 QML 객체를 클릭하면 C ++ 객체가 메시지를 인쇄하고 그 반대의 경우도 마찬가지입니다. 다음은 QML 유형 ( &lt;code&gt;QmlGui.qml&lt;/code&gt; )입니다.</target>
        </trans-unit>
        <trans-unit id="f623ecae6b0bf3deb0b4709dfed34b752dd6da21" translate="yes" xml:space="preserve">
          <source>In the following example, color is applied for all color groups:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6df2cdf4213aee987d4b8b2674d10f643c33bbc" translate="yes" xml:space="preserve">
          <source>In the following example, colors will be different for enabled and disabled states:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd38a731aead71ed9be686fff959ae1dfac6c231" translate="yes" xml:space="preserve">
          <source>In the following example, the &lt;code&gt;addConstant()&lt;/code&gt; method will add 13 to the parameter passed just as the programmer would expect irrespective of the value of the QML object's &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; properties.</source>
          <target state="translated">다음 예제에서 &lt;code&gt;addConstant()&lt;/code&gt; 메서드는 QML 객체의 &lt;code&gt;a&lt;/code&gt; 및 &lt;code&gt;b&lt;/code&gt; 속성 값에 관계없이 프로그래머가 예상하는 것처럼 전달 된 매개 변수에 13을 추가 합니다.</target>
        </trans-unit>
        <trans-unit id="59547659499bdcf5cff2c44ed1079fc9831e4602" translate="yes" xml:space="preserve">
          <source>In the following example, the &lt;code&gt;color&lt;/code&gt; property of &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt; depends on the &lt;code&gt;pressed&lt;/code&gt; property of &lt;a href=&quot;qml-qtquick-taphandler&quot;&gt;TapHandler&lt;/a&gt;. This relationship is described using a conditional expression:</source>
          <target state="translated">다음 예에서 &lt;code&gt;color&lt;/code&gt; 의 특성 &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;사각형&lt;/a&gt; 상의 따라 &lt;code&gt;pressed&lt;/code&gt; 의 재산 &lt;a href=&quot;qml-qtquick-taphandler&quot;&gt;TapHandler&lt;/a&gt; . 이 관계는 조건식을 사용하여 설명됩니다.</target>
        </trans-unit>
        <trans-unit id="80c0f852f3619a0ba059397adca8341bc8b6fac9" translate="yes" xml:space="preserve">
          <source>In the following example, the &lt;code&gt;index&lt;/code&gt; context property inserted by the &lt;a href=&quot;qml-qtquick-listview&quot;&gt;ListView&lt;/a&gt; into &lt;code&gt;delegateComponent&lt;/code&gt;'s context will be inaccessible to Text, as the Loader will use the creation context of &lt;code&gt;myComponent&lt;/code&gt; as the parent context when instantiating it, and &lt;code&gt;index&lt;/code&gt; does not refer to anything within that context chain.</source>
          <target state="translated">다음 예제 에서 &lt;a href=&quot;qml-qtquick-listview&quot;&gt;ListView&lt;/a&gt; 에 의해 &lt;code&gt;delegateComponent&lt;/code&gt; 의 컨텍스트에 삽입 된 &lt;code&gt;index&lt;/code&gt; 컨텍스트 속성 은 Text에 액세스 할 수 없습니다. Loader는 인스턴스화 할 때 &lt;code&gt;myComponent&lt;/code&gt; 의 생성 컨텍스트를 부모 컨텍스트로 사용하고 &lt;code&gt;index&lt;/code&gt; 는 내부의 어떤 것도 참조하지 않기 때문입니다. 그 컨텍스트 체인.</target>
        </trans-unit>
        <trans-unit id="2c1a3b0b7aa04aadcdeaef781ce1273789fd1a3c" translate="yes" xml:space="preserve">
          <source>In the following example, the TextSender class emits a &lt;code&gt;textCompleted()&lt;/code&gt; signal which carries a &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; parameter. Here is the class declaration:</source>
          <target state="translated">다음 예제에서 TextSender 클래스 는 &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; 매개 변수 를 전달하는 &lt;code&gt;textCompleted()&lt;/code&gt; 신호를 내 보냅니다 . 다음은 클래스 선언입니다.</target>
        </trans-unit>
        <trans-unit id="a3352880eeab52d6c62295880543212828a87c46" translate="yes" xml:space="preserve">
          <source>In the following example, the accent color of the highlighted button is changed to &lt;code&gt;Material.Orange&lt;/code&gt;:</source>
          <target state="translated">다음 예제에서는 강조 표시된 버튼의 강조 색상이 &lt;code&gt;Material.Orange&lt;/code&gt; 로 변경됩니다 .</target>
        </trans-unit>
        <trans-unit id="78d19a444e0e511a3cb9dcaba69cc7663ab9bb2f" translate="yes" xml:space="preserve">
          <source>In the following example, the accent color of the highlighted button is changed to &lt;code&gt;Universal.Orange&lt;/code&gt;:</source>
          <target state="translated">다음 예제에서는 강조 표시된 버튼의 강조 색상이 &lt;code&gt;Universal.Orange&lt;/code&gt; 로 변경됩니다 .</target>
        </trans-unit>
        <trans-unit id="eb9cd8fd9bd05420727217cf1a0a22388215db8c" translate="yes" xml:space="preserve">
          <source>In the following example, the addition of explicit prevents &lt;code&gt;myItem.width&lt;/code&gt; from being bound to &lt;code&gt;parent.width&lt;/code&gt;. Instead, it is assigned the value of &lt;code&gt;parent.width&lt;/code&gt; at the time of the state change.</source>
          <target state="translated">다음 예제에서 explicit을 추가하면 &lt;code&gt;myItem.width&lt;/code&gt; 가 &lt;code&gt;parent.width&lt;/code&gt; 에 바인드되지 않습니다 . 대신 상태 변경시 &lt;code&gt;parent.width&lt;/code&gt; 값이 할당됩니다 .</target>
        </trans-unit>
        <trans-unit id="96e5e49a119542cf78e7a0de167b4f79267fd829" translate="yes" xml:space="preserve">
          <source>In the following example, the background color of the button is changed to &lt;code&gt;Material.Teal&lt;/code&gt;:</source>
          <target state="translated">다음 예제에서 버튼의 배경색은 &lt;code&gt;Material.Teal&lt;/code&gt; 로 변경됩니다 .</target>
        </trans-unit>
        <trans-unit id="c0b747eb4cdd1148dbcce2713324d55431bba2e2" translate="yes" xml:space="preserve">
          <source>In the following example, the background color of the pane is changed to &lt;code&gt;Universal.Steel&lt;/code&gt;:</source>
          <target state="translated">다음 예제에서는 창의 배경색이 &lt;code&gt;Universal.Steel&lt;/code&gt; 로 변경됩니다 .</target>
        </trans-unit>
        <trans-unit id="a77a03410ece85274f6797b0ef16fdc7b0ab5063" translate="yes" xml:space="preserve">
          <source>In the following example, the delegate shows the property</source>
          <target state="translated">다음 예제에서 대리자는 속성을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="cc781dd00dd5a638dbe28a63fadb0fd0a139d73f" translate="yes" xml:space="preserve">
          <source>In the following example, the elevation of the pane is set to &lt;code&gt;6&lt;/code&gt; in order to achieve the look of an &lt;a href=&quot;https://material.google.com/components/cards.html&quot;&gt;elevated card&lt;/a&gt;:</source>
          <target state="translated">다음 예에서는 &lt;a href=&quot;https://material.google.com/components/cards.html&quot;&gt;승격 된 카드&lt;/a&gt; 의 모양을 얻기 위해 창의 높이를 &lt;code&gt;6&lt;/code&gt; 으로 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="6bc2b9e30678181b82a731599506d1f147727a2c" translate="yes" xml:space="preserve">
          <source>In the following example, the foreground color of the button is set to &lt;code&gt;Material.Pink&lt;/code&gt;:</source>
          <target state="translated">다음 예제에서 버튼의 전경색은 &lt;code&gt;Material.Pink&lt;/code&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="d7f80fed26df86ccdd2d3e899168b46e040786bc" translate="yes" xml:space="preserve">
          <source>In the following example, the foreground color of the button is set to &lt;code&gt;Universal.Pink&lt;/code&gt;:</source>
          <target state="translated">다음 예제에서 버튼의 전경색은 &lt;code&gt;Universal.Pink&lt;/code&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="4989d038344e505731fc2f0e8ab973e6410cb836" translate="yes" xml:space="preserve">
          <source>In the following example, the geometry of each child &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt; is bound to that of the parent &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt;. If the geometry of the parent &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt; were to change, the geometry of each child &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt; would automatically update due to the property bindings.</source>
          <target state="translated">다음 예에서, 각 아동의 형상 &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;사각형은&lt;/a&gt; 부모의에 바인딩 &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;사각형&lt;/a&gt; . 부모 &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt; 의 지오메트리가 변경되면 속성 바인딩으로 인해 각 자식 &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt; 의 지오메트리 가 자동으로 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="341370626c1f494f2c5d38563983b3c8f0df9d88" translate="yes" xml:space="preserve">
          <source>In the following example, the rectangle will spin indefinitely.</source>
          <target state="translated">다음 예제에서 사각형은 무한정 회전합니다.</target>
        </trans-unit>
        <trans-unit id="743d3704b4909878d3c325ebfc5ee54a02e4c5fa" translate="yes" xml:space="preserve">
          <source>In the following example, the theme for both the pane and the button is set to &lt;code&gt;Material.Dark&lt;/code&gt;:</source>
          <target state="translated">다음 예제에서는 창과 버튼 모두의 테마가 &lt;code&gt;Material.Dark&lt;/code&gt; 로 설정되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2a3d0c980e6076e4372b5a4c0cbaa2d332daabe0" translate="yes" xml:space="preserve">
          <source>In the following example, the theme for both the pane and the button is set to &lt;code&gt;Universal.Dark&lt;/code&gt;:</source>
          <target state="translated">다음 예제에서 창과 버튼의 테마는 &lt;code&gt;Universal.Dark&lt;/code&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="f707a116dec82eb863cb33247b6dd8baae00de63" translate="yes" xml:space="preserve">
          <source>In the following example, we animate a green rectangle along a bezier path.</source>
          <target state="translated">다음 예제에서는 베 지어 경로를 따라 녹색 직사각형을 애니메이션합니다.</target>
        </trans-unit>
        <trans-unit id="f158cd8619df9c72bf318794a5b1bc26fa7e5c13" translate="yes" xml:space="preserve">
          <source>In the following example, we append a CBOR Tag 1 (Unix &lt;code&gt;time_t&lt;/code&gt;) and an integer representing the current time to the stream, obtained using the &lt;code&gt;time()&lt;/code&gt; function:</source>
          <target state="translated">다음 예에서는 CBOR 태그 1 (Unix &lt;code&gt;time_t&lt;/code&gt; )과 &lt;code&gt;time()&lt;/code&gt; 함수를 사용하여 얻은 현재 시간을 나타내는 정수를 스트림에 추가 합니다.</target>
        </trans-unit>
        <trans-unit id="d6fd9744796d1b104621935a4a6328f618455725" translate="yes" xml:space="preserve">
          <source>In the following example, we append a CBOR Tag 36 (Regular Expression) and a &lt;a href=&quot;qregularexpression&quot;&gt;QRegularExpression&lt;/a&gt;'s pattern to the stream:</source>
          <target state="translated">다음 예제에서는 CBOR 태그 36 (정규식)과 &lt;a href=&quot;qregularexpression&quot;&gt;QRegularExpression&lt;/a&gt; 의 패턴을 스트림에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="dde8423def1bf713051467e8b52e0ba9b677e316" translate="yes" xml:space="preserve">
          <source>In the following example, we append a CBOR Tag 36 (Regular Expression) and a &lt;a href=&quot;qtcore-changes-qt6#qregularexpression&quot;&gt;QRegularExpression&lt;/a&gt;'s pattern to the stream:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e01cfb48210852f8dd95e4408d9268565b905118" translate="yes" xml:space="preserve">
          <source>In the following example, we declare a property of the enumeration type &lt;code&gt;Priority&lt;/code&gt; that is also called &lt;code&gt;priority&lt;/code&gt; and has a get function &lt;code&gt;priority()&lt;/code&gt; and a set function &lt;code&gt;setPriority()&lt;/code&gt;.</source>
          <target state="translated">다음 예제에서, 우리 는 &lt;code&gt;priority&lt;/code&gt; 라고도 부르고 get 함수 &lt;code&gt;priority()&lt;/code&gt; 및 set 함수 &lt;code&gt;setPriority()&lt;/code&gt; 가있는 열거 형 &lt;code&gt;Priority&lt;/code&gt; 의 속성을 선언합니다 .</target>
        </trans-unit>
        <trans-unit id="9b4a3a1f331007024f30f7e139ccf549e42fccb1" translate="yes" xml:space="preserve">
          <source>In the following example, we have a block of code which is run often (in this case, it is the contents of an explicit loop; but it could be a commonly-evaluated binding expression, for example) and in it, we resolve the object with the &quot;rect&quot; id and its &quot;color&quot; property multiple times:</source>
          <target state="translated">다음 예제에서는 자주 실행되는 코드 블록 (이 경우 명시 적 루프의 내용이지만 일반적으로 평가되는 바인딩 표현식이 될 수 있음)이 있습니다. &quot;rect&quot;ID와 &quot;color&quot;속성이 여러 번있는 개체 :</target>
        </trans-unit>
        <trans-unit id="5ee21d4a3a60fbc00455c78c23d1b1a49e5e2daa" translate="yes" xml:space="preserve">
          <source>In the following example, we have two small rectangles that follow our touch points.</source>
          <target state="translated">다음 예에서는 터치 포인트를 따르는 두 개의 작은 직사각형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="56883a9b4926a32a7dd3884ccc5a7fe11a5dc3fb" translate="yes" xml:space="preserve">
          <source>In the following example, we write the values -1, -2&lt;sup&gt;32&lt;/sup&gt; and INT64_MIN:</source>
          <target state="translated">다음 예에서는 -1, -2 &lt;sup&gt;32&lt;/sup&gt; 및 INT64_MIN 값 을 씁니다.</target>
        </trans-unit>
        <trans-unit id="c042b833c02669722bfb4cea9e7ff1e503c59868" translate="yes" xml:space="preserve">
          <source>In the following sections we will take a look at how this can be achieved. While the example uses &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-text&quot;&gt;Text&lt;/a&gt;, any Qt Quick content, including Qt Quick Controls, &lt;a href=&quot;qml-qtquick-shapes-shape&quot;&gt;Shape&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-shadereffect&quot;&gt;ShaderEffect&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-particles-particlesystem&quot;&gt;ParticleSystem&lt;/a&gt;, can be used this way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4f49c2cda8c5197cbdb2d193c5e6de20fce89f5" translate="yes" xml:space="preserve">
          <source>In the following snippet we animate the addition of a right anchor to a &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt;:</source>
          <target state="translated">다음 스 니펫에서는 &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle에&lt;/a&gt; 오른쪽 앵커를 추가하는 애니메이션을 적용합니다 .</target>
        </trans-unit>
        <trans-unit id="c7be1cf0dcf07a7af9e364bcc18d12513fdfed2c" translate="yes" xml:space="preserve">
          <source>In the following table, the various modes are illustrated with animations. The movement and the &lt;a href=&quot;qml-qtquick-controls2-scrollbar#stepSize-prop&quot;&gt;stepSize&lt;/a&gt; (&lt;code&gt;0.25&lt;/code&gt;) are identical in each animation.</source>
          <target state="translated">다음 표에는 다양한 모드가 애니메이션으로 설명되어 있습니다. 움직임과 &lt;a href=&quot;qml-qtquick-controls2-scrollbar#stepSize-prop&quot;&gt;stepSize&lt;/a&gt; ( &lt;code&gt;0.25&lt;/code&gt; )는 각 애니메이션에서 동일합니다.</target>
        </trans-unit>
        <trans-unit id="dd3fb0d762d56fc045cc53eb59db05be298a4209" translate="yes" xml:space="preserve">
          <source>In the following table, the various modes are illustrated with animations. The movement of the mouse cursor and the &lt;a href=&quot;qml-qtquick-controls2-slider#stepSize-prop&quot;&gt;stepSize&lt;/a&gt; (&lt;code&gt;0.2&lt;/code&gt;) are identical in each animation.</source>
          <target state="translated">다음 표에는 다양한 모드가 애니메이션으로 설명되어 있습니다. 마우스 커서의 움직임과 &lt;a href=&quot;qml-qtquick-controls2-slider#stepSize-prop&quot;&gt;stepSize&lt;/a&gt; ( &lt;code&gt;0.2&lt;/code&gt; )는 각 애니메이션에서 동일합니다.</target>
        </trans-unit>
        <trans-unit id="8e1eef09ea620a7bcaff164ce888f61fc4682e29" translate="yes" xml:space="preserve">
          <source>In the forms settings dialog you can specify the &lt;b&gt;Author&lt;/b&gt; of the form.</source>
          <target state="translated">양식 설정 대화 상자 에서 양식 &lt;b&gt;작성자&lt;/b&gt; 를 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5a6082e9b911ab0b6ba75d67f55be589f6bfd348" translate="yes" xml:space="preserve">
          <source>In the future, this may be extended to specify other types of paragraph decorations.</source>
          <target state="translated">향후에는 다른 유형의 단락 장식을 지정하도록 확장 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e60a0aced65c1ee590fed2890ff810aee3e6d361" translate="yes" xml:space="preserve">
          <source>In the generated HTML, the delimited text is surrounded by a &lt;b&gt;&amp;lt;div class=&quot;LegaleseLeft&quot;&amp;gt;&lt;/b&gt; and &lt;b&gt;&amp;lt;/div&amp;gt;&lt;/b&gt; tags.</source>
          <target state="translated">생성 된 HTML에서 구분 된 텍스트는 &lt;b&gt;&amp;lt;div class = &quot;LegaleseLeft&quot;&amp;gt;&lt;/b&gt; 및 &lt;b&gt;&amp;lt;/ div&amp;gt;&lt;/b&gt; 태그 로 둘러싸여 있습니다.</target>
        </trans-unit>
        <trans-unit id="c57ee3f7da3bc2fe3421eb7c814d7e4cd4bda70e" translate="yes" xml:space="preserve">
          <source>In the header delegate you have access to the following special properties:</source>
          <target state="translated">헤더 대리자에서 다음과 같은 특수 속성에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8173b8ef4a5f53c2549b7e4febc3ca8abd181b96" translate="yes" xml:space="preserve">
          <source>In the illustration above, Application One's primary screen is screen 0, and App Two's primary screen is screen 1.</source>
          <target state="translated">위의 그림에서 Application One의 기본 화면은 화면 0이고 App Two의 기본 화면은 화면 1입니다.</target>
        </trans-unit>
        <trans-unit id="3fb432b3ba74ad6dc109c6c379bc4fff8bedeee3" translate="yes" xml:space="preserve">
          <source>In the image above, the application's contents are</source>
          <target state="translated">위 이미지에서 응용 프로그램의 내용은</target>
        </trans-unit>
        <trans-unit id="c211da3ff0af505bb1a04f177de23028d06c25e4" translate="yes" xml:space="preserve">
          <source>In the image below, the Rectangle on the left has transparent borders and has blurred edges, whereas the Rectangle on the right does not:</source>
          <target state="translated">아래 이미지에서 왼쪽의 사각형에는 투명한 테두리가 있고 가장자리가 흐려지는 반면 오른쪽의 사각형은 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="191949eada4e16c66ee51b0e511e500ba2bcfade" translate="yes" xml:space="preserve">
          <source>In the image below, the dashed line represents the button's clickable area, as well as the space that it will take up in a layout. The shadow is marked by the striped area behind it:</source>
          <target state="translated">아래 이미지에서 점선은 버튼의 클릭 가능 영역과 레이아웃에서 차지할 공간을 나타냅니다. 그림자는 그 뒤에 줄무늬 영역으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="f648a46e343e549b31e734ea66fd63991f85987c" translate="yes" xml:space="preserve">
          <source>In the image below, there are 3 MapQuickItems that are identical except for the value of their &lt;a href=&quot;qml-qtlocation-mapquickitem#anchorPoint-prop&quot;&gt;anchorPoint&lt;/a&gt; properties. The values of &lt;a href=&quot;qml-qtlocation-mapquickitem#anchorPoint-prop&quot;&gt;anchorPoint&lt;/a&gt; for each are written on top of the item.</source>
          <target state="translated">아래 이미지에는 &lt;a href=&quot;qml-qtlocation-mapquickitem#anchorPoint-prop&quot;&gt;anchorPoint&lt;/a&gt; 속성 값을 제외하고 동일한 3 개의 MapQuickItem이 있습니다. 각각 의 &lt;a href=&quot;qml-qtlocation-mapquickitem#anchorPoint-prop&quot;&gt;anchorPoint&lt;/a&gt; 값이 항목 위에 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="082f7f30e8907c70363ecd18171de71be62db1d7" translate="yes" xml:space="preserve">
          <source>In the item delegate you have access to the following special properties:</source>
          <target state="translated">품목 위임에서 다음과 같은 특수 특성에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7bb6abe2856b41a5ce3d15e52bcc5ddd2f2d9067" translate="yes" xml:space="preserve">
          <source>In the left-most case, the blue backgrounds can be drawn in one call and the two text elements in another call, as the texts only overlap a background which they are stacked in front of. In the right-most case, the background of &quot;Item 4&quot; overlaps the text of &quot;Item 3&quot; so in this case, each of backgrounds and texts needs to be drawn using separate calls.</source>
          <target state="translated">가장 왼쪽의 경우, 텍스트는 앞에 쌓인 배경과 겹치므로 파란색 배경은 한 번의 호출로, 두 개의 텍스트 요소는 다른 호출로 그릴 수 있습니다. 가장 오른쪽의 경우 &quot;항목 4&quot;의 배경이 &quot;항목 3&quot;의 텍스트와 겹치므로이 경우 별도의 호출을 사용하여 각 배경과 텍스트를 그려야합니다.</target>
        </trans-unit>
        <trans-unit id="177b7d5c2decfb03bbfe45d40de7969b7109f90f" translate="yes" xml:space="preserve">
          <source>In the long term, the application should be adapted to run unmodified:</source>
          <target state="translated">장기적으로 응용 프로그램은 수정되지 않은 상태로 실행되도록 조정되어야합니다.</target>
        </trans-unit>
        <trans-unit id="8c3da8e46d1d8e95626b65e9bb8214b9d517af62" translate="yes" xml:space="preserve">
          <source>In the longer term, the application should be adapted to run unmodified:</source>
          <target state="translated">장기적으로 응용 프로그램은 수정되지 않은 상태로 실행되도록 조정해야합니다.</target>
        </trans-unit>
        <trans-unit id="51c6be12ebbbbbce5a427c8b0a320a8136d5c56c" translate="yes" xml:space="preserve">
          <source>In the main function, help should be printed to the standard output if the help option was passed and the application should return the exit code 0.</source>
          <target state="translated">기본 기능에서 도움말 옵션이 전달되고 응용 프로그램이 종료 코드 0을 리턴하면 도움말이 표준 출력으로 인쇄되어야합니다.</target>
        </trans-unit>
        <trans-unit id="ed013eb27af18e56a8b0e5420faef98e6525a1de" translate="yes" xml:space="preserve">
          <source>In the material slots list, select the desired material slot.</source>
          <target state="translated">재료 슬롯 목록에서 원하는 재료 슬롯을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="5e1a3459ad641f2f0c92cc0960f241ccfd42b74e" translate="yes" xml:space="preserve">
          <source>In the member function documentation,</source>
          <target state="translated">멤버 함수 문서에서</target>
        </trans-unit>
        <trans-unit id="d77c5dd9303a67ac6d7d5aebb50b969970257a99" translate="yes" xml:space="preserve">
          <source>In the middle of the header</source>
          <target state="translated">헤더 중간에</target>
        </trans-unit>
        <trans-unit id="af661d34da446aba519642819b2c4cf4140ea33d" translate="yes" xml:space="preserve">
          <source>In the mode Wildcard, the wildcard characters cannot be escaped. In the mode &lt;a href=&quot;qregexp#PatternSyntax-enum&quot;&gt;WildcardUnix&lt;/a&gt;, the character '\' escapes the wildcard.</source>
          <target state="translated">와일드 카드 모드에서는 와일드 카드 문자를 이스케이프 할 수 없습니다. &lt;a href=&quot;qregexp#PatternSyntax-enum&quot;&gt;WildcardUnix&lt;/a&gt; 모드 에서 문자 '\'는 와일드 카드를 이스케이프합니다.</target>
        </trans-unit>
        <trans-unit id="f8b69786d48f5ae87bab7e6f1ebdcfe64ffe3ce7" translate="yes" xml:space="preserve">
          <source>In the model/view architecture, the model provides a standard interface that views and delegates use to access data. In Qt, the standard interface is defined by the &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; class. No matter how the items of data are stored in any underlying data structure, all subclasses of &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; represent the data as a hierarchical structure containing tables of items. Views use this</source>
          <target state="translated">모델 / 뷰 아키텍처에서 모델은 뷰 및 델리게이트가 데이터에 액세스하는 데 사용하는 표준 인터페이스를 제공합니다. Qt에서 표준 인터페이스는 &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; 클래스에 의해 정의됩니다 . 기본 데이터 구조에 데이터 항목이 저장되는 방식에 관계없이 &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel의&lt;/a&gt; 모든 하위 클래스 는 데이터를 항목 테이블을 포함하는 계층 구조로 나타냅니다. 뷰는 이것을 사용합니다</target>
        </trans-unit>
        <trans-unit id="275784bafdfff3eb16930135da34d48478b10553" translate="yes" xml:space="preserve">
          <source>In the model/view architecture, the view obtains items of data from the model and presents them to the user. The way that the data is presented need not resemble the representation of the data provided by the model, and may be</source>
          <target state="translated">모델 / 뷰 아키텍처에서 뷰는 모델에서 데이터 항목을 가져와 사용자에게 제공합니다. 데이터가 제시되는 방식은 모델이 제공 한 데이터의 표현과 유사 할 필요는 없으며,</target>
        </trans-unit>
        <trans-unit id="a49a54368d26d92ba28f5862b8e174823625e9b2" translate="yes" xml:space="preserve">
          <source>In the model/view framework, items of data supplied by a single model can be shared by any number of views, and each of these can possibly represent the same information in completely different ways. Custom views and delegates are effective ways to provide radically different representations of the same data. However, applications often need to provide conventional views onto processed versions of the same data, such as differently-sorted views onto a list of items.</source>
          <target state="translated">모델 / 뷰 프레임 워크에서 단일 모델이 제공하는 데이터 항목은 여러 뷰에서 공유 할 수 있으며 각 항목은 완전히 다른 방식으로 동일한 정보를 나타낼 수 있습니다. 커스텀 뷰와 델리게이트는 동일한 데이터의 근본적으로 다른 표현을 제공하는 효과적인 방법입니다. 그러나 응용 프로그램은 종종 항목 목록에 대한 다르게 정렬 된보기와 같은 동일한 데이터의 처리 된 버전에 대한 일반적인보기를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="a21e4b40007ffeb9d778d238317abb44d5c23fe4" translate="yes" xml:space="preserve">
          <source>In the next example the first &lt;a href=&quot;qfuture#onCanceled&quot;&gt;onCanceled&lt;/a&gt;() (&lt;code&gt;Block 2&lt;/code&gt;) is removed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1336f1f47c6dbd46a0c5fbd43afadfef23c59a5" translate="yes" xml:space="preserve">
          <source>In the next example we demonstrate how you can append content to an editable combo box by reacting to the &lt;a href=&quot;qml-qtquick-controls-combobox#accepted-signal&quot;&gt;accepted&lt;/a&gt; signal. Note that you have to explicitly prevent duplicates.</source>
          <target state="translated">다음 예에서는 &lt;a href=&quot;qml-qtquick-controls-combobox#accepted-signal&quot;&gt;허용 된&lt;/a&gt; 신호 에 반응하여 편집 가능한 콤보 상자에 내용을 추가하는 방법을 보여줍니다 . 중복을 명시 적으로 방지해야합니다.</target>
        </trans-unit>
        <trans-unit id="fff6d48c82e62be915aadae1c2c6306b781872ae" translate="yes" xml:space="preserve">
          <source>In the next example, a &lt;a href=&quot;qml-qtquick-focusscope&quot;&gt;FocusScope&lt;/a&gt; type is added to the component, and the visual result shown.</source>
          <target state="translated">다음 예에서는 &lt;a href=&quot;qml-qtquick-focusscope&quot;&gt;FocusScope&lt;/a&gt; 유형이 구성 요소에 추가되고 시각적 결과가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="3a84ddb296d495f44770fbc6512d1d10fc13b94a" translate="yes" xml:space="preserve">
          <source>In the next section &lt;b&gt;In-App Purchase Details&lt;/b&gt; you specify the details for at least one language. When the app requests the product details like &lt;code&gt;title&lt;/code&gt; and &lt;code&gt;description&lt;/code&gt;, they will be provided in the language of their locale if they are available. Create language details for the regions you expect to distribute app in.</source>
          <target state="translated">다음 섹션 &lt;b&gt;인앱 구매 세부 사항&lt;/b&gt; 에서 하나 이상의 언어에 대한 &lt;b&gt;세부 사항&lt;/b&gt; 을 지정합니다. 앱에서 &lt;code&gt;title&lt;/code&gt; 및 &lt;code&gt;description&lt;/code&gt; 과 같은 제품 세부 정보를 요청하면 사용 가능한 로캘의 언어로 제공됩니다. 앱을 배포 할 지역의 언어 세부 정보를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="42f41286e6a6c222e5fb44103c0dcb5543cb5b89" translate="yes" xml:space="preserve">
          <source>In the normal case, where animations are not used, this will operate as expected. However, if an animation for the &lt;code&gt;geometry&lt;/code&gt; of &lt;code&gt;button&lt;/code&gt; is set on the transition between &lt;code&gt;s1&lt;/code&gt; and &lt;code&gt;s2&lt;/code&gt;, the animation will be started when &lt;code&gt;s2&lt;/code&gt; is entered, but the &lt;code&gt;geometry&lt;/code&gt; property will not actually reach its defined value before the animation is finished running. In this case, the message box will pop up before the geometry of the button has actually been set.</source>
          <target state="translated">애니메이션이 사용되지 않는 일반적인 경우에는 예상대로 작동합니다. 그러나 &lt;code&gt;button&lt;/code&gt; &lt;code&gt;geometry&lt;/code&gt; 에 대한 애니메이션이 &lt;code&gt;s1&lt;/code&gt; 과 &lt;code&gt;s2&lt;/code&gt; 사이의 전환에서 설정 되면 &lt;code&gt;s2&lt;/code&gt; 를 입력 할 때 애니메이션이 시작 되지만 애니메이션 실행이 완료되기 전에 &lt;code&gt;geometry&lt;/code&gt; 속성이 실제로 정의 된 값에 도달하지 않습니다. 이 경우 버튼의 지오메트리가 실제로 설정되기 전에 메시지 상자가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="17325e9c13239f8bec358a47722a114c09a84b73" translate="yes" xml:space="preserve">
          <source>In the preferences dialog box, locate the &lt;b&gt;Collada I/O&lt;/b&gt; section under &lt;b&gt;File I/O&lt;/b&gt;. Ensure that the &lt;b&gt;Save Triangles as Triangles&lt;/b&gt; option is checked.</source>
          <target state="translated">기본 설정 대화 상자 에서 &lt;b&gt;파일 I / O&lt;/b&gt; 아래 의 &lt;b&gt;Collada I / O&lt;/b&gt; 섹션을 찾습니다 . &lt;b&gt;삼각형을 삼각형으로 저장&lt;/b&gt; 옵션이 선택 &lt;b&gt;되어&lt;/b&gt; 있는지 확인하십시오 .&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ac99875170e76bb77a35adf7514e7d860053b108" translate="yes" xml:space="preserve">
          <source>In the previous example the Image item will implicitly get scroll behavior as if it was used within a &lt;a href=&quot;qml-qtquick-flickable&quot;&gt;Flickable&lt;/a&gt;. The width and height of the child item will be used to define the size of the content area.</source>
          <target state="translated">이전 예제에서 Image 항목은 &lt;a href=&quot;qml-qtquick-flickable&quot;&gt;Flickable&lt;/a&gt; 내에서 사용 된 것처럼 암시 적으로 스크롤 동작을 얻습니다 . 하위 항목의 너비와 높이는 컨텐츠 영역의 크기를 정의하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="772b0f71c73902deebe22dad6acf14257c43a016" translate="yes" xml:space="preserve">
          <source>In the previous example,</source>
          <target state="translated">이전 예에서</target>
        </trans-unit>
        <trans-unit id="c98f84e7920e2d706fb32da691ff01f1a6ea38e3" translate="yes" xml:space="preserve">
          <source>In the previous example, the &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtquick-animation-example.html#propertyanimation&quot;&gt;PropertyAnimation&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-numberanimation&quot;&gt;NumberAnimation&lt;/a&gt; objects needed to specify particular &lt;a href=&quot;qml-qtquick-propertyanimation#target-prop&quot;&gt;target&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-propertyanimation#properties-prop&quot;&gt;properties&lt;/a&gt; values to specify the objects and properties that should be animated. This can be avoided by using the</source>
          <target state="translated">이전 예제에서 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtquick-animation-example.html#propertyanimation&quot;&gt;PropertyAnimation&lt;/a&gt; 및 &lt;a href=&quot;qml-qtquick-numberanimation&quot;&gt;NumberAnimation&lt;/a&gt; 객체는 특정 &lt;a href=&quot;qml-qtquick-propertyanimation#target-prop&quot;&gt;대상&lt;/a&gt; 및 &lt;a href=&quot;qml-qtquick-propertyanimation#properties-prop&quot;&gt;속성&lt;/a&gt; 값을 지정하여 애니메이션을 적용 할 객체 및 속성을 지정해야했습니다. 이를 사용하여 피할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="b8c3f6b5d4707cf4cd86612144462b4d92515e94" translate="yes" xml:space="preserve">
          <source>In the previous example, the &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtquick-animation-example.html#propertyanimation&quot;&gt;PropertyAnimation&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-numberanimation&quot;&gt;NumberAnimation&lt;/a&gt; objects needed to specify particular &lt;a href=&quot;qml-qtquick-propertyanimation#target-prop&quot;&gt;target&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-propertyanimation#properties-prop&quot;&gt;properties&lt;/a&gt; values to specify the objects and properties that should be animated. This can be avoided by using the</source>
          <target state="translated">이전 예제에서 &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtquick-animation-example.html#propertyanimation&quot;&gt;PropertyAnimation&lt;/a&gt; 및 &lt;a href=&quot;qml-qtquick-numberanimation&quot;&gt;NumberAnimation&lt;/a&gt; 개체 는 애니메이션을 적용 할 개체와 속성을 지정하기 위해 특정 &lt;a href=&quot;qml-qtquick-propertyanimation#target-prop&quot;&gt;대상&lt;/a&gt; 및 &lt;a href=&quot;qml-qtquick-propertyanimation#properties-prop&quot;&gt;속성&lt;/a&gt; 값을 지정해야했습니다. 이것은 다음을 사용하여 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="470e4a3556453aa9f435b570f202da3edc9504db" translate="yes" xml:space="preserve">
          <source>In the previous example, the &lt;a href=&quot;https://doc.qt.io/qt-6.0/qtquick-animation-example.html#propertyanimation&quot;&gt;PropertyAnimation&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-numberanimation&quot;&gt;NumberAnimation&lt;/a&gt; objects needed to specify particular &lt;a href=&quot;qml-qtquick-propertyanimation#target-prop&quot;&gt;target&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-propertyanimation#properties-prop&quot;&gt;properties&lt;/a&gt; values to specify the objects and properties that should be animated. This can be avoided by using the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2678a9c929c58e4117992261fd411c31e21f57e1" translate="yes" xml:space="preserve">
          <source>In the previous example, the &lt;code&gt;first&lt;/code&gt; property is bound to an empty expression, whose result is undefined. The &lt;code&gt;second&lt;/code&gt; property is bound to an expression which contains a single, empty expression block (&quot;{}&quot;), which similarly has an undefined result. The &lt;code&gt;third&lt;/code&gt; property is bound to an expression which is evaluated as an empty object declaration, and thus the property will be initialized with that empty object value.</source>
          <target state="translated">이전 예제에서 &lt;code&gt;first&lt;/code&gt; 특성은 빈 표현식에 바인딩되며 결과는 정의되지 않습니다. 두 &lt;code&gt;second&lt;/code&gt; 특성은 하나의 빈 표현식 블록 ( &quot;{}&quot;)을 포함하는 표현식에 바인드되며 결과적으로 정의되지 않은 결과가 발생합니다. &lt;code&gt;third&lt;/code&gt; 특성은 빈 객체 선언으로 평가되고, 따라서 그 특성이 빈 객체 값으로 초기화한다 식으로 결합된다.</target>
        </trans-unit>
        <trans-unit id="92ee099e4a752c82bfa9a9a7bedb92d22f069ed1" translate="yes" xml:space="preserve">
          <source>In the previous example, the rectangles &lt;code&gt;r0&lt;/code&gt; and &lt;code&gt;r1&lt;/code&gt; do not have any custom properties, and thus the JavaScript and QML engines consider them both to be of the same type. That is, &lt;code&gt;r0&lt;/code&gt; and &lt;code&gt;r1&lt;/code&gt; are both considered to be of the explicitly defined &lt;code&gt;Rectangle&lt;/code&gt; type. The rectangles &lt;code&gt;r2&lt;/code&gt;, &lt;code&gt;r3&lt;/code&gt; and &lt;code&gt;r4&lt;/code&gt; each have custom properties and are each considered to be of different (implicit) types. Note that &lt;code&gt;r3&lt;/code&gt; and &lt;code&gt;r4&lt;/code&gt; are each considered to be of different types, even though they have identical property information, simply because the custom property was not declared in the component which they are instances of.</source>
          <target state="translated">이전 예제에서 사각형 &lt;code&gt;r0&lt;/code&gt; 및 &lt;code&gt;r1&lt;/code&gt; 에는 사용자 정의 특성이 없으므로 JavaScript 및 QML 엔진은 둘 다 동일한 유형 인 것으로 간주합니다. 즉, &lt;code&gt;r0&lt;/code&gt; 및 &lt;code&gt;r1&lt;/code&gt; 은 모두 명시 적으로 정의 된 &lt;code&gt;Rectangle&lt;/code&gt; 유형 인 것으로 간주됩니다 . 직사각형 &lt;code&gt;r2&lt;/code&gt; , &lt;code&gt;r3&lt;/code&gt; 및 &lt;code&gt;r4&lt;/code&gt; 는 각각 사용자 정의 특성을 가지며 각각 다른 (암시 적) 유형으로 간주됩니다. 참고 &lt;code&gt;r3&lt;/code&gt; 와 &lt;code&gt;r4&lt;/code&gt; 사용자 정의 속성이 인스턴스 인 구성 요소에서 선언되지 않았기 때문에 속성 정보가 동일하더라도 서로 다른 유형으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="c2d170d35d98882879d1582bff3bbe1a36253602" translate="yes" xml:space="preserve">
          <source>In the properties panel, select the &lt;b&gt;material&lt;/b&gt; tab.</source>
          <target state="translated">속성 패널에서 &lt;b&gt;재료&lt;/b&gt; 탭을 선택합니다 .</target>
        </trans-unit>
        <trans-unit id="71a58bdaf4897e02b754535e7683da68018828c6" translate="yes" xml:space="preserve">
          <source>In the properties panel, select the material tab.</source>
          <target state="translated">속성 패널에서 재료 탭을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="e3f84a9ff267abb577cc935f6add6f080297c590" translate="yes" xml:space="preserve">
          <source>In the properties panel, select the modifiers tab.</source>
          <target state="translated">속성 패널에서 수정 자 탭을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="c4a5f9e89da640948f69456d909fb4d55bf31b7e" translate="yes" xml:space="preserve">
          <source>In the property editor of Visual Studio we can modify the properties of our controls - &lt;a href=&quot;qpushbutton&quot;&gt;QPushButton&lt;/a&gt; exposes the &lt;code&gt;QWidget&lt;/code&gt; API and has many properties, while QAxWidget2 has only the Visual Studio standard properties in addition to its own property &quot;lineWidth&quot; in the &quot;Miscellaneous&quot; category. The objects are named &quot;axQPushButton1&quot; and &quot;axQAxWidget21&quot;, and since especially the last name is a bit confusing we rename the objects to &quot;resetButton&quot; and &quot;circleWidget&quot;.</source>
          <target state="translated">Visual Studio의 속성 편집기에서 컨트롤의 속성을 수정할 수 있습니다. &lt;a href=&quot;qpushbutton&quot;&gt;QPushButton&lt;/a&gt; 은 &lt;code&gt;QWidget&lt;/code&gt; API를 노출하고 많은 속성을 가지고있는 반면 QAxWidget2는 &quot;기타&quot;범주의 &quot;lineWidth&quot;속성 외에 Visual Studio 표준 속성 만 가지고 있습니다. . 개체 이름은 &quot;axQPushButton1&quot;및 &quot;axQAxWidget21&quot;이며 특히 성은 약간 혼동되므로 개체 이름을 &quot;resetButton&quot;및 &quot;circleWidget&quot;으로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="c0b81292a316bfa3aac884a259c2bc9cdfb2c8aa" translate="yes" xml:space="preserve">
          <source>In the rare case of a date that was entirely skipped (this happens when a zone east of the international date-line switches to being west of it), the return shall be invalid. Passing &lt;a href=&quot;qt#TimeSpec-enum&quot;&gt;Qt::TimeZone&lt;/a&gt; as</source>
          <target state="translated">드물게 날짜를 완전히 건너 뛴 경우 (국제 날짜 표시 줄의 동쪽 영역이 서쪽으로 전환되는 경우 발생) 반환은 무효가됩니다. 전달 &lt;a href=&quot;qt#TimeSpec-enum&quot;&gt;Qt는 :: 시간대를&lt;/a&gt; 로</target>
        </trans-unit>
        <trans-unit id="e477cd86bad09a09c16dec5ba813622fdbb4a44c" translate="yes" xml:space="preserve">
          <source>In the row delegate you have access to the following special properties:</source>
          <target state="translated">행 대리자에서 다음과 같은 특수 속성에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="801210748fb4e2e33b01b46d33a3b7b73d92c752" translate="yes" xml:space="preserve">
          <source>In the same manner, &lt;a href=&quot;qml-qtquick-controls2-spinbox&quot;&gt;SpinBox&lt;/a&gt; can be customized to accept floating point numbers:</source>
          <target state="translated">같은 방식으로 &lt;a href=&quot;qml-qtquick-controls2-spinbox&quot;&gt;SpinBox&lt;/a&gt; 는 부동 소수점 숫자를 허용하도록 사용자 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b227c5efb22ef0f2410b42cf14130672e8c6ba3f" translate="yes" xml:space="preserve">
          <source>In the same manner, SpinBox can be customized to accept floating point numbers:</source>
          <target state="translated">같은 방식으로 SpinBox를 사용자 정의하여 부동 소수점 숫자를 허용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e4cfdf9c5fb054c03b6216a6d300c49b3e804f04" translate="yes" xml:space="preserve">
          <source>In the section about &lt;a href=&quot;#wildcards-in-name-tests&quot;&gt;using wildcards in name tests&lt;/a&gt;, we saw three simple example XQueries, each of which selected a different list of XML attributes from the cookbook. We couldn't use &lt;code&gt;xmlpatterns&lt;/code&gt; to run these queries, however, because &lt;code&gt;xmlpatterns&lt;/code&gt; sends the &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt; results to a &lt;a href=&quot;qxmlserializer&quot;&gt;serializer&lt;/a&gt;, which expects to serialize the results as well-formed XML. Since a list of XML attributes by itself is not well-formed XML, the serializer reported an error for each &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#wildcards-in-name-tests&quot;&gt;이름 테스트에서 와일드 카드 사용&lt;/a&gt; 에 관한 섹션 에서 우리는 요리 책에서 다른 XML 속성 목록을 선택한 세 가지 간단한 XQueries 예제를 보았습니다. 그러나 &lt;code&gt;xmlpatterns&lt;/code&gt; 를 사용 하여 이러한 쿼리를 실행할 수 없었 습니다. &lt;code&gt;xmlpatterns&lt;/code&gt; 는 &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt; 결과를 &lt;a href=&quot;qxmlserializer&quot;&gt;serializer로&lt;/a&gt; 전송 하므로 결과는 올바른 형식의 XML로 직렬화 될 것으로 예상됩니다. XML 속성 자체는 제대로 구성된 XML이 아니므로 serializer는 각 &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt; 에 대해 오류를보고했습니다 .</target>
        </trans-unit>
        <trans-unit id="5a128015a674ebe1abbeba2144e6cc34dfe2d46d" translate="yes" xml:space="preserve">
          <source>In the section about &lt;a href=&quot;xquery-introduction#wildcards-in-name-tests&quot;&gt;using wildcards in name tests&lt;/a&gt;, we saw three simple example XQueries, each of which selected a different list of XML attributes from the cookbook. We couldn't use &lt;code&gt;xmlpatterns&lt;/code&gt; to run these queries, however, because &lt;code&gt;xmlpatterns&lt;/code&gt; sends the &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt; results to a &lt;a href=&quot;qxmlserializer&quot;&gt;serializer&lt;/a&gt;, which expects to serialize the results as well-formed XML. Since a list of XML attributes by itself is not well-formed XML, the serializer reported an error for each &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;xquery-introduction#wildcards-in-name-tests&quot;&gt;이름 tests에서 와일드 카드를 사용&lt;/a&gt; 하는 방법에 대한 섹션 에서 세 가지 간단한 예제 XQueries를 보았습니다. 각각은 요리 책에서 다른 XML 속성 목록을 선택했습니다. 그러나 &lt;code&gt;xmlpatterns&lt;/code&gt; 는 &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt; 결과를 올바른 형식의 XML로 직렬화 할 것으로 예상 하는 &lt;a href=&quot;qxmlserializer&quot;&gt;serializer로&lt;/a&gt; 보내기 때문에 &lt;code&gt;xmlpatterns&lt;/code&gt; 를 사용 하여 이러한 쿼리를 실행할 수 없습니다 . XML 속성 목록 자체는 올바른 형식의 XML이 아니기 때문에 serializer가 각 &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt; 에 대해 오류를보고했습니다 .</target>
        </trans-unit>
        <trans-unit id="3375442e852a098b37b733339d4e20adf3b09f02" translate="yes" xml:space="preserve">
          <source>In the simplest case, the target of a drag and drop action receives a copy of the data being dragged, and the source decides whether to delete the original. This is described by the &lt;code&gt;CopyAction&lt;/code&gt; action. The target may also choose to handle other actions, specifically the &lt;code&gt;MoveAction&lt;/code&gt; and &lt;code&gt;LinkAction&lt;/code&gt; actions. If the source calls &lt;a href=&quot;qdrag#exec&quot;&gt;QDrag::exec&lt;/a&gt;(), and it returns &lt;code&gt;MoveAction&lt;/code&gt;, the source is responsible for deleting any original data if it chooses to do so. The &lt;a href=&quot;qmimedata&quot;&gt;QMimeData&lt;/a&gt; and &lt;a href=&quot;qdrag&quot;&gt;QDrag&lt;/a&gt; objects created by the source widget</source>
          <target state="translated">가장 간단한 경우, 끌어서 놓기 조치의 대상은 끌고있는 데이터의 사본을 수신하고 원본은 원본을 삭제할지 여부를 결정합니다. 이것은 &lt;code&gt;CopyAction&lt;/code&gt; 조치에 의해 설명됩니다 . 대상은 다른 작업, 특히 &lt;code&gt;MoveAction&lt;/code&gt; 및 &lt;code&gt;LinkAction&lt;/code&gt; 작업 을 처리하도록 선택할 수도 있습니다 . 소스가 &lt;a href=&quot;qdrag#exec&quot;&gt;QDrag :: exec&lt;/a&gt; ()를 호출 하고 &lt;code&gt;MoveAction&lt;/code&gt; 을 반환 하면 소스는 원할 경우 원본 데이터를 삭제해야합니다. &lt;a href=&quot;qmimedata&quot;&gt;QMimeData&lt;/a&gt; 및 &lt;a href=&quot;qdrag&quot;&gt;QDrag은&lt;/a&gt; 소스 위젯에 의해 생성 된 오브젝트</target>
        </trans-unit>
        <trans-unit id="62eff399bf62cee712f1205397f622c033ee20a2" translate="yes" xml:space="preserve">
          <source>In the snippet above, &lt;code&gt;index&lt;/code&gt; is the same for the entire call. This means that accessing to the necessary data structures in order to retrieve the information for &lt;code&gt;index&lt;/code&gt; can be done only once (hoisting the relevant code out of the loop).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2254b056bbcad6f18a38091e4bbdf3abbd41041c" translate="yes" xml:space="preserve">
          <source>In the snippet above, the following occurs with the executable &lt;code&gt;myapp&lt;/code&gt;:</source>
          <target state="translated">위의 스 니펫에서 &lt;code&gt;myapp&lt;/code&gt; 실행 파일에서 다음이 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="4b9cd544023cebfc582b57171a486c13536f9da2" translate="yes" xml:space="preserve">
          <source>In the snippet below, the Rectangle on the left has transparent borders and has blurred edges, whereas the Rectangle on the right does not.</source>
          <target state="translated">아래 스 니펫에서 왼쪽의 사각형에는 투명한 테두리가 있고 가장자리가 흐려지는 반면 오른쪽의 사각형은 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b928f56f82db0d1d484f603348dff5be3a155807" translate="yes" xml:space="preserve">
          <source>In the snippet below, the search model has been assigned to the &lt;a href=&quot;qml-qtquick-listview&quot;&gt;ListView&lt;/a&gt;'s &lt;a href=&quot;qml-qtquick-listview#model-prop&quot;&gt;model&lt;/a&gt; property. When the model is updated with new results, the &lt;a href=&quot;qml-qtquick-listview&quot;&gt;ListView&lt;/a&gt; is automatically updated to reflect the model's new data items.</source>
          <target state="translated">아래 스 니펫에서 검색 모델이 &lt;a href=&quot;qml-qtquick-listview&quot;&gt;ListView&lt;/a&gt; 의 &lt;a href=&quot;qml-qtquick-listview#model-prop&quot;&gt;모델&lt;/a&gt; 속성 에 할당되었습니다 . 모델이 새 결과로 업데이트되면 모델의 새 데이터 항목을 반영하도록 &lt;a href=&quot;qml-qtquick-listview&quot;&gt;ListView&lt;/a&gt; 가 자동으로 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="96fd8a43e0a0a576fc00481b0e03bef2707b6cc0" translate="yes" xml:space="preserve">
          <source>In the snippet we see that the [QML]{&lt;a href=&quot;qml-qtlocation-geocodemodel&quot;&gt;GeocodeModel&lt;/a&gt;} contains the plugin and two signal handlers. One for changes in status &lt;a href=&quot;qml-qtlocation-geocodemodel#status-prop&quot;&gt;&lt;code&gt;onStatusChanged&lt;/code&gt;&lt;/a&gt; and the other to update the centering of the Map object &lt;a href=&quot;qml-qtlocation-geocodemodel#locationsChanged-signal&quot;&gt;&lt;code&gt;onLocationsChanged&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">스 니펫에서 [QML] { &lt;a href=&quot;qml-qtlocation-geocodemodel&quot;&gt;GeocodeModel&lt;/a&gt; }에 플러그인과 두 개의 신호 핸들러가 포함되어 있음을 알 수 있습니다. 하나는 &lt;a href=&quot;qml-qtlocation-geocodemodel#status-prop&quot;&gt; &lt;code&gt;onStatusChanged&lt;/code&gt; &lt;/a&gt; 상태 변경을위한 것이고 다른 하나는 &lt;a href=&quot;qml-qtlocation-geocodemodel#locationsChanged-signal&quot;&gt; &lt;code&gt;onLocationsChanged&lt;/code&gt; &lt;/a&gt; 지도 객체의 중심을 업데이트하기 위한 것 입니다.</target>
        </trans-unit>
        <trans-unit id="989abc71adb9a757a2b4a71aa1947dc82bb1a16f" translate="yes" xml:space="preserve">
          <source>In the special case where an Affector has no possible effect (e.g. Affector {}), this signal will be emitted for all particles being considered if you connect to it. This allows you to execute arbitrary code in response to particles (use the Affector::onAffectParticles signal handler if you want to execute code which affects the particles themselves). As this executes JavaScript code per particle, it is not recommended to use this signal with a high-volume particle system.</source>
          <target state="translated">Affector에 영향을 미치지 않는 특수한 경우 (예 : Affector {}),이 신호는 연결하면 고려중인 모든 입자에 대해 방출됩니다. 파티클에 대한 응답으로 임의 코드를 실행할 수 있습니다 (파티클 자체에 영향을 미치는 코드를 실행하려면 Affector :: onAffectParticles 신호 처리기 사용). 파티클 당 JavaScript 코드를 실행하므로이 신호를 대용량 파티클 시스템과 함께 사용하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="d66ae85ea2294c0c19f4823ddc222eaff12c166a" translate="yes" xml:space="preserve">
          <source>In the specified directories, QDoc will only read the files with the &lt;code&gt;fileextensions&lt;/code&gt; specified in the &lt;a href=&quot;#headers-fileextensions&quot;&gt;&lt;code&gt;headers.fileextensions&lt;/code&gt;&lt;/a&gt; variable. The default extensions are *.ch, *.h, *.h++, *.hh, *.hpp, and *.hxx&quot;. The files specified by &lt;a href=&quot;#headers&quot;&gt;&lt;code&gt;headers&lt;/code&gt;&lt;/a&gt; will be read without taking into account their fileextensions.</source>
          <target state="translated">지정된 디렉토리에서, QDOC 만에 파일을 읽을 &lt;code&gt;fileextensions&lt;/code&gt; 에 지정된 &lt;a href=&quot;#headers-fileextensions&quot;&gt; &lt;code&gt;headers.fileextensions&lt;/code&gt; 의&lt;/a&gt; 변수를. 기본 확장자는 * .ch, * .h, * .h ++, * .hh, * .hpp 및 * .hxx &quot;입니다. &lt;a href=&quot;#headers&quot;&gt; &lt;code&gt;headers&lt;/code&gt; &lt;/a&gt; 지정된 파일은 파일 확장자를 고려하지 않고 읽습니다.</target>
        </trans-unit>
        <trans-unit id="5f1d82693b5802f23c8c35ee835e2826f2e77081" translate="yes" xml:space="preserve">
          <source>In the specified directories, QDoc will only read the files with the &lt;code&gt;fileextensions&lt;/code&gt; specified in the &lt;a href=&quot;#sources-fileextensions&quot;&gt;&lt;code&gt;sources.fileextensions&lt;/code&gt;&lt;/a&gt; variable. The default extensions are *.c++, *.cc, *.cpp and *.cxx. The files specified by &lt;a href=&quot;#sources&quot;&gt;&lt;code&gt;sources&lt;/code&gt;&lt;/a&gt; will be read independent of their fileextensions.</source>
          <target state="translated">지정된 디렉토리에서, QDOC 만에 파일을 읽을 &lt;code&gt;fileextensions&lt;/code&gt; 을 에 지정된 &lt;a href=&quot;#sources-fileextensions&quot;&gt; &lt;code&gt;sources.fileextensions&lt;/code&gt; 의&lt;/a&gt; 변수를. 기본 확장자는 * .c ++, * .cc, * .cpp 및 * .cxx입니다. &lt;a href=&quot;#sources&quot;&gt; &lt;code&gt;sources&lt;/code&gt; &lt;/a&gt; 지정된 파일은 파일 확장자와 독립적으로 읽 힙니다.</target>
        </trans-unit>
        <trans-unit id="056fdd9f20b3fc01c1122801f4ecdae7833b86a9" translate="yes" xml:space="preserve">
          <source>In the specified directories, QDoc will only read the files with the &lt;code&gt;fileextensions&lt;/code&gt; specified in the &lt;a href=&quot;22-qdoc-configuration-generalvariables#headers-fileextensions&quot;&gt;&lt;code&gt;headers.fileextensions&lt;/code&gt;&lt;/a&gt; variable. The default extensions are *.ch, *.h, *.h++, *.hh, *.hpp, and *.hxx&quot;. The files specified by &lt;a href=&quot;22-qdoc-configuration-generalvariables#headers&quot;&gt;&lt;code&gt;headers&lt;/code&gt;&lt;/a&gt; will be read without taking into account their fileextensions.</source>
          <target state="translated">지정된 디렉토리에서, QDOC 만에 파일을 읽을 &lt;code&gt;fileextensions&lt;/code&gt; 에 지정된 &lt;a href=&quot;22-qdoc-configuration-generalvariables#headers-fileextensions&quot;&gt; &lt;code&gt;headers.fileextensions&lt;/code&gt; 의&lt;/a&gt; 변수를. 기본 확장자는 * .ch, * .h, * .h ++, * .hh, * .hpp 및 * .hxx &quot;입니다. &lt;a href=&quot;22-qdoc-configuration-generalvariables#headers&quot;&gt; &lt;code&gt;headers&lt;/code&gt; &lt;/a&gt; 지정된 파일은 파일 확장자를 고려하지 않고 읽 힙니다.</target>
        </trans-unit>
        <trans-unit id="6151ef08358a2f0dd0f4bce198cfa260d7a12f83" translate="yes" xml:space="preserve">
          <source>In the specified directories, QDoc will only read the files with the &lt;code&gt;fileextensions&lt;/code&gt; specified in the &lt;a href=&quot;22-qdoc-configuration-generalvariables#sources-fileextensions&quot;&gt;&lt;code&gt;sources.fileextensions&lt;/code&gt;&lt;/a&gt; variable. The default extensions are *.c++, *.cc, *.cpp and *.cxx. The files specified by &lt;a href=&quot;22-qdoc-configuration-generalvariables#sources&quot;&gt;&lt;code&gt;sources&lt;/code&gt;&lt;/a&gt; will be read independent of their fileextensions.</source>
          <target state="translated">지정된 디렉토리에서, QDOC 만에 파일을 읽을 &lt;code&gt;fileextensions&lt;/code&gt; 에 지정된 &lt;a href=&quot;22-qdoc-configuration-generalvariables#sources-fileextensions&quot;&gt; &lt;code&gt;sources.fileextensions&lt;/code&gt; 의&lt;/a&gt; 변수를. 기본 확장자는 * .c ++, * .cc, * .cpp 및 * .cxx입니다. &lt;a href=&quot;22-qdoc-configuration-generalvariables#sources&quot;&gt; &lt;code&gt;sources&lt;/code&gt; &lt;/a&gt; 의해 지정된 파일은 파일 확장자에 관계없이 읽 힙니다.</target>
        </trans-unit>
        <trans-unit id="40ee7dde22903ab927cdf7620a9752a18131af59" translate="yes" xml:space="preserve">
          <source>In the standard case, the alpha channel is ignored and a fully opaque image is created (typically of format &lt;a href=&quot;qimage#Format-enum&quot;&gt;QImage::Format_RGB32&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb199f938c6665059b05a219c1f50caa25100d21" translate="yes" xml:space="preserve">
          <source>In the style structure tree, we also include &lt;a href=&quot;qmenu&quot;&gt;QMenu&lt;/a&gt; as it also does styling related work. The bounding rectangles of menu items are calculated for the menu's size hint and when the menu is displayed or resized.</source>
          <target state="translated">스타일 구조 트리 에는 스타일 관련 작업도 수행하므로 &lt;a href=&quot;qmenu&quot;&gt;QMenu&lt;/a&gt; 도 포함됩니다 . 메뉴 항목의 경계 사각형은 메뉴의 크기 힌트 및 메뉴가 표시되거나 크기가 조정될 때 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="8e458fb9d3f3f7da311ceeabb2595a4265cb5e04" translate="yes" xml:space="preserve">
          <source>In the table above, &lt;code&gt;&amp;lt;APPNAME&amp;gt;&lt;/code&gt; is usually the organization name, the application name, or both, or a unique name generated at packaging. Similarly, &amp;lt;APPROOT&amp;gt; is the location where this application is installed (often a sandbox). &amp;lt;APPDIR&amp;gt; is the directory containing the application executable.</source>
          <target state="translated">위 표에서 &lt;code&gt;&amp;lt;APPNAME&amp;gt;&lt;/code&gt; 은 일반적으로 조직 이름, 응용 프로그램 이름 또는 둘 다 또는 패키징시 생성 된 고유 이름입니다. 마찬가지로 &amp;lt;APPROOT&amp;gt;은이 응용 프로그램이 설치된 위치 (종종 샌드 박스)입니다. &amp;lt;APPDIR&amp;gt;은 응용 프로그램 실행 파일이 들어있는 디렉토리입니다.</target>
        </trans-unit>
        <trans-unit id="cf5f7ca52e42eebde54614781228fa2e1a26817d" translate="yes" xml:space="preserve">
          <source>In the table, &quot;Amort.&quot; stands for &quot;amortized behavior&quot;. For example, &quot;Amort. O(1)&quot; means that if you call the function only once, you might get O(</source>
          <target state="translated">표에서 &quot;Amort&quot; &quot;암시 된 행동&quot;을 나타냅니다. 예를 들어 &quot;Amort. O (1)&quot;은 함수를 한 번만 호출하면 O (</target>
        </trans-unit>
        <trans-unit id="b40fb8aac34cbe6100c7335e6381c93eebb9d63a" translate="yes" xml:space="preserve">
          <source>In the world of &lt;a href=&quot;qtquick-index&quot;&gt;QML&lt;/a&gt;, there are additional entities we need to document such as QML signals, attached properties, and QML methods. Internally, they use Qt technologies, however, QML API documentation requires different layout and naming conventions from the Qt C++ API documentation.</source>
          <target state="translated">세계에서 &lt;a href=&quot;qtquick-index&quot;&gt;QML&lt;/a&gt; QML 신호, 첨부 된 속성 및 QML 메소드와 같이 문서화해야 할 추가 엔티티가 있습니다. 내부적으로 Qt 기술을 사용하지만 QML API 설명서에는 Qt C ++ API 설명서와 다른 레이아웃 및 명명 규칙이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="1aa8717ef358ec50a15dea47b01dc1443cd08e34" translate="yes" xml:space="preserve">
          <source>In theory this would allow running your application on every single macOS version released, but for practical (and technical) reasons there is a lower limit to this range, known as the</source>
          <target state="translated">이론적으로 이것은 출시 된 모든 단일 macOS 버전에서 응용 프로그램을 실행할 수 있지만, 실용적 (기술적) 이유로이 범위에는 하한이 있습니다.</target>
        </trans-unit>
        <trans-unit id="255207de917da7fa96bb3e4dfe04909f6d3feaad" translate="yes" xml:space="preserve">
          <source>In these examples, the comments will be associated with the strings passed to tr() in the context of each call.</source>
          <target state="translated">이 예제에서 주석은 각 호출의 컨텍스트에서 tr ()에 전달 된 문자열과 연관됩니다.</target>
        </trans-unit>
        <trans-unit id="859a3deb5ba0f625fda298b3e50025df3ff51021" translate="yes" xml:space="preserve">
          <source>In this approach, we subclass a Qt widget and set up the user interface from within the constructor. Components used in this way expose the widgets and layouts used in the form to the Qt widget subclass, and provide a standard system for making signal and slot connections between the user interface and other objects in your application. The generated &lt;code&gt;Ui::CalculatorForm&lt;/code&gt; structure is a member of the class.</source>
          <target state="translated">이 접근법에서는 Qt 위젯을 서브 클래 싱하고 생성자 내에서 사용자 인터페이스를 설정합니다. 이러한 방식으로 사용되는 컴포넌트는 폼에서 사용 된 위젯과 레이아웃을 Qt 위젯 서브 클래스에 노출하고 사용자 인터페이스와 애플리케이션의 다른 객체 사이에 신호 및 슬롯 연결을위한 표준 시스템을 제공합니다. 생성 된 &lt;code&gt;Ui::CalculatorForm&lt;/code&gt; 구조는 클래스의 멤버입니다.</target>
        </trans-unit>
        <trans-unit id="362c94c7e88772e9d32d521fb79b74f48ba4533c" translate="yes" xml:space="preserve">
          <source>In this case the -D option ensures that the &lt;code&gt;consoleedition&lt;/code&gt; preprocessor symbol is defined when QDoc processes the source files defined in the qtgui.qdocconf file.</source>
          <target state="translated">이 경우 -D 옵션은 &lt;code&gt;consoleedition&lt;/code&gt; 이 qtgui.qdocconf 파일에 정의 된 소스 파일을 처리 할 때 consoleedition 프리 프로세서 기호가 정의되도록합니다.</target>
        </trans-unit>
        <trans-unit id="d5bc21bdf3a5bc63ec2e556ed0988ffbfff9bbfd" translate="yes" xml:space="preserve">
          <source>In this case the -D option ensures that the &lt;code&gt;qtforpython&lt;/code&gt; preprocessor symbol is defined when QDoc processes the source files defined in the qtgui.qdocconf file.</source>
          <target state="translated">이 경우 -D 옵션은 &lt;code&gt;qtforpython&lt;/code&gt; 이 qtgui.qdocconf 파일에 정의 된 소스 파일을 처리 할 때 qtforpython 전 처리기 기호가 정의되도록합니다.</target>
        </trans-unit>
        <trans-unit id="6dbc7ebb89b91db904e7a322a6d918545a6d30a2" translate="yes" xml:space="preserve">
          <source>In this case the content size of the &lt;a href=&quot;qml-qtquick-controls-scrollview&quot;&gt;ScrollView&lt;/a&gt; will simply mirror that of its contained &lt;a href=&quot;qml-qtquick-controls-scrollview#flickableItem-prop&quot;&gt;flickableItem&lt;/a&gt;.</source>
          <target state="translated">이 경우 &lt;a href=&quot;qml-qtquick-controls-scrollview&quot;&gt;ScrollView&lt;/a&gt; 의 내용 크기 는 포함 &lt;a href=&quot;qml-qtquick-controls-scrollview#flickableItem-prop&quot;&gt;된 flickableItem&lt;/a&gt; 의 내용 크기를 미러링합니다 .</target>
        </trans-unit>
        <trans-unit id="f138d863bd31fe2ee9a4b0dd602baa3a5349ea12" translate="yes" xml:space="preserve">
          <source>In this case the content size of the ScrollView will simply mirror that of its contained &lt;a href=&quot;qml-qtquick-controls-scrollview#flickableItem-prop&quot;&gt;flickableItem&lt;/a&gt;.</source>
          <target state="translated">이 경우 ScrollView의 콘텐츠 크기는 포함 &lt;a href=&quot;qml-qtquick-controls-scrollview#flickableItem-prop&quot;&gt;된 flickableItem&lt;/a&gt; 의 크기를 단순히 미러링합니다 .</target>
        </trans-unit>
        <trans-unit id="54fdfbf35158389fca9671272bd410b6866e806d" translate="yes" xml:space="preserve">
          <source>In this case the events will occur in the following way:</source>
          <target state="translated">이 경우 이벤트는 다음과 같은 방식으로 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1b4ea093b00f035470dcb0bcfe53e07e95f4ad32" translate="yes" xml:space="preserve">
          <source>In this case the whole chain of continuations will be interrupted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69c2a3e1849c296af6d0417f143fe71be3f75d05" translate="yes" xml:space="preserve">
          <source>In this case we chose &lt;code&gt;8&lt;/code&gt; pixel margins, so we set the &lt;code&gt;implicitWidth&lt;/code&gt; of the tickmarks to that.</source>
          <target state="translated">이 경우 &lt;code&gt;8&lt;/code&gt; 픽셀 여백 을 선택 했으므로 틱 마크 의 &lt;code&gt;implicitWidth&lt;/code&gt; 너비를 설정했습니다.</target>
        </trans-unit>
        <trans-unit id="d96e23997fff4df9e9731671989278a1f195855e" translate="yes" xml:space="preserve">
          <source>In this case we want the application to quit when the state machine is finished, so the machine's</source>
          <target state="translated">이 경우 상태 머신이 완료되면 애플리케이션이 종료되기를 원하므로 머신은</target>
        </trans-unit>
        <trans-unit id="e1b975488490d31b42113087f62327369de204d0" translate="yes" xml:space="preserve">
          <source>In this case we want the application to quit when the state machine is finished, so the machine's &lt;a href=&quot;qstate#finished&quot;&gt;finished()&lt;/a&gt; signal is connected to the application's &lt;a href=&quot;qcoreapplication#quit&quot;&gt;quit()&lt;/a&gt; slot.</source>
          <target state="translated">이 경우 상태 머신이 완료되면 애플리케이션이 종료되기를 원하므로 머신의 &lt;a href=&quot;qstate#finished&quot;&gt;finished ()&lt;/a&gt; 신호가 애플리케이션의 &lt;a href=&quot;qcoreapplication#quit&quot;&gt;quit ()&lt;/a&gt; 슬롯에 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="fb3ffe58383d7277d71ec72c56b71b5ccdb59e72" translate="yes" xml:space="preserve">
          <source>In this case, &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;'s internal data will be generated at compile time; no conversion or allocation will occur at runtime.</source>
          <target state="translated">이 경우 &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; 의 내부 데이터는 컴파일 타임에 생성됩니다. 런타임에는 변환이나 할당이 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b7b16fee52137c726210b352bd2a3513af71290f" translate="yes" xml:space="preserve">
          <source>In this case, Pane cannot calculate a sensible implicit size. Since we're anchoring the &lt;a href=&quot;qml-qtquick-controls2-pageindicator&quot;&gt;PageIndicator&lt;/a&gt; over the &lt;a href=&quot;qml-qtquick-controls2-swipeview&quot;&gt;SwipeView&lt;/a&gt;, we can simply set the content size to the view's implicit size:</source>
          <target state="translated">이 경우 분할 창은 적절한 암시 적 크기를 계산할 수 없습니다. 우리는 고정하고 있기 때문에 &lt;a href=&quot;qml-qtquick-controls2-pageindicator&quot;&gt;PageIndicator&lt;/a&gt; 오버 &lt;a href=&quot;qml-qtquick-controls2-swipeview&quot;&gt;SwipeView을&lt;/a&gt; , 우리는 단순히 뷰의 암시 크기로 컨텐츠 크기를 설정할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="0c14340d72a02580e23a64a2b4670ce106e45f16" translate="yes" xml:space="preserve">
          <source>In this case, Popup cannot calculate a sensible implicit size. Since we're anchoring the &lt;a href=&quot;qml-qtquick-controls2-pageindicator&quot;&gt;PageIndicator&lt;/a&gt; over the &lt;a href=&quot;qml-qtquick-controls2-swipeview&quot;&gt;SwipeView&lt;/a&gt;, we can simply set the content size to the view's implicit size:</source>
          <target state="translated">이 경우 Popup은 적절한 암시 적 크기를 계산할 수 없습니다. 우리는 고정하고 있기 때문에 &lt;a href=&quot;qml-qtquick-controls2-pageindicator&quot;&gt;PageIndicator&lt;/a&gt; 오버 &lt;a href=&quot;qml-qtquick-controls2-swipeview&quot;&gt;SwipeView을&lt;/a&gt; , 우리는 단순히 뷰의 암시 크기로 컨텐츠 크기를 설정할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="55d2bd1f24a4bc5b8d4a75b8ac6bd6239d493a88" translate="yes" xml:space="preserve">
          <source>In this case, a margin of 5 pixels is reserved to the left of</source>
          <target state="translated">이 경우 왼쪽에 5 픽셀의 여백이 예약됩니다.</target>
        </trans-unit>
        <trans-unit id="2559699cff65ead711a811fd8cb59e14e6e11bff" translate="yes" xml:space="preserve">
          <source>In this case, create the correct wrapper class explicitly:</source>
          <target state="translated">이 경우 올바른 래퍼 클래스를 명시 적으로 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="d72df5d9857db08c85e9d865105471fa46d122b7" translate="yes" xml:space="preserve">
          <source>In this case, instead of:</source>
          <target state="translated">이 경우 다음 대신 :</target>
        </trans-unit>
        <trans-unit id="d44d0c003d379650806aa61e32500800e5f47f98" translate="yes" xml:space="preserve">
          <source>In this case, it may help to register the server as Administrator.</source>
          <target state="translated">이 경우 서버를 관리자로 등록하는 것이 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4de0ffe19fb979ad27b3dd71c09d8ee90acf5a96" translate="yes" xml:space="preserve">
          <source>In this case, the &lt;code&gt;Ui::CalculatorForm&lt;/code&gt; is an interface description object from the &lt;code&gt;ui_calculatorform.h&lt;/code&gt; file that sets up all the dialog's widgets and the connections between its signals and slots.</source>
          <target state="translated">이 경우 &lt;code&gt;Ui::CalculatorForm&lt;/code&gt; 은 모든 대화 상자 위젯과 해당 신호와 슬롯 간의 연결을 설정 하는 &lt;code&gt;ui_calculatorform.h&lt;/code&gt; 파일 의 인터페이스 설명 객체입니다 .</target>
        </trans-unit>
        <trans-unit id="761305134fb58163fb1211cb04e3a83c4da88d12" translate="yes" xml:space="preserve">
          <source>In this case, the QQuickWindow represents the scene, and provides the intrastructure for rendering a frame. It will not be backed by a render loop and a native window. Instead, in this case the application drives rendering, effectively substituting for the render loops. This allows generating image sequences, rendering into textures for use in external 3D engines, or rendering Qt Quick content within a VR environment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="557cb66c99ce847b1304ea0d2bca926ea7fa7f82" translate="yes" xml:space="preserve">
          <source>In this case, the Text item will be created in the engine's &lt;a href=&quot;qqmlengine#rootContext&quot;&gt;root context&lt;/a&gt;.</source>
          <target state="translated">이 경우 텍스트 항목은 엔진의 &lt;a href=&quot;qqmlengine#rootContext&quot;&gt;루트 컨텍스트&lt;/a&gt; 에서 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="c2fe0b85a97ec0c6f60af5b8b7ab7d0828ea2f99" translate="yes" xml:space="preserve">
          <source>In this case, the content on the display connected via DisplayPort will be the same as on the HDMI one. This is ensured by scanning out the same buffer on both.</source>
          <target state="translated">이 경우 DisplayPort를 통해 연결된 디스플레이의 콘텐츠는 HDMI 콘텐츠와 동일합니다. 이것은 둘 다에서 동일한 버퍼를 스캔함으로써 보장됩니다.</target>
        </trans-unit>
        <trans-unit id="335f5842e550058035279d36d68ce4217c4bd258" translate="yes" xml:space="preserve">
          <source>In this case, the default font query will be used with no modifications (so font size, for instance, will be the system default).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5093c104f6dbd51736a8187dd3bd4b0f6b1d9d6c" translate="yes" xml:space="preserve">
          <source>In this case, the engine will emit an error and refuse to load the file.</source>
          <target state="translated">이 경우 엔진에서 오류가 발생하고 파일로드를 거부합니다.</target>
        </trans-unit>
        <trans-unit id="6e9923736f41d1c99c5ade89166c3d1e07ec481f" translate="yes" xml:space="preserve">
          <source>In this case, the file is accessible as &lt;code&gt;:/myresources/cut-img.png&lt;/code&gt;.</source>
          <target state="translated">이 경우 파일은 &lt;code&gt;:/myresources/cut-img.png&lt;/code&gt; 로 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9e4817c64065a76057f86d53f70dd09bfacecc35" translate="yes" xml:space="preserve">
          <source>In this case, the filter attributes</source>
          <target state="translated">이 경우 필터 속성</target>
        </trans-unit>
        <trans-unit id="5db201376463ec4ac414b7caf1047c66a4faa690" translate="yes" xml:space="preserve">
          <source>In this case, the left edge of</source>
          <target state="translated">이 경우 왼쪽 가장자리</target>
        </trans-unit>
        <trans-unit id="f0ead38ce400183da10325a74e03ec2d21aa8a43" translate="yes" xml:space="preserve">
          <source>In this case, the name of the</source>
          <target state="translated">이 경우</target>
        </trans-unit>
        <trans-unit id="9dc83f168232d217b8a040e7b9dd001b4be5feb5" translate="yes" xml:space="preserve">
          <source>In this case, the order of destruction causes a problem. The parent's destructor is called first because it was created last. It then calls the destructor of its child, &lt;code&gt;quit&lt;/code&gt;, which is incorrect because &lt;code&gt;quit&lt;/code&gt; is a local variable. When &lt;code&gt;quit&lt;/code&gt; subsequently goes out of scope, its destructor is called again, this time correctly, but the damage has already been done.</source>
          <target state="translated">이 경우 파괴 순서에 문제가 발생합니다. 부모의 소멸자는 마지막에 생성되었으므로 먼저 소멸됩니다. 그런 다음 &lt;code&gt;quit&lt;/code&gt; 이 로컬 변수 이므로 잘못된 자식 &lt;code&gt;quit&lt;/code&gt; 의 소멸자를 호출합니다 . 시 &lt;code&gt;quit&lt;/code&gt; 이후 범위를 벗어나, 소멸자가 제대로 이번에 다시 호출하지만, 피해는 이미 완료되었습니다.</target>
        </trans-unit>
        <trans-unit id="bf2fce7fc50e346d6aa873ac66e0403499b0f04a" translate="yes" xml:space="preserve">
          <source>In this case, the regular expression engine should report a partial match, so that we can match again adding new data and (eventually) get a complete match. This implies that the regular expression engine may assume that there are other characters</source>
          <target state="translated">이 경우 정규식 엔진은 부분 일치를보고해야 새 데이터를 다시 추가하고 일치하여 (최종적으로) 완전 일치를 얻을 수 있습니다. 이것은 정규 표현식 엔진이 다른 문자가 있다고 가정 할 수 있음을 의미합니다</target>
        </trans-unit>
        <trans-unit id="b6d78751de3cfb23108400a3b33466817569417c" translate="yes" xml:space="preserve">
          <source>In this case, the return value is unimportant; we return an arbitrary value to satisfy the compiler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ec7f7d20357b4785d0506c8b802f3a49cbf18dd" translate="yes" xml:space="preserve">
          <source>In this case, the subpattern &lt;code&gt;abc\\w+X&lt;/code&gt; partially matches the subject string; however, the subpattern &lt;code&gt;def&lt;/code&gt; matches the subject string completely, and therefore a complete match is reported.</source>
          <target state="translated">이 경우 하위 패턴 &lt;code&gt;abc\\w+X&lt;/code&gt; 는 제목 문자열과 부분적으로 일치합니다. 그러나 서브 패턴 &lt;code&gt;def&lt;/code&gt; 는 주제 문자열과 완전히 일치하므로 완전한 일치가보고됩니다.</target>
        </trans-unit>
        <trans-unit id="32e27bbec8f2b28526f2a1647b8241468b8f9d32" translate="yes" xml:space="preserve">
          <source>In this case, the texture interpolation between a fully-transparent pixel and its neighboring somewhat-opaque pixel blends the RGB values between the two. If you use the image editing tool's transparent layers, the RGB values for certain transparent pixels are saved as white, and you will thus see white fringing at the edges of your transparent regions.</source>
          <target state="translated">이 경우 완전히 투명한 픽셀과 인접한 다소 불투명 한 픽셀 사이의 텍스처 보간은 둘 사이의 RGB 값을 혼합합니다. 이미지 편집 도구의 투명 레이어를 사용하는 경우 특정 투명 픽셀의 RGB 값은 흰색으로 저장되므로 투명 영역의 가장자리에 흰색 언저리가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="1621cf0096ee51e3a619b6331b188460f09d0bd5" translate="yes" xml:space="preserve">
          <source>In this case, the widgets used in the user interface can be accessed in the same say as a widget created in code by hand. We no longer require the &lt;code&gt;ui&lt;/code&gt; prefix to access them.</source>
          <target state="translated">이 경우, 사용자 인터페이스에서 사용되는 위젯은 코드에서 직접 작성한 위젯과 같은 방식으로 액세스 할 수 있습니다. 더 이상 &lt;code&gt;ui&lt;/code&gt; 접두사가 필요하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="f75ffd3874db6ea6ce0b615a59236fe8404b4e5d" translate="yes" xml:space="preserve">
          <source>In this case, we accept the proposed action without checking what it is. In a real world application, it may be necessary to return from the &lt;a href=&quot;qwidget#dropEvent&quot;&gt;dropEvent()&lt;/a&gt; function without accepting the proposed action or handling the data if the action is not relevant. For example, we may choose to ignore &lt;a href=&quot;qt#DropAction-enum&quot;&gt;Qt::LinkAction&lt;/a&gt; actions if we do not support links to external sources in our application.</source>
          <target state="translated">이 경우 제안 된 조치가 무엇인지 확인하지 않고 수락합니다. 실제 응용 프로그램에서는 제안 된 작업을 수락하거나 작업이 관련이없는 경우 데이터를 처리하지 않고 &lt;a href=&quot;qwidget#dropEvent&quot;&gt;dropEvent ()&lt;/a&gt; 함수 에서 반환해야 할 수도 있습니다 . 예를 들어, 애플리케이션에서 외부 소스에 대한 링크를 지원하지 않는 경우 &lt;a href=&quot;qt#DropAction-enum&quot;&gt;Qt :: LinkAction&lt;/a&gt; 조치 를 무시하도록 선택할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="12de9c11e19e2cf1aa429067cf7c63431e574ddf" translate="yes" xml:space="preserve">
          <source>In this case, we just use the geometry information provided by the view option in the item rectangle. A delegate that renders items with several elements would not use the item rectangle directly. It would position the editor in relation to the other elements in the item.</source>
          <target state="translated">이 경우 항목 사각형의보기 옵션에서 제공 한 형상 정보 만 사용합니다. 여러 요소가있는 항목을 렌더링하는 대리자는 항목 사각형을 직접 사용하지 않습니다. 항목의 다른 요소와 관련하여 편집기를 배치합니다.</target>
        </trans-unit>
        <trans-unit id="a5b579c1c4a5b92543cefd293a9eb46587cc9a52" translate="yes" xml:space="preserve">
          <source>In this case, we refuse to deal with move operations. Each type of drop action that we accept is checked and dealt with accordingly:</source>
          <target state="translated">이 경우 이동 작업 처리를 거부합니다. 우리가 수락하는 각 드롭 동작 유형을 확인하고 적절하게 처리합니다.</target>
        </trans-unit>
        <trans-unit id="9acf73b8652dc00675062e9a5cb9499c1c12038b" translate="yes" xml:space="preserve">
          <source>In this case, we set up a default &lt;a href=&quot;qfilesystemmodel&quot;&gt;QFileSystemModel&lt;/a&gt;, obtain a parent index using a specific implementation of &lt;a href=&quot;qfilesystemmodel#index&quot;&gt;index()&lt;/a&gt; provided by that model, and we count the number of rows in the model using the &lt;a href=&quot;qfilesystemmodel#rowCount&quot;&gt;rowCount()&lt;/a&gt; function.</source>
          <target state="translated">이 경우 기본 &lt;a href=&quot;qfilesystemmodel&quot;&gt;QFileSystemModel을&lt;/a&gt; 설정하고 해당 모델에서 제공 하는 특정 &lt;a href=&quot;qfilesystemmodel#index&quot;&gt;index ()&lt;/a&gt; 구현을 사용하여 상위 인덱스를 얻은 다음 &lt;a href=&quot;qfilesystemmodel#rowCount&quot;&gt;rowCount ()&lt;/a&gt; 함수를 사용하여 모델의 행 수를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="8343e7cf55f18383906f6a3af0acd82dba14d3f8" translate="yes" xml:space="preserve">
          <source>In this case, we start by setting up a default &lt;a href=&quot;qfilesystemmodel&quot;&gt;QFileSystemModel&lt;/a&gt;. We connect it to a lambda, in which we will obtain a parent index using a specific implementation of &lt;a href=&quot;qfilesystemmodel#index&quot;&gt;index()&lt;/a&gt; provided by that model. In the lambda, we count the number of rows in the model using the &lt;a href=&quot;qfilesystemmodel#rowCount&quot;&gt;rowCount()&lt;/a&gt; function. Finally, we set the root path of the &lt;a href=&quot;qfilesystemmodel&quot;&gt;QFileSystemModel&lt;/a&gt; so it starts loading data and triggers the lambda.</source>
          <target state="translated">이 경우 기본 &lt;a href=&quot;qfilesystemmodel&quot;&gt;QFileSystemModel&lt;/a&gt; 을 설정하여 시작합니다 . 이를 람다에 연결하면 해당 모델에서 제공하는 &lt;a href=&quot;qfilesystemmodel#index&quot;&gt;index ()&lt;/a&gt; 의 특정 구현을 사용하여 부모 인덱스를 얻을 수 있습니다. 람다에서 &lt;a href=&quot;qfilesystemmodel#rowCount&quot;&gt;rowCount ()&lt;/a&gt; 함수를 사용하여 모델의 행 수를 계산합니다 . 마지막으로 &lt;a href=&quot;qfilesystemmodel&quot;&gt;QFileSystemModel&lt;/a&gt; 의 루트 경로를 설정하여 데이터로드를 시작하고 람다를 트리거합니다.</target>
        </trans-unit>
        <trans-unit id="e105cc32dae04734242b23d52e7cc6250dbcb385" translate="yes" xml:space="preserve">
          <source>In this case, when the result of the lookup is ready, the slot or signal &lt;code&gt;function&lt;/code&gt; in &lt;code&gt;receiver&lt;/code&gt; is called with a &lt;a href=&quot;qhostinfo&quot;&gt;QHostInfo&lt;/a&gt; argument. The &lt;a href=&quot;qhostinfo&quot;&gt;QHostInfo&lt;/a&gt; object can then be inspected to get the results of the lookup.</source>
          <target state="translated">조회의 결과가 준비되면,이 경우에있어서, 상기 슬롯 또는 신호 &lt;code&gt;function&lt;/code&gt; 의 &lt;code&gt;receiver&lt;/code&gt; 불려 &lt;a href=&quot;qhostinfo&quot;&gt;QHostInfo의&lt;/a&gt; 인수. 그러면 &lt;a href=&quot;qhostinfo&quot;&gt;QHostInfo&lt;/a&gt; 객체를 검사하여 조회 결과를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c51e900b55884395dfabf713dd789c6e80fbe934" translate="yes" xml:space="preserve">
          <source>In this case, you need to have a sub-project with a &lt;code&gt;lib&lt;/code&gt; template that provides a different executable for the service. A sample project &lt;code&gt;.pro&lt;/code&gt; is:</source>
          <target state="translated">이 경우 서비스에 대해 다른 실행 파일을 제공하는 &lt;code&gt;lib&lt;/code&gt; 템플릿 이있는 하위 프로젝트가 있어야합니다. 샘플 프로젝트 &lt;code&gt;.pro&lt;/code&gt; 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="de22ce1b8b536997974c104fcfaa9f3c17db2579" translate="yes" xml:space="preserve">
          <source>In this chapter, we look at each of the structural elements used in a rich text document, outline their features and uses, and show how to examine their contents. Document editing is described in &lt;a href=&quot;richtext-cursor&quot;&gt;The QTextCursor Interface&lt;/a&gt;.</source>
          <target state="translated">이 장에서는 서식있는 텍스트 문서에 사용 된 각 구조 요소를 살펴보고 그 기능과 용도를 개괄적으로 설명하고 그 내용을 검토하는 방법을 보여줍니다. 문서 편집은 &lt;a href=&quot;richtext-cursor&quot;&gt;QTextCursor 인터페이스에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="2edc8f830b62cce7cad4ec3440f658823ce98aa6" translate="yes" xml:space="preserve">
          <source>In this chapter, we look at each of the structural elements used in a rich text document, outline their features and uses, and show how to examine their contents. Document editing is described in &lt;a href=&quot;richtext-cursor#&quot;&gt;The QTextCursor Interface&lt;/a&gt;.</source>
          <target state="translated">이 장에서는 서식있는 텍스트 문서에 사용 된 각 구조 요소를 살펴보고 해당 기능과 용도를 설명하고 내용을 검사하는 방법을 보여줍니다. 문서 편집은 &lt;a href=&quot;richtext-cursor#&quot;&gt;QTextCursor 인터페이스에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="80c6e171cbf5feee976517b022361c692a20a725" translate="yes" xml:space="preserve">
          <source>In this code sample, we loop through all devices that are able to output sound, i.e., play an audio stream in a supported format. For each device we find, we simply print the &lt;a href=&quot;qaudiodeviceinfo#deviceName&quot;&gt;deviceName&lt;/a&gt;().</source>
          <target state="translated">이 코드 샘플에서는 사운드를 출력 할 수있는 모든 장치 (예 : 지원되는 형식의 오디오 스트림 재생)를 반복합니다. 찾은 각 장치에 대해 간단히 &lt;a href=&quot;qaudiodeviceinfo#deviceName&quot;&gt;deviceName&lt;/a&gt; ()을 인쇄합니다 .</target>
        </trans-unit>
        <trans-unit id="1b5206919f18117e9f9142181c621fe66ea653e5" translate="yes" xml:space="preserve">
          <source>In this context same as Locale.ShortFormat</source>
          <target state="translated">이 컨텍스트에서 Locale.ShortFormat과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="77d00177c82097c5be50486e9ab9d1159a60412b" translate="yes" xml:space="preserve">
          <source>In this discussion, we will concentrate on &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt; and &lt;a href=&quot;qmap&quot;&gt;QMap&lt;/a&gt;. The iterator types for &lt;a href=&quot;qlinkedlist&quot;&gt;QLinkedList&lt;/a&gt;, &lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt;, and &lt;a href=&quot;qset&quot;&gt;QSet&lt;/a&gt; have exactly the same interface as &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt;'s iterators; similarly, the iterator types for &lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt; have the same interface as &lt;a href=&quot;qmap&quot;&gt;QMap&lt;/a&gt;'s iterators.</source>
          <target state="translated">이 토론에서는 &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt; 및 &lt;a href=&quot;qmap&quot;&gt;QMap&lt;/a&gt; 에 중점을 둘 것 입니다. &lt;a href=&quot;qlinkedlist&quot;&gt;QLinkedList&lt;/a&gt; , &lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt; 및 &lt;a href=&quot;qset&quot;&gt;QSet&lt;/a&gt; 의 반복자 유형은 &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt; 의 반복자 와 인터페이스가 동일 합니다. 마찬가지로 &lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt; 의 반복자 유형은 &lt;a href=&quot;qmap&quot;&gt;QMap&lt;/a&gt; 의 반복자 와 동일한 인터페이스를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="5cb0dfba726aef19da406e338c4572e830559fd4" translate="yes" xml:space="preserve">
          <source>In this discussion, we will concentrate on &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt; and &lt;a href=&quot;qmap&quot;&gt;QMap&lt;/a&gt;. The iterator types for &lt;a href=&quot;qset&quot;&gt;QSet&lt;/a&gt; have exactly the same interface as &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt;'s iterators; similarly, the iterator types for &lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt; have the same interface as &lt;a href=&quot;qmap&quot;&gt;QMap&lt;/a&gt;'s iterators.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5c1d5453199ec850f95b3864b16bde1f1033ecc" translate="yes" xml:space="preserve">
          <source>In this discussion, we will concentrate on &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt; and &lt;a href=&quot;qmap&quot;&gt;QMap&lt;/a&gt;. The iterator types for QLinkedList, &lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt;, and &lt;a href=&quot;qset&quot;&gt;QSet&lt;/a&gt; have exactly the same interface as &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt;'s iterators; similarly, the iterator types for &lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt; have the same interface as &lt;a href=&quot;qmap&quot;&gt;QMap&lt;/a&gt;'s iterators.</source>
          <target state="translated">이 토론에서는 &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt; 및 &lt;a href=&quot;qmap&quot;&gt;QMap&lt;/a&gt; 에 집중할 것 입니다. QLinkedList, &lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt; 및 &lt;a href=&quot;qset&quot;&gt;QSet&lt;/a&gt; 의 반복기 유형은 &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt; 의 반복기 와 정확히 동일한 인터페이스를 갖습니다 . 유사하게, &lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt; 의 반복자 유형은 &lt;a href=&quot;qmap&quot;&gt;QMap&lt;/a&gt; 의 반복자 와 동일한 인터페이스를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="c5b9f46acbee65ef19179225693f73e525c0e7d2" translate="yes" xml:space="preserve">
          <source>In this document, we take a custom type and describe how to integrate it into Qt's object model so that it can be stored in the same way as standard Qt types. We then show how to register the custom type to allow it to be used in signals and slots connections.</source>
          <target state="translated">이 문서에서는 커스텀 타입을 가져 와서 표준 Qt 타입과 같은 방식으로 저장할 수 있도록 Qt의 객체 모델에 통합하는 방법을 설명합니다. 그런 다음 신호 및 슬롯 연결에 사용할 수 있도록 사용자 정의 유형을 등록하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="deae06da34c5ea98ed2af81fad213ae5b7bbd837" translate="yes" xml:space="preserve">
          <source>In this example our input lines have the format company name, web address and country. Unfortunately the regexp is rather long and not very versatile -- the code will break if we add any more fields. A simpler and better solution is to look for the separator, '\t' in this case, and take the surrounding text. The &lt;a href=&quot;qstring#split&quot;&gt;QString::split&lt;/a&gt;() function can take a separator string or regexp as an argument and split a string accordingly.</source>
          <target state="translated">이 예에서 입력 라인은 회사 이름, 웹 주소 및 국가 형식을 갖습니다. 불행히도 정규 표현식은 길고 다재다능하지 않습니다. 더 많은 필드를 추가하면 코드가 손상됩니다. 더 간단하고 더 나은 해결책은이 경우 구분 기호 '\ t'를 찾고 주변 텍스트를 취하는 것입니다. &lt;a href=&quot;qstring#split&quot;&gt;QString :: 스플릿&lt;/a&gt; () 함수는 인수로 분리 문자열 또는 정규식을 따라 문자열을 분할 할 수있다.</target>
        </trans-unit>
        <trans-unit id="c68e45ce12232cea0e4433fbb4169154abeebb9d" translate="yes" xml:space="preserve">
          <source>In this example the shortcut is</source>
          <target state="translated">이 예에서 지름길은</target>
        </trans-unit>
        <trans-unit id="fac57de8cb8e27d59e842bd29d3ab7f5e8c83dc4" translate="yes" xml:space="preserve">
          <source>In this example we are demonstrating how to use a &lt;a href=&quot;qml-qtqml-models-listmodel&quot;&gt;ListModel&lt;/a&gt; with a combo box.</source>
          <target state="translated">이 예에서는 콤보 상자와 함께 &lt;a href=&quot;qml-qtqml-models-listmodel&quot;&gt;ListModel&lt;/a&gt; 을 사용하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="93132fdab803388ac80aa961ecde776ae47e6982" translate="yes" xml:space="preserve">
          <source>In this example we are demonstrating how to use a ListModel with a combo box.</source>
          <target state="translated">이 예에서는 콤보 상자와 함께 ListModel을 사용하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="1189e66d8d1010b7362db4792af15820adbb91c5" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;anim1&lt;/code&gt; and &lt;code&gt;anim2&lt;/code&gt; are two &lt;a href=&quot;qpropertyanimation&quot;&gt;QPropertyAnimation&lt;/a&gt;s that have already been set up.</source>
          <target state="translated">이 예제에서 &lt;code&gt;anim1&lt;/code&gt; 과 &lt;code&gt;anim2&lt;/code&gt; 는 이미 설정된 두 개의 &lt;a href=&quot;qpropertyanimation&quot;&gt;QPropertyAnimation&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0e76e3fd9da832a8ce5a7866306c4863e5056d1a" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;anim1&lt;/code&gt; and &lt;code&gt;anim2&lt;/code&gt; are two already set up &lt;a href=&quot;qpropertyanimation&quot;&gt;QPropertyAnimation&lt;/a&gt;s.</source>
          <target state="translated">이 예제에서 &lt;code&gt;anim1&lt;/code&gt; 과 &lt;code&gt;anim2&lt;/code&gt; 는 이미 &lt;a href=&quot;qpropertyanimation&quot;&gt;QPropertyAnimation&lt;/a&gt; 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="b19490627b2544a644d6217034dd7faaa7ea324c" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;p1&lt;/code&gt; and &lt;code&gt;p2&lt;/code&gt; share data until &lt;a href=&quot;qpainter#begin&quot;&gt;QPainter::begin&lt;/a&gt;() is called for &lt;code&gt;p2&lt;/code&gt;, because painting a pixmap will modify it.</source>
          <target state="translated">이 예제에서 &lt;code&gt;p1&lt;/code&gt; 과 &lt;code&gt;p2&lt;/code&gt; 는 pixmap을 페인팅하면 수정하기 때문에 &lt;code&gt;p2&lt;/code&gt; 에 대해 &lt;a href=&quot;qpainter#begin&quot;&gt;QPainter :: begin&lt;/a&gt; ()이 호출 될 때까지 데이터를 공유 합니다.</target>
        </trans-unit>
        <trans-unit id="d3e9a0c073a6c98292de8fb5126a0361b67561b0" translate="yes" xml:space="preserve">
          <source>In this example, a predefined gradient is set up differently depending on the orientation of the handle. &lt;a href=&quot;qsplitterhandle&quot;&gt;QSplitterHandle&lt;/a&gt; provides a reasonable size hint for the handle, so the subclass does not need to provide a reimplementation of &lt;a href=&quot;qsplitterhandle#sizeHint&quot;&gt;sizeHint&lt;/a&gt;() unless the handle has special size requirements.</source>
          <target state="translated">이 예에서, 사전 정의 된 그라디언트는 핸들의 방향에 따라 다르게 설정됩니다. &lt;a href=&quot;qsplitterhandle&quot;&gt;QSplitterHandle&lt;/a&gt; 은 핸들에 적절한 크기 힌트를 제공 하므로 핸들에 특별한 크기 요구 사항 이없는 경우 서브 클래스는 &lt;a href=&quot;qsplitterhandle#sizeHint&quot;&gt;sizeHint&lt;/a&gt; ()를 다시 구현할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="6f9d1c6da4b4119b87b9a6d3aca87056d4d65ca7" translate="yes" xml:space="preserve">
          <source>In this example, a predefined gradient is set up differently depending on the orientation of the handle. QSplitterHandle provides a reasonable size hint for the handle, so the subclass does not need to provide a reimplementation of &lt;a href=&quot;qsplitterhandle#sizeHint&quot;&gt;sizeHint&lt;/a&gt;() unless the handle has special size requirements.</source>
          <target state="translated">이 예에서는 미리 정의 된 그라데이션이 핸들 방향에 따라 다르게 설정됩니다. QSplitterHandle은 핸들에 적절한 크기 힌트를 제공 하므로 핸들에 특별한 크기 요구 사항 이없는 경우 하위 클래스는 &lt;a href=&quot;qsplitterhandle#sizeHint&quot;&gt;sizeHint&lt;/a&gt; ()를 다시 구현할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="999da1ad9787398f1d2e84ddb26854e2f75d0230" translate="yes" xml:space="preserve">
          <source>In this example, both the &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; and the &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; functions may produce a different number of reads/writes. This can confuse the Qt D-Bus type system and should be avoided.</source>
          <target state="translated">이 예에서 &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; 및 &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; 함수는 모두 다른 수의 읽기 / 쓰기를 생성 할 수 있습니다. 이것은 Qt D-Bus 타입 시스템을 혼동시킬 수 있으므로 피해야합니다.</target>
        </trans-unit>
        <trans-unit id="0b4c78e1bc50276fe63e7f90612ec2b4d6685ef7" translate="yes" xml:space="preserve">
          <source>In this example, if the user clicks OK the font they chose will be used, and if they click Cancel the original font is used.</source>
          <target state="translated">이 예에서 사용자가 확인을 클릭하면 선택한 글꼴이 사용되며 취소를 클릭하면 원래 글꼴이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2fcaccfcc775dc4e2a1aed36721366878fcca6b8" translate="yes" xml:space="preserve">
          <source>In this example, keyboard focus is transferred to the label's buddy (the &lt;a href=&quot;qlineedit&quot;&gt;QLineEdit&lt;/a&gt;) when the user presses Alt+P. If the buddy was a button (inheriting from &lt;a href=&quot;qabstractbutton&quot;&gt;QAbstractButton&lt;/a&gt;), triggering the mnemonic would emulate a button click.</source>
          <target state="translated">이 예제 에서 사용자가 Alt + P를 누르면 키보드 포커스가 레이블의 친구 ( &lt;a href=&quot;qlineedit&quot;&gt;QLineEdit&lt;/a&gt; ) 로 전송됩니다 . 친구가 버튼 ( &lt;a href=&quot;qabstractbutton&quot;&gt;QAbstractButton&lt;/a&gt; 에서 상 속됨 ) 인 경우 니모닉을 트리거하면 버튼 클릭이 에뮬레이트됩니다.</target>
        </trans-unit>
        <trans-unit id="2faf272681546fd3a889eb564ab412eac1cc354d" translate="yes" xml:space="preserve">
          <source>In this example, keyboard focus is transferred to the label's buddy (the &lt;a href=&quot;qlineedit&quot;&gt;QLineEdit&lt;/a&gt;) when the user presses Alt+P. If the buddy was a button (inheriting from &lt;a href=&quot;widgets-changes-qt6#qabstractbutton&quot;&gt;QAbstractButton&lt;/a&gt;), triggering the mnemonic would emulate a button click.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d15b59b3fdb51e89ff35ae53f4be8eb8fedcf2ef" translate="yes" xml:space="preserve">
          <source>In this example, main.qml will normally use Component.qml for the Component type. However on a unix platform, the unix selector will be present and the +unix/Component.qml version will be used instead. Note that this acts like swapping out Component.qml with +unix/Component.qml, so when using Component.qml you should not need to alter any paths based on which version was selected.</source>
          <target state="translated">이 예에서 main.qml은 일반적으로 구성 요소 유형에 Component.qml을 사용합니다. 그러나 유닉스 플랫폼에서는 유닉스 선택기가 있고 + unix / Component.qml 버전이 대신 사용됩니다. 이는 Component.qml을 + unix / Component.qml과 교체하는 것과 같이 작동하므로 Component.qml을 사용할 때 선택한 버전에 따라 경로를 변경할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="3ff9fb3748987a1b472588cbf21d795b62d10160" translate="yes" xml:space="preserve">
          <source>In this example, the &lt;code&gt;MyWidget&lt;/code&gt; constructor relays a signal from a private member variable, and makes it available under a name that relates to &lt;code&gt;MyWidget&lt;/code&gt;.</source>
          <target state="translated">이 예에서, &lt;code&gt;MyWidget&lt;/code&gt; 의 생성자 전용 멤버 변수로부터의 신호를 중계 및 관련 이름하에 사용할 수 있도록 &lt;code&gt;MyWidget&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1e3649d3f75d265bca2550faf5b7d5abd9dda84e" translate="yes" xml:space="preserve">
          <source>In this example, the dock widget can only be placed in the left and right dock areas, and it is initially placed in the left dock area.</source>
          <target state="translated">이 예에서 도크 위젯은 왼쪽 및 오른쪽 도크 영역에만 배치 할 수 있으며 처음에는 왼쪽 도크 영역에 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="0b72b94b4757c02a73386ac2ac7762e13e401756" translate="yes" xml:space="preserve">
          <source>In this example, the lambda function made the connection simple even though &lt;a href=&quot;qabstractbutton#clicked&quot;&gt;QPushButton::clicked&lt;/a&gt;() and &lt;code&gt;TextSender::textCompleted()&lt;/code&gt; have incompatible parameters. In contrast, a string-based implementation would require extra boilerplate code.</source>
          <target state="translated">이 예에서 &lt;a href=&quot;qabstractbutton#clicked&quot;&gt;QPushButton :: clicked&lt;/a&gt; () 및 &lt;code&gt;TextSender::textCompleted()&lt;/code&gt; 에 호환되지 않는 매개 변수가 있어도 lambda 함수는 연결을 간단하게 만들었습니다 . 반대로, 문자열 기반 구현에는 추가 상용구 코드가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="235379df72b319b5f0ef8b2f33686cc77de424dc" translate="yes" xml:space="preserve">
          <source>In this example, the page entitled &quot;Qt Creator Manual&quot; contains a nested list of links to pages in the documentation which is duplicated in Qt Assistant's Contents tab.</source>
          <target state="translated">이 예에서 &quot;Qt Creator Manual&quot;이라는 제목의 페이지에는 Qt Assistant의 내용 탭에 복제 된 설명서의 페이지에 대한 링크가 중첩되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="2da94753c669c0b214155883e8a88e777ac9bf77" translate="yes" xml:space="preserve">
          <source>In this example, the shortcut is</source>
          <target state="translated">이 예에서 단축키는</target>
        </trans-unit>
        <trans-unit id="d3564d070713315e9b062415b2c5d0a34613c1ad" translate="yes" xml:space="preserve">
          <source>In this example, the source object is a simple binary switch that will toggle its state based on a timer. When the state changes, a signal is emitted by the source which QtRO propagates to all replicas. As the replica will have the same properties, signals and slots as were exposed from the source object, any slots connected to the replica's signal will be called when the replica receives the signal. The client process then echoes back the received switch state to the source by emitting its own signal which is connected to a slot on the replica.</source>
          <target state="translated">이 예제에서 소스 개체는 타이머를 기반으로 상태를 전환하는 간단한 이진 스위치입니다. 상태가 변경되면 QtRO가 모든 복제본에 전파하는 소스에서 신호를 방출합니다. 복제본은 소스 객체에서 노출 된 것과 동일한 속성, 신호 및 슬롯을 가지므로 복제본이 신호를 수신하면 복제본 신호에 연결된 슬롯이 호출됩니다. 그런 다음 클라이언트 프로세스는 복제본의 슬롯에 연결된 자체 신호를 방출하여 수신 된 스위치 상태를 소스로 에코합니다.</target>
        </trans-unit>
        <trans-unit id="e36ccd2f1c46f5ff63faa5283e47c4297e4baad8" translate="yes" xml:space="preserve">
          <source>In this example, the timer is started by a call to &lt;a href=&quot;qelapsedtimer#start&quot;&gt;start&lt;/a&gt;() and the elapsed time is calculated by the &lt;a href=&quot;qelapsedtimer#elapsed&quot;&gt;elapsed&lt;/a&gt;() function.</source>
          <target state="translated">이 예에서 타이머는 &lt;a href=&quot;qelapsedtimer#start&quot;&gt;start&lt;/a&gt; () 호출로 시작 되고 경과 시간은 &lt;a href=&quot;qelapsedtimer#elapsed&quot;&gt;elapsed&lt;/a&gt; () 함수로 계산됩니다 .</target>
        </trans-unit>
        <trans-unit id="a27ca901639e7c105df3fd5c77af46728ef15bc6" translate="yes" xml:space="preserve">
          <source>In this example, the timer is started by a call to &lt;a href=&quot;qelapsedtimer#start&quot;&gt;start&lt;/a&gt;() and the elapsed timer is calculated by the &lt;a href=&quot;qelapsedtimer#elapsed&quot;&gt;elapsed&lt;/a&gt;() function.</source>
          <target state="translated">이 예에서, 타이머가 호출에 의해 시작되는 &lt;a href=&quot;qelapsedtimer#start&quot;&gt;시작&lt;/a&gt; () 및 경과 타이머는 계산된다 &lt;a href=&quot;qelapsedtimer#elapsed&quot;&gt;경과&lt;/a&gt; () 함수.</target>
        </trans-unit>
        <trans-unit id="04368f892c2f39db24b113e7bf2d0296b1a1de0b" translate="yes" xml:space="preserve">
          <source>In this example, the toolbar is restricted to the top and bottom toolbar areas of the main window, and is initially placed in the top tool bar area. We can see that the actions specified by &lt;code&gt;newAct&lt;/code&gt; and &lt;code&gt;openAct&lt;/code&gt; will be displayed both on the toolbar and in the file menu.</source>
          <target state="translated">이 예제에서 툴바는 기본 창의 상단 및 하단 툴바 영역으로 제한되며 맨 처음 툴바 영역에 배치됩니다. &lt;code&gt;newAct&lt;/code&gt; 및 &lt;code&gt;openAct&lt;/code&gt; 로 지정된 조치 가 도구 모음 및 파일 메뉴 모두에 표시 되는 것을 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7630fea80062eea7b38dbc08e557a2c772f26d23" translate="yes" xml:space="preserve">
          <source>In this example, there will be some level of data loss because the &lt;code&gt;%FF&lt;/code&gt; cannot be converted.</source>
          <target state="translated">이 예에서는 &lt;code&gt;%FF&lt;/code&gt; 를 변환 할 수 없으므로 데이터 손실 수준이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f801de70955d3907c634e712bc385370e892b307" translate="yes" xml:space="preserve">
          <source>In this example, we implement the shader effect manually. The &lt;a href=&quot;qtgraphicaleffects-index&quot;&gt;Qt Graphical Effects&lt;/a&gt; module contains a suite of ready-made effects for use with Qt Quick.</source>
          <target state="translated">이 예제에서는 셰이더 효과를 수동으로 구현합니다. &lt;a href=&quot;qtgraphicaleffects-index&quot;&gt;Qt는 그래픽 효과&lt;/a&gt; 모듈은 Qt를 빠른 사용하기위한 준비가 만든 효과의 제품군이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="949cde144af3ddb388161b46bf77b0212b49247e" translate="yes" xml:space="preserve">
          <source>In this example, we know that the editor widget is a spin box, but we could have provided different editors for different types of data in the model, in which case we would need to cast the widget to the appropriate type before accessing its member functions.</source>
          <target state="translated">이 예제에서는 편집기 위젯이 스핀 상자라는 것을 알고 있지만 모델의 여러 유형의 데이터에 대해 서로 다른 편집기를 제공 할 수 있습니다.이 경우 멤버 함수에 액세스하기 전에 위젯을 적절한 유형으로 캐스트해야합니다. .</target>
        </trans-unit>
        <trans-unit id="302e8cd2260bab3b6df359498303c437334ae297" translate="yes" xml:space="preserve">
          <source>In this example, when &lt;code&gt;button&lt;/code&gt; is clicked, the machine will enter &lt;code&gt;s2&lt;/code&gt;. It will remain in state &lt;code&gt;s2&lt;/code&gt; until the &lt;code&gt;geometry&lt;/code&gt; property has been set to &lt;code&gt;QRect(0, 0, 50, 50)&lt;/code&gt;. Then it will transition into &lt;code&gt;s3&lt;/code&gt;. When &lt;code&gt;s3&lt;/code&gt; is entered, the message box will pop up. If the transition into &lt;code&gt;s2&lt;/code&gt; has an animation for the &lt;code&gt;geometry&lt;/code&gt; property, then the machine will stay in &lt;code&gt;s2&lt;/code&gt; until the animation has finished playing. If there is no such animation, it will simply set the property and immediately enter state &lt;code&gt;s3&lt;/code&gt;.</source>
          <target state="translated">이 예에서 &lt;code&gt;button&lt;/code&gt; 을 클릭하면 머신이 &lt;code&gt;s2&lt;/code&gt; 로 입력 됩니다. &lt;code&gt;geometry&lt;/code&gt; 속성이 &lt;code&gt;QRect(0, 0, 50, 50)&lt;/code&gt; 로 설정 될 때까지 &lt;code&gt;s2&lt;/code&gt; 상태로 유지됩니다 . 그런 다음 &lt;code&gt;s3&lt;/code&gt; 으로 전환됩니다 . 때 &lt;code&gt;s3&lt;/code&gt; 입력, 메시지 상자가 나타납니다. 로 전환하면 &lt;code&gt;s2&lt;/code&gt; 에 대한 애니메이션이 &lt;code&gt;geometry&lt;/code&gt; 속성을 다음 기계에 남아있을 것입니다 &lt;code&gt;s2&lt;/code&gt; 애니메이션이 완성 된 연주를 가질 때까지. 이러한 애니메이션이 없으면 단순히 속성을 설정하고 즉시 상태 &lt;code&gt;s3&lt;/code&gt; 으로 들어갑니다 .</target>
        </trans-unit>
        <trans-unit id="1688a407b207637b41abe1be9043ecb899dfd3d6" translate="yes" xml:space="preserve">
          <source>In this example, when the table view needs to provide an editor, it asks the delegate to provide an editor widget that is appropriate for the item being modified. The &lt;a href=&quot;qabstractitemdelegate#createEditor&quot;&gt;createEditor()&lt;/a&gt; function is supplied with everything that the delegate needs to be able to set up a suitable widget:</source>
          <target state="translated">이 예에서 테이블 뷰는 편집기를 제공해야하는 경우 대리자에게 수정중인 항목에 적합한 편집기 위젯을 제공하도록 요청합니다. &lt;a href=&quot;qabstractitemdelegate#createEditor&quot;&gt;createEditor를 ()&lt;/a&gt; 함수는 위임 요구에 적합한 위젯을 설정할 수 있도록 모든 것이 함께 제공됩니다 :</target>
        </trans-unit>
        <trans-unit id="6b4b45f883cad08400fe2f283e3df0277bface4f" translate="yes" xml:space="preserve">
          <source>In this image the black dot is positioned at (0,0) within the item coordinates of the red rectangle. If the red rectangle was the root item of the scene, then the black dot would also be positioned at (0,0) in scene coordinates.</source>
          <target state="translated">이 이미지에서 검은 점은 빨간색 사각형의 항목 좌표 내 (0,0)에 위치합니다. 빨간색 사각형이 장면의 루트 항목 인 경우 검은 점도 장면 좌표에서 (0,0)에 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="efb41aa226d00b5cd9c17115bdf160b8d8cefd1f" translate="yes" xml:space="preserve">
          <source>In this instance, to avoid this issue, the view could set the property using a &lt;a href=&quot;qml-qtquick-propertyaction&quot;&gt;PropertyAction&lt;/a&gt; instead:</source>
          <target state="translated">이 경우이 문제를 피하기 위해보기는 대신 &lt;a href=&quot;qml-qtquick-propertyaction&quot;&gt;PropertyAction을&lt;/a&gt; 사용하여 속성을 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1c79f673d02c6a0b02afffb6a4413bac50fd2c46" translate="yes" xml:space="preserve">
          <source>In this mode the gradient coordinates are relative to the bounding rectangle of the object being drawn, with (0,0) in the top left corner, and (1,1) in the bottom right corner of the object's bounding rectangle. This value was added in Qt 5.12.</source>
          <target state="translated">이 모드에서 그라디언트 좌표는 그려지는 객체의 경계 사각형을 기준으로하며 왼쪽 상단 모서리에 (0,0)이 있고 객체 경계 사각형의 오른쪽 하단 모서리에 (1,1)이 있습니다. 이 값은 Qt 5.12에서 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="4bac153adc4b9fa8e68ca852dc8eface50bf9220" translate="yes" xml:space="preserve">
          <source>In this mode the gradient coordinates are relative to the bounding rectangle of the paint device, with (0,0) in the top left corner, and (1,1) in the bottom right corner of the paint device.</source>
          <target state="translated">이 모드에서 그라디언트 좌표는 페인트 장치의 경계 사각형을 기준으로하며 왼쪽 위 모서리에 (0,0)이 있고 페인트 장치의 오른쪽 아래 모서리에 (1,1)이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f99379591ca05eb12bd4a6f61185a599485cd60c" translate="yes" xml:space="preserve">
          <source>In this mode the tool button displays a special arrow to indicate that a menu is present. The menu is displayed when the arrow part of the button is pressed.</source>
          <target state="translated">이 모드에서 도구 버튼은 메뉴가 있음을 나타내는 특수 화살표를 표시합니다. 버튼의 화살표 부분을 누르면 메뉴가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="a5a4b03e05731f32b56648a426c9e32b56ddc0e9" translate="yes" xml:space="preserve">
          <source>In this mode, a thread can lock the same &lt;a href=&quot;qreadwritelock&quot;&gt;QReadWriteLock&lt;/a&gt; multiple times. The &lt;a href=&quot;qreadwritelock&quot;&gt;QReadWriteLock&lt;/a&gt; won't be unlocked until a corresponding number of &lt;a href=&quot;qreadwritelock#unlock&quot;&gt;unlock&lt;/a&gt;() calls have been made.</source>
          <target state="translated">이 모드에서 스레드는 동일한 &lt;a href=&quot;qreadwritelock&quot;&gt;QReadWriteLock을&lt;/a&gt; 여러 번 잠글 수 있습니다 . &lt;a href=&quot;qreadwritelock&quot;&gt;QReadWriteLock은&lt;/a&gt; 의 대응 수를 때까지 해제되지 않습니다 &lt;a href=&quot;qreadwritelock#unlock&quot;&gt;잠금 해제&lt;/a&gt; () 호출이되었습니다.</target>
        </trans-unit>
        <trans-unit id="cf8071f22e099a59fd4dd42f20046f8ac50f765e" translate="yes" xml:space="preserve">
          <source>In this mode, a thread can lock the same mutex multiple times and the mutex won't be unlocked until a corresponding number of &lt;a href=&quot;qmutex#unlock&quot;&gt;unlock&lt;/a&gt;() calls have been made.</source>
          <target state="translated">이 모드에서 스레드는 동일한 뮤텍스를 여러 번 잠글 수 있으며 해당 개수의 &lt;a href=&quot;qmutex#unlock&quot;&gt;unlock&lt;/a&gt; () 호출이 수행 될 때까지 뮤텍스가 잠금 해제되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="88d0a5220bdccf1681c678bb134055ed3908fc94" translate="yes" xml:space="preserve">
          <source>In this mode, a thread can lock the same mutex multiple times and the mutex won't be unlocked until a corresponding number of &lt;a href=&quot;qmutex#unlock&quot;&gt;unlock&lt;/a&gt;() calls have been made. You should use &lt;a href=&quot;qrecursivemutex&quot;&gt;QRecursiveMutex&lt;/a&gt; for this use-case.</source>
          <target state="translated">이 모드에서 스레드는 동일한 뮤텍스를 여러 번 잠글 수 있으며 해당 개수의 &lt;a href=&quot;qmutex#unlock&quot;&gt;unlock&lt;/a&gt; () 호출이 수행 될 때까지 뮤텍스가 잠금 해제되지 않습니다 . 당신은 사용해야 &lt;a href=&quot;qrecursivemutex&quot;&gt;QRecursiveMutex을&lt;/a&gt; 이 사용-경우에.</target>
        </trans-unit>
        <trans-unit id="39fcfd26a81ee3c453c79d5569011ba1a79f42c0" translate="yes" xml:space="preserve">
          <source>In this mode, a thread may only lock a &lt;a href=&quot;qreadwritelock&quot;&gt;QReadWriteLock&lt;/a&gt; once.</source>
          <target state="translated">이 모드에서 스레드는 &lt;a href=&quot;qreadwritelock&quot;&gt;QReadWriteLock을&lt;/a&gt; 한 번만 잠글 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5f6efbbcec8516b4d059c7b41ece0e309e734609" translate="yes" xml:space="preserve">
          <source>In this mode, a thread may only lock a mutex once.</source>
          <target state="translated">이 모드에서 스레드는 뮤텍스를 한 번만 잠글 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="51c4b84006f4a9a6f5eaba5872cb21631d3572f7" translate="yes" xml:space="preserve">
          <source>In this mode, the &lt;code&gt;files&lt;/code&gt; argument can be a list of files or directories. If a directory is specified, it will be included in the &lt;a href=&quot;qmake-variable-reference#dependpath&quot;&gt;DEPENDPATH&lt;/a&gt; variable, and relevant code from there will be included in the generated project file. If a file is given, it will be appended to the correct variable, depending on its extension. For example, UI files are added to &lt;a href=&quot;qmake-variable-reference#forms&quot;&gt;FORMS&lt;/a&gt;, and C++ files are added to &lt;a href=&quot;qmake-variable-reference#sources&quot;&gt;SOURCES&lt;/a&gt;.</source>
          <target state="translated">이 모드에서 &lt;code&gt;files&lt;/code&gt; 인수는 파일 또는 디렉토리 목록이 될 수 있습니다. 디렉토리가 지정되면 &lt;a href=&quot;qmake-variable-reference#dependpath&quot;&gt;DEPENDPATH&lt;/a&gt; 변수에 포함되고 거기에서 관련 코드가 생성 된 프로젝트 파일에 포함됩니다. 파일이 주어지면 확장자에 따라 올바른 변수에 추가됩니다. 예를 들어 UI 파일은 &lt;a href=&quot;qmake-variable-reference#forms&quot;&gt;FORMS&lt;/a&gt; 에 추가 되고 C ++ 파일은 &lt;a href=&quot;qmake-variable-reference#sources&quot;&gt;SOURCES에&lt;/a&gt; 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="b5ea371b73c38c196b0320941a7a5faa4ff5dcbe" translate="yes" xml:space="preserve">
          <source>In this model, the item in the string list that corresponds to the model index is replaced by the value provided. However, before we can modify the string list, we must make sure that the index is valid, the item is of the correct type, and that the role is supported. By convention, we insist that the role is the &lt;a href=&quot;qt#ItemDataRole-enum&quot;&gt;EditRole&lt;/a&gt; since this is the role used by the standard item delegate. For boolean values, however, you can use &lt;a href=&quot;qt#ItemDataRole-enum&quot;&gt;Qt::CheckStateRole&lt;/a&gt; and set the &lt;a href=&quot;qt#ItemFlag-enum&quot;&gt;Qt::ItemIsUserCheckable&lt;/a&gt; flag; a checkbox is then used for editing the value. The underlying data in this model is the same for all roles, so this detail just makes it easier to integrate the model with standard components.</source>
          <target state="translated">이 모델에서는 모델 색인에 해당하는 문자열 목록의 항목이 제공된 값으로 대체됩니다. 그러나 문자열 목록을 수정하기 전에 인덱스가 유효한지, 항목이 올바른 유형인지, 역할이 지원되는지 확인해야합니다. 관례 적으로 표준 항목 델리게이트가 사용하는 역할이기 때문에 역할이 &lt;a href=&quot;qt#ItemDataRole-enum&quot;&gt;EditRole&lt;/a&gt; 이라고 주장합니다 . 그러나 부울 값의 경우 &lt;a href=&quot;qt#ItemDataRole-enum&quot;&gt;Qt :: CheckStateRole&lt;/a&gt; 을 사용하고 &lt;a href=&quot;qt#ItemFlag-enum&quot;&gt;Qt :: ItemIsUserCheckable&lt;/a&gt; 플래그를 설정할 수 있습니다 . 그런 다음 값을 편집하는 데 확인란이 사용됩니다. 이 모델의 기본 데이터는 모든 역할에 대해 동일하므로이 세부 사항을 통해 모델을 표준 구성 요소와 쉽게 통합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c4ae048ff841aa06e0864405ffed2086e736baf" translate="yes" xml:space="preserve">
          <source>In this path expression, both &lt;code&gt;recipe&lt;/code&gt; and &lt;code&gt;title&lt;/code&gt; are name tests written in the shorthand form. &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt; resolves these names (&lt;a href=&quot;http://www.w3.org/TR/xquery/#id-basics&quot;&gt;QNames&lt;/a&gt;) to their expanded form using whatever &lt;a href=&quot;http://www.w3.org/TR/xquery/#dt-namespace-declaration&quot;&gt;namespace declarations&lt;/a&gt; it knows about. Resolving a name to its expanded form means replacing its namespace prefix, if one is present (there aren't any present in the example), with a namespace URI. The expanded name then consists of the namespace URI and the local name.</source>
          <target state="translated">이 경로 표현식에서 &lt;code&gt;recipe&lt;/code&gt; 와 &lt;code&gt;title&lt;/code&gt; 은 모두 축약 형식으로 작성된 이름 테스트입니다. &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt; 는 알고있는 &lt;a href=&quot;http://www.w3.org/TR/xquery/#dt-namespace-declaration&quot;&gt;네임 스페이스 선언을&lt;/a&gt; 사용하여 이러한 이름 ( &lt;a href=&quot;http://www.w3.org/TR/xquery/#id-basics&quot;&gt;QNames&lt;/a&gt; )을 확장 된 형식으로 확인합니다. 이름을 확장 된 형식으로 해석하는 것은 네임 스페이스 접두사가있는 경우 (예제에는 없음) 네임 스페이스 URI로 대체하는 것을 의미합니다. 확장 된 이름은 네임 스페이스 URI와 로컬 이름으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="5605cad4c620ef3a8507b3d76f04febe9af7a320" translate="yes" xml:space="preserve">
          <source>In this path expression, both &lt;code&gt;recipe&lt;/code&gt; and &lt;code&gt;title&lt;/code&gt; are name tests written in the shorthand form. &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt; resolves these names (&lt;a href=&quot;http://www.w3.org/TR/xquery/#id-basics&quot;&gt;QNames&lt;/a&gt;) to their expanded form using whatever &lt;a href=&quot;http://www.w3.org/TR/xquery/#dt-namespace-declaration&quot;&gt;namespace declarations&lt;/a&gt; it knows about. Resolving a name to its expanded form means replacing its namespace prefix, if one is present (there aren't any present in the example), with a namespace URI. The expanded name then consists of the namespace URI and the local name.</source>
          <target state="translated">이 경로 표현식에서 &lt;code&gt;recipe&lt;/code&gt; 와 &lt;code&gt;title&lt;/code&gt; 은 모두 축약 형식으로 작성된 이름 테스트입니다. &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt; 는 알고있는 &lt;a href=&quot;http://www.w3.org/TR/xquery/#dt-namespace-declaration&quot;&gt;네임 스페이스 선언을&lt;/a&gt; 사용하여 이러한 이름 ( &lt;a href=&quot;http://www.w3.org/TR/xquery/#id-basics&quot;&gt;QNames&lt;/a&gt; )을 확장 된 형식으로 확인합니다. 이름을 확장 된 형식으로 해석하는 것은 네임 스페이스 접두사가있는 경우 (예제에는 없음) 네임 스페이스 URI로 대체하는 것을 의미합니다. 확장 된 이름은 네임 스페이스 URI와 로컬 이름으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="234eaf6971e188df3c64ddb37bfe43b7d37738d9" translate="yes" xml:space="preserve">
          <source>In this section we will explain the procedure of implementing accessible plugins for your interfaces. A plugin is a class stored in a shared library that can be loaded at run-time. It is convenient to distribute interfaces as plugins since they will only be loaded when required.</source>
          <target state="translated">이 섹션에서는 인터페이스에 액세스 가능한 플러그인을 구현하는 절차를 설명합니다. 플러그인은 런타임에로드 할 수있는 공유 라이브러리에 저장된 클래스입니다. 인터페이스는 필요할 때만로드되므로 플러그인으로 배포하는 것이 편리합니다.</target>
        </trans-unit>
        <trans-unit id="54d3ed97e636aea202d0e7406445c6021f10ea06" translate="yes" xml:space="preserve">
          <source>In this section we will have a look at some implementation issues. Finally, we will see a complete example on the styling of a Java widget. We will continue to use the Java style throughout the document for examples and widget images. The implementation itself is somewhat involved, and it is not intended that you should read through it.</source>
          <target state="translated">이 섹션에서는 몇 가지 구현 문제를 살펴 보겠습니다. 마지막으로 Java 위젯 스타일링에 대한 전체 예제를 볼 수 있습니다. 예제와 위젯 이미지를 위해 문서 전체에서 Java 스타일을 계속 사용할 것입니다. 구현 자체는 다소 관련이 있으며이를 읽어야하는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="c0df91c69d5811751122073dd073984a8a527e0b" translate="yes" xml:space="preserve">
          <source>In this section we will show the most basic way to use Qt in a CMake project. We will walk through an example project that is utilizing &lt;a href=&quot;qtwidgets-index&quot;&gt;Qt Widgets&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3260e6a623886cc2b28bfaeb75b17b834e8dc4a2" translate="yes" xml:space="preserve">
          <source>In this section, we create a simple read-only model to explore the basic principles of the model/view architecture. Later in this section, we adapt this simple model so that items can be modified by the user.</source>
          <target state="translated">이 섹션에서는 모델 / 뷰 아키텍처의 기본 원칙을 탐색하기 위해 간단한 읽기 전용 모델을 만듭니다. 이 섹션의 뒷부분에서 사용자가 항목을 수정할 수 있도록이 간단한 모델을 조정합니다.</target>
        </trans-unit>
        <trans-unit id="10539b1f975fafffe2435b86b80bdefa49531feb" translate="yes" xml:space="preserve">
          <source>In this section, we implement a simple model based on a list of strings, so the &lt;a href=&quot;qabstractlistmodel&quot;&gt;QAbstractListModel&lt;/a&gt; provides an ideal base class on which to build.</source>
          <target state="translated">이 섹션에서는 문자열 목록을 기반으로 간단한 모델을 구현하므로 &lt;a href=&quot;qabstractlistmodel&quot;&gt;QAbstractListModel&lt;/a&gt; 은 빌드 할 이상적인 기본 클래스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="91c09ec270f1ce6cb036dc00b51571c7578d1550" translate="yes" xml:space="preserve">
          <source>In this section, we will examine how most of Qt's widgets are styled. Hopefully, this will save you some time and effort while developing your own styles and widgets. You will not find information here that is not attainable elsewhere (i.e., by examining the source code or the class descriptions for the style related classes).</source>
          <target state="translated">이 섹션에서는 대부분의 Qt 위젯의 스타일을 살펴 보겠습니다. 바라건대, 이렇게하면 자신 만의 스타일과 위젯을 개발하는 동안 시간과 노력을 절약 할 수 있습니다. 여기서는 다른 곳에서 얻을 수없는 정보를 찾을 수 없습니다 (예 : 스타일 관련 클래스에 대한 소스 코드 또는 클래스 설명 검사).</target>
        </trans-unit>
        <trans-unit id="3f47cd1ace10fa43698bf499821a9365534b48c8" translate="yes" xml:space="preserve">
          <source>In this section, you will find an overview of creating and exporting 3D assets to use in Qt Quick 3D. For more detailed information, see the section for the &lt;a href=&quot;quick3d-asset-conditioning-3d-assets#exporting-from-different-tools&quot;&gt;specific 3D modeling tool&lt;/a&gt; that you are using.</source>
          <target state="translated">이 섹션에서는 Qt Quick 3D에서 사용할 3D 자산 생성 및 내보내기에 대한 개요를 확인할 수 있습니다. 자세한 내용 은 사용 중인 &lt;a href=&quot;quick3d-asset-conditioning-3d-assets#exporting-from-different-tools&quot;&gt;특정 3D 모델링 도구에&lt;/a&gt; 대한 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f74dd0586be28685f37f6c5e141d9d8eeb1a83be" translate="yes" xml:space="preserve">
          <source>In this situation the application must determine which widget within the window should receive the focus.</source>
          <target state="translated">이 상황에서 애플리케이션은 창에서 포커스를받을 위젯을 결정해야합니다.</target>
        </trans-unit>
        <trans-unit id="d65c68dcc986167cbb47bec6fde19614928981a0" translate="yes" xml:space="preserve">
          <source>In this situation we can either move the component inline,</source>
          <target state="translated">이 상황에서는 구성 요소를 인라인으로 이동하거나</target>
        </trans-unit>
        <trans-unit id="f77e3a6148f95c824aff40abfaad81cae846b66c" translate="yes" xml:space="preserve">
          <source>In this state, the camera still consumes power.</source>
          <target state="translated">이 상태에서 카메라는 여전히 전력을 소비합니다.</target>
        </trans-unit>
        <trans-unit id="2718cb561f3575be5202c9c3990958a6a9e9ed5f" translate="yes" xml:space="preserve">
          <source>In this topic we summarize those changes in &lt;a href=&quot;https://doc.qt.io/qt-6.0/qtopengl-index.html&quot;&gt;Qt OpenGL&lt;/a&gt;, and provide guidance to handle them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5eb9d0e213c819baab4ce6670b7bfe73be022ac7" translate="yes" xml:space="preserve">
          <source>In this topic we summarize those changes in Qt Concurrent, and provide guidance to handle them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9f4f5f7451a8e3ec8b5aa07ea6c7bd8ea780721" translate="yes" xml:space="preserve">
          <source>In this topic we summarize those changes in Qt Core, and provide guidance to handle them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb19f8fcc9faeba40c08630b1bba709d72f1a3bb" translate="yes" xml:space="preserve">
          <source>In this topic we summarize those changes in Qt DBus, and provide guidance to handle them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="100b2ba96dc763d2ad1f58d520efe73ac104c626" translate="yes" xml:space="preserve">
          <source>In this topic we summarize those changes in Qt GUI, and provide guidance to handle them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc3fddb02433fe15735f0a8664ed0a6dc58f6071" translate="yes" xml:space="preserve">
          <source>In this topic we summarize those changes in Qt Image Formats, and provide guidance to handle them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87c953946218141d81a4447f805eee07b24e3124" translate="yes" xml:space="preserve">
          <source>In this topic we summarize those changes in Qt Network Authorization, and provide guidance to handle them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26b5e600fab8b4d92a045fa1346ee0a4bc41841f" translate="yes" xml:space="preserve">
          <source>In this topic we summarize those changes in Qt Network, and provide guidance to handle them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4be784b23bfa6346a4083dd1fd46feee299c7b41" translate="yes" xml:space="preserve">
          <source>In this topic we summarize those changes in Qt Print Support, and provide guidance to handle them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6df80fdf5182cf3b0f303f0df67c2db66d183ff4" translate="yes" xml:space="preserve">
          <source>In this topic we summarize those changes in Qt Quick 3D, and provide guidance to handle them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02f081ac81cbfc38fca17bc34074c16fee234829" translate="yes" xml:space="preserve">
          <source>In this topic we summarize those changes in Qt Quick Controls, and provide guidance to handle them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f26af38683012886efd02c1dd95acde79807096e" translate="yes" xml:space="preserve">
          <source>In this topic we summarize those changes in Qt Quick Labs Platform, and provide guidance to handle them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a998c1430627191b1895c9a8c7e37baa628a4b0d" translate="yes" xml:space="preserve">
          <source>In this topic we summarize those changes in Qt SQL, and provide guidance to handle them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="383eb28fad6ed4a531d3f009b3a4f183da77d78f" translate="yes" xml:space="preserve">
          <source>In this topic we summarize those changes in Qt SVG, and provide guidance to handle them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3c3b92c64f3c54e317198c9eed962778a820b6a" translate="yes" xml:space="preserve">
          <source>In this topic we summarize those changes in Qt Test, and provide guidance to handle them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abff527d8e70f5f423797a26f1c4ccd038afe634" translate="yes" xml:space="preserve">
          <source>In this topic we summarize those changes in Qt Wayland Compositor, and provide guidance to handle them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df9d2385d3218d725f1085e2f131544c4ea48404" translate="yes" xml:space="preserve">
          <source>In this topic we summarize those changes in Qt Widgets, and provide guidance to handle them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd64cbd4bf67765e0cf60800b8f345967a08ad61" translate="yes" xml:space="preserve">
          <source>In this topic we summarize those changes in Qt XML, and provide guidance to handle them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8749c880d56a5412352f906c01a343927e4ae051" translate="yes" xml:space="preserve">
          <source>In this topic we summarize those changes in Qt3D, and provide guidance to handle them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1062d235d1c4f3cc085f9aaebe56578fb475810f" translate="yes" xml:space="preserve">
          <source>In this type of device, the touch surface and display are integrated. This means the surface and display typically have the same size, such that there is a direct relationship between the touch points' physical positions and the coordinate reported by &lt;a href=&quot;qeventpoint&quot;&gt;QEventPoint&lt;/a&gt;. As a result, Qt allows the user to interact directly with multiple QWidgets, QGraphicsItems, or Qt Quick Items at the same time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f94475de620540cea71799bb6accd7b99465255" translate="yes" xml:space="preserve">
          <source>In this type of device, the touch surface and display are integrated. This means the surface and display typically have the same size, such that there is a direct relationship between the touch points' physical positions and the coordinate reported by &lt;a href=&quot;qtouchevent-touchpoint&quot;&gt;QTouchEvent::TouchPoint&lt;/a&gt;. As a result, Qt allows the user to interact directly with multiple QWidgets and QGraphicsItems at the same time.</source>
          <target state="translated">이 유형의 장치에서는 터치 표면과 디스플레이가 통합됩니다. 이는 표면과 디스플레이가 일반적으로 동일한 크기를 가지므로 터치 포인트의 물리적 위치와 &lt;a href=&quot;qtouchevent-touchpoint&quot;&gt;QTouchEvent :: TouchPoint에서&lt;/a&gt; 보고하는 좌표간에 직접적인 관계가 있음을 의미합니다 . 결과적으로 Qt는 사용자가 동시에 여러 QWidget 및 QGraphicsItem과 직접 상호 작용할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="6685aa01d1b3fcca52863e41b8119da93842cd0b" translate="yes" xml:space="preserve">
          <source>In this type of device, the touch surface is separate from the display. There is not a direct relationship between the physical touch location and the on-screen coordinates. Instead, they are calculated relative to the current mouse position, and the user must use the touch-pad to move this reference point. Unlike touch-screens, Qt allows users to only interact with a single &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; or &lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt; at a time.</source>
          <target state="translated">이 유형의 장치에서 터치 표면은 디스플레이와 분리되어 있습니다. 물리적 터치 위치와 화면상의 좌표 사이에는 직접적인 관계가 없습니다. 대신 현재 마우스 위치를 기준으로 계산되며 사용자는 터치 패드를 사용하여이 기준점을 이동해야합니다. 터치 스크린과 달리 Qt는 사용자가 한 번에 하나의 &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; 또는 &lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem 과만&lt;/a&gt; 상호 작용할 수 있도록합니다 .</target>
        </trans-unit>
        <trans-unit id="66946372302723dbc39686181c362595a68f3f34" translate="yes" xml:space="preserve">
          <source>In this type of device, the touch surface is separate from the display. There is not a direct relationship between the physical touch location and the on-screen coordinates. Instead, they are calculated relative to the current mouse position, and the user must use the touch-pad to move this reference point. Unlike touch-screens, Qt allows users to only interact with a single &lt;a href=&quot;widgets-changes-qt6#qwidget&quot;&gt;QWidget&lt;/a&gt; or &lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt; at a time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b2535faab60201dc65f2b10fa2b5ffba2ee808d" translate="yes" xml:space="preserve">
          <source>In this way an object declaration may &lt;a href=&quot;qtqml-typesystem-objecttypes#defining-object-types-from-qml&quot;&gt;expose a particular value&lt;/a&gt; to outside objects or maintain some internal state more easily.</source>
          <target state="translated">이런 식으로 객체 선언은 &lt;a href=&quot;qtqml-typesystem-objecttypes#defining-object-types-from-qml&quot;&gt;특정 값&lt;/a&gt; 을 외부 객체에 노출 하거나 일부 내부 상태를 더 쉽게 유지할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d883efb35cac06454a54d0337ddbcf3332cfbc9" translate="yes" xml:space="preserve">
          <source>In this way you can do a visual parenthesis matching and highlight from the current cursor position to the matching parenthesis. That makes it easier to spot a missing parenthesis in your code and to find where a corresponding opening/closing parenthesis is when editing parenthesis intensive code.</source>
          <target state="translated">이러한 방식으로 시각적 괄호 일치를 수행하고 현재 커서 위치에서 일치하는 괄호까지 강조 표시 할 수 있습니다. 이를 통해 코드에서 누락 된 괄호를 쉽게 찾아 내고 괄호 집약적 인 코드를 편집 할 때 해당하는 여는 / 닫는 괄호가있는 위치를 쉽게 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="65952435f5dc1053c6d61dfc47bb7e6eeaf06f91" translate="yes" xml:space="preserve">
          <source>In this way, modular user interface types are assembled and reused within an application.</source>
          <target state="translated">이러한 방식으로 모듈 식 사용자 인터페이스 유형이 애플리케이션 내에서 조합되고 재사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3de767a5f61844da8fcb371c7514c56d9009cc74" translate="yes" xml:space="preserve">
          <source>In toolbars, the icon is used as the tool button icon; in menus, it is displayed to the left of the menu text. There is no default icon.</source>
          <target state="translated">도구 모음에서 아이콘은 도구 단추 아이콘으로 사용됩니다. 메뉴에서는 메뉴 텍스트의 왼쪽에 표시됩니다. 기본 아이콘이 없습니다.</target>
        </trans-unit>
        <trans-unit id="e8558be4cbe55217d99da0c999c4bef98bb07c70" translate="yes" xml:space="preserve">
          <source>In total, there are four levels for sections in QDoc: &lt;code&gt;\section1&lt;/code&gt;, &lt;code&gt;\section2&lt;/code&gt;, &lt;code&gt;\section3&lt;/code&gt; and &lt;code&gt;\section4&lt;/code&gt;. These correspond to the traditional section, subsection, subsubsection and subsubsubsection.</source>
          <target state="translated">QDoc의 섹션에는 총 4 개의 레벨이 있습니다 : &lt;code&gt;\section1&lt;/code&gt; , &lt;code&gt;\section2&lt;/code&gt; , &lt;code&gt;\section3&lt;/code&gt; 및 &lt;code&gt;\section4&lt;/code&gt; . 이는 전통적인 섹션, 하위 섹션, 하위 섹션 및 하위 하위 섹션에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="4351286a425286096d471d342fe0417768836e7b" translate="yes" xml:space="preserve">
          <source>In traditional user interfaces, views can be scrolled using standard controls, such as scroll bars and arrow buttons. In some situations, it is also possible to drag the view directly by pressing and holding a mouse button while moving the cursor. In touch-based user interfaces, this dragging action is often complemented with a flicking action, where scrolling continues after the user has stopped touching the view.</source>
          <target state="translated">기존 사용자 인터페이스에서는 스크롤 막대 및 화살표 버튼과 같은 표준 컨트롤을 사용하여보기를 스크롤 할 수 있습니다. 경우에 따라 커서를 이동하는 동안 마우스 버튼을 길게 눌러 뷰를 직접 끌 수도 있습니다. 터치 기반 사용자 인터페이스에서이 드래그 동작은 종종 사용자가 뷰 터치를 중단 한 후에도 스크롤이 계속되는 플릭 동작으로 보완됩니다.</target>
        </trans-unit>
        <trans-unit id="f258c69f22317c14e8206b56e29ba44e76398da4" translate="yes" xml:space="preserve">
          <source>In widget applications, certain widgets can use '&amp;amp;' in front of a character. This will automatically create a mnemonic (a shortcut) for that character, e.g. &quot;E&amp;amp;xit&quot; will create the shortcut &lt;b&gt;Alt+X&lt;/b&gt; (use '&amp;amp;&amp;amp;' to display an actual ampersand). The widget might consume and perform an action on a given shortcut. On X11 the ampersand will not be shown and the character will be underlined. On Windows, shortcuts are normally not displayed until the user presses the &lt;b&gt;Alt&lt;/b&gt; key, but this is a setting the user can change. On Mac, shortcuts are disabled by default. Call &lt;a href=&quot;qkeysequence#qt_set_sequence_auto_mnemonic&quot;&gt;qt_set_sequence_auto_mnemonic&lt;/a&gt;() to enable them. However, because mnemonic shortcuts do not fit in with Aqua's guidelines, Qt will not show the shortcut character underlined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6aaafeefcb43476d4c9477cdad1175f7b376a547" translate="yes" xml:space="preserve">
          <source>In widget-based applications, this property is not used, as it's only meaningful for a widget to accept or reject a complete &lt;a href=&quot;qinputevent&quot;&gt;QInputEvent&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b39c6b56a1a873cf646e6b3b27f95ed83f3439e" translate="yes" xml:space="preserve">
          <source>In your &lt;a href=&quot;qaxbindable&quot;&gt;QAxBindable&lt;/a&gt; subclass, implement &lt;a href=&quot;qaxbindable#createAggregate&quot;&gt;QAxBindable::createAggregate&lt;/a&gt;() to return a new object of the &lt;a href=&quot;qaxaggregated&quot;&gt;QAxAggregated&lt;/a&gt; subclass.</source>
          <target state="translated">당신에 &lt;a href=&quot;qaxbindable&quot;&gt;QAxBindable&lt;/a&gt; 서브 클래스 구현 &lt;a href=&quot;qaxbindable#createAggregate&quot;&gt;QAxBindable :: createAggregate을&lt;/a&gt; 의 새로운 객체 반환 () &lt;a href=&quot;qaxaggregated&quot;&gt;QAxAggregated의&lt;/a&gt; 서브 클래스를.</target>
        </trans-unit>
        <trans-unit id="e08dc5194d05b6c6fcdb177b54541a9fe51a1537" translate="yes" xml:space="preserve">
          <source>In your &lt;a href=&quot;qevent&quot;&gt;QEvent&lt;/a&gt; subclasses, override clone(), and declare the protected and default-implemented copy constructor and assignment operator like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63d2d509606741256342c77c9b94f6727b2ddd39" translate="yes" xml:space="preserve">
          <source>In your &lt;a href=&quot;qexception&quot;&gt;QException&lt;/a&gt; subclass, reimplement clone() like this:</source>
          <target state="translated">당신에 &lt;a href=&quot;qexception&quot;&gt;QException의&lt;/a&gt; 이 같은 서브 클래스 구현할 클론 () :</target>
        </trans-unit>
        <trans-unit id="dd2fcbeb7884806ac64f611bf2ba25de6cbb9514" translate="yes" xml:space="preserve">
          <source>In your &lt;a href=&quot;qexception&quot;&gt;QException&lt;/a&gt; subclass, reimplement raise() like this:</source>
          <target state="translated">당신에 &lt;a href=&quot;qexception&quot;&gt;QException의&lt;/a&gt; 이 같은 서브 클래스 구현할 인상 () :</target>
        </trans-unit>
        <trans-unit id="1aad9d4262c115a217ea35af3bbe0130fb028821" translate="yes" xml:space="preserve">
          <source>In your configuration file, set your &lt;code&gt;outputformats&lt;/code&gt; variable to &lt;code&gt;DITAXML&lt;/code&gt;, and send the output to an appropriate directory:</source>
          <target state="translated">구성 파일에서 &lt;code&gt;outputformats&lt;/code&gt; 변수를 &lt;code&gt;DITAXML&lt;/code&gt; 로 설정 하고 출력을 적절한 디렉토리로 보냅니다.</target>
        </trans-unit>
        <trans-unit id="391d4c696460971bd0866dd82b78c9f902720909" translate="yes" xml:space="preserve">
          <source>In your own code, please use only &lt;code&gt;QUtf8StringView&lt;/code&gt; and/or &lt;code&gt;q_no_char8_t::QUtf8StringView&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="769cfd06088af9845715bff54aafd9073099ac35" translate="yes" xml:space="preserve">
          <source>In your reimplementation of this function, if you want to filter the</source>
          <target state="translated">이 함수를 다시 구현할 때</target>
        </trans-unit>
        <trans-unit id="427fe9e274e6f7646ab5f0deb14eec78dd36fab2" translate="yes" xml:space="preserve">
          <source>In your reimplementation of this function, if you want to stop the event being handled by Qt, return true and set</source>
          <target state="translated">이 함수를 다시 구현할 때 Qt에서 처리하는 이벤트를 중지하려면 true를 반환하고</target>
        </trans-unit>
        <trans-unit id="f961645c55c0b98e856d14a71b4d7fe3ad5f3874" translate="yes" xml:space="preserve">
          <source>In-App Purchases</source>
          <target state="translated">인앱 구매</target>
        </trans-unit>
        <trans-unit id="c5f3fec7bd65d1e33a7327f41ace571bdb281ccc" translate="yes" xml:space="preserve">
          <source>In-App Purchasing</source>
          <target state="translated">인앱 구매</target>
        </trans-unit>
        <trans-unit id="229d515f509ad82bcd53f709b3ca353b175a13b4" translate="yes" xml:space="preserve">
          <source>In-App purchasing can only be tested on the actual hardware for the iOS platform. For more information refer to the &lt;a href=&quot;http://developer.apple.com/in-app-purchase/&quot;&gt;iOS documentation&lt;/a&gt;.</source>
          <target state="translated">인앱 구매는 iOS 플랫폼의 실제 하드웨어에서만 테스트 할 수 있습니다. 자세한 정보는 &lt;a href=&quot;http://developer.apple.com/in-app-purchase/&quot;&gt;iOS 문서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="da7b66e1d584f7382180975b2990383747934177" translate="yes" xml:space="preserve">
          <source>In-App purchasing for &lt;a href=&quot;supported-platforms#winrt&quot;&gt;WinRT&lt;/a&gt; differentiates between two modes:</source>
          <target state="translated">&lt;a href=&quot;supported-platforms#winrt&quot;&gt;WinRT에&lt;/a&gt; 대한 앱 내 구매 는 두 가지 모드를 구분합니다.</target>
        </trans-unit>
        <trans-unit id="faf1192558e81dd0caccc8ea7443a78efd2db6f6" translate="yes" xml:space="preserve">
          <source>In-App purchasing for WinRT differentiates between two modes:</source>
          <target state="translated">WinRT에 대한 앱 내 구매는 두 가지 모드를 구분합니다.</target>
        </trans-unit>
        <trans-unit id="d61ae781ad501b98baf8c7fac2203050048064c6" translate="yes" xml:space="preserve">
          <source>In-Depth Memory Allocation Considerations</source>
          <target state="translated">심층 메모리 할당 고려 사항</target>
        </trans-unit>
        <trans-unit id="b89bb5ff5c8429f56a85f36063f920a4d959b3e6" translate="yes" xml:space="preserve">
          <source>In-app billing service</source>
          <target state="translated">인앱 결제 서비스</target>
        </trans-unit>
        <trans-unit id="957b8acbbcffca282d9fb4135026f4a00dec0dcd" translate="yes" xml:space="preserve">
          <source>In-app products will be available once you have published the application.</source>
          <target state="translated">애플리케이션을 게시하면 인앱 상품을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f27319b26f4231b0090f8ed768563c7d37495cb" translate="yes" xml:space="preserve">
          <source>In-app purchases are a way to monetize an application. These purchases are made from inside the application and can include anything from unlocking content to virtual items. The Qt Purchasing API is built on the system APIs for in-app purchases, which means the purchase process is more familiar to the user, and the information already stored by the platform (such as credit card information) can be used to simplify the purchase process.</source>
          <target state="translated">인앱 구매는 애플리케이션으로 수익을 창출하는 방법입니다. 이러한 구매는 애플리케이션 내부에서 이루어지며 콘텐츠 잠금 해제부터 가상 아이템까지 모든 것을 포함 할 수 있습니다. Qt Purchasing API는 인앱 구매를위한 시스템 API를 기반으로 구축되어 구매 프로세스가 사용자에게 더 친숙하고 플랫폼에 이미 저장된 정보 (예 : 신용 카드 정보)를 사용하여 구매를 단순화 할 수 있습니다. 방법.</target>
        </trans-unit>
        <trans-unit id="0d77760dfc42dc3720305af5dea4f411b55778eb" translate="yes" xml:space="preserve">
          <source>In-process servers can be registered using the &lt;code&gt;regsvr32&lt;/code&gt; tool available on all Windows systems.</source>
          <target state="translated">In-process 서버는 모든 Windows 시스템에서 사용할 수 있는 &lt;code&gt;regsvr32&lt;/code&gt; 도구를 사용하여 등록 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="09af574c7f20770e2ba62ab519196e2d4d08efa4" translate="yes" xml:space="preserve">
          <source>Inactive</source>
          <target state="translated">Inactive</target>
        </trans-unit>
        <trans-unit id="b3ae7850d6f2a44a03399e9a0dba5a89c8cc487d" translate="yes" xml:space="preserve">
          <source>Incidentally, &lt;a href=&quot;qlcdnumber&quot;&gt;QLCDNumber&lt;/a&gt; is the very oldest part of Qt, tracing its roots back to a BASIC program on the &lt;a href=&quot;http://www.nvg.ntnu.no/sinclair/computers/zxspectrum/zxspectrum.htm#&quot;&gt;Sinclair Spectrum&lt;/a&gt;.</source>
          <target state="translated">덧붙여서, &lt;a href=&quot;qlcdnumber&quot;&gt;QLCDNumber&lt;/a&gt; 는 Qt에서 가장 오래된 부분으로 &lt;a href=&quot;http://www.nvg.ntnu.no/sinclair/computers/zxspectrum/zxspectrum.htm#&quot;&gt;Sinclair Spectrum&lt;/a&gt; 의 BASIC 프로그램에 뿌리를두고 있습니다.</target>
        </trans-unit>
        <trans-unit id="72fbd3be5003e3120ca9f394b6148b8520d0b768" translate="yes" xml:space="preserve">
          <source>Incidentally, QLCDNumber is the very oldest part of Qt, tracing its roots back to a BASIC program on the &lt;a href=&quot;http://www.nvg.ntnu.no/sinclair/computers/zxspectrum/zxspectrum.htm&quot;&gt;Sinclair Spectrum&lt;/a&gt;.</source>
          <target state="translated">덧붙여서, QLCDNumber는 Qt에서 가장 오래된 부분으로 &lt;a href=&quot;http://www.nvg.ntnu.no/sinclair/computers/zxspectrum/zxspectrum.htm&quot;&gt;Sinclair Spectrum&lt;/a&gt; 의 BASIC 프로그램에 뿌리를두고 있습니다.</target>
        </trans-unit>
        <trans-unit id="e794db49ca9cd25f93986ee6089723c877e37e32" translate="yes" xml:space="preserve">
          <source>Includable Functions</source>
          <target state="translated">포함 가능한 기능</target>
        </trans-unit>
        <trans-unit id="1521a666fd6d8d437d41c159ff934a47f7429e39" translate="yes" xml:space="preserve">
          <source>Include debugging help for mismatched calls to unbind. See &lt;a href=&quot;https://developer.android.com/reference/android/content/Context.html#BIND_DEBUG_UNBIND&quot;&gt;BIND_DEBUG_UNBIND&lt;/a&gt; documentation for more details.</source>
          <target state="translated">바인딩 해제에 대한 불일치 호출에 대한 디버깅 도움말을 포함합니다. 자세한 내용은 &lt;a href=&quot;https://developer.android.com/reference/android/content/Context.html#BIND_DEBUG_UNBIND&quot;&gt;BIND_DEBUG_UNBIND&lt;/a&gt; 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2bc3fb3eaaf1e96edaa226b1b4b3f9af011ca27b" translate="yes" xml:space="preserve">
          <source>Include the header which defines the type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bf6b578622f60be8bbfa44c31e5ef1143efa871" translate="yes" xml:space="preserve">
          <source>Include the leading separator (if any) in the result string.</source>
          <target state="translated">결과 문자열에 선행 구분 기호 (있는 경우)를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="823c476fee5dc1ec5038dd68f3aec3cc039d47aa" translate="yes" xml:space="preserve">
          <source>Include the resulting header file in your code to access the object APIs through the generated C++ classes. See the &lt;a href=&quot;https://doc.qt.io/qt-5.13/activeqt-activeqt-qutlook-example.html#&quot;&gt;Qutlook&lt;/a&gt; example for more information.</source>
          <target state="translated">생성 된 C ++ 클래스를 통해 개체 API에 액세스하려면 코드에 결과 헤더 파일을 포함합니다. 자세한 내용은 &lt;a href=&quot;https://doc.qt.io/qt-5.13/activeqt-activeqt-qutlook-example.html#&quot;&gt;Qutlook&lt;/a&gt; 예제를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c4ede659f88f34e32b9ba9df4605562de78627b4" translate="yes" xml:space="preserve">
          <source>Include the resulting header file in your code to access the object APIs through the generated C++ classes. See the &lt;a href=&quot;https://doc.qt.io/qt-5.15/activeqt-activeqt-qutlook-example.html&quot;&gt;Qutlook&lt;/a&gt; example for more information.</source>
          <target state="translated">생성 된 C ++ 클래스를 통해 개체 API에 액세스하려면 코드에 결과 헤더 파일을 포함합니다. 자세한 내용은 &lt;a href=&quot;https://doc.qt.io/qt-5.15/activeqt-activeqt-qutlook-example.html&quot;&gt;Qutlook&lt;/a&gt; 예제를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b1a13b4f82773869c0dbf4da758c5311862a814a" translate="yes" xml:space="preserve">
          <source>Include the trailing separator (if any) in the result string.</source>
          <target state="translated">결과 문자열에 후행 구분 기호 (있는 경우)를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="8b9befecdc70e3214aeaa22320e99c2964a4ba82" translate="yes" xml:space="preserve">
          <source>Included with Qt Location is a geo services plugin which accesses the relevant HERE services provided by HERE/Nokia. The use of these services is governed by the terms and conditions available at &lt;a href=&quot;https://developer.here.com/terms-conditions&quot;&gt;https://developer.here.com/terms-conditions&lt;/a&gt;.</source>
          <target state="translated">Qt Location에는 HERE / Nokia에서 제공하는 관련 HERE 서비스에 액세스하는 지리적 서비스 플러그인이 포함되어 있습니다. 이러한 서비스의 사용에는 &lt;a href=&quot;https://developer.here.com/terms-conditions&quot;&gt;https://developer.here.com/terms-conditions&lt;/a&gt; 에서 제공되는 이용 약관이 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="2c6b963147a1da2032ab05a77d5838e725251a4c" translate="yes" xml:space="preserve">
          <source>Included with Qt Location is a position plugin which parses NMEA sentences streamed over a serial port into position updates.</source>
          <target state="translated">Qt Location에는 직렬 포트를 통해 스트리밍되는 NMEA 문장을 위치 업데이트로 구문 분석하는 위치 플러그인이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="d569de260153324cc660bf88ca63fd98a1a150b0" translate="yes" xml:space="preserve">
          <source>Includes hyperlinks in the keyboard focus chain.</source>
          <target state="translated">키보드 포커스 체인에 하이퍼 링크를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="1c849db5e8ff69f5eb683d3cbc1d8d5da69f91c2" translate="yes" xml:space="preserve">
          <source>Includes hyperlinks in the keyboard focus chain. Enabled by default.</source>
          <target state="translated">키보드 포커스 체인에 하이퍼 링크를 포함합니다. 기본적으로 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="e649bd4c7484a7480998b955eefa61137cce0dd4" translate="yes" xml:space="preserve">
          <source>Includes positive leading into the line's height if</source>
          <target state="translated">다음과 같은 경우 선의 높이에 양의 선행을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="4d331ec1b5532bcdd2585ae71345ec5b7c8c8142" translate="yes" xml:space="preserve">
          <source>Includes support for large files.</source>
          <target state="translated">대용량 파일에 대한 지원을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="9537403951f876c585489f46ebb3f178eb06acce" translate="yes" xml:space="preserve">
          <source>Includes the contents of the file specified by &lt;code&gt;filename&lt;/code&gt; into the current project at the point where it is included. This function succeeds if &lt;code&gt;filename&lt;/code&gt; is included; otherwise it fails. The included file is processed immediately.</source>
          <target state="translated">파일 이 포함 된 지점의 현재 프로젝트 에 &lt;code&gt;filename&lt;/code&gt; 으로 지정된 파일의 내용을 포함합니다. 이 함수는 &lt;code&gt;filename&lt;/code&gt; 이 포함 되면 성공합니다 . 그렇지 않으면 실패합니다. 포함 된 파일은 즉시 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="fdebf884b6e907f3e0c870709f3f4f971442f558" translate="yes" xml:space="preserve">
          <source>Including Code Inline</source>
          <target state="translated">코드 인라인 포함</target>
        </trans-unit>
        <trans-unit id="b3c5bddc09025dbb9697b087115765dd1bc3f074" translate="yes" xml:space="preserve">
          <source>Including External Code</source>
          <target state="translated">외부 코드 포함</target>
        </trans-unit>
        <trans-unit id="162fc00796665e805cdbe5354ecaf6f537a91aaa" translate="yes" xml:space="preserve">
          <source>Including Images</source>
          <target state="translated">이미지 포함</target>
        </trans-unit>
        <trans-unit id="f66c9197819af94c241fed0685c70e963b6c3180" translate="yes" xml:space="preserve">
          <source>Including code from external files</source>
          <target state="translated">외부 파일의 코드 포함</target>
        </trans-unit>
        <trans-unit id="7d9004f2ac9daa58c0222e68740d69eb89751b43" translate="yes" xml:space="preserve">
          <source>Including functionality from a library</source>
          <target state="translated">라이브러리의 기능 포함</target>
        </trans-unit>
        <trans-unit id="856357e2aaf151cc1159095a68744a63da15f37f" translate="yes" xml:space="preserve">
          <source>Including or Excluding Features</source>
          <target state="translated">기능 포함 또는 제외</target>
        </trans-unit>
        <trans-unit id="7e099b85912a418d4799b87042d73980c99c1e90" translate="yes" xml:space="preserve">
          <source>Including third-party Android libraries in an application</source>
          <target state="translated">애플리케이션에 타사 Android 라이브러리 포함</target>
        </trans-unit>
        <trans-unit id="a9c615b9e833ee226ac08cb33f93df17a615ca30" translate="yes" xml:space="preserve">
          <source>Incoming</source>
          <target state="translated">Incoming</target>
        </trans-unit>
        <trans-unit id="1662c834da328dd49f9925394ce54d2977405850" translate="yes" xml:space="preserve">
          <source>Incorrectly specified fields of the</source>
          <target state="translated">잘못 지정된 필드</target>
        </trans-unit>
        <trans-unit id="65d0253fa9adea6544b473e4c2fb8022218e9e72" translate="yes" xml:space="preserve">
          <source>Increase &lt;a href=&quot;qml-qtquick-controls2-dial#value-prop&quot;&gt;value&lt;/a&gt; by &lt;a href=&quot;qml-qtquick-controls2-dial#stepSize-prop&quot;&gt;stepSize&lt;/a&gt;</source>
          <target state="translated">증가 &lt;a href=&quot;qml-qtquick-controls2-dial#value-prop&quot;&gt;값을&lt;/a&gt; 하여 &lt;a href=&quot;qml-qtquick-controls2-dial#stepSize-prop&quot;&gt;스텝 사이즈&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="59c6cc71943b2dbe81617bc9ff88abaf82aae7ec" translate="yes" xml:space="preserve">
          <source>Increase symbol for a spin widget.</source>
          <target state="translated">스핀 위젯의 기호를 늘립니다.</target>
        </trans-unit>
        <trans-unit id="72200e94e65fbdb4dcaef69fd0f8a494fbcd1d08" translate="yes" xml:space="preserve">
          <source>Increased main memory consumption</source>
          <target state="translated">메인 메모리 소비 증가</target>
        </trans-unit>
        <trans-unit id="96f548068c72cb26a7dd9cd66ce0ceb9017ef1fb" translate="yes" xml:space="preserve">
          <source>Increased video memory consumption</source>
          <target state="translated">비디오 메모리 소비 증가</target>
        </trans-unit>
        <trans-unit id="972b711e7504ba6852948d3b603652176d23cc52" translate="yes" xml:space="preserve">
          <source>Increases or decreases the size of each unit in the canvas grid by multiplying the scale factors to the current tranform matrix.</source>
          <target state="translated">배율 계수를 현재 변환 행렬에 곱하여 캔버스 그리드에서 각 단위의 크기를 늘리거나 줄입니다.</target>
        </trans-unit>
        <trans-unit id="b74011f7eaf5f0a592695e2976fa648b7f0308f6" translate="yes" xml:space="preserve">
          <source>Increases the position by &lt;a href=&quot;qml-qtquick-controls2-scrollbar#stepSize-prop&quot;&gt;stepSize&lt;/a&gt; or &lt;code&gt;0.1&lt;/code&gt; if &lt;a href=&quot;qml-qtquick-controls2-scrollbar#stepSize-prop&quot;&gt;stepSize&lt;/a&gt; is &lt;code&gt;0.0&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-controls2-scrollbar#stepSize-prop&quot;&gt;stepSize&lt;/a&gt; 가 &lt;code&gt;0.0&lt;/code&gt; 이면 위치를 &lt;a href=&quot;qml-qtquick-controls2-scrollbar#stepSize-prop&quot;&gt;stepSize&lt;/a&gt; 또는 &lt;code&gt;0.1&lt;/code&gt; 만큼 늘립니다 .</target>
        </trans-unit>
        <trans-unit id="1d03609d2de69e408ae3d5957ad5e63d281153fa" translate="yes" xml:space="preserve">
          <source>Increases the value by &lt;a href=&quot;qml-qtquick-controls2-dial#stepSize-prop&quot;&gt;stepSize&lt;/a&gt;, or &lt;code&gt;0.1&lt;/code&gt; if &lt;a href=&quot;qml-qtquick-controls2-dial#stepSize-prop&quot;&gt;stepSize&lt;/a&gt; is not defined.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-controls2-dial#stepSize-prop&quot;&gt;stepSize&lt;/a&gt; 값을 증가 시키 거나 &lt;a href=&quot;qml-qtquick-controls2-dial#stepSize-prop&quot;&gt;stepSize&lt;/a&gt; 가 정의되지 않은 경우 &lt;code&gt;0.1&lt;/code&gt; 증가합니다 .</target>
        </trans-unit>
        <trans-unit id="62ac7a10eeaa4913c0ad4d27923ce83a7641d638" translate="yes" xml:space="preserve">
          <source>Increases the value by &lt;a href=&quot;qml-qtquick-controls2-slider#stepSize-prop&quot;&gt;stepSize&lt;/a&gt; or &lt;code&gt;0.1&lt;/code&gt; if &lt;a href=&quot;qml-qtquick-controls2-slider#stepSize-prop&quot;&gt;stepSize&lt;/a&gt; is not defined.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-controls2-slider#stepSize-prop&quot;&gt;stepSize&lt;/a&gt; 가 정의되지 않은 경우 값을 &lt;a href=&quot;qml-qtquick-controls2-slider#stepSize-prop&quot;&gt;stepSize&lt;/a&gt; 또는 &lt;code&gt;0.1&lt;/code&gt; 만큼 증가시킵니다 .</target>
        </trans-unit>
        <trans-unit id="a70e17687bf9ad714b29afd37043cb03b0ef05ee" translate="yes" xml:space="preserve">
          <source>Increases the value by &lt;a href=&quot;qml-qtquick-controls2-spinbox#stepSize-prop&quot;&gt;stepSize&lt;/a&gt;, or &lt;code&gt;1&lt;/code&gt; if &lt;a href=&quot;qml-qtquick-controls2-spinbox#stepSize-prop&quot;&gt;stepSize&lt;/a&gt; is not defined.</source>
          <target state="translated">값을 &lt;a href=&quot;qml-qtquick-controls2-spinbox#stepSize-prop&quot;&gt;stepSize로&lt;/a&gt; 늘리 거나 &lt;a href=&quot;qml-qtquick-controls2-spinbox#stepSize-prop&quot;&gt;stepSize&lt;/a&gt; 가 정의되지 않은 경우 &lt;code&gt;1&lt;/code&gt; 을 늘 립니다.</target>
        </trans-unit>
        <trans-unit id="f967605cd5f92bae360c81a37ac31cc3808f3157" translate="yes" xml:space="preserve">
          <source>Increases the value of the handle by &lt;a href=&quot;qml-qtquick-controls2-rangeslider#stepSize-prop&quot;&gt;stepSize&lt;/a&gt;, or &lt;code&gt;0.1&lt;/code&gt; if &lt;a href=&quot;qml-qtquick-controls2-rangeslider#stepSize-prop&quot;&gt;stepSize&lt;/a&gt; is not defined.</source>
          <target state="translated">핸들의 값을 &lt;a href=&quot;qml-qtquick-controls2-rangeslider#stepSize-prop&quot;&gt;stepSize로&lt;/a&gt; 늘리 거나 &lt;a href=&quot;qml-qtquick-controls2-rangeslider#stepSize-prop&quot;&gt;stepSize&lt;/a&gt; 가 정의되지 않은 경우 &lt;code&gt;0.1&lt;/code&gt; 을 늘 립니다.</target>
        </trans-unit>
        <trans-unit id="4eb4e0020909cf6d1687c289073922fe280a1314" translate="yes" xml:space="preserve">
          <source>Increment current value with saturation.</source>
          <target state="translated">포화 상태로 현재 값을 증가시킵니다.</target>
        </trans-unit>
        <trans-unit id="b720dc5837e48a90b2afa9e9e921a3f1e403a66c" translate="yes" xml:space="preserve">
          <source>Increment current value with wrap.</source>
          <target state="translated">랩으로 현재 값을 증가시킵니다.</target>
        </trans-unit>
        <trans-unit id="aeb94002b77a917f8b5069093085a0db653f7cc2" translate="yes" xml:space="preserve">
          <source>Increment or decrement the register's value.</source>
          <target state="translated">레지스터 값을 늘리거나 줄입니다.</target>
        </trans-unit>
        <trans-unit id="8325b6f89469788903b5501e21a6c242bd86b91e" translate="yes" xml:space="preserve">
          <source>Incremental Parsing</source>
          <target state="translated">증분 구문 분석</target>
        </trans-unit>
        <trans-unit id="6865b823869c9d02fe065513aa1d9a243113e20d" translate="yes" xml:space="preserve">
          <source>Incremental matching is another use case of partial matching. Suppose that we want to find the occurrences of a regular expression inside a large text (that is, substrings matching the regular expression). In order to do so we would like to &quot;feed&quot; the large text to the regular expression engines in smaller chunks. The obvious problem is what happens if the substring that matches the regular expression spans across two or more chunks.</source>
          <target state="translated">증분 일치는 부분 일치의 또 다른 사용 사례입니다. 큰 텍스트 (즉, 정규식과 일치하는 부분 문자열) 내에서 정규식의 발생을 찾고 싶다고 가정합니다. 그렇게하기 위해 큰 텍스트를 더 작은 청크로 정규식 엔진에 &quot;공급&quot;하고 싶습니다. 명백한 문제는 정규 표현식과 일치하는 하위 문자열이 둘 이상의 청크에 걸쳐있는 경우 발생하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="be2ef83dc5379c3316f94043edcf99b84a63aaba" translate="yes" xml:space="preserve">
          <source>Incremental/multi-segment matching</source>
          <target state="translated">증분 / 다중 세그먼트 매칭</target>
        </trans-unit>
        <trans-unit id="0e4e4509dd1e1168aea8972ee5993792d8a787e8" translate="yes" xml:space="preserve">
          <source>Increments the current index of the combo box, or the highlighted index if the popup list is visible.</source>
          <target state="translated">콤보 상자의 현재 색인을 증가 시키거나 팝업 목록이 표시되는 경우 강조 표시된 색인을 증가시킵니다.</target>
        </trans-unit>
        <trans-unit id="bcff447ff7e30525b1cc9dc422b164496cd6a0fa" translate="yes" xml:space="preserve">
          <source>Increments the current index of the container.</source>
          <target state="translated">컨테이너의 현재 인덱스를 증가시킵니다.</target>
        </trans-unit>
        <trans-unit id="736aad4b43d683dc580afa1f57fd75fa8f4c826e" translate="yes" xml:space="preserve">
          <source>Increments the current index.</source>
          <target state="translated">현재 인덱스를 증가시킵니다.</target>
        </trans-unit>
        <trans-unit id="03ccbc7ba6a2bbea4a64d38a4493181ea53b9db3" translate="yes" xml:space="preserve">
          <source>Increments the current index. The current index will wrap if &lt;a href=&quot;qml-qtquick-listview#keyNavigationWraps-prop&quot;&gt;keyNavigationWraps&lt;/a&gt; is true and it is currently at the end. This method has no effect if the &lt;a href=&quot;qml-qtquick-listview#count-prop&quot;&gt;count&lt;/a&gt; is zero.</source>
          <target state="translated">현재 인덱스를 증가시킵니다. 현재 색인은 &lt;a href=&quot;qml-qtquick-listview#keyNavigationWraps-prop&quot;&gt;keyNavigationWraps&lt;/a&gt; 가 true이고 현재 끝에있는 경우 랩핑됩니다 . 이 방법은 &lt;a href=&quot;qml-qtquick-listview#count-prop&quot;&gt;개수&lt;/a&gt; 가 0 이면 효과가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="ca634115aab3375e0033854281ceb6850d8f47ec" translate="yes" xml:space="preserve">
          <source>Increments the frequency by the frequency step for the current band. If the frequency is already set to the maximum frequency, calling this function has no effect.</source>
          <target state="translated">현재 대역의 주파수 단계로 주파수를 증가시킵니다. 주파수가 이미 최대 주파수로 설정된 경우이 함수를 호출해도 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="bd2cea1a3b7b77176b8d8230598f46e037025713" translate="yes" xml:space="preserve">
          <source>Incubate objects for</source>
          <target state="translated">개체 배양</target>
        </trans-unit>
        <trans-unit id="bd4f6615f4d3895046ffbfc5eaf1f153cd38c17c" translate="yes" xml:space="preserve">
          <source>Incubate objects while the atomic bool pointed to by</source>
          <target state="translated">원자 부울이 가리키는 동안 개체를 부화</target>
        </trans-unit>
        <trans-unit id="131332e4d2b14520e4243e2e585e985e5d98be1e" translate="yes" xml:space="preserve">
          <source>Incubate objects while the bool pointed to by</source>
          <target state="translated">부울이 가리키는 동안 개체를 부화</target>
        </trans-unit>
        <trans-unit id="68c573fd192ca06c4bbf84538623d2d2c22462e0" translate="yes" xml:space="preserve">
          <source>Incubation is not in progress. Call &lt;a href=&quot;qqmlcomponent#create&quot;&gt;QQmlComponent::create&lt;/a&gt;() to begin incubating.</source>
          <target state="translated">부화가 진행 중이 아닙니다. &lt;a href=&quot;qqmlcomponent#create&quot;&gt;QQmlComponent :: create&lt;/a&gt; ()를 호출 하여 배양을 시작합니다.</target>
        </trans-unit>
        <trans-unit id="2bc954f59122dd3ee3047d2bbb9dfd755e6351df" translate="yes" xml:space="preserve">
          <source>Indented paragraph</source>
          <target state="translated">들여 쓴 단락</target>
        </trans-unit>
        <trans-unit id="9fcdaccaad8839ab1b42e407591e47607de7a598" translate="yes" xml:space="preserve">
          <source>Indents the lines containing the selection or the cursor. Requires &lt;code&gt;contenteditable=&quot;true&quot;&lt;/code&gt;. (Added in Qt 5.10)</source>
          <target state="translated">선택 영역이나 커서가 포함 된 줄을 들여 씁니다. &lt;code&gt;contenteditable=&quot;true&quot;&lt;/code&gt; 가 필요합니다 . (Qt 5.10에 추가됨)</target>
        </trans-unit>
        <trans-unit id="32fef16cf420cf48dc1c80289415d6ce9d160bf8" translate="yes" xml:space="preserve">
          <source>Indents the list items by the specified no. of spaces.</source>
          <target state="translated">지정된 번호만큼 목록 항목을 들여 씁니다. 공간의.</target>
        </trans-unit>
        <trans-unit id="2982272409c65733299a01bd09cdae127160f053" translate="yes" xml:space="preserve">
          <source>Indents the text block by the specified no. spaces.</source>
          <target state="translated">지정된 번호만큼 텍스트 블록을 들여 씁니다. 공백.</target>
        </trans-unit>
        <trans-unit id="d1e77004038f7675f76eed50bd58a65fc137f3fe" translate="yes" xml:space="preserve">
          <source>Independent JPEG Group License</source>
          <target state="translated">독립 JPEG 그룹 라이선스</target>
        </trans-unit>
        <trans-unit id="24f8e6a8f27b3389c6c800cff28611a2b5eba29f" translate="yes" xml:space="preserve">
          <source>Independent of the platform you are building for, consider using the &lt;code&gt;-prefix&lt;/code&gt; option with &lt;code&gt;configure&lt;/code&gt; as well, for example, &lt;code&gt;-prefix&amp;lt;Qt-install-path&amp;gt;&lt;/code&gt;. This specifies the target folder where Qt will be installed and places all build artifacts outside of the source code tree.</source>
          <target state="translated">빌드하는 플랫폼에 관계없이 &lt;code&gt;configure&lt;/code&gt; 와 함께 &lt;code&gt;-prefix&lt;/code&gt; 옵션을 사용하는 것을 고려하십시오 ( 예 : &lt;code&gt;-prefix&amp;lt;Qt-install-path&amp;gt;&lt;/code&gt; . 이것은 Qt가 설치 될 대상 폴더를 지정하고 모든 빌드 아티팩트를 소스 코드 트리 외부에 배치합니다.</target>
        </trans-unit>
        <trans-unit id="17b9aba350712ae49b8566a901f158d5cb30979f" translate="yes" xml:space="preserve">
          <source>Independently maps the planes of a video buffer to memory.</source>
          <target state="translated">비디오 버퍼의 평면을 메모리에 독립적으로 매핑합니다.</target>
        </trans-unit>
        <trans-unit id="14d888a344d8120f86bc098e3dfc1aaf67f2bd11" translate="yes" xml:space="preserve">
          <source>Indeterminate progress bars have the &lt;a href=&quot;#indeterminate-ps&quot;&gt;:indeterminate&lt;/a&gt; pseudo state set.</source>
          <target state="translated">Indeterminate 진행률 표시 줄에는 &lt;a href=&quot;#indeterminate-ps&quot;&gt;: indeterminate&lt;/a&gt; 의사 상태가 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="b2abeb20071c8d68c473589d8bf3c00c08e4215d" translate="yes" xml:space="preserve">
          <source>Indeterminate progress bars have the &lt;a href=&quot;stylesheet-reference#indeterminate-ps&quot;&gt;:indeterminate&lt;/a&gt; pseudo state set.</source>
          <target state="translated">Indeterminate 진행률 표시 줄에는 &lt;a href=&quot;stylesheet-reference#indeterminate-ps&quot;&gt;: indeterminate&lt;/a&gt; 의사 상태가 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="3b2129be9156ad1e174b83921ce16cfb7cdd85b4" translate="yes" xml:space="preserve">
          <source>Indeterminate-length arrays and maps</source>
          <target state="translated">길이가 불확실한 배열 및 맵</target>
        </trans-unit>
        <trans-unit id="a7ead966bdda1bf50f59f483a5fd7af21f4e86a9" translate="yes" xml:space="preserve">
          <source>Index buffer object for use with &lt;code&gt;glDrawElements()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;glDrawElements()&lt;/code&gt; 와 함께 사용할 인덱스 버퍼 객체입니다 .</target>
        </trans-unit>
        <trans-unit id="e77c60d2487285afad6121cf2062c6c874a73239" translate="yes" xml:space="preserve">
          <source>Index holds the index of the item in that group.</source>
          <target state="translated">Index는 해당 그룹에있는 항목의 인덱스를 보유합니다.</target>
        </trans-unit>
        <trans-unit id="f1bf59b651793f02cb34f2835888abbba8be345b" translate="yes" xml:space="preserve">
          <source>Index lookup</source>
          <target state="translated">인덱스 조회</target>
        </trans-unit>
        <trans-unit id="b0cfd86511ad956c264568737ea4297f96c33398" translate="yes" xml:space="preserve">
          <source>Index of refraction for the material. Sensible range for different types of glass is &lt;code&gt;[1.4, 2.1]&lt;/code&gt;. Default is &lt;code&gt;1.5&lt;/code&gt;.</source>
          <target state="translated">재료의 굴절률입니다. 다양한 유형의 유리에 대한 감지 범위는 &lt;code&gt;[1.4, 2.1]&lt;/code&gt; 입니다. 기본값은 &lt;code&gt;1.5&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="518539f18eb55b228526ffb5d496243cc5c9fe10" translate="yes" xml:space="preserve">
          <source>Index of refraction for the material. Sensible range for different types of metals is &lt;code&gt;[0.47, 2.97]&lt;/code&gt;. Default is &lt;code&gt;2.5&lt;/code&gt;.</source>
          <target state="translated">재료의 굴절률입니다. 다양한 유형의 금속에 대한 현명한 범위는 &lt;code&gt;[0.47, 2.97]&lt;/code&gt; 입니다. 기본값은 &lt;code&gt;2.5&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="049d58a62ac11670f58bb55ce5aa188f58562ae0" translate="yes" xml:space="preserve">
          <source>Index of refraction for the material. Sensible range for different types of plastic is &lt;code&gt;[1.4, 1.6]&lt;/code&gt;. Default is &lt;code&gt;1.46&lt;/code&gt;.</source>
          <target state="translated">재료의 굴절률입니다. 다양한 유형의 플라스틱에 대한 합리적인 범위는 &lt;code&gt;[1.4, 1.6]&lt;/code&gt; 입니다. 기본값은 &lt;code&gt;1.46&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6e922b2c22934818c7ea8b38335c86eb63c06e22" translate="yes" xml:space="preserve">
          <source>Index of the current sort column. The default value is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">현재 정렬 열의 인덱스입니다. 기본값은 &lt;code&gt;0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="52765638c736c9a309f500b2da081ce965f87bab" translate="yes" xml:space="preserve">
          <source>Index of the light to sample.</source>
          <target state="translated">샘플링 할 빛의 인덱스입니다.</target>
        </trans-unit>
        <trans-unit id="480bc7af482c797601c22c871ee5715554b5661e" translate="yes" xml:space="preserve">
          <source>Index-of-refraction.</source>
          <target state="translated">Index-of-refraction.</target>
        </trans-unit>
        <trans-unit id="e13750d42d812c304f674805f75db4f2bea5ac85" translate="yes" xml:space="preserve">
          <source>IndexAttribute: used to define vertex indices when indexed draw calls are to be used</source>
          <target state="translated">IndexAttribute : 인덱싱 된 그리기 호출을 사용할 때 정점 인덱스를 정의하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="35eea435e2403229f2f807cea82dc5cd9a64c57f" translate="yes" xml:space="preserve">
          <source>Indexes in this array match column indexes in rows. If the list is shorter than the longest row, all columns will not get labels.</source>
          <target state="translated">이 배열의 인덱스는 행의 열 인덱스와 일치합니다. 목록이 가장 긴 행보다 짧으면 모든 열에 레이블이 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fc10c268c2fc61dd44953d39e441a052e071500d" translate="yes" xml:space="preserve">
          <source>Indexes in this array match the row indexes in the data array. If the list is shorter than the number of rows, all rows will not get labels.</source>
          <target state="translated">이 배열의 인덱스는 데이터 배열의 행 인덱스와 일치합니다. 목록이 행 수보다 짧으면 모든 행에 레이블이 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="683d23d64559d9c2833316c72904cd887afca2a0" translate="yes" xml:space="preserve">
          <source>Indexing:</source>
          <target state="translated">Indexing:</target>
        </trans-unit>
        <trans-unit id="4ceea0e53e34df925a02cd2a10ec84d7040e4aa1" translate="yes" xml:space="preserve">
          <source>Indicate that this icon is a mask image(boolean</source>
          <target state="translated">이 아이콘이 마스크 이미지임을 나타냅니다 (부울</target>
        </trans-unit>
        <trans-unit id="28442d79ffab853a4710987844112f8a0d0397e5" translate="yes" xml:space="preserve">
          <source>Indicates a &quot;tri-state&quot; checkbox.</source>
          <target state="translated">&quot;tri-state&quot;확인란을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b059c7dea46e3cbe9ad71872ceba9452158db58c" translate="yes" xml:space="preserve">
          <source>Indicates a &quot;tri-state&quot; controller.</source>
          <target state="translated">&quot;tri-state&quot;컨트롤러를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f02095f9320d1b1ae7ab42f0470ed32e4d246195" translate="yes" xml:space="preserve">
          <source>Indicates a flat frame.</source>
          <target state="translated">플랫 프레임을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="1b1f51dafdba84057684cfb9cfbf0fe29240c5ab" translate="yes" xml:space="preserve">
          <source>Indicates a flat push button.</source>
          <target state="translated">평평한 누름 버튼을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b56f1cdd9f6c8c4329a4fac2c8d4cabaf3dbe76a" translate="yes" xml:space="preserve">
          <source>Indicates a normal frame.</source>
          <target state="translated">일반 프레임을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="395af2db702eeca9a5c0147443982ff4e5a798fa" translate="yes" xml:space="preserve">
          <source>Indicates a normal item.</source>
          <target state="translated">일반 항목을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="1400195027e002b58865ed67dfae16c32e12f56a" translate="yes" xml:space="preserve">
          <source>Indicates a normal push button.</source>
          <target state="translated">일반 푸시 버튼을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="efc61e131144dcf7258173a64a9743d16382f010" translate="yes" xml:space="preserve">
          <source>Indicates a rounded frame.</source>
          <target state="translated">둥근 프레임을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="3fd8c95a1078b0d22278c999c6a97adf9a94fbe8" translate="yes" xml:space="preserve">
          <source>Indicates all possible error conditions found during Bluetooth device discovery.</source>
          <target state="translated">Bluetooth 장치 검색 중에 발견 된 모든 가능한 오류 조건을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="597757379af00d19ee4c0fa35a5c58f575c2191e" translate="yes" xml:space="preserve">
          <source>Indicates all possible error conditions found during the controller's existence.</source>
          <target state="translated">컨트롤러가 존재하는 동안 발견 된 모든 가능한 오류 조건을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="73933a718658b0e4aa2fa26ccfc465e40489e6bb" translate="yes" xml:space="preserve">
          <source>Indicates all possible error conditions found during the processing of the DNS lookup.</source>
          <target state="translated">DNS 조회를 처리하는 동안 발견 된 모든 가능한 오류 조건을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f5e7b31e1610dc299c48c0036a59b7f76d25fe1e" translate="yes" xml:space="preserve">
          <source>Indicates all possible error conditions found during the processing of the request.</source>
          <target state="translated">요청을 처리하는 동안 발견 된 모든 가능한 오류 조건을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="0ef61a23958ccbdd8adc762ea357d4368e7878d0" translate="yes" xml:space="preserve">
          <source>Indicates an item with wrapped text.</source>
          <target state="translated">줄 바꿈 된 텍스트가있는 항목을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="039cdbd1eab66a69fa13c9c9455ba4601e7cffb0" translate="yes" xml:space="preserve">
          <source>Indicates audio is muted.</source>
          <target state="translated">오디오가 음소거되었음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="26996ad14d32e630405daf001545fd1b0086ede6" translate="yes" xml:space="preserve">
          <source>Indicates background activity, for example, while content is being loaded</source>
          <target state="translated">예를 들어 컨텐츠가로드되는 동안 백그라운드 활동을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="417dfbe8ebc8216d5268243c93748bc1c5859f53" translate="yes" xml:space="preserve">
          <source>Indicates background activity, for example, while content is being loaded. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">예를 들어 컨텐츠가로드되는 동안 백그라운드 활동을 나타냅니다. &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e197706536cbdddfdb457427fc860a6711262cc2" translate="yes" xml:space="preserve">
          <source>Indicates how a &lt;a href=&quot;qt3dcore-qnode&quot;&gt;QNode&lt;/a&gt; listens for property updates.</source>
          <target state="translated">&lt;a href=&quot;qt3dcore-qnode&quot;&gt;QNode&lt;/a&gt; 가 특성 업데이트를 청취 하는 방법을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="362c2072f957e000d8beac0a22f80f264a9b8d3d" translate="yes" xml:space="preserve">
          <source>Indicates how full the data buffer is: 0.0 (empty) to 1.0 (full).</source>
          <target state="translated">데이터 버퍼가 가득 찬 정도를 나타냅니다. 0.0 (빈) ~ 1.0 (전체).</target>
        </trans-unit>
        <trans-unit id="6435a8d9a02c28835c04d333e53e588cb042f14e" translate="yes" xml:space="preserve">
          <source>Indicates if an aspect of the request's loading mechanism has been manually overridden, e.g. by Qt WebKit.</source>
          <target state="translated">요청 로딩 메커니즘의 측면이 Qt WebKit에 의해 수동으로 대체되었는지 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="4aa0a0a2a3c7de3a4e47f09d7ec6c50054076697" translate="yes" xml:space="preserve">
          <source>Indicates if loading of media should begin immediately.</source>
          <target state="translated">용지 공급을 즉시 시작해야하는지 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="0d18cb29ecaf1ef5e8442a72c84d6087468942fa" translate="yes" xml:space="preserve">
          <source>Indicates if the alpha information coming from the diffuse property will be taken into account during rendering. Defaults to false.</source>
          <target state="translated">렌더링 중에 확산 속성에서 오는 알파 정보가 고려되는지 여부를 나타냅니다. 기본값은 false입니다.</target>
        </trans-unit>
        <trans-unit id="784c9189821a1588ef7bbfc47d1513f7b678e3bf" translate="yes" xml:space="preserve">
          <source>Indicates if the file name filter details are hidden or not.</source>
          <target state="translated">파일 이름 필터 세부 사항이 숨겨져 있는지 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e946313b417d40277d4749fce157cf1368bdd303" translate="yes" xml:space="preserve">
          <source>Indicates if the flash is charged and ready to use.</source>
          <target state="translated">플래시가 충전되어 사용할 준비가되었는지 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="1393953ba17a61f7f429ebb290112b529370fdb2" translate="yes" xml:space="preserve">
          <source>Indicates if the renderer applies frustum culling to the scene.</source>
          <target state="translated">렌더러가 절두체 컬링을 장면에 적용하는지 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="7b8b439b901aa8a12bfc27f33bdc257a1cf79112" translate="yes" xml:space="preserve">
          <source>Indicates if the title bar should show a '*' for windows that are modified.</source>
          <target state="translated">제목 표시 줄에 수정 된 창의 '*'가 표시되어야하는지 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="822e6973a58317750e4e255672d02668b380c76c" translate="yes" xml:space="preserve">
          <source>Indicates that</source>
          <target state="translated">표시</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
