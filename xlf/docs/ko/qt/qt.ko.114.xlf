<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="qt">
    <body>
      <group id="qt">
        <trans-unit id="d32fff3763785084f6983df6bdfb6db3a87985f8" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qobjectcleanuphandler&quot;&gt;QObjectCleanupHandler&lt;/a&gt; is useful whenever you need to know when a number of &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;s that are owned by someone else have been deleted. This is important, for example, when referencing memory in an application that has been allocated in a shared library.</source>
          <target state="translated">&lt;a href=&quot;qobjectcleanuphandler&quot;&gt;QObjectCleanupHandler은&lt;/a&gt; 당신의 숫자 때 알아야 할 때마다 유용 &lt;a href=&quot;qobject&quot;&gt;QObject를&lt;/a&gt; 다른 사람 소유의이 삭제되었습니다. 예를 들어 공유 라이브러리에 할당 된 응용 프로그램에서 메모리를 참조 할 때 중요합니다.</target>
        </trans-unit>
        <trans-unit id="c7b371901429367f3cd2294111f50bd72868303f" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qpagesize&quot;&gt;QPageSize&lt;/a&gt; instance may also be obtained by querying the supported page sizes for a print device. In this case the localized name returned is that defined by the printer itself. Note that the print device may not support the current default locale language.</source>
          <target state="translated">&lt;a href=&quot;qpagesize&quot;&gt;QPageSize의&lt;/a&gt; 인스턴스는 인쇄 장치에 지원되는 페이지 크기를 조회하여 획득 될 수있다. 이 경우 반환되는 지역화 된 이름은 프린터 자체에서 정의한 이름입니다. 인쇄 장치가 현재 기본 로케일 언어를 지원하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c2748635b43826937ef79e05a950ac084d30256" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qpainterpath&quot;&gt;QPainterPath&lt;/a&gt; object can be constructed as an empty path, with a given start point, or as a copy of another &lt;a href=&quot;qpainterpath&quot;&gt;QPainterPath&lt;/a&gt; object. Once created, lines and curves can be added to the path using the &lt;a href=&quot;qpainterpath#lineTo&quot;&gt;lineTo&lt;/a&gt;(), &lt;a href=&quot;qpainterpath#arcTo&quot;&gt;arcTo&lt;/a&gt;(), &lt;a href=&quot;qpainterpath#cubicTo&quot;&gt;cubicTo&lt;/a&gt;() and &lt;a href=&quot;qpainterpath#quadTo&quot;&gt;quadTo&lt;/a&gt;() functions. The lines and curves stretch from the &lt;a href=&quot;qpainterpath#currentPosition&quot;&gt;currentPosition&lt;/a&gt;() to the position passed as argument.</source>
          <target state="translated">&lt;a href=&quot;qpainterpath&quot;&gt;QPainterPath의&lt;/a&gt; 객체는 주어진 시작점에 빈 경로로 구성, 또는 다른 사본으로 할 수 &lt;a href=&quot;qpainterpath&quot;&gt;QPainterPath의&lt;/a&gt; 객체입니다. 일단 만들어지면 &lt;a href=&quot;qpainterpath#lineTo&quot;&gt;lineTo&lt;/a&gt; (), &lt;a href=&quot;qpainterpath#arcTo&quot;&gt;arcTo&lt;/a&gt; (), &lt;a href=&quot;qpainterpath#cubicTo&quot;&gt;cubicTo&lt;/a&gt; () 및 &lt;a href=&quot;qpainterpath#quadTo&quot;&gt;quadTo&lt;/a&gt; () 함수를 사용하여 선과 곡선을 경로에 추가 할 수 있습니다 . 선과 곡선은 &lt;a href=&quot;qpainterpath#currentPosition&quot;&gt;currentPosition&lt;/a&gt; ()에서 인수로 전달 된 위치로 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="ac0e154e045226a93ecee4e1df38f277e4219ca7" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qpainterpath&quot;&gt;QPainterPath&lt;/a&gt; object can be used for filling, outlining, and clipping. To generate fillable outlines for a given painter path, use the &lt;a href=&quot;qpainterpathstroker&quot;&gt;QPainterPathStroker&lt;/a&gt; class.</source>
          <target state="translated">&lt;a href=&quot;qpainterpath&quot;&gt;QPainterPath의&lt;/a&gt; 객체 작성, 요약 및 클리핑 사용할 수 있습니다. 주어진 페인터 경로에 채울 수있는 아웃 라인을 생성하려면 &lt;a href=&quot;qpainterpathstroker&quot;&gt;QPainterPathStroker&lt;/a&gt; 클래스를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="ebc0a7fdd93957515d8f4289241d571e0cc9a707" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qpainterpath&quot;&gt;QPainterPath&lt;/a&gt; object can be used for filling, outlining, and clipping. To generate fillable outlines for a given painter path, use the &lt;a href=&quot;qpainterpathstroker&quot;&gt;QPainterPathStroker&lt;/a&gt; class. The main advantage of painter paths over normal drawing operations is that complex shapes only need to be created once; then they can be drawn many times using only calls to the &lt;a href=&quot;qpainter#drawPath&quot;&gt;QPainter::drawPath&lt;/a&gt;() function.</source>
          <target state="translated">&lt;a href=&quot;qpainterpath&quot;&gt;QPainterPath의&lt;/a&gt; 객체 작성, 요약 및 클리핑 사용할 수 있습니다. 주어진 페인터 경로에 채울 수있는 아웃 라인을 생성하려면 &lt;a href=&quot;qpainterpathstroker&quot;&gt;QPainterPathStroker&lt;/a&gt; 클래스를 사용하십시오 . 일반적인 그리기 작업에 비해 화가 경로의 주요 장점은 복잡한 모양을 한 번만 만들면된다는 것입니다. 그러면 &lt;a href=&quot;qpainter#drawPath&quot;&gt;QPainter :: drawPath&lt;/a&gt; () 함수 에 대한 호출 만 사용하여 여러 번 그릴 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8857fd385ce049ea76a487038d3e6490a16138c4" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qpersistentmodelindex&quot;&gt;QPersistentModelIndex&lt;/a&gt; is a model index that can be stored by an application, and later used to access information in a model. Unlike the &lt;a href=&quot;qmodelindex&quot;&gt;QModelIndex&lt;/a&gt; class, it is safe to store a &lt;a href=&quot;qpersistentmodelindex&quot;&gt;QPersistentModelIndex&lt;/a&gt; since the model will ensure that references to items will continue to be valid as long as they can be accessed by the model.</source>
          <target state="translated">&lt;a href=&quot;qpersistentmodelindex&quot;&gt;QPersistentModelIndex은&lt;/a&gt; 애플리케이션에 의해 저장되고, 이후의 모델의 액세스 정보로 사용될 수있는 모델의 인덱스이다. 달리 &lt;a href=&quot;qmodelindex&quot;&gt;QModelIndex의&lt;/a&gt; 클래스, 저장하는 것이 안전 &lt;a href=&quot;qpersistentmodelindex&quot;&gt;QPersistentModelIndex을&lt;/a&gt; 모델들이 모델에 액세스 할 수있는 항목에 대한 참조가 긴로서 계속 유효 것을 보장하기 때문에.</target>
        </trans-unit>
        <trans-unit id="6932f1e6746d3e281ddaaa13c4f14116523a287e" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qpixmap&quot;&gt;QPixmap&lt;/a&gt; can easily be displayed on the screen using &lt;a href=&quot;qlabel&quot;&gt;QLabel&lt;/a&gt; or one of &lt;a href=&quot;qabstractbutton&quot;&gt;QAbstractButton&lt;/a&gt;'s subclasses (such as &lt;a href=&quot;qpushbutton&quot;&gt;QPushButton&lt;/a&gt; and &lt;a href=&quot;qtoolbutton&quot;&gt;QToolButton&lt;/a&gt;). &lt;a href=&quot;qlabel&quot;&gt;QLabel&lt;/a&gt; has a pixmap property, whereas &lt;a href=&quot;qabstractbutton&quot;&gt;QAbstractButton&lt;/a&gt; has an icon property.</source>
          <target state="translated">&lt;a href=&quot;qpixmap&quot;&gt;QPixmap은&lt;/a&gt; 쉽게 사용하여 화면에 표시 할 수 &lt;a href=&quot;qlabel&quot;&gt;QLabel&lt;/a&gt; 또는 하나 &lt;a href=&quot;qabstractbutton&quot;&gt;QAbstractButton&lt;/a&gt; (등의 서브 &lt;a href=&quot;qpushbutton&quot;&gt;QPushButton을&lt;/a&gt; 하고 &lt;a href=&quot;qtoolbutton&quot;&gt;QToolButton을&lt;/a&gt; ). &lt;a href=&quot;qlabel&quot;&gt;QLabel&lt;/a&gt; 에는 pixmap 속성이 있고 &lt;a href=&quot;qabstractbutton&quot;&gt;QAbstractButton&lt;/a&gt; 에는 icon 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f43ef5fc0ebf01e42a041d47d713c830c57b0807" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qpixmap&quot;&gt;QPixmap&lt;/a&gt; object can be converted into a &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt; using the &lt;a href=&quot;qpixmap#toImage&quot;&gt;toImage&lt;/a&gt;() function. Likewise, a &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt; can be converted into a &lt;a href=&quot;qpixmap&quot;&gt;QPixmap&lt;/a&gt; using the &lt;a href=&quot;qpixmap#fromImage&quot;&gt;fromImage&lt;/a&gt;(). If this is too expensive an operation, you can use &lt;a href=&quot;qbitmap#fromImage&quot;&gt;QBitmap::fromImage&lt;/a&gt;() instead.</source>
          <target state="translated">&lt;a href=&quot;qpixmap&quot;&gt;QPixmap의&lt;/a&gt; 목적은 변환 될 수 &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt; 은 USING &lt;a href=&quot;qpixmap#toImage&quot;&gt;toImage&lt;/a&gt; () 함수. 마찬가지로 &lt;a href=&quot;qpixmap#fromImage&quot;&gt;fromImage&lt;/a&gt; ()를 사용하여 &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt; 를 &lt;a href=&quot;qpixmap&quot;&gt;QPixmap&lt;/a&gt; 으로 변환 할 수 있습니다 . 이 작업이 너무 &lt;a href=&quot;qbitmap#fromImage&quot;&gt;비싸면 QBitmap :: fromImage&lt;/a&gt; ()를 대신 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7f5ee29bf6e70ef74e347c4afbfef6b75fc3c783" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qplaceattribute&quot;&gt;QPlaceAttribute&lt;/a&gt; instance stores an additional piece of information about a place that is not otherwise exposed through the &lt;a href=&quot;qplace&quot;&gt;QPlace&lt;/a&gt; class. A &lt;a href=&quot;qplaceattribute&quot;&gt;QPlaceAttribute&lt;/a&gt; encapsulates a localized label which describes the attribute and rich text string representing the attribute's value. Generally, both are intended to be displayed to the end-user as is.</source>
          <target state="translated">&lt;a href=&quot;qplaceattribute&quot;&gt;QPlaceAttribute의&lt;/a&gt; 인스턴스는 달리 통해 노출되지 않는 장소에 대한 정보의 추가 조각 저장 &lt;a href=&quot;qplace&quot;&gt;QPlace의&lt;/a&gt; 클래스를. &lt;a href=&quot;qplaceattribute&quot;&gt;QPlaceAttribute는&lt;/a&gt; 속성의 값을 나타내는 속성 및 서식있는 텍스트 문자열을 설명하는 지역화 된 라벨을 캡슐화합니다. 일반적으로 둘 다 최종 사용자에게있는 그대로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="2cee81ab4b771f20776435f8bd060d90ea618510" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qplaintextdocumentlayout&quot;&gt;QPlainTextDocumentLayout&lt;/a&gt; is required for text documents that can be display or edited in a &lt;a href=&quot;qplaintextedit&quot;&gt;QPlainTextEdit&lt;/a&gt;. See &lt;a href=&quot;qtextdocument#setDocumentLayout&quot;&gt;QTextDocument::setDocumentLayout&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qplaintextdocumentlayout&quot;&gt;QPlainTextDocumentLayout는&lt;/a&gt; 디스플레이 또는 편집 할 수있는 텍스트 문서에 필요 &lt;a href=&quot;qplaintextedit&quot;&gt;QPlainTextEdit&lt;/a&gt; . &lt;a href=&quot;qtextdocument#setDocumentLayout&quot;&gt;QTextDocument :: setDocumentLayout&lt;/a&gt; ()을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8f35759b4448d7471d833ef6dfbcd2ec35e835ee" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qpoint&quot;&gt;QPoint&lt;/a&gt; object can also be used as a vector: Addition and subtraction are defined as for vectors (each component is added separately). A &lt;a href=&quot;qpoint&quot;&gt;QPoint&lt;/a&gt; object can also be divided or multiplied by an &lt;code&gt;int&lt;/code&gt; or a &lt;code&gt;qreal&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;qpoint&quot;&gt;의 QPoint&lt;/a&gt; 객체는 벡터로서 사용될 수있다 : 가감 (각 성분은 별도로 첨가 됨) 벡터로 정의한다. &lt;a href=&quot;qpoint&quot;&gt;의 QPoint&lt;/a&gt; 객체는 또한 나눈 또는 곱해질 수 &lt;code&gt;int&lt;/code&gt; 또는 &lt;code&gt;qreal&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="81aa5c0c0d094abf948d677de84dbd86b0a27412" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qpointf&quot;&gt;QPointF&lt;/a&gt; object can also be used as a vector: Addition and subtraction are defined as for vectors (each component is added separately). A &lt;a href=&quot;qpointf&quot;&gt;QPointF&lt;/a&gt; object can also be divided or multiplied by an &lt;code&gt;int&lt;/code&gt; or a &lt;code&gt;qreal&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;qpointf&quot;&gt;QPointF의&lt;/a&gt; 목적은 벡터로서 사용될 수있다 : 덧셈과 뺄셈은 (각각의 성분은 별도로 첨가 됨) 벡터로 정의한다. &lt;a href=&quot;qpointf&quot;&gt;QPointF의&lt;/a&gt; 목적은 또한 나눈 또는 곱해질 수 &lt;code&gt;int&lt;/code&gt; 또는 &lt;code&gt;qreal&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f2995b25fd5370f7318080fec047331e56ef415" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qpolygon&quot;&gt;QPolygon&lt;/a&gt; object is a &lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt;&amp;lt;&lt;a href=&quot;qpoint&quot;&gt;QPoint&lt;/a&gt;&amp;gt;. The easiest way to add points to a &lt;a href=&quot;qpolygon&quot;&gt;QPolygon&lt;/a&gt; is to use &lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt;'s streaming operator, as illustrated below:</source>
          <target state="translated">&lt;a href=&quot;qpolygon&quot;&gt;QPolygon의&lt;/a&gt; 목적은 인 &lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt; &amp;lt; &lt;a href=&quot;qpoint&quot;&gt;의 QPoint&lt;/a&gt; &amp;gt;. &lt;a href=&quot;qpolygon&quot;&gt;QPolygon&lt;/a&gt; 에 포인트를 추가하는 가장 쉬운 방법 은 아래 그림과 같이 &lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt; 스트리밍 연산자 를 사용 하는 것 입니다 .</target>
        </trans-unit>
        <trans-unit id="1fd417cb5c069f05bb6e94f593c093d77bae3a09" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qpolygonf&quot;&gt;QPolygonF&lt;/a&gt; is a &lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt;&amp;lt;&lt;a href=&quot;qpointf&quot;&gt;QPointF&lt;/a&gt;&amp;gt;. The easiest way to add points to a &lt;a href=&quot;qpolygonf&quot;&gt;QPolygonF&lt;/a&gt; is to use its streaming operator, as illustrated below:</source>
          <target state="translated">&lt;a href=&quot;qpolygonf&quot;&gt;QPolygonF는&lt;/a&gt; A는 &lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt; &amp;lt; &lt;a href=&quot;qpointf&quot;&gt;QPointF&lt;/a&gt; &amp;gt;. &lt;a href=&quot;qpolygonf&quot;&gt;QPolygonF&lt;/a&gt; 에 포인트를 추가하는 가장 쉬운 방법 은 아래 그림과 같이 스트리밍 연산자를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="3c5c20299a124c9554344c12ec8f47a1079504b6" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qprogressbar&quot;&gt;QProgressBar&lt;/a&gt;, draws CE_ProgressBarGroove, CE_ProgressBarContents and CE_ProgressBarLabel.</source>
          <target state="translated">&lt;a href=&quot;qprogressbar&quot;&gt;QProgressBar는&lt;/a&gt; , CE_ProgressBarGroove, CE_ProgressBarContents 및 CE_ProgressBarLabel을 그립니다.</target>
        </trans-unit>
        <trans-unit id="eb9cbad184458618a9403e1de092f538543a9871" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qproxystyle&quot;&gt;QProxyStyle&lt;/a&gt; wraps a &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt; (usually the default system style) for the purpose of dynamically overriding painting or other specific style behavior.</source>
          <target state="translated">&lt;a href=&quot;qproxystyle&quot;&gt;QProxyStyle는&lt;/a&gt; 랩 &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt; 동적으로 오버라이드 (override) 그림이나 다른 특정 스타일의 행동의 목적을 위해 (일반적으로 기본 시스템 스타일).</target>
        </trans-unit>
        <trans-unit id="bc752ae65676965c9389a9737906002295b93b87" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qpushbutton&quot;&gt;QPushButton&lt;/a&gt; instance.</source>
          <target state="translated">&lt;a href=&quot;qpushbutton&quot;&gt;QPushButton을의&lt;/a&gt; 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="56a9fd11ee7c0afcb13a49a43a5ef68c6646cdbe" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qpushbutton&quot;&gt;QPushButton&lt;/a&gt;, draws CE_PushButtonBevel, CE_PushButtonLabel and &lt;a href=&quot;qstyle#PrimitiveElement-enum&quot;&gt;PE_FrameFocusRect&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qpushbutton&quot;&gt;QPushButton을은&lt;/a&gt; , CE_PushButtonBevel, CE_PushButtonLabel와 그립니다 &lt;a href=&quot;qstyle#PrimitiveElement-enum&quot;&gt;PE_FrameFocusRect을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8e2f8e3502aa7644db2bd9c8719081de7efcecb2" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qqmlcomponent&quot;&gt;QQmlComponent&lt;/a&gt; instance can be created from a QML file. For example, if there is a &lt;code&gt;main.qml&lt;/code&gt; file like this:</source>
          <target state="translated">&lt;a href=&quot;qqmlcomponent&quot;&gt;QQmlComponent의&lt;/a&gt; 인스턴스는 QML 파일을 만들 수 있습니다. 예를 들어 다음 과 같은 &lt;code&gt;main.qml&lt;/code&gt; 파일이있는 경우 :</target>
        </trans-unit>
        <trans-unit id="acb51da0f04f9c2a61f3da915fba0efa8d07fd60" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qqmlincubationcontroller&quot;&gt;QQmlIncubationController&lt;/a&gt; derived instance should be created and set on a &lt;a href=&quot;qqmlengine&quot;&gt;QQmlEngine&lt;/a&gt; by calling the &lt;a href=&quot;qqmlengine#setIncubationController&quot;&gt;QQmlEngine::setIncubationController&lt;/a&gt;() method. Processing is then controlled by calling the &lt;a href=&quot;qqmlincubationcontroller#incubateFor&quot;&gt;QQmlIncubationController::incubateFor&lt;/a&gt;() or &lt;a href=&quot;qqmlincubationcontroller#incubateWhile&quot;&gt;QQmlIncubationController::incubateWhile&lt;/a&gt;() methods as dictated by the application's requirements.</source>
          <target state="translated">&lt;a href=&quot;qqmlincubationcontroller&quot;&gt;QQmlIncubationController는&lt;/a&gt; 인스턴스 생성 및 설정해야 유래 &lt;a href=&quot;qqmlengine&quot;&gt;QQmlEngine&lt;/a&gt; 호출하여 &lt;a href=&quot;qqmlengine#setIncubationController&quot;&gt;QQmlEngine :: setIncubationController&lt;/a&gt; () 메소드. 그런 다음 응용 프로그램 요구 사항에 따라 &lt;a href=&quot;qqmlincubationcontroller#incubateFor&quot;&gt;QQmlIncubationController :: incubateFor&lt;/a&gt; () 또는 &lt;a href=&quot;qqmlincubationcontroller#incubateWhile&quot;&gt;QQmlIncubationController :: incubateWhile&lt;/a&gt; () 메서드를 호출하여 처리를 제어 합니다.</target>
        </trans-unit>
        <trans-unit id="45c3e4a315e5d9d0bbbef748b41a06916fbc0944" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qquickrendertarget&quot;&gt;QQuickRenderTarget&lt;/a&gt; serves as an opaque handle for a renderable native object, most commonly a 2D texture, and associated metadata, such as the size in pixels.</source>
          <target state="translated">&lt;a href=&quot;qquickrendertarget&quot;&gt;QQuickRenderTarget은&lt;/a&gt; 그러한 픽셀 크기 렌더링 가능한 원시 오브젝트 불투명 핸들, 가장 일반적으로는 2D 텍스처와 연관된 메타 데이터로서 기능한다.</target>
        </trans-unit>
        <trans-unit id="b69c5fc8d1dd1872215c00fd93a4b298c372460b" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt; always has a single invisible root item containing all of its content. To add items to this window, reparent the items to the contentItem or to an existing item in the scene.</source>
          <target state="translated">&lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow는&lt;/a&gt; 항상 모든 콘텐츠를 포함하는 단일 보이지 않는 루트 항목이 있습니다. 이 창에 항목을 추가하려면 항목을 contentItem 또는 장면의 기존 항목에 다시 배치하십시오.</target>
        </trans-unit>
        <trans-unit id="84b1e6ae7b674778f63c30e2332d85e9bdc49a68" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt; always has a single invisible root item. To add items to this window, reparent the items to the root item or to an existing item in the scene.</source>
          <target state="translated">&lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow는&lt;/a&gt; 항상 하나의 보이지 않는 루트 항목이 있습니다. 이 창에 항목을 추가하려면 항목을 루트 항목 또는 장면의 기존 항목에 다시 배치하십시오.</target>
        </trans-unit>
        <trans-unit id="5587fd6b2bf1670fa438d974e81689904dae6c89" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qradiobutton&quot;&gt;QRadioButton&lt;/a&gt; instance.</source>
          <target state="translated">&lt;a href=&quot;qradiobutton&quot;&gt;QRadioButton의&lt;/a&gt; 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="548cba2593e20361d3143d00402bac7f9acde2ef" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qradiobutton&quot;&gt;QRadioButton&lt;/a&gt; is an option button that can be switched on (checked) or off (unchecked). Radio buttons typically present the user with a &quot;one of many&quot; choice. In a group of radio buttons, only one radio button at a time can be checked; if the user selects another button, the previously selected button is switched off.</source>
          <target state="translated">&lt;a href=&quot;qradiobutton&quot;&gt;QRadioButton는&lt;/a&gt; (체크) 또는 (체크) 오프를 전환 할 수있는 옵션 버튼이다. 라디오 버튼은 일반적으로 사용자에게 &quot;다중 하나&quot;를 선택합니다. 라디오 버튼 그룹에서는 한 번에 하나의 라디오 버튼 만 확인할 수 있습니다. 사용자가 다른 버튼을 선택하면 이전에 선택한 버튼이 꺼집니다.</target>
        </trans-unit>
        <trans-unit id="fce09b8407c24509adfcd45a688fa4a6570f444a" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qradiobutton&quot;&gt;QRadioButton&lt;/a&gt;, draws a &lt;a href=&quot;qstyle#PrimitiveElement-enum&quot;&gt;PE_IndicatorRadioButton&lt;/a&gt;, a CE_RadioButtonLabel and a &lt;a href=&quot;qstyle#PrimitiveElement-enum&quot;&gt;PE_FrameFocusRect&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qradiobutton&quot;&gt;QRadioButton는&lt;/a&gt; 하는립니다 &lt;a href=&quot;qstyle#PrimitiveElement-enum&quot;&gt;PE_IndicatorRadioButton&lt;/a&gt; 하는 CE_RadioButtonLabel과 &lt;a href=&quot;qstyle#PrimitiveElement-enum&quot;&gt;PE_FrameFocusRect을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="064a01b75d2dd54a00d8216bc301100251f5dbd1" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qrawfont&quot;&gt;QRawFont&lt;/a&gt; object represents a single, physical instance of a given font in a given pixel size. I.e. in the typical case it represents a set of TrueType or OpenType font tables and uses a user specified pixel size to convert metrics into logical pixel units. It can be used in combination with the &lt;a href=&quot;https://doc.qt.io/qt-5.13/qglyphrun.html&quot;&gt;QGlyphRun&lt;/a&gt; class to draw specific glyph indexes at specific positions, and also have accessors to some relevant data in the physical font.</source>
          <target state="translated">&lt;a href=&quot;qrawfont&quot;&gt;QRawFont의&lt;/a&gt; 목적은 주어진 화소 사이즈가 소정의 폰트의 단일 물리적 인스턴스를 나타낸다. 즉, 일반적인 경우 트루 타입 또는 OpenType 글꼴 테이블 세트를 나타내며 사용자 지정 픽셀 크기를 사용하여 메트릭을 논리 픽셀 단위로 변환합니다. &lt;a href=&quot;https://doc.qt.io/qt-5.13/qglyphrun.html&quot;&gt;QGlyphRun&lt;/a&gt; 클래스 와 함께 사용 하여 특정 위치에 특정 글리프 인덱스를 그리고 물리적 글꼴의 일부 관련 데이터에 대한 접근자를 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e341cff9c17c1a34a825547e5107c92221aa46d" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt; can be constructed with a set of left, top, width and height integers, or from a &lt;a href=&quot;qpoint&quot;&gt;QPoint&lt;/a&gt; and a &lt;a href=&quot;qsize&quot;&gt;QSize&lt;/a&gt;. The following code creates two identical rectangles.</source>
          <target state="translated">&lt;a href=&quot;qrect&quot;&gt;QRect는&lt;/a&gt; 왼쪽, 위쪽, 폭과 높이의 정수의 집합으로 구성하거나, 행 수 &lt;a href=&quot;qpoint&quot;&gt;의 QPoint&lt;/a&gt; 및 &lt;a href=&quot;qsize&quot;&gt;QSize&lt;/a&gt; . 다음 코드는 두 개의 동일한 사각형을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="52b606459c79a1ece52bf55cbdf81bbb9900d381" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt; specifying the page rectangle</source>
          <target state="translated">페이지 사각형을 지정 하는 &lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="aa0ee98602f44026d86ad62e71202760fbf5423e" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt; specifying the paper rectangle.</source>
          <target state="translated">종이 사각형을 지정 하는 &lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7303d4b34db264bd74de1b56a808cb930e0d1f11" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qrectf&quot;&gt;QRectF&lt;/a&gt; can be constructed with a set of left, top, width and height coordinates, or from a &lt;a href=&quot;qpointf&quot;&gt;QPointF&lt;/a&gt; and a &lt;a href=&quot;qsizef&quot;&gt;QSizeF&lt;/a&gt;. The following code creates two identical rectangles.</source>
          <target state="translated">&lt;a href=&quot;qrectf&quot;&gt;QRectF은&lt;/a&gt; 좌측, 상부, 폭 및 높이 좌표의 세트, 또는 행으로 구성 될 수 &lt;a href=&quot;qpointf&quot;&gt;QPointF&lt;/a&gt; 및 &lt;a href=&quot;qsizef&quot;&gt;QSizeF&lt;/a&gt; . 다음 코드는 두 개의 동일한 사각형을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="c1458d9e577059ca7236a9cf74f03dd92cfb274c" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qregularexpressionmatch&quot;&gt;QRegularExpressionMatch&lt;/a&gt; object can be obtained by calling the &lt;a href=&quot;qregularexpression#match&quot;&gt;QRegularExpression::match&lt;/a&gt;() function, or as a single result of a global match from a &lt;a href=&quot;qregularexpressionmatchiterator&quot;&gt;QRegularExpressionMatchIterator&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qregularexpressionmatch&quot;&gt;QRegularExpressionMatch의&lt;/a&gt; 목적은 호출함으로써 얻을 수있다 &lt;a href=&quot;qregularexpression#match&quot;&gt;QRegularExpression :: 매치&lt;/a&gt; () 함수, 또는 글로벌 매치로부터의 하나의 결과로서 &lt;a href=&quot;qregularexpressionmatchiterator&quot;&gt;QRegularExpressionMatchIterator&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c501d097a1ba188b61775fa2b3cd06ca9d994663" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qregularexpressionmatchiterator&quot;&gt;QRegularExpressionMatchIterator&lt;/a&gt; object is a forward only Java-like iterator; it can be obtained by calling the &lt;a href=&quot;qregularexpression#globalMatch&quot;&gt;QRegularExpression::globalMatch&lt;/a&gt;() function. A new &lt;a href=&quot;qregularexpressionmatchiterator&quot;&gt;QRegularExpressionMatchIterator&lt;/a&gt; will be positioned before the first result. You can then call the &lt;a href=&quot;qregularexpressionmatchiterator#hasNext&quot;&gt;hasNext&lt;/a&gt;() function to check if there are more results available; if so, the &lt;a href=&quot;qregularexpressionmatchiterator#next&quot;&gt;next&lt;/a&gt;() function will return the next result and advance the iterator.</source>
          <target state="translated">&lt;a href=&quot;qregularexpressionmatchiterator&quot;&gt;QRegularExpressionMatchIterator의&lt;/a&gt; 객체가 앞으로 만 자바와 같은 반복자; &lt;a href=&quot;qregularexpression#globalMatch&quot;&gt;QRegularExpression :: globalMatch&lt;/a&gt; () 함수 를 호출하여 얻을 수 있습니다 . 새로운 &lt;a href=&quot;qregularexpressionmatchiterator&quot;&gt;QRegularExpressionMatchIterator&lt;/a&gt; 가 첫 번째 결과 앞에 위치합니다. 그런 다음 &lt;a href=&quot;qregularexpressionmatchiterator#hasNext&quot;&gt;hasNext&lt;/a&gt; () 함수를 호출하여 사용 가능한 결과가 더 있는지 확인할 수 있습니다. 그렇다면 &lt;a href=&quot;qregularexpressionmatchiterator#next&quot;&gt;next&lt;/a&gt; () 함수는 다음 결과를 반환하고 이터레이터를 진행시킵니다.</target>
        </trans-unit>
        <trans-unit id="114b92fb765c6c0e90319093bd3575dd22f0e811" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qremoteobjectdynamicreplica&quot;&gt;QRemoteObjectDynamicReplica&lt;/a&gt; can be generated at runtime. To do so, you call &lt;a href=&quot;qremoteobjectnode#acquireDynamic&quot;&gt;QRemoteObjectNode::acquireDynamic&lt;/a&gt;(), passing in the &lt;a href=&quot;qtremoteobjects-source#source&quot;&gt;Source&lt;/a&gt; name (a &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;) as an argument. Dynamic replicas are a bit more verbose to use from C++, but do not require compilation. Dynamic replicas do not support initial property values, and do not support introspection until they have been initialized.</source>
          <target state="translated">&lt;a href=&quot;qremoteobjectdynamicreplica&quot;&gt;QRemoteObjectDynamicReplica는&lt;/a&gt; 실행시에 생성 될 수있다. 그렇게하려면 &lt;a href=&quot;qtremoteobjects-source#source&quot;&gt;소스&lt;/a&gt; 이름 ( &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; )을 인수로 전달하여 &lt;a href=&quot;qremoteobjectnode#acquireDynamic&quot;&gt;QRemoteObjectNode :: acquireDynamic&lt;/a&gt; () 을 호출 합니다. 동적 복제본은 C ++에서 사용하기에 좀 더 장황하지만 컴파일 할 필요는 없습니다. 동적 복제본은 초기 속성 값을 지원하지 않으며 초기화 될 때까지 내부 검사를 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bb0f9f77e1a8372077c15686858e6d26e6a7c211" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qremoteobjectdynamicreplica&quot;&gt;QRemoteObjectDynamicReplica&lt;/a&gt; can be generated at runtime. To do so, you call &lt;a href=&quot;qremoteobjectnode#acquireDynamic&quot;&gt;QRemoteObjectNode::acquireDynamic&lt;/a&gt;(), passing in the source name (a &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;) as an argument. Dynamic replicas are a bit more verbose to use from C++, but they do not require compilation. Dynamic replicas do not support initial property values, or introspection until they have been initialized.</source>
          <target state="translated">&lt;a href=&quot;qremoteobjectdynamicreplica&quot;&gt;QRemoteObjectDynamicReplica는&lt;/a&gt; 실행시에 생성 될 수있다. 이렇게하려면 &lt;a href=&quot;qremoteobjectnode#acquireDynamic&quot;&gt;QRemoteObjectNode :: acquireDynamic&lt;/a&gt; () 을 호출 하여 소스 이름 ( &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; )을 인수로 전달합니다. 동적 복제본은 C ++에서 사용하기에 좀 더 장황하지만 컴파일이 필요하지 않습니다. 동적 복제본은 초기화 될 때까지 초기 속성 값 또는 내부 검사를 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3b596274e8a4b4ebb387b72d7b79940b29cb426b" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qremoteobjectnode&quot;&gt;QRemoteObjectNode&lt;/a&gt; does not have a url that other nodes can connect to, and thus is able to acquire replicas only. It is not able to share source objects (only &lt;a href=&quot;qremoteobjecthost&quot;&gt;QRemoteObjectHost&lt;/a&gt; and &lt;a href=&quot;qremoteobjectregistryhost&quot;&gt;QRemoteObjectRegistryHost&lt;/a&gt; Nodes can share).</source>
          <target state="translated">&lt;a href=&quot;qremoteobjectnode&quot;&gt;QRemoteObjectNode는&lt;/a&gt; 다른 노드에 연결할 수있는 URL을 가지고, 따라서 취득은 복제본 할 수 없습니다. 소스 오브젝트를 공유 할 수 없습니다 ( &lt;a href=&quot;qremoteobjecthost&quot;&gt;QRemoteObjectHost&lt;/a&gt; 및 &lt;a href=&quot;qremoteobjectregistryhost&quot;&gt;QRemoteObjectRegistryHost&lt;/a&gt; 노드 만 공유 할 수 있음).</target>
        </trans-unit>
        <trans-unit id="43886504edcb38942991a02610a100eb18ce4fca" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qremoteobjectregistryhost&quot;&gt;QRemoteObjectRegistryHost&lt;/a&gt; has the same capability that a &lt;a href=&quot;qremoteobjecthost&quot;&gt;QRemoteObjectHost&lt;/a&gt; has (which includes everything a &lt;a href=&quot;qremoteobjectnode&quot;&gt;QRemoteObjectNode&lt;/a&gt; supports), and in addition is the owner of the Registry. Any &lt;a href=&quot;qremoteobjecthost&quot;&gt;QRemoteObjectHost&lt;/a&gt; node that connects to this Node will have all of their Source objects made available by the Registry.</source>
          <target state="translated">&lt;a href=&quot;qremoteobjectregistryhost&quot;&gt;QRemoteObjectRegistryHost는&lt;/a&gt; 하는 것과 같은 기능을 가지고 &lt;a href=&quot;qremoteobjecthost&quot;&gt;QRemoteObjectHost는&lt;/a&gt; (모든 포함하는이 &lt;a href=&quot;qremoteobjectnode&quot;&gt;QRemoteObjectNode의&lt;/a&gt; 지원을), 또한 레지스트리의 소유자입니다. 이 노드에 연결되는 모든 &lt;a href=&quot;qremoteobjecthost&quot;&gt;QRemoteObjectHost&lt;/a&gt; 노드는 레지스트리에서 모든 소스 오브젝트를 사용할 수있게합니다.</target>
        </trans-unit>
        <trans-unit id="217eff0c508e9e6706bb96debd159f6f236eb352" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qresource&quot;&gt;QResource&lt;/a&gt; can either be loaded with an absolute path, either treated as a file system rooted with a &lt;code&gt;/&lt;/code&gt; character, or in resource notation rooted with a &lt;code&gt;:&lt;/code&gt; character. A relative resource can also be opened which will be found in the list of paths returned by &lt;a href=&quot;qdir#searchPaths&quot;&gt;QDir::searchPaths&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qresource&quot;&gt;QResource은&lt;/a&gt; 하나의 절대 경로 로케이션 중 하나와 루트 파일 시스템으로 취급 될 수 &lt;code&gt;/&lt;/code&gt; 로 루팅 문자 또는 자원 표기 &lt;code&gt;:&lt;/code&gt; 캐릭터. &lt;a href=&quot;qdir#searchPaths&quot;&gt;QDir :: searchPaths&lt;/a&gt; ()에 의해 리턴 된 경로 목록에서 찾을 수있는 상대 자원도 열 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="82f3e914e30978f7f5139a2183515e8d8404cbd0" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qresource&quot;&gt;QResource&lt;/a&gt; that is representing a file will have data backing it, this data can possibly be compressed, in which case &lt;a href=&quot;qbytearray#qUncompress&quot;&gt;qUncompress&lt;/a&gt;() must be used to access the real data; this happens implicitly when accessed through a &lt;a href=&quot;qfile&quot;&gt;QFile&lt;/a&gt;. A &lt;a href=&quot;qresource&quot;&gt;QResource&lt;/a&gt; that is representing a directory will have only children and no data.</source>
          <target state="translated">&lt;a href=&quot;qresource&quot;&gt;QResource&lt;/a&gt; 하여 백업 데이터를 가질 것이다 파일을 표현하고, 이러한 데이터는 가능한 한 경우, 압축 될 수 &lt;a href=&quot;qbytearray#qUncompress&quot;&gt;qUncompress는&lt;/a&gt; () 액세스 실제 데이터를 사용한다; 이것은 &lt;a href=&quot;qfile&quot;&gt;QFile을&lt;/a&gt; 통해 액세스 할 때 암시 적으로 발생합니다 . &lt;a href=&quot;qresource&quot;&gt;QResource&lt;/a&gt; 디렉토리를 나타내는 경우에만 자녀없이 데이터를해야합니다.</target>
        </trans-unit>
        <trans-unit id="b8858ffbda69c51c9e13280a0e5e20bb8cfc7515" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qrubberband&quot;&gt;QRubberBand&lt;/a&gt; can represent a rectangle. Some styles will interpret this as a filled (often semi-transparent) rectangle, or a rectangular outline.</source>
          <target state="translated">&lt;a href=&quot;qrubberband&quot;&gt;QRubberBand는&lt;/a&gt; 사각형을 나타낼 수 있습니다. 일부 스타일은 이것을 채워진 (일반적으로 반투명) 사각형 또는 사각형 외곽선으로 해석합니다.</target>
        </trans-unit>
        <trans-unit id="1595160a3dbb9ec7d2e02cb274137a4dc25a70cc" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qrubberband&quot;&gt;QRubberBand&lt;/a&gt; can represent a vertical or horizontal line. Geometry is still given in &lt;a href=&quot;qwidget#rect-prop&quot;&gt;rect&lt;/a&gt;() and the line will fill the given geometry on most styles.</source>
          <target state="translated">&lt;a href=&quot;qrubberband&quot;&gt;QRubberBand는&lt;/a&gt; 수직 또는 수평 라인을 나타낼 수있다. 형상은 여전히 &lt;a href=&quot;qwidget#rect-prop&quot;&gt;rect&lt;/a&gt; ()로 표시되며 선은 대부분의 스타일에서 지정된 형상을 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="2e00d659897f1bd9d038c71109b1ae374688b386" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qrubberband#Shape-enum&quot;&gt;QRubberBand::Shape&lt;/a&gt; enum value that holds the shape of the band (which is either a rectangle or a line).</source>
          <target state="translated">밴드 모양 (사각형 또는 선)을 유지 하는 &lt;a href=&quot;qrubberband#Shape-enum&quot;&gt;QRubberBand :: Shape&lt;/a&gt; 열거 형 값입니다.</target>
        </trans-unit>
        <trans-unit id="6131cae4837789dc81a330f367c863df18fe64fc" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qscopedarraypointer&quot;&gt;QScopedArrayPointer&lt;/a&gt; is a &lt;a href=&quot;qscopedpointer&quot;&gt;QScopedPointer&lt;/a&gt; that defaults to deleting the object it is pointing to with the delete[] operator. It also features operator[] for convenience, so we can write:</source>
          <target state="translated">&lt;a href=&quot;qscopedarraypointer&quot;&gt;QScopedArrayPointer는&lt;/a&gt; A는 &lt;a href=&quot;qscopedpointer&quot;&gt;QScopedPointer&lt;/a&gt; 객체를 삭제하는 기본값은 삭제 [] 연산자를 가리키고 있는지. 또한 편의를 위해 operator []를 제공하므로 다음과 같이 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce07c2acff74a8645066af8cf66dee54f07d63fa" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qsemaphorereleaser&quot;&gt;QSemaphoreReleaser&lt;/a&gt; can be canceled by a call to &lt;a href=&quot;qsemaphorereleaser#cancel&quot;&gt;cancel&lt;/a&gt;(). A canceled semaphore releaser will no longer call &lt;a href=&quot;qsemaphore#release&quot;&gt;QSemaphore::release&lt;/a&gt;() in its destructor.</source>
          <target state="translated">&lt;a href=&quot;qsemaphorereleaser&quot;&gt;QSemaphoreReleaser이&lt;/a&gt; 호출에 의해 취소 할 수 있습니다 &lt;a href=&quot;qsemaphorereleaser#cancel&quot;&gt;취소&lt;/a&gt; (). 취소 된 세마포 &lt;a href=&quot;qsemaphore#release&quot;&gt;릴리스&lt;/a&gt; 는 더 이상 소멸자에서 QSemaphore :: release ()를 호출하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="d129d64cc5353c2bff57e982d816af9fd3d42c74" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qsequentialiterable-const-iterator&quot;&gt;QSequentialIterable::const_iterator&lt;/a&gt; can only be created by a &lt;a href=&quot;qsequentialiterable&quot;&gt;QSequentialIterable&lt;/a&gt; instance, and can be used in a way similar to other stl-style iterators.</source>
          <target state="translated">&lt;a href=&quot;qsequentialiterable-const-iterator&quot;&gt;QSequentialIterable :: const_iterator를이&lt;/a&gt; 만 만들 수 있습니다 &lt;a href=&quot;qsequentialiterable&quot;&gt;QSequentialIterable의&lt;/a&gt; 인스턴스 및 다른 STL 스타일 반복자와 유사한 방식으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c1a7bfbdecc76c15ef2c215f0925e6ca9b646bbb" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qsgabstractrenderer&quot;&gt;QSGAbstractRenderer&lt;/a&gt; created by a &lt;a href=&quot;qsgengine&quot;&gt;QSGEngine&lt;/a&gt; allows you to set your &lt;a href=&quot;qsgnode&quot;&gt;QSGNode&lt;/a&gt; tree through &lt;a href=&quot;qsgabstractrenderer#setRootNode&quot;&gt;setRootNode&lt;/a&gt;() and control the rendering viewport through &lt;a href=&quot;qsgabstractrenderer#setDeviceRect&quot;&gt;setDeviceRect&lt;/a&gt;(), &lt;a href=&quot;qsgabstractrenderer#setViewportRect&quot;&gt;setViewportRect&lt;/a&gt;() and &lt;a href=&quot;qsgabstractrenderer#setProjectionMatrixToRect&quot;&gt;setProjectionMatrixToRect&lt;/a&gt;(). You can finally trigger the rendering to the desired framebuffer through &lt;a href=&quot;qsgabstractrenderer#renderScene&quot;&gt;renderScene&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qsgabstractrenderer&quot;&gt;QSGAbstractRenderer은&lt;/a&gt; a로 만든 &lt;a href=&quot;qsgengine&quot;&gt;QSGEngine은&lt;/a&gt; 당신이 설정할 수 있습니다 &lt;a href=&quot;qsgnode&quot;&gt;QSGNode를&lt;/a&gt; 통해 나무 &lt;a href=&quot;qsgabstractrenderer#setRootNode&quot;&gt;setRootNode를&lt;/a&gt; ()를 통해 렌더링 뷰포트 제어 &lt;a href=&quot;qsgabstractrenderer#setDeviceRect&quot;&gt;setDeviceRect&lt;/a&gt; (), &lt;a href=&quot;qsgabstractrenderer#setViewportRect&quot;&gt;setViewportRect&lt;/a&gt; ()와 &lt;a href=&quot;qsgabstractrenderer#setProjectionMatrixToRect&quot;&gt;setProjectionMatrixToRect을&lt;/a&gt; (). &lt;a href=&quot;qsgabstractrenderer#renderScene&quot;&gt;renderScene&lt;/a&gt; ()을 통해 원하는 프레임 버퍼로 렌더링을 트리거 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="edb58c83dc377d23e37088f2e1a7618e5c6e66dd" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qsgengine&quot;&gt;QSGEngine&lt;/a&gt; can be used to render a tree of &lt;a href=&quot;qsgnode&quot;&gt;QSGNode&lt;/a&gt; directly on a &lt;a href=&quot;qwindow&quot;&gt;QWindow&lt;/a&gt; or &lt;a href=&quot;qopenglframebufferobject&quot;&gt;QOpenGLFramebufferObject&lt;/a&gt; without any integration with QML, &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt; or &lt;a href=&quot;qquickitem&quot;&gt;QQuickItem&lt;/a&gt; and the convenience that they provide.</source>
          <target state="translated">&lt;a href=&quot;qsgengine&quot;&gt;QSGEngine는&lt;/a&gt; 트리 렌더링하는 데 사용할 수 있습니다 &lt;a href=&quot;qsgnode&quot;&gt;QSGNode&lt;/a&gt; 직접에 &lt;a href=&quot;qwindow&quot;&gt;QWindow&lt;/a&gt; 또는 &lt;a href=&quot;qopenglframebufferobject&quot;&gt;QOpenGLFramebufferObject를&lt;/a&gt; QML, 어떤 통합없이 &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt; 또는 &lt;a href=&quot;qquickitem&quot;&gt;QQuickItem&lt;/a&gt; 그들이 제공하는 편의.</target>
        </trans-unit>
        <trans-unit id="2155505b17459e202673d3dcb14a3688ed49ec1d" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qsgtexture&quot;&gt;QSGTexture&lt;/a&gt; that does not have a native texture object underneath is typically &lt;b&gt;not&lt;/b&gt; equal to any other &lt;a href=&quot;qsgtexture&quot;&gt;QSGTexture&lt;/a&gt;, so the return value has to be crafted accordingly. There are exceptions to this, in particular when atlasing is used (where multiple textures share the same atlas texture under the hood), that is then up to the subclass implementations to deal with as appropriate.</source>
          <target state="translated">&lt;a href=&quot;qsgtexture&quot;&gt;QSGTexture&lt;/a&gt; 기본 텍스처 개체 아래가없는 일반적으로 &lt;b&gt;하지&lt;/b&gt; 다른 동일 &lt;a href=&quot;qsgtexture&quot;&gt;QSGTexture&lt;/a&gt; 반환 값이 따라 제작되어야한다, 그래서. 이에 대한 예외가 있습니다. 특히 아틀라스가 사용되는 경우 (여러 텍스처가 내부에서 동일한 아틀라스 텍스처를 공유하는 경우), 이는 적절하게 처리 할 서브 클래스 구현에 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="331d6136c975f6b05ae2b6b65813991145369530" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qsgtexture&quot;&gt;QSGTexture&lt;/a&gt; that does not have a native texture object underneath is typically not equal to any other &lt;a href=&quot;qsgtexture&quot;&gt;QSGTexture&lt;/a&gt;. There are exceptions to this, in particular when atlasing is used (where multiple textures share the same atlas texture under the hood), that is then up to the subclass implementations to deal with as appropriate.</source>
          <target state="translated">&lt;a href=&quot;qsgtexture&quot;&gt;QSGTexture&lt;/a&gt; 기본 텍스처 개체 아래가없는 보통 다른 동일하지 않습니다 &lt;a href=&quot;qsgtexture&quot;&gt;QSGTexture&lt;/a&gt; . 이에 대한 예외가 있습니다. 특히 아틀라스가 사용되는 경우 (여러 텍스처가 내부에서 동일한 아틀라스 텍스처를 공유하는 경우), 적절하게 처리 할 서브 클래스 구현에 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="53021068a33783e015b2d72915181141508480fc" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qsharedmemory#create&quot;&gt;create&lt;/a&gt;() operation failed because a shared memory segment with the specified key already existed.</source>
          <target state="translated">&lt;a href=&quot;qsharedmemory#create&quot;&gt;만들&lt;/a&gt; 지정된 키를 가진 공유 메모리 세그먼트가 이미 존재하기 때문에 () 작업이 실패했습니다.</target>
        </trans-unit>
        <trans-unit id="9dd34f7ea41ab75d7828a2a39bf4af6d854b7453" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qsharedmemory#create&quot;&gt;create&lt;/a&gt;() operation failed because there was not enough memory available to fill the request.</source>
          <target state="translated">&lt;a href=&quot;qsharedmemory#create&quot;&gt;생성&lt;/a&gt; 요청을 채우기 위해 사용 가능한 메모리가 충분하지 않았기 때문에 () 작업이 실패했습니다.</target>
        </trans-unit>
        <trans-unit id="1f8c347ea82347281a8845b7c513ac63b134b175" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qsharedpointer&quot;&gt;QSharedPointer&lt;/a&gt; object can be created from a normal pointer, another &lt;a href=&quot;qsharedpointer&quot;&gt;QSharedPointer&lt;/a&gt; object or by promoting a &lt;a href=&quot;qweakpointer&quot;&gt;QWeakPointer&lt;/a&gt; object to a strong reference.</source>
          <target state="translated">&lt;a href=&quot;qsharedpointer&quot;&gt;QSharedPointer의&lt;/a&gt; 목적은 통상의 포인터, 서로로부터 생성 될 수 &lt;a href=&quot;qsharedpointer&quot;&gt;QSharedPointer의&lt;/a&gt; 개체 또는 촉진하여 &lt;a href=&quot;qweakpointer&quot;&gt;QWeakPointer의&lt;/a&gt; 강한 레퍼런스 오브젝트.</target>
        </trans-unit>
        <trans-unit id="673d267507b8d8b33e452630be583771d7682479" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qsizef&quot;&gt;QSizeF&lt;/a&gt; specifying a custom paper size in the &lt;a href=&quot;qprinter#Unit-enum&quot;&gt;QPrinter::Point&lt;/a&gt; unit.</source>
          <target state="translated">&lt;a href=&quot;qsizef&quot;&gt;QSizeF는&lt;/a&gt; 에서 사용자 정의 용지 크기 지정 &lt;a href=&quot;qprinter#Unit-enum&quot;&gt;QPrinter :: 포인트&lt;/a&gt; 단위.</target>
        </trans-unit>
        <trans-unit id="8ed6621430518d239a15eae457ed7f2dba64997a" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qsizegrip&quot;&gt;QSizeGrip&lt;/a&gt; is placed in the bottom-right corner of the dialog when this property is enabled. By default, the size grip is disabled.</source>
          <target state="translated">&lt;a href=&quot;qsizegrip&quot;&gt;QSizeGrip은&lt;/a&gt; 이 속성을 사용할 수있을 때 대화 상자의 오른쪽 아래 모서리에 배치됩니다. 크기 그립은 기본적으로 비활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c7982133673eef5bdb88d64c0f9b7c2ce4c77d6" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qsqlerror&quot;&gt;QSqlError&lt;/a&gt; object can provide database-specific error data, including the &lt;a href=&quot;qsqlerror#driverText&quot;&gt;driverText&lt;/a&gt;() and &lt;a href=&quot;qsqlerror#databaseText&quot;&gt;databaseText&lt;/a&gt;() messages (or both concatenated together as &lt;a href=&quot;qsqlerror#text&quot;&gt;text&lt;/a&gt;()), and the &lt;a href=&quot;qsqlerror#nativeErrorCode&quot;&gt;nativeErrorCode&lt;/a&gt;() and &lt;a href=&quot;qsqlerror#type&quot;&gt;type&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qsqlerror&quot;&gt;QSqlError의&lt;/a&gt; 객체는 데이터베이스를 포함하여 특정 오류 데이터를 제공 할 수 &lt;a href=&quot;qsqlerror#driverText&quot;&gt;driverText&lt;/a&gt; () 및 &lt;a href=&quot;qsqlerror#databaseText&quot;&gt;databaseText&lt;/a&gt; (같이 함께 연결된 둘 또는 () 메시지 &lt;a href=&quot;qsqlerror#text&quot;&gt;텍스트&lt;/a&gt; 및 ()) &lt;a href=&quot;qsqlerror#nativeErrorCode&quot;&gt;nativeErrorCode&lt;/a&gt; () 및 &lt;a href=&quot;qsqlerror#type&quot;&gt;타입&lt;/a&gt; ()를.</target>
        </trans-unit>
        <trans-unit id="8a8f26e468feac403bb3d8b251a5764d8019ebe9" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qsqlfield&quot;&gt;QSqlField&lt;/a&gt; object can provide some meta-data about the field, for example, its &lt;a href=&quot;qsqlfield#name&quot;&gt;name&lt;/a&gt;(), variant &lt;a href=&quot;qsqlfield#type&quot;&gt;type&lt;/a&gt;(), &lt;a href=&quot;qsqlfield#length&quot;&gt;length&lt;/a&gt;(), &lt;a href=&quot;qsqlfield#precision&quot;&gt;precision&lt;/a&gt;(), &lt;a href=&quot;qsqlfield#defaultValue&quot;&gt;defaultValue&lt;/a&gt;(), typeID(), and its &lt;a href=&quot;qsqlfield#requiredStatus&quot;&gt;requiredStatus&lt;/a&gt;(), &lt;a href=&quot;qsqlfield#isGenerated&quot;&gt;isGenerated&lt;/a&gt;() and &lt;a href=&quot;qsqlfield#isReadOnly&quot;&gt;isReadOnly&lt;/a&gt;(). The field's data can be checked to see if it &lt;a href=&quot;qsqlfield#isNull&quot;&gt;isNull&lt;/a&gt;(), and its &lt;a href=&quot;qsqlfield#value&quot;&gt;value&lt;/a&gt;() retrieved. When editing the data can be set with &lt;a href=&quot;qsqlfield#setValue&quot;&gt;setValue&lt;/a&gt;() or set to NULL with &lt;a href=&quot;qsqlfield#clear&quot;&gt;clear&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qsqlfield&quot;&gt;QSqlField의&lt;/a&gt; 목적은, 예를 들어, 필드에 대한 약간의 메타 데이터를 제공 할 수 있으며, 그 &lt;a href=&quot;qsqlfield#name&quot;&gt;이름&lt;/a&gt; ()의 변형 &lt;a href=&quot;qsqlfield#type&quot;&gt;형태&lt;/a&gt; (), &lt;a href=&quot;qsqlfield#length&quot;&gt;길이&lt;/a&gt; (), &lt;a href=&quot;qsqlfield#precision&quot;&gt;정밀&lt;/a&gt; () &lt;a href=&quot;qsqlfield#defaultValue&quot;&gt;DEFAULTVALUE&lt;/a&gt; () 유형 ID ()와 &lt;a href=&quot;qsqlfield#requiredStatus&quot;&gt;requiredStatus&lt;/a&gt; () &lt;a href=&quot;qsqlfield#isGenerated&quot;&gt;isGenerated&lt;/a&gt; ( ) 및 &lt;a href=&quot;qsqlfield#isReadOnly&quot;&gt;isReadOnly&lt;/a&gt; ()입니다. 필드의 데이터를 검사하여 필드가 &lt;a href=&quot;qsqlfield#isNull&quot;&gt;Null&lt;/a&gt; ()인지, &lt;a href=&quot;qsqlfield#value&quot;&gt;값&lt;/a&gt; ()을 검색 했는지 확인할 수 있습니다 . 편집 할 때 &lt;a href=&quot;qsqlfield#setValue&quot;&gt;setValue&lt;/a&gt; ()로 데이터를 설정 하거나 &lt;a href=&quot;qsqlfield#clear&quot;&gt;clear&lt;/a&gt; () 로 NULL로 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="16e97107acdc06a75e0d69592c24bdb9b277c112" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qsqltablemodel&quot;&gt;QSqlTableModel&lt;/a&gt; subclass with foreign key support.</source>
          <target state="translated">외래 키를 지원 하는 &lt;a href=&quot;qsqltablemodel&quot;&gt;QSqlTableModel&lt;/a&gt; 서브 클래스.</target>
        </trans-unit>
        <trans-unit id="19e1d5ce7f4ce942adcef3215e519b1986df3769" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qsslconfiguration&quot;&gt;QSslConfiguration&lt;/a&gt; object is null if it has been default-constructed and no setter methods have been called.</source>
          <target state="translated">&lt;a href=&quot;qsslconfiguration&quot;&gt;QSslConfiguration의&lt;/a&gt; 가 기본적으로 구성되어 더 setter 메소드가 호출되지 않은 경우 개체가 null입니다.</target>
        </trans-unit>
        <trans-unit id="344862cb8c479646e6bb4c2cc7d57ab04d62710f" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qstackedlayout&quot;&gt;QStackedLayout&lt;/a&gt; can be populated with a number of child widgets (&quot;pages&quot;). For example:</source>
          <target state="translated">&lt;a href=&quot;qstackedlayout&quot;&gt;QStackedLayout은&lt;/a&gt; 자식 위젯의 숫자 ( &quot;페이지&quot;)로 채울 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5f2f6ddf400b2ffa5765e9d48034b2d6b047ec62" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qstatemachine&quot;&gt;QStateMachine&lt;/a&gt; runs its own event loop. For signal transitions (&lt;a href=&quot;qsignaltransition&quot;&gt;QSignalTransition&lt;/a&gt; objects), &lt;a href=&quot;qstatemachine&quot;&gt;QStateMachine&lt;/a&gt; automatically posts a &lt;a href=&quot;qstatemachine-signalevent&quot;&gt;QStateMachine::SignalEvent&lt;/a&gt; to itself when it intercepts the corresponding signal; similarly, for &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; event transitions (&lt;a href=&quot;qeventtransition&quot;&gt;QEventTransition&lt;/a&gt; objects) a &lt;a href=&quot;qstatemachine-wrappedevent&quot;&gt;QStateMachine::WrappedEvent&lt;/a&gt; is posted.</source>
          <target state="translated">&lt;a href=&quot;qstatemachine&quot;&gt;QStateMachine는&lt;/a&gt; 자신의 이벤트 루프를 실행합니다. 신호 전이 ( &lt;a href=&quot;qsignaltransition&quot;&gt;QSignalTransition&lt;/a&gt; 객체)의 경우 &lt;a href=&quot;qstatemachine&quot;&gt;QStateMachine&lt;/a&gt; 은 해당 신호를 차단할 때 &lt;a href=&quot;qstatemachine-signalevent&quot;&gt;QStateMachine :: SignalEvent&lt;/a&gt; 를 자동으로 게시합니다 . 마찬가지로 &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 이벤트 전환 ( &lt;a href=&quot;qeventtransition&quot;&gt;QEventTransition&lt;/a&gt; 객체)의 경우 &lt;a href=&quot;qstatemachine-wrappedevent&quot;&gt;QStateMachine :: WrappedEvent&lt;/a&gt; 가 게시됩니다.</target>
        </trans-unit>
        <trans-unit id="da2b69b9b4f858b5cfcb4b35b05de481ac3dded7" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; can embed '\0' characters (&lt;a href=&quot;qchar#SpecialCharacter-enum&quot;&gt;QChar::Null&lt;/a&gt;). The &lt;a href=&quot;qstring#size&quot;&gt;size&lt;/a&gt;() function always returns the size of the whole string, including embedded '\0' characters.</source>
          <target state="translated">&lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; 수 삽입 '\ 0'문자 ( &lt;a href=&quot;qchar#SpecialCharacter-enum&quot;&gt;QChar :: 널&lt;/a&gt; ). &lt;a href=&quot;qstring#size&quot;&gt;크기&lt;/a&gt; () 함수는 항상 포함 된 '\ 0'문자를 포함하여 전체 문자열의 크기를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a5d617ab5873bbe32bb402a2e20d195c1db7a03d" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qstringview&quot;&gt;QStringView&lt;/a&gt; references a contiguous portion of a UTF-16 string it does not own. It acts as an interface type to all kinds of UTF-16 string, without the need to construct a &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; first.</source>
          <target state="translated">&lt;a href=&quot;qstringview&quot;&gt;QStringView는&lt;/a&gt; 그 자체가하지 않는 UTF-16 문자열의 연속 부분을 참조합니다. &lt;a href=&quot;qstring&quot;&gt;QString을&lt;/a&gt; 먼저 구성 할 필요없이 모든 종류의 UTF-16 문자열에 대한 인터페이스 유형으로 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="8fee518211593f15051b267f4cb304a5b0b9d73d" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qstyleoptionheader#SectionPosition-enum&quot;&gt;QStyleOptionHeader::SectionPosition&lt;/a&gt; value giving the header section's position relative to the other sections.</source>
          <target state="translated">다른 섹션에 대한 헤더 섹션의 위치를 ​​제공 하는 &lt;a href=&quot;qstyleoptionheader#SectionPosition-enum&quot;&gt;QStyleOptionHeader :: SectionPosition&lt;/a&gt; 값입니다.</target>
        </trans-unit>
        <trans-unit id="17fc16cc17881e44d3400adadcd74ce0bba44ea7" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qstyleoptionheader#SelectedPosition-enum&quot;&gt;QStyleOptionHeader::SelectedPosition&lt;/a&gt; value giving the selected section's position relative to the section that is being painted.</source>
          <target state="translated">&lt;a href=&quot;qstyleoptionheader#SelectedPosition-enum&quot;&gt;QStyleOptionHeader :: SelectedPosition의&lt;/a&gt; 페인트되고있는 부분에 선택한 섹션의 위치를 제공하는 값입니다.</target>
        </trans-unit>
        <trans-unit id="32614a6be23d4fa404b2ceb5bd2d80c5cde853f8" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qstyleoptionheader#SortIndicator-enum&quot;&gt;QStyleOptionHeader::SortIndicator&lt;/a&gt; value that describes the direction in which the section's sort indicator should be drawn.</source>
          <target state="translated">섹션의 정렬 표시기가 그려지는 방향을 설명 하는 &lt;a href=&quot;qstyleoptionheader#SortIndicator-enum&quot;&gt;QStyleOptionHeader :: SortIndicator&lt;/a&gt; 값입니다.</target>
        </trans-unit>
        <trans-unit id="3a3077ea5d3ab561017d62f0e18927c06448dea4" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt#ArrowType-enum&quot;&gt;Qt::ArrowType&lt;/a&gt; enum value, which contains the direction of the buttons arrow (if an arrow is to be used in place of an icon).</source>
          <target state="translated">버튼 화살표의 방향을 포함 하는 &lt;a href=&quot;qt#ArrowType-enum&quot;&gt;Qt :: ArrowType&lt;/a&gt; 열거 형 값 (아이콘 대신 화살표를 사용하는 경우).</target>
        </trans-unit>
        <trans-unit id="1d28bee18197daaa06344d8788cc5a665aa3acfa" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt#Corner-enum&quot;&gt;Qt::Corner&lt;/a&gt; value that describes which corner in a window (or equivalent) the grip is located.</source>
          <target state="translated">&lt;a href=&quot;qt#Corner-enum&quot;&gt;Qt는 :: 코너&lt;/a&gt; 그립이 위치한 창 (또는 동급)에있는 코너를 설명 값.</target>
        </trans-unit>
        <trans-unit id="435b03b9e2346ee747228ea67a4cfcd0a23fcdc3" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt#Orientation-enum&quot;&gt;Qt::Orientation&lt;/a&gt; enum value that indicates whether the slider is vertical or horizontal.</source>
          <target state="translated">&lt;a href=&quot;qt#Orientation-enum&quot;&gt;Qt는 :: 방향&lt;/a&gt; ENUM 값 슬라이더가 수직 또는 수평인지 여부를 나타낸다.</target>
        </trans-unit>
        <trans-unit id="18763722c16e8ad3f5d05a708ef90cddeb4a39b9" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt#Orientation-enum&quot;&gt;Qt::Orientation&lt;/a&gt; value deciding whether the header is the horizontal header above the view or the vertical header on the left.</source>
          <target state="translated">헤더가 뷰 위의 수평 헤더인지 왼쪽의 수직 헤더인지를 결정 하는 &lt;a href=&quot;qt#Orientation-enum&quot;&gt;Qt :: Orientation&lt;/a&gt; 값입니다.</target>
        </trans-unit>
        <trans-unit id="6732ecae2611973232b9f2aa517a6d27bd17d44d" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt#ToolButtonStyle-enum&quot;&gt;Qt::ToolButtonStyle&lt;/a&gt; enum value which decides whether the button shows the icon, the text, or both.</source>
          <target state="translated">버튼에 아이콘, 텍스트 또는 둘 다를 표시할지 여부를 결정 하는 &lt;a href=&quot;qt#ToolButtonStyle-enum&quot;&gt;Qt :: ToolButtonStyle&lt;/a&gt; 열거 형 값입니다.</target>
        </trans-unit>
        <trans-unit id="69537524b353ce0b7a35561dfe9487fbfc9ca1f8" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3danimation-qkeyframeanimation&quot;&gt;Qt3DAnimation::QKeyframeAnimation&lt;/a&gt; class implements simple keyframe animation that can be used to animate &lt;a href=&quot;qtransform&quot;&gt;QTransform&lt;/a&gt;. The keyframes consists of multiple timed QTransforms, which are interpolated and applied to the target &lt;a href=&quot;qtransform&quot;&gt;QTransform&lt;/a&gt;. &lt;a href=&quot;qeasingcurve&quot;&gt;QEasingCurve&lt;/a&gt; is used between keyframes to control the interpolator. &lt;a href=&quot;qt3danimation-qkeyframeanimation#RepeatMode-enum&quot;&gt;RepeatMode&lt;/a&gt; can be set for when the position set to the &lt;a href=&quot;qt3danimation-qkeyframeanimation&quot;&gt;QKeyframeAnimation&lt;/a&gt; is below or above the values defined in the keyframe positions.</source>
          <target state="translated">&lt;a href=&quot;qt3danimation-qkeyframeanimation&quot;&gt;Qt3DAnimation :: QKeyframeAnimation의&lt;/a&gt; 클래스가 구현하는 애니메이션에 사용할 수있는 간단한 키 프레임 애니메이션 &lt;a href=&quot;qtransform&quot;&gt;QTransform&lt;/a&gt; . 키 프레임은 여러 QD로 구성되며, 대상 &lt;a href=&quot;qtransform&quot;&gt;QTransform에&lt;/a&gt; 보간되어 적용됩니다 . &lt;a href=&quot;qeasingcurve&quot;&gt;QEasingCurve&lt;/a&gt; 는 키 프레임간에 보간 기를 제어하는 데 사용됩니다. &lt;a href=&quot;qt3danimation-qkeyframeanimation#RepeatMode-enum&quot;&gt;QKeyframeAnimation&lt;/a&gt; 으로 설정된 위치 가 키 프레임 위치에 정의 된 값보다 낮거나 높은 경우 &lt;a href=&quot;qt3danimation-qkeyframeanimation&quot;&gt;반복 모드&lt;/a&gt; 를 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="18141d79765f5a6776e509dcf70be3d9e7ad69b4" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3danimation-qkeyframeanimation&quot;&gt;Qt3DAnimation::QKeyframeAnimation&lt;/a&gt; class implements simple keyframe animation that can be used to animate &lt;a href=&quot;qtransform&quot;&gt;QTransform&lt;/a&gt;. The keyframes consists of multiple timed QTransforms, which are interpolated and applied to the target &lt;a href=&quot;qtransform&quot;&gt;QTransform&lt;/a&gt;. &lt;a href=&quot;qeasingcurve&quot;&gt;QEasingCurve&lt;/a&gt; is used between keyframes to control the interpolator. &lt;a href=&quot;qt3danimation-qkeyframeanimation#RepeatMode-enum&quot;&gt;RepeatMode&lt;/a&gt; can be set for when the position set to the QKeyframeAnimation is below or above the values defined in the keyframe positions.</source>
          <target state="translated">&lt;a href=&quot;qt3danimation-qkeyframeanimation&quot;&gt;Qt3DAnimation :: QKeyframeAnimation의&lt;/a&gt; 클래스가 구현하는 애니메이션에 사용할 수있는 간단한 키 프레임 애니메이션 &lt;a href=&quot;qtransform&quot;&gt;QTransform&lt;/a&gt; . 키 프레임은 대상 &lt;a href=&quot;qtransform&quot;&gt;QTransform에&lt;/a&gt; 보간되고 적용되는 여러 시간 지정 QTransform으로 구성됩니다 . &lt;a href=&quot;qeasingcurve&quot;&gt;QEasingCurve&lt;/a&gt; 는 키 프레임 사이에서 보간 기를 제어하는 데 사용됩니다. &lt;a href=&quot;qt3danimation-qkeyframeanimation#RepeatMode-enum&quot;&gt;RepeatMode&lt;/a&gt; 는 QKeyframeAnimation에 설정된 위치가 키 프레임 위치에 정의 된 값보다 낮거나 위에있을 때 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="79e647608a938b7aa463bbab6a68ec4fe9e234fa" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3danimation-qmorphinganimation&quot;&gt;Qt3DAnimation::QMorphingAnimation&lt;/a&gt; class implements blend-shape morphing animation to a target &lt;a href=&quot;qt3drender-qgeometryrenderer&quot;&gt;QGeometryRenderer&lt;/a&gt;. The &lt;a href=&quot;qt3danimation-qmorphinganimation&quot;&gt;QMorphingAnimation&lt;/a&gt; sets the correct &lt;a href=&quot;qt3drender-qattribute&quot;&gt;QAttributes&lt;/a&gt; from the &lt;a href=&quot;qt3danimation-qmorphtarget&quot;&gt;morph targets&lt;/a&gt; to the target &lt;a href=&quot;qt3drender-qgeometryrenderer#geometry-prop&quot;&gt;QGeometryRenderer::geometry&lt;/a&gt; and calculates interpolator for the current position. The actual blending between the attributes must be implemented in the material. Qt3DAnimation::QMorphPhongMaterial implements material with morphing support for phong lighting model. The blending happens between 2 attributes - 'base' and 'target'. The names for the base and target attributes are taken from the morph target names, where the base attribute retains the name it already has and the target attribute name gets 'Target' appended to the name. The interpolator can be set as a &lt;a href=&quot;qt3drender-qparameter&quot;&gt;QParameter&lt;/a&gt; to the used material. All morph targets in the animation should contain the attributes with same names as those in the base geometry.</source>
          <target state="translated">&lt;a href=&quot;qt3danimation-qmorphinganimation&quot;&gt;Qt3DAnimation :: QMorphingAnimation&lt;/a&gt; 대상에 애니메이션을 모핑 클래스가 구현하는 혼합 모양 &lt;a href=&quot;qt3drender-qgeometryrenderer&quot;&gt;QGeometryRenderer&lt;/a&gt; . &lt;a href=&quot;qt3danimation-qmorphinganimation&quot;&gt;QMorphingAnimation는&lt;/a&gt; 올바른 설정 &lt;a href=&quot;qt3drender-qattribute&quot;&gt;QAttributes&lt;/a&gt; 로부터 &lt;a href=&quot;qt3danimation-qmorphtarget&quot;&gt;모프 타겟을&lt;/a&gt; 대상으로 &lt;a href=&quot;qt3drender-qgeometryrenderer#geometry-prop&quot;&gt;QGeometryRenderer :: 형상을&lt;/a&gt;현재 위치에 대한 보간기를 계산합니다. 속성 사이의 실제 혼합은 머티리얼에 구현되어야합니다. Qt3DAnimation :: QMorphPhongMaterial은 퐁 조명 모델에 대한 모핑을 지원하는 재질을 구현합니다. 블렌딩은 'base'와 'target'의 두 속성 사이에서 발생합니다. 기본 및 대상 속성의 이름은 모프 대상 이름에서 가져옵니다. 기본 속성은 이미 보유한 이름을 유지하고 대상 속성 이름은 이름에 'Target'이 추가됩니다. 보간 &lt;a href=&quot;qt3drender-qparameter&quot;&gt;기를&lt;/a&gt; 사용 된 재질에 대한 QParameter 로 설정할 수 있습니다 . 애니메이션의 모든 모프 타겟에는 기본 지오메트리와 동일한 이름을 가진 속성이 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="852b200806f28db207ebe0424fa4915361571b6d" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3danimation-qmorphinganimation&quot;&gt;Qt3DAnimation::QMorphingAnimation&lt;/a&gt; class implements blend-shape morphing animation to a target &lt;a href=&quot;qt3drender-qgeometryrenderer&quot;&gt;QGeometryRenderer&lt;/a&gt;. The QMorphingAnimation sets the correct &lt;a href=&quot;qt3dcore-qattribute&quot;&gt;QAttributes&lt;/a&gt; from the &lt;a href=&quot;qt3danimation-qmorphtarget&quot;&gt;morph targets&lt;/a&gt; to the target &lt;a href=&quot;qt3drender-qgeometryrenderer#geometry-prop&quot;&gt;QGeometryRenderer::geometry&lt;/a&gt; and calculates interpolator for the current position. The actual blending between the attributes must be implemented in the material. Qt3DAnimation::QMorphPhongMaterial implements material with morphing support for phong lighting model. The blending happens between 2 attributes - 'base' and 'target'. The names for the base and target attributes are taken from the morph target names, where the base attribute retains the name it already has and the target attribute name gets 'Target' appended to the name. The interpolator can be set as a &lt;a href=&quot;qt3drender-qparameter&quot;&gt;QParameter&lt;/a&gt; to the used material. All morph targets in the animation should contain the attributes with same names as those in the base geometry.</source>
          <target state="translated">&lt;a href=&quot;qt3danimation-qmorphinganimation&quot;&gt;Qt3DAnimation :: QMorphingAnimation&lt;/a&gt; 대상에 애니메이션을 모핑 클래스가 구현하는 혼합 모양 &lt;a href=&quot;qt3drender-qgeometryrenderer&quot;&gt;QGeometryRenderer&lt;/a&gt; . QMorphingAnimation 은 &lt;a href=&quot;qt3danimation-qmorphtarget&quot;&gt;모프 타겟&lt;/a&gt; 에서 타겟 &lt;a href=&quot;qt3drender-qgeometryrenderer#geometry-prop&quot;&gt;QGeometryRenderer :: geometry로&lt;/a&gt; 올바른 &lt;a href=&quot;qt3dcore-qattribute&quot;&gt;QAttributes&lt;/a&gt; 를 설정합니다.현재 위치에 대한 보간기를 계산합니다. 속성 간의 실제 블렌딩은 머티리얼에서 구현되어야합니다. Qt3DAnimation :: QMorphPhongMaterial은 퐁 조명 모델에 대한 모핑 지원을 사용하여 머티리얼을 구현합니다. 블렌딩은 'base'와 'target'의 두 가지 속성 사이에서 발생합니다. 기본 및 대상 속성의 이름은 모프 대상 이름에서 가져옵니다. 여기서 기본 속성은 이미 가지고있는 이름을 유지하고 대상 속성 이름은 이름에 'Target'이 추가됩니다. 보간 &lt;a href=&quot;qt3drender-qparameter&quot;&gt;기는&lt;/a&gt; 사용 된 재료에 대한 QParameter 로 설정할 수 있습니다 . 애니메이션의 모든 모프 타겟에는 기본 지오메트리의 이름과 동일한 이름의 속성이 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="a0193a70595de033b53c9f744c8ba951d4d78b46" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3danimation-qmorphinganimation&quot;&gt;Qt3DAnimation::QMorphingAnimation&lt;/a&gt; class implements blend-shape morphing animation to a target &lt;a href=&quot;qt3drender-qgeometryrenderer&quot;&gt;QGeometryRenderer&lt;/a&gt;. The QMorphingAnimation sets the correct &lt;a href=&quot;qt3drender-qattribute&quot;&gt;QAttributes&lt;/a&gt; from the &lt;a href=&quot;qt3danimation-qmorphtarget&quot;&gt;morph targets&lt;/a&gt; to the target &lt;a href=&quot;qt3drender-qgeometryrenderer#geometry-prop&quot;&gt;QGeometryRenderer::geometry&lt;/a&gt; and calculates interpolator for the current position. The actual blending between the attributes must be implemented in the material. Qt3DAnimation::QMorphPhongMaterial implements material with morphing support for phong lighting model. The blending happens between 2 attributes - 'base' and 'target'. The names for the base and target attributes are taken from the morph target names, where the base attribute retains the name it already has and the target attribute name gets 'Target' appended to the name. The interpolator can be set as a &lt;a href=&quot;qt3drender-qparameter&quot;&gt;QParameter&lt;/a&gt; to the used material. All morph targets in the animation should contain the attributes with same names as those in the base geometry.</source>
          <target state="translated">&lt;a href=&quot;qt3danimation-qmorphinganimation&quot;&gt;Qt3DAnimation :: QMorphingAnimation&lt;/a&gt; 대상에 애니메이션을 모핑 클래스가 구현하는 혼합 모양 &lt;a href=&quot;qt3drender-qgeometryrenderer&quot;&gt;QGeometryRenderer&lt;/a&gt; . QMorphingAnimation 은 &lt;a href=&quot;qt3danimation-qmorphtarget&quot;&gt;모프 타겟&lt;/a&gt; 에서 타겟 &lt;a href=&quot;qt3drender-qgeometryrenderer#geometry-prop&quot;&gt;QGeometryRenderer :: geometry로&lt;/a&gt; 올바른 &lt;a href=&quot;qt3drender-qattribute&quot;&gt;QAttributes&lt;/a&gt; 를 설정합니다.그리고 현재 위치에 대한 보간기를 계산합니다. 속성 간의 실제 혼합은 재료에서 구현되어야합니다. Qt3DAnimation :: QMorphPhongMaterial은 퐁 조명 모델에 대한 모핑 지원으로 머티리얼을 구현합니다. 블렌딩은 'base'와 'target'의 두 가지 속성 사이에서 발생합니다. 기본 및 대상 속성의 이름은 모프 대상 이름에서 가져옵니다. 여기서 기본 속성은 이미 가지고있는 이름을 유지하고 대상 속성 이름은 이름에 'Target'이 추가됩니다. 보간 &lt;a href=&quot;qt3drender-qparameter&quot;&gt;기는&lt;/a&gt; 사용 된 재료에 대한 QParameter 로 설정할 수 있습니다 . 애니메이션의 모든 모프 타겟에는 기본 지오메트리에있는 것과 이름이 같은 속성이 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="d332643b29c6b5bbfb136df25ca88ef54ca75b60" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3danimation-qmorphtarget&quot;&gt;Qt3DAnimation::QMorphTarget&lt;/a&gt; class is a convenience class, which provides a list of &lt;a href=&quot;qt3dcore-qattribute&quot;&gt;QAttributes&lt;/a&gt;, which the &lt;a href=&quot;qt3danimation-qmorphinganimation&quot;&gt;QMorphingAnimation&lt;/a&gt; uses to animate geometry. A QMorphTarget can also be created based on existing &lt;a href=&quot;qt3dcore-qgeometry&quot;&gt;Qt3DCore::QGeometry&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qt3danimation-qmorphtarget&quot;&gt;Qt3DAnimation :: QMorphTarget의&lt;/a&gt; 클래스의 목록을 제공하는 편리한 클래스이다 &lt;a href=&quot;qt3dcore-qattribute&quot;&gt;QAttributes&lt;/a&gt; 의 &lt;a href=&quot;qt3danimation-qmorphinganimation&quot;&gt;QMorphingAnimation의&lt;/a&gt; 애니메이션 형상에 사용합니다. QMorphTarget은 기존 &lt;a href=&quot;qt3dcore-qgeometry&quot;&gt;Qt3DCore :: QGeometry를&lt;/a&gt; 기반으로 만들 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="42976bf446755cafe149aa3a492555bc5b123078" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3danimation-qmorphtarget&quot;&gt;Qt3DAnimation::QMorphTarget&lt;/a&gt; class is a convenience class, which provides a list of &lt;a href=&quot;qt3drender-qattribute&quot;&gt;QAttributes&lt;/a&gt;, which the &lt;a href=&quot;qt3danimation-qmorphinganimation&quot;&gt;QMorphingAnimation&lt;/a&gt; uses to animate geometry. A &lt;a href=&quot;qt3danimation-qmorphtarget&quot;&gt;QMorphTarget&lt;/a&gt; can also be created based on existing &lt;a href=&quot;qt3drender-qgeometry&quot;&gt;Qt3DRender::QGeometry&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qt3danimation-qmorphtarget&quot;&gt;Qt3DAnimation :: QMorphTarget의&lt;/a&gt; 클래스의 목록을 제공하는 편리한 클래스이다 &lt;a href=&quot;qt3drender-qattribute&quot;&gt;QAttributes&lt;/a&gt; 의 &lt;a href=&quot;qt3danimation-qmorphinganimation&quot;&gt;QMorphingAnimation의&lt;/a&gt; 애니메이션 형상에 사용합니다. &lt;a href=&quot;qt3danimation-qmorphtarget&quot;&gt;QMorphTarget은&lt;/a&gt; 또한 기존에 기반을 만들 수 있습니다 &lt;a href=&quot;qt3drender-qgeometry&quot;&gt;Qt3DRender :: QGeometry을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="73bca253beb1b54503f64aeb26eb4a532029daa3" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3danimation-qmorphtarget&quot;&gt;Qt3DAnimation::QMorphTarget&lt;/a&gt; class is a convenience class, which provides a list of &lt;a href=&quot;qt3drender-qattribute&quot;&gt;QAttributes&lt;/a&gt;, which the &lt;a href=&quot;qt3danimation-qmorphinganimation&quot;&gt;QMorphingAnimation&lt;/a&gt; uses to animate geometry. A QMorphTarget can also be created based on existing &lt;a href=&quot;qt3drender-qgeometry&quot;&gt;Qt3DRender::QGeometry&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qt3danimation-qmorphtarget&quot;&gt;Qt3DAnimation :: QMorphTarget의&lt;/a&gt; 클래스의 목록을 제공하는 편리한 클래스이다 &lt;a href=&quot;qt3drender-qattribute&quot;&gt;QAttributes&lt;/a&gt; 의 &lt;a href=&quot;qt3danimation-qmorphinganimation&quot;&gt;QMorphingAnimation의&lt;/a&gt; 애니메이션 형상에 사용합니다. QMorphTarget은 기존 &lt;a href=&quot;qt3drender-qgeometry&quot;&gt;Qt3DRender :: QGeometry를&lt;/a&gt; 기반으로 만들 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="83924ad64683faa8c250bb3d090c1c63e3430ca8" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3danimation-qvertexblendanimation&quot;&gt;Qt3DAnimation::QVertexBlendAnimation&lt;/a&gt; class implements vertex-blend morphing animation to a target &lt;a href=&quot;qt3drender-qgeometryrenderer&quot;&gt;QGeometryRenderer&lt;/a&gt;. The &lt;a href=&quot;qt3danimation-qvertexblendanimation&quot;&gt;QVertexBlendAnimation&lt;/a&gt; sets the correct &lt;a href=&quot;qt3drender-qattribute&quot;&gt;QAttributes&lt;/a&gt; from the &lt;a href=&quot;qt3danimation-qmorphtarget&quot;&gt;morph targets&lt;/a&gt; to the target &lt;a href=&quot;qt3drender-qgeometryrenderer#geometry-prop&quot;&gt;QGeometryRenderer::geometry&lt;/a&gt; and calculates interpolator for the current position. Unlike with &lt;a href=&quot;qt3danimation-qmorphinganimation&quot;&gt;QMorphingAnimation&lt;/a&gt;, where the blending is controller with blend weights, the blending occurs between sequential morph targets. The actual blending between the attributes must be implemented in the material. Qt3DAnimation::QMorphPhongMaterial implements material with morphing support for phong lighting model. The blending happens between 2 attributes - 'base' and 'target'. The names for the base and target attributes are taken from the morph target names, where the base attribute retains the name it already has and the target attribute name gets 'Target' appended to the name. The interpolator can be set as a &lt;a href=&quot;qt3drender-qparameter&quot;&gt;QParameter&lt;/a&gt; to the used material. All morph targets in the animation should contain the attributes with same names as those in the base geometry.</source>
          <target state="translated">&lt;a href=&quot;qt3danimation-qvertexblendanimation&quot;&gt;Qt3DAnimation :: QVertexBlendAnimation&lt;/a&gt; 대상에 애니메이션을 모핑 클래스가 구현의 정점 혼합 &lt;a href=&quot;qt3drender-qgeometryrenderer&quot;&gt;QGeometryRenderer&lt;/a&gt; . &lt;a href=&quot;qt3danimation-qvertexblendanimation&quot;&gt;QVertexBlendAnimation는&lt;/a&gt; 올바른 설정 &lt;a href=&quot;qt3drender-qattribute&quot;&gt;QAttributes&lt;/a&gt; 로부터 &lt;a href=&quot;qt3danimation-qmorphtarget&quot;&gt;모프 타겟을&lt;/a&gt; 대상으로 &lt;a href=&quot;qt3drender-qgeometryrenderer#geometry-prop&quot;&gt;QGeometryRenderer :: 형상&lt;/a&gt; 의 현재 위치 및 보간 계산. &lt;a href=&quot;qt3danimation-qmorphinganimation&quot;&gt;QMorphingAnimation&lt;/a&gt; 과 달리블렌딩이 블렌드 가중치를 갖는 제어기 인 경우, 블렌딩은 순차적 모프 타겟 사이에서 발생한다. 속성 사이의 실제 혼합은 머티리얼에 구현되어야합니다. Qt3DAnimation :: QMorphPhongMaterial은 퐁 조명 모델에 대한 모핑을 지원하는 재질을 구현합니다. 블렌딩은 'base'와 'target'의 두 속성 사이에서 발생합니다. 기본 및 대상 속성의 이름은 모프 대상 이름에서 가져옵니다. 기본 속성은 이미 보유한 이름을 유지하고 대상 속성 이름은 이름에 'Target'이 추가됩니다. 보간 &lt;a href=&quot;qt3drender-qparameter&quot;&gt;기를&lt;/a&gt; 사용 된 재질에 대한 QParameter 로 설정할 수 있습니다 . 애니메이션의 모든 모프 타겟에는 기본 지오메트리와 동일한 이름을 가진 속성이 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="388b316fa61a7926764249f000ab9696842b8c26" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3danimation-qvertexblendanimation&quot;&gt;Qt3DAnimation::QVertexBlendAnimation&lt;/a&gt; class implements vertex-blend morphing animation to a target &lt;a href=&quot;qt3drender-qgeometryrenderer&quot;&gt;QGeometryRenderer&lt;/a&gt;. The QVertexBlendAnimation sets the correct &lt;a href=&quot;qt3dcore-qattribute&quot;&gt;QAttributes&lt;/a&gt; from the &lt;a href=&quot;qt3danimation-qmorphtarget&quot;&gt;morph targets&lt;/a&gt; to the target &lt;a href=&quot;qt3drender-qgeometryrenderer#geometry-prop&quot;&gt;QGeometryRenderer::geometry&lt;/a&gt; and calculates interpolator for the current position. Unlike with &lt;a href=&quot;qt3danimation-qmorphinganimation&quot;&gt;QMorphingAnimation&lt;/a&gt;, where the blending is controller with blend weights, the blending occurs between sequential morph targets. The actual blending between the attributes must be implemented in the material. Qt3DAnimation::QMorphPhongMaterial implements material with morphing support for phong lighting model. The blending happens between 2 attributes - 'base' and 'target'. The names for the base and target attributes are taken from the morph target names, where the base attribute retains the name it already has and the target attribute name gets 'Target' appended to the name. The interpolator can be set as a &lt;a href=&quot;qt3drender-qparameter&quot;&gt;QParameter&lt;/a&gt; to the used material. All morph targets in the animation should contain the attributes with same names as those in the base geometry.</source>
          <target state="translated">&lt;a href=&quot;qt3danimation-qvertexblendanimation&quot;&gt;Qt3DAnimation :: QVertexBlendAnimation&lt;/a&gt; 대상에 애니메이션을 모핑 클래스가 구현의 정점 혼합 &lt;a href=&quot;qt3drender-qgeometryrenderer&quot;&gt;QGeometryRenderer&lt;/a&gt; . QVertexBlendAnimation 은 &lt;a href=&quot;qt3danimation-qmorphtarget&quot;&gt;모프 타겟&lt;/a&gt; 에서 타겟 &lt;a href=&quot;qt3drender-qgeometryrenderer#geometry-prop&quot;&gt;QGeometryRenderer :: geometry로&lt;/a&gt; 올바른 &lt;a href=&quot;qt3dcore-qattribute&quot;&gt;QAttributes&lt;/a&gt; 를 설정 하고 현재 위치에 대한 보간 기를 계산합니다. &lt;a href=&quot;qt3danimation-qmorphinganimation&quot;&gt;QMorphingAnimation&lt;/a&gt; 과 달리, 블렌딩이 블렌드 가중치가있는 컨트롤러 인 경우 블렌딩은 순차적 모프 타겟간에 발생합니다. 속성 간의 실제 블렌딩은 머티리얼에서 구현되어야합니다. Qt3DAnimation :: QMorphPhongMaterial은 퐁 조명 모델에 대한 모핑 지원을 사용하여 머티리얼을 구현합니다. 블렌딩은 'base'와 'target'의 두 가지 속성 사이에서 발생합니다. 기본 및 대상 속성의 이름은 모프 대상 이름에서 가져옵니다. 여기서 기본 속성은 이미 가지고있는 이름을 유지하고 대상 속성 이름은 이름에 'Target'이 추가됩니다. 보간 &lt;a href=&quot;qt3drender-qparameter&quot;&gt;기는&lt;/a&gt; 사용 된 재료에 대한 QParameter 로 설정할 수 있습니다 . 애니메이션의 모든 모프 타겟에는 기본 지오메트리의 이름과 동일한 이름의 속성이 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="b14f629e5d131abbc4072f89cc77227bf58c2745" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3danimation-qvertexblendanimation&quot;&gt;Qt3DAnimation::QVertexBlendAnimation&lt;/a&gt; class implements vertex-blend morphing animation to a target &lt;a href=&quot;qt3drender-qgeometryrenderer&quot;&gt;QGeometryRenderer&lt;/a&gt;. The QVertexBlendAnimation sets the correct &lt;a href=&quot;qt3drender-qattribute&quot;&gt;QAttributes&lt;/a&gt; from the &lt;a href=&quot;qt3danimation-qmorphtarget&quot;&gt;morph targets&lt;/a&gt; to the target &lt;a href=&quot;qt3drender-qgeometryrenderer#geometry-prop&quot;&gt;QGeometryRenderer::geometry&lt;/a&gt; and calculates interpolator for the current position. Unlike with &lt;a href=&quot;qt3danimation-qmorphinganimation&quot;&gt;QMorphingAnimation&lt;/a&gt;, where the blending is controller with blend weights, the blending occurs between sequential morph targets. The actual blending between the attributes must be implemented in the material. Qt3DAnimation::QMorphPhongMaterial implements material with morphing support for phong lighting model. The blending happens between 2 attributes - 'base' and 'target'. The names for the base and target attributes are taken from the morph target names, where the base attribute retains the name it already has and the target attribute name gets 'Target' appended to the name. The interpolator can be set as a &lt;a href=&quot;qt3drender-qparameter&quot;&gt;QParameter&lt;/a&gt; to the used material. All morph targets in the animation should contain the attributes with same names as those in the base geometry.</source>
          <target state="translated">&lt;a href=&quot;qt3danimation-qvertexblendanimation&quot;&gt;Qt3DAnimation :: QVertexBlendAnimation&lt;/a&gt; 대상에 애니메이션을 모핑 클래스가 구현의 정점 혼합 &lt;a href=&quot;qt3drender-qgeometryrenderer&quot;&gt;QGeometryRenderer&lt;/a&gt; . QVertexBlendAnimation 은 &lt;a href=&quot;qt3danimation-qmorphtarget&quot;&gt;모프 타겟&lt;/a&gt; 에서 타겟 &lt;a href=&quot;qt3drender-qgeometryrenderer#geometry-prop&quot;&gt;QGeometryRenderer :: geometry로&lt;/a&gt; 올바른 &lt;a href=&quot;qt3drender-qattribute&quot;&gt;QAttributes&lt;/a&gt; 를 설정 하고 현재 위치에 대한 보간 기를 계산합니다. &lt;a href=&quot;qt3danimation-qmorphinganimation&quot;&gt;QMorphingAnimation&lt;/a&gt; 과 달리, 블렌딩이 블렌드 가중치가있는 컨트롤러 인 경우 블렌딩은 순차적 모프 타겟 사이에서 발생합니다. 속성 간의 실제 혼합은 재료에서 구현되어야합니다. Qt3DAnimation :: QMorphPhongMaterial은 퐁 조명 모델에 대한 모핑 지원으로 머티리얼을 구현합니다. 블렌딩은 'base'와 'target'의 두 가지 속성 사이에서 발생합니다. 기본 및 대상 속성의 이름은 모프 대상 이름에서 가져옵니다. 여기서 기본 속성은 이미 가지고있는 이름을 유지하고 대상 속성 이름은 이름에 'Target'이 추가됩니다. 보간 &lt;a href=&quot;qt3drender-qparameter&quot;&gt;기는&lt;/a&gt; 사용 된 재료에 대한 QParameter 로 설정할 수 있습니다 . 애니메이션의 모든 모프 타겟에는 기본 지오메트리에있는 것과 이름이 같은 속성이 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="4985e1ee2c1b0177d832423afe3c0597b277ced0" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3dcore-qcomponent&quot;&gt;QComponent&lt;/a&gt; has been added to a &lt;a href=&quot;qt3dcore-qentity&quot;&gt;QEntity&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qt3dcore-qcomponent&quot;&gt;QComponent는&lt;/a&gt; 에 추가되었습니다 &lt;a href=&quot;qt3dcore-qentity&quot;&gt;QEntity&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3f997f31a07bec809fcbdb505a692643345df981" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3dcore-qcomponent&quot;&gt;QComponent&lt;/a&gt; has been removed from a &lt;a href=&quot;qt3dcore-qentity&quot;&gt;QEntity&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qt3dcore-qcomponent&quot;&gt;QComponent는&lt;/a&gt; A로부터 제거 된 &lt;a href=&quot;qt3dcore-qentity&quot;&gt;QEntity&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e7d693fb0086d2895056778bd349317f0f0a6b48" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3dcore-qcomponent&quot;&gt;Qt3DCore::QComponent&lt;/a&gt; provides a vertical slice of behavior that can be assigned to and sometimes shared across &lt;a href=&quot;qt3dcore-qentity&quot;&gt;Qt3DCore::QEntity&lt;/a&gt; instances.</source>
          <target state="translated">&lt;a href=&quot;qt3dcore-qcomponent&quot;&gt;Qt3DCore :: QComponent는&lt;/a&gt; 할당 때로는에서 공유 할 수있는 행동의 수직 슬라이스 제공 &lt;a href=&quot;qt3dcore-qentity&quot;&gt;Qt3DCore :: QEntity의&lt;/a&gt; 인스턴스를.</target>
        </trans-unit>
        <trans-unit id="7d6281abf4ab616ca283e1e015b86744187a3366" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3dcore-qgeometry&quot;&gt;Qt3DCore::QGeometry&lt;/a&gt; aggregates various attributes to form a piece of geometry. Usually a proper geometry will provide an attribute for vertex positions, an attribute for vertex normals and an attribute for texture coordinates. If you want your geometry to also work with normal mapped materials it will need to provide a consistent set of vertex tangent vectors too.</source>
          <target state="translated">&lt;a href=&quot;qt3dcore-qgeometry&quot;&gt;Qt3DCore :: QGeometry는&lt;/a&gt; 형상의 조각을 형성하기 위해 다양한 속성을 집계합니다. 일반적으로 적절한 지오메트리는 정점 위치에 대한 속성, 정점 법선에 대한 속성 및 텍스처 좌표에 대한 속성을 제공합니다. 지오메트리가 노멀 매핑 된 머티리얼에서도 작동하도록하려면 일관된 버텍스 탄젠트 벡터 세트도 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="97cd392681a94eb4282477a166951e4dd8fea0b5" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3dcore-qgeometry&quot;&gt;Qt3DCore::QGeometry&lt;/a&gt; class is used to group a list of &lt;a href=&quot;qt3dcore-qattribute&quot;&gt;Qt3DCore::QAttribute&lt;/a&gt; objects together to form a geometric shape Qt3D is able to render using Qt3DCore::QGeometryRenderer. Special attribute can be set in order to calculate bounding volume of the shape.</source>
          <target state="translated">&lt;a href=&quot;qt3dcore-qgeometry&quot;&gt;Qt3DCore :: QGeometry의&lt;/a&gt; 클래스는 그룹의 목록이 사용됩니다 &lt;a href=&quot;qt3dcore-qattribute&quot;&gt;Qt3DCore을 :: QAttribute이&lt;/a&gt; Qt3D이 Qt3DCore :: QGeometryRenderer를 사용하여 렌더링 할 수있는 기하학적 형태를 형성하기 위해 함께 객체. 형상의 경계 부피를 계산하기 위해 특수 속성을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c884058b23cc8b0fb1fce3c06a189efaefdd963" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3dcore-qgeometryview&quot;&gt;Qt3DCore::QGeometryView&lt;/a&gt; takes a &lt;a href=&quot;qt3dcore-qgeometry&quot;&gt;Qt3DCore::QGeometry&lt;/a&gt;. It provides properties to control the draw call such as the number of instances to be drawn, the starting instance, the type of &lt;a href=&quot;qt3dcore-qgeometryview#PrimitiveType-enum&quot;&gt;Qt3DCore::QGeometryView::PrimitiveType&lt;/a&gt; to be used, etc.</source>
          <target state="translated">&lt;a href=&quot;qt3dcore-qgeometryview&quot;&gt;Qt3DCore :: QGeometryView는&lt;/a&gt; 소요 &lt;a href=&quot;qt3dcore-qgeometry&quot;&gt;Qt3DCore :: QGeometry을&lt;/a&gt; . 그릴 인스턴스 수, 시작 인스턴스, 사용할 &lt;a href=&quot;qt3dcore-qgeometryview#PrimitiveType-enum&quot;&gt;Qt3DCore :: QGeometryView :: PrimitiveType&lt;/a&gt; 유형 등과 같은 그리기 호출을 제어하는 ​​속성을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="2a810ec72b45ebcbd89ababe52daf7bb5ec27c12" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3dcore-qnode&quot;&gt;QNode&lt;/a&gt; has been added to the scene.</source>
          <target state="translated">&lt;a href=&quot;qt3dcore-qnode&quot;&gt;QNode는&lt;/a&gt; 장면에 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="13a994867c2d56976e7e335dbe3789917bd4053d" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3dcore-qnode&quot;&gt;QNode&lt;/a&gt; has been deleted.</source>
          <target state="translated">&lt;a href=&quot;qt3dcore-qnode&quot;&gt;QNode이&lt;/a&gt; 삭제되었습니다.</target>
        </trans-unit>
        <trans-unit id="08451735907597eb95c298935149cf03a5742f67" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3dcore-qnode&quot;&gt;QNode&lt;/a&gt; has been removed from the scene.</source>
          <target state="translated">&lt;a href=&quot;qt3dcore-qnode&quot;&gt;QNode은&lt;/a&gt; 현장에서 제거되었습니다.</target>
        </trans-unit>
        <trans-unit id="066db5954e25a5a4321c484593bfa1948a398979" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3dcore-qnode&quot;&gt;QNode&lt;/a&gt; property has been updated.</source>
          <target state="translated">&lt;a href=&quot;qt3dcore-qnode&quot;&gt;QNode의&lt;/a&gt; 속성이 업데이트되었습니다.</target>
        </trans-unit>
        <trans-unit id="ba5d381d0d512858e8943381c20b48225c5acc7d" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3dcore-qnode&quot;&gt;QNode&lt;/a&gt; triggered a callback.</source>
          <target state="translated">&lt;a href=&quot;qt3dcore-qnode&quot;&gt;QNode는&lt;/a&gt; 콜백을 트리거.</target>
        </trans-unit>
        <trans-unit id="9fc403167688ce0b8970faa79a1831b3f052bee3" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3dcore-qnodecommand&quot;&gt;QNodeCommand&lt;/a&gt; has been sent between a node and its backend.</source>
          <target state="translated">&lt;a href=&quot;qt3dcore-qnodecommand&quot;&gt;QNodeCommand는&lt;/a&gt; 노드와 백엔드 사이에 보냈습니다.</target>
        </trans-unit>
        <trans-unit id="19b4d564a94786097622690a56f5206acfb198ba" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3dinput-qaxis&quot;&gt;Qt3DInput::QAxis&lt;/a&gt; reports the current position of an axis on an input device. When the axis is returned to its neutral position the value of that axis returns to 0. Often, it is required to have the input from an axis control a variable in other ways, for example treating the value from the &lt;a href=&quot;qt3dinput-qaxis&quot;&gt;Qt3DInput::QAxis&lt;/a&gt; as a velocity (first derivative with respect to time) or as an acceleration (second derivative with respect to time). This can be done with user code or with a &lt;a href=&quot;qt3dlogic-qframeaction&quot;&gt;Qt3DLogic::QFrameAction&lt;/a&gt; but those approached are not ideal as they add more work to the main thread and are inherently imperative. The &lt;a href=&quot;qt3dinput-qaxisaccumulator&quot;&gt;Qt3DInput::QAxisAccumulator&lt;/a&gt; class allows for this common task to be performed on the Qt 3D backend and be specified in a declarative manner.</source>
          <target state="translated">&lt;a href=&quot;qt3dinput-qaxis&quot;&gt;Qt3DInput :: QAxis은&lt;/a&gt; 입력 장치상의 축의 현재 위치를보고한다. 축 종종 0으로 중립 위치로 그 축 반환 값을 반환 할 때 축이 다른 방식으로 가변 제어로부터,의 값 처리, 예를 들면, 입력이 요구된다 &lt;a href=&quot;qt3dinput-qaxis&quot;&gt;Qt3DInput :: QAxis&lt;/a&gt; A와를 속도 (시간에 대한 1 차 미분) 또는 가속도 (시간에 대한 2 차 미분). 이것은 사용자 코드 또는 &lt;a href=&quot;qt3dlogic-qframeaction&quot;&gt;Qt3DLogic :: QFrameAction&lt;/a&gt; 으로 수행 할 수 있지만 접근 한 것은 기본 스레드에 더 많은 작업을 추가하고 본질적으로 필수적이므로 이상적이지 않습니다. &lt;a href=&quot;qt3dinput-qaxisaccumulator&quot;&gt;Qt3DInput :: QAxisAccumulator&lt;/a&gt; 클래스는이 공통 작업이 Qt 3D 백엔드에서 수행되고 선언적인 방식으로 지정 될 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="77b8483509e898b3a6e32b5288823ca91ad55519" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3dinput-qmousedevice&quot;&gt;QMouseDevice&lt;/a&gt; delegates mouse events from physical mouse device to &lt;a href=&quot;qt3dinput-qmousehandler&quot;&gt;QMouseHandler&lt;/a&gt; objects. The sensitivity of the mouse can be controlled with the &lt;a href=&quot;qt3dinput-qmousedevice#sensitivity-prop&quot;&gt;QMouseDevice::sensitivity&lt;/a&gt; property, which specifies the rate in which the logical mouse coordinates change in response to physical movement of the mouse.</source>
          <target state="translated">&lt;a href=&quot;qt3dinput-qmousedevice&quot;&gt;QMouseDevice는&lt;/a&gt; 물리적 마우스 장치에서 위임 마우스 이벤트 &lt;a href=&quot;qt3dinput-qmousehandler&quot;&gt;QMouseHandler의&lt;/a&gt; 객체. &lt;a href=&quot;qt3dinput-qmousedevice#sensitivity-prop&quot;&gt;QMouseDevice :: sensitivity&lt;/a&gt; 속성 을 사용하여 마우스의 감도를 제어 할 수 있습니다.이 속성은 마우스의 물리적 움직임에 따라 논리적 마우스 좌표가 변경되는 속도를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="d50d17773b2123eaf986895798c91fe67e1b3dad" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3drender-geometry#geometryrenderer&quot;&gt;GeometryRenderer&lt;/a&gt; holds all the information necessary to draw a Geometry. A Geometry holds the coordinates of the geometry data - &lt;a href=&quot;qt3drender-geometry#geometryrenderer&quot;&gt;GeometryRenderer&lt;/a&gt; specifies how to interpret that data.</source>
          <target state="translated">&lt;a href=&quot;qt3drender-geometry#geometryrenderer&quot;&gt;GeometryRenderer는&lt;/a&gt; 기하학을 그리는 데 필요한 모든 정보를 보유하고 있습니다. - 기하학은 기하학 데이터의 좌표 보유 &lt;a href=&quot;qt3drender-geometry#geometryrenderer&quot;&gt;GeometryRenderer의&lt;/a&gt; 데이터를 해석하는 방법을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="c5041fb215ac1e6136d5e307ead0942bcb3350f5" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3drender-geometry#geometryview&quot;&gt;GeometryView&lt;/a&gt; holds all the information necessary to handle a Geometry. A Geometry holds the coordinates of the geometry data - &lt;a href=&quot;qt3drender-geometry#geometryview&quot;&gt;GeometryView&lt;/a&gt; specifies how to interpret that data.</source>
          <target state="translated">&lt;a href=&quot;qt3drender-geometry#geometryview&quot;&gt;GeometryView는&lt;/a&gt; 기하학을 처리하는 데 필요한 모든 정보를 보유하고 있습니다. - 기하학은 기하학 데이터의 좌표 보유 &lt;a href=&quot;qt3drender-geometry#geometryview&quot;&gt;GeometryView의&lt;/a&gt; 지정 어떻게 데이터를 해석하는 방법을.</target>
        </trans-unit>
        <trans-unit id="d461f543477e6d28f60a6bfc7d6f07298497b5bf" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3drender-qabstracttexture&quot;&gt;QAbstractTexture&lt;/a&gt; with a &lt;a href=&quot;qt3drender-qabstracttexture#Target-enum&quot;&gt;Target1D&lt;/a&gt; target format. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;qt3drender-qabstracttexture&quot;&gt;QAbstractTexture&lt;/a&gt; A의 &lt;a href=&quot;qt3drender-qabstracttexture#Target-enum&quot;&gt;Target1D의&lt;/a&gt; 대상 포맷. &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="35ef17507b815616dfc1c8f8ecf37173985ac507" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3drender-qabstracttexture&quot;&gt;QAbstractTexture&lt;/a&gt; with a &lt;a href=&quot;qt3drender-qabstracttexture#Target-enum&quot;&gt;Target1D&lt;/a&gt; target format. &lt;a href=&quot;qt3drender-qtexture1d#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;qt3drender-qabstracttexture&quot;&gt;QAbstractTexture&lt;/a&gt; A의 &lt;a href=&quot;qt3drender-qabstracttexture#Target-enum&quot;&gt;Target1D의&lt;/a&gt; 대상 포맷. &lt;a href=&quot;qt3drender-qtexture1d#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3dfe0675f75ee6bf17a61b08574952be372b21bb" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3drender-qabstracttexture&quot;&gt;QAbstractTexture&lt;/a&gt; with a &lt;a href=&quot;qt3drender-qabstracttexture#Target-enum&quot;&gt;Target1DArray&lt;/a&gt; target format. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;qt3drender-qabstracttexture&quot;&gt;QAbstractTexture&lt;/a&gt; A의 &lt;a href=&quot;qt3drender-qabstracttexture#Target-enum&quot;&gt;Target1DArray의&lt;/a&gt; 대상 포맷. &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e85434eea27b483a5c6534f116b0140d7e126373" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3drender-qabstracttexture&quot;&gt;QAbstractTexture&lt;/a&gt; with a &lt;a href=&quot;qt3drender-qabstracttexture#Target-enum&quot;&gt;Target1DArray&lt;/a&gt; target format. &lt;a href=&quot;qt3drender-qtexture1darray#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;qt3drender-qabstracttexture&quot;&gt;QAbstractTexture&lt;/a&gt; A의 &lt;a href=&quot;qt3drender-qabstracttexture#Target-enum&quot;&gt;Target1DArray의&lt;/a&gt; 대상 포맷. &lt;a href=&quot;qt3drender-qtexture1darray#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f182f2f134d238d1e8224238671c2369daa11326" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3drender-qabstracttexture&quot;&gt;QAbstractTexture&lt;/a&gt; with a &lt;a href=&quot;qt3drender-qabstracttexture#Target-enum&quot;&gt;Target2D&lt;/a&gt; target format. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;qt3drender-qabstracttexture&quot;&gt;QAbstractTexture&lt;/a&gt; A의 &lt;a href=&quot;qt3drender-qabstracttexture#Target-enum&quot;&gt;Target2D의&lt;/a&gt; 대상 포맷. &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3229fec2411c71e306d6aace65632f4220edc98d" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3drender-qabstracttexture&quot;&gt;QAbstractTexture&lt;/a&gt; with a &lt;a href=&quot;qt3drender-qabstracttexture#Target-enum&quot;&gt;Target2D&lt;/a&gt; target format. &lt;a href=&quot;qt3drender-qtexture2d#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;qt3drender-qabstracttexture&quot;&gt;QAbstractTexture&lt;/a&gt; A의 &lt;a href=&quot;qt3drender-qabstracttexture#Target-enum&quot;&gt;Target2D의&lt;/a&gt; 대상 포맷. &lt;a href=&quot;qt3drender-qtexture2d#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="50741f41d26d43140dc3e77e519a4a942f943449" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3drender-qabstracttexture&quot;&gt;QAbstractTexture&lt;/a&gt; with a &lt;a href=&quot;qt3drender-qabstracttexture#Target-enum&quot;&gt;Target2DArray&lt;/a&gt; target format. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;qt3drender-qabstracttexture&quot;&gt;QAbstractTexture&lt;/a&gt; A의 &lt;a href=&quot;qt3drender-qabstracttexture#Target-enum&quot;&gt;Target2DArray의&lt;/a&gt; 대상 포맷. &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0fa75b47c058e425fef1c7ca9c38d038d67e95b1" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3drender-qabstracttexture&quot;&gt;QAbstractTexture&lt;/a&gt; with a &lt;a href=&quot;qt3drender-qabstracttexture#Target-enum&quot;&gt;Target2DArray&lt;/a&gt; target format. &lt;a href=&quot;qt3drender-qtexture2darray#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;qt3drender-qabstracttexture&quot;&gt;QAbstractTexture&lt;/a&gt; A의 &lt;a href=&quot;qt3drender-qabstracttexture#Target-enum&quot;&gt;Target2DArray의&lt;/a&gt; 대상 포맷. &lt;a href=&quot;qt3drender-qtexture2darray#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b9b83893de410ff5e6d5dad69e987031b3b3b780" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3drender-qabstracttexture&quot;&gt;QAbstractTexture&lt;/a&gt; with a &lt;a href=&quot;qt3drender-qabstracttexture#Target-enum&quot;&gt;Target2DMultisample&lt;/a&gt; target format. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;qt3drender-qabstracttexture&quot;&gt;QAbstractTexture&lt;/a&gt; A의 &lt;a href=&quot;qt3drender-qabstracttexture#Target-enum&quot;&gt;Target2DMultisample의&lt;/a&gt; 대상 포맷. &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="432116fc110dc38b91684fa8ee12f7b92e37def2" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3drender-qabstracttexture&quot;&gt;QAbstractTexture&lt;/a&gt; with a &lt;a href=&quot;qt3drender-qabstracttexture#Target-enum&quot;&gt;Target2DMultisample&lt;/a&gt; target format. &lt;a href=&quot;qt3drender-qtexture2dmultisample#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;qt3drender-qabstracttexture&quot;&gt;QAbstractTexture&lt;/a&gt; A의 &lt;a href=&quot;qt3drender-qabstracttexture#Target-enum&quot;&gt;Target2DMultisample의&lt;/a&gt; 대상 포맷. &lt;a href=&quot;qt3drender-qtexture2dmultisample#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f955d6437d85b971c27e79e91cc289b5332b4753" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3drender-qabstracttexture&quot;&gt;QAbstractTexture&lt;/a&gt; with a &lt;a href=&quot;qt3drender-qabstracttexture#Target-enum&quot;&gt;Target2DMultisampleArray&lt;/a&gt; target format. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;qt3drender-qabstracttexture&quot;&gt;QAbstractTexture&lt;/a&gt; A의 &lt;a href=&quot;qt3drender-qabstracttexture#Target-enum&quot;&gt;Target2DMultisampleArray의&lt;/a&gt; 대상 포맷. &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6cd237bf39b6ebef5271a81d034dc6c7475fb8b3" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3drender-qabstracttexture&quot;&gt;QAbstractTexture&lt;/a&gt; with a &lt;a href=&quot;qt3drender-qabstracttexture#Target-enum&quot;&gt;Target2DMultisampleArray&lt;/a&gt; target format. &lt;a href=&quot;qt3drender-qtexture2dmultisamplearray#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;qt3drender-qabstracttexture&quot;&gt;QAbstractTexture&lt;/a&gt; A의 &lt;a href=&quot;qt3drender-qabstracttexture#Target-enum&quot;&gt;Target2DMultisampleArray의&lt;/a&gt; 대상 포맷. &lt;a href=&quot;qt3drender-qtexture2dmultisamplearray#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="dce5376942212ed311cac663a536a529d244b7d2" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3drender-qabstracttexture&quot;&gt;QAbstractTexture&lt;/a&gt; with a &lt;a href=&quot;qt3drender-qabstracttexture#Target-enum&quot;&gt;Target3D&lt;/a&gt; target format. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;qt3drender-qabstracttexture&quot;&gt;QAbstractTexture&lt;/a&gt; A의 &lt;a href=&quot;qt3drender-qabstracttexture#Target-enum&quot;&gt;Target3D의&lt;/a&gt; 대상 포맷. &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6f8a16b0837b27ae52dac0cb138bf295bbbbe41a" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3drender-qabstracttexture&quot;&gt;QAbstractTexture&lt;/a&gt; with a &lt;a href=&quot;qt3drender-qabstracttexture#Target-enum&quot;&gt;Target3D&lt;/a&gt; target format. &lt;a href=&quot;qt3drender-qtexture3d#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;qt3drender-qabstracttexture&quot;&gt;QAbstractTexture&lt;/a&gt; A의 &lt;a href=&quot;qt3drender-qabstracttexture#Target-enum&quot;&gt;Target3D의&lt;/a&gt; 대상 포맷. &lt;a href=&quot;qt3drender-qtexture3d#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4a4b479219993a89f1388a36b03abffcc880615d" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3drender-qabstracttexture&quot;&gt;QAbstractTexture&lt;/a&gt; with a &lt;a href=&quot;qt3drender-qabstracttexture#Target-enum&quot;&gt;TargetBuffer&lt;/a&gt; target format. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;qt3drender-qabstracttexture&quot;&gt;QAbstractTexture&lt;/a&gt; A의 &lt;a href=&quot;qt3drender-qabstracttexture#Target-enum&quot;&gt;TargetBuffer의&lt;/a&gt; 대상 포맷. &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8f97bdee8cf15b6aacb6d42571d263d3743f5464" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3drender-qabstracttexture&quot;&gt;QAbstractTexture&lt;/a&gt; with a &lt;a href=&quot;qt3drender-qabstracttexture#Target-enum&quot;&gt;TargetBuffer&lt;/a&gt; target format. &lt;a href=&quot;qt3drender-qtexturebuffer#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;qt3drender-qabstracttexture&quot;&gt;QAbstractTexture&lt;/a&gt; A의 &lt;a href=&quot;qt3drender-qabstracttexture#Target-enum&quot;&gt;TargetBuffer의&lt;/a&gt; 대상 포맷. &lt;a href=&quot;qt3drender-qtexturebuffer#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="412e5d05595e43e73ca05746c89e2224b2661c98" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3drender-qabstracttexture&quot;&gt;QAbstractTexture&lt;/a&gt; with a &lt;a href=&quot;qt3drender-qabstracttexture#Target-enum&quot;&gt;TargetCubeMap&lt;/a&gt; target format. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;qt3drender-qabstracttexture&quot;&gt;QAbstractTexture&lt;/a&gt; A의 &lt;a href=&quot;qt3drender-qabstracttexture#Target-enum&quot;&gt;TargetCubeMap의&lt;/a&gt; 대상 포맷. &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="93248f5e81f34d6714d01a935c51fa1d74e9d09e" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3drender-qabstracttexture&quot;&gt;QAbstractTexture&lt;/a&gt; with a &lt;a href=&quot;qt3drender-qabstracttexture#Target-enum&quot;&gt;TargetCubeMap&lt;/a&gt; target format. &lt;a href=&quot;qt3drender-qtexturecubemap#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;qt3drender-qabstracttexture&quot;&gt;QAbstractTexture&lt;/a&gt; A의 &lt;a href=&quot;qt3drender-qabstracttexture#Target-enum&quot;&gt;TargetCubeMap의&lt;/a&gt; 대상 포맷. &lt;a href=&quot;qt3drender-qtexturecubemap#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9f2cc1cf16ac4d29afb031399a7127e814638aa5" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3drender-qabstracttexture&quot;&gt;QAbstractTexture&lt;/a&gt; with a &lt;a href=&quot;qt3drender-qabstracttexture#Target-enum&quot;&gt;TargetCubeMapArray&lt;/a&gt; target format. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;qt3drender-qabstracttexture#Target-enum&quot;&gt;TargetCubeMapArray&lt;/a&gt; 대상 형식 의 &lt;a href=&quot;qt3drender-qabstracttexture&quot;&gt;QAbstractTexture&lt;/a&gt; 입니다 . &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f0021a3776d42929a831ccb124fff2404ca7abce" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3drender-qabstracttexture&quot;&gt;QAbstractTexture&lt;/a&gt; with a &lt;a href=&quot;qt3drender-qabstracttexture#Target-enum&quot;&gt;TargetCubeMapArray&lt;/a&gt; target format. &lt;a href=&quot;qt3drender-qtexturecubemaparray#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;qt3drender-qabstracttexture#Target-enum&quot;&gt;TargetCubeMapArray&lt;/a&gt; 대상 형식 의 &lt;a href=&quot;qt3drender-qabstracttexture&quot;&gt;QAbstractTexture&lt;/a&gt; 입니다 . &lt;a href=&quot;qt3drender-qtexturecubemaparray#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="45a51ee0fccb174462dd62e36d081682b95c7609" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3drender-qabstracttexture&quot;&gt;QAbstractTexture&lt;/a&gt; with a &lt;a href=&quot;qt3drender-qabstracttexture#Target-enum&quot;&gt;TargetRectangle&lt;/a&gt; target format. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;qt3drender-qabstracttexture&quot;&gt;QAbstractTexture&lt;/a&gt; A의 &lt;a href=&quot;qt3drender-qabstracttexture#Target-enum&quot;&gt;TargetRectangle의&lt;/a&gt; 대상 포맷. &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e0a207e672d922f8600c5a96831500f8edf2d183" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3drender-qabstracttexture&quot;&gt;QAbstractTexture&lt;/a&gt; with a &lt;a href=&quot;qt3drender-qabstracttexture#Target-enum&quot;&gt;TargetRectangle&lt;/a&gt; target format. &lt;a href=&quot;qt3drender-qtexturerectangle#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;qt3drender-qabstracttexture&quot;&gt;QAbstractTexture&lt;/a&gt; A의 &lt;a href=&quot;qt3drender-qabstracttexture#Target-enum&quot;&gt;TargetRectangle의&lt;/a&gt; 대상 포맷. &lt;a href=&quot;qt3drender-qtexturerectangle#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f5364892264eba57abe51cbeca169f49e0f18d6b" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3drender-qabstracttextureimage&quot;&gt;QAbstractTextureImage&lt;/a&gt; that can be written through a &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt;. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;qt3drender-qabstracttextureimage&quot;&gt;QAbstractTextureImage&lt;/a&gt; 스루 기록 할 수 &lt;a href=&quot;qpainter&quot;&gt;QPainter를&lt;/a&gt; . &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6d58823abdcdb523c45fc90b81c6a50fbe4d5dd4" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3drender-qabstracttextureimage&quot;&gt;QAbstractTextureImage&lt;/a&gt; that can be written through a &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt;. &lt;a href=&quot;qt3drender-qpaintedtextureimage#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;qt3drender-qabstracttextureimage&quot;&gt;QAbstractTextureImage&lt;/a&gt; 스루 기록 할 수 &lt;a href=&quot;qpainter&quot;&gt;QPainter를&lt;/a&gt; . &lt;a href=&quot;qt3drender-qpaintedtextureimage#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="745ead28a3d52e9a1df1c0ec930179ee80f758fb" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3drender-qalphacoverage&quot;&gt;Qt3DRender::QAlphaCoverage&lt;/a&gt; class enables alpha-to-coverage multisampling mode. When enabled, the fragment alpha value is used as a coverage for the sample and combined with fragment coverage value. &lt;a href=&quot;qt3drender-qalphacoverage&quot;&gt;Qt3DRender::QAlphaCoverage&lt;/a&gt; does nothing if multisampling is disabled. Alpha-to-coverage is most useful when order independent blending is required, for example when rendering leaves, grass and other rich vegetation.</source>
          <target state="translated">&lt;a href=&quot;qt3drender-qalphacoverage&quot;&gt;Qt3DRender :: QAlphaCoverage의&lt;/a&gt; 클래스는 알파에 대한 커버리지 모드 멀티 샘플링을 할 수 있습니다. 활성화되면 조각 알파 값이 샘플의 적용 범위로 사용되며 조각 적용 범위 값과 결합됩니다. 멀티 샘플링이 비활성화 된 경우 &lt;a href=&quot;qt3drender-qalphacoverage&quot;&gt;Qt3DRender :: QAlphaCoverage&lt;/a&gt; 는 아무 작업도 수행하지 않습니다. 알파 투 커버리지는 주문 독립 블렌딩이 필요한 경우, 예를 들어 잎, 잔디 및 기타 풍부한 초목을 렌더링 할 때 가장 유용합니다.</target>
        </trans-unit>
        <trans-unit id="32b5c6bcfcc6984e9e573c0d3d67ed4be5be9e8f" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3drender-qcameraselector&quot;&gt;Qt3DRender::QCameraSelector&lt;/a&gt; can be used to select the camera, which is used by the FrameGraph when drawing the entities.</source>
          <target state="translated">&lt;a href=&quot;qt3drender-qcameraselector&quot;&gt;Qt3DRender :: QCameraSelector는&lt;/a&gt; 엔티티를 그릴 때 FrameGraph 사용하는 카메라를 선택하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed1ebde616fea8245f311ff3c4e9e4b2d1c05c30" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3drender-qclearbuffers&quot;&gt;Qt3DRender::QClearBuffers&lt;/a&gt; FrameGraph node enables clearing of the specific render target buffers with specific values.</source>
          <target state="translated">&lt;a href=&quot;qt3drender-qclearbuffers&quot;&gt;Qt3DRender :: QClearBuffers&lt;/a&gt; FrameGraph 노드는 특정의 삭제가 특정 값으로 대상 버퍼를 렌더링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="92dffe00b6cd7c056a74c7666514f6b0f81973fe" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3drender-qcomputecommand&quot;&gt;Qt3DRender::QComputeCommand&lt;/a&gt; is used to issue work for the compute shader. The compute shader is specified in the &lt;a href=&quot;qt3drender-qmaterial&quot;&gt;QMaterial&lt;/a&gt; component of the same entity the &lt;a href=&quot;qt3drender-qcomputecommand&quot;&gt;QComputeCommand&lt;/a&gt; is added to. The &lt;a href=&quot;qt3drender-qcomputecommand#workGroupX-prop&quot;&gt;workGroupX&lt;/a&gt;, &lt;a href=&quot;qt3drender-qcomputecommand#workGroupY-prop&quot;&gt;workGroupY&lt;/a&gt; and &lt;a href=&quot;qt3drender-qcomputecommand#workGroupZ-prop&quot;&gt;workGroupZ&lt;/a&gt; properties specify the work group sizes for the compute shader invocation. &lt;a href=&quot;qt3drender-qdispatchcompute&quot;&gt;Qt3DRender::QDispatchCompute&lt;/a&gt; node needs to be present in the FrameGraph to actually issue the commands.</source>
          <target state="translated">&lt;a href=&quot;qt3drender-qcomputecommand&quot;&gt;Qt3DRender :: QComputeCommand는&lt;/a&gt; 컴퓨팅 쉐이더에 대한 문제를 작업에 사용됩니다. 컴퓨팅 쉐이더는에 지정된 &lt;a href=&quot;qt3drender-qmaterial&quot;&gt;QMaterial&lt;/a&gt; 상기 동일한 엔티티의 구성 요소 &lt;a href=&quot;qt3drender-qcomputecommand&quot;&gt;QComputeCommand가&lt;/a&gt; 추가된다. &lt;a href=&quot;qt3drender-qcomputecommand#workGroupX-prop&quot;&gt;workGroupX&lt;/a&gt; , &lt;a href=&quot;qt3drender-qcomputecommand#workGroupY-prop&quot;&gt;workGroupY&lt;/a&gt; 및 &lt;a href=&quot;qt3drender-qcomputecommand#workGroupZ-prop&quot;&gt;workGroupZ&lt;/a&gt; 속성은 연산 쉐이더 호출을위한 작업 그룹 크기를 지정합니다. 실제로 명령을 실행하려면 &lt;a href=&quot;qt3drender-qdispatchcompute&quot;&gt;Qt3DRender :: QDispatchCompute&lt;/a&gt; 노드가 FrameGraph에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="7b8adf47960d7f0acc432a61032b9fd90390afae" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3drender-qcomputecommand&quot;&gt;Qt3DRender::QComputeCommand&lt;/a&gt; is used to issue work for the compute shader. The compute shader is specified in the &lt;a href=&quot;qt3drender-qmaterial&quot;&gt;QMaterial&lt;/a&gt; component of the same entity the QComputeCommand is added to. The &lt;a href=&quot;qt3drender-qcomputecommand#workGroupX-prop&quot;&gt;workGroupX&lt;/a&gt;, &lt;a href=&quot;qt3drender-qcomputecommand#workGroupY-prop&quot;&gt;workGroupY&lt;/a&gt; and &lt;a href=&quot;qt3drender-qcomputecommand#workGroupZ-prop&quot;&gt;workGroupZ&lt;/a&gt; properties specify the work group sizes for the compute shader invocation. &lt;a href=&quot;qt3drender-qdispatchcompute&quot;&gt;Qt3DRender::QDispatchCompute&lt;/a&gt; node needs to be present in the FrameGraph to actually issue the commands.</source>
          <target state="translated">&lt;a href=&quot;qt3drender-qcomputecommand&quot;&gt;Qt3DRender :: QComputeCommand는&lt;/a&gt; 컴퓨팅 쉐이더에 대한 문제를 작업에 사용됩니다. 컴퓨팅 쉐이더는에 지정된 &lt;a href=&quot;qt3drender-qmaterial&quot;&gt;QMaterial&lt;/a&gt; QComputeCommand에 추가 된 동일한 엔티티의 구성 요소. &lt;a href=&quot;qt3drender-qcomputecommand#workGroupX-prop&quot;&gt;workGroupX&lt;/a&gt; , &lt;a href=&quot;qt3drender-qcomputecommand#workGroupY-prop&quot;&gt;workGroupY&lt;/a&gt; 및 &lt;a href=&quot;qt3drender-qcomputecommand#workGroupZ-prop&quot;&gt;workGroupZ&lt;/a&gt; 속성은 연산 쉐이더 호출을위한 작업 그룹 크기를 지정합니다. 실제로 명령을 실행하려면 &lt;a href=&quot;qt3drender-qdispatchcompute&quot;&gt;Qt3DRender :: QDispatchCompute&lt;/a&gt; 노드가 FrameGraph에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="3eb635265974c8d4a652f7d74274be742f4f2bd9" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3drender-qdepthtest&quot;&gt;QDepthTest&lt;/a&gt; class is used to enable depth testing with a given depth test function. The depth test enables writing fragment color values when the depth test passes, and reject fragments which fail the test. The depth test uses the depth function to test the fragments depth value to the value against z-buffer. If the underlying surface does not have z-buffer, then &lt;a href=&quot;qt3drender-qdepthtest&quot;&gt;QDepthTest&lt;/a&gt; does nothing.</source>
          <target state="translated">&lt;a href=&quot;qt3drender-qdepthtest&quot;&gt;QDepthTest의&lt;/a&gt; 클래스는 주어진 깊이 테스트 기능 깊이 테스트를 사용하도록 설정하는 데 사용됩니다. 깊이 테스트는 깊이 테스트를 통과 할 때 조각 색상 값을 쓸 수있게하고 테스트에 실패한 조각을 거부합니다. 깊이 테스트는 깊이 기능을 사용하여 z- 버퍼에 대한 조각 깊이 값을 값으로 테스트합니다. 기본 표면에 z 버퍼 가없는 경우 &lt;a href=&quot;qt3drender-qdepthtest&quot;&gt;QDepthTest&lt;/a&gt; 는 아무 작업도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3ca6bca9a8f2e2702eeb29e91e00c4cfe9eae5d9" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3drender-qdispatchcompute&quot;&gt;Qt3DRender::QDispatchCompute&lt;/a&gt; allows work to be issued for the compute shader to run on the GPU. The &lt;a href=&quot;qt3drender-qdispatchcompute#workGroupX-prop&quot;&gt;workGroupX&lt;/a&gt;, &lt;a href=&quot;qt3drender-qdispatchcompute#workGroupY-prop&quot;&gt;workGroupY&lt;/a&gt; and &lt;a href=&quot;qt3drender-qdispatchcompute#workGroupZ-prop&quot;&gt;workGroupZ&lt;/a&gt; properties specify the work group sizes for the compute shader invocation. &lt;a href=&quot;qt3drender-qcomputecommand&quot;&gt;QComputeCommand&lt;/a&gt; components need to be added to entities to instruct Qt3D to select the materials and geometry from the entities for the compute invocation. The work group sizes for the shader invocation will be the maximum of the work group sizes specified in &lt;a href=&quot;qt3drender-qdispatchcompute&quot;&gt;QDispatchCompute&lt;/a&gt; and &lt;a href=&quot;qt3drender-qcomputecommand&quot;&gt;QComputeCommand&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qt3drender-qdispatchcompute&quot;&gt;Qt3DRender :: QDispatchCompute는&lt;/a&gt; 컴퓨 트 쉐이더는 GPU에서 실행하는 작업을 발행 할 수 있습니다. &lt;a href=&quot;qt3drender-qdispatchcompute#workGroupX-prop&quot;&gt;workGroupX&lt;/a&gt; , &lt;a href=&quot;qt3drender-qdispatchcompute#workGroupY-prop&quot;&gt;workGroupY&lt;/a&gt; 및 &lt;a href=&quot;qt3drender-qdispatchcompute#workGroupZ-prop&quot;&gt;workGroupZ&lt;/a&gt; 속성은 연산 쉐이더 호출을위한 작업 그룹 크기를 지정합니다. &lt;a href=&quot;qt3drender-qcomputecommand&quot;&gt;Qt3D&lt;/a&gt; 가 계산 호출을 위해 엔티티에서 재료와 형상을 선택하도록 지시하려면 QComputeCommand 컴포넌트를 엔티티에 추가해야합니다. 셰이더 호출의 작업 그룹 크기는 &lt;a href=&quot;qt3drender-qdispatchcompute&quot;&gt;QDispatchCompute&lt;/a&gt; 및 &lt;a href=&quot;qt3drender-qcomputecommand&quot;&gt;QComputeCommand에&lt;/a&gt; 지정된 작업 그룹 크기의 최대 값입니다 .</target>
        </trans-unit>
        <trans-unit id="00f133ec84d6cf556ace955767235f701e6f85dc" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3drender-qdispatchcompute&quot;&gt;Qt3DRender::QDispatchCompute&lt;/a&gt; allows work to be issued for the compute shader to run on the GPU. The &lt;a href=&quot;qt3drender-qdispatchcompute#workGroupX-prop&quot;&gt;workGroupX&lt;/a&gt;, &lt;a href=&quot;qt3drender-qdispatchcompute#workGroupY-prop&quot;&gt;workGroupY&lt;/a&gt; and &lt;a href=&quot;qt3drender-qdispatchcompute#workGroupZ-prop&quot;&gt;workGroupZ&lt;/a&gt; properties specify the work group sizes for the compute shader invocation. &lt;a href=&quot;qt3drender-qcomputecommand&quot;&gt;QComputeCommand&lt;/a&gt; components need to be added to entities to instruct Qt3D to select the materials and geometry from the entities for the compute invocation. The work group sizes for the shader invocation will be the maximum of the work group sizes specified in QDispatchCompute and &lt;a href=&quot;qt3drender-qcomputecommand&quot;&gt;QComputeCommand&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qt3drender-qdispatchcompute&quot;&gt;Qt3DRender :: QDispatchCompute는&lt;/a&gt; 컴퓨 트 쉐이더는 GPU에서 실행하는 작업을 발행 할 수 있습니다. &lt;a href=&quot;qt3drender-qdispatchcompute#workGroupX-prop&quot;&gt;workGroupX&lt;/a&gt; , &lt;a href=&quot;qt3drender-qdispatchcompute#workGroupY-prop&quot;&gt;workGroupY&lt;/a&gt; 및 &lt;a href=&quot;qt3drender-qdispatchcompute#workGroupZ-prop&quot;&gt;workGroupZ&lt;/a&gt; 속성은 연산 쉐이더 호출을위한 작업 그룹 크기를 지정합니다. &lt;a href=&quot;qt3drender-qcomputecommand&quot;&gt;Qt3D&lt;/a&gt; 가 컴퓨팅 호출을 위해 엔티티에서 재료와 지오메트리를 선택하도록 지시하려면 QComputeCommand 구성 요소를 엔티티에 추가해야합니다. 셰이더 호출을위한 작업 그룹 크기는 QDispatchCompute 및 &lt;a href=&quot;qt3drender-qcomputecommand&quot;&gt;QComputeCommand에&lt;/a&gt; 지정된 작업 그룹 크기의 최대 값입니다 .</target>
        </trans-unit>
        <trans-unit id="51563093df4ee8b8188c70b75762be0dc88ac819" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3drender-qdithering&quot;&gt;Qt3DRender::QDithering&lt;/a&gt; class enables dithering. Dithering adds noise to the color values to randomize quantization error in order to prevent large scale patterns in the final image, such as banding. Dithering is most useful when rendering to a surface with low color bit depth, such as RGB565 or RGBA4444.</source>
          <target state="translated">&lt;a href=&quot;qt3drender-qdithering&quot;&gt;Qt3DRender :: QDithering&lt;/a&gt; 클래스 것은 디더링 할 수 있습니다. 디더링은 밴딩과 같은 최종 이미지에서 대규모 패턴을 방지하기 위해 색상 값에 노이즈를 추가하여 양자화 오류를 랜덤 화합니다. 디더링은 RGB565 또는 RGBA4444와 같이 낮은 색상 비트 심도로 표면에 렌더링 할 때 가장 유용합니다.</target>
        </trans-unit>
        <trans-unit id="b0cdf22ff4083f9ab26681fb0f501fba9d07795b" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3drender-qframegraphnode&quot;&gt;QFrameGraphNode&lt;/a&gt; used to select QTechniques to use. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;qt3drender-qframegraphnode&quot;&gt;QFrameGraphNode는&lt;/a&gt; 사용 QTechniques을 선택하는 데 사용됩니다. &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2e483ba4b985b01605a22dbc82a1742c641b0612" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3drender-qframegraphnode&quot;&gt;QFrameGraphNode&lt;/a&gt; used to select QTechniques to use. &lt;a href=&quot;qt3drender-qtechniquefilter#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;qt3drender-qframegraphnode&quot;&gt;QFrameGraphNode는&lt;/a&gt; 사용 QTechniques을 선택하는 데 사용됩니다. &lt;a href=&quot;qt3drender-qtechniquefilter#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="09294eee5826e38bd9c6be862e3455731e6d830d" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3drender-qfrontface&quot;&gt;Qt3DRender::QFrontFace&lt;/a&gt; sets the winding direction of the front facing polygons.</source>
          <target state="translated">&lt;a href=&quot;qt3drender-qfrontface&quot;&gt;Qt3DRender :: QFrontFace은&lt;/a&gt; 다각형 대향하는 앞의 권취 방향을 설정한다.</target>
        </trans-unit>
        <trans-unit id="da766419447c7eb0092551633796325143bb72ee" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3drender-qfrustumculling&quot;&gt;QFrustumCulling&lt;/a&gt; class enables frustum culling of the drawable entities based on the camera view and &lt;a href=&quot;qt3drender-qgeometry&quot;&gt;QGeometry&lt;/a&gt; bounds of the entities. If &lt;a href=&quot;qt3drender-qfrustumculling&quot;&gt;QFrustumCulling&lt;/a&gt; is present in the FrameGraph, only the entities whose &lt;a href=&quot;qt3drender-qgeometry&quot;&gt;QGeometry&lt;/a&gt; bounds intersect with the camera frustum, i.e. the view of the camera, are drawn. If &lt;a href=&quot;qt3drender-qfrustumculling&quot;&gt;QFrustumCulling&lt;/a&gt; is not present, all drawable entities will be drawn. The camera is selected by a &lt;a href=&quot;qt3drender-qcameraselector&quot;&gt;QCameraSelector&lt;/a&gt; frame graph node in the current hierarchy. Frustum culling can save a lot of GPU processing time when the rendered scene is complex.</source>
          <target state="translated">&lt;a href=&quot;qt3drender-qfrustumculling&quot;&gt;QFrustumCulling의&lt;/a&gt; 클래스는 카메라 뷰와에 따라 당김 기관의 컬링 프러스 텀 수 &lt;a href=&quot;qt3drender-qgeometry&quot;&gt;QGeometry의&lt;/a&gt; 엔티티의 경계를. 경우 &lt;a href=&quot;qt3drender-qfrustumculling&quot;&gt;QFrustumCulling가&lt;/a&gt; FrameGraph에 존재, 그의 유일한 실체 &lt;a href=&quot;qt3drender-qgeometry&quot;&gt;QGeometry이&lt;/a&gt; 카메라의 예 뷰 카메라 프러스 텀과 교차 경계는 그려져 있습니다. 경우 &lt;a href=&quot;qt3drender-qfrustumculling&quot;&gt;QFrustumCulling이&lt;/a&gt; 존재하지 않는, 모든 당김 개체가 그려집니다. 카메라는 현재 계층 의 &lt;a href=&quot;qt3drender-qcameraselector&quot;&gt;QCameraSelector&lt;/a&gt; 프레임 그래프 노드에 의해 선택됩니다 . 프러스 텀 컬링은 렌더링 된 장면이 복잡한 경우 많은 GPU 처리 시간을 절약 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d82b8c52914c4954a4acec6c65d4ef397f8e8cad" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3drender-qgeometry&quot;&gt;Qt3DRender::QGeometry&lt;/a&gt; aggregates various attributes to form a piece of geometry. Usually a proper geometry will provide an attribute for vertex positions, an attribute for vertex normals and an attribute for texture coordinates. If you want your geometry to also work with normal mapped materials it will need to provide a consistent set of vertex tangent vectors too.</source>
          <target state="translated">&lt;a href=&quot;qt3drender-qgeometry&quot;&gt;Qt3DRender :: QGeometry는&lt;/a&gt; 형상의 조각을 형성하기 위해 다양한 속성을 집계합니다. 일반적으로 적절한 형상은 정점 위치에 대한 속성, 정점 법선에 대한 속성 및 텍스처 좌표에 대한 속성을 제공합니다. 지오메트리가 노멀 매핑 된 머티리얼에서도 작동하게하려면 일관된 정점 탄젠트 벡터를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="e3cf0591418f6589166e3e1d29abad76aff61acb" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3drender-qgeometry&quot;&gt;Qt3DRender::QGeometry&lt;/a&gt; class is used to group a list of &lt;a href=&quot;qt3drender-qattribute&quot;&gt;Qt3DRender::QAttribute&lt;/a&gt; objects together to form a geometric shape Qt3D is able to render using &lt;a href=&quot;qt3drender-qgeometryrenderer&quot;&gt;Qt3DRender::QGeometryRenderer&lt;/a&gt;. Special attribute can be set in order to calculate bounding volume of the shape.</source>
          <target state="translated">&lt;a href=&quot;qt3drender-qgeometry&quot;&gt;Qt3DRender :: QGeometry의&lt;/a&gt; 클래스는 그룹의 목록이 사용됩니다 &lt;a href=&quot;qt3drender-qattribute&quot;&gt;Qt3DRender을 :: QAttribute이&lt;/a&gt; Qt3D 사용 렌더링 할 수있는 기하학적 형태 형성하기 위해 함께 객체 &lt;a href=&quot;qt3drender-qgeometryrenderer&quot;&gt;Qt3DRender :: QGeometryRenderer을&lt;/a&gt; . 모양의 경계 볼륨을 계산하기 위해 특수 속성을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae557cb983a4f056456668cf11da5cdb5fe65ff5" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3drender-qgeometryrenderer&quot;&gt;Qt3DRender::QGeometryRenderer&lt;/a&gt; holds all the information necessary to draw a &lt;a href=&quot;qt3dcore-qgeometry&quot;&gt;Qt3DCore::QGeometry&lt;/a&gt;. A QGeometry holds the coordinates of the geometry data - QGeometryRenderer specifies how to interpret that data.</source>
          <target state="translated">&lt;a href=&quot;qt3drender-qgeometryrenderer&quot;&gt;Qt3DRender :: QGeometryRenderer는&lt;/a&gt; 무승부하는 데 필요한 모든 정보를 보유하고 &lt;a href=&quot;qt3dcore-qgeometry&quot;&gt;Qt3DCore :: QGeometry을&lt;/a&gt; . QGeometry는 도형 데이터의 좌표를 보유합니다. QGeometryRenderer는 해당 데이터를 해석하는 방법을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="ed612072bf913678124d95e06db97bf6b6c8dc1a" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3drender-qgeometryrenderer&quot;&gt;Qt3DRender::QGeometryRenderer&lt;/a&gt; holds all the information necessary to draw a &lt;a href=&quot;qt3drender-qgeometry&quot;&gt;Qt3DRender::QGeometry&lt;/a&gt;. A &lt;a href=&quot;qt3drender-qgeometry&quot;&gt;QGeometry&lt;/a&gt; holds the coordinates of the geometry data - &lt;a href=&quot;qt3drender-qgeometryrenderer&quot;&gt;QGeometryRenderer&lt;/a&gt; specifies how to interpret that data.</source>
          <target state="translated">&lt;a href=&quot;qt3drender-qgeometryrenderer&quot;&gt;Qt3DRender :: QGeometryRenderer는&lt;/a&gt; 무승부하는 데 필요한 모든 정보를 보유하고 &lt;a href=&quot;qt3drender-qgeometry&quot;&gt;Qt3DRender :: QGeometry을&lt;/a&gt; . &lt;a href=&quot;qt3drender-qgeometry&quot;&gt;QGeometry는&lt;/a&gt; -하여 형상 데이터의 좌표 보유 &lt;a href=&quot;qt3drender-qgeometryrenderer&quot;&gt;QGeometryRenderer의&lt;/a&gt; 데이터를 해석하는 방법을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="76341ebeac3f20a397fd533fb9b73fe657faf75d" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3drender-qgeometryrenderer&quot;&gt;Qt3DRender::QGeometryRenderer&lt;/a&gt; holds all the information necessary to draw a &lt;a href=&quot;qt3drender-qgeometry&quot;&gt;Qt3DRender::QGeometry&lt;/a&gt;. A &lt;a href=&quot;qt3drender-qgeometry&quot;&gt;QGeometry&lt;/a&gt; holds the coordinates of the geometry data - QGeometryRenderer specifies how to interpret that data.</source>
          <target state="translated">&lt;a href=&quot;qt3drender-qgeometryrenderer&quot;&gt;Qt3DRender :: QGeometryRenderer는&lt;/a&gt; 무승부하는 데 필요한 모든 정보를 보유하고 &lt;a href=&quot;qt3drender-qgeometry&quot;&gt;Qt3DRender :: QGeometry을&lt;/a&gt; . &lt;a href=&quot;qt3drender-qgeometry&quot;&gt;QGeometry&lt;/a&gt; 는 도형 데이터의 좌표를 보유합니다 . QGeometryRenderer 는 해당 데이터를 해석하는 방법을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="29b595ccf2e1a7f95604911e014ff2992d7e9f91" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3drender-qlayer&quot;&gt;QLayer&lt;/a&gt; can be applied to a subtree of entities by setting the recursive property to true.</source>
          <target state="translated">&lt;a href=&quot;qt3drender-qlayer&quot;&gt;QLayer는&lt;/a&gt; true로 재귀 적 속성을 설정하여 개체의 하위 트리에 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="62e28f6424950062a89482a6ed638822e28e5cef" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3drender-qlayerfilter&quot;&gt;Qt3DRender::QLayerFilter&lt;/a&gt; can be used to instruct the renderer as to which layer(s) to draw in that branch of the frame graph. &lt;a href=&quot;qt3drender-qlayerfilter&quot;&gt;QLayerFilter&lt;/a&gt; selects which entities to draw based on the &lt;a href=&quot;qt3drender-qlayer&quot;&gt;QLayer&lt;/a&gt; instance(s) added to the &lt;a href=&quot;qt3drender-qlayerfilter&quot;&gt;QLayerFilter&lt;/a&gt; and as components to &lt;a href=&quot;qt3dcore-qentity&quot;&gt;Qt3DCore::QEntity&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qt3drender-qlayerfilter&quot;&gt;Qt3DRender :: QLayerFilter이&lt;/a&gt; 되는 층 (들), 프레임 그래프의 지점에서 그릴에 관해서 렌더러에 지시 할 수있다. &lt;a href=&quot;qt3drender-qlayerfilter&quot;&gt;QLayerFilter의&lt;/a&gt; 에 기초하여 그릴 엔티티 선택 &lt;a href=&quot;qt3drender-qlayer&quot;&gt;QLayer의&lt;/a&gt; 인스턴스 (들)을 첨가 &lt;a href=&quot;qt3drender-qlayerfilter&quot;&gt;QLayerFilter&lt;/a&gt; 및 발 성분으로서 &lt;a href=&quot;qt3dcore-qentity&quot;&gt;Qt3DCore :: QEntity&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a8b13f49d2141a19a6c3b29b966075edc67026ed" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3drender-qlayerfilter&quot;&gt;Qt3DRender::QLayerFilter&lt;/a&gt; can be used to instruct the renderer as to which layer(s) to draw in that branch of the frame graph. QLayerFilter selects which entities to draw based on the &lt;a href=&quot;qt3drender-qlayer&quot;&gt;QLayer&lt;/a&gt; instance(s) added to the QLayerFilter and as components to &lt;a href=&quot;qt3dcore-qentity&quot;&gt;Qt3DCore::QEntity&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qt3drender-qlayerfilter&quot;&gt;Qt3DRender :: QLayerFilter이&lt;/a&gt; 되는 층 (들), 프레임 그래프의 지점에서 그릴에 관해서 렌더러에 지시 할 수있다. QLayerFilter는 &lt;a href=&quot;qt3drender-qlayer&quot;&gt;QLayerFilter에&lt;/a&gt; 추가 된 QLayer 인스턴스를 기반으로 그리고 &lt;a href=&quot;qt3dcore-qentity&quot;&gt;Qt3DCore :: QEntity에 대한&lt;/a&gt; 컴포넌트로 그릴 엔티티를 선택합니다 .</target>
        </trans-unit>
        <trans-unit id="30dea4e6d1b318454bccde65c19f8d716ddc8e67" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3drender-qmemorybarrier&quot;&gt;Qt3DRender::QMemoryBarrier&lt;/a&gt; FrameGraph node is used to emplace a specific memory barrier at a specific time of the rendering. This is required to properly synchronize drawing and compute commands on the GPU.</source>
          <target state="translated">&lt;a href=&quot;qt3drender-qmemorybarrier&quot;&gt;Qt3DRender :: QMemoryBarrier&lt;/a&gt; FrameGraph 노드는 렌더링의 특정 시간에 특정 메모리 배리어를 설치하다하는데 사용된다. GPU에서 그리기 및 계산 명령을 올바르게 동기화하는 데 필요합니다.</target>
        </trans-unit>
        <trans-unit id="90b86ecdcd1ce40486cd8faf9850b0938a36574e" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3drender-qmultisampleantialiasing&quot;&gt;Qt3DRender::QMultiSampleAntiAliasing&lt;/a&gt; class enables multisample antialiasing.</source>
          <target state="translated">&lt;a href=&quot;qt3drender-qmultisampleantialiasing&quot;&gt;Qt3DRender는 :: QMultiSampleAntiAliasing&lt;/a&gt; 클래스 것은 멀티 샘플 안티 앨리어싱을 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c21e6112f83003a0feb490eb7f351d7fa975bdf" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3drender-qnodepthmask&quot;&gt;Qt3DRender::QNoDepthMask&lt;/a&gt; class disables fragment depth write to depth buffer.</source>
          <target state="translated">&lt;a href=&quot;qt3drender-qnodepthmask&quot;&gt;Qt3DRender :: QNoDepthMask의&lt;/a&gt; 클래스는 깊이 버퍼에 조각 깊이 쓰기를 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0e538c5d88d1dd5acd8c26710c59281a51453d61" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3drender-qpaintedtextureimage&quot;&gt;QPaintedTextureImage&lt;/a&gt; must be subclassed and the virtual &lt;a href=&quot;qt3drender-qpaintedtextureimage#paint&quot;&gt;paint&lt;/a&gt;() function implemented. Each time &lt;a href=&quot;qt3drender-qpaintedtextureimage#update&quot;&gt;update&lt;/a&gt;() is called on the &lt;a href=&quot;qt3drender-qpaintedtextureimage&quot;&gt;QPaintedTextureImage&lt;/a&gt;, the &lt;a href=&quot;qt3drender-qpaintedtextureimage#paint&quot;&gt;paint&lt;/a&gt;() function is invoked and the resulting image is uploaded.</source>
          <target state="translated">&lt;a href=&quot;qt3drender-qpaintedtextureimage&quot;&gt;QPaintedTextureImage는&lt;/a&gt; 서브 클래스 화해와 가상 &lt;a href=&quot;qt3drender-qpaintedtextureimage#paint&quot;&gt;페인트&lt;/a&gt; () 함수를 구현했습니다. 마다 &lt;a href=&quot;qt3drender-qpaintedtextureimage#update&quot;&gt;업데이트는&lt;/a&gt; ()가 호출됩니다 &lt;a href=&quot;qt3drender-qpaintedtextureimage&quot;&gt;QPaintedTextureImage&lt;/a&gt; 의 &lt;a href=&quot;qt3drender-qpaintedtextureimage#paint&quot;&gt;페인트&lt;/a&gt; () 함수가 호출되고 결과 이미지가 업로드됩니다.</target>
        </trans-unit>
        <trans-unit id="b277088b5fc178923afa8d2fcb5ead7a5cccb6a0" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3drender-qpaintedtextureimage&quot;&gt;QPaintedTextureImage&lt;/a&gt; provides a way to specify a texture image (and thus an OpenGL texture) through a &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt;. The width and height of the texture image can be specified through the width and height or size properties.</source>
          <target state="translated">&lt;a href=&quot;qt3drender-qpaintedtextureimage&quot;&gt;QPaintedTextureImage는&lt;/a&gt; 관통 텍스처 화상 (따라서는 OpenGL 질감)을 지정하는 방법을 제공 &lt;a href=&quot;qpainter&quot;&gt;QPainter를이&lt;/a&gt; . 텍스처 이미지의 너비와 높이는 너비와 높이 또는 크기 속성을 통해 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="40680b32e9c7b5eeb5c188113dca5750428b80a7" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3drender-qparameter&quot;&gt;QParameter&lt;/a&gt; can be referenced by a &lt;a href=&quot;qt3drender-qrenderpass&quot;&gt;QRenderPass&lt;/a&gt;, &lt;a href=&quot;qt3drender-qtechnique&quot;&gt;QTechnique&lt;/a&gt;, &lt;a href=&quot;qt3drender-qeffect&quot;&gt;QEffect&lt;/a&gt;, &lt;a href=&quot;qt3drender-qmaterial&quot;&gt;QMaterial&lt;/a&gt;, &lt;a href=&quot;qt3drender-qtechniquefilter&quot;&gt;QTechniqueFilter&lt;/a&gt;, &lt;a href=&quot;qt3drender-qrenderpassfilter&quot;&gt;QRenderPassFilter&lt;/a&gt;. At runtime, depending on which shader is selected for a given step of the rendering, the value contained in a &lt;a href=&quot;qt3drender-qparameter&quot;&gt;QParameter&lt;/a&gt; will be converted and uploaded if the shader contains a uniform with a name matching that of the &lt;a href=&quot;qt3drender-qparameter&quot;&gt;QParameter&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qt3drender-qparameter&quot;&gt;QParameter은&lt;/a&gt; a로 참조 할 수 &lt;a href=&quot;qt3drender-qrenderpass&quot;&gt;QRenderPass&lt;/a&gt; , &lt;a href=&quot;qt3drender-qtechnique&quot;&gt;QTechnique&lt;/a&gt; , &lt;a href=&quot;qt3drender-qeffect&quot;&gt;QEffect&lt;/a&gt; , &lt;a href=&quot;qt3drender-qmaterial&quot;&gt;QMaterial&lt;/a&gt; , &lt;a href=&quot;qt3drender-qtechniquefilter&quot;&gt;QTechniqueFilter&lt;/a&gt; , &lt;a href=&quot;qt3drender-qrenderpassfilter&quot;&gt;QRenderPassFilter&lt;/a&gt; . 런타임에 주어진 렌더링 단계에 대해 선택된 쉐이더에 따라 &lt;a href=&quot;qt3drender-qparameter&quot;&gt;QParameter에&lt;/a&gt; 포함 된 값 이 쉐이더에 &lt;a href=&quot;qt3drender-qparameter&quot;&gt;QParameter&lt;/a&gt; 와 이름이 일치하는 유니폼이 포함 된 경우 QParameter에 포함 된 값 이 변환 및 업로드됩니다 .</target>
        </trans-unit>
        <trans-unit id="8a04ee4091d624a460c26d864b47b023df875689" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3drender-qparameter&quot;&gt;QParameter&lt;/a&gt; defined on a &lt;a href=&quot;qt3drender-qmaterial&quot;&gt;QMaterial&lt;/a&gt; is overridden by a &lt;a href=&quot;qt3drender-qparameter&quot;&gt;QParameter&lt;/a&gt; (of the same name) defined in a &lt;a href=&quot;qt3drender-qtechniquefilter&quot;&gt;QTechniqueFilter&lt;/a&gt; or a &lt;a href=&quot;qt3drender-qrenderpassfilter&quot;&gt;QRenderPassFilter&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qt3drender-qparameter&quot;&gt;QParameter는&lt;/a&gt; (A)에 정의 &lt;a href=&quot;qt3drender-qmaterial&quot;&gt;QMaterial&lt;/a&gt; a로 겹쳐 &lt;a href=&quot;qt3drender-qparameter&quot;&gt;QParameter&lt;/a&gt; A의 정의 (동명) &lt;a href=&quot;qt3drender-qtechniquefilter&quot;&gt;QTechniqueFilter&lt;/a&gt; 또는 &lt;a href=&quot;qt3drender-qrenderpassfilter&quot;&gt;QRenderPassFilter&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7e04e186c56ba2776200fd848a40e035483409d3" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3drender-qparameter&quot;&gt;QParameter&lt;/a&gt; defined on a QMaterial is overridden by a &lt;a href=&quot;qt3drender-qparameter&quot;&gt;QParameter&lt;/a&gt; (of the same name) defined in a &lt;a href=&quot;qt3drender-qtechniquefilter&quot;&gt;QTechniqueFilter&lt;/a&gt; or a &lt;a href=&quot;qt3drender-qrenderpassfilter&quot;&gt;QRenderPassFilter&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qt3drender-qparameter&quot;&gt;QParameter는&lt;/a&gt; a로 재정의하는 QMaterial 정의 &lt;a href=&quot;qt3drender-qparameter&quot;&gt;QParameter&lt;/a&gt; A의 정의 (동명) &lt;a href=&quot;qt3drender-qtechniquefilter&quot;&gt;QTechniqueFilter&lt;/a&gt; 또는 &lt;a href=&quot;qt3drender-qrenderpassfilter&quot;&gt;QRenderPassFilter&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="88153b0b1cc1356ff63083bd48fb930557dd0a0b" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3drender-qparameter&quot;&gt;QParameter&lt;/a&gt; defined on an Effect is overridden by a &lt;a href=&quot;qt3drender-qparameter&quot;&gt;QParameter&lt;/a&gt; (of the same name) defined in a &lt;a href=&quot;qt3drender-qmaterial&quot;&gt;QMaterial&lt;/a&gt;, &lt;a href=&quot;qt3drender-qtechniquefilter&quot;&gt;QTechniqueFilter&lt;/a&gt;, &lt;a href=&quot;qt3drender-qrenderpassfilter&quot;&gt;QRenderPassFilter&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qt3drender-qparameter&quot;&gt;QParameter&lt;/a&gt; 이펙트 정의가 재정의된다 &lt;a href=&quot;qt3drender-qparameter&quot;&gt;QParameter&lt;/a&gt; A의 정의 (동명) &lt;a href=&quot;qt3drender-qmaterial&quot;&gt;QMaterial&lt;/a&gt; , &lt;a href=&quot;qt3drender-qtechniquefilter&quot;&gt;QTechniqueFilter&lt;/a&gt; , &lt;a href=&quot;qt3drender-qrenderpassfilter&quot;&gt;QRenderPassFilter&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="af32c3fe661350ab6417745ef1dfff22afd2c43b" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3drender-qpolygonoffset&quot;&gt;QPolygonOffset&lt;/a&gt; class adds an offset to the fragment depth value prior to depth test and depth write. The offset can be used to avoid z-fighting when rendering polygons with very close depth values such as decals.</source>
          <target state="translated">&lt;a href=&quot;qt3drender-qpolygonoffset&quot;&gt;QPolygonOffset의&lt;/a&gt; 클래스는 깊이 테스트, 깊이 기록 이전 프래그먼트 심도 값에 오프셋을 추가한다. 데칼과 같이 깊이 값이 매우 가까운 다각형을 렌더링 할 때 z-fighting을 피하기 위해 오프셋을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8891e2c33f4a31b5109f1201ced4bde6ff963a48" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3drender-qproximityfilter&quot;&gt;Qt3DRender::QProximityFilter&lt;/a&gt; can be used to select entities to render when they are placed within a given distance threshold of another entity.</source>
          <target state="translated">&lt;a href=&quot;qt3drender-qproximityfilter&quot;&gt;Qt3DRender :: QProximityFilter는&lt;/a&gt; 그들이 다른 기업의 주어진 거리 임계 값 내에 배치 될 때 렌더링 할 엔티티를 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6198a45cbfb788e36c24f62fd3d67e77f60b77bf" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3drender-qrenderpass&quot;&gt;Qt3DRender::QRenderPass&lt;/a&gt; specifies a single rendering pass - an instance of shader program execution - used by &lt;a href=&quot;qt3drender-qtechnique&quot;&gt;Qt3DRender::QTechnique&lt;/a&gt;. Render pass consists of a &lt;a href=&quot;qt3drender-qshaderprogram&quot;&gt;Qt3DRender::QShaderProgram&lt;/a&gt; and a list of &lt;a href=&quot;qt3drender-qfilterkey&quot;&gt;Qt3DRender::QFilterKey&lt;/a&gt; objects, a list of &lt;a href=&quot;qt3drender-qrenderstate&quot;&gt;Qt3DRender::QRenderState&lt;/a&gt; objects and a list of &lt;a href=&quot;qt3drender-qparameter&quot;&gt;Qt3DRender::QParameter&lt;/a&gt; objects.</source>
          <target state="translated">&lt;a href=&quot;qt3drender-qrenderpass&quot;&gt;Qt3DRender :: QRenderPass는&lt;/a&gt; 쉐이더 프로그램 실행의 예 - -가 사용하는 단일의 렌더링 패스 지정 &lt;a href=&quot;qt3drender-qtechnique&quot;&gt;Qt3DRender ::를 QTechnique&lt;/a&gt; . 렌더 패스는 &lt;a href=&quot;qt3drender-qshaderprogram&quot;&gt;Qt3DRender :: QShaderProgram&lt;/a&gt; 및 &lt;a href=&quot;qt3drender-qfilterkey&quot;&gt;Qt3DRender :: QFilterKey&lt;/a&gt; 객체 목록, &lt;a href=&quot;qt3drender-qrenderstate&quot;&gt;Qt3DRender :: QRenderState&lt;/a&gt; 객체 목록 및 &lt;a href=&quot;qt3drender-qparameter&quot;&gt;Qt3DRender :: QParameter&lt;/a&gt; 객체 목록으로 구성 됩니다.</target>
        </trans-unit>
        <trans-unit id="4b3986d3d7be9168532134ab39e45fcb77709914" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3drender-qrenderpassfilter&quot;&gt;Qt3DRender::QRenderPassFilter&lt;/a&gt; FrameGraph node is used to select which &lt;a href=&quot;qt3drender-qrenderpass&quot;&gt;Qt3DRender::QRenderPass&lt;/a&gt; objects are selected for drawing. &lt;a href=&quot;qt3drender-qrenderpassfilter&quot;&gt;QRenderPassFilter&lt;/a&gt; specifies a list of &lt;a href=&quot;qt3drender-qfilterkey&quot;&gt;Qt3DRender::QFilterKey&lt;/a&gt; objects and &lt;a href=&quot;qt3drender-qparameter&quot;&gt;Qt3DRender::QParameter&lt;/a&gt; objects. When &lt;a href=&quot;qt3drender-qrenderpassfilter&quot;&gt;QRenderPassFilter&lt;/a&gt; is present in the FrameGraph, only the &lt;a href=&quot;qt3drender-qrenderpass&quot;&gt;QRenderPass&lt;/a&gt; objects, whose &lt;a href=&quot;qt3drender-qfilterkey&quot;&gt;Qt3DRender::QFilterKey&lt;/a&gt; objects match the keys in &lt;a href=&quot;qt3drender-qrenderpassfilter&quot;&gt;QRenderPassFilter&lt;/a&gt; are selected for rendering. If no &lt;a href=&quot;qt3drender-qrenderpassfilter&quot;&gt;QRenderPassFilter&lt;/a&gt; is present, then all &lt;a href=&quot;qt3drender-qrenderpass&quot;&gt;QRenderPass&lt;/a&gt; objects are selected for rendering. The parameters in the list can be used to set values for shader parameters. The parameters in &lt;a href=&quot;qt3drender-qrenderpassfilter&quot;&gt;QRenderPassFilter&lt;/a&gt; are overridden by parameters in &lt;a href=&quot;qt3drender-qtechniquefilter&quot;&gt;QTechniqueFilter&lt;/a&gt;, &lt;a href=&quot;qt3drender-qtechnique&quot;&gt;QTechnique&lt;/a&gt; and &lt;a href=&quot;qt3drender-qrenderpass&quot;&gt;QRenderPass&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qt3drender-qrenderpassfilter&quot;&gt;Qt3DRender :: QRenderPassFilter&lt;/a&gt; FrameGraph 노드를 선택하기 위해서 사용된다 &lt;a href=&quot;qt3drender-qrenderpass&quot;&gt;Qt3DRender :: QRenderPass의&lt;/a&gt; 오브젝트가 드로잉을 위해 선택된다. &lt;a href=&quot;qt3drender-qrenderpassfilter&quot;&gt;QRenderPassFilter&lt;/a&gt; 는 &lt;a href=&quot;qt3drender-qfilterkey&quot;&gt;Qt3DRender :: QFilterKey&lt;/a&gt; 오브젝트 및 &lt;a href=&quot;qt3drender-qparameter&quot;&gt;Qt3DRender :: QParameter&lt;/a&gt; 오브젝트 목록을 지정 합니다. 때 &lt;a href=&quot;qt3drender-qrenderpassfilter&quot;&gt;QRenderPassFilter가&lt;/a&gt; FrameGraph에 존재 만 &lt;a href=&quot;qt3drender-qrenderpass&quot;&gt;QRenderPass는&lt;/a&gt; 객체, 그 &lt;a href=&quot;qt3drender-qfilterkey&quot;&gt;Qt3DRender이 :: QFilterKey가&lt;/a&gt; 에있는 키와 일치하는 객체 &lt;a href=&quot;qt3drender-qrenderpassfilter&quot;&gt;QRenderPassFilter하는&lt;/a&gt; 렌더링을 위해 선택됩니다. &lt;a href=&quot;qt3drender-qrenderpassfilter&quot;&gt;QRenderPassFilter&lt;/a&gt; 가 없으면 모든 &lt;a href=&quot;qt3drender-qrenderpass&quot;&gt;QRenderPass&lt;/a&gt;렌더링을 위해 객체가 선택됩니다. 목록의 매개 변수를 사용하여 셰이더 매개 변수의 값을 설정할 수 있습니다. &lt;a href=&quot;qt3drender-qrenderpassfilter&quot;&gt;QRenderPassFilter&lt;/a&gt; 의 매개 변수는 &lt;a href=&quot;qt3drender-qtechniquefilter&quot;&gt;QTechniqueFilter&lt;/a&gt; , &lt;a href=&quot;qt3drender-qtechnique&quot;&gt;QTechnique&lt;/a&gt; 및 &lt;a href=&quot;qt3drender-qrenderpass&quot;&gt;QRenderPass의&lt;/a&gt; 매개 변수로 대체됩니다 .</target>
        </trans-unit>
        <trans-unit id="9898ab99beef734a29d28fbc12e2eeff0366286c" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3drender-qrenderpassfilter&quot;&gt;Qt3DRender::QRenderPassFilter&lt;/a&gt; FrameGraph node is used to select which &lt;a href=&quot;qt3drender-qrenderpass&quot;&gt;Qt3DRender::QRenderPass&lt;/a&gt; objects are selected for drawing. QRenderPassFilter specifies a list of &lt;a href=&quot;qt3drender-qfilterkey&quot;&gt;Qt3DRender::QFilterKey&lt;/a&gt; objects and &lt;a href=&quot;qt3drender-qparameter&quot;&gt;Qt3DRender::QParameter&lt;/a&gt; objects. When QRenderPassFilter is present in the FrameGraph, only the &lt;a href=&quot;qt3drender-qrenderpass&quot;&gt;QRenderPass&lt;/a&gt; objects, whose &lt;a href=&quot;qt3drender-qfilterkey&quot;&gt;Qt3DRender::QFilterKey&lt;/a&gt; objects match the keys in QRenderPassFilter are selected for rendering. If no QRenderPassFilter is present, then all &lt;a href=&quot;qt3drender-qrenderpass&quot;&gt;QRenderPass&lt;/a&gt; objects are selected for rendering. The parameters in the list can be used to set values for shader parameters. The parameters in QRenderPassFilter are overridden by parameters in &lt;a href=&quot;qt3drender-qtechniquefilter&quot;&gt;QTechniqueFilter&lt;/a&gt;, &lt;a href=&quot;qt3drender-qtechnique&quot;&gt;QTechnique&lt;/a&gt; and &lt;a href=&quot;qt3drender-qrenderpass&quot;&gt;QRenderPass&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qt3drender-qrenderpassfilter&quot;&gt;Qt3DRender :: QRenderPassFilter&lt;/a&gt; FrameGraph 노드를 선택하기 위해서 사용된다 &lt;a href=&quot;qt3drender-qrenderpass&quot;&gt;Qt3DRender :: QRenderPass의&lt;/a&gt; 오브젝트가 드로잉을 위해 선택된다. QRenderPassFilter는 &lt;a href=&quot;qt3drender-qfilterkey&quot;&gt;Qt3DRender :: QFilterKey&lt;/a&gt; 객체 및 &lt;a href=&quot;qt3drender-qparameter&quot;&gt;Qt3DRender :: QParameter&lt;/a&gt; 객체 목록을 지정 합니다. QRenderPassFilter이 FrameGraph에 존재하는 경우에만 &lt;a href=&quot;qt3drender-qrenderpass&quot;&gt;QRenderPass는&lt;/a&gt; 객체, 그 &lt;a href=&quot;qt3drender-qfilterkey&quot;&gt;Qt3DRender이 :: QFilterKey가&lt;/a&gt; QRenderPassFilter의 키와 일치하는 개체를하는 렌더링을 위해 선택됩니다. QRenderPassFilter가 없으면 모든 &lt;a href=&quot;qt3drender-qrenderpass&quot;&gt;QRenderPass&lt;/a&gt; 개체가 렌더링을 위해 선택됩니다. 목록의 매개 변수를 사용하여 셰이더 매개 변수의 값을 설정할 수 있습니다. QRenderPassFilter의 매개 변수는 다음의 매개 변수에 의해 재정의됩니다.&lt;a href=&quot;qt3drender-qtechniquefilter&quot;&gt;QTechniqueFilter&lt;/a&gt; , &lt;a href=&quot;qt3drender-qtechnique&quot;&gt;QTechnique&lt;/a&gt; 및 &lt;a href=&quot;qt3drender-qrenderpass&quot;&gt;QRenderPass&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cb6157ffcf3bf4041f08ebac6466740b02604f0a" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3drender-qrenderstate&quot;&gt;Qt3DRender::QRenderState&lt;/a&gt; class is abstract base class for all render states. One can not instantiate &lt;a href=&quot;qt3drender-qrenderstate&quot;&gt;QRenderState&lt;/a&gt; directly, but through its subclasses.</source>
          <target state="translated">&lt;a href=&quot;qt3drender-qrenderstate&quot;&gt;Qt3DRender :: QRenderState의&lt;/a&gt; 클래스는 상태를 렌더링하는 모든 추상 기본 클래스입니다. &lt;a href=&quot;qt3drender-qrenderstate&quot;&gt;QRenderState를&lt;/a&gt; 직접 인스턴스화 할 수 없지만 서브 클래스를 통해 인스턴스화 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="fce3cf2c4c4ee9b7b8a4f6120483efd9a61bc329" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3drender-qrenderstate&quot;&gt;Qt3DRender::QRenderState&lt;/a&gt; class is abstract base class for all render states. One can not instantiate QRenderState directly, but through its subclasses.</source>
          <target state="translated">&lt;a href=&quot;qt3drender-qrenderstate&quot;&gt;Qt3DRender :: QRenderState의&lt;/a&gt; 클래스는 상태를 렌더링하는 모든 추상 기본 클래스입니다. QRenderState를 직접 인스턴스화 할 수는 없지만 하위 클래스를 통해 인스턴스화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7de4eed4aa0b9b3b2ee97e4b4455f1b35eca7509" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3drender-qrendertarget&quot;&gt;Qt3DRender::QRenderTarget&lt;/a&gt; comprises of &lt;a href=&quot;qt3drender-qrendertargetoutput&quot;&gt;Qt3DRender::QRenderTargetOutput&lt;/a&gt; objects, which specify the the buffers the render target is rendering to. The user can specify MRT(Multiple Render Targets) by attaching multiple textures to different attachment points. The results are undefined if the user tries to attach multiple textures to the same attachment point. At render time, only the draw buffers specified in the &lt;a href=&quot;qt3drender-qrendertargetselector&quot;&gt;Qt3DRender::QRenderTargetSelector&lt;/a&gt; are used.</source>
          <target state="translated">&lt;a href=&quot;qt3drender-qrendertarget&quot;&gt;Qt3DRender :: QRenderTarget가&lt;/a&gt; 구성되어 &lt;a href=&quot;qt3drender-qrendertargetoutput&quot;&gt;Qt3DRender :: QRenderTargetOutput에&lt;/a&gt; 상기 버퍼가 타겟에 렌더링되어 렌더링 지정 개체. 사용자는 여러 텍스처를 다른 부착 점에 부착하여 MRT (Multiple Render Targets)를 지정할 수 있습니다. 사용자가 동일한 부착 점에 여러 텍스처를 부착하려고하면 결과가 정의되지 않습니다. 렌더링시 &lt;a href=&quot;qt3drender-qrendertargetselector&quot;&gt;Qt3DRender :: QRenderTargetSelector에&lt;/a&gt; 지정된 그리기 버퍼 만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5e37aa3ca14ea52cbbd6bb56ca1e9f18811dbe4e" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3drender-qrendertargetoutput&quot;&gt;QRenderTargetOutput&lt;/a&gt; specifies the attachment point and parameters for texture that is attached to render target. In addition to the attachment point, texture miplevel, layer and cubemap face can be specified. The texture attached to the &lt;a href=&quot;qt3drender-qrendertargetoutput&quot;&gt;QRenderTargetOutput&lt;/a&gt; must be compatible with the given parameters.</source>
          <target state="translated">&lt;a href=&quot;qt3drender-qrendertargetoutput&quot;&gt;QRenderTargetOutput은&lt;/a&gt; 부착 점과 렌더링 타겟에 부착 된 텍스처에 대한 파라미터를 지정한다. 부착 점 외에도 텍스처 밉 레벨, 레이어 및 큐브 맵면을 지정할 수 있습니다. &lt;a href=&quot;qt3drender-qrendertargetoutput&quot;&gt;QRenderTargetOutput에&lt;/a&gt; 첨부 된 텍스처 는 주어진 매개 변수와 호환 가능해야합니다.</target>
        </trans-unit>
        <trans-unit id="6fa72ae82a5613c4ae68df7e49f5058703d68a8e" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3drender-qrendertargetselector&quot;&gt;Qt3DRender::QRenderTargetSelector&lt;/a&gt; is used to select active &lt;a href=&quot;qt3drender-qrendertarget&quot;&gt;Qt3DRender::QRenderTarget&lt;/a&gt; for the FrameGraph. When &lt;a href=&quot;qt3drender-qrendertargetselector&quot;&gt;QRenderTargetSelector&lt;/a&gt; is present in the FrameGraph, the rendering is directed into QTexture objects or draw buffers instead of the surface specified in the &lt;a href=&quot;qt3drender-qrendersurfaceselector&quot;&gt;Qt3DRender::QRenderSurfaceSelector&lt;/a&gt;. A render buffer is automatically generated for an attachment point if drawBuffers contain attachment point that any output in the &lt;a href=&quot;qt3drender-qrendertarget&quot;&gt;QRenderTarget&lt;/a&gt; do not specify. If the drawBuffers is empty, the renderer will default to using all the outputs in &lt;a href=&quot;qt3drender-qrendertarget&quot;&gt;QRenderTarget&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qt3drender-qrendertargetselector&quot;&gt;Qt3DRender :: QRenderTargetSelector은&lt;/a&gt; 활성 선택하는 데 사용됩니다 &lt;a href=&quot;qt3drender-qrendertarget&quot;&gt;Qt3DRender :: QRenderTarget&lt;/a&gt; FrameGraph을 위해. 경우 &lt;a href=&quot;qt3drender-qrendertargetselector&quot;&gt;QRenderTargetSelector가&lt;/a&gt; FrameGraph에 존재 QTexture는 개체 또는 버퍼 대신에 지정된 표면 그릴에, 렌더링은 지향 &lt;a href=&quot;qt3drender-qrendersurfaceselector&quot;&gt;Qt3DRender ::를 QRenderSurfaceSelector&lt;/a&gt; . drawBuffers가 어느 것을 출력 접속점 포함될 경우 렌더링 버퍼가 자동으로 연결 지점에 대해 생성 &lt;a href=&quot;qt3drender-qrendertarget&quot;&gt;QRenderTarget가&lt;/a&gt; 지정하지있다. drawBuffers가 비어 있으면 렌더러는 기본적으로 &lt;a href=&quot;qt3drender-qrendertarget&quot;&gt;QRenderTarget의&lt;/a&gt; 모든 출력을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="b7946ed2513b237fc37415f12f173d8dc34e3568" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3drender-qrendertargetselector&quot;&gt;Qt3DRender::QRenderTargetSelector&lt;/a&gt; is used to select active &lt;a href=&quot;qt3drender-qrendertarget&quot;&gt;Qt3DRender::QRenderTarget&lt;/a&gt; for the FrameGraph. When QRenderTargetSelector is present in the FrameGraph, the rendering is directed into QTexture objects or draw buffers instead of the surface specified in the &lt;a href=&quot;qt3drender-qrendersurfaceselector&quot;&gt;Qt3DRender::QRenderSurfaceSelector&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qt3drender-qrendertargetselector&quot;&gt;Qt3DRender :: QRenderTargetSelector은&lt;/a&gt; 활성 선택하는 데 사용됩니다 &lt;a href=&quot;qt3drender-qrendertarget&quot;&gt;Qt3DRender :: QRenderTarget&lt;/a&gt; FrameGraph을 위해. QRenderTargetSelector가 FrameGraph에있는 경우 렌더링은 &lt;a href=&quot;qt3drender-qrendersurfaceselector&quot;&gt;Qt3DRender :: QRenderSurfaceSelector에&lt;/a&gt; 지정된 표면 대신 QTexture 객체 또는 그리기 버퍼로 전달 됩니다.</target>
        </trans-unit>
        <trans-unit id="78ccb346e45033f88d71f158c13653e66db068f6" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3drender-qrendertargetselector&quot;&gt;Qt3DRender::QRenderTargetSelector&lt;/a&gt; is used to select active &lt;a href=&quot;qt3drender-qrendertarget&quot;&gt;Qt3DRender::QRenderTarget&lt;/a&gt; for the FrameGraph. When QRenderTargetSelector is present in the FrameGraph, the rendering is directed into QTexture objects or draw buffers instead of the surface specified in the &lt;a href=&quot;qt3drender-qrendersurfaceselector&quot;&gt;Qt3DRender::QRenderSurfaceSelector&lt;/a&gt;. A render buffer is automatically generated for an attachment point if drawBuffers contain attachment point that any output in the &lt;a href=&quot;qt3drender-qrendertarget&quot;&gt;QRenderTarget&lt;/a&gt; do not specify. If the drawBuffers is empty, the renderer will default to using all the outputs in &lt;a href=&quot;qt3drender-qrendertarget&quot;&gt;QRenderTarget&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qt3drender-qrendertargetselector&quot;&gt;Qt3DRender :: QRenderTargetSelector은&lt;/a&gt; 활성 선택하는 데 사용됩니다 &lt;a href=&quot;qt3drender-qrendertarget&quot;&gt;Qt3DRender :: QRenderTarget&lt;/a&gt; FrameGraph을 위해. QRenderTargetSelector가 FrameGraph에 있으면 렌더링은 &lt;a href=&quot;qt3drender-qrendersurfaceselector&quot;&gt;Qt3DRender :: QRenderSurfaceSelector에&lt;/a&gt; 지정된 표면 대신 QTexture 객체 또는 그리기 버퍼로 전달 됩니다. drawBuffers가 어느 것을 출력 접속점 포함될 경우 렌더링 버퍼가 자동으로 연결 지점에 대해 생성 &lt;a href=&quot;qt3drender-qrendertarget&quot;&gt;QRenderTarget가&lt;/a&gt; 지정하지있다. drawBuffers가 비어 있으면 렌더러는 기본적으로 &lt;a href=&quot;qt3drender-qrendertarget&quot;&gt;QRenderTarget의&lt;/a&gt; 모든 출력을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="819fff895952cabe56b98ecbccd228ee234ec797" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3drender-qscissortest&quot;&gt;QScissorTest&lt;/a&gt; class enables scissor test, which discards fragments outside the rectangular area of the screen specified by the left, bottom, width and height properties.</source>
          <target state="translated">&lt;a href=&quot;qt3drender-qscissortest&quot;&gt;QScissorTest의&lt;/a&gt; 클래스 시저 테스트를 가능하게하는 왼쪽, 하단 너비와 높이 속성에 의해 지정된 화면 직사각형 영역 외부 폐기 단편.</target>
        </trans-unit>
        <trans-unit id="18b6ad22ce2db98a75fe284118c571414fa49914" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3drender-qsortpolicy&quot;&gt;Qt3DRender::QSortPolicy&lt;/a&gt; class stores the sorting type used by the FrameGraph. The sort types determine how drawable entities are sorted before drawing to determine the drawing order. When &lt;a href=&quot;qt3drender-qsortpolicy&quot;&gt;QSortPolicy&lt;/a&gt; is present in the FrameGraph, the sorting mechanism is determined by the SortTypes list. Multiple sort types can be used simultaneously. If &lt;a href=&quot;qt3drender-qsortpolicy&quot;&gt;QSortPolicy&lt;/a&gt; is not present in the FrameGraph, entities are drawn in the order they appear in the entity hierarchy.</source>
          <target state="translated">&lt;a href=&quot;qt3drender-qsortpolicy&quot;&gt;Qt3DRender :: QSortPolicy의&lt;/a&gt; 클래스를 저장 FrameGraph에 의해 사용되는 정렬 유형입니다. 정렬 유형은 그리기 순서를 결정하기 위해 그리기 전에 그리기 가능한 요소를 정렬하는 방법을 결정합니다. 경우 &lt;a href=&quot;qt3drender-qsortpolicy&quot;&gt;QSortPolicy가&lt;/a&gt; FrameGraph에 존재하는, 정렬 메커니즘은 SortTypes리스트에 의해 결정된다. 여러 정렬 유형을 동시에 사용할 수 있습니다. 경우 &lt;a href=&quot;qt3drender-qsortpolicy&quot;&gt;QSortPolicy가&lt;/a&gt; FrameGraph에 존재하지 않는, 엔티티들은 엔티티 계층 구조에 나타나는 순서대로 그려집니다.</target>
        </trans-unit>
        <trans-unit id="19487e43577c044e4ea703279877301fd0db0739" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3drender-qsortpolicy&quot;&gt;Qt3DRender::QSortPolicy&lt;/a&gt; class stores the sorting type used by the FrameGraph. The sort types determine how drawable entities are sorted before drawing to determine the drawing order. When QSortPolicy is present in the FrameGraph, the sorting mechanism is determined by the &lt;a href=&quot;qt3drender-qsortpolicy#sortTypes&quot;&gt;sortTypes&lt;/a&gt; list. Multiple sort types can be used simultaneously. If QSortPolicy is not present in the FrameGraph, entities are drawn in the order they appear in the entity hierarchy.</source>
          <target state="translated">&lt;a href=&quot;qt3drender-qsortpolicy&quot;&gt;Qt3DRender :: QSortPolicy의&lt;/a&gt; 클래스를 저장 FrameGraph에 의해 사용되는 정렬 유형입니다. 정렬 유형은 그리기 순서를 결정하기 위해 그리기 전에 그리기 가능 엔티티가 정렬되는 방식을 결정합니다. QSortPolicy가 FrameGraph에있는 경우 정렬 메커니즘은 &lt;a href=&quot;qt3drender-qsortpolicy#sortTypes&quot;&gt;sortTypes&lt;/a&gt; 목록에 의해 결정됩니다 . 여러 정렬 유형을 동시에 사용할 수 있습니다. QSortPolicy가 FrameGraph에없는 경우 엔터티는 엔터티 계층 구조에 나타나는 순서대로 그려집니다.</target>
        </trans-unit>
        <trans-unit id="9a47a8f595953bcf8f3616a6c7ded00ef2da0eb4" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3drender-qstencilmask&quot;&gt;Qt3DRender::QStencilMask&lt;/a&gt; class specifies a write mask for the stencil values after the stencil test. Mask can be specified separately for the front-facing and back-facing polygons. The fragment stencil value is and'd with the mask before it is written to the stencil buffer.</source>
          <target state="translated">&lt;a href=&quot;qt3drender-qstencilmask&quot;&gt;Qt3DRender :: QStencilMask의&lt;/a&gt; 클래스는 스텐실 테스트 후 스텐실 값을 쓰기 마스크를 지정합니다. 전면 및 후면 다각형에 대해 마스크를 별도로 지정할 수 있습니다. 조각 스텐실 값은 스텐실 버퍼에 기록되기 전에 마스크와 함께 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="502090419e9b95f6bf36f2a6d15cef3140b61f9d" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3drender-qstenciloperation&quot;&gt;Qt3DRender::QStencilOperation&lt;/a&gt; class specifies the stencil operations for the front- and back-facing polygons. The stencil operation control what is done to fragment when the stencil and depth test pass or fail.</source>
          <target state="translated">&lt;a href=&quot;qt3drender-qstenciloperation&quot;&gt;Qt3DRender :: QStencilOperation의&lt;/a&gt; 클래스는 전면 및 후면에 직면 다각형의 스텐실 작업을 지정합니다. 스텐실 작동은 스텐실 및 깊이 테스트가 통과하거나 실패 할 때 조각화되는 작업을 제어합니다.</target>
        </trans-unit>
        <trans-unit id="68242f911d0fdc34031c865352045409a58e0603" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3drender-qstenciltest&quot;&gt;Qt3DRender::QStencilTest&lt;/a&gt; class specifies argument for the stencil test. The stencil test comprises of three arguments: stencil test function, stencil test mask and stencil reference value. &lt;a href=&quot;qt3drender-qstenciltest&quot;&gt;QStencilTest&lt;/a&gt; allows these arguments to be set for both front- and back-facing polygons separately.</source>
          <target state="translated">&lt;a href=&quot;qt3drender-qstenciltest&quot;&gt;Qt3DRender :: QStencilTest&lt;/a&gt; 스텐실 테스트를위한 클래스를 지정 인수입니다. 스텐실 테스트는 스텐실 테스트 기능, 스텐실 테스트 마스크 및 스텐실 기준값의 세 가지 인수로 구성됩니다. &lt;a href=&quot;qt3drender-qstenciltest&quot;&gt;QStencilTest를&lt;/a&gt; 사용하면 이러한 인수를 전면 및 후면 다각형에 개별적으로 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0684c90a6fbf9630f94cd3db0e610fbd90c2a752" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3drender-qstenciltest&quot;&gt;Qt3DRender::QStencilTest&lt;/a&gt; class specifies argument for the stencil test. The stencil test comprises of three arguments: stencil test function, stencil test mask and stencil reference value. QStencilTest allows these arguments to be set for both front- and back-facing polygons separately.</source>
          <target state="translated">&lt;a href=&quot;qt3drender-qstenciltest&quot;&gt;Qt3DRender :: QStencilTest&lt;/a&gt; 스텐실 테스트를위한 클래스를 지정 인수입니다. 스텐실 테스트는 스텐실 테스트 함수, 스텐실 테스트 마스크 및 스텐실 참조 값의 세 가지 인수로 구성됩니다. QStencilTest를 사용하면 이러한 인수를 전면 및 후면 다각형 모두에 대해 별도로 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="162e0c1b9e9c9a49f1d1883189d0af64491a66b3" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3drender-qtechnique&quot;&gt;Qt3DRender::QTechnique&lt;/a&gt; specifies a set of &lt;a href=&quot;qt3drender-qrenderpass&quot;&gt;Qt3DRender::QRenderPass&lt;/a&gt; objects, &lt;a href=&quot;qt3drender-qfilterkey&quot;&gt;Qt3DRender::QFilterKey&lt;/a&gt; objects, &lt;a href=&quot;qt3drender-qparameter&quot;&gt;Qt3DRender::QParameter&lt;/a&gt; objects and a &lt;a href=&quot;qt3drender-qgraphicsapifilter&quot;&gt;Qt3DRender::QGraphicsApiFilter&lt;/a&gt;, which together define a rendering technique the given graphics API can render. The filter keys are used by &lt;a href=&quot;qt3drender-qtechniquefilter&quot;&gt;Qt3DRender::QTechniqueFilter&lt;/a&gt; to select specific techniques at specific parts of the FrameGraph. If two &lt;a href=&quot;qt3drender-qparameter&quot;&gt;QParameter&lt;/a&gt; instances with the same name are specified in a &lt;a href=&quot;qt3drender-qtechnique&quot;&gt;QTechnique&lt;/a&gt; and a &lt;a href=&quot;qt3drender-qrenderpass&quot;&gt;QRenderPass&lt;/a&gt;, the one in Technique overrides the one used in the &lt;a href=&quot;qt3drender-qrenderpass&quot;&gt;QRenderPass&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qt3drender-qtechnique&quot;&gt;Qt3DRender :: QTechnique이&lt;/a&gt; 세트 지정 &lt;a href=&quot;qt3drender-qrenderpass&quot;&gt;Qt3DRender :: QRenderPass을&lt;/a&gt; , 객체 &lt;a href=&quot;qt3drender-qfilterkey&quot;&gt;Qt3DRender :: QFilterKey는&lt;/a&gt; , 객체 &lt;a href=&quot;qt3drender-qparameter&quot;&gt;Qt3DRender :: QParameter은&lt;/a&gt; 객체와 &lt;a href=&quot;qt3drender-qgraphicsapifilter&quot;&gt;Qt3DRender :: QGraphicsApiFilter&lt;/a&gt; 함께 주어진 그래픽 API 렌더링 할 수있는 렌더링 기술을 정의합니다. &lt;a href=&quot;qt3drender-qtechniquefilter&quot;&gt;Qt3DRender :: QTechniqueFilter&lt;/a&gt; 는 필터 키를 사용 하여 FrameGraph의 특정 부분에서 특정 기술을 선택합니다. 이 개 경우 &lt;a href=&quot;qt3drender-qparameter&quot;&gt;QParameter의&lt;/a&gt; 같은 이름의 인스턴스가 지정됩니다 &lt;a href=&quot;qt3drender-qtechnique&quot;&gt;QTechnique&lt;/a&gt; 과 &lt;a href=&quot;qt3drender-qrenderpass&quot;&gt;QRenderPass&lt;/a&gt; , 기술의 하나가에서 사용되는 우선 &lt;a href=&quot;qt3drender-qrenderpass&quot;&gt;QRenderPass을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dc56736ddd2b877e66527236d306841c084273d3" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3drender-qtechnique&quot;&gt;Qt3DRender::QTechnique&lt;/a&gt; specifies a set of &lt;a href=&quot;qt3drender-qrenderpass&quot;&gt;Qt3DRender::QRenderPass&lt;/a&gt; objects, &lt;a href=&quot;qt3drender-qfilterkey&quot;&gt;Qt3DRender::QFilterKey&lt;/a&gt; objects, &lt;a href=&quot;qt3drender-qparameter&quot;&gt;Qt3DRender::QParameter&lt;/a&gt; objects and a &lt;a href=&quot;qt3drender-qgraphicsapifilter&quot;&gt;Qt3DRender::QGraphicsApiFilter&lt;/a&gt;, which together define a rendering technique the given graphics API can render. The filter keys are used by &lt;a href=&quot;qt3drender-qtechniquefilter&quot;&gt;Qt3DRender::QTechniqueFilter&lt;/a&gt; to select specific techniques at specific parts of the FrameGraph. If two &lt;a href=&quot;qt3drender-qparameter&quot;&gt;QParameter&lt;/a&gt; instances with the same name are specified in a QTechnique and a &lt;a href=&quot;qt3drender-qrenderpass&quot;&gt;QRenderPass&lt;/a&gt;, the one in Technique overrides the one used in the &lt;a href=&quot;qt3drender-qrenderpass&quot;&gt;QRenderPass&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qt3drender-qtechnique&quot;&gt;Qt3DRender :: QTechnique이&lt;/a&gt; 세트 지정 &lt;a href=&quot;qt3drender-qrenderpass&quot;&gt;Qt3DRender :: QRenderPass을&lt;/a&gt; , 객체 &lt;a href=&quot;qt3drender-qfilterkey&quot;&gt;Qt3DRender :: QFilterKey는&lt;/a&gt; , 객체 &lt;a href=&quot;qt3drender-qparameter&quot;&gt;Qt3DRender :: QParameter은&lt;/a&gt; 객체와 &lt;a href=&quot;qt3drender-qgraphicsapifilter&quot;&gt;Qt3DRender :: QGraphicsApiFilter&lt;/a&gt; 함께 주어진 그래픽 API 렌더링 할 수있는 렌더링 기술을 정의합니다. 필터 키는 &lt;a href=&quot;qt3drender-qtechniquefilter&quot;&gt;Qt3DRender :: QTechniqueFilter&lt;/a&gt; 에서 FrameGraph의 특정 부분에서 특정 기술을 선택 하는 데 사용됩니다 . 이 경우 &lt;a href=&quot;qt3drender-qparameter&quot;&gt;QParameter의&lt;/a&gt; 이름이 같은 경우가 QTechnique과에 지정되어 &lt;a href=&quot;qt3drender-qrenderpass&quot;&gt;QRenderPass&lt;/a&gt; , 기술의 하나가에서 사용되는 우선 &lt;a href=&quot;qt3drender-qrenderpass&quot;&gt;QRenderPass을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="97129c47e8a30fda3f8b8753e5ea1543a152bc90" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3drender-qtechniquefilter&quot;&gt;Qt3DRender::QTechniqueFilter&lt;/a&gt; specifies which techniques are used by the FrameGraph when rendering the entities. &lt;a href=&quot;qt3drender-qtechniquefilter&quot;&gt;QTechniqueFilter&lt;/a&gt; specifies a list of &lt;a href=&quot;qt3drender-qfilterkey&quot;&gt;Qt3DRender::QFilterKey&lt;/a&gt; objects and &lt;a href=&quot;qt3drender-qparameter&quot;&gt;Qt3DRender::QParameter&lt;/a&gt; objects. When &lt;a href=&quot;qt3drender-qtechniquefilter&quot;&gt;QTechniqueFilter&lt;/a&gt; is present in the FrameGraph, only the techiques matching the keys in the list are used for rendering. The parameters in the list can be used to set values for shader parameters. The parameters in &lt;a href=&quot;qt3drender-qtechniquefilter&quot;&gt;QTechniqueFilter&lt;/a&gt; are overridden by parameters in &lt;a href=&quot;qt3drender-qtechnique&quot;&gt;QTechnique&lt;/a&gt; and &lt;a href=&quot;qt3drender-qrenderpass&quot;&gt;QRenderPass&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qt3drender-qtechniquefilter&quot;&gt;Qt3DRender :: QTechniqueFilter의&lt;/a&gt; 엔티티를 렌더링 할 때의 기술이 FrameGraph 지정하여 사용된다. &lt;a href=&quot;qt3drender-qtechniquefilter&quot;&gt;QTechniqueFilter&lt;/a&gt; 는 &lt;a href=&quot;qt3drender-qfilterkey&quot;&gt;Qt3DRender :: QFilterKey&lt;/a&gt; 오브젝트 및 &lt;a href=&quot;qt3drender-qparameter&quot;&gt;Qt3DRender :: QParameter&lt;/a&gt; 오브젝트 목록을 지정 합니다. 경우 &lt;a href=&quot;qt3drender-qtechniquefilter&quot;&gt;QTechniqueFilter가&lt;/a&gt; FrameGraph에 존재하는 목록에있는 키와 일치하는 경우에만 techiques 렌더링에 이용된다. 목록의 매개 변수를 사용하여 셰이더 매개 변수의 값을 설정할 수 있습니다. &lt;a href=&quot;qt3drender-qtechniquefilter&quot;&gt;QTechniqueFilter&lt;/a&gt; 의 매개 변수는 &lt;a href=&quot;qt3drender-qtechnique&quot;&gt;QTechnique&lt;/a&gt; 및 &lt;a href=&quot;qt3drender-qrenderpass&quot;&gt;QRenderPass의&lt;/a&gt; 매개 변수로 대체됩니다 .</target>
        </trans-unit>
        <trans-unit id="77860dd614fd15fb731610a2a12afafe80d82798" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qt3drender-qtechniquefilter&quot;&gt;Qt3DRender::QTechniqueFilter&lt;/a&gt; specifies which techniques are used by the FrameGraph when rendering the entities. QTechniqueFilter specifies a list of &lt;a href=&quot;qt3drender-qfilterkey&quot;&gt;Qt3DRender::QFilterKey&lt;/a&gt; objects and &lt;a href=&quot;qt3drender-qparameter&quot;&gt;Qt3DRender::QParameter&lt;/a&gt; objects. When QTechniqueFilter is present in the FrameGraph, only the techiques matching the keys in the list are used for rendering. The parameters in the list can be used to set values for shader parameters. The parameters in QTechniqueFilter are overridden by parameters in &lt;a href=&quot;qt3drender-qtechnique&quot;&gt;QTechnique&lt;/a&gt; and &lt;a href=&quot;qt3drender-qrenderpass&quot;&gt;QRenderPass&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qt3drender-qtechniquefilter&quot;&gt;Qt3DRender :: QTechniqueFilter의&lt;/a&gt; 엔티티를 렌더링 할 때의 기술이 FrameGraph 지정하여 사용된다. QTechniqueFilter는 &lt;a href=&quot;qt3drender-qfilterkey&quot;&gt;Qt3DRender :: QFilterKey&lt;/a&gt; 개체 및 &lt;a href=&quot;qt3drender-qparameter&quot;&gt;Qt3DRender :: QParameter&lt;/a&gt; 개체 목록을 지정 합니다. QTechniqueFilter가 FrameGraph에 있으면 목록의 키와 일치하는 기술 만 렌더링에 사용됩니다. 목록의 매개 변수를 사용하여 셰이더 매개 변수의 값을 설정할 수 있습니다. QTechniqueFilter의 매개 변수는 &lt;a href=&quot;qt3drender-qtechnique&quot;&gt;QTechnique&lt;/a&gt; 및 &lt;a href=&quot;qt3drender-qrenderpass&quot;&gt;QRenderPass의&lt;/a&gt; 매개 변수로 대체됩니다 .</target>
        </trans-unit>
        <trans-unit id="4a6f2c03d74ab8436f3ccd0e2b0ca4dc1d6b4020" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qtableview&quot;&gt;QTableView&lt;/a&gt; implements a table view that displays items from a model. This class is used to provide standard tables that were previously provided by the QTable class, but using the more flexible approach provided by Qt's model/view architecture.</source>
          <target state="translated">&lt;a href=&quot;qtableview&quot;&gt;QTableView은&lt;/a&gt; 모델에서 표시 항목이 테이블 뷰를 구현합니다. 이 클래스는 이전에 QTable 클래스에서 제공 한 표준 테이블을 제공하는 데 사용되지만 Qt의 모델 / 뷰 아키텍처에서 제공하는보다 유연한 접근 방식을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="5e74ea7a77dfe4abe3e4e8b556378fa7c8aae86e" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qtabwidget&quot;&gt;QTabWidget&lt;/a&gt; instance.</source>
          <target state="translated">&lt;a href=&quot;qtabwidget&quot;&gt;QTabWidget의&lt;/a&gt; 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="a955eb897bff96d648e55b3a97a1ffe837d3bb75" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qtcore-changes-qt6#qvariant&quot;&gt;QVariant&lt;/a&gt; containing a null pointer (&lt;a href=&quot;qmetatype#Type-enum&quot;&gt;QMetaType::Nullptr&lt;/a&gt;).</source>
          <target state="translated">&lt;a href=&quot;qtcore-changes-qt6#qvariant&quot;&gt;QVariant&lt;/a&gt; 널 포인터 (포함 &lt;a href=&quot;qmetatype#Type-enum&quot;&gt;QMetaType :: Nullptr을&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="a4da8aefff6e90e843e198bfe82e96a61f8fbd12" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qtcore-changes-qt6#qvariant&quot;&gt;QVariant&lt;/a&gt; containing a pointer to a type derived from &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; will also convert and return true for this function if a &lt;a href=&quot;qobject#qobject_cast&quot;&gt;qobject_cast&lt;/a&gt; to the type described by</source>
          <target state="translated">&lt;a href=&quot;qtcore-changes-qt6#qvariant&quot;&gt;QVariant은&lt;/a&gt; 로부터 도출 된 타입의 포인터 함유 &lt;a href=&quot;qobject&quot;&gt;있는 QObject를&lt;/a&gt; 경우도 변환이 함수에 true를 반환한다 &lt;a href=&quot;qobject#qobject_cast&quot;&gt;qobject_cast&lt;/a&gt; 형태에 의해 기재</target>
        </trans-unit>
        <trans-unit id="fd04b8fd800f396c37bc220d064d8ce2dd5efa2b" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qtcore-changes-qt6#qvariant&quot;&gt;QVariant&lt;/a&gt; containing a pointer to a type derived from &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; will also return true for this function if a &lt;a href=&quot;qobject#qobject_cast&quot;&gt;qobject_cast&lt;/a&gt; to the template type &lt;code&gt;T&lt;/code&gt; would succeed. Note that this only works for &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; subclasses which use the &lt;a href=&quot;qobject#Q_OBJECT&quot;&gt;Q_OBJECT&lt;/a&gt; macro.</source>
          <target state="translated">&lt;a href=&quot;qtcore-changes-qt6#qvariant&quot;&gt;QVariant&lt;/a&gt; 에서 파생 된 유형에 대한 포인터를 포함 &lt;a href=&quot;qobject&quot;&gt;QObject를이&lt;/a&gt; 경우이 함수에 대해 true를 반환합니다 &lt;a href=&quot;qobject#qobject_cast&quot;&gt;qobject_cast&lt;/a&gt; 템플릿 유형 &lt;code&gt;T&lt;/code&gt; 는 성공할 것입니다. 이것은 &lt;a href=&quot;qobject#Q_OBJECT&quot;&gt;Q_OBJECT&lt;/a&gt; 매크로 를 사용하는 &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 서브 클래스 에서만 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="d2e9a12513d18fb4a07d1a44be432c7356345adc" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qtcore-changes-qt6#qvariant&quot;&gt;QVariant&lt;/a&gt; containing a pointer to the &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qtcore-changes-qt6#qvariant&quot;&gt;QVariant&lt;/a&gt; 받는 포인터 들어 &lt;a href=&quot;qobject&quot;&gt;있는 QObject를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="574c0d866403de1435a6670691542a5becf19048" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qtcore-changes-qt6#qvariant&quot;&gt;QVariant&lt;/a&gt; containing the date value (&lt;a href=&quot;qjsvalue#toDateTime&quot;&gt;toDateTime&lt;/a&gt;()).</source>
          <target state="translated">날짜 값 ( &lt;a href=&quot;qjsvalue#toDateTime&quot;&gt;toDateTime&lt;/a&gt; ())을 포함 하는 &lt;a href=&quot;qtcore-changes-qt6#qvariant&quot;&gt;QVariant&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="13863fd12ad5ecfdb5b33ef41f73a281cde03bdd" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qtcore-changes-qt6#qvariant&quot;&gt;QVariant&lt;/a&gt; containing the regular expression value.</source>
          <target state="translated">정규식 값을 포함 하는 &lt;a href=&quot;qtcore-changes-qt6#qvariant&quot;&gt;QVariant&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="54075c2a6b5cfce5b9ac0aa4c294463881a76a14" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qtcore-changes-qt6#qvariant&quot;&gt;QVariant&lt;/a&gt; containing the value of the boolean.</source>
          <target state="translated">부울 값을 포함 하는 &lt;a href=&quot;qtcore-changes-qt6#qvariant&quot;&gt;QVariant&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="681746cf2027b83b09aee0f99570fa1ce3fc201c" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qtcore-changes-qt6#qvariant&quot;&gt;QVariant&lt;/a&gt; containing the value of the number.</source>
          <target state="translated">숫자 값을 포함 하는 &lt;a href=&quot;qtcore-changes-qt6#qvariant&quot;&gt;QVariant&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="33e641b960ea30125d28bc373233f778ce387692" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qtcore-changes-qt6#qvariant&quot;&gt;QVariant&lt;/a&gt; containing the value of the string.</source>
          <target state="translated">문자열 값을 포함 하는 &lt;a href=&quot;qtcore-changes-qt6#qvariant&quot;&gt;QVariant&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="715626ae2c7ba52f2f69eb7446ae8671789644af" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qtcore-changes-qt6#qvariant&quot;&gt;QVariant&lt;/a&gt; is used because &lt;a href=&quot;qmimedata&quot;&gt;QMimeData&lt;/a&gt; belongs to the Qt Core module, whereas &lt;a href=&quot;qcolor&quot;&gt;QColor&lt;/a&gt; belongs to Qt GUI. To convert the &lt;a href=&quot;qtcore-changes-qt6#qvariant&quot;&gt;QVariant&lt;/a&gt; to a &lt;a href=&quot;qcolor&quot;&gt;QColor&lt;/a&gt;, simply use &lt;a href=&quot;qvariant#qvariant_cast&quot;&gt;qvariant_cast&lt;/a&gt;(). For example:</source>
          <target state="translated">&lt;a href=&quot;qtcore-changes-qt6#qvariant&quot;&gt;QVariant이&lt;/a&gt; 때문에 사용 &lt;a href=&quot;qmimedata&quot;&gt;QMimeData는&lt;/a&gt; 반면 Qt의 코어 모듈에 속하는 &lt;a href=&quot;qcolor&quot;&gt;QColor는&lt;/a&gt; Qt는 GUI에 속한다. &lt;a href=&quot;qtcore-changes-qt6#qvariant&quot;&gt;QVariant&lt;/a&gt; 를 &lt;a href=&quot;qcolor&quot;&gt;QColor&lt;/a&gt; 로 변환하려면 간단히 &lt;a href=&quot;qvariant#qvariant_cast&quot;&gt;qvariant_cast&lt;/a&gt; () 를 사용 하십시오 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4a812f49e48cb4981106675a8a276ddcb730ce9b" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qtcore-changes-qt6#qvariant&quot;&gt;QVariant&lt;/a&gt; is used because &lt;a href=&quot;qmimedata&quot;&gt;QMimeData&lt;/a&gt; belongs to the Qt Core module, whereas &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt; belongs to Qt GUI. The conversion from &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt; to &lt;a href=&quot;qtcore-changes-qt6#qvariant&quot;&gt;QVariant&lt;/a&gt; is implicit. For example:</source>
          <target state="translated">&lt;a href=&quot;qtcore-changes-qt6#qvariant&quot;&gt;QVariant이&lt;/a&gt; 때문에 사용 &lt;a href=&quot;qmimedata&quot;&gt;QMimeData는&lt;/a&gt; 반면 Qt의 코어 모듈에 속하는 &lt;a href=&quot;qimage&quot;&gt;QImage는&lt;/a&gt; Qt는 GUI에 속한다. &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt; 에서 &lt;a href=&quot;qtcore-changes-qt6#qvariant&quot;&gt;QVariant&lt;/a&gt; 로의 변환 은 암시 적입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="dcb47663dbf88eb528da248c08f1e6b2f5c30680" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qtcore-changes-qt6#qvariant&quot;&gt;QVariant&lt;/a&gt; is used because &lt;a href=&quot;qmimedata&quot;&gt;QMimeData&lt;/a&gt; belongs to the Qt Core module, whereas &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt; belongs to Qt GUI. To convert the &lt;a href=&quot;qtcore-changes-qt6#qvariant&quot;&gt;QVariant&lt;/a&gt; to a &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt;, simply use &lt;a href=&quot;qvariant#qvariant_cast&quot;&gt;qvariant_cast&lt;/a&gt;(). For example:</source>
          <target state="translated">&lt;a href=&quot;qtcore-changes-qt6#qvariant&quot;&gt;QVariant이&lt;/a&gt; 때문에 사용 &lt;a href=&quot;qmimedata&quot;&gt;QMimeData는&lt;/a&gt; 반면 Qt의 코어 모듈에 속하는 &lt;a href=&quot;qimage&quot;&gt;QImage는&lt;/a&gt; Qt는 GUI에 속한다. &lt;a href=&quot;qtcore-changes-qt6#qvariant&quot;&gt;QVariant&lt;/a&gt; 를 &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt; 로 변환하려면 간단히 &lt;a href=&quot;qvariant#qvariant_cast&quot;&gt;qvariant_cast&lt;/a&gt; () 를 사용 하십시오 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="728f8dae8c9f9b30283440c7593cabfa6b64c069" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qtcore-changes-qt6#qvariant&quot;&gt;QVariant&lt;/a&gt; with a structure dependent on the type of extension.</source>
          <target state="translated">&lt;a href=&quot;qtcore-changes-qt6#qvariant&quot;&gt;QVariant&lt;/a&gt; 확장의 타입에 의존하는 구조로.</target>
        </trans-unit>
        <trans-unit id="95dbb32e8ff2ee88f6a2ad54183dc47bdd3545ea" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qtemporaryfile&quot;&gt;QTemporaryFile&lt;/a&gt; will always be opened in &lt;a href=&quot;qiodevice#OpenModeFlag-enum&quot;&gt;QIODevice::ReadWrite&lt;/a&gt; mode, this allows easy access to the data in the file. This function will return true upon success and will set the &lt;a href=&quot;qtemporaryfile#fileName&quot;&gt;fileName&lt;/a&gt;() to the unique filename used.</source>
          <target state="translated">&lt;a href=&quot;qtemporaryfile&quot;&gt;QTemporaryFile는&lt;/a&gt; 항상에서 열립니다 &lt;a href=&quot;qiodevice#OpenModeFlag-enum&quot;&gt;QIODevice :: 읽기 쓰기&lt;/a&gt; 모드는,이 파일의 데이터에 쉽게 액세스 할 수 있습니다. 이 함수는 성공하면 true를 반환하고 &lt;a href=&quot;qtemporaryfile#fileName&quot;&gt;fileName&lt;/a&gt; ()을 사용 된 고유 한 파일 이름으로 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="9710904739376867595b5f5af40bef1af3542566" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qtemporaryfile&quot;&gt;QTemporaryFile&lt;/a&gt; will always be opened in &lt;a href=&quot;qiodevicebase#OpenModeFlag-enum&quot;&gt;QIODevice::ReadWrite&lt;/a&gt; mode, this allows easy access to the data in the file. This function will return true upon success and will set the &lt;a href=&quot;qtemporaryfile#fileName&quot;&gt;fileName&lt;/a&gt;() to the unique filename used.</source>
          <target state="translated">&lt;a href=&quot;qtemporaryfile&quot;&gt;QTemporaryFile는&lt;/a&gt; 항상에서 열립니다 &lt;a href=&quot;qiodevicebase#OpenModeFlag-enum&quot;&gt;QIODevice :: 읽기 쓰기&lt;/a&gt; 모드는,이 파일의 데이터에 쉽게 액세스 할 수 있습니다. 이 함수는 성공하면 true를 반환하고 &lt;a href=&quot;qtemporaryfile#fileName&quot;&gt;fileName&lt;/a&gt; ()을 사용 된 고유 한 파일 이름으로 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="5fad42bc25065d9438adcb3ce60f3b89f3c3a99d" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qtesteventlist&quot;&gt;QTestEventList&lt;/a&gt; can be populated with GUI events that can be stored as test data for later usage, or be replayed on any &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt;. &lt;a href=&quot;qtesteventlist&quot;&gt;QTestEventList&lt;/a&gt; provides convenience functions for populating the list.</source>
          <target state="translated">&lt;a href=&quot;qtesteventlist&quot;&gt;QTestEventList는&lt;/a&gt; 나중에 사용에 대한 테스트 데이터로 저장 될 수있다, 또는에서 재생되는 GUI 이벤트로 채울 수 &lt;a href=&quot;qwidget&quot;&gt;는 QWidget&lt;/a&gt; . &lt;a href=&quot;qtesteventlist&quot;&gt;QTestEventList&lt;/a&gt; 는 목록을 채우기 위한 편리한 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="8ce846efd13b2caa367746b150e5e4c7376cdc36" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qtextcharformat&quot;&gt;QTextCharFormat&lt;/a&gt; for the part of the preedit string specified by start and length. value contains a &lt;a href=&quot;qtcore-changes-qt6#qvariant&quot;&gt;QVariant&lt;/a&gt; of type &lt;a href=&quot;qtextformat&quot;&gt;QTextFormat&lt;/a&gt; specifying rendering of this part of the preedit string. There should be at most one format for every part of the preedit string. If several are specified for any character in the string the behaviour is undefined. A conforming implementation has to at least honor the backgroundColor, textColor and fontUnderline properties of the format.</source>
          <target state="translated">&lt;a href=&quot;qtextcharformat&quot;&gt;QTextCharFormat&lt;/a&gt; 사전 편집 문자열의 부분은 시작과 길이로 지정했습니다. 값 은 사전 편집 문자열의이 부분의 렌더링을 지정 하는 &lt;a href=&quot;qtcore-changes-qt6#qvariant&quot;&gt;QTextFormat&lt;/a&gt; 유형의 &lt;a href=&quot;qtextformat&quot;&gt;QVariant&lt;/a&gt; 를 포함 합니다. 사전 편집 문자열의 모든 부분에 대해 최대 하나의 형식이 있어야합니다. 문자열의 문자에 대해 여러 개를 지정하면 동작이 정의되지 않습니다. 준수하는 구현은 최소한 형식의 backgroundColor, textColor 및 fontUnderline 속성을 준수해야합니다.</target>
        </trans-unit>
        <trans-unit id="66f965a8fe0a2df015d0aefb49c6b5b9f6edac66" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qtextcharformat&quot;&gt;QTextCharFormat&lt;/a&gt; for the part of the preedit string specified by start and length. value contains a &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; of type &lt;a href=&quot;qtextformat&quot;&gt;QTextFormat&lt;/a&gt; specifying rendering of this part of the preedit string. There should be at most one format for every part of the preedit string. If several are specified for any character in the string the behaviour is undefined. A conforming implementation has to at least honor the backgroundColor, textColor and fontUnderline properties of the format.</source>
          <target state="translated">&lt;a href=&quot;qtextcharformat&quot;&gt;QTextCharFormat&lt;/a&gt; 사전 편집 문자열의 부분은 시작과 길이로 지정했습니다. value 는 사전 편집 문자열의이 부분 렌더링을 지정 하는 &lt;a href=&quot;qvariant&quot;&gt;QTextFormat&lt;/a&gt; 유형의 &lt;a href=&quot;qtextformat&quot;&gt;QVariant&lt;/a&gt; 를 포함 합니다. 사전 편집 문자열의 모든 부분마다 최대 하나의 형식이 있어야합니다. 문자열의 문자에 대해 여러 개를 지정하면 동작이 정의되지 않습니다. 적합한 구현은 최소한 형식의 backgroundColor, textColor 및 fontUnderline 속성을 존중해야합니다.</target>
        </trans-unit>
        <trans-unit id="bf12c0a932a73542c77b616214a5108e191e2092" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qtextcursor&quot;&gt;QTextCursor&lt;/a&gt; also has an &lt;a href=&quot;qtextcursor#anchor&quot;&gt;anchor&lt;/a&gt;() position. The text that is between the &lt;a href=&quot;qtextcursor#anchor&quot;&gt;anchor&lt;/a&gt;() and the &lt;a href=&quot;qtextcursor#position&quot;&gt;position&lt;/a&gt;() is the selection. If &lt;a href=&quot;qtextcursor#anchor&quot;&gt;anchor&lt;/a&gt;() == &lt;a href=&quot;qtextcursor#position&quot;&gt;position&lt;/a&gt;() there is no selection.</source>
          <target state="translated">&lt;a href=&quot;qtextcursor&quot;&gt;QTextCursor은&lt;/a&gt; 또한 보유 &lt;a href=&quot;qtextcursor#anchor&quot;&gt;앵커&lt;/a&gt; ()의 총수. &lt;a href=&quot;qtextcursor#anchor&quot;&gt;앵커&lt;/a&gt; ()와 &lt;a href=&quot;qtextcursor#position&quot;&gt;위치&lt;/a&gt; () 사이에있는 텍스트가 선택입니다. 경우 &lt;a href=&quot;qtextcursor#anchor&quot;&gt;앵커&lt;/a&gt; () == &lt;a href=&quot;qtextcursor#position&quot;&gt;위치&lt;/a&gt; ()에는 선택이 없다.</target>
        </trans-unit>
        <trans-unit id="7322812ce953218f300f2a4e39c1f0b579c70cce" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qtextdocument&quot;&gt;QTextDocument&lt;/a&gt; can be edited programmatically using a &lt;a href=&quot;qtextcursor&quot;&gt;QTextCursor&lt;/a&gt;, and its contents can be examined by traversing the document structure. The entire document structure is stored as a hierarchy of document elements beneath the root frame, found with the &lt;a href=&quot;qtextdocument#rootFrame&quot;&gt;rootFrame&lt;/a&gt;() function. Alternatively, if you just want to iterate over the textual contents of the document you can use &lt;a href=&quot;qtextdocument#begin&quot;&gt;begin&lt;/a&gt;(), &lt;a href=&quot;qtextdocument#end&quot;&gt;end&lt;/a&gt;(), and &lt;a href=&quot;qtextdocument#findBlock&quot;&gt;findBlock&lt;/a&gt;() to retrieve text blocks that you can examine and iterate over.</source>
          <target state="translated">&lt;a href=&quot;qtextdocument&quot;&gt;QTextDocument를&lt;/a&gt; 사용하여 A 프로그램을 편집 할 수 &lt;a href=&quot;qtextcursor&quot;&gt;QTextCursor를&lt;/a&gt; , 그 내용은 문서 구조를 통과하여 조사 할 수있다. 전체 문서 구조는 &lt;a href=&quot;qtextdocument#rootFrame&quot;&gt;rootFrame&lt;/a&gt; () 함수로 찾은 루트 프레임 아래에 문서 요소의 계층 구조로 저장됩니다 . 또는 문서의 텍스트 내용을 반복하려는 경우 &lt;a href=&quot;qtextdocument#begin&quot;&gt;begin&lt;/a&gt; (), &lt;a href=&quot;qtextdocument#end&quot;&gt;end&lt;/a&gt; () 및 &lt;a href=&quot;qtextdocument#findBlock&quot;&gt;findBlock&lt;/a&gt; ()을 사용하여 검토하고 반복 할 수있는 텍스트 블록을 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4295e2b42de7d098c0ecc534b2a9300465e87623" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qtextdocumentfragment&quot;&gt;QTextDocumentFragment&lt;/a&gt; is a fragment of rich text, that can be inserted into a &lt;a href=&quot;qtextdocument&quot;&gt;QTextDocument&lt;/a&gt;. A document fragment can be created from a &lt;a href=&quot;qtextdocument&quot;&gt;QTextDocument&lt;/a&gt;, from a &lt;a href=&quot;qtextcursor&quot;&gt;QTextCursor&lt;/a&gt;'s selection, or from another document fragment. Document fragments can also be created by the static functions, &lt;a href=&quot;qtextdocumentfragment#fromPlainText&quot;&gt;fromPlainText&lt;/a&gt;() and &lt;a href=&quot;qtextdocumentfragment#fromHtml&quot;&gt;fromHtml&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qtextdocumentfragment&quot;&gt;QTextDocumentFragment은&lt;/a&gt; (A) 내로 삽입 될 수있는 다양한 텍스트의 단편이다 &lt;a href=&quot;qtextdocument&quot;&gt;QTextDocument&lt;/a&gt; . 문서 단편 (A)로부터 생성 될 수 &lt;a href=&quot;qtextdocument&quot;&gt;QTextDocument&lt;/a&gt; A로부터, &lt;a href=&quot;qtextcursor&quot;&gt;QTextCursor&lt;/a&gt; 의 선택, 또는 다른 문서에서 단편. 정적 함수 인 &lt;a href=&quot;qtextdocumentfragment#fromPlainText&quot;&gt;fromPlainText&lt;/a&gt; () 및 &lt;a href=&quot;qtextdocumentfragment#fromHtml&quot;&gt;fromHtml&lt;/a&gt; () 을 사용하여 문서 조각을 만들 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d876cfbe6e71d17a495b5f9f4923bc3aadffb7f2" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qtextformat&quot;&gt;QTextFormat&lt;/a&gt; is a generic class used for describing the format of parts of a &lt;a href=&quot;qtextdocument&quot;&gt;QTextDocument&lt;/a&gt;. The derived classes &lt;a href=&quot;qtextcharformat&quot;&gt;QTextCharFormat&lt;/a&gt;, &lt;a href=&quot;qtextblockformat&quot;&gt;QTextBlockFormat&lt;/a&gt;, &lt;a href=&quot;qtextlistformat&quot;&gt;QTextListFormat&lt;/a&gt;, and &lt;a href=&quot;qtexttableformat&quot;&gt;QTextTableFormat&lt;/a&gt; are usually more useful, and describe the formatting that is applied to specific parts of the document.</source>
          <target state="translated">&lt;a href=&quot;qtextformat&quot;&gt;QTextFormat는&lt;/a&gt; (A)의 일부의 포맷을 설명하기 위해 사용되는 일반적인 클래스 &lt;a href=&quot;qtextdocument&quot;&gt;QTextDocument를&lt;/a&gt; . 파생 클래스 &lt;a href=&quot;qtextcharformat&quot;&gt;QTextCharFormat&lt;/a&gt; , &lt;a href=&quot;qtextblockformat&quot;&gt;QTextBlockFormat&lt;/a&gt; , &lt;a href=&quot;qtextlistformat&quot;&gt;QTextListFormat&lt;/a&gt; 및 &lt;a href=&quot;qtexttableformat&quot;&gt;QTextTableFormat&lt;/a&gt; 은 일반적으로 더 유용하며 문서의 특정 부분에 적용되는 형식을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="e651ac6f3aeffaa0c4c84a170a93624518d05f13" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qthread&quot;&gt;QThread&lt;/a&gt; object manages one thread of control within the program. QThreads begin executing in &lt;a href=&quot;qthread#run&quot;&gt;run&lt;/a&gt;(). By default, &lt;a href=&quot;qthread#run&quot;&gt;run&lt;/a&gt;() starts the event loop by calling &lt;a href=&quot;qthread#exec&quot;&gt;exec&lt;/a&gt;() and runs a Qt event loop inside the thread.</source>
          <target state="translated">&lt;a href=&quot;qthread&quot;&gt;QThread의&lt;/a&gt; 객체는 프로그램 내에서의 컨트롤의 스레드를 관리합니다. QThreads는 &lt;a href=&quot;qthread#run&quot;&gt;run&lt;/a&gt; () 에서 실행을 시작합니다 . 기본적으로 &lt;a href=&quot;qthread#run&quot;&gt;run&lt;/a&gt; ()은 &lt;a href=&quot;qthread#exec&quot;&gt;exec&lt;/a&gt; () 를 호출하여 이벤트 루프를 시작 하고 스레드 내에서 Qt 이벤트 루프를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="b3842a79ee2b92edaa51039c7bd8c4a319d8ce41" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qtime&quot;&gt;QTime&lt;/a&gt; object contains a clock time, which it can express as the numbers of hours, minutes, seconds, and milliseconds since midnight. It can read the current time from the system clock and measure a span of elapsed time. It provides functions for comparing times and for manipulating a time by adding a number of milliseconds.</source>
          <target state="translated">&lt;a href=&quot;qtime&quot;&gt;QTime의&lt;/a&gt; 객체는 자정 이후의 시간, 분, 초 및 밀리 초를 숫자로 표현할 수있는 시계의 시간이 포함되어 있습니다. 시스템 시계에서 현재 시간을 읽고 경과 시간 범위를 측정 할 수 있습니다. 수 밀리 초를 추가하여 시간을 비교하고 시간을 조작하는 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="6bc6a66d684b1a5b25f21347672c5cd57213f9b0" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qtime&quot;&gt;QTime&lt;/a&gt; object is typically created either by giving the number of hours, minutes, seconds, and milliseconds explicitly, or by using the static function &lt;a href=&quot;qtime#currentTime&quot;&gt;currentTime&lt;/a&gt;(), which creates a &lt;a href=&quot;qtime&quot;&gt;QTime&lt;/a&gt; object that represents the system's local time.</source>
          <target state="translated">&lt;a href=&quot;qtime&quot;&gt;QTime의&lt;/a&gt; 목적은 일반적으로, 명시 적으로 시간, 분, 초, 밀리 초 단위의 수를 제공함으로써 또는 정적 함수를 사용하여 하나 생성 &lt;a href=&quot;qtime#currentTime&quot;&gt;currentTime을&lt;/a&gt; 생성 () &lt;a href=&quot;qtime&quot;&gt;QTime의&lt;/a&gt; 시스템의 로컬 시간을 나타내는 개체.</target>
        </trans-unit>
        <trans-unit id="1cd438cdd96c59b1cc3311e72b4cbd296d41679e" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qtoolbutton&quot;&gt;QToolButton&lt;/a&gt; instance.</source>
          <target state="translated">&lt;a href=&quot;qtoolbutton&quot;&gt;QToolButton의&lt;/a&gt; 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="9cb11fe279199d295d36a39f725588445000acad" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qtransform&quot;&gt;QTransform&lt;/a&gt; object can be built using the &lt;a href=&quot;qtransform#setMatrix&quot;&gt;setMatrix&lt;/a&gt;(), &lt;a href=&quot;qtransform#scale&quot;&gt;scale&lt;/a&gt;(), &lt;a href=&quot;qtransform#rotate&quot;&gt;rotate&lt;/a&gt;(), &lt;a href=&quot;qtransform#translate&quot;&gt;translate&lt;/a&gt;() and &lt;a href=&quot;qtransform#shear&quot;&gt;shear&lt;/a&gt;() functions. Alternatively, it can be built by applying &lt;a href=&quot;qtransform#basic-matrix-operations&quot;&gt;basic matrix operations&lt;/a&gt;. The matrix can also be defined when constructed, and it can be reset to the identity matrix (the default) using the &lt;a href=&quot;qtransform#reset&quot;&gt;reset&lt;/a&gt;() function.</source>
          <target state="translated">&lt;a href=&quot;qtransform&quot;&gt;QTransform의&lt;/a&gt; 객체는 사용하여 구축 할 수 &lt;a href=&quot;qtransform#setMatrix&quot;&gt;setMatrix을&lt;/a&gt; (), &lt;a href=&quot;qtransform#scale&quot;&gt;스케일&lt;/a&gt; (), &lt;a href=&quot;qtransform#rotate&quot;&gt;회전&lt;/a&gt; (), &lt;a href=&quot;qtransform#translate&quot;&gt;번역&lt;/a&gt; () 및 &lt;a href=&quot;qtransform#shear&quot;&gt;전단&lt;/a&gt; () 함수를. 또는 &lt;a href=&quot;qtransform#basic-matrix-operations&quot;&gt;기본 행렬 연산&lt;/a&gt; 을 적용하여 만들 수 있습니다 . 매트릭스는 구성 될 때 정의 할 수도 있으며, &lt;a href=&quot;qtransform#reset&quot;&gt;reset&lt;/a&gt; () 함수를 사용하여 단위 행렬 (기본값)로 재설정 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="55f3e0edd9340a005d02da86d1820bb1a11ff9c8" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qtransform&quot;&gt;QTransform&lt;/a&gt; object contains a 3 x 3 matrix. The &lt;code&gt;m31&lt;/code&gt; (&lt;code&gt;dx&lt;/code&gt;) and &lt;code&gt;m32&lt;/code&gt; (&lt;code&gt;dy&lt;/code&gt;) elements specify horizontal and vertical translation. The &lt;code&gt;m11&lt;/code&gt; and &lt;code&gt;m22&lt;/code&gt; elements specify horizontal and vertical scaling. The &lt;code&gt;m21&lt;/code&gt; and &lt;code&gt;m12&lt;/code&gt; elements specify horizontal and vertical</source>
          <target state="translated">&lt;a href=&quot;qtransform&quot;&gt;QTransform의&lt;/a&gt; 목적은 3 &amp;times; 3 행렬을 포함한다. &lt;code&gt;m31&lt;/code&gt; ( &lt;code&gt;dx&lt;/code&gt; ) 및 &lt;code&gt;m32&lt;/code&gt; ( &lt;code&gt;dy&lt;/code&gt; ) 요소는 수평 및 수직 변환을 지정. &lt;code&gt;m11&lt;/code&gt; 및 &lt;code&gt;m22&lt;/code&gt; 요소는 수평 및 수직 스케일을 지정. &lt;code&gt;m21&lt;/code&gt; 및 &lt;code&gt;m12&lt;/code&gt; 요소는 수평 및 수직 지정할</target>
        </trans-unit>
        <trans-unit id="92c8522cd77dc0b643894db25338dab319c7bce1" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qtreeview&quot;&gt;QTreeView&lt;/a&gt; implements a tree representation of items from a model. This class is used to provide standard hierarchical lists that were previously provided by the &lt;code&gt;QListView&lt;/code&gt; class, but using the more flexible approach provided by Qt's model/view architecture.</source>
          <target state="translated">&lt;a href=&quot;qtreeview&quot;&gt;QTreeView은&lt;/a&gt; 모델에서 항목의 트리 표현을 구현합니다. 이 클래스는 이전에 &lt;code&gt;QListView&lt;/code&gt; 클래스에서 제공했지만 Qt의 모델 / 뷰 아키텍처에서 제공하는보다 유연한 접근 방식을 사용하는 표준 계층 목록을 제공하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="3238aea85fb128f26a859e01cfd164c89492e357" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qtremoteobjects-replica#replica&quot;&gt;Replica&lt;/a&gt; is a light-weight proxy for the &lt;a href=&quot;qtremoteobjects-source#source&quot;&gt;Source&lt;/a&gt; object, but a Replica supports the same connections and behavior of QObjects, which makes it usable in the same way as any other &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; that Qt provides. Behind the scenes, QtRO handles everything that's necessary for the Replica to look like its Source.</source>
          <target state="translated">&lt;a href=&quot;qtremoteobjects-replica#replica&quot;&gt;복제본&lt;/a&gt; 위한 경량 프록시 &lt;a href=&quot;qtremoteobjects-source#source&quot;&gt;소스&lt;/a&gt; 객체하지만 복제는 다른 것과 같은 방식으로 사용할 수있는 접속과 같은 QObjects의 동작을 지원 &lt;a href=&quot;qobject&quot;&gt;QObject를&lt;/a&gt; Qt를 제공하는 것이다. 뒤에서 QtRO는 Replica가 소스처럼 보이기 위해 필요한 모든 것을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="1abd5b29a8e30044dcc5467f8733822760bee3f5" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qundocommand&quot;&gt;QUndoCommand&lt;/a&gt; has an associated &lt;a href=&quot;qundocommand#text&quot;&gt;text&lt;/a&gt;(). This is a short string describing what the command does. It is used to update the text properties of the stack's undo and redo actions; see &lt;a href=&quot;qundostack#createUndoAction&quot;&gt;QUndoStack::createUndoAction&lt;/a&gt;() and &lt;a href=&quot;qundostack#createRedoAction&quot;&gt;QUndoStack::createRedoAction&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qundocommand&quot;&gt;QUndoCommand가&lt;/a&gt; 연관된이 &lt;a href=&quot;qundocommand#text&quot;&gt;텍스트를&lt;/a&gt; (). 명령이 수행하는 작업을 설명하는 짧은 문자열입니다. 스택 실행 취소 및 재실행 작업의 텍스트 속성을 업데이트하는 데 사용됩니다. &lt;a href=&quot;qundostack#createUndoAction&quot;&gt;QUndoStack :: createUndoAction&lt;/a&gt; () 및 &lt;a href=&quot;qundostack#createRedoAction&quot;&gt;QUndoStack :: createRedoAction&lt;/a&gt; ()을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9011f19ddbb2da47c4e83d75f16cab77553161d4" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qundocommand&quot;&gt;QUndoCommand&lt;/a&gt; represents a single editing action on a document; for example, inserting or deleting a block of text in a text editor. &lt;a href=&quot;qundocommand&quot;&gt;QUndoCommand&lt;/a&gt; can apply a change to the document with &lt;a href=&quot;qundocommand#redo&quot;&gt;redo&lt;/a&gt;() and undo the change with &lt;a href=&quot;qundocommand#undo&quot;&gt;undo&lt;/a&gt;(). The implementations for these functions must be provided in a derived class.</source>
          <target state="translated">&lt;a href=&quot;qundocommand&quot;&gt;QUndoCommand은&lt;/a&gt; 문서에 하나의 편집 작업을 나타냅니다; 예를 들어, 텍스트 편집기에서 텍스트 블록을 삽입하거나 삭제합니다. &lt;a href=&quot;qundocommand&quot;&gt;QUndoCommand&lt;/a&gt; 는 &lt;a href=&quot;qundocommand#redo&quot;&gt;redo&lt;/a&gt; ()로 문서에 변경 사항을 적용하고 &lt;a href=&quot;qundocommand#undo&quot;&gt;undo&lt;/a&gt; ()로 변경 사항을 취소 할 수 있습니다 . 이러한 함수의 구현은 파생 클래스에서 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="44cc484f511c2c9e5ff7b0df34a1adbc48de27df" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qundogroup&quot;&gt;QUndoGroup&lt;/a&gt; is also useful in conjunction with &lt;a href=&quot;qundoview&quot;&gt;QUndoView&lt;/a&gt;. If a &lt;a href=&quot;qundoview&quot;&gt;QUndoView&lt;/a&gt; is set to watch a group using &lt;a href=&quot;qundoview#setGroup&quot;&gt;QUndoView::setGroup&lt;/a&gt;(), it will update itself to display the active stack.</source>
          <target state="translated">&lt;a href=&quot;qundogroup&quot;&gt;QUndoGroup은&lt;/a&gt; 또한 함께 유용하다 &lt;a href=&quot;qundoview&quot;&gt;QUndoView&lt;/a&gt; . 경우 &lt;a href=&quot;qundoview&quot;&gt;QUndoView을&lt;/a&gt; 사용하여 그룹을보기 위해 설정 &lt;a href=&quot;qundoview#setGroup&quot;&gt;QUndoView :: setGroup를&lt;/a&gt; ()는 활성 스택을 표시하기 위해 자동으로 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="e875425a43b04cc9d6b7876976a9cdc1a8b4d13e" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; containing a null pointer (&lt;a href=&quot;qmetatype#Type-enum&quot;&gt;QMetaType::Nullptr&lt;/a&gt;).</source>
          <target state="translated">&lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; 널 포인터 (포함 &lt;a href=&quot;qmetatype#Type-enum&quot;&gt;QMetaType :: Nullptr을&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="3ebfda5a9111d2694a1b3f3b4392e022ac7a8946" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; containing a pointer to a type derived from &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; will also convert and return true for this function if a &lt;a href=&quot;qobject#qobject_cast&quot;&gt;qobject_cast&lt;/a&gt; to the type described by</source>
          <target state="translated">&lt;a href=&quot;qvariant&quot;&gt;QVariant은&lt;/a&gt; 로부터 도출 된 타입의 포인터 함유 &lt;a href=&quot;qobject&quot;&gt;있는 QObject를&lt;/a&gt; 경우도 변환이 함수에 true를 반환한다 &lt;a href=&quot;qobject#qobject_cast&quot;&gt;qobject_cast&lt;/a&gt; 형태에 의해 기재</target>
        </trans-unit>
        <trans-unit id="9de8c189ee6e4b0bb5de2aac660b8d944db4103f" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; containing a pointer to a type derived from &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; will also return true for this function if a &lt;a href=&quot;qobject#qobject_cast&quot;&gt;qobject_cast&lt;/a&gt; to the template type &lt;code&gt;T&lt;/code&gt; would succeed. Note that this only works for &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; subclasses which use the &lt;a href=&quot;qobject#Q_OBJECT&quot;&gt;Q_OBJECT&lt;/a&gt; macro.</source>
          <target state="translated">&lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; 에서 파생 된 유형에 대한 포인터를 포함 &lt;a href=&quot;qobject&quot;&gt;QObject를이&lt;/a&gt; 경우이 함수에 대해 true를 반환합니다 &lt;a href=&quot;qobject#qobject_cast&quot;&gt;qobject_cast&lt;/a&gt; 템플릿 유형 &lt;code&gt;T&lt;/code&gt; 는 성공할 것입니다. 이것은 &lt;a href=&quot;qobject#Q_OBJECT&quot;&gt;Q_OBJECT&lt;/a&gt; 매크로 를 사용하는 &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 서브 클래스 에서만 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="e951e7f9dbc2d83362bfbfae4560b84516671b10" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; containing a pointer to a type derived from &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; will also return true for this function if a &lt;a href=&quot;qobject#qobject_cast&quot;&gt;qobject_cast&lt;/a&gt; to the type described by</source>
          <target state="translated">&lt;a href=&quot;qvariant&quot;&gt;QVariant은&lt;/a&gt; 로부터 도출 된 타입의 포인터 함유 &lt;a href=&quot;qobject&quot;&gt;있는 QObject를&lt;/a&gt; 경우이 함수에 true를 반환한다 &lt;a href=&quot;qobject#qobject_cast&quot;&gt;qobject_cast&lt;/a&gt; 형태에 의해 기재</target>
        </trans-unit>
        <trans-unit id="2b40ec11d4513b06064df6234ba2446931b977f7" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; containing a pointer to the &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; 받는 포인터 들어 &lt;a href=&quot;qobject&quot;&gt;있는 QObject를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="170019f1637d46474755638f7443c62b497dd150" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; containing a sequential container will also return true for this function if the</source>
          <target state="translated">&lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; 순차적 컨테이너를 포함 또한 경우이 함수에 true를 돌려줍니다</target>
        </trans-unit>
        <trans-unit id="550799b9c40a3740f0e1e880ec146b7d720fd090" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; containing the date value (&lt;a href=&quot;qjsvalue#toDateTime&quot;&gt;toDateTime&lt;/a&gt;()).</source>
          <target state="translated">날짜 값을 포함 하는 &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; ( &lt;a href=&quot;qjsvalue#toDateTime&quot;&gt;toDateTime&lt;/a&gt; ()).</target>
        </trans-unit>
        <trans-unit id="4a5337d8806bba5b1f4de3cab80b8a523bafa5f9" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; containing the regular expression value.</source>
          <target state="translated">정규식 값을 포함 하는 &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9923b0e5bb2e221393075db0b910e7d2d7b757c9" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; containing the value of the boolean.</source>
          <target state="translated">부울 값을 포함 하는 &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8c0bb00d97d940cbc36a240d8e3eaa8119c8076c" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; containing the value of the number.</source>
          <target state="translated">숫자 값을 포함 하는 &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6059293c49670d8977abec1000506dc5ddb28960" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; containing the value of the string.</source>
          <target state="translated">문자열 값을 포함 하는 &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9b632ab2ce7b912c18487142617c4488c6dd1bc8" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; is used because &lt;a href=&quot;qmimedata&quot;&gt;QMimeData&lt;/a&gt; belongs to the Qt Core module, whereas &lt;a href=&quot;qcolor&quot;&gt;QColor&lt;/a&gt; belongs to Qt GUI. To convert the &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; to a &lt;a href=&quot;qcolor&quot;&gt;QColor&lt;/a&gt;, simply use &lt;a href=&quot;qvariant#qvariant_cast&quot;&gt;qvariant_cast&lt;/a&gt;(). For example:</source>
          <target state="translated">&lt;a href=&quot;qvariant&quot;&gt;QVariant이&lt;/a&gt; 때문에 사용 &lt;a href=&quot;qmimedata&quot;&gt;QMimeData는&lt;/a&gt; 반면 Qt의 코어 모듈에 속하는 &lt;a href=&quot;qcolor&quot;&gt;QColor는&lt;/a&gt; Qt는 GUI에 속한다. &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; 를 &lt;a href=&quot;qcolor&quot;&gt;QColor&lt;/a&gt; 로 변환하려면 간단히 &lt;a href=&quot;qvariant#qvariant_cast&quot;&gt;qvariant_cast&lt;/a&gt; () 를 사용 하십시오 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="db07e2e1ccf64cc63f5cf860986f9f442d3b8020" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; is used because &lt;a href=&quot;qmimedata&quot;&gt;QMimeData&lt;/a&gt; belongs to the Qt Core module, whereas &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt; belongs to Qt GUI. The conversion from &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt; to &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; is implicit. For example:</source>
          <target state="translated">&lt;a href=&quot;qvariant&quot;&gt;QVariant이&lt;/a&gt; 때문에 사용 &lt;a href=&quot;qmimedata&quot;&gt;QMimeData는&lt;/a&gt; 반면 Qt의 코어 모듈에 속하는 &lt;a href=&quot;qimage&quot;&gt;QImage는&lt;/a&gt; Qt는 GUI에 속한다. &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt; 에서 &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; 로의 변환 은 암시 적입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="25783dcfe2b1fde71fd30288caf1a8aa18d67a86" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; is used because &lt;a href=&quot;qmimedata&quot;&gt;QMimeData&lt;/a&gt; belongs to the Qt Core module, whereas &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt; belongs to Qt GUI. To convert the &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; to a &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt;, simply use &lt;a href=&quot;qvariant#qvariant_cast&quot;&gt;qvariant_cast&lt;/a&gt;(). For example:</source>
          <target state="translated">&lt;a href=&quot;qvariant&quot;&gt;QVariant이&lt;/a&gt; 때문에 사용 &lt;a href=&quot;qmimedata&quot;&gt;QMimeData는&lt;/a&gt; 반면 Qt의 코어 모듈에 속하는 &lt;a href=&quot;qimage&quot;&gt;QImage는&lt;/a&gt; Qt는 GUI에 속한다. &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; 를 &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt; 로 변환하려면 간단히 &lt;a href=&quot;qvariant#qvariant_cast&quot;&gt;qvariant_cast&lt;/a&gt; () 를 사용 하십시오 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="89ee1cc409d7b731c23de4a41da95cd5af9da5c7" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; object holds a single value of a single &lt;a href=&quot;qvariant#type&quot;&gt;type&lt;/a&gt;() at a time. (Some &lt;a href=&quot;qvariant#type&quot;&gt;type&lt;/a&gt;()s are multi-valued, for example a string list.) You can find out what type, T, the variant holds, convert it to a different type using &lt;a href=&quot;qvariant#convert&quot;&gt;convert&lt;/a&gt;(), get its value using one of the toT() functions (e.g., &lt;a href=&quot;qvariant#toSize&quot;&gt;toSize&lt;/a&gt;()) and check whether the type can be converted to a particular type using &lt;a href=&quot;qvariant#canConvert-1&quot;&gt;canConvert&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qvariant&quot;&gt;QVariant의&lt;/a&gt; 목적은 하나의 단일 값 보유 &lt;a href=&quot;qvariant#type&quot;&gt;형&lt;/a&gt; 한번에을 (). (일부 &lt;a href=&quot;qvariant#type&quot;&gt;유형&lt;/a&gt; ()은 문자열 목록과 같이 여러 값을 갖습니다.) 변형이 보유한 유형 T를 찾고 &lt;a href=&quot;qvariant#convert&quot;&gt;변환&lt;/a&gt; ()을 사용하여 다른 유형으로 변환 하거나 toT 중 하나를 사용하여 값을 가져올 수 있습니다. () 함수 (예 : &lt;a href=&quot;qvariant#toSize&quot;&gt;toSize&lt;/a&gt; ())를 사용하고 &lt;a href=&quot;qvariant#canConvert-1&quot;&gt;canConvert&lt;/a&gt; ()를 사용하여 유형을 특정 유형으로 변환 할 수 있는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="72b456a0c9544fe1c851b99fb902baced468b135" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; with a structure dependent on the type of extension.</source>
          <target state="translated">확장 유형에 따라 구조가 있는 &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3b5100d56ee2059d4c1e51b859156afbdafaf879" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qvariant#QVariantList-typedef&quot;&gt;QVariantList&lt;/a&gt; can be bound to an &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt; $variable. All the &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt;s in the list must be of the same atomic type, and the $variable the variant list is bound to must be of that same atomic type. If the QVariants in the list are not all of the same atomic type, the &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt; behavior is undefined.</source>
          <target state="translated">&lt;a href=&quot;qvariant#QVariantList-typedef&quot;&gt;QVariantList은&lt;/a&gt; 에 바인딩 할 수 &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery를&lt;/a&gt; $ 변수. 목록의 모든 &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; 는 동일한 원자 유형이어야하며 변형 목록이 바인딩 된 $ 변수는 동일한 원자 유형이어야합니다. 목록의 QVariants가 모두 동일한 원자 유형이 아닌 경우 &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt; 동작은 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3b3e5711d653f48626f14b4105add2f90847f263" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qvariant#QVariantList-typedef&quot;&gt;QVariantList&lt;/a&gt; can be bound to an XQuery $variable. All the &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt;s in the list must be of the same atomic type, and the $variable the variant list is bound to must be of that same atomic type. If the QVariants in the list are not all of the same atomic type, the XQuery behavior is undefined.</source>
          <target state="translated">&lt;a href=&quot;qvariant#QVariantList-typedef&quot;&gt;QVariantList은&lt;/a&gt; XQuery를 $ 변수에 바인딩 할 수 있습니다. 리스트의 모든 &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; 는 동일한 원자 유형이어야하고 변형 목록이 바인딩 된 $ variable은 동일한 원자 유형이어야합니다. 목록의 QVariants가 모두 동일한 원자 유형이 아닌 경우 XQuery 동작은 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8b185ce739528a8ae124eb36f663f899e59e723f" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qvboxlayout&quot;&gt;QVBoxLayout&lt;/a&gt; lays out widgets in a vertical column, from top to bottom.</source>
          <target state="translated">&lt;a href=&quot;qvboxlayout&quot;&gt;QVBoxLayout는&lt;/a&gt; 위에서 아래로, 수직 열에 위젯을 낳는다.</target>
        </trans-unit>
        <trans-unit id="126ee8b6fc37613a52b0af53733429dcce8494c4" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qvideoframe&quot;&gt;QVideoFrame&lt;/a&gt; encapsulates the pixel data of a video frame, and information about the frame.</source>
          <target state="translated">&lt;a href=&quot;qvideoframe&quot;&gt;QVideoFrame는&lt;/a&gt; 상기 프레임에 대한 픽셀 비디오 프레임의 데이터 및 정보를 캡슐화한다.</target>
        </trans-unit>
        <trans-unit id="0d93082e40cf478dd928e07ca3bd1146ea22aec2" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qwebenginepage#visible-prop&quot;&gt;visible&lt;/a&gt; page must remain in the &lt;code&gt;Active&lt;/code&gt; state.</source>
          <target state="translated">&lt;a href=&quot;qwebenginepage#visible-prop&quot;&gt;보이는&lt;/a&gt; 페이지가 남아 있어야 &lt;code&gt;Active&lt;/code&gt; 상태입니다.</target>
        </trans-unit>
        <trans-unit id="98e5633fef7f9f6851c0077a68898eeff7969e3c" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qwebengineurlrequestjob&quot;&gt;QWebEngineUrlRequestJob&lt;/a&gt; is given to &lt;a href=&quot;qwebengineurlschemehandler#requestStarted&quot;&gt;QWebEngineUrlSchemeHandler::requestStarted&lt;/a&gt;() and must be handled by the derived implementations of the class. The job can be handled by calling either &lt;a href=&quot;qwebengineurlrequestjob#reply&quot;&gt;reply&lt;/a&gt;(), &lt;a href=&quot;qwebengineurlrequestjob#redirect&quot;&gt;redirect&lt;/a&gt;(), or &lt;a href=&quot;qwebengineurlrequestjob#fail&quot;&gt;fail&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qwebengineurlrequestjob&quot;&gt;QWebEngineUrlRequestJob가&lt;/a&gt; 부여된다 &lt;a href=&quot;qwebengineurlschemehandler#requestStarted&quot;&gt;QWebEngineUrlSchemeHandler :: requestStarted&lt;/a&gt; ()과 클래스의 상속 구현에 의해 처리되어야한다. &lt;a href=&quot;qwebengineurlrequestjob#reply&quot;&gt;응답&lt;/a&gt; (), &lt;a href=&quot;qwebengineurlrequestjob#redirect&quot;&gt;리디렉션&lt;/a&gt; () 또는 &lt;a href=&quot;qwebengineurlrequestjob#fail&quot;&gt;실패&lt;/a&gt; () 를 호출하여 작업을 처리 할 수 ​​있습니다 .</target>
        </trans-unit>
        <trans-unit id="4f748e52a14295d3e7d73adb735bce9e18173bb7" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qwebengineurlschemehandler&quot;&gt;QWebEngineUrlSchemeHandler&lt;/a&gt; can be registered for a profile by &lt;a href=&quot;qwebengineprofile#installUrlSchemeHandler&quot;&gt;installUrlSchemeHandler&lt;/a&gt;() to add support for custom URL schemes. Requests for the scheme are then issued to &lt;a href=&quot;qwebengineurlschemehandler#requestStarted&quot;&gt;QWebEngineUrlSchemeHandler::requestStarted&lt;/a&gt;() as &lt;a href=&quot;qwebengineurlrequestjob&quot;&gt;QWebEngineUrlRequestJob&lt;/a&gt; objects.</source>
          <target state="translated">&lt;a href=&quot;qwebengineurlschemehandler&quot;&gt;QWebEngineUrlSchemeHandler는&lt;/a&gt; 하여 프로필을 등록 할 수 있습니다 &lt;a href=&quot;qwebengineprofile#installUrlSchemeHandler&quot;&gt;installUrlSchemeHandler&lt;/a&gt; 사용자 정의 URL 체계에 대한 지원을 추가 할 (). 그런 다음 스킴에 대한 요청이 &lt;a href=&quot;qwebengineurlrequestjob&quot;&gt;QWebEngineUrlRequestJob&lt;/a&gt; 오브젝트 로 QWebEngineUrlSchemeHandler &lt;a href=&quot;qwebengineurlschemehandler#requestStarted&quot;&gt;:: requestStarted&lt;/a&gt; ()에 발행 됩니다.</target>
        </trans-unit>
        <trans-unit id="2474d728b83d04fa2385364e0e3618d61b802549" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; can have at most one of each action.</source>
          <target state="translated">&lt;a href=&quot;qwidget&quot;&gt;는 QWidget은&lt;/a&gt; 각 작업의 대부분을 한 곳에서 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="829a0e839b2fe25903a026615766f8e1f6017f33" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; pointer to an instance of the custom widget, constructed with the parent supplied.</source>
          <target state="translated">제공된 부모로 구성된 사용자 정의 위젯의 인스턴스에 대한 &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; 포인터.</target>
        </trans-unit>
        <trans-unit id="8206b5d79978cc62137016510c0899301c0d4d34" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; respects the safe area margins of a window by incorporating the margins into its contents' margins by default. This means, that a &lt;a href=&quot;qlayout&quot;&gt;QLayout&lt;/a&gt; will use the content area of a widget for its layout, unless the Qt::WA_LayoutOnEntireRect attribute is set. This along with a contents margin of 0 can be used on the actual layout, to allow for example a background image to underlay the status bar and other system areas on an iOS device, while still allowing child widgets of that background to be inset based on the safe area.</source>
          <target state="translated">&lt;a href=&quot;qwidget&quot;&gt;는 QWidget은&lt;/a&gt; 기본적으로 그 내용을 '여백에 여백을 포함하여 윈도우의 안전 영역 여백을 존중합니다. 즉, Qt :: WA_LayoutOnEntireRect 속성이 설정되어 있지 않으면 &lt;a href=&quot;qlayout&quot;&gt;QLayout&lt;/a&gt; 은 레이아웃에 위젯의 컨텐츠 영역을 사용합니다. 이것은 실제 레이아웃에서 콘텐츠 여백 0과 함께 사용되어 예를 들어 배경 이미지가 iOS 장치의 상태 표시 줄 및 기타 시스템 영역 아래에 놓 이도록 허용하면서 해당 배경의 하위 위젯을 기반으로 여전히 삽입 할 수 있습니다 안전한 지역.</target>
        </trans-unit>
        <trans-unit id="964b43044c29ab894791e5dc004d14bc9b97b6f3" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; should only have one of each action and adding an action it already has will not cause the same action to be in the widget twice.</source>
          <target state="translated">&lt;a href=&quot;qwidget&quot;&gt;는 QWidget은&lt;/a&gt; 각 행동 중 하나가이를 이미 같은 작업을 두 번 위젯으로하지 않습니다 원인이있는 조치를 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="5ec30fd7f2212793bc9e4abef7e6c0f3ceeb66e9" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; should only have one of each action.</source>
          <target state="translated">&lt;a href=&quot;qwidget&quot;&gt;는 QWidget은&lt;/a&gt; 각 동작 중 하나를 가져야한다.</target>
        </trans-unit>
        <trans-unit id="3ac199e9f73c744264011450f907be51315abd24" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qwindow&quot;&gt;QWindow&lt;/a&gt; created with the &lt;a href=&quot;qsurface#SurfaceType-enum&quot;&gt;QSurface::OpenGLSurface&lt;/a&gt; can be used in combination with &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; and &lt;a href=&quot;qopenglpaintdevice&quot;&gt;QOpenGLPaintDevice&lt;/a&gt; to have OpenGL hardware accelerated 2D graphics, by sacrificing some of the visual quality.</source>
          <target state="translated">&lt;a href=&quot;qsurface#SurfaceType-enum&quot;&gt;QSurface :: &lt;/a&gt;&lt;a href=&quot;qwindow&quot;&gt;OpenGLSurface로&lt;/a&gt; 생성 된 QWindow 를 &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; 및 &lt;a href=&quot;qopenglpaintdevice&quot;&gt;QOpenGLPaintDevice&lt;/a&gt; 와 함께 사용 하면 일부 시각적 품질을 희생하여 OpenGL 하드웨어 가속 2D 그래픽을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4b5c54bb5f64755c9a442e436f41967396bb028" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qwindow&quot;&gt;QWindow&lt;/a&gt; created with the surface type &lt;a href=&quot;qsurface#SurfaceType-enum&quot;&gt;QSurface::RasterSurface&lt;/a&gt; can be used in combination with &lt;a href=&quot;qbackingstore&quot;&gt;QBackingStore&lt;/a&gt; and &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt;, Qt's highly optimized 2D vector graphics API. &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; supports drawing lines, polygons, vector paths, images and text. For more information, see &lt;a href=&quot;paintsystem&quot;&gt;Paint System&lt;/a&gt; and &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtgui-rasterwindow-example.html&quot;&gt;Raster Window Example&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qwindow&quot;&gt;QWindow은&lt;/a&gt; 표면 형식으로 작성 &lt;a href=&quot;qsurface#SurfaceType-enum&quot;&gt;QSurface :: RasterSurface이&lt;/a&gt; 와 함께 사용할 수 &lt;a href=&quot;qbackingstore&quot;&gt;QBackingStore&lt;/a&gt; 및 &lt;a href=&quot;qpainter&quot;&gt;QPainter를&lt;/a&gt; , Qt의 최적화 된 2D 벡터 그래픽 API. &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; 는 선, 다각형, 벡터 경로, 이미지 및 텍스트 그리기를 지원합니다. 자세한 내용은 &lt;a href=&quot;paintsystem&quot;&gt;페인트 시스템&lt;/a&gt; 및 &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtgui-rasterwindow-example.html&quot;&gt;래스터 창 예제를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="27cd0dc8c744a791fb39bacb6c8ea1d79de5ca20" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qwindow&quot;&gt;QWindow&lt;/a&gt; created with the surface type &lt;a href=&quot;qsurface#SurfaceType-enum&quot;&gt;QSurface::RasterSurface&lt;/a&gt; can be used in combination with &lt;a href=&quot;qbackingstore&quot;&gt;QBackingStore&lt;/a&gt; and &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt;, Qt's highly optimized 2D vector graphics API. &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; supports drawing lines, polygons, vector paths, images and text. For more information, see &lt;a href=&quot;paintsystem&quot;&gt;Paint System&lt;/a&gt; and &lt;a href=&quot;https://doc.qt.io/qt-6.0/qtgui-rasterwindow-example.html&quot;&gt;Raster Window Example&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qwindow&quot;&gt;QWindow은&lt;/a&gt; 표면 형식으로 작성 &lt;a href=&quot;qsurface#SurfaceType-enum&quot;&gt;QSurface :: RasterSurface이&lt;/a&gt; 와 함께 사용할 수 &lt;a href=&quot;qbackingstore&quot;&gt;QBackingStore&lt;/a&gt; 및 &lt;a href=&quot;qpainter&quot;&gt;QPainter를&lt;/a&gt; , Qt의 최적화 된 2D 벡터 그래픽 API. &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; 는 선, 다각형, 벡터 경로, 이미지 및 텍스트 그리기를 지원합니다. 자세한 내용은 &lt;a href=&quot;paintsystem&quot;&gt;페인트 시스템&lt;/a&gt; 및 &lt;a href=&quot;https://doc.qt.io/qt-6.0/qtgui-rasterwindow-example.html&quot;&gt;래스터 창 예제를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="745ac1a7d7742ffec52578bdde2360e661acd0db" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qwindow&quot;&gt;QWindow&lt;/a&gt; created with the surface type &lt;a href=&quot;qsurface#SurfaceType-enum&quot;&gt;QSurface::RasterSurface&lt;/a&gt; can be used in combination with &lt;a href=&quot;qbackingstore&quot;&gt;QBackingStore&lt;/a&gt; and &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt;, Qt's highly optimized 2D vector graphics API. &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; supports drawing lines, polygons, vector paths, images and text. For more information, see &lt;a href=&quot;paintsystem#&quot;&gt;Paint System&lt;/a&gt; and &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtgui-rasterwindow-example.html#&quot;&gt;Raster Window Example&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qwindow&quot;&gt;QWindow은&lt;/a&gt; 표면 형식으로 작성 &lt;a href=&quot;qsurface#SurfaceType-enum&quot;&gt;QSurface :: RasterSurface이&lt;/a&gt; 와 함께 사용할 수 &lt;a href=&quot;qbackingstore&quot;&gt;QBackingStore&lt;/a&gt; 및 &lt;a href=&quot;qpainter&quot;&gt;QPainter를&lt;/a&gt; , Qt의 최적화 된 2D 벡터 그래픽 API. &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; 는 선, 다각형, 벡터 경로, 이미지 및 텍스트 그리기를 지원합니다. 자세한 내용은 &lt;a href=&quot;paintsystem#&quot;&gt;페인트 시스템&lt;/a&gt; 및 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtgui-rasterwindow-example.html#&quot;&gt;래스터 창 예제를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5df3f42a0d3687ebb50a05e01cdedb1afdd0cd68" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qwizardpage#subTitle-prop&quot;&gt;subTitle&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qwizardpage#subTitle-prop&quot;&gt;자막&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9cae12dc8d73ba388f4f16abfddc1282cc00f3d0" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qwizardpage#title-prop&quot;&gt;title&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qwizardpage#title-prop&quot;&gt;제목&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="33e7f960c35917466e319a88de2b56f3863f5c81" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;qxmlname&quot;&gt;QXmlName&lt;/a&gt; is constructed from</source>
          <target state="translated">&lt;a href=&quot;qxmlname&quot;&gt;QXmlName가&lt;/a&gt; 로 구성되어</target>
        </trans-unit>
        <trans-unit id="8390f8bfbcd2f1be61b391d1f0f7de0260838e23" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;supported-platforms#winrt&quot;&gt;WinRT&lt;/a&gt; application may not do socket-based communication with another application running on the same host (as this would violate the sandboxing).</source>
          <target state="translated">&lt;a href=&quot;supported-platforms#winrt&quot;&gt;WinRT의&lt;/a&gt; 응용 프로그램 (이것은 샌드 박스를 위반하는 것 같은) 다른 응용 프로그램이 동일한 호스트에서 실행하는 소켓 기반 통신을 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec404d2e6bc3dd068e78488feb9ba26df61c54a7" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;widgets-changes-qt6#qcombobox&quot;&gt;QComboBox&lt;/a&gt; instance.</source>
          <target state="translated">&lt;a href=&quot;widgets-changes-qt6#qcombobox&quot;&gt;QComboBox의&lt;/a&gt; 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="738cea92b00eee55e2189bab8444d15a81e94c3f" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;widgets-changes-qt6#qcombobox&quot;&gt;QComboBox&lt;/a&gt; uses the style to draw the button and label of non-editable boxes with &lt;code&gt;CC_ComboBox&lt;/code&gt; and &lt;code&gt;CE_ComboBoxLabel&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;widgets-changes-qt6#qcombobox&quot;&gt;QComboBox는&lt;/a&gt; 비 - 편집 상자의 버튼 라벨립니다 스타일을 사용 &lt;code&gt;CC_ComboBox&lt;/code&gt; 및 &lt;code&gt;CE_ComboBoxLabel&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="da8c737d54a811497593809349b3073de073adbd" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;widgets-changes-qt6#qwidget&quot;&gt;QWidget&lt;/a&gt; can have at most one of each action.</source>
          <target state="translated">&lt;a href=&quot;widgets-changes-qt6#qwidget&quot;&gt;는 QWidget은&lt;/a&gt; 각 작업의 대부분을 한 곳에서 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="61f2f69cc85542a92f92fffd9513c908f597ce55" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;widgets-changes-qt6#qwidget&quot;&gt;QWidget&lt;/a&gt; pointer to an instance of the custom widget, constructed with the parent supplied.</source>
          <target state="translated">제공된 부모로 구성된 사용자 정의 위젯의 인스턴스에 대한 &lt;a href=&quot;widgets-changes-qt6#qwidget&quot;&gt;QWidget&lt;/a&gt; 포인터입니다.</target>
        </trans-unit>
        <trans-unit id="39b160e76a2cbf7a57b5d1f9b6ebb990fcd55018" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;widgets-changes-qt6#qwidget&quot;&gt;QWidget&lt;/a&gt; respects the safe area margins of a window by incorporating the margins into its contents' margins by default. This means, that a &lt;a href=&quot;qlayout&quot;&gt;QLayout&lt;/a&gt; will use the content area of a widget for its layout, unless the Qt::WA_LayoutOnEntireRect attribute is set. This along with a contents margin of 0 can be used on the actual layout, to allow for example a background image to underlay the status bar and other system areas on an iOS device, while still allowing child widgets of that background to be inset based on the safe area.</source>
          <target state="translated">&lt;a href=&quot;widgets-changes-qt6#qwidget&quot;&gt;는 QWidget은&lt;/a&gt; 기본적으로 그 내용을 '여백에 여백을 포함하여 윈도우의 안전 영역 여백을 존중합니다. 즉, Qt :: WA_LayoutOnEntireRect 속성이 설정되지 않은 경우 &lt;a href=&quot;qlayout&quot;&gt;QLayout&lt;/a&gt; 은 레이아웃에 위젯의 콘텐츠 영역을 사용합니다. 콘텐츠 여백 0과 함께 실제 레이아웃에서 사용할 수 있습니다. 예를 들어 배경 이미지가 iOS 장치의 상태 표시 줄 및 기타 시스템 영역 아래에 놓 이도록 허용하는 동시에 해당 배경의 하위 위젯이 다음을 기반으로 삽입되도록 허용합니다. 안전한 지역.</target>
        </trans-unit>
        <trans-unit id="b97a14b203e5e5b55ef413c6912a34e15556a035" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;widgets-changes-qt6#qwidget&quot;&gt;QWidget&lt;/a&gt; should only have one of each action and adding an action it already has will not cause the same action to be in the widget twice.</source>
          <target state="translated">&lt;a href=&quot;widgets-changes-qt6#qwidget&quot;&gt;는 QWidget은&lt;/a&gt; 각 행동 중 하나가이를 이미 같은 작업을 두 번 위젯으로하지 않습니다 원인이있는 조치를 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="110757179062258922e84098b122119a7a9e8cb2" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;widgets-changes-qt6#qwidget&quot;&gt;QWidget&lt;/a&gt; should only have one of each action.</source>
          <target state="translated">&lt;a href=&quot;widgets-changes-qt6#qwidget&quot;&gt;는 QWidget은&lt;/a&gt; 각 동작 중 하나를 가져야한다.</target>
        </trans-unit>
        <trans-unit id="b2b866a1aef922537575b7fa144890693739fec1" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;Cancel&lt;/b&gt; button defined with the &lt;a href=&quot;qmessagebox#ButtonRole-enum&quot;&gt;RejectRole&lt;/a&gt;.</source>
          <target state="translated">A는 &lt;b&gt;취소&lt;/b&gt; 정의 버튼 &lt;a href=&quot;qmessagebox#ButtonRole-enum&quot;&gt;RejectRole을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f7e881d3c2c45790aae7fcb537e837e0adb2bbd0" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;Close&lt;/b&gt; button defined with the &lt;a href=&quot;qmessagebox#ButtonRole-enum&quot;&gt;RejectRole&lt;/a&gt;.</source>
          <target state="translated">&lt;b&gt;닫기&lt;/b&gt; 정의 버튼 &lt;a href=&quot;qmessagebox#ButtonRole-enum&quot;&gt;RejectRole&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="90248d825c2215c0da2d4cf30b4e1bf81bee27fb" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;Commit&lt;/b&gt; button replaces the &lt;b&gt;Next&lt;/b&gt; button on a commit page. Clicking this button simply calls &lt;a href=&quot;qwizard#next&quot;&gt;QWizard::next&lt;/a&gt;() just like clicking &lt;b&gt;Next&lt;/b&gt; does.</source>
          <target state="translated">A는 &lt;b&gt;커밋&lt;/b&gt; 버튼을 대체하는 &lt;b&gt;다음의&lt;/b&gt; 버튼을 A가 페이지를 커밋에. 이 버튼을 클릭하면 &lt;b&gt;다음을&lt;/b&gt; 클릭하는 것처럼 &lt;a href=&quot;qwizard#next&quot;&gt;QWizard :: next&lt;/a&gt; () 를 호출합니다 .&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="09fb529c2989b795d8c27e02565218348b84b3e8" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;Discard&lt;/b&gt; or &lt;b&gt;Don't Save&lt;/b&gt; button, depending on the platform, defined with the &lt;a href=&quot;qmessagebox#ButtonRole-enum&quot;&gt;DestructiveRole&lt;/a&gt;.</source>
          <target state="translated">&lt;b&gt;폐기&lt;/b&gt; 또는 &lt;b&gt;할 일을하지 저장을&lt;/b&gt; 버튼, 플랫폼에 따라 정의 &lt;a href=&quot;qmessagebox#ButtonRole-enum&quot;&gt;DestructiveRole&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d9177b410e9fc17156f42973a5c6b8fca00a6544" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;Help&lt;/b&gt; button defined with the &lt;a href=&quot;qmessagebox#ButtonRole-enum&quot;&gt;HelpRole&lt;/a&gt;.</source>
          <target state="translated">&lt;b&gt;도움말&lt;/b&gt; 정의 버튼 &lt;a href=&quot;qmessagebox#ButtonRole-enum&quot;&gt;HelpRole&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7b03e4b6a36ae75c2f853d1555bf05681bed5134" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;No to All&lt;/b&gt; button defined with the &lt;a href=&quot;qmessagebox#ButtonRole-enum&quot;&gt;NoRole&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qmessagebox#ButtonRole-enum&quot;&gt;NoRole로&lt;/a&gt; 정의 된 &lt;b&gt;모두에&lt;/b&gt; 대해 &lt;b&gt;아니오&lt;/b&gt; 단추 .</target>
        </trans-unit>
        <trans-unit id="86e23d198c62cc796c78cce610baa65585a00ce8" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;No&lt;/b&gt; button defined with the &lt;a href=&quot;qmessagebox#ButtonRole-enum&quot;&gt;NoRole&lt;/a&gt;.</source>
          <target state="translated">&lt;b&gt;없음&lt;/b&gt; 정의 버튼 &lt;a href=&quot;qmessagebox#ButtonRole-enum&quot;&gt;NoRole&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2ae1a29d1376fa7e9fb4d3c342c1a1b96c1399a2" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;Reset&lt;/b&gt; button defined with the &lt;a href=&quot;qmessagebox#ButtonRole-enum&quot;&gt;ResetRole&lt;/a&gt;.</source>
          <target state="translated">&lt;b&gt;재설정&lt;/b&gt; 정의 버튼 &lt;a href=&quot;qmessagebox#ButtonRole-enum&quot;&gt;ResetRole&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="11a59ec0b188e43ec67481e31b7dc60b647d897c" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;Restore Defaults&lt;/b&gt; button defined with the &lt;a href=&quot;qmessagebox#ButtonRole-enum&quot;&gt;ResetRole&lt;/a&gt;.</source>
          <target state="translated">A는 &lt;b&gt;기본값 복원&lt;/b&gt; 정의 버튼 &lt;a href=&quot;qmessagebox#ButtonRole-enum&quot;&gt;ResetRole을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a719628b27f2951fb4aae5c60393dd4c9e347c21" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;Retry&lt;/b&gt; button defined with the &lt;a href=&quot;qmessagebox#ButtonRole-enum&quot;&gt;AcceptRole&lt;/a&gt;.</source>
          <target state="translated">&lt;b&gt;재시도&lt;/b&gt; 정의 버튼 &lt;a href=&quot;qmessagebox#ButtonRole-enum&quot;&gt;AcceptRole&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="26608f4e742cb8475e2900936c660fd46d2571fe" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;Save All&lt;/b&gt; button defined with the &lt;a href=&quot;qmessagebox#ButtonRole-enum&quot;&gt;AcceptRole&lt;/a&gt;.</source>
          <target state="translated">&lt;b&gt;저장 모든&lt;/b&gt; 정의 버튼 &lt;a href=&quot;qmessagebox#ButtonRole-enum&quot;&gt;AcceptRole&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3cd87d74dc4e75d47ce6d32e621aef5b15871af9" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;Save&lt;/b&gt; button defined with the &lt;a href=&quot;qmessagebox#ButtonRole-enum&quot;&gt;AcceptRole&lt;/a&gt;.</source>
          <target state="translated">&lt;b&gt;저장&lt;/b&gt; 정의 버튼 &lt;a href=&quot;qmessagebox#ButtonRole-enum&quot;&gt;AcceptRole&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="000d380f271b6a56c079fe53d60157c35b098393" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;Yes to All&lt;/b&gt; button defined with the &lt;a href=&quot;qmessagebox#ButtonRole-enum&quot;&gt;YesRole&lt;/a&gt;.</source>
          <target state="translated">&lt;b&gt;모두 예&lt;/b&gt; 정의 버튼 &lt;a href=&quot;qmessagebox#ButtonRole-enum&quot;&gt;YesRole&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="89bef340393f198a6f41acda53a4ab670053a93b" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;Yes&lt;/b&gt; button defined with the &lt;a href=&quot;qmessagebox#ButtonRole-enum&quot;&gt;YesRole&lt;/a&gt;.</source>
          <target state="translated">&lt;b&gt;예를&lt;/b&gt; 정의 버튼 &lt;a href=&quot;qmessagebox#ButtonRole-enum&quot;&gt;YesRole&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="919a9d06adaef23366d180df88b7fd4fad8449c5" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;modal&lt;/b&gt; dialog is a dialog that blocks input to other visible windows in the same application. Dialogs that are used to request a file name from the user or that are used to set application preferences are usually modal. Dialogs can be &lt;a href=&quot;qt#WindowModality-enum&quot;&gt;application modal&lt;/a&gt; (the default) or &lt;a href=&quot;qt#WindowModality-enum&quot;&gt;window modal&lt;/a&gt;.</source>
          <target state="translated">&lt;b&gt;모달&lt;/b&gt; 대화 상자는 대화입니다 동일한 응용 프로그램에 표시된 다른 윈도우에 블록이 입력하는. 사용자에게 파일 이름을 요청하는 데 사용되거나 응용 프로그램 환경 설정을 설정하는 데 사용되는 대화 상자는 일반적으로 모달입니다. 대화 상자는 &lt;a href=&quot;qt#WindowModality-enum&quot;&gt;응용 프로그램 모달&lt;/a&gt; (기본값) 또는 &lt;a href=&quot;qt#WindowModality-enum&quot;&gt;창 모달 일 수&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5eb153f25dbaabba051451793fe380e1fc6a23b" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;modeless&lt;/b&gt; dialog is a dialog that operates independently of other windows in the same application. Find and replace dialogs in word-processors are often modeless to allow the user to interact with both the application's main window and with the dialog.</source>
          <target state="translated">&lt;b&gt;모덜리스의&lt;/b&gt; 대화는 같은 응용 프로그램에서 독립적으로 다른 창 작동하는 대화이다. 워드 프로세서에서 대화 상자 찾기 및 바꾸기는 종종 사용자가 응용 프로그램의 기본 창과 대화 상자와 상호 작용할 수 있도록 모덜리스입니다.</target>
        </trans-unit>
        <trans-unit id="100c7f7399b4bd52f03d3ca247c88ba3a3e0493e" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;.dic&lt;/code&gt; file that is a dictionary containing words for the language</source>
          <target state="translated">&lt;code&gt;.dic&lt;/code&gt; 를 언어에 대한 단어를 포함하는 사전이 파일</target>
        </trans-unit>
        <trans-unit id="5b910e10bf6053affa66fab9f25fabed5157116b" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;0-to-n&lt;/code&gt; quantification like &lt;code&gt;{,n}&lt;/code&gt; needs to be ported to &lt;code&gt;{0,n}&lt;/code&gt; to preserve semantics. Otherwise, a pattern such as &lt;code&gt;\d{,3}&lt;/code&gt; would actually match a digit followed by the exact string &lt;code&gt;&quot;{,3}&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;0-to-n&lt;/code&gt; 정량 등 &lt;code&gt;{,n}&lt;/code&gt; 에 포팅되어야 &lt;code&gt;{0,n}&lt;/code&gt; 시맨틱을 보존. 그렇지 않으면 &lt;code&gt;\d{,3}&lt;/code&gt; 와 같은 패턴 은 실제로 숫자 뒤에 정확한 문자열 &lt;code&gt;&quot;{,3}&quot;&lt;/code&gt; 이 오는 숫자와 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="9c40740d88382652b35301b29fca086b56435c77" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;CMake&lt;/code&gt; project is defined by files written in the CMake language. The main file is called &lt;code&gt;CMakeLists.txt&lt;/code&gt;, and is usually placed in the same directory as the actual program sources.</source>
          <target state="translated">&lt;code&gt;CMake&lt;/code&gt; 의 프로젝트는 CMake 언어로 작성된 파일에 의해 정의됩니다. 기본 파일은 &lt;code&gt;CMakeLists.txt&lt;/code&gt; 라고 하며 일반적으로 실제 프로그램 소스와 동일한 디렉토리에 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e3386648ae214b0a94fa645c50250352b2d137e" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;CreateProcessArgumentModifier&lt;/code&gt; function takes one parameter: a pointer to a &lt;code&gt;CreateProcessArguments&lt;/code&gt; struct. The members of this struct will be passed to &lt;code&gt;CreateProcess&lt;/code&gt; after the &lt;code&gt;CreateProcessArgumentModifier&lt;/code&gt; function is called.</source>
          <target state="translated">&lt;code&gt;CreateProcessArgumentModifier&lt;/code&gt; 의 A와 포인터 : 함수는 하나 개의 매개 변수 소요 &lt;code&gt;CreateProcessArguments&lt;/code&gt; 구조체. 이 구조체의 멤버 는 &lt;code&gt;CreateProcessArgumentModifier&lt;/code&gt; 함수가 호출 된 후 &lt;code&gt;CreateProcess&lt;/code&gt; 에 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="b44f0df69a00d7248e9924b1d0bfd79849e35db6" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;MEMBER&lt;/code&gt; variable association is required if no &lt;code&gt;READ&lt;/code&gt; accessor function is specified. This makes the given member variable readable and writable without the need of creating &lt;code&gt;READ&lt;/code&gt; and &lt;code&gt;WRITE&lt;/code&gt; accessor functions. It's still possible to use &lt;code&gt;READ&lt;/code&gt; or &lt;code&gt;WRITE&lt;/code&gt; accessor functions in addition to &lt;code&gt;MEMBER&lt;/code&gt; variable association (but not both), if you need to control the variable access.</source>
          <target state="translated">&lt;code&gt;MEMBER&lt;/code&gt; 어떠한 경우 변수 협회 필요한 &lt;code&gt;READ&lt;/code&gt; 의 접근 기능을 지정하지 않는다. 따라서 &lt;code&gt;READ&lt;/code&gt; 및 &lt;code&gt;WRITE&lt;/code&gt; 접근 자 함수 를 만들 필요없이 지정된 멤버 변수를 읽고 쓸 수 있습니다. 변수 액세스를 제어해야하는 경우 &lt;code&gt;MEMBER&lt;/code&gt; 변수 연결 (둘다는 아님) 외에 &lt;code&gt;READ&lt;/code&gt; 또는 &lt;code&gt;WRITE&lt;/code&gt; 접근 자 함수 를 계속 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="830dd5040f27fbf255adaa7a733f96dfb8d77cae" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Mac0&lt;/code&gt; map as specified by &lt;a href=&quot;https://tools.ietf.org/html/rfc8152&quot;&gt;RFC 8152&lt;/a&gt; (CBOR Object Signing and Encryption).</source>
          <target state="translated">&lt;code&gt;Mac0&lt;/code&gt; 가 지정한대로 매핑 &lt;a href=&quot;https://tools.ietf.org/html/rfc8152&quot;&gt;RFC 8152&lt;/a&gt; (CBOR 개체 서명 및 암호화).</target>
        </trans-unit>
        <trans-unit id="e70b630c6be4c039a81474782973914c175778ae" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Mac&lt;/code&gt; map as specified by &lt;a href=&quot;https://tools.ietf.org/html/rfc8152&quot;&gt;RFC 8152&lt;/a&gt; (CBOR Object Signing and Encryption).</source>
          <target state="translated">&lt;code&gt;Mac&lt;/code&gt; 에 의해 지정된지도 &lt;a href=&quot;https://tools.ietf.org/html/rfc8152&quot;&gt;RFC 8152&lt;/a&gt; (CBOR 개체 서명 및 암호화).</target>
        </trans-unit>
        <trans-unit id="de2d38b6c2e8eecb7d12c9e4e7315bcb906ea889" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Message&lt;/code&gt; object, which will be the</source>
          <target state="translated">&lt;code&gt;Message&lt;/code&gt; 될 것입니다 개체,</target>
        </trans-unit>
        <trans-unit id="eae0730ba549e750ed809f7cf3b5737f261309c9" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;NOTIFY&lt;/code&gt; signal is optional. If defined, it should specify one existing signal in that class that is emitted whenever the value of the property changes. &lt;code&gt;NOTIFY&lt;/code&gt; signals for &lt;code&gt;MEMBER&lt;/code&gt; variables must take zero or one parameter, which must be of the same type as the property. The parameter will take the new value of the property. The &lt;code&gt;NOTIFY&lt;/code&gt; signal should only be emitted when the property has really been changed, to avoid bindings being unnecessarily re-evaluated in QML, for example. Qt emits automatically that signal when needed for MEMBER properties that do not have an explicit setter.</source>
          <target state="translated">A는 &lt;code&gt;NOTIFY&lt;/code&gt; 신호는 선택 사항입니다. 정의 된 경우 속성 값이 변경 될 때마다 방출되는 해당 클래스의 기존 신호 하나를 지정해야합니다. &lt;code&gt;MEMBER&lt;/code&gt; 변수에 대한 &lt;code&gt;NOTIFY&lt;/code&gt; 신호는 0 또는 하나의 매개 변수를 가져야하며, 특성과 유형이 같아야합니다. 매개 변수는 특성의 새 값을 사용합니다. 는 &lt;code&gt;NOTIFY&lt;/code&gt; 신호는 단지, 예를 들어, 불필요하게 QML에서 재평가되는 바인딩을 피하기 위하여, 속성은 실제로 변경되었을 때 방출한다. Qt는 명시 적 세터가없는 MEMBER 속성에 필요할 때 해당 신호를 자동으로 방출합니다.</target>
        </trans-unit>
        <trans-unit id="a2e736a5fa7d1fb3d36b0daf949b24867acebc06" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;READ&lt;/code&gt; accessor function is required if no &lt;code&gt;MEMBER&lt;/code&gt; variable was specified. It is for reading the property value. Ideally, a const function is used for this purpose, and it must return either the property's type or a const reference to that type. e.g., &lt;a href=&quot;qwidget#focus-prop&quot;&gt;QWidget::focus&lt;/a&gt; is a read-only property with &lt;code&gt;READ&lt;/code&gt; function, &lt;a href=&quot;qwidget#focus-prop&quot;&gt;QWidget::hasFocus&lt;/a&gt;().</source>
          <target state="translated">&lt;code&gt;READ&lt;/code&gt; 어떤 경우 접근 기능이 요구되는 &lt;code&gt;MEMBER&lt;/code&gt; 변수가 지정되지 않았습니다. 속성 값을 읽기위한 것입니다. 이상적으로는 const 함수가이 목적으로 사용되며 속성 유형이나 해당 유형에 대한 const 참조를 반환해야합니다. 예를 들어, &lt;a href=&quot;qwidget#focus-prop&quot;&gt;QWidget :: focus&lt;/a&gt; 는 &lt;code&gt;READ&lt;/code&gt; 함수 &lt;a href=&quot;qwidget#focus-prop&quot;&gt;QWidget :: hasFocus&lt;/a&gt; () 가있는 읽기 전용 속성입니다 .</target>
        </trans-unit>
        <trans-unit id="469541031836ec916cac9a1bf1b20fb1d61cc9fc" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;RESET&lt;/code&gt; function is optional. It is for setting the property back to its context specific default value. e.g., &lt;a href=&quot;qwidget#cursor-prop&quot;&gt;QWidget::cursor&lt;/a&gt; has the typical &lt;code&gt;READ&lt;/code&gt; and &lt;code&gt;WRITE&lt;/code&gt; functions, &lt;a href=&quot;qwidget#cursor-prop&quot;&gt;QWidget::cursor&lt;/a&gt;() and &lt;a href=&quot;qwidget#cursor-prop&quot;&gt;QWidget::setCursor&lt;/a&gt;(), and it also has a &lt;code&gt;RESET&lt;/code&gt; function, &lt;a href=&quot;qwidget#cursor-prop&quot;&gt;QWidget::unsetCursor&lt;/a&gt;(), since no call to &lt;a href=&quot;qwidget#cursor-prop&quot;&gt;QWidget::setCursor&lt;/a&gt;() can mean</source>
          <target state="translated">&lt;code&gt;RESET&lt;/code&gt; 기능은 선택 사항입니다. 속성을 컨텍스트 별 기본값으로 다시 설정하기위한 것입니다. 예를 들어, &lt;a href=&quot;qwidget#cursor-prop&quot;&gt;는 QWidget는 :: 커서는&lt;/a&gt; 전형적인가 &lt;code&gt;READ&lt;/code&gt; 및 &lt;code&gt;WRITE&lt;/code&gt; 기능 &lt;a href=&quot;qwidget#cursor-prop&quot;&gt;는 QWidget :: 커서&lt;/a&gt; ()과 &lt;a href=&quot;qwidget#cursor-prop&quot;&gt;는 QWidget :: setCursor ()에을&lt;/a&gt; ()하고, 또한이 &lt;code&gt;RESET&lt;/code&gt; 기능, &lt;a href=&quot;qwidget#cursor-prop&quot;&gt;는 QWidget :: unsetCursor&lt;/a&gt; 없이 호출 이후 () &lt;a href=&quot;qwidget#cursor-prop&quot;&gt;는 QWidget을 :: setCursor&lt;/a&gt; ()는 다음을 의미 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="77de2e94bea91e675dcd5ef7deabd1595c40bd43" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;REVISION&lt;/code&gt; number is optional. If included, it defines the property and its notifier signal to be used in a particular revision of the API (usually for exposure to QML). If not included, it defaults to 0.</source>
          <target state="translated">&lt;code&gt;REVISION&lt;/code&gt; 번호는 선택 사항입니다. 포함 된 경우 API의 특정 개정 (보통 QML에 노출)에 사용되는 특성 및 해당 알리미 신호를 정의합니다. 포함되지 않은 경우 기본값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="544221cb802cb2347404c69702cc94353d73a18c" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;REVISION&lt;/code&gt; number or &lt;code&gt;REVISION()&lt;/code&gt; macro is optional. If included, it defines the property and its notifier signal to be used in a particular revision of the API (usually for exposure to QML). If not included, it defaults to 0.</source>
          <target state="translated">&lt;code&gt;REVISION&lt;/code&gt; 번호 또는 &lt;code&gt;REVISION()&lt;/code&gt; 매크로는 선택 사항입니다. 포함 된 경우 API의 특정 개정판 (일반적으로 QML 노출 용)에서 사용할 속성 및 알림 신호를 정의합니다. 포함되지 않은 경우 기본값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="70a58f5ac6c89faf3e26d28054eebc0ee8267e8f" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Sign1&lt;/code&gt; map as specified by &lt;a href=&quot;https://tools.ietf.org/html/rfc8152&quot;&gt;RFC 8152&lt;/a&gt; (CBOR Object Signing and Encryption).</source>
          <target state="translated">&lt;code&gt;Sign1&lt;/code&gt; 가 지정한대로 매핑 &lt;a href=&quot;https://tools.ietf.org/html/rfc8152&quot;&gt;RFC 8152&lt;/a&gt; (CBOR 개체 서명 및 암호화).</target>
        </trans-unit>
        <trans-unit id="83d9a1df88edaab8cdf6d0ce58f2a7053a456dd1" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Sign&lt;/code&gt; map as specified by &lt;a href=&quot;https://tools.ietf.org/html/rfc8152&quot;&gt;RFC 8152&lt;/a&gt; (CBOR Object Signing and Encryption).</source>
          <target state="translated">&lt;code&gt;Sign&lt;/code&gt; 에 의해 지정된지도 &lt;a href=&quot;https://tools.ietf.org/html/rfc8152&quot;&gt;RFC 8152&lt;/a&gt; (CBOR 개체 서명 및 암호화).</target>
        </trans-unit>
        <trans-unit id="306105a32c96a9365806a61df4bc01571546be2e" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;WRITE&lt;/code&gt; accessor function is optional. It is for setting the property value. It must return void and must take exactly one argument, either of the property's type or a pointer or reference to that type. e.g., &lt;a href=&quot;qwidget#enabled-prop&quot;&gt;QWidget::enabled&lt;/a&gt; has the &lt;code&gt;WRITE&lt;/code&gt; function &lt;a href=&quot;qwidget#enabled-prop&quot;&gt;QWidget::setEnabled&lt;/a&gt;(). Read-only properties do not need &lt;code&gt;WRITE&lt;/code&gt; functions. e.g., &lt;a href=&quot;qwidget#focus-prop&quot;&gt;QWidget::focus&lt;/a&gt; has no &lt;code&gt;WRITE&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;WRITE&lt;/code&gt; 접근 기능은 선택 사항입니다. 속성 값을 설정하기위한 것입니다. void를 반환해야하며 속성 유형이나 포인터 또는 해당 유형에 대한 참조 중 하나의 인수를 정확히 가져와야합니다. 예를 들어, &lt;a href=&quot;qwidget#enabled-prop&quot;&gt;QWidget :: enabled&lt;/a&gt; 에는 &lt;code&gt;WRITE&lt;/code&gt; 기능 &lt;a href=&quot;qwidget#enabled-prop&quot;&gt;QWidget :: setEnabled&lt;/a&gt; ()가 있습니다. 읽기 전용 속성에는 &lt;code&gt;WRITE&lt;/code&gt; 기능이 필요하지 않습니다 . 예를 들어, &lt;a href=&quot;qwidget#focus-prop&quot;&gt;QWidget :: focus&lt;/a&gt; 에는 &lt;code&gt;WRITE&lt;/code&gt; 기능 이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="4d0fe0b309c0df8eb1aa0106b0b34950f77ad7f6" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;georectangle&lt;/code&gt; can never cross the poles.</source>
          <target state="translated">&lt;code&gt;georectangle&lt;/code&gt; 는 극을 통과 할 수 없다.</target>
        </trans-unit>
        <trans-unit id="9e4876e257741e2eace4eb6c90ba174d0077bdaa" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;georectangle&lt;/code&gt; is considered invalid if the top-left or bottom-right coordinates are invalid or if the top-left coordinate is south of the bottom-right coordinate.</source>
          <target state="translated">&lt;code&gt;georectangle&lt;/code&gt; 은 왼쪽 상단 또는 하단 오른쪽 좌표가 유효하지 않은 경우 유효하지 않은 것으로 간주 또는 좌상 좌표 남쪽의 경우 오른쪽 하단 좌표입니다.</target>
        </trans-unit>
        <trans-unit id="c7cd0715d79f83518616e0f40000e945014501cc" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;list&lt;/code&gt; can only store QML objects, and cannot contain any &lt;a href=&quot;qtqml-typesystem-basictypes&quot;&gt;basic type&lt;/a&gt; values. (To store basic types within a list, use the &lt;a href=&quot;qml-var&quot;&gt;var&lt;/a&gt; type instead.)</source>
          <target state="translated">&lt;code&gt;list&lt;/code&gt; 만 QML 객체를 저장할 수 있으며, 모든 포함 할 수 없습니다 &lt;a href=&quot;qtqml-typesystem-basictypes&quot;&gt;기본 유형&lt;/a&gt; 값을. (목록에 기본 유형을 저장하려면 대신 &lt;a href=&quot;qml-var&quot;&gt;var&lt;/a&gt; 유형을 사용하십시오.)</target>
        </trans-unit>
        <trans-unit id="a0407992046ea1d51383d8e2c7a6ea7275f37513" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;list&lt;/code&gt; can only store QML objects, and cannot contain any &lt;a href=&quot;qtqml-typesystem-basictypes#&quot;&gt;basic type&lt;/a&gt; values. (To store basic types within a list, use the &lt;a href=&quot;qml-var&quot;&gt;var&lt;/a&gt; type instead.)</source>
          <target state="translated">&lt;code&gt;list&lt;/code&gt; 만 QML 객체를 저장할 수 있으며, 모든 포함 할 수 없습니다 &lt;a href=&quot;qtqml-typesystem-basictypes#&quot;&gt;기본 유형&lt;/a&gt; 값을. 기본 유형을 목록에 저장하려면 대신 &lt;a href=&quot;qml-var&quot;&gt;var&lt;/a&gt; 유형을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="47a7d7d5b8245b169401fa8c56c8609e38605543" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;locale&lt;/code&gt; object.</source>
          <target state="translated">&lt;code&gt;locale&lt;/code&gt; 객체입니다.</target>
        </trans-unit>
        <trans-unit id="1b9747cc4a733ae74fe8615a32ecec20a5061e61" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;matrix4x4&lt;/code&gt; type has sixteen values, each accessible via the properties &lt;code&gt;m11&lt;/code&gt; through &lt;code&gt;m44&lt;/code&gt; in QML (in row/column order). Values of this type can be composed with the Qt.matrix4x4() function. Each attribute in a matrix4x4 is stored as a real (single-precision on ARM, double-precision on x86).</source>
          <target state="translated">&lt;code&gt;matrix4x4&lt;/code&gt; 의 유형 여섯 개 값을 가지며, 각각의 속성을 통해 접근이 &lt;code&gt;m11&lt;/code&gt; 을 통해 &lt;code&gt;m44&lt;/code&gt; (행 / 열 순)으로 QML. 이 유형의 값은 Qt.matrix4x4 () 함수로 구성 할 수 있습니다. matrix4x4의 각 속성은 실수 (ARM의 단일 정밀도, x86의 배정 밀도)로 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="fc3a9fe2b4481aeba4419bddf6d9310dd61e096b" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;quaternion&lt;/code&gt; type has &lt;code&gt;scalar&lt;/code&gt;, &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt; and &lt;code&gt;z&lt;/code&gt; attributes.</source>
          <target state="translated">&lt;code&gt;quaternion&lt;/code&gt; 유형은 갖는 &lt;code&gt;scalar&lt;/code&gt; , &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; 및 &lt;code&gt;z&lt;/code&gt; 속성.</target>
        </trans-unit>
        <trans-unit id="f05e26ab843b04c33d6c023d99b422fad08cf843" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;variant&lt;/code&gt; type property can also hold an image or pixmap. A &lt;code&gt;variant&lt;/code&gt; which contains a &lt;a href=&quot;qpixmap&quot;&gt;QPixmap&lt;/a&gt; or &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt; is known as a &quot;scarce resource&quot; and the declarative engine will attempt to automatically release such resources after evaluation of any JavaScript expression which requires one to be copied has completed.</source>
          <target state="translated">&lt;code&gt;variant&lt;/code&gt; type 속성은 이미지 또는 픽스맵을 보유 할 수 있습니다. &lt;code&gt;variant&lt;/code&gt; 포함 &lt;a href=&quot;qpixmap&quot;&gt;QPixmap&lt;/a&gt; 또는 &lt;a href=&quot;qimage&quot;&gt;QImage는&lt;/a&gt; 자동으로 완료 복사 할 하나를 필요로하는 JavaScript 표현식을 평가 한 후 이러한 리소스를 해제하려고 시도하는 &quot;부족한 자원&quot;및 선언 엔진으로 알려져있다.</target>
        </trans-unit>
        <trans-unit id="0ebb1622ace5751207676ca0c880533f928b5d37" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;vector2d&lt;/code&gt; type has &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; attributes, otherwise it is similar to the &lt;code&gt;vector3d&lt;/code&gt; type. Please see the documentation about the &lt;code&gt;vector3d&lt;/code&gt; type for more information.</source>
          <target state="translated">&lt;code&gt;vector2d&lt;/code&gt; 의 유형은 갖는 &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; 그렇지는 유사 특성 &lt;code&gt;vector3d&lt;/code&gt; 형. 자세한 내용은 &lt;code&gt;vector3d&lt;/code&gt; 유형에 대한 설명서 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="881313a028420b5654f454097e43b03352080e35" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;vector4d&lt;/code&gt; type has &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, &lt;code&gt;z&lt;/code&gt; and &lt;code&gt;w&lt;/code&gt; attributes, otherwise it is similar to the &lt;code&gt;vector3d&lt;/code&gt; type. Please see the documentation about the &lt;code&gt;vector3d&lt;/code&gt; type for more information.</source>
          <target state="translated">&lt;code&gt;vector4d&lt;/code&gt; 의 유형은 갖는 &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; , &lt;code&gt;z&lt;/code&gt; 및 &lt;code&gt;w&lt;/code&gt; 는 그렇지는 유사 특성 &lt;code&gt;vector3d&lt;/code&gt; 형. 자세한 내용은 &lt;code&gt;vector3d&lt;/code&gt; 유형에 대한 설명서 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="94d0575d8e0f30fa662cdf6a23b439e18e40e4ba" translate="yes" xml:space="preserve">
          <source>A Backtab occurred. The input for this may include the Shift or Control keys; e.g. Shift+Tab.</source>
          <target state="translated">백탭이 발생했습니다. 여기에는 Shift 또는 Control 키가 포함될 수 있습니다. 예를 들어 Shift + Tab.</target>
        </trans-unit>
        <trans-unit id="6a53d81f01e07bdff9b7990cb94117757816eae1" translate="yes" xml:space="preserve">
          <source>A Behavior defines the default animation to be applied whenever a particular property value changes.</source>
          <target state="translated">비헤이비어는 특정 속성 값이 변경 될 때마다 적용되는 기본 애니메이션을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="ac5620841e528e85daaf560f5bf7e286c2e745a1" translate="yes" xml:space="preserve">
          <source>A Binary Space Partitioning tree is applied. All &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt;'s item location algorithms are of an order close to logarithmic complexity, by making use of binary search. Adding, moving and removing items is logarithmic. This approach is best for static scenes (i.e., scenes where most items do not move).</source>
          <target state="translated">이진 공간 분할 트리가 적용됩니다. 모든 &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; 의 항목 위치 알고리즘은 이진 검색을 사용하여 로그 복잡성에 가까운 순서입니다. 항목을 추가, 이동 및 제거하는 것이 로그입니다. 이 방법은 정적 장면 (예 : 대부분의 항목이 움직이지 않는 장면)에 가장 적합합니다.</target>
        </trans-unit>
        <trans-unit id="9acf7cadc643bcef87f518ff525eca2aebfe60d1" translate="yes" xml:space="preserve">
          <source>A Bluetooth Low Energy peripheral device can contain multiple services. In turn each service may include further services. This class represents a single service of the peripheral device and is created via &lt;a href=&quot;qlowenergycontroller#createServiceObject&quot;&gt;QLowEnergyController::createServiceObject&lt;/a&gt;(). The &lt;a href=&quot;qlowenergyservice#type&quot;&gt;type&lt;/a&gt;() indicates whether this service is a primary (top-level) service or whether the service is part of another service. Each service may contain one or more characteristics and each characteristic may contain descriptors. The resulting structure may look like the following diagram:</source>
          <target state="translated">Bluetooth 저에너지 주변 장치에는 여러 서비스가 포함될 수 있습니다. 차례로 각 서비스는 추가 서비스를 포함 할 수 있습니다. 이 클래스는 주변 장치의 단일 서비스를 &lt;a href=&quot;qlowenergycontroller#createServiceObject&quot;&gt;나타내며 QLowEnergyController :: createServiceObject&lt;/a&gt; () 를 통해 생성됩니다 . &lt;a href=&quot;qlowenergyservice#type&quot;&gt;타입&lt;/a&gt; ()이 서비스는 기본 (최상위) 서비스인지를 나타내거나 서비스 여부 다른 서비스의 부분이다. 각 서비스는 하나 이상의 특성을 포함 할 수 있으며 각 특성은 설명자를 포함 할 수 있습니다. 결과 구조는 다음 다이어그램과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1df710b360011e4760aab2209623772d9e8f7c17" translate="yes" xml:space="preserve">
          <source>A Bodymovin player for Qt. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">Qt의 Bodymovin 플레이어. &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="58cfd5dccb5f3bb2bb19b7a3a519b30d45465b0d" translate="yes" xml:space="preserve">
          <source>A BorderImage breaks a source image, specified using the &lt;a href=&quot;qml-qtquick-borderimage#source-prop&quot;&gt;source&lt;/a&gt; property, into 9 regions, as shown below:</source>
          <target state="translated">BorderImage는 아래와 같이 &lt;a href=&quot;qml-qtquick-borderimage#source-prop&quot;&gt;source&lt;/a&gt; 속성을 사용하여 지정된 소스 이미지 를 9 개의 영역으로 나눕니다.</target>
        </trans-unit>
        <trans-unit id="520b995735d298ba922c93dfc17b31191820ce03" translate="yes" xml:space="preserve">
          <source>A BorderImage is used to display the image, and it is given a size that is larger than the original image. Since the &lt;a href=&quot;qml-qtquick-borderimage#horizontalTileMode-prop&quot;&gt;horizontalTileMode&lt;/a&gt; property is set to &lt;a href=&quot;qml-qtquick-borderimage#horizontalTileMode-prop&quot;&gt;BorderImage.Stretch&lt;/a&gt;, the parts of image in regions 2 and 8 are stretched horizontally. Since the &lt;a href=&quot;qml-qtquick-borderimage#verticalTileMode-prop&quot;&gt;verticalTileMode&lt;/a&gt; property is set to &lt;a href=&quot;qml-qtquick-borderimage#verticalTileMode-prop&quot;&gt;BorderImage.Stretch&lt;/a&gt;, the parts of image in regions 4 and 6 are stretched vertically.</source>
          <target state="translated">BorderImage는 이미지를 표시하는 데 사용되며 원본 이미지보다 큰 크기가 지정됩니다. 때문에 &lt;a href=&quot;qml-qtquick-borderimage#horizontalTileMode-prop&quot;&gt;horizontalTileMode의&lt;/a&gt; 속성으로 설정되어 &lt;a href=&quot;qml-qtquick-borderimage#horizontalTileMode-prop&quot;&gt;BorderImage.Stretch&lt;/a&gt; , 영역 (2) 및도 8의 이미지 부분은 수평으로 뻗어있다. 때문에 &lt;a href=&quot;qml-qtquick-borderimage#verticalTileMode-prop&quot;&gt;verticalTileMode의&lt;/a&gt; 속성으로 설정되어 &lt;a href=&quot;qml-qtquick-borderimage#verticalTileMode-prop&quot;&gt;BorderImage.Stretch&lt;/a&gt; , 영역 (4) 및 (6) 이미지 부분은 수직으로 뻗어있다.</target>
        </trans-unit>
        <trans-unit id="a0bcfedec02d4cb98f02eaace8be28c0f1c737ff" translate="yes" xml:space="preserve">
          <source>A BoundaryRule defines the range of values that a particular property is allowed to have. When an out-of-range value would otherwise be set, it applies &quot;resistance&quot; via an easing curve.</source>
          <target state="translated">BoundaryRule은 특정 속성이 가질 수있는 값의 범위를 정의합니다. 범위를 벗어난 값이 설정되면 여유 곡선을 통해 &quot;저항&quot;을 적용합니다.</target>
        </trans-unit>
        <trans-unit id="10711d320934306f0f0a923ee2ed3566a1bf33bf" translate="yes" xml:space="preserve">
          <source>A Buffer can be used to create intermediate buffers to share data between &lt;a href=&quot;qml-qtquick3d-pass&quot;&gt;render passes&lt;/a&gt; in an &lt;a href=&quot;qml-qtquick3d-effect&quot;&gt;Effect&lt;/a&gt;.</source>
          <target state="translated">버퍼 는 &lt;a href=&quot;qml-qtquick3d-effect&quot;&gt;Effect&lt;/a&gt; 에서 &lt;a href=&quot;qml-qtquick3d-pass&quot;&gt;렌더 패스&lt;/a&gt; 사이에 데이터를 공유하기 위해 중간 버퍼를 만드는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6b7694d2e441e138e30511b5100b9446e39e5f6b" translate="yes" xml:space="preserve">
          <source>A C++ API for low-level access and control.</source>
          <target state="translated">저수준 액세스 및 제어를위한 C ++ API.</target>
        </trans-unit>
        <trans-unit id="103d07f523362891969f482c236dfce2794992df" translate="yes" xml:space="preserve">
          <source>A C++ class is documented with the &lt;a href=&quot;https://doc.qt.io/qt-5.13/13-qdoc-commands-topics.html#class-command&quot;&gt;\class&lt;/a&gt; command.</source>
          <target state="translated">C ++ 클래스는 &lt;a href=&quot;https://doc.qt.io/qt-5.13/13-qdoc-commands-topics.html#class-command&quot;&gt;\ class&lt;/a&gt; 명령으로 문서화됩니다 .</target>
        </trans-unit>
        <trans-unit id="f7e8ed824a4565df4089d053f4f9df00b3cbab45" translate="yes" xml:space="preserve">
          <source>A C++ class is documented with the &lt;a href=&quot;https://doc.qt.io/qt-5.13/13-qdoc-commands-topics.html#class-command&quot;&gt;\class&lt;/a&gt; command. The annotation for the class is taken from the argument of the class comment's &lt;a href=&quot;11-qdoc-commands-specialcontent#brief-command&quot;&gt;\brief&lt;/a&gt; command.</source>
          <target state="translated">C ++ 클래스는 &lt;a href=&quot;https://doc.qt.io/qt-5.13/13-qdoc-commands-topics.html#class-command&quot;&gt;\ class&lt;/a&gt; 명령으로 문서화됩니다 . 클래스의 주석은 클래스 주석의 &lt;a href=&quot;11-qdoc-commands-specialcontent#brief-command&quot;&gt;\ brief&lt;/a&gt; 명령 의 인수에서 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="7ab9fbcbaae97e21a0cf20f426bb839a602109e5" translate="yes" xml:space="preserve">
          <source>A C++ class is documented with the &lt;a href=&quot;https://doc.qt.io/qt-5.15/13-qdoc-commands-topics.html#class-command&quot;&gt;\class&lt;/a&gt; command.</source>
          <target state="translated">C ++ 클래스는 &lt;a href=&quot;https://doc.qt.io/qt-5.15/13-qdoc-commands-topics.html#class-command&quot;&gt;\ class&lt;/a&gt; 명령으로 문서화됩니다 .</target>
        </trans-unit>
        <trans-unit id="f5a1109e49c352f1e6f93cbae152abb3ac8d4e91" translate="yes" xml:space="preserve">
          <source>A C++ class is documented with the &lt;a href=&quot;https://doc.qt.io/qt-5.15/13-qdoc-commands-topics.html#class-command&quot;&gt;\class&lt;/a&gt; command. The annotation for the class is taken from the argument of the class comment's &lt;a href=&quot;11-qdoc-commands-specialcontent#brief-command&quot;&gt;\brief&lt;/a&gt; command.</source>
          <target state="translated">C ++ 클래스는 &lt;a href=&quot;https://doc.qt.io/qt-5.15/13-qdoc-commands-topics.html#class-command&quot;&gt;\ class&lt;/a&gt; 명령으로 문서화됩니다 . 클래스에 대한 주석은 클래스 주석의 &lt;a href=&quot;11-qdoc-commands-specialcontent#brief-command&quot;&gt;\ brief&lt;/a&gt; 명령 인수에서 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="301abeb05bc3f11054df79c170539f398ab0b292" translate="yes" xml:space="preserve">
          <source>A C++ class is documented with the &lt;a href=&quot;https://doc.qt.io/qt-6.0/13-qdoc-commands-topics.html#class-command&quot;&gt;\class&lt;/a&gt; command.</source>
          <target state="translated">C ++ 클래스는 &lt;a href=&quot;https://doc.qt.io/qt-6.0/13-qdoc-commands-topics.html#class-command&quot;&gt;\ class&lt;/a&gt; 명령으로 문서화됩니다 .</target>
        </trans-unit>
        <trans-unit id="98886d0d963895c8e2c0ad3141adfa24fe7679a3" translate="yes" xml:space="preserve">
          <source>A C++ class is documented with the &lt;a href=&quot;https://doc.qt.io/qt-6.0/13-qdoc-commands-topics.html#class-command&quot;&gt;\class&lt;/a&gt; command. The annotation for the class is taken from the argument of the class comment's &lt;a href=&quot;11-qdoc-commands-specialcontent#brief-command&quot;&gt;\brief&lt;/a&gt; command.</source>
          <target state="translated">C ++ 클래스는 &lt;a href=&quot;https://doc.qt.io/qt-6.0/13-qdoc-commands-topics.html#class-command&quot;&gt;\ class&lt;/a&gt; 명령으로 문서화됩니다 . 클래스에 대한 주석은 클래스 주석의 &lt;a href=&quot;11-qdoc-commands-specialcontent#brief-command&quot;&gt;\ brief&lt;/a&gt; 명령 의 인수에서 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="deff3292f5525434f11ce861649b3c20c1941503" translate="yes" xml:space="preserve">
          <source>A C++ model class can be defined as a &lt;a href=&quot;qstringlist&quot;&gt;QStringList&lt;/a&gt;, a &lt;a href=&quot;qvariant#QVariantList-typedef&quot;&gt;QVariantList&lt;/a&gt;, a &lt;a href=&quot;qobject#QObjectList-typedef&quot;&gt;QObjectList&lt;/a&gt; or a &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt;. The first three are useful for exposing simpler datasets, while &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; provides a more flexible solution for more complex models.</source>
          <target state="translated">C ++ 모델 클래스는 &lt;a href=&quot;qstringlist&quot;&gt;QStringList&lt;/a&gt; , &lt;a href=&quot;qvariant#QVariantList-typedef&quot;&gt;QVariantList&lt;/a&gt; , &lt;a href=&quot;qobject#QObjectList-typedef&quot;&gt;QObjectList&lt;/a&gt; 또는 &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; 로 정의 할 수 있습니다 . 처음 3 개는 더 간단한 데이터 세트를 노출하는 데 유용하지만 &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; 은 더 복잡한 모델에 대해보다 유연한 솔루션을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="49371d5aeeb4de6074949dfc6677a975df2c89c3" translate="yes" xml:space="preserve">
          <source>A CAN bus error occurred.</source>
          <target state="translated">CAN 버스 오류가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="4e6bd33976c8b452f95cab9dc14145864fd5747a" translate="yes" xml:space="preserve">
          <source>A CSS stylesheet.</source>
          <target state="translated">CSS 스타일 시트.</target>
        </trans-unit>
        <trans-unit id="41557512656d9ff5a00723bc11e17b5c2ae1b7c4" translate="yes" xml:space="preserve">
          <source>A CSS-style sheet.</source>
          <target state="translated">CSS 스타일 시트.</target>
        </trans-unit>
        <trans-unit id="0484ea15a7ad06c2243dc0419f315eef8ea4b81b" translate="yes" xml:space="preserve">
          <source>A Camera defines how the content of the 3D scene is projected onto a 2D surface, such as a &lt;a href=&quot;qml-qtquick3d-view3d&quot;&gt;View3D&lt;/a&gt;. A scene needs at least one Camera in order to visualize its contents.</source>
          <target state="translated">카메라는 3D 장면의 내용이 &lt;a href=&quot;qml-qtquick3d-view3d&quot;&gt;View3D&lt;/a&gt; 와 같은 2D 표면에 투영되는 방식을 정의합니다 . 장면은 콘텐츠를 시각화하기 위해 적어도 하나의 카메라가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="1bd8f596eb556b83bb82adf49b502fd89a79b2cf" translate="yes" xml:space="preserve">
          <source>A Camera is always necessary to view the content of a 3D scene. A camera defines how to project the content of a 3D scene into a 2D coordinate space, which can then be used on a 2D surface. When a camera is present in the scene it can be used to direct what is displayed in a &lt;a href=&quot;qml-qtquick3d-view3d&quot;&gt;View3D&lt;/a&gt;.</source>
          <target state="translated">3D 장면의 내용을 보려면 항상 카메라가 필요합니다. 카메라는 3D 장면의 콘텐츠를 2D 좌표 공간에 투영하는 방법을 정의한 다음 2D 표면에서 사용할 수 있습니다. 카메라가 장면에 있으면 &lt;a href=&quot;qml-qtquick3d-view3d&quot;&gt;View3D에&lt;/a&gt; 표시되는 것을 지시하는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f021a87dd9ae8c8a676c9ba6af0df370f1e7bac0" translate="yes" xml:space="preserve">
          <source>A CameraSelector can be used to select the camera, which is used by the FrameGraph when drawing the entities.</source>
          <target state="translated">CameraSelector를 사용하여 엔티티를 그릴 때 FrameGraph에서 사용하는 카메라를 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="42489fb8e40db2dbd53e889f99bf067eb759a035" translate="yes" xml:space="preserve">
          <source>A CheckBox is an option button that can be toggled on (checked) or off (unchecked). Checkboxes are typically used to represent features in an application that can be enabled or disabled without affecting others.</source>
          <target state="translated">CheckBox는 설정 (선택) 또는 해제 (선택 해제) 할 수있는 옵션 버튼입니다. 확인란은 일반적으로 다른 사람에게 영향을주지 않고 활성화 또는 비활성화 할 수있는 응용 프로그램의 기능을 나타내는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d406b07990ad0606a797401bb99c556c579bc3b8" translate="yes" xml:space="preserve">
          <source>A ColorDialog window is automatically transient for its parent window. So whether you declare the dialog inside an &lt;a href=&quot;qml-qtquick-item&quot;&gt;Item&lt;/a&gt; or inside a &lt;a href=&quot;qml-qtquick-window-window&quot;&gt;Window&lt;/a&gt;, the dialog will appear centered over the window containing the item, or over the Window that you declared.</source>
          <target state="translated">ColorDialog 창은 부모 창에 대해 자동으로 일시적입니다. 따라서 &lt;a href=&quot;qml-qtquick-item&quot;&gt;Item&lt;/a&gt; 내부 또는 &lt;a href=&quot;qml-qtquick-window-window&quot;&gt;Window&lt;/a&gt; 내부에서 대화를 선언하는지 여부에 관계없이 대화 상자는 항목이 포함 된 창 또는 선언 한 창 중앙에 나타납니다.</target>
        </trans-unit>
        <trans-unit id="320320cc8f5497f60d7d039aad91e79c0d183c35" translate="yes" xml:space="preserve">
          <source>A ColorDialogRequest is passed as an argument of the &lt;a href=&quot;qml-qtwebengine-webengineview#colorDialogRequested-signal&quot;&gt;WebEngineView::colorDialogRequested&lt;/a&gt; signal. It is generated when a color picker dialog is requested. See &lt;a href=&quot;https://www.w3.org/TR/html5/forms.html#color-state-(type=color)&quot;&gt;HTML5 Color State&lt;/a&gt;.</source>
          <target state="translated">ColorDialogRequest는 &lt;a href=&quot;qml-qtwebengine-webengineview#colorDialogRequested-signal&quot;&gt;WebEngineView :: colorDialogRequested&lt;/a&gt; 신호 의 인수로 전달됩니다 . 색상 선택기 대화 상자가 요청 될 때 생성됩니다. &lt;a href=&quot;https://www.w3.org/TR/html5/forms.html#color-state-(type=color)&quot;&gt;HTML5 색상 상태를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="63cdd70b268f237cb8c56b7f4679b6679288c5c0" translate="yes" xml:space="preserve">
          <source>A Column animate items using specific transitions when items are added to or moved within a Column.</source>
          <target state="translated">항목이 항목에 추가되거나 항목 내에서 이동할 때 특정 전환을 사용하여 항목에 애니메이션을 적용합니다.</target>
        </trans-unit>
        <trans-unit id="bfeafe4dfea192eb7ba359da24326ad15f2c9cce" translate="yes" xml:space="preserve">
          <source>A ComputeCommand is used to issue work for the compute shader. The compute shader is specified in the Material component of the same entity the ComputeCommand is added to. The &lt;a href=&quot;qml-qt3d-render-computecommand#workGroupX-prop&quot;&gt;workGroupX&lt;/a&gt;, &lt;a href=&quot;qml-qt3d-render-computecommand#workGroupY-prop&quot;&gt;workGroupY&lt;/a&gt; and &lt;a href=&quot;qml-qt3d-render-computecommand#workGroupZ-prop&quot;&gt;workGroupZ&lt;/a&gt; properties specify the work group sizes for the compute shader invocation. &lt;a href=&quot;qml-qt3d-render-dispatchcompute&quot;&gt;DispatchCompute&lt;/a&gt; node needs to be present in the FrameGraph to actually issue the commands. The execution behavior of the compute command can be controlled with the run type property.</source>
          <target state="translated">ComputeCommand는 컴퓨팅 셰이더에 대한 작업을 실행하는 데 사용됩니다. 컴퓨팅 셰이더는 ComputeCommand가 추가 된 동일한 엔터티의 재질 구성 요소에 지정됩니다. &lt;a href=&quot;qml-qt3d-render-computecommand#workGroupX-prop&quot;&gt;workGroupX&lt;/a&gt; , &lt;a href=&quot;qml-qt3d-render-computecommand#workGroupY-prop&quot;&gt;workGroupY&lt;/a&gt; 및 &lt;a href=&quot;qml-qt3d-render-computecommand#workGroupZ-prop&quot;&gt;workGroupZ&lt;/a&gt; 속성은 연산 쉐이더 호출을위한 작업 그룹 크기를 지정합니다. 실제로 명령을 실행하려면 &lt;a href=&quot;qml-qt3d-render-dispatchcompute&quot;&gt;DispatchCompute&lt;/a&gt; 노드가 FrameGraph에 있어야합니다. 컴퓨팅 명령의 실행 동작은 실행 유형 속성으로 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ff8d8c5112704061aeafa944c178cbb863b93db" translate="yes" xml:space="preserve">
          <source>A Connections object creates a connection to a QML signal.</source>
          <target state="translated">Connections 오브젝트는 QML 신호에 대한 연결을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="d0741f58583e4367eedcd4deeda042616d0bb02e" translate="yes" xml:space="preserve">
          <source>A ContextMenuRequest is passed as an argument of the &lt;a href=&quot;qml-qtwebengine-webengineview#contextMenuRequested-signal&quot;&gt;WebEngineView::contextMenuRequested&lt;/a&gt; signal. It provides further information about the context of the request. The position of the request origin can be found via the &lt;a href=&quot;qml-qtwebengine-contextmenurequest#x-prop&quot;&gt;x&lt;/a&gt; and &lt;a href=&quot;qml-qtwebengine-contextmenurequest#y-prop&quot;&gt;y&lt;/a&gt; properties.</source>
          <target state="translated">ContextMenuRequest는 &lt;a href=&quot;qml-qtwebengine-webengineview#contextMenuRequested-signal&quot;&gt;WebEngineView :: contextMenuRequested&lt;/a&gt; 신호 의 인수로 전달됩니다 . 요청 컨텍스트에 대한 추가 정보를 제공합니다. 요청 출처의 위치는 &lt;a href=&quot;qml-qtwebengine-contextmenurequest#x-prop&quot;&gt;x&lt;/a&gt; 및 &lt;a href=&quot;qml-qtwebengine-contextmenurequest#y-prop&quot;&gt;y&lt;/a&gt; 속성을 통해 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1c7e2e475b906f15673f23ccfdc4eaa854b126eb" translate="yes" xml:space="preserve">
          <source>A Controller Area Network (CAN) is a vehicle bus standard designed to allow microcontrollers and devices to communicate with each other in applications without a host computer.</source>
          <target state="translated">CAN (Controller Area Network)은 호스트 컴퓨터없이 응용 프로그램에서 마이크로 컨트롤러와 장치가 서로 통신 할 수 있도록 설계된 차량 버스 표준입니다.</target>
        </trans-unit>
        <trans-unit id="b503e119e4fdbebf72027adfb72d6c8344e64978" translate="yes" xml:space="preserve">
          <source>A Ctrl key on the keyboard is pressed.</source>
          <target state="translated">키보드의 Ctrl 키를 눌렀습니다.</target>
        </trans-unit>
        <trans-unit id="3940c34620de01cba93dd449edc4c82d86490924" translate="yes" xml:space="preserve">
          <source>A Ctrl key on the keyboard must be pressed.</source>
          <target state="translated">키보드의 Ctrl 키를 눌러야합니다.</target>
        </trans-unit>
        <trans-unit id="067afe9cf8afa7053c05df09954a1dd2199b2f99" translate="yes" xml:space="preserve">
          <source>A D-Bus function that takes an integer, a D-Bus variant and a string as parameters can be called with the following argument list (see &lt;a href=&quot;qdbusmessage#setArguments&quot;&gt;QDBusMessage::setArguments&lt;/a&gt;()):</source>
          <target state="translated">정수, D-Bus 변형 및 문자열을 매개 변수로 취하는 D-Bus 함수는 다음 인수 목록을 사용하여 호출 할 수 있습니다 ( &lt;a href=&quot;qdbusmessage#setArguments&quot;&gt;QDBusMessage :: setArguments&lt;/a&gt; () 참조).</target>
        </trans-unit>
        <trans-unit id="3f3548726d39906f63491b3d2fa849193c960159" translate="yes" xml:space="preserve">
          <source>A D-Bus variant type can contain any type, including other variants. It is similar to the Qt &lt;a href=&quot;qtcore-changes-qt6#qvariant&quot;&gt;QVariant&lt;/a&gt; type.</source>
          <target state="translated">D-Bus 변형 유형은 다른 변형을 포함하여 모든 유형을 포함 할 수 있습니다. Qt &lt;a href=&quot;qtcore-changes-qt6#qvariant&quot;&gt;QVariant&lt;/a&gt; 유형 과 유사 합니다.</target>
        </trans-unit>
        <trans-unit id="eb9b37927bdba7a3fe01972772f3d1178f63ead9" translate="yes" xml:space="preserve">
          <source>A D-Bus variant type can contain any type, including other variants. It is similar to the Qt &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; type.</source>
          <target state="translated">D- 버스 변형 유형에는 다른 변형을 포함하여 모든 유형이 포함될 수 있습니다. Qt &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; 유형 과 유사 합니다.</target>
        </trans-unit>
        <trans-unit id="85feba6bd47bdb30e1f79ed4b08f1f256ac071b0" translate="yes" xml:space="preserve">
          <source>A DBus signal is emitted from one application and is received by all applications that are listening for that signal from that interface.</source>
          <target state="translated">DBus 신호는 하나의 응용 프로그램에서 방출되며 해당 인터페이스에서 해당 신호를 수신하는 모든 응용 프로그램에서 수신됩니다.</target>
        </trans-unit>
        <trans-unit id="d382d7e43f709662b72b0596cfabd1f2e1c37e6c" translate="yes" xml:space="preserve">
          <source>A DBus signal is emitted from one application and is received only by the application owning the destination</source>
          <target state="translated">DBus 신호는 하나의 응용 프로그램에서 방출되며 대상을 소유 한 응용 프로그램에서만 수신</target>
        </trans-unit>
        <trans-unit id="27c8de78fe38a89b97c7a9822be33472bcf448c0" translate="yes" xml:space="preserve">
          <source>A DNS host name entry; the entry contains a host name entry that the certificate is valid for. The entry may contain wildcards.</source>
          <target state="translated">DNS 호스트 이름 항목 항목에 인증서가 유효한 호스트 이름 항목이 있습니다. 항목에 와일드 카드가 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="04f6ec2e382d3863d3aa2900bbd7b8c8241e4b89" translate="yes" xml:space="preserve">
          <source>A DTLS connection may be closed using &lt;a href=&quot;qdtls#shutdown&quot;&gt;shutdown&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qdtls#shutdown&quot;&gt;종료&lt;/a&gt; ()를 사용하여 DTLS 연결을 닫을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5795919e3a889cc073ca41b4341920d728c41e08" translate="yes" xml:space="preserve">
          <source>A DelayButton after being activated</source>
          <target state="translated">활성화 된 후 DelayButton</target>
        </trans-unit>
        <trans-unit id="b579bb7cbc9fd24ade16ce38531ec4094e5df5cd" translate="yes" xml:space="preserve">
          <source>A DelayButton being held down</source>
          <target state="translated">누르고있는 DelayButton</target>
        </trans-unit>
        <trans-unit id="79e42ab6aa192755a4e1da64e6e61bdc7243e915" translate="yes" xml:space="preserve">
          <source>A DepthTest type is used to enable depth testing with a given depth test function. The depth test enables writing fragment color values when the depth test passes, and reject fragments which fail the test. The depth test uses the depth function to test the fragments depth value to the value against z-buffer. If the underlying surface does not have z-buffer, the DepthTest does nothing.</source>
          <target state="translated">DepthTest 유형은 주어진 깊이 테스트 기능으로 깊이 테스트를 활성화하는 데 사용됩니다. 심도 테스트를 사용하면 심도 테스트를 통과하면 조각 색상 값을 쓸 수 있고 테스트에 실패한 조각은 거부 할 수 있습니다. 깊이 테스트는 깊이 함수를 사용하여 조각 깊이 값을 z 버퍼에 대한 값으로 테스트합니다. 기본 표면에 z 버퍼가 없으면 DepthTest는 아무 작업도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="194b7fb3505ce444afd166e9e6a32bd5d19a0a2b" translate="yes" xml:space="preserve">
          <source>A Dialog Without Auto-Connect</source>
          <target state="translated">자동 연결이없는 대화 상자</target>
        </trans-unit>
        <trans-unit id="7696353a2b078c8d27719c27c72a9fd51c80c173" translate="yes" xml:space="preserve">
          <source>A Dialog in English</source>
          <target state="translated">영어 대화</target>
        </trans-unit>
        <trans-unit id="51937631ef93b7534a1d4c5a929b61bcf0ad014d" translate="yes" xml:space="preserve">
          <source>A Dialog in French</source>
          <target state="translated">프랑스어 대화</target>
        </trans-unit>
        <trans-unit id="c274ae08d1779320198cd6faf282de73fc1e1b8c" translate="yes" xml:space="preserve">
          <source>A DispatchCompute allows work to be issued for the compute shader to run on the GPU. The &lt;a href=&quot;qml-qt3d-render-dispatchcompute#workGroupX-prop&quot;&gt;workGroupX&lt;/a&gt;, &lt;a href=&quot;qml-qt3d-render-dispatchcompute#workGroupY-prop&quot;&gt;workGroupY&lt;/a&gt; and &lt;a href=&quot;qml-qt3d-render-dispatchcompute#workGroupZ-prop&quot;&gt;workGroupZ&lt;/a&gt; properties specify the work group sizes for the compute shader invocation. &lt;a href=&quot;qml-qt3d-render-computecommand&quot;&gt;ComputeCommand&lt;/a&gt; components need to be added to entities to instruct Qt3D to select the materials and geometry from the entities for the compute invocation. The work group sizes for the shader invocation will be the maximum of the work group sizes specified in DispatchCompute and &lt;a href=&quot;qml-qt3d-render-computecommand&quot;&gt;ComputeCommand&lt;/a&gt;.</source>
          <target state="translated">DispatchCompute를 사용하면 컴퓨팅 셰이더가 GPU에서 실행되도록 작업을 실행할 수 있습니다. &lt;a href=&quot;qml-qt3d-render-dispatchcompute#workGroupX-prop&quot;&gt;workGroupX&lt;/a&gt; , &lt;a href=&quot;qml-qt3d-render-dispatchcompute#workGroupY-prop&quot;&gt;workGroupY&lt;/a&gt; 및 &lt;a href=&quot;qml-qt3d-render-dispatchcompute#workGroupZ-prop&quot;&gt;workGroupZ&lt;/a&gt; 속성은 연산 쉐이더 호출을위한 작업 그룹 크기를 지정합니다. &lt;a href=&quot;qml-qt3d-render-computecommand&quot;&gt;ComputeCommand&lt;/a&gt; 구성 요소를 엔티티에 추가하여 Qt3D가 컴퓨팅 호출을 위해 엔티티에서 재료와 지오메트리를 선택하도록 지시해야합니다. 셰이더 호출을위한 작업 그룹 크기는 DispatchCompute 및 &lt;a href=&quot;qml-qt3d-render-computecommand&quot;&gt;ComputeCommand에&lt;/a&gt; 지정된 작업 그룹 크기의 최대 값입니다 .</target>
        </trans-unit>
        <trans-unit id="e4300c782a67b8272f8415165fbd0f0f3e88aaeb" translate="yes" xml:space="preserve">
          <source>A Dithering type enables dithering. Dithering adds noise to the color values to randomize quantization error in order to prevent large scale patterns in the final image, such as banding. Dithering is most useful when rendering to a surface with low color bit depth, such as RGB565 or RGBA4444.</source>
          <target state="translated">디더링 유형은 디더링을 활성화합니다. 디더링은 밴딩과 같은 최종 이미지에서 대규모 패턴을 방지하기 위해 색상 값에 노이즈를 추가하여 양자화 오류를 랜덤 화합니다. 디더링은 RGB565 또는 RGBA4444와 같이 낮은 색상 비트 심도로 표면에 렌더링 할 때 가장 유용합니다.</target>
        </trans-unit>
        <trans-unit id="31554e405c62c1a77a0e7912477dc0849c06611b" translate="yes" xml:space="preserve">
          <source>A DropArea is an invisible item which receives events when other items are dragged over it.</source>
          <target state="translated">DropArea는 다른 항목을 드래그 할 때 이벤트를받는 보이지 않는 항목입니다.</target>
        </trans-unit>
        <trans-unit id="4da9556752594943703277eca566a8dfe66aed59" translate="yes" xml:space="preserve">
          <source>A FileDialog window is automatically transient for its parent window. So whether you declare the dialog inside an &lt;a href=&quot;qml-qtquick-item&quot;&gt;Item&lt;/a&gt; or inside a &lt;a href=&quot;qml-qtquick-window-window&quot;&gt;Window&lt;/a&gt;, the dialog will appear centered over the window containing the item, or over the Window that you declared.</source>
          <target state="translated">FileDialog 창은 부모 창에 대해 자동으로 일시적입니다. 따라서 &lt;a href=&quot;qml-qtquick-item&quot;&gt;Item&lt;/a&gt; 내부 또는 &lt;a href=&quot;qml-qtquick-window-window&quot;&gt;Window&lt;/a&gt; 내부에서 대화를 선언하는지 여부에 관계없이 대화 상자는 항목이 포함 된 창 또는 선언 한 창 중앙에 나타납니다.</target>
        </trans-unit>
        <trans-unit id="736541553d814e33c93a619a6b9f577ac7ec643c" translate="yes" xml:space="preserve">
          <source>A FileDialogRequest is passed as an argument of the &lt;a href=&quot;qml-qtwebengine-webengineview#fileDialogRequested-signal&quot;&gt;WebEngineView::fileDialogRequested&lt;/a&gt; signal. It is generated when the file dialog is requested by the input element. See &lt;a href=&quot;https://www.w3.org/TR/html5/forms.html#file-upload-state-(type=file)&quot;&gt;File Upload state&lt;/a&gt;.</source>
          <target state="translated">FileDialogRequest는 &lt;a href=&quot;qml-qtwebengine-webengineview#fileDialogRequested-signal&quot;&gt;WebEngineView :: fileDialogRequested&lt;/a&gt; 신호 의 인수로 전달됩니다 . 입력 요소가 파일 대화 상자를 요청할 때 생성됩니다. &lt;a href=&quot;https://www.w3.org/TR/html5/forms.html#file-upload-state-(type=file)&quot;&gt;파일 업로드 상태를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2559012e5debc093eeaba08ae375b32d93be4828" translate="yes" xml:space="preserve">
          <source>A FilterKey is a storage type for filter key and value pair. Filter keys are used by Technique and &lt;a href=&quot;qml-qt3d-render-renderpass&quot;&gt;RenderPass&lt;/a&gt; to specify at which stage of rendering the technique or the render pass is used.</source>
          <target state="translated">FilterKey는 필터 키 및 값 쌍에 대한 저장소 유형입니다. 필터 키는 Technique 및 &lt;a href=&quot;qml-qt3d-render-renderpass&quot;&gt;RenderPass&lt;/a&gt; 에서 기술 또는 렌더링 패스가 사용되는 렌더링 단계를 지정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a576cb03a01ceba76330ef9737fa7b4c61b4f925" translate="yes" xml:space="preserve">
          <source>A FontDialog window is automatically transient for its parent window. So whether you declare the dialog inside an &lt;a href=&quot;qml-qtquick-item&quot;&gt;Item&lt;/a&gt; or inside a &lt;a href=&quot;qml-qtquick-window-window&quot;&gt;Window&lt;/a&gt;, the dialog will appear centered over the window containing the item, or over the Window that you declared.</source>
          <target state="translated">FontDialog 창은 부모 창에 대해 자동으로 일시적입니다. 따라서 &lt;a href=&quot;qml-qtquick-item&quot;&gt;Item&lt;/a&gt; 내부 또는 &lt;a href=&quot;qml-qtquick-window-window&quot;&gt;Window&lt;/a&gt; 내부에서 대화를 선언하는지 여부에 관계없이 대화 상자는 항목이 포함 된 창 또는 선언 한 창 중앙에 나타납니다.</target>
        </trans-unit>
        <trans-unit id="28a49e1f7c528b6a15d5cd927d787fea2d4bcfbf" translate="yes" xml:space="preserve">
          <source>A FrameRateRange represents a range of frame rates as minimum and maximum rate. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">FrameRateRange는 프레임 속도 범위를 최소 및 최대 속도로 나타냅니다. &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="693c6947c83fbe544cebb0017442a3871769b39c" translate="yes" xml:space="preserve">
          <source>A FrontFace sets the winding direction of the front facing polygons.</source>
          <target state="translated">FrontFace는 정면을 향하는 다각형의 감기 ​​방향을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="d8b7733c5922bf3039afcb0a90a4165d14640458" translate="yes" xml:space="preserve">
          <source>A FrustumCulling type enables frustum culling of the drawable entities based on the camera view and Geometry bounds of the entities. If FrustumCulling is present in the FrameGraph, only the entities whose Geometry bounds intersect with the camera frustum, i.e. the view of the camera, are drawn. If FrustumCulling is not present, all drawable entities will be drawn. The camera is selected by a &lt;a href=&quot;qml-qt3d-render-cameraselector&quot;&gt;CameraSelector&lt;/a&gt; frame graph node in the current hierarchy. Frustum culling can save a lot of GPU processing time when the rendered scene is complex.</source>
          <target state="translated">FrustumCulling 유형을 사용하면 엔티티의 카메라 뷰 및 형상 경계를 기반으로 드로어 블 엔티티의 절두체 컬링이 가능합니다. FrustumCulling이 FrameGraph에있는 경우 Geometry 경계가 카메라 절두체와 교차하는 엔티티, 즉 카메라 뷰만 그려집니다. FrustumCulling이 없으면 모든 드로어 블 엔티티가 그려집니다. 카메라는 현재 계층 구조 의 &lt;a href=&quot;qml-qt3d-render-cameraselector&quot;&gt;CameraSelector&lt;/a&gt; 프레임 그래프 노드에 의해 선택됩니다 . Frustum 컬링은 렌더링 된 장면이 복잡 할 때 많은 GPU 처리 시간을 절약 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ae5e00252de3df624d754cb8c6cfa1daf441562" translate="yes" xml:space="preserve">
          <source>A Geometry type is used to group a list of Attribute objects together to form a geometric shape Qt3D is able to render using &lt;a href=&quot;qt3drender-geometry#geometryrenderer&quot;&gt;GeometryRenderer&lt;/a&gt;. Special attribute can be set in order to calculate bounding volume of the shape.</source>
          <target state="translated">Geometry 유형은 Attribute 객체 목록을 그룹화하여 Qt3D가 &lt;a href=&quot;qt3drender-geometry#geometryrenderer&quot;&gt;GeometryRenderer를&lt;/a&gt; 사용하여 렌더링 할 수있는 기하학적 모양을 형성하는 데 사용 됩니다. 모양의 경계 볼륨을 계산하기 위해 특수 속성을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7234c1a488ef0c0702134773edfc27a5dd6535b3" translate="yes" xml:space="preserve">
          <source>A GeometryRenderer holds all the information necessary to draw a Geometry. A Geometry holds the coordinates of the geometry data - GeometryRenderer specifies how to interpret that data.</source>
          <target state="translated">GeometryRenderer는 Geometry를 그리는 데 필요한 모든 정보를 보유합니다. Geometry는 도형 데이터의 좌표를 보유합니다. GeometryRenderer는 해당 데이터를 해석하는 방법을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="5b4b1b53820f4f541c3db1a879d9b9bc2d247f96" translate="yes" xml:space="preserve">
          <source>A GeometryView holds all the information necessary to handle a Geometry. A Geometry holds the coordinates of the geometry data - GeometryView specifies how to interpret that data.</source>
          <target state="translated">GeometryView는 Geometry를 처리하는 데 필요한 모든 정보를 보유합니다. Geometry는 기하학 데이터의 좌표를 보유합니다. GeometryView는 해당 데이터를 해석하는 방법을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="a522ab31d2513bb58d99fa08d473ce0b3e8595fb" translate="yes" xml:space="preserve">
          <source>A Grid creates a grid of cells that is large enough to hold all of its child items, and places these items in the cells from left to right and top to bottom. Each item is positioned at the top-left corner of its cell with position (0, 0).</source>
          <target state="translated">모눈은 모든 자식 항목을 담을 수있을만큼 큰 셀 모눈을 만들어 왼쪽에서 오른쪽으로, 위에서 아래로 셀에 배치합니다. 각 항목은 셀의 왼쪽 상단에 위치 (0, 0)로 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="eca227560551d4563e6526b484f9b526385d902d" translate="yes" xml:space="preserve">
          <source>A Grid defaults to four columns, and creates as many rows as are necessary to fit all of its child items. The number of rows and columns can be constrained by setting the &lt;a href=&quot;qml-qtquick-grid#rows-prop&quot;&gt;rows&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-grid#columns-prop&quot;&gt;columns&lt;/a&gt; properties.</source>
          <target state="translated">그리드는 기본적으로 4 개의 열로 구성되며 모든 하위 항목에 맞도록 필요한만큼의 행을 만듭니다. &lt;a href=&quot;qml-qtquick-grid#rows-prop&quot;&gt;rows&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-grid#columns-prop&quot;&gt;columns&lt;/a&gt; 속성 을 설정하여 행 과 열 수를 제한 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fd9a6117fc49256078a1ea60102fbc43c288635a" translate="yes" xml:space="preserve">
          <source>A GridView displays data from models created from built-in QML types like &lt;a href=&quot;qml-qtqml-models-listmodel&quot;&gt;ListModel&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-xmllistmodel-xmllistmodel&quot;&gt;XmlListModel&lt;/a&gt;, or custom model classes defined in C++ that inherit from &lt;a href=&quot;qabstractlistmodel&quot;&gt;QAbstractListModel&lt;/a&gt;.</source>
          <target state="translated">GridView는 &lt;a href=&quot;qml-qtqml-models-listmodel&quot;&gt;ListModel&lt;/a&gt; 및 &lt;a href=&quot;qml-qtquick-xmllistmodel-xmllistmodel&quot;&gt;XmlListModel&lt;/a&gt; 과 같은 기본 제공 QML 유형 또는 &lt;a href=&quot;qabstractlistmodel&quot;&gt;QAbstractListModel&lt;/a&gt; 에서 상속 된 C ++로 정의 된 사용자 지정 모델 클래스 에서 생성 된 모델의 데이터를 표시합니다 .</target>
        </trans-unit>
        <trans-unit id="67c5277b12c5814fd76112db36e91d1ba18637d6" translate="yes" xml:space="preserve">
          <source>A GridView displays data from models created from built-in QML types like &lt;a href=&quot;qml-qtqml-models-listmodel&quot;&gt;ListModel&lt;/a&gt; and XmlListModel, or custom model classes defined in C++ that inherit from &lt;a href=&quot;qabstractlistmodel&quot;&gt;QAbstractListModel&lt;/a&gt;.</source>
          <target state="translated">GridView는 &lt;a href=&quot;qml-qtqml-models-listmodel&quot;&gt;ListModel&lt;/a&gt; 및 XmlListModel 과 같은 기본 제공 QML 유형 또는 &lt;a href=&quot;qabstractlistmodel&quot;&gt;QAbstractListModel&lt;/a&gt; 에서 상속 된 C ++로 정의 된 사용자 지정 모델 클래스 에서 생성 된 모델의 데이터를 표시합니다 .</target>
        </trans-unit>
        <trans-unit id="c27b4b42563ae7f26c1c3f8667e3f20045ba4e95" translate="yes" xml:space="preserve">
          <source>A GridView has a &lt;a href=&quot;qml-qtquick-gridview#model-prop&quot;&gt;model&lt;/a&gt;, which defines the data to be displayed, and a &lt;a href=&quot;qml-qtquick-gridview#delegate-prop&quot;&gt;delegate&lt;/a&gt;, which defines how the data should be displayed. Items in a GridView are laid out horizontally or vertically. Grid views are inherently flickable as GridView inherits from &lt;a href=&quot;qml-qtquick-flickable&quot;&gt;Flickable&lt;/a&gt;.</source>
          <target state="translated">GridView에는 표시 할 데이터를 정의 하는 &lt;a href=&quot;qml-qtquick-gridview#model-prop&quot;&gt;model&lt;/a&gt; 과 데이터 표시 방법을 정의하는 &lt;a href=&quot;qml-qtquick-gridview#delegate-prop&quot;&gt;delegate&lt;/a&gt; 가 있습니다. GridView의 항목은 가로 또는 세로로 배치됩니다. GridView가 &lt;a href=&quot;qml-qtquick-flickable&quot;&gt;Flickable&lt;/a&gt; 에서 상속하므로 그리드 뷰는 본질적으로 플릭 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="83c3b2763ae7d06052abbcf2d6b2306db98bc983" translate="yes" xml:space="preserve">
          <source>A HiFi audio device.</source>
          <target state="translated">HiFi 오디오 장치.</target>
        </trans-unit>
        <trans-unit id="4078c3dfd01c62a2dfb5d52b569efbe8354b7dfa" translate="yes" xml:space="preserve">
          <source>A HorizontalHeaderView provides labeling of the columns of a &lt;a href=&quot;qml-qtquick-tableview&quot;&gt;TableView&lt;/a&gt;. To add a horizontal header to a &lt;a href=&quot;qml-qtquick-tableview&quot;&gt;TableView&lt;/a&gt;, bind the &lt;a href=&quot;qml-qtquick-controls2-horizontalheaderview#syncView-prop&quot;&gt;syncView&lt;/a&gt; property to the &lt;a href=&quot;qml-qtquick-tableview&quot;&gt;TableView&lt;/a&gt;:</source>
          <target state="translated">HorizontalHeaderView는 &lt;a href=&quot;qml-qtquick-tableview&quot;&gt;TableView&lt;/a&gt; 의 열 레이블링을 제공합니다 . A와 수평 헤더 추가 &lt;a href=&quot;qml-qtquick-tableview&quot;&gt;의 TableView&lt;/a&gt; , 바인드 &lt;a href=&quot;qml-qtquick-controls2-horizontalheaderview#syncView-prop&quot;&gt;syncView의&lt;/a&gt; 받는 재산 &lt;a href=&quot;qml-qtquick-tableview&quot;&gt;의 TableView를&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="3c6fac845a7634fec0e13fe47197c8ace4d55b89" translate="yes" xml:space="preserve">
          <source>A Instantiator can be used to control the dynamic creation of objects, or to dynamically create multiple objects from a template.</source>
          <target state="translated">Instantiator를 사용하여 객체의 동적 생성을 제어하거나 템플릿에서 여러 객체를 동적으로 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e8e96555e019a1da02432108906c1dd923ed7a0e" translate="yes" xml:space="preserve">
          <source>A JSON array is a list of values. The list can be manipulated by inserting and removing &lt;a href=&quot;qjsonvalue&quot;&gt;QJsonValue&lt;/a&gt;'s from the array.</source>
          <target state="translated">JSON 배열은 값 목록입니다. 배열에서 &lt;a href=&quot;qjsonvalue&quot;&gt;QJsonValue&lt;/a&gt; 를 삽입하고 제거하여 목록을 조작 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="895335865b457e39a7c4665829b4e5db7995a49a" translate="yes" xml:space="preserve">
          <source>A JSON document can be converted from its text-based representation to a &lt;a href=&quot;qjsondocument&quot;&gt;QJsonDocument&lt;/a&gt; using &lt;a href=&quot;qjsondocument#fromJson&quot;&gt;QJsonDocument::fromJson&lt;/a&gt;(). &lt;a href=&quot;qjsondocument#toJson&quot;&gt;toJson&lt;/a&gt;() converts it back to text. The parser is very fast and efficient and converts the JSON to the binary representation used by Qt.</source>
          <target state="translated">&lt;a href=&quot;qjsondocument#fromJson&quot;&gt;QJsonDocument :: fromJson&lt;/a&gt; ()을 사용하여 JSON 문서를 텍스트 기반 표현에서 &lt;a href=&quot;qjsondocument&quot;&gt;QJsonDocument&lt;/a&gt; 로 변환 할 수 있습니다 . &lt;a href=&quot;qjsondocument#toJson&quot;&gt;toJson&lt;/a&gt; ()은 다시 텍스트로 변환합니다. 파서는 매우 빠르고 효율적이며 JSON을 Qt에서 사용하는 이진 표현으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="1c30d361f63c33b669c83dda652bea2839a0adc2" translate="yes" xml:space="preserve">
          <source>A JSON document can be converted from its text-based representation to a QJsonDocument using &lt;a href=&quot;qjsondocument#fromJson&quot;&gt;QJsonDocument::fromJson&lt;/a&gt;(). &lt;a href=&quot;qjsondocument#toJson&quot;&gt;toJson&lt;/a&gt;() converts it back to text. The parser is very fast and efficient and converts the JSON to the binary representation used by Qt.</source>
          <target state="translated">JSON 문서는 &lt;a href=&quot;qjsondocument#fromJson&quot;&gt;QJsonDocument :: fromJson&lt;/a&gt; ()을 사용하여 텍스트 기반 표현에서 QJsonDocument로 변환 할 수 있습니다 . &lt;a href=&quot;qjsondocument#toJson&quot;&gt;toJson&lt;/a&gt; ()은 그것을 다시 텍스트로 변환합니다. 파서는 매우 빠르고 효율적이며 JSON을 Qt에서 사용하는 바이너리 표현으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="ce75b69642a02c35cf596b9ea912be38b2c22a7e" translate="yes" xml:space="preserve">
          <source>A JSON object is a list of key value pairs, where the keys are unique strings and the values are represented by a &lt;a href=&quot;qjsonvalue&quot;&gt;QJsonValue&lt;/a&gt;.</source>
          <target state="translated">JSON 객체는 키 값 쌍의 목록으로, 키는 고유 한 문자열이며 값은 &lt;a href=&quot;qjsonvalue&quot;&gt;QJsonValue&lt;/a&gt; 로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="16b5647424b7ed7669496c2a6a4f52200c911e69" translate="yes" xml:space="preserve">
          <source>A JavaScript alert dialog.</source>
          <target state="translated">JavaScript 경고 대화 상자</target>
        </trans-unit>
        <trans-unit id="3ab3126feaa317be32c45e104127998e4494c996" translate="yes" xml:space="preserve">
          <source>A JavaScript confirmation dialog.</source>
          <target state="translated">JavaScript 확인 ​​대화 상자</target>
        </trans-unit>
        <trans-unit id="4e11f677df78ac281ab1d154abc86bbda4b8aa1e" translate="yes" xml:space="preserve">
          <source>A JavaScript expression which describes a property's relationship with other properties. The variables in this expression are called the property's</source>
          <target state="translated">다른 속성과 속성의 관계를 설명하는 JavaScript 식입니다. 이 표현식의 변수를 속성의</target>
        </trans-unit>
        <trans-unit id="5b287935a6a5adabd58ebe90cc1e40c6f4ecf36e" translate="yes" xml:space="preserve">
          <source>A JavaScript prompt dialog.</source>
          <target state="translated">자바 스크립트 프롬프트 대화 상자.</target>
        </trans-unit>
        <trans-unit id="d2b4a7aa2d583703bc5bcf321c1920d7fd512bf9" translate="yes" xml:space="preserve">
          <source>A JavaScript resource declaration allows a JavaScript file to be exposed via the given identifier.</source>
          <target state="translated">JavaScript 리소스 선언을 사용하면 지정된 식별자를 통해 JavaScript 파일을 노출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="719abd787e129f7f89b0edd4e3692ca6877e8b05" translate="yes" xml:space="preserve">
          <source>A JavaScript resource may import a QML module in the following fashion:</source>
          <target state="translated">자바 스크립트 리소스는 다음과 같은 방식으로 QML 모듈을 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9aa5ef85c4c42a4fb9d1dc02522beeac80b86dd" translate="yes" xml:space="preserve">
          <source>A JavaScript resource may import another in the following fashion:</source>
          <target state="translated">JavaScript 리소스는 다음과 같은 방식으로 다른 리소스를 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a12791c6efb4ed0abf0664edb3af08a515d3af0" translate="yes" xml:space="preserve">
          <source>A JavaScriptDialogRequest is passed as an argument of the &lt;a href=&quot;qml-qtwebengine-webengineview#javaScriptDialogRequested-signal&quot;&gt;WebEngineView::javaScriptDialogRequested&lt;/a&gt; signal. The request is emitted if JavaScript on the page calls HTML5's &lt;a href=&quot;https://www.w3.org/TR/html5/webappapis.html#simple-dialogs&quot;&gt;Simple Dialogs&lt;/a&gt; API, or in response to HTML5's &lt;a href=&quot;https://www.w3.org/TR/html5/browsers.html#beforeunloadevent&quot;&gt;BeforeUnloadEvent&lt;/a&gt;. The type of a particular dialog can be checked with the &lt;a href=&quot;qml-qtwebengine-javascriptdialogrequest#type-prop&quot;&gt;type&lt;/a&gt; property.</source>
          <target state="translated">JavaScriptDialogRequest는 &lt;a href=&quot;qml-qtwebengine-webengineview#javaScriptDialogRequested-signal&quot;&gt;WebEngineView :: javaScriptDialogRequested&lt;/a&gt; 신호 의 인수로 전달됩니다 . 페이지의 JavaScript가 HTML5의 &lt;a href=&quot;https://www.w3.org/TR/html5/webappapis.html#simple-dialogs&quot;&gt;Simple Dialogs&lt;/a&gt; API를 호출 하거나 HTML5의 &lt;a href=&quot;https://www.w3.org/TR/html5/browsers.html#beforeunloadevent&quot;&gt;BeforeUnloadEvent&lt;/a&gt; 에 대한 응답으로 요청이 생성 됩니다. 특정 대화 상자의 &lt;a href=&quot;qml-qtwebengine-javascriptdialogrequest#type-prop&quot;&gt;유형&lt;/a&gt; 은 type 속성 으로 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fe92a4f69822a931eaaf7bea7023af9e3881f61a" translate="yes" xml:space="preserve">
          <source>A KeyframeAnimation type implements simple keyframe animation that can be used to animate &lt;a href=&quot;qml-qt3d-core-transform&quot;&gt;Transform&lt;/a&gt;. The keyframes consists of multiple timed &lt;a href=&quot;qml-qt3d-core-transform&quot;&gt;Qt3D.Core::Transform&lt;/a&gt;s, which are interpolated and applied to the target Transform. EasingCurve is used between keyframes to control the interpolator. RepeatMode can be set for when the position set to the KeyframeAnimation is less or or greater than the values defined in the keyframe positions.</source>
          <target state="translated">KeyframeAnimation 유형은 &lt;a href=&quot;qml-qt3d-core-transform&quot;&gt;Transform&lt;/a&gt; 에 애니메이션을 적용하는 데 사용할 수있는 간단한 키 프레임 애니메이션을 구현합니다 . 키 프레임은 여러 개의 시간이 지정된 &lt;a href=&quot;qml-qt3d-core-transform&quot;&gt;Qt3D.Core :: Transform&lt;/a&gt; 으로 구성되며 보간되고 대상 Transform에 적용됩니다. EasingCurve는 키 프레임 사이에서 보간기를 제어하는 ​​데 사용됩니다. RepeatMode는 KeyframeAnimation에 설정된 위치가 키 프레임 위치에 정의 된 값보다 작거나 클 때 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3213969583f1fc21e8fd7c9884919c4656073d45" translate="yes" xml:space="preserve">
          <source>A Layer can be applied to a subtree of entities by setting the recursive property to true.</source>
          <target state="translated">재귀 속성을 true로 설정하여 항목의 하위 트리에 레이어를 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="638a072713a4ee8e418d2d4aeea425cccc4ba963" translate="yes" xml:space="preserve">
          <source>A LayerFilter can be used to instruct the renderer as to which layer(s) to draw in that branch of the frame graph. The LayerFilter selects which entities to draw based on the &lt;a href=&quot;qml-qt3d-render-layer&quot;&gt;Layer&lt;/a&gt; instances added to the LayerFilter and as components to the &lt;a href=&quot;qml-qt3d-core-entity&quot;&gt;Entity&lt;/a&gt;.</source>
          <target state="translated">LayerFilter는 프레임 그래프의 해당 분기에 그릴 레이어를 렌더러에 지시하는 데 사용할 수 있습니다. LayerFilter는 LayerFilter에 추가되고 &lt;a href=&quot;qml-qt3d-core-entity&quot;&gt;Entity&lt;/a&gt; 에 대한 구성 요소로 추가 된 &lt;a href=&quot;qml-qt3d-render-layer&quot;&gt;Layer&lt;/a&gt; 인스턴스를 기반으로 그릴 엔티티를 선택합니다 .</target>
        </trans-unit>
        <trans-unit id="361b208bd75d822a2f5fe5e72d24943dc737c078" translate="yes" xml:space="preserve">
          <source>A LevelOfDetailLoader will load the entity matching the &lt;a href=&quot;qml-qt3d-render-levelofdetail#currentIndex-prop&quot;&gt;LevelOfDetail::currentIndex&lt;/a&gt;. The source is selected from the &lt;a href=&quot;qml-qt3d-render-levelofdetailloader#sources-prop&quot;&gt;sources&lt;/a&gt; property.</source>
          <target state="translated">LevelOfDetailLoader는 &lt;a href=&quot;qml-qt3d-render-levelofdetail#currentIndex-prop&quot;&gt;LevelOfDetail :: currentIndex와&lt;/a&gt; 일치하는 엔티티를로드합니다 . 소스는 &lt;a href=&quot;qml-qt3d-render-levelofdetailloader#sources-prop&quot;&gt;sources&lt;/a&gt; 속성 에서 선택 됩니다.</target>
        </trans-unit>
        <trans-unit id="44d5f93f2801d53b539644208ab07ee523146690" translate="yes" xml:space="preserve">
          <source>A ListView displays data from models created from built-in QML types like &lt;a href=&quot;qml-qtqml-models-listmodel&quot;&gt;ListModel&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-xmllistmodel-xmllistmodel&quot;&gt;XmlListModel&lt;/a&gt;, or custom model classes defined in C++ that inherit from &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; or &lt;a href=&quot;qabstractlistmodel&quot;&gt;QAbstractListModel&lt;/a&gt;.</source>
          <target state="translated">내장 같은 QML 유형에서 작성된 모델에서리스트 뷰 데이터를 표시 &lt;a href=&quot;qml-qtqml-models-listmodel&quot;&gt;하는 ListModel&lt;/a&gt; 와 &lt;a href=&quot;qml-qtquick-xmllistmodel-xmllistmodel&quot;&gt;XmlListModel&lt;/a&gt; C에 정의 된, 또는 사용자 정의 모델 클래스 ++에서 상속 &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; 또는 &lt;a href=&quot;qabstractlistmodel&quot;&gt;QAbstractListModel&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7edaaad3617cf57076b44a46d8467db19d8af38f" translate="yes" xml:space="preserve">
          <source>A ListView displays data from models created from built-in QML types like &lt;a href=&quot;qml-qtqml-models-listmodel&quot;&gt;ListModel&lt;/a&gt; and XmlListModel, or custom model classes defined in C++ that inherit from &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; or &lt;a href=&quot;qabstractlistmodel&quot;&gt;QAbstractListModel&lt;/a&gt;.</source>
          <target state="translated">내장 같은 QML 유형에서 작성된 모델에서리스트 뷰 데이터를 표시 &lt;a href=&quot;qml-qtqml-models-listmodel&quot;&gt;하는 ListModel&lt;/a&gt; C에 정의 XmlListModel, 또는 사용자 정의 모델 클래스 ++에서 상속 &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; 또는 &lt;a href=&quot;qabstractlistmodel&quot;&gt;QAbstractListModel&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b22b02a06d4be84623b6712c8cf0e52ef93787ae" translate="yes" xml:space="preserve">
          <source>A ListView has a &lt;a href=&quot;qml-qtquick-listview#model-prop&quot;&gt;model&lt;/a&gt;, which defines the data to be displayed, and a &lt;a href=&quot;qml-qtquick-listview#delegate-prop&quot;&gt;delegate&lt;/a&gt;, which defines how the data should be displayed. Items in a ListView are laid out horizontally or vertically. List views are inherently flickable because ListView inherits from &lt;a href=&quot;qml-qtquick-flickable&quot;&gt;Flickable&lt;/a&gt;.</source>
          <target state="translated">ListView에는 표시 할 데이터를 정의 하는 &lt;a href=&quot;qml-qtquick-listview#model-prop&quot;&gt;model&lt;/a&gt; 과 데이터를 표시 하는 방법을 정의하는 &lt;a href=&quot;qml-qtquick-listview#delegate-prop&quot;&gt;대리자&lt;/a&gt; 가 있습니다. ListView의 항목은 가로 또는 세로로 배치됩니다. ListView는 &lt;a href=&quot;qml-qtquick-flickable&quot;&gt;Flickable&lt;/a&gt; 에서 상속되기 때문에 목록보기는 본질적으로 플리 킹 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="7d87ce26e09779ef1386e18c5162ada42c7d75cc" translate="yes" xml:space="preserve">
          <source>A MapGestureArea is automatically created with a new Map and available with the &lt;a href=&quot;qml-qtlocation-map#gesture-prop&quot;&gt;gesture&lt;/a&gt; property. This is the only way to create a MapGestureArea, and once created this way cannot be destroyed without its parent Map.</source>
          <target state="translated">MapGestureArea는 새지도를 사용하여 자동으로 생성되고 &lt;a href=&quot;qml-qtlocation-map#gesture-prop&quot;&gt;제스처&lt;/a&gt; 속성으로 사용할 수 있습니다 . 이것은 MapGestureArea를 생성하는 유일한 방법이며, 이렇게 생성 된 후에는 부모 맵 없이는 파괴 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="593da9a58c8bf45fa163fc63c5e1c31a8c6bea2d" translate="yes" xml:space="preserve">
          <source>A MemoryBarrier FrameGraph node is used to emplace a specific memory barrier at a specific time of the rendering. This is required to properly synchronize drawing and compute commands on the GPU.</source>
          <target state="translated">MemoryBarrier FrameGraph 노드는 렌더링의 특정 시간에 특정 메모리 장벽을 배치하는 데 사용됩니다. 이는 GPU에서 드로잉 및 컴퓨팅 명령을 올바르게 동기화하는 데 필요합니다.</target>
        </trans-unit>
        <trans-unit id="e25f98cef9370fb9a4796233ae508ba2afa7b54e" translate="yes" xml:space="preserve">
          <source>A MessageDialog window is automatically transient for its parent window. So whether you declare the dialog inside an &lt;a href=&quot;qml-qtquick-item&quot;&gt;Item&lt;/a&gt; or inside a &lt;a href=&quot;qml-qtquick-window-window&quot;&gt;Window&lt;/a&gt;, the dialog will appear centered over the window containing the item, or over the Window that you declared.</source>
          <target state="translated">MessageDialog 창은 부모 창에 대해 자동으로 일시적입니다. 따라서 &lt;a href=&quot;qml-qtquick-item&quot;&gt;Item&lt;/a&gt; 내부 또는 &lt;a href=&quot;qml-qtquick-window-window&quot;&gt;Window&lt;/a&gt; 내부에서 대화를 선언하는지 여부에 관계없이 대화 상자는 항목이 포함 된 창 또는 선언 한 창 중앙에 나타납니다.</target>
        </trans-unit>
        <trans-unit id="f1a62c8aee42c2e3c9bad30ab5580ec78d32034d" translate="yes" xml:space="preserve">
          <source>A Meta key on the keyboard is pressed.</source>
          <target state="translated">키보드의 메타 키를 눌렀습니다.</target>
        </trans-unit>
        <trans-unit id="6fb53291a08e1f4f0a55f3a36c8fb9e4906a70de" translate="yes" xml:space="preserve">
          <source>A Meta key on the keyboard must be pressed.</source>
          <target state="translated">키보드의 Meta 키를 눌러야합니다.</target>
        </trans-unit>
        <trans-unit id="27069dc7df959b835081dd6f0cd3fd15318f6337" translate="yes" xml:space="preserve">
          <source>A Metal-based QRhi needs no special parameters for initialization.</source>
          <target state="translated">Metal 기반 QRhi는 초기화를위한 특별한 매개 변수가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a7e92cf9e5d4cba56606e15ecad9e635b183bf51" translate="yes" xml:space="preserve">
          <source>A Mifare target.</source>
          <target state="translated">Mifare 대상.</target>
        </trans-unit>
        <trans-unit id="37f7a301d4eaf4061408a24e906f898ac9485c9a" translate="yes" xml:space="preserve">
          <source>A Minimal qdocconf File</source>
          <target state="translated">최소 qdocconf 파일</target>
        </trans-unit>
        <trans-unit id="3d63e3142a7bbaae16dd36374e3714b7cee34acd" translate="yes" xml:space="preserve">
          <source>A Modbus request usually consists of a single byte describing the &lt;code&gt;FunctionCode&lt;/code&gt; and N bytes of payload</source>
          <target state="translated">Modbus 요청은 일반적으로 &lt;code&gt;FunctionCode&lt;/code&gt; 를 설명하는 단일 바이트 와 페이로드의 N 바이트 로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="e4e0bb40d65b1adef35f30fb4ede4fc0ea2f0df2" translate="yes" xml:space="preserve">
          <source>A Modbus specific protocol error occurred.</source>
          <target state="translated">Modbus 특정 프로토콜 오류가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="7f33fd40b209888d5ecdcf01af8d0c06efafa0c3" translate="yes" xml:space="preserve">
          <source>A MorphTarget type is a convenience type, which provides a list of &lt;a href=&quot;qml-qt3d-core-attribute&quot;&gt;Attributes&lt;/a&gt;, which the &lt;a href=&quot;qml-qt3d-animation-morphinganimation&quot;&gt;MorphingAnimation&lt;/a&gt; uses to animate geometry. A MorphTarget can also be created based on existing &lt;a href=&quot;qml-qt3d-core-geometry&quot;&gt;Geometry&lt;/a&gt;.</source>
          <target state="translated">MorphTarget 유형은 &lt;a href=&quot;qml-qt3d-animation-morphinganimation&quot;&gt;MorphingAnimation이&lt;/a&gt; 지오메트리를 애니메이션하는 데 사용 하는 &lt;a href=&quot;qml-qt3d-core-attribute&quot;&gt;Attributes&lt;/a&gt; 목록을 제공하는 편리한 유형 입니다. MorphTarget은 기존 &lt;a href=&quot;qml-qt3d-core-geometry&quot;&gt;Geometry를&lt;/a&gt; 기반으로 생성 될 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="000174e8a40e9b4df53cce097f81ae450dbb27e6" translate="yes" xml:space="preserve">
          <source>A MorphTarget type is a convenience type, which provides a list of &lt;a href=&quot;qml-qt3d-render-attribute&quot;&gt;Attributes&lt;/a&gt;, which the &lt;a href=&quot;qml-qt3d-animation-morphinganimation&quot;&gt;MorphingAnimation&lt;/a&gt; uses to animate geometry. A MorphTarget can also be created based on existing &lt;a href=&quot;qml-qt3d-render-geometry&quot;&gt;Geometry&lt;/a&gt;.</source>
          <target state="translated">MorphTarget 유형은 &lt;a href=&quot;qml-qt3d-animation-morphinganimation&quot;&gt;MorphingAnimation이&lt;/a&gt; 지오메트리를 애니메이션하는 데 사용 하는 &lt;a href=&quot;qml-qt3d-render-attribute&quot;&gt;Attributes&lt;/a&gt; 목록을 제공하는 편리한 유형 입니다. MorphTarget은 기존 &lt;a href=&quot;qml-qt3d-render-geometry&quot;&gt;Geometry를&lt;/a&gt; 기반으로 만들 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e1f7019a0cd9f18a8acfe46aad3a9e8c87f81267" translate="yes" xml:space="preserve">
          <source>A MorphingAnimation type implements blend-shape morphing animation to a target &lt;a href=&quot;qt3drender-geometry#geometryrenderer&quot;&gt;GeometryRenderer&lt;/a&gt;. The MorphingAnimation sets the correct &lt;a href=&quot;qt3drender-geometry#attribute&quot;&gt;Attributes&lt;/a&gt; from the morph targets to the target &lt;a href=&quot;qml-qt3d-render-geometryrenderer#geometry-prop&quot;&gt;GeometryRenderer::geometry&lt;/a&gt; and calculates interpolator for the current position. The actual blending between the attributes must be implemented in the material. MorphPhongMaterial implements material with morphing support for phong lighting model. The blending happens between 2 attributes - 'base' and 'target'. The names for the base and target attributes are taken from the morph target names, where the base attribute retains the name it already has and the target attribute name gets 'Target' appended to the name. All morph targets in the animation should contain the attributes with same names as those in the base geometry.</source>
          <target state="translated">MorphingAnimation 유형은 대상 &lt;a href=&quot;qt3drender-geometry#geometryrenderer&quot;&gt;GeometryRenderer에&lt;/a&gt; 블렌드 셰이프 모핑 애니메이션을 구현 합니다. MorphingAnimation 은 모프 타겟 의 올바른 &lt;a href=&quot;qt3drender-geometry#attribute&quot;&gt;속성&lt;/a&gt; 을 타겟 &lt;a href=&quot;qml-qt3d-render-geometryrenderer#geometry-prop&quot;&gt;GeometryRenderer :: geometry로 설정합니다.&lt;/a&gt;그리고 현재 위치에 대한 보간기를 계산합니다. 속성 간의 실제 혼합은 재료에서 구현되어야합니다. MorphPhongMaterial은 퐁 조명 모델에 대한 모핑 지원을 사용하여 재질을 구현합니다. 블렌딩은 'base'와 'target'의 두 가지 속성 사이에서 발생합니다. 기본 및 대상 속성의 이름은 모프 대상 이름에서 가져옵니다. 여기서 기본 속성은 이미 가지고있는 이름을 유지하고 대상 속성 이름은 이름에 'Target'이 추가됩니다. 애니메이션의 모든 모프 타겟에는 기본 지오메트리에있는 것과 이름이 같은 속성이 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="a29cce0af05ab1a4914d0686b3293b68dd4e5843" translate="yes" xml:space="preserve">
          <source>A MouseArea is an invisible item that is typically used in conjunction with a visible item in order to provide mouse handling for that item. By effectively acting as a proxy, the logic for mouse handling can be contained within a MouseArea item.</source>
          <target state="translated">MouseArea는 일반적으로 해당 항목에 대한 마우스 처리를 제공하기 위해 보이는 항목과 함께 사용되는 보이지 않는 항목입니다. 프록시 역할을 효과적으로 수행함으로써 마우스 처리 로직을 MouseArea 항목에 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a49d2efd4acb7e8df990f5aa398f914c3ebafbf9" translate="yes" xml:space="preserve">
          <source>A MouseDevice delegates mouse events from physical mouse device to &lt;a href=&quot;qml-qt3d-input-mousehandler&quot;&gt;MouseHandler&lt;/a&gt; objects. The sensitivity of the mouse can be controlled with the &lt;a href=&quot;qml-qt3d-input-mousedevice#sensitivity-prop&quot;&gt;MouseDevice::sensitivity&lt;/a&gt; property, which specifies the rate in which the logical mouse coordinates change in response to physical movement of the mouse.</source>
          <target state="translated">MouseDevice는 물리적 마우스 장치의 마우스 이벤트를 &lt;a href=&quot;qml-qt3d-input-mousehandler&quot;&gt;MouseHandler&lt;/a&gt; 객체에 위임 합니다. 마우스의 민감도는 &lt;a href=&quot;qml-qt3d-input-mousedevice#sensitivity-prop&quot;&gt;MouseDevice :: sensitivity&lt;/a&gt; 속성 으로 제어 할 수 있습니다.이 속성은 마우스의 물리적 움직임에 따라 논리적 마우스 좌표가 변경되는 속도를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="90ced844949f1162ebdd89cbac1174f683903ab7" translate="yes" xml:space="preserve">
          <source>A Multi Viewport FrameGraph</source>
          <target state="translated">다중 뷰포트 프레임</target>
        </trans-unit>
        <trans-unit id="943be587ae4e8ac92225f9c907863886d3ac5c8f" translate="yes" xml:space="preserve">
          <source>A MultiPointTouchArea is an invisible item that is used to track multiple touch points.</source>
          <target state="translated">MultiPointTouchArea는 여러 터치 포인트를 추적하는 데 사용되는 보이지 않는 항목입니다.</target>
        </trans-unit>
        <trans-unit id="808864fdafd7fd49b8d0d51af1b33835d379baea" translate="yes" xml:space="preserve">
          <source>A MultiSampleAntiAliasing type enables multisample antialiasing.</source>
          <target state="translated">MultiSampleAntiAliasing 유형은 다중 샘플 안티 앨리어싱을 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="d0adf3d3a90ef86a9aa4dd044edb94fa8dedd540" translate="yes" xml:space="preserve">
          <source>A NoDepthMask type disables fragment depth write to depth buffer.</source>
          <target state="translated">NoDepthMask 유형은 깊이 버퍼에 조각 깊이 쓰기를 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="b679d25fd28d569eef126683ff5a43df57d32f45" translate="yes" xml:space="preserve">
          <source>A Node does not have a url that other nodes can connect to, and thus is able to acquire replicas only. It is not able to share source objects.</source>
          <target state="translated">노드에는 다른 노드가 연결할 수있는 URL이 없으므로 복제본 만 얻을 수 있습니다. 소스 객체를 공유 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7dfcdfab23009b7337f9b32d68f33519cba48719" translate="yes" xml:space="preserve">
          <source>A NodeInstantiator can be used to control the dynamic creation of nodes, or to dynamically create multiple objects from a template.</source>
          <target state="translated">NodeInstantiator는 노드의 동적 생성을 제어하거나 템플릿에서 여러 개체를 동적으로 생성하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9eb45de1cb5275ec96a100314098ad48fd9f27f7" translate="yes" xml:space="preserve">
          <source>A Note About Accessing Attached Properties and Signal Handlers</source>
          <target state="translated">연결된 속성 및 신호 처리기 액세스에 대한 참고 사항</target>
        </trans-unit>
        <trans-unit id="0dde7956f78dcc3ffc4f86e5eb8cd52a3eeb334b" translate="yes" xml:space="preserve">
          <source>A Note for X11 Users</source>
          <target state="translated">X11 사용자를위한 참고 사항</target>
        </trans-unit>
        <trans-unit id="9d62cb028bc946f0de5fba86a93e8eb32c5fb41f" translate="yes" xml:space="preserve">
          <source>A Note on GUI Types</source>
          <target state="translated">GUI 유형에 대한 참고 사항</target>
        </trans-unit>
        <trans-unit id="8a7dbddcecedeae7ca85b8436433b9187bc690e5" translate="yes" xml:space="preserve">
          <source>A Null value</source>
          <target state="translated">널값</target>
        </trans-unit>
        <trans-unit id="388b764611680da0ff157c77367c9ef5b56efe1a" translate="yes" xml:space="preserve">
          <source>A PDF 1.4 compatible document is produced.</source>
          <target state="translated">PDF 1.4 호환 문서가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="6be8458e8da70b9585d213592e359deb6a5998ca" translate="yes" xml:space="preserve">
          <source>A PDF 1.6 compatible document is produced. This value was added in Qt 5.12.</source>
          <target state="translated">PDF 1.6 호환 문서가 생성됩니다. 이 값은 Qt 5.12에서 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="453b23bc8be051a0522d2abdae3d3e320599978c" translate="yes" xml:space="preserve">
          <source>A PDF/A-1b compatible document is produced.</source>
          <target state="translated">PDF / A-1b 호환 문서가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="4c6422c25ccbe1c5d95aaf89461f32d217aac687" translate="yes" xml:space="preserve">
          <source>A PDU is considered valid if the message code is in the range of 1 to 255 decimal and the PDU's compound size (function code + data) does not exceed 253 bytes. A default constructed PDU is invalid.</source>
          <target state="translated">메시지 코드가 10 진수 1-255 범위이고 PDU의 복합 크기 (함수 코드 + 데이터)가 253 바이트를 초과하지 않으면 PDU는 유효한 것으로 간주됩니다. 구성된 기본 PDU가 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="50e4e98dea9ff59b3de4ad7533fbd09b0f18e083" translate="yes" xml:space="preserve">
          <source>A Pan gesture.</source>
          <target state="translated">팬 제스처.</target>
        </trans-unit>
        <trans-unit id="3132a391c608fce93fb5e453f42d0920cfc89a15" translate="yes" xml:space="preserve">
          <source>A PaperSource defined by the printer that is unknown to Qt</source>
          <target state="translated">Qt에 알려지지 않은 프린터에 의해 정의 된 PaperSource</target>
        </trans-unit>
        <trans-unit id="7b2a4fbb37af10d05fe8dc1ed47c4610e2cdb181" translate="yes" xml:space="preserve">
          <source>A Parameter can be referenced by a &lt;a href=&quot;qml-qt3d-render-renderpass&quot;&gt;RenderPass&lt;/a&gt;, Technique, Effect, Material, &lt;a href=&quot;qml-qt3d-render-techniquefilter&quot;&gt;TechniqueFilter&lt;/a&gt;, &lt;a href=&quot;qml-qt3d-render-renderpassfilter&quot;&gt;RenderPassFilter&lt;/a&gt;. At runtime, depending on which shader is selected for a given step of the rendering, the value contained in a Parameter will be converted and uploaded if the shader contains a uniform with a name matching that of the Parameter.</source>
          <target state="translated">파라미터는 &lt;a href=&quot;qml-qt3d-render-renderpass&quot;&gt;RenderPass&lt;/a&gt; , Technique, Effect, Material, &lt;a href=&quot;qml-qt3d-render-techniquefilter&quot;&gt;TechniqueFilter&lt;/a&gt; , &lt;a href=&quot;qml-qt3d-render-renderpassfilter&quot;&gt;RenderPassFilter&lt;/a&gt; 로 참조 할 수 있습니다 . 런타임에 주어진 렌더링 단계에 대해 선택된 쉐이더에 따라 쉐이더에 매개 변수의 이름과 일치하는 유니폼이 포함되어 있으면 매개 변수에 포함 된 값이 변환되어 업로드됩니다.</target>
        </trans-unit>
        <trans-unit id="660b4cd64fd9b8d39121ea3a13aea924fab87bda" translate="yes" xml:space="preserve">
          <source>A Parameter defined on a Material is overridden by a Parameter (of the same name) defined in a &lt;a href=&quot;qml-qt3d-render-techniquefilter&quot;&gt;TechniqueFilter&lt;/a&gt; or a &lt;a href=&quot;qml-qt3d-render-renderpassfilter&quot;&gt;RenderPassFilter&lt;/a&gt;.</source>
          <target state="translated">머티리얼에 정의 된 매개 변수는 &lt;a href=&quot;qml-qt3d-render-techniquefilter&quot;&gt;TechniqueFilter&lt;/a&gt; 또는 &lt;a href=&quot;qml-qt3d-render-renderpassfilter&quot;&gt;RenderPassFilter에&lt;/a&gt; 정의 된 매개 변수 (동일한 이름)로 대체됩니다 .</target>
        </trans-unit>
        <trans-unit id="45f1375d6118f9d2eb91810f33ff3d5396cd10a8" translate="yes" xml:space="preserve">
          <source>A Parameter defined on an Effect is overridden by a QParameter (of the same name) defined in a Material, &lt;a href=&quot;qml-qt3d-render-techniquefilter&quot;&gt;TechniqueFilter&lt;/a&gt;, &lt;a href=&quot;qml-qt3d-render-renderpassfilter&quot;&gt;RenderPassFilter&lt;/a&gt;.</source>
          <target state="translated">Effect에 정의 된 Parameter는 Material, &lt;a href=&quot;qml-qt3d-render-techniquefilter&quot;&gt;TechniqueFilter&lt;/a&gt; , &lt;a href=&quot;qml-qt3d-render-renderpassfilter&quot;&gt;RenderPassFilter에&lt;/a&gt; 정의 된 QParameter (동일한 이름)로 대체됩니다 .</target>
        </trans-unit>
        <trans-unit id="c31e4d18e095cc412240ea61504728a430c10d82" translate="yes" xml:space="preserve">
          <source>A ParentAnimation can contain any number of animations. These animations will be run in parallel; to run them sequentially, define them within a &lt;a href=&quot;qml-qtquick-sequentialanimation&quot;&gt;SequentialAnimation&lt;/a&gt;.</source>
          <target state="translated">ParentAnimation은 여러 애니메이션을 포함 할 수 있습니다. 이러한 애니메이션은 병렬로 실행됩니다. 순차적으로 실행하려면 &lt;a href=&quot;qml-qtquick-sequentialanimation&quot;&gt;SequentialAnimation&lt;/a&gt; 내에서 정의하십시오 .</target>
        </trans-unit>
        <trans-unit id="314d0c1f487b3a8f317c948d692cde6bb749f6e4" translate="yes" xml:space="preserve">
          <source>A Path is composed of one or more path segments - &lt;a href=&quot;qml-qtquick-pathline&quot;&gt;PathLine&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-pathpolyline&quot;&gt;PathPolyline&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-pathquad&quot;&gt;PathQuad&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-pathcubic&quot;&gt;PathCubic&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-patharc&quot;&gt;PathArc&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-pathanglearc&quot;&gt;PathAngleArc&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-pathcurve&quot;&gt;PathCurve&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-pathsvg&quot;&gt;PathSvg&lt;/a&gt;.</source>
          <target state="translated">Path는 &lt;a href=&quot;qml-qtquick-pathline&quot;&gt;PathLine&lt;/a&gt; , &lt;a href=&quot;qml-qtquick-pathpolyline&quot;&gt;PathPolyline&lt;/a&gt; , &lt;a href=&quot;qml-qtquick-pathquad&quot;&gt;PathQuad&lt;/a&gt; , &lt;a href=&quot;qml-qtquick-pathcubic&quot;&gt;PathCubic&lt;/a&gt; , &lt;a href=&quot;qml-qtquick-patharc&quot;&gt;PathArc&lt;/a&gt; , &lt;a href=&quot;qml-qtquick-pathanglearc&quot;&gt;PathAngleArc&lt;/a&gt; , &lt;a href=&quot;qml-qtquick-pathcurve&quot;&gt;PathCurve&lt;/a&gt; , &lt;a href=&quot;qml-qtquick-pathsvg&quot;&gt;PathSvg&lt;/a&gt; 와 같은 하나 이상의 경로 세그먼트로 구성 됩니다.</target>
        </trans-unit>
        <trans-unit id="7cb72163aa0828179ebde19a5d52aab2e94dc8b4" translate="yes" xml:space="preserve">
          <source>A Path is composed of one or more path segments - &lt;a href=&quot;qml-qtquick-pathline&quot;&gt;PathLine&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-pathquad&quot;&gt;PathQuad&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-pathcubic&quot;&gt;PathCubic&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-patharc&quot;&gt;PathArc&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-pathanglearc&quot;&gt;PathAngleArc&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-pathcurve&quot;&gt;PathCurve&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-pathsvg&quot;&gt;PathSvg&lt;/a&gt;.</source>
          <target state="translated">Path는 &lt;a href=&quot;qml-qtquick-pathline&quot;&gt;PathLine&lt;/a&gt; , &lt;a href=&quot;qml-qtquick-pathquad&quot;&gt;PathQuad&lt;/a&gt; , &lt;a href=&quot;qml-qtquick-pathcubic&quot;&gt;PathCubic&lt;/a&gt; , &lt;a href=&quot;qml-qtquick-patharc&quot;&gt;PathArc&lt;/a&gt; , &lt;a href=&quot;qml-qtquick-pathanglearc&quot;&gt;PathAngleArc&lt;/a&gt; , &lt;a href=&quot;qml-qtquick-pathcurve&quot;&gt;PathCurve&lt;/a&gt; , &lt;a href=&quot;qml-qtquick-pathsvg&quot;&gt;PathSvg&lt;/a&gt; 와 같은 하나 이상의 경로 세그먼트로 구성 됩니다.</target>
        </trans-unit>
        <trans-unit id="f7f0b19150b19ecfde7b2b3b7d59fe4dba2e66f8" translate="yes" xml:space="preserve">
          <source>A PathView displays data from models created from built-in QML types like &lt;a href=&quot;qml-qtqml-models-listmodel&quot;&gt;ListModel&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-xmllistmodel-xmllistmodel&quot;&gt;XmlListModel&lt;/a&gt;, or custom model classes defined in C++ that inherit from &lt;a href=&quot;qabstractlistmodel&quot;&gt;QAbstractListModel&lt;/a&gt;.</source>
          <target state="translated">PathView는 &lt;a href=&quot;qml-qtqml-models-listmodel&quot;&gt;ListModel&lt;/a&gt; 및 &lt;a href=&quot;qml-qtquick-xmllistmodel-xmllistmodel&quot;&gt;XmlListModel&lt;/a&gt; 과 같은 내장 QML 유형 또는 &lt;a href=&quot;qabstractlistmodel&quot;&gt;QAbstractListModel&lt;/a&gt; 에서 상속 된 C ++로 정의 된 사용자 정의 모델 클래스 에서 생성 된 모델의 데이터를 표시합니다 .</target>
        </trans-unit>
        <trans-unit id="bab1802e2dc994262e642cddf24a47b87b47c0a8" translate="yes" xml:space="preserve">
          <source>A PathView displays data from models created from built-in QML types like &lt;a href=&quot;qml-qtqml-models-listmodel&quot;&gt;ListModel&lt;/a&gt; and XmlListModel, or custom model classes defined in C++ that inherit from &lt;a href=&quot;qabstractlistmodel&quot;&gt;QAbstractListModel&lt;/a&gt;.</source>
          <target state="translated">PathView는 &lt;a href=&quot;qml-qtqml-models-listmodel&quot;&gt;ListModel&lt;/a&gt; 및 XmlListModel 과 같은 내장 QML 유형 또는 &lt;a href=&quot;qabstractlistmodel&quot;&gt;QAbstractListModel&lt;/a&gt; 에서 상속 된 C ++로 정의 된 사용자 정의 모델 클래스 에서 생성 된 모델의 데이터를 표시합니다 .</target>
        </trans-unit>
        <trans-unit id="b1626d5d47b178d2a836026f3584b5e52f81e9c0" translate="yes" xml:space="preserve">
          <source>A Pinch gesture.</source>
          <target state="translated">핀치 제스처.</target>
        </trans-unit>
        <trans-unit id="9b15701cccb23f11375c8c7172814693a5b90ce0" translate="yes" xml:space="preserve">
          <source>A PinchArea is an invisible item that is typically used in conjunction with a visible item in order to provide pinch gesture handling for that item.</source>
          <target state="translated">PinchArea는 일반적으로 해당 항목에 핀치 제스처 처리를 제공하기 위해 표시되는 항목과 함께 사용되는 보이지 않는 항목입니다.</target>
        </trans-unit>
        <trans-unit id="4b7fa55f63f41105cdb01d6362b0a4918fa5095d" translate="yes" xml:space="preserve">
          <source>A Place is almost always tied to a &lt;a href=&quot;location-places-qml#plugin&quot;&gt;plugin&lt;/a&gt;. The &lt;a href=&quot;location-places-qml#plugin&quot;&gt;plugin&lt;/a&gt; property must be set before it is possible to call &lt;a href=&quot;qml-qtlocation-place#save-method&quot;&gt;save()&lt;/a&gt;, &lt;a href=&quot;qml-qtlocation-place#remove-method&quot;&gt;remove()&lt;/a&gt; or &lt;a href=&quot;qml-qtlocation-place#getDetails-method&quot;&gt;getDetails()&lt;/a&gt;. The &lt;a href=&quot;qml-qtlocation-place#reviewModel-prop&quot;&gt;reviewModel&lt;/a&gt;, &lt;a href=&quot;qml-qtlocation-place#imageModel-prop&quot;&gt;imageModel&lt;/a&gt; and &lt;a href=&quot;qml-qtlocation-place#editorialModel-prop&quot;&gt;editorialModel&lt;/a&gt; are only valid then the &lt;a href=&quot;location-places-qml#plugin&quot;&gt;plugin&lt;/a&gt; property is set.</source>
          <target state="translated">장소는 거의 항상 &lt;a href=&quot;location-places-qml#plugin&quot;&gt;플러그인&lt;/a&gt; 과 연결되어 있습니다 . &lt;a href=&quot;location-places-qml#plugin&quot;&gt;플러그인&lt;/a&gt; 이 호출 할 수 있습니다 전에 속성 설정을해야합니다 &lt;a href=&quot;qml-qtlocation-place#save-method&quot;&gt;() 저장&lt;/a&gt; , &lt;a href=&quot;qml-qtlocation-place#remove-method&quot;&gt;삭제 ()&lt;/a&gt; 또는 &lt;a href=&quot;qml-qtlocation-place#getDetails-method&quot;&gt;getDetails ()&lt;/a&gt; . &lt;a href=&quot;qml-qtlocation-place#reviewModel-prop&quot;&gt;reviewModel&lt;/a&gt; , &lt;a href=&quot;qml-qtlocation-place#imageModel-prop&quot;&gt;imageModel&lt;/a&gt; 및 &lt;a href=&quot;qml-qtlocation-place#editorialModel-prop&quot;&gt;editorialModel은&lt;/a&gt; 다음에만 유효 &lt;a href=&quot;location-places-qml#plugin&quot;&gt;플러그인&lt;/a&gt; 속성이 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="dd401aa8f180bf7d7a8b2e4ead964f82e9798ea7" translate="yes" xml:space="preserve">
          <source>A PointerEvent is an event describing contact or movement across a surface, provided by a mouse, a touchpoint (single finger on a touchscreen), or a stylus on a graphics tablet. The &lt;a href=&quot;qml-qtquick-pointerevent#device-prop&quot;&gt;device&lt;/a&gt; property provides more information about where the event came from.</source>
          <target state="translated">PointerEvent는 마우스, 터치 포인트 (터치 스크린의 한 손가락) 또는 그래픽 태블릿의 스타일러스가 제공하는 표면에서의 접촉 또는 이동을 설명하는 이벤트입니다. &lt;a href=&quot;qml-qtquick-pointerevent#device-prop&quot;&gt;장치&lt;/a&gt; 속성은 이벤트가 어디에서 왔는지에 대한 자세한 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="2e7d30ccbf4c2fcf11c629022afda01284b816f7" translate="yes" xml:space="preserve">
          <source>A PolygonOffset type adds an offset to the fragment depth value prior to depth test and depth write. The offset can be used to avoid z-fighting when rendering polygons with very close depth values such as decals.</source>
          <target state="translated">PolygonOffset 유형은 깊이 테스트 및 깊이 쓰기 전에 조각 깊이 값에 오프셋을 추가합니다. 오프셋은 데칼과 같이 깊이 값이 매우 가까운 다각형을 렌더링 할 때 z-fighting을 방지하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e1c0e159205316085f530e367ad021a46ea64074" translate="yes" xml:space="preserve">
          <source>A PropertyChanges object can also override the default signal handler for an object to implement a signal handler specific to the new state:</source>
          <target state="translated">PropertyChanges 객체는 객체의 기본 신호 처리기를 재정 의하여 새 상태에 특정한 신호 처리기를 구현할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="5fa4d344f1b2ee1eb1f2093b27eda3bce2c5ae8c" translate="yes" xml:space="preserve">
          <source>A Puck (a device that is similar to a flat mouse with a transparent circle with cross-hairs).</source>
          <target state="translated">퍽 (십자선이있는 투명한 원이있는 평면 마우스와 유사한 장치).</target>
        </trans-unit>
        <trans-unit id="8ac61a9e72ded6c9b30788599d739851110cbf40" translate="yes" xml:space="preserve">
          <source>A QAbstractItemDelegate provides the interface and common functionality for delegates in the model/view architecture. Delegates display individual items in views, and handle the editing of model data.</source>
          <target state="translated">QAbstractItemDelegate는 모델 / 뷰 아키텍처에서 델리게이트를위한 인터페이스와 공통 기능을 제공합니다. 대리인은보기에 개별 항목을 표시하고 모델 데이터 편집을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="c39af331fc76aae36f3ee1819306f14807d3cf03" translate="yes" xml:space="preserve">
          <source>A QAbstractTexture with a Target1D target format</source>
          <target state="translated">Target1D 대상 형식의 QAbstractTexture</target>
        </trans-unit>
        <trans-unit id="cc527b4ecef0b93b5743c6b4691ae35c9b17988c" translate="yes" xml:space="preserve">
          <source>A QAbstractTexture with a Target1DArray target format</source>
          <target state="translated">Target1DArray 대상 형식의 QAbstractTexture</target>
        </trans-unit>
        <trans-unit id="67f11b1698e0aa9fc08a1e9c64e9d56f14c5753e" translate="yes" xml:space="preserve">
          <source>A QAbstractTexture with a Target2D target format</source>
          <target state="translated">Target2D 대상 형식의 QAbstractTexture</target>
        </trans-unit>
        <trans-unit id="08720583737610faae1f65cf15b2df1a508f0ba6" translate="yes" xml:space="preserve">
          <source>A QAbstractTexture with a Target2DArray target format</source>
          <target state="translated">Target2DArray 대상 형식의 QAbstractTexture</target>
        </trans-unit>
        <trans-unit id="5497e7c3bdfe6b83397869bc9093e80690f3ae12" translate="yes" xml:space="preserve">
          <source>A QAbstractTexture with a Target2DMultisample target format</source>
          <target state="translated">Target2DMultisample 대상 형식의 QAbstractTexture</target>
        </trans-unit>
        <trans-unit id="bdba4836d483d64f42eb02562f61ac3c69221af6" translate="yes" xml:space="preserve">
          <source>A QAbstractTexture with a Target2DMultisampleArray target format</source>
          <target state="translated">Target2DMultisampleArray 대상 형식의 QAbstractTexture</target>
        </trans-unit>
        <trans-unit id="a191d78f82f2434e4a642ab8ab521b3db9e8b006" translate="yes" xml:space="preserve">
          <source>A QAbstractTexture with a Target3D target format</source>
          <target state="translated">Target3D 대상 형식의 QAbstractTexture</target>
        </trans-unit>
        <trans-unit id="136503d616e9218f60f67c75a0448ae81a497796" translate="yes" xml:space="preserve">
          <source>A QAbstractTexture with a TargetBuffer target format</source>
          <target state="translated">TargetBuffer 대상 형식의 QAbstractTexture</target>
        </trans-unit>
        <trans-unit id="19d6a95d0ea568213abe9f1858d0f4bca613db28" translate="yes" xml:space="preserve">
          <source>A QAbstractTexture with a TargetCubeMap target format</source>
          <target state="translated">TargetCubeMap 대상 형식의 QAbstractTexture</target>
        </trans-unit>
        <trans-unit id="5626e9e63a24fb26b692727552f4fa1116ad24be" translate="yes" xml:space="preserve">
          <source>A QAbstractTexture with a TargetCubeMapArray target format</source>
          <target state="translated">TargetCubeMapArray 대상 형식의 QAbstractTexture</target>
        </trans-unit>
        <trans-unit id="fee204d873e0cc13d1b61045879060dda8f67be2" translate="yes" xml:space="preserve">
          <source>A QAbstractTexture with a TargetRectangle target format</source>
          <target state="translated">TargetRectangle 대상 형식의 QAbstractTexture</target>
        </trans-unit>
        <trans-unit id="ab43479c8fa9c0bca07e52dcf88e33c95696c66d" translate="yes" xml:space="preserve">
          <source>A QAbstractTextureImage that can be written through a QPainter</source>
          <target state="translated">QPainter를 통해 작성할 수있는 QAbstractTextureImage</target>
        </trans-unit>
        <trans-unit id="37c318d6947de10612fea2697842fe5764efbcdc" translate="yes" xml:space="preserve">
          <source>A QAbstractXmlForwardIterator over &lt;a href=&quot;qxmlitem&quot;&gt;QXmlItem&lt;/a&gt;.</source>
          <target state="translated">위에 QAbstractXmlForwardIterator &lt;a href=&quot;qxmlitem&quot;&gt;QXmlItem&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="eb7b1603e1e2316373010cdffd595c33a37d4b20" translate="yes" xml:space="preserve">
          <source>A QAction may contain an icon, menu text, a shortcut, status text, &quot;What's This?&quot; text, and a tooltip. Most of these can be set in the constructor. They can also be set independently with &lt;a href=&quot;qaction#icon-prop&quot;&gt;setIcon&lt;/a&gt;(), &lt;a href=&quot;qaction#text-prop&quot;&gt;setText&lt;/a&gt;(), &lt;a href=&quot;qaction#iconText-prop&quot;&gt;setIconText&lt;/a&gt;(), &lt;a href=&quot;qaction#setShortcut&quot;&gt;setShortcut&lt;/a&gt;(), &lt;a href=&quot;qaction#statusTip-prop&quot;&gt;setStatusTip&lt;/a&gt;(), &lt;a href=&quot;qaction#whatsThis-prop&quot;&gt;setWhatsThis&lt;/a&gt;(), and &lt;a href=&quot;qaction#toolTip-prop&quot;&gt;setToolTip&lt;/a&gt;(). For menu items, it is possible to set an individual font with &lt;a href=&quot;qaction#font-prop&quot;&gt;setFont&lt;/a&gt;().</source>
          <target state="translated">QAction에는 아이콘, 메뉴 텍스트, 바로 가기, 상태 텍스트, &quot;What 's This?&quot;가 포함될 수 있습니다. 텍스트 및 도구 설명. 대부분은 생성자에서 설정할 수 있습니다. &lt;a href=&quot;qaction#icon-prop&quot;&gt;setIcon&lt;/a&gt; (), &lt;a href=&quot;qaction#text-prop&quot;&gt;setText&lt;/a&gt; (), &lt;a href=&quot;qaction#iconText-prop&quot;&gt;setIconText&lt;/a&gt; (), &lt;a href=&quot;qaction#setShortcut&quot;&gt;setShortcut&lt;/a&gt; (), &lt;a href=&quot;qaction#statusTip-prop&quot;&gt;setStatusTip&lt;/a&gt; (), &lt;a href=&quot;qaction#whatsThis-prop&quot;&gt;setWhatsThis&lt;/a&gt; () 및 &lt;a href=&quot;qaction#toolTip-prop&quot;&gt;setToolTip&lt;/a&gt; ()을 사용 하여 독립적으로 설정할 수도 있습니다 . 메뉴 항목의 경우 &lt;a href=&quot;qaction#font-prop&quot;&gt;setFont&lt;/a&gt; () 를 사용하여 개별 글꼴을 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d573972f765f8f5d36c0f61e22bc62e704989c73" translate="yes" xml:space="preserve">
          <source>A QAction may contain an icon, menu text, a shortcut, status text, &quot;What's This?&quot; text, and a tooltip. Most of these can be set in the constructor. They can also be set independently with &lt;a href=&quot;qaction#icon-prop&quot;&gt;setIcon&lt;/a&gt;(), &lt;a href=&quot;qaction#text-prop&quot;&gt;setText&lt;/a&gt;(), &lt;a href=&quot;qaction#iconText-prop&quot;&gt;setIconText&lt;/a&gt;(), &lt;a href=&quot;qaction#shortcut-prop&quot;&gt;setShortcut&lt;/a&gt;(), &lt;a href=&quot;qaction#statusTip-prop&quot;&gt;setStatusTip&lt;/a&gt;(), &lt;a href=&quot;qaction#whatsThis-prop&quot;&gt;setWhatsThis&lt;/a&gt;(), and &lt;a href=&quot;qaction#toolTip-prop&quot;&gt;setToolTip&lt;/a&gt;(). For menu items, it is possible to set an individual font with &lt;a href=&quot;qaction#font-prop&quot;&gt;setFont&lt;/a&gt;().</source>
          <target state="translated">QAction에는 아이콘, 메뉴 텍스트, 바로 가기, 상태 텍스트, &quot;What 's This?&quot;가 포함될 수 있습니다. 텍스트 및 도구 설명. 이들 중 대부분은 생성자에서 설정할 수 있습니다. &lt;a href=&quot;qaction#icon-prop&quot;&gt;setIcon&lt;/a&gt; (), &lt;a href=&quot;qaction#text-prop&quot;&gt;setText&lt;/a&gt; (), &lt;a href=&quot;qaction#iconText-prop&quot;&gt;setIconText&lt;/a&gt; (), &lt;a href=&quot;qaction#shortcut-prop&quot;&gt;setShortcut&lt;/a&gt; (), &lt;a href=&quot;qaction#statusTip-prop&quot;&gt;setStatusTip&lt;/a&gt; (), &lt;a href=&quot;qaction#whatsThis-prop&quot;&gt;setWhatsThis&lt;/a&gt; () 및 &lt;a href=&quot;qaction#toolTip-prop&quot;&gt;setToolTip&lt;/a&gt; ()을 사용 하여 독립적으로 설정할 수도 있습니다 . 메뉴 항목의 경우 &lt;a href=&quot;qaction#font-prop&quot;&gt;setFont&lt;/a&gt; ()로 개별 글꼴을 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2ee36eb9b451ed52c2863c53891485aa3661f446" translate="yes" xml:space="preserve">
          <source>A QActionGroup emits an &lt;a href=&quot;qactiongroup#triggered&quot;&gt;triggered&lt;/a&gt;() signal when one of its actions is chosen. Each action in an action group emits its &lt;a href=&quot;qactiongroup#triggered&quot;&gt;triggered&lt;/a&gt;() signal as usual.</source>
          <target state="translated">QActionGroup은 작업 중 하나가 선택 될 때 &lt;a href=&quot;qactiongroup#triggered&quot;&gt;트리거&lt;/a&gt; () 신호를 내 보냅니다. 조치 그룹의 각 조치는 평소와 같이 &lt;a href=&quot;qactiongroup#triggered&quot;&gt;트리거 된&lt;/a&gt; () 신호를 방출합니다 .</target>
        </trans-unit>
        <trans-unit id="987b7c64d02452454a6771fea3d0d450712c8756" translate="yes" xml:space="preserve">
          <source>A QAnyStringView references a contiguous portion of a string it does not own. It acts as an interface type to all kinds of strings, without the need to construct a &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; first.</source>
          <target state="translated">QAnyStringView는 소유하지 않은 문자열의 연속적인 부분을 참조합니다. &lt;a href=&quot;qstring&quot;&gt;QString을&lt;/a&gt; 먼저 구성 할 필요없이 모든 종류의 문자열에 대한 인터페이스 유형으로 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="116f84f660a957920d6a91cf59262c96bfc8fb0e" translate="yes" xml:space="preserve">
          <source>A QAssociativeIterable::const_iterator can only be created by a &lt;a href=&quot;qassociativeiterable&quot;&gt;QAssociativeIterable&lt;/a&gt; instance, and can be used in a way similar to other stl-style iterators.</source>
          <target state="translated">QAssociativeIterable :: const_iterator는 &lt;a href=&quot;qassociativeiterable&quot;&gt;QAssociativeIterable&lt;/a&gt; 인스턴스 에 의해서만 생성 될 수 있으며 다른 stl 스타일 반복기와 유사한 방식으로 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6179ac938e5b96ccb36ca8c60f7a64d329d8cbb7" translate="yes" xml:space="preserve">
          <source>A QAssociativeIterable::iterator can only be created by a &lt;a href=&quot;qassociativeiterable&quot;&gt;QAssociativeIterable&lt;/a&gt; instance, and can be used in a way similar to other stl-style iterators.</source>
          <target state="translated">QAssociativeIterable :: iterator는 &lt;a href=&quot;qassociativeiterable&quot;&gt;QAssociativeIterable&lt;/a&gt; 인스턴스 에 의해서만 생성 될 수 있으며 다른 stl 스타일 반복자와 유사한 방식으로 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0b247ad603b126d80f1a60efbe96800f998e575" translate="yes" xml:space="preserve">
          <source>A QAudioDeviceInfo is used by Qt to construct classes that communicate with the device--such as &lt;a href=&quot;qaudioinput&quot;&gt;QAudioInput&lt;/a&gt;, and &lt;a href=&quot;qaudiooutput&quot;&gt;QAudioOutput&lt;/a&gt;.</source>
          <target state="translated">Qt에서 QAudioDeviceInfo는 &lt;a href=&quot;qaudioinput&quot;&gt;QAudioInput&lt;/a&gt; 및 &lt;a href=&quot;qaudiooutput&quot;&gt;QAudioOutput&lt;/a&gt; 과 같은 장치와 통신하는 클래스를 생성하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="b7cb7b34cff00b3f67ac2f47a6677cd3a1a4738f" translate="yes" xml:space="preserve">
          <source>A QAxObject can be instantiated as an empty object, with the name of the COM object it should wrap, or with a pointer to the IUnknown that represents an existing COM object. If the COM object implements the &lt;code&gt;IDispatch&lt;/code&gt; interface, the properties, methods and events of that object become available as Qt properties, slots and signals. The base class, &lt;a href=&quot;qaxbase&quot;&gt;QAxBase&lt;/a&gt;, provides an API to access the COM object directly through the IUnknown pointer.</source>
          <target state="translated">QAxObject는 래핑해야하는 COM 개체의 이름 또는 기존 COM 개체를 나타내는 IUnknown에 대한 포인터를 사용하여 빈 개체로 인스턴스화 될 수 있습니다. COM 개체가 &lt;code&gt;IDispatch&lt;/code&gt; 인터페이스를 구현하면 해당 개체 의 속성, 메서드 및 이벤트를 Qt 속성, 슬롯 및 신호로 사용할 수 있습니다. 기본 클래스 인 &lt;a href=&quot;qaxbase&quot;&gt;QAxBase&lt;/a&gt; 는 IUnknown 포인터를 통해 직접 COM 개체에 액세스 할 수있는 API를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="6ee9ab1911b761b52b843a2f9a7abc52a98c7c4b" translate="yes" xml:space="preserve">
          <source>A QAxWidget can be instantiated as an empty object, with the name of the ActiveX control it should wrap, or with an existing interface pointer to the ActiveX control. The ActiveX control's properties, methods and events which only use &lt;a href=&quot;qaxbase&quot;&gt;QAxBase&lt;/a&gt; supported data types, become available as Qt properties, slots and signals. The base class &lt;a href=&quot;qaxbase&quot;&gt;QAxBase&lt;/a&gt; provides an API to access the ActiveX directly through the &lt;code&gt;IUnknown&lt;/code&gt; pointer.</source>
          <target state="translated">QAxWidget은 래핑해야하는 ActiveX 컨트롤의 이름 또는 ActiveX 컨트롤에 대한 기존 인터페이스 포인터를 사용하여 빈 개체로 인스턴스화 할 수 있습니다. &lt;a href=&quot;qaxbase&quot;&gt;QAxBase&lt;/a&gt; 지원 데이터 유형 만 사용하는 ActiveX 컨트롤의 속성, 메서드 및 이벤트 는 Qt 속성, 슬롯 및 신호로 사용할 수 있습니다. 기본 클래스 &lt;a href=&quot;qaxbase&quot;&gt;QAxBase&lt;/a&gt; 는 &lt;code&gt;IUnknown&lt;/code&gt; 포인터를 통해 ActiveX에 직접 액세스 할 수있는 API를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="6288539fde270609c2b37675e616f88a0c44027b" translate="yes" xml:space="preserve">
          <source>A QBackingStore contains a buffered representation of the window contents, and thus supports partial updates by using &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; to only update a sub region of the window contents.</source>
          <target state="translated">QBackingStore에는 창 콘텐츠의 버퍼 된 표현이 포함되어 있으므로 &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; 를 사용 하여 창 콘텐츠의 하위 영역 만 업데이트 함으로써 부분 업데이트를 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="16ffffd19c4f61f7c6735ed70cce418b7504fe27" translate="yes" xml:space="preserve">
          <source>A QBitArray is an array that gives access to individual bits and provides operators (&lt;a href=&quot;qbitarray#operator-and&quot;&gt;AND&lt;/a&gt;, &lt;a href=&quot;qbitarray#operator-7c&quot;&gt;OR&lt;/a&gt;, &lt;a href=&quot;qbitarray#operator-5e&quot;&gt;XOR&lt;/a&gt;, and &lt;a href=&quot;qbitarray#operator-7e&quot;&gt;NOT&lt;/a&gt;) that work on entire arrays of bits. It uses &lt;a href=&quot;implicit-sharing&quot;&gt;implicit sharing&lt;/a&gt; (copy-on-write) to reduce memory usage and to avoid the needless copying of data.</source>
          <target state="translated">QBitArray는 개별 비트에 대한 액세스를 제공 하고 전체 비트 배열에서 작동 하는 연산자 ( &lt;a href=&quot;qbitarray#operator-and&quot;&gt;AND&lt;/a&gt; , &lt;a href=&quot;qbitarray#operator-7c&quot;&gt;OR&lt;/a&gt; , &lt;a href=&quot;qbitarray#operator-5e&quot;&gt;XOR&lt;/a&gt; 및 &lt;a href=&quot;qbitarray#operator-7e&quot;&gt;NOT&lt;/a&gt; )를 제공하는 배열입니다. 그것은 사용하는 &lt;a href=&quot;implicit-sharing&quot;&gt;암시 적 공유&lt;/a&gt; (기록 중 복사) 메모리 사용량을 줄이고 데이터의 불필요한 복사를 방지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3e98eb7c976899b683ee2431c03e4fe511a90d80" translate="yes" xml:space="preserve">
          <source>A QByteArray can embed '\0' bytes. The &lt;a href=&quot;qbytearray#size&quot;&gt;size&lt;/a&gt;() function always returns the size of the whole array, including embedded '\0' bytes, but excluding the terminating '\0' added by QByteArray. For example:</source>
          <target state="translated">QByteArray는 '\ 0'바이트를 포함 할 수 있습니다. &lt;a href=&quot;qbytearray#size&quot;&gt;크기&lt;/a&gt; () 함수는 항상 포함하는 전체 어레이의 크기를 리턴 '\ 0'바이트를 포함하지만, 추가 QByteArray 종단 '\ 0'을 제외. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="784922218449627115b03a4c0b83eec30dbae023" translate="yes" xml:space="preserve">
          <source>A QByteArrayView references a contiguous portion of raw bytes it does not own. It acts as an interface type to all kinds of byte-array-like data, without the need to construct a &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; first.</source>
          <target state="translated">QByteArrayView는 소유하지 않은 원시 바이트의 연속 부분을 참조합니다. &lt;a href=&quot;qbytearray&quot;&gt;QByteArray를&lt;/a&gt; 먼저 구성 할 필요없이 모든 종류의 바이트 배열과 유사한 데이터에 대한 인터페이스 유형으로 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="b3b0d1e66277fd3ca0509e7d4466a830ada31e48" translate="yes" xml:space="preserve">
          <source>A QCalendar object maps a year, month, and day-number to a specific day (ultimately identified by its Julian day number), using the rules of a particular system.</source>
          <target state="translated">QCalendar 개체는 특정 시스템의 규칙을 사용하여 년, 월, 일 번호를 특정 날짜 (결국 율리우스 력 일 번호로 식별 됨)에 매핑합니다.</target>
        </trans-unit>
        <trans-unit id="187a1bb3ddc82c1b5874782f4d1a379e10e1b5eb" translate="yes" xml:space="preserve">
          <source>A QCalendar value is immutable.</source>
          <target state="translated">QCalendar 값은 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="dfcd89494f5f1fddedfbe49ba3ad5a8668b82224" translate="yes" xml:space="preserve">
          <source>A QCameraInfo can be used to construct a &lt;a href=&quot;qcamera&quot;&gt;QCamera&lt;/a&gt;. The following example instantiates a &lt;a href=&quot;qcamera&quot;&gt;QCamera&lt;/a&gt; whose camera device is named 'mycamera':</source>
          <target state="translated">QCameraInfo를 사용하여 &lt;a href=&quot;qcamera&quot;&gt;QCamera&lt;/a&gt; 를 구성 할 수 있습니다 . 다음 예제 는 카메라 장치 이름이 'mycamera'인 &lt;a href=&quot;qcamera&quot;&gt;QCamera&lt;/a&gt; 를 인스턴스화합니다 .</target>
        </trans-unit>
        <trans-unit id="d985b0c767e5e0c17c2ff405d812c5a6a1cae348" translate="yes" xml:space="preserve">
          <source>A QCheckBox is an option button that can be switched on (checked) or off (unchecked). Checkboxes are typically used to represent features in an application that can be enabled or disabled without affecting others. Different types of behavior can be implemented. For example, a &lt;a href=&quot;qbuttongroup&quot;&gt;QButtonGroup&lt;/a&gt; can be used to group check buttons logically, allowing exclusive checkboxes. However, &lt;a href=&quot;qbuttongroup&quot;&gt;QButtonGroup&lt;/a&gt; does not provide any visual representation.</source>
          <target state="translated">QCheckBox는 켜기 (선택) 또는 끄기 (선택 취소) 할 수있는 옵션 버튼입니다. 확인란은 일반적으로 다른 사람에게 영향을주지 않고 활성화 또는 비활성화 할 수있는 응용 프로그램의 기능을 나타내는 데 사용됩니다. 다양한 유형의 동작을 구현할 수 있습니다. 예를 들어, &lt;a href=&quot;qbuttongroup&quot;&gt;QButtonGroup&lt;/a&gt; 을 사용하여 체크 버튼을 논리적으로 그룹화하여 배타적 확인란을 허용 할 수 있습니다. 그러나 &lt;a href=&quot;qbuttongroup&quot;&gt;QButtonGroup&lt;/a&gt; 은 시각적 표현을 제공하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a217bbf000a150bfba003f79b2cd2e9d63d0c6dc" translate="yes" xml:space="preserve">
          <source>A QCollator object can be used together with template based sorting algorithms such as std::sort to sort a list of QStrings.</source>
          <target state="translated">QCollator 객체를 std :: sort와 같은 템플릿 기반 정렬 알고리즘과 함께 사용하여 QString 목록을 정렬 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="517f20bd9dadb8c786e336c1e32ea2a8a5baad11" translate="yes" xml:space="preserve">
          <source>A QComboBox provides a means of presenting a list of options to the user in a way that takes up the minimum amount of screen space.</source>
          <target state="translated">QComboBox는 최소한의 화면 공간을 차지하는 방식으로 사용자에게 옵션 목록을 제공하는 수단을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="460d734d8bff2f596f68b7065ebb022a4d7fb569" translate="yes" xml:space="preserve">
          <source>A QCompleter is used typically with a &lt;a href=&quot;qlineedit&quot;&gt;QLineEdit&lt;/a&gt; or &lt;a href=&quot;qcombobox&quot;&gt;QComboBox&lt;/a&gt;. For example, here's how to provide auto completions from a simple word list in a &lt;a href=&quot;qlineedit&quot;&gt;QLineEdit&lt;/a&gt;:</source>
          <target state="translated">QCompleter는 일반적으로 &lt;a href=&quot;qlineedit&quot;&gt;QLineEdit&lt;/a&gt; 또는 &lt;a href=&quot;qcombobox&quot;&gt;QComboBox&lt;/a&gt; 와 함께 사용됩니다 . 예를 들어, 다음은 &lt;a href=&quot;qlineedit&quot;&gt;QLineEdit&lt;/a&gt; 의 간단한 단어 목록에서 자동 완성을 제공하는 방법입니다 .</target>
        </trans-unit>
        <trans-unit id="76cb3ac260477952c8012b50956afd15bc9348dc" translate="yes" xml:space="preserve">
          <source>A QCompleter is used typically with a &lt;a href=&quot;qlineedit&quot;&gt;QLineEdit&lt;/a&gt; or &lt;a href=&quot;widgets-changes-qt6#qcombobox&quot;&gt;QComboBox&lt;/a&gt;. For example, here's how to provide auto completions from a simple word list in a &lt;a href=&quot;qlineedit&quot;&gt;QLineEdit&lt;/a&gt;:</source>
          <target state="translated">QCompleter는 일반적으로 &lt;a href=&quot;qlineedit&quot;&gt;QLineEdit&lt;/a&gt; 또는 &lt;a href=&quot;widgets-changes-qt6#qcombobox&quot;&gt;QComboBox&lt;/a&gt; 와 함께 사용됩니다 . 예를 들어, 다음은 &lt;a href=&quot;qlineedit&quot;&gt;QLineEdit&lt;/a&gt; 의 간단한 단어 목록에서 자동 완성을 제공하는 방법입니다 .</target>
        </trans-unit>
        <trans-unit id="21ec3cbb7431d02b938f769f46f9f389cf149796" translate="yes" xml:space="preserve">
          <source>A QDBusPendingCall object is a reference to a method call that was sent over D-Bus without waiting for a reply. QDBusPendingCall is an opaque type, meant to be used as a handle for a pending reply.</source>
          <target state="translated">QDBusPendingCall 객체는 응답을 기다리지 않고 D-Bus를 통해 전송 된 메서드 호출에 대한 참조입니다. QDBusPendingCall은 보류중인 응답에 대한 핸들로 사용되는 불투명 유형입니다.</target>
        </trans-unit>
        <trans-unit id="ec984e804be5e241df569ee65c9439de494e0bbd" translate="yes" xml:space="preserve">
          <source>A QDBusReply object is a subset of the &lt;a href=&quot;dbus-changes-qt6#qdbusmessage&quot;&gt;QDBusMessage&lt;/a&gt; object that represents a method call's reply. It contains only the first output argument or the error code and is used by &lt;a href=&quot;qdbusinterface&quot;&gt;QDBusInterface&lt;/a&gt;-derived classes to allow returning the error code as the function's return argument.</source>
          <target state="translated">QDBusReply 개체는 메서드 호출의 응답을 나타내는 &lt;a href=&quot;dbus-changes-qt6#qdbusmessage&quot;&gt;QDBusMessage&lt;/a&gt; 개체 의 하위 집합입니다 . 첫 번째 출력 인수 또는 오류 코드 만 포함하고 &lt;a href=&quot;qdbusinterface&quot;&gt;QDBusInterface&lt;/a&gt; 파생 클래스에서 함수의 반환 인수로 오류 코드를 반환 할 수 있도록 사용합니다.</target>
        </trans-unit>
        <trans-unit id="adcca88f86040af265cc9e6dd0ebb48443c51cc3" translate="yes" xml:space="preserve">
          <source>A QDBusReply object is a subset of the &lt;a href=&quot;qdbusmessage&quot;&gt;QDBusMessage&lt;/a&gt; object that represents a method call's reply. It contains only the first output argument or the error code and is used by &lt;a href=&quot;qdbusinterface&quot;&gt;QDBusInterface&lt;/a&gt;-derived classes to allow returning the error code as the function's return argument.</source>
          <target state="translated">QDBusReply 개체는 메서드 호출의 응답을 나타내는 &lt;a href=&quot;qdbusmessage&quot;&gt;QDBusMessage&lt;/a&gt; 개체 의 하위 집합입니다 . 첫 번째 출력 인수 또는 오류 코드 만 포함하고 &lt;a href=&quot;qdbusinterface&quot;&gt;QDBusInterface&lt;/a&gt; 파생 클래스에서 함수의 반환 인수로 오류 코드를 반환 할 수 있도록 사용합니다.</target>
        </trans-unit>
        <trans-unit id="09b216f7fe674889c02fc54ff2eac6abe08c5817" translate="yes" xml:space="preserve">
          <source>A QDBusServiceWatcher object can be used to notify the application about an ownership change of a service name on the bus. It has three watch modes:</source>
          <target state="translated">QDBusServiceWatcher 객체를 사용하여 버스에서 서비스 이름의 소유권 변경에 대해 애플리케이션에 알릴 수 있습니다. 세 가지 시계 모드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed5fbc1255fe63e5a4dc305906ab11a577377a3f" translate="yes" xml:space="preserve">
          <source>A QDate object is typically created by giving the year, month, and day numbers explicitly. Note that QDate interprets year numbers less than 100 as presented, i.e., as years 1 through 99, without adding any offset. The static function &lt;a href=&quot;qdate#currentDate&quot;&gt;currentDate&lt;/a&gt;() creates a QDate object containing the date read from the system clock. An explicit date can also be set using &lt;a href=&quot;qdate#setDate&quot;&gt;setDate&lt;/a&gt;(). The &lt;a href=&quot;qdate#fromString&quot;&gt;fromString&lt;/a&gt;() function returns a QDate given a string and a date format which is used to interpret the date within the string.</source>
          <target state="translated">QDate 객체는 일반적으로 연도, 월, 일 번호를 명시 적으로 제공하여 생성됩니다. QDate는 오프셋을 추가하지 않고 제시된대로 100 미만의 연도 번호 (예 : 1 년부터 99 년까지)를 해석합니다. 정적 함수 &lt;a href=&quot;qdate#currentDate&quot;&gt;currentDate&lt;/a&gt; ()는 시스템 시계에서 읽은 날짜를 포함하는 QDate 객체를 만듭니다. &lt;a href=&quot;qdate#setDate&quot;&gt;setDate&lt;/a&gt; ()를 사용하여 명시적인 날짜를 설정할 수도 있습니다 . &lt;a href=&quot;qdate#fromString&quot;&gt;fromString&lt;/a&gt; () 함수는 문자열과 문자열에서 날짜를 해석하는 데 사용되는 날짜 형식을 주어진 QDate을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f72c7395f44eb3cc5d0d1ea86fc40fbc4065d25b" translate="yes" xml:space="preserve">
          <source>A QDate object represents a particular day, regardless of calendar, locale or other settings used when creating it or supplied by the system. It can report the year, month and day of the month that represent the day with respect to the proleptic Gregorian calendar or any calendar supplied as a &lt;a href=&quot;qcalendar&quot;&gt;QCalendar&lt;/a&gt; object.</source>
          <target state="translated">QDate 객체는 달력, 로케일 또는 생성시 사용되거나 시스템에서 제공하는 기타 설정에 관계없이 특정 날짜를 나타냅니다. proleptic Gregorian 달력 또는 &lt;a href=&quot;qcalendar&quot;&gt;QCalendar&lt;/a&gt; 객체 로 제공된 달력과 관련하여 일을 나타내는 년, 월 및 일을보고 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a0b0cd093220098d833a4338e41dae46517f1b3f" translate="yes" xml:space="preserve">
          <source>A QDate object represents a particular day, regardless of calendar, locale or other settings used when creating it or supplied by the system. It can report the year, month and day of the month that represent the day with respect to the proleptic Gregorian calendar or any calendar supplied as a &lt;a href=&quot;qcalendar&quot;&gt;QCalendar&lt;/a&gt; object. QDate objects should be passed by value rather than by reference to const; they simply package &lt;code&gt;qint64&lt;/code&gt;.</source>
          <target state="translated">QDate 객체는 달력, 로케일 또는 작성시 사용되거나 시스템에서 제공하는 기타 설정에 관계없이 특정 날짜를 나타냅니다. &lt;a href=&quot;qcalendar&quot;&gt;Proleptic&lt;/a&gt; Gregorian 달력 또는 QCalendar 객체 로 제공된 달력과 관련하여 일을 나타내는 년, 월 및 일을보고 할 수 있습니다 . QDate 객체는 const에 대한 참조가 아닌 값으로 전달되어야합니다. 그들은 단순히 &lt;code&gt;qint64&lt;/code&gt; 를 패키지화 합니다.</target>
        </trans-unit>
        <trans-unit id="8629c0903436f12749add74dc782539532df8100" translate="yes" xml:space="preserve">
          <source>A QDateTime object encodes a calendar date and a clock time (a &quot;datetime&quot;). It combines features of the &lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt; and &lt;a href=&quot;qtime&quot;&gt;QTime&lt;/a&gt; classes. It can read the current datetime from the system clock. It provides functions for comparing datetimes and for manipulating a datetime by adding a number of seconds, days, months, or years.</source>
          <target state="translated">QDateTime 객체는 달력 날짜와 시계 시간 ( &quot;datetime&quot;)을 인코딩합니다. &lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt; 및 &lt;a href=&quot;qtime&quot;&gt;QTime&lt;/a&gt; 클래스 의 기능을 결합합니다 . 시스템 시계에서 현재 날짜 시간을 읽을 수 있습니다. 날짜 시간을 비교하고 초, 일, 월 또는 연도를 추가하여 날짜 시간을 조작하는 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="614566e57fdbd4e6f68eb010853c2d3ff14087cd" translate="yes" xml:space="preserve">
          <source>A QDateTime object is typically created either by giving a date and time explicitly in the constructor, or by using a static function such as &lt;a href=&quot;qdatetime#currentDateTime&quot;&gt;currentDateTime&lt;/a&gt;() or &lt;a href=&quot;qdatetime#fromMSecsSinceEpoch&quot;&gt;fromMSecsSinceEpoch&lt;/a&gt;(). The date and time can be changed with &lt;a href=&quot;qdatetime#setDate&quot;&gt;setDate&lt;/a&gt;() and &lt;a href=&quot;qdatetime#setTime&quot;&gt;setTime&lt;/a&gt;(). A datetime can also be set using the &lt;a href=&quot;qdatetime#setMSecsSinceEpoch&quot;&gt;setMSecsSinceEpoch&lt;/a&gt;() function that takes the time, in milliseconds, since 00:00:00 on January 1, 1970. The &lt;a href=&quot;qdatetime#fromString&quot;&gt;fromString&lt;/a&gt;() function returns a QDateTime, given a string and a date format used to interpret the date within the string.</source>
          <target state="translated">QDateTime 객체는 일반적으로 생성자에서 명시 적으로 날짜와 시간을 제공하거나 &lt;a href=&quot;qdatetime#currentDateTime&quot;&gt;currentDateTime&lt;/a&gt; () 또는 &lt;a href=&quot;qdatetime#fromMSecsSinceEpoch&quot;&gt;fromMSecsSinceEpoch&lt;/a&gt; () 와 같은 정적 함수를 사용하여 생성 됩니다. 날짜와 시간은 &lt;a href=&quot;qdatetime#setDate&quot;&gt;setDate&lt;/a&gt; () 및 &lt;a href=&quot;qdatetime#setTime&quot;&gt;setTime&lt;/a&gt; () 으로 변경할 수 있습니다 . 1970 년 1 월 1 일 00:00:00 이후의 시간 (밀리 초)을 사용하는 &lt;a href=&quot;qdatetime#setMSecsSinceEpoch&quot;&gt;setMSecsSinceEpoch&lt;/a&gt; () 함수를 사용하여 datetime을 설정할 수도 있습니다 . &lt;a href=&quot;qdatetime#fromString&quot;&gt;fromString&lt;/a&gt; () 함수는 문자열과 날짜 형식이 지정된 경우 QDateTime을 반환합니다. 문자열 내의 날짜를 해석합니다.</target>
        </trans-unit>
        <trans-unit id="e02fc0bdafad73055431dbde97ea6ae4cf72babc" translate="yes" xml:space="preserve">
          <source>A QDepthTest class is used to enable depth testing with a given depth test function. The depth test enables writing fragment color values when the depth test passes, and reject fragments which fail the test. The depth test uses the depth function to test the fragments depth value to the value against z-buffer. If the underlying surface does not have z-buffer, then QDepthTest does nothing.</source>
          <target state="translated">QDepthTest 클래스는 주어진 깊이 테스트 기능으로 깊이 테스트를 활성화하는 데 사용됩니다. 심도 테스트를 사용하면 심도 테스트를 통과하면 조각 색상 값을 쓸 수 있고 테스트에 실패한 조각은 거부 할 수 있습니다. 깊이 테스트는 깊이 함수를 사용하여 조각 깊이 값을 z 버퍼에 대한 값으로 테스트합니다. 기본 표면에 z 버퍼가 없으면 QDepthTest는 아무 작업도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0dceba246ca4bfc160b7346264fee9e33777ab85" translate="yes" xml:space="preserve">
          <source>A QDir can point to a file using either a relative or an absolute path. Absolute paths begin with the directory separator (optionally preceded by a drive specification under Windows). Relative file names begin with a directory name or a file name and specify a path relative to the current directory.</source>
          <target state="translated">QDir는 상대 또는 절대 경로를 사용하여 파일을 가리킬 수 있습니다. 절대 경로는 디렉터리 구분 기호로 시작합니다 (선택적으로 Windows에서 드라이브 사양이 선행 됨). 상대 파일 이름은 디렉토리 이름 또는 파일 이름으로 시작하고 현재 디렉토리에 상대적인 경로를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="ceb6225b9c333bdfc6dd81a2b1173c1c0e27079b" translate="yes" xml:space="preserve">
          <source>A QDir is used to manipulate path names, access information regarding paths and files, and manipulate the underlying file system. It can also be used to access Qt's &lt;a href=&quot;resources&quot;&gt;resource system&lt;/a&gt;.</source>
          <target state="translated">QDir는 경로 이름을 조작하고 경로 및 파일에 관한 정보에 액세스하며 기본 파일 시스템을 조작하는 데 사용됩니다. 또한 Qt의 &lt;a href=&quot;resources&quot;&gt;리소스 시스템&lt;/a&gt; 에 액세스하는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="75c925ad489dcf6e1d234498f8cadee2a2848ce3" translate="yes" xml:space="preserve">
          <source>A QDoc comment can contain multiple topic commands in the same category, with some restrictions. This way, it's possible to write a single comment that documents all overloads of a function (using multiple &lt;a href=&quot;https://doc.qt.io/qt-6.0/13-qdoc-commands-topics.html#fn-command&quot;&gt;\fn&lt;/a&gt; commands), or all properties in a QML property group (using &lt;a href=&quot;https://doc.qt.io/qt-6.0/13-qdoc-commands-topics.html#qmlproperty-command&quot;&gt;\qmlproperty&lt;/a&gt; commands) in one go.</source>
          <target state="translated">QDoc 주석은 몇 가지 제한 사항과 함께 동일한 범주에 여러 주제 명령을 포함 할 수 있습니다. 이렇게하면 함수의 모든 오버로드 (여러 &lt;a href=&quot;https://doc.qt.io/qt-6.0/13-qdoc-commands-topics.html#fn-command&quot;&gt;\ fn&lt;/a&gt; 명령 사용) 또는 QML 속성 그룹의 모든 속성 ( &lt;a href=&quot;https://doc.qt.io/qt-6.0/13-qdoc-commands-topics.html#qmlproperty-command&quot;&gt;\ qmlproperty&lt;/a&gt; 명령 사용)을 한 번에 문서화하는 단일 주석을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9361cdd2ddd68cad4a6583669960d353d004b873" translate="yes" xml:space="preserve">
          <source>A QDockWidget acts as a wrapper for its child widget, set with &lt;a href=&quot;qdockwidget#setWidget&quot;&gt;setWidget&lt;/a&gt;(). Custom size hints, minimum and maximum sizes and size policies should be implemented in the child widget. QDockWidget will respect them, adjusting its own constraints to include the frame and title. Size constraints should not be set on the QDockWidget itself, because they change depending on whether it is docked; a docked QDockWidget has no frame and a smaller title bar.</source>
          <target state="translated">QDockWidget은 &lt;a href=&quot;qdockwidget#setWidget&quot;&gt;setWidget&lt;/a&gt; ()으로 설정된 하위 위젯의 래퍼 역할을합니다 . 사용자 정의 크기 힌트, 최소 및 최대 크기 및 크기 정책은 하위 위젯에서 구현되어야합니다. QDockWidget은 프레임과 제목을 포함하도록 자체 제약 조건을 조정하여이를 존중합니다. 크기 제한은 QDockWidget 자체에 설정되어서는 안됩니다. 도킹 여부에 따라 변경되기 때문입니다. 도킹 된 QDockWidget에는 프레임이없고 제목 표시 줄이 더 작습니다.</target>
        </trans-unit>
        <trans-unit id="c65ed067e63930b12cbb2b1cf928890b0e4da622" translate="yes" xml:space="preserve">
          <source>A QDockWidget consists of a title bar and the content area. The title bar displays the dock widgets &lt;a href=&quot;qwidget#windowTitle-prop&quot;&gt;window title&lt;/a&gt;, a</source>
          <target state="translated">QDockWidget은 제목 표시 줄과 콘텐츠 영역으로 구성됩니다. 제목 표시 줄에는 독 위젯 &lt;a href=&quot;qwidget#windowTitle-prop&quot;&gt;창&lt;/a&gt; 제목이 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="e8ce84c1883452933d4ea72ff27d7b0ec58b95f1" translate="yes" xml:space="preserve">
          <source>A QDomEntityReference object may be inserted into the DOM tree when an entity reference is in the source document, or when the user wishes to insert an entity reference.</source>
          <target state="translated">QDomEntityReference 객체는 엔티티 참조가 소스 문서에 있거나 사용자가 엔티티 참조를 삽입하고자 할 때 DOM 트리에 삽입 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dace30defda755e2198db87150792a08e7d493a5" translate="yes" xml:space="preserve">
          <source>A QDomNode can be converted into one of its subclasses using &lt;a href=&quot;qdomnode#toAttr&quot;&gt;toAttr&lt;/a&gt;(), &lt;a href=&quot;qdomnode#toCDATASection&quot;&gt;toCDATASection&lt;/a&gt;(), &lt;a href=&quot;qdomnode#toDocumentFragment&quot;&gt;toDocumentFragment&lt;/a&gt;(), &lt;a href=&quot;qdomnode#toDocument&quot;&gt;toDocument&lt;/a&gt;(), &lt;a href=&quot;qdomnode#toDocumentType&quot;&gt;toDocumentType&lt;/a&gt;(), &lt;a href=&quot;qdomnode#toElement&quot;&gt;toElement&lt;/a&gt;(), &lt;a href=&quot;qdomnode#toEntityReference&quot;&gt;toEntityReference&lt;/a&gt;(), &lt;a href=&quot;qdomnode#toText&quot;&gt;toText&lt;/a&gt;(), &lt;a href=&quot;qdomnode#toEntity&quot;&gt;toEntity&lt;/a&gt;(), &lt;a href=&quot;qdomnode#toNotation&quot;&gt;toNotation&lt;/a&gt;(), &lt;a href=&quot;qdomnode#toProcessingInstruction&quot;&gt;toProcessingInstruction&lt;/a&gt;(), &lt;a href=&quot;qdomnode#toCharacterData&quot;&gt;toCharacterData&lt;/a&gt;() or &lt;a href=&quot;qdomnode#toComment&quot;&gt;toComment&lt;/a&gt;(). You can convert a node to a null node with &lt;a href=&quot;qdomnode#clear&quot;&gt;clear&lt;/a&gt;().</source>
          <target state="translated">QDomNode는 &lt;a href=&quot;qdomnode#toAttr&quot;&gt;toAttr&lt;/a&gt; (), &lt;a href=&quot;qdomnode#toCDATASection&quot;&gt;toCDATASection&lt;/a&gt; (), &lt;a href=&quot;qdomnode#toDocumentFragment&quot;&gt;toDocumentFragment&lt;/a&gt; (), &lt;a href=&quot;qdomnode#toDocument&quot;&gt;toDocument&lt;/a&gt; (), &lt;a href=&quot;qdomnode#toDocumentType&quot;&gt;toDocumentType&lt;/a&gt; (), &lt;a href=&quot;qdomnode#toElement&quot;&gt;toElement&lt;/a&gt; (), &lt;a href=&quot;qdomnode#toEntityReference&quot;&gt;toEntityReference&lt;/a&gt; (), &lt;a href=&quot;qdomnode#toText&quot;&gt;toText&lt;/a&gt; (), &lt;a href=&quot;qdomnode#toEntity&quot;&gt;toEntity&lt;/a&gt; (), &lt;a href=&quot;qdomnode#toNotation&quot;&gt;toNotation&lt;/a&gt; ()을 사용하여 하위 클래스 중 하나로 변환 할 수 있습니다. , &lt;a href=&quot;qdomnode#toProcessingInstruction&quot;&gt;toProcessingInstruction&lt;/a&gt; (), &lt;a href=&quot;qdomnode#toCharacterData&quot;&gt;toCharacterData&lt;/a&gt; () 또는 &lt;a href=&quot;qdomnode#toComment&quot;&gt;toComment&lt;/a&gt; (). &lt;a href=&quot;qdomnode#clear&quot;&gt;clear&lt;/a&gt; () 를 사용하여 노드를 null 노드로 변환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ab6c8d3c3c16fdc09a8301cf5a98709a1dba9bc6" translate="yes" xml:space="preserve">
          <source>A QDomNode can be null, much like &lt;code&gt;nullptr&lt;/code&gt;. Creating a copy of a null node results in another null node. It is not possible to modify a null node, but it is possible to assign another, possibly non-null node to it. In this case, the copy of the null node will remain null. You can check if a QDomNode is null by calling &lt;a href=&quot;qdomnode#isNull&quot;&gt;isNull&lt;/a&gt;(). The empty constructor of a QDomNode (or any of the derived classes) creates a null node.</source>
          <target state="translated">QDomNode는 &lt;code&gt;nullptr&lt;/code&gt; 처럼 null 일 수 있습니다 . 널 노드의 사본을 작성하면 다른 널 노드가 생성됩니다. 널 노드를 수정할 수는 없지만 널이 아닌 다른 노드를 할당 할 수 있습니다. 이 경우 널 노드의 사본은 널로 유지됩니다. &lt;a href=&quot;qdomnode#isNull&quot;&gt;isNull&lt;/a&gt; () 을 호출하여 QDomNode가 null인지 확인할 수 있습니다 . QDomNode (또는 파생 클래스 중 하나)의 빈 생성자는 null 노드를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="1af23f8b2b4fbaeb44ff043c91517f0bd53fb732" translate="yes" xml:space="preserve">
          <source>A QEventTransition object binds an event to a particular &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;. QEventTransition is part of &lt;a href=&quot;statemachine-api&quot;&gt;The State Machine Framework&lt;/a&gt;.</source>
          <target state="translated">QEventTransition 객체는 이벤트를 특정 &lt;a href=&quot;qobject&quot;&gt;QObject에&lt;/a&gt; 바인딩 합니다 . QEventTransition은 &lt;a href=&quot;statemachine-api&quot;&gt;State Machine Framework의&lt;/a&gt; 일부입니다 .</target>
        </trans-unit>
        <trans-unit id="c1a7aa2533d63408135540bcb162e757d23c0357" translate="yes" xml:space="preserve">
          <source>A QFileInfo can point to a file with either a relative or an absolute file path. Absolute file paths begin with the directory separator &quot;/&quot; (or with a drive specification on Windows). Relative file names begin with a directory name or a file name and specify a path relative to the current working directory. An example of an absolute path is the string &quot;/tmp/quartz&quot;. A relative path might look like &quot;src/fatlib&quot;. You can use the function &lt;a href=&quot;qfileinfo#isRelative&quot;&gt;isRelative&lt;/a&gt;() to check whether a QFileInfo is using a relative or an absolute file path. You can call the function &lt;a href=&quot;qfileinfo#makeAbsolute&quot;&gt;makeAbsolute&lt;/a&gt;() to convert a relative QFileInfo's path to an absolute path.</source>
          <target state="translated">QFileInfo는 상대 또는 절대 파일 경로가있는 파일을 가리킬 수 있습니다. 절대 파일 경로는 디렉터리 구분 기호 &quot;/&quot;(또는 Windows의 경우 드라이브 사양)로 시작합니다. 상대 파일 이름은 디렉토리 이름 또는 파일 이름으로 시작하고 현재 작업 디렉토리에 상대적인 경로를 지정합니다. 절대 경로의 예는 문자열 &quot;/ tmp / quartz&quot;입니다. 상대 경로는 &quot;src / fatlib&quot;처럼 보일 수 있습니다. &lt;a href=&quot;qfileinfo#isRelative&quot;&gt;isRelative&lt;/a&gt; () 함수를 사용하여 QFileInfo가 상대 또는 절대 파일 경로를 사용하고 있는지 확인할 수 있습니다 . &lt;a href=&quot;qfileinfo#makeAbsolute&quot;&gt;makeAbsolute&lt;/a&gt; () 함수를 호출하여 상대 QFileInfo의 경로를 절대 경로로 변환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7cada93d7684b3555a23f52358673b0668c15357" translate="yes" xml:space="preserve">
          <source>A QFrameGraphNode used to select QTechniques to use</source>
          <target state="translated">사용할 QTechniques를 선택하는 데 사용되는 QFrameGraphNode</target>
        </trans-unit>
        <trans-unit id="a8665d00b111221fa67a06ed5cdd7c5e9d305ee8" translate="yes" xml:space="preserve">
          <source>A QFrustumCulling class enables frustum culling of the drawable entities based on the camera view and &lt;a href=&quot;qt3drender-qgeometry&quot;&gt;QGeometry&lt;/a&gt; bounds of the entities. If QFrustumCulling is present in the FrameGraph, only the entities whose &lt;a href=&quot;qt3drender-qgeometry&quot;&gt;QGeometry&lt;/a&gt; bounds intersect with the camera frustum, i.e. the view of the camera, are drawn. If QFrustumCulling is not present, all drawable entities will be drawn. The camera is selected by a &lt;a href=&quot;qt3drender-qcameraselector&quot;&gt;QCameraSelector&lt;/a&gt; frame graph node in the current hierarchy. Frustum culling can save a lot of GPU processing time when the rendered scene is complex.</source>
          <target state="translated">QFrustumCulling 클래스는 엔티티의 카메라 뷰 및 &lt;a href=&quot;qt3drender-qgeometry&quot;&gt;QGeometry&lt;/a&gt; 경계를 기반으로 드로어 블 엔티티의 절두체 컬링을 활성화 합니다. QFrustumCulling이 FrameGraph에 존재하는 경우, 그의 유일한 실체 &lt;a href=&quot;qt3drender-qgeometry&quot;&gt;QGeometry이&lt;/a&gt; 카메라의 예 뷰 카메라 프러스 텀과 교차 경계는 그려져 있습니다. QFrustumCulling이 없으면 모든 드로어 블 엔티티가 그려집니다. 카메라는 현재 계층 구조에서 &lt;a href=&quot;qt3drender-qcameraselector&quot;&gt;QCameraSelector&lt;/a&gt; 프레임 그래프 노드에 의해 선택됩니다 . Frustum 컬링은 렌더링 된 장면이 복잡 할 때 많은 GPU 처리 시간을 절약 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f4406e9af5e7cdcb53a458c9f7bc858056470b0" translate="yes" xml:space="preserve">
          <source>A QFrustumCulling class enables frustum culling of the drawable entities based on the camera view and QGeometry bounds of the entities. If QFrustumCulling is present in the FrameGraph, only the entities whose QGeometry bounds intersect with the camera frustum, i.e. the view of the camera, are drawn. If QFrustumCulling is not present, all drawable entities will be drawn. The camera is selected by a &lt;a href=&quot;qt3drender-qcameraselector&quot;&gt;QCameraSelector&lt;/a&gt; frame graph node in the current hierarchy. Frustum culling can save a lot of GPU processing time when the rendered scene is complex.</source>
          <target state="translated">QFrustumCulling 클래스는 카메라 뷰와 엔티티의 QGeometry 경계를 기반으로 드로어 블 엔티티의 절두체 컬링을 활성화합니다. FrameGraph에 QFrustumCulling이 있으면 QGeometry 경계가 카메라 절두체와 교차하는 엔티티, 즉 카메라 뷰만 그려집니다. QFrustumCulling이 없으면 모든 드로어 블 엔티티가 그려집니다. 카메라는 현재 계층 구조 의 &lt;a href=&quot;qt3drender-qcameraselector&quot;&gt;QCameraSelector&lt;/a&gt; 프레임 그래프 노드에 의해 선택됩니다 . Frustum 컬링은 렌더링 된 장면이 복잡 할 때 많은 GPU 처리 시간을 절약 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="30def6bf9b607a8b40de74ad397b5a0170a03c7d" translate="yes" xml:space="preserve">
          <source>A QGeoAreaMonitorInfo object is valid if it has a non-empty name and a valid &lt;a href=&quot;qgeoareamonitorinfo#area&quot;&gt;area&lt;/a&gt;(). Such objects must be registered with a &lt;a href=&quot;qgeoareamonitorsource&quot;&gt;QGeoAreaMonitorSource&lt;/a&gt; to start and stop the monitoring process. Note that extensive monitoring can be very resource consuming because the positioning engine must remain active and has to match the current position with each QGeoAreaMonitorInfo instance.</source>
          <target state="translated">QGeoAreaMonitorInfo 객체는 비어 있지 않은 이름과 유효한 &lt;a href=&quot;qgeoareamonitorinfo#area&quot;&gt;영역&lt;/a&gt; ()이 있는 경우 유효 합니다 . 모니터링 프로세스를 시작 및 중지하려면 이러한 개체를 &lt;a href=&quot;qgeoareamonitorsource&quot;&gt;QGeoAreaMonitorSource&lt;/a&gt; 에 등록해야합니다 . 포지셔닝 엔진이 활성 상태로 유지되어야하고 현재 위치를 각 QGeoAreaMonitorInfo 인스턴스와 일치시켜야하기 때문에 광범위한 모니터링은 리소스를 많이 소모 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb7261a96403760aa3410ba4fd8578cb75fa596a" translate="yes" xml:space="preserve">
          <source>A QGeoAreaMonitorSource emits signals when the current position is in range, or has moved out of range, of a specified area. Each area is specified by a &lt;a href=&quot;qgeoareamonitorinfo&quot;&gt;QGeoAreaMonitorInfo&lt;/a&gt; object. For example:</source>
          <target state="translated">QGeoAreaMonitorSource는 현재 위치가 지정된 영역의 범위 내에 있거나 범위를 벗어날 때 신호를 내 보냅니다. 각 영역은 &lt;a href=&quot;qgeoareamonitorinfo&quot;&gt;QGeoAreaMonitorInfo&lt;/a&gt; 개체에 의해 지정됩니다 . 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="7646b399255793e1e9b08ddc67d1c28153667d7e" translate="yes" xml:space="preserve">
          <source>A QGeoCoordinate is defined by latitude, longitude, and optionally, altitude.</source>
          <target state="translated">QGeoCoordinate는 위도, 경도 및 선택적으로 고도로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="b9be3836994dc83ca7293b754baafc6e20a396d8" translate="yes" xml:space="preserve">
          <source>A QGeoLocation consists of a coordinate and corresponding address, along with an optional bounding box which is the recommended region to be displayed when viewing the location.</source>
          <target state="translated">QGeoLocation은 좌표 및 해당 주소와 함께 위치를 볼 때 표시 할 권장 영역 인 선택적인 경계 상자로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="4e95736c651a83f4ca3ed9ec624bd08b0e666b24" translate="yes" xml:space="preserve">
          <source>A QGeoPath is both invalid and empty if it contains no coordinate.</source>
          <target state="translated">QGeoPath는 좌표가없는 경우 유효하지 않으며 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e1bd99be8a0c0f75429e213298ea88c8af2acbb" translate="yes" xml:space="preserve">
          <source>A QGeoPositionInfo contains, at a minimum, a geographical coordinate and a timestamp. It may also have heading and speed measurements as well as estimates of the accuracy of the provided data.</source>
          <target state="translated">QGeoPositionInfo는 최소한 지리적 좌표와 타임 스탬프를 포함합니다. 또한 방향 및 속도 측정 값과 제공된 데이터의 정확도 추정치를 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="75291a011dfeb13785a3cf399c436ca2e56e0165" translate="yes" xml:space="preserve">
          <source>A QGeoRoute object contains high level information about a route, such as the length the route, the estimated travel time for the route, and enough information to render a basic image of the route on a map.</source>
          <target state="translated">QGeoRoute 객체는 경로 길이, 경로의 예상 이동 시간,지도에 경로의 기본 이미지를 렌더링하기에 충분한 정보와 같은 경로에 대한 높은 수준의 정보를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="438365d80ffe00ab0984ff1450866d7388990ce3" translate="yes" xml:space="preserve">
          <source>A QGeoRouteSegment instance has information about the physical layout of the route segment, the length of the route and estimated time required to traverse the route segment and an optional &lt;a href=&quot;qgeomaneuver&quot;&gt;QGeoManeuver&lt;/a&gt; associated with the beginning of the route segment.</source>
          <target state="translated">QGeoRouteSegment 인스턴스에는 경로 세그먼트의 물리적 레이아웃, 경로 길이 및 경로 세그먼트를 횡단하는 데 필요한 예상 시간 및 경로 세그먼트 의 시작과 관련된 선택적 &lt;a href=&quot;qgeomaneuver&quot;&gt;QGeoManeuver&lt;/a&gt; 에 대한 정보가 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a47d365c7fe92ab73c612841ab37c925627f9e5" translate="yes" xml:space="preserve">
          <source>A QGesture instance is implicitly created when needed and is owned by Qt. Developers should never destroy them or store them for later use as Qt may destroy particular instances of them and create new ones to replace them.</source>
          <target state="translated">QGesture 인스턴스는 필요할 때 암시 적으로 생성되며 Qt가 소유합니다. Qt가 특정 인스턴스를 파괴하고이를 대체 할 새 인스턴스를 생성 할 수 있으므로 개발자는이를 파괴하거나 나중에 사용하기 위해 저장해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="f7b538dff8312c1e16a052671321cf01f9967731" translate="yes" xml:space="preserve">
          <source>A QGraphicsItemGroup is a special type of compound item that treats itself and all its children as one item (i.e., all events and geometries for all children are merged together). It's common to use item groups in presentation tools, when the user wants to group several smaller items into one big item in order to simplify moving and copying of items.</source>
          <target state="translated">QGraphicsItemGroup은 자신과 모든 하위 항목을 하나의 항목으로 취급하는 특수 유형의 복합 항목입니다 (즉, 모든 하위 항목에 대한 모든 이벤트와 도형이 함께 병합 됨). 사용자가 항목의 이동 및 복사를 단순화하기 위해 여러 개의 작은 항목을 하나의 큰 항목으로 그룹화하려는 경우 프레젠테이션 도구에서 항목 그룹을 사용하는 것이 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="0b7b6e45c0345e8bb3adcd024d2b97be62ddedf6" translate="yes" xml:space="preserve">
          <source>A QHash allows only one value per key. If you call &lt;a href=&quot;qhash#insert&quot;&gt;insert&lt;/a&gt;() with a key that already exists in the QHash, the previous value is erased. For example:</source>
          <target state="translated">QHash는 키당 하나의 값만 허용합니다. QHash에 이미있는 키로 &lt;a href=&quot;qhash#insert&quot;&gt;insert&lt;/a&gt; () 를 호출 하면 이전 값이 지워집니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="43a99d5a0255be84b29e1a567ae03e70af1d17f5" translate="yes" xml:space="preserve">
          <source>A QHash's key type has additional requirements other than being an assignable data type: it must provide operator==(), and there must also be a &lt;a href=&quot;qhash#qHashx&quot;&gt;qHash&lt;/a&gt;() function in the type's namespace that returns a hash value for an argument of the key's type.</source>
          <target state="translated">QHash의 키 유형에는 할당 가능한 데이터 유형 이외의 추가 요구 사항이 있습니다. operator == ()를 제공해야하며 , 키 유형의 인수에 대한 해시 값을 반환하는 유형의 네임 스페이스에 &lt;a href=&quot;qhash#qHashx&quot;&gt;qHash&lt;/a&gt; () 함수 도 있어야합니다. .</target>
        </trans-unit>
        <trans-unit id="6c428dcfc7bc3a53cc82c3853c71b9cf98fc40c2" translate="yes" xml:space="preserve">
          <source>A QHeaderView displays the headers used in item views such as the &lt;a href=&quot;qtableview&quot;&gt;QTableView&lt;/a&gt; and &lt;a href=&quot;qtreeview&quot;&gt;QTreeView&lt;/a&gt; classes. It takes the place of Qt3's &lt;code&gt;QHeader&lt;/code&gt; class previously used for the same purpose, but uses the Qt's model/view architecture for consistency with the item view classes.</source>
          <target state="translated">QHeaderView는 &lt;a href=&quot;qtableview&quot;&gt;QTableView&lt;/a&gt; 및 &lt;a href=&quot;qtreeview&quot;&gt;QTreeView&lt;/a&gt; 클래스 와 같은 항목보기에서 사용되는 헤더를 표시합니다 . 이전에 동일한 목적으로 사용 된 Qt3의 &lt;code&gt;QHeader&lt;/code&gt; 클래스를 대신 하지만 항목 뷰 클래스와의 일관성을 위해 Qt의 모델 / 뷰 아키텍처를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="5d68265bcca060bd3295a7b7b61c9c4f57d16358" translate="yes" xml:space="preserve">
          <source>A QIcon can generate smaller, larger, active, and disabled pixmaps from the set of pixmaps it is given. Such pixmaps are used by Qt widgets to show an icon representing a particular action.</source>
          <target state="translated">QIcon은 주어진 픽스맵 세트에서 더 작고, 더 크고, 활성화되고, 비활성화 된 픽스맵을 생성 할 수 있습니다. 이러한 픽스맵은 Qt 위젯에서 특정 작업을 나타내는 아이콘을 표시하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="65988c4b73f1cf1d0e9fc51ae91395569ed046ad" translate="yes" xml:space="preserve">
          <source>A QItemSelection describes the items in a model that have been selected by the user. A QItemSelection is basically a list of selection ranges, see &lt;a href=&quot;qitemselectionrange&quot;&gt;QItemSelectionRange&lt;/a&gt;. It provides functions for creating and manipulating selections, and selecting a range of items from a model.</source>
          <target state="translated">QItemSelection은 사용자가 선택한 모델의 항목을 설명합니다. QItemSelection은 기본적으로 선택 범위 목록입니다 . &lt;a href=&quot;qitemselectionrange&quot;&gt;QItemSelectionRange를&lt;/a&gt; 참조하십시오 . 선택 항목을 만들고 조작하고 모델에서 항목 범위를 선택하는 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="518abb545bf2d65964ac9f479b5970489e9ffc63" translate="yes" xml:space="preserve">
          <source>A QItemSelectionModel keeps track of the selected items in a view, or in several views onto the same model. It also keeps track of the currently selected item in a view.</source>
          <target state="translated">QItemSelectionModel은보기 또는 동일한 모델의 여러보기에서 선택한 항목을 추적합니다. 또한보기에서 현재 선택된 항목을 추적합니다.</target>
        </trans-unit>
        <trans-unit id="73b3ada3b241cd504c08576437fcacfdf94aca99" translate="yes" xml:space="preserve">
          <source>A QItemSelectionRange contains information about a range of selected items in a model. A range of items is a contiguous array of model items, extending to cover a number of adjacent rows and columns with a common parent item; this can be visualized as a two-dimensional block of cells in a table. A selection range has a &lt;a href=&quot;qitemselectionrange#top&quot;&gt;top&lt;/a&gt;(), &lt;a href=&quot;qitemselectionrange#left&quot;&gt;left&lt;/a&gt;() a &lt;a href=&quot;qitemselectionrange#bottom&quot;&gt;bottom&lt;/a&gt;(), &lt;a href=&quot;qitemselectionrange#right&quot;&gt;right&lt;/a&gt;() and a &lt;a href=&quot;qitemselectionrange#parent&quot;&gt;parent&lt;/a&gt;().</source>
          <target state="translated">QItemSelectionRange에는 모델에서 선택한 항목 범위에 대한 정보가 포함됩니다. 항목의 범위는 모델 항목의 연속 배열로, 공통 상위 항목이있는 인접 행과 열을 포함하도록 확장됩니다. 이것은 표에서 2 차원 셀 블록으로 시각화 할 수 있습니다. 선택 범위에는 &lt;a href=&quot;qitemselectionrange#top&quot;&gt;상단&lt;/a&gt; (), &lt;a href=&quot;qitemselectionrange#left&quot;&gt;왼쪽&lt;/a&gt; (), &lt;a href=&quot;qitemselectionrange#bottom&quot;&gt;하단&lt;/a&gt; (), &lt;a href=&quot;qitemselectionrange#right&quot;&gt;오른쪽&lt;/a&gt; () 및 &lt;a href=&quot;qitemselectionrange#parent&quot;&gt;상위&lt;/a&gt; ()가 있습니다.</target>
        </trans-unit>
        <trans-unit id="ebc6bc2ffd903df333ee726f93d5a2c2279e1fa2" translate="yes" xml:space="preserve">
          <source>A QIterator can only be created by a &lt;a href=&quot;qiterable&quot;&gt;QIterable&lt;/a&gt; instance, and can be used in a way similar to other stl-style iterators. Generally, QIterator should not be used directly, but through its derived classes provided by &lt;a href=&quot;qsequentialiterable&quot;&gt;QSequentialIterable&lt;/a&gt; and &lt;a href=&quot;qassociativeiterable&quot;&gt;QAssociativeIterable&lt;/a&gt;.</source>
          <target state="translated">QIterator는 &lt;a href=&quot;qiterable&quot;&gt;QIterable&lt;/a&gt; 인스턴스 에 의해서만 생성 될 수 있으며 다른 stl 스타일 반복자와 유사한 방식으로 사용될 수 있습니다. 일반적으로 QIterator는 직접 사용해서는 안되며 &lt;a href=&quot;qsequentialiterable&quot;&gt;QSequentialIterable&lt;/a&gt; 및 &lt;a href=&quot;qassociativeiterable&quot;&gt;QAssociativeIterable에서&lt;/a&gt; 제공하는 파생 클래스를 통해 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="6f698e185d0fa802a382e81fdb562daac71ad1f2" translate="yes" xml:space="preserve">
          <source>A QJsonArray can be converted to and from a &lt;a href=&quot;qvariant#QVariantList-typedef&quot;&gt;QVariantList&lt;/a&gt;. You can query the number of entries with &lt;a href=&quot;qjsonarray#size&quot;&gt;size&lt;/a&gt;(), &lt;a href=&quot;qjsonarray#insert&quot;&gt;insert&lt;/a&gt;(), and &lt;a href=&quot;qjsonarray#removeAt&quot;&gt;removeAt&lt;/a&gt;() entries from it and iterate over its content using the standard C++ iterator pattern.</source>
          <target state="translated">QJsonArray는로와 변환 할 수 있습니다 &lt;a href=&quot;qvariant#QVariantList-typedef&quot;&gt;QVariantList&lt;/a&gt; . &lt;a href=&quot;qjsonarray#size&quot;&gt;크기&lt;/a&gt; (), &lt;a href=&quot;qjsonarray#insert&quot;&gt;삽입&lt;/a&gt; () 및 &lt;a href=&quot;qjsonarray#removeAt&quot;&gt;removeAt&lt;/a&gt; () 항목 이있는 항목 수를 쿼리하고 표준 C ++ 반복기 패턴을 사용하여 해당 콘텐츠를 반복 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="37fad3d2e4b96bcfff4c717812b4359b268cfda3" translate="yes" xml:space="preserve">
          <source>A QJsonObject can be converted to and from a &lt;a href=&quot;qvariant#QVariantMap-typedef&quot;&gt;QVariantMap&lt;/a&gt;. You can query the number of (key, value) pairs with &lt;a href=&quot;qjsonobject#size&quot;&gt;size&lt;/a&gt;(), &lt;a href=&quot;qjsonobject#insert&quot;&gt;insert&lt;/a&gt;(), and &lt;a href=&quot;qjsonobject#remove&quot;&gt;remove&lt;/a&gt;() entries from it and iterate over its content using the standard C++ iterator pattern.</source>
          <target state="translated">QJsonObject는로와 변환 할 수 있습니다 &lt;a href=&quot;qvariant#QVariantMap-typedef&quot;&gt;QVariantMap&lt;/a&gt; . &lt;a href=&quot;qjsonobject#size&quot;&gt;크기&lt;/a&gt; (), &lt;a href=&quot;qjsonobject#insert&quot;&gt;삽입&lt;/a&gt; () 및 &lt;a href=&quot;qjsonobject#remove&quot;&gt;제거&lt;/a&gt; () 항목을 사용하여 (키, 값) 쌍의 수를 쿼리하고 표준 C ++ 반복기 패턴을 사용하여 해당 콘텐츠를 반복 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="11fab3a310bf798894f20b9a6ef2bffadec5bc73" translate="yes" xml:space="preserve">
          <source>A QLabel can contain any of the following content types:</source>
          <target state="translated">QLabel에는 다음 콘텐츠 유형이 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9838c671428cf7d2c2ed77e4a299fd9e884c912c" translate="yes" xml:space="preserve">
          <source>A QLabel is often used as a label for an interactive widget. For this use QLabel provides a useful mechanism for adding an mnemonic (see &lt;a href=&quot;qkeysequence&quot;&gt;QKeySequence&lt;/a&gt;) that will set the keyboard focus to the other widget (called the QLabel's &quot;buddy&quot;). For example:</source>
          <target state="translated">QLabel은 종종 대화 형 위젯의 레이블로 사용됩니다. 이를 위해 QLabel은 키보드 포커스를 다른 위젯 (QLabel의 &quot;친구&quot;라고 함)에 설정 하는 니모닉 ( &lt;a href=&quot;qkeysequence&quot;&gt;QKeySequence&lt;/a&gt; 참조 ) 을 추가하는 유용한 메커니즘을 제공합니다 . 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="7c7818e1dcbfa232fd6aceba09da3bd575523e1f" translate="yes" xml:space="preserve">
          <source>A QLayer can be applied to a subtree of entities by setting the recursive property to true.</source>
          <target state="translated">재귀 속성을 true로 설정하여 QLayer를 엔티티의 하위 트리에 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ff719ffa993afbe2ec3fe13adda3c0e4bb06764" translate="yes" xml:space="preserve">
          <source>A QLine describes a finite length line (or a line segment) on a two-dimensional surface. The start and end points of the line are specified using integer point accuracy for coordinates. Use the &lt;a href=&quot;qlinef&quot;&gt;QLineF&lt;/a&gt; constructor to retrieve a floating point copy.</source>
          <target state="translated">QLine은 2 차원 표면의 유한 길이 선 (또는 선 세그먼트)을 설명합니다. 선의 시작점과 끝점은 좌표의 정수 점 정확도를 사용하여 지정됩니다. &lt;a href=&quot;qlinef&quot;&gt;QLineF&lt;/a&gt; 생성자를 사용하여 부동 소수점 복사본을 검색합니다.</target>
        </trans-unit>
        <trans-unit id="c4663a2f553cf1e4a170d9206f1301ebb6a92ec5" translate="yes" xml:space="preserve">
          <source>A QLineF describes a finite length line (or line segment) on a two-dimensional surface. QLineF defines the start and end points of the line using floating point accuracy for coordinates. Use the &lt;a href=&quot;qlinef#toLine&quot;&gt;toLine&lt;/a&gt;() function to retrieve an integer based copy of this line.</source>
          <target state="translated">QLineF는 2 차원 표면의 유한 길이 선 (또는 선 세그먼트)을 설명합니다. QLineF는 좌표에 대한 부동 소수점 정확도를 사용하여 선의 시작점과 끝점을 정의합니다. &lt;a href=&quot;qlinef#toLine&quot;&gt;toLine&lt;/a&gt; () 함수를 사용 하여이 행의 정수 기반 사본을 검색하십시오.</target>
        </trans-unit>
        <trans-unit id="967596c1aa5cb88cc34b9f625c9d1769b1622ed8" translate="yes" xml:space="preserve">
          <source>A QListView presents items stored in a model, either as a simple non-hierarchical list, or as a collection of icons. This class is used to provide lists and icon views that were previously provided by the &lt;code&gt;QListBox&lt;/code&gt; and &lt;code&gt;QIconView&lt;/code&gt; classes, but using the more flexible approach provided by Qt's model/view architecture.</source>
          <target state="translated">QListView는 모델에 저장된 항목을 단순한 비 계층 적 목록 또는 아이콘 모음으로 표시합니다. 이 클래스는 이전에 &lt;code&gt;QListBox&lt;/code&gt; 및 &lt;code&gt;QIconView&lt;/code&gt; 클래스에서 제공 한 목록 및 아이콘보기를 제공하는 데 사용 되지만 Qt의 모델 /보기 아키텍처에서 제공하는보다 유연한 접근 방식을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="ad1e81fa41c5ec9b1ba6e98c17145c93e793be97" translate="yes" xml:space="preserve">
          <source>A QListWidgetItem represents a single item in a &lt;a href=&quot;qlistwidget&quot;&gt;QListWidget&lt;/a&gt;. Each item can hold several pieces of information, and will display them appropriately.</source>
          <target state="translated">QListWidgetItem는 단일 항목을 나타냅니다 &lt;a href=&quot;qlistwidget&quot;&gt;QListWidget을&lt;/a&gt; . 각 항목은 여러 정보를 보유 할 수 있으며 적절하게 표시합니다.</target>
        </trans-unit>
        <trans-unit id="d4de08028afeca51bba2d441b657b9c042ebce01" translate="yes" xml:space="preserve">
          <source>A QML API to display and manipulate client content, fully integrated with all the features in Qt Quick.</source>
          <target state="translated">Qt Quick의 모든 기능과 완전히 통합 된 클라이언트 컨텐츠를 표시하고 조작하기위한 QML API.</target>
        </trans-unit>
        <trans-unit id="920c0b4f7e34014d5d0913de7eccfc4f465607bc" translate="yes" xml:space="preserve">
          <source>A QML RSS news reader that uses XmlListModel and XmlRole to download XML data, ListModel and ListElement to create a category list, and ListView to display the data</source>
          <target state="translated">XmlListModel 및 XmlRole을 사용하여 XML 데이터, ListModel 및 ListElement를 다운로드하여 카테고리 목록을 작성하고 ListView를 사용하여 데이터를 표시하는 QML RSS 뉴스 리더</target>
        </trans-unit>
        <trans-unit id="e54c5336b8a18349545a05b51ae15cff8a6c1293" translate="yes" xml:space="preserve">
          <source>A QML app designed for portrait devices that uses custom components, animated with AnimationController, and JavaScript for the application logic</source>
          <target state="translated">사용자 지정 구성 요소를 사용하고 AnimationController로 애니메이션 처리 된 응용 프로그램 로직 용 JavaScript 및 응용 프로그램 논리 용 JavaScript를 지원하는 QML 앱</target>
        </trans-unit>
        <trans-unit id="8004934a3066d0207e27275b969c18a11d7b7dfa" translate="yes" xml:space="preserve">
          <source>A QML app for touch devices that uses a Repeater with a FolderListModel to access content in a folder, and a PinchArea that contains a MouseArea to handle pinch gestures on the fetched content</source>
          <target state="translated">FolderListModel과 함께 Repeater를 사용하여 폴더의 컨텐츠에 액세스하고 가져온 컨텐츠의 핀치 제스처를 처리하기 위해 MouseArea가 포함 된 PinchArea를 사용하는 터치 디바이스 용 QML 앱</target>
        </trans-unit>
        <trans-unit id="9f4df3538384dedcdd19700792266bc954f988c0" translate="yes" xml:space="preserve">
          <source>A QML clock application that demonstrates using a ListView type to display data generated by a ListModel and a SpringAnimation type to animate images</source>
          <target state="translated">ListView 유형을 사용하여 ListModel 및 SpringAnimation 유형으로 생성 된 데이터를 표시하여 이미지를 애니메이션으로 표시하는 QML 시계 애플리케이션</target>
        </trans-unit>
        <trans-unit id="616724e307e8f12c53414e21e101a8222ebc84dc" translate="yes" xml:space="preserve">
          <source>A QML document can be loaded with &lt;a href=&quot;qqmlcomponent&quot;&gt;QQmlComponent&lt;/a&gt; or &lt;a href=&quot;qquickview&quot;&gt;QQuickView&lt;/a&gt;. &lt;a href=&quot;qqmlcomponent&quot;&gt;QQmlComponent&lt;/a&gt; loads a QML document as a C++ object that can then be modified from C++ code. &lt;a href=&quot;qquickview&quot;&gt;QQuickView&lt;/a&gt; also does this, but as &lt;a href=&quot;qquickview&quot;&gt;QQuickView&lt;/a&gt; is a &lt;a href=&quot;qwindow&quot;&gt;QWindow&lt;/a&gt;-derived class, the loaded object will also be rendered into a visual display; &lt;a href=&quot;qquickview&quot;&gt;QQuickView&lt;/a&gt; is generally used to integrate a displayable QML object into an application's user interface.</source>
          <target state="translated">QML 문서는 &lt;a href=&quot;qqmlcomponent&quot;&gt;QQmlComponent&lt;/a&gt; 또는 &lt;a href=&quot;qquickview&quot;&gt;QQuickView&lt;/a&gt; 와 함께로드 할 수 있습니다 . &lt;a href=&quot;qqmlcomponent&quot;&gt;QQmlComponent&lt;/a&gt; 는 QML 문서를 C ++ 객체로로드 한 다음 C ++ 코드에서 수정할 수 있습니다. &lt;a href=&quot;qquickview&quot;&gt;QQuickView도이 작업&lt;/a&gt; 을 수행하지만 &lt;a href=&quot;qquickview&quot;&gt;QQuickView&lt;/a&gt; 는 &lt;a href=&quot;qwindow&quot;&gt;QWindow&lt;/a&gt; 파생 클래스이므로로드 된 객체도 시각적 디스플레이로 렌더링됩니다. &lt;a href=&quot;qquickview&quot;&gt;QQuickView&lt;/a&gt; 는 일반적으로 표시 가능한 QML 객체를 응용 프로그램의 사용자 인터페이스에 통합하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d9e63afaeacfd614132f2a447fcae1459655ca2d" translate="yes" xml:space="preserve">
          <source>A QML document defines a hierarchy of objects with a highly-readable, structured layout. Every QML document consists of two parts: an imports section and an object declaration section. The types and functionality most common to user interfaces are provided in the &lt;code&gt;QtQuick&lt;/code&gt; import.</source>
          <target state="translated">QML 문서는 읽기 쉽고 구조화 된 레이아웃으로 객체의 계층 구조를 정의합니다. 모든 QML 문서는 가져 오기 섹션과 객체 선언 섹션의 두 부분으로 구성됩니다. 사용자 인터페이스에 가장 일반적인 유형과 기능은 &lt;code&gt;QtQuick&lt;/code&gt; 가져 오기 에서 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="242bed9d8a0f4cf0d719c1931a26fe983eb22ea1" translate="yes" xml:space="preserve">
          <source>A QML document describes a hierarchy of objects which can be instantiated. Each object definition has a certain structure; it has a type, it can have an id and an object name, it can have properties, it can have methods, it can have signals and it can have signal handlers.</source>
          <target state="translated">QML 문서는 인스턴스화 할 수있는 객체의 계층 구조를 설명합니다. 각 객체 정의에는 특정 구조가 있습니다. 유형, ID 및 객체 이름, 속성, 메소드, 신호 및 신호 처리기를 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="62dbf738e9ce5c8c7bcc487815895002e287be71" translate="yes" xml:space="preserve">
          <source>A QML document is a self contained piece of QML source code that consists of two parts:</source>
          <target state="translated">QML 문서는 다음 두 부분으로 구성된 자체 포함 된 QML 소스 코드입니다.</target>
        </trans-unit>
        <trans-unit id="4dccaba1ba51386a450e990e51d3a751bf1e8a11" translate="yes" xml:space="preserve">
          <source>A QML document may have one or more imports at the top of the file. An import can be any one of:</source>
          <target state="translated">QML 문서는 파일 맨 위에 하나 이상의 가져 오기가있을 수 있습니다. 가져 오기는 다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0cc1d65d26ba3994c5339ac0c25f745e3f7e1ed6" translate="yes" xml:space="preserve">
          <source>A QML document may import a JavaScript resource with the following syntax:</source>
          <target state="translated">QML 문서는 다음 구문으로 JavaScript 리소스를 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="20ed64dc3e1b4d0ce15c8a5fa150d411fe45739b" translate="yes" xml:space="preserve">
          <source>A QML engine uses QNetworkAccessManager for all network access. By implementing a factory, it is possible to provide the QML engine with custom QNetworkAccessManager instances with specialized caching, proxy and cookies support.</source>
          <target state="translated">QML 엔진은 모든 네트워크 액세스에 QNetworkAccessManager를 사용합니다. 팩토리를 구현하면 특수 캐싱, 프록시 및 쿠키를 지원하는 사용자 정의 QNetworkAccessManager 인스턴스를 QML 엔진에 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b473bb0bf18e6c236f4330256adb358f9673bcf" translate="yes" xml:space="preserve">
          <source>A QML file must only contain &lt;b&gt;a single root object definition&lt;/b&gt;. The following is invalid and will generate an error:</source>
          <target state="translated">QML 파일은 &lt;b&gt;단일 루트 오브젝트 정의&lt;/b&gt; 만 포함해야합니다 . 다음은 유효하지 않으며 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8be433f78ce4c5edeffe46a21a6b3c376c973670" translate="yes" xml:space="preserve">
          <source>A QML implementation of the popular puzzle game by Kuniaki Moribe</source>
          <target state="translated">Kuniaki Moribe의 인기있는 퍼즐 게임의 QML 구현</target>
        </trans-unit>
        <trans-unit id="539c0efd0db71b943853d0a7aa8403072a1ede0c" translate="yes" xml:space="preserve">
          <source>A QML object emits the &lt;code&gt;Component.completed&lt;/code&gt;&lt;a href=&quot;qtqml-syntax-signals#attached-signal-handlers&quot;&gt;attached signal&lt;/a&gt; when its instantiation is complete. The JavaScript code in the corresponding &lt;code&gt;Component.onCompleted&lt;/code&gt; handler runs after the object is instantiated. Thus, the best place to write application startup code is in the &lt;code&gt;Component.onCompleted&lt;/code&gt; handler of the top-level object, because this object emits &lt;code&gt;Component.completed&lt;/code&gt; when the QML environment is fully established.</source>
          <target state="translated">QML 객체 는 인스턴스화가 완료되면 &lt;code&gt;Component.completed&lt;/code&gt; &lt;a href=&quot;qtqml-syntax-signals#attached-signal-handlers&quot;&gt;첨부 신호를&lt;/a&gt; 방출합니다 . 해당 &lt;code&gt;Component.onCompleted&lt;/code&gt; 핸들러 의 JavaScript 코드 는 객체가 인스턴스화 된 후에 실행됩니다. 따라서 응용 프로그램 시작 코드를 작성하는 가장 좋은 위치는 최상위 개체 의 &lt;code&gt;Component.onCompleted&lt;/code&gt; 처리기입니다.이 개체 는 QML 환경이 완전히 구축되면 &lt;code&gt;Component.completed&lt;/code&gt; 를 생성 하기 때문 입니다.</target>
        </trans-unit>
        <trans-unit id="333c8d8189fdf0930403963f1c665edd4ad03bc8" translate="yes" xml:space="preserve">
          <source>A QML object is an instance of a &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtqml-typesystem-topic.html&quot;&gt;QML Object Type&lt;/a&gt;.</source>
          <target state="translated">QML 객체는 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtqml-typesystem-topic.html&quot;&gt;QML 객체 유형&lt;/a&gt; 의 인스턴스입니다 .</target>
        </trans-unit>
        <trans-unit id="5f79bea2e6f6bcfc5764d748ae6fd7da040a9fb3" translate="yes" xml:space="preserve">
          <source>A QML object is an instance of a &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtqml-typesystem-topic.html&quot;&gt;QML Object Type&lt;/a&gt;.</source>
          <target state="translated">QML 객체는 &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtqml-typesystem-topic.html&quot;&gt;QML 객체 유형&lt;/a&gt; 의 인스턴스입니다 .</target>
        </trans-unit>
        <trans-unit id="570d308987515027e117ab1d22ae624fd7c4e92b" translate="yes" xml:space="preserve">
          <source>A QML object is an instance of a &lt;a href=&quot;https://doc.qt.io/qt-6.0/qtqml-typesystem-topic.html&quot;&gt;QML Object Type&lt;/a&gt;.</source>
          <target state="translated">QML 객체는 &lt;a href=&quot;https://doc.qt.io/qt-6.0/qtqml-typesystem-topic.html&quot;&gt;QML 객체 유형&lt;/a&gt; 의 인스턴스입니다 .</target>
        </trans-unit>
        <trans-unit id="f391b89dfabb207994996b227c973b15dcf1688d" translate="yes" xml:space="preserve">
          <source>A QML object may have different easing curve for each property animation. There are also different parameters to control the curve, some of which are exclusive to a particular curve. For more information about the easing curves, visit the &lt;a href=&quot;qml-qtquick-propertyanimation#easing.type-prop&quot;&gt;easing&lt;/a&gt; documentation.</source>
          <target state="translated">QML 객체는 속성 애니메이션마다 다른 여유 곡선을 가질 수 있습니다. 곡선을 제어하기위한 여러 가지 매개 변수가 있으며,이 중 일부는 특정 곡선에만 적용됩니다. 여유 곡선에 대한 자세한 내용은 &lt;a href=&quot;qml-qtquick-propertyanimation#easing.type-prop&quot;&gt;여유&lt;/a&gt; 문서를 방문하십시오 .</target>
        </trans-unit>
        <trans-unit id="7b53877a199a1106cd5c2bb807298898c87a9802" translate="yes" xml:space="preserve">
          <source>A QML object type in a signal parameter is translated to a pointer to the class in C++:</source>
          <target state="translated">신호 매개 변수의 QML 객체 유형은 C ++의 클래스에 대한 포인터로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="80c6fb55c7a79058748bf0dc23012dacc7206ef0" translate="yes" xml:space="preserve">
          <source>A QML object type is a type from which a QML object can be instantiated.</source>
          <target state="translated">QML 객체 유형은 QML 객체를 인스턴스화 할 수있는 유형입니다.</target>
        </trans-unit>
        <trans-unit id="4c794f68b80b692d9ea92bb08ab562c1a16fbd53" translate="yes" xml:space="preserve">
          <source>A QML photo viewer that that uses XmlListModel and XmlRole to download Flickr feeds, and Package to display the photos in different views</source>
          <target state="translated">XmlListModel 및 XmlRole을 사용하여 Flickr 피드를 다운로드하고 패키지를 사용하여 사진을 다른보기로 표시하는 QML 사진 뷰어</target>
        </trans-unit>
        <trans-unit id="f85edbe2905b66de1f8a748f75a3ba47e88a768f" translate="yes" xml:space="preserve">
          <source>A QML photo viewer that uses XmlListModel and XmlListModelRole custom QML types to download Flickr feeds, and Package to display the photos in different views</source>
          <target state="translated">XmlListModel 및 XmlListModelRole 사용자 정의 QML 유형을 사용하여 Flickr 피드를 다운로드하고 패키지를 사용하여 다른보기에 사진을 표시하는 QML 사진 뷰어</target>
        </trans-unit>
        <trans-unit id="1ecfeca3e456fd9ca4b0be00cce8b3b6c0278f99" translate="yes" xml:space="preserve">
          <source>A QML representation of a &lt;a href=&quot;qeventpoint&quot;&gt;QEventPoint&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qeventpoint&quot;&gt;QEventPoint&lt;/a&gt; 의 QML 표현입니다 .</target>
        </trans-unit>
        <trans-unit id="234fe6f91b7e4295045f671a76f0711f7dfeb2fa" translate="yes" xml:space="preserve">
          <source>A QML representation of a QQuickEventPoint.</source>
          <target state="translated">QQuickEventPoint의 QML 표현.</target>
        </trans-unit>
        <trans-unit id="650d09ef9f087d6167988ef44f38d68b485fed83" translate="yes" xml:space="preserve">
          <source>A QML type belongs to a</source>
          <target state="translated">QML 유형은</target>
        </trans-unit>
        <trans-unit id="c66f5ea9502e8b53f0f287aee8022c5ef463cd91" translate="yes" xml:space="preserve">
          <source>A QML type can be defined either by a document in a .qml file beginning with a capital letter, or by a &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;-based C++ class.</source>
          <target state="translated">QML 유형은 대문자로 시작하는 .qml 파일의 문서 또는 &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 기반 C ++ 클래스 로 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9c71035835e0cbb6343d3da945540441ca9c26ea" translate="yes" xml:space="preserve">
          <source>A QML type implementation may choose to &lt;a href=&quot;qtqml-cppintegration-definetypes#providing-attached-properties&quot;&gt;create an &lt;i&gt;attaching type&lt;/i&gt; in C++&lt;/a&gt; with particular properties and signals. Instances of this type can then be created and</source>
          <target state="translated">QML 유형 구현은 특정 특성 및 신호 를 &lt;a href=&quot;qtqml-cppintegration-definetypes#providing-attached-properties&quot;&gt;사용하여 C ++에서 &lt;i&gt;첨부 유형&lt;/i&gt;&lt;/a&gt; 을 작성 하도록 선택할 수 있습니다 . 그런 다음이 유형의 인스턴스를 작성하고</target>
        </trans-unit>
        <trans-unit id="64fe7a687144af32370cdd44b1d145b60823cbf4" translate="yes" xml:space="preserve">
          <source>A QMatrix object can be built using the &lt;a href=&quot;qmatrix#setMatrix&quot;&gt;setMatrix&lt;/a&gt;(), &lt;a href=&quot;qmatrix#scale&quot;&gt;scale&lt;/a&gt;(), &lt;a href=&quot;qmatrix#rotate&quot;&gt;rotate&lt;/a&gt;(), &lt;a href=&quot;qmatrix#translate&quot;&gt;translate&lt;/a&gt;() and &lt;a href=&quot;qmatrix#shear&quot;&gt;shear&lt;/a&gt;() functions. Alternatively, it can be built by applying &lt;a href=&quot;qmatrix#basic-matrix-operations&quot;&gt;basic matrix operations&lt;/a&gt;. The matrix can also be defined when constructed, and it can be reset to the identity matrix (the default) using the &lt;a href=&quot;qmatrix#reset&quot;&gt;reset&lt;/a&gt;() function.</source>
          <target state="translated">QMatrix 객체는 &lt;a href=&quot;qmatrix#setMatrix&quot;&gt;setMatrix&lt;/a&gt; (), &lt;a href=&quot;qmatrix#scale&quot;&gt;scale&lt;/a&gt; (), &lt;a href=&quot;qmatrix#rotate&quot;&gt;rotate&lt;/a&gt; (), &lt;a href=&quot;qmatrix#translate&quot;&gt;translate&lt;/a&gt; () 및 &lt;a href=&quot;qmatrix#shear&quot;&gt;shear&lt;/a&gt; () 함수를 사용하여 만들 수 있습니다 . 또는 &lt;a href=&quot;qmatrix#basic-matrix-operations&quot;&gt;기본 행렬 연산&lt;/a&gt; 을 적용하여 만들 수 있습니다 . 행렬은 생성 될 때 정의 될 수도 있으며 &lt;a href=&quot;qmatrix#reset&quot;&gt;reset&lt;/a&gt; () 함수를 사용하여 단위 행렬 (기본값)로 재설정 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="61e6fffe90e5d27ff7e5166188f87fa1834f3bf0" translate="yes" xml:space="preserve">
          <source>A QMatrix object contains a 3 x 3 matrix. The &lt;code&gt;dx&lt;/code&gt; and &lt;code&gt;dy&lt;/code&gt; elements specify horizontal and vertical translation. The &lt;code&gt;m11&lt;/code&gt; and &lt;code&gt;m22&lt;/code&gt; elements specify horizontal and vertical scaling. And finally, the &lt;code&gt;m21&lt;/code&gt; and &lt;code&gt;m12&lt;/code&gt; elements specify horizontal and vertical</source>
          <target state="translated">QMatrix 객체는 3 x 3 행렬을 포함합니다. &lt;code&gt;dx&lt;/code&gt; 와 &lt;code&gt;dy&lt;/code&gt; 요소는 수평 및 수직 변환을 지정합니다. &lt;code&gt;m11&lt;/code&gt; 및 &lt;code&gt;m22&lt;/code&gt; 요소는 수평 및 수직 스케일을 지정. 마지막으로 &lt;code&gt;m21&lt;/code&gt; 및 &lt;code&gt;m12&lt;/code&gt; 요소는 수평 및 수직을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="85e8e7436fc9a16db6c63598ea1043da487b2fe0" translate="yes" xml:space="preserve">
          <source>A QMenu can also provide a tear-off menu. A tear-off menu is a top-level window that contains a copy of the menu. This makes it possible for the user to &quot;tear off&quot; frequently used menus and position them in a convenient place on the screen. If you want this functionality for a particular menu, insert a tear-off handle with &lt;a href=&quot;qmenu#tearOffEnabled-prop&quot;&gt;setTearOffEnabled&lt;/a&gt;(). When using tear-off menus, bear in mind that the concept isn't typically used on Microsoft Windows so some users may not be familiar with it. Consider using a &lt;a href=&quot;qtoolbar&quot;&gt;QToolBar&lt;/a&gt; instead.</source>
          <target state="translated">QMenu는 분리 메뉴도 제공 할 수 있습니다. 분리 메뉴는 메뉴 사본이 포함 된 최상위 창입니다. 이를 통해 사용자는 자주 사용하는 메뉴를 &quot;분리&quot;하여 화면의 편리한 위치에 배치 할 수 있습니다. 특정 메뉴에이 기능을 사용 &lt;a href=&quot;qmenu#tearOffEnabled-prop&quot;&gt;하려면 setTearOffEnabled&lt;/a&gt; ()를 사용하여 분리 핸들을 삽입하십시오 . 분리 메뉴를 사용할 때이 개념은 일반적으로 Microsoft Windows에서 사용되지 않으므로 일부 사용자는 익숙하지 않을 수 있습니다. 대신 &lt;a href=&quot;qtoolbar&quot;&gt;QToolBar&lt;/a&gt; 사용을 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="acecd2bd11a2e6daf62bdfbc148fbef8a98706fb" translate="yes" xml:space="preserve">
          <source>A QMetaMethod has a &lt;a href=&quot;qmetamethod#methodType&quot;&gt;methodType&lt;/a&gt;(), a &lt;a href=&quot;qmetamethod#methodSignature&quot;&gt;methodSignature&lt;/a&gt;(), a list of &lt;a href=&quot;qmetamethod#parameterTypes&quot;&gt;parameterTypes&lt;/a&gt;() and &lt;a href=&quot;qmetamethod#parameterNames&quot;&gt;parameterNames&lt;/a&gt;(), a return &lt;a href=&quot;qmetamethod#typeName&quot;&gt;typeName&lt;/a&gt;(), a &lt;a href=&quot;qmetamethod#tag&quot;&gt;tag&lt;/a&gt;(), and an &lt;a href=&quot;qmetamethod#access&quot;&gt;access&lt;/a&gt;() specifier. You can use &lt;a href=&quot;qmetamethod#invoke&quot;&gt;invoke&lt;/a&gt;() to invoke the method on an arbitrary &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;.</source>
          <target state="translated">QMetaMethod는 보유 &lt;a href=&quot;qmetamethod#methodType&quot;&gt;methodType&lt;/a&gt; ()와, &lt;a href=&quot;qmetamethod#methodSignature&quot;&gt;methodSignature&lt;/a&gt; ()의 목록 &lt;a href=&quot;qmetamethod#parameterTypes&quot;&gt;parameterTypes와&lt;/a&gt; () 및 &lt;a href=&quot;qmetamethod#parameterNames&quot;&gt;parameterNames&lt;/a&gt; (), 리턴 &lt;a href=&quot;qmetamethod#typeName&quot;&gt;유형 이름&lt;/a&gt; ()와, &lt;a href=&quot;qmetamethod#tag&quot;&gt;태그&lt;/a&gt; (), 및 &lt;a href=&quot;qmetamethod#access&quot;&gt;액세스&lt;/a&gt; ()을 지정. &lt;a href=&quot;qmetamethod#invoke&quot;&gt;invoke&lt;/a&gt; ()를 사용 하여 임의의 &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 에서 메서드를 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e79d4497d1ed9d6b81d93c54f3f50ecec990e5d1" translate="yes" xml:space="preserve">
          <source>A QModelRoleData object is typically created by views or delegates, setting which role they want to fetch the data for. The object is then passed to models (see &lt;a href=&quot;qabstractitemmodel#multiData&quot;&gt;QAbstractItemModel::multiData&lt;/a&gt;()), which populate the data corresponding to the role stored. Finally, the view visualizes the data retrieved from the model.</source>
          <target state="translated">QModelRoleData 객체는 일반적으로 뷰 또는 델리게이트에 의해 생성되며 데이터를 가져 오려는 역할을 설정합니다. 그런 다음 객체는 저장된 역할에 해당하는 데이터를 채우는 모델로 전달됩니다 ( &lt;a href=&quot;qabstractitemmodel#multiData&quot;&gt;QAbstractItemModel :: multiData&lt;/a&gt; () 참조). 마지막으로 뷰는 모델에서 검색된 데이터를 시각화합니다.</target>
        </trans-unit>
        <trans-unit id="9b94c45362e4ccc65bcd60480e7b418a31734269" translate="yes" xml:space="preserve">
          <source>A QModelRoleDataSpan is used as an abstraction over an array of &lt;a href=&quot;qmodelroledata&quot;&gt;QModelRoleData&lt;/a&gt; objects.</source>
          <target state="translated">QModelRoleDataSpan은 &lt;a href=&quot;qmodelroledata&quot;&gt;QModelRoleData&lt;/a&gt; 객체 배열에 대한 추상화로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="313764b1d88ba401430cc27a7ead741e44bba025" translate="yes" xml:space="preserve">
          <source>A QMouseDevice delegates mouse events from physical mouse device to &lt;a href=&quot;qt3dinput-qmousehandler&quot;&gt;QMouseHandler&lt;/a&gt; objects. The sensitivity of the mouse can be controlled with the &lt;a href=&quot;qt3dinput-qmousedevice#sensitivity-prop&quot;&gt;QMouseDevice::sensitivity&lt;/a&gt; property, which specifies the rate in which the logical mouse coordinates change in response to physical movement of the mouse.</source>
          <target state="translated">QMouseDevice는 물리적 마우스 장치에서 &lt;a href=&quot;qt3dinput-qmousehandler&quot;&gt;QMouseHandler&lt;/a&gt; 객체로 마우스 이벤트를 위임 합니다. 마우스의 감도는 &lt;a href=&quot;qt3dinput-qmousedevice#sensitivity-prop&quot;&gt;QMouseDevice :: sensitivity&lt;/a&gt; 속성 으로 제어 할 수 있습니다.이 속성은 마우스의 물리적 움직임에 따라 논리적 마우스 좌표가 변경되는 속도를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="f101d2ad055e10b0bc2103ff536a4560502bec98" translate="yes" xml:space="preserve">
          <source>A QMultiMap allows multiple values per key. If you call &lt;a href=&quot;qmultimap#insert&quot;&gt;insert&lt;/a&gt;() with a key that already exists in the map, a new (key, value) pair will be inserted. For example:</source>
          <target state="translated">QMultiMap은 키당 여러 값을 허용합니다. 맵에 이미 존재하는 키로 &lt;a href=&quot;qmultimap#insert&quot;&gt;insert&lt;/a&gt; () 를 호출 하면 새로운 (key, value) 쌍이 삽입됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2e8582a55fc71487d6fe5501c5743f08c3e86213" translate="yes" xml:space="preserve">
          <source>A QNX Neutrino RTOS target used for development with Qt Creator should provide a few additional command line tools and services.</source>
          <target state="translated">Qt Creator 개발에 사용되는 QNX Neutrino RTOS 대상은 몇 가지 추가 명령 줄 도구 및 서비스를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="d888703031bc66846480714acdf560a406c6af36" translate="yes" xml:space="preserve">
          <source>A QNdefMessage is a collection of 0 or more QNdefRecords. QNdefMessage inherits from &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt;&amp;lt;&lt;a href=&quot;qndefrecord&quot;&gt;QNdefRecord&lt;/a&gt;&amp;gt; and therefore the standard &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt; functions can be used to manipulate the NDEF records in the message.</source>
          <target state="translated">QNdefMessage는 0 개 이상의 QNdefRecords 모음입니다. QNdefMessage는 &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt; &amp;lt; &lt;a href=&quot;qndefrecord&quot;&gt;QNdefRecord&lt;/a&gt; &amp;gt; 에서 상속 되므로 표준 &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt; 함수를 사용하여 메시지의 NDEF 레코드를 조작 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="250f6360fe5b1679d80dd93a51a0253b6d96a721" translate="yes" xml:space="preserve">
          <source>A QNetworkSession enables control over the system's network interfaces. The session's configuration parameter are determined via the &lt;a href=&quot;qnetworkconfiguration&quot;&gt;QNetworkConfiguration&lt;/a&gt; object to which it is bound. Depending on the type of the session (single access point or service network) a session may be linked to one or more network interfaces. By means of &lt;a href=&quot;qnetworksession#open&quot;&gt;opening&lt;/a&gt; and &lt;a href=&quot;qnetworksession#close&quot;&gt;closing&lt;/a&gt; of network sessions a developer can start and stop the systems network interfaces. If the configuration represents multiple access points (see &lt;a href=&quot;qnetworkconfiguration#Type-enum&quot;&gt;QNetworkConfiguration::ServiceNetwork&lt;/a&gt;) more advanced features such as roaming may be supported.</source>
          <target state="translated">QNetworkSession을 사용하면 시스템의 네트워크 인터페이스를 제어 할 수 있습니다. 세션의 구성 매개 변수 는 바인딩 된 &lt;a href=&quot;qnetworkconfiguration&quot;&gt;QNetworkConfiguration&lt;/a&gt; 객체를 통해 결정됩니다 . 세션 유형 (단일 액세스 포인트 또는 서비스 네트워크)에 따라 세션이 하나 이상의 네트워크 인터페이스에 연결될 수 있습니다. 의하여 &lt;a href=&quot;qnetworksession#open&quot;&gt;개방&lt;/a&gt; 및 &lt;a href=&quot;qnetworksession#close&quot;&gt;폐쇄&lt;/a&gt; 네트워크 세션의 현상 시작 및 시스템의 네트워크 인터페이스를 중지 할 수있다. 구성이 여러 액세스 포인트를 나타내는 경우 ( &lt;a href=&quot;qnetworkconfiguration#Type-enum&quot;&gt;QNetworkConfiguration :: ServiceNetwork&lt;/a&gt; 참조 ) 로밍과 같은 고급 기능이 지원 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="319376b16abf63d6d643ec7d60926bab1ce80c20" translate="yes" xml:space="preserve">
          <source>A QNmeaPositionInfoSource instance operates in either &lt;a href=&quot;qnmeapositioninfosource#UpdateMode-enum&quot;&gt;RealTimeMode&lt;/a&gt; or &lt;a href=&quot;qnmeapositioninfosource#UpdateMode-enum&quot;&gt;SimulationMode&lt;/a&gt;. These modes allow NMEA data to be read from either a live source of positional data, or replayed for simulation purposes from previously recorded NMEA data.</source>
          <target state="translated">QNmeaPositionInfoSource 인스턴스는 &lt;a href=&quot;qnmeapositioninfosource#UpdateMode-enum&quot;&gt;RealTimeMode&lt;/a&gt; 또는 &lt;a href=&quot;qnmeapositioninfosource#UpdateMode-enum&quot;&gt;SimulationMode&lt;/a&gt; 에서 작동합니다 . 이러한 모드를 사용하면 위치 데이터의 라이브 소스에서 NMEA 데이터를 읽거나 이전에 기록 된 NMEA 데이터에서 시뮬레이션 목적으로 재생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="832f54b13d1265a6c8a9f91b3839ad18c4e24ee0" translate="yes" xml:space="preserve">
          <source>A QObject instance is said to have a</source>
          <target state="translated">QObject 인스턴스는</target>
        </trans-unit>
        <trans-unit id="b399ff9d77160c2d45c564a257788cbafaad1ce1" translate="yes" xml:space="preserve">
          <source>A QObjectCleanupHandler is useful whenever you need to know when a number of &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;s that are owned by someone else have been deleted. This is important, for example, when referencing memory in an application that has been allocated in a shared library.</source>
          <target state="translated">QObjectCleanupHandler는 다른 사람이 소유 한 여러 &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 가 삭제 된 시기를 알아야 할 때 유용합니다 . 예를 들어 공유 라이브러리에 할당 된 애플리케이션의 메모리를 참조 할 때 이는 중요합니다.</target>
        </trans-unit>
        <trans-unit id="990efc4a9df8cdbd2b4f066c33b26982cf9b2e25" translate="yes" xml:space="preserve">
          <source>A QPageSize instance may also be obtained by querying the supported page sizes for a print device. In this case the localized name returned is that defined by the printer itself. Note that the print device may not support the current default locale language.</source>
          <target state="translated">QPageSize 인스턴스는 인쇄 장치에 대해 지원되는 페이지 크기를 쿼리하여 얻을 수도 있습니다. 이 경우 반환 된 지역화 된 이름은 프린터 자체에서 정의한 이름입니다. 인쇄 장치가 현재 기본 로케일 언어를 지원하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6902d24ae5cd671aad21ed6be1f36bf86c3cedbb" translate="yes" xml:space="preserve">
          <source>A QPaintedTextureImage must be subclassed and the virtual &lt;a href=&quot;qt3drender-qpaintedtextureimage#paint&quot;&gt;paint&lt;/a&gt;() function implemented. Each time &lt;a href=&quot;qt3drender-qpaintedtextureimage#update&quot;&gt;update&lt;/a&gt;() is called on the QPaintedTextureImage, the &lt;a href=&quot;qt3drender-qpaintedtextureimage#paint&quot;&gt;paint&lt;/a&gt;() function is invoked and the resulting image is uploaded.</source>
          <target state="translated">QPaintedTextureImage는 서브 클래 싱되고 가상 &lt;a href=&quot;qt3drender-qpaintedtextureimage#paint&quot;&gt;페인트&lt;/a&gt; () 함수가 구현되어야합니다. 마다 &lt;a href=&quot;qt3drender-qpaintedtextureimage#update&quot;&gt;업데이트&lt;/a&gt; ()를 QPaintedTextureImage에 호출되는 &lt;a href=&quot;qt3drender-qpaintedtextureimage#paint&quot;&gt;페인트&lt;/a&gt; () 함수가 호출되고 결과 이미지가 업로드됩니다.</target>
        </trans-unit>
        <trans-unit id="2566fb1a6815b69cc052840c244f0791d0ab3e8a" translate="yes" xml:space="preserve">
          <source>A QPaintedTextureImage provides a way to specify a texture image (and thus an OpenGL texture) through a &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt;. The width and height of the texture image can be specified through the width and height or size properties.</source>
          <target state="translated">QPaintedTextureImage는 &lt;a href=&quot;qpainter&quot;&gt;QPainter를&lt;/a&gt; 통해 텍스처 이미지 (따라서 OpenGL 텍스처)를 지정하는 방법을 제공합니다 . 텍스처 이미지의 너비와 높이는 너비와 높이 또는 크기 속성을 통해 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="25d3ef2e88e359b9ad18ac55848b27a16dde6d14" translate="yes" xml:space="preserve">
          <source>A QPainterPath object can be constructed as an empty path, with a given start point, or as a copy of another QPainterPath object. Once created, lines and curves can be added to the path using the &lt;a href=&quot;qpainterpath#lineTo&quot;&gt;lineTo&lt;/a&gt;(), &lt;a href=&quot;qpainterpath#arcTo&quot;&gt;arcTo&lt;/a&gt;(), &lt;a href=&quot;qpainterpath#cubicTo&quot;&gt;cubicTo&lt;/a&gt;() and &lt;a href=&quot;qpainterpath#quadTo&quot;&gt;quadTo&lt;/a&gt;() functions. The lines and curves stretch from the &lt;a href=&quot;qpainterpath#currentPosition&quot;&gt;currentPosition&lt;/a&gt;() to the position passed as argument.</source>
          <target state="translated">QPainterPath 개체는 지정된 시작 지점이있는 빈 경로 또는 다른 QPainterPath 개체의 복사본으로 구성 될 수 있습니다. 일단 생성되면 &lt;a href=&quot;qpainterpath#lineTo&quot;&gt;lineTo&lt;/a&gt; (), &lt;a href=&quot;qpainterpath#arcTo&quot;&gt;arcTo&lt;/a&gt; (), &lt;a href=&quot;qpainterpath#cubicTo&quot;&gt;cubicTo&lt;/a&gt; () 및 &lt;a href=&quot;qpainterpath#quadTo&quot;&gt;quadTo&lt;/a&gt; () 함수를 사용하여 경로에 선과 곡선을 추가 할 수 있습니다 . 선과 곡선은 &lt;a href=&quot;qpainterpath#currentPosition&quot;&gt;currentPosition&lt;/a&gt; ()에서 인수로 전달 된 위치 까지 늘어납니다 .</target>
        </trans-unit>
        <trans-unit id="22e47ddc11ccdc5ed8a4574782006a5a1786a3ea" translate="yes" xml:space="preserve">
          <source>A QPainterPath object can be used for filling, outlining, and clipping. To generate fillable outlines for a given painter path, use the &lt;a href=&quot;qpainterpathstroker&quot;&gt;QPainterPathStroker&lt;/a&gt; class. The main advantage of painter paths over normal drawing operations is that complex shapes only need to be created once; then they can be drawn many times using only calls to the &lt;a href=&quot;qpainter#drawPath&quot;&gt;QPainter::drawPath&lt;/a&gt;() function.</source>
          <target state="translated">QPainterPath 객체는 채우기, 개요 및 클리핑에 사용할 수 있습니다. 주어진 페인터 경로에 대해 채울 수있는 윤곽선을 생성하려면 &lt;a href=&quot;qpainterpathstroker&quot;&gt;QPainterPathStroker&lt;/a&gt; 클래스를 사용하십시오 . 일반적인 그리기 작업에 비해 Painter 경로의 주요 이점은 복잡한 모양을 한 번만 만들면된다는 것입니다. 그런 다음 &lt;a href=&quot;qpainter#drawPath&quot;&gt;QPainter :: drawPath&lt;/a&gt; () 함수 에 대한 호출 만 사용하여 여러 번 그릴 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="be07c2fdd480831be20c96c0264402aad66070b6" translate="yes" xml:space="preserve">
          <source>A QParameter can be referenced by a &lt;a href=&quot;qt3drender-qrenderpass&quot;&gt;QRenderPass&lt;/a&gt;, &lt;a href=&quot;qt3drender-qtechnique&quot;&gt;QTechnique&lt;/a&gt;, &lt;a href=&quot;qt3drender-qeffect&quot;&gt;QEffect&lt;/a&gt;, &lt;a href=&quot;qt3drender-qmaterial&quot;&gt;QMaterial&lt;/a&gt;, &lt;a href=&quot;qt3drender-qtechniquefilter&quot;&gt;QTechniqueFilter&lt;/a&gt;, &lt;a href=&quot;qt3drender-qrenderpassfilter&quot;&gt;QRenderPassFilter&lt;/a&gt;. At runtime, depending on which shader is selected for a given step of the rendering, the value contained in a QParameter will be converted and uploaded if the shader contains a uniform with a name matching that of the QParameter.</source>
          <target state="translated">QParameter는 &lt;a href=&quot;qt3drender-qrenderpass&quot;&gt;QRenderPass&lt;/a&gt; , &lt;a href=&quot;qt3drender-qtechnique&quot;&gt;QTechnique&lt;/a&gt; , &lt;a href=&quot;qt3drender-qeffect&quot;&gt;QEffect&lt;/a&gt; , &lt;a href=&quot;qt3drender-qmaterial&quot;&gt;QMaterial&lt;/a&gt; , &lt;a href=&quot;qt3drender-qtechniquefilter&quot;&gt;QTechniqueFilter&lt;/a&gt; , &lt;a href=&quot;qt3drender-qrenderpassfilter&quot;&gt;QRenderPassFilter에서&lt;/a&gt; 참조 할 수 있습니다 . 런타임시, 렌더링의 주어진 단계에 대해 선택된 셰이더에 따라 셰이더에 QParameter의 이름과 일치하는 이름을 가진 유니폼이 포함되어 있으면 QParameter에 포함 된 값이 변환되고 업로드됩니다.</target>
        </trans-unit>
        <trans-unit id="832d50518997f23c2396c477c0f399981bfa817b" translate="yes" xml:space="preserve">
          <source>A QPartialOrdering value which represents an unordered result will always return false when compared against literal 0.</source>
          <target state="translated">정렬되지 않은 결과를 나타내는 QPartialOrdering 값은 리터럴 0과 비교할 때 항상 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="76a44b34ad4309efa51a0e71aa24b22605267651" translate="yes" xml:space="preserve">
          <source>A QPersistentModelIndex is a model index that can be stored by an application, and later used to access information in a model. Unlike the &lt;a href=&quot;qmodelindex&quot;&gt;QModelIndex&lt;/a&gt; class, it is safe to store a QPersistentModelIndex since the model will ensure that references to items will continue to be valid as long as they can be accessed by the model.</source>
          <target state="translated">QPersistentModelIndex는 애플리케이션에 의해 저장 될 수있는 모델 색인이며 나중에 모델의 정보에 액세스하는 데 사용됩니다. &lt;a href=&quot;qmodelindex&quot;&gt;QModelIndex&lt;/a&gt; 클래스 와 달리, 모델이 항목에 대한 참조가 모델에서 액세스 할 수있는 한 계속 유효하도록 보장하므로 QPersistentModelIndex를 저장하는 것이 안전합니다.</target>
        </trans-unit>
        <trans-unit id="614fa4ac9c3e9db873211bdf417619e12b650e30" translate="yes" xml:space="preserve">
          <source>A QPixmap can easily be displayed on the screen using &lt;a href=&quot;qlabel&quot;&gt;QLabel&lt;/a&gt; or one of &lt;a href=&quot;qabstractbutton&quot;&gt;QAbstractButton&lt;/a&gt;'s subclasses (such as &lt;a href=&quot;qpushbutton&quot;&gt;QPushButton&lt;/a&gt; and &lt;a href=&quot;qtoolbutton&quot;&gt;QToolButton&lt;/a&gt;). &lt;a href=&quot;qlabel&quot;&gt;QLabel&lt;/a&gt; has a pixmap property, whereas &lt;a href=&quot;qabstractbutton&quot;&gt;QAbstractButton&lt;/a&gt; has an icon property.</source>
          <target state="translated">&lt;a href=&quot;qlabel&quot;&gt;QLabel&lt;/a&gt; 또는 &lt;a href=&quot;qabstractbutton&quot;&gt;QAbstractButton&lt;/a&gt; 의 하위 클래스 (예 : &lt;a href=&quot;qpushbutton&quot;&gt;QPushButton&lt;/a&gt; 및 &lt;a href=&quot;qtoolbutton&quot;&gt;QToolButton&lt;/a&gt; ) 중 하나를 사용하여 QPixmap을 화면에 쉽게 표시 할 수 있습니다 . &lt;a href=&quot;qlabel&quot;&gt;QLabel&lt;/a&gt; 에는 pixmap 속성이있는 반면 &lt;a href=&quot;qabstractbutton&quot;&gt;QAbstractButton&lt;/a&gt; 에는 icon 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="614c3b02a8ab3e3379d0034820e83aa45a07a540" translate="yes" xml:space="preserve">
          <source>A QPixmap can easily be displayed on the screen using &lt;a href=&quot;qlabel&quot;&gt;QLabel&lt;/a&gt; or one of &lt;a href=&quot;widgets-changes-qt6#qabstractbutton&quot;&gt;QAbstractButton&lt;/a&gt;'s subclasses (such as &lt;a href=&quot;qpushbutton&quot;&gt;QPushButton&lt;/a&gt; and &lt;a href=&quot;qtoolbutton&quot;&gt;QToolButton&lt;/a&gt;). &lt;a href=&quot;qlabel&quot;&gt;QLabel&lt;/a&gt; has a pixmap property, whereas &lt;a href=&quot;widgets-changes-qt6#qabstractbutton&quot;&gt;QAbstractButton&lt;/a&gt; has an icon property.</source>
          <target state="translated">&lt;a href=&quot;qlabel&quot;&gt;QLabel&lt;/a&gt; 또는 &lt;a href=&quot;widgets-changes-qt6#qabstractbutton&quot;&gt;QAbstractButton&lt;/a&gt; 의 하위 클래스 (예 : &lt;a href=&quot;qpushbutton&quot;&gt;QPushButton&lt;/a&gt; 및 &lt;a href=&quot;qtoolbutton&quot;&gt;QToolButton&lt;/a&gt; ) 중 하나를 사용하여 QPixmap을 화면에 쉽게 표시 할 수 있습니다 . &lt;a href=&quot;qlabel&quot;&gt;QLabel&lt;/a&gt; 에는 pixmap 속성이있는 반면 &lt;a href=&quot;widgets-changes-qt6#qabstractbutton&quot;&gt;QAbstractButton&lt;/a&gt; 에는 아이콘 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e3aab2b4335cdf9725aa739cd574529d4571e5c" translate="yes" xml:space="preserve">
          <source>A QPixmap object can be converted into a &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt; using the &lt;a href=&quot;qpixmap#toImage&quot;&gt;toImage&lt;/a&gt;() function. Likewise, a &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt; can be converted into a QPixmap using the &lt;a href=&quot;qpixmap#fromImage&quot;&gt;fromImage&lt;/a&gt;(). If this is too expensive an operation, you can use &lt;a href=&quot;qbitmap#fromImage&quot;&gt;QBitmap::fromImage&lt;/a&gt;() instead.</source>
          <target state="translated">&lt;a href=&quot;qpixmap#toImage&quot;&gt;toImage&lt;/a&gt; () 함수를 사용하여 QPixmap 객체를 &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt; 로 변환 할 수 있습니다 . 마찬가지로 &lt;a href=&quot;qpixmap#fromImage&quot;&gt;fromImage&lt;/a&gt; ()를 사용하여 &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt; 를 QPixmap으로 변환 할 수 있습니다 . 이 작업이 너무 비싸다면 대신 &lt;a href=&quot;qbitmap#fromImage&quot;&gt;QBitmap :: fromImage&lt;/a&gt; ()를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f3a574af281c651c07783733224fdc24c07c27c0" translate="yes" xml:space="preserve">
          <source>A QPlaceAttribute instance stores an additional piece of information about a place that is not otherwise exposed through the &lt;a href=&quot;qplace&quot;&gt;QPlace&lt;/a&gt; class. A QPlaceAttribute encapsulates a localized label which describes the attribute and rich text string representing the attribute's value. Generally, both are intended to be displayed to the end-user as is.</source>
          <target state="translated">QPlaceAttribute 인스턴스는 &lt;a href=&quot;qplace&quot;&gt;QPlace&lt;/a&gt; 클래스를 통해 노출되지 않는 장소에 대한 추가 정보를 저장합니다 . QPlaceAttribute는 속성을 설명하는 지역화 된 레이블과 속성의 값을 나타내는 서식있는 텍스트 문자열을 캡슐화합니다. 일반적으로 둘 다 최종 사용자에게있는 그대로 표시되도록되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a1b1ebc85a3883cdd8e8c6c7c9c6a52f6666caa" translate="yes" xml:space="preserve">
          <source>A QPlainTextDocumentLayout is required for text documents that can be display or edited in a &lt;a href=&quot;qplaintextedit&quot;&gt;QPlainTextEdit&lt;/a&gt;. See &lt;a href=&quot;qtextdocument#setDocumentLayout&quot;&gt;QTextDocument::setDocumentLayout&lt;/a&gt;().</source>
          <target state="translated">QPlainTextDocumentLayout는 디스플레이 또는 편집 할 수있는 텍스트 문서에 필요 &lt;a href=&quot;qplaintextedit&quot;&gt;QPlainTextEdit&lt;/a&gt; . &lt;a href=&quot;qtextdocument#setDocumentLayout&quot;&gt;QTextDocument :: setDocumentLayout&lt;/a&gt; ()을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1fbb278eadd981bf3870bb57cd2a398c380b66dd" translate="yes" xml:space="preserve">
          <source>A QPoint object can also be used as a vector: Addition and subtraction are defined as for vectors (each component is added separately). A QPoint object can also be divided or multiplied by an &lt;code&gt;int&lt;/code&gt; or a &lt;code&gt;qreal&lt;/code&gt;.</source>
          <target state="translated">QPoint 객체는 벡터로도 사용할 수 있습니다. 덧셈과 뺄셈은 벡터에 대해 정의됩니다 (각 구성 요소가 개별적으로 추가됨). QPoint 객체는 &lt;code&gt;int&lt;/code&gt; 또는 &lt;code&gt;qreal&lt;/code&gt; 로 나누거나 곱할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e630e504a26a4833d02ac325dc3dccc9123f40d0" translate="yes" xml:space="preserve">
          <source>A QPointF object can also be used as a vector: Addition and subtraction are defined as for vectors (each component is added separately). A QPointF object can also be divided or multiplied by an &lt;code&gt;int&lt;/code&gt; or a &lt;code&gt;qreal&lt;/code&gt;.</source>
          <target state="translated">QPointF 객체는 벡터로도 사용할 수 있습니다. 덧셈과 뺄셈은 벡터에 대해 정의됩니다 (각 구성 요소는 개별적으로 추가됨). QPointF 객체는 &lt;code&gt;int&lt;/code&gt; 또는 &lt;code&gt;qreal&lt;/code&gt; 로 나누거나 곱할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="13a30c66edf76001ffe580856f83c2641f9018a0" translate="yes" xml:space="preserve">
          <source>A QPolygon object is a &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt;&amp;lt;&lt;a href=&quot;qpoint&quot;&gt;QPoint&lt;/a&gt;&amp;gt;. The easiest way to add points to a QPolygon is to use &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt;'s streaming operator, as illustrated below:</source>
          <target state="translated">QPolygon 객체는 &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt; &amp;lt; &lt;a href=&quot;qpoint&quot;&gt;QPoint&lt;/a&gt; &amp;gt;입니다. QPolygon에 포인트를 추가하는 가장 쉬운 방법은 아래 그림과 같이 &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt; 의 스트리밍 연산자 를 사용하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="f1151c7529c52b7a9354dc738991af96c6a1440e" translate="yes" xml:space="preserve">
          <source>A QPolygon object is a &lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt;&amp;lt;&lt;a href=&quot;qpoint&quot;&gt;QPoint&lt;/a&gt;&amp;gt;. The easiest way to add points to a QPolygon is to use &lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt;'s streaming operator, as illustrated below:</source>
          <target state="translated">QPolygon 객체는 &lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt; &amp;lt; &lt;a href=&quot;qpoint&quot;&gt;QPoint&lt;/a&gt; &amp;gt;입니다. QPolygon에 포인트를 추가하는 가장 쉬운 방법은 아래 그림과 같이 &lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt; 의 스트리밍 연산자 를 사용하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="b7d79b0b360f9f2393052df602164ba890a269e4" translate="yes" xml:space="preserve">
          <source>A QPolygonF is a &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt;&amp;lt;&lt;a href=&quot;qpointf&quot;&gt;QPointF&lt;/a&gt;&amp;gt;. The easiest way to add points to a QPolygonF is to use its streaming operator, as illustrated below:</source>
          <target state="translated">QPolygonF는 &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt; &amp;lt; &lt;a href=&quot;qpointf&quot;&gt;QPointF&lt;/a&gt; &amp;gt;입니다. QPolygonF에 포인트를 추가하는 가장 쉬운 방법은 아래 그림과 같이 스트리밍 연산자를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="19ddf62a242e47be1bfedda296b1d20380be2678" translate="yes" xml:space="preserve">
          <source>A QPolygonF is a &lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt;&amp;lt;&lt;a href=&quot;qpointf&quot;&gt;QPointF&lt;/a&gt;&amp;gt;. The easiest way to add points to a QPolygonF is to use its streaming operator, as illustrated below:</source>
          <target state="translated">QPolygonF는 &lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt; &amp;lt; &lt;a href=&quot;qpointf&quot;&gt;QPointF&lt;/a&gt; &amp;gt;입니다. QPolygonF에 포인트를 추가하는 가장 쉬운 방법은 아래 그림과 같이 스트리밍 연산자를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="0f6c8264dec0819e175ffe7ef8349d9f6b9412cc" translate="yes" xml:space="preserve">
          <source>A QPolygonOffset class adds an offset to the fragment depth value prior to depth test and depth write. The offset can be used to avoid z-fighting when rendering polygons with very close depth values such as decals.</source>
          <target state="translated">QPolygonOffset 클래스는 깊이 테스트 및 깊이 쓰기 전에 조각 깊이 값에 오프셋을 추가합니다. 오프셋은 데칼과 같이 깊이 값이 매우 가까운 다각형을 렌더링 할 때 z-fighting을 방지하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="95e92f813045c980ef8ecf1704f654d89a5f1a45" translate="yes" xml:space="preserve">
          <source>A QProxyStyle wraps a &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt; (usually the default system style) for the purpose of dynamically overriding painting or other specific style behavior.</source>
          <target state="translated">QProxyStyle 은 페인팅 또는 기타 특정 스타일 동작을 동적으로 재정의하기 위해 &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt; (일반적으로 기본 시스템 스타일)을 래핑합니다 .</target>
        </trans-unit>
        <trans-unit id="f6d537e9faddd545726376191c63bc1de21129c7" translate="yes" xml:space="preserve">
          <source>A QQmlComponent instance can be created from a QML file. For example, if there is a &lt;code&gt;main.qml&lt;/code&gt; file like this:</source>
          <target state="translated">QQmlComponent 인스턴스는 QML 파일에서 만들 수 있습니다. 예를 들어 다음 과 같은 &lt;code&gt;main.qml&lt;/code&gt; 파일이있는 경우 :</target>
        </trans-unit>
        <trans-unit id="b40a681c1935e8b83ad43587bcd908d721dfdefe" translate="yes" xml:space="preserve">
          <source>A QQmlIncubationController derived instance should be created and set on a &lt;a href=&quot;qqmlengine&quot;&gt;QQmlEngine&lt;/a&gt; by calling the &lt;a href=&quot;qqmlengine#setIncubationController&quot;&gt;QQmlEngine::setIncubationController&lt;/a&gt;() method. Processing is then controlled by calling the &lt;a href=&quot;qqmlincubationcontroller#incubateFor&quot;&gt;QQmlIncubationController::incubateFor&lt;/a&gt;() or &lt;a href=&quot;qqmlincubationcontroller#incubateWhile&quot;&gt;QQmlIncubationController::incubateWhile&lt;/a&gt;() methods as dictated by the application's requirements.</source>
          <target state="translated">&lt;a href=&quot;qqmlengine#setIncubationController&quot;&gt;QQmlEngine :: setIncubationController&lt;/a&gt; () 메서드 를 호출하여 QQmlIncubationController 파생 인스턴스를 만들고 &lt;a href=&quot;qqmlengine&quot;&gt;QQmlEngine&lt;/a&gt; 에 설정해야합니다 . 그런 다음 응용 프로그램의 요구 사항에 따라 &lt;a href=&quot;qqmlincubationcontroller#incubateFor&quot;&gt;QQmlIncubationController :: incubateFor&lt;/a&gt; () 또는 &lt;a href=&quot;qqmlincubationcontroller#incubateWhile&quot;&gt;QQmlIncubationController :: incubateWhile&lt;/a&gt; () 메서드를 호출하여 처리를 제어 합니다.</target>
        </trans-unit>
        <trans-unit id="1555dbde757ef564411b6e3a56159d253cc008e8" translate="yes" xml:space="preserve">
          <source>A QQmlIncubationController derived instance should be created and set on a &lt;a href=&quot;qqmlengine&quot;&gt;QQmlEngine&lt;/a&gt; by calling the &lt;a href=&quot;qqmlengine#setIncubationController&quot;&gt;QQmlEngine::setIncubationController&lt;/a&gt;() method. Processing is then controlled by calling the &lt;a href=&quot;qqmlincubationcontroller#incubateFor&quot;&gt;QQmlIncubationController::incubateFor&lt;/a&gt;() or QQmlIncubationController::incubateWhile() methods as dictated by the application's requirements.</source>
          <target state="translated">&lt;a href=&quot;qqmlengine#setIncubationController&quot;&gt;QQmlEngine :: setIncubationController&lt;/a&gt; () 메서드 를 호출하여 QQmlIncubationController 파생 인스턴스를 생성하고 &lt;a href=&quot;qqmlengine&quot;&gt;QQmlEngine&lt;/a&gt; 에 설정해야합니다 . 그런 다음 응용 프로그램의 요구 사항에 따라 &lt;a href=&quot;qqmlincubationcontroller#incubateFor&quot;&gt;QQmlIncubationController :: incubateFor&lt;/a&gt; () 또는 QQmlIncubationController :: incubateWhile () 메서드를 호출하여 처리를 제어 합니다.</target>
        </trans-unit>
        <trans-unit id="d6e64d2db27e059407986f872c7d8ff9cda58b5b" translate="yes" xml:space="preserve">
          <source>A QQuickWindow always has a single invisible root item. To add items to this window, reparent the items to the root item or to an existing item in the scene.</source>
          <target state="translated">QQuickWindow에는 항상 하나의 보이지 않는 루트 항목이 있습니다. 이 창에 항목을 추가하려면 항목을 루트 항목 또는 장면의 기존 항목의 상위 항목으로 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="b5e0d83f715379e1548c0320cd8373de27f48f96" translate="yes" xml:space="preserve">
          <source>A QQuickWindow is not necessarily backed by a native window on screen. The rendering can be redirected to target a custom render target, such as a given native texture. This is achieved in combination with the &lt;a href=&quot;qquickrendercontrol&quot;&gt;QQuickRenderControl&lt;/a&gt; class, and functions such as &lt;a href=&quot;qquickwindow#setRenderTarget&quot;&gt;setRenderTarget&lt;/a&gt;(), &lt;a href=&quot;qquickwindow#setGraphicsDevice&quot;&gt;setGraphicsDevice&lt;/a&gt;(), and &lt;a href=&quot;qquickwindow#setGraphicsConfiguration&quot;&gt;setGraphicsConfiguration&lt;/a&gt;().</source>
          <target state="translated">QQuickWindow는 화면의 기본 창에 의해 반드시 지원되는 것은 아닙니다. 렌더링은 지정된 네이티브 텍스처와 같은 사용자 지정 렌더링 대상을 대상으로 리디렉션 될 수 있습니다. 이는 &lt;a href=&quot;qquickrendercontrol&quot;&gt;QQuickRenderControl&lt;/a&gt; 클래스 및 &lt;a href=&quot;qquickwindow#setRenderTarget&quot;&gt;setRenderTarget&lt;/a&gt; (), &lt;a href=&quot;qquickwindow#setGraphicsDevice&quot;&gt;setGraphicsDevice&lt;/a&gt; () 및 &lt;a href=&quot;qquickwindow#setGraphicsConfiguration&quot;&gt;setGraphicsConfiguration&lt;/a&gt; () 과 같은 함수와 함께 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="be8927f6b88a455103e553536a4dc842389033de" translate="yes" xml:space="preserve">
          <source>A QRadioButton is an option button that can be switched on (checked) or off (unchecked). Radio buttons typically present the user with a &quot;one of many&quot; choice. In a group of radio buttons, only one radio button at a time can be checked; if the user selects another button, the previously selected button is switched off.</source>
          <target state="translated">QRadioButton은 켜기 (선택) 또는 끄기 (선택 취소) 할 수있는 옵션 버튼입니다. 라디오 버튼은 일반적으로 사용자에게 &quot;다중 하나&quot;선택을 제공합니다. 라디오 버튼 그룹에서는 한 번에 하나의 라디오 버튼 만 확인할 수 있습니다. 사용자가 다른 버튼을 선택하면 이전에 선택한 버튼이 꺼집니다.</target>
        </trans-unit>
        <trans-unit id="867761c4f4d43102ce74a9ff250cc59b6e335b9a" translate="yes" xml:space="preserve">
          <source>A QRawFont object represents a single, physical instance of a given font in a given pixel size. I.e. in the typical case it represents a set of TrueType or OpenType font tables and uses a user specified pixel size to convert metrics into logical pixel units. It can be used in combination with the &lt;a href=&quot;https://doc.qt.io/qt-5.15/qglyphrun.html&quot;&gt;QGlyphRun&lt;/a&gt; class to draw specific glyph indexes at specific positions, and also have accessors to some relevant data in the physical font.</source>
          <target state="translated">QRawFont 객체는 지정된 픽셀 크기로 지정된 글꼴의 단일 물리적 인스턴스를 나타냅니다. 즉, 일반적인 경우 TrueType 또는 OpenType 글꼴 테이블 집합을 나타내며 사용자 지정 픽셀 크기를 사용하여 메트릭을 논리적 픽셀 단위로 변환합니다. &lt;a href=&quot;https://doc.qt.io/qt-5.15/qglyphrun.html&quot;&gt;QGlyphRun&lt;/a&gt; 클래스 와 함께 사용 하여 특정 위치에 특정 글리프 인덱스를 그릴 수 있으며 물리적 글꼴의 일부 관련 데이터에 대한 접근자를 가질 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="58350416b1f044e4781660e9b5215ae5b6a87997" translate="yes" xml:space="preserve">
          <source>A QRawFont object represents a single, physical instance of a given font in a given pixel size. I.e. in the typical case it represents a set of TrueType or OpenType font tables and uses a user specified pixel size to convert metrics into logical pixel units. It can be used in combination with the &lt;a href=&quot;https://doc.qt.io/qt-6.0/qglyphrun.html&quot;&gt;QGlyphRun&lt;/a&gt; class to draw specific glyph indexes at specific positions, and also have accessors to some relevant data in the physical font.</source>
          <target state="translated">QRawFont 객체는 지정된 픽셀 크기로 지정된 글꼴의 단일 물리적 인스턴스를 나타냅니다. 즉, 일반적인 경우 TrueType 또는 OpenType 글꼴 테이블 집합을 나타내며 사용자 지정 픽셀 크기를 사용하여 메트릭을 논리적 픽셀 단위로 변환합니다. &lt;a href=&quot;https://doc.qt.io/qt-6.0/qglyphrun.html&quot;&gt;QGlyphRun&lt;/a&gt; 클래스 와 함께 사용 하여 특정 위치에 특정 글리프 인덱스를 그릴 수 있으며 물리적 글꼴의 일부 관련 데이터에 대한 접근자를 가질 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f94dfc87e9dea1c9d7aa981c7cceeb0d7831c08" translate="yes" xml:space="preserve">
          <source>A QRect can be constructed with a set of left, top, width and height integers, or from a &lt;a href=&quot;qpoint&quot;&gt;QPoint&lt;/a&gt; and a &lt;a href=&quot;qsize&quot;&gt;QSize&lt;/a&gt;. The following code creates two identical rectangles.</source>
          <target state="translated">QRect는 왼쪽, 위쪽, 너비 및 높이 정수 집합으로 또는 &lt;a href=&quot;qpoint&quot;&gt;QPoint&lt;/a&gt; 및 &lt;a href=&quot;qsize&quot;&gt;QSize&lt;/a&gt; 에서 구성 할 수 있습니다 . 다음 코드는 두 개의 동일한 사각형을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="445973cfd32ab3a5b20c3b36f62c2a73af95cef4" translate="yes" xml:space="preserve">
          <source>A QRectF can be constructed with a set of left, top, width and height coordinates, or from a &lt;a href=&quot;qpointf&quot;&gt;QPointF&lt;/a&gt; and a &lt;a href=&quot;qsizef&quot;&gt;QSizeF&lt;/a&gt;. The following code creates two identical rectangles.</source>
          <target state="translated">QRectF는 왼쪽, 위쪽, 너비 및 높이 좌표 집합으로 또는 &lt;a href=&quot;qpointf&quot;&gt;QPointF&lt;/a&gt; 및 &lt;a href=&quot;qsizef&quot;&gt;QSizeF&lt;/a&gt; 에서 구성 할 수 있습니다 . 다음 코드는 두 개의 동일한 사각형을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="d73cd00629e729f054c2d9c549b6de284474af01" translate="yes" xml:space="preserve">
          <source>A QRegularExpressionMatch object can be obtained by calling the &lt;a href=&quot;qregularexpression#match&quot;&gt;QRegularExpression::match&lt;/a&gt;() function, or as a single result of a global match from a &lt;a href=&quot;qregularexpressionmatchiterator&quot;&gt;QRegularExpressionMatchIterator&lt;/a&gt;.</source>
          <target state="translated">QRegularExpressionMatch 객체 호출함으로써 얻어 질 수 &lt;a href=&quot;qregularexpression#match&quot;&gt;QRegularExpression :: 매치&lt;/a&gt; () 함수, 또는 글로벌 매치로부터의 하나의 결과로서 &lt;a href=&quot;qregularexpressionmatchiterator&quot;&gt;QRegularExpressionMatchIterator&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7989680fe61514e935aaf108ed319cc43697dde0" translate="yes" xml:space="preserve">
          <source>A QRegularExpressionMatchIterator object is a forward only Java-like iterator; it can be obtained by calling the &lt;a href=&quot;qregularexpression#globalMatch&quot;&gt;QRegularExpression::globalMatch&lt;/a&gt;() function. A new QRegularExpressionMatchIterator will be positioned before the first result. You can then call the &lt;a href=&quot;qregularexpressionmatchiterator#hasNext&quot;&gt;hasNext&lt;/a&gt;() function to check if there are more results available; if so, the &lt;a href=&quot;qregularexpressionmatchiterator#next&quot;&gt;next&lt;/a&gt;() function will return the next result and advance the iterator.</source>
          <target state="translated">QRegularExpressionMatchIterator 객체는 Java와 유사한 순방향 전용 반복기입니다. &lt;a href=&quot;qregularexpression#globalMatch&quot;&gt;QRegularExpression :: globalMatch&lt;/a&gt; () 함수 를 호출하여 얻을 수 있습니다 . 새 QRegularExpressionMatchIterator는 첫 번째 결과 앞에 배치됩니다. 그런 다음 &lt;a href=&quot;qregularexpressionmatchiterator#hasNext&quot;&gt;hasNext&lt;/a&gt; () 함수를 호출하여 사용 가능한 결과가 더 있는지 확인할 수 있습니다. 그렇다면 &lt;a href=&quot;qregularexpressionmatchiterator#next&quot;&gt;next&lt;/a&gt; () 함수는 다음 결과를 반환하고 반복기를 진행합니다.</target>
        </trans-unit>
        <trans-unit id="d1ec7b2af488f227aff863585060c217c7d51abe" translate="yes" xml:space="preserve">
          <source>A QRemoteObjectNode does not have a url that other nodes can connect to, and thus is able to acquire replicas only. It is not able to share source objects (only &lt;a href=&quot;qremoteobjecthost&quot;&gt;QRemoteObjectHost&lt;/a&gt; and &lt;a href=&quot;qremoteobjectregistryhost&quot;&gt;QRemoteObjectRegistryHost&lt;/a&gt; Nodes can share).</source>
          <target state="translated">QRemoteObjectNode에는 다른 노드가 연결할 수있는 URL이 없으므로 복제본 만 획득 할 수 있습니다. 소스 개체를 공유 할 수 없습니다 ( &lt;a href=&quot;qremoteobjecthost&quot;&gt;QRemoteObjectHost&lt;/a&gt; 및 &lt;a href=&quot;qremoteobjectregistryhost&quot;&gt;QRemoteObjectRegistryHost&lt;/a&gt; 노드 만 공유 할 수 있음).</target>
        </trans-unit>
        <trans-unit id="a7e72091bd7fdba61bab649adbd3d0f9ecd4d74a" translate="yes" xml:space="preserve">
          <source>A QRemoteObjectRegistryHost has the same capability that a &lt;a href=&quot;qremoteobjecthost&quot;&gt;QRemoteObjectHost&lt;/a&gt; has (which includes everything a &lt;a href=&quot;qremoteobjectnode&quot;&gt;QRemoteObjectNode&lt;/a&gt; supports), and in addition is the owner of the Registry. Any &lt;a href=&quot;qremoteobjecthost&quot;&gt;QRemoteObjectHost&lt;/a&gt; node that connects to this Node will have all of their Source objects made available by the Registry.</source>
          <target state="translated">QRemoteObjectRegistryHost는 것과 같은 기능을 가지고 &lt;a href=&quot;qremoteobjecthost&quot;&gt;QRemoteObjectHost는&lt;/a&gt; (모든 포함하는이 &lt;a href=&quot;qremoteobjectnode&quot;&gt;QRemoteObjectNode의&lt;/a&gt; 지원을), 또한 레지스트리의 소유자입니다. 이 노드에 연결하는 모든 &lt;a href=&quot;qremoteobjecthost&quot;&gt;QRemoteObjectHost&lt;/a&gt; 노드는 레지스트리에서 사용 가능한 모든 소스 오브젝트를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="5d5e164fdd8050faac41f2d02acb06a463ec7532" translate="yes" xml:space="preserve">
          <source>A QRenderTargetOutput specifies the attachment point and parameters for texture that is attached to render target. In addition to the attachment point, texture miplevel, layer and cubemap face can be specified. The texture attached to the QRenderTargetOutput must be compatible with the given parameters.</source>
          <target state="translated">QRenderTargetOutput은 렌더 대상에 연결된 텍스처의 연결 지점 및 매개 변수를 지정합니다. 부착 지점 외에도 텍스처 밉 레벨, 레이어 및 큐브 맵면을 지정할 수 있습니다. QRenderTargetOutput에 연결된 텍스처는 지정된 매개 변수와 호환되어야합니다.</target>
        </trans-unit>
        <trans-unit id="9d5655bcdd32c264c4d2d1ebee6079a8a303d24a" translate="yes" xml:space="preserve">
          <source>A QResource can either be loaded with an absolute path, either treated as a file system rooted with a &lt;code&gt;/&lt;/code&gt; character, or in resource notation rooted with a &lt;code&gt;:&lt;/code&gt; character. A relative resource can also be opened which will be found in the list of paths returned by &lt;a href=&quot;qdir#searchPaths&quot;&gt;QDir::searchPaths&lt;/a&gt;().</source>
          <target state="translated">QResource는 &lt;code&gt;/&lt;/code&gt; 문자로 루트가 지정된 파일 시스템으로 처리 되거나 &lt;code&gt;:&lt;/code&gt; 문자로 루트가 지정된 자원 표기법으로 처리되는 절대 경로로로드 될 수 있습니다 . &lt;a href=&quot;qdir#searchPaths&quot;&gt;QDir :: searchPaths&lt;/a&gt; ()에서 반환 한 경로 목록에서 찾을 수있는 상대 리소스도 열 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b6c4665e7263cc92476dae9f11852122f2bc71b8" translate="yes" xml:space="preserve">
          <source>A QResource that is representing a file will have data backing it, this data can possibly be compressed, in which case &lt;a href=&quot;qbytearray#qUncompress&quot;&gt;qUncompress&lt;/a&gt;() must be used to access the real data; this happens implicitly when accessed through a &lt;a href=&quot;qfile&quot;&gt;QFile&lt;/a&gt;. A QResource that is representing a directory will have only children and no data.</source>
          <target state="translated">파일을 나타내는 QResource는이를 뒷받침하는 데이터를 갖게됩니다.이 데이터는 압축 될 수 있습니다.이 경우 실제 데이터에 액세스하려면 &lt;a href=&quot;qbytearray#qUncompress&quot;&gt;qUncompress&lt;/a&gt; ()를 사용해야합니다. 이것은 &lt;a href=&quot;qfile&quot;&gt;QFile을&lt;/a&gt; 통해 액세스 할 때 암시 적으로 발생합니다 . 디렉토리를 나타내는 QResource에는 하위 만 있고 데이터는 없습니다.</target>
        </trans-unit>
        <trans-unit id="74f02e0db4194502bee3ef5b8148d4f5f1d5d898" translate="yes" xml:space="preserve">
          <source>A QSGAbstractRenderer created by a QSGEngine allows you to set your &lt;a href=&quot;qsgnode&quot;&gt;QSGNode&lt;/a&gt; tree through &lt;a href=&quot;qsgabstractrenderer#setRootNode&quot;&gt;setRootNode&lt;/a&gt;() and control the rendering viewport through &lt;a href=&quot;qsgabstractrenderer#setDeviceRect&quot;&gt;setDeviceRect&lt;/a&gt;(), &lt;a href=&quot;qsgabstractrenderer#setViewportRect&quot;&gt;setViewportRect&lt;/a&gt;() and &lt;a href=&quot;qsgabstractrenderer#setProjectionMatrixToRect&quot;&gt;setProjectionMatrixToRect&lt;/a&gt;(). You can finally trigger the rendering to the desired framebuffer through &lt;a href=&quot;qsgabstractrenderer#renderScene&quot;&gt;renderScene&lt;/a&gt;().</source>
          <target state="translated">QSGEngine에서 생성 한 QSGAbstractRenderer를 사용하면 &lt;a href=&quot;qsgabstractrenderer#setRootNode&quot;&gt;setRootNode&lt;/a&gt; ()를 통해 &lt;a href=&quot;qsgnode&quot;&gt;QSGNode&lt;/a&gt; 트리 를 설정 하고 &lt;a href=&quot;qsgabstractrenderer#setDeviceRect&quot;&gt;setDeviceRect&lt;/a&gt; (), &lt;a href=&quot;qsgabstractrenderer#setViewportRect&quot;&gt;setViewportRect&lt;/a&gt; () 및 &lt;a href=&quot;qsgabstractrenderer#setProjectionMatrixToRect&quot;&gt;setProjectionMatrixToRect&lt;/a&gt; ()를 통해 렌더링 뷰포트를 제어 할 수 있습니다. 마지막으로 &lt;a href=&quot;qsgabstractrenderer#renderScene&quot;&gt;renderScene&lt;/a&gt; ()을 통해 원하는 프레임 버퍼로 렌더링을 트리거 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="698589f7faf1dfdc341160c4ff56d9c9a39d2a30" translate="yes" xml:space="preserve">
          <source>A QSGEngine can be used to render a tree of &lt;a href=&quot;qsgnode&quot;&gt;QSGNode&lt;/a&gt; directly on a &lt;a href=&quot;qwindow&quot;&gt;QWindow&lt;/a&gt; or &lt;a href=&quot;qopenglframebufferobject&quot;&gt;QOpenGLFramebufferObject&lt;/a&gt; without any integration with QML, &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt; or &lt;a href=&quot;qquickitem&quot;&gt;QQuickItem&lt;/a&gt; and the convenience that they provide.</source>
          <target state="translated">QSGEngine은 QML, &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt; 또는 &lt;a href=&quot;qquickitem&quot;&gt;QQuickItem&lt;/a&gt; 과의 통합 및 그들이 제공하는 편리함 없이 &lt;a href=&quot;qwindow&quot;&gt;QWindow&lt;/a&gt; 또는 &lt;a href=&quot;qopenglframebufferobject&quot;&gt;QOpenGLFramebufferObject&lt;/a&gt; 에서 직접 &lt;a href=&quot;qsgnode&quot;&gt;QSGNode&lt;/a&gt; 의 트리를 렌더링하는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9d1f5f7d8287b2fd220db184c99a902caac7054c" translate="yes" xml:space="preserve">
          <source>A QScissorTest class enables scissor test, which discards fragments outside the rectangular area of the screen specified by the left, bottom, width and height properties.</source>
          <target state="translated">QScissorTest 클래스는 left, bottom, width 및 height 속성으로 지정된 화면의 직사각형 영역 외부에있는 조각을 버리는 가위 테스트를 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="f119cf7dfe208b470dc615ea0794396842849b92" translate="yes" xml:space="preserve">
          <source>A QScopedArrayPointer is a &lt;a href=&quot;qscopedpointer&quot;&gt;QScopedPointer&lt;/a&gt; that defaults to deleting the object it is pointing to with the delete[] operator. It also features operator[] for convenience, so we can write:</source>
          <target state="translated">QScopedArrayPointer는 delete [] 연산자로 가리키는 개체를 기본적으로 삭제 하는 &lt;a href=&quot;qscopedpointer&quot;&gt;QScopedPointer&lt;/a&gt; 입니다. 또한 편의를 위해 operator []를 제공하므로 다음과 같이 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="846ee01ff48b8909af7cb93694f07b0a68d4388b" translate="yes" xml:space="preserve">
          <source>A QSemaphoreReleaser can be canceled by a call to &lt;a href=&quot;qsemaphorereleaser#cancel&quot;&gt;cancel&lt;/a&gt;(). A canceled semaphore releaser will no longer call &lt;a href=&quot;qsemaphore#release&quot;&gt;QSemaphore::release&lt;/a&gt;() in its destructor.</source>
          <target state="translated">QSemaphoreReleaser는 &lt;a href=&quot;qsemaphorereleaser#cancel&quot;&gt;cancel&lt;/a&gt; () 호출로 취소 할 수 있습니다 . 취소 된 세마포 &lt;a href=&quot;qsemaphore#release&quot;&gt;해제 기는&lt;/a&gt; 더 이상 소멸자에서 QSemaphore :: release ()를 호출하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="d39b9eaca4eb0557861dfbf9921f009a11027572" translate="yes" xml:space="preserve">
          <source>A QSequentialIterable::const_iterator can only be created by a &lt;a href=&quot;qsequentialiterable&quot;&gt;QSequentialIterable&lt;/a&gt; instance, and can be used in a way similar to other stl-style iterators.</source>
          <target state="translated">QSequentialIterable :: const_iterator는 &lt;a href=&quot;qsequentialiterable&quot;&gt;QSequentialIterable&lt;/a&gt; 인스턴스 에 의해서만 생성 될 수 있으며 다른 stl 스타일 반복자와 유사한 방식으로 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bfe76c44738b285db3550977761c7e04872edc91" translate="yes" xml:space="preserve">
          <source>A QSequentialIterable::iterator can only be created by a &lt;a href=&quot;qsequentialiterable&quot;&gt;QSequentialIterable&lt;/a&gt; instance, and can be used in a way similar to other stl-style iterators.</source>
          <target state="translated">QSequentialIterable :: iterator는 &lt;a href=&quot;qsequentialiterable&quot;&gt;QSequentialIterable&lt;/a&gt; 인스턴스 에 의해서만 생성 될 수 있으며, 다른 stl 스타일 반복자와 유사한 방식으로 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b34e5d0e7e0a80a2309aef49ffa32d5bde45d3bb" translate="yes" xml:space="preserve">
          <source>A QSharedPointer object can be created from a normal pointer, another QSharedPointer object or by promoting a &lt;a href=&quot;qweakpointer&quot;&gt;QWeakPointer&lt;/a&gt; object to a strong reference.</source>
          <target state="translated">QSharedPointer 개체는 일반 포인터, 다른 QSharedPointer 개체에서 또는 &lt;a href=&quot;qweakpointer&quot;&gt;QWeakPointer&lt;/a&gt; 개체를 강력한 참조 로 승격하여 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e5bf5c1c65286ce5d95d0d6872c5c6c641bb22f6" translate="yes" xml:space="preserve">
          <source>A QSqlError object can provide database-specific error data, including the &lt;a href=&quot;qsqlerror#driverText&quot;&gt;driverText&lt;/a&gt;() and &lt;a href=&quot;qsqlerror#databaseText&quot;&gt;databaseText&lt;/a&gt;() messages (or both concatenated together as &lt;a href=&quot;qsqlerror#text&quot;&gt;text&lt;/a&gt;()), and the &lt;a href=&quot;qsqlerror#nativeErrorCode&quot;&gt;nativeErrorCode&lt;/a&gt;() and &lt;a href=&quot;qsqlerror#type&quot;&gt;type&lt;/a&gt;().</source>
          <target state="translated">QSqlError 객체는 &lt;a href=&quot;qsqlerror#driverText&quot;&gt;driverText&lt;/a&gt; () 및 &lt;a href=&quot;qsqlerror#databaseText&quot;&gt;databaseText&lt;/a&gt; () 메시지 (또는 둘 다 &lt;a href=&quot;qsqlerror#text&quot;&gt;텍스트&lt;/a&gt; () 로 함께 &lt;a href=&quot;qsqlerror#nativeErrorCode&quot;&gt;연결됨&lt;/a&gt; ), nativeErrorCode () 및 &lt;a href=&quot;qsqlerror#type&quot;&gt;유형&lt;/a&gt; ()을 포함하여 데이터베이스 별 오류 데이터를 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c10bd12c3b135eb09ebb5cbd1b35ada8cec0813b" translate="yes" xml:space="preserve">
          <source>A QSqlField object can provide some meta-data about the field, for example, its &lt;a href=&quot;qsqlfield#name&quot;&gt;name&lt;/a&gt;(), variant &lt;a href=&quot;qsqlfield#type&quot;&gt;type&lt;/a&gt;(), &lt;a href=&quot;qsqlfield#length&quot;&gt;length&lt;/a&gt;(), &lt;a href=&quot;qsqlfield#precision&quot;&gt;precision&lt;/a&gt;(), &lt;a href=&quot;qsqlfield#defaultValue&quot;&gt;defaultValue&lt;/a&gt;(), typeID(), and its &lt;a href=&quot;qsqlfield#requiredStatus&quot;&gt;requiredStatus&lt;/a&gt;(), &lt;a href=&quot;qsqlfield#isGenerated&quot;&gt;isGenerated&lt;/a&gt;() and &lt;a href=&quot;qsqlfield#isReadOnly&quot;&gt;isReadOnly&lt;/a&gt;(). The field's data can be checked to see if it &lt;a href=&quot;qsqlfield#isNull&quot;&gt;isNull&lt;/a&gt;(), and its &lt;a href=&quot;qsqlfield#value&quot;&gt;value&lt;/a&gt;() retrieved. When editing the data can be set with &lt;a href=&quot;qsqlfield#setValue&quot;&gt;setValue&lt;/a&gt;() or set to NULL with &lt;a href=&quot;qsqlfield#clear&quot;&gt;clear&lt;/a&gt;().</source>
          <target state="translated">QSqlField 객체는 필드에 대한 일부 메타 데이터 ( 예 : &lt;a href=&quot;qsqlfield#name&quot;&gt;이름&lt;/a&gt; (), 변형 &lt;a href=&quot;qsqlfield#type&quot;&gt;유형&lt;/a&gt; (), &lt;a href=&quot;qsqlfield#length&quot;&gt;길이&lt;/a&gt; (), &lt;a href=&quot;qsqlfield#precision&quot;&gt;정밀도&lt;/a&gt; (), &lt;a href=&quot;qsqlfield#defaultValue&quot;&gt;defaultValue&lt;/a&gt; (), typeID () 및 &lt;a href=&quot;qsqlfield#requiredStatus&quot;&gt;requiredStatus&lt;/a&gt; (), &lt;a href=&quot;qsqlfield#isGenerated&quot;&gt;isGenerated&lt;/a&gt; ()를 제공 할 수 있습니다. ) 및 &lt;a href=&quot;qsqlfield#isReadOnly&quot;&gt;isReadOnly&lt;/a&gt; (). 필드의 데이터를 검사하여 &lt;a href=&quot;qsqlfield#isNull&quot;&gt;Null&lt;/a&gt; () 인지 확인 하고 해당 &lt;a href=&quot;qsqlfield#value&quot;&gt;값&lt;/a&gt; ()을 검색 할 수 있습니다. 데이터를 편집 할 때 &lt;a href=&quot;qsqlfield#setValue&quot;&gt;setValue&lt;/a&gt; ()로 설정하거나 &lt;a href=&quot;qsqlfield#clear&quot;&gt;지우기&lt;/a&gt; () 로 NULL로 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1828becbe4acb75857ebec8f3d6bf731b625c689" translate="yes" xml:space="preserve">
          <source>A QSqlField object can provide some meta-data about the field, for example, its &lt;a href=&quot;qsqlfield#name&quot;&gt;name&lt;/a&gt;(), variant type(), &lt;a href=&quot;qsqlfield#length&quot;&gt;length&lt;/a&gt;(), &lt;a href=&quot;qsqlfield#precision&quot;&gt;precision&lt;/a&gt;(), &lt;a href=&quot;qsqlfield#defaultValue&quot;&gt;defaultValue&lt;/a&gt;(), typeID(), and its &lt;a href=&quot;qsqlfield#requiredStatus&quot;&gt;requiredStatus&lt;/a&gt;(), &lt;a href=&quot;qsqlfield#isGenerated&quot;&gt;isGenerated&lt;/a&gt;() and &lt;a href=&quot;qsqlfield#isReadOnly&quot;&gt;isReadOnly&lt;/a&gt;(). The field's data can be checked to see if it &lt;a href=&quot;qsqlfield#isNull&quot;&gt;isNull&lt;/a&gt;(), and its &lt;a href=&quot;qsqlfield#value&quot;&gt;value&lt;/a&gt;() retrieved. When editing the data can be set with &lt;a href=&quot;qsqlfield#setValue&quot;&gt;setValue&lt;/a&gt;() or set to NULL with &lt;a href=&quot;qsqlfield#clear&quot;&gt;clear&lt;/a&gt;().</source>
          <target state="translated">QSqlField 객체는 필드에 대한 메타 데이터 ( 예 : &lt;a href=&quot;qsqlfield#name&quot;&gt;이름&lt;/a&gt; (), 변형 유형 (), &lt;a href=&quot;qsqlfield#length&quot;&gt;길이&lt;/a&gt; (), &lt;a href=&quot;qsqlfield#precision&quot;&gt;정밀도&lt;/a&gt; (), &lt;a href=&quot;qsqlfield#defaultValue&quot;&gt;defaultValue&lt;/a&gt; (), typeID () 및 &lt;a href=&quot;qsqlfield#requiredStatus&quot;&gt;requiredStatus&lt;/a&gt; (), &lt;a href=&quot;qsqlfield#isGenerated&quot;&gt;isGenerated&lt;/a&gt; ()를 제공 할 수 있습니다. ) 및 &lt;a href=&quot;qsqlfield#isReadOnly&quot;&gt;isReadOnly&lt;/a&gt; (). 필드의 데이터를 검사하여 &lt;a href=&quot;qsqlfield#isNull&quot;&gt;Null&lt;/a&gt; () 인지 확인 하고 해당 &lt;a href=&quot;qsqlfield#value&quot;&gt;값&lt;/a&gt; ()을 검색 할 수 있습니다. 데이터를 편집 할 때 &lt;a href=&quot;qsqlfield#setValue&quot;&gt;setValue&lt;/a&gt; ()로 설정하거나 &lt;a href=&quot;qsqlfield#clear&quot;&gt;지우기&lt;/a&gt; () 로 NULL로 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b2f0f5948392857267556204719c2451666d108b" translate="yes" xml:space="preserve">
          <source>A QStackedLayout can be populated with a number of child widgets (&quot;pages&quot;). For example:</source>
          <target state="translated">QStackedLayout은 여러 하위 위젯 ( &quot;페이지&quot;)으로 채울 수 있습니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="c31f0607c98537f99fbb1329bde4cfc5fb4cdaa0" translate="yes" xml:space="preserve">
          <source>A QString can embed '\0' characters (&lt;a href=&quot;qchar#SpecialCharacter-enum&quot;&gt;QChar::Null&lt;/a&gt;). The &lt;a href=&quot;qstring#size&quot;&gt;size&lt;/a&gt;() function always returns the size of the whole string, including embedded '\0' characters.</source>
          <target state="translated">QString은 '\ 0'문자 ( &lt;a href=&quot;qchar#SpecialCharacter-enum&quot;&gt;QChar :: Null&lt;/a&gt; )를 포함 할 수 있습니다 . &lt;a href=&quot;qstring#size&quot;&gt;크기&lt;/a&gt; () 함수는 항상 포함 된 '\ 0'문자를 포함하여 전체 문자열의 크기를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7e0e0c7aff9706f5c1f917136637d9cfec032498" translate="yes" xml:space="preserve">
          <source>A QStringView references a contiguous portion of a UTF-16 string it does not own. It acts as an interface type to all kinds of UTF-16 string, without the need to construct a &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; first.</source>
          <target state="translated">QStringView는 소유하지 않은 UTF-16 문자열의 연속 부분을 참조합니다. &lt;a href=&quot;qstring&quot;&gt;QString을&lt;/a&gt; 먼저 구성 할 필요없이 모든 종류의 UTF-16 문자열에 대한 인터페이스 유형으로 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="67cc870dc1bff3c91ab55e1c70d3bbe263d50321" translate="yes" xml:space="preserve">
          <source>A QTableView implements a table view that displays items from a model. This class is used to provide standard tables that were previously provided by the QTable class, but using the more flexible approach provided by Qt's model/view architecture.</source>
          <target state="translated">QTableView는 모델의 항목을 표시하는 테이블보기를 구현합니다. 이 클래스는 이전에 QTable 클래스에서 제공 한 표준 테이블을 제공하는 데 사용되지만 Qt의 모델 / 뷰 아키텍처에서 제공하는보다 유연한 접근 방식을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="bcf239d0d91dff58e4b2154a0535e4cd2a79b417" translate="yes" xml:space="preserve">
          <source>A QTestEventList can be populated with GUI events that can be stored as test data for later usage, or be replayed on any &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt;. QTestEventList provides convenience functions for populating the list.</source>
          <target state="translated">QTestEventList는 나중에 사용하기 위해 테스트 데이터로 저장하거나 &lt;a href=&quot;qwidget&quot;&gt;QWidget에서&lt;/a&gt; 재생할 수있는 GUI 이벤트로 채워질 수 있습니다 . QTestEventList는 목록을 채우기위한 편리한 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="0e996f2b0d86be65dde44803cbb42588ab629ad0" translate="yes" xml:space="preserve">
          <source>A QTestEventList can be populated with GUI events that can be stored as test data for later usage, or be replayed on any &lt;a href=&quot;widgets-changes-qt6#qwidget&quot;&gt;QWidget&lt;/a&gt;. QTestEventList provides convenience functions for populating the list.</source>
          <target state="translated">QTestEventList는 나중에 사용하기 위해 테스트 데이터로 저장하거나 &lt;a href=&quot;widgets-changes-qt6#qwidget&quot;&gt;QWidget에서&lt;/a&gt; 재생할 수있는 GUI 이벤트로 채워질 수 있습니다 . QTestEventList는 목록을 채우기위한 편리한 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b424f58feccfc26944d8ecdcb60a0f867cb090f3" translate="yes" xml:space="preserve">
          <source>A QTextCursor also has an &lt;a href=&quot;qtextcursor#anchor&quot;&gt;anchor&lt;/a&gt;() position. The text that is between the &lt;a href=&quot;qtextcursor#anchor&quot;&gt;anchor&lt;/a&gt;() and the &lt;a href=&quot;qtextcursor#position&quot;&gt;position&lt;/a&gt;() is the selection. If &lt;a href=&quot;qtextcursor#anchor&quot;&gt;anchor&lt;/a&gt;() == &lt;a href=&quot;qtextcursor#position&quot;&gt;position&lt;/a&gt;() there is no selection.</source>
          <target state="translated">QTextCursor에는 &lt;a href=&quot;qtextcursor#anchor&quot;&gt;앵커&lt;/a&gt; () 위치도 있습니다. &lt;a href=&quot;qtextcursor#anchor&quot;&gt;앵커&lt;/a&gt; ()와 &lt;a href=&quot;qtextcursor#position&quot;&gt;위치&lt;/a&gt; () 사이에있는 텍스트가 선택 항목입니다. 경우 &lt;a href=&quot;qtextcursor#anchor&quot;&gt;앵커&lt;/a&gt; () == &lt;a href=&quot;qtextcursor#position&quot;&gt;위치&lt;/a&gt; ()에는 선택이 없다.</target>
        </trans-unit>
        <trans-unit id="579e7bbcead95ac9aec4e4585b206740d2726247" translate="yes" xml:space="preserve">
          <source>A QTextDocument can be edited programmatically using a &lt;a href=&quot;qtextcursor&quot;&gt;QTextCursor&lt;/a&gt;, and its contents can be examined by traversing the document structure. The entire document structure is stored as a hierarchy of document elements beneath the root frame, found with the &lt;a href=&quot;qtextdocument#rootFrame&quot;&gt;rootFrame&lt;/a&gt;() function. Alternatively, if you just want to iterate over the textual contents of the document you can use &lt;a href=&quot;qtextdocument#begin&quot;&gt;begin&lt;/a&gt;(), &lt;a href=&quot;qtextdocument#end&quot;&gt;end&lt;/a&gt;(), and &lt;a href=&quot;qtextdocument#findBlock&quot;&gt;findBlock&lt;/a&gt;() to retrieve text blocks that you can examine and iterate over.</source>
          <target state="translated">QTextDocument은 사용 프로그램을 편집 할 수 &lt;a href=&quot;qtextcursor&quot;&gt;QTextCursor를&lt;/a&gt; , 그 내용은 문서 구조를 통과하여 조사 할 수있다. 전체 문서 구조는 &lt;a href=&quot;qtextdocument#rootFrame&quot;&gt;rootFrame&lt;/a&gt; () 함수로 찾을 수있는 루트 프레임 아래에 문서 요소의 계층 구조로 저장됩니다 . 또는 문서의 텍스트 내용 만 반복하려는 경우 &lt;a href=&quot;qtextdocument#begin&quot;&gt;begin&lt;/a&gt; (), &lt;a href=&quot;qtextdocument#end&quot;&gt;end&lt;/a&gt; () 및 &lt;a href=&quot;qtextdocument#findBlock&quot;&gt;findBlock&lt;/a&gt; ()을 사용하여 검사하고 반복 할 수있는 텍스트 블록을 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="df74c573bd0056fd0c4fd654bb14402e218f4cc5" translate="yes" xml:space="preserve">
          <source>A QTextDocumentFragment is a fragment of rich text, that can be inserted into a &lt;a href=&quot;qtextdocument&quot;&gt;QTextDocument&lt;/a&gt;. A document fragment can be created from a &lt;a href=&quot;qtextdocument&quot;&gt;QTextDocument&lt;/a&gt;, from a &lt;a href=&quot;qtextcursor&quot;&gt;QTextCursor&lt;/a&gt;'s selection, or from another document fragment. Document fragments can also be created by the static functions, &lt;a href=&quot;qtextdocumentfragment#fromPlainText&quot;&gt;fromPlainText&lt;/a&gt;() and &lt;a href=&quot;qtextdocumentfragment#fromHtml&quot;&gt;fromHtml&lt;/a&gt;().</source>
          <target state="translated">QTextDocumentFragment는 QTextDocument에 삽입 할 수있는 서식있는 텍스트의 &lt;a href=&quot;qtextdocument&quot;&gt;일부&lt;/a&gt; 입니다. 문서 조각은 &lt;a href=&quot;qtextdocument&quot;&gt;QTextDocument&lt;/a&gt; , &lt;a href=&quot;qtextcursor&quot;&gt;QTextCursor&lt;/a&gt; 의 선택 또는 다른 문서 조각에서 만들 수 있습니다 . 정적 함수 인 &lt;a href=&quot;qtextdocumentfragment#fromPlainText&quot;&gt;fromPlainText&lt;/a&gt; () 및 &lt;a href=&quot;qtextdocumentfragment#fromHtml&quot;&gt;fromHtml&lt;/a&gt; () 을 사용하여 문서 조각을 만들 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2a26a5e16424a330a1a1608616648ff4b341689f" translate="yes" xml:space="preserve">
          <source>A QTextFormat is a generic class used for describing the format of parts of a &lt;a href=&quot;qtextdocument&quot;&gt;QTextDocument&lt;/a&gt;. The derived classes &lt;a href=&quot;qtextcharformat&quot;&gt;QTextCharFormat&lt;/a&gt;, &lt;a href=&quot;qtextblockformat&quot;&gt;QTextBlockFormat&lt;/a&gt;, &lt;a href=&quot;qtextlistformat&quot;&gt;QTextListFormat&lt;/a&gt;, and &lt;a href=&quot;qtexttableformat&quot;&gt;QTextTableFormat&lt;/a&gt; are usually more useful, and describe the formatting that is applied to specific parts of the document.</source>
          <target state="translated">QTextFormat는 부분의 포맷을 설명하기 위해 사용되는 일반적인 클래스 &lt;a href=&quot;qtextdocument&quot;&gt;QTextDocument를&lt;/a&gt; . 파생 클래스 &lt;a href=&quot;qtextcharformat&quot;&gt;QTextCharFormat&lt;/a&gt; , &lt;a href=&quot;qtextblockformat&quot;&gt;QTextBlockFormat&lt;/a&gt; , &lt;a href=&quot;qtextlistformat&quot;&gt;QTextListFormat&lt;/a&gt; 및 &lt;a href=&quot;qtexttableformat&quot;&gt;QTextTableFormat&lt;/a&gt; 은 일반적으로 더 유용하며 문서의 특정 부분에 적용되는 서식을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="1c9a7d5c6aee0acf55614ed7bc03a84554a5ab86" translate="yes" xml:space="preserve">
          <source>A QThread object manages one thread of control within the program. QThreads begin executing in &lt;a href=&quot;qthread#run&quot;&gt;run&lt;/a&gt;(). By default, &lt;a href=&quot;qthread#run&quot;&gt;run&lt;/a&gt;() starts the event loop by calling &lt;a href=&quot;qthread#exec&quot;&gt;exec&lt;/a&gt;() and runs a Qt event loop inside the thread.</source>
          <target state="translated">QThread 객체는 프로그램 내에서 하나의 제어 스레드를 관리합니다. QThreads는 &lt;a href=&quot;qthread#run&quot;&gt;run&lt;/a&gt; () 에서 실행을 시작합니다 . 기본적으로 &lt;a href=&quot;qthread#run&quot;&gt;run&lt;/a&gt; ()은 &lt;a href=&quot;qthread#exec&quot;&gt;exec&lt;/a&gt; () 를 호출하여 이벤트 루프를 시작 하고 스레드 내에서 Qt 이벤트 루프를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="a7b881e18ec2197596246ab012b4955a4bc54a0d" translate="yes" xml:space="preserve">
          <source>A QTime object contains a clock time, which it can express as the numbers of hours, minutes, seconds, and milliseconds since midnight. It provides functions for comparing times and for manipulating a time by adding a number of milliseconds.</source>
          <target state="translated">QTime 객체에는 자정 이후의 시간, 분, 초 및 밀리 초 수로 표현할 수있는 시계 시간이 포함됩니다. 시간을 비교하고 밀리 초를 추가하여 시간을 조작하는 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="af114bd57a04702ac4da423d02f272b5510b4a89" translate="yes" xml:space="preserve">
          <source>A QTime object contains a clock time, which it can express as the numbers of hours, minutes, seconds, and milliseconds since midnight. It provides functions for comparing times and for manipulating a time by adding a number of milliseconds. QTime objects should be passed by value rather than by reference to const; they simply package &lt;code&gt;int&lt;/code&gt;.</source>
          <target state="translated">QTime 객체는 자정 이후의 시간, 분, 초 및 밀리 초 수로 표현할 수있는 시계 시간을 포함합니다. 시간을 비교하고 밀리 초를 추가하여 시간을 조작하는 기능을 제공합니다. QTime 객체는 const에 대한 참조가 아닌 값으로 전달되어야합니다. 그들은 단순히 &lt;code&gt;int&lt;/code&gt; 를 패키지화합니다 .</target>
        </trans-unit>
        <trans-unit id="a8862b8cb64cbde87885784c4c4cc78ec2ee5cd0" translate="yes" xml:space="preserve">
          <source>A QTime object is typically created either by giving the number of hours, minutes, seconds, and milliseconds explicitly, or by using the static function &lt;a href=&quot;qtime#currentTime&quot;&gt;currentTime&lt;/a&gt;(), which creates a QTime object that represents the system's local time.</source>
          <target state="translated">QTime 객체는 일반적으로시, 분, 초 및 밀리 초 수를 명시 적으로 제공하거나 시스템의 현지 시간을 나타내는 QTime 객체를 만드는 정적 함수 &lt;a href=&quot;qtime#currentTime&quot;&gt;currentTime&lt;/a&gt; () 을 사용하여 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="d13386a2bf8b8eab288da64e3108bb5c2d5f7e13" translate="yes" xml:space="preserve">
          <source>A QTransform object can be built using the &lt;a href=&quot;qtransform#setMatrix&quot;&gt;setMatrix&lt;/a&gt;(), &lt;a href=&quot;qtransform#scale&quot;&gt;scale&lt;/a&gt;(), &lt;a href=&quot;qtransform#rotate&quot;&gt;rotate&lt;/a&gt;(), &lt;a href=&quot;qtransform#translate&quot;&gt;translate&lt;/a&gt;() and &lt;a href=&quot;qtransform#shear&quot;&gt;shear&lt;/a&gt;() functions. Alternatively, it can be built by applying &lt;a href=&quot;qtransform#basic-matrix-operations&quot;&gt;basic matrix operations&lt;/a&gt;. The matrix can also be defined when constructed, and it can be reset to the identity matrix (the default) using the &lt;a href=&quot;qtransform#reset&quot;&gt;reset&lt;/a&gt;() function.</source>
          <target state="translated">QTransform 객체는 &lt;a href=&quot;qtransform#setMatrix&quot;&gt;setMatrix&lt;/a&gt; (), &lt;a href=&quot;qtransform#scale&quot;&gt;scale&lt;/a&gt; (), &lt;a href=&quot;qtransform#rotate&quot;&gt;rotate&lt;/a&gt; (), &lt;a href=&quot;qtransform#translate&quot;&gt;translate&lt;/a&gt; () 및 &lt;a href=&quot;qtransform#shear&quot;&gt;shear&lt;/a&gt; () 함수를 사용하여 만들 수 있습니다 . 또는 &lt;a href=&quot;qtransform#basic-matrix-operations&quot;&gt;기본 행렬 연산&lt;/a&gt; 을 적용하여 만들 수 있습니다 . 행렬은 생성 될 때 정의 할 수도 있으며 &lt;a href=&quot;qtransform#reset&quot;&gt;reset&lt;/a&gt; () 함수를 사용하여 단위 행렬 (기본값)로 재설정 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="972fdd6fa5e879ba4afca5754a52d449269da4ed" translate="yes" xml:space="preserve">
          <source>A QTransform object contains a 3 x 3 matrix. The &lt;code&gt;m31&lt;/code&gt; (&lt;code&gt;dx&lt;/code&gt;) and &lt;code&gt;m32&lt;/code&gt; (&lt;code&gt;dy&lt;/code&gt;) elements specify horizontal and vertical translation. The &lt;code&gt;m11&lt;/code&gt; and &lt;code&gt;m22&lt;/code&gt; elements specify horizontal and vertical scaling. The &lt;code&gt;m21&lt;/code&gt; and &lt;code&gt;m12&lt;/code&gt; elements specify horizontal and vertical</source>
          <target state="translated">QTransform 객체는 3 x 3 행렬을 포함합니다. &lt;code&gt;m31&lt;/code&gt; ( &lt;code&gt;dx&lt;/code&gt; ) 및 &lt;code&gt;m32&lt;/code&gt; ( &lt;code&gt;dy&lt;/code&gt; ) 요소는 수평 및 수직 변환을 지정. &lt;code&gt;m11&lt;/code&gt; 및 &lt;code&gt;m22&lt;/code&gt; 요소는 수평 및 수직 스케일을 지정. &lt;code&gt;m21&lt;/code&gt; 및 &lt;code&gt;m12&lt;/code&gt; 요소는 수평 및 수직 지정할</target>
        </trans-unit>
        <trans-unit id="4e05407399c11bf9ce7618b9331ff9daacdfde9b" translate="yes" xml:space="preserve">
          <source>A QTreeView implements a tree representation of items from a model. This class is used to provide standard hierarchical lists that were previously provided by the &lt;code&gt;QListView&lt;/code&gt; class, but using the more flexible approach provided by Qt's model/view architecture.</source>
          <target state="translated">QTreeView는 모델 항목의 트리 표현을 구현합니다. 이 클래스는 이전에 &lt;code&gt;QListView&lt;/code&gt; 클래스에서 제공 한 표준 계층 적 목록을 제공하는 데 사용 되지만 Qt의 모델 / 뷰 아키텍처에서 제공하는보다 유연한 접근 방식을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="24eb1d07cb079b7240d39ed1738868e895d5c458" translate="yes" xml:space="preserve">
          <source>A QUndoCommand has an associated &lt;a href=&quot;qundocommand#text&quot;&gt;text&lt;/a&gt;(). This is a short string describing what the command does. It is used to update the text properties of the stack's undo and redo actions; see &lt;a href=&quot;qundostack#createUndoAction&quot;&gt;QUndoStack::createUndoAction&lt;/a&gt;() and &lt;a href=&quot;qundostack#createRedoAction&quot;&gt;QUndoStack::createRedoAction&lt;/a&gt;().</source>
          <target state="translated">QUndoCommand에는 연관된 &lt;a href=&quot;qundocommand#text&quot;&gt;텍스트&lt;/a&gt; ()가 있습니다. 명령이 수행하는 작업을 설명하는 짧은 문자열입니다. 스택의 실행 취소 및 다시 실행 작업의 텍스트 속성을 업데이트하는 데 사용됩니다. &lt;a href=&quot;qundostack#createUndoAction&quot;&gt;QUndoStack :: createUndoAction&lt;/a&gt; () 및 &lt;a href=&quot;qundostack#createRedoAction&quot;&gt;QUndoStack :: createRedoAction&lt;/a&gt; ()을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="41039dff65f1a57a9116d21f630d4f31423c53b7" translate="yes" xml:space="preserve">
          <source>A QUndoCommand represents a single editing action on a document; for example, inserting or deleting a block of text in a text editor. QUndoCommand can apply a change to the document with &lt;a href=&quot;qundocommand#redo&quot;&gt;redo&lt;/a&gt;() and undo the change with &lt;a href=&quot;qundocommand#undo&quot;&gt;undo&lt;/a&gt;(). The implementations for these functions must be provided in a derived class.</source>
          <target state="translated">QUndoCommand는 문서에 대한 단일 편집 작업을 나타냅니다. 예를 들어, 텍스트 편집기에서 텍스트 블록을 삽입하거나 삭제합니다. QUndoCommand는 &lt;a href=&quot;qundocommand#redo&quot;&gt;다시 실행&lt;/a&gt; ()으로 문서에 변경 사항을 적용 하고 실행 &lt;a href=&quot;qundocommand#undo&quot;&gt;취소&lt;/a&gt; ()로 변경 사항을 취소 할 수 있습니다 . 이러한 함수에 대한 구현은 파생 클래스에서 제공되어야합니다.</target>
        </trans-unit>
        <trans-unit id="76359b378d0769a4e50c89b1947b0ea78a978dca" translate="yes" xml:space="preserve">
          <source>A QUndoGroup is also useful in conjunction with &lt;a href=&quot;qundoview&quot;&gt;QUndoView&lt;/a&gt;. If a &lt;a href=&quot;qundoview&quot;&gt;QUndoView&lt;/a&gt; is set to watch a group using &lt;a href=&quot;qundoview#setGroup&quot;&gt;QUndoView::setGroup&lt;/a&gt;(), it will update itself to display the active stack.</source>
          <target state="translated">QUndoGroup도 함께 유용하다 &lt;a href=&quot;qundoview&quot;&gt;QUndoView&lt;/a&gt; . 경우 &lt;a href=&quot;qundoview&quot;&gt;QUndoView을&lt;/a&gt; 사용하여 그룹을보기 위해 설정 &lt;a href=&quot;qundoview#setGroup&quot;&gt;QUndoView :: setGroup를&lt;/a&gt; ()는 활성 스택을 표시하기 위해 자동으로 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="a695d0c4ec8650516ddf2943681ebc5ed008e5d0" translate="yes" xml:space="preserve">
          <source>A QUtf8StringView references a contiguous portion of a UTF-8 string it does not own. It acts as an interface type to all kinds of UTF-8 string, without the need to construct a &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; or &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; first.</source>
          <target state="translated">QUtf8StringView는 소유하지 않은 UTF-8 문자열의 연속 부분을 참조합니다. &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; 또는 &lt;a href=&quot;qbytearray&quot;&gt;QByteArray를&lt;/a&gt; 먼저 구성 할 필요없이 모든 종류의 UTF-8 문자열에 대한 인터페이스 유형으로 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="08211b575f2bfb7700ea1da0abf6352f34d48612" translate="yes" xml:space="preserve">
          <source>A QVariant object holds a single value of a single &lt;a href=&quot;qvariant#type&quot;&gt;type&lt;/a&gt;() at a time. (Some &lt;a href=&quot;qvariant#type&quot;&gt;type&lt;/a&gt;()s are multi-valued, for example a string list.) You can find out what type, T, the variant holds, convert it to a different type using &lt;a href=&quot;qvariant#convert&quot;&gt;convert&lt;/a&gt;(), get its value using one of the toT() functions (e.g., &lt;a href=&quot;qvariant#toSize&quot;&gt;toSize&lt;/a&gt;()) and check whether the type can be converted to a particular type using &lt;a href=&quot;qvariant#canConvert-1&quot;&gt;canConvert&lt;/a&gt;().</source>
          <target state="translated">QVariant 객체는 한 번에 단일 &lt;a href=&quot;qvariant#type&quot;&gt;유형&lt;/a&gt; () 의 단일 값을 보유합니다 . (일부 &lt;a href=&quot;qvariant#type&quot;&gt;유형&lt;/a&gt; ()은 문자열 목록과 같이 다중 값입니다.) 어떤 유형, T, 변형이 보유하고 있는지 확인하고 &lt;a href=&quot;qvariant#convert&quot;&gt;convert&lt;/a&gt; ()를 사용하여 다른 유형으로 변환 하고 toT 중 하나를 사용하여 값을 가져올 수 있습니다. () 함수 (예 : &lt;a href=&quot;qvariant#toSize&quot;&gt;toSize&lt;/a&gt; ())를 사용하고 &lt;a href=&quot;qvariant#canConvert-1&quot;&gt;canConvert&lt;/a&gt; ()를 사용하여 유형을 특정 유형으로 변환 할 수 있는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="32802023ceb423e284b81b269a6d20c8576db351" translate="yes" xml:space="preserve">
          <source>A QVariant object holds a single value of a single type() at a time. (Some type()s are multi-valued, for example a string list.) You can find out what type, T, the variant holds, convert it to a different type using &lt;a href=&quot;qvariant#convert&quot;&gt;convert&lt;/a&gt;(), get its value using one of the toT() functions (e.g., &lt;a href=&quot;qvariant#toSize&quot;&gt;toSize&lt;/a&gt;()) and check whether the type can be converted to a particular type using &lt;a href=&quot;qvariant#canConvert-2&quot;&gt;canConvert&lt;/a&gt;().</source>
          <target state="translated">QVariant 객체는 한 번에 단일 type ()의 단일 값을 보유합니다. (일부 type ()은 문자열 목록과 같이 다중 값입니다.) 어떤 유형, T, 변형이 보유하고 있는지 확인하고 &lt;a href=&quot;qvariant#convert&quot;&gt;convert&lt;/a&gt; ()를 사용하여 다른 유형으로 변환 하고 toT 중 하나를 사용하여 값을 가져올 수 있습니다. () 함수 (예 : &lt;a href=&quot;qvariant#toSize&quot;&gt;toSize&lt;/a&gt; ())를 사용하고 &lt;a href=&quot;qvariant#canConvert-2&quot;&gt;canConvert&lt;/a&gt; ()를 사용하여 유형을 특정 유형으로 변환 할 수 있는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="2735804c8e837bbc5ef85339d13ad7551af3b9c4" translate="yes" xml:space="preserve">
          <source>A QVideoFrame encapsulates the pixel data of a video frame, and information about the frame.</source>
          <target state="translated">QVideoFrame은 비디오 프레임의 픽셀 데이터와 프레임에 대한 정보를 캡슐화합니다.</target>
        </trans-unit>
        <trans-unit id="403df26e27e4d9a0ccc9d04540f5cb61d43c5cb0" translate="yes" xml:space="preserve">
          <source>A QWebEngineUrlRequestJob is given to &lt;a href=&quot;qwebengineurlschemehandler#requestStarted&quot;&gt;QWebEngineUrlSchemeHandler::requestStarted&lt;/a&gt;() and must be handled by the derived implementations of the class. The job can be handled by calling either &lt;a href=&quot;qwebengineurlrequestjob#reply&quot;&gt;reply&lt;/a&gt;(), &lt;a href=&quot;qwebengineurlrequestjob#redirect&quot;&gt;redirect&lt;/a&gt;(), or &lt;a href=&quot;qwebengineurlrequestjob#fail&quot;&gt;fail&lt;/a&gt;().</source>
          <target state="translated">QWebEngineUrlRequestJob은 &lt;a href=&quot;qwebengineurlschemehandler#requestStarted&quot;&gt;QWebEngineUrlSchemeHandler :: requestStarted&lt;/a&gt; ()에 제공되며 클래스의 파생 구현에 의해 처리되어야합니다. &lt;a href=&quot;qwebengineurlrequestjob#reply&quot;&gt;응답&lt;/a&gt; (), &lt;a href=&quot;qwebengineurlrequestjob#redirect&quot;&gt;리디렉션&lt;/a&gt; () 또는 &lt;a href=&quot;qwebengineurlrequestjob#fail&quot;&gt;실패&lt;/a&gt; () 를 호출하여 작업을 처리 할 수 ​​있습니다 .</target>
        </trans-unit>
        <trans-unit id="a152ca10de7a2c15fc088f7428e086a31b8404d0" translate="yes" xml:space="preserve">
          <source>A Qt Quick application requires also additional dependencies:</source>
          <target state="translated">Qt Quick 애플리케이션에는 다음과 같은 추가 종속성이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="396da1e4cf2b474616d0d8a75d9d8ffd9b60cdcb" translate="yes" xml:space="preserve">
          <source>A Qt Quick game for touch devices that uses SpriteSequence, ParticleSystem, Emitter, and Wander types to animate objects and the SoundEffect type to play sound effects</source>
          <target state="translated">SpriteSequence, ParticleSystem, Emitter 및 Wander 유형을 사용하여 객체에 애니메이션을 적용하고 SoundEffect 유형을 사용하여 사운드 효과를 재생하는 터치 장치 용 Qt Quick 게임</target>
        </trans-unit>
        <trans-unit id="1780afd02e7529e96a406608bf595a9813b0715b" translate="yes" xml:space="preserve">
          <source>A Qt Quick item type for displaying and interacting with a &lt;a href=&quot;qml-qtwayland-compositor-shellsurface&quot;&gt;ShellSurface&lt;/a&gt;. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;qml-qtwayland-compositor-shellsurface&quot;&gt;ShellSurface&lt;/a&gt; 표시 및 상호 작용을위한 Qt Quick 항목 유형입니다 . &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b86136452304a51a734d41ed8bb4f1a6fcf7550d" translate="yes" xml:space="preserve">
          <source>A Qt application can host any ActiveScript engine installed on the system. The script engine can then run script code that accesses the COM objects.</source>
          <target state="translated">Qt 애플리케이션은 시스템에 설치된 모든 ActiveScript 엔진을 호스팅 할 수 있습니다. 그런 다음 스크립트 엔진은 COM 개체에 액세스하는 스크립트 코드를 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b28ce28f8d0d3fce04fffc8c7e476be6866d391" translate="yes" xml:space="preserve">
          <source>A Qt application can load this QML document and set the value of &lt;code&gt;myModel&lt;/code&gt; to a &lt;a href=&quot;qstringlist&quot;&gt;QStringList&lt;/a&gt;:</source>
          <target state="translated">Qt는 애플리케이션이 QML 문서로드 값 설정할 수 &lt;code&gt;myModel&lt;/code&gt; 를 (A)에 &lt;a href=&quot;qstringlist&quot;&gt;QStringList&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="8c50f9906faa08c5c686686d75be71332468a2a1" translate="yes" xml:space="preserve">
          <source>A Qt help project collects all data necessary to generate a compressed help file. Along with the actual help data, like the table of contents, index keywords and help documents, it contains some extra information like a namespace to identify the help file. One help project stands for one documentation set, for example the &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtassistant-index.html&quot;&gt;Qt Assistant Manual&lt;/a&gt;.</source>
          <target state="translated">Qt 도움말 프로젝트는 압축 된 도움말 파일을 생성하는 데 필요한 모든 데이터를 수집합니다. 목차, 색인 키워드 및 도움말 문서와 같은 실제 도움말 데이터와 함께 도움말 파일을 식별하기위한 네임 스페이스와 같은 추가 정보가 포함되어 있습니다. 하나의 도움말 프로젝트는 하나의 문서 세트 (예 : &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtassistant-index.html&quot;&gt;Qt Assistant Manual)를 나타&lt;/a&gt; 냅니다.</target>
        </trans-unit>
        <trans-unit id="cf82778fa3a6710f429a6a2bb052103268293578" translate="yes" xml:space="preserve">
          <source>A Qt help project collects all data necessary to generate a compressed help file. Along with the actual help data, like the table of contents, index keywords and help documents, it contains some extra information like a namespace to identify the help file. One help project stands for one documentation set, for example the &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtassistant-index.html&quot;&gt;Qt Assistant Manual&lt;/a&gt;.</source>
          <target state="translated">Qt 도움말 프로젝트는 압축 된 도움말 파일을 생성하는 데 필요한 모든 데이터를 수집합니다. 목차, 색인 키워드 및 도움말 문서와 같은 실제 도움말 데이터와 함께 도움말 파일을 식별하는 네임 스페이스와 같은 추가 정보가 포함되어 있습니다. 하나의 도움말 프로젝트는 하나의 문서 세트를 나타냅니다 (예 : &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtassistant-index.html&quot;&gt;Qt Assistant Manual)&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8ec57ac2ac3f26cac9aa64a83358b1552fb8d599" translate="yes" xml:space="preserve">
          <source>A Qt help project collects all data necessary to generate a compressed help file. Along with the actual help data, like the table of contents, index keywords and help documents, it contains some extra information like a namespace to identify the help file. One help project stands for one documentation set, for example the &lt;a href=&quot;qmake-manual&quot;&gt;qmake Manual&lt;/a&gt;.</source>
          <target state="translated">Qt 도움말 프로젝트는 압축 된 도움말 파일을 생성하는 데 필요한 모든 데이터를 수집합니다. 목차, 색인 키워드 및 도움말 문서와 같은 실제 도움말 데이터와 함께 도움말 파일을 식별하는 네임 스페이스와 같은 추가 정보가 포함되어 있습니다. 하나의 도움말 프로젝트는 하나의 문서 세트를 나타냅니다 (예 : &lt;a href=&quot;qmake-manual&quot;&gt;qmake Manual)&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="373d90b1db67d87b64d5ef7efd3f22340fabafd4" translate="yes" xml:space="preserve">
          <source>A Quick Start to Qt Designer</source>
          <target state="translated">Qt Designer의 빠른 시작</target>
        </trans-unit>
        <trans-unit id="2a52801e730cd9166669d08d6d5546ef1946e21a" translate="yes" xml:space="preserve">
          <source>A RadioButton is an option button that can be switched on (checked) or off (unchecked). Radio buttons typically present the user with a &quot;one of many&quot; choices. In a group of radio buttons, only one radio button can be checked at a time; if the user selects another button, the previously selected button is switched off.</source>
          <target state="translated">RadioButton은 켜거나 (선택) 해제 (선택 취소) 할 수있는 옵션 단추입니다. 라디오 버튼은 일반적으로 사용자에게 &quot;여러 가지 중 하나&quot;를 선택할 수 있도록합니다. 라디오 버튼 그룹에서는 한 번에 하나의 라디오 버튼 만 확인할 수 있습니다. 사용자가 다른 버튼을 선택하면 이전에 선택한 버튼이 꺼집니다.</target>
        </trans-unit>
        <trans-unit id="6621f1dd89b5618a721c99c526f9f683eeb189c2" translate="yes" xml:space="preserve">
          <source>A Real Example</source>
          <target state="translated">실제 예</target>
        </trans-unit>
        <trans-unit id="4daa20a6d104883e6088b08d33c3227e048d7679" translate="yes" xml:space="preserve">
          <source>A Remote Object Replica is a &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; proxy for another &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; (called the &lt;a href=&quot;qtremoteobjects-source#source&quot;&gt;Source&lt;/a&gt; object). Once initialized, a replica can be considered a &quot;latent copy&quot; of the &lt;a href=&quot;qtremoteobjects-source#source&quot;&gt;Source&lt;/a&gt; object. That is, every change to a &lt;a href=&quot;qobject#Q_PROPERTY&quot;&gt;Q_PROPERTY&lt;/a&gt; on the &lt;a href=&quot;qtremoteobjects-source#source&quot;&gt;Source&lt;/a&gt;, or signal emitted by the &lt;a href=&quot;qtremoteobjects-source#source&quot;&gt;Source&lt;/a&gt; will be updated/emitted by all &lt;a href=&quot;qtremoteobjects-replica#replica&quot;&gt;Replica&lt;/a&gt; objects. Latency is introduced by process scheduling by any OSes involved and network communication latency. As long as the replica has been initialized and the communication is not disrupted, receipt and order of changes is guaranteed.</source>
          <target state="translated">리모트 오브젝트 복제본은 다른 &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; ( &lt;a href=&quot;qtremoteobjects-source#source&quot;&gt;소스&lt;/a&gt; 오브젝트 라고 함)에 대한 &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 프록시입니다 . 일단 초기화되면 복제본은 &lt;a href=&quot;qtremoteobjects-source#source&quot;&gt;소스&lt;/a&gt; 객체 의 &quot;잠재적 인 사본&quot;으로 간주 될 수 있습니다 . 즉, (A)에 모든 변경 &lt;a href=&quot;qobject#Q_PROPERTY&quot;&gt;Q_PROPERTY&lt;/a&gt; 상의 &lt;a href=&quot;qtremoteobjects-source#source&quot;&gt;소스&lt;/a&gt; 에 의해 방사 된 신호 또는 &lt;a href=&quot;qtremoteobjects-source#source&quot;&gt;원본&lt;/a&gt; / 업데이트 될 모든 방출 &lt;a href=&quot;qtremoteobjects-replica#replica&quot;&gt;복제&lt;/a&gt; 개체. 대기 시간은 관련된 OS 및 네트워크 통신 대기 시간에 의한 프로세스 일정 계획에 의해 도입됩니다. 복제본이 초기화되고 통신이 중단되지 않는 한, 수신 및 변경 순서가 보장됩니다.</target>
        </trans-unit>
        <trans-unit id="7884495e42f5e99b08a5f07723981f23bf0a4427" translate="yes" xml:space="preserve">
          <source>A Remote Object Source is the &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; that is responsible for the implementation of the exposed API.</source>
          <target state="translated">리모트 오브젝트 소스는 노출 된 API의 구현을 담당 하는 &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6bd76d7ad63f8935e876fd96b62d4f0b1fa4d32b" translate="yes" xml:space="preserve">
          <source>A RenderPass specifies a single rendering pass - an instance of shader program execution - used by Technique. A Render pass consists of a &lt;a href=&quot;qml-qt3d-render-shaderprogram&quot;&gt;ShaderProgram&lt;/a&gt; and a list of &lt;a href=&quot;qml-qt3d-render-filterkey&quot;&gt;FilterKey&lt;/a&gt; objects, a list of &lt;a href=&quot;qml-qt3d-render-renderstate&quot;&gt;RenderState&lt;/a&gt; objects and a list of &lt;a href=&quot;qml-qt3d-render-parameter&quot;&gt;Parameter&lt;/a&gt; objects.</source>
          <target state="translated">RenderPass는 Technique에서 사용하는 단일 렌더링 패스 (셰이더 프로그램 실행 인스턴스)를 지정합니다. 렌더링 패스는 구성 &lt;a href=&quot;qml-qt3d-render-shaderprogram&quot;&gt;ShaderProgram&lt;/a&gt; 및 목록 &lt;a href=&quot;qml-qt3d-render-filterkey&quot;&gt;FilterKey는&lt;/a&gt; , 오브젝트의 목록 &lt;a href=&quot;qml-qt3d-render-renderstate&quot;&gt;렌다은&lt;/a&gt; 객체와의 목록 &lt;a href=&quot;qml-qt3d-render-parameter&quot;&gt;매개 변수가&lt;/a&gt; 객체.</target>
        </trans-unit>
        <trans-unit id="fdce6b6346da10ce32b20f636f5e1a5d9528b561" translate="yes" xml:space="preserve">
          <source>A RenderPassFilter FrameGraph node is used to select which &lt;a href=&quot;qml-qt3d-render-renderpass&quot;&gt;RenderPass&lt;/a&gt; objects are selected for drawing. When RenderPassFilter is present in the FrameGraph, only the &lt;a href=&quot;qml-qt3d-render-renderpass&quot;&gt;RenderPass&lt;/a&gt; objects, whose &lt;a href=&quot;qml-qt3d-render-filterkey&quot;&gt;FilterKey&lt;/a&gt; objects match the keys in RenderPassFilter are selected for rendering. If no RenderPassFilter is present, then all &lt;a href=&quot;qml-qt3d-render-renderpass&quot;&gt;RenderPass&lt;/a&gt; objects are selected for rendering.</source>
          <target state="translated">RenderPassFilter FrameGraph 노드는 그리기를 위해 선택된 &lt;a href=&quot;qml-qt3d-render-renderpass&quot;&gt;RenderPass&lt;/a&gt; 객체 를 선택하는 데 사용됩니다 . FrameGraph에 RenderPassFilter가 있으면 &lt;a href=&quot;qml-qt3d-render-renderpass&quot;&gt;FilterKey&lt;/a&gt; 개체 가 RenderPassFilter 의 &lt;a href=&quot;qml-qt3d-render-filterkey&quot;&gt;키&lt;/a&gt; 와 일치하는 RenderPass 개체 만 렌더링을 위해 선택됩니다. RenderPassFilter가 없으면 모든 &lt;a href=&quot;qml-qt3d-render-renderpass&quot;&gt;RenderPass&lt;/a&gt; 개체가 렌더링을 위해 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="19df5d341af3403a273d51bef9b1122287f4a319" translate="yes" xml:space="preserve">
          <source>A RenderState type is abstract base class for all render states. One can not instantiate RenderState directly, but through its subclasses.</source>
          <target state="translated">RenderState 유형은 모든 렌더링 상태에 대한 추상 기본 클래스입니다. RenderState를 직접 인스턴스화 할 수는 없지만 하위 클래스를 통해 인스턴스화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="072bbb4210acef6c35a48aac3b86cac69ad1ab63" translate="yes" xml:space="preserve">
          <source>A RenderTarget comprises of &lt;a href=&quot;qml-qt3d-render-rendertargetoutput&quot;&gt;RenderTargetOutput&lt;/a&gt; objects, which specify the the buffers the render target is rendering to. The user can specify MRT(Multiple Render Targets) by attaching multiple textures to different attachment points. The results are undefined if the user tries to attach multiple textures to the same attachment point. At render time, only the draw buffers specified in the &lt;a href=&quot;qml-qt3d-render-rendertargetselector&quot;&gt;RenderTargetSelector&lt;/a&gt; are used.</source>
          <target state="translated">RenderTarget은 &lt;a href=&quot;qml-qt3d-render-rendertargetoutput&quot;&gt;RenderTargetOutput&lt;/a&gt; 객체로 구성되며 , 렌더링 대상이 렌더링하는 버퍼를 지정합니다. 사용자는 여러 개의 텍스처를 서로 다른 부착 지점에 부착하여 MRT (Multiple Render Targets)를 지정할 수 있습니다. 사용자가 동일한 연결 지점에 여러 텍스처를 연결하려고하면 결과가 정의되지 않습니다. 렌더링시 &lt;a href=&quot;qml-qt3d-render-rendertargetselector&quot;&gt;RenderTargetSelector에&lt;/a&gt; 지정된 그리기 버퍼 만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c00c1906e5c26126adc225bd2afaaeb55d52ece2" translate="yes" xml:space="preserve">
          <source>A RenderTargetOutput specifies the attachment point and parameters for texture that is attached to render target. In addition to the attachment point, texture miplevel, layer and cubemap face can be specified. The texture attached to the RenderTargetOutput must be compatible with the given parameters.</source>
          <target state="translated">RenderTargetOutput은 렌더 대상에 연결된 텍스처의 연결 지점과 매개 변수를 지정합니다. 부착 지점 외에도 텍스처 밉 레벨, 레이어 및 큐브 맵면을 지정할 수 있습니다. RenderTargetOutput에 연결된 텍스처는 주어진 매개 변수와 호환되어야합니다.</target>
        </trans-unit>
        <trans-unit id="f1461c39e1cd9931901c8b7d6b52a28548e16a11" translate="yes" xml:space="preserve">
          <source>A RenderTargetSelector is used to select active &lt;a href=&quot;qml-qt3d-render-rendertarget&quot;&gt;RenderTarget&lt;/a&gt; for the FrameGraph. When RenderTargetSelector is present in the FrameGraph, the rendering is directed into Texture objects or draw buffers instead of the surface specified in the &lt;a href=&quot;qml-qt3d-render-rendersurfaceselector&quot;&gt;RenderSurfaceSelector&lt;/a&gt;.</source>
          <target state="translated">RenderTargetSelector는 FrameGraph의 활성 &lt;a href=&quot;qml-qt3d-render-rendertarget&quot;&gt;RenderTarget&lt;/a&gt; 을 선택하는 데 사용됩니다 . FrameGraph에 RenderTargetSelector가 있으면 렌더링이 &lt;a href=&quot;qml-qt3d-render-rendersurfaceselector&quot;&gt;RenderSurfaceSelector에&lt;/a&gt; 지정된 표면 대신 Texture 객체 또는 그리기 버퍼로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="93a97660b3db888200d74175348d326c383dcdfc" translate="yes" xml:space="preserve">
          <source>A Repeater's &lt;a href=&quot;qml-qtquick-repeater#model-prop&quot;&gt;model&lt;/a&gt; can be any of the supported &lt;a href=&quot;qtquick-modelviewsdata-modelview#qml-data-models&quot;&gt;data models&lt;/a&gt;. Additionally, like delegates for other views, a Repeater delegate can access its index within the repeater, as well as the model data relevant to the delegate. See the &lt;a href=&quot;qml-qtquick-repeater#delegate-prop&quot;&gt;delegate&lt;/a&gt; property documentation for details.</source>
          <target state="translated">리피터의 &lt;a href=&quot;qml-qtquick-repeater#model-prop&quot;&gt;모델&lt;/a&gt; 은 지원되는 &lt;a href=&quot;qtquick-modelviewsdata-modelview#qml-data-models&quot;&gt;데이터 모델&lt;/a&gt; 중 하나 일 수 있습니다 . 또한 다른 뷰의 델리게이트와 같이 Repeater 델리게이트는 델 리터와 관련된 모델 데이터뿐만 아니라 리피터 내의 인덱스에 액세스 할 수 있습니다. 자세한 내용은 &lt;a href=&quot;qml-qtquick-repeater#delegate-prop&quot;&gt;대리인&lt;/a&gt; 속성 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="69a50b6b7e5466e53c2247d794e0684c3af000d4" translate="yes" xml:space="preserve">
          <source>A Repeater's &lt;a href=&quot;qml-qtquick3d-repeater3d#model-prop&quot;&gt;model&lt;/a&gt; can be any of the supported &lt;a href=&quot;qtquick-modelviewsdata-modelview#qml-data-models&quot;&gt;data models&lt;/a&gt;. Additionally, like delegates for other views, a Repeater delegate can access its index within the repeater, as well as the model data relevant to the delegate. See the &lt;a href=&quot;qml-qtquick3d-repeater3d#delegate-prop&quot;&gt;delegate&lt;/a&gt; property documentation for details.</source>
          <target state="translated">Repeater의 &lt;a href=&quot;qml-qtquick3d-repeater3d#model-prop&quot;&gt;모델&lt;/a&gt; 은 지원되는 &lt;a href=&quot;qtquick-modelviewsdata-modelview#qml-data-models&quot;&gt;데이터 모델&lt;/a&gt; 중 하나 일 수 있습니다 . 또한 다른 뷰의 델리게이트와 마찬가지로 리피터 델리게이트는 리피터 내의 인덱스와 델리게이트와 관련된 모델 데이터에 액세스 할 수 있습니다. 자세한 내용은 &lt;a href=&quot;qml-qtquick3d-repeater3d#delegate-prop&quot;&gt;위임&lt;/a&gt; 속성 문서를 참조하세요.</target>
        </trans-unit>
        <trans-unit id="f7205d55ad3ac513810e456318f8890cd13d9ef6" translate="yes" xml:space="preserve">
          <source>A Route type contains high level information about a route, such as the length the route, the estimated travel time for the route, and enough information to render a basic image of the route on a map.</source>
          <target state="translated">경로 유형에는 경로 길이, 경로의 예상 이동 시간, 경로의 기본 이미지를지도에 렌더링하기에 충분한 정보 등 경로에 대한 고급 정보가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="c1bda6f827b4710686725ce355c3cab73bd13d51" translate="yes" xml:space="preserve">
          <source>A RouteQuery is used to pack all the parameters necessary to make a request to a routing service, which can then populate the contents of a &lt;a href=&quot;qml-qtlocation-routemodel&quot;&gt;RouteModel&lt;/a&gt;.</source>
          <target state="translated">RouteQuery는 라우팅 서비스에 요청하는 데 필요한 모든 매개 변수를 압축하는 데 사용되며, 그러면 &lt;a href=&quot;qml-qtlocation-routemodel&quot;&gt;RouteModel&lt;/a&gt; 의 콘텐츠를 채울 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1c3a81afec5dc5a866d37ad076630882c3e3341f" translate="yes" xml:space="preserve">
          <source>A RouteSegment instance has information about the physical layout of the route segment, the length of the route and estimated time required to traverse the route segment and optional RouteManeuvers associated with the end of the route segment.</source>
          <target state="translated">RouteSegment 인스턴스에는 경로 세그먼트의 물리적 레이아웃, 경로의 길이, 경로 세그먼트를 횡단하는 데 필요한 예상 시간 및 경로 세그먼트의 끝과 관련된 선택적 RouteManeuvers에 대한 정보가 있습니다.</target>
        </trans-unit>
        <trans-unit id="ffb690330ab626e6963b926b2b3b53ca3e49e7cf" translate="yes" xml:space="preserve">
          <source>A SQL field name</source>
          <target state="translated">SQL 필드 이름</target>
        </trans-unit>
        <trans-unit id="c5f1f413a7d740c49a137a3a67998bab62883c51" translate="yes" xml:space="preserve">
          <source>A SQL table name</source>
          <target state="translated">SQL 테이블 이름</target>
        </trans-unit>
        <trans-unit id="88155aff483a47e96f4fd97d70fbc50056f95e92" translate="yes" xml:space="preserve">
          <source>A ScissorTest type enables scissor test, which discards fragments outside the rectangular area of the screen specified by the left, bottom, width and height properties.</source>
          <target state="translated">ScissorTest 유형은 가위 테스트를 활성화하여 left, bottom, width 및 height 속성으로 지정된 화면의 사각형 영역 외부에있는 조각을 버립니다.</target>
        </trans-unit>
        <trans-unit id="dd57b8c39f4badbaad286d8eb1d897038f5cba07" translate="yes" xml:space="preserve">
          <source>A ScrollView can be used either to replace a &lt;a href=&quot;qml-qtquick-flickable&quot;&gt;Flickable&lt;/a&gt; or decorate an existing &lt;a href=&quot;qml-qtquick-flickable&quot;&gt;Flickable&lt;/a&gt;. Depending on the platform, it will add scroll bars and a content frame.</source>
          <target state="translated">ScrollView를 사용하여 &lt;a href=&quot;qml-qtquick-flickable&quot;&gt;Flickable&lt;/a&gt; 을 대체 하거나 기존 &lt;a href=&quot;qml-qtquick-flickable&quot;&gt;Flickable을&lt;/a&gt; 장식 할 수 있습니다 . 플랫폼에 따라 스크롤바와 콘텐츠 프레임이 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="790f0681b47e45637cd8fc3679a41f384c715b0d" translate="yes" xml:space="preserve">
          <source>A Shift key on the keyboard is pressed.</source>
          <target state="translated">키보드의 Shift 키가 눌려 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8ec3a90ed9a2a632d024de5fb1c8d0a3c3c2d22" translate="yes" xml:space="preserve">
          <source>A Shift key on the keyboard must be pressed.</source>
          <target state="translated">키보드의 Shift 키를 눌러야합니다.</target>
        </trans-unit>
        <trans-unit id="228e710c8f0864592ab0eb6de2fe5a5635085cd0" translate="yes" xml:space="preserve">
          <source>A Short Path to XQuery</source>
          <target state="translated">XQuery 로의 짧은 길</target>
        </trans-unit>
        <trans-unit id="b671ac0d028246c423146116e7e15964cde16b69" translate="yes" xml:space="preserve">
          <source>A Simple Example</source>
          <target state="translated">간단한 예</target>
        </trans-unit>
        <trans-unit id="398afec2838a221a1a7feeecbef89a3c963cc504" translate="yes" xml:space="preserve">
          <source>A Simple Forward Renderer</source>
          <target state="translated">간단한 포워드 렌더러</target>
        </trans-unit>
        <trans-unit id="85aa5a207b4c476aa65dd9720b0c24a87bce2896" translate="yes" xml:space="preserve">
          <source>A Simple Plugin</source>
          <target state="translated">간단한 플러그인</target>
        </trans-unit>
        <trans-unit id="11d83a91467702ba45c8fb7e546e2ec338cb519a" translate="yes" xml:space="preserve">
          <source>A Simple State Machine</source>
          <target state="translated">간단한 상태 머신</target>
        </trans-unit>
        <trans-unit id="d817b3db003caca03a74d56c37b4d6dd03e46cba" translate="yes" xml:space="preserve">
          <source>A Small Example</source>
          <target state="translated">작은 예</target>
        </trans-unit>
        <trans-unit id="a3cf85dbd6256c0df442b242935bb7e2400cd0eb" translate="yes" xml:space="preserve">
          <source>A SmoothedAnimation animates a property's value to a set target value using an ease in/out quad easing curve. When the target value changes, the easing curves used to animate between the old and new target values are smoothly spliced together to create a smooth movement to the new target value that maintains the current velocity.</source>
          <target state="translated">SmoothedAnimation은 이즈 인 / 아웃 쿼드 이징 곡선을 사용하여 속성 값을 설정된 대상 값으로 애니메이션합니다. 대상 값이 변경되면 이전 대상 값과 새 대상 값 사이를 애니메이션하는 데 사용되는 여유 곡선이 매끄럽게 연결되어 현재 속도를 유지하는 새 대상 값으로 부드럽게 이동합니다.</target>
        </trans-unit>
        <trans-unit id="1d183823e65b226bb0068037ff0ca8915b407f34" translate="yes" xml:space="preserve">
          <source>A SmoothedAnimation can be configured by setting the &lt;a href=&quot;qml-qtquick-smoothedanimation#velocity-prop&quot;&gt;velocity&lt;/a&gt; at which the animation should occur, or the &lt;a href=&quot;qml-qtquick-smoothedanimation#duration-prop&quot;&gt;duration&lt;/a&gt; that the animation should take. If both the &lt;a href=&quot;qml-qtquick-smoothedanimation#velocity-prop&quot;&gt;velocity&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-smoothedanimation#duration-prop&quot;&gt;duration&lt;/a&gt; are specified, the one that results in the quickest animation is chosen for each change in the target value.</source>
          <target state="translated">SmoothedAnimation은 애니메이션이 발생 하는 &lt;a href=&quot;qml-qtquick-smoothedanimation#velocity-prop&quot;&gt;속도&lt;/a&gt; 또는 애니메이션이 소요 되는 &lt;a href=&quot;qml-qtquick-smoothedanimation#duration-prop&quot;&gt;시간&lt;/a&gt; 을 설정하여 구성 할 수 있습니다 . 양쪽 경우 &lt;a href=&quot;qml-qtquick-smoothedanimation#velocity-prop&quot;&gt;속도&lt;/a&gt; 및 &lt;a href=&quot;qml-qtquick-smoothedanimation#duration-prop&quot;&gt;기간이&lt;/a&gt; 지정되어, 빠른 애니메이션 결과가 목표 값의 각 변경을 위해 선택되는 하나.</target>
        </trans-unit>
        <trans-unit id="402aaa2736122b5928d1b30f337e5612fd9a3f74" translate="yes" xml:space="preserve">
          <source>A SortPolicy class stores the sorting type used by the FrameGraph. The sort types determine how drawable entities are sorted before drawing to determine the drawing order. When SortPolicy is present in the FrameGraph, the sorting mechanism is determined by the &lt;a href=&quot;qml-qt3d-render-sortpolicy#sortTypes-prop&quot;&gt;sortTypes&lt;/a&gt; list. Multiple sort types can be used simultaneously. If SortPolicy is not present in the FrameGraph, entities are drawn in the order they appear in the entity hierarchy.</source>
          <target state="translated">SortPolicy 클래스는 FrameGraph에서 사용하는 정렬 유형을 저장합니다. 정렬 유형은 그리기 순서를 결정하기 위해 그리기 전에 그리기 가능 엔티티가 정렬되는 방식을 결정합니다. FrameGraph에 SortPolicy가있는 경우 정렬 메커니즘은 &lt;a href=&quot;qml-qt3d-render-sortpolicy#sortTypes-prop&quot;&gt;sortTypes&lt;/a&gt; 목록에 의해 결정됩니다 . 여러 정렬 유형을 동시에 사용할 수 있습니다. FrameGraph에 SortPolicy가없는 경우 엔터티는 엔터티 계층 구조에 나타나는 순서대로 그려집니다.</target>
        </trans-unit>
        <trans-unit id="50d3e12bc2952220c8d5262cb8c818de22eae93a" translate="yes" xml:space="preserve">
          <source>A StateChangeScript is run upon entering a state. You can optionally use &lt;a href=&quot;qml-qtquick-scriptaction&quot;&gt;ScriptAction&lt;/a&gt; to specify the point in the transition at which the StateChangeScript should be run.</source>
          <target state="translated">StateChangeScript는 상태에 들어가면 실행됩니다. 선택적으로 &lt;a href=&quot;qml-qtquick-scriptaction&quot;&gt;ScriptAction&lt;/a&gt; 을 사용하여 StateChangeScript가 실행되어야하는 전환 지점을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="98254de9361ef05712fe213aa09400c9a20c2b30" translate="yes" xml:space="preserve">
          <source>A StatusIndicator in the active state.</source>
          <target state="translated">활성 상태의 StatusIndicator입니다.</target>
        </trans-unit>
        <trans-unit id="103469710abd7c0e18e6f24c3901698c1518c523" translate="yes" xml:space="preserve">
          <source>A StatusIndicator in the inactive state.</source>
          <target state="translated">비활성 상태의 StatusIndicator입니다.</target>
        </trans-unit>
        <trans-unit id="76c206a984a0845acf63936f0cac096733e14b24" translate="yes" xml:space="preserve">
          <source>A StencilMask type specifies the mask for the stencil test. Mask can be specified separately for the front-facing and back-facing polygons. The stencil test reference value and stencil buffer value gets and'd with the mask prior to applying stencil function.</source>
          <target state="translated">StencilMask 유형은 스텐실 테스트를위한 마스크를 지정합니다. 마스크는 전면 및 후면 다각형에 대해 별도로 지정할 수 있습니다. 스텐실 테스트 참조 값과 스텐실 버퍼 값은 스텐실 기능을 적용하기 전에 마스크와 함께 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="8a15bb387ac1cefab0464ba24f4032cdf3dcbee4" translate="yes" xml:space="preserve">
          <source>A StencilOperation type specifies the stencil operations for the front- and back-facing polygons. The stencil operation control what is done to fragment when the stencil and depth test pass or fail.</source>
          <target state="translated">StencilOperation 유형은 전면 및 후면 다각형에 대한 스텐실 작업을 지정합니다. 스텐실 작업은 스텐실 및 깊이 테스트가 통과하거나 실패 할 때 조각화에 수행되는 작업을 제어합니다.</target>
        </trans-unit>
        <trans-unit id="df362e6f3521ba6fe1b1022e45cfa446391c7252" translate="yes" xml:space="preserve">
          <source>A StencilTest type specifies argument for the stencil test. The stencil test comprises of three arguments: stencil test function, stencil test mask and stencil reference value. StencilTest allows these arguments to be set for both front- and back-facing polygons separately.</source>
          <target state="translated">StencilTest 유형은 스텐실 테스트에 대한 인수를 지정합니다. 스텐실 테스트는 스텐실 테스트 함수, 스텐실 테스트 마스크 및 스텐실 참조 값의 세 가지 인수로 구성됩니다. StencilTest를 사용하면 이러한 인수를 전면 및 후면 다각형 모두에 대해 별도로 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b32ca5bd8c5f712c1dc2a9d89b661a6aa1c1f5f" translate="yes" xml:space="preserve">
          <source>A Stylus.</source>
          <target state="translated">스타일러스.</target>
        </trans-unit>
        <trans-unit id="d871924e2ff98bf8236ff757c74937a321dd2d54" translate="yes" xml:space="preserve">
          <source>A Swipe gesture.</source>
          <target state="translated">스 와이프 제스처</target>
        </trans-unit>
        <trans-unit id="4f6c67498a1348916cd29fef1d1e36f7d52e9e57" translate="yes" xml:space="preserve">
          <source>A Switch is a toggle button that can be switched on (checked) or off (unchecked). Switches are typically used to represent features in an application that can be enabled or disabled without affecting others.</source>
          <target state="translated">스위치는 켜거나 (체크) 해제 (확인) 할 수있는 토글 단추입니다. 스위치는 일반적으로 다른 기능에 영향을주지 않고 활성화 또는 비활성화 할 수있는 응용 프로그램 기능을 나타내는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0a809a1eb554819a273035210ecbcee04ac29580" translate="yes" xml:space="preserve">
          <source>A TCP connection must be established to a remote host and port before any data transfer can begin. Once the connection has been established, the IP address and port of the peer are available through &lt;a href=&quot;qabstractsocket#peerAddress&quot;&gt;QTcpSocket::peerAddress&lt;/a&gt;() and &lt;a href=&quot;qabstractsocket#peerPort&quot;&gt;QTcpSocket::peerPort&lt;/a&gt;(). At any time, the peer can close the connection, and data transfer will then stop immediately.</source>
          <target state="translated">데이터 전송을 시작하기 전에 원격 호스트 및 포트에 TCP 연결을 설정해야합니다. 연결이 설정되면 &lt;a href=&quot;qabstractsocket#peerAddress&quot;&gt;QTcpSocket :: peerAddress&lt;/a&gt; () 및 &lt;a href=&quot;qabstractsocket#peerPort&quot;&gt;QTcpSocket :: peerPort&lt;/a&gt; ()를 통해 피어의 IP 주소와 포트를 사용할 수 있습니다 . 언제든지 피어가 연결을 닫을 수 있으며 데이터 전송이 즉시 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="cd3d57ccca246112a91fd5dc19c22fdb57b03aea" translate="yes" xml:space="preserve">
          <source>A TCP connection using the standard TCP/IP protocol - supports connections between devices as well as between processes on the same device.</source>
          <target state="translated">표준 TCP / IP 프로토콜을 사용하는 TCP 연결-장치 간 연결은 물론 동일한 장치의 프로세스 간 연결을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="c9d10035f4a30f204261ce4ca96eae4ab22660b0" translate="yes" xml:space="preserve">
          <source>A Tab item inherits from Loader and provides a similar API.</source>
          <target state="translated">탭 항목은 로더에서 상속되며 유사한 API를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="33132d9d7b7ac8b3fcbb7943172023137e4cba4b" translate="yes" xml:space="preserve">
          <source>A TabPosition enum value that indicates the tab's position on the bar relative to the other tabs.</source>
          <target state="translated">다른 탭에 대한 막대의 탭 위치를 나타내는 TabPosition 열거 형 값입니다.</target>
        </trans-unit>
        <trans-unit id="15e3867a7da41c74b7595f769db17d6056ae696b" translate="yes" xml:space="preserve">
          <source>A TableView displays data from models created from built-in QML types such as &lt;a href=&quot;qml-qtqml-models-listmodel&quot;&gt;ListModel&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-xmllistmodel-xmllistmodel&quot;&gt;XmlListModel&lt;/a&gt;, which populates the first column only in a TableView. To create models with multiple columns, either use &lt;a href=&quot;qml-qt-labs-qmlmodels-tablemodel&quot;&gt;TableModel&lt;/a&gt; or a C++ model that inherits &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt;.</source>
          <target state="translated">TableView는 TableView 의 첫 번째 열만 채우는 &lt;a href=&quot;qml-qtqml-models-listmodel&quot;&gt;ListModel&lt;/a&gt; 및 &lt;a href=&quot;qml-qtquick-xmllistmodel-xmllistmodel&quot;&gt;XmlListModel&lt;/a&gt; 과 같은 기본 제공 QML 유형에서 생성 된 모델의 데이터를 표시합니다 . 여러 열이있는 모델을 만들려면 &lt;a href=&quot;qml-qt-labs-qmlmodels-tablemodel&quot;&gt;TableModel&lt;/a&gt; 또는 &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; 을 상속하는 C ++ 모델을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="5c5b5de446cc7a13d9bdc1b8c95b408ae7aad7b9" translate="yes" xml:space="preserve">
          <source>A TableView displays data from models created from built-in QML types such as &lt;a href=&quot;qml-qtqml-models-listmodel&quot;&gt;ListModel&lt;/a&gt; and XmlListModel, which populates the first column only in a TableView. To create models with multiple columns, either use &lt;a href=&quot;qml-qt-labs-qmlmodels-tablemodel&quot;&gt;TableModel&lt;/a&gt; or a C++ model that inherits &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt;.</source>
          <target state="translated">TableView는 TableView 의 첫 번째 열만 채우는 &lt;a href=&quot;qml-qtqml-models-listmodel&quot;&gt;ListModel&lt;/a&gt; 및 XmlListModel과 같은 기본 제공 QML 유형에서 생성 된 모델의 데이터를 표시합니다 . 여러 열이있는 모델을 만들려면 &lt;a href=&quot;qml-qt-labs-qmlmodels-tablemodel&quot;&gt;TableModel&lt;/a&gt; 또는 &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; 을 상속하는 C ++ 모델을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="77a0a337eed170bdc5b99fb09ef59aa9d6a701f8" translate="yes" xml:space="preserve">
          <source>A TableView has a &lt;a href=&quot;qml-qtquick-tableview#model-prop&quot;&gt;model&lt;/a&gt; that defines the data to be displayed, and a &lt;a href=&quot;qml-qtquick-tableview#delegate-prop&quot;&gt;delegate&lt;/a&gt; that defines how the data should be displayed.</source>
          <target state="translated">TableView에는 표시 할 데이터를 정의 하는 &lt;a href=&quot;qml-qtquick-tableview#model-prop&quot;&gt;모델&lt;/a&gt; 과 데이터 표시 방법을 정의하는 &lt;a href=&quot;qml-qtquick-tableview#delegate-prop&quot;&gt;대리자&lt;/a&gt; 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="70a4c66718ac51a735640d6491fe64ef782c9a69" translate="yes" xml:space="preserve">
          <source>A TableView is similar to &lt;a href=&quot;qml-qtquick-listview&quot;&gt;ListView&lt;/a&gt;, and adds scroll bars, selection, and resizable header sections. As with &lt;a href=&quot;qml-qtquick-listview&quot;&gt;ListView&lt;/a&gt;, data for each row is provided through a &lt;a href=&quot;qml-qtquick-controls-tableview#model-prop&quot;&gt;model&lt;/a&gt;:</source>
          <target state="translated">TableView는 &lt;a href=&quot;qml-qtquick-listview&quot;&gt;ListView&lt;/a&gt; 와 유사하며 스크롤 막대, 선택 및 크기 조정 가능한 헤더 섹션을 추가합니다. &lt;a href=&quot;qml-qtquick-listview&quot;&gt;ListView&lt;/a&gt; 와 마찬가지로 각 행의 데이터는 &lt;a href=&quot;qml-qtquick-controls-tableview#model-prop&quot;&gt;모델을&lt;/a&gt; 통해 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="a9a29d076fe65ecb18ca10a21d47acb865400b6b" translate="yes" xml:space="preserve">
          <source>A Tap gesture.</source>
          <target state="translated">탭 제스처.</target>
        </trans-unit>
        <trans-unit id="602a0e503013a86fc6bf8b6093c7752426c769f7" translate="yes" xml:space="preserve">
          <source>A Tap-And-Hold (Long-Tap) gesture.</source>
          <target state="translated">길게 누르기 (Long-Tap) 제스처.</target>
        </trans-unit>
        <trans-unit id="e6cd8e4630824759f7d3d88345257cee49bfff2d" translate="yes" xml:space="preserve">
          <source>A Technique specifies a set of &lt;a href=&quot;qml-qt3d-render-renderpass&quot;&gt;RenderPass&lt;/a&gt; objects, &lt;a href=&quot;qml-qt3d-render-filterkey&quot;&gt;FilterKey&lt;/a&gt; objects, Parameter objects and a &lt;a href=&quot;qml-qt3d-render-graphicsapifilter&quot;&gt;GraphicsApiFilter&lt;/a&gt;, which together define a rendering technique the given graphics API can render. The filter keys are used by &lt;a href=&quot;qml-qt3d-render-techniquefilter&quot;&gt;TechniqueFilter&lt;/a&gt; to select specific techniques at specific parts of the FrameGraph. If two Parameter instances with the same name are specified in a Technique and a &lt;a href=&quot;qml-qt3d-render-renderpass&quot;&gt;RenderPass&lt;/a&gt;, the one in Technique overrides the one used in the &lt;a href=&quot;qml-qt3d-render-renderpass&quot;&gt;RenderPass&lt;/a&gt;.</source>
          <target state="translated">이 기법은 지정된 그래픽 API가 렌더링 할 수있는 렌더링 기법을 함께 정의하는 &lt;a href=&quot;qml-qt3d-render-renderpass&quot;&gt;RenderPass&lt;/a&gt; 개체, &lt;a href=&quot;qml-qt3d-render-filterkey&quot;&gt;FilterKey&lt;/a&gt; 개체, Parameter 개체 및 &lt;a href=&quot;qml-qt3d-render-graphicsapifilter&quot;&gt;GraphicsApiFilter&lt;/a&gt; 집합을 지정합니다. 필터 키는 &lt;a href=&quot;qml-qt3d-render-techniquefilter&quot;&gt;TechniqueFilter&lt;/a&gt; 에서 FrameGraph의 특정 부분에서 특정 기술 을 선택 하는 데 사용됩니다 . 같은 이름을 가진 두 개의 매개 변수 인스턴스가 기술과에 지정되면 &lt;a href=&quot;qml-qt3d-render-renderpass&quot;&gt;RenderPass&lt;/a&gt; , 기술의 하나가에서 사용되는 우선 &lt;a href=&quot;qml-qt3d-render-renderpass&quot;&gt;RenderPass을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2671ba6dfb28d643647f1eaa9d57fb5a0fdf0bcf" translate="yes" xml:space="preserve">
          <source>A TechniqueFilter specifies which techniques are used by the FrameGraph when rendering the entities. TechniqueFilter specifies a list of &lt;a href=&quot;qml-qt3d-render-filterkey&quot;&gt;FilterKey&lt;/a&gt; objects and Parameter objects. When TechniqueFilter is present in the FrameGraph, only the techiques matching the keys in list are used for rendering. The parameters in the list can be used to set values for shader parameters. The parameters in TechniqueFilter are overridden by parameters in Technique and &lt;a href=&quot;qml-qt3d-render-renderpass&quot;&gt;RenderPass&lt;/a&gt;.</source>
          <target state="translated">TechniqueFilter는 엔터티를 렌더링 할 때 FrameGraph에서 사용하는 기술을 지정합니다. TechniqueFilter는 &lt;a href=&quot;qml-qt3d-render-filterkey&quot;&gt;FilterKey&lt;/a&gt; 개체 및 Parameter 개체 목록을 지정 합니다. TechniqueFilter가 FrameGraph에있는 경우 목록의 키와 일치하는 기술 만 렌더링에 사용됩니다. 목록의 매개 변수를 사용하여 셰이더 매개 변수 값을 설정할 수 있습니다. TechniqueFilter의 매개 변수는 Technique 및 &lt;a href=&quot;qml-qt3d-render-renderpass&quot;&gt;RenderPass의&lt;/a&gt; 매개 변수에 의해 재정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="923f4a34d66d197d7825487cfb42b5fcb65e5892" translate="yes" xml:space="preserve">
          <source>A TextArea that is placed inside a &lt;a href=&quot;qml-qtquick-controls2-scrollview&quot;&gt;ScrollView&lt;/a&gt; does the following:</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-controls2-scrollview&quot;&gt;ScrollView&lt;/a&gt; 내에 배치 된 TextArea 는 다음을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="ca3b7f1aed12d8636ce9cda62a5a56e80aa78b5c" translate="yes" xml:space="preserve">
          <source>A Thermometer.</source>
          <target state="translated">온도계.</target>
        </trans-unit>
        <trans-unit id="ac1adedf939bab3f89db872b91496d81634b484e" translate="yes" xml:space="preserve">
          <source>A Timer can be used to trigger an action either once, or repeatedly at a given interval.</source>
          <target state="translated">타이머는 한 번 또는 주어진 간격으로 반복적으로 작업을 트리거하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="146e3e9ae06d5e0d823da75d63c014b025b7ee6d" translate="yes" xml:space="preserve">
          <source>A Title bar, like those used in &lt;a href=&quot;qmdisubwindow&quot;&gt;QMdiSubWindow&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qmdisubwindow&quot;&gt;QMdiSubWindow&lt;/a&gt; 와 같은 제목 표시 줄 .</target>
        </trans-unit>
        <trans-unit id="a5b5977289da2d2b0efc91e6060da58b7fd45423" translate="yes" xml:space="preserve">
          <source>A TouchEventSequence is created by calling &lt;a href=&quot;qml-qttest-testcase#touchEvent-method&quot;&gt;TestCase.touchEvent()&lt;/a&gt;. The type can not be directly instantiated. Each method provided by the type returns the same object, allowing chained calls.</source>
          <target state="translated">TouchEventSequence는 &lt;a href=&quot;qml-qttest-testcase#touchEvent-method&quot;&gt;TestCase.touchEvent ()&lt;/a&gt; 를 호출하여 생성됩니다 . 유형은 직접 인스턴스화 할 수 없습니다. 형식에서 제공하는 각 메서드는 동일한 개체를 반환하여 연결 호출을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="df66e6f806611101e7317ec476cf059a4c2f1119" translate="yes" xml:space="preserve">
          <source>A Transition defines the animations to be applied when a &lt;a href=&quot;qml-qtquick-state&quot;&gt;State&lt;/a&gt; change occurs.</source>
          <target state="translated">전환은 &lt;a href=&quot;qml-qtquick-state&quot;&gt;상태&lt;/a&gt; 변경이 발생할 때 적용 할 애니메이션을 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="4e9868f7d0fff821b98db215cc7412364adf5e84" translate="yes" xml:space="preserve">
          <source>A TreeView implements a tree representation of items from a model.</source>
          <target state="translated">TreeView는 모델 항목의 트리 표현을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="cbd7a5add22a30636a2a9b9e029d50724d23c541" translate="yes" xml:space="preserve">
          <source>A Trivial Example</source>
          <target state="translated">사소한 예</target>
        </trans-unit>
        <trans-unit id="db327eb4dc7bcf9d7f1b62c5d8e788c663d72427" translate="yes" xml:space="preserve">
          <source>A Twitter search client with 3D effects</source>
          <target state="translated">3D 효과가있는 Twitter 검색 클라이언트</target>
        </trans-unit>
        <trans-unit id="6ec3b640c769b80bf19044be991ee7d9f0a5e1ce" translate="yes" xml:space="preserve">
          <source>A URI handling function was used incorrectly or the URI provided is malformed.</source>
          <target state="translated">URI 처리 기능이 잘못 사용되었거나 제공된 URI가 잘못되었습니다.</target>
        </trans-unit>
        <trans-unit id="cc2dd45d674390b494af9f27530c75932adaefa2" translate="yes" xml:space="preserve">
          <source>A URL can also be constructed piece by piece by calling &lt;a href=&quot;qurl#setScheme&quot;&gt;setScheme&lt;/a&gt;(), &lt;a href=&quot;qurl#setUserName&quot;&gt;setUserName&lt;/a&gt;(), &lt;a href=&quot;qurl#setPassword&quot;&gt;setPassword&lt;/a&gt;(), &lt;a href=&quot;qurl#setHost&quot;&gt;setHost&lt;/a&gt;(), &lt;a href=&quot;qurl#setPort&quot;&gt;setPort&lt;/a&gt;(), &lt;a href=&quot;qurl#setPath&quot;&gt;setPath&lt;/a&gt;(), &lt;a href=&quot;qurl#setQuery&quot;&gt;setQuery&lt;/a&gt;() and &lt;a href=&quot;qurl#setFragment&quot;&gt;setFragment&lt;/a&gt;(). Some convenience functions are also available: &lt;a href=&quot;qurl#setAuthority&quot;&gt;setAuthority&lt;/a&gt;() sets the user name, password, host and port. &lt;a href=&quot;qurl#setUserInfo&quot;&gt;setUserInfo&lt;/a&gt;() sets the user name and password at once.</source>
          <target state="translated">&lt;a href=&quot;qurl#setScheme&quot;&gt;setScheme&lt;/a&gt; (), &lt;a href=&quot;qurl#setUserName&quot;&gt;setUserName&lt;/a&gt; (), &lt;a href=&quot;qurl#setPassword&quot;&gt;setPassword&lt;/a&gt; (), &lt;a href=&quot;qurl#setHost&quot;&gt;setHost&lt;/a&gt; (), &lt;a href=&quot;qurl#setPort&quot;&gt;setPort&lt;/a&gt; (), &lt;a href=&quot;qurl#setPath&quot;&gt;setPath&lt;/a&gt; (), &lt;a href=&quot;qurl#setQuery&quot;&gt;setQuery&lt;/a&gt; () 및 &lt;a href=&quot;qurl#setFragment&quot;&gt;setFragment&lt;/a&gt; () 를 호출하여 URL을 하나씩 구성 할 수도 있습니다 . 일부 편의 기능도 사용할 수 있습니다. &lt;a href=&quot;qurl#setAuthority&quot;&gt;setAuthority&lt;/a&gt; ()는 사용자 이름, 비밀번호, 호스트 및 포트를 설정합니다. &lt;a href=&quot;qurl#setUserInfo&quot;&gt;setUserInfo&lt;/a&gt; ()는 사용자 이름과 비밀번호를 한 번에 설정합니다.</target>
        </trans-unit>
        <trans-unit id="ca046dbb4fd93166413e30194371092366b3a981" translate="yes" xml:space="preserve">
          <source>A URL of this type has no authority component at all. Everything after scheme name and separator character (:) will be preserved as is without validation or canonicalization. All URLs of such a scheme will be considered as having the same origin (unless the &lt;code&gt;NoAccessAllowed&lt;/code&gt; flag is used).</source>
          <target state="translated">이 유형의 URL에는 권한 구성 요소가 전혀 없습니다. 구성표 이름과 구분 기호 문자 (:) 뒤의 모든 내용은 유효성 검사 나 정식화없이 그대로 유지됩니다. 이러한 체계의 모든 URL은 동일한 출처를 갖는 것으로 간주됩니다 ( &lt;code&gt;NoAccessAllowed&lt;/code&gt; 플래그가 사용 되지 않는 한 ).</target>
        </trans-unit>
        <trans-unit id="f48ac6a1d9e4aba3f7fde61ea94fcb9a8ee8a158" translate="yes" xml:space="preserve">
          <source>A UWP application may not do socket-based communication with another application running on the same host (as this would violate the sandboxing).</source>
          <target state="translated">UWP 응용 프로그램은 동일한 호스트에서 실행중인 다른 응용 프로그램과 소켓 기반 통신을 수행 할 수 없습니다 (샌드 박싱을 위반할 수 있음).</target>
        </trans-unit>
        <trans-unit id="30637756af49b89f054072a66299e8ff88b71564" translate="yes" xml:space="preserve">
          <source>A Unique Connection Name is a string in the form &quot;:x.xxx&quot; (where x are decimal digits) that is assigned by the D-Bus server daemon upon connection. It uniquely identifies this client in the bus.</source>
          <target state="translated">고유 연결 이름은 연결시 D-Bus 서버 데몬이 할당 한 &quot;: x.xxx&quot;형식의 문자열입니다 (여기서 x는 십진수). 버스에서이 클라이언트를 고유하게 식별합니다.</target>
        </trans-unit>
        <trans-unit id="c040d39bf56be3d58b0e163f7a0ae82a15bd9046" translate="yes" xml:space="preserve">
          <source>A Vertex Array Object (VAO) is an OpenGL container object that encapsulates the state needed to specify per-vertex attribute data to the OpenGL pipeline. To put it another way, a VAO remembers the states of buffer objects (see &lt;a href=&quot;qopenglbuffer&quot;&gt;QOpenGLBuffer&lt;/a&gt;) and their associated state (e.g. vertex attribute divisors). This allows a very easy and efficient method of switching between OpenGL buffer states for rendering different &quot;objects&quot; in a scene. The &lt;a href=&quot;qopenglvertexarrayobject&quot;&gt;QOpenGLVertexArrayObject&lt;/a&gt; class is a thin wrapper around an OpenGL VAO.</source>
          <target state="translated">VAO (Vertex Array Object)는 OpenGL 파이프 라인에 정점 별 속성 데이터를 지정하는 데 필요한 상태를 캡슐화하는 OpenGL 컨테이너 객체입니다. 다시 말해 VAO는 버퍼 객체의 상태 ( &lt;a href=&quot;qopenglbuffer&quot;&gt;QOpenGLBuffer&lt;/a&gt; 참조 )와 관련 상태 (예 : 정점 속성 제수)를 기억합니다. 이것은 장면에서 다른 &quot;객체&quot;를 렌더링하기 위해 OpenGL 버퍼 상태를 전환하는 매우 쉽고 효율적인 방법을 허용합니다. &lt;a href=&quot;qopenglvertexarrayobject&quot;&gt;QOpenGLVertexArrayObject의&lt;/a&gt; 클래스는 OpenGL을 VAO 주위에 얇은 래퍼입니다.</target>
        </trans-unit>
        <trans-unit id="a7837684ab1b6fcf7455a61c8d54c0b318081c6c" translate="yes" xml:space="preserve">
          <source>A Vertex Array Object (VAO) is an OpenGL container object that encapsulates the state needed to specify per-vertex attribute data to the OpenGL pipeline. To put it another way, a VAO remembers the states of buffer objects (see &lt;a href=&quot;qopenglbuffer&quot;&gt;QOpenGLBuffer&lt;/a&gt;) and their associated state (e.g. vertex attribute divisors). This allows a very easy and efficient method of switching between OpenGL buffer states for rendering different &quot;objects&quot; in a scene. The QOpenGLVertexArrayObject class is a thin wrapper around an OpenGL VAO.</source>
          <target state="translated">VAO (Vertex Array Object)는 OpenGL 파이프 라인에 대한 정점 별 속성 데이터를 지정하는 데 필요한 상태를 캡슐화하는 OpenGL 컨테이너 객체입니다. 다시 말해, VAO는 버퍼 객체의 상태 ( &lt;a href=&quot;qopenglbuffer&quot;&gt;QOpenGLBuffer&lt;/a&gt; 참조 ) 및 관련 상태 (예 : 정점 속성 제수)를 기억합니다. 이것은 장면에서 다른 &quot;객체&quot;를 렌더링하기 위해 OpenGL 버퍼 상태 사이를 전환하는 매우 쉽고 효율적인 방법을 허용합니다. QOpenGLVertexArrayObject 클래스는 OpenGL VAO를 둘러싼 얇은 래퍼입니다.</target>
        </trans-unit>
        <trans-unit id="d8165d61e52b874648941896f7b1db37c58b757b" translate="yes" xml:space="preserve">
          <source>A VertexBlendAnimation type implements vertex-blend morphing animation to a target &lt;a href=&quot;qt3drender-geometry#geometryrenderer&quot;&gt;GeometryRenderer&lt;/a&gt;. The VertexBlendAnimation sets the correct &lt;a href=&quot;qt3drender-geometry#attribute&quot;&gt;Attributes&lt;/a&gt; from the morph targets to the target &lt;a href=&quot;qml-qt3d-render-geometryrenderer#geometry-prop&quot;&gt;GeometryRenderer::geometry&lt;/a&gt; and calculates interpolator for the current position. Unlike with &lt;a href=&quot;qml-qt3d-animation-morphinganimation&quot;&gt;MorphingAnimation&lt;/a&gt;, where the blending is controller with blend weights, the blending occurs between sequential morph targets. The actual blending between the attributes must be implemented in the material. MorphPhongMaterial implements material with morphing support for phong lighting model. The blending happens between 2 attributes - 'base' and 'target'. The names for the base and target attributes are taken from the morph target names, where the base attribute retains the name it already has and the target attribute name gets 'Target' appended to the name. All morph targets in the animation should contain the attributes with same names as those in the base geometry.</source>
          <target state="translated">VertexBlendAnimation 유형은 대상 &lt;a href=&quot;qt3drender-geometry#geometryrenderer&quot;&gt;GeometryRenderer에&lt;/a&gt; 정점 혼합 모핑 애니메이션을 구현 합니다. VertexBlendAnimation 은 모프 타겟 의 올바른 &lt;a href=&quot;qt3drender-geometry#attribute&quot;&gt;속성&lt;/a&gt; 을 타겟 &lt;a href=&quot;qml-qt3d-render-geometryrenderer#geometry-prop&quot;&gt;GeometryRenderer :: geometry로 설정&lt;/a&gt; 하고 현재 위치에 대한 보간 기를 계산합니다. &lt;a href=&quot;qml-qt3d-animation-morphinganimation&quot;&gt;MorphingAnimation&lt;/a&gt; 과 달리, 블렌딩이 블렌드 가중치가있는 컨트롤러 인 경우 블렌딩은 순차적 모프 타겟 사이에서 발생합니다. 속성 간의 실제 혼합은 재료에서 구현되어야합니다. MorphPhongMaterial은 퐁 조명 모델에 대한 모핑 지원을 사용하여 재질을 구현합니다. 블렌딩은 'base'와 'target'의 두 가지 속성 사이에서 발생합니다. 기본 및 대상 속성의 이름은 모프 대상 이름에서 가져옵니다. 여기서 기본 속성은 이미 가지고있는 이름을 유지하고 대상 속성 이름은 이름에 'Target'이 추가됩니다. 애니메이션의 모든 모프 타겟에는 기본 지오메트리에있는 것과 이름이 같은 속성이 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="aff3c3db04120e6c40237079e852939fd7f5cd2b" translate="yes" xml:space="preserve">
          <source>A VerticalHeaderView provides labeling of the rows of a &lt;a href=&quot;qml-qtquick-tableview&quot;&gt;TableView&lt;/a&gt;. To add a vertical header to a &lt;a href=&quot;qml-qtquick-tableview&quot;&gt;TableView&lt;/a&gt;, bind the &lt;a href=&quot;qml-qtquick-controls2-verticalheaderview#syncView-prop&quot;&gt;syncView&lt;/a&gt; property to the &lt;a href=&quot;qml-qtquick-tableview&quot;&gt;TableView&lt;/a&gt;:</source>
          <target state="translated">VerticalHeaderView는 &lt;a href=&quot;qml-qtquick-tableview&quot;&gt;TableView&lt;/a&gt; 행의 레이블링을 제공합니다 . A와 수직 헤더를 추가하려면 &lt;a href=&quot;qml-qtquick-tableview&quot;&gt;의 TableView&lt;/a&gt; , 바인드 &lt;a href=&quot;qml-qtquick-controls2-verticalheaderview#syncView-prop&quot;&gt;syncView의&lt;/a&gt; 받는 재산 &lt;a href=&quot;qml-qtquick-tableview&quot;&gt;의 TableView를&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="47fd46ac8ceec7f7d8ecd953d915a482685ff3ad" translate="yes" xml:space="preserve">
          <source>A Waypoint is a type that allows to specify properties of a waypoint in a &lt;a href=&quot;qml-qtlocation-routequery&quot;&gt;RouteQuery&lt;/a&gt;, such as the waypoint coordinate, or the angle of approach to the waypoint.</source>
          <target state="translated">웨이 포인트는 웨이 포인트 좌표 또는 웨이 포인트에 대한 접근 각도와 같은 &lt;a href=&quot;qml-qtlocation-routequery&quot;&gt;RouteQuery&lt;/a&gt; 의 웨이 포인트 속성을 지정할 수있는 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="ad8be9351e40768d32867df273158b6e8b946ebf" translate="yes" xml:space="preserve">
          <source>A WebEngineAction is returned by the &lt;a href=&quot;qml-qtwebengine-webengineview#action-method&quot;&gt;WebEngineView::action()&lt;/a&gt; method. It provides information about the action, such as whether it is &lt;a href=&quot;qml-qtwebengine-webengineaction#enabled-prop&quot;&gt;enabled&lt;/a&gt;.</source>
          <target state="translated">WebEngineAction은 &lt;a href=&quot;qml-qtwebengine-webengineview#action-method&quot;&gt;WebEngineView :: action ()&lt;/a&gt; 메서드에 의해 반환됩니다 . &lt;a href=&quot;qml-qtwebengine-webengineaction#enabled-prop&quot;&gt;활성화&lt;/a&gt; 여부와 같은 작업에 대한 정보를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="c4607edfbcad0076d33669a5120371f27afbe36b" translate="yes" xml:space="preserve">
          <source>A WebEngineView renders web content within a QML application. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">WebEngineView는 QML 애플리케이션 내에서 웹 콘텐츠를 렌더링합니다. &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f70c6706b3b0ba7345a41f55e6aa5a088677e95d" translate="yes" xml:space="preserve">
          <source>A Window can be declared inside an Item or inside another Window; in that case the inner Window will automatically become &quot;transient for&quot; the outer Window: that is, most platforms will show it centered upon the outer window by default, and there may be other platform-dependent behaviors, depending also on the &lt;a href=&quot;qml-qtquick-window-window#flags-prop&quot;&gt;flags&lt;/a&gt;. If the nested window is intended to be a dialog in your application, you should also set &lt;a href=&quot;qml-qtquick-window-window#flags-prop&quot;&gt;flags&lt;/a&gt; to Qt.Dialog, because some window managers will not provide the centering behavior without that flag. You can also declare multiple windows inside a top-level &lt;a href=&quot;qml-qtqml-qtobject&quot;&gt;QtObject&lt;/a&gt;, in which case the windows will have no transient relationship.</source>
          <target state="translated">Window는 Item 내부 또는 다른 Window 내부에서 선언 될 수 있습니다. 이 경우 내부 윈도우는 외부 윈도우에 대해 자동으로 &quot;일시적으로&quot;됩니다. 즉, 대부분의 플랫폼은 기본적으로 외부 윈도우를 중심으로 표시하며 &lt;a href=&quot;qml-qtquick-window-window#flags-prop&quot;&gt;플래그&lt;/a&gt; 에 따라 다른 플랫폼 종속 동작이있을 수 있습니다 . 중첩 된 창이 응용 프로그램의 대화 상자 인 경우 일부 창 관리자는 해당 플래그없이 센터링 동작을 제공하지 않으므로 &lt;a href=&quot;qml-qtquick-window-window#flags-prop&quot;&gt;플래그&lt;/a&gt; 를 Qt.Dialog로 설정해야합니다 . 최상위 &lt;a href=&quot;qml-qtqml-qtobject&quot;&gt;QtObject&lt;/a&gt; 내부에 여러 개의 창을 선언 할 수도 있습니다 .이 경우 창에는 일시적인 관계가 없습니다.</target>
        </trans-unit>
        <trans-unit id="48aded8ca24d8ffdb2ad7ef06d0d8b38d8b00bba" translate="yes" xml:space="preserve">
          <source>A Window can be declared inside an Item or inside another Window; in that case the inner Window will automatically become &quot;transient for&quot; the outer Window: that is, most platforms will show it centered upon the outer window by default, and there may be other platform-dependent behaviors, depending also on the &lt;a href=&quot;qml-window#flags-prop&quot;&gt;flags&lt;/a&gt;. If the nested window is intended to be a dialog in your application, you should also set &lt;a href=&quot;qml-window#flags-prop&quot;&gt;flags&lt;/a&gt; to Qt.Dialog, because some window managers will not provide the centering behavior without that flag. You can also declare multiple windows inside a top-level &lt;a href=&quot;qml-qtqml-qtobject&quot;&gt;QtObject&lt;/a&gt;, in which case the windows will have no transient relationship.</source>
          <target state="translated">Window는 Item 내부 또는 다른 Window 내부에서 선언 될 수 있습니다. 이 경우 내부 창은 자동으로 외부 창에 대해 &quot;일시적&quot;이됩니다. 즉, 대부분의 플랫폼은 기본적으로 외부 창 중앙에 표시되며 &lt;a href=&quot;qml-window#flags-prop&quot;&gt;플래그&lt;/a&gt; 에 따라 다른 플랫폼 종속 동작이있을 수 있습니다 . 중첩 된 창이 응용 프로그램의 대화 상자로 의도 된 경우 일부 창 관리자는 해당 플래그없이 중앙 정렬 동작을 제공하지 않기 때문에 &lt;a href=&quot;qml-window#flags-prop&quot;&gt;플래그&lt;/a&gt; 를 Qt.Dialog로 설정해야합니다 . 최상위 &lt;a href=&quot;qml-qtqml-qtobject&quot;&gt;QtObject&lt;/a&gt; 내에서 여러 창을 선언 할 수도 있습니다 .이 경우 창에는 일시적인 관계가 없습니다.</target>
        </trans-unit>
        <trans-unit id="53ae62b04edda97b8471d29cc4ac77cee3f3397f" translate="yes" xml:space="preserve">
          <source>A Window with a client area that is completely covered by another window, or is otherwise not visible may be considered obscured by Qt and may in such cases not receive expose events.</source>
          <target state="translated">다른 창으로 완전히 덮여 있거나 보이지 않는 클라이언트 영역이있는 창은 Qt에 의해 가려진 것으로 간주 될 수 있으며 이러한 경우 노출 이벤트를 수신하지 못할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae187e74ab287c25cf5413e5ac698f96220e51c4" translate="yes" xml:space="preserve">
          <source>A Windows-only extension for accessing ActiveX controls and COM objects</source>
          <target state="translated">ActiveX 컨트롤 및 COM 개체에 액세스하기위한 Windows 전용 확장</target>
        </trans-unit>
        <trans-unit id="7dcabac94e3a5e7f190696db7ba62d69513c3b31" translate="yes" xml:space="preserve">
          <source>A Windows-only static library for turning a Qt binary into a COM server</source>
          <target state="translated">Qt 바이너리를 COM 서버로 전환하기위한 Windows 전용 정적 라이브러리</target>
        </trans-unit>
        <trans-unit id="252a334825ee491509d7cc4310352ff83f47c01c" translate="yes" xml:space="preserve">
          <source>A Windows-specific activation event has occurred.</source>
          <target state="translated">Windows 특정 정품 인증 이벤트가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="1935f0ec4dbb78c115f8e393475153791d87faf2" translate="yes" xml:space="preserve">
          <source>A XmlListModel could create a model from this data, like this:</source>
          <target state="translated">XmlListModel은 다음과 같이이 데이터에서 모델을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0bba148cbad0fb8629fa4f9910a0472d1032807b" translate="yes" xml:space="preserve">
          <source>A Y'CbCr color space defined by ITU-R BT.709 with the same values range as YCbCr_BT601. Used for HDTV.</source>
          <target state="translated">ITU-R BT.709에 의해 정의 된 Y'CbCr 색 공간은 YCbCr_BT601과 동일한 값 범위를 갖습니다. HDTV에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="db086ffe60c6b2a9eaad01ee36e60155912c8140" translate="yes" xml:space="preserve">
          <source>A Y'CbCr color space defined by ITU-R recommendation BT.601 with Y value range from 16 to 235, and Cb/Cr range from 16 to 240. Used in standard definition video.</source>
          <target state="translated">ITU-R 권장 사항 BT.601에 의해 정의 된 Y'CbCr 색 공간은 Y 값 범위가 16-235이고 Cb / Cr 범위가 16-240입니다. 표준 화질 비디오에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="75342d9f1139eb43b7d17b3e43e1bbd4806ea909" translate="yes" xml:space="preserve">
          <source>A audio encoder settings object is used to specify the audio encoder settings used by &lt;a href=&quot;qmediarecorder&quot;&gt;QMediaRecorder&lt;/a&gt;. Audio encoder settings are selected by constructing a &lt;a href=&quot;qaudioencodersettings&quot;&gt;QAudioEncoderSettings&lt;/a&gt; object, setting the desired properties and then passing it to a &lt;a href=&quot;qmediarecorder&quot;&gt;QMediaRecorder&lt;/a&gt; instance using the &lt;a href=&quot;qmediarecorder#setEncodingSettings&quot;&gt;QMediaRecorder::setEncodingSettings&lt;/a&gt;() function.</source>
          <target state="translated">오디오 인코더 설정 객체는 &lt;a href=&quot;qmediarecorder&quot;&gt;QMediaRecorder가&lt;/a&gt; 사용하는 오디오 인코더 설정을 지정하는 데 사용됩니다 . 오디오 인코더 설정은 &lt;a href=&quot;qaudioencodersettings&quot;&gt;QAudioEncoderSettings&lt;/a&gt; 객체를 구성하고 원하는 속성을 설정 한 다음 &lt;a href=&quot;qmediarecorder#setEncodingSettings&quot;&gt;QMediaRecorder :: setEncodingSettings&lt;/a&gt; () 함수를 사용하여 &lt;a href=&quot;qmediarecorder&quot;&gt;QMediaRecorder&lt;/a&gt; 인스턴스 로 전달 하여 선택 됩니다.</target>
        </trans-unit>
        <trans-unit id="c5ef79b6f173115d34d052caa7b309bf8c535977" translate="yes" xml:space="preserve">
          <source>A audio encoder settings object is used to specify the audio encoder settings used by &lt;a href=&quot;qmediarecorder&quot;&gt;QMediaRecorder&lt;/a&gt;. Audio encoder settings are selected by constructing a QAudioEncoderSettings object, setting the desired properties and then passing it to a &lt;a href=&quot;qmediarecorder&quot;&gt;QMediaRecorder&lt;/a&gt; instance using the &lt;a href=&quot;qmediarecorder#setEncodingSettings&quot;&gt;QMediaRecorder::setEncodingSettings&lt;/a&gt;() function.</source>
          <target state="translated">오디오 인코더 설정 개체는 &lt;a href=&quot;qmediarecorder&quot;&gt;QMediaRecorder에서&lt;/a&gt; 사용하는 오디오 인코더 설정을 지정하는 데 사용됩니다 . 오디오 인코더 설정은 QAudioEncoderSettings 개체를 구성하고 원하는 속성을 설정 한 다음 &lt;a href=&quot;qmediarecorder#setEncodingSettings&quot;&gt;QMediaRecorder :: setEncodingSettings&lt;/a&gt; () 함수를 사용하여 &lt;a href=&quot;qmediarecorder&quot;&gt;QMediaRecorder&lt;/a&gt; 인스턴스에 전달 하여 선택 됩니다.</target>
        </trans-unit>
        <trans-unit id="e392ebf877b0a8b8cebb6bc7906d502695d258f3" translate="yes" xml:space="preserve">
          <source>A backend providing only area monitoring functionalities via polling on position updates.</source>
          <target state="translated">위치 업데이트에 대한 폴링을 통해 영역 모니터링 기능 만 제공하는 백엔드.</target>
        </trans-unit>
        <trans-unit id="bc679c5ad6651530019bc750409a7522a68543b3" translate="yes" xml:space="preserve">
          <source>A background-image does not scale with the size of the widget. To provide a &quot;skin&quot; or background that scales along with the widget size, one must use &lt;a href=&quot;stylesheet-reference#border-image-prop&quot;&gt;border-image&lt;/a&gt;. Since the border-image property provides an alternate background, it is not required to specify a background-image when border-image is specified. In the case, when both of them are specified, the border-image draws over the background-image.</source>
          <target state="translated">배경 이미지는 위젯의 크기에 맞게 조정되지 않습니다. 위젯 크기와 함께 확장되는 &quot;스킨&quot;또는 배경을 제공하려면 &lt;a href=&quot;stylesheet-reference#border-image-prop&quot;&gt;border-image를&lt;/a&gt; 사용해야합니다 . border-image 속성은 대체 배경을 제공하므로 border-image가 지정된 경우 배경 이미지를 지정할 필요가 없습니다. 두 가지를 모두 지정하면 테두리 이미지가 배경 이미지 위에 그려집니다.</target>
        </trans-unit>
        <trans-unit id="1b6d19ecdb6261ff99bea43f8cf5e3e4f0afce70" translate="yes" xml:space="preserve">
          <source>A backtrace with the number of frames specified by the optional &lt;code&gt;depth&lt;/code&gt; parameter (defaults to 5), and separated by the optional &lt;code&gt;separator&lt;/code&gt; parameter (defaults to &quot;|&quot;). This expansion is available only on some platforms (currently only platfoms using glibc). Names are only known for exported functions. If you want to see the name of every function in your application, use &lt;code&gt;QMAKE_LFLAGS += -rdynamic&lt;/code&gt;. When reading backtraces, take into account that frames might be missing due to inlining or tail call optimization.</source>
          <target state="translated">선택적 &lt;code&gt;depth&lt;/code&gt; 매개 변수 (기본값은 5)에 의해 지정되고 선택적 &lt;code&gt;separator&lt;/code&gt; 매개 변수 (기본값은 &quot;|&quot;)로 구분 된 프레임 수를 가진 역 추적 . 이 확장은 일부 플랫폼에서만 사용할 수 있습니다 (현재는 glibc를 사용하는 플랫폼 만). 이름은 내 보낸 함수로만 알려져 있습니다. 애플리케이션에서 모든 함수의 이름을 보려면 &lt;code&gt;QMAKE_LFLAGS += -rdynamic&lt;/code&gt; . 역 추적을 읽을 때 인라인 또는 테일 콜 최적화로 인해 프레임이 누락 될 수 있음을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="eed99aa7ce083c8958402410f1e7c8e403460ed6" translate="yes" xml:space="preserve">
          <source>A ball component might have a behavior animation assigned to its &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;color&lt;/code&gt; properties. The behavior animation could be set up to simulate an elastic effect. In effect, this behavior animation would apply the elastic effect to the properties whenever the ball moves.</source>
          <target state="translated">볼 구성 요소에는 &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; 및 &lt;code&gt;color&lt;/code&gt; 속성에 동작 애니메이션이 할당되어있을 수 있습니다 . 탄성 효과를 시뮬레이션하도록 동작 애니메이션을 설정할 수 있습니다. 실제로이 동작 애니메이션은 공이 움직일 때마다 속성에 탄성 효과를 적용합니다.</target>
        </trans-unit>
        <trans-unit id="1bb6d27425744e5fa8ebe85b81ce2e5ef27353c3" translate="yes" xml:space="preserve">
          <source>A banner component may have several icons or slogans to display, one after the other. The &lt;code&gt;opacity&lt;/code&gt; property could transform to &lt;code&gt;1.0&lt;/code&gt; denoting an opaque object. Using the &lt;a href=&quot;qml-qtquick-sequentialanimation&quot;&gt;SequentialAnimation&lt;/a&gt; type, the opacity animations will play after the preceding animation finishes. The &lt;a href=&quot;qml-qtquick-parallelanimation&quot;&gt;ParallelAnimation&lt;/a&gt; type will play the animations at the same time.</source>
          <target state="translated">배너 구성 요소에는 표시 할 여러 아이콘 또는 슬로건이 하나씩있을 수 있습니다. &lt;code&gt;opacity&lt;/code&gt; 속성으로 변환 할 수 &lt;code&gt;1.0&lt;/code&gt; 불투명 한 개체를 나타내는. &lt;a href=&quot;qml-qtquick-sequentialanimation&quot;&gt;SequentialAnimation&lt;/a&gt; 유형을 사용하면 불투명 애니메이션이 이전 애니메이션이 끝난 후에 재생됩니다. &lt;a href=&quot;qml-qtquick-parallelanimation&quot;&gt;ParallelAnimation의&lt;/a&gt; 유형은 같은 시간에 애니메이션을 재생합니다.</target>
        </trans-unit>
        <trans-unit id="6d23654db4b54872002a5cc144770e24680b8e47" translate="yes" xml:space="preserve">
          <source>A bar data item holds the data for a single rendered bar in a graph. Bar data proxies parse data into &lt;a href=&quot;qbardataitem&quot;&gt;QBarDataItem&lt;/a&gt; instances for visualization.</source>
          <target state="translated">막대 데이터 항목은 그래프에서 렌더링 된 단일 막대의 데이터를 보유합니다. 막대 데이터 프록시 는 시각화를 위해 데이터를 &lt;a href=&quot;qbardataitem&quot;&gt;QBarDataItem&lt;/a&gt; 인스턴스 로 구문 분석합니다 .</target>
        </trans-unit>
        <trans-unit id="cce81a73854596e6749459fc713abf30c4ef3635" translate="yes" xml:space="preserve">
          <source>A bar data item holds the data for a single rendered bar in a graph. Bar data proxies parse data into QBarDataItem instances for visualization.</source>
          <target state="translated">막대 데이터 항목은 그래프에서 렌더링 된 단일 막대에 대한 데이터를 보유합니다. 막대 데이터 프록시는 시각화를 위해 데이터를 QBarDataItem 인스턴스로 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="93a8b38c721b81c297b8adfbbcf74632e64dbc23" translate="yes" xml:space="preserve">
          <source>A bar data proxy handles adding, inserting, changing, and removing rows of data.</source>
          <target state="translated">막대 데이터 프록시는 데이터 행 추가, 삽입, 변경 및 제거를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="be79e228b398d83560fb7b5e2f87a11af0ef501a" translate="yes" xml:space="preserve">
          <source>A bar legend marker is related to &lt;a href=&quot;qabstractbarseries&quot;&gt;QAbstractBarSeries&lt;/a&gt; derived classes. With a bar series, each marker is related to one &lt;a href=&quot;qbarset&quot;&gt;QBarSet&lt;/a&gt;.</source>
          <target state="translated">막대 범례 마커는 &lt;a href=&quot;qabstractbarseries&quot;&gt;QAbstractBarSeries&lt;/a&gt; 파생 클래스 와 관련이 있습니다. 막대 시리즈를 사용하면 각 마커가 하나의 &lt;a href=&quot;qbarset&quot;&gt;QBarSet&lt;/a&gt; 과 관련됩니다 .</target>
        </trans-unit>
        <trans-unit id="f7749737118e19b6e396ecd3ac66841e99379c7e" translate="yes" xml:space="preserve">
          <source>A bar series.</source>
          <target state="translated">바 시리즈.</target>
        </trans-unit>
        <trans-unit id="382df92f881d019f8148e191887092bb721435ca" translate="yes" xml:space="preserve">
          <source>A bar set contains one data value for each category. The first value of a set is assumed to belong to the first category, the second one to the second category, and so on. If the set has fewer values than there are categories, the missing values are assumed to be located at the end of the set. For missing values in the middle of a set, the numerical value of zero is used. Labels for zero value sets are not shown.</source>
          <target state="translated">막대 집합에는 각 범주에 대한 하나의 데이터 값이 포함됩니다. 집합의 첫 번째 값은 첫 번째 범주에 속하고 두 번째 범주는 두 번째 범주에 속한다고 가정합니다. 집합에 범주보다 적은 값이있는 경우 누락 된 값은 집합의 끝 부분에 있다고 가정합니다. 세트 중간에 누락 된 값의 경우 숫자 값 0이 사용됩니다. 값이 0 인 레이블은 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="04d8546684c88f7763be453dd5b0e24c91a29da2" translate="yes" xml:space="preserve">
          <source>A base QML type that other types inherit. It cannot be directly created. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">다른 유형이 상속하는 기본 QML 유형. 직접 만들 수 없습니다. &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7199d06eede04e924c5217487aacab3e0c37fb85" translate="yes" xml:space="preserve">
          <source>A base class for changes in the &lt;a href=&quot;qml-qt3d-render-framegraphnode&quot;&gt;FrameGraphNode&lt;/a&gt;. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;qml-qt3d-render-framegraphnode&quot;&gt;FrameGraphNode&lt;/a&gt; 변경에 대한 기본 클래스입니다 . &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b03c6b8becc8a65dd9fdbde6fc1d5ff42daa970a" translate="yes" xml:space="preserve">
          <source>A base class for changes in the &lt;a href=&quot;qml-qt3d-render-framegraphnode&quot;&gt;FrameGraphNode&lt;/a&gt;. &lt;a href=&quot;qt3drender-qframegraphnodecreatedchangebase#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;qml-qt3d-render-framegraphnode&quot;&gt;FrameGraphNode&lt;/a&gt; 변경에 대한 기본 클래스입니다 . &lt;a href=&quot;qt3drender-qframegraphnodecreatedchangebase#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="892444e50ba524498a230a852672f03c83ff39f9" translate="yes" xml:space="preserve">
          <source>A base class for changes in the FrameGraphNode</source>
          <target state="translated">FrameGraphNode의 변경을위한 기본 클래스</target>
        </trans-unit>
        <trans-unit id="efbcc6f43d42370f7eeac347f3dc4e8ba106ab2a" translate="yes" xml:space="preserve">
          <source>A base class for handling keyframes</source>
          <target state="translated">키 프레임 처리를위한 기본 클래스</target>
        </trans-unit>
        <trans-unit id="01895fee30cd8d98677086f3b6ce1069390e4a83" translate="yes" xml:space="preserve">
          <source>A base class for handling keyframes. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">키 프레임 처리를위한 기본 클래스입니다. &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0b1f52d087ec59be2a14f9bffbf72dfa1453a1d2" translate="yes" xml:space="preserve">
          <source>A base class for handling keyframes. &lt;a href=&quot;qt3danimation-qkeyframe#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">키 프레임 처리를위한 기본 클래스입니다. &lt;a href=&quot;qt3danimation-qkeyframe#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1f2528b4b9ed2e5be67279391c94af1b62f32535" translate="yes" xml:space="preserve">
          <source>A base class for pointer events containing a single point, such as mouse events. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">마우스 이벤트와 같이 단일 지점을 포함하는 포인터 이벤트에 대한 기본 클래스입니다. &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8a6686b71927bf9ef5bcab2f1144fb44477e552a" translate="yes" xml:space="preserve">
          <source>A base class for pointer events. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">포인터 이벤트의 기본 클래스입니다. &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ab3b598b5ad73e835ecacce813d8f8e8aad6efa1" translate="yes" xml:space="preserve">
          <source>A base class that allows obtaining a &lt;a href=&quot;qsharedpointer&quot;&gt;QSharedPointer&lt;/a&gt; for an object already managed by a shared pointer. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">공유 포인터로 이미 관리되는 객체에 대한 &lt;a href=&quot;qsharedpointer&quot;&gt;QSharedPointer&lt;/a&gt; 를 얻을 수있는 기본 클래스입니다 . &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a80ca27c319e98db226fe4a04e5ca1eedf28f48b" translate="yes" xml:space="preserve">
          <source>A base class to be used to provide textures</source>
          <target state="translated">텍스처를 제공하는 데 사용되는 기본 클래스</target>
        </trans-unit>
        <trans-unit id="023bfcdcb93e07c8f4f56aa6e67df0652756aa3a" translate="yes" xml:space="preserve">
          <source>A base class to be used to provide textures. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">텍스처를 제공하는 데 사용되는 기본 클래스입니다. &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="abfd78e0be8c4e9464818bc1e602e0a4406f3b94" translate="yes" xml:space="preserve">
          <source>A base class to be used to provide textures. &lt;a href=&quot;qt3drender-qabstracttexture#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">텍스처를 제공하는 데 사용되는 기본 클래스입니다. &lt;a href=&quot;qt3drender-qabstracttexture#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5cd921da4bce1b6568b1505010f82f576d38e813" translate="yes" xml:space="preserve">
          <source>A base type for all data series. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">모든 데이터 계열의 기본 유형입니다. &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f2ac0810528c74a2cd8ead55308134b7e1a3a1a1" translate="yes" xml:space="preserve">
          <source>A base type for all the objects in a 3D scene. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">3D 장면의 모든 객체에 대한 기본 유형입니다. &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1a0f80c3888bb9841e130f3b7fa2b601a6778ad6" translate="yes" xml:space="preserve">
          <source>A base type for line, spline, and scatter series. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">선, 스플라인 및 산란 시리즈의 기본 유형입니다. &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="896121b50569bf39634722a9287aa1beaebfb12a" translate="yes" xml:space="preserve">
          <source>A base type for selection list item delegates. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">선택 목록 항목 위임의 기본 유형입니다. &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f68e4dcb084a3bf6e757ee314a5c27111449476a" translate="yes" xml:space="preserve">
          <source>A base type for the axes of a graph. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">그래프 축의 기본 유형입니다. &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="10f426520d8c02aeeb47526de87482cd977be7db" translate="yes" xml:space="preserve">
          <source>A base type for value axis formatters. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">값 축 포맷터의 기본 유형입니다. &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9a8afccb631fafc2911267f5331704d857c68652" translate="yes" xml:space="preserve">
          <source>A base type of the styled keys. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">스타일이 지정된 키의 기본 유형입니다. &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4391581a7a9bc99a26782600d337cf5df7aee185" translate="yes" xml:space="preserve">
          <source>A base type of the trace input key. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">추적 입력 키의 기본 유형입니다. &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9d30e06bb873b7403dbdd35a39c8fa583e3c26a8" translate="yes" xml:space="preserve">
          <source>A base type used for specialized axis types. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">특수 축 유형에 사용되는 기본 유형입니다. &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e41b504c72e82e5687ad73eec1de3e145285cac6" translate="yes" xml:space="preserve">
          <source>A basic QML type. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">기본 QML 유형입니다. &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="baeb371846d161ed9d70db662796d96d464f9013" translate="yes" xml:space="preserve">
          <source>A basic element, which is understood by &lt;a href=&quot;qtcore-changes-qt6#qvariant&quot;&gt;QVariant&lt;/a&gt;. The following types are considered basic: bool, byte, short, ushort, int, uint, qint64, quint64, double, &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;, &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt;, &lt;a href=&quot;qdbusobjectpath&quot;&gt;QDBusObjectPath&lt;/a&gt;, &lt;a href=&quot;qdbussignature&quot;&gt;QDBusSignature&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;qtcore-changes-qt6#qvariant&quot;&gt;QVariant에서&lt;/a&gt; 이해하는 기본 요소 입니다. 다음 유형은 기본으로 간주됩니다 : bool, byte, short, ushort, int, uint, qint64, quint64, double, &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; , &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; , &lt;a href=&quot;qdbusobjectpath&quot;&gt;QDBusObjectPath&lt;/a&gt; , &lt;a href=&quot;qdbussignature&quot;&gt;QDBusSignature&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="120600024f41f3514d450624cf42ebd58fcf4148" translate="yes" xml:space="preserve">
          <source>A basic element, which is understood by &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt;. The following types are considered basic: bool, byte, short, ushort, int, uint, qint64, quint64, double, &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;, &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt;, &lt;a href=&quot;qdbusobjectpath&quot;&gt;QDBusObjectPath&lt;/a&gt;, &lt;a href=&quot;qdbussignature&quot;&gt;QDBusSignature&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; 가 이해하는 기본 요소 입니다. bool, byte, short, ushort, int, uint, qint64, quint64, double, &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; , &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; , &lt;a href=&quot;qdbusobjectpath&quot;&gt;QDBusObjectPath&lt;/a&gt; , &lt;a href=&quot;qdbussignature&quot;&gt;QDBusSignature&lt;/a&gt; 유형은 기본으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="b0aef4eec6125a99af23ed8e026f5a7a96e3e9f0" translate="yes" xml:space="preserve">
          <source>A basic example of a QML file that makes use of controls is shown here:</source>
          <target state="translated">컨트롤을 사용하는 QML 파일의 기본 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a29d9cc83590e0b380a7cc59755c4b6c85096d06" translate="yes" xml:space="preserve">
          <source>A basic example of a source file that makes use of controls is shown here:</source>
          <target state="translated">컨트롤을 사용하는 소스 파일의 기본 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2bdaca4ecfb8d87c935a5ddd1d91f3674ae9c174" translate="yes" xml:space="preserve">
          <source>A basic mouse click-wheel works in steps of 15 degrees.</source>
          <target state="translated">기본 마우스 클릭 휠은 15도 단위로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="1f02a79201a24baf7e657be9e6aaab9778c60f6e" translate="yes" xml:space="preserve">
          <source>A basic store for persisted properties. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">지속 속성의 기본 저장소입니다. &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1c9eba467d31b6ba5d27835e049e8069a5666d59" translate="yes" xml:space="preserve">
          <source>A basic visual QML type. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">기본 비주얼 QML 유형입니다. &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6a43d0a4bf8a05a50c15d14e89c515225351b914" translate="yes" xml:space="preserve">
          <source>A better approach than just alerting the user to an event is to also ask the user what to do about it. Store the question in the &lt;a href=&quot;qmessagebox#informativeText-prop&quot;&gt;informative text&lt;/a&gt; property, and set the &lt;a href=&quot;qmessagebox#standardButtons-prop&quot;&gt;standard buttons&lt;/a&gt; property to the set of buttons you want as the set of user responses. The buttons are specified by combining values from &lt;a href=&quot;qmessagebox#StandardButton-enum&quot;&gt;StandardButtons&lt;/a&gt; using the bitwise OR operator. The display order for the buttons is platform-dependent. For example, on Windows, &lt;b&gt;Save&lt;/b&gt; is displayed to the left of &lt;b&gt;Cancel&lt;/b&gt;, whereas on Mac OS, the order is reversed.</source>
          <target state="translated">사용자에게 이벤트를 알리는 것보다 더 나은 방법은 사용자에게 이벤트에 대한 조치를 요청하는 것입니다. &lt;a href=&quot;qmessagebox#informativeText-prop&quot;&gt;정보 텍스트&lt;/a&gt; 특성에 질문을 저장하고 &lt;a href=&quot;qmessagebox#standardButtons-prop&quot;&gt;표준 단추&lt;/a&gt; 특성을 사용자 응답 세트로 원하는 단추 세트로 설정하십시오. 비트 OR 연산자를 사용하여 &lt;a href=&quot;qmessagebox#StandardButton-enum&quot;&gt;StandardButton의&lt;/a&gt; 값을 결합하여 버튼을 지정합니다 . 버튼의 표시 순서는 플랫폼에 따라 다릅니다. 예를 들어, Windows에서는 &lt;b&gt;저장&lt;/b&gt; 이 &lt;b&gt;취소&lt;/b&gt; 왼쪽에 표시되는 반면 Mac OS에서는 순서가 반대로됩니다.</target>
        </trans-unit>
        <trans-unit id="91517aba76347c98123d5729458ac183f70f1b9e" translate="yes" xml:space="preserve">
          <source>A binary large object</source>
          <target state="translated">이진 큰 개체</target>
        </trans-unit>
        <trans-unit id="2d32849d41343bbdcfa2c1f991316aad1d2ff094" translate="yes" xml:space="preserve">
          <source>A binding can contain any valid JavaScript expression or statement, as QML uses a standards compliant JavaScript engine. Bindings can access object properties, call methods and use built-in JavaScript objects such as &lt;code&gt;Date&lt;/code&gt; and &lt;code&gt;Math&lt;/code&gt;. Below are other possible bindings for the previous example:</source>
          <target state="translated">QML은 표준 호환 JavaScript 엔진을 사용하므로 바인딩에는 유효한 JavaScript 표현식 또는 명령문이 포함될 수 있습니다. 바인딩은 객체 속성에 액세스하고 메서드를 호출하며 &lt;code&gt;Date&lt;/code&gt; 및 &lt;code&gt;Math&lt;/code&gt; 와 같은 내장 JavaScript 객체를 사용할 수 있습니다 . 다음은 이전 예제에 가능한 다른 바인딩입니다.</target>
        </trans-unit>
        <trans-unit id="89f7c0cf31f1cb06cd4adfa08cc2474bce7d3510" translate="yes" xml:space="preserve">
          <source>A binding is a JavaScript expression which is &quot;bound&quot; to a property. The value of the property at any point in time will be the value returned by evaluating that expression.</source>
          <target state="translated">바인딩은 속성에 &quot;바운드 된&quot;JavaScript 식입니다. 특정 시점의 속성 값은 해당 식을 평가하여 반환 된 값입니다.</target>
        </trans-unit>
        <trans-unit id="b566c3ecc82e65ceb2e902337de8a948d5c1e973" translate="yes" xml:space="preserve">
          <source>A binding to the &lt;a href=&quot;qml-qtquick-hoverhandler#hovered-prop&quot;&gt;hovered&lt;/a&gt; property is the easiest way to react when the cursor enters or leaves the &lt;a href=&quot;qml-qtquick-hoverhandler#parent-prop&quot;&gt;parent&lt;/a&gt; Item. The &lt;a href=&quot;qml-qtquick-hoverhandler#point-prop&quot;&gt;point&lt;/a&gt; property provides more detail, including the cursor position. The &lt;a href=&quot;qml-qtquick-hoverhandler#acceptedDevices-prop&quot;&gt;acceptedDevices&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-hoverhandler#acceptedPointerTypes-prop&quot;&gt;acceptedPointerTypes&lt;/a&gt;, and &lt;a href=&quot;qml-qtquick-hoverhandler#acceptedModifiers-prop&quot;&gt;acceptedModifiers&lt;/a&gt; properties can be used to narrow the behavior to detect hovering of specific kinds of devices or while holding a modifier key.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-hoverhandler#hovered-prop&quot;&gt;호버 된&lt;/a&gt; 속성에 대한 바인딩 은 커서가 &lt;a href=&quot;qml-qtquick-hoverhandler#parent-prop&quot;&gt;부모&lt;/a&gt; 항목에 들어가거나 떠날 때 반응하는 가장 쉬운 방법 입니다. &lt;a href=&quot;qml-qtquick-hoverhandler#point-prop&quot;&gt;포인트&lt;/a&gt; 속성은 커서 위치를 포함하여 자세한 내용을 제공합니다. &lt;a href=&quot;qml-qtquick-hoverhandler#acceptedDevices-prop&quot;&gt;acceptedDevices&lt;/a&gt; , &lt;a href=&quot;qml-qtquick-hoverhandler#acceptedPointerTypes-prop&quot;&gt;acceptedPointerTypes&lt;/a&gt; 및 &lt;a href=&quot;qml-qtquick-hoverhandler#acceptedModifiers-prop&quot;&gt;acceptedModifiers의&lt;/a&gt; 속성은 변경 키를 누른 상태에서 장치의 특정 종류의 떠오르게하거나 검출하는 동작을 좁게 할 수있다.</target>
        </trans-unit>
        <trans-unit id="e9e0bd48d55e2e5d47def7b8986a6c5f60df53c5" translate="yes" xml:space="preserve">
          <source>A bit faster equivalent of (&lt;a href=&quot;qchar#mirroredChar&quot;&gt;QChar::mirroredChar&lt;/a&gt;(ucs4) != ucs4).</source>
          <target state="translated">( &lt;a href=&quot;qchar#mirroredChar&quot;&gt;QChar :: mirroredChar&lt;/a&gt; (ucs4)! = ucs4) 와 약간 더 빠릅니다 .</target>
        </trans-unit>
        <trans-unit id="da57b3ba6eb85fbb86a69d47612377e5fe23b1c2" translate="yes" xml:space="preserve">
          <source>A bit faster equivalent of (ch.&lt;a href=&quot;qchar#mirroredChar&quot;&gt;mirroredChar&lt;/a&gt;() != ch).</source>
          <target state="translated">(ch. &lt;a href=&quot;qchar#mirroredChar&quot;&gt;mirroredChar&lt;/a&gt; ()! = ch)에 비해 약간 빠릅니다 .</target>
        </trans-unit>
        <trans-unit id="ff40644a3a6f8f19950b64b62f1ab30376057331" translate="yes" xml:space="preserve">
          <source>A blackboard filter.</source>
          <target state="translated">칠판 필터.</target>
        </trans-unit>
        <trans-unit id="a13f76f9ba4c90900c2921ae4fdeb0a6ed4b421c" translate="yes" xml:space="preserve">
          <source>A blank/invisible cursor, typically used when the cursor shape needs to be hidden.</source>
          <target state="translated">공백 / 보이지 않는 커서로, 일반적으로 커서 모양을 숨겨야 할 때 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="84edaa213659c871672f5e17ed395a7bdfae9c72" translate="yes" xml:space="preserve">
          <source>A blend tree can be constructed from the following node types:</source>
          <target state="translated">블렌드 트리는 다음 노드 유형으로 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bdf1fd94e813e55724df58e4b2a4df2f2c3faac4" translate="yes" xml:space="preserve">
          <source>A block consists of a sequence of text fragments. This class provides a way to iterate over these, and read their contents. It does not provide a way to modify the internal structure or contents of the block.</source>
          <target state="translated">블록은 일련의 텍스트 조각으로 구성됩니다. 이 클래스는 이들을 반복하고 내용을 읽는 방법을 제공합니다. 블록의 내부 구조 나 내용을 수정하는 방법은 제공하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3e9bb1670eee10af9defc5d7a6745b40c579ea4d" translate="yes" xml:space="preserve">
          <source>A blood oxygen saturation meter.</source>
          <target state="translated">혈액 산소 포화도 측정기.</target>
        </trans-unit>
        <trans-unit id="06bc3559a3e0483df08faf4720a4eff5798663a5" translate="yes" xml:space="preserve">
          <source>A blood pressure monitor.</source>
          <target state="translated">혈압 모니터.</target>
        </trans-unit>
        <trans-unit id="21f54068d0fa34c3f4319c409e0bbb30e62d2146" translate="yes" xml:space="preserve">
          <source>A bloom with tonemapping effect. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">톤 매핑 효과가있는 꽃. &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a30e72e8e26acb11fbf55198a04066964b51aa10" translate="yes" xml:space="preserve">
          <source>A blur effect blurs the source. This effect is useful for reducing details, such as when the source loses focus and you want to draw attention to other elements. The level of detail can be modified using the &lt;a href=&quot;qgraphicsblureffect#blurRadius-prop&quot;&gt;setBlurRadius&lt;/a&gt;() function. Use &lt;a href=&quot;qgraphicsblureffect#blurHints-prop&quot;&gt;setBlurHints&lt;/a&gt;() to choose the blur hints.</source>
          <target state="translated">흐림 효과는 소스를 흐리게합니다. 이 효과는 소스가 초점을 잃고 다른 요소에주의를 기울이려는 경우와 같이 세부 사항을 줄이는 데 유용합니다. &lt;a href=&quot;qgraphicsblureffect#blurRadius-prop&quot;&gt;setBlurRadius&lt;/a&gt; () 함수를 사용하여 세부 수준을 수정할 수 있습니다 . &lt;a href=&quot;qgraphicsblureffect#blurHints-prop&quot;&gt;setBlurHints&lt;/a&gt; ()를 사용 하여 흐림 힌트를 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="d1385afbbfc3e3f8639fc35491b66f4c8572ce9b" translate="yes" xml:space="preserve">
          <source>A boolean describing if the printer should be full page or not.</source>
          <target state="translated">프린터가 전체 페이지인지 여부를 설명하는 부울입니다.</target>
        </trans-unit>
        <trans-unit id="66d7435ffef2fc6e08846f5da5d98348bb624f5d" translate="yes" xml:space="preserve">
          <source>A boolean indicating if the text in a message box should allow user interfactions (e.g. selection) or not.</source>
          <target state="translated">메시지 상자의 텍스트가 사용자 개입 (예 : 선택)을 허용해야하는지 여부를 나타내는 부울입니다.</target>
        </trans-unit>
        <trans-unit id="43d99742cc5dcb459537b466d039c2720b87d61c" translate="yes" xml:space="preserve">
          <source>A boolean indicating what the to use the border of the buttons (computed as half the button height) for the spacing of the button in a message box.</source>
          <target state="translated">메시지 상자에서 버튼의 간격에 대해 버튼의 테두리 (버튼 높이의 반으로 계산)를 사용할 것을 나타내는 부울입니다.</target>
        </trans-unit>
        <trans-unit id="4165ab995f72831ac0a8d55f2930d4a2331f8d0a" translate="yes" xml:space="preserve">
          <source>A boolean indicating whether controls on a title bar ought to update when the mouse is over them.</source>
          <target state="translated">제목 표시 줄의 컨트롤이 마우스 위에있을 때 업데이트해야하는지 여부를 나타내는 부울입니다.</target>
        </trans-unit>
        <trans-unit id="8f92fd18dc3667952397a215400feeae5a1b58d9" translate="yes" xml:space="preserve">
          <source>A boolean indicating whether gamma correction is enabled.</source>
          <target state="translated">감마 보정이 활성화되어 있는지 여부를 나타내는 부울입니다.</target>
        </trans-unit>
        <trans-unit id="776cd9ba8a01949fd2dc7b6088a72b988b07c9c1" translate="yes" xml:space="preserve">
          <source>A boolean indicating whether the buttons in the message box should be centered or not (see QDialogButtonBox::setCentered()).</source>
          <target state="translated">메시지 상자의 단추가 가운데에 있어야하는지 여부를 나타내는 부울입니다 (QDialogButtonBox :: setCentered () 참조).</target>
        </trans-unit>
        <trans-unit id="44592394554ed238e11e2b47fe0167ea66f60bd8" translate="yes" xml:space="preserve">
          <source>A boolean that describes whether the module was found successfully.</source>
          <target state="translated">모듈이 성공적으로 발견되었는지 여부를 설명하는 부울입니다.</target>
        </trans-unit>
        <trans-unit id="7ea63403f8dc69ec0ab46dfada81f804e2840bab" translate="yes" xml:space="preserve">
          <source>A boolean that indicates whether the certificate error can be overridden and ignored.</source>
          <target state="translated">인증서 오류를 무시하고 무시할 수 있는지 여부를 나타내는 부울입니다.</target>
        </trans-unit>
        <trans-unit id="a9bc9f71e9520f3f1fc22c0e9ba2c6b7d2f59d80" translate="yes" xml:space="preserve">
          <source>A boolean value indicating if the word candidate can be removed from the dictionary.</source>
          <target state="translated">단어 후보를 사전에서 제거 할 수 있는지 여부를 나타내는 부울 값입니다.</target>
        </trans-unit>
        <trans-unit id="b4e570ef43d0a83479e1ab449e289e5ff02e503a" translate="yes" xml:space="preserve">
          <source>A boolean value indicating whether both sides of the printer paper should be used for the printout.</source>
          <target state="translated">인쇄물에 프린터 용지의 양면을 사용해야하는지 여부를 나타내는 부울 값입니다.</target>
        </trans-unit>
        <trans-unit id="fa5edd29164f6dd63baee6a5e0dd115980ccd498" translate="yes" xml:space="preserve">
          <source>A boolean value indicating whether data for the document's fonts should be embedded in the data sent to the printer.</source>
          <target state="translated">문서의 글꼴 데이터가 프린터로 전송 된 데이터에 포함되어야하는지 여부를 나타내는 부울 값입니다.</target>
        </trans-unit>
        <trans-unit id="0e06b4c402da4a3545019cfc5bafaceb95b5f996" translate="yes" xml:space="preserve">
          <source>A boolean value indicating whether or not the printer supports printing multiple copies in one job.</source>
          <target state="translated">프린터가 한 작업에서 여러 사본 인쇄를 지원하는지 여부를 나타내는 부울 값입니다.</target>
        </trans-unit>
        <trans-unit id="65eeb39b575446199454fcdb70136d30b317a432" translate="yes" xml:space="preserve">
          <source>A boolean value indicating whether the printout should be collated or not.</source>
          <target state="translated">출력물을 한 부씩 인쇄 할지를 나타내는 부울 값입니다.</target>
        </trans-unit>
        <trans-unit id="9b24a5abb0b9f0a30bdfe7f743c73ac10cb975a7" translate="yes" xml:space="preserve">
          <source>A boolean value which, when &lt;code&gt;true&lt;/code&gt;, enables single-directory output mode; all generated files go to &lt;a href=&quot;#format-outputsubdir&quot;&gt;FORMAT.outputsubdir&lt;/a&gt; directory, instead of a subdirectory based on the documentation project name.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 인 경우 단일 디렉토리 출력 모드를 사용 하는 부울 값입니다 . 생성 된 모든 파일 은 문서 프로젝트 이름을 기반으로하는 서브 디렉토리 대신 &lt;a href=&quot;#format-outputsubdir&quot;&gt;FORMAT.outputsubdir&lt;/a&gt; 디렉토리 로 이동합니다 .</target>
        </trans-unit>
        <trans-unit id="fd49aa3425243c41756fd07d48dcb7a9809e4096" translate="yes" xml:space="preserve">
          <source>A boolean value which, when &lt;code&gt;true&lt;/code&gt;, enables single-directory output mode; all generated files go to &lt;a href=&quot;24-qdoc-configuration-htmlvariables#format-outputsubdir&quot;&gt;FORMAT.outputsubdir&lt;/a&gt; directory, instead of a subdirectory based on the documentation project name.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 이면 단일 디렉토리 출력 모드를 활성화 하는 부울 값 . 생성 된 모든 파일 은 문서 프로젝트 이름을 기반으로하는 하위 디렉토리 대신 &lt;a href=&quot;24-qdoc-configuration-htmlvariables#format-outputsubdir&quot;&gt;FORMAT.outputsubdir&lt;/a&gt; 디렉토리 로 이동합니다 .</target>
        </trans-unit>
        <trans-unit id="48c8a566f062f7da064996667fb5f4cfa5b9bb8c" translate="yes" xml:space="preserve">
          <source>A boolean value which, when &lt;code&gt;true&lt;/code&gt;, generates references to quoted content (for example, &lt;a href=&quot;07-0-qdoc-commands-includingexternalcode#quotefromfile-command&quot;&gt;\quotefromfile&lt;/a&gt; and &lt;a href=&quot;07-0-qdoc-commands-includingexternalcode#snippet-command&quot;&gt;\snippet&lt;/a&gt; commands) instead of including the content directly.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 인 경우 컨텐츠를 직접 포함하는 대신 인용 된 컨텐츠 (예 : &lt;a href=&quot;07-0-qdoc-commands-includingexternalcode#quotefromfile-command&quot;&gt;\ quotefromfile&lt;/a&gt; 및 &lt;a href=&quot;07-0-qdoc-commands-includingexternalcode#snippet-command&quot;&gt;\ snippet&lt;/a&gt; 명령)에 대한 참조를 생성 하는 부울 값입니다 .</target>
        </trans-unit>
        <trans-unit id="20fce9945cbc012f4dc34373333167e76d7bfb48" translate="yes" xml:space="preserve">
          <source>A boolean value. If true, left clicking on a scroll bar causes the slider to jump to that position. If false, left clicking will behave as appropriate for each control.</source>
          <target state="translated">부울 값입니다. true 인 경우 스크롤 막대를 마우스 왼쪽 버튼으로 클릭하면 슬라이더가 해당 위치로 이동합니다. False 인 경우 왼쪽 클릭은 각 컨트롤에 따라 동작합니다.</target>
        </trans-unit>
        <trans-unit id="2472f93eb5271b0532fd57a1074b72b33b9545d3" translate="yes" xml:space="preserve">
          <source>A boolean value. If true, middle clicking on a scroll bar causes the slider to jump to that position. If false, middle clicking is ignored.</source>
          <target state="translated">부울 값입니다. true 인 경우 스크롤 막대를 가운데 클릭하면 슬라이더가 해당 위치로 이동합니다. false 인 경우 중간 클릭이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="6c0efedf6b27777e43eab1dff50b840800d6a71a" translate="yes" xml:space="preserve">
          <source>A boolean value. If true, when clicking a scroll bar &lt;a href=&quot;qstyle#SubControl-enum&quot;&gt;SubControl&lt;/a&gt;, holding the mouse button down and moving the pointer outside the &lt;a href=&quot;qstyle#SubControl-enum&quot;&gt;SubControl&lt;/a&gt;, the scroll bar continues to scroll. If false, the scollbar stops scrolling when the pointer leaves the &lt;a href=&quot;qstyle#SubControl-enum&quot;&gt;SubControl&lt;/a&gt;.</source>
          <target state="translated">부울 값입니다. true 인 경우 스크롤 막대 &lt;a href=&quot;qstyle#SubControl-enum&quot;&gt;SubControl을&lt;/a&gt; 클릭 하고 마우스 단추를 누른 상태에서 포인터를 &lt;a href=&quot;qstyle#SubControl-enum&quot;&gt;SubControl&lt;/a&gt; 외부로 이동 하면 스크롤 막대가 계속 스크롤됩니다. False이면 포인터가 &lt;a href=&quot;qstyle#SubControl-enum&quot;&gt;SubControl을&lt;/a&gt; 떠날 때 스콜 바가 스크롤을 중지합니다 .</target>
        </trans-unit>
        <trans-unit id="a4b9c2a24ed4081cf776775f43c543394a0da5fc" translate="yes" xml:space="preserve">
          <source>A boolean value. If true, when clicking a scroll bar button (&lt;a href=&quot;qstyle#SubControl-enum&quot;&gt;SC_ScrollBarAddLine&lt;/a&gt; or &lt;a href=&quot;qstyle#SubControl-enum&quot;&gt;SC_ScrollBarSubLine&lt;/a&gt;) and dragging over to the opposite button (rolling) will press the new button and release the old one. When it is false, the original button is released and nothing happens (like a push button).</source>
          <target state="translated">부울 값입니다. true 인 경우 스크롤 막대 버튼 ( &lt;a href=&quot;qstyle#SubControl-enum&quot;&gt;SC_ScrollBarAddLine&lt;/a&gt; 또는 &lt;a href=&quot;qstyle#SubControl-enum&quot;&gt;SC_ScrollBarSubLine&lt;/a&gt; )을 클릭하고 반대 버튼 (롤링)으로 드래그하면 새 버튼을 누르고 이전 버튼을 놓습니다 . False이면 원래 버튼이 해제되고 아무 것도 발생하지 않습니다 (예 : 누름 버튼).</target>
        </trans-unit>
        <trans-unit id="65c7c21e566ea525d1067d0e1b9837b1f5ce6aa9" translate="yes" xml:space="preserve">
          <source>A boolean value. Use &lt;a href=&quot;qjsonvalue#toBool&quot;&gt;toBool&lt;/a&gt;() to convert to a bool.</source>
          <target state="translated">부울 값입니다. 부울로 변환 하려면 &lt;a href=&quot;qjsonvalue#toBool&quot;&gt;toBool&lt;/a&gt; ()을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="419f96b1757747d7827663b26e75e1b02d9eb6cb" translate="yes" xml:space="preserve">
          <source>A border image is an image that is composed of nine parts (top left, top center, top right, center left, center, center right, bottom left, bottom center, and bottom right). When a border of a certain size is required, the corner parts are used as is, and the top, right, bottom, and left parts are stretched or repeated to produce a border with the desired size.</source>
          <target state="translated">테두리 이미지는 9 개의 부분 (왼쪽 위, 가운데 위, 오른쪽 위, 가운데 왼쪽, 가운데, 가운데 오른쪽, 왼쪽 아래, 아래쪽 가운데 및 오른쪽 아래)으로 구성된 이미지입니다. 특정 크기의 테두리가 필요한 경우 모서리 부분을 그대로 사용하고 위쪽, 오른쪽, 아래쪽 및 왼쪽 부분을 늘이거나 반복하여 원하는 크기의 테두리를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="b357bb5f2b2d4a6f76d573dab96cba25ea1ebb7e" translate="yes" xml:space="preserve">
          <source>A bounding volume can be provided either as minimum and maximum extent coordinates, or a separate, usually simpler, geometry that approximates the rendered mesh.</source>
          <target state="translated">경계 볼륨은 최소 및 최대 범위 좌표로 제공되거나 렌더링 된 메시에 근접하는 별도의 일반적으로 더 간단한 지오메트리로 제공 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a3d3047aa7d9fbbe26c1b917afdae1960b93f22" translate="yes" xml:space="preserve">
          <source>A box plot chart.</source>
          <target state="translated">박스 플롯 차트.</target>
        </trans-unit>
        <trans-unit id="2b44ef30a7bf4766062ddc0612b552ca2bba1255" translate="yes" xml:space="preserve">
          <source>A box plot legend marker is related to a &lt;a href=&quot;qboxplotseries&quot;&gt;QBoxPlotSeries&lt;/a&gt; object.</source>
          <target state="translated">상자 그림 범례 마커는 &lt;a href=&quot;qboxplotseries&quot;&gt;QBoxPlotSeries&lt;/a&gt; 객체 와 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c2e1eff73bff24979c4ceba2ea1dce0cf431d6f5" translate="yes" xml:space="preserve">
          <source>A box plot series acts as a container for box-and-whiskers items. Items from multiple series are grouped into categories according to their index value.</source>
          <target state="translated">상자 그림 시리즈는 상자 및 수염 품목의 컨테이너 역할을합니다. 여러 계열의 항목은 색인 값에 따라 범주로 그룹화됩니다.</target>
        </trans-unit>
        <trans-unit id="435625d075eaf9111b22423ebca2911477465d6d" translate="yes" xml:space="preserve">
          <source>A box plot series.</source>
          <target state="translated">박스 플롯 시리즈.</target>
        </trans-unit>
        <trans-unit id="e28bd17db2f35d630c247e40bbeb82721b91f8ae" translate="yes" xml:space="preserve">
          <source>A box-and-whiskers item is a graphical representation of a range and three median values that is constructed from five different values. There are two ways to specify the values. The first one is by using a constructor or stream operator (&amp;lt;&amp;lt;). The values have to be specified in the following order: lower extreme, lower quartile, median, upper quartile, and upper extreme.</source>
          <target state="translated">box-and-whiskers 항목은 5 개의 다른 값으로 구성된 범위와 3 개의 중앙값을 그래픽으로 표현한 것입니다. 값을 지정하는 두 가지 방법이 있습니다. 첫 번째는 생성자 또는 스트림 연산자 (&amp;lt;&amp;lt;)를 사용하는 것입니다. 값은 다음 순서로 지정해야합니다. 극단 하한, 사 분위수, 중앙값, 상한 사 분위수 및 상위 극단.</target>
        </trans-unit>
        <trans-unit id="a4903dead201c3b2103de42eabd7dbe307e4506b" translate="yes" xml:space="preserve">
          <source>A box-and-whiskers item is a graphical representation of a range and three median values that is constructed from five different values. There are two ways to specify the values. The first one is by using a constructor or the &lt;a href=&quot;qml-qtcharts-boxset#append-method&quot;&gt;append()&lt;/a&gt; method. The values have to be specified in the following order: lower extreme, lower quartile, median, upper quartile, and upper extreme.</source>
          <target state="translated">box-and-whiskers 항목은 5 개의 다른 값으로 구성된 범위와 3 개의 중앙값을 그래픽으로 표현한 것입니다. 값을 지정하는 두 가지 방법이 있습니다. 첫 번째는 생성자 또는 &lt;a href=&quot;qml-qtcharts-boxset#append-method&quot;&gt;append ()&lt;/a&gt; 메소드를 사용하는 것입니다. 값은 다음 순서로 지정해야합니다. 극단 하한, 사 분위수, 중앙값, 상한 사 분위수 및 상위 극단.</target>
        </trans-unit>
        <trans-unit id="2f19da4c030ae6ad6856f9162817b838e28c1eac" translate="yes" xml:space="preserve">
          <source>A brief introduction to regexps is presented, a description of Qt's regexp language, some examples, and the function documentation itself. &lt;a href=&quot;qregexp&quot;&gt;QRegExp&lt;/a&gt; is modeled on Perl's regexp language. It fully supports Unicode. &lt;a href=&quot;qregexp&quot;&gt;QRegExp&lt;/a&gt; can also be used in a simpler,</source>
          <target state="translated">정규 표현식에 대한 간략한 소개, Qt의 정규 표현식 언어에 대한 설명, 몇 가지 예 및 함수 문서 자체가 제공됩니다. &lt;a href=&quot;qregexp&quot;&gt;QRegExp&lt;/a&gt; 는 Perl의 정규 표현식 언어로 모델링되었습니다. 유니 코드를 완벽하게 지원합니다. &lt;a href=&quot;qregexp&quot;&gt;QRegExp&lt;/a&gt; 는 더 간단한 방법으로도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7abb8e03458a9a72947a23f2bf2e81e09417f858" translate="yes" xml:space="preserve">
          <source>A brief introduction to regexps is presented, a description of Qt's regexp language, some examples, and the function documentation itself. QRegExp is modeled on Perl's regexp language. It fully supports Unicode. QRegExp can also be used in a simpler,</source>
          <target state="translated">정규 표현식에 대한 간략한 소개, Qt의 정규 표현식 언어에 대한 설명, 몇 가지 예제 및 함수 문서 자체가 제공됩니다. QRegExp는 Perl의 regexp 언어를 모델로합니다. 유니 코드를 완벽하게 지원합니다. QRegExp는 더 간단하게 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e0a911d6318efa1994a904469c80f90cc48d14cb" translate="yes" xml:space="preserve">
          <source>A brush has a style, a color, a gradient and a texture.</source>
          <target state="translated">브러시에는 스타일, 색상, 그라디언트 및 질감이 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a309a1d420f4e248bbfc0a0c9e320d397a60a65" translate="yes" xml:space="preserve">
          <source>A brush strokes noise effect. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">브러시 스트로크 노이즈 효과. &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7208674860ae3c99d2955f1439b1badb07c9b726" translate="yes" xml:space="preserve">
          <source>A bug in the OpenGL driver related to framebuffer object (FBO) readbacks may corrupt rendered glyphs. If you set the &lt;code&gt;QML_USE_GLYPHCACHE_WORKAROUND&lt;/code&gt; environment variable, Qt keeps an additional copy of the glyph in RAM. This means that performance is slightly lower when drawing glyphs that have not been drawn before, as Qt accesses the extra copy via the CPU. It also means that the glyph cache will use twice as much memory. The quality is not affected by this.</source>
          <target state="translated">프레임 버퍼 객체 (FBO) 리드 백과 관련된 OpenGL 드라이버의 버그로 인해 렌더링 된 글리프가 손상 될 수 있습니다. &lt;code&gt;QML_USE_GLYPHCACHE_WORKAROUND&lt;/code&gt; 환경 변수 를 설정하면 Qt는 글리프의 추가 사본을 RAM에 유지합니다. 이는 Qt가 CPU를 통해 추가 사본에 액세스하므로 이전에 그려지지 않은 글리프를 그릴 때 성능이 약간 저하됨을 의미합니다. 또한 글리프 캐시가 두 배의 메모리를 사용함을 의미합니다. 품질에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="128491aeb8ae34f2eb3cecbc41e7f6920b89076a" translate="yes" xml:space="preserve">
          <source>A busy indicator</source>
          <target state="translated">통화 중 표시기</target>
        </trans-unit>
        <trans-unit id="c1d7e635a9f1ede437020e73cb251a356066d331" translate="yes" xml:space="preserve">
          <source>A busy indicator. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">통화 중 표시기. &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="609cc4e081ee1fd649bcd7b21d2f2c717f1cc2aa" translate="yes" xml:space="preserve">
          <source>A button box used in dialogs. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">대화 상자에 사용되는 버튼 상자. &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7272a50e50b670a5fb2d5b39ae145843413d5545" translate="yes" xml:space="preserve">
          <source>A button can be added to the group with &lt;a href=&quot;qbuttongroup#addButton&quot;&gt;addButton&lt;/a&gt;() and removed with &lt;a href=&quot;qbuttongroup#removeButton&quot;&gt;removeButton&lt;/a&gt;(). If the group is exclusive, the currently checked button is available with &lt;a href=&quot;qbuttongroup#checkedButton&quot;&gt;checkedButton&lt;/a&gt;(). If a button is clicked, the &lt;a href=&quot;qbuttongroup#buttonClicked&quot;&gt;buttonClicked&lt;/a&gt;() signal is emitted; for a checkable button in an exclusive group this means that the button has been checked. The list of buttons in the group is returned by &lt;a href=&quot;qbuttongroup#buttons&quot;&gt;buttons&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qbuttongroup#addButton&quot;&gt;addButton&lt;/a&gt; () 을 사용하여 그룹에 버튼을 추가 하고 &lt;a href=&quot;qbuttongroup#removeButton&quot;&gt;removeButton&lt;/a&gt; ()을 사용 하여 제거 할 수 있습니다 . 그룹이 배타적이면 현재 선택된 버튼은 &lt;a href=&quot;qbuttongroup#checkedButton&quot;&gt;checkedButton&lt;/a&gt; () 과 함께 사용할 수 있습니다 . 버튼을 클릭하면 &lt;a href=&quot;qbuttongroup#buttonClicked&quot;&gt;buttonClicked&lt;/a&gt; () 신호가 출력됩니다. 독점 그룹의 확인 가능한 버튼의 경우 버튼이 확인되었음을 의미합니다. 그룹의 버튼 목록은 &lt;a href=&quot;qbuttongroup#buttons&quot;&gt;버튼&lt;/a&gt; ()으로 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="2497d364b1a62832d83b4c164b55a1294f2dded8" translate="yes" xml:space="preserve">
          <source>A button can be highlighted in order to draw the user's attention towards it. It has no effect on keyboard interaction.</source>
          <target state="translated">사용자의주의를 끌기 위해 버튼을 강조 표시 할 수 있습니다. 키보드 상호 작용에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3a7342c866f20cc585f7d7564e11d82ae4a85a8d" translate="yes" xml:space="preserve">
          <source>A button can be made the default button in a dialog by means of &lt;a href=&quot;qpushbutton#default-prop&quot;&gt;QPushButton::setDefault&lt;/a&gt;() and &lt;a href=&quot;qpushbutton#autoDefault-prop&quot;&gt;QPushButton::setAutoDefault&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qpushbutton#default-prop&quot;&gt;QPushButton :: setDefault&lt;/a&gt; () 및 &lt;a href=&quot;qpushbutton#autoDefault-prop&quot;&gt;QPushButton :: setAutoDefault&lt;/a&gt; () 를 사용하여 대화 상자에서 단추를 기본 단추로 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5e1e0e6b10d6a25dd228adadbffc5ea2bcf636f0" translate="yes" xml:space="preserve">
          <source>A button emits the signal &lt;a href=&quot;qml-qtquick-controls2-abstractbutton#clicked-signal&quot;&gt;clicked()&lt;/a&gt; when it is activated by the user. Connect to this signal to perform the button's action. Buttons also provide the signals &lt;a href=&quot;qml-qtquick-controls2-abstractbutton#canceled-signal&quot;&gt;canceled()&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-controls2-abstractbutton#doubleClicked-signal&quot;&gt;doubleClicked()&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-controls2-abstractbutton#pressed-signal&quot;&gt;pressed()&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-controls2-abstractbutton#released-signal&quot;&gt;released()&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-controls2-abstractbutton#pressAndHold-signal&quot;&gt;pressAndHold()&lt;/a&gt; for long presses.</source>
          <target state="translated">사용자가 버튼을 활성화 &lt;a href=&quot;qml-qtquick-controls2-abstractbutton#clicked-signal&quot;&gt;하면&lt;/a&gt; 버튼 clicked () 신호 가 발생합니다 . 이 신호에 연결하여 버튼의 동작을 수행하십시오. 버튼은 또한 &lt;a href=&quot;qml-qtquick-controls2-abstractbutton#canceled-signal&quot;&gt;canceled ()&lt;/a&gt; , &lt;a href=&quot;qml-qtquick-controls2-abstractbutton#doubleClicked-signal&quot;&gt;doubleClicked ()&lt;/a&gt; , &lt;a href=&quot;qml-qtquick-controls2-abstractbutton#pressed-signal&quot;&gt;pressed ()&lt;/a&gt; , &lt;a href=&quot;qml-qtquick-controls2-abstractbutton#released-signal&quot;&gt;release ()&lt;/a&gt; 및 &lt;a href=&quot;qml-qtquick-controls2-abstractbutton#pressAndHold-signal&quot;&gt;pressAndHold () 신호&lt;/a&gt; 를 길게 눌러 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f15fe6779d9f2bd664406c7028ec2f16f408810f" translate="yes" xml:space="preserve">
          <source>A button might have two states, the &lt;code&gt;pressed&lt;/code&gt; state when the user clicks on the button and a &lt;code&gt;released&lt;/code&gt; state when the user releases the button. We can assign different property configurations for each state. A transition would animate the change from the &lt;code&gt;pressed&lt;/code&gt; state to the &lt;code&gt;released&lt;/code&gt; state. Likewise, there would be an animation during the change from the &lt;code&gt;released&lt;/code&gt; state to the &lt;code&gt;pressed&lt;/code&gt; state.</source>
          <target state="translated">버튼은 사용자가 버튼을 클릭 할 때 &lt;code&gt;pressed&lt;/code&gt; 상태와 버튼을 &lt;code&gt;released&lt;/code&gt; 때 놓인 상태의 두 가지 상태를 가질 수 있습니다 . 각 상태마다 다른 속성 구성을 할당 할 수 있습니다. 전환은 &lt;code&gt;pressed&lt;/code&gt; 상태에서 &lt;code&gt;released&lt;/code&gt; 상태 로의 변경을 애니메이션으로 만듭니다. 마찬가지로 &lt;code&gt;released&lt;/code&gt; 상태에서 &lt;code&gt;pressed&lt;/code&gt; 상태 로 변경하는 동안 애니메이션이 나타납니다 .</target>
        </trans-unit>
        <trans-unit id="efe8bb6922d7bd4d8f5e0fdcfafa390417d02d39" translate="yes" xml:space="preserve">
          <source>A button should have a signal handler with the name &lt;code&gt;onPressAction&lt;/code&gt;. This signal may be emitted by an assistive tool such as a screen-reader. The implementation needs to behave the same as a mouse click or tap on the button.</source>
          <target state="translated">버튼에는 이름이 &lt;code&gt;onPressAction&lt;/code&gt; 인 신호 핸들러가 있어야합니다 . 이 신호는 스크린 리더와 같은 보조 도구에 의해 방출 될 수 있습니다. 구현은 마우스 클릭과 동일하게 동작하거나 버튼을 탭해야합니다.</target>
        </trans-unit>
        <trans-unit id="aed5ad419951654815bf4a4de98c8c7ff92d1cfd" translate="yes" xml:space="preserve">
          <source>A button that drops down a grid.</source>
          <target state="translated">그리드를 드롭 다운하는 버튼입니다.</target>
        </trans-unit>
        <trans-unit id="a5c3257a981edefdc4311df1c8c0cc337d5b7471" translate="yes" xml:space="preserve">
          <source>A button that drops down a list of items.</source>
          <target state="translated">항목 목록을 드롭 다운하는 버튼입니다.</target>
        </trans-unit>
        <trans-unit id="feb27363c7131557dca217667eb959d04e55a817" translate="yes" xml:space="preserve">
          <source>A button that drops down a menu.</source>
          <target state="translated">메뉴를 드롭 다운하는 버튼입니다.</target>
        </trans-unit>
        <trans-unit id="00f4764b9bd8fdbac0556580e9b1dbf35820e1c7" translate="yes" xml:space="preserve">
          <source>A button with this property set to true (i.e., the dialog's</source>
          <target state="translated">이 속성이 true로 설정된 버튼 (예 : 대화 상자의</target>
        </trans-unit>
        <trans-unit id="be695cd7044454b87d1306eb29238045fd92cbe9" translate="yes" xml:space="preserve">
          <source>A button.</source>
          <target state="translated">단추.</target>
        </trans-unit>
        <trans-unit id="987864fff3956f9623f7dba77d38e5f5db4e4c16" translate="yes" xml:space="preserve">
          <source>A cache of generated shader code is maintained. Generated shaders are by defaults saved in &lt;a href=&quot;qstandardpaths#writableLocation&quot;&gt;QStandardPaths::writableLocation&lt;/a&gt;(&lt;a href=&quot;qstandardpaths#StandardLocation-enum&quot;&gt;QStandardPaths::TempLocation&lt;/a&gt;)). This path can be overridden by setting environment variable QT3D_WRITABLE_CACHE_PATH to a valid writable path.</source>
          <target state="translated">생성 된 셰이더 코드의 캐시가 유지됩니다. 생성 된 셰이더는 기본적으로 &lt;a href=&quot;qstandardpaths#StandardLocation-enum&quot;&gt;QStandardPaths &lt;/a&gt;&lt;a href=&quot;qstandardpaths#writableLocation&quot;&gt;:: writableLocation&lt;/a&gt; ( QStandardPaths :: TempLocation ))에 저장됩니다. 이 경로는 환경 변수 QT3D_WRITABLE_CACHE_PATH를 유효한 쓰기 가능한 경로로 설정하여 재정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f0d0274d768866ee726c340c62d8c3b6e2c551d" translate="yes" xml:space="preserve">
          <source>A calendar may represent years from its first year onwards but provide no way to describe years before its first; such a calendar has no year zero and is not proleptic.</source>
          <target state="translated">달력은 첫해 이후의 연도를 나타낼 수 있지만 첫해 이전의 연도를 설명 할 방법은 없습니다. 그러한 달력에는 0 년이 없으며 proleptic이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="b149150fce88356d35ff9955eb380f4d81b43e06" translate="yes" xml:space="preserve">
          <source>A calendar model</source>
          <target state="translated">캘린더 모델</target>
        </trans-unit>
        <trans-unit id="92588cbb54e0f3c0cae869fcebf0d30cd73fae03" translate="yes" xml:space="preserve">
          <source>A calendar model. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">달력 모델. &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="60e3e7d65d5dd4cd624a9b7823770044ecf5e01d" translate="yes" xml:space="preserve">
          <source>A calendar namespace</source>
          <target state="translated">캘린더 네임 스페이스</target>
        </trans-unit>
        <trans-unit id="ac5a319eb40e19ef6583d3cce7647cb885b3ac09" translate="yes" xml:space="preserve">
          <source>A calendar namespace. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">달력 네임 스페이스 &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1f6d714b36545b80ee08d640cbdcea6f19e95499" translate="yes" xml:space="preserve">
          <source>A calendar which represents years before its first may number these years simply by following the usual integer counting, so that the year before the first is year zero, with negative-numbered years preceding this; such a calendar is proleptic and has a year zero. A calendar might also have a year zero (for example, the year of some great event, with subsequent years being the first year after that event, the second year after, and so on) without describing years before its year zero. Such a calendar would have a year zero without being proleptic.</source>
          <target state="translated">첫 번째 연도를 나타내는 달력은 일반적인 정수 계산에 따라이 연도를 간단히 번호를 매길 수 있으므로 첫 번째 연도는 0 년이고 이보다 앞선 연도는 음수입니다. 그러한 달력은 proleptic이고 연도는 0입니다. 달력에는 0 년 이전의 연도를 설명하지 않고 0 년 (예 : 멋진 이벤트의 연도, 이후 연도는 해당 이벤트 후 첫 해, 다음 해 2 년 등)이있을 수도 있습니다. 그러한 달력은 proleptic없이 0 년을 가질 것입니다.</target>
        </trans-unit>
        <trans-unit id="558544903de5fcadbfd88f1d6ff3d9fa79ff1102" translate="yes" xml:space="preserve">
          <source>A call to this function results in a write request to the remote device. If the operation is successful, the &lt;a href=&quot;qlowenergyservice#descriptorWritten&quot;&gt;descriptorWritten&lt;/a&gt;() signal is emitted; otherwise the &lt;a href=&quot;qlowenergyservice#ServiceError-enum&quot;&gt;DescriptorWriteError&lt;/a&gt; is emitted.</source>
          <target state="translated">이 기능을 호출하면 원격 장치에 대한 쓰기 요청이 발생합니다. 작업이 성공하면 &lt;a href=&quot;qlowenergyservice#descriptorWritten&quot;&gt;descriptorWritten&lt;/a&gt; () 신호가 발생합니다. 그렇지 않으면 &lt;a href=&quot;qlowenergyservice#ServiceError-enum&quot;&gt;DescriptorWriteError&lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1ec58acdddc0c9749c3cafebb437e0727abab41a" translate="yes" xml:space="preserve">
          <source>A camera.</source>
          <target state="translated">카메라.</target>
        </trans-unit>
        <trans-unit id="79ab48857799fe6d7a941e3d09e55d6ad3bc1dc9" translate="yes" xml:space="preserve">
          <source>A cancelled &lt;a href=&quot;qquickimageresponse&quot;&gt;QQuickImageResponse&lt;/a&gt; still needs to emit &lt;a href=&quot;qquickimageresponse#finished&quot;&gt;finished&lt;/a&gt;() so that the engine may clean up the &lt;a href=&quot;qquickimageresponse&quot;&gt;QQuickImageResponse&lt;/a&gt;.</source>
          <target state="translated">취소 된 &lt;a href=&quot;qquickimageresponse&quot;&gt;QQuickImageResponse는&lt;/a&gt; 여전히 방출 할 필요가 &lt;a href=&quot;qquickimageresponse#finished&quot;&gt;완성 된&lt;/a&gt; 엔진이 정리 수 () 그래서 &lt;a href=&quot;qquickimageresponse&quot;&gt;QQuickImageResponse을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fe94f2bb164a785104820f23f89290b25d2b95f5" translate="yes" xml:space="preserve">
          <source>A candlestick chart.</source>
          <target state="translated">촛대 차트.</target>
        </trans-unit>
        <trans-unit id="4aedc28e1670639c07f1b48b1b2b96a01db39c8a" translate="yes" xml:space="preserve">
          <source>A candlestick is</source>
          <target state="translated">촛대는</target>
        </trans-unit>
        <trans-unit id="a614fcd8cfdaaf6dbef87dfe0fac181ad1b8b82d" translate="yes" xml:space="preserve">
          <source>A candlestick series.</source>
          <target state="translated">촛대 시리즈.</target>
        </trans-unit>
        <trans-unit id="be84e962b2da0217c4d744a4f692b67ed3fbe279" translate="yes" xml:space="preserve">
          <source>A canvas.</source>
          <target state="translated">캔버스.</target>
        </trans-unit>
        <trans-unit id="cadbbbe6e6e8bf24d1252363a6e4554c703c609c" translate="yes" xml:space="preserve">
          <source>A car audio device.</source>
          <target state="translated">자동차 오디오 장치.</target>
        </trans-unit>
        <trans-unit id="779079ac0db3514f8cf252c436ae917e02b8a42d" translate="yes" xml:space="preserve">
          <source>A card reader peripheral.</source>
          <target state="translated">카드 리더 주변 장치.</target>
        </trans-unit>
        <trans-unit id="0fde8263bc4589294cd424e4af86748769447c81" translate="yes" xml:space="preserve">
          <source>A caret or ibeam cursor, indicating that a widget can accept and display text input.</source>
          <target state="translated">위젯이 텍스트 입력을 승인하고 표시 할 수 있음을 나타내는 캐럿 또는 ibeam 커서.</target>
        </trans-unit>
        <trans-unit id="45cad47112b06803329dbdd2e1c6f353279ae113" translate="yes" xml:space="preserve">
          <source>A cartesian chart.</source>
          <target state="translated">데카르트 차트.</target>
        </trans-unit>
        <trans-unit id="666dafa162e794b8ce56fbf157b3cbe18afd90ff" translate="yes" xml:space="preserve">
          <source>A case insensitive comparison is used when determining section boundaries.</source>
          <target state="translated">섹션 경계를 결정할 때 대소 문자를 구분하지 않는 비교가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3360f3aa718ccfacbeb16227d84425efc83a532e" translate="yes" xml:space="preserve">
          <source>A cast from a sequential container will also return true for this function if the</source>
          <target state="translated">순차 컨테이너의 캐스트도이 함수에 대해 true를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5377a387f9b4f49aff927b3c79e5963a4c7bbfb2" translate="yes" xml:space="preserve">
          <source>A category has to be a valid &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; and it cannot be duplicated.</source>
          <target state="translated">카테고리는 유효한 &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; 이어야하며 복제 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1965348afe199399d844ffe3bac6f41ac976195a" translate="yes" xml:space="preserve">
          <source>A category has to be a valid &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; and it cannot be duplicated. Duplicated categories will not be appended.</source>
          <target state="translated">카테고리는 유효한 &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; 이어야하며 복제 할 수 없습니다. 중복 된 카테고리는 추가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f7d575d107a5422778f541a348130daed9ba7b4b" translate="yes" xml:space="preserve">
          <source>A cell in a table.</source>
          <target state="translated">테이블의 셀</target>
        </trans-unit>
        <trans-unit id="0cbd0bf91edb1ab168224670aeb6d7b9ed0aca74" translate="yes" xml:space="preserve">
          <source>A cellular phone.</source>
          <target state="translated">휴대 전화</target>
        </trans-unit>
        <trans-unit id="56b7dce42d2f59ed76aa837ccc65bfde1741dd5d" translate="yes" xml:space="preserve">
          <source>A centered-tab</source>
          <target state="translated">중앙 탭</target>
        </trans-unit>
        <trans-unit id="28b03e8ca566693c16a56c1739ffaf6a98a6a963" translate="yes" xml:space="preserve">
          <source>A central widget will typically be a standard Qt widget such as a &lt;a href=&quot;qtextedit&quot;&gt;QTextEdit&lt;/a&gt; or a &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt;. Custom widgets can also be used for advanced applications. You set the central widget with &lt;code&gt;setCentralWidget()&lt;/code&gt;.</source>
          <target state="translated">중앙 위젯은 일반적으로 &lt;a href=&quot;qtextedit&quot;&gt;QTextEdit&lt;/a&gt; 또는 &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; 와 같은 표준 Qt 위젯 입니다. 사용자 정의 위젯은 고급 애플리케이션에도 사용할 수 있습니다. &lt;code&gt;setCentralWidget()&lt;/code&gt; 사용하여 중앙 위젯을 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="a69bb4e9027db42bf7e3e18e79892b2928c4afda" translate="yes" xml:space="preserve">
          <source>A certificate is considered self-signed its issuer and subject are identical.</source>
          <target state="translated">인증서는 자체 서명 된 것으로 간주되며 발급자와 주제는 동일합니다.</target>
        </trans-unit>
        <trans-unit id="d6093d7384b5b8c9bb058cf4c3436fd19809c9bd" translate="yes" xml:space="preserve">
          <source>A certificate is the means of identification used in the SSL process. The local certificate is used by the remote end to verify the local user's identity against its list of Certification Authorities. In most cases, such as in HTTP web browsing, only servers identify to the clients, so the client does not send a certificate.</source>
          <target state="translated">인증서는 SSL 프로세스에서 사용되는 식별 수단입니다. 로컬 인증서는 원격 사용자가 인증 기관 목록과 비교하여 로컬 사용자의 신원을 확인하는 데 사용됩니다. HTTP 웹 브라우징과 같은 대부분의 경우 서버 만 클라이언트를 식별하므로 클라이언트는 인증서를 보내지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4f3b217ad2b7fef3916423a2a387d3bf74a34e8e" translate="yes" xml:space="preserve">
          <source>A change occurs in the QML scene, causing &lt;code&gt;QQuickItem::update()&lt;/code&gt; to be called. This can be the result of for instance an animation or user input. An event is posted to the render thread to initiate a new frame.</source>
          <target state="translated">QML 장면에서 변경이 발생하여 &lt;code&gt;QQuickItem::update()&lt;/code&gt; 가 호출됩니다. 예를 들어 애니메이션 또는 사용자 입력의 결과 일 수 있습니다. 새 프레임을 시작하기 위해 이벤트가 렌더 스레드에 게시됩니다.</target>
        </trans-unit>
        <trans-unit id="fdd6b0668e6bf766ccb1da072392109f3e2885ec" translate="yes" xml:space="preserve">
          <source>A character represents itself unless it has a special regexp meaning. e.g. &lt;b&gt;c&lt;/b&gt; matches the character</source>
          <target state="translated">특별한 정규 표현식 의미가 없으면 문자가 나타납니다. 예 &lt;b&gt;C는&lt;/b&gt; 문자와 일치</target>
        </trans-unit>
        <trans-unit id="d05b7daaba0cf9c580c318292d1c3fcf2906a043" translate="yes" xml:space="preserve">
          <source>A character that follows a backslash matches the character itself, except as specified below. e.g., To match a literal caret at the beginning of a string, write &lt;b&gt;\^&lt;/b&gt;.</source>
          <target state="translated">백 슬래시 뒤에 오는 문자는 아래에 지정된 것을 제외하고 문자 자체와 일치합니다. 예를 들어, 문자열의 시작 부분에 리터럴 캐럿을 일치 시키려면 &lt;b&gt;\ ^을 작성하십시오&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="a8cfa68a7caef63e2e65376beba8eb59b47b317c" translate="yes" xml:space="preserve">
          <source>A characteristic belongs to a service if &lt;a href=&quot;qlowenergyservice#characteristics&quot;&gt;characteristics&lt;/a&gt;() contains the</source>
          <target state="translated">&lt;a href=&quot;qlowenergyservice#characteristics&quot;&gt;특성&lt;/a&gt; ()에 다음이 포함 된 경우 특성 은 서비스에 속합니다 .</target>
        </trans-unit>
        <trans-unit id="e3bd8c6a594af37f9dc4b4ca31858117c2e53e60" translate="yes" xml:space="preserve">
          <source>A characteristic can only be read if the service is in the &lt;a href=&quot;qlowenergyservice#ServiceState-enum&quot;&gt;ServiceDiscovered&lt;/a&gt; state and belongs to the service. If one of these conditions is not true the &lt;a href=&quot;qlowenergyservice#ServiceError-enum&quot;&gt;QLowEnergyService::OperationError&lt;/a&gt; is set.</source>
          <target state="translated">서비스가 &lt;a href=&quot;qlowenergyservice#ServiceState-enum&quot;&gt;ServiceDiscovered&lt;/a&gt; 상태이고 서비스에 속하는 경우에만 특성을 읽을 수 있습니다 . 이러한 조건 중 하나가 true가 아닌 경우 &lt;a href=&quot;qlowenergyservice#ServiceError-enum&quot;&gt;QLowEnergyService :: OperationError&lt;/a&gt; 가 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="9e330f868aa683ecb78c92abe79c89d9cb1d6852" translate="yes" xml:space="preserve">
          <source>A characteristic can only be written if this service is in the &lt;a href=&quot;qlowenergyservice#ServiceState-enum&quot;&gt;ServiceDiscovered&lt;/a&gt; state and belongs to the service. If one of these conditions is not true the &lt;a href=&quot;qlowenergyservice#ServiceError-enum&quot;&gt;QLowEnergyService::OperationError&lt;/a&gt; is set.</source>
          <target state="translated">이 서비스가 &lt;a href=&quot;qlowenergyservice#ServiceState-enum&quot;&gt;ServiceDiscovered&lt;/a&gt; 상태이고 서비스에 속하는 경우에만 특성을 쓸 수 있습니다 . 이러한 조건 중 하나가 true가 아닌 경우 &lt;a href=&quot;qlowenergyservice#ServiceError-enum&quot;&gt;QLowEnergyService :: OperationError&lt;/a&gt; 가 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="f350792e445787068030d52e84fae01f78e5fce5" translate="yes" xml:space="preserve">
          <source>A characteristic is the principal information carrier. It has a &lt;a href=&quot;qlowenergycharacteristic#value&quot;&gt;value()&lt;/a&gt; and &lt;a href=&quot;qlowenergycharacteristic#value&quot;&gt;properties()&lt;/a&gt; describing the access permissions for the value. The general purpose of the contained descriptor is to further define the nature of the characteristic. For example, it might specify how the value is meant to be interpreted or whether it can notify the value consumer about value changes.</source>
          <target state="translated">특징은 주요 정보 매체입니다. &lt;a href=&quot;qlowenergycharacteristic#value&quot;&gt;값에&lt;/a&gt; 대한 액세스 권한을 설명 하는 value () 및 &lt;a href=&quot;qlowenergycharacteristic#value&quot;&gt;properties ()&lt;/a&gt; 가 있습니다. 포함 된 디스크립터의 일반적인 목적은 특성의 특성을 추가로 정의하는 것입니다. 예를 들어, 값을 해석하는 방법 또는 값 소비자에게 값 변경에 대해 알릴 수 있는지 여부를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="796ed48ca2b07d9b5ebd0790c64cfe2c6610ccd1" translate="yes" xml:space="preserve">
          <source>A chart view does not require a &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; object to work. To display a chart in an existing &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt;, the &lt;a href=&quot;qchart&quot;&gt;QChart&lt;/a&gt; or &lt;a href=&quot;qpolarchart&quot;&gt;QPolarChart&lt;/a&gt; class should be used instead.</source>
          <target state="translated">차트보기에는 &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; 객체가 필요하지 않습니다 . 기존의 차트를 표시하려면 &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene을&lt;/a&gt; 의 &lt;a href=&quot;qchart&quot;&gt;QChart&lt;/a&gt; 또는 &lt;a href=&quot;qpolarchart&quot;&gt;QPolarChart&lt;/a&gt; 클래스를 대신 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="151dbd453e9e81aed06730583c8d205be0364a6b" translate="yes" xml:space="preserve">
          <source>A check box, like &lt;a href=&quot;qcheckbox&quot;&gt;QCheckBox&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qcheckbox&quot;&gt;QCheckBox&lt;/a&gt; 와 같은 확인란 .</target>
        </trans-unit>
        <trans-unit id="5268ccff6ca860d351a4eb531f722284344d32ed" translate="yes" xml:space="preserve">
          <source>A checkable action is one which has an on/off state. For example, in a word processor, a Bold toolbar button may be either on or off. An action which is not a toggle action is a command action; a command action is simply executed, e.g. file save. By default, this property is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">점검 가능한 조치는 켜기 / 끄기 상태입니다. 예를 들어 워드 프로세서에서 굵은 체 도구 모음 단추는 켜져 있거나 꺼져있을 수 있습니다. 토글 조치가 아닌 조치는 명령 조치입니다. 파일 저장과 같은 명령 동작이 간단하게 실행됩니다. 기본적으로이 속성은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5d321928e909f7a3b523aecf0849a50eaa9c249c" translate="yes" xml:space="preserve">
          <source>A checkable action toggles between checked (on) and unchecked (off) when triggered.</source>
          <target state="translated">점검 가능한 조치는 트리거 될 때 점검 (켜기)과 점검 (해제) 사이를 전환합니다.</target>
        </trans-unit>
        <trans-unit id="4897475d78fa7ddfa214578a1302ba3109e6f369" translate="yes" xml:space="preserve">
          <source>A checkable button that triggers an action when held in long enough</source>
          <target state="translated">충분히 길게 잡고있을 때 액션을 트리거하는 확인 가능한 버튼</target>
        </trans-unit>
        <trans-unit id="38f046c948ec63912abc7d0345d72e333fdc80f6" translate="yes" xml:space="preserve">
          <source>A checkable button that triggers an action when held in long enough. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">오랫동안 누르고 있으면 액션을 트리거하는 확인 가능한 버튼입니다. &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f9fd85822e662247fe1d67747df03be6d14b9c41" translate="yes" xml:space="preserve">
          <source>A checkable button toggles between checked (on) and unchecked (off) when the user clicks on it or presses the space bar while the button has active focus.</source>
          <target state="translated">확인 가능 버튼은 사용자가 버튼을 클릭하거나 스페이스 바를 누를 때 버튼이 활성화 된 상태에서 선택 (켜기)과 선택되지 않은 (끄기) 사이를 전환합니다.</target>
        </trans-unit>
        <trans-unit id="ac249a5c8641bdf7ac99bb5378e34bb1f08ef293" translate="yes" xml:space="preserve">
          <source>A checkable menu item has an on/off state. For example, in a word processor, a &quot;Bold&quot; menu item may be either on or off. A menu item that is not checkable is a command item that is simply executed, e.g. file save.</source>
          <target state="translated">확인 가능한 메뉴 항목은 켜짐 / 꺼짐 상태입니다. 예를 들어, 워드 프로세서에서 &quot;굵게&quot;메뉴 항목이 켜져 있거나 꺼져있을 수 있습니다. 확인할 수없는 메뉴 항목은 파일 저장과 같이 간단하게 실행되는 명령 항목입니다.</target>
        </trans-unit>
        <trans-unit id="bd80ea84342561d19669d0066b0ec589c01054a3" translate="yes" xml:space="preserve">
          <source>A checkbox may be in a partially checked state when the regular checked state can not be determined.</source>
          <target state="translated">정기 점검 상태를 판별 할 수없는 경우 선택란이 부분 점검 상태 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="06b2d936364b3b07aa4c1d1eb6dc0625f2218fad" translate="yes" xml:space="preserve">
          <source>A checkbox with a text label</source>
          <target state="translated">텍스트 레이블이있는 확인란</target>
        </trans-unit>
        <trans-unit id="8be560b2187c63e123b3adfe80a77edd19b705a1" translate="yes" xml:space="preserve">
          <source>A checkbox with a text label. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">텍스트 레이블이있는 확인란. &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c692d27f3e2938ae92e34873782d260655a99426" translate="yes" xml:space="preserve">
          <source>A checked &lt;a href=&quot;qml-qtquick-extras-togglebutton&quot;&gt;ToggleButton&lt;/a&gt;.</source>
          <target state="translated">확인 된 &lt;a href=&quot;qml-qtquick-extras-togglebutton&quot;&gt;ToggleButton&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="10f2b50e7d680cddc8604fcb9f255bbcf6174e36" translate="yes" xml:space="preserve">
          <source>A checked ToggleButton.</source>
          <target state="translated">체크 된 ToggleButton.</target>
        </trans-unit>
        <trans-unit id="26a975206cbeb7b8ddfb2a709a56672115751c3e" translate="yes" xml:space="preserve">
          <source>A child is added to this item. The value argument is the new child item (i.e., a &lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt; pointer). Do not pass this item to any item's &lt;a href=&quot;qgraphicsitem#setParentItem&quot;&gt;setParentItem&lt;/a&gt;() function as this notification is delivered. The return value is unused; you cannot adjust anything in this notification. Note that the new child might not be fully constructed when this notification is sent; calling pure virtual functions on the child can lead to a crash.</source>
          <target state="translated">자녀가이 항목에 추가됩니다. value 인수는 새로운 자식 항목입니다 (예 : &lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt; 포인터). 이 알림이 전달 될 때이 항목을 항목의 &lt;a href=&quot;qgraphicsitem#setParentItem&quot;&gt;setParentItem&lt;/a&gt; () 함수에 전달하지 마십시오 . 반환 값은 사용되지 않습니다. 이 알림에서 아무것도 조정할 수 없습니다. 이 알림이 전송 될 때 새 자식이 완전히 구성되지 않을 수 있습니다. 자식에서 순수한 가상 함수를 호출하면 충돌이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4422932c3807d2763240d7cbfc1ab4084d18510" translate="yes" xml:space="preserve">
          <source>A child is removed from this item. The value argument is the child item that is about to be removed (i.e., a &lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt; pointer). The return value is unused; you cannot adjust anything in this notification.</source>
          <target state="translated">이 항목에서 자녀가 제거되었습니다. value 인수는 제거 될 자식 항목입니다 (예 : &lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt; 포인터). 반환 값은 사용되지 않습니다. 이 알림에서 아무것도 조정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b0a45cc581adcc3dd71f17a696eb9308c6078802" translate="yes" xml:space="preserve">
          <source>A child state can be final (a &lt;a href=&quot;qfinalstate&quot;&gt;QFinalState&lt;/a&gt; object); when a final child state is entered, the parent state emits the &lt;a href=&quot;qstate#finished&quot;&gt;QState::finished&lt;/a&gt;() signal. The following diagram shows a composite state &lt;code&gt;s1&lt;/code&gt; which does some processing before entering a final state:</source>
          <target state="translated">자식 상태는 최종일 수 있습니다 ( &lt;a href=&quot;qfinalstate&quot;&gt;QFinalState&lt;/a&gt; 객체). 최종 자식 상태가 입력되면 부모 상태는 &lt;a href=&quot;qstate#finished&quot;&gt;QState :: finished&lt;/a&gt; () 신호를 방출합니다 . 다음 다이어그램은 최종 상태로 들어가기 전에 일부 처리를 수행 하는 복합 상태 &lt;code&gt;s1&lt;/code&gt; 을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="7cceb832fe4aba21d006559052f76fc13613c52f" translate="yes" xml:space="preserve">
          <source>A child state can be final (a &lt;a href=&quot;qml-qtqml-statemachine-finalstate&quot;&gt;FinalState&lt;/a&gt; object); when a final child state is entered, the parent state emits the &lt;a href=&quot;qml-qtqml-statemachine-state#finished-signal&quot;&gt;State::finished&lt;/a&gt; signal. The following diagram shows a composite state &lt;code&gt;s1&lt;/code&gt; which does some processing before entering a final state:</source>
          <target state="translated">자식 상태는 final ( &lt;a href=&quot;qml-qtqml-statemachine-finalstate&quot;&gt;FinalState&lt;/a&gt; 개체) 일 수 있습니다 . 최종 자식 상태가 입력되면 부모 상태는 &lt;a href=&quot;qml-qtqml-statemachine-state#finished-signal&quot;&gt;State :: finished&lt;/a&gt; 신호를 내 보냅니다. 다음 다이어그램은 최종 상태로 들어가기 전에 일부 처리를 수행 하는 복합 상태 &lt;code&gt;s1&lt;/code&gt; 을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="2f0d51606fcfe264c55def86057706496107a953" translate="yes" xml:space="preserve">
          <source>A child state can override an inherited transition. For example, the following code adds a transition that effectively causes the Quit button to be ignored when the state machine is in state &lt;code&gt;s12&lt;/code&gt;.</source>
          <target state="translated">자식 상태는 상속 된 전환을 재정의 할 수 있습니다. 예를 들어, 다음 코드는 상태 머신이 상태 &lt;code&gt;s12&lt;/code&gt; 에있을 때 종료 버튼을 효과적으로 무시하는 전환을 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="fb5f921ccea69491a39f7f68bfac75e60be6cbb9" translate="yes" xml:space="preserve">
          <source>A child state can override an inherited transition. For example, the following code adds a transition that effectively causes the Quit button to be ignored when the state machine is in state, &lt;code&gt;s12&lt;/code&gt;.</source>
          <target state="translated">자식 상태는 상속 된 전환을 재정의 할 수 있습니다. 예를 들어, 다음 코드는 상태 머신이 &lt;code&gt;s12&lt;/code&gt; 상태 일 때 종료 버튼을 효과적으로 무시하도록하는 전환을 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="1a3178e84d5a23a9d268577cb20ab73683f1bcc1" translate="yes" xml:space="preserve">
          <source>A child was added. &lt;a href=&quot;qquickitem-itemchangedata#item-var&quot;&gt;ItemChangeData::item&lt;/a&gt; contains the added child.</source>
          <target state="translated">아이가 추가되었습니다. &lt;a href=&quot;qquickitem-itemchangedata#item-var&quot;&gt;ItemChangeData :: item&lt;/a&gt; 에는 추가 된 자식이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="f84ba19d98bd6549531c85e6c6da9842b569e529" translate="yes" xml:space="preserve">
          <source>A child was removed. &lt;a href=&quot;qquickitem-itemchangedata#item-var&quot;&gt;ItemChangeData::item&lt;/a&gt; contains the removed child.</source>
          <target state="translated">아이가 제거되었습니다. &lt;a href=&quot;qquickitem-itemchangedata#item-var&quot;&gt;ItemChangeData :: item&lt;/a&gt; 에는 제거 된 자식이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="ee4c5a170aa4b05a9d3035c018b357f2c5bbecba" translate="yes" xml:space="preserve">
          <source>A child widget has been hidden.</source>
          <target state="translated">하위 위젯이 숨겨졌습니다.</target>
        </trans-unit>
        <trans-unit id="76a6200d9ad865158136f4a74ccb61dbb2cbd56b" translate="yes" xml:space="preserve">
          <source>A child widget has been shown.</source>
          <target state="translated">하위 위젯이 표시되었습니다.</target>
        </trans-unit>
        <trans-unit id="8b2698ad98b7e8cc368850e0b0b0793161191925" translate="yes" xml:space="preserve">
          <source>A chromatic aberration effect. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">색수차 효과. &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ad6c6776e0f78101707e6af1d802cd0eb611baf8" translate="yes" xml:space="preserve">
          <source>A circular arc between the two lines is filled.</source>
          <target state="translated">두 선 사이의 원호가 채워집니다.</target>
        </trans-unit>
        <trans-unit id="a2f6596e501bfdc7410e4968e10af755ef273d03" translate="yes" xml:space="preserve">
          <source>A circular dial that is rotated to set a value</source>
          <target state="translated">값을 설정하기 위해 회전하는 원형 다이얼</target>
        </trans-unit>
        <trans-unit id="62fd5640ed5b85f62d73f5724040b4057f94ad60" translate="yes" xml:space="preserve">
          <source>A circular dial that is rotated to set a value. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">값을 설정하기 위해 회전하는 원형 다이얼. &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9ebbc80cbfd3364df8d8b26b91f64fc7e29f5ded" translate="yes" xml:space="preserve">
          <source>A circular shape</source>
          <target state="translated">원형</target>
        </trans-unit>
        <trans-unit id="1145ad09acaab40b2ef5801fd9879dd380ae655a" translate="yes" xml:space="preserve">
          <source>A clamshell handheld computer or PDA.</source>
          <target state="translated">클램 쉘 핸드 헬드 컴퓨터 또는 PDA.</target>
        </trans-unit>
        <trans-unit id="c40d78bbf9369b63c1bc7d03705d6a04571557c0" translate="yes" xml:space="preserve">
          <source>A clark name is a way to present a full QName with only one string, where the namespace cannot contain braces. Here are a couple of examples:</source>
          <target state="translated">clark 이름은 네임 스페이스에 중괄호를 포함 할 수없는 하나의 문자열로 전체 QName을 표시하는 방법입니다. 다음은 몇 가지 예입니다.</target>
        </trans-unit>
        <trans-unit id="0a9db2c007fbe6f140b506973cd84f4f35664e51" translate="yes" xml:space="preserve">
          <source>A class declaring properties must be a &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;. To make it possible to animate a property, it must provide a setter (so that &lt;a href=&quot;qpropertyanimation&quot;&gt;QPropertyAnimation&lt;/a&gt; can set the property's value). Note that this makes it possible to animate many of Qt's widgets. Let's look at an example:</source>
          <target state="translated">속성을 선언하는 클래스는 &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 여야합니다 . 속성에 애니메이션을 적용하려면 setter를 제공해야합니다 ( &lt;a href=&quot;qpropertyanimation&quot;&gt;QPropertyAnimation&lt;/a&gt; 이 속성 값을 설정할 수 있도록 ). 이를 통해 많은 Qt 위젯을 애니메이션 할 수 있습니다. 예를 보자.</target>
        </trans-unit>
        <trans-unit id="b594907465a2c108d76d1d70ee3482d62b7a3ebe" translate="yes" xml:space="preserve">
          <source>A class declaring properties must be a &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;. To make it possible to animate a property, it must provide a setter (so that QPropertyAnimation can set the property's value). Note that this makes it possible to animate many of Qt's widgets. Let's look at an example:</source>
          <target state="translated">속성을 선언하는 클래스는 &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 여야합니다 . 속성에 애니메이션을 적용하려면 setter를 제공해야합니다 (QPropertyAnimation에서 속성 값을 설정할 수 있음). 이렇게하면 많은 Qt 위젯에 애니메이션을 적용 할 수 있습니다. 예를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="28fb83c180669a6b010f108815f630d84cad1678" translate="yes" xml:space="preserve">
          <source>A class encapsulating a Cocoa NSOpenGLContext. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">Cocoa NSOpenGLContext를 캡슐화하는 클래스. &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="106e429f4511ca1db8c867851b703a78d15bc359" translate="yes" xml:space="preserve">
          <source>A class encapsulating a WGL context on Windows with desktop OpenGL (opengl32.dll). &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">데스크탑 OpenGL (opengl32.dll)을 사용하여 Windows에서 WGL 컨텍스트를 캡슐화하는 클래스입니다. &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4184e168d12383dc1be66ac69870b8aadbf04c1c" translate="yes" xml:space="preserve">
          <source>A class encapsulating an EGL context and display handle. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">EGL 컨텍스트 및 표시 핸들을 캡슐화하는 클래스입니다. &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c680e9945128bdf78968a6001e540153f582a09d" translate="yes" xml:space="preserve">
          <source>A class for applying a &lt;a href=&quot;qfileselector&quot;&gt;QFileSelector&lt;/a&gt; to QML file loading. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;qfileselector&quot;&gt;QFileSelector&lt;/a&gt; 를 QML 파일 로딩 에 적용하기위한 클래스 . &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="71e7aa0bff88916f9aa1eb03d1155f83996187b4" translate="yes" xml:space="preserve">
          <source>A class grouping animations together</source>
          <target state="translated">애니메이션을 그룹화하는 클래스</target>
        </trans-unit>
        <trans-unit id="e11d6e6c622acadd050ef71f5b49a1a70b980ac2" translate="yes" xml:space="preserve">
          <source>A class grouping animations together. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">애니메이션을 그룹화하는 클래스입니다. &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="171d030e86e903757ba67dedaafadc4df0401eca" translate="yes" xml:space="preserve">
          <source>A class grouping animations together. &lt;a href=&quot;qt3danimation-qanimationgroup#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">애니메이션을 그룹화하는 클래스입니다. &lt;a href=&quot;qt3danimation-qanimationgroup#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4c36bcc860febf6c2300f686373662ab02bb364f" translate="yes" xml:space="preserve">
          <source>A class holding information about &lt;a href=&quot;qtremoteobjects-source#source&quot;&gt;Source&lt;/a&gt; objects available on the Qt Remote Objects network. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">Qt 원격 객체 네트워크에서 사용 가능한 &lt;a href=&quot;qtremoteobjects-source#source&quot;&gt;소스&lt;/a&gt; 객체 에 대한 정보를 보유하는 클래스 입니다. &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5c81c287d7291dd68fc112bc07579d1818b1e17f" translate="yes" xml:space="preserve">
          <source>A class implementing &lt;a href=&quot;qwidget#inputMethodEvent&quot;&gt;QWidget::inputMethodEvent&lt;/a&gt;() or &lt;a href=&quot;qgraphicsitem#inputMethodEvent&quot;&gt;QGraphicsItem::inputMethodEvent&lt;/a&gt;() should at least understand and honor the &lt;a href=&quot;qinputmethodevent#AttributeType-enum&quot;&gt;TextFormat&lt;/a&gt; and &lt;a href=&quot;qinputmethodevent#AttributeType-enum&quot;&gt;Cursor&lt;/a&gt; attributes.</source>
          <target state="translated">&lt;a href=&quot;qwidget#inputMethodEvent&quot;&gt;QWidget :: inputMethodEvent&lt;/a&gt; () 또는 &lt;a href=&quot;qgraphicsitem#inputMethodEvent&quot;&gt;QGraphicsItem :: inputMethodEvent&lt;/a&gt; ()를 구현하는 클래스 는 최소한 &lt;a href=&quot;qinputmethodevent#AttributeType-enum&quot;&gt;TextFormat&lt;/a&gt; 및 &lt;a href=&quot;qinputmethodevent#AttributeType-enum&quot;&gt;Cursor&lt;/a&gt; 속성을 이해하고 존중해야 합니다.</target>
        </trans-unit>
        <trans-unit id="1712c915336e5aa3cab00128c357cd5724f37472" translate="yes" xml:space="preserve">
          <source>A class implementing a text object needs to inherit both &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; and &lt;a href=&quot;qtextobjectinterface&quot;&gt;QTextObjectInterface&lt;/a&gt;. &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; must be the first class inherited. For instance:</source>
          <target state="translated">텍스트 객체를 구현하는 클래스는 &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 와 &lt;a href=&quot;qtextobjectinterface&quot;&gt;QTextObjectInterface를&lt;/a&gt; 모두 상속해야합니다 . &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 는 상속 된 첫 번째 클래스 여야합니다. 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="cdb01c023be57dd911931229107bc21cb264d55b" translate="yes" xml:space="preserve">
          <source>A class implementing a text object needs to inherit both &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; and QTextObjectInterface. &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; must be the first class inherited. For instance:</source>
          <target state="translated">텍스트 객체를 구현하는 클래스는 &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 와 QTextObjectInterface를 모두 상속해야합니다 . &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 는 상속 된 첫 번째 클래스 여야합니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="9b49c83d20dc44d2157e4bb585a1a62d5725fc42" translate="yes" xml:space="preserve">
          <source>A class implementing blend-shape morphing animation</source>
          <target state="translated">블렌드 셰이프 모핑 애니메이션을 구현하는 클래스</target>
        </trans-unit>
        <trans-unit id="4e49b21227d8bff1c63039b3d4ded77fa097f341" translate="yes" xml:space="preserve">
          <source>A class implementing blend-shape morphing animation. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">블렌드 셰이프 모핑 애니메이션을 구현하는 클래스입니다. &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c416248ff5e66b372e5fbc0dd5f7e03421b00099" translate="yes" xml:space="preserve">
          <source>A class implementing blend-shape morphing animation. &lt;a href=&quot;qt3danimation-qmorphinganimation#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">블렌드 셰이프 모핑 애니메이션을 구현하는 클래스입니다. &lt;a href=&quot;qt3danimation-qmorphinganimation#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="252fe3b5fd75630d6db07e0b0ebc8badad33966e" translate="yes" xml:space="preserve">
          <source>A class implementing simple keyframe animation to a &lt;a href=&quot;qtransform&quot;&gt;QTransform&lt;/a&gt;. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;qtransform&quot;&gt;QTransform에&lt;/a&gt; 간단한 키 프레임 애니메이션을 구현하는 클래스 입니다. &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8fe9bcca8de505102cd5342900eb62556774a53b" translate="yes" xml:space="preserve">
          <source>A class implementing simple keyframe animation to a &lt;a href=&quot;qtransform&quot;&gt;QTransform&lt;/a&gt;. &lt;a href=&quot;qt3danimation-qkeyframeanimation#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;qtransform&quot;&gt;QTransform에&lt;/a&gt; 간단한 키 프레임 애니메이션을 구현하는 클래스 입니다. &lt;a href=&quot;qt3danimation-qkeyframeanimation#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="82c114c3718f9bf018683121e868e11405da16f2" translate="yes" xml:space="preserve">
          <source>A class implementing simple keyframe animation to a QTransform</source>
          <target state="translated">QTransform에 간단한 키 프레임 애니메이션을 구현하는 클래스</target>
        </trans-unit>
        <trans-unit id="e6f3cfd2e9e48fe145f37769e7f7c0460b67a7b9" translate="yes" xml:space="preserve">
          <source>A class implementing vertex-blend morphing animation</source>
          <target state="translated">버텍스 블렌드 모핑 애니메이션을 구현하는 클래스</target>
        </trans-unit>
        <trans-unit id="ae4dbe25b45b10eac6f8e1c6f45183d9993ff414" translate="yes" xml:space="preserve">
          <source>A class implementing vertex-blend morphing animation. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">버텍스 블렌드 모핑 애니메이션을 구현하는 클래스입니다. &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7392bba63cd02134a0b62e3673cd310ca945b22c" translate="yes" xml:space="preserve">
          <source>A class implementing vertex-blend morphing animation. &lt;a href=&quot;qt3danimation-qvertexblendanimation#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">버텍스 블렌드 모핑 애니메이션을 구현하는 클래스입니다. &lt;a href=&quot;qt3danimation-qvertexblendanimation#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="00a8c084b6b421f18308857756d942ac4b8c9ebf" translate="yes" xml:space="preserve">
          <source>A class interacting with (but not implementing) a Qt API on the Remote Object network. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">원격 객체 네트워크에서 Qt API와 상호 작용하지만 구현하지는 않는 클래스입니다. &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="afd86f542bfb0450a872caf9d5bf35956f2f0611" translate="yes" xml:space="preserve">
          <source>A class is considered to inherit itself.</source>
          <target state="translated">클래스는 자신을 상속하는 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="80766e3b7e27abeb670c7d9dcc39ac8e45372059" translate="yes" xml:space="preserve">
          <source>A class or overview may belong to many groups.</source>
          <target state="translated">수업 또는 개요는 여러 그룹에 속할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b413e1263094bdb03d8fc07677d63b529459216b" translate="yes" xml:space="preserve">
          <source>A class providing morph targets to blend-shape animation</source>
          <target state="translated">애니메이션을 블렌드하기 위해 모프 타겟을 제공하는 클래스</target>
        </trans-unit>
        <trans-unit id="457caf6079e4b1f7f537d65b667f6ca87bd91065" translate="yes" xml:space="preserve">
          <source>A class providing morph targets to blend-shape animation. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">애니메이션을 블렌드하기 위해 모프 타겟을 제공하는 클래스입니다. &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d71dd4128f60959aff7b9c6db00f4c60ed1834ec" translate="yes" xml:space="preserve">
          <source>A class providing morph targets to blend-shape animation. &lt;a href=&quot;qt3danimation-qmorphtarget#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">애니메이션을 블렌드하기 위해 모프 타겟을 제공하는 클래스입니다. &lt;a href=&quot;qt3danimation-qmorphtarget#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="182389300a5a486612fc1f858612409d65168f18" translate="yes" xml:space="preserve">
          <source>A class that holds information about client backends available on the Qt Remote Objects network. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">Qt Remote Objects 네트워크에서 사용 가능한 클라이언트 백엔드에 대한 정보를 보유하는 클래스입니다. &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="551a40d9fd4bae0dca4db4bd1c1c9d0855889866" translate="yes" xml:space="preserve">
          <source>A class that holds information about server backends available on the Qt Remote Objects network. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">Qt Remote Objects 네트워크에서 사용 가능한 서버 백엔드에 대한 정보를 보유하는 클래스입니다. &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="63a267eb9d3afd8b317a55e5140bcec17efdd746" translate="yes" xml:space="preserve">
          <source>A class which provides the methods for setting PROP values of a replica to value they had the last time the replica was used. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">복제본의 PROP 값을 마지막으로 사용한 시간 값으로 설정하는 방법을 제공하는 클래스입니다. &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8f3ba622140922fc46d3758f3eaad0c4ea5ee6e0" translate="yes" xml:space="preserve">
          <source>A client must attempt to contact the target host with the lowest-numbered priority.</source>
          <target state="translated">클라이언트는 우선 순위가 가장 낮은 대상 호스트에 접속을 시도해야합니다.</target>
        </trans-unit>
        <trans-unit id="2da448b3b1ed8d770e441f62711f3265a6336bb6" translate="yes" xml:space="preserve">
          <source>A clock displaying time.</source>
          <target state="translated">시간을 표시하는 시계.</target>
        </trans-unit>
        <trans-unit id="1c51cb943e3767e2177a01475e798aa1bd8d1724" translate="yes" xml:space="preserve">
          <source>A colon separating keys from values inside objects is missing</source>
          <target state="translated">객체 내부의 값에서 키를 분리하는 콜론이 누락되었습니다.</target>
        </trans-unit>
        <trans-unit id="bad5166a172a381bc38068ac4162c7c0800fb119" translate="yes" xml:space="preserve">
          <source>A color adjustment effect. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">색상 조정 효과. &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="15fbfe8bf1257f945078913fd63ee7bcb8c6b174" translate="yes" xml:space="preserve">
          <source>A color can be set by passing an RGB string (such as &quot;#112233&quot;), or an ARGB string (such as &quot;#ff112233&quot;) or a color name (such as &quot;blue&quot;), to the &lt;a href=&quot;qcolor#setNamedColor&quot;&gt;setNamedColor&lt;/a&gt;() function. The color names are taken from the SVG 1.0 color names. The &lt;a href=&quot;qcolor#name&quot;&gt;name&lt;/a&gt;() function returns the name of the color in the format &quot;#RRGGBB&quot;. Colors can also be set using &lt;a href=&quot;qcolor#setRgb&quot;&gt;setRgb&lt;/a&gt;(), &lt;a href=&quot;qcolor#setHsv&quot;&gt;setHsv&lt;/a&gt;() and &lt;a href=&quot;qcolor#setCmyk&quot;&gt;setCmyk&lt;/a&gt;(). To get a lighter or darker color use the &lt;a href=&quot;qcolor#lighter&quot;&gt;lighter&lt;/a&gt;() and &lt;a href=&quot;qcolor#darker&quot;&gt;darker&lt;/a&gt;() functions respectively.</source>
          <target state="translated">RGB 문자열 (예 : &quot;# 112233&quot;) 또는 ARGB 문자열 (예 : &quot;# ff112233&quot;) 또는 색상 이름 (예 : &quot;blue&quot;)을 &lt;a href=&quot;qcolor#setNamedColor&quot;&gt;setNamedColor&lt;/a&gt; () 함수 에 전달하여 색상을 설정할 수 있습니다 . 색상 이름은 SVG 1.0 색상 이름에서 가져옵니다. &lt;a href=&quot;qcolor#name&quot;&gt;이름&lt;/a&gt; () 함수는 형식 &quot;#RRGGBB&quot;의 색상의 이름을 반환합니다. &lt;a href=&quot;qcolor#setRgb&quot;&gt;setRgb&lt;/a&gt; (), &lt;a href=&quot;qcolor#setHsv&quot;&gt;setHsv&lt;/a&gt; () 및 &lt;a href=&quot;qcolor#setCmyk&quot;&gt;setCmyk&lt;/a&gt; ()를 사용하여 색상을 설정할 수도 있습니다 . 더 밝거나 어두운 색상을 얻으려면 각각 &lt;a href=&quot;qcolor#darker&quot;&gt;더 &lt;/a&gt;&lt;a href=&quot;qcolor#lighter&quot;&gt;밝게&lt;/a&gt; () 및 더 어둡게 () 기능을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="f5ad0c4310ca592338efc0b5a9289116e599f268" translate="yes" xml:space="preserve">
          <source>A color is normally specified in terms of RGB (red, green, and blue) components, but it is also possible to specify it in terms of HSV (hue, saturation, and value) and CMYK (cyan, magenta, yellow and black) components. In addition a color can be specified using a color name. The color name can be any of the SVG 1.0 color names.</source>
          <target state="translated">색상은 일반적으로 RGB (빨간색, 녹색 및 파란색) 구성 요소로 지정되지만 HSV (색조, 채도 및 값) 및 CMYK (청록색, 자홍색, 노랑색 및 검은 색)로 지정할 수도 있습니다. 구성 요소. 또한 색상 이름을 사용하여 색상을 지정할 수 있습니다. 색상 이름은 SVG 1.0 색상 이름 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6bc085c876648a5a23a75923f655a8700afbcc58" translate="yes" xml:space="preserve">
          <source>A color space can generally speaking be conceived as a combination of set of primary colors and a transfer function. The primaries defines the axes of the color space, and the transfer function how values are mapped on the axes. The primaries are defined by three primary colors that represent exactly how red, green, and blue look in this particular color space, and a white color that represents where and how bright pure white is. The range of colors expressable by the primary colors is called the gamut, and a color space that can represent a wider range of colors is also known as a wide-gamut color space.</source>
          <target state="translated">색상 공간은 일반적으로 기본 색상 세트와 전달 함수의 조합으로 생각할 수 있습니다. 원색은 색 공간의 축과 값이 축에 매핑되는 전달 함수를 정의합니다. 원색은이 특정 색 공간에서 빨간색, 녹색 및 파란색이 어떻게 보이는지 정확히 나타내는 세 가지 기본 색상과 순수한 흰색이 어디에서 얼마나 밝은지를 나타내는 흰색으로 정의됩니다. 원색으로 표현할 수있는 색의 범위를 색역이라고하고, 더 넓은 범위의 색을 표현할 수있는 색 공간을 광역 색 공간이라고도합니다.</target>
        </trans-unit>
        <trans-unit id="ef6b395db2eedf58dee91744269625807c1c40d5" translate="yes" xml:space="preserve">
          <source>A color to indicate a selected item or the current item.</source>
          <target state="translated">선택한 항목 또는 현재 항목을 나타내는 색입니다.</target>
        </trans-unit>
        <trans-unit id="41d6a2c390fb307088d19fa185c444cb4599ce5e" translate="yes" xml:space="preserve">
          <source>A color to indicate a selected item or the current item. By default, the highlight color is &lt;a href=&quot;qt#GlobalColor-enum&quot;&gt;Qt::darkBlue&lt;/a&gt;.</source>
          <target state="translated">선택한 항목 또는 현재 항목을 나타내는 색입니다. 기본적으로 강조 색상은 &lt;a href=&quot;qt#GlobalColor-enum&quot;&gt;Qt :: darkBlue&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d6df669bd06253e7b37d26d3ce8b21ae17d2d536" translate="yes" xml:space="preserve">
          <source>A color type has &lt;code&gt;r&lt;/code&gt;, &lt;code&gt;g&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; properties that refer to the red, green, blue and alpha values of the color, respectively. Additionally it has &lt;code&gt;hsvHue&lt;/code&gt;, &lt;code&gt;hsvSaturation&lt;/code&gt;, &lt;code&gt;hsvValue&lt;/code&gt; and &lt;code&gt;hslHue&lt;/code&gt;, &lt;code&gt;hslSaturation&lt;/code&gt;, &lt;code&gt;hslLightness&lt;/code&gt; properties, which allow access to color values in HSV and HSL color models accordingly:</source>
          <target state="translated">색상 유형에는 &lt;code&gt;r&lt;/code&gt; , &lt;code&gt;g&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; 및 색상 의 빨강, 녹색, 파랑 및 알파 값을 각각 &lt;code&gt;a&lt;/code&gt; 속성이 있습니다. 또한 &lt;code&gt;hsvHue&lt;/code&gt; , &lt;code&gt;hsvSaturation&lt;/code&gt; , &lt;code&gt;hsvValue&lt;/code&gt; 및 &lt;code&gt;hslHue&lt;/code&gt; , &lt;code&gt;hslSaturation&lt;/code&gt; , &lt;code&gt;hslLightness&lt;/code&gt; 속성이있어 HSV 및 HSL 색상 모델의 색상 값에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="21f0e6b939fdc55ee515d15cb29db3946c108d77" translate="yes" xml:space="preserve">
          <source>A color-space using the primaries of DCI-P3, but with the whitepoint and transfer function of sRGB. Common in modern wide-gamut screens. &lt;a href=&quot;http://www.color.org/chardata/rgb/DCIP3.xalter&quot;&gt;ICC registration of DCI-P3&lt;/a&gt;</source>
          <target state="translated">DCI-P3의 원색을 사용하지만 sRGB의 화이트 포인트 및 전달 함수를 사용하는 색 공간입니다. 현대의 광역 화면에서 일반적입니다. &lt;a href=&quot;http://www.color.org/chardata/rgb/DCIP3.xalter&quot;&gt;DCI-P3 ICC 등록&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="acbd29f7e97306c785659e9a53cdf7aafa4adae7" translate="yes" xml:space="preserve">
          <source>A colorize effect renders the source with a tint of its &lt;a href=&quot;qgraphicscolorizeeffect#color-prop&quot;&gt;color&lt;/a&gt;(). The color can be modified using the &lt;a href=&quot;qgraphicscolorizeeffect#color-prop&quot;&gt;setColor&lt;/a&gt;() function.</source>
          <target state="translated">색상 화 효과는 그것의 색조 소스를 렌더링 &lt;a href=&quot;qgraphicscolorizeeffect#color-prop&quot;&gt;색&lt;/a&gt; (). &lt;a href=&quot;qgraphicscolorizeeffect#color-prop&quot;&gt;setColor&lt;/a&gt; () 함수를 사용하여 색상을 수정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ed86029bf2cd8b7da0bfe8ec238c9a06dc40cae7" translate="yes" xml:space="preserve">
          <source>A column of cells, usually within a table.</source>
          <target state="translated">일반적으로 테이블 내의 셀 열입니다.</target>
        </trans-unit>
        <trans-unit id="b6fbe42b297bb3f991da572b5d731017729445e6" translate="yes" xml:space="preserve">
          <source>A column of week numbers</source>
          <target state="translated">주 번호 열</target>
        </trans-unit>
        <trans-unit id="ec9c74b17b97e312e218c95a7acc61c77c957de4" translate="yes" xml:space="preserve">
          <source>A column of week numbers. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">주 번호 열. &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3e9d96834fc8d23965b6cb0bdbdbd51107410e03" translate="yes" xml:space="preserve">
          <source>A column within a tumbler</source>
          <target state="translated">텀블러 내의 열</target>
        </trans-unit>
        <trans-unit id="44d51517d064d11c668abc9ec2baefca0b061b4e" translate="yes" xml:space="preserve">
          <source>A column within a tumbler. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">텀블러 내의 열입니다. &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="74c110bc0121608496b4cf6f5cf8e098b6f02718" translate="yes" xml:space="preserve">
          <source>A combination of &lt;a href=&quot;qabstract3dgraph#SelectionFlag-enum&quot;&gt;SelectionFlags&lt;/a&gt;. By default, &lt;code&gt;SelectionItem&lt;/code&gt;. Different graph types support different selection modes.</source>
          <target state="translated">&lt;a href=&quot;qabstract3dgraph#SelectionFlag-enum&quot;&gt;SelectionFlags&lt;/a&gt; 의 조합입니다 . 기본적으로 &lt;code&gt;SelectionItem&lt;/code&gt; 입니다. 다른 그래프 유형은 다른 선택 모드를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="4cad76bcac1975a42227279e2510846581837a45" translate="yes" xml:space="preserve">
          <source>A combination of Clear and Select, provided for convenience.</source>
          <target state="translated">편의를 위해 Clear와 Select의 조합.</target>
        </trans-unit>
        <trans-unit id="2325ea5c128499eb2f69533a76c1a61f69ed195c" translate="yes" xml:space="preserve">
          <source>A combination of Select and Current, provided for convenience.</source>
          <target state="translated">편의를 위해 Select와 Current의 조합.</target>
        </trans-unit>
        <trans-unit id="340888b1701873ef30dcb69749168c701dc1a76c" translate="yes" xml:space="preserve">
          <source>A combination of Toggle and Current, provided for convenience.</source>
          <target state="translated">편의를 위해 제공되는 토글과 전류의 조합.</target>
        </trans-unit>
        <trans-unit id="33c493b159aa45c70dcef39b4b224fe38a531e53" translate="yes" xml:space="preserve">
          <source>A combo box, like &lt;a href=&quot;qcombobox&quot;&gt;QComboBox&lt;/a&gt;.</source>
          <target state="translated">같은 콤보 상자, &lt;a href=&quot;qcombobox&quot;&gt;QComboBox&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a1d4dd594d03fdd06424451f9a547f002d36a413" translate="yes" xml:space="preserve">
          <source>A combo box, like &lt;a href=&quot;widgets-changes-qt6#qcombobox&quot;&gt;QComboBox&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;widgets-changes-qt6#qcombobox&quot;&gt;QComboBox&lt;/a&gt; 와 같은 콤보 상자 .</target>
        </trans-unit>
        <trans-unit id="e822f091e202c0f34473a5fff40f5a341c2fd17b" translate="yes" xml:space="preserve">
          <source>A combobox can be populated using the insert functions, &lt;a href=&quot;qcombobox#insertItem&quot;&gt;insertItem&lt;/a&gt;() and &lt;a href=&quot;qcombobox#insertItems&quot;&gt;insertItems&lt;/a&gt;() for example. Items can be changed with &lt;a href=&quot;qcombobox#setItemText&quot;&gt;setItemText&lt;/a&gt;(). An item can be removed with &lt;a href=&quot;qcombobox#removeItem&quot;&gt;removeItem&lt;/a&gt;() and all items can be removed with &lt;a href=&quot;qcombobox#clear&quot;&gt;clear&lt;/a&gt;(). The text of the current item is returned by &lt;a href=&quot;qcombobox#currentText-prop&quot;&gt;currentText&lt;/a&gt;(), and the text of a numbered item is returned with text(). The current item can be set with &lt;a href=&quot;qcombobox#currentIndex-prop&quot;&gt;setCurrentIndex&lt;/a&gt;(). The number of items in the combobox is returned by &lt;a href=&quot;qcombobox#count-prop&quot;&gt;count&lt;/a&gt;(); the maximum number of items can be set with &lt;a href=&quot;qcombobox#maxCount-prop&quot;&gt;setMaxCount&lt;/a&gt;(). You can allow editing using &lt;a href=&quot;qcombobox#editable-prop&quot;&gt;setEditable&lt;/a&gt;(). For editable comboboxes you can set auto-completion using &lt;a href=&quot;qcombobox#setCompleter&quot;&gt;setCompleter&lt;/a&gt;() and whether or not the user can add duplicates is set with &lt;a href=&quot;qcombobox#duplicatesEnabled-prop&quot;&gt;setDuplicatesEnabled&lt;/a&gt;().</source>
          <target state="translated">삽입 함수 &lt;a href=&quot;qcombobox#insertItem&quot;&gt;insertItem&lt;/a&gt; () 및 &lt;a href=&quot;qcombobox#insertItems&quot;&gt;insertItems&lt;/a&gt; ()를 사용하여 콤보 박스를 채울 수 있습니다 . &lt;a href=&quot;qcombobox#setItemText&quot;&gt;setItemText&lt;/a&gt; () 로 항목을 변경할 수 있습니다 . 아이템은 제거 할 수 &lt;a href=&quot;qcombobox#removeItem&quot;&gt;removeItem&lt;/a&gt; () 모든 항목을 제거 할 수 있습니다 &lt;a href=&quot;qcombobox#clear&quot;&gt;분명&lt;/a&gt; ()을. 현재 항목의 텍스트는 &lt;a href=&quot;qcombobox#currentText-prop&quot;&gt;currentText&lt;/a&gt; ()에 의해 반환되고 번호가 매겨진 항목의 텍스트는 text ()와 함께 반환됩니다. 현재 항목은 &lt;a href=&quot;qcombobox#currentIndex-prop&quot;&gt;setCurrentIndex&lt;/a&gt; () 로 설정할 수 있습니다 . 콤보 박스의 항목 수는 &lt;a href=&quot;qcombobox#count-prop&quot;&gt;count&lt;/a&gt; () 로 반환됩니다 . 최대 항목 수는 &lt;a href=&quot;qcombobox#maxCount-prop&quot;&gt;setMaxCount&lt;/a&gt; () 로 설정할 수 있습니다 . &lt;a href=&quot;qcombobox#editable-prop&quot;&gt;setEditable을&lt;/a&gt; 사용하여 편집을 허용 할 수 있습니다(). 편집 가능한 콤보 박스의 경우 &lt;a href=&quot;qcombobox#setCompleter&quot;&gt;setCompleter&lt;/a&gt; ()를 사용하여 자동 완성을 설정할 수 있으며 사용자가 중복을 추가 할 수 있는지 여부는 &lt;a href=&quot;qcombobox#duplicatesEnabled-prop&quot;&gt;setDuplicatesEnabled&lt;/a&gt; ()로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="61df4f2a8de1c3f11d8a1d1d12bc55cff5baa624" translate="yes" xml:space="preserve">
          <source>A combobox is a selection widget that displays the current item, and can pop up a list of selectable items. A combobox may be editable, allowing the user to modify each item in the list.</source>
          <target state="translated">콤보 박스는 현재 항목을 표시하고 선택 가능한 항목 목록을 표시 할 수있는 선택 위젯입니다. 콤보 박스를 편집 할 수있어 사용자가 목록의 각 항목을 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3b47b63bb5a98d0e0fba54e671bc03ae12e91926" translate="yes" xml:space="preserve">
          <source>A combobox, like &lt;a href=&quot;qcombobox&quot;&gt;QComboBox&lt;/a&gt;.</source>
          <target state="translated">같은 콤보, &lt;a href=&quot;qcombobox&quot;&gt;QComboBox&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c59cd6a4df56baffa126a7c26e2d1c2802322dcb" translate="yes" xml:space="preserve">
          <source>A combobox, like &lt;a href=&quot;widgets-changes-qt6#qcombobox&quot;&gt;QComboBox&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;widgets-changes-qt6#qcombobox&quot;&gt;QComboBox&lt;/a&gt; 와 같은 콤보 박스 .</target>
        </trans-unit>
        <trans-unit id="fdf808982ec1978822829821add4806b746bc45d" translate="yes" xml:space="preserve">
          <source>A comma separating different items is missing</source>
          <target state="translated">다른 항목을 구분하는 쉼표가 누락되었습니다</target>
        </trans-unit>
        <trans-unit id="5128fb14af5c348d1c1ba73ebe9b2998ca4403eb" translate="yes" xml:space="preserve">
          <source>A command ID is used in command compression. It must be an integer unique to this command's class, or -1 if the command doesn't support compression.</source>
          <target state="translated">명령 ID는 명령 압축에 사용됩니다. 이 명령의 클래스에 고유 한 정수이거나 명령이 압축을 지원하지 않는 경우 -1이어야합니다.</target>
        </trans-unit>
        <trans-unit id="3f1ccfe8f5fe3fdd2c9290b01954868158cf282e" translate="yes" xml:space="preserve">
          <source>A command button is rectangular and typically displays a text label describing its action. A shortcut key can be specified by preceding the preferred character with an ampersand in the text. For example:</source>
          <target state="translated">명령 단추는 직사각형이며 일반적으로 작업을 설명하는 텍스트 레이블을 표시합니다. 텍스트에서 앰퍼샌드로 선호 문자를 앞에 붙여서 단축키를 지정할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2cf55cf2364114c5a7c391231ad87e5e06b15c65" translate="yes" xml:space="preserve">
          <source>A command can be marked obsolete with the &lt;a href=&quot;qundocommand#setObsolete&quot;&gt;QUndoCommand::setObsolete&lt;/a&gt;() function. The &lt;a href=&quot;qundocommand#isObsolete&quot;&gt;QUndoCommand::isObsolete&lt;/a&gt;() flag is checked in &lt;a href=&quot;qundostack#push&quot;&gt;QUndoStack::push&lt;/a&gt;(), &lt;a href=&quot;qundostack#undo&quot;&gt;QUndoStack::undo&lt;/a&gt;(), &lt;a href=&quot;qundostack#redo&quot;&gt;QUndoStack::redo&lt;/a&gt;(), and &lt;a href=&quot;qundostack#setIndex&quot;&gt;QUndoStack::setIndex&lt;/a&gt;() after calling &lt;a href=&quot;qundocommand#undo&quot;&gt;QUndoCommand::undo&lt;/a&gt;(), &lt;a href=&quot;qundocommand#redo&quot;&gt;QUndoCommand::redo&lt;/a&gt;() and &lt;a href=&quot;qundocommand&quot;&gt;QUndoCommand&lt;/a&gt;:mergeWith() where applicable.</source>
          <target state="translated">&lt;a href=&quot;qundocommand#setObsolete&quot;&gt;QUndoCommand :: setObsolete&lt;/a&gt; () 함수를 사용하여 명령이 더 이상 사용되지 않는 것으로 표시 될 수 있습니다 . &lt;a href=&quot;qundocommand#isObsolete&quot;&gt;QUndoCommand :: isObsolete&lt;/a&gt; () 플래그가 체크되어 &lt;a href=&quot;qundostack#push&quot;&gt;QUndoStack :: 푸시&lt;/a&gt; (), &lt;a href=&quot;qundostack#undo&quot;&gt;QUndoStack :: 실행 취소&lt;/a&gt; (), &lt;a href=&quot;qundostack#redo&quot;&gt;QUndoStack :: 리두&lt;/a&gt; () 및 &lt;a href=&quot;qundostack#setIndex&quot;&gt;QUndoStack :: setIndex&lt;/a&gt; 호출 한 후 () &lt;a href=&quot;qundocommand#undo&quot;&gt;QUndoCommand :: 취소를&lt;/a&gt; (), &lt;a href=&quot;qundocommand#redo&quot;&gt;QUndoCommand : 해당되는 경우 : redo&lt;/a&gt; () 및 &lt;a href=&quot;qundocommand&quot;&gt;QUndoCommand&lt;/a&gt; : mergeWith ()</target>
        </trans-unit>
        <trans-unit id="f2b132f3b223a778c8d8191db30c1427ffa61341" translate="yes" xml:space="preserve">
          <source>A command macro is a sequence of commands, all of which are undone and redone in one go. Command macros are created by giving a command a list of child commands. Undoing or redoing the parent command will cause the child commands to be undone or redone. Command macros may be created explicitly by specifying a parent in the &lt;a href=&quot;qundocommand&quot;&gt;QUndoCommand&lt;/a&gt; constructor, or by using the convenience functions &lt;a href=&quot;qundostack#beginMacro&quot;&gt;beginMacro&lt;/a&gt;() and &lt;a href=&quot;qundostack#endMacro&quot;&gt;endMacro&lt;/a&gt;().</source>
          <target state="translated">명령 매크로는 일련의 명령으로, 모두 한 번에 취소하고 다시 실행할 수 있습니다. 명령 매크로는 명령에 하위 명령 목록을 제공하여 작성됩니다. 부모 명령을 실행 취소하거나 다시 실행하면 자식 명령이 실행 취소되거나 다시 실행됩니다. 명령 매크로는 &lt;a href=&quot;qundocommand&quot;&gt;QUndoCommand&lt;/a&gt; 생성자 에서 부모를 지정 하거나 편의 함수 &lt;a href=&quot;qundostack#beginMacro&quot;&gt;beginMacro&lt;/a&gt; () 및 &lt;a href=&quot;qundostack#endMacro&quot;&gt;endMacro&lt;/a&gt; () 를 사용하여 명시 적으로 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4edd9ffe13d90913c5fb11cc1d25565e01f5c2ef" translate="yes" xml:space="preserve">
          <source>A command or shell fragment prepended to each test command. An example use-case is a &quot;timeout&quot; script which will terminate a test if it does not complete within a specified time.</source>
          <target state="translated">각 테스트 명령 앞에 추가 된 명령 또는 쉘 조각. 사용 사례의 예는 지정된 시간 내에 완료되지 않으면 테스트를 종료하는 &quot;timeout&quot;스크립트입니다.</target>
        </trans-unit>
        <trans-unit id="477bc9e3eee121001fc4e49f60071511c40b957c" translate="yes" xml:space="preserve">
          <source>A comment in the parsed XML such as this:</source>
          <target state="translated">구문 분석 된 XML의 주석은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="97e6fd3dcd10abfe9d91aa194e9a5b660e14a273" translate="yes" xml:space="preserve">
          <source>A comment may be provided by the host platform to assist users in choosing the correct time zone. Depending on the platform this may not be localized.</source>
          <target state="translated">사용자가 올바른 시간대를 선택할 수 있도록 호스트 플랫폼에서 설명을 제공 할 수 있습니다. 플랫폼에 따라 현지화되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="639036f532dc688068023b1683be72b5cd49180f" translate="yes" xml:space="preserve">
          <source>A commit page is a page that represents an action which cannot be undone by clicking &lt;b&gt;Back&lt;/b&gt; or &lt;b&gt;Cancel&lt;/b&gt;.</source>
          <target state="translated">커밋 페이지는 &lt;b&gt;뒤로&lt;/b&gt; 또는 &lt;b&gt;취소&lt;/b&gt; 를 클릭하여 취소 할 수없는 작업을 나타내는 페이지입니다 .</target>
        </trans-unit>
        <trans-unit id="0f5958a9034c37ae82a75b916410ae0723a865de" translate="yes" xml:space="preserve">
          <source>A common cause of bugs in QML applications is accidentally overwriting bindings with static values from JavaScript statements. To help developers track down problems of this kind, the QML engine is able to emit messages whenever a binding is lost due to imperative assignments.</source>
          <target state="translated">QML 애플리케이션에서 버그의 일반적인 원인은 실수로 JavaScript 명령문의 정적 값으로 바인딩을 겹쳐 쓰는 것입니다. 개발자가 이러한 종류의 문제를 추적 할 수 있도록 QML 엔진은 의무 할당으로 인해 바인딩이 손실 될 때마다 메시지를 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c553d9b9de382ae28563479347e802638cce6f49" translate="yes" xml:space="preserve">
          <source>A common convention used in models that expose tree data structures is that only items in the first column have children. For that case, when reimplementing this function in a subclass the column of the returned &lt;a href=&quot;qmodelindex&quot;&gt;QModelIndex&lt;/a&gt; would be 0.</source>
          <target state="translated">트리 데이터 구조를 노출하는 모델에 사용되는 일반적인 규칙은 첫 번째 열의 항목에만 자식이 있다는 것입니다. 이 경우 서브 클래스에서이 함수를 다시 구현할 때 리턴 된 &lt;a href=&quot;qmodelindex&quot;&gt;QModelIndex&lt;/a&gt; 의 열은 0입니다.</target>
        </trans-unit>
        <trans-unit id="cb2f2762cfb46f4a4d619d7958e96d5101b5f365" translate="yes" xml:space="preserve">
          <source>A common error is to assume that attached properties and signal handlers are directly accessible from the children of the object to which these attributes have been attached. This is not the case. The instance of the</source>
          <target state="translated">일반적인 오류는 연결된 속성 및 신호 처리기에 이러한 속성이 연결된 개체의 자식에서 직접 액세스 할 수 있다고 가정하는 것입니다. 그렇지 않다. 의 인스턴스</target>
        </trans-unit>
        <trans-unit id="eb30d8291d11f4f4e5f991693002a15855714c43" translate="yes" xml:space="preserve">
          <source>A common implementation of dragEnterEvent accepts or ignores</source>
          <target state="translated">dragEnterEvent의 일반적인 구현은 수락하거나 무시합니다.</target>
        </trans-unit>
        <trans-unit id="2ad5ac5f8e22cb263b4300453f17ae1ab2ee8faf" translate="yes" xml:space="preserve">
          <source>A common problem with progress dialogs is that it is difficult to know when to use them; operations take different amounts of time on different hardware. &lt;a href=&quot;qprogressdialog&quot;&gt;QProgressDialog&lt;/a&gt; offers a solution to this problem: it estimates the time the operation will take (based on time for steps), and only shows itself if that estimate is beyond &lt;a href=&quot;qprogressdialog#minimumDuration-prop&quot;&gt;minimumDuration&lt;/a&gt;() (4 seconds by default).</source>
          <target state="translated">진행률 대화 상자의 일반적인 문제점은 사용시기를 알기가 어렵다는 것입니다. 작업은 하드웨어마다 시간이 다릅니다. &lt;a href=&quot;qprogressdialog&quot;&gt;QProgressDialog&lt;/a&gt; 는이 문제에 대한 솔루션을 제공합니다.이 단계는 작업 소요 시간 (단계 시간 기준)을 추정하고 해당 추정치가 &lt;a href=&quot;qprogressdialog#minimumDuration-prop&quot;&gt;minimumDuration&lt;/a&gt; () (기본적으로 4 초)을 초과하는 경우에만 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="53053796dd8abc9965043f3b5c4fdab297a4db00" translate="yes" xml:space="preserve">
          <source>A common problem with progress dialogs is that it is difficult to know when to use them; operations take different amounts of time on different hardware. QProgressDialog offers a solution to this problem: it estimates the time the operation will take (based on time for steps), and only shows itself if that estimate is beyond &lt;a href=&quot;qprogressdialog#minimumDuration-prop&quot;&gt;minimumDuration&lt;/a&gt;() (4 seconds by default).</source>
          <target state="translated">진행률 대화 상자의 일반적인 문제는 사용시기를 알기가 어렵다는 것입니다. 작업은 하드웨어마다 다른 시간이 걸립니다. QProgressDialog는이 문제에 대한 해결책을 제공합니다. 작업에 걸리는 시간 (단계별 시간 기준)을 추정하고 해당 추정값이 &lt;a href=&quot;qprogressdialog#minimumDuration-prop&quot;&gt;minimumDuration&lt;/a&gt; () (기본적으로 4 초)을 초과하는 경우에만 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="bae9d4446500fce41a882a411c7f868dd58ae56c" translate="yes" xml:space="preserve">
          <source>A common requirement is to remove an item from a list and do something with it. For this, &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt; provides &lt;a href=&quot;qlist#takeAt&quot;&gt;takeAt&lt;/a&gt;(), &lt;a href=&quot;qlist#takeFirst&quot;&gt;takeFirst&lt;/a&gt;(), and &lt;a href=&quot;qlist#takeLast&quot;&gt;takeLast&lt;/a&gt;(). Here's a loop that removes the items from a list one at a time and calls &lt;code&gt;delete&lt;/code&gt; on them:</source>
          <target state="translated">일반적인 요구 사항은 목록에서 항목을 제거하고 무언가를 수행하는 것입니다. 이를 위해 &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt; 는 &lt;a href=&quot;qlist#takeAt&quot;&gt;takeAt&lt;/a&gt; (), &lt;a href=&quot;qlist#takeFirst&quot;&gt;takeFirst&lt;/a&gt; () 및 &lt;a href=&quot;qlist#takeLast&quot;&gt;takeLast&lt;/a&gt; ()를 제공합니다. 다음은 목록에서 항목을 한 번에 하나씩 제거하고 &lt;code&gt;delete&lt;/code&gt; 를 호출하는 루프입니다 .</target>
        </trans-unit>
        <trans-unit id="21080e1c241300e5935372f587e33b8470e9340b" translate="yes" xml:space="preserve">
          <source>A common requirement is to remove an item from a list and do something with it. For this, QList provides &lt;a href=&quot;qlist#takeAt&quot;&gt;takeAt&lt;/a&gt;(), &lt;a href=&quot;qlist#takeFirst&quot;&gt;takeFirst&lt;/a&gt;(), and &lt;a href=&quot;qlist#takeLast&quot;&gt;takeLast&lt;/a&gt;(). Here's a loop that removes the items from a list one at a time and calls &lt;code&gt;delete&lt;/code&gt; on them:</source>
          <target state="translated">일반적인 요구 사항은 목록에서 항목을 제거하고 항목을 사용하는 것입니다. 이를 위해 QList는 &lt;a href=&quot;qlist#takeAt&quot;&gt;takeAt&lt;/a&gt; (), &lt;a href=&quot;qlist#takeFirst&quot;&gt;takeFirst&lt;/a&gt; () 및 &lt;a href=&quot;qlist#takeLast&quot;&gt;takeLast&lt;/a&gt; ()를 제공합니다. 다음은 목록에서 항목을 한 번에 하나씩 제거하고 해당 항목에 대해 &lt;code&gt;delete&lt;/code&gt; 를 호출하는 루프입니다 .</target>
        </trans-unit>
        <trans-unit id="148f8d6ed7d7004c33096c3945c1f4b2c8276c3a" translate="yes" xml:space="preserve">
          <source>A common requirement is to remove the first or last item in the list and do something with it. For this, &lt;a href=&quot;qlinkedlist&quot;&gt;QLinkedList&lt;/a&gt; provides &lt;a href=&quot;qlinkedlist#takeFirst&quot;&gt;takeFirst&lt;/a&gt;() and &lt;a href=&quot;qlinkedlist#takeLast&quot;&gt;takeLast&lt;/a&gt;(). Here's a loop that removes the items from a list one at a time and calls &lt;code&gt;delete&lt;/code&gt; on them:</source>
          <target state="translated">일반적인 요구 사항은 목록에서 첫 번째 또는 마지막 항목을 제거하고 무언가를 수행하는 것입니다. 이를 위해 &lt;a href=&quot;qlinkedlist&quot;&gt;QLinkedList&lt;/a&gt; 는 &lt;a href=&quot;qlinkedlist#takeFirst&quot;&gt;takeFirst&lt;/a&gt; () 및 &lt;a href=&quot;qlinkedlist#takeLast&quot;&gt;takeLast&lt;/a&gt; ()를 제공 합니다 . 다음은 목록에서 항목을 한 번에 하나씩 제거하고 &lt;code&gt;delete&lt;/code&gt; 를 호출하는 루프입니다 .</target>
        </trans-unit>
        <trans-unit id="05ed12b36ed04f2da1927d1aca175af20ead6a03" translate="yes" xml:space="preserve">
          <source>A common requirement is to remove the first or last item in the list and do something with it. For this, QLinkedList provides &lt;a href=&quot;qlinkedlist#takeFirst&quot;&gt;takeFirst&lt;/a&gt;() and &lt;a href=&quot;qlinkedlist#takeLast&quot;&gt;takeLast&lt;/a&gt;(). Here's a loop that removes the items from a list one at a time and calls &lt;code&gt;delete&lt;/code&gt; on them:</source>
          <target state="translated">일반적인 요구 사항은 목록에서 첫 번째 또는 마지막 항목을 제거하고이 항목으로 작업을 수행하는 것입니다. 이를 위해 QLinkedList는 &lt;a href=&quot;qlinkedlist#takeFirst&quot;&gt;takeFirst&lt;/a&gt; () 및 &lt;a href=&quot;qlinkedlist#takeLast&quot;&gt;takeLast&lt;/a&gt; ()를 제공 합니다 . 다음은 목록에서 항목을 한 번에 하나씩 제거하고 해당 항목에 대해 &lt;code&gt;delete&lt;/code&gt; 를 호출하는 루프입니다 .</target>
        </trans-unit>
        <trans-unit id="b2d5106322347695c9b4dfc0312f3ebb4ca93929" translate="yes" xml:space="preserve">
          <source>A common usage pattern is as follows:</source>
          <target state="translated">일반적인 사용 패턴은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3e9f75e225f60244bf7056d00dd98aab303754ea" translate="yes" xml:space="preserve">
          <source>A common use case is to center a popup within its parent. One way to do this is with the &lt;a href=&quot;qml-qtquick-item#x-prop&quot;&gt;x&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-item#y-prop&quot;&gt;y&lt;/a&gt; properties. Anchors offer a more convenient approach:</source>
          <target state="translated">일반적인 사용 사례는 팝업을 부모 내부에 배치하는 것입니다. 이를 수행하는 한 가지 방법은 &lt;a href=&quot;qml-qtquick-item#x-prop&quot;&gt;x&lt;/a&gt; 및 &lt;a href=&quot;qml-qtquick-item#y-prop&quot;&gt;y&lt;/a&gt; 속성을 사용하는 것입니다. 앵커는보다 편리한 접근 방식을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="2c2cb7bb39598cad610315bdbbe10ab9287788e9" translate="yes" xml:space="preserve">
          <source>A common use case is to let the user specify the filter regular expression, wildcard pattern, or fixed string in a &lt;a href=&quot;qlineedit&quot;&gt;QLineEdit&lt;/a&gt; and to connect the &lt;a href=&quot;qlineedit#textChanged&quot;&gt;textChanged()&lt;/a&gt; signal to &lt;a href=&quot;qsortfilterproxymodel#setFilterRegularExpression&quot;&gt;setFilterRegularExpression&lt;/a&gt;(), &lt;a href=&quot;qsortfilterproxymodel#setFilterWildcard&quot;&gt;setFilterWildcard&lt;/a&gt;(), or &lt;a href=&quot;qsortfilterproxymodel#setFilterFixedString&quot;&gt;setFilterFixedString&lt;/a&gt;() to reapply the filter.</source>
          <target state="translated">일반적인 사용 사례는 사용자가 &lt;a href=&quot;qlineedit&quot;&gt;QLineEdit&lt;/a&gt; 에서 필터 정규식, 와일드 카드 패턴 또는 고정 문자열을 지정 하고 &lt;a href=&quot;qlineedit#textChanged&quot;&gt;textChanged ()&lt;/a&gt; 신호를 &lt;a href=&quot;qsortfilterproxymodel#setFilterRegularExpression&quot;&gt;setFilterRegularExpression&lt;/a&gt; (), &lt;a href=&quot;qsortfilterproxymodel#setFilterWildcard&quot;&gt;setFilterWildcard&lt;/a&gt; () 또는 &lt;a href=&quot;qsortfilterproxymodel#setFilterFixedString&quot;&gt;setFilterFixedString&lt;/a&gt; ()에 연결하여 필터를 다시 적용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e75b7f0392f224ac1920664088f56b1f16e73578" translate="yes" xml:space="preserve">
          <source>A common way to distribute applications is to provide a compressed disk image (.dmg file) that the user can mount in Finder. The deployment tool, &lt;code&gt;macdeployqt&lt;/code&gt; (available from the macOS installers), can be used to create the self-contained bundles, and optionally also create a .dmg archive. Applications can also be distributed through the Mac App Store. Qt 5 aims to stay within the app store sandbox rules. macdeployqt (bin/macdeployqt) can be used as a starting point for app store deployment.</source>
          <target state="translated">응용 프로그램을 배포하는 일반적인 방법은 사용자가 Finder에 마운트 할 수있는 압축 디스크 이미지 (.dmg 파일)를 제공하는 것입니다. 배포 도구 &lt;code&gt;macdeployqt&lt;/code&gt; (macOS 설치 프로그램에서 사용 가능)를 사용하여 자체 포함 번들을 작성하고 선택적으로 .dmg 아카이브를 작성할 수도 있습니다. 응용 프로그램은 Mac App Store를 통해 배포 할 수도 있습니다. Qt 5는 앱 스토어 샌드 박스 규칙을 유지하는 것을 목표로합니다. macdeployqt (bin / macdeployqt)를 앱 스토어 배포의 시작점으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b10612bb575e68e002adec36b541a4334cab0a34" translate="yes" xml:space="preserve">
          <source>A common way to distribute applications is to provide a compressed disk image (.dmg file) that the user can mount in Finder. The deployment tool, &lt;code&gt;macdeployqt&lt;/code&gt; (available from the macOS installers), can be used to create the self-contained bundles, and optionally also create a .dmg archive. Applications can also be distributed through the Mac App Store. Qt aims to stay within the app store sandbox rules. macdeployqt (bin/macdeployqt) can be used as a starting point for app store deployment.</source>
          <target state="translated">응용 프로그램을 배포하는 일반적인 방법은 사용자가 Finder에서 마운트 할 수있는 압축 된 디스크 이미지 (.dmg 파일)를 제공하는 것입니다. 배포 도구 인 &lt;code&gt;macdeployqt&lt;/code&gt; (macOS 설치 프로그램에서 사용 가능)를 사용하여 자체 포함 된 번들을 생성하고 선택적으로 .dmg 아카이브도 생성 할 수 있습니다. 응용 프로그램은 Mac App Store를 통해서도 배포 할 수 있습니다. Qt는 앱 스토어 샌드 박스 규칙을 지키는 것을 목표로합니다. macdeployqt (bin / macdeployqt)는 앱 스토어 배포의 시작점으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="45d4c06dcfe6d54dc086164905150db9ec9fbeae" translate="yes" xml:space="preserve">
          <source>A common way to perform incremental parsing is to connect the &lt;code&gt;readyRead()&lt;/code&gt; signal of a &lt;a href=&quot;qnetworkreply&quot;&gt;network reply&lt;/a&gt; a slot, and handle the incoming data there. See &lt;a href=&quot;qnetworkaccessmanager&quot;&gt;QNetworkAccessManager&lt;/a&gt;.</source>
          <target state="translated">증분 구문 분석을 수행하는 일반적인 방법 은 &lt;a href=&quot;qnetworkreply&quot;&gt;네트워크&lt;/a&gt; 의 &lt;code&gt;readyRead()&lt;/code&gt; 신호를 슬롯에 연결하고 들어오는 데이터를 처리하는 것입니다. &lt;a href=&quot;qnetworkaccessmanager&quot;&gt;QNetworkAccessManager를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="864cf07a7d838ba7a2c027903f7c0bb14dcbc5a1" translate="yes" xml:space="preserve">
          <source>A compile time processed form can be used in your application with one of the following approaches:</source>
          <target state="translated">다음 방법 중 하나를 사용하여 응용 프로그램에서 컴파일 시간 처리 양식을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f7200507ebca347868a0859fffeb314440f4c8d" translate="yes" xml:space="preserve">
          <source>A compiled replica is a &lt;a href=&quot;qremoteobjectreplica&quot;&gt;QRemoteObjectReplica&lt;/a&gt; based type, where the derived class definition is automatically generated by the &lt;a href=&quot;qtremoteobjects-repc&quot;&gt;repc&lt;/a&gt; compiler. When you use the &lt;code&gt;REPC_REPLICA&lt;/code&gt; variable in your &lt;code&gt;.pro&lt;/code&gt; file, this makes the generation part of the build process. Although only a header is generated, it's a complete type. There is no public constructor, so you need to use the &lt;a href=&quot;qremoteobjectnode#acquire&quot;&gt;QRemoteObjectNode::acquire&lt;/a&gt; template function to create the Replica instance.</source>
          <target state="translated">컴파일 된 복제본은 파생 된 클래스 정의가 &lt;a href=&quot;qtremoteobjects-repc&quot;&gt;repc&lt;/a&gt; 컴파일러에 의해 자동으로 생성되는 &lt;a href=&quot;qremoteobjectreplica&quot;&gt;QRemoteObjectReplica&lt;/a&gt; 기반 유형 입니다. 당신이 사용하는 경우 &lt;code&gt;REPC_REPLICA&lt;/code&gt; 의 당신에 변수를 &lt;code&gt;.pro&lt;/code&gt; 파일이 빌드 프로세스의 생성 부분을 만든다. 헤더 만 생성되지만 완전한 유형입니다. 공용 생성자가 없으므로 &lt;a href=&quot;qremoteobjectnode#acquire&quot;&gt;QRemoteObjectNode :: acquire&lt;/a&gt; 템플릿 함수를 사용하여 Replica 인스턴스를 만들어야합니다.</target>
        </trans-unit>
        <trans-unit id="e11801dc14d8a845c06c251ea6b8371b8246a3bd" translate="yes" xml:space="preserve">
          <source>A compiled replica is a &lt;a href=&quot;qremoteobjectreplica&quot;&gt;QRemoteObjectReplica&lt;/a&gt; based type, where the derived class definition is automatically generated by the &lt;a href=&quot;qtremoteobjects-repc#&quot;&gt;repc&lt;/a&gt; compiler. Only a header file is generated (using the &lt;a href=&quot;qtremoteobjects-repc#repc-replica&quot;&gt;REPC_REPLICA&lt;/a&gt; variable in your .pro file will make generation part of the build process), but it is a complete type. There is no public constructor, you need to use the &lt;a href=&quot;qremoteobjectnode#acquire&quot;&gt;QRemoteObjectNode::acquire&lt;/a&gt; template function to create the Replica instance.</source>
          <target state="translated">컴파일 된 복제본은 &lt;a href=&quot;qremoteobjectreplica&quot;&gt;QRemoteObjectReplica&lt;/a&gt; 기반 유형이며 파생 클래스 정의는 &lt;a href=&quot;qtremoteobjects-repc#&quot;&gt;repc&lt;/a&gt; 컴파일러에 의해 자동으로 생성됩니다 . 헤더 파일 만 생성 &lt;a href=&quot;qtremoteobjects-repc#repc-replica&quot;&gt;되지만&lt;/a&gt; ( .pro 파일에서 REPC_REPLICA 변수를 사용하면 생성 프로세스의 일부가 생성됨 ) 완전한 유형입니다. 공용 생성자가 없으므로 &lt;a href=&quot;qremoteobjectnode#acquire&quot;&gt;QRemoteObjectNode :: acquire&lt;/a&gt; 템플릿 함수를 사용하여 Replica 인스턴스를 만들어야합니다.</target>
        </trans-unit>
        <trans-unit id="0ea731e7e4fa5b37fe7883f02c8ef94b2f3176be" translate="yes" xml:space="preserve">
          <source>A compiled state machine can be instantiated the same way as any C++ object:</source>
          <target state="translated">컴파일 된 상태 머신은 모든 C ++ 객체와 동일한 방식으로 인스턴스화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="56c91b39af1a78cbb435f1df379bd9cba572a4d5" translate="yes" xml:space="preserve">
          <source>A complete &lt;a href=&quot;qbluetoothserviceinfo&quot;&gt;QBluetoothServiceInfo&lt;/a&gt; object contains a &lt;a href=&quot;qbluetoothserviceinfo#AttributeId-enum&quot;&gt;ProtocolDescriptorList&lt;/a&gt; attribute.</source>
          <target state="translated">완전한 &lt;a href=&quot;qbluetoothserviceinfo&quot;&gt;QBluetoothServiceInfo&lt;/a&gt; 오브젝트에는 &lt;a href=&quot;qbluetoothserviceinfo#AttributeId-enum&quot;&gt;ProtocolDescriptorList&lt;/a&gt; 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ab4882c64f44c58d02ad145187bd87ae025df83f" translate="yes" xml:space="preserve">
          <source>A complete custom widget specification looks like:</source>
          <target state="translated">완전한 사용자 정의 위젯 스펙은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="76a9017adfa8a4106d6f3a9a0164c49357fe4051" translate="yes" xml:space="preserve">
          <source>A complete description of DITA can be found at the &lt;a href=&quot;http://www.oasis-open.org/committees/tc_home.php?wg_abbrev=dita&quot;&gt;OASIS Darwin Information Typing Architecture&lt;/a&gt; site.</source>
          <target state="translated">DITA에 대한 자세한 설명은 &lt;a href=&quot;http://www.oasis-open.org/committees/tc_home.php?wg_abbrev=dita&quot;&gt;OASIS Darwin Information Typing Architecture&lt;/a&gt; 사이트 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7e4b24e283775b6d244e20f8047672f17d6033a7" translate="yes" xml:space="preserve">
          <source>A complete path to a directory containing a &lt;code&gt;qmake.conf&lt;/code&gt; file. In this case qmake will open the &lt;code&gt;qmake.conf&lt;/code&gt; file from within that directory. If the file does not exist, qmake will exit with an error.</source>
          <target state="translated">&lt;code&gt;qmake.conf&lt;/code&gt; 파일을 포함하는 디렉토리의 전체 경로 입니다. 이 경우 qmake는 해당 디렉토리 내 에서 &lt;code&gt;qmake.conf&lt;/code&gt; 파일을 엽니 다 . 파일이 없으면 qmake가 오류와 함께 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="23e8cc9528ee2c9db8bb4a099346df09a9a8358d" translate="yes" xml:space="preserve">
          <source>A complete web browser window.</source>
          <target state="translated">완전한 웹 브라우저 창.</target>
        </trans-unit>
        <trans-unit id="c712b496087f939e164f0ce3aef073b161529e2d" translate="yes" xml:space="preserve">
          <source>A component for displaying web content. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">웹 컨텐츠를 표시하기위한 구성 요소입니다. &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4c3858f37abfe07c1e0eba1f63ab78c13a7b3ceb" translate="yes" xml:space="preserve">
          <source>A component is a template from which a QML object or object tree is created. It is produced when a document is loaded by the QML engine. Once it has been loaded, it can be used to instantiate the object or object tree that it represents.</source>
          <target state="translated">컴포넌트는 QML 오브젝트 또는 오브젝트 트리가 작성되는 템플리트입니다. QML 엔진이 문서를로드 할 때 생성됩니다. 일단로드되면, 그것이 나타내는 오브젝트 또는 오브젝트 트리를 인스턴스화하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b328525d196a5bd7b479fec47247fba9aff5b9a8" translate="yes" xml:space="preserve">
          <source>A component is considered to be in use if there are any extant instances of the component itself, any instances of other components that use the component, or any objects instantiated by any of those components.</source>
          <target state="translated">구성 요소 자체의 기존 인스턴스, 구성 요소를 사용하는 다른 구성 요소 인스턴스 또는 해당 구성 요소로 인스턴스화 된 개체가있는 경우 구성 요소가 사용중인 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="7f576eded800f741e3e288acf2ecba1856cd5e5e" translate="yes" xml:space="preserve">
          <source>A computer device or PDA.</source>
          <target state="translated">컴퓨터 장치 또는 PDA</target>
        </trans-unit>
        <trans-unit id="963158a84d58b5338416baf086c1c44aee7c02fa" translate="yes" xml:space="preserve">
          <source>A configurable stock chart for the NASDAQ-100</source>
          <target state="translated">NASDAQ-100에 대한 구성 가능한 주식 차트</target>
        </trans-unit>
        <trans-unit id="9edc9508e4e416d4d2e514af0cb62bf16d7f458f" translate="yes" xml:space="preserve">
          <source>A configuration can represent a single access point configuration or a set of access point configurations. Such a set is called service network. A configuration that is based on a service network can potentially support roaming of network sessions.</source>
          <target state="translated">구성은 단일 액세스 지점 구성 또는 일련의 액세스 지점 구성을 나타낼 수 있습니다. 이러한 세트를 서비스 네트워크라고합니다. 서비스 네트워크를 기반으로하는 구성은 네트워크 세션 로밍을 잠재적으로 지원할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="16efa5515b03c1b20f59574d4c1476cd7e202dd5" translate="yes" xml:space="preserve">
          <source>A conical mesh</source>
          <target state="translated">원뿔형 메쉬</target>
        </trans-unit>
        <trans-unit id="0a669105f5e99fe0ecb2a7c943259cf9049e666c" translate="yes" xml:space="preserve">
          <source>A conical mesh. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">원뿔형 메쉬. &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="95211d4a48ea3d6e97ab60cc5fe138449e17d299" translate="yes" xml:space="preserve">
          <source>A conical mesh. &lt;a href=&quot;qt3dextras-qconegeometryview#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">원추형 메쉬. &lt;a href=&quot;qt3dextras-qconegeometryview#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="85e6f92a4b32e24ce2389b32934aec504b310ed0" translate="yes" xml:space="preserve">
          <source>A conical mesh. &lt;a href=&quot;qt3dextras-qconemesh#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">원뿔형 메쉬. &lt;a href=&quot;qt3dextras-qconemesh#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="43e6a4dfc68f973467bf70d0b82b8f1e31bedc5d" translate="yes" xml:space="preserve">
          <source>A connection is established.</source>
          <target state="translated">연결이 설정되었습니다.</target>
        </trans-unit>
        <trans-unit id="24f3ee9df98ea18ec7b6566034194b70db9d14c0" translate="yes" xml:space="preserve">
          <source>A consequence of this is that if Qt has problems dealing with some of these macOS features (dark-mode, layer-backed views), the only way to opt out of them is building with an earlier SDK (the 10.13 SDK, available through Xcode 9). This is a last-resort solution, and should only be applied if your application has no other ways of working around the problem.</source>
          <target state="translated">그 결과 Qt에 이러한 macOS 기능 중 일부 (다크 모드, 계층 지원보기)를 처리하는 데 문제가있는 경우이를 거부 할 수있는 유일한 방법은 이전 SDK (Xcode를 통해 사용 가능한 10.13 SDK)로 빌드하는 것입니다 9). 이것은 최후의 해결책이며, 응용 프로그램에 다른 문제 해결 방법이없는 경우에만 적용해야합니다.</target>
        </trans-unit>
        <trans-unit id="3ceb965987308bf617c0ec322f5c7557c4ca613d" translate="yes" xml:space="preserve">
          <source>A const pointer to the model is returned because calls to non-const functions of the model might invalidate the model index and possibly crash your application.</source>
          <target state="translated">모델의 상수가 아닌 함수를 호출하면 모델 인덱스가 무효화되고 응용 프로그램이 중단 될 수 있으므로 모델에 대한 const 포인터가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="b2d371833dad13e2036a8f14eb1db350d959f80a" translate="yes" xml:space="preserve">
          <source>A constant property providing an invalid index for selection. This index is set to the &lt;a href=&quot;qml-qtdatavisualization-scatter3dseries#selectedItem-prop&quot;&gt;selectedItem&lt;/a&gt; property to clear the selection from this series.</source>
          <target state="translated">선택에 유효하지 않은 인덱스를 제공하는 상수 속성입니다. 이 인덱스는 &lt;a href=&quot;qml-qtdatavisualization-scatter3dseries#selectedItem-prop&quot;&gt;selectedItem&lt;/a&gt; 속성으로 설정되어이 계열에서 선택한 항목을 지 웁니다.</target>
        </trans-unit>
        <trans-unit id="04147bde11823f127ca5d5aa3b2cab189f09dd4e" translate="yes" xml:space="preserve">
          <source>A constant property providing an invalid point for selection.</source>
          <target state="translated">선택에 유효하지 않은 점을 제공하는 상수 속성입니다.</target>
        </trans-unit>
        <trans-unit id="c307b93e6abe6756eaac5e4aac2045553faebbfb" translate="yes" xml:space="preserve">
          <source>A constant property providing an invalid position for selection. This position is set to the &lt;a href=&quot;qml-qtdatavisualization-bar3dseries#selectedBar-prop&quot;&gt;selectedBar&lt;/a&gt; property to clear the selection from this series.</source>
          <target state="translated">선택할 수없는 위치를 제공하는 상수 속성입니다. 이 위치는 &lt;a href=&quot;qml-qtdatavisualization-bar3dseries#selectedBar-prop&quot;&gt;selectedBar&lt;/a&gt; 속성으로 설정되어이 계열에서 선택한 항목을 지 웁니다.</target>
        </trans-unit>
        <trans-unit id="ddbedf210eaeb96bcba7e26855d33eba1351e08d" translate="yes" xml:space="preserve">
          <source>A constant property providing an invalid selection position. This position is set to the &lt;a href=&quot;qml-qtdatavisualization-surface3dseries#selectedPoint-prop&quot;&gt;selectedPoint&lt;/a&gt; property to clear the selection from this series.</source>
          <target state="translated">유효하지 않은 선택 위치를 제공하는 상수 속성입니다. 이 위치는 &lt;a href=&quot;qml-qtdatavisualization-surface3dseries#selectedPoint-prop&quot;&gt;selectedPoint&lt;/a&gt; 속성으로 설정되어이 계열에서 선택한 항목을 지 웁니다.</target>
        </trans-unit>
        <trans-unit id="0eb8952c07cef3aeb17b356c2b7afb7845d102d0" translate="yes" xml:space="preserve">
          <source>A constant that can be used for enabling transfer timeouts with a preset value.</source>
          <target state="translated">사전 설정된 값으로 전송 시간 초과를 활성화하는 데 사용할 수있는 상수입니다.</target>
        </trans-unit>
        <trans-unit id="7ae348a04894fab380002fe435b429835d75ef45" translate="yes" xml:space="preserve">
          <source>A constant value which does not depend on other properties.</source>
          <target state="translated">다른 속성에 의존하지 않는 상수 값.</target>
        </trans-unit>
        <trans-unit id="d5c5bf9c16ecf17dcd562ba7b2f208ff1d1125ea" translate="yes" xml:space="preserve">
          <source>A constructor for &lt;a href=&quot;qxmlstreamattributes&quot;&gt;QXmlStreamAttributes&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qxmlstreamattributes&quot;&gt;QXmlStreamAttributes&lt;/a&gt; 의 생성자입니다 .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
