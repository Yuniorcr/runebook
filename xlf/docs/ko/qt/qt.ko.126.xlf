<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="qt">
    <body>
      <group id="qt">
        <trans-unit id="c7e9a767ec6a5a9b325c919e143ccdff6481f048" translate="yes" xml:space="preserve">
          <source>No QEventLoops will be started anymore in this thread until &lt;a href=&quot;qthread#exec&quot;&gt;QThread::exec&lt;/a&gt;() has been called again. If the eventloop in &lt;a href=&quot;qthread#exec&quot;&gt;QThread::exec&lt;/a&gt;() is not running then the next call to &lt;a href=&quot;qthread#exec&quot;&gt;QThread::exec&lt;/a&gt;() will also return immediately.</source>
          <target state="translated">&lt;a href=&quot;qthread#exec&quot;&gt;QThread :: exec&lt;/a&gt; ()가 다시 호출 될 때까지이 스레드에서 더 이상 QEventLoops가 시작되지 않습니다 . 에서 eventloop 경우 &lt;a href=&quot;qthread#exec&quot;&gt;QThread :: 간부는&lt;/a&gt; () 다음에 다음 호출 실행되지 &lt;a href=&quot;qthread#exec&quot;&gt;QThread :: 간부를&lt;/a&gt; () 즉시 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1c382e8186686538518fc13d7192925f6a2d01d3" translate="yes" xml:space="preserve">
          <source>No Translation</source>
          <target state="translated">번역 없음</target>
        </trans-unit>
        <trans-unit id="85c001fea2dc345212885b257f2f7d1f69a4d6df" translate="yes" xml:space="preserve">
          <source>No Year 0</source>
          <target state="translated">년 없음 0</target>
        </trans-unit>
        <trans-unit id="7b4ef7fc27480f9491fa97e2ac7e874856f22494" translate="yes" xml:space="preserve">
          <source>No access restrictions have been set.</source>
          <target state="translated">액세스 제한이 설정되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="04009cfb37629dd663905e3a6bba0030c7801b8c" translate="yes" xml:space="preserve">
          <source>No access restrictions.</source>
          <target state="translated">액세스 제한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="f6a5cc3d225bade067021b817572f4f5b3fb1339" translate="yes" xml:space="preserve">
          <source>No action is triggered.</source>
          <target state="translated">동작이 트리거되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e6168c5b0c4c8610d753397daa516d9f08362fb5" translate="yes" xml:space="preserve">
          <source>No anchor, i.e. the view leaves the scene's position unchanged.</source>
          <target state="translated">앵커가 없습니다. 즉, 뷰는 장면의 위치를 ​​변경하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4b11823279d6206d6996d599e10bfbabbfedb98a" translate="yes" xml:space="preserve">
          <source>No anisotropic filtering.</source>
          <target state="translated">이방성 필터링이 없습니다.</target>
        </trans-unit>
        <trans-unit id="e4e0f15c38295e273af7d4270ce2aade4f61a9f2" translate="yes" xml:space="preserve">
          <source>No application protocol has been negotiated (yet).</source>
          <target state="translated">응용 프로그램 프로토콜이 협상되지 않았습니다 (아직).</target>
        </trans-unit>
        <trans-unit id="264053098d4cff51b15a541994ab25a8a043f48d" translate="yes" xml:space="preserve">
          <source>No attachment is added to the framebuffer object. Note that the OpenGL depth and stencil tests won't work when rendering to a framebuffer object without any depth or stencil buffers. This is the default value.</source>
          <target state="translated">프레임 버퍼 객체에 첨부 파일이 추가되지 않습니다. OpenGL 깊이 및 스텐실 테스트는 깊이 또는 스텐실 버퍼가없는 프레임 버퍼 객체로 렌더링 할 때는 작동하지 않습니다. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="d079b13c09793ea5369fd9123867bd738a00db36" translate="yes" xml:space="preserve">
          <source>No automatic rotation is applied to the reading values.</source>
          <target state="translated">판독 값에는 자동 회전이 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6b88617c3bc86ff939aa39a1504db05c6d6378ec" translate="yes" xml:space="preserve">
          <source>No boundary (use the whole text).</source>
          <target state="translated">경계가 없습니다 (전체 텍스트 사용).</target>
        </trans-unit>
        <trans-unit id="4939272d7b5e43e143c38edff33f3f322046fe23" translate="yes" xml:space="preserve">
          <source>No brush pattern.</source>
          <target state="translated">브러시 패턴이 없습니다.</target>
        </trans-unit>
        <trans-unit id="c105c4bfbee6f6fa2975caf0b2d3ce8e8b20e08f" translate="yes" xml:space="preserve">
          <source>No buffers will be cleared</source>
          <target state="translated">버퍼가 지워지지 않습니다</target>
        </trans-unit>
        <trans-unit id="a11fe2d5e8ea396f13acf4eb2ea379ad79b07b57" translate="yes" xml:space="preserve">
          <source>No camera service available.</source>
          <target state="translated">카메라 서비스가 없습니다.</target>
        </trans-unit>
        <trans-unit id="dd31b7f1b31d0ff9fea98030dd38a63ade74042f" translate="yes" xml:space="preserve">
          <source>No capitalization change is applied.</source>
          <target state="translated">대소 문자 변경이 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4d235224df8d216b932e6c7ce54dfab263559dd1" translate="yes" xml:space="preserve">
          <source>No category fetch query has been executed. The model is empty.</source>
          <target state="translated">카테고리 페치 조회가 실행되지 않았습니다. 모델이 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef70b2a7a29159d99839ca60207426a164b0241c" translate="yes" xml:space="preserve">
          <source>No cells have been added or removed, but the data of the specified cell range is invalid.</source>
          <target state="translated">추가 또는 제거 된 셀이 없지만 지정된 셀 범위의 데이터가 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="67c96a977cfc9d134925bbc4ef08f3dafa3cfc4f" translate="yes" xml:space="preserve">
          <source>No change in interpretation; this tag can be used as the outermost tag in a CBOR stream as the file header.</source>
          <target state="translated">해석에는 변화가 없습니다. 이 태그는 CBOR 스트림에서 파일 헤더로 가장 바깥 쪽 태그로 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a5afe3485bbdcbfa9aec3b7b14a0e83ec94b0ecc" translate="yes" xml:space="preserve">
          <source>No check is made to ensure that a directory with this name actually exists; but see &lt;a href=&quot;qdir#exists-1&quot;&gt;exists&lt;/a&gt;().</source>
          <target state="translated">이 이름의 디렉토리가 실제로 존재하는지 확인하지 않습니다. 그러나 &lt;a href=&quot;qdir#exists-1&quot;&gt;존재&lt;/a&gt; ()를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="40d786a9defb8616cfb0a7c4cf5e9d5f76b5ed7b" translate="yes" xml:space="preserve">
          <source>No check options are specified.</source>
          <target state="translated">점검 옵션이 지정되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="574e02572bc511f5d7dd1f6a52d85d7e02c1a7af" translate="yes" xml:space="preserve">
          <source>No color space is specified.</source>
          <target state="translated">색 공간이 지정되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="dc56f47fa564c2bcc9ee4bebdde8838211d74d71" translate="yes" xml:space="preserve">
          <source>No content is currently set to be shared.</source>
          <target state="translated">현재 공유하도록 설정된 컨텐츠가 없습니다.</target>
        </trans-unit>
        <trans-unit id="6a099223a07e854be9e6513cd0825d1c28ab220b" translate="yes" xml:space="preserve">
          <source>No data is available.</source>
          <target state="translated">사용 가능한 데이터가 없습니다.</target>
        </trans-unit>
        <trans-unit id="666ad0ec21e013b6263533384d4a5ad0c1eeb533" translate="yes" xml:space="preserve">
          <source>No data loss possible</source>
          <target state="translated">가능한 데이터 손실 없음</target>
        </trans-unit>
        <trans-unit id="cdc6f08ea76fdcdb3b0b04b0e6a331497c954644" translate="yes" xml:space="preserve">
          <source>No data type.</source>
          <target state="translated">데이터 유형이 없습니다.</target>
        </trans-unit>
        <trans-unit id="e184267359c0456bc3ac6acf7ddf786a57c64d26" translate="yes" xml:space="preserve">
          <source>No defined element.</source>
          <target state="translated">정의 된 요소가 없습니다.</target>
        </trans-unit>
        <trans-unit id="2cff6611e5d5b95fb991ec425c9f1cab184b1aef" translate="yes" xml:space="preserve">
          <source>No device, or an unknown device.</source>
          <target state="translated">장치가 없거나 알 수없는 장치입니다.</target>
        </trans-unit>
        <trans-unit id="646a470976530b94c9a8e0ec1779382c646ec240" translate="yes" xml:space="preserve">
          <source>No dithering; closest color is used.</source>
          <target state="translated">디더링 없음; 가장 가까운 색이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7d1b6ad5067f8d63b63c11a2e0234f14d6df136c" translate="yes" xml:space="preserve">
          <source>No edge.</source>
          <target state="translated">가장자리가 없습니다.</target>
        </trans-unit>
        <trans-unit id="31ecff337b26af4b7af6985ee5d9d62712ab7205" translate="yes" xml:space="preserve">
          <source>No editing possible.</source>
          <target state="translated">편집 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f686c517d76217d9cac13ca62f66efa6f61a18a7" translate="yes" xml:space="preserve">
          <source>No error has occurred</source>
          <target state="translated">오류가 발생하지 않았습니다</target>
        </trans-unit>
        <trans-unit id="b297df8f20cb042c6015714d6d62f91da3d77999" translate="yes" xml:space="preserve">
          <source>No error has occurred.</source>
          <target state="translated">오류가 발생하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="fc04fb845df75620ad37b0adde0194b02c1de048" translate="yes" xml:space="preserve">
          <source>No error has ocurred.</source>
          <target state="translated">오류가 발생하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="1d17c3343039e9ef19537cc72ba278d93078f748" translate="yes" xml:space="preserve">
          <source>No error occurred</source>
          <target state="translated">오류가 발생하지 않았습니다</target>
        </trans-unit>
        <trans-unit id="54362618eb30cb24ffaf007c0744b28f171163b3" translate="yes" xml:space="preserve">
          <source>No error occurred during the last operation, further operations may be performed on the category.</source>
          <target state="translated">마지막 작업 중에 오류가 발생하지 않았으므로 카테고리에서 추가 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="51b503f9f76f99f5545803f0c4a71dc531f17025" translate="yes" xml:space="preserve">
          <source>No error occurred during the last operation, further operations may be performed on the model.</source>
          <target state="translated">마지막 작업 중에 오류가 발생하지 않았으므로 모델에서 추가 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8402e6d7a81e23e60690e37e2bd8df7e0299088e" translate="yes" xml:space="preserve">
          <source>No error occurred during the last operation, further operations may be performed on the place.</source>
          <target state="translated">마지막 작업 중에 오류가 발생하지 않았으므로 해당 위치에서 추가 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eadca53bbf3975e5003a4dc25df2eaf833e00bfa" translate="yes" xml:space="preserve">
          <source>No error occurred, the last operation was successful.</source>
          <target state="translated">오류가 발생하지 않았으며 마지막 작업이 성공했습니다.</target>
        </trans-unit>
        <trans-unit id="281eed53295232d9bad65334e54a575ab5a0db5a" translate="yes" xml:space="preserve">
          <source>No error occurred.</source>
          <target state="translated">오류가 발생하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="9c2aca925e5e82770d198d24c0d9e6b051f92641" translate="yes" xml:space="preserve">
          <source>No error was detected.</source>
          <target state="translated">오류가 감지되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="b2f69b3d1ffe4476f9895565ab3c472eb9a4deae" translate="yes" xml:space="preserve">
          <source>No error.</source>
          <target state="translated">오류가 없습니다.</target>
        </trans-unit>
        <trans-unit id="c5eee9890ef65849861afc1be69d2e2747a38a42" translate="yes" xml:space="preserve">
          <source>No error. Used for testing.</source>
          <target state="translated">오류가 없습니다. 테스트에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="605256a55d0aaa5b8f371f89d7e258ce838bfef1" translate="yes" xml:space="preserve">
          <source>No errors</source>
          <target state="translated">오류 없음</target>
        </trans-unit>
        <trans-unit id="9f2e1ba38052da1b983266bfbc2c413575cd39ce" translate="yes" xml:space="preserve">
          <source>No errors have occurred</source>
          <target state="translated">오류가 발생하지 않았습니다</target>
        </trans-unit>
        <trans-unit id="cdf7ef05c0fdf47d6fcf496330a2b9cc8553655c" translate="yes" xml:space="preserve">
          <source>No errors have occurred.</source>
          <target state="translated">오류가 발생하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="737dae0b51bce2e6e2820bc9093ce3e83f60ff2e" translate="yes" xml:space="preserve">
          <source>No errors.</source>
          <target state="translated">오류가 없습니다.</target>
        </trans-unit>
        <trans-unit id="7892d6a502d5f2e2afd5b3f6dd7295506fe84c22" translate="yes" xml:space="preserve">
          <source>No explicit hint has been specified.</source>
          <target state="translated">명시적인 힌트가 지정되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="3cf9a8f6c1f780d068a5fd7c8081ef2c13395d28" translate="yes" xml:space="preserve">
          <source>No explicit visibility has been defined.</source>
          <target state="translated">명확한 가시성이 정의되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="2d0ec6cdeb3eeb22c10375761edf35b5b02d1748" translate="yes" xml:space="preserve">
          <source>No explicit visibility scope specified, places with any visibility may be part of search results.</source>
          <target state="translated">명확한 가시성 범위가 지정되지 않은 경우 가시성이있는 장소는 검색 결과의 일부일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f7ef0d0e0e908aa01729965419166a0afbbabe4" translate="yes" xml:space="preserve">
          <source>No filter is applied to images.</source>
          <target state="translated">이미지에 필터가 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="aa7fa771cab3010dd1711f91d38cd411a7ded9cf" translate="yes" xml:space="preserve">
          <source>No filtering should occur. This value is only used together with &lt;a href=&quot;qsgtexture#setMipmapFiltering&quot;&gt;setMipmapFiltering&lt;/a&gt;().</source>
          <target state="translated">필터링이 발생하지 않아야합니다. 이 값은 &lt;a href=&quot;qsgtexture#setMipmapFiltering&quot;&gt;setMipmapFiltering&lt;/a&gt; () 과 함께 만 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="37f264fdbe087a4fb4d54af8ea376b85fc60e465" translate="yes" xml:space="preserve">
          <source>No flag is set.</source>
          <target state="translated">플래그가 설정되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="71684007bf6a8ac7e3b2d2763f7e1fb0852894ef" translate="yes" xml:space="preserve">
          <source>No flow control.</source>
          <target state="translated">흐름 제어가 없습니다.</target>
        </trans-unit>
        <trans-unit id="dae09bdac8f896a136f3d3d20239e81c43fc27e1" translate="yes" xml:space="preserve">
          <source>No frames are cached (the default).</source>
          <target state="translated">캐시 된 프레임이 없습니다 (기본값).</target>
        </trans-unit>
        <trans-unit id="2ff64c461ab58e54ed3a56dae447964ba308a06c" translate="yes" xml:space="preserve">
          <source>No geocoding features are supported.</source>
          <target state="translated">지오 코딩 기능이 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="53cc84a746be056881b64eb02cd083428f84d818" translate="yes" xml:space="preserve">
          <source>No gesture has been detected.</source>
          <target state="translated">제스처가 감지되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="c42924007e146a414395e094d76cb5ff55950154" translate="yes" xml:space="preserve">
          <source>No gradient is used.</source>
          <target state="translated">그라디언트가 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="29e5224ed1bc66141eac60ece92d355288a0dda8" translate="yes" xml:space="preserve">
          <source>No hint is available.</source>
          <target state="translated">힌트가 없습니다.</target>
        </trans-unit>
        <trans-unit id="ff0efdbbb88b76c5cdb3d8137301c4f2fe8b9962" translate="yes" xml:space="preserve">
          <source>No hinting</source>
          <target state="translated">힌트 없음</target>
        </trans-unit>
        <trans-unit id="788be92192fa5af500fb8204c9a6b35ab2c5e990" translate="yes" xml:space="preserve">
          <source>No hints.</source>
          <target state="translated">힌트가 없습니다.</target>
        </trans-unit>
        <trans-unit id="18744b4973c73df2b0f4ca7cc6b899ac98036291" translate="yes" xml:space="preserve">
          <source>No icon is shown.</source>
          <target state="translated">아이콘이 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ee9c00230a5834194191d329277dd2640be52bcd" translate="yes" xml:space="preserve">
          <source>No index is applied. Item location is of linear complexity, as all items on the scene are searched. Adding, moving and removing items, however, is done in constant time. This approach is ideal for dynamic scenes, where many items are added, moved or removed continuously.</source>
          <target state="translated">인덱스가 적용되지 않습니다. 장면의 모든 항목이 검색되므로 항목 위치는 선형 적으로 복잡합니다. 그러나 항목 추가, 이동 및 제거는 일정한 시간에 수행됩니다. 이 방법은 많은 항목이 지속적으로 추가, 이동 또는 제거되는 동적 장면에 이상적입니다.</target>
        </trans-unit>
        <trans-unit id="24d07d15b6d3ee4151c8cf27ab63d29ad684124a" translate="yes" xml:space="preserve">
          <source>No interaction with the text is possible.</source>
          <target state="translated">텍스트와 상호 작용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="bead389416b9cae0fc62d60976f0177c1e44c0da" translate="yes" xml:space="preserve">
          <source>No known error</source>
          <target state="translated">알려진 오류가 없습니다</target>
        </trans-unit>
        <trans-unit id="78f6148adc5f3f86ebeb4877f24e59e26fbbf6bd" translate="yes" xml:space="preserve">
          <source>No leading dot is included, so for instance this would return &quot;jpg&quot;, &quot;jpeg&quot; for image/jpeg.</source>
          <target state="translated">선행 점은 포함되지 않으므로 예를 들어 image / jpeg에 대해 &quot;jpg&quot;, &quot;jpeg&quot;를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f114ab2e9626a657b95d2569157e21280cbcd254" translate="yes" xml:space="preserve">
          <source>No leading dot is included, so for instance this would return &quot;pdf&quot; for application/pdf. The return value can be empty, for mime types which do not have any suffixes associated.</source>
          <target state="translated">선행 점은 포함되지 않으므로 application / pdf에 대해 &quot;pdf&quot;를 반환합니다. 접미사가 연결되지 않은 MIME 유형의 경우 반환 값은 비어있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5edccb05a63f42602fcfd2ed77457db67ca38bc0" translate="yes" xml:space="preserve">
          <source>No line active</source>
          <target state="translated">활성화 된 라인이 없습니다</target>
        </trans-unit>
        <trans-unit id="86a27994acabd7c66d6c4374e9a9dbf122340b4f" translate="yes" xml:space="preserve">
          <source>No longer used since 5.11, as Blink now renders Validation messages internally.</source>
          <target state="translated">Blink가 이제 유효성 검사 메시지를 내부적으로 렌더링하므로 5.11 이후로 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="98e89c7b75d879821bbf736637b6045bf4b333e1" translate="yes" xml:space="preserve">
          <source>No maneuvers should be included with the route</source>
          <target state="translated">경로에 기동을 포함해서는 안됩니다</target>
        </trans-unit>
        <trans-unit id="047d18dd35dadf1d78ffa79fcd2af93bfd0a9bdd" translate="yes" xml:space="preserve">
          <source>No maneuvers should be included with the route.</source>
          <target state="translated">경로에 기동이 포함되어서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="ebd7fc62ef0841f5d890ac57ce36345d601f5118" translate="yes" xml:space="preserve">
          <source>No mapping features are supported.</source>
          <target state="translated">매핑 기능이 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="066451f79a8b484dc7a17c033b7dddc688367462" translate="yes" xml:space="preserve">
          <source>No mapping for xs:time</source>
          <target state="translated">xs : time에 대한 매핑이 없습니다.</target>
        </trans-unit>
        <trans-unit id="8e6b8618c40994b5364d76d94166d0012155e298" translate="yes" xml:space="preserve">
          <source>No match options are set.</source>
          <target state="translated">일치 옵션이 설정되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="0f8f04b81b30ae3c2f432d78561aca3e893832e1" translate="yes" xml:space="preserve">
          <source>No matching is done. This value is returned as the match type by a default constructed &lt;a href=&quot;qregularexpressionmatch&quot;&gt;QRegularExpressionMatch&lt;/a&gt; or &lt;a href=&quot;qregularexpressionmatchiterator&quot;&gt;QRegularExpressionMatchIterator&lt;/a&gt;. Using this match type is not very useful for the user, as no matching ever happens. This enum value has been introduced in Qt 5.1.</source>
          <target state="translated">일치하지 않습니다. 이 값은 기본 생성 된 &lt;a href=&quot;qregularexpressionmatch&quot;&gt;QRegularExpressionMatch&lt;/a&gt; 또는 &lt;a href=&quot;qregularexpressionmatchiterator&quot;&gt;QRegularExpressionMatchIterator에&lt;/a&gt; 의해 일치 유형으로 리턴됩니다 . 이 일치 유형을 사용하면 일치하는 항목이 없으므로 사용자에게별로 유용하지 않습니다. 이 열거 형 값은 Qt 5.1에 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="10d3f3571010a8601447016b451078f1bc1569c2" translate="yes" xml:space="preserve">
          <source>No modifier key is pressed.</source>
          <target state="translated">수정 자 키를 누르지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="9cae50c43368e59db34118232fb5c5217eaddc23" translate="yes" xml:space="preserve">
          <source>No mouse events are propagated to this component, which means that controls like Button will not function when used within it. You can check if the mouse is over this section by comparing &lt;code&gt;control.currentIndex&lt;/code&gt; to &lt;code&gt;styleData.index&lt;/code&gt;.</source>
          <target state="translated">이 구성 요소에 마우스 이벤트가 전달되지 않습니다. 즉, Button과 같은 컨트롤은 그 안에 사용될 때 작동하지 않습니다. &lt;code&gt;control.currentIndex&lt;/code&gt; 와 &lt;code&gt;styleData.index&lt;/code&gt; 를 비교하여 마우스가이 섹션 위에 있는지 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b97adebe9defd3010d96532eff3566b234e4878e" translate="yes" xml:space="preserve">
          <source>No namespace processing is performed either.</source>
          <target state="translated">네임 스페이스 처리도 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0146cae24d5c20f8522eea9f5c83f1aa22f47d3a" translate="yes" xml:space="preserve">
          <source>No namespace processing is performed.</source>
          <target state="translated">네임 스페이스 처리가 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b96618c4ba871d4b2c23a2194d4dcf13bec37535" translate="yes" xml:space="preserve">
          <source>No navigation features are supported.</source>
          <target state="translated">탐색 기능이 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d748228335e67fc15628ed4c389937c097009213" translate="yes" xml:space="preserve">
          <source>No network service available.</source>
          <target state="translated">사용 가능한 네트워크 서비스가 없습니다.</target>
        </trans-unit>
        <trans-unit id="03ff0c460a1f05f7656e2e41100eb2323c306c73" translate="yes" xml:space="preserve">
          <source>No options.</source>
          <target state="translated">옵션이 없습니다.</target>
        </trans-unit>
        <trans-unit id="17702254fe2b7d0ef91d2b79f62958c5068b1c1f" translate="yes" xml:space="preserve">
          <source>No parity bit it sent. This is the most common parity setting. Error detection is handled by the communication protocol.</source>
          <target state="translated">보낸 패리티 비트가 없습니다. 이것이 가장 일반적인 패리티 설정입니다. 에러 검출은 통신 프로토콜에 의해 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="3e0862f9cc42f13cb6f43ecc8e9dcd64d09cfbf7" translate="yes" xml:space="preserve">
          <source>No pattern options are set.</source>
          <target state="translated">패턴 옵션이 설정되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="caa16e4097ff65e50ee690a6f020728719815fdb" translate="yes" xml:space="preserve">
          <source>No places features are supported.</source>
          <target state="translated">지원되는 장소 기능이 없습니다.</target>
        </trans-unit>
        <trans-unit id="694fa8555ee309a1fb67d6a1780f50a2ef325e04" translate="yes" xml:space="preserve">
          <source>No policy in force, usage is unrestricted.</source>
          <target state="translated">시행중인 정책이 없으며 사용이 제한되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6756b0ce5d9ee8658119bf895b6efbdeedb4e5da" translate="yes" xml:space="preserve">
          <source>No proxying is used</source>
          <target state="translated">프록 싱이 사용되지 않습니다</target>
        </trans-unit>
        <trans-unit id="096dc58878299f4c0ed278013a387f5506c14409" translate="yes" xml:space="preserve">
          <source>No relevance hint is given to the provider.</source>
          <target state="translated">제공자에게 관련 힌트가 제공되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b67dc49dae957fcea58f42dc89f14745a3ea1e6d" translate="yes" xml:space="preserve">
          <source>No role; this special role is often used to indicate that a role has not been assigned.</source>
          <target state="translated">역할이 없습니다. 이 특수 역할은 역할이 할당되지 않았 음을 나타내는 데 종종 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="268ac35e888187b33ffc67afd63881719e10d9c6" translate="yes" xml:space="preserve">
          <source>No routing features are supported.</source>
          <target state="translated">라우팅 기능이 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="96cfc340f611ce8f57adc1566458e32d73ce5702" translate="yes" xml:space="preserve">
          <source>No search query has been executed. The model is empty.</source>
          <target state="translated">검색어가 실행되지 않았습니다. 모델이 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c721d5e74cb4de2f86b757017772ec7e6f23c03" translate="yes" xml:space="preserve">
          <source>No segment data should be included with the route</source>
          <target state="translated">경로에 구간 데이터를 포함해서는 안됩니다</target>
        </trans-unit>
        <trans-unit id="d7a6bd135aacf82dbfdd5ad18c41f0c4154c5d8c" translate="yes" xml:space="preserve">
          <source>No segment data should be included with the route. A route requested with this level of segment detail will initialize &lt;a href=&quot;qgeoroutesegment#path&quot;&gt;QGeoRouteSegment::path&lt;/a&gt;() as a straight line between the positions of the previous and next &lt;a href=&quot;qgeomaneuver&quot;&gt;QGeoManeuver&lt;/a&gt; instances.</source>
          <target state="translated">경로에 구간 데이터가 포함되어서는 안됩니다. 이 레벨의 세그먼트 세부 사항으로 요청 된 라우트는 &lt;a href=&quot;qgeoroutesegment#path&quot;&gt;QGeoRouteSegment :: path&lt;/a&gt; ()를 이전 및 다음 &lt;a href=&quot;qgeomaneuver&quot;&gt;QGeoManeuver&lt;/a&gt; 인스턴스 의 위치 사이의 직선으로 초기화 합니다.</target>
        </trans-unit>
        <trans-unit id="31f9ddb9116452c1585930342d4bf4fddf662dec" translate="yes" xml:space="preserve">
          <source>No selection will be made.</source>
          <target state="translated">선택하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="98479fc3edc81f1195f7c382688d28e029825a84" translate="yes" xml:space="preserve">
          <source>No series type.</source>
          <target state="translated">시리즈 타입이 없습니다.</target>
        </trans-unit>
        <trans-unit id="9ad94fe8cc7b13bffab416df7b852fb0145aabe0" translate="yes" xml:space="preserve">
          <source>No set of general guidelines can replace a solid understanding of the underlying principles of computer science combined with a practical knowledge of the implementation details of the platform for which the application developer is developing. Furthermore, no amount of theoretical calculation can replace a good set of benchmarks and analysis tools when making trade-off decisions.</source>
          <target state="translated">컴퓨터 개발자의 기본 원리에 대한 확실한 이해와 응용 프로그램 개발자가 개발중인 플랫폼의 구현 세부 사항에 대한 실질적인 지식을 대체 할 수있는 일반적인 지침은 없습니다. 게다가, 트레이드 오프 결정을 내릴 때 이론적 계산이 훌륭한 벤치 마크 및 분석 도구를 대체 할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="865209c45aa3054f6c1cb0d4d9701b9aad71dbc4" translate="yes" xml:space="preserve">
          <source>No sort indicator is needed</source>
          <target state="translated">정렬 표시기가 필요하지 않습니다</target>
        </trans-unit>
        <trans-unit id="621052f21cfc2d2892467691d2da3235e381d1f2" translate="yes" xml:space="preserve">
          <source>No source has been set or the source is null.</source>
          <target state="translated">소스가 설정되지 않았거나 소스가 널입니다.</target>
        </trans-unit>
        <trans-unit id="081a22c5415fe12b5b7e318a1fa27d489427f272" translate="yes" xml:space="preserve">
          <source>No space left on device.</source>
          <target state="translated">기기에 남은 공간이 없습니다.</target>
        </trans-unit>
        <trans-unit id="cf33c4a137bca49d69d38325acb25bee6b6095c5" translate="yes" xml:space="preserve">
          <source>No specific sandboxing desired</source>
          <target state="translated">특정 샌드 박싱이 필요하지 않음</target>
        </trans-unit>
        <trans-unit id="2b2ac9ca8f524fad33b8d9ab919168320bdfcc46" translate="yes" xml:space="preserve">
          <source>No status received</source>
          <target state="translated">상태가 수신되지 않았습니다</target>
        </trans-unit>
        <trans-unit id="6adec22206eff7fcff8da47561b3516d0992c3d3" translate="yes" xml:space="preserve">
          <source>No token has been retrieved.</source>
          <target state="translated">검색된 토큰이 없습니다.</target>
        </trans-unit>
        <trans-unit id="bef4e0b6c03c149572ac12556a2bbf677e54978f" translate="yes" xml:space="preserve">
          <source>No transformation should be applied.</source>
          <target state="translated">변환이 적용되지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="32869ce3e4d64eb3b2952ad2b3e32e4f44b026b8" translate="yes" xml:space="preserve">
          <source>No two rectangles may abut horizontally (they should be combined into a single wider rectangle in that case).</source>
          <target state="translated">두 개의 사각형은 가로로 접할 수 없습니다 (이 경우 하나의 더 넓은 사각형으로 결합해야 함).</target>
        </trans-unit>
        <trans-unit id="06b4993408a9344fbb9b0e82e356178d0b27250e" translate="yes" xml:space="preserve">
          <source>No user interaction is possible</source>
          <target state="translated">사용자 상호 작용이 불가능합니다</target>
        </trans-unit>
        <trans-unit id="c1a32b7f5c829c20433e447ad31bb3c104ec7e08" translate="yes" xml:space="preserve">
          <source>No zooming area is specified, and therefore zooming is not enabled.</source>
          <target state="translated">확대 / 축소 영역이 지정되지 않았으므로 확대 / 축소를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3bb5ebfcbb80e9316141f0bb85274978a21e3731" translate="yes" xml:space="preserve">
          <source>No*</source>
          <target state="translated">No*</target>
        </trans-unit>
        <trans-unit id="1a89f4415d22ba352a84d748a0e43c3ae425cc45" translate="yes" xml:space="preserve">
          <source>NoDepthMask</source>
          <target state="translated">NoDepthMask</target>
        </trans-unit>
        <trans-unit id="1d2ced94c34321139a88468ac1234e070b9aa2e2" translate="yes" xml:space="preserve">
          <source>NoDepthMask (QML type)</source>
          <target state="translated">NoDepthMask (QML 유형)</target>
        </trans-unit>
        <trans-unit id="630a3fc3f70f4e4a3a36ad10b711a45c9cfdc919" translate="yes" xml:space="preserve">
          <source>NoDepthMask QML Type</source>
          <target state="translated">NoDepthMask QML 유형</target>
        </trans-unit>
        <trans-unit id="eae54b3dbd10acda4905362c06a79176211feba0" translate="yes" xml:space="preserve">
          <source>NoDraw</source>
          <target state="translated">NoDraw</target>
        </trans-unit>
        <trans-unit id="d1e3b7bd3b6e9c218d77cde1e9cce5c0ad2b329c" translate="yes" xml:space="preserve">
          <source>NoDraw (QML type)</source>
          <target state="translated">NoDraw (QML 유형)</target>
        </trans-unit>
        <trans-unit id="c87c1b49f4ff4c851d6976cbfbc2f3dd6ca9a9ee" translate="yes" xml:space="preserve">
          <source>NoDraw QML Type</source>
          <target state="translated">NoDraw QML 유형</target>
        </trans-unit>
        <trans-unit id="d2eb06022116ea8d4db65621e6edb4e108cf0bd0" translate="yes" xml:space="preserve">
          <source>NoError</source>
          <target state="translated">NoError</target>
        </trans-unit>
        <trans-unit id="d18527b73f860dcabfae30b7085ffcfb13d7b846" translate="yes" xml:space="preserve">
          <source>NoMedia - no media has been set.</source>
          <target state="translated">미디어 없음-미디어가 설정되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="260f7a8cd4f6938b3cc185a619847cb83d670219" translate="yes" xml:space="preserve">
          <source>Node</source>
          <target state="translated">Node</target>
        </trans-unit>
        <trans-unit id="2faacd1c358246573b6c16f7102bfefb78cb3e48" translate="yes" xml:space="preserve">
          <source>Node (QML type)</source>
          <target state="translated">노드 (QML 유형)</target>
        </trans-unit>
        <trans-unit id="16a624bc363703f03066911e1d6ba07d27b248f8" translate="yes" xml:space="preserve">
          <source>Node Ownership</source>
          <target state="translated">노드 소유권</target>
        </trans-unit>
        <trans-unit id="7a1dcf429df5bf47d8c30238542017e90913b54b" translate="yes" xml:space="preserve">
          <source>Node QML Type</source>
          <target state="translated">노드 QML 유형</target>
        </trans-unit>
        <trans-unit id="5a65c8cd9db3a4c4f9b9783f1a02690f4a5e5ba2" translate="yes" xml:space="preserve">
          <source>Node Test</source>
          <target state="translated">노드 테스트</target>
        </trans-unit>
        <trans-unit id="ef1e6eaa9a5dc6b5208904520b59cf46cf059cdc" translate="yes" xml:space="preserve">
          <source>Node Tests</source>
          <target state="translated">노드 테스트</target>
        </trans-unit>
        <trans-unit id="33d6848a140f44110c77c4ebaec0484d26d02ccc" translate="yes" xml:space="preserve">
          <source>Node Type</source>
          <target state="translated">노드 유형</target>
        </trans-unit>
        <trans-unit id="30fc3dca1dbd7568fb34fa2ad8afa7ad4dc8a227" translate="yes" xml:space="preserve">
          <source>Node-local: Addresses that are only used for communicating with services on the same interface (e.g., the loopback interface &quot;::1&quot;).</source>
          <target state="translated">노드 로컬 : 동일한 인터페이스에서 서비스와 통신하는 데만 사용되는 주소 (예 : 루프백 인터페이스 &quot;:: 1&quot;).</target>
        </trans-unit>
        <trans-unit id="9c13c4a041b14dc7616df500f6c4cfbd31bccb8f" translate="yes" xml:space="preserve">
          <source>Node.childNodes</source>
          <target state="translated">Node.childNodes</target>
        </trans-unit>
        <trans-unit id="c7415f545bb59efd83dc79c5ba3cf2ce1085d1ed" translate="yes" xml:space="preserve">
          <source>Node.data</source>
          <target state="translated">Node.data</target>
        </trans-unit>
        <trans-unit id="1d7185d40ac996e92020f97420b43962e6787e89" translate="yes" xml:space="preserve">
          <source>Node.heartbeatInterval</source>
          <target state="translated">Node.heartbeatInterval</target>
        </trans-unit>
        <trans-unit id="d7b66c9f183dc07487c68aa185b60760642c9a4b" translate="yes" xml:space="preserve">
          <source>Node.persistedStore</source>
          <target state="translated">Node.persistedStore</target>
        </trans-unit>
        <trans-unit id="222dd65a47477be664abe018586f315028c701c1" translate="yes" xml:space="preserve">
          <source>Node.propertyTrackingOverrides</source>
          <target state="translated">Node.propertyTrackingOverrides</target>
        </trans-unit>
        <trans-unit id="9d3ca3b690dff8f42ceb7d4d09a01580dfa72f15" translate="yes" xml:space="preserve">
          <source>Node.registryUrl</source>
          <target state="translated">Node.registryUrl</target>
        </trans-unit>
        <trans-unit id="39e5f316e9cf392f74d7d7909be35e85269bdff6" translate="yes" xml:space="preserve">
          <source>NodeInstantiator (QML type)</source>
          <target state="translated">NodeInstantiator (QML 유형)</target>
        </trans-unit>
        <trans-unit id="0929820fb528d66cdee90be834ad10fff7e30ae6" translate="yes" xml:space="preserve">
          <source>NodeInstantiator QML Type</source>
          <target state="translated">NodeInstantiator QML 유형</target>
        </trans-unit>
        <trans-unit id="bb0507832684c1125b9d413c16229e3c027bfe4f" translate="yes" xml:space="preserve">
          <source>NodeInstantiator.active</source>
          <target state="translated">NodeInstantiator.active</target>
        </trans-unit>
        <trans-unit id="1d7aa2549db829d685f42638779adc40043e2401" translate="yes" xml:space="preserve">
          <source>NodeInstantiator.asynchronous</source>
          <target state="translated">NodeInstantiator.asynchronous</target>
        </trans-unit>
        <trans-unit id="87a0fb697c7cd29367e1de4c9a9ac9529a11cccc" translate="yes" xml:space="preserve">
          <source>NodeInstantiator.count</source>
          <target state="translated">NodeInstantiator.count</target>
        </trans-unit>
        <trans-unit id="3672e6a585979e6414f3821c37f9e10688602e6f" translate="yes" xml:space="preserve">
          <source>NodeInstantiator.delegate</source>
          <target state="translated">NodeInstantiator.delegate</target>
        </trans-unit>
        <trans-unit id="e2c62517af76b546acd1804de4ad874076c9314b" translate="yes" xml:space="preserve">
          <source>NodeInstantiator.model</source>
          <target state="translated">NodeInstantiator.model</target>
        </trans-unit>
        <trans-unit id="81a12c361075a5db57dca08ef9dbe3f1ca584f7b" translate="yes" xml:space="preserve">
          <source>NodeInstantiator.object</source>
          <target state="translated">NodeInstantiator.object</target>
        </trans-unit>
        <trans-unit id="0e99591ea57745411e90ce42cc7f1b4177dbbb24" translate="yes" xml:space="preserve">
          <source>NodeInstantiator.objectAdded()</source>
          <target state="translated">NodeInstantiator.objectAdded()</target>
        </trans-unit>
        <trans-unit id="45147ed5e87238c05a143107e8450d0505b8147f" translate="yes" xml:space="preserve">
          <source>NodeInstantiator.objectAt()</source>
          <target state="translated">NodeInstantiator.objectAt()</target>
        </trans-unit>
        <trans-unit id="6163158e744b1be2755cf46aeafb5d9e4835f540" translate="yes" xml:space="preserve">
          <source>NodeInstantiator.objectRemoved()</source>
          <target state="translated">NodeInstantiator.objectRemoved()</target>
        </trans-unit>
        <trans-unit id="9e325452c6548fc2449564842660d75ef3b1eb73" translate="yes" xml:space="preserve">
          <source>Nodes</source>
          <target state="translated">Nodes</target>
        </trans-unit>
        <trans-unit id="73990f52ec49bd6a52dea794901f611e6b737886" translate="yes" xml:space="preserve">
          <source>Nodes are inserted with &lt;a href=&quot;qdomnode#insertBefore&quot;&gt;insertBefore&lt;/a&gt;(), &lt;a href=&quot;qdomnode#insertAfter&quot;&gt;insertAfter&lt;/a&gt;() or &lt;a href=&quot;qdomnode#appendChild&quot;&gt;appendChild&lt;/a&gt;(). You can replace one node with another using &lt;a href=&quot;qdomnode#replaceChild&quot;&gt;replaceChild&lt;/a&gt;() and remove a node with &lt;a href=&quot;qdomnode#removeChild&quot;&gt;removeChild&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qdomnode#insertBefore&quot;&gt;insertBefore&lt;/a&gt; (), &lt;a href=&quot;qdomnode#insertAfter&quot;&gt;insertAfter&lt;/a&gt; () 또는 &lt;a href=&quot;qdomnode#appendChild&quot;&gt;appendChild&lt;/a&gt; ()를 사용 하여 노드를 삽입 합니다. &lt;a href=&quot;qdomnode#replaceChild&quot;&gt;replaceChild&lt;/a&gt; ()를 사용하여 한 노드를 다른 노드로 바꾸고 &lt;a href=&quot;qdomnode#removeChild&quot;&gt;removeChild&lt;/a&gt; () 로 노드를 제거 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a890f0392a70ee43979c04a3a88baea3c91c7e07" translate="yes" xml:space="preserve">
          <source>Nodes have a couple of &lt;a href=&quot;qremoteobjecthostbase#enableRemoting&quot;&gt;enableRemoting()&lt;/a&gt; methods that are used to share objects on the network (this will produce an error if the Node is not a Host Node however). Other processes/devices that want to interact with a shared object use one of the &lt;a href=&quot;qremoteobjectnode#acquire&quot;&gt;node's acquire()&lt;/a&gt; methods to instantiate a replica.</source>
          <target state="translated">노드에는 네트워크에서 객체를 공유하는 데 사용되는 몇 가지 &lt;a href=&quot;qremoteobjecthostbase#enableRemoting&quot;&gt;enableRemoting ()&lt;/a&gt; 메소드가 있습니다 (그러나 노드가 호스트 노드가 아닌 경우 오류가 발생 함). 공유 객체와 상호 작용하려는 다른 프로세스 / 장치는 &lt;a href=&quot;qremoteobjectnode#acquire&quot;&gt;노드의 acquire ()&lt;/a&gt; 메소드 중 하나를 사용 하여 복제본을 인스턴스화합니다.</target>
        </trans-unit>
        <trans-unit id="ff4644b03bcfa5fc36dc287e9eb8ebb71b8ea45f" translate="yes" xml:space="preserve">
          <source>Nodes have a virtual &lt;a href=&quot;qsgnode#preprocess&quot;&gt;QSGNode::preprocess&lt;/a&gt;() function, which will be called before the scene graph is rendered. Node subclasses can set the flag &lt;a href=&quot;qsgnode#Flag-enum&quot;&gt;QSGNode::UsePreprocess&lt;/a&gt; and override the &lt;a href=&quot;qsgnode#preprocess&quot;&gt;QSGNode::preprocess&lt;/a&gt;() function to do final preparation of their node. For example, dividing a bezier curve into the correct level of detail for the current scale factor or updating a section of a texture.</source>
          <target state="translated">노드에는 가상 &lt;a href=&quot;qsgnode#preprocess&quot;&gt;QSGNode :: preprocess&lt;/a&gt; () 함수가 있으며 장면 그래프가 렌더링되기 전에 호출됩니다. 노드 서브 클래스는 &lt;a href=&quot;qsgnode#Flag-enum&quot;&gt;QSGNode :: UsePreprocess&lt;/a&gt; 플래그를 설정하고 &lt;a href=&quot;qsgnode#preprocess&quot;&gt;QSGNode :: preprocess&lt;/a&gt; () 함수를 대체하여 노드의 최종 준비를 수행 할 수 있습니다. 예를 들어 베 지어 곡선을 현재 축척 비율에 대한 정확한 세부 수준으로 나누거나 텍스처 섹션을 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="1ebee72678859cff79a7fa65a52757fa5af07f91" translate="yes" xml:space="preserve">
          <source>Nodes may connect to each other directly using &lt;a href=&quot;qremoteobjectnode#connectToNode&quot;&gt;connectToNode&lt;/a&gt;, or they can use the &lt;a href=&quot;qremoteobjectregistry&quot;&gt;QRemoteObjectRegistry&lt;/a&gt; to simplify connections.</source>
          <target state="translated">노드는 &lt;a href=&quot;qremoteobjectnode#connectToNode&quot;&gt;connectToNode를&lt;/a&gt; 사용하여 직접 서로 연결 하거나 &lt;a href=&quot;qremoteobjectregistry&quot;&gt;QRemoteObjectRegistry&lt;/a&gt; 를 사용하여 연결을 단순화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ba0699ab58edd42a7d018746417fc4c82115a1ab" translate="yes" xml:space="preserve">
          <source>Nodes only support connection to one &lt;a href=&quot;qtremoteobjects-registry#registry&quot;&gt;registry&lt;/a&gt;, calling &lt;a href=&quot;qremoteobjectnode#registryUrl-prop&quot;&gt;QRemoteObjectNode::setRegistryUrl&lt;/a&gt; when a Registry is already set is considered an error. For something like a secure and insecure network (where different Registries would be applicable), the recommendation is to create separate Nodes to connect to each, in effect creating two independent Qt Remote Objects networks.</source>
          <target state="translated">노드 는 레지스트리가 이미 설정된 경우 &lt;a href=&quot;qremoteobjectnode#registryUrl-prop&quot;&gt;QRemoteObjectNode :: setRegistryUrl을&lt;/a&gt; 호출 하는 하나의 &lt;a href=&quot;qtremoteobjects-registry#registry&quot;&gt;레지스트리에&lt;/a&gt; 대한 연결 만 지원 하며 오류로 간주됩니다. 안전하고 안전하지 않은 네트워크 (다른 레지스트리가 적용되는 경우)와 같은 경우 별도의 노드를 만들어 서로 연결하여 두 개의 독립적 인 Qt 원격 개체 네트워크를 만드는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="d8a4d96815d59bde5bfd503fc3636f6ea9113162" translate="yes" xml:space="preserve">
          <source>Nodes, by themselves, don&amp;rsquo;t provide much use. The value comes from adding &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; classes to a node for sharing. Any peer node can then request a copy/instance of the shared object from the node that shares it (called the</source>
          <target state="translated">노드 자체는 그다지 유용하지 않습니다. 공유 할 노드에 &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 클래스를 추가하여 값을 가져옵니다 . 그런 다음 모든 피어 노드는 공유 노드를 공유하는 노드에서 공유 객체의 복사 / 인스턴스를 요청할 수 있습니다 (</target>
        </trans-unit>
        <trans-unit id="e9e86256f7bad0dbd6828e7a90557c0d48737e41" translate="yes" xml:space="preserve">
          <source>Non-Item objects may use states through the &lt;a href=&quot;qml-qtquick-stategroup&quot;&gt;StateGroup&lt;/a&gt; type.</source>
          <target state="translated">비 항목 객체는 &lt;a href=&quot;qml-qtquick-stategroup&quot;&gt;StateGroup&lt;/a&gt; 유형을 통해 상태를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6276f0c299230b825417d3965c54f86f514952ec" translate="yes" xml:space="preserve">
          <source>Non-attached Scroll Bars</source>
          <target state="translated">부착되지 않은 스크롤 막대</target>
        </trans-unit>
        <trans-unit id="9362bd61b51d5152dfbae769699522c60b1649f3" translate="yes" xml:space="preserve">
          <source>Non-attached Scroll Indicators</source>
          <target state="translated">부착되지 않은 스크롤 표시기</target>
        </trans-unit>
        <trans-unit id="5223ee77cc19aabff1fc87ba38dc610a435ef809" translate="yes" xml:space="preserve">
          <source>Non-breakable text</source>
          <target state="translated">깨지지 않는 텍스트</target>
        </trans-unit>
        <trans-unit id="15bf21e487b389622890a596e34f6fc7e8f358bf" translate="yes" xml:space="preserve">
          <source>Non-breaking space.</source>
          <target state="translated">비파괴 공간.</target>
        </trans-unit>
        <trans-unit id="c5cadad8e7f92fdc6cc1afd5247d9c4d52cb2986" translate="yes" xml:space="preserve">
          <source>Non-capturing parentheses are also supported, with the same (?:pattern) syntax.</source>
          <target state="translated">동일한 (? : pattern) 구문을 사용하여 캡처하지 않는 괄호도 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="b7181cc7a6f1dca6a2d49d447bf66b160edb68ca" translate="yes" xml:space="preserve">
          <source>Non-configurable properties cannot be deleted.</source>
          <target state="translated">구성 할 수없는 속성은 삭제할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="fa4d03074c0b99b90528bfb67dc01ffcba2be859" translate="yes" xml:space="preserve">
          <source>Non-creatable abstract base for materials. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">재료에 대한 생성 불가능한 추상 기반. &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7a038d7b18b864e7e3f5f81aa1f667340e63592c" translate="yes" xml:space="preserve">
          <source>Non-module Namespace Imports</source>
          <target state="translated">비 모듈 네임 스페이스 가져 오기</target>
        </trans-unit>
        <trans-unit id="fb8b24d7946f91e91d76f522345b8c44b842e4f4" translate="yes" xml:space="preserve">
          <source>Non-spontaneous show events are sent to widgets immediately before they are shown. The spontaneous show events of windows are delivered afterwards.</source>
          <target state="translated">자발적인 쇼 이벤트는 표시되기 직전에 위젯으로 전송됩니다. 자발적인 창문 쇼 이벤트가 나중에 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="58ff5229d38da23617ecee2d0708ea4305553037" translate="yes" xml:space="preserve">
          <source>Non-standard delimiters</source>
          <target state="translated">비표준 구분자</target>
        </trans-unit>
        <trans-unit id="73607959ac3fa3dd9656f59a604eea91937b1a5b" translate="yes" xml:space="preserve">
          <source>Non-standard delimiters should be chosen from among what RFC 3986 calls &quot;sub-delimiters&quot;. They are:</source>
          <target state="translated">비표준 구분 기호는 RFC 3986이 &quot;하위 구분 기호&quot;라고 부르는 것 중에서 선택해야합니다. 그들은:</target>
        </trans-unit>
        <trans-unit id="80dffdb056406d0c06286319912320a2ccc1a2c0" translate="yes" xml:space="preserve">
          <source>Non-threaded Render Loops (&quot;basic&quot; and &quot;windows&quot;)</source>
          <target state="translated">스레드되지 않은 렌더 루프 ( &quot;기본&quot;및 &quot;창&quot;)</target>
        </trans-unit>
        <trans-unit id="85379b4f454e1a1ec90576665b6330ebec5ecb17" translate="yes" xml:space="preserve">
          <source>Non-trivial program logic is best separated into a separate JavaScript file. This file can be imported into QML using an &lt;code&gt;import&lt;/code&gt; statement, like the QML &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtqml-modules-topic.html#&quot;&gt;modules&lt;/a&gt;.</source>
          <target state="translated">사소한 프로그램 논리는 별도의 JavaScript 파일로 분리하는 것이 가장 좋습니다. 이 파일은 QML &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtqml-modules-topic.html#&quot;&gt;모듈&lt;/a&gt; 과 같은 &lt;code&gt;import&lt;/code&gt; 문을 사용하여 QML로 가져올 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0cae7d1907e1ec054bbcb462e9150a496a2aef41" translate="yes" xml:space="preserve">
          <source>Non-window widgets are child widgets, displayed within their parent widgets. Most widgets in Qt are mainly useful as child widgets. For example, it is possible to display a button as a top-level window, but most people prefer to put their buttons inside other widgets, such as &lt;a href=&quot;qdialog&quot;&gt;QDialog&lt;/a&gt;.</source>
          <target state="translated">비 창조 위젯은 상위 위젯 내에 표시되는 하위 위젯입니다. Qt의 대부분의 위젯은 주로 하위 위젯으로 유용합니다. 예를 들어, 단추를 최상위 창으로 표시 할 수 있지만 대부분의 사람들은 단추를 &lt;a href=&quot;qdialog&quot;&gt;QDialog&lt;/a&gt; 와 같은 다른 위젯에 배치하는 것을 선호합니다 .</target>
        </trans-unit>
        <trans-unit id="efd9fba9d8cf5c2911fd3637507059d2379a47cd" translate="yes" xml:space="preserve">
          <source>Non-zero winding fill rule.</source>
          <target state="translated">0이 아닌 와인딩 채우기 규칙.</target>
        </trans-unit>
        <trans-unit id="6eef6648406c333a4035cd5e60d0bf2ecf2606d7" translate="yes" xml:space="preserve">
          <source>None</source>
          <target state="translated">None</target>
        </trans-unit>
        <trans-unit id="f5a2b73ba7ff78806dc13321133e57fb1713be8f" translate="yes" xml:space="preserve">
          <source>None of the above.</source>
          <target state="translated">위의 어느 것도 아닙니다.</target>
        </trans-unit>
        <trans-unit id="7886314e8ebf0262af1d397f949489c67bb2ba1d" translate="yes" xml:space="preserve">
          <source>None of the buttons are checked.</source>
          <target state="translated">버튼이 확인되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="cf83a8cb40bb34fe81a6732864fb82cce5d11bdb" translate="yes" xml:space="preserve">
          <source>None of the options are enabled.</source>
          <target state="translated">활성화 된 옵션이 없습니다.</target>
        </trans-unit>
        <trans-unit id="0a892cc16753ffc8a2335b0c6b28684cfa10d535" translate="yes" xml:space="preserve">
          <source>None of the other layer properties have any effect when the layer is disabled.</source>
          <target state="translated">다른 레이어 속성은 레이어가 비활성화되어있을 때 아무런 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2c94a1d7df8a7b93c9aa610b38bcd712ead98797" translate="yes" xml:space="preserve">
          <source>None of the positioning methods.</source>
          <target state="translated">위치 결정 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="1461f445da137b2e6a0e80f578b4d32f6e79eec5" translate="yes" xml:space="preserve">
          <source>None of the values changed.</source>
          <target state="translated">값이 변경되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="c2a1b919b3200174dffbefe7bd662d030e2a57cf" translate="yes" xml:space="preserve">
          <source>Nonetheless, couldn't a template-based solution improve the performance of an application using signals and slots? While it is true that Qt adds a small overhead to the cost of calling a slot through a signal, the cost of the call is only a small proportion of the entire cost of a slot. Benchmarking against Qt's signals and slots system is typically done with empty slots. As soon as you do anything useful in your slots, for example a few simple string operations, the calling overhead becomes negligible. Qt's system is so optimized that anything that requires operator new or delete (for example, string operations or inserting/removing something from a template container) is significantly more expensive than emitting a signal.</source>
          <target state="translated">그럼에도 불구하고 템플릿 기반 솔루션이 신호와 슬롯을 사용하는 애플리케이션의 성능을 향상시킬 수 없었습니까? Qt가 신호를 통해 슬롯을 호출하는 비용에 작은 오버 헤드를 추가하는 것은 사실이지만, 호출 비용은 슬롯 전체 비용의 작은 비율에 지나지 않습니다. Qt의 신호 및 슬롯 시스템에 대한 벤치마킹은 일반적으로 빈 슬롯으로 수행됩니다. 몇 가지 간단한 문자열 작업과 같이 슬롯에서 유용한 작업을 수행하면 호출 오버 헤드는 무시할 수 있습니다. Qt의 시스템은 연산자 새로 만들기 또는 삭제 (예 : 문자열 작업 또는 템플릿 컨테이너에서 항목 삽입 / 제거)가 필요한 것이 신호를 방출하는 것보다 훨씬 비싸도록 최적화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="992352057ac7a1f4eb8027b59c17e1bc9040cdae" translate="yes" xml:space="preserve">
          <source>Nor does X11 provide a way to maximize a window. &lt;a href=&quot;qwidget#showMaximized&quot;&gt;QWidget::showMaximized&lt;/a&gt;() has to emulate the feature. Its result depends on the result of &lt;a href=&quot;qwidget#frameGeometry-prop&quot;&gt;QWidget::frameGeometry&lt;/a&gt;() and the capability of the window manager to do proper window placement, neither of which can be guaranteed.</source>
          <target state="translated">X11은 창을 최대화하는 방법도 제공하지 않습니다. &lt;a href=&quot;qwidget#showMaximized&quot;&gt;QWidget :: showMaximized&lt;/a&gt; ()는 기능을 에뮬레이션해야합니다. 결과는 &lt;a href=&quot;qwidget#frameGeometry-prop&quot;&gt;QWidget :: frameGeometry&lt;/a&gt; () 의 결과 와 적절한 창 배치를 수행 할 수있는 창 관리자의 기능에 따라 달라집니다 .</target>
        </trans-unit>
        <trans-unit id="45e118d0563ea8581f830f46e85b60ae714faae4" translate="yes" xml:space="preserve">
          <source>Normal</source>
          <target state="translated">Normal</target>
        </trans-unit>
        <trans-unit id="3736ee6b2e7fd5a4ab3b5f833cf7ec56e405db1b" translate="yes" xml:space="preserve">
          <source>Normal (restore) button on title bars.</source>
          <target state="translated">제목 표시 줄의 일반 (복원) 버튼</target>
        </trans-unit>
        <trans-unit id="7ec88960224e7a0b423ba63d8e01b01bc57e99b4" translate="yes" xml:space="preserve">
          <source>Normal (restore) button.</source>
          <target state="translated">일반 (복원) 버튼</target>
        </trans-unit>
        <trans-unit id="f70f2dfa5661c4bda711e98df64e2d6cb2d69912" translate="yes" xml:space="preserve">
          <source>Normal C++ classes and functions can be used from managed .NET code by providing thin wrapper classes written in MC++. The wrapper class will take care of forwarding the calls to the normal C++ functions or methods, and converting parameter data as necessary. Since the wrapper class is a managed class, it can be used without further ado in any managed .NET application, whether written in C#, VB.NET, MC++ or other managed programming language.</source>
          <target state="translated">MC ++로 작성된 씬 래퍼 클래스를 제공하여 관리되는 .NET 코드에서 일반 C ++ 클래스 및 함수를 사용할 수 있습니다. 랩퍼 클래스는 호출을 일반 C ++ 함수 또는 메소드로 전달하고 필요에 따라 매개 변수 데이터를 변환합니다. 래퍼 클래스는 관리되는 클래스이므로 C #, VB.NET, MC ++ 또는 기타 관리되는 프로그래밍 언어로 작성된 관리되는 .NET 응용 프로그램에서 더 이상 사용하지 않고도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="346f25e5c8412dc95329f2a62136a44be69a0604" translate="yes" xml:space="preserve">
          <source>Normal Matching</source>
          <target state="translated">정상 매칭</target>
        </trans-unit>
        <trans-unit id="e504c4e197ed776f28166af32c8af402c7ec4f2d" translate="yes" xml:space="preserve">
          <source>Normal closure</source>
          <target state="translated">정상적인 폐쇄</target>
        </trans-unit>
        <trans-unit id="0739a40cb9287a423939c89161696333540e990c" translate="yes" xml:space="preserve">
          <source>Normal glyphs used in unstyled text.</source>
          <target state="translated">스타일이 지정되지 않은 텍스트에 사용되는 일반 글리프입니다.</target>
        </trans-unit>
        <trans-unit id="f604538414473b15cb5f94825afefbabc5f8a392" translate="yes" xml:space="preserve">
          <source>Normal priority</source>
          <target state="translated">보통 우선 순위</target>
        </trans-unit>
        <trans-unit id="52426b8e08a084fba86443b9a8b3ea50fc0b0f22" translate="yes" xml:space="preserve">
          <source>Normal sockets requesting a connection to a remote server, like &lt;a href=&quot;qtcpsocket&quot;&gt;QTcpSocket&lt;/a&gt;. The peer hostname and peer port match the values passed to &lt;a href=&quot;qabstractsocket#connectToHost&quot;&gt;QTcpSocket::connectToHost&lt;/a&gt;(). The local port is usually -1, indicating the socket has no preference in which port should be used. The URL component is not used.</source>
          <target state="translated">&lt;a href=&quot;qtcpsocket&quot;&gt;QTcpSocket&lt;/a&gt; 과 같은 원격 서버에 대한 연결을 요청하는 일반 소켓 . 피어 호스트 이름 및 피어 포트는 &lt;a href=&quot;qabstractsocket#connectToHost&quot;&gt;QTcpSocket :: connectToHost&lt;/a&gt; ()에 전달 된 값과 일치합니다 . 로컬 포트는 일반적으로 -1이며, 소켓이 어떤 포트를 사용해야하는지 선호하지 않음을 나타냅니다. URL 구성 요소가 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4ff02f66f03fbe63be4c8c1d700369b61036d472" translate="yes" xml:space="preserve">
          <source>NormalDiffuseMapAlphaMaterial (QML type)</source>
          <target state="translated">NormalDiffuseMapAlphaMaterial (QML 유형)</target>
        </trans-unit>
        <trans-unit id="9f0f121cb323bdb855c8723469a47189f966d0f8" translate="yes" xml:space="preserve">
          <source>NormalDiffuseMapAlphaMaterial QML Type</source>
          <target state="translated">NormalDiffuseMapAlphaMaterial QML 유형</target>
        </trans-unit>
        <trans-unit id="5ae319288fc94a97a4f67dfa2c1c04d648afaf6e" translate="yes" xml:space="preserve">
          <source>NormalDiffuseMapAlphaMaterial.ambient</source>
          <target state="translated">NormalDiffuseMapAlphaMaterial.ambient</target>
        </trans-unit>
        <trans-unit id="710e5b3f22e4421c693c654b298ef90bd80d05ff" translate="yes" xml:space="preserve">
          <source>NormalDiffuseMapAlphaMaterial.diffuse</source>
          <target state="translated">NormalDiffuseMapAlphaMaterial.diffuse</target>
        </trans-unit>
        <trans-unit id="d4f2559c734631d2c5768c310433dd849637de34" translate="yes" xml:space="preserve">
          <source>NormalDiffuseMapAlphaMaterial.normal</source>
          <target state="translated">NormalDiffuseMapAlphaMaterial.normal</target>
        </trans-unit>
        <trans-unit id="88f2036e028a542bc90994c0036213bec52e4b5a" translate="yes" xml:space="preserve">
          <source>NormalDiffuseMapAlphaMaterial.shininess</source>
          <target state="translated">NormalDiffuseMapAlphaMaterial.shininess</target>
        </trans-unit>
        <trans-unit id="138e4fe2584bb7d86515176bce248270af2c21b7" translate="yes" xml:space="preserve">
          <source>NormalDiffuseMapAlphaMaterial.specular</source>
          <target state="translated">NormalDiffuseMapAlphaMaterial.specular</target>
        </trans-unit>
        <trans-unit id="6412d6ffcc76c25f7259c1da7a2eb8cb4a7d3c96" translate="yes" xml:space="preserve">
          <source>NormalDiffuseMapAlphaMaterial.textureScale</source>
          <target state="translated">NormalDiffuseMapAlphaMaterial.textureScale</target>
        </trans-unit>
        <trans-unit id="1f1efe8e16003bd03110ada0eb5b942d5b92afe0" translate="yes" xml:space="preserve">
          <source>NormalDiffuseMapMaterial (QML type)</source>
          <target state="translated">NormalDiffuseMapMaterial (QML 유형)</target>
        </trans-unit>
        <trans-unit id="c9f858640dc19343b23e1dee61e715e14b3d865a" translate="yes" xml:space="preserve">
          <source>NormalDiffuseMapMaterial QML Type</source>
          <target state="translated">NormalDiffuseMapMaterial QML 유형</target>
        </trans-unit>
        <trans-unit id="a4df8fcb2fe1b05452320e7b13dbcd44d583326b" translate="yes" xml:space="preserve">
          <source>NormalDiffuseMapMaterial.ambient</source>
          <target state="translated">NormalDiffuseMapMaterial.ambient</target>
        </trans-unit>
        <trans-unit id="074a144d591cf62ed44ce237e1f97854af44bb68" translate="yes" xml:space="preserve">
          <source>NormalDiffuseMapMaterial.diffuse</source>
          <target state="translated">NormalDiffuseMapMaterial.diffuse</target>
        </trans-unit>
        <trans-unit id="74038be5a2ce0293770a04cd13a8699a0c7cae95" translate="yes" xml:space="preserve">
          <source>NormalDiffuseMapMaterial.normal</source>
          <target state="translated">NormalDiffuseMapMaterial.normal</target>
        </trans-unit>
        <trans-unit id="4c0e1ab0c0ee46fb07049ea120dbc215fc526fde" translate="yes" xml:space="preserve">
          <source>NormalDiffuseMapMaterial.shininess</source>
          <target state="translated">NormalDiffuseMapMaterial.shininess</target>
        </trans-unit>
        <trans-unit id="f36e677c53c02750e63d151cd4129ebe68aa8322" translate="yes" xml:space="preserve">
          <source>NormalDiffuseMapMaterial.specular</source>
          <target state="translated">NormalDiffuseMapMaterial.specular</target>
        </trans-unit>
        <trans-unit id="689767af391cf8bc30d11e9ad8907c3bbce0c825" translate="yes" xml:space="preserve">
          <source>NormalDiffuseMapMaterial.textureScale</source>
          <target state="translated">NormalDiffuseMapMaterial.textureScale</target>
        </trans-unit>
        <trans-unit id="349d9ac23c035ee66228850833eaf71713db27da" translate="yes" xml:space="preserve">
          <source>NormalDiffuseSpecularMapMaterial (QML type)</source>
          <target state="translated">NormalDiffuseSpecularMapMaterial (QML 유형)</target>
        </trans-unit>
        <trans-unit id="a1896022049eff48a9081f3e6d61d708881cd754" translate="yes" xml:space="preserve">
          <source>NormalDiffuseSpecularMapMaterial QML Type</source>
          <target state="translated">NormalDiffuseSpecularMapMaterial QML 유형</target>
        </trans-unit>
        <trans-unit id="f31602c9f426c050c4c90bb214c75ada84136386" translate="yes" xml:space="preserve">
          <source>NormalDiffuseSpecularMapMaterial.ambient</source>
          <target state="translated">NormalDiffuseSpecularMapMaterial.ambient</target>
        </trans-unit>
        <trans-unit id="91600070295a98f6add0d310a1922598f81afd3b" translate="yes" xml:space="preserve">
          <source>NormalDiffuseSpecularMapMaterial.diffuse</source>
          <target state="translated">NormalDiffuseSpecularMapMaterial.diffuse</target>
        </trans-unit>
        <trans-unit id="463c8c381f7f05843dddccfc6018ad5091bdbd54" translate="yes" xml:space="preserve">
          <source>NormalDiffuseSpecularMapMaterial.normal</source>
          <target state="translated">NormalDiffuseSpecularMapMaterial.normal</target>
        </trans-unit>
        <trans-unit id="cd0df550097f0660258725a30bd15f3adb75d0b6" translate="yes" xml:space="preserve">
          <source>NormalDiffuseSpecularMapMaterial.shininess</source>
          <target state="translated">NormalDiffuseSpecularMapMaterial.shininess</target>
        </trans-unit>
        <trans-unit id="5b2d87597e5dca03fc91a55bdbf3afbc59e91716" translate="yes" xml:space="preserve">
          <source>NormalDiffuseSpecularMapMaterial.specular</source>
          <target state="translated">NormalDiffuseSpecularMapMaterial.specular</target>
        </trans-unit>
        <trans-unit id="a761f40a784a0388b64a95c1fe1ab10481f2400a" translate="yes" xml:space="preserve">
          <source>NormalDiffuseSpecularMapMaterial.textureScale</source>
          <target state="translated">NormalDiffuseSpecularMapMaterial.textureScale</target>
        </trans-unit>
        <trans-unit id="39208c598f8f515fde64f9754eb85c702248a1b1" translate="yes" xml:space="preserve">
          <source>Normalized</source>
          <target state="translated">Normalized</target>
        </trans-unit>
        <trans-unit id="2443adae128dbed73712a76e48f2046023f6ab74" translate="yes" xml:space="preserve">
          <source>Normalizes a</source>
          <target state="translated">정규화</target>
        </trans-unit>
        <trans-unit id="9560d5af79f830514f6451a7c9f1e6b5156b1ba4" translate="yes" xml:space="preserve">
          <source>Normalizes the currect vector in place. Nothing happens if this vector is a null vector or the length of the vector is very close to 1.</source>
          <target state="translated">정확한 벡터를 제자리로 정규화합니다. 이 벡터가 null 벡터이거나 벡터의 길이가 1에 매우 가까운 경우 아무 일도 일어나지 않습니다.</target>
        </trans-unit>
        <trans-unit id="84de5ff8cc5549fe0b2bd027b2bd47ff57a98b35" translate="yes" xml:space="preserve">
          <source>Normalizes the current quaternion in place. Nothing happens if this is a null quaternion or the length of the quaternion is very close to 1.</source>
          <target state="translated">현재 쿼터니언을 제자리로 정규화합니다. 이것이 null 쿼터니언이거나 쿼터니언의 길이가 1에 매우 가까운 경우 아무 일도 일어나지 않습니다.</target>
        </trans-unit>
        <trans-unit id="43ddcc6f2f9237bfc9ac9f9010e7d7dd3092f536" translate="yes" xml:space="preserve">
          <source>Normalizes the signature of the given</source>
          <target state="translated">주어진 서명을 정규화</target>
        </trans-unit>
        <trans-unit id="5029d632ac854071a43ce9d7c0fffddab82f2154" translate="yes" xml:space="preserve">
          <source>Normally &lt;code&gt;stop()&lt;/code&gt; stops the animation immediately, and the animation has no further influence on property values. In this example animation</source>
          <target state="translated">일반적으로 &lt;code&gt;stop()&lt;/code&gt; 은 애니메이션을 즉시 중지하며 애니메이션은 속성 값에 더 이상 영향을 미치지 않습니다. 이 예제에서는 애니메이션</target>
        </trans-unit>
        <trans-unit id="034d182db8d77526f8a2a9b256882c1c25192f94" translate="yes" xml:space="preserve">
          <source>Normally QML files can be loaded as types directly from other QML files, or using a qmldir file. This function allows registration of files to types from C++ code, such as when the type mapping needs to be procedurally determined at startup.</source>
          <target state="translated">일반적으로 QML 파일은 다른 QML 파일에서 직접 또는 qmldir 파일을 사용하여 유형으로로드 할 수 있습니다. 이 함수를 사용하면 시작시 형식 매핑을 절차 적으로 결정해야하는 경우와 같이 C ++ 코드에서 형식에 파일을 등록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6600d7d0393e89b9a7631e7bcbb16f238a29630b" translate="yes" xml:space="preserve">
          <source>Normally a slider increases as it moves up or to the right; upsideDown indicates that it should do the opposite (increase as it moves down or to the left). The default value is false, i.e. the slider increases as it moves up or to the right.</source>
          <target state="translated">일반적으로 슬라이더는 위쪽 또는 오른쪽으로 이동함에 따라 증가합니다. upsideDown은 반대 방향으로 수행해야 함을 나타냅니다 (아래 또는 왼쪽으로 이동함에 따라 증가). 기본값은 false입니다. 즉 슬라이더가 위로 또는 오른쪽으로 이동함에 따라 슬라이더가 증가합니다.</target>
        </trans-unit>
        <trans-unit id="435b01db9d98ea32e7c65115d1e7b78923d847ed" translate="yes" xml:space="preserve">
          <source>Normally an action is added to a group by creating it with the group as its parent, so this function is not usually used.</source>
          <target state="translated">일반적으로 그룹을 상위 그룹으로하여 조치를 작성하여 조치를 그룹에 추가하므로이 기능은 일반적으로 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b6e494520f7e1a277faacf10969bb6505206330f" translate="yes" xml:space="preserve">
          <source>Normally an action is added to a group by creating it with the group as parent, so this function is not usually used.</source>
          <target state="translated">일반적으로 그룹을 상위 그룹으로 작성하여 조치를 그룹에 추가하므로이 기능은 일반적으로 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ae59032e3f1b5647d4a56842863f96cbb6a59fdc" translate="yes" xml:space="preserve">
          <source>Normally an application will not need to create its own &lt;a href=&quot;qfocusframe&quot;&gt;QFocusFrame&lt;/a&gt; as &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt; will handle this detail for you. A style writer can optionally use a &lt;a href=&quot;qfocusframe&quot;&gt;QFocusFrame&lt;/a&gt; to have a focus area outside of the widget's paintable geometry. In this way space need not be reserved for the widget to have focus but only set on a &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; with &lt;a href=&quot;qfocusframe#setWidget&quot;&gt;QFocusFrame::setWidget&lt;/a&gt;. It is, however, legal to create your own &lt;a href=&quot;qfocusframe&quot;&gt;QFocusFrame&lt;/a&gt; on a custom widget and set its geometry manually via &lt;a href=&quot;qwidget#geometry-prop&quot;&gt;QWidget::setGeometry&lt;/a&gt; however you will not get auto-placement when the focused widget changes size or placement.</source>
          <target state="translated">일반적으로 응용 프로그램은 자신의 만들 필요가 없습니다 &lt;a href=&quot;qfocusframe&quot;&gt;QFocusFrame을&lt;/a&gt; 같이 &lt;a href=&quot;qstyle&quot;&gt;QStyle는&lt;/a&gt; 당신이 세부 사항을 처리합니다. 스타일 작성자는 선택적으로 &lt;a href=&quot;qfocusframe&quot;&gt;QFocusFrame&lt;/a&gt; 을 사용 하여 위젯의 페인트 가능한 지오메트리 외부에 초점 영역을 가질 수 있습니다 . 이런 식으로 공간에 초점을하는 위젯에 예약 할 필요는 있지만, 만에 설정된 &lt;a href=&quot;qwidget&quot;&gt;는 QWidget&lt;/a&gt; 과 &lt;a href=&quot;qfocusframe#setWidget&quot;&gt;QFocusFrame :: setWidget&lt;/a&gt; . 그러나 사용자 정의 위젯에서 사용자 고유의 &lt;a href=&quot;qfocusframe&quot;&gt;QFocusFrame&lt;/a&gt; 을 작성 하고 &lt;a href=&quot;qwidget#geometry-prop&quot;&gt;QWidget :: setGeometry&lt;/a&gt; 를 통해 해당 지오메트리를 수동으로 설정하는 것이 합법적 이지만 초점이 맞춰진 위젯의 크기 나 위치가 변경 될 때 자동 배치를 얻지 못합니다.</target>
        </trans-unit>
        <trans-unit id="8ada750f68d5c889391a04aee92104e6aed25ac7" translate="yes" xml:space="preserve">
          <source>Normally animations are driven by an internal timer, but the &lt;a href=&quot;qml-qtquick-animationcontroller&quot;&gt;AnimationController&lt;/a&gt; allows the given</source>
          <target state="translated">일반적으로 애니메이션은 내부 타이머에 의해 구동되지만 &lt;a href=&quot;qml-qtquick-animationcontroller&quot;&gt;AnimationController&lt;/a&gt; 는</target>
        </trans-unit>
        <trans-unit id="64ca7d31ad558b522415835b4e918957ae665f71" translate="yes" xml:space="preserve">
          <source>Normally applications should not need to call this function, keyboard should automatically close when the text editor loses focus, for example when the parent view is closed.</source>
          <target state="translated">일반적으로 응용 프로그램은이 함수를 호출 할 필요가 없습니다. 예를 들어 부모보기가 닫히는 경우와 같이 텍스트 편집기에서 포커스를 잃으면 키보드가 자동으로 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="9cd08cb62d5640e08bba92fffe8f40e2b164a713" translate="yes" xml:space="preserve">
          <source>Normally applications should not need to call this function, keyboard should automatically open when the text editor gains focus.</source>
          <target state="translated">일반적으로 응용 프로그램은이 함수를 호출 할 필요가 없으며 텍스트 편집기에 포커스가 있으면 키보드가 자동으로 열립니다.</target>
        </trans-unit>
        <trans-unit id="08f59d367255c82db9315de7f997fdbedfbd186d" translate="yes" xml:space="preserve">
          <source>Normally if you declare a Window inside an Item or inside another Window, this relationship is deduced automatically. In that case, if you declare this window's &lt;a href=&quot;qml-qtquick-window-window#visible-prop&quot;&gt;visible&lt;/a&gt; property &lt;code&gt;true&lt;/code&gt;, it will not actually be shown until the &lt;code&gt;transientParent&lt;/code&gt; window is shown.</source>
          <target state="translated">일반적으로 Item 내부 또는 다른 Window 내부에 Window를 선언하면이 관계가 자동으로 추론됩니다. 이 경우이 창의 &lt;a href=&quot;qml-qtquick-window-window#visible-prop&quot;&gt;visible&lt;/a&gt; 속성을 &lt;code&gt;true&lt;/code&gt; 로 선언 하면 &lt;code&gt;transientParent&lt;/code&gt; 창이 표시 될 때까지 실제로 표시되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="5a9a68fb9e734166f16a9fcc29bde0900b1f728c" translate="yes" xml:space="preserve">
          <source>Normally it should not be necessary to call this function directly as all functions that set properties of the texture object implicitly call create() on your behalf.</source>
          <target state="translated">일반적으로 텍스처 객체의 속성을 설정하는 모든 함수가 사용자를 대신하여 create ()를 암시 적으로 호출하므로이 함수를 직접 호출 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="275c0d961ccbc0995f2bbf5e3ff36d1d3cc9b298" translate="yes" xml:space="preserve">
          <source>Normally the &lt;a href=&quot;qmatrix4x4&quot;&gt;QMatrix4x4&lt;/a&gt; class keeps track of this special type internally as operations are performed. However, if the matrix is modified directly with {&lt;a href=&quot;qloggingcategory#operator-28-29&quot;&gt;QLoggingCategory::operator&lt;/a&gt;()}{&lt;a href=&quot;qmatrix4x4#operator-28-29&quot;&gt;operator&lt;/a&gt;()()} or &lt;a href=&quot;qmatrix4x4#data&quot;&gt;data&lt;/a&gt;(), then &lt;a href=&quot;qmatrix4x4&quot;&gt;QMatrix4x4&lt;/a&gt; will lose track of the special type and will revert to the safest but least efficient operations thereafter.</source>
          <target state="translated">일반적으로 &lt;a href=&quot;qmatrix4x4&quot;&gt;QMatrix4x4&lt;/a&gt; 클래스는 작업이 수행 될 때이 특수 유형을 내부적으로 추적합니다. 그러나 { &lt;a href=&quot;qloggingcategory#operator-28-29&quot;&gt;QLoggingCategory :: operator&lt;/a&gt; ()} { &lt;a href=&quot;qmatrix4x4#operator-28-29&quot;&gt;operator&lt;/a&gt; () ()} 또는 &lt;a href=&quot;qmatrix4x4#data&quot;&gt;data&lt;/a&gt; ()를 사용 하여 행렬을 직접 수정 하면 &lt;a href=&quot;qmatrix4x4&quot;&gt;QMatrix4x4&lt;/a&gt; 는 특수 유형의 추적을 잃고 이후 가장 안전하지만 가장 효율적인 작업으로 되돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="8ffa165ac355ed07b8f1e0fce3e1114bfa22d013" translate="yes" xml:space="preserve">
          <source>Normally there is no need to reimplement this function. However, there are cases that involve decisions based on both the physical device and the surface. These cannot normally be performed before making the &lt;a href=&quot;qvulkanwindow&quot;&gt;QVulkanWindow&lt;/a&gt; visible since the Vulkan surface is not retrievable at that stage.</source>
          <target state="translated">일반적으로이 기능을 다시 구현할 필요가 없습니다. 그러나 물리적 장치와 표면을 기반으로 한 결정이 필요한 경우가 있습니다. Vulkan 표면은 해당 단계에서 검색 할 수 없으므로 &lt;a href=&quot;qvulkanwindow&quot;&gt;QVulkanWindow를&lt;/a&gt; 표시 하기 전에 정상적으로 수행 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="9c1808ddf5404b6ca0f89898cd8edfdcf0fc3b3b" translate="yes" xml:space="preserve">
          <source>Normally you do not need to use this class directly; &lt;a href=&quot;qshortcut&quot;&gt;QShortcut&lt;/a&gt; provides a higher-level interface to handle shortcut keys.</source>
          <target state="translated">일반적으로이 클래스를 직접 사용할 필요는 없습니다. &lt;a href=&quot;qshortcut&quot;&gt;QShortcut&lt;/a&gt; 은 단축키를 처리 할 수있는 고급 인터페이스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="7ebee225449cfe8007efa4ad6338a69a687adc79" translate="yes" xml:space="preserve">
          <source>Normally you don't need to call this function; the garbage collector will automatically be invoked when the &lt;a href=&quot;qjsengine&quot;&gt;QJSEngine&lt;/a&gt; decides that it's wise to do so (i.e. when a certain number of new objects have been created). However, you can call this function to explicitly request that garbage collection should be performed as soon as possible.</source>
          <target state="translated">일반적으로이 함수를 호출 할 필요는 없습니다. 가비지 컬렉터는 &lt;a href=&quot;qjsengine&quot;&gt;QJSEngine&lt;/a&gt; 이 현명하다고 판단 할 때 (즉, 특정 개수의 새 객체가 생성 된 경우) 자동으로 호출됩니다 . 그러나 가비지 수집을 최대한 빨리 수행하도록 명시 적으로 요청하려면이 함수를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c7cd878c5cc7d56b89aff14d674e560d2727fcdc" translate="yes" xml:space="preserve">
          <source>Normally you will use the function &lt;a href=&quot;qdomdocument#implementation&quot;&gt;QDomDocument::implementation&lt;/a&gt;() to get the implementation object.</source>
          <target state="translated">일반적으로 &lt;a href=&quot;qdomdocument#implementation&quot;&gt;QDomDocument :: implementation&lt;/a&gt; () 함수를 사용 하여 구현 객체를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="83d5a3f187b1a9ae41765b7f3fae90d0fed93df3" translate="yes" xml:space="preserve">
          <source>Normally, &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; draws in a &quot;natural&quot; coordinate system, but it is able to perform view and world transformations using the &lt;a href=&quot;qtransform&quot;&gt;QTransform&lt;/a&gt; class. For more information, see &lt;a href=&quot;coordsys#&quot;&gt;Coordinate System&lt;/a&gt;, which also describes the rendering process, i.e. the relation between the logical representation and the rendered pixels, and the benefits of anti-aliased painting.</source>
          <target state="translated">일반적으로 &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; 는 &quot;자연적인&quot;좌표계를 사용하지만 &lt;a href=&quot;qtransform&quot;&gt;QTransform&lt;/a&gt; 클래스를 사용하여 뷰 및 월드 변환을 수행 할 수 있습니다 . 자세한 내용 은 렌더링 시스템, 즉 논리적 표현과 렌더링 된 픽셀 간의 관계, 앤티 앨리어싱 페인팅의 이점을 설명하는 &lt;a href=&quot;coordsys#&quot;&gt;좌표계를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="72a8598bacd9e49f8469b6ce38e663bdcd51ead0" translate="yes" xml:space="preserve">
          <source>Normally, Qt resources are unloaded automatically when the application terminates, but if the resources are located in a plugin that is being unloaded, call Q_CLEANUP_RESOURCE() to force removal of your resources.</source>
          <target state="translated">일반적으로 Qt 자원은 애플리케이션이 종료 될 때 자동으로 언로드되지만 자원이 언로드중인 플러그인에있는 경우 Q_CLEANUP_RESOURCE ()를 호출하여 자원을 강제로 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="993202340faaac0bf8b291e436f74673882b7900" translate="yes" xml:space="preserve">
          <source>Normally, a &lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt; allows only one value per key. If you call &lt;a href=&quot;qhash#insert&quot;&gt;insert&lt;/a&gt;() with a key that already exists in the &lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt;, the previous value is erased. For example:</source>
          <target state="translated">일반적으로 &lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt; 는 키당 하나 의 값만 허용합니다. &lt;a href=&quot;qhash#qhash&quot;&gt;QHash에&lt;/a&gt; 이미 존재하는 키로 &lt;a href=&quot;qhash#insert&quot;&gt;insert&lt;/a&gt; () 를 호출 하면 이전 값이 지워집니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e5db20f8abb737ce9d7db9c831837e2657fc20d9" translate="yes" xml:space="preserve">
          <source>Normally, a &lt;a href=&quot;qmap&quot;&gt;QMap&lt;/a&gt; allows only one value per key. If you call &lt;a href=&quot;qmap#insert&quot;&gt;insert&lt;/a&gt;() with a key that already exists in the &lt;a href=&quot;qmap&quot;&gt;QMap&lt;/a&gt;, the previous value will be erased. For example:</source>
          <target state="translated">일반적으로 &lt;a href=&quot;qmap&quot;&gt;QMap&lt;/a&gt; 은 키당 하나의 값만 허용합니다. &lt;a href=&quot;qmap&quot;&gt;QMap에&lt;/a&gt; 이미 존재하는 키로 &lt;a href=&quot;qmap#insert&quot;&gt;insert&lt;/a&gt; () 를 호출 하면 이전 값이 지워집니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ac72a838b465a9384a844aab3287267eeebaf04e" translate="yes" xml:space="preserve">
          <source>Normally, a compositor application will have a single &lt;a href=&quot;qml-qtwayland-compositor-waylandcompositor&quot;&gt;WaylandCompositor&lt;/a&gt; instance, which can have several outputs as children.</source>
          <target state="translated">일반적으로 컴포 지터 응용 프로그램에는 단일 &lt;a href=&quot;qml-qtwayland-compositor-waylandcompositor&quot;&gt;WaylandCompositor&lt;/a&gt; 인스턴스가 있으며 자식으로 여러 출력을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c94ad304ce1e28eea2e073eb0f1ea82653e81da8" translate="yes" xml:space="preserve">
          <source>Normally, a compositor application will have a single &lt;a href=&quot;qml-qtwayland-compositor-waylandcompositor&quot;&gt;WaylandCompositor&lt;/a&gt; instance, which can have several outputs as children. When a client requests the compositor to create a surface, the request is handled by the onSurfaceRequested handler.</source>
          <target state="translated">일반적으로 컴포 지터 응용 프로그램에는 단일 &lt;a href=&quot;qml-qtwayland-compositor-waylandcompositor&quot;&gt;WaylandCompositor&lt;/a&gt; 인스턴스가 있으며 자식으로 여러 출력을 가질 수 있습니다. 클라이언트가 합성기를 요청하여 표면을 만들면 요청은 onSurfaceRequested 핸들러에 의해 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="b3914ae04937560a2eed2d77757caacc4db97a6c" translate="yes" xml:space="preserve">
          <source>Normally, a connection to a non-existent signal produces runtime errors.</source>
          <target state="translated">일반적으로 존재하지 않는 신호에 연결하면 런타임 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8a2ef996feb67014719a0dcf08ebe9cfda84a318" translate="yes" xml:space="preserve">
          <source>Normally, a timer is started just before a lengthy operation, such as:</source>
          <target state="translated">일반적으로 타이머는 다음과 같이 긴 작업 직전에 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="9a05f471957547d52ff859981b30edaa112685bb" translate="yes" xml:space="preserve">
          <source>Normally, a vertical wheel will produce a &lt;a href=&quot;qml-qtquick-wheelevent&quot;&gt;WheelEvent&lt;/a&gt; with positive delta values if the top of the wheel is rotating away from the hand operating it. Similarly, a horizontal wheel movement will produce a &lt;a href=&quot;qwheelevent&quot;&gt;QWheelEvent&lt;/a&gt; with positive delta values if the top of the wheel is moved to the left.</source>
          <target state="translated">일반적으로, 수직 휠은 휠 상단이 조작하는 손에서 멀어 질 경우 양수 델타 값 으로 &lt;a href=&quot;qml-qtquick-wheelevent&quot;&gt;WheelEvent&lt;/a&gt; 를 생성 합니다. 마찬가지로, 휠 의 상단이 왼쪽으로 이동하면 수평 휠 이동은 양의 델타 값을 갖는 &lt;a href=&quot;qwheelevent&quot;&gt;QWheelEvent&lt;/a&gt; 를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="7d40c273f0994972e11ffa208b103827d5d96da1" translate="yes" xml:space="preserve">
          <source>Normally, a vertical wheel will produce a &lt;a href=&quot;qwheelevent&quot;&gt;QWheelEvent&lt;/a&gt; with positive delta values if the top of the wheel is rotating away from the hand operating it. Similarly, a horizontal wheel movement will produce a &lt;a href=&quot;qwheelevent&quot;&gt;QWheelEvent&lt;/a&gt; with positive delta values if the top of the wheel is moved to the left.</source>
          <target state="translated">일반적으로, 수직 휠은 휠 상단이 조작하는 손에서 멀어 질 경우 양의 델타 값 으로 &lt;a href=&quot;qwheelevent&quot;&gt;QWheelEvent&lt;/a&gt; 를 생성 합니다. 마찬가지로, 휠 의 상단이 왼쪽으로 이동하면 수평 휠 이동은 양의 델타 값을 갖는 &lt;a href=&quot;qwheelevent&quot;&gt;QWheelEvent&lt;/a&gt; 를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="e9c1d94beea7d8a485b492de266055f95109686a" translate="yes" xml:space="preserve">
          <source>Normally, an empty line edit shows the placeholder text even when it has focus. However, if the content is horizontally centered, the placeholder text is not displayed under the cursor when the line edit has focus.</source>
          <target state="translated">일반적으로 빈 줄 편집은 자리 표시 자 텍스트에 포커스가있는 경우에도 표시됩니다. 그러나 내용이 가로 가운데에 있으면 행 편집에 포커스가있을 때 자리 표시 자 텍스트가 커서 아래에 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1c6a63ac34eb0549bc1aabdf82ca27369b2a0640" translate="yes" xml:space="preserve">
          <source>Normally, each managed widget or layout is put into a cell of its own using &lt;a href=&quot;qgridlayout#addWidget-1&quot;&gt;addWidget&lt;/a&gt;(). It is also possible for a widget to occupy multiple cells using the row and column spanning overloads of &lt;a href=&quot;qgridlayout#addItem&quot;&gt;addItem&lt;/a&gt;() and &lt;a href=&quot;qgridlayout#addWidget-1&quot;&gt;addWidget&lt;/a&gt;(). If you do this, &lt;a href=&quot;qgridlayout&quot;&gt;QGridLayout&lt;/a&gt; will guess how to distribute the size over the columns/rows (based on the stretch factors).</source>
          <target state="translated">일반적으로 각 관리되는 위젯 또는 레이아웃은 &lt;a href=&quot;qgridlayout#addWidget-1&quot;&gt;addWidget&lt;/a&gt; ()을 사용하여 자체 셀에 배치됩니다 . 위젯이 &lt;a href=&quot;qgridlayout#addItem&quot;&gt;addItem&lt;/a&gt; () 및 &lt;a href=&quot;qgridlayout#addWidget-1&quot;&gt;addWidget&lt;/a&gt; ()의 오버로드 및 행에 걸쳐 여러 셀을 차지할 수도 있습니다 . 이 작업을 수행하면 &lt;a href=&quot;qgridlayout&quot;&gt;QGridLayout&lt;/a&gt; 은 열 / 행에 크기를 분산시키는 방법을 추측합니다 (신축 계수를 기준으로).</target>
        </trans-unit>
        <trans-unit id="99a0a3028bea9ca51e4922a9fb0a244e117179b7" translate="yes" xml:space="preserve">
          <source>Normally, it isn't necessary to call this function, because Qt sets the &lt;a href=&quot;qapplication&quot;&gt;QApplication&lt;/a&gt; object as the root object immediately before the event loop is entered in &lt;a href=&quot;qapplication#exec&quot;&gt;QApplication::exec&lt;/a&gt;().</source>
          <target state="translated">Qt는 &lt;a href=&quot;qapplication#exec&quot;&gt;QApplication :: exec&lt;/a&gt; () 에 이벤트 루프가 입력되기 직전에 &lt;a href=&quot;qapplication&quot;&gt;QApplication&lt;/a&gt; 객체를 루트 객체로 설정하기 때문에이 함수를 호출 할 필요는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="47bd08b136edd8a3a2443a550949234b45ce1b72" translate="yes" xml:space="preserve">
          <source>Normally, several datagrams are to be received and sent by both peers during the handshake phase. Upon reading datagrams, server and client must pass these datagrams to &lt;a href=&quot;qdtls#doHandshake&quot;&gt;doHandshake&lt;/a&gt;() until some error is found or &lt;a href=&quot;qdtls#handshakeState&quot;&gt;handshakeState&lt;/a&gt;() returns &lt;a href=&quot;qdtls#HandshakeState-enum&quot;&gt;HandshakeComplete&lt;/a&gt;:</source>
          <target state="translated">일반적으로 핸드 셰이크 단계 동안 두 피어가 여러 데이터 그램을 수신 및 전송합니다. 데이터 그램을 읽을 때 서버와 클라이언트는 오류가 발견되거나 &lt;a href=&quot;qdtls#handshakeState&quot;&gt;handshakeState&lt;/a&gt; ()가 &lt;a href=&quot;qdtls#HandshakeState-enum&quot;&gt;HandshakeComplete을&lt;/a&gt; 반환 할 때까지 이러한 데이터 그램을 &lt;a href=&quot;qdtls#doHandshake&quot;&gt;doHandshake&lt;/a&gt; ()에 전달해야합니다 .</target>
        </trans-unit>
        <trans-unit id="dd33f0d5c50e3a9cd7d25901809cc9962d9a7c2a" translate="yes" xml:space="preserve">
          <source>Normally, the &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; operates on the device's own coordinate system (usually pixels), but &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; has good support for coordinate transformations.</source>
          <target state="translated">일반적으로 &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; 는 장치의 자체 좌표계 (일반적으로 픽셀)에서 작동하지만 &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; 는 좌표 변환을 잘 지원합니다.</target>
        </trans-unit>
        <trans-unit id="86eef4b2fe95817bed11b581acba3859378fd997" translate="yes" xml:space="preserve">
          <source>Normally, the &lt;b&gt;Next&lt;/b&gt; button and the &lt;b&gt;Finish&lt;/b&gt; button of a wizard are mutually exclusive. If &lt;a href=&quot;qwizardpage#isFinalPage&quot;&gt;isFinalPage&lt;/a&gt;() returns &lt;code&gt;true&lt;/code&gt;, &lt;b&gt;Finish&lt;/b&gt; is available; otherwise, &lt;b&gt;Next&lt;/b&gt; is available. By default, &lt;a href=&quot;qwizardpage#isFinalPage&quot;&gt;isFinalPage&lt;/a&gt;() is true only when &lt;a href=&quot;qwizardpage#nextId&quot;&gt;nextId&lt;/a&gt;() returns -1. If you want to show &lt;b&gt;Next&lt;/b&gt; and &lt;b&gt;Final&lt;/b&gt; simultaneously for a page (letting the user perform an &quot;early finish&quot;), call &lt;a href=&quot;qwizardpage#setFinalPage&quot;&gt;setFinalPage&lt;/a&gt;(true) on that page. For wizards that support early finishes, you might also want to set the &lt;a href=&quot;qwizard#WizardOption-enum&quot;&gt;HaveNextButtonOnLastPage&lt;/a&gt; and &lt;a href=&quot;qwizard#WizardOption-enum&quot;&gt;HaveFinishButtonOnEarlyPages&lt;/a&gt; options on the wizard.</source>
          <target state="translated">일반적으로 마법사 의 &lt;b&gt;다음&lt;/b&gt; 버튼과 &lt;b&gt;마침&lt;/b&gt; 버튼은 상호 배타적입니다. 경우 &lt;a href=&quot;qwizardpage#isFinalPage&quot;&gt;isFinalPage은&lt;/a&gt; () 반환 &lt;code&gt;true&lt;/code&gt; , &lt;b&gt;마침&lt;/b&gt; 유효하다; 그렇지 않으면 &lt;b&gt;다음&lt;/b&gt; 을 사용할 수 있습니다. &lt;a href=&quot;qwizardpage#isFinalPage&quot;&gt;isIdinalPage&lt;/a&gt; ()는 &lt;a href=&quot;qwizardpage#nextId&quot;&gt;nextId&lt;/a&gt; ()가 -1을 반환 할 때만 기본적으로 true 입니다. 페이지에 대해 &lt;b&gt;다음&lt;/b&gt; 및 &lt;b&gt;최종을&lt;/b&gt; 동시에 표시 하려면 (사용자가 &quot;조기 완료&quot;를 수행하도록 함 ) 해당 페이지에서 &lt;a href=&quot;qwizardpage#setFinalPage&quot;&gt;setFinalPage&lt;/a&gt; (true)를 호출 하십시오. 조기 완료를 지원하는 마법사의 경우 &lt;a href=&quot;qwizard#WizardOption-enum&quot;&gt;HaveNextButtonOnLastPage&lt;/a&gt; 및 &lt;a href=&quot;qwizard#WizardOption-enum&quot;&gt;HaveFinishButtonOnEarlyPages&lt;/a&gt; 를 설정할 수도 있습니다. 마법사의 옵션.</target>
        </trans-unit>
        <trans-unit id="461f0ca5d70294382d65b1c0886d89e7af06c00e" translate="yes" xml:space="preserve">
          <source>Normally, the begin and end functions are capable of informing other components about changes to the model's underlying structure. For more complex changes to the model's structure, perhaps involving internal reorganization, sorting of data or any other structural change, it is necessary to perform the following sequence:</source>
          <target state="translated">일반적으로 begin 및 end 함수는 모델의 기본 구조에 대한 변경 사항을 다른 구성 요소에 알릴 수 있습니다. 내부 구조 조정, 데이터 정렬 또는 기타 구조적 변경을 포함하여 모델 구조를보다 복잡하게 변경하려면 다음 순서를 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="9a4bb5277245967a8842220e1408d91121bc17c1" translate="yes" xml:space="preserve">
          <source>Normally, the default message handler is sufficient. It writes compile and runtime messages to</source>
          <target state="translated">일반적으로 기본 메시지 핸들러로 충분합니다. 컴파일 및 런타임 메시지를</target>
        </trans-unit>
        <trans-unit id="c68852faed3a42b9182317237cc52b40cccd71e6" translate="yes" xml:space="preserve">
          <source>Normally, the default message handler is sufficient. It writes compile and validation messages to</source>
          <target state="translated">일반적으로 기본 메시지 핸들러로 충분합니다. 컴파일 및 유효성 검사 메시지를</target>
        </trans-unit>
        <trans-unit id="e07ea0a8dc744af847b9f3bfe71c9d1b592ad770" translate="yes" xml:space="preserve">
          <source>Normally, the following QML would result in a binding being established for the &lt;code&gt;script&lt;/code&gt; property; i.e. &lt;code&gt;script&lt;/code&gt; would be assigned the value obtained from running &lt;code&gt;myObj.value = Math.max(myValue, 100)&lt;/code&gt;</source>
          <target state="translated">일반적으로 다음 QML은 &lt;code&gt;script&lt;/code&gt; 특성 에 대한 바인딩을 설정 합니다. 즉, &lt;code&gt;script&lt;/code&gt; &lt;code&gt;myObj.value = Math.max(myValue, 100)&lt;/code&gt; 을 실행하여 얻은 값이 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="cb8705827a59b554cf2b2ebe0ba3ecae6e62cf06" translate="yes" xml:space="preserve">
          <source>Normally, the message is displayed immediately. However, if there are pending messages, it will be queued to be displayed later.</source>
          <target state="translated">일반적으로 메시지가 즉시 표시됩니다. 그러나 보류중인 메시지가 있으면 나중에 표시되도록 대기합니다.</target>
        </trans-unit>
        <trans-unit id="49f6fde1e345bd0df14097aa7109c2c857b173cc" translate="yes" xml:space="preserve">
          <source>Normally, the primary index is set automatically whenever you call &lt;a href=&quot;qsqltablemodel#setTable&quot;&gt;setTable&lt;/a&gt;().</source>
          <target state="translated">일반적으로 기본 인덱스는 &lt;a href=&quot;qsqltablemodel#setTable&quot;&gt;setTable&lt;/a&gt; () 을 호출 할 때마다 자동으로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="9c998342d3bdb99fb398288ecc9113ba6b87a963" translate="yes" xml:space="preserve">
          <source>Normally, the types exported by a plugin should be fixed. However, if a C++ type is not available, you should at least &quot;reserve&quot; the QML type name, and give the user of the unavailable type a meaningful error message.</source>
          <target state="translated">일반적으로 플러그인에서 내 보낸 유형은 고정되어 있어야합니다. 그러나 C ++ 유형을 사용할 수없는 경우 최소한 QML 유형 이름을 &quot;예약&quot;하고 사용할 수없는 유형의 사용자에게 의미있는 오류 메시지를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="d71449d42cc72a47c0f371425ccca3c152d73efe" translate="yes" xml:space="preserve">
          <source>Normally, when a QML type is marked with</source>
          <target state="translated">일반적으로 QML 유형이</target>
        </trans-unit>
        <trans-unit id="1a836777bd8dd2bece616b86f836bfa00f0b0ec6" translate="yes" xml:space="preserve">
          <source>Normally, you connect each menu action to a single slot using &lt;a href=&quot;qaction#triggered&quot;&gt;QAction::triggered&lt;/a&gt;(), but sometimes you will want to connect several items to a single slot (most often if the user selects from an array). This signal is useful in such cases.</source>
          <target state="translated">일반적으로 &lt;a href=&quot;qaction#triggered&quot;&gt;QAction :: triggered&lt;/a&gt; ()를 사용하여 각 메뉴 작업을 단일 슬롯 에 연결하지만 때로는 여러 항목을 단일 슬롯에 연결하려고 할 수도 있습니다 (대부분 사용자가 배열에서 선택하는 경우). 이 신호는 그러한 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="abf747f6c10ce22773a2baecc7633c9241c9cb2c" translate="yes" xml:space="preserve">
          <source>Normally, you connect each menu action's &lt;a href=&quot;qaction#triggered&quot;&gt;triggered()&lt;/a&gt; signal to its own custom slot, but sometimes you will want to connect several actions to a single slot, for example, when you have a group of closely related actions, such as &quot;left justify&quot;, &quot;center&quot;, &quot;right justify&quot;.</source>
          <target state="translated">일반적으로 각 메뉴 작업의 &lt;a href=&quot;qaction#triggered&quot;&gt;triggered ()&lt;/a&gt; 신호를 자체 사용자 정의 슬롯에 연결하지만 &quot;왼쪽 정렬&quot;과 같이 밀접하게 관련된 작업 그룹이있는 경우와 같이 여러 작업을 단일 슬롯에 연결하려고 할 때가 있습니다. , &quot;중심&quot;, &quot;맞춤&quot;.</target>
        </trans-unit>
        <trans-unit id="4dc941c573fd53b44633539356bbe665fe347e14" translate="yes" xml:space="preserve">
          <source>Normally, you do not have to call this function.</source>
          <target state="translated">일반적으로이 함수를 호출 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="abaedf997f5c37ff234647646a76d4c100fff101" translate="yes" xml:space="preserve">
          <source>Normally, you do not need to create a &lt;a href=&quot;qtextinlineobject&quot;&gt;QTextInlineObject&lt;/a&gt;. It is used by &lt;a href=&quot;qabstracttextdocumentlayout&quot;&gt;QAbstractTextDocumentLayout&lt;/a&gt; to handle inline objects when implementing a custom layout.</source>
          <target state="translated">일반적으로 &lt;a href=&quot;qtextinlineobject&quot;&gt;QTextInlineObject&lt;/a&gt; 를 만들 필요가 없습니다 . &lt;a href=&quot;qabstracttextdocumentlayout&quot;&gt;QAbstractTextDocumentLayout&lt;/a&gt; 에서 사용자 정의 레이아웃을 구현할 때 인라인 객체를 처리 하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="44ca5d64975012afcf60db27fef71b2c13834941" translate="yes" xml:space="preserve">
          <source>Normally, you don't need to use these, since &lt;a href=&quot;qframe#frameShadow-prop&quot;&gt;frameShadow&lt;/a&gt;() and &lt;a href=&quot;qframe#frameShape-prop&quot;&gt;frameShape&lt;/a&gt;() already extract the &lt;a href=&quot;qframe#Shadow-enum&quot;&gt;Shadow&lt;/a&gt; and the &lt;a href=&quot;qframe#Shape-enum&quot;&gt;Shape&lt;/a&gt; parts of &lt;a href=&quot;qframe#frameStyle&quot;&gt;frameStyle&lt;/a&gt;().</source>
          <target state="translated">때문에 일반적으로, 당신은이를 사용할 필요가 없습니다 &lt;a href=&quot;qframe#frameShadow-prop&quot;&gt;frameShadow&lt;/a&gt; ()와 &lt;a href=&quot;qframe#frameShape-prop&quot;&gt;frameShape&lt;/a&gt; 이미 추출) ( &lt;a href=&quot;qframe#Shadow-enum&quot;&gt;그림자&lt;/a&gt; 와 &lt;a href=&quot;qframe#Shape-enum&quot;&gt;모양&lt;/a&gt; 의 부품 &lt;a href=&quot;qframe#frameStyle&quot;&gt;frameStyle을&lt;/a&gt; ().</target>
        </trans-unit>
        <trans-unit id="af24f129bb9e10af1b50349d21adf6015fae6cf8" translate="yes" xml:space="preserve">
          <source>Normally, you don't need to use this class directly. Qt's built-in layout managers provide the following functions for manipulating empty space in layouts:</source>
          <target state="translated">일반적으로이 클래스를 직접 사용할 필요는 없습니다. Qt의 내장 레이아웃 관리자는 레이아웃에서 빈 공간을 조작하기 위해 다음 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="7aae31543813b1d6a1de216548a4f86ad6d6c71b" translate="yes" xml:space="preserve">
          <source>Normally, you don't need to use this class directly. Qt's built-in layout managers provide the following functions for manipulating widgets in layouts:</source>
          <target state="translated">일반적으로이 클래스를 직접 사용할 필요는 없습니다. Qt의 내장 레이아웃 관리자는 레이아웃에서 위젯을 조작하기 위해 다음 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="3e2eca35f2d92998315829760f01bc6f5bc877df" translate="yes" xml:space="preserve">
          <source>Normally, you should not need to call this function directly. Instead, use &lt;a href=&quot;qmetatype#Type-enum&quot;&gt;QVariant&lt;/a&gt;'s &lt;code&gt;operator&amp;gt;&amp;gt;()&lt;/code&gt;, which relies on load() to stream custom types.</source>
          <target state="translated">일반적으로이 함수를 직접 호출 할 필요는 없습니다. 대신, &lt;a href=&quot;qmetatype#Type-enum&quot;&gt;QVariant&lt;/a&gt; 의 &lt;code&gt;operator&amp;gt;&amp;gt;()&lt;/code&gt; 사용자 정의 유형을 스트리밍하는 부하 ()에 의존한다.</target>
        </trans-unit>
        <trans-unit id="f76237e560731eff73fb94dcf12a24b9bdb84536" translate="yes" xml:space="preserve">
          <source>Normally, you should not need to call this function directly. Instead, use &lt;a href=&quot;qmetatype#Type-enum&quot;&gt;QVariant&lt;/a&gt;'s &lt;code&gt;operator&amp;lt;&amp;lt;()&lt;/code&gt;, which relies on save() to stream custom types.</source>
          <target state="translated">일반적으로이 함수를 직접 호출 할 필요는 없습니다. 대신, save ()를 사용하여 사용자 정의 유형을 스트리밍 하는 &lt;a href=&quot;qmetatype#Type-enum&quot;&gt;QVariant&lt;/a&gt; 의 &lt;code&gt;operator&amp;lt;&amp;lt;()&lt;/code&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b13731fadfd8d146fcc17b293da3c0d0a8c5c1e6" translate="yes" xml:space="preserve">
          <source>Normally, you should place calls using &lt;a href=&quot;qdbusabstractinterface#asyncCall&quot;&gt;asyncCall&lt;/a&gt;().</source>
          <target state="translated">일반적으로 &lt;a href=&quot;qdbusabstractinterface#asyncCall&quot;&gt;asyncCall&lt;/a&gt; ()을 사용하여 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="22674d9378c4e52d6270ba30beaefeaebb573d97" translate="yes" xml:space="preserve">
          <source>Normally, you should place calls using &lt;a href=&quot;qdbusabstractinterface#call&quot;&gt;call&lt;/a&gt;().</source>
          <target state="translated">일반적으로 &lt;a href=&quot;qdbusabstractinterface#call&quot;&gt;call&lt;/a&gt; ()을 사용하여 전화를 걸어야합니다 .</target>
        </trans-unit>
        <trans-unit id="04d5dd001ea10805b9fb027667cc7127ffe6a2f8" translate="yes" xml:space="preserve">
          <source>Normally, you should pop the context at the end of each XML element. After popping the context, all namespace prefix mappings that were previously in force are restored.</source>
          <target state="translated">일반적으로 각 XML 요소의 끝에 컨텍스트를 표시해야합니다. 컨텍스트를 팝업 한 후에는 이전에 적용되었던 모든 네임 스페이스 접두사 매핑이 복원됩니다.</target>
        </trans-unit>
        <trans-unit id="6498540a59385527ffd2d47264cce3a09d751fc0" translate="yes" xml:space="preserve">
          <source>Normally, you should push a new context at the beginning of each XML element: the new context automatically inherits the declarations of its parent context, and it also keeps track of which declarations were made within this context.</source>
          <target state="translated">일반적으로 각 XML 요소의 시작 부분에 새 컨텍스트를 푸시해야합니다. 새 컨텍스트는 자동으로 상위 컨텍스트의 선언을 상속하며이 컨텍스트 내에서 어떤 선언이 이루어 졌는지 추적합니다.</target>
        </trans-unit>
        <trans-unit id="e8015199831ae98627ce192997b32d694753d088" translate="yes" xml:space="preserve">
          <source>Normally, you would use &lt;a href=&quot;qsqlquery&quot;&gt;QSqlQuery&lt;/a&gt; instead of &lt;a href=&quot;qsqlresult&quot;&gt;QSqlResult&lt;/a&gt;, since &lt;a href=&quot;qsqlquery&quot;&gt;QSqlQuery&lt;/a&gt; provides a generic wrapper for database-specific implementations of &lt;a href=&quot;qsqlresult&quot;&gt;QSqlResult&lt;/a&gt;.</source>
          <target state="translated">일반적으로, 사용하는 것이 &lt;a href=&quot;qsqlquery&quot;&gt;QSqlQuery&lt;/a&gt; 대신 &lt;a href=&quot;qsqlresult&quot;&gt;QSqlResult을&lt;/a&gt; 하기 때문에, &lt;a href=&quot;qsqlquery&quot;&gt;QSqlQuery가&lt;/a&gt; 의 데이터베이스 특정 구현에 대한 일반적인 래퍼를 제공 &lt;a href=&quot;qsqlresult&quot;&gt;QSqlResult&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="79b723002f87708ebc11fd4f3b902a03f7c9a5c1" translate="yes" xml:space="preserve">
          <source>Norwegian</source>
          <target state="translated">Norwegian</target>
        </trans-unit>
        <trans-unit id="1de91415f70a00ed251cdd8383e078c13aa33c9b" translate="yes" xml:space="preserve">
          <source>Norwegian Layout</source>
          <target state="translated">노르웨이어 레이아웃</target>
        </trans-unit>
        <trans-unit id="23c9fe64cf8470df8244ce51b4904e00c7bf3b10" translate="yes" xml:space="preserve">
          <source>Norwegian, Nordic Bokmal</source>
          <target state="translated">노르웨이어, 노르딕 보크 말</target>
        </trans-unit>
        <trans-unit id="ef39cd57a569bb886190b06c9f33260005515160" translate="yes" xml:space="preserve">
          <source>Nostalgia</source>
          <target state="translated">Nostalgia</target>
        </trans-unit>
        <trans-unit id="d71eab6323b7c31e94cdd0d65a77dff04da7974b" translate="yes" xml:space="preserve">
          <source>Not Set</source>
          <target state="translated">미 설정</target>
        </trans-unit>
        <trans-unit id="b3034ec567c2321a383d655a57d2cb638f893719" translate="yes" xml:space="preserve">
          <source>Not Supported</source>
          <target state="translated">미지원</target>
        </trans-unit>
        <trans-unit id="6eccab182c97013c56d863cb44575fe3b4454c03" translate="yes" xml:space="preserve">
          <source>Not a media.</source>
          <target state="translated">미디어가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="946155f4955cb1c5bc87bdb5c6e5e28781930d68" translate="yes" xml:space="preserve">
          <source>Not a valid type, either due to parsing error or due to reaching the end of an array or map.</source>
          <target state="translated">구문 분석 오류 또는 배열 또는 맵의 끝에 도달하여 유효한 유형이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="5b14b5e2d599326c6356b9a5edd05dee9b4ac8c3" translate="yes" xml:space="preserve">
          <source>Not a valid value, this usually indicates a CBOR decoding error</source>
          <target state="translated">유효한 값이 아닙니다. 일반적으로 CBOR 디코딩 오류를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a1848e7c9e19ecda4f34cdfdfa1b530181e591a9" translate="yes" xml:space="preserve">
          <source>Not adjacent to the selected section</source>
          <target state="translated">선택한 섹션에 인접하지 않음</target>
        </trans-unit>
        <trans-unit id="b3d52dca42b7cd3ee33ee68b4b8618fda85a40d7" translate="yes" xml:space="preserve">
          <source>Not all &lt;a href=&quot;qt#ItemDataRole-enum&quot;&gt;ItemDataRole&lt;/a&gt;s will have an effect on a &lt;a href=&quot;qheaderview&quot;&gt;QHeaderView&lt;/a&gt;. If you need to draw other roles, you can subclass &lt;a href=&quot;qheaderview&quot;&gt;QHeaderView&lt;/a&gt; and reimplement &lt;a href=&quot;qheaderview#paintEvent&quot;&gt;paintEvent()&lt;/a&gt;. &lt;a href=&quot;qheaderview&quot;&gt;QHeaderView&lt;/a&gt; respects the following item data roles, unless they are in conflict with the style (which can happen for styles that follow the desktop theme):</source>
          <target state="translated">모든 &lt;a href=&quot;qt#ItemDataRole-enum&quot;&gt;ItemDataRole&lt;/a&gt; 이 &lt;a href=&quot;qheaderview&quot;&gt;QHeaderView에&lt;/a&gt; 영향을주는 것은 아닙니다 . 다른 역할을 &lt;a href=&quot;qheaderview&quot;&gt;가져와야하는 경우 QHeaderView&lt;/a&gt; 를 서브 클래스 화 하고 &lt;a href=&quot;qheaderview#paintEvent&quot;&gt;paintEvent ()를&lt;/a&gt; 다시 구현할 수 있습니다 . &lt;a href=&quot;qheaderview&quot;&gt;QHeaderView&lt;/a&gt; 는 스타일과 충돌하지 않는 한 다음 항목 데이터 역할을 존중합니다 (데스크탑 테마를 따르는 스타일에서 발생할 수 있음).</target>
        </trans-unit>
        <trans-unit id="dd36f248af501658c8b239322c1044a84f7b7ada" translate="yes" xml:space="preserve">
          <source>Not all &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; types are supported. Below is a list of currently supported &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; types:</source>
          <target state="translated">모든 &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; 유형이 지원되는 것은 아닙니다 . 다음은 현재 지원되는 &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; 유형 목록입니다 .</target>
        </trans-unit>
        <trans-unit id="6f9be1da6b6cb18e31561e26fd94d8a84c9dd871" translate="yes" xml:space="preserve">
          <source>Not all QML list properties support all operations. A set of methods, &lt;a href=&quot;qqmllistreference#canAppend&quot;&gt;canAppend&lt;/a&gt;(), &lt;a href=&quot;qqmllistreference#canAt&quot;&gt;canAt&lt;/a&gt;(), &lt;a href=&quot;qqmllistreference#canClear&quot;&gt;canClear&lt;/a&gt;() and &lt;a href=&quot;qqmllistreference#canCount&quot;&gt;canCount&lt;/a&gt;() allow programs to query whether an operation is supported on a given property.</source>
          <target state="translated">모든 QML 목록 특성이 모든 조작을 지원하는 것은 아닙니다. 방법의 세트 &lt;a href=&quot;qqmllistreference#canAppend&quot;&gt;canAppend&lt;/a&gt; () &lt;a href=&quot;qqmllistreference#canAt&quot;&gt;canAt&lt;/a&gt; () &lt;a href=&quot;qqmllistreference#canClear&quot;&gt;canClear&lt;/a&gt; () 및 &lt;a href=&quot;qqmllistreference#canCount&quot;&gt;canCount&lt;/a&gt; ()는 동작이 지정된 속성에 지원되는지 질의 프로그램을 허용한다.</target>
        </trans-unit>
        <trans-unit id="920a4ddd5ebd507cc29ac19cb6c5989b712760a1" translate="yes" xml:space="preserve">
          <source>Not all backends and devices might support setting the acceleration mode. For those cases, the default mode &lt;a href=&quot;qaccelerometer#AccelerationMode-enum&quot;&gt;QAccelerometer::Combined&lt;/a&gt; is used, changing it has no effect.</source>
          <target state="translated">모든 백엔드 및 장치가 가속 모드 설정을 지원하지는 않습니다. 이러한 경우 기본 모드 &lt;a href=&quot;qaccelerometer#AccelerationMode-enum&quot;&gt;QAccelerometer :: Combined&lt;/a&gt; 가 사용되며 변경해도 아무런 영향이 없습니다.</target>
        </trans-unit>
        <trans-unit id="0c3ef0e191ed651b5eb833765ea18844f8166d8b" translate="yes" xml:space="preserve">
          <source>Not all buffer implementations will map more than the first plane, if this returns a single plane for a planar format the additional planes will have to be calculated from the line stride of the first plane and the frame height. Mapping a buffer with &lt;a href=&quot;qvideoframe&quot;&gt;QVideoFrame&lt;/a&gt; will do this for you.</source>
          <target state="translated">모든 버퍼 구현이 첫 번째 평면 이상으로 매핑되는 것은 아닙니다. 평면 형식의 단일 평면을 반환하면 첫 번째 평면의 선 보폭과 프레임 높이에서 추가 평면을 계산해야합니다. &lt;a href=&quot;qvideoframe&quot;&gt;QVideoFrame&lt;/a&gt; 으로 버퍼를 매핑하면 이 작업이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="56ccf465d841877665b2e6bebae78a1235a092b6" translate="yes" xml:space="preserve">
          <source>Not all filesystems support this feature. In this case, the value returned by this method could be empty. An empty string is returned if the file system does not support labels, or if no label is set.</source>
          <target state="translated">모든 파일 시스템이이 기능을 지원하는 것은 아닙니다. 이 경우이 메서드에서 반환 한 값이 비어있을 수 있습니다. 파일 시스템이 레이블을 지원하지 않거나 레이블이 설정되지 않은 경우 빈 문자열이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="9855b33cf797230a4f2adf23ead2ccd496f06777" translate="yes" xml:space="preserve">
          <source>Not all image formats support embedded text. You can find out if a specific image or format supports embedding text by using &lt;a href=&quot;qimagewriter#supportsOption&quot;&gt;QImageWriter::supportsOption&lt;/a&gt;(). We give an example:</source>
          <target state="translated">모든 이미지 형식이 포함 된 텍스트를 지원하지는 않습니다. &lt;a href=&quot;qimagewriter#supportsOption&quot;&gt;QImageWriter :: supportsOption&lt;/a&gt; () 을 사용하여 특정 이미지 또는 형식이 텍스트 포함을 지원하는지 확인할 수 있습니다 . 예를 들어 보자.</target>
        </trans-unit>
        <trans-unit id="2a0033d81c61d850a7275618f9235c6796503f5d" translate="yes" xml:space="preserve">
          <source>Not all layouts should necessarily be mirrored. There are cases where a visual type is positioned to the right side of the screen for improved one-handed use, because most people are right-handed, and not because of the reading direction. In the case that a child type should not be affected by mirroring, set the &lt;a href=&quot;qml-qtquick-layoutmirroring#enabled-prop&quot;&gt;LayoutMirroring.enabled&lt;/a&gt; property for that type to false.</source>
          <target state="translated">모든 레이아웃이 반드시 미러링되어야하는 것은 아닙니다. 한 손으로 사용하기 위해 시각적 유형이 화면 오른쪽에 배치되는 경우가 있습니다. 대부분의 사람들은 읽기 방향이 아니라 오른 손잡이이기 때문입니다. 자식 형식이 미러링의 영향을받지 않아야하는 경우 해당 형식의 &lt;a href=&quot;qml-qtquick-layoutmirroring#enabled-prop&quot;&gt;LayoutMirroring.enabled&lt;/a&gt; 속성을 false로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="0a9217f7bb749bdd07b6006263d5caded9b191cc" translate="yes" xml:space="preserve">
          <source>Not all light sensor support retrieving their field of view. For sensors that don't support this property, the value will be 0. Whether the field of view is supported can be checked with &lt;a href=&quot;qsensor#isFeatureSupported&quot;&gt;QSensor::isFeatureSupported&lt;/a&gt;() and the &lt;a href=&quot;qsensor#Feature-enum&quot;&gt;QSensor::FieldOfView&lt;/a&gt; flag.</source>
          <target state="translated">모든 광 센서가 시야를 검색하는 것을 지원하지는 않습니다. 이 특성을 지원하지 않는 센서의 경우 값은 0입니다. 시야가 지원되는지 여부는 &lt;a href=&quot;qsensor#isFeatureSupported&quot;&gt;QSensor :: isFeatureSupported&lt;/a&gt; () 및 QSensor &lt;a href=&quot;qsensor#Feature-enum&quot;&gt;:: FieldOfView&lt;/a&gt; 플래그를 사용 하여 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1078dc10ef57f9878b22261107120d76133cc9f6" translate="yes" xml:space="preserve">
          <source>Not all operating systems support reporting all features. Only the IPv4 addresses are guaranteed to be listed by this class in all platforms. In particular, IPv6 address listing is only supported on Windows, Linux, &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; and the BSDs.</source>
          <target state="translated">모든 운영 체제가 모든 기능보고를 지원하지는 않습니다. 모든 플랫폼에서이 클래스는 IPv4 주소 만 나열하도록 보장합니다. 특히 IPv6 주소 목록은 Windows, Linux, &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; 및 BSD 에서만 지원됩니다 .</target>
        </trans-unit>
        <trans-unit id="c33237b79325f11d19e938f45a8351c5c269d91f" translate="yes" xml:space="preserve">
          <source>Not all platforms distinguish the different positioning methods or communicate the current user configuration of the device. The following table provides an overview of the current platform situation:</source>
          <target state="translated">모든 플랫폼이 서로 다른 포지셔닝 방법을 구별하거나 장치의 현재 사용자 구성을 전달하는 것은 아닙니다. 다음 표는 현재 플랫폼 상황에 대한 개요를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="7f3207637552b92e0a597ec2f706c93ab560fb73" translate="yes" xml:space="preserve">
          <source>Not all platforms support &lt;a href=&quot;qbluetoothdevicediscoveryagent#InquiryType-enum&quot;&gt;LimitedInquiry&lt;/a&gt;.</source>
          <target state="translated">모든 플랫폼이 &lt;a href=&quot;qbluetoothdevicediscoveryagent#InquiryType-enum&quot;&gt;LimitedInquiry를&lt;/a&gt; 지원하는 것은 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="f20e8eed75ec9cded6bc7fde5a483471fe3805a9" translate="yes" xml:space="preserve">
          <source>Not all platforms support audio stream categorization. In this case, the function call will be ignored.</source>
          <target state="translated">모든 플랫폼이 오디오 스트림 분류를 지원하지는 않습니다. 이 경우 함수 호출은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="42267fb1f7d2ef3537901d7001dc8ee8045789da" translate="yes" xml:space="preserve">
          <source>Not all playback services support change of the playback rate. It is framework defined as to the status and quality of audio and video while fast forwarding or rewinding.</source>
          <target state="translated">모든 재생 서비스가 재생 속도 변경을 지원하는 것은 아닙니다. 빨리 감기 또는 되감기 동안 오디오 및 비디오의 상태와 품질에 대해 정의 된 프레임 워크입니다.</target>
        </trans-unit>
        <trans-unit id="5ae94eb1d9588b00c18119f53067f96c45eab7da" translate="yes" xml:space="preserve">
          <source>Not all properties of a Position object are necessarily valid or available (for example latitude and longitude may be valid, but speed update has not been received or set manually). As a result, corresponding &quot;valid&quot; properties are available (for example &lt;a href=&quot;qml-qtpositioning-position#coordinate-prop&quot;&gt;coordinate&lt;/a&gt; and &lt;a href=&quot;qml-qtpositioning-position#longitudeValid-prop&quot;&gt;longitudeValid&lt;/a&gt;, &lt;a href=&quot;qml-qtpositioning-position#latitudeValid-prop&quot;&gt;latitudeValid&lt;/a&gt; etc) to discern whether the data is available and valid in this position update.</source>
          <target state="translated">Position 객체의 모든 속성이 반드시 유효하거나 사용 가능한 것은 아닙니다 (예 : 위도와 경도는 유효하지만 속도 업데이트는 수동으로 받거나 설정하지 않았습니다). 결과적 으로이 위치 업데이트에서 데이터가 사용 가능하고 유효한지 여부를 식별하기 위해 해당 &quot;유효한&quot;속성 (예 : &lt;a href=&quot;qml-qtpositioning-position#coordinate-prop&quot;&gt;coordinate&lt;/a&gt; 및 &lt;a href=&quot;qml-qtpositioning-position#longitudeValid-prop&quot;&gt;longitudeValid&lt;/a&gt; , &lt;a href=&quot;qml-qtpositioning-position#latitudeValid-prop&quot;&gt;latitudeValid&lt;/a&gt; 등)을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b0d8841621d63d51d771e2e2c613af36d6311fa3" translate="yes" xml:space="preserve">
          <source>Not all properties of an Address are necessarily available or relevant in all parts of the world and all locales. The &lt;a href=&quot;qml-qtpositioning-address#district-prop&quot;&gt;district&lt;/a&gt;, &lt;a href=&quot;qml-qtpositioning-address#state-prop&quot;&gt;state&lt;/a&gt; and &lt;a href=&quot;qml-qtpositioning-address#county-prop&quot;&gt;county&lt;/a&gt; properties are particularly area-specific for many data sources, and often only one or two of these are available or useful.</source>
          <target state="translated">주소의 모든 속성이 전 세계 모든 지역과 모든 지역에서 반드시 사용 가능하거나 관련있는 것은 아닙니다. &lt;a href=&quot;qml-qtpositioning-address#district-prop&quot;&gt;지역&lt;/a&gt; , &lt;a href=&quot;qml-qtpositioning-address#state-prop&quot;&gt;주&lt;/a&gt; 및 &lt;a href=&quot;qml-qtpositioning-address#county-prop&quot;&gt;카운티&lt;/a&gt; 속성은 특히 많은 데이터 소스에 대한 영역 별, 그리고 종종 하나 또는이 두 가지가 가능하거나 유용합니다.</target>
        </trans-unit>
        <trans-unit id="962d6be12fe0eac2bdc039867712131ca6899413" translate="yes" xml:space="preserve">
          <source>Not all surfaces will block until the presentation of a frame has completed. Calling present() on a non-blocking surface may fail if called before the presentation of a previous frame has completed. In such cases the surface may not return to a ready state until it has had an opportunity to process events.</source>
          <target state="translated">프레임 표현이 완료 될 때까지 모든 표면이 차단되는 것은 아닙니다. 이전 프레임의 프리젠 테이션이 완료되기 전에 호출되면 비 블로킹 표면에서 present () 호출이 실패 할 수 있습니다. 이러한 경우 표면은 이벤트를 처리 할 기회가있을 때까지 준비 상태로 돌아 오지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3fc01800d08c9c3206cfa68087be7c2909531a14" translate="yes" xml:space="preserve">
          <source>Not all touch devices support velocity. If velocity is not supported, it will be reported as 0,0.</source>
          <target state="translated">모든 터치 장치가 속도를 지원하는 것은 아닙니다. 속도가 지원되지 않으면 0,0으로보고됩니다.</target>
        </trans-unit>
        <trans-unit id="6ba00239d6dc40ce03a913c0a89ce212b384ad4f" translate="yes" xml:space="preserve">
          <source>Not all valid PPD page sizes have a Windows equivalent, in which case 0 will be returned.</source>
          <target state="translated">유효한 모든 PPD 페이지 크기가 Windows에 해당하는 것은 아니며 0이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="3203211aa24373af4718f241bb6b795939f4c3b3" translate="yes" xml:space="preserve">
          <source>Not all views display headers with the item data, and those that do may be configured to hide them. Nonetheless, it is recommended that you implement the &lt;a href=&quot;qabstractitemmodel#headerData&quot;&gt;headerData()&lt;/a&gt; function to provide relevant information about the data provided by the model.</source>
          <target state="translated">모든보기에 항목 데이터가 포함 된 머리글이 표시되는 것은 아니며, 머리글이 숨겨 지도록 구성되어있을 수 있습니다. 그럼에도 불구하고 &lt;a href=&quot;qabstractitemmodel#headerData&quot;&gt;headerData ()&lt;/a&gt; 함수를 구현 하여 모델이 제공 한 데이터에 대한 관련 정보를 제공 하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="8b85856d4da04565a35cceabbe1540cc04131e83" translate="yes" xml:space="preserve">
          <source>Not all widgets have every state implemented. This goes for states that are common, e.g., &lt;code&gt;State_Disabled&lt;/code&gt;. Each state is, however, implemented for at least one widget.</source>
          <target state="translated">모든 위젯이 모든 상태를 구현하는 것은 아닙니다. 이것은 일반적인 상태, 예를 들어 &lt;code&gt;State_Disabled&lt;/code&gt; 입니다. 그러나 각 상태는 하나 이상의 위젯에 대해 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="8586cb1ea88fd85a6406b26c7b3c9748a4533c02" translate="yes" xml:space="preserve">
          <source>Not all widgets send a pointer to themselves. If the style option sent to the function does not contain the information you need, you should check the widget implementation to see if it sends a pointer to itself.</source>
          <target state="translated">모든 위젯이 자신에게 포인터를 보내는 것은 아닙니다. 함수에 전송 된 스타일 옵션에 필요한 정보가 포함되어 있지 않으면 위젯 구현이 자체 포인터를 보내는 지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="32d6504ce1831d0c3be30ad8947b92911e3d41b8" translate="yes" xml:space="preserve">
          <source>Not an event.</source>
          <target state="translated">이벤트가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="a1ec39debdd474dbcadef4bf3469aace2a9f7610" translate="yes" xml:space="preserve">
          <source>Not defined.</source>
          <target state="translated">정의되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="dc92a0df32bc60ff9b92002606a6591f2491a20e" translate="yes" xml:space="preserve">
          <source>Not null-terminated varying binary string with 4-byte string length indicator</source>
          <target state="translated">4 바이트 문자열 길이 표시기가있는 널 (NULL)로 끝나지 않는 가변 2 진 문자열</target>
        </trans-unit>
        <trans-unit id="e77db16315b46f2991cd4a5abcd4cb31fcfd4a86" translate="yes" xml:space="preserve">
          <source>Not null-terminated varying length character string</source>
          <target state="translated">널로 끝나지 않는 가변 길이 문자열</target>
        </trans-unit>
        <trans-unit id="6f5d1b24713be7170c0b03bb40b3d5a1daee26d8" translate="yes" xml:space="preserve">
          <source>Not officially supported, but technically possible via private APIs</source>
          <target state="translated">공식적으로 지원되지는 않지만 비공개 API를 통해 기술적으로 가능</target>
        </trans-unit>
        <trans-unit id="3bd71a4e5bb2166baabf9a764f892d60a8def717" translate="yes" xml:space="preserve">
          <source>Not only Qt itself but also Qt application can be extended through plugins. This requires the application to detect and load plugins using &lt;a href=&quot;qpluginloader&quot;&gt;QPluginLoader&lt;/a&gt;. In that context, plugins may provide arbitrary functionality and are not limited to database drivers, image formats, text codecs, styles, and the other types of plugin that extend Qt's functionality.</source>
          <target state="translated">Qt 자체뿐만 아니라 Qt 애플리케이션도 플러그인을 통해 확장 할 수 있습니다. 이를 위해서는 애플리케이션이 &lt;a href=&quot;qpluginloader&quot;&gt;QPluginLoader를&lt;/a&gt; 사용하여 플러그인을 감지하고로드해야합니다 . 이러한 맥락에서 플러그인은 임의의 기능을 제공 할 수 있으며 데이터베이스 드라이버, 이미지 형식, 텍스트 코덱, 스타일 및 Qt의 기능을 확장하는 다른 유형의 플러그인으로 제한되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6e5eb7862f18509dcd08c5340ad8a1271009d10f" translate="yes" xml:space="preserve">
          <source>Not only does handling events and logic in C++ increase performance, but it allows the visual QML layer to be a simple, declarative layer on top. This is reflected in the structure of the controls project: all visual implementations sit in the</source>
          <target state="translated">C ++에서 이벤트와 로직을 처리하면 성능이 향상 될뿐만 아니라 시각적 QML 레이어가 단순하고 선언적인 레이어가 될 수 있습니다. 이는 컨트롤 프로젝트의 구조에 반영됩니다. 모든 시각적 구현은</target>
        </trans-unit>
        <trans-unit id="842027b4684d01f4e4724ce27f032db3a919a5c1" translate="yes" xml:space="preserve">
          <source>Not recommended formats: all mono formats (for example &lt;a href=&quot;qimage#Format-enum&quot;&gt;QImage::Format_Mono&lt;/a&gt;).</source>
          <target state="translated">권장하지 않는 형식 : 모든 모노 형식 (예 &lt;a href=&quot;qimage#Format-enum&quot;&gt;: QImage :: Format_Mono&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="e8f5f22e840b92fdc264fab87319e2f73fd95cd2" translate="yes" xml:space="preserve">
          <source>Not sorted by default.</source>
          <target state="translated">기본적으로 정렬되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8e635455c1c04acc72cc3cb8b3930fa2002922c7" translate="yes" xml:space="preserve">
          <source>Not supported</source>
          <target state="translated">미지원</target>
        </trans-unit>
        <trans-unit id="9f838ec4724e773fa7ddcc0fca00bde7f8d8e7e8" translate="yes" xml:space="preserve">
          <source>Not yet initialized.</source>
          <target state="translated">아직 초기화되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="e6573a76306929c393f0738d4800b0353387f0a7" translate="yes" xml:space="preserve">
          <source>Not yet known due to no window and scenegraph associated</source>
          <target state="translated">연결된 창 및 장면 그래프가 없기 때문에 아직 알 수 없음</target>
        </trans-unit>
        <trans-unit id="25a623900f7593067a8d488822842096b3bd57c8" translate="yes" xml:space="preserve">
          <source>NotSupportedFeatureError</source>
          <target state="translated">NotSupportedFeatureError</target>
        </trans-unit>
        <trans-unit id="9fffe5c2260d7d5a26d9fd3ce7dcc5d930796c0e" translate="yes" xml:space="preserve">
          <source>Notation nodes can be imported, but at the moment there is no way to use them since the document type is read-only in DOM level 2.</source>
          <target state="translated">표기법 노드는 가져올 수 있지만 DOM 레벨 2에서는 문서 유형이 읽기 전용이므로 현재 사용할 수있는 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="2c924e3088204ee77ba681f72be3444357932fca" translate="yes" xml:space="preserve">
          <source>Note</source>
          <target state="translated">Note</target>
        </trans-unit>
        <trans-unit id="015ff47a539abb636c5f0168d82db93affb30ed0" translate="yes" xml:space="preserve">
          <source>Note about casting to a signed integer: all bits returned by this function are random, so there's a 50% chance that the most significant bit will be set. If you wish to cast the returned value to qint64 and keep it positive, you should mask the sign bit off:</source>
          <target state="translated">부호있는 정수로 캐스트하는 것에 대한 참고 사항 :이 함수가 반환하는 모든 비트는 임의이므로 가장 중요한 비트가 설정 될 확률은 50 %입니다. 리턴 값을 qint64로 캐스트하고 양수로 유지하려면 부호 비트를 마스킹해야합니다.</target>
        </trans-unit>
        <trans-unit id="78291faee746794d3b970b21a4d9546cfce34381" translate="yes" xml:space="preserve">
          <source>Note also that if a &lt;code&gt;SelfDestroyingRect&lt;/code&gt; instance was created statically like this:</source>
          <target state="translated">&lt;code&gt;SelfDestroyingRect&lt;/code&gt; 인스턴스가 다음과 같이 정적으로 생성 된 경우에도 유의 하십시오.</target>
        </trans-unit>
        <trans-unit id="0627974e1728db3fb678d692db4eb32b9e6f0969" translate="yes" xml:space="preserve">
          <source>Note also that remote applications may not have support for Unix file descriptor passing. If you make a D-Bus to a remote application that cannot receive such a type, you will receive an error reply. If you try to send a signal containing a D-Bus file descriptor or return one from a method call, the message will be silently dropped.</source>
          <target state="translated">또한 원격 애플리케이션은 Unix 파일 디스크립터 전달을 지원하지 않을 수 있습니다. 이러한 유형을 수신 할 수없는 원격 애플리케이션에 D-Bus를 만들면 오류 응답이 수신됩니다. D-Bus 파일 디스크립터가 포함 된 신호를 보내거나 메소드 호출에서 신호를 보내려고하면 메시지가 자동으로 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="89784bf26a30700386d678dbbc8d5cf94bed0b4a" translate="yes" xml:space="preserve">
          <source>Note also that the indentation style used by &lt;a href=&quot;qxmlformatter&quot;&gt;QXmlFormatter&lt;/a&gt; remains loosely defined and may change in future versions of Qt. If a specific indentation style is required then either use the base class &lt;a href=&quot;qxmlserializer&quot;&gt;QXmlSerializer&lt;/a&gt; directly, or write your own subclass of &lt;a href=&quot;qxmlserializer&quot;&gt;QXmlSerializer&lt;/a&gt; or &lt;a href=&quot;qabstractxmlreceiver&quot;&gt;QAbstractXmlReceiver&lt;/a&gt;. Alternatively, you can subclass &lt;a href=&quot;qxmlformatter&quot;&gt;QXmlFormatter&lt;/a&gt; and reimplement the callbacks there.</source>
          <target state="translated">또한 &lt;a href=&quot;qxmlformatter&quot;&gt;QXmlFormatter에서&lt;/a&gt; 사용하는 들여 쓰기 스타일 은 느슨하게 정의되어 있으며 향후 Qt 버전에서 변경 될 수 있습니다. 특정 들여 쓰기 스타일이 필요한 경우 기본 클래스 &lt;a href=&quot;qxmlserializer&quot;&gt;QXmlSerializer를&lt;/a&gt; 직접 사용 하거나 &lt;a href=&quot;qxmlserializer&quot;&gt;QXmlSerializer&lt;/a&gt; 또는 &lt;a href=&quot;qabstractxmlreceiver&quot;&gt;QAbstractXmlReceiver&lt;/a&gt; 의 자체 서브 클래스를 작성하십시오 . 또는 &lt;a href=&quot;qxmlformatter&quot;&gt;QXmlFormatter&lt;/a&gt; 를 서브 클래 싱 하고 콜백을 다시 구현할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4adc44fe61d744fdea6ad839a8d2a9f882123a92" translate="yes" xml:space="preserve">
          <source>Note for &lt;a href=&quot;qt#DateFormat-enum&quot;&gt;Qt::TextDate&lt;/a&gt;: It is recommended that you use the English short month names (e.g. &quot;Jan&quot;). Although localized month names can also be used, they depend on the user's locale settings.</source>
          <target state="translated">&lt;a href=&quot;qt#DateFormat-enum&quot;&gt;Qt :: TextDate&lt;/a&gt; 참고 사항 : 영어 짧은 달 이름 (예 : &quot;Jan&quot;)을 사용하는 것이 좋습니다. 현지화 된 월 이름도 사용할 수 있지만 사용자의 로캘 설정에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="b0a83b7a7b11d41214a6405b90e122a37090858e" translate="yes" xml:space="preserve">
          <source>Note for C Programmers</source>
          <target state="translated">C 프로그래머를위한 참고 사항</target>
        </trans-unit>
        <trans-unit id="524e49516a5ab947844836fabb4089a6f771aca8" translate="yes" xml:space="preserve">
          <source>Note for developers implementing classes derived from &lt;a href=&quot;qiodevice&quot;&gt;QIODevice&lt;/a&gt;: you should always emit readyRead() when new data has arrived (do not emit it only because there's data still to be read in your buffers). Do not emit readyRead() in other conditions.</source>
          <target state="translated">&lt;a href=&quot;qiodevice&quot;&gt;QIODevice&lt;/a&gt; 에서 파생 된 클래스를 구현하는 개발자를위한 참고 사항 : 새 데이터가 도착하면 항상 readyRead ()를 방출해야합니다 (버퍼에서 여전히 읽을 데이터가 있으므로 방출하지 마십시오). 다른 조건에서는 readyRead ()를 방출하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="f91253173a5e49ac5f89db760edadba6b49d5551" translate="yes" xml:space="preserve">
          <source>Note how &lt;a href=&quot;qdebug&quot;&gt;QDebug&lt;/a&gt; needed to close and reopen the string in the way C and C++ languages concatenate string literals so that the letter 'b' is not interpreted as part of the previous hexadecimal escape sequence.</source>
          <target state="translated">C 및 C ++ 언어가 문자열 리터럴을 연결하여 문자 'b'가 이전 16 진 이스케이프 시퀀스의 일부로 해석되지 않도록 &lt;a href=&quot;qdebug&quot;&gt;QDebug&lt;/a&gt; 가 문자열을 닫았다가 다시 열어야 하는 방법에 주목 하십시오.</target>
        </trans-unit>
        <trans-unit id="fbd56c9be9e27b30363c658a176dc95d30207896" translate="yes" xml:space="preserve">
          <source>Note how the &lt;code&gt;color&lt;/code&gt; assignment in each &lt;a href=&quot;qml-qtquick-controls2-control#background-prop&quot;&gt;background&lt;/a&gt; item qualifies the attached property with the &lt;code&gt;id&lt;/code&gt; of the label. This is important; using the attached properties on an item causes that item to accept events. Suppose we had left out the &lt;code&gt;id&lt;/code&gt; in the previous example:</source>
          <target state="translated">각 &lt;a href=&quot;qml-qtquick-controls2-control#background-prop&quot;&gt;배경&lt;/a&gt; 항목 의 &lt;code&gt;color&lt;/code&gt; 지정 이 레이블 의 &lt;code&gt;id&lt;/code&gt; 로 첨부 된 특성을 규정하는 방법에 유의하십시오 . 이건 중요하다; 항목에 첨부 된 특성을 사용하면 해당 항목이 이벤트를 승인합니다. 이전 예에서 &lt;code&gt;id&lt;/code&gt; 를 생략했다고 가정 해 봅시다 .</target>
        </trans-unit>
        <trans-unit id="676031fd8bdd1d3aa072d6ba96563b7ff17a35ac" translate="yes" xml:space="preserve">
          <source>Note how this function can be used to encode numbers that cannot fit a standard computer's 64-bit signed integer like &lt;a href=&quot;qtglobal#qint64-typedef&quot;&gt;qint64&lt;/a&gt;. That is, if</source>
          <target state="translated">이 함수를 사용하여 &lt;a href=&quot;qtglobal#qint64-typedef&quot;&gt;qint64&lt;/a&gt; 와 같은 표준 컴퓨터의 64 비트 부호있는 정수에 맞지 않는 숫자를 인코딩 할 수 있습니다 . 즉,</target>
        </trans-unit>
        <trans-unit id="22f88e3599162afb62355973cff16ea10f05035e" translate="yes" xml:space="preserve">
          <source>Note how, on Windows, environment variable names are case-insensitive.</source>
          <target state="translated">Windows에서 환경 변수 이름은 대소 문자를 구분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0c60e32b43b419a0e7d7483babc7759b41fe7acd" translate="yes" xml:space="preserve">
          <source>Note however that it is rare to require the full location to the library in &lt;code&gt;CMake&lt;/code&gt; code. Most &lt;code&gt;CMake&lt;/code&gt; APIs are aware of imported targets and can automatically use them instead of the full path.</source>
          <target state="translated">그러나 &lt;code&gt;CMake&lt;/code&gt; 코드 에서 라이브러리의 전체 위치를 요구하는 경우는 드 rare니다 . 대부분의 &lt;code&gt;CMake&lt;/code&gt; API는 가져온 대상을 알고 있으며 전체 경로 대신 자동으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea4769bf74eddade1742d3c53812aaead1c81bd2" translate="yes" xml:space="preserve">
          <source>Note it is the responsibility of the creator to delete any &lt;a href=&quot;qqmlcontext&quot;&gt;QQmlContext&lt;/a&gt; it constructs. If the &lt;code&gt;context&lt;/code&gt; object in the example is no longer needed when the &lt;code&gt;window&lt;/code&gt; component instance is destroyed, the &lt;code&gt;context&lt;/code&gt; must be destroyed explicitly. The simplest way to ensure this is to set &lt;code&gt;window&lt;/code&gt; as the parent of &lt;code&gt;context&lt;/code&gt;.</source>
          <target state="translated">생성 하는 &lt;a href=&quot;qqmlcontext&quot;&gt;QQmlContext&lt;/a&gt; 를 삭제하는 것은 작성자의 책임입니다 . &lt;code&gt;window&lt;/code&gt; 구성 요소 인스턴스가 삭제 될 때 예제 의 &lt;code&gt;context&lt;/code&gt; 객체가 더 이상 필요하지 않은 경우 &lt;code&gt;context&lt;/code&gt; 를 명시 적으로 삭제해야합니다. 이를 확인하는 가장 간단한 방법은 &lt;code&gt;window&lt;/code&gt; 를 &lt;code&gt;context&lt;/code&gt; 의 부모 로 설정 하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="31b1bc7a853c52f86f4dd2c153ca34a958ed01fa" translate="yes" xml:space="preserve">
          <source>Note on X11 that if the given</source>
          <target state="translated">X11에서 주어진 경우</target>
        </trans-unit>
        <trans-unit id="da7038b6159ab37164aeb7442907c881108aff7e" translate="yes" xml:space="preserve">
          <source>Note that</source>
          <target state="translated">참고</target>
        </trans-unit>
        <trans-unit id="3db560280e1f6e816ba01598c91fee31d617f580" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;activeqt-dumpcpp#&quot;&gt;dumpcpp&lt;/a&gt; might not be able to expose all APIs in the type library.</source>
          <target state="translated">참고 &lt;a href=&quot;activeqt-dumpcpp#&quot;&gt;dumpcpp은&lt;/a&gt; 형식 라이브러리에있는 모든 API를 노출 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="0a9c06cd50e70c72456a5d42a3654e7c8c51fe47" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtquick-animation-example.html#propertyanimation&quot;&gt;PropertyAnimation&lt;/a&gt; inherits the abstract &lt;a href=&quot;qml-qtquick-animation&quot;&gt;Animation&lt;/a&gt; type. This includes additional properties and methods for controlling the animation.</source>
          <target state="translated">참고 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtquick-animation-example.html#propertyanimation&quot;&gt;PropertyAnimation이&lt;/a&gt; 추상 상속 &lt;a href=&quot;qml-qtquick-animation&quot;&gt;애니메이션&lt;/a&gt; 유형입니다. 여기에는 애니메이션을 제어하기위한 추가 속성 및 방법이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="51112e83439ea9185236a49948d674a044a2d355" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;qabstractlistmodel&quot;&gt;QAbstractListModel&lt;/a&gt; provides a default implementation of &lt;a href=&quot;qabstractitemmodel#columnCount&quot;&gt;columnCount&lt;/a&gt;() that informs views that there is only a single column of items in this model.</source>
          <target state="translated">참고 것을 &lt;a href=&quot;qabstractlistmodel&quot;&gt;QAbstractListModel가&lt;/a&gt; 의 디폴트 구현을 제공 &lt;a href=&quot;qabstractitemmodel#columnCount&quot;&gt;열 개수를&lt;/a&gt; ()이 모델 항목의 단일 열이 있다는 정보 용의 전망이.</target>
        </trans-unit>
        <trans-unit id="04b3091c1ff527eddb1f5091d90cbcc4eb6aa25c" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;qdatawidgetmapper&quot;&gt;QDataWidgetMapper&lt;/a&gt; keeps track of external modifications. If the contents of the model are updated in another module of the application, the widgets are updated as well.</source>
          <target state="translated">참고 &lt;a href=&quot;qdatawidgetmapper&quot;&gt;QDataWidgetMapper는&lt;/a&gt; 외부 수정을 추적합니다. 모델의 컨텐츠가 애플리케이션의 다른 모듈에서 업데이트되면 위젯도 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="48a55db1c76a7d0a6dd409ddfa1de6ac6399ee72" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;qdbusconnection&quot;&gt;QDBusConnection&lt;/a&gt; objects are reference counted: &lt;a href=&quot;qdbusservicewatcher&quot;&gt;QDBusServiceWatcher&lt;/a&gt; will keep a reference for this connection while it exists. The connection is not closed until the reference count drops to zero, so this will ensure that any notifications are received while this &lt;a href=&quot;qdbusservicewatcher&quot;&gt;QDBusServiceWatcher&lt;/a&gt; object exists.</source>
          <target state="translated">참고 &lt;a href=&quot;qdbusconnection&quot;&gt;QDBusConnection의&lt;/a&gt; 객체 참조입니다 카운트 : &lt;a href=&quot;qdbusservicewatcher&quot;&gt;QDBusServiceWatcher이&lt;/a&gt; 존재하는 동안이 연결에 대한 참조를 유지합니다. 참조 카운트가 0으로 떨어질 때까지 연결이 닫히지 &lt;a href=&quot;qdbusservicewatcher&quot;&gt;않으므로이 QDBusServiceWatcher&lt;/a&gt; 오브젝트가 존재 하는 동안 모든 알림이 수신 됩니다.</target>
        </trans-unit>
        <trans-unit id="0939a2c7cd032c04beaaad8f3d5fb3a0d5bab849" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;qdbusunixfiledescriptor&quot;&gt;QDBusUnixFileDescriptor&lt;/a&gt; continues to operate even if this function returns &lt;code&gt;false&lt;/code&gt;. The only difference is that the &lt;a href=&quot;qdbusunixfiledescriptor&quot;&gt;QDBusUnixFileDescriptor&lt;/a&gt; objects will always be in the &lt;a href=&quot;qdbusunixfiledescriptor#isValid&quot;&gt;isValid&lt;/a&gt;() == false state and &lt;a href=&quot;qdbusunixfiledescriptor#fileDescriptor&quot;&gt;fileDescriptor&lt;/a&gt;() will always return -1. The class will not consume any operating system resources.</source>
          <target state="translated">참고 &lt;a href=&quot;qdbusunixfiledescriptor&quot;&gt;QDBusUnixFileDescriptor가&lt;/a&gt; 이 기능을 반환하는 경우에도 계속 작동 &lt;code&gt;false&lt;/code&gt; . 유일한 차이점은 &lt;a href=&quot;qdbusunixfiledescriptor&quot;&gt;QDBusUnixFileDescriptor&lt;/a&gt; 오브젝트가 항상 &lt;a href=&quot;qdbusunixfiledescriptor#isValid&quot;&gt;isValid&lt;/a&gt; () == false 상태이고 &lt;a href=&quot;qdbusunixfiledescriptor#fileDescriptor&quot;&gt;fileDescriptor&lt;/a&gt; ()가 항상 -1을 리턴한다는 것입니다. 이 클래스는 운영 체제 리소스를 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cd3d2cf05bbce22aa85a785f7e7823aac6ab3c8e" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;qdialog&quot;&gt;QDialog&lt;/a&gt; (and any other widget that has type &lt;code&gt;Qt::Dialog&lt;/code&gt;) uses the parent widget slightly differently from other classes in Qt. A dialog is always a top-level widget, but if it has a parent, its default location is centered on top of the parent's top-level widget (if it is not top-level itself). It will also share the parent's taskbar entry.</source>
          <target state="translated">참고 &lt;a href=&quot;qdialog&quot;&gt;인 QDialog&lt;/a&gt; (및 입력이 다른 위젯 &lt;code&gt;Qt::Dialog&lt;/code&gt; ) Qt는 다른 클래스에서 다른 위젯 약간의 부모를 사용합니다. 대화 상자는 항상 최상위 위젯이지만 부모가있는 경우 기본 위치는 부모의 최상위 위젯 (중앙 자체가 아닌 경우)의 상단에 위치합니다. 부모의 작업 표시 줄 항목도 공유합니다.</target>
        </trans-unit>
        <trans-unit id="b80777599e58e9446dc22937776b43054491f5ae" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;qdomnamednodemap&quot;&gt;QDomNamedNodeMap&lt;/a&gt; does not inherit from &lt;a href=&quot;qdomnodelist&quot;&gt;QDomNodeList&lt;/a&gt;. QDomNamedNodeMaps do not provide any specific node ordering. Although nodes in a &lt;a href=&quot;qdomnamednodemap&quot;&gt;QDomNamedNodeMap&lt;/a&gt; may be accessed by an ordinal index, this is simply to allow a convenient enumeration of the contents of a &lt;a href=&quot;qdomnamednodemap&quot;&gt;QDomNamedNodeMap&lt;/a&gt;, and does not imply that the DOM specifies an ordering of the nodes.</source>
          <target state="translated">참고 &lt;a href=&quot;qdomnamednodemap&quot;&gt;QDomNamedNodeMap이&lt;/a&gt; 상속되지 않습니다 &lt;a href=&quot;qdomnodelist&quot;&gt;QDomNodeList&lt;/a&gt; . QDomNamedNodeMaps는 특정 노드 순서를 제공하지 않습니다. &lt;a href=&quot;qdomnamednodemap&quot;&gt;QDomNamedNodeMap의&lt;/a&gt; 노드 는 서수 색인으로 액세스 할 수 있지만 이는 단순히 &lt;a href=&quot;qdomnamednodemap&quot;&gt;QDomNamedNodeMap&lt;/a&gt; 의 컨텐츠를 편리하게 열거 할 수 있도록하기위한 것이며 DOM이 노드의 순서를 지정한다는 것을 의미하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="243b04cbdaab0538fed1f2a736c93742d1cba34f" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;qdrag#setMimeData&quot;&gt;setMimeData&lt;/a&gt;() assigns ownership of the &lt;a href=&quot;qmimedata&quot;&gt;QMimeData&lt;/a&gt; object to the &lt;a href=&quot;qdrag&quot;&gt;QDrag&lt;/a&gt; object. The &lt;a href=&quot;qdrag&quot;&gt;QDrag&lt;/a&gt; must be constructed on the heap with a parent &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; to ensure that Qt can clean up after the drag and drop operation has been completed.</source>
          <target state="translated">참고 &lt;a href=&quot;qdrag#setMimeData&quot;&gt;setMimeData&lt;/a&gt; 의 () 양수인의 소유권 &lt;a href=&quot;qmimedata&quot;&gt;QMimeData를&lt;/a&gt; 받는 객체 &lt;a href=&quot;qdrag&quot;&gt;QDrag의&lt;/a&gt; 객체입니다. &lt;a href=&quot;qdrag&quot;&gt;QDrag는&lt;/a&gt; 부모와 힙에 건설해야 &lt;a href=&quot;qobject&quot;&gt;QObject를&lt;/a&gt; Qt는이 드래그 앤 드롭 작업을 완료 한 후 정리 할 수 있도록.</target>
        </trans-unit>
        <trans-unit id="a5adc6ccbaabdc9e07b310f22a81a308f7946bd1" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; has no visual appearance of its own; it only manages the items. You need to create a &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; widget to visualize the scene.</source>
          <target state="translated">참고 &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene는&lt;/a&gt; 자신의 시각적 외관이 없습니다; 항목 만 관리합니다. 장면을 시각화하려면 &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; 위젯 을 작성해야합니다 .</target>
        </trans-unit>
        <trans-unit id="86243ea5c2f4d1f7f91240687db5414e0045d3a1" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;qgraphicstextitem&quot;&gt;QGraphicsTextItem&lt;/a&gt; keeps a &lt;a href=&quot;qtextdocument&quot;&gt;QTextDocument&lt;/a&gt; internally, which is used to calculate the text width.</source>
          <target state="translated">참고 &lt;a href=&quot;qgraphicstextitem&quot;&gt;QGraphicsTextItem가&lt;/a&gt; 유지 &lt;a href=&quot;qtextdocument&quot;&gt;QTextDocument을&lt;/a&gt; 텍스트 폭을 계산하는 데 사용되는, 내부적으로.</target>
        </trans-unit>
        <trans-unit id="9d1654e3b6bd820612e41913f0754b999bb9eed0" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; currently supports background caching only (see &lt;a href=&quot;qgraphicsview#CacheModeFlag-enum&quot;&gt;QGraphicsView::CacheBackground&lt;/a&gt;). This function is equivalent to calling &lt;a href=&quot;qgraphicsscene#update&quot;&gt;update&lt;/a&gt;() if any layer but &lt;a href=&quot;qgraphicsscene#SceneLayer-enum&quot;&gt;BackgroundLayer&lt;/a&gt; is passed.</source>
          <target state="translated">주의 &lt;a href=&quot;qgraphicsview&quot;&gt;를 QGraphicsView가&lt;/a&gt; 현재는 배경 캐싱을 지원한다 (참조 &lt;a href=&quot;qgraphicsview#CacheModeFlag-enum&quot;&gt;를 QGraphicsView :: CacheBackground을&lt;/a&gt; ). 이 함수는 &lt;a href=&quot;qgraphicsscene#SceneLayer-enum&quot;&gt;BackgroundLayer&lt;/a&gt; 이외의 레이어 가 전달 된 경우 &lt;a href=&quot;qgraphicsscene#update&quot;&gt;update&lt;/a&gt; () 를 호출하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="603ca9427a566e53d85505314ccc6c860ead5030" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; currently supports background caching only (see &lt;a href=&quot;qgraphicsview#CacheModeFlag-enum&quot;&gt;QGraphicsView::CacheBackground&lt;/a&gt;). This function is equivalent to calling &lt;a href=&quot;qwidget#update&quot;&gt;update&lt;/a&gt;() if any layer but &lt;a href=&quot;qgraphicsscene#SceneLayer-enum&quot;&gt;QGraphicsScene::BackgroundLayer&lt;/a&gt; is passed.</source>
          <target state="translated">주의 &lt;a href=&quot;qgraphicsview&quot;&gt;를 QGraphicsView가&lt;/a&gt; 현재는 배경 캐싱을 지원한다 (참조 &lt;a href=&quot;qgraphicsview#CacheModeFlag-enum&quot;&gt;를 QGraphicsView :: CacheBackground을&lt;/a&gt; ). 이 함수는 &lt;a href=&quot;qgraphicsscene#SceneLayer-enum&quot;&gt;QGraphicsScene :: BackgroundLayer를&lt;/a&gt; 제외한 모든 레이어 가 전달 되면 &lt;a href=&quot;qwidget#update&quot;&gt;update&lt;/a&gt; () 를 호출하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="2b76c78b141e2ed8e8e803aa5356e7c411a6757e" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt; uses &lt;a href=&quot;implicit-sharing&quot;&gt;implicit data sharing&lt;/a&gt;, but this function does</source>
          <target state="translated">참고 것을 &lt;a href=&quot;qimage&quot;&gt;QImage는&lt;/a&gt; 사용 &lt;a href=&quot;implicit-sharing&quot;&gt;암시 적 데이터를 공유&lt;/a&gt; 하지만,이 기능을 수행합니다</target>
        </trans-unit>
        <trans-unit id="c11122ee827cea6787a4f72c0273362dcd876144" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt; uses &lt;a href=&quot;implicit-sharing&quot;&gt;implicit data sharing&lt;/a&gt;. This function performs a deep copy of the shared pixel data, thus ensuring that this &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt; is the only one using the current return value.</source>
          <target state="translated">참고 &lt;a href=&quot;qimage&quot;&gt;QImage가&lt;/a&gt; 사용하는 &lt;a href=&quot;implicit-sharing&quot;&gt;암시 적 데이터 공유를&lt;/a&gt; . 이 함수는 공유 픽셀 데이터의 딥 카피를 수행 &lt;a href=&quot;qimage&quot;&gt;하므로이 QImage&lt;/a&gt; 가 현재 반환 값을 사용하는 유일한 것입니다.</target>
        </trans-unit>
        <trans-unit id="7046dacd9d7f26f3b8a09121e6a1f869ebcdcc10" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;qjsvalueiterator&quot;&gt;QJSValueIterator&lt;/a&gt; only iterates over the &lt;a href=&quot;qjsvalue&quot;&gt;QJSValue&lt;/a&gt;'s own properties; i.e. it does not follow the prototype chain. You can use a loop like this to follow the prototype chain:</source>
          <target state="translated">참고 &lt;a href=&quot;qjsvalueiterator&quot;&gt;QJSValueIterator은&lt;/a&gt; 단지 반복 할 &lt;a href=&quot;qjsvalue&quot;&gt;QJSValue&lt;/a&gt; 의 자신의 특성; 즉, 프로토 타입 체인을 따르지 않습니다. 다음과 같은 루프를 사용하여 프로토 타입 체인을 따를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="def7c9812aa10f0017764277681b342cb59ef9c0" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;qkeyevent&quot;&gt;QKeyEvent&lt;/a&gt; starts with isAccepted() == true, so you do not need to call &lt;a href=&quot;qevent#accept&quot;&gt;QKeyEvent::accept&lt;/a&gt;() - just do not call the base class implementation if you act upon the key.</source>
          <target state="translated">참고 &lt;a href=&quot;qkeyevent&quot;&gt;QKeyEvent가&lt;/a&gt; 전화 할 필요가 없습니다, () == 사실 isAccepted 시작 &lt;a href=&quot;qevent#accept&quot;&gt;QKeyEvent이 : 동의&lt;/a&gt; 당신은 키에 따라 행동한다면 단지 기본 클래스 구현을 호출하지 않습니다 - ().</target>
        </trans-unit>
        <trans-unit id="3ae9933f28a68b82b83d2b8371342bc806c2ec90" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;qlabel&quot;&gt;QLabel&lt;/a&gt; is well-suited to display small rich text documents, such as small documents that get their document specific settings (font, text color, link color) from the label's palette and font properties. For large documents, use &lt;a href=&quot;qtextedit&quot;&gt;QTextEdit&lt;/a&gt; in read-only mode instead. &lt;a href=&quot;qtextedit&quot;&gt;QTextEdit&lt;/a&gt; can also provide a scroll bar when necessary.</source>
          <target state="translated">참고 &lt;a href=&quot;qlabel&quot;&gt;QLabel이&lt;/a&gt; 같은 자신의 문서의 특정 설정 (글꼴, 텍스트 색상, 링크 색상) 레이블의 팔레트 및 글꼴 속성에서 얻을 작은 문서 작은 리치 텍스트 문서를 표시하는 데 적합하다. 큰 문서의 경우 &lt;a href=&quot;qtextedit&quot;&gt;QTextEdit&lt;/a&gt; 을 읽기 전용 모드로 대신 사용하십시오. &lt;a href=&quot;qtextedit&quot;&gt;QTextEdit&lt;/a&gt; 은 필요할 때 스크롤 막대를 제공 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="368f567dca31b26ef7798f89c23de9aa24e60ea9" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt; uses 0-based indexes, just like C++ arrays. Negative indexes are not supported with the exception of the value mentioned above.</source>
          <target state="translated">참고 것을 &lt;a href=&quot;qlist&quot;&gt;QList은&lt;/a&gt; 단지 C ++ 배열과 같은 0 기반 인덱스를 사용합니다. 위에서 언급 한 값을 제외하고 음수 인덱스는 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="77f39a579a77378a4bdfabd2686075145245f760" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;qlockfile#tryLock&quot;&gt;tryLock&lt;/a&gt;() automatically deleted the file if there is no running application with this PID, so &lt;a href=&quot;qlockfile#LockError-enum&quot;&gt;LockFailedError&lt;/a&gt; can only happen if there is an application with this PID (it could be unrelated though).</source>
          <target state="translated">참고 &lt;a href=&quot;qlockfile#tryLock&quot;&gt;설정된 tryLock가&lt;/a&gt; 이 PID 아무런 실행중인 응용 프로그램이없는 경우, 그래서 () 자동으로 파일을 삭제 &lt;a href=&quot;qlockfile#LockError-enum&quot;&gt;LockFailedError가&lt;/a&gt; 이 PID를 사용하여 응용 프로그램이있는 경우에만 발생할 수 있습니다 (이것은 관련이없는 생각 될 수있다).</target>
        </trans-unit>
        <trans-unit id="9808fbc78b15d8973285a87ef11b6a5c37ce11bd" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;qmacnativewidget&quot;&gt;QMacNativeWidget&lt;/a&gt; requires knowledge of Cocoa. All it does is get the Qt hierarchy into a window not owned by Qt. It is then up to the programmer to ensure it is placed correctly in the window and responds correctly to events.</source>
          <target state="translated">참고 &lt;a href=&quot;qmacnativewidget&quot;&gt;QMacNativeWidget은&lt;/a&gt; 코코아의 지식이 필요합니다. Qt 계층 구조를 Qt가 소유하지 않은 창으로 가져 오기만하면됩니다. 그러면 창에 올바르게 배치되고 이벤트에 올바르게 응답하는지 확인하는 것은 프로그래머에게 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f44dab8449936746fcfdb72d394a1f684c24c4c" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;qml-qtquick-numberanimation&quot;&gt;NumberAnimation&lt;/a&gt; may not animate smoothly if there are irregular changes in the number value that it is tracking. If this is the case, use &lt;a href=&quot;qml-qtquick-smoothedanimation&quot;&gt;SmoothedAnimation&lt;/a&gt; instead.</source>
          <target state="translated">참고 &lt;a href=&quot;qml-qtquick-numberanimation&quot;&gt;NumberAnimation&lt;/a&gt; 하지 애니메이션 원활이 추적하고있는 숫자 값의 불규칙적 인 변화가있을 경우에 할 수있다. 이 경우 대신 &lt;a href=&quot;qml-qtquick-smoothedanimation&quot;&gt;SmoothedAnimation을&lt;/a&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="5ac02058d2a5cb6e6da39bb59bcf6f0dd036f75d" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt; expects a standard conformant implementation of resource sharing when it comes to the underlying graphics drivers. For example, some drivers, in particular for mobile and embedded hardware, have issues with setting up sharing between an existing context and others that are created later. Some other drivers may behave in unexpected ways when trying to utilize shared resources between different threads.</source>
          <target state="translated">참고 &lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget는&lt;/a&gt; 이 기본 그래픽 드라이버에 관해서 자원 공유의 표준 준수 구현을 기대하고있다. 예를 들어 일부 드라이버, 특히 모바일 및 임베디드 하드웨어의 경우 기존 컨텍스트와 나중에 생성되는 다른 컨텍스트간에 공유를 설정하는 데 문제가 있습니다. 다른 스레드간에 공유 리소스를 사용하려고 할 때 일부 다른 드라이버가 예기치 않은 방식으로 작동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f05a95f7a6d8dcb3b6d106c49597f8074ab9980a" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;qremoteobjectnode#acquire&quot;&gt;acquire()&lt;/a&gt; returns a pointer to the replica. However, it does not manage the pointer lifetime. This example uses the recommended process of wrapping the returned pointer in a &lt;a href=&quot;qsharedpointer&quot;&gt;QSharedPointer&lt;/a&gt; or &lt;a href=&quot;qscopedpointer&quot;&gt;QScopedPointer&lt;/a&gt; to ensure the pointer is properly deleted.</source>
          <target state="translated">그 주 &lt;a href=&quot;qremoteobjectnode#acquire&quot;&gt;() 취득을&lt;/a&gt; 복제에 대한 포인터를 반환한다. 그러나 포인터 수명은 관리하지 않습니다. 이 예에서는 반환 된 포인터를 &lt;a href=&quot;qsharedpointer&quot;&gt;QSharedPointer&lt;/a&gt; 또는 &lt;a href=&quot;qscopedpointer&quot;&gt;QScopedPointer&lt;/a&gt; 에 래핑하는 권장 프로세스 를 사용하여 포인터가 올바르게 삭제되도록합니다.</target>
        </trans-unit>
        <trans-unit id="eea61f71792f146e0b1526ff0917351d790205b9" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;qsensorreading&quot;&gt;QSensorReading&lt;/a&gt; is not particularly useful by itself. The interesting data for each sensor is defined in a sub-class of &lt;a href=&quot;qsensorreading&quot;&gt;QSensorReading&lt;/a&gt;.</source>
          <target state="translated">참고 &lt;a href=&quot;qsensorreading&quot;&gt;QSensorReading은&lt;/a&gt; 그 자체로 특히 유용하지 않습니다. 각 센서에 대한 흥미로운 데이터는 &lt;a href=&quot;qsensorreading&quot;&gt;QSensorReading&lt;/a&gt; 의 하위 클래스에 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="01568234e1fbad976c23a680e0ad6a9d79205ccd" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;qsettings#sync&quot;&gt;sync&lt;/a&gt;() imports changes made by other processes (in addition to writing the changes from this &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt;).</source>
          <target state="translated">참고 &lt;a href=&quot;qsettings#sync&quot;&gt;동기화&lt;/a&gt; (이 기록의 변경에 부가하여 다른 프로세스에 의해 () 수입 변화 &lt;a href=&quot;qsettings&quot;&gt;QSettings을&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="e8b8113db50f572d9dc54559a37ae8d25b04cf34" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;qstatusbar&quot;&gt;QStatusBar&lt;/a&gt; already uses this widget, so if you have a status bar (e.g., you are using &lt;a href=&quot;qmainwindow&quot;&gt;QMainWindow&lt;/a&gt;), then you don't need to use this widget explicitly. The same goes for &lt;a href=&quot;qdialog&quot;&gt;QDialog&lt;/a&gt;, for which you can just call &lt;a href=&quot;qdialog#sizeGripEnabled-prop&quot;&gt;QDialog::setSizeGripEnabled()&lt;/a&gt;.</source>
          <target state="translated">참고 &lt;a href=&quot;qstatusbar&quot;&gt;QStatusBar가&lt;/a&gt; 이미이 상태 표시 줄 (예를 들어, 당신이 사용하고있는 그렇다면,이 위젯을 사용 &lt;a href=&quot;qmainwindow&quot;&gt;QMainWindow는&lt;/a&gt; ) 다음 위젯 명시 적으로이를 사용할 필요가 없습니다. 동일은 간다 &lt;a href=&quot;qdialog&quot;&gt;인 QDialog&lt;/a&gt; ,하는 당신은 그냥 호출 할 수 있습니다 &lt;a href=&quot;qdialog#sizeGripEnabled-prop&quot;&gt;인 QDialog :: setSizeGripEnabled ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e32d4052b402192b0bbc56d313b24e224eb18676" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;qstorageinfo#fileSystemType&quot;&gt;fileSystemType&lt;/a&gt;(), &lt;a href=&quot;qstorageinfo#name&quot;&gt;name&lt;/a&gt;(), &lt;a href=&quot;qstorageinfo#bytesTotal&quot;&gt;bytesTotal&lt;/a&gt;(), &lt;a href=&quot;qstorageinfo#bytesFree&quot;&gt;bytesFree&lt;/a&gt;(), and &lt;a href=&quot;qstorageinfo#bytesAvailable&quot;&gt;bytesAvailable&lt;/a&gt;() will return invalid data until the volume is ready.</source>
          <target state="translated">참고 &lt;a href=&quot;qstorageinfo#fileSystemType&quot;&gt;fileSystemType&lt;/a&gt; (), &lt;a href=&quot;qstorageinfo#name&quot;&gt;이름&lt;/a&gt; (), &lt;a href=&quot;qstorageinfo#bytesTotal&quot;&gt;bytesTotal이라는&lt;/a&gt; (), &lt;a href=&quot;qstorageinfo#bytesFree&quot;&gt;bytesFree&lt;/a&gt; () 및 &lt;a href=&quot;qstorageinfo#bytesAvailable&quot;&gt;됨 bytesAvailable&lt;/a&gt; () 볼륨이 준비가 될 때까지 유효하지 않은 데이터를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="13e44de3a15f99ed5e6ab5c45efb067e59ab7397" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;qthreadpool&quot;&gt;QThreadPool&lt;/a&gt; is a low-level class for managing threads, see the Qt Concurrent module for higher level alternatives.</source>
          <target state="translated">참고 것을 &lt;a href=&quot;qthreadpool&quot;&gt;QThreadPool가&lt;/a&gt; 스레드를 관리하기위한 낮은 수준의 클래스이며, 높은 수준의 대안을 Qt의 동시 모듈을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f7ae6afdce1a09ef8640e7890d29beadbbc60b34" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;qtimer&quot;&gt;QTimer&lt;/a&gt;'s accuracy depends on the underlying operating system and hardware. The</source>
          <target state="translated">참고 &lt;a href=&quot;qtimer&quot;&gt;QTimer&lt;/a&gt; 의 정확성은 기본 운영 체제 및 하드웨어에 따라 달라집니다. 그만큼</target>
        </trans-unit>
        <trans-unit id="8af2d579def40907b72f15358ae69a4874cc07f4" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;qurl#ComponentFormattingOption-enum&quot;&gt;QUrl::FullyDecoded&lt;/a&gt; may cause data loss if those non-representable sequences are present. It is recommended to use that value when the result will be used in a non-URL context, such as sending to an FTP server.</source>
          <target state="translated">참고 &lt;a href=&quot;qurl#ComponentFormattingOption-enum&quot;&gt;QUrl :: FullyDecoded는&lt;/a&gt; 그 비 표현할 서열이 존재하는 경우 데이터가 손실 될 수있다. 결과가 FTP 서버로 전송과 같은 비 URL 컨텍스트에서 사용될 경우이 값을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="73ff03aa05dc2cd5491aa46f27c722638ef5f927" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;qurl#ComponentFormattingOption-enum&quot;&gt;QUrl::FullyDecoded&lt;/a&gt; may cause data loss if those non-representable sequences are present. It is recommended to use that value when the result will be used in a non-URL context, such as setting in &lt;a href=&quot;qauthenticator&quot;&gt;QAuthenticator&lt;/a&gt; or negotiating a login.</source>
          <target state="translated">참고 &lt;a href=&quot;qurl#ComponentFormattingOption-enum&quot;&gt; QUrl :: FullyDecoded는&lt;/a&gt; 그 비 표현할 서열이 존재하는 경우 데이터가 손실 될 수있다. &lt;a href=&quot;qauthenticator&quot;&gt;QAuthenticator&lt;/a&gt; 설정 또는 로그인 협상 과 같이 URL 이외의 컨텍스트에서 결과를 사용할 경우이 값을 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="a83c0390d5bc660a116f87bfe6f13e3b2d3ba7b1" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;qurl#ComponentFormattingOption-enum&quot;&gt;QUrl::FullyDecoded&lt;/a&gt; may cause data loss if those non-representable sequences are present. It is recommended to use that value when the result will be used in a non-URL context.</source>
          <target state="translated">참고 &lt;a href=&quot;qurl#ComponentFormattingOption-enum&quot;&gt; QUrl :: FullyDecoded는&lt;/a&gt; 그 비 표현할 서열이 존재하는 경우 데이터가 손실 될 수있다. URL이 아닌 컨텍스트에서 결과가 사용될 때 해당 값을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="b29bacb16e32df19b6b77f4512b984fafca759f0" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;qwidget#event&quot;&gt;QWidget::event&lt;/a&gt;() is still called for all of the cases not handled, and that the return value indicates whether an event was dealt with; a &lt;code&gt;true&lt;/code&gt; value prevents the event from being sent on to other objects.</source>
          <target state="translated">참고 &lt;a href=&quot;qwidget#event&quot;&gt;는 QWidget :: 이벤트&lt;/a&gt; () 아직도 처리되는 모든 경우에 대해 호출하고, 반환 값은 이벤트가 처리되었는지 여부를 나타내는 것을; &lt;code&gt;true&lt;/code&gt; 값은 다른 개체에 전송되는 이벤트를 방지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa776dc890a079efeac9b44ee8914debf04d753c" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;qxmlname&quot;&gt;QXmlName&lt;/a&gt;'s default constructor constructs a null instance. It is typically used for allocating unused entries in collections of &lt;a href=&quot;qxmlname&quot;&gt;QXmlName&lt;/a&gt;.</source>
          <target state="translated">참고 &lt;a href=&quot;qxmlname&quot;&gt;QXmlName을&lt;/a&gt; 의 기본 생성자는 널 (null) 인스턴스를 구축합니다. 일반적으로 &lt;a href=&quot;qxmlname&quot;&gt;QXmlName&lt;/a&gt; 콜렉션에 사용되지 않은 항목을 할당하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="f8dad27f3d2cb0fd4c5e02be9e64cf9b6c042ccf" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;C:\interbase\bin&lt;/code&gt; must be in the &lt;code&gt;PATH&lt;/code&gt;.</source>
          <target state="translated">참고 &lt;code&gt;C:\interbase\bin&lt;/code&gt; 에 있어야합니다 &lt;code&gt;PATH&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6c04a10b1920f4a1282bcbfa24f33118ae0f4ab4" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;PE_FrameButtonTool&lt;/code&gt; and &lt;code&gt;PE_IndicatorArrowDown&lt;/code&gt; are included in the tree as the Java style draws them, but they can safely be omitted if you prefer it. The structure may also be different. &lt;a href=&quot;qcommonstyle&quot;&gt;QCommonStyle&lt;/a&gt;, for instance, draws both &lt;code&gt;PE_IndicatorButtonDropDown&lt;/code&gt; and &lt;code&gt;PE_IndicatorArrowDown&lt;/code&gt; in &lt;code&gt;CE_ToolButton&lt;/code&gt;.</source>
          <target state="translated">참고 &lt;code&gt;PE_FrameButtonTool&lt;/code&gt; 및 &lt;code&gt;PE_IndicatorArrowDown&lt;/code&gt; 는 자바 스타일을 그립니다 트리에 포함되어 있지만, 당신이 그것을 원하는 경우 그들이 안전하게 생략 할 수 있습니다. 구조도 다를 수 있습니다. &lt;a href=&quot;qcommonstyle&quot;&gt;QCommonStyle는&lt;/a&gt; , 예를 들어, 모두 그립니다 &lt;code&gt;PE_IndicatorButtonDropDown&lt;/code&gt; 및 &lt;code&gt;PE_IndicatorArrowDown&lt;/code&gt; 을 에 &lt;code&gt;CE_ToolButton&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="35ae86ee6466e131b71f30dd2f5eb239b213a6d0" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;WalltimeNanoseconds&lt;/code&gt; and &lt;code&gt;BytesAllocated&lt;/code&gt; are only provided for use via &lt;a href=&quot;qtest#setBenchmarkResult&quot;&gt;setBenchmarkResult&lt;/a&gt;(), and results in those metrics are not able to be provided automatically by the &lt;a href=&quot;qtest&quot;&gt;QTest&lt;/a&gt; framework.</source>
          <target state="translated">참고 &lt;code&gt;WalltimeNanoseconds&lt;/code&gt; 및 &lt;code&gt;BytesAllocated&lt;/code&gt; 이 단지를 통해 사용하기 위해 제공되는 &lt;a href=&quot;qtest#setBenchmarkResult&quot;&gt;setBenchmarkResult&lt;/a&gt; (), 그 측정 결과가 자동으로 제공 될 수 없습니다&lt;a href=&quot;qtest&quot;&gt; QTEST&lt;/a&gt; 프레임 워크.</target>
        </trans-unit>
        <trans-unit id="4a82b50510c508687b53c6253a664f503012e37e" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;X&lt;/code&gt; must have the same cv-qualifiers (&lt;code&gt;const&lt;/code&gt; and &lt;code&gt;volatile&lt;/code&gt;) that &lt;code&gt;T&lt;/code&gt; has, or the code will fail to compile. Use &lt;a href=&quot;qsharedpointer#qSharedPointerConstCast&quot;&gt;qSharedPointerConstCast&lt;/a&gt; to cast away the constness.</source>
          <target state="translated">참고 &lt;code&gt;X&lt;/code&gt; 는 같은 이력서 - 예선 (가 있어야 &lt;code&gt;const&lt;/code&gt; 및 &lt;code&gt;volatile&lt;/code&gt; 것을) &lt;code&gt;T&lt;/code&gt; 가 있다, 또는 코드가 컴파일에 실패합니다. 사용하다&lt;a href=&quot;qsharedpointer#qSharedPointerConstCast&quot;&gt;qSharedPointerConstCast&lt;/a&gt; 를 constness 를 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="a0851ce87e24b9d912135926ad4cb459371064e3" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;clip&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; by default which means that the item might paint outside its bounding rectangle even if the fillMode is set to &lt;code&gt;PreserveAspectCrop&lt;/code&gt;.</source>
          <target state="translated">하는 것으로 &lt;code&gt;clip&lt;/code&gt; 입니다 &lt;code&gt;false&lt;/code&gt; 기본적으로 어떤 항목이 FILLMODE로 설정되는 경우에도 외부의 경계 사각형을 그릴 수 있음을 의미합니다 &lt;code&gt;PreserveAspectCrop&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="e176023dba0b41547930d1b84d688d1932d3b56f" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;display()&lt;/code&gt; is overloaded; Qt will select the appropriate version when you connect a signal to the slot. With callbacks, you'd have to find five different names and keep track of the types yourself.</source>
          <target state="translated">참고 &lt;code&gt;display()&lt;/code&gt; 가 오버로드됨에 . Qt는 신호를 슬롯에 연결할 때 적절한 버전을 선택합니다. 콜백을 사용하면 5 개의 다른 이름을 찾아서 직접 유형을 추적해야합니다.</target>
        </trans-unit>
        <trans-unit id="50cdf05965bfbcde32786c0bec9f1b8dabfa4034" translate="yes" xml:space="preserve">
          <source>Note that Attractor has the standard Item x,y,width and height properties. Like other affectors, these represent the affected area. They do not represent the 0x0 point which is the target of the attraction.</source>
          <target state="translated">Attractor에는 표준 Item x, y, width 및 height 속성이 있습니다. 다른 영향 요인과 마찬가지로 영향을받는 영역을 나타냅니다. 그들은 매력의 대상인 0x0 지점을 나타내지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d6ba0bc586df480f92f39a4e094bf9eae63c757d" translate="yes" xml:space="preserve">
          <source>Note that CBOR maps are unordered, which means that two maps containing the very same pairs but in different order will still compare differently. To avoid this, it is recommended to insert elements into the map in a predictable order, such as by ascending key value. In fact, maps with keys in sorted order are required for Canonical CBOR representation.</source>
          <target state="translated">CBOR 맵은 순서가 정렬되지 않았으므로 매우 동일한 쌍을 포함하지만 순서가 다른 두 맵은 여전히 ​​다르게 비교됩니다. 이를 피하려면 오름차순 키 값과 같이 예측 가능한 순서로 요소를 맵에 삽입하는 것이 좋습니다. 실제로, 정식 CBOR 표시에는 키가 정렬 된 맵이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="24c53f9788fb2700b09fb9edd4dc6433cc60b806" translate="yes" xml:space="preserve">
          <source>Note that IPv6 unique local unicast addresses are considered global addresses (see &lt;a href=&quot;qhostaddress#isUniqueLocalUnicast&quot;&gt;isUniqueLocalUnicast&lt;/a&gt;()), as are IPv4 addresses reserved for local networks by &lt;a href=&quot;https://tools.ietf.org/html/rfc1918&quot;&gt;RFC 1918&lt;/a&gt;.</source>
          <target state="translated">IPv6 고유 로컬 유니 캐스트 주소는 로컬 주소로 예약 된 IPv4 주소와 마찬가지로 전역 주소로 간주됩니다 ( &lt;a href=&quot;qhostaddress#isUniqueLocalUnicast&quot;&gt;isUniqueLocalUnicast&lt;/a&gt; () 참조 ).&lt;a href=&quot;https://tools.ietf.org/html/rfc1918&quot;&gt; RFC 1918에&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="38e413f39be2ca90e211925257d46b26f122d5bc" translate="yes" xml:space="preserve">
          <source>Note that InterBase requires you to specify the full path to the database file, no matter whether it is stored locally or on another server.</source>
          <target state="translated">InterBase에서는 데이터베이스 파일이 로컬로 저장되어 있는지 또는 다른 서버에 저장되어 있는지에 관계없이 데이터베이스 파일의 전체 경로를 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="5ebe4ee7293ae9a7b4e5c26a141696ffd1d51f72" translate="yes" xml:space="preserve">
          <source>Note that JavaScript is slower to execute, so it is not recommended to use this in high-volume particle systems.</source>
          <target state="translated">JavaScript는 실행 속도가 느리므로 대량 파티클 시스템에서는 사용하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="28f0e5a005061656c49f4b3dd754d8f6bf748b49" translate="yes" xml:space="preserve">
          <source>Note that LightLevel constants are exposed through the &lt;a href=&quot;qml-qtsensors-ambientlightreading&quot;&gt;AmbientLightReading&lt;/a&gt; class.</source>
          <target state="translated">LightLevel 상수는 &lt;a href=&quot;qml-qtsensors-ambientlightreading&quot;&gt;AmbientLightReading&lt;/a&gt; 클래스를 통해 노출됩니다 .</target>
        </trans-unit>
        <trans-unit id="944bb498c75fa41b9be05ccc4984febb7fd6afca" translate="yes" xml:space="preserve">
          <source>Note that Mac flavors must all be self-terminating. The input</source>
          <target state="translated">Mac 플레이버는 모두 자동 종료되어야합니다. 입력</target>
        </trans-unit>
        <trans-unit id="d4d3bf9d2e87d0a555824f6713467240ac6ccd79" translate="yes" xml:space="preserve">
          <source>Note that Mac flavors must all be self-terminating. The return value may contain trailing data.</source>
          <target state="translated">Mac 플레이버는 모두 자동 종료되어야합니다. 반환 값은 후행 데이터를 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ed44264030a6c5caacd07abdd8eeb798a1da0dd" translate="yes" xml:space="preserve">
          <source>Note that OpenGL does not permit nesting or interleaving of multiple timer queries using &lt;a href=&quot;qopengltimerquery#begin&quot;&gt;begin&lt;/a&gt;() and &lt;a href=&quot;qopengltimerquery#end&quot;&gt;end&lt;/a&gt;(). Using multiple timer queries and &lt;a href=&quot;qopengltimerquery#recordTimestamp&quot;&gt;recordTimestamp&lt;/a&gt;() avoids this limitation. When using &lt;a href=&quot;qopengltimerquery#recordTimestamp&quot;&gt;recordTimestamp&lt;/a&gt;() the result can be obtained at some later time using &lt;a href=&quot;qopengltimerquery#isResultAvailable&quot;&gt;isResultAvailable&lt;/a&gt;() and &lt;a href=&quot;qopengltimerquery#waitForResult&quot;&gt;waitForResult&lt;/a&gt;(). Qt provides the convenience class &lt;a href=&quot;qopengltimemonitor&quot;&gt;QOpenGLTimeMonitor&lt;/a&gt; that helps with using multiple query objects.</source>
          <target state="translated">OpenGL은 &lt;a href=&quot;qopengltimerquery#begin&quot;&gt;begin&lt;/a&gt; () 및 &lt;a href=&quot;qopengltimerquery#end&quot;&gt;end&lt;/a&gt; ()를 사용하여 여러 타이머 쿼리의 중첩 또는 인터리빙을 허용하지 않습니다 . 여러 타이머 쿼리와 &lt;a href=&quot;qopengltimerquery#recordTimestamp&quot;&gt;recordTimestamp&lt;/a&gt; ()를 사용하면이 제한이 방지됩니다. &lt;a href=&quot;qopengltimerquery#recordTimestamp&quot;&gt;recordTimestamp&lt;/a&gt; ()를 사용할 때 &lt;a href=&quot;qopengltimerquery#isResultAvailable&quot;&gt;isResultAvailable&lt;/a&gt; () 및 &lt;a href=&quot;qopengltimerquery#waitForResult&quot;&gt;waitForResult&lt;/a&gt; ()를 사용하여 나중에 결과를 얻을 수 있습니다 . Qt는 여러 쿼리 개체를 사용하는 데 도움이 되는 편리한 클래스 &lt;a href=&quot;qopengltimemonitor&quot;&gt;QOpenGLTimeMonitor&lt;/a&gt; 를 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="2bf1775b46a575bb867c5a4e97c6baf40986363c" translate="yes" xml:space="preserve">
          <source>Note that OpenGL implementations have a vendor-specific limit to the length of the messages that can be inserted in the debug log. You can retrieve this length by calling the &lt;a href=&quot;qopengldebuglogger#maximumMessageLength&quot;&gt;maximumMessageLength&lt;/a&gt;() method; messages longer than the limit will automatically get truncated.</source>
          <target state="translated">OpenGL 구현에는 디버그 로그에 삽입 할 수있는 메시지 길이에 대한 공급 업체별 제한이 있습니다. &lt;a href=&quot;qopengldebuglogger#maximumMessageLength&quot;&gt;maximumMessageLength&lt;/a&gt; 를 호출하여이 길이를 검색 할 수 있습니다. () 메소드를 . 한도보다 긴 메시지는 자동으로 잘립니다.</target>
        </trans-unit>
        <trans-unit id="8aa39909c5b7e998a2d783eb3efed1ac10b1bcbb" translate="yes" xml:space="preserve">
          <source>Note that Orientation constants are exposed through the &lt;a href=&quot;qml-qtsensors-orientationreading&quot;&gt;OrientationReading&lt;/a&gt; class.</source>
          <target state="translated">오리엔테이션 상수는 &lt;a href=&quot;qml-qtsensors-orientationreading&quot;&gt;OrientationReading&lt;/a&gt; 클래스를 통해 노출됩니다 .</target>
        </trans-unit>
        <trans-unit id="22f51f71cb417a6621bb8b37ff844c5e29ed92d7" translate="yes" xml:space="preserve">
          <source>Note that QML makes the following modifications to native objects:</source>
          <target state="translated">QML은 기본 객체를 다음과 같이 수정합니다.</target>
        </trans-unit>
        <trans-unit id="94ec8a387d5af3e6a7f83ce83475eed7cc355a03" translate="yes" xml:space="preserve">
          <source>Note that QPixmaps are automatically added to the &lt;a href=&quot;qpixmapcache&quot;&gt;QPixmapCache&lt;/a&gt; when loaded from a file in main thread; the key used is internal and cannot be acquired.</source>
          <target state="translated">QPixmaps가 자동으로 추가됩니다 참고 &lt;a href=&quot;qpixmapcache&quot;&gt;QPixmapCache&lt;/a&gt; 메인 쓰레드에서 파일에서로드; 사용 된 키는 내부 용이며 취득 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e363844033d14815da9138531ee9c9f810bfff15" translate="yes" xml:space="preserve">
          <source>Note that Qt 5 introduces a slight change in behavior when using &lt;a href=&quot;qpointer&quot;&gt;QPointer&lt;/a&gt;.</source>
          <target state="translated">Qt 5는 &lt;a href=&quot;qpointer&quot;&gt;QPointer를&lt;/a&gt; 사용할 때 약간의 동작 변화를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="7f7c75b4500d4fdeee658a1d4c1ee551d95e74b1" translate="yes" xml:space="preserve">
          <source>Note that Qt destroys a plugin automatically when it is no longer used, so there is no need for calling the destructor explicitly.</source>
          <target state="translated">Qt는 더 이상 사용하지 않으면 자동으로 플러그인을 제거하므로 소멸자를 명시 적으로 호출 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="6619b661dacad31641d75c928a1bcc6062c24c49" translate="yes" xml:space="preserve">
          <source>Note that Remote Objects behave differently from traditional Remote Procedure Call (RPC) implementations, for example:</source>
          <target state="translated">원격 객체는 다음과 같은 기존 RPC (원격 프로 시저 호출) 구현과 다르게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="9095bdc1a55db23a29dd7cac21a0063648039f5b" translate="yes" xml:space="preserve">
          <source>Note that TapDirection constants are exposed through the &lt;a href=&quot;qml-qtsensors-tapreading&quot;&gt;TapReading&lt;/a&gt; class.</source>
          <target state="translated">TapDirection 상수는 &lt;a href=&quot;qml-qtsensors-tapreading&quot;&gt;TapReading&lt;/a&gt; 클래스를 통해 노출됩니다 .</target>
        </trans-unit>
        <trans-unit id="43e7efd6a053f711419f8700bdde9332fda54aef" translate="yes" xml:space="preserve">
          <source>Note that TolerantMode is not usually enough for parsing user input, which often contains more errors and expectations than the parser can deal with. When dealing with data coming directly from the user -- as opposed to data coming from data-transfer sources, such as other programs -- it is recommended to use &lt;a href=&quot;qurl#fromUserInput&quot;&gt;fromUserInput&lt;/a&gt;().</source>
          <target state="translated">TolerantMode는 일반적으로 사용자 입력을 구문 분석하기에 충분하지 않으며, 종종 구문 분석기가 처리 할 수있는 것보다 더 많은 오류와 기대치를 포함합니다. 다른 프로그램과 같은 데이터 전송 소스에서 오는 데이터와 달리 사용자가 직접 가져 오는 데이터를 처리 할 때는 &lt;a href=&quot;qurl#fromUserInput&quot;&gt;fromUserInput&lt;/a&gt; () 을 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="711c6627a8bc56274b1474eb1cf1a438551ac1ee" translate="yes" xml:space="preserve">
          <source>Note that Unique local unicast addresses count as global addresses too. RFC 4193 says that, in practice, &quot;applications may treat these addresses like global scoped addresses.&quot; Only routers need care about the distinction.</source>
          <target state="translated">고유 한 로컬 유니 캐스트 주소도 전역 주소로 계산됩니다. RFC 4193은 실제로 &quot;응용 프로그램은 이러한 주소를 전역 범위 주소처럼 취급 할 수 있습니다&quot;라고 말합니다. 라우터 만이 구별에주의를 기울여야합니다.</target>
        </trans-unit>
        <trans-unit id="2357db77093b1cf01f9677aaaaab3656dcbc3a45" translate="yes" xml:space="preserve">
          <source>Note that VerticalSortHint and HorizontalSortHint carry the meaning that items are being moved within the same parent, not moved to a different parent in the model, and not filtered out or in.</source>
          <target state="translated">VerticalSortHint 및 HorizontalSortHint는 항목이 동일한 상위 내에서 이동되고 모델의 다른 상위로 이동되지 않으며 필터링되거나 필터링되지 않음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="10a747acc5e6513f31b235b7daa7ebf4a8499512" translate="yes" xml:space="preserve">
          <source>Note that You must add the layout of</source>
          <target state="translated">레이아웃을 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="30caf1f81652b6b1880f503033405b98f421e0e7" translate="yes" xml:space="preserve">
          <source>Note that a &lt;a href=&quot;qcoreapplication&quot;&gt;QCoreApplication&lt;/a&gt; object must be instantiated before using any of these classes.</source>
          <target state="translated">&amp;bull; 그래도 참고 &lt;a href=&quot;qcoreapplication&quot;&gt;QCoreApplication의&lt;/a&gt; 목적은 이러한 클래스 중 하나를 사용하기 전에 인스턴스화해야합니다.</target>
        </trans-unit>
        <trans-unit id="6a8a30295003de80bc20eb6dee1199ef6dbd4937" translate="yes" xml:space="preserve">
          <source>Note that a &lt;a href=&quot;qguiapplication&quot;&gt;QGuiApplication&lt;/a&gt; instance must exist before a &lt;a href=&quot;qfont&quot;&gt;QFont&lt;/a&gt; can be used. You can set the application's default font with &lt;a href=&quot;qguiapplication#setFont&quot;&gt;QGuiApplication::setFont&lt;/a&gt;().</source>
          <target state="translated">&amp;bull; 그래도 참고 &lt;a href=&quot;qguiapplication&quot;&gt;QGuiApplication의&lt;/a&gt; 전 (before) 인스턴스가 존재해야합니다 &lt;a href=&quot;qfont&quot;&gt;QFont가&lt;/a&gt; 사용할 수 있습니다. &lt;a href=&quot;qguiapplication#setFont&quot;&gt;QGuiApplication :: setFont&lt;/a&gt; ()를 사용하여 응용 프로그램의 기본 글꼴을 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="16b5d5f0d7184c93e062430936a86c5b4fa90eb5" translate="yes" xml:space="preserve">
          <source>Note that a &lt;a href=&quot;qjsvalue&quot;&gt;QJSValue&lt;/a&gt; for which &lt;a href=&quot;qjsvalue#isObject&quot;&gt;isObject&lt;/a&gt;() is true only carries a reference to an actual object; copying the &lt;a href=&quot;qjsvalue&quot;&gt;QJSValue&lt;/a&gt; will only copy the object reference, not the object itself. If you want to clone an object (i.e. copy an object's properties to another object), you can do so with the help of a &lt;code&gt;for-in&lt;/code&gt; statement in script code, or &lt;a href=&quot;qjsvalueiterator&quot;&gt;QJSValueIterator&lt;/a&gt; in C++.</source>
          <target state="translated">유의 &lt;a href=&quot;qjsvalue&quot;&gt;QJSValue&lt;/a&gt; 하는 &lt;a href=&quot;qjsvalue#isObject&quot;&gt;isObject는&lt;/a&gt; ()에 해당하는 경우에만 실제 객체에 대한 참조를 전달; 복사 &lt;a href=&quot;qjsvalue&quot;&gt;QJSValue 것은&lt;/a&gt; 단지 객체 참조가 아닌 객체 자체를 복사합니다. 오브젝트를 복제하려는 경우 (예 : 오브젝트의 특성을 다른 오브젝트에 복사) 스크립트 코드 의 &lt;code&gt;for-in&lt;/code&gt; 문 또는 &lt;a href=&quot;qjsvalueiterator&quot;&gt;QJSValueIterator를 사용하여이를 복제 할 수 있습니다.&lt;/a&gt; C ++의 를 .</target>
        </trans-unit>
        <trans-unit id="86addfca96d6e8599e241d136a2c78f5318415f9" translate="yes" xml:space="preserve">
          <source>Note that a &lt;a href=&quot;qml-qtlocation-placesearchmodel&quot;&gt;PlaceSearchModel&lt;/a&gt; will call &lt;a href=&quot;qml-qtlocation-place#getDetails-method&quot;&gt;Place::getDetails&lt;/a&gt; on any place that it detects an update on. A consequence of this is that whenever a Place from a &lt;a href=&quot;qml-qtlocation-placesearchmodel&quot;&gt;PlaceSearchModel&lt;/a&gt; is successfully saved, it will be followed by a fetch of place details, leading to a sequence of state changes of &lt;code&gt;Saving&lt;/code&gt;, &lt;code&gt;Ready&lt;/code&gt;, &lt;code&gt;Fetching&lt;/code&gt;, &lt;code&gt;Ready&lt;/code&gt;.</source>
          <target state="translated">참고는 것을 &lt;a href=&quot;qml-qtlocation-placesearchmodel&quot;&gt;PlaceSearchModel가&lt;/a&gt; 호출 &lt;a href=&quot;qml-qtlocation-place#getDetails-method&quot;&gt;장소 : getDetails를&lt;/a&gt; 이에 대한 업데이 트를 감지 한 장소에. 그 결과 &lt;a href=&quot;qml-qtlocation-placesearchmodel&quot;&gt;PlaceSearchModel&lt;/a&gt; 의 작업 공간 이 성공적으로 저장 될 때마다 작업 공간 세부 사항 페치가 이어지고 &lt;code&gt;Saving&lt;/code&gt; , &lt;code&gt;Ready&lt;/code&gt; , &lt;code&gt;Fetching&lt;/code&gt; , &lt;code&gt;Ready&lt;/code&gt; 중 상태가 순차적으로 변경 됩니다.</target>
        </trans-unit>
        <trans-unit id="503bbcd690e9d977d896f91d8e5d14f7d6af9af3" translate="yes" xml:space="preserve">
          <source>Note that a &lt;a href=&quot;qwebchannel&quot;&gt;QWebChannel&lt;/a&gt; is only fully operational once you connect it to a &lt;a href=&quot;qwebchannelabstracttransport&quot;&gt;QWebChannelAbstractTransport&lt;/a&gt;. The HTML clients also need to be setup appropriately using &lt;a href=&quot;qtwebchannel-javascript#&quot;&gt;&lt;code&gt;qwebchannel.js&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&amp;bull; 그래도 참고 &lt;a href=&quot;qwebchannel&quot;&gt;QWebChannel은&lt;/a&gt; 당신이에 연결 한 번만 완전히 작동 &lt;a href=&quot;qwebchannelabstracttransport&quot;&gt;QWebChannelAbstractTransport&lt;/a&gt; . HTML 클라이언트는 &lt;a href=&quot;qtwebchannel-javascript#&quot;&gt; &lt;code&gt;qwebchannel.js&lt;/code&gt; 를&lt;/a&gt; 사용하여 적절하게 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="0f361c945386e67e1853cdea5eed385b27efa122" translate="yes" xml:space="preserve">
          <source>Note that a &lt;a href=&quot;qxmlnamepool&quot;&gt;name pool&lt;/a&gt; is</source>
          <target state="translated">&amp;bull; 그래도 참고 &lt;a href=&quot;qxmlnamepool&quot;&gt;이름 풀이&lt;/a&gt; 입니다</target>
        </trans-unit>
        <trans-unit id="02637b0cd08e75d9af4e6bcfc682c63a7bb3a869" translate="yes" xml:space="preserve">
          <source>Note that a cursor always moves when text is inserted before the current position of the cursor, and it always keeps its position when text is inserted after the current position of the cursor.</source>
          <target state="translated">커서가 현재 커서 위치 앞에 텍스트가 삽입되면 커서가 항상 이동하고 커서가 현재 커서 위치 뒤에 텍스트가 삽입 될 때 항상 위치를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="6f76131721fa5c25db41f016753541beabf40984" translate="yes" xml:space="preserve">
          <source>Note that a moved-from &lt;a href=&quot;qcollator&quot;&gt;QCollator&lt;/a&gt; can only be destroyed or assigned to. The effect of calling other functions than the destructor or one of the assignment operators is undefined.</source>
          <target state="translated">이동 한 &lt;a href=&quot;qcollator&quot;&gt;QCollator&lt;/a&gt; 는 파기 또는 할당 만 할 수 있습니다. 소멸자 또는 대입 연산자 중 하나 이외의 다른 함수를 호출하는 효과는 정의되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9aac276e0a336240da5324f9483b107de4eddb1c" translate="yes" xml:space="preserve">
          <source>Note that a property cannot have more than one assigned Behavior. To provide multiple animations within a Behavior, use &lt;a href=&quot;qml-qtquick-parallelanimation&quot;&gt;ParallelAnimation&lt;/a&gt; or &lt;a href=&quot;qml-qtquick-sequentialanimation&quot;&gt;SequentialAnimation&lt;/a&gt;.</source>
          <target state="translated">속성에는 둘 이상의 할당 된 동작이있을 수 없습니다. 비헤이비어 내에 여러 애니메이션을 제공하려면 &lt;a href=&quot;qml-qtquick-parallelanimation&quot;&gt;ParallelAnimation&lt;/a&gt; 또는 &lt;a href=&quot;qml-qtquick-sequentialanimation&quot;&gt;SequentialAnimation을 사용하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="70eba09345475938858eb55399c27d94c435c59f" translate="yes" xml:space="preserve">
          <source>Note that a single &lt;a href=&quot;qml-qtquick-patharc&quot;&gt;PathArc&lt;/a&gt; cannot be used to specify a circle. Instead, you can use two &lt;a href=&quot;qml-qtquick-patharc&quot;&gt;PathArc&lt;/a&gt; elements, each specifying half of the circle.</source>
          <target state="translated">단일 &lt;a href=&quot;qml-qtquick-patharc&quot;&gt;PathArc&lt;/a&gt; 를 사용하여 원을 지정할 수 없습니다. 대신 각각 원의 절반을 지정 하는 두 개의 &lt;a href=&quot;qml-qtquick-patharc&quot;&gt;PathArc&lt;/a&gt; 요소를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5451eec835716891135e1dd10a6611eabb1a2b1e" translate="yes" xml:space="preserve">
          <source>Note that a window that is mapped to screen may still not be considered exposed if the window client area is completely covered by other windows, or if the window is otherwise not visible. This function will then time out when waiting for such a window.</source>
          <target state="translated">창 클라이언트 영역이 다른 창으로 완전히 덮여 있거나 창이 표시되지 않으면 화면에 매핑 된 창은 여전히 ​​노출 된 것으로 간주되지 않을 수 있습니다. 그런 다음이 창을 기다릴 때이 기능이 시간 초과됩니다.</target>
        </trans-unit>
        <trans-unit id="4c10711923ea12fa526d7cf2de9c4b286a7d51ed" translate="yes" xml:space="preserve">
          <source>Note that abbreviations may or may not be localized.</source>
          <target state="translated">약어는 현지화되거나 현지화되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5690be84d5b05770ff50486372be58d00e661165" translate="yes" xml:space="preserve">
          <source>Note that accepting the terms and conditions only applies those terms and conditions to the use of the HERE geo services plugin and does not limit the use of the other geo services plugins that may be included with Qt.</source>
          <target state="translated">이용 약관에 동의하면 해당 이용 약관은 HERE 지리 서비스 플러그인 사용에만 적용되며 Qt에 포함될 수있는 다른 지리 서비스 플러그인의 사용을 제한하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="438ae93e5434a3f3950b7259b62d264aa0402587" translate="yes" xml:space="preserve">
          <source>Note that all &lt;a href=&quot;qmimetype&quot;&gt;QMimeType&lt;/a&gt; instances refer to proper mimetypes, never to aliases directly.</source>
          <target state="translated">모든 &lt;a href=&quot;qmimetype&quot;&gt;QMimeType&lt;/a&gt; 인스턴스는 적절한 MIME 유형을 참조하며 직접 별명을 참조하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="1f3b0a52a328b2953b0765a0f48679098ff227c4" translate="yes" xml:space="preserve">
          <source>Note that all C++ types registered with the QML type system must be &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;-derived, even if they are non-instantiable.</source>
          <target state="translated">QML 유형 시스템에 등록 된 모든 C ++ 유형 은 인스턴스화 할 수없는 경우에도 &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 파생 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="050a7c7b96bddc3d6fb4f47173e48159713d6d47" translate="yes" xml:space="preserve">
          <source>Note that all active timers for the object will be reset. The timers are first stopped in the current thread and restarted (with the same interval) in the</source>
          <target state="translated">객체에 대한 모든 활성 타이머가 재설정됩니다. 타이머는 현재 스레드에서 먼저 중지 된 후 타이머에서 동일한 간격으로 다시 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="5754636c97a664ccc7e9d1341a009eb89beabfc1" translate="yes" xml:space="preserve">
          <source>Note that all effects are disabled on screens running at less than 16-bit color depth.</source>
          <target state="translated">16 비트 미만의 색 심도에서 실행되는 화면에서는 모든 효과가 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="ea977213302a8f0ed6f41631194ed6daac550753" translate="yes" xml:space="preserve">
          <source>Note that all formats may not be supported. The exact set of supported formats is dependent upon your OpenGL implementation and version.</source>
          <target state="translated">모든 형식이 지원되지 않을 수 있습니다. 지원되는 형식의 정확한 세트는 OpenGL 구현 및 버전에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="ff6a1db020ba1cf01fb635fddf116d3d4e4ea617" translate="yes" xml:space="preserve">
          <source>Note that all of the Qt associative containers already have built-in support, and it is not necessary to use this macro with them. The std::map container also has built-in support.</source>
          <target state="translated">모든 Qt 연관 컨테이너는 이미 지원 기능이 내장되어 있으므로이 매크로를 컨테이너와 함께 사용할 필요는 없습니다. std :: map 컨테이너도 내장 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="24d9874c65cee435e603256ae2fcc3121b49d711" translate="yes" xml:space="preserve">
          <source>Note that all of the Qt sequential containers already have built-in support, and it is not necessary to use this macro with them. The std::vector and std::list containers also have built-in support.</source>
          <target state="translated">모든 Qt 순차 컨테이너는 이미 기본 제공 지원을 가지고 있으므로이 매크로를 컨테이너와 함께 사용할 필요는 없습니다. std :: vector 및 std :: list 컨테이너도 기본적으로 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="4b12375ab6b3e35c3f931a1c5ca6b66a8ce4656c" translate="yes" xml:space="preserve">
          <source>Note that all signals are emitted as usual. If you connect a &lt;a href=&quot;qaction&quot;&gt;QAction&lt;/a&gt; to a slot and call the menu's &lt;a href=&quot;qmenu#exec&quot;&gt;exec&lt;/a&gt;(), you get the result both via the signal-slot connection and in the return value of &lt;a href=&quot;qmenu#exec&quot;&gt;exec&lt;/a&gt;().</source>
          <target state="translated">모든 신호는 평소대로 방출됩니다. &lt;a href=&quot;qaction&quot;&gt;QAction&lt;/a&gt; 을 슬롯에 연결 하고 메뉴의 &lt;a href=&quot;qmenu#exec&quot;&gt;exec&lt;/a&gt; ()를 호출 하면 신호 슬롯 연결과 &lt;a href=&quot;qmenu#exec&quot;&gt;exec&lt;/a&gt; () 의 반환 값을 통해 결과를 얻습니다 .</target>
        </trans-unit>
        <trans-unit id="d542bf4f149ca0c53a59c4db2645120c7e71fa46" translate="yes" xml:space="preserve">
          <source>Note that all signals declared will be exported to the &lt;a href=&quot;qsensorgesture&quot;&gt;QSensorGesture&lt;/a&gt; object. If you need to use signals that are not exported, you should use a private class to do so.</source>
          <target state="translated">선언 된 모든 신호는 &lt;a href=&quot;qsensorgesture&quot;&gt;QSensorGesture&lt;/a&gt; 객체 로 내보내집니다 . 내 보내지 않은 신호를 사용해야하는 경우 개인 클래스를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="2f484d7c33046bb3903e38e027f0bf33e243912b" translate="yes" xml:space="preserve">
          <source>Note that all this is different from what you get in other JavaScript implementations which usually treat year 0 as valid in all string representations. As the date formats are &quot;implementation-dependent&quot; in the ECMAScript standard, this is still valid, though.</source>
          <target state="translated">이 모든 것은 일반적으로 0 년을 모든 문자열 표현에서 유효한 것으로 취급하는 다른 JavaScript 구현에서 얻는 것과 다릅니다. ECMAScript 표준에서 날짜 형식은 &quot;구현에 따라&quot;다르지만 여전히 유효합니다.</target>
        </trans-unit>
        <trans-unit id="1a6a5df26b499205ee6debbf2e1b4bed31eb6c0c" translate="yes" xml:space="preserve">
          <source>Note that an empty &lt;a href=&quot;qfileinfo&quot;&gt;QFileInfo&lt;/a&gt; object contain no file reference.</source>
          <target state="translated">빈 &lt;a href=&quot;qfileinfo&quot;&gt;QFileInfo&lt;/a&gt; 객체에는 파일 참조가 없습니다.</target>
        </trans-unit>
        <trans-unit id="553f1705d00f84aadbf3ccdc4a03163b3a8ce441" translate="yes" xml:space="preserve">
          <source>Note that an extra variable, index, will be available inside instances of the delegate. This variable refers to the index of the instance inside the Instantiator, and can be used to obtain the object through the &lt;a href=&quot;qml-qtqml-instantiator#objectAt-method&quot;&gt;objectAt&lt;/a&gt; method of the Instantiator.</source>
          <target state="translated">델리게이트 인스턴스 내에서 추가 변수 인 인덱스를 사용할 수 있습니다. 이 변수는 Instantiator 내부의 인스턴스 색인을 나타내며 Instantiator의 &lt;a href=&quot;qml-qtqml-instantiator#objectAt-method&quot;&gt;objectAt&lt;/a&gt; 메소드를 통해 객체를 얻는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b98003e5d7ec2ec30b0f0c4184a9224d537f52ad" translate="yes" xml:space="preserve">
          <source>Note that an extra variable, index, will be available inside instances of the delegate. This variable refers to the index of the instance inside the Instantiator, and can be used to obtain the object through the itemAt method of the Instantiator.</source>
          <target state="translated">델리게이트 인스턴스 내에서 추가 변수 인 인덱스를 사용할 수 있습니다. 이 변수는 Instantiator 내부의 인스턴스 색인을 나타내며 Instantiator의 itemAt 메소드를 통해 객체를 얻는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aeb4340ebaf439e5901a02b2a8650d0f6a833837" translate="yes" xml:space="preserve">
          <source>Note that an item will not receive double click events if it is neither &lt;a href=&quot;qgraphicsitem#GraphicsItemFlag-enum&quot;&gt;selectable&lt;/a&gt; nor &lt;a href=&quot;qgraphicsitem#GraphicsItemFlag-enum&quot;&gt;movable&lt;/a&gt; (single mouse clicks are ignored in this case, and that stops the generation of double clicks).</source>
          <target state="translated">항목을 &lt;a href=&quot;qgraphicsitem#GraphicsItemFlag-enum&quot;&gt;선택&lt;/a&gt; 하거나 &lt;a href=&quot;qgraphicsitem#GraphicsItemFlag-enum&quot;&gt;이동할 &lt;/a&gt;수 없는 경우 항목이 두 번 클릭 이벤트를 수신하지 않습니다 (이 경우 단일 마우스 클릭은 무시되고 두 번 클릭 생성이 중지됨).</target>
        </trans-unit>
        <trans-unit id="fd4c9fdddbbab080b96cf76514d83baa9822437b" translate="yes" xml:space="preserve">
          <source>Note that an object may have multiple children with the same &lt;code&gt;objectName&lt;/code&gt;. For example, &lt;a href=&quot;qml-qtquick-listview&quot;&gt;ListView&lt;/a&gt; creates multiple instances of its delegate, so if its delegate is declared with a particular objectName, the &lt;a href=&quot;qml-qtquick-listview&quot;&gt;ListView&lt;/a&gt; will have multiple children with the same &lt;code&gt;objectName&lt;/code&gt;. In this case, &lt;a href=&quot;qobject#findChildren&quot;&gt;QObject::findChildren&lt;/a&gt;() can be used to find all children with a matching &lt;code&gt;objectName&lt;/code&gt;.</source>
          <target state="translated">객체에는 동일한 &lt;code&gt;objectName&lt;/code&gt; 을 가진 여러 개의 자식이있을 수 있습니다 . 예를 들어 &lt;a href=&quot;qml-qtquick-listview&quot;&gt;ListView&lt;/a&gt; 는 대리자의 여러 인스턴스를 생성하므로 대리자가 특정 objectName으로 선언되면 &lt;a href=&quot;qml-qtquick-listview&quot;&gt;ListView&lt;/a&gt; 는 동일한 &lt;code&gt;objectName&lt;/code&gt; 을 가진 여러 개의 자식을 갖게됩니다 . 이 경우 &lt;a href=&quot;qobject#findChildren&quot;&gt;QObject :: findChildren&lt;/a&gt; ()을 사용하여 &lt;code&gt;objectName&lt;/code&gt; 과 일치하는 모든 자식을 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8073ea7abf3da3fc1f1485943f8c1bd609cdf904" translate="yes" xml:space="preserve">
          <source>Note that animations explicitly set on transitions will take precedence over any default animation for the given property.</source>
          <target state="translated">전환에 명시 적으로 설정된 애니메이션은 해당 속성의 기본 애니메이션보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="4d69f18d6df8ed3446103479905b103d8d960c24" translate="yes" xml:space="preserve">
          <source>Note that any of the &lt;code&gt;id&lt;/code&gt; values defined in &lt;code&gt;SquareButton.qml&lt;/code&gt; are not accessible to &lt;code&gt;SquareButton&lt;/code&gt; objects, as id values are only accessible from within the component scope in which a component is declared. The &lt;code&gt;SquareButton&lt;/code&gt; object definition above cannot refer to &lt;code&gt;mouseArea&lt;/code&gt; in order to refer to the &lt;a href=&quot;qml-qtquick-mousearea&quot;&gt;MouseArea&lt;/a&gt; child, and if it had an &lt;code&gt;id&lt;/code&gt; of &lt;code&gt;root&lt;/code&gt; rather than &lt;code&gt;squareButton&lt;/code&gt;, this would not conflict with the &lt;code&gt;id&lt;/code&gt; of the same value for the root object defined in &lt;code&gt;SquareButton.qml&lt;/code&gt; as the two would be declared within separate scopes.</source>
          <target state="translated">의 모든 점에 유의 &lt;code&gt;id&lt;/code&gt; 정의 값 &lt;code&gt;SquareButton.qml&lt;/code&gt; 가 접근하지 &lt;code&gt;SquareButton&lt;/code&gt; ID 값은 구성 요소가 선언 된 성분 범위 내에서만 액세스 할 수있는 바와 같이, 물체. &lt;code&gt;SquareButton&lt;/code&gt; 객체 정의는 위를 참조 할 수 없습니다 &lt;code&gt;mouseArea&lt;/code&gt; 참고하여주십시오하기 위해 &lt;a href=&quot;qml-qtquick-mousearea&quot;&gt;MouseArea의&lt;/a&gt; 아이, 그리고 그것은이 있다면 &lt;code&gt;id&lt;/code&gt; 의 &lt;code&gt;root&lt;/code&gt; 보다는 &lt;code&gt;squareButton&lt;/code&gt; 는이 것없는 충돌 &lt;code&gt;id&lt;/code&gt; 에 정의 된 루트 객체에 대해 동일한 값의 &lt;code&gt;SquareButton.qml&lt;/code&gt; 두 가지가 별도의 범위 내에서 선언되기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="b4ebad99420c37a8c2b95d62660414abf3d6fede" translate="yes" xml:space="preserve">
          <source>Note that application layouts and animations that are defined using &lt;a href=&quot;qml-qtquick-item#x-prop&quot;&gt;x&lt;/a&gt; property values (as opposed to anchors or positioner types) are not affected by the &lt;a href=&quot;qml-qtquick-layoutmirroring&quot;&gt;LayoutMirroring&lt;/a&gt; attached property. Therefore, adding right-to-left support to these types of layouts may require some code changes to your application, especially in views that rely on both the anchors and x coordinate-based positioning. Here is one way to use the &lt;a href=&quot;qml-qtquick-layoutmirroring&quot;&gt;LayoutMirroring&lt;/a&gt; attached property to apply mirroring to an item that is positioned using &lt;a href=&quot;qml-qtquick-item#x-prop&quot;&gt;x&lt;/a&gt; coordinates:</source>
          <target state="translated">앵커 또는 포지셔너 유형과 달리 &lt;a href=&quot;qml-qtquick-item#x-prop&quot;&gt;x&lt;/a&gt; 속성 값을 사용하여 정의 된 응용 프로그램 레이아웃 및 애니메이션 은 &lt;a href=&quot;qml-qtquick-layoutmirroring&quot;&gt;LayoutMirroring&lt;/a&gt; 연결된 속성의 영향을받지 않습니다 . 따라서 이러한 유형의 레이아웃에 오른쪽에서 왼쪽으로의 지원을 추가하려면 특히 앵커와 x 좌표 기반 위치 지정에 의존하는 뷰에서 응용 프로그램에 대한 일부 코드 변경이 필요할 수 있습니다. 다음은 &lt;a href=&quot;qml-qtquick-layoutmirroring&quot;&gt;LayoutMirroring&lt;/a&gt; 연결된 속성을 사용하여 &lt;a href=&quot;qml-qtquick-item#x-prop&quot;&gt;x&lt;/a&gt; 좌표를 사용하여 배치 된 항목에 미러링을 적용 하는 한 가지 방법입니다 .</target>
        </trans-unit>
        <trans-unit id="8a5b303f666ffa9a20260867f8c7d09ef5370a76" translate="yes" xml:space="preserve">
          <source>Note that application/octet-stream is the ultimate parent for all types of files (but not directories).</source>
          <target state="translated">application / octet-stream은 모든 유형의 파일 (디렉토리 제외)의 최종 상위 항목입니다.</target>
        </trans-unit>
        <trans-unit id="d2468279dbc2cc1e7a0e182d9b08bf83dc261687" translate="yes" xml:space="preserve">
          <source>Note that applying &lt;a href=&quot;qbrush#setTexture&quot;&gt;setTexture&lt;/a&gt;() makes &lt;a href=&quot;qbrush#style&quot;&gt;style&lt;/a&gt;() == &lt;a href=&quot;qt#BrushStyle-enum&quot;&gt;Qt::TexturePattern&lt;/a&gt;, regardless of previous style settings. Also, calling &lt;a href=&quot;qbrush#setColor&quot;&gt;setColor&lt;/a&gt;() will not make a difference if the style is a gradient. The same is the case if the style is &lt;a href=&quot;qt#BrushStyle-enum&quot;&gt;Qt::TexturePattern&lt;/a&gt; style unless the current texture is a &lt;a href=&quot;qbitmap&quot;&gt;QBitmap&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qbrush#setTexture&quot;&gt;setTexture&lt;/a&gt; () 를 적용 하면 이전 스타일 설정에 관계없이 &lt;a href=&quot;qbrush#style&quot;&gt;style&lt;/a&gt; () == &lt;a href=&quot;qt#BrushStyle-enum&quot;&gt;Qt :: TexturePattern이&lt;/a&gt; 됩니다. 또한 스타일이 그라디언트 인 경우 &lt;a href=&quot;qbrush#setColor&quot;&gt;setColor&lt;/a&gt; ()를 호출 해도 차이가 없습니다. 현재 텍스처가 &lt;a href=&quot;qbitmap&quot;&gt;QBitmap&lt;/a&gt; 이 아닌 경우 스타일이 &lt;a href=&quot;qt#BrushStyle-enum&quot;&gt;Qt :: TexturePattern&lt;/a&gt; 스타일 인 경우에도 마찬가지 입니다.</target>
        </trans-unit>
        <trans-unit id="92c266e6ec839efc98e1887b023e21e41665d36f" translate="yes" xml:space="preserve">
          <source>Note that asking for a partial match can still lead to a complete match, if one is found; in this case, &lt;a href=&quot;qregularexpressionmatch#hasMatch&quot;&gt;hasMatch()&lt;/a&gt; will return &lt;code&gt;true&lt;/code&gt; and &lt;a href=&quot;qregularexpressionmatch#hasPartialMatch&quot;&gt;hasPartialMatch()&lt;/a&gt;&lt;code&gt;false&lt;/code&gt;. It never happens that a &lt;a href=&quot;qregularexpressionmatch&quot;&gt;QRegularExpressionMatch&lt;/a&gt; reports both a partial and a complete match.</source>
          <target state="translated">부분 일치를 요청하면 일치하는 경우 여전히 완전 일치로 이어질 수 있습니다. 이 경우 &lt;a href=&quot;qregularexpressionmatch#hasMatch&quot;&gt;hasMatch ()&lt;/a&gt; 는 &lt;code&gt;true&lt;/code&gt; 및 &lt;a href=&quot;qregularexpressionmatch#hasPartialMatch&quot;&gt;hasPartialMatch () &lt;/a&gt; &lt;code&gt;false&lt;/code&gt; 를 반환 합니다 . &lt;a href=&quot;qregularexpressionmatch&quot;&gt;QRegularExpressionMatch&lt;/a&gt; 가 부분 및 전체 일치를보고 하는 것은 결코 발생하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="de9873214397064878b74efe147f06e6da69a551" translate="yes" xml:space="preserve">
          <source>Note that attribute names are processed differently than element names: an unprefixed element name gets the default namespace (if any), while an unprefixed attribute name does not.</source>
          <target state="translated">속성 이름은 요소 이름과 다르게 처리됩니다. 접두사가없는 요소 이름은 기본 네임 스페이스 (있는 경우)를 가져오고 접두사가없는 속성 이름은 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="b85b7993606169f706161766359889c72df90bb2" translate="yes" xml:space="preserve">
          <source>Note that both keys and values are case sensitive.</source>
          <target state="translated">키와 값은 모두 대소 문자를 구분합니다.</target>
        </trans-unit>
        <trans-unit id="bb9553d45905abb81aa8a42aa3d067b35aaed56b" translate="yes" xml:space="preserve">
          <source>Note that both the QML engine and the JavaScript engine will automatically generate their own caches of type-data about observed types. Every component loaded by an application is a distinct (explicit) type, and every element (component instance) that defines its own custom properties in QML is an implicit type. Any element (instance of a component) that does not define any custom property is considered by the JavaScript and QML engines to be of the type explicitly defined by the component, rather than its own implicit type.</source>
          <target state="translated">QML 엔진과 JavaScript 엔진은 모두 관찰 된 유형에 대한 자체 유형 데이터 캐시를 자동으로 생성합니다. 응용 프로그램이로드 한 모든 구성 요소는 고유 한 (명시 적) 유형이며, QML에서 고유 한 사용자 정의 특성을 정의하는 모든 요소 (구성 요소 인스턴스)는 내재적 유형입니다. 사용자 정의 특성을 정의하지 않은 요소 (구성 요소의 인스턴스)는 JavaScript 및 QML 엔진에 의해 고유 한 암시 적 유형이 아니라 구성 요소가 명시 적으로 정의한 유형 인 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="f68c7700d4a779c84115d83ba195ba082d922f00" translate="yes" xml:space="preserve">
          <source>Note that buttons (such as &lt;a href=&quot;qpushbutton&quot;&gt;QPushButton&lt;/a&gt;) are often implemented not to care whether the press and release occur close together: if you press the button and then change your mind, you need to drag all the way off the edge of the button in order to cancel the click. For this use case, set the &lt;a href=&quot;qml-qtquick-taphandler#gesturePolicy-prop&quot;&gt;gesturePolicy&lt;/a&gt; to &lt;code&gt;TapHandler.ReleaseWithinBounds&lt;/code&gt;.</source>
          <target state="translated">버튼 (예 : &lt;a href=&quot;qpushbutton&quot;&gt;QPushButton&lt;/a&gt; )은 종종 눌림 과 눌림 이 서로 밀접하게 발생하는지 여부를 신경 쓰지 않기 위해 구현됩니다. 버튼을 눌렀다가 마음이 바뀌면 버튼 가장자리에서 끝까지 드래그해야합니다. 클릭을 취소하십시오. 이 사용 사례의 경우 &lt;a href=&quot;qml-qtquick-taphandler#gesturePolicy-prop&quot;&gt;gesturePolicy&lt;/a&gt; 를 &lt;code&gt;TapHandler.ReleaseWithinBounds&lt;/code&gt; 로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="0df67ea42533f0de938a1308386267d1cf340d7e" translate="yes" xml:space="preserve">
          <source>Note that by default tooltips are only shown for widgets that are children of the active window. You can change this behavior by setting the attribute &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt::WA_AlwaysShowToolTips&lt;/a&gt; on the</source>
          <target state="translated">기본적으로 툴팁은 활성 창의 하위 위젯에 대해서만 표시됩니다. &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt :: WA_AlwaysShowToolTips&lt;/a&gt; 속성을 설정하여이 동작을 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b41647324c8cf6343f280fbc90c75ff25cdcedfd" translate="yes" xml:space="preserve">
          <source>Note that by default, &lt;a href=&quot;qtimeline&quot;&gt;QTimeLine&lt;/a&gt; uses the EaseInOut curve shape, which provides a value that grows slowly, then grows steadily, and finally grows slowly. For a custom timeline, you can reimplement &lt;a href=&quot;qtimeline#valueForTime&quot;&gt;valueForTime&lt;/a&gt;(), in which case &lt;a href=&quot;qtimeline&quot;&gt;QTimeLine&lt;/a&gt;'s &lt;a href=&quot;qtimeline#curveShape-prop&quot;&gt;curveShape&lt;/a&gt; property is ignored.</source>
          <target state="translated">기본적으로 &lt;a href=&quot;qtimeline&quot;&gt;QTimeLine&lt;/a&gt; 은 EaseInOut 곡선 모양을 사용합니다.이 곡선 모양은 천천히 성장한 다음 꾸준히 성장하고 천천히 성장하는 값을 제공합니다. 사용자 정의 타임 라인의 경우 &lt;a href=&quot;qtimeline#valueForTime&quot;&gt;valueForTime&lt;/a&gt; ()을 다시 구현할 수 &lt;a href=&quot;qtimeline&quot;&gt;있으며이&lt;/a&gt; 경우 QTimeLine 의 &lt;a href=&quot;qtimeline#curveShape-prop&quot;&gt;curveShape&lt;/a&gt; 속성이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="2f39b8b314c76639f6ef8821437194b890ff7541" translate="yes" xml:space="preserve">
          <source>Note that by default, if not contradicted by the file metadata, the loaded texture will have the following properties set: - &lt;a href=&quot;qt3drender-qabstracttexture#wrapMode-prop&quot;&gt;wrapMode&lt;/a&gt; set to Repeat - &lt;a href=&quot;qt3drender-qabstracttexture#minificationFilter-prop&quot;&gt;minificationFilter&lt;/a&gt; set to &lt;a href=&quot;qt3drender-qabstracttexture#Filter-enum&quot;&gt;LinearMipMapLinear&lt;/a&gt; - &lt;a href=&quot;qt3drender-qabstracttexture#magnificationFilter-prop&quot;&gt;magnificationFilter&lt;/a&gt; set to Linear - &lt;a href=&quot;qt3drender-qabstracttexture#generateMipMaps-prop&quot;&gt;generateMipMaps&lt;/a&gt; set to true - &lt;a href=&quot;qt3drender-qabstracttexture#maximumAnisotropy&quot;&gt;maximumAnisotropy&lt;/a&gt; set to 16.0f - target set to &lt;a href=&quot;qt3drender-qabstracttexture#Target-enum&quot;&gt;TargetAutomatic&lt;/a&gt;</source>
          <target state="translated">참고 다음과 같은 속성이 설정된 파일 메타 데이터 모순되지 않을 경우 기본적으로,로드 된 텍스처가있는 것 : - &lt;a href=&quot;qt3drender-qabstracttexture#wrapMode-prop&quot;&gt;wrapMode의&lt;/a&gt; 세트를 반복하기 - &lt;a href=&quot;qt3drender-qabstracttexture#minificationFilter-prop&quot;&gt;minificationFilter의&lt;/a&gt; 집합에 &lt;a href=&quot;qt3drender-qabstracttexture#Filter-enum&quot;&gt;LinearMipMapLinear&lt;/a&gt; - &lt;a href=&quot;qt3drender-qabstracttexture#magnificationFilter-prop&quot;&gt;magnificationFilter의&lt;/a&gt; 세트를 선형으로 - &lt;a href=&quot;qt3drender-qabstracttexture#generateMipMaps-prop&quot;&gt;generateMipMaps이&lt;/a&gt; - true로 설정 &lt;a href=&quot;qt3drender-qabstracttexture#maximumAnisotropy&quot;&gt;maximumAnisotropy&lt;/a&gt; 16.0f로 설정 - 대상이 &lt;a href=&quot;qt3drender-qabstracttexture#Target-enum&quot;&gt;TargetAutomatic으로&lt;/a&gt; 설정</target>
        </trans-unit>
        <trans-unit id="d7fe1cd28fb1810a66e5be326babf87e758c5dbd" translate="yes" xml:space="preserve">
          <source>Note that by the time the transition is applied, the item has already been removed from the model; any references to the model data for the removed index will not be valid.</source>
          <target state="translated">전환이 적용될 때까지 항목은 이미 모델에서 제거되었습니다. 제거 된 인덱스의 모델 데이터에 대한 참조는 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cbaaac217d8f8c713e731d433f6e8b477105ec24" translate="yes" xml:space="preserve">
          <source>Note that cacheBuffer is not a pixel buffer - it only maintains additional instantiated delegates.</source>
          <target state="translated">cacheBuffer는 픽셀 버퍼가 아니며 추가 인스턴스화 된 델리게이트 만 유지합니다.</target>
        </trans-unit>
        <trans-unit id="850791f60e2cee1adcc1bc3c46066512d1ba8575" translate="yes" xml:space="preserve">
          <source>Note that calling setColor() will not make a difference if the style is a gradient. The same is the case if the style is &lt;a href=&quot;qt#BrushStyle-enum&quot;&gt;Qt::TexturePattern&lt;/a&gt; style unless the current texture is a &lt;a href=&quot;qbitmap&quot;&gt;QBitmap&lt;/a&gt;.</source>
          <target state="translated">스타일이 그라디언트 인 경우 setColor ()를 호출해도 차이가 없습니다. 현재 텍스처가 &lt;a href=&quot;qbitmap&quot;&gt;QBitmap&lt;/a&gt; 이 아닌 경우 스타일이 &lt;a href=&quot;qt#BrushStyle-enum&quot;&gt;Qt :: TexturePattern&lt;/a&gt; 스타일 인 경우에도 마찬가지 입니다.</target>
        </trans-unit>
        <trans-unit id="f5fdfb615d5c90337b509849080d969b87e38585" translate="yes" xml:space="preserve">
          <source>Note that calling this function can be significantely slower than using call() on the respective &lt;a href=&quot;qaxscript&quot;&gt;QAxScript&lt;/a&gt; directly.</source>
          <target state="translated">이 함수를 호출하면 해당 &lt;a href=&quot;qaxscript&quot;&gt;QAxScript에서&lt;/a&gt; 직접 call ()을 사용하는 것보다 상당히 느릴 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="35b09cc9da84e41fd1034b0d5899c8c1a7c6edae" translate="yes" xml:space="preserve">
          <source>Note that calling this function repeatedly, for instance from a key event handler, may be slow. In such cases, you should use the &lt;code&gt;dataChanged()&lt;/code&gt; signal instead.</source>
          <target state="translated">예를 들어 키 이벤트 핸들러에서이 함수를 반복적으로 호출하면 속도가 느려질 수 있습니다. 이러한 경우 &lt;code&gt;dataChanged()&lt;/code&gt; 신호를 대신 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="733f8433d52671c788b2c43a44a517663d55aac1" translate="yes" xml:space="preserve">
          <source>Note that changing settings in &lt;a href=&quot;qsslconfiguration&quot;&gt;QSslConfiguration&lt;/a&gt; is not enough to change the settings in the related SSL connection. You must call setSslConfiguration on a modified &lt;a href=&quot;qsslconfiguration&quot;&gt;QSslConfiguration&lt;/a&gt; object to achieve that. The following example illustrates how to change the protocol to TLSv1_0 in a &lt;a href=&quot;qsslsocket&quot;&gt;QSslSocket&lt;/a&gt; object:</source>
          <target state="translated">의 설정을 변경합니다 &lt;a href=&quot;qsslconfiguration&quot;&gt;QSslConfiguration하는&lt;/a&gt; 관련 SSL 연결의 설정을 변경하는 것만으로는 충분하지 않습니다. 이를 위해서는 수정 된 &lt;a href=&quot;qsslconfiguration&quot;&gt;QSslConfiguration&lt;/a&gt; 오브젝트에서 setSslConfiguration을 호출해야합니다 . 다음 예제는 &lt;a href=&quot;qsslsocket&quot;&gt;QSslSocket&lt;/a&gt; 오브젝트 에서 프로토콜을 TLSv1_0으로 변경하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="96391d8b54351dfc1ca9187d6ccd1f5f25b682eb" translate="yes" xml:space="preserve">
          <source>Note that changing the engines will reset the printer state and all its properties.</source>
          <target state="translated">엔진을 변경하면 프린터 상태와 모든 속성이 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="9b9b3830c0f47597047904fa3dceae48819e2f7f" translate="yes" xml:space="preserve">
          <source>Note that changing the message handler after the query has been compiled has no effect, i.e. the query uses the same message handler at runtime that it uses at compile time.</source>
          <target state="translated">쿼리가 컴파일 된 후 메시지 핸들러를 변경해도 아무런 영향을 미치지 않습니다. 즉, 쿼리시 런타임에 컴파일시 사용하는 것과 동일한 메시지 핸들러를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="28b264c661fc9cd1afbbdddaf26eb9cefa5f3f3f" translate="yes" xml:space="preserve">
          <source>Note that changing the type of a proxy does not change the set of capabilities this &lt;a href=&quot;qnetworkproxy&quot;&gt;QNetworkProxy&lt;/a&gt; object holds if any capabilities have been set with &lt;a href=&quot;qnetworkproxy#setCapabilities&quot;&gt;setCapabilities&lt;/a&gt;().</source>
          <target state="translated">프록시의 유형을 변경해도 &lt;a href=&quot;qnetworkproxy#setCapabilities&quot;&gt;setCapabilities&lt;/a&gt; () 로 설정된 기능이있는 &lt;a href=&quot;qnetworkproxy&quot;&gt;경우이 QNetworkProxy&lt;/a&gt; 객체가 보유하는 기능 세트는 변경되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="506d718d25aa1537cfc2dc0e0b14d1d97f55065e" translate="yes" xml:space="preserve">
          <source>Note that changing this value implicitly changes also the distance between the camera and the map, so that, at a tilting angle of 0 degrees, the resulting image is identical for any value used for this property.</source>
          <target state="translated">이 값을 변경하면 카메라와지도 사이의 거리도 암시 적으로 변경되므로 0 도의 기울기 각도에서 결과 이미지가이 속성에 사용 된 값과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="8fe56606380a91e0d8bd96ca3eb37d0ce62e8db0" translate="yes" xml:space="preserve">
          <source>Note that character references and references to predefined entities are expanded by the XML processor so that characters are represented by their Unicode equivalent rather than by an entity reference.</source>
          <target state="translated">문자 참조 및 사전 정의 된 엔티티에 대한 참조는 XML 프로세서에 의해 확장되므로 문자는 엔티티 참조가 아닌 해당 유니 코드로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="1dc911db5b6d31c867d442f2c1cc2fccf818912d" translate="yes" xml:space="preserve">
          <source>Note that checkable items need to be given both a suitable set of flags and an initial state, indicating whether the item is checked or not. This is handled automatically for model/view components, but needs to be explicitly set for instances of &lt;a href=&quot;qlistwidgetitem&quot;&gt;QListWidgetItem&lt;/a&gt;, &lt;a href=&quot;qtablewidgetitem&quot;&gt;QTableWidgetItem&lt;/a&gt;, and &lt;a href=&quot;qtreewidgetitem&quot;&gt;QTreeWidgetItem&lt;/a&gt;.</source>
          <target state="translated">확인 가능한 항목에는 적절한 플래그 세트와 초기 상태가 지정되어 항목을 확인했는지 여부를 나타냅니다. 이는 모델 / 뷰 컴포넌트에 대해 자동으로 처리되지만 &lt;a href=&quot;qlistwidgetitem&quot;&gt;QListWidgetItem&lt;/a&gt; , &lt;a href=&quot;qtablewidgetitem&quot;&gt;QTableWidgetItem&lt;/a&gt; 및 &lt;a href=&quot;qtreewidgetitem&quot;&gt;QTreeWidgetItem의&lt;/a&gt; 인스턴스에 대해 명시 적으로 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="2b49e639810a092fd5d83d12fed27ab02150e4f8" translate="yes" xml:space="preserve">
          <source>Note that class &lt;code&gt;Employee&lt;/code&gt; also has a trivial copy constructor defined, which is not strictly required in this case.</source>
          <target state="translated">&lt;code&gt;Employee&lt;/code&gt; 클래스 에도 간단한 복사 생성자가 정의되어 있으며이 경우에는 꼭 필요한 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="0f7a5540d96c26724a819254dbfe953cf985b0e3" translate="yes" xml:space="preserve">
          <source>Note that class &lt;code&gt;T&lt;/code&gt; must inherit &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;, or a compilation or link error will result.</source>
          <target state="translated">클래스 &lt;code&gt;T&lt;/code&gt; 는 &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 를 상속해야합니다. 그렇지 않으면 컴파일 또는 링크 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9c5cc19a0336a06096e6ba8b1756e4356755d2d9" translate="yes" xml:space="preserve">
          <source>Note that comparing paths may involve a per element comparison which can be slow for complex paths.</source>
          <target state="translated">경로를 비교하는 것은 복잡한 경로에 대해 느릴 수있는 요소 당 비교를 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="423656132077510fd1907b8f7df344aefd8f2a52" translate="yes" xml:space="preserve">
          <source>Note that comparing to &lt;code&gt;time_point&lt;/code&gt; is not as efficient as comparing to &lt;code&gt;duration&lt;/code&gt;, since &lt;a href=&quot;qdeadlinetimer&quot;&gt;QDeadlineTimer&lt;/a&gt; may need to convert from its own internal clock source to the clock source used by the &lt;code&gt;time_point&lt;/code&gt; object. Also note that, due to this conversion, the deadlines will not be precise, so the following code is not expected to compare equally:</source>
          <target state="translated">에 비해 유의 &lt;code&gt;time_point&lt;/code&gt; 하기 에 비해만큼 효율적이지 못하다 &lt;code&gt;duration&lt;/code&gt; 이후, &lt;a href=&quot;qdeadlinetimer&quot;&gt;QDeadlineTimer가&lt;/a&gt; 에 의해 사용되는 클럭 소스에 자체 내장 클럭 소스로 변환해야 할 수도 있습니다 &lt;code&gt;time_point&lt;/code&gt; 의 객체입니다. 또한이 변환으로 인해 마감일이 정확하지 않으므로 다음 코드는 동일하게 비교할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c71fcb8942e2ac0a9e997b63c5ef8e530f61d8c8" translate="yes" xml:space="preserve">
          <source>Note that comparing values where either</source>
          <target state="translated">값이 비교되는 경우</target>
        </trans-unit>
        <trans-unit id="61ad454c89c5d8b5cf4059acd78469532471749f" translate="yes" xml:space="preserve">
          <source>Note that composition transformation operates pixelwise. For that reason, there is a difference between using the graphic primitive itself and its bounding rectangle: The bounding rect contains pixels with alpha == 0 (i.e the pixels surrounding the primitive). These pixels will overwrite the other image's pixels, effectively clearing those, while the primitive only overwrites its own area.</source>
          <target state="translated">컴포지션 변환은 픽셀 단위로 작동합니다. 이러한 이유로 그래픽 프리미티브 자체와 그 경계 사각형을 사용하는 것에는 차이가 있습니다. 바운딩 rect는 alpha == 0 인 픽셀을 포함합니다 (즉, 프리미티브를 둘러싸는 픽셀). 이 픽셀은 다른 이미지의 픽셀을 덮어 쓰기하여 효과적으로 지우는 반면, 기본은 자신의 영역 만 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="4a93e55b1cf45a7fa51929bac385a9c6cfc7f660" translate="yes" xml:space="preserve">
          <source>Note that custom datatypes must be declared as &lt;a href=&quot;qmetaobject&quot;&gt;meta objects&lt;/a&gt; and that stream operators must be implemented for them. See the &lt;a href=&quot;qmetaobject&quot;&gt;QMetaObject&lt;/a&gt; class description for details.</source>
          <target state="translated">사용자 정의 데이터 유형은 &lt;a href=&quot;qmetaobject&quot;&gt;메타 오브젝트&lt;/a&gt; 로 선언해야하며 스트림 연산자는이를 구현해야합니다. 자세한 내용은 &lt;a href=&quot;qmetaobject&quot;&gt;QMetaObject&lt;/a&gt; 클래스 설명을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1e2743a9f2f37d3ec6ecd1f9bad8f8ac52079bb5" translate="yes" xml:space="preserve">
          <source>Note that custom datatypes used in item views must be declared as &lt;a href=&quot;qmetaobject&quot;&gt;meta objects&lt;/a&gt; and that stream operators for them must be implemented.</source>
          <target state="translated">항목보기에 사용 된 사용자 정의 데이터 유형은 &lt;a href=&quot;qmetaobject&quot;&gt;메타 오브젝트&lt;/a&gt; 로 선언되어야하며 해당 유형에 대한 스트림 연산자를 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="7ff8be836b633828f5d62b1ac450c5a59a213ff5" translate="yes" xml:space="preserve">
          <source>Note that custom views may interpret the concepts of next and previous differently.</source>
          <target state="translated">사용자 정의보기는 다음과 이전의 개념을 다르게 해석 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eacba435b9fceb3e8f81a22dc5846651c217050b" translate="yes" xml:space="preserve">
          <source>Note that data can be written to the socket immediately after the return from &lt;a href=&quot;qsslsocket#connectToHostEncrypted&quot;&gt;connectToHostEncrypted&lt;/a&gt;() (i.e., before the &lt;a href=&quot;qsslsocket#encrypted&quot;&gt;encrypted&lt;/a&gt;() signal is emitted). The data is queued in &lt;a href=&quot;qsslsocket&quot;&gt;QSslSocket&lt;/a&gt; until after the &lt;a href=&quot;qsslsocket#encrypted&quot;&gt;encrypted&lt;/a&gt;() signal is emitted.</source>
          <target state="translated">&lt;a href=&quot;qsslsocket#connectToHostEncrypted&quot;&gt;connectToHostEncrypted&lt;/a&gt; () 에서 리턴 한 직후 (즉, &lt;a href=&quot;qsslsocket#encrypted&quot;&gt;암호화 된&lt;/a&gt; () 신호가 생성 되기 전에) 소켓에 데이터를 쓸 수 있습니다 . 데이터는 &lt;a href=&quot;qsslsocket#encrypted&quot;&gt;암호화 된&lt;/a&gt; () 신호가 방출 될 때까지 &lt;a href=&quot;qsslsocket&quot;&gt;QSslSocket에&lt;/a&gt; 대기 합니다.</target>
        </trans-unit>
        <trans-unit id="0f3949d9d7e2d5ff3ff35b13974fc07186a04323" translate="yes" xml:space="preserve">
          <source>Note that datagrams can be transmitted with no data, so the returned &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; may be empty.</source>
          <target state="translated">데이터 그램은 데이터없이 전송 될 수 있으므로 반환 된 &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; 가 비어있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4efa978bda74fc870cadbf4bbf2827a4bc6f0d9e" translate="yes" xml:space="preserve">
          <source>Note that declaring a &lt;a href=&quot;qml-qtlocation-mapcopyrightnotice&quot;&gt;MapCopyrightNotice&lt;/a&gt; inside a &lt;a href=&quot;qml-qtlocation-map&quot;&gt;QtLocation::Map&lt;/a&gt; element is not possible, like for any other &lt;a href=&quot;qquickitem&quot;&gt;QQuickItem&lt;/a&gt;.</source>
          <target state="translated">다른 &lt;a href=&quot;qquickitem&quot;&gt;QQuickItem&lt;/a&gt; 과 마찬가지로 &lt;a href=&quot;qml-qtlocation-map&quot;&gt;QtLocation :: Map&lt;/a&gt; 요소 내에 &lt;a href=&quot;qml-qtlocation-mapcopyrightnotice&quot;&gt;MapCopyrightNotice&lt;/a&gt; 를 선언 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="690a376a1f59531760b717ba5655eef60fc40ee0" translate="yes" xml:space="preserve">
          <source>Note that deleting a &lt;a href=&quot;qthread&quot;&gt;QThread&lt;/a&gt; object will not stop the execution of the thread it manages. Deleting a running &lt;a href=&quot;qthread&quot;&gt;QThread&lt;/a&gt; (i.e. &lt;a href=&quot;qthread#isFinished&quot;&gt;isFinished&lt;/a&gt;() returns &lt;code&gt;false&lt;/code&gt;) will result in a program crash. Wait for the &lt;a href=&quot;qthread#finished&quot;&gt;finished&lt;/a&gt;() signal before deleting the &lt;a href=&quot;qthread&quot;&gt;QThread&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qthread&quot;&gt;QThread&lt;/a&gt; 객체 를 삭제 해도 관리하는 스레드의 실행이 중지되지는 않습니다. 실행중인 &lt;a href=&quot;qthread&quot;&gt;QThread를&lt;/a&gt; 삭제하면 (즉, &lt;a href=&quot;qthread#isFinished&quot;&gt;isFinished&lt;/a&gt; ()는 &lt;code&gt;false&lt;/code&gt; 를 반환 함 ) 프로그램 충돌이 발생합니다. &lt;a href=&quot;qthread&quot;&gt;QThread&lt;/a&gt; 를 삭제하기 전에 &lt;a href=&quot;qthread#finished&quot;&gt;완료&lt;/a&gt; () 신호를 기다 립니다.</target>
        </trans-unit>
        <trans-unit id="88be7f7359ef57ce9d46f02cd011581b72e7a4bd" translate="yes" xml:space="preserve">
          <source>Note that display of messages are dependent on the system configuration and user preferences, and that messages may not appear at all. Hence, it should not be relied upon as the sole means for providing critical information.</source>
          <target state="translated">메시지 표시는 시스템 구성 및 사용자 기본 설정에 따라 다르며 메시지가 전혀 표시되지 않을 수 있습니다. 따라서 중요한 정보를 제공하는 유일한 수단으로 의존해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="294085a0c6b4261e722d56e7979363ecac1974c8" translate="yes" xml:space="preserve">
          <source>Note that due to C++ literal strings rules, you must escape all backslashes inside the pattern string with another backslash:</source>
          <target state="translated">C ++ 리터럴 문자열 규칙으로 인해 패턴 문자열 내부의 모든 백 슬래시를 다른 백 슬래시로 이스케이프해야합니다.</target>
        </trans-unit>
        <trans-unit id="165292cbf6379c14bebcf68edabe701c1dc348b4" translate="yes" xml:space="preserve">
          <source>Note that due to the way &lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt; and &lt;a href=&quot;qrectf&quot;&gt;QRectF&lt;/a&gt; are defined, an empty &lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt; is defined in essentially the same way as &lt;a href=&quot;qrectf&quot;&gt;QRectF&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt; 및 &lt;a href=&quot;qrectf&quot;&gt;QRectF&lt;/a&gt; 가 정의 되는 방식으로 인해 빈 &lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt; 는 &lt;a href=&quot;qrectf&quot;&gt;QRectF&lt;/a&gt; 와 기본적으로 동일한 방식으로 정의 됩니다.</target>
        </trans-unit>
        <trans-unit id="c789f311ac4aaeb0c962769c47f5c3f619d8e737" translate="yes" xml:space="preserve">
          <source>Note that due to the way &lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt; and &lt;a href=&quot;qrectf&quot;&gt;QRectF&lt;/a&gt; are defined, an empty &lt;a href=&quot;qrectf&quot;&gt;QRectF&lt;/a&gt; is defined in essentially the same way as &lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt; 및 &lt;a href=&quot;qrectf&quot;&gt;QRectF&lt;/a&gt; 가 정의 된 방식으로 인해 빈 &lt;a href=&quot;qrectf&quot;&gt;QRectF&lt;/a&gt; 는 본질적으로 &lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt; 와 동일한 방식으로 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="6681b016434e11ab7ee9f0c24b422487bc670111" translate="yes" xml:space="preserve">
          <source>Note that each &lt;a href=&quot;qml-qtqml-component&quot;&gt;Component&lt;/a&gt; object declaration creates its own</source>
          <target state="translated">각 &lt;a href=&quot;qml-qtqml-component&quot;&gt;Component&lt;/a&gt; 객체 선언은 고유 한</target>
        </trans-unit>
        <trans-unit id="809e98fdcdf42c64eb4aea334339ae2853cf16c9" translate="yes" xml:space="preserve">
          <source>Note that elements added as closed subpaths using the &lt;a href=&quot;qpainterpath#addEllipse&quot;&gt;addEllipse&lt;/a&gt;(), &lt;a href=&quot;qpainterpath#addPath&quot;&gt;addPath&lt;/a&gt;(), &lt;a href=&quot;qpainterpath#addPolygon&quot;&gt;addPolygon&lt;/a&gt;(), &lt;a href=&quot;qpainterpath#addRect&quot;&gt;addRect&lt;/a&gt;(), &lt;a href=&quot;qpainterpath#addRegion&quot;&gt;addRegion&lt;/a&gt;() and &lt;a href=&quot;qpainterpath#addText&quot;&gt;addText&lt;/a&gt;() convenience functions, is actually added to the path as a collection of separate elements using the &lt;a href=&quot;qpainterpath#moveTo&quot;&gt;moveTo&lt;/a&gt;(), &lt;a href=&quot;qpainterpath#lineTo&quot;&gt;lineTo&lt;/a&gt;() and &lt;a href=&quot;qpainterpath#cubicTo&quot;&gt;cubicTo&lt;/a&gt;() functions.</source>
          <target state="translated">요소가 사용 닫힌 윤곽선으로서 첨가 유의 &lt;a href=&quot;qpainterpath#addEllipse&quot;&gt;addEllipse&lt;/a&gt; () &lt;a href=&quot;qpainterpath#addPath&quot;&gt;addPath&lt;/a&gt; () &lt;a href=&quot;qpainterpath#addPolygon&quot;&gt;addPolygon&lt;/a&gt; () &lt;a href=&quot;qpainterpath#addRect&quot;&gt;addRect&lt;/a&gt; () &lt;a href=&quot;qpainterpath#addRegion&quot;&gt;addRegion&lt;/a&gt; () 및 &lt;a href=&quot;qpainterpath#addText&quot;&gt;addText&lt;/a&gt; () 편의 기능은 실제로 이용 개별 요소의 모음으로의 경로에 추가 &lt;a href=&quot;qpainterpath#moveTo&quot;&gt;의 moveTo을&lt;/a&gt; (), &lt;a href=&quot;qpainterpath#lineTo&quot;&gt;lineTo&lt;/a&gt; () 및 &lt;a href=&quot;qpainterpath#cubicTo&quot;&gt;cubicTo&lt;/a&gt; () 함수.</target>
        </trans-unit>
        <trans-unit id="efd9eaba1554d92c34691a74eca3d710c2c92e54" translate="yes" xml:space="preserve">
          <source>Note that entering and leaving a new event loop (e.g., by opening a modal dialog) will</source>
          <target state="translated">새 이벤트 루프를 시작하거나 종료하면 (예 : 모달 대화 상자를 열어서)</target>
        </trans-unit>
        <trans-unit id="170d411e8cec285c953b113a959808e290914f4d" translate="yes" xml:space="preserve">
          <source>Note that error codes are sensor-specific.</source>
          <target state="translated">오류 코드는 센서마다 다릅니다.</target>
        </trans-unit>
        <trans-unit id="16988d0fb5c4fbbaacace40238a420272a9f3879" translate="yes" xml:space="preserve">
          <source>Note that even a disabled tab/page may be visible. If the page is visible already, &lt;a href=&quot;qtabwidget&quot;&gt;QTabWidget&lt;/a&gt; will not hide it; if all the pages are disabled, &lt;a href=&quot;qtabwidget&quot;&gt;QTabWidget&lt;/a&gt; will show one of them.</source>
          <target state="translated">비활성화 된 탭 / 페이지도 표시 될 수 있습니다. 페이지가 이미 표시되어 있으면 &lt;a href=&quot;qtabwidget&quot;&gt;QTabWidget&lt;/a&gt; 은 해당 페이지를 숨기지 않습니다. 모든 페이지가 비활성화되면 &lt;a href=&quot;qtabwidget&quot;&gt;QTabWidget&lt;/a&gt; 이 그 중 하나를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="0cfaef1849684d1c22c183b120e39ba011fbaa2c" translate="yes" xml:space="preserve">
          <source>Note that even if &lt;a href=&quot;qlocale&quot;&gt;QLocale&lt;/a&gt; object was constructed with an explicit script, name() will not contain it for compatibility reasons. Use &lt;a href=&quot;qlocale#bcp47Name&quot;&gt;bcp47Name&lt;/a&gt;() instead if you need a full locale name.</source>
          <target state="translated">경우에도주의 &lt;a href=&quot;qlocale&quot;&gt;QLocale의&lt;/a&gt; 객체가 명시 적 스크립트로 구성되었으며, 이름 () 호환성을 위해 포함되지 않습니다. 전체 로케일 이름이 필요한 경우 &lt;a href=&quot;qlocale#bcp47Name&quot;&gt;bcp47Name&lt;/a&gt; ()을 대신 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="48d7284e7117b17d3277cc443cb0b82fc40cedfd" translate="yes" xml:space="preserve">
          <source>Note that even if successive tests return the exact same results (or empty results), a change notification will be emitted at every test.</source>
          <target state="translated">연속 테스트에서 정확히 동일한 결과 (또는 빈 결과)를 반환하더라도 모든 테스트에서 변경 알림이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="4608acbe844f1ebc93b49fb06e1cf1d2d02b89a5" translate="yes" xml:space="preserve">
          <source>Note that even if wrapping is enabled, the cell will not be expanded to fit all text. Ellipsis will be inserted according to the current &lt;a href=&quot;qabstractitemview#textElideMode-prop&quot;&gt;textElideMode&lt;/a&gt;.</source>
          <target state="translated">줄 바꿈을 사용하더라도 셀이 모든 텍스트에 맞게 확장되지는 않습니다. 현재 &lt;a href=&quot;qabstractitemview#textElideMode-prop&quot;&gt;textElideMode&lt;/a&gt; 에 따라 줄임표가 삽입됩니다 .</target>
        </trans-unit>
        <trans-unit id="186f8f25b38a9339b6c67c229a4831465b6e6056" translate="yes" xml:space="preserve">
          <source>Note that even of wrapping is enabled, the cell will not be expanded to fit all text. Ellipsis will be inserted according to the current &lt;a href=&quot;qabstractitemview#textElideMode-prop&quot;&gt;textElideMode&lt;/a&gt;.</source>
          <target state="translated">줄 바꿈을 사용하더라도 셀이 모든 텍스트에 맞게 확장되지는 않습니다. 현재 &lt;a href=&quot;qabstractitemview#textElideMode-prop&quot;&gt;textElideMode&lt;/a&gt; 에 따라 줄임표가 삽입됩니다 .</target>
        </trans-unit>
        <trans-unit id="f1ca8bae3895a72e4d03fb6c1cc2cb2fb34a4f9e" translate="yes" xml:space="preserve">
          <source>Note that even though only the element at index 2 is modified in the loop, the three bindings will all be re-evaluated since the granularity of the change signal is that the entire property has changed. As such, adding an intermediate binding can sometimes be beneficial:</source>
          <target state="translated">루프에서 인덱스 2의 요소 만 수정하더라도 변경 신호의 세분성이 전체 속성이 변경 되었기 때문에 세 개의 바인딩이 모두 재평가됩니다. 따라서 중간 바인딩을 추가하면 유익 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ffea268c20772709a879b295e77d493a9833aab" translate="yes" xml:space="preserve">
          <source>Note that for Oracle databases the row's ROWID will be returned, while for MySQL databases the row's auto-increment field will be returned.</source>
          <target state="translated">Oracle 데이터베이스의 경우 행의 ROWID가 반환되고 MySQL 데이터베이스의 경우 행의 자동 증가 필드가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="18f546d3685b9168b9ab54d5c053508f09d5260b" translate="yes" xml:space="preserve">
          <source>Note that for a single line of text, the size of the text is the area of the text. In this common case, all alignments are equivalent. If you want the text to be, say, centered in its parent, then you will need to either modify the &lt;a href=&quot;qml-qtquick-item#anchors-prop&quot;&gt;Item::anchors&lt;/a&gt;, or set &lt;a href=&quot;qml-qtquick-text#horizontalAlignment-prop&quot;&gt;horizontalAlignment&lt;/a&gt; to Text.AlignHCenter and bind the width to that of the parent.</source>
          <target state="translated">한 줄의 텍스트에서 텍스트의 크기는 텍스트의 영역입니다. 이 일반적인 경우 모든 정렬은 동일합니다. 텍스트를 부모의 가운데에 배치하려면 &lt;a href=&quot;qml-qtquick-item#anchors-prop&quot;&gt;Item :: anchors를&lt;/a&gt; 수정 하거나 &lt;a href=&quot;qml-qtquick-text#horizontalAlignment-prop&quot;&gt;horizontalAlignment&lt;/a&gt; 를 Text.AlignHCenter로 설정 하고 너비를 부모의 너비에 바인딩해야합니다.</target>
        </trans-unit>
        <trans-unit id="9c2346327725ea3e995ab331e4784543522316d1" translate="yes" xml:space="preserve">
          <source>Note that for an application- or module-wide cleanup, qAddPostRoutine() is often not suitable. For example, if the program is split into dynamically loaded modules, the relevant module may be unloaded long before the &lt;a href=&quot;qcoreapplication&quot;&gt;QCoreApplication&lt;/a&gt; destructor is called. In such cases, if using qAddPostRoutine() is still desirable, &lt;a href=&quot;qcoreapplication#qRemovePostRoutine&quot;&gt;qRemovePostRoutine&lt;/a&gt;() can be used to prevent a routine from being called by the &lt;a href=&quot;qcoreapplication&quot;&gt;QCoreApplication&lt;/a&gt; destructor. For example, if that routine was called before the module was unloaded.</source>
          <target state="translated">응용 프로그램 또는 모듈 전체 정리의 경우 qAddPostRoutine ()이 적합하지 않은 경우가 있습니다. 예를 들어, 프로그램이 동적으로로드 된 모듈로 분할 된 경우 &lt;a href=&quot;qcoreapplication&quot;&gt;QCoreApplication&lt;/a&gt; 소멸자가 호출 되기 훨씬 전에 관련 모듈이 언로드 될 수 있습니다 . 이러한 경우 qAddPostRoutine ()을 사용하는 것이 여전히 바람직한 경우 &lt;a href=&quot;qcoreapplication#qRemovePostRoutine&quot;&gt;qRemovePostRoutine&lt;/a&gt; ()을 사용하여 &lt;a href=&quot;qcoreapplication&quot;&gt;QCoreApplication&lt;/a&gt; 소멸자 가 루틴을 호출하지 못하게 할 수 있습니다 . 예를 들어, 모듈이 언로드되기 전에 해당 루틴이 호출 된 경우.</target>
        </trans-unit>
        <trans-unit id="d44de2f763b7121990e47a1e3c9eb266528f1709" translate="yes" xml:space="preserve">
          <source>Note that for efficiency, the local name string is not stored in the &lt;a href=&quot;qxmlname&quot;&gt;QXmlName&lt;/a&gt; but in the &lt;a href=&quot;qxmlnamepool&quot;&gt;QXmlNamePool&lt;/a&gt; that was passed to the constructor. Hence, that same</source>
          <target state="translated">효율성을 위해 로컬 이름 문자열은 &lt;a href=&quot;qxmlname&quot;&gt;QXmlName에&lt;/a&gt; 저장되지 않고 생성자에 전달 된 &lt;a href=&quot;qxmlnamepool&quot;&gt;QXmlNamePool&lt;/a&gt; 에 저장됩니다 . 따라서 동일</target>
        </trans-unit>
        <trans-unit id="4b06e79fc927f5bba4d2b8e7ce804bccd07a39e7" translate="yes" xml:space="preserve">
          <source>Note that for efficiency, the namespace URI string is not stored in the &lt;a href=&quot;qxmlname&quot;&gt;QXmlName&lt;/a&gt; but in the &lt;a href=&quot;qxmlnamepool&quot;&gt;QXmlNamePool&lt;/a&gt; that was passed to the constructor. Hence, that same</source>
          <target state="translated">효율성을 위해 네임 스페이스 URI 문자열은 &lt;a href=&quot;qxmlname&quot;&gt;QXmlName에&lt;/a&gt; 저장되지 않고 생성자에 전달 된 &lt;a href=&quot;qxmlnamepool&quot;&gt;QXmlNamePool&lt;/a&gt; 에 저장됩니다 . 따라서 동일</target>
        </trans-unit>
        <trans-unit id="a2da0c84ec79e2e522e648ad834973c633ded906" translate="yes" xml:space="preserve">
          <source>Note that for efficiency, the namespace URI, local name, and prefix strings are not stored in the &lt;a href=&quot;qxmlname&quot;&gt;QXmlName&lt;/a&gt; but in the &lt;a href=&quot;qxmlnamepool&quot;&gt;QXmlNamePool&lt;/a&gt; that was passed to the constructor. Hence, that same</source>
          <target state="translated">효율성을 위해 네임 스페이스 URI, 로컬 이름 및 접두사 문자열은 &lt;a href=&quot;qxmlname&quot;&gt;QXmlName이&lt;/a&gt; 아니라 생성자에 전달 된 &lt;a href=&quot;qxmlnamepool&quot;&gt;QXmlNamePool&lt;/a&gt; 에 저장됩니다 . 따라서 동일</target>
        </trans-unit>
        <trans-unit id="6967884a328e5a24bdd366889923f1ef1f6a1142" translate="yes" xml:space="preserve">
          <source>Note that for efficiency, the prefix string is not stored in the &lt;a href=&quot;qxmlname&quot;&gt;QXmlName&lt;/a&gt; but in the &lt;a href=&quot;qxmlnamepool&quot;&gt;QXmlNamePool&lt;/a&gt; that was passed to the constructor. Hence, that same</source>
          <target state="translated">효율성을 위해 접두사 문자열은 &lt;a href=&quot;qxmlname&quot;&gt;QXmlName에&lt;/a&gt; 저장되지 않고 생성자에 전달 된 &lt;a href=&quot;qxmlnamepool&quot;&gt;QXmlNamePool&lt;/a&gt; 에 저장됩니다 . 따라서 동일</target>
        </trans-unit>
        <trans-unit id="ac4c14f7f135949b9657e88babe097d9c5ffa0ac" translate="yes" xml:space="preserve">
          <source>Note that for historical reasons the return value of the &lt;a href=&quot;qrect#right&quot;&gt;QRect::right&lt;/a&gt;() and &lt;a href=&quot;qrect#bottom&quot;&gt;QRect::bottom&lt;/a&gt;() functions deviate from the true bottom-right corner of the rectangle.</source>
          <target state="translated">역사적 이유로 &lt;a href=&quot;qrect#right&quot;&gt;QRect :: right&lt;/a&gt; () 및 &lt;a href=&quot;qrect#bottom&quot;&gt;QRect :: bottom&lt;/a&gt; () 함수 의 반환 값은 사각형의 오른쪽 아래 모서리에서 벗어납니다.</target>
        </trans-unit>
        <trans-unit id="67b1031dd9528499dae500e642c3cbe6c63ed2c9" translate="yes" xml:space="preserve">
          <source>Note that for historical reasons the values returned by the &lt;a href=&quot;qrect#bottom&quot;&gt;bottom&lt;/a&gt;() and &lt;a href=&quot;qrect#right&quot;&gt;right&lt;/a&gt;() functions deviate from the true bottom-right corner of the rectangle: The &lt;a href=&quot;qrect#right&quot;&gt;right&lt;/a&gt;() function returns</source>
          <target state="translated">역사적 이유로 &lt;a href=&quot;qrect#bottom&quot;&gt;bottom&lt;/a&gt; () 및 &lt;a href=&quot;qrect#right&quot;&gt;right&lt;/a&gt; () 함수가 반환 한 값 은 사각형의 오른쪽 아래 모서리에서 벗어납니다. &lt;a href=&quot;qrect#right&quot;&gt;right&lt;/a&gt; () 함수는</target>
        </trans-unit>
        <trans-unit id="2df9678ea36558c501bb251a5c8de59ba618d277" translate="yes" xml:space="preserve">
          <source>Note that for historical reasons this function returns &lt;a href=&quot;qpoint&quot;&gt;QPoint&lt;/a&gt;(&lt;a href=&quot;qrect#left&quot;&gt;left&lt;/a&gt;() + &lt;a href=&quot;qrect#width&quot;&gt;width&lt;/a&gt;() -1, &lt;a href=&quot;qrect#top&quot;&gt;top&lt;/a&gt;() + &lt;a href=&quot;qrect#height&quot;&gt;height&lt;/a&gt;() - 1).</source>
          <target state="translated">역사적 이유로이 함수는 &lt;a href=&quot;qpoint&quot;&gt;QPoint&lt;/a&gt; ( &lt;a href=&quot;qrect#left&quot;&gt;left&lt;/a&gt; () + &lt;a href=&quot;qrect#width&quot;&gt;width&lt;/a&gt; () -1, &lt;a href=&quot;qrect#top&quot;&gt;top&lt;/a&gt; () + &lt;a href=&quot;qrect#height&quot;&gt;height&lt;/a&gt; () -1 )를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="7f3f7d27b0d7d166ef592bfdbdb2a46b466016d8" translate="yes" xml:space="preserve">
          <source>Note that for historical reasons this function returns &lt;a href=&quot;qpoint&quot;&gt;QPoint&lt;/a&gt;(&lt;a href=&quot;qrect#left&quot;&gt;left&lt;/a&gt;() + &lt;a href=&quot;qrect#width&quot;&gt;width&lt;/a&gt;() -1, &lt;a href=&quot;qrect#top&quot;&gt;top&lt;/a&gt;()).</source>
          <target state="translated">역사적 이유로이 함수는 &lt;a href=&quot;qpoint&quot;&gt;QPoint&lt;/a&gt; ( &lt;a href=&quot;qrect#left&quot;&gt;left&lt;/a&gt; () + &lt;a href=&quot;qrect#width&quot;&gt;width&lt;/a&gt; () -1, &lt;a href=&quot;qrect#top&quot;&gt;top&lt;/a&gt; ())를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="8f44d88685b93a80897173ff992bffbe612cc19f" translate="yes" xml:space="preserve">
          <source>Note that for historical reasons this function returns &lt;a href=&quot;qrect#left&quot;&gt;left&lt;/a&gt;() + &lt;a href=&quot;qrect#width&quot;&gt;width&lt;/a&gt;() - 1; use &lt;a href=&quot;qrect#x&quot;&gt;x&lt;/a&gt;() + &lt;a href=&quot;qrect#width&quot;&gt;width&lt;/a&gt;() to retrieve the true x-coordinate.</source>
          <target state="translated">역사적 이유로이 함수는 &lt;a href=&quot;qrect#left&quot;&gt;left&lt;/a&gt; () + &lt;a href=&quot;qrect#width&quot;&gt;width&lt;/a&gt; ()-1을 반환합니다 . 사용 &lt;a href=&quot;qrect#x&quot;&gt;X는&lt;/a&gt; () + &lt;a href=&quot;qrect#width&quot;&gt;폭&lt;/a&gt; () 실제 X 좌표를 검색한다.</target>
        </trans-unit>
        <trans-unit id="02017018df965bf31b87da8e65bbb30d100db747" translate="yes" xml:space="preserve">
          <source>Note that for historical reasons this function returns &lt;a href=&quot;qrect#top&quot;&gt;top&lt;/a&gt;() + &lt;a href=&quot;qrect#height&quot;&gt;height&lt;/a&gt;() - 1; use &lt;a href=&quot;qrect#y&quot;&gt;y&lt;/a&gt;() + &lt;a href=&quot;qrect#height&quot;&gt;height&lt;/a&gt;() to retrieve the true y-coordinate.</source>
          <target state="translated">역사적 이유로이 함수는 &lt;a href=&quot;qrect#top&quot;&gt;top&lt;/a&gt; () + &lt;a href=&quot;qrect#height&quot;&gt;height&lt;/a&gt; ()-1을 반환합니다 . 사용 &lt;a href=&quot;qrect#y&quot;&gt;예&lt;/a&gt; () + &lt;a href=&quot;qrect#height&quot;&gt;높이&lt;/a&gt; () 진정한 Y 좌표를 검색한다.</target>
        </trans-unit>
        <trans-unit id="a804c6a5236f49ec4666591cfc5c7ac7f089314b" translate="yes" xml:space="preserve">
          <source>Note that for icons to appear in buttons in a &lt;a href=&quot;qdialogbuttonbox&quot;&gt;QDialogButtonBox&lt;/a&gt;, you need to set the dialogbuttonbox-buttons-have-icons property to true. Also, to customize the size of the icons, use the icon-size property.</source>
          <target state="translated">&lt;a href=&quot;qdialogbuttonbox&quot;&gt;QDialogButtonBox의&lt;/a&gt; 버튼에 아이콘이 나타나 려면 dialogbuttonbox-buttons-have-icons 속성을 true로 설정해야합니다. 또한 아이콘 크기를 사용자 정의하려면 icon-size 특성을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="195e0d1bd485aca9927339619f04da751b46de00" translate="yes" xml:space="preserve">
          <source>Note that for nested Flickables with pressDelay set, the pressDelay of outer Flickables is overridden by the innermost Flickable. If the drag exceeds the platform drag threshold, the press event will be delivered regardless of this property.</source>
          <target state="translated">pressDelay가 설정된 중첩 된 Flickables의 경우 외부 Flickables의 pressDelay가 가장 안쪽 Flickable에 의해 재정의됩니다. 드래그가 플랫폼 드래그 임계 값을 초과하면이 속성에 관계없이 프레스 이벤트가 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="22e5e43cd11b59116f942d146d458caf124b3af7" translate="yes" xml:space="preserve">
          <source>Note that for some plain text strings containing XML meta-characters, the auto-text &lt;a href=&quot;qt-sub-qtgui#mightBeRichText&quot;&gt;rich text detection test&lt;/a&gt; may fail causing your plain text string to be interpreted incorrectly as rich text. In these rare cases, use &lt;a href=&quot;qt-sub-qtgui#convertFromPlainText&quot;&gt;Qt::convertFromPlainText&lt;/a&gt;() to convert your plain text string to a visually equivalent rich text string, or set the &lt;a href=&quot;qmessagebox#textFormat-prop&quot;&gt;text format&lt;/a&gt; property explicitly with &lt;a href=&quot;qmessagebox#textFormat-prop&quot;&gt;setTextFormat&lt;/a&gt;().</source>
          <target state="translated">XML 메타 문자를 포함하는 일부 일반 텍스트 문자열의 경우 자동 텍스트 &lt;a href=&quot;qt-sub-qtgui#mightBeRichText&quot;&gt;리치 텍스트 감지 테스트&lt;/a&gt; 가 실패하여 일반 텍스트 문자열이 리치 텍스트로 잘못 해석 될 수 있습니다. 드문 경우이지만 &lt;a href=&quot;qt-sub-qtgui#convertFromPlainText&quot;&gt;Qt :: convertFromPlainText&lt;/a&gt; ()를 사용하여 일반 텍스트 문자열을 시각적으로 동등한 리치 텍스트 문자열로 변환하거나 &lt;a href=&quot;qmessagebox#textFormat-prop&quot;&gt;setTextFormat&lt;/a&gt; ()을 사용하여 &lt;a href=&quot;qmessagebox#textFormat-prop&quot;&gt;텍스트 형식&lt;/a&gt; 속성을 명시 적으로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="6dba32cfff614823f0dfc07797ab56d35c15277f" translate="yes" xml:space="preserve">
          <source>Note that for the moment, alpha masks on monochrome images are ignored.</source>
          <target state="translated">현재 흑백 이미지의 알파 마스크는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="f505b1de5ccceadfb4a8ab01281bd656c0ca3ed5" translate="yes" xml:space="preserve">
          <source>Note that for the single selection mode, the current item will be in the selection. In the multi-selection and extended selection modes, the current item may not lie within the selection, depending on the way the user formed the selection.</source>
          <target state="translated">단일 선택 모드의 경우 현재 항목이 선택됩니다. 다중 선택 및 확장 선택 모드에서 사용자가 선택을 구성한 방식에 따라 현재 항목이 선택 내에 있지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="713c46fc3e762df83dfbe19f41638d9941f9e365" translate="yes" xml:space="preserve">
          <source>Note that for views with a large content size (more than 10 times the view size), the velocity of the flick may exceed the velocity of the touch in the case of multiple quick consecutive flicks. This allows the user to flick faster through large content.</source>
          <target state="translated">컨텐츠 크기가 큰 (뷰 크기의 10 배 이상) 뷰의 경우 연속으로 빠르게 여러 번 튕기는 경우 플릭 속도가 터치 속도를 초과 할 수 있습니다. 이를 통해 사용자는 대용량 콘텐츠를 빠르게 넘길 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b308372f575c8ed500a2abbac2963177ba7fc37c" translate="yes" xml:space="preserve">
          <source>Note that fromString() uses a &quot;C&quot; locale encoded string to convert milliseconds to a float value. If the default locale is not &quot;C&quot;, this may result in two conversion attempts (if the conversion fails for the default locale). This should be considered an implementation detail.</source>
          <target state="translated">fromString ()은 &quot;C&quot;로케일로 인코딩 된 문자열을 사용하여 밀리 초를 부동 소수점 값으로 변환합니다. 기본 로캘이 &quot;C&quot;가 아닌 경우 두 번의 변환 시도가 발생할 수 있습니다 (기본 로캘에 대한 변환이 실패한 경우). 이것은 구현 세부 사항으로 간주되어야합니다.</target>
        </trans-unit>
        <trans-unit id="603ca3815aa51d47d4fc3eda8695131e3460ea4f" translate="yes" xml:space="preserve">
          <source>Note that function values, variant values, and &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; values are objects, so this function returns true for such values.</source>
          <target state="translated">함수 값, 변형 값 및 &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 값은 객체 이므로이 함수는 해당 값에 대해 true를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e53b06f872020ebc0a54e119a7b976b3f16cd4e6" translate="yes" xml:space="preserve">
          <source>Note that if</source>
          <target state="translated">만약에</target>
        </trans-unit>
        <trans-unit id="eaf41539bdfb4fd3f39e405f8d3ea5c0f8a41de9" translate="yes" xml:space="preserve">
          <source>Note that if &lt;a href=&quot;qshareddatapointer#detach&quot;&gt;detach&lt;/a&gt;() is called more than once in a member function due to multiple dereferences of the</source>
          <target state="translated">경우 유의 &lt;a href=&quot;qshareddatapointer#detach&quot;&gt;분리가&lt;/a&gt; ()으로 인해 다수의 역 참조로 더 멤버 함수를 두 번 이상이라고</target>
        </trans-unit>
        <trans-unit id="e60d881f7285911354eed813f4214ff0ba97160b" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;highlightRangeMode&lt;/code&gt; is set to &lt;code&gt;StrictlyEnforceRange&lt;/code&gt; the currentIndex will be affected by dragging/flicking the view, since the view will always ensure that the &lt;code&gt;currentIndex&lt;/code&gt; is within the highlight range specified.</source>
          <target state="translated">&lt;code&gt;highlightRangeMode&lt;/code&gt; 가 &lt;code&gt;StrictlyEnforceRange&lt;/code&gt; 로 설정된 경우 뷰는 항상 &lt;code&gt;currentIndex&lt;/code&gt; 가 지정된 강조 표시 범위 내에 있도록 보장하기 때문에 뷰를 끌어서 이동하여 currentIndex에 영향을 줍니다.</target>
        </trans-unit>
        <trans-unit id="2123fa00aa289d952f9363835c1826907ba1d9e5" translate="yes" xml:space="preserve">
          <source>Note that if a &lt;a href=&quot;qml-qtquick-keynavigation&quot;&gt;KeyNavigation&lt;/a&gt; attached property receives the key press and release events for a requested arrow or tab key, the event is accepted and does not propagate any further.</source>
          <target state="translated">경우주의 &lt;a href=&quot;qml-qtquick-keynavigation&quot;&gt;KeyNavigation&lt;/a&gt; 연결된 속성이 요청 된 화살표 나 탭 키의 키 언론과 릴리스 이벤트를 수신, 이벤트가 인정되고 더 이상 전파되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ad7e21b12dc235cb18f336676d4116dd6bb74b68" translate="yes" xml:space="preserve">
          <source>Note that if a QML document does not import a module which provides a particular QML object type, but attempts to use that object type anyway, an error will occur. For example, the following QML document does not import &lt;code&gt;QtQuick&lt;/code&gt; and thus attempting to use the &lt;code&gt;Rectangle&lt;/code&gt; type will fail:</source>
          <target state="translated">QML 문서가 특정 QML 오브젝트 유형을 제공하는 모듈을 가져 오지 않지만 해당 오브젝트 유형을 사용하려고 시도하면 오류가 발생합니다. 예를 들어, 다음 QML 문서는 &lt;code&gt;QtQuick&lt;/code&gt; 을 가져 오지 않으므로 &lt;code&gt;Rectangle&lt;/code&gt; 유형 을 사용하려고 하면 실패합니다.</target>
        </trans-unit>
        <trans-unit id="877239311b8229dbc42a6cb2a7dcd6874110fba9" translate="yes" xml:space="preserve">
          <source>Note that if a binding cannot be optimized by the QML engine's optimized binding expression evaluator, and thus must be evaluated by the full JavaScript environment, some of the tips listed above will no longer apply. For example, it can sometimes be beneficial to cache the result of property resolution in an intermediate JavaScript variable in a very complex binding. Upcoming sections have more information on these sorts of optimizations.</source>
          <target state="translated">QML 엔진의 최적화 된 바인딩 표현식 평가기로 바인딩을 최적화 할 수 없으므로 전체 JavaScript 환경에서 평가해야하는 경우 위에 나열된 일부 팁이 더 이상 적용되지 않습니다. 예를 들어, 속성 분석 결과를 매우 복잡한 바인딩으로 중간 JavaScript 변수에 캐시하는 것이 유익 할 수 있습니다. 다음 섹션에는 이러한 종류의 최적화에 대한 자세한 정보가 있습니다.</target>
        </trans-unit>
        <trans-unit id="4fc382e25e8b60dc9798023bb9fc0c80a890eae1" translate="yes" xml:space="preserve">
          <source>Note that if a control element is not listed here, it is because it uses a plain &lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption&lt;/a&gt; object.</source>
          <target state="translated">여기에 컨트롤 요소가 없으면 일반 &lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption&lt;/a&gt; 개체를 사용하기 때문 입니다.</target>
        </trans-unit>
        <trans-unit id="638909dd931eb31d278af6a5bfc249abbe52309c" translate="yes" xml:space="preserve">
          <source>Note that if a file with the name</source>
          <target state="translated">이름이 파일 인 경우</target>
        </trans-unit>
        <trans-unit id="d6c1f11ba9215a49c80cbd5fe0a97a1d1ed0dc1e" translate="yes" xml:space="preserve">
          <source>Note that if a model is reset it should be considered that all information previously retrieved from it is invalid. This includes but is not limited to the &lt;a href=&quot;qabstractitemmodel#rowCount&quot;&gt;rowCount&lt;/a&gt;() and &lt;a href=&quot;qabstractitemmodel#columnCount&quot;&gt;columnCount&lt;/a&gt;(), &lt;a href=&quot;qabstractitemmodel#flags&quot;&gt;flags&lt;/a&gt;(), data retrieved through &lt;a href=&quot;qabstractitemmodel#data&quot;&gt;data&lt;/a&gt;(), and &lt;a href=&quot;qabstractitemmodel#roleNames&quot;&gt;roleNames&lt;/a&gt;().</source>
          <target state="translated">모델이 재설정되면 이전에 검색된 모든 정보가 유효하지 않은 것으로 간주됩니다. 여기에는 &lt;a href=&quot;qabstractitemmodel#rowCount&quot;&gt;rowCount&lt;/a&gt; () 및 &lt;a href=&quot;qabstractitemmodel#columnCount&quot;&gt;columnCount&lt;/a&gt; (), &lt;a href=&quot;qabstractitemmodel#flags&quot;&gt;플래그&lt;/a&gt; (), 데이터를 통해 검색된 &lt;a href=&quot;qabstractitemmodel#data&quot;&gt;데이터&lt;/a&gt; () 및 &lt;a href=&quot;qabstractitemmodel#roleNames&quot;&gt;roleNames&lt;/a&gt; ()가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="19447e21c9dc73f42725507321637f24c8d00ddb" translate="yes" xml:space="preserve">
          <source>Note that if a primitive element is not listed here, it is because it uses a plain &lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption&lt;/a&gt; object.</source>
          <target state="translated">기본 요소가 여기에 나열되지 않으면 일반 &lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption&lt;/a&gt; 오브젝트를 사용하기 때문 입니다.</target>
        </trans-unit>
        <trans-unit id="8f08f14db1ddd0b5de168013033cf81834d446bb" translate="yes" xml:space="preserve">
          <source>Note that if a widget is set as modified, all its ancestors will also be set as modified. However, if you call &lt;code&gt;setWindowModified(false)&lt;/code&gt; on a widget, this will not propagate to its parent because other children of the parent might have been modified.</source>
          <target state="translated">위젯이 수정 된 것으로 설정되면 모든 조상도 수정 된 것으로 설정됩니다. 그러나 위젯에서 &lt;code&gt;setWindowModified(false)&lt;/code&gt; 를 호출하면 부모의 다른 자식이 수정되었을 수 있으므로 부모로 전파되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5346b31bf872a13afaf4e80d1b751badec8a81a7" translate="yes" xml:space="preserve">
          <source>Note that if changeSize() is called after the spacer item has been added to a layout, it is necessary to invalidate the layout in order for the spacer item's new size to take effect.</source>
          <target state="translated">스페이서 항목을 레이아웃에 추가 한 후 changeSize ()를 호출하면 스페이서 항목의 새 크기를 적용하기 위해 레이아웃을 무효화해야합니다.</target>
        </trans-unit>
        <trans-unit id="1e5f70ec4faf03fb5dc641cf495524bb3ff723a7" translate="yes" xml:space="preserve">
          <source>Note that if creating a functions object via this method that the &lt;a href=&quot;qopenglcontext&quot;&gt;QOpenGLContext&lt;/a&gt; retains ownership of the object. This is to allow the object to be cached and shared.</source>
          <target state="translated">이 메소드를 통해 함수 오브젝트를 작성하는 경우 &lt;a href=&quot;qopenglcontext&quot;&gt;QOpenGLContext&lt;/a&gt; 는 오브젝트의 소유권을 보유합니다. 이는 객체를 캐시하고 공유 할 수 있도록하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="3d756d73a6152d5591e4cba5c19d3a655e7f4da9" translate="yes" xml:space="preserve">
          <source>Note that if sorting is enabled (see &lt;a href=&quot;qtableview#sortingEnabled-prop&quot;&gt;sortingEnabled&lt;/a&gt;) and</source>
          <target state="translated">정렬이 활성화 된 경우 ( &lt;a href=&quot;qtableview#sortingEnabled-prop&quot;&gt;sortingEnabled&lt;/a&gt; 참조 ) 및</target>
        </trans-unit>
        <trans-unit id="4c0752adf733e36ba441ebb96a9cf5ae4de08dc3" translate="yes" xml:space="preserve">
          <source>Note that if the [begin, end) range refers to an area that can store more than 32 bits per element, the elements will still be initialized with only 32 bits of data. Any other bits will be zero. To fill the range with 64 bit quantities, one can write:</source>
          <target state="translated">[시작, 끝) 범위가 요소 당 32 비트 이상을 저장할 수있는 영역을 참조하는 경우 요소는 여전히 32 비트의 데이터로 초기화됩니다. 다른 비트는 0이됩니다. 64 비트 수량으로 범위를 채우려면 다음과 같이 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d12c9b32c43f70abe4ec220bd3a207e01e738123" translate="yes" xml:space="preserve">
          <source>Note that if the destination manager is to facilitate saving and cross-referencing from any arbitrary manager, it internally must accommodate saving of arbitrary key value pairs since we cannot know the provider names before hand, nor can we know what structure the ids will be.</source>
          <target state="translated">대상 관리자가 임의의 관리자로부터 저장 및 상호 참조를 용이하게하려면 내부적으로 사전에 공급자 이름을 알 수 없으며 ID가 어떤 구조인지 알 수 없으므로 내부적으로 임의의 키 값 쌍을 저장할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="741a69da66d912b10a2f088adf44a629179f8a66" translate="yes" xml:space="preserve">
          <source>Note that if the documentation immediately precedes the function or class in the source code, then it does not need to have a topic. QDoc will assume that the documentation above the code is the documentation for that code.</source>
          <target state="translated">문서가 소스 코드에서 함수 또는 클래스 바로 앞에 오는 경우 주제가 필요하지 않습니다. QDoc은 코드 위의 문서가 해당 코드의 문서라고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="c6edd1af5eb2b2dd156d3366d90f34eafec5cd1a" translate="yes" xml:space="preserve">
          <source>Note that if the entity is unknown, the reader reports it through &lt;a href=&quot;qxmlcontenthandler#skippedEntity&quot;&gt;QXmlContentHandler::skippedEntity&lt;/a&gt;() and not through this function.</source>
          <target state="translated">엔티티를 알 수없는 경우 리더는 이 함수가 아닌 &lt;a href=&quot;qxmlcontenthandler#skippedEntity&quot;&gt;QXmlContentHandler :: skippedEntity&lt;/a&gt; ()를 통해이를보고합니다.</target>
        </trans-unit>
        <trans-unit id="f343e94eccc7199c3315a074d3f87a85f8791ac2" translate="yes" xml:space="preserve">
          <source>Note that if the event is a multiple-key compressed event that is partly due to auto-repeat, this function could return either true or false indeterminately.</source>
          <target state="translated">이벤트가 부분적으로 자동 반복으로 인한 다중 키 압축 이벤트 인 경우이 함수는 true 또는 false를 확실하게 리턴 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cef7297e974a15ccaf6fbaee43930a2ccc59c6d7" translate="yes" xml:space="preserve">
          <source>Note that if the item is being moved, this property holds the index that the item is moving to, not from.</source>
          <target state="translated">항목을 이동하는 경우이 속성은 항목이 아닌 이동하는 색인을 보유합니다.</target>
        </trans-unit>
        <trans-unit id="69c0ccd401b1b617a8ae931aa71b7f6bcb063261" translate="yes" xml:space="preserve">
          <source>Note that if the logicalDpiX() doesn't equal the &lt;a href=&quot;qpaintdevice#physicalDpiX&quot;&gt;physicalDpiX&lt;/a&gt;(), the corresponding &lt;a href=&quot;qpaintengine&quot;&gt;QPaintEngine&lt;/a&gt; must handle the resolution mapping.</source>
          <target state="translated">logicalDpiX ()가 &lt;a href=&quot;qpaintdevice#physicalDpiX&quot;&gt;physicalDpiX&lt;/a&gt; ()와 &lt;a href=&quot;qpaintengine&quot;&gt;같지&lt;/a&gt; 않으면 해당 QPaintEngine 이 해상도 매핑을 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="a29e305295b0a56506ba753dd028ac493bc192e6" translate="yes" xml:space="preserve">
          <source>Note that if the logicalDpiY() doesn't equal the &lt;a href=&quot;qpaintdevice#physicalDpiY&quot;&gt;physicalDpiY&lt;/a&gt;(), the corresponding &lt;a href=&quot;qpaintengine&quot;&gt;QPaintEngine&lt;/a&gt; must handle the resolution mapping.</source>
          <target state="translated">logicalDpiY ()가 &lt;a href=&quot;qpaintdevice#physicalDpiY&quot;&gt;physicalDpiY&lt;/a&gt; ()와 &lt;a href=&quot;qpaintengine&quot;&gt;같지&lt;/a&gt; 않으면 해당 QPaintEngine 이 해상도 매핑을 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="cfde6b0e09e2851af02c6874b5e1c96035f01bd0" translate="yes" xml:space="preserve">
          <source>Note that if the physicalDpiX() doesn't equal the &lt;a href=&quot;qpaintdevice#logicalDpiX&quot;&gt;logicalDpiX&lt;/a&gt;(), the corresponding &lt;a href=&quot;qpaintengine&quot;&gt;QPaintEngine&lt;/a&gt; must handle the resolution mapping.</source>
          <target state="translated">physicalDpiX ()가 &lt;a href=&quot;qpaintdevice#logicalDpiX&quot;&gt;logicalDpiX&lt;/a&gt; ()와 &lt;a href=&quot;qpaintengine&quot;&gt;같지&lt;/a&gt; 않으면 해당 QPaintEngine 이 해상도 매핑을 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="29d67bdb2fe2911f9536eda5e4ec782acbd46127" translate="yes" xml:space="preserve">
          <source>Note that if the physicalDpiY() doesn't equal the &lt;a href=&quot;qpaintdevice#logicalDpiY&quot;&gt;logicalDpiY&lt;/a&gt;(), the corresponding &lt;a href=&quot;qpaintengine&quot;&gt;QPaintEngine&lt;/a&gt; must handle the resolution mapping.</source>
          <target state="translated">physicalDpiY ()가 &lt;a href=&quot;qpaintdevice#logicalDpiY&quot;&gt;logicalDpiY&lt;/a&gt; ()와 &lt;a href=&quot;qpaintengine&quot;&gt;같지&lt;/a&gt; 않으면 해당 QPaintEngine 이 해상도 매핑을 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="9f488157a26f9edd40a79b060c33bab470758daf" translate="yes" xml:space="preserve">
          <source>Note that if the source is a local file, the status will initially be Ready (or Error). While there will be no onStatusChanged signal in that case, the onLoaded will still be invoked.</source>
          <target state="translated">소스가 로컬 파일 인 경우 상태는 처음에 준비 (또는 오류)입니다. 이 경우에는 onStatusChanged 신호가 없지만 onLoaded는 계속 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="e7cd4703690030742475f046adc16b5b7ecaaa4f" translate="yes" xml:space="preserve">
          <source>Note that if the text does not fit in the bounding rectangle it will be abruptly chopped.</source>
          <target state="translated">텍스트가 경계 사각형에 맞지 않으면 갑자기 잘립니다.</target>
        </trans-unit>
        <trans-unit id="17323b153a52168d5f0cadbf730201f426d20354" translate="yes" xml:space="preserve">
          <source>Note that if the text encoding set when connecting to the database is not the same as in the database, problems with transliteration might arise.</source>
          <target state="translated">데이터베이스에 연결할 때 설정된 텍스트 인코딩이 데이터베이스와 동일하지 않으면 음역에 문제가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce840200463e853f3b7b4873d4c522f8f65d350f" translate="yes" xml:space="preserve">
          <source>Note that if there are still &lt;a href=&quot;qdbusconnection&quot;&gt;QDBusConnection&lt;/a&gt; objects associated with the same connection, the connection will not be closed until all references are dropped. However, no further references can be created using the &lt;a href=&quot;qdbusconnection&quot;&gt;QDBusConnection&lt;/a&gt; constructor.</source>
          <target state="translated">동일한 연결과 연관된 &lt;a href=&quot;qdbusconnection&quot;&gt;QDBusConnection&lt;/a&gt; 오브젝트 가 여전히 있으면 모든 참조가 삭제 될 때까지 연결이 닫히지 않습니다. 그러나 &lt;a href=&quot;qdbusconnection&quot;&gt;QDBusConnection&lt;/a&gt; 생성자를 사용하여 추가 참조를 작성할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="262614ed4eb12cee45670955f7687c97f8bf6ca9" translate="yes" xml:space="preserve">
          <source>Note that if there is a validator set on the line edit, the &lt;a href=&quot;qlineedit#returnPressed&quot;&gt;returnPressed&lt;/a&gt;()/&lt;a href=&quot;qlineedit#editingFinished&quot;&gt;editingFinished&lt;/a&gt;() signals will only be emitted if the validator returns &lt;a href=&quot;qvalidator#State-enum&quot;&gt;QValidator::Acceptable&lt;/a&gt;.</source>
          <target state="translated">라인 편집에 유효성 검사기가 설정되어 &lt;a href=&quot;qlineedit#returnPressed&quot;&gt;있으면 returnPressed&lt;/a&gt; () / &lt;a href=&quot;qlineedit#editingFinished&quot;&gt;editingFinished&lt;/a&gt; () 신호는 유효성 검사기가 &lt;a href=&quot;qvalidator#State-enum&quot;&gt;QValidator :: Acceptable을&lt;/a&gt; 반환하는 경우에만 방출됩니다 .</target>
        </trans-unit>
        <trans-unit id="43ee271126f23dce62d77de4530a79039bc819ec" translate="yes" xml:space="preserve">
          <source>Note that if this &lt;a href=&quot;qjsvalue&quot;&gt;QJSValue&lt;/a&gt; is an object, calling this function has side effects on the script engine, since the engine will call the object's toString() function (and possibly valueOf()) in an attempt to convert the object to a primitive value (possibly resulting in an uncaught script exception).</source>
          <target state="translated">이 &lt;a href=&quot;qjsvalue&quot;&gt;QJSValue&lt;/a&gt; 가 객체 인 경우 엔진이 객체를 원시 값으로 변환하려고 시도 할 때 엔진이 객체의 toString () 함수 (및 valueOf ())를 호출하기 때문에이 함수를 호출하면 스크립트 엔진에 부작용이 있습니다. 캐치되지 않은 스크립트 예외가 발생할 수 있습니다).</target>
        </trans-unit>
        <trans-unit id="31ec4c2a1f54a2caf96d230c7c3ed5816d5ff9b3" translate="yes" xml:space="preserve">
          <source>Note that if this &lt;a href=&quot;qjsvalue&quot;&gt;QJSValue&lt;/a&gt; is an object, calling this function has side effects on the script engine, since the engine will call the object's valueOf() function (and possibly &lt;a href=&quot;qjsvalue#toString&quot;&gt;toString&lt;/a&gt;()) in an attempt to convert the object to a primitive value (possibly resulting in an uncaught script exception).</source>
          <target state="translated">이 경우 참고 것을 &lt;a href=&quot;qjsvalue&quot;&gt;QJSValue이&lt;/a&gt; 객체가 엔진 (아마도 및 객체의 valueOf () 함수를 호출하기 때문에,이 함수를 호출하면, 스크립트 엔진에 대한 부작용을 가지고 &lt;a href=&quot;qjsvalue#toString&quot;&gt;toString을&lt;/a&gt; (원시 값으로 개체를 변환하는 시도 ()) 캐치되지 않은 스크립트 예외가 발생할 수 있습니다).</target>
        </trans-unit>
        <trans-unit id="85c74bf3e1963ccca9996fae0b181d34183cb29c" translate="yes" xml:space="preserve">
          <source>Note that if this &lt;a href=&quot;qjsvalue&quot;&gt;QJSValue&lt;/a&gt; or the</source>
          <target state="translated">이 &lt;a href=&quot;qjsvalue&quot;&gt;QJSValue&lt;/a&gt; 또는</target>
        </trans-unit>
        <trans-unit id="dcba4e6d519ca6a5be152da39bd81b5b830a3fbe" translate="yes" xml:space="preserve">
          <source>Note that if you apply a &lt;a href=&quot;qmatrix&quot;&gt;QMatrix&lt;/a&gt; to a point defined in widget coordinates, the direction of the rotation will be clockwise because the y-axis points downwards.</source>
          <target state="translated">위젯 좌표에 정의 된 점에 &lt;a href=&quot;qmatrix&quot;&gt;QMatrix&lt;/a&gt; 를 적용 하면 y 축이 아래쪽을 향하기 때문에 회전 방향이 시계 방향이됩니다.</target>
        </trans-unit>
        <trans-unit id="79b7fc68d7c450da0aa0fe2c3d68264b44395c65" translate="yes" xml:space="preserve">
          <source>Note that if you apply a &lt;a href=&quot;qtransform&quot;&gt;QTransform&lt;/a&gt; to a point defined in widget coordinates, the direction of the rotation will be clockwise because the y-axis points downwards.</source>
          <target state="translated">위젯 좌표에 정의 된 점에 &lt;a href=&quot;qtransform&quot;&gt;QTransform&lt;/a&gt; 을 적용 하면 y 축이 아래쪽을 향하기 때문에 회전 방향이 시계 방향이됩니다.</target>
        </trans-unit>
        <trans-unit id="d502d17a0c45623bd56526d695c1c74f90ed8ff9" translate="yes" xml:space="preserve">
          <source>Note that if you are attempting to join an IPv4 group, your socket must not be bound using IPv6 (or in dual mode, using &lt;a href=&quot;qhostaddress#SpecialAddress-enum&quot;&gt;QHostAddress::Any&lt;/a&gt;). You must use &lt;a href=&quot;qhostaddress#SpecialAddress-enum&quot;&gt;QHostAddress::AnyIPv4&lt;/a&gt; instead.</source>
          <target state="translated">IPv4 그룹에 참여하려는 경우 소켓은 IPv6 (또는 &lt;a href=&quot;qhostaddress#SpecialAddress-enum&quot;&gt;QHostAddress :: Any를&lt;/a&gt; 사용하는 이중 모드)을 사용하여 바인드되어서는 안됩니다 . 당신은 사용해야합니다 &lt;a href=&quot;qhostaddress#SpecialAddress-enum&quot;&gt;QHostAddress :: AnyIPv4을&lt;/a&gt; 대신.</target>
        </trans-unit>
        <trans-unit id="350f58652ed28288f241bac209a37a31c0e37559" translate="yes" xml:space="preserve">
          <source>Note that if you call this function, you need to do so</source>
          <target state="translated">이 함수를 호출하면 그렇게해야합니다.</target>
        </trans-unit>
        <trans-unit id="8ec1c17deb82e766ddb593e203b068b097108dc9" translate="yes" xml:space="preserve">
          <source>Note that if you change the value of a property using the &lt;a href=&quot;qdesignerpropertysheetextension#setProperty&quot;&gt;QDesignerPropertySheetExtension::setProperty&lt;/a&gt;() function, the undo stack is not updated. To ensure that a property's value can be reverted using the undo stack, you must use the &lt;a href=&quot;qdesignerformwindowcursorinterface#setProperty&quot;&gt;QDesignerFormWindowCursorInterface::setProperty&lt;/a&gt;() function, or its buddy &lt;a href=&quot;qdesignerformwindowcursorinterface#setWidgetProperty&quot;&gt;setWidgetProperty()&lt;/a&gt;, instead.</source>
          <target state="translated">&lt;a href=&quot;qdesignerpropertysheetextension#setProperty&quot;&gt;QDesignerPropertySheetExtension :: setProperty&lt;/a&gt; () 함수를 사용하여 속성 값을 변경 하면 실행 취소 스택이 업데이트되지 않습니다. 실행 취소 스택을 사용하여 속성 값을 되돌리려면 &lt;a href=&quot;qdesignerformwindowcursorinterface#setProperty&quot;&gt;QDesignerFormWindowCursorInterface :: setProperty&lt;/a&gt; () 함수 또는 그 친구 인 &lt;a href=&quot;qdesignerformwindowcursorinterface#setWidgetProperty&quot;&gt;setWidgetProperty ()&lt;/a&gt; 를 대신 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="5c3c8287eec96e42400d79f073baf18536788e56" translate="yes" xml:space="preserve">
          <source>Note that if you have merged multiple columns and rows into one cell, you will not be able to split the merged cell into new cells spanning over more than one row or column. To be able to split cells spanning over several rows and columns you need to do this over several iterations.</source>
          <target state="translated">여러 열과 행을 하나의 셀로 병합 한 경우 병합 된 셀을 둘 이상의 행이나 열에 걸쳐있는 새 셀로 분할 할 수 없습니다. 여러 행과 열에 걸쳐있는 셀을 분할하려면 여러 번 반복하여이 작업을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="3994b18aaa7b6b61d0f1c66e538d4afa4f4158b0" translate="yes" xml:space="preserve">
          <source>Note that if you need to monitor both reads and writes for the same file descriptor, you must create two socket notifiers. Note also that it is not possible to install two socket notifiers of the same type (Read, Write, Exception) on the same socket.</source>
          <target state="translated">동일한 파일 디스크립터에 대한 읽기 및 쓰기를 모두 모니터해야하는 경우 두 개의 소켓 알리미를 작성해야합니다. 또한 동일한 소켓에 동일한 유형의 두 개의 소켓 알리미 (읽기, 쓰기, 예외)를 설치할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="71f133119fd7d20d5e3212539c6afdacaffbecdc" translate="yes" xml:space="preserve">
          <source>Note that if you require decimal values you will need to set the &lt;a href=&quot;qml-qtquick-controls-spinbox#decimals-prop&quot;&gt;decimals&lt;/a&gt; to a non 0 value.</source>
          <target state="translated">소수점 값이 필요한 경우 &lt;a href=&quot;qml-qtquick-controls-spinbox#decimals-prop&quot;&gt;소수점&lt;/a&gt; 을 0이 아닌 값 으로 설정해야 합니다.</target>
        </trans-unit>
        <trans-unit id="9aec82bfd39aaa480f7a47199a421213df02f772" translate="yes" xml:space="preserve">
          <source>Note that if you specify a two digit year, it will be interpreted to be in the century in which the date time edit was initialized. The default century is the 21 (2000-2099).</source>
          <target state="translated">두 자리 연도를 지정하면 날짜 시간 편집이 초기화 된 세기로 해석됩니다. 기본 세기는 21 (2000-2099)입니다.</target>
        </trans-unit>
        <trans-unit id="a80b101c8f2e709931bcf80e8de0eaca7f502048" translate="yes" xml:space="preserve">
          <source>Note that if you use this class but find you are calling &lt;a href=&quot;qexplicitlyshareddatapointer#detach&quot;&gt;detach&lt;/a&gt;() a lot, you probably should be using &lt;a href=&quot;qshareddatapointer&quot;&gt;QSharedDataPointer&lt;/a&gt; instead.</source>
          <target state="translated">이 클래스를 사용하지만 &lt;a href=&quot;qexplicitlyshareddatapointer#detach&quot;&gt;detach&lt;/a&gt; ()를 많이 호출 하는 경우 &lt;a href=&quot;qshareddatapointer&quot;&gt;QSharedDataPointer를&lt;/a&gt; 대신 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="7fc7c2da823a8d26a0981c186b0e7a0573d89ddf" translate="yes" xml:space="preserve">
          <source>Note that if you want to iterate over the list, you should iterate over a copy, e.g.</source>
          <target state="translated">목록을 반복하려면 사본을 반복해야합니다.</target>
        </trans-unit>
        <trans-unit id="4585ac52c607286c0d4e6c4d682fb350463e8c38" translate="yes" xml:space="preserve">
          <source>Note that if you want to use a custom data type in an item view drag and drop operation, you must register it as a Qt &lt;a href=&quot;qmetatype&quot;&gt;meta type&lt;/a&gt;, using the &lt;a href=&quot;qmetatype#Q_DECLARE_METATYPE&quot;&gt;Q_DECLARE_METATYPE&lt;/a&gt;() macro, and implement stream operators for it. The stream operators must then be registered with the &lt;a href=&quot;qmetatype#qRegisterMetaTypeStreamOperators&quot;&gt;qRegisterMetaTypeStreamOperators&lt;/a&gt;() function.</source>
          <target state="translated">항목보기 끌어서 놓기 조작에서 사용자 정의 데이터 유형을 사용하려면 &lt;a href=&quot;qmetatype#Q_DECLARE_METATYPE&quot;&gt;Q_DECLARE_METATYPE&lt;/a&gt; () 매크로를 사용하여 Qt &lt;a href=&quot;qmetatype&quot;&gt;메타 유형&lt;/a&gt; 으로 등록하고 스트림 연산자를 구현해야합니다. 그런 다음 스트림 연산자는 &lt;a href=&quot;qmetatype#qRegisterMetaTypeStreamOperators&quot;&gt;qRegisterMetaTypeStreamOperators&lt;/a&gt; () 함수 로 등록해야합니다 .</target>
        </trans-unit>
        <trans-unit id="c8ed0e048c6046a1e9b38bfa761a545a371ccf57" translate="yes" xml:space="preserve">
          <source>Note that in general regexps cannot be used to check for balanced brackets or tags. For example, a regexp can be written to match an opening html &lt;code&gt;&amp;lt;b&amp;gt;&lt;/code&gt; and its closing &lt;code&gt;&amp;lt;/b&amp;gt;&lt;/code&gt;, if the &lt;code&gt;&amp;lt;b&amp;gt;&lt;/code&gt; tags are not nested, but if the &lt;code&gt;&amp;lt;b&amp;gt;&lt;/code&gt; tags are nested, that same regexp will match an opening &lt;code&gt;&amp;lt;b&amp;gt;&lt;/code&gt; tag with the wrong closing &lt;code&gt;&amp;lt;/b&amp;gt;&lt;/code&gt;. For the fragment &lt;code&gt;&amp;lt;b&amp;gt;bold &amp;lt;b&amp;gt;bolder&amp;lt;/b&amp;gt;&amp;lt;/b&amp;gt;&lt;/code&gt;, the first &lt;code&gt;&amp;lt;b&amp;gt;&lt;/code&gt; would be matched with the first &lt;code&gt;&amp;lt;/b&amp;gt;&lt;/code&gt;, which is not correct. However, it is possible to write a regexp that will match nested brackets or tags correctly, but only if the number of nesting levels is fixed and known. If the number of nesting levels is not fixed and known, it is impossible to write a regexp that will not fail.</source>
          <target state="translated">일반적으로 정규 표현식을 사용하여 대괄호 또는 태그를 확인할 수는 없습니다. 예를 들면, 정규식은 개구 HTML에 맞게 기록 될 수있다 &lt;code&gt;&amp;lt;b&amp;gt;&lt;/code&gt; 와 폐쇄 &lt;code&gt;&amp;lt;/b&amp;gt;&lt;/code&gt; 을 상기 경우 &lt;code&gt;&amp;lt;b&amp;gt;&lt;/code&gt; 태그는 중첩되지 않고있는 경우 &lt;code&gt;&amp;lt;b&amp;gt;&lt;/code&gt; 태그는 중첩되고, 동일한 정규 표현식은 일치하는 것으로 개구 &lt;code&gt;&amp;lt;b&amp;gt;&lt;/code&gt; 잘못된 닫는 태그 &lt;code&gt;&amp;lt;/b&amp;gt;&lt;/code&gt; . &lt;code&gt;&amp;lt;b&amp;gt;bold &amp;lt;b&amp;gt;bolder&amp;lt;/b&amp;gt;&amp;lt;/b&amp;gt;&lt;/code&gt; 단편의 경우 첫 번째 &lt;code&gt;&amp;lt;b&amp;gt;&lt;/code&gt; 는 첫 번째 &amp;lt;b&amp;gt; 와 일치합니다 &lt;code&gt;&amp;lt;/b&amp;gt;&lt;/code&gt; 잘못되었습니다. 그러나 중첩 된 대괄호 나 태그와 올바르게 일치하는 정규 표현식을 작성할 수 있지만 중첩 수준의 수가 고정되어 알려진 경우에만 가능합니다. 중첩 수준의 수가 고정되어 있고 알려지지 않은 경우 실패하지 않는 정규식을 작성할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ae596454332ebd9b7d7a5f2ada16eb415528c1a5" translate="yes" xml:space="preserve">
          <source>Note that in order for the interpolation to work with a &lt;a href=&quot;qeasingcurve&quot;&gt;QEasingCurve&lt;/a&gt; that return a value smaller than 0 or larger than 1 (such as &lt;a href=&quot;qeasingcurve#Type-enum&quot;&gt;QEasingCurve::InBack&lt;/a&gt;) you should make sure that it can extrapolate. If the semantic of the datatype does not allow extrapolation this function should handle that gracefully.</source>
          <target state="translated">보간 이 0보다 작거나 1보다 큰 값 (예 : &lt;a href=&quot;qeasingcurve#Type-enum&quot;&gt;QEasingCurve :: InBack&lt;/a&gt; ) 을 리턴 하는 &lt;a href=&quot;qeasingcurve&quot;&gt;QEasingCurve&lt;/a&gt; 와 함께 작동 하려면 외삽이 가능한지 확인해야합니다. 데이터 유형의 시맨틱이 외삽을 허용하지 않는 경우이 함수는이를 적절하게 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="66b09e1429a4d031da74af48fcd7350b3ecf29c3" translate="yes" xml:space="preserve">
          <source>Note that in order to draw a bitmap or pixmap transparently, you must use &lt;a href=&quot;qpixmap#setMask&quot;&gt;QPixmap::setMask&lt;/a&gt;().</source>
          <target state="translated">비트 맵 또는 픽스맵을 투명하게 그리려면 &lt;a href=&quot;qpixmap#setMask&quot;&gt;QPixmap :: setMask&lt;/a&gt; () 를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="2aa7dfd22db0db2a9f9b46546a1e0ca403352b9f" translate="yes" xml:space="preserve">
          <source>Note that in some circumstances disabling a Transition may cause an alternative Transition to be used in its place. In the following example, although the first Transition has been set to animate changes from &quot;state1&quot; to &quot;state2&quot;, this transition has been disabled by setting &lt;code&gt;enabled&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt;, so any such state change will actually be animated by the second Transition instead.</source>
          <target state="translated">경우에 따라 전환을 비활성화하면 대체 전환이 대신 사용될 수 있습니다. 다음 예제에서는 첫 번째 전환이 &quot;state1&quot;에서 &quot;state2&quot;로 변경 사항을 애니메이션으로 설정했지만,이 전환은 &lt;code&gt;enabled&lt;/code&gt; 를 &lt;code&gt;false&lt;/code&gt; 로 설정 하여 비활성화 되었으므로 이러한 상태 변경은 실제로 두 번째 전환에 의해 애니메이션됩니다.</target>
        </trans-unit>
        <trans-unit id="8e4847690d899f38830b7c79b398d6615b761f3b" translate="yes" xml:space="preserve">
          <source>Note that in this case, the &lt;code&gt;index&lt;/code&gt; parameter passed to &lt;a href=&quot;qml-qtquick-controls-menu#insertItem-method&quot;&gt;insertItem()&lt;/a&gt; is relative to the position of the &lt;a href=&quot;qml-qtqml-instantiator&quot;&gt;Instantiator&lt;/a&gt; in the menu, as opposed to absolute position in the menu.</source>
          <target state="translated">이 경우 &lt;a href=&quot;qml-qtquick-controls-menu#insertItem-method&quot;&gt;insertItem ()에&lt;/a&gt; 전달 된 &lt;code&gt;index&lt;/code&gt; 매개 변수 는 메뉴의 절대 위치가 아니라 메뉴 의 &lt;a href=&quot;qml-qtqml-instantiator&quot;&gt;인스턴스 화기&lt;/a&gt; 위치에 상대적 입니다.</target>
        </trans-unit>
        <trans-unit id="014cf3f8d0a544c5c6b5c5587112f651997b87ae" translate="yes" xml:space="preserve">
          <source>Note that individual tabs may be disabled even if the tab bar is not. The tab will be active if the tab bar is active.</source>
          <target state="translated">탭 막대가 아닌 경우에도 개별 탭이 비활성화 될 수 있습니다. 탭 표시 줄이 활성화되어 있으면 탭이 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="c04acf61f478879792345199d49305b0bf96b5c4" translate="yes" xml:space="preserve">
          <source>Note that instead of exporting each custom widget plugin using the &lt;a href=&quot;#Q_PLUGIN_METADATA&quot;&gt;Q_PLUGIN_METADATA&lt;/a&gt;() macro, you export the entire collection. The &lt;a href=&quot;#Q_PLUGIN_METADATA&quot;&gt;Q_PLUGIN_METADATA&lt;/a&gt;() macro ensures that</source>
          <target state="translated">&lt;a href=&quot;#Q_PLUGIN_METADATA&quot;&gt;Q_PLUGIN_METADATA&lt;/a&gt; () 매크로를 사용하여 각 사용자 정의 위젯 플러그인을 내보내는 대신 전체 콜렉션을 내 보냅니다. &lt;a href=&quot;#Q_PLUGIN_METADATA&quot;&gt;Q_PLUGIN_METADATA&lt;/a&gt; () 매크로 것을 보장</target>
        </trans-unit>
        <trans-unit id="edef8e308d34fbdfa63e768f7afdf296c9279678" translate="yes" xml:space="preserve">
          <source>Note that invisible widgets have a size of 0.</source>
          <target state="translated">보이지 않는 위젯의 크기는 0입니다.</target>
        </trans-unit>
        <trans-unit id="c8fd89dda6269cf97aaafa1ab026a910f9508b1e" translate="yes" xml:space="preserve">
          <source>Note that is perfectly reasonable in some circumstances to overwrite bindings. Any message generated by the QML engine should be treated as a diagnostic aid, and not necessarily as evidence of a problem without further investigation.</source>
          <target state="translated">일부 환경에서는 바인딩을 덮어 쓰는 것이 합리적입니다. QML 엔진에 의해 생성 된 모든 메시지는 진단 보조 수단으로 취급되어야하며 추가 조사없이 문제의 증거가 될 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="1dd456ec5b64e9d8aced115ec7eb071d56172f72" translate="yes" xml:space="preserve">
          <source>Note that it does &lt;b&gt;not&lt;/b&gt; delete the text of the selection.</source>
          <target state="translated">선택 텍스트는 삭제 되지 &lt;b&gt;않습니다&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="3d754814a4e9a2a4d9f025eb47f0613c43220c7f" translate="yes" xml:space="preserve">
          <source>Note that it does not refer to the total number of search results available in the backend. The total number of search results is not currently supported by the API.</source>
          <target state="translated">백엔드에서 사용 가능한 총 검색 결과 수를 나타내지 않습니다. 총 검색 결과 수는 현재 API에서 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="76ffa54c7f0fb2b552d86c0b8b3a902008a62b73" translate="yes" xml:space="preserve">
          <source>Note that it is always possible to programmatically insert duplicate items into the combobox.</source>
          <target state="translated">프로그래밍 방식으로 중복 항목을 콤보 상자에 삽입하는 것이 항상 가능합니다.</target>
        </trans-unit>
        <trans-unit id="a03b1490e20d880eb4a4e7ca3d5e5bf21192e174" translate="yes" xml:space="preserve">
          <source>Note that it is equivalent to the following:</source>
          <target state="translated">다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0e3fe1406f8185fc21aacff1f60b868400445c93" translate="yes" xml:space="preserve">
          <source>Note that it is faster to get and set properties using &lt;a href=&quot;qobject#property&quot;&gt;QObject::property&lt;/a&gt;() and &lt;a href=&quot;qobject#setProperty&quot;&gt;QObject::setProperty&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qobject#property&quot;&gt;QObject :: property&lt;/a&gt; () 및 &lt;a href=&quot;qobject#setProperty&quot;&gt;QObject :: setProperty&lt;/a&gt; ()를 사용하여 속성을 가져오고 설정하는 것이 더 빠릅니다 .</target>
        </trans-unit>
        <trans-unit id="45f5cd7292cd3f5c99451db94e661001a03c2bb0" translate="yes" xml:space="preserve">
          <source>Note that it is generally not recommended to override this.</source>
          <target state="translated">일반적으로 이것을 무시하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="9994389808e10a69537039100c72675792686a29" translate="yes" xml:space="preserve">
          <source>Note that it is meaningless to compare two instances of &lt;a href=&quot;qxmlname&quot;&gt;QXmlName&lt;/a&gt; that were created with different &lt;a href=&quot;qxmlnamepool&quot;&gt;name pools&lt;/a&gt;, but the attempt is not detected and the behavior is undefined.</source>
          <target state="translated">다른 &lt;a href=&quot;qxmlnamepool&quot;&gt;이름 풀로&lt;/a&gt; 작성된 &lt;a href=&quot;qxmlname&quot;&gt;QXmlName의&lt;/a&gt; 두 인스턴스를 비교하는 것은 의미가 없지만 시도는 감지되지 않으며 동작은 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5f7fbfa363a05fe3dfa8cd5d6bc68451c187118d" translate="yes" xml:space="preserve">
          <source>Note that it is not necessary to keep the original &lt;a href=&quot;qdbuspendingcall&quot;&gt;QDBusPendingCall&lt;/a&gt; object around since &lt;a href=&quot;qdbuspendingcallwatcher&quot;&gt;QDBusPendingCallWatcher&lt;/a&gt; inherits from that class too.</source>
          <target state="translated">원래 유지할 필요가 없다고 주 &lt;a href=&quot;qdbuspendingcall&quot;&gt;QDBusPendingCall의&lt;/a&gt; 이후 개체 주위를 &lt;a href=&quot;qdbuspendingcallwatcher&quot;&gt;QDBusPendingCallWatcher의&lt;/a&gt; 너무 그 클래스에서 상속됩니다.</target>
        </trans-unit>
        <trans-unit id="90c0da1dda5fef40a6a9d98a2ed9a49f57a346b0" translate="yes" xml:space="preserve">
          <source>Note that it is not required to hold an open session in order to obtain the network interface state. A connected but closed session may be used to monitor network interfaces whereas an open and connected session object may prevent the network interface from being shut down.</source>
          <target state="translated">네트워크 인터페이스 상태를 얻기 위해 열린 세션을 유지할 필요는 없습니다. 연결되었지만 닫힌 세션은 네트워크 인터페이스를 모니터링하는 데 사용될 수 있지만 열려 있고 연결된 세션 개체는 네트워크 인터페이스가 종료되는 것을 방지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b70f4f23e90f384c5ea3b0155803a673b612222" translate="yes" xml:space="preserve">
          <source>Note that it is not usually necessary to call this function directly, as it will be implicitly called by &lt;a href=&quot;qwindow#show&quot;&gt;show&lt;/a&gt;(), &lt;a href=&quot;qwindow#visible-prop&quot;&gt;setVisible&lt;/a&gt;(), and other functions that require access to the platform resources.</source>
          <target state="translated">&lt;a href=&quot;qwindow#show&quot;&gt;show&lt;/a&gt; (), &lt;a href=&quot;qwindow#visible-prop&quot;&gt;setVisible&lt;/a&gt; () 및 플랫폼 리소스에 액세스해야하는 다른 함수에 의해 암시 적으로 호출되므로 일반적으로이 함수를 직접 호출 할 필요는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="044795d694e75e262f743accb2225dd2f2047c75" translate="yes" xml:space="preserve">
          <source>Note that it is safe to call destroy() on an object within that object. Objects are not destroyed the instant destroy() is called, but are cleaned up sometime between the end of that script block and the next frame (unless you specified a non-zero delay).</source>
          <target state="translated">해당 객체 내의 객체에서 destroy ()를 호출하는 것이 안전합니다. 객체는 파괴되지 않고 즉시 destroy ()가 호출되지만 스크립트 블록의 끝과 다음 프레임 사이에서 언젠가 정리됩니다 (0이 아닌 지연을 지정하지 않은 경우).</target>
        </trans-unit>
        <trans-unit id="1d0dc8bc1bd9ea87b26c8cd2bfd192657f6cc1db" translate="yes" xml:space="preserve">
          <source>Note that it is sometimes easier to configure a dock widget if it is added to a form before a layout is applied to the central widget. For example, it is possible to undock it and resize it, making it more convenient to add child widgets.</source>
          <target state="translated">레이아웃이 중앙 위젯에 적용되기 전에 독 위젯이 양식에 추가되는 경우 독 위젯을 구성하는 것이 더 쉬운 경우가 있습니다. 예를 들어, 도킹을 해제하고 크기를 조정하여 하위 위젯을 추가하는 것이 더 편리합니다.</target>
        </trans-unit>
        <trans-unit id="8c6950439738fd8cd8e665dd612aa5378d723440" translate="yes" xml:space="preserve">
          <source>Note that it is undefined behavior to reimplement &lt;a href=&quot;qabstractitemmodel#hasChildren&quot;&gt;QAbstractItemModel::hasChildren&lt;/a&gt; to return true for an index if that index has the Qt::ItemNeverHasChildren flag set.</source>
          <target state="translated">인덱스에 Qt :: ItemNeverHasChildren 플래그가 설정된 경우 인덱스에 대해 true를 반환하는 &lt;a href=&quot;qabstractitemmodel#hasChildren&quot;&gt;QAbstractItemModel :: hasChildren&lt;/a&gt; 을 다시 구현하는 것은 정의되지 않은 동작 입니다.</target>
        </trans-unit>
        <trans-unit id="178a1cf2aedf1ce043c81e5546961a3d4f7d52c1" translate="yes" xml:space="preserve">
          <source>Note that it is undefined behavior to report that a particular index hasChildren with this method if the same index has the flag &lt;a href=&quot;qt#ItemFlag-enum&quot;&gt;Qt::ItemNeverHasChildren&lt;/a&gt; set.</source>
          <target state="translated">동일한 인덱스에 플래그 &lt;a href=&quot;qt#ItemFlag-enum&quot;&gt;Qt :: ItemNeverHasChildren이&lt;/a&gt; 설정 되어있는 경우 특정 인덱스에이 메소드를 가진 childChildren 이 있다고보고하는 것은 정의되지 않은 동작 입니다.</target>
        </trans-unit>
        <trans-unit id="3ef290c88dc16648dd0d906fd9e3996628dbd5e4" translate="yes" xml:space="preserve">
          <source>Note that it is up to the widget to activate the action, for example by reimplementing mouse event handlers and calling &lt;a href=&quot;qaction#trigger&quot;&gt;QAction::trigger&lt;/a&gt;().</source>
          <target state="translated">마우스 이벤트 핸들러를 다시 구현하고 &lt;a href=&quot;qaction#trigger&quot;&gt;QAction :: trigger&lt;/a&gt; ()를 호출하는 등의 조치를 활성화하는 것은 위젯에 달려 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c3a503b2bd720fb23daae9d66f27f2e571147d7d" translate="yes" xml:space="preserve">
          <source>Note that it's perfectly reasonable for a library to register types to older versions than the actual version of the library. Indeed, it is normal for the new library to allow QML written to previous versions to continue to work, even if more advanced versions of some of its types are available.</source>
          <target state="translated">라이브러리가 실제 버전의 라이브러리보다 이전 버전에 유형을 등록하는 것이 합리적입니다. 실제로 새 라이브러리에서 일부 유형의 고급 버전을 사용할 수 있더라도 이전 버전으로 작성된 QML이 계속 작동하는 것이 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="0857371f3c04ced93f844f9eefaf9c9c8e01ee3d" translate="yes" xml:space="preserve">
          <source>Note that it's possible to squeeze the XPM variable a little bit by using an unusual declaration:</source>
          <target state="translated">특이한 선언을 사용하여 XPM 변수를 약간 짜낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f3b9a4c1772eba566baa9934da0af716117f8bea" translate="yes" xml:space="preserve">
          <source>Note that item dragging must be enabled in the view for dragging to work; see &lt;a href=&quot;qabstractitemview#dragEnabled-prop&quot;&gt;QAbstractItemView::dragEnabled&lt;/a&gt;.</source>
          <target state="translated">드래그가 작동하려면보기에서 항목 드래그를 활성화해야합니다. &lt;a href=&quot;qabstractitemview#dragEnabled-prop&quot;&gt;QAbstractItemView :: dragEnabled를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="172095200678d06c4918c5bfc7f4eb5204c75ccc" translate="yes" xml:space="preserve">
          <source>Note that items can be dropped into the top level of the model, but dragging is only enabled for valid items.</source>
          <target state="translated">아이템은 모델의 최상위 레벨에 놓을 수 있지만 드래그는 유효한 아이템에 대해서만 가능합니다.</target>
        </trans-unit>
        <trans-unit id="0ca11a203ca8aaa3b1d3b4d57d1c537a3a933b7d" translate="yes" xml:space="preserve">
          <source>Note that items in a Column can use the &lt;a href=&quot;qml-qtquick-positioner&quot;&gt;Positioner&lt;/a&gt; attached property to access more information about its position within the Column.</source>
          <target state="translated">열의 항목은 &lt;a href=&quot;qml-qtquick-positioner&quot;&gt;Positioner&lt;/a&gt; attached 속성을 사용하여 열 내의 위치에 대한 자세한 정보에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="55befcc16a0925c0f81b34f5adce462cd703af65" translate="yes" xml:space="preserve">
          <source>Note that items in a Row can use the &lt;a href=&quot;qml-qtquick-positioner&quot;&gt;Positioner&lt;/a&gt; attached property to access more information about its position within the Row.</source>
          <target state="translated">행의 항목은 &lt;a href=&quot;qml-qtquick-positioner&quot;&gt;Positioner&lt;/a&gt; attached 속성을 사용하여 행 내 위치에 대한 자세한 정보에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c1b59852db4fa29933ecc96aba78c3113d6cd262" translate="yes" xml:space="preserve">
          <source>Note that key events are only received for items that set the &lt;a href=&quot;qgraphicsitem#GraphicsItemFlag-enum&quot;&gt;ItemIsFocusable&lt;/a&gt; flag, and that have keyboard input focus.</source>
          <target state="translated">키 이벤트는 &lt;a href=&quot;qgraphicsitem#GraphicsItemFlag-enum&quot;&gt;ItemIsFocusable&lt;/a&gt; 플래그 를 설정하고 키보드 입력 포커스가 있는 항목에 대해서만 수신됩니다 .</target>
        </trans-unit>
        <trans-unit id="473a4f1d05c420468d738b00e7f26ca05db21503" translate="yes" xml:space="preserve">
          <source>Note that logging must have been started or the value of this property will be meaningless.</source>
          <target state="translated">로깅이 시작되었거나이 특성의 값은 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="c3d5d7cf0741edf09a82620a7543e312fdd7ccb1" translate="yes" xml:space="preserve">
          <source>Note that logical particles are not automatically rendered, you will need to have one or more &lt;a href=&quot;qml-qtquick-particles-particlepainter&quot;&gt;ParticlePainter&lt;/a&gt; elements visualizing them.</source>
          <target state="translated">논리 파티클은 자동으로 렌더링되지 않으므로 이를 시각화하는 하나 이상의 &lt;a href=&quot;qml-qtquick-particles-particlepainter&quot;&gt;ParticlePainter&lt;/a&gt; 요소 가 있어야 합니다.</target>
        </trans-unit>
        <trans-unit id="9c07830b9dab013575aa7bf01f12873edb367dce" translate="yes" xml:space="preserve">
          <source>Note that matrix multiplication is not commutative, i.e. a*b != b*a.</source>
          <target state="translated">행렬 곱셈은 순차적이지 않습니다. 즉 a * b! = b * a.</target>
        </trans-unit>
        <trans-unit id="1947c382d91d6d387c0924818c4231bade1bc0f9" translate="yes" xml:space="preserve">
          <source>Note that modifying this list with setServicesWatched() is an expensive operation. If you can, prefer to change it by way of &lt;a href=&quot;qdbusservicewatcher#addWatchedService&quot;&gt;addWatchedService&lt;/a&gt;() and &lt;a href=&quot;qdbusservicewatcher#removeWatchedService&quot;&gt;removeWatchedService&lt;/a&gt;().</source>
          <target state="translated">setServicesWatched ()로이 목록을 수정하면 많은 비용이 소요됩니다. 가능하면 &lt;a href=&quot;qdbusservicewatcher#addWatchedService&quot;&gt;addWatchedService&lt;/a&gt; () 및 &lt;a href=&quot;qdbusservicewatcher#removeWatchedService&quot;&gt;removeWatchedService&lt;/a&gt; () 를 통해 변경하는 것을 선호합니다 .</target>
        </trans-unit>
        <trans-unit id="d8b052ddd2b28b3097499ed0a8dac27c2ffd4aa0" translate="yes" xml:space="preserve">
          <source>Note that most of the time, you can use one of the constructors instead of begin(), and that &lt;a href=&quot;qpainter#end&quot;&gt;end&lt;/a&gt;() is automatically done at destruction.</source>
          <target state="translated">대부분의 경우 begin () 대신 생성자 중 하나를 사용할 수 있으며 &lt;a href=&quot;qpainter#end&quot;&gt;end&lt;/a&gt; ()는 자동으로 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="6b62ee01075b1fadb72e2f12d7d682fb0334f578" translate="yes" xml:space="preserve">
          <source>Note that most platforms require a pairing prior to connecting to the remote device. Otherwise the connection process may fail.</source>
          <target state="translated">대부분의 플랫폼은 원격 장치에 연결하기 전에 페어링이 필요합니다. 그렇지 않으면 연결 프로세스가 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="86fe514eddb3d068b2057d00d8fad0daec946b2c" translate="yes" xml:space="preserve">
          <source>Note that multiple QML documents can import &lt;code&gt;&quot;factorial.js&quot;&lt;/code&gt; and call the factorial and factorialCallCount functions that it provides. The state of the JavaScript import is shared across the QML documents which import it, and thus the return value of the factorialCallCount function may be non-zero when called within a QML document which never calls the factorial function.</source>
          <target state="translated">여러 QML 문서는 &lt;code&gt;&quot;factorial.js&quot;&lt;/code&gt; 를 가져 와서 제공하는 factorial 및 factorialCallCount 함수를 호출 할 수 있습니다. JavaScript 가져 오기 상태는이를 가져 오는 QML 문서에서 공유되므로 factorialCallCount 함수의 리턴 값은 factorial 함수를 호출하지 않는 QML 문서 내에서 호출 될 때 0이 아닐 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7db960726f88fb71ae7094c5dfd0d419814734e4" translate="yes" xml:space="preserve">
          <source>Note that multiple modules can be imported into the same namespace in the same way that multiple modules can be imported into the global namespace. For example:</source>
          <target state="translated">여러 개의 모듈을 전역 네임 스페이스로 가져올 수있는 것과 같은 방식으로 여러 개의 모듈을 동일한 네임 스페이스로 가져올 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f70ef22ca19e9551413a1063888d0c9f63c740da" translate="yes" xml:space="preserve">
          <source>Note that negative leading is ignored, it must be handled in the code using the text lines by letting the lines overlap.</source>
          <target state="translated">음의 선행은 무시되므로 행을 겹치게하여 텍스트 행을 사용하여 코드에서 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="69a2a56c9d8d93e92126e019689119ce8a45b57b" translate="yes" xml:space="preserve">
          <source>Note that no editor widgets are set up when the delegate is constructed. We only construct an editor widget when it is needed.</source>
          <target state="translated">델리게이트가 생성 될 때 편집기 위젯이 설정되지 않습니다. 필요한 경우에만 편집기 위젯을 구성합니다.</target>
        </trans-unit>
        <trans-unit id="056bb2a0f1eb0882ae87203fbd7b221c22b0c654" translate="yes" xml:space="preserve">
          <source>Note that no functions of the control are called.</source>
          <target state="translated">컨트롤의 기능은 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="85b82cc3d65c6ec49475ab50626000dbb32b7c81" translate="yes" xml:space="preserve">
          <source>Note that not all pixmaps will conform, in which case the returned pixmap is a plain copy.</source>
          <target state="translated">모든 픽스맵이 준수되는 것은 아니며 반환 된 픽스맵은 일반 사본입니다.</target>
        </trans-unit>
        <trans-unit id="13316a3020567da5899f78e5bfffa083824faf6b" translate="yes" xml:space="preserve">
          <source>Note that not all primitives use all of these flags, and that the flags may mean different things to different items.</source>
          <target state="translated">모든 프리미티브가 이러한 플래그를 모두 사용하는 것은 아니며 플래그는 항목마다 다른 것을 의미 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2fa67f67780e558e86642381d2f614fd1f7aba98" translate="yes" xml:space="preserve">
          <source>Note that objects cannot be individually added to or removed from the list once created; to modify the contents of a list, it must be reassigned to a new list.</source>
          <target state="translated">한 번 작성된 오브젝트는 목록에 개별적으로 추가하거나 제거 할 수 없습니다. 목록의 내용을 수정하려면 새 목록에 다시 할당해야합니다.</target>
        </trans-unit>
        <trans-unit id="f5a576825690b830885108256212dfd4f9090fc2" translate="yes" xml:space="preserve">
          <source>Note that on Mac OS X 10.3 (Panther), dynamic libraries cannot be unloaded.</source>
          <target state="translated">Mac OS X 10.3 (Panther)에서는 동적 라이브러리를 언로드 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="bd0da880e32abad642a2a9938c1336ba33bfff64" translate="yes" xml:space="preserve">
          <source>Note that on Windows and &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; custom paper sizes won't be reflected in the native page setup dialogs. Additionally, custom page margins set on a &lt;a href=&quot;qprinter&quot;&gt;QPrinter&lt;/a&gt; won't show in the native &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; page setup dialog.</source>
          <target state="translated">Windows 및 &lt;a href=&quot;internationalization#macos&quot;&gt;macOS에서&lt;/a&gt; 사용자 정의 용지 크기는 기본 페이지 설정 대화 상자에 반영되지 않습니다. 또한 &lt;a href=&quot;qprinter&quot;&gt;QPrinter에&lt;/a&gt; 설정된 사용자 정의 페이지 여백 은 기본 &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; 페이지 설정 대화 상자에 표시되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="25c5da08d0c5962f18d2343364afc7d08ac2feb3" translate="yes" xml:space="preserve">
          <source>Note that on some systems, this value will persist across reboots and on some it will not. Applications should not blindly depend on this fact without verifying the OS capabilities. In particular, on Linux systems, this ID is usually permanent and it matches the D-Bus machine ID, except for nodes without their own storage (replicated nodes).</source>
          <target state="translated">일부 시스템에서는이 값이 재부팅 후에도 유지되고 일부 시스템에서는 유지되지 않습니다. OS 기능을 확인하지 않고 애플리케이션이이 사실에 맹목적으로 의존해서는 안됩니다. 특히 Linux 시스템에서이 ID는 일반적으로 영구적이며 자체 스토리지가없는 노드 (복제 된 노드)를 제외하고 D-Bus 시스템 ID와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="7af4bdcdf60b2e34420d77afa5661e47c47c0503" translate="yes" xml:space="preserve">
          <source>Note that on systems that support system colors, the style's standard palette is not used. In particular, the Windows Vista and Mac styles do not use the standard palette, but make use of native theme engines. With these styles, you should not set the palette with &lt;a href=&quot;qapplication#setPalette&quot;&gt;QApplication::setPalette&lt;/a&gt;().</source>
          <target state="translated">시스템 색상을 지원하는 시스템에서는 스타일의 표준 팔레트가 사용되지 않습니다. 특히, Windows Vista 및 Mac 스타일은 표준 팔레트를 사용하지 않지만 기본 테마 엔진을 사용합니다. 이러한 스타일을 사용하면 &lt;a href=&quot;qapplication#setPalette&quot;&gt;QApplication :: setPalette&lt;/a&gt; ()로 팔레트를 설정하지 않아야합니다 .</target>
        </trans-unit>
        <trans-unit id="d8f83b0907014908753b595bf4b798092a00fe7b" translate="yes" xml:space="preserve">
          <source>Note that one network interface cannot be both broadcast-based and point-to-point.</source>
          <target state="translated">하나의 네트워크 인터페이스는 브로드 캐스트 기반 및 포인트 투 포인트가 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="42238f9e235502b13057c0dfb5d47fd4fae637f3" translate="yes" xml:space="preserve">
          <source>Note that only &lt;a href=&quot;qitemselectionmodel#SelectionFlag-enum&quot;&gt;QItemSelectionModel::Select&lt;/a&gt;, &lt;a href=&quot;qitemselectionmodel#SelectionFlag-enum&quot;&gt;QItemSelectionModel::Deselect&lt;/a&gt;, and &lt;a href=&quot;qitemselectionmodel#SelectionFlag-enum&quot;&gt;QItemSelectionModel::Toggle&lt;/a&gt; are supported.</source>
          <target state="translated">단지 참고 &lt;a href=&quot;qitemselectionmodel#SelectionFlag-enum&quot;&gt;QItemSelectionModel :: 선택&lt;/a&gt; , &lt;a href=&quot;qitemselectionmodel#SelectionFlag-enum&quot;&gt;QItemSelectionModel :: 선택을 취소&lt;/a&gt; 하고, &lt;a href=&quot;qitemselectionmodel#SelectionFlag-enum&quot;&gt;QItemSelectionModel :: 전환이&lt;/a&gt; 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="019a91b030a7adce406e921da4c19e56a2385765" translate="yes" xml:space="preserve">
          <source>Note that only &lt;a href=&quot;qmdisubwindow&quot;&gt;QMdiSubWindow&lt;/a&gt;s can be set as children of &lt;a href=&quot;qmdiarea&quot;&gt;QMdiArea&lt;/a&gt;; you cannot, for instance, write:</source>
          <target state="translated">오직주의 &lt;a href=&quot;qmdisubwindow&quot;&gt;QMdiSubWindow&lt;/a&gt; 의가의 자식으로 설정 될 수 &lt;a href=&quot;qmdiarea&quot;&gt;QMdiArea&lt;/a&gt; ; 예를 들어 다음과 같이 쓸 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e7521cb8b47b0e534d0429c4fecd792943d0515f" translate="yes" xml:space="preserve">
          <source>Note that only constructors that are declared with the &lt;a href=&quot;qobject#Q_INVOKABLE&quot;&gt;Q_INVOKABLE&lt;/a&gt; modifier are made available through the meta-object system.</source>
          <target state="translated">&lt;a href=&quot;qobject#Q_INVOKABLE&quot;&gt;Q_INVOKABLE&lt;/a&gt; 수정 자로 선언 된 생성자 만 메타 오브젝트 시스템을 통해 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="46b275c531122a8aabcaf3a48baf60fd5c98fd56" translate="yes" xml:space="preserve">
          <source>Note that only the Full form of the cookie can be parsed back into its original contents.</source>
          <target state="translated">쿠키의 전체 형식 만 원래 내용으로 다시 구문 분석 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f89d93871ba9550ac373f17887c88ee326f6f93b" translate="yes" xml:space="preserve">
          <source>Note that only the states the underlying paint engine changes will be reset to their respective default states. The states we reset may change from release to release. The following states are currently reset in the OpenGL 2 engine:</source>
          <target state="translated">기본 페인트 엔진 변경 상태 만 해당 기본 상태로 재설정됩니다. 재설정 한 상태는 릴리스마다 변경 될 수 있습니다. 다음 상태는 현재 OpenGL 2 엔진에서 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="18a00d29f533fc4c86f3fe70c6fa8c630c895ca2" translate="yes" xml:space="preserve">
          <source>Note that only values that are marked as generated will be updated. The generated flag can be set with &lt;a href=&quot;qsqlrecord#setGenerated&quot;&gt;QSqlRecord::setGenerated&lt;/a&gt;() and checked with &lt;a href=&quot;qsqlrecord#isGenerated&quot;&gt;QSqlRecord::isGenerated&lt;/a&gt;().</source>
          <target state="translated">생성 된 것으로 표시된 값만 업데이트됩니다. 생성 된 플래그는 &lt;a href=&quot;qsqlrecord#setGenerated&quot;&gt;QSqlRecord :: setGenerated&lt;/a&gt; () 로 설정 하고 &lt;a href=&quot;qsqlrecord#isGenerated&quot;&gt;QSqlRecord :: isGenerated&lt;/a&gt; ()로 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a01f29a1a6f0606343422579ba1e16c360a5991" translate="yes" xml:space="preserve">
          <source>Note that only values that have the generated-flag set are updated. The generated-flag can be set with &lt;a href=&quot;qsqlrecord#setGenerated&quot;&gt;QSqlRecord::setGenerated&lt;/a&gt;() and tested with &lt;a href=&quot;qsqlrecord#isGenerated&quot;&gt;QSqlRecord::isGenerated&lt;/a&gt;().</source>
          <target state="translated">생성 된 플래그가 설정된 값만 업데이트됩니다. 생성 된 플래그가 설정 될 수있다 &lt;a href=&quot;qsqlrecord#setGenerated&quot;&gt;: QSqlRecord setGenerated&lt;/a&gt; 와 () 및 시험 &lt;a href=&quot;qsqlrecord#isGenerated&quot;&gt;QSqlRecord :: isGenerated&lt;/a&gt; ().</target>
        </trans-unit>
        <trans-unit id="5a36357155ce3252c682c2eb197b9b80db2befb8" translate="yes" xml:space="preserve">
          <source>Note that only visible items can grab keyboard input. Calling grabKeyboard() on an invisible item has no effect.</source>
          <target state="translated">보이는 항목 만 키보드 입력을 잡을 수 있습니다. 보이지 않는 항목에서 grabKeyboard ()를 호출해도 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="f8c662b7df88ec37d3af44df064acbfc85cf07c2" translate="yes" xml:space="preserve">
          <source>Note that only visible items can grab mouse input. Calling grabMouse() on an invisible item has no effect.</source>
          <target state="translated">보이는 항목 만 마우스 입력을 잡을 수 있습니다. 보이지 않는 항목에서 grabMouse ()를 호출해도 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="3a22d6e64ad94731eabd37555675f63615789ad8" translate="yes" xml:space="preserve">
          <source>Note that other libraries that define variables called &lt;code&gt;signals&lt;/code&gt; or &lt;code&gt;slots&lt;/code&gt; may cause compiler warnings and errors when compiled alongside a Qt-based application. To solve this problem, &lt;code&gt;#undef&lt;/code&gt; the offending preprocessor symbol.</source>
          <target state="translated">&lt;code&gt;signals&lt;/code&gt; 또는 &lt;code&gt;slots&lt;/code&gt; 이라는 변수를 정의하는 다른 라이브러리 는 Qt 기반 응용 프로그램과 함께 컴파일 될 때 컴파일러 경고 및 오류를 유발할 수 있습니다. 이 문제를 해결하려면 문제 가되는 전 처리기 기호를 &lt;code&gt;#undef&lt;/code&gt; 로 지정 하십시오.</target>
        </trans-unit>
        <trans-unit id="d3c853c4ebb56d0d3b2d67511da4bdc9d0f8416a" translate="yes" xml:space="preserve">
          <source>Note that other rows may be displaced accordingly.</source>
          <target state="translated">다른 행도 그에 따라 대체 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="051375711d34ba24c18759e9f12bae9c1b8e9ba2" translate="yes" xml:space="preserve">
          <source>Note that other rows may be displaced accordingly. Note also that when moving items within the same parent you should not attempt invalid or no-op moves. In the above example, item 2 is at row 2 before the move, so it cannot be moved to row 2 (where it is already) or row 3 (no-op as row 3 means above row 3, where it is already)</source>
          <target state="translated">다른 행도 그에 따라 대체 될 수 있습니다. 또한 동일한 상위 내에서 항목을 이동할 때 유효하지 않거나 이동하지 않아야합니다. 위의 예에서 항목 2는 이동 전에 행 2에 있으므로 행 2 (이미있는 위치) 또는 행 3으로 이동할 수 없습니다 (행 3은 이미 행 3의 위를 의미하므로 작동하지 않음)</target>
        </trans-unit>
        <trans-unit id="7dbc30dd5c039e7142ab3b76bb62281f0cd3f3c8" translate="yes" xml:space="preserve">
          <source>Note that ownership must be taken care of by subclasses of &lt;a href=&quot;qgeoareamonitorsource&quot;&gt;QGeoAreaMonitorSource&lt;/a&gt;. Due to the singleton pattern behind this class</source>
          <target state="translated">소유권은 &lt;a href=&quot;qgeoareamonitorsource&quot;&gt;QGeoAreaMonitorSource의&lt;/a&gt; 서브 클래스에 의해 처리되어야합니다 . 이 클래스 뒤의 싱글 톤 패턴으로 인해</target>
        </trans-unit>
        <trans-unit id="aee666352f858e9d84e4b3a49616bb53cc6ea791" translate="yes" xml:space="preserve">
          <source>Note that particle count is often estimated by the particle system, and in some cases explicitly providing hints as to how many particles will be needed will improve performance. You can do this by setting maximumEmitted on an Emitter, and it is generally useful for Emitters which do not continuously emit particles.</source>
          <target state="translated">입자 수는 종종 입자 시스템에 의해 추정되며 경우에 따라 필요한 입자 수에 대한 힌트를 명시 적으로 제공하면 성능이 향상됩니다. 이미 터에서 maximumEmitted를 설정하여이 작업을 수행 할 수 있으며 일반적으로 입자를 계속 방출하지 않는 이미 터에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="90abf035ba0d267228983e9c29fcea516687263c" translate="yes" xml:space="preserve">
          <source>Note that passing the dot expression to the &lt;a href=&quot;http://www.w3.org/TR/xpath-functions/#func-string-length&quot;&gt;string-length()&lt;/a&gt; function is optional. When &lt;a href=&quot;http://www.w3.org/TR/xpath-functions/#func-string-length&quot;&gt;string-length()&lt;/a&gt; is called with no parameter, the context node is assumed:</source>
          <target state="translated">점 표현식을 &lt;a href=&quot;http://www.w3.org/TR/xpath-functions/#func-string-length&quot;&gt;string-length ()&lt;/a&gt; 함수에 전달하는 것은 선택 사항입니다. 경우 &lt;a href=&quot;http://www.w3.org/TR/xpath-functions/#func-string-length&quot;&gt;문자열 길이 ()는&lt;/a&gt; 매개 변수없이 호출 컨텍스트 노드 가정한다 :</target>
        </trans-unit>
        <trans-unit id="dafa43666581dee47cdf038f7227db7f47ad10c6" translate="yes" xml:space="preserve">
          <source>Note that passing the minimum of &lt;code&gt;qint64&lt;/code&gt; (&lt;code&gt;std::numeric_limits&amp;lt;qint64&amp;gt;::min()&lt;/code&gt;) to</source>
          <target state="translated">최소 &lt;code&gt;qint64&lt;/code&gt; ( &lt;code&gt;std::numeric_limits&amp;lt;qint64&amp;gt;::min()&lt;/code&gt; )를 전달하여</target>
        </trans-unit>
        <trans-unit id="b1b46ffc5079b476e597970c77761d7e4f161084" translate="yes" xml:space="preserve">
          <source>Note that passing the value &lt;code&gt;QSound::Infinite&lt;/code&gt; will cause the sound to loop indefinitely.</source>
          <target state="translated">&lt;code&gt;QSound::Infinite&lt;/code&gt; 값을 전달하면 사운드가 무한정 반복됩니다.</target>
        </trans-unit>
        <trans-unit id="5171e5ddc7d74edcc6d312d1fb226c8ba1ae84c0" translate="yes" xml:space="preserve">
          <source>Note that pressing the stylus button while the stylus hovers over the tablet will generate a button press on some types of tablets, while on other types it will be necessary to press the stylus against the tablet surface in order to register the simultaneous stylus button press.</source>
          <target state="translated">스타일러스가 태블릿 위로 마우스를 가져가는 동안 스타일러스 버튼을 누르면 일부 유형의 태블릿에서 버튼을 누르는 반면, 다른 유형의 경우 스타일러스 버튼을 동시에 등록하려면 스타일러스를 태블릿 표면에 눌러야합니다.</target>
        </trans-unit>
        <trans-unit id="3991f0be1309a9322720ebb4add2dce9a2bd9cc2" translate="yes" xml:space="preserve">
          <source>Note that properties of the returned object that are themselves objects will also be models, and this get() method is used to access elements:</source>
          <target state="translated">반환 된 객체 자체가 객체 인 속성도 모델이며이 get () 메서드는 요소에 액세스하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="acf4c296f084b0eb3fb482bde82066932d0bdcb3" translate="yes" xml:space="preserve">
          <source>Note that qintptr is signed. Use quintptr for unsigned values.</source>
          <target state="translated">qintptr이 서명되었습니다. 부호없는 값에 quintptr을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="8e433cdfc89082986e5808abb818280f92a244d3" translate="yes" xml:space="preserve">
          <source>Note that qptrdiff is signed. Use quintptr for unsigned values.</source>
          <target state="translated">qptrdiff가 서명되었습니다. 부호없는 값에 quintptr을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="73dcfa8bdd65361b28d32d1a093fcb8e8642f3f5" translate="yes" xml:space="preserve">
          <source>Note that qsizetype is signed. Use &lt;code&gt;size_t&lt;/code&gt; for unsigned values.</source>
          <target state="translated">qsizetype이 서명되었습니다. 부호없는 값 에는 &lt;code&gt;size_t&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="7cf494e5dca771735e6ae5f934819bc0e0e3d522" translate="yes" xml:space="preserve">
          <source>Note that quintptr is unsigned. Use qptrdiff for signed values.</source>
          <target state="translated">quintptr은 부호가 없습니다. 부호있는 값에 qptrdiff를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ac776601bf09c34db17a338c79b397a8439e7a56" translate="yes" xml:space="preserve">
          <source>Note that requesting a 3.2 OpenGL Core Profile is just for the example's purposes; this class is not tied to any specific OpenGL or OpenGL ES version, as it relies on the availability of the &lt;code&gt;GL_KHR_debug&lt;/code&gt; extension (see below).</source>
          <target state="translated">3.2 OpenGL 코어 프로파일을 요청하는 것은 예제를위한 것입니다. 이 클래스는 &lt;code&gt;GL_KHR_debug&lt;/code&gt; 확장 의 가용성에 의존하기 때문에 특정 OpenGL 또는 OpenGL ES 버전과 관련이 없습니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="e93b64536639a15d605e5cc3e5abdbbbc2316a0e" translate="yes" xml:space="preserve">
          <source>Note that requests for function objects of other versions or profiles can fail and in doing so will return &lt;code&gt;nullptr&lt;/code&gt;. Situations in which creation of the functions object can fail are if the request cannot be satisfied due to asking for functions that are not in the version or profile of this context. For example:</source>
          <target state="translated">다른 버전이나 프로파일의 함수 객체에 대한 요청은 실패 할 수 &lt;code&gt;nullptr&lt;/code&gt; 반환 됩니다. 함수 오브젝트 작성에 실패 할 수있는 상황은이 컨텍스트의 버전 또는 프로파일에없는 함수를 요청하여 요청을 충족시킬 수없는 경우입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c7df8cc916184d9f5d3c971c2dec810b104a3419" translate="yes" xml:space="preserve">
          <source>Note that return values in the ranges QVariant::Char through QVariant::RegExp and QVariant::Font through QVariant::Transform correspond to the values in the ranges &lt;a href=&quot;qmetatype#Type-enum&quot;&gt;QMetaType::QChar&lt;/a&gt; through &lt;a href=&quot;qmetatype#Type-enum&quot;&gt;QMetaType::QRegExp&lt;/a&gt; and &lt;a href=&quot;qmetatype#Type-enum&quot;&gt;QMetaType::QFont&lt;/a&gt; through &lt;a href=&quot;qmetatype#Type-enum&quot;&gt;QMetaType::QQuaternion&lt;/a&gt;.</source>
          <target state="translated">QVariant :: Char-QVariant :: RegExp 및 QVariant :: Font-QVariant :: Transform 범위의 값은 &lt;a href=&quot;qmetatype#Type-enum&quot;&gt;QMetaType :: QChar&lt;/a&gt; - &lt;a href=&quot;qmetatype#Type-enum&quot;&gt;QMetaType :: QRegExp&lt;/a&gt; 및 &lt;a href=&quot;qmetatype#Type-enum&quot;&gt;QMetaType :: QFont&lt;/a&gt; - &lt;a href=&quot;qmetatype#Type-enum&quot;&gt;QMetaType&lt;/a&gt; 범위의 값에 해당합니다 . : QQuaternion .</target>
        </trans-unit>
        <trans-unit id="04f7b789b00c09630f3c0f93f48a472ef0defc7f" translate="yes" xml:space="preserve">
          <source>Note that rewinding inserts addition lines in the polygon so the outline of the fill polygon does not match the outline of the path.</source>
          <target state="translated">되감기는 다각형에 추가 선을 삽입하여 채우기 다각형의 윤곽선이 경로의 윤곽선과 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d6236ff0e45f11cd50b6069dd17eb4c2f9dee3e8" translate="yes" xml:space="preserve">
          <source>Note that sensor timestamps from different sensors may not be directly comparable (as they may choose different fixed points for their reference).</source>
          <target state="translated">서로 다른 센서의 센서 타임 스탬프는 직접 비교할 수 없습니다 (참조 용으로 다른 고정 점을 선택할 수 있음).</target>
        </trans-unit>
        <trans-unit id="0e106a19d1b8de17a8919259ee4f7ede563a76fe" translate="yes" xml:space="preserve">
          <source>Note that setHeaderLabels() won't remove existing columns.</source>
          <target state="translated">setHeaderLabels ()는 기존 열을 제거하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7e0332392bca9cd8a557c2c55f3c2b55bf90252f" translate="yes" xml:space="preserve">
          <source>Note that setting</source>
          <target state="translated">설정에 유의하십시오</target>
        </trans-unit>
        <trans-unit id="aa9493d2c234336e3628c6b369d9fb76d6efd0e5" translate="yes" xml:space="preserve">
          <source>Note that setting &lt;a href=&quot;qsvgrenderer&quot;&gt;QSvgRenderer&lt;/a&gt; on a &lt;a href=&quot;qgraphicssvgitem&quot;&gt;QGraphicsSvgItem&lt;/a&gt; doesn't make the item take ownership of the renderer, therefore if using &lt;a href=&quot;qgraphicssvgitem#setSharedRenderer&quot;&gt;setSharedRenderer&lt;/a&gt;() method one has to make sure that the lifetime of the &lt;a href=&quot;qsvgrenderer&quot;&gt;QSvgRenderer&lt;/a&gt; object will be at least as long as that of the &lt;a href=&quot;qgraphicssvgitem&quot;&gt;QGraphicsSvgItem&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qgraphicssvgitem&quot;&gt;QGraphicsSvgItem&lt;/a&gt; 에서 &lt;a href=&quot;qsvgrenderer&quot;&gt;QSvgRenderer&lt;/a&gt; 를 설정 한다고 해서 아이템이 렌더러의 소유권을 &lt;a href=&quot;qgraphicssvgitem#setSharedRenderer&quot;&gt;가지지&lt;/a&gt; 않으므로 setSharedRenderer () 메소드를 사용하는 경우 &lt;a href=&quot;qsvgrenderer&quot;&gt;QSvgRenderer&lt;/a&gt; 객체 의 수명 이 &lt;a href=&quot;qgraphicssvgitem&quot;&gt;QGraphicsSvgItem&lt;/a&gt; 의 수명보다 길어야 합니다 .</target>
        </trans-unit>
        <trans-unit id="bc4f289addee1e29e92900e5bff7af86f202d643" translate="yes" xml:space="preserve">
          <source>Note that setting a source URL will result in the QML component being instantiated, even if the URL is unchanged from the current value.</source>
          <target state="translated">소스 URL을 설정하면 URL이 현재 값에서 변경되지 않은 경우에도 QML 구성 요소가 인스턴스화됩니다.</target>
        </trans-unit>
        <trans-unit id="06f6aa63927afe2f26a5bcadacae2318e77e5b64" translate="yes" xml:space="preserve">
          <source>Note that setting parameters like paper size and resolution on an invalid printer is undefined. You can use &lt;a href=&quot;qprinter#isValid&quot;&gt;QPrinter::isValid&lt;/a&gt;() to verify this before changing any parameters.</source>
          <target state="translated">유효하지 않은 프린터에서 용지 크기 및 해상도와 같은 매개 변수 설정은 정의되어 있지 않습니다. 매개 변수를 변경하기 전에 &lt;a href=&quot;qprinter#isValid&quot;&gt;QPrinter :: isValid&lt;/a&gt; ()를 사용하여이를 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a456954f29611613fc8d2c4d8b1afdea9ba7d4bc" translate="yes" xml:space="preserve">
          <source>Note that setting preventStealing to &lt;code&gt;true&lt;/code&gt; once an item has started stealing events has no effect until the next press event.</source>
          <target state="translated">항목이 이벤트를 훔치기 시작한 후 preventStealing을 &lt;code&gt;true&lt;/code&gt; 로 설정 하면 다음 프레스 이벤트까지 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="77982ec2935a70e6a0d7c3a6b5c0b0ccd29549f3" translate="yes" xml:space="preserve">
          <source>Note that setting preventStealing to true once an item has started stealing events will have no effect until the next press event.</source>
          <target state="translated">항목이 이벤트를 훔치기 시작한 후 preventStealing을 true로 설정하면 다음 프레스 이벤트까지 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d1c55dd183b4fb5f4c7db4ca94192eaf74ee1f66" translate="yes" xml:space="preserve">
          <source>Note that setting the entire list means removing all previous rules for watching services and adding new ones. This is an expensive operation and should be avoided, if possible. Instead, use &lt;a href=&quot;qdbusservicewatcher#addWatchedService&quot;&gt;addWatchedService&lt;/a&gt;() and &lt;a href=&quot;qdbusservicewatcher#removeWatchedService&quot;&gt;removeWatchedService&lt;/a&gt;() if you can to manipulate entries in the list.</source>
          <target state="translated">전체 목록을 설정한다는 것은 서비스 시청 및 새로운 규칙 추가에 대한 이전 규칙을 모두 제거한다는 것을 의미합니다. 이는 비용이 많이 드는 작업이므로 가능하면 피해야합니다. 대신 목록에서 항목을 조작 할 수있는 경우 &lt;a href=&quot;qdbusservicewatcher#addWatchedService&quot;&gt;addWatchedService&lt;/a&gt; () 및 &lt;a href=&quot;qdbusservicewatcher#removeWatchedService&quot;&gt;removeWatchedService&lt;/a&gt; ()를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="cef3505eb8c6dd3f2cc51b314b711cbd7fc78b39" translate="yes" xml:space="preserve">
          <source>Note that setting this flag does not imply that QGeoAreaMonitorInfoSource supports persistent monitoring. &lt;a href=&quot;qgeoareamonitorsource#supportedAreaMonitorFeatures&quot;&gt;QGeoAreaMonitorSource::supportedAreaMonitorFeatures&lt;/a&gt;() can be used to check for this feature's availability.</source>
          <target state="translated">이 플래그를 설정한다고해서 QGeoAreaMonitorInfoSource가 지속적 모니터링을 지원한다는 것을 의미하지는 않습니다. &lt;a href=&quot;qgeoareamonitorsource#supportedAreaMonitorFeatures&quot;&gt;QGeoAreaMonitorSource :: supportedAreaMonitorFeatures&lt;/a&gt; ()를 사용하여이 기능의 사용 가능 여부를 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7dab1a6bec4aa027a12cd6ede77bc6616aea6683" translate="yes" xml:space="preserve">
          <source>Note that setting this property will apply the limit immediately to the document contents.</source>
          <target state="translated">이 속성을 설정하면 문서 내용에 즉시 제한이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="45f0ea82267e22a7b4f59d0a21212c2ff451d376" translate="yes" xml:space="preserve">
          <source>Note that setting this property will apply the limit immediately to the document contents. Setting this property also disables the undo redo history.</source>
          <target state="translated">이 속성을 설정하면 문서 내용에 즉시 제한이 적용됩니다. 이 속성을 설정하면 실행 취소 재실행 기록도 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="62d2388c4b9ce54d640f3aeff26d90a6427e8f87" translate="yes" xml:space="preserve">
          <source>Note that setting this value to true will not have an immediate effect. Instead, the sensor will be started once the event loop has been reached.</source>
          <target state="translated">이 값을 true로 설정해도 즉각적인 효과는 없습니다. 대신 이벤트 루프에 도달하면 센서가 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="ecca1c5b065be8d76a9186be59630a0ec4f9fd79" translate="yes" xml:space="preserve">
          <source>Note that showMessage() is called to show temporary explanations of tool tip texts, so passing a</source>
          <target state="translated">showMessage ()는 툴팁 텍스트에 대한 임시 설명을 표시하기 위해 호출되므로 a</target>
        </trans-unit>
        <trans-unit id="a94378d5caa1942808d45a572429190e97778fb4" translate="yes" xml:space="preserve">
          <source>Note that signal and slot arguments are not checked by the compiler when using this &lt;a href=&quot;qobject#connect&quot;&gt;QObject::connect&lt;/a&gt;() overload.</source>
          <target state="translated">이 &lt;a href=&quot;qobject#connect&quot;&gt;QObject :: connect를&lt;/a&gt; 사용할 때 컴파일러는 신호 및 슬롯 인수를 확인하지 않습니다. () 오버로드를 .</target>
        </trans-unit>
        <trans-unit id="a4e00f1dbc9dc1ed054cf55123547d54b7f3eae8" translate="yes" xml:space="preserve">
          <source>Note that similarly to other percent methods, the percentage measurement is not linear with regards to the length, if curves are present in the path. When curves are present the percentage argument is mapped to the t parameter of the Bezier equations.</source>
          <target state="translated">경로에 곡선이있는 경우 다른 백분율 방법과 마찬가지로 백분율 측정은 길이와 관련하여 선형이 아닙니다. 곡선이 존재할 때 백분율 인수는 베 지어 방정식의 t 매개 변수에 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="e61192546337e3636dabcd41fceb433b6916268c" translate="yes" xml:space="preserve">
          <source>Note that similarly to the other percent methods, the percentage measurement is not linear with regards to the length if curves are present in the path. When curves are present the percentage argument is mapped to the t parameter of the Bezier equations.</source>
          <target state="translated">다른 퍼센트 방법과 마찬가지로 패스에 곡선이있는 경우 퍼센트 측정은 길이와 관련하여 선형이 아닙니다. 곡선이 존재할 때 백분율 인수는 베 지어 방정식의 t 매개 변수에 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="2c1282d63e40e5426a24a68117aecf20b0352809" translate="yes" xml:space="preserve">
          <source>Note that since the tab order of the</source>
          <target state="translated">탭 순서는</target>
        </trans-unit>
        <trans-unit id="82c941b7785be59e54a1d2aef99ba84315c2582e" translate="yes" xml:space="preserve">
          <source>Note that singleton types do not have an associated &lt;a href=&quot;qqmlcontext&quot;&gt;QQmlContext&lt;/a&gt; as they are shared across all contexts in an engine. &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; singleton type instances are constructed and owned by the &lt;a href=&quot;qqmlengine&quot;&gt;QQmlEngine&lt;/a&gt;, and will be destroyed when the engine is destroyed.</source>
          <target state="translated">싱글 톤 유형 에는 엔진의 모든 컨텍스트에서 공유 되므로 연관된 &lt;a href=&quot;qqmlcontext&quot;&gt;QQmlContext&lt;/a&gt; 가 없습니다 . &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 싱글 톤 타입 인스턴스는 &lt;a href=&quot;qqmlengine&quot;&gt;QQmlEngine에&lt;/a&gt; 의해 구성되고 소유됩니다 엔진이 파괴되면 소멸됩니다.</target>
        </trans-unit>
        <trans-unit id="8cd1ee27bdfea02b3dd15605f90c265515dd6421" translate="yes" xml:space="preserve">
          <source>Note that some databases need to be &lt;a href=&quot;qsqldriver#open&quot;&gt;open&lt;/a&gt;() before this can be determined.</source>
          <target state="translated">이를 결정하기 전에 일부 데이터베이스를 &lt;a href=&quot;qsqldriver#open&quot;&gt;열어야합니다&lt;/a&gt; ().</target>
        </trans-unit>
        <trans-unit id="09783a5c8c8ac6b6fc6a94d3058792a409358b41" translate="yes" xml:space="preserve">
          <source>Note that some databases, i.e. Microsoft SQL Server, requires non-scrollable cursors when working with multiple result sets. Some databases may execute all statements at once while others may delay the execution until the result set is actually accessed, and some databases may have restrictions on which statements are allowed to be used in a SQL batch.</source>
          <target state="translated">Microsoft SQL Server와 같은 일부 데이터베이스는 여러 결과 집합으로 작업 할 때 스크롤 할 수없는 커서가 필요합니다. 일부 데이터베이스는 모든 명령문을 한 번에 실행할 수 있지만 다른 데이터베이스는 결과 세트에 실제로 액세스 할 때까지 실행을 지연시킬 수 있으며 일부 데이터베이스는 SQL 배치에서 사용할 수있는 명령문에 제한이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b4532d0e850703932803484cc9927824f3af73c" translate="yes" xml:space="preserve">
          <source>Note that some of the capturing groups with an index less than lastCapturedIndex() could have not matched, and therefore captured nothing.</source>
          <target state="translated">lastCapturedIndex ()보다 작은 인덱스를 가진 캡처 그룹 중 일부는 일치하지 않았으므로 아무 것도 캡처하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="946b44a084b3caee40fff6ab6dd5112b0c56b163" translate="yes" xml:space="preserve">
          <source>Note that some of these settings mirror settings in some paint devices, e.g. &lt;a href=&quot;qwidget#font-prop&quot;&gt;QWidget::font&lt;/a&gt;(). The &lt;a href=&quot;qpainter#begin&quot;&gt;QPainter::begin&lt;/a&gt;() function (or equivalently the &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; constructor) copies these attributes from the paint device.</source>
          <target state="translated">이러한 설정 중 일부는 &lt;a href=&quot;qwidget#font-prop&quot;&gt;QWidget :: font&lt;/a&gt; () 와 같은 일부 페인트 장치에서 설정을 반영 합니다. &lt;a href=&quot;qpainter#begin&quot;&gt;QPainter를이 :: 시작&lt;/a&gt; () 함수 (또는 동등 &lt;a href=&quot;qpainter&quot;&gt;QPainter가의&lt;/a&gt; 생성자) 복사 페인트 장치에서 이러한 특성을.</target>
        </trans-unit>
        <trans-unit id="3f7fa47e4dafaf1a7c45f943621ca5416dcbe7a3" translate="yes" xml:space="preserve">
          <source>Note that some properties, such as &lt;code&gt;enabled&lt;/code&gt;, &lt;code&gt;text&lt;/code&gt;, or &lt;code&gt;iconSource&lt;/code&gt;, only make sense in a particular use case of the menu.</source>
          <target state="translated">&lt;code&gt;enabled&lt;/code&gt; , &lt;code&gt;text&lt;/code&gt; 또는 &lt;code&gt;iconSource&lt;/code&gt; 와 같은 일부 속성 은 메뉴의 특정 사용 사례에서만 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b9ca420865ae8edadf2e02e36a2786161f0a9c59" translate="yes" xml:space="preserve">
          <source>Note that some rounding may occur if</source>
          <target state="translated">다음과 같은 경우 반올림이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="200ebe8ec2356e04f060f86f2a66f22bfd9fe302" translate="yes" xml:space="preserve">
          <source>Note that some standard page sizes are defined with a width larger than their height, hence the orientation is defined relative to the standard page size and not using the relative page dimensions.</source>
          <target state="translated">일부 표준 페이지 크기는 높이보다 큰 너비로 정의되므로 방향은 표준 페이지 크기를 기준으로 정의되며 상대 페이지 크기를 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ae81adf523aee4176e1e1faaab7cb34ecf6a454e" translate="yes" xml:space="preserve">
          <source>Note that some styles might render &lt;a href=&quot;qabstractspinbox#ButtonSymbols-enum&quot;&gt;PlusMinus&lt;/a&gt; and &lt;a href=&quot;qabstractspinbox#ButtonSymbols-enum&quot;&gt;UpDownArrows&lt;/a&gt; identically.</source>
          <target state="translated">일부 스타일은 &lt;a href=&quot;qabstractspinbox#ButtonSymbols-enum&quot;&gt;PlusMinus&lt;/a&gt; 및 &lt;a href=&quot;qabstractspinbox#ButtonSymbols-enum&quot;&gt;UpDownArrows를&lt;/a&gt; 렌더링 할 수 있습니다. 동일하게 .</target>
        </trans-unit>
        <trans-unit id="77ab6bd9653307d36fe8fe4530270de865375ab3" translate="yes" xml:space="preserve">
          <source>Note that specifying a search center can be done by setting a circular search area that has a center but no radius. The default radius is set to -1, which indicates an undefined radius. The provider will interpret this as being free to choose its own default radius.</source>
          <target state="translated">중심은 있지만 반경은없는 원형 검색 영역을 설정하여 검색 센터를 지정할 수 있습니다. 기본 반지름은 -1로 설정되어 정의되지 않은 반지름을 나타냅니다. 제공자는이를 자신의 기본 반경을 자유롭게 선택할 수있는 것으로 해석합니다.</target>
        </trans-unit>
        <trans-unit id="0f1008d6d395cde97cdc6c1699c16e6df8a76ac4" translate="yes" xml:space="preserve">
          <source>Note that startPrefixMapping() and &lt;a href=&quot;qxmlcontenthandler#endPrefixMapping&quot;&gt;endPrefixMapping&lt;/a&gt;() calls are not guaranteed to be properly nested relative to each other: all startPrefixMapping() events occur before the corresponding &lt;a href=&quot;qxmlcontenthandler#startElement&quot;&gt;startElement&lt;/a&gt;() event, and all &lt;a href=&quot;qxmlcontenthandler#endPrefixMapping&quot;&gt;endPrefixMapping&lt;/a&gt;() events occur after the corresponding &lt;a href=&quot;qxmlcontenthandler#endElement&quot;&gt;endElement&lt;/a&gt;() event, but their order is not otherwise guaranteed.</source>
          <target state="translated">startPrefixMapping () 및 &lt;a href=&quot;qxmlcontenthandler#endPrefixMapping&quot;&gt;endPrefixMapping&lt;/a&gt; () 호출은 서로에 대해 올바르게 중첩되지 않을 수 있습니다. 모든 startPrefixMapping () 이벤트는 해당 &lt;a href=&quot;qxmlcontenthandler#startElement&quot;&gt;startElement&lt;/a&gt; () 이벤트 전에 발생 하며 모든 &lt;a href=&quot;qxmlcontenthandler#endPrefixMapping&quot;&gt;endPrefixMapping&lt;/a&gt; () 이벤트는 해당 &lt;a href=&quot;qxmlcontenthandler#endElement&quot;&gt;endElement&lt;/a&gt; () 이벤트 후에 발생합니다. 하지만 순서는 보장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0cd6447c94eaf7e1c7a48950387ed79e9d1d840e" translate="yes" xml:space="preserve">
          <source>Note that steps lie between 0.0 and 1.0. It may be necessary to use &lt;a href=&quot;qtimeline#updateInterval-prop&quot;&gt;setUpdateInterval()&lt;/a&gt;. The default update interval is 40 ms. A scheduled transformation cannot be removed when set, so scheduling several transformations of the same kind (e.g., rotations) at the same step is not recommended.</source>
          <target state="translated">단계는 0.0과 1.0 사이에 있습니다. &lt;a href=&quot;qtimeline#updateInterval-prop&quot;&gt;setUpdateInterval ()&lt;/a&gt; 을 사용해야 할 수도 있습니다. . 기본 업데이트 간격은 40ms입니다. 예약 된 변환은 설정시 제거 할 수 없으므로 동일한 단계에서 동일한 종류 (예 : 회전)의 여러 변환 예약은 권장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8da8e95e94dd3114b96d2fef726fcf0d76e1cb1e" translate="yes" xml:space="preserve">
          <source>Note that styles are free to choose any color from the palette. You can modify the palette or set a style sheet if you don't achieve the result you want with setBackgroundRole().</source>
          <target state="translated">스타일은 팔레트에서 색상을 자유롭게 선택할 수 있습니다. setBackgroundRole ()을 사용하여 원하는 결과를 얻지 못하면 팔레트를 수정하거나 스타일 시트를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4ee128161fcbcfb5cf0e8060e60915f2879004b" translate="yes" xml:space="preserve">
          <source>Note that styles are free to choose any color from the palette. You can modify the palette or set a style sheet if you don't achieve the result you want with setForegroundRole().</source>
          <target state="translated">스타일은 팔레트에서 색상을 자유롭게 선택할 수 있습니다. setForegroundRole ()로 원하는 결과를 얻지 못하면 팔레트를 수정하거나 스타일 시트를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc0ca310c25d964ee94b62c4015ffc123fd8d445" translate="yes" xml:space="preserve">
          <source>Note that sub controls are not the same as the control elements described in the previous section. You cannot use the style to draw a sub control; the style will only calculate the bounding rectangle in which the sub control should be drawn. It is common, though, that complex elements use control and primitive elements to draw their sub controls, which is an approach that is frequently used by the built-in styles in Qt and also the Java style. For instance, the Java style uses PE_IndicatorCheckBox to draw the check box in group boxes (which is a sub control of &lt;code&gt;CC_GroupBox&lt;/code&gt;). Some sub controls have an equivalent control element, e.g., the scroll bar slider (&lt;code&gt;SC_SCrollBarSlider&lt;/code&gt; and &lt;code&gt;CE_ScrollBarSlider&lt;/code&gt;).</source>
          <target state="translated">하위 컨트롤은 이전 섹션에서 설명한 컨트롤 요소와 동일하지 않습니다. 하위 컨트롤을 그리는 데 스타일을 사용할 수 없습니다. 스타일은 하위 컨트롤을 그릴 경계 사각형 만 계산합니다. 그러나 복잡한 요소는 컨트롤과 기본 요소를 사용하여 하위 컨트롤을 그리는 것이 일반적입니다. 이는 Qt의 내장 스타일과 Java 스타일에서 자주 사용되는 접근 방식입니다. 예를 들어, 자바 스타일 (의 하위 컨트롤입니다 그룹 상자에서 확인란을 그릴 PE_IndicatorCheckBox를 사용 &lt;code&gt;CC_GroupBox&lt;/code&gt; 을 ). 일부 하위 제어에는 스크롤 막대 슬라이더 ( &lt;code&gt;SC_SCrollBarSlider&lt;/code&gt; 및 &lt;code&gt;CE_ScrollBarSlider&lt;/code&gt; ) 와 동등한 제어 요소가 있습니다. ) 있습니다.</target>
        </trans-unit>
        <trans-unit id="b1ef38fed13b2484b62d214ff64f9cd8a4e2bfac" translate="yes" xml:space="preserve">
          <source>Note that subclasses that reimplement &lt;a href=&quot;qvariant#clear&quot;&gt;clear&lt;/a&gt;() should reimplement the destructor to call &lt;a href=&quot;qvariant#clear&quot;&gt;clear&lt;/a&gt;(). This destructor calls &lt;a href=&quot;qvariant#clear&quot;&gt;clear&lt;/a&gt;(), but because it is the destructor, &lt;a href=&quot;qvariant#clear&quot;&gt;QVariant::clear&lt;/a&gt;() is called rather than a subclass's &lt;a href=&quot;qvariant#clear&quot;&gt;clear&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qvariant#clear&quot;&gt;clear&lt;/a&gt; () 를 다시 구현하는 서브 클래스 는 소멸자를 다시 구현하여 &lt;a href=&quot;qvariant#clear&quot;&gt;clear&lt;/a&gt; () 를 호출해야합니다 . 이 소멸자는 &lt;a href=&quot;qvariant#clear&quot;&gt;clear&lt;/a&gt; ()를 호출 하지만 소멸자이므로 &lt;a href=&quot;qvariant#clear&quot;&gt;QVariant :: clear&lt;/a&gt; ()는 하위 클래스의 &lt;a href=&quot;qvariant#clear&quot;&gt;clear가&lt;/a&gt; 아니라 호출됩니다. ()가 됩니다.</target>
        </trans-unit>
        <trans-unit id="643a90b7cc572aa8f24a2a4aeec18309319e74d7" translate="yes" xml:space="preserve">
          <source>Note that the</source>
          <target state="translated">참고</target>
        </trans-unit>
        <trans-unit id="71f730a30b7ed28a2a3b091faf86c60ceb68df06" translate="yes" xml:space="preserve">
          <source>Note that the &quot;enabled&quot; status for a given message is a property of the (id, source, type, severity) tuple; the message attributes</source>
          <target state="translated">주어진 메시지에 대한 &quot;사용 가능&quot;상태는 (ID, 소스, 유형, 심각도) 튜플의 속성입니다. 메시지 속성</target>
        </trans-unit>
        <trans-unit id="f2bd2451b18a247a530fc233330342f5f316b1ad" translate="yes" xml:space="preserve">
          <source>Note that the -iterations command line argument has no effect on test functions without the QBENCHMARK macro.</source>
          <target state="translated">-iterations 명령 행 인수는 QBENCHMARK 매크로가없는 테스트 기능에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5dfdc3b6cc92124a0773cfeaaec6796010463e1d" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;qapplication&quot;&gt;QApplication&lt;/a&gt; instance must be created before this function is called.</source>
          <target state="translated">점을 유의 &lt;a href=&quot;qapplication&quot;&gt;의 QApplication&lt;/a&gt; 이 함수가 호출되기 전에 인스턴스를 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="1023fd844e5aee23a360aba54cabb15d72df9ea5" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;qfuture#result&quot;&gt;QFuture::result&lt;/a&gt;() function blocks and waits for the result to become available. Use &lt;a href=&quot;qfuturewatcher&quot;&gt;QFutureWatcher&lt;/a&gt; to get notification when the function has finished execution and the result is available.</source>
          <target state="translated">있습니다 &lt;a href=&quot;qfuture#result&quot;&gt;QFuture :: 결과&lt;/a&gt; 결과에 대한 () 함수 블록 및 대기 사용할 수있게 할 수 있습니다. &lt;a href=&quot;qfuturewatcher&quot;&gt;QFutureWatcher&lt;/a&gt; 사용함수가 실행을 완료하고 결과를 사용할 수있을 때 를 하여 알림을받습니다.</target>
        </trans-unit>
        <trans-unit id="dee5acf7be82760b42b43776bbd056dca352dc91" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;qgradient#setSpread&quot;&gt;setSpread&lt;/a&gt;() function has no effect for conical gradients. The reason is that the conical gradient is closed by definition, i.e. the conical gradient fills the entire circle from 0 - 360 degrees, while the boundary of a radial or a linear gradient can be specified through its radius or final stop points, respectively.</source>
          <target state="translated">점을 유의 &lt;a href=&quot;qgradient#setSpread&quot;&gt;setSpread&lt;/a&gt; () 함수 원추 구배에 영향을 미치지 않는다. 그 이유는 원뿔형 그래디언트가 정의에 의해 닫히기 때문입니다. 즉, 원뿔형 그래디언트는 전체 원을 0-360도까지 채우고 방사형 또는 선형 그래디언트의 경계는 각각 반경 또는 최종 정지 점을 통해 지정할 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="7fd27a7f67842eccce40bf3dd5cd033beae43817" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;qgradient#setSpread&quot;&gt;setSpread&lt;/a&gt;() function only has effect for linear and radial gradients. The reason is that the conical gradient is closed by definition, i.e. the</source>
          <target state="translated">참고 것을 &lt;a href=&quot;qgradient#setSpread&quot;&gt;setSpread&lt;/a&gt; () 함수는 선형 및 방사형 그라데이션에 대한 효과를 갖는다. 그 이유는 원뿔형 그래디언트가 정의에 의해 닫혀 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="ab59c6b133d4e06194ec76c374b18d401e0e0cae" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;qguiapplication&quot;&gt;QGuiApplication&lt;/a&gt; instance must be created before this function is called.</source>
          <target state="translated">합니다 &lt;a href=&quot;qguiapplication&quot;&gt;QGuiApplication&lt;/a&gt; 이 함수가 호출되기 전에 인스턴스를 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="05da42d9f9beaf37c52688678852ffc46519055b" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;qheaderview#sectionPressed&quot;&gt;sectionPressed&lt;/a&gt; signal will also be emitted.</source>
          <target state="translated">점을 유의 &lt;a href=&quot;qheaderview#sectionPressed&quot;&gt;sectionPressed&lt;/a&gt; 신호도 방출한다.</target>
        </trans-unit>
        <trans-unit id="a867b8041831ecef49eaed317e995c47b07a1659" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;qheaderview#visualIndex&quot;&gt;visualIndex&lt;/a&gt; is not affected by hidden sections.</source>
          <target state="translated">있습니다 &lt;a href=&quot;qheaderview#visualIndex&quot;&gt;visualIndex가&lt;/a&gt; 숨겨진 섹션의 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a5b097d9ad4de72fe93971c6dce58b47b73cd395" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt; is mirrored vertically to account for the fact that OpenGL and &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt; use opposite directions for the y axis. Another option would be to transform your texture coordinates.</source>
          <target state="translated">점을 유의 &lt;a href=&quot;qimage&quot;&gt;QImage는&lt;/a&gt; OpenGL을하고 있다는 사실을 고려하여 수직 미러링 &lt;a href=&quot;qimage&quot;&gt;QImage은&lt;/a&gt; 은 Y 축에 대해 반대 방향으로 사용한다. 다른 옵션은 텍스처 좌표를 변환하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7e0f671dd9e48393d5a72bafa91195c66750a973" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt; the object should fill has to be provided as an element in the parameter list of &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt;s.</source>
          <target state="translated">객체가 채워야 하는 &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt; 는 &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; 의 파라미터 목록에 요소로 제공되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="4f7737d606f85a800158bc14d6e2b5c25f820104" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;qml-qt-labs-folderlistmodel-folderlistmodel#nameFilters-prop&quot;&gt;nameFilters&lt;/a&gt; are not applied to directories.</source>
          <target state="translated">있습니다 &lt;a href=&quot;qml-qt-labs-folderlistmodel-folderlistmodel#nameFilters-prop&quot;&gt;nameFilters이&lt;/a&gt; 디렉토리에 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="848a7f528cc382a3f57c82fd54587b9b93c2c23f" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;qml-qtquick-controls-statusbar&quot;&gt;StatusBar&lt;/a&gt; does not provide a layout of its own, but requires you to position its contents, for instance by creating a &lt;a href=&quot;qml-qtquick-layouts-rowlayout&quot;&gt;RowLayout&lt;/a&gt;.</source>
          <target state="translated">있습니다 &lt;a href=&quot;qml-qtquick-controls-statusbar&quot;&gt;상태 바는&lt;/a&gt; 자신의 레이아웃을 제공하지만, 만들어 예를 들어, 그 내용을 위치하도록 요구하지 않습니다 &lt;a href=&quot;qml-qtquick-layouts-rowlayout&quot;&gt;RowLayout을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="08da4044255777a68025d93b76f91c05131a9c65" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;qml-qtquick-controls-toolbar&quot;&gt;ToolBar&lt;/a&gt; does not provide a layout of its own, but requires you to position its contents, for instance by creating a &lt;a href=&quot;qml-qtquick-layouts-rowlayout&quot;&gt;RowLayout&lt;/a&gt;.</source>
          <target state="translated">있습니다 &lt;a href=&quot;qml-qtquick-controls-toolbar&quot;&gt;도구 모음이&lt;/a&gt; 자신의 레이아웃을 제공하지만, 만들어 예를 들어, 그 내용을 위치하도록 요구하지 않습니다 &lt;a href=&quot;qml-qtquick-layouts-rowlayout&quot;&gt;RowLayout을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9b8af5841f7807fccfdc20638322e0e20b8e39ba" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;qml-qtquick-pathview&quot;&gt;PathView&lt;/a&gt; will layout the items based on the size of the root item in the delegate.</source>
          <target state="translated">있습니다 &lt;a href=&quot;qml-qtquick-pathview&quot;&gt;PathView은&lt;/a&gt; 대리인의 루트 항목의 크기에 따라 항목을 레이아웃합니다.</target>
        </trans-unit>
        <trans-unit id="883ed88b93a09e8abe33a455a25cd8011e045251" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;qml-qtquick-textedit&quot;&gt;TextEdit&lt;/a&gt; does not implement scrolling, following the cursor, or other behaviors specific to a look-and-feel. For example, to add flickable scrolling that follows the cursor:</source>
          <target state="translated">참고 것을 &lt;a href=&quot;qml-qtquick-textedit&quot;&gt;텍스트 편집기&lt;/a&gt; , 스크롤 모양과 느낌 커서, 또는 다른 행동의 특정에 따라 구현하지 않습니다. 예를 들어 커서 뒤에 긋기 가능한 스크롤을 추가하려면</target>
        </trans-unit>
        <trans-unit id="be1bd7a76bf7571d92956e8b72416f25aa6bdc1d" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;qobject#destroyed&quot;&gt;destroyed&lt;/a&gt;() signal will be emitted even if the signals for this object have been blocked.</source>
          <target state="translated">점을 유의 &lt;a href=&quot;qobject#destroyed&quot;&gt;파괴&lt;/a&gt; () 신호는이 오브젝트의 신호가 차단 된 경우에도 배출된다.</target>
        </trans-unit>
        <trans-unit id="cc33ace551357735af6e7ee6b05d46844bc799b2" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;qpagesize&quot;&gt;QPageSize&lt;/a&gt; is always defined in a Portrait orientation. To obtain a size that takes the set orientation into account you must use &lt;a href=&quot;qpagelayout#fullRect&quot;&gt;fullRect&lt;/a&gt;().</source>
          <target state="translated">있습니다 &lt;a href=&quot;qpagesize&quot;&gt;QPageSize는&lt;/a&gt; 항상 세로 방향으로 정의된다. 설정된 방향을 고려한 크기를 얻으려면 &lt;a href=&quot;qpagelayout#fullRect&quot;&gt;fullRect&lt;/a&gt; () 를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="5789c9cac29296f213e8281aa040208dea709628" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;qpluginloader&quot;&gt;QPluginLoader&lt;/a&gt; cannot be used if your application is statically linked against Qt. In this case, you will also have to link to plugins statically. You can use &lt;a href=&quot;qlibrary&quot;&gt;QLibrary&lt;/a&gt; if you need to load dynamic libraries in a statically linked application.</source>
          <target state="translated">있습니다 &lt;a href=&quot;qpluginloader&quot;&gt;QPluginLoader는&lt;/a&gt; 응용 프로그램이 정적으로 Qt는에 연결되어있는 경우 사용할 수 없습니다. 이 경우 플러그인에 정적으로 연결해야합니다. 정적으로 링크 된 응용 프로그램에서 동적 라이브러리를로드 &lt;a href=&quot;qlibrary&quot;&gt;해야하는&lt;/a&gt; 경우 QLibrary 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3d0c1071fd7ee101d6962994adc4391884e26494" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;qweakpointer&quot;&gt;QWeakPointer&lt;/a&gt;, &lt;a href=&quot;qsharedpointer&quot;&gt;QSharedPointer&lt;/a&gt; and &lt;a href=&quot;qpointer&quot;&gt;QPointer&lt;/a&gt; already have built-in support, and it is not necessary to use this macro with them.</source>
          <target state="translated">있습니다 &lt;a href=&quot;qweakpointer&quot;&gt;QWeakPointer&lt;/a&gt; , &lt;a href=&quot;qsharedpointer&quot;&gt;QSharedPointer&lt;/a&gt; 및 &lt;a href=&quot;qpointer&quot;&gt;QPointer가&lt;/a&gt; 이미 지원 내장 한, 그리고 그들과 함께이 매크로를 사용할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="443da81710d71b6f038a59388f6e320cdf06abfb" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;richtext-html-subset&quot;&gt;Supported HTML Subset&lt;/a&gt; is limited. Also, if the text contains HTML img tags that load remote images, the text is reloaded.</source>
          <target state="translated">있습니다 &lt;a href=&quot;richtext-html-subset&quot;&gt;지원되는 HTML 부분적인&lt;/a&gt; 제한됩니다. 또한 텍스트에 원격 이미지를로드하는 HTML img 태그가 포함 된 경우 텍스트가 다시로드됩니다.</target>
        </trans-unit>
        <trans-unit id="11e804fb15997803c6697cc12984b430a5f8e821" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;&amp;lt;Identifier&amp;gt;&lt;/code&gt; must be unique within a QML document, unlike the local namespace qualifier which can be applied to module imports.</source>
          <target state="translated">참고 그 &lt;code&gt;&amp;lt;Identifier&amp;gt;&lt;/code&gt; 모듈 수입에 적용 할 수있는 로컬 네임 스페이스 한정자는 달리, QML 문서 내에서 고유해야합니다.</target>
        </trans-unit>
        <trans-unit id="847b03b1eadcdf15f1e441daa9906758c0158006" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;GL_KHR_debug&lt;/code&gt; extension</source>
          <target state="translated">참고 그 &lt;code&gt;GL_KHR_debug&lt;/code&gt; 의 확장</target>
        </trans-unit>
        <trans-unit id="dd5320fdb8f9af4dbc0a389b6543464d9e0b799d" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;StringListModel&lt;/code&gt; is declared as a &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt;. This allows us to use the abstract interface to the model, and ensures that the code still works, even if we replace the string list model with a different model.</source>
          <target state="translated">있습니다 &lt;code&gt;StringListModel&lt;/code&gt; 는 A와 선언 &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; . 이를 통해 모델에 대한 추상 인터페이스를 사용할 수 있으며 문자열 목록 모델을 다른 모델로 바꾸어도 코드가 계속 작동합니다.</target>
        </trans-unit>
        <trans-unit id="4bedf3a189cbb6eea784bde270f844c0a127ce96" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;finished&lt;/code&gt; signals should always be emitted when a reply is complete, even if an error has been encountered, that is, if there is an error, both the &lt;code&gt;error&lt;/code&gt; and &lt;code&gt;finished&lt;/code&gt; signals should be emitted while if there is no error, only the &lt;code&gt;finished&lt;/code&gt; signals are emitted.</source>
          <target state="translated">것을 주 &lt;code&gt;finished&lt;/code&gt; 응답이 오류가 오류가있는 경우, 인 모두가, 발생 된 경우에도 완료되면 신호가 항상 발생해야 할 &lt;code&gt;error&lt;/code&gt; 및 &lt;code&gt;finished&lt;/code&gt; 신호가 방출되어야하는 동안 오류 만이없는 경우 &lt;code&gt;finished&lt;/code&gt; 신호가 방출됩니다.</target>
        </trans-unit>
        <trans-unit id="24001e235efaa1ed44fde131d9113fbc3e5060ba" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;import MyStyle 1.0&lt;/code&gt; statement is only necessary because we are using the attached property belonging to &lt;code&gt;MyStyle&lt;/code&gt;. Both buttons will use our custom style, even if we were to remove the import.</source>
          <target state="translated">점을 유의 &lt;code&gt;import MyStyle 1.0&lt;/code&gt; 우리가에 속하는 연결된 속성 사용하기 때문에 문에만 필요 &lt;code&gt;MyStyle&lt;/code&gt; 을 . 가져 오기를 제거하더라도 두 버튼 모두 사용자 정의 스타일을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="169a9baa56231264710348d06dc0240107d42b3b" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;setValue()&lt;/code&gt; function sets the value and emits the signal only if &lt;code&gt;value != m_value&lt;/code&gt;. This prevents infinite looping in the case of cyclic connections (e.g., if &lt;code&gt;b.valueChanged()&lt;/code&gt; were connected to &lt;code&gt;a.setValue()&lt;/code&gt;).</source>
          <target state="translated">점을 유의 &lt;code&gt;setValue()&lt;/code&gt; 함수의 값을 설정하고 신호 인 경우에만 방출 &lt;code&gt;value != m_value&lt;/code&gt; . 이 방지가 연결 고리의 경우에는 무한 루프 (경우, 예 &lt;code&gt;b.valueChanged()&lt;/code&gt; 접속 된 &lt;code&gt;a.setValue()&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="d3427cfdefa7ee4eb458261d9c8225164c95d019" translate="yes" xml:space="preserve">
          <source>Note that the JavaScript &lt;a href=&quot;qwebchannel&quot;&gt;QWebChannel&lt;/a&gt; object should be constructed once the transport object is fully operational. In case of a WebSocket, that means you should create the &lt;a href=&quot;qwebchannel&quot;&gt;QWebChannel&lt;/a&gt; in the socket's &lt;code&gt;onopen&lt;/code&gt; handler. Take a look at the &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtwebchannel-standalone-example.html#&quot;&gt;Qt WebChannel Standalone Example&lt;/a&gt; to see how this is done.</source>
          <target state="translated">전송 오브젝트가 완전히 작동되면 JavaScript &lt;a href=&quot;qwebchannel&quot;&gt;QWebChannel&lt;/a&gt; 오브젝트를 구성해야합니다. WebSocket의 경우 소켓의 &lt;code&gt;onopen&lt;/code&gt; 핸들러 에서 &lt;a href=&quot;qwebchannel&quot;&gt;QWebChannel&lt;/a&gt; 을 작성해야 합니다. 상기 봐 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtwebchannel-standalone-example.html#&quot;&gt;Qt는 WebChannel 독립 예&lt;/a&gt; 이 작업을 수행하는 방법을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="cf4e8eec1eef58c10d358a2a959d8098947d2a66" translate="yes" xml:space="preserve">
          <source>Note that the OLE default verbs (OLEIVERB_SHOW etc) are not included in the list.</source>
          <target state="translated">OLE 기본 동사 (OLEIVERB_SHOW 등)는 목록에 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="229af0d84a09c457b894ddbb9fe4392411055dfa" translate="yes" xml:space="preserve">
          <source>Note that the Qt 5 implementation has several limitations compared to Qt 4:</source>
          <target state="translated">Qt 5 구현에는 Qt 4와 비교하여 몇 가지 제한 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b015451bcc21149858e91a44c06edfabaebff8bb" translate="yes" xml:space="preserve">
          <source>Note that the Screen type is not valid at Component.onCompleted, because the Item or Window has not been displayed on a screen by this time.</source>
          <target state="translated">이때까지 화면에 항목 또는 창이 표시되지 않았으므로 Component.onCompleted에서 화면 유형이 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3767f8f7183ff0cc865c849df04238b920c0e22a" translate="yes" xml:space="preserve">
          <source>Note that the Windows registry and INI files use case-insensitive keys, whereas the CFPreferences API on &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; and iOS uses case-sensitive keys. To avoid portability problems, see the &lt;a href=&quot;qsettings#section-and-key-syntax&quot;&gt;Section and Key Syntax&lt;/a&gt; rules.</source>
          <target state="translated">Windows 레지스트리 및 INI 파일은 대소 문자를 구분하지 않는 반면 &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; 및 iOS 의 CFPreferences API 는 대소 문자를 구분하는 키를 사용합니다. 이식성 문제를 피하려면 &lt;a href=&quot;qsettings#section-and-key-syntax&quot;&gt;섹션 및 키 구문&lt;/a&gt; 규칙을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e54f3c9936e8755c3f611c9e401ab37239057acc" translate="yes" xml:space="preserve">
          <source>Note that the X11 version of Qt may not be able to deliver all combinations of style flags on all systems. This is because on X11, Qt can only ask the window manager, and the window manager can override the application's settings. On Windows, Qt can set whatever flags you want.</source>
          <target state="translated">Qt의 X11 버전은 모든 시스템에서 모든 스타일 플래그 조합을 제공하지 못할 수도 있습니다. X11에서 Qt는 창 관리자에게만 요청할 수 있고 창 관리자는 응용 프로그램의 설정을 무시할 수 있기 때문입니다. Windows에서 Qt는 원하는 플래그를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e0211eb64e32981a758c391a651471c0d36c0ead" translate="yes" xml:space="preserve">
          <source>Note that the abbreviation is not guaranteed to be unique to this time zone and should not be used in place of the ID or display name.</source>
          <target state="translated">약어가이 시간대에 고유 한 것은 아니며 ID 또는 표시 이름 대신 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="852e9cb9c82908ab574059bb5e79e98f6b9c67f6" translate="yes" xml:space="preserve">
          <source>Note that the above table assumes that the &lt;a href=&quot;qabstractitemview#selectionMode-prop&quot;&gt;selection mode&lt;/a&gt; allows the operations. For instance, you cannot select items if the selection mode is &lt;a href=&quot;qabstractitemview#SelectionMode-enum&quot;&gt;QAbstractItemView::NoSelection&lt;/a&gt;.</source>
          <target state="translated">위의 표는 &lt;a href=&quot;qabstractitemview#selectionMode-prop&quot;&gt;선택 모드&lt;/a&gt; 가 조작을 허용 한다고 가정합니다 . 예를 들어, 선택 모드가 &lt;a href=&quot;qabstractitemview#SelectionMode-enum&quot;&gt;QAbstractItemView :: NoSelection 인&lt;/a&gt; 경우 항목을 선택할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="0148c6bd22a3475f62649c7930a47a03263b034e" translate="yes" xml:space="preserve">
          <source>Note that the accuracy depends on the accuracy of the underlying operating system; not all systems provide 1-millisecond accuracy.</source>
          <target state="translated">정확도는 기본 운영 체제의 정확도에 따라 다릅니다. 모든 시스템이 1 밀리 초의 정확도를 제공하는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="ed4d8f71dbffc6db27ffa4bfd59e7fafeaf25102" translate="yes" xml:space="preserve">
          <source>Note that the advance can be negative if the text flows from the right to the left.</source>
          <target state="translated">텍스트가 오른쪽에서 왼쪽으로 흐르면 진행이 음수 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e908d2e98901bfed79aa1ea1f97660b5c5fb40fb" translate="yes" xml:space="preserve">
          <source>Note that the backslash character is, as mentioned, used by &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; to separate subkeys. As a result, you cannot read or write windows registry entries that contain slashes or backslashes; you should use a native windows API if you need to do so.</source>
          <target state="translated">백 슬래시 문자는 언급 한 바와 같이 &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; 에서 하위 키를 분리 하는 데 사용됩니다 . 결과적으로 슬래시 또는 백 슬래시가 포함 된 Windows 레지스트리 항목을 읽거나 쓸 수 없습니다. 필요한 경우 기본 Windows API를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="eb5e333044381a26153f8928fe1e9daecba13996" translate="yes" xml:space="preserve">
          <source>Note that the bottom-right corner of the rectangle is located at (rectangle.x() + rectangle.width(), rectangle.y() + rectangle.height()).</source>
          <target state="translated">사각형의 오른쪽 아래 모서리는 (rectangle.x () + rectangle.width (), rectangle.y () + rectangle.height ())에 있습니다.</target>
        </trans-unit>
        <trans-unit id="325cbe9d68d58d4d909f61f9a75daf02f3cc0379" translate="yes" xml:space="preserve">
          <source>Note that the bounding rectangle may extend to the left of (0, 0) (e.g., for italicized fonts), and that the text output may cover</source>
          <target state="translated">경계 사각형은 (0, 0)의 왼쪽으로 확장 될 수 있으며 (예를 들어, 기울임 꼴 글꼴의 경우) 텍스트 출력이 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="707914edba182845a169e1627d1004d86729d49d" translate="yes" xml:space="preserve">
          <source>Note that the bounding rectangle may extend to the left of (0, 0), e.g. for italicized fonts, and that the text output may cover</source>
          <target state="translated">경계 사각형은 예를 들어 기울임 꼴 글꼴의 경우 (0, 0) 왼쪽으로 확장 될 수 있으며 텍스트 출력은</target>
        </trans-unit>
        <trans-unit id="c771236b7ee696537501c5ca211c26c45a22f21b" translate="yes" xml:space="preserve">
          <source>Note that the bounding rectangle may extend to the left of (0, 0), e.g. for italicized fonts, and that the width of the returned rectangle might be different than what the width() method returns.</source>
          <target state="translated">경계 사각형은 예를 들어 기울임 꼴 글꼴의 경우 (0, 0) 왼쪽으로 확장 될 수 있으며 반환 된 사각형의 너비는 width () 메서드가 반환하는 너비와 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f0f399e60141cfdf7b8e99fce423542727fe9be" translate="yes" xml:space="preserve">
          <source>Note that the bounding rectangle may extend to the left of (0, 0), e.g. for italicized fonts.</source>
          <target state="translated">경계 사각형은 예를 들어 기울임 꼴 글꼴의 경우 (0, 0) 왼쪽으로 확장 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="28b0bbfe6b5f2cc2a394de11dc969d0d3b51ac63" translate="yes" xml:space="preserve">
          <source>Note that the browser will automatically handle navigation to the location specified by</source>
          <target state="translated">브라우저는 자동으로 지정된 위치로 탐색을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="3289388ea3a9a49dc7a89778d94522f9dd785d10" translate="yes" xml:space="preserve">
          <source>Note that the cached</source>
          <target state="translated">캐시 된</target>
        </trans-unit>
        <trans-unit id="314342d4daec76f3494228d982af274c12086a69" translate="yes" xml:space="preserve">
          <source>Note that the call is made after the value of the slider has changed because clients may query the new value immediately after receiving the event.</source>
          <target state="translated">클라이언트는 이벤트를받은 직후 새 값을 쿼리 할 수 ​​있으므로 슬라이더 값이 변경된 후에 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="48ffbe89128006e15be16697870df5f0efcdbd37" translate="yes" xml:space="preserve">
          <source>Note that the case folding rules in &lt;a href=&quot;http://www.rfc-editor.org/rfc/rfc3491.txt&quot;&gt;Nameprep&lt;/a&gt;, which &lt;a href=&quot;qurl&quot;&gt;QUrl&lt;/a&gt; conforms to, require host names to always be converted to lower case, regardless of the Qt::FormattingOptions used.</source>
          <target state="translated">의 규칙 접는 경우주의 &lt;a href=&quot;http://www.rfc-editor.org/rfc/rfc3491.txt&quot;&gt;Nameprep&lt;/a&gt; , &lt;a href=&quot;qurl&quot;&gt;QUrl의&lt;/a&gt; 에 부합는 호스트 이름을 필요가에 관계없이 항상 사용되는 Qt는 :: FormattingOptions의, 소문자로 변환 할.</target>
        </trans-unit>
        <trans-unit id="7682973b3120d58851f9effe32d9a34d1083aeda" translate="yes" xml:space="preserve">
          <source>Note that the cell's row or column span cannot be changed through this function. You have to use &lt;a href=&quot;qtexttable#mergeCells&quot;&gt;QTextTable::mergeCells&lt;/a&gt; and &lt;a href=&quot;qtexttable#splitCell&quot;&gt;QTextTable::splitCell&lt;/a&gt; instead.</source>
          <target state="translated">이 함수를 통해 셀의 행 또는 열 범위를 변경할 수 없습니다. 당신은 사용할 필요가 &lt;a href=&quot;qtexttable#mergeCells&quot;&gt;QTextTable :: mergeCells&lt;/a&gt; 및 &lt;a href=&quot;qtexttable#splitCell&quot;&gt;QTextTable :: splitCell을&lt;/a&gt; 대신.</target>
        </trans-unit>
        <trans-unit id="85d8ab4ac3b37b4c7d021c759097d7469ebaf9c1" translate="yes" xml:space="preserve">
          <source>Note that the class this macro appears on must be default-constructible.</source>
          <target state="translated">이 매크로가 나타나는 클래스는 기본 구성 가능해야합니다.</target>
        </trans-unit>
        <trans-unit id="5064a7dc6e6ea23f708a51a763c18f03d0162e11" translate="yes" xml:space="preserve">
          <source>Note that the client must create a &lt;a href=&quot;qml-qtlocation-plugin&quot;&gt;Plugin&lt;/a&gt; object prior to using a &lt;a href=&quot;qml-qtlocation-geocodemodel&quot;&gt;GeocodeModel&lt;/a&gt; object. This will enable access to geocoding translation services and thus data to display.</source>
          <target state="translated">클라이언트는 &lt;a href=&quot;qml-qtlocation-geocodemodel&quot;&gt;GeocodeModel&lt;/a&gt; 객체 를 사용하기 전에 &lt;a href=&quot;qml-qtlocation-plugin&quot;&gt;플러그인&lt;/a&gt; 객체를 생성해야 합니다. 이를 통해 지오 코딩 번역 서비스에 액세스하여 데이터를 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e8b66c740d15bee812b8551bdcfcab156e5d9aaa" translate="yes" xml:space="preserve">
          <source>Note that the client must create a &lt;a href=&quot;qml-qtlocation-plugin&quot;&gt;Plugin&lt;/a&gt; object prior to using a &lt;a href=&quot;qml-qtlocation-map&quot;&gt;Map&lt;/a&gt; type in order to have access to map data to display.</source>
          <target state="translated">참고 클라이언트가 만들어야합니다 &lt;a href=&quot;qml-qtlocation-plugin&quot;&gt;플러그인&lt;/a&gt; 사용하기 전에 객체 &lt;a href=&quot;qml-qtlocation-map&quot;&gt;지도&lt;/a&gt; 표시에 데이터를 매핑 할 수있는 권한을 부여하기 위해 유형입니다.</target>
        </trans-unit>
        <trans-unit id="ae67cc6a3ab43e5a3869b3f1214618218d4e360c" translate="yes" xml:space="preserve">
          <source>Note that the clip path is specified in logical (painter) coordinates.</source>
          <target state="translated">클립 경로는 논리적 (페인터) 좌표로 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="a38abca040e3cdb6d47138e2b2c3fbb1c0a03b6e" translate="yes" xml:space="preserve">
          <source>Note that the clip rectangle is specified in logical (painter) coordinates.</source>
          <target state="translated">클립 사각형은 논리적 (페인터) 좌표로 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="2d7701a9538ff16a9044f38e4bf6dafef71df804" translate="yes" xml:space="preserve">
          <source>Note that the clip region is given in logical coordinates.</source>
          <target state="translated">클립 영역은 논리 좌표로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="5eea3e8da34c985476b9afdef3fd4e653250f4b1" translate="yes" xml:space="preserve">
          <source>Note that the columns and rows are not equally wide or tall. If you want two columns to have the same width, you must set their minimum widths and stretch factors to be the same yourself. You do this using &lt;a href=&quot;qgridlayout#setColumnMinimumWidth&quot;&gt;setColumnMinimumWidth&lt;/a&gt;() and &lt;a href=&quot;qgridlayout#setColumnStretch&quot;&gt;setColumnStretch&lt;/a&gt;().</source>
          <target state="translated">열과 행의 너비가 같거나 크지 않습니다. 두 열의 너비를 동일하게하려면 최소 너비와 신축 계수를 동일하게 설정해야합니다. &lt;a href=&quot;qgridlayout#setColumnMinimumWidth&quot;&gt;setColumnMinimumWidth&lt;/a&gt; () 및 &lt;a href=&quot;qgridlayout#setColumnStretch&quot;&gt;setColumnStretch&lt;/a&gt; ()를 사용하여이를 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="d39d60e3609de62033a530aed40347b59d63e292" translate="yes" xml:space="preserve">
          <source>Note that the components in the returned margins will be rounded to the nearest integer.</source>
          <target state="translated">반환 된 여백의 구성 요소는 가장 가까운 정수로 반올림됩니다.</target>
        </trans-unit>
        <trans-unit id="0f823aeaa046ecce3ad267e5999091669af618af" translate="yes" xml:space="preserve">
          <source>Note that the coordinates in the returned size will be rounded to the nearest integer.</source>
          <target state="translated">반환 된 크기의 좌표는 가장 가까운 정수로 반올림됩니다.</target>
        </trans-unit>
        <trans-unit id="48374ac232976bb7985981e60071906b684b660d" translate="yes" xml:space="preserve">
          <source>Note that the core profile might still contain functionality that is deprecated and scheduled for removal in a higher version. To get access to the deprecated functionality for the core profile in the set &lt;a href=&quot;qsurfaceformat#RenderableType-enum&quot;&gt;OpenGL&lt;/a&gt; version you can use the &lt;a href=&quot;qsurfaceformat&quot;&gt;QSurfaceFormat&lt;/a&gt; format option &lt;a href=&quot;qsurfaceformat#FormatOption-enum&quot;&gt;QSurfaceFormat::DeprecatedFunctions&lt;/a&gt;.</source>
          <target state="translated">코어 프로파일에는 더 이상 사용되지 않으며 상위 버전에서 제거 될 예정인 기능이 여전히 포함되어있을 수 있습니다. 설정된 &lt;a href=&quot;qsurfaceformat#RenderableType-enum&quot;&gt;OpenGL&lt;/a&gt; 버전 에서 코어 프로파일에 대해 더 이상 사용되지 않는 기능에 액세스하려면 &lt;a href=&quot;qsurfaceformat&quot;&gt;QSurfaceFormat&lt;/a&gt; 형식 옵션 &lt;a href=&quot;qsurfaceformat#FormatOption-enum&quot;&gt;QSurfaceFormat :: DeprecatedFunctions를&lt;/a&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0ae6c1d12d36517de4bb5e0f90708fcb35acb56d" translate="yes" xml:space="preserve">
          <source>Note that the counter wraps to zero 24 hours after the last call to &lt;a href=&quot;qtime#start&quot;&gt;start&lt;/a&gt;() or restart().</source>
          <target state="translated">마지막으로 &lt;a href=&quot;qtime#start&quot;&gt;start&lt;/a&gt; () 또는 restart ()를 호출 한 후 24 시간 후에 카운터가 0으로 줄어 듭니다 .</target>
        </trans-unit>
        <trans-unit id="b6b9d30b05b6d8cf3a8cf9a764cec79541ff9fe5" translate="yes" xml:space="preserve">
          <source>Note that the counter wraps to zero 24 hours after the last call to &lt;a href=&quot;qtime#start&quot;&gt;start&lt;/a&gt;() or restart.</source>
          <target state="translated">마지막 호출 &lt;a href=&quot;qtime#start&quot;&gt;시작&lt;/a&gt; () 또는 다시 시작 후 24 시간 후에 카운터가 0으로 줄어 듭니다 .</target>
        </trans-unit>
        <trans-unit id="bd9402145b1ef822d74b672bfcffb11c0dd774f6" translate="yes" xml:space="preserve">
          <source>Note that the current position after the polygon has been added, is the last point in</source>
          <target state="translated">다각형이 추가 된 후의 현재 위치는</target>
        </trans-unit>
        <trans-unit id="0b794bfe794be254cb14d7e88deadf9756fbbf08" translate="yes" xml:space="preserve">
          <source>Note that the cursor does not have to be moved after each search and replace operation; it is always positioned at the end of the word that was just replaced.</source>
          <target state="translated">각 검색 및 바꾸기 작업 후에 커서를 이동할 필요는 없습니다. 항상 바뀐 단어의 끝에 위치합니다.</target>
        </trans-unit>
        <trans-unit id="2ef3a75ce01f98f39d85fc33db9a342f073aae65" translate="yes" xml:space="preserve">
          <source>Note that the cursor was moved from the start of the first line to the end, but that it retained an anchor at the start of the line. This demonstrates the cursor-based selection facilities of the &lt;a href=&quot;qtextcursor&quot;&gt;QTextCursor&lt;/a&gt; class.</source>
          <target state="translated">커서는 첫 번째 줄의 시작에서 끝으로 이동했지만 줄의 시작 부분에 앵커가 유지되었습니다. &lt;a href=&quot;qtextcursor&quot;&gt;QTextCursor&lt;/a&gt; 클래스 의 커서 기반 선택 기능을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="f4344b0917fe95c30466ba8c90df7e41e15135ec" translate="yes" xml:space="preserve">
          <source>Note that the custom deleter function will be called with a pointer to type &lt;code&gt;X&lt;/code&gt;, even if the &lt;a href=&quot;qsharedpointer&quot;&gt;QSharedPointer&lt;/a&gt; template parameter &lt;code&gt;T&lt;/code&gt; is not the same.</source>
          <target state="translated">&lt;a href=&quot;qsharedpointer&quot;&gt;QSharedPointer&lt;/a&gt; 템플릿 매개 변수 &lt;code&gt;T&lt;/code&gt; 가 동일하지 않더라도 사용자 지정 삭제 기능은 &lt;code&gt;X&lt;/code&gt; 유형에 대한 포인터와 함께 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="4a65219443f2b873003a4874c7d28cb57269c34c" translate="yes" xml:space="preserve">
          <source>Note that the dash pattern is specified in units of the pens width, e.g. a dash of length 5 in width 10 is 50 pixels long.</source>
          <target state="translated">대시 패턴은 펜 너비 단위로 지정됩니다. 예를 들어 너비 10의 길이 5의 대시 길이는 50 픽셀입니다.</target>
        </trans-unit>
        <trans-unit id="a4fd2b4329f63dd121a447af866e189849bc1933" translate="yes" xml:space="preserve">
          <source>Note that the default cap style is &lt;a href=&quot;qt#PenCapStyle-enum&quot;&gt;Qt::SquareCap&lt;/a&gt;, meaning that a square line end covers the end point and extends beyond it by half the line width.</source>
          <target state="translated">기본 캡 스타일은 &lt;a href=&quot;qt#PenCapStyle-enum&quot;&gt;Qt :: SquareCap&lt;/a&gt; 이며, 사각형 선 끝이 끝점을 덮고 선 너비의 절반으로 연장됩니다.</target>
        </trans-unit>
        <trans-unit id="62d524079313cf9229dd28b3f002e23af3010954" translate="yes" xml:space="preserve">
          <source>Note that the default formatVersion is -1 which signifies the current release, i.e. for Qt 4.0 a formatVersion of 7 is the same as the default formatVersion of -1.</source>
          <target state="translated">기본 formatVersion은 -1이며 현재 릴리스를 나타냅니다. 즉 Qt 4.0의 경우 formatVersion 7은 기본 formatVersion -1과 같습니다.</target>
        </trans-unit>
        <trans-unit id="82fed073baa252e940c1136a19a877053569592f" translate="yes" xml:space="preserve">
          <source>Note that the default implementation does nothing. Reasonable actions in this function might be to call the QWidget::setBackgroundMode() function for the widget. Do not use the function to set, for example, the geometry. Reimplementing this function provides a back-door through which the appearance of a widget can be changed, but with Qt's style engine it is rarely necessary to implement this function; reimplement &lt;a href=&quot;qstyle#drawItemPixmap&quot;&gt;drawItemPixmap&lt;/a&gt;(), &lt;a href=&quot;qstyle#drawItemText&quot;&gt;drawItemText&lt;/a&gt;(), &lt;a href=&quot;qstyle#drawPrimitive&quot;&gt;drawPrimitive&lt;/a&gt;(), etc. instead.</source>
          <target state="translated">기본 구현은 아무 것도 수행하지 않습니다. 이 함수에서 합리적인 조치는 위젯에 대한 QWidget :: setBackgroundMode () 함수를 호출하는 것입니다. 예를 들어 형상을 설정하기 위해이 기능을 사용하지 마십시오. 이 함수를 다시 구현하면 위젯의 모양을 변경할 수있는 백도어가 제공되지만 Qt의 스타일 엔진에서는이 기능을 구현할 필요가 거의 없습니다. &lt;a href=&quot;qstyle#drawItemPixmap&quot;&gt;대신 drawItemPixmap&lt;/a&gt; (), &lt;a href=&quot;qstyle#drawItemText&quot;&gt;drawItemText&lt;/a&gt; (), &lt;a href=&quot;qstyle#drawPrimitive&quot;&gt;drawPrimitive&lt;/a&gt; () 등을 다시 구현 하십시오 .</target>
        </trans-unit>
        <trans-unit id="f7de95b609328e3a8b48fdd1fb4fe5574e9e524c" translate="yes" xml:space="preserve">
          <source>Note that the definition of contentItem is somewhat different to that of a Flickable, where the contentItem is implicitly created.</source>
          <target state="translated">contentItem의 정의는 contentItem이 암시 적으로 생성되는 Flickable의 정의와 다소 다릅니다.</target>
        </trans-unit>
        <trans-unit id="c86a3a07e679a7f62ae8a994fbc370417d3425bd" translate="yes" xml:space="preserve">
          <source>Note that the desired attachments or number of samples per pixels might not be supported by the hardware driver. Call &lt;a href=&quot;qopenglframebufferobject#format&quot;&gt;QOpenGLFramebufferObject::format&lt;/a&gt;() after creating a &lt;a href=&quot;qopenglframebufferobject&quot;&gt;QOpenGLFramebufferObject&lt;/a&gt; to find the exact format that was used to create the frame buffer object.</source>
          <target state="translated">하드웨어 드라이버가 원하는 첨부 파일 또는 픽셀 당 샘플 수를 지원하지 않을 수 있습니다. 전화 &lt;a href=&quot;qopenglframebufferobject#format&quot;&gt;QOpenGLFramebufferObject :: 형식&lt;/a&gt; ()을 만든 후 &lt;a href=&quot;qopenglframebufferobject&quot;&gt;QOpenGLFramebufferObject를&lt;/a&gt; 프레임 버퍼 오브젝트를 만드는 데 사용 된 정확한 형식을 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="67e3f5412a1c3d6dd9308d1bd5ffe67faebceb62" translate="yes" xml:space="preserve">
          <source>Note that the directory separator &quot;/&quot; works for all operating systems supported by Qt.</source>
          <target state="translated">디렉토리 구분 기호 &quot;/&quot;는 Qt가 지원하는 모든 운영 체제에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="f34e042dfddf3714609c625f77139543f539c80f" translate="yes" xml:space="preserve">
          <source>Note that the distinction only matters for decorated top-level widgets. For all child widgets, the frame geometry is equal to the widget's client geometry.</source>
          <target state="translated">이 구별은 장식 된 최상위 위젯에만 중요합니다. 모든 하위 위젯에서 프레임 지오메트리는 위젯의 클라이언트 지오메트리와 같습니다.</target>
        </trans-unit>
        <trans-unit id="819be5c77c822d0cbad93516cd9733af4b97e471" translate="yes" xml:space="preserve">
          <source>Note that the documentation must be in the implementation files such as &lt;code&gt;.cpp&lt;/code&gt;.</source>
          <target state="translated">설명서는 &lt;code&gt;.cpp&lt;/code&gt; 와 같은 구현 파일에 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="0b1782616a78d8ac7424ef4e086a7462fee0635e" translate="yes" xml:space="preserve">
          <source>Note that the domain here may start with a dot, which is not a valid hostname. However, it means this cookie matches all hostnames ending with that domain name.</source>
          <target state="translated">여기서 도메인은 유효한 호스트 이름이 아닌 점으로 시작할 수 있습니다. 그러나이 쿠키는 해당 도메인 이름으로 끝나는 모든 호스트 이름과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="b168e0d47e1f437fb7d5d20f2b63bc27a92b75ac" translate="yes" xml:space="preserve">
          <source>Note that the effect of this property is noticeable when only a part of the scene is visible (i.e., when there are scroll bars). Otherwise, if the whole scene fits in the view, &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; uses the view &lt;a href=&quot;stylesheet-reference#alignment&quot;&gt;alignment&lt;/a&gt; to position the scene in the view.</source>
          <target state="translated">이 속성의 효과는 장면의 일부만 표시 될 때 (즉, 스크롤 막대가있는 경우) 눈에 that니다. 그렇지 않으면 전체 장면이 뷰에 맞는 경우 &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; 은 뷰 &lt;a href=&quot;stylesheet-reference#alignment&quot;&gt;정렬&lt;/a&gt; 을 사용하여 뷰 에 장면을 배치합니다.</target>
        </trans-unit>
        <trans-unit id="67becbf68ca11b5bc8a50699805e2bd85c152252" translate="yes" xml:space="preserve">
          <source>Note that the eventTest method of the</source>
          <target state="translated">의 eventTest 메소드는</target>
        </trans-unit>
        <trans-unit id="e595a3869e4468665555af631a672501ea886e7e" translate="yes" xml:space="preserve">
          <source>Note that the example above is somewhat simplified and will not animate an indeterminate progress bar. The following snippet demonstrates how you can incorporate a custom animation for the indeterminate state as well.</source>
          <target state="translated">위의 예제는 다소 단순화되었으며 결정되지 않은 진행률 표시 줄에 애니메이션을 적용하지 않습니다. 다음 스 니펫은 불확정 상태에 대한 사용자 정의 애니메이션을 통합하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="39ab2934220126d057120154985a67129943c436" translate="yes" xml:space="preserve">
          <source>Note that the exec() function does not block the main event loop.</source>
          <target state="translated">exec () 함수는 기본 이벤트 루프를 차단하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b16783b3a0bb8381ae231b893bc7b8061a5e5a43" translate="yes" xml:space="preserve">
          <source>Note that the file descriptor returned by this function is owned by the &lt;a href=&quot;qdbusunixfiledescriptor&quot;&gt;QDBusUnixFileDescriptor&lt;/a&gt; object and must not be stored past the lifetime of this object. It is ok to use it while this object is valid, but if one wants to store it for longer use, the file descriptor should be cloned using the Unix &lt;code&gt;dup(2)&lt;/code&gt;, &lt;code&gt;dup2(2)&lt;/code&gt; or &lt;code&gt;dup3(2)&lt;/code&gt; functions.</source>
          <target state="translated">이 함수가 리턴 한 파일 디스크립터는 &lt;a href=&quot;qdbusunixfiledescriptor&quot;&gt;QDBusUnixFileDescriptor&lt;/a&gt; 오브젝트 가 소유 하며이 오브젝트의 수명이 지난 후에 저장해서는 안됩니다. 이 객체가 유효한 동안 사용하는 것이 좋지만, 더 오래 사용하기 위해 저장하려면 파일 기술자는 Unix &lt;code&gt;dup(2)&lt;/code&gt; , &lt;code&gt;dup2(2)&lt;/code&gt; 또는 &lt;code&gt;dup3(2)&lt;/code&gt; 함수를 사용하여 복제해야합니다 .</target>
        </trans-unit>
        <trans-unit id="256a897c0b69dfc07308e13a93c590816fa4113b" translate="yes" xml:space="preserve">
          <source>Note that the file name describes the font, for example &lt;code&gt;helvetica_120_50.qpf&lt;/code&gt; is 12 point Helvetica while &lt;code&gt;helvetica_120_50i.qpf&lt;/code&gt; is 12 point Helvetica</source>
          <target state="translated">파일 이름은 글꼴을 나타냅니다. 예를 들어 &lt;code&gt;helvetica_120_50.qpf&lt;/code&gt; 는 12 포인트 Helvetica이고 &lt;code&gt;helvetica_120_50i.qpf&lt;/code&gt; 는 12 포인트 Helvetica입니다.</target>
        </trans-unit>
        <trans-unit id="81113b71aa29f8d0d48997ab8ee0623f76feda81" translate="yes" xml:space="preserve">
          <source>Note that the filter &lt;b&gt;*.*&lt;/b&gt; is not portable, because the historical assumption that the file extension determines the file type is not consistent on every operating system. It is possible to have a file with no dot in its name (for example, &lt;code&gt;Makefile&lt;/code&gt;). In a native Windows file dialog, &lt;b&gt;*.*&lt;/b&gt; will match such files, while in other types of file dialogs it may not. So it is better to use &lt;b&gt;*&lt;/b&gt; if you mean to select any file.</source>
          <target state="translated">파일 확장자가 파일 유형을 결정한다는 이전 가정은 모든 운영 체제에서 일치하지 않기 때문에 &lt;b&gt;*. *&lt;/b&gt; 필터 는 이식성이 없습니다. 이름에 점이없는 파일을 가질 수 있습니다 (예 : &lt;code&gt;Makefile&lt;/code&gt; ). 기본 Windows 파일 대화 상자에서 &lt;b&gt;*. *&lt;/b&gt; 는 이러한 파일과 일치하지만 다른 유형의 파일 대화 상자에서는 그렇지 않을 수 있습니다. 따라서 파일을 선택하려는 경우 &lt;b&gt;*&lt;/b&gt; 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="88b31df53d2843275a4bc52ea67c308d28da48ca" translate="yes" xml:space="preserve">
          <source>Note that the filter you set should always include the &lt;a href=&quot;qdir#Filter-enum&quot;&gt;QDir::AllDirs&lt;/a&gt; enum value, otherwise &lt;a href=&quot;qdirmodel&quot;&gt;QDirModel&lt;/a&gt; won't be able to read the directory structure.</source>
          <target state="translated">설정 한 필터는 항상 &lt;a href=&quot;qdir#Filter-enum&quot;&gt;QDir :: AllDirs&lt;/a&gt; 열거 형 값을 포함해야 합니다. 그렇지 않으면 &lt;a href=&quot;qdirmodel&quot;&gt;QDirModel&lt;/a&gt; 은 디렉토리 구조를 읽을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a35492801d6ab66071be6d1fea554315a969fce9" translate="yes" xml:space="preserve">
          <source>Note that the filter you set should always include the &lt;a href=&quot;qdir#Filter-enum&quot;&gt;QDir::AllDirs&lt;/a&gt; enum value, otherwise &lt;a href=&quot;qfilesystemmodel&quot;&gt;QFileSystemModel&lt;/a&gt; won't be able to read the directory structure.</source>
          <target state="translated">설정 한 필터는 항상 &lt;a href=&quot;qdir#Filter-enum&quot;&gt;QDir :: AllDirs&lt;/a&gt; 열거 형 값을 포함해야 합니다. 그렇지 않으면 &lt;a href=&quot;qfilesystemmodel&quot;&gt;QFileSystemModel&lt;/a&gt; 이 디렉토리 구조를 읽을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="68319831252ba922216f1bb4d48728c857090e12" translate="yes" xml:space="preserve">
          <source>Note that the filtering object must be in the same thread as this object. If</source>
          <target state="translated">필터링 개체는이 개체와 동일한 스레드에 있어야합니다. 만약</target>
        </trans-unit>
        <trans-unit id="6302bec68787b67d2a1cbc343c582c7c263c8585" translate="yes" xml:space="preserve">
          <source>Note that the first position in the sequence is position 1, not 0. We can also select</source>
          <target state="translated">시퀀스의 첫 번째 위치는 0이 아니라 위치 1입니다.</target>
        </trans-unit>
        <trans-unit id="cd581dfb7d8fbe77f96131d6ac68373f3ee6603f" translate="yes" xml:space="preserve">
          <source>Note that the font filtering options might not be supported on some platforms (e.g. Mac). They are always supported by the non native dialog (used on Windows or Linux).</source>
          <target state="translated">일부 플랫폼 (예 : Mac)에서는 글꼴 필터링 옵션이 지원되지 않을 수 있습니다. 비 기본 대화 상자 (Windows 또는 Linux에서 사용)에서 항상 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="1a38e49065048ff8caee838f309af1816aa49a31" translate="yes" xml:space="preserve">
          <source>Note that the frame width depends on the &lt;a href=&quot;qframe#setFrameStyle&quot;&gt;frame style&lt;/a&gt;, not only the line width and the mid-line width. For example, the style specified by &lt;a href=&quot;qframe#Shape-enum&quot;&gt;NoFrame&lt;/a&gt; always has a frame width of 0, whereas the style &lt;a href=&quot;qframe#Shape-enum&quot;&gt;Panel&lt;/a&gt; has a frame width equivalent to the line width.</source>
          <target state="translated">프레임 너비 는 선 너비와 중간 선 너비뿐만 아니라 &lt;a href=&quot;qframe#setFrameStyle&quot;&gt;프레임 스타일&lt;/a&gt; 에 따라 달라집니다 . 예를 들어 &lt;a href=&quot;qframe#Shape-enum&quot;&gt;NoFrame으로&lt;/a&gt; 지정된 스타일 의 프레임 너비는 항상 0 인 반면 스타일 &lt;a href=&quot;qframe#Shape-enum&quot;&gt;패널&lt;/a&gt; 의 프레임 너비는 선 너비와 같습니다.</target>
        </trans-unit>
        <trans-unit id="d148334bb561943c8c6d9555e3ae152be884e1cc" translate="yes" xml:space="preserve">
          <source>Note that the front end must call &lt;a href=&quot;qsensor#active-prop&quot;&gt;QSensor::isActive&lt;/a&gt;() to see if the sensor has stopped. If the sensor has stopped due to an error the &lt;a href=&quot;qsensorbackend#sensorError&quot;&gt;sensorError&lt;/a&gt;() function should be called to notify the class of the error condition.</source>
          <target state="translated">센서가 중지되었는지 확인 하려면 프론트 엔드가 &lt;a href=&quot;qsensor#active-prop&quot;&gt;QSensor :: isActive&lt;/a&gt; ()를 호출해야합니다 . 오류로 인해 센서가 중지 된 경우 오류 조건을 클래스에 알리기 위해 &lt;a href=&quot;qsensorbackend#sensorError&quot;&gt;sensorError&lt;/a&gt; () 함수를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="ae7cee952c4e8e079004277c3b7087eb941bff65" translate="yes" xml:space="preserve">
          <source>Note that the front end must call &lt;a href=&quot;qsensor#busy-prop&quot;&gt;QSensor::isBusy&lt;/a&gt;() to see if the sensor is busy. If the sensor has stopped due to an error the &lt;a href=&quot;qsensorbackend#sensorError&quot;&gt;sensorError&lt;/a&gt;() function should be called to notify the class of the error condition.</source>
          <target state="translated">센서가 사용 중인지 확인 하려면 프론트 엔드가 &lt;a href=&quot;qsensor#busy-prop&quot;&gt;QSensor :: isBusy&lt;/a&gt; ()를 호출해야합니다 . 오류로 인해 센서가 중지 된 경우 오류 조건을 클래스에 알리기 위해 &lt;a href=&quot;qsensorbackend#sensorError&quot;&gt;sensorError&lt;/a&gt; () 함수를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="37ce3668e57b8a855281855a6f74dbb881ed7832" translate="yes" xml:space="preserve">
          <source>Note that the generated flags in</source>
          <target state="translated">생성 된 플래그는</target>
        </trans-unit>
        <trans-unit id="c3c21bdbc746d5bf2a6883286a2e0059eb273650" translate="yes" xml:space="preserve">
          <source>Note that the given starting attributes can be modified at any point in the particle's lifetime by any Affector element in the same &lt;a href=&quot;qml-qtquick-particles-particlesystem&quot;&gt;ParticleSystem&lt;/a&gt;. This includes attributes like lifespan.</source>
          <target state="translated">주어진 시작 속성은 동일한 &lt;a href=&quot;qml-qtquick-particles-particlesystem&quot;&gt;ParticleSystem의&lt;/a&gt; Affector 요소에 의해 입자 수명의 어느 시점에서나 수정 될 수 있습니다 . 여기에는 수명과 같은 속성이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="e805563d665203996dcefd45f7dd2eb482048249" translate="yes" xml:space="preserve">
          <source>Note that the handler will always be called from within the same thread that calls &lt;a href=&quot;qdesktopservices#openUrl&quot;&gt;QDesktopServices::openUrl&lt;/a&gt;().</source>
          <target state="translated">핸들러는 항상 &lt;a href=&quot;qdesktopservices#openUrl&quot;&gt;QDesktopServices :: openUrl&lt;/a&gt; () 을 호출하는 동일한 스레드 내에서 호출 됩니다.</target>
        </trans-unit>
        <trans-unit id="333951bb8fc7fcf7a3291b86521cc9555bada48c" translate="yes" xml:space="preserve">
          <source>Note that the heights shown above may vary based on differences in fonts across platforms.</source>
          <target state="translated">위에 표시된 높이는 플랫폼 간 글꼴 차이에 따라 달라질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6cb2ab9936e43e6fc91819d84a228ba5e5fbc3b" translate="yes" xml:space="preserve">
          <source>Note that the highlight animation also affects the way that the view is scrolled. This is because the view moves to maintain the highlight within the preferred highlight range (or visible viewport).</source>
          <target state="translated">하이라이트 애니메이션은 또한 뷰가 스크롤되는 방식에 영향을줍니다. 뷰가 선호하는 하이라이트 범위 (또는 가시적 뷰포트) 내에서 하이라이트를 유지하기 위해 이동하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="beb3ea60d1fd624060bb2430f37f4fbcb284615b" translate="yes" xml:space="preserve">
          <source>Note that the identifier is filled out automatically when the sensor is connected to a backend. If you want to connect a specific backend, you should call setIdentifier() before &lt;a href=&quot;qsensor#connectToBackend&quot;&gt;connectToBackend&lt;/a&gt;().</source>
          <target state="translated">센서가 백엔드에 연결되면 식별자가 자동으로 채워집니다. 특정 백엔드를 연결하려면 &lt;a href=&quot;qsensor#connectToBackend&quot;&gt;connectToBackend&lt;/a&gt; () 전에 setIdentifier ()를 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="31960ba6052bcfd7f051eecf9cb199501baf00c4" translate="yes" xml:space="preserve">
          <source>Note that the identifiers are case-insensitive, but the rest of the URL will be passed on with preserved case. For example, the below snippet would still specify that the image is loaded by the image provider named &quot;myimageprovider&quot;, but it would request a different image than the above snippet (&quot;Image.png&quot; instead of &quot;image.png&quot;).</source>
          <target state="translated">식별자는 대소 문자를 구분하지 않지만 나머지 URL은 대소 문자를 구분하여 전달됩니다. 예를 들어 아래 스 니펫은 여전히 ​​&quot;myimageprovider&quot;라는 이미지 제공자가 이미지를로드하도록 지정하지만 위 스 니펫 ( &quot;image.png&quot;대신 &quot;Image.png&quot;)과 다른 이미지를 요청합니다.</target>
        </trans-unit>
        <trans-unit id="704bfb5be3b1cbb315853d9a796bb5ebd256033e" translate="yes" xml:space="preserve">
          <source>Note that the images are expected to be tightly packed in the atlas: the width and height of the cursors are decided based on the total image size and the &lt;code&gt;cursorsPerRow&lt;/code&gt; setting. Atlases have to provide an image for all the supported cursors.</source>
          <target state="translated">이미지는 아틀라스에 꽉 채워져 있어야합니다. 커서의 너비와 높이는 총 이미지 크기와 &lt;code&gt;cursorsPerRow&lt;/code&gt; 설정 에 따라 결정 됩니다. Atlases는 지원되는 모든 커서에 대한 이미지를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="b2d65c3a23309150efa0d935b067e1fa65e74969" translate="yes" xml:space="preserve">
          <source>Note that the images are white and semi-transparent, to allow colorization and alpha levels to have maximum effect.</source>
          <target state="translated">이미지는 흰색과 반투명하므로 색상 및 알파 수준이 최대의 효과를 낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b4d5d131fa03e05ee92754ff1468a23aa4a0db7" translate="yes" xml:space="preserve">
          <source>Note that the implementation of the &lt;a href=&quot;qhash#qHashx&quot;&gt;qHash&lt;/a&gt;() overloads offered by Qt may change at any time. You &lt;b&gt;must not&lt;/b&gt; rely on the fact that &lt;a href=&quot;qhash#qHashx&quot;&gt;qHash&lt;/a&gt;() will give the same results (for the same inputs) across different Qt versions.</source>
          <target state="translated">Qt가 제공 하는 &lt;a href=&quot;qhash#qHashx&quot;&gt;qHash&lt;/a&gt; () 과부하 의 구현은 언제든지 변경 될 수 있습니다. 당신은 &lt;b&gt;하지 않아야&lt;/b&gt; 한다는 사실에 의존 &lt;a href=&quot;qhash#qHashx&quot;&gt;qHash은&lt;/a&gt; () 다른 Qt는 버전에서 (같은 입력에 대한) 같은 결과를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c2fdf690e4974b08866589cde3603bf4ac78252" translate="yes" xml:space="preserve">
          <source>Note that the interface index can also be set with &lt;a href=&quot;qhostaddress#setScopeId&quot;&gt;QHostAddress::setScopeId&lt;/a&gt;() for IPv6 destination addresses and then with &lt;a href=&quot;qnetworkdatagram#setDestination&quot;&gt;setDestination&lt;/a&gt;(). If the scope ID set in the destination address and</source>
          <target state="translated">IPv6 대상 주소에 대해 &lt;a href=&quot;qhostaddress#setScopeId&quot;&gt;QHostAddress :: setScopeId&lt;/a&gt; ()를 사용하여 설정 한 다음 &lt;a href=&quot;qnetworkdatagram#setDestination&quot;&gt;setDestination&lt;/a&gt; () 을 사용하여 인터페이스 색인을 설정할 수도 있습니다 . 대상 주소에 범위 ID가 설정된 경우</target>
        </trans-unit>
        <trans-unit id="0218a029c6c604f44424a2c7bafec268ea7ff025" translate="yes" xml:space="preserve">
          <source>Note that the internal array only ever gets bigger over the life of the list. It never shrinks. The internal array is deallocated by the destructor and by the assignment operator, when one list is assigned to another.</source>
          <target state="translated">내부 배열은 목록 수명 기간 동안 만 커집니다. 절대 축소되지 않습니다. 하나의 목록이 다른 목록에 할당되면 내부 배열은 소멸자와 할당 연산자에 의해 할당 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="d1cc7323f624d60f6bc31db7992d6b68e01b242f" translate="yes" xml:space="preserve">
          <source>Note that the item's general visibility is unrelated to whether or not it is actually being visualized by a &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt;.</source>
          <target state="translated">아이템의 일반적인 가시성은 &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView에&lt;/a&gt; 의해 실제로 시각화되는지 여부와 관련이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="f10b38b9083c60116aae4ce7012f384ef2a59176" translate="yes" xml:space="preserve">
          <source>Note that the item's geometry is provided in item coordinates, and its position is initialized to (0, 0).</source>
          <target state="translated">아이템의 지오메트리는 아이템 좌표로 제공되며 위치는 (0, 0)으로 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="85d96b1643c8b96254f3a503cb40bd30c892db9d" translate="yes" xml:space="preserve">
          <source>Note that the item's geometry is provided in item coordinates, and its position is initialized to (0, 0). For example, if a &lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt;(50, 50, 100, 100) is added, its top-left corner will be at (50, 50) relative to the origin in the item's coordinate system.</source>
          <target state="translated">아이템의 지오메트리는 아이템 좌표로 제공되며 위치는 (0, 0)으로 초기화됩니다. 예를 들어, &lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt; (50, 50, 100, 100)가 추가되면 왼쪽 상단 모서리는 항목 좌표계의 원점을 기준으로 (50, 50)이됩니다.</target>
        </trans-unit>
        <trans-unit id="9279308e7388b67030442c563fae37721bdabeb1" translate="yes" xml:space="preserve">
          <source>Note that the items in the list may not be adjacent elements in the document. For example, the top-level items in a multi-level list will be separated by the items in lower levels of the list.</source>
          <target state="translated">목록의 항목이 문서의 요소와 인접하지 않을 수 있습니다. 예를 들어, 다단계 목록의 최상위 항목은 목록의 하위 수준에있는 항목으로 구분됩니다.</target>
        </trans-unit>
        <trans-unit id="c3889a5c562fd1fbdfb4ce91c889791ea1c255cf" translate="yes" xml:space="preserve">
          <source>Note that the iterator selects both frames and blocks, so it is necessary to check which it is referring to. This allows us to navigate the document structure on a frame-by-frame basis yet still access text blocks if required. Both the &lt;a href=&quot;qtextblock-iterator&quot;&gt;QTextBlock::iterator&lt;/a&gt; and &lt;a href=&quot;qtextframe-iterator&quot;&gt;QTextFrame::iterator&lt;/a&gt; classes can be used in complementary ways to extract the required structure from a document.</source>
          <target state="translated">반복자는 프레임과 블록을 모두 선택하므로 참조하는 프레임을 확인해야합니다. 이를 통해 프레임 단위로 문서 구조를 탐색 할 수 있지만 필요한 경우 여전히 텍스트 블록에 액세스 할 수 있습니다. 모두 &lt;a href=&quot;qtextblock-iterator&quot;&gt;QTextBlock는 :: 반복자&lt;/a&gt; 와 &lt;a href=&quot;qtextframe-iterator&quot;&gt;QTextFrame :: 반복자&lt;/a&gt; 클래스는 문서에서 필요한 구조를 추출하는 보완적인 방법으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb8c94b6aca492d17181c22511b158235fd2c8a8" translate="yes" xml:space="preserve">
          <source>Note that the key bindings are platform dependent. The currently bound shortcuts can be queried using &lt;a href=&quot;qkeysequence#keyBindings&quot;&gt;keyBindings&lt;/a&gt;().</source>
          <target state="translated">키 바인딩은 플랫폼에 따라 다릅니다. &lt;a href=&quot;qkeysequence#keyBindings&quot;&gt;keyBindings&lt;/a&gt; ()를 사용하여 현재 바인딩 된 바로 가기를 쿼리 할 수 ​​있습니다 .</target>
        </trans-unit>
        <trans-unit id="67d6161b0119249b6a5634aedd1633772057b541" translate="yes" xml:space="preserve">
          <source>Note that the keys are case-insensitive.</source>
          <target state="translated">키는 대소 문자를 구분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a3b0efa055233d5267baec1379f927ff5798f132" translate="yes" xml:space="preserve">
          <source>Note that the last error for this query is reset when &lt;a href=&quot;qsqlquery#exec-1&quot;&gt;exec&lt;/a&gt;() is called.</source>
          <target state="translated">이 쿼리의 마지막 오류는 &lt;a href=&quot;qsqlquery#exec-1&quot;&gt;exec&lt;/a&gt; ()가 호출 될 때 재설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="5dfa77a4f93c9e20ea3fd1b3f132abfb549a62fb" translate="yes" xml:space="preserve">
          <source>Note that the last error for this query is reset when exec() is called.</source>
          <target state="translated">이 쿼리의 마지막 오류는 exec ()가 호출 될 때 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="b2fd977ead293ddab3666ef0008fc44a8f952306" translate="yes" xml:space="preserve">
          <source>Note that the layout is free to use geometry caching to optimize this process. To forcefully invalidate any such cache, you can call &lt;a href=&quot;qgraphicslayout#invalidate&quot;&gt;invalidate&lt;/a&gt;() before calling activate().</source>
          <target state="translated">레이아웃은이 프로세스를 최적화하기 위해 지오메트리 캐싱을 자유롭게 사용할 수 있습니다. 이러한 캐시를 강제로 무효화하려면 activate ()를 호출하기 전에 &lt;a href=&quot;qgraphicslayout#invalidate&quot;&gt;invalidate&lt;/a&gt; ()를 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="931baa08f18ee5ccb86406378de3268ecd979a3b" translate="yes" xml:space="preserve">
          <source>Note that the list may become outdated if changes are made on the local system or remote print server. Only instantiate required &lt;a href=&quot;qprinterinfo&quot;&gt;QPrinterInfo&lt;/a&gt; instances when needed, and always check for validity before calling.</source>
          <target state="translated">로컬 시스템 또는 원격 인쇄 서버에서 변경을 수행하면 목록이 오래 될 수 있습니다. 필요한 경우 필요한 &lt;a href=&quot;qprinterinfo&quot;&gt;QPrinterInfo&lt;/a&gt; 인스턴스 만 인스턴스화 하고 호출하기 전에 항상 유효성을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="893b3b53fd5d87a7bb9869a297d9d9ba571a5685" translate="yes" xml:space="preserve">
          <source>Note that the list of painter commands is reset on each call to the &lt;a href=&quot;qpainter#begin&quot;&gt;QPainter::begin&lt;/a&gt;() function.</source>
          <target state="translated">&lt;a href=&quot;qpainter#begin&quot;&gt;QPainter :: begin&lt;/a&gt; () 함수를 호출 할 때마다 페인터 명령 목록이 재설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="9ca75aea308b31b231d359fc1fe625bc9960d5c4" translate="yes" xml:space="preserve">
          <source>Note that the list order changes when &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; children are &lt;a href=&quot;qwidget#raise&quot;&gt;raised&lt;/a&gt; or &lt;a href=&quot;qwidget#lower&quot;&gt;lowered&lt;/a&gt;. A widget that is raised becomes the last object in the list, and a widget that is lowered becomes the first object in the list.</source>
          <target state="translated">&lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; 하위 항목을 &lt;a href=&quot;qwidget#raise&quot;&gt;올리&lt;/a&gt; 거나 &lt;a href=&quot;qwidget#lower&quot;&gt;내릴&lt;/a&gt; 때 목록 순서가 변경됩니다 . 올려 진 위젯은 목록의 마지막 객체가되고 내려진 위젯은 목록의 첫 번째 객체가됩니다.</target>
        </trans-unit>
        <trans-unit id="caff9acc77629d2ee604fec7408328aa5b9d276a" translate="yes" xml:space="preserve">
          <source>Note that the local machine ID is not guaranteed to be persistent across boots of the system, so this identifier should not be stored in persistent storage (like the filesystem). It is guaranteed to remain constant only during the lifetime of this boot session.</source>
          <target state="translated">로컬 시스템 ID가 시스템의 부트에서 지속적으로 유지되는 것은 아니므로이 식별자는 파일 시스템과 같은 영구 저장소에 저장해서는 안됩니다. 이 부팅 세션 동안에 만 일정하게 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="e9d432d5fcd6bf668375e90fdebce36d0764472b" translate="yes" xml:space="preserve">
          <source>Note that the model used is &lt;a href=&quot;qfilesystemmodel&quot;&gt;QFileSystemModel&lt;/a&gt;. It has custom item data roles, which is described by the &lt;a href=&quot;qfilesystemmodel#Roles-enum&quot;&gt;Roles&lt;/a&gt; enum. You can use a &lt;a href=&quot;qfileiconprovider&quot;&gt;QFileIconProvider&lt;/a&gt; if you only want custom icons.</source>
          <target state="translated">사용 된 모델은 &lt;a href=&quot;qfilesystemmodel&quot;&gt;QFileSystemModel&lt;/a&gt; 입니다. 그것은에 의해 설명 사용자 정의 항목 데이터 역할이 &lt;a href=&quot;qfilesystemmodel#Roles-enum&quot;&gt;역할&lt;/a&gt; 열거. 사용자 정의 아이콘 만 원하는 경우 &lt;a href=&quot;qfileiconprovider&quot;&gt;QFileIconProvider&lt;/a&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="205d058469d855fc01f0c7b71c3a4fa6c4c7316b" translate="yes" xml:space="preserve">
          <source>Note that the model used needs to provide support for drag and drop operations.</source>
          <target state="translated">사용 된 모델은 끌어서 놓기 작업을 지원해야합니다.</target>
        </trans-unit>
        <trans-unit id="3e70c35138250388f9bbe731cc071e15593bbd98" translate="yes" xml:space="preserve">
          <source>Note that the model will typically need to provide implementations of the &lt;a href=&quot;qabstractitemmodel#insertRows&quot;&gt;QAbstractItemModel::insertRows&lt;/a&gt;() and &lt;a href=&quot;qabstractitemmodel#setData&quot;&gt;QAbstractItemModel::setData&lt;/a&gt;() functions.</source>
          <target state="translated">모델은 일반적으로 &lt;a href=&quot;qabstractitemmodel#insertRows&quot;&gt;QAbstractItemModel :: insertRows&lt;/a&gt; () 및 &lt;a href=&quot;qabstractitemmodel#setData&quot;&gt;QAbstractItemModel :: setData&lt;/a&gt; () 함수의 구현을 제공해야 합니다.</target>
        </trans-unit>
        <trans-unit id="a559cec58514c032b72ce0a0dc9631f2eb428bba" translate="yes" xml:space="preserve">
          <source>Note that the module will not receive additional features anymore. For reading or writing XML documents iteratively (SAX), we recommend using Qt Core's &lt;a href=&quot;qxmlstreamreader&quot;&gt;QXmlStreamReader&lt;/a&gt; and &lt;a href=&quot;qxmlstreamwriter&quot;&gt;QXmlStreamWriter&lt;/a&gt; classes. The classes are both easier to use and more compliant with the XML standard.</source>
          <target state="translated">모듈은 더 이상 추가 기능을받지 않습니다. 반복적으로 XML 문서를 읽거나 쓰 &lt;a href=&quot;qxmlstreamreader&quot;&gt;려면&lt;/a&gt; (SAX) Qt Core의 QXmlStreamReader 및 &lt;a href=&quot;qxmlstreamwriter&quot;&gt;QXmlStreamWriter&lt;/a&gt; 클래스를 사용하는 것이 좋습니다 . 이 클래스는 사용하기 쉽고 XML 표준을 준수합니다.</target>
        </trans-unit>
        <trans-unit id="2df460294ccf94fbf9fc37131626d6cb0f699513" translate="yes" xml:space="preserve">
          <source>Note that the namespaces</source>
          <target state="translated">네임 스페이스는</target>
        </trans-unit>
        <trans-unit id="28bc52218faba957874da52c425e37c4f1e940dd" translate="yes" xml:space="preserve">
          <source>Note that the next block may be in a different frame or table to this block.</source>
          <target state="translated">다음 블록은이 블록과 다른 프레임 또는 테이블에있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a911d0130ca3562b83a19ea3f855a7046573b2fe" translate="yes" xml:space="preserve">
          <source>Note that the only part of the class definition that is specific to this particular custom widget is the class name. In addition, since we are implementing an interface, we must ensure that it's made known to the meta object system using the &lt;a href=&quot;qobject#Q_INTERFACES&quot;&gt;Q_INTERFACES&lt;/a&gt;() macro. This enables</source>
          <target state="translated">이 특정 사용자 정의 위젯과 관련된 클래스 정의의 유일한 부분은 클래스 이름입니다. 또한 인터페이스를 구현하고 있으므로 &lt;a href=&quot;qobject#Q_INTERFACES&quot;&gt;Q_INTERFACES&lt;/a&gt; () 매크로를 사용하여 메타 객체 시스템에 해당 인터페이스가 알려 지도록해야합니다 . 이것은 가능</target>
        </trans-unit>
        <trans-unit id="81097c333b641d5c81571db04df6adab1a8594bd" translate="yes" xml:space="preserve">
          <source>Note that the operating system may impose further limits on applications holding a lot of allocated memory, especially large, contiguous blocks. Such considerations, the configuration of such behavior or any mitigation are outside the scope of the &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; API.</source>
          <target state="translated">운영 체제는 많은 양의 할당 된 메모리, 특히 크고 연속적인 블록을 보유하는 응용 프로그램에 추가 제한을 부과 할 수 있습니다. 이러한 고려 사항, 이러한 동작의 구성 또는 완화는 &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; API 의 범위를 벗어 납니다 .</target>
        </trans-unit>
        <trans-unit id="a130196eaa4bc41c84758b11314c27a007b22a72" translate="yes" xml:space="preserve">
          <source>Note that the operating system may impose further limits on applications holding a lot of allocated memory, especially large, contiguous blocks. Such considerations, the configuration of such behavior or any mitigation are outside the scope of the Qt API.</source>
          <target state="translated">운영 체제는 많은 양의 할당 된 메모리, 특히 크고 연속적인 블록을 보유하는 응용 프로그램에 추가 제한을 부과 할 수 있습니다. 이러한 고려 사항, 이러한 동작의 구성 또는 완화는 Qt API의 범위를 벗어납니다.</target>
        </trans-unit>
        <trans-unit id="acf020250b2890dc46dd84ffccf99779ed4bc9b4" translate="yes" xml:space="preserve">
          <source>Note that the optional XML declaration at very beginning of the XML document is not a processing instruction</source>
          <target state="translated">XML 문서의 맨 처음에 선택적 XML 선언은 처리 명령이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="9d1f1f8da8f6dbc87b139601e19f8a1b86d3d283" translate="yes" xml:space="preserve">
          <source>Note that the order we add the parameters is important, because there is dependency between the parameters. Adding a layer before adding a source will create an invalid layer, same goes for adding a paint property for a layer that doesn't exist.</source>
          <target state="translated">매개 변수 사이에 종속성이 있기 때문에 매개 변수를 추가하는 순서가 중요합니다. 소스를 추가하기 전에 레이어를 추가하면 유효하지 않은 레이어가 생성되며, 존재하지 않는 레이어에 페인트 속성을 추가하는 것과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="1cd5f49603f9b1664cd9bf37ae06190cdb8280b1" translate="yes" xml:space="preserve">
          <source>Note that the original image is not changed.</source>
          <target state="translated">원본 이미지는 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f45fafdd6992ce9fec27ab47abd67ccddf91b86a" translate="yes" xml:space="preserve">
          <source>Note that the other notification types will be sent even if the notifications for this object have been blocked.</source>
          <target state="translated">이 객체에 대한 알림이 차단 된 경우에도 다른 알림 유형이 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="c5c3336409d6b975ac6824e4d87c75520931c134" translate="yes" xml:space="preserve">
          <source>Note that the path may not currently exist on the filesystem, so callers wanting to</source>
          <target state="translated">경로는 현재 파일 시스템에 존재하지 않을 수 있으므로 호출자는</target>
        </trans-unit>
        <trans-unit id="f54c75111d02c45cb47257dd956c260ac57e9eed" translate="yes" xml:space="preserve">
          <source>Note that the pixel data in a pixmap is internal and is managed by the underlying window system. Because &lt;a href=&quot;qpixmap&quot;&gt;QPixmap&lt;/a&gt; is a &lt;a href=&quot;qpaintdevice&quot;&gt;QPaintDevice&lt;/a&gt; subclass, &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; can be used to draw directly onto pixmaps. Pixels can only be accessed through &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; functions or by converting the &lt;a href=&quot;qpixmap&quot;&gt;QPixmap&lt;/a&gt; to a &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt;. However, the &lt;a href=&quot;qpixmap#fill&quot;&gt;fill&lt;/a&gt;() function is available for initializing the entire pixmap with a given color.</source>
          <target state="translated">픽스맵의 픽셀 데이터는 내부 데이터이며 기본 윈도우 시스템에 의해 관리됩니다. 때문에 &lt;a href=&quot;qpixmap&quot;&gt;QPixmap는&lt;/a&gt; A는 &lt;a href=&quot;qpaintdevice&quot;&gt;QPaintDevice의&lt;/a&gt; 하위 클래스 &lt;a href=&quot;qpainter&quot;&gt;QPainter를는&lt;/a&gt; 픽스맵에 직접 묘화에 사용된다. 픽셀은 &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; 함수 또는 &lt;a href=&quot;qpixmap&quot;&gt;QPixmap&lt;/a&gt; 을 &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt; 로 변환하여 액세스 할 수 있습니다 . 그러나 &lt;a href=&quot;qpixmap#fill&quot;&gt;fill&lt;/a&gt; () 함수는 주어진 색상으로 전체 픽스맵을 초기화하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="45ac1202da8180aee9bca70eafd878851fe9da61" translate="yes" xml:space="preserve">
          <source>Note that the pointer remains valid only as long as the string is not modified by other means. For read-only access, &lt;a href=&quot;qstring#constData&quot;&gt;constData&lt;/a&gt;() is faster because it never causes a &lt;a href=&quot;implicit-sharing#deep-copy&quot;&gt;deep copy&lt;/a&gt; to occur.</source>
          <target state="translated">포인터가 다른 방법으로 문자열을 수정하지 않는 한 포인터는 계속 유효합니다. 읽기 전용 액세스의 경우 &lt;a href=&quot;qstring#constData&quot;&gt;constData&lt;/a&gt; ()는 &lt;a href=&quot;implicit-sharing#deep-copy&quot;&gt;깊은 복사&lt;/a&gt; 가 발생 하지 않기 때문에 더 빠릅니다 .</target>
        </trans-unit>
        <trans-unit id="95aa67a1b92b5f7eee27369ff131e1c6e15b5f3f" translate="yes" xml:space="preserve">
          <source>Note that the pointer remains valid only as long as the string is not modified.</source>
          <target state="translated">포인터는 문자열이 수정되지 않는 한 유효합니다.</target>
        </trans-unit>
        <trans-unit id="81df146537add4fd8ddb77c1e9428a9f73e5a26c" translate="yes" xml:space="preserve">
          <source>Note that the pointer returned by this function is managed by &lt;a href=&quot;qnetworkaccessmanager&quot;&gt;QNetworkAccessManager&lt;/a&gt; and could be deleted at any time.</source>
          <target state="translated">이 함수에 의해 반환 된 포인터는 &lt;a href=&quot;qnetworkaccessmanager&quot;&gt;QNetworkAccessManager에&lt;/a&gt; 의해 관리되며 언제든지 삭제할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="893d2b0119153b0629f0c8d5d6cda67a29cad856" translate="yes" xml:space="preserve">
          <source>Note that the position of the current item may only be approximate until it becomes visible in the view.</source>
          <target state="translated">현재 항목의 위치는보기에 표시 될 때까지만 대략적 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb7c4bf67b610cc519cfab6332dcc193f038dc14" translate="yes" xml:space="preserve">
          <source>Note that the position source may have a minimum value requirement for update intervals, as returned by &lt;a href=&quot;qgeopositioninfosource#minimumUpdateInterval-prop&quot;&gt;minimumUpdateInterval&lt;/a&gt;().</source>
          <target state="translated">positionUpdate는 &lt;a href=&quot;qgeopositioninfosource#minimumUpdateInterval-prop&quot;&gt;minimumUpdateInterval&lt;/a&gt; ()에 의해 반환되는 업데이트 간격에 대한 최소값 요구 사항을 가질 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3a2cdde6bca3928dc13b2bb1935d23a033461baf" translate="yes" xml:space="preserve">
          <source>Note that the prefix</source>
          <target state="translated">접두사</target>
        </trans-unit>
        <trans-unit id="2f512d6c5b8f9c9b1e84e3590dbe224cef90747f" translate="yes" xml:space="preserve">
          <source>Note that the previous block may be in a different frame or table to this block.</source>
          <target state="translated">이전 블록은이 블록과 다른 프레임 또는 테이블에있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a56afc3eb8a29f00f93427a9c6fb6601c4c3f27c" translate="yes" xml:space="preserve">
          <source>Note that the qmake project of this example includes a resource file &lt;code&gt;testcon.rc&lt;/code&gt; with a version resource. This is required by some ActiveX controls (ie. Shockwave ActiveX Controls), which might crash or misbehave otherwise if such version information is missing.</source>
          <target state="translated">이 예제의 qmake 프로젝트에는 버전 자원 이있는 자원 파일 &lt;code&gt;testcon.rc&lt;/code&gt; 가 포함되어 있습니다. 이는 일부 ActiveX 컨트롤 (예 : Shockwave ActiveX 컨트롤)에 필요합니다. 이러한 버전 정보가 없으면 충돌하거나 오작동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c49f3e3184fc4b46d7786ceb6e5b3bee66dc1b1b" translate="yes" xml:space="preserve">
          <source>Note that the range is not updated until the widget is shown.</source>
          <target state="translated">위젯이 표시 될 때까지 범위가 업데이트되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="11ba26128f120cc8760e6a98042e8cbb59684272" translate="yes" xml:space="preserve">
          <source>Note that the range of values used is independent of the actual size of the scroll bar widget. You do not need to take this into account when you choose values for the range and the page step.</source>
          <target state="translated">사용 된 값의 범위는 스크롤 막대 위젯의 실제 크기와 무관합니다. 범위 및 페이지 단계의 값을 선택할 때이를 고려할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="9c7e1f6ab28601b4c9096ca5eba8c3ce66a37de5" translate="yes" xml:space="preserve">
          <source>Note that the rectangle usually extends both above and below the base line.</source>
          <target state="translated">사각형은 일반적으로 기준선 위와 아래 모두로 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="e7eea4bb109066ee8b24fd3f515648916a0748d3" translate="yes" xml:space="preserve">
          <source>Note that the result is rounded to the nearest integer as points are held as integers. Use &lt;a href=&quot;qpointf&quot;&gt;QPointF&lt;/a&gt; for floating point accuracy.</source>
          <target state="translated">포인트가 정수로 유지되므로 결과는 가장 가까운 정수로 반올림됩니다. 부동 소수점 정확도를 위해 &lt;a href=&quot;qpointf&quot;&gt;QPointF&lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="99998472d79951feb45b036975f38e6cbfc64af9" translate="yes" xml:space="preserve">
          <source>Note that the result is rounded to the nearest integer.</source>
          <target state="translated">결과는 가장 가까운 정수로 반올림됩니다.</target>
        </trans-unit>
        <trans-unit id="a833ac0dac2e3e6650a8acb70524f04e44e042fd" translate="yes" xml:space="preserve">
          <source>Note that the result of comparing two empty &lt;a href=&quot;qfileinfo&quot;&gt;QFileInfo&lt;/a&gt; objects, containing no file references (file paths that do not exist or are empty), is undefined.</source>
          <target state="translated">존재하지 않거나 비어있는 파일 참조가없는 두 개의 빈 &lt;a href=&quot;qfileinfo&quot;&gt;QFileInfo&lt;/a&gt; 객체 를 비교 한 결과 는 정의되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="06553a94231607edc8a83ecbca713402876c46b4" translate="yes" xml:space="preserve">
          <source>Note that the result of comparing two invalid &lt;a href=&quot;qstorageinfo&quot;&gt;QStorageInfo&lt;/a&gt; objects is always positive.</source>
          <target state="translated">유효하지 않은 두 &lt;a href=&quot;qstorageinfo&quot;&gt;QStorageInfo&lt;/a&gt; 오브젝트 를 비교 한 결과 는 항상 긍정적입니다.</target>
        </trans-unit>
        <trans-unit id="9455966e3ddcdd7fd7a8708d925b88285294e062" translate="yes" xml:space="preserve">
          <source>Note that the result types above are not &lt;a href=&quot;qfuture&quot;&gt;QFuture&lt;/a&gt; objects, but real result types (in this case, &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt;&amp;lt;QImage&amp;gt; and QImage).</source>
          <target state="translated">위의 결과 유형은 &lt;a href=&quot;qfuture&quot;&gt;QFuture&lt;/a&gt; 오브젝트가 아니라 실제 결과 유형입니다 (이 경우 &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt; &amp;lt;QImage&amp;gt; 및 QImage).</target>
        </trans-unit>
        <trans-unit id="52404f798007b3ce5bd6a35a3894a63e0fc0c39b" translate="yes" xml:space="preserve">
          <source>Note that the result types above are not &lt;a href=&quot;qfuture&quot;&gt;QFuture&lt;/a&gt; objects, but real result types (in this case, &lt;a href=&quot;qstringlist&quot;&gt;QStringList&lt;/a&gt; and &lt;a href=&quot;qset&quot;&gt;QSet&lt;/a&gt;&amp;lt;&lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;&amp;gt;).</source>
          <target state="translated">위의 결과 유형은 &lt;a href=&quot;qfuture&quot;&gt;QFuture&lt;/a&gt; 오브젝트가 아니라 실제 결과 유형입니다 (이 경우 &lt;a href=&quot;qstringlist&quot;&gt;QStringList&lt;/a&gt; 및 &lt;a href=&quot;qset&quot;&gt;QSet&lt;/a&gt; &amp;lt; &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; &amp;gt;).</target>
        </trans-unit>
        <trans-unit id="51e19b847dd64845c76b7f5deb5263a19534dcd4" translate="yes" xml:space="preserve">
          <source>Note that the return value and return type of the map function are not used.</source>
          <target state="translated">맵 함수의 반환 값과 반환 유형은 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4ec6a81f2adc2ebc02f7177305ed2da055fdf02b" translate="yes" xml:space="preserve">
          <source>Note that the returned &lt;a href=&quot;qtextlayout&quot;&gt;QTextLayout&lt;/a&gt; object can only be modified from the documentChanged implementation of a &lt;a href=&quot;qabstracttextdocumentlayout&quot;&gt;QAbstractTextDocumentLayout&lt;/a&gt; subclass. Any changes applied from the outside cause undefined behavior.</source>
          <target state="translated">리턴 된 &lt;a href=&quot;qtextlayout&quot;&gt;QTextLayout&lt;/a&gt; 오브젝트는 &lt;a href=&quot;qabstracttextdocumentlayout&quot;&gt;QAbstractTextDocumentLayout&lt;/a&gt; 서브 클래스 의 documentChanged 구현에서만 수정할 수 있습니다 . 외부에서 적용된 변경 사항은 정의되지 않은 동작을 유발합니다.</target>
        </trans-unit>
        <trans-unit id="2357442c445daa102e80db09253868c0ce98a0c9" translate="yes" xml:space="preserve">
          <source>Note that the returned line's start and end points are rounded to the nearest integer.</source>
          <target state="translated">반환 된 줄의 시작 및 끝 지점은 가장 가까운 정수로 반올림됩니다.</target>
        </trans-unit>
        <trans-unit id="20107e5c5cc5b651f84c94f8824b4abcba36917a" translate="yes" xml:space="preserve">
          <source>Note that the returned value is always &lt;a href=&quot;qt#MouseButton-enum&quot;&gt;Qt::NoButton&lt;/a&gt; for &lt;a href=&quot;qevent#Type-enum&quot;&gt;TabletMove&lt;/a&gt;, &lt;a href=&quot;qevent#Type-enum&quot;&gt;TabletEnterProximity&lt;/a&gt; and &lt;a href=&quot;qevent#Type-enum&quot;&gt;TabletLeaveProximity&lt;/a&gt; events.</source>
          <target state="translated">반환 된 값은 &lt;a href=&quot;qevent#Type-enum&quot;&gt;TabletMove&lt;/a&gt; , &lt;a href=&quot;qevent#Type-enum&quot;&gt;TabletEnterProximity&lt;/a&gt; 및 &lt;a href=&quot;qevent#Type-enum&quot;&gt;TabletLeaveProximity&lt;/a&gt; 이벤트에 대해 항상 &lt;a href=&quot;qt#MouseButton-enum&quot;&gt;Qt :: NoButton&lt;/a&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="7d371b14b24c2024581798cedb334d5ace393b33" translate="yes" xml:space="preserve">
          <source>Note that the returned value is always &lt;a href=&quot;qt#MouseButton-enum&quot;&gt;Qt::NoButton&lt;/a&gt; for mouse move events.</source>
          <target state="translated">반환 된 값은 항상 마우스 이동 이벤트에 대한 &lt;a href=&quot;qt#MouseButton-enum&quot;&gt;Qt :: NoButton&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6bb5e32ae5d90393604deef8b29e1a8bd15397cc" translate="yes" xml:space="preserve">
          <source>Note that the root (CA) certificate should not be included in the list to be verified, this will be looked up automatically either using the CA list specified by QSslSocket::defaultCaCertificates() or, if possible, it will be loaded on demand on Unix.</source>
          <target state="translated">루트 (CA) 인증서는 확인할 목록에 포함되지 않아야합니다. 이는 QSslSocket :: defaultCaCertificates ()에 의해 지정된 CA 목록을 사용하여 자동으로 조회되거나 가능하면 요청시로드됩니다. 유닉스.</target>
        </trans-unit>
        <trans-unit id="99ef917431487c7252dfc942bc61b5a9d9e59a64" translate="yes" xml:space="preserve">
          <source>Note that the root item of the delegate component must be a &lt;a href=&quot;qquickitem&quot;&gt;QQuickItem&lt;/a&gt; or &lt;a href=&quot;qquickitem&quot;&gt;QQuickItem&lt;/a&gt; derived item.</source>
          <target state="translated">델리게이트 컴포넌트의 루트 아이템은 &lt;a href=&quot;qquickitem&quot;&gt;QQuickItem&lt;/a&gt; 또는 &lt;a href=&quot;qquickitem&quot;&gt;QQuickItem&lt;/a&gt; 파생 아이템 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="7e2e2897f4933d81ab34647ae6658ddc7db509eb" translate="yes" xml:space="preserve">
          <source>Note that the root rectangle in the code above is superfluous as the window is also white, so drawing the rectangle is a waste of resources in this case. Changing it to an Item can give a slight performance boost.</source>
          <target state="translated">위의 코드에서 루트 사각형은 창이 흰색이기 때문에 불필요하므로 사각형을 그리는 것은 리소스 낭비입니다. 아이템으로 변경하면 성능이 약간 향상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a80a7c24c4a56e6370db72fa960575828468a5be" translate="yes" xml:space="preserve">
          <source>Note that the rows and columns in the table begin at zero.</source>
          <target state="translated">테이블의 행과 열은 0에서 시작합니다.</target>
        </trans-unit>
        <trans-unit id="ff4e877559139a523eabc6b48335110b2e5ee5f2" translate="yes" xml:space="preserve">
          <source>Note that the satellite source may have a minimum value requirement for update intervals, as returned by &lt;a href=&quot;qgeosatelliteinfosource#minimumUpdateInterval-prop&quot;&gt;minimumUpdateInterval&lt;/a&gt;().</source>
          <target state="translated">위성 소스는 &lt;a href=&quot;qgeosatelliteinfosource#minimumUpdateInterval-prop&quot;&gt;minimumUpdateInterval&lt;/a&gt; ()에 의해 반환되는 업데이트 간격에 대한 최소값 요구 사항을 가질 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="651ff2c9070e2724d6aa186d1e4c7932eb90910d" translate="yes" xml:space="preserve">
          <source>Note that the size and position of this element affects which particles it affects. The size of the point attracted to is always 0x0, and the location of that point is specified by the pointX and pointY properties.</source>
          <target state="translated">이 요소의 크기와 위치는 영향을받는 입자에 영향을 미칩니다. 끌어 당겨진 점의 크기는 항상 0x0이며 해당 점의 위치는 pointX 및 pointY 속성으로 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="9d1b76f01a2a06eefc62dcb282427d1f676ad0c7" translate="yes" xml:space="preserve">
          <source>Note that the sprite image will be scaled to a square based on the size of the particle being rendered.</source>
          <target state="translated">스프라이트 이미지는 렌더링되는 입자의 크기에 따라 정사각형으로 조정됩니다.</target>
        </trans-unit>
        <trans-unit id="b303990ec67debdc1821bba9fec057af04b6ab6a" translate="yes" xml:space="preserve">
          <source>Note that the standard and DST offsets for a time zone may change over time as countries have changed DST laws or even their standard time offset.</source>
          <target state="translated">국가가 DST 법을 변경하거나 표준 시간 오프셋을 변경함에 따라 시간대에 대한 표준 및 DST 오프셋이 시간이 지남에 따라 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f7a06c1cac4ed4b90be9814753d4e716cf2b8e4b" translate="yes" xml:space="preserve">
          <source>Note that the startup function will run at the end of the &lt;a href=&quot;qcoreapplication&quot;&gt;QCoreApplication&lt;/a&gt; constructor, before any GUI initialization. If GUI code is required in the function, use a timer (or a queued invocation) to perform the initialization later on, from the event loop.</source>
          <target state="translated">시작 기능은 GUI 초기화 전에 &lt;a href=&quot;qcoreapplication&quot;&gt;QCoreApplication&lt;/a&gt; 생성자 의 끝에서 실행됩니다 . 함수에 GUI 코드가 필요한 경우, 타이머 (또는 대기 호출)를 사용하여 나중에 이벤트 루프에서 초기화를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="2ae0a8048633d6feb0a9feab4074993da1369c4a" translate="yes" xml:space="preserve">
          <source>Note that the static function signatures have changed with respect to their button parameters, which are now used to set the &lt;a href=&quot;qmessagebox#standardButtons-prop&quot;&gt;standard buttons&lt;/a&gt; and the &lt;a href=&quot;qmessagebox#defaultButton&quot;&gt;default button&lt;/a&gt;.</source>
          <target state="translated">정적 함수 시그니처는 버튼 매개 변수와 관련하여 변경되었으며, 이제는 &lt;a href=&quot;qmessagebox#standardButtons-prop&quot;&gt;표준 버튼&lt;/a&gt; 및 &lt;a href=&quot;qmessagebox#defaultButton&quot;&gt;기본 버튼&lt;/a&gt; 을 설정하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="e18e5a0128cfc3f65359edcf7cb25167a5e49489" translate="yes" xml:space="preserve">
          <source>Note that the table view uses the horizontal header section positions to determine the positions of columns in the view.</source>
          <target state="translated">테이블 뷰는 가로 머리글 섹션 위치를 사용하여 뷰의 열 위치를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="be19473933101d0885da4c334d43a650b9be5626" translate="yes" xml:space="preserve">
          <source>Note that the table view uses the vertical header section positions to determine the positions of rows in the view.</source>
          <target state="translated">테이블 뷰는 세로 머리글 섹션 위치를 사용하여 뷰에서 행의 위치를 ​​결정합니다.</target>
        </trans-unit>
        <trans-unit id="bc81a14e86fe31a446b40843a68cdb8d683d1c2c" translate="yes" xml:space="preserve">
          <source>Note that the template class type for the &lt;a href=&quot;qqmllistproperty&quot;&gt;QQmlListProperty&lt;/a&gt; &amp;mdash; in this case, &lt;code&gt;Message&lt;/code&gt; &amp;mdash; must be &lt;a href=&quot;qtqml-cppintegration-definetypes#registering-c-types-with-the-qml-type-system&quot;&gt;registered&lt;/a&gt; with the QML type system.</source>
          <target state="translated">&lt;a href=&quot;qqmllistproperty&quot;&gt;QQmlListProperty (&lt;/a&gt; 이 경우 &lt;code&gt;Message&lt;/code&gt; 의 템플리트 클래스 유형 은 QML 유형 시스템에 &lt;a href=&quot;qtqml-cppintegration-definetypes#registering-c-types-with-the-qml-type-system&quot;&gt;등록&lt;/a&gt; 되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="f0fc4bdab6fe1831aeb1f04563de73586616b79b" translate="yes" xml:space="preserve">
          <source>Note that the text format is something like this &quot;Menu text&lt;b&gt;\t&lt;/b&gt;Shortcut&quot;.</source>
          <target state="translated">텍스트 형식은 &quot;메뉴 텍스트 &lt;b&gt;\ t&lt;/b&gt; 바로 가기&quot;와 같습니다.</target>
        </trans-unit>
        <trans-unit id="6556b9323bed5d00b7457fe38928694dd2a05e6f" translate="yes" xml:space="preserve">
          <source>Note that the text properties of most objects are read-only so calling this function might have no effect.</source>
          <target state="translated">대부분의 객체의 텍스트 속성은 읽기 전용이므로이 함수를 호출해도 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="2e9b2c3bb71d1b3f5ee20037a5e64879c5d63154" translate="yes" xml:space="preserve">
          <source>Note that the thread pool takes ownership of the</source>
          <target state="translated">스레드 풀은</target>
        </trans-unit>
        <trans-unit id="f2aa18d58ce4943c60a8b56a407a353f342059c6" translate="yes" xml:space="preserve">
          <source>Note that the time will wrap if it passes midnight.</source>
          <target state="translated">자정이 지나면 시간이 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="420273956af88df07dbd801586088045e0a6dc1e" translate="yes" xml:space="preserve">
          <source>Note that the time will wrap if it passes midnight. See &lt;a href=&quot;qtime#addSecs&quot;&gt;addSecs&lt;/a&gt;() for an example.</source>
          <target state="translated">자정이 지나면 시간이 줄어 듭니다. 예제는 &lt;a href=&quot;qtime#addSecs&quot;&gt;addSecs&lt;/a&gt; ()를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="42327f2a54ecc39ff386bb855a534bde18388027" translate="yes" xml:space="preserve">
          <source>Note that the translator must be created</source>
          <target state="translated">번역기를 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="975794537a0a5c73be368e9c86ade76311d398fe" translate="yes" xml:space="preserve">
          <source>Note that the tree view uses the horizontal header section positions to determine the positions of columns in the view.</source>
          <target state="translated">트리 뷰는 가로 머리글 섹션 위치를 사용하여 뷰에서 열의 위치를 ​​결정합니다.</target>
        </trans-unit>
        <trans-unit id="e240615bc0cf96fae759435ba4ac4f456f96b77f" translate="yes" xml:space="preserve">
          <source>Note that the type of</source>
          <target state="translated">유형이</target>
        </trans-unit>
        <trans-unit id="a4ebcdc172bcde654322ac8440f62c537ba87f6a" translate="yes" xml:space="preserve">
          <source>Note that the validity of a regexp may also depend on the setting of the wildcard flag, for example &lt;b&gt;*.html&lt;/b&gt; is a valid wildcard regexp but an invalid full regexp.</source>
          <target state="translated">정규 표현식의 유효성은 와일드 카드 플래그 설정에 따라 달라질 수 있습니다. 예를 들어 &lt;b&gt;* .html&lt;/b&gt; 은 유효한 와일드 카드 정규 표현식이지만 유효하지 않은 전체 정규 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="721d3f620b4a78dea02a18fe63935c90aa4b92b0" translate="yes" xml:space="preserve">
          <source>Note that the value returned by &lt;a href=&quot;qdbusunixfiledescriptor#fileDescriptor&quot;&gt;fileDescriptor&lt;/a&gt;() will be different from the</source>
          <target state="translated">&lt;a href=&quot;qdbusunixfiledescriptor#fileDescriptor&quot;&gt;fileDescriptor&lt;/a&gt; ()에 의해 반환 된 값 은</target>
        </trans-unit>
        <trans-unit id="a17c6df9942084beec45857776beaf6c234514d2" translate="yes" xml:space="preserve">
          <source>Note that the value returned by rootPath() is the real mount point of a volume, and may not be equal to the value passed to the constructor or &lt;a href=&quot;qstorageinfo#setPath&quot;&gt;setPath&lt;/a&gt;() method. For example, if you have only the root volume in the system, and pass '/directory' to &lt;a href=&quot;qstorageinfo#setPath&quot;&gt;setPath&lt;/a&gt;(), then this method will return '/'.</source>
          <target state="translated">rootPath ()에 의해 리턴 된 값은 볼륨의 실제 마운트 지점이며 생성자 또는 &lt;a href=&quot;qstorageinfo#setPath&quot;&gt;setPath&lt;/a&gt; () 메소드에 전달 된 값과 같지 않을 수 있습니다 . 예를 들어 시스템에 루트 볼륨 만 있고 '/ directory'를 &lt;a href=&quot;qstorageinfo#setPath&quot;&gt;setPath&lt;/a&gt; ()에 전달하면이 메소드는 '/'를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="40d9582f71491edc69eff5d0b8f071c1af5b8f9e" translate="yes" xml:space="preserve">
          <source>Note that the values in the class returned by &lt;a href=&quot;qsensor#reading-prop&quot;&gt;QSensor::reading&lt;/a&gt;() will not be updated until after the filters have been run.</source>
          <target state="translated">&lt;a href=&quot;qsensor#reading-prop&quot;&gt;QSensor :: reading&lt;/a&gt; ()에 의해 리턴 된 클래스의 값 은 필터가 실행될 때까지 업데이트되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d2397ff4f0a783df1111e5727ce2813dabe964bb" translate="yes" xml:space="preserve">
          <source>Note that the values of both</source>
          <target state="translated">두 값 모두</target>
        </trans-unit>
        <trans-unit id="ccde549c6fb3527ec601cff7fcaa23b97d3262a2" translate="yes" xml:space="preserve">
          <source>Note that the width is always &amp;gt;= &lt;a href=&quot;qtextdocument#pageSize-prop&quot;&gt;pageSize&lt;/a&gt;().width().</source>
          <target state="translated">너비는 항상&amp;gt; = &lt;a href=&quot;qtextdocument#pageSize-prop&quot;&gt;pageSize&lt;/a&gt; () .width ()입니다.</target>
        </trans-unit>
        <trans-unit id="ed0a12ae058952dbd4f1a67973fee8b977ec9e20" translate="yes" xml:space="preserve">
          <source>Note that the window-viewport conversion is only a linear transformation, i.e. it does not perform clipping. This means that if you paint outside the currently set &quot;window&quot;, your painting is still transformed to the viewport using the same linear algebraic approach.</source>
          <target state="translated">창-뷰포트 변환은 선형 변환 일뿐입니다. 즉 클리핑을 수행하지 않습니다. 즉, 현재 설정된 &quot;창&quot;외부에서 페인트를해도 동일한 선형 대수 방식을 사용하여 페인팅이 뷰포트로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="cccdddb4fe64f71eb3b9af9e20c245d6f3f25556" translate="yes" xml:space="preserve">
          <source>Note that there are no direct mapping between the Qt &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; tree and the accessible object tree. For instance, scroll bar handles are accessible objects but are not widgets or objects in Qt.</source>
          <target state="translated">Qt &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 트리와 액세스 가능한 객체 트리 사이에는 직접 매핑이 없습니다 . 예를 들어, 스크롤 막대 핸들은 액세스 가능한 객체이지만 Qt의 위젯이나 객체는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="bbf840b78cf5d577c6dec511cee778888c58ba17" translate="yes" xml:space="preserve">
          <source>Note that there are possible values for</source>
          <target state="translated">가능한 값이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e9d9da1d14088b53e7993ba2c54584dcea7c551c" translate="yes" xml:space="preserve">
          <source>Note that there is a special case logic to prevent the generic plugin's backends from becoming the default when another backend is registered for the same type. This logic means that a backend identifier starting with &lt;code&gt;generic.&lt;/code&gt; will only be the default if no other backends have been registered for that type, or if it is specified in &lt;code&gt;Sensors.conf&lt;/code&gt;.</source>
          <target state="translated">다른 유형의 백엔드가 동일한 유형으로 등록 될 때 일반 플러그인의 백엔드가 기본값이되지 않도록하는 특별한 경우 논리가 있습니다. 이 논리는 백엔드 식별자가 &lt;code&gt;generic.&lt;/code&gt; 시작 함을 의미합니다 . 해당 유형에 대해 다른 백엔드가 등록되지 않았거나 &lt;code&gt;Sensors.conf&lt;/code&gt; 에 지정된 경우에만 기본값이됩니다 .</target>
        </trans-unit>
        <trans-unit id="040a29552119cd4cad1314620902431dc83dbc59" translate="yes" xml:space="preserve">
          <source>Note that there is an asymmetry in this library. &lt;a href=&quot;qxmlnamespacesupport#prefix&quot;&gt;prefix&lt;/a&gt;() does not return the default &quot;&quot; prefix, even if you have declared one; to check for a default prefix, you must look it up explicitly using &lt;a href=&quot;qxmlnamespacesupport#uri&quot;&gt;uri&lt;/a&gt;(). This asymmetry exists to make it easier to look up prefixes for attribute names, where the default prefix is not allowed.</source>
          <target state="translated">이 라이브러리에는 비대칭 성이 있습니다. &lt;a href=&quot;qxmlnamespacesupport#prefix&quot;&gt;접두사&lt;/a&gt; ()는 선언 한 경우에도 기본 &quot;&quot;접두사를 반환하지 않습니다. 기본 접두사를 확인하려면 &lt;a href=&quot;qxmlnamespacesupport#uri&quot;&gt;uri&lt;/a&gt; ()를 사용하여 명시 적으로 접두사를 찾아야합니다 . 이 비대칭 성은 기본 접두사가 허용되지 않는 속성 이름의 접 두부를 더 쉽게 찾을 수 있도록하기 위해 존재합니다.</target>
        </trans-unit>
        <trans-unit id="ab5d05366d3d76fb582263c6b34890c1e2011c83" translate="yes" xml:space="preserve">
          <source>Note that there is no mechanism to determine the current data rate in use by the platform.</source>
          <target state="translated">플랫폼에서 사용중인 현재 데이터 속도를 결정하는 메커니즘은 없습니다.</target>
        </trans-unit>
        <trans-unit id="1703c5e411e4055ec09accb43105e8d975198ad6" translate="yes" xml:space="preserve">
          <source>Note that there is no mechanism to determine the current output range in use by the platform.</source>
          <target state="translated">플랫폼에서 사용중인 현재 출력 범위를 결정하는 메커니즘은 없습니다.</target>
        </trans-unit>
        <trans-unit id="3adee1deacd618bc3819337df64f810b69c38e0a" translate="yes" xml:space="preserve">
          <source>Note that there is special case logic to prevent the generic plugin's backends from becoming the default when another backend is registered for the same type. This logic means that a backend identifier starting with &lt;code&gt;generic.&lt;/code&gt; will only be the default if no other backends have been registered for that type or if it is specified in &lt;code&gt;Sensors.conf&lt;/code&gt;.</source>
          <target state="translated">다른 유형의 백엔드가 동일한 유형으로 등록 될 때 일반 플러그인의 백엔드가 기본값이되는 것을 방지하는 특수한 경우 논리가 있습니다. 이 논리는 백엔드 식별자가 &lt;code&gt;generic.&lt;/code&gt; 시작 함을 의미합니다 . 해당 유형에 대해 다른 백엔드가 등록되지 않았거나 &lt;code&gt;Sensors.conf&lt;/code&gt; 에 지정된 경우에만 기본값이됩니다 .</target>
        </trans-unit>
        <trans-unit id="79d0f0e4783ad3fa291caf8291d621303898f0a1" translate="yes" xml:space="preserve">
          <source>Note that these functions will return &lt;code&gt;null&lt;/code&gt; when called inside the constructor of a &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; subclass, as the instance will not yet have a context nor engine.</source>
          <target state="translated">인스턴스에는 컨텍스트 나 엔진이 없기 때문에 &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 서브 클래스 의 생성자 내에서 호출 될 때 이러한 함수는 &lt;code&gt;null&lt;/code&gt; 을 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="6d51ddedcb2b26cc5b208f16c00100bcab7420d0" translate="yes" xml:space="preserve">
          <source>Note that these three cases represent exactly the possible states of a &lt;a href=&quot;qvalidator&quot;&gt;QValidator&lt;/a&gt; (see the &lt;a href=&quot;qvalidator#State-enum&quot;&gt;QValidator::State&lt;/a&gt; enum).</source>
          <target state="translated">이 세 가지 경우는 &lt;a href=&quot;qvalidator&quot;&gt;QValidator&lt;/a&gt; 의 가능한 가능한 상태를 나타냅니다 ( &lt;a href=&quot;qvalidator#State-enum&quot;&gt;QValidator :: State&lt;/a&gt; 열거 형 참조).</target>
        </trans-unit>
        <trans-unit id="19d3a179d0e97d72ebe002047be0c91013cb006d" translate="yes" xml:space="preserve">
          <source>Note that these values are provided purely for convenience, since event priorities can be any value between &lt;code&gt;INT_MAX&lt;/code&gt; and &lt;code&gt;INT_MIN&lt;/code&gt;, inclusive. For example, you can define custom priorities as being relative to each other:</source>
          <target state="translated">이벤트 우선 순위는 &lt;code&gt;INT_MAX&lt;/code&gt; ~ &lt;code&gt;INT_MIN&lt;/code&gt; 사이의 값이 될 수 있으므로 편의상 순전히 이러한 값이 제공됩니다 . 예를 들어, 사용자 지정 우선 순위를 서로에 대해 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba5dc00358b33ffe2140d0c00f74b4e08ad8f3f7" translate="yes" xml:space="preserve">
          <source>Note that this API is not currently supported on Android.</source>
          <target state="translated">이 API는 현재 Android에서 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1180934ec881d0b0c75a8e65afa410b2d9b114e4" translate="yes" xml:space="preserve">
          <source>Note that this call is asynchronous. Depending on the outcome of this call the results can be enquired by connecting to the &lt;a href=&quot;qnetworksession#stateChanged&quot;&gt;stateChanged&lt;/a&gt;(), &lt;a href=&quot;qnetworksession#opened&quot;&gt;opened&lt;/a&gt;() or &lt;a href=&quot;qnetworksession#error&quot;&gt;error&lt;/a&gt;() signals.</source>
          <target state="translated">이 호출은 비동기 적입니다. 이 호출의 결과에 따라 &lt;a href=&quot;qnetworksession#stateChanged&quot;&gt;stateChanged&lt;/a&gt; (), &lt;a href=&quot;qnetworksession#opened&quot;&gt;open&lt;/a&gt; () 또는 &lt;a href=&quot;qnetworksession#error&quot;&gt;error&lt;/a&gt; () 신호 에 연결하여 결과를 조회 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7b25cfa6ac2f78e340887d2e69f901eedca52828" translate="yes" xml:space="preserve">
          <source>Note that this class inherits most of its functionality from &lt;a href=&quot;qdropevent&quot;&gt;QDropEvent&lt;/a&gt;.</source>
          <target state="translated">이 클래스는 대부분의 기능을 &lt;a href=&quot;qdropevent&quot;&gt;QDropEvent&lt;/a&gt; 에서 상속 합니다.</target>
        </trans-unit>
        <trans-unit id="16e16dea450e21ea3a9459466570c16f0c854507" translate="yes" xml:space="preserve">
          <source>Note that this constructor is invoked automatically by the &lt;a href=&quot;#Q_PLUGIN_METADATA&quot;&gt;Q_PLUGIN_METADATA&lt;/a&gt;() macro, so there is no need for calling it explicitly.</source>
          <target state="translated">이 생성자는 &lt;a href=&quot;#Q_PLUGIN_METADATA&quot;&gt;Q_PLUGIN_METADATA&lt;/a&gt; () 매크로에 의해 자동으로 호출되므로 명시 적으로 호출 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="48320daa59d0c8c35465d1e2bf527da51843314d" translate="yes" xml:space="preserve">
          <source>Note that this constructor is invoked automatically by the moc generated code that exports the plugin, so there is no need for calling it explicitly.</source>
          <target state="translated">이 생성자는 플러그인을 내보내는 moc 생성 코드에 의해 자동으로 호출되므로 명시 적으로 호출 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="e0486c4ac66735844ef62dfd0b729e08407e7815" translate="yes" xml:space="preserve">
          <source>Note that this does not apply when there are no other widgets underneath and the intention is to have a semi-transparent window. In that case the traditional approach of setting &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt::WA_TranslucentBackground&lt;/a&gt; on the top-level window is sufficient. Note that if the transparent areas are only desired in the &lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt;, then &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt::WA_NoSystemBackground&lt;/a&gt; will need to be turned back to &lt;code&gt;false&lt;/code&gt; after enabling &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt::WA_TranslucentBackground&lt;/a&gt;. Additionally, requesting an alpha channel for the &lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt;'s context via &lt;a href=&quot;qopenglwidget#setFormat&quot;&gt;setFormat&lt;/a&gt;() may be necessary too, depending on the system.</source>
          <target state="translated">아래에 다른 위젯이없고 반투명 창이있는 경우에는 적용되지 않습니다. 이 경우 최상위 창에서 &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt :: WA_TranslucentBackground&lt;/a&gt; 를 설정하는 전통적인 접근 방식으로 충분합니다. 투명 영역이 &lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt; 에서만 필요한 경우 &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt :: WA_TranslucentBackground&lt;/a&gt; 를 활성화 한 후 &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt :: WA_NoSystemBackground&lt;/a&gt; 를 &lt;code&gt;false&lt;/code&gt; 로 다시 설정해야합니다 . 또한 시스템에 따라 &lt;a href=&quot;qopenglwidget#setFormat&quot;&gt;setFormat&lt;/a&gt; ()을 통해 &lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt; 의 컨텍스트에 대한 알파 채널을 요청 해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b4c42a7dedafafb800b4d16b17b6781de925e1c" translate="yes" xml:space="preserve">
          <source>Note that this does not count properties declared in &lt;a href=&quot;qsensorreading&quot;&gt;QSensorReading&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qsensorreading&quot;&gt;QSensorReading에&lt;/a&gt; 선언 된 특성은 계산되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="9011bff3358b4574e345149dcfa05059d63c5b55" translate="yes" xml:space="preserve">
          <source>Note that this effect can be slow if the region is particularly complex.</source>
          <target state="translated">영역이 특히 복잡한 경우이 효과가 느려질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eeca50a1ac969028e42f22bc735cdf14bff03152" translate="yes" xml:space="preserve">
          <source>Note that this flag must be set before calling &lt;a href=&quot;qthreadpool#start&quot;&gt;QThreadPool::start&lt;/a&gt;(). Calling this function after &lt;a href=&quot;qthreadpool#start&quot;&gt;QThreadPool::start&lt;/a&gt;() results in undefined behavior.</source>
          <target state="translated">&lt;a href=&quot;qthreadpool#start&quot;&gt;QThreadPool :: start&lt;/a&gt; ()를 호출하기 전에이 플래그를 설정해야합니다 . &lt;a href=&quot;qthreadpool#start&quot;&gt;QThreadPool :: start&lt;/a&gt; () 이후에이 함수를 호출하면 정의되지 않은 동작이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8c04c9e9b885d198d00eed994ce04031cd282ebc" translate="yes" xml:space="preserve">
          <source>Note that this function can be very slow if the font is large.</source>
          <target state="translated">글꼴이 크면이 기능이 매우 느려질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="82458d2bce322e91c2cd0fa1a38df6706ff8f0a1" translate="yes" xml:space="preserve">
          <source>Note that this function cannot be used to modify values in the database since the model is read-only.</source>
          <target state="translated">모델이 읽기 전용이므로이 함수를 사용하여 데이터베이스의 값을 수정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="89edc73131f01c788f424a3d261c18746067ceda" translate="yes" xml:space="preserve">
          <source>Note that this function cannot be used to obtain values in the full 32-bit range of int. Instead, use &lt;a href=&quot;qrandomgenerator#generate&quot;&gt;generate&lt;/a&gt;() and cast to int.</source>
          <target state="translated">이 함수는 전체 32 비트 범위의 int 값을 얻는 데 사용할 수 없습니다. 대신 &lt;a href=&quot;qrandomgenerator#generate&quot;&gt;generate&lt;/a&gt; ()를 사용 하고 int로 캐스트하십시오.</target>
        </trans-unit>
        <trans-unit id="9f0c9335fe7c72f0cee24568b05e244f2cecdac4" translate="yes" xml:space="preserve">
          <source>Note that this function cannot be used to obtain values in the full 32-bit range of quint32. Instead, use &lt;a href=&quot;qrandomgenerator#generate&quot;&gt;generate&lt;/a&gt;().</source>
          <target state="translated">이 함수는 quint32의 전체 32 비트 범위에서 값을 얻는 데 사용할 수 없습니다. 대신 &lt;a href=&quot;qrandomgenerator#generate&quot;&gt;generate&lt;/a&gt; ()를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="957250e6baf69685d666ab5fa364aabd5426b77b" translate="yes" xml:space="preserve">
          <source>Note that this function checks whether the item's shape or bounding rectangle (depending on</source>
          <target state="translated">이 함수는 항목의 모양 또는 경계 사각형을 확인합니다 (</target>
        </trans-unit>
        <trans-unit id="083615ca02fe431778303ad8c6d3377f25091a00" translate="yes" xml:space="preserve">
          <source>Note that this function connects the starting point of the arc to the current position if they are not already connected. After the arc has been added, the current position is the last point in arc. To draw a line back to the first point, use the &lt;a href=&quot;qpainterpath#closeSubpath&quot;&gt;closeSubpath&lt;/a&gt;() function.</source>
          <target state="translated">이 기능은 호의 시작점을 아직 연결하지 않은 경우 현재 위치에 연결합니다. 호가 추가 된 후 현재 위치는 호의 마지막 점입니다. 첫 번째 점으로 선을 다시 그리려면 &lt;a href=&quot;qpainterpath#closeSubpath&quot;&gt;closeSubpath&lt;/a&gt; () 함수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="c6bc07180f3d884a3b1da0f0161da6d872740f4a" translate="yes" xml:space="preserve">
          <source>Note that this function considers URLs with hostnames to be local file paths, even if the eventual file path cannot be opened with &lt;a href=&quot;qfile#open&quot;&gt;QFile::open&lt;/a&gt;().</source>
          <target state="translated">이 함수는 최종 파일 경로를 &lt;a href=&quot;qfile#open&quot;&gt;QFile :: open&lt;/a&gt; () 으로 열 수없는 경우에도 호스트 이름이있는 URL을 로컬 파일 경로로 간주합니다 .</target>
        </trans-unit>
        <trans-unit id="af00839828c1d89382e64d5758333deb9b7bbafb" translate="yes" xml:space="preserve">
          <source>Note that this function considers a TLD to be any domain that allows users to register subdomains under, including many home, dynamic DNS websites and blogging providers. This is useful for determining whether two websites belong to the same infrastructure and communication should be allowed, such as browser cookies: two domains should be considered part of the same website if they share at least one label in addition to the value returned by this function.</source>
          <target state="translated">이 기능은 TLD를 사용자가 많은 홈, 동적 DNS 웹 사이트 및 블로그 제공자를 포함하여 하위 도메인을 등록 할 수있는 임의의 도메인으로 간주합니다. 이 기능은 브라우저 쿠키와 같이 두 개의 웹 사이트가 동일한 인프라에 속하고 통신이 허용되어야하는지 여부를 결정하는 데 유용합니다.이 기능에서 반환 된 값 외에 하나 이상의 레이블을 공유하는 두 도메인은 동일한 웹 사이트의 일부로 간주되어야합니다. .</target>
        </trans-unit>
        <trans-unit id="4a291c967e99485f2b8faf0cde5d8593e5b03b30" translate="yes" xml:space="preserve">
          <source>Note that this function disregards the alpha buffer.</source>
          <target state="translated">이 함수는 알파 버퍼를 무시합니다.</target>
        </trans-unit>
        <trans-unit id="fa65d225bcb30ebd19ec0f94b22dc45327203c89" translate="yes" xml:space="preserve">
          <source>Note that this function does</source>
          <target state="translated">이 기능은</target>
        </trans-unit>
        <trans-unit id="141c9befa85e2763711c49d0174fd625dee24d90" translate="yes" xml:space="preserve">
          <source>Note that this function does not bind the local address of the socket prior to a connection (e.g., &lt;a href=&quot;qabstractsocket#bind&quot;&gt;QAbstractSocket::bind&lt;/a&gt;()).</source>
          <target state="translated">이 함수는 연결 전에 소켓의 로컬 주소를 바인딩하지 않습니다 (예 : &lt;a href=&quot;qabstractsocket#bind&quot;&gt;QAbstractSocket :: bind&lt;/a&gt; ()).</target>
        </trans-unit>
        <trans-unit id="63d1e9654b70ab89e9680818d98d2c751060c069" translate="yes" xml:space="preserve">
          <source>Note that this function does not bind the local port of the socket prior to a connection (e.g., &lt;a href=&quot;qabstractsocket#bind&quot;&gt;QAbstractSocket::bind&lt;/a&gt;()).</source>
          <target state="translated">이 함수는 연결 전에 소켓의 로컬 포트를 바인딩하지 않습니다 (예 : &lt;a href=&quot;qabstractsocket#bind&quot;&gt;QAbstractSocket :: bind&lt;/a&gt; ()).</target>
        </trans-unit>
        <trans-unit id="45af50554875dd7af66a2ec1c6f3b868d3896ecb" translate="yes" xml:space="preserve">
          <source>Note that this function does not change the current index. Since the current index defines the next and previous items to edit, users may find that keyboard navigation does not work as expected. To provide consistent navigation behavior, call &lt;a href=&quot;qabstractitemview#setCurrentIndex&quot;&gt;setCurrentIndex&lt;/a&gt;() before this function with the same model index.</source>
          <target state="translated">이 함수는 현재 색인을 변경하지 않습니다. 현재 색인은 편집 할 다음 및 이전 항목을 정의하므로 사용자는 키보드 탐색이 예상대로 작동하지 않을 수 있습니다. 일관된 탐색 동작을 제공하려면 동일한 모델 인덱스로이 함수 전에 &lt;a href=&quot;qabstractitemview#setCurrentIndex&quot;&gt;setCurrentIndex&lt;/a&gt; ()를 호출 하십시오.</target>
        </trans-unit>
        <trans-unit id="d22ca7e08db6ea85a02dbc7584614f6957705092" translate="yes" xml:space="preserve">
          <source>Note that this function does not return true for an IPv4 network's local broadcast address. For that, please use &lt;a href=&quot;qnetworkinterface&quot;&gt;QNetworkInterface&lt;/a&gt; to obtain the broadcast addresses of the local machine.</source>
          <target state="translated">이 기능은 IPv4 네트워크의 로컬 브로드 캐스트 주소에 대해서는 true를 반환하지 않습니다. 이를 위해 &lt;a href=&quot;qnetworkinterface&quot;&gt;QNetworkInterface&lt;/a&gt; 를 사용 하여 로컬 시스템의 브로드 캐스트 주소를 얻으십시오.</target>
        </trans-unit>
        <trans-unit id="e59a935531d25e7510f0c229964cf4a4bff7d177" translate="yes" xml:space="preserve">
          <source>Note that this function does not return true if you are using the sensor, only if another process is using the sensor.</source>
          <target state="translated">센서를 사용하는 경우 다른 프로세스가 센서를 사용하는 경우에만이 기능이 true를 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="057d0792d9dffb7b54781b3e501e9e7dfd8fc2f4" translate="yes" xml:space="preserve">
          <source>Note that this function does not set</source>
          <target state="translated">이 기능은 설정되지 않습니다</target>
        </trans-unit>
        <trans-unit id="4c045f64ac550e95cb13ef786ecd91b62233eb5f" translate="yes" xml:space="preserve">
          <source>Note that this function is frequently called by &lt;a href=&quot;qtreeview&quot;&gt;QTreeView&lt;/a&gt; and &lt;a href=&quot;qtableview&quot;&gt;QTableView&lt;/a&gt;, so margins must be implemented by &lt;a href=&quot;qabstractscrollarea&quot;&gt;QAbstractScrollArea&lt;/a&gt; subclasses. Also, if the subclasses are to be used in item views, they should not call this function.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;qtreeview&quot;&gt;QTreeView&lt;/a&gt; 및 &lt;a href=&quot;qtableview&quot;&gt;QTableView에&lt;/a&gt; 의해 자주 호출 되므로 마진은 &lt;a href=&quot;qabstractscrollarea&quot;&gt;QAbstractScrollArea&lt;/a&gt; 서브 클래스에 의해 구현되어야합니다 . 또한 서브 클래스가 항목보기에서 사용되는 경우이 함수를 호출하면 안됩니다.</target>
        </trans-unit>
        <trans-unit id="cc0f4f6c5905883cd85a0a9d47e0f19bd54998af" translate="yes" xml:space="preserve">
          <source>Note that this function is slow for images without color table.</source>
          <target state="translated">컬러 테이블이없는 이미지의 경우이 기능이 느려집니다.</target>
        </trans-unit>
        <trans-unit id="49e78598f78ed7d80ead976d700f5244342869a0" translate="yes" xml:space="preserve">
          <source>Note that this function is slower than calling the data function directly.</source>
          <target state="translated">이 함수는 데이터 함수를 직접 호출하는 것보다 느립니다.</target>
        </trans-unit>
        <trans-unit id="bc43af52d64ebd219d03ba6583dc4236dfb6951b" translate="yes" xml:space="preserve">
          <source>Note that this function is usually faster than calling &lt;a href=&quot;qitemselectionmodel#isSelected&quot;&gt;isSelected&lt;/a&gt;() on all items in the same column and that unselectable items are ignored.</source>
          <target state="translated">이 함수는 일반적으로 같은 열의 모든 항목에서 &lt;a href=&quot;qitemselectionmodel#isSelected&quot;&gt;isSelected&lt;/a&gt; ()를 호출하는 것보다 빠르며 선택할 수없는 항목은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="6f8de48235a7a14b697ba38a7ebfd050c2d9566b" translate="yes" xml:space="preserve">
          <source>Note that this function is usually faster than calling &lt;a href=&quot;qitemselectionmodel#isSelected&quot;&gt;isSelected&lt;/a&gt;() on all items in the same row and that unselectable items are ignored.</source>
          <target state="translated">이 함수는 일반적으로 같은 행의 모든 ​​항목에서 &lt;a href=&quot;qitemselectionmodel#isSelected&quot;&gt;isSelected&lt;/a&gt; ()를 호출하는 것보다 빠르며 선택할 수없는 항목은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="53cc6c6ab192e1f99f895008a634225b164961db" translate="yes" xml:space="preserve">
          <source>Note that this function is usually faster than calling &lt;a href=&quot;qml-qtqml-models-itemselectionmodel#isSelected-method&quot;&gt;isSelected()&lt;/a&gt; on all items in the same column, and that unselectable items are ignored.</source>
          <target state="translated">이 함수는 일반적으로 같은 열의 모든 항목에서 &lt;a href=&quot;qml-qtqml-models-itemselectionmodel#isSelected-method&quot;&gt;isSelected ()&lt;/a&gt; 를 호출하는 것보다 빠르며 선택할 수없는 항목은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="8d606da5028cb9a03bb5f3c30784d41fd26a101f" translate="yes" xml:space="preserve">
          <source>Note that this function is usually faster than calling &lt;a href=&quot;qml-qtqml-models-itemselectionmodel#isSelected-method&quot;&gt;isSelected()&lt;/a&gt; on all items in the same row, and that unselectable items are ignored.</source>
          <target state="translated">이 함수는 일반적으로 같은 행의 모든 ​​항목에서 &lt;a href=&quot;qml-qtqml-models-itemselectionmodel#isSelected-method&quot;&gt;isSelected ()&lt;/a&gt; 를 호출하는 것보다 빠르며 선택할 수없는 항목은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="70f63da4a9d9cf58667b6a462ae1c2ef51d57231" translate="yes" xml:space="preserve">
          <source>Note that this function must be called before &lt;a href=&quot;qaxbase#control-prop&quot;&gt;setControl&lt;/a&gt;() to have any effect.</source>
          <target state="translated">&lt;a href=&quot;qaxbase#control-prop&quot;&gt;setControl&lt;/a&gt; () 전에이 함수를 호출해야 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b38da33bd7eff723801bbfd876341bd1b87a8da9" translate="yes" xml:space="preserve">
          <source>Note that this function must be called from the constructor.</source>
          <target state="translated">이 함수는 생성자에서 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="447378543cc02dd5686056ff3d322fef507f63b4" translate="yes" xml:space="preserve">
          <source>Note that this function must be called immediately after construction of the object</source>
          <target state="translated">이 함수는 객체를 생성 한 직후에 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="54d852496abfc649a22c7004518952bec33b922b" translate="yes" xml:space="preserve">
          <source>Note that this function must be called immediately after construction of the object.</source>
          <target state="translated">이 함수는 객체를 생성 한 직후에 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="5137f228aead599d21cbad86c66c22ef1010b098" translate="yes" xml:space="preserve">
          <source>Note that this function must be called or you will not be able to send readings to the front end.</source>
          <target state="translated">이 기능을 호출해야합니다. 그렇지 않으면 프런트 엔드에 판독 값을 보낼 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="8bf37ee82496c2730e2cd5f4bbf7c93b8b7ba862" translate="yes" xml:space="preserve">
          <source>Note that this function only changes state if you call &lt;a href=&quot;qdbuspendingcallwatcher#waitForFinished&quot;&gt;waitForFinished&lt;/a&gt;() or if an external D-Bus event happens, which in general only happens if you return to the event loop execution.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;qdbuspendingcallwatcher#waitForFinished&quot;&gt;waitForFinished&lt;/a&gt; () 를 호출 하거나 외부 D-Bus 이벤트가 발생하는 경우에만 상태를 변경 합니다. 일반적으로 이벤트 루프 실행으로 돌아가는 경우에만 발생합니다.</target>
        </trans-unit>
        <trans-unit id="822df7195b9b0b3600d3c5809e63c294e814391a" translate="yes" xml:space="preserve">
          <source>Note that this function only changes state if you call &lt;a href=&quot;qdbuspendingreply#waitForFinished&quot;&gt;waitForFinished&lt;/a&gt;() or if an external D-Bus event happens, which in general only happens if you return to the event loop execution.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;qdbuspendingreply#waitForFinished&quot;&gt;waitForFinished&lt;/a&gt; () 를 호출 하거나 외부 D-Bus 이벤트가 발생하는 경우에만 상태를 변경 합니다. 일반적으로 이벤트 루프 실행으로 돌아가는 경우에만 발생합니다.</target>
        </trans-unit>
        <trans-unit id="54c0430245420f8fb55606425f1892038c44c66c" translate="yes" xml:space="preserve">
          <source>Note that this function only has effect for linear and radial gradients.</source>
          <target state="translated">이 기능은 선형 및 방사형 그래디언트에만 영향을 미칩니다.</target>
        </trans-unit>
        <trans-unit id="e9e6ffc11a6bbabcbf2fb07e4786bd6b30edd48d" translate="yes" xml:space="preserve">
          <source>Note that this function only makes sense in documents without complex objects such as tables or frames.</source>
          <target state="translated">이 기능은 테이블이나 프레임과 같은 복잡한 개체가없는 문서에서만 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="d3a8df00f4930c6c3aaf586a2c74999cc70ae7b0" translate="yes" xml:space="preserve">
          <source>Note that this function performs no conversion from other types to &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt;.</source>
          <target state="translated">이 함수는 다른 유형에서 &lt;a href=&quot;qbytearray&quot;&gt;QByteArray로&lt;/a&gt; 변환하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="ffbeb033e746c08f045dd704479e3fabdf4464c1" translate="yes" xml:space="preserve">
          <source>Note that this function performs no conversion from other types to &lt;a href=&quot;qcborarray&quot;&gt;QCborArray&lt;/a&gt;.</source>
          <target state="translated">이 함수는 다른 유형에서 &lt;a href=&quot;qcborarray&quot;&gt;QCborArray로&lt;/a&gt; 변환하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="2987e8c3215482d97452eefda289082f350c2209" translate="yes" xml:space="preserve">
          <source>Note that this function performs no conversion from other types to &lt;a href=&quot;qcbormap&quot;&gt;QCborMap&lt;/a&gt;.</source>
          <target state="translated">이 함수는 다른 유형에서 &lt;a href=&quot;qcbormap&quot;&gt;QCborMap으로&lt;/a&gt; 변환하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="9963abd12d14bea702fabc68928b4e049261919e" translate="yes" xml:space="preserve">
          <source>Note that this function performs no conversion from other types to &lt;a href=&quot;qdatetime&quot;&gt;QDateTime&lt;/a&gt;.</source>
          <target state="translated">이 함수는 다른 유형에서 &lt;a href=&quot;qdatetime&quot;&gt;QDateTime으로&lt;/a&gt; 변환하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="3ba5dc24f8d3c66abfc3487a3ace4ce747022589" translate="yes" xml:space="preserve">
          <source>Note that this function performs no conversion from other types to &lt;a href=&quot;qregularexpression&quot;&gt;QRegularExpression&lt;/a&gt;.</source>
          <target state="translated">이 함수는 다른 유형에서 &lt;a href=&quot;qregularexpression&quot;&gt;QRegularExpression으로&lt;/a&gt; 변환하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="50c820531c4b331f4cd429cffeed01c4ec51ae87" translate="yes" xml:space="preserve">
          <source>Note that this function performs no conversion from other types to &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;.</source>
          <target state="translated">이 함수는 다른 유형에서 &lt;a href=&quot;qstring&quot;&gt;QString으로&lt;/a&gt; 변환하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="2857fe927c06830b76face6ef42288f687e6acd7" translate="yes" xml:space="preserve">
          <source>Note that this function performs no conversion from other types to &lt;a href=&quot;qurl&quot;&gt;QUrl&lt;/a&gt;.</source>
          <target state="translated">이 함수는 다른 유형에서 &lt;a href=&quot;qurl&quot;&gt;QUrl&lt;/a&gt; 로의 변환을 수행하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="5857052c6bf6e66f1d6f53f0f33830a0b30e088f" translate="yes" xml:space="preserve">
          <source>Note that this function performs no conversion from other types to &lt;a href=&quot;quuid&quot;&gt;QUuid&lt;/a&gt;.</source>
          <target state="translated">이 함수는 다른 유형에서 &lt;a href=&quot;quuid&quot;&gt;QUuid&lt;/a&gt; 로의 변환을 수행하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="d95bec0bd2c8dc6c8cad81f09b385de0d88196c7" translate="yes" xml:space="preserve">
          <source>Note that this function replaces the previous values. &lt;a href=&quot;qmatrix&quot;&gt;QMatrix&lt;/a&gt; provide the &lt;a href=&quot;qmatrix#translate&quot;&gt;translate&lt;/a&gt;(), &lt;a href=&quot;qmatrix#rotate&quot;&gt;rotate&lt;/a&gt;(), &lt;a href=&quot;qmatrix#scale&quot;&gt;scale&lt;/a&gt;() and &lt;a href=&quot;qmatrix#shear&quot;&gt;shear&lt;/a&gt;() convenience functions to manipulate the various matrix elements based on the currently defined coordinate system.</source>
          <target state="translated">이 함수는 이전 값을 대체합니다. &lt;a href=&quot;qmatrix&quot;&gt;QMatrix&lt;/a&gt; 는 현재 정의 된 좌표계를 기반으로 다양한 행렬 요소를 조작 할 수있는 &lt;a href=&quot;qmatrix#translate&quot;&gt;변환&lt;/a&gt; (), &lt;a href=&quot;qmatrix#rotate&quot;&gt;회전&lt;/a&gt; (), &lt;a href=&quot;qmatrix#scale&quot;&gt;배율&lt;/a&gt; () 및 &lt;a href=&quot;qmatrix#shear&quot;&gt;전단&lt;/a&gt; () 편의 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="eba4495a7f131de44a4600085c69c301ff65023a" translate="yes" xml:space="preserve">
          <source>Note that this function returns immediately, and therefore may not work if the</source>
          <target state="translated">이 함수는 즉시 반환되므로</target>
        </trans-unit>
        <trans-unit id="e1eff6c5172fe9d07fd526735d5573e2bd79a3b3" translate="yes" xml:space="preserve">
          <source>Note that this function returns the states for all configurations as they are known at the time of this function call. If for instance a configuration of type WLAN is defined the system may have to perform a WLAN scan in order to determine whether it is actually available. To obtain the most accurate state &lt;a href=&quot;qnetworkconfigurationmanager#updateConfigurations&quot;&gt;updateConfigurations&lt;/a&gt;() should be used to update each configuration's state. Note that such an update may require some time. It's completion is signalled by &lt;a href=&quot;qnetworkconfigurationmanager#updateCompleted&quot;&gt;updateCompleted&lt;/a&gt;(). In the absence of a configuration update this function returns the best estimate at the time of the call. Therefore, if WLAN configurations are of interest, it is recommended that &lt;a href=&quot;qnetworkconfigurationmanager#updateConfigurations&quot;&gt;updateConfigurations&lt;/a&gt;() is called once after &lt;a href=&quot;qnetworkconfigurationmanager&quot;&gt;QNetworkConfigurationManager&lt;/a&gt; instantiation (WLAN scans are too time consuming to perform in constructor). After this the data is kept automatically up-to-date as the system reports any changes.</source>
          <target state="translated">이 함수는이 함수 호출시 알려진대로 모든 구성의 상태를 반환합니다. 예를 들어 WLAN 유형의 구성이 정의 된 경우 시스템은 실제로 사용 가능한지 확인하기 위해 WLAN 스캔을 수행해야 할 수도 있습니다. 가장 정확한 상태 얻으려면 &lt;a href=&quot;qnetworkconfigurationmanager#updateConfigurations&quot;&gt;updateConfigurations을&lt;/a&gt; () 각 구성의 상태를 업데이트하는 데 사용되어야한다. 이러한 업데이트에는 다소 시간이 걸릴 수 있습니다. 완료는 &lt;a href=&quot;qnetworkconfigurationmanager#updateCompleted&quot;&gt;updateCompleted&lt;/a&gt; ()에 의해 표시됩니다 . 구성 업데이트가없는 경우이 함수는 통화시 최상의 추정치를 반환합니다. 따라서 WLAN 구성에 관심이있는 경우 &lt;a href=&quot;qnetworkconfigurationmanager&quot;&gt;QNetworkConfigurationManager&lt;/a&gt; 다음에 &lt;a href=&quot;qnetworkconfigurationmanager#updateConfigurations&quot;&gt;updateConfigurations&lt;/a&gt; ()를 한 번 호출 하는 것이 좋습니다.인스턴스화 (WLAN 스캔은 생성자에서 수행하는 데 너무 많은 시간이 걸립니다). 이 후 시스템이 변경 사항을보고함에 따라 데이터가 자동으로 최신 상태로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="61d615f1aef94618c6b62c935a550d7b8803c818" translate="yes" xml:space="preserve">
          <source>Note that this function should be called from the constructor so that the information is available immediately.</source>
          <target state="translated">정보를 즉시 사용할 수 있도록 생성자에서이 함수를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="9fe58e1a23975057e852c22d8374d85738d475f8" translate="yes" xml:space="preserve">
          <source>Note that this function should be called immediately after construction of the object.</source>
          <target state="translated">이 함수는 오브젝트 생성 직후에 호출되어야합니다.</target>
        </trans-unit>
        <trans-unit id="199f4694f60ba4d6a65f15519ec8dcb90f9a4ce5" translate="yes" xml:space="preserve">
          <source>Note that this function should not be called explicitly by the user, since it's meant for reimplementation purposes only. The function is called by Qt internally, and the default implementation may not always return a valid pointer.</source>
          <target state="translated">이 함수는 재 구현 목적으로 만 사용되므로 사용자가 명시 적으로 호출하면 안됩니다. 이 함수는 내부적으로 Qt에 의해 호출되며 기본 구현이 항상 유효한 포인터를 반환하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="e4335eae29ede077ea2c279292d96093c10fc135" translate="yes" xml:space="preserve">
          <source>Note that this function should only be called when the item wants to stop handling further events. There is no need to call this function after a release or cancel event since no future events will be received in any case. No move or release events will be delivered after this function was called.</source>
          <target state="translated">이 함수는 항목이 추가 이벤트 처리를 중지하려는 경우에만 호출해야합니다. 어떤 경우에도 향후 이벤트가 수신되지 않으므로 릴리스 또는 취소 이벤트 후에이 기능을 호출 할 필요가 없습니다. 이 함수가 호출 된 후 이동 또는 해제 이벤트가 전달되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4760c406f66be14439eb6452aefac4fafde58d95" translate="yes" xml:space="preserve">
          <source>Note that this function will lazily create an item for the index (using &lt;a href=&quot;qstandarditemmodel#itemPrototype&quot;&gt;itemPrototype&lt;/a&gt;()), and set it in the parent item's child table, if no item already exists at that index.</source>
          <target state="translated">이 함수는 인덱스에 대한 항목을 느리게 생성하고 ( &lt;a href=&quot;qstandarditemmodel#itemPrototype&quot;&gt;itemPrototype&lt;/a&gt; () 사용) 해당 인덱스에 항목이없는 경우 상위 항목의 자식 테이블에 설정합니다.</target>
        </trans-unit>
        <trans-unit id="bd877185eb4e8cdfd6c8ebf47639900516dfafbf" translate="yes" xml:space="preserve">
          <source>Note that this function will not return until the process is terminated.</source>
          <target state="translated">이 기능은 프로세스가 종료 될 때까지 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4426b1aa6bb3551f8dae2ea65a0077596ce0b206" translate="yes" xml:space="preserve">
          <source>Note that this function, unlike &lt;a href=&quot;qstandarditem#takeRow&quot;&gt;takeRow&lt;/a&gt;() and &lt;a href=&quot;qstandarditem#takeColumn&quot;&gt;takeColumn&lt;/a&gt;(), does not affect the dimensions of the child table.</source>
          <target state="translated">&lt;a href=&quot;qstandarditem#takeRow&quot;&gt;takeRow&lt;/a&gt; () 및 &lt;a href=&quot;qstandarditem#takeColumn&quot;&gt;takeColumn&lt;/a&gt; () 과 달리이 함수 는 자식 테이블의 차원에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ec83ed01a7cb80d0f34f5ba1b11d0baf4ff682c6" translate="yes" xml:space="preserve">
          <source>Note that this gives no indication of whether the character is available in a particular font.</source>
          <target state="translated">이것은 특정 글꼴에서 문자를 사용할 수 있는지 여부를 나타내지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ccbdbea2eafeeb5fcddc3f3c32da52e400e7f8b1" translate="yes" xml:space="preserve">
          <source>Note that this has nothing to do with &lt;a href=&quot;qdatastream#version&quot;&gt;QDataStream::version&lt;/a&gt;().</source>
          <target state="translated">이것은 &lt;a href=&quot;qdatastream#version&quot;&gt;QDataStream :: version&lt;/a&gt; () 과 관련이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="69cf3eab0cffbba8899986854e9d37ed5d2229aa" translate="yes" xml:space="preserve">
          <source>Note that this implicitly adds this graphics item to the scene of the parent. You should not &lt;a href=&quot;qgraphicsscene#addItem&quot;&gt;add&lt;/a&gt; the item to the scene yourself.</source>
          <target state="translated">이렇게하면이 그래픽 항목이 상위 장면에 암시 적으로 추가됩니다. 항목을 장면에 직접 &lt;a href=&quot;qgraphicsscene#addItem&quot;&gt;추가&lt;/a&gt; 해서는 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="d0ea8a2c4a30d8d2a4a9c7a7726808587d58c12d" translate="yes" xml:space="preserve">
          <source>Note that this information is not mandatory as not all sensors have a rate at which they run. In such cases, the list will be empty.</source>
          <target state="translated">모든 센서가 작동 속도를 갖는 것은 아니기 때문에이 정보가 필수는 아닙니다. 이러한 경우 목록이 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec3c7da67cb04f30701e5b4cb700b4b6ab2639a3" translate="yes" xml:space="preserve">
          <source>Note that this information is not mandatory. This information is typically only available for sensors that have selectable output ranges (such as typical accelerometers).</source>
          <target state="translated">이 정보는 필수가 아닙니다. 이 정보는 일반적으로 선택 가능한 출력 범위가있는 센서 (예 : 일반 가속도계)에만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a61b288cfd27d3ace9551d07315b034f18b2e91a" translate="yes" xml:space="preserve">
          <source>Note that this interface includes only those DTD events that the XML recommendation requires processors to report, i.e. notation and unparsed entity declarations using &lt;a href=&quot;qxmldtdhandler#notationDecl&quot;&gt;notationDecl&lt;/a&gt;() and &lt;a href=&quot;qxmldtdhandler#unparsedEntityDecl&quot;&gt;unparsedEntityDecl&lt;/a&gt;() respectively.</source>
          <target state="translated">이 인터페이스에는 XML 권장 사항에서 프로세서가보고해야하는 DTD 이벤트 (예 : &lt;a href=&quot;qxmldtdhandler#notationDecl&quot;&gt;notationDecl&lt;/a&gt; () 및 &lt;a href=&quot;qxmldtdhandler#unparsedEntityDecl&quot;&gt;unparsedEntityDecl&lt;/a&gt; ()를 사용하는 표기법 및 구문 분석되지 않은 엔티티 선언 ) 만 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="cc1cba068eed22b40aac5b628e3eebcf6c19bc5a" translate="yes" xml:space="preserve">
          <source>Note that this is a non-hierarchical model, so we don't have to worry about the parent-child relationships. If our model was hierarchical, we would also have to implement the &lt;a href=&quot;qabstractitemmodel#index&quot;&gt;index()&lt;/a&gt; and &lt;a href=&quot;qabstractitemmodel#parent&quot;&gt;parent()&lt;/a&gt; functions.</source>
          <target state="translated">이것은 비 계층 적 모델이므로 부모-자식 관계에 대해 걱정할 필요가 없습니다. 모델이 계층 적이라면 &lt;a href=&quot;qabstractitemmodel#index&quot;&gt;index ()&lt;/a&gt; 및 &lt;a href=&quot;qabstractitemmodel#parent&quot;&gt;parent ()&lt;/a&gt; 함수 도 구현해야 합니다.</target>
        </trans-unit>
        <trans-unit id="59fbba0d26a249304195a721597a0d19089108dc" translate="yes" xml:space="preserve">
          <source>Note that this is a strict equality, especially for page size where the &lt;a href=&quot;qpagesize&quot;&gt;QPageSize&lt;/a&gt; ID, name and size must exactly match, and the margins where the units must match.</source>
          <target state="translated">이는 특히 &lt;a href=&quot;qpagesize&quot;&gt;QPageSize&lt;/a&gt; ID, 이름 및 크기가 정확히 일치 해야하는 페이지 크기 및 단위가 일치해야하는 여백에 대해 엄격한 평등 입니다.</target>
        </trans-unit>
        <trans-unit id="76e0070e4c3c29abb9dfe8517f9dd92740f9cd6f" translate="yes" xml:space="preserve">
          <source>Note that this is a template function so it should be called with the appropriate type.</source>
          <target state="translated">이것은 템플릿 함수이므로 적절한 유형으로 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="ff329605d834e830b2f08e4d2eba30d0a884f7e6" translate="yes" xml:space="preserve">
          <source>Note that this is not namespace aware. For instance, if this &lt;a href=&quot;qxmlstreamattributes&quot;&gt;QXmlStreamAttributes&lt;/a&gt; contains an attribute whose lexical name is &quot;xlink:href&quot; this doesn't tell that an attribute named &lt;code&gt;href&lt;/code&gt; in the XLink namespace is present, since the &lt;code&gt;xlink&lt;/code&gt; prefix can be bound to any namespace. Use the overload that takes a namespace URI and a local name as parameter, for namespace aware code.</source>
          <target state="translated">이것은 네임 스페이스를 인식하지 않습니다. 예를 들어,이 &lt;a href=&quot;qxmlstreamattributes&quot;&gt;QXmlStreamAttributes&lt;/a&gt; 에 어휘 이름이 &quot;xlink : href&quot;인 속성 이 포함되어 있으면 &lt;code&gt;xlink&lt;/code&gt; 접두어가 모든 네임 스페이스에 바인딩 될 수 있으므로 XLink 네임 스페이스에 &lt;code&gt;href&lt;/code&gt; 라는 속성 이 존재 한다는 것을 나타내지 않습니다 . 네임 스페이스 인식 코드의 경우 네임 스페이스 URI 및 로컬 이름을 매개 변수로 사용하는 오버로드를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="56abcf1f90a668cdf6c04c1288695aa4169a6ade" translate="yes" xml:space="preserve">
          <source>Note that this is the column number relative to a wrapped line, not relative to the block (i.e. the paragraph).</source>
          <target state="translated">이것은 블록 (즉, 단락)에 대한 것이 아니라 줄 바꿈 된 행에 대한 열 번호입니다.</target>
        </trans-unit>
        <trans-unit id="9fb2b9c4ae649e208ea990cd69b40a5d9372e8dc" translate="yes" xml:space="preserve">
          <source>Note that this item is not a visual representation of a gradient. To display a gradient, use a visual item (like &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt;) which supports the use of gradients.</source>
          <target state="translated">이 항목은 그라디언트의 시각적 표현이 아닙니다. 그라디언트를 표시하려면 그라디언트 사용을 지원하는 시각적 항목 (예 : &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt; )을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c4871718f2fb7ad6e203d22311a1271557d57e43" translate="yes" xml:space="preserve">
          <source>Note that this list is not localized. For a localized representation re-implement &lt;a href=&quot;qaccessibleactioninterface#localizedActionName&quot;&gt;localizedActionName&lt;/a&gt;() and &lt;a href=&quot;qaccessibleactioninterface#localizedActionDescription&quot;&gt;localizedActionDescription&lt;/a&gt;()</source>
          <target state="translated">이 목록은 현지화되지 않았습니다. 현지화 된 표현의 경우 &lt;a href=&quot;qaccessibleactioninterface#localizedActionName&quot;&gt;localizedActionName&lt;/a&gt; () 및 &lt;a href=&quot;qaccessibleactioninterface#localizedActionDescription&quot;&gt;localizedActionDescription&lt;/a&gt; ()을 다시 구현하십시오.</target>
        </trans-unit>
        <trans-unit id="90d4c55792121b5e05cfba2c2ad94424362ebefc" translate="yes" xml:space="preserve">
          <source>Note that this macro is only available if using &lt;code&gt;CMake&lt;/code&gt; 2.8.9 or later. This macro is obsolete. Use target_link_libraries with IMPORTED targets instead.</source>
          <target state="translated">이 매크로는 &lt;code&gt;CMake&lt;/code&gt; 2.8.9 이상을 사용하는 경우에만 사용할 수 있습니다 . 이 매크로는 더 이상 사용되지 않습니다. 대신 IMPORTED 대상과 함께 target_link_libraries를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="9a8f10f676bb7036f0180d8d0cb0923380805a54" translate="yes" xml:space="preserve">
          <source>Note that this macro is only available if using &lt;code&gt;CMake&lt;/code&gt; 3.9 or later.</source>
          <target state="translated">이 매크로는 &lt;code&gt;CMake&lt;/code&gt; 3.9 이상을 사용하는 경우에만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0b9ddd4ba220faf72039d76e7bf47e2aebfd11e1" translate="yes" xml:space="preserve">
          <source>Note that this may be 1, in which case the sensor does not support any form of buffering. In that case, &lt;a href=&quot;qsensor#isFeatureSupported&quot;&gt;isFeatureSupported&lt;/a&gt;(&lt;a href=&quot;qsensor#Feature-enum&quot;&gt;QSensor::Buffering&lt;/a&gt;) will also return false.</source>
          <target state="translated">이 값은 1 일 수 있으며,이 경우 센서는 어떤 형태의 버퍼링도 지원하지 않습니다. 이 경우 &lt;a href=&quot;qsensor#isFeatureSupported&quot;&gt;isFeatureSupported&lt;/a&gt; ( QSensor &lt;a href=&quot;qsensor#Feature-enum&quot;&gt;:: Buffering&lt;/a&gt; )도 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ddd70a9aad05e50b2724361b223e9cd137d74aae" translate="yes" xml:space="preserve">
          <source>Note that this method is generally used to check whether the item is under the mouse cursor, and for that reason, the implementation of this function should be as light-weight as possible.</source>
          <target state="translated">이 방법은 일반적으로 항목이 마우스 커서 아래에 있는지 확인하는 데 사용되므로이 기능의 구현은 가능한 한 가벼워 야합니다.</target>
        </trans-unit>
        <trans-unit id="65aee6708cb5d30c2f14124c9f14ee6ee58a6947" translate="yes" xml:space="preserve">
          <source>Note that this neither waits nor cancels the asynchronous computation. Use &lt;a href=&quot;qfuture#waitForFinished&quot;&gt;waitForFinished&lt;/a&gt;() or &lt;a href=&quot;qfuturesynchronizer&quot;&gt;QFutureSynchronizer&lt;/a&gt; when you need to ensure that the computation is completed before the future is destroyed.</source>
          <target state="translated">이것은 비동기 계산을 기다리거나 취소하지 않습니다. 미래가 파괴되기 전에 계산이 완료되었는지 확인해야 할 경우 &lt;a href=&quot;qfuture#waitForFinished&quot;&gt;waitForFinished&lt;/a&gt; () 또는 &lt;a href=&quot;qfuturesynchronizer&quot;&gt;QFutureSynchronizer를&lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="47d034e99dd278f42c39dcec005a226b7e7f20cf" translate="yes" xml:space="preserve">
          <source>Note that this only changes when measuring geomagnetic flux density. Raw magnetic flux readings will always have a value of 1.</source>
          <target state="translated">지자기 플럭스 밀도를 측정 할 때만 변경됩니다. 원시 자속 측정 값은 항상 1입니다.</target>
        </trans-unit>
        <trans-unit id="60a56910f468bc8ada1bb2c0aa1416877b2a43e8" translate="yes" xml:space="preserve">
          <source>Note that this only prevents new instance of the backend from being created. It does not invalidate the existing instances of the backend. The backend code should handle the disappearance of the underlying hardware itself.</source>
          <target state="translated">이렇게하면 백엔드의 새 인스턴스가 작성되지 않습니다. 백엔드의 기존 인스턴스를 무효화하지 않습니다. 백엔드 코드는 기본 하드웨어 자체의 소멸을 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="edd7fd8d3370885ba5497b96fafdc4e9101d8f9b" translate="yes" xml:space="preserve">
          <source>Note that this property affects object instantiation only; it is unrelated to loading a component asynchronously via a network.</source>
          <target state="translated">이 속성은 객체 인스턴스화에만 영향을 미칩니다. 네트워크를 통해 컴포넌트를 비동기식으로로드하는 것과는 관련이 없습니다.</target>
        </trans-unit>
        <trans-unit id="5f5aedda3afb2b2fc9690433553361c1a8150ab2" translate="yes" xml:space="preserve">
          <source>Note that this property does not affect the serialization or deserialization of &lt;code&gt;qfloat16&lt;/code&gt; instances.</source>
          <target state="translated">이 속성은 &lt;code&gt;qfloat16&lt;/code&gt; 인스턴스 의 직렬화 또는 역 직렬화에 영향을 미치지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="f9c126376b2267efe6eab51d68ad7c07fc5010e1" translate="yes" xml:space="preserve">
          <source>Note that this property is only valid for images read from the local filesystem. Images loaded via a network resource (e.g. HTTP) are always loaded asynchronously.</source>
          <target state="translated">이 특성은 로컬 파일 시스템에서 읽은 이미지에만 유효합니다. 네트워크 리소스 (예 : HTTP)를 통해로드 된 이미지는 항상 비동기 적으로로드됩니다.</target>
        </trans-unit>
        <trans-unit id="bbcd9cfc1f5508ebfafcf55352460c164fc4972f" translate="yes" xml:space="preserve">
          <source>Note that this property should be a regular expression in JS syntax, e.g /a/ for the regular expression matching &quot;a&quot;.</source>
          <target state="translated">이 속성은 JS 구문의 정규 표현식이어야합니다 (예 : &quot;a&quot;와 일치하는 정규 표현식의 경우 / a /).</target>
        </trans-unit>
        <trans-unit id="7a3ff0bf4a7ad0b0aba3ef822a5bb8929ba75c04" translate="yes" xml:space="preserve">
          <source>Note that this signal is</source>
          <target state="translated">이 신호는</target>
        </trans-unit>
        <trans-unit id="0db174405cf72778e45d0505dc0183a86f18e9e9" translate="yes" xml:space="preserve">
          <source>Note that this signal is also emitted whenever the</source>
          <target state="translated">이 신호는</target>
        </trans-unit>
        <trans-unit id="60883fb603150b15c766c5c0da2e89620569fb30" translate="yes" xml:space="preserve">
          <source>Note that this signal will not be emitted when the item model is reset.</source>
          <target state="translated">이 신호는 아이템 모델이 재설정 될 때 방출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f37e4351285d36785f017ddf98163a1fb539d504" translate="yes" xml:space="preserve">
          <source>Note that this will return 0 until a sensor backend is connected to a backend.</source>
          <target state="translated">센서 백엔드가 백엔드에 연결될 때까지 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="04e5e13e0b61dcfd9d929320c6ba7df6dd3a842b" translate="yes" xml:space="preserve">
          <source>Note that to ensure a valid list of current configurations immediately available, updating is done during construction which causes some delay.</source>
          <target state="translated">현재 사용 가능한 현재 구성의 유효한 목록을 보장하기 위해 구성 중에 업데이트가 수행되어 약간의 지연이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3d721fd17d63462060f2f1f7117b91fae0764107" translate="yes" xml:space="preserve">
          <source>Note that to save an already</source>
          <target state="translated">이미 저장하려면</target>
        </trans-unit>
        <trans-unit id="ff8fde53d6112bd49c1f0e8a55a917dd4574c8b9" translate="yes" xml:space="preserve">
          <source>Note that type information is not preserved when reading settings from INI files; all values will be returned as &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;.</source>
          <target state="translated">INI 파일에서 설정을 읽을 때 유형 정보가 유지되지 않습니다. 모든 값은 &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; 으로 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="553b2b8d297e93b6a6f9077530c7cd8270789282" translate="yes" xml:space="preserve">
          <source>Note that typically the top left corner of this rectangle will be &lt;code&gt;0,0&lt;/code&gt; while the width and height will be the width and height of the input content. Only when the video source has a viewport set, these values will differ.</source>
          <target state="translated">일반적으로이 사각형의 왼쪽 위 모서리는 &lt;code&gt;0,0&lt;/code&gt; 인 반면 너비와 높이는 입력 내용의 너비와 높이입니다. 비디오 소스에 뷰포트가 설정된 경우에만이 값이 달라집니다.</target>
        </trans-unit>
        <trans-unit id="8644872c2e7593f935d7e5b82915d3269ca1c8cc" translate="yes" xml:space="preserve">
          <source>Note that unbound parameters will retain their values.</source>
          <target state="translated">언 바운드 매개 변수는 해당 값을 유지합니다.</target>
        </trans-unit>
        <trans-unit id="1ce93a7eba6868c61b3eb1b6b2391858ea1d8d5e" translate="yes" xml:space="preserve">
          <source>Note that unbuffered devices, which have no way of determining what can be read, always return false.</source>
          <target state="translated">읽을 수있는 것을 결정할 방법이없는 버퍼되지 않은 장치는 항상 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="08783f938b7e6bc16ea07e038c60bd5292cacb9e" translate="yes" xml:space="preserve">
          <source>Note that unlike &lt;a href=&quot;qml-qtquick-propertychanges&quot;&gt;PropertyChanges&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-parentchange&quot;&gt;ParentChange&lt;/a&gt; expects an Item-based target; it will not work with arbitrary objects (for example, you couldn't use it to reparent a Timer).</source>
          <target state="translated">그와는 달리 주 &lt;a href=&quot;qml-qtquick-propertychanges&quot;&gt;PropertyChanges을&lt;/a&gt; , &lt;a href=&quot;qml-qtquick-parentchange&quot;&gt;ParentChange은&lt;/a&gt; 아이템 기반의 타겟이 예상; 임의의 개체에서는 작동하지 않습니다 (예 : 타이머를 다시 설정하는 데 사용할 수 없음).</target>
        </trans-unit>
        <trans-unit id="a2a6cbecdb93920d99f6b0ba618ddebcb6df3376" translate="yes" xml:space="preserve">
          <source>Note that unlike &lt;a href=&quot;qml-qtquick-spritesequence&quot;&gt;SpriteSequence&lt;/a&gt;, the &lt;a href=&quot;qml-qtquick-animatedsprite&quot;&gt;AnimatedSprite&lt;/a&gt; type does not use &lt;a href=&quot;qml-qtquick-sprite&quot;&gt;Sprite&lt;/a&gt; to define multiple animations, but instead encapsulates a single animation itself.</source>
          <target state="translated">참고 달리 것을 &lt;a href=&quot;qml-qtquick-spritesequence&quot;&gt;SpriteSequence&lt;/a&gt; 의 &lt;a href=&quot;qml-qtquick-animatedsprite&quot;&gt;AnimatedSprite의&lt;/a&gt; 유형은 사용하지 않습니다 &lt;a href=&quot;qml-qtquick-sprite&quot;&gt;스프라이트를&lt;/a&gt; 여러 애니메이션을 정의하는 대신 하나의 애니메이션 자체를 캡슐화합니다.</target>
        </trans-unit>
        <trans-unit id="6c892ab9996d9ed132a0caf6c18171f3c4f68e97" translate="yes" xml:space="preserve">
          <source>Note that unlike &lt;a href=&quot;qstring#fromUtf16&quot;&gt;fromUtf16&lt;/a&gt;(), this function does not consider BOMs and possibly differing byte ordering.</source>
          <target state="translated">&lt;a href=&quot;qstring#fromUtf16&quot;&gt;Utf16&lt;/a&gt; () 과 달리이 함수는 BOM 및 다른 바이트 순서를 고려하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ae24a2278244dcc61b9830812aa5f432cca9458b" translate="yes" xml:space="preserve">
          <source>Note that unlike in most other &lt;a href=&quot;qiodevice&quot;&gt;QIODevice&lt;/a&gt; subclasses, open() may not open the device directly. The function return false if the socket was already connected or if the server to connect to was not defined and true in any other case. The &lt;a href=&quot;qlocalsocket#connected&quot;&gt;connected&lt;/a&gt;() or &lt;a href=&quot;qlocalsocket#error&quot;&gt;error&lt;/a&gt;() signals will be emitted once the device is actualy open (or the connection failed).</source>
          <target state="translated">대부분의 다른 &lt;a href=&quot;qiodevice&quot;&gt;QIODevice&lt;/a&gt; 서브 클래스 와 달리 open ()은 장치를 직접 열지 못할 수도 있습니다. 소켓이 이미 연결되었거나 연결할 서버가 정의되지 않은 경우 함수는 false를 리턴하고 다른 경우에는 true를 리턴합니다. &lt;a href=&quot;qlocalsocket#connected&quot;&gt;접속&lt;/a&gt; () 또는 &lt;a href=&quot;qlocalsocket#error&quot;&gt;에러&lt;/a&gt; () 신호 장치 actualy 열리면 출사된다 (또는 접속 실패).</target>
        </trans-unit>
        <trans-unit id="68f2011c273029cd30c8054b677da56953324cf1" translate="yes" xml:space="preserve">
          <source>Note that unlike the &lt;a href=&quot;qpainter#drawPolygon&quot;&gt;drawPolygon&lt;/a&gt;() function the last point is</source>
          <target state="translated">&lt;a href=&quot;qpainter#drawPolygon&quot;&gt;drawPolygon&lt;/a&gt; () 함수 와 달리 마지막 점은</target>
        </trans-unit>
        <trans-unit id="8365323b741f740afcec7ec3e571a74aa8e1a916" translate="yes" xml:space="preserve">
          <source>Note that unlike the C library function of the same name, this function</source>
          <target state="translated">같은 이름의 C 라이브러리 함수와 달리이 함수는</target>
        </trans-unit>
        <trans-unit id="d0f65679007ce3c167a47bc9f313f8f0ac1af8cb" translate="yes" xml:space="preserve">
          <source>Note that unpolish() will only be called if the widget is destroyed. This can cause problems in some cases, e.g, if you remove a widget from the UI, cache it, and then reinsert it after the style has changed; some of Qt's classes cache their widgets.</source>
          <target state="translated">unpolish ()는 위젯이 파괴 된 경우에만 호출됩니다. 예를 들어, UI에서 위젯을 제거하고 캐시 한 다음 스타일이 변경된 후 다시 삽입하는 경우와 같은 경우에 문제가 발생할 수 있습니다. Qt 클래스 중 일부는 위젯을 캐시합니다.</target>
        </trans-unit>
        <trans-unit id="a39415cc0d7d703356c91bc423d6faa2cd83b2b7" translate="yes" xml:space="preserve">
          <source>Note that use of &lt;a href=&quot;qurl#ComponentFormattingOption-enum&quot;&gt;QUrl::FullyDecoded&lt;/a&gt; in queries is discouraged, as queries often contain data that is supposed to remain percent-encoded, including the use of the &quot;%2B&quot; sequence to represent a plus character ('+').</source>
          <target state="translated">쿼리 에는 &lt;a href=&quot;qurl#ComponentFormattingOption-enum&quot;&gt;QUrl :: FullyDecoded&lt;/a&gt; 를 사용 하지 않는 것이 좋습니다. 쿼리에는 더하기 문자 ( '+')를 나타내는 &quot;% 2B&quot;시퀀스 사용을 포함하여 퍼센트 인코딩 된 데이터가 포함되어 있기 때문에 권장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="957750a59d8232daec29f91deeaa41b30a46e219" translate="yes" xml:space="preserve">
          <source>Note that using &lt;a href=&quot;qxmlformatter&quot;&gt;QXmlFormatter&lt;/a&gt; instead of &lt;a href=&quot;qxmlserializer&quot;&gt;QXmlSerializer&lt;/a&gt; will increase computational overhead and document storage size due to the insertion of whitespace.</source>
          <target state="translated">사용하여 참고 &lt;a href=&quot;qxmlformatter&quot;&gt;QXmlFormatter를&lt;/a&gt; 대신 &lt;a href=&quot;qxmlserializer&quot;&gt;QXmlSerializer하기&lt;/a&gt; 때문에 공백의 삽입을 계산 오버 헤드 및 문서 저장 크기를 증가시킬 것이다.</target>
        </trans-unit>
        <trans-unit id="115c0d9b0a66a80945ac8e90be9d8a865657eee9" translate="yes" xml:space="preserve">
          <source>Note that using an existing Item property name such as &quot;opacity&quot; as an attribute is allowed. This is because path attributes add a new &lt;a href=&quot;qtqml-syntax-objectattributes#attached-properties-and-attached-signal-handlers&quot;&gt;Attached Property&lt;/a&gt; which in no way clashes with existing properties.</source>
          <target state="translated">&quot;opacity&quot;와 같은 기존 항목 속성 이름을 속성으로 사용할 수 있습니다. 이는 경로 속성 이 기존 속성과 충돌하지 않는 새로운 &lt;a href=&quot;qtqml-syntax-objectattributes#attached-properties-and-attached-signal-handlers&quot;&gt;연결된&lt;/a&gt; 속성을 추가하기 때문 입니다.</target>
        </trans-unit>
        <trans-unit id="3642a9a4a98a482741748b5a5508a30d85dd4e4b" translate="yes" xml:space="preserve">
          <source>Note that using non-const operators and functions can cause &lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt; to do a deep copy of the data. This is due to &lt;a href=&quot;implicit-sharing#&quot;&gt;implicit sharing&lt;/a&gt;.</source>
          <target state="translated">Const가 아닌 연산자와 함수를 사용하면 &lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt; 가 데이터의 딥 카피를 수행 할 수 있습니다 . 이것은 &lt;a href=&quot;implicit-sharing#&quot;&gt;암시 적 공유 때문&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="34a1539ee62953e068b2de8659992eee2bb755ab" translate="yes" xml:space="preserve">
          <source>Note that using non-const operators can cause &lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt; to do a deep copy.</source>
          <target state="translated">&lt;a href=&quot;qvector&quot;&gt;상수&lt;/a&gt; 가 아닌 연산자를 사용하면 QVector 가 딥 카피를 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dd8ff4eaa3f1d06e8a53ffe91b0809009f14ba60" translate="yes" xml:space="preserve">
          <source>Note that value() can only access properties declared with &lt;a href=&quot;qobject#Q_PROPERTY&quot;&gt;Q_PROPERTY&lt;/a&gt;() in sub-classes of &lt;a href=&quot;qsensorreading&quot;&gt;QSensorReading&lt;/a&gt;.</source>
          <target state="translated">value ()는 &lt;a href=&quot;qsensorreading&quot;&gt;QSensorReading의&lt;/a&gt; 하위 클래스에서 &lt;a href=&quot;qobject#Q_PROPERTY&quot;&gt;Q_PROPERTY&lt;/a&gt; ()로 선언 된 속성에만 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3d5ca3da1e07caa2add696f40b3a2b99210bcc2a" translate="yes" xml:space="preserve">
          <source>Note that values in both CBOR Maps and Arrays are converted recursively using this function too and placed in &lt;a href=&quot;qvariant#QVariantMap-typedef&quot;&gt;QVariantMap&lt;/a&gt; and &lt;a href=&quot;qvariant#QVariantList-typedef&quot;&gt;QVariantList&lt;/a&gt; instead. You will not find &lt;a href=&quot;qcbormap&quot;&gt;QCborMap&lt;/a&gt; and &lt;a href=&quot;qcborarray&quot;&gt;QCborArray&lt;/a&gt; stored inside the QVariants.</source>
          <target state="translated">CBOR 맵 및 배열의 ​​값은이 함수를 사용하여 재귀 적으로 변환되어 대신 &lt;a href=&quot;qvariant#QVariantMap-typedef&quot;&gt;QVariantMap&lt;/a&gt; 및 &lt;a href=&quot;qvariant#QVariantList-typedef&quot;&gt;QVariantList에&lt;/a&gt; 배치 됩니다. &lt;a href=&quot;qcborarray&quot;&gt;QVariants&lt;/a&gt; 내에 저장된 &lt;a href=&quot;qcbormap&quot;&gt;QCborMap&lt;/a&gt; 및 QCborArray를 찾을 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="8f305e5f0c3ceca628244e525c2481ed84b83f74" translate="yes" xml:space="preserve">
          <source>Note that visibility does not affect how &lt;a href=&quot;qml-qtlocation-place&quot;&gt;Place&lt;/a&gt;s associated with the category are displayed in the user-interface of an application on the device. Instead, it defines the sharing semantics of the category.</source>
          <target state="translated">가시성은 카테고리와 관련된 &lt;a href=&quot;qml-qtlocation-place&quot;&gt;장소&lt;/a&gt; 가 기기에서 애플리케이션의 사용자 인터페이스에 표시되는 방식에 영향을주지 않습니다 . 대신 카테고리의 공유 의미를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="02c4844daef034dbcb895efa590ee5a4de491926" translate="yes" xml:space="preserve">
          <source>Note that visibility does not affect how the place is displayed in the user-interface of an application on the device. Instead, it defines the sharing semantics of the place.</source>
          <target state="translated">가시성은 기기에서 애플리케이션의 사용자 인터페이스에 장소가 표시되는 방식에 영향을주지 않습니다. 대신 장소의 공유 의미를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="fe235d870772411b7af7a0db93f392c89305d40f" translate="yes" xml:space="preserve">
          <source>Note that we attempt to convert each node to a text node and use &lt;a href=&quot;qdomelement#text&quot;&gt;text&lt;/a&gt;() rather than using &lt;a href=&quot;qdomnode#firstChild&quot;&gt;firstChild&lt;/a&gt;().&lt;a href=&quot;qdomnode#toText&quot;&gt;toText&lt;/a&gt;().data() or n.&lt;a href=&quot;qdomnode#toText&quot;&gt;toText&lt;/a&gt;().data() directly on the node, because the node may not be a text element.</source>
          <target state="translated">각 노드를 텍스트 노드로 변환하고 &lt;a href=&quot;qdomnode#firstChild&quot;&gt;firstChild&lt;/a&gt; ()를 사용하는 대신 &lt;a href=&quot;qdomelement#text&quot;&gt;text&lt;/a&gt; ()를 사용하려고합니다 . &lt;a href=&quot;qdomnode#toText&quot;&gt;toText&lt;/a&gt; () .data () 또는 n. 노드가 텍스트 요소가 아니기 때문에 노드에서 직접 &lt;a href=&quot;qdomnode#toText&quot;&gt;toText&lt;/a&gt; () .data ().</target>
        </trans-unit>
        <trans-unit id="9cd8f33d3f80c657867e7d1b0a887a59ca4b5a5f" translate="yes" xml:space="preserve">
          <source>Note that we checked for individual drop actions in the above code. As mentioned above in the section on &lt;a href=&quot;#overriding-proposed-actions&quot;&gt;Overriding Proposed Actions&lt;/a&gt;, it is sometimes necessary to override the proposed drop action and choose a different one from the selection of possible drop actions. To do this, you need to check for the presence of each action in the value supplied by the event's &lt;a href=&quot;qdropevent#possibleActions&quot;&gt;possibleActions()&lt;/a&gt;, set the drop action with &lt;a href=&quot;qdropevent#setDropAction&quot;&gt;setDropAction()&lt;/a&gt;, and call &lt;a href=&quot;qevent#accept&quot;&gt;accept()&lt;/a&gt;.</source>
          <target state="translated">위 코드에서 개별 드롭 동작을 확인했습니다. 위에서 &lt;a href=&quot;#overriding-proposed-actions&quot;&gt;제안 된 조치 재정&lt;/a&gt; 의 섹션에서 언급했듯이 제안 된 놓기 조치를 대체하고 가능한 놓기 조치 선택에서 다른 조치를 선택해야하는 경우가 있습니다. 이렇게하려면 이벤트의 &lt;a href=&quot;qdropevent#possibleActions&quot;&gt;possibleActions ()&lt;/a&gt; 에서 제공 한 값에 각 조치가 있는지 확인 하고 &lt;a href=&quot;qdropevent#setDropAction&quot;&gt;setDropAction ()으로&lt;/a&gt; 삭제 조치를 설정 한 후 &lt;a href=&quot;qevent#accept&quot;&gt;accept ()를&lt;/a&gt; 호출해야 합니다.</target>
        </trans-unit>
        <trans-unit id="938bf67203630ae1dba7c7d94f5637cc19b47cce" translate="yes" xml:space="preserve">
          <source>Note that we do not have to know how the delegate performs the actual editing process. We only have to provide a way for the delegate to set the data in the model. This is achieved through the &lt;a href=&quot;qabstractitemmodel#setData&quot;&gt;setData()&lt;/a&gt; function:</source>
          <target state="translated">대리인이 실제 편집 프로세스를 수행하는 방법을 알 필요는 없습니다. 델리게이트가 모델에서 데이터를 설정할 수있는 방법 만 제공하면됩니다. 이는 &lt;a href=&quot;qabstractitemmodel#setData&quot;&gt;setData ()&lt;/a&gt; 함수를 통해 달성됩니다 .</target>
        </trans-unit>
        <trans-unit id="b0c679c468039714e141f0cb0af328becd2d2858" translate="yes" xml:space="preserve">
          <source>Note that we do not need to keep a pointer to the editor widget because the view takes responsibility for destroying it when it is no longer needed.</source>
          <target state="translated">뷰가 더 이상 필요하지 않을 때 뷰를 삭제해야하기 때문에 편집기 위젯에 대한 포인터를 유지할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="1752ad60f1835051f69fc65351509b850437c82e" translate="yes" xml:space="preserve">
          <source>Note that we do not use the &lt;code&gt;Link&lt;/code&gt; and &lt;code&gt;LinkVisited&lt;/code&gt; roles when rendering rich text in Qt, and that we recommend that you use CSS and the &lt;a href=&quot;qtextdocument#defaultStyleSheet-prop&quot;&gt;QTextDocument::setDefaultStyleSheet&lt;/a&gt;() function to alter the appearance of links. For example:</source>
          <target state="translated">Qt에서 리치 텍스트를 렌더링 할 때는 &lt;code&gt;Link&lt;/code&gt; 및 &lt;code&gt;LinkVisited&lt;/code&gt; 역할을 사용하지 않으며 CSS 및 &lt;a href=&quot;qtextdocument#defaultStyleSheet-prop&quot;&gt;QTextDocument :: setDefaultStyleSheet&lt;/a&gt; () 함수를 사용하여 링크 모양을 변경하는 것이 좋습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a7a1f27206f045bb46a609c6b28e22496947e598" translate="yes" xml:space="preserve">
          <source>Note that we:</source>
          <target state="translated">우리는 :</target>
        </trans-unit>
        <trans-unit id="50f87f44def10b4e2e5b964350838716998c1128" translate="yes" xml:space="preserve">
          <source>Note that when a file imports a directory over a network, it can only access QML and JavaScript files specified in the &lt;code&gt;qmldir&lt;/code&gt; file located in the directory.</source>
          <target state="translated">파일이 네트워크를 통해 디렉토리를 가져올 때 디렉토리에있는 &lt;code&gt;qmldir&lt;/code&gt; 파일에 지정된 QML 및 JavaScript 파일에만 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bcfccdbac5ec39850fee2a4ab6ecc24c37c2891e" translate="yes" xml:space="preserve">
          <source>Note that when creating content dynamically the set of available properties cannot be changed once set. Whatever properties are first added to the model are the only permitted properties in the model.</source>
          <target state="translated">컨텐츠를 동적으로 작성할 때 사용 가능한 특성 세트를 설정 한 후에는 변경할 수 없습니다. 모델에 처음 추가 된 속성은 모델에서 유일하게 허용되는 속성입니다.</target>
        </trans-unit>
        <trans-unit id="efb6a03594b3761d0198df788001678aa64d4c3e" translate="yes" xml:space="preserve">
          <source>Note that when creating custom text editing widgets, the &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt::WA_InputMethodEnabled&lt;/a&gt; window attribute must be set explicitly (using the &lt;a href=&quot;qwidget#setAttribute&quot;&gt;QWidget::setAttribute&lt;/a&gt;() function) in order to receive input method events.</source>
          <target state="translated">사용자 정의 텍스트 편집 위젯을 작성할 때 입력 메소드 이벤트를 수신 하려면 &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt :: WA_InputMethodEnabled&lt;/a&gt; 창 속성을 명시 적으로 설정해야합니다 ( &lt;a href=&quot;qwidget#setAttribute&quot;&gt;QWidget :: setAttribute&lt;/a&gt; () 함수 사용).</target>
        </trans-unit>
        <trans-unit id="b80870412ce74cb0108a3d9bcdb170ed0ee54a03" translate="yes" xml:space="preserve">
          <source>Note that when creating custom text editing widgets, the &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt::WA_InputMethodEnabled&lt;/a&gt; window attribute must be set explicitly (using the &lt;a href=&quot;qwidget#setAttribute&quot;&gt;setAttribute&lt;/a&gt;() function) in order to receive input method events.</source>
          <target state="translated">사용자 정의 텍스트 편집 위젯을 작성할 때 입력 메소드 이벤트를 수신 하려면 &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt :: WA_InputMethodEnabled&lt;/a&gt; 창 속성을 명시 적으로 설정해야합니다 ( &lt;a href=&quot;qwidget#setAttribute&quot;&gt;setAttribute&lt;/a&gt; () 함수 사용).</target>
        </trans-unit>
        <trans-unit id="0a012ae9f54ba43200ea3d2dc9fdb20107ac8ea5" translate="yes" xml:space="preserve">
          <source>Note that when the progress is 1.0, the XML data has been downloaded, but it is yet to be loaded into the model at this point. Use the status property to find out when the XML data has been read and loaded into the model.</source>
          <target state="translated">진행률이 1.0 인 경우 XML 데이터가 다운로드되었지만이 시점에서 아직 모델로로드되지 않습니다. XML 데이터를 읽고 모델로로드 한시기를 확인하려면 status 특성을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="5b514a2ff1b65477219fe802b2f4a1ed7678a78a" translate="yes" xml:space="preserve">
          <source>Note that when using QML without a &lt;a href=&quot;qguiapplication&quot;&gt;QGuiApplication&lt;/a&gt;, the following properties will be undefined:</source>
          <target state="translated">&lt;a href=&quot;qguiapplication&quot;&gt;QGuiApplication&lt;/a&gt; 없이 QML을 사용하는 경우 다음 특성이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="66b0f2f7efd145a65a8a45ee76189f9b7a82d36e" translate="yes" xml:space="preserve">
          <source>Note that when using QtConcurrent::filteredReduced(), you can mix the use of normal and member functions freely:</source>
          <target state="translated">QtConcurrent :: filteredReduced ()를 사용할 때 일반 함수와 멤버 함수를 자유롭게 혼합하여 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b10d2718938bb514e9f3bde88de9b15476b9d573" translate="yes" xml:space="preserve">
          <source>Note that when using QtConcurrent::mappedReduced(), you can mix the use of normal and member functions freely:</source>
          <target state="translated">QtConcurrent :: mappedReduced ()를 사용할 때 일반 함수와 멤버 함수를 자유롭게 혼합하여 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a42f976a93f69eec1a6d384d3d86cf1f20c685ac" translate="yes" xml:space="preserve">
          <source>Note that when using a &lt;a href=&quot;qtextstream&quot;&gt;QTextStream&lt;/a&gt; on a &lt;a href=&quot;qfile&quot;&gt;QFile&lt;/a&gt;, calling reset() on the &lt;a href=&quot;qfile&quot;&gt;QFile&lt;/a&gt; will not have the expected result because &lt;a href=&quot;qtextstream&quot;&gt;QTextStream&lt;/a&gt; buffers the file. Use the &lt;a href=&quot;qtextstream#seek&quot;&gt;QTextStream::seek&lt;/a&gt;() function instead.</source>
          <target state="translated">주의점 사용하는 경우 그 &lt;a href=&quot;qtextstream&quot;&gt;QTextStream&lt;/a&gt; A의 &lt;a href=&quot;qfile&quot;&gt;Qfile을을&lt;/a&gt; 온 리셋 ()를 호출, &lt;a href=&quot;qfile&quot;&gt;Qfile을을&lt;/a&gt; 하기 때문에 예상 된 결과가되지 않습니다 &lt;a href=&quot;qtextstream&quot;&gt;QTextStream이&lt;/a&gt; 파일을 버퍼링. 사용 &lt;a href=&quot;qtextstream#seek&quot;&gt;QTextStream을 :: 추구하는&lt;/a&gt; 대신에 () 함수를.</target>
        </trans-unit>
        <trans-unit id="b690dd31cc293beecd2ecd7b4f63bd1fa8ba2a22" translate="yes" xml:space="preserve">
          <source>Note that when writing to &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;, &lt;a href=&quot;qxmlstreamwriter&quot;&gt;QXmlStreamWriter&lt;/a&gt; ignores the codec set with &lt;a href=&quot;qxmlstreamwriter#setCodec&quot;&gt;setCodec&lt;/a&gt;(). See that function for more information.</source>
          <target state="translated">기록 할 때 유의 &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; , &lt;a href=&quot;qxmlstreamwriter&quot;&gt;QXmlStreamWriter을&lt;/a&gt; 가진 코덱 세트 무시 &lt;a href=&quot;qxmlstreamwriter#setCodec&quot;&gt;setCodec을&lt;/a&gt; (). 자세한 내용은 해당 기능을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4e6ed38c3b413bf8d69243d4fcf0054406de13a5" translate="yes" xml:space="preserve">
          <source>Note that when x is 90 or -90, values for z and y achieve rotation around the same axis (due to the order of operations). In this case the y rotation will be 0.</source>
          <target state="translated">x가 90 또는 -90 인 경우 z 및 y 값은 작업 순서로 인해 동일한 축을 중심으로 회전합니다. 이 경우 y 회전은 0이됩니다.</target>
        </trans-unit>
        <trans-unit id="a6739ddc60d123db0442b580ca807db2cf338593" translate="yes" xml:space="preserve">
          <source>Note that whether or not the text is drawn is dependent on the style. Currently CleanLooks and Plastique draw the text. Mac, Windows and WindowsVista style do not.</source>
          <target state="translated">텍스트가 그려 지는지 여부는 스타일에 따라 다릅니다. 현재 CleanLooks 및 Plastique는 텍스트를 그립니다. Mac, Windows 및 WindowsVista 스타일은 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b79e7a8373c921825bae13c939fc9e0872681d48" translate="yes" xml:space="preserve">
          <source>Note that while</source>
          <target state="translated">그 동안</target>
        </trans-unit>
        <trans-unit id="524116b44c3e19c62b52f5ded45ff25c9ead2857" translate="yes" xml:space="preserve">
          <source>Note that while the &lt;a href=&quot;qpainter#brushOrigin&quot;&gt;brushOrigin&lt;/a&gt;() was necessary to adopt the parent's background for a widget in Qt 3, this is no longer the case since the Qt 4 painter doesn't paint the background unless you explicitly tell it to do so by setting the widget's &lt;a href=&quot;qwidget#autoFillBackground-prop&quot;&gt;autoFillBackground&lt;/a&gt; property to true.</source>
          <target state="translated">그동안 있습니다 &lt;a href=&quot;qpainter#brushOrigin&quot;&gt;brushOrigin은&lt;/a&gt; () Qt는 3 위젯에 대한 부모의 배경을 채택하는 것이 필요하다고 명시 적으로 위젯의 설정에 의해 그렇게하도록 지시하지 않는 한 Qt는 4 화가 배경을 페인트하지 않기 때문에,이 경우는 더 이상 &lt;a href=&quot;qwidget#autoFillBackground-prop&quot;&gt;autoFillBackground&lt;/a&gt; 속성을 true로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="05556e8158816144304ae51a354d8cfb46223cd1" translate="yes" xml:space="preserve">
          <source>Note that while the Qt QML module provides the language and infrastructure for QML applications, the &lt;a href=&quot;qtquick-index&quot;&gt;Qt Quick&lt;/a&gt; module provides many visual components, model-view support, an animation framework, and much more for building user interfaces.</source>
          <target state="translated">Qt QML 모듈은 QML 애플리케이션을위한 언어 및 인프라를 제공 하지만 &lt;a href=&quot;qtquick-index&quot;&gt;Qt Quick&lt;/a&gt; 모듈은 많은 시각적 구성 요소, 모델 뷰 지원, 애니메이션 프레임 워크 및 사용자 인터페이스 구축을위한 훨씬 더 많은 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="59d12c181dfc8fb72f3a0688f220da7c40bdacb0" translate="yes" xml:space="preserve">
          <source>Note that while you can set the size increment for all widgets, it only affects windows.</source>
          <target state="translated">모든 위젯의 크기 증분을 설정할 수는 있지만 창에만 영향을 미칩니다.</target>
        </trans-unit>
        <trans-unit id="686ae5547e7d5a8612b8b6e6def5872486b8e387" translate="yes" xml:space="preserve">
          <source>Note that widgets with the &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt::WA_PaintOnScreen&lt;/a&gt; widget attribute set and widgets that wrap an external application or controller are not supported. Examples are QGLWidget and QAxWidget.</source>
          <target state="translated">와 위젯 있습니다 &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt는 :: WA_PaintOnScreen&lt;/a&gt; 위젯 속성 세트 및 위젯 랩 외부 응용 프로그램 또는 컨트롤러가 지원되지 않습니다. 예는 QGLWidget 및 QAxWidget입니다.</target>
        </trans-unit>
        <trans-unit id="cd2f718434b9d4b444846b49663bc72dcf7d9eb8" translate="yes" xml:space="preserve">
          <source>Note that widgets with the &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt::WA_PaintOnScreen&lt;/a&gt; widget attribute set and widgets that wrap an external application or controller cannot be embedded. Examples are QGLWidget and QAxWidget.</source>
          <target state="translated">위젯으로 유의 &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt는 :: WA_PaintOnScreen&lt;/a&gt; 위젯 속성 세트 및 위젯 랩 외부 애플리케이션 또는 컨트롤러가 내장 될 수있다. 예는 QGLWidget 및 QAxWidget입니다.</target>
        </trans-unit>
        <trans-unit id="744073f480534943de4561e8012efb0f9d3615fa" translate="yes" xml:space="preserve">
          <source>Note that you also need to ensure that drops are enabled in the view; see &lt;a href=&quot;qwidget#acceptDrops-prop&quot;&gt;QWidget::acceptDrops&lt;/a&gt;(); and that the model supports the desired drop actions; see &lt;a href=&quot;qabstractitemmodel#supportedDropActions&quot;&gt;QAbstractItemModel::supportedDropActions&lt;/a&gt;().</source>
          <target state="translated">뷰에서 드랍이 활성화되어 있는지 확인해야합니다. &lt;a href=&quot;qwidget#acceptDrops-prop&quot;&gt;QWidget :: acceptDrops&lt;/a&gt; ();를 참조하십시오 . 모델이 원하는 드롭 동작을 지원한다는 점; &lt;a href=&quot;qabstractitemmodel#supportedDropActions&quot;&gt;QAbstractItemModel :: supportedDropActions&lt;/a&gt; ()를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9a8e3a2baebe430e597e9a928e73f2a49a3ad58b" translate="yes" xml:space="preserve">
          <source>Note that you also need to ensure that item dragging is enabled in the view; see &lt;a href=&quot;qabstractitemview#dragEnabled-prop&quot;&gt;QAbstractItemView::dragEnabled&lt;/a&gt;.</source>
          <target state="translated">뷰에서 항목 드래그가 활성화되어 있는지 확인해야합니다. &lt;a href=&quot;qabstractitemview#dragEnabled-prop&quot;&gt;QAbstractItemView :: dragEnabled를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1868860b6a0dd3a36076dcb6105877e7d3365535" translate="yes" xml:space="preserve">
          <source>Note that you can also pass a &lt;a href=&quot;qpixmap&quot;&gt;QPixmap&lt;/a&gt; object as an icon (thanks to the implicit type conversion provided by C++).</source>
          <target state="translated">&lt;a href=&quot;qpixmap&quot;&gt;QPixmap&lt;/a&gt; 객체를 아이콘으로 전달할 수도 있습니다 (C ++에서 제공하는 암시 적 유형 변환 덕분에).</target>
        </trans-unit>
        <trans-unit id="67a8a734eb5d7dd4a311eb6c65946fb1aaf207a9" translate="yes" xml:space="preserve">
          <source>Note that you can also use the &lt;a href=&quot;https://doc.qt.io/qt-5.13/animation-overview.html&quot;&gt;Animation Framework&lt;/a&gt; for animations.</source>
          <target state="translated">&lt;a href=&quot;https://doc.qt.io/qt-5.13/animation-overview.html&quot;&gt;애니메이션에 애니메이션 프레임 워크&lt;/a&gt; 를 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fde6c07febf4d73b8d6791ee56e2a30d441806a7" translate="yes" xml:space="preserve">
          <source>Note that you can examine how Qt's widgets implement their accessibility. One major problem with the MSAA standard is that interfaces are often implemented in an inconsistent way. This makes life difficult for clients and often leads to guesswork on object functionality.</source>
          <target state="translated">Qt의 위젯이 접근성을 구현하는 방법을 확인할 수 있습니다. MSAA 표준의 한 가지 주요 문제점은 인터페이스가 종종 일관되지 않은 방식으로 구현된다는 것입니다. 이로 인해 클라이언트의 삶이 어려워지고 종종 개체 기능에 대한 추측이 이루어집니다.</target>
        </trans-unit>
        <trans-unit id="0c19b3775df115ae29c8fe7b3cb800922193fde6" translate="yes" xml:space="preserve">
          <source>Note that you can set the expected certificate in the SSL error: If, for instance, you want to connect to a server that uses a self-signed certificate, consider the following snippet:</source>
          <target state="translated">SSL 오류에서 예상 인증서를 설정할 수 있습니다. 예를 들어 자체 서명 된 인증서를 사용하는 서버에 연결하려는 경우 다음 스 니펫을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="608151c1dbcb5c3cb8f8971aa38868d6b21f8fb7" translate="yes" xml:space="preserve">
          <source>Note that you cannot unregister objects that were not registered with &lt;a href=&quot;qdbusconnection#registerObject&quot;&gt;registerObject&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qdbusconnection#registerObject&quot;&gt;registerObject&lt;/a&gt; () 로 등록 되지 않은 객체는 등록을 취소 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="e0acf29faa59076bd77bbf7b26d0fc14b5bf2dfb" translate="yes" xml:space="preserve">
          <source>Note that you cannot use the setters on the returned object, you must either call the &lt;a href=&quot;qprinter&quot;&gt;QPrinter&lt;/a&gt; methods or &lt;a href=&quot;qprinter#setPageLayout&quot;&gt;setPageLayout&lt;/a&gt;().</source>
          <target state="translated">리턴 된 오브젝트에서 setter를 사용할 수 없으므로 &lt;a href=&quot;qprinter&quot;&gt;QPrinter&lt;/a&gt; 메소드 또는 &lt;a href=&quot;qprinter#setPageLayout&quot;&gt;setPageLayout&lt;/a&gt; ()을 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="b733ecbdc9106805a83582d25b1a2b980c5f648d" translate="yes" xml:space="preserve">
          <source>Note that you cannot use the setters on the returned object, you must either call the individual &lt;a href=&quot;qpagedpaintdevice&quot;&gt;QPagedPaintDevice&lt;/a&gt; setters or use &lt;a href=&quot;qpagedpaintdevice#setPageLayout&quot;&gt;setPageLayout&lt;/a&gt;().</source>
          <target state="translated">반환 된 객체에서 setter를 사용할 수 없으므로 개별 &lt;a href=&quot;qpagedpaintdevice&quot;&gt;QPagedPaintDevice&lt;/a&gt; setter를 호출 하거나 &lt;a href=&quot;qpagedpaintdevice#setPageLayout&quot;&gt;setPageLayout&lt;/a&gt; ()을 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="e941841daa9c42db73774f1c921addfd6cb42cae" translate="yes" xml:space="preserve">
          <source>Note that you cannot use the setters on the returned object, you must either call the individual &lt;a href=&quot;qpdfwriter&quot;&gt;QPdfWriter&lt;/a&gt; methods or use &lt;a href=&quot;qpdfwriter#setPageLayout&quot;&gt;setPageLayout&lt;/a&gt;().</source>
          <target state="translated">리턴 된 오브젝트에서 setter를 사용할 수 없으므로 개별 &lt;a href=&quot;qpdfwriter&quot;&gt;QPdfWriter&lt;/a&gt; 메소드를 호출 하거나 &lt;a href=&quot;qpdfwriter#setPageLayout&quot;&gt;setPageLayout&lt;/a&gt; ()을 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="ef0311d0dc9ee2eb18546a9bfd35ec980dbef9ca" translate="yes" xml:space="preserve">
          <source>Note that you have to pass the address of the variable you want stored.</source>
          <target state="translated">저장하려는 변수의 주소를 전달해야합니다.</target>
        </trans-unit>
        <trans-unit id="096ab7558c079e48d6b79582a3d873cac604ffce" translate="yes" xml:space="preserve">
          <source>Note that you must add the layout of the</source>
          <target state="translated">레이아웃을 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="24ac31da6f2bf93d9d665c284b59993ea746f297" translate="yes" xml:space="preserve">
          <source>Note that you must re-import the project if its setup changes, for example, when adding or removing source files.</source>
          <target state="translated">소스 파일을 추가하거나 제거 할 때와 같이 설정이 변경되면 프로젝트를 다시 가져와야합니다.</target>
        </trans-unit>
        <trans-unit id="5320d14e107b35f930d1f7860ed2217ab12c32b6" translate="yes" xml:space="preserve">
          <source>Note that you should never manually delete objects that were dynamically created by convenience QML object factories (such as &lt;a href=&quot;qml-qtquick-loader&quot;&gt;Loader&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-repeater&quot;&gt;Repeater&lt;/a&gt;). Also, you should avoid deleting objects that you did not dynamically create yourself.</source>
          <target state="translated">편의 QML 객체 팩토리 (예 : &lt;a href=&quot;qml-qtquick-loader&quot;&gt;Loader&lt;/a&gt; 및 &lt;a href=&quot;qml-qtquick-repeater&quot;&gt;Repeater&lt;/a&gt; ) 로 동적으로 작성된 객체를 수동으로 삭제해서는 안됩니다 . 또한 동적으로 자신을 만들지 않은 개체는 삭제하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="68d82da44bb7159d67fa9fb121bdcf8f1425ccb1" translate="yes" xml:space="preserve">
          <source>Note that you should not update the source model through the proxy model when dynamicSortFilter is true. For instance, if you set the proxy model on a &lt;a href=&quot;qcombobox&quot;&gt;QComboBox&lt;/a&gt;, then using functions that update the model, e.g., &lt;a href=&quot;qcombobox#addItem&quot;&gt;addItem()&lt;/a&gt;, will not work as expected. An alternative is to set dynamicSortFilter to false and call &lt;a href=&quot;qsortfilterproxymodel#sort&quot;&gt;sort()&lt;/a&gt; after adding items to the &lt;a href=&quot;qcombobox&quot;&gt;QComboBox&lt;/a&gt;.</source>
          <target state="translated">dynamicSortFilter가 true 인 경우 프록시 모델을 통해 소스 모델을 업데이트하지 않아야합니다. 예를 들어, &lt;a href=&quot;qcombobox&quot;&gt;QComboBox&lt;/a&gt; 에서 프록시 모델을 설정 한 경우 모델 을 업데이트하는 함수 &lt;a href=&quot;qcombobox#addItem&quot;&gt;(&lt;/a&gt; 예 : addItem ()) 를 사용하면 예상대로 작동하지 않습니다. 대안은 dynamicSortFilter를 false로 설정 하고 &lt;a href=&quot;qcombobox&quot;&gt;QComboBox에&lt;/a&gt; 항목을 추가 한 후 &lt;a href=&quot;qsortfilterproxymodel#sort&quot;&gt;sort ()를&lt;/a&gt; 호출 하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="cc1a14cb5833ab8a0c5e76cf2c90d0c94fad6dd0" translate="yes" xml:space="preserve">
          <source>Note that you will need to down-cast to the appropriate type.</source>
          <target state="translated">적절한 유형으로 다운 캐스트해야합니다.</target>
        </trans-unit>
        <trans-unit id="030dcfeb0caa9f3c7e36c9af8eb874b2533d5bda" translate="yes" xml:space="preserve">
          <source>Note that, although the scene supports a virtually unlimited size, the range of the scroll bars will never exceed the range of an integer (INT_MIN, INT_MAX). When the scene is larger than the scroll bars' values, you can choose to use &lt;a href=&quot;qgraphicsview#translate&quot;&gt;translate&lt;/a&gt;() to navigate the scene instead.</source>
          <target state="translated">장면이 사실상 무제한 크기를 지원하지만 스크롤 막대 범위는 정수 범위 (INT_MIN, INT_MAX)를 초과하지 않습니다. 장면이 스크롤 막대의 값보다 큰 경우 &lt;a href=&quot;qgraphicsview#translate&quot;&gt;translate&lt;/a&gt; ()을 사용하여 대신 장면을 탐색 하도록 선택할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f50fcd290240aa9b514c46e4a8c058bc1cf469e7" translate="yes" xml:space="preserve">
          <source>Note that, by default, &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; renders the outline (using the currently set pen) when drawing shapes. Use &lt;a href=&quot;qt#PenStyle-enum&quot;&gt;&lt;code&gt;painter.setPen(Qt::NoPen)&lt;/code&gt;&lt;/a&gt; to disable this behavior.</source>
          <target state="translated">기본적으로 &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; 는 도형을 그릴 때 현재 설정된 펜을 사용하여 윤곽선을 렌더링합니다. 이 동작을 비활성화 하려면 &lt;a href=&quot;qt#PenStyle-enum&quot;&gt; &lt;code&gt;painter.setPen(Qt::NoPen)&lt;/code&gt; &lt;/a&gt; 을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="750fc056d65abdb2cc1cb1b4588b0e1be37d5ba1" translate="yes" xml:space="preserve">
          <source>Note that, due to the nature of weak references, the pointer that &lt;a href=&quot;qweakpointer&quot;&gt;QWeakPointer&lt;/a&gt; references can become &lt;code&gt;nullptr&lt;/code&gt; at any moment, so the value returned from this function can change from false to true from one call to the next.</source>
          <target state="translated">약한 참조의 특성으로 인해 &lt;a href=&quot;qweakpointer&quot;&gt;QWeakPointer가&lt;/a&gt; 참조 하는 포인터 는 언제든지 &lt;code&gt;nullptr&lt;/code&gt; 이 될 수 있으므로이 함수에서 리턴 된 값은 한 호출에서 다음 호출로 false에서 true로 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="91ed0bdf5be6988b871adffb428fe3eeb0cc1bff" translate="yes" xml:space="preserve">
          <source>Note that, due to the nature of weak references, the pointer that &lt;a href=&quot;qweakpointer&quot;&gt;QWeakPointer&lt;/a&gt; references can become &lt;code&gt;nullptr&lt;/code&gt; at any moment, so the value returned from this function can change from true to false from one call to the next.</source>
          <target state="translated">약한 참조의 특성으로 인해 &lt;a href=&quot;qweakpointer&quot;&gt;QWeakPointer가&lt;/a&gt; 참조 하는 포인터 는 언제든지 &lt;code&gt;nullptr&lt;/code&gt; 이 될 수 있으므로이 함수에서 반환 된 값은 한 호출에서 다음 호출로 true에서 false로 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8bf4fc278ab3e3874ae2dfc2664e4d61a182ba9" translate="yes" xml:space="preserve">
          <source>Note that, for letters, the case used in the specification string does not matter. In the above examples, the user does not need to hold down the &lt;b&gt;Shift&lt;/b&gt; key to activate a shortcut specified with &quot;Ctrl+P&quot;. However, for other keys, the use of &lt;b&gt;Shift&lt;/b&gt; as an unspecified extra modifier key can lead to confusion for users of an application whose keyboards have different layouts to those used by the developers. See the &lt;a href=&quot;qkeysequence#keyboard-layout-issues&quot;&gt;Keyboard Layout Issues&lt;/a&gt; section below for more details.</source>
          <target state="translated">문자의 경우 사양 문자열에 사용 된 대소 문자는 중요하지 않습니다. 위의 예에서 사용자는 &quot;Ctrl + P&quot;로 지정된 바로 가기를 활성화하기 위해 &lt;b&gt;Shift&lt;/b&gt; 키를 누르고있을 필요가 없습니다 . 그러나 다른 키의 경우 &lt;b&gt;Shift&lt;/b&gt; 를 지정되지 않은 추가 수정 자 키로 사용하면 키보드가 개발자가 사용하는 키보드와 레이아웃이 다른 응용 프로그램 사용자에게 혼란을 줄 수 있습니다. 자세한 내용은 아래 의 &lt;a href=&quot;qkeysequence#keyboard-layout-issues&quot;&gt;키보드 레이아웃 문제&lt;/a&gt; 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="dda4305e318d998bb0cb9512594383a9dabfa9f1" translate="yes" xml:space="preserve">
          <source>Note that, if the image data comes from a sequential device (e.g. a socket), &lt;a href=&quot;qmovie&quot;&gt;QMovie&lt;/a&gt; can only loop the movie if the &lt;a href=&quot;qmovie#cacheMode-prop&quot;&gt;cacheMode&lt;/a&gt; is set to &lt;a href=&quot;qmovie#CacheMode-enum&quot;&gt;QMovie::CacheAll&lt;/a&gt;.</source>
          <target state="translated">이미지 데이터가 순차적 장치 (예 : 소켓)에서 &lt;a href=&quot;qmovie&quot;&gt;온&lt;/a&gt; 경우 , QMode 는 &lt;a href=&quot;qmovie#cacheMode-prop&quot;&gt;cacheMode&lt;/a&gt; 가 &lt;a href=&quot;qmovie#CacheMode-enum&quot;&gt;QMovie :: CacheAll로&lt;/a&gt; 설정된 경우에만 동영상을 반복 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b7fcaee2ab0f7c4e92ab4a3633b3adaece1fe192" translate="yes" xml:space="preserve">
          <source>Note that, if the reply hasn't arrived, this function causes the calling thread to block until the reply is processed.</source>
          <target state="translated">응답이 도착하지 않은 경우이 함수는 응답이 처리 될 때까지 호출 스레드를 차단합니다.</target>
        </trans-unit>
        <trans-unit id="48dc5f66b4731049c45eef25e6e41c32a1a4ed47" translate="yes" xml:space="preserve">
          <source>Note that, if this &lt;a href=&quot;qfileinfo&quot;&gt;QFileInfo&lt;/a&gt; object is given a path ending in a slash, the name of the file is considered empty and this function will return the entire path.</source>
          <target state="translated">이 &lt;a href=&quot;qfileinfo&quot;&gt;QFileInfo&lt;/a&gt; 객체에 슬래시로 끝나는 경로가 제공되면 파일 이름이 비어있는 것으로 간주 되며이 함수는 전체 경로를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="148a9ce23ba6e02639587b746d0ae63ca972b6ed" translate="yes" xml:space="preserve">
          <source>Note that, if this &lt;a href=&quot;qfileinfo&quot;&gt;QFileInfo&lt;/a&gt; object is given a path ending in a slash, the name of the file is considered empty.</source>
          <target state="translated">이 &lt;a href=&quot;qfileinfo&quot;&gt;QFileInfo&lt;/a&gt; 객체에 슬래시로 끝나는 경로가 제공되면 파일 이름이 비어있는 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="1d5c53949d92ad91cebde6cbc0c4cbb932fceb7f" translate="yes" xml:space="preserve">
          <source>Note that, if this &lt;a href=&quot;qurl&quot;&gt;QUrl&lt;/a&gt; object is given a path ending in a slash, the name of the file is considered empty.</source>
          <target state="translated">이 &lt;a href=&quot;qurl&quot;&gt;QUrl&lt;/a&gt; 오브젝트에 슬래시로 끝나는 경로가 제공되면 파일 이름이 비어있는 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="419867ba7519e67753cb3c989cb4f6ecc96eb080" translate="yes" xml:space="preserve">
          <source>Note that, if you call &lt;a href=&quot;qabstractitemview#setModel&quot;&gt;setModel&lt;/a&gt;() after this function, the given</source>
          <target state="translated">이 함수 다음에 &lt;a href=&quot;qabstractitemview#setModel&quot;&gt;setModel&lt;/a&gt; () 을 호출하면</target>
        </trans-unit>
        <trans-unit id="80a2c96f97d545b9342d569152f9acfc06be8330" translate="yes" xml:space="preserve">
          <source>Note that, if you want to display these error messages to your application's users, they will be displayed in English unless they are explicitly translated.</source>
          <target state="translated">이러한 오류 메시지를 응용 프로그램 사용자에게 표시하려면 명시 적으로 번역하지 않는 한 영어로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="c3621a03746865a7079eee548581b97194a53490" translate="yes" xml:space="preserve">
          <source>Note that, if you want to show tooltips in an item view, the model/view architecture provides functionality to set an item's tool tip; e.g., the &lt;a href=&quot;qtablewidgetitem#setToolTip&quot;&gt;QTableWidgetItem::setToolTip&lt;/a&gt;() function. However, if you want to provide custom tool tips in an item view, you must intercept the help event in the &lt;a href=&quot;qabstractitemview#viewportEvent&quot;&gt;QAbstractItemView::viewportEvent&lt;/a&gt;() function and handle it yourself.</source>
          <target state="translated">항목보기에 도구 설명을 표시하려는 경우 모델 /보기 아키텍처는 항목의 도구 설명을 설정하는 기능을 제공합니다. 예를 들어, &lt;a href=&quot;qtablewidgetitem#setToolTip&quot;&gt;QTableWidgetItem :: setToolTip&lt;/a&gt; () 함수입니다. 그러나 항목보기에서 사용자 정의 도구 팁을 제공하려면 &lt;a href=&quot;qabstractitemview#viewportEvent&quot;&gt;QAbstractItemView :: viewportEvent&lt;/a&gt; () 함수 에서 도움말 이벤트를 가로 채서 직접 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="13ad2d3adfb6e183e38b07db0b442eb30a61260a" translate="yes" xml:space="preserve">
          <source>Note that, in all cases, the result of the parsing must be a valid hostname according to STD 3 rules, as modified by the Internationalized Resource Identifiers specification (RFC 3987). Invalid hostnames are not permitted and will cause &lt;a href=&quot;qurl#isValid&quot;&gt;isValid&lt;/a&gt;() to become false.</source>
          <target state="translated">모든 경우에 구문 분석 결과는 국제화 된 자원 식별자 스펙 (RFC 3987)에 의해 수정 된 STD 3 규칙에 따라 유효한 호스트 이름이어야합니다. 유효하지 않은 호스트 이름은 허용되지 않으며 &lt;a href=&quot;qurl#isValid&quot;&gt;isValid&lt;/a&gt; ()가 false가됩니다.</target>
        </trans-unit>
        <trans-unit id="39697513fb021693d9ac7b41e89bc3f7a4510298" translate="yes" xml:space="preserve">
          <source>Note that, in cases where there are other tables in the font that affect the shaping of the text, the returned glyph indexes will not correctly represent the rendering of the text. To get the correctly shaped text, you can use &lt;a href=&quot;qtextlayout&quot;&gt;QTextLayout&lt;/a&gt; to lay out and shape the text, then call QTextLayout::glyphs() to get the set of glyph index list and &lt;a href=&quot;qrawfont&quot;&gt;QRawFont&lt;/a&gt; pairs.</source>
          <target state="translated">글꼴에 텍스트 모양에 영향을주는 다른 테이블이있는 경우 반환되는 글리프 인덱스는 텍스트 렌더링을 올바르게 나타내지 않습니다. 올바른 모양의 텍스트를 얻으려면 &lt;a href=&quot;qtextlayout&quot;&gt;QTextLayout&lt;/a&gt; 을 사용 하여 텍스트를 배치하고 모양을 지정한 다음 QTextLayout :: glyphs ()를 호출하여 글리프 색인 목록 및 &lt;a href=&quot;qrawfont&quot;&gt;QRawFont&lt;/a&gt; 쌍 세트를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="f6833c9c5d548b81b4f1261878b766216e4610f5" translate="yes" xml:space="preserve">
          <source>Note that, since Column inherits directly from Item, any background color must be added to a parent Rectangle, if desired.</source>
          <target state="translated">Column은 Item에서 직접 상속되므로 원하는 경우 모든 배경색을 부모 Rectangle에 추가해야합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
