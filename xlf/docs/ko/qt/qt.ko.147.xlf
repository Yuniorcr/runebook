<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="qt">
    <body>
      <group id="qt">
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="53451c3064513a35eea5eca862e3f52dc56bdb7c" translate="yes" xml:space="preserve">
          <source>Introduction and Concepts</source>
          <target state="translated">소개 및 개념</target>
        </trans-unit>
        <trans-unit id="298f3dca7e4240b0e6eae2119d7cceeb98bf97d2" translate="yes" xml:space="preserve">
          <source>Introduction to DOM</source>
          <target state="translated">DOM 소개</target>
        </trans-unit>
        <trans-unit id="2e5cacd0c9d1de31c9825ed14af49f02412fd6ef" translate="yes" xml:space="preserve">
          <source>Introduction to Model/View Programming</source>
          <target state="translated">모델 / 뷰 프로그래밍 소개</target>
        </trans-unit>
        <trans-unit id="be99ee5e295af601e7d782415138de0e021ce432" translate="yes" xml:space="preserve">
          <source>Introduction to QDoc</source>
          <target state="translated">QDoc 소개</target>
        </trans-unit>
        <trans-unit id="4a60ef26b46f2d85b08e69bcd757269ec6b2bc4d" translate="yes" xml:space="preserve">
          <source>Introduction to QML Test Cases</source>
          <target state="translated">QML 테스트 사례 소개</target>
        </trans-unit>
        <trans-unit id="547b4f5f999568f26fbbf2f80a8b18760b672290" translate="yes" xml:space="preserve">
          <source>Introduction to SAX2</source>
          <target state="translated">SAX2 소개</target>
        </trans-unit>
        <trans-unit id="5b75c9e4f007cb4993ae4315fb85cb9ca6aed444" translate="yes" xml:space="preserve">
          <source>Introduction to view classes on the example of QStringView</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06a74c02894ec93718a988055ab27d78060281a8" translate="yes" xml:space="preserve">
          <source>Introductory Concepts</source>
          <target state="translated">입문 개념</target>
        </trans-unit>
        <trans-unit id="6f6d459efec086aaa242454a455bbb8fb4a9e034" translate="yes" xml:space="preserve">
          <source>Intuitive &lt;a href=&quot;https://doc.qt.io/qt-5.13/reference-overview.html#&quot;&gt;API&lt;/a&gt;s for &lt;a href=&quot;https://doc.qt.io/qt-5.13/classes.html#&quot;&gt;C++&lt;/a&gt; and JavaScript-like programming with &lt;a href=&quot;qmlapplications#&quot;&gt;Qt Quick&lt;/a&gt; for rapid UI creation.</source>
          <target state="translated">빠른 UI 생성을 위해 &lt;a href=&quot;qmlapplications#&quot;&gt;Qt Quick&lt;/a&gt; 을 사용 하는 &lt;a href=&quot;https://doc.qt.io/qt-5.13/classes.html#&quot;&gt;C ++&lt;/a&gt; 및 JavaScript 유사 프로그래밍을 위한 직관적 인 &lt;a href=&quot;https://doc.qt.io/qt-5.13/reference-overview.html#&quot;&gt;API&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="036d980b6694a16cc916188dbd9587d7a630ad5b" translate="yes" xml:space="preserve">
          <source>Intuitive &lt;a href=&quot;https://doc.qt.io/qt-5.15/reference-overview.html&quot;&gt;API&lt;/a&gt;s for &lt;a href=&quot;https://doc.qt.io/qt-5.15/classes.html&quot;&gt;C++&lt;/a&gt; and JavaScript-like programming with &lt;a href=&quot;qmlapplications&quot;&gt;Qt Quick&lt;/a&gt; for rapid UI creation.</source>
          <target state="translated">빠른 UI 생성을위한 &lt;a href=&quot;qmlapplications&quot;&gt;Qt Quick&lt;/a&gt; 을 사용한 &lt;a href=&quot;https://doc.qt.io/qt-5.15/classes.html&quot;&gt;C ++&lt;/a&gt; 및 JavaScript 유사 프로그래밍을 위한 직관적 인 &lt;a href=&quot;https://doc.qt.io/qt-5.15/reference-overview.html&quot;&gt;API&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3e3635183cd84547d8e81a7727792e1e3eab1c2a" translate="yes" xml:space="preserve">
          <source>Intuitive &lt;a href=&quot;https://doc.qt.io/qt-6.0/reference-overview.html&quot;&gt;API&lt;/a&gt;s for &lt;a href=&quot;https://doc.qt.io/qt-6.0/classes.html&quot;&gt;C++&lt;/a&gt; and JavaScript-like programming with &lt;a href=&quot;qmlapplications&quot;&gt;Qt Quick&lt;/a&gt; for rapid UI creation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf87d8947f7e385c66b754976ac41d4992f63494" translate="yes" xml:space="preserve">
          <source>Intuitively, the viewCenter is the location the camera is pointing at.</source>
          <target state="translated">직관적으로 viewCenter는 카메라가 가리키는 위치입니다.</target>
        </trans-unit>
        <trans-unit id="823ae32ca81959cfaa13f2adbec04e5033548aa0" translate="yes" xml:space="preserve">
          <source>Invalid CBOR stream</source>
          <target state="translated">잘못된 CBOR 스트림</target>
        </trans-unit>
        <trans-unit id="302199ba8b22f010b6e4004fc46be10750bbd995" translate="yes" xml:space="preserve">
          <source>Invalid content was provided for sharing.</source>
          <target state="translated">공유를 위해 잘못된 컨텐츠가 제공되었습니다.</target>
        </trans-unit>
        <trans-unit id="2fe3dee92c8d25f938abeebed888b2f83e79dcc8" translate="yes" xml:space="preserve">
          <source>Invalid data (certificate, key, cypher, etc.) was provided and its use resulted in an error in the SSL library.</source>
          <target state="translated">유효하지 않은 데이터 (인증서, 키, 사이퍼 등)가 제공되었으며 SSL 라이브러리에서 오류가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="ea0eeb53d4ab504a5c937902749a6bfaef3b2b1a" translate="yes" xml:space="preserve">
          <source>Invalid frame payload data</source>
          <target state="translated">유효하지 않은 프레임 페이로드 데이터</target>
        </trans-unit>
        <trans-unit id="8725da555ba6740f4cb81f6a0addf84fd854f4d8" translate="yes" xml:space="preserve">
          <source>Invalid maneuvers are used when there is no information that needs to be attached to the endpoint of a &lt;a href=&quot;qgeoroutesegment&quot;&gt;QGeoRouteSegment&lt;/a&gt; instance.</source>
          <target state="translated">&lt;a href=&quot;qgeoroutesegment&quot;&gt;QGeoRouteSegment&lt;/a&gt; 인스턴스 의 엔드 포인트에 첨부해야하는 정보가없는 경우 유효하지 않은 조작이 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="38b0d315a5253b12fb226a6a57814782bb1ca8d6" translate="yes" xml:space="preserve">
          <source>Invalid parameters were passed to a tag type specific function.</source>
          <target state="translated">태그 유형별 함수에 유효하지 않은 매개 변수가 전달되었습니다.</target>
        </trans-unit>
        <trans-unit id="5a59f06efae52e30c138550cf6052e71fd3d1ac9" translate="yes" xml:space="preserve">
          <source>Invalid usage:</source>
          <target state="translated">잘못된 사용법 :</target>
        </trans-unit>
        <trans-unit id="c36e404fedcad259fb1f8b710d66da4011e648d5" translate="yes" xml:space="preserve">
          <source>InvalidMedia - the media cannot be played.</source>
          <target state="translated">InvalidMedia-미디어를 재생할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7c9fc450b1e63daf00928865af63a2878a8d0fec" translate="yes" xml:space="preserve">
          <source>InvalidRequestError</source>
          <target state="translated">InvalidRequestError</target>
        </trans-unit>
        <trans-unit id="b343bfc8edef7982a27505cca76bf9e171177f2c" translate="yes" xml:space="preserve">
          <source>Invalidate the engine releasing its resources</source>
          <target state="translated">엔진을 무효화하여 리소스 해제</target>
        </trans-unit>
        <trans-unit id="28fd0da131c10039574fdf6a2387a1b7572f1e42" translate="yes" xml:space="preserve">
          <source>Invalidates all open sessions against the network interface and therefore stops the underlying network interface. This function always changes the session's &lt;a href=&quot;qnetworksession#state&quot;&gt;state&lt;/a&gt;() flag to &lt;a href=&quot;qnetworksession#State-enum&quot;&gt;Disconnected&lt;/a&gt;.</source>
          <target state="translated">네트워크 인터페이스에 대해 열려있는 모든 세션을 무효화하여 기본 네트워크 인터페이스를 중지합니다. 이 함수는 항상 세션의 &lt;a href=&quot;qnetworksession#state&quot;&gt;상태&lt;/a&gt; () 플래그를 &lt;a href=&quot;qnetworksession#State-enum&quot;&gt;Disconnected로&lt;/a&gt; 변경합니다 .</target>
        </trans-unit>
        <trans-unit id="396930f732f1b9e10197625d97961ea0eb15239c" translate="yes" xml:space="preserve">
          <source>Invalidates and destroys the &lt;a href=&quot;qvulkandevicefunctions&quot;&gt;QVulkanDeviceFunctions&lt;/a&gt; object for the given</source>
          <target state="translated">주어진 &lt;a href=&quot;qvulkandevicefunctions&quot;&gt;QVulkanDeviceFunctions&lt;/a&gt; 객체를 무효화하고 파기합니다.</target>
        </trans-unit>
        <trans-unit id="63acc69da023485981f875033a90db8cebf50236" translate="yes" xml:space="preserve">
          <source>Invalidates and schedules a redraw of</source>
          <target state="translated">다시 그리기 무효화 및 예약</target>
        </trans-unit>
        <trans-unit id="617f68dafc0d99ed33bf6d23481ff2f4aaaa0832" translate="yes" xml:space="preserve">
          <source>Invalidates and schedules a redraw of the</source>
          <target state="translated">다시 그리기를 무효화하고 예약합니다.</target>
        </trans-unit>
        <trans-unit id="8fa55c79f548c62898df83a1a0f5f787288abed8" translate="yes" xml:space="preserve">
          <source>Invalidates any cached information in this layout item.</source>
          <target state="translated">이 레이아웃 항목에서 캐시 된 정보를 무효화합니다.</target>
        </trans-unit>
        <trans-unit id="a4e3f3d5f583411be6e7d49b04496787cec13e76" translate="yes" xml:space="preserve">
          <source>Invalidates the current filtering for the columns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="757bb30ef9fa43325330dc83a9d224a470c2f72c" translate="yes" xml:space="preserve">
          <source>Invalidates the current filtering for the rows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1c7f88e06661f3b9c657a064aab76e4f5b60e2a" translate="yes" xml:space="preserve">
          <source>Invalidates the current filtering.</source>
          <target state="translated">현재 필터링을 무효화합니다.</target>
        </trans-unit>
        <trans-unit id="61eb128cc15d583da295effc653be5c7369d7111" translate="yes" xml:space="preserve">
          <source>Invalidates the current sorting and filtering.</source>
          <target state="translated">현재 정렬 및 필터링을 무효화합니다.</target>
        </trans-unit>
        <trans-unit id="d8e3c68e4ecb1b6f049aacf3a7c3c3a596c31057" translate="yes" xml:space="preserve">
          <source>InverseModelMatrix</source>
          <target state="translated">InverseModelMatrix</target>
        </trans-unit>
        <trans-unit id="0e661f7bd72983f6a6d4371aa3e0af6c1aed1106" translate="yes" xml:space="preserve">
          <source>InverseModelViewMatrix</source>
          <target state="translated">InverseModelViewMatrix</target>
        </trans-unit>
        <trans-unit id="2ef2cf002f8bd74e633bd46ec9ff5b31b2b36206" translate="yes" xml:space="preserve">
          <source>InverseModelViewProjectionMatrix</source>
          <target state="translated">InverseModelViewProjectionMatrix</target>
        </trans-unit>
        <trans-unit id="4ad6555d1727b8811ec82aab8bbf33a5c90109aa" translate="yes" xml:space="preserve">
          <source>InverseProjectionMatrix</source>
          <target state="translated">InverseProjectionMatrix</target>
        </trans-unit>
        <trans-unit id="5f8bde9fda525a665edec186dcd78af663229474" translate="yes" xml:space="preserve">
          <source>InverseViewMatrix</source>
          <target state="translated">InverseViewMatrix</target>
        </trans-unit>
        <trans-unit id="65cf1d14551dd4e4151a012883b3056f5c9bdb9a" translate="yes" xml:space="preserve">
          <source>InverseViewProjectionMatrix</source>
          <target state="translated">InverseViewProjectionMatrix</target>
        </trans-unit>
        <trans-unit id="d514461d1f2a20ff2e1bb5f30a5db01583e37b0c" translate="yes" xml:space="preserve">
          <source>InverseViewportMatrix</source>
          <target state="translated">InverseViewportMatrix</target>
        </trans-unit>
        <trans-unit id="d6c01c5ff52beb88be0fae8bb8795b83173a3836" translate="yes" xml:space="preserve">
          <source>Inversely, two connections having different connection names will always either be connected to different buses, or have a different unique name (as returned by &lt;a href=&quot;qdbusconnection#baseService&quot;&gt;baseService&lt;/a&gt;()) on that bus.</source>
          <target state="translated">반대로, 연결 이름이 다른 두 개의 연결은 항상 다른 버스에 연결되거나 해당 버스에서 다른 고유 이름 ( &lt;a href=&quot;qdbusconnection#baseService&quot;&gt;baseService&lt;/a&gt; ()에서 리턴 된 대로 ) 을 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="3fa2ee7cee68ecaea156a486358ad7d443ff492c" translate="yes" xml:space="preserve">
          <source>Invert all channels, including the alpha channel.</source>
          <target state="translated">알파 채널을 포함한 모든 채널을 반전시킵니다.</target>
        </trans-unit>
        <trans-unit id="d6f3b4435a21d2db03f17e956b39cf2c26fa1421" translate="yes" xml:space="preserve">
          <source>Invert only the RGB values and leave the alpha channel unchanged.</source>
          <target state="translated">RGB 값만 반전하고 알파 채널은 변경하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="dca87fb0afc4f2d70c4759cf137ccc73e28dacd1" translate="yes" xml:space="preserve">
          <source>Invert the current value.</source>
          <target state="translated">현재 값을 반전시킵니다.</target>
        </trans-unit>
        <trans-unit id="41a5a6b05a530daa22077eb00ce33d9e41f004aa" translate="yes" xml:space="preserve">
          <source>Inverted landscape orientation, rotated 180 degrees relative to landscape.</source>
          <target state="translated">반전 된 가로 방향으로 가로를 기준으로 180도 회전합니다.</target>
        </trans-unit>
        <trans-unit id="bb29bbe1651a1795e7803012b5e529310ed04c0c" translate="yes" xml:space="preserve">
          <source>Inverted portrait orientation, rotated 180 degrees relative to portrait.</source>
          <target state="translated">거꾸로 된 세로 방향으로 세로에 대해 180도 회전합니다.</target>
        </trans-unit>
        <trans-unit id="614ba9f0ee40ff48178d3333d8eafb243c7bb045" translate="yes" xml:space="preserve">
          <source>Inverting an 8-bit image means to replace all pixels using color index</source>
          <target state="translated">8 비트 이미지를 반전 시키면 색상 인덱스를 사용하여 모든 픽셀을 교체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f89e2e13b2d53505e4ba5beb51ed508f2f905217" translate="yes" xml:space="preserve">
          <source>Inverts all pixel values in the image using the given &lt;a href=&quot;qimage#InvertMode-enum&quot;&gt;InvertMode&lt;/a&gt; value.</source>
          <target state="translated">주어진 &lt;a href=&quot;qimage#InvertMode-enum&quot;&gt;InvertMode&lt;/a&gt; 값을 사용하여 이미지의 모든 픽셀 값을 반전시킵니다 .</target>
        </trans-unit>
        <trans-unit id="183c03455e9c447f3250a0431b6af950625dab3d" translate="yes" xml:space="preserve">
          <source>Inverts all pixel values in the image.</source>
          <target state="translated">이미지의 모든 픽셀 값을 반전시킵니다.</target>
        </trans-unit>
        <trans-unit id="75673da0e7d44f906a810b07a2238929f869bda3" translate="yes" xml:space="preserve">
          <source>Inverts the blur area, so the center is blurred instead. &lt;code&gt;false&lt;/code&gt; by default.</source>
          <target state="translated">블러 영역을 반전하여 중앙이 블러 처리되도록합니다. 기본적으로 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f32c06e8537108c19e0f7e1ba43f9d7e5c49ba40" translate="yes" xml:space="preserve">
          <source>Inverts the blur area, so the center is blurred instead. The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba293f01c775cf65b4737bb63033476678ce328a" translate="yes" xml:space="preserve">
          <source>Inverts the value of the bit at index position</source>
          <target state="translated">인덱스 위치에서 비트 값을 반전시킵니다.</target>
        </trans-unit>
        <trans-unit id="0a6e9c27b722c122b9532e1dccd0134643d2b50b" translate="yes" xml:space="preserve">
          <source>Inverts the x-axis controls.</source>
          <target state="translated">x 축 컨트롤을 반전합니다.</target>
        </trans-unit>
        <trans-unit id="b4045c42845e89d442d29f2a81db94ecd549dac7" translate="yes" xml:space="preserve">
          <source>Inverts the x-axis controls. The default value is false.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c0907e12128d6c4f8a03a195b12285c10faf0e6" translate="yes" xml:space="preserve">
          <source>Inverts the y-axis controls.</source>
          <target state="translated">Y 축 컨트롤을 반전합니다.</target>
        </trans-unit>
        <trans-unit id="81a38b569e72601bf009124116261965e5b393fd" translate="yes" xml:space="preserve">
          <source>Inverts the y-axis controls. The default value is true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81f55d03d9cf38ebad7eaa836f0634d6bc0d5993" translate="yes" xml:space="preserve">
          <source>InvokeInfo Struct</source>
          <target state="translated">InvokeInfo 구조</target>
        </trans-unit>
        <trans-unit id="4381d0970c870f9bccbeee86a74393f59ac3dad1" translate="yes" xml:space="preserve">
          <source>InvokeInfo::autoforward</source>
          <target state="translated">InvokeInfo::autoforward</target>
        </trans-unit>
        <trans-unit id="8206e9d65f10260ed4d21eda61ce247d7b226e60" translate="yes" xml:space="preserve">
          <source>InvokeInfo::context</source>
          <target state="translated">InvokeInfo::context</target>
        </trans-unit>
        <trans-unit id="7402e64f0e220b77a006d6709f773e2e1a12760f" translate="yes" xml:space="preserve">
          <source>InvokeInfo::expr</source>
          <target state="translated">InvokeInfo::expr</target>
        </trans-unit>
        <trans-unit id="38d0b39fb27a9b22acb33c01cdd5f2dfc5701d5f" translate="yes" xml:space="preserve">
          <source>InvokeInfo::finalize</source>
          <target state="translated">InvokeInfo::finalize</target>
        </trans-unit>
        <trans-unit id="596689b53ca7d90620be0ec6b273a9edaa78a33a" translate="yes" xml:space="preserve">
          <source>InvokeInfo::id</source>
          <target state="translated">InvokeInfo::id</target>
        </trans-unit>
        <trans-unit id="385a98bc9f665ae6eedf11448572b492ac6f73ea" translate="yes" xml:space="preserve">
          <source>InvokeInfo::location</source>
          <target state="translated">InvokeInfo::location</target>
        </trans-unit>
        <trans-unit id="eabb765d76a8959ac813b96803f1ec194c4baa3b" translate="yes" xml:space="preserve">
          <source>InvokeInfo::prefix</source>
          <target state="translated">InvokeInfo::prefix</target>
        </trans-unit>
        <trans-unit id="37f4b18289c2f3a000794156016f542673d71d30" translate="yes" xml:space="preserve">
          <source>Invoked after class creation, but before any properties have been set.</source>
          <target state="translated">클래스가 생성 된 후 속성이 설정되기 전에 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="9c5d65ebf8a7c7a86e94a67e797da7008ef07891" translate="yes" xml:space="preserve">
          <source>Invoked after the root component that caused this instantiation has completed construction. At this point all static values and binding values have been assigned to the class.</source>
          <target state="translated">이 인스턴스화를 유발 한 루트 구성 요소가 구성을 완료 한 후에 호출됩니다. 이 시점에서 모든 정적 값과 바인딩 값이 클래스에 할당되었습니다.</target>
        </trans-unit>
        <trans-unit id="c652c4a193a119c00ad771917bcf571273845893" translate="yes" xml:space="preserve">
          <source>InvokedServices (QML type)</source>
          <target state="translated">InvokedServices (QML 유형)</target>
        </trans-unit>
        <trans-unit id="9b723a70a83f1081bbd8502be88feff54fff5dd7" translate="yes" xml:space="preserve">
          <source>InvokedServices QML Type</source>
          <target state="translated">InvokedServices QML 유형</target>
        </trans-unit>
        <trans-unit id="e89c1d489a20cd5daa31f3ffbd42fc1219b9aca9" translate="yes" xml:space="preserve">
          <source>InvokedServices.children</source>
          <target state="translated">InvokedServices.children</target>
        </trans-unit>
        <trans-unit id="8064a80348b64a5df6ebb80a9c558076ddf3e16f" translate="yes" xml:space="preserve">
          <source>InvokedServices.qmlChildren</source>
          <target state="translated">InvokedServices.qmlChildren</target>
        </trans-unit>
        <trans-unit id="89d0818053f38ad3dd4c981d540ad228f4a88d7b" translate="yes" xml:space="preserve">
          <source>InvokedServices.stateMachine</source>
          <target state="translated">InvokedServices.stateMachine</target>
        </trans-unit>
        <trans-unit id="d0653cecd1812cafe7ac03d67f761d57b75037a1" translate="yes" xml:space="preserve">
          <source>Invokes the</source>
          <target state="translated">호출</target>
        </trans-unit>
        <trans-unit id="403926caf9b98373530bada5936c3b9b41e12cee" translate="yes" xml:space="preserve">
          <source>Invokes the action specified by</source>
          <target state="translated">에 의해 지정된 작업을 호출합니다</target>
        </trans-unit>
        <trans-unit id="19a0d8f5b219129e5c850a19a90607a1663b0ea5" translate="yes" xml:space="preserve">
          <source>Invokes the service with the parameters given in the constructor, passing</source>
          <target state="translated">생성자에 제공된 매개 변수를 사용하여 서비스를 호출하고</target>
        </trans-unit>
        <trans-unit id="def778a938250cecb483089c54dc1c291e3a04eb" translate="yes" xml:space="preserve">
          <source>Invokes this method on a &lt;a href=&quot;qobject#Q_GADGET&quot;&gt;Q_GADGET&lt;/a&gt;. Returns &lt;code&gt;true&lt;/code&gt; if the member could be invoked. Returns &lt;code&gt;false&lt;/code&gt; if there is no such member or the parameters did not match.</source>
          <target state="translated">&lt;a href=&quot;qobject#Q_GADGET&quot;&gt;Q_GADGET&lt;/a&gt; 에서이 메소드를 호출합니다 . 멤버를 호출 할 수 있으면 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 . 그러한 멤버가 없거나 매개 변수가 일치하지 않으면 &lt;code&gt;false&lt;/code&gt; 를 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="3fd9a794b68cc3e82e967ff9592720df0b5e426f" translate="yes" xml:space="preserve">
          <source>Invokes this method on the object</source>
          <target state="translated">객체에서이 메소드를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="fa69c8403504cb303c6b242c44d65e7a1eb60eec" translate="yes" xml:space="preserve">
          <source>Invoking External Tools</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="521190094228156d8d614c1d4f8d823ae59819a7" translate="yes" xml:space="preserve">
          <source>Invoking QML Methods</source>
          <target state="translated">QML 메소드 호출</target>
        </trans-unit>
        <trans-unit id="f84a9393850762e0faa1e82668357fb9ff331d37" translate="yes" xml:space="preserve">
          <source>Invoking a function with arguments is done by passing them to &lt;a href=&quot;qtconcurrent-qtaskbuilder#withArguments&quot;&gt;QtConcurrent::QTaskBuilder::withArguments&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d8d897e6822c0e5934d639bd071d785bd97ac79" translate="yes" xml:space="preserve">
          <source>Invoking external tools</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cc49c7e9c46b038949aacd9d2f9a4384c094e53" translate="yes" xml:space="preserve">
          <source>Invoking functions with overloaded operator()()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ad0b492b145db07777ac0897d486c668b634c41" translate="yes" xml:space="preserve">
          <source>Invoking the &lt;a href=&quot;qregularexpressionmatchiterator#hasNext&quot;&gt;hasNext&lt;/a&gt;() member function on the constructed object will return false, as the iterator is not iterating on a valid sequence of matches.</source>
          <target state="translated">구성된 객체 에서 &lt;a href=&quot;qregularexpressionmatchiterator#hasNext&quot;&gt;hasNext&lt;/a&gt; () 멤버 함수를 호출하면 반복자가 유효한 일치 시퀀스를 반복하지 않으므로 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2bddaea174340270be5a83fe7aed2e32aa628eba" translate="yes" xml:space="preserve">
          <source>Irish</source>
          <target state="translated">Irish</target>
        </trans-unit>
        <trans-unit id="de607a85708636dbeef859ca15fd3611756082c1" translate="yes" xml:space="preserve">
          <source>Irish, Ireland Gaelic</source>
          <target state="translated">아일랜드, 아일랜드 게 일어</target>
        </trans-unit>
        <trans-unit id="6f4209f4f1a509e0a1ecea752f65dad71847167e" translate="yes" xml:space="preserve">
          <source>Is Alternative Frequency currently enabled</source>
          <target state="translated">대체 주파수가 현재 활성화되어 있습니까?</target>
        </trans-unit>
        <trans-unit id="7a989cfaa0b13c8e65bcffebcea63eb577109d1f" translate="yes" xml:space="preserve">
          <source>Is currently being animated into a value explicitly assigned to the property.</source>
          <target state="translated">현재 속성에 명시 적으로 지정된 값으로 애니메이션되고 있습니다.</target>
        </trans-unit>
        <trans-unit id="38c3afb2be1d5c11f4e714c3090fd7df8e09273c" translate="yes" xml:space="preserve">
          <source>Is easier to use (can use an integer directly)</source>
          <target state="translated">사용하기 쉬움 (정수를 직접 사용할 수 있음)</target>
        </trans-unit>
        <trans-unit id="4b03ec4c67db372618c61438473d3465e98838e5" translate="yes" xml:space="preserve">
          <source>Is faster (no conversion to integer)</source>
          <target state="translated">더 빠름 (정수로 변환하지 않음)</target>
        </trans-unit>
        <trans-unit id="b760aca9613c83d76c1d8a842c2603e996fd7165" translate="yes" xml:space="preserve">
          <source>Is replaced with simple &lt;a href=&quot;qml-qtquick-controls2-scrollbar&quot;&gt;ScrollBar&lt;/a&gt;/&lt;a href=&quot;qml-qtquick-controls2-scrollindicator&quot;&gt;ScrollIndicator&lt;/a&gt; controls that can be attached to any Flickable:</source>
          <target state="translated">Flickable에 연결할 수있는 간단한 &lt;a href=&quot;qml-qtquick-controls2-scrollbar&quot;&gt;ScrollBar&lt;/a&gt; / &lt;a href=&quot;qml-qtquick-controls2-scrollindicator&quot;&gt;ScrollIndicator&lt;/a&gt; 컨트롤 로 대체되었습니다 .</target>
        </trans-unit>
        <trans-unit id="53dae1f2888a1dac0cf6a200eda0a4828798f032" translate="yes" xml:space="preserve">
          <source>Is set if one of the sub controls &lt;code&gt;CC_SpinUp&lt;/code&gt; or &lt;code&gt;CC_SpinDown&lt;/code&gt; is pressed on with the mouse.</source>
          <target state="translated">하위 컨트롤 &lt;code&gt;CC_SpinUp&lt;/code&gt; 또는 &lt;code&gt;CC_SpinDown&lt;/code&gt; 중 하나를 마우스로 누르면 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="f7cb88ca211debbcb4ccfa2fed4163384ad7e738" translate="yes" xml:space="preserve">
          <source>Is the base of all QML animations. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">모든 QML 애니메이션의 기본입니다. &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="379845bcf0f21c58164cfdedeb93f17a65116be6" translate="yes" xml:space="preserve">
          <source>Is the base of all QML animators. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">모든 QML 애니메이터의 기반입니다. &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5e519a8d6848029d5a23aa10992a6fe1e91c8825" translate="yes" xml:space="preserve">
          <source>Is this class thread-safe?</source>
          <target state="translated">이 클래스는 스레드로부터 안전합니까?</target>
        </trans-unit>
        <trans-unit id="33ec2e47616bd9d7cbbec9faf74756ff4e984eaf" translate="yes" xml:space="preserve">
          <source>Is this function reentrant?</source>
          <target state="translated">이 기능은 재진입입니까?</target>
        </trans-unit>
        <trans-unit id="a37ffd6c22de35ce5f9a01d71d9ccaaee20b4709" translate="yes" xml:space="preserve">
          <source>Iscii-Bng, Dev, Gjr, Knd, Mlm, Ori, Pnj, Tlg, and Tml</source>
          <target state="translated">Iscii-Bng, Dev, Gjr, Knd, Mlm, Ori, Pnj, Tlg 및 Tml</target>
        </trans-unit>
        <trans-unit id="5b50617b96967ffbee403356a54dcd844a4dfe47" translate="yes" xml:space="preserve">
          <source>Issues an OpenGL timer query at this point in the OpenGL command queue. Calling this function in a sequence in your application's rendering function, will build up details of the GPU time taken to execute the OpenGL commands between successive calls to this function.</source>
          <target state="translated">이 시점에서 OpenGL 명령 큐에서 OpenGL 타이머 쿼리를 실행합니다. 애플리케이션의 렌더링 함수에서이 함수를 순서대로 호출하면이 함수에 대한 연속 호출간에 OpenGL 명령을 실행하는 데 걸리는 GPU 시간에 대한 세부 정보가 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="316c5953f37a6e67e5584de45c686a673745a61b" translate="yes" xml:space="preserve">
          <source>Issues the specified</source>
          <target state="translated">지정된 문제를 발행</target>
        </trans-unit>
        <trans-unit id="ff6bd96161d69f44ec125f231a68c0e462f49e16" translate="yes" xml:space="preserve">
          <source>Issues with High DPI</source>
          <target state="translated">높은 DPI 문제</target>
        </trans-unit>
        <trans-unit id="892d6fcd0c02d7b2fb1b90bbd23dd5031612fdaa" translate="yes" xml:space="preserve">
          <source>It affects the locations into which test programs might write files: &lt;code&gt;GenericDataLocation&lt;/code&gt;, &lt;code&gt;AppDataLocation&lt;/code&gt;, &lt;code&gt;ConfigLocation&lt;/code&gt;, &lt;code&gt;GenericConfigLocation&lt;/code&gt;, &lt;code&gt;AppConfigLocation&lt;/code&gt;, &lt;code&gt;GenericCacheLocation&lt;/code&gt;, and &lt;code&gt;CacheLocation&lt;/code&gt;. Other locations are not affected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d0fc319f9079960cbbc488619ac3235dbb15ca0" translate="yes" xml:space="preserve">
          <source>It affects the locations into which test programs might write files: &lt;code&gt;GenericDataLocation&lt;/code&gt;, &lt;code&gt;DataLocation&lt;/code&gt;, &lt;code&gt;ConfigLocation&lt;/code&gt;, &lt;code&gt;GenericConfigLocation&lt;/code&gt;, &lt;code&gt;AppConfigLocation&lt;/code&gt;, &lt;code&gt;GenericCacheLocation&lt;/code&gt;, and &lt;code&gt;CacheLocation&lt;/code&gt;. Other locations are not affected.</source>
          <target state="translated">테스트 프로그램이 파일을 기록 할 수있는 위치에 영향을줍니다 : &lt;code&gt;GenericDataLocation&lt;/code&gt; , &lt;code&gt;DataLocation&lt;/code&gt; , &lt;code&gt;ConfigLocation&lt;/code&gt; , &lt;code&gt;GenericConfigLocation&lt;/code&gt; , &lt;code&gt;AppConfigLocation&lt;/code&gt; , &lt;code&gt;GenericCacheLocation&lt;/code&gt; 및 &lt;code&gt;CacheLocation&lt;/code&gt; . 다른 위치는 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="45e7a5bbe1ef1b964f66b1e1d230220f5336143f" translate="yes" xml:space="preserve">
          <source>It allows (z axis) rotation to be relative to an arbitrary point, and also provides a way to specify 3D-like rotations for Items. This gives more control over item rotation than the &lt;a href=&quot;qml-qtquick-item#rotation-prop&quot;&gt;rotation&lt;/a&gt; property.</source>
          <target state="translated">(z 축) 회전이 임의의 점을 기준으로하고 항목에 대해 3D와 같은 회전을 지정하는 방법을 제공합니다. 이는 &lt;a href=&quot;qml-qtquick-item#rotation-prop&quot;&gt;회전&lt;/a&gt; 속성 보다 항목 회전을 더 많이 제어 합니다.</target>
        </trans-unit>
        <trans-unit id="4984fdb3206365702c090708330b833f441b097f" translate="yes" xml:space="preserve">
          <source>It allows a QML class connect to another Bluetooth device and exchange strings with it. Data is sent and received using a &lt;a href=&quot;qdatastream&quot;&gt;QDataStream&lt;/a&gt; object allowing type safe transfers of QStrings. &lt;a href=&quot;qdatastream&quot;&gt;QDataStream&lt;/a&gt; is a well known format and can be decoded by non-Qt applications. Note that for the ease of use, &lt;a href=&quot;qml-qtbluetooth-bluetoothsocket&quot;&gt;BluetoothSocket&lt;/a&gt; is only well suited for use with strings. If you want to use a binary protocol for your application's communication you should consider using its C++ counterpart &lt;a href=&quot;qbluetoothsocket&quot;&gt;QBluetoothSocket&lt;/a&gt;.</source>
          <target state="translated">QML 클래스가 다른 Bluetooth 장치에 연결하여 문자열을 교환 할 수 있습니다. QString의 안전한 형식 전송을 허용 하는 &lt;a href=&quot;qdatastream&quot;&gt;QDataStream&lt;/a&gt; 객체를 사용하여 데이터 를 송수신합니다. &lt;a href=&quot;qdatastream&quot;&gt;QDataStream&lt;/a&gt; 은 잘 알려진 형식이며 비 Qt 응용 프로그램에서 디코딩 할 수 있습니다. 사용하기 쉽도록 &lt;a href=&quot;qml-qtbluetooth-bluetoothsocket&quot;&gt;BluetoothSocket&lt;/a&gt; 은 문자열과 함께 사용하기에 적합합니다. 응용 프로그램의 통신에 이진 프로토콜을 사용하려면 C ++ 대응 &lt;a href=&quot;qbluetoothsocket&quot;&gt;QBluetoothSocket&lt;/a&gt; 사용을 고려해야 합니다.</target>
        </trans-unit>
        <trans-unit id="5a27d83087a5e0c9d1b504e38272dc7fc8f4e275" translate="yes" xml:space="preserve">
          <source>It allows a QML class connect to another Bluetooth device and exchange strings with it. Data is sent and received using a &lt;a href=&quot;qdatastream&quot;&gt;QDataStream&lt;/a&gt; object allowing type safe transfers of QStrings. &lt;a href=&quot;qdatastream&quot;&gt;QDataStream&lt;/a&gt; is a well known format and can be decoded by non-Qt applications. Note that for the ease of use, BluetoothSocket is only well suited for use with strings. If you want to use a binary protocol for your application's communication you should consider using its C++ counterpart &lt;a href=&quot;qbluetoothsocket&quot;&gt;QBluetoothSocket&lt;/a&gt;.</source>
          <target state="translated">QML 클래스를 다른 Bluetooth 장치에 연결하고 문자열을 교환 할 수 있습니다. 데이터는 &lt;a href=&quot;qdatastream&quot;&gt;QDataStream&lt;/a&gt; 객체를 사용하여 전송 및 수신 되어 QStrings의 유형 안전 전송을 허용합니다. &lt;a href=&quot;qdatastream&quot;&gt;QDataStream&lt;/a&gt; 은 잘 알려진 형식이며 비 Qt 응용 프로그램에서 디코딩 할 수 있습니다. 사용 편의성을 위해 BluetoothSocket은 문자열과 함께 사용하는 데만 적합합니다. 애플리케이션 통신에 바이너리 프로토콜을 사용하려면 해당 C ++ 대응 &lt;a href=&quot;qbluetoothsocket&quot;&gt;QBluetoothSocket&lt;/a&gt; 사용을 고려해야 합니다.</target>
        </trans-unit>
        <trans-unit id="b12bd1d383fbab4f5efe9fc2f69778a2ccfc5ca8" translate="yes" xml:space="preserve">
          <source>It allows a QML project to get information about a remote service, or describe a service for a &lt;a href=&quot;qml-qtbluetooth-bluetoothsocket&quot;&gt;BluetoothSocket&lt;/a&gt; to connect to.</source>
          <target state="translated">QML 프로젝트는 원격 서비스에 대한 정보를 얻거나 &lt;a href=&quot;qml-qtbluetooth-bluetoothsocket&quot;&gt;BluetoothSocket&lt;/a&gt; 에 연결할 서비스를 설명 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b4b3433cd22c8f41bbe4095e05cf6268dc8bb9a" translate="yes" xml:space="preserve">
          <source>It allows different scaling values for the x and y axes, and allows the scale to be relative to an arbitrary point. This gives more control over item scaling than the &lt;a href=&quot;qml-qtquick-item#scale-prop&quot;&gt;scale&lt;/a&gt; property.</source>
          <target state="translated">x 및 y 축에 대해 다른 스케일링 값을 허용하고 스케일이 임의의 점을 기준으로 할 수 있습니다. 이렇게하면 &lt;a href=&quot;qml-qtquick-item#scale-prop&quot;&gt;scale&lt;/a&gt; 속성 보다 항목 배율을 더 많이 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b7ddece79928f675514b612febb4cad06af4bdd6" translate="yes" xml:space="preserve">
          <source>It allows for a combination of rotation, scale, translatation and shearing by using just one tranformation provided in a 4x4-matrix.</source>
          <target state="translated">4x4- 매트릭스에 제공된 단 하나의 변환 만 사용하여 회전, 스케일, 변환 및 전단을 조합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f026fd7a5630d3c3fe988c2e105524badcd48ed" translate="yes" xml:space="preserve">
          <source>It also contains a hint to the renderer if this attribute is the attribute describing the position. The scene graph renderer may use this information to perform optimizations.</source>
          <target state="translated">이 속성이 위치를 설명하는 속성 인 경우 렌더러에 대한 힌트도 포함합니다. 장면 그래프 렌더러는이 정보를 사용하여 최적화를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4bce71644cd326e0cd998c032adb61ef2dc96e28" translate="yes" xml:space="preserve">
          <source>It also contains some functions to ease the process of implementing different authentication flows.</source>
          <target state="translated">또한 다른 인증 흐름을 구현하는 프로세스를 용이하게하는 몇 가지 기능이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="493cddeffcbe0452095a7fd90b0b93f6886175e0" translate="yes" xml:space="preserve">
          <source>It also contains some helper functions to check if a version supports profiles or is a legacy version.</source>
          <target state="translated">또한 버전이 프로파일을 지원하는지 또는 레거시 버전인지 확인하는 몇 가지 도우미 기능도 포함합니다.</target>
        </trans-unit>
        <trans-unit id="af02a6692a3a740f2c059b27631f5a770d91067c" translate="yes" xml:space="preserve">
          <source>It also serves as the default text in menus and tooltips if the action has not been defined with &lt;a href=&quot;qaction#text-prop&quot;&gt;setText&lt;/a&gt;() or &lt;a href=&quot;qaction#toolTip-prop&quot;&gt;setToolTip&lt;/a&gt;(), and will also be used in toolbar buttons if no icon has been defined using &lt;a href=&quot;qaction#icon-prop&quot;&gt;setIcon&lt;/a&gt;().</source>
          <target state="translated">조치가 &lt;a href=&quot;qaction#text-prop&quot;&gt;setText&lt;/a&gt; () 또는 &lt;a href=&quot;qaction#toolTip-prop&quot;&gt;setToolTip&lt;/a&gt; () 로 정의되지 않은 경우 메뉴 및 툴팁에서 기본 텍스트 로 사용되며 &lt;a href=&quot;qaction#icon-prop&quot;&gt;setIcon&lt;/a&gt; ()을 사용하여 정의 된 아이콘이없는 경우 도구 모음 단추에도 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="1d137d4a22515286cbe8e400b4de632f7101bf05" translate="yes" xml:space="preserve">
          <source>It also skips any tear-down or tidy-up that was supposed to happen at the end of the test, and might therefore leave the workspace in an untidy state, which might cause complications for further tests.</source>
          <target state="translated">또한 테스트가 끝날 때 발생할 것으로 예상되는 분해 또는 정리를 건너 뛰므로 작업 공간을 깔끔한 상태로 남겨 추가 테스트에 대한 합병증을 유발할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c203ad6a1c7c27d13a01e3369d445de0f98f7af1" translate="yes" xml:space="preserve">
          <source>It also supports changing the acceleration mode, which controls whether the force of gravity is included in the accelerometer values or not.</source>
          <target state="translated">또한 가속 모드 변경을 지원하여 중력이 가속도계 값에 포함되는지 여부를 제어합니다.</target>
        </trans-unit>
        <trans-unit id="d9a8fc79765558feb0300bb02f26757bc3871342" translate="yes" xml:space="preserve">
          <source>It also supports multi-homing, meaning that a connected endpoint can have alternate IP addresses associated with it in order to route around network failure or changing conditions.</source>
          <target state="translated">또한 멀티 호밍 (multi-homing)을 지원합니다. 즉, 연결된 엔드 포인트에 네트워크 장애 또는 변경 조건 주위를 라우팅하기 위해 연결된 IP 주소와 연관된 대체 IP 주소가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="30e14d615ec5de502fa147d4d19339331e025f93" translate="yes" xml:space="preserve">
          <source>It also works for any decimal values, 0.041 is increased to 0.042 by stepping once.</source>
          <target state="translated">또한 10 진수 값에도 작동하며 한 번 밟아 0.041을 0.042로 증가시킵니다.</target>
        </trans-unit>
        <trans-unit id="cef09f3e06d41b65454452fa162e02412a062301" translate="yes" xml:space="preserve">
          <source>It applies this transformation to</source>
          <target state="translated">이 변환을 적용합니다</target>
        </trans-unit>
        <trans-unit id="be7907abb5fe86c969233eb24984d6a8bfa256a3" translate="yes" xml:space="preserve">
          <source>It backs &lt;a href=&quot;qoffscreensurface&quot;&gt;QOffscreenSurface&lt;/a&gt; with standard EGL pbuffer surfaces (by default this is disabled and a gbm surface is used instead).</source>
          <target state="translated">그것은 백업 &lt;a href=&quot;qoffscreensurface&quot;&gt;QOffscreenSurface을&lt;/a&gt; 표준 EGL의의 pbuffer 표면에 (기본적으로이 사용할 수 없습니다와 GBM 표면이 대신 사용됩니다).</target>
        </trans-unit>
        <trans-unit id="ec74539d87886723fe218f1f5f4fef1dfc156a4b" translate="yes" xml:space="preserve">
          <source>It bears repeating that the implementation of qHashBits() - like the &lt;a href=&quot;qhash#qHashx&quot;&gt;qHash&lt;/a&gt;() overloads offered by Qt - may change at any time. You &lt;b&gt;must not&lt;/b&gt; rely on the fact that qHashBits() will give the same results (for the same inputs) across different Qt versions.</source>
          <target state="translated">Qt가 제공 하는 &lt;a href=&quot;qhash#qHashx&quot;&gt;qHash&lt;/a&gt; () 오버로드 와 같이 qHashBits ()의 구현은 언제든지 변경 될 수 있음을 반복합니다. 당신은 &lt;b&gt;안&lt;/b&gt; qHashBits ()는 서로 다른 Qt는 버전에서 (같은 입력에 대한) 같은 결과를 얻을 수 있다는 사실에 의존한다.</target>
        </trans-unit>
        <trans-unit id="ad7b9fddc80281837646eddd4ae396c594cdd1b8" translate="yes" xml:space="preserve">
          <source>It bears repeating that the implementation of qHashRange() - like the &lt;a href=&quot;qhash#qHashx&quot;&gt;qHash&lt;/a&gt;() overloads offered by Qt - may change at any time. You &lt;b&gt;must not&lt;/b&gt; rely on the fact that qHashRange() will give the same results (for the same inputs) across different Qt versions, even if &lt;a href=&quot;qhash#qHashx&quot;&gt;qHash&lt;/a&gt;() for the element type would.</source>
          <target state="translated">Qt가 제공 하는 &lt;a href=&quot;qhash#qHashx&quot;&gt;qHash&lt;/a&gt; () 오버로드 와 같이 qHashRange ()의 구현은 언제든지 변경 될 수 있음을 반복합니다. 당신은 &lt;b&gt;안&lt;/b&gt; , 심지어 다른 경우의 Qt 버전에서 qHashRange ()을 (같은 입력에 대해) 동일한 결과를 얻을 수 있다는 사실에 의존 &lt;a href=&quot;qhash#qHashx&quot;&gt;qHash&lt;/a&gt; 요소 유형 것이기 ().</target>
        </trans-unit>
        <trans-unit id="64a0f55217642aafebe2b85ae8fc003c1bae06cb" translate="yes" xml:space="preserve">
          <source>It bears repeating that the implementation of qHashRangeCommutative() - like the &lt;a href=&quot;qhash#qHashx&quot;&gt;qHash&lt;/a&gt;() overloads offered by Qt - may change at any time. You &lt;b&gt;must not&lt;/b&gt; rely on the fact that qHashRangeCommutative() will give the same results (for the same inputs) across different Qt versions, even if &lt;a href=&quot;qhash#qHashx&quot;&gt;qHash&lt;/a&gt;() for the element type would.</source>
          <target state="translated">Qt에서 제공 하는 &lt;a href=&quot;qhash#qHashx&quot;&gt;qHash&lt;/a&gt; () 오버로드 와 같이 qHashRangeCommutative ()의 구현은 언제든지 변경 될 수 있음을 반복합니다. 당신은 &lt;b&gt;안&lt;/b&gt; , 심지어 다른 경우의 Qt 버전에서 qHashRangeCommutative ()을 (같은 입력에 대해) 동일한 결과를 얻을 수 있다는 사실에 의존 &lt;a href=&quot;qhash#qHashx&quot;&gt;qHash&lt;/a&gt; 요소 유형 것이기 ().</target>
        </trans-unit>
        <trans-unit id="a5944cc5e5e18363fef910bcd4efee0b9d7c004c" translate="yes" xml:space="preserve">
          <source>It binds the entire sequence (2, 3, 1) to &lt;code&gt;$i&lt;/code&gt; one time only; the</source>
          <target state="translated">전체 시퀀스 (2, 3, 1)를 &lt;code&gt;$i&lt;/code&gt; 한 번만 바인딩합니다 . 그만큼</target>
        </trans-unit>
        <trans-unit id="4a29180c50b22b9467b90804ea3b41a735e4caf3" translate="yes" xml:space="preserve">
          <source>It builds upon the API concepts and types in the &lt;a href=&quot;location-positioning-qml&quot;&gt;QML Positioning API&lt;/a&gt;. A more hands-on introduction of the Maps and Navigation types can be found in the &lt;a href=&quot;qml-location5-maps&quot;&gt;Maps and Navigation tutorial&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;location-positioning-qml&quot;&gt;QML Positioning API&lt;/a&gt; 의 API 개념 및 유형을 기반으로합니다 . 지도 및 내비게이션 유형에 대한 자세한 소개는 &lt;a href=&quot;qml-location5-maps&quot;&gt;지도 및 내비게이션 튜토리얼&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6edb9bc8f0d65fd663144161a9ebdb55a6e2d504" translate="yes" xml:space="preserve">
          <source>It builds upon the API concepts and types in the &lt;a href=&quot;location-positioning-qml&quot;&gt;QML Positioning API&lt;/a&gt;. A more hands-on introduction of the Maps and Navigation types can be found in the &lt;a href=&quot;qml-location5-maps#&quot;&gt;Maps and Navigation tutorial&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;location-positioning-qml&quot;&gt;QML 포지셔닝 API&lt;/a&gt; 의 API 개념 및 유형을 기반으로합니다 . 지도 및 탐색 유형에 대한 자세한 실습 소개는 &lt;a href=&quot;qml-location5-maps#&quot;&gt;지도 및 탐색 자습서&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="76e018e8f1ab8bdee308e845a5c0c9ac4cc190ec" translate="yes" xml:space="preserve">
          <source>It calculates bounding rectangles with &lt;a href=&quot;qaccessibleinterface#rect&quot;&gt;rect()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qaccessibleinterface#rect&quot;&gt;rect ()로&lt;/a&gt; 경계 사각형을 계산 합니다.</target>
        </trans-unit>
        <trans-unit id="219e19c86e81f297e7203581f535136a8a3189a0" translate="yes" xml:space="preserve">
          <source>It can also be controlled with the &lt;a href=&quot;qml-qtquick-particles-particlesystem#pause-method&quot;&gt;pause()&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-particles-particlesystem#resume-method&quot;&gt;resume()&lt;/a&gt; methods.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-particles-particlesystem#pause-method&quot;&gt;pause ()&lt;/a&gt; 및 &lt;a href=&quot;qml-qtquick-particles-particlesystem#resume-method&quot;&gt;resume ()&lt;/a&gt; 메서드를 사용하여 제어 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="79e5efdb1f3b42907410bd26d8fce88aff86ea38" translate="yes" xml:space="preserve">
          <source>It can also be controlled with the &lt;a href=&quot;qml-qtquick-particles-particlesystem#start-method&quot;&gt;start()&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-particles-particlesystem#stop-method&quot;&gt;stop()&lt;/a&gt; methods.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-particles-particlesystem#start-method&quot;&gt;start ()&lt;/a&gt; 및 &lt;a href=&quot;qml-qtquick-particles-particlesystem#stop-method&quot;&gt;stop ()&lt;/a&gt; 메소드 로 제어 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cfade74f7c590c9a6a5837eaa81def8efe6d6236" translate="yes" xml:space="preserve">
          <source>It can also be helpful to build &lt;a href=&quot;https://doc.qt.io/qt-5.15/license-changes.html#qt-image-formats&quot;&gt;Qt Image Formats&lt;/a&gt; as this module provides support for additional texture formats.</source>
          <target state="translated">이 모듈은 추가 텍스처 형식에 대한 지원을 제공하므로 &lt;a href=&quot;https://doc.qt.io/qt-5.15/license-changes.html#qt-image-formats&quot;&gt;Qt 이미지 형식&lt;/a&gt; 을 빌드하는 것도 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c8e19bcf4c6fd9384ad9ea3da65b7ea4e85dc0f" translate="yes" xml:space="preserve">
          <source>It can also be used on other platforms, where it will fall back to using &lt;a href=&quot;qfiledialog&quot;&gt;QFileDialog&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qfiledialog&quot;&gt;QFileDialog&lt;/a&gt; 사용으로 대체 되는 다른 플랫폼에서도 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c19aead23c28756fafe778a7a23039aefd300005" translate="yes" xml:space="preserve">
          <source>It can also be used to manage variables that are temporarily set, such as reentrancy guards. By using this class, the variable will be reset whether the function is exited normally, exited early by a return statement, or exited by an exception.</source>
          <target state="translated">재진입 가드와 같이 일시적으로 설정된 변수를 관리하는 데에도 사용할 수 있습니다. 이 클래스를 사용하면 함수가 정상적으로 종료되거나 return 문에 의해 일찍 종료되거나 예외에 의해 종료되는지 여부에 따라 변수가 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="576766953327a007c542234820d8d3e3d0d82303" translate="yes" xml:space="preserve">
          <source>It can also be useful for C++ integration, as it is just a plain &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;. See the &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; documentation for further details.</source>
          <target state="translated">일반 &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 이므로 C ++ 통합에도 유용 할 수 있습니다 . 자세한 내용은 &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 설명서를 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="ddeb01fb7f1586aef3d3140874c13b6db65e2d13" translate="yes" xml:space="preserve">
          <source>It can always be overridden on a per-instance basis by using the class in question's own setFormat() function. However, it is often more convenient to set the format for all windows once at the start of the application. It also guarantees proper behavior in cases where shared contexts are required, because settings the format via this function guarantees that all contexts and surfaces, even the ones created internally by Qt, will use the same format.</source>
          <target state="translated">문제의 클래스 자체 setFormat () 함수를 사용하여 인스턴스 별 기준으로 항상 재정의 할 수 있습니다. 그러나 응용 프로그램을 시작할 때 모든 창의 형식을 한 번 설정하는 것이 더 편리한 경우가 많습니다. 또한이 기능을 통해 형식을 설정하면 Qt가 내부적으로 작성한 컨텍스트와 표면도 모두 동일한 형식을 사용하므로 공유 컨텍스트가 필요한 경우에도 올바른 동작을 보장합니다.</target>
        </trans-unit>
        <trans-unit id="e9eb34d60505405a32e394fc0fbf2f67fb4b87ad" translate="yes" xml:space="preserve">
          <source>It can be a JS array of JS arrays of points constructed with &lt;code&gt;Qt.point()&lt;/code&gt;, a &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt; or &lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt; of &lt;a href=&quot;qpolygonf&quot;&gt;QPolygonF&lt;/a&gt;, or &lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt;&amp;lt;&lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt;&amp;lt;&lt;a href=&quot;qpointf&quot;&gt;QPointF&lt;/a&gt;&amp;gt;&amp;gt;. If you are binding this to a custom property in some C++ object, &lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt;&amp;lt;&lt;a href=&quot;qpolygonf&quot;&gt;QPolygonF&lt;/a&gt;&amp;gt; or &lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt;&amp;lt;&lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt;&amp;lt;&lt;a href=&quot;qpointf&quot;&gt;QPointF&lt;/a&gt;&amp;gt;&amp;gt; is the most appropriate type to use.</source>
          <target state="translated">이 점으로 구성 JS 어레이의 JS 배열 될 수 &lt;code&gt;Qt.point()&lt;/code&gt; 하는 &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt; 또는 &lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt; 의 &lt;a href=&quot;qpolygonf&quot;&gt;QPolygonF&lt;/a&gt; 또는 &lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt; &amp;lt; &lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt; &amp;lt; &lt;a href=&quot;qpointf&quot;&gt;QPointF&lt;/a&gt; &amp;gt;&amp;gt;. 이것을 일부 C ++ 객체의 사용자 정의 속성에 바인딩하는 경우 &lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt; &amp;lt; &lt;a href=&quot;qpolygonf&quot;&gt;QPolygonF&lt;/a&gt; &amp;gt; 또는 &lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt; &amp;lt; &lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt; &amp;lt; &lt;a href=&quot;qpointf&quot;&gt;QPointF&lt;/a&gt; &amp;gt;&amp;gt;가 사용하기에 가장 적합한 유형입니다.</target>
        </trans-unit>
        <trans-unit id="a24cc1aab3f2afc48e0638cb17dd921fc4c9084c" translate="yes" xml:space="preserve">
          <source>It can be a JS array of points constructed with &lt;code&gt;Qt.point()&lt;/code&gt;, a &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt; or &lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt; of &lt;a href=&quot;qpointf&quot;&gt;QPointF&lt;/a&gt;, or &lt;a href=&quot;qpolygonf&quot;&gt;QPolygonF&lt;/a&gt;. If you are binding this to a custom property in some C++ object, &lt;a href=&quot;qpolygonf&quot;&gt;QPolygonF&lt;/a&gt; is the most appropriate type to use.</source>
          <target state="translated">그것은로 구성 점 JS 배열 될 수 &lt;code&gt;Qt.point()&lt;/code&gt; 하는 &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt; 또는 &lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt; 의 &lt;a href=&quot;qpointf&quot;&gt;QPointF&lt;/a&gt; 또는 &lt;a href=&quot;qpolygonf&quot;&gt;QPolygonF&lt;/a&gt; . 이것을 일부 C ++ 객체의 사용자 정의 속성에 바인딩하는 경우 &lt;a href=&quot;qpolygonf&quot;&gt;QPolygonF&lt;/a&gt; 가 사용하기에 가장 적합한 유형입니다.</target>
        </trans-unit>
        <trans-unit id="24fa36164b918cd24b98323c51d1dfb678fd91e8" translate="yes" xml:space="preserve">
          <source>It can be accessed through &lt;a href=&quot;qml-qtaudioengine-audioengine#samples-prop&quot;&gt;QtAudioEngine::AudioEngine::samples&lt;/a&gt; with its unique name and must be defined inside &lt;a href=&quot;qml-qtaudioengine-audioengine&quot;&gt;AudioEngine&lt;/a&gt; or be added to it using &lt;a href=&quot;qml-qtaudioengine-audioengine#addAudioSample-method&quot;&gt;AudioEngine.addAudioSample()&lt;/a&gt; if &lt;a href=&quot;qml-qtaudioengine-audiosample&quot;&gt;AudioSample&lt;/a&gt; is created dynamically.</source>
          <target state="translated">그것은을 통해 액세스 할 수 있습니다 &lt;a href=&quot;qml-qtaudioengine-audioengine#samples-prop&quot;&gt;QtAudioEngine :: AudioEngine :: 샘플&lt;/a&gt; 독특한 이름과 내부에 정의해야합니다 &lt;a href=&quot;qml-qtaudioengine-audioengine&quot;&gt;AudioEngine&lt;/a&gt; 또는 사용하여 추가 할 &lt;a href=&quot;qml-qtaudioengine-audioengine#addAudioSample-method&quot;&gt;AudioEngine.addAudioSample ()&lt;/a&gt; 경우 &lt;a href=&quot;qml-qtaudioengine-audiosample&quot;&gt;AudioSample가&lt;/a&gt; 동적으로 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="a86ad1f53c8b7f24c03598993832d7f86a582485" translate="yes" xml:space="preserve">
          <source>It can be accessed through &lt;a href=&quot;qml-qtaudioengine-audioengine#samples-prop&quot;&gt;QtAudioEngine::AudioEngine::samples&lt;/a&gt; with its unique name and must be defined inside &lt;a href=&quot;qml-qtaudioengine-audioengine&quot;&gt;AudioEngine&lt;/a&gt; or be added to it using &lt;a href=&quot;qml-qtaudioengine-audioengine#addAudioSample-method&quot;&gt;AudioEngine.addAudioSample()&lt;/a&gt; if AudioSample is created dynamically.</source>
          <target state="translated">그것은을 통해 액세스 할 수 있습니다 &lt;a href=&quot;qml-qtaudioengine-audioengine#samples-prop&quot;&gt;QtAudioEngine :: AudioEngine :: 샘플&lt;/a&gt; 독특한 이름과 내부에 정의해야합니다 &lt;a href=&quot;qml-qtaudioengine-audioengine&quot;&gt;AudioEngine&lt;/a&gt; 또는 사용하여 추가 할 &lt;a href=&quot;qml-qtaudioengine-audioengine#addAudioSample-method&quot;&gt;AudioEngine.addAudioSample ()&lt;/a&gt; AudioSample 동적으로 생성 된 경우입니다.</target>
        </trans-unit>
        <trans-unit id="39253f3cd3feae05e5a33d596f92a18b8ce17f2e" translate="yes" xml:space="preserve">
          <source>It can be added by calling the addRenderState() method on a &lt;a href=&quot;qt3drender-qrenderpass&quot;&gt;QRenderPass&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;qt3drender-qrenderpass&quot;&gt;QRenderPass&lt;/a&gt; 에서 addRenderState () 메소드를 호출하여 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7cd7b00495f9b9033bb6f0df4a2c067c5f5cfd1c" translate="yes" xml:space="preserve">
          <source>It can be added to a &lt;a href=&quot;qml-qt3d-render-renderpass&quot;&gt;RenderPass&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;qml-qt3d-render-renderpass&quot;&gt;RenderPass에&lt;/a&gt; 추가 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="35cb0834007b85d120b70e7e3374271d030b058b" translate="yes" xml:space="preserve">
          <source>It can be added to a &lt;a href=&quot;qt3drender-qrenderpass&quot;&gt;QRenderPass&lt;/a&gt; by calling &lt;a href=&quot;qt3drender-qrenderpass#addRenderState&quot;&gt;QRenderPass::addRenderState&lt;/a&gt;():</source>
          <target state="translated">&lt;a href=&quot;qt3drender-qrenderpass#addRenderState&quot;&gt;QRenderPass :: addRenderState&lt;/a&gt; ()를 호출 하여 &lt;a href=&quot;qt3drender-qrenderpass&quot;&gt;QRenderPass&lt;/a&gt; 에 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="756454e7ff6a7b759692a71049cdf2e00d1be48c" translate="yes" xml:space="preserve">
          <source>It can be added to the renderStates property of a &lt;a href=&quot;qml-qt3d-render-renderpass&quot;&gt;RenderPass&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;qml-qt3d-render-renderpass&quot;&gt;RenderPass&lt;/a&gt; 의 renderStates 속성에 추가 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="863953534b59c1406d24c245ca2bcfc1f761ba12" translate="yes" xml:space="preserve">
          <source>It can be checked or unchecked by the user.</source>
          <target state="translated">사용자가 확인하거나 선택을 취소 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ddd4c2e884a5b7dc84bb431c4f54fbf755e617c3" translate="yes" xml:space="preserve">
          <source>It can be constructed by calling QTextLayout::glyphs() or QTextFragment::glyphs(). The returned QGlyphs objects will contain &lt;a href=&quot;qrawfont&quot;&gt;QRawFont&lt;/a&gt; objects which represent the actual fonts used to render each portion of the text.</source>
          <target state="translated">QTextLayout :: glyphs () 또는 QTextFragment :: glyphs ()를 호출하여 구성 할 수 있습니다. 반환 QGlyphs 개체를 포함 &lt;a href=&quot;qrawfont&quot;&gt;QRawFont의&lt;/a&gt; 텍스트의 각 부분을 렌더링하는 데 사용되는 실제 글꼴을 나타내는 개체를.</target>
        </trans-unit>
        <trans-unit id="aba175c0f934bb59e6c6994153be8b66c4ea5457" translate="yes" xml:space="preserve">
          <source>It can be constructed by calling QTextLayout::glyphs() or QTextFragment::glyphs(). The returned QGlyphs objects will contain QRawFont objects which represent the actual fonts used to render each portion of the text.</source>
          <target state="translated">QTextLayout :: glyphs () 또는 QTextFragment :: glyphs ()를 호출하여 생성 할 수 있습니다. 반환 된 QGlyphs 개체에는 텍스트의 각 부분을 렌더링하는 데 사용되는 실제 글꼴을 나타내는 QRawFont 개체가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="4692ad2ddde150da1d2f4b4fa28afa84fa78d8bc" translate="yes" xml:space="preserve">
          <source>It can be constructed by passing a &lt;a href=&quot;gui-changes-qt6#qfont&quot;&gt;QFont&lt;/a&gt; object to &lt;a href=&quot;qrawfont#fromFont&quot;&gt;QRawFont::fromFont&lt;/a&gt;(). The function will return a QRawFont object representing the font that will be selected as response to the &lt;a href=&quot;gui-changes-qt6#qfont&quot;&gt;QFont&lt;/a&gt; query and the selected writing system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f55802815077653d397d9c042a23f0232b6cb09" translate="yes" xml:space="preserve">
          <source>It can be constructed by passing a &lt;a href=&quot;qfont&quot;&gt;QFont&lt;/a&gt; object to &lt;a href=&quot;qrawfont#fromFont&quot;&gt;QRawFont::fromFont&lt;/a&gt;(). The function will return a &lt;a href=&quot;qrawfont&quot;&gt;QRawFont&lt;/a&gt; object representing the font that will be selected as response to the &lt;a href=&quot;qfont&quot;&gt;QFont&lt;/a&gt; query and the selected writing system.</source>
          <target state="translated">&lt;a href=&quot;qfont&quot;&gt;QRFont&lt;/a&gt; 오브젝트를 &lt;a href=&quot;qrawfont#fromFont&quot;&gt;QRawFont :: fromFont&lt;/a&gt; () 에 전달하여 구성 할 수 있습니다 . 이 함수는 &lt;a href=&quot;qfont&quot;&gt;QFont&lt;/a&gt; 조회 및 선택된 쓰기 시스템에 대한 응답으로 선택 될 글꼴을 나타내는 &lt;a href=&quot;qrawfont&quot;&gt;QRawFont&lt;/a&gt; 오브젝트 를 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="103cb69908003d1d236f6ca9a8e5c72f419375f0" translate="yes" xml:space="preserve">
          <source>It can be constructed by passing a &lt;a href=&quot;qfont&quot;&gt;QFont&lt;/a&gt; object to &lt;a href=&quot;qrawfont#fromFont&quot;&gt;QRawFont::fromFont&lt;/a&gt;(). The function will return a QRawFont object representing the font that will be selected as response to the &lt;a href=&quot;qfont&quot;&gt;QFont&lt;/a&gt; query and the selected writing system.</source>
          <target state="translated">&lt;a href=&quot;qfont&quot;&gt;QFont&lt;/a&gt; 객체를 &lt;a href=&quot;qrawfont#fromFont&quot;&gt;QRawFont :: fromFont&lt;/a&gt; () 에 전달하여 구성 할 수 있습니다 . 이 함수는 &lt;a href=&quot;qfont&quot;&gt;QFont&lt;/a&gt; 쿼리 및 선택한 쓰기 시스템에 대한 응답으로 선택 될 글꼴을 나타내는 QRawFont 개체를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="65bdde1c55c3f6482b8a9f3379aedf34642cdcb9" translate="yes" xml:space="preserve">
          <source>It can be constructed by passing a file name or &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; directly to the &lt;a href=&quot;qrawfont&quot;&gt;QRawFont&lt;/a&gt; constructor, or by calling &lt;a href=&quot;qrawfont#loadFromFile&quot;&gt;loadFromFile&lt;/a&gt;() or &lt;a href=&quot;qrawfont#loadFromData&quot;&gt;loadFromData&lt;/a&gt;(). In this case, the font will not be registered in &lt;a href=&quot;qfontdatabase&quot;&gt;QFontDatabase&lt;/a&gt;, and it will not be available as part of regular font selection.</source>
          <target state="translated">파일 이름 또는 &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; 를 &lt;a href=&quot;qrawfont&quot;&gt;QRawFont&lt;/a&gt; 생성자에 직접 전달 하거나 &lt;a href=&quot;qrawfont#loadFromFile&quot;&gt;loadFromFile&lt;/a&gt; () 또는 &lt;a href=&quot;qrawfont#loadFromData&quot;&gt;loadFromData&lt;/a&gt; () 를 호출 하여 구성 할 수 있습니다 . 이 경우 글꼴은 &lt;a href=&quot;qfontdatabase&quot;&gt;QFontDatabase에&lt;/a&gt; 등록 되지 않으며 일반 글꼴 선택의 일부로 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="15f9535f3d82a5d0d4af3ca867cd5a47c1bc3bf2" translate="yes" xml:space="preserve">
          <source>It can be constructed by passing a file name or &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; directly to the QRawFont constructor, or by calling &lt;a href=&quot;qrawfont#loadFromFile&quot;&gt;loadFromFile&lt;/a&gt;() or &lt;a href=&quot;qrawfont#loadFromData&quot;&gt;loadFromData&lt;/a&gt;(). In this case, the font will not be registered in &lt;a href=&quot;gui-changes-qt6#qfontdatabase&quot;&gt;QFontDatabase&lt;/a&gt;, and it will not be available as part of regular font selection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5941bf9dba673c962486b044540a334be9f5108e" translate="yes" xml:space="preserve">
          <source>It can be constructed by passing a file name or &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; directly to the QRawFont constructor, or by calling &lt;a href=&quot;qrawfont#loadFromFile&quot;&gt;loadFromFile&lt;/a&gt;() or &lt;a href=&quot;qrawfont#loadFromData&quot;&gt;loadFromData&lt;/a&gt;(). In this case, the font will not be registered in &lt;a href=&quot;qfontdatabase&quot;&gt;QFontDatabase&lt;/a&gt;, and it will not be available as part of regular font selection.</source>
          <target state="translated">파일 이름 또는 &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; 를 QRawFont 생성자에 직접 전달 하거나 &lt;a href=&quot;qrawfont#loadFromFile&quot;&gt;loadFromFile&lt;/a&gt; () 또는 &lt;a href=&quot;qrawfont#loadFromData&quot;&gt;loadFromData&lt;/a&gt; () 를 호출 하여 생성 할 수 있습니다 . 이 경우 글꼴은 &lt;a href=&quot;qfontdatabase&quot;&gt;QFontDatabase에&lt;/a&gt; 등록 되지 않으며 일반 글꼴 선택의 일부로 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3c276d80a9a30740d1706d84828ebb244e57bac4" translate="yes" xml:space="preserve">
          <source>It can be divided up into four frames:</source>
          <target state="translated">네 개의 프레임으로 나눌 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1223746ae57a94dce4395bcb2706e48ca8104c53" translate="yes" xml:space="preserve">
          <source>It can be dragged.</source>
          <target state="translated">드래그 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ac4f7dc8a0ca2d13e7045480e410b514bbb3f8c3" translate="yes" xml:space="preserve">
          <source>It can be edited.</source>
          <target state="translated">편집 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7ce4f7873a95fa64d74869a7d1cb5e87330fe9b" translate="yes" xml:space="preserve">
          <source>It can be either of the following two values:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="597be183245fc23b96ccdbcc67660b11f2a3a037" translate="yes" xml:space="preserve">
          <source>It can be made movable again, for instance in the case of flat lists without a tree structure, by calling this method. In such a scenario, it is recommended to call &lt;a href=&quot;qtreeview#rootIsDecorated-prop&quot;&gt;QTreeView::setRootIsDecorated&lt;/a&gt;(false) as well.</source>
          <target state="translated">예를 들어 트리 구조가없는 플랫 목록의 경우이 메소드를 호출하여 다시 이동 가능하게 만들 수 있습니다. 이러한 시나리오에서는 &lt;a href=&quot;qtreeview#rootIsDecorated-prop&quot;&gt;QTreeView :: setRootIsDecorated&lt;/a&gt; (false)도 호출하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="15b46fe0d86c02e525a5dde701316cbe8ee5fdbb" translate="yes" xml:space="preserve">
          <source>It can be one of:</source>
          <target state="translated">다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b7c4d914e36f712edaeb95c5553bd269c537f1e" translate="yes" xml:space="preserve">
          <source>It can be selected.</source>
          <target state="translated">선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4641348892fc6fdcd2d9cacf5ccc61a4a5320beb" translate="yes" xml:space="preserve">
          <source>It can be set directly in script, for example if a KeyProxy might forward keys to it and you desire it to look active when this happens (but without actually giving it active focus).</source>
          <target state="translated">예를 들어 KeyProxy가 키를 키로 전달할 수 있고 이런 상황이 발생했을 때 활성 상태로 보이기를 원할 경우 스크립트에 직접 설정할 수 있습니다 (실제로 활성 포커스를주지 않음).</target>
        </trans-unit>
        <trans-unit id="c41d785207e03aa1adb4dc982c51cdc3e5132b76" translate="yes" xml:space="preserve">
          <source>It can be set to any Item type, but is generally used with &lt;a href=&quot;qml-qtquick-controls-statusbar&quot;&gt;StatusBar&lt;/a&gt;.</source>
          <target state="translated">항목 유형으로 설정할 수 있지만 일반적으로 &lt;a href=&quot;qml-qtquick-controls-statusbar&quot;&gt;StatusBar&lt;/a&gt; 와 함께 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="b0784486a79a740d55a513ff81b31e808caf0bb4" translate="yes" xml:space="preserve">
          <source>It can be set to any Item type, but is generally used with &lt;a href=&quot;qml-qtquick-controls-toolbar&quot;&gt;ToolBar&lt;/a&gt;.</source>
          <target state="translated">항목 유형으로 설정할 수 있지만 일반적으로 &lt;a href=&quot;qml-qtquick-controls-toolbar&quot;&gt;ToolBar&lt;/a&gt; 와 함께 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="567670ddbd0ae3fec2006a1b13cb71bfe5ddfe36" translate="yes" xml:space="preserve">
          <source>It can be set to specify the type of audio being played when the backend supports audio roles unknown to Qt. Specifying a role allows the system to make appropriate decisions when it comes to volume, routing or post-processing.</source>
          <target state="translated">백엔드가 Qt에 알려지지 않은 오디오 역할을 지원할 때 재생되는 오디오 유형을 지정하도록 설정할 수 있습니다. 역할을 지정하면 시스템이 볼륨, 라우팅 또는 사후 처리와 관련하여 적절한 결정을 내릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="20aa4597a59e191237d3bb6e66efd962ad684236" translate="yes" xml:space="preserve">
          <source>It can be set to specify the type of audio being played, allowing the system to make appropriate decisions when it comes to volume, routing or post-processing.</source>
          <target state="translated">재생되는 오디오 유형을 지정하여 시스템이 볼륨, 라우팅 또는 사후 처리와 관련하여 적절한 결정을 내릴 수 있도록 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="283e125d8412d3960dd6a9daa6e07fb72799b119" translate="yes" xml:space="preserve">
          <source>It can be trivially modified to this legal code.</source>
          <target state="translated">이 법률 코드로 간단하게 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="99c38d3ce62724786ab29874c396ded2562633f6" translate="yes" xml:space="preserve">
          <source>It can be used as a drop target.</source>
          <target state="translated">놓기 대상으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b7a23ba4f81b7d98d9ee6935314e7bca508fcd59" translate="yes" xml:space="preserve">
          <source>It can be used for example to query the list of sample rates, supported by specific audio codec.</source>
          <target state="translated">예를 들어 특정 오디오 코덱에서 지원하는 샘플 속도 목록을 쿼리하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="183b1de3935ac771e1fd8c10f79a1d6ac954fd9c" translate="yes" xml:space="preserve">
          <source>It can be used in the following manner:</source>
          <target state="translated">다음과 같은 방식으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ead9df0c1b0575bc0d0a33bce64a5d7d3f5aebc" translate="yes" xml:space="preserve">
          <source>It can be used like so:</source>
          <target state="translated">다음과 같이 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="abd99b8b533b0aeb5722d11614f365584e6a7b43" translate="yes" xml:space="preserve">
          <source>It can be used the following way:</source>
          <target state="translated">다음과 같은 방법으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="34364e67d73845bacc0449fa4d3fc154a7472391" translate="yes" xml:space="preserve">
          <source>It can be used to check if the connection is valid and to disconnect it using &lt;a href=&quot;qobject#disconnect&quot;&gt;QObject::disconnect&lt;/a&gt;(). For a signal-functor connection without a context object, it is the only way to selectively disconnect that connection.</source>
          <target state="translated">연결이 유효한지 확인하고 &lt;a href=&quot;qobject#disconnect&quot;&gt;QObject :: disconnect&lt;/a&gt; ()를 사용하여 연결을 끊는 데 사용할 수 있습니다 . 컨텍스트 객체가없는 신호 펑터 연결의 경우 해당 연결을 선택적으로 끊을 수있는 유일한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="54a9d1ecb238e00108daf77c249d74adb8efb61e" translate="yes" xml:space="preserve">
          <source>It can be used to control some of Qt 3D's behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9c21c8b8ae4ca9d07b3563567eb8bc09c34c3fb" translate="yes" xml:space="preserve">
          <source>It can be used to define animations in a number of ways:</source>
          <target state="translated">다음과 같은 여러 가지 방법으로 애니메이션을 정의하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="74f5affc1716e1f7cc78adcc84bf9c6eeb36bca8" translate="yes" xml:space="preserve">
          <source>It can be used to get a pointer to a &lt;a href=&quot;qcamera&quot;&gt;QCamera&lt;/a&gt; object in order to integrate with C++ code.</source>
          <target state="translated">C ++ 코드와 통합하기 위해 &lt;a href=&quot;qcamera&quot;&gt;QCamera&lt;/a&gt; 객체에 대한 포인터를 얻는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="719bdd30f3a1d36fdc308c00432d38baabe88fe2" translate="yes" xml:space="preserve">
          <source>It can be used to get a pointer to a &lt;a href=&quot;qmediaplayer&quot;&gt;QMediaPlayer&lt;/a&gt; object in order to integrate with C++ code.</source>
          <target state="translated">C ++ 코드와 통합하기 위해 &lt;a href=&quot;qmediaplayer&quot;&gt;QMediaPlayer&lt;/a&gt; 객체에 대한 포인터를 얻는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2d4650be314919998feb18759663ed8063cb3544" translate="yes" xml:space="preserve">
          <source>It can be useful to create a &lt;a href=&quot;qml-qtqml-qtobject&quot;&gt;QtObject&lt;/a&gt; if you need an extremely lightweight type to enclose a set of custom properties:</source>
          <target state="translated">사용자 정의 특성 세트를 &lt;a href=&quot;qml-qtqml-qtobject&quot;&gt;묶기&lt;/a&gt; 위해 매우 가벼운 유형이 필요한 경우 QtObject 를 작성하는 것이 유용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="88a00dce10283a8040f85514bd6857c75a89340a" translate="yes" xml:space="preserve">
          <source>It can be useful to create a QtObject if you need an extremely lightweight type to enclose a set of custom properties:</source>
          <target state="translated">사용자 지정 속성 집합을 포함하기 위해 매우 가벼운 유형이 필요한 경우 QtObject를 만드는 것이 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd26f5b10ac0cd1404617fdf0d0e17928c20bd47" translate="yes" xml:space="preserve">
          <source>It can display a number in just about any size. It can display decimal, hexadecimal, octal or binary numbers. It is easy to connect to data sources using the &lt;a href=&quot;qlcdnumber#display&quot;&gt;display&lt;/a&gt;() slot, which is overloaded to take any of five argument types.</source>
          <target state="translated">거의 모든 크기의 숫자를 표시 할 수 있습니다. 10 진수, 16 진수, 8 진수 또는 2 진수를 표시 할 수 있습니다. 5 개의 인수 유형 중 하나를 사용하도록 오버로드 된 &lt;a href=&quot;qlcdnumber#display&quot;&gt;디스플레이&lt;/a&gt; () 슬롯 을 사용하여 데이터 소스에 쉽게 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="94a869f078fbe9528084e08bb53b5c677affb42e" translate="yes" xml:space="preserve">
          <source>It can display both plain and rich text. For example:</source>
          <target state="translated">일반 텍스트와 서식있는 텍스트를 모두 표시 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e999e99adeadccdcf56950f0b1cb402a39a39e9a" translate="yes" xml:space="preserve">
          <source>It can have the following values:</source>
          <target state="translated">다음과 같은 값을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="914517643dabff5989680bb0fa42b9b264191cc4" translate="yes" xml:space="preserve">
          <source>It can hold one of the following values:</source>
          <target state="translated">다음 값 중 하나를 보유 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a48b614dec16d9688e9f40140647c07c34efd10f" translate="yes" xml:space="preserve">
          <source>It can increase performance, if there are fewer objects benefiting from z-culling. In cases with little overlap it can be faster to render with the one pass technique.</source>
          <target state="translated">z-culling의 혜택을받는 개체가 더 적 으면 성능이 향상 될 수 있습니다. 겹치는 부분이 거의없는 경우 원 패스 기술로 렌더링하는 것이 더 빠를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ffa07a546f629995f6f807ec2bea525a645aa9a2" translate="yes" xml:space="preserve">
          <source>It can move any number of times between inactive and active. When an item is activated, it's visible on the screen and is considered to be the current item. An item in a &lt;a href=&quot;qml-qtquick-controls-stackview&quot;&gt;StackView&lt;/a&gt; that is not visible is not activated, even if the item is currently the top-most item in the stack. When the stack becomes visible, the item that is top-most gets activated. Likewise if the stack is then hidden, the topmost item would be deactivated. Popping the item off the top of the stack at this point would not result in further deactivation since the item is not active.</source>
          <target state="translated">비활성과 활성 사이에서 여러 번 이동할 수 있습니다. 항목이 활성화되면 화면에 표시되며 현재 항목으로 간주됩니다. 항목이 현재 스택에서 최상위 항목 인 경우에도 표시되지 않는 &lt;a href=&quot;qml-qtquick-controls-stackview&quot;&gt;StackView&lt;/a&gt; 의 항목은 활성화되지 않습니다. 스택이 표시되면 최상위 항목이 활성화됩니다. 마찬가지로 스택을 숨기면 최상위 항목이 비활성화됩니다. 이 시점에서 스택 상단에 아이템을 올려 놓으면 아이템이 활성화되어 있지 않기 때문에 더 이상 비활성화되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="85dde880d7c405d7b8dfa112e514001b6a3c40f9" translate="yes" xml:space="preserve">
          <source>It can move any number of times between inactive and active. When an item is activated, it's visible on the screen and is considered to be the current item. An item in a StackView that is not visible is not activated, even if the item is currently the top-most item in the stack. When the stack becomes visible, the item that is top-most gets activated. Likewise if the stack is then hidden, the topmost item would be deactivated. Popping the item off the top of the stack at this point would not result in further deactivation since the item is not active.</source>
          <target state="translated">비활성과 활성 사이에서 여러 번 이동할 수 있습니다. 항목이 활성화되면 화면에 표시되고 현재 항목으로 간주됩니다. 표시되지 않는 StackView의 항목은 항목이 현재 스택에서 최상위 항목 인 경우에도 활성화되지 않습니다. 스택이 표시되면 맨 위에있는 항목이 활성화됩니다. 마찬가지로 스택이 숨겨지면 최상위 항목이 비활성화됩니다. 이 시점에서 항목을 스택 맨 위에서 꺼내도 항목이 활성화되지 않았으므로 더 이상 비활성화되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="981602013db45a2004e08c5ae8649530ebe8c51e" translate="yes" xml:space="preserve">
          <source>It can often be helpful to use a &lt;a href=&quot;qml-qtquick-loader&quot;&gt;Loader&lt;/a&gt; to create a delegate that will choose different &lt;a href=&quot;qml-qtqml-component&quot;&gt;Component&lt;/a&gt;s based on the search result type.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-loader&quot;&gt;로더&lt;/a&gt; 를 사용 하여 검색 결과 유형에 따라 다른 &lt;a href=&quot;qml-qtqml-component&quot;&gt;컴포넌트&lt;/a&gt; 를 선택할 델리게이트를 작성하는 것이 도움 이 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f7169aeff3e0c406834e60dbc638bc5bc37c67fb" translate="yes" xml:space="preserve">
          <source>It can only refer to an object, or the property of an object, that is within the scope of the &lt;a href=&quot;qtqml-typesystem-objecttypes&quot;&gt;type&lt;/a&gt; within which the alias is declared.</source>
          <target state="translated">별칭이 선언 된 &lt;a href=&quot;qtqml-typesystem-objecttypes&quot;&gt;유형&lt;/a&gt; 의 범위 내에있는 개체 또는 개체의 속성 만 참조 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6be06a8058b5e30aa884f9f64e6d645bc5084f34" translate="yes" xml:space="preserve">
          <source>It can only refer to an object, or the property of an object, that is within the scope of the &lt;a href=&quot;qtqml-typesystem-objecttypes#&quot;&gt;type&lt;/a&gt; within which the alias is declared.</source>
          <target state="translated">별명을 선언 하는 &lt;a href=&quot;qtqml-typesystem-objecttypes#&quot;&gt;유형&lt;/a&gt; 의 범위 내에있는 객체 또는 객체의 속성 만 참조 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a15e0344d288486a506acea443939f47f6a52b1e" translate="yes" xml:space="preserve">
          <source>It can parse and construct URLs in both encoded and unencoded form. &lt;a href=&quot;qurl&quot;&gt;QUrl&lt;/a&gt; also has support for internationalized domain names (IDNs).</source>
          <target state="translated">인코딩 된 형식과 인코딩되지 않은 형식의 URL을 구문 분석하고 구성 할 수 있습니다. &lt;a href=&quot;qurl&quot;&gt;QUrl&lt;/a&gt; 은 국제화 된 도메인 이름 (IDN)도 지원합니다.</target>
        </trans-unit>
        <trans-unit id="bdecae37835fed6867316547b61be9c26fdb170d" translate="yes" xml:space="preserve">
          <source>It can parse and construct URLs in both encoded and unencoded form. QUrl also has support for internationalized domain names (IDNs).</source>
          <target state="translated">인코딩 된 형식과 인코딩되지 않은 형식으로 URL을 구문 분석하고 구성 할 수 있습니다. QUrl은 또한 국제화 된 도메인 이름 (IDN)을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="15549a038b624c1c82b6784f42f79754db50d35e" translate="yes" xml:space="preserve">
          <source>It cannot contain arbitrary JavaScript expressions</source>
          <target state="translated">임의의 JavaScript 표현식을 포함 할 수 없습니다</target>
        </trans-unit>
        <trans-unit id="cc53e1d1f1962e58c3ef52a28e58e16ca3116859" translate="yes" xml:space="preserve">
          <source>It cannot refer to &lt;a href=&quot;#attached-properties-and-attached-signal-handlers&quot;&gt;attached properties&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#attached-properties-and-attached-signal-handlers&quot;&gt;첨부 된 속성을&lt;/a&gt; 참조 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="77ea2e5305c539e46857b514b0dab533d5f9ff93" translate="yes" xml:space="preserve">
          <source>It cannot refer to &lt;a href=&quot;qtqml-syntax-objectattributes#attached-properties-and-attached-signal-handlers&quot;&gt;attached properties&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qtqml-syntax-objectattributes#attached-properties-and-attached-signal-handlers&quot;&gt;연결된 속성을&lt;/a&gt; 참조 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="ab4a07c82d8fd418ee2d9897679e5a862c7e2363" translate="yes" xml:space="preserve">
          <source>It cannot refer to grouped properties; the following code will not work:</source>
          <target state="translated">그룹화 된 특성을 참조 할 수 없습니다. 다음 코드는 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5d718011d690c2a7c86ffd153d8ca57c39a7c714" translate="yes" xml:space="preserve">
          <source>It cannot refer to objects declared outside of the scope of its type.</source>
          <target state="translated">유형의 범위 밖에서 선언 된 객체는 참조 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9f181c5e6450b71cfbc97fd19db7236f89d85849" translate="yes" xml:space="preserve">
          <source>It cannot refer to properties inside a hierarchy with depth 3 or greater. The following code will not work:</source>
          <target state="translated">깊이가 3 이상인 계층 구조 내부의 속성을 참조 할 수 없습니다. 다음 코드는 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="37343cc1dd236d610aa9ef34a872d732f3fdaee8" translate="yes" xml:space="preserve">
          <source>It completely defines the details of a mesh so that operations such as bounding volume computation and picking can be done on a mesh without requiring it to be rendered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c774a12f3d7b2e724a6be900e58eef99c8e867d0" translate="yes" xml:space="preserve">
          <source>It considers everything as its argument until the next \li command, until the next &lt;a href=&quot;#table-command&quot;&gt;\endtable&lt;/a&gt;, or &lt;a href=&quot;#list-command&quot;&gt;\endlist&lt;/a&gt; command. See &lt;a href=&quot;#table-command&quot;&gt;\table&lt;/a&gt; and &lt;a href=&quot;#list-command&quot;&gt;\list&lt;/a&gt; for examples.</source>
          <target state="translated">다음 \ li 명령까지, 다음 &lt;a href=&quot;#table-command&quot;&gt;\ endtable&lt;/a&gt; 또는 &lt;a href=&quot;#list-command&quot;&gt;\ endlist&lt;/a&gt; 명령 까지 모든 것을 인수로 간주 합니다. 예제는 &lt;a href=&quot;#table-command&quot;&gt;\ table&lt;/a&gt; 및 &lt;a href=&quot;#list-command&quot;&gt;\ list&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9c0605ae125e1787ca58c2a8e353c61170e45d91" translate="yes" xml:space="preserve">
          <source>It considers everything as its argument until the next \li command, until the next &lt;a href=&quot;10-qdoc-commands-tablesandlists#table-command&quot;&gt;\endtable&lt;/a&gt;, or &lt;a href=&quot;10-qdoc-commands-tablesandlists#list-command&quot;&gt;\endlist&lt;/a&gt; command. See &lt;a href=&quot;10-qdoc-commands-tablesandlists#table-command&quot;&gt;\table&lt;/a&gt; and &lt;a href=&quot;10-qdoc-commands-tablesandlists#list-command&quot;&gt;\list&lt;/a&gt; for examples.</source>
          <target state="translated">다음 \ li 명령, 다음 &lt;a href=&quot;10-qdoc-commands-tablesandlists#table-command&quot;&gt;\ endtable&lt;/a&gt; 또는 &lt;a href=&quot;10-qdoc-commands-tablesandlists#list-command&quot;&gt;\ endlist&lt;/a&gt; 명령 까지 모든 것을 인수로 간주 합니다. 예제는 &lt;a href=&quot;10-qdoc-commands-tablesandlists#table-command&quot;&gt;\ table&lt;/a&gt; 및 &lt;a href=&quot;10-qdoc-commands-tablesandlists#list-command&quot;&gt;\ list&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="683f4ad4925cca36470b681737c2063e3235bc5d" translate="yes" xml:space="preserve">
          <source>It contains a bitwise combination of the following flags:</source>
          <target state="translated">다음 플래그의 비트 조합이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="ae10595351d107e0b1100232f5c97e310d2de508" translate="yes" xml:space="preserve">
          <source>It contains a bitwise combination of:</source>
          <target state="translated">비트 조합은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d5a652170af614a432e7f5dc020bad5e3357d859" translate="yes" xml:space="preserve">
          <source>It contains a number of bits which are reserved for future use.</source>
          <target state="translated">여기에는 나중에 사용하기 위해 예약 된 여러 비트가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="de627034552374543aaf2ea3babd9803cad918ce" translate="yes" xml:space="preserve">
          <source>It contains locale specific properties for formatting data and numbers. Unless a special locale has been set, this is either the parent's locale or the default locale.</source>
          <target state="translated">데이터 및 숫자 서식에 대한 로캘 별 속성이 포함되어 있습니다. 특별한 로케일이 설정되어 있지 않으면, 이것은 부모의 로케일이거나 기본 로케일입니다.</target>
        </trans-unit>
        <trans-unit id="5b3c10267dbf61cfa55764fd16dc6da382c762e4" translate="yes" xml:space="preserve">
          <source>It contains only the bare minimum you need to get a Qt application up and running.</source>
          <target state="translated">Qt 응용 프로그램을 시작하고 실행하는 데 필요한 최소한의 내용 만 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="f81199369a996a01dfdeeb066ee12855cc07ab7c" translate="yes" xml:space="preserve">
          <source>It contains the necessary information mipmap level, layer, cube face and source URL to load at the proper place data into an OpenGL texture.</source>
          <target state="translated">적절한 장소 데이터를 OpenGL 텍스처에로드하는 데 필요한 정보 밉맵 레벨, 레이어, 큐브면 및 소스 URL이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa85f4882b7961774f9760cbe7ffa180bfd15cb1" translate="yes" xml:space="preserve">
          <source>It contains the new value.</source>
          <target state="translated">새로운 가치를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="edd740f635ad31227c41db473f259fc8dedc4a4d" translate="yes" xml:space="preserve">
          <source>It corresponds to the Wayland &lt;code&gt;ivi_surface&lt;/code&gt; interface.</source>
          <target state="translated">Wayland &lt;code&gt;ivi_surface&lt;/code&gt; 인터페이스에 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="c875677cf59aca1579db214ecccd0eb3643e0993" translate="yes" xml:space="preserve">
          <source>It corresponds to the Wayland interface &lt;code&gt;wl_shell_surface&lt;/code&gt;.</source>
          <target state="translated">Wayland 인터페이스 &lt;code&gt;wl_shell_surface&lt;/code&gt; 에 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="2d7ab84c14287c233d9637feaea440f91dca4096" translate="yes" xml:space="preserve">
          <source>It corresponds to the Wayland interface &lt;code&gt;xdg_popup&lt;/code&gt; for the unstable xdg-shell protocol v5.</source>
          <target state="translated">불안정한 &lt;code&gt;xdg_popup&lt;/code&gt; -shell 프로토콜 v5 의 Wayland 인터페이스 xdg_popup 에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="bd387a8d318380f81a010425f4cd491cb0975525" translate="yes" xml:space="preserve">
          <source>It corresponds to the Wayland interface &lt;code&gt;xdg_popup&lt;/code&gt;.</source>
          <target state="translated">Wayland 인터페이스 &lt;code&gt;xdg_popup&lt;/code&gt; 에 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="ff7f41e5d703902991079a77fc825755f23f8cb7" translate="yes" xml:space="preserve">
          <source>It corresponds to the Wayland interface &lt;code&gt;xdg_surface&lt;/code&gt; for the unstable xdg-shell protocol v5.</source>
          <target state="translated">불안정한 &lt;code&gt;xdg_surface&lt;/code&gt; -shell 프로토콜 v5 의 Wayland 인터페이스 xdg_surface 에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="598dbcff4b6c53a9810ff3dbdc8caff169832847" translate="yes" xml:space="preserve">
          <source>It corresponds to the Wayland interface &lt;code&gt;xdg_surface&lt;/code&gt;.</source>
          <target state="translated">Wayland 인터페이스 &lt;code&gt;xdg_surface&lt;/code&gt; 에 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="cba404c1dfa22997e3adf32ddbb15c441436a7c3" translate="yes" xml:space="preserve">
          <source>It corresponds to the Wayland interface &lt;code&gt;xdg_toplevel&lt;/code&gt;.</source>
          <target state="translated">Wayland 인터페이스 &lt;code&gt;xdg_toplevel&lt;/code&gt; 에 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="1c32e9c3a26fcfa5e9b6d5c829b69e32d46d37de" translate="yes" xml:space="preserve">
          <source>It corresponds to the Wayland interface &lt;code&gt;zxdg_popup_v6&lt;/code&gt;.</source>
          <target state="translated">Wayland 인터페이스 &lt;code&gt;zxdg_popup_v6&lt;/code&gt; 에 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="6b23189d3c6152b079f6976750e60b3875fca0fb" translate="yes" xml:space="preserve">
          <source>It corresponds to the Wayland interface &lt;code&gt;zxdg_surface_v6&lt;/code&gt;.</source>
          <target state="translated">Wayland 인터페이스 &lt;code&gt;zxdg_surface_v6&lt;/code&gt; 에 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="fe3eee004d263b6e6f6c423d2b674a04bf1e66be" translate="yes" xml:space="preserve">
          <source>It corresponds to the Wayland interface &lt;code&gt;zxdg_toplevel_v6&lt;/code&gt;.</source>
          <target state="translated">Wayland 인터페이스 &lt;code&gt;zxdg_toplevel_v6&lt;/code&gt; 에 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="36320ceb8b2b941fa71b9c4ac0a0e43f9f243a93" translate="yes" xml:space="preserve">
          <source>It corresponds to the Wayland interface xdg_popup.</source>
          <target state="translated">Wayland 인터페이스 xdg_popup에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="0fbad593bf3c856bca988f7afbe12181233645d8" translate="yes" xml:space="preserve">
          <source>It corresponds to the Wayland interface xdg_surface.</source>
          <target state="translated">Wayland 인터페이스 xdg_surface에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="d94960f4c8fe01717abeb64f90ea03ddea1b81aa" translate="yes" xml:space="preserve">
          <source>It could be rewritten as follows:</source>
          <target state="translated">다음과 같이 다시 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7854cbaa5b348027942941ef88093fd21cd9253b" translate="yes" xml:space="preserve">
          <source>It creates a modal file dialog with the given</source>
          <target state="translated">주어진 모달 파일 대화 상자를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="57a19ad12ba8a78de65b07b87d50a795242a17f0" translate="yes" xml:space="preserve">
          <source>It creates a new &lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt; element in the output and sets its &lt;code&gt;id&lt;/code&gt; attribute to be the &lt;code&gt;id&lt;/code&gt; attribute from an &lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt; element in the &lt;code&gt;other.html&lt;/code&gt; file.</source>
          <target state="translated">그것은 신규 작성 &lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt; 출력에서 요소와 설정 &lt;code&gt;id&lt;/code&gt; 것으로 특성을 &lt;code&gt;id&lt;/code&gt; 의 속성 &lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt; 의 요소 &lt;code&gt;other.html&lt;/code&gt; 파일.</target>
        </trans-unit>
        <trans-unit id="c5eb04a2a2d3c56f524e4c7ef9e242d2a41da1dc" translate="yes" xml:space="preserve">
          <source>It declares a copy constructor and an assignment operator in the private section, so that if you use them by mistake, the compiler will report an error.</source>
          <target state="translated">개인 섹션에 복사 생성자와 할당 연산자를 선언하므로 실수로 사용하는 경우 컴파일러에서 오류를보고합니다.</target>
        </trans-unit>
        <trans-unit id="1ba0405223d67e0e23594f2a7b087cb507bad3fd" translate="yes" xml:space="preserve">
          <source>It defines the application's look and feel, which is encapsulated in a &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt; object. This can be changed at runtime with &lt;a href=&quot;qapplication#setStyle&quot;&gt;setStyle&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt; 객체에 캡슐화 된 응용 프로그램의 모양과 느낌을 정의 합니다. &lt;a href=&quot;qapplication#setStyle&quot;&gt;setStyle&lt;/a&gt; ()을 사용 하여 런타임에 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d2753de9f070b2f00d912912c932263e0df9f2a1" translate="yes" xml:space="preserve">
          <source>It delays errors that could be found at build time to run time, slowing down the development process.</source>
          <target state="translated">빌드시 발견 될 수있는 오류를 런타임으로 지연시켜 개발 프로세스를 늦 춥니 다.</target>
        </trans-unit>
        <trans-unit id="d3ed3cb647fae1c8e09170c073f57ba28de7fd37" translate="yes" xml:space="preserve">
          <source>It does not have any properties set.</source>
          <target state="translated">속성이 설정되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3acce62e4074d338db65ec656e6177d6e55e5df6" translate="yes" xml:space="preserve">
          <source>It does not matter if you need the plugin to be statically or dynamically linked with the application.</source>
          <target state="translated">플러그인을 애플리케이션과 정적으로 또는 동적으로 링크해야하는지 여부는 중요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="04512ed337df9551c01626a7ac2b8624e38d2f75" translate="yes" xml:space="preserve">
          <source>It does not rely on the keypress events having been received by this process, which makes it possible to check the modifiers while moving a window, for instance. Note that in most cases, you should use &lt;a href=&quot;qguiapplication#keyboardModifiers&quot;&gt;keyboardModifiers&lt;/a&gt;(), which is faster and more accurate since it contains the state of the modifiers as they were when the currently processed event was received.</source>
          <target state="translated">이 프로세스가 수신 한 키 누르기 이벤트에 의존하지 않으므로 예를 들어 창을 이동하는 동안 수정자를 확인할 수 있습니다. 대부분의 경우 현재 처리 된 이벤트가 수신되었을 때의 수정 자 상태를 포함하므로 더 빠르고 정확한 &lt;a href=&quot;qguiapplication#keyboardModifiers&quot;&gt;keyboardModifiers&lt;/a&gt; () 를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="087d89232ff16315383e2516545349d303a30cef" translate="yes" xml:space="preserve">
          <source>It doesn't matter whether</source>
          <target state="translated">그것은 중요하지 않습니다</target>
        </trans-unit>
        <trans-unit id="2ecb6ebc61063bbacb9c0c026f36ad2f9b073e1a" translate="yes" xml:space="preserve">
          <source>It effectively removes the</source>
          <target state="translated">효과적으로 제거합니다</target>
        </trans-unit>
        <trans-unit id="047ff4409a40669e18bbd69be6d389bc7a2ab30d" translate="yes" xml:space="preserve">
          <source>It ensures the best visual quality with its two pass rendering technique, that enables the correct rendering of overlapping and intersecting 3D objects. It also ensures correct blending of transparent objects.</source>
          <target state="translated">겹치고 교차하는 3D 개체의 올바른 렌더링을 가능하게하는 2 단계 렌더링 기술로 최상의 시각적 품질을 보장합니다. 또한 투명 개체의 올바른 혼합을 보장합니다.</target>
        </trans-unit>
        <trans-unit id="586523dd1de61e24c38212f20a100a98c979028d" translate="yes" xml:space="preserve">
          <source>It exits if the environment variable QT_FATAL_CRITICALS is not empty.</source>
          <target state="translated">환경 변수 QT_FATAL_CRITICALS가 비어 있지 않으면 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="f6bc5ec246de23c168d2000a0c80fda9f82d05ed" translate="yes" xml:space="preserve">
          <source>It expands to &quot;constexpr&quot; if your compiler supports C++14 relaxed constant expressions, or to nothing otherwise.</source>
          <target state="translated">컴파일러가 C ++ 14 완화 상수 표현식을 지원하는 경우 &quot;constexpr&quot;로 확장되거나 다른 방법으로 확장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b14daf646ead43dc35f1beadc58b1dff95da4835" translate="yes" xml:space="preserve">
          <source>It expands to &quot;constexpr&quot; if your compiler supports that C++11 keyword, or to nothing otherwise.</source>
          <target state="translated">컴파일러가 해당 C ++ 11 키워드를 지원하는 경우 &quot;constexpr&quot;로 확장되거나 다른 방법으로 확장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c2fafd14a2a13054735b0b90fecc6b2a4c9038e5" translate="yes" xml:space="preserve">
          <source>It expands to &quot;final&quot; if your compiler supports that C++11 contextual keyword, or something non-standard if your compiler supports something close enough to the C++11 semantics, or to nothing otherwise.</source>
          <target state="translated">컴파일러가 해당 C ++ 11 컨텍스트 키워드를 지원하는 경우 &quot;최종&quot;으로 확장되거나, 컴파일러가 C ++ 11 의미에 충분히 가까운 것을 지원하거나 그렇지 않으면 표준이 아닌 것으로 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="dda4956c81f1a66f18c2382c338c70ef02f6dd00" translate="yes" xml:space="preserve">
          <source>It expands to &quot;override&quot; if your compiler supports that C++11 contextual keyword, or to nothing otherwise.</source>
          <target state="translated">컴파일러가 해당 C ++ 11 컨텍스트 키워드를 지원하는 경우 &quot;재정의&quot;로 확장되거나 다른 방법으로 확장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1328a7abac036019dc6108ffe87f51dc513b2ce6" translate="yes" xml:space="preserve">
          <source>It expands to &quot;std::move&quot; if your compiler supports that C++11 function, or to nothing otherwise.</source>
          <target state="translated">컴파일러가 C ++ 11 함수를 지원하는 경우 &quot;std :: move&quot;로 확장되거나 다른 방법으로 확장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6a22201dd0cacb85cbedd7a1f8b71bcd9312ee34" translate="yes" xml:space="preserve">
          <source>It gives &lt;a href=&quot;qaccessibleinterface#text&quot;&gt;text()&lt;/a&gt; strings that are appropriate for a generic widget.</source>
          <target state="translated">일반 위젯에 적합한 &lt;a href=&quot;qaccessibleinterface#text&quot;&gt;text ()&lt;/a&gt; 문자열을 제공 합니다 .</target>
        </trans-unit>
        <trans-unit id="baff72efa71208d9ce3bf84d42f6c7e9ad05c6dc" translate="yes" xml:space="preserve">
          <source>It handles action and methods that can be performed on all widgets.</source>
          <target state="translated">모든 위젯에서 수행 할 수있는 조치 및 메소드를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="d80eaf5aafc8276d75cb7e3929df1f695f1bbea6" translate="yes" xml:space="preserve">
          <source>It handles events, roles, and actions that are common for all &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt;s.</source>
          <target state="translated">모든 &lt;a href=&quot;qwidget&quot;&gt;QWidget에&lt;/a&gt; 공통적 인 이벤트, 역할 및 조치를 처리합니다 .</target>
        </trans-unit>
        <trans-unit id="ba503655ceb20b3e3721633f4dbfb1c3e489c1a0" translate="yes" xml:space="preserve">
          <source>It handles events, roles, and actions that are common for all &lt;a href=&quot;widgets-changes-qt6#qwidget&quot;&gt;QWidget&lt;/a&gt;s.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcfa18afa04130e35cc9bc0fdd8c0670a74b26d7" translate="yes" xml:space="preserve">
          <source>It handles the navigation of the tree and hit testing of the objects.</source>
          <target state="translated">트리 탐색 및 개체 테스트를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="25f4cfd1770b336ed72e290d4a4d907c55769643" translate="yes" xml:space="preserve">
          <source>It has a constructor, &lt;a href=&quot;qvector3d#QVector3D&quot;&gt;QVector3D::QVector3D&lt;/a&gt;(), which was documented with the following QDoc comment:</source>
          <target state="translated">&lt;a href=&quot;qvector3d#QVector3D&quot;&gt;QVector3D :: QVector3D&lt;/a&gt; () 생성자 가 있으며 다음 QDoc 주석으로 문서화되었습니다.</target>
        </trans-unit>
        <trans-unit id="307b0514246f0b2cbf6a25766fb90dbf848a8746" translate="yes" xml:space="preserve">
          <source>It has no effect if this &lt;a href=&quot;qwaylandview&quot;&gt;QWaylandView&lt;/a&gt; is not holding any &lt;a href=&quot;qwaylandsurface&quot;&gt;QWaylandSurface&lt;/a&gt;</source>
          <target state="translated">이 경우는 효과가 없습니다 &lt;a href=&quot;qwaylandview&quot;&gt;QWaylandView는&lt;/a&gt; 어떤 유지되지 &lt;a href=&quot;qwaylandsurface&quot;&gt;QWaylandSurface을&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c9214a064597d998360157e3eb1ad171cc63c9dc" translate="yes" xml:space="preserve">
          <source>It has properties to restrict the range of dragging, rotation, and zoom.</source>
          <target state="translated">드래그, 회전 및 확대 / 축소 범위를 제한하는 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="cbb147382f18634242fec28ddac23ed6d1bd30b3" translate="yes" xml:space="preserve">
          <source>It has properties to restrict the range of dragging.</source>
          <target state="translated">드래그 범위를 제한하는 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b0da96ecf616499fd95fd33ebc5ffa269b4740bb" translate="yes" xml:space="preserve">
          <source>It holds the &lt;a href=&quot;qstyleoptiongroupbox#lineWidth-var&quot;&gt;lineWidth&lt;/a&gt; and the &lt;a href=&quot;qstyleoptiongroupbox#midLineWidth-var&quot;&gt;midLineWidth&lt;/a&gt; for drawing the panel, the group box's &lt;a href=&quot;qstyleoptiongroupbox#text-var&quot;&gt;title&lt;/a&gt; and the title's &lt;a href=&quot;qstyleoptiongroupbox#textAlignment-var&quot;&gt;alignment&lt;/a&gt; and &lt;a href=&quot;qstyleoptiongroupbox#textColor-var&quot;&gt;color&lt;/a&gt;.</source>
          <target state="translated">그것은 보유 &lt;a href=&quot;qstyleoptiongroupbox#lineWidth-var&quot;&gt;선폭&lt;/a&gt; 과 &lt;a href=&quot;qstyleoptiongroupbox#midLineWidth-var&quot;&gt;midLineWidth를&lt;/a&gt; 패널, 그룹 상자의 그림에 대한 &lt;a href=&quot;qstyleoptiongroupbox#text-var&quot;&gt;제목&lt;/a&gt; 과 제목의 &lt;a href=&quot;qstyleoptiongroupbox#textAlignment-var&quot;&gt;정렬&lt;/a&gt; 및 &lt;a href=&quot;qstyleoptiongroupbox#textColor-var&quot;&gt;색상을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="17e69d5003726c1bac53e6cedac2584d9d7f9050" translate="yes" xml:space="preserve">
          <source>It indicates that the current menu item is a submenu.</source>
          <target state="translated">현재 메뉴 항목이 하위 메뉴임을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="8e093bfc6d78e1e1547c0a049f6e522be5305702" translate="yes" xml:space="preserve">
          <source>It initializes the application with the user's desktop settings such as &lt;a href=&quot;qapplication#palette&quot;&gt;palette&lt;/a&gt;(), &lt;a href=&quot;qapplication#font&quot;&gt;font&lt;/a&gt;() and &lt;a href=&quot;qapplication#doubleClickInterval-prop&quot;&gt;doubleClickInterval&lt;/a&gt;(). It keeps track of these properties in case the user changes the desktop globally, for example through some kind of control panel.</source>
          <target state="translated">&lt;a href=&quot;qapplication#palette&quot;&gt;팔레트&lt;/a&gt; (), &lt;a href=&quot;qapplication#font&quot;&gt;글꼴&lt;/a&gt; () 및 &lt;a href=&quot;qapplication#doubleClickInterval-prop&quot;&gt;doubleClickInterval&lt;/a&gt; () 과 같은 사용자의 데스크탑 설정으로 응용 프로그램을 초기화합니다 . 사용자가 일종의 제어판을 통해 데스크톱을 전체적으로 변경하는 경우 이러한 속성을 추적합니다.</target>
        </trans-unit>
        <trans-unit id="717fbf1f2896e6f5e2110800645fa1bf23a79870" translate="yes" xml:space="preserve">
          <source>It initializes the application with the user's desktop settings, such as &lt;a href=&quot;qguiapplication#palette&quot;&gt;palette&lt;/a&gt;(), &lt;a href=&quot;qguiapplication#font&quot;&gt;font&lt;/a&gt;() and &lt;a href=&quot;qguiapplication#styleHints&quot;&gt;styleHints&lt;/a&gt;(). It keeps track of these properties in case the user changes the desktop globally, for example, through some kind of control panel.</source>
          <target state="translated">&lt;a href=&quot;qguiapplication#palette&quot;&gt;팔레트&lt;/a&gt; (), &lt;a href=&quot;qguiapplication#font&quot;&gt;글꼴&lt;/a&gt; () 및 &lt;a href=&quot;qguiapplication#styleHints&quot;&gt;styleHints&lt;/a&gt; 와 같은 사용자의 데스크탑 설정으로 응용 프로그램을 초기화합니다. () . 사용자가 일종의 제어판을 통해 데스크톱을 전체적으로 변경하는 경우 이러한 속성을 추적합니다.</target>
        </trans-unit>
        <trans-unit id="cc35ae00f82715e9ddbda13ce7420db3ff6b1ea4" translate="yes" xml:space="preserve">
          <source>It interferes with tooling; Qt Quick Designer, for example, doesn't support JavaScript.</source>
          <target state="translated">툴링을 방해합니다. 예를 들어 Qt Quick Designer는 JavaScript를 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="158bb68a636b8a4bf14d764de8e18bcbcf4514ba" translate="yes" xml:space="preserve">
          <source>It is &lt;code&gt;true&lt;/code&gt; if the state machine has been initialized, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">그것은이다 &lt;code&gt;true&lt;/code&gt; 상태 머신이 초기화 된 경우 &lt;code&gt;false&lt;/code&gt; 이 없습니다.</target>
        </trans-unit>
        <trans-unit id="7b828861f1e5c605a6da8279a9400c9e8ecb0aea" translate="yes" xml:space="preserve">
          <source>It is NOT recommended to use this as creating each printer instance may take a long time, especially if there are remote networked printers, and retained instances may become outdated if changes are made on the local system or remote print server. Use &lt;a href=&quot;qprinterinfo#availablePrinterNames&quot;&gt;availablePrinterNames&lt;/a&gt;() instead and only instantiate printer instances as you need them.</source>
          <target state="translated">특히 원격 네트워크 프린터가있는 경우 각 프린터 인스턴스를 만드는 데 시간이 오래 걸리고 로컬 시스템이나 원격 인쇄 서버에서 변경 한 경우 보유 인스턴스가 오래 될 수 있으므로이 방법을 사용하지 않는 것이 좋습니다. 사용 &lt;a href=&quot;qprinterinfo#availablePrinterNames&quot;&gt;availablePrinterNames는&lt;/a&gt; () 당신이 그들을 대신 만 인스턴스화 프린터 인스턴스를 필요로한다.</target>
        </trans-unit>
        <trans-unit id="7df1f5b7578eddafecf13d4c19140bcb447b6512" translate="yes" xml:space="preserve">
          <source>It is Qt's widgets that are styled. Some widgets do not exist at all in Java, e.g., &lt;a href=&quot;qtoolbox&quot;&gt;QToolBox&lt;/a&gt;. Others contain elements that the Java widgets don't. The tree widget is an example of the latter in which Java's JTree does not have a header.</source>
          <target state="translated">스타일이 지정된 것은 Qt의 위젯입니다. &lt;a href=&quot;qtoolbox&quot;&gt;QToolBox&lt;/a&gt; 와 같은 일부 위젯은 Java에 전혀 존재하지 않습니다 . 다른 것들은 자바 위젯이 가지고 있지 않은 요소를 포함합니다. 트리 위젯은 자바의 JTree에 헤더가없는 후자의 예입니다.</target>
        </trans-unit>
        <trans-unit id="53311b03eb87fc69e7b003cf8cf53b87468551a2" translate="yes" xml:space="preserve">
          <source>It is a common pattern to enable or disable the groupbox's children when its checkbox is toggled on or off, but it is up to the application to decide on the behavior of the checkbox.</source>
          <target state="translated">확인란을 설정하거나 해제 할 때 그룹 상자의 자식을 활성화 또는 비활성화하는 일반적인 패턴이지만 확인란의 동작을 결정하는 것은 응용 프로그램에 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c366d914eed1e83aca437a132691aaafb5dedf8" translate="yes" xml:space="preserve">
          <source>It is a message-based protocol, designed originally for multiplex electrical wiring within automobiles, but is also used in many other contexts.</source>
          <target state="translated">이 프로토콜은 원래 자동차의 다중 전기 배선을 위해 설계된 메시지 기반 프로토콜이지만 다른 많은 상황에서도 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0171709e02ae0c22857b4d42663d7c67cc52da9c" translate="yes" xml:space="preserve">
          <source>It is a read-only property.</source>
          <target state="translated">읽기 전용 속성입니다.</target>
        </trans-unit>
        <trans-unit id="e887987ed98ce584e83214e2953e3ab76cc9f524" translate="yes" xml:space="preserve">
          <source>It is a separate import in order to allow you to have a QML environment without access to window system features.</source>
          <target state="translated">창 시스템 기능에 액세스하지 않고 QML 환경을 가질 수 있도록하기 위해 별도의 가져 오기입니다.</target>
        </trans-unit>
        <trans-unit id="b57b97b79872693313dda786ba76fe317ebb8643" translate="yes" xml:space="preserve">
          <source>It is a waste of time to make a separate &lt;code&gt;.qdocinc&lt;/code&gt; file for every QDoc include snippet you want to use in multiple places in the documentation, especially given that you probably have to put the copyright/license notice in every one of these files. So if you have a large number of snippets to be included, you can put them all in a single file if you want, and surround each one with:</source>
          <target state="translated">문서의 여러 위치에서 사용하려는 모든 QDoc 포함 코드 조각마다 별도의 &lt;code&gt;.qdocinc&lt;/code&gt; 파일 을 만드는 것은 시간 낭비입니다 . 특히 이러한 파일 중 하나에 모두 저작권 / 라이센스 통지를해야하는 경우가 있습니다. 따라서 많은 수의 스 니펫을 포함하는 경우 원하는 경우 모두 단일 파일에 배치하고 각 파일을 다음과 같이 둘러 쌀 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5fc3a96f6a0375330fce259bb6e8266d9ab1a963" translate="yes" xml:space="preserve">
          <source>It is advisable to replace the generated Info.plist with your own copy, to prevent it from being overwritten the next time qmake is run. You can define a custom information property list with &lt;a href=&quot;qmake-variable-reference#qmake-info-plist&quot;&gt;QMAKE_INFO_PLIST&lt;/a&gt; variable in your .pro file.</source>
          <target state="translated">다음에 qmake가 실행될 때 겹쳐 쓰지 않도록 생성 된 Info.plist를 사용자 고유의 사본으로 바꾸는 것이 좋습니다. .pro 파일에서 &lt;a href=&quot;qmake-variable-reference#qmake-info-plist&quot;&gt;QMAKE_INFO_PLIST&lt;/a&gt; 변수를 사용하여 사용자 정의 정보 특성 목록을 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0ab78b2f6648de89b1fd8c1b15e2d603939a795b" translate="yes" xml:space="preserve">
          <source>It is almost always incorrect to use the Synchronous incubation mode - elements or components that want the appearance of synchronous instantiation, but without the downsides of introducing freezes or stutters into the application, should use the &lt;a href=&quot;qqmlincubator#IncubationMode-enum&quot;&gt;AsynchronousIfNested&lt;/a&gt; incubation mode.</source>
          <target state="translated">동기식 인큐베이션 모드를 사용하는 동기식 인큐베이션 모드를 사용하는 것은 거의 항상 올바르지 않습니다. 그러나 애플리케이션에 정지 또는 스 터터를 도입하는 단점이없는 경우 &lt;a href=&quot;qqmlincubator#IncubationMode-enum&quot;&gt;AsynchronousIfNested&lt;/a&gt; 인큐베이션 모드를 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="f6162530598b07fc079d3bcc5b5a68ee86304e4b" translate="yes" xml:space="preserve">
          <source>It is almost never necessary to explicitly grab the keyboard in Qt, as Qt grabs and releases it sensibly. In particular, Qt grabs the keyboard when your item gains input focus, and releases it when your item loses input focus, or when the item is hidden.</source>
          <target state="translated">Qt가 키보드를 눈에 띄게 잡고 떼기 때문에 Qt에서 키보드를 명시 적으로 잡을 필요는 거의 없습니다. 특히 Qt는 항목에 입력 포커스가있을 때 키보드를 잡고 항목에 입력 포커스가 없어지거나 항목이 숨겨지면 키보드를 놓습니다.</target>
        </trans-unit>
        <trans-unit id="dd769466237fe77c02badbed366dc136951dcd80" translate="yes" xml:space="preserve">
          <source>It is almost never necessary to explicitly grab the mouse in Qt, as Qt grabs and releases it sensibly. In particular, Qt grabs the mouse when you press a mouse button, and keeps the mouse grabbed until you release the last mouse button. Also, &lt;a href=&quot;qt#WindowType-enum&quot;&gt;Qt::Popup&lt;/a&gt; widgets implicitly call grabMouse() when shown, and &lt;a href=&quot;qgraphicsitem#ungrabMouse&quot;&gt;ungrabMouse&lt;/a&gt;() when hidden.</source>
          <target state="translated">Qt가 마우스를 현명하게 잡을 때 마우스를 명시 적으로 잡을 필요는 없습니다. 특히, Qt는 마우스 버튼을 누를 때 마우스를 잡고 마지막 마우스 버튼을 놓을 때까지 마우스를 잡고 있습니다. 또한, &lt;a href=&quot;qt#WindowType-enum&quot;&gt;Qt는 :: 팝업&lt;/a&gt; 위젯은 암시 적으로 () 표시 할 때, 그리고 grabMouse 전화 &lt;a href=&quot;qgraphicsitem#ungrabMouse&quot;&gt;ungrabMouse&lt;/a&gt; ()을 숨겨 때.</target>
        </trans-unit>
        <trans-unit id="b2df1664baf4040632633d516e44021a5edfd104" translate="yes" xml:space="preserve">
          <source>It is almost never necessary to grab the mouse when using Qt, as Qt grabs and releases it sensibly. In particular, Qt grabs the mouse when a mouse button is pressed and keeps it until the last button is released.</source>
          <target state="translated">Qt를 사용할 때 마우스를 잡을 필요가 거의 없습니다. Qt는 마우스를 잡아서 현명하게 놓습니다. 특히 Qt는 마우스 버튼을 누를 때 마우스를 잡고 마지막 버튼을 놓을 때까지 마우스를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="06ce74bdab3c79e72b4e802b67e9c64c594e19e7" translate="yes" xml:space="preserve">
          <source>It is also called when the &lt;code&gt;onbeforeunload&lt;/code&gt; handler is requesting a confirmation before leaving a page.</source>
          <target state="translated">&lt;code&gt;onbeforeunload&lt;/code&gt; 핸들러가 페이지를 떠나기 전에 확인을 요청하는 경우에도 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="918ea64a9cf288952cbe6d10d8635b8b1c17045a" translate="yes" xml:space="preserve">
          <source>It is also necessary to ensure that the plugin is installed together with other</source>
          <target state="translated">플러그인이 다른 플러그인과 함께 설치되어 있는지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="155ddbe7f7b65b7350a23fd9c290a80d5901ad04" translate="yes" xml:space="preserve">
          <source>It is also possible to access a newly created object by using returned reference:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fa8e5d351235b93e4f5f477a53bb4c35645c672" translate="yes" xml:space="preserve">
          <source>It is also possible to add offsets to this rectangle's coordinates using the &lt;a href=&quot;qrect#adjust&quot;&gt;adjust&lt;/a&gt;() function, as well as retrieve a new rectangle based on adjustments of the original one using the &lt;a href=&quot;qrect#adjusted&quot;&gt;adjusted&lt;/a&gt;() function. If either of the width and height is negative, use the &lt;a href=&quot;qrect#normalized&quot;&gt;normalized&lt;/a&gt;() function to retrieve a rectangle where the corners are swapped.</source>
          <target state="translated">사용하여이 사각형의 좌표에 오프셋을 추가 할 수도 있습니다 &lt;a href=&quot;qrect#adjust&quot;&gt;조정&lt;/a&gt; 뿐만 아니라 사용하여 원래의 조정에 따라 새로운 사각형 검색으로, () 함수를 &lt;a href=&quot;qrect#adjusted&quot;&gt;조정&lt;/a&gt; () 함수를. 너비와 높이 중 하나가 음수이면 &lt;a href=&quot;qrect#normalized&quot;&gt;normalized&lt;/a&gt; () 함수를 사용 하여 모서리가 바뀌는 사각형을 검색하십시오.</target>
        </trans-unit>
        <trans-unit id="76ab689eeb38675ef6811fdf610699d3746a2391" translate="yes" xml:space="preserve">
          <source>It is also possible to add offsets to this rectangle's coordinates using the &lt;a href=&quot;qrectf#adjust&quot;&gt;adjust&lt;/a&gt;() function, as well as retrieve a new rectangle based on adjustments of the original one using the &lt;a href=&quot;qrectf#adjusted&quot;&gt;adjusted&lt;/a&gt;() function. If either of the width and height is negative, use the &lt;a href=&quot;qrectf#normalized&quot;&gt;normalized&lt;/a&gt;() function to retrieve a rectangle where the corners are swapped.</source>
          <target state="translated">사용하여이 사각형의 좌표에 오프셋을 추가 할 수도 있습니다 &lt;a href=&quot;qrectf#adjust&quot;&gt;조정&lt;/a&gt; 뿐만 아니라 사용하여 원래의 조정에 따라 새로운 사각형 검색으로, () 함수를 &lt;a href=&quot;qrectf#adjusted&quot;&gt;조정&lt;/a&gt; () 함수를. 너비와 높이 중 하나가 음수이면 &lt;a href=&quot;qrectf#normalized&quot;&gt;normalized&lt;/a&gt; () 함수를 사용 하여 모서리가 바뀌는 사각형을 검색하십시오.</target>
        </trans-unit>
        <trans-unit id="3c0258ee76afc53147ecf9674ffe18781ac56e3d" translate="yes" xml:space="preserve">
          <source>It is also possible to catch the thrown error in JavaScript:</source>
          <target state="translated">JavaScript에서 발생 된 오류를 잡을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7f83c18da726a02f0a45f554f22cea88b3dda83" translate="yes" xml:space="preserve">
          <source>It is also possible to center the popup in the window by using &lt;a href=&quot;qml-qtquick-controls2-overlay&quot;&gt;Overlay&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-controls2-overlay&quot;&gt;오버레이&lt;/a&gt; 를 사용하여 팝업을 창 중앙에 배치 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f05fc3d02e6ce632c08e021186ca19c5eaa6fee9" translate="yes" xml:space="preserve">
          <source>It is also possible to combine multiple layered items:</source>
          <target state="translated">여러 계층화 된 항목을 결합 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="da60f9f75fea34148c723e1ab6663fd7d1515299" translate="yes" xml:space="preserve">
          <source>It is also possible to create your own static plugins, by following these steps:</source>
          <target state="translated">다음 단계에 따라 고유 한 정적 플러그인을 작성할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="85560b2f5fcb03e979c1aaf83df3ae175a24e258" translate="yes" xml:space="preserve">
          <source>It is also possible to define where the 3D scene is rendered to using the &lt;a href=&quot;qml-qtquick3d-view3d#renderMode-prop&quot;&gt;renderMode&lt;/a&gt; property. This can be necessary for performance reasons on certain platforms where it is expensive to render to intermediate offscreen surfaces. There are certain tradeoffs to rendering directly to the window though, so this is not the default.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick3d-view3d#renderMode-prop&quot;&gt;renderMode&lt;/a&gt; 속성 을 사용하여 3D 장면이 렌더링되는 위치를 정의 할 수도 있습니다 . 중간 오프 스크린 표면으로 렌더링하는 데 비용이 많이 드는 특정 플랫폼에서 성능상의 이유로 필요할 수 있습니다. 하지만 창에 직접 렌더링하는 데는 특정 장단점이 있으므로 이것이 기본값이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="01ea410c8f2f3af9ebac97523455059a19e3b3d2" translate="yes" xml:space="preserve">
          <source>It is also possible to determine if a routing waypoint has been passed by checking if &lt;a href=&quot;qgeomaneuver#waypoint&quot;&gt;waypoint&lt;/a&gt;() returns a valid &lt;a href=&quot;qgeocoordinate&quot;&gt;QGeoCoordinate&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qgeomaneuver#waypoint&quot;&gt;waypoint&lt;/a&gt; ()가 유효한 &lt;a href=&quot;qgeocoordinate&quot;&gt;QGeoCoordinate를&lt;/a&gt; 반환 하는지 확인하여 라우팅 웨이 포인트가 전달되었는지 확인할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2d123453692ee09be2ba1797b38df57e086d1580" translate="yes" xml:space="preserve">
          <source>It is also possible to disable support for these libraries by using &lt;code&gt;-no&lt;/code&gt; instead of &lt;code&gt;-qt&lt;/code&gt;. For example, to use the system's xcb library and disable zlib support, enter the following:</source>
          <target state="translated">&lt;code&gt;-qt&lt;/code&gt; 대신 &lt;code&gt;-no&lt;/code&gt; 를 사용하여 이러한 라이브러리에 대한 지원을 비활성화 할 수도 있습니다 . 예를 들어, 시스템의 xcb 라이브러리를 사용하고 zlib 지원을 사용하지 않으려면 다음을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="9abce1fa8fc7a1fc26c050273f4e7b5515c5d54a" translate="yes" xml:space="preserve">
          <source>It is also possible to draw 2D graphics onto a &lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt; subclass using &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;qpainter&quot;&gt;QPainter를&lt;/a&gt; 사용하여 &lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt; 서브 클래스 에 2D 그래픽을 그릴 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0db1ab3ef7f7305078525cb4316a59cb36ea0254" translate="yes" xml:space="preserve">
          <source>It is also possible to draw 2D graphics onto a QOpenGLWidget subclass using &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;qpainter&quot;&gt;QPainter를&lt;/a&gt; 사용하여 2D 그래픽을 QOpenGLWidget 서브 클래스에 그릴 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0c6460f2cd7fac16bb0d947b87f6eeebad0b3c48" translate="yes" xml:space="preserve">
          <source>It is also possible to drop Widgets onto the &lt;a href=&quot;#the-object-inspector&quot;&gt;Object Inspector&lt;/a&gt; to handle nested layouts easily.</source>
          <target state="translated">중첩 된 레이아웃을 쉽게 처리하기 위해 위젯을 &lt;a href=&quot;#the-object-inspector&quot;&gt;Object Inspector&lt;/a&gt; 에 놓을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="3b27a785548474f0c2ce8719e3a24b3a037abe32" translate="yes" xml:space="preserve">
          <source>It is also possible to drop Widgets onto the &lt;a href=&quot;designer-widget-mode#the-object-inspector&quot;&gt;Object Inspector&lt;/a&gt; to handle nested layouts easily.</source>
          <target state="translated">중첩 된 레이아웃을 쉽게 처리하기 위해 위젯을 &lt;a href=&quot;designer-widget-mode#the-object-inspector&quot;&gt;Object Inspector&lt;/a&gt; 에 놓을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="372ccf2f52e9e48053a626b1e2385c2a6686cacc" translate="yes" xml:space="preserve">
          <source>It is also possible to filter</source>
          <target state="translated">필터링도 가능합니다</target>
        </trans-unit>
        <trans-unit id="8da27e376350611d95285d11a6f675949b019ca7" translate="yes" xml:space="preserve">
          <source>It is also possible to filter out certain types of node by passing certain &lt;a href=&quot;qtreewidgetitemiterator#IteratorFlag-enum&quot;&gt;flags&lt;/a&gt; to the constructor of &lt;a href=&quot;qtreewidgetitemiterator&quot;&gt;QTreeWidgetItemIterator&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qtreewidgetitemiterator&quot;&gt;QTreeWidgetItemIterator&lt;/a&gt; 의 생성자에 특정 &lt;a href=&quot;qtreewidgetitemiterator#IteratorFlag-enum&quot;&gt;플래그&lt;/a&gt; 를 전달하여 특정 유형의 노드를 필터링 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b87e13aec474787050e0d33d1144b87663358e2e" translate="yes" xml:space="preserve">
          <source>It is also possible to filter out certain types of node by passing certain &lt;a href=&quot;qtreewidgetitemiterator#IteratorFlag-enum&quot;&gt;flags&lt;/a&gt; to the constructor of QTreeWidgetItemIterator.</source>
          <target state="translated">특정 &lt;a href=&quot;qtreewidgetitemiterator#IteratorFlag-enum&quot;&gt;플래그&lt;/a&gt; 를 QTreeWidgetItemIterator의 생성자 에 전달하여 특정 유형의 노드를 필터링 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2a9cd6da091425f9c298c19e22f1b534444b3edf" translate="yes" xml:space="preserve">
          <source>It is also possible to get a shared pointer from an object outside of the class itself. This is especially useful in code that provides an interface to scripts, where it is currently not possible to use shared pointers. For example:</source>
          <target state="translated">클래스 외부의 객체에서 공유 포인터를 얻는 것도 가능합니다. 이것은 스크립트에 대한 인터페이스를 제공하는 코드에서 특히 유용하며, 현재 공유 포인터를 사용할 수 없습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c22c2d95f1becf636e9f75f0652c72ad6f10b783" translate="yes" xml:space="preserve">
          <source>It is also possible to have QML singleton types registered without using the &lt;a href=&quot;qqmlengine#qmlRegisterSingletonType&quot;&gt;qmlRegisterSingletonType&lt;/a&gt; function. That can be done by adding a pragma Singleton statement among the imports of the type's QML file. In addition the type must be defined in a qmldir file with a singleton keyword and the qmldir must be imported by the QML files using the singleton.</source>
          <target state="translated">&lt;a href=&quot;qqmlengine#qmlRegisterSingletonType&quot;&gt;qmlRegisterSingletonType&lt;/a&gt; 함수 를 사용하지 않고 QML 싱글 톤 유형을 등록 할 수도 있습니다. 형식의 QML 파일을 가져 오는 중에 pragma Singleton 문을 추가하면됩니다. 또한 단일 유형 키워드를 사용하여 qmldir 파일에 유형을 정의해야하며 단일 유형을 사용하여 QML 파일에서 qmldir을 가져와야합니다.</target>
        </trans-unit>
        <trans-unit id="b7ecc1d1aa9c93a3ecc2108eb6d4372535567c13" translate="yes" xml:space="preserve">
          <source>It is also possible to have QML singleton types registered without using the qmlRegisterSingletonType function. That can be done by adding a pragma Singleton statement among the imports of the type's QML file. In addition the type must be defined in a qmldir file with a singleton keyword and the qmldir must be imported by the QML files using the singleton.</source>
          <target state="translated">qmlRegisterSingletonType 함수를 사용하지 않고 QML 싱글 톤 유형을 등록 할 수도 있습니다. 이는 유형의 QML 파일 가져 오기 사이에 pragma Singleton 문을 추가하여 수행 할 수 있습니다. 또한 유형은 싱글 톤 키워드를 사용하여 qmldir 파일에 정의되어야하며 qmldir은 싱글 톤을 사용하는 QML 파일에서 가져와야합니다.</target>
        </trans-unit>
        <trans-unit id="a2431e2de322561aaeda2e9041d6f8bfcc2bc519" translate="yes" xml:space="preserve">
          <source>It is also possible to initialize the object from a file, e.g.</source>
          <target state="translated">예를 들어 파일에서 객체를 초기화 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="53ba905de9a0210b2bd577c0b528cab818142a66" translate="yes" xml:space="preserve">
          <source>It is also possible to instantiate components without blocking via the &lt;a href=&quot;qml-qtqml-component#incubateObject-method&quot;&gt;incubateObject()&lt;/a&gt; function.</source>
          <target state="translated">&lt;a href=&quot;qml-qtqml-component#incubateObject-method&quot;&gt;incubateObject ()&lt;/a&gt; 함수 를 통해 차단하지 않고 구성 요소를 인스턴스화 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="97666956bf09a62e9c16aac8198a6e45fb3e3d9e" translate="yes" xml:space="preserve">
          <source>It is also possible to manually enable dependencies on Qt libraries by opening the &lt;b&gt;Run&lt;/b&gt; settings of your project, expanding &lt;b&gt;Package configurations&lt;/b&gt; and selecting the &lt;b&gt;Libraries&lt;/b&gt; tab. Manually check the libraries that are dependencies of your project.</source>
          <target state="translated">프로젝트 의 &lt;b&gt;실행&lt;/b&gt; 설정을 열고 &lt;b&gt;패키지 구성을&lt;/b&gt; 확장 하고 &lt;b&gt;라이브러리&lt;/b&gt; 탭을 선택하여 Qt 라이브러리에 대한 종속성을 수동으로 활성화 할 수도 있습니다 . 프로젝트의 종속성 인 라이브러리를 수동으로 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="636c707658d7a99b8a61c10e5c0176e751cf341a" translate="yes" xml:space="preserve">
          <source>It is also possible to misuse &lt;a href=&quot;qcborstreamwriter&quot;&gt;QCborStreamWriter&lt;/a&gt; and produce invalid CBOR streams that will fail to be decoded by a receiver. The following actions will produce invalid streams:</source>
          <target state="translated">&lt;a href=&quot;qcborstreamwriter&quot;&gt;QCborStreamWriter&lt;/a&gt; 를 잘못 사용 하고 수신자가 디코딩하지 못하는 유효하지 않은 CBOR 스트림을 생성 할 수도 있습니다. 다음 조치는 유효하지 않은 스트림을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="0c69b384ae6c6b15e434fd0c9119947694c1f528" translate="yes" xml:space="preserve">
          <source>It is also possible to misuse QCborStreamWriter and produce invalid CBOR streams that will fail to be decoded by a receiver. The following actions will produce invalid streams:</source>
          <target state="translated">또한 QCborStreamWriter를 오용하여 수신자가 디코딩하지 못하는 잘못된 CBOR 스트림을 생성 할 수도 있습니다. 다음 작업은 잘못된 스트림을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="60c0bfb7deac43c8e29508d5238355ee0fb73c9c" translate="yes" xml:space="preserve">
          <source>It is also possible to modify the model's data via the delegate, as shown in the example above:</source>
          <target state="translated">위의 예와 같이 대리자를 통해 모델의 데이터를 수정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9e05499ebbd0e58be0348798001c333ad3452f2" translate="yes" xml:space="preserve">
          <source>It is also possible to override the antialiasing method used by setting the environment variable &lt;code&gt;QSG_ANTIALIASING_METHOD&lt;/code&gt; to either &lt;code&gt;vertex&lt;/code&gt; or &lt;code&gt;msaa&lt;/code&gt;.</source>
          <target state="translated">환경 변수 &lt;code&gt;QSG_ANTIALIASING_METHOD&lt;/code&gt; 를 &lt;code&gt;vertex&lt;/code&gt; 또는 &lt;code&gt;msaa&lt;/code&gt; 로 설정하여 사용되는 앤티 앨리어싱 방법을 재정의 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8a6dc3e2e2acfd6c9cd819b5f38aad533a9fa384" translate="yes" xml:space="preserve">
          <source>It is also possible to perform dynamic casts using &lt;a href=&quot;qobject#qobject_cast&quot;&gt;qobject_cast&lt;/a&gt;() on &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; classes. The &lt;a href=&quot;qobject#qobject_cast&quot;&gt;qobject_cast&lt;/a&gt;() function behaves similarly to the standard C++ &lt;code&gt;dynamic_cast()&lt;/code&gt;, with the advantages that it doesn't require RTTI support and it works across dynamic library boundaries. It attempts to cast its argument to the pointer type specified in angle-brackets, returning a non-zero pointer if the object is of the correct type (determined at run-time), or &lt;code&gt;nullptr&lt;/code&gt; if the object's type is incompatible.</source>
          <target state="translated">&lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 클래스 에서 &lt;a href=&quot;qobject#qobject_cast&quot;&gt;qobject_cast&lt;/a&gt; ()를 사용하여 동적 캐스트를 수행 할 수도 있습니다 . &lt;a href=&quot;qobject#qobject_cast&quot;&gt;qobject_cast&lt;/a&gt; 유사 표준 C ++ () 함수의 동작합니다 &lt;code&gt;dynamic_cast()&lt;/code&gt; 장점과 함께, 그것은 RTTI 지원이 필요하지 않습니다 그것은 동적 라이브러리의 경계를 넘어 작동합니다. 객체가 올바른 유형 (런타임으로 결정됨) 인 경우 0이 아닌 포인터를 반환하거나 객체 유형이 호환되지 않는 경우 &lt;code&gt;nullptr&lt;/code&gt; 을 반환하여 꺾쇠 괄호로 지정된 포인터 유형으로 인수를 캐스팅하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="bdb68f03a0442be419ce189e77451068fb01e681" translate="yes" xml:space="preserve">
          <source>It is also possible to receive a stream of debug messages from the OpenGL server</source>
          <target state="translated">OpenGL 서버에서 디버그 메시지 스트림을 수신 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d1e23d87234bd00238c49aea0177469ff52d4aa" translate="yes" xml:space="preserve">
          <source>It is also possible to reference an existing scene by using the &lt;a href=&quot;qml-qtquick3d-view3d#importScene-prop&quot;&gt;importScene&lt;/a&gt; property and setting it to the root &lt;a href=&quot;qml-qtquick3d-node&quot;&gt;Node&lt;/a&gt; of the scene you want to visualize. This &lt;a href=&quot;qml-qtquick3d-node&quot;&gt;Node&lt;/a&gt; does not have to be an ancestor of the View3D, and you can have multiple View3Ds that import the same scene.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e675e3d704952fccda2f9adfe47442a17da6d0b5" translate="yes" xml:space="preserve">
          <source>It is also possible to reference an existing scene by using the &lt;a href=&quot;qml-qtquick3d-view3d#importScene-prop&quot;&gt;importScene&lt;/a&gt; property of the scene you want to render. This scene does not have to exist as a child of the current View3D.</source>
          <target state="translated">렌더링하려는 장면 의 &lt;a href=&quot;qml-qtquick3d-view3d#importScene-prop&quot;&gt;importScene&lt;/a&gt; 속성을 사용하여 기존 장면을 참조 할 수도 있습니다 . 이 장면은 현재 View3D의 자식으로 존재할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="2889cb70240788ffb44204acb38a9a94697971df" translate="yes" xml:space="preserve">
          <source>It is also possible to run a single file using the &lt;code&gt;-input&lt;/code&gt; option. For example:</source>
          <target state="translated">&lt;code&gt;-input&lt;/code&gt; 옵션을 사용하여 단일 파일을 실행할 수도 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="db33c652c1a5643d022e7bff49e6246a7d979b19" translate="yes" xml:space="preserve">
          <source>It is also possible to set certain default properties by modifying the &lt;a href=&quot;qprinter&quot;&gt;QPrinter&lt;/a&gt; before it is supplied to the print dialog. For example, applications that generate batches of reports for printing may set up the &lt;a href=&quot;qprinter&quot;&gt;QPrinter&lt;/a&gt; to &lt;a href=&quot;qprinter#setOutputFileName&quot;&gt;write to a local file&lt;/a&gt; by default rather than to a printer.</source>
          <target state="translated">인쇄 대화 상자에 제공되기 전에 &lt;a href=&quot;qprinter&quot;&gt;QPrinter&lt;/a&gt; 를 수정하여 특정 기본 속성을 설정할 수도 있습니다 . 예를 들어, 인쇄용 일괄 보고서를 생성하는 응용 프로그램은 기본적으로 프린터가 아닌 &lt;a href=&quot;qprinter#setOutputFileName&quot;&gt;로컬 파일&lt;/a&gt; 에 쓰도록 &lt;a href=&quot;qprinter&quot;&gt;QPrinter&lt;/a&gt; 를 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2f60135b7b5eeb67132a2bbf1d8a21f6895fed4e" translate="yes" xml:space="preserve">
          <source>It is also possible to set multiple shortcut &lt;a href=&quot;qml-qtquick-shortcut#sequences-prop&quot;&gt;sequences&lt;/a&gt;, so that the shortcut can be &lt;a href=&quot;qml-qtquick-shortcut#activated-signal&quot;&gt;activated&lt;/a&gt; via several different sequences of key presses.</source>
          <target state="translated">또한 일련의 복수 단축 할 수있다 &lt;a href=&quot;qml-qtquick-shortcut#sequences-prop&quot;&gt;서열&lt;/a&gt; 단축을 할 수 있도록하는 것이, &lt;a href=&quot;qml-qtquick-shortcut#activated-signal&quot;&gt;활성화 된&lt;/a&gt; 키 누름의 시퀀스를 통해 여러.</target>
        </trans-unit>
        <trans-unit id="8526893572d2213609eb7b181c1f941c538f5115" translate="yes" xml:space="preserve">
          <source>It is also possible to set values at specified steps situated between the start and end value. The interpolation will then touch these points at the specified steps. Note that the start and end values are defined as the key values at 0.0 and 1.0.</source>
          <target state="translated">시작 값과 끝 값 사이에 위치한 지정된 단계에서 값을 설정할 수도 있습니다. 그러면 보간은 지정된 단계에서이 점들을 터치합니다. 시작 및 종료 값은 0.0 및 1.0의 키 값으로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="58907f11a7ee5b997bf4379e8c4c134194cc383a" translate="yes" xml:space="preserve">
          <source>It is also possible to show different help texts for different regions of a widget, by using a &lt;a href=&quot;qhelpevent&quot;&gt;QHelpEvent&lt;/a&gt; of type &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent::WhatsThis&lt;/a&gt;. Intercept the help event in your widget's &lt;a href=&quot;qwidget#event&quot;&gt;QWidget::event&lt;/a&gt;() function and call &lt;a href=&quot;qwhatsthis#showText&quot;&gt;QWhatsThis::showText&lt;/a&gt;() with the text you want to display for the position specified in &lt;a href=&quot;qhelpevent#pos&quot;&gt;QHelpEvent::pos&lt;/a&gt;(). If the text is rich text and the user clicks on a link, the widget also receives a &lt;a href=&quot;qwhatsthisclickedevent&quot;&gt;QWhatsThisClickedEvent&lt;/a&gt; with the link's reference as &lt;a href=&quot;qwhatsthisclickedevent#href&quot;&gt;QWhatsThisClickedEvent::href&lt;/a&gt;(). If a &lt;a href=&quot;qwhatsthisclickedevent&quot;&gt;QWhatsThisClickedEvent&lt;/a&gt; is handled (i.e. &lt;a href=&quot;qwidget#event&quot;&gt;QWidget::event&lt;/a&gt;() returns true), the help window remains visible. Call &lt;a href=&quot;qwhatsthis#hideText&quot;&gt;QWhatsThis::hideText&lt;/a&gt;() to hide it explicitly.</source>
          <target state="translated">사용하여 위젯의 다른 지역에 대한 다른 도움말 텍스트를 표시 할 수도 있습니다 &lt;a href=&quot;qhelpevent&quot;&gt;QHelpEvent&lt;/a&gt; 형의 &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent :: WhatsThis을&lt;/a&gt; . 위젯의 &lt;a href=&quot;qwidget#event&quot;&gt;QWidget :: event&lt;/a&gt; () 함수 에서 도움말 이벤트를 가로 &lt;a href=&quot;qhelpevent#pos&quot;&gt;채고 QHelpEvent :: pos&lt;/a&gt; ()에 지정된 위치에 표시하려는 텍스트로 &lt;a href=&quot;qwhatsthis#showText&quot;&gt;QWhatsThis :: showText&lt;/a&gt; ()를 호출 하십시오 . 텍스트가 서식있는 텍스트와 링크를 사용자가 클릭하면 위젯도 수신 &lt;a href=&quot;qwhatsthisclickedevent&quot;&gt;QWhatsThisClickedEvent&lt;/a&gt; 로 링크의 참조 &lt;a href=&quot;qwhatsthisclickedevent#href&quot;&gt;QWhatsThisClickedEvent :: HREF를&lt;/a&gt; (). 경우 &lt;a href=&quot;qwhatsthisclickedevent&quot;&gt;QWhatsThisClickedEvent가&lt;/a&gt; (즉, 처리 &lt;a href=&quot;qwidget#event&quot;&gt;는 QWidget :: 이벤트를&lt;/a&gt; ()가 true를 돌려), 도움말 창이 계속 표시됩니다. 요구&lt;a href=&quot;qwhatsthis#hideText&quot;&gt;QWhatsThis :: hideText&lt;/a&gt; ()를 명시 적으로 숨 깁니다.</target>
        </trans-unit>
        <trans-unit id="9244191674a5b2c04ef44b034401cddef7f9141a" translate="yes" xml:space="preserve">
          <source>It is also possible to show different tool tips for different regions of a widget, by using a &lt;a href=&quot;qhelpevent&quot;&gt;QHelpEvent&lt;/a&gt; of type &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent::ToolTip&lt;/a&gt;. Intercept the help event in your widget's &lt;a href=&quot;qwidget#event&quot;&gt;event()&lt;/a&gt; function and call &lt;a href=&quot;qtooltip#showText&quot;&gt;QToolTip::showText&lt;/a&gt;() with the text you want to display. The &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtwidgets-widgets-tooltips-example.html#&quot;&gt;Tooltips&lt;/a&gt; example illustrates this technique.</source>
          <target state="translated">사용하여 위젯의 다른 지역에 대해 서로 다른 도구 팁을 표시 할 수도 있습니다 &lt;a href=&quot;qhelpevent&quot;&gt;QHelpEvent&lt;/a&gt; 형의 &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent :: 도구 설명을&lt;/a&gt; . 위젯의 &lt;a href=&quot;qwidget#event&quot;&gt;event ()&lt;/a&gt; 함수 에서 도움말 이벤트를 가로 &lt;a href=&quot;qtooltip#showText&quot;&gt;채고&lt;/a&gt; 표시하려는 텍스트로 QToolTip :: showText ()를 호출 하십시오 . &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtwidgets-widgets-tooltips-example.html#&quot;&gt;툴팁&lt;/a&gt; 예는이 기술을 도시한다.</target>
        </trans-unit>
        <trans-unit id="08ce8ea1016fd5a72776dd0280d552e93ad757fa" translate="yes" xml:space="preserve">
          <source>It is also possible to show different tool tips for different regions of a widget, by using a &lt;a href=&quot;qhelpevent&quot;&gt;QHelpEvent&lt;/a&gt; of type &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent::ToolTip&lt;/a&gt;. Intercept the help event in your widget's &lt;a href=&quot;qwidget#event&quot;&gt;event()&lt;/a&gt; function and call &lt;a href=&quot;qtooltip#showText&quot;&gt;QToolTip::showText&lt;/a&gt;() with the text you want to display. The &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtwidgets-widgets-tooltips-example.html&quot;&gt;Tooltips&lt;/a&gt; example illustrates this technique.</source>
          <target state="translated">사용하여 위젯의 다른 지역에 대해 서로 다른 도구 팁을 표시 할 수도 있습니다 &lt;a href=&quot;qhelpevent&quot;&gt;QHelpEvent&lt;/a&gt; 형의 &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent :: 도구 설명을&lt;/a&gt; . 위젯의 &lt;a href=&quot;qwidget#event&quot;&gt;event ()&lt;/a&gt; 함수 에서 도움말 이벤트를 가로 &lt;a href=&quot;qtooltip#showText&quot;&gt;채고&lt;/a&gt; 표시 할 텍스트로 QToolTip :: showText ()를 호출 합니다. &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtwidgets-widgets-tooltips-example.html&quot;&gt;툴팁&lt;/a&gt; 예는이 기술을 도시한다.</target>
        </trans-unit>
        <trans-unit id="92c5709975f866900e185eb9695d80264d11e4c7" translate="yes" xml:space="preserve">
          <source>It is also possible to show different tool tips for different regions of a widget, by using a &lt;a href=&quot;qhelpevent&quot;&gt;QHelpEvent&lt;/a&gt; of type &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent::ToolTip&lt;/a&gt;. Intercept the help event in your widget's &lt;a href=&quot;qwidget#event&quot;&gt;event()&lt;/a&gt; function and call &lt;a href=&quot;qtooltip#showText&quot;&gt;QToolTip::showText&lt;/a&gt;() with the text you want to display. The &lt;a href=&quot;https://doc.qt.io/qt-6.0/qtwidgets-widgets-tooltips-example.html&quot;&gt;Tooltips&lt;/a&gt; example illustrates this technique.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aafeb8ce0dabc39e76808f27a313d68e37b1c960" translate="yes" xml:space="preserve">
          <source>It is also possible to simply use the result of &lt;a href=&quot;qregularexpression#globalMatch&quot;&gt;QRegularExpression::globalMatch&lt;/a&gt; in a range-based for loop, for instance like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ec11205dbe1a818a163c2297989fa3a069aca61" translate="yes" xml:space="preserve">
          <source>It is also possible to specify a member function directly, as in:</source>
          <target state="translated">다음과 같이 멤버 함수를 직접 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="6664cd8e25c3f513ffe4fe98ad9b23eb91945abc" translate="yes" xml:space="preserve">
          <source>It is also possible to specify colors like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ec061b403c31a1522bc910e5dfaf840bf338b30" translate="yes" xml:space="preserve">
          <source>It is also possible to specify start and end in a single argument, with the numbers separated by two periods.</source>
          <target state="translated">숫자를 두 개의 마침표로 구분하여 단일 인수로 시작과 끝을 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb12509294d47da34a51229bbe48ad84ad549e07" translate="yes" xml:space="preserve">
          <source>It is also possible to use &lt;a href=&quot;qabstractitemmodeltester&quot;&gt;QAbstractItemModelTester&lt;/a&gt; outside of a test case. For instance, it may be useful to test an item model used by an application without the need of building an explicit unit test for such a model (which might be challenging). In order to use &lt;a href=&quot;qabstractitemmodeltester&quot;&gt;QAbstractItemModelTester&lt;/a&gt; outside of a test case, pass one of the &lt;code&gt;QAbstractItemModelTester::FailureReportingMode&lt;/code&gt; enumerators to its constructor, therefore specifying how failures should be logged.</source>
          <target state="translated">테스트 케이스 외부에서 &lt;a href=&quot;qabstractitemmodeltester&quot;&gt;QAbstractItemModelTester&lt;/a&gt; 를 사용할 수도 있습니다 . 예를 들어, 이러한 모델에 대해 명시 적 단위 테스트를 구축 할 필요없이 애플리케이션에서 사용하는 항목 모델을 테스트하는 것이 유용 할 수 있습니다 (어려울 수 있음). 테스트 케이스 외부에서 &lt;a href=&quot;qabstractitemmodeltester&quot;&gt;QAbstractItemModelTester&lt;/a&gt; 를 사용 하려면 &lt;code&gt;QAbstractItemModelTester::FailureReportingMode&lt;/code&gt; 열거 자 중 하나를 생성자에 전달하여 실패를 기록하는 방법을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="644e2f21be422cbbf57e77faa182b8490616af02" translate="yes" xml:space="preserve">
          <source>It is also possible to use &lt;code&gt;threshold&lt;/code&gt;, &lt;code&gt;compress&lt;/code&gt;, and &lt;code&gt;compress-algo&lt;/code&gt; as attributes in a .qrc &lt;code&gt;file&lt;/code&gt; tag.</source>
          <target state="translated">.qrc &lt;code&gt;file&lt;/code&gt; 태그의 속성으로 &lt;code&gt;threshold&lt;/code&gt; , &lt;code&gt;compress&lt;/code&gt; 및 &lt;code&gt;compress-algo&lt;/code&gt; 를 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="69db22c462e4ce0290c759dbaf4418e5b30a3657" translate="yes" xml:space="preserve">
          <source>It is also possible to use QAbstractItemModelTester outside of a test case. For instance, it may be useful to test an item model used by an application without the need of building an explicit unit test for such a model (which might be challenging). In order to use QAbstractItemModelTester outside of a test case, pass one of the &lt;code&gt;QAbstractItemModelTester::FailureReportingMode&lt;/code&gt; enumerators to its constructor, therefore specifying how failures should be logged.</source>
          <target state="translated">테스트 케이스 외부에서 QAbstractItemModelTester를 사용할 수도 있습니다. 예를 들어, 그러한 모델에 대한 명시적인 단위 테스트를 구축 할 필요없이 애플리케이션에서 사용하는 항목 모델을 테스트하는 것이 유용 할 수 있습니다 (어려울 수 있음). 테스트 케이스 외부에서 QAbstractItemModelTester를 사용하려면 &lt;code&gt;QAbstractItemModelTester::FailureReportingMode&lt;/code&gt; 열거 자 중 하나를 생성자에 전달하여 실패를 기록하는 방법을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="4b32458ed1959b27d9c08f30ba65b748c3cf361d" translate="yes" xml:space="preserve">
          <source>It is also possible to use a delegate as the template for the items created by a Repeater. This is specified using the &lt;a href=&quot;qml-qtquick-repeater#delegate-prop&quot;&gt;delegate&lt;/a&gt; property.</source>
          <target state="translated">또한 Repeater가 만든 항목의 템플릿으로 대리자를 사용할 수도 있습니다. 이것은 &lt;a href=&quot;qml-qtquick-repeater#delegate-prop&quot;&gt;delegate&lt;/a&gt; 속성을 사용하여 지정 됩니다.</target>
        </trans-unit>
        <trans-unit id="53e56b30a39183fbc13875a195f9cd389ac70fd4" translate="yes" xml:space="preserve">
          <source>It is also possible to use the &lt;code&gt;on&lt;/code&gt; keyword to tie the &lt;a href=&quot;qml-qtquick-opacityanimator&quot;&gt;OpacityAnimator&lt;/a&gt; directly to an Item instance.</source>
          <target state="translated">&lt;code&gt;on&lt;/code&gt; 키워드 를 사용 하여 &lt;a href=&quot;qml-qtquick-opacityanimator&quot;&gt;OpacityAnimator&lt;/a&gt; 를 Item 인스턴스에 직접 연결할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a19848eb55088cd32ed0468f7142a5d0d05a0a1" translate="yes" xml:space="preserve">
          <source>It is also possible to use the &lt;code&gt;on&lt;/code&gt; keyword to tie the &lt;a href=&quot;qml-qtquick-rotationanimator&quot;&gt;RotationAnimator&lt;/a&gt; directly to the &lt;code&gt;rotation&lt;/code&gt; property of an Item instance.</source>
          <target state="translated">&lt;code&gt;on&lt;/code&gt; 키워드 를 사용하여 &lt;a href=&quot;qml-qtquick-rotationanimator&quot;&gt;RotationAnimator&lt;/a&gt; 를 Item 인스턴스 의 &lt;code&gt;rotation&lt;/code&gt; 속성에 직접 연결할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bdce0f3a3e277a98d60e74ce915b72408445641e" translate="yes" xml:space="preserve">
          <source>It is also possible to use the &lt;code&gt;on&lt;/code&gt; keyword to tie the &lt;a href=&quot;qml-qtquick-scaleanimator&quot;&gt;ScaleAnimator&lt;/a&gt; directly to an Item instance.</source>
          <target state="translated">&lt;code&gt;on&lt;/code&gt; 키워드 를 사용 하여 &lt;a href=&quot;qml-qtquick-scaleanimator&quot;&gt;ScaleAnimator&lt;/a&gt; 를 Item 인스턴스에 직접 연결할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c80ec327ff85447ee100d1bb71fa6dd3b2df115" translate="yes" xml:space="preserve">
          <source>It is also possible to use the &lt;code&gt;on&lt;/code&gt; keyword to tie the &lt;a href=&quot;qml-qtquick-uniformanimator&quot;&gt;UniformAnimator&lt;/a&gt; directly to a uniform of a &lt;a href=&quot;qml-qtquick-shadereffect&quot;&gt;ShaderEffect&lt;/a&gt; instance.</source>
          <target state="translated">&lt;code&gt;on&lt;/code&gt; 키워드 를 사용하여 &lt;a href=&quot;qml-qtquick-shadereffect&quot;&gt;UniformAnimator를 ShaderEffect&lt;/a&gt; 인스턴스 의 유니폼에 직접 &lt;a href=&quot;qml-qtquick-uniformanimator&quot;&gt;연결할&lt;/a&gt; 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6e01460823de575901dc6f64cd863058b7be3562" translate="yes" xml:space="preserve">
          <source>It is also possible to use the &lt;code&gt;on&lt;/code&gt; keyword to tie the &lt;a href=&quot;qml-qtquick-xanimator&quot;&gt;XAnimator&lt;/a&gt; directly to an Item instance.</source>
          <target state="translated">&lt;code&gt;on&lt;/code&gt; 키워드 를 사용 하여 &lt;a href=&quot;qml-qtquick-xanimator&quot;&gt;XAnimator&lt;/a&gt; 를 Item 인스턴스에 직접 연결할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7daa6d7f3766cd43a117a7e6e32addc079bcba4" translate="yes" xml:space="preserve">
          <source>It is also possible to use the &lt;code&gt;on&lt;/code&gt; keyword to tie the &lt;a href=&quot;qml-qtquick-yanimator&quot;&gt;YAnimator&lt;/a&gt; directly to an Item instance.</source>
          <target state="translated">&lt;code&gt;on&lt;/code&gt; 키워드 를 사용 하여 &lt;a href=&quot;qml-qtquick-yanimator&quot;&gt;YAnimator&lt;/a&gt; 를 Item 인스턴스에 직접 연결할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c5e7e541cdf0f443d70dc0d3829b04c5acba3ee" translate="yes" xml:space="preserve">
          <source>It is also possible to use the &lt;code&gt;on&lt;/code&gt; keyword to tie the OpacityAnimator directly to an Item instance.</source>
          <target state="translated">&lt;code&gt;on&lt;/code&gt; 키워드 를 사용 하여 OpacityAnimator를 Item 인스턴스에 직접 연결할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="73be3d5520cc086b4db97c4b154d00a8822b177c" translate="yes" xml:space="preserve">
          <source>It is also possible to use the &lt;code&gt;on&lt;/code&gt; keyword to tie the RotationAnimator directly to the &lt;code&gt;rotation&lt;/code&gt; property of an Item instance.</source>
          <target state="translated">&lt;code&gt;on&lt;/code&gt; 키워드 를 사용하여 RotationAnimator를 Item 인스턴스 의 &lt;code&gt;rotation&lt;/code&gt; 속성에 직접 연결할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cfc80adae4ba4c754467dde48af5e7a725df58f9" translate="yes" xml:space="preserve">
          <source>It is also possible to use the &lt;code&gt;on&lt;/code&gt; keyword to tie the ScaleAnimator directly to an Item instance.</source>
          <target state="translated">&lt;code&gt;on&lt;/code&gt; 키워드 를 사용 하여 ScaleAnimator를 Item 인스턴스에 직접 연결할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="6dc943d09e3b1215f57ac2f09f472c2396f248b1" translate="yes" xml:space="preserve">
          <source>It is also possible to use the &lt;code&gt;on&lt;/code&gt; keyword to tie the UniformAnimator directly to a uniform of a &lt;a href=&quot;qml-qtquick-shadereffect&quot;&gt;ShaderEffect&lt;/a&gt; instance.</source>
          <target state="translated">&lt;code&gt;on&lt;/code&gt; 키워드 를 사용하여 &lt;a href=&quot;qml-qtquick-shadereffect&quot;&gt;UniformAnimator를 ShaderEffect&lt;/a&gt; 인스턴스 의 유니폼에 직접 연결할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3475ff2ddf138580fb349534fad2d34d667c64c0" translate="yes" xml:space="preserve">
          <source>It is also possible to use the &lt;code&gt;on&lt;/code&gt; keyword to tie the XAnimator directly to an Item instance.</source>
          <target state="translated">&lt;code&gt;on&lt;/code&gt; 키워드 를 사용 하여 XAnimator를 Item 인스턴스에 직접 연결할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4442deaba3438771a666397591fdf6e02649589" translate="yes" xml:space="preserve">
          <source>It is also possible to use the &lt;code&gt;on&lt;/code&gt; keyword to tie the YAnimator directly to an Item instance.</source>
          <target state="translated">&lt;code&gt;on&lt;/code&gt; 키워드 를 사용 하여 YAnimator를 Item 인스턴스에 직접 연결할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="d08002d7d81f64ca972720281235b18e295dda05" translate="yes" xml:space="preserve">
          <source>It is also possible to use the built-in custom geometry provider &lt;a href=&quot;qml-qtquick3d-helpers-gridgeometry&quot;&gt;GridGeometry&lt;/a&gt; in the &lt;code&gt;Helpers&lt;/code&gt; module. The following is an example of &lt;a href=&quot;qml-qtquick3d-helpers-gridgeometry&quot;&gt;GridGeometry&lt;/a&gt;. Any application-provided Geometry subclass can be taken into use in the same manner.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ac9d329eba8527f87838828d0a8dc9a7cdde5e7" translate="yes" xml:space="preserve">
          <source>It is also possible to write custom material without using the boilerplate code, in which case the main function must be implemented in the shader.</source>
          <target state="translated">상용구 코드를 사용하지 않고 커스텀 머티리얼을 작성할 수도 있습니다.이 경우 메인 함수는 셰이더에서 구현되어야합니다.</target>
        </trans-unit>
        <trans-unit id="c5694751cea43b041f8e2a663660048fd0d27b61" translate="yes" xml:space="preserve">
          <source>It is also possible to write the custom material without the rest of the material system. In this case it is not necessary to write all the functions described above. Each pass needs a main function only.</source>
          <target state="translated">나머지 머티리얼 시스템없이 커스텀 머티리얼을 작성하는 것도 가능합니다. 이 경우 위에서 설명한 모든 함수를 작성할 필요는 없습니다. 각 패스에는 주 기능 만 필요합니다.</target>
        </trans-unit>
        <trans-unit id="70881c0db00dee2420383c49a6ca254a0f5476a4" translate="yes" xml:space="preserve">
          <source>It is also usual to use &lt;code&gt;PE_IndicatorCheckBox&lt;/code&gt; (instead of using &lt;code&gt;PE_IndicatorMenuCheckMark&lt;/code&gt;) and &lt;code&gt;PE_IndicatorRadioButton&lt;/code&gt; for drawing checkable menu items; we have not included them in the style tree as this is optional and varies from style to style.</source>
          <target state="translated">또한 사용하는 것이 일반적이다 &lt;code&gt;PE_IndicatorCheckBox&lt;/code&gt; (대신 사용하는 &lt;code&gt;PE_IndicatorMenuCheckMark&lt;/code&gt; 과) &lt;code&gt;PE_IndicatorRadioButton&lt;/code&gt; 을 체크 할 메뉴 항목을 그리기 위해; 선택 사항이며 스타일에 따라 스타일 트리에 포함하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="df5157cc775b9e7ee0e83e062447bc9ee2a95697" translate="yes" xml:space="preserve">
          <source>It is always best to cast integers to a Qt integer type, such as &lt;a href=&quot;qtglobal#qint16-typedef&quot;&gt;qint16&lt;/a&gt; or &lt;a href=&quot;qtglobal#quint32-typedef&quot;&gt;quint32&lt;/a&gt;, when reading and writing. This ensures that you always know exactly what size integers you are reading and writing, no matter what the underlying platform and architecture the application happens to be running on.</source>
          <target state="translated">읽고 쓸 때 항상 정수를 &lt;a href=&quot;qtglobal#qint16-typedef&quot;&gt;qint16&lt;/a&gt; 또는 &lt;a href=&quot;qtglobal#quint32-typedef&quot;&gt;quint32&lt;/a&gt; 와 같은 Qt 정수 유형으로 캐스트하는 것이 가장 좋습니다 . 이를 통해 응용 프로그램이 실행되는 기본 플랫폼 및 아키텍처에 관계없이 읽고 쓰는 크기의 정수를 항상 정확하게 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="10ae19d77ab28328d9e4f5073dc624a0bf2e5900" translate="yes" xml:space="preserve">
          <source>It is always safe to remove an event filter, even during event filter activation (i.e. from the &lt;a href=&quot;qobject#eventFilter&quot;&gt;eventFilter&lt;/a&gt;() function).</source>
          <target state="translated">이벤트 필터 활성화 중에도 (예 : &lt;a href=&quot;qobject#eventFilter&quot;&gt;eventFilter&lt;/a&gt; () 함수에서) 이벤트 필터를 제거하는 것이 항상 안전합니다 .</target>
        </trans-unit>
        <trans-unit id="6bf2d74636c6daefde70cc25c6232998bb8b4e25" translate="yes" xml:space="preserve">
          <source>It is always safe to remove an event filter, even during event filter activation (i.e. from the nativeEventFilter() function).</source>
          <target state="translated">이벤트 필터 활성화 중에도 (예 : nativeEventFilter () 함수에서) 이벤트 필터를 제거하는 것이 항상 안전합니다.</target>
        </trans-unit>
        <trans-unit id="56aa8a6e88ada08148ea931a197072313c54af7d" translate="yes" xml:space="preserve">
          <source>It is always safe to remove an event filter, even during event filter filter activation (that is, even from within the &lt;a href=&quot;qabstractnativeeventfilter#nativeEventFilter&quot;&gt;nativeEventFilter()&lt;/a&gt; function).</source>
          <target state="translated">이벤트 필터 필터 활성화 중에 (즉, &lt;a href=&quot;qabstractnativeeventfilter#nativeEventFilter&quot;&gt;nativeEventFilter ()&lt;/a&gt; 함수 내에서도) 이벤트 필터를 제거하는 것이 항상 안전합니다 .</target>
        </trans-unit>
        <trans-unit id="4d14cf07f967c7a4767253322ec7c24163ade430" translate="yes" xml:space="preserve">
          <source>It is an extended radial gradient.</source>
          <target state="translated">확장 된 방사형 그래디언트입니다.</target>
        </trans-unit>
        <trans-unit id="5a92cda40432e18765c5ad2d06c71b84593fb33d" translate="yes" xml:space="preserve">
          <source>It is an indicative measure calculated from the dimensions of the map area, roughly corresponding how much zoom level could change with maximum pinch zoom. Default value is 4.0, maximum value is 10.0</source>
          <target state="translated">이는 최대 핀치 확대 / 축소와 함께 확대 / 축소 수준이 얼마나 변할 수 있는지에 해당하는 맵 영역의 크기에서 계산 된 지표입니다. 기본값은 4.0이고 최대 값은 10.0입니다.</target>
        </trans-unit>
        <trans-unit id="4e766061a8aefde8309a4bc3115316659d910e0e" translate="yes" xml:space="preserve">
          <source>It is applied to all items that are created when:</source>
          <target state="translated">다음과 같은 경우 생성되는 모든 항목에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="1ddb5a28e9a9113a838d12a815b586cb79fe380b" translate="yes" xml:space="preserve">
          <source>It is assumed that &lt;a href=&quot;qopenglbuffer#create&quot;&gt;create&lt;/a&gt;() has been called on this buffer and that it has been bound to the current context.</source>
          <target state="translated">이 버퍼에서 &lt;a href=&quot;qopenglbuffer#create&quot;&gt;create&lt;/a&gt; ()가 호출되었고 현재 컨텍스트에 바인딩 된 것으로 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="129e6e4bc27c2510269b13a04e570226d8f70ee3" translate="yes" xml:space="preserve">
          <source>It is assumed that this buffer has been bound to the current context, and that it was previously mapped with &lt;a href=&quot;qopenglbuffer#map&quot;&gt;map&lt;/a&gt;().</source>
          <target state="translated">이 버퍼는 현재 컨텍스트에 바인딩되었으며 이전에 &lt;a href=&quot;qopenglbuffer#map&quot;&gt;map&lt;/a&gt; ()으로 매핑 된 것으로 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="25534a13d5099963ed578b6caddd34729e8ef682" translate="yes" xml:space="preserve">
          <source>It is assumed that this buffer has been bound to the current context.</source>
          <target state="translated">이 버퍼는 현재 컨텍스트에 바인딩 된 것으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="a766809687525fe238537020d0b462294c0551aa" translate="yes" xml:space="preserve">
          <source>It is assumed the list is given in highest to lowest preference order. By calling this function all previous configurations will be invalidated and replaced with the new list.</source>
          <target state="translated">목록이 가장 높은 우선 순위에서 가장 낮은 우선 순위로 제공되는 것으로 가정합니다. 이 함수를 호출하면 이전의 모든 구성이 무효화되고 새 목록으로 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="623d5b0a45435708982ac32b50cef0c73ce57c4f" translate="yes" xml:space="preserve">
          <source>It is at this point that the surface format set using &lt;a href=&quot;qoffscreensurface#setFormat&quot;&gt;setFormat&lt;/a&gt;() gets resolved into an actual native surface.</source>
          <target state="translated">이 시점에서 &lt;a href=&quot;qoffscreensurface#setFormat&quot;&gt;setFormat&lt;/a&gt; ()을 사용하여 설정된 표면 형식 이 실제 고유 표면으로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="2a31fb5fe9a2a1a457a12df6097699e680812e6a" translate="yes" xml:space="preserve">
          <source>It is at this point that the surface format set using &lt;a href=&quot;qwindow#setFormat&quot;&gt;setFormat&lt;/a&gt;() gets resolved into an actual native surface. However, the window remains hidden until &lt;a href=&quot;qwindow#visible-prop&quot;&gt;setVisible&lt;/a&gt;() is called.</source>
          <target state="translated">이 시점에서 &lt;a href=&quot;qwindow#setFormat&quot;&gt;setFormat&lt;/a&gt; ()을 사용하여 설정된 표면 형식 이 실제 고유 표면으로 해석됩니다. 그러나 &lt;a href=&quot;qwindow#visible-prop&quot;&gt;setVisible&lt;/a&gt; ()이 호출 될 때까지 창은 숨겨져 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c28bcedba1d45890d6d91a10dc5f317e31c8f3a" translate="yes" xml:space="preserve">
          <source>It is attached to each child item of the &lt;a href=&quot;qml-qtquick-controls2-swipeview&quot;&gt;SwipeView&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-controls2-swipeview&quot;&gt;SwipeView&lt;/a&gt; 의 각 하위 항목에 첨부됩니다 .</target>
        </trans-unit>
        <trans-unit id="0b1246f9ad07b0d01b165e9dd5dc88e69642faf1" translate="yes" xml:space="preserve">
          <source>It is attached to each instance of the delegate and also to the header, the footer and the highlight delegates.</source>
          <target state="translated">대리자의 각 인스턴스와 머리글, 바닥 글 및 강조 표시 대리자에 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="ea71242f46d9f5013a2a5a6ca43e279a9780a018" translate="yes" xml:space="preserve">
          <source>It is attached to each instance of the delegate and also to the header, the footer, the section and the highlight delegates.</source>
          <target state="translated">델리게이트의 각 인스턴스와 머리글, 바닥 글, 섹션 및 강조 표시 델리게이트에 첨부됩니다.</target>
        </trans-unit>
        <trans-unit id="2c38e46008f8137c53006711504cd9a98470aad2" translate="yes" xml:space="preserve">
          <source>It is attached to each instance of the delegate.</source>
          <target state="translated">델리게이트의 각 인스턴스에 첨부됩니다.</target>
        </trans-unit>
        <trans-unit id="88cbca332b9fbdbdd4223c711fa5482c540788ed" translate="yes" xml:space="preserve">
          <source>It is attached to each tab button of the &lt;a href=&quot;qml-qtquick-controls2-tabbar&quot;&gt;TabBar&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-controls2-tabbar&quot;&gt;TabBar&lt;/a&gt; 의 각 탭 버튼에 첨부됩니다 .</target>
        </trans-unit>
        <trans-unit id="bc92eb6b4d088ae6c3eac423e49dd78cb10de9f0" translate="yes" xml:space="preserve">
          <source>It is attached to each tab button of the &lt;a href=&quot;qtquickcontrols2-navigation#tabbar&quot;&gt;TabBar&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qtquickcontrols2-navigation#tabbar&quot;&gt;TabBar&lt;/a&gt; 의 각 탭 버튼에 첨부됩니다 .</target>
        </trans-unit>
        <trans-unit id="a8538c9439c5972550d98139c45c3a0626307c25" translate="yes" xml:space="preserve">
          <source>It is available as a convenience for developers, as it offers a cleaner API.</source>
          <target state="translated">더 깨끗한 API를 제공하므로 개발자의 편의를 위해 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="010aa57a32da8a16628682a57841d8fb968a7c5d" translate="yes" xml:space="preserve">
          <source>It is bright (eg. shade).</source>
          <target state="translated">밝습니다 (예 : 그늘).</target>
        </trans-unit>
        <trans-unit id="9452f6a38a6280572a93e2344caf809679c134db" translate="yes" xml:space="preserve">
          <source>It is called by the QPA platform plugin. On Windows, it is called by the event dispatcher.</source>
          <target state="translated">QPA 플랫폼 플러그인에 의해 호출됩니다. Windows에서는 이벤트 디스패처에 의해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="5ea61bddedc3d9d65839d53bbd5d5af2c31850dd" translate="yes" xml:space="preserve">
          <source>It is common for a style to have certain properties or attributes that apply to all controls. &lt;a href=&quot;qtqml-syntax-objectattributes#attached-properties-and-attached-signal-handlers&quot;&gt;Attached properties&lt;/a&gt; are a great way of extending an item in QML without having to modify any existing C++ belonging to that item. For example, both the &lt;a href=&quot;qtquickcontrols2-material&quot;&gt;Material&lt;/a&gt; and &lt;a href=&quot;qtquickcontrols2-universal&quot;&gt;Universal&lt;/a&gt; styles have an attached theme property that controls whether an item and its children will be rendered in a light or dark theme.</source>
          <target state="translated">스타일에 모든 컨트롤에 적용되는 특정 속성이나 특성이있는 것은 일반적입니다. &lt;a href=&quot;qtqml-syntax-objectattributes#attached-properties-and-attached-signal-handlers&quot;&gt;연결된 속성&lt;/a&gt; 은 해당 항목에 속한 기존 C ++를 수정하지 않고도 QML에서 항목을 확장하는 좋은 방법입니다. 예를 들어, &lt;a href=&quot;qtquickcontrols2-material&quot;&gt;Material&lt;/a&gt; 스타일 과 &lt;a href=&quot;qtquickcontrols2-universal&quot;&gt;Universal&lt;/a&gt; 스타일에는 항목과 해당 하위 항목이 밝은 테마 또는 어두운 테마로 렌더링되는지 여부를 제어하는 ​​연결된 테마 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e34fc78ca0cddadfd1d71a057b44c0bbaee4b35" translate="yes" xml:space="preserve">
          <source>It is common for a style to have certain properties or attributes that apply to all controls. &lt;a href=&quot;qtqml-syntax-objectattributes#attached-properties-and-attached-signal-handlers&quot;&gt;Attached properties&lt;/a&gt; are a great way of extending an item in QML without having to modify any existing C++ belonging to that item. For example, both the &lt;a href=&quot;qtquickcontrols2-material#&quot;&gt;Material&lt;/a&gt; and &lt;a href=&quot;qtquickcontrols2-universal#&quot;&gt;Universal&lt;/a&gt; styles have an attached theme property that controls whether an item and its children will be rendered in a light or dark theme.</source>
          <target state="translated">스타일에는 모든 컨트롤에 적용되는 특정 속성이나 특성이있는 것이 일반적입니다. &lt;a href=&quot;qtqml-syntax-objectattributes#attached-properties-and-attached-signal-handlers&quot;&gt;연결된 속성&lt;/a&gt; 은 해당 항목에 속하는 기존 C ++를 수정하지 않고도 QML에서 항목을 확장하는 좋은 방법입니다. 예를 들어, &lt;a href=&quot;qtquickcontrols2-material#&quot;&gt;재질&lt;/a&gt; 및 &lt;a href=&quot;qtquickcontrols2-universal#&quot;&gt;유니버설&lt;/a&gt; 스타일 모두 항목과 해당 하위 항목을 밝거나 어두운 테마로 렌더링할지 여부를 제어하는 ​​테마 속성이 첨부되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6b625dfd42310f7f1aadbb1abaae4aea0f2de45" translate="yes" xml:space="preserve">
          <source>It is common on Unix to also use the build tool to install applications and libraries; for example, by invoking &lt;code&gt;make install&lt;/code&gt;. For this reason, qmake has the concept of an &lt;code&gt;install set&lt;/code&gt;, an object which contains instructions about the way a part of a project is to be installed. For example, a collection of documentation files can be described in the following way:</source>
          <target state="translated">Unix에서는 빌드 도구를 사용하여 응용 프로그램 및 라이브러리를 설치하는 것이 일반적입니다. 예를 들어, 호출에 의해 &lt;code&gt;make install&lt;/code&gt; . 이러한 이유로 qmake는 프로젝트의 일부를 설치하는 방법에 대한 지시 사항을 포함하는 오브젝트 인 &lt;code&gt;install set&lt;/code&gt; 개념을 가지고 있습니다. 예를 들어 문서 파일 모음은 다음과 같은 방법으로 설명 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f3b456ff1e3f7af07002a6a66e055a7adc5746d6" translate="yes" xml:space="preserve">
          <source>It is currently not possible to set files in Xcode configuration settings from the qmake generated Xcode project file. The way the libraries are linked in the</source>
          <target state="translated">현재 qmake 생성 Xcode 프로젝트 파일에서 Xcode 구성 설정의 파일을 설정할 수 없습니다. 라이브러리가 라이브러리에서 연결되는 방식</target>
        </trans-unit>
        <trans-unit id="2e0fc9241cbe83d02a5bf3108392bd689bb47e49" translate="yes" xml:space="preserve">
          <source>It is customary to add a &quot;.&quot; at the end of the description.</source>
          <target state="translated">&quot;.&quot;를 추가하는 것이 일반적입니다. 설명의 끝에.</target>
        </trans-unit>
        <trans-unit id="c2e1e606a9787eacf9644145f8300a30fa1a6ba7" translate="yes" xml:space="preserve">
          <source>It is dark.</source>
          <target state="translated">어둡다.</target>
        </trans-unit>
        <trans-unit id="b2d6c2a997ce3b7935e828af41c611c9080b83d6" translate="yes" xml:space="preserve">
          <source>It is demonstrated by the uiloader example:</source>
          <target state="translated">uiloader 예제에서 설명합니다.</target>
        </trans-unit>
        <trans-unit id="27ea536d05b2b846cdd7c52afa6c124387447657" translate="yes" xml:space="preserve">
          <source>It is easier to list the source files and the headers only once in a script to build a static library. Then the &lt;code&gt;main()&lt;/code&gt; function will be linked against the static library to build the executable and the tests will be linked against the static libraries.</source>
          <target state="translated">정적 라이브러리를 빌드하기 위해 스크립트에서 소스 파일과 헤더를 한 번만 나열하는 것이 더 쉽습니다. 그런 다음 &lt;code&gt;main()&lt;/code&gt; 함수는 실행 파일을 빌드하기 위해 정적 라이브러리에 연결되고 테스트는 정적 라이브러리에 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="8146302270fb45d397c493dd6468046828cb8bad" translate="yes" xml:space="preserve">
          <source>It is easy to move items around between the top level and lower levels in the tree. We just need to check whether the items are top-level items or not, and this information is supplied by each item's &lt;code&gt;parent()&lt;/code&gt; function. For example, we can remove the current item in the tree widget regardless of its location:</source>
          <target state="translated">트리에서 최상위 수준과 하위 수준 사이에서 항목을 쉽게 이동할 수 있습니다. 항목이 최상위 항목인지 여부를 확인하기 만하면됩니다.이 정보는 각 항목의 &lt;code&gt;parent()&lt;/code&gt; 함수 에 의해 제공됩니다 . 예를 들어, 위치에 관계없이 트리 위젯에서 현재 항목을 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="26cb0deebc5382597abfb9cef263ffa1378ccce5" translate="yes" xml:space="preserve">
          <source>It is equivalent to</source>
          <target state="translated">그것은</target>
        </trans-unit>
        <trans-unit id="75e0bfe833798efaebf20d3ba56c0a3ac5e09079" translate="yes" xml:space="preserve">
          <source>It is equivalent to &lt;code&gt;for (;;)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;for (;;)&lt;/code&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="56a78c541c5bf9c60110964633a0bba9f85fbbb9" translate="yes" xml:space="preserve">
          <source>It is equivalent to DefaultLocaleShortDate.</source>
          <target state="translated">DefaultLocaleShortDate와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="14069489fcbfc859dc0b97d0515b9db325b3a7f0" translate="yes" xml:space="preserve">
          <source>It is equivalent to SystemLocaleShortDate.</source>
          <target state="translated">SystemLocaleShortDate와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="3bc23296d0636cfb2a92d034fdb9c24e9fdd10f7" translate="yes" xml:space="preserve">
          <source>It is equivalent to a plain &lt;code&gt;int&lt;/code&gt;, except with respect to function overloading and type conversions. You should never need to use this class in your applications.</source>
          <target state="translated">함수 오버로딩과 타입 변환을 제외하고 는 일반 &lt;code&gt;int&lt;/code&gt; 와 같습니다 . 응용 프로그램에서이 클래스를 사용할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="7c4c711893861b666a75432c98b3587a7ad0e21c" translate="yes" xml:space="preserve">
          <source>It is equivalent to a regular JavaScript variable. For example, var properties can store numbers, strings, objects, arrays and functions:</source>
          <target state="translated">일반 JavaScript 변수와 같습니다. 예를 들어 var 속성은 숫자, 문자열, 객체, 배열 및 함수를 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2916d11bc42a9fa95831147ea86ce0f13f890c50" translate="yes" xml:space="preserve">
          <source>It is equivalent to the following code:</source>
          <target state="translated">다음 코드와 같습니다.</target>
        </trans-unit>
        <trans-unit id="6ad0e9ce2d2116d74fb4ae3071167fd7914bb1ed" translate="yes" xml:space="preserve">
          <source>It is equivalent to the following snippet, but is faster and easier to use.</source>
          <target state="translated">다음 스 니펫과 동일하지만 더 빠르고 사용하기 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="dd682ac87607826c2b9f641beda6ad968ac97712" translate="yes" xml:space="preserve">
          <source>It is equivalent to:</source>
          <target state="translated">다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b8c3b404b69159368514d4f130296fab626f1329" translate="yes" xml:space="preserve">
          <source>It is expected that a Scene3DView's Entity provide a &lt;a href=&quot;qml-qt3d-render-rendersettings&quot;&gt;RenderSettings&lt;/a&gt; with a valid SceneGraph. Please note that only the &lt;a href=&quot;qml-qt3d-render-rendersettings&quot;&gt;RenderSettings&lt;/a&gt; of the first Scene3DView instantiated will be taken into account.</source>
          <target state="translated">Scene3DView의 엔티티 는 유효한 SceneGraph 와 함께 &lt;a href=&quot;qml-qt3d-render-rendersettings&quot;&gt;RenderSettings&lt;/a&gt; 를 제공 할 것으로 예상 됩니다. 인스턴스화 된 첫 번째 Scene3DView 의 &lt;a href=&quot;qml-qt3d-render-rendersettings&quot;&gt;RenderSettings&lt;/a&gt; 만 고려됩니다.</target>
        </trans-unit>
        <trans-unit id="9461ca819b79aca455e7db0ca5cfd3c74a66ccfa" translate="yes" xml:space="preserve">
          <source>It is generally advisable to explicitly enable or disable the socket notifier, especially for write notifiers.</source>
          <target state="translated">일반적으로 소켓 알리미, 특히 쓰기 알리미의 경우 명시 적으로 활성화 또는 비활성화하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="e74d2d8dea2295d8503926bc1b4e5bcc52917794" translate="yes" xml:space="preserve">
          <source>It is generally not advisable to add excessive amounts of pages to a &lt;a href=&quot;qml-qtquick-controls2-swipeview&quot;&gt;SwipeView&lt;/a&gt;. However, when the amount of pages grows larger, or individual pages are relatively complex, it may be desirable to free up resources by unloading pages that are outside the immediate reach of the user. The following example presents how to use &lt;a href=&quot;qml-qtquick-loader&quot;&gt;Loader&lt;/a&gt; to keep a maximum of three pages simultaneously instantiated.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-controls2-swipeview&quot;&gt;SwipeView에&lt;/a&gt; 과도한 양의 페이지를 추가하는 것은 일반적으로 권장되지 않습니다 . 그러나 페이지 수가 커지거나 개별 페이지가 상대적으로 복잡한 경우 사용자가 직접 접근 할 수없는 페이지를 언로드하여 리소스를 확보하는 것이 좋습니다. 다음 예는 &lt;a href=&quot;qml-qtquick-loader&quot;&gt;로더&lt;/a&gt; 를 사용 하여 최대 3 개의 페이지를 동시에 인스턴스화 하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="3f2f8a5cb0c06f867db2fb281f9163f79d36b575" translate="yes" xml:space="preserve">
          <source>It is generally not advisable to add excessive amounts of pages to a SwipeView. However, when the amount of pages grows larger, or individual pages are relatively complex, it may be desirable to free up resources by unloading pages that are outside the immediate reach of the user. The following example presents how to use &lt;a href=&quot;qml-qtquick-loader&quot;&gt;Loader&lt;/a&gt; to keep a maximum of three pages simultaneously instantiated.</source>
          <target state="translated">일반적으로 SwipeView에 과도한 양의 페이지를 추가하는 것은 바람직하지 않습니다. 그러나 페이지의 양이 더 커지거나 개별 페이지가 상대적으로 복잡한 경우 사용자가 직접 접근 할 수없는 페이지를 언로드하여 리소스를 확보하는 것이 바람직 할 수 있습니다. 다음 예제는 &lt;a href=&quot;qml-qtquick-loader&quot;&gt;Loader&lt;/a&gt; 를 사용 하여 최대 세 페이지를 동시에 인스턴스화 하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="975004d91ac6535aceecf578becbefc9384c7860" translate="yes" xml:space="preserve">
          <source>It is generally recommended that saving across plugins be handled as saving &lt;a href=&quot;qml-qtlocation-place#favorites&quot;&gt;favorites&lt;/a&gt; as explained in the Favorites section. However there is another approach which is to create a new place, set its (destination) plugin and then use the &lt;a href=&quot;qml-qtlocation-place#copyFrom-method&quot;&gt;copyFrom()&lt;/a&gt; method to copy the details of the original place. Using &lt;a href=&quot;qml-qtlocation-place#copyFrom-method&quot;&gt;copyFrom()&lt;/a&gt; only copies data that is supported by the destination plugin, plugin specific data such as the place identifier is not copied over. Once the copy is done, the place is in a suitable state to be saved.</source>
          <target state="translated">일반적으로 플러그인 전체에서 저장 &lt;a href=&quot;qml-qtlocation-place#favorites&quot;&gt;하는&lt;/a&gt; 것은 즐겨 찾기 섹션에 설명 된대로 즐겨 찾기 저장으로 처리하는 것이 좋습니다 . 그러나 새 장소를 작성하고 (목적지) 플러그인을 설정 한 다음 &lt;a href=&quot;qml-qtlocation-place#copyFrom-method&quot;&gt;copyFrom ()&lt;/a&gt; 메소드를 사용 하여 원래 장소의 세부 사항을 복사하는 다른 방법이 있습니다. &lt;a href=&quot;qml-qtlocation-place#copyFrom-method&quot;&gt;copyFrom ()을&lt;/a&gt; 사용 하면 대상 플러그인에서 지원하는 데이터 만 복사하며 장소 식별자와 같은 플러그인 특정 데이터는 복사되지 않습니다. 복사가 완료되면 장소는 저장하기에 적합한 상태입니다.</target>
        </trans-unit>
        <trans-unit id="4e39ad455f26cd03f557ebbfbd4f53805340369f" translate="yes" xml:space="preserve">
          <source>It is good practice to check that persistent model indexes are valid before using them.</source>
          <target state="translated">지속적 모델 색인이 사용하기 전에 유효한지 확인하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="26b1103fa73cbd63a372437cb81f765f52b73d25" translate="yes" xml:space="preserve">
          <source>It is important that subclasses use this method to ensure that the engine reports its capabilities correctly. If this function is not used the engine will report that it supports no feature types at all.</source>
          <target state="translated">서브 클래스에서 엔진이 기능을 올바르게보고하도록하려면이 메소드를 사용하는 것이 중요합니다. 이 기능을 사용하지 않으면 엔진은 기능 유형이 전혀 지원되지 않는다고보고합니다.</target>
        </trans-unit>
        <trans-unit id="174d037084f991bc15ed34658397b385c41ccb5b" translate="yes" xml:space="preserve">
          <source>It is important that subclasses use this method to ensure that the engine reports its capabilities correctly. If this function is not used the engine will report that it supports no feature weights at all.</source>
          <target state="translated">서브 클래스에서 엔진이 기능을 올바르게보고하도록하려면이 메소드를 사용하는 것이 중요합니다. 이 기능을 사용하지 않으면 엔진은 기능 가중치를 전혀 지원하지 않는다고보고합니다.</target>
        </trans-unit>
        <trans-unit id="b14ab6f34d8cda255104be8a4e9ca871eb3dfdf8" translate="yes" xml:space="preserve">
          <source>It is important that subclasses use this method to ensure that the engine reports its capabilities correctly. If this function is not used the engine will report that it supports no maneuver details at all.</source>
          <target state="translated">서브 클래스에서 엔진이 기능을 올바르게보고하도록하려면이 메소드를 사용하는 것이 중요합니다. 이 기능을 사용하지 않으면 엔진은 조작 세부 사항을 전혀 지원하지 않는다고보고합니다.</target>
        </trans-unit>
        <trans-unit id="1c43299b32dd759de87f92833b7128f8045469a4" translate="yes" xml:space="preserve">
          <source>It is important that subclasses use this method to ensure that the engine reports its capabilities correctly. If this function is not used the engine will report that it supports no route optimizations at all.</source>
          <target state="translated">서브 클래스에서 엔진이 기능을 올바르게보고하도록하려면이 메소드를 사용하는 것이 중요합니다. 이 기능을 사용하지 않으면 엔진은 경로 최적화를 전혀 지원하지 않는다고보고합니다.</target>
        </trans-unit>
        <trans-unit id="2d676de6f84c7c803dd76e18f3e8d6ae1d3a74bc" translate="yes" xml:space="preserve">
          <source>It is important that subclasses use this method to ensure that the engine reports its capabilities correctly. If this function is not used the engine will report that it supports no segment detail at all.</source>
          <target state="translated">서브 클래스에서 엔진이 기능을 올바르게보고하도록하려면이 메소드를 사용하는 것이 중요합니다. 이 기능을 사용하지 않으면 엔진은 세그먼트 세부 사항을 전혀 지원하지 않는다고보고합니다.</target>
        </trans-unit>
        <trans-unit id="cf9d03e573ee6966f0e0813b7eb5cbf1afe47954" translate="yes" xml:space="preserve">
          <source>It is important that subclasses use this method to ensure that the engine reports its capabilities correctly. If this function is not used the engine will report that it supports no travel modes at all.</source>
          <target state="translated">서브 클래스에서 엔진이 기능을 올바르게보고하도록하려면이 메소드를 사용하는 것이 중요합니다. 이 기능을 사용하지 않으면 엔진은 주행 모드를 전혀 지원하지 않는다고보고합니다.</target>
        </trans-unit>
        <trans-unit id="012d0f22fd1c0dfb663f652dd7215779724ddba3" translate="yes" xml:space="preserve">
          <source>It is important that the application stores the purchase information before calling &lt;a href=&quot;qinapptransaction#finalize&quot;&gt;finalize&lt;/a&gt;(). If a transaction is not finalized (for example because the application was interrupted before it had a chance to save the information), then the transaction will be emitted again the next time the product is registered by &lt;a href=&quot;qinappstore#registerProduct&quot;&gt;QInAppStore::registerProduct&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qinapptransaction#finalize&quot;&gt;finalize&lt;/a&gt; () 를 호출하기 전에 애플리케이션이 구매 정보를 저장하는 것이 중요합니다 . 트랜잭션이 완료되지 않은 경우 (예 : 정보를 저장하기 전에 응용 프로그램이 인터럽트 되었기 때문에) 다음에 &lt;a href=&quot;qinappstore#registerProduct&quot;&gt;QInAppStore :: registerProduct&lt;/a&gt; ()에 의해 제품을 등록 할 때 트랜잭션이 다시 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="1ab729fc211c7fc438a1b472feb77695e9c74eef" translate="yes" xml:space="preserve">
          <source>It is important that the lifetime of the creation context outlive any created objects. See &lt;a href=&quot;qtqml-javascript-dynamicobjectcreation#maintaining-dynamically-created-objects&quot;&gt;Maintaining Dynamically Created Objects&lt;/a&gt; for more details.</source>
          <target state="translated">생성 컨텍스트의 수명이 생성 된 개체보다 수명이 길어야합니다. 자세한 내용은 &lt;a href=&quot;qtqml-javascript-dynamicobjectcreation#maintaining-dynamically-created-objects&quot;&gt;동적으로 생성 된 객체 유지 관리&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="cc0ab4889ed04d78385978d7ce346aae2f3489c5" translate="yes" xml:space="preserve">
          <source>It is important that this is done before &lt;a href=&quot;qgeoroutingmanagerengine#calculateRoute&quot;&gt;calculateRoute&lt;/a&gt;(), &lt;a href=&quot;qgeoroutingmanagerengine#updateRoute&quot;&gt;updateRoute&lt;/a&gt;() or any of the capability reporting functions are used to prevent incorrect or inconsistent behavior.</source>
          <target state="translated">&lt;a href=&quot;qgeoroutingmanagerengine#calculateRoute&quot;&gt;calculateRoute&lt;/a&gt; (), &lt;a href=&quot;qgeoroutingmanagerengine#updateRoute&quot;&gt;updateRoute&lt;/a&gt; () 또는 기능보고 기능을 사용하여 부정확하거나 일관성이없는 동작을 방지 하기 전에이 작업을 수행해야 합니다.</target>
        </trans-unit>
        <trans-unit id="c907c36acbdba58842b6001078c74f66c1675903" translate="yes" xml:space="preserve">
          <source>It is important that you first log out of the current iTunes user on your Apple device. To do this, open the &lt;b&gt;Settings&lt;/b&gt; app from the homescreen and go to the &lt;b&gt;iTunes &amp;amp; App Store&lt;/b&gt; entry. Click the first entry (which should be &lt;b&gt;Apple ID&lt;/b&gt;) and select &lt;b&gt;Sign Out&lt;/b&gt;.</source>
          <target state="translated">먼저 Apple 장비에서 현재 iTunes 사용자를 로그 아웃해야합니다. 이렇게하려면 홈 화면에서 &lt;b&gt;설정&lt;/b&gt; 앱을 열고 &lt;b&gt;iTunes &amp;amp; App Store&lt;/b&gt; 항목으로 이동하십시오. 첫 번째 항목 ( &lt;b&gt;Apple ID&lt;/b&gt; 여야 함 )을 클릭하고 &lt;b&gt;로그 아웃을&lt;/b&gt; 선택하십시오 .</target>
        </trans-unit>
        <trans-unit id="3cffedcaff560f6aa27c9f8aa9e26b809601ccc7" translate="yes" xml:space="preserve">
          <source>It is important that you have a current OpenGL context set when creating the &lt;a href=&quot;qopenglframebufferobject&quot;&gt;QOpenGLFramebufferObject&lt;/a&gt;, otherwise the initialization will fail.</source>
          <target state="translated">&lt;a href=&quot;qopenglframebufferobject&quot;&gt;QOpenGLFramebufferObject를&lt;/a&gt; 만들 때 현재 OpenGL 컨텍스트를 설정해야합니다 . 그렇지 않으면 초기화에 실패합니다.</target>
        </trans-unit>
        <trans-unit id="79cbc92d33615fb197aeb2866986c188c1ee1f8a" translate="yes" xml:space="preserve">
          <source>It is important that you have a current OpenGL context set when creating the QOpenGLFramebufferObject, otherwise the initialization will fail.</source>
          <target state="translated">QOpenGLFramebufferObject를 생성 할 때 현재 OpenGL 컨텍스트가 설정되어 있어야합니다. 그렇지 않으면 초기화가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="03ee7437446422026062e49703fd2a5c4f792985" translate="yes" xml:space="preserve">
          <source>It is important to note that changes in regular properties of JavaScript objects assigned to a var property will &lt;b&gt;not&lt;/b&gt; trigger updates of bindings that access them. The example below will display &quot;The car has 4 wheels&quot; as the change to the wheels property will not cause the reevaluation of the binding assigned to the &quot;text&quot; property:</source>
          <target state="translated">var 속성에 할당 된 JavaScript 객체의 일반 속성을 변경해도 해당 객체에 액세스하는 바인딩의 업데이트는 트리거 &lt;b&gt;되지 않습니다&lt;/b&gt; . 아래 예제는 wheels 속성을 변경해도 &quot;text&quot;속성에 할당 된 바인딩을 재평가하지 않으므로 &quot;자동차에 4 개의 휠이 있습니다&quot;가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="edba41d969b8314c08ee7f1d257182c013dfed70" translate="yes" xml:space="preserve">
          <source>It is important to note that qAsConst() does not copy its argument, it just performs a &lt;code&gt;const_cast&amp;lt;const T&amp;amp;&amp;gt;(t)&lt;/code&gt;. This is also the reason why it is designed to fail for rvalues: The returned reference would go stale too soon. So while this works (but detaches the returned object):</source>
          <target state="translated">qAsConst ()는 인수를 복사하지 않고 &lt;code&gt;const_cast&amp;lt;const T&amp;amp;&amp;gt;(t)&lt;/code&gt; 만 수행합니다 . 이것이 rvalue에 실패하도록 설계된 이유이기도합니다. 반환 된 참조가 너무 빨리 만료됩니다. 그래서 이것이 작동하는 동안 (그러나 반환 된 객체를 분리합니다) :</target>
        </trans-unit>
        <trans-unit id="5c2278586684d35b34cc6ba1056194dd99c22c91" translate="yes" xml:space="preserve">
          <source>It is important to note that the &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; and &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; streaming functions must always produce the same number of entries in case of structures, both in reading and in writing (marshalling and demarshalling), otherwise calls and signals may start to silently fail.</source>
          <target state="translated">그것은 것이 중요하다 &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; 및 &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; 그렇지 않으면 호출 신호 실패를 자동으로 시작할 수 있고, 스트리밍 기능이 항상 읽기 및 쓰기 (마샬링하고, 분석하는)의 구조, 양자의 경우에 동일 항목 수를 생성해야 .</target>
        </trans-unit>
        <trans-unit id="76c0b9977aec506b6ffbafd7a03a8d8f6a14fbac" translate="yes" xml:space="preserve">
          <source>It is important to note that the above syntax is in fact an &lt;a href=&quot;qtqml-syntax-basics#object-declarations&quot;&gt;object declaration&lt;/a&gt; which will instantiate an object which acts on a pre-existing property.</source>
          <target state="translated">위의 구문은 사실 기존 속성에 작용하는 객체를 인스턴스화하는 객체 &lt;a href=&quot;qtqml-syntax-basics#object-declarations&quot;&gt;선언&lt;/a&gt; 이라는 점에 유의해야합니다 .</target>
        </trans-unit>
        <trans-unit id="b4fa2a7b79a59dd440bef47d100c165686e7ed47" translate="yes" xml:space="preserve">
          <source>It is important to note that the results in the &lt;a href=&quot;qplacecontentreply&quot;&gt;QPlaceContentReply&lt;/a&gt;, is a &lt;a href=&quot;qplacecontent#Collection-typedef&quot;&gt;QPlaceContent::Collection&lt;/a&gt; which is essentially a &lt;a href=&quot;qmap&quot;&gt;QMap&lt;/a&gt;&amp;lt;int, &lt;a href=&quot;qplacecontent&quot;&gt;QPlaceContent&lt;/a&gt;&amp;gt;. The key &lt;code&gt;int&lt;/code&gt; in this case is the index of the content, and the value is the content itself. Due to the way Content is implemented it is possible to convert a content type as follows</source>
          <target state="translated">의 결과 것이 중요합니다 &lt;a href=&quot;qplacecontentreply&quot;&gt;QPlaceContentReply이&lt;/a&gt; 하는 것입니다 &lt;a href=&quot;qplacecontent#Collection-typedef&quot;&gt;QPlaceContent :: 컬렉션&lt;/a&gt; 본질적이다 &lt;a href=&quot;qmap&quot;&gt;QMap&lt;/a&gt; &amp;lt;INT, &lt;a href=&quot;qplacecontent&quot;&gt;QPlaceContent&lt;/a&gt; &amp;gt;. 이 경우 중요한 &lt;code&gt;int&lt;/code&gt; 는 컨텐츠의 색인이며 값은 컨텐츠 자체입니다. 컨텐츠 구현 방식으로 인해 컨텐츠 유형을 다음과 같이 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="df991ff64539213f31feaa035b09649a6567217f" translate="yes" xml:space="preserve">
          <source>It is important to note that using a low-priority worker thread is recommended to minimize the risk of starving the GUI thread (which could result in worse perceived performance). Also, remember that synchronization and locking mechanisms can be a significant cause of slow performance, and so care should be taken to avoid unnecessary locking.</source>
          <target state="translated">GUI 스레드가 고갈 될 위험을 최소화하려면 우선 순위가 낮은 작업자 스레드를 사용하는 것이 좋습니다 (성능이 저하 될 수 있음). 또한 동기화 및 잠금 메커니즘이 성능 저하의 중요한 원인 일 수 있으므로 불필요한 잠금을 피하기 위해주의를 기울여야합니다.</target>
        </trans-unit>
        <trans-unit id="d4d2dc43ca3893ab0de2b9987ff1f1831106ffb3" translate="yes" xml:space="preserve">
          <source>It is important to remember that Frameworks always link with</source>
          <target state="translated">프레임 워크는 항상</target>
        </trans-unit>
        <trans-unit id="5ec23f5aaa648d329361b5660b879ffea24d0fb4" translate="yes" xml:space="preserve">
          <source>It is important to remember that a &lt;a href=&quot;qthread&quot;&gt;QThread&lt;/a&gt; instance &lt;a href=&quot;qobject#thread-affinity&quot;&gt;lives in&lt;/a&gt; the old thread that instantiated it, not in the new thread that calls &lt;a href=&quot;qthread#run&quot;&gt;run&lt;/a&gt;(). This means that all of &lt;a href=&quot;qthread&quot;&gt;QThread&lt;/a&gt;'s queued slots and &lt;a href=&quot;qmetaobject#invokeMethod&quot;&gt;invoked methods&lt;/a&gt; will execute in the old thread. Thus, a developer who wishes to invoke slots in the new thread must use the worker-object approach; new slots should not be implemented directly into a subclassed &lt;a href=&quot;qthread&quot;&gt;QThread&lt;/a&gt;.</source>
          <target state="translated">기억하는 것이 중요하다 &lt;a href=&quot;qthread&quot;&gt;QThread의&lt;/a&gt; 인스턴스가 &lt;a href=&quot;qobject#thread-affinity&quot;&gt;에 살고&lt;/a&gt; 있지 호출하는 새 스레드에서, 그것을 인스턴스화 이전 스레드 &lt;a href=&quot;qthread#run&quot;&gt;실행&lt;/a&gt; (). 이것은 모든 &lt;a href=&quot;qthread&quot;&gt;QThread&lt;/a&gt; 의 대기 된 슬롯과 &lt;a href=&quot;qmetaobject#invokeMethod&quot;&gt;호출 된 메소드&lt;/a&gt; 가 이전 스레드에서 실행 됨을 의미합니다 . 따라서 새 스레드에서 슬롯을 호출하려는 개발자는 작업자-객체 접근 방식을 사용해야합니다. 새로운 슬롯을 서브 클래스 &lt;a href=&quot;qthread&quot;&gt;QThread에&lt;/a&gt; 직접 구현해서는 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="dd5a015300b94069165de457fa50d30a4ad866f5" translate="yes" xml:space="preserve">
          <source>It is important to remember that a QThread instance &lt;a href=&quot;qobject#thread-affinity&quot;&gt;lives in&lt;/a&gt; the old thread that instantiated it, not in the new thread that calls &lt;a href=&quot;qthread#run&quot;&gt;run&lt;/a&gt;(). This means that all of QThread's queued slots and &lt;a href=&quot;qmetaobject#invokeMethod&quot;&gt;invoked methods&lt;/a&gt; will execute in the old thread. Thus, a developer who wishes to invoke slots in the new thread must use the worker-object approach; new slots should not be implemented directly into a subclassed QThread.</source>
          <target state="translated">QThread 인스턴스 것을 기억하는 것이 중요하다 &lt;a href=&quot;qobject#thread-affinity&quot;&gt;에 살고&lt;/a&gt; 있지 호출하는 새 스레드에서, 그것을 인스턴스화 이전 스레드 &lt;a href=&quot;qthread#run&quot;&gt;실행&lt;/a&gt; (). 이것은 모든 QThread의 대기 슬롯과 &lt;a href=&quot;qmetaobject#invokeMethod&quot;&gt;호출 된 메서드&lt;/a&gt; 가 이전 스레드에서 실행 된다는 것을 의미합니다 . 따라서 새 스레드에서 슬롯을 호출하려는 개발자는 작업자 개체 접근 방식을 사용해야합니다. 새 슬롯은 서브 클래 싱 된 QThread에 직접 구현해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="d3ba072954ac0b0a6a28ee3a3e47bab04c5ae8b0" translate="yes" xml:space="preserve">
          <source>It is important to select the appropriate mechanism to exclude inapplicable tests: &lt;a href=&quot;qtest#QSKIP&quot;&gt;QSKIP&lt;/a&gt;(), using conditional statements to exclude parts of a test function, or not building the test for a particular platform.</source>
          <target state="translated">적용 할 수없는 테스트를 제외하는 적절한 메커니즘을 선택하는 것이 중요합니다. &lt;a href=&quot;qtest#QSKIP&quot;&gt;QSKIP&lt;/a&gt; (), 조건문을 사용하여 테스트 함수의 일부를 제외하거나 특정 플랫폼에 대한 테스트를 빌드하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f22ff167f1710ecdaf6aa9a5d8eb1a4763d74693" translate="yes" xml:space="preserve">
          <source>It is important to set this property when the widget does not provide any text. For example a button that only contains an icon needs to set this property to work with screen readers. The name should be short and equivalent to the visual information conveyed by the widget.</source>
          <target state="translated">위젯이 텍스트를 제공하지 않으면이 특성을 설정해야합니다. 예를 들어, 아이콘 만 포함 된 버튼은 화면 판독기와 작동하도록이 속성을 설정해야합니다. 이름은 짧아야하며 위젯이 전달하는 시각적 정보와 동일해야합니다.</target>
        </trans-unit>
        <trans-unit id="b7e5eb8574e041c10f899c3971339da369260b9e" translate="yes" xml:space="preserve">
          <source>It is impossible to assign a weight to &lt;a href=&quot;qgeorouterequest#FeatureType-enum&quot;&gt;QGeoRouteRequest::NoFeature&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qgeorouterequest#FeatureType-enum&quot;&gt;QGeoRouteRequest :: NoFeature에&lt;/a&gt; 가중치를 할당 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="ba50f25cd2e2c7ac90e6b2fa85b238318560387b" translate="yes" xml:space="preserve">
          <source>It is impossible to compare two numbers as strings directly. As a workaround, construct temporary values with a non-numeric prefix and compare these.</source>
          <target state="translated">두 숫자를 문자열로 직접 비교하는 것은 불가능합니다. 이 문제를 해결하려면 숫자가 아닌 접두사를 사용하여 임시 값을 구성하고이를 비교하십시오.</target>
        </trans-unit>
        <trans-unit id="71bd4ea55e48a1e236d043fd181ff306e6781f44" translate="yes" xml:space="preserve">
          <source>It is instructive to compare &lt;a href=&quot;qexplicitlyshareddatapointer&quot;&gt;QExplicitlySharedDataPointer&lt;/a&gt; with &lt;a href=&quot;qshareddatapointer&quot;&gt;QSharedDataPointer&lt;/a&gt; by way of an example. Consider the &lt;a href=&quot;qshareddatapointer#employee-example&quot;&gt;Employee example&lt;/a&gt; in &lt;a href=&quot;qshareddatapointer&quot;&gt;QSharedDataPointer&lt;/a&gt;, modified to use explicit sharing as explained in the discussion &lt;a href=&quot;qshareddatapointer#implicit-vs-explicit-sharing&quot;&gt;Implicit vs Explicit Sharing&lt;/a&gt;.</source>
          <target state="translated">예제를 통해 &lt;a href=&quot;qexplicitlyshareddatapointer&quot;&gt;QExplicitlySharedDataPointer&lt;/a&gt; 와 &lt;a href=&quot;qshareddatapointer&quot;&gt;QSharedDataPointer&lt;/a&gt; 를 비교하는 것이 좋습니다 . &lt;a href=&quot;qshareddatapointer#implicit-vs-explicit-sharing&quot;&gt;암시 적 vs 명시 적 공유에&lt;/a&gt; 설명 된대로 명시 적 공유를 사용하도록 수정 된 &lt;a href=&quot;qshareddatapointer&quot;&gt;QSharedDataPointer&lt;/a&gt; 의 &lt;a href=&quot;qshareddatapointer#employee-example&quot;&gt;직원 예제&lt;/a&gt; 를 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="e9dbbc24fdf38c2051ceac477e36f8516ed33c67" translate="yes" xml:space="preserve">
          <source>It is instructive to compare QExplicitlySharedDataPointer with &lt;a href=&quot;qshareddatapointer&quot;&gt;QSharedDataPointer&lt;/a&gt; by way of an example. Consider the &lt;a href=&quot;qshareddatapointer#employee-example&quot;&gt;Employee example&lt;/a&gt; in &lt;a href=&quot;qshareddatapointer&quot;&gt;QSharedDataPointer&lt;/a&gt;, modified to use explicit sharing as explained in the discussion &lt;a href=&quot;qshareddatapointer#implicit-vs-explicit-sharing&quot;&gt;Implicit vs Explicit Sharing&lt;/a&gt;.</source>
          <target state="translated">예를 들어 QExplicitlySharedDataPointer와 &lt;a href=&quot;qshareddatapointer&quot;&gt;QSharedDataPointer&lt;/a&gt; 를 비교하는 것은 유익 합니다. &lt;a href=&quot;qshareddatapointer&quot;&gt;QSharedDataPointer&lt;/a&gt; 의 &lt;a href=&quot;qshareddatapointer#employee-example&quot;&gt;Employee 예제&lt;/a&gt; 를 살펴보면 &lt;a href=&quot;qshareddatapointer#implicit-vs-explicit-sharing&quot;&gt;암시 적 공유 대 명시 적 공유&lt;/a&gt; 논의에 설명 된대로 명시 적 공유를 사용하도록 수정되었습니다 .</target>
        </trans-unit>
        <trans-unit id="6b00413076cac600bb2eb053b8081483aab47f5c" translate="yes" xml:space="preserve">
          <source>It is light (eg. internal lights).</source>
          <target state="translated">빛입니다 (예 : 내부 조명).</target>
        </trans-unit>
        <trans-unit id="a372ecb5f20dde23cc306a871312878490424cfb" translate="yes" xml:space="preserve">
          <source>It is likely at this point that you do not have all the necessary details to complete the information required to register your app. For now, just fill out the forms with stub data as everything except the &lt;b&gt;SKU&lt;/b&gt; and &lt;b&gt;Version&lt;/b&gt; fields are editable later.</source>
          <target state="translated">이 시점에서 앱 등록에 필요한 정보를 완성하는 데 필요한 모든 세부 정보가 없을 수 있습니다. 지금은 &lt;b&gt;SKU&lt;/b&gt; 및 &lt;b&gt;버전&lt;/b&gt; 필드를 제외한 모든 항목을 나중에 편집 할 수 있으므로 스텁 데이터로 양식을 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="76d28b8d59ed5fa49f03e9e3e07f540ec8616817" translate="yes" xml:space="preserve">
          <source>It is mandatory to call this at the end of the saving operation, otherwise the file will be discarded.</source>
          <target state="translated">저장 작업이 끝나면이를 호출해야합니다. 그렇지 않으면 파일이 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="1bee586e821a8226e0a973f772b2cb41652532fa" translate="yes" xml:space="preserve">
          <source>It is modeled after &lt;a href=&quot;qtcpserver&quot;&gt;QTcpServer&lt;/a&gt;, and behaves the same. So, if you know how to use &lt;a href=&quot;qtcpserver&quot;&gt;QTcpServer&lt;/a&gt;, you know how to use &lt;a href=&quot;qwebsocketserver&quot;&gt;QWebSocketServer&lt;/a&gt;. This class makes it possible to accept incoming WebSocket connections. You can specify the port or have &lt;a href=&quot;qwebsocketserver&quot;&gt;QWebSocketServer&lt;/a&gt; pick one automatically. You can listen on a specific address or on all the machine's addresses. Call &lt;a href=&quot;qwebsocketserver#listen&quot;&gt;listen&lt;/a&gt;() to have the server listen for incoming connections.</source>
          <target state="translated">&lt;a href=&quot;qtcpserver&quot;&gt;QTcpServer&lt;/a&gt; 이후에 모델링되었으며 동일하게 작동합니다. 당신이 사용하는 방법을 알고있는 경우에 따라서, &lt;a href=&quot;qtcpserver&quot;&gt;QTcpServer을&lt;/a&gt; , 당신이 사용하는 방법을 알고 &lt;a href=&quot;qwebsocketserver&quot;&gt;QWebSocketServer을&lt;/a&gt; . 이 클래스를 사용하면 들어오는 WebSocket 연결을 수락 할 수 있습니다. 포트를 지정하거나 &lt;a href=&quot;qwebsocketserver&quot;&gt;QWebSocketServer가&lt;/a&gt; 자동으로 포트를 선택 하도록 할 수 있습니다 . 특정 주소 나 모든 기기의 주소를들을 수 있습니다. 서버가 수신 연결을 청취하게하려면 &lt;a href=&quot;qwebsocketserver#listen&quot;&gt;청취&lt;/a&gt; ()를 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="93c99086159e259af9fca29f2fd8c5405ba13209" translate="yes" xml:space="preserve">
          <source>It is modeled after &lt;a href=&quot;qtcpserver&quot;&gt;QTcpServer&lt;/a&gt;, and behaves the same. So, if you know how to use &lt;a href=&quot;qtcpserver&quot;&gt;QTcpServer&lt;/a&gt;, you know how to use QWebSocketServer. This class makes it possible to accept incoming WebSocket connections. You can specify the port or have QWebSocketServer pick one automatically. You can listen on a specific address or on all the machine's addresses. Call &lt;a href=&quot;qwebsocketserver#listen&quot;&gt;listen&lt;/a&gt;() to have the server listen for incoming connections.</source>
          <target state="translated">&lt;a href=&quot;qtcpserver&quot;&gt;QTcpServer를&lt;/a&gt; 모델로 하며 동일하게 작동합니다. 따라서 &lt;a href=&quot;qtcpserver&quot;&gt;QTcpServer&lt;/a&gt; 사용 방법을 알고 있다면 QWebSocketServer 사용 방법을 알 수 있습니다. 이 클래스를 사용하면 들어오는 WebSocket 연결을 수락 할 수 있습니다. 포트를 지정하거나 QWebSocketServer에서 자동으로 선택하도록 할 수 있습니다. 특정 주소 또는 모든 기기의 주소에서 수신 할 수 있습니다. 서버가 들어오는 연결을 수신하도록하려면 &lt;a href=&quot;qwebsocketserver#listen&quot;&gt;listen&lt;/a&gt; ()을 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="b18da9b8db071e24e7df35de8d0f871165b4e024" translate="yes" xml:space="preserve">
          <source>It is moderately dark.</source>
          <target state="translated">약간 어둡습니다.</target>
        </trans-unit>
        <trans-unit id="3e8fa35edff019402eae8437fbebd56a6630061a" translate="yes" xml:space="preserve">
          <source>It is more efficient to use anchors rather than bindings to position items relative to each other. Consider this use of bindings to position rect2 relative to rect1:</source>
          <target state="translated">서로에 대해 항목을 배치하기 위해 바인딩보다 앵커를 사용하는 것이 더 효율적입니다. rect1을 기준으로 rect2를 배치하기 위해 이러한 바인딩 사용을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="9f507a367592c795347ff2370f9a8ed7dca3cc12" translate="yes" xml:space="preserve">
          <source>It is mostly used as a container to access other types such as &lt;a href=&quot;qml-qtaudioengine-audiocategory&quot;&gt;AudioCategory&lt;/a&gt;, &lt;a href=&quot;qml-qtaudioengine-audiosample&quot;&gt;AudioSample&lt;/a&gt; and Sound.</source>
          <target state="translated">&lt;a href=&quot;qml-qtaudioengine-audiocategory&quot;&gt;AudioCategory&lt;/a&gt; , &lt;a href=&quot;qml-qtaudioengine-audiosample&quot;&gt;AudioSample&lt;/a&gt; 및 Sound와 같은 다른 유형에 액세스하기위한 컨테이너로 주로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="9dda7b4c6bc00b9014386313e0d52be49e51597b" translate="yes" xml:space="preserve">
          <source>It is necessary to call this function to start event handling. The main event loop receives events from the window system and dispatches these to the application widgets.</source>
          <target state="translated">이벤트 처리를 시작하려면이 함수를 호출해야합니다. 기본 이벤트 루프는 윈도우 시스템에서 이벤트를 수신하여이를 애플리케이션 위젯으로 디스패치합니다.</target>
        </trans-unit>
        <trans-unit id="606505cd6d77ddd79ff5d656d18538652790baa0" translate="yes" xml:space="preserve">
          <source>It is necessary to first register the scheme with &lt;a href=&quot;qwebengineurlscheme#registerScheme&quot;&gt;QWebEngineUrlScheme::registerScheme&lt;/a&gt; at application startup.</source>
          <target state="translated">응용 프로그램 시작시 먼저 &lt;a href=&quot;qwebengineurlscheme#registerScheme&quot;&gt;QWebEngineUrlScheme :: registerScheme&lt;/a&gt; 에 체계를 등록 해야합니다.</target>
        </trans-unit>
        <trans-unit id="de6e405c93cb5bc14f06c240caaaa03ca4361ab6" translate="yes" xml:space="preserve">
          <source>It is necessary to specify a format before writing an picture, but it is not necessary to specify a format before reading an picture.</source>
          <target state="translated">그림을 쓰기 전에 형식을 지정할 필요는 없지만 그림을 읽기 전에 형식을 지정할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="52ee4a50eba7009a5453a6049a18ca3b60cc4d5e" translate="yes" xml:space="preserve">
          <source>It is never emitted by &lt;a href=&quot;qlcdnumber#setDigitCount&quot;&gt;setDigitCount&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qlcdnumber#setDigitCount&quot;&gt;setDigitCount&lt;/a&gt; ()에 의해 방출되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="f161e07e48f805cb7a17fcf05290aa615986a9be" translate="yes" xml:space="preserve">
          <source>It is normal to begin using drag and drop in response to this event.</source>
          <target state="translated">이 이벤트에 대한 응답으로 끌어서 놓기를 사용하는 것이 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="58cc8e1c38f68e8deff9d8880271e58d19c5be9d" translate="yes" xml:space="preserve">
          <source>It is normally empty, because touchscreens cannot uniquely identify fingers. But when it is set, it is expected to uniquely identify a specific token (fiducial object).</source>
          <target state="translated">터치 스크린은 손가락을 고유하게 식별 할 수 없으므로 일반적으로 비어 있습니다. 그러나 설정되면 특정 토큰 (기준 객체)을 고유하게 식별해야합니다.</target>
        </trans-unit>
        <trans-unit id="8db4ac30741536454b38d43b5cc31dc6282cde73" translate="yes" xml:space="preserve">
          <source>It is normally invalid (see &lt;a href=&quot;qpointingdeviceuniqueid#isValid&quot;&gt;isValid()&lt;/a&gt;), because touchscreens cannot uniquely identify fingers. But when the &lt;a href=&quot;qtouchevent-touchpoint#InfoFlag-enum&quot;&gt;Token&lt;/a&gt; flag is set, it is expected to uniquely identify a specific token (fiducial object).</source>
          <target state="translated">터치 스크린은 손가락을 고유하게 식별 할 수 없으므로 일반적으로 유효하지 않습니다 ( &lt;a href=&quot;qpointingdeviceuniqueid#isValid&quot;&gt;isValid ()&lt;/a&gt; 참조 ) . 그러나 &lt;a href=&quot;qtouchevent-touchpoint#InfoFlag-enum&quot;&gt;토큰&lt;/a&gt; 플래그가 설정되면 특정 토큰 (기준 객체)을 고유하게 식별해야합니다.</target>
        </trans-unit>
        <trans-unit id="5c2efce7eebe2344f5984edd91de8daea76feba5" translate="yes" xml:space="preserve">
          <source>It is not a requirement to open a session in order to monitor the underlying network interface.</source>
          <target state="translated">기본 네트워크 인터페이스를 모니터링하기 위해 세션을 열 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="d8745ef2687adc004df7be098b6167dbc2b6f1b5" translate="yes" xml:space="preserve">
          <source>It is not always possible to abort a print job. For example, all the data has gone to the printer but the printer cannot or will not cancel the job when asked to.</source>
          <target state="translated">인쇄 작업을 중단 할 수있는 것은 아닙니다. 예를 들어 모든 데이터가 프린터로 전송되었지만 요청시 프린터가 작업을 취소 할 수 없거나 취소하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="370f72d25f0b3635cc3d0aeceac1f66cfc3259b3" translate="yes" xml:space="preserve">
          <source>It is not emitted when &lt;a href=&quot;qml-qtquick-animation#running-prop&quot;&gt;running&lt;/a&gt; is set to &lt;code&gt;false&lt;/code&gt;, nor for animations whose &lt;a href=&quot;qml-qtquick-animation#loops-prop&quot;&gt;loops&lt;/a&gt; property is set to &lt;code&gt;Animation.Infinite&lt;/code&gt;.</source>
          <target state="translated">그것은 때 방출되지 않고 &lt;a href=&quot;qml-qtquick-animation#running-prop&quot;&gt;실행이&lt;/a&gt; 설정되어 &lt;code&gt;false&lt;/code&gt; 않으며, 그 애니메이션 &lt;a href=&quot;qml-qtquick-animation#loops-prop&quot;&gt;루프&lt;/a&gt; 속성에 설정되어 &lt;code&gt;Animation.Infinite&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="adea5774af0de95b05a6cea28620951ca8ecbe5e" translate="yes" xml:space="preserve">
          <source>It is not emitted when running is set to &lt;code&gt;false&lt;/code&gt;, nor for sprites whose &lt;a href=&quot;qml-qtquick-animatedsprite#loops-prop&quot;&gt;loops&lt;/a&gt; property is set to &lt;code&gt;AnimatedSprite.Infinite&lt;/code&gt;.</source>
          <target state="translated">running이 &lt;code&gt;false&lt;/code&gt; 로 설정 되거나 &lt;a href=&quot;qml-qtquick-animatedsprite#loops-prop&quot;&gt;loops&lt;/a&gt; 속성이 &lt;code&gt;AnimatedSprite.Infinite&lt;/code&gt; 로 설정된 스프라이트에 대해서는 방출되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="bd7004a98b0fd7f3dd4bcef4010a21c5b6281566" translate="yes" xml:space="preserve">
          <source>It is not generally necessary to refer to these properties when adding child items or resources, as the default &lt;a href=&quot;qml-qtquick-item#data-prop&quot;&gt;data&lt;/a&gt; property will automatically assign child objects to the &lt;code&gt;children&lt;/code&gt; and &lt;code&gt;resources&lt;/code&gt; properties as appropriate. See the &lt;a href=&quot;qml-qtquick-item#data-prop&quot;&gt;data&lt;/a&gt; documentation for details.</source>
          <target state="translated">기본 &lt;a href=&quot;qml-qtquick-item#data-prop&quot;&gt;데이터&lt;/a&gt; 속성은 자동으로 하위 개체를 &lt;code&gt;children&lt;/code&gt; 및 &lt;code&gt;resources&lt;/code&gt; 속성에 자동으로 할당 하므로 하위 항목 또는 리소스를 추가 할 때 이러한 속성을 참조 할 필요는 없습니다 . 자세한 내용은 &lt;a href=&quot;qml-qtquick-item#data-prop&quot;&gt;데이터&lt;/a&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1cb19d16197181c90d3a03b8123fe1c1eee1f551" translate="yes" xml:space="preserve">
          <source>It is not generally necessary to refer to these properties when adding child objects or resources, as the default &lt;a href=&quot;qml-qtquick3d-object3d#data-prop&quot;&gt;data&lt;/a&gt; property will automatically assign child objects to the &lt;code&gt;children&lt;/code&gt; and &lt;code&gt;resources&lt;/code&gt; properties as appropriate. See the &lt;a href=&quot;qml-qtquick3d-object3d#data-prop&quot;&gt;QtQuick3D::Object3D::data&lt;/a&gt; documentation for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8976c9d396db9f7d57c5e934d66758c20802941c" translate="yes" xml:space="preserve">
          <source>It is not guaranteed that a &lt;a href=&quot;qscrollevent&quot;&gt;QScrollEvent&lt;/a&gt; will be sent after an acceepted &lt;a href=&quot;qscrollprepareevent&quot;&gt;QScrollPrepareEvent&lt;/a&gt;, e.g. in a case where the maximum content position is (0,0).</source>
          <target state="translated">&lt;a href=&quot;qscrollevent&quot;&gt;QScrollEvent&lt;/a&gt; 가 승인 된 &lt;a href=&quot;qscrollprepareevent&quot;&gt;QScrollPrepareEvent&lt;/a&gt; 후에 전송 되는 것은 보장되지 않습니다 ( 예 : 최대 컨텐츠 위치가 (0,0) 인 경우).</target>
        </trans-unit>
        <trans-unit id="782325e2375d4e6dc6bd1154f3d783f121f2fd4e" translate="yes" xml:space="preserve">
          <source>It is not guaranteed that a &lt;a href=&quot;qscrollevent&quot;&gt;QScrollEvent&lt;/a&gt; will be sent after an acceepted QScrollPrepareEvent, e.g. in a case where the maximum content position is (0,0).</source>
          <target state="translated">&lt;a href=&quot;qscrollevent&quot;&gt;QScrollEvent&lt;/a&gt; 가 acceepted QScrollPrepareEvent 이후에 전송 된다는 보장은 없습니다 . 예를 들어 최대 콘텐츠 위치가 (0,0) 인 경우.</target>
        </trans-unit>
        <trans-unit id="9898ffc21dd4d5958b972d18f64d55409fc99564" translate="yes" xml:space="preserve">
          <source>It is not guaranteed that a &lt;a href=&quot;qscrollevent&quot;&gt;QScrollEvent&lt;/a&gt; will be sent after an accepted QScrollPrepareEvent, e.g. in a case where the maximum content position is (0, 0).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0b30e2564372f87079bc08b049255a907f8ee0e" translate="yes" xml:space="preserve">
          <source>It is not instantiable; to use it, call the members of the global &lt;code&gt;Qt&lt;/code&gt; object directly. For example:</source>
          <target state="translated">인스턴스화 할 수 없습니다. 사용하려면 전역 &lt;code&gt;Qt&lt;/code&gt; 객체 의 멤버를 직접 호출하십시오 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="198eb1643ec70aa3ac8e082990a9b16239c3a817" translate="yes" xml:space="preserve">
          <source>It is not instantiable; to use it, call the members of the global &lt;code&gt;QtMultimedia&lt;/code&gt; object directly. For example:</source>
          <target state="translated">인스턴스화 할 수 없습니다. 이를 사용하려면 글로벌 &lt;code&gt;QtMultimedia&lt;/code&gt; 객체 의 멤버를 직접 호출하십시오 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="747d42c2e679834f47b93d131f6825d069da4b40" translate="yes" xml:space="preserve">
          <source>It is not necessary to call this function in most cases, because it is called automatically before invoking &lt;a href=&quot;qopenglwidget#paintGL&quot;&gt;paintGL&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qopenglwidget#paintGL&quot;&gt;paintGL&lt;/a&gt; ()을 호출하기 전에 자동으로 호출되므로 대부분의 경우이 함수를 호출 할 필요는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="5c8d8367bc87fac5d5ea525ca6f14f3376d8fb16" translate="yes" xml:space="preserve">
          <source>It is not necessary to call this function in most cases, because it is called automatically before invoking &lt;a href=&quot;qopenglwindow#paintGL&quot;&gt;paintGL&lt;/a&gt;(). It is provided nonetheless to support advanced, multi-threaded scenarios where a thread different than the GUI or main thread may want to update the surface or framebuffer contents. See &lt;a href=&quot;gui-changes-qt6#qopenglcontext&quot;&gt;QOpenGLContext&lt;/a&gt; for more information on threading related issues.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="565c3cb09953498797ec4b760dd2ac75786b4108" translate="yes" xml:space="preserve">
          <source>It is not necessary to call this function in most cases, because it is called automatically before invoking &lt;a href=&quot;qopenglwindow#paintGL&quot;&gt;paintGL&lt;/a&gt;(). It is provided nonetheless to support advanced, multi-threaded scenarios where a thread different than the GUI or main thread may want to update the surface or framebuffer contents. See &lt;a href=&quot;qopenglcontext&quot;&gt;QOpenGLContext&lt;/a&gt; for more information on threading related issues.</source>
          <target state="translated">&lt;a href=&quot;qopenglwindow#paintGL&quot;&gt;paintGL&lt;/a&gt; ()을 호출하기 전에 자동으로 호출되므로 대부분의 경우이 함수를 호출 할 필요는 없습니다 . 그럼에도 불구하고 GUI 또는 주 스레드와 다른 스레드가 표면 또는 프레임 버퍼 내용을 업데이트하려고 할 수있는 고급 다중 스레드 시나리오를 지원하기 위해 제공됩니다. 스레딩 관련 문제에 대한 자세한 내용 은 &lt;a href=&quot;qopenglcontext&quot;&gt;QOpenGLContext&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c2bd03f2b1e729fdcf5fcd47df7e6ff49425e51f" translate="yes" xml:space="preserve">
          <source>It is not necessary to call this function in most cases, since the widget will make sure the context is bound and released properly when invoking &lt;a href=&quot;qopenglwidget#paintGL&quot;&gt;paintGL&lt;/a&gt;().</source>
          <target state="translated">위젯은 &lt;a href=&quot;qopenglwidget#paintGL&quot;&gt;paintGL&lt;/a&gt; ()을 호출 할 때 컨텍스트가 바인드되고 올바르게 해제되도록하기 때문에 대부분의 경우이 함수를 호출 할 필요는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="36a78afe54b3319e999e942959ef7c3c8a9a336d" translate="yes" xml:space="preserve">
          <source>It is not necessary to call this function in most cases, since the widget will make sure the context is bound and released properly when invoking &lt;a href=&quot;qopenglwindow#paintGL&quot;&gt;paintGL&lt;/a&gt;().</source>
          <target state="translated">위젯은 &lt;a href=&quot;qopenglwindow#paintGL&quot;&gt;paintGL&lt;/a&gt; ()을 호출 할 때 컨텍스트가 바인드되고 올바르게 해제되도록하기 때문에 대부분의 경우이 함수를 호출 할 필요는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="5278023ba30ef3a642da426aee380f042e1dd070" translate="yes" xml:space="preserve">
          <source>It is not necessary to construct a &lt;a href=&quot;qpauseanimation&quot;&gt;QPauseAnimation&lt;/a&gt; yourself. &lt;a href=&quot;qsequentialanimationgroup&quot;&gt;QSequentialAnimationGroup&lt;/a&gt; provides the convenience functions &lt;a href=&quot;qsequentialanimationgroup#addPause&quot;&gt;addPause()&lt;/a&gt; and &lt;a href=&quot;qsequentialanimationgroup#insertPause&quot;&gt;insertPause()&lt;/a&gt;. These functions simply take the number of milliseconds the pause should last.</source>
          <target state="translated">&lt;a href=&quot;qpauseanimation&quot;&gt;QPauseAnimation을&lt;/a&gt; 직접 구성 할 필요는 없습니다 . &lt;a href=&quot;qsequentialanimationgroup&quot;&gt;QSequentialAnimationGroup&lt;/a&gt; 은 편리한 함수 &lt;a href=&quot;qsequentialanimationgroup#addPause&quot;&gt;addPause ()&lt;/a&gt; 및 &lt;a href=&quot;qsequentialanimationgroup#insertPause&quot;&gt;insertPause ()를 제공&lt;/a&gt; 합니다. 이러한 기능은 일시 정지가 지속되는 시간을 밀리 초 단위로 유지합니다.</target>
        </trans-unit>
        <trans-unit id="7afdc6e7706c51decb3d7f10d2fc5c916a814f2c" translate="yes" xml:space="preserve">
          <source>It is not necessary to construct a QPauseAnimation yourself. &lt;a href=&quot;qsequentialanimationgroup&quot;&gt;QSequentialAnimationGroup&lt;/a&gt; provides the convenience functions &lt;a href=&quot;qsequentialanimationgroup#addPause&quot;&gt;addPause()&lt;/a&gt; and &lt;a href=&quot;qsequentialanimationgroup#insertPause&quot;&gt;insertPause()&lt;/a&gt;. These functions simply take the number of milliseconds the pause should last.</source>
          <target state="translated">QPauseAnimation을 직접 구성 할 필요는 없습니다. &lt;a href=&quot;qsequentialanimationgroup&quot;&gt;QSequentialAnimationGroup&lt;/a&gt; 은 편리한 함수 &lt;a href=&quot;qsequentialanimationgroup#addPause&quot;&gt;addPause ()&lt;/a&gt; 및 &lt;a href=&quot;qsequentialanimationgroup#insertPause&quot;&gt;insertPause ()를 제공&lt;/a&gt; 합니다. 이러한 함수는 일시 중지가 지속되어야하는 시간 (밀리 초) 만 사용합니다.</target>
        </trans-unit>
        <trans-unit id="9f62c8b0355ca63906b99df0acd761a7cfe5e845" translate="yes" xml:space="preserve">
          <source>It is not necessary to support every role defined in &lt;a href=&quot;qt#ItemDataRole-enum&quot;&gt;Qt::ItemDataRole&lt;/a&gt;. Depending on the type of data contained within a model, it may only be useful to implement the &lt;a href=&quot;qabstractitemmodel#data&quot;&gt;data&lt;/a&gt;() function to return valid information for some of the more common roles. Most models provide at least a textual representation of item data for the &lt;a href=&quot;qt#ItemDataRole-enum&quot;&gt;Qt::DisplayRole&lt;/a&gt;, and well-behaved models should also provide valid information for the &lt;a href=&quot;qt#ItemDataRole-enum&quot;&gt;Qt::ToolTipRole&lt;/a&gt; and &lt;a href=&quot;qt#ItemDataRole-enum&quot;&gt;Qt::WhatsThisRole&lt;/a&gt;. Supporting these roles enables models to be used with standard Qt views. However, for some models that handle highly-specialized data, it may be appropriate to provide data only for user-defined roles.</source>
          <target state="translated">&lt;a href=&quot;qt#ItemDataRole-enum&quot;&gt;Qt :: ItemDataRole에&lt;/a&gt; 정의 된 모든 역할을 지원할 필요는 없습니다 . 모델에 포함 된 데이터 유형에 따라 일부 일반적인 역할에 대한 유효한 정보를 반환 하기 위해 &lt;a href=&quot;qabstractitemmodel#data&quot;&gt;data&lt;/a&gt; () 함수를 구현하는 것만 유용 할 수 있습니다 . 대부분의 모델은 최소한 &lt;a href=&quot;qt#ItemDataRole-enum&quot;&gt;Qt :: DisplayRole에&lt;/a&gt; 대한 항목 데이터의 텍스트 표현을 제공하며 올바르게 작동하는 모델은 &lt;a href=&quot;qt#ItemDataRole-enum&quot;&gt;Qt :: ToolTipRole&lt;/a&gt; 및 &lt;a href=&quot;qt#ItemDataRole-enum&quot;&gt;Qt :: WhatsThisRole에&lt;/a&gt; 대한 유효한 정보도 제공해야합니다 . 이러한 역할을 지원하면 표준 Qt보기와 함께 모델을 사용할 수 있습니다. 그러나 고도로 전문화 된 데이터를 처리하는 일부 모델의 경우 사용자 정의 역할에 대해서만 데이터를 제공하는 것이 적절할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b7c5c997f5d6e5d2c41507ae2ecf4dbff1a4c0cb" translate="yes" xml:space="preserve">
          <source>It is not possible to have the sensor report both single and double tap events. If both are needed the app should create 2 sensor objects.</source>
          <target state="translated">센서가 단일 및 이중 탭 이벤트를 모두보고하도록 할 수는 없습니다. 둘 다 필요한 경우 앱은 2 개의 센서 객체를 생성해야합니다.</target>
        </trans-unit>
        <trans-unit id="fb3951e29337bf2c6afc962fb9f3be8d4958f719" translate="yes" xml:space="preserve">
          <source>It is not possible to lock for read if the thread already has locked for write.</source>
          <target state="translated">스레드가 쓰기를 위해 이미 잠겨 있으면 읽기 용으로 잠글 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="407c0ca79f739dbb49c78f0b660b686510558a09" translate="yes" xml:space="preserve">
          <source>It is not possible to lock for write if the thread already has locked for read.</source>
          <target state="translated">스레드가 이미 읽기를 위해 잠겨 있으면 쓰기를 위해 잠글 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="8237e2a89c474f1de22d3ef095f336b0b21ef8bd" translate="yes" xml:space="preserve">
          <source>It is not possible to remove a title bar from a dock widget. However, a similar effect can be achieved by setting a default constructed &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; as the title bar widget.</source>
          <target state="translated">독 위젯에서 제목 표시 줄을 제거 할 수 없습니다. 그러나 기본 생성 된 &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; 을 제목 표시 줄 위젯으로 설정하여 유사한 효과를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="95927031463cbb13470a60d9cb5c2cb006f9b4c9" translate="yes" xml:space="preserve">
          <source>It is not possible to remove a title bar from a dock widget. However, a similar effect can be achieved by setting a default constructed &lt;a href=&quot;widgets-changes-qt6#qwidget&quot;&gt;QWidget&lt;/a&gt; as the title bar widget.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdbca9cb736167f2551e7cc111d8d5a72c641fc3" translate="yes" xml:space="preserve">
          <source>It is not possible to render particle effects with the Software adaptation. Whenever possible, remove particles completely from the scene. Otherwise, they will still require some processing, even though they are not visible.</source>
          <target state="translated">소프트웨어 적응으로 입자 효과를 렌더링 할 수 없습니다. 가능하면 장면에서 파티클을 완전히 제거하십시오. 그렇지 않으면 보이지 않지만 여전히 일부 처리가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="a194e67d3b9ba693053771651527fab9b6d0dc13" translate="yes" xml:space="preserve">
          <source>It is not possible to retrieve the contents of a &lt;a href=&quot;qlcdnumber&quot;&gt;QLCDNumber&lt;/a&gt; object, although you can retrieve the numeric value with &lt;a href=&quot;qlcdnumber#value-prop&quot;&gt;value&lt;/a&gt;(). If you really need the text, we recommend that you connect the signals that feed the &lt;a href=&quot;qlcdnumber#display&quot;&gt;display&lt;/a&gt;() slot to another slot as well and store the value there.</source>
          <target state="translated">&lt;a href=&quot;qlcdnumber#value-prop&quot;&gt;값&lt;/a&gt; ()을 사용하여 숫자 값을 검색 할 수 있지만 &lt;a href=&quot;qlcdnumber&quot;&gt;QLCDNumber&lt;/a&gt; 오브젝트 의 컨텐츠를 검색 할 수 없습니다 . 실제로 텍스트가 필요한 경우 &lt;a href=&quot;qlcdnumber#display&quot;&gt;디스플레이&lt;/a&gt; () 슬롯을 공급하는 신호 를 다른 슬롯에 연결하고 값을 저장하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="9272ced28c703315ee575cc29cec2a4be86cef6f" translate="yes" xml:space="preserve">
          <source>It is not possible to retrieve the contents of a QLCDNumber object, although you can retrieve the numeric value with &lt;a href=&quot;qlcdnumber#value-prop&quot;&gt;value&lt;/a&gt;(). If you really need the text, we recommend that you connect the signals that feed the &lt;a href=&quot;qlcdnumber#display&quot;&gt;display&lt;/a&gt;() slot to another slot as well and store the value there.</source>
          <target state="translated">&lt;a href=&quot;qlcdnumber#value-prop&quot;&gt;값&lt;/a&gt; ()으로 숫자 값을 검색 할 수 있지만 QLCDNumber 오브젝트의 컨텐츠를 검색 할 수 없습니다 . 텍스트가 정말로 필요한 경우 &lt;a href=&quot;qlcdnumber#display&quot;&gt;디스플레이&lt;/a&gt; () 슬롯을 공급하는 신호 를 다른 슬롯에도 연결하고 여기에 값을 저장하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="3f122aa3d34a498c293d428fff185f0647f2f80d" translate="yes" xml:space="preserve">
          <source>It is not possible to set the SSL-state related fields.</source>
          <target state="translated">SSL 상태 관련 필드를 설정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9a365dba196942232257912078423f52284c491d" translate="yes" xml:space="preserve">
          <source>It is not possible to set the port with &lt;a href=&quot;qsqldatabase#setPort&quot;&gt;QSqlDatabase::setPort&lt;/a&gt;() due to limitations in the Sybase client library. Refer to the Sybase documentation for information on how to set up a Sybase client configuration file to enable connections to databases on non-default ports.</source>
          <target state="translated">Sybase 클라이언트 라이브러리의 제한 사항으로 인해 &lt;a href=&quot;qsqldatabase#setPort&quot;&gt;QSqlDatabase :: setPort&lt;/a&gt; ()로 포트를 설정할 수 없습니다 . 기본이 아닌 포트의 데이터베이스에 연결할 수 있도록 Sybase 클라이언트 구성 파일을 설정하는 방법에 대한 정보는 Sybase 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="bdfe83545ee39a27fb3eefcb5a42d9c208db28b5" translate="yes" xml:space="preserve">
          <source>It is not possible to simultanously request updates for more than one signal of the same monitor object. The last call to this function determines the signal upon which the updates cease to continue. At this stage only the &lt;a href=&quot;qgeoareamonitorsource#areaEntered&quot;&gt;areaEntered&lt;/a&gt;() and &lt;a href=&quot;qgeoareamonitorsource#areaExited&quot;&gt;areaExited&lt;/a&gt;() signals can be used to terminate the monitoring process.</source>
          <target state="translated">동일한 모니터 오브젝트의 둘 이상의 신호에 대한 업데이트를 동시에 요청할 수 없습니다. 이 함수에 대한 마지막 호출은 업데이트가 계속되는 신호를 결정합니다. 이 단계에서는 &lt;a href=&quot;qgeoareamonitorsource#areaEntered&quot;&gt;areaEntered&lt;/a&gt; () 및 &lt;a href=&quot;qgeoareamonitorsource#areaExited&quot;&gt;areaExited&lt;/a&gt; () 신호 만 모니터링 프로세스를 종료하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="320eea8d384cfe3b5bd1a19033202372c6c1f115" translate="yes" xml:space="preserve">
          <source>It is not recommended to hard-code colors, as applications and individual widgets can set their own palette and also use their style's palette for drawing. Note that none of Qt's widgets set their own palette. The Java style does hard-code some colors, but only as a decision of the author; it is not advised. Of course, it is not intended that the style should look good with any palette.</source>
          <target state="translated">응용 프로그램 및 개별 위젯은 자체 팔레트를 설정하고 스타일 팔레트를 사용하여 색상을 하드 코딩하는 것은 권장되지 않습니다. Qt의 위젯은 자체 팔레트를 설정하지 않습니다. Java 스타일은 일부 색상을 하드 코딩하지만 작성자의 결정으로 만 사용됩니다. 권장되지 않습니다. 물론 스타일이 팔레트에서 잘 보이도록 의도 된 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="03fc27de9f8ed92a2a44b3f1e9125545fa1624ae" translate="yes" xml:space="preserve">
          <source>It is not recommended to instantiate more than a single Scene3D instance per application. The reason for this is that a Scene3D instance instantiates the entire Qt 3D engine (memory managers, thread pool, render ...) under the scene.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bd083eae9a9ac83b3e84414859dcdd463b1e96c" translate="yes" xml:space="preserve">
          <source>It is not recommended to instantiate more than a single Scene3D instance per application. The reason for this is that a Scene3D instance instantiates the entire Qt 3D engine (memory managers, thread pool, render ...) under the scene. You should instead look into using &lt;a href=&quot;qml-qtquick-scene3d-scene3dview&quot;&gt;Scene3DView&lt;/a&gt; instances in conjunction with a single Scene3D instance.</source>
          <target state="translated">애플리케이션 당 두 개 이상의 Scene3D 인스턴스를 인스턴스화하지 않는 것이 좋습니다. 그 이유는 Scene3D 인스턴스가 장면 아래에서 전체 Qt 3D 엔진 (메모리 관리자, 스레드 풀, 렌더링 ...)을 인스턴스화하기 때문입니다. 대신 &lt;a href=&quot;qml-qtquick-scene3d-scene3dview&quot;&gt;Scene3DView&lt;/a&gt; 인스턴스를 단일 Scene3D 인스턴스와 함께 사용하는 것을 고려해야합니다.</target>
        </trans-unit>
        <trans-unit id="46576e57b039a8113850b78a8e77b75d97627490" translate="yes" xml:space="preserve">
          <source>It is not recommended to override the default values set for a page size as this may be the minimum printable area for a physical print device.</source>
          <target state="translated">실제 인쇄 장치의 인쇄 가능한 최소 영역 일 수 있으므로 페이지 크기에 설정된 기본값을 무시하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="a15694691ba6ba1c7e15e95fd833c0999342983d" translate="yes" xml:space="preserve">
          <source>It is not recommended to use &lt;a href=&quot;qml-qtquick-flickable#contentX-prop&quot;&gt;contentX&lt;/a&gt; or &lt;a href=&quot;qml-qtquick-flickable#contentY-prop&quot;&gt;contentY&lt;/a&gt; to position the view at a particular index. This is unreliable since removing items from the start of the list does not cause all other items to be repositioned, and because the actual start of the view can vary based on the size of the delegates.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-flickable#contentX-prop&quot;&gt;contentX&lt;/a&gt; 또는 &lt;a href=&quot;qml-qtquick-flickable#contentY-prop&quot;&gt;contentY&lt;/a&gt; 를 사용 하여 뷰를 특정 인덱스에 배치 하지 않는 것이 좋습니다 . 목록의 시작 부분에서 항목을 제거해도 다른 모든 항목의 위치가 변경되지 않으며보기의 실제 시작 부분은 대리자의 크기에 따라 달라질 수 있기 때문에 신뢰할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ec22e1f9eb78230c8686b28a83777566c903a4ac" translate="yes" xml:space="preserve">
          <source>It is not recommended to use &lt;a href=&quot;qml-qtquick-flickable#contentX-prop&quot;&gt;contentX&lt;/a&gt; or &lt;a href=&quot;qml-qtquick-flickable#contentY-prop&quot;&gt;contentY&lt;/a&gt; to position the view at a particular index. This is unreliable since removing items from the start of the list does not cause all other items to be repositioned, and because the actual start of the view can vary based on the size of the delegates. The correct way to bring an item into view is with &lt;code&gt;positionViewAtIndex&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-flickable#contentX-prop&quot;&gt;contentX&lt;/a&gt; 또는 &lt;a href=&quot;qml-qtquick-flickable#contentY-prop&quot;&gt;contentY&lt;/a&gt; 를 사용 하여 뷰를 특정 인덱스에 배치 하지 않는 것이 좋습니다 . 목록의 시작 부분에서 항목을 제거해도 다른 모든 항목의 위치가 변경되지 않으며보기의 실제 시작 부분은 대리자의 크기에 따라 달라질 수 있기 때문에 신뢰할 수 없습니다. 항목을 표시하는 올바른 방법은 &lt;code&gt;positionViewAtIndex&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="df103f2829f8eab2f7bcba5b6a4e444912eb33ab" translate="yes" xml:space="preserve">
          <source>It is not recommended to use &lt;a href=&quot;qml-qtquick-flickable#contentX-prop&quot;&gt;contentX&lt;/a&gt; or &lt;a href=&quot;qml-qtquick-flickable#contentY-prop&quot;&gt;contentY&lt;/a&gt; to position the view at a particular index. This is unreliable since removing items from the start of the view does not cause all other items to be repositioned. The correct way to bring an item into view is with &lt;code&gt;positionViewAtIndex&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-flickable#contentX-prop&quot;&gt;contentX&lt;/a&gt; 또는 &lt;a href=&quot;qml-qtquick-flickable#contentY-prop&quot;&gt;contentY&lt;/a&gt; 를 사용 하여 뷰를 특정 인덱스에 배치 하지 않는 것이 좋습니다 . 보기의 시작 부분에서 항목을 제거해도 다른 모든 항목의 위치가 변경되지 않으므로 신뢰할 수 없습니다. 항목을 표시하는 올바른 방법은 &lt;code&gt;positionViewAtIndex&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2969b6f2eb3297a4b71d4aa1cedb47e4f4925739" translate="yes" xml:space="preserve">
          <source>It is not sufficient for an attribute or element to merely be called &lt;code&gt;id&lt;/code&gt;. Its value type must also be &lt;code&gt;ID&lt;/code&gt;. However, the reserved name &lt;code&gt;xml:id&lt;/code&gt; is sufficient.</source>
          <target state="translated">속성이나 요소를 단순히 &lt;code&gt;id&lt;/code&gt; 라고 부르는 것만으로는 충분하지 않습니다 . 값 유형도 &lt;code&gt;ID&lt;/code&gt; 여야합니다 . 그러나 예약 된 이름 &lt;code&gt;xml:id&lt;/code&gt; 이면 충분합니다.</target>
        </trans-unit>
        <trans-unit id="e1e8640fc848463537ffc9df2a440df791599486" translate="yes" xml:space="preserve">
          <source>It is not sufficient for an attribute or element to merely be called &lt;code&gt;idref&lt;/code&gt;. It must also be of type &lt;code&gt;IDREF&lt;/code&gt;. Elements must be typed as &lt;code&gt;xs:IDREF&lt;/code&gt; or &lt;code&gt;xs:IDREFS&lt;/code&gt;, or, in the case of attributes, as &lt;code&gt;IDREF&lt;/code&gt; or &lt;code&gt;IDREFS&lt;/code&gt; in the schema.</source>
          <target state="translated">속성 또는 요소를 단순히 &lt;code&gt;idref&lt;/code&gt; 라고하는 것만으로는 충분하지 않습니다 . 또한 &lt;code&gt;IDREF&lt;/code&gt; 유형이어야합니다 . 요소는 &lt;code&gt;xs:IDREF&lt;/code&gt; 또는 &lt;code&gt;xs:IDREFS&lt;/code&gt; 로 입력하거나 속성의 경우 스키마에서 &lt;code&gt;IDREF&lt;/code&gt; 또는 &lt;code&gt;IDREFS&lt;/code&gt; 로 입력해야합니다.</target>
        </trans-unit>
        <trans-unit id="804fef8ec10154cd817a953dd48c757e879ee576" translate="yes" xml:space="preserve">
          <source>It is occasionally necessary to run some imperative code at application (or component instance) startup. While it is tempting to just include the startup script as</source>
          <target state="translated">응용 프로그램 (또는 구성 요소 인스턴스) 시작시 명령 코드를 실행해야하는 경우가 있습니다. 시작 스크립트를 다음과 같이 포함하고 싶은 유혹이 있습니다.</target>
        </trans-unit>
        <trans-unit id="78690aa9b0ed1c83b4d660b98f6a036c92b973c9" translate="yes" xml:space="preserve">
          <source>It is often desirable to delay some processing until the component is completed.</source>
          <target state="translated">구성 요소가 완료 될 때까지 일부 처리를 지연시키는 것이 종종 바람직합니다.</target>
        </trans-unit>
        <trans-unit id="c8d55342fb1f34d5127ef080bc6d1bd3721a7381" translate="yes" xml:space="preserve">
          <source>It is often desirable to give the user a special (often default) choice in addition to the range of numeric values. See &lt;a href=&quot;qabstractspinbox#specialValueText-prop&quot;&gt;setSpecialValueText&lt;/a&gt;() for how to do this with &lt;a href=&quot;qdoublespinbox&quot;&gt;QDoubleSpinBox&lt;/a&gt;.</source>
          <target state="translated">숫자 값의 범위 외에 사용자에게 특별한 (종종 기본값) 선택을 제공하는 것이 종종 바람직합니다. 참조 &lt;a href=&quot;qabstractspinbox#specialValueText-prop&quot;&gt;setSpecialValueText를&lt;/a&gt; 사용하여이 작업을 수행하는 방법은 () &lt;a href=&quot;qdoublespinbox&quot;&gt;QDoubleSpinBox&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f19f84c0dec2a71fde1b5515317e4e3e4265f4ad" translate="yes" xml:space="preserve">
          <source>It is often desirable to give the user a special (often default) choice in addition to the range of numeric values. See &lt;a href=&quot;qabstractspinbox#specialValueText-prop&quot;&gt;setSpecialValueText&lt;/a&gt;() for how to do this with &lt;a href=&quot;qspinbox&quot;&gt;QSpinBox&lt;/a&gt;.</source>
          <target state="translated">숫자 값의 범위 외에 사용자에게 특별한 (종종 기본값) 선택을 제공하는 것이 종종 바람직합니다. &lt;a href=&quot;qspinbox&quot;&gt;QSpinBox&lt;/a&gt; 로이를 수행하는 방법 은 &lt;a href=&quot;qabstractspinbox#specialValueText-prop&quot;&gt;setSpecialValueText&lt;/a&gt; ()를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="45095397a00b59a2f21c0972fa4078460e6a151b" translate="yes" xml:space="preserve">
          <source>It is often desirable to give the user a special (often default) choice in addition to the range of numeric values. See &lt;a href=&quot;qabstractspinbox#specialValueText-prop&quot;&gt;setSpecialValueText&lt;/a&gt;() for how to do this with QDoubleSpinBox.</source>
          <target state="translated">사용자에게 숫자 값 범위 외에 특별한 (종종 기본값) 선택을 제공하는 것이 바람직합니다. &lt;a href=&quot;qabstractspinbox#specialValueText-prop&quot;&gt;QDoubleSpinBox로이&lt;/a&gt; 를 수행하는 방법 은 setSpecialValueText ()를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7a8545e7c8bb2ea3c9ec9e72a5866975b78dbfe7" translate="yes" xml:space="preserve">
          <source>It is often desirable to give the user a special (often default) choice in addition to the range of numeric values. See &lt;a href=&quot;qabstractspinbox#specialValueText-prop&quot;&gt;setSpecialValueText&lt;/a&gt;() for how to do this with QSpinBox.</source>
          <target state="translated">사용자에게 숫자 값 범위 외에 특별한 (종종 기본값) 선택을 제공하는 것이 바람직합니다. QSpinBox로이를 수행하는 방법 은 &lt;a href=&quot;qabstractspinbox#specialValueText-prop&quot;&gt;setSpecialValueText&lt;/a&gt; ()를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8590b20fd476fabe22ea676780c46a698f7e2de4" translate="yes" xml:space="preserve">
          <source>It is often desirable to write your own custom model in C++ for use with a view in QML. While the optimal implementation of any such model will depend heavily on the use-case it must fulfil, some general guidelines are as follows:</source>
          <target state="translated">QML의 뷰와 함께 사용하기 위해 C ++로 사용자 정의 모델을 작성하는 것이 종종 바람직합니다. 이러한 모델의 최적 구현은 이행해야하는 사용 사례에 따라 크게 다르지만 몇 가지 일반적인 지침은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="160a6b1c7425564459a3a362f29b3742e923ee6f" translate="yes" xml:space="preserve">
          <source>It is often easier and cleaner to define an ENUM inside a class (see &lt;a href=&quot;#enum&quot;&gt;ENUM&lt;/a&gt;), but if you need a standalone enum type, using the ENUM keyword outside of a class definition can be helpful. This will generate a new class in your header files that handles marshalling, etc.. The syntax is identical to &lt;a href=&quot;#enum&quot;&gt;ENUM&lt;/a&gt;, with the exception that the declaration in this case is not contained in a &lt;code&gt;class&lt;/code&gt; declaration.</source>
          <target state="translated">클래스 내에서 ENUM을 정의하는 것이 더 쉽고 깔끔한 경우가 많지만 ( &lt;a href=&quot;#enum&quot;&gt;ENUM&lt;/a&gt; 참조 ) 독립형 열거 형 유형이 필요한 경우 클래스 정의 외부에서 ENUM 키워드를 사용하면 도움이 될 수 있습니다. 이렇게하면 마샬링 등을 처리하는 헤더 파일에 새 클래스가 생성 됩니다.이 경우 선언이 &lt;code&gt;class&lt;/code&gt; 선언에 포함되지 않는다는 점을 제외하면 구문은 &lt;a href=&quot;#enum&quot;&gt;ENUM&lt;/a&gt; 과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="f290464adc08a63f0b6ec042546fa5413d9417cd" translate="yes" xml:space="preserve">
          <source>It is often easier and cleaner to define an ENUM inside a class (see &lt;a href=&quot;qtremoteobjects-repc#enum&quot;&gt;ENUM&lt;/a&gt;), but if you need a standalone enum type, using the ENUM keyword outside of a class definition can be helpful. This will generate a new class in your header files that handles marshalling, etc.. The syntax is identical to &lt;a href=&quot;qtremoteobjects-repc#enum&quot;&gt;ENUM&lt;/a&gt;, with the exception that the declaration in this case is not contained in a &lt;code&gt;class&lt;/code&gt; declaration.</source>
          <target state="translated">클래스 내에서 ENUM을 정의하는 것이 더 쉽고 깔끔 하지만 ( &lt;a href=&quot;qtremoteobjects-repc#enum&quot;&gt;ENUM&lt;/a&gt; 참조 ) 독립형 enum 유형이 필요한 경우 클래스 정의 외부에서 ENUM 키워드를 사용하는 것이 도움이 될 수 있습니다. 이렇게하면 마샬링 등을 처리하는 헤더 파일에 새 클래스가 생성됩니다. 구문은 &lt;a href=&quot;qtremoteobjects-repc#enum&quot;&gt;ENUM&lt;/a&gt; 과 동일하지만 이 경우 선언이 &lt;code&gt;class&lt;/code&gt; 선언에 포함되지 않는다는 점이 다릅니다.</target>
        </trans-unit>
        <trans-unit id="7782b4d399ca66c9db7af038e155a7ce9b090c5b" translate="yes" xml:space="preserve">
          <source>It is often invalid (see &lt;a href=&quot;qpointingdeviceuniqueid#isValid&quot;&gt;isValid()&lt;/a&gt;), because touchscreens cannot uniquely identify fingers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="480c6a8f35b7be35ec849611ef531650d27388ac" translate="yes" xml:space="preserve">
          <source>It is often more convenient to use &lt;a href=&quot;qdeadlinetimer&quot;&gt;QDeadlineTimer&lt;/a&gt; in this case, which counts towards a timeout in the future instead of tracking elapsed time.</source>
          <target state="translated">이 경우 &lt;a href=&quot;qdeadlinetimer&quot;&gt;QDeadlineTimer&lt;/a&gt; 를 사용하는 것이 더 편리합니다 .이 시간은 경과 시간을 추적하는 대신 미래의 시간 초과로 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="d010f5292a2038c9bee95bcba519aeb7c0c73e17" translate="yes" xml:space="preserve">
          <source>It is often quite useful to make a custom type printable for debugging purposes, as in the following code:</source>
          <target state="translated">다음 코드와 같이 디버깅 목적으로 사용자 정의 유형을 인쇄 가능하게 만드는 것이 종종 유용합니다.</target>
        </trans-unit>
        <trans-unit id="0f5822d82ed0604bb7346cd6ad61790d10b1c9d1" translate="yes" xml:space="preserve">
          <source>It is often useful to be able to find items within an item view widget, either as a developer or as a service to present to users. All three item view convenience classes provide a common &lt;code&gt;findItems()&lt;/code&gt; function to make this as consistent and simple as possible.</source>
          <target state="translated">개발자 또는 사용자에게 제공 할 서비스로 항목보기 위젯에서 항목을 찾을 수있는 것이 종종 유용합니다. 세 가지 항목보기 편의 클래스는 모두 공통적 인 &lt;code&gt;findItems()&lt;/code&gt; 함수를 제공하여 가능한 한 일관되고 단순하게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="5a21453b3d943980ad7aa41fbf1ccd8accbc5010" translate="yes" xml:space="preserve">
          <source>It is ok to obtain the value of the pointer and using that value itself, like for example in debugging statements:</source>
          <target state="translated">예를 들어 디버깅 명령문에서와 같이 포인터의 값을 얻고 해당 값 자체를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="d21bb65e9bcc700397d9a5602e52f134cb88e660" translate="yes" xml:space="preserve">
          <source>It is only possible to call functions through dynamicCall() that have parameters or return values of datatypes supported by &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt;. See the &lt;a href=&quot;qaxbase&quot;&gt;QAxBase&lt;/a&gt; class documentation for a list of supported and unsupported datatypes. If you want to call functions that have unsupported datatypes in the parameter list, use &lt;a href=&quot;qaxbase#queryInterface&quot;&gt;queryInterface&lt;/a&gt;() to retrieve the appropriate COM interface, and use the function directly.</source>
          <target state="translated">&lt;a href=&quot;qvariant&quot;&gt;QVariant가&lt;/a&gt; 지원하는 데이터 유형의 매개 변수 또는 리턴 값이있는 dynamicCall ()을 통해서만 함수를 호출 할 수 있습니다 . 지원 및 지원되지 않는 데이터 유형 목록은 &lt;a href=&quot;qaxbase&quot;&gt;QAxBase&lt;/a&gt; 클래스 문서를 참조하십시오 . 매개 변수 목록에서 지원되지 않는 데이터 유형이있는 함수를 호출하려면 &lt;a href=&quot;qaxbase#queryInterface&quot;&gt;queryInterface&lt;/a&gt; ()를 사용 하여 적절한 COM 인터페이스를 검색하고 함수를 직접 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="9af2099d251964ebf57b90bdc95c255bc227e72f" translate="yes" xml:space="preserve">
          <source>It is only triggered for top-level, standalone animations. It will not be triggered for animations in a Behavior or Transition, or animations that are part of an animation group.</source>
          <target state="translated">최상위 독립 실행 형 애니메이션에 대해서만 트리거됩니다. 비헤이비어 또는 전환의 애니메이션 또는 애니메이션 그룹의 일부인 애니메이션에 대해서는 트리거되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="65511d2a482e0599722c5cbefca357f129a5d2a9" translate="yes" xml:space="preserve">
          <source>It is perfectly OK to create an instance of &lt;a href=&quot;qmimedatabase&quot;&gt;QMimeDatabase&lt;/a&gt; every time you need to perform a lookup. The parsing of mimetypes is done on demand (when shared-mime-info is installed) or when the very first instance is constructed (when parsing XML files directly).</source>
          <target state="translated">조회를 수행해야 할 때마다 &lt;a href=&quot;qmimedatabase&quot;&gt;QMimeDatabase&lt;/a&gt; 인스턴스를 작성 해도 됩니다. mimetype의 구문 분석은 요청시 (shared-mime-info가 설치된 경우) 또는 첫 번째 인스턴스가 구성 될 때 (XML 파일을 직접 구문 분석 할 때) 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="26ea6491158ce6432e502f30801b3dd77fccfb70" translate="yes" xml:space="preserve">
          <source>It is perfectly OK to create an instance of QMimeDatabase every time you need to perform a lookup. The parsing of mimetypes is done on demand (when shared-mime-info is installed) or when the very first instance is constructed (when parsing XML files directly).</source>
          <target state="translated">조회를 수행해야 할 때마다 QMimeDatabase의 인스턴스를 생성하는 것은 완벽합니다. MIME 유형의 구문 분석은 요청시 (shared-mime-info가 설치된 경우) 또는 첫 번째 인스턴스가 생성 될 때 (XML 파일을 직접 구문 분석 할 때) 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="26c07d685926a4e9e18cfeb51b0da8c8af86d24f" translate="yes" xml:space="preserve">
          <source>It is positive if the property value exceeds &lt;a href=&quot;qml-qt-labs-animation-boundaryrule#maximum-prop&quot;&gt;maximum&lt;/a&gt;, negative if the property value is less than &lt;a href=&quot;qml-qt-labs-animation-boundaryrule#minimum-prop&quot;&gt;minimum&lt;/a&gt;, or 0 if the property value is within both boundaries.</source>
          <target state="translated">속성 값이 &lt;a href=&quot;qml-qt-labs-animation-boundaryrule#maximum-prop&quot;&gt;maximum을&lt;/a&gt; 초과하면 양수, 속성 값이 &lt;a href=&quot;qml-qt-labs-animation-boundaryrule#minimum-prop&quot;&gt;minimum&lt;/a&gt; 미만이면 음수 , 속성 값이 두 경계 내에 있으면 0입니다.</target>
        </trans-unit>
        <trans-unit id="f797a1814c82acfaad7eb84efa973cda5156cfac" translate="yes" xml:space="preserve">
          <source>It is possible for a &lt;a href=&quot;qregularexpression&quot;&gt;QRegularExpression&lt;/a&gt; object to be invalid because of syntax errors in the pattern string. The &lt;a href=&quot;qregularexpression#isValid&quot;&gt;isValid&lt;/a&gt;() function will return true if the regular expression is valid, or false otherwise:</source>
          <target state="translated">A에 대한 것이 가능하다 &lt;a href=&quot;qregularexpression&quot;&gt;QRegularExpression의&lt;/a&gt; 객체가 있기 때문에 패턴 문자열에 구문 오류의 무효. &lt;a href=&quot;qregularexpression#isValid&quot;&gt;isValid&lt;/a&gt; 정규 표현식이 유효하거나, 그렇지 않은 경우는 false 경우 () 함수는 true를 반환합니다 :</target>
        </trans-unit>
        <trans-unit id="62cc8075587ba85131cf56fbf31d37cb332d3fb6" translate="yes" xml:space="preserve">
          <source>It is possible for a QRegularExpression object to be invalid because of syntax errors in the pattern string. The &lt;a href=&quot;qregularexpression#isValid&quot;&gt;isValid&lt;/a&gt;() function will return true if the regular expression is valid, or false otherwise:</source>
          <target state="translated">패턴 문자열의 구문 오류로 인해 QRegularExpression 객체가 유효하지 않을 수 있습니다. &lt;a href=&quot;qregularexpression#isValid&quot;&gt;isValid&lt;/a&gt; 정규 표현식이 유효하거나, 그렇지 않은 경우는 false 경우 () 함수는 true를 반환합니다 :</target>
        </trans-unit>
        <trans-unit id="9a4614ac6c8279c6ee6a9ba7c5a5822113d40371" translate="yes" xml:space="preserve">
          <source>It is possible for a custom delegate to provide editors without the use of an editor item factory. In this case, the following virtual functions must be reimplemented:</source>
          <target state="translated">커스텀 델리게이트는 에디터 아이템 팩토리를 사용하지 않고 에디터를 제공 할 수 있습니다. 이 경우 다음 가상 기능을 다시 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="cc885bdd2fcb6d6b24f79c0585f359f61d7bb804" translate="yes" xml:space="preserve">
          <source>It is possible for an aliasing property to have the same name as an existing property, effectively overwriting the existing property. For example, the following QML type has a &lt;code&gt;color&lt;/code&gt; alias property, named the same as the built-in &lt;a href=&quot;qml-qtquick-rectangle#color-prop&quot;&gt;Rectangle::color&lt;/a&gt; property:</source>
          <target state="translated">앨리어싱 속성이 기존 속성과 이름이 동일하여 기존 속성을 효과적으로 덮어 쓸 수 있습니다. 예를 들어 다음 QML 유형에는 내장 &lt;a href=&quot;qml-qtquick-rectangle#color-prop&quot;&gt;Rectangle :: color&lt;/a&gt; 속성 과 이름이 같은 &lt;code&gt;color&lt;/code&gt; 별칭 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="abf20951678d3358e7e308e0d573088880963f22" translate="yes" xml:space="preserve">
          <source>It is possible for applications and libraries to insert custom messages in the debug log, for instance for marking a group of related OpenGL commands and therefore being then able to identify eventual messages coming from them.</source>
          <target state="translated">응용 프로그램 및 라이브러리가 디버그 로그에 사용자 정의 메시지를 삽입 할 수 있습니다. 예를 들어 관련 OpenGL 명령 그룹을 표시하여 최종 메시지를 식별 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d52d6c48f12268b10686307191eed95e8d165223" translate="yes" xml:space="preserve">
          <source>It is possible for roles to contain list data. In the following example we create a list of fruit attributes:</source>
          <target state="translated">역할이 목록 데이터를 포함 할 수 있습니다. 다음 예제에서는 과일 속성 목록을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="dc45547eb4d42a0586a127a8486ce9a6721910c5" translate="yes" xml:space="preserve">
          <source>It is possible that a newly created &lt;a href=&quot;qgeocodereply&quot;&gt;QGeoCodeReply&lt;/a&gt; may be in a finished state, most commonly because an error has occurred. Since such an instance will never emit the &lt;a href=&quot;qgeocodereply#finished&quot;&gt;finished&lt;/a&gt;() or error(&lt;a href=&quot;qgeocodereply#Error-enum&quot;&gt;QGeoCodeReply::Error&lt;/a&gt;,&lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;) signals, it is important to check the result of &lt;a href=&quot;qgeocodereply#isFinished&quot;&gt;isFinished&lt;/a&gt;() before making the connections to the signals. The documentation for &lt;a href=&quot;qgeocodingmanager&quot;&gt;QGeoCodingManager&lt;/a&gt; demonstrates how this might be carried out.</source>
          <target state="translated">새로 생성 된 &lt;a href=&quot;qgeocodereply&quot;&gt;QGeoCodeReply&lt;/a&gt; 가 완료 상태 일 수 있습니다. 가장 일반적으로 오류가 발생했기 때문입니다. 이러한 인스턴스는 &lt;a href=&quot;qgeocodereply#finished&quot;&gt;완료된&lt;/a&gt; () 또는 error ( &lt;a href=&quot;qgeocodereply#Error-enum&quot;&gt;QGeoCodeReply :: Error&lt;/a&gt; , &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; ) 신호를 방출하지 않으므로 신호 에 연결하기 전에 &lt;a href=&quot;qgeocodereply#isFinished&quot;&gt;isFinished&lt;/a&gt; () 의 결과를 확인하는 것이 중요합니다 . &lt;a href=&quot;qgeocodingmanager&quot;&gt;QGeoCodingManager에&lt;/a&gt; 대한 문서는 이를 수행하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="7998b967136c5e4ab2a067a08f8136a06f5c34eb" translate="yes" xml:space="preserve">
          <source>It is possible that a newly created &lt;a href=&quot;qgeoroutereply&quot;&gt;QGeoRouteReply&lt;/a&gt; may be in a finished state, most commonly because an error has occurred. Since such an instance will never emit the &lt;a href=&quot;qgeoroutereply#finished&quot;&gt;finished&lt;/a&gt;() or error(&lt;a href=&quot;qgeoroutereply#Error-enum&quot;&gt;QGeoRouteReply::Error&lt;/a&gt;,&lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;) signals, it is important to check the result of &lt;a href=&quot;qgeoroutereply#isFinished&quot;&gt;isFinished&lt;/a&gt;() before making the connections to the signals. The documentation for &lt;a href=&quot;qgeoroutingmanager&quot;&gt;QGeoRoutingManager&lt;/a&gt; demonstrates how this might be carried out.</source>
          <target state="translated">새로 생성 된 &lt;a href=&quot;qgeoroutereply&quot;&gt;QGeoRouteReply&lt;/a&gt; 가 완료 상태 일 수 있습니다. 가장 일반적으로 오류가 발생했기 때문입니다. 이러한 인스턴스는 &lt;a href=&quot;qgeoroutereply#finished&quot;&gt;완료된&lt;/a&gt; () 또는 error ( &lt;a href=&quot;qgeoroutereply#Error-enum&quot;&gt;QGeoRouteReply :: Error&lt;/a&gt; , &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; ) 신호 를 절대로 방출하지 않으므로 신호 에 연결하기 전에 &lt;a href=&quot;qgeoroutereply#isFinished&quot;&gt;isFinished&lt;/a&gt; () 의 결과를 확인하는 것이 중요합니다 . &lt;a href=&quot;qgeoroutingmanager&quot;&gt;QGeoRoutingManager에&lt;/a&gt; 대한 문서는 이를 수행하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="3e6653472cc9c63a8a3352ec24b09e0fa7bb56b1" translate="yes" xml:space="preserve">
          <source>It is possible that a newly created QGeoCodeReply may be in a finished state, most commonly because an error has occurred. Since such an instance will never emit the &lt;a href=&quot;qgeocodereply#finished&quot;&gt;finished&lt;/a&gt;() or error(&lt;a href=&quot;qgeocodereply#Error-enum&quot;&gt;QGeoCodeReply::Error&lt;/a&gt;,&lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;) signals, it is important to check the result of &lt;a href=&quot;qgeocodereply#isFinished&quot;&gt;isFinished&lt;/a&gt;() before making the connections to the signals. The documentation for &lt;a href=&quot;qgeocodingmanager&quot;&gt;QGeoCodingManager&lt;/a&gt; demonstrates how this might be carried out.</source>
          <target state="translated">새로 생성 된 QGeoCodeReply가 완료 상태 일 수 있으며, 가장 일반적으로 오류가 발생했기 때문입니다. 이러한 인스턴스는 &lt;a href=&quot;qgeocodereply#finished&quot;&gt;완료&lt;/a&gt; () 또는 오류 ( &lt;a href=&quot;qgeocodereply#Error-enum&quot;&gt;QGeoCodeReply :: Error&lt;/a&gt; , &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; ) 신호를 방출하지 않으므로 신호 에 연결하기 전에 &lt;a href=&quot;qgeocodereply#isFinished&quot;&gt;isFinished&lt;/a&gt; () 의 결과를 확인하는 것이 중요합니다 . &lt;a href=&quot;qgeocodingmanager&quot;&gt;QGeoCodingManager에&lt;/a&gt; 대한 문서는 이것이 수행되는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="bb4ffd53abba8f1687d9b72588ed4d1ab53b5811" translate="yes" xml:space="preserve">
          <source>It is possible that a newly created QGeoRouteReply may be in a finished state, most commonly because an error has occurred. Since such an instance will never emit the &lt;a href=&quot;qgeoroutereply#finished&quot;&gt;finished&lt;/a&gt;() or error(&lt;a href=&quot;qgeoroutereply#Error-enum&quot;&gt;QGeoRouteReply::Error&lt;/a&gt;,&lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;) signals, it is important to check the result of &lt;a href=&quot;qgeoroutereply#isFinished&quot;&gt;isFinished&lt;/a&gt;() before making the connections to the signals. The documentation for &lt;a href=&quot;qgeoroutingmanager&quot;&gt;QGeoRoutingManager&lt;/a&gt; demonstrates how this might be carried out.</source>
          <target state="translated">새로 생성 된 QGeoRouteReply가 완료 상태 일 수 있으며, 가장 일반적으로 오류가 발생했기 때문입니다. 이러한 인스턴스는 &lt;a href=&quot;qgeoroutereply#finished&quot;&gt;완료&lt;/a&gt; () 또는 오류 ( &lt;a href=&quot;qgeoroutereply#Error-enum&quot;&gt;QGeoRouteReply :: Error&lt;/a&gt; , &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; ) 신호 를 절대 방출하지 않으므로 신호 에 연결하기 전에 &lt;a href=&quot;qgeoroutereply#isFinished&quot;&gt;isFinished&lt;/a&gt; () 의 결과를 확인하는 것이 중요합니다 . &lt;a href=&quot;qgeoroutingmanager&quot;&gt;QGeoRoutingManager에&lt;/a&gt; 대한 문서는 이것이 수행되는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="507728da206e572853be7889ebeb42394d76bca8" translate="yes" xml:space="preserve">
          <source>It is possible that an included service contains yet another service. Such second level includes have to be obtained via their relevant first level &lt;a href=&quot;qlowenergyservice&quot;&gt;QLowEnergyService&lt;/a&gt; instance. Technically, this could create a circular dependency.</source>
          <target state="translated">포함 된 서비스에 또 다른 서비스가 포함되어있을 수 있습니다. 이러한 두 번째 수준은 관련 첫 번째 수준 &lt;a href=&quot;qlowenergyservice&quot;&gt;QLowEnergyService&lt;/a&gt; 인스턴스 를 통해 얻어야 합니다. 기술적으로 이것은 순환 종속성을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d065ee5c4ba894eac8a34c04e83f7dd9eb6fcd0e" translate="yes" xml:space="preserve">
          <source>It is possible that providers may only support a subset of these. See the &lt;a href=&quot;qtlocation-index#plugin-references-and-parameters&quot;&gt;plugin documentation&lt;/a&gt; for more details.</source>
          <target state="translated">공급자는 이들 중 일부만 지원할 수 있습니다. 자세한 내용은 &lt;a href=&quot;qtlocation-index#plugin-references-and-parameters&quot;&gt;플러그인 설명서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="dad59a08026da383ebafd37152286ae39d3294a9" translate="yes" xml:space="preserve">
          <source>It is possible to access elements in an array in two ways. The first is to use the array index as the property name:</source>
          <target state="translated">두 가지 방법으로 배열의 요소에 액세스 할 수 있습니다. 첫 번째는 배열 인덱스를 속성 이름으로 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="85bbadc260fbc055218e4e62503b4b8922f4d08f" translate="yes" xml:space="preserve">
          <source>It is possible to add modules to the &lt;a href=&quot;http://freetype.sourceforge.net/freetype2/index.html&quot;&gt;FreeType 2&lt;/a&gt; font engine to support other types of font files. For more information, see the font engine's own website: &lt;a href=&quot;http://freetype.sourceforge.net/freetype2/index.html&quot;&gt;http://freetype.sourceforge.net/freetype2/index.html&lt;/a&gt;.</source>
          <target state="translated">다른 유형의 글꼴 파일을 지원 하기 위해 &lt;a href=&quot;http://freetype.sourceforge.net/freetype2/index.html&quot;&gt;FreeType 2&lt;/a&gt; 글꼴 엔진에 모듈을 추가 할 수 있습니다 . 자세한 내용은 글꼴 엔진 자체 웹 사이트 ( &lt;a href=&quot;http://freetype.sourceforge.net/freetype2/index.html&quot;&gt;http://freetype.sourceforge.net/freetype2/index.html)를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="063222f7245b62b11a62e056ecc671a399e7a783" translate="yes" xml:space="preserve">
          <source>It is possible to add support for &lt;a href=&quot;qml-qtquick-controls-exclusivegroup&quot;&gt;ExclusiveGroup&lt;/a&gt; for an object or control. It should have a &lt;code&gt;checked&lt;/code&gt; property, and either a &lt;code&gt;checkedChanged&lt;/code&gt;, &lt;code&gt;toggled()&lt;/code&gt;, or &lt;code&gt;toggled(bool)&lt;/code&gt; signal. It also needs to be bound with &lt;a href=&quot;qml-qtquick-controls-exclusivegroup#bindCheckable-method&quot;&gt;ExclusiveGroup::bindCheckable()&lt;/a&gt; when its &lt;a href=&quot;qml-qtquick-controls-exclusivegroup&quot;&gt;ExclusiveGroup&lt;/a&gt; typed property is set.</source>
          <target state="translated">개체 또는 컨트롤에 대해 &lt;a href=&quot;qml-qtquick-controls-exclusivegroup&quot;&gt;ExclusiveGroup에&lt;/a&gt; 대한 지원을 추가 할 수 있습니다 . &lt;code&gt;checked&lt;/code&gt; 속성과 &lt;code&gt;checkedChanged&lt;/code&gt; , &lt;code&gt;toggled()&lt;/code&gt; 또는 &lt;code&gt;toggled(bool)&lt;/code&gt; 신호 가 있어야합니다 . 또한 &lt;a href=&quot;qml-qtquick-controls-exclusivegroup&quot;&gt;ExclusiveGroup&lt;/a&gt; 유형 속성이 설정 될 때 &lt;a href=&quot;qml-qtquick-controls-exclusivegroup#bindCheckable-method&quot;&gt;ExclusiveGroup :: bindCheckable ()&lt;/a&gt; 과 바인딩되어야 합니다.</target>
        </trans-unit>
        <trans-unit id="182f8106b0f5ca4d2bc1366097c6177ea645915d" translate="yes" xml:space="preserve">
          <source>It is possible to add support for ExclusiveGroup for an object or control. It should have a &lt;code&gt;checked&lt;/code&gt; property, and either a &lt;code&gt;checkedChanged&lt;/code&gt;, &lt;code&gt;toggled()&lt;/code&gt;, or &lt;code&gt;toggled(bool)&lt;/code&gt; signal. It also needs to be bound with &lt;a href=&quot;qml-qtquick-controls-exclusivegroup#bindCheckable-method&quot;&gt;ExclusiveGroup::bindCheckable()&lt;/a&gt; when its ExclusiveGroup typed property is set.</source>
          <target state="translated">개체 또는 컨트롤에 대한 ExclusiveGroup 지원을 추가 할 수 있습니다. &lt;code&gt;checked&lt;/code&gt; 속성과 &lt;code&gt;checkedChanged&lt;/code&gt; , &lt;code&gt;toggled()&lt;/code&gt; 또는 &lt;code&gt;toggled(bool)&lt;/code&gt; 신호 가 있어야합니다 . 또한 ExclusiveGroup 유형 속성이 설정 될 때 &lt;a href=&quot;qml-qtquick-controls-exclusivegroup#bindCheckable-method&quot;&gt;ExclusiveGroup :: bindCheckable ()&lt;/a&gt; 로 바인드되어야 합니다.</target>
        </trans-unit>
        <trans-unit id="2ca39ac0075b0065c052fd44a2e070e562b70c2f" translate="yes" xml:space="preserve">
          <source>It is possible to apply an effect on a layer at runtime using layer.effect:</source>
          <target state="translated">layer.effect를 사용하여 런타임에 레이어에 효과를 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb9ebeb9c71f6448277c0b246056bbd498b7ce56" translate="yes" xml:space="preserve">
          <source>It is possible to call the grabWindow() function when the window is not visible. This requires that the window is &lt;a href=&quot;qwindow#create&quot;&gt;created&lt;/a&gt; and has a valid size and that no other &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt; instances are rendering in the same process.</source>
          <target state="translated">창이 보이지 않을 때 grabWindow () 함수를 호출 할 수 있습니다. 이를 위해서는 윈도우가 &lt;a href=&quot;qwindow#create&quot;&gt;생성&lt;/a&gt; 되고 유효한 크기이고 다른 프로세스에서 동일한 &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt; 인스턴스가 렌더링 되지 않아야 합니다.</target>
        </trans-unit>
        <trans-unit id="f907026bc11813feef3696844e6d5ff9fa9e1679" translate="yes" xml:space="preserve">
          <source>It is possible to change the number of rows and columns in a model. In the string list model it only makes sense to change the number of rows, so we only reimplement the functions for inserting and removing rows. These are declared in the class definition:</source>
          <target state="translated">모델의 행과 열 수를 변경할 수 있습니다. 문자열 목록 모델에서는 행 수를 변경하는 것이 적합하므로 행 삽입 및 제거 기능 만 다시 구현합니다. 이들은 클래스 정의에 선언되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="493abb28ca1f3f3fd6768e37ad4e536457307aaf" translate="yes" xml:space="preserve">
          <source>It is possible to constrain the input to an editable combobox using &lt;a href=&quot;qvalidator&quot;&gt;QValidator&lt;/a&gt;; see &lt;a href=&quot;qcombobox#setValidator&quot;&gt;setValidator&lt;/a&gt;(). By default, any input is accepted.</source>
          <target state="translated">&lt;a href=&quot;qvalidator&quot;&gt;QValidator를&lt;/a&gt; 사용하여 입력을 편집 가능한 콤보 박스로 제한 할 수 있습니다 . &lt;a href=&quot;qcombobox#setValidator&quot;&gt;setValidator&lt;/a&gt; ()를 참조하십시오 . 기본적으로 모든 입력이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="3e8835a269cbced2162831de5adaca57199fba7a" translate="yes" xml:space="preserve">
          <source>It is possible to create an instance of &lt;a href=&quot;qml-qtquick-controls2-scrollbar&quot;&gt;ScrollBar&lt;/a&gt; without using the attached property API. This is useful when the behavior of the attached scroll bar is not sufficient or a &lt;a href=&quot;qml-qtquick-flickable&quot;&gt;Flickable&lt;/a&gt; is not in use. In the following example, horizontal and vertical scroll bars are used to scroll over the text without using &lt;a href=&quot;qml-qtquick-flickable&quot;&gt;Flickable&lt;/a&gt;:</source>
          <target state="translated">연결된 속성 API를 사용하지 않고 &lt;a href=&quot;qml-qtquick-controls2-scrollbar&quot;&gt;ScrollBar&lt;/a&gt; 인스턴스를 만들 수 있습니다 . 연결된 스크롤 막대의 동작이 충분하지 않거나 &lt;a href=&quot;qml-qtquick-flickable&quot;&gt;Flickable&lt;/a&gt; 을 사용하지 않는 경우에 유용합니다. 다음 예제에서는 &lt;a href=&quot;qml-qtquick-flickable&quot;&gt;Flickable&lt;/a&gt; 을 사용하지 않고 가로 및 세로 스크롤 막대를 사용하여 텍스트를 스크롤합니다 .</target>
        </trans-unit>
        <trans-unit id="80dabfd5d1d51a87ed7232851ffab1471df45bf1" translate="yes" xml:space="preserve">
          <source>It is possible to create an instance of &lt;a href=&quot;qml-qtquick-controls2-scrollindicator&quot;&gt;ScrollIndicator&lt;/a&gt; without using the attached property API. This is useful when the behavior of the attached scoll indicator is not sufficient or a &lt;a href=&quot;qml-qtquick-flickable&quot;&gt;Flickable&lt;/a&gt; is not in use. In the following example, horizontal and vertical scroll indicators are used to indicate how far the user has scrolled over the text (using &lt;a href=&quot;qml-qtquick-mousearea&quot;&gt;MouseArea&lt;/a&gt; instead of &lt;a href=&quot;qml-qtquick-flickable&quot;&gt;Flickable&lt;/a&gt;):</source>
          <target state="translated">연결된 속성 API를 사용하지 않고 &lt;a href=&quot;qml-qtquick-controls2-scrollindicator&quot;&gt;ScrollIndicator&lt;/a&gt; 인스턴스를 만들 수 있습니다 . 연결된 &lt;a href=&quot;qml-qtquick-flickable&quot;&gt;scoll&lt;/a&gt; 표시기의 동작이 충분하지 않거나 Flickable 을 사용하지 않을 때 유용 합니다. 다음 예제에서 가로 및 세로 스크롤 표시기는 사용자가 텍스트를 스크롤 한 거리를 나타내는 데 사용됩니다 ( &lt;a href=&quot;qml-qtquick-mousearea&quot;&gt;Flickable&lt;/a&gt; 대신 &lt;a href=&quot;qml-qtquick-flickable&quot;&gt;MouseArea 사용&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="af02d26c2adf77d87d583a2a890a5753d98dbe90" translate="yes" xml:space="preserve">
          <source>It is possible to create an instance of ScrollBar without using the attached property API. This is useful when the behavior of the attached scroll bar is not sufficient or a &lt;a href=&quot;qml-qtquick-flickable&quot;&gt;Flickable&lt;/a&gt; is not in use. In the following example, horizontal and vertical scroll bars are used to scroll over the text without using &lt;a href=&quot;qml-qtquick-flickable&quot;&gt;Flickable&lt;/a&gt;:</source>
          <target state="translated">첨부 된 속성 API를 사용하지 않고 ScrollBar의 인스턴스를 생성 할 수 있습니다. 이것은 연결된 스크롤 막대의 동작이 충분하지 않거나 &lt;a href=&quot;qml-qtquick-flickable&quot;&gt;Flickable&lt;/a&gt; 이 사용되지 않을 때 유용 합니다. 다음 예제에서 가로 및 세로 스크롤 막대는 &lt;a href=&quot;qml-qtquick-flickable&quot;&gt;Flickable&lt;/a&gt; 을 사용하지 않고 텍스트를 스크롤하는 데 사용 됩니다 .</target>
        </trans-unit>
        <trans-unit id="c9a905697b45311c189e11c31de16a9c5a4df91e" translate="yes" xml:space="preserve">
          <source>It is possible to create an instance of ScrollIndicator without using the attached property API. This is useful when the behavior of the attached scoll indicator is not sufficient or a &lt;a href=&quot;qml-qtquick-flickable&quot;&gt;Flickable&lt;/a&gt; is not in use. In the following example, horizontal and vertical scroll indicators are used to indicate how far the user has scrolled over the text (using &lt;a href=&quot;qml-qtquick-mousearea&quot;&gt;MouseArea&lt;/a&gt; instead of &lt;a href=&quot;qml-qtquick-flickable&quot;&gt;Flickable&lt;/a&gt;):</source>
          <target state="translated">첨부 된 속성 API를 사용하지 않고도 ScrollIndicator의 인스턴스를 생성 할 수 있습니다. 이것은 첨부 된 &lt;a href=&quot;qml-qtquick-flickable&quot;&gt;scoll&lt;/a&gt; 표시기의 동작이 충분하지 않거나 Flickable 이 사용되지 않을 때 유용 합니다. 다음 예제에서는 가로 및 세로 스크롤 표시기를 사용하여 사용자가 텍스트 위로 스크롤 한 거리를 나타냅니다 ( &lt;a href=&quot;qml-qtquick-mousearea&quot;&gt;Flickable&lt;/a&gt; 대신 &lt;a href=&quot;qml-qtquick-flickable&quot;&gt;MouseArea 사용&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="d0fd84a36335858392ae626e0427aaaca69e5ad8" translate="yes" xml:space="preserve">
          <source>It is possible to create each side of the &lt;a href=&quot;qiodevice&quot;&gt;QIODevice&lt;/a&gt; and call &lt;a href=&quot;qremoteobjectnode#addClientSideConnection&quot;&gt;QRemoteObjectNode::addClientSideConnection&lt;/a&gt;(QIODevice *ioDevice) and &lt;a href=&quot;qremoteobjecthostbase#addHostSideConnection&quot;&gt;QRemoteObjectHostBase::addHostSideConnection&lt;/a&gt;(QIODevice *ioDevice) as shown above. This is fully supported, but requires the client know how to establish the connection or have a way to discover that information. This is exactly the problem the registry was designed to solve.</source>
          <target state="translated">양쪽 만들 수 &lt;a href=&quot;qiodevice&quot;&gt;QIODevice&lt;/a&gt; 및 통화 &lt;a href=&quot;qremoteobjectnode#addClientSideConnection&quot;&gt;QRemoteObjectNode :: addClientSideConnection&lt;/a&gt; (QIODevice ioDevice *) 및 &lt;a href=&quot;qremoteobjecthostbase#addHostSideConnection&quot;&gt;QRemoteObjectHostBase :: addHostSideConnection&lt;/a&gt; 위와 같이 (QIODevice * ioDevice 참조). 이것은 완전히 지원되지만 클라이언트가 연결을 설정하거나 해당 정보를 발견 할 수있는 방법을 알아야합니다. 이것은 레지스트리가 해결하도록 설계된 정확한 문제입니다.</target>
        </trans-unit>
        <trans-unit id="7c9ecfb67d93783492d60bb1323bd04f997cf24b" translate="yes" xml:space="preserve">
          <source>It is possible to customize qmake to support new compilers and preprocessors:</source>
          <target state="translated">새로운 컴파일러 및 전처리기를 지원하도록 qmake를 사용자 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="08fb5c95d90a802fe13bbdc07f8c64df4e48aa12" translate="yes" xml:space="preserve">
          <source>It is possible to customize the names of the build targets depending on the target platform. For example, a library or plugin may be named using a different convention on Windows from the one used on Unix platforms:</source>
          <target state="translated">대상 플랫폼에 따라 빌드 대상의 이름을 사용자 정의 할 수 있습니다. 예를 들어, 라이브러리 또는 플러그인은 Windows에서 Unix 플랫폼에서 사용되는 것과 다른 규칙을 사용하여 이름을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b40433af5fc4b0ec6d03815420ece79d42778910" translate="yes" xml:space="preserve">
          <source>It is possible to defer the decision of rejecting a certificate by calling &lt;a href=&quot;qml-qtwebengine-webenginecertificateerror#defer-method&quot;&gt;defer&lt;/a&gt;, which is useful when waiting for user input.</source>
          <target state="translated">defer를 호출하여 인증서 거부 결정을 &lt;a href=&quot;qml-qtwebengine-webenginecertificateerror#defer-method&quot;&gt;연기 할 수&lt;/a&gt; 있으며 이는 사용자 입력을 기다릴 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="850d247396a6a7df8768d301045642e77662f3f1" translate="yes" xml:space="preserve">
          <source>It is possible to define dependencies using either variable. Qt documentation only uses the &lt;code&gt;depends&lt;/code&gt; variable.</source>
          <target state="translated">두 변수 중 하나를 사용하여 종속성을 정의 할 수 있습니다. Qt 문서는 &lt;code&gt;depends&lt;/code&gt; 변수 만 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="3ef6937bbd477020adb4fba7786bc920609d299d" translate="yes" xml:space="preserve">
          <source>It is possible to define your own functions to provide conditions for scopes. The following example tests whether each file in a list exists and returns true if they all exist, or false if not:</source>
          <target state="translated">범위에 대한 조건을 제공하기 위해 고유 한 기능을 정의 할 수 있습니다. 다음 예제는 목록의 각 파일이 존재하는지 테스트하고 파일이 모두 존재하면 true를, 그렇지 않으면 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="25828a143424d42054836f214555faa30d4e5704" translate="yes" xml:space="preserve">
          <source>It is possible to draw into a &lt;a href=&quot;qopenglframebufferobject&quot;&gt;QOpenGLFramebufferObject&lt;/a&gt; using &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; and &lt;a href=&quot;qopenglpaintdevice&quot;&gt;QOpenGLPaintDevice&lt;/a&gt; in a separate thread.</source>
          <target state="translated">별도의 스레드에서 &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; 및 &lt;a href=&quot;qopenglpaintdevice&quot;&gt;QOpenGLPaintDevice&lt;/a&gt; 를 사용하여 &lt;a href=&quot;qopenglframebufferobject&quot;&gt;QOpenGLFramebufferObject&lt;/a&gt; 에 그릴 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="30ba04dc3070f4f267d2288098c3e219f716a4d3" translate="yes" xml:space="preserve">
          <source>It is possible to draw into a QOpenGLFramebufferObject using &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; and &lt;a href=&quot;qopenglpaintdevice&quot;&gt;QOpenGLPaintDevice&lt;/a&gt; in a separate thread.</source>
          <target state="translated">별도의 스레드에서 &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; 및 &lt;a href=&quot;qopenglpaintdevice&quot;&gt;QOpenGLPaintDevice&lt;/a&gt; 를 사용하여 QOpenGLFramebufferObject에 그릴 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9eea90551f075fa99ff39ad3674fc2173a79a46a" translate="yes" xml:space="preserve">
          <source>It is possible to dynamically generate menu items. One of the easiest ways to do so is with &lt;a href=&quot;qml-qtqml-instantiator&quot;&gt;Instantiator&lt;/a&gt;. For example, to implement a &quot;Recent Files&quot; submenu, where the items are based on a list of files stored in settings, the following code could be used:</source>
          <target state="translated">메뉴 항목을 동적으로 생성 할 수 있습니다. 가장 쉬운 방법 중 하나는 &lt;a href=&quot;qml-qtqml-instantiator&quot;&gt;Instantiator를 사용하는 것&lt;/a&gt; 입니다. 예를 들어 항목이 설정에 저장된 파일 목록을 기반으로하는 &quot;최근 파일&quot;하위 메뉴를 구현하려면 다음 코드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b242b386c3f0fadd3302a23ef28f8b9cf6101a42" translate="yes" xml:space="preserve">
          <source>It is possible to dynamically generate menu items. One of the easiest ways to do so is with &lt;a href=&quot;qml-qtqml-models-instantiator&quot;&gt;Instantiator&lt;/a&gt;. For example, to implement a &quot;Recent Files&quot; submenu, where the items are based on a list of files stored in settings, the following code could be used:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c3dabea509529360924b9ae97e8fa1bc32e5731" translate="yes" xml:space="preserve">
          <source>It is possible to dynamically generate menu items. One of the easiest ways to do so is with Instantiator. For example, to implement a &quot;Recent Files&quot; submenu, where the items are based on a list of files stored in settings, the following code could be used:</source>
          <target state="translated">메뉴 항목을 동적으로 생성 할 수 있습니다. 가장 쉬운 방법 중 하나는 Instantiator를 사용하는 것입니다. 예를 들어, 항목이 설정에 저장된 파일 목록을 기반으로하는 &quot;최근 파일&quot;하위 메뉴를 구현하려면 다음 코드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cab799898968dec0f46b6f87df3fc98718d7ee36" translate="yes" xml:space="preserve">
          <source>It is possible to enable or disable messages by selecting them by:</source>
          <target state="translated">다음을 통해 메시지를 선택하여 메시지를 활성화 또는 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf553d302c62ff4e7ba922a9de75c5c89cbec83d" translate="yes" xml:space="preserve">
          <source>It is possible to export meshes, lights, cameras, transform animations (scale/rotation/location), UV layouts, pivot points, object hierarchy, and material slots from Blender.</source>
          <target state="translated">블렌더에서 메시, 조명, 카메라, 변형 애니메이션 (스케일 / 회전 / 위치), UV 레이아웃, 피벗 포인트, 오브젝트 계층 및 재질 슬롯을 내보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eab9cc30f5f5f096f755d4e246c08d41b7209e5e" translate="yes" xml:space="preserve">
          <source>It is possible to filter the relations by using</source>
          <target state="translated">를 사용하여 관계를 필터링 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="d0daf2e61c6dea5cd7aa3c79eb142ba1474e472c" translate="yes" xml:space="preserve">
          <source>It is possible to filter the relations by using the optional parameter</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57ee6169fd7d7026a2315f724d581eea256d0773" translate="yes" xml:space="preserve">
          <source>It is possible to generate mipmaps at runtime by setting the property &lt;a href=&quot;qml-qtquick3d-texture#generateMipmaps-prop&quot;&gt;Texture::generateMipmaps&lt;/a&gt; to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bbde10ca12a948e56a300407872e5984458b404" translate="yes" xml:space="preserve">
          <source>It is possible to get the pattern options currently set on a &lt;a href=&quot;qregularexpression&quot;&gt;QRegularExpression&lt;/a&gt; object by using the &lt;a href=&quot;qregularexpression#patternOptions&quot;&gt;patternOptions&lt;/a&gt;() function:</source>
          <target state="translated">&lt;a href=&quot;qregularexpression#patternOptions&quot;&gt;patternOptions&lt;/a&gt; () 함수를 사용하여 &lt;a href=&quot;qregularexpression&quot;&gt;QRegularExpression&lt;/a&gt; 객체에 현재 설정된 패턴 옵션을 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="510ff62f27f940a03f584421d2d8a8cdeae63ecd" translate="yes" xml:space="preserve">
          <source>It is possible to get the pattern options currently set on a QRegularExpression object by using the &lt;a href=&quot;qregularexpression#patternOptions&quot;&gt;patternOptions&lt;/a&gt;() function:</source>
          <target state="translated">&lt;a href=&quot;qregularexpression#patternOptions&quot;&gt;patternOptions&lt;/a&gt; () 함수를 사용하여 QRegularExpression 객체에 현재 설정된 패턴 옵션을 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="83a3cbf7b2c6b49c35412b9ffba58fd375fa7d83" translate="yes" xml:space="preserve">
          <source>It is possible to give the view hints about the data it is handling in order to improve its performance when displaying large numbers of items. One approach that can be taken for views that are intended to display items with equal heights is to set the &lt;a href=&quot;qtreeview#uniformRowHeights-prop&quot;&gt;uniformRowHeights&lt;/a&gt; property to true.</source>
          <target state="translated">많은 수의 항목을 표시 할 때 성능을 향상시키기 위해 처리중인 데이터에 대한보기 힌트를 제공 할 수 있습니다. 높이가 동일한 항목을 표시하려는 뷰에 대해 수행 할 수있는 한 가지 방법은 &lt;a href=&quot;qtreeview#uniformRowHeights-prop&quot;&gt;uniformRowHeights&lt;/a&gt; 속성을 true 로 설정하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="e5619fd65b7b52c3be98938941f5639f7ce4424a" translate="yes" xml:space="preserve">
          <source>It is possible to give the view hints about the data it is handling in order to improve its performance when displaying large numbers of items. One approach that can be taken for views that are intended to display items with equal sizes is to set the &lt;a href=&quot;qlistview#uniformItemSizes-prop&quot;&gt;uniformItemSizes&lt;/a&gt; property to true.</source>
          <target state="translated">많은 수의 항목을 표시 할 때 성능을 향상시키기 위해 처리중인 데이터에 대한보기 힌트를 제공 할 수 있습니다. 크기가 같은 항목을 표시하려는 뷰에 대해 수행 할 수있는 한 가지 방법은 &lt;a href=&quot;qlistview#uniformItemSizes-prop&quot;&gt;uniformItemSizes&lt;/a&gt; 속성을 true 로 설정하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="e234f92b8c4fe733f641be93a3268d1838fa8965" translate="yes" xml:space="preserve">
          <source>It is possible to have multiple items which individually receive mouse and touch events. For example, to have two actions in the &lt;code&gt;swipe.right&lt;/code&gt; item, use the following code:</source>
          <target state="translated">마우스 및 터치 이벤트를 개별적으로받는 여러 항목을 가질 수 있습니다. 예를 들어 &lt;code&gt;swipe.right&lt;/code&gt; 항목 에 두 가지 작업을 수행 하려면 다음 코드를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="21f041a7d59578aee510c40252df6352b0d21268" translate="yes" xml:space="preserve">
          <source>It is possible to implement interfaces by inheriting &lt;a href=&quot;qaccessibleinterface&quot;&gt;QAccessibleInterface&lt;/a&gt; and implementing its pure virtual functions. In practice, however, it is usually preferable to inherit &lt;a href=&quot;qaccessibleobject&quot;&gt;QAccessibleObject&lt;/a&gt; or &lt;a href=&quot;qaccessiblewidget&quot;&gt;QAccessibleWidget&lt;/a&gt;, which implement part of the functionality for you. In the next section, we will see an example of implementing accessibility for a widget by inheriting the &lt;a href=&quot;qaccessiblewidget&quot;&gt;QAccessibleWidget&lt;/a&gt; class.</source>
          <target state="translated">&lt;a href=&quot;qaccessibleinterface&quot;&gt;QAccessibleInterface&lt;/a&gt; 를 상속 하고 순수한 가상 함수를 구현하여 인터페이스를 구현할 수 있습니다. 그러나 실제로는 일반적으로 기능의 일부를 구현하는 &lt;a href=&quot;qaccessibleobject&quot;&gt;QAccessibleObject&lt;/a&gt; 또는 &lt;a href=&quot;qaccessiblewidget&quot;&gt;QAccessibleWidget&lt;/a&gt; 을 상속하는 것이 좋습니다. 다음 섹션에서는 &lt;a href=&quot;qaccessiblewidget&quot;&gt;QAccessibleWidget&lt;/a&gt; 클래스 를 상속하여 위젯에 대한 액세스 가능성을 구현하는 예를 보여 줍니다 .</target>
        </trans-unit>
        <trans-unit id="40f9f33cce8b29087a5db311299edc647cbae5b0" translate="yes" xml:space="preserve">
          <source>It is possible to insert a node from another document into the document using &lt;a href=&quot;qdomdocument#importNode&quot;&gt;importNode&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qdomdocument#importNode&quot;&gt;importNode&lt;/a&gt; ()를 사용하여 다른 문서에서 문서로 노드를 삽입 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="72c231d35ea3101b3ea6a42d5591e63d504366a4" translate="yes" xml:space="preserve">
          <source>It is possible to integrate OpenGL, Vulkan, Metal, or Direct3D 11 calls directly into the QQuickWindow, as long as the QQuickWindow and the underlying scene graph is rendering using the same API. To access native graphics objects, such as device or context object handles, use &lt;a href=&quot;qsgrendererinterface&quot;&gt;QSGRendererInterface&lt;/a&gt;. An instance of &lt;a href=&quot;qsgrendererinterface&quot;&gt;QSGRendererInterface&lt;/a&gt; is queriable from QQuickWindow by calling &lt;a href=&quot;qquickwindow#rendererInterface&quot;&gt;rendererInterface&lt;/a&gt;(). The enablers for this integration are the &lt;a href=&quot;qquickwindow#beforeRendering&quot;&gt;beforeRendering&lt;/a&gt;(), &lt;a href=&quot;qquickwindow#beforeRenderPassRecording&quot;&gt;beforeRenderPassRecording&lt;/a&gt;(), &lt;a href=&quot;qquickwindow#afterRenderPassRecording&quot;&gt;afterRenderPassRecording&lt;/a&gt;(), and related signals. These allow rendering underlays or overlays. Alternatively, &lt;a href=&quot;qnativeinterface-qsgopengltexture&quot;&gt;QNativeInterface::QSGOpenGLTexture&lt;/a&gt;, &lt;a href=&quot;qnativeinterface-qsgvulkantexture&quot;&gt;QNativeInterface::QSGVulkanTexture&lt;/a&gt;, and other similar classes allow wrapping an existing native texture or image object in a &lt;a href=&quot;qsgtexture&quot;&gt;QSGTexture&lt;/a&gt; that can then be used with the scene graph.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="558faa704cc1093f2281c355d610b59a4c1649b3" translate="yes" xml:space="preserve">
          <source>It is possible to keep &lt;a href=&quot;qml-qtquick-controls2-scrollbar#binding-the-active-state-of-horizontal-and-vertical-scroll-bars&quot;&gt;both horizontal and vertical bars visible&lt;/a&gt; while scrolling in either direction.</source>
          <target state="translated">또한 유지할 수있다 &lt;a href=&quot;qml-qtquick-controls2-scrollbar#binding-the-active-state-of-horizontal-and-vertical-scroll-bars&quot;&gt;볼 모두 수평 및 수직 막대를&lt;/a&gt; 어느 방향으로 스크롤하는 동안.</target>
        </trans-unit>
        <trans-unit id="d447f4c6cf004298c362e8f59038d8787f585ecb" translate="yes" xml:space="preserve">
          <source>It is possible to keep &lt;a href=&quot;qml-qtquick-controls2-scrollindicator#binding-the-active-state-of-horizontal-and-vertical-scroll-indicators&quot;&gt;both horizontal and vertical indicators visible&lt;/a&gt; while scrolling in either direction.</source>
          <target state="translated">또한 유지할 수있다 &lt;a href=&quot;qml-qtquick-controls2-scrollindicator#binding-the-active-state-of-horizontal-and-vertical-scroll-indicators&quot;&gt;볼 상하 좌우 지표를&lt;/a&gt; 어느 방향으로 스크롤하는 동안.</target>
        </trans-unit>
        <trans-unit id="6ce60bbeffd22deb48dd97e09a931b57b9e3a3f5" translate="yes" xml:space="preserve">
          <source>It is possible to load animations from an arbitrary offset, but they will still follow the same pattern. Consider now the red numbers. If we specify that the animation begins at pixel location 120,0, with a frame count of 5 and the same frame size as before, then it will load the frames as they are numbered in red. The first 120x40 of the image will not be used, as it starts reading 40x40 blocks from the location of 120,0. When it reaches the end of the file at 160,0, it then starts to read the next row from 0,40.</source>
          <target state="translated">임의의 오프셋에서 애니메이션을로드 할 수 있지만 여전히 동일한 패턴을 따릅니다. 이제 빨간 숫자를 고려하십시오. 애니메이션이 픽셀 위치 120,0에서 시작하고 프레임 카운트가 5이고 이전과 동일한 프레임 크기를 지정하면 빨간색으로 번호가 매겨진 프레임이로드됩니다. 120,0의 위치에서 40x40 블록을 읽기 시작하므로 이미지의 첫 120x40은 사용되지 않습니다. 160,0에서 파일 끝에 도달하면 0,40에서 다음 행을 읽기 시작합니다.</target>
        </trans-unit>
        <trans-unit id="1863f7ea3766a69b11f135f5e18bbe93b4ddc48b" translate="yes" xml:space="preserve">
          <source>It is possible to look up a translation using &lt;a href=&quot;qtranslator#translate&quot;&gt;translate&lt;/a&gt;() (as &lt;a href=&quot;qobject#tr&quot;&gt;tr&lt;/a&gt;() and &lt;a href=&quot;qcoreapplication#translate&quot;&gt;QCoreApplication::translate&lt;/a&gt;() do). The &lt;a href=&quot;qtranslator#translate&quot;&gt;translate&lt;/a&gt;() function takes up to three parameters:</source>
          <target state="translated">&lt;a href=&quot;qtranslator#translate&quot;&gt;translate&lt;/a&gt; ()를 사용하여 번역 을 조회 할 수 있습니다 ( &lt;a href=&quot;qobject#tr&quot;&gt;tr&lt;/a&gt; () 및 &lt;a href=&quot;qcoreapplication#translate&quot;&gt;QCoreApplication :: translate&lt;/a&gt; () do). &lt;a href=&quot;qtranslator#translate&quot;&gt;번역&lt;/a&gt; () 함수는 세 개의 매개 변수를 취합니다</target>
        </trans-unit>
        <trans-unit id="4b648e475417c034c8bc8c53fc402bbe09651006" translate="yes" xml:space="preserve">
          <source>It is possible to make the item editable by setting the &lt;a href=&quot;qt#TextInteractionFlag-enum&quot;&gt;Qt::TextEditorInteraction&lt;/a&gt; flag using &lt;a href=&quot;qgraphicstextitem#setTextInteractionFlags&quot;&gt;setTextInteractionFlags&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qgraphicstextitem#setTextInteractionFlags&quot;&gt;setTextInteractionFlags&lt;/a&gt; ()를 사용하여 &lt;a href=&quot;qt#TextInteractionFlag-enum&quot;&gt;Qt :: TextEditorInteraction&lt;/a&gt; 플래그를 설정하여 항목을 편집 가능하게 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e44e34fd7435be6589fef572a0fa12ca44ccd408" translate="yes" xml:space="preserve">
          <source>It is possible to merge two multi maps by calling &lt;a href=&quot;qmultimap#unite&quot;&gt;unite&lt;/a&gt;(), by using operator+(), and by using operator+=(). Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="315ce8d478a67fc413bec1c25b3bf0125af7076c" translate="yes" xml:space="preserve">
          <source>It is possible to mix and match service providers for the various domains, so that a geocoding manager from one service provider can be used with a geographic routing manager from another service provider.</source>
          <target state="translated">여러 도메인의 서비스 제공 업체를 혼합하여 일치시킬 수 있으므로 한 서비스 제공 업체의 지오 코딩 관리자를 다른 서비스 제공 업체의 지리적 라우팅 관리자와 함께 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="284ab1b869c730f4bbafe9b24cd3a9e64e4aec5d" translate="yes" xml:space="preserve">
          <source>It is possible to modify elements in an array in two ways. The first is to use the array index as the property name:</source>
          <target state="translated">두 가지 방법으로 배열의 요소를 수정할 수 있습니다. 첫 번째는 배열 인덱스를 속성 이름으로 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="42c2e97fa640360aaaa7704434b4fe5d49aa9e00" translate="yes" xml:space="preserve">
          <source>It is possible to modify this default behavior of &lt;code&gt;SUBDIRS&lt;/code&gt; by giving additional modifiers to &lt;code&gt;SUBDIRS&lt;/code&gt; elements. Supported modifiers are:</source>
          <target state="translated">&lt;code&gt;SUBDIRS&lt;/code&gt; 요소에 추가 수정자를 제공하여 &lt;code&gt;SUBDIRS&lt;/code&gt; 의이 기본 동작을 수정할 수 있습니다 . 지원되는 수정자는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c0e34d812d6eea1b3767dc849420d74899731bf1" translate="yes" xml:space="preserve">
          <source>It is possible to nest calls to beginEditBlock and &lt;a href=&quot;qtextcursor#endEditBlock&quot;&gt;endEditBlock&lt;/a&gt;. The top-most pair will determine the scope of the undo/redo operation.</source>
          <target state="translated">beginEditBlock 및 &lt;a href=&quot;qtextcursor#endEditBlock&quot;&gt;endEditBlock&lt;/a&gt; 호출을 중첩시킬 수 있습니다 . 최상위 쌍은 실행 취소 / 다시 실행 작업의 범위를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="eaee15700bf298d17fe2c27b81e51d1715c040f6" translate="yes" xml:space="preserve">
          <source>It is possible to pass a starting offset and one or more match options to the &lt;a href=&quot;qregularexpression#globalMatch&quot;&gt;globalMatch&lt;/a&gt;() function, exactly like normal matching with &lt;a href=&quot;qregularexpression#match&quot;&gt;match&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qregularexpression#match&quot;&gt;match&lt;/a&gt; () 와 정확히 일치하는 것처럼 시작 오프셋과 하나 이상의 일치 옵션을 &lt;a href=&quot;qregularexpression#globalMatch&quot;&gt;globalMatch&lt;/a&gt; () 함수에 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5ecfc9da127996912965609d2798ba57bc9e023e" translate="yes" xml:space="preserve">
          <source>It is possible to position and rotate the &lt;a href=&quot;https://doc.qt.io/qt-6.0/qtquick3d-intro-example.html#camera&quot;&gt;Camera&lt;/a&gt; like any other spatial &lt;a href=&quot;qml-qtquick3d-node&quot;&gt;Node&lt;/a&gt; in the scene. The &lt;a href=&quot;qml-qtquick3d-node&quot;&gt;Node&lt;/a&gt;'s location and orientation determines where the &lt;a href=&quot;https://doc.qt.io/qt-6.0/qtquick3d-intro-example.html#camera&quot;&gt;Camera&lt;/a&gt; is in the scene, and what direction it is facing. The default orientation of the &lt;a href=&quot;https://doc.qt.io/qt-6.0/qtquick3d-intro-example.html#camera&quot;&gt;Camera&lt;/a&gt; has its forward vector pointing along the negative Z axis and its up vector along the positive Y axis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a00168fa3179c941eb09799e16f9f99cece7285b" translate="yes" xml:space="preserve">
          <source>It is possible to position and rotate the Camera like any other spatial &lt;a href=&quot;qml-qtquick3d-node&quot;&gt;Node&lt;/a&gt; in the scene. The &lt;a href=&quot;qml-qtquick3d-node&quot;&gt;Node&lt;/a&gt;'s location and orientation determines where the Camera is in the scene, and what direction it is facing. The default orientation of the camera has its forward vector pointing along the negative Z axis and its up vector along the positive Y axis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b66926ec47f7813837a6daa23e74d5564d5d2c67" translate="yes" xml:space="preserve">
          <source>It is possible to print some information to the debug output by enabling the &lt;code&gt;qt.qpa.input&lt;/code&gt; logging rule, for example by setting the &lt;code&gt;QT_LOGGING_RULES&lt;/code&gt; environment variable to &lt;code&gt;qt.qpa.input=true&lt;/code&gt;. This is useful for detecting which device is being used, or to troubleshoot device discovery issues.</source>
          <target state="translated">&lt;code&gt;qt.qpa.input&lt;/code&gt; 로깅 규칙을 사용하여 (예 : &lt;code&gt;QT_LOGGING_RULES&lt;/code&gt; 환경 변수를 &lt;code&gt;qt.qpa.input=true&lt;/code&gt; 로 설정하여) 일부 정보를 디버그 출력에 인쇄 할 수 있습니다 . 사용중인 장치를 감지하거나 장치 검색 문제를 해결하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="63edcc1f21a614363da265cdea51a3d6a229a8e4" translate="yes" xml:space="preserve">
          <source>It is possible to provide a JSON-format configuration file specifying which OpenGL implementation to use depending on the graphics card and driver version. The location is given by the environment variable &lt;code&gt;QT_OPENGL_BUGLIST&lt;/code&gt;. Relative paths are resolved using &lt;code&gt;QLibraryInfo::SettingsPath&lt;/code&gt; or &lt;code&gt;QStandardPaths::ConfigLocation&lt;/code&gt;. The file utilizes the format of the driver bug list used in &lt;a href=&quot;http://www.chromium.org/Home&quot;&gt;The Chromium Projects&lt;/a&gt;. It consists of a list of entries each of which specifies a set of conditions and a list of feature keywords. Typically, device id and vendor id are used to match a specific graphics card. They can be found in the output of the &lt;code&gt;qtdiag&lt;/code&gt; or &lt;code&gt;dxdiag&lt;/code&gt; tool.</source>
          <target state="translated">그래픽 카드 및 드라이버 버전에 따라 사용할 OpenGL 구현을 지정하는 JSON 형식 구성 파일을 제공 할 수 있습니다. 위치는 환경 변수 &lt;code&gt;QT_OPENGL_BUGLIST&lt;/code&gt; 에 의해 제공됩니다 . 상대 경로를 사용하여 해결 &lt;code&gt;QLibraryInfo::SettingsPath&lt;/code&gt; 또는 &lt;code&gt;QStandardPaths::ConfigLocation&lt;/code&gt; . 이 파일은 &lt;a href=&quot;http://www.chromium.org/Home&quot;&gt;Chromium 프로젝트에&lt;/a&gt; 사용 된 드라이버 버그 목록의 형식을 사용합니다 . 이는 각각 조건 세트와 기능 키워드 목록을 지정하는 항목 목록으로 구성됩니다. 일반적으로 장치 ID와 공급 업체 ID는 특정 그래픽 카드를 일치시키는 데 사용됩니다. &lt;code&gt;qtdiag&lt;/code&gt; 또는 &lt;code&gt;dxdiag&lt;/code&gt; 도구 의 출력에서 ​​찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fb035718de3f546b101a1bab19524ac4084d9838" translate="yes" xml:space="preserve">
          <source>It is possible to provide high resolution versions of images should a scaling between</source>
          <target state="translated">이미지 사이의 배율을 조정하면 고해상도 버전의 이미지를 제공 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="6633af5c997fb06b9dbeb56eec601ae68450b470" translate="yes" xml:space="preserve">
          <source>It is possible to recursively generate &lt;code&gt;.vcproj&lt;/code&gt; files in subdirectories and a &lt;code&gt;.sln&lt;/code&gt; file in the main directory, by typing:</source>
          <target state="translated">다음 을 입력하여 서브 디렉토리에서 &lt;code&gt;.vcproj&lt;/code&gt; 파일과 기본 디렉토리에서 &lt;code&gt;.sln&lt;/code&gt; 파일 을 재귀 적으로 생성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fffc49bccdceb851739293dca6d6af0357b4db26" translate="yes" xml:space="preserve">
          <source>It is possible to reduce the number of entries returned by &lt;a href=&quot;qdir#entryList&quot;&gt;entryList&lt;/a&gt;() and &lt;a href=&quot;qdir#entryInfoList&quot;&gt;entryInfoList&lt;/a&gt;() by applying filters to a &lt;a href=&quot;qdir&quot;&gt;QDir&lt;/a&gt; object. You can apply a name filter to specify a pattern with wildcards that file names need to match, an attribute filter that selects properties of entries and can distinguish between files and directories, and a sort order.</source>
          <target state="translated">&lt;a href=&quot;qdir&quot;&gt;QDir&lt;/a&gt; 오브젝트에 필터를 적용 하여 &lt;a href=&quot;qdir#entryList&quot;&gt;entryList&lt;/a&gt; () 및 &lt;a href=&quot;qdir#entryInfoList&quot;&gt;entryInfoList&lt;/a&gt; ()에 의해 리턴되는 항목 수를 줄일 수 있습니다. 이름 필터를 적용하여 파일 이름이 일치해야하는 와일드 카드, 항목의 속성을 선택하고 파일과 디렉토리를 구분할 수있는 속성 필터 및 정렬 순서로 패턴을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b0ae1750034f22f8b8ee35ddf32576e742239639" translate="yes" xml:space="preserve">
          <source>It is possible to reduce the number of entries returned by &lt;a href=&quot;qdir#entryList&quot;&gt;entryList&lt;/a&gt;() and &lt;a href=&quot;qdir#entryInfoList&quot;&gt;entryInfoList&lt;/a&gt;() by applying filters to a QDir object. You can apply a name filter to specify a pattern with wildcards that file names need to match, an attribute filter that selects properties of entries and can distinguish between files and directories, and a sort order.</source>
          <target state="translated">QDir 객체에 필터를 적용 하여 &lt;a href=&quot;qdir#entryList&quot;&gt;entryList&lt;/a&gt; () 및 &lt;a href=&quot;qdir#entryInfoList&quot;&gt;entryInfoList&lt;/a&gt; ()에 의해 반환되는 항목 수를 줄일 수 있습니다. 이름 필터를 적용하여 파일 이름이 일치해야하는 와일드 카드, 항목의 속성을 선택하고 파일과 디렉터리를 구분할 수있는 속성 필터 및 정렬 순서를 사용하여 패턴을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="54b91412914df51d9fba78e81327cbf979c92621" translate="yes" xml:space="preserve">
          <source>It is possible to repeat or reflect the gradient outside its area by specifiying the &lt;a href=&quot;qgradient#Spread-enum&quot;&gt;spread method&lt;/a&gt; using the &lt;a href=&quot;qgradient#setSpread&quot;&gt;setSpread&lt;/a&gt;() function. The default is to pad the outside area with the color at the closest stop point. The currently set &lt;a href=&quot;qgradient#Spread-enum&quot;&gt;spread method&lt;/a&gt; can be retrieved using the &lt;a href=&quot;qgradient#spread&quot;&gt;spread&lt;/a&gt;() function. The &lt;a href=&quot;qgradient#Spread-enum&quot;&gt;QGradient::Spread&lt;/a&gt; enum defines three different methods:</source>
          <target state="translated">&lt;a href=&quot;qgradient#setSpread&quot;&gt;setSpread&lt;/a&gt; () 함수를 사용하여 &lt;a href=&quot;qgradient#Spread-enum&quot;&gt;스프레드 방법&lt;/a&gt; 을 지정하여 영역 외부의 그래디언트를 반복하거나 반영 할 수 있습니다 . 기본값은 가장 가까운 정지 점에서 색상으로 외부 영역을 채우는 것입니다. &lt;a href=&quot;qgradient#spread&quot;&gt;spread&lt;/a&gt; () 함수를 사용하여 현재 설정된 &lt;a href=&quot;qgradient#Spread-enum&quot;&gt;스프레드 방법&lt;/a&gt; 을 검색 할 수 있습니다 . &lt;a href=&quot;qgradient#Spread-enum&quot;&gt;QGradient :: 확산&lt;/a&gt; 열거 세 가지 방법을 정의한다 :</target>
        </trans-unit>
        <trans-unit id="1c8602a7cf1778ac70c8617865e642dadce6ab15" translate="yes" xml:space="preserve">
          <source>It is possible to request a functions object for a different version and profile than that for which the context was created. To do this either use the template version of this function specifying the desired functions object type as the template parameter or by passing in a &lt;a href=&quot;qopenglversionprofile&quot;&gt;QOpenGLVersionProfile&lt;/a&gt; object as an argument to the non-template function.</source>
          <target state="translated">컨텍스트가 작성된 것과 다른 버전 및 프로파일에 대해 함수 오브젝트를 요청할 수 있습니다. 이를 수행하려면 원하는 함수 오브젝트 유형을 템플리트 매개 변수로 지정하거나 &lt;a href=&quot;qopenglversionprofile&quot;&gt;QOpenGLVersionProfile&lt;/a&gt; 오브젝트를 템플리트가 아닌 함수의 인수로 전달하여이 함수의 템플리트 버전을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="35d980ce985de291287a972c73847c777f7f36b2" translate="yes" xml:space="preserve">
          <source>It is possible to reserve a margin area around the viewport, see &lt;a href=&quot;qabstractscrollarea#setViewportMargins&quot;&gt;setViewportMargins&lt;/a&gt;(). The feature is mostly used to place a &lt;a href=&quot;qheaderview&quot;&gt;QHeaderView&lt;/a&gt; widget above or beside the scrolling area. Subclasses of &lt;a href=&quot;qabstractscrollarea&quot;&gt;QAbstractScrollArea&lt;/a&gt; should implement margins.</source>
          <target state="translated">뷰포트 주위에 여백 영역을 예약 할 수 있습니다 . &lt;a href=&quot;qabstractscrollarea#setViewportMargins&quot;&gt;setViewportMargins&lt;/a&gt; ()를 참조하십시오 . 이 기능은 주로 스크롤 영역 위 또는 옆에 &lt;a href=&quot;qheaderview&quot;&gt;QHeaderView&lt;/a&gt; 위젯 을 배치하는 데 사용됩니다 . &lt;a href=&quot;qabstractscrollarea&quot;&gt;QAbstractScrollArea의&lt;/a&gt; 서브 클래스는 마진을 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="7dc797f881085d2cf16eb8f26a2cdb95b916b785" translate="yes" xml:space="preserve">
          <source>It is possible to reserve a margin area around the viewport, see &lt;a href=&quot;qabstractscrollarea#setViewportMargins&quot;&gt;setViewportMargins&lt;/a&gt;(). The feature is mostly used to place a &lt;a href=&quot;qheaderview&quot;&gt;QHeaderView&lt;/a&gt; widget above or beside the scrolling area. Subclasses of QAbstractScrollArea should implement margins.</source>
          <target state="translated">뷰포트 주변에 여백 영역을 예약 할 수 있습니다 . &lt;a href=&quot;qabstractscrollarea#setViewportMargins&quot;&gt;setViewportMargins&lt;/a&gt; ()를 참조하십시오 . 이 기능은 주로 스크롤 영역 위나 옆에 &lt;a href=&quot;qheaderview&quot;&gt;QHeaderView&lt;/a&gt; 위젯 을 배치하는 데 사용됩니다 . QAbstractScrollArea의 서브 클래스는 여백을 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="6426f19b666d01b41794ebe8132f71f9930a0e3a" translate="yes" xml:space="preserve">
          <source>It is possible to set an item delegate to support custom widgets. By default, a &lt;a href=&quot;qitemdelegate&quot;&gt;QItemDelegate&lt;/a&gt; is used to synchronize the model with the widgets.</source>
          <target state="translated">사용자 정의 위젯을 지원하도록 항목 대리자를 설정할 수 있습니다. 기본적으로 &lt;a href=&quot;qitemdelegate&quot;&gt;QItemDelegate&lt;/a&gt; 는 모델을 위젯과 동기화하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="75e63a8576a859732fc8e6ed8a6f2c4e4da7012c" translate="yes" xml:space="preserve">
          <source>It is possible to set filters using &lt;a href=&quot;qsqltablemodel#setFilter&quot;&gt;setFilter&lt;/a&gt;(), or modify the sort order using &lt;a href=&quot;qsqltablemodel#setSort&quot;&gt;setSort&lt;/a&gt;(). At the end, you must call &lt;a href=&quot;qsqltablemodel#select&quot;&gt;select&lt;/a&gt;() to populate the model with data.</source>
          <target state="translated">&lt;a href=&quot;qsqltablemodel#setFilter&quot;&gt;setFilter&lt;/a&gt; ()를 사용하여 필터를 설정 하거나 &lt;a href=&quot;qsqltablemodel#setSort&quot;&gt;setSort&lt;/a&gt; ()를 사용하여 정렬 순서를 수정할 수 있습니다. 마지막으로 &lt;a href=&quot;qsqltablemodel#select&quot;&gt;select&lt;/a&gt; ()를 호출 하여 모델로 데이터를 채워야합니다.</target>
        </trans-unit>
        <trans-unit id="9b0991f502bfd33bc935f0420ebe469866dd0415" translate="yes" xml:space="preserve">
          <source>It is possible to set the height of characters shown on the screen to a specified number of pixels with &lt;a href=&quot;qfont#setPixelSize&quot;&gt;setPixelSize&lt;/a&gt;(); however using &lt;a href=&quot;qfont#setPointSize&quot;&gt;setPointSize&lt;/a&gt;() has a similar effect and provides device independence.</source>
          <target state="translated">&lt;a href=&quot;qfont#setPixelSize&quot;&gt;setPixelSize&lt;/a&gt; () 를 사용하여 화면에 표시되는 문자 높이를 지정된 픽셀 수로 설정할 수 있습니다 . 그러나 &lt;a href=&quot;qfont#setPointSize&quot;&gt;setPointSize&lt;/a&gt; ()를 사용하면 비슷한 효과가 있으며 장치 독립성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="5b120f9e45b516d6f6d8dfa7b0f6ca144ab10e9f" translate="yes" xml:space="preserve">
          <source>It is possible to specify a custom location for the configuration file with the &lt;a href=&quot;qtquickcontrols2-environment&quot;&gt;QT_QUICK_CONTROLS_CONF&lt;/a&gt; environment variable.</source>
          <target state="translated">&lt;a href=&quot;qtquickcontrols2-environment&quot;&gt;QT_QUICK_CONTROLS_CONF&lt;/a&gt; 환경 변수 를 사용하여 구성 파일의 사용자 지정 위치를 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a97b9ec23c4aa079171f977f41276de2ec57cded" translate="yes" xml:space="preserve">
          <source>It is possible to specify a custom location for the configuration file with the &lt;a href=&quot;qtquickcontrols2-environment#&quot;&gt;QT_QUICK_CONTROLS_CONF&lt;/a&gt; environment variable.</source>
          <target state="translated">&lt;a href=&quot;qtquickcontrols2-environment#&quot;&gt;QT_QUICK_CONTROLS_CONF&lt;/a&gt; 환경 변수 를 사용하여 구성 파일의 사용자 정의 위치를 ​​지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4dd7a93b793e557e9a79cd04a2b29090ea9d58b8" translate="yes" xml:space="preserve">
          <source>It is possible to specify multiple index files from several projects.</source>
          <target state="translated">여러 프로젝트에서 여러 색인 파일을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f741c21b65d6cf8a3194636c17aee74105654478" translate="yes" xml:space="preserve">
          <source>It is possible to supply a source string template like:</source>
          <target state="translated">다음과 같은 소스 문자열 템플릿을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b2014ffcf4ae3fd31f280b7ecedbb05458687282" translate="yes" xml:space="preserve">
          <source>It is possible to turn off compression, if desired. This can be useful if your resources already contain a compressed format, such as &lt;code&gt;.png&lt;/code&gt; files, and you do not want to incur the CPU cost at build time to confirm that it can't be compressed. Another reason is if disk usage is not a problem and the application would prefer to keep the content as clean memory pages at runtime. You do this by giving the &lt;code&gt;-no-compress&lt;/code&gt; command line argument.</source>
          <target state="translated">원하는 경우 압축을 해제 할 수 있습니다. 리소스에 &lt;code&gt;.png&lt;/code&gt; 파일 과 같은 압축 된 형식이 이미 포함되어 있고 빌드 할 때 CPU 비용이 발생하여 압축 할 수 없는지 확인하려는 경우에 유용 할 수 있습니다 . 또 다른 이유는 디스크 사용에 문제가없고 애플리케이션이 런타임시 컨텐츠를 깨끗한 메모리 페이지로 유지하는 것을 선호하기 때문입니다. &lt;code&gt;-no-compress&lt;/code&gt; 명령 행 인수 를 제공하여이를 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="56c39908e2a631fd6d55afbd26e8cf3d586ca99e" translate="yes" xml:space="preserve">
          <source>It is possible to use Qt with a 3rd party signal/slot mechanism. You can even use both mechanisms in the same project. Just add the following line to your qmake project (.pro) file.</source>
          <target state="translated">타사 신호 / 슬롯 메커니즘과 함께 Qt를 사용할 수 있습니다. 동일한 프로젝트에서 두 메커니즘을 모두 사용할 수도 있습니다. qmake 프로젝트 (.pro) 파일에 다음 줄을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="5ad9880696e514c9cab8fcbfb44f2a1df0ca39ef" translate="yes" xml:space="preserve">
          <source>It is possible to use launch images (PNG files), as described below, to support the iPhone 6, but it is not recommended. Qmake generates a default LaunchScreen.xib, so it is better to use another name for a custom launch screen to avoid clashes.</source>
          <target state="translated">iPhone 6을 지원하기 위해 아래에 설명 된대로 시작 이미지 (PNG 파일)를 사용할 수 있지만 권장되지는 않습니다. Qmake는 기본 LaunchScreen.xib를 생성하므로 충돌을 피하기 위해 사용자 정의 시작 화면에 다른 이름을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="05ec2650a6df8238d9013e80572a0328325f6d88" translate="yes" xml:space="preserve">
          <source>It is preferable to use standard shortcuts where possible. When creating key sequences for non-standard shortcuts, you should use human-readable strings in preference to hard-coded integer values.</source>
          <target state="translated">가능한 경우 표준 바로 가기를 사용하는 것이 좋습니다. 비표준 바로 가기 키 시퀀스를 만들 때는 하드 코딩 된 정수 값보다 사람이 읽을 수있는 문자열을 우선적으로 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="fa9ea897f1945c20e4afbfbc3d0fd92017690d8f" translate="yes" xml:space="preserve">
          <source>It is provided so that index overflows can be corrected when using the cache as a circular buffer.</source>
          <target state="translated">캐시를 순환 버퍼로 사용할 때 인덱스 오버 플로우를 정정 할 수 있도록 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="adbf8655f8e49caaba7f8077b52ce062b0558e88" translate="yes" xml:space="preserve">
          <source>It is recommended that all custom URL schemes are first registered with this function at application startup, even if the default options are to be used.</source>
          <target state="translated">기본 옵션을 사용하더라도 응용 프로그램을 시작할 때 모든 사용자 정의 URL 체계를이 기능으로 먼저 등록하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="78c7ddc2863ed3dd8db0ef7ade2b5563865659bc" translate="yes" xml:space="preserve">
          <source>It is recommended that the delegate's size be a whole number to avoid sub-pixel alignment of items.</source>
          <target state="translated">하위 픽셀 정렬 항목을 피하기 위해 델리게이트의 크기는 정수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="baf83cf8c69296840d648ac4b793607b0fb7f605" translate="yes" xml:space="preserve">
          <source>It is recommended that the project file in each subdirectory has the same base name as the subdirectory itself, because that makes it possible to omit the file name. For example, if the subdirectory is called &lt;code&gt;myapp&lt;/code&gt;, the project file in that directory should be called &lt;code&gt;myapp.pro&lt;/code&gt;.</source>
          <target state="translated">각 서브 디렉토리의 프로젝트 파일은 서브 디렉토리 자체와 동일한 기본 이름을 갖는 것이 좋습니다. 파일 이름을 생략 할 수 있기 때문입니다. 예를 들어, 서브 디렉토리가 &lt;code&gt;myapp&lt;/code&gt; 인 경우 해당 디렉토리 의 프로젝트 파일은 &lt;code&gt;myapp.pro&lt;/code&gt; 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="cc812bb9330e642f8905ff72b12eb9398211c767" translate="yes" xml:space="preserve">
          <source>It is recommended that the styles do not alter the proposed size of widgets with the &lt;a href=&quot;qstyle#sizeFromContents&quot;&gt;QStyle::sizeFromContents&lt;/a&gt;() function, but let the &lt;a href=&quot;qcommonstyle&quot;&gt;QCommonStyle&lt;/a&gt; implementation handle it instead. If changes need to be made, you should try to keep them small; application development may be difficult if the layout of widgets looks considerably different in the various styles.</source>
          <target state="translated">스타일은 &lt;a href=&quot;qstyle#sizeFromContents&quot;&gt;QStyle :: sizeFromContents&lt;/a&gt; () 함수를 사용 하여 제안 된 위젯 크기를 변경하지 않고 &lt;a href=&quot;qcommonstyle&quot;&gt;QCommonStyle&lt;/a&gt; 구현이 대신 처리하도록하는 것이 좋습니다. 변경이 필요한 경우 변경을 작게 유지해야합니다. 위젯의 레이아웃이 다양한 스타일에서 상당히 다르게 보이는 경우 응용 프로그램 개발이 어려울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a196675e3702d63bb79a5566780549020d651ea" translate="yes" xml:space="preserve">
          <source>It is recommended that you try to avoid multiple top-level windows in the case of Android apps, as there is no traditional window system on this platform.</source>
          <target state="translated">이 플랫폼에는 전통적인 윈도우 시스템이 없으므로 Android 앱의 경우 여러 최상위 윈도우를 피하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="44be777eb01da3028921fd8768e1ae895b5b8379" translate="yes" xml:space="preserve">
          <source>It is recommended that you use unixODBC. You can find the latest version and ODBC drivers at &lt;a href=&quot;http://www.unixodbc.org&quot;&gt;http://www.unixodbc.org&lt;/a&gt;. You need the unixODBC header files and shared libraries.</source>
          <target state="translated">unixODBC를 사용하는 것이 좋습니다. 최신 버전 및 ODBC 드라이버는 &lt;a href=&quot;http://www.unixodbc.org&quot;&gt;http://www.unixodbc.org&lt;/a&gt; 에서 찾을 수 있습니다 . unixODBC 헤더 파일 및 공유 라이브러리가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="339c1eab3d6d724ace0be1b0cc1282b7bcaf9ecc" translate="yes" xml:space="preserve">
          <source>It is recommended to build Qt 5 using a</source>
          <target state="translated">Qt 5를 사용하여 빌드하는 것이 좋습니다</target>
        </trans-unit>
        <trans-unit id="c6dee651fb40f992dec56cf4fa999cdfc3a9cdb9" translate="yes" xml:space="preserve">
          <source>It is recommended to disable the cache when the source or the effect properties are animated.</source>
          <target state="translated">소스 또는 효과 속성에 애니메이션이 적용되는 경우 캐시를 비활성화하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="3f8efdfe1605c92c751763ef748fbd14f3f4bca3" translate="yes" xml:space="preserve">
          <source>It is recommended to keep these directories separate by shadow-building and using the &lt;code&gt;-prefix&lt;/code&gt; option. This enables you to keep the Qt</source>
          <target state="translated">새도우 빌드 및 &lt;code&gt;-prefix&lt;/code&gt; 옵션을 사용하여 이러한 디렉토리를 분리하는 것이 좋습니다 . 이를 통해 Qt를 유지할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="0c492a720f4fa9f113504a0a8a9a1947829e5019" translate="yes" xml:space="preserve">
          <source>It is recommended to restrict the usage of QOpenGLContexts created this way. Various platform-specific behavior and issues may prevent such contexts to be made current with windows (surfaces) created by Qt due to non-matching pixel formats for example. A potentially safer solution is to use the wrapped context only to set up sharing and perform Qt-based rendering offscreen, using a separate, dedicated &lt;a href=&quot;qopenglcontext&quot;&gt;QOpenGLContext&lt;/a&gt;. The resulting textures are then accessible in the foreign context too.</source>
          <target state="translated">이 방법으로 작성된 QOpenGLContexts의 사용을 제한하는 것이 좋습니다. 다양한 플랫폼 별 동작 및 문제로 인해 이러한 컨텍스트가 일치하지 않는 픽셀 형식으로 인해 Qt에서 만든 창 (표면)으로 최신 상태가되지 않을 수 있습니다. 잠재적으로 안전한 솔루션은 랩핑 된 컨텍스트 만 사용하여 별도의 전용 &lt;a href=&quot;qopenglcontext&quot;&gt;QOpenGLContext를&lt;/a&gt; 사용하여 공유를 설정하고 Qt 기반 렌더링 오프 스크린을 수행하는 것 입니다. 결과 텍스처는 외부 컨텍스트에서도 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="80338d71c593317d44dc5f10fad0aae8878ec321" translate="yes" xml:space="preserve">
          <source>It is recommended to store the QML type id during registration, e.g. as a static member in the singleton class. Otherwise, a costly lookup via &lt;a href=&quot;qqmlengine#qmlTypeId&quot;&gt;qmlTypeId&lt;/a&gt;() has to be performed at run-time.</source>
          <target state="translated">등록하는 동안 QML 유형 ID를 저장하는 것이 좋습니다 (예 : 싱글 톤 클래스의 정적 멤버). 그렇지 않으면 &lt;a href=&quot;qqmlengine#qmlTypeId&quot;&gt;qmlTypeId&lt;/a&gt; () 를 통한 비용이 많이 드는 조회를 런타임에 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="07c19ca8baa40c260fe400e16525b4a2b127c9ca" translate="yes" xml:space="preserve">
          <source>It is recommended to store the QML type id, e.g. as a static member in the singleton class. The lookup via &lt;a href=&quot;qqmlengine#qmlTypeId&quot;&gt;qmlTypeId&lt;/a&gt;() is costly.</source>
          <target state="translated">예를 들어 싱글 톤 클래스의 정적 멤버로 QML 유형 ID를 저장하는 것이 좋습니다. &lt;a href=&quot;qqmlengine#qmlTypeId&quot;&gt;qmlTypeId&lt;/a&gt; () 를 통한 조회 는 비용이 많이 듭니다.</target>
        </trans-unit>
        <trans-unit id="56e4e7198dca270dabf978e28be77f77c6d341e0" translate="yes" xml:space="preserve">
          <source>It is recommended to unset this property when developer tools are not visible; otherwise some debug information may appear in the inspected &lt;a href=&quot;qml-qtwebengine-webengineview&quot;&gt;WebEngineView&lt;/a&gt;.</source>
          <target state="translated">개발자 도구가 보이지 않으면이 속성을 설정 해제하는 것이 좋습니다. 그렇지 않으면 검사 된 &lt;a href=&quot;qml-qtwebengine-webengineview&quot;&gt;WebEngineView&lt;/a&gt; 에 일부 디버그 정보가 나타날 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ead83bf8189f3ea91b5a531707aa69f2d414ac1b" translate="yes" xml:space="preserve">
          <source>It is recommended to use &lt;a href=&quot;qml-qtquick-controls2-itemdelegate&quot;&gt;ItemDelegate&lt;/a&gt; (or any other &lt;a href=&quot;qml-qtquick-controls2-abstractbutton&quot;&gt;AbstractButton&lt;/a&gt; derivatives) as the delegate. This ensures that the interaction works as expected, and the popup will automatically close when appropriate. When other types are used as the delegate, the popup must be closed manually. For example, if &lt;a href=&quot;qml-qtquick-mousearea&quot;&gt;MouseArea&lt;/a&gt; is used:</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-controls2-itemdelegate&quot;&gt;ItemDelegate&lt;/a&gt; (또는 다른 &lt;a href=&quot;qml-qtquick-controls2-abstractbutton&quot;&gt;AbstractButton&lt;/a&gt; 파생)를 대리자 로 사용하는 것이 좋습니다 . 이를 통해 상호 작용이 예상대로 작동하고 팝업이 필요할 때 자동으로 닫힙니다. 다른 유형을 대리자로 사용하는 경우 팝업을 수동으로 닫아야합니다. 예를 들어 &lt;a href=&quot;qml-qtquick-mousearea&quot;&gt;MouseArea&lt;/a&gt; 를 사용하는 경우 :</target>
        </trans-unit>
        <trans-unit id="a0b2cd38500cfcd5ea6fad7c5d9cb28189c49791" translate="yes" xml:space="preserve">
          <source>It is recommended to use this function to prevent expensive notifications via &lt;a href=&quot;qaccessible#updateAccessibility&quot;&gt;updateAccessibility&lt;/a&gt;() when they are not needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cc6a905f9fb02c8c95a035498d110f9b7aece9f" translate="yes" xml:space="preserve">
          <source>It is recommended to use this function to prevent expensive notifications via updateAccessibility() when they are not needed.</source>
          <target state="translated">필요하지 않은 경우 updateAccessibility ()를 통한 고가의 알림을 방지하려면이 함수를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="a7a8b630c0e0caaf8871c9db4b8ad4381c8abfb6" translate="yes" xml:space="preserve">
          <source>It is recommended to use this instead of &lt;a href=&quot;qprinterinfo#availablePrinters&quot;&gt;availablePrinters&lt;/a&gt;() as it will be faster on most systems.</source>
          <target state="translated">대부분의 시스템에서 더 빠를 수 있기 때문에 &lt;a href=&quot;qprinterinfo#availablePrinters&quot;&gt;availablePrinters&lt;/a&gt; () 대신 이것을 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="a7dbc8e02f806ff4f344925e5d01daa2271c7314" translate="yes" xml:space="preserve">
          <source>It is relevant when the role is &lt;a href=&quot;qaccessible#Role-enum&quot;&gt;QAccessible::EditableText&lt;/a&gt; and set to be read-only. By default this property is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">역할이 &lt;a href=&quot;qaccessible#Role-enum&quot;&gt;QAccessible :: EditableText&lt;/a&gt; 이고 읽기 전용으로 설정된 경우에 관련 됩니다. 기본적으로이 속성은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ce272aafea9d127aac2714325412a18186055aba" translate="yes" xml:space="preserve">
          <source>It is returned as a &lt;a href=&quot;qprocessenvironment&quot;&gt;QProcessEnvironment&lt;/a&gt;. This function does not cache the system environment. Therefore, it's possible to obtain an updated version of the environment if low-level C library functions like &lt;code&gt;setenv&lt;/code&gt; or &lt;code&gt;putenv&lt;/code&gt; have been called.</source>
          <target state="translated">&lt;a href=&quot;qprocessenvironment&quot;&gt;QProcessEnvironment&lt;/a&gt; 로 리턴됩니다 . 이 기능은 시스템 환경을 캐시하지 않습니다. 따라서 &lt;code&gt;setenv&lt;/code&gt; 또는 &lt;code&gt;putenv&lt;/code&gt; 와 같은 저수준 C 라이브러리 함수 가 호출 된 경우 업데이트 된 버전의 환경을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="41c8008152f562cd0b0ae8aa789ff33ad86794c0" translate="yes" xml:space="preserve">
          <source>It is safe to access properties of the associated &lt;a href=&quot;qabstractvideofilter&quot;&gt;QAbstractVideoFilter&lt;/a&gt; instance from this function.</source>
          <target state="translated">이 함수에서 관련 &lt;a href=&quot;qabstractvideofilter&quot;&gt;QAbstractVideoFilter&lt;/a&gt; 인스턴스의 속성에 액세스하는 것이 안전 합니다.</target>
        </trans-unit>
        <trans-unit id="fc08ab1ecd65e0107a8d8e1b3f98adb32372b467" translate="yes" xml:space="preserve">
          <source>It is safe to call this function multiple times from the same context.</source>
          <target state="translated">동일한 컨텍스트에서이 함수를 여러 번 호출하는 것이 안전합니다.</target>
        </trans-unit>
        <trans-unit id="aae1b13febc579890c2bfc6adb3b816cd224eed9" translate="yes" xml:space="preserve">
          <source>It is safe to delete a &lt;a href=&quot;qdnslookup&quot;&gt;QDnsLookup&lt;/a&gt; object even if it is not finished, you will simply never receive its results.</source>
          <target state="translated">완료되지 않은 경우에도 &lt;a href=&quot;qdnslookup&quot;&gt;QDnsLookup&lt;/a&gt; 객체 를 삭제하는 것이 안전 합니다. 결과를받지 못할 것입니다.</target>
        </trans-unit>
        <trans-unit id="1d20f02a0afbaef4162a3f39317e9284f045e7f7" translate="yes" xml:space="preserve">
          <source>It is safe to use this feature even with code compiled without the feature. &lt;a href=&quot;qsharedpointer&quot;&gt;QSharedPointer&lt;/a&gt; will ensure that the pointer is removed from the tracker even from code compiled without pointer tracking.</source>
          <target state="translated">기능없이 컴파일 된 코드에서도이 기능을 사용하는 것이 안전합니다. &lt;a href=&quot;qsharedpointer&quot;&gt;QSharedPointer&lt;/a&gt; 는 포인터 추적없이 컴파일 된 코드에서도 포인터가 추적기에서 제거되도록합니다.</target>
        </trans-unit>
        <trans-unit id="6d6cb32b82d4f6b2691c9ab86b7b662c798ef7d9" translate="yes" xml:space="preserve">
          <source>It is safe to use this feature even with code compiled without the feature. QSharedPointer will ensure that the pointer is removed from the tracker even from code compiled without pointer tracking.</source>
          <target state="translated">기능없이 컴파일 된 코드로도이 기능을 사용하는 것이 안전합니다. QSharedPointer는 포인터 추적없이 컴파일 된 코드에서도 추적기에서 포인터가 제거되도록합니다.</target>
        </trans-unit>
        <trans-unit id="9bc9703cc8c19891ddda44a312e928336c2e4992" translate="yes" xml:space="preserve">
          <source>It is simple to construct a tree view displaying data from a model. In the following example, the contents of a directory are supplied by a &lt;a href=&quot;qfilesystemmodel&quot;&gt;QFileSystemModel&lt;/a&gt; and displayed as a tree:</source>
          <target state="translated">모델의 데이터를 표시하는 트리 뷰를 구성하는 것은 간단합니다. 다음 예제에서 디렉토리의 내용은 &lt;a href=&quot;qfilesystemmodel&quot;&gt;QFileSystemModel&lt;/a&gt; 에 의해 제공되며 트리로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="469994c0d20a35e8ac1a59244c93cff450232624" translate="yes" xml:space="preserve">
          <source>It is simply a typedef for &lt;code&gt;std::reverse_iterator&amp;lt;QLinkedList::const_iterator&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">단순히 &lt;code&gt;std::reverse_iterator&amp;lt;QLinkedList::const_iterator&amp;gt;&lt;/code&gt; 의 typedef입니다 .</target>
        </trans-unit>
        <trans-unit id="f05929b58b72ba6f8215e6be6305d14c945bf50e" translate="yes" xml:space="preserve">
          <source>It is simply a typedef for &lt;code&gt;std::reverse_iterator&amp;lt;QLinkedList::iterator&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">단순히 &lt;code&gt;std::reverse_iterator&amp;lt;QLinkedList::iterator&amp;gt;&lt;/code&gt; 의 typedef입니다 .</target>
        </trans-unit>
        <trans-unit id="7adb3f514f28a10c1b894998b1ffe592387d358f" translate="yes" xml:space="preserve">
          <source>It is simply a typedef for &lt;code&gt;std::reverse_iterator&amp;lt;QSet::const_iterator&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">단순히 &lt;code&gt;std::reverse_iterator&amp;lt;QSet::const_iterator&amp;gt;&lt;/code&gt; 의 typedef입니다 .</target>
        </trans-unit>
        <trans-unit id="82d20bcd8deaea9a970944740ca614654b3b23b5" translate="yes" xml:space="preserve">
          <source>It is simply a typedef for &lt;code&gt;std::reverse_iterator&amp;lt;QSet::iterator&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">단순히 &lt;code&gt;std::reverse_iterator&amp;lt;QSet::iterator&amp;gt;&lt;/code&gt; 의 typedef입니다 .</target>
        </trans-unit>
        <trans-unit id="81314285fc40db886de573c546bc3207af7fe535" translate="yes" xml:space="preserve">
          <source>It is simply a typedef for &lt;code&gt;std::reverse_iterator&amp;lt;T*&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">단순히 &lt;code&gt;std::reverse_iterator&amp;lt;T*&amp;gt;&lt;/code&gt; 의 typedef입니다 .</target>
        </trans-unit>
        <trans-unit id="a7a9dfc4740fbb00f43015215edf4b7ec85d5925" translate="yes" xml:space="preserve">
          <source>It is simply a typedef for &lt;code&gt;std::reverse_iterator&amp;lt;const T*&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">단순히 &lt;code&gt;std::reverse_iterator&amp;lt;const T*&amp;gt;&lt;/code&gt; 의 typedef입니다 .</target>
        </trans-unit>
        <trans-unit id="feb45b9497c2dd9d2e76702fb6e871af7e517c87" translate="yes" xml:space="preserve">
          <source>It is simply a typedef for &lt;code&gt;std::reverse_iterator&amp;lt;const_iterator&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">단순히 &lt;code&gt;std::reverse_iterator&amp;lt;const_iterator&amp;gt;&lt;/code&gt; 의 typedef입니다 .</target>
        </trans-unit>
        <trans-unit id="431a580c6160d9bd48ada33ae57793812a24a1df" translate="yes" xml:space="preserve">
          <source>It is simply a typedef for &lt;code&gt;std::reverse_iterator&amp;lt;iterator&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">단순히 &lt;code&gt;std::reverse_iterator&amp;lt;iterator&amp;gt;&lt;/code&gt; 의 typedef입니다 .</target>
        </trans-unit>
        <trans-unit id="7b41ef32e71627bcdf7890579f808a6aa41c71d2" translate="yes" xml:space="preserve">
          <source>It is sometimes necessary to be able to show a path in the native representation for the user's platform. The static &lt;a href=&quot;qdir#toNativeSeparators&quot;&gt;toNativeSeparators&lt;/a&gt;() function returns a copy of the specified path in which each directory separator is replaced by the appropriate separator for the underlying operating system.</source>
          <target state="translated">때때로 사용자 플랫폼의 기본 표현에 경로를 표시 할 수 있어야합니다. static &lt;a href=&quot;qdir#toNativeSeparators&quot;&gt;toNativeSeparators&lt;/a&gt; () 함수는 각 디렉토리 분리자가 기본 운영 체제에 대한 적절한 분리 자로 대체되는 지정된 경로의 사본을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="dccac8ee753bb7d08d70e1f70a577f0f24841635" translate="yes" xml:space="preserve">
          <source>It is sometimes necessary to delay the destruction of an item until an animation completes. The example delegate below ensures that the animation completes before the item is removed from the list.</source>
          <target state="translated">애니메이션이 완료 될 때까지 항목 파괴를 지연해야하는 경우가 있습니다. 아래의 델리게이트 예제는 항목이 목록에서 제거되기 전에 애니메이션이 완료되도록합니다.</target>
        </trans-unit>
        <trans-unit id="6e03c95e7f694a97d774299c92fb95e37fb47182" translate="yes" xml:space="preserve">
          <source>It is sometimes necessary to provide internationalization support for strings used in classes that do not inherit &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; or use the &lt;a href=&quot;qobject#Q_OBJECT&quot;&gt;Q_OBJECT&lt;/a&gt; macro to enable translation features. Since Qt translates strings at run-time based on the class they are associated with and &lt;code&gt;lupdate&lt;/code&gt; looks for translatable strings in the source code, non-Qt classes must use mechanisms that also provide this information.</source>
          <target state="translated">&lt;a href=&quot;qobject&quot;&gt;QObject를&lt;/a&gt; 상속하지 않거나 &lt;a href=&quot;qobject#Q_OBJECT&quot;&gt;Q_OBJECT&lt;/a&gt; 매크로를 사용하여 변환 기능을 사용 가능하게 하지 않는 클래스에 사용 된 문자열에 대한 국제화 지원을 제공 해야하는 경우가 있습니다. Qt는 연관된 클래스를 기반으로 런타임에 문자열을 변환하고 &lt;code&gt;lupdate&lt;/code&gt; 는 소스 코드에서 번역 가능한 문자열을 검색하므로 Qt가 아닌 클래스는이 정보를 제공하는 메커니즘을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="d633961314a15745707044a8af6709cefd965b5f" translate="yes" xml:space="preserve">
          <source>It is sometimes useful to be able to hide items in an item view widget rather than remove them. Items for all of the above widgets can be hidden and later shown again. You can determine whether an item is hidden by calling the isItemHidden() function, and items can be hidden with &lt;code&gt;setItemHidden()&lt;/code&gt;.</source>
          <target state="translated">항목보기 위젯에서 항목을 제거하지 않고 숨길 수있는 경우가 종종 있습니다. 위의 모든 위젯에 대한 항목을 숨기고 나중에 다시 표시 할 수 있습니다. 당신은 항목이 isItemHidden () 함수를 호출하여 숨겨져 있는지 여부를 확인 할 수 있으며, 항목으로 숨길 수 있습니다 &lt;code&gt;setItemHidden()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="58e3a17abee31487c9241aeb3e073067cf4030dc" translate="yes" xml:space="preserve">
          <source>It is sometimes useful to limit the files and directories exposed to those that the user can access. The &lt;a href=&quot;qml-qt-labs-folderlistmodel-folderlistmodel#showOnlyReadable-prop&quot;&gt;showOnlyReadable&lt;/a&gt; property can be set to enable this feature.</source>
          <target state="translated">때때로 사용자가 액세스 할 수있는 파일 및 디렉토리를 제한하는 것이 유용합니다. &lt;a href=&quot;qml-qt-labs-folderlistmodel-folderlistmodel#showOnlyReadable-prop&quot;&gt;showOnlyReadable&lt;/a&gt; 속성은이 기능을 사용하도록 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3e49376b823a0359c043b48488c665f5b32cd35f" translate="yes" xml:space="preserve">
          <source>It is sometimes useful to respond to property changes as events. For example, you might want to display a user notification when a certain property change occurs. However, this user notification would then also be triggered when a replica first became &lt;code&gt;QRemoteObjectReplica::Valid&lt;/code&gt;, as all property change signals are emitted at that time. This isn't always desirable, and &lt;code&gt;notified&lt;/code&gt; allows the developer to distinguish between these two cases.</source>
          <target state="translated">속성 변경에 이벤트로 응답하는 것이 유용한 경우가 있습니다. 예를 들어 특정 속성 변경이 발생하면 사용자 알림을 표시 할 수 있습니다. 그러나이 사용자 알림은 복제본이 처음 &lt;code&gt;QRemoteObjectReplica::Valid&lt;/code&gt; 가 될 때도 트리거됩니다. 그 때 모든 속성 변경 신호가 방출되기 때문입니다. 이것이 항상 바람직한 것은 아니며 &lt;code&gt;notified&lt;/code&gt; 통해 개발자가이 두 경우를 구분할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2744524e31f7e53251513a310af52e486bd7d35f" translate="yes" xml:space="preserve">
          <source>It is sometimes useful to update the splash screen with messages, for example, announcing connections established or modules loaded as the application starts up:</source>
          <target state="translated">응용 프로그램이 시작될 때 연결이 설정되었거나로드 된 모듈을 알리는 등의 메시지로 스플래시 화면을 업데이트하는 것이 유용한 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="64ea90c9389d4ca6354bed0e0a5139515ac688d3" translate="yes" xml:space="preserve">
          <source>It is strongly recommended to verify that the gamepad's input device is present, and is sending events, via the &lt;code&gt;lsinput&lt;/code&gt; and &lt;code&gt;evtest&lt;/code&gt; utilities.</source>
          <target state="translated">&lt;code&gt;lsinput&lt;/code&gt; 및 &lt;code&gt;evtest&lt;/code&gt; 유틸리티 를 통해 게임 패드의 입력 장치가 있고 이벤트를 보내는 지 확인하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="660e4eb65312921ad18fc5b66111fb6ac1896c24" translate="yes" xml:space="preserve">
          <source>It is the caller's responsibility to free the &lt;code&gt;HBITMAP&lt;/code&gt; data after use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5efdffc4dbea680dc862d37c66350aa1e834b340" translate="yes" xml:space="preserve">
          <source>It is the caller's responsibility to free the &lt;code&gt;HICON&lt;/code&gt; data after use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4abce180d73f49d71eb8e4e1800723c0e3af5ee0" translate="yes" xml:space="preserve">
          <source>It is the caller's responsibility to release the &lt;code&gt;CGImageRef&lt;/code&gt; data after use.</source>
          <target state="translated">사용 후 &lt;code&gt;CGImageRef&lt;/code&gt; 데이터 를 해제하는 것은 호출자의 책임 입니다.</target>
        </trans-unit>
        <trans-unit id="7b3536c908df0425a65a5fecb52be405e775ae05" translate="yes" xml:space="preserve">
          <source>It is the caller's responsibility to release the &lt;code&gt;NSImage&lt;/code&gt; data after use.</source>
          <target state="translated">사용 후 &lt;code&gt;NSImage&lt;/code&gt; 데이터 를 해제하는 것은 호출자의 책임 입니다.</target>
        </trans-unit>
        <trans-unit id="c7e26b266ae865f4585e1113f95a8f417fbf1a84" translate="yes" xml:space="preserve">
          <source>It is the gradient's complete set of stop points (accessible through the &lt;a href=&quot;qgradient#stops&quot;&gt;stops&lt;/a&gt;() function) that describes how the gradient area should be filled. If no stop points have been specified, a gradient of black at 0 to white at 1 is used.</source>
          <target state="translated">그것은합니다 (통해 액세스 정지 점의 기울기의 전체 집합입니다 &lt;a href=&quot;qgradient#stops&quot;&gt;정거장&lt;/a&gt; () 함수) 그라데이션 영역이 채워 져야하는 방법을 설명하는. 정지 점이 지정되지 않은 경우 0에서 검은 색에서 1에서 흰색의 기울기가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5eaf6f9949bc04b1998876e2392c93c7ccd6bcf0" translate="yes" xml:space="preserve">
          <source>It is the order of the elements that is reversed: If a &lt;a href=&quot;qpainterpath&quot;&gt;QPainterPath&lt;/a&gt; is composed by calling the &lt;a href=&quot;qpainterpath#moveTo&quot;&gt;moveTo&lt;/a&gt;(), &lt;a href=&quot;qpainterpath#lineTo&quot;&gt;lineTo&lt;/a&gt;() and &lt;a href=&quot;qpainterpath#cubicTo&quot;&gt;cubicTo&lt;/a&gt;() functions in the specified order, the reversed copy is composed by calling &lt;a href=&quot;qpainterpath#cubicTo&quot;&gt;cubicTo&lt;/a&gt;(), &lt;a href=&quot;qpainterpath#lineTo&quot;&gt;lineTo&lt;/a&gt;() and &lt;a href=&quot;qpainterpath#moveTo&quot;&gt;moveTo&lt;/a&gt;().</source>
          <target state="translated">이것은 반전 요소의 순서는 다음과하면 &lt;a href=&quot;qpainterpath&quot;&gt;QPainterPath이&lt;/a&gt; 호출에 의해 구성된다 &lt;a href=&quot;qpainterpath#moveTo&quot;&gt;의 moveTo&lt;/a&gt; () &lt;a href=&quot;qpainterpath#lineTo&quot;&gt;에 lineTo&lt;/a&gt; () 및 &lt;a href=&quot;qpainterpath#cubicTo&quot;&gt;cubicTo&lt;/a&gt; () 지정된 순서 기능, 반전 된 복사본을 호출하여 구성된다 &lt;a href=&quot;qpainterpath#cubicTo&quot;&gt;cubicTo&lt;/a&gt; () &lt;a href=&quot;qpainterpath#lineTo&quot;&gt;에 lineTo을&lt;/a&gt; () 및 &lt;a href=&quot;qpainterpath#moveTo&quot;&gt;moveTo&lt;/a&gt; ().</target>
        </trans-unit>
        <trans-unit id="3c64376141c1254f880bd9be46bbfdd2d0b95adc" translate="yes" xml:space="preserve">
          <source>It is the programmer's responsibility to specify which stack is active by calling &lt;a href=&quot;qundostack#active-prop&quot;&gt;QUndoStack::setActive&lt;/a&gt;(), usually when the associated document window receives focus. The active stack may also be set with &lt;a href=&quot;qundogroup#setActiveStack&quot;&gt;setActiveStack&lt;/a&gt;(), and is returned by &lt;a href=&quot;qundogroup#activeStack&quot;&gt;activeStack&lt;/a&gt;().</source>
          <target state="translated">일반적으로 관련 문서 창이 포커스를받을 때 &lt;a href=&quot;qundostack#active-prop&quot;&gt;QUndoStack :: setActive&lt;/a&gt; () 를 호출하여 활성화 할 스택을 지정하는 것은 프로그래머의 책임 입니다. 활성 스택은 &lt;a href=&quot;qundogroup#setActiveStack&quot;&gt;setActiveStack&lt;/a&gt; () 으로 설정 될 수도 있으며 &lt;a href=&quot;qundogroup#activeStack&quot;&gt;activeStack&lt;/a&gt; ()에 의해 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="475f36a5a8b3a7018cd262241e3298beb6f897f8" translate="yes" xml:space="preserve">
          <source>It is the programmer's responsibility to specify which stack is active by calling setActive(), usually when the associated document window receives focus.</source>
          <target state="translated">일반적으로 관련 문서 창이 포커스를받을 때 setActive ()를 호출하여 활성화 할 스택을 지정하는 것은 프로그래머의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="22ecd0f2f3c0b76414c37afe7bd229960f952cd1" translate="yes" xml:space="preserve">
          <source>It is the responsibility of the delegate to manage the editor's geometry. The geometry must be set when the editor is created, and when the item's size or position in the view is changed. Fortunately, the view provides all the necessary geometry information inside a &lt;a href=&quot;qstyleoptionviewitem&quot;&gt;view option&lt;/a&gt; object.</source>
          <target state="translated">편집자의 지오메트리를 관리하는 것은 대의원의 책임입니다. 편집기를 만들 때와보기에서 항목의 크기 나 위치가 변경 될 때 형상을 설정해야합니다. 다행히 뷰는 &lt;a href=&quot;qstyleoptionviewitem&quot;&gt;뷰 옵션&lt;/a&gt; 객체 내부에 필요한 모든 지오메트리 정보를 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="f9f8ebb8ef3ae6bc29b2939799389604e1d10322" translate="yes" xml:space="preserve">
          <source>It is the style that draws the headers of Qt's item views. The item views keep the dimensions on individual sections. Also note that the delegates may use the style to paint decorations and frames around items. &lt;a href=&quot;qitemdelegate&quot;&gt;QItemDelegate&lt;/a&gt;, for instance, draws &lt;code&gt;PE_FrameFocusRect&lt;/code&gt; and &lt;code&gt;PE_IndicatorItemViewItemCheck&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0692ba535366f2eee2fbe9bcc4cbc8d99b2ddb61" translate="yes" xml:space="preserve">
          <source>It is the style that draws the headers of Qt's item views. The item views keep the dimensions on individual sections. Also note that the delegates may use the style to paint decorations and frames around items. &lt;a href=&quot;qitemdelegate&quot;&gt;QItemDelegate&lt;/a&gt;, for instance, draws &lt;code&gt;PE_FrameFocusRect&lt;/code&gt; and &lt;code&gt;PE_IndicatorViewItemCheck&lt;/code&gt;.</source>
          <target state="translated">Qt의 아이템 뷰의 헤더를 그리는 스타일입니다. 항목보기는 개별 섹션의 치수를 유지합니다. 또한 대리인은 스타일을 사용하여 항목 주위에 장식 및 프레임을 페인트 할 수 있습니다. &lt;a href=&quot;qitemdelegate&quot;&gt;QItemDelegate는&lt;/a&gt; , 예를 들어, 무 &lt;code&gt;PE_FrameFocusRect&lt;/code&gt; 및 &lt;code&gt;PE_IndicatorViewItemCheck&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="7e9d727f3110c3fa764e7600a68b4915803838bd" translate="yes" xml:space="preserve">
          <source>It is the user's responsibility to send a</source>
          <target state="translated">이메일을 보내는 것은 사용자의 책임입니다</target>
        </trans-unit>
        <trans-unit id="64c285ba8a4f5a883e3f8d08e98ca74e56b91c96" translate="yes" xml:space="preserve">
          <source>It is then advisable to introduce a function to do the command line parsing which takes a struct or class receiving the option values returning an enumeration representing the result. The dnslookup example of the &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtnetwork-module.html&quot;&gt;QtNetwork&lt;/a&gt; module illustrates this:</source>
          <target state="translated">그런 다음 결과를 나타내는 열거를 반환하는 옵션 값을받는 구조체 또는 클래스를 사용하는 명령 줄 구문 분석을 수행하는 함수를 도입하는 것이 좋습니다. &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtnetwork-module.html&quot;&gt;QtNetwork&lt;/a&gt; 모듈 의 dnslookup 예제는 다음을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="f42c883d66a148382dd7ec2989e338fc79994cd7" translate="yes" xml:space="preserve">
          <source>It is then advisable to introduce a function to do the command line parsing which takes a struct or class receiving the option values returning an enumeration representing the result. The dnslookup example of the &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtnetwork-module.html&quot;&gt;QtNetwork&lt;/a&gt; module illustrates this:</source>
          <target state="translated">그런 다음 결과를 나타내는 열거 형을 반환하는 옵션 값을받는 구조체 또는 클래스를 사용하는 명령 줄 구문 분석을 수행하는 함수를 도입하는 것이 좋습니다. &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtnetwork-module.html&quot;&gt;QtNetwork&lt;/a&gt; 모듈 의 dnslookup 예제는 다음을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="94134a0f2a38dcf224c6b7842cff1419df143593" translate="yes" xml:space="preserve">
          <source>It is then advisable to introduce a function to do the command line parsing which takes a struct or class receiving the option values returning an enumeration representing the result. The dnslookup example of the &lt;a href=&quot;https://doc.qt.io/qt-6.0/qtnetwork-module.html&quot;&gt;QtNetwork&lt;/a&gt; module illustrates this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="114d9e3472940f3d418ff0e689814f57751b29c6" translate="yes" xml:space="preserve">
          <source>It is typcally used through subclassing allowing to set the device name and defining enums for the various axis and buttons of your targeted device.</source>
          <target state="translated">일반적으로 서브 클래 싱을 통해 장치 이름을 설정하고 대상 장치의 다양한 축과 버튼에 대한 열거 형을 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="24d5cb58791201568a08d2e8498dd7df665f1d02" translate="yes" xml:space="preserve">
          <source>It is unknown whether the user grants or denies permission.</source>
          <target state="translated">사용자가 권한을 부여할지 거부하는지 알 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e5034277fb7c700265da764152f49e873ba4aeb0" translate="yes" xml:space="preserve">
          <source>It is up to the application that requests the data to delete the &lt;a href=&quot;qiodevice&quot;&gt;QIODevice&lt;/a&gt; when done with it.</source>
          <target state="translated">완료 되면 &lt;a href=&quot;qiodevice&quot;&gt;QIODevice&lt;/a&gt; 를 삭제하기 위해 데이터를 요청하는 것은 애플리케이션에 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="8fd2f060ce6c2245304b3173676e93bd2e150322" translate="yes" xml:space="preserve">
          <source>It is used as follows:</source>
          <target state="translated">다음과 같이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="68f3a5f0d404e82cb4076caf8b04c25d1d51e774" translate="yes" xml:space="preserve">
          <source>It is used by the input method to query a set of properties of the object to be able to support complex input method operations as support for surrounding text and reconversions.</source>
          <target state="translated">입력 방법에서 객체의 속성 집합을 쿼리하여 주변 텍스트 및 변환을 지원하는 복잡한 입력 방법 작업을 지원할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="83823b0ad29439d5f4235011a1fe52d9f6d2b301" translate="yes" xml:space="preserve">
          <source>It is used on some platforms to be able to notify the AT client about state changes. The backend will traverse up all ancestors until it finds a window. (This means that at least one interface among the ancestors should return a valid &lt;a href=&quot;qwindow&quot;&gt;QWindow&lt;/a&gt; pointer).</source>
          <target state="translated">일부 플랫폼에서는 AT 클라이언트에게 상태 변경에 대해 알릴 수 있습니다. 백엔드는 창을 찾을 때까지 모든 조상을 순회합니다. 이것은 조상 중 하나 이상의 인터페이스가 유효한 &lt;a href=&quot;qwindow&quot;&gt;QWindow&lt;/a&gt; 포인터를 반환해야 함을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="0f9c50f9bd5eb8e0494106a34d0c7c4e7a139f59" translate="yes" xml:space="preserve">
          <source>It is used to parse the query strings found in URLs like the following:</source>
          <target state="translated">다음과 같이 URL에있는 쿼리 문자열을 구문 분석하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="64f4efc75604a7e410c591b323d16cfa1d5a7e16" translate="yes" xml:space="preserve">
          <source>It is useful for &lt;a href=&quot;qtquickcontrols2-customize#customizing-toolseparator&quot;&gt;customizing ToolSeparator&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qtquickcontrols2-customize#customizing-toolseparator&quot;&gt;ToolSeparator&lt;/a&gt; 를 사용자 정의하는 데 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="6721bdfcb5a66ce13d721aa3d5c6e61f357cb2ee" translate="yes" xml:space="preserve">
          <source>It is useful for custom styling.</source>
          <target state="translated">사용자 정의 스타일에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="65f75061ba89d59066892de2f51d7a2a2979dbe5" translate="yes" xml:space="preserve">
          <source>It is useful for performing some action upon cancellation of a swipe. For example, it can be used to cancel the removal of the delegate from the list that it is in.</source>
          <target state="translated">스 와이프 취소시 일부 작업을 수행하는 데 유용합니다. 예를 들어, 목록에있는 델리게이트 제거를 취소하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae77a32d0eaf533e1b92037316f3c7870e643f43" translate="yes" xml:space="preserve">
          <source>It is useful for performing some action upon completion of a swipe. For example, it can be used to remove the delegate from the list that it is in.</source>
          <target state="translated">스 와이프가 완료되면 일부 작업을 수행하는 데 유용합니다. 예를 들어, 목록에있는 대리자를 제거하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="08ba2cb212f8024adb53cc7df30cdd314c483950" translate="yes" xml:space="preserve">
          <source>It is useful for setting non-animated property values during an animation.</source>
          <target state="translated">애니메이션 중에 애니메이션되지 않은 속성 값을 설정하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="e5f7736b9866a18e4ef1d16c5d591af75ba1f926" translate="yes" xml:space="preserve">
          <source>It is useful to examine some of the functions inherited by &lt;a href=&quot;qxmldefaulthandler&quot;&gt;QXmlDefaultHandler&lt;/a&gt;, and consider why they might be reimplemented in a custom handler. Custom handlers will typically reimplement &lt;a href=&quot;qxmlcontenthandler#startDocument&quot;&gt;QXmlContentHandler::startDocument&lt;/a&gt;() to prepare the handler for new content. Document elements and the text within them can be processed by reimplementing &lt;a href=&quot;qxmlcontenthandler#startElement&quot;&gt;QXmlContentHandler::startElement&lt;/a&gt;(), &lt;a href=&quot;qxmlcontenthandler#endElement&quot;&gt;QXmlContentHandler::endElement&lt;/a&gt;(), and &lt;a href=&quot;qxmlcontenthandler#characters&quot;&gt;QXmlContentHandler::characters&lt;/a&gt;(). You may want to reimplement &lt;a href=&quot;qxmlcontenthandler#endDocument&quot;&gt;QXmlContentHandler::endDocument&lt;/a&gt;() to perform some finalization or validation on the content once the document has been read completely.</source>
          <target state="translated">&lt;a href=&quot;qxmldefaulthandler&quot;&gt;QXmlDefaultHandler&lt;/a&gt; 에 의해 상속 된 함수 중 일부를 검사 하고 사용자 정의 핸들러에서 다시 구현 될 수있는 이유를 고려 하는 것이 유용 합니다. 사용자 정의 핸들러는 일반적으로 &lt;a href=&quot;qxmlcontenthandler#startDocument&quot;&gt;QXmlContentHandler :: startDocument&lt;/a&gt; ()를 다시 구현 하여 새 컨텐츠에 대한 핸들러를 준비합니다. &lt;a href=&quot;qxmlcontenthandler#startElement&quot;&gt;QXmlContentHandler :: startElement&lt;/a&gt; (), &lt;a href=&quot;qxmlcontenthandler#endElement&quot;&gt;QXmlContentHandler :: endElement&lt;/a&gt; () 및 &lt;a href=&quot;qxmlcontenthandler#characters&quot;&gt;QXmlContentHandler :: characters&lt;/a&gt; () 를 다시 구현하여 문서 요소 및 그 안의 텍스트를 처리 할 수 ​​있습니다 . 문서를 완전히 읽은 후 &lt;a href=&quot;qxmlcontenthandler#endDocument&quot;&gt;QXmlContentHandler :: endDocument&lt;/a&gt; () 를 다시 구현 하여 컨텐츠에 대한 마무리 또는 유효성 검증을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="58beb332fededc93d1694e262364389c5680796b" translate="yes" xml:space="preserve">
          <source>It is useful to examine some of the functions inherited by QXmlDefaultHandler, and consider why they might be reimplemented in a custom handler. Custom handlers will typically reimplement &lt;a href=&quot;qxmlcontenthandler#startDocument&quot;&gt;QXmlContentHandler::startDocument&lt;/a&gt;() to prepare the handler for new content. Document elements and the text within them can be processed by reimplementing &lt;a href=&quot;qxmlcontenthandler#startElement&quot;&gt;QXmlContentHandler::startElement&lt;/a&gt;(), &lt;a href=&quot;qxmlcontenthandler#endElement&quot;&gt;QXmlContentHandler::endElement&lt;/a&gt;(), and &lt;a href=&quot;qxmlcontenthandler#characters&quot;&gt;QXmlContentHandler::characters&lt;/a&gt;(). You may want to reimplement &lt;a href=&quot;qxmlcontenthandler#endDocument&quot;&gt;QXmlContentHandler::endDocument&lt;/a&gt;() to perform some finalization or validation on the content once the document has been read completely.</source>
          <target state="translated">QXmlDefaultHandler에서 상속 된 일부 함수를 검사하고 사용자 지정 처리기에서 다시 구현 될 수있는 이유를 고려하는 것이 유용합니다. 사용자 정의 핸들러는 일반적으로 &lt;a href=&quot;qxmlcontenthandler#startDocument&quot;&gt;QXmlContentHandler :: startDocument&lt;/a&gt; ()를 다시 구현 하여 새 콘텐츠에 대한 핸들러를 준비합니다. 문서 요소와 그 안에있는 텍스트는 &lt;a href=&quot;qxmlcontenthandler#startElement&quot;&gt;QXmlContentHandler :: startElement&lt;/a&gt; (), &lt;a href=&quot;qxmlcontenthandler#endElement&quot;&gt;QXmlContentHandler :: endElement&lt;/a&gt; () 및 &lt;a href=&quot;qxmlcontenthandler#characters&quot;&gt;QXmlContentHandler :: characters&lt;/a&gt; () 를 다시 구현하여 처리 할 수 ​​있습니다 . &lt;a href=&quot;qxmlcontenthandler#endDocument&quot;&gt;QXmlContentHandler :: endDocument&lt;/a&gt; () 를 다시 구현 하여 문서를 완전히 읽은 후 콘텐츠에 대한 일부 마무리 또는 유효성 검사를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2efa01bf9980151b6a23c5c8cc436840f126b2a" translate="yes" xml:space="preserve">
          <source>It is useful when you perform a &lt;a href=&quot;qtandroid#bindService&quot;&gt;QtAndroid::bindService&lt;/a&gt; operation.</source>
          <target state="translated">&lt;a href=&quot;qtandroid#bindService&quot;&gt;QtAndroid :: bindService&lt;/a&gt; 작업 을 수행 할 때 유용 합니다.</target>
        </trans-unit>
        <trans-unit id="ccedb2a0dcdae86de603453d5044478eca88cc70" translate="yes" xml:space="preserve">
          <source>It is usual to create one &lt;a href=&quot;qaxscriptmanager&quot;&gt;QAxScriptManager&lt;/a&gt; for each document in an application.</source>
          <target state="translated">애플리케이션의 각 문서마다 하나의 &lt;a href=&quot;qaxscriptmanager&quot;&gt;QAxScriptManager&lt;/a&gt; 를 작성하는 것이 일반적 입니다.</target>
        </trans-unit>
        <trans-unit id="ea7cbc32b5676c5b0fda47b75e0544bca39ddbe0" translate="yes" xml:space="preserve">
          <source>It is usual to create one QAxScriptManager for each document in an application.</source>
          <target state="translated">응용 프로그램의 각 문서에 대해 하나의 QAxScriptManager를 만드는 것이 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="99ee231891699e27206c153574172c6435601783" translate="yes" xml:space="preserve">
          <source>It is usual to use the class with a &lt;a href=&quot;qtimeline&quot;&gt;QTimeLine&lt;/a&gt;. The timeline's &lt;a href=&quot;qtimeline#valueChanged&quot;&gt;valueChanged()&lt;/a&gt; signal is then connected to the &lt;code&gt;setStep()&lt;/code&gt; slot. For example, you can set up an item for rotation by calling &lt;code&gt;setRotationAt()&lt;/code&gt; for different step values. The animations timeline is set with the &lt;a href=&quot;qgraphicsitemanimation#setTimeLine&quot;&gt;setTimeLine&lt;/a&gt;() function.</source>
          <target state="translated">클래스를 &lt;a href=&quot;qtimeline&quot;&gt;QTimeLine&lt;/a&gt; 과 함께 사용하는 것이 일반적 입니다. 타임 라인의 &lt;a href=&quot;qtimeline#valueChanged&quot;&gt;valueChanged ()&lt;/a&gt; 신호는 &lt;code&gt;setStep()&lt;/code&gt; 슬롯에 연결됩니다 . 예를 들어, 다른 단계 값에 대해 &lt;code&gt;setRotationAt()&lt;/code&gt; 를 호출하여 회전 할 항목을 설정할 수 있습니다 . 애니메이션 타임 라인은 &lt;a href=&quot;qgraphicsitemanimation#setTimeLine&quot;&gt;setTimeLine&lt;/a&gt; () 함수로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="2de5de8a1e21eb4d83f5aec2b82cddff448ba7e0" translate="yes" xml:space="preserve">
          <source>It is usually never necessary to invoke IDC manually, as the &lt;code&gt;qmake&lt;/code&gt; build system takes care of adding the required post processing steps to the build process. See the &lt;a href=&quot;activeqt-index&quot;&gt;ActiveQt&lt;/a&gt; documentation for details.</source>
          <target state="translated">&lt;code&gt;qmake&lt;/code&gt; 빌드 시스템은 빌드 프로세스에 필요한 사후 처리 단계를 추가하므로 IDC를 수동으로 호출 할 필요는 없습니다 . 자세한 내용은 &lt;a href=&quot;activeqt-index&quot;&gt;ActiveQt&lt;/a&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="125af56e31d2b987dd9caab4980b12ba8453c44f" translate="yes" xml:space="preserve">
          <source>It is usually not necessary to call this function on datagrams received from the network.</source>
          <target state="translated">일반적으로 네트워크에서 수신 한 데이터 그램에서이 함수를 호출 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="3fc23cf7e07dbb0d5d03f56879c55befa7dbf45f" translate="yes" xml:space="preserve">
          <source>It is usually not necessary to create a &lt;a href=&quot;qml-qtqml-models-delegatemodel&quot;&gt;DelegateModel&lt;/a&gt;. However, it can be useful for manipulating and accessing the &lt;a href=&quot;qml-qtqml-models-delegatemodel#modelIndex-method&quot;&gt;modelIndex&lt;/a&gt; when a &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; subclass is used as the model. Also, &lt;a href=&quot;qml-qtqml-models-delegatemodel&quot;&gt;DelegateModel&lt;/a&gt; is used together with &lt;a href=&quot;qml-package&quot;&gt;Package&lt;/a&gt; to provide delegates to multiple views, and with &lt;a href=&quot;qml-qtqml-models-delegatemodelgroup&quot;&gt;DelegateModelGroup&lt;/a&gt; to sort and filter delegate items.</source>
          <target state="translated">일반적으로 &lt;a href=&quot;qml-qtqml-models-delegatemodel&quot;&gt;DelegateModel&lt;/a&gt; 을 만들 필요는 없습니다 . 그러나 &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; 서브 클래스가 모델로 사용될 때 &lt;a href=&quot;qml-qtqml-models-delegatemodel#modelIndex-method&quot;&gt;modelIndex&lt;/a&gt; 를 조작하고 액세스하는 데 유용 할 수 있습니다 . 또한 &lt;a href=&quot;qml-qtqml-models-delegatemodel&quot;&gt;DelegateModel&lt;/a&gt; 은 &lt;a href=&quot;qml-package&quot;&gt;Package&lt;/a&gt; 와 함께 사용 하여 여러보기에 대리자를 제공하고 &lt;a href=&quot;qml-qtqml-models-delegatemodelgroup&quot;&gt;DelegateModelGroup&lt;/a&gt; 과 함께 대리 항목을 정렬 및 필터링합니다.</target>
        </trans-unit>
        <trans-unit id="c091faa8e3c9187ee6ce887b4ea4c6e2ab424919" translate="yes" xml:space="preserve">
          <source>It is usually not necessary to create a DelegateModel. However, it can be useful for manipulating and accessing the &lt;a href=&quot;qml-qtqml-models-delegatemodel#modelIndex-method&quot;&gt;modelIndex&lt;/a&gt; when a &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; subclass is used as the model. Also, DelegateModel is used together with &lt;a href=&quot;qml-qtqml-models-package&quot;&gt;Package&lt;/a&gt; to provide delegates to multiple views, and with &lt;a href=&quot;qml-qtqml-models-delegatemodelgroup&quot;&gt;DelegateModelGroup&lt;/a&gt; to sort and filter delegate items.</source>
          <target state="translated">일반적으로 DelegateModel을 생성 할 필요는 없습니다. 그러나 &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; 하위 클래스가 모델로 사용될 때 &lt;a href=&quot;qml-qtqml-models-delegatemodel#modelIndex-method&quot;&gt;modelIndex&lt;/a&gt; 를 조작하고 액세스하는 데 유용 할 수 있습니다 . 또한 DelegateModel은 &lt;a href=&quot;qml-qtqml-models-package&quot;&gt;Package&lt;/a&gt; 와 함께 사용 하여 여러 뷰에 대리자를 제공하고 &lt;a href=&quot;qml-qtqml-models-delegatemodelgroup&quot;&gt;DelegateModelGroup&lt;/a&gt; 과 함께 사용 하여 대리자 항목을 정렬 및 필터링합니다.</target>
        </trans-unit>
        <trans-unit id="31dce88f7eed61ce7a451fc8f494e894bce7b1c5" translate="yes" xml:space="preserve">
          <source>It is usually used like the following example:</source>
          <target state="translated">일반적으로 다음 예제와 같이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="af3a076e4a0d0c264d8fa05c2cdf3968867cd362" translate="yes" xml:space="preserve">
          <source>It is valid only with certain tablet stylus devices and touchscreens that can measure the rotation angle. Otherwise, it will be zero.</source>
          <target state="translated">회전 각도를 측정 할 수있는 특정 태블릿 스타일러스 장치 및 터치 스크린에서만 유효합니다. 그렇지 않으면 0이됩니다.</target>
        </trans-unit>
        <trans-unit id="10863570d8c512bf0f5644f235600b7d4b119dcd" translate="yes" xml:space="preserve">
          <source>It is valid only with certain tablets and touchscreens that can measure pressure. Otherwise, it will be &lt;code&gt;1.0&lt;/code&gt; when pressed.</source>
          <target state="translated">압력을 측정 할 수있는 특정 태블릿 및 터치 스크린에서만 유효합니다. 그렇지 않으면 눌렀을 때 &lt;code&gt;1.0&lt;/code&gt; 이 됩니다.</target>
        </trans-unit>
        <trans-unit id="3c59c646f2ea200ba91b430917abe03b3c8e7811" translate="yes" xml:space="preserve">
          <source>It is valid only with certain tablets and touchscreens that can measure pressure. Otherwise, it will be zero.</source>
          <target state="translated">압력을 측정 할 수있는 특정 태블릿 및 터치 스크린에서만 유효합니다. 그렇지 않으면 0이됩니다.</target>
        </trans-unit>
        <trans-unit id="37cae792ebf5a85c6950e20a135a14316e7098b3" translate="yes" xml:space="preserve">
          <source>It is very bright (eg. direct sunlight).</source>
          <target state="translated">매우 밝습니다 (예 : 직사광선).</target>
        </trans-unit>
        <trans-unit id="bfa7136fa67173bf3b61ce4bcf32a29192d3a877" translate="yes" xml:space="preserve">
          <source>It is very convenient to use this function because you do not need to bother with a &lt;a href=&quot;qobject#timerEvent&quot;&gt;timerEvent&lt;/a&gt; or create a local &lt;a href=&quot;qtimer&quot;&gt;QTimer&lt;/a&gt; object.</source>
          <target state="translated">&lt;a href=&quot;qobject#timerEvent&quot;&gt;timerEvent를 사용&lt;/a&gt; 하거나 로컬 &lt;a href=&quot;qtimer&quot;&gt;QTimer&lt;/a&gt; 객체를 만들 필요가 없기 때문에이 기능을 사용하는 것이 매우 편리 합니다.</target>
        </trans-unit>
        <trans-unit id="f3bc871ee447f1205606df0cf940007ac8daf536" translate="yes" xml:space="preserve">
          <source>It is very important to test that the temporary directory could be created, using &lt;a href=&quot;qtemporarydir#isValid&quot;&gt;isValid&lt;/a&gt;(). Do not use &lt;a href=&quot;qdir#exists-1&quot;&gt;exists()&lt;/a&gt;, since a default-constructed &lt;a href=&quot;qdir&quot;&gt;QDir&lt;/a&gt; represents the current directory, which exists.</source>
          <target state="translated">&lt;a href=&quot;qtemporarydir#isValid&quot;&gt;isValid&lt;/a&gt; ()를 사용하여 임시 디렉토리를 작성할 수 있는지 테스트하는 것이 매우 중요합니다 . 기본으로 구성된 &lt;a href=&quot;qdir&quot;&gt;QDir&lt;/a&gt; 은 존재하는 현재 디렉토리를 나타내므로 exist &lt;a href=&quot;qdir#exists-1&quot;&gt;()를&lt;/a&gt; 사용하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="78663467a07fa6415050c51ec27d9b702ab36f8c" translate="yes" xml:space="preserve">
          <source>It is, however, possible to exchange the value with other processes running on the same machine, provided that they also use the same reference clock. &lt;a href=&quot;qelapsedtimer&quot;&gt;QElapsedTimer&lt;/a&gt; will always use the same clock, so it's safe to compare with the value coming from another process in the same machine. If comparing to values produced by other APIs, you should check that the clock used is the same as &lt;a href=&quot;qelapsedtimer&quot;&gt;QElapsedTimer&lt;/a&gt; (see &lt;a href=&quot;qelapsedtimer#clockType&quot;&gt;QElapsedTimer::clockType&lt;/a&gt;()).</source>
          <target state="translated">그러나 동일한 참조 클럭을 사용하는 경우 동일한 시스템에서 실행중인 다른 프로세스와 값을 교환 할 수 있습니다. &lt;a href=&quot;qelapsedtimer&quot;&gt;QElapsedTimer&lt;/a&gt; 는 항상 같은 시계를 사용하므로 동일한 컴퓨터의 다른 프로세스에서 오는 값과 비교하는 것이 안전합니다. 다른 API에서 생성 한 값과 비교할 경우 사용 된 시계가 &lt;a href=&quot;qelapsedtimer&quot;&gt;QElapsedTimer&lt;/a&gt; 와 같은지 확인해야합니다 ( &lt;a href=&quot;qelapsedtimer#clockType&quot;&gt;QElapsedTimer :: clockType&lt;/a&gt; () 참조).</target>
        </trans-unit>
        <trans-unit id="40391ad3ef454a60f35bc6a0a051678bdb0822bf" translate="yes" xml:space="preserve">
          <source>It is, however, possible to exchange the value with other processes running on the same machine, provided that they also use the same reference clock. QElapsedTimer will always use the same clock, so it's safe to compare with the value coming from another process in the same machine. If comparing to values produced by other APIs, you should check that the clock used is the same as QElapsedTimer (see &lt;a href=&quot;qelapsedtimer#clockType&quot;&gt;QElapsedTimer::clockType&lt;/a&gt;()).</source>
          <target state="translated">그러나 동일한 참조 클럭을 사용하는 경우 동일한 시스템에서 실행중인 다른 프로세스와 값을 교환 할 수 있습니다. QElapsedTimer는 항상 동일한 시계를 사용하므로 동일한 시스템의 다른 프로세스에서 오는 값과 비교하는 것이 안전합니다. 다른 API에서 생성 된 값과 비교할 경우 사용 된 시계가 QElapsedTimer와 동일한 지 확인해야합니다 ( &lt;a href=&quot;qelapsedtimer#clockType&quot;&gt;QElapsedTimer :: clockType&lt;/a&gt; () 참조).</target>
        </trans-unit>
        <trans-unit id="96b5e003824b7fb36c46e3d718683ec93456a894" translate="yes" xml:space="preserve">
          <source>It knows about the application's windows. You can ask which widget is at a certain position using &lt;a href=&quot;qapplication#widgetAt&quot;&gt;widgetAt&lt;/a&gt;(), get a list of &lt;a href=&quot;qapplication#topLevelWidgets&quot;&gt;topLevelWidgets&lt;/a&gt;() and &lt;a href=&quot;qapplication#closeAllWindows&quot;&gt;closeAllWindows&lt;/a&gt;(), etc.</source>
          <target state="translated">응용 프로그램의 창에 대해 알고 있습니다. &lt;a href=&quot;qapplication#widgetAt&quot;&gt;widgetAt&lt;/a&gt; ()를 사용하여 특정 위치에있는 위젯을 묻거나 &lt;a href=&quot;qapplication#topLevelWidgets&quot;&gt;topLevelWidgets&lt;/a&gt; () 및 &lt;a href=&quot;qapplication#closeAllWindows&quot;&gt;closeAllWindows&lt;/a&gt; () 목록을 가져올 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="adfabdb8918f791cda1cd765b01a30c22e7a40d8" translate="yes" xml:space="preserve">
          <source>It knows about the application's windows. You can ask which window is at a certain position using &lt;a href=&quot;qguiapplication#topLevelAt&quot;&gt;topLevelAt&lt;/a&gt;(), get a list of &lt;a href=&quot;qguiapplication#topLevelWindows&quot;&gt;topLevelWindows&lt;/a&gt;(), etc.</source>
          <target state="translated">응용 프로그램의 창에 대해 알고 있습니다. 다음을 사용하여 특정 위치에있는 창을 요청할 수 있습니다 &lt;a href=&quot;qguiapplication#topLevelAt&quot;&gt;topLevelAt을&lt;/a&gt; 목록을 얻을, () &lt;a href=&quot;qguiapplication#topLevelWindows&quot;&gt;topLevelWindows를&lt;/a&gt; (), 등</target>
        </trans-unit>
        <trans-unit id="f04538e94aac32b0c0477a52b1c871381ea9fcb7" translate="yes" xml:space="preserve">
          <source>It looks ok, but it isn't. It is supposed to be a FLWOR expression comprising a</source>
          <target state="translated">괜찮아 보이지만 그렇지 않습니다. 그것은 다음을 포함하는 FLWOR 식이어야합니다</target>
        </trans-unit>
        <trans-unit id="2085bcffca702e08bdfbc7b4942f6739c0ab544f" translate="yes" xml:space="preserve">
          <source>It manages the application's mouse cursor handling, see &lt;a href=&quot;qguiapplication#setOverrideCursor&quot;&gt;setOverrideCursor&lt;/a&gt;()</source>
          <target state="translated">응용 프로그램의 마우스 커서 처리를 관리합니다. &lt;a href=&quot;qguiapplication#setOverrideCursor&quot;&gt;setOverrideCursor&lt;/a&gt; ()를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3523656e9ec7b9d36af749008cf1e4939e04bad7" translate="yes" xml:space="preserve">
          <source>It may be reimplemented to cancel a request in the provider side, however, it is not mandatory.</source>
          <target state="translated">제공자 측에서 요청을 취소하기 위해 다시 구현 될 수 있지만 필수는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="4c3753a4f3b8cd2ff42c5caf55b6afb2bf8185cb" translate="yes" xml:space="preserve">
          <source>It may identify a specific token (fiducial object) when the TUIO driver is in use with a touchscreen that supports them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f14e501ea1266048a4e90c8f3ad18b7a8d6a1ade" translate="yes" xml:space="preserve">
          <source>It may sometimes be even better to replace the function pointer with inheritance and virtual functions.</source>
          <target state="translated">함수 포인터를 상속 및 가상 함수로 바꾸는 것이 더 나은 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="ac6cdc37ee4bd7c4968e222e1552c80f0b61df33" translate="yes" xml:space="preserve">
          <source>It means that text color will be the same for both buttons.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcd65614fe6afe280e7e91d32b3dbfb4f07f2d53" translate="yes" xml:space="preserve">
          <source>It might be tempting to write code like this:</source>
          <target state="translated">다음과 같은 코드를 작성하고 싶을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c6fa2249876933504db883250a6c0cebc3e37bc7" translate="yes" xml:space="preserve">
          <source>It must be comprised of alphanumeric characters or underscores.</source>
          <target state="translated">영숫자 또는 밑줄로 구성되어야합니다.</target>
        </trans-unit>
        <trans-unit id="e08af898bb3206b4f32676e1c3f698e529bd33ff" translate="yes" xml:space="preserve">
          <source>It must begin with an uppercase letter.</source>
          <target state="translated">대문자로 시작해야합니다.</target>
        </trans-unit>
        <trans-unit id="98149ab065b1c766981dbd45f6e2d1ba02451e79" translate="yes" xml:space="preserve">
          <source>It offers better performance with opaque objects, which occlude other objects. Skipping the rendering of pixels that are hidden behind fully opaque objects is a common and powerful 3D rendering optimization known as z-culling.</source>
          <target state="translated">다른 개체를 가리는 불투명 한 개체로 더 나은 성능을 제공합니다. 완전히 불투명 한 개체 뒤에 숨겨진 픽셀의 렌더링을 건너 뛰는 것은 z-culling으로 알려진 일반적이고 강력한 3D 렌더링 최적화입니다.</target>
        </trans-unit>
        <trans-unit id="31714c0c4fadba26a36b0428869d7e26c8782ea3" translate="yes" xml:space="preserve">
          <source>It offers many features expected from a modern text layout engine, including Unicode compliant rendering, line breaking and handling of cursor positioning. It can also produce and render device independent layout, something that is important for WYSIWYG applications.</source>
          <target state="translated">유니 코드 호환 렌더링, 줄 바꿈 및 커서 위치 처리 등 최신 텍스트 레이아웃 엔진에서 예상되는 많은 기능을 제공합니다. 또한 WYSIWYG 응용 프로그램에 중요한 장치 독립 레이아웃을 생성하고 렌더링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d9a11fcc91321b1d87ff12d3b782e69e46c766b" translate="yes" xml:space="preserve">
          <source>It overwrites any declarative binding that was in place. In most cases this is intended, but sometimes it can be unintentional. See &lt;a href=&quot;qtqml-syntax-propertybinding#debugging-overwriting-of-bindings&quot;&gt;Debugging overwriting of bindings&lt;/a&gt; for more information.</source>
          <target state="translated">제자리에 있던 선언적 바인딩을 덮어 씁니다. 대부분의 경우 이는 의도 된 것이지만 의도하지 않은 경우도 있습니다. 자세한 내용 &lt;a href=&quot;qtqml-syntax-propertybinding#debugging-overwriting-of-bindings&quot;&gt;은 바인딩 덮어 쓰기 디버깅&lt;/a&gt; 을 참조하세요.</target>
        </trans-unit>
        <trans-unit id="6c60853010c1995a24ecea5a753ce35e81cc39d6" translate="yes" xml:space="preserve">
          <source>It parses common command line arguments and sets its internal state accordingly. See the &lt;a href=&quot;qapplication#QApplication&quot;&gt;constructor documentation&lt;/a&gt; below for more details.</source>
          <target state="translated">일반적인 명령 줄 인수를 구문 분석하고 그에 따라 내부 상태를 설정합니다. 자세한 내용은 아래 &lt;a href=&quot;qapplication#QApplication&quot;&gt;생성자 설명서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="632c6adc7891fdaa5367b8b0083ba31c7ab0c239" translate="yes" xml:space="preserve">
          <source>It parses common command line arguments and sets its internal state accordingly. See the &lt;a href=&quot;qguiapplication#QGuiApplication&quot;&gt;constructor documentation&lt;/a&gt; below for more details.</source>
          <target state="translated">일반적인 명령 줄 인수를 구문 분석하고 그에 따라 내부 상태를 설정합니다. 자세한 내용은 아래 &lt;a href=&quot;qguiapplication#QGuiApplication&quot;&gt;생성자 설명서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a7e3971c6623682e574c9cadb107cdc096c38282" translate="yes" xml:space="preserve">
          <source>It performs event handling, meaning that it receives events from the underlying window system and dispatches them to the relevant widgets. By using &lt;a href=&quot;qcoreapplication#sendEvent&quot;&gt;sendEvent&lt;/a&gt;() and &lt;a href=&quot;qcoreapplication#postEvent&quot;&gt;postEvent&lt;/a&gt;() you can send your own events to widgets.</source>
          <target state="translated">이벤트 처리를 수행합니다. 즉, 기본 윈도우 시스템에서 이벤트를 수신하여 관련 위젯으로 디스패치합니다. 사용하여 &lt;a href=&quot;qcoreapplication#sendEvent&quot;&gt;sendEvent&lt;/a&gt; ()와 &lt;a href=&quot;qcoreapplication#postEvent&quot;&gt;postEvent를&lt;/a&gt; () 당신은 위젯에 자신의 이벤트를 보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="14c4cd14798684a073c1bdfdc117388f3c27ebcc" translate="yes" xml:space="preserve">
          <source>It performs event handling, meaning that it receives events from the underlying window system and dispatches them to the relevant widgets. You can send your own events to windows by using &lt;a href=&quot;qcoreapplication#sendEvent&quot;&gt;sendEvent&lt;/a&gt;() and &lt;a href=&quot;qcoreapplication#postEvent&quot;&gt;postEvent&lt;/a&gt;().</source>
          <target state="translated">이벤트 처리를 수행합니다. 즉, 기본 윈도우 시스템에서 이벤트를 수신하여 관련 위젯으로 디스패치합니다. &lt;a href=&quot;qcoreapplication#sendEvent&quot;&gt;sendEvent&lt;/a&gt; () 및 &lt;a href=&quot;qcoreapplication#postEvent&quot;&gt;postEvent&lt;/a&gt; () 를 사용하여 고유 한 이벤트를 창으로 보낼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="050b65797d00e21770e115a76cb58158d9fc6f93" translate="yes" xml:space="preserve">
          <source>It prefers &lt;a href=&quot;qwidget#windowIcon-prop&quot;&gt;parent-&amp;gt;icon()&lt;/a&gt; if that exists.</source>
          <target state="translated">&lt;a href=&quot;qwidget#windowIcon-prop&quot;&gt;부모-&amp;gt; icon ()이&lt;/a&gt; 있으면 선호 합니다.</target>
        </trans-unit>
        <trans-unit id="b13f727fecb1f86f6b15b167a215d8db189b4067" translate="yes" xml:space="preserve">
          <source>It provides a declarative API for the functions in &lt;a href=&quot;qfontmetricsf&quot;&gt;QFontMetricsF&lt;/a&gt; which take arguments.</source>
          <target state="translated">인수를 취하는 &lt;a href=&quot;qfontmetricsf&quot;&gt;QFontMetricsF&lt;/a&gt; 의 함수에 대한 선언적 API를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="f35a825461329d8709373b9f9366c2aec6f8a5c9" translate="yes" xml:space="preserve">
          <source>It provides a light-weight foundation for writing your own custom items. This includes defining the item's geometry, collision detection, its painting implementation and item interaction through its event handlers. &lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt; is part of the &lt;a href=&quot;graphicsview#&quot;&gt;Graphics View Framework&lt;/a&gt;</source>
          <target state="translated">사용자 정의 항목을 작성하기위한 간단한 기초를 제공합니다. 여기에는 아이템의 지오메트리 정의, 충돌 감지, 페인팅 구현 및 이벤트 핸들러를 통한 아이템 인터랙션이 포함됩니다. &lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt; 은 &lt;a href=&quot;graphicsview#&quot;&gt;Graphics View Framework의&lt;/a&gt; 일부입니다</target>
        </trans-unit>
        <trans-unit id="90154bd0d8b2882da0091be7935f3754a88a089d" translate="yes" xml:space="preserve">
          <source>It provides a light-weight foundation for writing your own custom items. This includes defining the item's geometry, collision detection, its painting implementation and item interaction through its event handlers. QGraphicsItem is part of the &lt;a href=&quot;graphicsview&quot;&gt;Graphics View Framework&lt;/a&gt;</source>
          <target state="translated">사용자 지정 항목을 작성하기위한 가벼운 기초를 제공합니다. 여기에는 항목의 지오메트리 정의, 충돌 감지, 페인팅 구현 및 이벤트 핸들러를 통한 항목 상호 작용이 포함됩니다. QGraphicsItem은 &lt;a href=&quot;graphicsview&quot;&gt;기하 창 프레임 워크의&lt;/a&gt; 일부입니다.</target>
        </trans-unit>
        <trans-unit id="b46433abaa855d46f9fa4e0279862009644e3e92" translate="yes" xml:space="preserve">
          <source>It provides a subset of the C++ &lt;a href=&quot;qfontmetricsf&quot;&gt;QFontMetricsF&lt;/a&gt; API, with the added ability to change the font that is used for calculations via the &lt;a href=&quot;qml-qtquick-fontmetrics#font-prop&quot;&gt;font&lt;/a&gt; property.</source>
          <target state="translated">C ++ &lt;a href=&quot;qfontmetricsf&quot;&gt;QFontMetricsF&lt;/a&gt; API 의 서브 세트를 제공하며 &lt;a href=&quot;qml-qtquick-fontmetrics#font-prop&quot;&gt;font&lt;/a&gt; 속성을 통해 계산에 사용되는 글꼴을 변경하는 기능이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="c485af1851c7509ea785bbd299e55a562b582b2c" translate="yes" xml:space="preserve">
          <source>It provides localization of strings that are visible to the user via &lt;a href=&quot;qcoreapplication#translate&quot;&gt;translate&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qcoreapplication#translate&quot;&gt;translate&lt;/a&gt; () 를 통해 사용자에게 표시되는 문자열의 현지화를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="1b8290a1411daa6ed9e05d1511a4eb9c72c0a321" translate="yes" xml:space="preserve">
          <source>It provides some basic functionality that is common to other high level classes like &lt;a href=&quot;qmediaplayer&quot;&gt;QMediaPlayer&lt;/a&gt;, &lt;a href=&quot;qaudiodecoder&quot;&gt;QAudioDecoder&lt;/a&gt; and &lt;a href=&quot;qcamera&quot;&gt;QCamera&lt;/a&gt;, including availability and meta-data functionality, as well as functionality to connect media objects with support classes like &lt;a href=&quot;qmediaplaylist&quot;&gt;QMediaPlaylist&lt;/a&gt;.</source>
          <target state="translated">그것은 몇 가지 기본적인 같은 다른 높은 수준의 클래스에 공통 기능 제공 &lt;a href=&quot;qmediaplayer&quot;&gt;QMediaPlayer&lt;/a&gt; , &lt;a href=&quot;qaudiodecoder&quot;&gt;QAudioDecoder&lt;/a&gt; 및 &lt;a href=&quot;qcamera&quot;&gt;QCamera&lt;/a&gt; 같은 지원 클래스와 연결 미디어 객체에 대한 가용성 및 메타 데이터 기능을 포함하여,뿐만 아니라 기능 &lt;a href=&quot;qmediaplaylist&quot;&gt;QMediaPlaylist을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="64ffaff4ef87aa7e8ce67b5e2e09a3dd8644e86a" translate="yes" xml:space="preserve">
          <source>It provides some magical objects like the &lt;a href=&quot;qapplication#desktop&quot;&gt;desktop&lt;/a&gt;() and the &lt;a href=&quot;qguiapplication#clipboard&quot;&gt;clipboard&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qapplication#desktop&quot;&gt;바탕 화면&lt;/a&gt; () 및 &lt;a href=&quot;qguiapplication#clipboard&quot;&gt;클립 보드&lt;/a&gt; () 와 같은 마술 같은 물건을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="d996c81db2eee1f908376e66f6838c7a90223734" translate="yes" xml:space="preserve">
          <source>It provides some magical objects like the &lt;a href=&quot;qguiapplication#clipboard&quot;&gt;clipboard&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qguiapplication#clipboard&quot;&gt;클립 보드&lt;/a&gt; () 와 같은 마술 같은 물건을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="283e6e02bf9f8242f6f54559d493484cf0c532a7" translate="yes" xml:space="preserve">
          <source>It provides support for sophisticated &lt;a href=&quot;ipc#session-management&quot;&gt;session management&lt;/a&gt;. This makes it possible for applications to terminate gracefully when the user logs out, to cancel a shutdown process if termination isn't possible and even to preserve the entire application's state for a future session. See &lt;a href=&quot;qguiapplication#isSessionRestored&quot;&gt;isSessionRestored&lt;/a&gt;(), &lt;a href=&quot;qguiapplication#sessionId&quot;&gt;sessionId&lt;/a&gt;() and &lt;a href=&quot;qguiapplication#commitDataRequest&quot;&gt;commitDataRequest&lt;/a&gt;() and &lt;a href=&quot;qguiapplication#saveStateRequest&quot;&gt;saveStateRequest&lt;/a&gt;() for details.</source>
          <target state="translated">정교한 &lt;a href=&quot;ipc#session-management&quot;&gt;세션 관리를&lt;/a&gt; 지원합니다 . 이를 통해 사용자가 로그 아웃 할 때 응용 프로그램이 정상적으로 종료되고 종료가 불가능한 경우 종료 프로세스를 취소하고 향후 세션을 위해 전체 응용 프로그램의 상태를 보존 할 수 있습니다. 자세한 내용은 &lt;a href=&quot;qguiapplication#isSessionRestored&quot;&gt;isSessionRestored&lt;/a&gt; (), &lt;a href=&quot;qguiapplication#sessionId&quot;&gt;sessionId&lt;/a&gt; () 및 &lt;a href=&quot;qguiapplication#commitDataRequest&quot;&gt;commitDataRequest&lt;/a&gt; () 및 &lt;a href=&quot;qguiapplication#saveStateRequest&quot;&gt;saveStateRequest&lt;/a&gt; ()를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="bb54262d5f3ed96e8c0a927bd467690ff5f4acc6" translate="yes" xml:space="preserve">
          <source>It returns an empty record, having only the field names. This function can be used to retrieve the field names of a record.</source>
          <target state="translated">필드 이름 만 가진 빈 레코드를 반환합니다. 이 함수는 레코드의 필드 이름을 검색하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ccc4d02d916dd76317ee65171b87d4f776c60066" translate="yes" xml:space="preserve">
          <source>It serves as a hook to display a custom language dialog instead of the built-in language popup in the virtual keyboard.</source>
          <target state="translated">가상 키보드의 내장 언어 팝업 대신 사용자 정의 언어 대화 상자를 표시하는 후크 역할을합니다.</target>
        </trans-unit>
        <trans-unit id="5bbad91b4449ab7a9e800a20dffc948f12256d54" translate="yes" xml:space="preserve">
          <source>It serves no purpose outside the &lt;a href=&quot;qsgmaterial#type&quot;&gt;QSGMaterial::type&lt;/a&gt;() function.</source>
          <target state="translated">&lt;a href=&quot;qsgmaterial#type&quot;&gt;QSGMaterial :: type&lt;/a&gt; () 함수 이외의 용도로는 사용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="fda683c69d529cee77d881c4434439ca51610ae7" translate="yes" xml:space="preserve">
          <source>It sets the &lt;a href=&quot;qaccessible-state&quot;&gt;states&lt;/a&gt; that are common for all widgets.</source>
          <target state="translated">모든 위젯에 공통적 인 &lt;a href=&quot;qaccessible-state&quot;&gt;상태&lt;/a&gt; 를 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="0445b3a583d439420b88cc1a7abb39cf5a9d6370" translate="yes" xml:space="preserve">
          <source>It sets the &lt;a href=&quot;qapplication#activeWindow&quot;&gt;activeWindow&lt;/a&gt;() and &lt;a href=&quot;qapplication#focusWidget&quot;&gt;focusWidget&lt;/a&gt;() attributes and sends proper &lt;a href=&quot;qevent#Type-enum&quot;&gt;WindowActivate&lt;/a&gt;/&lt;a href=&quot;qevent#Type-enum&quot;&gt;WindowDeactivate&lt;/a&gt; and &lt;a href=&quot;qevent#Type-enum&quot;&gt;FocusIn&lt;/a&gt;/&lt;a href=&quot;qevent#Type-enum&quot;&gt;FocusOut&lt;/a&gt; events to all appropriate widgets. The window will then be painted in active state (e.g. cursors in line edits will blink), and it will have tool tips enabled.</source>
          <target state="translated">그것은 설정 &lt;a href=&quot;qapplication#activeWindow&quot;&gt;activeWindow&lt;/a&gt; ()와 &lt;a href=&quot;qapplication#focusWidget&quot;&gt;focusWidget를&lt;/a&gt; ) (속성 및 적절한 전송 &lt;a href=&quot;qevent#Type-enum&quot;&gt;WindowActivate&lt;/a&gt; / &lt;a href=&quot;qevent#Type-enum&quot;&gt;WindowDeactivate&lt;/a&gt; 와 &lt;a href=&quot;qevent#Type-enum&quot;&gt;하는 focusIn&lt;/a&gt; / &lt;a href=&quot;qevent#Type-enum&quot;&gt;대한 focusOut&lt;/a&gt; 모든 적절한 위젯 이벤트를. 그런 다음 창은 활성 상태로 페인트되고 (예 : 라인 편집의 커서가 깜박임) 도구 설명이 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="7eda81c1968458d5a323115fab84bd2ccdc93114" translate="yes" xml:space="preserve">
          <source>It should be also noted that, at the Cocoa level, there is a difference between top-level windows and views (widgets that are inside a window). For this reason, make sure that the NSView that you are wrapping doesn't end up as a top-level window. The best way to ensure this is to make sure &lt;a href=&quot;qmaccocoaviewcontainer&quot;&gt;QMacCocoaViewContainer&lt;/a&gt;'s parent widget is not null.</source>
          <target state="translated">Cocoa 수준에서는 최상위 창과보기 (창 안에있는 위젯)간에 차이가 있습니다. 따라서 래핑중인 NSView가 최상위 창으로 끝나지 않아야합니다. 이를 보장하는 가장 좋은 방법은 &lt;a href=&quot;qmaccocoaviewcontainer&quot;&gt;QMacCocoaViewContainer&lt;/a&gt; 의 상위 위젯이 널이 아닌지 확인하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="f8846eeb96cebb771712a2fcea4b0a96cc1a4350" translate="yes" xml:space="preserve">
          <source>It should be also noted that, at the Cocoa level, there is a difference between top-level windows and views (widgets that are inside a window). For this reason, make sure that the NSView that you are wrapping doesn't end up as a top-level window. The best way to ensure this is to make sure QMacCocoaViewContainer's parent widget is not null.</source>
          <target state="translated">또한 Cocoa 수준에서는 최상위 창과 뷰 (창 안에있는 위젯)간에 차이가 있습니다. 이러한 이유로 래핑하는 NSView가 최상위 창으로 끝나지 않는지 확인하십시오. 이를 확인하는 가장 좋은 방법은 QMacCocoaViewContainer의 상위 위젯이 null이 아닌지 확인하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="99b3377a8c2a1a66f65a224727042954df20e5ef" translate="yes" xml:space="preserve">
          <source>It should be noted that a particle system can be disabled when not in use (for example, on a non-visible element) to avoid doing unnecessary simulation.</source>
          <target state="translated">불필요한 시뮬레이션을 피하기 위해 파티클 시스템을 사용하지 않을 때 (예 : 보이지 않는 요소에서) 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="78642e380689c855b717abcbaaf70a28ed1e02fa" translate="yes" xml:space="preserve">
          <source>It should be noted that any of the criteria may be missing or unknown (an empty &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; for the hostname or protocol name, -1 for the port numbers). If that happens, the functions executing the query should make their best guess or apply some implementation-defined default values.</source>
          <target state="translated">기준 중 하나가 누락되었거나 알 수 없음 ( 호스트 이름 또는 프로토콜 이름의 경우 비어있는 &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; , 포트 번호의 경우 -1)에 유의하십시오 . 이 경우 쿼리를 실행하는 함수가 최선의 추측을하거나 구현 정의 된 기본값을 적용해야합니다.</target>
        </trans-unit>
        <trans-unit id="b9c5ae5f91fb472de6291442bc5fc5295c247a91" translate="yes" xml:space="preserve">
          <source>It should be noted that the orientation sensor reports the orientation of the device and not the UI. The orientation of the device will not change just because the UI is rotated. This means this sensor cannot be used to detect if a device is in portrait or landscape mode.</source>
          <target state="translated">방향 센서는 UI가 아닌 장치의 방향을보고합니다. UI가 회전되어 장치의 방향이 바뀌지 않습니다. 즉,이 센서를 사용하여 장치가 세로 또는 가로 모드인지 감지 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="72b5cf9526e4bc287e3e47cc45999c0b24495b40" translate="yes" xml:space="preserve">
          <source>It should be noted that, while the pointer value can be accessed in this manner (that is, by multiple threads at the same time, without synchronization), &lt;a href=&quot;qsharedpointer&quot;&gt;QSharedPointer&lt;/a&gt; and &lt;a href=&quot;qweakpointer&quot;&gt;QWeakPointer&lt;/a&gt; provide no guarantee about the object being pointed to. The specific thread-safety and reentrancy rules for that object still apply.</source>
          <target state="translated">포인터 값은 이런 방식으로 (즉, 동기화없이 동시에 여러 스레드에 의해) 액세스 될 수 있지만 &lt;a href=&quot;qsharedpointer&quot;&gt;QSharedPointer&lt;/a&gt; 와 &lt;a href=&quot;qweakpointer&quot;&gt;QWeakPointer&lt;/a&gt; 는 지시 된 오브젝트에 대해 보증하지 않습니다. 해당 객체에 대한 특정 스레드 안전성 및 재진입 규칙이 여전히 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="c5d8b7f0d67184b7e61662bce5cb9ffb8a2327b1" translate="yes" xml:space="preserve">
          <source>It should be noted that, while the pointer value can be accessed in this manner (that is, by multiple threads at the same time, without synchronization), QSharedPointer and &lt;a href=&quot;qweakpointer&quot;&gt;QWeakPointer&lt;/a&gt; provide no guarantee about the object being pointed to. The specific thread-safety and reentrancy rules for that object still apply.</source>
          <target state="translated">포인터 값은 이러한 방식으로 (즉, 동기화없이 동시에 여러 스레드에 의해) 액세스 할 수 있지만 QSharedPointer 및 &lt;a href=&quot;qweakpointer&quot;&gt;QWeakPointer&lt;/a&gt; 는 가리키는 개체에 대한 보장을 제공하지 않습니다. 해당 객체에 대한 특정 스레드 안전성 및 재진입 규칙이 계속 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="ca1f319524ba9d65b1d96320ecac98b9286b55de" translate="yes" xml:space="preserve">
          <source>It should be noted this may not reflect the actual buttons held on the input device at the time of calling but rather the mouse buttons as last reported in one of the above events. If no mouse buttons are being held &lt;a href=&quot;qt#MouseButton-enum&quot;&gt;Qt::NoButton&lt;/a&gt; is returned.</source>
          <target state="translated">이는 호출시 입력 장치에 고정 된 실제 버튼이 아니라 위의 이벤트 중 하나에서 마지막으로보고 된 마우스 버튼을 반영 할 수 있습니다. 마우스 버튼을 누르고 있지 않으면 &lt;a href=&quot;qt#MouseButton-enum&quot;&gt;Qt :: NoButton&lt;/a&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="225279f26811d096f6f42d126b29339419d9b434" translate="yes" xml:space="preserve">
          <source>It should be noted this may not reflect the actual keys held on the input device at the time of calling but rather the modifiers as last reported in one of the above events. If no keys are being held &lt;a href=&quot;qt#KeyboardModifier-enum&quot;&gt;Qt::NoModifier&lt;/a&gt; is returned.</source>
          <target state="translated">이는 호출시 입력 장치에 보유 된 실제 키가 아니라 위의 이벤트 중 하나에서 마지막으로보고 된 수정자를 반영 할 수 있습니다. 키를 누르고 있지 않으면 &lt;a href=&quot;qt#KeyboardModifier-enum&quot;&gt;Qt :: NoModifier&lt;/a&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="139fcba7fc599169861a807a06e15306ee61867f" translate="yes" xml:space="preserve">
          <source>It should not be constructed separately, instead the &lt;code&gt;exposure&lt;/code&gt; property of the a &lt;a href=&quot;qml-multimedia#camera&quot;&gt;Camera&lt;/a&gt; should be used.</source>
          <target state="translated">별도로 구성하지 말고 &lt;a href=&quot;qml-multimedia#camera&quot;&gt;카메라&lt;/a&gt; 의 &lt;code&gt;exposure&lt;/code&gt; 속성을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="25f7812fb5b0dba4991d8aebb2ac2d703e29075c" translate="yes" xml:space="preserve">
          <source>It should not be constructed separately, instead the &lt;code&gt;flash&lt;/code&gt; property of a &lt;a href=&quot;qml-multimedia#camera&quot;&gt;Camera&lt;/a&gt; should be used.</source>
          <target state="translated">별도로 구성하지 말고 대신 &lt;a href=&quot;qml-multimedia#camera&quot;&gt;카메라&lt;/a&gt; 의 &lt;code&gt;flash&lt;/code&gt; 속성을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="21f2bc77ae30107dc8fa8e907779df90ecc9f652" translate="yes" xml:space="preserve">
          <source>It should not be constructed separately, instead the &lt;code&gt;focus&lt;/code&gt; property of a &lt;a href=&quot;qml-multimedia#camera&quot;&gt;Camera&lt;/a&gt; should be used.</source>
          <target state="translated">별도로 구성하지 말고 &lt;a href=&quot;qml-multimedia#camera&quot;&gt;카메라&lt;/a&gt; 의 &lt;code&gt;focus&lt;/code&gt; 속성을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="bc5767a67208ac0fc1c008aabf398067d4e6343e" translate="yes" xml:space="preserve">
          <source>It should not be constructed separately, instead the &lt;code&gt;imageProcessing&lt;/code&gt; property of a &lt;a href=&quot;qml-multimedia#camera&quot;&gt;Camera&lt;/a&gt; should be used.</source>
          <target state="translated">별도로 구성하지 말고 &lt;a href=&quot;qml-multimedia#camera&quot;&gt;카메라&lt;/a&gt; 의 &lt;code&gt;imageProcessing&lt;/code&gt; 속성을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="862c55946b6ffcc84531f03f03e0d23ff4173d6a" translate="yes" xml:space="preserve">
          <source>It should not be constructed separately, instead the &lt;code&gt;videoRecorder&lt;/code&gt; property of a &lt;a href=&quot;qml-multimedia#camera&quot;&gt;Camera&lt;/a&gt; should be used.</source>
          <target state="translated">별도로 구성하지 말고 &lt;a href=&quot;qml-multimedia#camera&quot;&gt;카메라&lt;/a&gt; 의 &lt;code&gt;videoRecorder&lt;/code&gt; 속성을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="d485abd579e387d08a91e41ed1042c4a898c2770" translate="yes" xml:space="preserve">
          <source>It should not be necessary to use QQuick3DObject directly anywhere currently because it is just an interface for supporting spatial items and resources in a 3D scene, as well as exposing similar functionality as &lt;a href=&quot;qquickitem&quot;&gt;QQuickItem&lt;/a&gt; for 3D scene content.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37f2b0e227cfe45bf881394f78a26bc9e3650a8f" translate="yes" xml:space="preserve">
          <source>It should not be set directly on the item, like in the below QML, as the specified value will be overridden and lost on focus changes.</source>
          <target state="translated">아래의 QML과 같이 항목에 직접 설정하면 포커스 값 변경시 지정된 값이 무시되고 손실됩니다.</target>
        </trans-unit>
        <trans-unit id="f2e0538e9ef3f8b3d343c494bfc8705ab1294b36" translate="yes" xml:space="preserve">
          <source>It should not generally be necessary to refer to the &lt;code&gt;choices&lt;/code&gt; property, as it is the default property for &lt;a href=&quot;qml-qt-labs-qmlmodels-delegatechooser&quot;&gt;DelegateChooser&lt;/a&gt; and thus all child items are automatically assigned to this property.</source>
          <target state="translated">&lt;code&gt;choices&lt;/code&gt; 속성 은 일반적으로 &lt;a href=&quot;qml-qt-labs-qmlmodels-delegatechooser&quot;&gt;DelegateChooser&lt;/a&gt; 의 기본 속성 이므로 모든 자식 항목이이 속성에 자동으로 할당되므로 선택 속성 을 참조 할 필요는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="da2a9a61b19f9622fd2d5e93c6e31d6062ea723b" translate="yes" xml:space="preserve">
          <source>It should not generally be necessary to refer to the &lt;code&gt;data&lt;/code&gt; property, as it is the default property for &lt;a href=&quot;qml-qtquick3d-object3d&quot;&gt;Object3D&lt;/a&gt; and thus all child objects are automatically assigned to this property.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2e858a4aeeda5adf9ed6da2289ed28e50552292" translate="yes" xml:space="preserve">
          <source>It should not generally be necessary to refer to the &lt;code&gt;data&lt;/code&gt; property, as it is the default property for Item and thus all child items are automatically assigned to this property.</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; 속성은 Item의 기본 속성이므로 모든 자식 항목이이 속성에 자동으로 할당되므로 일반적으로 data 속성 을 참조 할 필요는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="7539a8ca138e1f5602580a3f05b473ae419b23ec" translate="yes" xml:space="preserve">
          <source>It should not generally be necessary to refer to the &lt;code&gt;data&lt;/code&gt; property, as it is the default property for Window and thus all child items are automatically assigned to this property.</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; 속성은 Window의 기본 속성이므로 모든 자식 항목이이 속성에 자동으로 할당되므로 일반적으로 data 속성 을 참조 할 필요는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="022debcd710bf394c10119619abc7e39207e78c7" translate="yes" xml:space="preserve">
          <source>It should not generally be necessary to refer to the contentData property, as it is the default property for &lt;a href=&quot;qml-qtquick-controls2-applicationwindow&quot;&gt;ApplicationWindow&lt;/a&gt; and thus all child items are automatically assigned to this property.</source>
          <target state="translated">contentWindow 속성은 &lt;a href=&quot;qml-qtquick-controls2-applicationwindow&quot;&gt;ApplicationWindow&lt;/a&gt; 의 기본 속성 이므로 모든 자식 항목이이 속성에 자동으로 할당되므로 일반적으로 contentData 속성을 참조 할 필요는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="35a4e1166a3d3c2fb58ef4ef10395e49f7cf47eb" translate="yes" xml:space="preserve">
          <source>It should not generally be necessary to refer to the contentData property, as it is the default property for &lt;a href=&quot;qtquickcontrols-changes-qt6#applicationwindow&quot;&gt;ApplicationWindow&lt;/a&gt; and thus all child items are automatically assigned to this property.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b707c1833e629aa8ee6d45ca3a899b9f9d0437c0" translate="yes" xml:space="preserve">
          <source>It specifies how the application is to allocate colors. See setColorSpec() for details.</source>
          <target state="translated">응용 프로그램이 색상을 할당하는 방법을 지정합니다. 자세한 내용은 setColorSpec ()을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="24078cc39e4d72efcf776d430a8f61553e567f95" translate="yes" xml:space="preserve">
          <source>It tells Qt not to define the moc keywords &lt;code&gt;signals&lt;/code&gt;, &lt;code&gt;slots&lt;/code&gt;, and &lt;code&gt;emit&lt;/code&gt;, because these names will be used by a 3rd party library, e.g. Boost. Then to continue using Qt signals and slots with the &lt;code&gt;no_keywords&lt;/code&gt; flag, simply replace all uses of the Qt moc keywords in your sources with the corresponding Qt macros &lt;a href=&quot;qobject#Q_SIGNALS&quot;&gt;Q_SIGNALS&lt;/a&gt; (or &lt;a href=&quot;qobject#Q_SIGNAL&quot;&gt;Q_SIGNAL&lt;/a&gt;), &lt;a href=&quot;qobject#Q_SLOTS&quot;&gt;Q_SLOTS&lt;/a&gt; (or &lt;a href=&quot;qobject#Q_SLOT&quot;&gt;Q_SLOT&lt;/a&gt;), and &lt;a href=&quot;qobject#Q_EMIT&quot;&gt;Q_EMIT&lt;/a&gt;.</source>
          <target state="translated">그것은 mot 키워드 &lt;code&gt;signals&lt;/code&gt; , &lt;code&gt;slots&lt;/code&gt; 및 &lt;code&gt;emit&lt;/code&gt; 를 정의하지 말라고 Qt에 지시합니다. 이러한 이름은 타사 라이브러리 (예 : Boost)에서 사용되기 때문입니다. 그런 다음 &lt;code&gt;no_keywords&lt;/code&gt; 플래그 와 함께 Qt 신호 및 슬롯을 계속 사용하려면 소스의 Qt moc 키워드를 해당 Qt 매크로 &lt;a href=&quot;qobject#Q_SIGNALS&quot;&gt;Q_SIGNALS&lt;/a&gt; (또는 &lt;a href=&quot;qobject#Q_SIGNAL&quot;&gt;Q_SIGNAL&lt;/a&gt; ), &lt;a href=&quot;qobject#Q_SLOTS&quot;&gt;Q_SLOTS&lt;/a&gt; (또는 &lt;a href=&quot;qobject#Q_SLOT&quot;&gt;Q_SLOT&lt;/a&gt; ) 및 &lt;a href=&quot;qobject#Q_EMIT&quot;&gt;Q_EMIT로 바꾸십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f9c9e0080851b573b637cbf1457e9e6ab53587c6" translate="yes" xml:space="preserve">
          <source>It uses</source>
          <target state="translated">사용합니다</target>
        </trans-unit>
        <trans-unit id="8dc8881339a0a74b1fe0fb15ac829b0d2fc2bfa6" translate="yes" xml:space="preserve">
          <source>It uses a fast, binary message-passing protocol, which is suitable for same-machine communication due to its low latency and low overhead. Its specification is currently defined by the &lt;code&gt;freedesktop.org&lt;/code&gt; project, and is available to all parties.</source>
          <target state="translated">빠른 이진 메시지 전달 프로토콜을 사용합니다.이 프로토콜은 대기 시간이 짧고 오버 헤드가 적기 때문에 동일한 컴퓨터 통신에 적합합니다. 사양은 현재 &lt;code&gt;freedesktop.org&lt;/code&gt; 프로젝트에 의해 정의되며 모든 당사자가 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="de256e7a1b61da59357d8b0dc0413b9b7ad9a396" translate="yes" xml:space="preserve">
          <source>It uses the same algorithm used in &lt;a href=&quot;qcolor#setNamedColor&quot;&gt;setNamedColor&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qcolor#setNamedColor&quot;&gt;setNamedColor&lt;/a&gt; () 에 사용 된 것과 동일한 알고리즘을 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="d02616b17fc0f50dd565ca20adc50b4c4e43de2a" translate="yes" xml:space="preserve">
          <source>It was largely written by Mizi Research Inc. Here is the copyright statement for the code as it was at the point of contribution. The subsequent modifications are covered by the usual copyright for Qt.</source>
          <target state="translated">이 문서는 Mizi Research Inc.가 주로 작성했습니다. 다음은 코드 작성 시점의 코드에 대한 저작권 정보입니다. 후속 수정 사항은 Qt에 대한 일반 저작권이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="d6583644a469f2d7b42e7815e504b6d5a3ead750" translate="yes" xml:space="preserve">
          <source>It will appear in the generated HTML as:</source>
          <target state="translated">생성 된 HTML에 다음과 같이 나타납니다.</target>
        </trans-unit>
        <trans-unit id="89bd17c3c15a3f07500a2b8f94cd76f7340088c8" translate="yes" xml:space="preserve">
          <source>It will return the Android, iOS, &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt;, Windows full-product versions on those systems.</source>
          <target state="translated">해당 시스템 에서 Android, iOS, &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; , Windows 정식 버전을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="536f7912a4dccfd870decd78af38f7c7c7d1a510" translate="yes" xml:space="preserve">
          <source>It will return the Android, iOS, macOS, Windows full-product versions on those systems.</source>
          <target state="translated">해당 시스템에서 Android, iOS, macOS, Windows 전체 제품 버전을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e4e5994d267fbe49e27f06b791f4bdf75608ef62" translate="yes" xml:space="preserve">
          <source>It will trigger property binding updates every time &lt;a href=&quot;qml-qtqml-models-itemselectionmodel#selectionChanged-signal&quot;&gt;selectionChanged()&lt;/a&gt; is emitted, even though its value hasn't changed.</source>
          <target state="translated">&lt;a href=&quot;qml-qtqml-models-itemselectionmodel#selectionChanged-signal&quot;&gt;selectionChanged ()&lt;/a&gt; 가 생성 될 때마다 값이 변경되지 않은 경우에도 속성 바인딩 업데이트를 트리거합니다 .</target>
        </trans-unit>
        <trans-unit id="8a6477358ad587b294197262e6276126bdbe8040" translate="yes" xml:space="preserve">
          <source>It won't match anything because &lt;code&gt;index.html&lt;/code&gt; is an XHTML file, and all XHTML files declare the default namespace &lt;code&gt;&quot;http://www.w3.org/1999/xhtml&quot;&lt;/code&gt; in their top (&lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt;) element. But the query doesn't declare this namespace, so the path expression expands &lt;code&gt;html&lt;/code&gt; to &lt;code&gt;{}html&lt;/code&gt; and tries to match that expanded name. But the actual expanded name is &lt;code&gt;{http://www.w3.org/1999/xhtml}html&lt;/code&gt;. One possible fix is to declare the correct default namespace in the &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt;:</source>
          <target state="translated">&lt;code&gt;index.html&lt;/code&gt; 은 XHTML 파일이고 모든 XHTML 파일 은 최상위 ( &lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt; ) 요소에 기본 네임 스페이스 &lt;code&gt;&quot;http://www.w3.org/1999/xhtml&quot;&lt;/code&gt; 을 선언 하기 때문에 일치하지 않습니다 . 그러나 쿼리는이 네임 스페이스를 선언하지 않으므로 경로 표현식은 &lt;code&gt;html&lt;/code&gt; 을 &lt;code&gt;{}html&lt;/code&gt; 로 확장하고 확장 된 이름과 일치 시키려고합니다. 그러나 실제 확장 된 이름은 &lt;code&gt;{http://www.w3.org/1999/xhtml}html&lt;/code&gt; 입니다. 한 가지 가능한 수정 사항은 &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt; 에서 올바른 기본 네임 스페이스를 선언하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="048907aa33c8dde564b20f9479d2cb5ee71b994c" translate="yes" xml:space="preserve">
          <source>It won't match anything because &lt;code&gt;index.html&lt;/code&gt; is an XHTML file, and all XHTML files declare the default namespace &lt;code&gt;&quot;http://www.w3.org/1999/xhtml&quot;&lt;/code&gt; in their top (&lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt;) element. But the query doesn't declare this namespace, so the path expression expands &lt;code&gt;html&lt;/code&gt; to &lt;code&gt;{}html&lt;/code&gt; and tries to match that expanded name. But the actual expanded name is &lt;code&gt;{http://www.w3.org/1999/xhtml}html&lt;/code&gt;. One possible fix is to declare the correct default namespace in the &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt;:</source>
          <target state="translated">&lt;code&gt;index.html&lt;/code&gt; 이 XHTML 파일이므로 모든 XHTML 파일 이 맨 위 ( &lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt; ) 요소에 기본 네임 스페이스 &lt;code&gt;&quot;http://www.w3.org/1999/xhtml&quot;&lt;/code&gt; 을 선언 하므로 아무 것도 일치하지 않습니다 . 그러나 쿼리는이 네임 스페이스를 선언하지 않으므로 경로 표현식은 &lt;code&gt;html&lt;/code&gt; 을 &lt;code&gt;{}html&lt;/code&gt; 로 확장하고 확장 된 이름과 일치 시키려고합니다. 그러나 실제 확장 이름은 &lt;code&gt;{http://www.w3.org/1999/xhtml}html&lt;/code&gt; 입니다. 가능한 한 가지 수정은 &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt; 에서 올바른 기본 네임 스페이스를 선언하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="9dcfb8c304508b3595d3fe6b6f4753c041719595" translate="yes" xml:space="preserve">
          <source>It won't use the hardware cursor (falls back to rendering the mouse cursor via OpenGL; by default hardware cursors are enabled as they're more efficient).</source>
          <target state="translated">하드웨어 커서를 사용하지 않습니다 (OpenGL을 통해 마우스 커서를 렌더링하는 것으로 돌아갑니다. 기본적으로 하드웨어 커서는 더 효율적이므로 활성화됩니다).</target>
        </trans-unit>
        <trans-unit id="0bdfc7f59226ccb058609606896b72315c818434" translate="yes" xml:space="preserve">
          <source>It works as expected. The sequence of QDoc commands and text found between the two tags with the same name as the second argument is sent to the QDoc input stream. You can even have nested snippets.</source>
          <target state="translated">예상대로 작동합니다. 두 번째 인수와 동일한 이름을 가진 두 태그 사이에있는 QDoc 명령 시퀀스와 텍스트는 QDoc 입력 스트림으로 전송됩니다. 중첩 된 스 니펫을 가질 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b770672fd5f67483ec92c1ac51fe1fe5dde1054a" translate="yes" xml:space="preserve">
          <source>It works as follows: The &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt; to iterate over is passed to the &lt;a href=&quot;qlistiterator&quot;&gt;QListIterator&lt;/a&gt; constructor. At that point, the iterator is located just in front of the first item in the list (before item &quot;A&quot;). Then we call &lt;a href=&quot;qlistiterator#hasNext&quot;&gt;hasNext()&lt;/a&gt; to check whether there is an item after the iterator. If there is, we call &lt;a href=&quot;qlistiterator#next&quot;&gt;next()&lt;/a&gt; to jump over that item. The next() function returns the item that it jumps over. For a &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt;&amp;lt;&lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;&amp;gt;, that item is of type &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;.</source>
          <target state="translated">반복 되는 &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt; 는 &lt;a href=&quot;qlistiterator&quot;&gt;QListIterator&lt;/a&gt; 생성자로 전달됩니다 . 이 시점에서 반복자는 목록의 첫 번째 항목 바로 앞에 있습니다 (항목 &quot;A&quot;앞). 그런 다음 &lt;a href=&quot;qlistiterator#hasNext&quot;&gt;hasNext ()&lt;/a&gt; 를 호출 하여 반복자 뒤에 항목이 있는지 확인합니다. 있는 경우 &lt;a href=&quot;qlistiterator#next&quot;&gt;next ()&lt;/a&gt; 를 호출 하여 해당 항목을 건너 뜁니다. next () 함수는 건너 뛴 항목을 반환합니다. A에 대한 &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt; &amp;lt; &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; &amp;gt; 해당 항목이 형이다 &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4d0890e37eed266b66cb9efed088e58ed917241a" translate="yes" xml:space="preserve">
          <source>It works exactly like the &lt;a href=&quot;qobject#Q_NAMESPACE&quot;&gt;Q_NAMESPACE&lt;/a&gt; macro. However, the external &lt;code&gt;staticMetaObject&lt;/code&gt; variable that gets defined in the namespace is declared with the supplied</source>
          <target state="translated">&lt;a href=&quot;qobject#Q_NAMESPACE&quot;&gt;Q_NAMESPACE&lt;/a&gt; 매크로 와 똑같이 작동합니다 . 그러나 네임 스페이스에 정의 된 외부 &lt;code&gt;staticMetaObject&lt;/code&gt; 변수는 제공된</target>
        </trans-unit>
        <trans-unit id="7ca919b67c5952b96becabdbdc9fb5fa7381586c" translate="yes" xml:space="preserve">
          <source>It would also be possible to put all the logic in one place, in a &lt;a href=&quot;qwizard#nextId&quot;&gt;QWizard::nextId&lt;/a&gt;() reimplementation. For example:</source>
          <target state="translated">&lt;a href=&quot;qwizard#nextId&quot;&gt;QWizard :: nextId&lt;/a&gt; () 재 구현 에서 모든 로직을 한 곳에 배치 할 수도 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4d1a18266c745e51a78d1b68c1e9ab43d0ab67b8" translate="yes" xml:space="preserve">
          <source>It would have also been possible to make one call to &lt;a href=&quot;qrandomgenerator#generate64&quot;&gt;generate64&lt;/a&gt;() and then split the two halves of the 64-bit value.</source>
          <target state="translated">&lt;a href=&quot;qrandomgenerator#generate64&quot;&gt;generate64&lt;/a&gt; () 를 한 번 호출 한 다음 64 비트 값의 두 부분을 분할하는 것도 가능했을 것 입니다.</target>
        </trans-unit>
        <trans-unit id="38a4b9c94883abc63cb9f5899f0e991708646693" translate="yes" xml:space="preserve">
          <source>It's allowed to change capture mode in any camera state, but if the camera is currently active, chaging capture mode is likely to lead to camera status chaged to &lt;a href=&quot;qcamera#Status-enum&quot;&gt;QCamera::LoadedStatus&lt;/a&gt;, &lt;a href=&quot;qcamera#Status-enum&quot;&gt;QCamera::LoadingStatus&lt;/a&gt;, and when the camera is ready to &lt;a href=&quot;qcamera#Status-enum&quot;&gt;QCamera::ActiveStatus&lt;/a&gt;.</source>
          <target state="translated">모든 카메라 상태에서 캡처 모드를 변경할 수 있지만 현재 카메라가 활성화되어있는 경우 캡처 모드를 사용하면 카메라 상태가 &lt;a href=&quot;qcamera#Status-enum&quot;&gt;QCamera :: LoadedStatus&lt;/a&gt; , &lt;a href=&quot;qcamera#Status-enum&quot;&gt;QCamera :: LoadingStatus로&lt;/a&gt; , 카메라가 &lt;a href=&quot;qcamera#Status-enum&quot;&gt;QCamera에&lt;/a&gt; 준비 될 때 : ActiveStatus .</target>
        </trans-unit>
        <trans-unit id="befdc05c66921d6537eb79537f07159a2270ce12" translate="yes" xml:space="preserve">
          <source>It's also acceptable to relock already locked settings, depending on the lock parameter this initiates new focusing, exposure or white balance calculation.</source>
          <target state="translated">잠금 매개 변수에 따라 새로운 초점 조정, 노출 또는 화이트 밸런스 계산을 시작하는 이미 잠금 설정을 다시 잠글 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb233380d0baf33d1ac5d03957b95fd6d88ec905" translate="yes" xml:space="preserve">
          <source>It's also common to use &lt;a href=&quot;qtextstream&quot;&gt;QTextStream&lt;/a&gt; to read console input and write console output. &lt;a href=&quot;qtextstream&quot;&gt;QTextStream&lt;/a&gt; is locale aware, and will automatically decode standard input using the correct codec. Example:</source>
          <target state="translated">&lt;a href=&quot;qtextstream&quot;&gt;QTextStream&lt;/a&gt; 을 사용 하여 콘솔 입력을 읽고 콘솔 출력을 쓰는 것도 일반적 입니다. &lt;a href=&quot;qtextstream&quot;&gt;QTextStream&lt;/a&gt; 은 로케일을 인식하며 올바른 코덱을 사용하여 표준 입력을 자동으로 디코딩합니다. 예:</target>
        </trans-unit>
        <trans-unit id="b58e7f7d1a5dbab475d819064694f98e38b230e2" translate="yes" xml:space="preserve">
          <source>It's also common to use QTextStream to read console input and write console output. QTextStream is locale aware, and will automatically decode standard input using the correct codec. Example:</source>
          <target state="translated">콘솔 입력을 읽고 콘솔 출력을 쓰기 위해 QTextStream을 사용하는 것도 일반적입니다. QTextStream은 로케일을 인식하며 올바른 코덱을 사용하여 표준 입력을 자동으로 디코딩합니다. 예:</target>
        </trans-unit>
        <trans-unit id="fe43b885180873971742bd8792d39a2923b31c94" translate="yes" xml:space="preserve">
          <source>It's also common to use QTextStream to read console input and write console output. QTextStream is locale aware, and will automatically decode standard input using the correct encoding. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="259ccf2135186a55a894925c321f93fd84a50877" translate="yes" xml:space="preserve">
          <source>It's also possible for applications or third-party libraries and toolkits to create and insert messages in the debug log. In order to do so, you can use the &lt;a href=&quot;qopengldebugmessage#createApplicationMessage&quot;&gt;createApplicationMessage&lt;/a&gt;() or the &lt;a href=&quot;qopengldebugmessage#createThirdPartyMessage&quot;&gt;createThirdPartyMessage&lt;/a&gt;() static functions.</source>
          <target state="translated">응용 프로그램이나 타사 라이브러리 및 툴킷이 디버그 로그에 메시지를 작성하고 삽입 할 수도 있습니다. 그렇게하기 위해 &lt;a href=&quot;qopengldebugmessage#createApplicationMessage&quot;&gt;createApplicationMessage&lt;/a&gt; () 또는 &lt;a href=&quot;qopengldebugmessage#createThirdPartyMessage&quot;&gt;createThirdPartyMessage&lt;/a&gt; () 정적 함수를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e5555ab9d28fc7284eb7228e6199368b9c2389b" translate="yes" xml:space="preserve">
          <source>It's also possible to disable support for these libraries by using &lt;b&gt;-no&lt;/b&gt; instead of &lt;b&gt;-qt&lt;/b&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d4d807a7064ec8fd747ebea2026eea9b1d3a367" translate="yes" xml:space="preserve">
          <source>It's also possible to report the progress of a task independently of result reporting, like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="488385a885ceac8608433f116b84708dfb1cfbe2" translate="yes" xml:space="preserve">
          <source>It's also possible to retrieve the starting and the ending offsets (inside the subject string) of each captured substring, by using the &lt;a href=&quot;qregularexpressionmatch#capturedStart&quot;&gt;capturedStart()&lt;/a&gt; and the &lt;a href=&quot;qregularexpressionmatch#capturedEnd&quot;&gt;capturedEnd()&lt;/a&gt; functions:</source>
          <target state="translated">&lt;a href=&quot;qregularexpressionmatch#capturedStart&quot;&gt;capturedStart ()&lt;/a&gt; 및 &lt;a href=&quot;qregularexpressionmatch#capturedEnd&quot;&gt;capturedEnd ()&lt;/a&gt; 함수 를 사용하여 캡처 된 각 하위 문자열의 시작 및 끝 오프셋 (제목 문자열 내)을 검색 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c75196d6814f5ca5f10ceb2c79c741f765d0d605" translate="yes" xml:space="preserve">
          <source>It's also possible to start a match at an arbitrary offset inside the subject string by passing the offset as an argument of the &lt;a href=&quot;qregularexpression#match&quot;&gt;match&lt;/a&gt;() function. In the following example &lt;code&gt;&quot;12 abc&quot;&lt;/code&gt; is not matched because the match is started at offset 1:</source>
          <target state="translated">&lt;a href=&quot;qregularexpression#match&quot;&gt;match&lt;/a&gt; () 함수 의 인수로 오프셋을 전달하여 제목 문자열 내에서 임의의 오프셋에서 일치를 시작할 수도 있습니다 . 다음 예 에서는 일치가 오프셋 1에서 시작되므로 &lt;code&gt;&quot;12 abc&quot;&lt;/code&gt; 가 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="147ea94bb3250d78868f58383d452dafa073d0e8" translate="yes" xml:space="preserve">
          <source>It's common to call fitInView() from inside a reimplementation of &lt;a href=&quot;qgraphicsview#resizeEvent&quot;&gt;resizeEvent&lt;/a&gt;(), to ensure that the whole scene, or parts of the scene, scales automatically to fit the new size of the viewport as the view is resized. Note though, that calling fitInView() from inside &lt;a href=&quot;qgraphicsview#resizeEvent&quot;&gt;resizeEvent&lt;/a&gt;() can lead to unwanted resize recursion, if the new transformation toggles the automatic state of the scrollbars. You can toggle the scrollbar policies to always on or always off to prevent this (see &lt;a href=&quot;qabstractscrollarea#horizontalScrollBarPolicy-prop&quot;&gt;horizontalScrollBarPolicy&lt;/a&gt;() and &lt;a href=&quot;qabstractscrollarea#verticalScrollBarPolicy-prop&quot;&gt;verticalScrollBarPolicy&lt;/a&gt;()).</source>
          <target state="translated">그것은의 재 구현 내부에서 () fitInView를 호출하는 것이 일반적이다 &lt;a href=&quot;qgraphicsview#resizeEvent&quot;&gt;resizeEvent&lt;/a&gt; (), 뷰의 크기가 변경 될 때 자동으로 스케일이 뷰포트의 새로운 크기에 맞게, 그 전체 장면을 위해, 또는 장면의 일부입니다. 그러나 새 변환이 스크롤 막대의 자동 상태를 토글하는 경우 &lt;a href=&quot;qgraphicsview#resizeEvent&quot;&gt;resizeEvent&lt;/a&gt; () 내부에서 fitInView ()를 호출 하면 원하지 않는 크기 조정 재귀가 발생할 수 있습니다. 이를 방지하기 위해 스크롤 막대 정책을 항상 사용 또는 사용 중지하도록 전환 할 수 있습니다 ( &lt;a href=&quot;qabstractscrollarea#horizontalScrollBarPolicy-prop&quot;&gt;horizontalScrollBarPolicy&lt;/a&gt; () 및 &lt;a href=&quot;qabstractscrollarea#verticalScrollBarPolicy-prop&quot;&gt;verticalScrollBarPolicy&lt;/a&gt; () 참조).</target>
        </trans-unit>
        <trans-unit id="bbd10b5236f6db72bddbee4b57ff66674f2736a4" translate="yes" xml:space="preserve">
          <source>It's common to connect the &lt;a href=&quot;qguiapplication#lastWindowClosed&quot;&gt;QGuiApplication::lastWindowClosed&lt;/a&gt;() signal to quit(), and you also often connect e.g. &lt;a href=&quot;qabstractbutton#clicked&quot;&gt;QAbstractButton::clicked&lt;/a&gt;() or signals in &lt;a href=&quot;qaction&quot;&gt;QAction&lt;/a&gt;, &lt;a href=&quot;qmenu&quot;&gt;QMenu&lt;/a&gt;, or &lt;a href=&quot;qmenubar&quot;&gt;QMenuBar&lt;/a&gt; to it.</source>
          <target state="translated">&lt;a href=&quot;qguiapplication#lastWindowClosed&quot;&gt;QGuiApplication :: lastWindowClosed&lt;/a&gt; () 신호를 quit () 에 연결하는 것이 일반적 이며, &lt;a href=&quot;qabstractbutton#clicked&quot;&gt;QAbstractButton :: clicked&lt;/a&gt; () 또는 &lt;a href=&quot;qaction&quot;&gt;QAction&lt;/a&gt; , &lt;a href=&quot;qmenu&quot;&gt;QMenu&lt;/a&gt; 또는 &lt;a href=&quot;qmenubar&quot;&gt;QMenuBar의&lt;/a&gt; 신호 도 종종 연결 합니다.</target>
        </trans-unit>
        <trans-unit id="c8c8e8a56110d0d95fbc510becf52ff3de3b9c6a" translate="yes" xml:space="preserve">
          <source>It's common to open a &lt;a href=&quot;qmenu&quot;&gt;QMenu&lt;/a&gt; in response to receiving a context menu event. Example:</source>
          <target state="translated">컨텍스트 메뉴 이벤트 수신에 대한 응답으로 &lt;a href=&quot;qmenu&quot;&gt;QMenu&lt;/a&gt; 를 여는 것이 일반적 입니다. 예:</target>
        </trans-unit>
        <trans-unit id="a12903f067a09160cf9d6d8bf10c1efd319d0025" translate="yes" xml:space="preserve">
          <source>It's easy to understand this behavior if we remember that the engine expects the subject string to be only a substring of the whole text we're looking for a match into (that is, how we said before, that the engine assumes that there are other characters beyond the end of the subject string).</source>
          <target state="translated">엔진이 제목 문자열이 우리가 찾고자하는 전체 텍스트의 하위 문자열 일 것으로 예상한다는 것을 기억하면이 동작을 이해하기 쉽습니다. 제목 문자열의 끝을 넘어서는 문자).</target>
        </trans-unit>
        <trans-unit id="514eabe773b2c5d57270826b78ebe5dfbd0e6f54" translate="yes" xml:space="preserve">
          <source>It's easy to understand this behaviour if we remember that the engine expects the subject string to be only a substring of the whole text we're looking for a match into (that is, how we said before, that the engine assumes that there are other characters beyond the end of the subject string).</source>
          <target state="translated">엔진이 주제 문자열이 일치시킬 전체 텍스트의 하위 문자열 일 것으로 예상한다는 것을 기억하면 쉽게 이해할 수 있습니다. 제목 문자열의 끝을 넘는 문자).</target>
        </trans-unit>
        <trans-unit id="61e345d6101dda4da8e36254184b2bffd576d760" translate="yes" xml:space="preserve">
          <source>It's encumbered by the manual delete calls. With &lt;a href=&quot;qscopedpointer&quot;&gt;QScopedPointer&lt;/a&gt;, the code can be simplified to:</source>
          <target state="translated">수동 삭제 호출에 의해 방해를받습니다. 로 &lt;a href=&quot;qscopedpointer&quot;&gt;QScopedPointer&lt;/a&gt; , 코드를 단순화 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="e5034730aec3be9dabb248f610dea9c7582198aa" translate="yes" xml:space="preserve">
          <source>It's encumbered by the manual delete calls. With QScopedPointer, the code can be simplified to:</source>
          <target state="translated">수동 삭제 호출로 인해 방해가됩니다. QScopedPointer를 사용하면 코드를 다음과 같이 단순화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b44a999204a02f01a2574682419707456f0b1895" translate="yes" xml:space="preserve">
          <source>It's good practice to always connect signals to this slot using a &lt;a href=&quot;qt#ConnectionType-enum&quot;&gt;QueuedConnection&lt;/a&gt;. If a signal connected (non-queued) to this slot is emitted before control enters the main event loop (such as before &quot;int main&quot; calls &lt;a href=&quot;qcoreapplication#exec&quot;&gt;exec()&lt;/a&gt;), the slot has no effect and the application never exits. Using a queued connection ensures that the slot will not be invoked until after control enters the main event loop.</source>
          <target state="translated">&lt;a href=&quot;qt#ConnectionType-enum&quot;&gt;QueuedConnection을&lt;/a&gt; 사용하여 신호를 항상이 슬롯에 연결하는 것이 좋습니다 . 제어가 기본 이벤트 루프에 들어가기 전에 (예 : &quot;int main&quot;이 &lt;a href=&quot;qcoreapplication#exec&quot;&gt;exec ()를&lt;/a&gt; 호출하기 전에)이 슬롯에 연결된 (큐에없는) 신호가 발생 하면 슬롯이 영향을 미치지 않으며 응용 프로그램이 종료되지 않습니다. 대기 연결을 사용하면 제어가 기본 이벤트 루프에 들어갈 때까지 슬롯이 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6e5873be8412f221225dc9c177cc89bdff85c521" translate="yes" xml:space="preserve">
          <source>It's important to note that &lt;a href=&quot;qweakpointer&quot;&gt;QWeakPointer&lt;/a&gt; provides no automatic casting operators to prevent mistakes from happening. Even though &lt;a href=&quot;qweakpointer&quot;&gt;QWeakPointer&lt;/a&gt; tracks a pointer, it should not be considered a pointer itself, since it doesn't guarantee that the pointed object remains valid.</source>
          <target state="translated">이 점에 유의하는 것이 중요 &lt;a href=&quot;qweakpointer&quot;&gt;QWeakPointer가&lt;/a&gt; 일어나는 실수를 예방할 수있는 자동 캐스팅 연산자를 제공하지 않습니다. &lt;a href=&quot;qweakpointer&quot;&gt;QWeakPointer&lt;/a&gt; 가 포인터를 추적 하더라도 뾰족한 개체가 유효한 상태를 보장하지는 않으므로 포인터 자체로 간주해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="e247bd61d8351151098b30c67ef3933459d1d585" translate="yes" xml:space="preserve">
          <source>It's important to note that QWeakPointer provides no automatic casting operators to prevent mistakes from happening. Even though QWeakPointer tracks a pointer, it should not be considered a pointer itself, since it doesn't guarantee that the pointed object remains valid.</source>
          <target state="translated">QWeakPointer는 실수 발생을 방지하기 위해 자동 캐스팅 연산자를 제공하지 않는다는 점에 유의하는 것이 중요합니다. QWeakPointer가 포인터를 추적하더라도 뾰족한 개체가 유효한 상태로 유지된다는 것을 보장하지 않으므로 포인터 자체로 간주해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="0ee8948bb47712d970a77fc53ff86fbc6da34fa9" translate="yes" xml:space="preserve">
          <source>It's mainly for use in Qt Quick at this time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b45f2363272efcdd0ce2ec1b23edcdd328d88c4" translate="yes" xml:space="preserve">
          <source>It's most commonly used to animate a GUI control by calling a slot periodically. You can construct a timeline by passing its duration in milliseconds to &lt;a href=&quot;qtimeline&quot;&gt;QTimeLine&lt;/a&gt;'s constructor. The timeline's duration describes for how long the animation will run. Then you set a suitable frame range by calling &lt;a href=&quot;qtimeline#setFrameRange&quot;&gt;setFrameRange&lt;/a&gt;(). Finally connect the &lt;a href=&quot;qtimeline#frameChanged&quot;&gt;frameChanged&lt;/a&gt;() signal to a suitable slot in the widget you wish to animate (for example, &lt;a href=&quot;qprogressbar#value-prop&quot;&gt;setValue()&lt;/a&gt; in &lt;a href=&quot;qprogressbar&quot;&gt;QProgressBar&lt;/a&gt;). When you proceed to calling &lt;a href=&quot;qtimeline#start&quot;&gt;start&lt;/a&gt;(), &lt;a href=&quot;qtimeline&quot;&gt;QTimeLine&lt;/a&gt; will enter Running state, and start emitting &lt;a href=&quot;qtimeline#frameChanged&quot;&gt;frameChanged&lt;/a&gt;() at regular intervals, causing your widget's connected property's value to grow from the lower end to the upper and of your frame range, at a steady rate. You can specify the update interval by calling &lt;a href=&quot;qtimeline#updateInterval-prop&quot;&gt;setUpdateInterval&lt;/a&gt;(). When done, &lt;a href=&quot;qtimeline&quot;&gt;QTimeLine&lt;/a&gt; enters &lt;a href=&quot;qtimeline#State-enum&quot;&gt;NotRunning&lt;/a&gt; state, and emits &lt;a href=&quot;qtimeline#finished&quot;&gt;finished&lt;/a&gt;().</source>
          <target state="translated">슬롯을 주기적으로 호출하여 GUI 컨트롤에 애니메이션을 적용하는 데 가장 일반적으로 사용됩니다. 밀리 초 단위의 지속 시간을 &lt;a href=&quot;qtimeline&quot;&gt;QTimeLine&lt;/a&gt; 의 생성자 에 전달하여 타임 라인을 구성 할 수 있습니다 . 타임 라인의 지속 시간은 애니메이션이 실행되는 시간을 나타냅니다. 그런 다음 &lt;a href=&quot;qtimeline#setFrameRange&quot;&gt;setFrameRange&lt;/a&gt; () 를 호출하여 적절한 프레임 범위를 설정하십시오 . 마지막으로 연결 &lt;a href=&quot;qtimeline#frameChanged&quot;&gt;frameChanged&lt;/a&gt; (예를 들어, 애니메이션하고자하는 위젯에 적합한 슬롯 () 신호 &lt;a href=&quot;qprogressbar#value-prop&quot;&gt;의 setValue ()&lt;/a&gt; 에서 &lt;a href=&quot;qprogressbar&quot;&gt;QProgressBar&lt;/a&gt; ). &lt;a href=&quot;qtimeline#start&quot;&gt;start&lt;/a&gt; () 호출을 진행하면 &lt;a href=&quot;qtimeline&quot;&gt;QTimeLine&lt;/a&gt; 이 Running 상태가 되고 frameChanged 가 방출 &lt;a href=&quot;qtimeline#frameChanged&quot;&gt;됩니다.&lt;/a&gt;()가 일정한 간격으로 위젯의 연결된 속성 값이 꾸준한 속도로 하단에서 상단 및 프레임 범위로 증가합니다. &lt;a href=&quot;qtimeline#updateInterval-prop&quot;&gt;setUpdateInterval&lt;/a&gt; () 을 호출하여 업데이트 간격을 지정할 수 있습니다 . 완료되면 &lt;a href=&quot;qtimeline&quot;&gt;QTimeLine&lt;/a&gt; 은 &lt;a href=&quot;qtimeline#State-enum&quot;&gt;NotRunning&lt;/a&gt; 상태가되고 &lt;a href=&quot;qtimeline#finished&quot;&gt;종료&lt;/a&gt; ()가됩니다.</target>
        </trans-unit>
        <trans-unit id="b30a01115b876bfa3212702fa17addbf8baf1f25" translate="yes" xml:space="preserve">
          <source>It's most commonly used to animate a GUI control by calling a slot periodically. You can construct a timeline by passing its duration in milliseconds to QTimeLine's constructor. The timeline's duration describes for how long the animation will run. Then you set a suitable frame range by calling &lt;a href=&quot;qtimeline#setFrameRange&quot;&gt;setFrameRange&lt;/a&gt;(). Finally connect the &lt;a href=&quot;qtimeline#frameChanged&quot;&gt;frameChanged&lt;/a&gt;() signal to a suitable slot in the widget you wish to animate (for example, &lt;a href=&quot;qprogressbar#value-prop&quot;&gt;setValue()&lt;/a&gt; in &lt;a href=&quot;qprogressbar&quot;&gt;QProgressBar&lt;/a&gt;). When you proceed to calling &lt;a href=&quot;qtimeline#start&quot;&gt;start&lt;/a&gt;(), QTimeLine will enter Running state, and start emitting &lt;a href=&quot;qtimeline#frameChanged&quot;&gt;frameChanged&lt;/a&gt;() at regular intervals, causing your widget's connected property's value to grow from the lower end to the upper and of your frame range, at a steady rate. You can specify the update interval by calling &lt;a href=&quot;qtimeline#updateInterval-prop&quot;&gt;setUpdateInterval&lt;/a&gt;(). When done, QTimeLine enters &lt;a href=&quot;qtimeline#State-enum&quot;&gt;NotRunning&lt;/a&gt; state, and emits &lt;a href=&quot;qtimeline#finished&quot;&gt;finished&lt;/a&gt;().</source>
          <target state="translated">주기적으로 슬롯을 호출하여 GUI 컨트롤을 애니메이션하는 데 가장 일반적으로 사용됩니다. 밀리 초 단위의 기간을 QTimeLine의 생성자에 전달하여 타임 라인을 구성 할 수 있습니다. 타임 라인의 기간은 애니메이션이 실행되는 시간을 나타냅니다. 그런 다음 &lt;a href=&quot;qtimeline#setFrameRange&quot;&gt;setFrameRange&lt;/a&gt; () 를 호출하여 적절한 프레임 범위를 설정합니다 . 마지막으로 연결 &lt;a href=&quot;qtimeline#frameChanged&quot;&gt;frameChanged&lt;/a&gt; (예를 들어, 애니메이션하고자하는 위젯에 적합한 슬롯 () 신호 &lt;a href=&quot;qprogressbar#value-prop&quot;&gt;의 setValue ()&lt;/a&gt; 에서 &lt;a href=&quot;qprogressbar&quot;&gt;QProgressBar&lt;/a&gt; ). &lt;a href=&quot;qtimeline#start&quot;&gt;start&lt;/a&gt; () 호출을 진행하면 QTimeLine이 Running 상태로 &lt;a href=&quot;qtimeline#frameChanged&quot;&gt;들어가고 frameChanged&lt;/a&gt; 방출을 시작합니다.() 일정한 간격으로 위젯의 연결된 속성 값이 일정한 속도로 하단에서 상단 및 프레임 범위로 증가합니다. &lt;a href=&quot;qtimeline#updateInterval-prop&quot;&gt;setUpdateInterval&lt;/a&gt; () 을 호출하여 업데이트 간격을 지정할 수 있습니다 . 완료되면 QTimeLine은 &lt;a href=&quot;qtimeline#State-enum&quot;&gt;NotRunning&lt;/a&gt; 상태 로 들어가고 &lt;a href=&quot;qtimeline#finished&quot;&gt;finished&lt;/a&gt; ()를 내 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="54b9642b6281091b307ffba950d6791c368be218" translate="yes" xml:space="preserve">
          <source>It's not necessary to explcitly load the camera, unless unless the application have to read the supported camera settings and change the default depending on the camera capabilities.</source>
          <target state="translated">응용 프로그램에서 지원되는 카메라 설정을 읽고 카메라 기능에 따라 기본값을 변경하지 않는 한 카메라를 신속하게로드 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="3b6080153c6aa522cf0f78f33b809e2020f7430c" translate="yes" xml:space="preserve">
          <source>It's not necessary to explicitly load the camera, unless the application needs to read the supported camera settings and change the default values according to the camera capabilities.</source>
          <target state="translated">애플리케이션이 지원되는 카메라 설정을 읽고 카메라 기능에 따라 기본값을 변경해야하는 경우가 아니면 카메라를 명시 적으로로드 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="29b2738b336e43fd47f297ea1305cb9d1460030b" translate="yes" xml:space="preserve">
          <source>It's not possible to create an object of this class manually. See &lt;a href=&quot;qtconcurrenttask&quot;&gt;Concurrent Task&lt;/a&gt; for more details and usage examples.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1102653adee9d48b2b1da435e2cba0ef5762d6af" translate="yes" xml:space="preserve">
          <source>It's not possible to filter by the message text itself; applications have to do that on their own (in slots connected to the &lt;a href=&quot;qopengldebuglogger#messageLogged&quot;&gt;messageLogged&lt;/a&gt;() signal, or after fetching the messages in the internal debug log through &lt;a href=&quot;qopengldebuglogger#loggedMessages&quot;&gt;loggedMessages&lt;/a&gt;()).</source>
          <target state="translated">메시지 텍스트 자체로는 필터링 할 수 없습니다. 응용 프로그램은 자체적으로 ( &lt;a href=&quot;qopengldebuglogger#messageLogged&quot;&gt;messageLogged&lt;/a&gt; () 신호에 연결된 슬롯 에서 또는 &lt;a href=&quot;qopengldebuglogger#loggedMessages&quot;&gt;logsMessages&lt;/a&gt; ()를 통해 내부 디버그 로그에서 메시지를 가져온 후 )이를 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="5ab514dd42ade474d4564581d7459a5421864906" translate="yes" xml:space="preserve">
          <source>It's not possible to render particle effects with the &lt;a href=&quot;qtquick-visualcanvas-adaptations#openvg&quot;&gt;OpenVG&lt;/a&gt; adaptation. Whenever possible, remove particles completely from the scene. Otherwise they'll still require some processing, even though they are not visible.</source>
          <target state="translated">&lt;a href=&quot;qtquick-visualcanvas-adaptations#openvg&quot;&gt;OpenVG&lt;/a&gt; 적응으로 입자 효과를 렌더링 할 수 없습니다 . 가능하면 장면에서 파티클을 완전히 제거하십시오. 그렇지 않으면 보이지 않지만 여전히 일부 처리가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="0a4f3534dfee6819410503ff681a7ad4b79da4c7" translate="yes" xml:space="preserve">
          <source>It's not unusual for keyboard shortcuts to move the focus. This can happen implicitly by opening modal dialogs, but also explicitly using focus accelerators such as those provided by &lt;a href=&quot;qlabel#setBuddy&quot;&gt;QLabel::setBuddy&lt;/a&gt;(), &lt;a href=&quot;qgroupbox&quot;&gt;QGroupBox&lt;/a&gt;, and &lt;a href=&quot;qtabbar&quot;&gt;QTabBar&lt;/a&gt;.</source>
          <target state="translated">키보드 단축키로 포커스를 이동하는 것은 드문 일이 아닙니다. 이것은 모달 대화 상자를 열어 암시 적으로 발생할 수 있지만 &lt;a href=&quot;qlabel#setBuddy&quot;&gt;QLabel :: setBuddy&lt;/a&gt; (), &lt;a href=&quot;qgroupbox&quot;&gt;QGroupBox&lt;/a&gt; 및 &lt;a href=&quot;qtabbar&quot;&gt;QTabBar에서&lt;/a&gt; 제공하는 것과 같은 포커스 가속기를 명시 적으로 사용하여 발생할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8d10c7712090d61c634dc68db1051ea0eec38de1" translate="yes" xml:space="preserve">
          <source>It's only possible to change settings when the encoder is in the QMediaEncoder::StoppedState state.</source>
          <target state="translated">인코더가 QMediaEncoder :: StoppedState 상태에있을 때만 설정을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="322ea46ac40b5fd52253ea3ce2a4ff6e0ae1a835" translate="yes" xml:space="preserve">
          <source>It's permissible to call &lt;a href=&quot;qcameraimagecapturecontrol#capture&quot;&gt;capture&lt;/a&gt;() while the camera status is &lt;a href=&quot;qcamera#Status-enum&quot;&gt;QCamera::ActiveStatus&lt;/a&gt; regardless of isReadyForCapture property value. If camera is not ready to capture image immediately, the capture request is queued with all the related camera settings to be executed as soon as possible.</source>
          <target state="translated">isReadyForCapture 속성 값에 관계없이 카메라 상태가 &lt;a href=&quot;qcamera#Status-enum&quot;&gt;QCamera :: ActiveStatus 인&lt;/a&gt; 동안 &lt;a href=&quot;qcameraimagecapturecontrol#capture&quot;&gt;캡처&lt;/a&gt; () 를 호출 할 수 있습니다. 카메라가 즉시 이미지를 캡처 할 준비가되지 않은 경우 캡처 관련 요청이 가능한 한 빨리 모든 관련 카메라 설정과 함께 대기합니다.</target>
        </trans-unit>
        <trans-unit id="0db7dd47ed9e8bbe6144305a6d76f36b2bbb66fd" translate="yes" xml:space="preserve">
          <source>It's possible to chain multiple continuations and handlers in any order. The first handler that can handle the state of its parent is invoked first. If there's no proper handler, the state is propagated to the next continuation or handler. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="773ee187fde8574421bde7a405a6ff1f56e42315" translate="yes" xml:space="preserve">
          <source>It's possible to combine multiple Camera::FocusMode values, for example Camera.FocusMacro + Camera.FocusContinuous.</source>
          <target state="translated">여러 Camera :: FocusMode 값을 결합 할 수 있습니다 (예 : Camera.FocusMacro + Camera.FocusContinuous).</target>
        </trans-unit>
        <trans-unit id="eee0875be64f0875c91975abf5130fe988a16462" translate="yes" xml:space="preserve">
          <source>It's possible to configure Qt with -qt-xcb, which compiles in a set of xcb helper libraries instead of trying to link against the system versions. This can help make Qt less dependent on some of the xcb helper libraries that might not be available on all distributions. The table specifies which dependencies are provided by -qt-xcb.</source>
          <target state="translated">-qt-xcb를 사용하여 Qt를 구성 할 수 있습니다. -qt-xcb는 시스템 버전에 연결하지 않고 일련의 xcb 헬퍼 라이브러리에서 컴파일합니다. 이것은 모든 배포판에서 사용 가능하지 않을 수있는 일부 xcb 헬퍼 라이브러리에 Qt의 의존성을 떨어 뜨릴 수 있습니다. 이 테이블은 -qt-xcb가 제공하는 종속성을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="ac47cc2b9f12701bfce4a7cdce3d37fbb0d9b575" translate="yes" xml:space="preserve">
          <source>It's possible to connect to a Oracle database without a tnsnames.ora file. This requires that the database SID is passed to the driver as the database name, and that a hostname is given.</source>
          <target state="translated">tnsnames.ora 파일없이 Oracle 데이터베이스에 연결할 수 있습니다. 이를 위해서는 데이터베이스 SID가 데이터베이스 이름으로 드라이버에 전달되고 호스트 이름이 제공되어야합니다.</target>
        </trans-unit>
        <trans-unit id="3854f97d1b8f549a0600bb7d6556881c5cabed72" translate="yes" xml:space="preserve">
          <source>It's possible to make an existing property required with</source>
          <target state="translated">필요한 기존 속성을 다음과 같이 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="19907609e77b36fffddfa7c26a58898dc5b09831" translate="yes" xml:space="preserve">
          <source>It's possible to make bindings to properties of a &lt;a href=&quot;qml-qtquick-singlepointhandler&quot;&gt;SinglePointHandler&lt;/a&gt;'s current point. For example:</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-singlepointhandler&quot;&gt;SinglePointHandler&lt;/a&gt; 의 현재 포인트의 속성에 바인딩 할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="80bd82d89c7abe5d5226910fb0abf47f4e654adb" translate="yes" xml:space="preserve">
          <source>It's possible to make bindings to properties of a handler's current &lt;a href=&quot;qml-qtquick-singlepointhandler#point-prop&quot;&gt;point&lt;/a&gt; or &lt;a href=&quot;qml-qtquick-multipointhandler#centroid-prop&quot;&gt;centroid&lt;/a&gt;. For example:</source>
          <target state="translated">핸들러의 현재 &lt;a href=&quot;qml-qtquick-singlepointhandler#point-prop&quot;&gt;point&lt;/a&gt; 또는 &lt;a href=&quot;qml-qtquick-multipointhandler#centroid-prop&quot;&gt;centroid&lt;/a&gt; 속성에 바인딩을 만들 수 있습니다 . 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="15429f2a8419b04c9ce60059ccd19c3072cedc4e" translate="yes" xml:space="preserve">
          <source>It's possible to print some information to the debug output by enabling the &lt;code&gt;qt.qpa.input&lt;/code&gt; logging rule, for example by setting the &lt;code&gt;QT_LOGGING_RULES&lt;/code&gt; environment variable to &lt;code&gt;qt.qpa.input=true&lt;/code&gt;. This is useful for detecting which device is being used, or for troubleshooting device discovery issues.</source>
          <target state="translated">그것은 가능하게함으로써 디버그 출력에 대한 몇 가지 정보를 인쇄하는 것이 가능 &lt;code&gt;qt.qpa.input&lt;/code&gt; 의 설정에 따라, 예를 들어, 로깅 규칙을 &lt;code&gt;QT_LOGGING_RULES&lt;/code&gt; 의 에 환경 변수 &lt;code&gt;qt.qpa.input=true&lt;/code&gt; . 이는 사용중인 장치를 감지하거나 장치 검색 문제를 해결하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="cd5b3e4c5d919241bde97739fe9b86619ce08639" translate="yes" xml:space="preserve">
          <source>It's recommended to keep these directories separate by shadow-building and using the &lt;b&gt;-prefix&lt;/b&gt; option. This enables you to keep the Qt</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7d2b6a8780b2c49fa72c8a01b46fccabaa21adb" translate="yes" xml:space="preserve">
          <source>It's similar to &lt;a href=&quot;qmoveevent&quot;&gt;QMoveEvent&lt;/a&gt;, but its positions, &lt;a href=&quot;qgraphicsscenemoveevent#oldPos&quot;&gt;oldPos&lt;/a&gt;() and &lt;a href=&quot;qgraphicsscenemoveevent#newPos&quot;&gt;newPos&lt;/a&gt;(), use &lt;a href=&quot;qpointf&quot;&gt;QPointF&lt;/a&gt; instead of &lt;a href=&quot;qpoint&quot;&gt;QPoint&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qmoveevent&quot;&gt;QMoveEvent&lt;/a&gt; 와 비슷 하지만 &lt;a href=&quot;qgraphicsscenemoveevent#oldPos&quot;&gt;oldPos&lt;/a&gt; () 및 &lt;a href=&quot;qgraphicsscenemoveevent#newPos&quot;&gt;newPos&lt;/a&gt; () &lt;a href=&quot;qpoint&quot;&gt;위치&lt;/a&gt; 는 QPoint 대신 &lt;a href=&quot;qpointf&quot;&gt;QPointF&lt;/a&gt; 를 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="934dddf117f6c00d5fe09f928bc05ef75baa78ba" translate="yes" xml:space="preserve">
          <source>It's similar to &lt;a href=&quot;qresizeevent&quot;&gt;QResizeEvent&lt;/a&gt;, but its sizes, &lt;a href=&quot;qgraphicssceneresizeevent#oldSize&quot;&gt;oldSize&lt;/a&gt;() and &lt;a href=&quot;qgraphicssceneresizeevent#newSize&quot;&gt;newSize&lt;/a&gt;(), use &lt;a href=&quot;qsizef&quot;&gt;QSizeF&lt;/a&gt; instead of &lt;a href=&quot;qsize&quot;&gt;QSize&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qresizeevent&quot;&gt;QResizeEvent&lt;/a&gt; 와 비슷 하지만, &lt;a href=&quot;qgraphicssceneresizeevent#oldSize&quot;&gt;oldSize&lt;/a&gt; () 및 &lt;a href=&quot;qgraphicssceneresizeevent#newSize&quot;&gt;newSize&lt;/a&gt; () 크기 는 &lt;a href=&quot;qsizef&quot;&gt;QSize&lt;/a&gt; 대신 &lt;a href=&quot;qsize&quot;&gt;QSizeF를 사용&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="5817971605f9bb01f85106ef572fabcf10337acf" translate="yes" xml:space="preserve">
          <source>It's slow. The color property will first be evaluated with a default-constructed value, and then again with &quot;red&quot; later on.</source>
          <target state="translated">느립니다. color 속성은 먼저 기본 생성 값으로 평가되고 나중에 &quot;red&quot;로 다시 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="1808b38f031aaafd0f76411ccfd079e0b7cc3e9b" translate="yes" xml:space="preserve">
          <source>It's used only for parameters with a limited set of values, like &lt;a href=&quot;qcameraimageprocessingcontrol#ProcessingParameter-enum&quot;&gt;WhiteBalancePreset&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qcameraimageprocessingcontrol#ProcessingParameter-enum&quot;&gt;WhiteBalancePreset&lt;/a&gt; 과 같이 제한된 값 세트를 가진 매개 변수에만 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="6dd3388c21da9cde23ff7b0ede81c771236912ef" translate="yes" xml:space="preserve">
          <source>It's useful when you have your own Java implementation. Of course &lt;a href=&quot;qandroidserviceconnection#onServiceConnected&quot;&gt;onServiceConnected&lt;/a&gt;()/&lt;a href=&quot;qandroidserviceconnection#onServiceDisconnected&quot;&gt;onServiceDisconnected&lt;/a&gt;() will not be called anymore.</source>
          <target state="translated">자체 Java 구현이있는 경우 유용합니다. 물론 &lt;a href=&quot;qandroidserviceconnection#onServiceConnected&quot;&gt;onServiceConnected&lt;/a&gt; () / &lt;a href=&quot;qandroidserviceconnection#onServiceDisconnected&quot;&gt;onServiceDisconnected&lt;/a&gt; ()는 더 이상 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="485b57adcc80650a0f376fe516e0ea35fef68007" translate="yes" xml:space="preserve">
          <source>Italian</source>
          <target state="translated">Italian</target>
        </trans-unit>
        <trans-unit id="af6824436fc11a904a07d98f2312bae08f1964cb" translate="yes" xml:space="preserve">
          <source>Italian Layout</source>
          <target state="translated">이탈리아어 레이아웃</target>
        </trans-unit>
        <trans-unit id="1616e2e5405e69c4e3914c67c644a9bd3ac00956" translate="yes" xml:space="preserve">
          <source>Italic</source>
          <target state="translated">Italic</target>
        </trans-unit>
        <trans-unit id="5a48ebbe67a9f8de5a7ee49a7b4eea0f31490eea" translate="yes" xml:space="preserve">
          <source>Italic glyphs that are specifically designed for the purpose of representing italicized text.</source>
          <target state="translated">이탤릭체 텍스트를 나타 내기 위해 특별히 설계된 이탤릭체 글리프.</target>
        </trans-unit>
        <trans-unit id="de8a44e4a35427b18e9c3ea12cb6129b204f89b1" translate="yes" xml:space="preserve">
          <source>Italic text.</source>
          <target state="translated">기울임 꼴 텍스트.</target>
        </trans-unit>
        <trans-unit id="ecdda59aea5ee67d7d854c969ccf7f4f4b4a4c54" translate="yes" xml:space="preserve">
          <source>Item</source>
          <target state="translated">Item</target>
        </trans-unit>
        <trans-unit id="a5df127683bb9b560ad23e6714912676402ca4be" translate="yes" xml:space="preserve">
          <source>Item &quot;A&quot; has a number of children. A model index for item &quot;B&quot; is obtained with the following code:</source>
          <target state="translated">항목 &quot;A&quot;에는 여러 자녀가 ​​있습니다. &quot;B&quot;항목에 대한 모델 색인은 다음 코드를 사용하여 얻습니다.</target>
        </trans-unit>
        <trans-unit id="e50ae63691519dfef4cc84f52f812d2db7b4b7df" translate="yes" xml:space="preserve">
          <source>Item (QML type)</source>
          <target state="translated">품목 (QML 유형)</target>
        </trans-unit>
        <trans-unit id="e4f898bb6d810d23a082edd694f438cb76b6b0a0" translate="yes" xml:space="preserve">
          <source>Item (and all derived types) provides built in support for states and transitions via its &lt;a href=&quot;qml-qtquick-item#state-prop&quot;&gt;state&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-item#states-prop&quot;&gt;states&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-item#transitions-prop&quot;&gt;transitions&lt;/a&gt; properties. &lt;a href=&quot;qml-qtquick-stategroup&quot;&gt;StateGroup&lt;/a&gt; provides an easy way to use this support in other (non-Item-derived) types.</source>
          <target state="translated">항목 (및 모든 파생 유형)은 &lt;a href=&quot;qml-qtquick-item#state-prop&quot;&gt;state&lt;/a&gt; , &lt;a href=&quot;qml-qtquick-item#states-prop&quot;&gt;states&lt;/a&gt; 및 &lt;a href=&quot;qml-qtquick-item#transitions-prop&quot;&gt;transitions&lt;/a&gt; 속성을 통해 상태 및 전환을 기본적으로 지원 합니다. &lt;a href=&quot;qml-qtquick-stategroup&quot;&gt;StateGroup&lt;/a&gt; 은 다른 (항목에서 파생되지 않은) 유형에서이 지원을 사용하는 쉬운 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f1a7412cc94c83e0a752584abb8cd43105f416eb" translate="yes" xml:space="preserve">
          <source>Item (and all derived types) provides built in support for states and transitions via its &lt;a href=&quot;qml-qtquick-item#state-prop&quot;&gt;state&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-item#states-prop&quot;&gt;states&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-item#transitions-prop&quot;&gt;transitions&lt;/a&gt; properties. StateGroup provides an easy way to use this support in other (non-Item-derived) types.</source>
          <target state="translated">항목 (및 모든 파생 유형)은 &lt;a href=&quot;qml-qtquick-item#state-prop&quot;&gt;state&lt;/a&gt; , &lt;a href=&quot;qml-qtquick-item#states-prop&quot;&gt;states&lt;/a&gt; 및 &lt;a href=&quot;qml-qtquick-item#transitions-prop&quot;&gt;transitions&lt;/a&gt; 속성을 통해 상태 및 전환에 대한 기본 지원을 제공 합니다. StateGroup은 다른 (항목 파생이 아닌) 유형에서이 지원을 사용하는 쉬운 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="ddf70253940ac83f3ef72575e0f24057265b100c" translate="yes" xml:space="preserve">
          <source>Item &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-controls-stackview#find-method&quot;&gt;find&lt;/a&gt;&lt;/b&gt;&lt;/b&gt;(</source>
          <target state="translated">아이템 &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-controls-stackview#find-method&quot;&gt;찾기&lt;/a&gt;&lt;/b&gt;&lt;/b&gt; (</target>
        </trans-unit>
        <trans-unit id="0a2ce97121dfd0343ad3e3a9c0a5dbae36c7a194" translate="yes" xml:space="preserve">
          <source>Item &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-controls-stackview#get-method&quot;&gt;get&lt;/a&gt;&lt;/b&gt;&lt;/b&gt;(int</source>
          <target state="translated">아이템 &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-controls-stackview#get-method&quot;&gt;획득&lt;/a&gt;&lt;/b&gt;&lt;/b&gt; (int</target>
        </trans-unit>
        <trans-unit id="49e9c7d16507fed376977d7117be893a3f4131bb" translate="yes" xml:space="preserve">
          <source>Item &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-controls-stackview#pop-method&quot;&gt;pop&lt;/a&gt;&lt;/b&gt;&lt;/b&gt;(Item</source>
          <target state="translated">아이템 &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-controls-stackview#pop-method&quot;&gt;팝&lt;/a&gt;&lt;/b&gt;&lt;/b&gt; (Item</target>
        </trans-unit>
        <trans-unit id="3c1adbae60f92d0980809160f00fb7aa2ad05bc8" translate="yes" xml:space="preserve">
          <source>Item &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-controls-stackview#push-method&quot;&gt;push&lt;/a&gt;&lt;/b&gt;&lt;/b&gt;(Item</source>
          <target state="translated">항목 &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-controls-stackview#push-method&quot;&gt;푸시&lt;/a&gt;&lt;/b&gt;&lt;/b&gt; (항목</target>
        </trans-unit>
        <trans-unit id="c4438a00f1ed0f8a5454b0b16e6b60f8798d0b2e" translate="yes" xml:space="preserve">
          <source>Item &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-controls2-container#itemAt-method&quot;&gt;itemAt&lt;/a&gt;&lt;/b&gt;&lt;/b&gt;(</source>
          <target state="translated">품목 &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-controls2-container#itemAt-method&quot;&gt;itemAt&lt;/a&gt;&lt;/b&gt;&lt;/b&gt; (</target>
        </trans-unit>
        <trans-unit id="fe4a116515a6738f82bd6666b56c273655cfb71d" translate="yes" xml:space="preserve">
          <source>Item &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-controls2-container#itemAt-method&quot;&gt;itemAt&lt;/a&gt;&lt;/b&gt;&lt;/b&gt;(int</source>
          <target state="translated">항목 &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-controls2-container#itemAt-method&quot;&gt;itemAt&lt;/a&gt;&lt;/b&gt;&lt;/b&gt; (int</target>
        </trans-unit>
        <trans-unit id="95367f592e8fd659c0a4cae32b7b06ec4462f6b1" translate="yes" xml:space="preserve">
          <source>Item &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-controls2-container#takeItem-method&quot;&gt;takeItem&lt;/a&gt;&lt;/b&gt;&lt;/b&gt;(</source>
          <target state="translated">품목 &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-controls2-container#takeItem-method&quot;&gt;takeItem&lt;/a&gt;&lt;/b&gt;&lt;/b&gt; (</target>
        </trans-unit>
        <trans-unit id="8315abfc497d025c3cf8ab4c0c7603d5919818af" translate="yes" xml:space="preserve">
          <source>Item &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-controls2-container#takeItem-method&quot;&gt;takeItem&lt;/a&gt;&lt;/b&gt;&lt;/b&gt;(int</source>
          <target state="translated">항목 &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-controls2-container#takeItem-method&quot;&gt;takeItem&lt;/a&gt;&lt;/b&gt;&lt;/b&gt; (int</target>
        </trans-unit>
        <trans-unit id="6598f5548f0bf84a9d2e2ff93391e98dccc50e11" translate="yes" xml:space="preserve">
          <source>Item &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-controls2-menu#itemAt-method&quot;&gt;itemAt&lt;/a&gt;&lt;/b&gt;&lt;/b&gt;(</source>
          <target state="translated">품목 &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-controls2-menu#itemAt-method&quot;&gt;itemAt&lt;/a&gt;&lt;/b&gt;&lt;/b&gt; (</target>
        </trans-unit>
        <trans-unit id="1041328ea0f8cda005e65701ed2f82cf234d1f9b" translate="yes" xml:space="preserve">
          <source>Item &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-controls2-menu#itemAt-method&quot;&gt;itemAt&lt;/a&gt;&lt;/b&gt;&lt;/b&gt;(int</source>
          <target state="translated">항목 &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-controls2-menu#itemAt-method&quot;&gt;itemAt&lt;/a&gt;&lt;/b&gt;&lt;/b&gt; (int</target>
        </trans-unit>
        <trans-unit id="5ffa5acbe6122a36f6c39f3f6c150487cc17d3a2" translate="yes" xml:space="preserve">
          <source>Item &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-controls2-stackview#find-method&quot;&gt;find&lt;/a&gt;&lt;/b&gt;&lt;/b&gt;(</source>
          <target state="translated">아이템 &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-controls2-stackview#find-method&quot;&gt;찾기&lt;/a&gt;&lt;/b&gt;&lt;/b&gt; (</target>
        </trans-unit>
        <trans-unit id="40dfdd761bb35a8ba345211c85096e98592a64e8" translate="yes" xml:space="preserve">
          <source>Item &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-controls2-stackview#get-method&quot;&gt;get&lt;/a&gt;&lt;/b&gt;&lt;/b&gt;(</source>
          <target state="translated">아이템 &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-controls2-stackview#get-method&quot;&gt;가져 오기&lt;/a&gt;&lt;/b&gt;&lt;/b&gt; (</target>
        </trans-unit>
        <trans-unit id="af5a36b33c11c6ae94ff99211db4c61d90861815" translate="yes" xml:space="preserve">
          <source>Item &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-controls2-stackview#pop-method&quot;&gt;pop&lt;/a&gt;&lt;/b&gt;&lt;/b&gt;(</source>
          <target state="translated">아이템 &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-controls2-stackview#pop-method&quot;&gt;팝&lt;/a&gt;&lt;/b&gt;&lt;/b&gt; (</target>
        </trans-unit>
        <trans-unit id="44d5299595db3963d567f7e443bb0ab016642bd2" translate="yes" xml:space="preserve">
          <source>Item &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-controls2-stackview#push-method&quot;&gt;push&lt;/a&gt;&lt;/b&gt;&lt;/b&gt;(</source>
          <target state="translated">아이템 &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-controls2-stackview#push-method&quot;&gt;푸시&lt;/a&gt;&lt;/b&gt;&lt;/b&gt; (</target>
        </trans-unit>
        <trans-unit id="a197847b9838a4df7e5cbd888ca2b6b77a380944" translate="yes" xml:space="preserve">
          <source>Item &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-controls2-stackview#replace-method&quot;&gt;replace&lt;/a&gt;&lt;/b&gt;&lt;/b&gt;(</source>
          <target state="translated">아이템 &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-controls2-stackview#replace-method&quot;&gt;교체&lt;/a&gt;&lt;/b&gt;&lt;/b&gt; (</target>
        </trans-unit>
        <trans-unit id="8c9f4c98345f7c74221211ef4cdd714936a0da4e" translate="yes" xml:space="preserve">
          <source>Item &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-gridview#itemAt-method&quot;&gt;itemAt&lt;/a&gt;&lt;/b&gt;&lt;/b&gt;(</source>
          <target state="translated">품목 &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-gridview#itemAt-method&quot;&gt;itemAt&lt;/a&gt;&lt;/b&gt;&lt;/b&gt; (</target>
        </trans-unit>
        <trans-unit id="189dd7ecf23b221fe2549948a2b126fb9a3e7521" translate="yes" xml:space="preserve">
          <source>Item &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-gridview#itemAt-method&quot;&gt;itemAt&lt;/a&gt;&lt;/b&gt;&lt;/b&gt;(real</source>
          <target state="translated">항목 &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-gridview#itemAt-method&quot;&gt;itemAt&lt;/a&gt;&lt;/b&gt;&lt;/b&gt; (실제</target>
        </trans-unit>
        <trans-unit id="4622712203499e3e3324158820a2402a80575f72" translate="yes" xml:space="preserve">
          <source>Item &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-gridview#itemAtIndex-method&quot;&gt;itemAtIndex&lt;/a&gt;&lt;/b&gt;&lt;/b&gt;(</source>
          <target state="translated">항목 &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-gridview#itemAtIndex-method&quot;&gt;itemAtIndex&lt;/a&gt;&lt;/b&gt;&lt;/b&gt; (</target>
        </trans-unit>
        <trans-unit id="e0cdbfdeaa28a9e7ae3da4c81344b27c64504f26" translate="yes" xml:space="preserve">
          <source>Item &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-gridview#itemAtIndex-method&quot;&gt;itemAtIndex&lt;/a&gt;&lt;/b&gt;&lt;/b&gt;(int</source>
          <target state="translated">항목 &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-gridview#itemAtIndex-method&quot;&gt;itemAtIndex&lt;/a&gt;&lt;/b&gt;&lt;/b&gt; (int</target>
        </trans-unit>
        <trans-unit id="41ef75f00c9dc9e65090489268adfae49d61a2cb" translate="yes" xml:space="preserve">
          <source>Item &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-listview#itemAt-method&quot;&gt;itemAt&lt;/a&gt;&lt;/b&gt;&lt;/b&gt;(</source>
          <target state="translated">품목 &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-listview#itemAt-method&quot;&gt;itemAt&lt;/a&gt;&lt;/b&gt;&lt;/b&gt; (</target>
        </trans-unit>
        <trans-unit id="cb1bd569a0a017d50d6d4c20b9c73184b9054faf" translate="yes" xml:space="preserve">
          <source>Item &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-listview#itemAt-method&quot;&gt;itemAt&lt;/a&gt;&lt;/b&gt;&lt;/b&gt;(real</source>
          <target state="translated">항목 &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-listview#itemAt-method&quot;&gt;itemAt&lt;/a&gt;&lt;/b&gt;&lt;/b&gt; (실제</target>
        </trans-unit>
        <trans-unit id="d5fe1c8e89205b056dbb32746b23ae863c4c025c" translate="yes" xml:space="preserve">
          <source>Item &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-listview#itemAtIndex-method&quot;&gt;itemAtIndex&lt;/a&gt;&lt;/b&gt;&lt;/b&gt;(</source>
          <target state="translated">항목 &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-listview#itemAtIndex-method&quot;&gt;itemAtIndex&lt;/a&gt;&lt;/b&gt;&lt;/b&gt; (</target>
        </trans-unit>
        <trans-unit id="f64f214afc79b84a239065393a5634cec0ebe682" translate="yes" xml:space="preserve">
          <source>Item &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-listview#itemAtIndex-method&quot;&gt;itemAtIndex&lt;/a&gt;&lt;/b&gt;&lt;/b&gt;(int</source>
          <target state="translated">항목 &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-listview#itemAtIndex-method&quot;&gt;itemAtIndex&lt;/a&gt;&lt;/b&gt;&lt;/b&gt; (int</target>
        </trans-unit>
        <trans-unit id="1af242103489c9a6d9c7e57c4460e059f34bdf62" translate="yes" xml:space="preserve">
          <source>Item &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-pathview#itemAt-method&quot;&gt;itemAt&lt;/a&gt;&lt;/b&gt;&lt;/b&gt;(</source>
          <target state="translated">품목 &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-pathview#itemAt-method&quot;&gt;itemAt&lt;/a&gt;&lt;/b&gt;&lt;/b&gt; (</target>
        </trans-unit>
        <trans-unit id="978e18599ea404264d86b6366b220f092b2a8fb2" translate="yes" xml:space="preserve">
          <source>Item &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-pathview#itemAt-method&quot;&gt;itemAt&lt;/a&gt;&lt;/b&gt;&lt;/b&gt;(real</source>
          <target state="translated">항목 &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-pathview#itemAt-method&quot;&gt;itemAt&lt;/a&gt;&lt;/b&gt;&lt;/b&gt; (실제</target>
        </trans-unit>
        <trans-unit id="89a7c9297643a4f81addf172dcd1f961fb47ad2d" translate="yes" xml:space="preserve">
          <source>Item &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-repeater#itemAt-method&quot;&gt;itemAt&lt;/a&gt;&lt;/b&gt;&lt;/b&gt;(</source>
          <target state="translated">품목 &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-repeater#itemAt-method&quot;&gt;itemAt&lt;/a&gt;&lt;/b&gt;&lt;/b&gt; (</target>
        </trans-unit>
        <trans-unit id="f5f1ff9e673a3e0f669a476fc28d14bd78098868" translate="yes" xml:space="preserve">
          <source>Item &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-tableview#itemAtCell-method&quot;&gt;itemAtCell&lt;/a&gt;&lt;/b&gt;&lt;/b&gt;(point</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1043962abe19ba53d595f1e3777efbd739b0faf9" translate="yes" xml:space="preserve">
          <source>Item &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-tableview#itemAtCell-method-1&quot;&gt;itemAtCell&lt;/a&gt;&lt;/b&gt;&lt;/b&gt;(int</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="201e7adb3886f8ea20f4aca9821c7de2ee20566d" translate="yes" xml:space="preserve">
          <source>Item Coordinates</source>
          <target state="translated">아이템 좌표</target>
        </trans-unit>
        <trans-unit id="09f472343e7cc56f3732b3128bd660dea6c4dc12" translate="yes" xml:space="preserve">
          <source>Item Groups</source>
          <target state="translated">품목 그룹</target>
        </trans-unit>
        <trans-unit id="4986df28cec7555918dc6e355c4a70c0d45a9f14" translate="yes" xml:space="preserve">
          <source>Item Layers</source>
          <target state="translated">아이템 레이어</target>
        </trans-unit>
        <trans-unit id="d5c9f5996caf101dabc161f4cd976e61de7fd1ab" translate="yes" xml:space="preserve">
          <source>Item Models and Data Mapping</source>
          <target state="translated">아이템 모델 및 데이터 매핑</target>
        </trans-unit>
        <trans-unit id="a1c537bd015c1c74434089d12c13d8e9ce682046" translate="yes" xml:space="preserve">
          <source>Item Ownership</source>
          <target state="translated">아이템 소유권</target>
        </trans-unit>
        <trans-unit id="b615a37bccc41fc6b14cd92f6a7372901c468d91" translate="yes" xml:space="preserve">
          <source>Item Positioners</source>
          <target state="translated">아이템 포지셔너</target>
        </trans-unit>
        <trans-unit id="aa610b2cb81002951dde08cb6b50e71c81105c5c" translate="yes" xml:space="preserve">
          <source>Item QML Type</source>
          <target state="translated">품목 QML 유형</target>
        </trans-unit>
        <trans-unit id="0b67c8d1f000678bb49d9dd13c1c665ba8dd6f82" translate="yes" xml:space="preserve">
          <source>Item View Convenience Classes</source>
          <target state="translated">아이템 뷰 편의 클래스</target>
        </trans-unit>
        <trans-unit id="d5caa284635328070a664054bc74cfb9e342c288" translate="yes" xml:space="preserve">
          <source>Item View Headers</source>
          <target state="translated">아이템 뷰 헤더</target>
        </trans-unit>
        <trans-unit id="c69d47ca34a82a2a69eda6bfd3740dea3536f02f" translate="yes" xml:space="preserve">
          <source>Item acts as a link to a file that the application can open.</source>
          <target state="translated">항목은 응용 프로그램이 열 수있는 파일에 대한 링크 역할을합니다.</target>
        </trans-unit>
        <trans-unit id="d54c1ac2b23604a11002fb1b10ef3d82dec0f17e" translate="yes" xml:space="preserve">
          <source>Item data handling</source>
          <target state="translated">품목 데이터 처리</target>
        </trans-unit>
        <trans-unit id="d9d6fa91c0d8241dc5483dd85a978a1676ee1620" translate="yes" xml:space="preserve">
          <source>Item defaults to the value provided via touchEvent(). X and y default to the midpoint of the item.</source>
          <target state="translated">항목의 기본값은 touchEvent ()를 통해 제공된 값입니다. X와 y의 기본값은 항목의 중간 점입니다.</target>
        </trans-unit>
        <trans-unit id="dcde0507a8c37135d26f5570f88a09e4122c672e" translate="yes" xml:space="preserve">
          <source>Item delegate with a check indicator that can be toggled on or off</source>
          <target state="translated">켜거나 끌 수있는 점검 표시기가있는 품목 대리자</target>
        </trans-unit>
        <trans-unit id="1a822479578b56c19509293155fe1a5f94981db5" translate="yes" xml:space="preserve">
          <source>Item delegate with a check indicator that can be toggled on or off. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">켜거나 끌 수있는 확인 표시기가있는 항목 대리인. &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="dbd25052d707307af916ec9d28ab488c3a162182" translate="yes" xml:space="preserve">
          <source>Item delegate with a switch indicator that can be toggled on or off</source>
          <target state="translated">켜거나 끌 수있는 스위치 표시기가있는 항목 대리자</target>
        </trans-unit>
        <trans-unit id="7ef2d68e84d4ca7ef9776f53eb8b2ad5bd693f78" translate="yes" xml:space="preserve">
          <source>Item delegate with a switch indicator that can be toggled on or off. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">켜거나 끌 수있는 스위치 표시기가있는 항목 델리게이트. &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="506296d3c72a1aa0f2cd3164eef98f7acad99131" translate="yes" xml:space="preserve">
          <source>Item displays the current valid copyright notice for a Map element</source>
          <target state="translated">항목은지도 요소에 대한 현재 유효한 저작권 표시를 표시합니다</target>
        </trans-unit>
        <trans-unit id="6113aef69f4201aff7843f045f83f593471f04d3" translate="yes" xml:space="preserve">
          <source>Item for use with the QListWidget item view class</source>
          <target state="translated">QListWidget 항목보기 클래스와 함께 사용하기위한 항목</target>
        </trans-unit>
        <trans-unit id="8f1ca4a2dbe5ee9d97bbd21b1388dda25000f6a0" translate="yes" xml:space="preserve">
          <source>Item for use with the QStandardItemModel class</source>
          <target state="translated">QStandardItemModel 클래스와 함께 사용할 항목</target>
        </trans-unit>
        <trans-unit id="638916425f8da3caeb872412247b281a28ae2233" translate="yes" xml:space="preserve">
          <source>Item for use with the QTableWidget class</source>
          <target state="translated">QTableWidget 클래스와 함께 사용할 항목</target>
        </trans-unit>
        <trans-unit id="1129f8b650f043ccd8fee0ebe8cd578eb4cc9810" translate="yes" xml:space="preserve">
          <source>Item for use with the QTreeWidget convenience class</source>
          <target state="translated">QTreeWidget 편의 클래스와 함께 사용하기위한 항목</target>
        </trans-unit>
        <trans-unit id="31ff6aa9d1812d8ae12d5306bf0d713e3fa4f144" translate="yes" xml:space="preserve">
          <source>Item gains keyboard grab (&lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt; only).</source>
          <target state="translated">아이템은 키보드 잡기 ( &lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt; 만 해당)를 얻습니다 .</target>
        </trans-unit>
        <trans-unit id="d9bf006d143c45d829320e50970a54f53ffb5f59" translate="yes" xml:space="preserve">
          <source>Item gains mouse grab (&lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt; only).</source>
          <target state="translated">아이템은 마우스 잡기 ( &lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt; 만 해당)를 얻습니다 .</target>
        </trans-unit>
        <trans-unit id="e2b110447bd1706f527420c4ad4abec94a9f83fd" translate="yes" xml:space="preserve">
          <source>Item is a separator. Only tasks category supports separators.</source>
          <target state="translated">항목은 구분 기호입니다. 작업 범주 만 구분 기호를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="ac8384ec23bce7e8a4c667ea77cc8e1492678a85" translate="yes" xml:space="preserve">
          <source>Item layouts can be mirrored using the &lt;a href=&quot;qml-qtquick-layoutmirroring&quot;&gt;LayoutMirroring&lt;/a&gt; attached property. This causes &lt;a href=&quot;qml-qtquick-item#anchors.top-prop&quot;&gt;anchors&lt;/a&gt; to be horizontally reversed, and also causes items that lay out or position their children (such as &lt;a href=&quot;qml-qtquick-listview&quot;&gt;ListView&lt;/a&gt; or &lt;a href=&quot;qml-qtquick-row&quot;&gt;Row&lt;/a&gt;) to horizontally reverse the direction of their layouts.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-layoutmirroring&quot;&gt;LayoutMirroring&lt;/a&gt; 연결된 속성을 사용하여 항목 레이아웃을 미러링 할 수 있습니다 . 이로 인해 &lt;a href=&quot;qml-qtquick-item#anchors.top-prop&quot;&gt;앵커&lt;/a&gt; 가 가로로 반전되고 자식을 배치하거나 배치하는 항목 (예 : &lt;a href=&quot;qml-qtquick-listview&quot;&gt;ListView&lt;/a&gt; 또는 &lt;a href=&quot;qml-qtquick-row&quot;&gt;Row&lt;/a&gt; )이 레이아웃 방향을 가로로 반전시킵니다.</target>
        </trans-unit>
        <trans-unit id="c5adc51350d8893a7dfcd3e6f731a76870e76046" translate="yes" xml:space="preserve">
          <source>Item loses keyboard grab (&lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt; only).</source>
          <target state="translated">항목이 키보드 잡기를 잃습니다 ( &lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt; 만 해당).</target>
        </trans-unit>
        <trans-unit id="fa9b4bac29c744fe12dcb9539227c21e4f0200b1" translate="yes" xml:space="preserve">
          <source>Item loses mouse grab (&lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt;, &lt;a href=&quot;qquickitem&quot;&gt;QQuickItem&lt;/a&gt;).</source>
          <target state="translated">항목이 마우스 잡기 ( &lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt; , &lt;a href=&quot;qquickitem&quot;&gt;QQuickItem&lt;/a&gt; )를 잃습니다 .</target>
        </trans-unit>
        <trans-unit id="abe6d1781ae90355780b2013dfef416755d0227c" translate="yes" xml:space="preserve">
          <source>Item position is specified either in data coordinates or in absolute coordinates, depending on the &lt;a href=&quot;qcustom3ditem#positionAbsolute-prop&quot;&gt;positionAbsolute&lt;/a&gt; property. When using absolute coordinates, values between &lt;code&gt;-1.0...1.0&lt;/code&gt; are within axis ranges.</source>
          <target state="translated">항목 위치는 &lt;a href=&quot;qcustom3ditem#positionAbsolute-prop&quot;&gt;positionAbsolute&lt;/a&gt; 속성 에 따라 데이터 좌표 또는 절대 좌표로 지정 됩니다. 절대 좌표를 사용할 때 &lt;code&gt;-1.0...1.0&lt;/code&gt; 사이의 값은 축 범위 내에 있습니다.</target>
        </trans-unit>
        <trans-unit id="405c9edf27f261290daf417a2ab81cde1d681176" translate="yes" xml:space="preserve">
          <source>Item position is specified either in data coordinates or in absolute coordinates, depending on the value of the &lt;a href=&quot;qml-qtdatavisualization-custom3ditem#positionAbsolute-prop&quot;&gt;positionAbsolute&lt;/a&gt; property. When using absolute coordinates, values between &lt;code&gt;-1.0...1.0&lt;/code&gt; are within axis ranges.</source>
          <target state="translated">항목 위치는 &lt;a href=&quot;qml-qtdatavisualization-custom3ditem#positionAbsolute-prop&quot;&gt;positionAbsolute&lt;/a&gt; 속성 값에 따라 데이터 좌표 또는 절대 좌표로 지정 됩니다. 절대 좌표를 사용할 때 &lt;code&gt;-1.0...1.0&lt;/code&gt; 사이의 값은 축 범위 내에 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a3491e16dfc49da123573cf3ffafe746ec93ecb" translate="yes" xml:space="preserve">
          <source>Item represents a link to an application.</source>
          <target state="translated">항목은 응용 프로그램에 대한 링크를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="960d5f5595f91215aeed822d94655bb5610a8fa6" translate="yes" xml:space="preserve">
          <source>Item roles</source>
          <target state="translated">아이템 역할</target>
        </trans-unit>
        <trans-unit id="ba4cfc57592a7d5ebb2e689a0daffe9faccda501" translate="yes" xml:space="preserve">
          <source>Item scaling is either in data values or in absolute values, depending on the &lt;a href=&quot;qcustom3ditem#scalingAbsolute-prop&quot;&gt;scalingAbsolute&lt;/a&gt; property. The default vector interpreted as absolute values sets the item to 10% of the height of the graph, provided the item mesh is normalized and the graph aspect ratios have not been changed from the defaults.</source>
          <target state="translated">항목 배율은 &lt;a href=&quot;qcustom3ditem#scalingAbsolute-prop&quot;&gt;scalingAbsolute&lt;/a&gt; 속성 에 따라 데이터 값 또는 절대 값으로 표시 됩니다. 절대 값으로 해석되는 기본 벡터는 항목 메쉬가 정규화되고 그래프 종횡비가 기본값에서 변경되지 않은 경우 항목을 그래프 높이의 10 %로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="ab82267a2614879c18f1880c7d81df26c10ed289" translate="yes" xml:space="preserve">
          <source>Item scaling is specified either in data values or in absolute values, depending on the value of the &lt;a href=&quot;qml-qtdatavisualization-custom3ditem#scalingAbsolute-prop&quot;&gt;scalingAbsolute&lt;/a&gt; property. The default vector interpreted as absolute values sets the item to 10% of the height of the graph, provided the item mesh is normalized and the graph aspect ratios have not been changed from the defaults.</source>
          <target state="translated">항목 크기 조정은 &lt;a href=&quot;qml-qtdatavisualization-custom3ditem#scalingAbsolute-prop&quot;&gt;scalingAbsolute&lt;/a&gt; 속성 값에 따라 데이터 값 또는 절대 값으로 지정 됩니다. 절대 값으로 해석되는 기본 벡터는 항목 메쉬가 정규화되고 그래프 종횡비가 기본값에서 변경되지 않은 경우 항목을 그래프 높이의 10 %로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="0074f16162ca8f76fe096adf407ddcdd59ab4b02" translate="yes" xml:space="preserve">
          <source>Item selection mode.</source>
          <target state="translated">아이템 선택 모드.</target>
        </trans-unit>
        <trans-unit id="9e69764dae229258fa95590267574f01e61583f7" translate="yes" xml:space="preserve">
          <source>Item selection modes. Values of this enumeration can be combined with OR operator.</source>
          <target state="translated">아이템 선택 모드. 이 열거의 값은 OR 연산자와 결합 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7c5726e41b643fba2a42b46bb8e1c4764109d76" translate="yes" xml:space="preserve">
          <source>Item size for the series.</source>
          <target state="translated">시리즈의 아이템 사이즈.</target>
        </trans-unit>
        <trans-unit id="2e8dca30b4bdb81076cc2094b5a88dca9313aa33" translate="yes" xml:space="preserve">
          <source>Item specific key handling, e.g. &lt;a href=&quot;qml-qtquick-textinput&quot;&gt;TextInput&lt;/a&gt; key handling</source>
          <target state="translated">품목별 키 처리 (예 : &lt;a href=&quot;qml-qtquick-textinput&quot;&gt;TextInput&lt;/a&gt; 키 처리)</target>
        </trans-unit>
        <trans-unit id="5a532fffe66a3a71159a44a9b3e97c279c89faf6" translate="yes" xml:space="preserve">
          <source>Item to add in a menu or a menu bar</source>
          <target state="translated">메뉴 또는 메뉴 막대에 추가 할 항목</target>
        </trans-unit>
        <trans-unit id="4d7030ddc07030386da8cf100b56ba380a474caf" translate="yes" xml:space="preserve">
          <source>Item transformations accumulate from parent to child, so if both a parent and child item are rotated 90 degrees, the child's total transformation will be 180 degrees. Similarly, if the item's parent is scaled to 2x its original size, its children will also be twice as large. An item's transformation does not affect its own local geometry; all geometry functions (e.g., &lt;a href=&quot;qgraphicsitem#contains&quot;&gt;contains&lt;/a&gt;(), &lt;a href=&quot;qgraphicsitem#update&quot;&gt;update&lt;/a&gt;(), and all the mapping functions) still operate in local coordinates. For convenience, &lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt; provides the functions &lt;a href=&quot;qgraphicsitem#sceneTransform&quot;&gt;sceneTransform&lt;/a&gt;(), which returns the item's total transformation matrix (including its position and all parents' positions and transformations), and &lt;a href=&quot;qgraphicsitem#scenePos&quot;&gt;scenePos&lt;/a&gt;(), which returns its position in scene coordinates. To reset an item's matrix, call &lt;a href=&quot;qgraphicsitem#resetTransform&quot;&gt;resetTransform&lt;/a&gt;().</source>
          <target state="translated">항목 변환은 상위 항목에서 하위 항목으로 누적되므로 상위 항목과 하위 항목이 모두 90도 회전하면 하위의 전체 변형이 180 도가됩니다. 마찬가지로 항목의 부모 크기가 원래 크기의 2 배로 조정되면 자식의 크기도 두 배가됩니다. 항목의 변형은 자체 로컬 지오메트리에 영향을 미치지 않습니다. 모든 지오메트리 함수 (예 : &lt;a href=&quot;qgraphicsitem#contains&quot;&gt;contains&lt;/a&gt; (), &lt;a href=&quot;qgraphicsitem#update&quot;&gt;update&lt;/a&gt; () 및 모든 매핑 함수)는 여전히 로컬 좌표로 작동합니다. 편의상 &lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt; 은 항목의 전체 변환 행렬 (위치 및 모든 부모의 위치 및 변환 포함)과 &lt;a href=&quot;qgraphicsitem#scenePos&quot;&gt;scenePos&lt;/a&gt; 를 반환하는 &lt;a href=&quot;qgraphicsitem#sceneTransform&quot;&gt;sceneTransform&lt;/a&gt; () 함수를 제공합니다.() : 장면 좌표에서 위치를 반환합니다. 항목의 행렬을 재설정하려면 &lt;a href=&quot;qgraphicsitem#resetTransform&quot;&gt;resetTransform&lt;/a&gt; ()을 호출 하십시오 .</target>
        </trans-unit>
        <trans-unit id="ee2012eee00149d102879f6cef822664d27b0b4f" translate="yes" xml:space="preserve">
          <source>Item transformations accumulate from parent to child, so if both a parent and child item are rotated 90 degrees, the child's total transformation will be 180 degrees. Similarly, if the item's parent is scaled to 2x its original size, its children will also be twice as large. An item's transformation does not affect its own local geometry; all geometry functions (e.g., &lt;a href=&quot;qgraphicsitem#contains&quot;&gt;contains&lt;/a&gt;(), &lt;a href=&quot;qgraphicsitem#update&quot;&gt;update&lt;/a&gt;(), and all the mapping functions) still operate in local coordinates. For convenience, QGraphicsItem provides the functions &lt;a href=&quot;qgraphicsitem#sceneTransform&quot;&gt;sceneTransform&lt;/a&gt;(), which returns the item's total transformation matrix (including its position and all parents' positions and transformations), and &lt;a href=&quot;qgraphicsitem#scenePos&quot;&gt;scenePos&lt;/a&gt;(), which returns its position in scene coordinates. To reset an item's matrix, call &lt;a href=&quot;qgraphicsitem#resetTransform&quot;&gt;resetTransform&lt;/a&gt;().</source>
          <target state="translated">항목 변형은 부모에서 자식으로 누적되므로 부모 및 자식 항목이 모두 90도 회전하면 자식의 총 변형은 180 도가됩니다. 마찬가지로 항목의 상위 항목이 원래 크기의 2 배로 조정되면 하위 항목도 두 배로 커집니다. 항목의 변형은 자체 로컬 지오메트리에 영향을주지 않습니다. 모든 지오메트리 함수 (예 : &lt;a href=&quot;qgraphicsitem#contains&quot;&gt;포함&lt;/a&gt; (), &lt;a href=&quot;qgraphicsitem#update&quot;&gt;업데이트&lt;/a&gt; () 및 모든 매핑 함수)는 여전히 로컬 좌표에서 작동합니다. 편의를 위해 QGraphicsItem은 항목의 전체 변환 행렬 (위치와 모든 상위 위치 및 변환 포함)을 반환하는 &lt;a href=&quot;qgraphicsitem#sceneTransform&quot;&gt;sceneTransform&lt;/a&gt; () 함수 와 &lt;a href=&quot;qgraphicsitem#scenePos&quot;&gt;scenePos를 제공합니다.&lt;/a&gt;(), 장면 좌표에서 위치를 반환합니다. 항목의 행렬을 재설정하려면 &lt;a href=&quot;qgraphicsitem#resetTransform&quot;&gt;resetTransform&lt;/a&gt; ()을 호출 하십시오 .</target>
        </trans-unit>
        <trans-unit id="98149105b58e62d631ba2aaf35ad2bb547e37cb1" translate="yes" xml:space="preserve">
          <source>Item value formatted using the format of the value axis attached to the graph. For more information, see &lt;a href=&quot;qvalue3daxis#labelFormat-prop&quot;&gt;QValue3DAxis::labelFormat&lt;/a&gt;.</source>
          <target state="translated">그래프에 첨부 된 값 축의 형식을 사용하여 형식이 지정된 항목 값. 자세한 정보는 &lt;a href=&quot;qvalue3daxis#labelFormat-prop&quot;&gt;QValue3DAxis :: labelFormat을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="266c5eef2bfe7cba9ea69047b08d87122a4dc071" translate="yes" xml:space="preserve">
          <source>Item value formatted using the format of the x-axis. For more information, see &lt;a href=&quot;qvalue3daxis#labelFormat-prop&quot;&gt;QValue3DAxis::setLabelFormat&lt;/a&gt;().</source>
          <target state="translated">x 축 형식을 사용하여 형식이 지정된 항목 값입니다. 자세한 정보는 &lt;a href=&quot;qvalue3daxis#labelFormat-prop&quot;&gt;QValue3DAxis :: setLabelFormat&lt;/a&gt; ()을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a15392e40a7a05434f069780d3b5922e78a3a76c" translate="yes" xml:space="preserve">
          <source>Item value formatted using the format of the y-axis. For more information, see &lt;a href=&quot;qvalue3daxis#labelFormat-prop&quot;&gt;QValue3DAxis::setLabelFormat&lt;/a&gt;().</source>
          <target state="translated">y 축 형식을 사용하여 형식이 지정된 항목 값입니다. 자세한 정보는 &lt;a href=&quot;qvalue3daxis#labelFormat-prop&quot;&gt;QValue3DAxis :: setLabelFormat&lt;/a&gt; ()을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="df6e9a52853b926fcaafc46e06ea634958d81ccf" translate="yes" xml:space="preserve">
          <source>Item value formatted using the format of the z-axis. For more information, see &lt;a href=&quot;qvalue3daxis#labelFormat-prop&quot;&gt;QValue3DAxis::setLabelFormat&lt;/a&gt;().</source>
          <target state="translated">z 축 형식을 사용하여 형식이 지정된 항목 값입니다. 자세한 정보는 &lt;a href=&quot;qvalue3daxis#labelFormat-prop&quot;&gt;QValue3DAxis :: setLabelFormat&lt;/a&gt; ()을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1667ce1c291fa2e017ee5cfcb512c63315e4fcad" translate="yes" xml:space="preserve">
          <source>Item value in the specified format. Formatted using the same rules as &lt;a href=&quot;qvalue3daxis#labelFormat-prop&quot;&gt;QValue3DAxis::labelFormat&lt;/a&gt;.</source>
          <target state="translated">지정된 형식의 항목 값 &lt;a href=&quot;qvalue3daxis#labelFormat-prop&quot;&gt;QValue3DAxis :: labelFormat&lt;/a&gt; 과 동일한 규칙을 사용하여 형식화됩니다 .</target>
        </trans-unit>
        <trans-unit id="66219a56567d29332f23188e5ef2583ab1a729c9" translate="yes" xml:space="preserve">
          <source>Item-based list widget</source>
          <target state="translated">아이템 기반 목록 위젯</target>
        </trans-unit>
        <trans-unit id="1a1ff76828862b83d034c8003013b5f1e0da11c2" translate="yes" xml:space="preserve">
          <source>Item-based table view with a default model</source>
          <target state="translated">기본 모델의 항목 기반 테이블보기</target>
        </trans-unit>
        <trans-unit id="d71ee514f124b58e8efd2db4a7b52e4f5c02db8c" translate="yes" xml:space="preserve">
          <source>Item.activeFocus</source>
          <target state="translated">Item.activeFocus</target>
        </trans-unit>
        <trans-unit id="b0f6ed9324058703ad0abd2e5aeb5b02eb6e2402" translate="yes" xml:space="preserve">
          <source>Item.activeFocusOnTab</source>
          <target state="translated">Item.activeFocusOnTab</target>
        </trans-unit>
        <trans-unit id="99f73e848e1a47d45fb82f37a8abd269ef1ca40a" translate="yes" xml:space="preserve">
          <source>Item.anchors.alignWhenCentered</source>
          <target state="translated">Item.anchors.alignWhenCentered</target>
        </trans-unit>
        <trans-unit id="648dec1468177bac4f366088a738b3ea62295b60" translate="yes" xml:space="preserve">
          <source>Item.antialiasing</source>
          <target state="translated">Item.antialiasing</target>
        </trans-unit>
        <trans-unit id="1dcb68f08b84479f9f044c783c049c51e9bd6f37" translate="yes" xml:space="preserve">
          <source>Item.baselineOffset</source>
          <target state="translated">Item.baselineOffset</target>
        </trans-unit>
        <trans-unit id="c7718760a49c645343545d9cd9a093354e96f659" translate="yes" xml:space="preserve">
          <source>Item.childAt()</source>
          <target state="translated">Item.childAt()</target>
        </trans-unit>
        <trans-unit id="a3fc2c9213406c79300077bd97d61587c1973e50" translate="yes" xml:space="preserve">
          <source>Item.children</source>
          <target state="translated">Item.children</target>
        </trans-unit>
        <trans-unit id="04bf25490fe94f3d6e6629b2c7181a75bf32308d" translate="yes" xml:space="preserve">
          <source>Item.childrenRect.height</source>
          <target state="translated">Item.childrenRect.height</target>
        </trans-unit>
        <trans-unit id="3a8dd3c9d2591e719b4601cb48cc73badd664ce5" translate="yes" xml:space="preserve">
          <source>Item.childrenRect.x</source>
          <target state="translated">Item.childrenRect.x</target>
        </trans-unit>
        <trans-unit id="4b0187fef6a32d6c649de2b82084902abf588068" translate="yes" xml:space="preserve">
          <source>Item.clip</source>
          <target state="translated">Item.clip</target>
        </trans-unit>
        <trans-unit id="50457da7b8530da1c842e0c9fbcdabdc2af272f5" translate="yes" xml:space="preserve">
          <source>Item.containmentMask</source>
          <target state="translated">Item.containmentMask</target>
        </trans-unit>
        <trans-unit id="4112a811d685dae838010670eeceb21eb463885e" translate="yes" xml:space="preserve">
          <source>Item.contains()</source>
          <target state="translated">Item.contains()</target>
        </trans-unit>
        <trans-unit id="e83ea1cf30733780fa3bf018a48498f647d68053" translate="yes" xml:space="preserve">
          <source>Item.data</source>
          <target state="translated">Item.data</target>
        </trans-unit>
        <trans-unit id="ec4421c33b5ed3c25c7cabf458ee157347971931" translate="yes" xml:space="preserve">
          <source>Item.enabled</source>
          <target state="translated">Item.enabled</target>
        </trans-unit>
        <trans-unit id="b5217c23c4612e1c38bd0b262cc273fbedb7f229" translate="yes" xml:space="preserve">
          <source>Item.focus</source>
          <target state="translated">Item.focus</target>
        </trans-unit>
        <trans-unit id="7e84d77c7563d241966998e105ea29a462c0a6ff" translate="yes" xml:space="preserve">
          <source>Item.forceActiveFocus()</source>
          <target state="translated">Item.forceActiveFocus()</target>
        </trans-unit>
        <trans-unit id="e5d5fc7a155fadf6e1e229d97b7e9bb9c711c91f" translate="yes" xml:space="preserve">
          <source>Item.grabToImage()</source>
          <target state="translated">Item.grabToImage()</target>
        </trans-unit>
        <trans-unit id="9bc42682539319d241f292f0a1c5ac600163640f" translate="yes" xml:space="preserve">
          <source>Item.groupanchors.top</source>
          <target state="translated">Item.groupanchors.top</target>
        </trans-unit>
        <trans-unit id="a68c240c117527351080e83f99af7268ad72f2e1" translate="yes" xml:space="preserve">
          <source>Item.height</source>
          <target state="translated">Item.height</target>
        </trans-unit>
        <trans-unit id="a14bc673bba1a441913b86bbf11036c0da50a03e" translate="yes" xml:space="preserve">
          <source>Item.implicitHeight</source>
          <target state="translated">Item.implicitHeight</target>
        </trans-unit>
        <trans-unit id="0f4084fe8ce2d122acd823167e9a6f70b3f1d6de" translate="yes" xml:space="preserve">
          <source>Item.implicitWidth</source>
          <target state="translated">Item.implicitWidth</target>
        </trans-unit>
        <trans-unit id="25eee9287b4d17cf22599dbe165db837874967cc" translate="yes" xml:space="preserve">
          <source>Item.layer.effect</source>
          <target state="translated">Item.layer.effect</target>
        </trans-unit>
        <trans-unit id="704162bd3a73d531caaf128646ec6aaed691b553" translate="yes" xml:space="preserve">
          <source>Item.layer.enabled</source>
          <target state="translated">Item.layer.enabled</target>
        </trans-unit>
        <trans-unit id="e4c54f1e21adf07f7e7758d66aa3afe402d19178" translate="yes" xml:space="preserve">
          <source>Item.layer.format</source>
          <target state="translated">Item.layer.format</target>
        </trans-unit>
        <trans-unit id="aa63a87947ff69acabd457aa4cd57db8aeac0e5b" translate="yes" xml:space="preserve">
          <source>Item.layer.mipmap</source>
          <target state="translated">Item.layer.mipmap</target>
        </trans-unit>
        <trans-unit id="499defac35a26b96e320eabda8161adfe6326538" translate="yes" xml:space="preserve">
          <source>Item.layer.samplerName</source>
          <target state="translated">Item.layer.samplerName</target>
        </trans-unit>
        <trans-unit id="2f60cea2cdbeacc8d47a80f074469ef5897eeb4f" translate="yes" xml:space="preserve">
          <source>Item.layer.samples</source>
          <target state="translated">Item.layer.samples</target>
        </trans-unit>
        <trans-unit id="73039fc683522df7851746a9551fb55c1919b978" translate="yes" xml:space="preserve">
          <source>Item.layer.smooth</source>
          <target state="translated">Item.layer.smooth</target>
        </trans-unit>
        <trans-unit id="64bb4c2c04c06caa9f50836130f8b715ac814543" translate="yes" xml:space="preserve">
          <source>Item.layer.sourceRect</source>
          <target state="translated">Item.layer.sourceRect</target>
        </trans-unit>
        <trans-unit id="55b851c7803a18907f319d8c8609ecfabf7aeaaf" translate="yes" xml:space="preserve">
          <source>Item.layer.textureMirroring</source>
          <target state="translated">Item.layer.textureMirroring</target>
        </trans-unit>
        <trans-unit id="d82e4209c0b3e7801f86eee2e0a2fc1b0fc61aab" translate="yes" xml:space="preserve">
          <source>Item.layer.textureSize</source>
          <target state="translated">Item.layer.textureSize</target>
        </trans-unit>
        <trans-unit id="980865b0abacacaebefa37646d20dd09c4f5898b" translate="yes" xml:space="preserve">
          <source>Item.layer.wrapMode</source>
          <target state="translated">Item.layer.wrapMode</target>
        </trans-unit>
        <trans-unit id="ecee123e02cdc70686f781839f572944d6edee2f" translate="yes" xml:space="preserve">
          <source>Item.mapFromGlobal()</source>
          <target state="translated">Item.mapFromGlobal()</target>
        </trans-unit>
        <trans-unit id="4a4b2ffb92fa06eeaea20c71a62f3910fd71fc36" translate="yes" xml:space="preserve">
          <source>Item.mapFromItem()</source>
          <target state="translated">Item.mapFromItem()</target>
        </trans-unit>
        <trans-unit id="ede43c5043eb8c4fd70f2b9a945d4347bb232282" translate="yes" xml:space="preserve">
          <source>Item.mapToGlobal()</source>
          <target state="translated">Item.mapToGlobal()</target>
        </trans-unit>
        <trans-unit id="980d2bbf8fef9f87dfb5b57982beb3350fd2e4ef" translate="yes" xml:space="preserve">
          <source>Item.mapToItem()</source>
          <target state="translated">Item.mapToItem()</target>
        </trans-unit>
        <trans-unit id="7ff4c1a72926bcb5cad78e784ea4be4d3c778819" translate="yes" xml:space="preserve">
          <source>Item.nextItemInFocusChain()</source>
          <target state="translated">Item.nextItemInFocusChain()</target>
        </trans-unit>
        <trans-unit id="ce16760e64736103c01cc396fa8848126d1259e2" translate="yes" xml:space="preserve">
          <source>Item.opacity</source>
          <target state="translated">Item.opacity</target>
        </trans-unit>
        <trans-unit id="6851de54caba283712995e0c05e73c257493eab9" translate="yes" xml:space="preserve">
          <source>Item.parent</source>
          <target state="translated">Item.parent</target>
        </trans-unit>
        <trans-unit id="bfc1d8d0da7a33fc0e0790f6caac39f2ebfcc08d" translate="yes" xml:space="preserve">
          <source>Item.rotation</source>
          <target state="translated">Item.rotation</target>
        </trans-unit>
        <trans-unit id="24fd4878eb8c2acbe48c8b7f749ad8ae43518ce1" translate="yes" xml:space="preserve">
          <source>Item.scale</source>
          <target state="translated">Item.scale</target>
        </trans-unit>
        <trans-unit id="3a1d14e2fb6b33e4bf90d8a3284577a06f77b967" translate="yes" xml:space="preserve">
          <source>Item.smooth</source>
          <target state="translated">Item.smooth</target>
        </trans-unit>
        <trans-unit id="64605fd62d8814ebea957e1ad660a8078cff122c" translate="yes" xml:space="preserve">
          <source>Item.state</source>
          <target state="translated">Item.state</target>
        </trans-unit>
        <trans-unit id="335ebd19659d8ccd5cb02d2db27578ff765b520e" translate="yes" xml:space="preserve">
          <source>Item.states</source>
          <target state="translated">Item.states</target>
        </trans-unit>
        <trans-unit id="e2616d10e51cb34ab36aac6114b61f0015286ff8" translate="yes" xml:space="preserve">
          <source>Item.transform</source>
          <target state="translated">Item.transform</target>
        </trans-unit>
        <trans-unit id="edfb7d3650e54aa73fe1307707d8564f15fecfac" translate="yes" xml:space="preserve">
          <source>Item.transformOrigin</source>
          <target state="translated">Item.transformOrigin</target>
        </trans-unit>
        <trans-unit id="cc993607e19c8c44433934a7c7308990e9160422" translate="yes" xml:space="preserve">
          <source>Item.transitions</source>
          <target state="translated">Item.transitions</target>
        </trans-unit>
        <trans-unit id="a7a33821c3855b8a2a6c87afb05db9111bdc706b" translate="yes" xml:space="preserve">
          <source>Item.visible</source>
          <target state="translated">Item.visible</target>
        </trans-unit>
        <trans-unit id="bb14ba6eabd7956b136e725fb286ce9e8da2717a" translate="yes" xml:space="preserve">
          <source>Item.visibleChildren</source>
          <target state="translated">Item.visibleChildren</target>
        </trans-unit>
        <trans-unit id="5e026367a5f0743de66e839a214aedc33a7577a5" translate="yes" xml:space="preserve">
          <source>Item.x</source>
          <target state="translated">Item.x</target>
        </trans-unit>
        <trans-unit id="a67f6252957c8222693e45dbf5dca5f206d2e876" translate="yes" xml:space="preserve">
          <source>Item.z</source>
          <target state="translated">Item.z</target>
        </trans-unit>
        <trans-unit id="3cb0cb271daf7d5a69a4c5259c7c358b9ec91d65" translate="yes" xml:space="preserve">
          <source>ItemChangeData Union</source>
          <target state="translated">ItemChangeData 연합</target>
        </trans-unit>
        <trans-unit id="76d2ddf46e72fbdfc28e0108bc64933229f8c97c" translate="yes" xml:space="preserve">
          <source>ItemChangeData::boolValue</source>
          <target state="translated">ItemChangeData::boolValue</target>
        </trans-unit>
        <trans-unit id="96c2fb53d609f4be6ee4d0dedd7d8bcfb1ca9c75" translate="yes" xml:space="preserve">
          <source>ItemChangeData::item</source>
          <target state="translated">ItemChangeData::item</target>
        </trans-unit>
        <trans-unit id="e64ff948a7f5d267348d9f243be1371a47ba35ef" translate="yes" xml:space="preserve">
          <source>ItemChangeData::realValue</source>
          <target state="translated">ItemChangeData::realValue</target>
        </trans-unit>
        <trans-unit id="5c26e35f78ec2e4245418d82b35b9a324ddb0322" translate="yes" xml:space="preserve">
          <source>ItemChangeData::window</source>
          <target state="translated">ItemChangeData::window</target>
        </trans-unit>
        <trans-unit id="e2e4050d7da13944711ac404be89b963b0652545" translate="yes" xml:space="preserve">
          <source>ItemDelegate</source>
          <target state="translated">ItemDelegate</target>
        </trans-unit>
        <trans-unit id="061a717c15d62af52f87fda1ef606cd6fdbb7b10" translate="yes" xml:space="preserve">
          <source>ItemDelegate (QML type)</source>
          <target state="translated">ItemDelegate (QML 유형)</target>
        </trans-unit>
        <trans-unit id="f8b6525eaf0338b9fa30d0fb55193e8bdf8b95a1" translate="yes" xml:space="preserve">
          <source>ItemDelegate Control</source>
          <target state="translated">항목 위임 제어</target>
        </trans-unit>
        <trans-unit id="12bda0d9c1e9c9e0caf42d57d173b423b4b37d51" translate="yes" xml:space="preserve">
          <source>ItemDelegate QML Type</source>
          <target state="translated">ItemDelegate QML 유형</target>
        </trans-unit>
        <trans-unit id="cf151464335cae8f344c0ed43abbbed24a6409e4" translate="yes" xml:space="preserve">
          <source>ItemDelegate inherits its API from &lt;a href=&quot;qml-qtquick-controls2-abstractbutton&quot;&gt;AbstractButton&lt;/a&gt;. For instance, you can set &lt;a href=&quot;qml-qtquick-controls2-abstractbutton#text-prop&quot;&gt;text&lt;/a&gt;, display an &lt;a href=&quot;qtquickcontrols2-icons&quot;&gt;icon&lt;/a&gt;, and react to &lt;a href=&quot;qml-qtquick-controls2-abstractbutton#clicked-signal&quot;&gt;clicks&lt;/a&gt; using the &lt;a href=&quot;qml-qtquick-controls2-abstractbutton&quot;&gt;AbstractButton&lt;/a&gt; API.</source>
          <target state="translated">ItemDelegate는 &lt;a href=&quot;qml-qtquick-controls2-abstractbutton&quot;&gt;AbstractButton&lt;/a&gt; 에서 API를 상속합니다 . 예를 들어 &lt;a href=&quot;qml-qtquick-controls2-abstractbutton&quot;&gt;AbstractButton&lt;/a&gt; API를 사용하여 &lt;a href=&quot;qml-qtquick-controls2-abstractbutton#text-prop&quot;&gt;텍스트&lt;/a&gt; 를 설정 하고 &lt;a href=&quot;qtquickcontrols2-icons&quot;&gt;아이콘을&lt;/a&gt; 표시하고 클릭 에 반응 할 &lt;a href=&quot;qml-qtquick-controls2-abstractbutton#clicked-signal&quot;&gt;수&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ef4fe0cf3313a5e19effd6101790d4a54f8c424" translate="yes" xml:space="preserve">
          <source>ItemDelegate presents a standard view item. It can be used as a delegate in various views and controls, such as &lt;a href=&quot;qml-qtquick-listview&quot;&gt;ListView&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-controls2-combobox&quot;&gt;ComboBox&lt;/a&gt;.</source>
          <target state="translated">ItemDelegate는 표준보기 항목을 제공합니다. &lt;a href=&quot;qml-qtquick-listview&quot;&gt;ListView&lt;/a&gt; 및 &lt;a href=&quot;qml-qtquick-controls2-combobox&quot;&gt;ComboBox&lt;/a&gt; 와 같은 다양한보기 및 컨트롤에서 대리자로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="19f34de73d40c7df6f8d35543173f65144842dd4" translate="yes" xml:space="preserve">
          <source>ItemDelegate presents a standard view item. It can be used as a delegate in various views and controls, such as &lt;a href=&quot;qml-qtquick-listview&quot;&gt;ListView&lt;/a&gt; and &lt;a href=&quot;qtquickcontrols-changes-qt6#combobox&quot;&gt;ComboBox&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbb6b091b8144cc11f08f9461eb154f7e8c90c30" translate="yes" xml:space="preserve">
          <source>ItemDelegate.highlighted</source>
          <target state="translated">ItemDelegate.highlighted</target>
        </trans-unit>
        <trans-unit id="9266f6ec1bbfc565be01364d85713feb2f7673ef" translate="yes" xml:space="preserve">
          <source>ItemGrabResult</source>
          <target state="translated">ItemGrabResult</target>
        </trans-unit>
        <trans-unit id="62a2808fd16bfa5a727bffe9475e9f2ec0a122a0" translate="yes" xml:space="preserve">
          <source>ItemGrabResult (QML type)</source>
          <target state="translated">ItemGrabResult (QML 유형)</target>
        </trans-unit>
        <trans-unit id="9c4dcafec047c8086b54dd7d90b5021907005f14" translate="yes" xml:space="preserve">
          <source>ItemGrabResult QML Type</source>
          <target state="translated">ItemGrabResult QML 유형</target>
        </trans-unit>
        <trans-unit id="f99a69d9f0eeb0c2b35a24a727446561aa3ce2c6" translate="yes" xml:space="preserve">
          <source>ItemGrabResult.image</source>
          <target state="translated">ItemGrabResult.image</target>
        </trans-unit>
        <trans-unit id="7a2678f07ac5add6a0e88b42e7d55e5f8e242584" translate="yes" xml:space="preserve">
          <source>ItemGrabResult.saveToFile()</source>
          <target state="translated">ItemGrabResult.saveToFile()</target>
        </trans-unit>
        <trans-unit id="5fcb44f7f7385467a495b26ed8746132b8f1951b" translate="yes" xml:space="preserve">
          <source>ItemGrabResult.url</source>
          <target state="translated">ItemGrabResult.url</target>
        </trans-unit>
        <trans-unit id="25d6fe855799241be95812106f4fb8d24bd8fb2d" translate="yes" xml:space="preserve">
          <source>ItemModelBarDataProxy</source>
          <target state="translated">ItemModelBarDataProxy</target>
        </trans-unit>
        <trans-unit id="252631736bb9e8c87964de278ca385377a9ea630" translate="yes" xml:space="preserve">
          <source>ItemModelBarDataProxy (QML type)</source>
          <target state="translated">ItemModelBarDataProxy (QML 유형)</target>
        </trans-unit>
        <trans-unit id="095d49ecc1adcc137b82088e004b3cd6f8af1067" translate="yes" xml:space="preserve">
          <source>ItemModelBarDataProxy QML Type</source>
          <target state="translated">ItemModelBarDataProxy QML 유형</target>
        </trans-unit>
        <trans-unit id="33bc3632483b8ee21272fff1f7c77f687b2fbc34" translate="yes" xml:space="preserve">
          <source>ItemModelBarDataProxy.autoColumnCategories</source>
          <target state="translated">ItemModelBarDataProxy.autoColumnCategories</target>
        </trans-unit>
        <trans-unit id="cc9977655bf858a4bd7622880a80bfced30bffe6" translate="yes" xml:space="preserve">
          <source>ItemModelBarDataProxy.autoRowCategories</source>
          <target state="translated">ItemModelBarDataProxy.autoRowCategories</target>
        </trans-unit>
        <trans-unit id="ffca0d87a40366e9628d3df7bb21167d068ececa" translate="yes" xml:space="preserve">
          <source>ItemModelBarDataProxy.columnCategories</source>
          <target state="translated">ItemModelBarDataProxy.columnCategories</target>
        </trans-unit>
        <trans-unit id="17eb182c137622845d297cc0a5fcb95a9eada707" translate="yes" xml:space="preserve">
          <source>ItemModelBarDataProxy.columnRole</source>
          <target state="translated">ItemModelBarDataProxy.columnRole</target>
        </trans-unit>
        <trans-unit id="fa789340debb344d56384cd1fd1884df7b07edb9" translate="yes" xml:space="preserve">
          <source>ItemModelBarDataProxy.columnRolePattern</source>
          <target state="translated">ItemModelBarDataProxy.columnRolePattern</target>
        </trans-unit>
        <trans-unit id="51f8e4549d40bf5fc682dd30bbe7d16362fa8aad" translate="yes" xml:space="preserve">
          <source>ItemModelBarDataProxy.columnRoleReplace</source>
          <target state="translated">ItemModelBarDataProxy.columnRoleReplace</target>
        </trans-unit>
        <trans-unit id="2b3cb55b99ac1ba2ee471294eb2476388009642e" translate="yes" xml:space="preserve">
          <source>ItemModelBarDataProxy.itemModel</source>
          <target state="translated">ItemModelBarDataProxy.itemModel</target>
        </trans-unit>
        <trans-unit id="02af90c81cd96c1332853d9bf97c0e7438972a78" translate="yes" xml:space="preserve">
          <source>ItemModelBarDataProxy.multiMatchBehavior</source>
          <target state="translated">ItemModelBarDataProxy.multiMatchBehavior</target>
        </trans-unit>
        <trans-unit id="0bae27ce81be571a531763233a3008c4e2c6596d" translate="yes" xml:space="preserve">
          <source>ItemModelBarDataProxy.rotationRole</source>
          <target state="translated">ItemModelBarDataProxy.rotationRole</target>
        </trans-unit>
        <trans-unit id="5a28ea345b1d042feec6bf6dd6129f63efd0626c" translate="yes" xml:space="preserve">
          <source>ItemModelBarDataProxy.rotationRolePattern</source>
          <target state="translated">ItemModelBarDataProxy.rotationRolePattern</target>
        </trans-unit>
        <trans-unit id="47a8e07c9eeda1dc487a334e2fa2e0455ef0e29d" translate="yes" xml:space="preserve">
          <source>ItemModelBarDataProxy.rotationRoleReplace</source>
          <target state="translated">ItemModelBarDataProxy.rotationRoleReplace</target>
        </trans-unit>
        <trans-unit id="faa99d07fdf1bd31ab542e5f5c02bd6ec848d04a" translate="yes" xml:space="preserve">
          <source>ItemModelBarDataProxy.rowCategories</source>
          <target state="translated">ItemModelBarDataProxy.rowCategories</target>
        </trans-unit>
        <trans-unit id="6958f9cf9b7dd74f86affa1ed0309c1e7ea0f5e4" translate="yes" xml:space="preserve">
          <source>ItemModelBarDataProxy.rowRole</source>
          <target state="translated">ItemModelBarDataProxy.rowRole</target>
        </trans-unit>
        <trans-unit id="9af56d02c338e8f6e98e8d01149855837b144277" translate="yes" xml:space="preserve">
          <source>ItemModelBarDataProxy.rowRolePattern</source>
          <target state="translated">ItemModelBarDataProxy.rowRolePattern</target>
        </trans-unit>
        <trans-unit id="2c5baf65fe7aa2768be23be40c729caac4c7bc29" translate="yes" xml:space="preserve">
          <source>ItemModelBarDataProxy.rowRoleReplace</source>
          <target state="translated">ItemModelBarDataProxy.rowRoleReplace</target>
        </trans-unit>
        <trans-unit id="e29f8afd146412af918492ee9800e58d5c1ecbb6" translate="yes" xml:space="preserve">
          <source>ItemModelBarDataProxy.useModelCategories</source>
          <target state="translated">ItemModelBarDataProxy.useModelCategories</target>
        </trans-unit>
        <trans-unit id="847c446f92eec01170e4bdb0c4586757fec8a342" translate="yes" xml:space="preserve">
          <source>ItemModelBarDataProxy.valueRole</source>
          <target state="translated">ItemModelBarDataProxy.valueRole</target>
        </trans-unit>
        <trans-unit id="6d88dce67436066eccf7a4f4f74f00176e763c7a" translate="yes" xml:space="preserve">
          <source>ItemModelBarDataProxy.valueRolePattern</source>
          <target state="translated">ItemModelBarDataProxy.valueRolePattern</target>
        </trans-unit>
        <trans-unit id="2d7bc9869f7c4353fdc16b5a2d9c5265033c17c0" translate="yes" xml:space="preserve">
          <source>ItemModelBarDataProxy.valueRoleReplace</source>
          <target state="translated">ItemModelBarDataProxy.valueRoleReplace</target>
        </trans-unit>
        <trans-unit id="9db442fccf817f8c55d4a93b93f17864fdcebb45" translate="yes" xml:space="preserve">
          <source>ItemModelScatterDataProxy</source>
          <target state="translated">ItemModelScatterDataProxy</target>
        </trans-unit>
        <trans-unit id="24fe1905777e20ea518cdd31f9dba5577120d6cd" translate="yes" xml:space="preserve">
          <source>ItemModelScatterDataProxy (QML type)</source>
          <target state="translated">ItemModelScatterDataProxy (QML 유형)</target>
        </trans-unit>
        <trans-unit id="5d040ba40acd09a3995f63133fe8943ac947c55d" translate="yes" xml:space="preserve">
          <source>ItemModelScatterDataProxy QML Type</source>
          <target state="translated">ItemModelScatterDataProxy QML 유형</target>
        </trans-unit>
        <trans-unit id="d3728aed1ff2e86a4080682af4b064b0aacfa50e" translate="yes" xml:space="preserve">
          <source>ItemModelScatterDataProxy.itemModel</source>
          <target state="translated">ItemModelScatterDataProxy.itemModel</target>
        </trans-unit>
        <trans-unit id="b4f4a1d99b29159ea628edd04faaf902043d7a9c" translate="yes" xml:space="preserve">
          <source>ItemModelScatterDataProxy.rotationRole</source>
          <target state="translated">ItemModelScatterDataProxy.rotationRole</target>
        </trans-unit>
        <trans-unit id="aa737e1cb9c29a8a36cbbcb5f220d0af1535aa6b" translate="yes" xml:space="preserve">
          <source>ItemModelScatterDataProxy.rotationRolePattern</source>
          <target state="translated">ItemModelScatterDataProxy.rotationRolePattern</target>
        </trans-unit>
        <trans-unit id="191e290c1df8dfa7c451e45897ad61b018f2e2dd" translate="yes" xml:space="preserve">
          <source>ItemModelScatterDataProxy.rotationRoleReplace</source>
          <target state="translated">ItemModelScatterDataProxy.rotationRoleReplace</target>
        </trans-unit>
        <trans-unit id="d1529189c93dcaa9ea95152a9f5c44dad6504485" translate="yes" xml:space="preserve">
          <source>ItemModelScatterDataProxy.xPosRole</source>
          <target state="translated">ItemModelScatterDataProxy.xPosRole</target>
        </trans-unit>
        <trans-unit id="8c5304b2c4f2a4adb5363b4bc7492b632fd37d2c" translate="yes" xml:space="preserve">
          <source>ItemModelScatterDataProxy.xPosRolePattern</source>
          <target state="translated">ItemModelScatterDataProxy.xPosRolePattern</target>
        </trans-unit>
        <trans-unit id="e346e7d1e45d601e0286c7da44e20d4876e38446" translate="yes" xml:space="preserve">
          <source>ItemModelScatterDataProxy.xPosRoleReplace</source>
          <target state="translated">ItemModelScatterDataProxy.xPosRoleReplace</target>
        </trans-unit>
        <trans-unit id="a69abc69ce2255817f5869cf731a01cf7ea2bbf9" translate="yes" xml:space="preserve">
          <source>ItemModelScatterDataProxy.yPosRole</source>
          <target state="translated">ItemModelScatterDataProxy.yPosRole</target>
        </trans-unit>
        <trans-unit id="bc8a68f341cabc425388b9e04cf70fad458c929b" translate="yes" xml:space="preserve">
          <source>ItemModelScatterDataProxy.yPosRolePattern</source>
          <target state="translated">ItemModelScatterDataProxy.yPosRolePattern</target>
        </trans-unit>
        <trans-unit id="2e913b810d24b77377f7a49c180513ff35e88f0f" translate="yes" xml:space="preserve">
          <source>ItemModelScatterDataProxy.yPosRoleReplace</source>
          <target state="translated">ItemModelScatterDataProxy.yPosRoleReplace</target>
        </trans-unit>
        <trans-unit id="c5ee886e4a0d6218737a05f9ecc0ad0de974e937" translate="yes" xml:space="preserve">
          <source>ItemModelScatterDataProxy.zPosRole</source>
          <target state="translated">ItemModelScatterDataProxy.zPosRole</target>
        </trans-unit>
        <trans-unit id="97d4a42fb297f9defc769686924b5d1333bbedf5" translate="yes" xml:space="preserve">
          <source>ItemModelScatterDataProxy.zPosRolePattern</source>
          <target state="translated">ItemModelScatterDataProxy.zPosRolePattern</target>
        </trans-unit>
        <trans-unit id="347a30e4e1813ddb255d03b078dadf25cca86ed0" translate="yes" xml:space="preserve">
          <source>ItemModelScatterDataProxy.zPosRoleReplace</source>
          <target state="translated">ItemModelScatterDataProxy.zPosRoleReplace</target>
        </trans-unit>
        <trans-unit id="dc50393bd8a9fa2beb3d53a3a77f8f215cb9684f" translate="yes" xml:space="preserve">
          <source>ItemModelSurfaceDataProxy</source>
          <target state="translated">ItemModelSurfaceDataProxy</target>
        </trans-unit>
        <trans-unit id="de4210de2596b98ae92e31354525d334157240ca" translate="yes" xml:space="preserve">
          <source>ItemModelSurfaceDataProxy (QML type)</source>
          <target state="translated">ItemModelSurfaceDataProxy (QML 유형)</target>
        </trans-unit>
        <trans-unit id="bb0145632c975728c52910d3aade20ce0ef3e6d2" translate="yes" xml:space="preserve">
          <source>ItemModelSurfaceDataProxy QML Type</source>
          <target state="translated">ItemModelSurfaceDataProxy QML 유형</target>
        </trans-unit>
        <trans-unit id="409167d10b11021dde2510df1858d2e25a6edf39" translate="yes" xml:space="preserve">
          <source>ItemModelSurfaceDataProxy.autoColumnCategories</source>
          <target state="translated">ItemModelSurfaceDataProxy.autoColumnCategories</target>
        </trans-unit>
        <trans-unit id="b3b26cfb70f90d1d240874bc36aea619d3f647bf" translate="yes" xml:space="preserve">
          <source>ItemModelSurfaceDataProxy.autoRowCategories</source>
          <target state="translated">ItemModelSurfaceDataProxy.autoRowCategories</target>
        </trans-unit>
        <trans-unit id="1e846167d590d8323242dd56b0c08fce53796909" translate="yes" xml:space="preserve">
          <source>ItemModelSurfaceDataProxy.columnCategories</source>
          <target state="translated">ItemModelSurfaceDataProxy.columnCategories</target>
        </trans-unit>
        <trans-unit id="9bb7befc661a5092624b0f5dc66dd53e175467a6" translate="yes" xml:space="preserve">
          <source>ItemModelSurfaceDataProxy.columnRole</source>
          <target state="translated">ItemModelSurfaceDataProxy.columnRole</target>
        </trans-unit>
        <trans-unit id="5b44c33e952fd90a0989bce537e6f035ee7d6bd6" translate="yes" xml:space="preserve">
          <source>ItemModelSurfaceDataProxy.columnRolePattern</source>
          <target state="translated">ItemModelSurfaceDataProxy.columnRolePattern</target>
        </trans-unit>
        <trans-unit id="d5774e73deccc8aeb903fe225dd2b685734e2423" translate="yes" xml:space="preserve">
          <source>ItemModelSurfaceDataProxy.columnRoleReplace</source>
          <target state="translated">ItemModelSurfaceDataProxy.columnRoleReplace</target>
        </trans-unit>
        <trans-unit id="fba9bfeebfd5e26187a6a05c83903b83df9e5bee" translate="yes" xml:space="preserve">
          <source>ItemModelSurfaceDataProxy.itemModel</source>
          <target state="translated">ItemModelSurfaceDataProxy.itemModel</target>
        </trans-unit>
        <trans-unit id="ea8a349fa2509ed30cc7aa35db4d99d9503c0acb" translate="yes" xml:space="preserve">
          <source>ItemModelSurfaceDataProxy.multiMatchBehavior</source>
          <target state="translated">ItemModelSurfaceDataProxy.multiMatchBehavior</target>
        </trans-unit>
        <trans-unit id="cecaf2fdedc6efe146765c314b5c1f725f2122f7" translate="yes" xml:space="preserve">
          <source>ItemModelSurfaceDataProxy.rowCategories</source>
          <target state="translated">ItemModelSurfaceDataProxy.rowCategories</target>
        </trans-unit>
        <trans-unit id="ccc04ac83167a688ed86bb8b712487b685e7b914" translate="yes" xml:space="preserve">
          <source>ItemModelSurfaceDataProxy.rowRole</source>
          <target state="translated">ItemModelSurfaceDataProxy.rowRole</target>
        </trans-unit>
        <trans-unit id="d9a21ed90407e963598308de6a0b36251732956f" translate="yes" xml:space="preserve">
          <source>ItemModelSurfaceDataProxy.rowRolePattern</source>
          <target state="translated">ItemModelSurfaceDataProxy.rowRolePattern</target>
        </trans-unit>
        <trans-unit id="7a9078969e874aabc8dca0e7b7117f44f1b384ee" translate="yes" xml:space="preserve">
          <source>ItemModelSurfaceDataProxy.rowRoleReplace</source>
          <target state="translated">ItemModelSurfaceDataProxy.rowRoleReplace</target>
        </trans-unit>
        <trans-unit id="1d070ae7363b392f7947a5fd68c9fc04511d869b" translate="yes" xml:space="preserve">
          <source>ItemModelSurfaceDataProxy.useModelCategories</source>
          <target state="translated">ItemModelSurfaceDataProxy.useModelCategories</target>
        </trans-unit>
        <trans-unit id="166de7b5b115dd918f4dc2c35fdf45c83d0567b8" translate="yes" xml:space="preserve">
          <source>ItemModelSurfaceDataProxy.xPosRole</source>
          <target state="translated">ItemModelSurfaceDataProxy.xPosRole</target>
        </trans-unit>
        <trans-unit id="ec34f45c3f2f255362b4f8bdc2b5d0517393f1a7" translate="yes" xml:space="preserve">
          <source>ItemModelSurfaceDataProxy.xPosRolePattern</source>
          <target state="translated">ItemModelSurfaceDataProxy.xPosRolePattern</target>
        </trans-unit>
        <trans-unit id="316a5824c1caf2401d4888bbeeee8fef66db2736" translate="yes" xml:space="preserve">
          <source>ItemModelSurfaceDataProxy.xPosRoleReplace</source>
          <target state="translated">ItemModelSurfaceDataProxy.xPosRoleReplace</target>
        </trans-unit>
        <trans-unit id="876e0fc937a5efcb869eac11d69a2cd5be589b59" translate="yes" xml:space="preserve">
          <source>ItemModelSurfaceDataProxy.yPosRole</source>
          <target state="translated">ItemModelSurfaceDataProxy.yPosRole</target>
        </trans-unit>
        <trans-unit id="e6010021e8bfe95c1bd411b8fb3339363702ce06" translate="yes" xml:space="preserve">
          <source>ItemModelSurfaceDataProxy.yPosRolePattern</source>
          <target state="translated">ItemModelSurfaceDataProxy.yPosRolePattern</target>
        </trans-unit>
        <trans-unit id="c2ace34bf57b08a5f74545ee6da3aece0169f82b" translate="yes" xml:space="preserve">
          <source>ItemModelSurfaceDataProxy.yPosRoleReplace</source>
          <target state="translated">ItemModelSurfaceDataProxy.yPosRoleReplace</target>
        </trans-unit>
        <trans-unit id="d80099b8aa8360fc68c61e13735104805e482855" translate="yes" xml:space="preserve">
          <source>ItemModelSurfaceDataProxy.zPosRole</source>
          <target state="translated">ItemModelSurfaceDataProxy.zPosRole</target>
        </trans-unit>
        <trans-unit id="98377022091b759589cf91dbb1a66fea86486ecf" translate="yes" xml:space="preserve">
          <source>ItemModelSurfaceDataProxy.zPosRolePattern</source>
          <target state="translated">ItemModelSurfaceDataProxy.zPosRolePattern</target>
        </trans-unit>
        <trans-unit id="8914993e172e61ddcbe2116798cbf36f58cec1f1" translate="yes" xml:space="preserve">
          <source>ItemModelSurfaceDataProxy.zPosRoleReplace</source>
          <target state="translated">ItemModelSurfaceDataProxy.zPosRoleReplace</target>
        </trans-unit>
        <trans-unit id="510c166f06a31c55ca1796b38c49af972b865608" translate="yes" xml:space="preserve">
          <source>ItemParticle (QML type)</source>
          <target state="translated">ItemParticle (QML 유형)</target>
        </trans-unit>
        <trans-unit id="ec643200fa57d3adbc90b4ef7ccb997c5fa01820" translate="yes" xml:space="preserve">
          <source>ItemParticle QML Type</source>
          <target state="translated">ItemParticle QML 유형</target>
        </trans-unit>
        <trans-unit id="cd7b8ea99d0d3ffb71ac54d53b87523b6de32115" translate="yes" xml:space="preserve">
          <source>ItemParticle.delegate</source>
          <target state="translated">ItemParticle.delegate</target>
        </trans-unit>
        <trans-unit id="168bf87c645df06dfbf58a39ea239d988bebf1b5" translate="yes" xml:space="preserve">
          <source>ItemParticle.fade</source>
          <target state="translated">ItemParticle.fade</target>
        </trans-unit>
        <trans-unit id="5f2797df202436c97730a21aa8ca07ecfb7bc2e1" translate="yes" xml:space="preserve">
          <source>ItemParticle.freeze()</source>
          <target state="translated">ItemParticle.freeze()</target>
        </trans-unit>
        <trans-unit id="105c94b84927800646757a592071c2f259f97ce2" translate="yes" xml:space="preserve">
          <source>ItemParticle.give()</source>
          <target state="translated">ItemParticle.give()</target>
        </trans-unit>
        <trans-unit id="baa621ed4fb486044df0ca4516c536f8108c6d78" translate="yes" xml:space="preserve">
          <source>ItemParticle.take()</source>
          <target state="translated">ItemParticle.take()</target>
        </trans-unit>
        <trans-unit id="816b7a8421510768d96a9531898f621a6badf641" translate="yes" xml:space="preserve">
          <source>ItemParticle.unfreeze()</source>
          <target state="translated">ItemParticle.unfreeze()</target>
        </trans-unit>
        <trans-unit id="b4e182c61cfd75b83e4f068403ec6b5b1cbd3c50" translate="yes" xml:space="preserve">
          <source>ItemSelectionModel (QML type)</source>
          <target state="translated">ItemSelectionModel (QML 유형)</target>
        </trans-unit>
        <trans-unit id="365053800cbdb27788e868134a23f16080fd31db" translate="yes" xml:space="preserve">
          <source>ItemSelectionModel QML Type</source>
          <target state="translated">ItemSelectionModel QML 유형</target>
        </trans-unit>
        <trans-unit id="eae41cb3c566799839ce2f3ed78dc7c31dfd28e9" translate="yes" xml:space="preserve">
          <source>ItemSelectionModel.clear()</source>
          <target state="translated">ItemSelectionModel.clear()</target>
        </trans-unit>
        <trans-unit id="658c25c60f34b6b43dd0eb9c2595d9ea21d779b4" translate="yes" xml:space="preserve">
          <source>ItemSelectionModel.clearCurrentIndex()</source>
          <target state="translated">ItemSelectionModel.clearCurrentIndex()</target>
        </trans-unit>
        <trans-unit id="58f058cd2a3e2d6bac4d6125e1d2afba1d5de9e5" translate="yes" xml:space="preserve">
          <source>ItemSelectionModel.clearSelection()</source>
          <target state="translated">ItemSelectionModel.clearSelection()</target>
        </trans-unit>
        <trans-unit id="781d67c3d53e1a28d8045a5171b02da0de123bfa" translate="yes" xml:space="preserve">
          <source>ItemSelectionModel.columnIntersectsSelection()</source>
          <target state="translated">ItemSelectionModel.columnIntersectsSelection()</target>
        </trans-unit>
        <trans-unit id="716784458671802620862b614462881acc6c0199" translate="yes" xml:space="preserve">
          <source>ItemSelectionModel.currentChanged()</source>
          <target state="translated">ItemSelectionModel.currentChanged()</target>
        </trans-unit>
        <trans-unit id="aa9a00d9e9b9a9ea5b19a1522ad3e1b45baeb0d3" translate="yes" xml:space="preserve">
          <source>ItemSelectionModel.currentIndex</source>
          <target state="translated">ItemSelectionModel.currentIndex</target>
        </trans-unit>
        <trans-unit id="68bd976e26ac0ad40839ad566cf88232b228a864" translate="yes" xml:space="preserve">
          <source>ItemSelectionModel.hasSelection</source>
          <target state="translated">ItemSelectionModel.hasSelection</target>
        </trans-unit>
        <trans-unit id="94280d1f5fe7b111f5fb8554e34a0fb8ab875a27" translate="yes" xml:space="preserve">
          <source>ItemSelectionModel.isColumnSelected()</source>
          <target state="translated">ItemSelectionModel.isColumnSelected()</target>
        </trans-unit>
        <trans-unit id="1d070dde923056eb944bbfa80419df715acfd1db" translate="yes" xml:space="preserve">
          <source>ItemSelectionModel.isRowSelected()</source>
          <target state="translated">ItemSelectionModel.isRowSelected()</target>
        </trans-unit>
        <trans-unit id="f353483c95bfb7eb5e36f2aedec9e948b0fedbee" translate="yes" xml:space="preserve">
          <source>ItemSelectionModel.isSelected()</source>
          <target state="translated">ItemSelectionModel.isSelected()</target>
        </trans-unit>
        <trans-unit id="841a854de63871867abe28a93d902432bda2b08c" translate="yes" xml:space="preserve">
          <source>ItemSelectionModel.model</source>
          <target state="translated">ItemSelectionModel.model</target>
        </trans-unit>
        <trans-unit id="3cc25ed79e859daf2b55a7358889eae3ab3b415e" translate="yes" xml:space="preserve">
          <source>ItemSelectionModel.reset()</source>
          <target state="translated">ItemSelectionModel.reset()</target>
        </trans-unit>
        <trans-unit id="0ff00782bccae101d794a5b2546d8636de09e870" translate="yes" xml:space="preserve">
          <source>ItemSelectionModel.rowIntersectsSelection()</source>
          <target state="translated">ItemSelectionModel.rowIntersectsSelection()</target>
        </trans-unit>
        <trans-unit id="c55528c3b36761c4073ed620961beda8f9f4bc20" translate="yes" xml:space="preserve">
          <source>ItemSelectionModel.select()</source>
          <target state="translated">ItemSelectionModel.select()</target>
        </trans-unit>
        <trans-unit id="7c3ca8577d437912b30592e6e1dce15cc91d843f" translate="yes" xml:space="preserve">
          <source>ItemSelectionModel.selectedColumns()</source>
          <target state="translated">ItemSelectionModel.selectedColumns()</target>
        </trans-unit>
        <trans-unit id="f073ffffd75c1a00d900e7a5f3a149be22c1aa54" translate="yes" xml:space="preserve">
          <source>ItemSelectionModel.selectedIndexes</source>
          <target state="translated">ItemSelectionModel.selectedIndexes</target>
        </trans-unit>
        <trans-unit id="0634f54552caf0cacbc753238215905001f49e2a" translate="yes" xml:space="preserve">
          <source>ItemSelectionModel.selectedRows()</source>
          <target state="translated">ItemSelectionModel.selectedRows()</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
