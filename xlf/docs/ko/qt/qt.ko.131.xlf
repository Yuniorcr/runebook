<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="qt">
    <body>
      <group id="qt">
        <trans-unit id="a07c9e5fba8fdc39616f97bb2231f9e010ed63b9" translate="yes" xml:space="preserve">
          <source>If the material has the RequiresFullMatrix flag set, this is guaranteed to be the complete transform matrix calculated from the scenegraph.</source>
          <target state="translated">머티리얼에 requireFullMatrix 플래그가 설정되어 있으면 장면 그래프에서 계산 된 완전한 변환 매트릭스가됩니다.</target>
        </trans-unit>
        <trans-unit id="2935b5747ad099243e9453f22a0f3bd434e9e584" translate="yes" xml:space="preserve">
          <source>If the material is changed without calling setMaterial() again, the user must also mark the material as dirty using &lt;a href=&quot;qsgnode#markDirty&quot;&gt;QSGNode::markDirty&lt;/a&gt;().</source>
          <target state="translated">setMaterial ()을 다시 호출하지 않고 재료를 변경 한 경우 사용자는 &lt;a href=&quot;qsgnode#markDirty&quot;&gt;QSGNode :: markDirty&lt;/a&gt; ()를 사용하여 재료를 더티로 표시해야합니다 .</target>
        </trans-unit>
        <trans-unit id="836023ee0cf33daa498b09dbca888339f9330daa" translate="yes" xml:space="preserve">
          <source>If the material is changed without calling setOpaqueMaterial() again, the user must also mark the opaque material as dirty using &lt;a href=&quot;qsgnode#markDirty&quot;&gt;QSGNode::markDirty&lt;/a&gt;().</source>
          <target state="translated">setOpaqueMaterial ()을 다시 호출하지 않고 재료를 변경 한 경우, 사용자는 &lt;a href=&quot;qsgnode#markDirty&quot;&gt;QSGNode :: markDirty&lt;/a&gt; ()를 사용하여 불투명 재료를 더티로 표시해야합니다 .</target>
        </trans-unit>
        <trans-unit id="404eeecf1a84a028a400812f6263208f5210b059" translate="yes" xml:space="preserve">
          <source>If the matrix has a special type (identity, translate, scale, etc), the programmer should follow this constructor with a call to &lt;a href=&quot;qmatrix4x4#optimize&quot;&gt;optimize&lt;/a&gt;() if they wish &lt;a href=&quot;qmatrix4x4&quot;&gt;QMatrix4x4&lt;/a&gt; to optimize further calls to &lt;a href=&quot;qmatrix4x4#translate&quot;&gt;translate&lt;/a&gt;(), &lt;a href=&quot;qmatrix4x4#scale&quot;&gt;scale&lt;/a&gt;(), etc.</source>
          <target state="translated">행렬에 특수한 유형 (ID, 변환, 스케일 등)이있는 경우 프로그래머는 &lt;a href=&quot;qmatrix4x4&quot;&gt;QMatrix4x4&lt;/a&gt; 가 &lt;a href=&quot;qmatrix4x4#translate&quot;&gt;변환&lt;/a&gt; (), &lt;a href=&quot;qmatrix4x4#scale&quot;&gt;스케일&lt;/a&gt; () 등의 추가 호출을 최적화하도록 하려면 &lt;a href=&quot;qmatrix4x4#optimize&quot;&gt;최적화 생성&lt;/a&gt; () 을 통해이 생성자를 따라야합니다 .</target>
        </trans-unit>
        <trans-unit id="47c07df6873f4d01f57ae92fad4566b4a39941c5" translate="yes" xml:space="preserve">
          <source>If the matrix has a special type (identity, translate, scale, etc), the programmer should follow this constructor with a call to &lt;a href=&quot;qmatrix4x4#optimize&quot;&gt;optimize&lt;/a&gt;() if they wish QMatrix4x4 to optimize further calls to &lt;a href=&quot;qmatrix4x4#translate&quot;&gt;translate&lt;/a&gt;(), &lt;a href=&quot;qmatrix4x4#scale&quot;&gt;scale&lt;/a&gt;(), etc.</source>
          <target state="translated">행렬에 특수 유형 (ID, 번역, 크기 조정 등)이있는 경우 프로그래머는 QMatrix4x4가 &lt;a href=&quot;qmatrix4x4#translate&quot;&gt;번역&lt;/a&gt; (), &lt;a href=&quot;qmatrix4x4#scale&quot;&gt;크기 조정&lt;/a&gt; () 등의 추가 호출을 최적화하기를 원하는 경우 &lt;a href=&quot;qmatrix4x4#optimize&quot;&gt;최적화&lt;/a&gt; () 호출과 함께이 생성자를 따라야합니다 .</target>
        </trans-unit>
        <trans-unit id="a72596b2b43c12d5545a8174d91447a606802a50" translate="yes" xml:space="preserve">
          <source>If the matrix is recognized as the identity or an orthonormal matrix, then this function will quickly invert the matrix using optimized routines.</source>
          <target state="translated">행렬이 항등 성 또는 직교 정규 행렬로 인식되면이 함수는 최적화 된 루틴을 사용하여 행렬을 빠르게 반전시킵니다.</target>
        </trans-unit>
        <trans-unit id="0298b5199ee082b8361c6bee4ac750335abd3d36" translate="yes" xml:space="preserve">
          <source>If the matrix is singular (not invertible), the returned matrix is the identity matrix. If</source>
          <target state="translated">행렬이 특이 형인 경우 (반전 불가능) 반환 된 행렬은 항등 행렬입니다. 만약</target>
        </trans-unit>
        <trans-unit id="91859466b8d7a8f1b4dadc8a6bdb3a36d6b1379f" translate="yes" xml:space="preserve">
          <source>If the maximum frame</source>
          <target state="translated">최대 프레임 인 경우</target>
        </trans-unit>
        <trans-unit id="ae9a31b44c23be46ee5fc156dd6a76b01e5ea77e" translate="yes" xml:space="preserve">
          <source>If the maximum level is set to a new value that is lower than the existing minimum level, the minimum level is adjusted to the new maximum as well. If the current &lt;a href=&quot;q3dcamera#zoomLevel-prop&quot;&gt;zoomLevel&lt;/a&gt; is outside the new bounds, it is adjusted as well. Defaults to &lt;code&gt;500.0f&lt;/code&gt;.</source>
          <target state="translated">최대 레벨이 기존 최소 레벨보다 낮은 새 값으로 설정되면 최소 레벨도 새 최대 값으로 조정됩니다. 현재 확대 / &lt;a href=&quot;q3dcamera#zoomLevel-prop&quot;&gt;축소 수준&lt;/a&gt; 이 새 범위를 벗어나면 조정됩니다. 기본값은 &lt;code&gt;500.0f&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c04be3be4613b18fe8bc1019f9650b58ccecc63b" translate="yes" xml:space="preserve">
          <source>If the media doesn't have a fixed duration (a live stream for example) this will be 0.</source>
          <target state="translated">미디어에 고정 기간이없는 경우 (예 : 라이브 스트림)이 값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="6e1459c5ca81cde4441a377d8cf898c44771ec4c" translate="yes" xml:space="preserve">
          <source>If the media object does not support monitoring audio, this function will return false.</source>
          <target state="translated">미디어 개체가 오디오 모니터링을 지원하지 않으면이 함수는 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="cc4f4b06d73219f61af5a5db1904f68e198f28ed" translate="yes" xml:space="preserve">
          <source>If the media object does not support monitoring video, this function will return false.</source>
          <target state="translated">미디어 객체가 비디오 모니터링을 지원하지 않으면이 함수는 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1f0bc8a01fea4459d15f95aa9a5e0de55231db62" translate="yes" xml:space="preserve">
          <source>If the media player has already video output attached, it will be replaced with a new one.</source>
          <target state="translated">미디어 플레이어에 이미 비디오 출력이 연결되어 있으면 새 것으로 교체됩니다.</target>
        </trans-unit>
        <trans-unit id="b9ef0a9013c3f8de2f529cccf96d802565d2a707" translate="yes" xml:space="preserve">
          <source>If the media playlist is used as a source, &lt;a href=&quot;qmediaplayer#currentMedia-prop&quot;&gt;QMediaPlayer::currentMedia&lt;/a&gt; is updated with a current playlist item. The current source should be selected with &lt;a href=&quot;qmediaplaylist#setCurrentIndex&quot;&gt;QMediaPlaylist::setCurrentIndex&lt;/a&gt;(int) instead of &lt;a href=&quot;qmediaplayer#setMedia&quot;&gt;QMediaPlayer::setMedia&lt;/a&gt;(), otherwise the current playlist will be discarded.</source>
          <target state="translated">미디어 재생 목록이 소스로 사용되는 경우 &lt;a href=&quot;qmediaplayer#currentMedia-prop&quot;&gt;QMediaPlayer :: currentMedia&lt;/a&gt; 는 현재 재생 목록 항목으로 업데이트됩니다. 현재 소스는 &lt;a href=&quot;qmediaplayer#setMedia&quot;&gt;QMediaPlayer :: setMedia&lt;/a&gt; () 대신 &lt;a href=&quot;qmediaplaylist#setCurrentIndex&quot;&gt;QMediaPlaylist :: setCurrentIndex&lt;/a&gt; (int) 로 선택해야합니다 . 그렇지 않으면 현재 재생 목록이 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="6ff6201337a5b98ec6c2239192004876ab9a52dd" translate="yes" xml:space="preserve">
          <source>If the media recorder instance does not support monitoring audio, this function will return false.</source>
          <target state="translated">미디어 레코더 인스턴스가 오디오 모니터링을 지원하지 않으면이 함수는 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1fec5f3c5ef04df320514982bbac78ec028eed6e" translate="yes" xml:space="preserve">
          <source>If the media recorder instance does not support monitoring video, this function will return false.</source>
          <target state="translated">미디어 레코더 인스턴스가 비디오 모니터링을 지원하지 않으면이 함수는 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="259f1367ec243d269c1c33f8d5effb9228933eb8" translate="yes" xml:space="preserve">
          <source>If the menu is opened in a position where some of its menu items would be outside of &lt;a href=&quot;qml-qtquick-extras-piemenu#boundingItem-prop&quot;&gt;boundingItem&lt;/a&gt;, it is automatically moved to a position where they will not be hidden. By default, the &lt;a href=&quot;qml-qtquick-extras-piemenu#boundingItem-prop&quot;&gt;boundingItem&lt;/a&gt; is set to the parent of the menu. It can also be set to &lt;code&gt;null&lt;/code&gt; to prevent this behavior.</source>
          <target state="translated">메뉴 항목 중 일부가 &lt;a href=&quot;qml-qtquick-extras-piemenu#boundingItem-prop&quot;&gt;boundingItem&lt;/a&gt; 외부에있는 위치에서 메뉴를 열면 메뉴가 숨겨지지 않는 위치로 자동 이동됩니다. 기본적으로 &lt;a href=&quot;qml-qtquick-extras-piemenu#boundingItem-prop&quot;&gt;boundingItem&lt;/a&gt; 은 메뉴의 부모로 설정되어 있습니다. 이 동작을 방지하기 위해 &lt;code&gt;null&lt;/code&gt; 로 설정할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4e13665426cb11931fd1056063ca29387a0f1a07" translate="yes" xml:space="preserve">
          <source>If the menu item doesn't have a shortcut, it will just contain the menu item's text. The default value is an empty string.</source>
          <target state="translated">메뉴 항목에 바로 가기가 없으면 메뉴 항목의 텍스트 만 포함됩니다. 기본값은 빈 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="9ab998a15cfa810daa754aef195bfe9cb1820473" translate="yes" xml:space="preserve">
          <source>If the menu item is a scroller, its pointing direction. Valid values are &lt;code&gt;Qt.UpArrow&lt;/code&gt;, &lt;code&gt;Qt.DownArrow&lt;/code&gt;, and &lt;code&gt;Qt.NoArrow&lt;/code&gt;.</source>
          <target state="translated">메뉴 아이템이 스크롤러 인 경우, 그 지시 방향. 유효한 값은 &lt;code&gt;Qt.UpArrow&lt;/code&gt; , &lt;code&gt;Qt.DownArrow&lt;/code&gt; 및 &lt;code&gt;Qt.NoArrow&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a12aa2c91ce3b22acdcda06f108bc87e61f7fb59" translate="yes" xml:space="preserve">
          <source>If the menu item is checkable, this property reflects its checked state. Defaults to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">메뉴 항목을 검사 할 수 있으면이 속성은 해당 검사 상태를 반영합니다. 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="59e6d14dd3f73218165aa6c8d7be56b961684a41" translate="yes" xml:space="preserve">
          <source>If the menu would not fit on the screen, the other direction is used automatically.</source>
          <target state="translated">메뉴가 화면에 맞지 않으면 다른 방향이 자동으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f3b6f5acccff054700deaabfc58fcf4d34c84b3a" translate="yes" xml:space="preserve">
          <source>If the mesh is &lt;a href=&quot;qabstract3dseries#Mesh-enum&quot;&gt;MeshUserDefined&lt;/a&gt;, then the &lt;a href=&quot;qabstract3dseries#userDefinedMesh-prop&quot;&gt;userDefinedMesh&lt;/a&gt; property must also be set for items to render properly. The default value depends on the graph type.</source>
          <target state="translated">메쉬가 &lt;a href=&quot;qabstract3dseries#Mesh-enum&quot;&gt;MeshUserDefined&lt;/a&gt; 인 경우 항목이 올바르게 렌더링되도록 &lt;a href=&quot;qabstract3dseries#userDefinedMesh-prop&quot;&gt;userDefinedMesh&lt;/a&gt; 속성도 설정해야합니다. 기본값은 그래프 유형에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="4ca0157565da986df4e06a85a102f9aa386557a8" translate="yes" xml:space="preserve">
          <source>If the method has parameters, they are accessible by name within the method. Below, when the &lt;a href=&quot;qml-qtquick-mousearea&quot;&gt;MouseArea&lt;/a&gt; is clicked it invokes the &lt;code&gt;moveTo()&lt;/code&gt; method which can then refer to the received &lt;code&gt;newX&lt;/code&gt; and &lt;code&gt;newY&lt;/code&gt; parameters to reposition the text:</source>
          <target state="translated">메소드에 매개 변수가 있으면 메소드 내에서 이름으로 액세스 할 수 있습니다. 아래에서 &lt;a href=&quot;qml-qtquick-mousearea&quot;&gt;MouseArea&lt;/a&gt; 를 클릭하면 &lt;code&gt;moveTo()&lt;/code&gt; 메소드를 호출 하여 텍스트를 재배치 하기 위해 수신 된 &lt;code&gt;newX&lt;/code&gt; 및 &lt;code&gt;newY&lt;/code&gt; 매개 변수를 참조 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c3edfe4eb339e9c265b026880f7d626e29708a8d" translate="yes" xml:space="preserve">
          <source>If the minimum frame</source>
          <target state="translated">최소 프레임 인 경우</target>
        </trans-unit>
        <trans-unit id="387fdcf2c400d4d7aac65fbb0f83be0996c97e96" translate="yes" xml:space="preserve">
          <source>If the minimum frame rate is equal to the maximum frame rate, the frame rate is fixed. If not, the actual frame rate fluctuates between the minimum and the maximum.</source>
          <target state="translated">최소 프레임 속도가 최대 프레임 속도와 같으면 프레임 속도가 고정됩니다. 그렇지 않으면 실제 프레임 속도가 최소값과 최대 값 사이에서 변동합니다.</target>
        </trans-unit>
        <trans-unit id="ade9109ab6dac5b6d520f9f5afdbb47bb3512cd3" translate="yes" xml:space="preserve">
          <source>If the minimum level is set to a new value that is higher than the existing maximum level, the maximum level is adjusted to the new minimum as well. If the current &lt;a href=&quot;q3dcamera#zoomLevel-prop&quot;&gt;zoomLevel&lt;/a&gt; is outside the new bounds, it is adjusted as well. The minZoomLevel cannot be set below &lt;code&gt;1.0f&lt;/code&gt;. Defaults to &lt;code&gt;10.0f&lt;/code&gt;.</source>
          <target state="translated">최소 레벨이 기존 최대 레벨보다 높은 새 값으로 설정되면 최대 레벨도 새 최소값으로 조정됩니다. 현재 확대 / &lt;a href=&quot;q3dcamera#zoomLevel-prop&quot;&gt;축소 수준&lt;/a&gt; 이 새 범위를 벗어나면 조정됩니다. minZoomLevel은 &lt;code&gt;1.0f&lt;/code&gt; 이하로 설정할 수 없습니다 . 기본값은 &lt;code&gt;10.0f&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7abb704e938970e10bc6b09fe45782ef84ec8d70" translate="yes" xml:space="preserve">
          <source>If the model caches data, it should discard cached data and replace it with data from the underlying data store.</source>
          <target state="translated">모델이 데이터를 캐시하는 경우 캐시 된 데이터를 삭제하고 기본 데이터 저장소의 데이터로 바꿔야합니다.</target>
        </trans-unit>
        <trans-unit id="dab4963e2f372d3de61aaf326cc6db4fc4149754" translate="yes" xml:space="preserve">
          <source>If the model caches data, it should write out cached data to the underlying data store.</source>
          <target state="translated">모델이 데이터를 캐시하는 경우 캐시 된 데이터를 기본 데이터 저장소에 기록해야합니다.</target>
        </trans-unit>
        <trans-unit id="48da8fe3283f47cf58945c388879e74f68573f97" translate="yes" xml:space="preserve">
          <source>If the model is a list, columns will be &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">모델이 목록 인 경우 열은 &lt;code&gt;1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="72fdc0f663d4fce2087717376528ab99425093a7" translate="yes" xml:space="preserve">
          <source>If the model is a read-write model (e.g., &lt;a href=&quot;qsqltablemodel&quot;&gt;QSqlTableModel&lt;/a&gt;), the view lets the user edit the fields. You can disable this by calling</source>
          <target state="translated">모델이 읽기 / 쓰기 모델 인 경우 (예 : &lt;a href=&quot;qsqltablemodel&quot;&gt;QSqlTableModel&lt;/a&gt; )보기를 사용하면 필드를 편집 할 수 있습니다. 당신은 호출하여 이것을 비활성화 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="f065ed6e1e174baa0ea937bd337179ad2de2ce6d" translate="yes" xml:space="preserve">
          <source>If the model is a string list, the delegate is also exposed to a read-only &lt;code&gt;modelData&lt;/code&gt; property that holds the string. For example:</source>
          <target state="translated">모델이 문자열 목록 인 경우 대리자는 문자열을 보유 하는 읽기 전용 &lt;code&gt;modelData&lt;/code&gt; 속성 에도 노출됩니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3ada1c46df02d18e6e659feefcfb0c49336d0b1a" translate="yes" xml:space="preserve">
          <source>If the model is a tree, the parents will be transposed as well. For example, if an index in the source model had parent `index(2,0)`, it will have parent `index(0,2)` in the proxy.</source>
          <target state="translated">모델이 나무이면 부모도 바뀝니다. 예를 들어, 소스 모델의 인덱스에 부모`index (2,0)`가 있으면 프록시에 부모 인덱스 '0 (2,0)'이 있습니다.</target>
        </trans-unit>
        <trans-unit id="2201bd2340b1b1ec723e1b991c5b8bbffe01fd83" translate="yes" xml:space="preserve">
          <source>If the model is already populated with data from a database, the model re-selects it with the new filter. Otherwise, the filter will be applied the next time &lt;a href=&quot;qsqltablemodel#select&quot;&gt;select&lt;/a&gt;() is called.</source>
          <target state="translated">모델이 데이터베이스의 데이터로 이미 채워져있는 경우 모델은 새 필터로 모델을 다시 선택합니다. 그렇지 않으면 다음에 &lt;a href=&quot;qsqltablemodel#select&quot;&gt;select&lt;/a&gt; ()가 호출 될 때 필터가 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="e168ae60bda9b280b69128083aa1c61be17b8277" translate="yes" xml:space="preserve">
          <source>If the model is not initialized, an empty record will be returned.</source>
          <target state="translated">모델이 초기화되지 않으면 빈 레코드가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="9872c367fdf193e8003f29e3e26f1678eddd5841" translate="yes" xml:space="preserve">
          <source>If the model is sorted on the column and role that are used for completion, you can call &lt;a href=&quot;qcompleter#modelSorting-prop&quot;&gt;setModelSorting&lt;/a&gt;() with either &lt;a href=&quot;qcompleter#ModelSorting-enum&quot;&gt;QCompleter::CaseSensitivelySortedModel&lt;/a&gt; or &lt;a href=&quot;qcompleter#ModelSorting-enum&quot;&gt;QCompleter::CaseInsensitivelySortedModel&lt;/a&gt; as the argument. On large models, this can lead to significant performance improvements, because &lt;a href=&quot;qcompleter&quot;&gt;QCompleter&lt;/a&gt; can then use binary search instead of linear search. The binary search only works when the &lt;a href=&quot;qcompleter#filterMode-prop&quot;&gt;filterMode&lt;/a&gt; is &lt;a href=&quot;qt#MatchFlag-enum&quot;&gt;Qt::MatchStartsWith&lt;/a&gt;.</source>
          <target state="translated">모델이 완료에 사용되는 열과 역할에 따라 정렬 된 경우 &lt;a href=&quot;qcompleter#ModelSorting-enum&quot;&gt;QCompleter :: CaseSensitivelySortedModel&lt;/a&gt; 또는 &lt;a href=&quot;qcompleter#ModelSorting-enum&quot;&gt;QCompleter :: CaseInsensitivelySortedModel&lt;/a&gt; 을 인수로 사용하여 &lt;a href=&quot;qcompleter#modelSorting-prop&quot;&gt;setModelSorting&lt;/a&gt; ()을 호출 할 수 있습니다 . 대형 모델에서는 &lt;a href=&quot;qcompleter&quot;&gt;QCompleter&lt;/a&gt; 가 선형 검색 대신 이진 검색을 사용할 수 있으므로 성능이 크게 향상 될 수 있습니다. 이진 검색은 &lt;a href=&quot;qcompleter#filterMode-prop&quot;&gt;filterMode&lt;/a&gt; 가 &lt;a href=&quot;qt#MatchFlag-enum&quot;&gt;Qt :: MatchStartsWith 인&lt;/a&gt; 경우에만 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="93f8769e53fd19b0de8f58be4e81ad3f532233fc" translate="yes" xml:space="preserve">
          <source>If the model is sorted on the column and role that are used for completion, you can call &lt;a href=&quot;qcompleter#modelSorting-prop&quot;&gt;setModelSorting&lt;/a&gt;() with either &lt;a href=&quot;qcompleter#ModelSorting-enum&quot;&gt;QCompleter::CaseSensitivelySortedModel&lt;/a&gt; or &lt;a href=&quot;qcompleter#ModelSorting-enum&quot;&gt;QCompleter::CaseInsensitivelySortedModel&lt;/a&gt; as the argument. On large models, this can lead to significant performance improvements, because QCompleter can then use binary search instead of linear search. The binary search only works when the &lt;a href=&quot;qcompleter#filterMode-prop&quot;&gt;filterMode&lt;/a&gt; is &lt;a href=&quot;qt#MatchFlag-enum&quot;&gt;Qt::MatchStartsWith&lt;/a&gt;.</source>
          <target state="translated">모델이 완료에 사용되는 열과 역할을 기준으로 정렬 된 경우 &lt;a href=&quot;qcompleter#ModelSorting-enum&quot;&gt;QCompleter :: CaseSensitivelySortedModel&lt;/a&gt; 또는 &lt;a href=&quot;qcompleter#ModelSorting-enum&quot;&gt;QCompleter :: CaseInsensitivelySortedModel&lt;/a&gt; 을 인수로 사용하여 &lt;a href=&quot;qcompleter#modelSorting-prop&quot;&gt;setModelSorting&lt;/a&gt; ()을 호출 할 수 있습니다 . 대형 모델에서는 QCompleter가 선형 검색 대신 이진 검색을 사용할 수 있기 때문에 성능이 크게 향상 될 수 있습니다. 이진 검색은 &lt;a href=&quot;qcompleter#filterMode-prop&quot;&gt;filterMode&lt;/a&gt; 가 &lt;a href=&quot;qt#MatchFlag-enum&quot;&gt;Qt :: MatchStartsWith 인&lt;/a&gt; 경우에만 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="54617b8431345e03179740fe37ff21f0c69811c1" translate="yes" xml:space="preserve">
          <source>If the model's data for the &lt;a href=&quot;qcompleter#completionColumn-prop&quot;&gt;completionColumn&lt;/a&gt;() and &lt;a href=&quot;qcompleter#completionRole-prop&quot;&gt;completionRole&lt;/a&gt;() is sorted in ascending order, you can set this property to &lt;a href=&quot;qcompleter#ModelSorting-enum&quot;&gt;CaseSensitivelySortedModel&lt;/a&gt; or &lt;a href=&quot;qcompleter#ModelSorting-enum&quot;&gt;CaseInsensitivelySortedModel&lt;/a&gt;. On large models, this can lead to significant performance improvements because the completer object can then use a binary search algorithm instead of linear search algorithm.</source>
          <target state="translated">&lt;a href=&quot;qcompleter#completionColumn-prop&quot;&gt;completionColumn&lt;/a&gt; () 및 &lt;a href=&quot;qcompleter#completionRole-prop&quot;&gt;completionRole&lt;/a&gt; () 의 모델 데이터 가 오름차순으로 정렬 된 경우이 특성을 &lt;a href=&quot;qcompleter#ModelSorting-enum&quot;&gt;CaseSensitivelySortedModel&lt;/a&gt; 또는 &lt;a href=&quot;qcompleter#ModelSorting-enum&quot;&gt;CaseInsensitivelySortedModel&lt;/a&gt; 로 설정할 수 있습니다 . 대형 모델에서는 완전한 객체가 선형 검색 알고리즘 대신 이진 검색 알고리즘을 사용할 수 있으므로 성능이 크게 향상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9cf739fe8e101008a17a3b5672600329ad6d6b5c" translate="yes" xml:space="preserve">
          <source>If the module was imported into a document-local namespace, the JavaScript resource identifiers must be prefixed with the namespace qualifier in order to be used:</source>
          <target state="translated">모듈을 문서 로컬 네임 스페이스로 가져온 경우 JavaScript 자원 식별자 앞에 네임 스페이스 한정자를 접두어로 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="27bb455ca237b068a07d9b8e21543965d5e75680" translate="yes" xml:space="preserve">
          <source>If the named capturing group</source>
          <target state="translated">명명 된 캡처 그룹이</target>
        </trans-unit>
        <trans-unit id="6cc37aff59db55c30853c1312e7416e614b63b21" translate="yes" xml:space="preserve">
          <source>If the named file/directory does not exist at any of these locations, a warning is printed to the test log.</source>
          <target state="translated">명명 된 파일 / 디렉토리가이 위치에 존재하지 않으면 테스트 로그에 경고가 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="ce8f7e217f1a93a01394b5c7343b060b7df680d0" translate="yes" xml:space="preserve">
          <source>If the named node map does not contain such a node, a &lt;a href=&quot;qdomnode#isNull&quot;&gt;null node&lt;/a&gt; is returned. A node's name is the name returned by &lt;a href=&quot;qdomnode#nodeName&quot;&gt;QDomNode::nodeName&lt;/a&gt;().</source>
          <target state="translated">명명 된 노드 맵에 그러한 노드가 없으면 &lt;a href=&quot;qdomnode#isNull&quot;&gt;널 노드&lt;/a&gt; 가 리턴됩니다. 노드 이름은 &lt;a href=&quot;qdomnode#nodeName&quot;&gt;QDomNode :: nodeName&lt;/a&gt; ()에 의해 리턴되는 이름 입니다.</target>
        </trans-unit>
        <trans-unit id="d757938a032114807f75f4739d456ad8387e8d6e" translate="yes" xml:space="preserve">
          <source>If the namespace contains braces, the returned value is either invalid or has undefined content.</source>
          <target state="translated">네임 스페이스에 중괄호가 포함되어 있으면 반환 된 값이 유효하지 않거나 정의되지 않은 내용이있는 것입니다.</target>
        </trans-unit>
        <trans-unit id="264cabb0d6f89e85204b18fcce33da3c93b81556" translate="yes" xml:space="preserve">
          <source>If the netmask or broadcast address or other information is not necessary, you can call the &lt;a href=&quot;qnetworkinterface#allAddresses&quot;&gt;allAddresses&lt;/a&gt;() function to obtain just the IP addresses of the active interfaces.</source>
          <target state="translated">넷 마스크 또는 브로드 캐스트 주소 또는 기타 정보가 필요하지 않은 경우 &lt;a href=&quot;qnetworkinterface#allAddresses&quot;&gt;allAddresses&lt;/a&gt; () 함수를 호출 하여 활성 인터페이스의 IP 주소 만 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4dc4e8a285bb2166e87714fafecacd4725228575" translate="yes" xml:space="preserve">
          <source>If the network configuration returned by &lt;a href=&quot;qnetworkaccessmanager#configuration&quot;&gt;configuration&lt;/a&gt;() is of type &lt;a href=&quot;qnetworkconfiguration#Type-enum&quot;&gt;QNetworkConfiguration::ServiceNetwork&lt;/a&gt; this function will return the current active child network configuration of that configuration. Otherwise returns the same network configuration as &lt;a href=&quot;qnetworkaccessmanager#configuration&quot;&gt;configuration&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qnetworkaccessmanager#configuration&quot;&gt;configuration&lt;/a&gt; ()에 의해 리턴 된 네트워크 구성 이 &lt;a href=&quot;qnetworkconfiguration#Type-enum&quot;&gt;QNetworkConfiguration :: ServiceNetwork&lt;/a&gt; 유형 인 경우이 기능은 해당 구성의 현재 활성 하위 네트워크 구성을 리턴합니다. 그렇지 않으면 &lt;a href=&quot;qnetworkaccessmanager#configuration&quot;&gt;구성&lt;/a&gt; () 과 동일한 네트워크 구성을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="fbcedaaf1e8df717003c0bbce174aaf99186dd59" translate="yes" xml:space="preserve">
          <source>If the network is &lt;a href=&quot;qnetworkaccessmanager#NetworkAccessibility-enum&quot;&gt;not accessible&lt;/a&gt; the network access manager will not process any new network requests, all such requests will fail with an error. Requests with URLs with the file:// scheme will still be processed.</source>
          <target state="translated">네트워크의 경우 &lt;a href=&quot;qnetworkaccessmanager#NetworkAccessibility-enum&quot;&gt;액세스 할 수 없습니다&lt;/a&gt; 네트워크 액세스 매니저가 새로운 네트워크 요청을 처리하지 않습니다, 이러한 모든 요청이 오류와 함께 실패합니다. file : // 스킴이있는 URL이있는 요청은 계속 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="afe66f37fb5780a4f53bbe06c62010e2153ba388" translate="yes" xml:space="preserve">
          <source>If the new height is less than 0.0 or if this geo rectangle is invalid, the property is not changed. To set up the values of an invalid geo rectangle based on the center, width, and height, you should use &lt;a href=&quot;qgeorectangle#setCenter&quot;&gt;setCenter&lt;/a&gt;() first to make the geo rectangle valid.</source>
          <target state="translated">새 높이가 0.0보다 작거나이 지역 사각형이 유효하지 않은 경우 속성이 변경되지 않습니다. 중심, 너비 및 높이를 기준으로 잘못된 지오 사각형의 값을 설정하려면 먼저 &lt;a href=&quot;qgeorectangle#setCenter&quot;&gt;setCenter&lt;/a&gt; ()를 사용하여 지오 사각형을 유효하게 만들어야합니다.</target>
        </trans-unit>
        <trans-unit id="23a29e819b4a65a27d77fefd890cf33ccbc59315" translate="yes" xml:space="preserve">
          <source>If the new node replaces an existing node, i.e. the map contains a node with the same name, the replaced node is returned.</source>
          <target state="translated">새 노드가 기존 노드를 바꾸는 경우, 즉 맵에 이름이 같은 노드가 있으면 교체 된 노드가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="24c240444260c3a652582f677a86e6b1304769c0" translate="yes" xml:space="preserve">
          <source>If the new parent widget is in a different window, the reparented widget and its children are appended to the end of the &lt;a href=&quot;qwidget#focusPolicy-prop&quot;&gt;tab chain&lt;/a&gt; of the new parent widget, in the same internal order as before. If one of the moved widgets had keyboard focus, setParent() calls &lt;a href=&quot;qwidget#clearFocus&quot;&gt;clearFocus&lt;/a&gt;() for that widget.</source>
          <target state="translated">새 상위 위젯이 다른 창에있는 경우, 상위 위젯 및 해당 하위가 이전과 동일한 내부 순서로 새 상위 위젯 의 &lt;a href=&quot;qwidget#focusPolicy-prop&quot;&gt;탭 체인&lt;/a&gt; 끝에 추가됩니다 . 이동 된 위젯 중 하나에 키보드 포커스가있는 경우 setParent ()는 해당 위젯에 대해 &lt;a href=&quot;qwidget#clearFocus&quot;&gt;clearFocus&lt;/a&gt; ()를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="efd7240d84201141dc43f87d9d45c27c05c9b0f1" translate="yes" xml:space="preserve">
          <source>If the new parent widget is in the same window as the old parent, setting the parent doesn't change the tab order or keyboard focus.</source>
          <target state="translated">새 부모 위젯이 이전 부모와 동일한 창에있는 경우 부모를 설정해도 탭 순서 나 키보드 포커스가 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d4d9879f9a0efb718128e5252d07950e78e3d9c4" translate="yes" xml:space="preserve">
          <source>If the new size is smaller then the current cache size then the cache will call &lt;a href=&quot;qnetworkdiskcache#expire&quot;&gt;expire&lt;/a&gt;().</source>
          <target state="translated">새 크기가 현재 캐시 크기보다 작 으면 캐시는 &lt;a href=&quot;qnetworkdiskcache#expire&quot;&gt;expire&lt;/a&gt; ()를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="2dd6cb16e4c4540a1980e397a4245e25170e4faa" translate="yes" xml:space="preserve">
          <source>If the new width is less than 0.0 or if this geo rectangle is invalid, this function does nothing. To set up the values of an invalid geo rectangle based on the center, width, and height, you should use &lt;a href=&quot;qgeorectangle#setCenter&quot;&gt;setCenter&lt;/a&gt;() first to make the geo rectangle valid.</source>
          <target state="translated">새 너비가 0.0보다 작거나이 지역 사각형이 유효하지 않은 경우이 함수는 아무 작업도 수행하지 않습니다. 중심, 너비 및 높이를 기준으로 잘못된 지오 사각형의 값을 설정하려면 먼저 &lt;a href=&quot;qgeorectangle#setCenter&quot;&gt;setCenter&lt;/a&gt; ()를 사용하여 지오 사각형을 유효하게 만들어야합니다.</target>
        </trans-unit>
        <trans-unit id="c3f3edd6b62a46e5d46e8dbf0b8f2eeaca0d8444" translate="yes" xml:space="preserve">
          <source>If the new window can be created, the new window's &lt;a href=&quot;qwebenginepage&quot;&gt;QWebEnginePage&lt;/a&gt; is returned; otherwise a null pointer is returned.</source>
          <target state="translated">새 창을 만들 수 있으면 새 창의 &lt;a href=&quot;qwebenginepage&quot;&gt;QWebEnginePage&lt;/a&gt; 가 반환됩니다. 그렇지 않으면 널 포인터가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="99cebd73af384751a04c49354a384079f699156a" translate="yes" xml:space="preserve">
          <source>If the node has a namespace prefix, this function changes the namespace prefix of the node to</source>
          <target state="translated">노드에 네임 스페이스 접두사가있는 경우이 함수는 노드의 네임 스페이스 접 두부를 다음으로 변경합니다.</target>
        </trans-unit>
        <trans-unit id="4215f964295fea98309d27adffe85702ad4ed1ab" translate="yes" xml:space="preserve">
          <source>If the node has the flag &lt;a href=&quot;qsgnode#Flag-enum&quot;&gt;QSGNode::OwnsGeometry&lt;/a&gt; set, it will also delete the geometry object it is pointing to. This flag is not set by default.</source>
          <target state="translated">노드에 플래그 &lt;a href=&quot;qsgnode#Flag-enum&quot;&gt;QSGNode :: OwnsGeometry가&lt;/a&gt; 설정되어 있으면, 가리키는 지오메트리 오브젝트도 삭제됩니다. 이 플래그는 기본적으로 설정되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f0adf6dd9b21e0ff32c6204996c8ba71a984eace" translate="yes" xml:space="preserve">
          <source>If the node is a &lt;a href=&quot;qdomnode#isNull&quot;&gt;null node&lt;/a&gt;, it will return an empty string.</source>
          <target state="translated">노드가 &lt;a href=&quot;qdomnode#isNull&quot;&gt;null 노드&lt;/a&gt; 인 경우 빈 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="cfb31cc39108426be78502be9cf68744345fe2e3" translate="yes" xml:space="preserve">
          <source>If the node model maps to a URI in a natural way, return that URI. Otherwise, return the company or product URI. The document URI can be any URI as long as its valid and absolute.</source>
          <target state="translated">노드 모델이 자연스럽게 URI에 맵핑되면 해당 URI를 리턴하십시오. 그렇지 않으면 회사 또는 제품 URI를 반환하십시오. 문서 URI는 유효하고 절대적인 한 임의의 URI 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="59574e8d7871cc298fb2c4b31fffc719310d2e5d" translate="yes" xml:space="preserve">
          <source>If the node uses namespaces, this function returns the local name of the node; otherwise it returns an empty string.</source>
          <target state="translated">노드가 네임 스페이스를 사용하는 경우이 함수는 노드의 로컬 이름을 리턴합니다. 그렇지 않으면 빈 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3edad66ae52ed9d2dd93d2e9ef4a40f72a2423b7" translate="yes" xml:space="preserve">
          <source>If the number of elements in the array is odd, the elements of the array get copied and concatenated. For example, [5, 15, 25] will become [5, 15, 25, 5, 15, 25].</source>
          <target state="translated">배열의 요소 수가 홀수이면 배열의 요소가 복사되고 연결됩니다. 예를 들어 [5, 15, 25]는 [5, 15, 25, 5, 15, 25]가됩니다.</target>
        </trans-unit>
        <trans-unit id="80ed166857aebeba2a71329b3c1f83a1a641d5b1" translate="yes" xml:space="preserve">
          <source>If the number of values is very large, consider applying a filter.</source>
          <target state="translated">값 수가 매우 많은 경우 필터 적용을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="6117b6d571290f592a27bd46ba42fa28a9d3d9d9" translate="yes" xml:space="preserve">
          <source>If the object being created from this component is a visual item, it must have a visual parent, which can be set by calling &lt;a href=&quot;qquickitem#parent-prop&quot;&gt;QQuickItem::setParentItem&lt;/a&gt;(). See &lt;a href=&quot;qtquick-visualcanvas-visualparent&quot;&gt;Concepts - Visual Parent in Qt Quick&lt;/a&gt; for more details.</source>
          <target state="translated">이 컴포넌트에서 작성되는 오브젝트가 시각적 항목 인 경우 &lt;a href=&quot;qquickitem#parent-prop&quot;&gt;QQuickItem :: setParentItem&lt;/a&gt; () 을 호출하여 설정할 수있는 시각적 상위가 있어야합니다 . 자세한 내용 &lt;a href=&quot;qtquick-visualcanvas-visualparent&quot;&gt;은 Qt Quick의 개념-시각적 부모&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="49c12b33f159d7bfab0346dfd9fc477dd739895e" translate="yes" xml:space="preserve">
          <source>If the object has multiple names, the first is returned.</source>
          <target state="translated">객체의 이름이 여러 개인 경우 첫 번째 이름이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="05654701702394e525a7059c2af55ff82d4d03ed" translate="yes" xml:space="preserve">
          <source>If the object has no parent scene, the value is 0.</source>
          <target state="translated">오브젝트에 부모 장면이 없으면 값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="2c3ad6876fe206d0f39bb1351587d2ff267cfbdb" translate="yes" xml:space="preserve">
          <source>If the object is being created in a context that is already part of an asynchronous creation, this incubator will join that existing incubation and execute asynchronously. The existing incubation will not become Ready until both it and this incubation have completed. Otherwise, the incubation will execute synchronously.</source>
          <target state="translated">객체가 이미 비동기 생성의 일부인 컨텍스트에서 생성되는 경우이 인큐베이터는 기존 인큐베이션에 참여하고 비동기 적으로 실행됩니다. 기존 배양은이 배양과이 배양이 완료 될 때까지 준비되지 않습니다. 그렇지 않으면 인큐베이션이 동 기적으로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="5fd82b025fb8eccc21cb3905887c5a9df9f83034" translate="yes" xml:space="preserve">
          <source>If the object or any of its ancestors has &lt;a href=&quot;qobject#Q_CLASSINFO&quot;&gt;Q_CLASSINFO&lt;/a&gt; of type &quot;RemoteObject Type&quot; defined, that type name is used.</source>
          <target state="translated">오브젝트 또는 조상 중 하나에 &quot;RemoteObject Type&quot;유형의 &lt;a href=&quot;qobject#Q_CLASSINFO&quot;&gt;Q_CLASSINFO&lt;/a&gt; 가 정의되어 있으면 해당 유형 이름이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b6ee33efd1c8eba49af880335b467f1cf5b4b1b0" translate="yes" xml:space="preserve">
          <source>If the object or any of its ancestors has &lt;a href=&quot;qobject#Q_CLASSINFO&quot;&gt;Q_CLASSINFO&lt;/a&gt; of type &quot;RemoteObject Type&quot; defined, the defined type name will be used.</source>
          <target state="translated">오브젝트 또는 &lt;a href=&quot;qobject#Q_CLASSINFO&quot;&gt;상위 항목&lt;/a&gt; 에 &quot;RemoteObject Type&quot;유형의 Q_CLASSINFO 가 정의 된 경우 정의 된 유형 이름이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d6e8414d77f1fc4c72dbf05bf4d43227ea2667b9" translate="yes" xml:space="preserve">
          <source>If the object picker is not attached to a leaf node in the scene graph, this is useful to find which child entity was actually picked.</source>
          <target state="translated">오브젝트 선택기가 장면 그래프의 리프 노드에 연결되어 있지 않은 경우 실제로 선택한 자식 엔티티를 찾는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="96f407c51cd16e7ce59ca3755cea359bb8c90283" translate="yes" xml:space="preserve">
          <source>If the object returned is a &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; it will be exposed as an ActiveX control, otherwise the returned object will be exposed as a simple COM object.</source>
          <target state="translated">반환 된 개체가 &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; 이면 ActiveX 컨트롤로 노출되고, 그렇지 않으면 반환 된 개체는 간단한 COM 개체로 노출됩니다.</target>
        </trans-unit>
        <trans-unit id="f06dd15b76b0733dcd13dd4e33f6c893444edc92" translate="yes" xml:space="preserve">
          <source>If the offscreen surface has been created, it will be recreated on the</source>
          <target state="translated">오프 스크린 화면이 생성 된 경우 화면 표면이 다시 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="d92ea18f8f2c3c49bb48e011b981e14beafec9e6" translate="yes" xml:space="preserve">
          <source>If the onCompleted handler instead had &lt;code&gt;&quot;car = new Object({wheels: 6})&quot;&lt;/code&gt; then the text would be updated to say &quot;The car has 6 wheels&quot;, since the car property itself would be changed, which causes a change notification to be emitted.</source>
          <target state="translated">onCompleted 핸들러에 대신 &lt;code&gt;&quot;car = new Object({wheels: 6})&quot;&lt;/code&gt; 가있는 경우 car 속성 자체가 변경되므로 텍스트에 &quot;car에는 6 개의 바퀴가 있습니다&quot;라는 메시지가 업데이트됩니다. 방출된다.</target>
        </trans-unit>
        <trans-unit id="bc1ab1986dab052d82072168079ac9c2ce14d393" translate="yes" xml:space="preserve">
          <source>If the only argument needed is &quot;item&quot;, the following short-hand notation can be applied:</source>
          <target state="translated">필요한 유일한 인수가 &quot;item&quot;인 경우 다음과 같은 속기 표기법을 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="904ce6ceed6bf1fdf72ec37afe3ddbaca9a0dd4e" translate="yes" xml:space="preserve">
          <source>If the operand may be already negative, another step is necessary to normalize the number:</source>
          <target state="translated">피연산자가 이미 음수 인 경우 숫자를 정규화하려면 다른 단계가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="161343ec53569fb898fc9c2f5b94566cd1b564f8" translate="yes" xml:space="preserve">
          <source>If the operating system has a &quot;natural scrolling&quot; setting that causes scrolling to be in the same direction as the finger movement, then if this property is set to &lt;code&gt;true&lt;/code&gt;, and &lt;a href=&quot;qml-qtquick-wheelhandler&quot;&gt;WheelHandler&lt;/a&gt; is directly setting a property on &lt;a href=&quot;qmake-variable-reference#target&quot;&gt;target&lt;/a&gt;, the direction of movement will correspond to the system setting. If this property is set to &lt;code&gt;false&lt;/code&gt;, it will invert the &lt;a href=&quot;qml-qtquick-wheelhandler#rotation-prop&quot;&gt;rotation&lt;/a&gt; so that the direction of motion is always the same as the direction of finger movement.</source>
          <target state="translated">운영 체제에 스크롤링이 손가락 움직임과 같은 방향이되도록하는 &quot;자연 스크롤링&quot;설정이있는 경우이 속성이 &lt;code&gt;true&lt;/code&gt; 로 설정 되고 &lt;a href=&quot;qml-qtquick-wheelhandler&quot;&gt;WheelHandler&lt;/a&gt; 가 &lt;a href=&quot;qmake-variable-reference#target&quot;&gt;target에&lt;/a&gt; 속성을 직접 설정하면 이동 방향이 일치합니다. 시스템 설정에. 이 속성을 &lt;code&gt;false&lt;/code&gt; 로 설정하면 동작 방향이 항상 손가락 이동 방향과 같도록 &lt;a href=&quot;qml-qtquick-wheelhandler#rotation-prop&quot;&gt;회전&lt;/a&gt; 이 반전됩니다 .</target>
        </trans-unit>
        <trans-unit id="92eb75183add692f9b83714a0c684d092bded00a" translate="yes" xml:space="preserve">
          <source>If the operation completed successfully, &lt;a href=&quot;qgeocodereply#setLocations&quot;&gt;QGeoCodeReply::setLocations&lt;/a&gt;() should be called before this function. If an error occurred, &lt;a href=&quot;qgeocodereply#setError&quot;&gt;QGeoCodeReply::setError&lt;/a&gt;() should be used instead.</source>
          <target state="translated">작업이 성공적으로 완료되면 이 함수 전에 &lt;a href=&quot;qgeocodereply#setLocations&quot;&gt;QGeoCodeReply :: setLocations&lt;/a&gt; ()를 호출해야합니다. 오류가 발생하면 &lt;a href=&quot;qgeocodereply#setError&quot;&gt;QGeoCodeReply :: setError&lt;/a&gt; ()를 대신 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="0234aae46f2bdacecea43cab097c2cefc9caa6e0" translate="yes" xml:space="preserve">
          <source>If the operation completed successfully, &lt;a href=&quot;qgeoroutereply#setRoutes&quot;&gt;QGeoRouteReply::setRoutes&lt;/a&gt;() should be called before this function. If an error occurred, &lt;a href=&quot;qgeoroutereply#setError&quot;&gt;QGeoRouteReply::setError&lt;/a&gt;() should be used instead.</source>
          <target state="translated">작업이 성공적으로 완료되면 이 함수 전에 &lt;a href=&quot;qgeoroutereply#setRoutes&quot;&gt;QGeoRouteReply :: setRoutes&lt;/a&gt; ()를 호출해야합니다. 오류가 발생하면 &lt;a href=&quot;qgeoroutereply#setError&quot;&gt;QGeoRouteReply :: setError&lt;/a&gt; ()를 대신 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="783e29e8841968e66c7a90fa5d032fa161efb959" translate="yes" xml:space="preserve">
          <source>If the operation completes successfully the results will be able to be accessed with &lt;a href=&quot;qgeocodereply#locations&quot;&gt;locations&lt;/a&gt;().</source>
          <target state="translated">작업이 성공적으로 완료되면 &lt;a href=&quot;qgeocodereply#locations&quot;&gt;위치&lt;/a&gt; () 를 사용하여 결과에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1f3b169bf7587bf27b2e211762c3bbe19d564600" translate="yes" xml:space="preserve">
          <source>If the operation completes successfully the results will be able to be accessed with &lt;a href=&quot;qgeoroutereply#routes&quot;&gt;routes&lt;/a&gt;().</source>
          <target state="translated">작업이 성공적으로 완료되면 &lt;a href=&quot;qgeoroutereply#routes&quot;&gt;경로&lt;/a&gt; () 를 사용하여 결과에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c75b6aeec836c4223af0bb5cae564258a19ac0cb" translate="yes" xml:space="preserve">
          <source>If the operation is not successful the number of places is always zero.</source>
          <target state="translated">작업이 실패하면 장소 수는 항상 0입니다.</target>
        </trans-unit>
        <trans-unit id="1cee85f5bc67a8d093d09b7855ba680ac02230b2" translate="yes" xml:space="preserve">
          <source>If the operation is successful, the number of places in the reply matches those in the request. If a particular place in the request is not found, a default constructed place is used as a place holder in the reply. In this way, there is always a one is to one relationship between input places in the request, and output places in the reply.</source>
          <target state="translated">작업이 성공하면 응답의 장소 수가 요청의 장소와 일치합니다. 요청에서 특정 장소를 찾을 수없는 경우 기본 생성 된 장소가 회신에서 자리 표시 자로 사용됩니다. 이러한 방식으로 요청의 입력 장소와 응답의 출력 장소 간에는 일대일 관계가 항상 존재합니다.</target>
        </trans-unit>
        <trans-unit id="46f4814e69db2040b6241ac684e4715ee568dc5e" translate="yes" xml:space="preserve">
          <source>If the optional</source>
          <target state="translated">옵션 인 경우</target>
        </trans-unit>
        <trans-unit id="3f83f6c19a489d3df5cb0c756a243ddc206da1d2" translate="yes" xml:space="preserve">
          <source>If the optional parameter</source>
          <target state="translated">선택적 매개 변수 인 경우</target>
        </trans-unit>
        <trans-unit id="71dbcd4da4daf59608513fd579bd90881c2e76c7" translate="yes" xml:space="preserve">
          <source>If the orientation is &lt;a href=&quot;qt#Orientation-enum&quot;&gt;Qt::Horizontal&lt;/a&gt; (the default), a widget is mapped to a column of a data model. The widget will be populated with the model's data from its mapped column and the row that &lt;a href=&quot;qdatawidgetmapper#currentIndex-prop&quot;&gt;currentIndex&lt;/a&gt;() points at.</source>
          <target state="translated">방향이 &lt;a href=&quot;qt#Orientation-enum&quot;&gt;Qt :: Horizontal&lt;/a&gt; (기본값) 인 경우 위젯은 데이터 모델의 열에 매핑됩니다. 위젯은 매핑 된 열과 &lt;a href=&quot;qdatawidgetmapper#currentIndex-prop&quot;&gt;currentIndex&lt;/a&gt; ()가 가리키는 행의 모델 데이터로 채워집니다 .</target>
        </trans-unit>
        <trans-unit id="abaf972625ba74170415c84e80aae3e73dd9970a" translate="yes" xml:space="preserve">
          <source>If the orientation is set to &lt;a href=&quot;qt#Orientation-enum&quot;&gt;Qt::Vertical&lt;/a&gt;, a widget is mapped to a row. Calling &lt;a href=&quot;qdatawidgetmapper#currentIndex-prop&quot;&gt;setCurrentIndex&lt;/a&gt;() will change the current column. The widget will be populates with the model's data from its mapped row and the column that &lt;a href=&quot;qdatawidgetmapper#currentIndex-prop&quot;&gt;currentIndex&lt;/a&gt;() points at.</source>
          <target state="translated">방향이 &lt;a href=&quot;qt#Orientation-enum&quot;&gt;Qt :: Vertical로&lt;/a&gt; 설정되면 위젯이 행에 맵핑됩니다. &lt;a href=&quot;qdatawidgetmapper#currentIndex-prop&quot;&gt;setCurrentIndex&lt;/a&gt; ()를 호출 하면 현재 열이 변경됩니다. 위젯은 매핑 된 행과 &lt;a href=&quot;qdatawidgetmapper#currentIndex-prop&quot;&gt;currentIndex&lt;/a&gt; ()가 가리키는 열의 모델 데이터로 채워집니다 .</target>
        </trans-unit>
        <trans-unit id="b34fe87f6368580767e4846549d9dd86339123dd" translate="yes" xml:space="preserve">
          <source>If the original file does not exist, the original</source>
          <target state="translated">원본 파일이 없으면 원본</target>
        </trans-unit>
        <trans-unit id="53ce591bf00e63514247a7fa2d3cc691e029ae67" translate="yes" xml:space="preserve">
          <source>If the page has no &lt;code&gt;&amp;lt;title&amp;gt;&lt;/code&gt; element, then the URL is used instead. For &lt;code&gt;file://&lt;/code&gt; URLs only the filename is used and not the full path.</source>
          <target state="translated">페이지에 &lt;code&gt;&amp;lt;title&amp;gt;&lt;/code&gt; 요소 가 없으면 URL이 대신 사용됩니다. 들어 &lt;code&gt;file://&lt;/code&gt; 파일 이름 만 사용하는 URL이 아닌 전체 경로입니다.</target>
        </trans-unit>
        <trans-unit id="5a5b9832eed2b628912f313455fe170c9532323a" translate="yes" xml:space="preserve">
          <source>If the page is being inspected by a &lt;a href=&quot;qml-qtwebengine-webengineview#devToolsView-prop&quot;&gt;devToolsView&lt;/a&gt; then both pages must remain in the &lt;code&gt;Active&lt;/code&gt; states.</source>
          <target state="translated">페이지가 &lt;a href=&quot;qml-qtwebengine-webengineview#devToolsView-prop&quot;&gt;devToolsView에&lt;/a&gt; 의해 검사되는 경우 두 페이지가 모두 &lt;code&gt;Active&lt;/code&gt; 상태로 유지되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="61f07bdb449703aeb19d217ffdcac127098438aa" translate="yes" xml:space="preserve">
          <source>If the page is being inspected by a &lt;a href=&quot;qwebenginepage#devToolsPage&quot;&gt;devToolsPage&lt;/a&gt; then both pages must remain in the &lt;code&gt;Active&lt;/code&gt; states.</source>
          <target state="translated">&lt;a href=&quot;qwebenginepage#devToolsPage&quot;&gt;devToolsPage&lt;/a&gt; 에서 페이지를 검사하는 경우 두 페이지는 모두 &lt;code&gt;Active&lt;/code&gt; 상태로 유지되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="5ac55ae2a15e04e0d9d5f2d104999d1b79b6be81" translate="yes" xml:space="preserve">
          <source>If the page is connected to a &lt;a href=&quot;qwebenginepage#view&quot;&gt;view&lt;/a&gt; then this property will be managed automatically by the view according to it's own visibility.</source>
          <target state="translated">페이지가 &lt;a href=&quot;qwebenginepage#view&quot;&gt;보기에&lt;/a&gt; 연결되어있는 경우이 속성은 자체 가시성에 따라보기에서 자동으로 관리됩니다.</target>
        </trans-unit>
        <trans-unit id="96ba643297ab180f44d719a71e5cfaf8273dd112" translate="yes" xml:space="preserve">
          <source>If the paragraph is not a heading, the level should be set to 0 (the default).</source>
          <target state="translated">단락이 제목이 아닌 경우 수준을 0 (기본값)으로 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="82ca20faa4d99f721a1123b1e0361229c17e5464" translate="yes" xml:space="preserve">
          <source>If the parameter value is set to 0, the amount of denoising applied is selected by camera and depends on camera capabilities and settings. Changing value in -1.0..1.0 range adjusts the amount of denoising applied within the supported range.</source>
          <target state="translated">매개 변수 값이 0으로 설정되면 적용되는 노이즈 제거량이 카메라에 의해 선택되며 카메라 기능 및 설정에 따라 다릅니다. -1.0..1.0 범위에서 값을 변경하면 지원되는 범위 내에서 적용되는 노이즈 제거 양이 조정됩니다.</target>
        </trans-unit>
        <trans-unit id="c0c5f85049ac9c3e4dd5ea1db1e30fa6d5800eed" translate="yes" xml:space="preserve">
          <source>If the parent is a &lt;a href=&quot;qtextedit&quot;&gt;QTextEdit&lt;/a&gt;, it installs the syntax highlighter on the parents document. The specified &lt;a href=&quot;qtextedit&quot;&gt;QTextEdit&lt;/a&gt; also becomes the owner of the &lt;a href=&quot;qsyntaxhighlighter&quot;&gt;QSyntaxHighlighter&lt;/a&gt;.</source>
          <target state="translated">부모가 &lt;a href=&quot;qtextedit&quot;&gt;QTextEdit&lt;/a&gt; 인 경우 부모 문서에 구문 형광펜을 설치합니다. 지정된 &lt;a href=&quot;qtextedit&quot;&gt;QTextEdit&lt;/a&gt; 도 &lt;a href=&quot;qsyntaxhighlighter&quot;&gt;QSyntaxHighlighter&lt;/a&gt; 의 소유자가됩니다 .</target>
        </trans-unit>
        <trans-unit id="824eb4e4b2c4af057323e61cc68711ab51d501a4" translate="yes" xml:space="preserve">
          <source>If the parent is a &lt;a href=&quot;qtextedit&quot;&gt;QTextEdit&lt;/a&gt;, it installs the syntax highlighter on the parents document. The specified &lt;a href=&quot;qtextedit&quot;&gt;QTextEdit&lt;/a&gt; also becomes the owner of the QSyntaxHighlighter.</source>
          <target state="translated">부모가 &lt;a href=&quot;qtextedit&quot;&gt;QTextEdit&lt;/a&gt; 이면 부모 문서에 구문 하이 라이터를 설치합니다. 지정된 &lt;a href=&quot;qtextedit&quot;&gt;QTextEdit&lt;/a&gt; 도 QSyntaxHighlighter의 소유자가됩니다.</target>
        </trans-unit>
        <trans-unit id="b9f86bb0d6a8fcd45f8f52dc5dc290fb8bbbdd6c" translate="yes" xml:space="preserve">
          <source>If the parent model index is valid, the drop occurred on an item. In this simple list model, we find out the row number of the item and use that value to insert dropped items into the top level of the model.</source>
          <target state="translated">상위 모델 색인이 유효하면 항목에서 삭제가 발생했습니다. 이 간단한 목록 모델에서는 항목의 행 번호를 찾아 해당 값을 사용하여 삭제 된 항목을 모델의 최상위 레벨에 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="5558ce0cf553099d1b9106ee00886846f86d566a" translate="yes" xml:space="preserve">
          <source>If the parent of this node is not a frame graph node, this method will recursively look for a parent node that is a frame graph node.</source>
          <target state="translated">이 노드의 부모가 프레임 그래프 노드가 아닌 경우이 방법은 프레임 그래프 노드 인 부모 노드를 반복적으로 찾습니다.</target>
        </trans-unit>
        <trans-unit id="1fec16fcd1f4ec35d29d16ed931a6304cf9328c6" translate="yes" xml:space="preserve">
          <source>If the path already exists when this function is called, it will return true.</source>
          <target state="translated">이 함수가 호출 될 때 경로가 이미 존재하면 true를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="1ac5e55f54bd2a260c7fd227575fa88a209ad283" translate="yes" xml:space="preserve">
          <source>If the path doesn't contain any slash, it is fully returned as the fileName.</source>
          <target state="translated">경로에 슬래시가 없으면 fileName으로 완전히 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="e359bed9e99bc5508191fe010472e220b7fe963c" translate="yes" xml:space="preserve">
          <source>If the path is changed, the &lt;a href=&quot;qfilesystemmodel#rootPathChanged&quot;&gt;rootPathChanged&lt;/a&gt;() signal will be emitted.</source>
          <target state="translated">경로가 변경되면 &lt;a href=&quot;qfilesystemmodel#rootPathChanged&quot;&gt;rootPathChanged&lt;/a&gt; () 신호가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="a9065aa64bff2f516e50efda90a4f6d06d6bc426" translate="yes" xml:space="preserve">
          <source>If the pending call has not finished processing, this function also returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">보류중인 통화 처리가 완료되지 않은 경우이 함수는 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="b5328ed2fca2fc1d372710aca47eb89940bd354a" translate="yes" xml:space="preserve">
          <source>If the pending call has not finished processing, this function return false.</source>
          <target state="translated">보류중인 통화 처리가 완료되지 않은 경우이 함수는 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="164664c5927040472a83d978e5d04b8d4d147a58" translate="yes" xml:space="preserve">
          <source>If the pipeline contains a &lt;code&gt;qtvideosink&lt;/code&gt; element, the current &lt;a href=&quot;qml-qtmultimedia-videooutput&quot;&gt;VideoOutput&lt;/a&gt; will be used for rendering video.</source>
          <target state="translated">파이프 라인에 &lt;code&gt;qtvideosink&lt;/code&gt; 요소 가 포함 된 경우 현재 &lt;a href=&quot;qml-qtmultimedia-videooutput&quot;&gt;VideoOutput&lt;/a&gt; 이 비디오 렌더링에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ababf4540c1ea2d02410e77a1a572c87a30b7308" translate="yes" xml:space="preserve">
          <source>If the pipeline contains appsrc element, it will be used to push data from</source>
          <target state="translated">파이프 라인에 appsrc 요소가 포함 된 경우 데이터를 푸시하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5ba81458c17e1b14fccd7eaa023fc2a0ccd1fab2" translate="yes" xml:space="preserve">
          <source>If the pixmap has 1-bit depth, the returned image will also be 1 bit deep. Images with more bits will be returned in a format closely represents the underlying system. Usually this will be &lt;a href=&quot;qimage#Format-enum&quot;&gt;QImage::Format_ARGB32_Premultiplied&lt;/a&gt; for pixmaps with an alpha and &lt;a href=&quot;qimage#Format-enum&quot;&gt;QImage::Format_RGB32&lt;/a&gt; or &lt;a href=&quot;qimage#Format-enum&quot;&gt;QImage::Format_RGB16&lt;/a&gt; for pixmaps without alpha.</source>
          <target state="translated">픽스맵의 깊이가 1 비트이면 반환 된 이미지의 깊이도 1 비트입니다. 더 많은 비트를 가진 이미지는 기본 시스템을 나타내는 형식으로 반환됩니다. 일반적으로 알파가있는 픽스맵의 경우 &lt;a href=&quot;qimage#Format-enum&quot;&gt;QImage :: Format_ARGB32_Premultiplied&lt;/a&gt; 이고 알파가없는 픽스맵의 경우 &lt;a href=&quot;qimage#Format-enum&quot;&gt;QImage :: Format_RGB32&lt;/a&gt; 또는 &lt;a href=&quot;qimage#Format-enum&quot;&gt;QImage :: Format_RGB16&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="52513d22bc83fc7b86aa6b533bb4aa745f2dc3bf" translate="yes" xml:space="preserve">
          <source>If the pixmap has a depth greater than 1, the resulting bitmap will be dithered automatically.</source>
          <target state="translated">픽스맵의 깊이가 1보다 크면 결과 비트 맵이 자동으로 디더링됩니다.</target>
        </trans-unit>
        <trans-unit id="406ee417b8227ab280c03081825639d557d119be" translate="yes" xml:space="preserve">
          <source>If the platform does not support out-of-process sessions calling this function does not stop the interface. In this case &lt;a href=&quot;qnetworksession#stop&quot;&gt;stop&lt;/a&gt;() has to be used to force a shut down. The platform capabilities can be detected via &lt;a href=&quot;qnetworkconfigurationmanager#capabilities&quot;&gt;QNetworkConfigurationManager::capabilities&lt;/a&gt;().</source>
          <target state="translated">플랫폼이 프로세스 외 세션을 지원하지 않으면이 함수를 호출해도 인터페이스가 중지되지 않습니다. 이 경우 &lt;a href=&quot;qnetworksession#stop&quot;&gt;stop&lt;/a&gt; ()을 사용하여 강제로 종료해야합니다. 플랫폼 기능은 &lt;a href=&quot;qnetworkconfigurationmanager#capabilities&quot;&gt;QNetworkConfigurationManager :: capabilities&lt;/a&gt; () 를 통해 감지 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="be65e79f5bbf72f1fc6bc0780b8f05d3e4e441c3" translate="yes" xml:space="preserve">
          <source>If the platform does not support the Object Push profile, this function will return &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">플랫폼이 오브젝트 푸시 프로파일을 지원하지 않으면이 함수는 &lt;code&gt;0&lt;/code&gt; 을 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="bee5fe3ccfe48c9443bab035e6dfc985cea56715" translate="yes" xml:space="preserve">
          <source>If the platform is supported and the serial port is open, returns the native serial port handle; otherwise returns &lt;code&gt;-1&lt;/code&gt;.</source>
          <target state="translated">플랫폼이 지원되고 직렬 포트가 열려 있으면 기본 직렬 포트 핸들을 반환합니다. 그렇지 않으면 &lt;code&gt;-1&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="79cc294a40a66d7bb8ff9bb2f11a3e237965ab09" translate="yes" xml:space="preserve">
          <source>If the platform supports both modes of roaming, an application indicates its preference by connecting to the &lt;a href=&quot;qnetworksession#preferredConfigurationChanged&quot;&gt;preferredConfigurationChanged&lt;/a&gt;() signal. Connecting to this signal means that the application wants to take control over the roaming behavior and therefore implies application level roaming. If the client does not connect to the &lt;a href=&quot;qnetworksession#preferredConfigurationChanged&quot;&gt;preferredConfigurationChanged&lt;/a&gt;(), forced roaming is used. If forced roaming is not supported the network session will not roam by default.</source>
          <target state="translated">플랫폼이 두 가지 로밍 모드를 모두 지원하는 경우 응용 프로그램은 &lt;a href=&quot;qnetworksession#preferredConfigurationChanged&quot;&gt;preferredConfigurationChanged&lt;/a&gt; () 신호 에 연결하여 기본 설정을 나타냅니다 . 이 신호에 연결하면 응용 프로그램이 로밍 동작을 제어하려고하므로 응용 프로그램 수준 로밍을 의미합니다. 클라이언트가 &lt;a href=&quot;qnetworksession#preferredConfigurationChanged&quot;&gt;preferredConfigurationChanged&lt;/a&gt; ()에 연결하지 않으면 강제 로밍이 사용됩니다. 강제 로밍이 지원되지 않으면 네트워크 세션이 기본적으로 로밍되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f64fe765ec4f683bbb07595a8642d3530ab6a9d3" translate="yes" xml:space="preserve">
          <source>If the plugin fails to load, &lt;a href=&quot;qtexttospeech#state-prop&quot;&gt;QTextToSpeech::state&lt;/a&gt;() returns &lt;a href=&quot;qtexttospeech#State-enum&quot;&gt;QTextToSpeech::BackendError&lt;/a&gt;.</source>
          <target state="translated">플러그인이로드되지 않으면 &lt;a href=&quot;qtexttospeech#state-prop&quot;&gt;QTextToSpeech :: state&lt;/a&gt; ()는 &lt;a href=&quot;qtexttospeech#State-enum&quot;&gt;QTextToSpeech :: BackendError를&lt;/a&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="eb5b3409b9d3d3974098428f73dc847bb42b3150" translate="yes" xml:space="preserve">
          <source>If the plugin metadata contains &lt;code&gt;InputMethod&lt;/code&gt; field defining an input method name, Qt Virtual Keyboard will call registerTypes() for registering the input method as QML type. The type must be registered with a</source>
          <target state="translated">플러그인 메타 데이터 에 입력 메소드 이름을 정의하는 &lt;code&gt;InputMethod&lt;/code&gt; 필드 가 포함 된 경우 Qt 가상 키보드는 입력 메소드를 QML 유형으로 등록하기 위해 registerTypes ()를 호출합니다. 유형은</target>
        </trans-unit>
        <trans-unit id="ceade8dd56fb522c2223be201e7cbe9691b8b58b" translate="yes" xml:space="preserve">
          <source>If the plugin supports paging, the limit parameter may be provided to the search request.</source>
          <target state="translated">플러그인이 페이징을 지원하는 경우 limit 매개 변수가 검색 요청에 제공 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3b8a52f2eb986354d273500631495862b643a02d" translate="yes" xml:space="preserve">
          <source>If the plugins provided by Qt are not suitable for the required target platform, a custom CAN bus plugin can be implemented. The implementation follows the standard way of implementing Qt plug-ins. The custom plugin must be deployed to &lt;code&gt;$QTDIR/plugins/canbus&lt;/code&gt;.</source>
          <target state="translated">Qt에서 제공하는 플러그인이 필요한 대상 플랫폼에 적합하지 않은 경우 사용자 정의 CAN 버스 플러그인을 구현할 수 있습니다. 구현은 Qt 플러그인을 구현하는 표준 방식을 따릅니다. 사용자 정의 플러그인은 &lt;code&gt;$QTDIR/plugins/canbus&lt;/code&gt; 배치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="4ef6b119dafc8d048d22f9d72c489939d10dfaf9" translate="yes" xml:space="preserve">
          <source>If the position source is not active, it will be activated for as long as it takes to receive an update, or until the request times out. The request timeout period is source-specific.</source>
          <target state="translated">위치 소스가 활성화되어 있지 않으면 업데이트를받는 동안 또는 요청 시간이 초과 될 때까지 활성화됩니다. 요청 시간 초과 기간은 소스별로 다릅니다.</target>
        </trans-unit>
        <trans-unit id="f69f66464f34fd54d160ce8eab45e305410f0ef5" translate="yes" xml:space="preserve">
          <source>If the preceding stream operations were successful, sets the status of the data stream to</source>
          <target state="translated">이전 스트림 작업이 성공한 경우 데이터 스트림의 상태를</target>
        </trans-unit>
        <trans-unit id="da111151ccfd7b5a23524b9b274b3b02b2a3de40" translate="yes" xml:space="preserve">
          <source>If the preferred height of your widget depends on its actual width (e.g., a label with automatic word-breaking), set the &lt;a href=&quot;qsizepolicy#hasHeightForWidth&quot;&gt;height-for-width&lt;/a&gt; flag in the widget's &lt;a href=&quot;qwidget#sizePolicy-prop&quot;&gt;size policy&lt;/a&gt; and reimplement &lt;a href=&quot;qwidget#heightForWidth&quot;&gt;QWidget::heightForWidth&lt;/a&gt;().</source>
          <target state="translated">위젯의 선호 높이가 실제 너비 (예 : 자동 단어 구분이있는 레이블)에 의존하는 경우 위젯의 &lt;a href=&quot;qwidget#sizePolicy-prop&quot;&gt;크기 정책&lt;/a&gt; 에서 &lt;a href=&quot;qsizepolicy#hasHeightForWidth&quot;&gt;너비&lt;/a&gt; 의 높이 플래그 를 설정하고 &lt;a href=&quot;qwidget#heightForWidth&quot;&gt;QWidget :: heightForWidth&lt;/a&gt; ()를 다시 구현하십시오 .</target>
        </trans-unit>
        <trans-unit id="5f2000ed01bcf811a5f08096db4afbd6401cfa4b" translate="yes" xml:space="preserve">
          <source>If the previous value was 0, the new value will be 1. If the previous value was 1, the new value will be 0.</source>
          <target state="translated">이전 값이 0 인 경우 새 값은 1이됩니다. 이전 값이 1 인 경우 새 값은 0이됩니다.</target>
        </trans-unit>
        <trans-unit id="47f0f981481651e7ca408ca2e3a8e62335e485f9" translate="yes" xml:space="preserve">
          <source>If the primary series itself is removed from the graph, this property resets to default.</source>
          <target state="translated">기본 계열 자체가 그래프에서 제거되면이 속성이 기본값으로 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="208a6c08043f3cd34c5508451bda39087b478b70" translate="yes" xml:space="preserve">
          <source>If the printer selection option is changed while the printer is active, the current print job may or may not be affected.</source>
          <target state="translated">프린터가 활성화되어있는 동안 프린터 선택 옵션을 변경하면 현재 인쇄 작업에 영향을 주거나받지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d31ad71a331d9004f2bdb2ca9909ceb33a3207d" translate="yes" xml:space="preserve">
          <source>If the process cannot be started, -2 is returned. If the process crashes, -1 is returned. Otherwise, the process' exit code is returned.</source>
          <target state="translated">프로세스를 시작할 수 없으면 -2가 리턴됩니다. 프로세스가 충돌하면 -1이 반환됩니다. 그렇지 않으면 프로세스 종료 코드가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="e312456e1c0785a3c06bdd68552417e8f8b65ef4" translate="yes" xml:space="preserve">
          <source>If the process holding the lock crashes, the lock file stays on disk and can prevent any other process from accessing the shared resource, ever. For this reason, &lt;a href=&quot;qlockfile&quot;&gt;QLockFile&lt;/a&gt; tries to detect such a &quot;stale&quot; lock file, based on the process ID written into the file. To cover the situation that the process ID got reused meanwhile, the current process name is compared to the name of the process that corresponds to the process ID from the lock file. If the process names differ, the lock file is considered stale. Additionally, the last modification time of the lock file (30s by default, for the use case of a short-lived operation) is taken into account. If the lock file is found to be stale, it will be deleted.</source>
          <target state="translated">잠금을 보유한 프로세스가 충돌하면 잠금 파일이 디스크에 남아있어 다른 프로세스가 공유 자원에 액세스하지 못하게 할 수 있습니다. 이러한 이유로 &lt;a href=&quot;qlockfile&quot;&gt;QLockFile&lt;/a&gt; 은 파일에 기록 된 프로세스 ID를 기반으로 이러한 &quot;stale&quot;잠금 파일을 감지하려고합니다. 프로세스 ID가 재사용 된 상황을 처리하기 위해 현재 프로세스 이름은 잠금 파일의 프로세스 ID에 해당하는 프로세스 이름과 비교됩니다. 프로세스 이름이 다르면 잠금 파일이 오래된 것으로 간주됩니다. 또한 잠금 파일의 마지막 수정 시간 (기본적으로 수명이 짧은 작업의 경우 30 초)이 고려됩니다. 잠금 파일이 오래된 것으로 판명되면 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="46d219d610ead83e598497a6abc8c081e2f7b85c" translate="yes" xml:space="preserve">
          <source>If the process holding the lock crashes, the lock file stays on disk and can prevent any other process from accessing the shared resource, ever. For this reason, QLockFile tries to detect such a &quot;stale&quot; lock file, based on the process ID written into the file. To cover the situation that the process ID got reused meanwhile, the current process name is compared to the name of the process that corresponds to the process ID from the lock file. If the process names differ, the lock file is considered stale. Additionally, the last modification time of the lock file (30s by default, for the use case of a short-lived operation) is taken into account. If the lock file is found to be stale, it will be deleted.</source>
          <target state="translated">잠금을 보유한 프로세스가 충돌하면 잠금 파일은 디스크에 남아 있으며 다른 프로세스가 공유 리소스에 액세스하는 것을 방지 할 수 있습니다. 이러한 이유로 QLockFile은 파일에 기록 된 프로세스 ID를 기반으로 이러한 &quot;부실&quot;잠금 파일을 감지하려고 시도합니다. 한편 프로세스 ID가 재사용 된 상황을 다루기 위해 현재 프로세스 이름을 잠금 파일의 프로세스 ID에 해당하는 프로세스 이름과 비교합니다. 프로세스 이름이 다른 경우 잠금 파일은 오래된 것으로 간주됩니다. 또한 잠금 파일의 마지막 수정 시간 (단기 작업의 경우 기본적으로 30 초)이 고려됩니다. 잠금 파일이 오래된 것으로 확인되면 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="f990f55d868d2997df26fb21704959525e6e36f2" translate="yes" xml:space="preserve">
          <source>If the profile is not the default profile, the caller must ensure that the profile stays alive for as long as the page does.</source>
          <target state="translated">프로필이 기본 프로필이 아닌 경우 호출자는 페이지가있는 한 프로필이 활성 상태로 유지되도록해야합니다.</target>
        </trans-unit>
        <trans-unit id="2a38832044b1f88df50ab1ff460d629849d3d408" translate="yes" xml:space="preserve">
          <source>If the profile is off-the-record, &lt;a href=&quot;qquickwebengineprofile#HttpCacheType-enum&quot;&gt;MemoryHttpCache&lt;/a&gt; is returned.</source>
          <target state="translated">프로필이 레코드에없는 경우 &lt;a href=&quot;qquickwebengineprofile#HttpCacheType-enum&quot;&gt;MemoryHttpCache&lt;/a&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="71b4dce528709c7ca20412216fd9674733a1c7f1" translate="yes" xml:space="preserve">
          <source>If the profile is off-the-record, &lt;a href=&quot;qwebengineprofile#HttpCacheType-enum&quot;&gt;MemoryHttpCache&lt;/a&gt; is returned.</source>
          <target state="translated">프로필이 레코드에없는 경우 &lt;a href=&quot;qwebengineprofile#HttpCacheType-enum&quot;&gt;MemoryHttpCache&lt;/a&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="670b7e500ce69216aa74493bf4af8a3c4c8f35e6" translate="yes" xml:space="preserve">
          <source>If the profile is off-the-record, &lt;a href=&quot;qwebengineprofile#PersistentCookiesPolicy-enum&quot;&gt;NoPersistentCookies&lt;/a&gt; is returned.</source>
          <target state="translated">프로필이 기록에 &lt;a href=&quot;qwebengineprofile#PersistentCookiesPolicy-enum&quot;&gt;맞지 않으면 NoPersistentCookies&lt;/a&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="14355064ada4c4afd34d2a4662a2e19952c55c67" translate="yes" xml:space="preserve">
          <source>If the program can determine whether the field is needed, it can move focus there when the user finishes entry and presses &lt;b&gt;OK&lt;/b&gt;, or when the user presses Enter after finishing the other fields. Alternately, include the field in the tab order but disable it. Enable it if it becomes appropriate in view of what the user has set in the other fields.</source>
          <target state="translated">프로그램이 필드가 필요한지 여부를 판별 할 수 있으면 사용자가 입력을 마치고 &lt;b&gt;확인을&lt;/b&gt; 누르 거나 다른 필드를 완료 한 후 Enter를 누를 때 포커스를 이동시킬 수 있습니다. 또는 필드를 탭 순서에 포함 시키지만 비활성화하십시오. 사용자가 다른 필드에서 설정 한 내용을 고려하여 적절 해지면 활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="381e9b2321fabed3dd7a2ac4eda2bbec8df1c5ce" translate="yes" xml:space="preserve">
          <source>If the progress bar displays text, use the &lt;a href=&quot;#text-align-prop&quot;&gt;text-align&lt;/a&gt; property to position the text.</source>
          <target state="translated">진행률 표시 줄에 텍스트가 표시되면 &lt;a href=&quot;#text-align-prop&quot;&gt;텍스트 정렬&lt;/a&gt; 속성을 사용하여 텍스트 를 배치합니다.</target>
        </trans-unit>
        <trans-unit id="72be1fbb44aab6f78a10de8b6d130d40c01c02d5" translate="yes" xml:space="preserve">
          <source>If the progress bar displays text, use the &lt;a href=&quot;stylesheet-reference#text-align-prop&quot;&gt;text-align&lt;/a&gt; property to position the text.</source>
          <target state="translated">진행률 표시 줄에 텍스트가 표시되면 &lt;a href=&quot;stylesheet-reference#text-align-prop&quot;&gt;text-align&lt;/a&gt; 속성을 사용하여 텍스트 를 배치합니다.</target>
        </trans-unit>
        <trans-unit id="3387c5c2c983f502a798da9423709ebb141b8a4d" translate="yes" xml:space="preserve">
          <source>If the project name contains whitespace or special characters, these are replaced with dashes ('-') in the generated index file name.</source>
          <target state="translated">프로젝트 이름에 공백 또는 특수 문자가 포함 된 경우 생성 된 색인 파일 이름에서 대시 ( '-')로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="1f40b76044819d65b5a748d3cc750d93fce1f10e" translate="yes" xml:space="preserve">
          <source>If the prompt was cancelled by the user, the implementation should return &lt;code&gt;false&lt;/code&gt;; otherwise the result should be written to</source>
          <target state="translated">사용자가 프롬프트를 취소 한 경우 구현은 &lt;code&gt;false&lt;/code&gt; 를 반환해야합니다 . 그렇지 않으면 결과는</target>
        </trans-unit>
        <trans-unit id="37b14c2ff9b308f014de3b143fd0bc83b4a948ed" translate="yes" xml:space="preserve">
          <source>If the property is &lt;code&gt;false&lt;/code&gt; after any signal handlers for &lt;a href=&quot;qml-qtwebengine-webengineview#authenticationDialogRequested-signal&quot;&gt;WebEngineView::authenticationDialogRequested&lt;/a&gt; have been executed, a default authentication dialog will be shown. To prevent this, set &lt;code&gt;request.accepted&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;qml-qtwebengine-webengineview#authenticationDialogRequested-signal&quot;&gt;WebEngineView :: authenticationDialogRequested에&lt;/a&gt; 대한 신호 핸들러 가 실행 된 후이 특성이 &lt;code&gt;false&lt;/code&gt; 이면 기본 인증 대화 상자가 표시됩니다. 이를 방지하려면 &lt;code&gt;request.accepted&lt;/code&gt; 를 &lt;code&gt;true&lt;/code&gt; 로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="a5615af07ecb2617eb3c31b6090bac124579692c" translate="yes" xml:space="preserve">
          <source>If the property is &lt;code&gt;false&lt;/code&gt; after any signal handlers for &lt;a href=&quot;qml-qtwebengine-webengineview#colorDialogRequested-signal&quot;&gt;WebEngineView::colorDialogRequested&lt;/a&gt; have been executed, a default color picker dialog will be shown. To prevent this, set &lt;code&gt;request.accepted&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;qml-qtwebengine-webengineview#colorDialogRequested-signal&quot;&gt;WebEngineView :: colorDialogRequested에&lt;/a&gt; 대한 신호 처리기 가 실행 된 후이 속성이 &lt;code&gt;false&lt;/code&gt; 이면 기본 색상 선택기 대화 상자가 표시됩니다. 이를 방지하려면 &lt;code&gt;request.accepted&lt;/code&gt; 를 &lt;code&gt;true&lt;/code&gt; 로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="65f3487e2a35324d1c0f5a0ef87d3175b1e1d3b4" translate="yes" xml:space="preserve">
          <source>If the property is &lt;code&gt;false&lt;/code&gt; after any signal handlers for &lt;a href=&quot;qml-qtwebengine-webengineview#contextMenuRequested-signal&quot;&gt;WebEngineView::contextMenuRequested&lt;/a&gt; have been executed, a default context menu will be shown. To prevent this, set &lt;code&gt;request.accepted&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;qml-qtwebengine-webengineview#contextMenuRequested-signal&quot;&gt;WebEngineView :: contextMenuRequested에&lt;/a&gt; 대한 신호 핸들러 가 실행 된 후이 특성이 &lt;code&gt;false&lt;/code&gt; 이면 기본 컨텍스트 메뉴가 표시됩니다. 이를 방지하려면 &lt;code&gt;request.accepted&lt;/code&gt; 를 &lt;code&gt;true&lt;/code&gt; 로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="7806ec1dafa4df273ad22dc3f71fdc8f88ffe745" translate="yes" xml:space="preserve">
          <source>If the property is &lt;code&gt;false&lt;/code&gt; after any signal handlers for &lt;a href=&quot;qml-qtwebengine-webengineview#fileDialogRequested-signal&quot;&gt;WebEngineView::fileDialogRequested&lt;/a&gt; have been executed, a default file picker dialog will be shown. To prevent this, set &lt;code&gt;request.accepted&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;qml-qtwebengine-webengineview#fileDialogRequested-signal&quot;&gt;WebEngineView :: fileDialogRequested에&lt;/a&gt; 대한 신호 핸들러 가 실행 된 후이 특성이 &lt;code&gt;false&lt;/code&gt; 이면 기본 파일 선택기 대화 상자가 표시됩니다. 이를 방지하려면 &lt;code&gt;request.accepted&lt;/code&gt; 를 &lt;code&gt;true&lt;/code&gt; 로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="af5bd01bdabfbca3c68121b2b7880c2ac9f407f6" translate="yes" xml:space="preserve">
          <source>If the property is &lt;code&gt;false&lt;/code&gt; after any signal handlers for &lt;a href=&quot;qml-qtwebengine-webengineview#javaScriptDialogRequested-signal&quot;&gt;WebEngineView::javaScriptDialogRequested&lt;/a&gt; have been executed, a default dialog will be shown. To prevent this, set &lt;code&gt;request.accepted&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;qml-qtwebengine-webengineview#javaScriptDialogRequested-signal&quot;&gt;WebEngineView :: javaScriptDialogRequested에&lt;/a&gt; 대한 신호 핸들러 가 실행 된 후이 특성이 &lt;code&gt;false&lt;/code&gt; 이면 기본 대화 상자가 표시됩니다. 이를 방지하려면 &lt;code&gt;request.accepted&lt;/code&gt; 를 &lt;code&gt;true&lt;/code&gt; 로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="792af4d6150eb8ecd755e000213c526a490cb519" translate="yes" xml:space="preserve">
          <source>If the property is &lt;code&gt;false&lt;/code&gt; after any signal handlers for &lt;a href=&quot;qml-qtwebengine-webengineview#tooltipRequested-signal&quot;&gt;WebEngineView::tooltipRequested&lt;/a&gt; have been executed, a default tooltip will be shown. To prevent this, set &lt;code&gt;request.accepted&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;qml-qtwebengine-webengineview#tooltipRequested-signal&quot;&gt;WebEngineView :: tooltipRequested에&lt;/a&gt; 대한 신호 처리기 가 실행 된 후 속성이 &lt;code&gt;false&lt;/code&gt; 이면 기본 도구 설명이 표시됩니다. 이를 방지하려면 &lt;code&gt;request.accepted&lt;/code&gt; 를 &lt;code&gt;true&lt;/code&gt; 로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="1c7f03474422d2b224e30e1d62b4e972004613a6" translate="yes" xml:space="preserve">
          <source>If the property is &lt;code&gt;false&lt;/code&gt; after any signal handlers for WebEngineView::validationMessageRequested have been executed, a default file validation message will be shown. To prevent this, set &lt;code&gt;request.accepted&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">WebEngineView :: validationMessageRequested에 대한 신호 핸들러가 실행 된 후이 특성이 &lt;code&gt;false&lt;/code&gt; 이면 기본 파일 유효성 검증 메시지가 표시됩니다. 이를 방지하려면 &lt;code&gt;request.accepted&lt;/code&gt; 를 &lt;code&gt;true&lt;/code&gt; 로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="c6cf1fdd497948b861458958d599cccff7e43e97" translate="yes" xml:space="preserve">
          <source>If the property is &lt;code&gt;true&lt;/code&gt;, a series of notches are drawn around the dial to indicate the range of values available; otherwise no notches are shown.</source>
          <target state="translated">속성이 &lt;code&gt;true&lt;/code&gt; 이면 다이얼 주위에 일련의 노치가 그려져 사용 가능한 값의 범위를 나타냅니다. 그렇지 않으면 노치가 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fc017948a77c9f0fd9baa52b3f3acf4dca65fef2" translate="yes" xml:space="preserve">
          <source>If the property is an enumeration, &lt;a href=&quot;qmetaproperty#isEnumType&quot;&gt;isEnumType&lt;/a&gt;() returns &lt;code&gt;true&lt;/code&gt;; if the property is an enumeration that is also a flag (i.e. its values can be combined using the OR operator), &lt;a href=&quot;qmetaproperty#isEnumType&quot;&gt;isEnumType&lt;/a&gt;() and &lt;a href=&quot;qmetaproperty#isFlagType&quot;&gt;isFlagType&lt;/a&gt;() both return true. The enumerator for these types is available from &lt;a href=&quot;qmetaproperty#enumerator&quot;&gt;enumerator&lt;/a&gt;().</source>
          <target state="translated">등록 정보가 열거이면 &lt;a href=&quot;qmetaproperty#isEnumType&quot;&gt;isEnumType&lt;/a&gt; ()은 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 . 속성이 플래그이기도 한 열거 &lt;a href=&quot;qmetaproperty#isEnumType&quot;&gt;형인&lt;/a&gt; 경우 (즉, OR 연산자를 사용하여 값을 결합 할 수있는 경우) isEnumType () 및 &lt;a href=&quot;qmetaproperty#isFlagType&quot;&gt;isFlagType&lt;/a&gt; ()은 모두 true를 반환합니다. 이러한 유형의 열거자는 &lt;a href=&quot;qmetaproperty#enumerator&quot;&gt;열거 자&lt;/a&gt; () 에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1ba42f040ad90efc2562bd2134c560650283b5b0" translate="yes" xml:space="preserve">
          <source>If the property is defined in the class using &lt;a href=&quot;qobject#Q_PROPERTY&quot;&gt;Q_PROPERTY&lt;/a&gt; then true is returned on success and false otherwise. If the property is not defined using &lt;a href=&quot;qobject#Q_PROPERTY&quot;&gt;Q_PROPERTY&lt;/a&gt;, and therefore not listed in the meta-object, it is added as a dynamic property and false is returned.</source>
          <target state="translated">속성이 &lt;a href=&quot;qobject#Q_PROPERTY&quot;&gt;Q_PROPERTY&lt;/a&gt; 를 사용하여 클래스에 정의되면 성공하면 true가 반환되고 그렇지 않으면 false가 반환됩니다. &lt;a href=&quot;qobject#Q_PROPERTY&quot;&gt;Q_PROPERTY를&lt;/a&gt; 사용하여 특성을 정의 하지 않아 메타 오브젝트에 나열 되지 않은 경우 특성이 동적 특성으로 추가되고 false가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="4fe6f2cf302e256170d7ad081fb3283271386542" translate="yes" xml:space="preserve">
          <source>If the property is implemented using a getter function (i.e. has the PropertyGetter flag set), calling property() has side-effects on the script engine, since the getter function will be called (possibly resulting in an uncaught script exception). If an exception occurred, property() returns the value that was thrown (typically an &lt;code&gt;Error&lt;/code&gt; object).</source>
          <target state="translated">속성이 getter 함수를 사용하여 구현 된 경우 (즉, PropertyGetter 플래그가 설정되어있는 경우) getter 함수가 호출되기 때문에 property ()를 호출하면 스크립트 엔진에 부작용이 있습니다 (아마도 catch되지 않은 스크립트 예외가 발생할 수 있음). 예외가 발생하면 property ()는 throw 된 값 (일반적으로 &lt;code&gt;Error&lt;/code&gt; 객체)을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="a4abd9a8e0ca8c61a6cb9d9958ae91243f12e235" translate="yes" xml:space="preserve">
          <source>If the property is modified during an auto repeating key event, behavior is undefined.</source>
          <target state="translated">자동 반복 키 이벤트 중에 특성이 수정되면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a7bb4d01c5c7d223720eadf8ee8ccca3c048b938" translate="yes" xml:space="preserve">
          <source>If the property is not set, the drop action is CopyAction when the supported actions support CopyAction.</source>
          <target state="translated">특성이 설정되지 않은 경우 지원되는 조치가 CopyAction을 지원할 때 놓기 조치는 CopyAction입니다.</target>
        </trans-unit>
        <trans-unit id="237369ec3cf7d6ee6dc7a205c90ae6a42f49955b" translate="yes" xml:space="preserve">
          <source>If the property is set to &lt;code&gt;false&lt;/code&gt;, the pixels outside the source are interpreted to contain the same color as the pixels at the edge of the item, which is similar to OpenGL clamp-to-edge behavior. The blur does not expand outside the effect item area.</source>
          <target state="translated">이 속성이 &lt;code&gt;false&lt;/code&gt; 로 설정 되면 소스 외부의 픽셀은 항목의 가장자리에있는 픽셀과 동일한 색상을 포함하는 것으로 해석되며 OpenGL 클램프 간 동작과 유사합니다. 효과 항목 영역 밖으로 흐림이 확장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ff0e0c99c2610bcd8aeadeafdd898ffd4e7456a7" translate="yes" xml:space="preserve">
          <source>If the property is set to &lt;code&gt;true&lt;/code&gt;, the pixels outside the source are interpreted to be transparent, which is similar to OpenGL clamp-to-border extension. The blur is expanded slightly outside the effect item area.</source>
          <target state="translated">이 속성이 &lt;code&gt;true&lt;/code&gt; 로 설정 되면 소스 외부의 픽셀은 투명하게 해석되며 OpenGL 클램프 대 테두리 확장과 유사합니다. 흐림 효과 항목 영역 밖으로 약간 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="4bd22d8896cb1ceaefe9665f825fbbf77dbc1f4a" translate="yes" xml:space="preserve">
          <source>If the property references an enum declared with Q_ENUMS, you should reference its constants by name, i.e., not their numeric value.</source>
          <target state="translated">속성이 Q_ENUMS로 선언 된 열거를 참조하는 경우 숫자 값이 아닌 이름으로 상수를 참조해야합니다.</target>
        </trans-unit>
        <trans-unit id="c76cabc22a2886d3d286c846b340a65a29496566" translate="yes" xml:space="preserve">
          <source>If the property value is less than or equal to 0, the quick selection feature is disabled.</source>
          <target state="translated">속성 값이 0보다 작거나 같은 경우 빠른 선택 기능이 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="44d6619d676425561deb8c70f9a3d6b4c0586244" translate="yes" xml:space="preserve">
          <source>If the proposed drop action is not suitable, perhaps because your custom widget does not support that action, you can replace it with any of the &lt;a href=&quot;qdropevent#possibleActions&quot;&gt;possible drop actions&lt;/a&gt; by calling &lt;a href=&quot;qdropevent#setDropAction&quot;&gt;setDropAction&lt;/a&gt;() with your preferred action. If you set a value that is not present in the bitwise OR combination of values returned by &lt;a href=&quot;qdropevent#possibleActions&quot;&gt;possibleActions&lt;/a&gt;(), the default copy action will be used. Once a replacement drop action has been set, call &lt;a href=&quot;qevent#accept&quot;&gt;accept&lt;/a&gt;() instead of &lt;a href=&quot;qdropevent#acceptProposedAction&quot;&gt;acceptProposedAction&lt;/a&gt;() to complete the drop operation.</source>
          <target state="translated">사용자 정의 위젯이 해당 조치를 지원하지 않기 때문에 제안 된 놓기 조치가 적합하지 않은 경우, &lt;a href=&quot;qdropevent#setDropAction&quot;&gt;setDropAction&lt;/a&gt; ()을 선호하는 조치 로 호출 하여 &lt;a href=&quot;qdropevent#possibleActions&quot;&gt;가능한 놓기 조치&lt;/a&gt; 로 이를 대체 할 수 있습니다 . &lt;a href=&quot;qdropevent#possibleActions&quot;&gt;possibleActions&lt;/a&gt; ()에서 반환 한 비트 단위 OR 조합의 값에없는 값을 설정 하면 기본 복사 동작이 사용됩니다. 대체 삭제 동작이 설정되면 &lt;a href=&quot;qdropevent#acceptProposedAction&quot;&gt;acceptProposedAction&lt;/a&gt; () 대신 &lt;a href=&quot;qevent#accept&quot;&gt;accept&lt;/a&gt; ()를 호출 하여 삭제 작업을 완료합니다.</target>
        </trans-unit>
        <trans-unit id="e960b3633d0ac83d947a9059a0faa4a9dad727aa" translate="yes" xml:space="preserve">
          <source>If the provided HTML contains references to external resources such as imported style sheets, then they will be loaded through the</source>
          <target state="translated">제공된 HTML에 가져온 스타일 시트와 같은 외부 자원에 대한 참조가 포함되어 있으면</target>
        </trans-unit>
        <trans-unit id="23ace9f15efc7d8237c9810b37f2ba74c9e5bf74" translate="yes" xml:space="preserve">
          <source>If the provided text contains an ampersand character ('&amp;amp;'), a mnemonic is automatically created for it. The character that follows the '&amp;amp;' will be used as the shortcut key. Any previous mnemonic will be overwritten, or cleared if no mnemonic is defined by the text. See the &lt;a href=&quot;qshortcut#mnemonic&quot;&gt;QShortcut&lt;/a&gt; documentation for details (to display an actual ampersand, use '&amp;amp;&amp;amp;').</source>
          <target state="translated">제공된 텍스트에 앰퍼샌드 문자 ( '&amp;amp;')가 포함되어 있으면 니모닉이 자동으로 작성됩니다. '&amp;amp;'뒤에 나오는 문자가 바로 가기 키로 사용됩니다. 텍스트로 정의 된 니모닉이 없으면 이전 니모닉을 덮어 쓰거나 지 웁니다. 자세한 내용은 &lt;a href=&quot;qshortcut#mnemonic&quot;&gt;QShortcut&lt;/a&gt; 설명서를 참조하십시오 (실제 앰퍼샌드를 표시하려면 '&amp;amp;&amp;amp;'사용).</target>
        </trans-unit>
        <trans-unit id="0fc179f1a49dd293d08a15dfa49739867297850b" translate="yes" xml:space="preserve">
          <source>If the provided text contains an ampersand character ('&amp;amp;'), a shortcut is automatically created for it. The character that follows the '&amp;amp;' will be used as the shortcut key. Any previous shortcut will be overwritten, or cleared if no shortcut is defined by the text. See the &lt;a href=&quot;qshortcut#mnemonic&quot;&gt;QShortcut&lt;/a&gt; documentation for details (to display an actual ampersand, use '&amp;amp;&amp;amp;').</source>
          <target state="translated">제공된 텍스트에 앰퍼샌드 문자 ( '&amp;amp;')가 있으면 바로 가기가 자동으로 생성됩니다. '&amp;amp;'뒤에 나오는 문자가 바로 가기 키로 사용됩니다. 텍스트로 정의 된 바로 가기가 없으면 이전 바로 가기를 덮어 쓰거나 지 웁니다. 자세한 내용은 &lt;a href=&quot;qshortcut#mnemonic&quot;&gt;QShortcut&lt;/a&gt; 설명서를 참조하십시오 (실제 앰퍼샌드를 표시하려면 '&amp;amp;&amp;amp;'사용).</target>
        </trans-unit>
        <trans-unit id="0e70aa81795812baead37bc8602ed576ab3c2744" translate="yes" xml:space="preserve">
          <source>If the proxy is not of type &lt;a href=&quot;qnetworkproxy#ProxyType-enum&quot;&gt;HttpProxy&lt;/a&gt; or &lt;a href=&quot;qnetworkproxy#ProxyType-enum&quot;&gt;HttpCachingProxy&lt;/a&gt; an empty &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt; is returned.</source>
          <target state="translated">프록시가 &lt;a href=&quot;qnetworkproxy#ProxyType-enum&quot;&gt;HttpProxy&lt;/a&gt; 또는 &lt;a href=&quot;qnetworkproxy#ProxyType-enum&quot;&gt;HttpCachingProxy&lt;/a&gt; 유형이 아닌 경우 빈 &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="9537fd95c8d3f94e9a9c8da85ad21d2318a0926d" translate="yes" xml:space="preserve">
          <source>If the proxy is not of type &lt;a href=&quot;qnetworkproxy#ProxyType-enum&quot;&gt;HttpProxy&lt;/a&gt; or &lt;a href=&quot;qnetworkproxy#ProxyType-enum&quot;&gt;HttpCachingProxy&lt;/a&gt; this has no effect.</source>
          <target state="translated">프록시가 &lt;a href=&quot;qnetworkproxy#ProxyType-enum&quot;&gt;HttpProxy&lt;/a&gt; 또는 &lt;a href=&quot;qnetworkproxy#ProxyType-enum&quot;&gt;HttpCachingProxy&lt;/a&gt; 유형이 아닌 경우 에는 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="672749708350ab4af3fd3ef22bcdb7abe7043095" translate="yes" xml:space="preserve">
          <source>If the proxy rejects the credentials, &lt;a href=&quot;qnetworkaccessmanager&quot;&gt;QNetworkAccessManager&lt;/a&gt; will emit the signal again.</source>
          <target state="translated">프록시가 자격 증명을 거부하면 &lt;a href=&quot;qnetworkaccessmanager&quot;&gt;QNetworkAccessManager&lt;/a&gt; 가 신호를 다시 방출합니다.</target>
        </trans-unit>
        <trans-unit id="3bd215a339dd656975eee67d4fa8a54ab793a64d" translate="yes" xml:space="preserve">
          <source>If the public identifier is missing,</source>
          <target state="translated">공개 식별자가 없으면</target>
        </trans-unit>
        <trans-unit id="daf717fe7ed53851159cf92467b27affb1994ac6" translate="yes" xml:space="preserve">
          <source>If the query &lt;a href=&quot;qxmlquery#isValid&quot;&gt;is valid&lt;/a&gt; and the evaluation succeeds, true is returned. Otherwise, false is returned and the contents of</source>
          <target state="translated">쿼리 &lt;a href=&quot;qxmlquery#isValid&quot;&gt;가 유효&lt;/a&gt; 하고 평가에 성공하면 true가 반환됩니다. 그렇지 않으면 false가 반환되고 내용이</target>
        </trans-unit>
        <trans-unit id="e041a07cbec7a23bcd963a481b8bdadd488b0edb" translate="yes" xml:space="preserve">
          <source>If the query contains a static error (e.g. syntax error), an error message is sent to the &lt;a href=&quot;qxmlquery#messageHandler&quot;&gt;messageHandler&lt;/a&gt;(), and &lt;a href=&quot;qxmlquery#isValid&quot;&gt;isValid&lt;/a&gt;() will return</source>
          <target state="translated">쿼리에 정적 오류 (예 : 구문 오류)가 포함되어 있으면 오류 메시지가 &lt;a href=&quot;qxmlquery#messageHandler&quot;&gt;messageHandler&lt;/a&gt; ()로 전송 되고 &lt;a href=&quot;qxmlquery#isValid&quot;&gt;isValid&lt;/a&gt; ()가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="6dab4941c0d623702b40d1e69a88430668ef15e3" translate="yes" xml:space="preserve">
          <source>If the query type is &lt;a href=&quot;qnetworkproxyquery#QueryType-enum&quot;&gt;QNetworkProxyQuery::UrlRequest&lt;/a&gt;, this function returns the host component of the URL being requested.</source>
          <target state="translated">조회 유형이 &lt;a href=&quot;qnetworkproxyquery#QueryType-enum&quot;&gt;QNetworkProxyQuery :: UrlRequest&lt;/a&gt; 인 경우이 함수는 요청중인 URL의 호스트 구성 요소를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="dd91fe8cdb77b75d7405508f674fb9f6daaa4ca9" translate="yes" xml:space="preserve">
          <source>If the query type is &lt;a href=&quot;qnetworkproxyquery#QueryType-enum&quot;&gt;QNetworkProxyQuery::UrlRequest&lt;/a&gt;, this function returns the port number of the URL being requested. In general, frameworks will fill in the port number from their default values.</source>
          <target state="translated">쿼리 유형이 &lt;a href=&quot;qnetworkproxyquery#QueryType-enum&quot;&gt;QNetworkProxyQuery :: UrlRequest&lt;/a&gt; 인 경우이 함수는 요청중인 URL의 포트 번호를 리턴합니다. 일반적으로, 프레임 워크는 기본값에서 포트 번호를 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="11284e9683a89a88bbb2a1cd2988e6f643c68550" translate="yes" xml:space="preserve">
          <source>If the query will access an XML document contained in a &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;, use a &lt;a href=&quot;qbuffer&quot;&gt;QBuffer&lt;/a&gt; as shown in the following snippet. Suppose</source>
          <target state="translated">쿼리가 &lt;a href=&quot;qstring&quot;&gt;QString에&lt;/a&gt; 포함 된 XML 문서에 액세스하는 경우 다음 스 니펫에 표시된대로 &lt;a href=&quot;qbuffer&quot;&gt;QBuffer&lt;/a&gt; 를 사용하십시오 . 가정</target>
        </trans-unit>
        <trans-unit id="e202a6c2018924dae72b428ea4ed317c01b3d380" translate="yes" xml:space="preserve">
          <source>If the quoted text is not in a member function of a &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; subclass, use either the tr() function of an appropriate class, or the &lt;a href=&quot;qcoreapplication#translate&quot;&gt;QCoreApplication::translate&lt;/a&gt;() function directly:</source>
          <target state="translated">인용 된 텍스트가 &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 서브 클래스 의 멤버 함수에없는 경우 적절한 클래스의 tr () 함수 또는 &lt;a href=&quot;qcoreapplication#translate&quot;&gt;QCoreApplication :: translate&lt;/a&gt; () 함수를 직접 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="bc96b610424f1570f66e04e4a94f3d26da834560" translate="yes" xml:space="preserve">
          <source>If the range is narrower then a time interval whose end it spans, for example a week that spans the end of a month, users can only edit the date to one in the later part of the range if keyboard-tracking is disabled.</source>
          <target state="translated">범위가 끝이 끝나는 시간 간격 (예 : 월말에 걸친 주)보다 좁 으면 사용자는 키보드 추적이 비활성화 된 경우 범위의 후반부에있는 날짜로만 날짜를 편집 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="242f0e894eae7f95788d624d74df27fc6803fe02" translate="yes" xml:space="preserve">
          <source>If the range is narrower then a time interval whose end it spans, for example a week that spans the end of a month, users can only edit the date-time to one in the later part of the range if keyboard-tracking is disabled.</source>
          <target state="translated">범위가 끝이 끝나는 시간 간격보다 좁 으면 (예 : 월말에 걸친 주), 키보드 추적이 비활성화 된 경우 사용자는 날짜-시간을 범위의 후반부에있는 날짜로만 편집 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="84d0b99cc269bd955995bfa3fdfa750ef9fe5990" translate="yes" xml:space="preserve">
          <source>If the range is narrower then a time interval whose end it spans, for example the interval from ten to an hour to ten past the same hour, users can only edit the time to one in the later part of the range if keyboard-tracking is disabled.</source>
          <target state="translated">범위가 끝이 끝나는 시간 간격보다 좁 으면 (예 : 같은 시간의 10에서 1 시간에서 10까지의 간격) 키보드 추적이 활성화 된 경우 사용자는 범위의 후반부에있는 1로만 시간을 편집 할 수 있습니다. 비활성화 됨.</target>
        </trans-unit>
        <trans-unit id="57a54190e2654c8ef3ca547e03a1c75110208264" translate="yes" xml:space="preserve">
          <source>If the range refers to contiguous memory (such as an array or the data from a &lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt;), the &lt;a href=&quot;qrandomgenerator#fillRange&quot;&gt;fillRange&lt;/a&gt;() function may be used too.</source>
          <target state="translated">범위가 연속 메모리 (예 : 배열 또는 &lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt; 의 데이터)를 나타내는 경우 &lt;a href=&quot;qrandomgenerator#fillRange&quot;&gt;fillRange&lt;/a&gt; () 함수도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d83870ebce37c9899b0467093a4f2c78000a67da" translate="yes" xml:space="preserve">
          <source>If the reader cannot read any image from the device (e.g., there is no image there, or the image has already been read), or if the format is unsupported, this function returns an empty QByteArray().</source>
          <target state="translated">리더가 장치에서 이미지를 읽을 수 없거나 (예 : 이미지가 없거나 이미 읽은 이미지) 형식이 지원되지 않으면이 함수는 빈 QByteArray ()를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c958c5956ffcd3f45676531dddfe978c7019f60f" translate="yes" xml:space="preserve">
          <source>If the reader has the feature called</source>
          <target state="translated">독자에게 다음과 같은 기능이있는 경우</target>
        </trans-unit>
        <trans-unit id="83930d2fa7ec81fd7b5d5ab2254a99057086189a" translate="yes" xml:space="preserve">
          <source>If the reader has the property</source>
          <target state="translated">독자가 재산을 가지고 있다면</target>
        </trans-unit>
        <trans-unit id="d2fdfc9341a9b873cd0257895277c4e369d485ad" translate="yes" xml:space="preserve">
          <source>If the record could not be retrieved, the result is positioned after the last record and false is returned. If the record is successfully retrieved, true is returned.</source>
          <target state="translated">레코드를 검색 할 수없는 경우 결과는 마지막 레코드 뒤에 배치되고 false가 리턴됩니다. 레코드가 성공적으로 검색되면 true가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="ce6dbf55ba30b7755f5cb6e6617ef932abe7a88c" translate="yes" xml:space="preserve">
          <source>If the record could not be retrieved, the result is positioned before the first record and false is returned. If the record is successfully retrieved, true is returned.</source>
          <target state="translated">레코드를 검색 할 수없는 경우 결과는 첫 번째 레코드 앞에 배치되고 false가 리턴됩니다. 레코드가 성공적으로 검색되면 true가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="161f145036a87c6f95fa1befb05ef71532e3c886" translate="yes" xml:space="preserve">
          <source>If the rectangle is empty, drag move events will be sent continuously. This is useful if the source is scrolling in a timer event.</source>
          <target state="translated">사각형이 비어 있으면 드래그 이동 이벤트가 계속 전송됩니다. 소스가 타이머 이벤트에서 스크롤되는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="5dfa841391364e3254b8d64e2f662df9c2c9fb4e" translate="yes" xml:space="preserve">
          <source>If the rectangle is invalid a null region will be created.</source>
          <target state="translated">사각형이 유효하지 않으면 null 영역이 만들어집니다.</target>
        </trans-unit>
        <trans-unit id="e7039f31563e78d8d9ccbfdf43113578b733ba43" translate="yes" xml:space="preserve">
          <source>If the referenced texture is a one-dimensional array, two-dimensional array, three-dimensional, cube map, cube map array, or two-dimensional multisample array texture, it is possible to bind either the entire texture level or a single layer or face of the texture level. This can be controlled with the &lt;a href=&quot;qml-qt3d-render-shaderimage#layered-prop&quot;&gt;layered&lt;/a&gt; property.</source>
          <target state="translated">참조 된 텍스처가 1 차원 배열, 2 차원 배열, 3 차원, 큐브 맵, 큐브 맵 배열 또는 2 차원 다중 샘플 배열 텍스처 인 경우 전체 텍스처 수준 또는 단일 레이어 또는 단일 레이어를 바인딩 할 수 있습니다. 텍스처 레벨의면. 이는 &lt;a href=&quot;qml-qt3d-render-shaderimage#layered-prop&quot;&gt;layered&lt;/a&gt; 속성 으로 제어 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="21797d2fe93ee5148d8b695fb0028abdc35952bc" translate="yes" xml:space="preserve">
          <source>If the referenced texture is a one-dimensional array, two-dimensional array, three-dimensional, cube map, cube map array, or two-dimensional multisample array texture, it is possible to bind either the entire texture level or a single layer or face of the texture level. This can be controlled with the &lt;a href=&quot;qt3drender-qshaderimage#layered-prop&quot;&gt;layered&lt;/a&gt; property.</source>
          <target state="translated">참조 된 텍스처가 1 차원 배열, 2 차원 배열, 3 차원, 큐브 맵, 큐브 맵 배열 또는 2 차원 다중 샘플 배열 텍스처 인 경우 전체 텍스처 수준 또는 단일 레이어 또는 단일 레이어를 바인딩 할 수 있습니다. 텍스처 레벨의면. 이는 &lt;a href=&quot;qt3drender-qshaderimage#layered-prop&quot;&gt;layered&lt;/a&gt; 속성 으로 제어 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b36682402f54e28695ab6c2b913397976e7fe9e3" translate="yes" xml:space="preserve">
          <source>If the regexp partially matches against the string, the result is considered &lt;a href=&quot;qvalidator#State-enum&quot;&gt;Intermediate&lt;/a&gt;. For example, &quot;&quot; and &quot;A&quot; are &lt;a href=&quot;qvalidator#State-enum&quot;&gt;Intermediate&lt;/a&gt; for the regexp &lt;b&gt;[A-Z][0-9]&lt;/b&gt; (whereas &quot;&lt;a href=&quot;qromancalendar&quot;&gt;_&lt;/a&gt;&quot; would be &lt;a href=&quot;qvalidator#State-enum&quot;&gt;Invalid&lt;/a&gt;).</source>
          <target state="translated">정규 표현식이 문자열과 부분적으로 일치하면 결과는 &lt;a href=&quot;qvalidator#State-enum&quot;&gt;Intermediate&lt;/a&gt; 로 간주됩니다 . 예를 들어 &quot;&quot;및 &quot;A&quot;는 정규 표현식 &lt;b&gt;[AZ] [0-9]의 &lt;/b&gt;&lt;a href=&quot;qvalidator#State-enum&quot;&gt;중간&lt;/a&gt; 입니다 ( &quot; &lt;a href=&quot;qromancalendar&quot;&gt;_&lt;/a&gt; &quot;는 &lt;a href=&quot;qvalidator#State-enum&quot;&gt;유효&lt;/a&gt; 하지 않음 ).&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="c86151bcf8599e990c199ba4a52af2a2aeae6ba1" translate="yes" xml:space="preserve">
          <source>If the regexp partially matches against the string, the result is considered &lt;a href=&quot;qvalidator#State-enum&quot;&gt;Intermediate&lt;/a&gt;. For example, &quot;&quot; and &quot;A&quot; are &lt;a href=&quot;qvalidator#State-enum&quot;&gt;Intermediate&lt;/a&gt; for the regexp &lt;b&gt;[A-Z][0-9]&lt;/b&gt; (whereas &quot;_&quot; would be &lt;a href=&quot;qvalidator#State-enum&quot;&gt;Invalid&lt;/a&gt;).</source>
          <target state="translated">정규 표현식이 문자열과 부분적으로 일치하면 결과는 &lt;a href=&quot;qvalidator#State-enum&quot;&gt;중간&lt;/a&gt; 으로 간주됩니다 . 예를 들어, &quot;&quot;및 &quot;A&quot;는 정규 표현식 &lt;b&gt;[AZ] [0-9]&lt;/b&gt; 에서 &lt;a href=&quot;qvalidator#State-enum&quot;&gt;중간&lt;/a&gt; 입니다 ( &quot;_&quot;는 &lt;a href=&quot;qvalidator#State-enum&quot;&gt;유효&lt;/a&gt; 하지 않음 ).&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="fb55abd4b94da6e9bac96ad169428e873e8319ae" translate="yes" xml:space="preserve">
          <source>If the regular expression did not match, this function returns -1.</source>
          <target state="translated">정규식이 일치하지 않으면이 함수는 -1을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="45cff9799787b808e5b74dcc7b1e77d15853f341" translate="yes" xml:space="preserve">
          <source>If the regular expression is not valid, returns an empty list.</source>
          <target state="translated">정규식이 유효하지 않으면 빈 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b7d16b9bf8ce71270e805fa76b2b78172386e0f1" translate="yes" xml:space="preserve">
          <source>If the reimplemented resolve() function decides it has nothing to do about resolving the</source>
          <target state="translated">다시 구현 된 resolve () 함수가이를 해결하는 것과 관련이 없다고 결정하면</target>
        </trans-unit>
        <trans-unit id="8210395af83d1dbf2e130d93996b52cf8491b2da" translate="yes" xml:space="preserve">
          <source>If the remote method call cannot fail, you can skip the error checking:</source>
          <target state="translated">원격 메소드 호출이 실패 할 수없는 경우 오류 점검을 건너 뛸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="67ae59d531ea7e9e073e17c1370d776606b16a6d" translate="yes" xml:space="preserve">
          <source>If the remote service</source>
          <target state="translated">원격 서비스</target>
        </trans-unit>
        <trans-unit id="4c41fa2e297d22119552fe24b3121dfb55466ac4" translate="yes" xml:space="preserve">
          <source>If the rename operation fails, Qt will attempt to copy this file's contents to</source>
          <target state="translated">이름 바꾸기 작업이 실패하면 Qt는이 파일의 내용을 복사하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="90cde67f1ca7d440cb89a1730c773b5cde6fce76" translate="yes" xml:space="preserve">
          <source>If the rendering in the framebuffer was not done with premultiplied alpha in mind, create a wrapper &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt; with a non-premultiplied format. This is necessary before performing operations like &lt;a href=&quot;qimage#save&quot;&gt;QImage::save&lt;/a&gt;() because otherwise the image data would get unpremultiplied, even though it was not premultiplied in the first place. To create such a wrapper without performing a copy of the pixel data, do the following:</source>
          <target state="translated">프레임 버퍼의 렌더링이 미리 곱셈 된 알파를 염두에두고 수행되지 않은 경우, 미리 곱셈 되지 않은 형식으로 래퍼 &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt; 를 작성하십시오 . &lt;a href=&quot;qimage#save&quot;&gt;QImage :: save&lt;/a&gt; () 와 같은 작업을 수행하기 전에이 작업이 필요합니다. 그렇지 않으면 이미지 데이터가 처음에 사전 곱셈되지 않았더라도 이미지 데이터가 미리 곱셈되지 않기 때문입니다. 픽셀 데이터의 사본을 수행하지 않고 이러한 랩퍼를 작성하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="3e498455718c068e5fd5c458eda3d229440c4e81" translate="yes" xml:space="preserve">
          <source>If the rendering is happening on a different thread, then the job will happen on the rendering thread.</source>
          <target state="translated">다른 스레드에서 렌더링이 발생하면 렌더링 스레드에서 작업이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="a36bc8f18d79336af8b4180537475b59e5a8a6fd" translate="yes" xml:space="preserve">
          <source>If the repeat is enabled, the key will repeat the input events while held down. The repeat should not be used if &lt;a href=&quot;qml-qtquick-virtualkeyboard-basekey#alternativeKeys-prop&quot;&gt;alternativeKeys&lt;/a&gt; is also set.</source>
          <target state="translated">반복이 활성화되면 키를 누르고있는 동안 키가 입력 이벤트를 반복합니다. &lt;a href=&quot;qml-qtquick-virtualkeyboard-basekey#alternativeKeys-prop&quot;&gt;alternativeKeys&lt;/a&gt; 도 설정되어 있으면 반복을 사용하지 않아야합니다 .</target>
        </trans-unit>
        <trans-unit id="694cafbaf257ea11e796222ca0b5012221e5ea94" translate="yes" xml:space="preserve">
          <source>If the repetition argument is empty or null, the value &quot;repeat&quot; is used.</source>
          <target state="translated">반복 인수가 비어 있거나 널인 경우 &quot;repeat&quot;값이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="04c5aaddd8b78b7332c9723a2b9c2cecf09bb2dc" translate="yes" xml:space="preserve">
          <source>If the reply arrives with a different number of arguments (or with different types), it will be transformed into an error reply indicating a bad signature.</source>
          <target state="translated">응답이 다른 수의 인수 (또는 다른 유형)로 도착하면 잘못된 서명을 나타내는 오류 응답으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="c27de1bdb74d767c27964fb3ad7c38ec1f251e34" translate="yes" xml:space="preserve">
          <source>If the reply does not contain an argument at position</source>
          <target state="translated">회신에 위치에 인수가 포함되지 않은 경우</target>
        </trans-unit>
        <trans-unit id="fec0a28ce2e84498a7061e9f4114006d07d6323b" translate="yes" xml:space="preserve">
          <source>If the reply is an error reply, this function returns a default-constructed &lt;code&gt;T1&lt;/code&gt; object, which may be indistinguishable from a valid value. To reliably determine whether the message was an error, use &lt;a href=&quot;qdbuspendingreply#isError&quot;&gt;isError&lt;/a&gt;().</source>
          <target state="translated">응답이 오류 응답 인 경우이 함수는 기본 구성된 &lt;code&gt;T1&lt;/code&gt; 객체를 반환하며,이 값은 유효한 값과 구별 할 수 없습니다. 메시지가 오류인지 확실하게 확인하려면 &lt;a href=&quot;qdbuspendingreply#isError&quot;&gt;isError&lt;/a&gt; ()를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="46f0214d260f81064faec2b22408e73270d4e906" translate="yes" xml:space="preserve">
          <source>If the request has not finished then the returned &lt;a href=&quot;qmodbusresponse&quot;&gt;QModbusResponse&lt;/a&gt; instance is invalid.</source>
          <target state="translated">요청이 완료되지 않으면 리턴 된 &lt;a href=&quot;qmodbusresponse&quot;&gt;QModbusResponse&lt;/a&gt; 인스턴스가 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="88744eb4043b02f4d4894c929d340668fdae8610" translate="yes" xml:space="preserve">
          <source>If the request has not finished, has failed with an error or was a write request then the returned &lt;a href=&quot;qmodbusdataunit&quot;&gt;QModbusDataUnit&lt;/a&gt; instance is invalid.</source>
          <target state="translated">요청이 완료되지 않았거나 오류와 함께 실패했거나 쓰기 요청 인 경우 리턴 된 &lt;a href=&quot;qmodbusdataunit&quot;&gt;QModbusDataUnit&lt;/a&gt; 인스턴스가 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c149786a772607b1250678c23e0cbb30d3427642" translate="yes" xml:space="preserve">
          <source>If the request is accepted the element requesting fullscreen will fill the viewport, but it is up to the application to make the view fullscreen or move the page to a view that is fullscreen.</source>
          <target state="translated">요청이 수락되면 전체 화면을 요청하는 요소가 뷰포트를 채우지 만 뷰를 전체 화면으로 만들거나 페이지를 전체 화면으로보기는 응용 프로그램에 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="394d41c0df5c5c13172808d5e524b18a17356a14" translate="yes" xml:space="preserve">
          <source>If the request to enter the fullscreen mode is accepted, the element requesting fullscreen mode will fill the viewport, but it is up to the application to make the view fullscreen or to move the page to a view that is in the fullscreen mode.</source>
          <target state="translated">전체 화면 모드로의 요청이 수락되면 전체 화면 모드를 요청하는 요소가 뷰포트를 채울 수 있지만 뷰를 전체 화면으로 만들거나 페이지를 전체 화면 모드에있는 뷰로 이동하는 것은 응용 프로그램에 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="ac5ba70f2d85db87ba6c31309764be77272a3928" translate="yes" xml:space="preserve">
          <source>If the requested font family is unavailable you can influence the &lt;a href=&quot;qfont#fontmatching&quot;&gt;font matching algorithm&lt;/a&gt; by choosing a particular &lt;a href=&quot;qfont#StyleHint-enum&quot;&gt;QFont::StyleHint&lt;/a&gt; and &lt;a href=&quot;qfont#StyleStrategy-enum&quot;&gt;QFont::StyleStrategy&lt;/a&gt; with &lt;a href=&quot;qfont#setStyleHint&quot;&gt;setStyleHint&lt;/a&gt;(). The default family (corresponding to the current style hint) is returned by &lt;a href=&quot;qfont#defaultFamily&quot;&gt;defaultFamily&lt;/a&gt;().</source>
          <target state="translated">요청 된 글꼴 패밀리를 사용할 수없는 경우 &lt;a href=&quot;qfont#setStyleHint&quot;&gt;setStyleHint&lt;/a&gt; ()를 사용 하여 특정 &lt;a href=&quot;qfont#StyleHint-enum&quot;&gt;QFont :: StyleHint&lt;/a&gt; 및 &lt;a href=&quot;qfont#StyleStrategy-enum&quot;&gt;QFont :: StyleStrategy&lt;/a&gt; 를 선택 하여 &lt;a href=&quot;qfont#fontmatching&quot;&gt;글꼴 일치 알고리즘&lt;/a&gt; 에 영향을 줄 수 있습니다 . &lt;a href=&quot;qfont#defaultFamily&quot;&gt;defaultFamily&lt;/a&gt; () 는 기본 스타일 (현재 스타일 힌트에 해당)을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="e90bdbf2010428da7853e0bdea5010ae5cb7da00" translate="yes" xml:space="preserve">
          <source>If the requested format was not supported by the platform implementation, the requestedFormat will differ from the actual offscreen surface format.</source>
          <target state="translated">요청 된 형식이 플랫폼 구현에서 지원되지 않은 경우, 요청 된 형식은 실제 오프 스크린 표면 형식과 다릅니다.</target>
        </trans-unit>
        <trans-unit id="7e868e6ea1f802eabb00dcb21f72b2e2f18b33ad" translate="yes" xml:space="preserve">
          <source>If the requested format was not supported by the platform implementation, the requestedFormat will differ from the actual window format.</source>
          <target state="translated">요청 된 형식이 플랫폼 구현에서 지원되지 않은 경우 requestedFormat은 실제 창 형식과 다릅니다.</target>
        </trans-unit>
        <trans-unit id="4605b8c4e59c2ee91ebdb352542c0d2878bbcc96" translate="yes" xml:space="preserve">
          <source>If the resource is compressed, this function returns the size of the compressed data. See &lt;a href=&quot;qresource#uncompressedSize&quot;&gt;uncompressedSize&lt;/a&gt;() for the uncompressed size.</source>
          <target state="translated">리소스가 압축 된 경우이 함수는 압축 된 데이터의 크기를 반환합니다. &lt;a href=&quot;qresource#uncompressedSize&quot;&gt;압축되지&lt;/a&gt; 않은 크기는 uncompressedSize ()를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ead58d100e9a7d735a0038aa33ecc5a8a62b9380" translate="yes" xml:space="preserve">
          <source>If the restored geometry is off-screen, it will be modified to be inside the available screen geometry.</source>
          <target state="translated">복원 된 형상이 화면 외부인 경우 사용 가능한 화면 형상 내부에 있도록 수정됩니다.</target>
        </trans-unit>
        <trans-unit id="6f9558e1b65cb142031dbe0a02242e4cfc53aa69" translate="yes" xml:space="preserve">
          <source>If the result is &lt;a href=&quot;qgeocodereply#Error-enum&quot;&gt;QGeoCodeReply::NoError&lt;/a&gt; then no error has occurred.</source>
          <target state="translated">결과가 &lt;a href=&quot;qgeocodereply#Error-enum&quot;&gt;QGeoCodeReply :: NoError&lt;/a&gt; 이면 오류가 발생하지 않은 것입니다.</target>
        </trans-unit>
        <trans-unit id="c94a2c8daf57cd71799761794afe972c563bdab2" translate="yes" xml:space="preserve">
          <source>If the result is &lt;a href=&quot;qgeoroutereply#Error-enum&quot;&gt;QGeoRouteReply::NoError&lt;/a&gt; then no error has occurred.</source>
          <target state="translated">결과가 &lt;a href=&quot;qgeoroutereply#Error-enum&quot;&gt;QGeoRouteReply :: NoError&lt;/a&gt; 이면 오류가 발생하지 않은 것입니다.</target>
        </trans-unit>
        <trans-unit id="166244a2ac84870fd9b32ab5ff0140432f7915c4" translate="yes" xml:space="preserve">
          <source>If the result is currently located after the last record, an attempt is made to retrieve the last record.</source>
          <target state="translated">결과가 현재 마지막 레코드 뒤에있는 경우 마지막 레코드를 검색하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="bf8e7d6a260485fc737ed88fba3cb979db2c229b" translate="yes" xml:space="preserve">
          <source>If the result is currently located after the last record, there is no change and false is returned.</source>
          <target state="translated">결과가 현재 마지막 레코드 뒤에있는 경우 변경 사항이 없으며 false가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="d6fcf8ff1979cb186defe26faabd6e8b0471379b" translate="yes" xml:space="preserve">
          <source>If the result is currently located before the first record, e.g. immediately after a query is executed, an attempt is made to retrieve the first record.</source>
          <target state="translated">결과가 현재 첫 번째 레코드 이전에있는 경우 (예 : 쿼리 실행 직후) 첫 번째 레코드를 검색하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="f448c8ba488f3475efee9b7ec87864428f1d1b22" translate="yes" xml:space="preserve">
          <source>If the result is currently located before the first record, there is no change and false is returned.</source>
          <target state="translated">결과가 현재 첫 번째 레코드 앞에있는 경우 변경 사항이 없으며 false가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="a3b7a92b4cdc8d7d86db41b70fcb62728f19bc0a" translate="yes" xml:space="preserve">
          <source>If the result is currently located somewhere in the middle, and the relative offset</source>
          <target state="translated">결과가 현재 중간 어딘가에 있고 상대 오프셋 인 경우</target>
        </trans-unit>
        <trans-unit id="e65f7b94e1c1d61820b7c4c1f21b5cf7ad2dc78e" translate="yes" xml:space="preserve">
          <source>If the result is currently positioned after the last record and:</source>
          <target state="translated">결과가 현재 마지막 레코드 뒤에있는 경우 :</target>
        </trans-unit>
        <trans-unit id="270ab1c0faada0bd43fcbb699b39e9846d8a3ab9" translate="yes" xml:space="preserve">
          <source>If the result is currently positioned before the first record and:</source>
          <target state="translated">결과가 현재 첫 번째 레코드 앞에있는 경우 :</target>
        </trans-unit>
        <trans-unit id="bd659c86b495e465e91a4cf82bd7aa00f40885bc" translate="yes" xml:space="preserve">
          <source>If the result is located somewhere in the middle, an attempt is made to retrieve the next record.</source>
          <target state="translated">결과가 중간 어딘가에 있으면 다음 레코드를 검색하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="7a8ea225920a0d418e7aab5c3e7d15273c843c31" translate="yes" xml:space="preserve">
          <source>If the result is somewhere in the middle, an attempt is made to retrieve the previous record.</source>
          <target state="translated">결과가 중간에 있으면 이전 레코드를 검색하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="860c3fcbc5da530fe1630bcff089decc54f06557" translate="yes" xml:space="preserve">
          <source>If the return &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; is a default constructed variant, it signals that</source>
          <target state="translated">리턴 &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; 가 기본 생성 된 변형 인 경우,</target>
        </trans-unit>
        <trans-unit id="2da7461a68604344eb95235b43463b59dc69c0f6" translate="yes" xml:space="preserve">
          <source>If the return type is of a coclass or interface type declared in another type library you have to include the namespace header for that other type library before including the header for the namespace you want to use (both header have to be generated with this tool).</source>
          <target state="translated">리턴 유형이 다른 유형 라이브러리에 선언 된 coclass 또는 인터페이스 유형 인 경우 사용하려는 네임 스페이스의 헤더를 포함하기 전에 다른 유형 라이브러리의 네임 스페이스 헤더를 포함해야합니다 (두 가지 모두이 도구를 사용하여 생성해야 함) .</target>
        </trans-unit>
        <trans-unit id="ddd7819ecdfbb8181dce07ad8ebc019b74865b28" translate="yes" xml:space="preserve">
          <source>If the return types patch, &lt;a href=&quot;qdbusreply&quot;&gt;QDBusReply&lt;/a&gt; will extract the first return argument from the reply.</source>
          <target state="translated">리턴 유형이 패치 인 경우 &lt;a href=&quot;qdbusreply&quot;&gt;QDBusReply&lt;/a&gt; 는 응답에서 첫 번째 리턴 인수를 추출합니다.</target>
        </trans-unit>
        <trans-unit id="6881a7bc9d9aacbfe995e8c57b83ffd2fabb86c2" translate="yes" xml:space="preserve">
          <source>If the return types patch, QDBusReply will extract the first return argument from the reply.</source>
          <target state="translated">반환 유형이 패치 인 경우 QDBusReply는 응답에서 첫 번째 반환 인수를 추출합니다.</target>
        </trans-unit>
        <trans-unit id="a0ce27817e233be2e9426bf45c5bbf3fe7c514aa" translate="yes" xml:space="preserve">
          <source>If the return value is true, the window receives all key events until setKeyboardGrabEnabled(false) is called; other windows get no key events at all. Mouse events are not affected. Use &lt;a href=&quot;qwindow#setMouseGrabEnabled&quot;&gt;setMouseGrabEnabled&lt;/a&gt;() if you want to grab that.</source>
          <target state="translated">리턴 값이 true 인 경우, setKeyboardGrabEnabled (false)가 호출 될 때까지 창은 모든 키 이벤트를 수신합니다. 다른 창에는 중요한 이벤트가 전혀 없습니다. 마우스 이벤트는 영향을받지 않습니다. 잡으려면 &lt;a href=&quot;qwindow#setMouseGrabEnabled&quot;&gt;setMouseGrabEnabled&lt;/a&gt; ()를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="fee67eaf7d45d09402b7e3840f40944f8835493d" translate="yes" xml:space="preserve">
          <source>If the return value is true, the window receives all mouse events until setMouseGrabEnabled(false) is called; other windows get no mouse events at all. Keyboard events are not affected. Use &lt;a href=&quot;qwindow#setKeyboardGrabEnabled&quot;&gt;setKeyboardGrabEnabled&lt;/a&gt;() if you want to grab that.</source>
          <target state="translated">리턴 값이 true이면, setMouseGrabEnabled (false)가 호출 될 때까지 창은 모든 마우스 이벤트를 수신합니다. 다른 창에는 마우스 이벤트가 전혀 없습니다. 키보드 이벤트는 영향을받지 않습니다. 잡으려면 &lt;a href=&quot;qwindow#setKeyboardGrabEnabled&quot;&gt;setKeyboardGrabEnabled&lt;/a&gt; ()를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="a75f638e79cc0d01b251d8cd09e2e96fca551331" translate="yes" xml:space="preserve">
          <source>If the returned value is negative, it means that the information is not available from the database.</source>
          <target state="translated">리턴 된 값이 음수이면 데이터베이스에서 정보를 사용할 수 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="728b09aaa08d967f70a0f0e3ff957ef0e55d0c31" translate="yes" xml:space="preserve">
          <source>If the roaming process is non-seamless the IP address will change which means that a socket becomes invalid. However seamless mobility can ensure that the local IP address does not change. This is achieved by using a virtual IP address which is bound to the actual link address. During the roaming process the virtual address is attached to the new link address.</source>
          <target state="translated">로밍 프로세스가 완벽하지 않은 경우 IP 주소가 변경되어 소켓이 유효하지 않게됩니다. 그러나 원활한 이동성은 로컬 IP 주소가 변경되지 않도록합니다. 실제 링크 주소에 바인딩 된 가상 IP 주소를 사용하면됩니다. 로밍 프로세스 중에 가상 주소가 새 링크 주소에 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="95ee5e65707ccc7edeb4f03284b4c5ea2921e04a" translate="yes" xml:space="preserve">
          <source>If the root &lt;a href=&quot;qml-qtquick-item&quot;&gt;Item&lt;/a&gt; is reached, the key event is &lt;a href=&quot;qevent#ignore&quot;&gt;ignored&lt;/a&gt; and regular Qt key handling continues.</source>
          <target state="translated">루트 &lt;a href=&quot;qml-qtquick-item&quot;&gt;아이템&lt;/a&gt; 에 도달하면 키 이벤트가 &lt;a href=&quot;qevent#ignore&quot;&gt;무시&lt;/a&gt; 되고 일반 Qt 키 처리가 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="a3838c39e60fc34b2dd7eaa5fe93b9e52e110667" translate="yes" xml:space="preserve">
          <source>If the root component object was destroyed, calling this function creates a new instance.</source>
          <target state="translated">루트 구성 요소 오브젝트가 손상된 경우이 함수를 호출하면 새 인스턴스가 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="40bddb6c6aa189ac549daa944b89cd5c9bc2056a" translate="yes" xml:space="preserve">
          <source>If the routing service supports updating routes as they are being traveled, the subclass should provide an implementation of &lt;a href=&quot;qgeoroutingmanagerengine#updateRoute&quot;&gt;updateRoute&lt;/a&gt;() and call setSupportsRouteUpdates(true) at some point in time before &lt;a href=&quot;qgeoroutingmanagerengine#updateRoute&quot;&gt;updateRoute&lt;/a&gt;() is called.</source>
          <target state="translated">라우팅 서비스가 경로를 이동하면서 경로 업데이트를 지원하는 경우 서브 클래스는 &lt;a href=&quot;qgeoroutingmanagerengine#updateRoute&quot;&gt;updateRoute&lt;/a&gt; () 의 구현을 제공하고 &lt;a href=&quot;qgeoroutingmanagerengine#updateRoute&quot;&gt;updateRoute&lt;/a&gt; ()가 호출 되기 전에 특정 시점에서 setSupportsRouteUpdates (true)를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="58457a66fda80b4c21819f738386712992e1f622" translate="yes" xml:space="preserve">
          <source>If the rubber band rectangle is displayed in the press event specified by</source>
          <target state="translated">에 의해 지정된 프레스 이벤트에 고무 밴드 사각형이 표시되는 경우</target>
        </trans-unit>
        <trans-unit id="985514fea40723609e92f6d69da97cf72daeb5b0" translate="yes" xml:space="preserve">
          <source>If the same</source>
          <target state="translated">같은 경우</target>
        </trans-unit>
        <trans-unit id="e6a32e5dff59b354282cdea4efbf9078bc5dcebb" translate="yes" xml:space="preserve">
          <source>If the same key</source>
          <target state="translated">같은 키라면</target>
        </trans-unit>
        <trans-unit id="3ede64475abf08bdc20e3b79a64e9ecb1eaf7706" translate="yes" xml:space="preserve">
          <source>If the same translatable string is used in different roles within the same translation context, an additional identifying string may be passed in the call to &lt;a href=&quot;qobject#tr&quot;&gt;tr()&lt;/a&gt;. This optional disambiguation argument is used to distinguish between otherwise identical strings.</source>
          <target state="translated">동일한 번역 컨텍스트 내에서 동일한 번역 가능한 문자열이 다른 역할에서 사용되는 경우 추가 식별 문자열이 &lt;a href=&quot;qobject#tr&quot;&gt;tr ()&lt;/a&gt; 호출에 전달 될 수 있습니다 . 이 선택적 명확성 인수는 다른 동일한 문자열을 구별하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="950678192498cdc7d9532ebf8cff1de709aa7807" translate="yes" xml:space="preserve">
          <source>If the scale of any axis is set to 0, the light will be emitted along the world's Z axis.</source>
          <target state="translated">축의 배율이 0으로 설정되어 있으면 라이트가 월드의 Z 축을 따라 방출됩니다.</target>
        </trans-unit>
        <trans-unit id="a0b0f76c81d0f2873e0b3a1acd0b4e4fd0af01a8" translate="yes" xml:space="preserve">
          <source>If the scene already has focus, this function does nothing.</source>
          <target state="translated">장면에 이미 초점이 있으면이 기능은 아무 작업도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c217ae6f8e16a6a09d61ccf8237fccd7f9fe4973" translate="yes" xml:space="preserve">
          <source>If the scene graph is not ready, or the scene graph is not using OpenGL, this function will return null.</source>
          <target state="translated">장면 그래프가 준비되지 않았거나 장면 그래프가 OpenGL을 사용하지 않는 경우이 함수는 null을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="dab7f072e29a6f938a4cffbc374f1c6bd0adf9e6" translate="yes" xml:space="preserve">
          <source>If the scene is currently inactive,</source>
          <target state="translated">장면이 현재 비활성화 된 경우</target>
        </trans-unit>
        <trans-unit id="20c709cd5d474ed5e995838d38189b54ddcb0d1c" translate="yes" xml:space="preserve">
          <source>If the scene to be rendered includes non-opaque materials, you may need to modify those materials with custom blend arguments in order for them to be rendered correctly. For example, if working with a &lt;a href=&quot;qml-qt3d-extras-phongalphamaterial&quot;&gt;PhongAlphaMaterial&lt;/a&gt; and a scene with an opaque clear color, you will likely want to add:</source>
          <target state="translated">렌더링 할 장면에 불투명하지 않은 재질이 포함 된 경우 해당 재질을 올바르게 렌더링하려면 사용자 정의 혼합 인수로 해당 재질을 수정해야 할 수도 있습니다. 예를 들어 &lt;a href=&quot;qml-qt3d-extras-phongalphamaterial&quot;&gt;PhongAlphaMaterial&lt;/a&gt; 및 불투명 한 색상의 장면을 사용하는 경우 다음을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4fae842e9b4b99419777b2fff6f71340f6472da5" translate="yes" xml:space="preserve">
          <source>If the scene's font changes, either directly through setFont() or indirectly when the application font changes, &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; first sends itself a &lt;a href=&quot;qevent#Type-enum&quot;&gt;FontChange&lt;/a&gt; event, and it then sends &lt;a href=&quot;qevent#Type-enum&quot;&gt;FontChange&lt;/a&gt; events to all top-level widget items in the scene. These items respond by resolving their own fonts to the scene, and they then notify their children, who again notify their children, and so on, until all widget items have updated their fonts.</source>
          <target state="translated">장면의 글꼴이 setFont ()를 통해 직접 또는 응용 프로그램 글꼴이 변경 될 때 간접적으로 변경되면 &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene은&lt;/a&gt; 먼저 &lt;a href=&quot;qevent#Type-enum&quot;&gt;FontChange&lt;/a&gt; 이벤트를 보낸 다음 장면의 모든 최상위 위젯 항목으로 &lt;a href=&quot;qevent#Type-enum&quot;&gt;FontChange&lt;/a&gt; 이벤트를 보냅니다 . 이러한 항목은 장면에 대한 자체 글꼴을 해결하여 응답 한 다음 모든 위젯 항목이 글꼴을 업데이트 할 때까지 자식에게 알리고 다시 자식에게 알리는 등의 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="1d6eaac84e69835fb2152adc2b37a30ad3edf76c" translate="yes" xml:space="preserve">
          <source>If the scene's palette changes, either directly through setPalette() or indirectly when the application palette changes, &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; first sends itself a &lt;a href=&quot;qevent#Type-enum&quot;&gt;PaletteChange&lt;/a&gt; event, and it then sends &lt;a href=&quot;qevent#Type-enum&quot;&gt;PaletteChange&lt;/a&gt; events to all top-level widget items in the scene. These items respond by resolving their own palettes to the scene, and they then notify their children, who again notify their children, and so on, until all widget items have updated their palettes.</source>
          <target state="translated">장면의 팔레트가 setPalette ()를 통해 직접 또는 응용 프로그램 팔레트가 변경 될 때 간접적으로 변경되면 &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene은&lt;/a&gt; 먼저 &lt;a href=&quot;qevent#Type-enum&quot;&gt;PaletteChange&lt;/a&gt; 이벤트를 전송 한 다음 &lt;a href=&quot;qevent#Type-enum&quot;&gt;PaletteChange&lt;/a&gt; 이벤트를 장면의 모든 최상위 위젯 항목으로 전송합니다. 이러한 항목은 장면에 대한 자체 팔레트를 해결하여 응답 한 다음 모든 위젯 항목이 팔레트를 업데이트 할 때까지 자식에게 알리고 다시 자식에게 알리는 등의 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="0b746ac16080f32d86dd5f5557e8fbf19345d130" translate="yes" xml:space="preserve">
          <source>If the schema &lt;a href=&quot;qxmlschema#isValid&quot;&gt;is invalid&lt;/a&gt;, &lt;code&gt;false&lt;/code&gt; is returned and the behavior is undefined.</source>
          <target state="translated">스키마가있는 경우 &lt;a href=&quot;qxmlschema#isValid&quot;&gt;무효&lt;/a&gt; , &lt;code&gt;false&lt;/code&gt; 반환되고, 동작은 정의되지 않는다.</target>
        </trans-unit>
        <trans-unit id="4968cae8a20987631df322e5c29753ea0c008a2c" translate="yes" xml:space="preserve">
          <source>If the script is a single expression, we recommend writing it inline:</source>
          <target state="translated">스크립트가 단일 표현식 인 경우 인라인으로 작성하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="c6c0db66cc3f462d4ed47df3108def0f542f5189" translate="yes" xml:space="preserve">
          <source>If the script is more than a couple of lines long or can be used by different objects, we recommend creating a function and calling it like this:</source>
          <target state="translated">스크립트가 두 줄 이상이거나 다른 객체에서 사용할 수있는 경우 함수를 만들고 다음과 같이 호출하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="0557b0d4fdd672dd6088c21c157a07155f2d52d0" translate="yes" xml:space="preserve">
          <source>If the script is only a couple of lines long, we generally use a block:</source>
          <target state="translated">스크립트의 길이가 몇 줄에 불과한 경우 일반적으로 블록을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="868b4c67bebb9445d535d4042cadfcd92e25b4ea" translate="yes" xml:space="preserve">
          <source>If the scroll area is visible when the</source>
          <target state="translated">스크롤 영역이 표시 될 때</target>
        </trans-unit>
        <trans-unit id="ebd451bd5bd1219ffd9ecadd7561ef98a15d3291" translate="yes" xml:space="preserve">
          <source>If the search succeeds, &lt;a href=&quot;qhelpsearchengine#searchingFinished&quot;&gt;searchingFinished&lt;/a&gt;() is called with the search result count to fetch the search results from the search engine. Calling the &lt;a href=&quot;qhelpsearchengine#searchResults&quot;&gt;searchResults&lt;/a&gt;() function with a range returns a list of &lt;a href=&quot;qhelpsearchresult&quot;&gt;QHelpSearchResult&lt;/a&gt; objects within the range. The results consist of the document title and URL, as well as a snippet from the document that contains the best match for the search input.</source>
          <target state="translated">검색이 성공하면 검색 엔진에서 검색 결과를 가져 오기 위해 검색 결과 개수와 함께 &lt;a href=&quot;qhelpsearchengine#searchingFinished&quot;&gt;searchingFinished&lt;/a&gt; ()가 호출됩니다. 범위와 함께 &lt;a href=&quot;qhelpsearchengine#searchResults&quot;&gt;searchResults&lt;/a&gt; () 함수를 호출하면 범위 내의 &lt;a href=&quot;qhelpsearchresult&quot;&gt;QHelpSearchResult&lt;/a&gt; 객체 목록이 반환 됩니다. 결과는 문서 제목 및 URL과 검색 입력에 가장 일치하는 문서의 스 니펫으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="e0af225ca337a7f11847a6d64a0027720a3105e3" translate="yes" xml:space="preserve">
          <source>If the section is hidden, the return value is undefined.</source>
          <target state="translated">섹션이 숨겨져 있으면 반환 값이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="02787519b8e6ebf0f30df38d1b602e4ff8b0a17e" translate="yes" xml:space="preserve">
          <source>If the selected backend is invalid or an error occurs, the default backend (OpenGL or software, depending on the Qt configuration) is used.</source>
          <target state="translated">선택한 백엔드가 유효하지 않거나 오류가 발생하면 기본 백엔드 (Qt 구성에 따라 OpenGL 또는 소프트웨어)가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5c70158622925506e3d73178eea652a26e1b6d92" translate="yes" xml:space="preserve">
          <source>If the selection spans over table cells,</source>
          <target state="translated">선택이 테이블 셀에 걸쳐 있으면</target>
        </trans-unit>
        <trans-unit id="fc4cdf70502492327344bd19e2e44456f6d152e3" translate="yes" xml:space="preserve">
          <source>If the semaphore already exists, its initial resource count is not reset. If the semaphore does not already exist, it is created and its initial resource count set.</source>
          <target state="translated">세마포어가 이미 존재하면 초기 자원 수는 재설정되지 않습니다. 세마포어가 존재하지 않는 경우 세마포어가 작성되고 초기 자원 수가 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="34c541a2f74ba48b2f57c077f5539cc929fca9ff" translate="yes" xml:space="preserve">
          <source>If the sequence is exposed as a &lt;a href=&quot;qobject#Q_PROPERTY&quot;&gt;Q_PROPERTY&lt;/a&gt;, accessing any value in the sequence by index will cause the sequence data to be read from the &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;'s property, then a read to occur. Similarly, modifying any value in the sequence will cause the sequence data to be read, and then the modification will be performed and the modified sequence will be written back to the &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;'s property.</source>
          <target state="translated">시퀀스가 &lt;a href=&quot;qobject#Q_PROPERTY&quot;&gt;Q_PROPERTY&lt;/a&gt; 로 노출되면 인덱스로 시퀀스의 값에 액세스하면 &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 의 속성 에서 시퀀스 데이터를 읽은 후 읽기가 발생합니다. 마찬가지로 시퀀스의 값을 수정하면 시퀀스 데이터를 읽은 다음 수정이 수행되고 수정 된 시퀀스가 &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 의 속성에 다시 쓰여집니다 .</target>
        </trans-unit>
        <trans-unit id="cf5f5f2f6c8bbf049dfc54d5fe1b276cd3219844" translate="yes" xml:space="preserve">
          <source>If the sequence is returned from a &lt;a href=&quot;qobject#Q_INVOKABLE&quot;&gt;Q_INVOKABLE&lt;/a&gt; function, access and mutation is much cheaper, as no &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; property read or write occurs; instead, the C++ sequence data is accessed and modified directly.</source>
          <target state="translated">&lt;a href=&quot;qobject#Q_INVOKABLE&quot;&gt;Q_INVOKABLE&lt;/a&gt; 함수 에서 시퀀스가 ​​반환되면 &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 속성 읽기 또는 쓰기가 발생 하지 않으므로 액세스 및 변형이 훨씬 저렴 합니다. 대신 C ++ 시퀀스 데이터에 직접 액세스하고 수정합니다.</target>
        </trans-unit>
        <trans-unit id="ca22b62ba87be229d95d048b3759c18b9be5adac" translate="yes" xml:space="preserve">
          <source>If the series is null, this property resets to default. Defaults to the first added series or zero if no series are added to the graph.</source>
          <target state="translated">계열이 null 인 경우이 속성은 기본값으로 재설정됩니다. 첫 번째로 추가 된 계열이 기본값이되며 그래프에 계열이 추가되지 않으면 0이됩니다.</target>
        </trans-unit>
        <trans-unit id="e0239850fd84abfb7743093588769d592cad7725" translate="yes" xml:space="preserve">
          <source>If the server could be built and registered correctly during the build process, but the object cannot be initiliazed e.g. by the OLE/COM Object Viewer application, make sure that no DLL the server depends on is missing from the system path (e.g. the Qt DLL). Use a dependency walker to view all dependencies of the server binary.</source>
          <target state="translated">빌드 프로세스 중에 서버를 빌드하고 올바로 등록 할 수 있지만 OLE / COM 오브젝트 뷰어 응용 프로그램 등으로 오브젝트를 초기화 할 수없는 경우 서버가 의존하는 DLL이 시스템 경로에서 누락되지 않았는지 확인하십시오 (예 : Qt DLL). ). 종속성 워커를 사용하여 서버 바이너리의 모든 종속성을보십시오.</target>
        </trans-unit>
        <trans-unit id="f58bcf7a96b50057a2ec742703553f0a993c2383" translate="yes" xml:space="preserve">
          <source>If the server does not use &lt;a href=&quot;qdtlsclientverifier&quot;&gt;QDtlsClientVerifier&lt;/a&gt;, it</source>
          <target state="translated">서버는 사용하지 않는 경우 &lt;a href=&quot;qdtlsclientverifier&quot;&gt;QDtlsClientVerifier를&lt;/a&gt; , 그것은</target>
        </trans-unit>
        <trans-unit id="4b13d3eeeb9f3b030e2e2aee93f64bb69e934a32" translate="yes" xml:space="preserve">
          <source>If the server is using &lt;a href=&quot;qnetworkproxy&quot;&gt;QNetworkProxy&lt;/a&gt;, the returned descriptor may not be usable with native socket functions.</source>
          <target state="translated">서버가 &lt;a href=&quot;qnetworkproxy&quot;&gt;QNetworkProxy를&lt;/a&gt; 사용 하는 경우, 리턴 된 디스크립터는 기본 소켓 기능과 함께 사용하지 못할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="01d569c91b1350246db048282f687deef97670cb" translate="yes" xml:space="preserve">
          <source>If the server object is already listening for incoming connections this function always returns &lt;code&gt;false&lt;/code&gt;. &lt;a href=&quot;qbluetoothserver#close&quot;&gt;close&lt;/a&gt;() should be called before calling this function.</source>
          <target state="translated">서버 객체가 이미 들어오는 연결을 수신하고 있으면이 함수는 항상 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 . 이 함수를 호출하기 전에 &lt;a href=&quot;qbluetoothserver#close&quot;&gt;close&lt;/a&gt; ()를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="c80056990e7ed500c27aea7ebee45a5b8efa8b45" translate="yes" xml:space="preserve">
          <source>If the server object is already listening for incoming connections this function returns an invalid &lt;a href=&quot;qbluetoothserviceinfo&quot;&gt;QBluetoothServiceInfo&lt;/a&gt;.</source>
          <target state="translated">서버 객체가 이미 들어오는 연결을 수신하고있는 경우이 함수는 잘못된 &lt;a href=&quot;qbluetoothserviceinfo&quot;&gt;QBluetoothServiceInfo를&lt;/a&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="64709a78b559662b7a7b49ba74ad88c1323fb161" translate="yes" xml:space="preserve">
          <source>If the server runs (e.g. the task manager lists a process), see the following section for information on debugging your server.</source>
          <target state="translated">서버가 실행되는 경우 (예 : 작업 관리자에 프로세스가 나열 됨) 서버 디버깅에 대한 정보는 다음 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c6f4c9f4e83c9ff2f89e5a2bfe0096d54f9e1301" translate="yes" xml:space="preserve">
          <source>If the server runs, see the following section for information on debugging your server.</source>
          <target state="translated">서버가 실행되면 서버 디버깅에 대한 정보는 다음 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="bd5f9f75d5eae9f173b6dd7cc0c416f1dcfb63d3" translate="yes" xml:space="preserve">
          <source>If the service does not implement the control, or if it is unavailable a null pointer is returned instead.</source>
          <target state="translated">서비스가 컨트롤을 구현하지 않거나 사용할 수없는 경우 대신 널 포인터가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="02df3b435bd97f01d14a2cf05ac192916d88add9" translate="yes" xml:space="preserve">
          <source>If the service information is already registered with the platform's SDP database, the database entry will not be updated until &lt;a href=&quot;qbluetoothserviceinfo#registerService&quot;&gt;registerService&lt;/a&gt;() was called again.</source>
          <target state="translated">서비스 정보가 이미 플랫폼의 SDP 데이터베이스에 등록되어 있으면 &lt;a href=&quot;qbluetoothserviceinfo#registerService&quot;&gt;registerService&lt;/a&gt; ()를 다시 호출 할 때까지 데이터베이스 항목이 업데이트되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="5340ab668570cd2bf981b2776d5aa136cb56cd3f" translate="yes" xml:space="preserve">
          <source>If the service information is already registered with the platforms SDP database, the database entry will not be updated until &lt;a href=&quot;qbluetoothserviceinfo#registerService&quot;&gt;registerService&lt;/a&gt;() was called again.</source>
          <target state="translated">서비스 정보가 이미 플랫폼 SDP 데이터베이스에 등록되어 있으면 &lt;a href=&quot;qbluetoothserviceinfo#registerService&quot;&gt;registerService&lt;/a&gt; ()를 다시 호출 할 때까지 데이터베이스 항목이 업데이트되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="b864b2f1146b1150ae001e8c9d34e6c441edf3da" translate="yes" xml:space="preserve">
          <source>If the service provider supports geocoding the subclass should provide an implementation of &lt;a href=&quot;qgeocodingmanagerengine#geocode&quot;&gt;geocode&lt;/a&gt;() and call setSupportsGeocoding(true) at some point in time before &lt;a href=&quot;qgeocodingmanagerengine#geocode&quot;&gt;geocode&lt;/a&gt;() is called.</source>
          <target state="translated">서비스 제공자가 지오 코딩을 지원하는 경우 서브 클래스는 &lt;a href=&quot;qgeocodingmanagerengine#geocode&quot;&gt;지오 코드&lt;/a&gt; () 의 구현을 제공하고 &lt;a href=&quot;qgeocodingmanagerengine#geocode&quot;&gt;지오 코드&lt;/a&gt; ()가 호출 되기 전에 특정 시점에 setSupportsGeocoding (true)을 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="c1129aafb01cb11c9ea321240dd1d60be4258356" translate="yes" xml:space="preserve">
          <source>If the service registration succeeds, the &lt;a href=&quot;qdbusconnectioninterface#serviceRegistered&quot;&gt;serviceRegistered&lt;/a&gt;() signal will be emitted. If we are placed in queue, the signal will be emitted when we obtain the name. If</source>
          <target state="translated">서비스 등록에 성공하면 &lt;a href=&quot;qdbusconnectioninterface#serviceRegistered&quot;&gt;serviceRegistered&lt;/a&gt; () 신호가 발생합니다. 우리가 대기열에 있으면 이름을 얻을 때 신호가 방출됩니다. 만약</target>
        </trans-unit>
        <trans-unit id="0370a8b993b291ca4bea577370f2c5875cceb96b" translate="yes" xml:space="preserve">
          <source>If the session &lt;a href=&quot;qnetworksession#isOpen&quot;&gt;isOpen&lt;/a&gt;() and is bound to a &lt;a href=&quot;qnetworkconfiguration&quot;&gt;QNetworkConfiguration&lt;/a&gt; of type UserChoice, this property returns the identifier of the &lt;a href=&quot;qnetworkconfiguration&quot;&gt;QNetworkConfiguration&lt;/a&gt; that the configuration resolved to when &lt;a href=&quot;qnetworksession#open&quot;&gt;open&lt;/a&gt;() was called; otherwise an empty string.</source>
          <target state="translated">세션 경우 &lt;a href=&quot;qnetworksession#isOpen&quot;&gt;ISOPEN&lt;/a&gt; () 및이에 바인딩 &lt;a href=&quot;qnetworkconfiguration&quot;&gt;QNetworkConfiguration&lt;/a&gt; 형 UserChoice의이 속성의 식별자 반환 &lt;a href=&quot;qnetworkconfiguration&quot;&gt;QNetworkConfiguration을&lt;/a&gt; 구성을 할 때 해결 것을 &lt;a href=&quot;qnetworksession#open&quot;&gt;공개&lt;/a&gt; 불렸다를 (); 그렇지 않으면 빈 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="c546f2cb4a6052df671f92c55b0fb0d37ac2c1d8" translate="yes" xml:space="preserve">
          <source>If the session &lt;a href=&quot;qnetworksession#isOpen&quot;&gt;isOpen&lt;/a&gt;() and is bound to a QNetworkConfiguration of type UserChoice, this property returns the identifier of the QNetworkConfiguration that the configuration resolved to when &lt;a href=&quot;qnetworksession#open&quot;&gt;open&lt;/a&gt;() was called; otherwise an empty string.</source>
          <target state="translated">세션 경우 &lt;a href=&quot;qnetworksession#isOpen&quot;&gt;ISOPEN&lt;/a&gt; () 및이 형 UserChoice의 QNetworkConfiguration에 바인딩이 속성은 구성 할 때 해결하는 QNetworkConfiguration의 식별자를 반환 &lt;a href=&quot;qnetworksession#open&quot;&gt;열린&lt;/a&gt; 불렸다를 (); 그렇지 않으면 빈 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="5dff93b365ef92ddcb679e0549b20bf14e3139a4" translate="yes" xml:space="preserve">
          <source>If the session &lt;a href=&quot;qnetworksession#isOpen&quot;&gt;isOpen&lt;/a&gt;() this property returns the identifier of the &lt;a href=&quot;qnetworkconfiguration&quot;&gt;QNetworkConfiguration&lt;/a&gt; that is used by this session; otherwise an empty string.</source>
          <target state="translated">세션 경우 &lt;a href=&quot;qnetworksession#isOpen&quot;&gt;ISOPEN은&lt;/a&gt; ()이 속성은 식별자 반환 &lt;a href=&quot;qnetworkconfiguration&quot;&gt;QNetworkConfiguration을&lt;/a&gt; 이 세션에서 사용된다; 그렇지 않으면 빈 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="330416953756aed724d42dd254adaf8011d43cbd" translate="yes" xml:space="preserve">
          <source>If the session &lt;a href=&quot;qnetworksession#isOpen&quot;&gt;isOpen&lt;/a&gt;() this property returns the identifier of the QNetworkConfiguration that is used by this session; otherwise an empty string.</source>
          <target state="translated">만약 세션 &lt;a href=&quot;qnetworksession#isOpen&quot;&gt;ISOPEN&lt;/a&gt; ()이 속성이 세션에서 사용되는 QNetworkConfiguration의 식별자를 반환한다; 그렇지 않으면 빈 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="c57034be011e076e2493a5bedb61bb00bbce26ce" translate="yes" xml:space="preserve">
          <source>If the session is based on a service network configuration the number of sent bytes across all active member configurations are returned.</source>
          <target state="translated">세션이 서비스 네트워크 구성을 기반으로하는 경우 모든 활성 구성원 구성에서 전송 된 바이트 수가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="f4405d99231d406ab58aada8eb1e82d906a3d5f2" translate="yes" xml:space="preserve">
          <source>If the session is based on a single access point configuration the state of the session is the same as the state of the associated network interface. Therefore a network session object can be used to monitor network interfaces.</source>
          <target state="translated">세션이 단일 액세스 포인트 구성을 기반으로하는 경우 세션 상태는 연결된 네트워크 인터페이스의 상태와 같습니다. 따라서 네트워크 세션 객체를 사용하여 네트워크 인터페이스를 모니터링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3abd26c005dc07fc5a2eb3e5ce5b0ee4f5361ac2" translate="yes" xml:space="preserve">
          <source>If the session manager is capable of restoring sessions it will execute</source>
          <target state="translated">세션 관리자가 세션을 복원 할 수 있으면 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="fdd50b33a1d4123b6f2b49040633b01db5e26e90" translate="yes" xml:space="preserve">
          <source>If the session requires polling to keep its state up to date, this property holds the timeout in milliseconds before the session will automatically close. If the value of this property is -1 the session will not automatically close. This property is set to -1 by default.</source>
          <target state="translated">세션의 상태를 최신 상태로 유지하기 위해 세션을 폴링해야하는 경우이 속성은 세션이 자동으로 닫히기 전에 밀리 초 단위로 시간 초과를 유지합니다. 이 특성의 값이 -1이면 세션이 자동으로 닫히지 않습니다. 이 속성은 기본적으로 -1로 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5aa0429b87cff2909e5b636253778ae7d7bfae5" translate="yes" xml:space="preserve">
          <source>If the setting is successful or set before opening the port, returns &lt;code&gt;true&lt;/code&gt;; otherwise returns &lt;code&gt;false&lt;/code&gt; and sets an error code which can be obtained by accessing the value of the &lt;a href=&quot;qserialport#error-prop&quot;&gt;QSerialPort::error&lt;/a&gt; property.</source>
          <target state="translated">포트를 열기 전에 설정이 성공하거나 설정되면 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 . 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 리턴 하고 &lt;a href=&quot;qserialport#error-prop&quot;&gt;QSerialPort :: error&lt;/a&gt; 특성 의 값에 액세스하여 얻을 수있는 오류 코드를 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="536ed7b8e925ac447c96297ac5b170b26db0409a" translate="yes" xml:space="preserve">
          <source>If the setting is successful or set before opening the port, returns &lt;code&gt;true&lt;/code&gt;; otherwise returns &lt;code&gt;false&lt;/code&gt; and sets an error code which can be obtained by accessing the value of the &lt;a href=&quot;qserialport#error-prop&quot;&gt;QSerialPort::error&lt;/a&gt; property. To set the baud rate, use the enumeration &lt;a href=&quot;qserialport#BaudRate-enum&quot;&gt;QSerialPort::BaudRate&lt;/a&gt; or any positive qint32 value.</source>
          <target state="translated">포트를 열기 전에 설정이 성공하거나 설정되면 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 . 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 리턴 하고 &lt;a href=&quot;qserialport#error-prop&quot;&gt;QSerialPort :: error&lt;/a&gt; 특성 의 값에 액세스하여 얻을 수있는 오류 코드를 설정합니다 . 전송 속도를 설정하려면 열거 &lt;a href=&quot;qserialport#BaudRate-enum&quot;&gt;QSerialPort :: BaudRate&lt;/a&gt; 또는 양의 qint32 값을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="22b4d89737d5928418a27715d3eebda5c88174a5" translate="yes" xml:space="preserve">
          <source>If the shader program was already linked, calling this function again will force it to be re-linked.</source>
          <target state="translated">셰이더 프로그램이 이미 링크 된 경우이 함수를 다시 호출하면 강제로 다시 링크됩니다.</target>
        </trans-unit>
        <trans-unit id="08b715151e0efe65d8eaa2cd89590f1ad12eb0cd" translate="yes" xml:space="preserve">
          <source>If the shared data object's reference count is greater than 1, this function creates a deep copy of the shared data object and sets the</source>
          <target state="translated">공유 데이터 객체의 참조 카운트가 1보다 큰 경우이 함수는 공유 데이터 객체의 딥 카피를 생성하고</target>
        </trans-unit>
        <trans-unit id="7c8e4933a05c9153aba19126aa69d5e5b0d43ab4" translate="yes" xml:space="preserve">
          <source>If the shared memory object is attached to an underlying shared memory segment, it will &lt;a href=&quot;qsharedmemory#detach&quot;&gt;detach&lt;/a&gt; from it before setting the new key. This function does not do an &lt;a href=&quot;qsharedmemory#attach&quot;&gt;attach&lt;/a&gt;().</source>
          <target state="translated">공유 메모리 객체가 기본 공유 메모리 세그먼트에 연결된 경우 새 키를 설정하기 전에 &lt;a href=&quot;qsharedmemory#detach&quot;&gt;분리&lt;/a&gt; 됩니다. 이 함수는 &lt;a href=&quot;qsharedmemory#attach&quot;&gt;첨부&lt;/a&gt; ()를 하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="ebfe4ca28a17820e525a4d42b6a14e1a86fd32b1" translate="yes" xml:space="preserve">
          <source>If the signal has no parameters, the &quot;()&quot; brackets are optional. If parameters are used, the parameter types must be declared, as for the &lt;code&gt;string&lt;/code&gt; and &lt;code&gt;var&lt;/code&gt; arguments for the &lt;code&gt;actionPerformed&lt;/code&gt; signal above. The allowed parameter types are the same as those listed under &lt;a href=&quot;#defining-property-attributes&quot;&gt;Defining Property Attributes&lt;/a&gt; on this page.</source>
          <target state="translated">신호에 매개 변수가없는 경우 &quot;()&quot;괄호는 선택 사항입니다. 매개 변수가 사용되는 경우, 위 의 &lt;code&gt;actionPerformed&lt;/code&gt; 신호에 대한 &lt;code&gt;string&lt;/code&gt; 및 &lt;code&gt;var&lt;/code&gt; 인수 와 같이 매개 변수 유형을 선언해야합니다 . 허용되는 매개 변수 유형은 이 페이지의 &lt;a href=&quot;#defining-property-attributes&quot;&gt;특성 속성 정의에&lt;/a&gt; 나열된 것과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="d82a68587dc6cda0a7f123e33745071151f7d9df" translate="yes" xml:space="preserve">
          <source>If the signal has no parameters, the &quot;()&quot; brackets are optional. If parameters are used, the parameter types must be declared, as for the &lt;code&gt;string&lt;/code&gt; and &lt;code&gt;var&lt;/code&gt; arguments for the &lt;code&gt;actionPerformed&lt;/code&gt; signal above. The allowed parameter types are the same as those listed under &lt;a href=&quot;qtqml-syntax-objectattributes#defining-property-attributes&quot;&gt;Defining Property Attributes&lt;/a&gt; on this page.</source>
          <target state="translated">신호에 매개 변수가없는 경우 &quot;()&quot;대괄호는 선택 사항입니다. 매개 변수를 사용하는 경우 위 의 &lt;code&gt;actionPerformed&lt;/code&gt; 신호에 대한 &lt;code&gt;string&lt;/code&gt; 및 &lt;code&gt;var&lt;/code&gt; 인수 와 같이 매개 변수 유형을 선언해야합니다 . 허용되는 매개 변수 유형은 이 페이지의 &lt;a href=&quot;qtqml-syntax-objectattributes#defining-property-attributes&quot;&gt;속성 속성 정의&lt;/a&gt; 아래에 나열된 것과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="baf8972ac4c1a1f0d23c8cd53bbd6742a91af783" translate="yes" xml:space="preserve">
          <source>If the signal is emitted, no other signals will be emitted for the associated changes.</source>
          <target state="translated">신호가 방출되면 관련 변경에 대해 다른 신호가 방출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="469e3f2db163b590554df9999d56adff7bdee63b" translate="yes" xml:space="preserve">
          <source>If the signal is not handled,</source>
          <target state="translated">신호가 처리되지 않으면</target>
        </trans-unit>
        <trans-unit id="4274e528c6b7e77e518a06686f7c61b4d108d79e" translate="yes" xml:space="preserve">
          <source>If the size matches a standard &lt;a href=&quot;qpagedpaintdevice#PageSize-enum&quot;&gt;QPagedPaintDevice::PageSize&lt;/a&gt; then that page size will be used, otherwise &lt;a href=&quot;qpagedpaintdevice#PageSize-enum&quot;&gt;QPagedPaintDevice::Custom&lt;/a&gt; will be set.</source>
          <target state="translated">크기가 표준 &lt;a href=&quot;qpagedpaintdevice#PageSize-enum&quot;&gt;QPagedPaintDevice :: PageSize&lt;/a&gt; 와 일치하면 해당 페이지 크기가 사용되며 그렇지 않으면 &lt;a href=&quot;qpagedpaintdevice#PageSize-enum&quot;&gt;QPagedPaintDevice :: Custom&lt;/a&gt; 이 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="ca789ffa5e5117bb49171be208e897f7c65c46fa" translate="yes" xml:space="preserve">
          <source>If the size of the Loader is specified explicitly by setting the width, height or by anchoring, the loaded item will be resized to the size of the Loader.</source>
          <target state="translated">너비, 높이를 설정하거나 앵커링하여 로더 크기를 명시 적으로 지정하면로드 된 항목의 크기가 로더 크기로 조정됩니다.</target>
        </trans-unit>
        <trans-unit id="5f2d1199fa6860bad5dc73584f7c7a3ba19ad178" translate="yes" xml:space="preserve">
          <source>If the slider has active feedback (i.e., &lt;a href=&quot;qabstractslider#tracking-prop&quot;&gt;QAbstractSlider::tracking&lt;/a&gt; is true), this value will be the same as &lt;a href=&quot;qstyleoptionslider#sliderPosition-var&quot;&gt;sliderPosition&lt;/a&gt;. Otherwise, it will have the value the slider had before the mouse was pressed.</source>
          <target state="translated">슬라이더에 활성 피드백이있는 경우 (즉, &lt;a href=&quot;qabstractslider#tracking-prop&quot;&gt;QAbstractSlider :: tracking&lt;/a&gt; 이 true 인 경우)이 값은 &lt;a href=&quot;qstyleoptionslider#sliderPosition-var&quot;&gt;sliderPosition&lt;/a&gt; 과 같습니다 . 그렇지 않으면 마우스를 누르기 전에 슬라이더의 값을 갖게됩니다.</target>
        </trans-unit>
        <trans-unit id="7cf9ee44d28a296c988e665d040030202884a70c" translate="yes" xml:space="preserve">
          <source>If the slider has active feedback (i.e., &lt;a href=&quot;qabstractslider#tracking-prop&quot;&gt;QAbstractSlider::tracking&lt;/a&gt; is true), this value will be the same as &lt;a href=&quot;qstyleoptionslider#sliderValue-var&quot;&gt;sliderValue&lt;/a&gt;. Otherwise, it will have the current position of the handle. The default value is 0.</source>
          <target state="translated">슬라이더에 활성 피드백이있는 경우 (즉, &lt;a href=&quot;qabstractslider#tracking-prop&quot;&gt;QAbstractSlider :: tracking&lt;/a&gt; 이 true 인 경우)이 값은 &lt;a href=&quot;qstyleoptionslider#sliderValue-var&quot;&gt;sliderValue&lt;/a&gt; 와 같습니다 . 그렇지 않으면 핸들의 현재 위치가됩니다. 기본값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="ba4bb6d920ab18b36b4ce9ec97d00b0dee699025" translate="yes" xml:space="preserve">
          <source>If the socket is using &lt;a href=&quot;qnetworkproxy&quot;&gt;QNetworkProxy&lt;/a&gt;, the returned descriptor may not be usable with native socket functions.</source>
          <target state="translated">소켓이 &lt;a href=&quot;qnetworkproxy&quot;&gt;QNetworkProxy를&lt;/a&gt; 사용 하는 경우, 리턴 된 디스크립터는 원시 소켓 함수와 함께 사용하지 못할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="622c5da4e756463f55acb7ea90794c45442cc232" translate="yes" xml:space="preserve">
          <source>If the socketName is empty (the default), the contents of the start argument &lt;code&gt;--wayland-socket-name&lt;/code&gt; are used instead. If the argument is not set, the compositor tries to find a socket name, which is &lt;code&gt;wayland-0&lt;/code&gt; by default.</source>
          <target state="translated">socketName이 비어 있으면 (기본값) start 인수 &lt;code&gt;--wayland-socket-name&lt;/code&gt; 의 내용 이 대신 사용됩니다. 인수를 설정하지 않으면 컴포 지터는 기본적으로 &lt;code&gt;wayland-0&lt;/code&gt; 인 소켓 이름을 찾으려고합니다 .</target>
        </trans-unit>
        <trans-unit id="9bef2151444abb051e827b3b306370abf3dcd2b8" translate="yes" xml:space="preserve">
          <source>If the source component is not an Item type, Loader does not apply any special sizing rules. When used to load visual types, Loader applies the following sizing rules:</source>
          <target state="translated">소스 구성 요소가 항목 유형이 아닌 경우 로더는 특별한 크기 조정 규칙을 적용하지 않습니다. 비주얼 유형을로드하는 데 사용되는 경우 로더는 다음 크기 조정 규칙을 적용합니다.</target>
        </trans-unit>
        <trans-unit id="04b80385e91ff7f35c0c9f7ee7a117c67a6cffb9" translate="yes" xml:space="preserve">
          <source>If the source data is a &lt;a href=&quot;qiodevice&quot;&gt;QIODevice&lt;/a&gt;, this function will call &lt;a href=&quot;qiodevice#reset&quot;&gt;QIODevice::reset&lt;/a&gt;(), which will seek to byte position 0. If the CBOR stream is not found at the beginning of the device (e.g., beginning of a file), then this function will likely do the wrong thing. Instead, position the &lt;a href=&quot;qiodevice&quot;&gt;QIODevice&lt;/a&gt; to the right offset and call &lt;a href=&quot;qcborstreamreader#setDevice&quot;&gt;setDevice&lt;/a&gt;().</source>
          <target state="translated">소스 데이터가 &lt;a href=&quot;qiodevice&quot;&gt;QIODevice&lt;/a&gt; 인 경우이 함수는 &lt;a href=&quot;qiodevice#reset&quot;&gt;QIODevice :: reset&lt;/a&gt; ()을 호출 하여 바이트 위치 0을 찾습니다. CBOR 스트림이 장치의 시작 (예 : 파일의 시작)에서 발견되지 않으면 이 기능은 잘못된 일을 할 것입니다. 대신 &lt;a href=&quot;qiodevice&quot;&gt;QIODevice&lt;/a&gt; 를 올바른 오프셋에 &lt;a href=&quot;qcborstreamreader#setDevice&quot;&gt;놓고 setDevice&lt;/a&gt; ()를 호출 하십시오 .</target>
        </trans-unit>
        <trans-unit id="d5a2ce0ee7da6a011a11d82647caa5dd940e9259" translate="yes" xml:space="preserve">
          <source>If the source is a non-scalable image (eg. JPEG), the loaded image will be no greater than this property specifies. For some formats (currently only JPEG), the whole image will never actually be loaded into memory.</source>
          <target state="translated">소스가 확장 불가능한 이미지 (예 : JPEG) 인 경우로드 된 이미지는이 속성이 지정한 크기보다 크지 않습니다. 일부 형식 (현재 JPEG 만)의 경우 전체 이미지가 실제로 메모리에로드되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d4cb4ebb67401c1894b8f0ddbb2638485df48186" translate="yes" xml:space="preserve">
          <source>If the source is an intrinsically scalable image (eg. SVG), this property determines the size of the loaded image regardless of intrinsic size. Avoid changing this property dynamically; rendering an SVG is</source>
          <target state="translated">소스가 본질적으로 확장 가능한 이미지 (예 : SVG) 인 경우이 속성은 고유 한 크기에 관계없이로드 된 이미지의 크기를 결정합니다. 이 속성을 동적으로 변경하지 마십시오. SVG 렌더링</target>
        </trans-unit>
        <trans-unit id="7c88a3dbc1b0ced9934c426d3b01827c91f31dcc" translate="yes" xml:space="preserve">
          <source>If the source models don't have the same number of columns, the proxy will only have as many columns as the source model with the smallest number of columns. Additional columns in other source models will simply be ignored.</source>
          <target state="translated">소스 모델에 동일한 수의 열이없는 경우 프록시에는 가장 적은 수의 열이있는 소스 모델만큼의 열만 있습니다. 다른 소스 모델의 추가 열은 단순히 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="d53fe7bbf68fef19427984483ebc91e9651db2da" translate="yes" xml:space="preserve">
          <source>If the source of the drag operation is a widget in this application, this function returns that source; otherwise it returns &lt;code&gt;nullptr&lt;/code&gt;. The source of the operation is the first parameter to the &lt;a href=&quot;qdrag&quot;&gt;QDrag&lt;/a&gt; object used instantiate the drag.</source>
          <target state="translated">드래그 조작의 소스가이 애플리케이션의 위젯 인 경우이 함수는 해당 소스를 리턴합니다. 그렇지 않으면 &lt;code&gt;nullptr&lt;/code&gt; 반환합니다 . 작업의 소스 는 드래그를 인스턴스화하는 데 사용되는 &lt;a href=&quot;qdrag&quot;&gt;QDrag&lt;/a&gt; 객체에 대한 첫 번째 매개 변수 입니다.</target>
        </trans-unit>
        <trans-unit id="05906caa8388db483f83c842c60210bd2f64fc1c" translate="yes" xml:space="preserve">
          <source>If the source uses multiple positioning methods, it tries to get the current position from the most accurate positioning method within the given timeout.</source>
          <target state="translated">소스가 여러 포지셔닝 방법을 사용하는 경우 주어진 타임 아웃 내에서 가장 정확한 포지셔닝 방법에서 현재 위치를 가져 오려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="83a0207e4970b362b75d7a6023ef61ff6b0f765d" translate="yes" xml:space="preserve">
          <source>If the spacing is negative, the items will overlap to some extent.</source>
          <target state="translated">간격이 음수이면 항목이 어느 정도 겹치게됩니다.</target>
        </trans-unit>
        <trans-unit id="3e84ad687673454fe523dddf34813a69f0c5c23a" translate="yes" xml:space="preserve">
          <source>If the specified</source>
          <target state="translated">지정된 경우</target>
        </trans-unit>
        <trans-unit id="cdff49f85312e06da2247f64394762bc46fd85e8" translate="yes" xml:space="preserve">
          <source>If the specified date is invalid, the &lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt; object is set to be invalid.</source>
          <target state="translated">지정된 날짜가 유효하지 않으면 &lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt; 오브젝트가 유효하지 않은 것으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="2d53490303d79fda6eff0f680bddb58861ae26d7" translate="yes" xml:space="preserve">
          <source>If the specified date is invalid, the date is not set and &lt;a href=&quot;qdate#isValid&quot;&gt;isValid&lt;/a&gt;() returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">지정된 날짜가 유효하지 않으면 날짜가 설정되지 않고 &lt;a href=&quot;qdate#isValid&quot;&gt;isValid&lt;/a&gt; ()가 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="7e2746532ae9cb0b31714e69260bc64015c05ecb" translate="yes" xml:space="preserve">
          <source>If the specified interval is adjacent to, or overlaps existing intervals within the time range, these intervals will be merged.</source>
          <target state="translated">지정된 간격이 시간 범위 내에서 기존 간격에 인접하거나 기존 간격과 겹치면 이러한 간격이 병합됩니다.</target>
        </trans-unit>
        <trans-unit id="aaeae022a94d14439f43b625c4aff5019ee7d7b0" translate="yes" xml:space="preserve">
          <source>If the specified rect cannot be reached, the contents are scrolled to the nearest valid position.</source>
          <target state="translated">지정된 rect에 도달 할 수 없으면 내용이 가장 가까운 유효한 위치로 스크롤됩니다.</target>
        </trans-unit>
        <trans-unit id="3e96bcc628409b08fd4759c8fb03a004b1b56f5c" translate="yes" xml:space="preserve">
          <source>If the specified series is not yet added to the graph, setting it as the primary series will also implicitly add it to the graph.</source>
          <target state="translated">지정된 계열이 아직 그래프에 추가되지 않은 경우 기본 계열로 설정하면 암시 적으로 그래프에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="f03c44a89537aed2154d820ff14d1eb2bedc58d5" translate="yes" xml:space="preserve">
          <source>If the splitter is horizontal, the values set the width of each widget in pixels, from left to right. If the splitter is vertical, the height of each widget is set, from top to bottom.</source>
          <target state="translated">스플리터가 수평 인 경우 값은 왼쪽에서 오른쪽으로 각 위젯의 너비를 픽셀 단위로 설정합니다. 스플리터가 수직이면 각 위젯의 높이가 위에서 아래로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="c5e9a502848e7bc5ffd483a9dbd2ce2524b62cae" translate="yes" xml:space="preserve">
          <source>If the splitter's orientation is horizontal, the list contains the widgets width in pixels, from left to right; if the orientation is vertical, the list contains the widgets' heights in pixels, from top to bottom.</source>
          <target state="translated">스플리터의 방향이 가로이면 목록에 위젯 너비가 왼쪽에서 오른쪽으로 픽셀 단위로 포함됩니다. 방향이 수직 인 경우, 목록은 위젯의 높이를 픽셀 단위로 위에서 아래로 포함합니다.</target>
        </trans-unit>
        <trans-unit id="ddc971f7ea1d657a2f2e29c036957a9059a378f7" translate="yes" xml:space="preserve">
          <source>If the stack is empty, or if the bottom command on the stack has already been undone, this function does nothing.</source>
          <target state="translated">스택이 비어 있거나 스택의 맨 아래 명령이 이미 실행 취소 된 경우이 기능은 아무 작업도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9a6923daca80c351ff379da21d20783536a53ab5" translate="yes" xml:space="preserve">
          <source>If the stack is empty, or if the top command on the stack has already been redone, this function does nothing.</source>
          <target state="translated">스택이 비어 있거나 스택의 맨 위 명령이 이미 다시 실행 된 경우이 함수는 아무 작업도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3064d73556c6775a7cde6608df54f261d638f4cc" translate="yes" xml:space="preserve">
          <source>If the stack is in the clean state, returns &lt;code&gt;true&lt;/code&gt;; otherwise returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">스택이 클린 상태 인 &lt;code&gt;true&lt;/code&gt; 반환 합니다 . 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="cec1a7128f418d8998258d5a5e875d1c89cb0378" translate="yes" xml:space="preserve">
          <source>If the stack is not a member of this group, this function does nothing.</source>
          <target state="translated">스택이이 그룹의 구성원이 아닌 경우이 함수는 아무 작업도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="51ecaf2448054e9054e619dc1d7a4f33c5b9c4de" translate="yes" xml:space="preserve">
          <source>If the state group is in its base state (i.e. no explicit state has been set), &lt;code&gt;state&lt;/code&gt; will be a blank string. Likewise, you can return a state group to its base state by setting its current state to &lt;code&gt;''&lt;/code&gt;.</source>
          <target state="translated">상태 그룹이 기본 상태에 있으면 (즉, 명시 적 상태가 설정되지 않은 경우) &lt;code&gt;state&lt;/code&gt; 는 빈 문자열이됩니다. 마찬가지로 현재 상태를 &lt;code&gt;''&lt;/code&gt; 로 설정하여 상태 그룹을 기본 상태로 되돌릴 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="eb2d95ed64c2dc56da5e00fce0037fcc81db0e24" translate="yes" xml:space="preserve">
          <source>If the state is already in a different machine, it will first be removed from its old machine, and then added to this machine.</source>
          <target state="translated">상태가 이미 다른 시스템에있는 경우 먼저 이전 시스템에서 제거한 후이 시스템에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="01d3e46a02cd22a1913bb98f08ab53ad473d284c" translate="yes" xml:space="preserve">
          <source>If the stream has read to the end of the file, readLine() will return a null &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;. For strings, or for devices that support it, you can explicitly test for the end of the stream using &lt;a href=&quot;qtextstream#atEnd&quot;&gt;atEnd&lt;/a&gt;().</source>
          <target state="translated">스트림이 파일의 끝까지 읽은 경우 readLine ()은 null &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; 을 반환합니다 . 문자열 또는이를 지원하는 장치의 경우 &lt;a href=&quot;qtextstream#atEnd&quot;&gt;atEnd&lt;/a&gt; ()를 사용하여 스트림의 끝을 명시 적으로 테스트 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e0d49e82cc3fa6c95a040dbfb58fc8b2a3e8a132" translate="yes" xml:space="preserve">
          <source>If the stream operates on a device, &lt;a href=&quot;qtextstream#flush&quot;&gt;flush&lt;/a&gt;() will be called implicitly. Otherwise, the device is unaffected.</source>
          <target state="translated">스트림이 장치에서 작동하는 경우 &lt;a href=&quot;qtextstream#flush&quot;&gt;flush&lt;/a&gt; ()가 암시 적으로 호출됩니다. 그렇지 않으면 장치가 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="023a5f3a2612ac39f625a262fb6df2141d29f4ed" translate="yes" xml:space="preserve">
          <source>If the stretch factor is 0 and nothing else in the &lt;a href=&quot;qboxlayout&quot;&gt;QBoxLayout&lt;/a&gt; has a stretch factor greater than zero, the space is distributed according to the &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt;:sizePolicy() of each widget that's involved.</source>
          <target state="translated">신축 계수가 0이고 &lt;a href=&quot;qboxlayout&quot;&gt;QBoxLayout의&lt;/a&gt; 다른 신축 계수가 0 보다 큰 경우 공간은 관련된 각 위젯 의 &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; : sizePolicy ()에 따라 분배됩니다 .</target>
        </trans-unit>
        <trans-unit id="3cb876878eea916e6d7fd25093c01b597440ec31" translate="yes" xml:space="preserve">
          <source>If the string</source>
          <target state="translated">문자열이</target>
        </trans-unit>
        <trans-unit id="6d87c711a29ef49f19c5fc56a242441f2a80f728" translate="yes" xml:space="preserve">
          <source>If the string assigned to a URL is already an absolute URL, then &quot;resolving&quot; does not change it and the URL is assigned directly.</source>
          <target state="translated">URL에 할당 된 문자열이 이미 절대 URL 인 경우 &quot;해결&quot;은 해당 URL을 변경하지 않으며 URL이 직접 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="3c16aac73e34ae5d85d412015881b999da5a3b6c" translate="yes" xml:space="preserve">
          <source>If the string could not be parsed, returns an invalid &lt;a href=&quot;qdatetime&quot;&gt;QDateTime&lt;/a&gt;.</source>
          <target state="translated">문자열을 구문 분석 할 수 없으면 유효하지 않은 &lt;a href=&quot;qdatetime&quot;&gt;QDateTime을&lt;/a&gt; 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="c54dff5b7c74aea87e64d30cb2608c2f886628ad" translate="yes" xml:space="preserve">
          <source>If the string of QML imports files using relative paths, the path should be relative to the file in which the parent object (the second argument to the method) is defined.</source>
          <target state="translated">QML 문자열이 상대 경로를 사용하여 파일을 가져 오는 경우, 경로는 상위 오브젝트 (메소드에 대한 두 번째 인수)가 정의 된 파일을 기준으로해야합니다.</target>
        </trans-unit>
        <trans-unit id="1b499b0ca1f2f2be868e05fe0c00fb07628a20cc" translate="yes" xml:space="preserve">
          <source>If the string reference is not a complete reference of the string (meaning that &lt;a href=&quot;qstringref#position&quot;&gt;position&lt;/a&gt;() is 0 and &lt;a href=&quot;qstringref#size&quot;&gt;size&lt;/a&gt;() equals &lt;a href=&quot;qstringref#string&quot;&gt;string&lt;/a&gt;()-&amp;gt;&lt;a href=&quot;qstringref#size&quot;&gt;size&lt;/a&gt;()), this function will allocate a new string to return.</source>
          <target state="translated">문자열 참조가 문자열의 완전한 참조가 아닌 경우 ( &lt;a href=&quot;qstringref#position&quot;&gt;위치&lt;/a&gt; ()가 0이고 &lt;a href=&quot;qstringref#size&quot;&gt;크기&lt;/a&gt; ()가 &lt;a href=&quot;qstringref#string&quot;&gt;문자열&lt;/a&gt; ()-&amp;gt; &lt;a href=&quot;qstringref#size&quot;&gt;크기&lt;/a&gt; ()) 임을 의미하면 이 함수는 반환 할 새 문자열을 할당합니다.</target>
        </trans-unit>
        <trans-unit id="2890eb757b1accfe872df38a7d4500da1d5bba7d" translate="yes" xml:space="preserve">
          <source>If the string representation cannot be converted to any enum representation, the variant is set to &lt;code&gt;Invalid&lt;/code&gt;.</source>
          <target state="translated">문자열 표현을 열거 형 표현으로 변환 할 수없는 경우 변형은 &lt;code&gt;Invalid&lt;/code&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="9e6d0efac6da8e1433ca3fb17674af4e0bf31f50" translate="yes" xml:space="preserve">
          <source>If the string violates the locale format, or language is not a valid ISO 369 code, the &quot;C&quot; locale is used instead. If country is not present, or is not a valid ISO 3166 code, the most appropriate country is chosen for the specified language.</source>
          <target state="translated">문자열이 로케일 형식을 위반하거나 언어가 유효한 ISO 369 코드가 아닌 경우 &quot;C&quot;로케일이 대신 사용됩니다. 국가가 없거나 유효한 ISO 3166 코드가 아닌 경우 지정된 언어에 가장 적합한 국가가 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="8dcc20d9fc585d806c8a300b3bcf74ac502ee3df" translate="yes" xml:space="preserve">
          <source>If the string violates the locale format, or language is not a valid ISO 639 code, the &quot;C&quot; locale is used instead. If country is not present, or is not a valid ISO 3166 code, the most appropriate country is chosen for the specified language.</source>
          <target state="translated">문자열이 로케일 형식을 위반하거나 언어가 유효한 ISO 639 코드가 아닌 경우 &quot;C&quot;로케일이 대신 사용됩니다. 국가가 없거나 유효한 ISO 3166 코드가 아닌 경우 지정된 언어에 가장 적합한 국가가 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="9d058f8ef2b37836eb0434571761de6d7f344feb" translate="yes" xml:space="preserve">
          <source>If the style that uses the type is one of many styles used by an application, it may be better to only register it when necessary. This is the point at which it would make sense to implement your own &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtqml-modules-cppplugins.html&quot;&gt;QML plugin&lt;/a&gt;.</source>
          <target state="translated">유형을 사용하는 스타일이 응용 프로그램에서 사용하는 많은 스타일 중 하나 인 경우 필요할 때만 등록하는 것이 좋습니다. 이것은 자신의 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtqml-modules-cppplugins.html&quot;&gt;QML 플러그인&lt;/a&gt; 을 구현하는 것이 합리적인 시점 입니다.</target>
        </trans-unit>
        <trans-unit id="13d9895ffd342e3012e52db2ce11473be8e007d0" translate="yes" xml:space="preserve">
          <source>If the style that uses the type is one of many styles used by an application, it may be better to only register it when necessary. This is the point at which it would make sense to implement your own &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtqml-modules-cppplugins.html&quot;&gt;QML plugin&lt;/a&gt;.</source>
          <target state="translated">유형을 사용하는 스타일이 응용 프로그램에서 사용하는 여러 스타일 중 하나 인 경우 필요한 경우에만 등록하는 것이 좋습니다. 이것은 자신의 &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtqml-modules-cppplugins.html&quot;&gt;QML 플러그인&lt;/a&gt; 을 구현하는 것이 합리적 입니다.</target>
        </trans-unit>
        <trans-unit id="5c8e5aae2d6b9b60e60ec01845b24fff7eb3e7ae" translate="yes" xml:space="preserve">
          <source>If the style that uses the type is the only style used by an application, it's enough to register it with the QML engine via &lt;a href=&quot;qqmlengine#qmlRegisterType-1&quot;&gt;qmlRegisterType&lt;/a&gt;():</source>
          <target state="translated">유형을 사용하는 스타일이 애플리케이션에서 사용하는 유일한 스타일 인 경우 &lt;a href=&quot;qqmlengine#qmlRegisterType-1&quot;&gt;qmlRegisterType&lt;/a&gt; ()을 통해 QML 엔진에 등록하기에 충분합니다 .</target>
        </trans-unit>
        <trans-unit id="988ceb811e7aa9b3672f28cba22a70640d5ba3bd" translate="yes" xml:space="preserve">
          <source>If the style that uses the type is the only style used by an application, it's enough to register it with the QML engine via qmlRegisterType():</source>
          <target state="translated">유형을 사용하는 스타일이 애플리케이션에서 사용되는 유일한 스타일 인 경우 qmlRegisterType ()을 통해 QML 엔진에 등록하는 것으로 충분합니다.</target>
        </trans-unit>
        <trans-unit id="75ffeaf9b2bf2ba7d9f682bc7b08e02669143394" translate="yes" xml:space="preserve">
          <source>If the stylesheet has no template named</source>
          <target state="translated">스타일 시트에 이름이 지정된 템플릿이없는 경우</target>
        </trans-unit>
        <trans-unit id="fa451619b3081b1cf00f68504dcae197c95e6f92" translate="yes" xml:space="preserve">
          <source>If the subpath does not contain any elements, this function does nothing.</source>
          <target state="translated">서브 패스에 요소가 없으면이 함수는 아무 것도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9355e4e84b4ebf56fccec441b95ac4556c93923d" translate="yes" xml:space="preserve">
          <source>If the substring argument is surrounded by slashes it is interpreted as a &lt;a href=&quot;qregexp&quot;&gt;regular expression&lt;/a&gt;.</source>
          <target state="translated">하위 문자열 인수가 슬래시로 묶여 있으면 &lt;a href=&quot;qregexp&quot;&gt;정규 표현식으로&lt;/a&gt; 해석됩니다 .</target>
        </trans-unit>
        <trans-unit id="3cd5cbb12b457cebe68f610c9985b210530ffcc0" translate="yes" xml:space="preserve">
          <source>If the supplied</source>
          <target state="translated">제공된 경우</target>
        </trans-unit>
        <trans-unit id="37c335f033f0f1b07f7e9ab7b8149845ac3ffab7" translate="yes" xml:space="preserve">
          <source>If the supplied point lies outside the rendered area, the returned point will be outside the source rectangle.</source>
          <target state="translated">제공된 점이 렌더링 된 영역 밖에 있으면 반환 된 점은 소스 사각형 밖에 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a4824f0d26b316db60ab2a0a1548054848d84e1" translate="yes" xml:space="preserve">
          <source>If the supplied point lies outside the rendered area, the returned point will be outside the source rectangle. No clamping is performed.</source>
          <target state="translated">제공된 점이 렌더링 된 영역 밖에 있으면 반환 된 점은 소스 사각형 밖에 있습니다. 클램핑이 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="38610600f3793c2ab7f8f19bfed4d94174b7f5dc" translate="yes" xml:space="preserve">
          <source>If the surface is to present frames using a frame's handle a surface format will also include a handle type which is given by the &lt;a href=&quot;qvideosurfaceformat#handleType&quot;&gt;handleType&lt;/a&gt;() function.</source>
          <target state="translated">표면이 프레임의 핸들을 사용하여 프레임을 &lt;a href=&quot;qvideosurfaceformat#handleType&quot;&gt;나타내&lt;/a&gt; 려면 표면 형식에도 handleType () 함수 가 제공하는 핸들 유형이 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="06325d3028d8ea50838c3dfbc9d73db2dbe0a044" translate="yes" xml:space="preserve">
          <source>If the system ID is based of a Bluetooth Device Address with a Company Identifier (OUI) is 0x123456 and the Company Assigned Identifier is 0x9ABCDE, then the System Identifier is required to be 0x123456FFFE9ABCDE.</source>
          <target state="translated">시스템 ID가 회사 식별자 (OUI)가있는 Bluetooth 장치 주소를 기반으로하고 0x123456이고 회사 할당 식별자가 0x9ABCDE 인 경우 시스템 식별자는 0x123456FFFE9ABCDE 여야합니다.</target>
        </trans-unit>
        <trans-unit id="3374dcf99c53848fca21b2c0a2a33600073459ee" translate="yes" xml:space="preserve">
          <source>If the system is configured to invert the delta values delivered with the event (such as natural scrolling of the touchpad on &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt;),</source>
          <target state="translated">시스템이 이벤트와 함께 제공되는 델타 값을 반전 시키도록 구성된 경우 (예 : &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; 에서 터치 패드의 자연스러운 스크롤 )</target>
        </trans-unit>
        <trans-unit id="359cdda8ff37285e758540b26dd19c1b74366d19" translate="yes" xml:space="preserve">
          <source>If the system is configured to invert the delta values delivered with the event (such as natural scrolling of the touchpad on OS X),</source>
          <target state="translated">시스템이 이벤트와 함께 제공된 델타 값을 반전 시키도록 구성된 경우 (예 : OS X에서 터치 패드의 자연스러운 스크롤)</target>
        </trans-unit>
        <trans-unit id="131c528620af1465a21e0503b42cf45c171a65e2" translate="yes" xml:space="preserve">
          <source>If the system is configured to invert the delta values delivered with the event (such as natural scrolling of the touchpad on macOS),</source>
          <target state="translated">시스템이 이벤트와 함께 제공되는 델타 값을 반전하도록 구성된 경우 (예 : macOS에서 터치 패드의 자연스러운 스크롤),</target>
        </trans-unit>
        <trans-unit id="1909ef3c6a090fb630cda5893d07bc5530d21323" translate="yes" xml:space="preserve">
          <source>If the system is unable to start the server (check with the task manager whether the server runs a process), make sure that no DLL the server depends on is missing from the system path (e.g. the Qt DLL!). Use a dependency walker to view all dependencies of the server binary.</source>
          <target state="translated">시스템이 서버를 시작할 수없는 경우 (작업 관리자가 서버가 프로세스를 실행하는지 확인) 서버가 의존하는 DLL이 시스템 경로에서 누락되지 않았는지 확인하십시오 (예 : Qt DLL!). 종속성 워커를 사용하여 서버 바이너리의 모든 종속성을보십시오.</target>
        </trans-unit>
        <trans-unit id="4baf26bd65b5810eaf64002b1e2b9d45025331da" translate="yes" xml:space="preserve">
          <source>If the system tray is currently unavailable but becomes available later, &lt;a href=&quot;qsystemtrayicon&quot;&gt;QSystemTrayIcon&lt;/a&gt; will automatically add an entry in the system tray if it is &lt;a href=&quot;qsystemtrayicon#visible-prop&quot;&gt;visible&lt;/a&gt;.</source>
          <target state="translated">시스템 트레이를 현재 사용할 수 없지만 나중에 사용할 수있게되면 &lt;a href=&quot;qsystemtrayicon&quot;&gt;QSystemTrayIcon&lt;/a&gt; 은 시스템 트레이에 항목이 &lt;a href=&quot;qsystemtrayicon#visible-prop&quot;&gt;표시&lt;/a&gt; 되면 자동으로 항목을 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="c57ed5d0f02487d9385e380a8bc49d4c1bf5017d" translate="yes" xml:space="preserve">
          <source>If the system tray is unavailable when a system tray icon is constructed, but becomes available later, &lt;a href=&quot;qsystemtrayicon&quot;&gt;QSystemTrayIcon&lt;/a&gt; will automatically add an entry for the application in the system tray if the icon is &lt;a href=&quot;qsystemtrayicon#visible-prop&quot;&gt;visible&lt;/a&gt;.</source>
          <target state="translated">시스템 트레이 아이콘을 구성 할 때 시스템 트레이를 사용할 수 없지만 나중에 사용할 수있게 되면 아이콘이 &lt;a href=&quot;qsystemtrayicon#visible-prop&quot;&gt;표시&lt;/a&gt; 되면 &lt;a href=&quot;qsystemtrayicon&quot;&gt;QSystemTrayIcon&lt;/a&gt; 이 시스템 트레이에 응용 프로그램에 대한 항목을 자동으로 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="21cc0259a0ec08c466f1a9efd0fd917f2ac2630e" translate="yes" xml:space="preserve">
          <source>If the system tray is unavailable when a system tray icon is constructed, but becomes available later, QSystemTrayIcon will automatically add an entry for the application in the system tray if the icon is &lt;a href=&quot;qsystemtrayicon#visible-prop&quot;&gt;visible&lt;/a&gt;.</source>
          <target state="translated">시스템 트레이 아이콘이 생성되었을 때 시스템 트레이를 사용할 수 없지만 나중에 사용할 수있게되면 QSystemTrayIcon은 아이콘이 &lt;a href=&quot;qsystemtrayicon#visible-prop&quot;&gt;보이면&lt;/a&gt; 시스템 트레이에 응용 프로그램 항목을 자동으로 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="8bb3a50a7281ab68badfd5e79e71f0ef03baad2e" translate="yes" xml:space="preserve">
          <source>If the system triggers an event associated to a persistent &lt;a href=&quot;qgeoareamonitorinfo&quot;&gt;QGeoAreaMonitorInfo&lt;/a&gt; the relevant application will be re-started and the appropriate signal emitted.</source>
          <target state="translated">시스템이 지속적 &lt;a href=&quot;qgeoareamonitorinfo&quot;&gt;QGeoAreaMonitorInfo&lt;/a&gt; 와 관련된 이벤트를 트리거하면 관련 응용 프로그램이 다시 시작되고 적절한 신호가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="ed7f0f0de19153e9cd4f7ffe08e9fd810648f43c" translate="yes" xml:space="preserve">
          <source>If the tab's</source>
          <target state="translated">탭이</target>
        </trans-unit>
        <trans-unit id="4ce6d6639d6251799410f93b6212d16bcf49c831" translate="yes" xml:space="preserve">
          <source>If the tablet is configured in xorg.conf to use the Wacom driver, there will be separate XInput &quot;devices&quot; for the stylus, eraser, and (optionally) cursor and touchpad. Qt recognizes these by their names. Otherwise, if the tablet is configured to use the evdev driver, there will be only one device and applications may not be able to distinguish the stylus from the eraser.</source>
          <target state="translated">태블릿이 Wacom 드라이버를 사용하도록 xorg.conf에 구성된 경우 스타일러스, 지우개 및 커서 및 터치 패드에 대해 별도의 XInput &quot;장치&quot;가 있습니다. Qt는이를 이름으로 인식합니다. 그렇지 않으면 태블릿이 evdev 드라이버를 사용하도록 구성된 경우 장치가 하나만 있고 응용 프로그램에서 스타일러스와 지우개를 구별하지 못할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c8f801a599aff795bdeba3158a3ec020a98d22d" translate="yes" xml:space="preserve">
          <source>If the target state does not assign any value to the property, there are two options: By default, the property will be assigned the value defined by the state it is leaving (the value it would have been assigned if the animation had been permitted to finish playing). If a global restore policy is set, however, this will take precedence, and the property will be restored as usual.</source>
          <target state="translated">대상 상태가 속성에 값을 할당하지 않으면 두 가지 옵션이 있습니다. 기본적으로 속성에는 떠나는 상태 (애니메이션이 허용 된 경우 할당 된 값)에 의해 정의 된 값이 할당됩니다. 재생 완료). 그러나 글로벌 복원 정책이 설정되면이 정책이 우선하며 속성이 평소대로 복원됩니다.</target>
        </trans-unit>
        <trans-unit id="f03ae15aaf4503fd23fdc6d444a0eb56e8976c35" translate="yes" xml:space="preserve">
          <source>If the target state of a transition is a sub-state of a compound state, and that compound state is the source state, an internal transition will not leave the source state.</source>
          <target state="translated">전이의 대상 상태가 복합 상태의 하위 상태이고 해당 복합 상태가 소스 상태 인 경우 내부 전이는 소스 상태를 벗어나지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d75777a9ff089890ea5dc30093de8419b005c903" translate="yes" xml:space="preserve">
          <source>If the target supports &lt;a href=&quot;qnearfieldtarget#AccessMethod-enum&quot;&gt;LlcpAccess&lt;/a&gt;, the QLlcpSocket class can be used to connected to a service provided by the target.</source>
          <target state="translated">대상이 &lt;a href=&quot;qnearfieldtarget#AccessMethod-enum&quot;&gt;LlcpAccess를&lt;/a&gt; 지원하는 경우 QLlcpSocket 클래스를 사용하여 대상이 제공 한 서비스에 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="058703a6791dd970d8babd28449f80d5b5ed435b" translate="yes" xml:space="preserve">
          <source>If the target supports &lt;a href=&quot;qnearfieldtarget#AccessMethod-enum&quot;&gt;NdefAccess&lt;/a&gt;, &lt;a href=&quot;qnearfieldtarget#hasNdefMessage&quot;&gt;hasNdefMessage&lt;/a&gt;() can be called to test if the target has a stored NDEF message, &lt;a href=&quot;qnearfieldtarget#readNdefMessages&quot;&gt;readNdefMessages&lt;/a&gt;() and &lt;a href=&quot;qnearfieldtarget#writeNdefMessages&quot;&gt;writeNdefMessages&lt;/a&gt;() functions can be used to get and set the NDEF message.</source>
          <target state="translated">대상이 지원하는 경우 &lt;a href=&quot;qnearfieldtarget#AccessMethod-enum&quot;&gt;NdefAccess&lt;/a&gt; , &lt;a href=&quot;qnearfieldtarget#hasNdefMessage&quot;&gt;hasNdefMessage을&lt;/a&gt; 타겟 저장 NDEF 메시지가있는 경우 (가) 시험이라 할 수 &lt;a href=&quot;qnearfieldtarget#readNdefMessages&quot;&gt;readNdefMessages&lt;/a&gt; () 및 &lt;a href=&quot;qnearfieldtarget#writeNdefMessages&quot;&gt;writeNdefMessages&lt;/a&gt; () 함수를 얻기 위해 사용되며, NDEF 메시지를 설정할 수있다.</target>
        </trans-unit>
        <trans-unit id="bf2c994c1b005861175e01f9e82ebeb7bf400314" translate="yes" xml:space="preserve">
          <source>If the target supports &lt;a href=&quot;qnearfieldtarget#AccessMethod-enum&quot;&gt;TagTypeSpecificAccess&lt;/a&gt;, &lt;a href=&quot;qnearfieldtarget#sendCommand&quot;&gt;sendCommand&lt;/a&gt;() can be used to send a single proprietary command to the target and retrieve the response. &lt;a href=&quot;qnearfieldtarget#sendCommands&quot;&gt;sendCommands&lt;/a&gt;() can be used to send multiple proprietary commands to the target and retrieve all of the responses.</source>
          <target state="translated">대상이 지원하는 경우 &lt;a href=&quot;qnearfieldtarget#AccessMethod-enum&quot;&gt;TagTypeSpecificAccess&lt;/a&gt; , &lt;a href=&quot;qnearfieldtarget#sendCommand&quot;&gt;인 sendCommand을&lt;/a&gt; () 타겟에 하나의 독점 명령을 보내고 응답을 검색 할 수 있습니다. &lt;a href=&quot;qnearfieldtarget#sendCommands&quot;&gt;sendCommands&lt;/a&gt; ()를 사용하여 여러 독점 명령을 대상에 보내고 모든 응답을 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba1a39851121f6710c7eb6ed3c5e8c9df30b5920" translate="yes" xml:space="preserve">
          <source>If the target understands the &lt;code&gt;LinkAction&lt;/code&gt; action, it should store its own reference to the original information; the source does not need to perform any further processing on the data. The most common use of drag and drop actions is when performing a Move within the same widget; see the section on &lt;a href=&quot;#drop-actions&quot;&gt;Drop Actions&lt;/a&gt; for more information about this feature.</source>
          <target state="translated">대상이 &lt;code&gt;LinkAction&lt;/code&gt; 조치를 이해 하면 원래 정보에 대한 자체 참조를 저장해야합니다. 소스는 데이터에 대해 추가 처리를 수행 할 필요가 없습니다. 드래그 앤 드롭 동작의 가장 일반적인 용도는 동일한 위젯 내에서 이동을 수행 할 때입니다. 이 기능에 대한 자세한 내용은 &lt;a href=&quot;#drop-actions&quot;&gt;드롭 동작&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0cbbf6056a48d7f4b574c93465c15ee55e846926" translate="yes" xml:space="preserve">
          <source>If the target understands the &lt;code&gt;LinkAction&lt;/code&gt; action, it should store its own reference to the original information; the source does not need to perform any further processing on the data. The most common use of drag and drop actions is when performing a Move within the same widget; see the section on &lt;a href=&quot;dnd#drop-actions&quot;&gt;Drop Actions&lt;/a&gt; for more information about this feature.</source>
          <target state="translated">대상이 &lt;code&gt;LinkAction&lt;/code&gt; 작업을 이해하는 경우 원래 정보에 대한 자체 참조를 저장해야합니다. 소스는 데이터에 대해 추가 처리를 수행 할 필요가 없습니다. 드래그 앤 드롭 동작의 가장 일반적인 사용은 동일한 위젯 내에서 이동을 수행 할 때입니다. 이 기능에 대한 자세한 내용은 &lt;a href=&quot;dnd#drop-actions&quot;&gt;삭제 작업&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="97ba2b49125725312c3ac04bb2670a637ba9d4a9" translate="yes" xml:space="preserve">
          <source>If the test is data-driven, each call to QSKIP() in the test function will skip only the current row of test data, so an unconditional call to QSKIP() will produce one skip message in the test log for each row of test data.</source>
          <target state="translated">테스트가 데이터 기반 인 경우 테스트 함수에서 QSKIP ()에 대한 각 호출은 테스트 데이터의 현재 행만 건너 뛰므로 QSKIP ()에 대한 무조건 호출은 테스트의 각 행에 대해 테스트 로그에 하나의 건너 뛰기 메시지를 생성합니다. 데이터.</target>
        </trans-unit>
        <trans-unit id="e321050075273264c740adedae0b35908a1fa8ff" translate="yes" xml:space="preserve">
          <source>If the test is data-driven, each call to QSKIP() will skip only the current row of test data, so an unconditional call to QSKIP will produce one skip message in the test log for each row of test data.</source>
          <target state="translated">테스트가 데이터 중심 인 경우 QSKIP ()에 대한 각 호출은 현재 테스트 데이터 행만 건너 뛰므로 QSKIP에 대한 무조건 호출은 테스트 데이터의 각 행에 대해 테스트 로그에 하나의 건너 뛰기 메시지를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="8e46e321cd6819be4544b652b2c7df8551b35c3c" translate="yes" xml:space="preserve">
          <source>If the test is not data-driven, then</source>
          <target state="translated">테스트가 데이터 중심이 아닌 경우</target>
        </trans-unit>
        <trans-unit id="a829a50f58b94cec176d3a85c54c24a344e86135" translate="yes" xml:space="preserve">
          <source>If the test project is built successfully, the test passes.</source>
          <target state="translated">테스트 프로젝트가 성공적으로 빌드되면 테스트에 통과합니다.</target>
        </trans-unit>
        <trans-unit id="ac2b86976673d35bb3a21d47ed726dbb10ac3919" translate="yes" xml:space="preserve">
          <source>If the text contains an ampersand character ('&amp;amp;'), a shortcut is automatically created for it. The character that follows the '&amp;amp;' will be used as the shortcut key. Any previous shortcut will be overwritten or cleared if no shortcut is defined by the text. See the &lt;a href=&quot;qshortcut#mnemonic&quot;&gt;QShortcut&lt;/a&gt; documentation for details. To display an actual ampersand, use '&amp;amp;&amp;amp;'.</source>
          <target state="translated">텍스트에 앰퍼샌드 문자 ( '&amp;amp;')가 있으면 바로 가기가 자동으로 만들어집니다. '&amp;amp;'뒤에 나오는 문자가 바로 가기 키로 사용됩니다. 텍스트로 정의 된 단축키가 없으면 이전 단축키를 덮어 쓰거나 지 웁니다. 자세한 내용은 &lt;a href=&quot;qshortcut#mnemonic&quot;&gt;QShortcut&lt;/a&gt; 설명서를 참조하십시오. 실제 앰퍼샌드를 표시하려면 '&amp;amp;&amp;amp;'를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="fe3c05618cfcca54171282394499c3f6a0c20bae" translate="yes" xml:space="preserve">
          <source>If the text does not fit within the item bounds with the minimum font size the text will be elided as per the &lt;a href=&quot;qml-qtquick-text#elide-prop&quot;&gt;elide&lt;/a&gt; property.</source>
          <target state="translated">텍스트가 최소 글꼴 크기로 항목 범위 내에 맞지 않으면 &lt;a href=&quot;qml-qtquick-text#elide-prop&quot;&gt;elide&lt;/a&gt; 속성에 따라 텍스트가 제거됩니다 .</target>
        </trans-unit>
        <trans-unit id="4c101296efd451960fda80c72a54fcca9231cb7e" translate="yes" xml:space="preserve">
          <source>If the text edit has another content type, it will not be replaced by plain text if you call &lt;a href=&quot;qtextedit#toPlainText&quot;&gt;toPlainText&lt;/a&gt;(). The only exception to this is the non-break space,</source>
          <target state="translated">텍스트 편집에 다른 내용 유형이있는 경우 &lt;a href=&quot;qtextedit#toPlainText&quot;&gt;toPlainText&lt;/a&gt; () 를 호출하면 일반 텍스트로 대체되지 않습니다 . 이것에 대한 유일한 예외는 비 휴식 공간입니다.</target>
        </trans-unit>
        <trans-unit id="10c2e90537c90f5a977b7bddd8c1a39474ea21dd" translate="yes" xml:space="preserve">
          <source>If the text format is &lt;code&gt;Text.AutoText&lt;/code&gt; the Text item will automatically determine whether the text should be treated as styled text. This determination is made using &lt;a href=&quot;qt-sub-qtgui#mightBeRichText&quot;&gt;Qt::mightBeRichText()&lt;/a&gt; which uses a fast and therefore simple heuristic. It mainly checks whether there is something that looks like a tag before the first line break. Although the result may be correct for common cases, there is no guarantee.</source>
          <target state="translated">텍스트 형식이 &lt;code&gt;Text.AutoText&lt;/code&gt; 인 경우 텍스트 항목은 텍스트를 스타일있는 텍스트로 취급해야하는지 여부를 자동으로 결정합니다. 이 결정은 빠르고 간단한 휴리스틱을 사용하는 &lt;a href=&quot;qt-sub-qtgui#mightBeRichText&quot;&gt;Qt :: mightBeRichText ()&lt;/a&gt; 를 사용 하여 이루어집니다 . 주로 첫 줄 바꿈 전에 태그처럼 보이는 것이 있는지 확인합니다. 일반적인 경우 결과가 정확할 수도 있지만 보장 할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="1d12c5f988f0fc93dcbf2b83a7449011d81686dc" translate="yes" xml:space="preserve">
          <source>If the text format is &lt;code&gt;Text.AutoText&lt;/code&gt; the Text item will automatically determine whether the text should be treated as styled text. This determination is made using &lt;a href=&quot;qt-sub-qtgui#mightBeRichText&quot;&gt;Qt::mightBeRichText()&lt;/a&gt;, which can detect the presence of an HTML tag on the first line of text, but cannot distinguish Markdown from plain text.</source>
          <target state="translated">텍스트 형식이 &lt;code&gt;Text.AutoText&lt;/code&gt; 이면 텍스트 항목은 텍스트를 스타일이 지정된 텍스트로 처리할지 여부를 자동으로 결정합니다. 이 결정은 &lt;a href=&quot;qt-sub-qtgui#mightBeRichText&quot;&gt;Qt :: mightBeRichText ()를&lt;/a&gt; 사용하여 이루어지며 , 텍스트의 첫 번째 줄에 HTML 태그가 있는지 감지 할 수 있지만 Markdown과 일반 텍스트를 구분할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="99c161e309d0298bd97079c743c8f0d6987cd9b3" translate="yes" xml:space="preserve">
          <source>If the text is a multi-length string, and the mode is not &lt;code&gt;Text.ElideNone&lt;/code&gt;, the first string that fits will be used, otherwise the last will be elided.</source>
          <target state="translated">텍스트가 다중 길이 문자열이고 모드가 &lt;code&gt;Text.ElideNone&lt;/code&gt; 이 아닌 경우 맞는 첫 번째 문자열이 사용되며 그렇지 않으면 마지막 문자열이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="9496b2bb0957544a91fafa47c58321502a6a32e5" translate="yes" xml:space="preserve">
          <source>If the text is localized, consider the influence of a longer text on the layout.</source>
          <target state="translated">텍스트가 현지화 된 경우 더 긴 텍스트가 레이아웃에 미치는 영향을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="74f04f67ad3dc76de0e29e3f296b378f74a5a1f9" translate="yes" xml:space="preserve">
          <source>If the text is too long, it is truncated at the limit.</source>
          <target state="translated">텍스트가 너무 길면 한도에서 잘립니다.</target>
        </trans-unit>
        <trans-unit id="14f08d40e6ec8ce2b4292942cf1ae10f3f6573a1" translate="yes" xml:space="preserve">
          <source>If the text to be rendered in the code font contains spaces, enclose the entire text in curly brackets.</source>
          <target state="translated">코드 글꼴로 렌더링 할 텍스트에 공백이 있으면 전체 텍스트를 중괄호로 묶습니다.</target>
        </trans-unit>
        <trans-unit id="0857dc7f7e6bc236f5d692968965505e07711d8e" translate="yes" xml:space="preserve">
          <source>If the text width is set to -1 then the text will not be broken into multiple lines unless it is enforced through an explicit line break or a new paragraph.</source>
          <target state="translated">텍스트 너비가 -1로 설정되어 있으면 명시적인 줄 바꿈이나 새 단락을 통해 적용되지 않는 한 텍스트가 여러 줄로 분리되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6f3e6bdea774a793f38b8ca23bac4abb5cf6b000" translate="yes" xml:space="preserve">
          <source>If the texture does not have mipmapping support, enabling mipmapping has no effect.</source>
          <target state="translated">텍스처에 밉 매핑이 지원되지 않으면 밉 매핑을 활성화해도 아무런 영향이 없습니다.</target>
        </trans-unit>
        <trans-unit id="54c89ed52fe8f4f49f4986306622145346e5d5a3" translate="yes" xml:space="preserve">
          <source>If the texture format is not indexed, this array is not used and can be empty.</source>
          <target state="translated">텍스처 형식이 인덱스되지 않은 경우이 배열은 사용되지 않으며 비어있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="83c0cd9687e57bc32daee851bae56b60e33ef582" translate="yes" xml:space="preserve">
          <source>If the texture is not part of a texture atlas, this function returns 0.</source>
          <target state="translated">텍스처가 텍스처 아틀라스의 일부가 아닌 경우이 함수는 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="564b8bd8767ee90c13b1487acfbc771697d63847" translate="yes" xml:space="preserve">
          <source>If the texture is not part of a texture atlas, this function returns &lt;code&gt;nullptr&lt;/code&gt;.</source>
          <target state="translated">텍스처가 텍스처 아틀라스의 일부가 아닌 경우이 함수는 &lt;code&gt;nullptr&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="384c3b873ee3e44706687e200c3575ba28d395ab" translate="yes" xml:space="preserve">
          <source>If the texture is used in such a way that atlas is not preferable, the function &lt;a href=&quot;qsgtexture#removedFromAtlas&quot;&gt;removedFromAtlas&lt;/a&gt;() can be used to extract a non-atlassed copy.</source>
          <target state="translated">텍스처가 아틀라스 바람직하지 않다 것과 같은 방식으로 사용되는 경우, 기능 &lt;a href=&quot;qsgtexture#removedFromAtlas&quot;&gt;removedFromAtlas은&lt;/a&gt; ()이 아닌 atlassed 복사본을 추출 할 수있다.</target>
        </trans-unit>
        <trans-unit id="99f225b863f2c94a93a7f22fe3369e3f146fa59e" translate="yes" xml:space="preserve">
          <source>If the texture target does not support mipmaps this function has no effect.</source>
          <target state="translated">텍스처 대상이 밉맵을 지원하지 않으면이 기능은 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="4857855596b2e6afff1dffa92b7bed78a1d3e0ee" translate="yes" xml:space="preserve">
          <source>If the texture was set as a &lt;a href=&quot;qpixmap&quot;&gt;QPixmap&lt;/a&gt; it will be converted to a &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt;.</source>
          <target state="translated">텍스처가 &lt;a href=&quot;qpixmap&quot;&gt;QPixmap&lt;/a&gt; 으로 설정된 경우 &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt; 로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="5f0b57bacd853c107997bb11beb415914b4fc70f" translate="yes" xml:space="preserve">
          <source>If the time could not be parsed, returns an invalid time.</source>
          <target state="translated">시간을 구문 분석 할 수 없으면 유효하지 않은 시간을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="22b5e941c5d47ffa0e2d44a52570df2dd22321a1" translate="yes" xml:space="preserve">
          <source>If the time is invalid, an empty string will be returned.</source>
          <target state="translated">시간이 유효하지 않으면 빈 문자열이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="7dcb556f04637c55595b4df3b5ada582ec13ca35" translate="yes" xml:space="preserve">
          <source>If the time is invalid, an empty string will be returned. If</source>
          <target state="translated">시간이 유효하지 않으면 빈 문자열이 반환됩니다. 만약</target>
        </trans-unit>
        <trans-unit id="a32d1d7d55aa700aececb2f8f544e719d45a9457" translate="yes" xml:space="preserve">
          <source>If the timeout is zero, the timeout defaults to a reasonable timeout period as appropriate for the source.</source>
          <target state="translated">시간 초과가 0이면 시간 초과의 기본값은 소스에 적합한 적당한 시간 초과 기간입니다.</target>
        </trans-unit>
        <trans-unit id="bf85241d3535759a4bd42c49eff30b2836b4945d" translate="yes" xml:space="preserve">
          <source>If the timer is already running, calling this method has no effect. The &lt;code&gt;running&lt;/code&gt; property will be true following a call to &lt;code&gt;start()&lt;/code&gt;.</source>
          <target state="translated">타이머가 이미 실행중인 경우이 메서드를 호출해도 아무런 영향이 없습니다. &lt;code&gt;running&lt;/code&gt; 속성에 대한 호출 다음 중 하나에 해당 될 것입니다 &lt;code&gt;start()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="24dd83b8835f51bc566b616e4dffd5d48ce2cae9" translate="yes" xml:space="preserve">
          <source>If the timer is already running, it will be &lt;a href=&quot;qtimer#stop&quot;&gt;stopped&lt;/a&gt; and restarted.</source>
          <target state="translated">타이머가 이미 실행중인 경우 &lt;a href=&quot;qtimer#stop&quot;&gt;중지&lt;/a&gt; 되고 다시 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="389190f0adcd176c7221636aa908a07067a60a08" translate="yes" xml:space="preserve">
          <source>If the timer is not running, calling this method has no effect. The &lt;code&gt;running&lt;/code&gt; property will be false following a call to &lt;code&gt;stop()&lt;/code&gt;.</source>
          <target state="translated">타이머가 실행되고 있지 않으면이 메서드를 호출해도 아무런 영향이 없습니다. &lt;code&gt;running&lt;/code&gt; 속성을 호출 다음과 같은 잘못된 것 &lt;code&gt;stop()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b3c6083206d41865463a30dda5e1d0714f9bcd95" translate="yes" xml:space="preserve">
          <source>If the top or bottom edges of both geo rectangles are at one of the poles the geo rectangles are considered to be intersecting, since the longitude is irrelevant when the edges are at the pole.</source>
          <target state="translated">두 지리적 사각형의 위쪽 또는 아래쪽 가장자리가 극 중 하나에 있으면 가장자리가 극에있을 때 경도가 관련이 없으므로 지리적 사각형이 교차하는 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="e7d310e1ccaed74b1d0147d7daede69cfac75c0e" translate="yes" xml:space="preserve">
          <source>If the total number of pages changed, the &lt;a href=&quot;qabstracttextdocumentlayout#pageCountChanged&quot;&gt;pageCountChanged&lt;/a&gt;() signal should be emitted.</source>
          <target state="translated">총 페이지 수가 변경된 경우 &lt;a href=&quot;qabstracttextdocumentlayout#pageCountChanged&quot;&gt;pageCountChanged&lt;/a&gt; () 신호가 발생해야합니다.</target>
        </trans-unit>
        <trans-unit id="19d2dc545dd8c0fa92dc679ee42336756224e9bd" translate="yes" xml:space="preserve">
          <source>If the total size changed, the &lt;a href=&quot;qabstracttextdocumentlayout#documentSizeChanged&quot;&gt;documentSizeChanged&lt;/a&gt;() signal should be emitted.</source>
          <target state="translated">전체 크기가 변경된 경우 &lt;a href=&quot;qabstracttextdocumentlayout#documentSizeChanged&quot;&gt;documentSizeChanged&lt;/a&gt; () 신호가 방출되어야합니다.</target>
        </trans-unit>
        <trans-unit id="e862e3579b258189d6873d6478f1ee6db4ffb491" translate="yes" xml:space="preserve">
          <source>If the total width of the buttons exceeds the available width of the tab bar, it automatically becomes flickable.</source>
          <target state="translated">버튼의 총 너비가 탭 막대의 사용 가능한 너비를 초과하면 자동으로 깜박일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bde4d10d3fe11fe7c6acafd5a2e9b673d40e7eb8" translate="yes" xml:space="preserve">
          <source>If the transaction is not finalized, the onPurchaseSucceeded handler will be called again the next time the product is registered (on application startup.) This means that if saving the information failed, the user will have the opportunity of rectifying the problem (for example by deleting something else to make space for the data) and the transaction will be completed once they restart the application and the problem has been solved.</source>
          <target state="translated">트랜잭션이 완료되지 않은 경우 다음에 제품을 등록 할 때 (애플리케이션 시작시) onPurchaseSucceeded 핸들러가 다시 호출됩니다. 즉, 정보 저장에 실패하면 사용자는 문제를 해결할 수 있습니다 (예 : 데이터를위한 공간을 확보하기 위해 다른 것을 삭제)) 애플리케이션이 다시 시작되고 문제가 해결되면 트랜잭션이 완료됩니다.</target>
        </trans-unit>
        <trans-unit id="34a981dd092b6d8e42bbf0be90d49450009d5ab2" translate="yes" xml:space="preserve">
          <source>If the transition did not set the &lt;code&gt;to&lt;/code&gt; and &lt;code&gt;reversible&lt;/code&gt; values, then on the mouse release, the transition would play the &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtquick-animation-example.html#propertyanimation&quot;&gt;PropertyAnimation&lt;/a&gt; before the &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtquick-animation-example.html#coloranimation&quot;&gt;ColorAnimation&lt;/a&gt; instead of reversing the sequence.</source>
          <target state="translated">전환이 &lt;code&gt;to&lt;/code&gt; 및 &lt;code&gt;reversible&lt;/code&gt; 값 을 설정하지 않은 경우 마우스를 놓으면 전환이 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtquick-animation-example.html#coloranimation&quot;&gt;ColorAnimation&lt;/a&gt; 이전에 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtquick-animation-example.html#propertyanimation&quot;&gt;PropertyAnimation을&lt;/a&gt; 재생합니다. 시퀀스를 반전하는 대신 .</target>
        </trans-unit>
        <trans-unit id="02d76564ea31bbbac61a527414ffb0386c6d56b1" translate="yes" xml:space="preserve">
          <source>If the transition did not set the &lt;code&gt;to&lt;/code&gt; and &lt;code&gt;reversible&lt;/code&gt; values, then on the mouse release, the transition would play the &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtquick-animation-example.html#propertyanimation&quot;&gt;PropertyAnimation&lt;/a&gt; before the &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtquick-animation-example.html#coloranimation&quot;&gt;ColorAnimation&lt;/a&gt; instead of reversing the sequence.</source>
          <target state="translated">전환이 &lt;code&gt;to&lt;/code&gt; 및 &lt;code&gt;reversible&lt;/code&gt; 값 을 설정하지 않은 경우 마우스를 놓으면 전환이 시퀀스를 반전하는 대신 &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtquick-animation-example.html#coloranimation&quot;&gt;ColorAnimation&lt;/a&gt; 전에 &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtquick-animation-example.html#propertyanimation&quot;&gt;PropertyAnimation을&lt;/a&gt; 재생합니다 .</target>
        </trans-unit>
        <trans-unit id="77300d60f58012a6bd67f277f24427b1701a5374" translate="yes" xml:space="preserve">
          <source>If the transition was changed to this:</source>
          <target state="translated">전환이 다음과 같이 변경된 경우 :</target>
        </trans-unit>
        <trans-unit id="f04c2ee8bc5a7f7803a57a1521b71a8d864f2074" translate="yes" xml:space="preserve">
          <source>If the translation would have caused the geo rectangle to cross a pole the geo rectangle will be translated until the top or bottom edge of the geo rectangle touches the pole but not further.</source>
          <target state="translated">변환으로 인해 지오 사각형이 극점을 교차하게되면 지오 사각형의 위쪽 또는 아래쪽 가장자리가 극점에 닿을 때까지 지오 사각형이 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="fdbbbd7873e80f58d6be259280a967d1fd9ca661" translate="yes" xml:space="preserve">
          <source>If the tuner is set to a frequency outside the current &lt;a href=&quot;qradiotuner#band-prop&quot;&gt;band&lt;/a&gt;, the band will be changed to one occupied by the new frequency.</source>
          <target state="translated">튜너가 현재 &lt;a href=&quot;qradiotuner#band-prop&quot;&gt;대역&lt;/a&gt; 외부의 주파수로 설정된 경우 되면 밴드는 새로운 주파수가 차지하는 주파수로 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="b75be82b0daaec9b81a270a6e929ce9709fc1b55" translate="yes" xml:space="preserve">
          <source>If the two URLs were used via HTTP GET, the interpretation by the web server would probably be different. In the first case, it would interpret as one parameter, with a key of &quot;q&quot; and value &quot;a+=b&amp;amp;c&quot;. In the second case, it would probably interpret as two parameters, one with a key of &quot;q&quot; and value &quot;a =b&quot;, and the second with a key &quot;c&quot; and no value.</source>
          <target state="translated">두 URL이 HTTP GET을 통해 사용 된 경우 웹 서버의 해석이 다를 수 있습니다. 첫 번째 경우에는 키가 &quot;q&quot;이고 값이 &quot;a + = b &amp;amp; c&quot;인 하나의 매개 변수로 해석됩니다. 두 번째 경우에는 아마도 &quot;q&quot;키와 &quot;a = b&quot;값을 가진 두 개의 매개 변수로, 두 번째 매개 변수는 키 &quot;c&quot;를 갖고 값이없는 것으로 해석 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="88407959405c40025ba4e53835b8a998fdc1b955" translate="yes" xml:space="preserve">
          <source>If the type &lt;code&gt;T&lt;/code&gt; is supported by &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt;, this function behaves exactly as &lt;a href=&quot;qvariant#toString&quot;&gt;toString&lt;/a&gt;(), &lt;a href=&quot;qvariant#toInt&quot;&gt;toInt&lt;/a&gt;() etc.</source>
          <target state="translated">유형 &lt;code&gt;T&lt;/code&gt; 가 &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; 에서 지원되는 경우이 함수는 &lt;a href=&quot;qvariant#toString&quot;&gt;toString&lt;/a&gt; (), &lt;a href=&quot;qvariant#toInt&quot;&gt;toInt&lt;/a&gt; 와 동일하게 작동합니다. () 등의 .</target>
        </trans-unit>
        <trans-unit id="2e502f2c31df852b97313782ada9ce53643b4d88" translate="yes" xml:space="preserve">
          <source>If the type is a &lt;a href=&quot;qobject#Q_GADGET&quot;&gt;Q_GADGET&lt;/a&gt;, &lt;a href=&quot;qmetatype#flags&quot;&gt;flags&lt;/a&gt;() contains &lt;a href=&quot;qmetatype#TypeFlag-enum&quot;&gt;QMetaType::IsGadget&lt;/a&gt;, and this function returns its &lt;a href=&quot;qmetaobject&quot;&gt;QMetaObject&lt;/a&gt;. This can be used to retrieve &lt;a href=&quot;qmetamethod&quot;&gt;QMetaMethod&lt;/a&gt; and &lt;a href=&quot;qmetaproperty&quot;&gt;QMetaProperty&lt;/a&gt; and use them on a pointer of this type. (given by QVariant::data for example)</source>
          <target state="translated">유형이 &lt;a href=&quot;qobject#Q_GADGET&quot;&gt;Q_GADGET 인&lt;/a&gt; 경우 &lt;a href=&quot;qmetatype#flags&quot;&gt;flags&lt;/a&gt; ()에 &lt;a href=&quot;qmetatype#TypeFlag-enum&quot;&gt;QMetaType :: IsGadget&lt;/a&gt; 이 포함 되며이 함수는 &lt;a href=&quot;qmetaobject&quot;&gt;QMetaObject를&lt;/a&gt; 반환합니다 . &lt;a href=&quot;qmetamethod&quot;&gt;QMetaMethod&lt;/a&gt; 및 &lt;a href=&quot;qmetaproperty&quot;&gt;QMetaProperty&lt;/a&gt; 를 검색 하여이 유형의 포인터에서 사용할 수 있습니다. (예를 들어 QVariant :: data에서 제공)</target>
        </trans-unit>
        <trans-unit id="eec0855a3850e83475bc4ba7d4dac07bf2f66f0d" translate="yes" xml:space="preserve">
          <source>If the type is a pointer type to a subclass of &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;, &lt;a href=&quot;qmetatype#flags&quot;&gt;flags&lt;/a&gt;() contains &lt;a href=&quot;qmetatype#TypeFlag-enum&quot;&gt;QMetaType::PointerToQObject&lt;/a&gt; and this function returns the corresponding &lt;a href=&quot;qmetaobject&quot;&gt;QMetaObject&lt;/a&gt;. This can be used to in combinaison with QMetaObject::construct to create &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; of this type.</source>
          <target state="translated">유형이 &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 의 서브 클래스에 대한 포인터 유형 인 경우 , &lt;a href=&quot;qmetatype#flags&quot;&gt;flags&lt;/a&gt; ()는 &lt;a href=&quot;qmetatype#TypeFlag-enum&quot;&gt;QMetaType :: PointerToQObject를&lt;/a&gt; 포함 하며이 함수는 해당 &lt;a href=&quot;qmetaobject&quot;&gt;QMetaObject를&lt;/a&gt; 리턴합니다 . QMetaObject :: construct와 결합 하여이 유형의 &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 를 작성하는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9642ffd8df779bc6a0afe0794bd6f0b0cea8b7e2" translate="yes" xml:space="preserve">
          <source>If the type is an enumeration, &lt;a href=&quot;qmetatype#flags&quot;&gt;flags&lt;/a&gt;() contains &lt;a href=&quot;qmetatype#TypeFlag-enum&quot;&gt;QMetaType::IsEnumeration&lt;/a&gt;, and this function returns the &lt;a href=&quot;qmetaobject&quot;&gt;QMetaObject&lt;/a&gt; of the enclosing object if the enum was registered as a &lt;a href=&quot;qobject#Q_ENUM&quot;&gt;Q_ENUM&lt;/a&gt; or &lt;code&gt;nullptr&lt;/code&gt; otherwise</source>
          <target state="translated">유형이 열거 인 경우 &lt;a href=&quot;qmetatype#flags&quot;&gt;플래그&lt;/a&gt; ()를 포함 &lt;a href=&quot;qmetatype#TypeFlag-enum&quot;&gt;QMetaType :: IsEnumeration는&lt;/a&gt; ,이 함수가 반환 &lt;a href=&quot;qmetaobject&quot;&gt;QMetaObject&lt;/a&gt; 둘러싸는 객체가 열거는로 등록 된 경우 &lt;a href=&quot;qobject#Q_ENUM&quot;&gt;Q_ENUM&lt;/a&gt; 또는 &lt;code&gt;nullptr&lt;/code&gt; 그렇지 않으면</target>
        </trans-unit>
        <trans-unit id="b8157478bb90be533a52000f495acddf101fcda7" translate="yes" xml:space="preserve">
          <source>If the type is not known the return &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; is empty.</source>
          <target state="translated">유형을 알 수 없으면 리턴 &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; 가 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="5dadab1ceac676e5185a487ea6f2219016894ddc" translate="yes" xml:space="preserve">
          <source>If the type is omitted in QML, then you must specify &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; as type with &lt;a href=&quot;qmetaobject#Q_RETURN_ARG&quot;&gt;Q_RETURN_ARG&lt;/a&gt;() and &lt;a href=&quot;qmetaobject#Q_ARG&quot;&gt;Q_ARG&lt;/a&gt;() when calling &lt;a href=&quot;qmetaobject#invokeMethod&quot;&gt;QMetaObject::invokeMethod&lt;/a&gt;.</source>
          <target state="translated">QML에서 유형이 생략 된 경우 &lt;a href=&quot;qmetaobject#invokeMethod&quot;&gt;QMetaObject :: invokeMethod를&lt;/a&gt; 호출 할 때 &lt;a href=&quot;qmetaobject#Q_RETURN_ARG&quot;&gt;Q_RETURN_ARG&lt;/a&gt; () 및 &lt;a href=&quot;qmetaobject#Q_ARG&quot;&gt;Q_ARG&lt;/a&gt; ()를 사용하여 &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; 를 유형으로 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="12030b52c2c88b4059b9287027b19b7fc12b2888" translate="yes" xml:space="preserve">
          <source>If the type of the data at the modified role does not match the type of the data that is set, it will be automatically converted via &lt;a href=&quot;qvariant#canConvert-1&quot;&gt;QVariant&lt;/a&gt;.</source>
          <target state="translated">수정 된 역할의 데이터 유형이 설정된 데이터 유형과 일치하지 않으면 &lt;a href=&quot;qvariant#canConvert-1&quot;&gt;QVariant&lt;/a&gt; 를 통해 자동으로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="889f8d60af93ae32fedd0393b8817340cf15fd13" translate="yes" xml:space="preserve">
          <source>If the type of the variable binding changes (e.g., if a previous binding by the same name was a &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt;, or if there was no previous binding), &lt;a href=&quot;qxmlquery#isValid&quot;&gt;isValid&lt;/a&gt;() will return &lt;code&gt;false&lt;/code&gt;, and recompilation of the query text is required. To recompile the query, call &lt;a href=&quot;qxmlquery#setQuery&quot;&gt;setQuery&lt;/a&gt;(). For this reason, &lt;a href=&quot;qxmlquery#bindVariable&quot;&gt;bindVariable&lt;/a&gt;() should be called before &lt;a href=&quot;qxmlquery#setQuery&quot;&gt;setQuery&lt;/a&gt;(), if possible.</source>
          <target state="translated">변수 바인딩의 유형이 변경되면 (예 : 동일한 이름의 이전 바인딩이 &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; 이거나 이전 바인딩이없는 경우) &lt;a href=&quot;qxmlquery#isValid&quot;&gt;isValid&lt;/a&gt; ()는 &lt;code&gt;false&lt;/code&gt; 를 반환 하고 쿼리 텍스트를 다시 컴파일해야합니다. 쿼리를 다시 컴파일하려면 &lt;a href=&quot;qxmlquery#setQuery&quot;&gt;setQuery&lt;/a&gt; ()를 호출하십시오 . 따라서 &lt;a href=&quot;qxmlquery#setQuery&quot;&gt;setQuery&lt;/a&gt; 전에 &lt;a href=&quot;qxmlquery#bindVariable&quot;&gt;bindVariable&lt;/a&gt; ()을 호출해야합니다. 가능하면 ().</target>
        </trans-unit>
        <trans-unit id="e87ed8204b8bc1320f9424a52e8cbd0a1bd9c0f2" translate="yes" xml:space="preserve">
          <source>If the type of the variable binding changes (e.g., if a previous binding by the same name was a &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt;, or if there was no previous binding), &lt;a href=&quot;qxmlquery#isValid&quot;&gt;isValid&lt;/a&gt;() will return &lt;code&gt;false&lt;/code&gt;, and recompilation of the query text is required. To recompile the query, call &lt;a href=&quot;qxmlquery#setQuery&quot;&gt;setQuery&lt;/a&gt;(). For this reason, bindVariable() should be called before &lt;a href=&quot;qxmlquery#setQuery&quot;&gt;setQuery&lt;/a&gt;(), if possible.</source>
          <target state="translated">변수 바인딩의 유형이 변경되면 (예 : 동일한 이름의 이전 바인딩이 &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; 이거나 이전 바인딩이없는 경우) &lt;a href=&quot;qxmlquery#isValid&quot;&gt;isValid&lt;/a&gt; ()는 &lt;code&gt;false&lt;/code&gt; 를 반환 하고 쿼리 텍스트를 다시 컴파일해야합니다. 쿼리를 다시 컴파일하려면 &lt;a href=&quot;qxmlquery#setQuery&quot;&gt;setQuery&lt;/a&gt; ()를 호출 합니다. 따라서 가능한 경우 &lt;a href=&quot;qxmlquery#setQuery&quot;&gt;setQuery&lt;/a&gt; () 전에 bindVariable ()을 호출해야 합니다.</target>
        </trans-unit>
        <trans-unit id="0b926e22c5143fec4df51baf4876fcb4f7133aae" translate="yes" xml:space="preserve">
          <source>If the type of this &lt;a href=&quot;qjsvalue&quot;&gt;QJSValue&lt;/a&gt; is different from the type of the</source>
          <target state="translated">이 &lt;a href=&quot;qjsvalue&quot;&gt;QJSValue&lt;/a&gt; 의 유형이</target>
        </trans-unit>
        <trans-unit id="88b487c56a8dbec5929e97b520b7653cc4408274" translate="yes" xml:space="preserve">
          <source>If the type you want to demarshall is a &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt;, &lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt; or any of the Qt's &lt;a href=&quot;https://doc.qt.io/qt-5.13/topics-core.html#container-classes&quot;&gt;Container Classes&lt;/a&gt; that take one template parameter, you need not declare an &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; function for it, since Qt D-Bus provides generic templates to do the job of demarshalling the data. The same applies for STL's sequence containers, such as &lt;code&gt;std::list&lt;/code&gt;, &lt;code&gt;std::vector&lt;/code&gt;, etc.</source>
          <target state="translated">비 정렬 화하려는 유형이 &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt; , &lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt; 또는 하나의 템플리트 매개 변수를 취하는 Qt의 &lt;a href=&quot;https://doc.qt.io/qt-5.13/topics-core.html#container-classes&quot;&gt;컨테이너 클래스 인&lt;/a&gt; 경우 Qt D-Bus는 작업을 수행하기위한 일반 템플리트를 제공하므로 &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; 함수를 선언 할 필요가 없습니다. 데이터를 비 정렬 화합니다. &lt;code&gt;std::list&lt;/code&gt; , &lt;code&gt;std::vector&lt;/code&gt; 와 같은 STL의 시퀀스 컨테이너에도 동일하게 적용됩니다. .</target>
        </trans-unit>
        <trans-unit id="e0ab96ae955e1e2b7ac1b95661ba909ca6edb87c" translate="yes" xml:space="preserve">
          <source>If the type you want to demarshall is a &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt;, &lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt; or any of the Qt's &lt;a href=&quot;https://doc.qt.io/qt-5.15/topics-core.html#container-classes&quot;&gt;Container Classes&lt;/a&gt; that take one template parameter, you need not declare an &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; function for it, since Qt D-Bus provides generic templates to do the job of demarshalling the data. The same applies for STL's sequence containers, such as &lt;code&gt;std::list&lt;/code&gt;, &lt;code&gt;std::vector&lt;/code&gt;, etc.</source>
          <target state="translated">디 마샬링하려는 유형이 &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt; , &lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt; 또는 하나의 템플릿 매개 변수 를 사용하는 Qt의 &lt;a href=&quot;https://doc.qt.io/qt-5.15/topics-core.html#container-classes&quot;&gt;컨테이너 클래스 인&lt;/a&gt; 경우, Qt D-Bus가 작업을 수행하는 일반 템플릿을 제공하므로 이에 대한 &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; 함수를 선언 할 필요가 없습니다. 데이터를 역 마샬링합니다. &lt;code&gt;std::list&lt;/code&gt; , &lt;code&gt;std::vector&lt;/code&gt; 등과 같은 STL의 시퀀스 컨테이너에도 동일하게 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="64618ad835571eede403966fd801c67f228f8d65" translate="yes" xml:space="preserve">
          <source>If the type you want to demarshall is a &lt;a href=&quot;qmap&quot;&gt;QMap&lt;/a&gt; or &lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt;, you need not declare an &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; function for it, since Qt D-Bus provides generic templates to do the job of demarshalling the data.</source>
          <target state="translated">비 정렬 화하려는 유형이 &lt;a href=&quot;qmap&quot;&gt;QMap&lt;/a&gt; 또는 &lt;a href=&quot;qhash#qhash&quot;&gt;QHash 인&lt;/a&gt; 경우 Qt D-Bus는 데이터를 비 정렬 화하는 작업을 수행하기위한 일반 템플리트를 제공하므로 &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; 함수를 선언 할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="a523ad06073783884c7f67c85b4cef24948fcd75" translate="yes" xml:space="preserve">
          <source>If the type you want to marshall is a &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt;, &lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt; or any of the Qt's &lt;a href=&quot;https://doc.qt.io/qt-5.13/topics-core.html#container-classes&quot;&gt;Container Classes&lt;/a&gt; that take one template parameter, you need not declare an &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; function for it, since Qt D-Bus provides generic templates to do the job of marshalling the data. The same applies for STL's sequence containers, such as &lt;code&gt;std::list&lt;/code&gt;, &lt;code&gt;std::vector&lt;/code&gt;, etc.</source>
          <target state="translated">마샬링하려는 유형 이 하나의 템플릿 매개 변수를 사용 하는 &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt; , &lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt; 또는 Qt의 &lt;a href=&quot;https://doc.qt.io/qt-5.13/topics-core.html#container-classes&quot;&gt;컨테이너 클래스 인&lt;/a&gt; 경우 Qt D-Bus는 작업을 수행하기 위해 일반 템플릿을 제공하므로 &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; 함수를 선언 할 필요가 없습니다. 데이터 마샬링 &lt;code&gt;std::list&lt;/code&gt; , &lt;code&gt;std::vector&lt;/code&gt; 등과 같은 STL의 시퀀스 컨테이너에도 동일하게 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="9d2c61ecd36391af08869293c91ae158ca98c5a6" translate="yes" xml:space="preserve">
          <source>If the type you want to marshall is a &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt;, &lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt; or any of the Qt's &lt;a href=&quot;https://doc.qt.io/qt-5.15/topics-core.html#container-classes&quot;&gt;Container Classes&lt;/a&gt; that take one template parameter, you need not declare an &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; function for it, since Qt D-Bus provides generic templates to do the job of marshalling the data. The same applies for STL's sequence containers, such as &lt;code&gt;std::list&lt;/code&gt;, &lt;code&gt;std::vector&lt;/code&gt;, etc.</source>
          <target state="translated">마샬링하려는 유형이 &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt; , &lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt; 또는 하나의 템플릿 매개 변수 를 사용하는 Qt의 &lt;a href=&quot;https://doc.qt.io/qt-5.15/topics-core.html#container-classes&quot;&gt;컨테이너 클래스 인&lt;/a&gt; 경우, Qt D-Bus가 작업을 수행하기위한 일반 템플릿을 제공하기 때문에 &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; 함수를 선언 할 필요가 없습니다. 데이터 마샬링. &lt;code&gt;std::list&lt;/code&gt; , &lt;code&gt;std::vector&lt;/code&gt; 등과 같은 STL의 시퀀스 컨테이너에도 동일하게 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="d6ccc238acb25d538d7c059636edc82ab574b883" translate="yes" xml:space="preserve">
          <source>If the type you want to marshall is a &lt;a href=&quot;qmap&quot;&gt;QMap&lt;/a&gt; or &lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt;, you need not declare an &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; function for it, since Qt D-Bus provides generic templates to do the job of marshalling the data.</source>
          <target state="translated">마샬링하려는 유형이 &lt;a href=&quot;qmap&quot;&gt;QMap&lt;/a&gt; 또는 &lt;a href=&quot;qhash#qhash&quot;&gt;QHash 인&lt;/a&gt; 경우 Qt D-Bus는 데이터 마샬링 작업을 수행하기위한 일반 템플릿을 제공하므로 &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; 함수를 선언 할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="e99318347b82989db23e33f4c34fb1be38488c48" translate="yes" xml:space="preserve">
          <source>If the underlying database engine supports transactions, &lt;a href=&quot;qsqldriver#hasFeature&quot;&gt;QSqlDriver::hasFeature&lt;/a&gt;(&lt;a href=&quot;qsqldriver#DriverFeature-enum&quot;&gt;QSqlDriver::Transactions&lt;/a&gt;) will return true. You can use &lt;a href=&quot;qsqldatabase#transaction&quot;&gt;QSqlDatabase::transaction&lt;/a&gt;() to initiate a transaction, followed by the SQL commands you want to execute within the context of the transaction, and then either &lt;a href=&quot;qsqldatabase#commit&quot;&gt;QSqlDatabase::commit&lt;/a&gt;() or &lt;a href=&quot;qsqldatabase#rollback&quot;&gt;QSqlDatabase::rollback&lt;/a&gt;(). When using transactions you must start the transaction before you create your query.</source>
          <target state="translated">기본 데이터베이스 엔진이 트랜잭션을 지원하면 &lt;a href=&quot;qsqldriver#hasFeature&quot;&gt;QSqlDriver :: hasFeature&lt;/a&gt; ( &lt;a href=&quot;qsqldriver#DriverFeature-enum&quot;&gt;QSqlDriver :: Transactions&lt;/a&gt; )가 true를 리턴합니다. 당신은 사용할 수 있습니다 &lt;a href=&quot;qsqldatabase#transaction&quot;&gt;QSqlDatabase :: 거래를&lt;/a&gt; 당신이 트랜잭션의 컨텍스트 내에서 실행하고자하는 SQL 명령 다음에 트랜잭션을 시작하는 (), 다음 중 하나를 &lt;a href=&quot;qsqldatabase#commit&quot;&gt;QSqlDatabase는 :: 커밋&lt;/a&gt; () 또는 &lt;a href=&quot;qsqldatabase#rollback&quot;&gt;QSqlDatabase :: 롤백&lt;/a&gt; (). 트랜잭션을 사용할 때는 쿼리를 작성하기 전에 트랜잭션을 시작해야합니다.</target>
        </trans-unit>
        <trans-unit id="6326583f3237b67810ed5921690addf3f227dd8d" translate="yes" xml:space="preserve">
          <source>If the underlying platform was not able to support the requested sharing, this will return 0.</source>
          <target state="translated">기본 플랫폼이 요청 된 공유를 지원할 수없는 경우 0을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="93c438aa3cd271e4e77db3ae2323e3eda44be06c" translate="yes" xml:space="preserve">
          <source>If the update interval is not set (or is set to 0) the source will provide updates as often as necessary.</source>
          <target state="translated">업데이트 간격이 설정되지 않은 경우 (또는 0으로 설정된 경우) 소스는 필요한만큼 업데이트를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="efb858264ebfbcf764e5212f6bb5b3780b569613" translate="yes" xml:space="preserve">
          <source>If the update interval is set, the source will provide updates at an interval as close to the requested interval as possible. If the requested interval is less than the &lt;a href=&quot;qgeopositioninfosource#minimumUpdateInterval-prop&quot;&gt;minimumUpdateInterval&lt;/a&gt;(), the minimum interval is used instead.</source>
          <target state="translated">업데이트 간격이 설정되면 소스는 가능한 한 요청 된 간격에 가까운 간격으로 업데이트를 제공합니다. 요청 된 간격이 &lt;a href=&quot;qgeopositioninfosource#minimumUpdateInterval-prop&quot;&gt;minimumUpdateInterval&lt;/a&gt; () 보다 작 으면 최소 간격이 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="515ee97feffe63eb479e0911dd64c87dfe430ca2" translate="yes" xml:space="preserve">
          <source>If the update interval is set, the source will provide updates at an interval as close to the requested interval as possible. If the requested interval is less than the &lt;a href=&quot;qgeosatelliteinfosource#minimumUpdateInterval-prop&quot;&gt;minimumUpdateInterval&lt;/a&gt;(), the minimum interval is used instead.</source>
          <target state="translated">업데이트 간격이 설정되면 소스는 가능한 한 요청 된 간격에 가까운 간격으로 업데이트를 제공합니다. 요청 된 간격이 &lt;a href=&quot;qgeosatelliteinfosource#minimumUpdateInterval-prop&quot;&gt;minimumUpdateInterval&lt;/a&gt; () 보다 작 으면 최소 간격이 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1441e84810c63702bd63189a7f1114aa0eb6f118" translate="yes" xml:space="preserve">
          <source>If the url contains newline characters (\r\n), then the error signal will be emitted with &lt;a href=&quot;qabstractsocket#SocketError-enum&quot;&gt;QAbstractSocket::ConnectionRefusedError&lt;/a&gt; as error type.</source>
          <target state="translated">URL에 개행 문자 (\ r \ n)가 포함되어 있으면 오류 유형으로 &lt;a href=&quot;qabstractsocket#SocketError-enum&quot;&gt;QAbstractSocket :: ConnectionRefusedError&lt;/a&gt; 와 함께 오류 신호가 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="058d04eecd4863699d9281e089f8e92a49d9b0d9" translate="yes" xml:space="preserve">
          <source>If the url is valid and the cache contains the data for url, a valid &lt;a href=&quot;qnetworkcachemetadata&quot;&gt;QNetworkCacheMetaData&lt;/a&gt; is returned.</source>
          <target state="translated">url이 유효하고 캐시에 url에 대한 데이터가 포함 된 경우 유효한 &lt;a href=&quot;qnetworkcachemetadata&quot;&gt;QNetworkCacheMetaData&lt;/a&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="d8d4c75085caf0ec558b405da6cc62002b474a28" translate="yes" xml:space="preserve">
          <source>If the user changes the system language without a reboot, depending on the system, the strings in arrays and list models and other data structures might not be refreshed automatically. To force the texts to be refreshed when they are displayed in the user interface, you need to declare the strings with the &lt;a href=&quot;#QT_TR_NOOP&quot;&gt;QT_TR_NOOP&lt;/a&gt;() macro. Then, when you populate the objects for display, you need to explicitly retrieve the translation for each text. For example:</source>
          <target state="translated">사용자가 시스템에 따라 재부팅하지 않고 시스템 언어를 변경하면 배열의 문자열 및 목록 모델 및 기타 데이터 구조가 자동으로 새로 고쳐지지 않을 수 있습니다. 사용자 인터페이스에 텍스트가 표시 될 때 텍스트를 새로 고치려면 &lt;a href=&quot;#QT_TR_NOOP&quot;&gt;QT_TR_NOOP&lt;/a&gt; () 매크로를 사용 하여 문자열을 선언해야합니다 . 그런 다음 표시 할 개체를 채울 때 각 텍스트에 대한 번역을 명시 적으로 검색해야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e0c320985856bbb7034bbb58be7eddd2d6ca217b" translate="yes" xml:space="preserve">
          <source>If the user changes the system language without a reboot, depending on the system, the strings in arrays and list models and other data structures might not be refreshed automatically. To force the texts to be refreshed when they are displayed in the user interface, you need to declare the strings with the &lt;a href=&quot;qtglobal#QT_TR_NOOP&quot;&gt;QT_TR_NOOP&lt;/a&gt;() macro. Then, when you populate the objects for display, you need to explicitly retrieve the translation for each text. For example:</source>
          <target state="translated">사용자가 재부팅없이 시스템 언어를 변경하면 시스템에 따라 배열 및 목록 모델의 문자열과 기타 데이터 구조가 자동으로 새로 고쳐지지 않을 수 있습니다. 사용자 인터페이스에 표시 될 때 텍스트를 강제로 새로 고치려면 &lt;a href=&quot;qtglobal#QT_TR_NOOP&quot;&gt;QT_TR_NOOP&lt;/a&gt; () 매크로를 사용 하여 문자열을 선언해야합니다 . 그런 다음 표시 할 개체를 채울 때 각 텍스트에 대한 번역을 명시 적으로 검색해야합니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="0c09cbe0bbc8886d78427cecd2fcce5bc29f2fb8" translate="yes" xml:space="preserve">
          <source>If the user clicks &lt;b&gt;OK&lt;/b&gt;, the selected font is returned. If the user clicks &lt;b&gt;Cancel&lt;/b&gt;, the</source>
          <target state="translated">사용자가 &lt;b&gt;확인을&lt;/b&gt; 클릭 하면 선택한 글꼴이 반환됩니다. 사용자가 &lt;b&gt;취소를&lt;/b&gt; 클릭 하면</target>
        </trans-unit>
        <trans-unit id="a23c924dbc739a99b0c5aae42db87bbe5a1a6081" translate="yes" xml:space="preserve">
          <source>If the user clicks &lt;b&gt;OK&lt;/b&gt;, the selected font is returned. If the user clicks &lt;b&gt;Cancel&lt;/b&gt;, the Qt default font is returned.</source>
          <target state="translated">사용자가 &lt;b&gt;확인을&lt;/b&gt; 클릭 하면 선택한 글꼴이 반환됩니다. 사용자가 &lt;b&gt;취소를&lt;/b&gt; 클릭 하면 Qt 기본 글꼴이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="be18f7b6d79a8d10f0a513d27ea9f3fef894ef94" translate="yes" xml:space="preserve">
          <source>If the user clicks OK the font they chose will be used for myWidget, and if they click Cancel the original font is used.</source>
          <target state="translated">사용자가 확인을 클릭하면 선택한 글꼴이 myWidget에 사용되고 취소를 클릭하면 원래 글꼴이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7e0071b86464b86c5697135076668bda97ce3e5f" translate="yes" xml:space="preserve">
          <source>If the user decides to cancel the shutdown process during the interaction phase, you must tell the session manager that this has happened by calling &lt;a href=&quot;qsessionmanager#cancel&quot;&gt;cancel&lt;/a&gt;().</source>
          <target state="translated">사용자가 상호 작용 단계 중에 종료 프로세스를 취소하기로 결정한 경우, &lt;a href=&quot;qsessionmanager#cancel&quot;&gt;cancel&lt;/a&gt; () 을 호출하여 세션 관리자에게이 문제가 발생했음을 알려야합니다 .</target>
        </trans-unit>
        <trans-unit id="36b35fcf20db56d6a31569f3b4f149b094a5ffea" translate="yes" xml:space="preserve">
          <source>If the user edits the text in a fragment and introduces a different character format, the fragment's text will be split at each point where the format changes, and new fragments will be created. For example, changing the style of some text in the middle of a sentence will cause the fragment to be broken into three separate fragments: the first and third with the same format as before, and the second with the new style. The first fragment will contain the text from the beginning of the sentence, the second will contain the text from the middle, and the third takes the text from the end of the sentence.</source>
          <target state="translated">사용자가 조각에서 텍스트를 편집하고 다른 문자 형식을 도입하면 조각의 텍스트가 형식이 변경되는 각 지점에서 분할되고 새 조각이 만들어집니다. 예를 들어, 문장 중간에 일부 텍스트의 스타일을 변경하면 조각이 세 개의 개별 조각으로 나뉩니다. 첫 번째와 세 번째는 이전과 같은 형식이고 다른 두 번째는 새 스타일입니다. 첫 번째 조각은 문장의 시작 부분에서 텍스트를 포함하고, 두 번째 조각은 중간에서 텍스트를 포함하고, 세 번째 조각은 문장의 끝에서 텍스트를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="6a1998339851d9bf4feb55eb6962d2ed14aa7f83" translate="yes" xml:space="preserve">
          <source>If the user interface is in &quot;What's This?&quot; mode, this function switches back to normal mode; otherwise it does nothing.</source>
          <target state="translated">사용자 인터페이스가 &quot;무엇입니까?&quot; 모드에서이 기능은 정상 모드로 다시 전환됩니다. 그렇지 않으면 아무것도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="70b3278c7b57a588103554cee898e4c6993ece67" translate="yes" xml:space="preserve">
          <source>If the user presses &lt;b&gt;Back&lt;/b&gt;, &lt;a href=&quot;qwizard#cleanupPage&quot;&gt;cleanupPage&lt;/a&gt;() is called (which in turn calls &lt;a href=&quot;qwizardpage#cleanupPage&quot;&gt;QWizardPage::cleanupPage&lt;/a&gt;()). The default implementation resets the page's fields to their original values (the values they had before &lt;a href=&quot;qwizard#initializePage&quot;&gt;initializePage&lt;/a&gt;() was called). If you want the &lt;b&gt;Back&lt;/b&gt; button to be non-destructive and keep the values entered by the user, simply enable the &lt;a href=&quot;qwizard#WizardOption-enum&quot;&gt;IndependentPages&lt;/a&gt; option.</source>
          <target state="translated">사용자가 누르면 &lt;b&gt;뒤로&lt;/b&gt; , &lt;a href=&quot;qwizard#cleanupPage&quot;&gt;cleanupPage&lt;/a&gt; ()가 호출 (차례로 호출 &lt;a href=&quot;qwizardpage#cleanupPage&quot;&gt;QWizardPage :: cleanupPage을&lt;/a&gt; ()). 기본 구현은 페이지 필드를 원래 값 ( &lt;a href=&quot;qwizard#initializePage&quot;&gt;initialPage&lt;/a&gt; ()가 호출 되기 전에 있던 값)으로 재설정합니다 . 당신이 원하는 경우 &lt;b&gt;뒤로&lt;/b&gt; 버튼을 비파괴로 사용자가 입력 한 값을 유지, 단순히 수 &lt;a href=&quot;qwizard#WizardOption-enum&quot;&gt;IndependentPages의&lt;/a&gt; 옵션을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="118159a3e8a9c72c87fbfd78ac8df867141fee07" translate="yes" xml:space="preserve">
          <source>If the user presses the Esc key in a dialog, &lt;a href=&quot;qdialog#reject&quot;&gt;QDialog::reject&lt;/a&gt;() will be called. This will cause the window to close: The &lt;a href=&quot;qcloseevent&quot;&gt;close event&lt;/a&gt; cannot be &lt;a href=&quot;qevent#ignore&quot;&gt;ignored&lt;/a&gt;.</source>
          <target state="translated">사용자가 대화 상자에서 Esc 키를 누르면 &lt;a href=&quot;qdialog#reject&quot;&gt;QDialog :: reject&lt;/a&gt; ()가 호출됩니다. 그러면 창이 닫힙니다. &lt;a href=&quot;qcloseevent&quot;&gt;close 이벤트&lt;/a&gt; 는 &lt;a href=&quot;qevent#ignore&quot;&gt;무시할&lt;/a&gt; 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="fe5b55c484f37eba5c0c77b8c13f910a316fae87" translate="yes" xml:space="preserve">
          <source>If the user selects an item without using a modifier key, the existing selection is cleared.</source>
          <target state="translated">사용자가 수정 자 키를 사용하지 않고 항목을 선택하면 기존 선택이 지워집니다.</target>
        </trans-unit>
        <trans-unit id="4cce50b76d088861764b5595b44e3e7bb14a68b4" translate="yes" xml:space="preserve">
          <source>If the user's locale is French (i.e., &lt;a href=&quot;qlocale#system&quot;&gt;QLocale::system&lt;/a&gt;().name() returns &quot;fr_FR&quot;), &lt;code&gt;:/cut.jpg&lt;/code&gt; becomes a reference to the &lt;code&gt;cut_fr.jpg&lt;/code&gt; image. For other locales, &lt;code&gt;cut.jpg&lt;/code&gt; is used.</source>
          <target state="translated">사용자의 로케일이 프랑스어 인 경우 (즉, &lt;a href=&quot;qlocale#system&quot;&gt;QLocale :: system&lt;/a&gt; () .name ()이 &quot;fr_FR&quot;을 리턴 함), &lt;code&gt;:/cut.jpg&lt;/code&gt; 는 &lt;code&gt;cut_fr.jpg&lt;/code&gt; 이미지에 대한 참조가됩니다 . 다른 로케일의 경우 &lt;code&gt;cut.jpg&lt;/code&gt; 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f405376f1fa5e2658aea5f5a094c391c89d934af" translate="yes" xml:space="preserve">
          <source>If the valid range consists of just positive integers (e.g., 32 to 100) and</source>
          <target state="translated">유효한 범위가 양의 정수 (예 : 32 ~ 100)로 구성되어 있고</target>
        </trans-unit>
        <trans-unit id="e652fe17658fb35e036f3df629b362341807f36f" translate="yes" xml:space="preserve">
          <source>If the value exceeds the widget's number of visible lines, the widget should interpret the scroll operation as a single</source>
          <target state="translated">값이 위젯의 ​​표시 가능한 행 수를 초과하면 위젯은 스크롤 조작을 단일로 해석해야합니다.</target>
        </trans-unit>
        <trans-unit id="64eb9862c8b44e0211819a561de8c20cb21b505c" translate="yes" xml:space="preserve">
          <source>If the value in</source>
          <target state="translated">값이</target>
        </trans-unit>
        <trans-unit id="75c32bc18e3a6eeffb22099439ccdc456cda4bf4" translate="yes" xml:space="preserve">
          <source>If the value is &quot;no&quot; the class cannot be created by the client, and is only available through the API of another class (ie. the class is a sub-type).</source>
          <target state="translated">값이 &quot;no&quot;이면 클라이언트가 클래스를 작성할 수 없으며 다른 클래스의 API를 통해서만 사용할 수 있습니다 (예 : 클래스는 하위 유형입니다).</target>
        </trans-unit>
        <trans-unit id="2c32b5bffeeabe8d28a7e456ef7c92478b77a062" translate="yes" xml:space="preserve">
          <source>If the value is &quot;no&quot; the class does not support aggregation. By default aggregation is supported.</source>
          <target state="translated">값이 &quot;no&quot;이면 클래스는 집계를 지원하지 않습니다. 기본적으로 집계가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="e1ee1920093767f0ede24c42760bcf775dab0355" translate="yes" xml:space="preserve">
          <source>If the value is &quot;yes&quot; objects of this class are registered with OLE and accessible from the running object table (ie. clients can connect to an already running instance of this class). This attribute is only supported in out-of-process servers.</source>
          <target state="translated">값이 &quot;yes&quot;인 경우이 클래스의 오브젝트가 OLE에 등록되고 실행중인 오브젝트 테이블에서 액세스 할 수 있습니다 (즉, 클라이언트는이 클래스의 이미 실행중인 인스턴스에 연결할 수 있음). 이 속성은 Out-of-process 서버에서만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="1abf7e9f2071f55fcb0665a83de3d75b4d803611" translate="yes" xml:space="preserve">
          <source>If the value is &quot;yes&quot; the class is registered to be &quot;Insertable&quot; and will be listed in OLE 2 containers (ie. Microsoft Office). This attribute is not be set by default.</source>
          <target state="translated">값이 &quot;yes&quot;이면 클래스가 &quot;삽입 가능&quot;으로 등록되고 OLE 2 컨테이너 (예 : Microsoft Office)에 나열됩니다. 이 속성은 기본적으로 설정되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8bbcc572b7cadba52617760064290750a7eb8844" translate="yes" xml:space="preserve">
          <source>If the value is &lt;a href=&quot;qjsonvalue#Type-enum&quot;&gt;QJsonValue::Undefined&lt;/a&gt;, it will cause the key to get removed from the object. The returned iterator will then point to &lt;a href=&quot;qjsonobject#end&quot;&gt;end&lt;/a&gt;().</source>
          <target state="translated">값이 &lt;a href=&quot;qjsonvalue#Type-enum&quot;&gt;QJsonValue :: Undefined&lt;/a&gt; 인 경우 키가 오브젝트에서 제거됩니다. 리턴 된 반복자는 &lt;a href=&quot;qjsonobject#end&quot;&gt;종료&lt;/a&gt; () 를 가리 킵니다 .</target>
        </trans-unit>
        <trans-unit id="57424714ec6592ab033cf65d8a92346b86569c96" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;-1&lt;/code&gt;, the list is visible until input focus changes, or the input panel is hidden.</source>
          <target state="translated">값이 &lt;code&gt;-1&lt;/code&gt; 인 경우 입력 초점이 변경되거나 입력 패널이 숨겨 질 때까지 목록이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="af418d4161f063aa90ad2b8d2a63f8564874a7be" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;0&lt;/code&gt;, the list is immediately hidden when cleared.</source>
          <target state="translated">값이 &lt;code&gt;0&lt;/code&gt; 이면 목록을 지우면 즉시 숨겨집니다.</target>
        </trans-unit>
        <trans-unit id="8f9d54a6d0981c22f937efc7fb804ccce72b1e7a" translate="yes" xml:space="preserve">
          <source>If the value is less than or equal to zero, the ray is concidered to be infinite.</source>
          <target state="translated">값이 0보다 작거나 같으면 광선이 무한대로 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="29f446105e7e0c48f459f54b2f53bd82cdbd8691" translate="yes" xml:space="preserve">
          <source>If the value is less than zero, the camera automatically determines an appropriate aperture value.</source>
          <target state="translated">값이 0보다 작 으면 카메라가 자동으로 적절한 조리개 값을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="26ffd97d57e0aa3846b9c21ec0e589a3319a387a" translate="yes" xml:space="preserve">
          <source>If the value of this property is an invalid size, no minimum size is recommended.</source>
          <target state="translated">이 특성의 값이 유효하지 않은 경우 최소 크기를 권장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="999dca4ad9040aa4fdcdedd1d6c387d8bdeee924" translate="yes" xml:space="preserve">
          <source>If the value of this property is an invalid size, no size is recommended.</source>
          <target state="translated">이 특성의 값이 유효하지 않은 크기 인 경우 권장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="778b64f55aa3df2fc24600a451f0f6e94ab09edb" translate="yes" xml:space="preserve">
          <source>If the value type is a primitive type (e.g., char, int, float) or a pointer type (e.g., &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; *), new elements are not initialized. For other types, the elements are initialized with a &lt;a href=&quot;containers#default-constructed-value&quot;&gt;default-constructed value&lt;/a&gt;.</source>
          <target state="translated">값 유형이 기본 유형 (예 : char, int, float) 또는 포인터 유형 (예 : &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; *) 인 경우 새 요소가 초기화되지 않습니다. 다른 유형의 경우 요소는 &lt;a href=&quot;containers#default-constructed-value&quot;&gt;기본 구성 값으로&lt;/a&gt; 초기화됩니다 .</target>
        </trans-unit>
        <trans-unit id="bc68e4b7efabcfe91acdfff5c38e2f5d17e9e994" translate="yes" xml:space="preserve">
          <source>If the value type is a primitive type (e.g., char, int, float) or a pointer type (e.g., &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; *), the elements are not initialized. For other types, the elements are initialized with a &lt;a href=&quot;containers#default-constructed-value&quot;&gt;default-constructed value&lt;/a&gt;.</source>
          <target state="translated">값 유형이 기본 유형 (예 : char, int, float) 또는 포인터 유형 (예 : &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; *) 인 경우 요소가 초기화되지 않습니다. 다른 유형의 경우 요소는 &lt;a href=&quot;containers#default-constructed-value&quot;&gt;기본 구성 값으로&lt;/a&gt; 초기화됩니다 .</target>
        </trans-unit>
        <trans-unit id="ce9681a4084a65a9755b566cae6227babb38e5f5" translate="yes" xml:space="preserve">
          <source>If the velocity of the drag is suffient at the time the touch/mouse button is released then a flick will start.</source>
          <target state="translated">터치 / 마우스 버튼을 놓을 때 드래그 속도가 충분하면 플릭이 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="36f891c5cdb69693dbb41fdcd7397145e7602ece" translate="yes" xml:space="preserve">
          <source>If the velocity value and the duration value are both enabled, then the animation will use whichever gives the shorter duration.</source>
          <target state="translated">속도 값과 지속 시간 값이 모두 활성화 된 경우 애니메이션은 지속 시간이 짧은 것을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="0db8b9843bfb9260efc43c72e10e9e7fda0e96d2" translate="yes" xml:space="preserve">
          <source>If the version could not be determined, this function may return an empty string.</source>
          <target state="translated">버전을 확인할 수 없으면이 함수는 빈 문자열을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c403dbfccd43648e73aaeb737142632b8122a052" translate="yes" xml:space="preserve">
          <source>If the vertical spacing is equal to the horizontal spacing, this function returns that value; otherwise it return -1.</source>
          <target state="translated">수직 간격이 수평 간격과 같으면이 함수는 해당 값을 반환합니다. 그렇지 않으면 -1을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6420747f0e8a76763b7d39b3ded0bcc2484b1731" translate="yes" xml:space="preserve">
          <source>If the vertical spacing is equal to the horizontal spacing, this function returns that value; otherwise it returns -1.</source>
          <target state="translated">수직 간격이 수평 간격과 같으면이 함수는 해당 값을 반환합니다. 그렇지 않으면 -1을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9478f47d3a49fe78d6923ce11008920ff52e0141" translate="yes" xml:space="preserve">
          <source>If the video frame has been mapped in read only mode, it is permissible to map it multiple times in read only mode (and unmap it a corresponding number of times). In all other cases it is necessary to unmap the frame first before mapping a second time.</source>
          <target state="translated">비디오 프레임이 읽기 전용 모드로 매핑 된 경우 읽기 전용 모드에서 여러 번 매핑 할 수 있습니다 (해당 횟수만큼 매핑 해제). 다른 모든 경우에는 두 번째로 매핑하기 전에 먼저 프레임을 매핑 해제해야합니다.</target>
        </trans-unit>
        <trans-unit id="d1d000dfbae6bf393f5d6ce217344fc0561c379c" translate="yes" xml:space="preserve">
          <source>If the video is not interlaced this will return WholeFrame.</source>
          <target state="translated">비디오가 인터레이스되지 않으면 WholeFrame이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="21e551ea18c8ca00f5c82fd8167388e1d71d9e0a" translate="yes" xml:space="preserve">
          <source>If the view and the controller objects are combined, the result is the model/view architecture. This still separates the way that data is stored from the way that it is presented to the user, but provides a simpler framework based on the same principles. This separation makes it possible to display the same data in several different views, and to implement new types of views, without changing the underlying data structures. To allow flexible handling of user input, we introduce the concept of the</source>
          <target state="translated">뷰와 컨트롤러 객체가 결합되면 결과는 모델 / 뷰 아키텍처입니다. 이는 여전히 데이터가 사용자에게 제공되는 방식과 데이터가 저장되는 방식을 분리하지만 동일한 원칙에 따라 더 간단한 프레임 워크를 제공합니다. 이렇게 분리하면 여러 데이터보기에서 동일한 데이터를 표시하고 기본 데이터 구조를 변경하지 않고도 새로운 유형의보기를 구현할 수 있습니다. 사용자 입력을 유연하게 처리 할 수 ​​있도록</target>
        </trans-unit>
        <trans-unit id="44c62dd96949db299bce4fa01084166221083089" translate="yes" xml:space="preserve">
          <source>If the view associated with the web page is a &lt;a href=&quot;qwebengineview&quot;&gt;QWebEngineView&lt;/a&gt; object, then the default implementation forwards the request to &lt;a href=&quot;qwebengineview#createWindow&quot;&gt;QWebEngineView::createWindow&lt;/a&gt;(); otherwise it returns a null pointer.</source>
          <target state="translated">웹 페이지와 연관된보기가 &lt;a href=&quot;qwebengineview&quot;&gt;QWebEngineView&lt;/a&gt; 오브젝트 인 경우 기본 구현은 요청을 &lt;a href=&quot;qwebengineview#createWindow&quot;&gt;QWebEngineView :: createWindow&lt;/a&gt; (); 그렇지 않으면 널 포인터를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="a2b5d19ffc29bad4a29b59eeab8a2650587e96be" translate="yes" xml:space="preserve">
          <source>If the view is not looking at group, this function returns &lt;code&gt;nullptr&lt;/code&gt;.</source>
          <target state="translated">뷰가 그룹을보고 있지 않으면이 함수는 &lt;code&gt;nullptr&lt;/code&gt; 을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="30fe63d57d629ecb5fb69527747f9e95048d433e" translate="yes" xml:space="preserve">
          <source>If the view requests an invalid index, an invalid variant is returned.</source>
          <target state="translated">뷰가 잘못된 인덱스를 요청하면 잘못된 변형이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="37d7a8984dd6a8c90f325e9363355af52dd55a85" translate="yes" xml:space="preserve">
          <source>If the view was previously looking at a &lt;a href=&quot;qundogroup&quot;&gt;QUndoGroup&lt;/a&gt;, the group is set to &lt;code&gt;nullptr&lt;/code&gt;.</source>
          <target state="translated">뷰가 이전에 &lt;a href=&quot;qundogroup&quot;&gt;QUndoGroup을&lt;/a&gt; 보고 있었다면 그룹은 &lt;code&gt;nullptr&lt;/code&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="8b4e5f999a2da1976916c7b40c20b45b48b37e32" translate="yes" xml:space="preserve">
          <source>If the watch is successfully removed, true is returned.</source>
          <target state="translated">시계가 성공적으로 제거되면 true가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="d2e28b23fafe412d79097ecb34b2774c75e7dec1" translate="yes" xml:space="preserve">
          <source>If the watch was successful, true is returned.</source>
          <target state="translated">시계가 성공하면 true가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="5edd705c87d49c4974ddfc708fa9d0eef4bacc85" translate="yes" xml:space="preserve">
          <source>If the web browser supports scripting use JavaScript, VBScript and forms to script the control. The &lt;a href=&quot;https://doc.qt.io/qt-5.13/examples-activeqt.html&quot;&gt;ActiveQt Examples&lt;/a&gt; include demonstration HTML pages for the example controls.</source>
          <target state="translated">웹 브라우저가 스크립팅을 지원하는 경우 JavaScript, VBScript 및 양식을 사용하여 컨트롤을 스크립팅하십시오. 그만큼&lt;a href=&quot;https://doc.qt.io/qt-5.13/examples-activeqt.html&quot;&gt;ActiveQt의 예는&lt;/a&gt; 예제 컨트롤에 대한 데모 HTML 페이지를 포함한다.</target>
        </trans-unit>
        <trans-unit id="be9fb8a7243cb66bdb6de87c9d01ced3988f5c39" translate="yes" xml:space="preserve">
          <source>If the web browser supports scripting use JavaScript, VBScript and forms to script the control. The &lt;a href=&quot;https://doc.qt.io/qt-5.15/examples-activeqt.html&quot;&gt;ActiveQt Examples&lt;/a&gt; include demonstration HTML pages for the example controls.</source>
          <target state="translated">웹 브라우저가 스크립팅을 지원하는 경우 JavaScript, VBScript 및 양식을 사용하여 컨트롤을 스크립팅합니다. &lt;a href=&quot;https://doc.qt.io/qt-5.15/examples-activeqt.html&quot;&gt;ActiveQt의 예는&lt;/a&gt; 예제 컨트롤에 대한 데모 HTML 페이지를 포함한다.</target>
        </trans-unit>
        <trans-unit id="2566f3b867ffaebe462f14d9baea8438baa9a099" translate="yes" xml:space="preserve">
          <source>If the wheel event comes from a physical mouse wheel,</source>
          <target state="translated">휠 이벤트가 실제 마우스 휠에서 오는 경우</target>
        </trans-unit>
        <trans-unit id="ed1e188650ab09f39518ece5642b95355d344cb6" translate="yes" xml:space="preserve">
          <source>If the whole scene is visible in the view, (i.e., there are no visible scroll bars,) the view's alignment will decide where the scene will be rendered in the view. For example, if the alignment is &lt;a href=&quot;qt#AlignmentFlag-enum&quot;&gt;Qt::AlignCenter&lt;/a&gt;, which is default, the scene will be centered in the view, and if the alignment is (&lt;a href=&quot;qt#AlignmentFlag-enum&quot;&gt;Qt::AlignLeft&lt;/a&gt; | &lt;a href=&quot;qt#AlignmentFlag-enum&quot;&gt;Qt::AlignTop&lt;/a&gt;), the scene will be rendered in the top-left corner of the view.</source>
          <target state="translated">전체 장면이 뷰에 표시되면 (즉, 보이는 스크롤 막대가없는 경우) 뷰의 정렬에 따라 뷰에서 장면이 렌더링되는 위치가 결정됩니다. 예를 들어, 정렬이 기본적으로 &lt;a href=&quot;qt#AlignmentFlag-enum&quot;&gt;Qt :: AlignCenter&lt;/a&gt; 인 경우 장면이 뷰의 중앙에 오며 정렬이 ( &lt;a href=&quot;qt#AlignmentFlag-enum&quot;&gt;Qt :: AlignLeft&lt;/a&gt; | &lt;a href=&quot;qt#AlignmentFlag-enum&quot;&gt;Qt :: AlignTop 인 경우)&lt;/a&gt; )이면 장면이 맨 위에 렌더링됩니다. -보기의 왼쪽 모서리.</target>
        </trans-unit>
        <trans-unit id="2cdf83c23415d7645f047f5b6e398d10c43c15fc" translate="yes" xml:space="preserve">
          <source>If the widget displays dates or numbers, these should be formatted using the widget's locale.</source>
          <target state="translated">위젯에 날짜 또는 숫자가 표시되면 위젯의 로케일을 사용하여 형식을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="88ed6fe73ad1c0e776bf4a21bbb6055d9327b19d" translate="yes" xml:space="preserve">
          <source>If the widget had type &lt;a href=&quot;qt#WindowType-enum&quot;&gt;Qt::Widget&lt;/a&gt; or &lt;a href=&quot;qt#WindowType-enum&quot;&gt;Qt::SubWindow&lt;/a&gt; and becomes a window (&lt;a href=&quot;qt#WindowType-enum&quot;&gt;Qt::Window&lt;/a&gt;, &lt;a href=&quot;qt#WindowType-enum&quot;&gt;Qt::Dialog&lt;/a&gt;, etc.), it is put at position (0, 0) on the desktop. If the widget is a window and becomes a &lt;a href=&quot;qt#WindowType-enum&quot;&gt;Qt::Widget&lt;/a&gt; or &lt;a href=&quot;qt#WindowType-enum&quot;&gt;Qt::SubWindow&lt;/a&gt;, it is put at position (0, 0) relative to its parent widget.</source>
          <target state="translated">위젯의 유형이 &lt;a href=&quot;qt#WindowType-enum&quot;&gt;Qt :: Widget&lt;/a&gt; 또는 &lt;a href=&quot;qt#WindowType-enum&quot;&gt;Qt :: SubWindow&lt;/a&gt; 이고 창 ( &lt;a href=&quot;qt#WindowType-enum&quot;&gt;Qt :: Window&lt;/a&gt; , &lt;a href=&quot;qt#WindowType-enum&quot;&gt;Qt :: Dialog&lt;/a&gt; 등)이되면 데스크탑에서 위치 (0, 0)에 놓입니다. 위젯이 창이고 &lt;a href=&quot;qt#WindowType-enum&quot;&gt;Qt :: Widget&lt;/a&gt; 또는 &lt;a href=&quot;qt#WindowType-enum&quot;&gt;Qt :: SubWindow가되는 경우&lt;/a&gt; 되면 상위 위젯을 기준으로 위치 (0, 0)에 놓입니다.</target>
        </trans-unit>
        <trans-unit id="0ae96a1fdb41b4a198c5ab83e88c1c627f1481b6" translate="yes" xml:space="preserve">
          <source>If the widget has a focus proxy, then the focus policy will be propagated to it.</source>
          <target state="translated">위젯에 포커스 프록시가 있으면 포커스 정책이 해당 위젯으로 전파됩니다.</target>
        </trans-unit>
        <trans-unit id="5b8db5dacae22558606e25a3f95c1acec2213c82" translate="yes" xml:space="preserve">
          <source>If the widget has active focus, a &lt;a href=&quot;qwidget#focusOutEvent&quot;&gt;focus out event&lt;/a&gt; is sent to this widget to tell it that it has lost the focus.</source>
          <target state="translated">위젯에 포커스가있는 경우 &lt;a href=&quot;qwidget#focusOutEvent&quot;&gt;포커스 아웃 이벤트&lt;/a&gt; 을 잃었다는 것을 알리기 위해이 위젯으로 가 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="d53c13952299e2a1dc2284dbf14dfde55befe621" translate="yes" xml:space="preserve">
          <source>If the widget has no graphics effect, &lt;code&gt;nullptr&lt;/code&gt; is returned.</source>
          <target state="translated">위젯에 그래픽 효과가없는 경우 &lt;code&gt;nullptr&lt;/code&gt; 이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="bf5ea61858246bb289434cab67720c2ae8e25393" translate="yes" xml:space="preserve">
          <source>If the widget has not yet been shown, the requested format is returned.</source>
          <target state="translated">위젯이 아직 표시되지 않은 경우 요청 된 형식이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="881fc7a841c1f9f3e66baef35d391d6c637e869c" translate="yes" xml:space="preserve">
          <source>If the widget has selected text, the selected text should get removed.</source>
          <target state="translated">위젯이 텍스트를 선택한 경우 선택한 텍스트가 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="971c86d500cc24b9d0919dfbd51a15ed2ff1b989" translate="yes" xml:space="preserve">
          <source>If the widget has the &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt::WA_DeleteOnClose&lt;/a&gt; attribute set it will be deleted.</source>
          <target state="translated">위젯에 &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt :: WA_DeleteOnClose&lt;/a&gt; 속성이 설정되어 있으면 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="b0d07c633d072e3ba42dd6d972a76514d17b6b66" translate="yes" xml:space="preserve">
          <source>If the widget has the &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt::WA_DeleteOnClose&lt;/a&gt; flag, the widget is also deleted. A close events is delivered to the widget no matter if the widget is visible or not.</source>
          <target state="translated">위젯에 &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt :: WA_DeleteOnClose&lt;/a&gt; 플래그 가 있으면 위젯 도 삭제됩니다. 위젯의 표시 여부에 관계없이 닫기 이벤트가 위젯에 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="79b5d591c78b0593670d6c6227aba49a6937c4dd" translate="yes" xml:space="preserve">
          <source>If the widget implements undo/redo, the &lt;a href=&quot;qinputmethodevent#preeditString&quot;&gt;preeditString&lt;/a&gt;() should not influence the undo/redo stack in any way.</source>
          <target state="translated">위젯이 실행 취소 / 다시 실행을 구현하는 경우 &lt;a href=&quot;qinputmethodevent#preeditString&quot;&gt;preeditString&lt;/a&gt; ()은 실행 취소 / 다시 실행 스택에 영향을 미치지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="e9139c9be5b5969f6fb3aadbac5fcf79b02c60e0" translate="yes" xml:space="preserve">
          <source>If the widget implements undo/redo, this operation gets added to the undo stack.</source>
          <target state="translated">위젯이 실행 취소 / 다시 실행을 구현하면이 작업이 실행 취소 스택에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="c026c54f634e9c1ef43d8c82739707ef853f346a" translate="yes" xml:space="preserve">
          <source>If the widget in the example above doesn't have a defined &lt;a href=&quot;qdesignerpropertysheetextension&quot;&gt;QDesignerPropertySheetExtension&lt;/a&gt;, &lt;code&gt;propertySheet&lt;/code&gt; will be a null pointer.</source>
          <target state="translated">이 예에서 위젯이 위의 정의가없는 경우 &lt;a href=&quot;qdesignerpropertysheetextension&quot;&gt;QDesignerPropertySheetExtension을&lt;/a&gt; , &lt;code&gt;propertySheet&lt;/code&gt; 널 포인터가 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="076771580f715cc44a271ad887e782ae70c4d83b" translate="yes" xml:space="preserve">
          <source>If the widget is a window, the position is that of the widget on the desktop, including its frame.</source>
          <target state="translated">위젯이 창인 경우 프레임을 포함하여 데스크탑의 위젯 위치입니다.</target>
        </trans-unit>
        <trans-unit id="7c6f59232c30336eeba16a6f344957830e7e730b" translate="yes" xml:space="preserve">
          <source>If the widget is a window, the widget itself is returned.</source>
          <target state="translated">위젯이 창이면 위젯 자체가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="a36b84d960a149773cae2087e4ca610fcca0fbb8" translate="yes" xml:space="preserve">
          <source>If the widget is already embedded, return the existing proxy widget.</source>
          <target state="translated">위젯이 이미 임베드 된 경우 기존 프록시 위젯을 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="9e6dfc756ffa79d369c2a54a3089bacf68d343d8" translate="yes" xml:space="preserve">
          <source>If the widget is native, this function returns the native widget ID. Otherwise, the window ID of the first native parent widget, i.e., the top-level widget that contains this widget, is returned.</source>
          <target state="translated">위젯이 기본 인 경우이 함수는 기본 위젯 ID를 리턴합니다. 그렇지 않으면 첫 번째 기본 상위 위젯, 즉이 위젯을 포함하는 최상위 위젯의 창 ID가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="031a13625601d36b61303e36c00dd2b52798a527" translate="yes" xml:space="preserve">
          <source>If the widget is the desktop (&lt;a href=&quot;qwidget#windowType&quot;&gt;windowType&lt;/a&gt;() == &lt;a href=&quot;qt#WindowType-enum&quot;&gt;Qt::Desktop&lt;/a&gt;), this may fail if another application is using the desktop; you can call acceptDrops() to test if this occurs.</source>
          <target state="translated">위젯이 데스크탑 인 경우 ( &lt;a href=&quot;qwidget#windowType&quot;&gt;windowType&lt;/a&gt; () == &lt;a href=&quot;qt#WindowType-enum&quot;&gt;Qt :: Desktop&lt;/a&gt; ) 다른 응용 프로그램이 데스크탑을 사용하는 경우 실패 할 수 있습니다. acceptDrops ()를 호출하여 이것이 발생하는지 테스트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="54194f05e9c82646071455ae4abdfc74cdfda664" translate="yes" xml:space="preserve">
          <source>If the widget is visible when it is being resized, it receives a resize event (&lt;a href=&quot;qwidget#resizeEvent&quot;&gt;resizeEvent&lt;/a&gt;()) immediately. If the widget is not currently visible, it is guaranteed to receive an event before it is shown.</source>
          <target state="translated">위젯 크기를 조정할 때 위젯이 표시되면 크기 조정 이벤트 ( &lt;a href=&quot;qwidget#resizeEvent&quot;&gt;resizeEvent&lt;/a&gt; ())를 즉시받습니다. 위젯이 현재 표시되어 있지 않으면 표시되기 전에 이벤트를 수신 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c3ff9e1d40d1838f6ca4693ac1c8cc3b93936bc" translate="yes" xml:space="preserve">
          <source>If the widget's layout direction is &lt;a href=&quot;qt#LayoutDirection-enum&quot;&gt;Qt::RightToLeft&lt;/a&gt; (instead of &lt;a href=&quot;qt#LayoutDirection-enum&quot;&gt;Qt::LeftToRight&lt;/a&gt;, the default), Qt::AlignLeft refers to the</source>
          <target state="translated">위젯의 레이아웃 방향이 &lt;a href=&quot;qt#LayoutDirection-enum&quot;&gt;Qt :: RightToLeft&lt;/a&gt; ( 기본값 &lt;a href=&quot;qt#LayoutDirection-enum&quot;&gt;: Qt :: LeftToRight&lt;/a&gt; 대신 ) 인 경우 Qt :: AlignLeft는</target>
        </trans-unit>
        <trans-unit id="f7fed290b26d15915623ab3e86f2661aa9202cfd" translate="yes" xml:space="preserve">
          <source>If the window has a &lt;a href=&quot;qmenubar&quot;&gt;QMenuBar&lt;/a&gt;, then it is used.</source>
          <target state="translated">창에 &lt;a href=&quot;qmenubar&quot;&gt;QMenuBar&lt;/a&gt; 가 있으면 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="270de41a776e2acfdde789d218aa436031ecf3bb" translate="yes" xml:space="preserve">
          <source>If the window has been created, it will be recreated on the</source>
          <target state="translated">창을 만든 경우 창에서 다시 만들어집니다</target>
        </trans-unit>
        <trans-unit id="b1b416d309a5bcf26d2518847c2c5cad05b48e0f" translate="yes" xml:space="preserve">
          <source>If the window has no parent, then the default menu bar is used (as documented below).</source>
          <target state="translated">창에 부모가 없으면 기본 메뉴 표시 줄이 사용됩니다 (아래에 설명 된대로).</target>
        </trans-unit>
        <trans-unit id="8c85f848542a6ce1820b7cdabad2fd9ee3ab6fd7" translate="yes" xml:space="preserve">
          <source>If the window is modal, then its menu bar is used. If no menu bar is specified, then a default menu bar is used (as documented below).</source>
          <target state="translated">창이 모달 인 경우 해당 메뉴 표시 줄이 사용됩니다. 메뉴 표시 줄을 지정하지 않으면 기본 메뉴 표시 줄이 사용됩니다 (아래에 설명 된대로).</target>
        </trans-unit>
        <trans-unit id="3b768000bdb0066846b91b9874449672a923a683" translate="yes" xml:space="preserve">
          <source>If the window is moved off screen, is made totally obscured by another window, iconified or similar, this function might be called and the value of &lt;a href=&quot;qwindow#isExposed&quot;&gt;isExposed&lt;/a&gt;() might change to false. When this happens, an application should stop its rendering as it is no longer visible to the user.</source>
          <target state="translated">창을 화면 밖으로 이동하고 다른 창에 의해 가려 지거나 아이콘 화되거나 유사한 경우이 함수가 호출되고 &lt;a href=&quot;qwindow#isExposed&quot;&gt;isExposed&lt;/a&gt; () 값이 false로 변경 될 수 있습니다. 이 경우 응용 프로그램은 더 이상 사용자에게 표시되지 않으므로 렌더링을 중지해야합니다.</target>
        </trans-unit>
        <trans-unit id="8eb646865610d0b309c4f8a6610d8876e2dd716a" translate="yes" xml:space="preserve">
          <source>If the window is not visible (i.e. &lt;a href=&quot;qwidget#visible-prop&quot;&gt;isVisible&lt;/a&gt;() returns &lt;code&gt;false&lt;/code&gt;), the window state will take effect when &lt;a href=&quot;qwidget#show&quot;&gt;show&lt;/a&gt;() is called. For visible windows, the change is immediate. For example, to toggle between full-screen and normal mode, use the following code:</source>
          <target state="translated">윈도우가 보이지 않으면 (즉, &lt;a href=&quot;qwidget#visible-prop&quot;&gt;isVisible&lt;/a&gt; ()은 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 ), &lt;a href=&quot;qwidget#show&quot;&gt;show&lt;/a&gt; ()가 호출 될 때 윈도우 상태가 적용됩니다 . 눈에 보이는 창은 즉시 변경됩니다. 예를 들어 전체 화면 모드와 일반 모드를 전환하려면 다음 코드를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="17024c0b4c33abe2bc8858f775cda8758c27b34f" translate="yes" xml:space="preserve">
          <source>If the window is successfully shown by the windowing system, this will be followed by a resize and an expose event.</source>
          <target state="translated">윈도우 시스템에 의해 윈도우가 성공적으로 표시되면, 크기 조정 및 노출 이벤트가 뒤 따릅니다.</target>
        </trans-unit>
        <trans-unit id="a847fbfc906921e1b50bda99924e6a9effeedd28" translate="yes" xml:space="preserve">
          <source>If the window title is set at any point, then the window title takes precedence and will be shown instead of the file path string.</source>
          <target state="translated">창 제목이 언제든지 설정되면 창 제목이 우선하며 파일 경로 문자열 대신 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="389722b48acebd620e5127d2e717e87ad8875861" translate="yes" xml:space="preserve">
          <source>If the window's width and height are left uninitialized, the window will get a reasonable default geometry from the platform window. If the position is left uninitialized, then the platform window will allow the windowing system to position the window. For example on X11, the window manager usually does some kind of smart positioning to try to avoid having new windows completely obscure existing windows. However &lt;a href=&quot;qwindow#setGeometry&quot;&gt;setGeometry&lt;/a&gt;() initializes both the position and the size, so if you want a fixed size but an automatic position, you should call &lt;a href=&quot;qwindow#resize&quot;&gt;resize&lt;/a&gt;() or &lt;a href=&quot;qwindow#width-prop&quot;&gt;setWidth&lt;/a&gt;() and &lt;a href=&quot;qwindow#height-prop&quot;&gt;setHeight&lt;/a&gt;() instead.</source>
          <target state="translated">창의 너비와 높이가 초기화되지 않은 경우 플랫폼 창의 적절한 기본 형상이 창에 표시됩니다. 위치가 초기화되지 않은 경우 플랫폼 창을 통해 창 시스템에서 창을 배치 할 수 있습니다. 예를 들어 X11의 경우 창 관리자는 일반적으로 새 창에서 기존 창을 완전히 가리지 않도록 일종의 스마트 위치 지정을 수행합니다. 그러나 &lt;a href=&quot;qwindow#setGeometry&quot;&gt;setGeometry&lt;/a&gt; ()는 위치와 크기를 모두 초기화하므로 고정 크기이지만 자동 위치를 원하면 &lt;a href=&quot;qwindow#resize&quot;&gt;resize&lt;/a&gt; () 또는 &lt;a href=&quot;qwindow#width-prop&quot;&gt;setWidth&lt;/a&gt; () 및 &lt;a href=&quot;qwindow#height-prop&quot;&gt;setHeight&lt;/a&gt; ()를 대신 호출해야 합니다.</target>
        </trans-unit>
        <trans-unit id="92b052939e46b039fb56f343397a40bce0095c49" translate="yes" xml:space="preserve">
          <source>If the windowing system supports window opacity, this can be used to fade the window in and out, or to make it semitransparent.</source>
          <target state="translated">윈도우 시스템이 윈도우 불투명도를 지원하는 경우 윈도우를 페이드 인 및 페이드 아웃하거나 반투명하게 만드는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec4ab70130b83aa2e8a9d723e9c0330766a79766" translate="yes" xml:space="preserve">
          <source>If the wizard's style is &lt;a href=&quot;qwizard#WizardStyle-enum&quot;&gt;MacStyle&lt;/a&gt;, the page looks radically different:</source>
          <target state="translated">마법사 스타일이 &lt;a href=&quot;qwizard#WizardStyle-enum&quot;&gt;MacStyle&lt;/a&gt; 인 경우 페이지는 크게 다르게 보입니다.</target>
        </trans-unit>
        <trans-unit id="838615bf224e40252afd5e16e2eb7f19eb2ba2d3" translate="yes" xml:space="preserve">
          <source>If the wrap mode is &lt;a href=&quot;qtextedit#LineWrapMode-enum&quot;&gt;FixedPixelWidth&lt;/a&gt;, the value is the number of pixels from the left edge of the text edit at which text should be wrapped. If the wrap mode is &lt;a href=&quot;qtextedit#LineWrapMode-enum&quot;&gt;FixedColumnWidth&lt;/a&gt;, the value is the column number (in character columns) from the left edge of the text edit at which text should be wrapped.</source>
          <target state="translated">줄 바꿈 모드가 &lt;a href=&quot;qtextedit#LineWrapMode-enum&quot;&gt;FixedPixelWidth&lt;/a&gt; 인 경우 값은 텍스트를 줄 바꿈해야하는 텍스트 편집의 왼쪽 가장자리부터 픽셀 수입니다. 랩 모드가 &lt;a href=&quot;qtextedit#LineWrapMode-enum&quot;&gt;FixedColumnWidth&lt;/a&gt; 인 경우 값은 텍스트를 줄 바꿈 할 텍스트 편집의 왼쪽 가장자리에서 열 번호 (문자 열)입니다.</target>
        </trans-unit>
        <trans-unit id="7bb9b0a22df740eeafbe96013a9993ae10d75d6e" translate="yes" xml:space="preserve">
          <source>If there already exists a setting with the same key, the existing value is overwritten by the new value. For efficiency, the changes may not be saved to permanent storage immediately. (You can always call &lt;a href=&quot;qsettings#sync&quot;&gt;sync&lt;/a&gt;() to commit your changes.)</source>
          <target state="translated">동일한 키를 가진 설정이 이미 존재하면 기존 값을 새 값으로 덮어 씁니다. 효율성을 위해 변경 사항이 영구 저장소에 즉시 저장되지 않을 수 있습니다. 변경 사항을 커밋하려면 항상 &lt;a href=&quot;qsettings#sync&quot;&gt;sync&lt;/a&gt; ()를 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="72fb77f426425490dc51f94e37db5eb9773079b5" translate="yes" xml:space="preserve">
          <source>If there already is a layout manager installed on this widget, &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; won't let you install another. You must first delete the existing layout manager (returned by &lt;a href=&quot;qwidget#layout&quot;&gt;layout&lt;/a&gt;()) before you can call setLayout() with the new layout.</source>
          <target state="translated">이 위젯에 이미 레이아웃 관리자가 설치되어 있으면 &lt;a href=&quot;qwidget&quot;&gt;QWidget에서&lt;/a&gt; 다른 위젯 을 설치할 수 없습니다. 먼저 기존의 레이아웃 매니저 삭제해야합니다 (에 의해 반환 된 &lt;a href=&quot;qwidget#layout&quot;&gt;레이아웃을&lt;/a&gt; 새 레이아웃 setLayout의 ()를 호출 할 수 있습니다 ()) 전에.</target>
        </trans-unit>
        <trans-unit id="e74d551875c87a58b352c3bc121b1460b8840c6e" translate="yes" xml:space="preserve">
          <source>If there are fewer labels than categories, the remaining ones do not have a label. If category labels are not defined explicitly, labels are generated from the data row (or column) labels of the primary series of the graph.</source>
          <target state="translated">범주보다 레이블이 적 으면 나머지 레이블에는 레이블이 없습니다. 범주 레이블이 명시 적으로 정의되지 않은 경우 기본 시리즈 그래프의 데이터 행 (또는 열) 레이블에서 레이블이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="a20fd539ba8a58213ec9710e897f6a9d2ee010a5" translate="yes" xml:space="preserve">
          <source>If there are hours, minutes, seconds or milliseconds set, they will be removed.</source>
          <target state="translated">시간, 분, 초 또는 밀리 초가 설정되어 있으면 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="500f21e90d5300a7b0e4acddcd9b73c01b6382e5" translate="yes" xml:space="preserve">
          <source>If there are less than</source>
          <target state="translated">보다 적은 경우</target>
        </trans-unit>
        <trans-unit id="90ca199ad739b35cb00a3cdd56de8f8d7bc5d730" translate="yes" xml:space="preserve">
          <source>If there are more series than colors, the color list wraps and starts again with the first color in the list.</source>
          <target state="translated">색상보다 계열이 더 많으면 색상 목록이 줄 바꿈되어 목록의 첫 번째 색상으로 다시 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="3a1a7b2712387b8618d9ef8ba11415be8b1e0cea" translate="yes" xml:space="preserve">
          <source>If there are more series than gradients, the gradient list wraps and starts again with the first gradient in the list</source>
          <target state="translated">그라디언트보다 계열이 더 많으면 그라디언트 목록이 랩핑되고 목록의 첫 번째 그라디언트로 다시 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="172f51fa7f02a679752d7ccef80458785ee7b327" translate="yes" xml:space="preserve">
          <source>If there are multiple items with the</source>
          <target state="translated">여러 항목이있는 경우</target>
        </trans-unit>
        <trans-unit id="421b3e40d78e0a6ce230022f3011a8c74a9ea167" translate="yes" xml:space="preserve">
          <source>If there are multiple items with the key</source>
          <target state="translated">키가 여러 개인 경우</target>
        </trans-unit>
        <trans-unit id="d8e04739083d19eb90a63d1158c9e75a55657a4c" translate="yes" xml:space="preserve">
          <source>If there are no</source>
          <target state="translated">없는 경우</target>
        </trans-unit>
        <trans-unit id="624b49daa6d1e347807974f5566d1c23ca6f9ae1" translate="yes" xml:space="preserve">
          <source>If there are no Qt signals, and you are writing the test as part of developing a new API, consider whether the API could benefit from the addition of a signal that reports the completion of the asynchronous behavior.</source>
          <target state="translated">Qt 신호가없고 새 API 개발의 일부로 테스트를 작성하는 경우 API가 비동기 동작의 완료를보고하는 신호를 추가하여 이점을 얻을 수 있는지 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="2576a837437186783e3acd4a250c469588bf9a4a" translate="yes" xml:space="preserve">
          <source>If there are no Qt signals, use the &lt;code&gt;QTRY_COMPARE()&lt;/code&gt; and &lt;code&gt;QTRY_VERIFY()&lt;/code&gt; macros, which periodically test a specified condition until it becomes true or some maximum timeout is reached. These macros prevent the test from taking longer than necessary, while avoiding breakages when tests are written on workstations and later executed on embedded platforms.</source>
          <target state="translated">Qt 신호가 없으면 &lt;code&gt;QTRY_COMPARE()&lt;/code&gt; 및 &lt;code&gt;QTRY_VERIFY()&lt;/code&gt; 매크로를 사용합니다.이 매크로는 지정된 조건이 참이되거나 최대 시간 초과에 도달 할 때까지 주기적으로 테스트합니다. 이러한 매크로는 테스트가 필요한 것보다 오래 걸리는 것을 방지하는 동시에 테스트가 워크 스테이션에서 작성되고 나중에 임베디드 플랫폼에서 실행될 때 손상을 방지합니다.</target>
        </trans-unit>
        <trans-unit id="2e7c667ad67c843f88f452ad2984fb024ce94da1" translate="yes" xml:space="preserve">
          <source>If there are no accessibility tools listening to this event, the performance penalty for calling this function is small, but if determining the parameters of the call is expensive you can test &lt;a href=&quot;qaccessible#isActive&quot;&gt;QAccessible::isActive&lt;/a&gt;() to avoid unnecessary computation.</source>
          <target state="translated">이 이벤트를 수신하는 접근성 도구가없는 경우이 함수를 호출하면 성능이 저하되지만 호출 매개 변수를 결정하는 데 비용이 많이 드는 경우 &lt;a href=&quot;qaccessible#isActive&quot;&gt;QAccessible :: isActive&lt;/a&gt; ()를 테스트 하여 불필요한 계산을 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="185b7b9e753c0a89d0eb6680f723fe314f11a7be" translate="yes" xml:space="preserve">
          <source>If there are no bytes to be read and there can never be more bytes available (examples include socket closed, pipe closed, sub-process finished), this function returns -1.</source>
          <target state="translated">읽을 바이트가없고 더 이상 사용 가능한 바이트가 없을 경우 (예 : 소켓 닫힘, 파이프 닫힘, 하위 프로세스 완료 포함)이 함수는 -1을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8f323900759b0f390a0163b5ca1818ffe0534009" translate="yes" xml:space="preserve">
          <source>If there are no errors during the SSL handshake phase (i.e., the identity of the peer is established with no problems), &lt;a href=&quot;qsslsocket&quot;&gt;QSslSocket&lt;/a&gt; will not emit the &lt;a href=&quot;qsslsocket#sslErrors&quot;&gt;sslErrors&lt;/a&gt;() signal, and it is unnecessary to call this function.</source>
          <target state="translated">SSL 핸드 셰이크 단계 중에 오류가없는 경우 (즉, 피어의 ID가 문제없이 설정 됨) &lt;a href=&quot;qsslsocket&quot;&gt;QSslSocket&lt;/a&gt; 은 &lt;a href=&quot;qsslsocket#sslErrors&quot;&gt;sslErrors&lt;/a&gt; () 신호를 방출하지 않으므로이 함수를 호출 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="8ba0a74200e9bb125f38a31d27240eda91969b7d" translate="yes" xml:space="preserve">
          <source>If there are no errors during the SSL handshake phase (i.e., the identity of the peer is established with no problems), &lt;a href=&quot;qsslsocket&quot;&gt;QSslSocket&lt;/a&gt; will not emit the sslErrors() signal, and it is unnecessary to call this function.</source>
          <target state="translated">SSL 핸드 셰이크 단계에서 오류가없는 경우 (즉, 피어의 ID가 문제없이 설정 됨) &lt;a href=&quot;qsslsocket&quot;&gt;QSslSocket&lt;/a&gt; 은 sslErrors () 신호를 방출하지 않으며이 함수를 호출 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="39c621cb23ac3b8fbe307e5c494159d5b6692c09" translate="yes" xml:space="preserve">
          <source>If there are no relevant animations, or no property assignments defined for the state, then the signal will be emitted immediately before the state is entered.</source>
          <target state="translated">관련 애니메이션이 없거나 상태에 대해 속성 할당이 정의되지 않은 경우 상태가 입력되기 직전에 신호가 방출됩니다.</target>
        </trans-unit>
        <trans-unit id="dda6bf943e7ff5a0e0e966cd9581b93dc2d82376" translate="yes" xml:space="preserve">
          <source>If there are only two mutually exclusive options, combine them into a single checkbox or a switch.</source>
          <target state="translated">상호 배타적 인 옵션이 두 개 뿐인 경우 단일 확인란이나 스위치로 결합하십시오.</target>
        </trans-unit>
        <trans-unit id="06aca1f91a5eb636115c08c23224909abe470cd6" translate="yes" xml:space="preserve">
          <source>If there are several &lt;a href=&quot;qxyseries&quot;&gt;QXYSeries&lt;/a&gt; derived series added to the chart and no series of other types have been added, then only one pair of axes is created. If there are several series of different types added to the chart, then each series gets its own axes pair.</source>
          <target state="translated">차트에 여러 &lt;a href=&quot;qxyseries&quot;&gt;QXYSeries&lt;/a&gt; 파생 계열이 추가되고 다른 유형의 계열이 추가되지 않은 경우 한 쌍의 축만 작성됩니다. 차트에 여러 유형의 서로 다른 유형이 추가 된 경우 각 계열은 자체 축 쌍을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="d6a118ddfa3766a43dc34cc70feabebb3779d83a" translate="yes" xml:space="preserve">
          <source>If there is a &lt;a href=&quot;qlayout&quot;&gt;QLayout&lt;/a&gt; that manages this widget's children, the size policy specified by that layout is used. If there is no such &lt;a href=&quot;qlayout&quot;&gt;QLayout&lt;/a&gt;, the result of this function is used.</source>
          <target state="translated">이 위젯의 ​​하위를 관리 하는 &lt;a href=&quot;qlayout&quot;&gt;QLayout&lt;/a&gt; 이있는 경우 해당 레이아웃에 지정된 크기 정책이 사용됩니다. 그러한 &lt;a href=&quot;qlayout&quot;&gt;QLayout&lt;/a&gt; 이 없으면 이 함수의 결과가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e03866c6d3214ba179732c7265b825ba5d3bf8e0" translate="yes" xml:space="preserve">
          <source>If there is a &lt;a href=&quot;qmessagebox#StandardButton-enum&quot;&gt;Cancel&lt;/a&gt; button, it is made the escape button.</source>
          <target state="translated">&lt;a href=&quot;qmessagebox#StandardButton-enum&quot;&gt;취소&lt;/a&gt; 버튼 이 있으면 이스케이프 버튼이됩니다.</target>
        </trans-unit>
        <trans-unit id="4003c427337d692e886ebf5af718285c79657a04" translate="yes" xml:space="preserve">
          <source>If there is a &lt;a href=&quot;qmessagebox#StandardButton-enum&quot;&gt;Cancel&lt;/a&gt; button, it is the button activated when &lt;b&gt;Esc&lt;/b&gt; is pressed.</source>
          <target state="translated">가있는 경우 &lt;a href=&quot;qmessagebox#StandardButton-enum&quot;&gt;취소&lt;/a&gt; 버튼,이 때 활성화 버튼입니다 &lt;b&gt;Esc 키를&lt;/b&gt; 누르면됩니다.</target>
        </trans-unit>
        <trans-unit id="dc4df0a2ff1710801edbf1115fa2522c2fc9ecca" translate="yes" xml:space="preserve">
          <source>If there is a constraint on the length of the characteristic value and</source>
          <target state="translated">특성 값의 길이에 제약이있는 경우</target>
        </trans-unit>
        <trans-unit id="add593c4108a9fb0619c493f44b4ccc7bcc6aca8" translate="yes" xml:space="preserve">
          <source>If there is a default prefix, this function does not return it in the list; check for the default prefix using &lt;a href=&quot;qxmlnamespacesupport#uri&quot;&gt;uri&lt;/a&gt;() with an argument of &quot;&quot;.</source>
          <target state="translated">기본 접두사가 있으면이 함수는 목록에서 접두사를 반환하지 않습니다. 인수 &quot;&quot;와 함께 &lt;a href=&quot;qxmlnamespacesupport#uri&quot;&gt;uri&lt;/a&gt; ()를 사용하여 기본 접 두부를 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="087d4df18b86ffd6bef0fb4b82147c081425848a" translate="yes" xml:space="preserve">
          <source>If there is a match, the</source>
          <target state="translated">일치하는 경우</target>
        </trans-unit>
        <trans-unit id="abe93d80d5bd153252c98d15e7121385a1da6ace" translate="yes" xml:space="preserve">
          <source>If there is a more informative error message you could construct from the values being tested, you can use &lt;code&gt;QVERIFY2()&lt;/code&gt; to pass that message along with your test condition, to provide a more informative message on failure:</source>
          <target state="translated">테스트중인 값에서 구성 할 수있는 더 많은 정보를 제공하는 오류 메시지가있는 경우 &lt;code&gt;QVERIFY2()&lt;/code&gt; 를 사용하여 테스트 조건과 함께 해당 메시지를 전달하고 실패시 더 많은 정보를 제공하는 메시지를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="66cb02c222c449533c4aef692b22ab3d723f0473" translate="yes" xml:space="preserve">
          <source>If there is a naming clash between the model's properties and the delegate's properties, the roles can be accessed with the qualified</source>
          <target state="translated">모델의 속성과 대리인의 속성간에 이름이 충돌하는 경우 자격을 갖춘 역할을 통해 역할에 액세스 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="9d5db1e90258f9df89b778ab01f4f4081aaa7bc9" translate="yes" xml:space="preserve">
          <source>If there is a selection, its content is deleted; otherwise does nothing.</source>
          <target state="translated">선택이 있으면 내용이 삭제됩니다. 그렇지 않으면 아무것도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6f83f468572d446a4e9978b331ff625cc2cdce87" translate="yes" xml:space="preserve">
          <source>If there is a selection, the selection is deleted and replaced by</source>
          <target state="translated">선택이 있으면 선택이 삭제되고</target>
        </trans-unit>
        <trans-unit id="d459e759be14d173d0a0ecd4ce9335373c6774ca" translate="yes" xml:space="preserve">
          <source>If there is already an anchor between the edge pairs, it will be replaced by the anchors that this function specifies.</source>
          <target state="translated">가장자리 쌍 사이에 이미 앵커가 있으면이 함수가 지정하는 앵커로 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="c6f44b132b99b2d795cbcc549d264782d56e331b" translate="yes" xml:space="preserve">
          <source>If there is already an item with the</source>
          <target state="translated">이미 항목이있는 경우</target>
        </trans-unit>
        <trans-unit id="d0953d447624dd862701d39c4af2c6ed92f7ed4a" translate="yes" xml:space="preserve">
          <source>If there is already an item with the key</source>
          <target state="translated">키가있는 항목이 이미있는 경우</target>
        </trans-unit>
        <trans-unit id="2a2d6a3ac75b05d725c74bb9350f18d5bf3122e2" translate="yes" xml:space="preserve">
          <source>If there is already an item with the same key in the hash, this function will simply create a new one. (This behavior is different from &lt;a href=&quot;qhash#insert&quot;&gt;insert&lt;/a&gt;(), which overwrites the value of an existing item.)</source>
          <target state="translated">해시에 동일한 키를 가진 항목이 이미있는 경우이 함수는 단순히 새 항목을 만듭니다. (이 동작은 기존 항목의 값을 덮어 쓰는 &lt;a href=&quot;qhash#insert&quot;&gt;insert&lt;/a&gt; ()와 다릅니다 .)</target>
        </trans-unit>
        <trans-unit id="07b889f77ab2da1cc26fee839deb569502284320" translate="yes" xml:space="preserve">
          <source>If there is already an item with the same key in the hash, this function will simply create a new one. (This behavior is different from &lt;a href=&quot;qmultihash#replace&quot;&gt;replace&lt;/a&gt;(), which overwrites the value of an existing item.)</source>
          <target state="translated">해시에 동일한 키를 가진 항목이 이미있는 경우이 함수는 단순히 새 항목을 만듭니다. (이 동작은 기존 항목의 값을 덮어 쓰는 &lt;a href=&quot;qmultihash#replace&quot;&gt;replace&lt;/a&gt; ()와 다릅니다 .)</target>
        </trans-unit>
        <trans-unit id="860b65a09e7628ea2a82620ef73b6de2ce5e72ba" translate="yes" xml:space="preserve">
          <source>If there is already an item with the same key in the map, this function will simply create a new one.</source>
          <target state="translated">맵에 동일한 키를 가진 아이템이 이미있는 경우이 함수는 단순히 새로운 아이템을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="0b23a30303b9429db4b55de5d7ae6e969d9da34c" translate="yes" xml:space="preserve">
          <source>If there is already an item with the same key in the map, this function will simply create a new one. (This behavior is different from &lt;a href=&quot;qmap#insert&quot;&gt;insert&lt;/a&gt;(), which overwrites the value of an existing item.)</source>
          <target state="translated">맵에 동일한 키를 가진 아이템이 이미있는 경우이 함수는 단순히 새로운 아이템을 생성합니다. (이 동작은 기존 항목의 값을 덮어 쓰는 &lt;a href=&quot;qmap#insert&quot;&gt;insert&lt;/a&gt; ()와 다릅니다 .)</target>
        </trans-unit>
        <trans-unit id="b858cac88035c1223565bdc66ad90b779930e790" translate="yes" xml:space="preserve">
          <source>If there is already an item with the same key in the map, this function will simply create a new one. (This behavior is different from &lt;a href=&quot;qmultimap#replace&quot;&gt;replace&lt;/a&gt;(), which overwrites the value of an existing item.)</source>
          <target state="translated">맵에 동일한 키를 가진 아이템이 이미있는 경우이 함수는 단순히 새로운 아이템을 생성합니다. (이 동작은 기존 항목의 값을 덮어 쓰는 &lt;a href=&quot;qmultimap#replace&quot;&gt;replace&lt;/a&gt; ()와 다릅니다 .)</target>
        </trans-unit>
        <trans-unit id="362eca62837f82235173243f84f36961d2d0ab33" translate="yes" xml:space="preserve">
          <source>If there is exactly one button having either &lt;a href=&quot;qmessagebox#ButtonRole-enum&quot;&gt;the Reject role&lt;/a&gt; or the &lt;a href=&quot;qmessagebox#ButtonRole-enum&quot;&gt;the No role&lt;/a&gt;, it is the button activated when &lt;b&gt;Esc&lt;/b&gt; is pressed.</source>
          <target state="translated">&lt;a href=&quot;qmessagebox#ButtonRole-enum&quot;&gt;거부 역할&lt;/a&gt; 또는 &lt;a href=&quot;qmessagebox#ButtonRole-enum&quot;&gt;아니오 역할&lt;/a&gt; 이있는 단추 가 정확히 하나 인 경우 &lt;b&gt;Esc&lt;/b&gt; 를 누르면 활성화 된 단추 입니다.</target>
        </trans-unit>
        <trans-unit id="255f79736bfd23d3393c1170d97177b84b7f52b7" translate="yes" xml:space="preserve">
          <source>If there is more than one child matching the search, the most direct ancestor is returned. If there are several direct ancestors, it is undefined which one will be returned. In that case, &lt;a href=&quot;qobject#findChildren&quot;&gt;findChildren&lt;/a&gt;() should be used.</source>
          <target state="translated">검색과 일치하는 둘 이상의 자식이있는 경우 가장 직접적인 조상이 반환됩니다. 직계 조상이 여러 개인 경우 어떤 조상이 반환 될지는 정의되지 않습니다. 이 경우 &lt;a href=&quot;qobject#findChildren&quot;&gt;findChildren&lt;/a&gt; ()을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="ebb3e150a09519b734bc9595004d15e0f894adfe" translate="yes" xml:space="preserve">
          <source>If there is no cache for</source>
          <target state="translated">캐시가없는 경우</target>
        </trans-unit>
        <trans-unit id="cad18e7acab448ee7be362a2dee329dbbedfad94" translate="yes" xml:space="preserve">
          <source>If there is no current preedit string, insert the &lt;a href=&quot;qinputmethodevent#preeditString&quot;&gt;preeditString&lt;/a&gt;() at the current cursor position; otherwise replace the previous &lt;a href=&quot;qinputmethodevent#preeditString&quot;&gt;preeditString&lt;/a&gt; with the one received from this event.</source>
          <target state="translated">현재 사전 편집 문자열이없는 경우 현재 커서 위치에 &lt;a href=&quot;qinputmethodevent#preeditString&quot;&gt;preeditString&lt;/a&gt; ()을 삽입하십시오 . 그렇지 않으면 이전 &lt;a href=&quot;qinputmethodevent#preeditString&quot;&gt;preeditString을이&lt;/a&gt; 이벤트에서 수신 한 것과 바꿉니다 .</target>
        </trans-unit>
        <trans-unit id="fbd7fbbfe120c2d9deed922dad8e856595d8ef26" translate="yes" xml:space="preserve">
          <source>If there is no default camera, &lt;code&gt;defaultCamera.deviceId&lt;/code&gt; will contain an empty string.</source>
          <target state="translated">기본 카메라가 없으면 &lt;code&gt;defaultCamera.deviceId&lt;/code&gt; 에 빈 문자열이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="d4e5c7546b523946f1720670beef11723f733169" translate="yes" xml:space="preserve">
          <source>If there is no item at the given position on the scene, the selection area is reset, any focus item loses its input focus, and the event is then ignored.</source>
          <target state="translated">장면의 지정된 위치에 항목이 없으면 선택 영역이 재설정되고 초점 항목이 입력 초점을 잃은 다음 이벤트가 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="b49e339b5c8f6e7a167a9c68617767d1990b53e1" translate="yes" xml:space="preserve">
          <source>If there is no item with the specified key in the hash, these functions return a &lt;a href=&quot;containers#default-constructed-value&quot;&gt;default-constructed value&lt;/a&gt;.</source>
          <target state="translated">해시에 지정된 키가있는 항목이 없으면이 함수는 &lt;a href=&quot;containers#default-constructed-value&quot;&gt;기본 구성 값을&lt;/a&gt; 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="c76575c98bc62a9a5abdd872315938266bb43fc7" translate="yes" xml:space="preserve">
          <source>If there is no item with the specified key in the map, these functions return a &lt;a href=&quot;containers#default-constructed-value&quot;&gt;default-constructed value&lt;/a&gt;.</source>
          <target state="translated">맵에 지정된 키가있는 항목이 없으면이 함수는 &lt;a href=&quot;containers#default-constructed-value&quot;&gt;기본 구성 값을&lt;/a&gt; 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="60ea341b3e5da9fd4da5247cd1a857414126ee1d" translate="yes" xml:space="preserve">
          <source>If there is no matching &lt;a href=&quot;qpagesize#PageSizeId-enum&quot;&gt;PageSizeId&lt;/a&gt; then &lt;a href=&quot;qpagesize#PageSizeId-enum&quot;&gt;QPageSize::Custom&lt;/a&gt; is returned.</source>
          <target state="translated">일치가없는 경우 &lt;a href=&quot;qpagesize#PageSizeId-enum&quot;&gt;PageSizeId&lt;/a&gt; 다음 &lt;a href=&quot;qpagesize#PageSizeId-enum&quot;&gt;QPageSize : 사용자가&lt;/a&gt; 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="38dcc3ef4643c8226eb09b89d3c213c51327856e" translate="yes" xml:space="preserve">
          <source>If there is no mediaObject associated with</source>
          <target state="translated">연관된 mediaObject가없는 경우</target>
        </trans-unit>
        <trans-unit id="c5208cef4d6ed8fd797568f186014a317d945a23" translate="yes" xml:space="preserve">
          <source>If there is no next page in the document, nothing happens.</source>
          <target state="translated">문서에 다음 페이지가 없으면 아무 일도 일어나지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f2267df83c582542b26d42a7762edbf1051bf09c" translate="yes" xml:space="preserve">
          <source>If there is no operation to redo, i.e. there is no redo step in the undo/redo history, nothing happens.</source>
          <target state="translated">다시 실행할 작업이없는 경우, 즉 실행 취소 / 다시 실행 기록에 다시 실행 단계가 없으면 아무 일도 일어나지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a3260e1afe59fd52e73ad2a85ab1586d1d74639a" translate="yes" xml:space="preserve">
          <source>If there is no operation to undo, i.e. there is no undo step in the undo/redo history, nothing happens.</source>
          <target state="translated">실행 취소 작업이없는 경우, 즉 실행 취소 / 다시 실행 기록에 실행 취소 단계가 없으면 아무 일도 일어나지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8330eb7cb7058bb87e8ccb966ea163665d40c933" translate="yes" xml:space="preserve">
          <source>If there is no previous page in the document, nothing happens.</source>
          <target state="translated">문서에 이전 페이지가 없으면 아무 일도 일어나지 않습니다.</target>
        </trans-unit>
        <trans-unit id="56da5651a5eaf456ae37836cb77328c60986b992" translate="yes" xml:space="preserve">
          <source>If there is no selected item or the selected item is not visible, returns an empty string.</source>
          <target state="translated">선택한 항목이 없거나 선택한 항목이 보이지 않으면 빈 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="31dd3fa01bd377299e56714fc19893a42e6c96fe" translate="yes" xml:space="preserve">
          <source>If there is no selected text nothing happens.</source>
          <target state="translated">선택된 텍스트가 없으면 아무 일도 일어나지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0b84595e0c672054aa9838ce815c2b4d985c1a9a" translate="yes" xml:space="preserve">
          <source>If there is no selected text this property's value is an empty string.</source>
          <target state="translated">선택된 텍스트가 없으면이 속성 값은 빈 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="bacdf8d19de73975226914d32edcdbe4f71409f6" translate="yes" xml:space="preserve">
          <source>If there is no selected text, deletes the character</source>
          <target state="translated">선택된 텍스트가 없으면 문자를 삭제합니다</target>
        </trans-unit>
        <trans-unit id="448bab0b58fa3ed4b3e1e37b14c60476fd5b86b1" translate="yes" xml:space="preserve">
          <source>If there is no setting with the specified name, &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; returns a null &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; (which can be converted to the integer 0). You can specify another default value by passing a second argument to &lt;a href=&quot;qsettings#value&quot;&gt;value&lt;/a&gt;():</source>
          <target state="translated">지정된 이름의 설정이 없으면 &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; 는 null &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; (정수 0으로 변환 할 수 있음)를 반환합니다 . 두 번째 인수를 &lt;a href=&quot;qsettings#value&quot;&gt;value&lt;/a&gt; () 에 전달하여 다른 기본값을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="81d9d10e0ba359cb5c0a0d82a8cbf0745fd03a03" translate="yes" xml:space="preserve">
          <source>If there is no setting with the specified name, QSettings returns a null &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; (which can be converted to the integer 0). You can specify another default value by passing a second argument to &lt;a href=&quot;qsettings#value&quot;&gt;value&lt;/a&gt;():</source>
          <target state="translated">지정된 이름의 설정이 없으면 QSettings는 null &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; (정수 0으로 변환 할 수 있음)를 반환합니다 . 두 번째 인수를 &lt;a href=&quot;qsettings#value&quot;&gt;value&lt;/a&gt; () 에 전달하여 다른 기본값을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2b037a04fa96b207eede80eeb91f4b93e9acaebf" translate="yes" xml:space="preserve">
          <source>If there is no substitution for</source>
          <target state="translated">대체품이없는 경우</target>
        </trans-unit>
        <trans-unit id="de6c434a3e9a8badc022f43813771ebd431d7f07" translate="yes" xml:space="preserve">
          <source>If there is no text in the clipboard nothing happens.</source>
          <target state="translated">클립 보드에 텍스트가 없으면 아무 일도 일어나지 않습니다.</target>
        </trans-unit>
        <trans-unit id="400cd5a785badf017e62badfca6b22c7f47d90de" translate="yes" xml:space="preserve">
          <source>If there is no transition after the given</source>
          <target state="translated">주어진 후 전환이없는 경우</target>
        </trans-unit>
        <trans-unit id="7a20d3c265410dbc35aca7369405a76a2eacd95b" translate="yes" xml:space="preserve">
          <source>If there is no transition before the given</source>
          <target state="translated">주어진 전에 전환이없는 경우</target>
        </trans-unit>
        <trans-unit id="4347b45a980638992907ed907b39ef094d63fc33" translate="yes" xml:space="preserve">
          <source>If there is no unreplaced place marker remaining, a warning message is output and the result is undefined. Place marker numbers must be in the range 1 to 99.</source>
          <target state="translated">대체되지 않은 장소 표시자가 남아 있지 않으면 경고 메시지가 출력되고 결과는 정의되지 않습니다. 장소 표시 자 숫자는 1에서 99 사이 여야합니다.</target>
        </trans-unit>
        <trans-unit id="2308ca66eca64924cdcfc0bc6b96ebeeec0fa39c" translate="yes" xml:space="preserve">
          <source>If there is no unreplaced place-marker remaining, a warning message is printed and the result is undefined. Place-marker numbers must be in the range 1 to 99.</source>
          <target state="translated">대체되지 않은 장소 마커가 남아 있지 않으면 경고 메시지가 인쇄되고 결과가 정의되지 않습니다. 장소 표시 숫자는 1에서 99 사이 여야합니다.</target>
        </trans-unit>
        <trans-unit id="6143f7b6f529b55d66f45b327d64c27216b5e967" translate="yes" xml:space="preserve">
          <source>If there is not waypoint associated with this maneuver an invalid &lt;a href=&quot;qgeocoordinate&quot;&gt;QGeoCoordinate&lt;/a&gt; will be returned.</source>
          <target state="translated">이 기동과 관련된 웨이 포인트가 없으면 유효하지 않은 &lt;a href=&quot;qgeocoordinate&quot;&gt;QGeoCoordinate&lt;/a&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="ba9268ca0f9f6ba90f6b7bd1675d190461e1eba8" translate="yes" xml:space="preserve">
          <source>If there is only ever one image for an icon, then &lt;a href=&quot;qplaceicon#SingleUrl-var&quot;&gt;QPlaceIcon::SingleUrl&lt;/a&gt; can be used as a parameter key with a &lt;a href=&quot;qurl&quot;&gt;QUrl&lt;/a&gt; as the associated value. If this key is set, then the &lt;a href=&quot;qplaceicon#url&quot;&gt;url&lt;/a&gt;() function will always return the specified URL and not defer to any manager.</source>
          <target state="translated">아이콘에 대해 하나의 이미지 만있는 경우 &lt;a href=&quot;qplaceicon#SingleUrl-var&quot;&gt;QPlaceIcon :: SingleUrl&lt;/a&gt; 을 &lt;a href=&quot;qurl&quot;&gt;QUrl&lt;/a&gt; 을 연관된 값 으로 사용하여 매개 변수 키로 사용할 수 있습니다 . 이 키를 설정하면 &lt;a href=&quot;qplaceicon#url&quot;&gt;url&lt;/a&gt; () 함수는 항상 지정된 URL을 반환하며 관리자에게 지연되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3efc2360d1c07afcd93ae6ba004e91b1252efbc1" translate="yes" xml:space="preserve">
          <source>If there is only one button, it is made the escape button.</source>
          <target state="translated">버튼이 하나만 있으면 이스케이프 버튼이됩니다.</target>
        </trans-unit>
        <trans-unit id="ef150d1d0c057da518bc7891ba4c0c05f167faf7" translate="yes" xml:space="preserve">
          <source>If there is only one button, it is the button activated when &lt;b&gt;Esc&lt;/b&gt; is pressed.</source>
          <target state="translated">단추가 하나만 있으면 &lt;b&gt;Esc&lt;/b&gt; 를 누를 때 활성화되는 단추 입니다.</target>
        </trans-unit>
        <trans-unit id="41a9346b2f0abc7bf1342c740f707b2bc7bb7a2f" translate="yes" xml:space="preserve">
          <source>If there was an error while creating the object, &lt;code&gt;null&lt;/code&gt; will be returned.</source>
          <target state="translated">객체를 생성하는 동안 오류가 발생하면 &lt;code&gt;null&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="29a4308e0945951e7798c3fe39f16dead6158d1c" translate="yes" xml:space="preserve">
          <source>If these aren't set explicitly the style hint will default to &lt;code&gt;AnyStyle&lt;/code&gt; and the style strategy to &lt;code&gt;PreferDefault&lt;/code&gt;.</source>
          <target state="translated">이것들이 명시 적으로 설정되지 않으면 스타일 힌트는 기본적으로 &lt;code&gt;AnyStyle&lt;/code&gt; 이고 스타일 전략은 &lt;code&gt;PreferDefault&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f005384ee2027b4284fa9314d02fd58749dd17d1" translate="yes" xml:space="preserve">
          <source>If these elements are not sufficient, qmake has the two system variables &lt;a href=&quot;qmake-variable-reference#rc-file&quot;&gt;RC_FILE&lt;/a&gt; and &lt;a href=&quot;qmake-variable-reference#res-file&quot;&gt;RES_FILE&lt;/a&gt; that point directly to an externally created .rc or .res file. By setting one of these variables, the specified file is linked to the EXE or DLL.</source>
          <target state="translated">이러한 요소가 충분하지 않은 경우 qmake에는 외부에서 작성된 .rc 또는 .res 파일을 직접 가리키는 두 개의 시스템 변수 &lt;a href=&quot;qmake-variable-reference#rc-file&quot;&gt;RC_FILE&lt;/a&gt; 및 &lt;a href=&quot;qmake-variable-reference#res-file&quot;&gt;RES_FILE&lt;/a&gt; 이 있습니다. 이러한 변수 중 하나를 설정하면 지정된 파일이 EXE 또는 DLL에 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="54097327ac6d74d4399d1a9f24a1e381bb68c411" translate="yes" xml:space="preserve">
          <source>If these standard models do not meet your requirements, you can subclass &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt;, &lt;a href=&quot;qabstractlistmodel&quot;&gt;QAbstractListModel&lt;/a&gt;, or &lt;a href=&quot;qabstracttablemodel&quot;&gt;QAbstractTableModel&lt;/a&gt; to create your own custom models.</source>
          <target state="translated">이러한 표준 모델이 요구 사항을 충족하지 않으면 &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; , &lt;a href=&quot;qabstractlistmodel&quot;&gt;QAbstractListModel&lt;/a&gt; 또는 &lt;a href=&quot;qabstracttablemodel&quot;&gt;QAbstractTableModel&lt;/a&gt; 을 서브 클래스 하여 고유 한 사용자 지정 모델을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b18d68224c4502134956cd3f8a1ffeac676e537f" translate="yes" xml:space="preserve">
          <source>If these two methods are called in succession, the following happens:</source>
          <target state="translated">이 두 가지 방법을 연속해서 호출하면 다음이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="53a01c0f9a3b1dd49320c976a36dbc15a3db93d3" translate="yes" xml:space="preserve">
          <source>If these two methods are called simultaneously from two threads then the following sequence could result:</source>
          <target state="translated">이 두 메소드가 두 스레드에서 동시에 호출되면 다음 순서가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cfb96f2fe8228064a0ebc216efe69f933e027f79" translate="yes" xml:space="preserve">
          <source>If this &lt;a href=&quot;qcborvalue&quot;&gt;QCborValue&lt;/a&gt; contains the undefined value, this function will return an undefined &lt;a href=&quot;qjsonvalue&quot;&gt;QJsonValue&lt;/a&gt; too. Note that JSON does not support undefined values and undefined QJsonValues are an extension to the specification. They cannot be held in a &lt;a href=&quot;qjsonarray&quot;&gt;QJsonArray&lt;/a&gt; or &lt;a href=&quot;qjsonobject&quot;&gt;QJsonObject&lt;/a&gt;, but can be returned from functions to indicate a failure. For all other intents and purposes, they are the same as null.</source>
          <target state="translated">이 &lt;a href=&quot;qcborvalue&quot;&gt;QCborValue&lt;/a&gt; 에 정의되지 않은 값 이 포함 된 경우이 함수는 정의되지 않은 &lt;a href=&quot;qjsonvalue&quot;&gt;QJsonValue&lt;/a&gt; 도 리턴합니다 . JSON은 정의되지 않은 값을 지원하지 않으며 정의되지 않은 QJsonValues는 사양의 확장입니다. &lt;a href=&quot;qjsonarray&quot;&gt;QJsonArray&lt;/a&gt; 또는 &lt;a href=&quot;qjsonobject&quot;&gt;QJsonObject에&lt;/a&gt; 보유 할 수 없지만 실패를 표시하기 위해 함수에서 리턴 될 수 있습니다. 다른 모든 의도와 목적을 위해, 그들은 null과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d6442e112b6731aa14e363611bda3317de5b9889" translate="yes" xml:space="preserve">
          <source>If this &lt;a href=&quot;qcborvalue&quot;&gt;QCborValue&lt;/a&gt; is a &lt;a href=&quot;qcbormap&quot;&gt;QCborMap&lt;/a&gt;, searches elements for the value whose key matches</source>
          <target state="translated">이 &lt;a href=&quot;qcborvalue&quot;&gt;QCborValue&lt;/a&gt; 가 &lt;a href=&quot;qcbormap&quot;&gt;QCborMap&lt;/a&gt; 인 경우 키와 일치하는 값을 요소에서 검색합니다.</target>
        </trans-unit>
        <trans-unit id="86e353747f4fca48b3b84680432f16a370589a01" translate="yes" xml:space="preserve">
          <source>If this &lt;a href=&quot;qdeadlinetimer&quot;&gt;QDeadlineTimer&lt;/a&gt; never expires or the number of nanoseconds until the deadline can't be accommodated in the return type, this function returns &lt;code&gt;std::numeric_limits&amp;lt;qint64&amp;gt;::max()&lt;/code&gt;.</source>
          <target state="translated">이 &lt;a href=&quot;qdeadlinetimer&quot;&gt;QDeadlineTimer&lt;/a&gt; 가 만료되지 않거나 반환 유형에 최종 기한을 수용 할 수있을 때까지 나노초 수이면이 함수는 &lt;code&gt;std::numeric_limits&amp;lt;qint64&amp;gt;::max()&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="095fae73687e4ae82f7306209b4370494bf54b15" translate="yes" xml:space="preserve">
          <source>If this &lt;a href=&quot;qdeadlinetimer&quot;&gt;QDeadlineTimer&lt;/a&gt; never expires, this function returns &lt;code&gt;std::numeric_limits&amp;lt;qint64&amp;gt;::max()&lt;/code&gt;.</source>
          <target state="translated">이 &lt;a href=&quot;qdeadlinetimer&quot;&gt;QDeadlineTimer&lt;/a&gt; 가 만료되지 않으면이 함수는 &lt;code&gt;std::numeric_limits&amp;lt;qint64&amp;gt;::max()&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="34816323381e490aef5264cf4ca8287494c4b5c3" translate="yes" xml:space="preserve">
          <source>If this &lt;a href=&quot;qjsvalue&quot;&gt;QJSValue&lt;/a&gt; does not already have a property with name</source>
          <target state="translated">이 &lt;a href=&quot;qjsvalue&quot;&gt;QJSValue&lt;/a&gt; 에 이름이있는 특성이없는 경우</target>
        </trans-unit>
        <trans-unit id="71df3649d8ae81a1290aeef969a417865f237000" translate="yes" xml:space="preserve">
          <source>If this &lt;a href=&quot;qjsvalue&quot;&gt;QJSValue&lt;/a&gt; is a &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;, returns the &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; pointer that the &lt;a href=&quot;qjsvalue&quot;&gt;QJSValue&lt;/a&gt; represents; otherwise, returns &lt;code&gt;nullptr&lt;/code&gt;.</source>
          <target state="translated">이 &lt;a href=&quot;qjsvalue&quot;&gt;QJSValue&lt;/a&gt; 가 &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 인 경우 &lt;a href=&quot;qjsvalue&quot;&gt;QJSValue가&lt;/a&gt; 나타내는 &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 포인터를 리턴합니다 . 그렇지 않으면 &lt;code&gt;nullptr&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="c28bd290d87d98f1dbcf2af17aa231d942c4e447" translate="yes" xml:space="preserve">
          <source>If this &lt;a href=&quot;qjsvalue&quot;&gt;QJSValue&lt;/a&gt; is an object, returns the internal prototype (&lt;code&gt;__proto__&lt;/code&gt; property) of this object; otherwise returns an undefined &lt;a href=&quot;qjsvalue&quot;&gt;QJSValue&lt;/a&gt;.</source>
          <target state="translated">이 &lt;a href=&quot;qjsvalue&quot;&gt;QJSValue&lt;/a&gt; 가 객체 인 경우이 객체의 내부 프로토 타입 ( &lt;code&gt;__proto__&lt;/code&gt; 속성)을 반환 합니다. 그렇지 않으면 정의되지 않은 &lt;a href=&quot;qjsvalue&quot;&gt;QJSValue를&lt;/a&gt; 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="f3cc4537501b45def3dab11733b77d412ff9d344" translate="yes" xml:space="preserve">
          <source>If this &lt;a href=&quot;qjsvalue&quot;&gt;QJSValue&lt;/a&gt; is an object, sets the internal prototype (&lt;code&gt;__proto__&lt;/code&gt; property) of this object to be</source>
          <target state="translated">이 &lt;a href=&quot;qjsvalue&quot;&gt;QJSValue&lt;/a&gt; 가 객체 인 경우이 객체의 내부 프로토 타입 ( &lt;code&gt;__proto__&lt;/code&gt; 속성)을</target>
        </trans-unit>
        <trans-unit id="a444a77e03f455507a6176f1fe23e1bdf4d1ff86" translate="yes" xml:space="preserve">
          <source>If this &lt;a href=&quot;qjsvalue&quot;&gt;QJSValue&lt;/a&gt; is not a function, &lt;a href=&quot;qjsvalue#call&quot;&gt;call&lt;/a&gt;() does nothing and returns an undefined &lt;a href=&quot;qjsvalue&quot;&gt;QJSValue&lt;/a&gt;.</source>
          <target state="translated">이 &lt;a href=&quot;qjsvalue&quot;&gt;QJSValue&lt;/a&gt; 가 함수가 아닌 경우 , &lt;a href=&quot;qjsvalue#call&quot;&gt;호출&lt;/a&gt; ()은 아무것도하지 않고 정의되지 않은 &lt;a href=&quot;qjsvalue&quot;&gt;QJSValue를&lt;/a&gt; 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="4f79a69ba9286f52c9b76a3bd851c50531735019" translate="yes" xml:space="preserve">
          <source>If this &lt;a href=&quot;qjsvalue&quot;&gt;QJSValue&lt;/a&gt; is not a function, callAsConstructor() does nothing and returns an undefined &lt;a href=&quot;qjsvalue&quot;&gt;QJSValue&lt;/a&gt;.</source>
          <target state="translated">이 &lt;a href=&quot;qjsvalue&quot;&gt;QJSValue&lt;/a&gt; 가 함수가 아닌 경우 , callAsConstructor ()는 아무것도하지 않고 정의되지 않은 &lt;a href=&quot;qjsvalue&quot;&gt;QJSValue를&lt;/a&gt; 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="9e7c534c52e9dc670c39d2b182b21edf44edc8e1" translate="yes" xml:space="preserve">
          <source>If this &lt;a href=&quot;qjsvalue&quot;&gt;QJSValue&lt;/a&gt; is not an Array object, this function behaves as if &lt;a href=&quot;qjsvalue#property&quot;&gt;property&lt;/a&gt;() was called with the string representation of</source>
          <target state="translated">이 &lt;a href=&quot;qjsvalue&quot;&gt;QJSValue&lt;/a&gt; 가 Array 객체가 아닌 경우,이 함수 는 문자열 표현으로 &lt;a href=&quot;qjsvalue#property&quot;&gt;속성&lt;/a&gt; ()이 호출 된 것처럼 동작 합니다.</target>
        </trans-unit>
        <trans-unit id="2619780966f6883183e8a962e0a77614797d470b" translate="yes" xml:space="preserve">
          <source>If this &lt;a href=&quot;qjsvalue&quot;&gt;QJSValue&lt;/a&gt; is not an Array object, this function behaves as if &lt;a href=&quot;qjsvalue#setProperty&quot;&gt;setProperty&lt;/a&gt;() was called with the string representation of</source>
          <target state="translated">이 &lt;a href=&quot;qjsvalue&quot;&gt;QJSValue&lt;/a&gt; 가 Array 객체가 아닌 경우,이 함수 는 다음의 문자열 표현으로 &lt;a href=&quot;qjsvalue#setProperty&quot;&gt;setProperty&lt;/a&gt; ()가 호출 된 것처럼 동작 합니다.</target>
        </trans-unit>
        <trans-unit id="9e8955afab83a8c00d99ec7c0a61a3239bbc6438" translate="yes" xml:space="preserve">
          <source>If this &lt;a href=&quot;qjsvalue&quot;&gt;QJSValue&lt;/a&gt; is not an Array object, this function behaves as if property() was called with the string representation of</source>
          <target state="translated">이 &lt;a href=&quot;qjsvalue&quot;&gt;QJSValue&lt;/a&gt; 가 Array 객체가 아닌 경우이 함수는 property ()가 다음의 문자열 표현으로 호출 된 것처럼 작동합니다.</target>
        </trans-unit>
        <trans-unit id="0dfbc53bd0df854be6a99cbaf377eb25c173216d" translate="yes" xml:space="preserve">
          <source>If this &lt;a href=&quot;qjsvalue&quot;&gt;QJSValue&lt;/a&gt; is not an Array object, this function behaves as if setProperty() was called with the string representation of</source>
          <target state="translated">이 &lt;a href=&quot;qjsvalue&quot;&gt;QJSValue&lt;/a&gt; 가 Array 객체가 아닌 경우이 함수는 setProperty ()가 다음의 문자열 표현으로 호출 된 것처럼 작동합니다.</target>
        </trans-unit>
        <trans-unit id="812e85c767bafbb284e17e21019008bdc163b73a" translate="yes" xml:space="preserve">
          <source>If this &lt;a href=&quot;qjsvalue&quot;&gt;QJSValue&lt;/a&gt; is not an object, this function does nothing.</source>
          <target state="translated">이 &lt;a href=&quot;qjsvalue&quot;&gt;QJSValue&lt;/a&gt; 가 오브젝트가 아닌 경우이 함수는 아무 것도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8b313ab38df138dfb9a035847cafb9d8680a45d4" translate="yes" xml:space="preserve">
          <source>If this &lt;a href=&quot;qjsvalue&quot;&gt;QJSValue&lt;/a&gt; is not callable, call() does nothing and returns an undefined &lt;a href=&quot;qjsvalue&quot;&gt;QJSValue&lt;/a&gt;.</source>
          <target state="translated">이 &lt;a href=&quot;qjsvalue&quot;&gt;QJSValue&lt;/a&gt; 를 호출 할 수없는 경우 , call ()은 아무것도하지 않고 정의되지 않은 &lt;a href=&quot;qjsvalue&quot;&gt;QJSValue를&lt;/a&gt; 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="3b7ad2728efbf696ccf994f4ed2ab3ef77c72645" translate="yes" xml:space="preserve">
          <source>If this &lt;a href=&quot;qxmlitem&quot;&gt;QXmlItem&lt;/a&gt; represents a node, it returns the item as a &lt;a href=&quot;qxmlnodemodelindex&quot;&gt;QXmlNodeModelIndex&lt;/a&gt;. If this &lt;a href=&quot;qxmlitem&quot;&gt;QXmlItem&lt;/a&gt; is not a node, the return value is undefined. You can call &lt;a href=&quot;qxmlitem#isNode&quot;&gt;isNode&lt;/a&gt;() to test whether the item is a node.</source>
          <target state="translated">이 &lt;a href=&quot;qxmlitem&quot;&gt;QXmlItem&lt;/a&gt; 이 노드를 나타내는 경우 항목을 &lt;a href=&quot;qxmlnodemodelindex&quot;&gt;QXmlNodeModelIndex&lt;/a&gt; 로 리턴합니다 . 이 &lt;a href=&quot;qxmlitem&quot;&gt;QXmlItem&lt;/a&gt; 이 노드가 아닌 경우 리턴 값이 정의되지 않습니다. &lt;a href=&quot;qxmlitem#isNode&quot;&gt;isNode&lt;/a&gt; ()를 호출 하여 항목이 노드인지 테스트 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="48f7e066d724ef2f9243852b35b0718230e5d828" translate="yes" xml:space="preserve">
          <source>If this &lt;a href=&quot;qxmlitem&quot;&gt;QXmlItem&lt;/a&gt; represents an atomic value, it is converted to an appropriate &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; and returned. If this &lt;a href=&quot;qxmlitem&quot;&gt;QXmlItem&lt;/a&gt; is not an atomic value, the return value is a default constructed &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt;. You can call &lt;a href=&quot;qxmlitem#isAtomicValue&quot;&gt;isAtomicValue&lt;/a&gt;() to test whether the item is an atomic value.</source>
          <target state="translated">이 &lt;a href=&quot;qxmlitem&quot;&gt;QXmlItem&lt;/a&gt; 이 원자 값을 나타내는 경우 적절한 &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; 로 변환되어 리턴됩니다. 이 &lt;a href=&quot;qxmlitem&quot;&gt;QXmlItem&lt;/a&gt; 이 원자 값이 아닌 경우 리턴 값은 기본 구성된 &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; 입니다. 항목이 원자 값인지 테스트하기 위해 &lt;a href=&quot;qxmlitem#isAtomicValue&quot;&gt;isAtomicValue&lt;/a&gt; ()를 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4cda4d945c5ab46fbacd370f729be3ff2ae051e5" translate="yes" xml:space="preserve">
          <source>If this URL contains a non-empty hostname, it will be encoded in the returned value in the form found on SMB networks (for example, &quot;//servername/path/to/file.txt&quot;).</source>
          <target state="translated">이 URL에 비어 있지 않은 호스트 이름이 포함되어 있으면 SMB 네트워크에서 찾은 형식으로 반환 된 값으로 인코딩됩니다 (예 : &quot;//servername/path/to/file.txt&quot;).</target>
        </trans-unit>
        <trans-unit id="c9731f31fd9cdca34aca956810658dc9bd80a15b" translate="yes" xml:space="preserve">
          <source>If this animation is part of a &lt;a href=&quot;qanimationgroup&quot;&gt;QAnimationGroup&lt;/a&gt;, this function returns a pointer to the group; otherwise, it returns &lt;code&gt;nullptr&lt;/code&gt;.</source>
          <target state="translated">이 애니메이션이 &lt;a href=&quot;qanimationgroup&quot;&gt;QAnimationGroup의&lt;/a&gt; 일부인 경우이 함수는 그룹에 대한 포인터를 반환합니다. 그렇지 않으면 &lt;code&gt;nullptr&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="89823c80ddc3a688e9a9ba5e0639dc8492809c75" translate="yes" xml:space="preserve">
          <source>If this argument is equal or greater than zero, all occurrences of &lt;code&gt;%n&lt;/code&gt; in the resulting string are replaced with a decimal representation of the value supplied. In addition, the translation used will adapt to the value according to the rules for each language.</source>
          <target state="translated">이 인수가 0보다 크거나 같은 경우 결과 문자열에서 발생하는 모든 &lt;code&gt;%n&lt;/code&gt; 은 제공된 값의 10 진수 표현으로 대체됩니다. 또한 사용 된 번역은 각 언어의 규칙에 따라 값에 맞게 조정됩니다.</target>
        </trans-unit>
        <trans-unit id="3ae36af3614cd7bc3efbcdd41f1ffbd6e433d735" translate="yes" xml:space="preserve">
          <source>If this branch is being tested in the Qt CI system, the above detailed failure message will be inserted into the summary posted to the code-review system:</source>
          <target state="translated">이 분기가 Qt CI 시스템에서 테스트되는 경우 위의 자세한 실패 메시지가 코드 검토 시스템에 게시 된 요약에 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="a8e5048acb52493cf91a288640ee3c37c026fb85" translate="yes" xml:space="preserve">
          <source>If this buffer is not part of a stream, this will return -1.</source>
          <target state="translated">이 버퍼가 스트림의 일부가 아닌 경우는 -1을 돌려줍니다.</target>
        </trans-unit>
        <trans-unit id="da6abdb08f79760601bda257ab2164069e69fda7" translate="yes" xml:space="preserve">
          <source>If this causes the geo rectangle to cross on of the poles the height of the geo rectangle will be truncated such that the geo rectangle only extends up to the pole. The center of the geo rectangle will be unchanged, and the height will be adjusted such that the center point is at the center of the truncated geo rectangle.</source>
          <target state="translated">이로 인해 지오 사각형이 극점을 가로 지르면 지오 사각형이 극점까지만 연장되도록 지오 사각형의 높이가 잘립니다. 지오 사각형의 중심은 변경되지 않고 중심점이 잘린 지오 사각형의 중심에 오도록 높이가 조정됩니다.</target>
        </trans-unit>
        <trans-unit id="a8f615f888382dcf0d960d90820d824a90fd6941" translate="yes" xml:space="preserve">
          <source>If this class instance was requested to use the default adapter but there was no default adapter when creating this class instance, the returned &lt;a href=&quot;qbluetoothaddress&quot;&gt;QBluetoothAddress&lt;/a&gt; will be null.</source>
          <target state="translated">이 클래스 인스턴스가 기본 어댑터를 사용하도록 요청되었지만이 클래스 인스턴스를 작성할 때 기본 어댑터가없는 경우 리턴 된 &lt;a href=&quot;qbluetoothaddress&quot;&gt;QBluetoothAddress&lt;/a&gt; 는 널이됩니다.</target>
        </trans-unit>
        <trans-unit id="2bbf8373514cfa24780d9417526483415ff1bcb7" translate="yes" xml:space="preserve">
          <source>If this code is compiled with &lt;code&gt;QT_NO_DEBUG&lt;/code&gt; defined, the code in the &lt;a href=&quot;#Q_CHECK_PTR&quot;&gt;Q_CHECK_PTR&lt;/a&gt;() expression is not executed and</source>
          <target state="translated">이 코드가 정의 된 &lt;code&gt;QT_NO_DEBUG&lt;/code&gt; 로 컴파일 된 경우 &lt;a href=&quot;#Q_CHECK_PTR&quot;&gt;Q_CHECK_PTR&lt;/a&gt; () 표현식 의 코드 는 실행되지 않으며</target>
        </trans-unit>
        <trans-unit id="4ed0341a2c6d4f77678b14e3c2f80e491086ef07" translate="yes" xml:space="preserve">
          <source>If this code is compiled with &lt;code&gt;QT_NO_DEBUG&lt;/code&gt; defined, the code in the &lt;a href=&quot;qtglobal#Q_CHECK_PTR&quot;&gt;Q_CHECK_PTR&lt;/a&gt;() expression is not executed and</source>
          <target state="translated">이 코드가 정의 된 &lt;code&gt;QT_NO_DEBUG&lt;/code&gt; 로 컴파일 되면 &lt;a href=&quot;qtglobal#Q_CHECK_PTR&quot;&gt;Q_CHECK_PTR&lt;/a&gt; () 표현식 의 코드 가 실행되지 않고</target>
        </trans-unit>
        <trans-unit id="6af8531a016756c4a49339fd0023478001b06152" translate="yes" xml:space="preserve">
          <source>If this datagram was received from the network, this is the index of the interface that the packet was received from. If this is an outgoing datagram, this is the index of the interface that the datagram should be sent on.</source>
          <target state="translated">이 데이터 그램이 네트워크에서 수신 된 경우 패킷이 수신 된 인터페이스의 색인입니다. 나가는 데이터 그램 인 경우 데이터 그램을 전송해야하는 인터페이스의 인덱스입니다.</target>
        </trans-unit>
        <trans-unit id="752cd3ab2831de0b33b58454d0876d48c058369c" translate="yes" xml:space="preserve">
          <source>If this datagram was received from the network, this is the remaining hop count of the datagram after reception and was decremented by 1 by each node that forwarded the packet. A value of -1 indicates that the hop limit count not be obtained.</source>
          <target state="translated">이 데이터 그램이 네트워크에서 수신 된 경우 이는 수신 후 데이터 그램의 나머지 홉 수이며 패킷을 전달한 각 노드에 의해 1 씩 감소합니다. 값이 -1이면 홉 제한 개수를 얻지 못했음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="41122439482a8ee42028b7f9bf61255c19c85729" translate="yes" xml:space="preserve">
          <source>If this datetime is invalid, an invalid datetime will be returned.</source>
          <target state="translated">이 날짜 시간이 유효하지 않으면 유효하지 않은 날짜 시간이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="156cae2b7a374a0bac8e6a74befd7b5309982173" translate="yes" xml:space="preserve">
          <source>If this dialog is shown with &lt;a href=&quot;qdialog#exec&quot;&gt;exec&lt;/a&gt;(), done() also causes the local event loop to finish, and &lt;a href=&quot;qdialog#exec&quot;&gt;exec&lt;/a&gt;() to return</source>
          <target state="translated">이 대화 상자에 &lt;a href=&quot;qdialog#exec&quot;&gt;exec&lt;/a&gt; () 가 표시 되면 done ()으로 인해 로컬 이벤트 루프가 종료되고 &lt;a href=&quot;qdialog#exec&quot;&gt;exec&lt;/a&gt; ()가 리턴됩니다</target>
        </trans-unit>
        <trans-unit id="d22998bf1430a9decaac7ab11b11389539aaeae5" translate="yes" xml:space="preserve">
          <source>If this entry is not found a default Quit item will be created to call &lt;a href=&quot;qcoreapplication#quit&quot;&gt;QCoreApplication::quit&lt;/a&gt;()</source>
          <target state="translated">이 항목을 찾을 수 없으면 &lt;a href=&quot;qcoreapplication#quit&quot;&gt;QCoreApplication :: quit&lt;/a&gt; () 를 호출하기위한 기본 Quit 항목이 생성됩니다</target>
        </trans-unit>
        <trans-unit id="c580b65f7be4f07cc1eba69db1a805df802bf56e" translate="yes" xml:space="preserve">
          <source>If this entry is not found the Settings item will be disabled</source>
          <target state="translated">이 항목을 찾을 수 없으면 설정 항목이 비활성화됩니다</target>
        </trans-unit>
        <trans-unit id="bb2d34b31e070405b36c923c5098371aaef2576e" translate="yes" xml:space="preserve">
          <source>If this event is generated by an invoked state machine, returns the ID of the &lt;code&gt;&amp;lt;invoke&amp;gt;&lt;/code&gt; element. Otherwise, returns an empty value.</source>
          <target state="translated">이 이벤트가 호출 된 상태 머신에 의해 생성되면 &lt;code&gt;&amp;lt;invoke&amp;gt;&lt;/code&gt; 요소 의 ID를 리턴합니다 . 그렇지 않으면 빈 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0d4857d53d9065e2874e668ab9f34f6cd2d679ca" translate="yes" xml:space="preserve">
          <source>If this factory is set as the application proxy factory, DefaultProxy and NoProxy will have the same meaning.</source>
          <target state="translated">이 팩토리가 애플리케이션 프록시 팩토리로 설정되면 DefaultProxy와 NoProxy는 동일한 의미를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="9d182d4a2baf3d5332a07e1fbaef27e75283ea71" translate="yes" xml:space="preserve">
          <source>If this feedback type is locked, or if the supplied path is inaccessible, this function will return false. In addition, some forms of feedback may be non-auditory (e.g. a red light, or a vibration), and false may be returned in this case.</source>
          <target state="translated">이 피드백 유형이 잠겨 있거나 제공된 경로에 액세스 할 수 없으면이 함수는 false를 리턴합니다. 또한, 일부 형태의 피드백은 청각이 아닌 것 (예 : 빨간불 또는 진동) 일 수 있으며,이 경우 거짓이 반환 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b007b40752ee82cb0cd4cc3f74836437cb1f6137" translate="yes" xml:space="preserve">
          <source>If this flag is set &lt;a href=&quot;qnetworksession&quot;&gt;QNetworkSession&lt;/a&gt; can provide statistics about transmitted and received data.</source>
          <target state="translated">이 플래그가 설정 &lt;a href=&quot;qnetworksession&quot;&gt;되면 QNetworkSession&lt;/a&gt; 은 전송 및 수신 된 데이터에 대한 통계를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="536b485470f29bb3272c5d5131381a9a509c0dc1" translate="yes" xml:space="preserve">
          <source>If this flag is set QNetworkSession can provide statistics about transmitted and received data.</source>
          <target state="translated">이 플래그가 설정되면 QNetworkSession은 전송 및 수신 데이터에 대한 통계를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c6a1b0729956a68d34a6e55a0319486c2f2c7320" translate="yes" xml:space="preserve">
          <source>If this flag is set the platform requires that a network session is created before network operations can be performed.</source>
          <target state="translated">이 플래그가 설정되면 플랫폼에서 네트워크 작업을 수행하기 전에 네트워크 세션을 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="90d4e238159e0b79b1b1b2aa4f1eed26f9f7cf85" translate="yes" xml:space="preserve">
          <source>If this flag is set the underlying platform ensures that a network interface is not shut down until the last network session has been &lt;a href=&quot;qnetworksession#close&quot;&gt;closed()&lt;/a&gt;. This works across multiple processes. If the platform session support is missing this API can only ensure the above behavior for network sessions within the same process. In general mobile platforms have such support whereas most desktop platform lack this capability.</source>
          <target state="translated">이 플래그가 설정되면 기본 플랫폼은 마지막 네트워크 세션이 &lt;a href=&quot;qnetworksession#close&quot;&gt;닫힐&lt;/a&gt; 때까지 네트워크 인터페이스가 종료되지 않도록합니다 () . 이것은 여러 프로세스에서 작동합니다. 플랫폼 세션 지원이 누락 된 경우이 API는 동일한 프로세스 내에서 네트워크 세션에 대해 위의 동작 만 보장 할 수 있습니다. 일반적으로 모바일 플랫폼은 이러한 지원을 제공하지만 대부분의 데스크톱 플랫폼에는이 기능이 없습니다.</target>
        </trans-unit>
        <trans-unit id="bdda8d08cd5c10dfd8cd6d2ddeb18d927c2068a6" translate="yes" xml:space="preserve">
          <source>If this flag is set, each invalid input character is output as a null character.</source>
          <target state="translated">이 플래그가 설정되면 유효하지 않은 각 입력 문자가 널 문자로 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="f18d7cf7eb3f34715daac231b49f5cedacd7e31a" translate="yes" xml:space="preserve">
          <source>If this flag is true then the text is visible. Otherwise, the text is not visible. The default value is false.</source>
          <target state="translated">이 플래그가 true이면 텍스트가 표시됩니다. 그렇지 않으면 텍스트가 보이지 않습니다. 기본값은 false입니다.</target>
        </trans-unit>
        <trans-unit id="ff610eb2bf55339d908363381e9cb29081d926b4" translate="yes" xml:space="preserve">
          <source>If this function is called multiple times using the same service UUID, the returned &lt;a href=&quot;qlowenergyservice&quot;&gt;QLowEnergyService&lt;/a&gt; instances share their internal data. Therefore if one of the instances initiates the discovery of the service details, the other instances automatically transition into the discovery state too.</source>
          <target state="translated">동일한 서비스 UUID를 사용하여이 함수를 여러 번 호출하면 리턴 된 &lt;a href=&quot;qlowenergyservice&quot;&gt;QLowEnergyService&lt;/a&gt; 인스턴스는 내부 데이터를 공유합니다. 따라서 인스턴스 중 하나가 서비스 세부 사항 감지를 시작하면 다른 인스턴스도 자동으로 감지 상태로 전환됩니다.</target>
        </trans-unit>
        <trans-unit id="f7879e8d02354fbd2103da22eb31905aabec6cae" translate="yes" xml:space="preserve">
          <source>If this function is called on a list that is currently being shared, it will trigger a copy of all elements. Otherwise, this function runs in &lt;a href=&quot;containers#algorithmic-complexity&quot;&gt;constant time&lt;/a&gt;. If you do not want to modify the list you should use &lt;a href=&quot;qlist#at&quot;&gt;QList::at&lt;/a&gt;().</source>
          <target state="translated">이 함수가 현재 공유중인 목록에서 호출되면 모든 요소의 사본을 트리거합니다. 그렇지 않으면이 함수는 &lt;a href=&quot;containers#algorithmic-complexity&quot;&gt;일정한 시간에&lt;/a&gt; 실행됩니다 . 목록을 수정하지 않으려면 &lt;a href=&quot;qlist#at&quot;&gt;QList :: at&lt;/a&gt; () 을 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="4fb5e9bb72b017102b2808c65c6d6dea0725bd6f" translate="yes" xml:space="preserve">
          <source>If this function is called with</source>
          <target state="translated">이 함수를 호출하면</target>
        </trans-unit>
        <trans-unit id="f91cb5744d398e52feaa693013ed3ca3a7ac9685" translate="yes" xml:space="preserve">
          <source>If this function is called, SSL errors related to network connection will be ignored, including certificate validation errors.</source>
          <target state="translated">이 함수를 호출하면 인증서 유효성 검사 오류를 포함하여 네트워크 연결과 관련된 SSL 오류가 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="94fa93e45babc95b874186ce2a35c452fd1cf405" translate="yes" xml:space="preserve">
          <source>If this function is called, the SSL errors given in</source>
          <target state="translated">이 함수가 호출되면 SSL 오류는</target>
        </trans-unit>
        <trans-unit id="6130ddf78fcfc44bf8cf8b228b0641a9113a401f" translate="yes" xml:space="preserve">
          <source>If this function is not called before connecting, a default register with zero entries is setup.</source>
          <target state="translated">연결하기 전에이 기능을 호출하지 않으면 항목이 0 인 기본 레지스터가 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="c7d49145b3374b46f275e6cd40fa4ab53d2973e2" translate="yes" xml:space="preserve">
          <source>If this function is overridden for comments or processing instructions, it is important to remember to call it (for elements and attributes having values not of type &lt;code&gt;xs:string&lt;/code&gt;) to ensure that the values are formatted according to &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt;.</source>
          <target state="translated">이 함수가 주석 또는 처리 명령에 대해 재정의 된 경우 값이 &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt; 에 따라 형식이 지정되도록하려면 ( &lt;code&gt;xs:string&lt;/code&gt; 형식이 아닌 값을 가진 요소 및 속성에 대해) 호출하는 것을 기억하는 것이 중요합니다 .</target>
        </trans-unit>
        <trans-unit id="8be18d1fd72107f1ae3ddd1e1583843d59047b6a" translate="yes" xml:space="preserve">
          <source>If this function is overridden for comments or processing instructions, it is important to remember to call it (for elements and attributes having values not of type &lt;code&gt;xs:string&lt;/code&gt;) to ensure that the values are formatted according to &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt;.</source>
          <target state="translated">주석 또는 처리 지시 사항에 대해이 함수를 대체하는 경우 &lt;code&gt;xs:string&lt;/code&gt; 유형이 아닌 값을 갖는 요소 및 속성에 대해이 함수를 호출 하여 값이 &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt; 에 따라 형식화되도록해야합니다 .</target>
        </trans-unit>
        <trans-unit id="4c6713cc7e7306d8b961a414c06e6f6018006d35" translate="yes" xml:space="preserve">
          <source>If this function reenters the Qt event loop in order to wait for the reply, it will exclude user input. During the wait, it may deliver signals and other method calls to your application. Therefore, it must be prepared to handle a reentrancy whenever a call is placed with &lt;a href=&quot;qdbusabstractinterface#call&quot;&gt;call&lt;/a&gt;().</source>
          <target state="translated">이 함수는 응답을 기다리기 위해 Qt 이벤트 루프를 다시 입력하면 사용자 입력을 제외합니다. 대기 중에 신호 및 기타 메소드 호출을 애플리케이션에 전달할 수 있습니다. 따라서,이 호출에 배치 될 때마다 재 입력을 처리 할 준비가되어 있어야 &lt;a href=&quot;qdbusabstractinterface#call&quot;&gt;호&lt;/a&gt; ().</target>
        </trans-unit>
        <trans-unit id="f7db9febd836618fa194f5cf6a9c27c25ec10220" translate="yes" xml:space="preserve">
          <source>If this function reenters the Qt event loop in order to wait for the reply, it will exclude user input. During the wait, it may deliver signals and other method calls to your application. Therefore, it must be prepared to handle a reentrancy whenever a call is placed with call().</source>
          <target state="translated">이 함수가 응답을 기다리기 위해 Qt 이벤트 루프에 다시 들어가면 사용자 입력을 제외합니다. 대기 중에 신호 및 기타 메서드 호출을 애플리케이션에 전달할 수 있습니다. 따라서 call ()로 호출 할 때마다 재진입을 처리 할 준비가되어 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="e603b59cbba45370eddf18ab6bb8c5b0293b6dd2" translate="yes" xml:space="preserve">
          <source>If this function returns &lt;a href=&quot;qresource#Compression-enum&quot;&gt;QResource::ZlibCompression&lt;/a&gt;, you may decompress the data using the &lt;a href=&quot;qbytearray#qUncompress&quot;&gt;qUncompress&lt;/a&gt;() function. Up until Qt 5.13, this was the only possible compression algorithm.</source>
          <target state="translated">이 함수가 &lt;a href=&quot;qresource#Compression-enum&quot;&gt;QResource :: ZlibCompression을&lt;/a&gt; 반환 하면 &lt;a href=&quot;qbytearray#qUncompress&quot;&gt;qUncompress&lt;/a&gt; () 함수를 사용하여 데이터를 압축 해제 할 수 있습니다. Qt 5.13까지는 이것이 유일한 압축 알고리즘이었습니다.</target>
        </trans-unit>
        <trans-unit id="fa146cc91a9fa3c6029b7e389aed26f912443b82" translate="yes" xml:space="preserve">
          <source>If this function returns &lt;a href=&quot;qresource#Compression-enum&quot;&gt;QResource::ZstdCompression&lt;/a&gt;, you need to use the Zstandard library functios (&lt;code&gt;&amp;lt;zstd.h&amp;gt; header). Qt does not provide a wrapper. See \l{http://facebook.github.io/zstd/zstd_manual.html}{Zstandard manual}. \sa data(), isFile()&lt;/code&gt;</source>
          <target state="translated">이 함수가 &lt;a href=&quot;qresource#Compression-enum&quot;&gt;QResource :: ZstdCompression을&lt;/a&gt; 반환 하는 경우 Zstandard 라이브러리 함수 ( &lt;code&gt;&amp;lt;zstd.h&amp;gt; header). Qt does not provide a wrapper. See \l{http://facebook.github.io/zstd/zstd_manual.html}{Zstandard manual}. \sa data(), isFile()&lt;/code&gt; 를 사용해야합니다 . Qt는 래퍼를 제공하지 않습니다. \ l {http://facebook.github.io/zstd/zstd_manual.html} {Zstandard 매뉴얼}을 참조하세요. \ sa data (), isFile ()</target>
        </trans-unit>
        <trans-unit id="1cd0271cbb54ac383049c5e16c4caec54713733b" translate="yes" xml:space="preserve">
          <source>If this function returns &lt;a href=&quot;qresource#Compression-enum&quot;&gt;QResource::ZstdCompression&lt;/a&gt;, you need to use the Zstandard library functios (&lt;code&gt;&amp;lt;zstd.h&amp;gt; header). Qt does not provide a wrapper. See \l{http://facebook.github.io/zstd/zstd_manual.html}{Zstandard manual}. \sa isCompressed(), data(), isFile()&lt;/code&gt;</source>
          <target state="translated">이 함수가 &lt;a href=&quot;qresource#Compression-enum&quot;&gt;QResource :: ZstdCompression을&lt;/a&gt; 리턴 하면 Zstandard 라이브러리 functios ( &lt;code&gt;&amp;lt;zstd.h&amp;gt; header). Qt does not provide a wrapper. See \l{http://facebook.github.io/zstd/zstd_manual.html}{Zstandard manual}. \sa isCompressed(), data(), isFile()&lt;/code&gt; 를 사용해야합니다 . Qt는 래퍼를 제공하지 않습니다. \ l {http://facebook.github.io/zstd/zstd_manual.html} {Zstandard manual}을 참조하십시오. \ sa isCompressed (), data (), isFile ()</target>
        </trans-unit>
        <trans-unit id="2720222c7b7a6d74d21eaa2178869bd546acc364" translate="yes" xml:space="preserve">
          <source>If this function returns &lt;code&gt;false&lt;/code&gt; the reader stops parsing and reports an error. The reader uses the function &lt;a href=&quot;qxmlcontenthandler#errorString&quot;&gt;errorString&lt;/a&gt;() to get the error message.</source>
          <target state="translated">이 함수가 &lt;code&gt;false&lt;/code&gt; 를 반환 하면 판독기는 구문 분석을 중지하고 오류를보고합니다. 리더는 &lt;a href=&quot;qxmlcontenthandler#errorString&quot;&gt;errorString&lt;/a&gt; () 함수를 사용 하여 오류 메시지를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="fcddf8acaf07868f57dc4ba56319d57b2c9c54b3" translate="yes" xml:space="preserve">
          <source>If this function returns &lt;code&gt;false&lt;/code&gt; the reader stops parsing and reports an error. The reader uses the function &lt;a href=&quot;qxmldeclhandler#errorString&quot;&gt;errorString&lt;/a&gt;() to get the error message.</source>
          <target state="translated">이 함수가 &lt;code&gt;false&lt;/code&gt; 를 반환 하면 판독기는 구문 분석을 중지하고 오류를보고합니다. 리더는 &lt;a href=&quot;qxmldeclhandler#errorString&quot;&gt;errorString&lt;/a&gt; () 함수를 사용 하여 오류 메시지를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="028af623fa60d47c39a10c79e2e1ead8c643e45a" translate="yes" xml:space="preserve">
          <source>If this function returns &lt;code&gt;false&lt;/code&gt; the reader stops parsing and reports an error. The reader uses the function &lt;a href=&quot;qxmldtdhandler#errorString&quot;&gt;errorString&lt;/a&gt;() to get the error message.</source>
          <target state="translated">이 함수가 &lt;code&gt;false&lt;/code&gt; 를 반환 하면 판독기는 구문 분석을 중지하고 오류를보고합니다. 리더는 &lt;a href=&quot;qxmldtdhandler#errorString&quot;&gt;errorString&lt;/a&gt; () 함수를 사용 하여 오류 메시지를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="b0c68f8c86bc7f57b051f6e92f9c42b97a17b57e" translate="yes" xml:space="preserve">
          <source>If this function returns &lt;code&gt;false&lt;/code&gt; the reader stops parsing and reports an error. The reader uses the function &lt;a href=&quot;qxmlentityresolver#errorString&quot;&gt;errorString&lt;/a&gt;() to get the error message.</source>
          <target state="translated">이 함수가 &lt;code&gt;false&lt;/code&gt; 를 반환 하면 판독기는 구문 분석을 중지하고 오류를보고합니다. 리더는 &lt;a href=&quot;qxmlentityresolver#errorString&quot;&gt;errorString&lt;/a&gt; () 함수를 사용 하여 오류 메시지를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="84b29eab57b4a6b4f0c7fc15ccf37eec07bbffc8" translate="yes" xml:space="preserve">
          <source>If this function returns &lt;code&gt;false&lt;/code&gt; the reader stops parsing and reports an error. The reader uses the function &lt;a href=&quot;qxmlerrorhandler#errorString&quot;&gt;errorString&lt;/a&gt;() to get the error message.</source>
          <target state="translated">이 함수가 &lt;code&gt;false&lt;/code&gt; 를 반환 하면 판독기는 구문 분석을 중지하고 오류를보고합니다. 리더는 &lt;a href=&quot;qxmlerrorhandler#errorString&quot;&gt;errorString&lt;/a&gt; () 함수를 사용 하여 오류 메시지를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="a71d54a9ea4dbed2be3c31b87232a2695569a435" translate="yes" xml:space="preserve">
          <source>If this function returns &lt;code&gt;false&lt;/code&gt; the reader stops parsing and reports an error. The reader uses the function &lt;a href=&quot;qxmllexicalhandler#errorString&quot;&gt;errorString&lt;/a&gt;() to get the error message.</source>
          <target state="translated">이 함수가 &lt;code&gt;false&lt;/code&gt; 를 반환 하면 판독기는 구문 분석을 중지하고 오류를보고합니다. 리더는 &lt;a href=&quot;qxmllexicalhandler#errorString&quot;&gt;errorString&lt;/a&gt; () 함수를 사용 하여 오류 메시지를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="4cd05a7a23aedcbde3503deb9d1808e37ae31532" translate="yes" xml:space="preserve">
          <source>If this function returns &lt;code&gt;true&lt;/code&gt; the reader might try to go on parsing and reporting further errors, but no regular parsing events are reported.</source>
          <target state="translated">이 함수가 &lt;code&gt;true&lt;/code&gt; 를 반환 하면 판독기는 구문 분석을 진행하여 추가 오류를보고하려고하지만 정기적 인 구문 분석 이벤트는보고되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4cc482e9071cedb1f98a9a3d694b63223ebf8b37" translate="yes" xml:space="preserve">
          <source>If this function returns &lt;code&gt;true&lt;/code&gt;, calling this command's &lt;a href=&quot;qundocommand#redo&quot;&gt;redo&lt;/a&gt;() must have the same effect as redoing both this command and</source>
          <target state="translated">이 함수가 &lt;code&gt;true&lt;/code&gt; 를 반환하면이 명령의 &lt;a href=&quot;qundocommand#redo&quot;&gt;redo&lt;/a&gt; () 호출 은이 명령과</target>
        </trans-unit>
        <trans-unit id="6a2cbaac2f346dcd81ffcb535bd81026fbcbc2bc" translate="yes" xml:space="preserve">
          <source>If this function returns &lt;code&gt;true&lt;/code&gt;, it does not imply that this object is a &lt;a href=&quot;qdomcdatasection&quot;&gt;QDomCDATASection&lt;/a&gt;; you can get the &lt;a href=&quot;qdomcdatasection&quot;&gt;QDomCDATASection&lt;/a&gt; with &lt;a href=&quot;qdomnode#toCDATASection&quot;&gt;toCDATASection&lt;/a&gt;().</source>
          <target state="translated">이 함수가 &lt;code&gt;true&lt;/code&gt; 를 돌려주는 경우 ,이 객체가 &lt;a href=&quot;qdomcdatasection&quot;&gt;QDomCDATASection 인&lt;/a&gt; 것은 아닙니다 . &lt;a href=&quot;qdomnode#toCDATASection&quot;&gt;toCDATASection&lt;/a&gt; ()을 사용 하여 &lt;a href=&quot;qdomcdatasection&quot;&gt;QDomCDATASection&lt;/a&gt; 을 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8d4a2d20f499d5ff415391aa5ec5deb1d88108f6" translate="yes" xml:space="preserve">
          <source>If this function returns &lt;code&gt;true&lt;/code&gt;, it does not imply that this object is a &lt;a href=&quot;qdomcharacterdata&quot;&gt;QDomCharacterData&lt;/a&gt;; you can get the &lt;a href=&quot;qdomcharacterdata&quot;&gt;QDomCharacterData&lt;/a&gt; with &lt;a href=&quot;qdomnode#toCharacterData&quot;&gt;toCharacterData&lt;/a&gt;().</source>
          <target state="translated">이 함수가 &lt;code&gt;true&lt;/code&gt; 를 돌려주는 경우 ,이 객체가 &lt;a href=&quot;qdomcharacterdata&quot;&gt;QDomCharacterData 인&lt;/a&gt; 것을 암시하지 않습니다 . 당신이 얻을 수있는 &lt;a href=&quot;qdomcharacterdata&quot;&gt;QDomCharacterData&lt;/a&gt; 와 &lt;a href=&quot;qdomnode#toCharacterData&quot;&gt;toCharacterData을&lt;/a&gt; ().</target>
        </trans-unit>
        <trans-unit id="3c2639809daacdf02594367f4d9914ce2bdef140" translate="yes" xml:space="preserve">
          <source>If this function returns &lt;code&gt;true&lt;/code&gt;, it does not imply that this object is a &lt;a href=&quot;qdomcomment&quot;&gt;QDomComment&lt;/a&gt;; you can get the &lt;a href=&quot;qdomcomment&quot;&gt;QDomComment&lt;/a&gt; with &lt;a href=&quot;qdomnode#toComment&quot;&gt;toComment&lt;/a&gt;().</source>
          <target state="translated">이 함수가 &lt;code&gt;true&lt;/code&gt; 를 돌려주는 경우 ,이 객체가 &lt;a href=&quot;qdomcomment&quot;&gt;QDomComment 인&lt;/a&gt; 것은 아닙니다 . 당신이 얻을 수있는 &lt;a href=&quot;qdomcomment&quot;&gt;QDomComment&lt;/a&gt; 와 &lt;a href=&quot;qdomnode#toComment&quot;&gt;toComment을&lt;/a&gt; ().</target>
        </trans-unit>
        <trans-unit id="89a7739b87ece5c94d20517b4fe2bb90ce4947e0" translate="yes" xml:space="preserve">
          <source>If this function returns &lt;code&gt;true&lt;/code&gt;, it does not imply that this object is a &lt;a href=&quot;qdomdocument&quot;&gt;QDomDocument&lt;/a&gt;; you can get the &lt;a href=&quot;qdomdocument&quot;&gt;QDomDocument&lt;/a&gt; with &lt;a href=&quot;qdomnode#toDocument&quot;&gt;toDocument&lt;/a&gt;().</source>
          <target state="translated">이 함수가 &lt;code&gt;true&lt;/code&gt; 를 돌려주는 경우 ,이 객체가 &lt;a href=&quot;qdomdocument&quot;&gt;QDomDocument 인&lt;/a&gt; 것을 암시하지 않습니다 . 당신이 얻을 수있는 &lt;a href=&quot;qdomdocument&quot;&gt;QDomDocument&lt;/a&gt; 와 &lt;a href=&quot;qdomnode#toDocument&quot;&gt;toDocument을&lt;/a&gt; ().</target>
        </trans-unit>
        <trans-unit id="b116415fc59a62fb2a6d244f21de8b751ddf0070" translate="yes" xml:space="preserve">
          <source>If this function returns &lt;code&gt;true&lt;/code&gt;, it does not imply that this object is a &lt;a href=&quot;qdomdocumentfragment&quot;&gt;QDomDocumentFragment&lt;/a&gt;; you can get the &lt;a href=&quot;qdomdocumentfragment&quot;&gt;QDomDocumentFragment&lt;/a&gt; with &lt;a href=&quot;qdomnode#toDocumentFragment&quot;&gt;toDocumentFragment&lt;/a&gt;().</source>
          <target state="translated">이 함수가 &lt;code&gt;true&lt;/code&gt; 를 돌려주는 경우 ,이 객체가 &lt;a href=&quot;qdomdocumentfragment&quot;&gt;QDomDocumentFragment 인&lt;/a&gt; 것은 아닙니다 . &lt;a href=&quot;qdomnode#toDocumentFragment&quot;&gt;toDocumentFragment&lt;/a&gt; ()를 사용 하여 &lt;a href=&quot;qdomdocumentfragment&quot;&gt;QDomDocumentFragment&lt;/a&gt; 를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="856b2962d362d85186f9d74b0d8f9d84bbe10e31" translate="yes" xml:space="preserve">
          <source>If this function returns &lt;code&gt;true&lt;/code&gt;, it does not imply that this object is a &lt;a href=&quot;qdomdocumenttype&quot;&gt;QDomDocumentType&lt;/a&gt;; you can get the &lt;a href=&quot;qdomdocumenttype&quot;&gt;QDomDocumentType&lt;/a&gt; with &lt;a href=&quot;qdomnode#toDocumentType&quot;&gt;toDocumentType&lt;/a&gt;().</source>
          <target state="translated">이 함수가 &lt;code&gt;true&lt;/code&gt; 를 돌려주는 경우 ,이 객체가 &lt;a href=&quot;qdomdocumenttype&quot;&gt;QDomDocumentType 인&lt;/a&gt; 것은 아닙니다 . 당신이 얻을 수있는 &lt;a href=&quot;qdomdocumenttype&quot;&gt;QDomDocumentType&lt;/a&gt; 와 &lt;a href=&quot;qdomnode#toDocumentType&quot;&gt;toDocumentType을&lt;/a&gt; ().</target>
        </trans-unit>
        <trans-unit id="aefa7944392df1598e5d53823e8535cc29b8a34a" translate="yes" xml:space="preserve">
          <source>If this function returns &lt;code&gt;true&lt;/code&gt;, it does not imply that this object is a &lt;a href=&quot;qdomelement&quot;&gt;QDomElement&lt;/a&gt;; you can get the &lt;a href=&quot;qdomelement&quot;&gt;QDomElement&lt;/a&gt; with &lt;a href=&quot;qdomnode#toElement&quot;&gt;toElement&lt;/a&gt;().</source>
          <target state="translated">이 함수가 &lt;code&gt;true&lt;/code&gt; 를 돌려주는 경우 ,이 객체가 &lt;a href=&quot;qdomelement&quot;&gt;QDomElement 인&lt;/a&gt; 것은 아닙니다 . &lt;a href=&quot;qdomnode#toElement&quot;&gt;toElement&lt;/a&gt; ()로 &lt;a href=&quot;qdomelement&quot;&gt;QDomElement&lt;/a&gt; 를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6c227a4dfd83f54195b659f74de8af2bcb0c349b" translate="yes" xml:space="preserve">
          <source>If this function returns &lt;code&gt;true&lt;/code&gt;, it does not imply that this object is a &lt;a href=&quot;qdomentity&quot;&gt;QDomEntity&lt;/a&gt;; you can get the &lt;a href=&quot;qdomentity&quot;&gt;QDomEntity&lt;/a&gt; with &lt;a href=&quot;qdomnode#toEntity&quot;&gt;toEntity&lt;/a&gt;().</source>
          <target state="translated">이 함수가 &lt;code&gt;true&lt;/code&gt; 를 돌려주는 경우 ,이 객체가 &lt;a href=&quot;qdomentity&quot;&gt;QDomEntity 인&lt;/a&gt; 것을 암시하지 않습니다 . 당신이 얻을 수있는 &lt;a href=&quot;qdomentity&quot;&gt;QDomEntity&lt;/a&gt; 와 &lt;a href=&quot;qdomnode#toEntity&quot;&gt;toEntity을&lt;/a&gt; ().</target>
        </trans-unit>
        <trans-unit id="a3bf164135d2e8da210c8452aaf3ed73ca085479" translate="yes" xml:space="preserve">
          <source>If this function returns &lt;code&gt;true&lt;/code&gt;, it does not imply that this object is a &lt;a href=&quot;qdomentityreference&quot;&gt;QDomEntityReference&lt;/a&gt;; you can get the &lt;a href=&quot;qdomentityreference&quot;&gt;QDomEntityReference&lt;/a&gt; with &lt;a href=&quot;qdomnode#toEntityReference&quot;&gt;toEntityReference&lt;/a&gt;().</source>
          <target state="translated">이 함수가 &lt;code&gt;true&lt;/code&gt; 를 돌려주는 경우 ,이 객체가 &lt;a href=&quot;qdomentityreference&quot;&gt;QDomEntityReference 인&lt;/a&gt; 것은 아닙니다 . &lt;a href=&quot;qdomnode#toEntityReference&quot;&gt;toEntityReference&lt;/a&gt; ()를 사용 하여 &lt;a href=&quot;qdomentityreference&quot;&gt;QDomEntityReference&lt;/a&gt; 를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="079bf6f1eb63f64d888b70722156501225c2ef17" translate="yes" xml:space="preserve">
          <source>If this function returns &lt;code&gt;true&lt;/code&gt;, it does not imply that this object is a &lt;a href=&quot;qdomnotation&quot;&gt;QDomNotation&lt;/a&gt;; you can get the &lt;a href=&quot;qdomnotation&quot;&gt;QDomNotation&lt;/a&gt; with &lt;a href=&quot;qdomnode#toNotation&quot;&gt;toNotation&lt;/a&gt;().</source>
          <target state="translated">이 함수가 &lt;code&gt;true&lt;/code&gt; 를 돌려주는 경우 ,이 객체가 &lt;a href=&quot;qdomnotation&quot;&gt;QDomNotation 인&lt;/a&gt; 것은 아닙니다 . 당신이 얻을 수있는 &lt;a href=&quot;qdomnotation&quot;&gt;QDomNotation&lt;/a&gt; 와 &lt;a href=&quot;qdomnode#toNotation&quot;&gt;toNotation을&lt;/a&gt; ().</target>
        </trans-unit>
        <trans-unit id="0f952201b97f2c57661c6197841bcfec40b20868" translate="yes" xml:space="preserve">
          <source>If this function returns &lt;code&gt;true&lt;/code&gt;, it does not imply that this object is a &lt;a href=&quot;qdomprocessinginstruction&quot;&gt;QDomProcessingInstruction&lt;/a&gt;; you can get the QProcessingInstruction with &lt;a href=&quot;qdomnode#toProcessingInstruction&quot;&gt;toProcessingInstruction&lt;/a&gt;().</source>
          <target state="translated">이 함수가 &lt;code&gt;true&lt;/code&gt; 를 돌려주는 경우 ,이 객체가 &lt;a href=&quot;qdomprocessinginstruction&quot;&gt;QDomProcessingInstruction 인&lt;/a&gt; 것을 암시하지 않습니다 . &lt;a href=&quot;qdomnode#toProcessingInstruction&quot;&gt;toProcessingInstruction&lt;/a&gt; ()을 사용 하여 QProcessingInstruction을 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9ad6203018365885172c42781803dadb77e57da6" translate="yes" xml:space="preserve">
          <source>If this function returns &lt;code&gt;true&lt;/code&gt;, it does not imply that this object is a &lt;a href=&quot;qdomtext&quot;&gt;QDomText&lt;/a&gt;; you can get the &lt;a href=&quot;qdomtext&quot;&gt;QDomText&lt;/a&gt; with &lt;a href=&quot;qdomnode#toText&quot;&gt;toText&lt;/a&gt;().</source>
          <target state="translated">이 함수가 &lt;code&gt;true&lt;/code&gt; 를 돌려주는 경우 ,이 객체가 &lt;a href=&quot;qdomtext&quot;&gt;QDomText 인&lt;/a&gt; 것을 암시하지 않습니다 . 당신이 얻을 수있는 &lt;a href=&quot;qdomtext&quot;&gt;QDomText&lt;/a&gt; 와 &lt;a href=&quot;qdomnode#toText&quot;&gt;toText을&lt;/a&gt; ().</target>
        </trans-unit>
        <trans-unit id="9e97aef4a84c69dc49766a3668d2dce72d3bb296" translate="yes" xml:space="preserve">
          <source>If this function returns &lt;code&gt;true&lt;/code&gt;, it does not imply that this object is a QDomAttribute; you can get the QDomAttribute with toAttribute().</source>
          <target state="translated">이 함수가 &lt;code&gt;true&lt;/code&gt; 를 돌려주는 경우 ,이 객체가 QDomAttribute 인 것을 암시하지 않습니다. toAttribute ()로 QDomAttribute를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd5a0518c7b1f26077c80c75a78d04d94e2624a8" translate="yes" xml:space="preserve">
          <source>If this geocoding manager supports returning the results in different languages, they will be returned in the language of</source>
          <target state="translated">이 지오 코딩 관리자가 다른 언어로 결과를 반환하도록 지원하는 경우 다음 언어로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="b0028fe7e19ede2f06abba25ce80fe90d44aff9e" translate="yes" xml:space="preserve">
          <source>If this handler has already grabbed the given</source>
          <target state="translated">이 핸들러가 이미 주어진 것을 잡은 경우</target>
        </trans-unit>
        <trans-unit id="94bd5291f8b8d70d7d41a3419e8d262510429fb4" translate="yes" xml:space="preserve">
          <source>If this information could not be determined, this function returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">이 정보를 확인할 수 없으면이 함수는 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="71a2cb154c93b9cc5c6d481d10d96549a9a78584" translate="yes" xml:space="preserve">
          <source>If this information is not available, false is returned.</source>
          <target state="translated">이 정보를 사용할 수 없으면 false가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="d958f1bcdcd203676780637c380bd5db80cf093b" translate="yes" xml:space="preserve">
          <source>If this is &lt;code&gt;true&lt;/code&gt; and the session manager allows user interaction, &lt;a href=&quot;qguiapplication&quot;&gt;QGuiApplication&lt;/a&gt; will try to close toplevel windows after &lt;a href=&quot;qguiapplication#commitDataRequest&quot;&gt;commitDataRequest&lt;/a&gt;() has been emitted. If a window cannot be closed, session shutdown will be canceled and the application will keep running.</source>
          <target state="translated">이것이 &lt;code&gt;true&lt;/code&gt; 이고 세션 관리자가 사용자 상호 작용을 허용하면 &lt;a href=&quot;qguiapplication&quot;&gt;QGuiApplication&lt;/a&gt; 은 &lt;a href=&quot;qguiapplication#commitDataRequest&quot;&gt;commitDataRequest&lt;/a&gt; ()가 생성 된 후 최상위 창을 닫으려고 시도합니다 . 창을 닫을 수 없으면 세션 종료가 취소되고 응용 프로그램이 계속 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="e7d9fdc08c06206ec6fa17debb213d91bb54c778" translate="yes" xml:space="preserve">
          <source>If this is &lt;code&gt;true&lt;/code&gt;, the user can navigate the view with a keyboard. It is useful for applications that need to selectively enable or disable mouse and keyboard interaction.</source>
          <target state="translated">이것이 &lt;code&gt;true&lt;/code&gt; 이면 사용자는 키보드로보기를 탐색 할 수 있습니다. 마우스 및 키보드 상호 작용을 선택적으로 활성화 또는 비활성화해야하는 응용 프로그램에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="c4503eabf56d16492da15f185410febbdc98a114" translate="yes" xml:space="preserve">
          <source>If this is a native widget, return the associated &lt;a href=&quot;qwindow&quot;&gt;QWindow&lt;/a&gt;. Otherwise return null.</source>
          <target state="translated">이것이 고유 위젯 인 경우 연관된 &lt;a href=&quot;qwindow&quot;&gt;QWindow를&lt;/a&gt; 리턴하십시오 . 그렇지 않으면 null을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="94aa942a004d3d6a0bd80dab35ff7ec3a6b53492" translate="yes" xml:space="preserve">
          <source>If this is an error event, returns the error message. Otherwise, returns an empty &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;.</source>
          <target state="translated">이것이 오류 이벤트 인 경우 오류 메시지를 리턴합니다. 그렇지 않으면 빈 &lt;a href=&quot;qstring&quot;&gt;QString을&lt;/a&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="e50b5d9c244ef985dbe2abaabed31d940f75e23f" translate="yes" xml:space="preserve">
          <source>If this is an error event, the</source>
          <target state="translated">이것이 오류 이벤트 인 경우</target>
        </trans-unit>
        <trans-unit id="8cae1e6634be6205e65e489444a4a659625fa553" translate="yes" xml:space="preserve">
          <source>If this is an outgoing datagram, this is the value to be set in the IP header upon sending. A value of -1 indicates the operating system should choose the value.</source>
          <target state="translated">나가는 데이터 그램 인 경우 전송시 IP 헤더에 설정되는 값입니다. 값이 -1이면 운영 체제가 값을 선택해야 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="17b7d08c9b60e6c4dcbddbf93fa461fcf9c064f9" translate="yes" xml:space="preserve">
          <source>If this is an outgoing packet, this is the index of the interface the datagram should be sent on. A value of 0 indicates that the operating system should choose the interface based on other factors.</source>
          <target state="translated">이것이 나가는 패킷 인 경우, 데이터 그램을 보내야하는 인터페이스의 인덱스입니다. 값이 0이면 운영 체제가 다른 요인에 따라 인터페이스를 선택해야 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e88532aa061457683da78a6edb4997b8f342541b" translate="yes" xml:space="preserve">
          <source>If this is an outgoing packet, this is the value to be set in the IP header upon sending. The valid range for the value is 1 to 255. This function also accepts a value of -1 to indicate that the operating system should choose the value.</source>
          <target state="translated">이것이 나가는 패킷 인 경우 전송시 IP 헤더에 설정되는 값입니다. 값의 유효 범위는 1-255입니다.이 기능은 또한 -1 값을 허용하여 운영 체제가 값을 선택해야 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f4713b9b31b7938466b082eee9debbdb3782385f" translate="yes" xml:space="preserve">
          <source>If this is false, then the item will not receive any hover events through the &lt;a href=&quot;qquickitem#hoverEnterEvent&quot;&gt;hoverEnterEvent&lt;/a&gt;(), &lt;a href=&quot;qquickitem#hoverMoveEvent&quot;&gt;hoverMoveEvent&lt;/a&gt;() and &lt;a href=&quot;qquickitem#hoverLeaveEvent&quot;&gt;hoverLeaveEvent&lt;/a&gt;() functions.</source>
          <target state="translated">이 값이 false이면 &lt;a href=&quot;qquickitem#hoverEnterEvent&quot;&gt;hoverEnterEvent&lt;/a&gt; (), &lt;a href=&quot;qquickitem#hoverMoveEvent&quot;&gt;hoverMoveEvent&lt;/a&gt; () 및 &lt;a href=&quot;qquickitem#hoverLeaveEvent&quot;&gt;hoverLeaveEvent&lt;/a&gt; () 함수를 통해 항목에 호버 이벤트가 수신되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="9b5259a7c1135883647972c96ff1dd8900a9865e" translate="yes" xml:space="preserve">
          <source>If this is false, then the item will not receive any touch events through the &lt;a href=&quot;qquickitem#touchEvent&quot;&gt;touchEvent&lt;/a&gt;() function.</source>
          <target state="translated">이 값이 false이면 &lt;a href=&quot;qquickitem#touchEvent&quot;&gt;touchEvent&lt;/a&gt; () 함수를 통해 항목에 터치 이벤트가 수신되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="db4d637575b01faa2f265615ae1992ad8362ef9b" translate="yes" xml:space="preserve">
          <source>If this is not sufficient we can implement our own wrapper classes thanks to the C++ extensions provided by Microsoft.</source>
          <target state="translated">이것이 충분하지 않은 경우 Microsoft에서 제공하는 C ++ 확장 덕분에 자체 래퍼 클래스를 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2212b7f3408c4c254a52ab8b98bff0ba162177fe" translate="yes" xml:space="preserve">
          <source>If this is not the case, it's not advisable to proceed further with the build since accelerated graphics won't be functional without the Raspberry Pi-specific backend, even if the rest of Qt compiles successfully.</source>
          <target state="translated">그렇지 않은 경우, Qt의 나머지 부분이 성공적으로 컴파일 되더라도 가속 그래픽이 Raspberry Pi 관련 백엔드 없이는 작동하지 않으므로 빌드를 계속 진행하는 것은 좋지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0640810e7677429cc8c41ab3339bfd15742101aa" translate="yes" xml:space="preserve">
          <source>If this is set to &lt;code&gt;AnimatedSprite.Infinite&lt;/code&gt; the animation will not stop playing on its own.</source>
          <target state="translated">이것이 &lt;code&gt;AnimatedSprite.Infinite&lt;/code&gt; 로 설정되면 애니메이션 자체 재생이 중지되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6f2ea3fdec5f6c5bda665005f3122f935f806218" translate="yes" xml:space="preserve">
          <source>If this is set to &lt;code&gt;BoundaryRule.None&lt;/code&gt; (the default), the intercepted property will hold a value whose overshoot is limited to &lt;a href=&quot;qml-qt-labs-animation-boundaryrule#currentOvershoot-prop&quot;&gt;currentOvershoot&lt;/a&gt;. If this is set to &lt;code&gt;BoundaryRule.Peak&lt;/code&gt;, the intercepted property will hold a value whose overshoot is limited to &lt;a href=&quot;qml-qt-labs-animation-boundaryrule#peakOvershoot-prop&quot;&gt;peakOvershoot&lt;/a&gt;.</source>
          <target state="translated">이것이 &lt;code&gt;BoundaryRule.None&lt;/code&gt; (기본값)으로 설정되면 인터셉트 된 속성은 오버 슈트가 &lt;a href=&quot;qml-qt-labs-animation-boundaryrule#currentOvershoot-prop&quot;&gt;currentOvershoot&lt;/a&gt; 로 제한되는 값을 보유합니다 . 이것이 &lt;code&gt;BoundaryRule.Peak&lt;/code&gt; 로 설정 되면 인터셉트 된 속성은 오버 슈트가 &lt;a href=&quot;qml-qt-labs-animation-boundaryrule#peakOvershoot-prop&quot;&gt;peakOvershoot&lt;/a&gt; 로 제한되는 값을 보유합니다 .</target>
        </trans-unit>
        <trans-unit id="3bd151c5ace1571defe65a7a9b0b3a1f96949f65" translate="yes" xml:space="preserve">
          <source>If this is set to a number below zero, then there is no maximum limit on the number of particles this emitter can have alive.</source>
          <target state="translated">이것이 0보다 작은 수로 설정되면,이 이미 터가 살아있을 수있는 입자의 수에는 최대 제한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="815da3f7f3ae9a63945072b509466fc6eee3b821" translate="yes" xml:space="preserve">
          <source>If this is the case, the slot should return control to the application's main loop to avoid freezing the user interface, and resume the process later. To accomplish this, it should make use of the extra &lt;code&gt;QDBusMessage&lt;/code&gt; parameter at the end of the input parameter list and request a delayed reply.</source>
          <target state="translated">이 경우, 슬롯은 사용자 인터페이스 정지를 피하기 위해 제어를 응용 프로그램의 기본 루프로 되돌려 야하며 나중에 프로세스를 다시 시작해야합니다. 이를 위해서는 입력 매개 변수 목록 끝에서 추가 &lt;code&gt;QDBusMessage&lt;/code&gt; 매개 변수를 사용 하고 지연된 응답을 요청해야합니다.</target>
        </trans-unit>
        <trans-unit id="d571b5d69c9b6bedb57f47e3a631b517db9e2747" translate="yes" xml:space="preserve">
          <source>If this is the current context for the thread, &lt;a href=&quot;qopenglcontext#doneCurrent&quot;&gt;doneCurrent&lt;/a&gt;() is also called.</source>
          <target state="translated">이것이 스레드의 현재 컨텍스트 인 경우 &lt;a href=&quot;qopenglcontext#doneCurrent&quot;&gt;doneCurrent&lt;/a&gt; ()도 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="c22ae0a30ceb173c3fb30b7b7caadeb257189e7f" translate="yes" xml:space="preserve">
          <source>If this is the first time the module is imported in the engine, the file is loaded from the specified location in either the local file system or the Qt resource system and evaluated as an ECMAScript module. The file is expected to be encoded in UTF-8 text.</source>
          <target state="translated">엔진에서 모듈을 처음으로 가져 오는 경우 로컬 파일 시스템 또는 Qt 자원 시스템의 지정된 위치에서 파일이로드되어 ECMAScript 모듈로 평가됩니다. 파일은 UTF-8 텍스트로 인코딩 될 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="cb6ce944f7e82486375cd067b727ef54469e1622" translate="yes" xml:space="preserve">
          <source>If this is the outermost macro in a set nested macros, this function emits &lt;a href=&quot;qundostack#indexChanged&quot;&gt;indexChanged&lt;/a&gt;() once for the entire macro command.</source>
          <target state="translated">중첩 된 매크로 집합에서 가장 바깥 쪽 매크로 인 경우이 함수 는 전체 매크로 명령에 대해 &lt;a href=&quot;qundostack#indexChanged&quot;&gt;indexChanged&lt;/a&gt; ()를 한 번 방출 합니다.</target>
        </trans-unit>
        <trans-unit id="3d9f73266a89f0829e3e84d6c6ec662a343d750a" translate="yes" xml:space="preserve">
          <source>If this is true the meta-data is writable, otherwise the meta-data is read-only.</source>
          <target state="translated">이것이 사실이라면 메타 데이터는 쓰기 가능하고, 그렇지 않으면 메타 데이터는 읽기 전용이다.</target>
        </trans-unit>
        <trans-unit id="edd578f1ea9dc5b6d82c8899d7d7357bcc7e4dec" translate="yes" xml:space="preserve">
          <source>If this is true the structure of the extension's value will not change between Qt versions.</source>
          <target state="translated">이것이 사실이라면 확장 값의 구조는 Qt 버전간에 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="02587674a2287aa0735a13eb9c908d9235be01fc" translate="yes" xml:space="preserve">
          <source>If this is true there is meta-data available, otherwise there is no meta-data available.</source>
          <target state="translated">이것이 사실이라면, 이용 가능한 메타 데이터가 존재하고, 그렇지 않으면 이용 가능한 메타 데이터가 존재하지 않는 것입니다.</target>
        </trans-unit>
        <trans-unit id="6958c1169e9abe3d23486655702d3c87e587858b" translate="yes" xml:space="preserve">
          <source>If this is true, key navigation that would move the current item selection past one end of the view instead wraps around and moves the selection to the other end of the view.</source>
          <target state="translated">이것이 사실이라면, 현재 아이템 선택을 뷰의 한쪽 끝을 지나서 이동시키는 키 탐색은 대신 랩핑되어 선택을 뷰의 다른 쪽 끝으로 이동시킵니다.</target>
        </trans-unit>
        <trans-unit id="3baa2a3c347e7375b69de5a0939b28ef0c5f3651" translate="yes" xml:space="preserve">
          <source>If this is true, key navigation that would move the current item selection past the end of the list instead wraps around and moves the selection to the start of the list, and vice-versa.</source>
          <target state="translated">이것이 사실이라면, 현재 아이템 선택을리스트의 끝을 지나서 이동시키는 키 탐색은 대신에 랩핑하고 선택을리스트의 시작으로 이동 시키며, 그 반대도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="1fed67d510c314a6d9d6afa7f5c3c36c23414ed7" translate="yes" xml:space="preserve">
          <source>If this item is a &lt;a href=&quot;qlayout&quot;&gt;QLayout&lt;/a&gt;, it is returned as a &lt;a href=&quot;qlayout&quot;&gt;QLayout&lt;/a&gt;; otherwise &lt;code&gt;nullptr&lt;/code&gt; is returned. This function provides type-safe casting.</source>
          <target state="translated">이 항목은 경우 &lt;a href=&quot;qlayout&quot;&gt;QLayout&lt;/a&gt; , 그것은으로 반환됩니다 &lt;a href=&quot;qlayout&quot;&gt;QLayout&lt;/a&gt; ; 그렇지 않으면 &lt;code&gt;nullptr&lt;/code&gt; 이 반환됩니다. 이 기능은 형식이 안전한 캐스팅을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="08dca8ce9290fc268eb52329f177a5390a05cbdd" translate="yes" xml:space="preserve">
          <source>If this item is a &lt;a href=&quot;qspaceritem&quot;&gt;QSpacerItem&lt;/a&gt;, it is returned as a &lt;a href=&quot;qspaceritem&quot;&gt;QSpacerItem&lt;/a&gt;; otherwise &lt;code&gt;nullptr&lt;/code&gt; is returned. This function provides type-safe casting.</source>
          <target state="translated">이 항목은 경우 &lt;a href=&quot;qspaceritem&quot;&gt;QSpacerItem를&lt;/a&gt; , 그것은으로 반환됩니다 &lt;a href=&quot;qspaceritem&quot;&gt;QSpacerItem&lt;/a&gt; ; 그렇지 않으면 &lt;code&gt;nullptr&lt;/code&gt; 이 반환됩니다. 이 기능은 형식이 안전한 캐스팅을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b98ccca372cdec81e1dfe7dc6e1c06c48f6a6c88" translate="yes" xml:space="preserve">
          <source>If this item is a focus scope, this returns the item in its focus chain that currently has focus.</source>
          <target state="translated">이 항목이 포커스 범위 인 경우 현재 포커스가있는 포커스 체인의 항목을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4e1ed7323c0a873b445f28366c285318ff453130" translate="yes" xml:space="preserve">
          <source>If this item is an input item, this method should be reimplemented to return the relevant input method flags for the given</source>
          <target state="translated">이 항목이 입력 항목 인 경우이 메소드는 주어진 입력에 대한 관련 입력 메소드 플래그를 리턴하도록 다시 구현되어야합니다.</target>
        </trans-unit>
        <trans-unit id="e0409abc2566c4f30a3cbdfee6aa28c8bd2bb64f" translate="yes" xml:space="preserve">
          <source>If this item is not viewed by a &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt;, this function does nothing.</source>
          <target state="translated">&lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; 가이 항목을 보지 않으면 이 함수는 아무 작업도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="21d6cc7c9d1f0be77f27dcf3379efdd28fa1722f" translate="yes" xml:space="preserve">
          <source>If this item is not visible, not active, or not associated with a scene, it will not gain immediate input focus. However, it will be registered as the preferred focus item for its subtree of items, should it later become visible.</source>
          <target state="translated">이 항목이 보이지 않거나 활성화되지 않았거나 장면과 관련이없는 경우 즉각적인 입력 포커스를 얻지 못합니다. 그러나 나중에 볼 수있게되면 하위 항목 트리의 기본 초점 항목으로 등록됩니다.</target>
        </trans-unit>
        <trans-unit id="e9693bda328af43aae2664285e2615bd225b2a96" translate="yes" xml:space="preserve">
          <source>If this item is part of a scene that is viewed by a &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt;, this convenience function will attempt to scroll the view to ensure that</source>
          <target state="translated">이 항목이 &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; 로 보는 장면의 일부인 경우이 편의 기능은보기를 스크롤하여</target>
        </trans-unit>
        <trans-unit id="5cd8094637349a26fb0957ad6f49bd73adc6bb56" translate="yes" xml:space="preserve">
          <source>If this item manages a &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt;, returns that widget. Otherwise, &lt;code&gt;nullptr&lt;/code&gt; is returned.</source>
          <target state="translated">이 항목이 &lt;a href=&quot;qwidget&quot;&gt;QWidget을&lt;/a&gt; 관리하면 해당 위젯을 리턴합니다. 그렇지 않으면 &lt;code&gt;nullptr&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="0691ad065a63a8babece1c4e9b0b187672444d01" translate="yes" xml:space="preserve">
          <source>If this item, a child or descendant of this item currently has input focus, this function will return a pointer to that item. If no descendant has input focus, &lt;code&gt;nullptr&lt;/code&gt; is returned.</source>
          <target state="translated">이 항목,이 항목의 자식 또는 하위 항목에 현재 입력 포커스가있는 경우이 함수는 해당 항목에 대한 포인터를 반환합니다. 하위 항목에 입력 포커스가 &lt;code&gt;nullptr&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="e90d10eab36f838e880bbcda4e8eaf590a891c0c" translate="yes" xml:space="preserve">
          <source>If this list is not shared, this operation is typically very fast (amortized &lt;a href=&quot;containers#algorithmic-complexity&quot;&gt;constant time&lt;/a&gt;), because &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt; preallocates extra space on both sides of its internal buffer to allow for fast growth at both ends of the list.</source>
          <target state="translated">이리스트를 공유하지 않는 경우,이 동작은 매우 빠르고 (전형적 상각 &lt;a href=&quot;containers#algorithmic-complexity&quot;&gt;일정 시간&lt;/a&gt; 때문에) &lt;a href=&quot;qlist&quot;&gt;QList가&lt;/a&gt; 리스트의 양단의 고속 성장을 허용하는 내부 버퍼의 양쪽에 별도의 공간을 미리 할당.</target>
        </trans-unit>
        <trans-unit id="18a7a58f1906cbf0782ee28e5b8e1c02172d354f" translate="yes" xml:space="preserve">
          <source>If this list is not shared, this operation takes &lt;a href=&quot;containers#algorithmic-complexity&quot;&gt;constant time&lt;/a&gt;.</source>
          <target state="translated">이 목록을 공유하지 않으면이 작업에 &lt;a href=&quot;containers#algorithmic-complexity&quot;&gt;일정한 시간&lt;/a&gt; 이 걸립니다 .</target>
        </trans-unit>
        <trans-unit id="f2487c53377a53917b91c9442b289266e9b4aa67" translate="yes" xml:space="preserve">
          <source>If this macro is used outside a function, the behavior is undefined.</source>
          <target state="translated">이 매크로가 함수 외부에서 사용되면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d6498308f28ed7d1001ab6e162cc95b9ee675eb6" translate="yes" xml:space="preserve">
          <source>If this method is not called for each data point, the channel data will be padded with empty values. However, the data cannot be added at arbitrary index, i.e., it must be added in synchronously with the point data.</source>
          <target state="translated">이 방법을 각 데이터 포인트에 대해 호출하지 않으면 채널 데이터가 빈 값으로 채워집니다. 그러나 임의의 인덱스에 데이터를 추가 할 수 없습니다. 즉, 포인트 데이터와 동기식으로 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="5908d86a6631884c1100450b8c5816780b2d5b11" translate="yes" xml:space="preserve">
          <source>If this object contained the last reference of a pending asynchronous call, the call will be canceled and no further notifications will be received. There will be no way of accessing the reply's contents when it arrives.</source>
          <target state="translated">이 객체에 보류중인 비동기 호출의 마지막 참조가 포함 된 경우 호출이 취소되고 더 이상 알림이 수신되지 않습니다. 회신 내용이 도착하면 액세스 할 수있는 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="5827e92b0d7cecb1c2a47add475c405e3b233bf5" translate="yes" xml:space="preserve">
          <source>If this object doesn't have an own property of the given</source>
          <target state="translated">이 객체에 지정된 속성이없는 경우</target>
        </trans-unit>
        <trans-unit id="d794f4306ef2e4b518323f7c6985ef0d736c48b3" translate="yes" xml:space="preserve">
          <source>If this object is currently not in the &lt;a href=&quot;qlowenergycontroller#ControllerState-enum&quot;&gt;UnconnectedState&lt;/a&gt;, nothing happens.</source>
          <target state="translated">이 객체가 현재 &lt;a href=&quot;qlowenergycontroller#ControllerState-enum&quot;&gt;UnconnectedState&lt;/a&gt; 에 없으면 아무 일도 일어나지 않습니다.</target>
        </trans-unit>
        <trans-unit id="14e7b7dd5cef30678457e791d3826fb351a64494" translate="yes" xml:space="preserve">
          <source>If this object was created by writing to a &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt;, this function will return an internal instance of &lt;a href=&quot;qbuffer&quot;&gt;QBuffer&lt;/a&gt;, which is owned by &lt;a href=&quot;qcborstreamwriter&quot;&gt;QCborStreamWriter&lt;/a&gt;.</source>
          <target state="translated">이 객체가 &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; 에 기록하여 작성된 경우이 함수는 &lt;a href=&quot;qbuffer&quot;&gt;QCborStreamWriter&lt;/a&gt; 가 소유 한 &lt;a href=&quot;qcborstreamwriter&quot;&gt;QBuffer&lt;/a&gt; 의 내부 인스턴스를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="9ece89e3ae8adc75a0838cab3da0672775a32094" translate="yes" xml:space="preserve">
          <source>If this option is set to false, then the menu has no checkable items. This makes it possible for GUI styles to save some horizontal space that would normally be used for the check column.</source>
          <target state="translated">이 옵션을 false로 설정하면 메뉴에 확인 가능한 항목이 없습니다. 이를 통해 GUI 스타일에서 일반적으로 검사 열에 사용되는 일부 수평 공간을 절약 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fef33347894014c8419e4e8d7c02759d014bf1e5" translate="yes" xml:space="preserve">
          <source>If this option is set, the alternate quotation marks will be used to quote strings.</source>
          <target state="translated">이 옵션을 설정하면 대체 인용 부호를 사용하여 문자열을 인용합니다.</target>
        </trans-unit>
        <trans-unit id="ff620433ab0b30055d7043612804f9f933ed5595" translate="yes" xml:space="preserve">
          <source>If this option is set, the number-to-string functions will not insert group separators in their return values. The default is to insert group separators.</source>
          <target state="translated">이 옵션을 설정하면 문자열 수 함수는 그룹 구분 기호를 반환 값에 삽입하지 않습니다. 기본값은 그룹 구분 기호를 삽입하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="8170173537a51269359acd552cbe77e44b3fa2f3" translate="yes" xml:space="preserve">
          <source>If this option is set, the number-to-string functions will not pad exponents with zeroes when printing floating point numbers in scientific notation. The default is to add one leading zero to single digit exponents.</source>
          <target state="translated">이 옵션을 설정하면 숫자 표기법으로 부동 소수점 숫자를 과학적 표기법으로 인쇄 할 때 지수를 0으로 채우지 않습니다. 기본값은 한 자리 지수에 선행 0을 추가하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="b264f880177ee14161614fb0b5f440e4b1e32e0d" translate="yes" xml:space="preserve">
          <source>If this option is set, the number-to-string functions will pad numbers with zeroes to the requested precision in &quot;g&quot; or &quot;most concise&quot; mode, even if the number of significant digits is lower than the requested precision. The default is to omit trailing zeroes.</source>
          <target state="translated">이 옵션이 설정되면, 숫자-문자열 함수는 유효 자릿수가 요청 된 정밀도보다 적더라도 &quot;g&quot;또는 &quot;가장 간결한&quot;모드에서 요청 된 정밀도에 0으로 숫자를 채 웁니다. 기본값은 후행 0을 생략하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="4b7b71b2eb80d6ceadb310a56031ff921e6101fc" translate="yes" xml:space="preserve">
          <source>If this option is set, the standard quotation marks will be used to quote strings.</source>
          <target state="translated">이 옵션을 설정하면 표준 인용 부호를 사용하여 문자열을 인용합니다.</target>
        </trans-unit>
        <trans-unit id="ae3bd855e5b35b606d7486a2119d6905f9d7dc64" translate="yes" xml:space="preserve">
          <source>If this option is set, the string-to-number functions will fail if they encounter an exponent padded with zeroes when parsing a floating point number in scientific notation. The default is to accept such padding.</source>
          <target state="translated">이 옵션을 설정하면 과학적 표기법으로 부동 소수점 숫자를 구문 분석 할 때 0으로 채워진 지수가 발생하면 문자열 대 숫자 함수가 실패합니다. 기본값은 이러한 패딩을 허용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ac5c3999f6614ea7f837cd70d9d12a86bc05536e" translate="yes" xml:space="preserve">
          <source>If this option is set, the string-to-number functions will fail if they encounter group separators in their input. The default is to accept numbers containing correctly placed group separators.</source>
          <target state="translated">이 옵션을 설정하면 입력에 그룹 구분 기호가 있으면 문자열-숫자 함수가 실패합니다. 기본값은 올바르게 배치 된 그룹 구분 기호가 포함 된 숫자를 허용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="4f87d44b9c1aa83baadc81d5667564dcdaafd12b" translate="yes" xml:space="preserve">
          <source>If this option is set, the string-to-number functions will fail if they encounter trailing zeroes after the decimal dot when parsing a number in scientific or decimal representation. The default is to accept trailing zeroes.</source>
          <target state="translated">이 옵션을 설정하면 과학적 또는 십진 표현으로 숫자를 구문 분석 할 때 소수점 이하 자릿수가 발생하면 문자열 대 숫자 함수가 실패합니다. 기본값은 후행 0을 허용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="90f41317b022bbcdc549dcfdc095d5ebee3552fa" translate="yes" xml:space="preserve">
          <source>If this option is true, the branch and any decorations on selected items should be highlighted, indicating that the item is selected; otherwise, no highlighting is required. The default value is false.</source>
          <target state="translated">이 옵션이 참이면 항목이 선택되었음을 나타내는 선택한 항목의 분기 및 모든 장식이 강조 표시되어야합니다. 그렇지 않으면 강조 표시가 필요하지 않습니다. 기본값은 false입니다.</target>
        </trans-unit>
        <trans-unit id="dfc42798feb31b60264d6a32589b11a24d634011" translate="yes" xml:space="preserve">
          <source>If this point has been grabbed by a Pointer Handler or an Item, it means that object has taken sole responsibility for handling the movement and the release if this point. In that case, this is the position at which the grab occurred, in the coordinate system of the &lt;a href=&quot;qtquick-visualcanvas-scenegraph&quot;&gt;scene graph&lt;/a&gt;.</source>
          <target state="translated">이 지점이 포인터 핸들러 또는 항목에 의해 잡혔다면, 이는 객체가 이동 및 해제를 처리하는 데 전적으로 책임이 있음을 의미합니다. 이 경우 &lt;a href=&quot;qtquick-visualcanvas-scenegraph&quot;&gt;장면 그래프&lt;/a&gt; 의 좌표계에서 그랩이 발생한 위치 입니다.</target>
        </trans-unit>
        <trans-unit id="ac45c819c21e06634a86122118857da75f572b88" translate="yes" xml:space="preserve">
          <source>If this point has been grabbed by a Pointer Handler or an Item, it means that object has taken sole responsibility for handling the movement and the release if this point. In that case, this is the position at which the grab occurred, in the coordinate system of the &lt;a href=&quot;qtquick-visualcanvas-scenegraph#&quot;&gt;scene graph&lt;/a&gt;.</source>
          <target state="translated">이 지점이 포인터 처리기 또는 항목에 의해 잡힌 경우,이 지점의 경우 이동 및 해제 처리에 대한 책임은 객체에 있음을 의미합니다. 이 경우, 이것은 &lt;a href=&quot;qtquick-visualcanvas-scenegraph#&quot;&gt;장면 그래프&lt;/a&gt; 의 좌표계에서 횡령이 발생한 위치 입니다.</target>
        </trans-unit>
        <trans-unit id="3b771755bcb68853c7647cff7ff047b99762b810" translate="yes" xml:space="preserve">
          <source>If this property is &lt;a href=&quot;qlistview#Flow-enum&quot;&gt;LeftToRight&lt;/a&gt;, the items will be laid out left to right. If the &lt;a href=&quot;qlistview#isWrapping-prop&quot;&gt;isWrapping&lt;/a&gt; property is &lt;code&gt;true&lt;/code&gt;, the layout will wrap when it reaches the right side of the visible area. If this property is &lt;a href=&quot;qlistview#Flow-enum&quot;&gt;TopToBottom&lt;/a&gt;, the items will be laid out from the top of the visible area, wrapping when it reaches the bottom.</source>
          <target state="translated">이 속성이 &lt;a href=&quot;qlistview#Flow-enum&quot;&gt;LeftToRight&lt;/a&gt; 이면 항목이 왼쪽에서 오른쪽으로 배치됩니다. 는 IF &lt;a href=&quot;qlistview#isWrapping-prop&quot;&gt;isWrapping&lt;/a&gt; 재산이 &lt;code&gt;true&lt;/code&gt; 은 가시 영역의 오른쪽에 도달 할 때, 레이아웃은 포장됩니다. 이 속성이 &lt;a href=&quot;qlistview#Flow-enum&quot;&gt;TopToBottom&lt;/a&gt; 인 경우 항목은 표시 영역의 맨 위에서 배치되어 맨 아래에 도달하면 줄 바꿈됩니다.</target>
        </trans-unit>
        <trans-unit id="e0ed98fb3f26af964ab35b29e2d2e03c4f47fc40" translate="yes" xml:space="preserve">
          <source>If this property is &lt;a href=&quot;qlistview#ResizeMode-enum&quot;&gt;Adjust&lt;/a&gt;, the items will be laid out again when the view is resized. If the value is &lt;a href=&quot;qlistview#ResizeMode-enum&quot;&gt;Fixed&lt;/a&gt;, the items will not be laid out when the view is resized.</source>
          <target state="translated">이 속성이 &lt;a href=&quot;qlistview#ResizeMode-enum&quot;&gt;Adjust&lt;/a&gt; 인 경우보기의 크기를 조정할 때 항목이 다시 배치됩니다. 값이 &lt;a href=&quot;qlistview#ResizeMode-enum&quot;&gt;Fixed&lt;/a&gt; 인 경우보기 크기를 조정할 때 항목이 배치되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b7deca13855ec8eb228a3cb15af5d985131a3a0a" translate="yes" xml:space="preserve">
          <source>If this property is &lt;code&gt;false&lt;/code&gt; (the default), the minimum and maximum will be shown in its classic position for the inherited widget. If the value is true, the minimum and maximum appear at their opposite location.</source>
          <target state="translated">이 특성이 &lt;code&gt;false&lt;/code&gt; (기본값)이면 최소값과 최대 값이 상속 된 위젯의 기본 위치에 표시됩니다. 값이 true이면 최소값과 최대 값이 반대 위치에 나타납니다.</target>
        </trans-unit>
        <trans-unit id="256e6641ec2c6b6d48d09b781a84aea2426069bc" translate="yes" xml:space="preserve">
          <source>If this property is &lt;code&gt;false&lt;/code&gt;, dock areas can only contain a single row (horizontal or vertical) of dock widgets. If this property is &lt;code&gt;true&lt;/code&gt;, the area occupied by a dock widget can be split in either direction to contain more dock widgets.</source>
          <target state="translated">이 특성이 &lt;code&gt;false&lt;/code&gt; 인 경우 도크 영역은 단일 행 (수평 또는 수직)의 도크 위젯 만 포함 할 수 있습니다. 이 특성이 &lt;code&gt;true&lt;/code&gt; 인 경우 , 도크 위젯이 차지하는 영역을 더 많은 도크 위젯을 포함하도록 어느 방향으로나 분할 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f3e1271f58ebff794cd459e2422872920458ec5" translate="yes" xml:space="preserve">
          <source>If this property is &lt;code&gt;false&lt;/code&gt;, scrolling the mouse wheel &quot;up&quot; and using keys like page up will increase the slider's value towards its maximum. Otherwise pressing page up will move value towards the slider's minimum.</source>
          <target state="translated">이 속성이 &lt;code&gt;false&lt;/code&gt; 인 경우 마우스 휠을 &quot;위로&quot;스크롤하고 페이지 위로 같은 키를 사용하면 슬라이더 값이 최대 값으로 증가합니다. 그렇지 않으면 page up을 누르면 값이 슬라이더의 최소쪽으로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="3ee8b5c73c89c4c40ab0e354058db3c7ef2a4d10" translate="yes" xml:space="preserve">
          <source>If this property is &lt;code&gt;false&lt;/code&gt;, the resulting opacity is the source alpha multiplied with the mask alpha, &lt;code&gt;As * Am&lt;/code&gt;.</source>
          <target state="translated">이 속성이 &lt;code&gt;false&lt;/code&gt; 이면 결과 불투명도는 소스 알파에 마스크 알파 &lt;code&gt;As * Am&lt;/code&gt; 과 곱한 소스 알파 입니다.</target>
        </trans-unit>
        <trans-unit id="6edaaf262acc7e9b654c374c4fdca4564a815657" translate="yes" xml:space="preserve">
          <source>If this property is &lt;code&gt;false&lt;/code&gt;, the series is not rendered. Defaults to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">이 속성이 &lt;code&gt;false&lt;/code&gt; 인 경우 계열이 렌더링되지 않습니다. 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="281aa164a58e2063f00f60d828e957875cae1e82" translate="yes" xml:space="preserve">
          <source>If this property is &lt;code&gt;false&lt;/code&gt;, then all actions in the group are disabled. If this property is &lt;code&gt;true&lt;/code&gt;, all actions in the group are enabled, unless explicitly disabled.</source>
          <target state="translated">이 특성이 &lt;code&gt;false&lt;/code&gt; 이면 그룹의 모든 조치가 사용 불가능합니다. 이 특성이 &lt;code&gt;true&lt;/code&gt; 이면 명시 적으로 비활성화하지 않는 한 그룹의 모든 조치가 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="5c0792ab3294c4129069112087b2b1ac088d6695" translate="yes" xml:space="preserve">
          <source>If this property is &lt;code&gt;true&lt;/code&gt; a grid is drawn for the table; if the property is &lt;code&gt;false&lt;/code&gt;, no grid is drawn. The default value is true.</source>
          <target state="translated">이 속성이 &lt;code&gt;true&lt;/code&gt; 이면 테이블에 대한 그리드가 그려집니다. 속성이 &lt;code&gt;false&lt;/code&gt; 인 경우 그리드가 그려지지 않습니다. 기본값은 true입니다.</target>
        </trans-unit>
        <trans-unit id="715a3d72e1d5f463d3f5fadc11252c21aee4d3f6" translate="yes" xml:space="preserve">
          <source>If this property is &lt;code&gt;true&lt;/code&gt; all columns will show focus, otherwise only one column will show focus.</source>
          <target state="translated">이 속성이 &lt;code&gt;true&lt;/code&gt; 이면 모든 열에 포커스가 표시되고, 그렇지 않으면 하나의 열에 만 포커스가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="f083d2835729d9046625c2aa9b97039bc54cc0a1" translate="yes" xml:space="preserve">
          <source>If this property is &lt;code&gt;true&lt;/code&gt; the treeview will animate expansion and collapsing of branches. If this property is &lt;code&gt;false&lt;/code&gt;, the treeview will expand or collapse branches immediately without showing the animation.</source>
          <target state="translated">이 속성이 &lt;code&gt;true&lt;/code&gt; 인 경우 트 리뷰는 분기의 확장 및 축소에 애니메이션을 적용합니다. 이 속성이 &lt;code&gt;false&lt;/code&gt; 인 경우 트리 뷰는 애니메이션을 표시하지 않고 분기를 즉시 확장하거나 축소합니다.</target>
        </trans-unit>
        <trans-unit id="2cc893005e6ec24519c7cf45760dbad5f87999eb" translate="yes" xml:space="preserve">
          <source>If this property is &lt;code&gt;true&lt;/code&gt; then button in the top-left corner of the table view is enabled. Clicking on this button will select all the cells in the table view.</source>
          <target state="translated">이 속성이 &lt;code&gt;true&lt;/code&gt; 이면 테이블 뷰의 왼쪽 상단에있는 버튼이 활성화됩니다. 이 버튼을 클릭하면 테이블보기에서 모든 셀이 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="b07edf7e1edad62c96bf31817d4c3f6991ad5812" translate="yes" xml:space="preserve">
          <source>If this property is &lt;code&gt;true&lt;/code&gt; then label text is wrapped where necessary at word-breaks; otherwise it is not wrapped at all.</source>
          <target state="translated">이 속성이 &lt;code&gt;true&lt;/code&gt; 이면 단어 구분에서 필요한 경우 레이블 텍스트가 줄 바꿈됩니다. 그렇지 않으면 전혀 랩핑되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4a334517a92068a23c8907809ee72f10e790ad59" translate="yes" xml:space="preserve">
          <source>If this property is &lt;code&gt;true&lt;/code&gt; then the item text is wrapped where necessary at word-breaks; otherwise it is not wrapped at all. This property is &lt;code&gt;false&lt;/code&gt; by default.</source>
          <target state="translated">이 속성이 &lt;code&gt;true&lt;/code&gt; 인 경우 단어 구분에서 필요한 경우 항목 텍스트가 줄 바꿈됩니다. 그렇지 않으면 전혀 랩핑되지 않습니다. 이 속성은 기본적으로 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2fd0605bbc63cb0b4f60a9c99332acdbdc37bdf7" translate="yes" xml:space="preserve">
          <source>If this property is &lt;code&gt;true&lt;/code&gt; then the item text is wrapped where necessary at word-breaks; otherwise it is not wrapped at all. This property is &lt;code&gt;true&lt;/code&gt; by default.</source>
          <target state="translated">이 속성이 &lt;code&gt;true&lt;/code&gt; 인 경우 단어 구분에서 필요한 경우 항목 텍스트가 줄 바꿈됩니다. 그렇지 않으면 전혀 랩핑되지 않습니다. 이 속성은 기본적으로 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="92a94fbaf6c337c13d6dc3228a80c63cd238b5c1" translate="yes" xml:space="preserve">
          <source>If this property is &lt;code&gt;true&lt;/code&gt; then the selection rectangle is visible; otherwise it will be hidden.</source>
          <target state="translated">이 속성이 &lt;code&gt;true&lt;/code&gt; 이면 선택 사각형이 표시됩니다. 그렇지 않으면 숨겨집니다.</target>
        </trans-unit>
        <trans-unit id="f4017c6a997429ac56099abaa00427a73797ab10" translate="yes" xml:space="preserve">
          <source>If this property is &lt;code&gt;true&lt;/code&gt;, &lt;a href=&quot;qml-qtquick-controls-checkbox#checked-prop&quot;&gt;checked&lt;/a&gt; will be &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">이 속성이 &lt;code&gt;true&lt;/code&gt; 이면 &lt;a href=&quot;qml-qtquick-controls-checkbox#checked-prop&quot;&gt;checked&lt;/a&gt; 가 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d45638ac6cea0c50290550bb0deb762ced2ebd22" translate="yes" xml:space="preserve">
          <source>If this property is &lt;code&gt;true&lt;/code&gt;, existing text is overwritten, character-for-character by new text; otherwise, text is inserted at the cursor position, displacing existing text.</source>
          <target state="translated">이 속성이 &lt;code&gt;true&lt;/code&gt; 인 경우 기존 텍스트를 새 텍스트로 문자 별 겹쳐 씁니다. 그렇지 않으면 커서 위치에 텍스트가 삽입되어 기존 텍스트가 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="162325a9f72a9416ce360af34a474de91eb293b8" translate="yes" xml:space="preserve">
          <source>If this property is &lt;code&gt;true&lt;/code&gt;, sorting is enabled for the list; if the property is false, sorting is not enabled.</source>
          <target state="translated">이 속성이 &lt;code&gt;true&lt;/code&gt; 이면 목록에 대한 정렬이 활성화됩니다. 속성이 false이면 정렬이 활성화되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7f5844c10428d27a41ededec51ec281d3b59a7c8" translate="yes" xml:space="preserve">
          <source>If this property is &lt;code&gt;true&lt;/code&gt;, sorting is enabled for the table. If this property is &lt;code&gt;false&lt;/code&gt;, sorting is not enabled. The default value is false.</source>
          <target state="translated">이 특성이 &lt;code&gt;true&lt;/code&gt; 이면 테이블에 대한 정렬이 사용 가능합니다. 이 특성이 &lt;code&gt;false&lt;/code&gt; 이면 정렬이 사용되지 않습니다. 기본값은 false입니다.</target>
        </trans-unit>
        <trans-unit id="9b00747790e129b5e420e9827ba30e900b875c25" translate="yes" xml:space="preserve">
          <source>If this property is &lt;code&gt;true&lt;/code&gt;, sorting is enabled for the tree; if the property is false, sorting is not enabled. The default value is false.</source>
          <target state="translated">이 속성이 &lt;code&gt;true&lt;/code&gt; 이면 트리에 대한 정렬이 활성화됩니다. 속성이 false이면 정렬이 활성화되지 않습니다. 기본값은 false입니다.</target>
        </trans-unit>
        <trans-unit id="b7a5e9da4db2c69a5c70c07e5a89a704fe6d2f7e" translate="yes" xml:space="preserve">
          <source>If this property is &lt;code&gt;true&lt;/code&gt;, the applications quits when the last visible primary window (i.e. window with no parent) is closed.</source>
          <target state="translated">이 속성이 &lt;code&gt;true&lt;/code&gt; 이면 마지막으로 보이는 기본 윈도우 (즉, 부모가없는 윈도우)가 닫히면 응용 프로그램이 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="d7bc6c0458081235b47caf3e26e772aef2302bbb" translate="yes" xml:space="preserve">
          <source>If this property is &lt;code&gt;true&lt;/code&gt;, the button is pressed down. The signals &lt;a href=&quot;qabstractbutton#pressed&quot;&gt;pressed&lt;/a&gt;() and &lt;a href=&quot;qabstractbutton#clicked&quot;&gt;clicked&lt;/a&gt;() are not emitted if you set this property to true. The default is false.</source>
          <target state="translated">이 속성이 &lt;code&gt;true&lt;/code&gt; 이면 버튼이 눌려집니다. 이 속성을 true로 설정 &lt;a href=&quot;qabstractbutton#clicked&quot;&gt;하면 &lt;/a&gt;&lt;a href=&quot;qabstractbutton#pressed&quot;&gt;누른&lt;/a&gt; () 및 클릭 된 () 신호 가 방출되지 않습니다. 기본값은 false입니다.</target>
        </trans-unit>
        <trans-unit id="b29c008b519f25f13830546cca1b34c6e25896f9" translate="yes" xml:space="preserve">
          <source>If this property is &lt;code&gt;true&lt;/code&gt;, the group box displays its title using a checkbox in place of an ordinary label. If the checkbox is checked, the group box's children are enabled; otherwise, they are disabled and inaccessible.</source>
          <target state="translated">이 속성이 &lt;code&gt;true&lt;/code&gt; 인 경우 그룹 상자는 일반 레이블 대신 확인란을 사용하여 제목을 표시합니다. 확인란을 선택하면 그룹 상자의 자식이 활성화됩니다. 그렇지 않으면 비활성화되어 액세스 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="af6c4b35e7b1ba6365b0acecf3a1d5d96f3719ab" translate="yes" xml:space="preserve">
          <source>If this property is &lt;code&gt;true&lt;/code&gt;, the header is not shown otherwise it is. The default value is false.</source>
          <target state="translated">이 속성이 &lt;code&gt;true&lt;/code&gt; 이면 헤더가 표시되지 않습니다. 기본값은 false입니다.</target>
        </trans-unit>
        <trans-unit id="9d98572256e94287016ab11f359655aab7b77e84" translate="yes" xml:space="preserve">
          <source>If this property is &lt;code&gt;true&lt;/code&gt;, the item background will be drawn using &lt;a href=&quot;qpalette#ColorRole-enum&quot;&gt;QPalette::Base&lt;/a&gt; and &lt;a href=&quot;qpalette#ColorRole-enum&quot;&gt;QPalette::AlternateBase&lt;/a&gt;; otherwise the background will be drawn using the &lt;a href=&quot;qpalette#ColorRole-enum&quot;&gt;QPalette::Base&lt;/a&gt; color.</source>
          <target state="translated">이 속성이 &lt;code&gt;true&lt;/code&gt; 이면&lt;a href=&quot;qpalette#ColorRole-enum&quot;&gt;QPalette :: Base&lt;/a&gt; 및 &lt;a href=&quot;qpalette#ColorRole-enum&quot;&gt;QPalette :: AlternateBase를&lt;/a&gt; 사용하여 항목 배경이 그려집니다 . 그렇지 않으면 &lt;a href=&quot;qpalette#ColorRole-enum&quot;&gt;QPalette :: Base&lt;/a&gt; 색상을 사용하여 배경이 그려집니다 .</target>
        </trans-unit>
        <trans-unit id="02e1035eaabed7a4b62fbb96b1792d9ac993c856" translate="yes" xml:space="preserve">
          <source>If this property is &lt;code&gt;true&lt;/code&gt;, the item will be as tall as possible while respecting the given constraints. If the property is &lt;code&gt;false&lt;/code&gt;, the item will have a fixed height set to the preferred height. The default is &lt;code&gt;false&lt;/code&gt;, except for layouts themselves, which default to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">이 속성이 &lt;code&gt;true&lt;/code&gt; 인 경우 주어진 제약 조건을 준수하면서 항목의 키가 최대한 커집니다. 이 속성이 &lt;code&gt;false&lt;/code&gt; 인 경우 항목의 고정 높이는 기본 설정 높이로 설정됩니다. 레이아웃 자체를 제외하고 기본값은 &lt;code&gt;false&lt;/code&gt; 이며 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4ecad7ef35d3126ddb94a0ff52a4d2c2c5bf58fc" translate="yes" xml:space="preserve">
          <source>If this property is &lt;code&gt;true&lt;/code&gt;, the item will be as wide as possible while respecting the given constraints. If the property is &lt;code&gt;false&lt;/code&gt;, the item will have a fixed width set to the preferred width. The default is &lt;code&gt;false&lt;/code&gt;, except for layouts themselves, which default to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">이 속성이 &lt;code&gt;true&lt;/code&gt; 인 경우 주어진 제약 조건을 준수하면서 항목의 너비가 최대한 넓어집니다. 이 속성이 &lt;code&gt;false&lt;/code&gt; 인 경우 항목의 고정 너비는 기본 너비로 설정됩니다. 레이아웃 자체를 제외하고 기본값은 &lt;code&gt;false&lt;/code&gt; 이며 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="866f4939746b1f7948377061052baaf5962b9df0" translate="yes" xml:space="preserve">
          <source>If this property is &lt;code&gt;true&lt;/code&gt;, the progress bar grows in the other direction (e.g. from right to left). By default, the progress bar is not inverted.</source>
          <target state="translated">이 속성이 &lt;code&gt;true&lt;/code&gt; 이면 진행률 막대가 다른 방향 (예 : 오른쪽에서 왼쪽)으로 커집니다. 기본적으로 진행률 표시 줄은 반전되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5744fabb152a192853b9c9bdfdfe5197460bbcb3" translate="yes" xml:space="preserve">
          <source>If this property is &lt;code&gt;true&lt;/code&gt;, the resulting opacity is the source alpha multiplied with the inverse of the mask alpha, &lt;code&gt;As * (1 - Am)&lt;/code&gt;.</source>
          <target state="translated">이 속성이 &lt;code&gt;true&lt;/code&gt; 이면 결과 불투명도는 소스 알파에 마스크 알파의 역수 &lt;code&gt;As * (1 - Am)&lt;/code&gt; 곱한 소스 알파 입니다.</target>
        </trans-unit>
        <trans-unit id="e21fa6dfff783d88d1c550f984277ae50faf1151" translate="yes" xml:space="preserve">
          <source>If this property is &lt;code&gt;true&lt;/code&gt;, then only one action in the group can be checked at any given time. The user can trigger any action to check it, and that action will replace the existing one as the checked action in the group.</source>
          <target state="translated">이 특성이 &lt;code&gt;true&lt;/code&gt; 이면 그룹에서 한 번에 하나의 조치 만 점검 할 수 있습니다. 사용자는 조치를 트리거하여이를 점검 할 수 있으며 해당 조치는 기존 조치를 그룹에서 점검 된 조치로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="47a4fba628c147042bcee21e0d6d2ee775022447" translate="yes" xml:space="preserve">
          <source>If this property is &lt;code&gt;true&lt;/code&gt;, then only one button in the group can be checked at any given time. The user can click on any button to check it, and that button will replace the existing one as the checked button in the group.</source>
          <target state="translated">이 속성이 &lt;code&gt;true&lt;/code&gt; 이면 그룹에서 한 번에 하나의 버튼 만 확인할 수 있습니다. 사용자는 아무 버튼이나 클릭하여 확인할 수 있으며, 해당 버튼은 그룹의 기존 버튼을 기존 버튼으로 대체합니다.</target>
        </trans-unit>
        <trans-unit id="4f7832baf67af190c84f10f00ae93f77fb790f26" translate="yes" xml:space="preserve">
          <source>If this property is changed, all instances using the old delegate will be destroyed and new instances will be created using the new delegate.</source>
          <target state="translated">이 속성을 변경하면 이전 대리자를 사용하는 모든 인스턴스가 삭제되고 새 대리자를 사용하여 새 인스턴스가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="028511c9ae4d44f955fa6cffa99056e685e7ebcf" translate="yes" xml:space="preserve">
          <source>If this property is enabled for a group box, it will also be initially checked to ensure that its contents are enabled.</source>
          <target state="translated">이 특성이 그룹 상자에 사용 가능한 경우, 해당 컨텐츠가 사용 가능한지 확인하기 위해 초기에 점검됩니다.</target>
        </trans-unit>
        <trans-unit id="1992d04a0b6ef9728582b337c65f6fb7d5b0a555" translate="yes" xml:space="preserve">
          <source>If this property is enabled, pressing a non-modifier key will cause a date edit to popup if the calendar widget has focus, allowing the user to specify a date in the form specified by the current locale.</source>
          <target state="translated">이 속성을 활성화하면 수정 자 이외의 키를 누르면 달력 위젯에 포커스가있는 경우 날짜 편집이 팝업되어 사용자가 현재 로캘에 지정된 형식으로 날짜를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="facfaf9f43f95438406104f2b3e8d5fa427e2fad" translate="yes" xml:space="preserve">
          <source>If this property is not set, a default animation is applied.</source>
          <target state="translated">이 속성을 설정하지 않으면 기본 애니메이션이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="f3614db33e1917e7090d87b4a0f9cec843907c32" translate="yes" xml:space="preserve">
          <source>If this property is not set, the &lt;code&gt;target&lt;/code&gt; defaults to the parent of the Connection.</source>
          <target state="translated">이 특성이 설정되지 않은 경우 &lt;code&gt;target&lt;/code&gt; 기본값은 Connection의 상위입니다.</target>
        </trans-unit>
        <trans-unit id="940f38acd8a75e41ae1d10d9ea7867354f956706" translate="yes" xml:space="preserve">
          <source>If this property is not set, the default is the &lt;a href=&quot;qwidget#font-prop&quot;&gt;QWidget::font&lt;/a&gt;.</source>
          <target state="translated">이 특성이 설정되지 않은 경우 기본값은 &lt;a href=&quot;qwidget#font-prop&quot;&gt;QWidget :: font&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8b36876b9dd1592eb387b3a5bc62dc9dca2e7ce5" translate="yes" xml:space="preserve">
          <source>If this property is not set, the default is whatever is set for in the widget's palette for the &lt;a href=&quot;qwidget#foregroundRole&quot;&gt;QWidget::foregroundRole&lt;/a&gt; (typically black).</source>
          <target state="translated">이 특성이 설정되지 않은 경우 기본값은 &lt;a href=&quot;qwidget#foregroundRole&quot;&gt;QWidget :: foregroundRole&lt;/a&gt; (일반적으로 검은 색) 에 대한 위젯 팔레트에서 설정된 값입니다 .</target>
        </trans-unit>
        <trans-unit id="0002f8ea19631d68590107e7625b83fbec8144ca" translate="yes" xml:space="preserve">
          <source>If this property is not set, the default value is whatever is set for the palette's &lt;a href=&quot;qpalette#ColorRole-enum&quot;&gt;AlternateBase&lt;/a&gt; role.</source>
          <target state="translated">이 속성을 설정하지 않으면 기본값은 팔레트의 &lt;a href=&quot;qpalette#ColorRole-enum&quot;&gt;AlternateBase&lt;/a&gt; 역할에 설정된 값입니다 .</target>
        </trans-unit>
        <trans-unit id="1caed5061b406d3e8378ca314b782aab182301c3" translate="yes" xml:space="preserve">
          <source>If this property is not set, the default value is whatever is set for the palette's &lt;a href=&quot;qpalette#ColorRole-enum&quot;&gt;Highlight&lt;/a&gt; role.</source>
          <target state="translated">이 속성을 설정하지 않으면 기본값은 팔레트의 &lt;a href=&quot;qpalette#ColorRole-enum&quot;&gt;강조 표시&lt;/a&gt; 역할에 설정된 값입니다 .</target>
        </trans-unit>
        <trans-unit id="9da0cca2644f60b6fb001690ff8132b9fba1f8ba" translate="yes" xml:space="preserve">
          <source>If this property is not set, the default value is whatever is set for the palette's &lt;a href=&quot;qpalette#ColorRole-enum&quot;&gt;HighlightedText&lt;/a&gt; role.</source>
          <target state="translated">이 속성이 설정되지 않은 경우 기본값은 팔레트의 &lt;a href=&quot;qpalette#ColorRole-enum&quot;&gt;HighlightedText&lt;/a&gt; 역할에 설정된 값입니다 .</target>
        </trans-unit>
        <trans-unit id="6a859b3f5e5a3d916c84af816955274b07cf71b0" translate="yes" xml:space="preserve">
          <source>If this property is not set, then spacing is used for the column spacing.</source>
          <target state="translated">이 특성을 설정하지 않으면 열 간격에 간격이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7a61a88a51154cd8634f69de7e78498456e0b91c" translate="yes" xml:space="preserve">
          <source>If this property is not set, then spacing is used for the row spacing.</source>
          <target state="translated">이 특성을 설정하지 않으면 행 간격에 간격이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b8e9d249aa367858f4b3d7e30c5431d4ca51559c" translate="yes" xml:space="preserve">
          <source>If this property is not specified, it defaults to 0.</source>
          <target state="translated">이 특성을 지정하지 않으면 기본값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="30a23b7cf3f8c9e0acd7df247ed05401c50baa7f" translate="yes" xml:space="preserve">
          <source>If this property is not specified, it defaults to &lt;a href=&quot;#color-prop&quot;&gt;color&lt;/a&gt; (i.e., the widget's foreground color).</source>
          <target state="translated">이 속성을 지정하지 않으면 기본적으로 &lt;a href=&quot;#color-prop&quot;&gt;색상&lt;/a&gt; (위젯의 전경색)으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="a9df9d08bf0e6d909f4ac1d7e9690bc5fb295164" translate="yes" xml:space="preserve">
          <source>If this property is not specified, it defaults to &lt;a href=&quot;stylesheet-reference#color-prop&quot;&gt;color&lt;/a&gt; (i.e., the widget's foreground color).</source>
          <target state="translated">이 속성을 지정하지 않으면 기본적으로 &lt;a href=&quot;stylesheet-reference#color-prop&quot;&gt;색상&lt;/a&gt; (즉, 위젯의 전경색)이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f5a5b14da297cad2a072e2bce814ec8be996a8be" translate="yes" xml:space="preserve">
          <source>If this property is not specified, it defaults to &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">이 특성을 지정하지 않으면 기본값은 &lt;code&gt;0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f3696aa5a39b0a9337d14f2b61af3d65037519e1" translate="yes" xml:space="preserve">
          <source>If this property is not specified, it defaults to &lt;code&gt;none&lt;/code&gt;.</source>
          <target state="translated">이 특성을 지정하지 않으면 기본값은 &lt;code&gt;none&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="690a0ed6fd7b824cd65a4fef16dd9c8a1e5c3b76" translate="yes" xml:space="preserve">
          <source>If this property is not specified, it defaults to &lt;code&gt;relative&lt;/code&gt;.</source>
          <target state="translated">이 특성을 지정하지 않으면 기본적으로 &lt;code&gt;relative&lt;/code&gt; 로 설정 됩니다.</target>
        </trans-unit>
        <trans-unit id="e7edbcfd248e634c5cdf5868ef73f1a65d40b618" translate="yes" xml:space="preserve">
          <source>If this property is not specified, it defaults to a value that depends on the subcontrol.</source>
          <target state="translated">이 속성을 지정하지 않으면 하위 컨트롤에 따라 달라지는 값이 기본값이됩니다.</target>
        </trans-unit>
        <trans-unit id="8f745f858d3f06a56504629ee1dd1702288f49e7" translate="yes" xml:space="preserve">
          <source>If this property is not specified, it defaults to a value that depends on the subcontrol/widget and on the current style.</source>
          <target state="translated">이 속성을 지정하지 않으면 하위 컨트롤 / 위젯과 현재 스타일에 따라 달라지는 값이 기본값이됩니다.</target>
        </trans-unit>
        <trans-unit id="da59bf4645bee2a0faa3a3c2fa796727a38ad9ca" translate="yes" xml:space="preserve">
          <source>If this property is not specified, it defaults to the value specified by the current style for the &lt;a href=&quot;qstyle#StyleHint-enum&quot;&gt;SH_DialogButtonLayout&lt;/a&gt; style hint.</source>
          <target state="translated">이 속성을 지정하지 않으면 &lt;a href=&quot;qstyle#StyleHint-enum&quot;&gt;SH_DialogButtonLayout&lt;/a&gt; 스타일 힌트 의 현재 스타일로 지정된 값이 기본값이됩니다 .</target>
        </trans-unit>
        <trans-unit id="e11a7c1c37b60efcce8c3b6c0ef4ad9523eabb57" translate="yes" xml:space="preserve">
          <source>If this property is not specified, it defaults to the value specified by the current style for the &lt;a href=&quot;qstyle#StyleHint-enum&quot;&gt;SH_ItemView_ShowDecorationSelected&lt;/a&gt; style hint.</source>
          <target state="translated">이 속성을 지정하지 않으면 &lt;a href=&quot;qstyle#StyleHint-enum&quot;&gt;SH_ItemView_ShowDecorationSelected&lt;/a&gt; 스타일 힌트에 대해 현재 스타일로 지정된 값이 기본값이됩니다 .</target>
        </trans-unit>
        <trans-unit id="a9a9d65698d81f90a596ecaf87d29ceda072a92c" translate="yes" xml:space="preserve">
          <source>If this property is not specified, it defaults to the value specified by the current style for the &lt;a href=&quot;qstyle#StyleHint-enum&quot;&gt;SH_LineEdit_PasswordCharacter&lt;/a&gt; style hint.</source>
          <target state="translated">이 속성을 지정하지 않으면 &lt;a href=&quot;qstyle#StyleHint-enum&quot;&gt;SH_LineEdit_PasswordCharacter&lt;/a&gt; 스타일 힌트에 대한 현재 스타일로 지정된 값이 기본값이됩니다 .</target>
        </trans-unit>
        <trans-unit id="9405c74ec7ec2297b34d09bdddb6e4e626856570" translate="yes" xml:space="preserve">
          <source>If this property is not specified, it defaults to the value specified by the current style for the &lt;a href=&quot;qstyle#StyleHint-enum&quot;&gt;SH_LineEdit_PasswordMaskDelay&lt;/a&gt; style hint.</source>
          <target state="translated">이 속성을 지정하지 않으면 &lt;a href=&quot;qstyle#StyleHint-enum&quot;&gt;SH_LineEdit_PasswordMaskDelay&lt;/a&gt; 스타일 힌트 의 현재 스타일로 지정된 값이 기본값이됩니다 .</target>
        </trans-unit>
        <trans-unit id="480def6328238909faa631c8f90114c2bed1bbed" translate="yes" xml:space="preserve">
          <source>If this property is not specified, it defaults to the value specified by the current style for the &lt;a href=&quot;qstyle#StyleHint-enum&quot;&gt;SH_MessageBox_TextInteractionFlags&lt;/a&gt; style hint.</source>
          <target state="translated">이 속성을 지정하지 않으면 &lt;a href=&quot;qstyle#StyleHint-enum&quot;&gt;SH_MessageBox_TextInteractionFlags&lt;/a&gt; 스타일 힌트 의 현재 스타일로 지정된 값이 기본값이됩니다 .</target>
        </trans-unit>
        <trans-unit id="cae4bc7ccf46f23248414485b7bec5919684f314" translate="yes" xml:space="preserve">
          <source>If this property is not specified, it defaults to the value specified by the current style for the &lt;a href=&quot;qstyle#StyleHint-enum&quot;&gt;SH_Table_GridLineColor&lt;/a&gt; style hint.</source>
          <target state="translated">이 속성을 지정하지 않으면 &lt;a href=&quot;qstyle#StyleHint-enum&quot;&gt;SH_Table_GridLineColor&lt;/a&gt; 스타일 힌트 의 현재 스타일로 지정된 값이 기본값이됩니다 .</target>
        </trans-unit>
        <trans-unit id="636173856ac0f34d05e80b5a76914f7d9071d4e9" translate="yes" xml:space="preserve">
          <source>If this property is not specified, it defaults to the value specified by the current style for the &lt;a href=&quot;qstyle#StyleHint-enum&quot;&gt;SH_ToolTipLabel_Opacity&lt;/a&gt; style hint.</source>
          <target state="translated">이 속성을 지정하지 않으면 &lt;a href=&quot;qstyle#StyleHint-enum&quot;&gt;SH_ToolTipLabel_Opacity&lt;/a&gt; 스타일 힌트 의 현재 스타일로 지정된 값이 기본값이됩니다 .</target>
        </trans-unit>
        <trans-unit id="e0582a6ed2d27128183829fabbe94fdb129754f8" translate="yes" xml:space="preserve">
          <source>If this property is not specified, it defaults to the value specified by the current style for the &lt;a href=&quot;qstyle#StyleHint-enum&quot;&gt;SH_Widget_Animation_Duration&lt;/a&gt; style hint.</source>
          <target state="translated">이 속성을 지정하지 않으면 &lt;a href=&quot;qstyle#StyleHint-enum&quot;&gt;SH_Widget_Animation_Duration&lt;/a&gt; 스타일 힌트 의 현재 스타일로 지정된 값이 기본값이됩니다 .</target>
        </trans-unit>
        <trans-unit id="9c10a8fc492e2a041e5e5b896ae58fcfe08a6862" translate="yes" xml:space="preserve">
          <source>If this property is not specified, the alignment is &lt;code&gt;top&lt;/code&gt;&lt;code&gt;left&lt;/code&gt;.</source>
          <target state="translated">이 속성을 지정하지 않으면 정렬은 &lt;code&gt;left&lt;/code&gt; &lt;code&gt;top&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="004b03c1442e8b290689b0a4afc217501429b42a" translate="yes" xml:space="preserve">
          <source>If this property is not specified, the background image is repeated in both directions (&lt;code&gt;repeat&lt;/code&gt;).</source>
          <target state="translated">이 속성을 지정하지 않으면 배경 이미지가 양방향으로 반복됩니다 ( &lt;code&gt;repeat&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="69a72e994c4f4fa5f40820a65ee6afd2fbd3d2da" translate="yes" xml:space="preserve">
          <source>If this property is not specified, the default is &lt;code&gt;border&lt;/code&gt;.</source>
          <target state="translated">이 특성을 지정하지 않으면 기본값은 &lt;code&gt;border&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="765a33cef03b4b7a602c61c61b55037872a225c8" translate="yes" xml:space="preserve">
          <source>If this property is not specified, the default is &lt;code&gt;padding&lt;/code&gt;.</source>
          <target state="translated">이 특성을 지정하지 않으면 기본값은 &lt;code&gt;padding&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f2100e5d9bcfddac2c1db7cd1d6c224e3887a42c" translate="yes" xml:space="preserve">
          <source>If this property is not specified, the default value depends on the widget and on the current style.</source>
          <target state="translated">이 특성을 지정하지 않으면 기본값은 위젯 및 현재 스타일에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="f3202dba9a3c71ac7f0155c581932ff0bc8c0c77" translate="yes" xml:space="preserve">
          <source>If this property is not specified, the minimum height is derived based on the widget's contents and the style.</source>
          <target state="translated">이 속성을 지정하지 않으면 위젯의 내용과 스타일을 기반으로 최소 높이가 파생됩니다.</target>
        </trans-unit>
        <trans-unit id="8d1ab18bbbacbc91fbbfcec2b006eabe15adf347" translate="yes" xml:space="preserve">
          <source>If this property is not specified, the minimum width is derived based on the widget's contents and the style.</source>
          <target state="translated">이 속성을 지정하지 않으면 위젯의 내용과 스타일을 기반으로 최소 너비가 파생됩니다.</target>
        </trans-unit>
        <trans-unit id="ddfc1a9a045f051ec9e148c7e22b1e615f79db80" translate="yes" xml:space="preserve">
          <source>If this property is set to 1, the buttons of a &lt;a href=&quot;qdialogbuttonbox&quot;&gt;QDialogButtonBox&lt;/a&gt; show icons; if it is set to 0, the icons are not shown.</source>
          <target state="translated">이 속성을 1로 설정하면 &lt;a href=&quot;qdialogbuttonbox&quot;&gt;QDialogButtonBox&lt;/a&gt; 의 버튼에 아이콘이 표시됩니다. 0으로 설정하면 아이콘이 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5ea889e4a1a609463e178aea6ea50662e2d7cb12" translate="yes" xml:space="preserve">
          <source>If this property is set to &lt;a href=&quot;qml-qtquick-doublevalidator&quot;&gt;DoubleValidator&lt;/a&gt;.ScientificNotation, the written number may have an exponent part (e.g. 1.5E-2).</source>
          <target state="translated">이 속성을 &lt;a href=&quot;qml-qtquick-doublevalidator&quot;&gt;DoubleValidator&lt;/a&gt; .ScientificNotation 으로 설정 하면 기록 된 숫자에 지수 부분 (예 : 1.5E-2)이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="423369f0bccbe3ad1b049e743b395691ac9eae29" translate="yes" xml:space="preserve">
          <source>If this property is set to &lt;a href=&quot;qquickview#ResizeMode-enum&quot;&gt;SizeRootObjectToView&lt;/a&gt;, the view will automatically resize the root item to the size of the view.</source>
          <target state="translated">이 속성을 &lt;a href=&quot;qquickview#ResizeMode-enum&quot;&gt;SizeRootObjectToView&lt;/a&gt; 로 설정 하면보기는 루트 항목의 크기를보기 크기로 자동 조정합니다.</target>
        </trans-unit>
        <trans-unit id="2b6cc22135961a11630232ef4ca5c357712281f3" translate="yes" xml:space="preserve">
          <source>If this property is set to &lt;a href=&quot;qquickview#ResizeMode-enum&quot;&gt;SizeViewToRootObject&lt;/a&gt; (the default), the view resizes to the size of the root item in the QML.</source>
          <target state="translated">이 특성이 &lt;a href=&quot;qquickview#ResizeMode-enum&quot;&gt;SizeViewToRootObject&lt;/a&gt; (기본값)로 설정되면보기는 QML의 루트 항목 크기로 크기가 조정됩니다.</target>
        </trans-unit>
        <trans-unit id="07f8803a463d5487452b67d05fe6400f283cbeb9" translate="yes" xml:space="preserve">
          <source>If this property is set to &lt;a href=&quot;qquickwidget#ResizeMode-enum&quot;&gt;SizeRootObjectToView&lt;/a&gt;, the view will automatically resize the root item to the size of the view.</source>
          <target state="translated">이 속성을 &lt;a href=&quot;qquickwidget#ResizeMode-enum&quot;&gt;SizeRootObjectToView&lt;/a&gt; 로 설정 하면보기는 루트 항목의 크기를보기 크기로 자동 조정합니다.</target>
        </trans-unit>
        <trans-unit id="f2fced218968a4d34d7ebd4eb7b31ebc91bec20f" translate="yes" xml:space="preserve">
          <source>If this property is set to &lt;a href=&quot;qquickwidget#ResizeMode-enum&quot;&gt;SizeViewToRootObject&lt;/a&gt; (the default), the view resizes to the size of the root item in the QML.</source>
          <target state="translated">이 특성이 &lt;a href=&quot;qquickwidget#ResizeMode-enum&quot;&gt;SizeViewToRootObject&lt;/a&gt; (기본값)로 설정되면보기는 QML의 루트 항목 크기로 크기가 조정됩니다.</target>
        </trans-unit>
        <trans-unit id="f3d867eeb3b3d1e25f696270cf1cd5e2689c8a59" translate="yes" xml:space="preserve">
          <source>If this property is set to &lt;code&gt;Qt.KeyboardModifierMask&lt;/code&gt; (the default value), then the &lt;a href=&quot;qml-qtquick-pointerhandler&quot;&gt;PointerHandler&lt;/a&gt; ignores the modifier keys.</source>
          <target state="translated">이 속성이 &lt;code&gt;Qt.KeyboardModifierMask&lt;/code&gt; (기본값) 로 설정되어 있으면 &lt;a href=&quot;qml-qtquick-pointerhandler&quot;&gt;PointerHandler&lt;/a&gt; 는 수정 자 키를 무시합니다.</target>
        </trans-unit>
        <trans-unit id="6366fd344da23b031fea585a5cc134a19e749604" translate="yes" xml:space="preserve">
          <source>If this property is set to &lt;code&gt;false&lt;/code&gt;, the item will no longer receive mouse events, but will continue to receive key events and will retain the keyboard &lt;a href=&quot;qml-qtquick-item#focus-prop&quot;&gt;focus&lt;/a&gt; if it has been set. (In contrast, setting the &lt;a href=&quot;qml-qtquick-item#enabled-prop&quot;&gt;enabled&lt;/a&gt; property to &lt;code&gt;false&lt;/code&gt; stops both mouse and keyboard events, and also removes focus from the item.)</source>
          <target state="translated">이 속성이 &lt;code&gt;false&lt;/code&gt; 로 설정 되면 항목은 더 이상 마우스 이벤트를받지 않지만 키 이벤트를 계속 수신하며 설정된 경우 키보드 &lt;a href=&quot;qml-qtquick-item#focus-prop&quot;&gt;포커스를&lt;/a&gt; 유지합니다 . 반대로 &lt;a href=&quot;qml-qtquick-item#enabled-prop&quot;&gt;enabled&lt;/a&gt; 속성을 &lt;code&gt;false&lt;/code&gt; 로 설정하면 마우스 및 키보드 이벤트가 모두 중지되고 항목에서 포커스가 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="5232a5bf8d71a613191bf6438536119fdf838735" translate="yes" xml:space="preserve">
          <source>If this property is set to &lt;code&gt;false&lt;/code&gt;, the item will no longer receive mouse events, but will continue to receive key events and will retain the keyboard &lt;a href=&quot;qquickitem#focus-prop&quot;&gt;focus&lt;/a&gt; if it has been set. (In contrast, setting the &lt;a href=&quot;qquickitem#enabled-prop&quot;&gt;enabled&lt;/a&gt; property to &lt;code&gt;false&lt;/code&gt; stops both mouse and keyboard events, and also removes focus from the item.)</source>
          <target state="translated">이 속성이 &lt;code&gt;false&lt;/code&gt; 로 설정 되면 항목은 더 이상 마우스 이벤트를받지 않지만 키 이벤트를 계속 수신하며 설정된 경우 키보드 &lt;a href=&quot;qquickitem#focus-prop&quot;&gt;포커스를&lt;/a&gt; 유지합니다 . 반대로 &lt;a href=&quot;qquickitem#enabled-prop&quot;&gt;enabled&lt;/a&gt; 속성을 &lt;code&gt;false&lt;/code&gt; 로 설정하면 마우스 및 키보드 이벤트가 모두 중지되고 항목에서 포커스가 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="66bdcee7e239e418a59113255fddb1898b69364e" translate="yes" xml:space="preserve">
          <source>If this property is set to &lt;code&gt;true&lt;/code&gt;, such errors are ignored. This is useful if you intend to connect to different types of objects, handling a different set of signals for each object.</source>
          <target state="translated">이 특성을 &lt;code&gt;true&lt;/code&gt; 로 설정하면 이러한 오류가 무시됩니다. 이것은 다른 유형의 객체에 연결하여 각 객체에 대해 다른 신호 세트를 처리하려는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="34efb370c31d133ca86f26320d72fe66eca74221" translate="yes" xml:space="preserve">
          <source>If this property is set to &lt;code&gt;true&lt;/code&gt;, the &lt;a href=&quot;qml-qtquick-controls2-abstractbutton#pressAndHold-signal&quot;&gt;pressAndHold()&lt;/a&gt; signal will not be emitted.</source>
          <target state="translated">이 속성을 &lt;code&gt;true&lt;/code&gt; 로 설정 하면 &lt;a href=&quot;qml-qtquick-controls2-abstractbutton#pressAndHold-signal&quot;&gt;pressAndHold ()&lt;/a&gt; 신호가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9a40541afc9b72394b30c0cb4f263c787fdd0b37" translate="yes" xml:space="preserve">
          <source>If this property is set to &lt;code&gt;true&lt;/code&gt;, the text cannot be edited by user interaction.</source>
          <target state="translated">이 특성을 &lt;code&gt;true&lt;/code&gt; 로 설정하면 사용자 상호 작용으로 텍스트를 편집 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="81d1dca4364ecf91a97e5af46a5825729958bc5b" translate="yes" xml:space="preserve">
          <source>If this property is set to Text.ElideRight, it can be used with &lt;a href=&quot;qml-qtquick-text#wrapMode-prop&quot;&gt;wrapped&lt;/a&gt; text. The text will only elide if &lt;code&gt;maximumLineCount&lt;/code&gt;, or &lt;code&gt;height&lt;/code&gt; has been set. If both &lt;code&gt;maximumLineCount&lt;/code&gt; and &lt;code&gt;height&lt;/code&gt; are set, &lt;code&gt;maximumLineCount&lt;/code&gt; will apply unless the lines do not fit in the height allowed.</source>
          <target state="translated">이 속성을 Text.ElideRight로 설정하면 줄 &lt;a href=&quot;qml-qtquick-text#wrapMode-prop&quot;&gt;바꿈 된&lt;/a&gt; 텍스트 와 함께 사용할 수 있습니다 . &lt;code&gt;maximumLineCount&lt;/code&gt; 또는 &lt;code&gt;height&lt;/code&gt; 가 설정된 경우에만 텍스트가 제거됩니다 . &lt;code&gt;maximumLineCount&lt;/code&gt; 와 &lt;code&gt;height&lt;/code&gt; 가 모두 설정되어 있으면 선이 허용 된 높이에 맞지 않는 한 &lt;code&gt;maximumLineCount&lt;/code&gt; 가 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="2bc1dd9e563b5d0004881a9c3732ed0db548f760" translate="yes" xml:space="preserve">
          <source>If this property is set to a &lt;a href=&quot;qml-geocircle&quot;&gt;geocircle&lt;/a&gt; its &lt;a href=&quot;qml-geocircle&quot;&gt;radius&lt;/a&gt; property may be left unset, in which case the &lt;a href=&quot;location-places-qml#plugin&quot;&gt;Plugin&lt;/a&gt; will choose an appropriate radius for the search.</source>
          <target state="translated">이 속성은로 설정되어있는 경우 &lt;a href=&quot;qml-geocircle&quot;&gt;geocircle&lt;/a&gt; 의 &lt;a href=&quot;qml-geocircle&quot;&gt;반경&lt;/a&gt; 이 경우 속성이 설정되지 않은 남아있을 수 있습니다, &lt;a href=&quot;location-places-qml#plugin&quot;&gt;플러그인&lt;/a&gt; 검색에 대한 적절한 반경을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="cd8444bbc126a20a30c8fbf7f7c40dfb4bd970dc" translate="yes" xml:space="preserve">
          <source>If this property is set to a positive value, the &lt;a href=&quot;qcombobox#minimumSizeHint&quot;&gt;minimumSizeHint&lt;/a&gt;() and &lt;a href=&quot;qcombobox#sizeHint&quot;&gt;sizeHint&lt;/a&gt;() take it into account.</source>
          <target state="translated">이 속성을 양수 값으로 설정하면 &lt;a href=&quot;qcombobox#minimumSizeHint&quot;&gt;minimumSizeHint&lt;/a&gt; () 및 &lt;a href=&quot;qcombobox#sizeHint&quot;&gt;sizeHint&lt;/a&gt; () 가이 를 고려합니다.</target>
        </trans-unit>
        <trans-unit id="5073e1a3a91e8f12240a132738f629a8c5bc6b8e" translate="yes" xml:space="preserve">
          <source>If this property is set to a string with more than one character, the first character is used. If the string is empty, the value is ignored and the property is not set.</source>
          <target state="translated">이 특성이 둘 이상의 문자가있는 문자열로 설정되면 첫 번째 문자가 사용됩니다. 문자열이 비어 있으면 값이 무시되고 속성이 설정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="24519db9032f311679b8872a0437d577a4382eff" translate="yes" xml:space="preserve">
          <source>If this property is set to a value other than &lt;a href=&quot;q3dscene#invalidSelectionPoint&quot;&gt;invalidSelectionPoint&lt;/a&gt;(), the graph tries to match a graph position to the specified coordinates within the primary viewport. After the rendering pass, this property is returned to its default state of &lt;a href=&quot;q3dscene#invalidSelectionPoint&quot;&gt;invalidSelectionPoint&lt;/a&gt;(). The queried graph position can be read from the &lt;a href=&quot;qabstract3dgraph#queriedGraphPosition-prop&quot;&gt;QAbstract3DGraph::queriedGraphPosition&lt;/a&gt; property after the next render pass.</source>
          <target state="translated">이 속성이 &lt;a href=&quot;q3dscene#invalidSelectionPoint&quot;&gt;invalidSelectionPoint&lt;/a&gt; () 이외의 값으로 설정 되면 그래프는 그래프 위치를 기본 뷰포트 내의 지정된 좌표와 일치 시키려고합니다. 렌더링 패스 후이 속성은 기본 상태 인 &lt;a href=&quot;q3dscene#invalidSelectionPoint&quot;&gt;invalidSelectionPoint&lt;/a&gt; () 로 반환됩니다 . 쿼리 된 그래프 위치는 다음 렌더링 패스 후 &lt;a href=&quot;qabstract3dgraph#queriedGraphPosition-prop&quot;&gt;QAbstract3DGraph :: queriedGraphPosition&lt;/a&gt; 속성 에서 읽을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d4819a3283fa793ebdc1cb160b4f5c2c5e9d0641" translate="yes" xml:space="preserve">
          <source>If this property is set to a value other than &lt;a href=&quot;q3dscene#invalidSelectionPoint&quot;&gt;invalidSelectionPoint&lt;/a&gt;(), the graph tries to select a data item, axis label, or a custom item at the specified coordinates within the primary viewport. After the rendering pass, the property is returned to its default state of &lt;a href=&quot;q3dscene#invalidSelectionPoint&quot;&gt;invalidSelectionPoint&lt;/a&gt;().</source>
          <target state="translated">이 속성이 &lt;a href=&quot;q3dscene#invalidSelectionPoint&quot;&gt;invalidSelectionPoint&lt;/a&gt; () 이외의 값으로 설정되어 있으면 그래프는 기본 뷰포트 내의 지정된 좌표에서 데이터 항목, 축 레이블 또는 사용자 지정 항목을 선택하려고합니다. 렌더링 단계가 끝나면 속성이 기본 상태 인 &lt;a href=&quot;q3dscene#invalidSelectionPoint&quot;&gt;invalidSelectionPoint&lt;/a&gt; () 로 돌아갑니다 .</target>
        </trans-unit>
        <trans-unit id="42b19a605fa9c22e528488387800a0ee59e9fa45" translate="yes" xml:space="preserve">
          <source>If this property is set to false (the default), the scroll area honors the size of its widget. Regardless of this property, you can programmatically resize the widget using &lt;a href=&quot;qscrollarea#widget&quot;&gt;widget&lt;/a&gt;()-&amp;gt;&lt;a href=&quot;qwidget#size-prop&quot;&gt;resize&lt;/a&gt;(), and the scroll area will automatically adjust itself to the new size.</source>
          <target state="translated">이 특성을 false (기본값)로 설정하면 스크롤 영역이 해당 위젯의 크기를 따릅니다. 이 속성에 관계없이 &lt;a href=&quot;qscrollarea#widget&quot;&gt;widget&lt;/a&gt; ()-&amp;gt; &lt;a href=&quot;qwidget#size-prop&quot;&gt;resize&lt;/a&gt; ()를 사용하여 프로그래밍 방식으로 위젯 크기를 조정할 수 있으며 스크롤 영역이 자동으로 새 크기로 조정됩니다.</target>
        </trans-unit>
        <trans-unit id="dffe0bf3de65cba72b12a808e508b4b59cd7f02e" translate="yes" xml:space="preserve">
          <source>If this property is set to false, the directory model will allow renaming, copying and deleting of files and directories.</source>
          <target state="translated">이 특성이 false로 설정되면 디렉토리 모델은 파일 및 디렉토리의 이름 바꾸기, 복사 및 삭제를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="73db8d9a3359c83beafc44ef47d13b3f7e9c29e0" translate="yes" xml:space="preserve">
          <source>If this property is set to false, the directory model will make sure that a directory actually containes any files before reporting that it has children. Otherwise the directory model will report that an item has children if the item is a directory.</source>
          <target state="translated">이 특성이 false로 설정되면 디렉토리 모델은 디렉토리에 하위 파일이 있음을보고하기 전에 디렉토리에 실제로 파일이 포함되어 있는지 확인합니다. 그렇지 않으면 디렉토리 모델은 항목이 디렉토리 인 경우 항목에 하위 항목이 있다고보고합니다.</target>
        </trans-unit>
        <trans-unit id="b902cb4a8201d02db6d9d70ded5ab6faf1e5a5c5" translate="yes" xml:space="preserve">
          <source>If this property is set to true (the default), the &lt;a href=&quot;qabstractitemview&quot;&gt;QAbstractItemView&lt;/a&gt; automatically scrolls the contents of the view if the user drags within 16 pixels of the viewport edge. If the current item changes, then the view will scroll automatically to ensure that the current item is fully visible.</source>
          <target state="translated">이 속성을 true로 설정하면 (기본값) &lt;a href=&quot;qabstractitemview&quot;&gt;QAbstractItemView&lt;/a&gt; 는 사용자가 뷰포트 가장자리의 16 픽셀 내에서 드래그하면 뷰의 내용을 자동으로 스크롤합니다. 현재 항목이 변경되면보기가 자동으로 스크롤되어 현재 항목이 완전히 표시되도록합니다.</target>
        </trans-unit>
        <trans-unit id="77e17ab9cb69247e19e78243865c4f4566d7e5e0" translate="yes" xml:space="preserve">
          <source>If this property is set to true then the push button is an auto default button.</source>
          <target state="translated">이 속성이 true로 설정되면 푸시 버튼이 자동 기본 버튼입니다.</target>
        </trans-unit>
        <trans-unit id="bd4d7e8be29dc04fe8fcc195fc1d9f928771996c" translate="yes" xml:space="preserve">
          <source>If this property is set to true, the layout will use design metrics. Otherwise, the metrics of the paint device as set on &lt;a href=&quot;qabstracttextdocumentlayout#setPaintDevice&quot;&gt;QAbstractTextDocumentLayout::setPaintDevice&lt;/a&gt;() will be used.</source>
          <target state="translated">이 속성이 true로 설정되면 레이아웃은 디자인 메트릭을 사용합니다. 그렇지 않으면 &lt;a href=&quot;qabstracttextdocumentlayout#setPaintDevice&quot;&gt;QAbstractTextDocumentLayout :: setPaintDevice&lt;/a&gt; () 에 설정된 페인트 장치의 메트릭 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="03637033cd890d8ee0857569835f921d8c015e6e" translate="yes" xml:space="preserve">
          <source>If this property is set to true, the scroll area will automatically resize the widget in order to avoid scroll bars where they can be avoided, or to take advantage of extra space.</source>
          <target state="translated">이 속성을 true로 설정하면 스크롤 영역을 피할 수있는 스크롤 막대를 피하거나 추가 공간을 활용하기 위해 스크롤 영역이 위젯의 ​​크기를 자동으로 조정합니다.</target>
        </trans-unit>
        <trans-unit id="e85d5238f3aa170516f706f46ee54ee289390e68" translate="yes" xml:space="preserve">
          <source>If this property is set to true, then when the mouse or touchpoint moves far enough to begin dragging the content, the content will jump, such that the content pixel which was under the cursor or touchpoint when pressed remains under that point.</source>
          <target state="translated">이 속성을 true로 설정하면 마우스 나 터치 포인트가 내용 드래그를 시작하기에 충분히 멀어 질 때 커서 나 터치 포인트 아래에있는 내용 픽셀이 해당 지점 아래에 있도록 내용이 이동합니다.</target>
        </trans-unit>
        <trans-unit id="b6c31bd5baa06d8885b24ef5e66ab710bfe11bdd" translate="yes" xml:space="preserve">
          <source>If this property is set, it will require the given keyboard modifiers to be pressed in order to react to pointer events, and otherwise ignore them.</source>
          <target state="translated">이 속성이 설정되면 포인터 이벤트에 반응하고 그렇지 않으면 무시하기 위해 주어진 키보드 수정자를 눌러야합니다.</target>
        </trans-unit>
        <trans-unit id="25fe5ac4eb56116ee6ca70945d9be5b3239a3f40" translate="yes" xml:space="preserve">
          <source>If this property is true (the default value), the highlight is moved smoothly to follow the current item. Otherwise, the highlight is not moved by the view, and any movement must be implemented by the highlight.</source>
          <target state="translated">이 속성이 true (기본값)이면 강조 표시가 부드럽게 이동하여 현재 항목을 따릅니다. 그렇지 않으면, 강조 표시가 뷰에 의해 이동되지 않으며 강조 표시로 이동을 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="bf95bb03f5821fcf12dd4d7d6ad98fea00a68180" translate="yes" xml:space="preserve">
          <source>If this property is true, all modes previously added are replaced by a mode that matches window size and screen refresh rate.</source>
          <target state="translated">이 속성이 true이면 이전에 추가 된 모든 모드가 창 크기 및 화면 새로 고침 빈도와 일치하는 모드로 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="7b2733c56d01fa4157e4f403f2b95d130cfc23e0" translate="yes" xml:space="preserve">
          <source>If this property is true, mipmaps are generated for the texture.</source>
          <target state="translated">이 속성이 true이면 텍스처에 대한 밉맵이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="89447fa2e019d30a0cde9a6f6c2bc28f70765698" translate="yes" xml:space="preserve">
          <source>If this property is true, the &lt;a href=&quot;qml-qtquick-shadereffectsource#sourceItem-prop&quot;&gt;sourceItem&lt;/a&gt; is hidden, though it will still be rendered into the texture. As opposed to hiding the &lt;a href=&quot;qml-qtquick-shadereffectsource#sourceItem-prop&quot;&gt;sourceItem&lt;/a&gt; by setting &lt;a href=&quot;qml-qtquick-item#visible-prop&quot;&gt;visible&lt;/a&gt; to false, setting this property to true will not prevent mouse or keyboard input from reaching &lt;a href=&quot;qml-qtquick-shadereffectsource#sourceItem-prop&quot;&gt;sourceItem&lt;/a&gt;. The property is useful when the &lt;a href=&quot;qml-qtquick-shadereffectsource&quot;&gt;ShaderEffectSource&lt;/a&gt; is anchored on top of, and meant to replace the &lt;a href=&quot;qml-qtquick-shadereffectsource#sourceItem-prop&quot;&gt;sourceItem&lt;/a&gt;.</source>
          <target state="translated">이 속성이 true이면 &lt;a href=&quot;qml-qtquick-shadereffectsource#sourceItem-prop&quot;&gt;sourceItem&lt;/a&gt; 은 숨겨 지지만 여전히 텍스처에 렌더링됩니다. &lt;a href=&quot;qml-qtquick-item#visible-prop&quot;&gt;visible&lt;/a&gt; 을 false 로 설정 하여 &lt;a href=&quot;qml-qtquick-shadereffectsource#sourceItem-prop&quot;&gt;sourceItem&lt;/a&gt; 을 숨기는 대신 이 속성을 true로 설정하면 마우스 또는 키보드 입력이 &lt;a href=&quot;qml-qtquick-shadereffectsource#sourceItem-prop&quot;&gt;sourceItem&lt;/a&gt; 에 도달하지 못하게 됩니다. 이 속성은 &lt;a href=&quot;qml-qtquick-shadereffectsource&quot;&gt;ShaderEffectSource&lt;/a&gt; 가 맨 위에 고정되어 &lt;a href=&quot;qml-qtquick-shadereffectsource#sourceItem-prop&quot;&gt;sourceItem&lt;/a&gt; 을 대체 할 때 유용 합니다.</target>
        </trans-unit>
        <trans-unit id="e89a18c8e26d330e01784117924442056151df7c" translate="yes" xml:space="preserve">
          <source>If this property is true, the group box displays its title using a checkbox in place of an ordinary label. If the checkbox is checked, the group box's children are enabled; otherwise, they are disabled and inaccessible.</source>
          <target state="translated">이 속성이 true 인 경우 그룹 상자는 일반 레이블 대신 확인란을 사용하여 제목을 표시합니다. 확인란을 선택하면 그룹 상자의 자식이 활성화됩니다. 그렇지 않으면 비활성화되어 액세스 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3ffa897652f13df657629066b7c43e9a90efd919" translate="yes" xml:space="preserve">
          <source>If this property is true, the input language is only changed between the languages providing custom layout.</source>
          <target state="translated">이 속성이 true 인 경우 입력 언어는 사용자 정의 레이아웃을 제공하는 언어 사이에서만 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="dd815bf468ce6a60d7025c43eb015d99838d9f25" translate="yes" xml:space="preserve">
          <source>If this property is true, the output from the &lt;a href=&quot;qml-qtquick-shadereffect#fragmentShader-prop&quot;&gt;fragmentShader&lt;/a&gt; is blended with the background using source-over blend mode. If false, the background is disregarded. Blending decreases the performance, so you should set this property to false when blending is not needed. The default value is true.</source>
          <target state="translated">이 속성이 true 인 경우 &lt;a href=&quot;qml-qtquick-shadereffect#fragmentShader-prop&quot;&gt;fragmentShader&lt;/a&gt; 의 출력은 소스 오버 블렌드 모드를 사용하여 배경과 블렌딩됩니다. False이면 배경이 무시됩니다. 혼합하면 성능이 저하되므로 혼합이 필요하지 않은 경우이 속성을 false로 설정해야합니다. 기본값은 true입니다.</target>
        </trans-unit>
        <trans-unit id="087dbab36012dedcc9fda210a6cdb2a5d231a6a1" translate="yes" xml:space="preserve">
          <source>If this property is true, the texture is updated whenever the &lt;a href=&quot;qml-qtquick-shadereffectsource#sourceItem-prop&quot;&gt;sourceItem&lt;/a&gt; updates. Otherwise, it will be a frozen image, even if &lt;a href=&quot;qml-qtquick-shadereffectsource#sourceItem-prop&quot;&gt;sourceItem&lt;/a&gt; is assigned a new item. The property is true by default.</source>
          <target state="translated">이 속성이 true이면 &lt;a href=&quot;qml-qtquick-shadereffectsource#sourceItem-prop&quot;&gt;sourceItem&lt;/a&gt; 이 업데이트 될 때마다 텍스처가 업데이트 됩니다. 그렇지 않으면 &lt;a href=&quot;qml-qtquick-shadereffectsource#sourceItem-prop&quot;&gt;sourceItem&lt;/a&gt; 에 새 항목이 할당 된 경우에도 정지 된 이미지 가됩니다. 이 속성은 기본적으로 true입니다.</target>
        </trans-unit>
        <trans-unit id="1069f4aa7662a23db3bc3f703a9bbce8417c8892" translate="yes" xml:space="preserve">
          <source>If this property is used, then the value of &lt;a href=&quot;qml-qtquick3d-texture#source-prop&quot;&gt;source&lt;/a&gt; will be ignored.</source>
          <target state="translated">이 속성을 사용하면 &lt;a href=&quot;qml-qtquick3d-texture#source-prop&quot;&gt;source&lt;/a&gt; 값 이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="7f8916f4a9cec10b1dcff7b2a3cd3d66cb3a8470" translate="yes" xml:space="preserve">
          <source>If this property isn't explicitly set, this property defaults to the lowest page ID in this wizard, or -1 if no page has been inserted yet.</source>
          <target state="translated">이 속성이 명시 적으로 설정되어 있지 않으면이 속성의 기본값은이 마법사에서 가장 낮은 페이지 ID이거나, 아직 페이지가 삽입되지 않은 경우 -1입니다.</target>
        </trans-unit>
        <trans-unit id="cedd1c5bc0f5c4691d1c0ec92043e9cc0fbc045c" translate="yes" xml:space="preserve">
          <source>If this property of a &lt;a href=&quot;qml-qtquick-tableview&quot;&gt;TableView&lt;/a&gt; is set to another &lt;a href=&quot;qml-qtquick-tableview&quot;&gt;TableView&lt;/a&gt;, both the tables will synchronize with regard to flicking, column widths/row heights, and spacing according to &lt;a href=&quot;qml-qtquick-tableview#syncDirection-prop&quot;&gt;syncDirection&lt;/a&gt;.</source>
          <target state="translated">(A)의 특성이 경우 &lt;a href=&quot;qml-qtquick-tableview&quot;&gt;의 TableView는&lt;/a&gt; 다른 설정 &lt;a href=&quot;qml-qtquick-tableview&quot;&gt;의 TableView&lt;/a&gt; , 두 테이블에있어서, 열 너비 / 높이 열 플릭 및 간격에 관하여 동기화 할 &lt;a href=&quot;qml-qtquick-tableview#syncDirection-prop&quot;&gt;syncDirection&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5201e8ead5ff6d46b87bf4737671f6e806f5d6ab" translate="yes" xml:space="preserve">
          <source>If this property value is &lt;code&gt;true&lt;/code&gt;, &lt;a href=&quot;qcustom3dvolume#alphaMultiplier-prop&quot;&gt;alphaMultiplier&lt;/a&gt; is only applied to texels that already have some transparency. If it is &lt;code&gt;false&lt;/code&gt;, the multiplier is applied to the alpha value of all texels. Defaults to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">이 속성 값이 &lt;code&gt;true&lt;/code&gt; 인 경우 &lt;a href=&quot;qcustom3dvolume#alphaMultiplier-prop&quot;&gt;alphaMultiplier&lt;/a&gt; 는 이미 일부 투명도가있는 텍셀에만 적용됩니다. 이 경우 &lt;code&gt;false&lt;/code&gt; , 승산기 모든 텍셀의 알파 값이 적용된다. 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6fc259e5e43ffbe64eb36d15782f9675d43f45df" translate="yes" xml:space="preserve">
          <source>If this property value is &lt;code&gt;true&lt;/code&gt;, &lt;a href=&quot;qml-qtdatavisualization-custom3dvolume#alphaMultiplier-prop&quot;&gt;alphaMultiplier&lt;/a&gt; is only applied to texels that already have some transparency. If it is &lt;code&gt;false&lt;/code&gt;, the multiplier is applied to the alpha value of all texels. Defaults to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">이 속성 값이 &lt;code&gt;true&lt;/code&gt; 인 경우 &lt;a href=&quot;qml-qtdatavisualization-custom3dvolume#alphaMultiplier-prop&quot;&gt;alphaMultiplier&lt;/a&gt; 는 이미 일부 투명도가있는 텍셀에만 적용됩니다. 이 경우 &lt;code&gt;false&lt;/code&gt; , 승산기 모든 텍셀의 알파 값이 적용된다. 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6dbfc4991bf3c40a30965d0be67022d20d746264" translate="yes" xml:space="preserve">
          <source>If this property value is &lt;code&gt;true&lt;/code&gt;, a high definition shader is used to render the volume. If it is &lt;code&gt;false&lt;/code&gt;, a low definition shader is used.</source>
          <target state="translated">이 속성 값이 &lt;code&gt;true&lt;/code&gt; 인 경우 고화질 셰이더를 사용하여 볼륨을 렌더링합니다. 이 경우 &lt;code&gt;false&lt;/code&gt; , 낮은 정의 쉐이더가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0535fc8be4ff3e7ee689d37203fda50da5c481f5" translate="yes" xml:space="preserve">
          <source>If this property value is &lt;code&gt;true&lt;/code&gt;, a high definition shader is used. If it is &lt;code&gt;false&lt;/code&gt;, a low definition shader is used.</source>
          <target state="translated">이 속성 값이 &lt;code&gt;true&lt;/code&gt; 인 경우 고화질 셰이더가 사용됩니다. 이 경우 &lt;code&gt;false&lt;/code&gt; , 낮은 정의 쉐이더가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="154021c467523c3ca86789d97f5f9291d5be2648" translate="yes" xml:space="preserve">
          <source>If this property value is &lt;code&gt;true&lt;/code&gt;, the frames of slices indicated by slice index properties will be drawn around the volume. If it is &lt;code&gt;false&lt;/code&gt;, no slice frames will be drawn.</source>
          <target state="translated">이 속성 값이 &lt;code&gt;true&lt;/code&gt; 인 경우 슬라이스 인덱스 속성으로 표시되는 슬라이스 프레임이 볼륨 주위에 그려집니다. 이 경우 &lt;code&gt;false&lt;/code&gt; , 더 슬라이스 프레임이 그려되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4b3638960eac959f8c4c52e78f407f5b0a5e50f2" translate="yes" xml:space="preserve">
          <source>If this property value is &lt;code&gt;true&lt;/code&gt;, the frames of slices indicated by slice index properties will be drawn around the volume. If it is &lt;code&gt;false&lt;/code&gt;, no slice frames will be drawn. Drawing slice frames is independent of drawing slices, so you can show the full volume and still draw the slice frames around it. Defaults to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">이 속성 값이 &lt;code&gt;true&lt;/code&gt; 인 경우 슬라이스 인덱스 속성으로 표시되는 슬라이스 프레임이 볼륨 주위에 그려집니다. 이 경우 &lt;code&gt;false&lt;/code&gt; , 더 슬라이스 프레임이 그려되지 않습니다. 도면 슬라이스 프레임은 도면 슬라이스와 무관하므로 전체 볼륨을 표시하고 그 주위에 슬라이스 프레임을 그릴 수 있습니다. 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="de0a025be717c756c002f1c5819353a5b1b6b769" translate="yes" xml:space="preserve">
          <source>If this property value is &lt;code&gt;true&lt;/code&gt;, the slices indicated by slice index properties will be drawn instead of the full volume. If it is &lt;code&gt;false&lt;/code&gt;, the full volume will always be drawn. Defaults to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">이 속성 값이 &lt;code&gt;true&lt;/code&gt; 인 경우 슬라이스 인덱스 속성으로 표시된 슬라이스는 전체 볼륨 대신 그려집니다. &lt;code&gt;false&lt;/code&gt; 인 경우 항상 전체 볼륨이 그려집니다. 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8a080765111764977c8ae9223ac764cb884d1aa9" translate="yes" xml:space="preserve">
          <source>If this property value is set to &lt;code&gt;true&lt;/code&gt;, the parent axis sub-segment count is ignored when calculating sub-grid line positions. The sub-grid positions are generated automatically according to the &lt;a href=&quot;qlogvalue3daxisformatter#base-prop&quot;&gt;base&lt;/a&gt; property value. The number of sub-grid lines is set to the base value minus one, rounded down. This property is ignored when the base value is zero. Defaults to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">이 특성 값을 &lt;code&gt;true&lt;/code&gt; 로 설정하면 하위 그리드 선 위치를 계산할 때 상위 축 하위 세그먼트 수가 무시됩니다. 하위 표 위치는 &lt;a href=&quot;qlogvalue3daxisformatter#base-prop&quot;&gt;기본&lt;/a&gt; 속성 값 에 따라 자동으로 생성됩니다 . 서브 그리드 라인의 수는 반올림 한 기본 값에서 1을 뺀 값으로 설정됩니다. 기본 값이 0이면이 속성이 무시됩니다. 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="099b07f85765cd016c077eadb3bacd9ff0df9676" translate="yes" xml:space="preserve">
          <source>If this property value is set to &lt;code&gt;true&lt;/code&gt;, the parent axis sub-segment count is ignored when calculating sub-grid line positions. The sub-grid positions are generated automatically according to the &lt;a href=&quot;qml-qtdatavisualization-logvalueaxis3dformatter#base-prop&quot;&gt;base&lt;/a&gt; property value. The number of sub-grid lines is set to the base value minus one, rounded down. This property is ignored when the base value is zero. Defaults to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">이 특성 값을 &lt;code&gt;true&lt;/code&gt; 로 설정하면 하위 그리드 선 위치를 계산할 때 상위 축 하위 세그먼트 수가 무시됩니다. 하위 표 위치는 &lt;a href=&quot;qml-qtdatavisualization-logvalueaxis3dformatter#base-prop&quot;&gt;기본&lt;/a&gt; 속성 값 에 따라 자동으로 생성됩니다 . 서브 그리드 라인의 수는 반올림 한 기본 값에서 1을 뺀 값으로 설정됩니다. 기본 값이 0이면이 속성이 무시됩니다. 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="20822bb1322d8d5d555634ab7bd0e780d999181e" translate="yes" xml:space="preserve">
          <source>If this quaternion is null, then a null quaternion is returned. If the length of the quaternion is very close to 1, then the quaternion will be returned as-is. Otherwise the normalized form of the quaternion of length 1 will be returned.</source>
          <target state="translated">이 쿼터니언이 널이면 널 쿼터니언이 리턴됩니다. 쿼터니언의 길이가 1에 매우 가까운 경우 쿼터니언은 그대로 반환됩니다. 그렇지 않으면 길이가 1 인 쿼터니언의 정규화 된 형식이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="35a24e099253b5a88e67f643863078439300a407" translate="yes" xml:space="preserve">
          <source>If this query &lt;a href=&quot;qxmlquery#isValid&quot;&gt;is invalid&lt;/a&gt;, &lt;code&gt;false&lt;/code&gt; is returned and the behavior is undefined. If</source>
          <target state="translated">이 쿼리는 경우 &lt;a href=&quot;qxmlquery#isValid&quot;&gt;무효&lt;/a&gt; , &lt;code&gt;false&lt;/code&gt; 반환되고, 동작은 정의되지 않는다. 만약</target>
        </trans-unit>
        <trans-unit id="e5c1dc074e2b5cf55ce9fa79c5c23d3d373abae7" translate="yes" xml:space="preserve">
          <source>If this role is not defined, &lt;a href=&quot;qitemmodelsurfacedataproxy#columnRole-prop&quot;&gt;columnRole&lt;/a&gt; is used to determine the X-coordinate value of the resolved &lt;a href=&quot;qsurfacedataitem&quot;&gt;QSurfaceDataItem&lt;/a&gt; objects.</source>
          <target state="translated">이 역할이 정의되지 않은 경우 &lt;a href=&quot;qitemmodelsurfacedataproxy#columnRole-prop&quot;&gt;columnRole&lt;/a&gt; 은 해석 된 &lt;a href=&quot;qsurfacedataitem&quot;&gt;QSurfaceDataItem&lt;/a&gt; 오브젝트 의 X 좌표 값을 판별하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="ff74e676e7544e509b5582d354341c399728fce4" translate="yes" xml:space="preserve">
          <source>If this role is not defined, &lt;a href=&quot;qitemmodelsurfacedataproxy#rowRole-prop&quot;&gt;rowRole&lt;/a&gt; is used to determine the Z-coordinate value of resolved &lt;a href=&quot;qsurfacedataitem&quot;&gt;QSurfaceDataItem&lt;/a&gt; objects.</source>
          <target state="translated">이 역할이 정의되지 않은 경우 &lt;a href=&quot;qitemmodelsurfacedataproxy#rowRole-prop&quot;&gt;rowRole&lt;/a&gt; 을 사용하여 해결 된 &lt;a href=&quot;qsurfacedataitem&quot;&gt;QSurfaceDataItem&lt;/a&gt; 객체 의 Z 좌표 값을 결정 합니다.</target>
        </trans-unit>
        <trans-unit id="04bbf11a73aed0531f71d0c57ea7e9e4c1a965a3" translate="yes" xml:space="preserve">
          <source>If this routing manager supports returning addresses and instructions in different languages, they will be returned in the language of</source>
          <target state="translated">이 라우팅 관리자가 다른 언어로 주소 및 명령어 반환을 지원하는 경우 해당 언어로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="438d6327741e081d67b307e3db8df1c170b54cae" translate="yes" xml:space="preserve">
          <source>If this semaphore releaser had the responsibility to call some &lt;a href=&quot;qsemaphore#release&quot;&gt;QSemaphore::release&lt;/a&gt;() itself, it performs the call before taking over from</source>
          <target state="translated">이 세마포어 &lt;a href=&quot;qsemaphore#release&quot;&gt;릴리스가 QSemaphore :: release&lt;/a&gt; () 자체 를 호출 할 책임이있는 경우,이 세마포어 릴리스 가</target>
        </trans-unit>
        <trans-unit id="76f8e89e49be027007923c5da18f2ac36b55048a" translate="yes" xml:space="preserve">
          <source>If this series is added to a graph, the graph can adjust the selection according to user interaction or if it becomes invalid. Selecting a bar on another added series will also clear the selection.</source>
          <target state="translated">이 계열이 그래프에 추가되면 그래프는 사용자 상호 작용에 따라 또는 유효하지 않은 경우 선택을 조정할 수 있습니다. 추가 된 다른 시리즈에서 막대를 선택하면 선택이 취소됩니다.</target>
        </trans-unit>
        <trans-unit id="dac5211fea0cb72bd6621ff926124b6ba8d2f0d0" translate="yes" xml:space="preserve">
          <source>If this server is using &lt;a href=&quot;qnetworkproxy&quot;&gt;QNetworkProxy&lt;/a&gt; then the</source>
          <target state="translated">이 서버가 &lt;a href=&quot;qnetworkproxy&quot;&gt;QNetworkProxy&lt;/a&gt; 를 사용 중인 경우</target>
        </trans-unit>
        <trans-unit id="f5d8c50648a0b644233d60c7ba35bbb736326e83" translate="yes" xml:space="preserve">
          <source>If this setting is changed while a sound effect is playing it will only take effect when the sound effect has stopped playing.</source>
          <target state="translated">음향 효과가 재생되는 동안이 설정을 변경하면 음향 효과 재생이 중지 된 경우에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="e16bb50fe73b95cd7e166915a565003f6568c417" translate="yes" xml:space="preserve">
          <source>If this signal is not handled, the requested load will fail.</source>
          <target state="translated">이 신호를 처리하지 않으면 요청 된로드가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="fef3fff95a20a7e18389569e5f35c67c5dbfb14c" translate="yes" xml:space="preserve">
          <source>If this string contains any characters that cannot be encoded in the locale, the returned byte array is undefined. Those characters may be suppressed or replaced by another.</source>
          <target state="translated">이 문자열에 로캘로 인코딩 할 수없는 문자가 포함되어 있으면 반환 된 바이트 배열이 정의되지 않은 것입니다. 이러한 문자는 억제되거나 다른 문자로 대체 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="84544065e3e948d468bd49f34c162f9954e26724" translate="yes" xml:space="preserve">
          <source>If this test fails, it will give no clue as to why the file failed to open:</source>
          <target state="translated">이 테스트가 실패하면 파일이 열리지 않은 이유를 알 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d94bc2ada40f1077e7ae7e64b7e5c22d1bd6355f" translate="yes" xml:space="preserve">
          <source>If this true the animation will complete its current iteration when it is stopped - either by setting the &lt;code&gt;running&lt;/code&gt; property to false, or by calling the &lt;code&gt;stop()&lt;/code&gt; method. The &lt;code&gt;complete()&lt;/code&gt; method is not effected by this value.</source>
          <target state="translated">이 속성 이 true이면 애니메이션이 중지 될 때 현재 반복을 완료합니다. &lt;code&gt;running&lt;/code&gt; 속성을 false 로 설정 하거나 &lt;code&gt;stop()&lt;/code&gt; 메서드를 호출합니다 . &lt;code&gt;complete()&lt;/code&gt; 메소드는이 값에 의해 수행되지 않는다.</target>
        </trans-unit>
        <trans-unit id="1eb0f67e00d17b82f6530359a63f2aeaaad3a7b3" translate="yes" xml:space="preserve">
          <source>If this value is greater than zero, the view may keep as many delegates instantiated as it can fit within the buffer specified. For example, if in a vertical view the delegate is 20 pixels high and &lt;code&gt;cacheBuffer&lt;/code&gt; is set to 40, then up to 2 delegates above and 2 delegates below the visible area may be created/retained. The buffered delegates are created asynchronously, allowing creation to occur across multiple frames and reducing the likelihood of skipping frames. In order to improve painting performance delegates outside the visible area are not painted.</source>
          <target state="translated">이 값이 0보다 큰 경우, 뷰는 지정된 버퍼 내에 들어갈 수있는만큼 많은 델리게이트를 인스턴스화 할 수 있습니다. 예를 들어 세로보기에서 델리게이트의 높이가 20 픽셀이고 &lt;code&gt;cacheBuffer&lt;/code&gt; 가 40으로 설정된 경우 표시 영역 아래에서 최대 2 개의 델리게이트 및 2 개의 델리게이트가 작성 / 보존 될 수 있습니다. 버퍼 된 델리게이트는 비동기 적으로 생성되므로 여러 프레임에서 생성이 가능하며 프레임을 건너 뛸 가능성이 줄어 듭니다. 페인팅 성능을 향상시키기 위해 표시 영역 외부의 델리게이트는 페인트되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d7ad9ed01be513c9164d477bfd55038c8472be79" translate="yes" xml:space="preserve">
          <source>If this value is greater than zero, the view may keep as many delegates instantiated as will fit within the buffer specified. For example, if in a vertical view the delegate is 20 pixels high, there are 3 columns and &lt;code&gt;cacheBuffer&lt;/code&gt; is set to 40, then up to 6 delegates above and 6 delegates below the visible area may be created/retained. The buffered delegates are created asynchronously, allowing creation to occur across multiple frames and reducing the likelihood of skipping frames. In order to improve painting performance delegates outside the visible area are not painted.</source>
          <target state="translated">이 값이 0보다 큰 경우, 뷰는 지정된 버퍼 내에 맞는만큼 많은 델리게이트를 인스턴스화 할 수 있습니다. 예를 들어 세로보기에서 델리게이트의 높이가 20 픽셀 인 경우 3 개의 열이 있고 &lt;code&gt;cacheBuffer&lt;/code&gt; 가 40으로 설정된 경우 최대 6 개의 델리게이트 및 가시 영역 아래의 6 개의 델리게이트가 작성 / 보존 될 수 있습니다. 버퍼 된 델리게이트는 비동기 적으로 생성되므로 여러 프레임에서 생성이 가능하며 프레임을 건너 뛸 가능성이 줄어 듭니다. 페인팅 성능을 향상시키기 위해 표시 영역 외부의 델리게이트는 페인트되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="127580f6f41b51546fd3bc5efae2ed614120c7f5" translate="yes" xml:space="preserve">
          <source>If this value is non-zero, the view will create extra delegates before the start of the view, or after the end. The view will create as many delegates as it can fit into the pixel size specified.</source>
          <target state="translated">이 값이 0이 아닌 경우, 뷰는 뷰 시작 전 또는 종료 후에 추가 대리자를 만듭니다. 뷰는 지정된 픽셀 크기에 맞는 수의 델리게이트를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="770b381afabf568da75de06a5ce23788975f7ca4" translate="yes" xml:space="preserve">
          <source>If this value is non-zero, then any movement of the emitter will provide additional starting velocity to the particles based on the movement. The additional vector will be the same angle as the emitter's movement, with a magnitude that is the magnitude of the emitters movement multiplied by velocityFromMovement.</source>
          <target state="translated">이 값이 0이 아닌 경우, 이미 터의 움직임은 움직임에 따라 입자에 추가 시작 속도를 제공합니다. 추가 벡터는 이미 터의 움직임과 같은 각도이며 이미 터의 움직임 크기에 velocityFromMovement를 곱한 크기입니다.</target>
        </trans-unit>
        <trans-unit id="7135c234f8bcce211d310450397ae0ceb229509e" translate="yes" xml:space="preserve">
          <source>If this value is not specified, it defaults to the value that depends on the native style.</source>
          <target state="translated">이 값을 지정하지 않으면 기본 스타일에 따라 달라집니다.</target>
        </trans-unit>
        <trans-unit id="5cdf10f3a25ac04653570c9a405850ab7e1b2aa5" translate="yes" xml:space="preserve">
          <source>If this value is set when the emitter is loaded, then it will emit particles from the past, up to startTime milliseconds ago. These will simulate as if they were emitted then, but will not have any affectors applied to them. Affectors will take effect from the present time.</source>
          <target state="translated">이미 터가로드 될 때이 값을 설정하면 과거부터 최대 밀리 초 전까지의 파티클을 방출합니다. 이것들은 마치 마치 방출 된 것처럼 시뮬레이트되지만 적용되는 애펙 터는 없습니다. Affectors는 현재부터 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="25df681494581c983182a0ff7f7c6b3e1dc1fd02" translate="yes" xml:space="preserve">
          <source>If this value to null, the bounding volume of the entity is used. Care must be taken that this bounding volume never becomes invalid.</source>
          <target state="translated">이 값이 null이면 엔터티의 경계 볼륨이 사용됩니다. 이 경계 볼륨이 유효하지 않게주의해야합니다.</target>
        </trans-unit>
        <trans-unit id="00572fcd65ca575d2f655af12f123f101026983f" translate="yes" xml:space="preserve">
          <source>If this value to nullptr, the bounding volume of the entity is used. Care must be taken that this bounding volume never becomes invalid.</source>
          <target state="translated">이 값이 nullptr 인 경우 엔티티의 바운딩 볼륨이 사용됩니다. 이 경계 볼륨이 유효하지 않게주의해야합니다.</target>
        </trans-unit>
        <trans-unit id="1b9ff9f54e32c4c6447460fdd0fe4fc58d670cef" translate="yes" xml:space="preserve">
          <source>If this vector is null, then a null vector is returned. If the length of the vector is very close to 1, then the vector will be returned as-is. Otherwise the normalized form of the vector of length 1 will be returned.</source>
          <target state="translated">이 벡터가 null이면 null 벡터가 반환됩니다. 벡터의 길이가 1에 매우 가까운 경우 벡터는 그대로 반환됩니다. 그렇지 않으면 길이가 1 인 벡터의 정규화 된 형식이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="1af9c981cc60b8e39478122ba9858df9f6f71b20" translate="yes" xml:space="preserve">
          <source>If this view item is checkable, i.e., ViewItemFeature::HasCheckIndicator is true, &lt;code&gt;checkState&lt;/code&gt; is true if the item is checked; otherwise, it is false.</source>
          <target state="translated">이 뷰 항목을 확인할 수있는 경우 (예 : ViewItemFeature :: HasCheckIndicator가 true 인 경우) 항목을 확인하면 &lt;code&gt;checkState&lt;/code&gt; 가 true입니다. 그렇지 않으면 거짓입니다.</target>
        </trans-unit>
        <trans-unit id="8cf301d55d9e51c75f6280fd5a29d08ad107d1fe" translate="yes" xml:space="preserve">
          <source>If this volume was not mounted from a subvolume of a larger filesystem or if the subvolume could not be detected, this function returns an empty byte array.</source>
          <target state="translated">이 볼륨이 더 큰 파일 시스템의 서브 볼륨에서 마운트되지 않았거나 서브 볼륨을 감지 할 수없는 경우이 함수는 빈 바이트 배열을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="ef311f7dc421c384d81389971d02b87b6206c29c" translate="yes" xml:space="preserve">
          <source>If this widget has a layout, the default implementation returns the layout's preferred height. if there is no layout, the default implementation returns -1 indicating that the preferred height does not depend on the width.</source>
          <target state="translated">이 위젯에 레이아웃이있는 경우 기본 구현은 레이아웃의 기본 높이를 반환합니다. 레이아웃이없는 경우 기본 구현은 선호 높이가 너비에 의존하지 않음을 나타내는 -1을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0ffec507a5615d842ae9e35d2f4b30ab9324a37a" translate="yes" xml:space="preserve">
          <source>If this widget is currently managed by a layout, this function notifies the layout that the widget's size hints have changed and the layout may need to resize and reposition the widget accordingly.</source>
          <target state="translated">이 위젯이 현재 레이아웃으로 관리되는 경우이 기능은 위젯의 크기 힌트가 변경되었음을 레이아웃에 알리고 레이아웃은 위젯의 크기를 조정하고 위치를 조정해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="deb9ccc0b5e466e9dd4b4bcd82150cd34b0b1599" translate="yes" xml:space="preserve">
          <source>If this widget, a child or descendant of this widget currently has input focus, this function will return a pointer to that widget. If no descendant widget has input focus, &lt;code&gt;nullptr&lt;/code&gt; is returned.</source>
          <target state="translated">이 위젯,이 위젯의 ​​하위 또는 하위 위젯에 현재 입력 포커스가있는 경우이 함수는 해당 위젯에 대한 포인터를 리턴합니다. 하위 위젯에 입력 포커스가 &lt;code&gt;nullptr&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="ae826ae43c7f7d284672ec7997b3e9d6b7a2d4d0" translate="yes" xml:space="preserve">
          <source>If those requirements are not met one ore more of the following errors are likely to occur:</source>
          <target state="translated">이러한 요구 사항이 충족되지 않으면 다음 오류 중 하나 이상이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="83a8c7ad5f6cb23d01df9dd9eb0c4f8496096c47" translate="yes" xml:space="preserve">
          <source>If thread A and thread B load the variable's old value simultaneously, increment their register, and store it back, they end up overwriting each other, and the variable is incremented only once!</source>
          <target state="translated">스레드 A와 스레드 B가 변수의 이전 값을 동시에로드하고 레지스터를 증가시킨 후 다시 저장하면 서로 덮어 쓰게되고 변수는 한 번만 증가합니다!</target>
        </trans-unit>
        <trans-unit id="69de2038d5c75fedf3b59076c123348b0ac74b70" translate="yes" xml:space="preserve">
          <source>If tracking is enabled (the default), the slider emits the &lt;a href=&quot;qabstractslider#valueChanged&quot;&gt;valueChanged&lt;/a&gt;() signal while the slider is being dragged. If tracking is disabled, the slider emits the &lt;a href=&quot;qabstractslider#valueChanged&quot;&gt;valueChanged&lt;/a&gt;() signal only when the user releases the slider.</source>
          <target state="translated">추적이 활성화 된 경우 (기본값) 슬라이더를 드래그하는 동안 슬라이더가 &lt;a href=&quot;qabstractslider#valueChanged&quot;&gt;valueChanged&lt;/a&gt; () 신호를 방출합니다 . 추적이 비활성화 된 경우 사용자가 슬라이더를 놓을 때만 슬라이더가 &lt;a href=&quot;qabstractslider#valueChanged&quot;&gt;valueChanged&lt;/a&gt; () 신호를 방출합니다.</target>
        </trans-unit>
        <trans-unit id="2fe813bb89eb1f8e684d82a8c590244de14f0457" translate="yes" xml:space="preserve">
          <source>If transformation metadata is not supported by the image format, the transform is applied before writing.</source>
          <target state="translated">이미지 형식에서 변환 메타 데이터를 지원하지 않으면 쓰기 전에 변환이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="87c2eec7ff0fd9a64c44a911b81d33b0c502394b" translate="yes" xml:space="preserve">
          <source>If true the decimal point is drawn between two digit positions. Otherwise it occupies a digit position of its own, i.e. is drawn in a digit position. The default is false.</source>
          <target state="translated">참이면 소수점 두 자리 사이에 그려집니다. 그렇지 않으면 자체 자리 위치를 차지합니다. 즉 자리 위치에 그려집니다. 기본값은 false입니다.</target>
        </trans-unit>
        <trans-unit id="9363d718d389d50aa53a260898f506a5e46192d6" translate="yes" xml:space="preserve">
          <source>If true the text edit shows a cursor.</source>
          <target state="translated">참이면 텍스트 편집에 커서가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="c54421a03a8d84f52502d03221185b6a54bfd5a5" translate="yes" xml:space="preserve">
          <source>If true then &lt;a href=&quot;qtabbar&quot;&gt;QTabBar&lt;/a&gt; draws a base in relation to the styles overlab. Otherwise only the tabs are drawn.</source>
          <target state="translated">true 인 경우 &lt;a href=&quot;qtabbar&quot;&gt;QTabBar&lt;/a&gt; 는 스타일 오버랩과 관련하여 기준을 그립니다. 그렇지 않으면 탭만 그려집니다.</target>
        </trans-unit>
        <trans-unit id="88eb7d44cf9a780bc862bdb9850aab3ea70b30ba" translate="yes" xml:space="preserve">
          <source>If true, a debug overlay will be rendered over the scene. It will show detailed information about the runtime rendering state, let the user turn logging on and off, etc.</source>
          <target state="translated">참이면 디버그 오버레이가 씬 위에 렌더링됩니다. 런타임 렌더링 상태에 대한 자세한 정보를 표시하고 사용자가 로깅을 켜고 끌 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f77ddfdd2a081ae8dd7036dedaf26b2a131a9074" translate="yes" xml:space="preserve">
          <source>If true, affected particles will jump directly to the target group instead of taking the shortest valid path to get there. They will also not finish their current state, but immediately move to the beginning of the goal state.</source>
          <target state="translated">참이면 영향을받는 파티클은 유효한 최단 경로를 사용하는 대신 대상 그룹으로 바로 이동합니다. 또한 현재 상태를 끝내지 않고 즉시 목표 상태의 시작으로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="87ae48f730bdbacb8891acec503553ba883309c0" translate="yes" xml:space="preserve">
          <source>If true, affected sprites will jump directly to the goal state instead of taking the shortest valid path to get there. They will also not finish their current state, but immediately move to the beginning of the goal state.</source>
          <target state="translated">참이면 영향을받는 스프라이트는 유효한 최단 경로를 사용하는 대신 목표 상태로 바로 이동합니다. 또한 현재 상태를 끝내지 않고 즉시 목표 상태의 시작으로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="e14f31c02b5e8161ad6e453e666d875eba466728" translate="yes" xml:space="preserve">
          <source>If true, calling the &lt;a href=&quot;qml-qtmultimedia-audio#seek-method&quot;&gt;seek()&lt;/a&gt; method will cause playback to seek to the new position.</source>
          <target state="translated">true 인 경우 &lt;a href=&quot;qml-qtmultimedia-audio#seek-method&quot;&gt;seek ()&lt;/a&gt; 메서드를 호출 하면 재생이 새로운 위치를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="0e2a44833e164e72e8ed4e671e39489a69ad886b" translate="yes" xml:space="preserve">
          <source>If true, calling the &lt;a href=&quot;qml-qtmultimedia-mediaplayer#seek-method&quot;&gt;seek()&lt;/a&gt; method will cause playback to seek to the new position.</source>
          <target state="translated">true 인 경우 &lt;a href=&quot;qml-qtmultimedia-mediaplayer#seek-method&quot;&gt;seek ()&lt;/a&gt; 메서드를 호출 하면 재생이 새로운 위치를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="6d48c91e05b4b950fbafc2f2f1b9740c12ce5f8b" translate="yes" xml:space="preserve">
          <source>If true, calling the &lt;a href=&quot;qml-qtmultimedia-video#seek-method&quot;&gt;seek()&lt;/a&gt; method will cause playback to seek to the new position.</source>
          <target state="translated">true 인 경우 &lt;a href=&quot;qml-qtmultimedia-video#seek-method&quot;&gt;seek ()&lt;/a&gt; 메서드를 호출 하면 재생이 새로운 위치를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="ea47b3186db45c9a348c54ad710083e01ac72d44" translate="yes" xml:space="preserve">
          <source>If true, directories are included in the model; otherwise only files are included.</source>
          <target state="translated">true 인 경우 디렉토리가 모델에 포함됩니다. 그렇지 않으면 파일 만 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="519f75663f366cd0b741f4bae7a8ee2414a588d9" translate="yes" xml:space="preserve">
          <source>If true, files are included in the model; otherwise only directories are included.</source>
          <target state="translated">참이면 파일이 모델에 포함됩니다. 그렇지 않으면 디렉토리 만 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="07986e8bdf3da1e6c7d93cf9e26fc92364592901" translate="yes" xml:space="preserve">
          <source>If true, hidden files and directories are included in the model; otherwise they are excluded.</source>
          <target state="translated">true 인 경우 숨겨진 파일 및 디렉토리가 모델에 포함됩니다. 그렇지 않으면 제외됩니다.</target>
        </trans-unit>
        <trans-unit id="4066953a40bd0f9690049626bc8d4661eb194a61" translate="yes" xml:space="preserve">
          <source>If true, if directories are included in the model they will always be shown first, then the files.</source>
          <target state="translated">true 인 경우 디렉토리가 모델에 포함 된 경우 항상 디렉토리가 먼저 표시되고 파일이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="77c893993cc6d54289cdf29571b831d58af82641" translate="yes" xml:space="preserve">
          <source>If true, interpolation will occur between sprite frames to make the animation appear smoother.</source>
          <target state="translated">참이면 스프라이트 프레임 사이에 보간이 발생하여 애니메이션이 더 매끄럽게 나타납니다.</target>
        </trans-unit>
        <trans-unit id="9627abef39738f22bb71420356025593d412c45e" translate="yes" xml:space="preserve">
          <source>If true, only readable files and directories are shown; otherwise all files and directories are shown.</source>
          <target state="translated">참이면 읽을 수있는 파일과 디렉토리 만 표시됩니다. 그렇지 않으면 모든 파일과 디렉토리가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="d3c8ed1339e32495bdf91c4a5c8ffc0973812dc3" translate="yes" xml:space="preserve">
          <source>If true, the &quot;.&quot; and &quot;..&quot; directories are included in the model; otherwise they are excluded.</source>
          <target state="translated">true 인 경우 &quot;.&quot; &quot;..&quot;디렉토리가 모델에 포함되어 있습니다. 그렇지 않으면 제외됩니다.</target>
        </trans-unit>
        <trans-unit id="99cef708df110b3efce9af42eb5f128fb1370f6c" translate="yes" xml:space="preserve">
          <source>If true, the action will auto repeat when the keyboard shortcut combination is held down, provided that keyboard auto repeat is enabled on the system. The default value is true.</source>
          <target state="translated">true 인 경우 시스템에서 키보드 자동 반복이 활성화 된 경우 키보드 단축키 조합을 누르고 있으면 작업이 자동 반복됩니다. 기본값은 true입니다.</target>
        </trans-unit>
        <trans-unit id="072e1bfaaef7ac1be9a7d88fde2a8c2e5216a413" translate="yes" xml:space="preserve">
          <source>If true, the item will automatically be faded in and out at the ends of its lifetime. If false, you will have to implement any entry effect yourself.</source>
          <target state="translated">참이면 해당 항목의 수명이 다하면 자동으로 페이드 인 및 페이드 아웃됩니다. False 인 경우 직접 입력 효과를 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="9d0361c07174b2e943b151f6e2a3093d1498a8aa" translate="yes" xml:space="preserve">
          <source>If true, the shortcut will auto repeat when the keyboard shortcut combination is held down, provided that keyboard auto repeat is enabled on the system. The default value is true.</source>
          <target state="translated">true 인 경우 시스템에서 키보드 자동 반복이 활성화 된 경우 키보드 단축키 조합을 누르고 있으면 바로 가기가 자동으로 반복됩니다. 기본값은 true입니다.</target>
        </trans-unit>
        <trans-unit id="c55743c8928e6b2bf356819a6ba89c86403bf66b" translate="yes" xml:space="preserve">
          <source>If true, the tab bar is automatically hidden when it contains less than 2 tabs.</source>
          <target state="translated">true 인 경우 탭이 2 개 미만이면 탭 표시 줄이 자동으로 숨겨집니다.</target>
        </trans-unit>
        <trans-unit id="d1558ec7298db42eff1fc61ae4598cf6b8318137" translate="yes" xml:space="preserve">
          <source>If true, the user can use the keyboard to select text even if the editor is read-only. If false, the user cannot use the keyboard to select text even if the editor is editable.</source>
          <target state="translated">true 인 경우 사용자는 편집기가 읽기 전용 인 경우에도 키보드를 사용하여 텍스트를 선택할 수 있습니다. false 인 경우 편집기를 편집 할 수있는 경우에도 키보드를 사용하여 텍스트를 선택할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="636af586df45cf9846fb475d828a461a230be19e" translate="yes" xml:space="preserve">
          <source>If true, the user can use the mouse to select text in some platform-specific way. Note that for some platforms this may not be an appropriate interaction (it may conflict with how the text needs to behave inside a &lt;a href=&quot;qml-qtquick-flickable&quot;&gt;Flickable&lt;/a&gt;, for example).</source>
          <target state="translated">true 인 경우 사용자는 마우스를 사용하여 플랫폼 별 방식으로 텍스트를 선택할 수 있습니다. 일부 플랫폼의 경우 이는 적절한 상호 작용이 아닐 수 있습니다 (예 : 텍스트가 &lt;a href=&quot;qml-qtquick-flickable&quot;&gt;Flickable&lt;/a&gt; 내부에서 동작해야하는 방식과 충돌 할 수 있음 ).</target>
        </trans-unit>
        <trans-unit id="bc63c69ac9fa5951541e8a4527199b0caefa24e6" translate="yes" xml:space="preserve">
          <source>If true, the user can use the mouse to select text in some platform-specific way. Note that for some platforms this may not be an appropriate interaction; it may conflict with how the text needs to behave inside a Flickable, for example.</source>
          <target state="translated">true 인 경우 사용자는 마우스를 사용하여 플랫폼 별 방식으로 텍스트를 선택할 수 있습니다. 일부 플랫폼의 경우 이는 적절한 상호 작용이 아닐 수 있습니다. 예를 들어 텍스트가 Flickable 내에서 동작해야하는 방식과 충돌 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="08720e1d29cb49edb317c255966ebbaf14f6da0c" translate="yes" xml:space="preserve">
          <source>If true, then the animation will be played in reverse.</source>
          <target state="translated">참이면 애니메이션이 반대로 재생됩니다.</target>
        </trans-unit>
        <trans-unit id="e19fd3950179344f0e0b09195c5972afecc82f56" translate="yes" xml:space="preserve">
          <source>If true, then the animation will have no duration. Instead, the animation will advance one frame each time a frame is rendered to the screen. This synchronizes it with the painting rate as opposed to elapsed time.</source>
          <target state="translated">참이면 애니메이션에 지속 시간이 없습니다. 대신 애니메이션은 프레임이 화면에 렌더링 될 때마다 한 프레임 씩 전진합니다. 이렇게하면 경과 시간이 아닌 페인팅 속도와 동기화됩니다.</target>
        </trans-unit>
        <trans-unit id="b6acc5d1e93dc0a9e040a2a88ed1a56888b811c1" translate="yes" xml:space="preserve">
          <source>If true, then the animation will start its first animation with a random amount of its duration skipped. This allows them to not look like they all just started when the animation begins.</source>
          <target state="translated">true이면 애니메이션이 임의의 지속 시간 길이를 건너 뛰어 첫 번째 애니메이션을 시작합니다. 이를 통해 애니메이션이 시작될 때 모두 시작된 것처럼 보이지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c608cf24035c4df8ec8e6da85ae804f48c24e37" translate="yes" xml:space="preserve">
          <source>If true, then the current tab is automatically changed when dragging over the tabbar.</source>
          <target state="translated">true 인 경우 탭 막대 위로 드래그하면 현재 탭이 자동으로 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="edefc7bc483a0bac748a69c6754b5302eaee2bdc" translate="yes" xml:space="preserve">
          <source>If true, then the value of magnitude and &lt;a href=&quot;qml-qtquick-particles-targetdirection#magnitudeVariation-prop&quot;&gt;magnitudeVariation&lt;/a&gt; shall be interpreted as multiples of the distance between the source point and the target point, per second.</source>
          <target state="translated">참인 경우, 크기 및 &lt;a href=&quot;qml-qtquick-particles-targetdirection#magnitudeVariation-prop&quot;&gt;크기 변화량&lt;/a&gt; 은 초당 소스 포인트와 목표 포인트 사이의 거리의 배수로 해석되어야한다.</target>
        </trans-unit>
        <trans-unit id="bba7e28a5506481feef90cba2ff52c4d5ee57976" translate="yes" xml:space="preserve">
          <source>If true, wrapping is enabled; otherwise some space is inserted at the bottom of the dial to separate the ends of the range of valid values.</source>
          <target state="translated">참이면 줄 바꿈이 활성화됩니다. 그렇지 않으면 유효한 값 범위의 끝을 구분하기 위해 다이얼 하단에 약간의 공간이 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="4f3b55b01365a01150bdd3683f551b3e3b0e852a" translate="yes" xml:space="preserve">
          <source>If truncation occurs any selected text will be unselected, the cursor position is set to 0 and the first part of the string is shown.</source>
          <target state="translated">잘림이 발생하면 선택한 텍스트가 선택 취소되고 커서 위치가 0으로 설정되고 문자열의 첫 부분이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="2b8b91c6eaa2516686ca8c59e69344d174677978" translate="yes" xml:space="preserve">
          <source>If two pixmaps are inserted into the cache using equal keys then the last pixmap will replace the first pixmap in the cache. This follows the behavior of the &lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt; and &lt;a href=&quot;qcache&quot;&gt;QCache&lt;/a&gt; classes.</source>
          <target state="translated">동일한 키를 사용하여 두 개의 픽스맵이 캐시에 삽입되면 마지막 픽스맵은 캐시의 첫 번째 픽스맵을 대체합니다. 이것은 &lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt; 및 &lt;a href=&quot;qcache&quot;&gt;QCache&lt;/a&gt; 클래스 의 동작을 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="4ad83344b3bf3b576b64b6a4417e9818f086ed03" translate="yes" xml:space="preserve">
          <source>If two visible popups have the same z-value, the last one that was opened will be on top.</source>
          <target state="translated">보이는 두 팝업에 동일한 z 값이 있으면 마지막으로 열린 팝업이 맨 위에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="092eee05ab6c42af29cb5a3f9a0b1c6eebb144f5" translate="yes" xml:space="preserve">
          <source>If type is DelimitorTab; tab until this char is found in the text.</source>
          <target state="translated">type이 DelimitorTab 인 경우; 이 문자가 텍스트에 나타날 때까지 탭하십시오.</target>
        </trans-unit>
        <trans-unit id="c14ebe39cde7fb63a7339dcf44b821bc27523b14" translate="yes" xml:space="preserve">
          <source>If undefined or unsupported values are passed to &lt;a href=&quot;qcameraviewfindersettingscontrol2#setViewfinderSettings&quot;&gt;QCameraViewfinderSettingsControl2::setViewfinderSettings&lt;/a&gt;(), this function returns the actual settings used by the camera viewfinder. These may be available only once the camera is active.</source>
          <target state="translated">정의되지 않거나 지원되지 않는 값이 &lt;a href=&quot;qcameraviewfindersettingscontrol2#setViewfinderSettings&quot;&gt;QCameraViewfinderSettingsControl2 :: setViewfinderSettings&lt;/a&gt; ()에 전달 되면이 함수는 카메라 뷰 파인더에서 사용 된 실제 설정을 반환합니다. 카메라가 활성화 된 후에 만 ​​사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="38f2be60a4c75084de2e3377c072fa13a28e8741" translate="yes" xml:space="preserve">
          <source>If unset, Wander will not affect x values.</source>
          <target state="translated">설정하지 않으면 방황은 x 값에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="306c443b24eb59d8ccec79d90ad71463738d2db9" translate="yes" xml:space="preserve">
          <source>If unset, Wander will not affect y values.</source>
          <target state="translated">설정하지 않으면 방황은 y 값에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="82fab8872a62aaba7cd627a5648ce295dae09a7a" translate="yes" xml:space="preserve">
          <source>If unset, or if a null &lt;a href=&quot;qrectf&quot;&gt;QRectF&lt;/a&gt; is set, this property has the same value as &lt;a href=&quot;qgraphicsscene#sceneRect-prop&quot;&gt;QGraphicsScene::sceneRect&lt;/a&gt;, and it changes with &lt;a href=&quot;qgraphicsscene#sceneRect-prop&quot;&gt;QGraphicsScene::sceneRect&lt;/a&gt;. Otherwise, the view's scene rect is unaffected by the scene.</source>
          <target state="translated">설정되지 않은 경우, 널 (null)의 경우, 또는 &lt;a href=&quot;qrectf&quot;&gt;QRectF이&lt;/a&gt; 설정되어 있으며,이 건물은 같은 값이 &lt;a href=&quot;qgraphicsscene#sceneRect-prop&quot;&gt;QGraphicsScene :: sceneRect을&lt;/a&gt; , 그리고에 따라 변화 &lt;a href=&quot;qgraphicsscene#sceneRect-prop&quot;&gt;QGraphicsScene :: sceneRect&lt;/a&gt; . 그렇지 않으면 뷰의 장면 rect는 장면의 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e83f7562da52dff91b9d0216d49cc1d402e1305c" translate="yes" xml:space="preserve">
          <source>If unset, or if set to a null &lt;a href=&quot;qrectf&quot;&gt;QRectF&lt;/a&gt;, sceneRect() will return the largest bounding rect of all items on the scene since the scene was created (i.e., a rectangle that grows when items are added to or moved in the scene, but never shrinks).</source>
          <target state="translated">설정하지 않거나 null &lt;a href=&quot;qrectf&quot;&gt;QRectF로&lt;/a&gt; 설정하면 sceneRect ()는 장면이 생성 된 이후 장면에있는 모든 항목의 가장 큰 경계 사각형을 반환합니다 (즉, 장면에 항목을 추가하거나 이동할 때 커지는 사각형이지만 절대 축소되지 않습니다).</target>
        </trans-unit>
        <trans-unit id="e3e8e1191ccf8bd49afa7c8d764c1aedcfcb386a" translate="yes" xml:space="preserve">
          <source>If unspecified, the system will look for the attribute using the name returned by &lt;a href=&quot;qt3drender-qattribute#defaultPositionAttributeName&quot;&gt;QAttribute::defaultPositionAttributeName&lt;/a&gt;.</source>
          <target state="translated">지정되지 않은 경우 시스템은 &lt;a href=&quot;qt3drender-qattribute#defaultPositionAttributeName&quot;&gt;QAttribute :: defaultPositionAttributeName이&lt;/a&gt; 반환 한 이름을 사용하여 속성을 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="8fb2bc982d0c7c97238ef0f8598493fb4fa741b7" translate="yes" xml:space="preserve">
          <source>If unspecified, the system will look for the attribute using the name returned by QAttribute::defaultPositionAttributeName.</source>
          <target state="translated">지정하지 않으면 시스템은 QAttribute :: defaultPositionAttributeName에 의해 리턴 된 이름을 사용하여 속성을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="1070ad3d1f3f38156973bf7fa335773eb113cb84" translate="yes" xml:space="preserve">
          <source>If using &lt;a href=&quot;qpagesize#SizeMatchPolicy-enum&quot;&gt;FuzzyMatch&lt;/a&gt; then the point size of the &lt;a href=&quot;qpagesize#PageSizeId-enum&quot;&gt;PageSizeId&lt;/a&gt; returned may not exactly match the</source>
          <target state="translated">&lt;a href=&quot;qpagesize#SizeMatchPolicy-enum&quot;&gt;FuzzyMatch&lt;/a&gt; 를 사용하는 경우 반환 된 &lt;a href=&quot;qpagesize#PageSizeId-enum&quot;&gt;PageSizeId&lt;/a&gt; 의 포인트 크기가</target>
        </trans-unit>
        <trans-unit id="73acba8b7996ac864e6a99b35a7604ff8e80a9a7" translate="yes" xml:space="preserve">
          <source>If using &lt;a href=&quot;qpagesize#SizeMatchPolicy-enum&quot;&gt;FuzzyMatch&lt;/a&gt; then the unit size of the &lt;a href=&quot;qpagesize#PageSizeId-enum&quot;&gt;PageSizeId&lt;/a&gt; returned may not exactly match the</source>
          <target state="translated">&lt;a href=&quot;qpagesize#SizeMatchPolicy-enum&quot;&gt;FuzzyMatch&lt;/a&gt; 를 사용하는 경우 반환 된 &lt;a href=&quot;qpagesize#PageSizeId-enum&quot;&gt;PageSizeId&lt;/a&gt; 의 단위 크기가</target>
        </trans-unit>
        <trans-unit id="fff58ec642a6bc6a5dd10ba387da5a4a85c71c9e" translate="yes" xml:space="preserve">
          <source>If using &lt;a href=&quot;qspinbox#prefix-prop&quot;&gt;prefix&lt;/a&gt;(), &lt;a href=&quot;qspinbox#suffix-prop&quot;&gt;suffix&lt;/a&gt;(), and &lt;a href=&quot;qabstractspinbox#specialValueText-prop&quot;&gt;specialValueText&lt;/a&gt;() don't provide enough control, you subclass &lt;a href=&quot;qspinbox&quot;&gt;QSpinBox&lt;/a&gt; and reimplement &lt;a href=&quot;qspinbox#valueFromText&quot;&gt;valueFromText&lt;/a&gt;() and &lt;a href=&quot;qspinbox#textFromValue&quot;&gt;textFromValue&lt;/a&gt;(). For example, here's the code for a custom spin box that allows the user to enter icon sizes (e.g., &quot;32 x 32&quot;):</source>
          <target state="translated">사용하는 경우 &lt;a href=&quot;qspinbox#prefix-prop&quot;&gt;접두사&lt;/a&gt; (), &lt;a href=&quot;qspinbox#suffix-prop&quot;&gt;접미사&lt;/a&gt; () 및 &lt;a href=&quot;qabstractspinbox#specialValueText-prop&quot;&gt;specialValueText는&lt;/a&gt; () 충분히 제어, 당신이 서브 클래스 제공하지 않습니다 &lt;a href=&quot;qspinbox&quot;&gt;QSpinBox&lt;/a&gt; 및 구현할 &lt;a href=&quot;qspinbox#valueFromText&quot;&gt;valueFromText&lt;/a&gt; ()와 &lt;a href=&quot;qspinbox#textFromValue&quot;&gt;textFromValue&lt;/a&gt; ()을. 예를 들어 다음은 사용자가 아이콘 크기를 입력 할 수있는 사용자 지정 스핀 상자의 코드입니다 (예 : &quot;32 x 32&quot;).</target>
        </trans-unit>
        <trans-unit id="7d961535f31366897caad61b08855f1b65f18264" translate="yes" xml:space="preserve">
          <source>If using &lt;a href=&quot;qspinbox#prefix-prop&quot;&gt;prefix&lt;/a&gt;(), &lt;a href=&quot;qspinbox#suffix-prop&quot;&gt;suffix&lt;/a&gt;(), and &lt;a href=&quot;qabstractspinbox#specialValueText-prop&quot;&gt;specialValueText&lt;/a&gt;() don't provide enough control, you subclass QSpinBox and reimplement &lt;a href=&quot;qspinbox#valueFromText&quot;&gt;valueFromText&lt;/a&gt;() and &lt;a href=&quot;qspinbox#textFromValue&quot;&gt;textFromValue&lt;/a&gt;(). For example, here's the code for a custom spin box that allows the user to enter icon sizes (e.g., &quot;32 x 32&quot;):</source>
          <target state="translated">사용하는 경우 &lt;a href=&quot;qspinbox#prefix-prop&quot;&gt;접두사&lt;/a&gt; (), &lt;a href=&quot;qspinbox#suffix-prop&quot;&gt;접미사&lt;/a&gt; () 및 &lt;a href=&quot;qabstractspinbox#specialValueText-prop&quot;&gt;specialValueText는&lt;/a&gt; () 충분히 제어, 당신이 서브 클래스 QSpinBox 및 구현할 제공하지 않습니다 &lt;a href=&quot;qspinbox#valueFromText&quot;&gt;valueFromText&lt;/a&gt; ()와 &lt;a href=&quot;qspinbox#textFromValue&quot;&gt;textFromValue&lt;/a&gt; ()을. 예를 들어 다음은 사용자가 아이콘 크기 (예 : &quot;32 x 32&quot;)를 입력 할 수있는 사용자 지정 스핀 상자에 대한 코드입니다.</target>
        </trans-unit>
        <trans-unit id="8123f0eab50a3da7721d5a5378298130d3f9e870" translate="yes" xml:space="preserve">
          <source>If using a calendar which has a year 0, check using &lt;a href=&quot;qdate#isValid&quot;&gt;isValid&lt;/a&gt;() if the return is 0. Such calendars use negative year numbers in the obvious way, with year 1 preceded by year 0, in turn preceded by year -1 and so on.</source>
          <target state="translated">연도가 0 인 달력을 사용하는 경우 반환 값이 0이면 &lt;a href=&quot;qdate#isValid&quot;&gt;isValid&lt;/a&gt; ()를 사용하여 확인 합니다. 이러한 달력은 명백한 방식으로 음의 연도 숫자를 사용합니다. 1 년은 0 년, 차례로 -1 년은 차례로 시작됩니다. .</target>
        </trans-unit>
        <trans-unit id="6f9a2697f68ce8c6fa3506d69c793884b3323abb" translate="yes" xml:space="preserve">
          <source>If using a compressed &lt;a href=&quot;qopengltexture#format&quot;&gt;format&lt;/a&gt;() then you should use &lt;a href=&quot;qopengltexture#setCompressedData&quot;&gt;setCompressedData&lt;/a&gt;() instead of this function.</source>
          <target state="translated">압축 &lt;a href=&quot;qopengltexture#format&quot;&gt;형식&lt;/a&gt; ()을 사용 하는 경우이 함수 대신 &lt;a href=&quot;qopengltexture#setCompressedData&quot;&gt;setCompressedData&lt;/a&gt; ()를 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="df175fa34fc6197b1820a44997ba2a76099c4b06" translate="yes" xml:space="preserve">
          <source>If using a custom surface format, the stencil buffer needs to be defined (&lt;a href=&quot;qsurfaceformat#setStencilBufferSize&quot;&gt;QSurfaceFormat::setStencilBufferSize&lt;/a&gt;()) for reflections to work.</source>
          <target state="translated">사용자 정의 표면 형식을 사용하는 경우 반사가 작동 하도록 스텐실 버퍼를 정의해야합니다 ( &lt;a href=&quot;qsurfaceformat#setStencilBufferSize&quot;&gt;QSurfaceFormat :: setStencilBufferSize&lt;/a&gt; ()).</target>
        </trans-unit>
        <trans-unit id="f3b110129af5a9dbb532995d4abc5ee3ccc7010c" translate="yes" xml:space="preserve">
          <source>If using a texture that has a combined depth/stencil format this function sets which component of the texture is accessed to</source>
          <target state="translated">깊이 / 스텐실 형식이 결합 된 텍스처를 사용하는 경우이 기능은 텍스처의 어느 구성 요소에 액세스 할 것인지 설정합니다.</target>
        </trans-unit>
        <trans-unit id="d6ee08be27dd8ca1920b92a691492f1c00d26efa" translate="yes" xml:space="preserve">
          <source>If using multiple properties from a group of properties, consider using</source>
          <target state="translated">속성 그룹에서 여러 속성을 사용하는 경우</target>
        </trans-unit>
        <trans-unit id="e598f0c143d34e93e28eb5bd7333fca1c29dc471" translate="yes" xml:space="preserve">
          <source>If using the assets mechanism is not required for your app, the recommended way of distributing resources with your Qt app is to use &lt;a href=&quot;resources&quot;&gt;The Qt Resource System&lt;/a&gt;, which is a cross-platform mechanism for distributing resources with your app.</source>
          <target state="translated">앱에 자산 메커니즘을 사용할 필요가없는 경우 Qt 앱과 함께 리소스를 배포하는 권장 방법은 앱 과 함께 리소스를 배포하기위한 크로스 플랫폼 메커니즘 인 &lt;a href=&quot;resources&quot;&gt;Qt 리소스 시스템&lt;/a&gt; 을 사용 하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="36e9b0493d16e4a8d772524c362444c96b687b54" translate="yes" xml:space="preserve">
          <source>If using the manual run mode, this function executes the jobs for each aspect. It is blocking and won't return until all jobs have been completed.</source>
          <target state="translated">수동 실행 모드를 사용하는 경우이 기능은 각 측면에 대한 작업을 실행합니다. 차단 중이며 모든 작업이 완료 될 때까지 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="982abf038d3106d3150c19907a420813ef6c1e96" translate="yes" xml:space="preserve">
          <source>If viewfinder settings are not supported by the camera, it always returns a null &lt;a href=&quot;qcameraviewfindersettings&quot;&gt;QCameraViewfinderSettings&lt;/a&gt; object.</source>
          <target state="translated">카메라에서 뷰 파인더 설정을 지원하지 않으면 항상 null &lt;a href=&quot;qcameraviewfindersettings&quot;&gt;QCameraViewfinderSettings&lt;/a&gt; 객체를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="994197ed75e3b5bc756c922271b51a071f942854" translate="yes" xml:space="preserve">
          <source>If we add a mutex, we should get the result we want:</source>
          <target state="translated">뮤텍스를 추가하면 원하는 결과를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f511b0976d2c3e4b5c7087d4ba09c724e0a080fa" translate="yes" xml:space="preserve">
          <source>If we added a third property (say, Red vs Blue), the total number of states would double, to eight; and if we added a fourth property (say, Enclosed vs Convertible), the total number of states would double again, to 16.</source>
          <target state="translated">세 번째 속성 (예 : Red vs Blue)을 추가하면 총 주 수가 8 배로 늘어납니다. 그리고 네 번째 속성 (Enclosed vs Convertible)을 추가하면 총 상태 수는 다시 16으로 두 배가됩니다.</target>
        </trans-unit>
        <trans-unit id="69c3920a0228de0571627a90e5da1a716ec512d5" translate="yes" xml:space="preserve">
          <source>If we apply stretch factors to each widget, they will be laid out in proportion (but never less than their minimum size hint), e.g.</source>
          <target state="translated">각 위젯에 스트레치 팩터를 적용하면 비율에 따라 배치되지만 최소 크기 힌트보다 작지 않습니다.</target>
        </trans-unit>
        <trans-unit id="391d5d3c94c88dfbfc5db8acaebe6629e44596f9" translate="yes" xml:space="preserve">
          <source>If we are using nested states, the parent defines a value for the property which is inherited by all descendants that do not explicitly assign a value to the property.</source>
          <target state="translated">중첩 상태를 사용하는 경우 부모는 속성에 값을 명시 적으로 할당하지 않은 모든 자손이 상속하는 속성 값을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="ddadac7ff808aedab2554bcc0c9e740eda355b10" translate="yes" xml:space="preserve">
          <source>If we continue our analogy with Web services, object paths equate to the path part of a URL:</source>
          <target state="translated">웹 서비스와 유사성을 유지한다면 객체 경로는 URL의 경로 부분과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0f1c1a3d2c9d206d7de9af864589670478b3e1fb" translate="yes" xml:space="preserve">
          <source>If we did provide an identifier then we could retrieve a category's children.</source>
          <target state="translated">식별자를 제공 한 경우 카테고리의 하위를 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="135904c55ac8fbe0fcd1f240a70a644d44dc854a" translate="yes" xml:space="preserve">
          <source>If we don't provide a copy constructor or an assignment operator, C++ provides a default implementation that performs a member-by-member copy. In the example above, that would have been sufficient. Also, if you don't provide any constructors, C++ provides a default constructor that initializes its member using default constructors. Although it doesn't provide any explicit constructors or assignment operator, the following data type can be stored in a container:</source>
          <target state="translated">복사 생성자 또는 할당 연산자를 제공하지 않으면 C ++은 멤버 별 복사를 수행하는 기본 구현을 제공합니다. 위의 예에서는 충분했을 것입니다. 또한 생성자를 제공하지 않으면 C ++은 기본 생성자를 사용하여 멤버를 초기화하는 기본 생성자를 제공합니다. 명시적인 생성자 또는 할당 연산자를 제공하지는 않지만 다음 데이터 유형을 컨테이너에 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="939f9c417675fdc58025672643465c1600ac04b7" translate="yes" xml:space="preserve">
          <source>If we had done it that way here, the copy constructor shown would be required. Since the copy constructor is trivial, you might as well just always include it.</source>
          <target state="translated">여기에서 그렇게 한 경우 표시된 복사 생성자가 필요합니다. 복사 생성자는 사소한 것이므로 항상 포함시킬 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="92e2cea0383d5d45395f6838ba2705436aba982b" translate="yes" xml:space="preserve">
          <source>If we have three widgets laid out using a &lt;a href=&quot;qhboxlayout&quot;&gt;QHBoxLayout&lt;/a&gt; with no stretch factors set we will get a layout like this:</source>
          <target state="translated">스트레치 팩터가 설정되지 않은 &lt;a href=&quot;qhboxlayout&quot;&gt;QHBoxLayout&lt;/a&gt; 을 사용하여 세 개의 위젯을 배치 하면 다음과 같은 레이아웃을 얻게됩니다.</target>
        </trans-unit>
        <trans-unit id="285d51aa4b50f00b8522b0176884435bea7bebdc" translate="yes" xml:space="preserve">
          <source>If we instead used the corresponding type from the &lt;a href=&quot;qtquickcontrols-index&quot;&gt;QtQuick.Controls&lt;/a&gt; import as we did in the previous section, it would not work: the control we were defining would try to derive from itself.</source>
          <target state="translated">대신 이전 섹션에서했던 것처럼 &lt;a href=&quot;qtquickcontrols-index&quot;&gt;QtQuick.Controls&lt;/a&gt; 가져 오기 에서 해당 유형을 사용하면 작동하지 않습니다. 정의한 컨트롤은 자체에서 파생하려고합니다.</target>
        </trans-unit>
        <trans-unit id="b5bec29f2afa07f4a58155b5f58351c6a2ff7836" translate="yes" xml:space="preserve">
          <source>If we instead used the corresponding type from the &lt;a href=&quot;qtquickcontrols-index#&quot;&gt;QtQuick.Controls&lt;/a&gt; import as we did in the previous section, it would not work: the control we were defining would try to derive from itself.</source>
          <target state="translated">이전 섹션에서와 같이 &lt;a href=&quot;qtquickcontrols-index#&quot;&gt;QtQuick.Controls&lt;/a&gt; 가져 오기 에서 해당 유형을 대신 사용하면 작동하지 않습니다. 정의한 제어가 자체에서 파생됩니다.</target>
        </trans-unit>
        <trans-unit id="5de420dd5294579c79c00a4e4e06ba39256245db" translate="yes" xml:space="preserve">
          <source>If we just want to modify the value of an existing item, we can use &lt;a href=&quot;qmutablelistiterator#setValue&quot;&gt;setValue()&lt;/a&gt;. In the code below, we replace any value larger than 128 with 128:</source>
          <target state="translated">기존 항목의 값만 수정하려면 &lt;a href=&quot;qmutablelistiterator#setValue&quot;&gt;setValue ()를&lt;/a&gt; 사용할 수 있습니다 . 아래 코드에서 128보다 큰 값을 128로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="56dc8f9c50f5b17baa4ce4c71338e2386c3287f4" translate="yes" xml:space="preserve">
          <source>If we make the logical coordinate system a square, we should also make the viewport a square using the &lt;a href=&quot;qpainter#setViewport&quot;&gt;QPainter::setViewport&lt;/a&gt;() function. In the example above we make it equivalent to the largest square that fit into the paint device's rectangle. By taking the paint device's size into consideration when setting the window or viewport, it is possible to keep the drawing code independent of the paint device.</source>
          <target state="translated">논리 좌표계를 정사각형으로 만들면 &lt;a href=&quot;qpainter#setViewport&quot;&gt;QPainter :: setViewport&lt;/a&gt; () 함수를 사용하여 뷰포트를 정사각형으로 만들어야합니다 . 위의 예에서 페인트 장치의 사각형에 맞는 가장 큰 사각형과 같습니다. 창 또는 뷰포트를 설정할 때 페인트 장치의 크기를 고려하면 페인트 장치와 독립적으로 그리기 코드를 유지할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e23a5c50007246fc7a836789bb8c7bf034581142" translate="yes" xml:space="preserve">
          <source>If we now compile and run the project we can click on the circle widget to increase its line width, and press the reset button to set the line width back to 1.</source>
          <target state="translated">이제 프로젝트를 컴파일하고 실행하면 원 위젯을 클릭하여 선 너비를 늘리고 재설정 버튼을 눌러 선 너비를 다시 1로 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dea76d6abb59ae1dba5d6f14e2566e1ea06bae4b" translate="yes" xml:space="preserve">
          <source>If we save that document as &quot;HelloWorld.qml&quot;, we can load and display it.</source>
          <target state="translated">해당 문서를 &quot;HelloWorld.qml&quot;로 저장하면로드하여 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f37d9a5f8663d07893822c29691b657bd2ef981" translate="yes" xml:space="preserve">
          <source>If we save the example &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt; shown above in a text file (e.g. &lt;code&gt;myquery.xq&lt;/code&gt;), we can run it from a Qt application using a standard Qt XML Patterns code sequence:</source>
          <target state="translated">위에 표시된 예제 &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery를&lt;/a&gt; 텍스트 파일 (예 : &lt;code&gt;myquery.xq&lt;/code&gt; )에 저장하면 표준 Qt XML 패턴 코드 시퀀스를 사용하여 Qt 애플리케이션에서 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4e43e615e5806e9457bf677576affcd477b41dd" translate="yes" xml:space="preserve">
          <source>If we save the example XQuery shown above in a text file (e.g. &lt;code&gt;myquery.xq&lt;/code&gt;), we can run it from a Qt application using a standard Qt XML Patterns code sequence:</source>
          <target state="translated">위에 표시된 XQuery 예제를 텍스트 파일 (예 : &lt;code&gt;myquery.xq&lt;/code&gt; )에 저장하면 표준 Qt XML 패턴 코드 시퀀스를 사용하여 Qt 애플리케이션에서 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c668140f896257a8ba1337adc7c2d1f236b8c6d4" translate="yes" xml:space="preserve">
          <source>If we want the stream operators &lt;code&gt;operator&amp;lt;&amp;lt;()&lt;/code&gt; and &lt;code&gt;operator&amp;gt;&amp;gt;()&lt;/code&gt; to work on &lt;a href=&quot;qmetatype#Type-enum&quot;&gt;QVariant&lt;/a&gt; objects that store custom types, the custom type must provide &lt;code&gt;operator&amp;lt;&amp;lt;()&lt;/code&gt; and &lt;code&gt;operator&amp;gt;&amp;gt;()&lt;/code&gt; operators.</source>
          <target state="translated">스트림 연산자 &lt;code&gt;operator&amp;lt;&amp;lt;()&lt;/code&gt; 및 &lt;code&gt;operator&amp;gt;&amp;gt;()&lt;/code&gt; 가 사용자 정의 유형을 저장 하는 &lt;a href=&quot;qmetatype#Type-enum&quot;&gt;QVariant&lt;/a&gt; 객체 에서 작동하게 하려면 사용자 정의 유형이 &lt;code&gt;operator&amp;lt;&amp;lt;()&lt;/code&gt; 및 &lt;code&gt;operator&amp;gt;&amp;gt;()&lt;/code&gt; 연산자를 제공해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f03c51cf5d11dac6ddaa2a52fb2ca9deddaeea5f" translate="yes" xml:space="preserve">
          <source>If we want to count all the occurrences of 'Eric' and 'Eirik' in a string, two valid solutions are &lt;b&gt;\b(Eric|Eirik)\b&lt;/b&gt; and &lt;b&gt;\bEi?ri[ck]\b&lt;/b&gt;. The word boundary assertion '\b' is required to avoid matching words that contain either name, e.g. 'Ericsson'. Note that the second regexp matches more spellings than we want: 'Eric', 'Erik', 'Eiric' and 'Eirik'.</source>
          <target state="translated">문자열에서 'Eric'및 'Eirik'의 모든 발생을 계산하려면 두 가지 유효한 솔루션은 &lt;b&gt;\ b (Eric | Eirik) \ b&lt;/b&gt; 및 &lt;b&gt;\ bEi? ri [ck] \ b&lt;/b&gt; 입니다. 단어 경계 어설 션 '\ b'는 이름이 포함 된 단어 (예 : 'Ericsson')와 일치하는 단어를 피하기 위해 필요합니다. 두 번째 정규 표현식은 우리가 원하는 것보다 더 많은 철자 법인 'Eric', 'Erik', 'Eiric'및 'Eirik'과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="228813af00250292acc7d372590bf0870f0a379b" translate="yes" xml:space="preserve">
          <source>If we want to iterate through all the items with the same value, we can use &lt;a href=&quot;qmapiterator#findNext&quot;&gt;findNext()&lt;/a&gt; or &lt;a href=&quot;qmapiterator#findPrevious&quot;&gt;findPrevious()&lt;/a&gt;. Here's an example where we remove all the items with a particular value:</source>
          <target state="translated">동일한 값을 가진 모든 항목을 반복하려면 &lt;a href=&quot;qmapiterator#findNext&quot;&gt;findNext ()&lt;/a&gt; 또는 &lt;a href=&quot;qmapiterator#findPrevious&quot;&gt;findPrevious ()를&lt;/a&gt; 사용할 수 있습니다 . 다음은 특정 값을 가진 모든 항목을 제거하는 예입니다.</target>
        </trans-unit>
        <trans-unit id="62dccd109997265b265acb7a29596b2ebf981557" translate="yes" xml:space="preserve">
          <source>If we want to replace ampersand characters with the HTML entity &lt;b&gt;&amp;amp;amp;&lt;/b&gt;, the regexp to match is simply &lt;b&gt;&amp;amp;&lt;/b&gt;. But this regexp will also match ampersands that have already been converted to HTML entities. We want to replace only ampersands that are not already followed by &lt;b&gt;amp;&lt;/b&gt;. For this, we need the negative lookahead assertion, &lt;b&gt;(?!&lt;/b&gt;__&lt;b&gt;)&lt;/b&gt;. The regexp can then be written as &lt;b&gt;&amp;amp;(?!amp;)&lt;/b&gt;, i.e.</source>
          <target state="translated">앰퍼샌드 문자를 HTML 엔티티 &lt;b&gt;&amp;amp; amp;&lt;/b&gt; 일치하는 정규 표현식은 단순히 &lt;b&gt;&amp;amp;&lt;/b&gt; 입니다. 그러나이 정규 표현식은 이미 HTML 엔터티로 변환 된 앰퍼샌드와도 일치합니다. 우리는 아직 &lt;b&gt;amp&lt;/b&gt; 뒤에 오는 앰퍼샌드 만 교체하고 싶습니다 &lt;b&gt;.&lt;/b&gt; . 이를 위해서는 네거티브 미리보기 어설 션 &lt;b&gt;(?!&lt;/b&gt; __ &lt;b&gt;)이 필요&lt;/b&gt; 합니다. 정규 표현식은 다음과 같이 쓸 수있다 &lt;b&gt;; 및 (? A)&lt;/b&gt; , 즉</target>
        </trans-unit>
        <trans-unit id="4208ebd6956f11ebfad60161063794f89f5db08f" translate="yes" xml:space="preserve">
          <source>If we want to use parentheses purely for grouping and not for capturing we can use the non-capturing syntax, e.g. &lt;b&gt;(?:green|blue)&lt;/b&gt;. Non-capturing parentheses begin '(?:' and end ')'. In this example we match either 'green' or 'blue' but we do not capture the match so we only know whether or not we matched but not which color we actually found. Using non-capturing parentheses is more efficient than using capturing parentheses since the regexp engine has to do less book-keeping.</source>
          <target state="translated">그룹화에만 사용하고 캡처에는 사용하지 않고 괄호를 사용하려면 캡처하지 않는 구문을 사용할 수 있습니다 &lt;b&gt;(&lt;/b&gt; 예 : &lt;b&gt;(? : green | blue))&lt;/b&gt; . 캡처하지 않는 괄호는 '(? :'및 end ')'로 시작합니다. 이 예에서는 '녹색'또는 '파란색'과 일치하지만 일치를 캡처하지 않으므로 일치 여부 만 알지만 실제로 찾은 색상은 알 수 없습니다. 정규식 엔진이 예약을 덜 수행해야하기 때문에 캡처하지 않는 괄호를 사용하는 것이 캡처 괄호를 사용하는 것보다 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="32198f4e4bde30e9720192f732eea0d71ba088ab" translate="yes" xml:space="preserve">
          <source>If wrap is &lt;code&gt;true&lt;/code&gt;, stepping past &lt;a href=&quot;qml-qtquick-controls2-spinbox#to-prop&quot;&gt;to&lt;/a&gt; changes the value to &lt;a href=&quot;qml-qtquick-controls2-spinbox#from-prop&quot;&gt;from&lt;/a&gt; and vice versa.</source>
          <target state="translated">줄 바꿈이 &lt;code&gt;true&lt;/code&gt; 이면 단계를 건너 뛰면 값이 &lt;a href=&quot;qml-qtquick-controls2-spinbox#from-prop&quot;&gt;에서 &lt;/a&gt;&lt;a href=&quot;qml-qtquick-controls2-spinbox#to-prop&quot;&gt;로&lt;/a&gt; 변경 되고 그 반대로도 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="7d8ba470d02c9e9cab21333de5c72425c862d14e" translate="yes" xml:space="preserve">
          <source>If wrapping is true stepping up from maximum() value will take you to the minimum() value and vice versa. Wrapping only make sense if you have minimum() and maximum() values set.</source>
          <target state="translated">줄 바꿈이 true 인 경우 maximum () 값에서 올라가면 minimum () 값으로 이동하고 그 반대도 마찬가지입니다. 랩핑은 minimum () 및 maximum () 값이 설정된 경우에만 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="69b99beed73cd180056131c452501a77aece7ebb" translate="yes" xml:space="preserve">
          <source>If you access out of bounds, a zero (null object) is returned and a warning is issued.</source>
          <target state="translated">범위를 벗어난 곳에 액세스하면 0 (널 오브젝트)이 리턴되고 경고가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="573e2c289f21af6f9eba01b6f44b050e88e36db5" translate="yes" xml:space="preserve">
          <source>If you add a &lt;a href=&quot;qtoolbutton&quot;&gt;QToolButton&lt;/a&gt; with this method, the toolbar's &lt;a href=&quot;qt#ToolButtonStyle-enum&quot;&gt;Qt::ToolButtonStyle&lt;/a&gt; will not be respected.</source>
          <target state="translated">이 메소드 로 &lt;a href=&quot;qtoolbutton&quot;&gt;QToolButton&lt;/a&gt; 을 추가 하면 툴바의 &lt;a href=&quot;qt#ToolButtonStyle-enum&quot;&gt;Qt :: ToolButtonStyle&lt;/a&gt; 이 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e92974e65bc0cc53ad8104fe86b9f43444f1421e" translate="yes" xml:space="preserve">
          <source>If you add a child widget to an already visible widget you must explicitly show the child to make it visible.</source>
          <target state="translated">이미 표시된 위젯에 하위 위젯을 추가하는 경우 하위 위젯을 명시 적으로 표시하여 위젯을 표시해야합니다.</target>
        </trans-unit>
        <trans-unit id="3ff0ca814fc818ed35bf736e1608d0c88b71b6d6" translate="yes" xml:space="preserve">
          <source>If you already have a &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; subclass and want an easy optimization, you can use &lt;a href=&quot;qbasictimer&quot;&gt;QBasicTimer&lt;/a&gt; instead of &lt;a href=&quot;qtimer&quot;&gt;QTimer&lt;/a&gt;. With &lt;a href=&quot;qbasictimer&quot;&gt;QBasicTimer&lt;/a&gt;, you must reimplement &lt;a href=&quot;qobject#timerEvent&quot;&gt;timerEvent()&lt;/a&gt; in your &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; subclass and handle the timeout there. The &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtwidgets-widgets-wiggly-example.html&quot;&gt;Wiggly&lt;/a&gt; example shows how to use &lt;a href=&quot;qbasictimer&quot;&gt;QBasicTimer&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 서브 클래스 가 이미 있고 쉬운 최적화를 원하는 경우 &lt;a href=&quot;qtimer&quot;&gt;QTimer&lt;/a&gt; 대신 &lt;a href=&quot;qbasictimer&quot;&gt;QBasicTimer&lt;/a&gt; 를 사용할 수 있습니다 . &lt;a href=&quot;qbasictimer&quot;&gt;QBasicTimer을&lt;/a&gt; 사용하면 &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 서브 클래스 에서 &lt;a href=&quot;qobject#timerEvent&quot;&gt;timerEvent ()&lt;/a&gt; 를 다시 구현 하고 타임 아웃을 처리해야합니다. &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtwidgets-widgets-wiggly-example.html&quot;&gt;흔들기&lt;/a&gt; 예를 보여줍니다 어떻게 사용하는 &lt;a href=&quot;qbasictimer&quot;&gt;QBasicTimer을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="47ba2fd5564431daa0e2da53bdb77e16fe28fd62" translate="yes" xml:space="preserve">
          <source>If you already have a &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; subclass and want an easy optimization, you can use &lt;a href=&quot;qbasictimer&quot;&gt;QBasicTimer&lt;/a&gt; instead of &lt;a href=&quot;qtimer&quot;&gt;QTimer&lt;/a&gt;. With &lt;a href=&quot;qbasictimer&quot;&gt;QBasicTimer&lt;/a&gt;, you must reimplement &lt;a href=&quot;qobject#timerEvent&quot;&gt;timerEvent()&lt;/a&gt; in your &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; subclass and handle the timeout there. The &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtwidgets-widgets-wiggly-example.html&quot;&gt;Wiggly&lt;/a&gt; example shows how to use &lt;a href=&quot;qbasictimer&quot;&gt;QBasicTimer&lt;/a&gt;.</source>
          <target state="translated">이미 &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 하위 클래스가 있고 쉬운 최적화를 원하면 &lt;a href=&quot;qtimer&quot;&gt;QTimer&lt;/a&gt; 대신 &lt;a href=&quot;qbasictimer&quot;&gt;QBasicTimer&lt;/a&gt; 를 사용할 수 있습니다 . &lt;a href=&quot;qbasictimer&quot;&gt;QBasicTimer를&lt;/a&gt; 사용하면 &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 하위 클래스 에서 &lt;a href=&quot;qobject#timerEvent&quot;&gt;timerEvent ()&lt;/a&gt; 를 다시 구현 하고 거기에서 시간 초과를 처리해야합니다. &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtwidgets-widgets-wiggly-example.html&quot;&gt;흔들기&lt;/a&gt; 예를 보여줍니다 어떻게 사용하는 &lt;a href=&quot;qbasictimer&quot;&gt;QBasicTimer을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="66dc6e8efe388635cff4d6b8e7b83340b07897e3" translate="yes" xml:space="preserve">
          <source>If you already have a fully defined &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;, it can become a Source simply by passing it to &lt;a href=&quot;qremoteobjecthostbase#enableRemoting&quot;&gt;QRemoteObjectHostBase::enableRemoting&lt;/a&gt;(). This lets other processes/devices create a &lt;a href=&quot;qtremoteobjects-replica#replica&quot;&gt;Replica&lt;/a&gt; of the object to interact with (see &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtremoteobjects-interaction.html#remote-object-interaction&quot;&gt;Remote Object Interaction&lt;/a&gt;). You can then instantiate &lt;a href=&quot;qremoteobjectdynamicreplica&quot;&gt;QRemoteObjectDynamicReplica&lt;/a&gt;s of your object.</source>
          <target state="translated">이미 완전히 정의 된 &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 가있는 경우 &lt;a href=&quot;qremoteobjecthostbase#enableRemoting&quot;&gt;QRemoteObjectHostBase :: enableRemoting&lt;/a&gt; () 에 전달하여 간단히 소스가 될 수 있습니다 . 이를 통해 다른 프로세스 / 장치 가 상호 작용할 객체 의 &lt;a href=&quot;qtremoteobjects-replica#replica&quot;&gt;복제본&lt;/a&gt; 을 생성 할 수 있습니다 ( &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtremoteobjects-interaction.html#remote-object-interaction&quot;&gt;원격 객체 상호 작용&lt;/a&gt; 참조 ). 그런 다음 객체의 &lt;a href=&quot;qremoteobjectdynamicreplica&quot;&gt;QRemoteObjectDynamicReplica&lt;/a&gt; 를 인스턴스화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6aaa6040ada04fc8869f4d0ba9a68f1848a9b49c" translate="yes" xml:space="preserve">
          <source>If you already have a fully defined &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;, you can use it as a source by passing it to &lt;a href=&quot;qremoteobjecthostbase#enableRemoting&quot;&gt;QRemoteObjectHostBase::enableRemoting&lt;/a&gt;(). This way, other processes or devices can then create &lt;a href=&quot;qremoteobjectdynamicreplica&quot;&gt;dynamics replicas&lt;/a&gt; of the object to interact with.</source>
          <target state="translated">이미 완전히 정의 된 &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 가있는 경우 &lt;a href=&quot;qremoteobjecthostbase#enableRemoting&quot;&gt;QRemoteObjectHostBase :: enableRemoting&lt;/a&gt; () 에 전달하여 소스로 사용할 수 있습니다 . 이렇게하면 다른 프로세스 나 장치 가 상호 작용할 개체의 &lt;a href=&quot;qremoteobjectdynamicreplica&quot;&gt;동적 복제본&lt;/a&gt; 을 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="54dd070f132699b449fced117bece39fae043218" translate="yes" xml:space="preserve">
          <source>If you always use the same file you do not need to use &lt;a href=&quot;qfileselector&quot;&gt;QFileSelector&lt;/a&gt;.</source>
          <target state="translated">항상 같은 파일을 사용 &lt;a href=&quot;qfileselector&quot;&gt;한다면 QFileSelector&lt;/a&gt; 를 사용할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="835045414217b0e54728bae6ade1a40a53eea242" translate="yes" xml:space="preserve">
          <source>If you always use the same file you do not need to use QFileSelector.</source>
          <target state="translated">항상 동일한 파일을 사용하는 경우 QFileSelector를 사용할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="357d8c8c15072da4629552f4faa8ec4975bbc4f4" translate="yes" xml:space="preserve">
          <source>If you append a built-in install set to the &lt;code&gt;INSTALLS&lt;/code&gt; variable and do not specify &lt;code&gt;files&lt;/code&gt; or &lt;code&gt;extra&lt;/code&gt; members, qmake will decide what needs to be copied for you. Currently, the &lt;code&gt;target&lt;/code&gt; and &lt;code&gt;dlltarget&lt;/code&gt; install sets are supported. For example:</source>
          <target state="translated">내장 설치 세트를 &lt;code&gt;INSTALLS&lt;/code&gt; 변수에 &lt;code&gt;extra&lt;/code&gt; &lt;code&gt;files&lt;/code&gt; 이나 추가 멤버를 지정하지 않으면 qmake가 복사 할 항목을 결정합니다. 현재 &lt;code&gt;target&lt;/code&gt; 및 &lt;code&gt;dlltarget&lt;/code&gt; 설치 세트가 지원됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fb4055566f4e21980f25a6697df12ac5c9d286c0" translate="yes" xml:space="preserve">
          <source>If you are building a &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; gradually and know in advance approximately how many characters the &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; will contain, you can call &lt;a href=&quot;qstring#reserve&quot;&gt;reserve&lt;/a&gt;(), asking &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; to preallocate a certain amount of memory. You can also call &lt;a href=&quot;qstring#capacity&quot;&gt;capacity&lt;/a&gt;() to find out how much memory &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; actually allocated.</source>
          <target state="translated">당신이 만든다면 &lt;a href=&quot;qstring&quot;&gt;QString을&lt;/a&gt; 점차적으로 약 얼마나 많은 문자를 사전에 알고 &lt;a href=&quot;qstring&quot;&gt;QString이&lt;/a&gt; 포함됩니다, 당신은 호출 할 수 있습니다 &lt;a href=&quot;qstring#reserve&quot;&gt;예약을&lt;/a&gt; 요청, () &lt;a href=&quot;qstring&quot;&gt;QString를&lt;/a&gt; 메모리의 일정 금액을 미리 할당 할 수 있습니다. &lt;a href=&quot;qstring#capacity&quot;&gt;용량&lt;/a&gt; ()을 호출 하여 실제로 &lt;a href=&quot;qstring&quot;&gt;QString에&lt;/a&gt; 할당 된 메모리 양을 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="83da4ec031537e79ba3801874b00a2d080b4cd30" translate="yes" xml:space="preserve">
          <source>If you are building a QString gradually and know in advance approximately how many characters the QString will contain, you can call &lt;a href=&quot;qstring#reserve&quot;&gt;reserve&lt;/a&gt;(), asking QString to preallocate a certain amount of memory. You can also call &lt;a href=&quot;qstring#capacity&quot;&gt;capacity&lt;/a&gt;() to find out how much memory QString actually allocated.</source>
          <target state="translated">QString을 점진적으로 빌드하고 QString에 포함될 문자 수를 미리 알고있는 경우 &lt;a href=&quot;qstring#reserve&quot;&gt;reserve&lt;/a&gt; ()를 호출 하여 QString에 특정 양의 메모리를 미리 할당하도록 요청할 수 있습니다. &lt;a href=&quot;qstring#capacity&quot;&gt;capacity&lt;/a&gt; ()를 호출 하여 QString이 실제로 할당 된 메모리 양을 확인할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1f69359a3ea41192cfeea7a41e2eda47d527426f" translate="yes" xml:space="preserve">
          <source>If you are calling &lt;a href=&quot;qtooltip#hideText&quot;&gt;QToolTip::hideText&lt;/a&gt;(), or &lt;a href=&quot;qtooltip#showText&quot;&gt;QToolTip::showText&lt;/a&gt;() with an empty string, as a result of a &lt;a href=&quot;qevent#Type-enum&quot;&gt;ToolTip&lt;/a&gt;-event you should also call &lt;a href=&quot;qevent#ignore&quot;&gt;ignore()&lt;/a&gt; on the event, to signal that you don't want to start any tooltip specific modes.</source>
          <target state="translated">당신이 호출하는 경우 &lt;a href=&quot;qtooltip#hideText&quot;&gt;QToolTip :: hideText&lt;/a&gt; () 또는 &lt;a href=&quot;qtooltip#showText&quot;&gt;QToolTip :: showText&lt;/a&gt; 의 결과로 빈 문자열을 (), &lt;a href=&quot;qevent#Type-enum&quot;&gt;도구 설명&lt;/a&gt; 당신은 또한 호출해야 - 이벤트 &lt;a href=&quot;qevent#ignore&quot;&gt;) (무시&lt;/a&gt; 원하지 않는 것을 알리기 위해 이벤트에 툴팁 특정 모드를 시작합니다.</target>
        </trans-unit>
        <trans-unit id="43e0cbbb5c171786dfe76f3c109568d78c086065" translate="yes" xml:space="preserve">
          <source>If you are calling a function on an &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; subclass that doesn't live in the current thread and the object might receive events, you must protect all access to your &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; subclass's internal data with a mutex; otherwise, you may experience crashes or other undesired behavior.</source>
          <target state="translated">현재 스레드에 존재하지 않는 &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 서브 클래스 에서 함수를 호출 하고 오브젝트가 이벤트를 수신 할 수 있는 경우, 뮤텍스 를 사용하여 &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 서브 클래스의 내부 데이터에 대한 모든 액세스를 보호해야합니다 . 그렇지 않으면 충돌이나 다른 원하지 않는 동작이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8660160035ab2a9f737194b2dbeeab682345d2e7" translate="yes" xml:space="preserve">
          <source>If you are certain the QML file to be loaded is a local file, you could omit the &lt;code&gt;finishCreation()&lt;/code&gt; function and call &lt;a href=&quot;qml-qtqml-component#createObject-method&quot;&gt;createObject()&lt;/a&gt; immediately:</source>
          <target state="translated">로드 할 QML 파일이 로컬 파일이라고 확신하는 경우 &lt;code&gt;finishCreation()&lt;/code&gt; 함수를 생략하고 즉시 &lt;a href=&quot;qml-qtqml-component#createObject-method&quot;&gt;createObject ()를&lt;/a&gt; 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="66a985357066e965ac0d58d4bd13bc9ea2d8fe59" translate="yes" xml:space="preserve">
          <source>If you are certain you want your variables processed after the files specified, then you may pass the &lt;code&gt;-after&lt;/code&gt; option. When this is specified, all assignments on the command line after the &lt;code&gt;-after&lt;/code&gt; option will be postponed until after the specified files are parsed.</source>
          <target state="translated">지정된 파일 이후에 변수를 처리하려는 경우 &lt;code&gt;-after&lt;/code&gt; 옵션을 전달할 수 있습니다. 이것이 지정되면, &lt;code&gt;-after&lt;/code&gt; 옵션 다음에있는 명령 행의 모든 ​​지정 은 지정된 파일이 구문 분석 될 때까지 연기됩니다.</target>
        </trans-unit>
        <trans-unit id="148f7c117f2dde1027fc147e230853f26463b083" translate="yes" xml:space="preserve">
          <source>If you are changing the number of columns or rows you do not need to emit this signal, but use the begin/end functions (refer to the section on subclassing in the &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; class description for details).</source>
          <target state="translated">열 또는 행 수를 변경하는 경우이 신호를 방출 할 필요는 없지만 시작 / 종료 기능을 사용하십시오 ( 자세한 내용 은 &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; 클래스 설명의 서브 클래 싱 섹션 참조).</target>
        </trans-unit>
        <trans-unit id="e611044ce802a496de3904731dc8c7df2ec5aa83" translate="yes" xml:space="preserve">
          <source>If you are considering defining a new component, it's worth double checking that such a component doesn't already exist in the component set for your platform. Otherwise, you will be forcing the QML engine to generate and store type-data for a type which is essentially a duplicate of another pre-existing and potentially already loaded component.</source>
          <target state="translated">새 컴포넌트 정의를 고려중인 경우 해당 컴포넌트가 플랫폼의 컴포넌트 세트에 없는지 다시 확인해야합니다. 그렇지 않으면 QML 엔진이 다른 기존의 잠재적으로 이미로드 된 구성 요소와 본질적으로 중복되는 유형에 대한 유형 데이터를 생성하고 저장하도록합니다.</target>
        </trans-unit>
        <trans-unit id="a7ed74a89447502632954ce9ef8c44afaaa3bd1a" translate="yes" xml:space="preserve">
          <source>If you are designing an application which changes its layout depending on device orientation, you probably want to use primaryOrientation to determine the layout. That is because on a desktop computer, you can expect primaryOrientation to change when the user rotates the screen via the operating system's control panel, even if the computer does not contain an accelerometer. Likewise on most handheld computers which do have accelerometers, the operating system will rotate the whole screen automatically, so again you will see the primaryOrientation change.</source>
          <target state="translated">장치 방향에 따라 레이아웃을 변경하는 응용 프로그램을 디자인하는 경우 primaryOrientation을 사용하여 레이아웃을 결정할 수 있습니다. 데스크톱 컴퓨터에서는 컴퓨터에 가속도계가없는 경우에도 사용자가 운영 체제 제어판을 통해 화면을 회전하면 primaryOrientation이 변경 될 수 있기 때문입니다. 마찬가지로 가속도계가있는 대부분의 핸드 헬드 컴퓨터에서 운영 체제는 전체 화면을 자동으로 회전하므로 기본 방향 변경이 다시 나타납니다.</target>
        </trans-unit>
        <trans-unit id="a838ab048609c1ff2f968e68271c83f70b5950b3" translate="yes" xml:space="preserve">
          <source>If you are developing custom widgets and want them to look good on all platforms, you can use &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt; functions to perform parts of the widget drawing, such as &lt;a href=&quot;qstyle#drawItemText&quot;&gt;drawItemText&lt;/a&gt;(), &lt;a href=&quot;qstyle#drawItemPixmap&quot;&gt;drawItemPixmap&lt;/a&gt;(), &lt;a href=&quot;qstyle#drawPrimitive&quot;&gt;drawPrimitive&lt;/a&gt;(), &lt;a href=&quot;qstyle#drawControl&quot;&gt;drawControl&lt;/a&gt;(), and &lt;a href=&quot;qstyle#drawComplexControl&quot;&gt;drawComplexControl&lt;/a&gt;().</source>
          <target state="translated">사용자 정의 위젯을 개발 중이고 모든 플랫폼에서 잘 보이도록하려면 &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt; 함수를 사용 하여 &lt;a href=&quot;qstyle#drawItemText&quot;&gt;drawItemText&lt;/a&gt; (), &lt;a href=&quot;qstyle#drawItemPixmap&quot;&gt;drawItemPixmap&lt;/a&gt; (), &lt;a href=&quot;qstyle#drawPrimitive&quot;&gt;drawPrimitive&lt;/a&gt; (), &lt;a href=&quot;qstyle#drawControl&quot;&gt;drawControl&lt;/a&gt; () 및 &lt;a href=&quot;qstyle#drawComplexControl&quot;&gt;drawComplexControl&lt;/a&gt; ( ).</target>
        </trans-unit>
        <trans-unit id="bb5cd60e4ace21a0293ad3698cfd5443e59ec13d" translate="yes" xml:space="preserve">
          <source>If you are developing custom widgets and want them to look good on all platforms, you can use QStyle functions to perform parts of the widget drawing, such as &lt;a href=&quot;qstyle#drawItemText&quot;&gt;drawItemText&lt;/a&gt;(), &lt;a href=&quot;qstyle#drawItemPixmap&quot;&gt;drawItemPixmap&lt;/a&gt;(), &lt;a href=&quot;qstyle#drawPrimitive&quot;&gt;drawPrimitive&lt;/a&gt;(), &lt;a href=&quot;qstyle#drawControl&quot;&gt;drawControl&lt;/a&gt;(), and &lt;a href=&quot;qstyle#drawComplexControl&quot;&gt;drawComplexControl&lt;/a&gt;().</source>
          <target state="translated">사용자 정의 위젯을 개발하고 모든 플랫폼에서보기 좋게 보이도록하려면 QStyle 함수를 사용하여 &lt;a href=&quot;qstyle#drawItemText&quot;&gt;drawItemText&lt;/a&gt; (), &lt;a href=&quot;qstyle#drawItemPixmap&quot;&gt;drawItemPixmap&lt;/a&gt; (), &lt;a href=&quot;qstyle#drawPrimitive&quot;&gt;drawPrimitive&lt;/a&gt; (), &lt;a href=&quot;qstyle#drawControl&quot;&gt;drawControl&lt;/a&gt; () 및 &lt;a href=&quot;qstyle#drawComplexControl&quot;&gt;drawComplexControl&lt;/a&gt; ( ) 과 같은 위젯 그리기의 일부를 수행 할 수 있습니다. ).</target>
        </trans-unit>
        <trans-unit id="2b6f89e9c27aa8dab9848665ab7be6e8dabb614b" translate="yes" xml:space="preserve">
          <source>If you are experiencing strange problems with using special flags that modify the alignment of structure and union members (such as &lt;code&gt;/Zp2&lt;/code&gt;) then you will need to recompile Qt with the flags set for the application as well.</source>
          <target state="translated">구조 및 공용체 멤버 (예 : &lt;code&gt;/Zp2&lt;/code&gt; ) 의 정렬을 수정하는 특수 플래그를 사용할 때 이상한 문제가 발생 하면 응용 프로그램에 설정된 플래그를 사용하여 Qt를 다시 컴파일해야합니다.</target>
        </trans-unit>
        <trans-unit id="c59e1562773da0f0fa467136ee2b15d0a2847993" translate="yes" xml:space="preserve">
          <source>If you are extending your own C++ classes to interoperate with &lt;a href=&quot;qml-qtmultimedia-videooutput&quot;&gt;VideoOutput&lt;/a&gt;, you can either provide a &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; based class with a &lt;code&gt;mediaObject&lt;/code&gt; property that exposes a &lt;a href=&quot;qmediaobject&quot;&gt;QMediaObject&lt;/a&gt; derived class that has a &lt;a href=&quot;qvideorenderercontrol&quot;&gt;QVideoRendererControl&lt;/a&gt; available, or you can provide a &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; based class with a writable &lt;code&gt;videoSurface&lt;/code&gt; property that can accept a &lt;a href=&quot;qabstractvideosurface&quot;&gt;QAbstractVideoSurface&lt;/a&gt; based class and can follow the correct protocol to deliver QVideoFrames to it.</source>
          <target state="translated">당신이와 상호에 자신의 C ++ 클래스를 확장하는 경우 &lt;a href=&quot;qml-qtmultimedia-videooutput&quot;&gt;VideoOutput&lt;/a&gt; , 당신이 중 하나 제공 할 수 &lt;a href=&quot;qobject&quot;&gt;있는 QObject&lt;/a&gt; A를 기반으로 클래스 &lt;code&gt;mediaObject&lt;/code&gt; 노출 특성 &lt;a href=&quot;qmediaobject&quot;&gt;QMediaObject이&lt;/a&gt; 가 파생 클래스 &lt;a href=&quot;qvideorenderercontrol&quot;&gt;QVideoRendererControl이&lt;/a&gt; 가능한을, 또는 당신이 제공 할 수있는 &lt;a href=&quot;qobject&quot;&gt;QObject를&lt;/a&gt; 쓰기 가능으로 기반 클래스를 &lt;code&gt;videoSurface&lt;/code&gt; 의 특성 &lt;a href=&quot;qabstractvideosurface&quot;&gt;QAbstractVideoSurface&lt;/a&gt; 기반 클래스를 허용 하고 올바른 프로토콜을 따라 QVideoFrame을 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="16d93e1a61f637a487cbc998bfd086b866dc5f19" translate="yes" xml:space="preserve">
          <source>If you are extending your own C++ classes to interoperate with &lt;a href=&quot;qml-qtmultimedia-videooutput&quot;&gt;VideoOutput&lt;/a&gt;, you can either provide a &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; based class with a &lt;code&gt;mediaObject&lt;/code&gt; property that exposes a &lt;a href=&quot;qmediaobject&quot;&gt;QMediaObject&lt;/a&gt; derived class that has a QVideoRendererControl available, or you can provide a &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; based class with a writable &lt;code&gt;videoSurface&lt;/code&gt; property that can accept a &lt;a href=&quot;qabstractvideosurface&quot;&gt;QAbstractVideoSurface&lt;/a&gt; based class and can follow the correct protocol to deliver QVideoFrames to it.</source>
          <target state="translated">당신이와 상호에 자신의 C ++ 클래스를 확장하는 경우 &lt;a href=&quot;qml-qtmultimedia-videooutput&quot;&gt;VideoOutput&lt;/a&gt; , 당신이 중 하나 제공 할 수 &lt;a href=&quot;qobject&quot;&gt;있는 QObject&lt;/a&gt; A를 기반으로 클래스 &lt;code&gt;mediaObject&lt;/code&gt; 노출 특성 &lt;a href=&quot;qmediaobject&quot;&gt;QMediaObject이&lt;/a&gt; QVideoRendererControl 사용할 수있다 클래스를 파생를, 또는 당신이 제공 할 수있는 &lt;a href=&quot;qobject&quot;&gt;QObject를&lt;/a&gt; 쓰기 가능으로 기반 클래스를 &lt;code&gt;videoSurface&lt;/code&gt; 의 특성 &lt;a href=&quot;qabstractvideosurface&quot;&gt;QAbstractVideoSurface&lt;/a&gt; 기반 클래스를 허용 하고 올바른 프로토콜을 따라 QVideoFrames를 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2068e5692548a6f1e549d6b12838d705c030e74b" translate="yes" xml:space="preserve">
          <source>If you are faced with this problem, we recommend that you address the following issues:</source>
          <target state="translated">이 문제가 발생하면 다음 문제를 해결하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="35d5488eb1f1d92d7e5aa88f4683fbf0e4c5537e" translate="yes" xml:space="preserve">
          <source>If you are implementing your own SQL driver (by subclassing &lt;a href=&quot;qsqldriver&quot;&gt;QSqlDriver&lt;/a&gt;), you will need to provide your own &lt;a href=&quot;qsqlresult&quot;&gt;QSqlResult&lt;/a&gt; subclass that implements all the pure virtual functions and other virtual functions that you need.</source>
          <target state="translated">&lt;a href=&quot;qsqldriver&quot;&gt;QSqlDriver&lt;/a&gt; 를 서브 클래 싱하여 고유 한 SQL 드라이버를 구현하는 경우 필요한 모든 순수 가상 함수 및 기타 가상 함수를 구현하는 고유 한 &lt;a href=&quot;qsqlresult&quot;&gt;QSqlResult&lt;/a&gt; 서브 클래스 를 제공 해야합니다.</target>
        </trans-unit>
        <trans-unit id="a3ef456a7fc229cbd7e9c0ffe9581608f81e9277" translate="yes" xml:space="preserve">
          <source>If you are implementing your own SQL driver (by subclassing &lt;a href=&quot;qsqldriver&quot;&gt;QSqlDriver&lt;/a&gt;), you will need to provide your own QSqlResult subclass that implements all the pure virtual functions and other virtual functions that you need.</source>
          <target state="translated">자체 SQL 드라이버를 구현하는 경우 ( &lt;a href=&quot;qsqldriver&quot;&gt;QSqlDriver&lt;/a&gt; 를 서브 클래 싱 하여 ), 필요한 모든 순수 가상 함수 및 기타 가상 함수를 구현하는 고유 한 QSqlResult 하위 클래스를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="fd7eda5202cfdf24951838ad2ef93ee507cbd43f" translate="yes" xml:space="preserve">
          <source>If you are interested in later Qt releases, please &lt;a href=&quot;https://www.qt.io/contact-us/&quot;&gt;contact&lt;/a&gt; Qt professional services.</source>
          <target state="translated">이후 Qt 릴리스에 관심이 있으시면 Qt 전문 서비스에 &lt;a href=&quot;https://www.qt.io/contact-us/&quot;&gt;문의&lt;/a&gt; 하십시오 .</target>
        </trans-unit>
        <trans-unit id="fe18452186fa9062361200b3ccb934910231423b" translate="yes" xml:space="preserve">
          <source>If you are loading baked animation data from a file, e.g. as created by an artist, then use the &lt;a href=&quot;qt3danimation-qanimationcliploader&quot;&gt;QAnimationClipLoader&lt;/a&gt; class and set its &lt;code&gt;source&lt;/code&gt; property.</source>
          <target state="translated">아티스트가 만든 것과 같이 파일에서 구운 애니메이션 데이터를로드하는 경우 &lt;a href=&quot;qt3danimation-qanimationcliploader&quot;&gt;QAnimationClipLoader&lt;/a&gt; 클래스 를 사용하고 해당 &lt;code&gt;source&lt;/code&gt; 속성을 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="0cba86e45535051458a0288e4fb4ffb80d91bae6" translate="yes" xml:space="preserve">
          <source>If you are looking for the form window containing a specific widget, you can use the static &lt;a href=&quot;qdesignerformwindowinterface#findFormWindow&quot;&gt;QDesignerFormWindowInterface::findFormWindow&lt;/a&gt;() function:</source>
          <target state="translated">특정 위젯을 포함하는 양식 창을 찾고 있다면 정적 &lt;a href=&quot;qdesignerformwindowinterface#findFormWindow&quot;&gt;QDesignerFormWindowInterface :: findFormWindow&lt;/a&gt; () 함수를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2c0316dc7513ec4a829da5c582f7d1d6acdb751f" translate="yes" xml:space="preserve">
          <source>If you are making a one-of-a-kind special layout, you can also make a custom widget as described above. Reimplement &lt;a href=&quot;qwidget#resizeEvent&quot;&gt;QWidget::resizeEvent&lt;/a&gt;() to calculate the required distribution of sizes and call &lt;a href=&quot;qwidget#geometry-prop&quot;&gt;setGeometry()&lt;/a&gt; on each child.</source>
          <target state="translated">독특한 특수 레이아웃을 만드는 경우 위에서 설명한대로 사용자 정의 위젯을 만들 수도 있습니다. &lt;a href=&quot;qwidget#resizeEvent&quot;&gt;QWidget :: resizeEvent&lt;/a&gt; ()를 다시 구현 하여 필요한 크기 분포를 계산하고 각 하위에서 &lt;a href=&quot;qwidget#geometry-prop&quot;&gt;setGeometry ()&lt;/a&gt; 를 호출 하십시오 .</target>
        </trans-unit>
        <trans-unit id="c26fcdb2f849b2d77d06693955db2fff3cc3f735" translate="yes" xml:space="preserve">
          <source>If you are new to</source>
          <target state="translated">당신이 새로운 경우</target>
        </trans-unit>
        <trans-unit id="f8ea4e5d187592b96f3d3e96fb4ff64cf40b146a" translate="yes" xml:space="preserve">
          <source>If you are not using a Microsoft compiler, replace &lt;code&gt;nmake&lt;/code&gt; with &lt;code&gt;mingw32-make&lt;/code&gt; above.</source>
          <target state="translated">Microsoft 컴파일러를 사용하지 않는 경우 &lt;code&gt;nmake&lt;/code&gt; 를 위의 &lt;code&gt;mingw32-make&lt;/code&gt; 로 바꿉니다 .</target>
        </trans-unit>
        <trans-unit id="dcd9c9ce13348f2c89eb8cba78831786c5cc5b63" translate="yes" xml:space="preserve">
          <source>If you are not using a Microsoft compiler, replace &lt;code&gt;nmake&lt;/code&gt; with &lt;code&gt;mingw32-make&lt;/code&gt; in the line above.</source>
          <target state="translated">Microsoft 컴파일러를 사용하지 않는 경우 위 행에서 &lt;code&gt;nmake&lt;/code&gt; 를 &lt;code&gt;mingw32-make&lt;/code&gt; 로 바꾸십시오 .</target>
        </trans-unit>
        <trans-unit id="1edeadb4bd991b2129e132ab33cd635b95bce3f1" translate="yes" xml:space="preserve">
          <source>If you are producing a new binary data format, such as a file format for documents created by your application, you could use a &lt;a href=&quot;qdatastream&quot;&gt;QDataStream&lt;/a&gt; to write the data in a portable format. Typically, you would write a brief header containing a magic string and a version number to give yourself room for future expansion. For example:</source>
          <target state="translated">응용 프로그램에서 만든 문서의 파일 형식과 같은 새로운 이진 데이터 형식을 생성하는 경우 &lt;a href=&quot;qdatastream&quot;&gt;QDataStream&lt;/a&gt; 을 사용 하여 데이터를 이식 가능한 형식으로 쓸 수 있습니다 . 일반적으로 매직 문자열과 버전 번호가 포함 된 간단한 헤더를 작성하여 향후 확장을위한 공간을 제공합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b85be7cbb917aa35229bc81cb7ed6a637a4a094e" translate="yes" xml:space="preserve">
          <source>If you are producing a new binary data format, such as a file format for documents created by your application, you could use a QDataStream to write the data in a portable format. Typically, you would write a brief header containing a magic string and a version number to give yourself room for future expansion. For example:</source>
          <target state="translated">애플리케이션에서 만든 문서의 파일 형식과 같은 새로운 이진 데이터 형식을 생성하는 경우 QDataStream을 사용하여 데이터를 이식 가능한 형식으로 쓸 수 있습니다. 일반적으로 향후 확장을위한 공간을 제공하기 위해 매직 문자열과 버전 번호가 포함 된 간단한 헤더를 작성합니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="eb09fb598133779ad982ebb67c487885dec29d18" translate="yes" xml:space="preserve">
          <source>If you are targeting a remote device, follow the instructions by Visual Studio to set it up correctly.</source>
          <target state="translated">원격 장치를 대상으로하는 경우 Visual Studio의 지침에 따라 올바르게 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="e7be62f1d287b5ad9255a5f38cc81e4c59081ab0" translate="yes" xml:space="preserve">
          <source>If you are targeting a remote device, please follow all instructions by Visual Studio to set it up correctly.</source>
          <target state="translated">원격 장치를 대상으로하는 경우 Visual Studio의 모든 지침에 따라 올바르게 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="ea5596ebb0c31feb5d9df57aad25f2ddd84844a7" translate="yes" xml:space="preserve">
          <source>If you are using &lt;a href=&quot;qmaccocoaviewcontainer&quot;&gt;QMacCocoaViewContainer&lt;/a&gt; as a subclass and are accessing Cocoa API, it is probably simpler to have your file end with &lt;code&gt;.mm&lt;/code&gt; instead of &lt;code&gt;.cpp&lt;/code&gt;. Most Apple tools will correctly identify the source as Objective-C++.</source>
          <target state="translated">당신이 사용하는 경우 &lt;a href=&quot;qmaccocoaviewcontainer&quot;&gt;QMacCocoaViewContainer를&lt;/a&gt; 서브 클래스로와 코코아 API에 액세스하고, 그것을 사용하여 파일 끝이 아마 간단 &lt;code&gt;.mm&lt;/code&gt; 대신 &lt;code&gt;.cpp&lt;/code&gt; . 대부분의 Apple 도구는 소스를 Objective-C ++로 올바르게 식별합니다.</target>
        </trans-unit>
        <trans-unit id="cce264affcdcade384e7402de8bca3620ccaf966" translate="yes" xml:space="preserve">
          <source>If you are using Firebird, the Firebird library has to be set explicitly:</source>
          <target state="translated">Firebird를 사용하는 경우 Firebird 라이브러리를 명시 적으로 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="76cab77a64194ebfdfb08bb8f02673df169ab05d" translate="yes" xml:space="preserve">
          <source>If you are using InterBase:</source>
          <target state="translated">InterBase를 사용하는 경우 :</target>
        </trans-unit>
        <trans-unit id="1b24d910a145f4c5008d5bda461465dab9c233b5" translate="yes" xml:space="preserve">
          <source>If you are using QMacCocoaViewContainer as a subclass and are accessing Cocoa API, it is probably simpler to have your file end with &lt;code&gt;.mm&lt;/code&gt; instead of &lt;code&gt;.cpp&lt;/code&gt;. Most Apple tools will correctly identify the source as Objective-C++.</source>
          <target state="translated">QMacCocoaViewContainer를 서브 클래스로 사용하고 Cocoa API에 액세스하는 경우 파일 이 &lt;code&gt;.cpp&lt;/code&gt; 대신 &lt;code&gt;.mm&lt;/code&gt; 로 끝나는 것이 더 간단 할 것입니다 . 대부분의 Apple 도구는 소스를 Objective-C ++로 올바르게 식별합니다.</target>
        </trans-unit>
        <trans-unit id="5aa0be9550f6d982ee509d2621be3bbbef0f0cdf" translate="yes" xml:space="preserve">
          <source>If you are using a pragma library script to store application-wide instance data, consider using a &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; singleton type instead. This should result in better performance, and will result in less JavaScript heap memory being used.</source>
          <target state="translated">pragma 라이브러리 스크립트를 사용하여 애플리케이션 전체 인스턴스 데이터를 저장하는 경우 &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 싱글 톤 유형을 대신 사용하십시오. 이로 인해 성능이 향상되고 사용되는 JavaScript 힙 메모리가 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="3770d0073ac083205b9034be2c54e0470c39f38e" translate="yes" xml:space="preserve">
          <source>If you are using a shared configuration of Qt enter the &lt;code&gt;plugin&lt;/code&gt; subdirectory and run &lt;code&gt;qmake&lt;/code&gt; and your make tool to build a plugin that integrates the &lt;a href=&quot;https://doc.qt.io/qt-5.13/qaxcontainer-module.html&quot;&gt;QAxContainer&lt;/a&gt; module into &lt;a href=&quot;qtdesigner-manual&quot;&gt;Qt Designer&lt;/a&gt;.</source>
          <target state="translated">Qt의 공유 구성을 사용하는 경우 &lt;code&gt;plugin&lt;/code&gt; 서브 디렉토리를 입력하고 &lt;code&gt;qmake&lt;/code&gt; 및 make 도구를 실행 하여 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qaxcontainer-module.html&quot;&gt;QAxContainer&lt;/a&gt; 모듈을 &lt;a href=&quot;qtdesigner-manual&quot;&gt;Qt Designer에&lt;/a&gt; 통합하는 플러그인을 빌드하십시오 .</target>
        </trans-unit>
        <trans-unit id="19fc65f87770f099e77d3065ca78a198baf61865" translate="yes" xml:space="preserve">
          <source>If you are using a shared configuration of Qt enter the &lt;code&gt;plugin&lt;/code&gt; subdirectory and run &lt;code&gt;qmake&lt;/code&gt; and your make tool to build a plugin that integrates the &lt;a href=&quot;https://doc.qt.io/qt-5.15/qaxcontainer-module.html&quot;&gt;QAxContainer&lt;/a&gt; module into &lt;a href=&quot;qtdesigner-manual&quot;&gt;Qt Designer&lt;/a&gt;.</source>
          <target state="translated">Qt의 공유 구성을 사용하는 경우 &lt;code&gt;plugin&lt;/code&gt; 하위 디렉토리에 들어가 &lt;code&gt;qmake&lt;/code&gt; 및 make 도구를 실행 하여 &lt;a href=&quot;https://doc.qt.io/qt-5.15/qaxcontainer-module.html&quot;&gt;QAxContainer&lt;/a&gt; 모듈을 &lt;a href=&quot;qtdesigner-manual&quot;&gt;Qt Designer에&lt;/a&gt; 통합하는 플러그인을 빌드하십시오 .</target>
        </trans-unit>
        <trans-unit id="804809b08005ed145375e8b07500633c8542f86c" translate="yes" xml:space="preserve">
          <source>If you are using coordinates with Qt's raster-based paint engine, it is important to note that, while coordinates greater than +/- 2&lt;sup&gt;15&lt;/sup&gt; can be used, any painting performed with coordinates outside this range is not guaranteed to be shown; the drawing may be clipped. This is due to the use of &lt;code&gt;short int&lt;/code&gt; in the implementation.</source>
          <target state="translated">Qt의 래스터 기반 페인트 엔진에 좌표를 사용하는 경우 +/- 2 &lt;sup&gt;15&lt;/sup&gt; 보다 큰 좌표를 사용할 수 있지만이 범위를 벗어난 좌표로 수행 된 페인팅은 표시되지 않을 수 있습니다. 그림이 잘릴 수 있습니다. 이는 구현에서 &lt;code&gt;short int&lt;/code&gt; 를 사용하기 때문 입니다.</target>
        </trans-unit>
        <trans-unit id="6c0876b52f0bb97073b195db808c67ccd41dfa9f" translate="yes" xml:space="preserve">
          <source>If you are using multiple inheritance, &lt;code&gt;moc&lt;/code&gt; assumes that the first inherited class is a subclass of &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;. Also, be sure that only the first inherited class is a &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;.</source>
          <target state="translated">다중 상속을 사용하는 경우 &lt;code&gt;moc&lt;/code&gt; 는 첫 번째 상속 된 클래스가 &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 의 서브 클래스라고 가정 합니다 . 또한, 상속 된 첫 번째 클래스 만 &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 인지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="0118c72bf59f28a9993657d26d130211a27352ae" translate="yes" xml:space="preserve">
          <source>If you are using older versions of GDB you must run with the full path to the executable. Later versions allow you to pass the bundle name on the command line.</source>
          <target state="translated">이전 버전의 GDB를 사용하는 경우 실행 파일의 전체 경로로 실행해야합니다. 최신 버전에서는 명령 행에서 번들 이름을 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="85b6bb08aa314f172681866d0c5bc4b59b8c4460" translate="yes" xml:space="preserve">
          <source>If you are using other libraries in your project in addition to those supplied with Qt, you need to specify them in your project file.</source>
          <target state="translated">Qt와 함께 제공된 라이브러리 외에 프로젝트에서 다른 라이브러리를 사용하는 경우 프로젝트 파일에서 라이브러리를 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="8a732d6c50e076fc75334ed75ced8d8ed40fd0bd" translate="yes" xml:space="preserve">
          <source>If you are using the &lt;b&gt;default message handler&lt;/b&gt; this function will abort to create a core dump. On Windows, for debug builds, this function will report a _CRT_ERROR enabling you to connect a debugger to the application.</source>
          <target state="translated">&lt;b&gt;기본 메시지 핸들러를&lt;/b&gt; 사용하는 경우이 기능은 중단되어 코어 덤프를 작성합니다. Windows에서 디버그 빌드의 경우이 함수는 디버거를 응용 프로그램에 연결할 수있는 _CRT_ERROR를보고합니다.</target>
        </trans-unit>
        <trans-unit id="45295d1c90cb9b9c5438d7a1a26913d214a13541" translate="yes" xml:space="preserve">
          <source>If you are using the QRenderAspect,</source>
          <target state="translated">QRenderAspect를 사용하는 경우</target>
        </trans-unit>
        <trans-unit id="c3b9a00ccce4e62ff266c186ade813aa22558a16" translate="yes" xml:space="preserve">
          <source>If you are using the mouse wheel to adjust the dial, the increment value is determined by the lesser value of &lt;a href=&quot;qapplication#wheelScrollLines-prop&quot;&gt;wheelScrollLines&lt;/a&gt; multipled by &lt;a href=&quot;qabstractslider#singleStep-prop&quot;&gt;singleStep&lt;/a&gt;, and &lt;a href=&quot;qabstractslider#pageStep-prop&quot;&gt;pageStep&lt;/a&gt;.</source>
          <target state="translated">당신이 다이얼을 조정하기 위해 마우스 휠을 사용하는 경우, 증가 값 중 작은 값에 의해 결정됩니다 &lt;a href=&quot;qapplication#wheelScrollLines-prop&quot;&gt;wheelScrollLines&lt;/a&gt; 에 의해 다중화 된 &lt;a href=&quot;qabstractslider#singleStep-prop&quot;&gt;singleStep&lt;/a&gt; 및 &lt;a href=&quot;qabstractslider#pageStep-prop&quot;&gt;pageStep&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5680084fc0c9cb534680eb4e097fee45a07cc304" translate="yes" xml:space="preserve">
          <source>If you are working with large amounts of filtering and have to invoke &lt;a href=&quot;qsortfilterproxymodel#invalidateFilter&quot;&gt;invalidateFilter&lt;/a&gt;() repeatedly, using &lt;a href=&quot;qabstractitemmodel#beginResetModel&quot;&gt;beginResetModel&lt;/a&gt;() / &lt;a href=&quot;qabstractitemmodel#endResetModel&quot;&gt;endResetModel&lt;/a&gt;() may be more efficient, depending on the implementation of your model. However, &lt;a href=&quot;qabstractitemmodel#beginResetModel&quot;&gt;beginResetModel&lt;/a&gt;() / &lt;a href=&quot;qabstractitemmodel#endResetModel&quot;&gt;endResetModel&lt;/a&gt;() returns the proxy model to its original state, losing selection information, and will cause the proxy model to be repopulated.</source>
          <target state="translated">당신은 필터링 많은 양의 작업을하고 호출이있는 경우 &lt;a href=&quot;qsortfilterproxymodel#invalidateFilter&quot;&gt;invalidateFilter을&lt;/a&gt; 사용하여 반복적으로 () &lt;a href=&quot;qabstractitemmodel#beginResetModel&quot;&gt;beginResetModel&lt;/a&gt; () / &lt;a href=&quot;qabstractitemmodel#endResetModel&quot;&gt;endResetModel는&lt;/a&gt; () 모델의 구현에 따라,보다 효율적으로 할 수있다. 그러나 &lt;a href=&quot;qabstractitemmodel#beginResetModel&quot;&gt;beginResetModel&lt;/a&gt; () / &lt;a href=&quot;qabstractitemmodel#endResetModel&quot;&gt;endResetModel는&lt;/a&gt; () 선택 정보의 손실, 원래 상태로 프록시 모델을 반환하고, 프록시 모델을 다시 채워 원인이됩니다.</target>
        </trans-unit>
        <trans-unit id="4e92252016948c7d93f00c52d4881602666a0f61" translate="yes" xml:space="preserve">
          <source>If you are working with large amounts of filtering and have to invoke &lt;a href=&quot;qsortfilterproxymodel#invalidateFilter&quot;&gt;invalidateFilter&lt;/a&gt;() repeatedly, using reset() may be more efficient, depending on the implementation of your model. However, reset() returns the proxy model to its original state, losing selection information, and will cause the proxy model to be repopulated.</source>
          <target state="translated">대량의 필터링 작업을 수행하고 &lt;a href=&quot;qsortfilterproxymodel#invalidateFilter&quot;&gt;invalidateFilter&lt;/a&gt; ()를 반복적 으로 호출해야하는 경우 모델 구현에 따라 reset ()을 사용하는 것이 더 효율적일 수 있습니다. 그러나 reset ()은 프록시 모델을 원래 상태로 되돌려 선택 정보를 잃어 프록시 모델을 다시 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="34e44643802042a92e26e2ac644b7bbd813df0ea" translate="yes" xml:space="preserve">
          <source>If you assign an &lt;a href=&quot;qml-qtquick-item&quot;&gt;Item&lt;/a&gt; to the data list, it becomes a child of the Window's &lt;a href=&quot;qml-qtquick-window-window#contentItem-prop&quot;&gt;contentItem&lt;/a&gt;, so that it appears inside the window. The item's parent will be the window's &lt;a href=&quot;qml-qtquick-window-window#contentItem-prop&quot;&gt;contentItem&lt;/a&gt;, which is the root of the Item ownership tree within that Window.</source>
          <target state="translated">데이터 목록에 &lt;a href=&quot;qml-qtquick-item&quot;&gt;항목&lt;/a&gt; 을 할당하면 해당 항목 이 창의 &lt;a href=&quot;qml-qtquick-window-window#contentItem-prop&quot;&gt;contentItem&lt;/a&gt; 의 자식이되어 창 안에 나타납니다. 아이템의 부모는 윈도우의 &lt;a href=&quot;qml-qtquick-window-window#contentItem-prop&quot;&gt;contentItem&lt;/a&gt; 이며, 이는 해당 윈도우 내의 아이템 소유권 트리의 루트입니다.</target>
        </trans-unit>
        <trans-unit id="5aaba7502661bc68db19eb08ff6699bd95815c44" translate="yes" xml:space="preserve">
          <source>If you assign an Item to the contentData list, it becomes a child of the window's &lt;a href=&quot;qml-qtquick-controls2-applicationwindow#contentItem-attached-prop&quot;&gt;contentItem&lt;/a&gt;, so that it appears inside the window. The item's parent will be the window's &lt;a href=&quot;qml-qtquick-controls2-applicationwindow#contentItem-attached-prop&quot;&gt;contentItem&lt;/a&gt;.</source>
          <target state="translated">contentData 목록에 항목을 할당하면 해당 항목이 창의 &lt;a href=&quot;qml-qtquick-controls2-applicationwindow#contentItem-attached-prop&quot;&gt;contentItem&lt;/a&gt; 의 자식이되어 창 안에 나타납니다. 아이템의 부모는 윈도우의 &lt;a href=&quot;qml-qtquick-controls2-applicationwindow#contentItem-attached-prop&quot;&gt;contentItem&lt;/a&gt; 이 될 것 입니다.</target>
        </trans-unit>
        <trans-unit id="ae7ce82b8f37a865273277d942e3addd51f65355" translate="yes" xml:space="preserve">
          <source>If you assign another Window to the data list, the nested window will become &quot;transient for&quot; the outer Window.</source>
          <target state="translated">데이터 목록에 다른 창을 할당하면 중첩 된 창은 외부 창에 대해 &quot;일시적&quot;이됩니다.</target>
        </trans-unit>
        <trans-unit id="6035c7d9b7cf831619fd5c7a4a0d37226189ee56" translate="yes" xml:space="preserve">
          <source>If you assign any other object type, it is added as a resource.</source>
          <target state="translated">다른 객체 유형을 할당하면 해당 객체 유형이 리소스로 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="1c354aa520efd20d31e9318d38fb15177e0b11b8" translate="yes" xml:space="preserve">
          <source>If you build Qt directly from the Git repository, you should initialize the repository only with modules which are supported or build and install modules separately. This helps to prevent unexpected build problems.</source>
          <target state="translated">Git 저장소에서 직접 Qt를 빌드하는 경우 지원되는 모듈로만 저장소를 초기화하거나 모듈을 별도로 빌드 및 설치해야합니다. 예기치 않은 빌드 문제를 방지하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="06fc70f2a7700754e8743bc2e93d51b94fb545ce" translate="yes" xml:space="preserve">
          <source>If you build Qt from a released source code distribution archive, the &lt;code&gt;configure&lt;/code&gt; tool ensures that the build will be made only for modules which are known to build for the target specified. Additionally, you can explicitly exclude unsupported or not needed modules from the build via the &lt;code&gt;-skip &amp;lt;module&amp;gt;&lt;/code&gt; option when running the &lt;code&gt;configure&lt;/code&gt; tool.</source>
          <target state="translated">릴리스 된 소스 코드 배포 아카이브에서 Qt를 빌드하는 경우 &lt;code&gt;configure&lt;/code&gt; 도구는 지정된 대상에 대해 빌드 된 것으로 알려진 모듈에 대해서만 빌드되도록합니다. 또한 &lt;code&gt;configure&lt;/code&gt; 도구를 실행할 때 &lt;code&gt;-skip &amp;lt;module&amp;gt;&lt;/code&gt; 옵션을 통해 빌드에서 지원되지 않거나 필요하지 않은 모듈을 명시 적으로 제외 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0e610364a79b087476ba6a095bd06550ca27dd37" translate="yes" xml:space="preserve">
          <source>If you call &lt;a href=&quot;qaudiodecoder#read&quot;&gt;read&lt;/a&gt;() before a buffer is ready, an invalid buffer will be returned, again without blocking.</source>
          <target state="translated">버퍼가 준비되기 전에 &lt;a href=&quot;qaudiodecoder#read&quot;&gt;read&lt;/a&gt; () 를 호출하면 다시 차단하지 않고 잘못된 버퍼가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="c48e608f5b5491fc020146b414547db6c7503de9" translate="yes" xml:space="preserve">
          <source>If you call &lt;a href=&quot;qregexp#exactMatch&quot;&gt;exactMatch&lt;/a&gt;() with an empty pattern on an empty string it will return true; otherwise it returns &lt;code&gt;false&lt;/code&gt; since it operates over the whole string. If you call &lt;a href=&quot;qregexp#indexIn&quot;&gt;indexIn&lt;/a&gt;() with an empty pattern on</source>
          <target state="translated">빈 문자열에 빈 패턴으로 &lt;a href=&quot;qregexp#exactMatch&quot;&gt;exactMatch&lt;/a&gt; () 를 호출하면 true를 반환합니다. 그렇지 않으면 전체 문자열에서 작동하므로 &lt;code&gt;false&lt;/code&gt; 를 반환 합니다. 빈 패턴으로 &lt;a href=&quot;qregexp#indexIn&quot;&gt;indexIn&lt;/a&gt; () 을 호출하면</target>
        </trans-unit>
        <trans-unit id="cec9bbda48a93480232a0f202e7db7386279c388" translate="yes" xml:space="preserve">
          <source>If you can't parse the entire input in one go (for example, it is huge, or is being delivered over a network connection), data can be fed to the parser in pieces. This is achieved by telling &lt;a href=&quot;qxmlsimplereader#parse&quot;&gt;parse&lt;/a&gt;() to work incrementally, and making subsequent calls to the &lt;a href=&quot;qxmlsimplereader#parseContinue&quot;&gt;parseContinue&lt;/a&gt;() function, until all the data has been processed.</source>
          <target state="translated">전체 입력을 한 번에 구문 분석 할 수없는 경우 (예 : 용량이 크거나 네트워크 연결을 통해 전달되는 경우) 데이터를 파서에 조각으로 공급할 수 있습니다. 이는 모든 데이터가 처리 될 때까지 &lt;a href=&quot;qxmlsimplereader#parse&quot;&gt;parse&lt;/a&gt; ()에게 점진적으로 작동하도록하고 &lt;a href=&quot;qxmlsimplereader#parseContinue&quot;&gt;parseContinue&lt;/a&gt; () 함수 에 대한 후속 호출을 수행함으로써 달성됩니다 .</target>
        </trans-unit>
        <trans-unit id="161a3dea480d3f0f0c723c9f283dc0ca633fd1f9" translate="yes" xml:space="preserve">
          <source>If you cannot determine a better proxy alternative, use &lt;a href=&quot;qnetworkproxy#ProxyType-enum&quot;&gt;QNetworkProxy::DefaultProxy&lt;/a&gt;, which tells the code querying for a proxy to use a higher alternative. For example, if this factory is set to a &lt;a href=&quot;qnetworkaccessmanager&quot;&gt;QNetworkAccessManager&lt;/a&gt; object, DefaultProxy will tell it to query the application-level proxy settings.</source>
          <target state="translated">더 나은 프록시 대안을 결정할 수없는 경우 &lt;a href=&quot;qnetworkproxy#ProxyType-enum&quot;&gt;QNetworkProxy :: DefaultProxy&lt;/a&gt; 를 사용하면 프록시가 더 높은 대안을 사용하도록 쿼리하도록 코드에 지시합니다. 예를 들어,이 팩토리가 &lt;a href=&quot;qnetworkaccessmanager&quot;&gt;QNetworkAccessManager&lt;/a&gt; 객체로 설정된 경우 DefaultProxy는 애플리케이션 수준 프록시 설정을 쿼리하도록 지시합니다.</target>
        </trans-unit>
        <trans-unit id="47ee22ae7e0b70ca20b7a7ddcb373d31f54e2606" translate="yes" xml:space="preserve">
          <source>If you change the color of the legend, the style of the legend brush is set to &lt;a href=&quot;qt#BrushStyle-enum&quot;&gt;Qt::SolidPattern&lt;/a&gt;.</source>
          <target state="translated">범례의 색상을 변경하면 범례 브러시 스타일이 &lt;a href=&quot;qt#BrushStyle-enum&quot;&gt;Qt :: SolidPattern로&lt;/a&gt; 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="7475bf20fe338cf02b178e9339633535de23b38a" translate="yes" xml:space="preserve">
          <source>If you change the values that a &lt;a href=&quot;qml-qtquick-tableview#rowHeightProvider-prop&quot;&gt;rowHeightProvider&lt;/a&gt; or a &lt;a href=&quot;qml-qtquick-tableview#columnWidthProvider-prop&quot;&gt;columnWidthProvider&lt;/a&gt; return for rows and columns inside the viewport, you must call &lt;a href=&quot;qml-qtquick-tableview#forceLayout-method&quot;&gt;forceLayout&lt;/a&gt;. This informs &lt;a href=&quot;qml-qtquick-tableview&quot;&gt;TableView&lt;/a&gt; that it needs to use the provider functions again to recalculate and update the layout.</source>
          <target state="translated">뷰포트 내의 행과 열에 대해 &lt;a href=&quot;qml-qtquick-tableview#rowHeightProvider-prop&quot;&gt;rowHeightProvider&lt;/a&gt; 또는 &lt;a href=&quot;qml-qtquick-tableview#columnWidthProvider-prop&quot;&gt;columnWidthProvider가&lt;/a&gt; 반환 하는 값을 변경하면 &lt;a href=&quot;qml-qtquick-tableview#forceLayout-method&quot;&gt;forceLayout을&lt;/a&gt; 호출해야합니다 . 그러면 &lt;a href=&quot;qml-qtquick-tableview&quot;&gt;TableView&lt;/a&gt; 에 공급자 함수를 다시 사용하여 레이아웃을 다시 계산하고 업데이트해야합니다.</target>
        </trans-unit>
        <trans-unit id="92bca5c90310c6b9e2402ae2496f378c208edc9e" translate="yes" xml:space="preserve">
          <source>If you change the values that a &lt;a href=&quot;qml-qtquick-tableview#rowHeightProvider-prop&quot;&gt;rowHeightProvider&lt;/a&gt; or a &lt;a href=&quot;qml-qtquick-tableview#columnWidthProvider-prop&quot;&gt;columnWidthProvider&lt;/a&gt; return for rows and columns inside the viewport, you must call &lt;a href=&quot;qml-qtquick-tableview#forceLayout-method&quot;&gt;forceLayout&lt;/a&gt;. This informs TableView that it needs to use the provider functions again to recalculate and update the layout.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-tableview#rowHeightProvider-prop&quot;&gt;rowHeightProvider&lt;/a&gt; 또는 &lt;a href=&quot;qml-qtquick-tableview#columnWidthProvider-prop&quot;&gt;columnWidthProvider&lt;/a&gt; 가 뷰포트 내의 행과 열에 대해 반환 하는 값을 변경하는 경우 &lt;a href=&quot;qml-qtquick-tableview#forceLayout-method&quot;&gt;forceLayout을&lt;/a&gt; 호출해야합니다 . 이것은 레이아웃을 다시 계산하고 업데이트하기 위해 제공자 함수를 다시 사용해야한다는 것을 TableView에 알립니다.</target>
        </trans-unit>
        <trans-unit id="500f7c2ed4541742fa250d78ebc48a1f3b9006ae" translate="yes" xml:space="preserve">
          <source>If you choose to represent a gesture by a custom &lt;a href=&quot;qgesture&quot;&gt;QGesture&lt;/a&gt; subclass, you will need to reimplement the &lt;a href=&quot;qgesturerecognizer#create&quot;&gt;create&lt;/a&gt;() function to construct instances of your gesture class. Similarly, you may need to reimplement the &lt;a href=&quot;qgesturerecognizer#reset&quot;&gt;reset&lt;/a&gt;() function if your custom gesture objects need to be specially handled when a gesture is canceled.</source>
          <target state="translated">사용자 정의 &lt;a href=&quot;qgesture&quot;&gt;QGesture&lt;/a&gt; 서브 클래스 로 제스처를 표시하도록 선택하면 제스처 클래스의 인스턴스를 구성하기 위해 &lt;a href=&quot;qgesturerecognizer#create&quot;&gt;create&lt;/a&gt; () 함수를 다시 구현해야합니다 . 마찬가지로 제스처가 취소 될 때 사용자 지정 제스처 객체를 특별히 처리해야하는 경우 &lt;a href=&quot;qgesturerecognizer#reset&quot;&gt;reset&lt;/a&gt; () 기능 을 다시 구현해야 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="575ee9c79996cf1fc9e83075aafbc7b1ede52c95" translate="yes" xml:space="preserve">
          <source>If you compile Qt yourself, you can configure how Qt uses OpenSSL by setting either the &lt;code&gt;-openssl&lt;/code&gt; / &lt;code&gt;-openssl-runtime&lt;/code&gt; or &lt;code&gt;-openssl-linked&lt;/code&gt; configure flags.</source>
          <target state="translated">Qt를 직접 컴파일하는 경우 &lt;code&gt;-openssl&lt;/code&gt; / &lt;code&gt;-openssl-runtime&lt;/code&gt; 또는 &lt;code&gt;-openssl-linked&lt;/code&gt; 구성 플래그 를 설정하여 Qt에서 OpenSSL을 사용하는 방법을 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="60298eee3c23b33b1a704690c48b9151a00629d4" translate="yes" xml:space="preserve">
          <source>If you create a custom style, you should take special care when drawing asymmetric elements to make sure that they also look correct in a mirrored layout. An easy way to test your styles is to run applications with the &lt;code&gt;-reverse&lt;/code&gt; command-line option or to call &lt;a href=&quot;qguiapplication#layoutDirection-prop&quot;&gt;QApplication::setLayoutDirection&lt;/a&gt;() in your &lt;code&gt;main()&lt;/code&gt; function.</source>
          <target state="translated">사용자 정의 스타일을 작성하는 경우 비대칭 요소를 그릴 때 미러 레이아웃에서도 올바르게 표시되도록 특별한주의를 기울여야합니다. 스타일을 테스트하는 쉬운 방법은 &lt;code&gt;-reverse&lt;/code&gt; 명령 줄 옵션으로 응용 프로그램을 실행 하거나 &lt;code&gt;main()&lt;/code&gt; 함수 에서 &lt;a href=&quot;qguiapplication#layoutDirection-prop&quot;&gt;QApplication :: setLayoutDirection&lt;/a&gt; () 을 호출하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="17cd68422c27362470960984384c5dc705d301d1" translate="yes" xml:space="preserve">
          <source>If you create a new widget we strongly recommend that you use the colors in the palette rather than hard-coding specific colors.</source>
          <target state="translated">새 위젯을 작성하는 경우 특정 색상을 하드 코딩하는 대신 팔레트의 색상을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="3f4462d3119b6a25e2fe9303c0a819f7485e1e86" translate="yes" xml:space="preserve">
          <source>If you create a subclass of &lt;a href=&quot;qgraphicslayoutitem&quot;&gt;QGraphicsLayoutItem&lt;/a&gt; and reimplement its virtual functions, you will enable the layout to resize and position your item along with other QGraphicsLayoutItems including &lt;a href=&quot;graphicsview#qgraphicswidget&quot;&gt;QGraphicsWidget&lt;/a&gt; and &lt;a href=&quot;graphicsview#qgraphicslayout&quot;&gt;QGraphicsLayout&lt;/a&gt;.</source>
          <target state="translated">당신의 서브 클래스 만드는 경우 &lt;a href=&quot;qgraphicslayoutitem&quot;&gt;QGraphicsLayoutItem을&lt;/a&gt; 하고 가상 함수를 다시 구현, 당신은을 포함하여 다른 QGraphicsLayoutItems와 함께 항목을 크기를 조정하고 위치로 레이아웃을 가능하게 할 것이다 &lt;a href=&quot;graphicsview#qgraphicswidget&quot;&gt;QGraphicsWidget&lt;/a&gt; 및 &lt;a href=&quot;graphicsview#qgraphicslayout&quot;&gt;QGraphicsLayout&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a1a612dece7462522525e84b25c5c8a2de0d8e80" translate="yes" xml:space="preserve">
          <source>If you create a subclass of QGraphicsLayoutItem and reimplement its virtual functions, you will enable the layout to resize and position your item along with other QGraphicsLayoutItems including &lt;a href=&quot;graphicsview#qgraphicswidget&quot;&gt;QGraphicsWidget&lt;/a&gt; and &lt;a href=&quot;graphicsview#qgraphicslayout&quot;&gt;QGraphicsLayout&lt;/a&gt;.</source>
          <target state="translated">QGraphicsLayoutItem의 하위 클래스를 만들고 가상 기능을 다시 구현하면 레이아웃을 활성화하여 &lt;a href=&quot;graphicsview#qgraphicswidget&quot;&gt;QGraphicsWidget&lt;/a&gt; 및 &lt;a href=&quot;graphicsview#qgraphicslayout&quot;&gt;QGraphicsLayout을&lt;/a&gt; 포함한 다른 QGraphicsLayoutItems와 함께 항목의 크기를 조정하고 위치를 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fbd1dc4f7124280b641957b9c985d0980cf1e5a2" translate="yes" xml:space="preserve">
          <source>If you create an element or attribute with &lt;a href=&quot;qdomdocument#createElement&quot;&gt;QDomDocument::createElement&lt;/a&gt;() or &lt;a href=&quot;qdomdocument#createAttribute&quot;&gt;QDomDocument::createAttribute&lt;/a&gt;(), the prefix will be an empty string. If you use &lt;a href=&quot;qdomdocument#createElementNS&quot;&gt;QDomDocument::createElementNS&lt;/a&gt;() or &lt;a href=&quot;qdomdocument#createAttributeNS&quot;&gt;QDomDocument::createAttributeNS&lt;/a&gt;() instead, the prefix will not be an empty string; but it might be an empty string if the name does not have a prefix.</source>
          <target state="translated">&lt;a href=&quot;qdomdocument#createElement&quot;&gt;QDomDocument :: createElement&lt;/a&gt; () 또는 &lt;a href=&quot;qdomdocument#createAttribute&quot;&gt;QDomDocument :: createAttribute&lt;/a&gt; () 로 요소 또는 속성을 작성하면 접 두부가 빈 문자열이됩니다. 당신이 사용하는 경우 &lt;a href=&quot;qdomdocument#createElementNS&quot;&gt;QDomDocument ::에는 createElementNS&lt;/a&gt; () 또는 &lt;a href=&quot;qdomdocument#createAttributeNS&quot;&gt;QDomDocument :: createAttributeNS는&lt;/a&gt; () 대신에, 접두사는 빈 문자열되지 않습니다; 이름에 접두사가 없으면 빈 문자열 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a8af07b0934236da5d1098a000948ac0c59d159" translate="yes" xml:space="preserve">
          <source>If you create multiple database connections, specify a unique connection name for each one, when you call &lt;a href=&quot;qsqldatabase#addDatabase&quot;&gt;addDatabase&lt;/a&gt;(). Use &lt;a href=&quot;qsqldatabase#database&quot;&gt;database&lt;/a&gt;() with a connection name to get that connection. Use &lt;a href=&quot;qsqldatabase#removeDatabase&quot;&gt;removeDatabase&lt;/a&gt;() with a connection name to remove a connection. &lt;a href=&quot;qsqldatabase&quot;&gt;QSqlDatabase&lt;/a&gt; outputs a warning if you try to remove a connection referenced by other &lt;a href=&quot;qsqldatabase&quot;&gt;QSqlDatabase&lt;/a&gt; objects. Use &lt;a href=&quot;qsqldatabase#contains&quot;&gt;contains&lt;/a&gt;() to see if a given connection name is in the list of connections.</source>
          <target state="translated">여러 데이터베이스 연결을 작성하는 경우 &lt;a href=&quot;qsqldatabase#addDatabase&quot;&gt;addDatabase&lt;/a&gt; () 를 호출 할 때 각각에 고유 한 연결 이름을 지정하십시오 . 사용하여 &lt;a href=&quot;qsqldatabase#database&quot;&gt;데이터베이스를&lt;/a&gt; 해당 연결을 얻을 수있는 연결 이름 (). 사용 &lt;a href=&quot;qsqldatabase#removeDatabase&quot;&gt;removeDatabase를&lt;/a&gt; 연결을 제거하기 위해 연결 이름 (). 다른 &lt;a href=&quot;qsqldatabase&quot;&gt;QSqlDatabase&lt;/a&gt; 오브젝트가 참조하는 연결을 제거하려고하면 &lt;a href=&quot;qsqldatabase&quot;&gt;QSqlDatabase&lt;/a&gt; 가 경고를 출력 합니다. &lt;a href=&quot;qsqldatabase#contains&quot;&gt;포함&lt;/a&gt; ()을 사용 하여 지정된 연결 이름이 연결 목록에 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="cf63af2b8619ee051d3e4a4b1749839916624b30" translate="yes" xml:space="preserve">
          <source>If you create multiple database connections, specify a unique connection name for each one, when you call &lt;a href=&quot;qsqldatabase#addDatabase&quot;&gt;addDatabase&lt;/a&gt;(). Use &lt;a href=&quot;qsqldatabase#database&quot;&gt;database&lt;/a&gt;() with a connection name to get that connection. Use &lt;a href=&quot;qsqldatabase#removeDatabase&quot;&gt;removeDatabase&lt;/a&gt;() with a connection name to remove a connection. QSqlDatabase outputs a warning if you try to remove a connection referenced by other QSqlDatabase objects. Use &lt;a href=&quot;qsqldatabase#contains&quot;&gt;contains&lt;/a&gt;() to see if a given connection name is in the list of connections.</source>
          <target state="translated">여러 데이터베이스 연결을 만드는 경우 &lt;a href=&quot;qsqldatabase#addDatabase&quot;&gt;addDatabase&lt;/a&gt; () 를 호출 할 때 각각에 대해 고유 한 연결 이름을 지정합니다 . 사용하여 &lt;a href=&quot;qsqldatabase#database&quot;&gt;데이터베이스를&lt;/a&gt; 해당 연결을 얻을 수있는 연결 이름 (). 연결을 제거하려면 연결 이름과 함께 &lt;a href=&quot;qsqldatabase#removeDatabase&quot;&gt;removeDatabase&lt;/a&gt; ()를 사용하십시오 . QSqlDatabase는 다른 QSqlDatabase 개체가 참조하는 연결을 제거하려고하면 경고를 출력합니다. &lt;a href=&quot;qsqldatabase#contains&quot;&gt;포함&lt;/a&gt; ()을 사용 하여 지정된 연결 이름이 연결 목록에 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="7646273ae2dbacaa23658a4e7083837be610751f" translate="yes" xml:space="preserve">
          <source>If you create new widgets in the mousePressEvent() the &lt;a href=&quot;qwidget#mouseReleaseEvent&quot;&gt;mouseReleaseEvent&lt;/a&gt;() may not end up where you expect, depending on the underlying window system (or X11 window manager), the widgets' location and maybe more.</source>
          <target state="translated">mousePressEvent ()에서 새 위젯을 작성 하면 기본 창 시스템 (또는 X11 창 관리자), 위젯 위치 및 기타에 따라 &lt;a href=&quot;qwidget#mouseReleaseEvent&quot;&gt;mouseReleaseEvent&lt;/a&gt; ()가 예상 한 위치에서 끝나지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8099c41c6c4619a93004cbcf0c3515483d52ce0b" translate="yes" xml:space="preserve">
          <source>If you declare the</source>
          <target state="translated">당신이 선언하면</target>
        </trans-unit>
        <trans-unit id="9e4643eafbd0d4a96807a4ddcf5f41ce29cc0458" translate="yes" xml:space="preserve">
          <source>If you develop components you might want to control who is able to instantiate those components. Since the server binary can be shipped to and registered on any client machine it is possible for anybody to use those components in his own software.</source>
          <target state="translated">컴포넌트를 개발하는 경우 해당 컴포넌트를 인스턴스화 할 수있는 사람을 제어 할 수 있습니다. 서버 바이너리는 모든 클라이언트 시스템으로 배송 및 등록 할 수 있으므로 누구나 자신의 소프트웨어에서 해당 구성 요소를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ec1ab807ee3535bc730f9e500858259db3a5b6a" translate="yes" xml:space="preserve">
          <source>If you develop on a Linux machine, you can also run the compositor within a window on your development machine. This lets you run clients in an environment that closely resembles the target device. Without rebuilding the client, you can also run it with &lt;code&gt;-platform wayland&lt;/code&gt; to run it inside the compositor. If you use &lt;code&gt;-platform xcb&lt;/code&gt; (for X11), you can run the client on the desktop. In other words, you can start developing your clients before the compositor is ready for use.</source>
          <target state="translated">Linux 시스템에서 개발하는 경우 개발 시스템의 창에서 컴포 지터를 실행할 수도 있습니다. 이를 통해 대상 장치와 매우 유사한 환경에서 클라이언트를 실행할 수 있습니다. 클라이언트를 재 구축하지 않고 &lt;code&gt;-platform wayland&lt;/code&gt; 로 실행하여 컴포 지터 내에서 실행할 수도 있습니다. &lt;code&gt;-platform xcb&lt;/code&gt; (X11의 경우)를 사용 하면 데스크탑에서 클라이언트를 실행할 수 있습니다. 즉, 컴포 지터를 사용할 준비가되기 전에 클라이언트 개발을 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="afa8bf4954cb5202a30b0fc12f02b6b538c3177e" translate="yes" xml:space="preserve">
          <source>If you did not build Qt with RPATH enabled, you can place the Qt runtime components in any folder in the file system. The following environment variables should point to valid locations assuming that the Qt installation is located in &lt;code&gt;&amp;lt;Qt-install-path&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">RPATH를 사용하여 Qt를 빌드하지 않은 경우 Qt 런타임 구성 요소를 파일 시스템의 임의의 폴더에 배치 할 수 있습니다. Qt 설치가 &lt;code&gt;&amp;lt;Qt-install-path&amp;gt;&lt;/code&gt; 에 있다고 가정하면 다음 환경 변수는 유효한 위치를 가리켜 야합니다 .</target>
        </trans-unit>
        <trans-unit id="f5ac96c3608663c3ee69d2ea4c3f3259795c6549" translate="yes" xml:space="preserve">
          <source>If you disable a parent item, all its children will also be disabled. If you enable a parent item, all children will be enabled, unless they have been explicitly disabled (i.e., if you call setEnabled(false) on a child, it will not be reenabled if its parent is disabled, and then enabled again).</source>
          <target state="translated">상위 항목을 비활성화하면 모든 하위 항목도 비활성화됩니다. 부모 항목을 활성화하면 명시 적으로 비활성화되지 않은 모든 하위 항목이 활성화됩니다 (예 : 하위 항목에서 setEnabled (false)를 호출하면 상위 항목이 비활성화 된 후 다시 활성화 될 수 있음).</target>
        </trans-unit>
        <trans-unit id="b84a34e331b907bd7ec85f721effe578cfa854d4" translate="yes" xml:space="preserve">
          <source>If you disable the &lt;code&gt;const char *&lt;/code&gt; to &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; automatic conversion by compiling your software with the macro &lt;code&gt;QT_NO_CAST_FROM_ASCII&lt;/code&gt; defined, you'll be very likely to catch any strings you are missing. See &lt;a href=&quot;qstring#fromUtf8&quot;&gt;QString::fromUtf8&lt;/a&gt;() and &lt;a href=&quot;qstring#fromLatin1&quot;&gt;QString::fromLatin1&lt;/a&gt;() for more information.</source>
          <target state="translated">매크로 &lt;code&gt;QT_NO_CAST_FROM_ASCII&lt;/code&gt; 가 정의 된 상태에서 소프트웨어를 컴파일하여 &lt;code&gt;const char *&lt;/code&gt; 를 &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; 자동 변환으로 비활성화하면 누락 된 문자열을 잡을 가능성이 큽니다. 자세한 정보는 &lt;a href=&quot;qstring#fromUtf8&quot;&gt;QString :: fromUtf8&lt;/a&gt; () 및 &lt;a href=&quot;qstring#fromLatin1&quot;&gt;QString :: fromLatin1&lt;/a&gt; ()을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1beb35be34924577a497d6aa4f5c769f34ab178d" translate="yes" xml:space="preserve">
          <source>If you disable the deprecated version using the &lt;a href=&quot;qtglobal#QT_DISABLE_DEPRECATED_BEFORE&quot;&gt;QT_DISABLE_DEPRECATED_BEFORE&lt;/a&gt; macro, then you can omit &lt;code&gt;Qt::ReturnByValue&lt;/code&gt; as shown below:</source>
          <target state="translated">&lt;a href=&quot;qtglobal#QT_DISABLE_DEPRECATED_BEFORE&quot;&gt;QT_DISABLE_DEPRECATED_BEFORE&lt;/a&gt; 매크로 를 사용하여 더 이상 사용되지 않는 버전을 비활성화하는 경우 아래와 같이 &lt;code&gt;Qt::ReturnByValue&lt;/code&gt; 를 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c6a1ddfc7d45f56ca6150fe2e413b375a67c3c1" translate="yes" xml:space="preserve">
          <source>If you do not see the entries for the gamepad you are using, check if the &lt;code&gt;joystick&lt;/code&gt; package is installed. If not, install the package and &lt;code&gt;grep&lt;/code&gt; the &lt;code&gt;dmesg&lt;/code&gt; logs again.</source>
          <target state="translated">사용중인 게임 패드에 대한 항목이 표시되지 않으면 &lt;code&gt;joystick&lt;/code&gt; 패키지가 설치되어 있는지 확인하십시오 . 그렇지 않은 경우 패키지를 설치 하고 &lt;code&gt;dmesg&lt;/code&gt; 로그를 다시 &lt;code&gt;grep&lt;/code&gt; 하십시오.</target>
        </trans-unit>
        <trans-unit id="ca2f383e2bf046db28456505c081643e252eeb5d" translate="yes" xml:space="preserve">
          <source>If you do not specify a format, the format of the decoded audio itself will be used. Otherwise, some format conversion will be applied.</source>
          <target state="translated">형식을 지정하지 않으면 디코딩 된 오디오 자체 형식이 사용됩니다. 그렇지 않으면 일부 형식 변환이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="de1635a44cea7651e746c1686155d7406a62dc52" translate="yes" xml:space="preserve">
          <source>If you do not want all plugins added to QTPLUGIN to be automatically linked, remove &lt;code&gt;import_plugins&lt;/code&gt; from the &lt;code&gt;CONFIG&lt;/code&gt; variable:</source>
          <target state="translated">QTPLUGIN에 추가 된 모든 플러그인이 자동으로 링크 &lt;code&gt;import_plugins&lt;/code&gt; 않게하려면 &lt;code&gt;CONFIG&lt;/code&gt; 변수 에서 import_plugins 를 제거하십시오 .</target>
        </trans-unit>
        <trans-unit id="cdd8ad11a5a8433d7c4e01c15d5566bd728f5503" translate="yes" xml:space="preserve">
          <source>If you do not want particles to automatically die after a time, for example if you wish to dispose of them manually, set lifeSpan to Emitter.InfiniteLife.</source>
          <target state="translated">예를 들어 입자를 수동으로 폐기하려는 경우와 같이 시간이 지난 후에 입자가 자동으로 죽지 않게하려면 lifeSpan을 Emitter.InfiniteLife로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="137e6ed64703982d6f6a1b7c58462d03cb2952de" translate="yes" xml:space="preserve">
          <source>If you do not want the line edit to have a context menu, you can set its &lt;a href=&quot;qwidget#contextMenuPolicy-prop&quot;&gt;contextMenuPolicy&lt;/a&gt; to &lt;a href=&quot;qt#ContextMenuPolicy-enum&quot;&gt;Qt::NoContextMenu&lt;/a&gt;. If you want to customize the context menu, reimplement this function. If you want to extend the standard context menu, reimplement this function, call &lt;a href=&quot;qlineedit#createStandardContextMenu&quot;&gt;createStandardContextMenu&lt;/a&gt;() and extend the menu returned.</source>
          <target state="translated">행 편집에 컨텍스트 메뉴가 없도록하려면 &lt;a href=&quot;qwidget#contextMenuPolicy-prop&quot;&gt;contextMenuPolicy&lt;/a&gt; 를 &lt;a href=&quot;qt#ContextMenuPolicy-enum&quot;&gt;Qt :: NoContextMenu&lt;/a&gt; 로 설정할 수 있습니다 . 상황에 맞는 메뉴를 사용자 정의하려면이 기능을 다시 구현하십시오. 표준 컨텍스트 메뉴를 확장하려면이 함수를 다시 구현하고 &lt;a href=&quot;qlineedit#createStandardContextMenu&quot;&gt;createStandardContextMenu&lt;/a&gt; ()를 호출 하고 반환 된 메뉴를 확장하십시오.</target>
        </trans-unit>
        <trans-unit id="fc81d4dd3f76f07754477505ca4dd2bf14711219" translate="yes" xml:space="preserve">
          <source>If you do not want the text edit to have a context menu, you can set its &lt;a href=&quot;qwidget#contextMenuPolicy-prop&quot;&gt;contextMenuPolicy&lt;/a&gt; to &lt;a href=&quot;qt#ContextMenuPolicy-enum&quot;&gt;Qt::NoContextMenu&lt;/a&gt;. If you want to customize the context menu, reimplement this function. If you want to extend the standard context menu, reimplement this function, call &lt;a href=&quot;qplaintextedit#createStandardContextMenu&quot;&gt;createStandardContextMenu&lt;/a&gt;() and extend the menu returned.</source>
          <target state="translated">텍스트 편집에 상황에 맞는 메뉴가 없도록하려면 &lt;a href=&quot;qwidget#contextMenuPolicy-prop&quot;&gt;contextMenuPolicy&lt;/a&gt; 를 &lt;a href=&quot;qt#ContextMenuPolicy-enum&quot;&gt;Qt :: NoContextMenu&lt;/a&gt; 로 설정할 수 있습니다 . 상황에 맞는 메뉴를 사용자 정의하려면이 기능을 다시 구현하십시오. 표준 컨텍스트 메뉴를 확장하려면이 함수를 다시 구현하고 &lt;a href=&quot;qplaintextedit#createStandardContextMenu&quot;&gt;createStandardContextMenu&lt;/a&gt; ()를 호출 하고 반환 된 메뉴를 확장하십시오.</target>
        </trans-unit>
        <trans-unit id="264b0fb3179ab096c73c0b90036579cf8921a2f4" translate="yes" xml:space="preserve">
          <source>If you do not want the text edit to have a context menu, you can set its &lt;a href=&quot;qwidget#contextMenuPolicy-prop&quot;&gt;contextMenuPolicy&lt;/a&gt; to &lt;a href=&quot;qt#ContextMenuPolicy-enum&quot;&gt;Qt::NoContextMenu&lt;/a&gt;. If you want to customize the context menu, reimplement this function. If you want to extend the standard context menu, reimplement this function, call &lt;a href=&quot;qtextedit#createStandardContextMenu&quot;&gt;createStandardContextMenu&lt;/a&gt;() and extend the menu returned.</source>
          <target state="translated">텍스트 편집에 상황에 맞는 메뉴가 없도록하려면 &lt;a href=&quot;qwidget#contextMenuPolicy-prop&quot;&gt;contextMenuPolicy&lt;/a&gt; 를 &lt;a href=&quot;qt#ContextMenuPolicy-enum&quot;&gt;Qt :: NoContextMenu&lt;/a&gt; 로 설정할 수 있습니다 . 상황에 맞는 메뉴를 사용자 정의하려면이 기능을 다시 구현하십시오. 표준 컨텍스트 메뉴를 확장하려면이 함수를 다시 구현하고 &lt;a href=&quot;qtextedit#createStandardContextMenu&quot;&gt;createStandardContextMenu&lt;/a&gt; ()를 호출 하고 반환 된 메뉴를 확장하십시오.</target>
        </trans-unit>
        <trans-unit id="414a4b42e3e1fdf1f4fbba5afc1d7f27ca70c7d1" translate="yes" xml:space="preserve">
          <source>If you do not want to include all data contained in the model, or the autogenerated rows and columns are not ordered as you wish, you can specify which rows and columns should be included and in which order by defining an explicit list of categories for either or both of rows and columns.</source>
          <target state="translated">모델에 포함 된 모든 데이터를 포함하지 않으려는 경우 또는 자동 생성 된 행 및 열이 원하는 순서대로 정렬되지 않은 경우 다음 중 하나에 대한 명시 적 범주 목록을 정의하여 포함해야하는 행 및 열과 순서를 지정할 수 있습니다. 또는 행과 열 모두.</target>
        </trans-unit>
        <trans-unit id="057684615c560d24fa3d7850ba2b1690d752365f" translate="yes" xml:space="preserve">
          <source>If you do not want to provide plugins for your accessibility interfaces, you can use an interface factory (&lt;a href=&quot;qaccessible#InterfaceFactory-typedef&quot;&gt;QAccessible::InterfaceFactory&lt;/a&gt;), which is the recommended way to provide accessible interfaces in a statically-linked application.</source>
          <target state="translated">내게 필요한 옵션 인터페이스에 플러그인을 제공하지 않으려면 정적으로 링크 된 응용 프로그램에서 액세스 가능한 인터페이스를 제공하는 권장 방법 인 인터페이스 팩토리 ( &lt;a href=&quot;qaccessible#InterfaceFactory-typedef&quot;&gt;QAccessible :: InterfaceFactory&lt;/a&gt; )를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="40d74a535b955d54f4d75584d27c82f8baeb3109" translate="yes" xml:space="preserve">
          <source>If you do not want to use the &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtsql-attribution-sqlite.html#sqlite&quot;&gt;SQLite&lt;/a&gt; library included with Qt, you can pass &lt;code&gt;-system-sqlite&lt;/code&gt; to the configure script to use the &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtsql-attribution-sqlite.html#sqlite&quot;&gt;SQLite&lt;/a&gt; libraries of the operating system. This is recommended whenever possible, as it reduces the installation size and removes one component for which you need to track security advisories.</source>
          <target state="translated">Qt에 포함 된 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtsql-attribution-sqlite.html#sqlite&quot;&gt;SQLite&lt;/a&gt; 라이브러리 를 사용하지 않으려면 운영 체제 의 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtsql-attribution-sqlite.html#sqlite&quot;&gt;SQLite&lt;/a&gt; 라이브러리 를 사용하기 위해 &lt;code&gt;-system-sqlite&lt;/code&gt; 를 구성 스크립트에 전달할 수 있습니다 . 설치 크기를 줄이고 보안 권고를 추적해야하는 하나의 구성 요소를 제거하므로 가능할 때마다 권장됩니다.</target>
        </trans-unit>
        <trans-unit id="b0ac722ef049b33f7fc11c0603adb986e2b05a42" translate="yes" xml:space="preserve">
          <source>If you do not want to use the &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtsql-attribution-sqlite.html#sqlite&quot;&gt;SQLite&lt;/a&gt; library included with Qt, you can pass &lt;code&gt;-system-sqlite&lt;/code&gt; to the configure script to use the &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtsql-attribution-sqlite.html#sqlite&quot;&gt;SQLite&lt;/a&gt; libraries of the operating system. This is recommended whenever possible, as it reduces the installation size and removes one component for which you need to track security advisories.</source>
          <target state="translated">Qt에 포함 된 &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtsql-attribution-sqlite.html#sqlite&quot;&gt;SQLite&lt;/a&gt; 라이브러리 를 사용하지 않으려면 &lt;code&gt;-system-sqlite&lt;/code&gt; 를 configure 스크립트에 전달 하여 운영 체제 의 &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtsql-attribution-sqlite.html#sqlite&quot;&gt;SQLite&lt;/a&gt; 라이브러리 를 사용할 수 있습니다. 설치 크기를 줄이고 보안 권고를 추적해야하는 구성 요소 하나를 제거하므로 가능할 때마다 권장됩니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
