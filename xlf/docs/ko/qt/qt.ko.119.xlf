<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="qt">
    <body>
      <group id="qt">
        <trans-unit id="6366fd344da23b031fea585a5cc134a19e749604" translate="yes" xml:space="preserve">
          <source>If this property is set to &lt;code&gt;false&lt;/code&gt;, the item will no longer receive mouse events, but will continue to receive key events and will retain the keyboard &lt;a href=&quot;qml-qtquick-item#focus-prop&quot;&gt;focus&lt;/a&gt; if it has been set. (In contrast, setting the &lt;a href=&quot;qml-qtquick-item#enabled-prop&quot;&gt;enabled&lt;/a&gt; property to &lt;code&gt;false&lt;/code&gt; stops both mouse and keyboard events, and also removes focus from the item.)</source>
          <target state="translated">이 속성이 &lt;code&gt;false&lt;/code&gt; 로 설정 되면 항목은 더 이상 마우스 이벤트를받지 않지만 키 이벤트를 계속 수신하며 설정된 경우 키보드 &lt;a href=&quot;qml-qtquick-item#focus-prop&quot;&gt;포커스를&lt;/a&gt; 유지합니다 . 반대로 &lt;a href=&quot;qml-qtquick-item#enabled-prop&quot;&gt;enabled&lt;/a&gt; 속성을 &lt;code&gt;false&lt;/code&gt; 로 설정하면 마우스 및 키보드 이벤트가 모두 중지되고 항목에서 포커스가 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="5232a5bf8d71a613191bf6438536119fdf838735" translate="yes" xml:space="preserve">
          <source>If this property is set to &lt;code&gt;false&lt;/code&gt;, the item will no longer receive mouse events, but will continue to receive key events and will retain the keyboard &lt;a href=&quot;qquickitem#focus-prop&quot;&gt;focus&lt;/a&gt; if it has been set. (In contrast, setting the &lt;a href=&quot;qquickitem#enabled-prop&quot;&gt;enabled&lt;/a&gt; property to &lt;code&gt;false&lt;/code&gt; stops both mouse and keyboard events, and also removes focus from the item.)</source>
          <target state="translated">이 속성이 &lt;code&gt;false&lt;/code&gt; 로 설정 되면 항목은 더 이상 마우스 이벤트를받지 않지만 키 이벤트를 계속 수신하며 설정된 경우 키보드 &lt;a href=&quot;qquickitem#focus-prop&quot;&gt;포커스를&lt;/a&gt; 유지합니다 . 반대로 &lt;a href=&quot;qquickitem#enabled-prop&quot;&gt;enabled&lt;/a&gt; 속성을 &lt;code&gt;false&lt;/code&gt; 로 설정하면 마우스 및 키보드 이벤트가 모두 중지되고 항목에서 포커스가 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="66bdcee7e239e418a59113255fddb1898b69364e" translate="yes" xml:space="preserve">
          <source>If this property is set to &lt;code&gt;true&lt;/code&gt;, such errors are ignored. This is useful if you intend to connect to different types of objects, handling a different set of signals for each object.</source>
          <target state="translated">이 특성을 &lt;code&gt;true&lt;/code&gt; 로 설정하면 이러한 오류가 무시됩니다. 이것은 다른 유형의 객체에 연결하여 각 객체에 대해 다른 신호 세트를 처리하려는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="9a40541afc9b72394b30c0cb4f263c787fdd0b37" translate="yes" xml:space="preserve">
          <source>If this property is set to &lt;code&gt;true&lt;/code&gt;, the text cannot be edited by user interaction.</source>
          <target state="translated">이 특성을 &lt;code&gt;true&lt;/code&gt; 로 설정하면 사용자 상호 작용으로 텍스트를 편집 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="81d1dca4364ecf91a97e5af46a5825729958bc5b" translate="yes" xml:space="preserve">
          <source>If this property is set to Text.ElideRight, it can be used with &lt;a href=&quot;qml-qtquick-text#wrapMode-prop&quot;&gt;wrapped&lt;/a&gt; text. The text will only elide if &lt;code&gt;maximumLineCount&lt;/code&gt;, or &lt;code&gt;height&lt;/code&gt; has been set. If both &lt;code&gt;maximumLineCount&lt;/code&gt; and &lt;code&gt;height&lt;/code&gt; are set, &lt;code&gt;maximumLineCount&lt;/code&gt; will apply unless the lines do not fit in the height allowed.</source>
          <target state="translated">이 속성을 Text.ElideRight로 설정하면 줄 &lt;a href=&quot;qml-qtquick-text#wrapMode-prop&quot;&gt;바꿈 된&lt;/a&gt; 텍스트 와 함께 사용할 수 있습니다 . &lt;code&gt;maximumLineCount&lt;/code&gt; 또는 &lt;code&gt;height&lt;/code&gt; 가 설정된 경우에만 텍스트가 제거됩니다 . &lt;code&gt;maximumLineCount&lt;/code&gt; 와 &lt;code&gt;height&lt;/code&gt; 가 모두 설정되어 있으면 선이 허용 된 높이에 맞지 않는 한 &lt;code&gt;maximumLineCount&lt;/code&gt; 가 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="2bc1dd9e563b5d0004881a9c3732ed0db548f760" translate="yes" xml:space="preserve">
          <source>If this property is set to a &lt;a href=&quot;qml-geocircle&quot;&gt;geocircle&lt;/a&gt; its &lt;a href=&quot;qml-geocircle&quot;&gt;radius&lt;/a&gt; property may be left unset, in which case the &lt;a href=&quot;location-places-qml#plugin&quot;&gt;Plugin&lt;/a&gt; will choose an appropriate radius for the search.</source>
          <target state="translated">이 속성은로 설정되어있는 경우 &lt;a href=&quot;qml-geocircle&quot;&gt;geocircle&lt;/a&gt; 의 &lt;a href=&quot;qml-geocircle&quot;&gt;반경&lt;/a&gt; 이 경우 속성이 설정되지 않은 남아있을 수 있습니다, &lt;a href=&quot;location-places-qml#plugin&quot;&gt;플러그인&lt;/a&gt; 검색에 대한 적절한 반경을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="cd8444bbc126a20a30c8fbf7f7c40dfb4bd970dc" translate="yes" xml:space="preserve">
          <source>If this property is set to a positive value, the &lt;a href=&quot;qcombobox#minimumSizeHint&quot;&gt;minimumSizeHint&lt;/a&gt;() and &lt;a href=&quot;qcombobox#sizeHint&quot;&gt;sizeHint&lt;/a&gt;() take it into account.</source>
          <target state="translated">이 속성을 양수 값으로 설정하면 &lt;a href=&quot;qcombobox#minimumSizeHint&quot;&gt;minimumSizeHint&lt;/a&gt; () 및 &lt;a href=&quot;qcombobox#sizeHint&quot;&gt;sizeHint&lt;/a&gt; () 가이 를 고려합니다.</target>
        </trans-unit>
        <trans-unit id="5073e1a3a91e8f12240a132738f629a8c5bc6b8e" translate="yes" xml:space="preserve">
          <source>If this property is set to a string with more than one character, the first character is used. If the string is empty, the value is ignored and the property is not set.</source>
          <target state="translated">이 특성이 둘 이상의 문자가있는 문자열로 설정되면 첫 번째 문자가 사용됩니다. 문자열이 비어 있으면 값이 무시되고 속성이 설정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="24519db9032f311679b8872a0437d577a4382eff" translate="yes" xml:space="preserve">
          <source>If this property is set to a value other than &lt;a href=&quot;q3dscene#invalidSelectionPoint&quot;&gt;invalidSelectionPoint&lt;/a&gt;(), the graph tries to match a graph position to the specified coordinates within the primary viewport. After the rendering pass, this property is returned to its default state of &lt;a href=&quot;q3dscene#invalidSelectionPoint&quot;&gt;invalidSelectionPoint&lt;/a&gt;(). The queried graph position can be read from the &lt;a href=&quot;qabstract3dgraph#queriedGraphPosition-prop&quot;&gt;QAbstract3DGraph::queriedGraphPosition&lt;/a&gt; property after the next render pass.</source>
          <target state="translated">이 속성이 &lt;a href=&quot;q3dscene#invalidSelectionPoint&quot;&gt;invalidSelectionPoint&lt;/a&gt; () 이외의 값으로 설정 되면 그래프는 그래프 위치를 기본 뷰포트 내의 지정된 좌표와 일치 시키려고합니다. 렌더링 패스 후이 속성은 기본 상태 인 &lt;a href=&quot;q3dscene#invalidSelectionPoint&quot;&gt;invalidSelectionPoint&lt;/a&gt; () 로 반환됩니다 . 쿼리 된 그래프 위치는 다음 렌더링 패스 후 &lt;a href=&quot;qabstract3dgraph#queriedGraphPosition-prop&quot;&gt;QAbstract3DGraph :: queriedGraphPosition&lt;/a&gt; 속성 에서 읽을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d4819a3283fa793ebdc1cb160b4f5c2c5e9d0641" translate="yes" xml:space="preserve">
          <source>If this property is set to a value other than &lt;a href=&quot;q3dscene#invalidSelectionPoint&quot;&gt;invalidSelectionPoint&lt;/a&gt;(), the graph tries to select a data item, axis label, or a custom item at the specified coordinates within the primary viewport. After the rendering pass, the property is returned to its default state of &lt;a href=&quot;q3dscene#invalidSelectionPoint&quot;&gt;invalidSelectionPoint&lt;/a&gt;().</source>
          <target state="translated">이 속성이 &lt;a href=&quot;q3dscene#invalidSelectionPoint&quot;&gt;invalidSelectionPoint&lt;/a&gt; () 이외의 값으로 설정되어 있으면 그래프는 기본 뷰포트 내의 지정된 좌표에서 데이터 항목, 축 레이블 또는 사용자 지정 항목을 선택하려고합니다. 렌더링 단계가 끝나면 속성이 기본 상태 인 &lt;a href=&quot;q3dscene#invalidSelectionPoint&quot;&gt;invalidSelectionPoint&lt;/a&gt; () 로 돌아갑니다 .</target>
        </trans-unit>
        <trans-unit id="42b19a605fa9c22e528488387800a0ee59e9fa45" translate="yes" xml:space="preserve">
          <source>If this property is set to false (the default), the scroll area honors the size of its widget. Regardless of this property, you can programmatically resize the widget using &lt;a href=&quot;qscrollarea#widget&quot;&gt;widget&lt;/a&gt;()-&amp;gt;&lt;a href=&quot;qwidget#size-prop&quot;&gt;resize&lt;/a&gt;(), and the scroll area will automatically adjust itself to the new size.</source>
          <target state="translated">이 특성을 false (기본값)로 설정하면 스크롤 영역이 해당 위젯의 크기를 따릅니다. 이 속성에 관계없이 &lt;a href=&quot;qscrollarea#widget&quot;&gt;widget&lt;/a&gt; ()-&amp;gt; &lt;a href=&quot;qwidget#size-prop&quot;&gt;resize&lt;/a&gt; ()를 사용하여 프로그래밍 방식으로 위젯 크기를 조정할 수 있으며 스크롤 영역이 자동으로 새 크기로 조정됩니다.</target>
        </trans-unit>
        <trans-unit id="dffe0bf3de65cba72b12a808e508b4b59cd7f02e" translate="yes" xml:space="preserve">
          <source>If this property is set to false, the directory model will allow renaming, copying and deleting of files and directories.</source>
          <target state="translated">이 특성이 false로 설정되면 디렉토리 모델은 파일 및 디렉토리의 이름 바꾸기, 복사 및 삭제를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="73db8d9a3359c83beafc44ef47d13b3f7e9c29e0" translate="yes" xml:space="preserve">
          <source>If this property is set to false, the directory model will make sure that a directory actually containes any files before reporting that it has children. Otherwise the directory model will report that an item has children if the item is a directory.</source>
          <target state="translated">이 특성이 false로 설정되면 디렉토리 모델은 디렉토리에 하위 파일이 있음을보고하기 전에 디렉토리에 실제로 파일이 포함되어 있는지 확인합니다. 그렇지 않으면 디렉토리 모델은 항목이 디렉토리 인 경우 항목에 하위 항목이 있다고보고합니다.</target>
        </trans-unit>
        <trans-unit id="b902cb4a8201d02db6d9d70ded5ab6faf1e5a5c5" translate="yes" xml:space="preserve">
          <source>If this property is set to true (the default), the &lt;a href=&quot;qabstractitemview&quot;&gt;QAbstractItemView&lt;/a&gt; automatically scrolls the contents of the view if the user drags within 16 pixels of the viewport edge. If the current item changes, then the view will scroll automatically to ensure that the current item is fully visible.</source>
          <target state="translated">이 속성을 true로 설정하면 (기본값) &lt;a href=&quot;qabstractitemview&quot;&gt;QAbstractItemView&lt;/a&gt; 는 사용자가 뷰포트 가장자리의 16 픽셀 내에서 드래그하면 뷰의 내용을 자동으로 스크롤합니다. 현재 항목이 변경되면보기가 자동으로 스크롤되어 현재 항목이 완전히 표시되도록합니다.</target>
        </trans-unit>
        <trans-unit id="77e17ab9cb69247e19e78243865c4f4566d7e5e0" translate="yes" xml:space="preserve">
          <source>If this property is set to true then the push button is an auto default button.</source>
          <target state="translated">이 속성이 true로 설정되면 푸시 버튼이 자동 기본 버튼입니다.</target>
        </trans-unit>
        <trans-unit id="bd4d7e8be29dc04fe8fcc195fc1d9f928771996c" translate="yes" xml:space="preserve">
          <source>If this property is set to true, the layout will use design metrics. Otherwise, the metrics of the paint device as set on &lt;a href=&quot;qabstracttextdocumentlayout#setPaintDevice&quot;&gt;QAbstractTextDocumentLayout::setPaintDevice&lt;/a&gt;() will be used.</source>
          <target state="translated">이 속성이 true로 설정되면 레이아웃은 디자인 메트릭을 사용합니다. 그렇지 않으면 &lt;a href=&quot;qabstracttextdocumentlayout#setPaintDevice&quot;&gt;QAbstractTextDocumentLayout :: setPaintDevice&lt;/a&gt; () 에 설정된 페인트 장치의 메트릭 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="03637033cd890d8ee0857569835f921d8c015e6e" translate="yes" xml:space="preserve">
          <source>If this property is set to true, the scroll area will automatically resize the widget in order to avoid scroll bars where they can be avoided, or to take advantage of extra space.</source>
          <target state="translated">이 속성을 true로 설정하면 스크롤 영역을 피할 수있는 스크롤 막대를 피하거나 추가 공간을 활용하기 위해 스크롤 영역이 위젯의 ​​크기를 자동으로 조정합니다.</target>
        </trans-unit>
        <trans-unit id="e85d5238f3aa170516f706f46ee54ee289390e68" translate="yes" xml:space="preserve">
          <source>If this property is set to true, then when the mouse or touchpoint moves far enough to begin dragging the content, the content will jump, such that the content pixel which was under the cursor or touchpoint when pressed remains under that point.</source>
          <target state="translated">이 속성을 true로 설정하면 마우스 나 터치 포인트가 내용 드래그를 시작하기에 충분히 멀어 질 때 커서 나 터치 포인트 아래에있는 내용 픽셀이 해당 지점 아래에 있도록 내용이 이동합니다.</target>
        </trans-unit>
        <trans-unit id="b6c31bd5baa06d8885b24ef5e66ab710bfe11bdd" translate="yes" xml:space="preserve">
          <source>If this property is set, it will require the given keyboard modifiers to be pressed in order to react to pointer events, and otherwise ignore them.</source>
          <target state="translated">이 속성이 설정되면 포인터 이벤트에 반응하고 그렇지 않으면 무시하기 위해 주어진 키보드 수정자를 눌러야합니다.</target>
        </trans-unit>
        <trans-unit id="25fe5ac4eb56116ee6ca70945d9be5b3239a3f40" translate="yes" xml:space="preserve">
          <source>If this property is true (the default value), the highlight is moved smoothly to follow the current item. Otherwise, the highlight is not moved by the view, and any movement must be implemented by the highlight.</source>
          <target state="translated">이 속성이 true (기본값)이면 강조 표시가 부드럽게 이동하여 현재 항목을 따릅니다. 그렇지 않으면, 강조 표시가 뷰에 의해 이동되지 않으며 강조 표시로 이동을 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="bf95bb03f5821fcf12dd4d7d6ad98fea00a68180" translate="yes" xml:space="preserve">
          <source>If this property is true, all modes previously added are replaced by a mode that matches window size and screen refresh rate.</source>
          <target state="translated">이 속성이 true이면 이전에 추가 된 모든 모드가 창 크기 및 화면 새로 고침 빈도와 일치하는 모드로 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="7b2733c56d01fa4157e4f403f2b95d130cfc23e0" translate="yes" xml:space="preserve">
          <source>If this property is true, mipmaps are generated for the texture.</source>
          <target state="translated">이 속성이 true이면 텍스처에 대한 밉맵이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="89447fa2e019d30a0cde9a6f6c2bc28f70765698" translate="yes" xml:space="preserve">
          <source>If this property is true, the &lt;a href=&quot;qml-qtquick-shadereffectsource#sourceItem-prop&quot;&gt;sourceItem&lt;/a&gt; is hidden, though it will still be rendered into the texture. As opposed to hiding the &lt;a href=&quot;qml-qtquick-shadereffectsource#sourceItem-prop&quot;&gt;sourceItem&lt;/a&gt; by setting &lt;a href=&quot;qml-qtquick-item#visible-prop&quot;&gt;visible&lt;/a&gt; to false, setting this property to true will not prevent mouse or keyboard input from reaching &lt;a href=&quot;qml-qtquick-shadereffectsource#sourceItem-prop&quot;&gt;sourceItem&lt;/a&gt;. The property is useful when the &lt;a href=&quot;qml-qtquick-shadereffectsource&quot;&gt;ShaderEffectSource&lt;/a&gt; is anchored on top of, and meant to replace the &lt;a href=&quot;qml-qtquick-shadereffectsource#sourceItem-prop&quot;&gt;sourceItem&lt;/a&gt;.</source>
          <target state="translated">이 속성이 true이면 &lt;a href=&quot;qml-qtquick-shadereffectsource#sourceItem-prop&quot;&gt;sourceItem&lt;/a&gt; 은 숨겨 지지만 여전히 텍스처에 렌더링됩니다. &lt;a href=&quot;qml-qtquick-item#visible-prop&quot;&gt;visible&lt;/a&gt; 을 false 로 설정 하여 &lt;a href=&quot;qml-qtquick-shadereffectsource#sourceItem-prop&quot;&gt;sourceItem&lt;/a&gt; 을 숨기는 대신 이 속성을 true로 설정하면 마우스 또는 키보드 입력이 &lt;a href=&quot;qml-qtquick-shadereffectsource#sourceItem-prop&quot;&gt;sourceItem&lt;/a&gt; 에 도달하지 못하게 됩니다. 이 속성은 &lt;a href=&quot;qml-qtquick-shadereffectsource&quot;&gt;ShaderEffectSource&lt;/a&gt; 가 맨 위에 고정되어 &lt;a href=&quot;qml-qtquick-shadereffectsource#sourceItem-prop&quot;&gt;sourceItem&lt;/a&gt; 을 대체 할 때 유용 합니다.</target>
        </trans-unit>
        <trans-unit id="e89a18c8e26d330e01784117924442056151df7c" translate="yes" xml:space="preserve">
          <source>If this property is true, the group box displays its title using a checkbox in place of an ordinary label. If the checkbox is checked, the group box's children are enabled; otherwise, they are disabled and inaccessible.</source>
          <target state="translated">이 속성이 true 인 경우 그룹 상자는 일반 레이블 대신 확인란을 사용하여 제목을 표시합니다. 확인란을 선택하면 그룹 상자의 자식이 활성화됩니다. 그렇지 않으면 비활성화되어 액세스 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3ffa897652f13df657629066b7c43e9a90efd919" translate="yes" xml:space="preserve">
          <source>If this property is true, the input language is only changed between the languages providing custom layout.</source>
          <target state="translated">이 속성이 true 인 경우 입력 언어는 사용자 정의 레이아웃을 제공하는 언어 사이에서만 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="dd815bf468ce6a60d7025c43eb015d99838d9f25" translate="yes" xml:space="preserve">
          <source>If this property is true, the output from the &lt;a href=&quot;qml-qtquick-shadereffect#fragmentShader-prop&quot;&gt;fragmentShader&lt;/a&gt; is blended with the background using source-over blend mode. If false, the background is disregarded. Blending decreases the performance, so you should set this property to false when blending is not needed. The default value is true.</source>
          <target state="translated">이 속성이 true 인 경우 &lt;a href=&quot;qml-qtquick-shadereffect#fragmentShader-prop&quot;&gt;fragmentShader&lt;/a&gt; 의 출력은 소스 오버 블렌드 모드를 사용하여 배경과 블렌딩됩니다. False이면 배경이 무시됩니다. 혼합하면 성능이 저하되므로 혼합이 필요하지 않은 경우이 속성을 false로 설정해야합니다. 기본값은 true입니다.</target>
        </trans-unit>
        <trans-unit id="087dbab36012dedcc9fda210a6cdb2a5d231a6a1" translate="yes" xml:space="preserve">
          <source>If this property is true, the texture is updated whenever the &lt;a href=&quot;qml-qtquick-shadereffectsource#sourceItem-prop&quot;&gt;sourceItem&lt;/a&gt; updates. Otherwise, it will be a frozen image, even if &lt;a href=&quot;qml-qtquick-shadereffectsource#sourceItem-prop&quot;&gt;sourceItem&lt;/a&gt; is assigned a new item. The property is true by default.</source>
          <target state="translated">이 속성이 true이면 &lt;a href=&quot;qml-qtquick-shadereffectsource#sourceItem-prop&quot;&gt;sourceItem&lt;/a&gt; 이 업데이트 될 때마다 텍스처가 업데이트 됩니다. 그렇지 않으면 &lt;a href=&quot;qml-qtquick-shadereffectsource#sourceItem-prop&quot;&gt;sourceItem&lt;/a&gt; 에 새 항목이 할당 된 경우에도 정지 된 이미지 가됩니다. 이 속성은 기본적으로 true입니다.</target>
        </trans-unit>
        <trans-unit id="7f8916f4a9cec10b1dcff7b2a3cd3d66cb3a8470" translate="yes" xml:space="preserve">
          <source>If this property isn't explicitly set, this property defaults to the lowest page ID in this wizard, or -1 if no page has been inserted yet.</source>
          <target state="translated">이 속성이 명시 적으로 설정되어 있지 않으면이 속성의 기본값은이 마법사에서 가장 낮은 페이지 ID이거나, 아직 페이지가 삽입되지 않은 경우 -1입니다.</target>
        </trans-unit>
        <trans-unit id="5201e8ead5ff6d46b87bf4737671f6e806f5d6ab" translate="yes" xml:space="preserve">
          <source>If this property value is &lt;code&gt;true&lt;/code&gt;, &lt;a href=&quot;qcustom3dvolume#alphaMultiplier-prop&quot;&gt;alphaMultiplier&lt;/a&gt; is only applied to texels that already have some transparency. If it is &lt;code&gt;false&lt;/code&gt;, the multiplier is applied to the alpha value of all texels. Defaults to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">이 속성 값이 &lt;code&gt;true&lt;/code&gt; 인 경우 &lt;a href=&quot;qcustom3dvolume#alphaMultiplier-prop&quot;&gt;alphaMultiplier&lt;/a&gt; 는 이미 일부 투명도가있는 텍셀에만 적용됩니다. 이 경우 &lt;code&gt;false&lt;/code&gt; , 승산기 모든 텍셀의 알파 값이 적용된다. 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6fc259e5e43ffbe64eb36d15782f9675d43f45df" translate="yes" xml:space="preserve">
          <source>If this property value is &lt;code&gt;true&lt;/code&gt;, &lt;a href=&quot;qml-qtdatavisualization-custom3dvolume#alphaMultiplier-prop&quot;&gt;alphaMultiplier&lt;/a&gt; is only applied to texels that already have some transparency. If it is &lt;code&gt;false&lt;/code&gt;, the multiplier is applied to the alpha value of all texels. Defaults to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">이 속성 값이 &lt;code&gt;true&lt;/code&gt; 인 경우 &lt;a href=&quot;qml-qtdatavisualization-custom3dvolume#alphaMultiplier-prop&quot;&gt;alphaMultiplier&lt;/a&gt; 는 이미 일부 투명도가있는 텍셀에만 적용됩니다. 이 경우 &lt;code&gt;false&lt;/code&gt; , 승산기 모든 텍셀의 알파 값이 적용된다. 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6dbfc4991bf3c40a30965d0be67022d20d746264" translate="yes" xml:space="preserve">
          <source>If this property value is &lt;code&gt;true&lt;/code&gt;, a high definition shader is used to render the volume. If it is &lt;code&gt;false&lt;/code&gt;, a low definition shader is used.</source>
          <target state="translated">이 속성 값이 &lt;code&gt;true&lt;/code&gt; 인 경우 고화질 셰이더를 사용하여 볼륨을 렌더링합니다. 이 경우 &lt;code&gt;false&lt;/code&gt; , 낮은 정의 쉐이더가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0535fc8be4ff3e7ee689d37203fda50da5c481f5" translate="yes" xml:space="preserve">
          <source>If this property value is &lt;code&gt;true&lt;/code&gt;, a high definition shader is used. If it is &lt;code&gt;false&lt;/code&gt;, a low definition shader is used.</source>
          <target state="translated">이 속성 값이 &lt;code&gt;true&lt;/code&gt; 인 경우 고화질 셰이더가 사용됩니다. 이 경우 &lt;code&gt;false&lt;/code&gt; , 낮은 정의 쉐이더가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="154021c467523c3ca86789d97f5f9291d5be2648" translate="yes" xml:space="preserve">
          <source>If this property value is &lt;code&gt;true&lt;/code&gt;, the frames of slices indicated by slice index properties will be drawn around the volume. If it is &lt;code&gt;false&lt;/code&gt;, no slice frames will be drawn.</source>
          <target state="translated">이 속성 값이 &lt;code&gt;true&lt;/code&gt; 인 경우 슬라이스 인덱스 속성으로 표시되는 슬라이스 프레임이 볼륨 주위에 그려집니다. 이 경우 &lt;code&gt;false&lt;/code&gt; , 더 슬라이스 프레임이 그려되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4b3638960eac959f8c4c52e78f407f5b0a5e50f2" translate="yes" xml:space="preserve">
          <source>If this property value is &lt;code&gt;true&lt;/code&gt;, the frames of slices indicated by slice index properties will be drawn around the volume. If it is &lt;code&gt;false&lt;/code&gt;, no slice frames will be drawn. Drawing slice frames is independent of drawing slices, so you can show the full volume and still draw the slice frames around it. Defaults to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">이 속성 값이 &lt;code&gt;true&lt;/code&gt; 인 경우 슬라이스 인덱스 속성으로 표시되는 슬라이스 프레임이 볼륨 주위에 그려집니다. 이 경우 &lt;code&gt;false&lt;/code&gt; , 더 슬라이스 프레임이 그려되지 않습니다. 도면 슬라이스 프레임은 도면 슬라이스와 무관하므로 전체 볼륨을 표시하고 그 주위에 슬라이스 프레임을 그릴 수 있습니다. 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="de0a025be717c756c002f1c5819353a5b1b6b769" translate="yes" xml:space="preserve">
          <source>If this property value is &lt;code&gt;true&lt;/code&gt;, the slices indicated by slice index properties will be drawn instead of the full volume. If it is &lt;code&gt;false&lt;/code&gt;, the full volume will always be drawn. Defaults to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">이 속성 값이 &lt;code&gt;true&lt;/code&gt; 인 경우 슬라이스 인덱스 속성으로 표시된 슬라이스는 전체 볼륨 대신 그려집니다. &lt;code&gt;false&lt;/code&gt; 인 경우 항상 전체 볼륨이 그려집니다. 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8a080765111764977c8ae9223ac764cb884d1aa9" translate="yes" xml:space="preserve">
          <source>If this property value is set to &lt;code&gt;true&lt;/code&gt;, the parent axis sub-segment count is ignored when calculating sub-grid line positions. The sub-grid positions are generated automatically according to the &lt;a href=&quot;qlogvalue3daxisformatter#base-prop&quot;&gt;base&lt;/a&gt; property value. The number of sub-grid lines is set to the base value minus one, rounded down. This property is ignored when the base value is zero. Defaults to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">이 특성 값을 &lt;code&gt;true&lt;/code&gt; 로 설정하면 하위 그리드 선 위치를 계산할 때 상위 축 하위 세그먼트 수가 무시됩니다. 하위 표 위치는 &lt;a href=&quot;qlogvalue3daxisformatter#base-prop&quot;&gt;기본&lt;/a&gt; 속성 값 에 따라 자동으로 생성됩니다 . 서브 그리드 라인의 수는 반올림 한 기본 값에서 1을 뺀 값으로 설정됩니다. 기본 값이 0이면이 속성이 무시됩니다. 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="099b07f85765cd016c077eadb3bacd9ff0df9676" translate="yes" xml:space="preserve">
          <source>If this property value is set to &lt;code&gt;true&lt;/code&gt;, the parent axis sub-segment count is ignored when calculating sub-grid line positions. The sub-grid positions are generated automatically according to the &lt;a href=&quot;qml-qtdatavisualization-logvalueaxis3dformatter#base-prop&quot;&gt;base&lt;/a&gt; property value. The number of sub-grid lines is set to the base value minus one, rounded down. This property is ignored when the base value is zero. Defaults to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">이 특성 값을 &lt;code&gt;true&lt;/code&gt; 로 설정하면 하위 그리드 선 위치를 계산할 때 상위 축 하위 세그먼트 수가 무시됩니다. 하위 표 위치는 &lt;a href=&quot;qml-qtdatavisualization-logvalueaxis3dformatter#base-prop&quot;&gt;기본&lt;/a&gt; 속성 값 에 따라 자동으로 생성됩니다 . 서브 그리드 라인의 수는 반올림 한 기본 값에서 1을 뺀 값으로 설정됩니다. 기본 값이 0이면이 속성이 무시됩니다. 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="20822bb1322d8d5d555634ab7bd0e780d999181e" translate="yes" xml:space="preserve">
          <source>If this quaternion is null, then a null quaternion is returned. If the length of the quaternion is very close to 1, then the quaternion will be returned as-is. Otherwise the normalized form of the quaternion of length 1 will be returned.</source>
          <target state="translated">이 쿼터니언이 널이면 널 쿼터니언이 리턴됩니다. 쿼터니언의 길이가 1에 매우 가까운 경우 쿼터니언은 그대로 반환됩니다. 그렇지 않으면 길이가 1 인 쿼터니언의 정규화 된 형식이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="35a24e099253b5a88e67f643863078439300a407" translate="yes" xml:space="preserve">
          <source>If this query &lt;a href=&quot;qxmlquery#isValid&quot;&gt;is invalid&lt;/a&gt;, &lt;code&gt;false&lt;/code&gt; is returned and the behavior is undefined. If</source>
          <target state="translated">이 쿼리는 경우 &lt;a href=&quot;qxmlquery#isValid&quot;&gt;무효&lt;/a&gt; , &lt;code&gt;false&lt;/code&gt; 반환되고, 동작은 정의되지 않는다. 만약</target>
        </trans-unit>
        <trans-unit id="e5c1dc074e2b5cf55ce9fa79c5c23d3d373abae7" translate="yes" xml:space="preserve">
          <source>If this role is not defined, &lt;a href=&quot;qitemmodelsurfacedataproxy#columnRole-prop&quot;&gt;columnRole&lt;/a&gt; is used to determine the X-coordinate value of the resolved &lt;a href=&quot;qsurfacedataitem&quot;&gt;QSurfaceDataItem&lt;/a&gt; objects.</source>
          <target state="translated">이 역할이 정의되지 않은 경우 &lt;a href=&quot;qitemmodelsurfacedataproxy#columnRole-prop&quot;&gt;columnRole&lt;/a&gt; 은 해석 된 &lt;a href=&quot;qsurfacedataitem&quot;&gt;QSurfaceDataItem&lt;/a&gt; 오브젝트 의 X 좌표 값을 판별하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="ff74e676e7544e509b5582d354341c399728fce4" translate="yes" xml:space="preserve">
          <source>If this role is not defined, &lt;a href=&quot;qitemmodelsurfacedataproxy#rowRole-prop&quot;&gt;rowRole&lt;/a&gt; is used to determine the Z-coordinate value of resolved &lt;a href=&quot;qsurfacedataitem&quot;&gt;QSurfaceDataItem&lt;/a&gt; objects.</source>
          <target state="translated">이 역할이 정의되지 않은 경우 &lt;a href=&quot;qitemmodelsurfacedataproxy#rowRole-prop&quot;&gt;rowRole&lt;/a&gt; 을 사용하여 해결 된 &lt;a href=&quot;qsurfacedataitem&quot;&gt;QSurfaceDataItem&lt;/a&gt; 객체 의 Z 좌표 값을 결정 합니다.</target>
        </trans-unit>
        <trans-unit id="04bbf11a73aed0531f71d0c57ea7e9e4c1a965a3" translate="yes" xml:space="preserve">
          <source>If this routing manager supports returning addresses and instructions in different languages, they will be returned in the language of</source>
          <target state="translated">이 라우팅 관리자가 다른 언어로 주소 및 명령어 반환을 지원하는 경우 해당 언어로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="438d6327741e081d67b307e3db8df1c170b54cae" translate="yes" xml:space="preserve">
          <source>If this semaphore releaser had the responsibility to call some &lt;a href=&quot;qsemaphore#release&quot;&gt;QSemaphore::release&lt;/a&gt;() itself, it performs the call before taking over from</source>
          <target state="translated">이 세마포어 &lt;a href=&quot;qsemaphore#release&quot;&gt;릴리스가 QSemaphore :: release&lt;/a&gt; () 자체 를 호출 할 책임이있는 경우,이 세마포어 릴리스 가</target>
        </trans-unit>
        <trans-unit id="76f8e89e49be027007923c5da18f2ac36b55048a" translate="yes" xml:space="preserve">
          <source>If this series is added to a graph, the graph can adjust the selection according to user interaction or if it becomes invalid. Selecting a bar on another added series will also clear the selection.</source>
          <target state="translated">이 계열이 그래프에 추가되면 그래프는 사용자 상호 작용에 따라 또는 유효하지 않은 경우 선택을 조정할 수 있습니다. 추가 된 다른 시리즈에서 막대를 선택하면 선택이 취소됩니다.</target>
        </trans-unit>
        <trans-unit id="dac5211fea0cb72bd6621ff926124b6ba8d2f0d0" translate="yes" xml:space="preserve">
          <source>If this server is using &lt;a href=&quot;qnetworkproxy&quot;&gt;QNetworkProxy&lt;/a&gt; then the</source>
          <target state="translated">이 서버가 &lt;a href=&quot;qnetworkproxy&quot;&gt;QNetworkProxy&lt;/a&gt; 를 사용 중인 경우</target>
        </trans-unit>
        <trans-unit id="f5d8c50648a0b644233d60c7ba35bbb736326e83" translate="yes" xml:space="preserve">
          <source>If this setting is changed while a sound effect is playing it will only take effect when the sound effect has stopped playing.</source>
          <target state="translated">음향 효과가 재생되는 동안이 설정을 변경하면 음향 효과 재생이 중지 된 경우에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="e16bb50fe73b95cd7e166915a565003f6568c417" translate="yes" xml:space="preserve">
          <source>If this signal is not handled, the requested load will fail.</source>
          <target state="translated">이 신호를 처리하지 않으면 요청 된로드가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="fef3fff95a20a7e18389569e5f35c67c5dbfb14c" translate="yes" xml:space="preserve">
          <source>If this string contains any characters that cannot be encoded in the locale, the returned byte array is undefined. Those characters may be suppressed or replaced by another.</source>
          <target state="translated">이 문자열에 로캘로 인코딩 할 수없는 문자가 포함되어 있으면 반환 된 바이트 배열이 정의되지 않은 것입니다. 이러한 문자는 억제되거나 다른 문자로 대체 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d94bc2ada40f1077e7ae7e64b7e5c22d1bd6355f" translate="yes" xml:space="preserve">
          <source>If this true the animation will complete its current iteration when it is stopped - either by setting the &lt;code&gt;running&lt;/code&gt; property to false, or by calling the &lt;code&gt;stop()&lt;/code&gt; method. The &lt;code&gt;complete()&lt;/code&gt; method is not effected by this value.</source>
          <target state="translated">이 속성 이 true이면 애니메이션이 중지 될 때 현재 반복을 완료합니다. &lt;code&gt;running&lt;/code&gt; 속성을 false 로 설정 하거나 &lt;code&gt;stop()&lt;/code&gt; 메서드를 호출합니다 . &lt;code&gt;complete()&lt;/code&gt; 메소드는이 값에 의해 수행되지 않는다.</target>
        </trans-unit>
        <trans-unit id="1eb0f67e00d17b82f6530359a63f2aeaaad3a7b3" translate="yes" xml:space="preserve">
          <source>If this value is greater than zero, the view may keep as many delegates instantiated as it can fit within the buffer specified. For example, if in a vertical view the delegate is 20 pixels high and &lt;code&gt;cacheBuffer&lt;/code&gt; is set to 40, then up to 2 delegates above and 2 delegates below the visible area may be created/retained. The buffered delegates are created asynchronously, allowing creation to occur across multiple frames and reducing the likelihood of skipping frames. In order to improve painting performance delegates outside the visible area are not painted.</source>
          <target state="translated">이 값이 0보다 큰 경우, 뷰는 지정된 버퍼 내에 들어갈 수있는만큼 많은 델리게이트를 인스턴스화 할 수 있습니다. 예를 들어 세로보기에서 델리게이트의 높이가 20 픽셀이고 &lt;code&gt;cacheBuffer&lt;/code&gt; 가 40으로 설정된 경우 표시 영역 아래에서 최대 2 개의 델리게이트 및 2 개의 델리게이트가 작성 / 보존 될 수 있습니다. 버퍼 된 델리게이트는 비동기 적으로 생성되므로 여러 프레임에서 생성이 가능하며 프레임을 건너 뛸 가능성이 줄어 듭니다. 페인팅 성능을 향상시키기 위해 표시 영역 외부의 델리게이트는 페인트되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d7ad9ed01be513c9164d477bfd55038c8472be79" translate="yes" xml:space="preserve">
          <source>If this value is greater than zero, the view may keep as many delegates instantiated as will fit within the buffer specified. For example, if in a vertical view the delegate is 20 pixels high, there are 3 columns and &lt;code&gt;cacheBuffer&lt;/code&gt; is set to 40, then up to 6 delegates above and 6 delegates below the visible area may be created/retained. The buffered delegates are created asynchronously, allowing creation to occur across multiple frames and reducing the likelihood of skipping frames. In order to improve painting performance delegates outside the visible area are not painted.</source>
          <target state="translated">이 값이 0보다 큰 경우, 뷰는 지정된 버퍼 내에 맞는만큼 많은 델리게이트를 인스턴스화 할 수 있습니다. 예를 들어 세로보기에서 델리게이트의 높이가 20 픽셀 인 경우 3 개의 열이 있고 &lt;code&gt;cacheBuffer&lt;/code&gt; 가 40으로 설정된 경우 최대 6 개의 델리게이트 및 가시 영역 아래의 6 개의 델리게이트가 작성 / 보존 될 수 있습니다. 버퍼 된 델리게이트는 비동기 적으로 생성되므로 여러 프레임에서 생성이 가능하며 프레임을 건너 뛸 가능성이 줄어 듭니다. 페인팅 성능을 향상시키기 위해 표시 영역 외부의 델리게이트는 페인트되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="127580f6f41b51546fd3bc5efae2ed614120c7f5" translate="yes" xml:space="preserve">
          <source>If this value is non-zero, the view will create extra delegates before the start of the view, or after the end. The view will create as many delegates as it can fit into the pixel size specified.</source>
          <target state="translated">이 값이 0이 아닌 경우, 뷰는 뷰 시작 전 또는 종료 후에 추가 대리자를 만듭니다. 뷰는 지정된 픽셀 크기에 맞는 수의 델리게이트를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="770b381afabf568da75de06a5ce23788975f7ca4" translate="yes" xml:space="preserve">
          <source>If this value is non-zero, then any movement of the emitter will provide additional starting velocity to the particles based on the movement. The additional vector will be the same angle as the emitter's movement, with a magnitude that is the magnitude of the emitters movement multiplied by velocityFromMovement.</source>
          <target state="translated">이 값이 0이 아닌 경우, 이미 터의 움직임은 움직임에 따라 입자에 추가 시작 속도를 제공합니다. 추가 벡터는 이미 터의 움직임과 같은 각도이며 이미 터의 움직임 크기에 velocityFromMovement를 곱한 크기입니다.</target>
        </trans-unit>
        <trans-unit id="7135c234f8bcce211d310450397ae0ceb229509e" translate="yes" xml:space="preserve">
          <source>If this value is not specified, it defaults to the value that depends on the native style.</source>
          <target state="translated">이 값을 지정하지 않으면 기본 스타일에 따라 달라집니다.</target>
        </trans-unit>
        <trans-unit id="5cdf10f3a25ac04653570c9a405850ab7e1b2aa5" translate="yes" xml:space="preserve">
          <source>If this value is set when the emitter is loaded, then it will emit particles from the past, up to startTime milliseconds ago. These will simulate as if they were emitted then, but will not have any affectors applied to them. Affectors will take effect from the present time.</source>
          <target state="translated">이미 터가로드 될 때이 값을 설정하면 과거부터 최대 밀리 초 전까지의 파티클을 방출합니다. 이것들은 마치 마치 방출 된 것처럼 시뮬레이트되지만 적용되는 애펙 터는 없습니다. Affectors는 현재부터 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="25df681494581c983182a0ff7f7c6b3e1dc1fd02" translate="yes" xml:space="preserve">
          <source>If this value to null, the bounding volume of the entity is used. Care must be taken that this bounding volume never becomes invalid.</source>
          <target state="translated">이 값이 null이면 엔터티의 경계 볼륨이 사용됩니다. 이 경계 볼륨이 유효하지 않게주의해야합니다.</target>
        </trans-unit>
        <trans-unit id="00572fcd65ca575d2f655af12f123f101026983f" translate="yes" xml:space="preserve">
          <source>If this value to nullptr, the bounding volume of the entity is used. Care must be taken that this bounding volume never becomes invalid.</source>
          <target state="translated">이 값이 nullptr 인 경우 엔티티의 바운딩 볼륨이 사용됩니다. 이 경계 볼륨이 유효하지 않게주의해야합니다.</target>
        </trans-unit>
        <trans-unit id="1b9ff9f54e32c4c6447460fdd0fe4fc58d670cef" translate="yes" xml:space="preserve">
          <source>If this vector is null, then a null vector is returned. If the length of the vector is very close to 1, then the vector will be returned as-is. Otherwise the normalized form of the vector of length 1 will be returned.</source>
          <target state="translated">이 벡터가 null이면 null 벡터가 반환됩니다. 벡터의 길이가 1에 매우 가까운 경우 벡터는 그대로 반환됩니다. 그렇지 않으면 길이가 1 인 벡터의 정규화 된 형식이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="1af9c981cc60b8e39478122ba9858df9f6f71b20" translate="yes" xml:space="preserve">
          <source>If this view item is checkable, i.e., ViewItemFeature::HasCheckIndicator is true, &lt;code&gt;checkState&lt;/code&gt; is true if the item is checked; otherwise, it is false.</source>
          <target state="translated">이 뷰 항목을 확인할 수있는 경우 (예 : ViewItemFeature :: HasCheckIndicator가 true 인 경우) 항목을 확인하면 &lt;code&gt;checkState&lt;/code&gt; 가 true입니다. 그렇지 않으면 거짓입니다.</target>
        </trans-unit>
        <trans-unit id="8cf301d55d9e51c75f6280fd5a29d08ad107d1fe" translate="yes" xml:space="preserve">
          <source>If this volume was not mounted from a subvolume of a larger filesystem or if the subvolume could not be detected, this function returns an empty byte array.</source>
          <target state="translated">이 볼륨이 더 큰 파일 시스템의 서브 볼륨에서 마운트되지 않았거나 서브 볼륨을 감지 할 수없는 경우이 함수는 빈 바이트 배열을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="ef311f7dc421c384d81389971d02b87b6206c29c" translate="yes" xml:space="preserve">
          <source>If this widget has a layout, the default implementation returns the layout's preferred height. if there is no layout, the default implementation returns -1 indicating that the preferred height does not depend on the width.</source>
          <target state="translated">이 위젯에 레이아웃이있는 경우 기본 구현은 레이아웃의 기본 높이를 반환합니다. 레이아웃이없는 경우 기본 구현은 선호 높이가 너비에 의존하지 않음을 나타내는 -1을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0ffec507a5615d842ae9e35d2f4b30ab9324a37a" translate="yes" xml:space="preserve">
          <source>If this widget is currently managed by a layout, this function notifies the layout that the widget's size hints have changed and the layout may need to resize and reposition the widget accordingly.</source>
          <target state="translated">이 위젯이 현재 레이아웃으로 관리되는 경우이 기능은 위젯의 크기 힌트가 변경되었음을 레이아웃에 알리고 레이아웃은 위젯의 크기를 조정하고 위치를 조정해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="deb9ccc0b5e466e9dd4b4bcd82150cd34b0b1599" translate="yes" xml:space="preserve">
          <source>If this widget, a child or descendant of this widget currently has input focus, this function will return a pointer to that widget. If no descendant widget has input focus, &lt;code&gt;nullptr&lt;/code&gt; is returned.</source>
          <target state="translated">이 위젯,이 위젯의 ​​하위 또는 하위 위젯에 현재 입력 포커스가있는 경우이 함수는 해당 위젯에 대한 포인터를 리턴합니다. 하위 위젯에 입력 포커스가 &lt;code&gt;nullptr&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="ae826ae43c7f7d284672ec7997b3e9d6b7a2d4d0" translate="yes" xml:space="preserve">
          <source>If those requirements are not met one ore more of the following errors are likely to occur:</source>
          <target state="translated">이러한 요구 사항이 충족되지 않으면 다음 오류 중 하나 이상이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="83a8c7ad5f6cb23d01df9dd9eb0c4f8496096c47" translate="yes" xml:space="preserve">
          <source>If thread A and thread B load the variable's old value simultaneously, increment their register, and store it back, they end up overwriting each other, and the variable is incremented only once!</source>
          <target state="translated">스레드 A와 스레드 B가 변수의 이전 값을 동시에로드하고 레지스터를 증가시킨 후 다시 저장하면 서로 덮어 쓰게되고 변수는 한 번만 증가합니다!</target>
        </trans-unit>
        <trans-unit id="69de2038d5c75fedf3b59076c123348b0ac74b70" translate="yes" xml:space="preserve">
          <source>If tracking is enabled (the default), the slider emits the &lt;a href=&quot;qabstractslider#valueChanged&quot;&gt;valueChanged&lt;/a&gt;() signal while the slider is being dragged. If tracking is disabled, the slider emits the &lt;a href=&quot;qabstractslider#valueChanged&quot;&gt;valueChanged&lt;/a&gt;() signal only when the user releases the slider.</source>
          <target state="translated">추적이 활성화 된 경우 (기본값) 슬라이더를 드래그하는 동안 슬라이더가 &lt;a href=&quot;qabstractslider#valueChanged&quot;&gt;valueChanged&lt;/a&gt; () 신호를 방출합니다 . 추적이 비활성화 된 경우 사용자가 슬라이더를 놓을 때만 슬라이더가 &lt;a href=&quot;qabstractslider#valueChanged&quot;&gt;valueChanged&lt;/a&gt; () 신호를 방출합니다.</target>
        </trans-unit>
        <trans-unit id="2fe813bb89eb1f8e684d82a8c590244de14f0457" translate="yes" xml:space="preserve">
          <source>If transformation metadata is not supported by the image format, the transform is applied before writing.</source>
          <target state="translated">이미지 형식에서 변환 메타 데이터를 지원하지 않으면 쓰기 전에 변환이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="87c2eec7ff0fd9a64c44a911b81d33b0c502394b" translate="yes" xml:space="preserve">
          <source>If true the decimal point is drawn between two digit positions. Otherwise it occupies a digit position of its own, i.e. is drawn in a digit position. The default is false.</source>
          <target state="translated">참이면 소수점 두 자리 사이에 그려집니다. 그렇지 않으면 자체 자리 위치를 차지합니다. 즉 자리 위치에 그려집니다. 기본값은 false입니다.</target>
        </trans-unit>
        <trans-unit id="9363d718d389d50aa53a260898f506a5e46192d6" translate="yes" xml:space="preserve">
          <source>If true the text edit shows a cursor.</source>
          <target state="translated">참이면 텍스트 편집에 커서가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="c54421a03a8d84f52502d03221185b6a54bfd5a5" translate="yes" xml:space="preserve">
          <source>If true then &lt;a href=&quot;qtabbar&quot;&gt;QTabBar&lt;/a&gt; draws a base in relation to the styles overlab. Otherwise only the tabs are drawn.</source>
          <target state="translated">true 인 경우 &lt;a href=&quot;qtabbar&quot;&gt;QTabBar&lt;/a&gt; 는 스타일 오버랩과 관련하여 기준을 그립니다. 그렇지 않으면 탭만 그려집니다.</target>
        </trans-unit>
        <trans-unit id="f77ddfdd2a081ae8dd7036dedaf26b2a131a9074" translate="yes" xml:space="preserve">
          <source>If true, affected particles will jump directly to the target group instead of taking the shortest valid path to get there. They will also not finish their current state, but immediately move to the beginning of the goal state.</source>
          <target state="translated">참이면 영향을받는 파티클은 유효한 최단 경로를 사용하는 대신 대상 그룹으로 바로 이동합니다. 또한 현재 상태를 끝내지 않고 즉시 목표 상태의 시작으로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="87ae48f730bdbacb8891acec503553ba883309c0" translate="yes" xml:space="preserve">
          <source>If true, affected sprites will jump directly to the goal state instead of taking the shortest valid path to get there. They will also not finish their current state, but immediately move to the beginning of the goal state.</source>
          <target state="translated">참이면 영향을받는 스프라이트는 유효한 최단 경로를 사용하는 대신 목표 상태로 바로 이동합니다. 또한 현재 상태를 끝내지 않고 즉시 목표 상태의 시작으로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="e14f31c02b5e8161ad6e453e666d875eba466728" translate="yes" xml:space="preserve">
          <source>If true, calling the &lt;a href=&quot;qml-qtmultimedia-audio#seek-method&quot;&gt;seek()&lt;/a&gt; method will cause playback to seek to the new position.</source>
          <target state="translated">true 인 경우 &lt;a href=&quot;qml-qtmultimedia-audio#seek-method&quot;&gt;seek ()&lt;/a&gt; 메서드를 호출 하면 재생이 새로운 위치를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="0e2a44833e164e72e8ed4e671e39489a69ad886b" translate="yes" xml:space="preserve">
          <source>If true, calling the &lt;a href=&quot;qml-qtmultimedia-mediaplayer#seek-method&quot;&gt;seek()&lt;/a&gt; method will cause playback to seek to the new position.</source>
          <target state="translated">true 인 경우 &lt;a href=&quot;qml-qtmultimedia-mediaplayer#seek-method&quot;&gt;seek ()&lt;/a&gt; 메서드를 호출 하면 재생이 새로운 위치를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="6d48c91e05b4b950fbafc2f2f1b9740c12ce5f8b" translate="yes" xml:space="preserve">
          <source>If true, calling the &lt;a href=&quot;qml-qtmultimedia-video#seek-method&quot;&gt;seek()&lt;/a&gt; method will cause playback to seek to the new position.</source>
          <target state="translated">true 인 경우 &lt;a href=&quot;qml-qtmultimedia-video#seek-method&quot;&gt;seek ()&lt;/a&gt; 메서드를 호출 하면 재생이 새로운 위치를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="ea47b3186db45c9a348c54ad710083e01ac72d44" translate="yes" xml:space="preserve">
          <source>If true, directories are included in the model; otherwise only files are included.</source>
          <target state="translated">true 인 경우 디렉토리가 모델에 포함됩니다. 그렇지 않으면 파일 만 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="519f75663f366cd0b741f4bae7a8ee2414a588d9" translate="yes" xml:space="preserve">
          <source>If true, files are included in the model; otherwise only directories are included.</source>
          <target state="translated">참이면 파일이 모델에 포함됩니다. 그렇지 않으면 디렉토리 만 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="07986e8bdf3da1e6c7d93cf9e26fc92364592901" translate="yes" xml:space="preserve">
          <source>If true, hidden files and directories are included in the model; otherwise they are excluded.</source>
          <target state="translated">true 인 경우 숨겨진 파일 및 디렉토리가 모델에 포함됩니다. 그렇지 않으면 제외됩니다.</target>
        </trans-unit>
        <trans-unit id="4066953a40bd0f9690049626bc8d4661eb194a61" translate="yes" xml:space="preserve">
          <source>If true, if directories are included in the model they will always be shown first, then the files.</source>
          <target state="translated">true 인 경우 디렉토리가 모델에 포함 된 경우 항상 디렉토리가 먼저 표시되고 파일이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="77c893993cc6d54289cdf29571b831d58af82641" translate="yes" xml:space="preserve">
          <source>If true, interpolation will occur between sprite frames to make the animation appear smoother.</source>
          <target state="translated">참이면 스프라이트 프레임 사이에 보간이 발생하여 애니메이션이 더 매끄럽게 나타납니다.</target>
        </trans-unit>
        <trans-unit id="9627abef39738f22bb71420356025593d412c45e" translate="yes" xml:space="preserve">
          <source>If true, only readable files and directories are shown; otherwise all files and directories are shown.</source>
          <target state="translated">참이면 읽을 수있는 파일과 디렉토리 만 표시됩니다. 그렇지 않으면 모든 파일과 디렉토리가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="d3c8ed1339e32495bdf91c4a5c8ffc0973812dc3" translate="yes" xml:space="preserve">
          <source>If true, the &quot;.&quot; and &quot;..&quot; directories are included in the model; otherwise they are excluded.</source>
          <target state="translated">true 인 경우 &quot;.&quot; &quot;..&quot;디렉토리가 모델에 포함되어 있습니다. 그렇지 않으면 제외됩니다.</target>
        </trans-unit>
        <trans-unit id="99cef708df110b3efce9af42eb5f128fb1370f6c" translate="yes" xml:space="preserve">
          <source>If true, the action will auto repeat when the keyboard shortcut combination is held down, provided that keyboard auto repeat is enabled on the system. The default value is true.</source>
          <target state="translated">true 인 경우 시스템에서 키보드 자동 반복이 활성화 된 경우 키보드 단축키 조합을 누르고 있으면 작업이 자동 반복됩니다. 기본값은 true입니다.</target>
        </trans-unit>
        <trans-unit id="072e1bfaaef7ac1be9a7d88fde2a8c2e5216a413" translate="yes" xml:space="preserve">
          <source>If true, the item will automatically be faded in and out at the ends of its lifetime. If false, you will have to implement any entry effect yourself.</source>
          <target state="translated">참이면 해당 항목의 수명이 다하면 자동으로 페이드 인 및 페이드 아웃됩니다. False 인 경우 직접 입력 효과를 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="9d0361c07174b2e943b151f6e2a3093d1498a8aa" translate="yes" xml:space="preserve">
          <source>If true, the shortcut will auto repeat when the keyboard shortcut combination is held down, provided that keyboard auto repeat is enabled on the system. The default value is true.</source>
          <target state="translated">true 인 경우 시스템에서 키보드 자동 반복이 활성화 된 경우 키보드 단축키 조합을 누르고 있으면 바로 가기가 자동으로 반복됩니다. 기본값은 true입니다.</target>
        </trans-unit>
        <trans-unit id="c55743c8928e6b2bf356819a6ba89c86403bf66b" translate="yes" xml:space="preserve">
          <source>If true, the tab bar is automatically hidden when it contains less than 2 tabs.</source>
          <target state="translated">true 인 경우 탭이 2 개 미만이면 탭 표시 줄이 자동으로 숨겨집니다.</target>
        </trans-unit>
        <trans-unit id="d1558ec7298db42eff1fc61ae4598cf6b8318137" translate="yes" xml:space="preserve">
          <source>If true, the user can use the keyboard to select text even if the editor is read-only. If false, the user cannot use the keyboard to select text even if the editor is editable.</source>
          <target state="translated">true 인 경우 사용자는 편집기가 읽기 전용 인 경우에도 키보드를 사용하여 텍스트를 선택할 수 있습니다. false 인 경우 편집기를 편집 할 수있는 경우에도 키보드를 사용하여 텍스트를 선택할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="636af586df45cf9846fb475d828a461a230be19e" translate="yes" xml:space="preserve">
          <source>If true, the user can use the mouse to select text in some platform-specific way. Note that for some platforms this may not be an appropriate interaction (it may conflict with how the text needs to behave inside a &lt;a href=&quot;qml-qtquick-flickable&quot;&gt;Flickable&lt;/a&gt;, for example).</source>
          <target state="translated">true 인 경우 사용자는 마우스를 사용하여 플랫폼 별 방식으로 텍스트를 선택할 수 있습니다. 일부 플랫폼의 경우 이는 적절한 상호 작용이 아닐 수 있습니다 (예 : 텍스트가 &lt;a href=&quot;qml-qtquick-flickable&quot;&gt;Flickable&lt;/a&gt; 내부에서 동작해야하는 방식과 충돌 할 수 있음 ).</target>
        </trans-unit>
        <trans-unit id="bc63c69ac9fa5951541e8a4527199b0caefa24e6" translate="yes" xml:space="preserve">
          <source>If true, the user can use the mouse to select text in some platform-specific way. Note that for some platforms this may not be an appropriate interaction; it may conflict with how the text needs to behave inside a Flickable, for example.</source>
          <target state="translated">true 인 경우 사용자는 마우스를 사용하여 플랫폼 별 방식으로 텍스트를 선택할 수 있습니다. 일부 플랫폼의 경우 이는 적절한 상호 작용이 아닐 수 있습니다. 예를 들어 텍스트가 Flickable 내에서 동작해야하는 방식과 충돌 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="08720e1d29cb49edb317c255966ebbaf14f6da0c" translate="yes" xml:space="preserve">
          <source>If true, then the animation will be played in reverse.</source>
          <target state="translated">참이면 애니메이션이 반대로 재생됩니다.</target>
        </trans-unit>
        <trans-unit id="e19fd3950179344f0e0b09195c5972afecc82f56" translate="yes" xml:space="preserve">
          <source>If true, then the animation will have no duration. Instead, the animation will advance one frame each time a frame is rendered to the screen. This synchronizes it with the painting rate as opposed to elapsed time.</source>
          <target state="translated">참이면 애니메이션에 지속 시간이 없습니다. 대신 애니메이션은 프레임이 화면에 렌더링 될 때마다 한 프레임 씩 전진합니다. 이렇게하면 경과 시간이 아닌 페인팅 속도와 동기화됩니다.</target>
        </trans-unit>
        <trans-unit id="b6acc5d1e93dc0a9e040a2a88ed1a56888b811c1" translate="yes" xml:space="preserve">
          <source>If true, then the animation will start its first animation with a random amount of its duration skipped. This allows them to not look like they all just started when the animation begins.</source>
          <target state="translated">true이면 애니메이션이 임의의 지속 시간 길이를 건너 뛰어 첫 번째 애니메이션을 시작합니다. 이를 통해 애니메이션이 시작될 때 모두 시작된 것처럼 보이지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c608cf24035c4df8ec8e6da85ae804f48c24e37" translate="yes" xml:space="preserve">
          <source>If true, then the current tab is automatically changed when dragging over the tabbar.</source>
          <target state="translated">true 인 경우 탭 막대 위로 드래그하면 현재 탭이 자동으로 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="edefc7bc483a0bac748a69c6754b5302eaee2bdc" translate="yes" xml:space="preserve">
          <source>If true, then the value of magnitude and &lt;a href=&quot;qml-qtquick-particles-targetdirection#magnitudeVariation-prop&quot;&gt;magnitudeVariation&lt;/a&gt; shall be interpreted as multiples of the distance between the source point and the target point, per second.</source>
          <target state="translated">참인 경우, 크기 및 &lt;a href=&quot;qml-qtquick-particles-targetdirection#magnitudeVariation-prop&quot;&gt;크기 변화량&lt;/a&gt; 은 초당 소스 포인트와 목표 포인트 사이의 거리의 배수로 해석되어야한다.</target>
        </trans-unit>
        <trans-unit id="bba7e28a5506481feef90cba2ff52c4d5ee57976" translate="yes" xml:space="preserve">
          <source>If true, wrapping is enabled; otherwise some space is inserted at the bottom of the dial to separate the ends of the range of valid values.</source>
          <target state="translated">참이면 줄 바꿈이 활성화됩니다. 그렇지 않으면 유효한 값 범위의 끝을 구분하기 위해 다이얼 하단에 약간의 공간이 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="4f3b55b01365a01150bdd3683f551b3e3b0e852a" translate="yes" xml:space="preserve">
          <source>If truncation occurs any selected text will be unselected, the cursor position is set to 0 and the first part of the string is shown.</source>
          <target state="translated">잘림이 발생하면 선택한 텍스트가 선택 취소되고 커서 위치가 0으로 설정되고 문자열의 첫 부분이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="2b8b91c6eaa2516686ca8c59e69344d174677978" translate="yes" xml:space="preserve">
          <source>If two pixmaps are inserted into the cache using equal keys then the last pixmap will replace the first pixmap in the cache. This follows the behavior of the &lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt; and &lt;a href=&quot;qcache&quot;&gt;QCache&lt;/a&gt; classes.</source>
          <target state="translated">동일한 키를 사용하여 두 개의 픽스맵이 캐시에 삽입되면 마지막 픽스맵은 캐시의 첫 번째 픽스맵을 대체합니다. 이것은 &lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt; 및 &lt;a href=&quot;qcache&quot;&gt;QCache&lt;/a&gt; 클래스 의 동작을 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="4ad83344b3bf3b576b64b6a4417e9818f086ed03" translate="yes" xml:space="preserve">
          <source>If two visible popups have the same z-value, the last one that was opened will be on top.</source>
          <target state="translated">보이는 두 팝업에 동일한 z 값이 있으면 마지막으로 열린 팝업이 맨 위에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="092eee05ab6c42af29cb5a3f9a0b1c6eebb144f5" translate="yes" xml:space="preserve">
          <source>If type is DelimitorTab; tab until this char is found in the text.</source>
          <target state="translated">type이 DelimitorTab 인 경우; 이 문자가 텍스트에 나타날 때까지 탭하십시오.</target>
        </trans-unit>
        <trans-unit id="c14ebe39cde7fb63a7339dcf44b821bc27523b14" translate="yes" xml:space="preserve">
          <source>If undefined or unsupported values are passed to &lt;a href=&quot;qcameraviewfindersettingscontrol2#setViewfinderSettings&quot;&gt;QCameraViewfinderSettingsControl2::setViewfinderSettings&lt;/a&gt;(), this function returns the actual settings used by the camera viewfinder. These may be available only once the camera is active.</source>
          <target state="translated">정의되지 않거나 지원되지 않는 값이 &lt;a href=&quot;qcameraviewfindersettingscontrol2#setViewfinderSettings&quot;&gt;QCameraViewfinderSettingsControl2 :: setViewfinderSettings&lt;/a&gt; ()에 전달 되면이 함수는 카메라 뷰 파인더에서 사용 된 실제 설정을 반환합니다. 카메라가 활성화 된 후에 만 ​​사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="38f2be60a4c75084de2e3377c072fa13a28e8741" translate="yes" xml:space="preserve">
          <source>If unset, Wander will not affect x values.</source>
          <target state="translated">설정하지 않으면 방황은 x 값에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="306c443b24eb59d8ccec79d90ad71463738d2db9" translate="yes" xml:space="preserve">
          <source>If unset, Wander will not affect y values.</source>
          <target state="translated">설정하지 않으면 방황은 y 값에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="82fab8872a62aaba7cd627a5648ce295dae09a7a" translate="yes" xml:space="preserve">
          <source>If unset, or if a null &lt;a href=&quot;qrectf&quot;&gt;QRectF&lt;/a&gt; is set, this property has the same value as &lt;a href=&quot;qgraphicsscene#sceneRect-prop&quot;&gt;QGraphicsScene::sceneRect&lt;/a&gt;, and it changes with &lt;a href=&quot;qgraphicsscene#sceneRect-prop&quot;&gt;QGraphicsScene::sceneRect&lt;/a&gt;. Otherwise, the view's scene rect is unaffected by the scene.</source>
          <target state="translated">설정되지 않은 경우, 널 (null)의 경우, 또는 &lt;a href=&quot;qrectf&quot;&gt;QRectF이&lt;/a&gt; 설정되어 있으며,이 건물은 같은 값이 &lt;a href=&quot;qgraphicsscene#sceneRect-prop&quot;&gt;QGraphicsScene :: sceneRect을&lt;/a&gt; , 그리고에 따라 변화 &lt;a href=&quot;qgraphicsscene#sceneRect-prop&quot;&gt;QGraphicsScene :: sceneRect&lt;/a&gt; . 그렇지 않으면 뷰의 장면 rect는 장면의 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e83f7562da52dff91b9d0216d49cc1d402e1305c" translate="yes" xml:space="preserve">
          <source>If unset, or if set to a null &lt;a href=&quot;qrectf&quot;&gt;QRectF&lt;/a&gt;, sceneRect() will return the largest bounding rect of all items on the scene since the scene was created (i.e., a rectangle that grows when items are added to or moved in the scene, but never shrinks).</source>
          <target state="translated">설정하지 않거나 null &lt;a href=&quot;qrectf&quot;&gt;QRectF로&lt;/a&gt; 설정하면 sceneRect ()는 장면이 생성 된 이후 장면에있는 모든 항목의 가장 큰 경계 사각형을 반환합니다 (즉, 장면에 항목을 추가하거나 이동할 때 커지는 사각형이지만 절대 축소되지 않습니다).</target>
        </trans-unit>
        <trans-unit id="e3e8e1191ccf8bd49afa7c8d764c1aedcfcb386a" translate="yes" xml:space="preserve">
          <source>If unspecified, the system will look for the attribute using the name returned by &lt;a href=&quot;qt3drender-qattribute#defaultPositionAttributeName&quot;&gt;QAttribute::defaultPositionAttributeName&lt;/a&gt;.</source>
          <target state="translated">지정되지 않은 경우 시스템은 &lt;a href=&quot;qt3drender-qattribute#defaultPositionAttributeName&quot;&gt;QAttribute :: defaultPositionAttributeName이&lt;/a&gt; 반환 한 이름을 사용하여 속성을 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="8fb2bc982d0c7c97238ef0f8598493fb4fa741b7" translate="yes" xml:space="preserve">
          <source>If unspecified, the system will look for the attribute using the name returned by QAttribute::defaultPositionAttributeName.</source>
          <target state="translated">지정하지 않으면 시스템은 QAttribute :: defaultPositionAttributeName에 의해 리턴 된 이름을 사용하여 속성을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="1070ad3d1f3f38156973bf7fa335773eb113cb84" translate="yes" xml:space="preserve">
          <source>If using &lt;a href=&quot;qpagesize#SizeMatchPolicy-enum&quot;&gt;FuzzyMatch&lt;/a&gt; then the point size of the &lt;a href=&quot;qpagesize#PageSizeId-enum&quot;&gt;PageSizeId&lt;/a&gt; returned may not exactly match the</source>
          <target state="translated">&lt;a href=&quot;qpagesize#SizeMatchPolicy-enum&quot;&gt;FuzzyMatch&lt;/a&gt; 를 사용하는 경우 반환 된 &lt;a href=&quot;qpagesize#PageSizeId-enum&quot;&gt;PageSizeId&lt;/a&gt; 의 포인트 크기가</target>
        </trans-unit>
        <trans-unit id="73acba8b7996ac864e6a99b35a7604ff8e80a9a7" translate="yes" xml:space="preserve">
          <source>If using &lt;a href=&quot;qpagesize#SizeMatchPolicy-enum&quot;&gt;FuzzyMatch&lt;/a&gt; then the unit size of the &lt;a href=&quot;qpagesize#PageSizeId-enum&quot;&gt;PageSizeId&lt;/a&gt; returned may not exactly match the</source>
          <target state="translated">&lt;a href=&quot;qpagesize#SizeMatchPolicy-enum&quot;&gt;FuzzyMatch&lt;/a&gt; 를 사용하는 경우 반환 된 &lt;a href=&quot;qpagesize#PageSizeId-enum&quot;&gt;PageSizeId&lt;/a&gt; 의 단위 크기가</target>
        </trans-unit>
        <trans-unit id="fff58ec642a6bc6a5dd10ba387da5a4a85c71c9e" translate="yes" xml:space="preserve">
          <source>If using &lt;a href=&quot;qspinbox#prefix-prop&quot;&gt;prefix&lt;/a&gt;(), &lt;a href=&quot;qspinbox#suffix-prop&quot;&gt;suffix&lt;/a&gt;(), and &lt;a href=&quot;qabstractspinbox#specialValueText-prop&quot;&gt;specialValueText&lt;/a&gt;() don't provide enough control, you subclass &lt;a href=&quot;qspinbox&quot;&gt;QSpinBox&lt;/a&gt; and reimplement &lt;a href=&quot;qspinbox#valueFromText&quot;&gt;valueFromText&lt;/a&gt;() and &lt;a href=&quot;qspinbox#textFromValue&quot;&gt;textFromValue&lt;/a&gt;(). For example, here's the code for a custom spin box that allows the user to enter icon sizes (e.g., &quot;32 x 32&quot;):</source>
          <target state="translated">사용하는 경우 &lt;a href=&quot;qspinbox#prefix-prop&quot;&gt;접두사&lt;/a&gt; (), &lt;a href=&quot;qspinbox#suffix-prop&quot;&gt;접미사&lt;/a&gt; () 및 &lt;a href=&quot;qabstractspinbox#specialValueText-prop&quot;&gt;specialValueText는&lt;/a&gt; () 충분히 제어, 당신이 서브 클래스 제공하지 않습니다 &lt;a href=&quot;qspinbox&quot;&gt;QSpinBox&lt;/a&gt; 및 구현할 &lt;a href=&quot;qspinbox#valueFromText&quot;&gt;valueFromText&lt;/a&gt; ()와 &lt;a href=&quot;qspinbox#textFromValue&quot;&gt;textFromValue&lt;/a&gt; ()을. 예를 들어 다음은 사용자가 아이콘 크기를 입력 할 수있는 사용자 지정 스핀 상자의 코드입니다 (예 : &quot;32 x 32&quot;).</target>
        </trans-unit>
        <trans-unit id="6f9a2697f68ce8c6fa3506d69c793884b3323abb" translate="yes" xml:space="preserve">
          <source>If using a compressed &lt;a href=&quot;qopengltexture#format&quot;&gt;format&lt;/a&gt;() then you should use &lt;a href=&quot;qopengltexture#setCompressedData&quot;&gt;setCompressedData&lt;/a&gt;() instead of this function.</source>
          <target state="translated">압축 &lt;a href=&quot;qopengltexture#format&quot;&gt;형식&lt;/a&gt; ()을 사용 하는 경우이 함수 대신 &lt;a href=&quot;qopengltexture#setCompressedData&quot;&gt;setCompressedData&lt;/a&gt; ()를 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="df175fa34fc6197b1820a44997ba2a76099c4b06" translate="yes" xml:space="preserve">
          <source>If using a custom surface format, the stencil buffer needs to be defined (&lt;a href=&quot;qsurfaceformat#setStencilBufferSize&quot;&gt;QSurfaceFormat::setStencilBufferSize&lt;/a&gt;()) for reflections to work.</source>
          <target state="translated">사용자 정의 표면 형식을 사용하는 경우 반사가 작동 하도록 스텐실 버퍼를 정의해야합니다 ( &lt;a href=&quot;qsurfaceformat#setStencilBufferSize&quot;&gt;QSurfaceFormat :: setStencilBufferSize&lt;/a&gt; ()).</target>
        </trans-unit>
        <trans-unit id="f3b110129af5a9dbb532995d4abc5ee3ccc7010c" translate="yes" xml:space="preserve">
          <source>If using a texture that has a combined depth/stencil format this function sets which component of the texture is accessed to</source>
          <target state="translated">깊이 / 스텐실 형식이 결합 된 텍스처를 사용하는 경우이 기능은 텍스처의 어느 구성 요소에 액세스 할 것인지 설정합니다.</target>
        </trans-unit>
        <trans-unit id="d6ee08be27dd8ca1920b92a691492f1c00d26efa" translate="yes" xml:space="preserve">
          <source>If using multiple properties from a group of properties, consider using</source>
          <target state="translated">속성 그룹에서 여러 속성을 사용하는 경우</target>
        </trans-unit>
        <trans-unit id="e598f0c143d34e93e28eb5bd7333fca1c29dc471" translate="yes" xml:space="preserve">
          <source>If using the assets mechanism is not required for your app, the recommended way of distributing resources with your Qt app is to use &lt;a href=&quot;resources&quot;&gt;The Qt Resource System&lt;/a&gt;, which is a cross-platform mechanism for distributing resources with your app.</source>
          <target state="translated">앱에 자산 메커니즘을 사용할 필요가없는 경우 Qt 앱과 함께 리소스를 배포하는 권장 방법은 앱 과 함께 리소스를 배포하기위한 크로스 플랫폼 메커니즘 인 &lt;a href=&quot;resources&quot;&gt;Qt 리소스 시스템&lt;/a&gt; 을 사용 하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="982abf038d3106d3150c19907a420813ef6c1e96" translate="yes" xml:space="preserve">
          <source>If viewfinder settings are not supported by the camera, it always returns a null &lt;a href=&quot;qcameraviewfindersettings&quot;&gt;QCameraViewfinderSettings&lt;/a&gt; object.</source>
          <target state="translated">카메라에서 뷰 파인더 설정을 지원하지 않으면 항상 null &lt;a href=&quot;qcameraviewfindersettings&quot;&gt;QCameraViewfinderSettings&lt;/a&gt; 객체를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="994197ed75e3b5bc756c922271b51a071f942854" translate="yes" xml:space="preserve">
          <source>If we add a mutex, we should get the result we want:</source>
          <target state="translated">뮤텍스를 추가하면 원하는 결과를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f511b0976d2c3e4b5c7087d4ba09c724e0a080fa" translate="yes" xml:space="preserve">
          <source>If we added a third property (say, Red vs Blue), the total number of states would double, to eight; and if we added a fourth property (say, Enclosed vs Convertible), the total number of states would double again, to 16.</source>
          <target state="translated">세 번째 속성 (예 : Red vs Blue)을 추가하면 총 주 수가 8 배로 늘어납니다. 그리고 네 번째 속성 (Enclosed vs Convertible)을 추가하면 총 상태 수는 다시 16으로 두 배가됩니다.</target>
        </trans-unit>
        <trans-unit id="69c3920a0228de0571627a90e5da1a716ec512d5" translate="yes" xml:space="preserve">
          <source>If we apply stretch factors to each widget, they will be laid out in proportion (but never less than their minimum size hint), e.g.</source>
          <target state="translated">각 위젯에 스트레치 팩터를 적용하면 비율에 따라 배치되지만 최소 크기 힌트보다 작지 않습니다.</target>
        </trans-unit>
        <trans-unit id="391d5d3c94c88dfbfc5db8acaebe6629e44596f9" translate="yes" xml:space="preserve">
          <source>If we are using nested states, the parent defines a value for the property which is inherited by all descendants that do not explicitly assign a value to the property.</source>
          <target state="translated">중첩 상태를 사용하는 경우 부모는 속성에 값을 명시 적으로 할당하지 않은 모든 자손이 상속하는 속성 값을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="ddadac7ff808aedab2554bcc0c9e740eda355b10" translate="yes" xml:space="preserve">
          <source>If we continue our analogy with Web services, object paths equate to the path part of a URL:</source>
          <target state="translated">웹 서비스와 유사성을 유지한다면 객체 경로는 URL의 경로 부분과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0f1c1a3d2c9d206d7de9af864589670478b3e1fb" translate="yes" xml:space="preserve">
          <source>If we did provide an identifier then we could retrieve a category's children.</source>
          <target state="translated">식별자를 제공 한 경우 카테고리의 하위를 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="135904c55ac8fbe0fcd1f240a70a644d44dc854a" translate="yes" xml:space="preserve">
          <source>If we don't provide a copy constructor or an assignment operator, C++ provides a default implementation that performs a member-by-member copy. In the example above, that would have been sufficient. Also, if you don't provide any constructors, C++ provides a default constructor that initializes its member using default constructors. Although it doesn't provide any explicit constructors or assignment operator, the following data type can be stored in a container:</source>
          <target state="translated">복사 생성자 또는 할당 연산자를 제공하지 않으면 C ++은 멤버 별 복사를 수행하는 기본 구현을 제공합니다. 위의 예에서는 충분했을 것입니다. 또한 생성자를 제공하지 않으면 C ++은 기본 생성자를 사용하여 멤버를 초기화하는 기본 생성자를 제공합니다. 명시적인 생성자 또는 할당 연산자를 제공하지는 않지만 다음 데이터 유형을 컨테이너에 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="939f9c417675fdc58025672643465c1600ac04b7" translate="yes" xml:space="preserve">
          <source>If we had done it that way here, the copy constructor shown would be required. Since the copy constructor is trivial, you might as well just always include it.</source>
          <target state="translated">여기에서 그렇게 한 경우 표시된 복사 생성자가 필요합니다. 복사 생성자는 사소한 것이므로 항상 포함시킬 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="92e2cea0383d5d45395f6838ba2705436aba982b" translate="yes" xml:space="preserve">
          <source>If we have three widgets laid out using a &lt;a href=&quot;qhboxlayout&quot;&gt;QHBoxLayout&lt;/a&gt; with no stretch factors set we will get a layout like this:</source>
          <target state="translated">스트레치 팩터가 설정되지 않은 &lt;a href=&quot;qhboxlayout&quot;&gt;QHBoxLayout&lt;/a&gt; 을 사용하여 세 개의 위젯을 배치 하면 다음과 같은 레이아웃을 얻게됩니다.</target>
        </trans-unit>
        <trans-unit id="b5bec29f2afa07f4a58155b5f58351c6a2ff7836" translate="yes" xml:space="preserve">
          <source>If we instead used the corresponding type from the &lt;a href=&quot;qtquickcontrols-index#&quot;&gt;QtQuick.Controls&lt;/a&gt; import as we did in the previous section, it would not work: the control we were defining would try to derive from itself.</source>
          <target state="translated">이전 섹션에서와 같이 &lt;a href=&quot;qtquickcontrols-index#&quot;&gt;QtQuick.Controls&lt;/a&gt; 가져 오기 에서 해당 유형을 대신 사용하면 작동하지 않습니다. 정의한 제어가 자체에서 파생됩니다.</target>
        </trans-unit>
        <trans-unit id="5de420dd5294579c79c00a4e4e06ba39256245db" translate="yes" xml:space="preserve">
          <source>If we just want to modify the value of an existing item, we can use &lt;a href=&quot;qmutablelistiterator#setValue&quot;&gt;setValue()&lt;/a&gt;. In the code below, we replace any value larger than 128 with 128:</source>
          <target state="translated">기존 항목의 값만 수정하려면 &lt;a href=&quot;qmutablelistiterator#setValue&quot;&gt;setValue ()를&lt;/a&gt; 사용할 수 있습니다 . 아래 코드에서 128보다 큰 값을 128로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="56dc8f9c50f5b17baa4ce4c71338e2386c3287f4" translate="yes" xml:space="preserve">
          <source>If we make the logical coordinate system a square, we should also make the viewport a square using the &lt;a href=&quot;qpainter#setViewport&quot;&gt;QPainter::setViewport&lt;/a&gt;() function. In the example above we make it equivalent to the largest square that fit into the paint device's rectangle. By taking the paint device's size into consideration when setting the window or viewport, it is possible to keep the drawing code independent of the paint device.</source>
          <target state="translated">논리 좌표계를 정사각형으로 만들면 &lt;a href=&quot;qpainter#setViewport&quot;&gt;QPainter :: setViewport&lt;/a&gt; () 함수를 사용하여 뷰포트를 정사각형으로 만들어야합니다 . 위의 예에서 페인트 장치의 사각형에 맞는 가장 큰 사각형과 같습니다. 창 또는 뷰포트를 설정할 때 페인트 장치의 크기를 고려하면 페인트 장치와 독립적으로 그리기 코드를 유지할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e23a5c50007246fc7a836789bb8c7bf034581142" translate="yes" xml:space="preserve">
          <source>If we now compile and run the project we can click on the circle widget to increase its line width, and press the reset button to set the line width back to 1.</source>
          <target state="translated">이제 프로젝트를 컴파일하고 실행하면 원 위젯을 클릭하여 선 너비를 늘리고 재설정 버튼을 눌러 선 너비를 다시 1로 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dea76d6abb59ae1dba5d6f14e2566e1ea06bae4b" translate="yes" xml:space="preserve">
          <source>If we save that document as &quot;HelloWorld.qml&quot;, we can load and display it.</source>
          <target state="translated">해당 문서를 &quot;HelloWorld.qml&quot;로 저장하면로드하여 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4e43e615e5806e9457bf677576affcd477b41dd" translate="yes" xml:space="preserve">
          <source>If we save the example XQuery shown above in a text file (e.g. &lt;code&gt;myquery.xq&lt;/code&gt;), we can run it from a Qt application using a standard Qt XML Patterns code sequence:</source>
          <target state="translated">위에 표시된 XQuery 예제를 텍스트 파일 (예 : &lt;code&gt;myquery.xq&lt;/code&gt; )에 저장하면 표준 Qt XML 패턴 코드 시퀀스를 사용하여 Qt 애플리케이션에서 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c668140f896257a8ba1337adc7c2d1f236b8c6d4" translate="yes" xml:space="preserve">
          <source>If we want the stream operators &lt;code&gt;operator&amp;lt;&amp;lt;()&lt;/code&gt; and &lt;code&gt;operator&amp;gt;&amp;gt;()&lt;/code&gt; to work on &lt;a href=&quot;qmetatype#Type-enum&quot;&gt;QVariant&lt;/a&gt; objects that store custom types, the custom type must provide &lt;code&gt;operator&amp;lt;&amp;lt;()&lt;/code&gt; and &lt;code&gt;operator&amp;gt;&amp;gt;()&lt;/code&gt; operators.</source>
          <target state="translated">스트림 연산자 &lt;code&gt;operator&amp;lt;&amp;lt;()&lt;/code&gt; 및 &lt;code&gt;operator&amp;gt;&amp;gt;()&lt;/code&gt; 가 사용자 정의 유형을 저장 하는 &lt;a href=&quot;qmetatype#Type-enum&quot;&gt;QVariant&lt;/a&gt; 객체 에서 작동하게 하려면 사용자 정의 유형이 &lt;code&gt;operator&amp;lt;&amp;lt;()&lt;/code&gt; 및 &lt;code&gt;operator&amp;gt;&amp;gt;()&lt;/code&gt; 연산자를 제공해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f03c51cf5d11dac6ddaa2a52fb2ca9deddaeea5f" translate="yes" xml:space="preserve">
          <source>If we want to count all the occurrences of 'Eric' and 'Eirik' in a string, two valid solutions are &lt;b&gt;\b(Eric|Eirik)\b&lt;/b&gt; and &lt;b&gt;\bEi?ri[ck]\b&lt;/b&gt;. The word boundary assertion '\b' is required to avoid matching words that contain either name, e.g. 'Ericsson'. Note that the second regexp matches more spellings than we want: 'Eric', 'Erik', 'Eiric' and 'Eirik'.</source>
          <target state="translated">문자열에서 'Eric'및 'Eirik'의 모든 발생을 계산하려면 두 가지 유효한 솔루션은 &lt;b&gt;\ b (Eric | Eirik) \ b&lt;/b&gt; 및 &lt;b&gt;\ bEi? ri [ck] \ b&lt;/b&gt; 입니다. 단어 경계 어설 션 '\ b'는 이름이 포함 된 단어 (예 : 'Ericsson')와 일치하는 단어를 피하기 위해 필요합니다. 두 번째 정규 표현식은 우리가 원하는 것보다 더 많은 철자 법인 'Eric', 'Erik', 'Eiric'및 'Eirik'과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="228813af00250292acc7d372590bf0870f0a379b" translate="yes" xml:space="preserve">
          <source>If we want to iterate through all the items with the same value, we can use &lt;a href=&quot;qmapiterator#findNext&quot;&gt;findNext()&lt;/a&gt; or &lt;a href=&quot;qmapiterator#findPrevious&quot;&gt;findPrevious()&lt;/a&gt;. Here's an example where we remove all the items with a particular value:</source>
          <target state="translated">동일한 값을 가진 모든 항목을 반복하려면 &lt;a href=&quot;qmapiterator#findNext&quot;&gt;findNext ()&lt;/a&gt; 또는 &lt;a href=&quot;qmapiterator#findPrevious&quot;&gt;findPrevious ()를&lt;/a&gt; 사용할 수 있습니다 . 다음은 특정 값을 가진 모든 항목을 제거하는 예입니다.</target>
        </trans-unit>
        <trans-unit id="62dccd109997265b265acb7a29596b2ebf981557" translate="yes" xml:space="preserve">
          <source>If we want to replace ampersand characters with the HTML entity &lt;b&gt;&amp;amp;amp;&lt;/b&gt;, the regexp to match is simply &lt;b&gt;&amp;amp;&lt;/b&gt;. But this regexp will also match ampersands that have already been converted to HTML entities. We want to replace only ampersands that are not already followed by &lt;b&gt;amp;&lt;/b&gt;. For this, we need the negative lookahead assertion, &lt;b&gt;(?!&lt;/b&gt;__&lt;b&gt;)&lt;/b&gt;. The regexp can then be written as &lt;b&gt;&amp;amp;(?!amp;)&lt;/b&gt;, i.e.</source>
          <target state="translated">앰퍼샌드 문자를 HTML 엔티티 &lt;b&gt;&amp;amp; amp;&lt;/b&gt; 일치하는 정규 표현식은 단순히 &lt;b&gt;&amp;amp;&lt;/b&gt; 입니다. 그러나이 정규 표현식은 이미 HTML 엔터티로 변환 된 앰퍼샌드와도 일치합니다. 우리는 아직 &lt;b&gt;amp&lt;/b&gt; 뒤에 오는 앰퍼샌드 만 교체하고 싶습니다 &lt;b&gt;.&lt;/b&gt; . 이를 위해서는 네거티브 미리보기 어설 션 &lt;b&gt;(?!&lt;/b&gt; __ &lt;b&gt;)이 필요&lt;/b&gt; 합니다. 정규 표현식은 다음과 같이 쓸 수있다 &lt;b&gt;; 및 (? A)&lt;/b&gt; , 즉</target>
        </trans-unit>
        <trans-unit id="4208ebd6956f11ebfad60161063794f89f5db08f" translate="yes" xml:space="preserve">
          <source>If we want to use parentheses purely for grouping and not for capturing we can use the non-capturing syntax, e.g. &lt;b&gt;(?:green|blue)&lt;/b&gt;. Non-capturing parentheses begin '(?:' and end ')'. In this example we match either 'green' or 'blue' but we do not capture the match so we only know whether or not we matched but not which color we actually found. Using non-capturing parentheses is more efficient than using capturing parentheses since the regexp engine has to do less book-keeping.</source>
          <target state="translated">그룹화에만 사용하고 캡처에는 사용하지 않고 괄호를 사용하려면 캡처하지 않는 구문을 사용할 수 있습니다 &lt;b&gt;(&lt;/b&gt; 예 : &lt;b&gt;(? : green | blue))&lt;/b&gt; . 캡처하지 않는 괄호는 '(? :'및 end ')'로 시작합니다. 이 예에서는 '녹색'또는 '파란색'과 일치하지만 일치를 캡처하지 않으므로 일치 여부 만 알지만 실제로 찾은 색상은 알 수 없습니다. 정규식 엔진이 예약을 덜 수행해야하기 때문에 캡처하지 않는 괄호를 사용하는 것이 캡처 괄호를 사용하는 것보다 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="32198f4e4bde30e9720192f732eea0d71ba088ab" translate="yes" xml:space="preserve">
          <source>If wrap is &lt;code&gt;true&lt;/code&gt;, stepping past &lt;a href=&quot;qml-qtquick-controls2-spinbox#to-prop&quot;&gt;to&lt;/a&gt; changes the value to &lt;a href=&quot;qml-qtquick-controls2-spinbox#from-prop&quot;&gt;from&lt;/a&gt; and vice versa.</source>
          <target state="translated">줄 바꿈이 &lt;code&gt;true&lt;/code&gt; 이면 단계를 건너 뛰면 값이 &lt;a href=&quot;qml-qtquick-controls2-spinbox#from-prop&quot;&gt;에서 &lt;/a&gt;&lt;a href=&quot;qml-qtquick-controls2-spinbox#to-prop&quot;&gt;로&lt;/a&gt; 변경 되고 그 반대로도 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="7d8ba470d02c9e9cab21333de5c72425c862d14e" translate="yes" xml:space="preserve">
          <source>If wrapping is true stepping up from maximum() value will take you to the minimum() value and vice versa. Wrapping only make sense if you have minimum() and maximum() values set.</source>
          <target state="translated">줄 바꿈이 true 인 경우 maximum () 값에서 올라가면 minimum () 값으로 이동하고 그 반대도 마찬가지입니다. 랩핑은 minimum () 및 maximum () 값이 설정된 경우에만 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="69b99beed73cd180056131c452501a77aece7ebb" translate="yes" xml:space="preserve">
          <source>If you access out of bounds, a zero (null object) is returned and a warning is issued.</source>
          <target state="translated">범위를 벗어난 곳에 액세스하면 0 (널 오브젝트)이 리턴되고 경고가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="573e2c289f21af6f9eba01b6f44b050e88e36db5" translate="yes" xml:space="preserve">
          <source>If you add a &lt;a href=&quot;qtoolbutton&quot;&gt;QToolButton&lt;/a&gt; with this method, the toolbar's &lt;a href=&quot;qt#ToolButtonStyle-enum&quot;&gt;Qt::ToolButtonStyle&lt;/a&gt; will not be respected.</source>
          <target state="translated">이 메소드 로 &lt;a href=&quot;qtoolbutton&quot;&gt;QToolButton&lt;/a&gt; 을 추가 하면 툴바의 &lt;a href=&quot;qt#ToolButtonStyle-enum&quot;&gt;Qt :: ToolButtonStyle&lt;/a&gt; 이 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e92974e65bc0cc53ad8104fe86b9f43444f1421e" translate="yes" xml:space="preserve">
          <source>If you add a child widget to an already visible widget you must explicitly show the child to make it visible.</source>
          <target state="translated">이미 표시된 위젯에 하위 위젯을 추가하는 경우 하위 위젯을 명시 적으로 표시하여 위젯을 표시해야합니다.</target>
        </trans-unit>
        <trans-unit id="3ff0ca814fc818ed35bf736e1608d0c88b71b6d6" translate="yes" xml:space="preserve">
          <source>If you already have a &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; subclass and want an easy optimization, you can use &lt;a href=&quot;qbasictimer&quot;&gt;QBasicTimer&lt;/a&gt; instead of &lt;a href=&quot;qtimer&quot;&gt;QTimer&lt;/a&gt;. With &lt;a href=&quot;qbasictimer&quot;&gt;QBasicTimer&lt;/a&gt;, you must reimplement &lt;a href=&quot;qobject#timerEvent&quot;&gt;timerEvent()&lt;/a&gt; in your &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; subclass and handle the timeout there. The &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtwidgets-widgets-wiggly-example.html&quot;&gt;Wiggly&lt;/a&gt; example shows how to use &lt;a href=&quot;qbasictimer&quot;&gt;QBasicTimer&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 서브 클래스 가 이미 있고 쉬운 최적화를 원하는 경우 &lt;a href=&quot;qtimer&quot;&gt;QTimer&lt;/a&gt; 대신 &lt;a href=&quot;qbasictimer&quot;&gt;QBasicTimer&lt;/a&gt; 를 사용할 수 있습니다 . &lt;a href=&quot;qbasictimer&quot;&gt;QBasicTimer을&lt;/a&gt; 사용하면 &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 서브 클래스 에서 &lt;a href=&quot;qobject#timerEvent&quot;&gt;timerEvent ()&lt;/a&gt; 를 다시 구현 하고 타임 아웃을 처리해야합니다. &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtwidgets-widgets-wiggly-example.html&quot;&gt;흔들기&lt;/a&gt; 예를 보여줍니다 어떻게 사용하는 &lt;a href=&quot;qbasictimer&quot;&gt;QBasicTimer을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="66dc6e8efe388635cff4d6b8e7b83340b07897e3" translate="yes" xml:space="preserve">
          <source>If you already have a fully defined &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;, it can become a Source simply by passing it to &lt;a href=&quot;qremoteobjecthostbase#enableRemoting&quot;&gt;QRemoteObjectHostBase::enableRemoting&lt;/a&gt;(). This lets other processes/devices create a &lt;a href=&quot;qtremoteobjects-replica#replica&quot;&gt;Replica&lt;/a&gt; of the object to interact with (see &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtremoteobjects-interaction.html#remote-object-interaction&quot;&gt;Remote Object Interaction&lt;/a&gt;). You can then instantiate &lt;a href=&quot;qremoteobjectdynamicreplica&quot;&gt;QRemoteObjectDynamicReplica&lt;/a&gt;s of your object.</source>
          <target state="translated">이미 완전히 정의 된 &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 가있는 경우 &lt;a href=&quot;qremoteobjecthostbase#enableRemoting&quot;&gt;QRemoteObjectHostBase :: enableRemoting&lt;/a&gt; () 에 전달하여 간단히 소스가 될 수 있습니다 . 이를 통해 다른 프로세스 / 장치 가 상호 작용할 객체 의 &lt;a href=&quot;qtremoteobjects-replica#replica&quot;&gt;복제본&lt;/a&gt; 을 생성 할 수 있습니다 ( &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtremoteobjects-interaction.html#remote-object-interaction&quot;&gt;원격 객체 상호 작용&lt;/a&gt; 참조 ). 그런 다음 객체의 &lt;a href=&quot;qremoteobjectdynamicreplica&quot;&gt;QRemoteObjectDynamicReplica&lt;/a&gt; 를 인스턴스화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="54dd070f132699b449fced117bece39fae043218" translate="yes" xml:space="preserve">
          <source>If you always use the same file you do not need to use &lt;a href=&quot;qfileselector&quot;&gt;QFileSelector&lt;/a&gt;.</source>
          <target state="translated">항상 같은 파일을 사용 &lt;a href=&quot;qfileselector&quot;&gt;한다면 QFileSelector&lt;/a&gt; 를 사용할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="357d8c8c15072da4629552f4faa8ec4975bbc4f4" translate="yes" xml:space="preserve">
          <source>If you append a built-in install set to the &lt;code&gt;INSTALLS&lt;/code&gt; variable and do not specify &lt;code&gt;files&lt;/code&gt; or &lt;code&gt;extra&lt;/code&gt; members, qmake will decide what needs to be copied for you. Currently, the &lt;code&gt;target&lt;/code&gt; and &lt;code&gt;dlltarget&lt;/code&gt; install sets are supported. For example:</source>
          <target state="translated">내장 설치 세트를 &lt;code&gt;INSTALLS&lt;/code&gt; 변수에 &lt;code&gt;extra&lt;/code&gt; &lt;code&gt;files&lt;/code&gt; 이나 추가 멤버를 지정하지 않으면 qmake가 복사 할 항목을 결정합니다. 현재 &lt;code&gt;target&lt;/code&gt; 및 &lt;code&gt;dlltarget&lt;/code&gt; 설치 세트가 지원됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fb4055566f4e21980f25a6697df12ac5c9d286c0" translate="yes" xml:space="preserve">
          <source>If you are building a &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; gradually and know in advance approximately how many characters the &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; will contain, you can call &lt;a href=&quot;qstring#reserve&quot;&gt;reserve&lt;/a&gt;(), asking &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; to preallocate a certain amount of memory. You can also call &lt;a href=&quot;qstring#capacity&quot;&gt;capacity&lt;/a&gt;() to find out how much memory &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; actually allocated.</source>
          <target state="translated">당신이 만든다면 &lt;a href=&quot;qstring&quot;&gt;QString을&lt;/a&gt; 점차적으로 약 얼마나 많은 문자를 사전에 알고 &lt;a href=&quot;qstring&quot;&gt;QString이&lt;/a&gt; 포함됩니다, 당신은 호출 할 수 있습니다 &lt;a href=&quot;qstring#reserve&quot;&gt;예약을&lt;/a&gt; 요청, () &lt;a href=&quot;qstring&quot;&gt;QString를&lt;/a&gt; 메모리의 일정 금액을 미리 할당 할 수 있습니다. &lt;a href=&quot;qstring#capacity&quot;&gt;용량&lt;/a&gt; ()을 호출 하여 실제로 &lt;a href=&quot;qstring&quot;&gt;QString에&lt;/a&gt; 할당 된 메모리 양을 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1f69359a3ea41192cfeea7a41e2eda47d527426f" translate="yes" xml:space="preserve">
          <source>If you are calling &lt;a href=&quot;qtooltip#hideText&quot;&gt;QToolTip::hideText&lt;/a&gt;(), or &lt;a href=&quot;qtooltip#showText&quot;&gt;QToolTip::showText&lt;/a&gt;() with an empty string, as a result of a &lt;a href=&quot;qevent#Type-enum&quot;&gt;ToolTip&lt;/a&gt;-event you should also call &lt;a href=&quot;qevent#ignore&quot;&gt;ignore()&lt;/a&gt; on the event, to signal that you don't want to start any tooltip specific modes.</source>
          <target state="translated">당신이 호출하는 경우 &lt;a href=&quot;qtooltip#hideText&quot;&gt;QToolTip :: hideText&lt;/a&gt; () 또는 &lt;a href=&quot;qtooltip#showText&quot;&gt;QToolTip :: showText&lt;/a&gt; 의 결과로 빈 문자열을 (), &lt;a href=&quot;qevent#Type-enum&quot;&gt;도구 설명&lt;/a&gt; 당신은 또한 호출해야 - 이벤트 &lt;a href=&quot;qevent#ignore&quot;&gt;) (무시&lt;/a&gt; 원하지 않는 것을 알리기 위해 이벤트에 툴팁 특정 모드를 시작합니다.</target>
        </trans-unit>
        <trans-unit id="43e0cbbb5c171786dfe76f3c109568d78c086065" translate="yes" xml:space="preserve">
          <source>If you are calling a function on an &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; subclass that doesn't live in the current thread and the object might receive events, you must protect all access to your &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; subclass's internal data with a mutex; otherwise, you may experience crashes or other undesired behavior.</source>
          <target state="translated">현재 스레드에 존재하지 않는 &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 서브 클래스 에서 함수를 호출 하고 오브젝트가 이벤트를 수신 할 수 있는 경우, 뮤텍스 를 사용하여 &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 서브 클래스의 내부 데이터에 대한 모든 액세스를 보호해야합니다 . 그렇지 않으면 충돌이나 다른 원하지 않는 동작이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8660160035ab2a9f737194b2dbeeab682345d2e7" translate="yes" xml:space="preserve">
          <source>If you are certain the QML file to be loaded is a local file, you could omit the &lt;code&gt;finishCreation()&lt;/code&gt; function and call &lt;a href=&quot;qml-qtqml-component#createObject-method&quot;&gt;createObject()&lt;/a&gt; immediately:</source>
          <target state="translated">로드 할 QML 파일이 로컬 파일이라고 확신하는 경우 &lt;code&gt;finishCreation()&lt;/code&gt; 함수를 생략하고 즉시 &lt;a href=&quot;qml-qtqml-component#createObject-method&quot;&gt;createObject ()를&lt;/a&gt; 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="66a985357066e965ac0d58d4bd13bc9ea2d8fe59" translate="yes" xml:space="preserve">
          <source>If you are certain you want your variables processed after the files specified, then you may pass the &lt;code&gt;-after&lt;/code&gt; option. When this is specified, all assignments on the command line after the &lt;code&gt;-after&lt;/code&gt; option will be postponed until after the specified files are parsed.</source>
          <target state="translated">지정된 파일 이후에 변수를 처리하려는 경우 &lt;code&gt;-after&lt;/code&gt; 옵션을 전달할 수 있습니다. 이것이 지정되면, &lt;code&gt;-after&lt;/code&gt; 옵션 다음에있는 명령 행의 모든 ​​지정 은 지정된 파일이 구문 분석 될 때까지 연기됩니다.</target>
        </trans-unit>
        <trans-unit id="148f7c117f2dde1027fc147e230853f26463b083" translate="yes" xml:space="preserve">
          <source>If you are changing the number of columns or rows you do not need to emit this signal, but use the begin/end functions (refer to the section on subclassing in the &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; class description for details).</source>
          <target state="translated">열 또는 행 수를 변경하는 경우이 신호를 방출 할 필요는 없지만 시작 / 종료 기능을 사용하십시오 ( 자세한 내용 은 &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; 클래스 설명의 서브 클래 싱 섹션 참조).</target>
        </trans-unit>
        <trans-unit id="e611044ce802a496de3904731dc8c7df2ec5aa83" translate="yes" xml:space="preserve">
          <source>If you are considering defining a new component, it's worth double checking that such a component doesn't already exist in the component set for your platform. Otherwise, you will be forcing the QML engine to generate and store type-data for a type which is essentially a duplicate of another pre-existing and potentially already loaded component.</source>
          <target state="translated">새 컴포넌트 정의를 고려중인 경우 해당 컴포넌트가 플랫폼의 컴포넌트 세트에 없는지 다시 확인해야합니다. 그렇지 않으면 QML 엔진이 다른 기존의 잠재적으로 이미로드 된 구성 요소와 본질적으로 중복되는 유형에 대한 유형 데이터를 생성하고 저장하도록합니다.</target>
        </trans-unit>
        <trans-unit id="a7ed74a89447502632954ce9ef8c44afaaa3bd1a" translate="yes" xml:space="preserve">
          <source>If you are designing an application which changes its layout depending on device orientation, you probably want to use primaryOrientation to determine the layout. That is because on a desktop computer, you can expect primaryOrientation to change when the user rotates the screen via the operating system's control panel, even if the computer does not contain an accelerometer. Likewise on most handheld computers which do have accelerometers, the operating system will rotate the whole screen automatically, so again you will see the primaryOrientation change.</source>
          <target state="translated">장치 방향에 따라 레이아웃을 변경하는 응용 프로그램을 디자인하는 경우 primaryOrientation을 사용하여 레이아웃을 결정할 수 있습니다. 데스크톱 컴퓨터에서는 컴퓨터에 가속도계가없는 경우에도 사용자가 운영 체제 제어판을 통해 화면을 회전하면 primaryOrientation이 변경 될 수 있기 때문입니다. 마찬가지로 가속도계가있는 대부분의 핸드 헬드 컴퓨터에서 운영 체제는 전체 화면을 자동으로 회전하므로 기본 방향 변경이 다시 나타납니다.</target>
        </trans-unit>
        <trans-unit id="a838ab048609c1ff2f968e68271c83f70b5950b3" translate="yes" xml:space="preserve">
          <source>If you are developing custom widgets and want them to look good on all platforms, you can use &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt; functions to perform parts of the widget drawing, such as &lt;a href=&quot;qstyle#drawItemText&quot;&gt;drawItemText&lt;/a&gt;(), &lt;a href=&quot;qstyle#drawItemPixmap&quot;&gt;drawItemPixmap&lt;/a&gt;(), &lt;a href=&quot;qstyle#drawPrimitive&quot;&gt;drawPrimitive&lt;/a&gt;(), &lt;a href=&quot;qstyle#drawControl&quot;&gt;drawControl&lt;/a&gt;(), and &lt;a href=&quot;qstyle#drawComplexControl&quot;&gt;drawComplexControl&lt;/a&gt;().</source>
          <target state="translated">사용자 정의 위젯을 개발 중이고 모든 플랫폼에서 잘 보이도록하려면 &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt; 함수를 사용 하여 &lt;a href=&quot;qstyle#drawItemText&quot;&gt;drawItemText&lt;/a&gt; (), &lt;a href=&quot;qstyle#drawItemPixmap&quot;&gt;drawItemPixmap&lt;/a&gt; (), &lt;a href=&quot;qstyle#drawPrimitive&quot;&gt;drawPrimitive&lt;/a&gt; (), &lt;a href=&quot;qstyle#drawControl&quot;&gt;drawControl&lt;/a&gt; () 및 &lt;a href=&quot;qstyle#drawComplexControl&quot;&gt;drawComplexControl&lt;/a&gt; ( ).</target>
        </trans-unit>
        <trans-unit id="2b6f89e9c27aa8dab9848665ab7be6e8dabb614b" translate="yes" xml:space="preserve">
          <source>If you are experiencing strange problems with using special flags that modify the alignment of structure and union members (such as &lt;code&gt;/Zp2&lt;/code&gt;) then you will need to recompile Qt with the flags set for the application as well.</source>
          <target state="translated">구조 및 공용체 멤버 (예 : &lt;code&gt;/Zp2&lt;/code&gt; ) 의 정렬을 수정하는 특수 플래그를 사용할 때 이상한 문제가 발생 하면 응용 프로그램에 설정된 플래그를 사용하여 Qt를 다시 컴파일해야합니다.</target>
        </trans-unit>
        <trans-unit id="c59e1562773da0f0fa467136ee2b15d0a2847993" translate="yes" xml:space="preserve">
          <source>If you are extending your own C++ classes to interoperate with &lt;a href=&quot;qml-qtmultimedia-videooutput&quot;&gt;VideoOutput&lt;/a&gt;, you can either provide a &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; based class with a &lt;code&gt;mediaObject&lt;/code&gt; property that exposes a &lt;a href=&quot;qmediaobject&quot;&gt;QMediaObject&lt;/a&gt; derived class that has a &lt;a href=&quot;qvideorenderercontrol&quot;&gt;QVideoRendererControl&lt;/a&gt; available, or you can provide a &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; based class with a writable &lt;code&gt;videoSurface&lt;/code&gt; property that can accept a &lt;a href=&quot;qabstractvideosurface&quot;&gt;QAbstractVideoSurface&lt;/a&gt; based class and can follow the correct protocol to deliver QVideoFrames to it.</source>
          <target state="translated">당신이와 상호에 자신의 C ++ 클래스를 확장하는 경우 &lt;a href=&quot;qml-qtmultimedia-videooutput&quot;&gt;VideoOutput&lt;/a&gt; , 당신이 중 하나 제공 할 수 &lt;a href=&quot;qobject&quot;&gt;있는 QObject&lt;/a&gt; A를 기반으로 클래스 &lt;code&gt;mediaObject&lt;/code&gt; 노출 특성 &lt;a href=&quot;qmediaobject&quot;&gt;QMediaObject이&lt;/a&gt; 가 파생 클래스 &lt;a href=&quot;qvideorenderercontrol&quot;&gt;QVideoRendererControl이&lt;/a&gt; 가능한을, 또는 당신이 제공 할 수있는 &lt;a href=&quot;qobject&quot;&gt;QObject를&lt;/a&gt; 쓰기 가능으로 기반 클래스를 &lt;code&gt;videoSurface&lt;/code&gt; 의 특성 &lt;a href=&quot;qabstractvideosurface&quot;&gt;QAbstractVideoSurface&lt;/a&gt; 기반 클래스를 허용 하고 올바른 프로토콜을 따라 QVideoFrame을 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2068e5692548a6f1e549d6b12838d705c030e74b" translate="yes" xml:space="preserve">
          <source>If you are faced with this problem, we recommend that you address the following issues:</source>
          <target state="translated">이 문제가 발생하면 다음 문제를 해결하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="35d5488eb1f1d92d7e5aa88f4683fbf0e4c5537e" translate="yes" xml:space="preserve">
          <source>If you are implementing your own SQL driver (by subclassing &lt;a href=&quot;qsqldriver&quot;&gt;QSqlDriver&lt;/a&gt;), you will need to provide your own &lt;a href=&quot;qsqlresult&quot;&gt;QSqlResult&lt;/a&gt; subclass that implements all the pure virtual functions and other virtual functions that you need.</source>
          <target state="translated">&lt;a href=&quot;qsqldriver&quot;&gt;QSqlDriver&lt;/a&gt; 를 서브 클래 싱하여 고유 한 SQL 드라이버를 구현하는 경우 필요한 모든 순수 가상 함수 및 기타 가상 함수를 구현하는 고유 한 &lt;a href=&quot;qsqlresult&quot;&gt;QSqlResult&lt;/a&gt; 서브 클래스 를 제공 해야합니다.</target>
        </trans-unit>
        <trans-unit id="fd7eda5202cfdf24951838ad2ef93ee507cbd43f" translate="yes" xml:space="preserve">
          <source>If you are interested in later Qt releases, please &lt;a href=&quot;https://www.qt.io/contact-us/&quot;&gt;contact&lt;/a&gt; Qt professional services.</source>
          <target state="translated">이후 Qt 릴리스에 관심이 있으시면 Qt 전문 서비스에 &lt;a href=&quot;https://www.qt.io/contact-us/&quot;&gt;문의&lt;/a&gt; 하십시오 .</target>
        </trans-unit>
        <trans-unit id="fe18452186fa9062361200b3ccb934910231423b" translate="yes" xml:space="preserve">
          <source>If you are loading baked animation data from a file, e.g. as created by an artist, then use the &lt;a href=&quot;qt3danimation-qanimationcliploader&quot;&gt;QAnimationClipLoader&lt;/a&gt; class and set its &lt;code&gt;source&lt;/code&gt; property.</source>
          <target state="translated">아티스트가 만든 것과 같이 파일에서 구운 애니메이션 데이터를로드하는 경우 &lt;a href=&quot;qt3danimation-qanimationcliploader&quot;&gt;QAnimationClipLoader&lt;/a&gt; 클래스 를 사용하고 해당 &lt;code&gt;source&lt;/code&gt; 속성을 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="0cba86e45535051458a0288e4fb4ffb80d91bae6" translate="yes" xml:space="preserve">
          <source>If you are looking for the form window containing a specific widget, you can use the static &lt;a href=&quot;qdesignerformwindowinterface#findFormWindow&quot;&gt;QDesignerFormWindowInterface::findFormWindow&lt;/a&gt;() function:</source>
          <target state="translated">특정 위젯을 포함하는 양식 창을 찾고 있다면 정적 &lt;a href=&quot;qdesignerformwindowinterface#findFormWindow&quot;&gt;QDesignerFormWindowInterface :: findFormWindow&lt;/a&gt; () 함수를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2c0316dc7513ec4a829da5c582f7d1d6acdb751f" translate="yes" xml:space="preserve">
          <source>If you are making a one-of-a-kind special layout, you can also make a custom widget as described above. Reimplement &lt;a href=&quot;qwidget#resizeEvent&quot;&gt;QWidget::resizeEvent&lt;/a&gt;() to calculate the required distribution of sizes and call &lt;a href=&quot;qwidget#geometry-prop&quot;&gt;setGeometry()&lt;/a&gt; on each child.</source>
          <target state="translated">독특한 특수 레이아웃을 만드는 경우 위에서 설명한대로 사용자 정의 위젯을 만들 수도 있습니다. &lt;a href=&quot;qwidget#resizeEvent&quot;&gt;QWidget :: resizeEvent&lt;/a&gt; ()를 다시 구현 하여 필요한 크기 분포를 계산하고 각 하위에서 &lt;a href=&quot;qwidget#geometry-prop&quot;&gt;setGeometry ()&lt;/a&gt; 를 호출 하십시오 .</target>
        </trans-unit>
        <trans-unit id="c26fcdb2f849b2d77d06693955db2fff3cc3f735" translate="yes" xml:space="preserve">
          <source>If you are new to</source>
          <target state="translated">당신이 새로운 경우</target>
        </trans-unit>
        <trans-unit id="dcd9c9ce13348f2c89eb8cba78831786c5cc5b63" translate="yes" xml:space="preserve">
          <source>If you are not using a Microsoft compiler, replace &lt;code&gt;nmake&lt;/code&gt; with &lt;code&gt;mingw32-make&lt;/code&gt; in the line above.</source>
          <target state="translated">Microsoft 컴파일러를 사용하지 않는 경우 위 행에서 &lt;code&gt;nmake&lt;/code&gt; 를 &lt;code&gt;mingw32-make&lt;/code&gt; 로 바꾸십시오 .</target>
        </trans-unit>
        <trans-unit id="1edeadb4bd991b2129e132ab33cd635b95bce3f1" translate="yes" xml:space="preserve">
          <source>If you are producing a new binary data format, such as a file format for documents created by your application, you could use a &lt;a href=&quot;qdatastream&quot;&gt;QDataStream&lt;/a&gt; to write the data in a portable format. Typically, you would write a brief header containing a magic string and a version number to give yourself room for future expansion. For example:</source>
          <target state="translated">응용 프로그램에서 만든 문서의 파일 형식과 같은 새로운 이진 데이터 형식을 생성하는 경우 &lt;a href=&quot;qdatastream&quot;&gt;QDataStream&lt;/a&gt; 을 사용 하여 데이터를 이식 가능한 형식으로 쓸 수 있습니다 . 일반적으로 매직 문자열과 버전 번호가 포함 된 간단한 헤더를 작성하여 향후 확장을위한 공간을 제공합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e7be62f1d287b5ad9255a5f38cc81e4c59081ab0" translate="yes" xml:space="preserve">
          <source>If you are targeting a remote device, please follow all instructions by Visual Studio to set it up correctly.</source>
          <target state="translated">원격 장치를 대상으로하는 경우 Visual Studio의 모든 지침에 따라 올바르게 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="ea5596ebb0c31feb5d9df57aad25f2ddd84844a7" translate="yes" xml:space="preserve">
          <source>If you are using &lt;a href=&quot;qmaccocoaviewcontainer&quot;&gt;QMacCocoaViewContainer&lt;/a&gt; as a subclass and are accessing Cocoa API, it is probably simpler to have your file end with &lt;code&gt;.mm&lt;/code&gt; instead of &lt;code&gt;.cpp&lt;/code&gt;. Most Apple tools will correctly identify the source as Objective-C++.</source>
          <target state="translated">당신이 사용하는 경우 &lt;a href=&quot;qmaccocoaviewcontainer&quot;&gt;QMacCocoaViewContainer를&lt;/a&gt; 서브 클래스로와 코코아 API에 액세스하고, 그것을 사용하여 파일 끝이 아마 간단 &lt;code&gt;.mm&lt;/code&gt; 대신 &lt;code&gt;.cpp&lt;/code&gt; . 대부분의 Apple 도구는 소스를 Objective-C ++로 올바르게 식별합니다.</target>
        </trans-unit>
        <trans-unit id="cce264affcdcade384e7402de8bca3620ccaf966" translate="yes" xml:space="preserve">
          <source>If you are using Firebird, the Firebird library has to be set explicitly:</source>
          <target state="translated">Firebird를 사용하는 경우 Firebird 라이브러리를 명시 적으로 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="76cab77a64194ebfdfb08bb8f02673df169ab05d" translate="yes" xml:space="preserve">
          <source>If you are using InterBase:</source>
          <target state="translated">InterBase를 사용하는 경우 :</target>
        </trans-unit>
        <trans-unit id="5aa0be9550f6d982ee509d2621be3bbbef0f0cdf" translate="yes" xml:space="preserve">
          <source>If you are using a pragma library script to store application-wide instance data, consider using a &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; singleton type instead. This should result in better performance, and will result in less JavaScript heap memory being used.</source>
          <target state="translated">pragma 라이브러리 스크립트를 사용하여 애플리케이션 전체 인스턴스 데이터를 저장하는 경우 &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 싱글 톤 유형을 대신 사용하십시오. 이로 인해 성능이 향상되고 사용되는 JavaScript 힙 메모리가 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="3770d0073ac083205b9034be2c54e0470c39f38e" translate="yes" xml:space="preserve">
          <source>If you are using a shared configuration of Qt enter the &lt;code&gt;plugin&lt;/code&gt; subdirectory and run &lt;code&gt;qmake&lt;/code&gt; and your make tool to build a plugin that integrates the &lt;a href=&quot;https://doc.qt.io/qt-5.13/qaxcontainer-module.html&quot;&gt;QAxContainer&lt;/a&gt; module into &lt;a href=&quot;qtdesigner-manual&quot;&gt;Qt Designer&lt;/a&gt;.</source>
          <target state="translated">Qt의 공유 구성을 사용하는 경우 &lt;code&gt;plugin&lt;/code&gt; 서브 디렉토리를 입력하고 &lt;code&gt;qmake&lt;/code&gt; 및 make 도구를 실행 하여 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qaxcontainer-module.html&quot;&gt;QAxContainer&lt;/a&gt; 모듈을 &lt;a href=&quot;qtdesigner-manual&quot;&gt;Qt Designer에&lt;/a&gt; 통합하는 플러그인을 빌드하십시오 .</target>
        </trans-unit>
        <trans-unit id="804809b08005ed145375e8b07500633c8542f86c" translate="yes" xml:space="preserve">
          <source>If you are using coordinates with Qt's raster-based paint engine, it is important to note that, while coordinates greater than +/- 2&lt;sup&gt;15&lt;/sup&gt; can be used, any painting performed with coordinates outside this range is not guaranteed to be shown; the drawing may be clipped. This is due to the use of &lt;code&gt;short int&lt;/code&gt; in the implementation.</source>
          <target state="translated">Qt의 래스터 기반 페인트 엔진에 좌표를 사용하는 경우 +/- 2 &lt;sup&gt;15&lt;/sup&gt; 보다 큰 좌표를 사용할 수 있지만이 범위를 벗어난 좌표로 수행 된 페인팅은 표시되지 않을 수 있습니다. 그림이 잘릴 수 있습니다. 이는 구현에서 &lt;code&gt;short int&lt;/code&gt; 를 사용하기 때문 입니다.</target>
        </trans-unit>
        <trans-unit id="6c0876b52f0bb97073b195db808c67ccd41dfa9f" translate="yes" xml:space="preserve">
          <source>If you are using multiple inheritance, &lt;code&gt;moc&lt;/code&gt; assumes that the first inherited class is a subclass of &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;. Also, be sure that only the first inherited class is a &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;.</source>
          <target state="translated">다중 상속을 사용하는 경우 &lt;code&gt;moc&lt;/code&gt; 는 첫 번째 상속 된 클래스가 &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 의 서브 클래스라고 가정 합니다 . 또한, 상속 된 첫 번째 클래스 만 &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 인지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="0118c72bf59f28a9993657d26d130211a27352ae" translate="yes" xml:space="preserve">
          <source>If you are using older versions of GDB you must run with the full path to the executable. Later versions allow you to pass the bundle name on the command line.</source>
          <target state="translated">이전 버전의 GDB를 사용하는 경우 실행 파일의 전체 경로로 실행해야합니다. 최신 버전에서는 명령 행에서 번들 이름을 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="85b6bb08aa314f172681866d0c5bc4b59b8c4460" translate="yes" xml:space="preserve">
          <source>If you are using other libraries in your project in addition to those supplied with Qt, you need to specify them in your project file.</source>
          <target state="translated">Qt와 함께 제공된 라이브러리 외에 프로젝트에서 다른 라이브러리를 사용하는 경우 프로젝트 파일에서 라이브러리를 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="8a732d6c50e076fc75334ed75ced8d8ed40fd0bd" translate="yes" xml:space="preserve">
          <source>If you are using the &lt;b&gt;default message handler&lt;/b&gt; this function will abort to create a core dump. On Windows, for debug builds, this function will report a _CRT_ERROR enabling you to connect a debugger to the application.</source>
          <target state="translated">&lt;b&gt;기본 메시지 핸들러를&lt;/b&gt; 사용하는 경우이 기능은 중단되어 코어 덤프를 작성합니다. Windows에서 디버그 빌드의 경우이 함수는 디버거를 응용 프로그램에 연결할 수있는 _CRT_ERROR를보고합니다.</target>
        </trans-unit>
        <trans-unit id="c3b9a00ccce4e62ff266c186ade813aa22558a16" translate="yes" xml:space="preserve">
          <source>If you are using the mouse wheel to adjust the dial, the increment value is determined by the lesser value of &lt;a href=&quot;qapplication#wheelScrollLines-prop&quot;&gt;wheelScrollLines&lt;/a&gt; multipled by &lt;a href=&quot;qabstractslider#singleStep-prop&quot;&gt;singleStep&lt;/a&gt;, and &lt;a href=&quot;qabstractslider#pageStep-prop&quot;&gt;pageStep&lt;/a&gt;.</source>
          <target state="translated">당신이 다이얼을 조정하기 위해 마우스 휠을 사용하는 경우, 증가 값 중 작은 값에 의해 결정됩니다 &lt;a href=&quot;qapplication#wheelScrollLines-prop&quot;&gt;wheelScrollLines&lt;/a&gt; 에 의해 다중화 된 &lt;a href=&quot;qabstractslider#singleStep-prop&quot;&gt;singleStep&lt;/a&gt; 및 &lt;a href=&quot;qabstractslider#pageStep-prop&quot;&gt;pageStep&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4e92252016948c7d93f00c52d4881602666a0f61" translate="yes" xml:space="preserve">
          <source>If you are working with large amounts of filtering and have to invoke &lt;a href=&quot;qsortfilterproxymodel#invalidateFilter&quot;&gt;invalidateFilter&lt;/a&gt;() repeatedly, using reset() may be more efficient, depending on the implementation of your model. However, reset() returns the proxy model to its original state, losing selection information, and will cause the proxy model to be repopulated.</source>
          <target state="translated">대량의 필터링 작업을 수행하고 &lt;a href=&quot;qsortfilterproxymodel#invalidateFilter&quot;&gt;invalidateFilter&lt;/a&gt; ()를 반복적 으로 호출해야하는 경우 모델 구현에 따라 reset ()을 사용하는 것이 더 효율적일 수 있습니다. 그러나 reset ()은 프록시 모델을 원래 상태로 되돌려 선택 정보를 잃어 프록시 모델을 다시 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="34e44643802042a92e26e2ac644b7bbd813df0ea" translate="yes" xml:space="preserve">
          <source>If you assign an &lt;a href=&quot;qml-qtquick-item&quot;&gt;Item&lt;/a&gt; to the data list, it becomes a child of the Window's &lt;a href=&quot;qml-qtquick-window-window#contentItem-prop&quot;&gt;contentItem&lt;/a&gt;, so that it appears inside the window. The item's parent will be the window's &lt;a href=&quot;qml-qtquick-window-window#contentItem-prop&quot;&gt;contentItem&lt;/a&gt;, which is the root of the Item ownership tree within that Window.</source>
          <target state="translated">데이터 목록에 &lt;a href=&quot;qml-qtquick-item&quot;&gt;항목&lt;/a&gt; 을 할당하면 해당 항목 이 창의 &lt;a href=&quot;qml-qtquick-window-window#contentItem-prop&quot;&gt;contentItem&lt;/a&gt; 의 자식이되어 창 안에 나타납니다. 아이템의 부모는 윈도우의 &lt;a href=&quot;qml-qtquick-window-window#contentItem-prop&quot;&gt;contentItem&lt;/a&gt; 이며, 이는 해당 윈도우 내의 아이템 소유권 트리의 루트입니다.</target>
        </trans-unit>
        <trans-unit id="5aaba7502661bc68db19eb08ff6699bd95815c44" translate="yes" xml:space="preserve">
          <source>If you assign an Item to the contentData list, it becomes a child of the window's &lt;a href=&quot;qml-qtquick-controls2-applicationwindow#contentItem-attached-prop&quot;&gt;contentItem&lt;/a&gt;, so that it appears inside the window. The item's parent will be the window's &lt;a href=&quot;qml-qtquick-controls2-applicationwindow#contentItem-attached-prop&quot;&gt;contentItem&lt;/a&gt;.</source>
          <target state="translated">contentData 목록에 항목을 할당하면 해당 항목이 창의 &lt;a href=&quot;qml-qtquick-controls2-applicationwindow#contentItem-attached-prop&quot;&gt;contentItem&lt;/a&gt; 의 자식이되어 창 안에 나타납니다. 아이템의 부모는 윈도우의 &lt;a href=&quot;qml-qtquick-controls2-applicationwindow#contentItem-attached-prop&quot;&gt;contentItem&lt;/a&gt; 이 될 것 입니다.</target>
        </trans-unit>
        <trans-unit id="ae7ce82b8f37a865273277d942e3addd51f65355" translate="yes" xml:space="preserve">
          <source>If you assign another Window to the data list, the nested window will become &quot;transient for&quot; the outer Window.</source>
          <target state="translated">데이터 목록에 다른 창을 할당하면 중첩 된 창은 외부 창에 대해 &quot;일시적&quot;이됩니다.</target>
        </trans-unit>
        <trans-unit id="6035c7d9b7cf831619fd5c7a4a0d37226189ee56" translate="yes" xml:space="preserve">
          <source>If you assign any other object type, it is added as a resource.</source>
          <target state="translated">다른 객체 유형을 할당하면 해당 객체 유형이 리소스로 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="1c354aa520efd20d31e9318d38fb15177e0b11b8" translate="yes" xml:space="preserve">
          <source>If you build Qt directly from the Git repository, you should initialize the repository only with modules which are supported or build and install modules separately. This helps to prevent unexpected build problems.</source>
          <target state="translated">Git 저장소에서 직접 Qt를 빌드하는 경우 지원되는 모듈로만 저장소를 초기화하거나 모듈을 별도로 빌드 및 설치해야합니다. 예기치 않은 빌드 문제를 방지하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="06fc70f2a7700754e8743bc2e93d51b94fb545ce" translate="yes" xml:space="preserve">
          <source>If you build Qt from a released source code distribution archive, the &lt;code&gt;configure&lt;/code&gt; tool ensures that the build will be made only for modules which are known to build for the target specified. Additionally, you can explicitly exclude unsupported or not needed modules from the build via the &lt;code&gt;-skip &amp;lt;module&amp;gt;&lt;/code&gt; option when running the &lt;code&gt;configure&lt;/code&gt; tool.</source>
          <target state="translated">릴리스 된 소스 코드 배포 아카이브에서 Qt를 빌드하는 경우 &lt;code&gt;configure&lt;/code&gt; 도구는 지정된 대상에 대해 빌드 된 것으로 알려진 모듈에 대해서만 빌드되도록합니다. 또한 &lt;code&gt;configure&lt;/code&gt; 도구를 실행할 때 &lt;code&gt;-skip &amp;lt;module&amp;gt;&lt;/code&gt; 옵션을 통해 빌드에서 지원되지 않거나 필요하지 않은 모듈을 명시 적으로 제외 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0e610364a79b087476ba6a095bd06550ca27dd37" translate="yes" xml:space="preserve">
          <source>If you call &lt;a href=&quot;qaudiodecoder#read&quot;&gt;read&lt;/a&gt;() before a buffer is ready, an invalid buffer will be returned, again without blocking.</source>
          <target state="translated">버퍼가 준비되기 전에 &lt;a href=&quot;qaudiodecoder#read&quot;&gt;read&lt;/a&gt; () 를 호출하면 다시 차단하지 않고 잘못된 버퍼가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="c48e608f5b5491fc020146b414547db6c7503de9" translate="yes" xml:space="preserve">
          <source>If you call &lt;a href=&quot;qregexp#exactMatch&quot;&gt;exactMatch&lt;/a&gt;() with an empty pattern on an empty string it will return true; otherwise it returns &lt;code&gt;false&lt;/code&gt; since it operates over the whole string. If you call &lt;a href=&quot;qregexp#indexIn&quot;&gt;indexIn&lt;/a&gt;() with an empty pattern on</source>
          <target state="translated">빈 문자열에 빈 패턴으로 &lt;a href=&quot;qregexp#exactMatch&quot;&gt;exactMatch&lt;/a&gt; () 를 호출하면 true를 반환합니다. 그렇지 않으면 전체 문자열에서 작동하므로 &lt;code&gt;false&lt;/code&gt; 를 반환 합니다. 빈 패턴으로 &lt;a href=&quot;qregexp#indexIn&quot;&gt;indexIn&lt;/a&gt; () 을 호출하면</target>
        </trans-unit>
        <trans-unit id="cec9bbda48a93480232a0f202e7db7386279c388" translate="yes" xml:space="preserve">
          <source>If you can't parse the entire input in one go (for example, it is huge, or is being delivered over a network connection), data can be fed to the parser in pieces. This is achieved by telling &lt;a href=&quot;qxmlsimplereader#parse&quot;&gt;parse&lt;/a&gt;() to work incrementally, and making subsequent calls to the &lt;a href=&quot;qxmlsimplereader#parseContinue&quot;&gt;parseContinue&lt;/a&gt;() function, until all the data has been processed.</source>
          <target state="translated">전체 입력을 한 번에 구문 분석 할 수없는 경우 (예 : 용량이 크거나 네트워크 연결을 통해 전달되는 경우) 데이터를 파서에 조각으로 공급할 수 있습니다. 이는 모든 데이터가 처리 될 때까지 &lt;a href=&quot;qxmlsimplereader#parse&quot;&gt;parse&lt;/a&gt; ()에게 점진적으로 작동하도록하고 &lt;a href=&quot;qxmlsimplereader#parseContinue&quot;&gt;parseContinue&lt;/a&gt; () 함수 에 대한 후속 호출을 수행함으로써 달성됩니다 .</target>
        </trans-unit>
        <trans-unit id="161a3dea480d3f0f0c723c9f283dc0ca633fd1f9" translate="yes" xml:space="preserve">
          <source>If you cannot determine a better proxy alternative, use &lt;a href=&quot;qnetworkproxy#ProxyType-enum&quot;&gt;QNetworkProxy::DefaultProxy&lt;/a&gt;, which tells the code querying for a proxy to use a higher alternative. For example, if this factory is set to a &lt;a href=&quot;qnetworkaccessmanager&quot;&gt;QNetworkAccessManager&lt;/a&gt; object, DefaultProxy will tell it to query the application-level proxy settings.</source>
          <target state="translated">더 나은 프록시 대안을 결정할 수없는 경우 &lt;a href=&quot;qnetworkproxy#ProxyType-enum&quot;&gt;QNetworkProxy :: DefaultProxy&lt;/a&gt; 를 사용하면 프록시가 더 높은 대안을 사용하도록 쿼리하도록 코드에 지시합니다. 예를 들어,이 팩토리가 &lt;a href=&quot;qnetworkaccessmanager&quot;&gt;QNetworkAccessManager&lt;/a&gt; 객체로 설정된 경우 DefaultProxy는 애플리케이션 수준 프록시 설정을 쿼리하도록 지시합니다.</target>
        </trans-unit>
        <trans-unit id="47ee22ae7e0b70ca20b7a7ddcb373d31f54e2606" translate="yes" xml:space="preserve">
          <source>If you change the color of the legend, the style of the legend brush is set to &lt;a href=&quot;qt#BrushStyle-enum&quot;&gt;Qt::SolidPattern&lt;/a&gt;.</source>
          <target state="translated">범례의 색상을 변경하면 범례 브러시 스타일이 &lt;a href=&quot;qt#BrushStyle-enum&quot;&gt;Qt :: SolidPattern로&lt;/a&gt; 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="7475bf20fe338cf02b178e9339633535de23b38a" translate="yes" xml:space="preserve">
          <source>If you change the values that a &lt;a href=&quot;qml-qtquick-tableview#rowHeightProvider-prop&quot;&gt;rowHeightProvider&lt;/a&gt; or a &lt;a href=&quot;qml-qtquick-tableview#columnWidthProvider-prop&quot;&gt;columnWidthProvider&lt;/a&gt; return for rows and columns inside the viewport, you must call &lt;a href=&quot;qml-qtquick-tableview#forceLayout-method&quot;&gt;forceLayout&lt;/a&gt;. This informs &lt;a href=&quot;qml-qtquick-tableview&quot;&gt;TableView&lt;/a&gt; that it needs to use the provider functions again to recalculate and update the layout.</source>
          <target state="translated">뷰포트 내의 행과 열에 대해 &lt;a href=&quot;qml-qtquick-tableview#rowHeightProvider-prop&quot;&gt;rowHeightProvider&lt;/a&gt; 또는 &lt;a href=&quot;qml-qtquick-tableview#columnWidthProvider-prop&quot;&gt;columnWidthProvider가&lt;/a&gt; 반환 하는 값을 변경하면 &lt;a href=&quot;qml-qtquick-tableview#forceLayout-method&quot;&gt;forceLayout을&lt;/a&gt; 호출해야합니다 . 그러면 &lt;a href=&quot;qml-qtquick-tableview&quot;&gt;TableView&lt;/a&gt; 에 공급자 함수를 다시 사용하여 레이아웃을 다시 계산하고 업데이트해야합니다.</target>
        </trans-unit>
        <trans-unit id="500f7c2ed4541742fa250d78ebc48a1f3b9006ae" translate="yes" xml:space="preserve">
          <source>If you choose to represent a gesture by a custom &lt;a href=&quot;qgesture&quot;&gt;QGesture&lt;/a&gt; subclass, you will need to reimplement the &lt;a href=&quot;qgesturerecognizer#create&quot;&gt;create&lt;/a&gt;() function to construct instances of your gesture class. Similarly, you may need to reimplement the &lt;a href=&quot;qgesturerecognizer#reset&quot;&gt;reset&lt;/a&gt;() function if your custom gesture objects need to be specially handled when a gesture is canceled.</source>
          <target state="translated">사용자 정의 &lt;a href=&quot;qgesture&quot;&gt;QGesture&lt;/a&gt; 서브 클래스 로 제스처를 표시하도록 선택하면 제스처 클래스의 인스턴스를 구성하기 위해 &lt;a href=&quot;qgesturerecognizer#create&quot;&gt;create&lt;/a&gt; () 함수를 다시 구현해야합니다 . 마찬가지로 제스처가 취소 될 때 사용자 지정 제스처 객체를 특별히 처리해야하는 경우 &lt;a href=&quot;qgesturerecognizer#reset&quot;&gt;reset&lt;/a&gt; () 기능 을 다시 구현해야 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="60298eee3c23b33b1a704690c48b9151a00629d4" translate="yes" xml:space="preserve">
          <source>If you create a custom style, you should take special care when drawing asymmetric elements to make sure that they also look correct in a mirrored layout. An easy way to test your styles is to run applications with the &lt;code&gt;-reverse&lt;/code&gt; command-line option or to call &lt;a href=&quot;qguiapplication#layoutDirection-prop&quot;&gt;QApplication::setLayoutDirection&lt;/a&gt;() in your &lt;code&gt;main()&lt;/code&gt; function.</source>
          <target state="translated">사용자 정의 스타일을 작성하는 경우 비대칭 요소를 그릴 때 미러 레이아웃에서도 올바르게 표시되도록 특별한주의를 기울여야합니다. 스타일을 테스트하는 쉬운 방법은 &lt;code&gt;-reverse&lt;/code&gt; 명령 줄 옵션으로 응용 프로그램을 실행 하거나 &lt;code&gt;main()&lt;/code&gt; 함수 에서 &lt;a href=&quot;qguiapplication#layoutDirection-prop&quot;&gt;QApplication :: setLayoutDirection&lt;/a&gt; () 을 호출하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="17cd68422c27362470960984384c5dc705d301d1" translate="yes" xml:space="preserve">
          <source>If you create a new widget we strongly recommend that you use the colors in the palette rather than hard-coding specific colors.</source>
          <target state="translated">새 위젯을 작성하는 경우 특정 색상을 하드 코딩하는 대신 팔레트의 색상을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="3f4462d3119b6a25e2fe9303c0a819f7485e1e86" translate="yes" xml:space="preserve">
          <source>If you create a subclass of &lt;a href=&quot;qgraphicslayoutitem&quot;&gt;QGraphicsLayoutItem&lt;/a&gt; and reimplement its virtual functions, you will enable the layout to resize and position your item along with other QGraphicsLayoutItems including &lt;a href=&quot;graphicsview#qgraphicswidget&quot;&gt;QGraphicsWidget&lt;/a&gt; and &lt;a href=&quot;graphicsview#qgraphicslayout&quot;&gt;QGraphicsLayout&lt;/a&gt;.</source>
          <target state="translated">당신의 서브 클래스 만드는 경우 &lt;a href=&quot;qgraphicslayoutitem&quot;&gt;QGraphicsLayoutItem을&lt;/a&gt; 하고 가상 함수를 다시 구현, 당신은을 포함하여 다른 QGraphicsLayoutItems와 함께 항목을 크기를 조정하고 위치로 레이아웃을 가능하게 할 것이다 &lt;a href=&quot;graphicsview#qgraphicswidget&quot;&gt;QGraphicsWidget&lt;/a&gt; 및 &lt;a href=&quot;graphicsview#qgraphicslayout&quot;&gt;QGraphicsLayout&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fbd1dc4f7124280b641957b9c985d0980cf1e5a2" translate="yes" xml:space="preserve">
          <source>If you create an element or attribute with &lt;a href=&quot;qdomdocument#createElement&quot;&gt;QDomDocument::createElement&lt;/a&gt;() or &lt;a href=&quot;qdomdocument#createAttribute&quot;&gt;QDomDocument::createAttribute&lt;/a&gt;(), the prefix will be an empty string. If you use &lt;a href=&quot;qdomdocument#createElementNS&quot;&gt;QDomDocument::createElementNS&lt;/a&gt;() or &lt;a href=&quot;qdomdocument#createAttributeNS&quot;&gt;QDomDocument::createAttributeNS&lt;/a&gt;() instead, the prefix will not be an empty string; but it might be an empty string if the name does not have a prefix.</source>
          <target state="translated">&lt;a href=&quot;qdomdocument#createElement&quot;&gt;QDomDocument :: createElement&lt;/a&gt; () 또는 &lt;a href=&quot;qdomdocument#createAttribute&quot;&gt;QDomDocument :: createAttribute&lt;/a&gt; () 로 요소 또는 속성을 작성하면 접 두부가 빈 문자열이됩니다. 당신이 사용하는 경우 &lt;a href=&quot;qdomdocument#createElementNS&quot;&gt;QDomDocument ::에는 createElementNS&lt;/a&gt; () 또는 &lt;a href=&quot;qdomdocument#createAttributeNS&quot;&gt;QDomDocument :: createAttributeNS는&lt;/a&gt; () 대신에, 접두사는 빈 문자열되지 않습니다; 이름에 접두사가 없으면 빈 문자열 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a8af07b0934236da5d1098a000948ac0c59d159" translate="yes" xml:space="preserve">
          <source>If you create multiple database connections, specify a unique connection name for each one, when you call &lt;a href=&quot;qsqldatabase#addDatabase&quot;&gt;addDatabase&lt;/a&gt;(). Use &lt;a href=&quot;qsqldatabase#database&quot;&gt;database&lt;/a&gt;() with a connection name to get that connection. Use &lt;a href=&quot;qsqldatabase#removeDatabase&quot;&gt;removeDatabase&lt;/a&gt;() with a connection name to remove a connection. &lt;a href=&quot;qsqldatabase&quot;&gt;QSqlDatabase&lt;/a&gt; outputs a warning if you try to remove a connection referenced by other &lt;a href=&quot;qsqldatabase&quot;&gt;QSqlDatabase&lt;/a&gt; objects. Use &lt;a href=&quot;qsqldatabase#contains&quot;&gt;contains&lt;/a&gt;() to see if a given connection name is in the list of connections.</source>
          <target state="translated">여러 데이터베이스 연결을 작성하는 경우 &lt;a href=&quot;qsqldatabase#addDatabase&quot;&gt;addDatabase&lt;/a&gt; () 를 호출 할 때 각각에 고유 한 연결 이름을 지정하십시오 . 사용하여 &lt;a href=&quot;qsqldatabase#database&quot;&gt;데이터베이스를&lt;/a&gt; 해당 연결을 얻을 수있는 연결 이름 (). 사용 &lt;a href=&quot;qsqldatabase#removeDatabase&quot;&gt;removeDatabase를&lt;/a&gt; 연결을 제거하기 위해 연결 이름 (). 다른 &lt;a href=&quot;qsqldatabase&quot;&gt;QSqlDatabase&lt;/a&gt; 오브젝트가 참조하는 연결을 제거하려고하면 &lt;a href=&quot;qsqldatabase&quot;&gt;QSqlDatabase&lt;/a&gt; 가 경고를 출력 합니다. &lt;a href=&quot;qsqldatabase#contains&quot;&gt;포함&lt;/a&gt; ()을 사용 하여 지정된 연결 이름이 연결 목록에 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="7646273ae2dbacaa23658a4e7083837be610751f" translate="yes" xml:space="preserve">
          <source>If you create new widgets in the mousePressEvent() the &lt;a href=&quot;qwidget#mouseReleaseEvent&quot;&gt;mouseReleaseEvent&lt;/a&gt;() may not end up where you expect, depending on the underlying window system (or X11 window manager), the widgets' location and maybe more.</source>
          <target state="translated">mousePressEvent ()에서 새 위젯을 작성 하면 기본 창 시스템 (또는 X11 창 관리자), 위젯 위치 및 기타에 따라 &lt;a href=&quot;qwidget#mouseReleaseEvent&quot;&gt;mouseReleaseEvent&lt;/a&gt; ()가 예상 한 위치에서 끝나지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8099c41c6c4619a93004cbcf0c3515483d52ce0b" translate="yes" xml:space="preserve">
          <source>If you declare the</source>
          <target state="translated">당신이 선언하면</target>
        </trans-unit>
        <trans-unit id="9e4643eafbd0d4a96807a4ddcf5f41ce29cc0458" translate="yes" xml:space="preserve">
          <source>If you develop components you might want to control who is able to instantiate those components. Since the server binary can be shipped to and registered on any client machine it is possible for anybody to use those components in his own software.</source>
          <target state="translated">컴포넌트를 개발하는 경우 해당 컴포넌트를 인스턴스화 할 수있는 사람을 제어 할 수 있습니다. 서버 바이너리는 모든 클라이언트 시스템으로 배송 및 등록 할 수 있으므로 누구나 자신의 소프트웨어에서 해당 구성 요소를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ec1ab807ee3535bc730f9e500858259db3a5b6a" translate="yes" xml:space="preserve">
          <source>If you develop on a Linux machine, you can also run the compositor within a window on your development machine. This lets you run clients in an environment that closely resembles the target device. Without rebuilding the client, you can also run it with &lt;code&gt;-platform wayland&lt;/code&gt; to run it inside the compositor. If you use &lt;code&gt;-platform xcb&lt;/code&gt; (for X11), you can run the client on the desktop. In other words, you can start developing your clients before the compositor is ready for use.</source>
          <target state="translated">Linux 시스템에서 개발하는 경우 개발 시스템의 창에서 컴포 지터를 실행할 수도 있습니다. 이를 통해 대상 장치와 매우 유사한 환경에서 클라이언트를 실행할 수 있습니다. 클라이언트를 재 구축하지 않고 &lt;code&gt;-platform wayland&lt;/code&gt; 로 실행하여 컴포 지터 내에서 실행할 수도 있습니다. &lt;code&gt;-platform xcb&lt;/code&gt; (X11의 경우)를 사용 하면 데스크탑에서 클라이언트를 실행할 수 있습니다. 즉, 컴포 지터를 사용할 준비가되기 전에 클라이언트 개발을 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="afa8bf4954cb5202a30b0fc12f02b6b538c3177e" translate="yes" xml:space="preserve">
          <source>If you did not build Qt with RPATH enabled, you can place the Qt runtime components in any folder in the file system. The following environment variables should point to valid locations assuming that the Qt installation is located in &lt;code&gt;&amp;lt;Qt-install-path&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">RPATH를 사용하여 Qt를 빌드하지 않은 경우 Qt 런타임 구성 요소를 파일 시스템의 임의의 폴더에 배치 할 수 있습니다. Qt 설치가 &lt;code&gt;&amp;lt;Qt-install-path&amp;gt;&lt;/code&gt; 에 있다고 가정하면 다음 환경 변수는 유효한 위치를 가리켜 야합니다 .</target>
        </trans-unit>
        <trans-unit id="f5ac96c3608663c3ee69d2ea4c3f3259795c6549" translate="yes" xml:space="preserve">
          <source>If you disable a parent item, all its children will also be disabled. If you enable a parent item, all children will be enabled, unless they have been explicitly disabled (i.e., if you call setEnabled(false) on a child, it will not be reenabled if its parent is disabled, and then enabled again).</source>
          <target state="translated">상위 항목을 비활성화하면 모든 하위 항목도 비활성화됩니다. 부모 항목을 활성화하면 명시 적으로 비활성화되지 않은 모든 하위 항목이 활성화됩니다 (예 : 하위 항목에서 setEnabled (false)를 호출하면 상위 항목이 비활성화 된 후 다시 활성화 될 수 있음).</target>
        </trans-unit>
        <trans-unit id="b84a34e331b907bd7ec85f721effe578cfa854d4" translate="yes" xml:space="preserve">
          <source>If you disable the &lt;code&gt;const char *&lt;/code&gt; to &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; automatic conversion by compiling your software with the macro &lt;code&gt;QT_NO_CAST_FROM_ASCII&lt;/code&gt; defined, you'll be very likely to catch any strings you are missing. See &lt;a href=&quot;qstring#fromUtf8&quot;&gt;QString::fromUtf8&lt;/a&gt;() and &lt;a href=&quot;qstring#fromLatin1&quot;&gt;QString::fromLatin1&lt;/a&gt;() for more information.</source>
          <target state="translated">매크로 &lt;code&gt;QT_NO_CAST_FROM_ASCII&lt;/code&gt; 가 정의 된 상태에서 소프트웨어를 컴파일하여 &lt;code&gt;const char *&lt;/code&gt; 를 &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; 자동 변환으로 비활성화하면 누락 된 문자열을 잡을 가능성이 큽니다. 자세한 정보는 &lt;a href=&quot;qstring#fromUtf8&quot;&gt;QString :: fromUtf8&lt;/a&gt; () 및 &lt;a href=&quot;qstring#fromLatin1&quot;&gt;QString :: fromLatin1&lt;/a&gt; ()을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7c6a1ddfc7d45f56ca6150fe2e413b375a67c3c1" translate="yes" xml:space="preserve">
          <source>If you do not see the entries for the gamepad you are using, check if the &lt;code&gt;joystick&lt;/code&gt; package is installed. If not, install the package and &lt;code&gt;grep&lt;/code&gt; the &lt;code&gt;dmesg&lt;/code&gt; logs again.</source>
          <target state="translated">사용중인 게임 패드에 대한 항목이 표시되지 않으면 &lt;code&gt;joystick&lt;/code&gt; 패키지가 설치되어 있는지 확인하십시오 . 그렇지 않은 경우 패키지를 설치 하고 &lt;code&gt;dmesg&lt;/code&gt; 로그를 다시 &lt;code&gt;grep&lt;/code&gt; 하십시오.</target>
        </trans-unit>
        <trans-unit id="ca2f383e2bf046db28456505c081643e252eeb5d" translate="yes" xml:space="preserve">
          <source>If you do not specify a format, the format of the decoded audio itself will be used. Otherwise, some format conversion will be applied.</source>
          <target state="translated">형식을 지정하지 않으면 디코딩 된 오디오 자체 형식이 사용됩니다. 그렇지 않으면 일부 형식 변환이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="de1635a44cea7651e746c1686155d7406a62dc52" translate="yes" xml:space="preserve">
          <source>If you do not want all plugins added to QTPLUGIN to be automatically linked, remove &lt;code&gt;import_plugins&lt;/code&gt; from the &lt;code&gt;CONFIG&lt;/code&gt; variable:</source>
          <target state="translated">QTPLUGIN에 추가 된 모든 플러그인이 자동으로 링크 &lt;code&gt;import_plugins&lt;/code&gt; 않게하려면 &lt;code&gt;CONFIG&lt;/code&gt; 변수 에서 import_plugins 를 제거하십시오 .</target>
        </trans-unit>
        <trans-unit id="cdd8ad11a5a8433d7c4e01c15d5566bd728f5503" translate="yes" xml:space="preserve">
          <source>If you do not want particles to automatically die after a time, for example if you wish to dispose of them manually, set lifeSpan to Emitter.InfiniteLife.</source>
          <target state="translated">예를 들어 입자를 수동으로 폐기하려는 경우와 같이 시간이 지난 후에 입자가 자동으로 죽지 않게하려면 lifeSpan을 Emitter.InfiniteLife로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="137e6ed64703982d6f6a1b7c58462d03cb2952de" translate="yes" xml:space="preserve">
          <source>If you do not want the line edit to have a context menu, you can set its &lt;a href=&quot;qwidget#contextMenuPolicy-prop&quot;&gt;contextMenuPolicy&lt;/a&gt; to &lt;a href=&quot;qt#ContextMenuPolicy-enum&quot;&gt;Qt::NoContextMenu&lt;/a&gt;. If you want to customize the context menu, reimplement this function. If you want to extend the standard context menu, reimplement this function, call &lt;a href=&quot;qlineedit#createStandardContextMenu&quot;&gt;createStandardContextMenu&lt;/a&gt;() and extend the menu returned.</source>
          <target state="translated">행 편집에 컨텍스트 메뉴가 없도록하려면 &lt;a href=&quot;qwidget#contextMenuPolicy-prop&quot;&gt;contextMenuPolicy&lt;/a&gt; 를 &lt;a href=&quot;qt#ContextMenuPolicy-enum&quot;&gt;Qt :: NoContextMenu&lt;/a&gt; 로 설정할 수 있습니다 . 상황에 맞는 메뉴를 사용자 정의하려면이 기능을 다시 구현하십시오. 표준 컨텍스트 메뉴를 확장하려면이 함수를 다시 구현하고 &lt;a href=&quot;qlineedit#createStandardContextMenu&quot;&gt;createStandardContextMenu&lt;/a&gt; ()를 호출 하고 반환 된 메뉴를 확장하십시오.</target>
        </trans-unit>
        <trans-unit id="fc81d4dd3f76f07754477505ca4dd2bf14711219" translate="yes" xml:space="preserve">
          <source>If you do not want the text edit to have a context menu, you can set its &lt;a href=&quot;qwidget#contextMenuPolicy-prop&quot;&gt;contextMenuPolicy&lt;/a&gt; to &lt;a href=&quot;qt#ContextMenuPolicy-enum&quot;&gt;Qt::NoContextMenu&lt;/a&gt;. If you want to customize the context menu, reimplement this function. If you want to extend the standard context menu, reimplement this function, call &lt;a href=&quot;qplaintextedit#createStandardContextMenu&quot;&gt;createStandardContextMenu&lt;/a&gt;() and extend the menu returned.</source>
          <target state="translated">텍스트 편집에 상황에 맞는 메뉴가 없도록하려면 &lt;a href=&quot;qwidget#contextMenuPolicy-prop&quot;&gt;contextMenuPolicy&lt;/a&gt; 를 &lt;a href=&quot;qt#ContextMenuPolicy-enum&quot;&gt;Qt :: NoContextMenu&lt;/a&gt; 로 설정할 수 있습니다 . 상황에 맞는 메뉴를 사용자 정의하려면이 기능을 다시 구현하십시오. 표준 컨텍스트 메뉴를 확장하려면이 함수를 다시 구현하고 &lt;a href=&quot;qplaintextedit#createStandardContextMenu&quot;&gt;createStandardContextMenu&lt;/a&gt; ()를 호출 하고 반환 된 메뉴를 확장하십시오.</target>
        </trans-unit>
        <trans-unit id="264b0fb3179ab096c73c0b90036579cf8921a2f4" translate="yes" xml:space="preserve">
          <source>If you do not want the text edit to have a context menu, you can set its &lt;a href=&quot;qwidget#contextMenuPolicy-prop&quot;&gt;contextMenuPolicy&lt;/a&gt; to &lt;a href=&quot;qt#ContextMenuPolicy-enum&quot;&gt;Qt::NoContextMenu&lt;/a&gt;. If you want to customize the context menu, reimplement this function. If you want to extend the standard context menu, reimplement this function, call &lt;a href=&quot;qtextedit#createStandardContextMenu&quot;&gt;createStandardContextMenu&lt;/a&gt;() and extend the menu returned.</source>
          <target state="translated">텍스트 편집에 상황에 맞는 메뉴가 없도록하려면 &lt;a href=&quot;qwidget#contextMenuPolicy-prop&quot;&gt;contextMenuPolicy&lt;/a&gt; 를 &lt;a href=&quot;qt#ContextMenuPolicy-enum&quot;&gt;Qt :: NoContextMenu&lt;/a&gt; 로 설정할 수 있습니다 . 상황에 맞는 메뉴를 사용자 정의하려면이 기능을 다시 구현하십시오. 표준 컨텍스트 메뉴를 확장하려면이 함수를 다시 구현하고 &lt;a href=&quot;qtextedit#createStandardContextMenu&quot;&gt;createStandardContextMenu&lt;/a&gt; ()를 호출 하고 반환 된 메뉴를 확장하십시오.</target>
        </trans-unit>
        <trans-unit id="414a4b42e3e1fdf1f4fbba5afc1d7f27ca70c7d1" translate="yes" xml:space="preserve">
          <source>If you do not want to include all data contained in the model, or the autogenerated rows and columns are not ordered as you wish, you can specify which rows and columns should be included and in which order by defining an explicit list of categories for either or both of rows and columns.</source>
          <target state="translated">모델에 포함 된 모든 데이터를 포함하지 않으려는 경우 또는 자동 생성 된 행 및 열이 원하는 순서대로 정렬되지 않은 경우 다음 중 하나에 대한 명시 적 범주 목록을 정의하여 포함해야하는 행 및 열과 순서를 지정할 수 있습니다. 또는 행과 열 모두.</target>
        </trans-unit>
        <trans-unit id="057684615c560d24fa3d7850ba2b1690d752365f" translate="yes" xml:space="preserve">
          <source>If you do not want to provide plugins for your accessibility interfaces, you can use an interface factory (&lt;a href=&quot;qaccessible#InterfaceFactory-typedef&quot;&gt;QAccessible::InterfaceFactory&lt;/a&gt;), which is the recommended way to provide accessible interfaces in a statically-linked application.</source>
          <target state="translated">내게 필요한 옵션 인터페이스에 플러그인을 제공하지 않으려면 정적으로 링크 된 응용 프로그램에서 액세스 가능한 인터페이스를 제공하는 권장 방법 인 인터페이스 팩토리 ( &lt;a href=&quot;qaccessible#InterfaceFactory-typedef&quot;&gt;QAccessible :: InterfaceFactory&lt;/a&gt; )를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="40d74a535b955d54f4d75584d27c82f8baeb3109" translate="yes" xml:space="preserve">
          <source>If you do not want to use the &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtsql-attribution-sqlite.html#sqlite&quot;&gt;SQLite&lt;/a&gt; library included with Qt, you can pass &lt;code&gt;-system-sqlite&lt;/code&gt; to the configure script to use the &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtsql-attribution-sqlite.html#sqlite&quot;&gt;SQLite&lt;/a&gt; libraries of the operating system. This is recommended whenever possible, as it reduces the installation size and removes one component for which you need to track security advisories.</source>
          <target state="translated">Qt에 포함 된 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtsql-attribution-sqlite.html#sqlite&quot;&gt;SQLite&lt;/a&gt; 라이브러리 를 사용하지 않으려면 운영 체제 의 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtsql-attribution-sqlite.html#sqlite&quot;&gt;SQLite&lt;/a&gt; 라이브러리 를 사용하기 위해 &lt;code&gt;-system-sqlite&lt;/code&gt; 를 구성 스크립트에 전달할 수 있습니다 . 설치 크기를 줄이고 보안 권고를 추적해야하는 하나의 구성 요소를 제거하므로 가능할 때마다 권장됩니다.</target>
        </trans-unit>
        <trans-unit id="343aa26528918bf8eae80d3edfbc84e50deb8988" translate="yes" xml:space="preserve">
          <source>If you do not wish to store the address of the reading you may use the &lt;a href=&quot;qsensorbackend#reading&quot;&gt;reading&lt;/a&gt;() method to get it again later.</source>
          <target state="translated">판독 주소를 저장하지 않으려면 나중에 다시 &lt;a href=&quot;qsensorbackend#reading&quot;&gt;읽기&lt;/a&gt; 위해 reading () 메소드를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="59343985f92053a6f90ac9774ec6c299a593e440" translate="yes" xml:space="preserve">
          <source>If you do reimplement this function,</source>
          <target state="translated">이 기능을 다시 구현하면</target>
        </trans-unit>
        <trans-unit id="7459f1c7db2abb955632f345eb9bcbc56a6e2474" translate="yes" xml:space="preserve">
          <source>If you do reimplement this function, you should call the base class implementation.</source>
          <target state="translated">이 함수를 다시 구현하면 기본 클래스 구현을 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="47d6e81d9e44e07739dfe3bc8280ba53c8a5bed7" translate="yes" xml:space="preserve">
          <source>If you don't care about overflow, or you know that overflow cannot occur, you can ignore the &lt;code&gt;overflow()&lt;/code&gt; signal, i.e. don't connect it to any slot.</source>
          <target state="translated">오버플로에 신경 쓰지 않거나 오버플로가 발생할 수 없다는 것을 알고 있으면 &lt;code&gt;overflow()&lt;/code&gt; 신호를 무시할 수 있습니다 . 즉, 어떤 슬롯에도 연결하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="c3f8db5f627a6412eb185b92c3a869ae90aabc98" translate="yes" xml:space="preserve">
          <source>If you don't include the function name with the &lt;b&gt;\overload&lt;/b&gt; command, then instead of the &quot;This function overloads...&quot; line with the link to the documentation for the primary version, you get the old standard line:</source>
          <target state="translated">&lt;b&gt;\ overload&lt;/b&gt; 명령에 함수 이름을 포함시키지 않으면 기본 버전의 문서에 대한 링크가있는 &quot;이 함수 오버로드 ...&quot;행 대신 이전 표준 행이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="f4b13e746ac6ed5f37e7487d2823fe3bfc4ac180" translate="yes" xml:space="preserve">
          <source>If you don't need C++11 noexcept semantics, e.g. because your function can't possibly throw, don't use this macro, use &lt;a href=&quot;qtglobal#Q_DECL_NOTHROW&quot;&gt;Q_DECL_NOTHROW&lt;/a&gt; instead.</source>
          <target state="translated">C ++ 11 noexcept 시맨틱이 필요하지 않은 경우, 예를 들어 함수가 던질 수 &lt;a href=&quot;qtglobal#Q_DECL_NOTHROW&quot;&gt;없으므로이&lt;/a&gt; 매크로를 사용 하지 말고 대신 Q_DECL_NOTHROW를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f4aac5a2cb5b5ba20fa581bac2ac4ecdfa698a32" translate="yes" xml:space="preserve">
          <source>If you don't set at least the content and error handlers, the parser will fall back on its default behavior---and will do nothing.</source>
          <target state="translated">최소한 내용 및 오류 처리기를 설정하지 않으면 파서는 기본 동작으로 돌아가고 아무것도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5041c0834c26c12411e9d4b9de6cf518e963de2e" translate="yes" xml:space="preserve">
          <source>If you don't use the return value, &lt;a href=&quot;qcontiguouscache#removeFirst&quot;&gt;removeFirst&lt;/a&gt;() is more efficient.</source>
          <target state="translated">반환 값을 사용하지 않으면 &lt;a href=&quot;qcontiguouscache#removeFirst&quot;&gt;removeFirst&lt;/a&gt; ()가 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="6f0b3ec2e3f2240b0c9bd99bec86af00d556f943" translate="yes" xml:space="preserve">
          <source>If you don't use the return value, &lt;a href=&quot;qcontiguouscache#removeLast&quot;&gt;removeLast&lt;/a&gt;() is more efficient.</source>
          <target state="translated">반환 값을 사용하지 않으면 &lt;a href=&quot;qcontiguouscache#removeLast&quot;&gt;removeLast&lt;/a&gt; ()가 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="c3eda638d5401c3d46365a3d5398cb614bb77093" translate="yes" xml:space="preserve">
          <source>If you don't use the return value, &lt;a href=&quot;qhash#remove&quot;&gt;remove&lt;/a&gt;() is more efficient.</source>
          <target state="translated">반환 값을 사용하지 않으면 &lt;a href=&quot;qhash#remove&quot;&gt;remove&lt;/a&gt; ()가 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="6238b630b08739411aeb3e4860079290f1daeb6a" translate="yes" xml:space="preserve">
          <source>If you don't use the return value, &lt;a href=&quot;qjsonarray#removeAt&quot;&gt;removeAt&lt;/a&gt;() is more efficient.</source>
          <target state="translated">반환 값을 사용하지 않으면 &lt;a href=&quot;qjsonarray#removeAt&quot;&gt;removeAt&lt;/a&gt; ()가 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="16389cdcb2d83186dca00f19daf34b971a56ae6c" translate="yes" xml:space="preserve">
          <source>If you don't use the return value, &lt;a href=&quot;qlinkedlist#removeFirst&quot;&gt;removeFirst&lt;/a&gt;() is more efficient.</source>
          <target state="translated">반환 값을 사용하지 않으면 &lt;a href=&quot;qlinkedlist#removeFirst&quot;&gt;removeFirst&lt;/a&gt; ()가 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="e532d96c70aba46349957efbde0774df9e51d4ff" translate="yes" xml:space="preserve">
          <source>If you don't use the return value, &lt;a href=&quot;qlinkedlist#removeLast&quot;&gt;removeLast&lt;/a&gt;() is more efficient.</source>
          <target state="translated">반환 값을 사용하지 않으면 &lt;a href=&quot;qlinkedlist#removeLast&quot;&gt;removeLast&lt;/a&gt; ()가 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="2c512ded4975686b35f1fb701d84a9b7cd1d15e6" translate="yes" xml:space="preserve">
          <source>If you don't use the return value, &lt;a href=&quot;qlist#removeAt&quot;&gt;removeAt&lt;/a&gt;() is more efficient.</source>
          <target state="translated">반환 값을 사용하지 않으면 &lt;a href=&quot;qlist#removeAt&quot;&gt;removeAt&lt;/a&gt; ()가 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="3580c79a00255579ecf1dc06e86b78e8a44314f1" translate="yes" xml:space="preserve">
          <source>If you don't use the return value, &lt;a href=&quot;qlist#removeFirst&quot;&gt;removeFirst&lt;/a&gt;() is more efficient.</source>
          <target state="translated">반환 값을 사용하지 않으면 &lt;a href=&quot;qlist#removeFirst&quot;&gt;removeFirst&lt;/a&gt; ()가 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="9e0c4f65190d8ec00e741c79f6a58ec29cd4558a" translate="yes" xml:space="preserve">
          <source>If you don't use the return value, &lt;a href=&quot;qlist#removeLast&quot;&gt;removeLast&lt;/a&gt;() is more efficient.</source>
          <target state="translated">반환 값을 사용하지 않으면 &lt;a href=&quot;qlist#removeLast&quot;&gt;removeLast&lt;/a&gt; ()가 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="7b89e12bb904cadd6f68a456bf8a4d218049020f" translate="yes" xml:space="preserve">
          <source>If you don't use the return value, &lt;a href=&quot;qmap#remove&quot;&gt;remove&lt;/a&gt;() is more efficient.</source>
          <target state="translated">반환 값을 사용하지 않으면 &lt;a href=&quot;qmap#remove&quot;&gt;remove&lt;/a&gt; ()가 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="8b4317833de468d14b7193cf24bfa578254f1bac" translate="yes" xml:space="preserve">
          <source>If you don't use the return value, &lt;a href=&quot;qvector#removeLast&quot;&gt;removeLast&lt;/a&gt;() is more efficient.</source>
          <target state="translated">반환 값을 사용하지 않으면 &lt;a href=&quot;qvector#removeLast&quot;&gt;removeLast&lt;/a&gt; ()가 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="98a6cadcb257cc7405bae4f90b3e1e2945c7348f" translate="yes" xml:space="preserve">
          <source>If you don't want to reuse items or if the &lt;a href=&quot;qml-qtquick-tableview#delegate-prop&quot;&gt;delegate&lt;/a&gt; cannot support it, you can set the &lt;a href=&quot;qml-qtquick-tableview#reuseItems-prop&quot;&gt;reuseItems&lt;/a&gt; property to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">항목을 재사용하지 않으려는 경우 또는 &lt;a href=&quot;qml-qtquick-tableview#delegate-prop&quot;&gt;대리자&lt;/a&gt; 가 지원할 수없는 경우 &lt;a href=&quot;qml-qtquick-tableview#reuseItems-prop&quot;&gt;reuseItems&lt;/a&gt; 속성을 &lt;code&gt;false&lt;/code&gt; 로 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="838b97a9339f2b2d2c2a71a001cc2517e1ae6341" translate="yes" xml:space="preserve">
          <source>If you don't want to use frameworks, simply configure Qt with &lt;code&gt;-no-framework&lt;/code&gt;.</source>
          <target state="translated">프레임 워크를 사용하지 않으려면 &lt;code&gt;-no-framework&lt;/code&gt; 로 Qt를 구성하십시오 .</target>
        </trans-unit>
        <trans-unit id="0a836131e0f2704bfd556204956a2e5fd4bc8cef" translate="yes" xml:space="preserve">
          <source>If you draw any graphics items on top of a chart containing an accelerated series, the accelerated series is drawn over those items.</source>
          <target state="translated">가속 계열이 포함 된 차트 위에 그래픽 항목을 그리면 해당 항목 위에 가속 계열이 그려집니다.</target>
        </trans-unit>
        <trans-unit id="70073c2e33637d94e0f741698ec0d2592dfc1ea1" translate="yes" xml:space="preserve">
          <source>If you enable a focus policy (i.e., not &lt;a href=&quot;qt#FocusPolicy-enum&quot;&gt;Qt::NoFocus&lt;/a&gt;), &lt;a href=&quot;graphicsview#qgraphicswidget&quot;&gt;QGraphicsWidget&lt;/a&gt; will automatically enable the &lt;a href=&quot;qgraphicsitem#GraphicsItemFlag-enum&quot;&gt;ItemIsFocusable&lt;/a&gt; flag. Setting &lt;a href=&quot;qt#FocusPolicy-enum&quot;&gt;Qt::NoFocus&lt;/a&gt; on a widget will clear the &lt;a href=&quot;qgraphicsitem#GraphicsItemFlag-enum&quot;&gt;ItemIsFocusable&lt;/a&gt; flag. If the widget currently has keyboard focus, the widget will automatically lose focus.</source>
          <target state="translated">포커스 정책을 활성화하면 (예 : &lt;a href=&quot;qt#FocusPolicy-enum&quot;&gt;Qt :: NoFocus 아님&lt;/a&gt; ) &lt;a href=&quot;graphicsview#qgraphicswidget&quot;&gt;QGraphicsWidget&lt;/a&gt; 은 자동으로 &lt;a href=&quot;qgraphicsitem#GraphicsItemFlag-enum&quot;&gt;ItemIsFocusable&lt;/a&gt; 플래그를 활성화합니다 . 위젯에서 &lt;a href=&quot;qt#FocusPolicy-enum&quot;&gt;Qt :: NoFocus&lt;/a&gt; 를 설정 하면 &lt;a href=&quot;qgraphicsitem#GraphicsItemFlag-enum&quot;&gt;ItemIsFocusable&lt;/a&gt; 플래그 가 지워집니다 . 위젯에 현재 키보드 포커스가있는 경우 위젯은 자동으로 포커스를 잃습니다.</target>
        </trans-unit>
        <trans-unit id="41dc335fec90b30b3454b0f635c1e50125bda194" translate="yes" xml:space="preserve">
          <source>If you enable this option, a rubber band control is used to represent the subwindow's outline, and the user moves this instead of the subwindow itself. As a result, the subwindow remains in its original position until the move operation has completed, at which time a &lt;a href=&quot;qmoveevent&quot;&gt;QMoveEvent&lt;/a&gt; is sent to the window. By default, this option is disabled.</source>
          <target state="translated">이 옵션을 활성화하면 고무 밴드 컨트롤을 사용하여 하위 창의 외곽선을 나타내며 사용자는 하위 창 자체 대신이를 이동합니다. 결과적으로, 서브 윈도우는 이동 조작이 완료 될 때까지 원래 위치를 유지하며, 이때 &lt;a href=&quot;qmoveevent&quot;&gt;QMoveEvent&lt;/a&gt; 가 창으로 전송됩니다. 기본적으로이 옵션은 비활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="33f5358221b7caed93fe5c10ea0c248f1b41a5c2" translate="yes" xml:space="preserve">
          <source>If you enable this option, a rubber band control is used to represent the subwindow's outline, and the user resizes this instead of the subwindow itself. As a result, the subwindow maintains its original position and size until the resize operation has been completed, at which time it will receive a single &lt;a href=&quot;qresizeevent&quot;&gt;QResizeEvent&lt;/a&gt;. By default, this option is disabled.</source>
          <target state="translated">이 옵션을 활성화하면 고무 밴드 컨트롤을 사용하여 하위 창의 외곽선을 나타내며 사용자는 하위 창 자체 대신 크기를 조정합니다. 결과적으로, 서브 윈도우는 크기 조정 작업이 완료 될 때까지 원래의 위치와 크기를 유지하며, 이때 단일 &lt;a href=&quot;qresizeevent&quot;&gt;QResizeEvent&lt;/a&gt; 가 수신됩니다 . 기본적으로이 옵션은 비활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee9e15e9e7e88dd472e71c94c981951ef20f8571" translate="yes" xml:space="preserve">
          <source>If you enable this option, the widget's &lt;a href=&quot;qwidget#mask&quot;&gt;QWidget::mask&lt;/a&gt;() is ignored when rendering into the target. By default, this option is disabled.</source>
          <target state="translated">이 옵션을 사용 하면 대상으로 렌더링 할 때 위젯의 &lt;a href=&quot;qwidget#mask&quot;&gt;QWidget :: mask&lt;/a&gt; ()가 무시됩니다. 기본적으로이 옵션은 비활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="29baace13a9463b22a74a74a22cd35d6e24e59e4" translate="yes" xml:space="preserve">
          <source>If you enable this option, the widget's background is rendered into the target even if &lt;a href=&quot;qwidget#autoFillBackground-prop&quot;&gt;autoFillBackground&lt;/a&gt; is not set. By default, this option is enabled.</source>
          <target state="translated">이 옵션을 사용하면 &lt;a href=&quot;qwidget#autoFillBackground-prop&quot;&gt;autoFillBackground&lt;/a&gt; 가 설정되지 않은 경우에도 위젯의 배경이 대상에 렌더링됩니다 . 기본적으로이 옵션은 활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ca699664ee5b0a2558f5e46c84fccb5c7a7c628" translate="yes" xml:space="preserve">
          <source>If you enable this option, the widget's children are rendered recursively into the target. By default, this option is enabled.</source>
          <target state="translated">이 옵션을 사용하면 위젯의 하위가 대상으로 재귀 적으로 렌더링됩니다. 기본적으로이 옵션은 활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a44f4aa208acbf490ca3cc98609e0f8457532a5" translate="yes" xml:space="preserve">
          <source>If you encounter issues, always set the &lt;code&gt;QSG_INFO&lt;/code&gt; and &lt;code&gt;QT_D3D_DEBUG&lt;/code&gt; environment variables to &lt;code&gt;1&lt;/code&gt;, to get debug and warning messages printed on the debug output. &lt;code&gt;QT_D3D_DEBUG&lt;/code&gt; enables the Direct3D debug layer.</source>
          <target state="translated">당신은 문제가 발생할 경우, 항상 설정 &lt;code&gt;QSG_INFO&lt;/code&gt; 및 &lt;code&gt;QT_D3D_DEBUG&lt;/code&gt; 에 환경 변수를 &lt;code&gt;1&lt;/code&gt; 디버그 및 디버그 출력에 인쇄 경고 메시지를 얻을. &lt;code&gt;QT_D3D_DEBUG&lt;/code&gt; 는 Direct3D 디버그 계층을 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="ad40d497502697850fda1deea9f60068b4a3ecc3" translate="yes" xml:space="preserve">
          <source>If you exclusively use function objects then you will get compile time errors if you attempt to use a function not included in that version and profile. This is obviously a lot easier to debug than undefined behavior at run time.</source>
          <target state="translated">함수 객체를 독점적으로 사용하는 경우 해당 버전 및 프로파일에 포함되지 않은 함수를 사용하려고하면 컴파일 시간 오류가 발생합니다. 런타임에 정의되지 않은 동작보다 디버그하기가 훨씬 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="ec4c5fc223f0c10dcc5beafaa6caffa95226dcd5" translate="yes" xml:space="preserve">
          <source>If you experience very slow access of the ODBC datasource, make sure that ODBC call tracing is turned off in the ODBC datasource manager.</source>
          <target state="translated">ODBC 데이터 소스에 대한 액세스 속도가 매우 느리면 ODBC 데이터 소스 관리자에서 ODBC 호출 추적이 해제되어 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="28e8c8e90363713071c08bffc584af58a728c846" translate="yes" xml:space="preserve">
          <source>If you get linkage errors in the final building phase of your program, saying that &lt;code&gt;YourClass::className()&lt;/code&gt; is undefined or that &lt;code&gt;YourClass&lt;/code&gt; lacks a vtable, something has been done wrong. Most often, you have forgotten to compile or &lt;code&gt;#include&lt;/code&gt; the moc-generated C++ code, or (in the former case) include that object file in the link command. If you use &lt;code&gt;qmake&lt;/code&gt;, try rerunning it to update your makefile. This should do the trick.</source>
          <target state="translated">프로그램의 최종 빌드 단계에서 링크 오류가 발생하면 &lt;code&gt;YourClass::className()&lt;/code&gt; 이 정의되지 않았거나 &lt;code&gt;YourClass&lt;/code&gt; 에 vtable이 부족 하다고 말하면 문제 가 발생한 것입니다. 대부분의 경우 moc 생성 C ++ 코드 를 컴파일하거나 &lt;code&gt;#include&lt;/code&gt; 하거나 (이전의 경우) 링크 명령에 해당 오브젝트 파일을 포함시키는 것을 잊어 버렸습니다 . &lt;code&gt;qmake&lt;/code&gt; 를 사용하는 경우 , makefile을 업데이트하기 위해 다시 실행하십시오. 이것은 트릭을해야합니다.</target>
        </trans-unit>
        <trans-unit id="eb19136b2ee8f51e016ddebdf8cf1cafd00b88de" translate="yes" xml:space="preserve">
          <source>If you had both an Adobe and a Cronyx Helvetica, you might get either.</source>
          <target state="translated">Adobe와 Cronyx Helvetica를 모두 보유한 경우 둘 중 하나를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="093501ca07e1b048873f519ee54bbe9affd78b82" translate="yes" xml:space="preserve">
          <source>If you have XML like this:</source>
          <target state="translated">다음과 같은 XML이있는 경우 :</target>
        </trans-unit>
        <trans-unit id="0f3028a3f541466286a12cfacbcb9811b5158360" translate="yes" xml:space="preserve">
          <source>If you have a CPU with multiple cores, a multi-process system can help distribute the load evenly across different cores, making more efficient use of your CPU.</source>
          <target state="translated">코어가 여러 개인 CPU가있는 경우 다중 프로세스 시스템은 다른 코어에로드를 고르게 분산시켜 CPU를보다 효율적으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a513986a1bf7e1220dab5eefa567b76a52bcd6b8" translate="yes" xml:space="preserve">
          <source>If you have a complex UI, then multi-process is useful because if one part of the UI crashes, it doesn't affect the entire system. Similarly, the display won't freeze, even when one client freezes.</source>
          <target state="translated">UI가 복잡한 경우 UI의 한 부분이 충돌해도 전체 시스템에 영향을 미치지 않기 때문에 다중 프로세스가 유용합니다. 마찬가지로 한 클라이언트가 멈추더라도 화면이 멈추지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d37de89818a0a93f6cd07292f522f47de7107ae7" translate="yes" xml:space="preserve">
          <source>If you have a custom component or an application that embeds</source>
          <target state="translated">사용자 정의 컴포넌트 또는 임베드 된 애플리케이션이있는 경우</target>
        </trans-unit>
        <trans-unit id="b7117b76ff8d814f10a4596a6862b2d44fee9406" translate="yes" xml:space="preserve">
          <source>If you have a font which matches on family, even if none of the other attributes match, this font will be chosen in preference to a font which doesn't match on family but which does match on the other attributes. This is because font family is the dominant search criteria.</source>
          <target state="translated">패밀리와 일치하는 글꼴이있는 경우 다른 속성이 일치하지 않더라도이 글꼴은 패밀리와 일치하지 않지만 다른 속성과 일치하는 글꼴보다 우선적으로 선택됩니다. 글꼴 모음이 주요 검색 기준이기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="edb8fa84e65c82236eb5f0f616d31d8b82c3f7b8" translate="yes" xml:space="preserve">
          <source>If you have a loop where you do some processing, but only the final result of the processing is important, it is often better to update a temporary accumulator which you afterwards assign to the property you need to update, rather than incrementally updating the property itself, in order to avoid triggering re-evaluation of binding expressions during the intermediate stages of accumulation.</source>
          <target state="translated">일부 처리를 수행하는 루프가 있지만 처리의 최종 결과 만 중요한 경우에는 속성 자체를 점진적으로 업데이트하는 대신 나중에 업데이트해야하는 속성에 할당하는 임시 누산기를 업데이트하는 것이 좋습니다. 중간 축적 단계 동안 결합 ​​발현의 재평가를 유발하는 것을 피하기 위해.</target>
        </trans-unit>
        <trans-unit id="7833a0e9686bea974ea7046d997ccb46fe3b0afd" translate="yes" xml:space="preserve">
          <source>If you have a new style class called &lt;code&gt;MyStyle&lt;/code&gt; that you want to make available as a plugin, the class needs to be defined as follows (&lt;code&gt;mystyleplugin.h&lt;/code&gt;):</source>
          <target state="translated">플러그인으로 사용 가능하게하려는 &lt;code&gt;MyStyle&lt;/code&gt; 이라는 새 스타일 클래스가있는 경우 클래스는 다음과 같이 정의되어야합니다 ( &lt;code&gt;mystyleplugin.h&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="3f4d5741fec7d17ca29f8c5099a118c8c010c66e" translate="yes" xml:space="preserve">
          <source>If you have a pointer to an object, you can use &lt;a href=&quot;qobject#metaObject&quot;&gt;metaObject&lt;/a&gt;() to retrieve the meta-object associated with that object.</source>
          <target state="translated">객체에 대한 포인터가 있으면 &lt;a href=&quot;qobject#metaObject&quot;&gt;metaObject&lt;/a&gt; ()를 사용 하여 해당 객체와 연관된 메타 객체를 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fc4c2bd6a20a583368114747bf95813ca0ed13d2" translate="yes" xml:space="preserve">
          <source>If you have code that looks like this:</source>
          <target state="translated">다음과 같은 코드가있는 경우 :</target>
        </trans-unit>
        <trans-unit id="1d42bdafc68ae936bd171e32c366e91c134b7e92" translate="yes" xml:space="preserve">
          <source>If you have elements which are totally covered by other (opaque) elements, it is best to set their &quot;visible&quot; property to &lt;code&gt;false&lt;/code&gt; or they will be drawn needlessly.</source>
          <target state="translated">다른 (불투명 한) 요소로 완전히 덮힌 요소가있는 경우 &quot;visible&quot;속성을 &lt;code&gt;false&lt;/code&gt; 로 설정하는 것이 가장 좋습니다 . 그렇지 않으면 불필요하게 그려집니다.</target>
        </trans-unit>
        <trans-unit id="dfc4e0f8c2bf7525a3a838de728f9d8bd61c812d" translate="yes" xml:space="preserve">
          <source>If you have large forms that do not fit in the Qt Creator &lt;b&gt;Design&lt;/b&gt; mode, you can open them in the stand-alone</source>
          <target state="translated">Qt Creator &lt;b&gt;디자인&lt;/b&gt; 모드에 맞지 않는 큰 양식이 있는 경우 독립형으로 열 수 있습니다</target>
        </trans-unit>
        <trans-unit id="4b0b4fe41787d4b4f7c373135e22dcffa7954df8" translate="yes" xml:space="preserve">
          <source>If you have many occurrences of a certain set of keys, you can use arrays to make your life easier. For example, let's suppose that you want to save a variable-length list of user names and passwords. You could then write:</source>
          <target state="translated">특정 키 세트가 많이있는 경우 배열을 사용하여보다 쉽게 ​​생활 할 수 있습니다. 예를 들어, 가변 길이의 사용자 이름 및 비밀번호 목록을 저장한다고 가정하십시오. 그런 다음 쓸 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="593656e2cbae068866581c1bb67f541d54a1eec4" translate="yes" xml:space="preserve">
          <source>If you have no pointer to an actual object instance but still want to access the meta-object of a class, you can use &lt;a href=&quot;qobject#staticMetaObject-var&quot;&gt;staticMetaObject&lt;/a&gt;.</source>
          <target state="translated">실제 객체 인스턴스에 대한 포인터는 없지만 클래스의 메타 객체에 여전히 액세스하려는 경우 &lt;a href=&quot;qobject#staticMetaObject-var&quot;&gt;staticMetaObject&lt;/a&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="073ec092d3e6402042ace4ab5ccf8f01d19d871b" translate="yes" xml:space="preserve">
          <source>If you have only one single custom widget then you can set it as default widget using &lt;a href=&quot;qwidgetaction#setDefaultWidget&quot;&gt;setDefaultWidget&lt;/a&gt;(). That widget will then be used if the action is added to a &lt;a href=&quot;qtoolbar&quot;&gt;QToolBar&lt;/a&gt;, or in general to an action container that supports &lt;a href=&quot;qwidgetaction&quot;&gt;QWidgetAction&lt;/a&gt;. If a &lt;a href=&quot;qwidgetaction&quot;&gt;QWidgetAction&lt;/a&gt; with only a default widget is added to two toolbars at the same time then the default widget is shown only in the first toolbar the action was added to. &lt;a href=&quot;qwidgetaction&quot;&gt;QWidgetAction&lt;/a&gt; takes over ownership of the default widget.</source>
          <target state="translated">하나의 단일 사용자 정의 위젯 만있는 경우 &lt;a href=&quot;qwidgetaction#setDefaultWidget&quot;&gt;setDefaultWidget&lt;/a&gt; ()을 사용하여 기본 위젯으로 설정할 수 있습니다 . 그런 다음 조치가 &lt;a href=&quot;qtoolbar&quot;&gt;QToolBar&lt;/a&gt; 또는 일반적으로 &lt;a href=&quot;qwidgetaction&quot;&gt;QWidgetAction&lt;/a&gt; 을 지원하는 조치 컨테이너에 추가되면 해당 위젯이 사용됩니다 . 기본 위젯 만 있는 &lt;a href=&quot;qwidgetaction&quot;&gt;QWidgetAction&lt;/a&gt; 이 두 개의 도구 모음에 동시에 추가되면 기본 위젯은 조치가 추가 된 첫 번째 도구 모음에만 표시됩니다. &lt;a href=&quot;qwidgetaction&quot;&gt;QWidgetAction&lt;/a&gt; 은 기본 위젯의 소유권을 인수합니다.</target>
        </trans-unit>
        <trans-unit id="b044cf74f2358671783da692819f13ac65606c4d" translate="yes" xml:space="preserve">
          <source>If you have problems installing open source versions of Qt provided by your Linux distribution, for example, from RPM or APT repositories, please consult the maintainers of the distribution.</source>
          <target state="translated">Linux 배포판 (예 : RPM 또는 APT 리포지토리)에서 제공하는 오픈 소스 버전의 Qt를 설치하는 데 문제가있는 경우 배포판 관리자에게 문의하십시오.</target>
        </trans-unit>
        <trans-unit id="43e0f84948bbeba6b3511f8f03e7121e68df5cf7" translate="yes" xml:space="preserve">
          <source>If you have programatically created the arguments, as opposed to getting them from the arguments in &lt;code&gt;main()&lt;/code&gt;, it is likely of interest to use QTest::qExec(&lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; *, const &lt;a href=&quot;qstringlist&quot;&gt;QStringList&lt;/a&gt; &amp;amp;) since it is Unicode safe.</source>
          <target state="translated">&lt;code&gt;main()&lt;/code&gt; 의 인수에서 인수를 얻는 것과 달리 프로그래밍 방식으로 인수를 만든 경우 유니 코드 안전하므로 QTest :: qExec ( &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; *, const &lt;a href=&quot;qstringlist&quot;&gt;QStringList&lt;/a&gt; &amp;amp;)를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="67532b014024b48dccc7bd6b4f01cf6849669d04" translate="yes" xml:space="preserve">
          <source>If you have reimplemented &lt;a href=&quot;qtimeline#valueForTime&quot;&gt;valueForTime&lt;/a&gt;(), this value is ignored.</source>
          <target state="translated">&lt;a href=&quot;qtimeline#valueForTime&quot;&gt;valueForTime&lt;/a&gt; () 을 다시 구현 한 경우이 값은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="3c4f5edd184fd000c128f5048b97d4d92bf3821e" translate="yes" xml:space="preserve">
          <source>If you have resources in a library, you need to force initialization of your resources by calling &lt;a href=&quot;qdir#Q_INIT_RESOURCE&quot;&gt;Q_INIT_RESOURCE&lt;/a&gt;() with the base name of the &lt;code&gt;.qrc&lt;/code&gt; file. For example:</source>
          <target state="translated">라이브러리에 자원이있는 경우 &lt;code&gt;.qrc&lt;/code&gt; 파일 의 기본 이름으로 &lt;a href=&quot;qdir#Q_INIT_RESOURCE&quot;&gt;Q_INIT_RESOURCE&lt;/a&gt; ()를 호출하여 자원을 강제로 초기화해야 합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4efcb21d844a9a9269c0619eb7765d115b79b762" translate="yes" xml:space="preserve">
          <source>If you have seen regexps described elsewhere, they may have looked different from the ones shown here. This is because some sets of characters and some quantifiers are so common that they have been given special symbols to represent them. &lt;b&gt;[0-9]&lt;/b&gt; can be replaced with the symbol &lt;b&gt;\d&lt;/b&gt;. The quantifier to match exactly one occurrence, &lt;b&gt;{1,1}&lt;/b&gt;, can be replaced with the expression itself, i.e. &lt;b&gt;x{1,1}&lt;/b&gt; is the same as &lt;b&gt;x&lt;/b&gt;. So our 0 to 99 matcher could be written as &lt;b&gt;^\d{1,2}$&lt;/b&gt;. It can also be written &lt;b&gt;^\d\d{0,1}$&lt;/b&gt;, i.e.</source>
          <target state="translated">다른 곳에서 설명한 정규 표현식을 본 경우 여기에 표시된 것과 다르게 보일 수 있습니다. 이는 일부 문자 세트와 일부 수량 화기가 너무 일반적이기 때문에이를 나타내는 특수 기호가 제공 되었기 때문입니다. &lt;b&gt;[0-9]&lt;/b&gt; 는 &lt;b&gt;\ d&lt;/b&gt; 기호로 대체 될 수 있습니다 . 정확히 한 번의 발생 &lt;b&gt;{1,1}&lt;/b&gt; 과 일치하는 수량 자는 표현식 자체로 대체 될 수 있습니다. 즉 &lt;b&gt;x {1,1}&lt;/b&gt; 은 &lt;b&gt;x&lt;/b&gt; 와 동일합니다 . 따라서 0에서 99까지의 매처는 &lt;b&gt;^ \ d {1,2} $&lt;/b&gt; 로 쓸 수 있습니다 . &lt;b&gt;^ \ d \ d {0,1} $&lt;/b&gt; 로 쓸 수도 있습니다 . 즉</target>
        </trans-unit>
        <trans-unit id="99eb71782f95aa9f75d79617643a560c36139759" translate="yes" xml:space="preserve">
          <source>If you hide a parent item, all its children will also be hidden. If you show a parent item, all children will be shown, unless they have been explicitly hidden (i.e., if you call setVisible(false) on a child, it will not be reshown even if its parent is hidden, and then shown again).</source>
          <target state="translated">부모 항목을 숨기면 모든 자식 항목도 숨겨집니다. 부모 항목을 표시하면 명시 적으로 숨겨져 있지 않는 한 모든 자식이 표시됩니다 (예 : 자식에서 setVisible (false)를 호출하면 부모가 숨겨져도 다시 표시되지 않음) .</target>
        </trans-unit>
        <trans-unit id="3e76e7caf35eee52604b222848022d14ae7e690c" translate="yes" xml:space="preserve">
          <source>If you ignore the event (i.e., by calling &lt;a href=&quot;qevent#ignore&quot;&gt;QEvent::ignore&lt;/a&gt;()),</source>
          <target state="translated">이벤트를 무시하면 (예 &lt;a href=&quot;qevent#ignore&quot;&gt;: QEvent :: ignore&lt;/a&gt; ()를 호출 하여 )</target>
        </trans-unit>
        <trans-unit id="b5be8bce7d84f21c1008d75c236bbe2fd2fa45a8" translate="yes" xml:space="preserve">
          <source>If you ignore the event, (i.e., by calling &lt;a href=&quot;qevent#ignore&quot;&gt;QEvent::ignore&lt;/a&gt;(),) it will propagate to any item beneath this item. If no items accept the event, it will be ignored by the scene, and propagate to the view (e.g., the view's vertical scroll bar).</source>
          <target state="translated">이벤트를 무시하면 (즉, &lt;a href=&quot;qevent#ignore&quot;&gt;QEvent :: ignore&lt;/a&gt; () 를 호출 하여 )이 항목 아래의 모든 항목으로 전파됩니다. 이벤트를 수락하는 항목이 없으면 장면에서 무시되고보기 (예 :보기의 세로 스크롤 막대)로 전파됩니다.</target>
        </trans-unit>
        <trans-unit id="d0b5138a89d332131f26aa61549d834762616824" translate="yes" xml:space="preserve">
          <source>If you implement &lt;a href=&quot;qabstractscrollarea#scrollContentsBy&quot;&gt;scrollContentsBy&lt;/a&gt;() in a subclass of &lt;a href=&quot;qabstractitemview&quot;&gt;QAbstractItemView&lt;/a&gt;, call this function before you call &lt;a href=&quot;qwidget#scroll&quot;&gt;QWidget::scroll&lt;/a&gt;() on the viewport. Alternatively, just call &lt;a href=&quot;qabstractitemview#update&quot;&gt;update&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qabstractitemview&quot;&gt;QAbstractItemView&lt;/a&gt; 의 서브 클래스에서 &lt;a href=&quot;qabstractscrollarea#scrollContentsBy&quot;&gt;scrollContentsBy&lt;/a&gt; () 를 구현 하는 경우 뷰포트에서 &lt;a href=&quot;qwidget#scroll&quot;&gt;QWidget :: scroll&lt;/a&gt; ()을 호출하기 전에이 함수를 호출 하십시오. 또는 &lt;a href=&quot;qabstractitemview#update&quot;&gt;update&lt;/a&gt; ()를 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="4125209b6ce63aa8c8f3650e5c6a37c6c7ff1328" translate="yes" xml:space="preserve">
          <source>If you implement your own model, you can reimplement this function if you want to support insertions. Alternatively, you can provide your own API for altering the data.</source>
          <target state="translated">자체 모델을 구현하는 경우 삽입을 지원하려는 경우이 기능을 다시 구현할 수 있습니다. 또는 데이터 변경을위한 고유 한 API를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d331f2f6a611d244753300f85e1e74aca09e6fe4" translate="yes" xml:space="preserve">
          <source>If you implement your own model, you can reimplement this function if you want to support insertions. Alternatively, you can provide your own API for altering the data. In either case, you will need to call &lt;a href=&quot;qabstractitemmodel#beginInsertRows&quot;&gt;beginInsertRows&lt;/a&gt;() and &lt;a href=&quot;qabstractitemmodel#endInsertRows&quot;&gt;endInsertRows&lt;/a&gt;() to notify other components that the model has changed.</source>
          <target state="translated">자체 모델을 구현하는 경우 삽입을 지원하려는 경우이 기능을 다시 구현할 수 있습니다. 또는 데이터 변경을위한 고유 한 API를 제공 할 수 있습니다. 두 경우 모두 &lt;a href=&quot;qabstractitemmodel#beginInsertRows&quot;&gt;beginInsertRows&lt;/a&gt; () 및 &lt;a href=&quot;qabstractitemmodel#endInsertRows&quot;&gt;endInsertRows&lt;/a&gt; ()를 호출 하여 모델이 변경되었음을 다른 구성 요소에 알려야합니다.</target>
        </trans-unit>
        <trans-unit id="106510d50377a8cd03188b6d7c0fd7c458fa892f" translate="yes" xml:space="preserve">
          <source>If you implement your own model, you can reimplement this function if you want to support moving. Alternatively, you can provide your own API for altering the data.</source>
          <target state="translated">자신의 모델을 구현하는 경우 이동을 지원하려는 경우이 기능을 다시 구현할 수 있습니다. 또는 데이터 변경을위한 고유 한 API를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2edbb20a834141e84df6cf15ba7e897a962af7bb" translate="yes" xml:space="preserve">
          <source>If you implement your own model, you can reimplement this function if you want to support removing. Alternatively, you can provide your own API for altering the data.</source>
          <target state="translated">자체 모델을 구현하는 경우 제거를 지원하려는 경우이 기능을 다시 구현할 수 있습니다. 또는 데이터 변경을위한 고유 한 API를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ab60b25c79bdcda285d18c592f7167e340feb06a" translate="yes" xml:space="preserve">
          <source>If you include &amp;lt;QtDebug&amp;gt;, a more convenient syntax is also available:</source>
          <target state="translated">&amp;lt;QtDebug&amp;gt;를 포함하면보다 편리한 구문도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="207679727f9b11ffb1852492267dde99e64deb5b" translate="yes" xml:space="preserve">
          <source>If you include &lt;code&gt;&amp;lt;QtDebug&amp;gt;&lt;/code&gt;, a more convenient syntax is also available:</source>
          <target state="translated">&lt;code&gt;&amp;lt;QtDebug&amp;gt;&lt;/code&gt; 를 포함 하면보다 편리한 구문도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c4832ad82817ce9ca13b654baaa7923c3c0c260" translate="yes" xml:space="preserve">
          <source>If you include the &amp;lt;QtDebug&amp;gt; header file, the &lt;code&gt;qDebug()&lt;/code&gt; macro can also be used as an output stream. For example:</source>
          <target state="translated">&amp;lt;QtDebug&amp;gt; 헤더 파일을 포함하면 &lt;code&gt;qDebug()&lt;/code&gt; 매크로를 출력 스트림으로 사용할 수도 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3ae64c01642f09e9b36108cb089b8bf5e640b581" translate="yes" xml:space="preserve">
          <source>If you include the &lt;code&gt;%L&lt;/code&gt; modifier when you specify a parameter, the number is localized according to the current regional settings. For example, in the following code snippet, &lt;code&gt;%L1&lt;/code&gt; means to format the first parameters according to the number formatting conventions of the currently selected locale (geographical region):</source>
          <target state="translated">매개 변수를 지정할 때 &lt;code&gt;%L&lt;/code&gt; 수정자를 포함하면 숫자가 현재 지역 설정에 따라 현지화됩니다. 예를 들어 다음 코드 스 니펫에서 &lt;code&gt;%L1&lt;/code&gt; 은 현재 선택된 로케일 (지역)의 숫자 형식 규칙에 따라 첫 번째 매개 변수의 형식을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="c35fec5071466912f6e977d5b38d0d1971590123" translate="yes" xml:space="preserve">
          <source>If you include the above in your qdocconf file for qtbase, there will be no class documentation generated for &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt;.</source>
          <target state="translated">qtbase의 qdocconf 파일에 위 내용을 포함 시키면 &lt;a href=&quot;qwidget&quot;&gt;QWidget에&lt;/a&gt; 대한 클래스 문서가 생성되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="ea209d0aa612b39eaf83772d3fa5d10a5ac7f4e1" translate="yes" xml:space="preserve">
          <source>If you intend to use Qt Charts C++ classes in your application, use the following include and using directives:</source>
          <target state="translated">애플리케이션에서 Qt Charts C ++ 클래스를 사용하려면 다음 include 및 using 지시문을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="013cb061ad1d682c520847a81164689a638779b9" translate="yes" xml:space="preserve">
          <source>If you intend to use Qt Data Visualization C++ classes in your application, use the following include and using directives:</source>
          <target state="translated">애플리케이션에서 Qt Data Visualization C ++ 클래스를 사용하려면 다음 include 및 using 지시문을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="87e83a7a4a4b2cc04ff93e0ccddd6d0ea6f1b471" translate="yes" xml:space="preserve">
          <source>If you intend to use the C++ classes in your application, include the C++ definitions using the following directive:</source>
          <target state="translated">응용 프로그램에서 C ++ 클래스를 사용하려는 경우 다음 지시문을 사용하여 C ++ 정의를 포함하십시오.</target>
        </trans-unit>
        <trans-unit id="1c306d26aba22c480b4cb5c9819286c146a14567" translate="yes" xml:space="preserve">
          <source>If you invoke the &lt;a href=&quot;qwidget#show&quot;&gt;show()&lt;/a&gt; function after hiding a dialog, the dialog will be displayed in its original position. This is because the window manager decides the position for windows that have not been explicitly placed by the programmer. To preserve the position of a dialog that has been moved by the user, save its position in your &lt;a href=&quot;qwidget#closeEvent&quot;&gt;closeEvent()&lt;/a&gt; handler and then move the dialog to that position, before showing it again.</source>
          <target state="translated">대화 상자를 숨긴 후 &lt;a href=&quot;qwidget#show&quot;&gt;show ()&lt;/a&gt; 함수 를 호출하면 대화 상자가 원래 위치에 표시됩니다. 윈도우 관리자가 프로그래머가 명시 적으로 배치하지 않은 윈도우의 위치를 ​​결정하기 때문입니다. 사용자가 이동 한 대화 상자의 위치를 ​​유지하려면 &lt;a href=&quot;qwidget#closeEvent&quot;&gt;closeEvent ()&lt;/a&gt; 핸들러 에 해당 위치를 저장 한 다음 대화 상자를 다시 표시하기 전에 해당 위치로 이동하십시오.</target>
        </trans-unit>
        <trans-unit id="0f804f726a66c4e54a56a123b766c3508c288994" translate="yes" xml:space="preserve">
          <source>If you just need to display a small piece of rich text use &lt;a href=&quot;qlabel&quot;&gt;QLabel&lt;/a&gt;.</source>
          <target state="translated">작은 서식있는 텍스트를 표시해야 할 경우 &lt;a href=&quot;qlabel&quot;&gt;QLabel을&lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="671426a4ddfca9ca8181c499337c24b4302d8c51" translate="yes" xml:space="preserve">
          <source>If you just want to iterate over all the items in a container in order, you can use Qt's &lt;code&gt;foreach&lt;/code&gt; keyword. The keyword is a Qt-specific addition to the C++ language, and is implemented using the preprocessor.</source>
          <target state="translated">컨테이너의 모든 항목을 순서대로 반복하려면 Qt의 &lt;code&gt;foreach&lt;/code&gt; 키워드를 사용할 수 있습니다 . 키워드는 C ++ 언어에 대한 Qt 별 추가이며 전처리기를 사용하여 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="5d1a6fde8942f05249887dbeaacee61a0c4df298" translate="yes" xml:space="preserve">
          <source>If you just want to serialize your XML in a human-readable format, use &lt;a href=&quot;qxmlformatter&quot;&gt;QXmlFormatter&lt;/a&gt; as it is. The default indentation level is 4 spaces, but you can set your own indentation value &lt;a href=&quot;qxmlformatter#setIndentationDepth&quot;&gt;setIndentationDepth&lt;/a&gt;().</source>
          <target state="translated">XML을 사람이 읽을 수있는 형식으로 직렬화하려면 &lt;a href=&quot;qxmlformatter&quot;&gt;QXmlFormatter&lt;/a&gt; 를 그대로 사용 하십시오. 기본 들여 쓰기 수준은 4 칸이지만, 들여 쓰기 값 &lt;a href=&quot;qxmlformatter#setIndentationDepth&quot;&gt;setIndentationDepth&lt;/a&gt; ()를 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="46e56bf216eac5daf92da5b89455b45f437042ff" translate="yes" xml:space="preserve">
          <source>If you just want to store a single text block (i.e., a &quot;comment&quot; or just a description), you can either pass an empty key, or use a generic key like &quot;Description&quot;.</source>
          <target state="translated">단일 텍스트 블록 (예 : &quot;설명&quot;또는 설명) 만 저장하려는 경우 빈 키를 전달하거나 &quot;설명&quot;과 같은 일반 키를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2b0f8112d0bacf60286bec0b9fdae8d2d17d85e7" translate="yes" xml:space="preserve">
          <source>If you know approximately how many items you will store in a container, you can start by calling &lt;a href=&quot;qstring#reserve&quot;&gt;reserve()&lt;/a&gt;, and when you are done populating the container, you can call &lt;a href=&quot;qstring#squeeze&quot;&gt;squeeze()&lt;/a&gt; to release the extra preallocated memory.</source>
          <target state="translated">컨테이너에 저장할 항목 수를 대략 알고있는 경우 &lt;a href=&quot;qstring#reserve&quot;&gt;reserve ()&lt;/a&gt; 를 호출하여 시작할 수 있으며 컨테이너 채우기 가 완료되면 &lt;a href=&quot;qstring#squeeze&quot;&gt;squeeze ()&lt;/a&gt; 를 호출 하여 사전 할당 된 추가 메모리를 해제 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e506536703fb7f20a6bdf79b9f8f4456e55d8b44" translate="yes" xml:space="preserve">
          <source>If you know in advance approximately how many items the &lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt; will contain, you can call &lt;a href=&quot;qvector#reserve&quot;&gt;reserve&lt;/a&gt;(), asking &lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt; to preallocate a certain amount of memory. You can also call &lt;a href=&quot;qvector#capacity&quot;&gt;capacity&lt;/a&gt;() to find out how much memory &lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt; actually allocated.</source>
          <target state="translated">&lt;a href=&quot;qvector&quot;&gt;QVector에&lt;/a&gt; 얼마나 많은 항목 이 포함되어 있는지 대략 알고 있다면 &lt;a href=&quot;qvector#reserve&quot;&gt;reserve&lt;/a&gt; ()를 호출 하여 &lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt; 에 특정 양의 메모리를 미리 할당하도록 요청할 수 있습니다 . 또한 &lt;a href=&quot;qvector#capacity&quot;&gt;용량&lt;/a&gt; ()을 호출 하여 &lt;a href=&quot;qvector&quot;&gt;QVector가&lt;/a&gt; 실제로 할당 한 메모리 양을 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="25543a785b45632b691af66aeb9dcf2a862fd0af" translate="yes" xml:space="preserve">
          <source>If you know up front what the height of the table will be, assign a value to &lt;code&gt;contentHeight&lt;/code&gt; explicitly, to avoid unnecessary calculations and updates to the &lt;a href=&quot;qml-qtquick-tableview&quot;&gt;TableView&lt;/a&gt;.</source>
          <target state="translated">테이블의 높이를 미리 알고 있다면 불필요한 계산 및 &lt;a href=&quot;qml-qtquick-tableview&quot;&gt;TableView&lt;/a&gt; 업데이트를 피하기 위해 &lt;code&gt;contentHeight&lt;/code&gt; 에 값을 명시 적으로 지정하십시오 .</target>
        </trans-unit>
        <trans-unit id="76ecbbf6e35548252c0274214fd7812d5146cce6" translate="yes" xml:space="preserve">
          <source>If you know up front what the width of the table will be, assign a value to &lt;code&gt;contentWidth&lt;/code&gt; explicitly, to avoid unnecessary calculations and updates to the &lt;a href=&quot;qml-qtquick-tableview&quot;&gt;TableView&lt;/a&gt;.</source>
          <target state="translated">테이블 너비를 미리 알고 있으면 불필요한 계산 및 &lt;a href=&quot;qml-qtquick-tableview&quot;&gt;TableView&lt;/a&gt; 업데이트를 피하기 위해 &lt;code&gt;contentWidth&lt;/code&gt; 에 값을 명시 적으로 지정하십시오 .</target>
        </trans-unit>
        <trans-unit id="9f92abc2a00b2f80db551ba62e402726d7c10657" translate="yes" xml:space="preserve">
          <source>If you later on convert the returned html string into a byte array for transmission over a network or when saving to disk you should specify the encoding you're going to use for the conversion to a byte array here.</source>
          <target state="translated">나중에 네트워크를 통해 전송하기 위해 반환 된 html 문자열을 바이트 배열로 변환하거나 디스크에 저장할 때 여기에서 바이트 배열로 변환하는 데 사용할 인코딩을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="e7c0048e898893a6e5d1c8cb46448f039b953244" translate="yes" xml:space="preserve">
          <source>If you lazy load components, or create objects dynamically during a JavaScript expression, it is often better to &lt;code&gt;destroy()&lt;/code&gt; them manually rather than wait for automatic garbage collection to do so. See the prior section on &lt;a href=&quot;#controlling-element-lifetime&quot;&gt;Controlling Element Lifetime&lt;/a&gt; for more information.</source>
          <target state="translated">JavaScript 표현식 중에 구성 요소를 지연로드하거나 동적으로 오브젝트를 작성 하는 경우 자동 가비지 콜렉션이 기다리기를 기다리는 대신 수동으로 &lt;code&gt;destroy()&lt;/code&gt; 하는 것이 좋습니다. 자세한 내용은 &lt;a href=&quot;#controlling-element-lifetime&quot;&gt;요소 수명 제어&lt;/a&gt; 에 대한 이전 섹션 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f1b6e142a71a05aa00ba5bae3b0b5f2ae89756c9" translate="yes" xml:space="preserve">
          <source>If you leave out</source>
          <target state="translated">나가면</target>
        </trans-unit>
        <trans-unit id="2db783b80ff1020ccaceac55ba2023405ff45002" translate="yes" xml:space="preserve">
          <source>If you make a mistake, simply double click outside of any number or choose &lt;b&gt;Restart&lt;/b&gt; from the form's context menu to start again. If you have many widgets on your form and would like to change the tab order in the middle or at the end of the tab order chain, you can edit it at any position. Press &lt;b&gt;Ctrl&lt;/b&gt; and click the number from which you want to start. Alternatively, choose &lt;b&gt;Start from Here&lt;/b&gt; in the context menu.</source>
          <target state="translated">실수 한 경우 숫자를 두 번 클릭하거나 양식의 상황에 맞는 메뉴에서 &lt;b&gt;다시 시작&lt;/b&gt; 을 선택 하여 다시 시작하십시오. 양식에 많은 위젯이 있고 탭 순서 체인의 중간 또는 끝에있는 탭 순서를 변경하려면 원하는 위치에서 편집 할 수 있습니다. 보도 &lt;b&gt;Ctrl 키를&lt;/b&gt; 시작하고자하는 번호를 클릭합니다. 또는 상황에 맞는 메뉴 &lt;b&gt;에서 여기&lt;/b&gt; 에서 &lt;b&gt;시작을&lt;/b&gt; 선택 &lt;b&gt;하십시오&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="d6243f8fa37fa62c4ab8dc9f019c9d4a49cb12c4" translate="yes" xml:space="preserve">
          <source>If you modify a primary key, the record might slip through your fingers while you are trying to populate it.</source>
          <target state="translated">기본 키를 수정하면 레코드를 채우려 고 할 때 레코드가 손가락으로 미끄러질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fee78d1a8d6e37dec838fcf815b60c25dd57ea2e" translate="yes" xml:space="preserve">
          <source>If you move the widget as a result of the mouse event, use the global position returned by &lt;a href=&quot;qmouseevent#globalPos&quot;&gt;globalPos&lt;/a&gt;() to avoid a shaking motion.</source>
          <target state="translated">마우스 이벤트의 결과로 위젯을 이동하는 경우 흔들리는 동작을 피하기 위해 &lt;a href=&quot;qmouseevent#globalPos&quot;&gt;globalPos&lt;/a&gt; ()에서 반환 한 전역 위치를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="48836d76f845406462aa8231c83942c16a308fb1" translate="yes" xml:space="preserve">
          <source>If you move the widget as a result of the mouse event, use the screen position returned by &lt;a href=&quot;qmouseevent#screenPos&quot;&gt;screenPos&lt;/a&gt;() to avoid a shaking motion.</source>
          <target state="translated">마우스 이벤트의 결과로 위젯을 이동하는 경우 흔들리는 동작을 피하기 위해 &lt;a href=&quot;qmouseevent#screenPos&quot;&gt;screenPos&lt;/a&gt; ()에서 반환 한 화면 위치를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="a94049d4fb9f710d3ac1e5672cbaf20893df6f70" translate="yes" xml:space="preserve">
          <source>If you move widgets around in response to mouse events, use &lt;a href=&quot;qtabletevent#globalPos&quot;&gt;globalPos&lt;/a&gt;() instead of this function.</source>
          <target state="translated">마우스 이벤트에 대한 응답으로 위젯을 이동 하는 경우이 함수 대신 &lt;a href=&quot;qtabletevent#globalPos&quot;&gt;globalPos&lt;/a&gt; ()를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="1cb7bd27fb2afab61fc9d90a41c1cc5333493ec1" translate="yes" xml:space="preserve">
          <source>If you move widgets around in response to mouse events, use &lt;a href=&quot;qtabletevent#globalPosF&quot;&gt;globalPosF&lt;/a&gt;() instead of this function.</source>
          <target state="translated">마우스 이벤트에 대한 응답으로 위젯을 이동 하는 경우이 함수 대신 &lt;a href=&quot;qtabletevent#globalPosF&quot;&gt;globalPosF&lt;/a&gt; ()를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="bc1189230837866bd16163177bf8f8b92b690b0f" translate="yes" xml:space="preserve">
          <source>If you move your widgets around in response to mouse events, use &lt;a href=&quot;qwheelevent#globalPos&quot;&gt;globalPos&lt;/a&gt;() instead of this function.</source>
          <target state="translated">마우스 이벤트에 대한 응답으로 위젯을 이동 하는 경우이 함수 대신 &lt;a href=&quot;qwheelevent#globalPos&quot;&gt;globalPos&lt;/a&gt; ()를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="69ef74d3f62546691122624c9d6b9996fde5f307" translate="yes" xml:space="preserve">
          <source>If you move your widgets around in response to mouse events, use &lt;a href=&quot;qwheelevent#globalPosF&quot;&gt;globalPosF&lt;/a&gt;() instead of this function.</source>
          <target state="translated">마우스 이벤트에 대한 응답으로 위젯을 이동 하는 경우이 함수 대신 &lt;a href=&quot;qwheelevent#globalPosF&quot;&gt;globalPosF&lt;/a&gt; ()를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="98398f110a351968fea2d7f0aafa7392066d7e46" translate="yes" xml:space="preserve">
          <source>If you must expose a &lt;a href=&quot;qvariant#QVariantMap-typedef&quot;&gt;QVariantMap&lt;/a&gt; to QML, use a &quot;var&quot; property rather than a &quot;variant&quot; property. In general, &quot;property var&quot; should be considered to be superior to &quot;property variant&quot; for every use-case from &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtquick-qmlmodule.html&quot;&gt;QtQuick&lt;/a&gt; 2.0 and newer (note that &quot;property variant&quot; is marked as obsolete), as it allows a true JavaScript reference to be stored (which can reduce the number of conversions required in certain expressions).</source>
          <target state="translated">&lt;a href=&quot;qvariant#QVariantMap-typedef&quot;&gt;QVariantMap&lt;/a&gt; 을 QML에 노출해야하는 경우 &quot;variant&quot;특성 대신 &quot;var&quot;특성을 사용하십시오. 일반적으로, &quot;속성 var&quot;는 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtquick-qmlmodule.html&quot;&gt;QtQuick&lt;/a&gt; 2.0 이상의 모든 사용 사례에서 &quot;속성 변형&quot;보다 우수한 것으로 간주되어야합니다 ( &quot;속성 변형&quot;은 더 이상 사용되지 않는 것으로 표시됨). 저장 됨 (특정 표현식에 필요한 변환 횟수를 줄일 수 있음).</target>
        </trans-unit>
        <trans-unit id="c2d2d4d5382a8845849da6e1184539b78f29d016" translate="yes" xml:space="preserve">
          <source>If you navigate within a result set, and use next() and seek() only for browsing forward, you can call &lt;a href=&quot;qsqlquery#setForwardOnly&quot;&gt;QSqlQuery::setForwardOnly&lt;/a&gt;(true) before calling exec(). This is an easy optimization that will speed up the query significantly when operating on large result sets.</source>
          <target state="translated">결과 집합 내에서 탐색하고 앞으로 탐색 할 때만 next () 및 seek ( )를 사용하는 경우 exec ()를 호출하기 전에 &lt;a href=&quot;qsqlquery#setForwardOnly&quot;&gt;QSqlQuery :: setForwardOnly&lt;/a&gt; (true)를 호출 할 수 있습니다 . 이는 큰 결과 집합에서 작업 할 때 쿼리 속도를 크게 향상시키는 쉬운 최적화입니다.</target>
        </trans-unit>
        <trans-unit id="f0be1ad7bf98429079625ea60af0aa6a3256b39e" translate="yes" xml:space="preserve">
          <source>If you need C++11 noexcept semantics, don't use this macro, use &lt;a href=&quot;qtglobal#Q_DECL_NOEXCEPT&quot;&gt;Q_DECL_NOEXCEPT&lt;/a&gt;/&lt;a href=&quot;qtglobal#Q_DECL_NOEXCEPT_EXPR&quot;&gt;Q_DECL_NOEXCEPT_EXPR&lt;/a&gt; instead.</source>
          <target state="translated">C ++ 11 noexcept 의미가 필요한 경우이 매크로를 사용 &lt;a href=&quot;qtglobal#Q_DECL_NOEXCEPT&quot;&gt;하지 &lt;/a&gt;&lt;a href=&quot;qtglobal#Q_DECL_NOEXCEPT_EXPR&quot;&gt;말고&lt;/a&gt; 대신 Q_DECL_NOEXCEPT / Q_DECL_NOEXCEPT_EXPR을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="5ead8b6ac852866dc1489d0e461e4bf87214a911" translate="yes" xml:space="preserve">
          <source>If you need a custom label, you can replace the label item.</source>
          <target state="translated">사용자 정의 레이블이 필요한 경우 레이블 항목을 교체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1cf280db22d6d52488b60a0e249b954f6baf900f" translate="yes" xml:space="preserve">
          <source>If you need a model to use with an item view such as QML's List View element or the C++ widgets &lt;a href=&quot;qlistview&quot;&gt;QListView&lt;/a&gt; or &lt;a href=&quot;qtableview&quot;&gt;QTableView&lt;/a&gt;, you should consider subclassing &lt;a href=&quot;qabstractlistmodel&quot;&gt;QAbstractListModel&lt;/a&gt; or &lt;a href=&quot;qabstracttablemodel&quot;&gt;QAbstractTableModel&lt;/a&gt; instead of this class.</source>
          <target state="translated">QML의 목록보기 요소 또는 C ++ 위젯 &lt;a href=&quot;qlistview&quot;&gt;QListView&lt;/a&gt; 또는 &lt;a href=&quot;qtableview&quot;&gt;QTableView&lt;/a&gt; 와 같은 항목보기와 함께 사용할 모델이 필요한 경우이 클래스 대신 &lt;a href=&quot;qabstractlistmodel&quot;&gt;QAbstractListModel&lt;/a&gt; 또는 &lt;a href=&quot;qabstracttablemodel&quot;&gt;QAbstractTableModel을&lt;/a&gt; 서브 클래 싱하는 것을 고려해야 합니다.</target>
        </trans-unit>
        <trans-unit id="bb7be3fd0c46756019cfdb4476764790df813f72" translate="yes" xml:space="preserve">
          <source>If you need a more specific run-time error to describe an exception, you can use the &lt;a href=&quot;qjsengine#throwError-1&quot;&gt;throwError(QJSValue::ErrorType errorType, const QString &amp;amp;message)&lt;/a&gt; overload.</source>
          <target state="translated">예외를 설명하기 위해보다 구체적인 런타임 오류가 필요한 경우 &lt;a href=&quot;qjsengine#throwError-1&quot;&gt;throwError (QJSValue :: ErrorType errorType, const QString &amp;amp; message)&lt;/a&gt; 오버로드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5ab13ffd4dd0d04293eb4de3600e7136f20fb6d" translate="yes" xml:space="preserve">
          <source>If you need a real linked list, which guarantees &lt;a href=&quot;containers#algorithmic-complexity&quot;&gt;constant time&lt;/a&gt; insertions mid-list and uses iterators to items rather than indexes, use &lt;a href=&quot;qlinkedlist&quot;&gt;QLinkedList&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;containers#algorithmic-complexity&quot;&gt;일정한 시간 동안&lt;/a&gt; 미드리스트를 삽입하고 인덱스가 아닌 항목에 반복자를 사용 하는 실제 링크리스트가 필요한 경우 &lt;a href=&quot;qlinkedlist&quot;&gt;QLinkedList를&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="82835375128e32f063444bcf40d34143273bf20c" translate="yes" xml:space="preserve">
          <source>If you need a real linked list, with guarantees of &lt;a href=&quot;containers#constant-time&quot;&gt;constant time&lt;/a&gt; insertions in the middle of the list and iterators to items rather than indexes, use &lt;a href=&quot;qlinkedlist&quot;&gt;QLinkedList&lt;/a&gt;.</source>
          <target state="translated">목록 중간에 &lt;a href=&quot;containers#constant-time&quot;&gt;일정한 시간을&lt;/a&gt; 삽입하고 색인이 아닌 항목에 반복자를 삽입 하여 실제 연결 목록이 필요한 경우 &lt;a href=&quot;qlinkedlist&quot;&gt;QLinkedList를&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="2ff7766b8126fa8cbc1466fed1f0e58190dcb2a0" translate="yes" xml:space="preserve">
          <source>If you need only to find out if the service is registered or unregistered only, without being notified that the ownership changed, consider using the specific modes for those operations. This class is more efficient if you use the more specific modes.</source>
          <target state="translated">소유권이 변경되었다는 알림을받지 않고 서비스가 등록 또는 등록되지 않은 상태인지 확인해야하는 경우 해당 작업에 특정 모드를 사용하는 것이 좋습니다. 보다 구체적인 모드를 사용하면이 클래스가 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="ccbe8ac683ad87263216c93c889911927b43a223" translate="yes" xml:space="preserve">
          <source>If you need the always-true version of C++11 noexcept, use &lt;a href=&quot;qtglobal#Q_DECL_NOEXCEPT&quot;&gt;Q_DECL_NOEXCEPT&lt;/a&gt;.</source>
          <target state="translated">항상 진정한 C ++ 11 noexcept 버전이 필요한 경우 Q_DECL_NOEXCEPT를 사용 &lt;a href=&quot;qtglobal#Q_DECL_NOEXCEPT&quot;&gt;하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cba64fb8058145d48a493bb7b0fd35b6484109d5" translate="yes" xml:space="preserve">
          <source>If you need the operator version of C++11 noexcept, use &lt;a href=&quot;qtglobal#Q_DECL_NOEXCEPT_EXPR&quot;&gt;Q_DECL_NOEXCEPT_EXPR&lt;/a&gt;(x).</source>
          <target state="translated">C ++ 11 noexcept의 운영자 버전이 필요한 경우 &lt;a href=&quot;qtglobal#Q_DECL_NOEXCEPT_EXPR&quot;&gt;Q_DECL_NOEXCEPT_EXPR&lt;/a&gt; (x)을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="9ee8c3221c99146b0e5e11193014fd65ae082d49" translate="yes" xml:space="preserve">
          <source>If you need the same transformations over and over, you can also use &lt;a href=&quot;qtransform&quot;&gt;QTransform&lt;/a&gt; objects and the &lt;a href=&quot;qpainter#worldTransform&quot;&gt;QPainter::worldTransform&lt;/a&gt;() and &lt;a href=&quot;qpainter#setWorldTransform&quot;&gt;QPainter::setWorldTransform&lt;/a&gt;() functions. You can at any time save the &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt;'s transformation matrix by calling the &lt;a href=&quot;qpainter#save&quot;&gt;QPainter::save&lt;/a&gt;() function which saves the matrix on an internal stack. The &lt;a href=&quot;qpainter#restore&quot;&gt;QPainter::restore&lt;/a&gt;() function pops it back.</source>
          <target state="translated">동일한 변환이 반복적으로 필요하면 &lt;a href=&quot;qtransform&quot;&gt;QTransform&lt;/a&gt; 객체와 &lt;a href=&quot;qpainter#worldTransform&quot;&gt;QPainter :: worldTransform&lt;/a&gt; () 및 &lt;a href=&quot;qpainter#setWorldTransform&quot;&gt;QPainter :: setWorldTransform&lt;/a&gt; () 함수를 사용할 수도 있습니다. 매트릭스를 내부 스택에 &lt;a href=&quot;qpainter#save&quot;&gt;저장&lt;/a&gt; 하는 QPainter :: save () 함수를 호출하여 언제든지 &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; 변환 매트릭스를 저장할 수 있습니다 . &lt;a href=&quot;qpainter#restore&quot;&gt;QPainter를 :: 복원&lt;/a&gt; () 함수가 다시 나타납니다.</target>
        </trans-unit>
        <trans-unit id="957945d5b8560d51a2336561d3b078926428d4e6" translate="yes" xml:space="preserve">
          <source>If you need to access properties or pass parameters of unsupported datatypes you must access the COM object directly through its &lt;code&gt;IDispatch&lt;/code&gt; implementation or other interfaces. Those interfaces can be retrieved through &lt;a href=&quot;qaxbase#queryInterface&quot;&gt;queryInterface&lt;/a&gt;().</source>
          <target state="translated">속성에 액세스하거나 지원되지 않는 데이터 형식의 매개 변수를 전달해야하는 경우 &lt;code&gt;IDispatch&lt;/code&gt; 구현 또는 기타 인터페이스를 통해 COM 개체에 직접 액세스해야합니다 . 이러한 인터페이스는 &lt;a href=&quot;qaxbase#queryInterface&quot;&gt;queryInterface&lt;/a&gt; ()를 통해 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0f5b04a0753b7c48a75e79fc700b949642ace0fd" translate="yes" xml:space="preserve">
          <source>If you need to change some settings when a widget is polished, reimplement &lt;a href=&quot;qwidget#event&quot;&gt;event&lt;/a&gt;() and handle the &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent::Polish&lt;/a&gt; event type.</source>
          <target state="translated">위젯을 &lt;a href=&quot;qevent#Type-enum&quot;&gt;다듬을&lt;/a&gt; 때 일부 설정을 변경해야하는 경우 &lt;a href=&quot;qwidget#event&quot;&gt;이벤트&lt;/a&gt; ()를 다시 구현 하고 QEvent :: Polish 이벤트 유형을 처리하십시오 .</target>
        </trans-unit>
        <trans-unit id="a69bdfba6ff23a4b4157931795226cafaa943e60" translate="yes" xml:space="preserve">
          <source>If you need to determine whether an object is an instance of a particular class for the purpose of casting it, consider using &lt;a href=&quot;qobject#qobject_cast&quot;&gt;qobject_cast&lt;/a&gt;&amp;lt;Type *&amp;gt;(object) instead.</source>
          <target state="translated">오브젝트를 캐스트하기 위해 오브젝트가 특정 클래스의 인스턴스인지 판별해야하는 경우 대신 &lt;a href=&quot;qobject#qobject_cast&quot;&gt;qobject_cast&lt;/a&gt; &amp;lt;Type *&amp;gt; (object)를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="7189bef7b3a3389b6825b2a88460691d1aa98363" translate="yes" xml:space="preserve">
          <source>If you need to draw a complex shape, especially if you need to do so repeatedly, consider creating a &lt;a href=&quot;qpainterpath&quot;&gt;QPainterPath&lt;/a&gt; and drawing it using &lt;a href=&quot;qpainter#drawPath&quot;&gt;drawPath&lt;/a&gt;().</source>
          <target state="translated">복잡한 모양을 그려야하는 경우, 특히 반복적으로 그려야하는 경우 &lt;a href=&quot;qpainterpath&quot;&gt;QPainterPath를&lt;/a&gt; 만들어 &lt;a href=&quot;qpainter#drawPath&quot;&gt;drawPath&lt;/a&gt; ()를 사용하여 그리는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="3fc46b15e20a06df652aee6a62607471919cf5fb" translate="yes" xml:space="preserve">
          <source>If you need to ensure that the subdirectories are built in the order in which they are specified, update the &lt;a href=&quot;#config&quot;&gt;CONFIG&lt;/a&gt; variable to include the &lt;code&gt;ordered&lt;/code&gt; option:</source>
          <target state="translated">서브 디렉토리가 지정된 순서대로 빌드되도록 보장 하려면 &lt;code&gt;ordered&lt;/code&gt; 옵션 을 포함하도록 &lt;a href=&quot;#config&quot;&gt;CONFIG&lt;/a&gt; 변수를 갱신하십시오 .</target>
        </trans-unit>
        <trans-unit id="519adfd81a5373cd725dc77ba69d6aa56719cd7c" translate="yes" xml:space="preserve">
          <source>If you need to expose data to QML components, you need to make them available to the context of the current QML engine. See &lt;a href=&quot;qqmlcontext&quot;&gt;QQmlContext&lt;/a&gt; for more information.</source>
          <target state="translated">QML 구성 요소에 데이터를 노출해야하는 경우 현재 QML 엔진의 컨텍스트에서 사용할 수 있도록해야합니다. 자세한 정보는 &lt;a href=&quot;qqmlcontext&quot;&gt;QQmlContext&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d9b7d0be063a4569fd31f202dedd7cca3cd9a550" translate="yes" xml:space="preserve">
          <source>If you need to handle incoming TCP connections (e.g., in a server application), use the &lt;a href=&quot;qtcpserver&quot;&gt;QTcpServer&lt;/a&gt; class. Call &lt;a href=&quot;qtcpserver#listen&quot;&gt;QTcpServer::listen&lt;/a&gt;() to set up the server, and connect to the &lt;a href=&quot;qtcpserver#newConnection&quot;&gt;QTcpServer::newConnection&lt;/a&gt;() signal, which is emitted once for every client that connects. In your slot, call &lt;a href=&quot;qtcpserver#nextPendingConnection&quot;&gt;QTcpServer::nextPendingConnection&lt;/a&gt;() to accept the connection and use the returned &lt;a href=&quot;qtcpsocket&quot;&gt;QTcpSocket&lt;/a&gt; to communicate with the client.</source>
          <target state="translated">들어오는 TCP 연결을 처리해야하는 경우 (예 : 서버 응용 프로그램에서) &lt;a href=&quot;qtcpserver&quot;&gt;QTcpServer&lt;/a&gt; 클래스를 사용하십시오 . &lt;a href=&quot;qtcpserver#listen&quot;&gt;QTcpServer :: listen&lt;/a&gt; ()을 호출 하여 서버를 설정하고 연결하는 모든 클라이언트에 대해 한 번씩 생성 되는 &lt;a href=&quot;qtcpserver#newConnection&quot;&gt;QTcpServer :: newConnection&lt;/a&gt; () 신호에 연결하십시오. 슬롯에서 &lt;a href=&quot;qtcpserver#nextPendingConnection&quot;&gt;QTcpServer :: nextPendingConnection&lt;/a&gt; ()을 호출 하여 연결을 승인하고 리턴 된 &lt;a href=&quot;qtcpsocket&quot;&gt;QTcpSocket&lt;/a&gt; 을 사용하여 클라이언트와 통신하십시오.</target>
        </trans-unit>
        <trans-unit id="9c2072c17e040860f444f8edd85f0a7ccd07039b" translate="yes" xml:space="preserve">
          <source>If you need to have translatable text completely outside a function, there are two macros to help: &lt;a href=&quot;#QT_TR_NOOP&quot;&gt;QT_TR_NOOP&lt;/a&gt;() and &lt;a href=&quot;#QT_TRANSLATE_NOOP&quot;&gt;QT_TRANSLATE_NOOP&lt;/a&gt;(). They merely mark the text for extraction by the &lt;code&gt;lupdate&lt;/code&gt; tool. The macros expand to just the text (without the context).</source>
          <target state="translated">번역 할 수있는 텍스트가 함수 외부에 완전히 있어야하는 경우 &lt;a href=&quot;#QT_TR_NOOP&quot;&gt;QT_TR_NOOP&lt;/a&gt; () 및 &lt;a href=&quot;#QT_TRANSLATE_NOOP&quot;&gt;QT_TRANSLATE_NOOP&lt;/a&gt; () 라는 두 가지 매크로가 있습니다. &lt;code&gt;lupdate&lt;/code&gt; 도구로 추출 할 텍스트 만 표시합니다 . 매크로는 컨텍스트없이 텍스트 만 확장합니다.</target>
        </trans-unit>
        <trans-unit id="aab2531b447cc12880786ec55864c21278ccbf87" translate="yes" xml:space="preserve">
          <source>If you need to have two different strings for &lt;a href=&quot;qundocommand#text&quot;&gt;text&lt;/a&gt;() and &lt;a href=&quot;qundocommand#actionText&quot;&gt;actionText&lt;/a&gt;(), separate them with &quot;\n&quot; and pass into this function. Even if you do not use this feature for English strings during development, you can still let translators use two different strings in order to match specific languages' needs. The described feature and the function &lt;a href=&quot;qundocommand#actionText&quot;&gt;actionText&lt;/a&gt;() are available since Qt 4.8.</source>
          <target state="translated">&lt;a href=&quot;qundocommand#text&quot;&gt;text&lt;/a&gt; ()와 &lt;a href=&quot;qundocommand#actionText&quot;&gt;actionText&lt;/a&gt; ()에 대해 서로 다른 두 개의 문자열이 필요한 경우 &quot;\ n&quot;으로 구분하여이 함수에 전달하십시오. 개발 중에 영어 문자열에이 기능을 사용하지 않더라도 번역가가 특정 언어의 요구에 맞게 두 개의 다른 문자열을 사용할 수 있습니다. 기술 된 특징 및 함수 &lt;a href=&quot;qundocommand#actionText&quot;&gt;actionText&lt;/a&gt; ()는 Qt 4.8부터 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="1a9a2adacfff0b2777d2e32710905d3d4b9316e0" translate="yes" xml:space="preserve">
          <source>If you need to hide the implementation details, you can use the &amp;lt;Type&amp;gt;Source class instead, which is the 2nd class declared in the header file. This class definition does not provide data members, and makes the getter/setter functions pure virtual as well. You have more flexibility in how you implement the class, although you need to write more code.</source>
          <target state="translated">구현 세부 사항을 숨길 필요가있는 경우 &amp;lt;Type&amp;gt; Source 클래스를 대신 사용할 수 있습니다.이 클래스는 헤더 파일에 선언 된 두 번째 클래스입니다. 이 클래스 정의는 데이터 멤버를 제공하지 않으며 getter / setter 함수를 순수 가상으로 만듭니다. 더 많은 코드를 작성해야하지만 클래스를 구현하는 방법이 더 유연합니다.</target>
        </trans-unit>
        <trans-unit id="d9cdef74aa4c95ffef75289e890aed596df23b78" translate="yes" xml:space="preserve">
          <source>If you need to identify specific objects, your application should provide UI for registering objects and mapping them to functionality: allow the user to select a meaning, virtual tool, or action, prompt the user to bring the object into proximity, and store a mapping from uniqueId to its purpose, for example in &lt;a href=&quot;qml-qt-labs-settings-settings&quot;&gt;Settings&lt;/a&gt;.</source>
          <target state="translated">특정 객체를 식별해야하는 경우 응용 프로그램은 객체를 등록하고이를 기능에 매핑하기위한 UI를 제공해야합니다. UNIQUEID에서 예를 들면 그 목적에 &lt;a href=&quot;qml-qt-labs-settings-settings&quot;&gt;설정&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="424e57500c05caf36ad3723c09a844bed95cd8be" translate="yes" xml:space="preserve">
          <source>If you need to insert a new item into the list at a particular position, then it should be constructed without a parent widget. The &lt;a href=&quot;qlistwidget#insertItem&quot;&gt;insertItem&lt;/a&gt;() function should then be used to place it within the list. The list widget will take ownership of the item.</source>
          <target state="translated">특정 위치에서 목록에 새 항목을 삽입해야하는 경우 상위 위젯없이 구성해야합니다. 그런 다음 &lt;a href=&quot;qlistwidget#insertItem&quot;&gt;insertItem&lt;/a&gt; () 함수를 사용하여 목록 내에 배치해야합니다. 목록 위젯은 항목의 소유권을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="91a7a709a86a27efd33ac820b90801a38fa581ba" translate="yes" xml:space="preserve">
          <source>If you need to interpolate other variant types, including custom types, you have to implement interpolation for these yourself. To do this, you can register an interpolator function for a given type. This function takes 3 parameters: the start value, the end value, and the current progress.</source>
          <target state="translated">사용자 정의 유형을 포함하여 다른 변형 유형을 보간해야하는 경우 이러한 유형에 대한 보간을 직접 구현해야합니다. 이를 위해 주어진 유형에 대해 보간 기 기능을 등록 할 수 있습니다. 이 함수는 시작 값, 종료 값 및 현재 진행률의 3 가지 매개 변수를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="bd38e2abcc058e1e2d4291dfaf58e15f21d80da9" translate="yes" xml:space="preserve">
          <source>If you need to programatically insert translations into a &lt;a href=&quot;qtranslator&quot;&gt;QTranslator&lt;/a&gt;, this function can be reimplemented.</source>
          <target state="translated">프로그래밍 방식으로 번역을 &lt;a href=&quot;qtranslator&quot;&gt;QTranslator에&lt;/a&gt; 삽입해야하는 경우이 기능을 다시 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="abdd8296c8ec5fc28dfa79ecfbd861b121d7e2a6" translate="yes" xml:space="preserve">
          <source>If you need to provide a scrolling view onto another widget, it may be more convenient to use the &lt;a href=&quot;qscrollarea&quot;&gt;QScrollArea&lt;/a&gt; class because this provides a viewport widget and scroll bars. &lt;a href=&quot;qscrollbar&quot;&gt;QScrollBar&lt;/a&gt; is useful if you need to implement similar functionality for specialized widgets using &lt;a href=&quot;qabstractscrollarea&quot;&gt;QAbstractScrollArea&lt;/a&gt;; for example, if you decide to subclass &lt;a href=&quot;qabstractitemview&quot;&gt;QAbstractItemView&lt;/a&gt;. For most other situations where a slider control is used to obtain a value within a given range, the &lt;a href=&quot;qslider&quot;&gt;QSlider&lt;/a&gt; class may be more appropriate for your needs.</source>
          <target state="translated">다른 위젯으로 스크롤보기를 제공해야하는 경우 &lt;a href=&quot;qscrollarea&quot;&gt;QScrollArea&lt;/a&gt; 클래스 를 사용하는 것이 뷰포트 위젯 및 스크롤 막대를 제공하므로 보다 편리 할 수 ​​있습니다 . &lt;a href=&quot;qscrollbar&quot;&gt;QScrollBar&lt;/a&gt; 는 &lt;a href=&quot;qabstractscrollarea&quot;&gt;QAbstractScrollArea를&lt;/a&gt; 사용하여 특수 위젯에 유사한 기능을 구현해야하는 경우 유용합니다 . 예를 들어 &lt;a href=&quot;qabstractitemview&quot;&gt;QAbstractItemView&lt;/a&gt; 를 서브 클래스로 결정한 경우 . 슬라이더 컨트롤을 사용하여 지정된 범위 내에서 값을 얻는 대부분의 다른 상황에서는 &lt;a href=&quot;qslider&quot;&gt;QSlider&lt;/a&gt; 클래스가 필요에 더 적합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aee0d7e82a69b338949c0fd649b848c1c596b557" translate="yes" xml:space="preserve">
          <source>If you need to react to events that pass parameters of unsupported datatypes you can use the generic signal that delivers the event data as provided by the COM event.</source>
          <target state="translated">지원되지 않는 데이터 유형의 매개 변수를 전달하는 이벤트에 반응해야하는 경우 COM 이벤트에서 제공 한대로 이벤트 데이터를 전달하는 일반 신호를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6fbe9cee9a63dbb8da30a1f9d07d90fe350cd2da" translate="yes" xml:space="preserve">
          <source>If you need to register a C++ class to use from QML, you can call &lt;a href=&quot;qqmlengine#qmlRegisterType-1&quot;&gt;qmlRegisterType&lt;/a&gt;() before declaring your &lt;a href=&quot;qqmlapplicationengine&quot;&gt;QQmlApplicationEngine&lt;/a&gt;. See &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtqml-cppintegration-overview.html#defining-qml-types-from-c&quot;&gt;Defining QML Types from C++&lt;/a&gt; for more information.</source>
          <target state="translated">당신은 QML에서 사용할 수있는 C ++ 클래스를 등록해야하는 경우 호출 할 수 있습니다 &lt;a href=&quot;qqmlengine#qmlRegisterType-1&quot;&gt;qmlRegisterType을&lt;/a&gt; 당신의 선언하기 전에 () &lt;a href=&quot;qqmlapplicationengine&quot;&gt;QQmlApplicationEngine를&lt;/a&gt; . 자세한 정보 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtqml-cppintegration-overview.html#defining-qml-types-from-c&quot;&gt;는 C ++에서 QML 유형 정의&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="070df41811e4cfcb443c483f838b46b263327697" translate="yes" xml:space="preserve">
          <source>If you need to save the cookies to disk, you have to derive from &lt;a href=&quot;qnetworkcookiejar&quot;&gt;QNetworkCookieJar&lt;/a&gt; and save the cookies to disk yourself.</source>
          <target state="translated">쿠키를 디스크에 저장해야하는 경우 &lt;a href=&quot;qnetworkcookiejar&quot;&gt;QNetworkCookieJar&lt;/a&gt; 에서 파생 하여 쿠키를 디스크에 직접 저장해야합니다.</target>
        </trans-unit>
        <trans-unit id="11677a07f59fd2e9a0986a72e6b84c2aa0ffc7b2" translate="yes" xml:space="preserve">
          <source>If you need to set the height of a given row to a fixed value, call &lt;a href=&quot;qheaderview#resizeSection&quot;&gt;QHeaderView::resizeSection&lt;/a&gt;() on the table's vertical header.</source>
          <target state="translated">주어진 행의 높이를 고정 된 값으로 설정해야하는 경우 테이블의 세로 헤더에서 &lt;a href=&quot;qheaderview#resizeSection&quot;&gt;QHeaderView :: resizeSection&lt;/a&gt; ()을 호출 하십시오 .</target>
        </trans-unit>
        <trans-unit id="06aa884764c4854a13cd94643e4c1dc676f0acf2" translate="yes" xml:space="preserve">
          <source>If you need to set the width of a given column to a fixed value, call &lt;a href=&quot;qheaderview#resizeSection&quot;&gt;QHeaderView::resizeSection&lt;/a&gt;() on the table's horizontal header.</source>
          <target state="translated">주어진 열의 너비를 고정 된 값으로 설정해야하는 경우 테이블의 가로 헤더에서 &lt;a href=&quot;qheaderview#resizeSection&quot;&gt;QHeaderView :: resizeSection&lt;/a&gt; ()을 호출 하십시오 .</target>
        </trans-unit>
        <trans-unit id="8d8ffa11866f62c1262dc9debe5cf831cc949b36" translate="yes" xml:space="preserve">
          <source>If you need to set the width of a given column to a fixed value, call &lt;a href=&quot;qheaderview#resizeSection&quot;&gt;QHeaderView::resizeSection&lt;/a&gt;() on the view's header.</source>
          <target state="translated">주어진 열의 너비를 고정 된 값으로 설정해야하는 경우 뷰 헤더에서 &lt;a href=&quot;qheaderview#resizeSection&quot;&gt;QHeaderView :: resizeSection&lt;/a&gt; ()을 호출 하십시오 .</target>
        </trans-unit>
        <trans-unit id="37c115c6486d5e86ef8fcd9338eb375846af8d7b" translate="yes" xml:space="preserve">
          <source>If you need to trigger a repaint from places other than &lt;a href=&quot;qopenglwidget#paintGL&quot;&gt;paintGL&lt;/a&gt;() (a typical example is when using &lt;a href=&quot;qtimer&quot;&gt;timers&lt;/a&gt; to animate scenes), you should call the widget's &lt;a href=&quot;qwidget#update&quot;&gt;update&lt;/a&gt;() function to schedule an update.</source>
          <target state="translated">&lt;a href=&quot;qopenglwidget#paintGL&quot;&gt;paintGL&lt;/a&gt; () 이외의 장소에서 다시 그리기를 트리거해야하는 경우 (일반적인 예는 &lt;a href=&quot;qtimer&quot;&gt;타이머&lt;/a&gt; 를 사용하여 장면에 애니메이션을 적용 할 때 ) 위젯의 &lt;a href=&quot;qwidget#update&quot;&gt;업데이트&lt;/a&gt; () 함수를 호출하여 업데이트 를 예약해야합니다.</target>
        </trans-unit>
        <trans-unit id="a9d06232d9c3dd95a5b84067a80c515158f99fb4" translate="yes" xml:space="preserve">
          <source>If you need to use the &lt;code&gt;widget&lt;/code&gt; argument to obtain additional information, be careful to ensure that it isn't 0 and that it is of the correct type before using it. For example:</source>
          <target state="translated">추가 정보를 얻기 위해 &lt;code&gt;widget&lt;/code&gt; 인수 를 사용해야하는 경우 , 사용하기 전에 0이 아니고 올바른 유형인지 확인하십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="342e5e2c96f1b7735f5d0c43329a1275eddb3a9f" translate="yes" xml:space="preserve">
          <source>If you need toggle behavior (see &lt;a href=&quot;qabstractbutton#checkable-prop&quot;&gt;setCheckable&lt;/a&gt;()) or a button that auto-repeats the activation signal when being pushed down like the arrows in a scroll bar (see &lt;a href=&quot;qabstractbutton#autoRepeat-prop&quot;&gt;setAutoRepeat&lt;/a&gt;()), a command button is probably not what you want. When in doubt, use a tool button.</source>
          <target state="translated">토글 동작 ( &lt;a href=&quot;qabstractbutton#checkable-prop&quot;&gt;setCheckable&lt;/a&gt; () 참조 )이나 스크롤 막대의 화살표처럼 아래로 눌렀을 때 활성화 신호를 자동 반복하는 버튼 ( &lt;a href=&quot;qabstractbutton#autoRepeat-prop&quot;&gt;setAutoRepeat&lt;/a&gt; () 참조 )이 필요한 경우 명령 버튼이 원하는 것이 아닐 수 있습니다. 의심스러운 경우 도구 단추를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="595944df693a930933ce18bd6f32394d05a05c6f" translate="yes" xml:space="preserve">
          <source>If you only need to extract the values from a hash (not the keys), you can also use &lt;a href=&quot;containers#foreach&quot;&gt;foreach&lt;/a&gt;:</source>
          <target state="translated">키가 아닌 해시에서만 값을 추출해야하는 경우 &lt;a href=&quot;containers#foreach&quot;&gt;foreach&lt;/a&gt; 를 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cb290be20faaadde003e66d6e10ca093fb9aec1a" translate="yes" xml:space="preserve">
          <source>If you only need to extract the values from a map (not the keys), you can also use &lt;a href=&quot;containers#foreach&quot;&gt;foreach&lt;/a&gt;:</source>
          <target state="translated">키가 아닌 맵에서 값만 추출해야하는 경우 &lt;a href=&quot;containers#foreach&quot;&gt;foreach&lt;/a&gt; 를 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="af9902078a527e4b41418e71e29f173b97546a06" translate="yes" xml:space="preserve">
          <source>If you only need to show plain text in an item, consider using &lt;a href=&quot;qgraphicssimpletextitem&quot;&gt;QGraphicsSimpleTextItem&lt;/a&gt; instead.</source>
          <target state="translated">항목에 일반 텍스트 만 표시해야하는 경우 &lt;a href=&quot;qgraphicssimpletextitem&quot;&gt;QGraphicsSimpleTextItem을&lt;/a&gt; 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="8d9a6fad5ee10addfae06f1d28f7009954de1b27" translate="yes" xml:space="preserve">
          <source>If you only want to remove the entries in the current &lt;a href=&quot;qsettings#group&quot;&gt;group&lt;/a&gt;(), use remove(&quot;&quot;) instead.</source>
          <target state="translated">현재 &lt;a href=&quot;qsettings#group&quot;&gt;그룹&lt;/a&gt; () 의 항목 만 제거하려면 대신 remove ( &quot;&quot;)를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="1981b65c0e1afa08eff47ad52174318a614d9ae7" translate="yes" xml:space="preserve">
          <source>If you open the buffer in write-only mode or read-write mode and write something into the &lt;a href=&quot;qbuffer&quot;&gt;QBuffer&lt;/a&gt;,</source>
          <target state="translated">당신이 쓰기 전용 모드로 버퍼를 열거 나에 모드 및 쓰기 뭔가 읽기 - 쓰기 경우 &lt;a href=&quot;qbuffer&quot;&gt;QBuffer&lt;/a&gt; ,</target>
        </trans-unit>
        <trans-unit id="b1432aef431beb90fd8a3836144deeea09dc4ba0" translate="yes" xml:space="preserve">
          <source>If you parse XML data that does not utilize namespaces according to the XML specification or doesn't use namespaces at all, you can use the element's &lt;a href=&quot;qxmlstreamreader#qualifiedName&quot;&gt;qualifiedName&lt;/a&gt;() instead. A qualified name is the element's &lt;a href=&quot;qxmlstreamreader#prefix&quot;&gt;prefix&lt;/a&gt;() followed by colon followed by the element's local &lt;a href=&quot;qxmlstreamreader#name&quot;&gt;name&lt;/a&gt;() - exactly like the element appears in the raw XML data. Since the mapping &lt;a href=&quot;qxmlstreamreader#namespaceUri&quot;&gt;namespaceUri&lt;/a&gt; to prefix is neither unique nor universal, &lt;a href=&quot;qxmlstreamreader#qualifiedName&quot;&gt;qualifiedName&lt;/a&gt;() should be avoided for namespace-compliant XML data.</source>
          <target state="translated">XML 사양에 따라 네임 스페이스를 사용하지 않거나 네임 스페이스를 전혀 사용하지 않는 XML 데이터를 구문 분석하는 경우 요소의 &lt;a href=&quot;qxmlstreamreader#qualifiedName&quot;&gt;QualifiedName&lt;/a&gt; ()을 대신 사용할 수 있습니다 . 정규화 된 이름은 요소의 &lt;a href=&quot;qxmlstreamreader#prefix&quot;&gt;접두사&lt;/a&gt; (), 콜론, 요소의 로컬 &lt;a href=&quot;qxmlstreamreader#name&quot;&gt;이름&lt;/a&gt; ()입니다. 요소가 원시 XML 데이터에 나타나는 것과 같습니다. &lt;a href=&quot;qxmlstreamreader#namespaceUri&quot;&gt;namespaceUri&lt;/a&gt; 를 접두사에 매핑 하는 것은 고유하거나 보편적이지 않으므로 네임 스페이스 호환 XML 데이터에 대해서는 &lt;a href=&quot;qxmlstreamreader#qualifiedName&quot;&gt;QualifiedName&lt;/a&gt; ()을 사용하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="a9cadaec13e38df68e5abb156e901760e7c27372" translate="yes" xml:space="preserve">
          <source>If you pass &lt;code&gt;stsvar&lt;/code&gt;, the command's exit status will be stored in that variable. If the command crashes, the status will be -1, otherwise a non-negative exit code of the command's choosing. Usually, comparing the status with zero (success) is sufficient.</source>
          <target state="translated">&lt;code&gt;stsvar&lt;/code&gt; 를 전달 하면 명령의 종료 상태가 해당 변수에 저장됩니다. 명령이 충돌하면 상태는 -1이되고, 그렇지 않으면 명령이 선택하는 음이 아닌 종료 코드가됩니다. 일반적으로 상태를 0 (성공)으로 비교하면 충분합니다.</target>
        </trans-unit>
        <trans-unit id="2468029b6202e79cf90eedbcc8b9f8bac7c82f7e" translate="yes" xml:space="preserve">
          <source>If you pass a directory or file, the &lt;a href=&quot;qstorageinfo&quot;&gt;QStorageInfo&lt;/a&gt; object will refer to the volume where this directory or file is located. You can check if the created object is correct using the &lt;a href=&quot;qstorageinfo#isValid&quot;&gt;isValid&lt;/a&gt;() method.</source>
          <target state="translated">디렉토리 나 파일을 전달하면 &lt;a href=&quot;qstorageinfo&quot;&gt;QStorageInfo&lt;/a&gt; 오브젝트는이 디렉토리 나 파일이있는 볼륨을 참조합니다. &lt;a href=&quot;qstorageinfo#isValid&quot;&gt;isValid&lt;/a&gt; () 메소드를 사용하여 작성된 오브젝트가 올바른지 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="095eb0d3621325e3be7f0f3c9d8de12134c82c50" translate="yes" xml:space="preserve">
          <source>If you pass a literal IP address to</source>
          <target state="translated">리터럴 IP 주소를</target>
        </trans-unit>
        <trans-unit id="c440b0ccf58e2711892efe6e2daa75e11c2eb77f" translate="yes" xml:space="preserve">
          <source>If you pass a parent to &lt;a href=&quot;qrubberband&quot;&gt;QRubberBand&lt;/a&gt;'s constructor, the rubber band will display only inside its parent, but stays on top of other child widgets. If no parent is passed, &lt;a href=&quot;qrubberband&quot;&gt;QRubberBand&lt;/a&gt; will act as a top-level widget.</source>
          <target state="translated">&lt;a href=&quot;qrubberband&quot;&gt;QRubberBand&lt;/a&gt; 의 생성자에 부모를 전달 하면 고무 밴드가 부모 내부에만 표시되지만 다른 자식 위젯 위에 유지됩니다. 상위가 전달되지 않으면 &lt;a href=&quot;qrubberband&quot;&gt;QRubberBand&lt;/a&gt; 는 최상위 레벨 위젯으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="58ac130298ee38b7431712a4fcde652ae17a3c46" translate="yes" xml:space="preserve">
          <source>If you pass the SubPath option, this introspection has to include all child nodes. Otherwise &lt;a href=&quot;qdbus&quot;&gt;QDBus&lt;/a&gt; handles the introspection of the child nodes.</source>
          <target state="translated">SubPath 옵션을 전달하면이 내부 검사에는 모든 자식 노드가 포함되어야합니다. 그렇지 않으면 &lt;a href=&quot;qdbus&quot;&gt;QDBus&lt;/a&gt; 는 자식 노드의 내부 검사를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="62cbd3dd55a6c3dd22dd756d6bec35f6568c6d0e" translate="yes" xml:space="preserve">
          <source>If you pass the function a format string and a list of arguments, it works in similar way to the C printf() function. The format should be a Latin-1 string.</source>
          <target state="translated">함수에 형식 문자열과 인수 목록을 전달하면 C printf () 함수와 유사한 방식으로 작동합니다. 형식은 라틴 -1 문자열이어야합니다.</target>
        </trans-unit>
        <trans-unit id="42f31dacf417f05e127400fc88bee63ad97c25aa" translate="yes" xml:space="preserve">
          <source>If you prefer the STL-style iterators, you can call &lt;a href=&quot;qmultimap#find&quot;&gt;find&lt;/a&gt;() to get the iterator for the first item with a key and iterate from there:</source>
          <target state="translated">STL 스타일 반복자를 선호하는 경우 &lt;a href=&quot;qmultimap#find&quot;&gt;find&lt;/a&gt; ()를 호출 하여 키가있는 첫 번째 항목의 반복자를 가져 와서 반복 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bfe35a94f18877c56725758571c2d1f2bbda275e" translate="yes" xml:space="preserve">
          <source>If you provide 'A' as an argument to the \list command, the bullets are replaced with characters in alphabetical order:</source>
          <target state="translated">\ list 명령에 인수로 'A'를 제공하면 글 머리 기호가 알파벳 순서로 문자로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="ae37e01cf5eb2864e6b40947b465f94efbf33c9a" translate="yes" xml:space="preserve">
          <source>If you provide 'i' as the argument, the bullets are replaced with roman numerals:</source>
          <target state="translated">'i'를 인수로 제공하면 글 머리 기호가 로마 숫자로 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="731970c1d1538198d94cf0457f2b4f3e4be894b3" translate="yes" xml:space="preserve">
          <source>If you re-implement this method in a subclass, be sure to call</source>
          <target state="translated">서브 클래스에서이 메소드를 다시 구현하는 경우 다음을 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="c345887566efa1bc25ea77a4606f6a41c7e58022" translate="yes" xml:space="preserve">
          <source>If you reimplement &lt;a href=&quot;qwizardpage#isComplete&quot;&gt;isComplete&lt;/a&gt;(), make sure to emit completeChanged() whenever the value of &lt;a href=&quot;qwizardpage#isComplete&quot;&gt;isComplete&lt;/a&gt;() changes, to ensure that &lt;a href=&quot;qwizard&quot;&gt;QWizard&lt;/a&gt; updates the enabled or disabled state of its buttons.</source>
          <target state="translated">&lt;a href=&quot;qwizardpage#isComplete&quot;&gt;isComplete&lt;/a&gt; () 을 다시 구현하는 경우 &lt;a href=&quot;qwizard&quot;&gt;QWizard&lt;/a&gt; 가 버튼의 활성화 또는 비활성화 상태를 업데이트 하도록 &lt;a href=&quot;qwizardpage#isComplete&quot;&gt;isComplete&lt;/a&gt; () 의 값이 변경 될 때마다 completeChanged ()를 방출해야 합니다.</target>
        </trans-unit>
        <trans-unit id="914843405683e7c66dc5a8782b04dd8c9a8dd7df" translate="yes" xml:space="preserve">
          <source>If you reimplement this function in a subclass, note that the value you return is only used when &lt;a href=&quot;qtableview#resizeRowToContents&quot;&gt;resizeRowToContents&lt;/a&gt;() is called. In that case, if a larger row height is required by either the vertical header or the item delegate, that width will be used instead.</source>
          <target state="translated">서브 클래스에서이 함수를 다시 구현하면, &lt;a href=&quot;qtableview#resizeRowToContents&quot;&gt;resizeRowToContents&lt;/a&gt; ()가 호출 될 때만 리턴하는 값이 사용됩니다 . 이 경우 세로 머리글 또는 항목 대리자가 더 큰 행 높이를 요구하면 해당 너비가 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="dc4cc9b4c334f4a25945c6d6e420725dabce950f" translate="yes" xml:space="preserve">
          <source>If you reimplement this function in a subclass, note that the value you return is only used when &lt;a href=&quot;qtreeview#resizeColumnToContents&quot;&gt;resizeColumnToContents&lt;/a&gt;() is called. In that case, if a larger column width is required by either the view's header or the item delegate, that width will be used instead.</source>
          <target state="translated">서브 클래스에서이 함수를 다시 구현하는 경우, &lt;a href=&quot;qtreeview#resizeColumnToContents&quot;&gt;resizeColumnToContents&lt;/a&gt; ()가 호출 될 때만 리턴하는 값이 사용됩니다 . 이 경우 뷰의 머리글이나 항목 대리자가 더 큰 열 너비를 요구하면 해당 너비가 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="80faad784ed683b7ebe81a65a067e804edbd5ae4" translate="yes" xml:space="preserve">
          <source>If you reimplement this function in a subclass, note that the value you return will be used when &lt;a href=&quot;qtableview#resizeColumnToContents&quot;&gt;resizeColumnToContents&lt;/a&gt;() or &lt;a href=&quot;qheaderview#resizeSections-1&quot;&gt;QHeaderView::resizeSections&lt;/a&gt;() is called. If a larger column width is required by either the horizontal header or the item delegate, the larger width will be used instead.</source>
          <target state="translated">서브 클래스에서이 함수를 다시 구현하는 경우 &lt;a href=&quot;qtableview#resizeColumnToContents&quot;&gt;resizeColumnToContents&lt;/a&gt; () 또는 &lt;a href=&quot;qheaderview#resizeSections-1&quot;&gt;QHeaderView :: resizeSections&lt;/a&gt; ()가 호출 될 때 리턴하는 값이 사용됩니다 . 가로 머리글이나 항목 대리자에 더 큰 열 너비가 필요한 경우 더 큰 너비가 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="14bf8a36129c68c52297b33af2104f3a3e57519f" translate="yes" xml:space="preserve">
          <source>If you reimplement this function in your custom model, you must also reimplement the member functions that call it: &lt;a href=&quot;qabstractitemmodel#mimeData&quot;&gt;mimeData&lt;/a&gt;() and &lt;a href=&quot;qabstractitemmodel#dropMimeData&quot;&gt;dropMimeData&lt;/a&gt;().</source>
          <target state="translated">사용자 정의 모델에서이 함수를 다시 구현하는 경우이를 호출하는 멤버 함수 &lt;a href=&quot;qabstractitemmodel#mimeData&quot;&gt;mimeData&lt;/a&gt; () 및 &lt;a href=&quot;qabstractitemmodel#dropMimeData&quot;&gt;dropMimeData&lt;/a&gt; () 도 다시 구현해야합니다 .</target>
        </trans-unit>
        <trans-unit id="241523b4fecf200ea38f75fde41e25bf784b4fb7" translate="yes" xml:space="preserve">
          <source>If you reimplement this function to show a custom pop-up, make sure you call &lt;a href=&quot;qcombobox#hidePopup&quot;&gt;hidePopup&lt;/a&gt;() to reset the internal state.</source>
          <target state="translated">이 함수를 다시 구현하여 사용자 정의 팝업을 표시하는 경우 &lt;a href=&quot;qcombobox#hidePopup&quot;&gt;hidePopup&lt;/a&gt; ()을 호출 하여 내부 상태를 재설정하십시오.</target>
        </trans-unit>
        <trans-unit id="317cef53e92834b58f8db232e0262505d2f0d722" translate="yes" xml:space="preserve">
          <source>If you reimplement this function you also have to implement &lt;a href=&quot;qaxbindable#readData&quot;&gt;readData&lt;/a&gt;(). The default implementation does nothing and returns false.</source>
          <target state="translated">이 함수를 다시 구현하면 &lt;a href=&quot;qaxbindable#readData&quot;&gt;readData&lt;/a&gt; ()도 구현해야합니다 . 기본 구현은 아무것도하지 않고 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a5f6f0fc3652bfa4cdf346a95036c06abc5448ad" translate="yes" xml:space="preserve">
          <source>If you reimplement this function you also have to implement &lt;a href=&quot;qaxbindable#writeData&quot;&gt;writeData&lt;/a&gt;(). The default implementation does nothing and returns false.</source>
          <target state="translated">이 함수를 다시 구현하면 &lt;a href=&quot;qaxbindable#writeData&quot;&gt;writeData&lt;/a&gt; ()도 구현해야합니다 . 기본 구현은 아무것도하지 않고 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="59c499ef805f5adda87a6e828740b95fa5da9b9c" translate="yes" xml:space="preserve">
          <source>If you reimplement this function you must also reimplement &lt;a href=&quot;qaxfactory#unregisterClass&quot;&gt;unregisterClass&lt;/a&gt;() to remove the additional registry values.</source>
          <target state="translated">이 함수를 다시 구현하면 &lt;a href=&quot;qaxfactory#unregisterClass&quot;&gt;unregisterClass&lt;/a&gt; () 도 다시 구현 하여 추가 레지스트리 값을 제거해야합니다.</target>
        </trans-unit>
        <trans-unit id="5dafa3e034af5fad97569d1e5e7ef17dc7603299" translate="yes" xml:space="preserve">
          <source>If you reimplement this function you must also reimplement the destructor to call clear(), and call this implementation at the end of your clear() function.</source>
          <target state="translated">이 함수를 다시 구현하면 소멸자를 다시 구현하여 clear ()를 호출하고 clear () 함수 끝에서이 구현을 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="ba7b5a834b411685e0a6145d25de991fe9466f7e" translate="yes" xml:space="preserve">
          <source>If you reimplement this function, be careful to return the correct value: it should return the number of bytes read in this line, including the terminating newline, or 0 if there is no line to be read at this point. If an error occurs, it should return -1 if and only if no bytes were read. Reading past EOF is considered an error.</source>
          <target state="translated">이 함수를 다시 구현하는 경우 올바른 값을 반환하도록주의하십시오. 종료 줄 바꿈을 포함하여이 줄에서 읽은 바이트 수를 반환하거나이 시점에서 읽을 줄이 없으면 0을 반환해야합니다. 오류가 발생하면 읽은 바이트가없는 경우에만 -1을 반환해야합니다. EOF 지나서 읽는 것은 오류로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="7f0f811b2dee4e47f7f67e785a39ee8b1336e278" translate="yes" xml:space="preserve">
          <source>If you reimplement this function, make sure to emit &lt;a href=&quot;qwizardpage#completeChanged&quot;&gt;completeChanged&lt;/a&gt;(), from the rest of your implementation, whenever the value of isComplete() changes. This ensures that &lt;a href=&quot;qwizard&quot;&gt;QWizard&lt;/a&gt; updates the enabled or disabled state of its buttons. An example of the reimplementation is available &lt;a href=&quot;http://doc.qt.io/archives/qq/qq22-qwizard.html#validatebeforeitstoolate&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">이 함수를 다시 구현하는 경우 isComplete () 값이 변경 될 때마다 나머지 구현에서 &lt;a href=&quot;qwizardpage#completeChanged&quot;&gt;completeChanged&lt;/a&gt; ()를 내 보내야합니다. 이를 통해 &lt;a href=&quot;qwizard&quot;&gt;QWizard&lt;/a&gt; 는 해당 버튼의 활성화 또는 비활성화 상태를 업데이트합니다. 재 구현 예는 &lt;a href=&quot;http://doc.qt.io/archives/qq/qq22-qwizard.html#validatebeforeitstoolate&quot;&gt;여기에서&lt;/a&gt; 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6121aea8e26ace6bd5c7785a32c8007ecd435fbe" translate="yes" xml:space="preserve">
          <source>If you reimplement this function, note that the ownership of the returned &lt;a href=&quot;qmimedata&quot;&gt;QMimeData&lt;/a&gt; object is passed to the caller. The selection can be retrieved by using the &lt;a href=&quot;qplaintextedit#textCursor&quot;&gt;textCursor&lt;/a&gt;() function.</source>
          <target state="translated">이 함수를 다시 구현하면 반환 된 &lt;a href=&quot;qmimedata&quot;&gt;QMimeData&lt;/a&gt; 객체 의 소유권 이 호출자에게 전달됩니다. &lt;a href=&quot;qplaintextedit#textCursor&quot;&gt;textCursor&lt;/a&gt; () 함수를 사용하여 선택을 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="019f7bf1d1d734e24dd917dd0cee3eadc03d7fdb" translate="yes" xml:space="preserve">
          <source>If you reimplement this function, note that the ownership of the returned &lt;a href=&quot;qmimedata&quot;&gt;QMimeData&lt;/a&gt; object is passed to the caller. The selection can be retrieved by using the &lt;a href=&quot;qtextedit#textCursor&quot;&gt;textCursor&lt;/a&gt;() function.</source>
          <target state="translated">이 함수를 다시 구현하면 반환 된 &lt;a href=&quot;qmimedata&quot;&gt;QMimeData&lt;/a&gt; 객체 의 소유권 이 호출자에게 전달됩니다. &lt;a href=&quot;qtextedit#textCursor&quot;&gt;textCursor&lt;/a&gt; () 함수를 사용하여 선택을 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="48ee44b9472494640a1a02db7be151a05fbbfe6f" translate="yes" xml:space="preserve">
          <source>If you reimplement this function, you can return other &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; types. The table below shows which variant types are supported depending on the resource type:</source>
          <target state="translated">이 기능을 다시 구현하면 다른 &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; 유형을 반환 할 수 있습니다. 아래 표는 리소스 유형에 따라 지원되는 변형 유형을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="19a862905403389a4b02d238d2699e0e0553cbaf" translate="yes" xml:space="preserve">
          <source>If you reimplement this handler, it is very important that you &lt;a href=&quot;qevent&quot;&gt;ignore()&lt;/a&gt; the event if you do not handle it, so that the widget's parent can interpret it.</source>
          <target state="translated">이 핸들러를 다시 구현 하는 경우 위젯의 상위가 해석 할 수 있도록 처리하지 않으면 이벤트 를 &lt;a href=&quot;qevent&quot;&gt;무시 ()&lt;/a&gt; 하는 것이 매우 중요 합니다.</target>
        </trans-unit>
        <trans-unit id="bd6881e41238ecfdfdf2717ee493442d7a4ad036" translate="yes" xml:space="preserve">
          <source>If you reimplement this handler, it is very important that you call the base class implementation if you do not act upon the key.</source>
          <target state="translated">이 핸들러를 다시 구현하는 경우 키를 조작하지 않으면 기본 클래스 구현을 호출하는 것이 매우 중요합니다.</target>
        </trans-unit>
        <trans-unit id="7e8e223786b37a873a7278ae8baeb7e9b6b9e63c" translate="yes" xml:space="preserve">
          <source>If you reimplement this you must also reimplement &lt;a href=&quot;qabstractitemdelegate#paint&quot;&gt;paint&lt;/a&gt;().</source>
          <target state="translated">이것을 다시 구현하면 &lt;a href=&quot;qabstractitemdelegate#paint&quot;&gt;페인트&lt;/a&gt; () 도 다시 구현해야합니다 .</target>
        </trans-unit>
        <trans-unit id="637e7ac5550b4557cb47b73ba483c57837079309" translate="yes" xml:space="preserve">
          <source>If you reimplement this you must also reimplement &lt;a href=&quot;qabstractitemdelegate#sizeHint&quot;&gt;sizeHint&lt;/a&gt;().</source>
          <target state="translated">이를 다시 구현하면 &lt;a href=&quot;qabstractitemdelegate#sizeHint&quot;&gt;sizeHint&lt;/a&gt; () 도 다시 구현해야합니다 .</target>
        </trans-unit>
        <trans-unit id="ce640650d17e4498675375a04b2eb5b8a0016844" translate="yes" xml:space="preserve">
          <source>If you reimplement this, you may also need to reimplement &lt;a href=&quot;qdatetimeedit#validate&quot;&gt;validate&lt;/a&gt;().</source>
          <target state="translated">이것을 다시 구현하면 &lt;a href=&quot;qdatetimeedit#validate&quot;&gt;validate&lt;/a&gt; () 를 다시 구현해야 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a33c3d76f7cfc8a3320bef2d8f1e863c93b633cd" translate="yes" xml:space="preserve">
          <source>If you reimplement this, you may also need to reimplement &lt;a href=&quot;qdoublespinbox#valueFromText&quot;&gt;valueFromText&lt;/a&gt;().</source>
          <target state="translated">이를 다시 구현하면 &lt;a href=&quot;qdoublespinbox#valueFromText&quot;&gt;valueFromText&lt;/a&gt; () 를 다시 구현해야 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7e6e004075e74e9581fdc0b4adde39e723bceee2" translate="yes" xml:space="preserve">
          <source>If you reimplement this, you may also need to reimplement &lt;a href=&quot;qspinbox#valueFromText&quot;&gt;valueFromText&lt;/a&gt;() and &lt;a href=&quot;qspinbox#validate&quot;&gt;validate&lt;/a&gt;()</source>
          <target state="translated">이것을 다시 구현하면 &lt;a href=&quot;qspinbox#valueFromText&quot;&gt;valueFromText&lt;/a&gt; () 를 다시 구현 하고 &lt;a href=&quot;qspinbox#validate&quot;&gt;유효성 검사&lt;/a&gt; () 해야 할 수도 있습니다</target>
        </trans-unit>
        <trans-unit id="037eabcdd3665a989ed4b2e44de2d118c2dd4856" translate="yes" xml:space="preserve">
          <source>If you remove the menu bar, a new one can be created by selecting the &lt;b&gt;Create Menu Bar&lt;/b&gt; option from the context menu, obtained by right-clicking within the main window form.</source>
          <target state="translated">메뉴 표시 줄을 제거 하면 기본 창 양식에서 마우스 오른쪽 단추를 클릭하여 표시되는 상황에 맞는 메뉴에서 &lt;b&gt;메뉴 표시 줄 작성&lt;/b&gt; 옵션을 선택하여 새 메뉴 표시 줄을 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ccfdab642e1e2bbb6355170fc5b98e2173313427" translate="yes" xml:space="preserve">
          <source>If you replace 'A' with '1', the list items are numbered in ascending order:</source>
          <target state="translated">'A'를 '1'로 바꾸면 목록 항목이 오름차순으로 번호가 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="d82384c56b8b47dd8ba0f28c64d195e5e8098152" translate="yes" xml:space="preserve">
          <source>If you require finer control over playing sounds, consider the &lt;a href=&quot;qsoundeffect&quot;&gt;QSoundEffect&lt;/a&gt; or &lt;a href=&quot;qaudiooutput&quot;&gt;QAudioOutput&lt;/a&gt; classes.</source>
          <target state="translated">사운드 재생을보다 세밀하게 제어해야하는 경우 &lt;a href=&quot;qsoundeffect&quot;&gt;QSoundEffect&lt;/a&gt; 또는 &lt;a href=&quot;qaudiooutput&quot;&gt;QAudioOutput&lt;/a&gt; 클래스를 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="70a2df5240d20ed12120f0888cff3009256a2d06" translate="yes" xml:space="preserve">
          <source>If you restore the Z value, the item's insertion order will decide its stacking order.</source>
          <target state="translated">Z 값을 복원하면 항목의 삽입 순서에 따라 스택 순서가 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="2c7ed57b46833bd7c963562211c28f66948481e5" translate="yes" xml:space="preserve">
          <source>If you set &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt;'s &lt;a href=&quot;qpainter#RenderHint-enum&quot;&gt;anti-aliasing&lt;/a&gt; render hint, the pixels will be rendered symetrically on both sides of the mathematically defined points:</source>
          <target state="translated">&lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; 의 &lt;a href=&quot;qpainter#RenderHint-enum&quot;&gt;앤티 앨리어싱&lt;/a&gt; 렌더 힌트 를 설정 하면 수학적으로 정의 된 점의 양쪽에 픽셀이 대칭으로 렌더링됩니다.</target>
        </trans-unit>
        <trans-unit id="403ac36c3dc11f4321381173d9b10dd0fa897d5e" translate="yes" xml:space="preserve">
          <source>If you set &lt;code&gt;QML_IMPORT_TRACE=1&lt;/code&gt; before running the &lt;a href=&quot;qtquick-qmlscene#&quot;&gt;QML Scene&lt;/a&gt; or your QML C++ application, you will see output similar to:</source>
          <target state="translated">&lt;a href=&quot;qtquick-qmlscene#&quot;&gt;QML 장면&lt;/a&gt; 또는 QML C ++ 애플리케이션을 실행하기 전에 &lt;code&gt;QML_IMPORT_TRACE=1&lt;/code&gt; 을 설정하면 다음 과 유사한 출력이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="1bef83b959da9c78ca1c919563bd96a50bdf2db6" translate="yes" xml:space="preserve">
          <source>If you set a cursorDelegate for a &lt;a href=&quot;qml-qtquick-textedit&quot;&gt;TextEdit&lt;/a&gt;, this delegate will be used for drawing the cursor instead of the standard cursor. An instance of the delegate will be created and managed by the text edit when a cursor is needed, and the x and y properties of delegate instance will be set so as to be one pixel before the top left of the current character.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-textedit&quot;&gt;TextEdit에&lt;/a&gt; 대해 cursorDelegate를 설정하면 이 대리자가 표준 커서 대신 커서를 그리는 데 사용됩니다. 커서가 필요할 때 텍스트 편집으로 델리게이트 인스턴스가 생성 및 관리되며 델리게이트 인스턴스의 x 및 y 속성은 현재 문자의 왼쪽 상단보다 한 픽셀이되도록 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="bbd4f27ee17216328f29625eaca8cfb2ff7dc6c3" translate="yes" xml:space="preserve">
          <source>If you set a cursorDelegate for a &lt;a href=&quot;qml-qtquick-textinput&quot;&gt;TextInput&lt;/a&gt;, this delegate will be used for drawing the cursor instead of the standard cursor. An instance of the delegate will be created and managed by the &lt;a href=&quot;qml-qtquick-textinput&quot;&gt;TextInput&lt;/a&gt; when a cursor is needed, and the x property of the delegate instance will be set so as to be one pixel before the top left of the current character.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-textinput&quot;&gt;TextInput에&lt;/a&gt; 대해 cursorDelegate를 설정하면 이 대리자가 표준 커서 대신 커서를 그리는 데 사용됩니다. 커서가 필요할 때 &lt;a href=&quot;qml-qtquick-textinput&quot;&gt;TextInput에&lt;/a&gt; 의해 대리자의 인스턴스가 생성 및 관리되며, 대리자 인스턴스의 x 속성은 현재 문자의 왼쪽 상단보다 한 픽셀이되도록 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="047958af1c10584793fadf46dfff954803186cf9" translate="yes" xml:space="preserve">
          <source>If you set a drop action that is not one of the possible actions, the drag and drop operation will default to a copy operation.</source>
          <target state="translated">가능한 동작 중 하나가 아닌 드롭 동작을 설정하면 드래그 앤 드롭 작업은 기본적으로 복사 작업이됩니다.</target>
        </trans-unit>
        <trans-unit id="a5a96eb99713196f9a09efc6f3f1749958e02b44" translate="yes" xml:space="preserve">
          <source>If you set a font that isn't available, Qt finds a close match. &lt;a href=&quot;qpainter#font&quot;&gt;font&lt;/a&gt;() will return what you set using setFont() and &lt;a href=&quot;qpainter#fontInfo&quot;&gt;fontInfo&lt;/a&gt;() returns the font actually being used (which may be the same).</source>
          <target state="translated">사용할 수없는 글꼴을 설정하면 Qt가 밀접하게 일치하는 것을 찾습니다. &lt;a href=&quot;qpainter#font&quot;&gt;font&lt;/a&gt; ()는 setFont ()를 사용하여 설정 한 내용을 반환하고 &lt;a href=&quot;qpainter#fontInfo&quot;&gt;fontInfo&lt;/a&gt; ()는 실제로 사용중인 글꼴을 반환합니다 (동일 할 수도 있음).</target>
        </trans-unit>
        <trans-unit id="004043069d8a07628c90c4b4958ae006433f2857" translate="yes" xml:space="preserve">
          <source>If you set a list of point types as values, the x-coordinate of the point specifies its zero-based index in the bar set. The size of the bar set is the highest x-coordinate value + 1. If a point is missing for any x-coordinate between zero and the highest value, it gets the value zero.</source>
          <target state="translated">포인트 유형 목록을 값으로 설정하면 포인트의 x 좌표가 막대 세트에서 0부터 시작하는 인덱스를 지정합니다. 막대 세트의 크기는 가장 높은 x 좌표 값 + 1입니다. 0과 가장 높은 값 사이의 x 좌표에 대해 점이 누락되면 값이 0이됩니다.</target>
        </trans-unit>
        <trans-unit id="fdc9233830c1d652cc4418de75ef220f3d6bf0d6" translate="yes" xml:space="preserve">
          <source>If you set a list of real types as values, they directly define the bar set values.</source>
          <target state="translated">실제 유형 목록을 값으로 설정하면 막대 세트 값을 직접 정의합니다.</target>
        </trans-unit>
        <trans-unit id="d026b32ff4e11356bacbf6f7cec5aac64d62b2ec" translate="yes" xml:space="preserve">
          <source>If you set a proxy factory with this function, any application level proxies set with &lt;a href=&quot;qnetworkproxy#setApplicationProxy&quot;&gt;QNetworkProxy::setApplicationProxy&lt;/a&gt; will be overridden, and &lt;a href=&quot;qnetworkproxyfactory#usesSystemConfiguration&quot;&gt;usesSystemConfiguration&lt;/a&gt;() will return &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">이 함수를 사용하여 프록시 팩토리를 설정하면 &lt;a href=&quot;qnetworkproxy#setApplicationProxy&quot;&gt;QNetworkProxy :: setApplicationProxy로&lt;/a&gt; 설정된 모든 애플리케이션 레벨 프록시 가 재정의되고 &lt;a href=&quot;qnetworkproxyfactory#usesSystemConfiguration&quot;&gt;usesSystemConfiguration&lt;/a&gt; ()이 &lt;code&gt;false&lt;/code&gt; 를 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="b13a093dc2ce286f0c9ccccb7cc994fb7903b344" translate="yes" xml:space="preserve">
          <source>If you set a text width on the &lt;a href=&quot;qstatictext&quot;&gt;QStaticText&lt;/a&gt; object, this will bound the text. The text will be formatted so that no line exceeds the given width. The text width set for &lt;a href=&quot;qstatictext&quot;&gt;QStaticText&lt;/a&gt; will not automatically be used for clipping. To achieve clipping in addition to line breaks, use &lt;a href=&quot;qpainter#setClipRect&quot;&gt;QPainter::setClipRect&lt;/a&gt;(). The position of the text is decided by the argument passed to &lt;a href=&quot;qpainter#drawStaticText&quot;&gt;QPainter::drawStaticText&lt;/a&gt;() and can change from call to call with a minimal impact on performance.</source>
          <target state="translated">&lt;a href=&quot;qstatictext&quot;&gt;QStaticText&lt;/a&gt; 객체 에 텍스트 너비를 설정하면 텍스트 가 바인딩됩니다. 주어진 너비를 초과하는 줄이 없도록 텍스트가 형식화됩니다. &lt;a href=&quot;qstatictext&quot;&gt;QStaticText에&lt;/a&gt; 설정된 텍스트 너비 는 클리핑에 자동으로 사용되지 않습니다. 줄 바꿈 외에도 클리핑을 달성하려면 &lt;a href=&quot;qpainter#setClipRect&quot;&gt;QPainter :: setClipRect&lt;/a&gt; ()를 사용하십시오. 텍스트의 위치는 &lt;a href=&quot;qpainter#drawStaticText&quot;&gt;QPainter :: drawStaticText&lt;/a&gt; ()에 전달 된 인수에 의해 결정되며 성능에 미치는 영향을 최소화하면서 호출마다 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f5118897b753fa9be9a7cd2e59ff122df27064a9" translate="yes" xml:space="preserve">
          <source>If you set handleWidth to 1 or 0, the actual grab area will grow to overlap a few pixels of its respective widgets.</source>
          <target state="translated">handleWidth를 1 또는 0으로 설정하면 실제 잡기 영역이 해당 위젯의 몇 픽셀과 겹치도록 커집니다.</target>
        </trans-unit>
        <trans-unit id="d0ec48d57a2e4338f862d2ee757f449cd9f198c0" translate="yes" xml:space="preserve">
          <source>If you set the rectangle to a null rectangle (for example, &lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt;(0, 0, 0, 0)), then the resulting frame rectangle is equivalent to the &lt;a href=&quot;qwidget#rect-prop&quot;&gt;widget rectangle&lt;/a&gt;.</source>
          <target state="translated">사각형을 널 사각형으로 설정하면 (예 : &lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt; (0, 0, 0, 0)) 결과 프레임 사각형은 &lt;a href=&quot;qwidget#rect-prop&quot;&gt;위젯 사각형&lt;/a&gt; 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="431602cc3b53aaddb31c020ccf0ff4c5479bf5ad" translate="yes" xml:space="preserve">
          <source>If you set this property to &lt;code&gt;false&lt;/code&gt;, ensure the application provides a way to remove the file once it is no longer needed, including passing the responsibility on to another process. Always use the &lt;a href=&quot;qtemporaryfile#fileName&quot;&gt;fileName&lt;/a&gt;() function to obtain the name and never try to guess the name that &lt;a href=&quot;qtemporaryfile&quot;&gt;QTemporaryFile&lt;/a&gt; has generated.</source>
          <target state="translated">이 특성을 &lt;code&gt;false&lt;/code&gt; 로 설정 하면 애플리케이션이 파일을 더 이상 필요하지 않은 경우 다른 프로세스로 책임을 전달하는 등 파일을 제거 할 수있는 방법을 제공해야합니다. 항상 &lt;a href=&quot;qtemporaryfile#fileName&quot;&gt;fileName&lt;/a&gt; () 함수를 사용하여 이름을 얻고 &lt;a href=&quot;qtemporaryfile&quot;&gt;QTemporaryFile&lt;/a&gt; 이 생성 한 이름을 추측하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="643778f0fba3e1dca37f5ecfec036f6d4506a847" translate="yes" xml:space="preserve">
          <source>If you simply want to check whether a &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; contains a particular character or substring, use &lt;a href=&quot;qbytearray#contains&quot;&gt;contains&lt;/a&gt;(). If you want to find out how many times a particular character or substring occurs in the byte array, use &lt;a href=&quot;qbytearray#count-3&quot;&gt;count&lt;/a&gt;(). If you want to replace all occurrences of a particular value with another, use one of the two-parameter &lt;a href=&quot;qbytearray#replace&quot;&gt;replace&lt;/a&gt;() overloads.</source>
          <target state="translated">&lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; 에 특정 문자 또는 하위 문자열이 포함되어 있는지 확인 하려면 &lt;a href=&quot;qbytearray#contains&quot;&gt;contains&lt;/a&gt; ()를 사용하십시오. 바이트 배열에서 특정 문자 또는 하위 문자열이 몇 번이나 발생하는지 확인하려면 &lt;a href=&quot;qbytearray#count-3&quot;&gt;count&lt;/a&gt; ()를 사용하십시오. 특정 값의 모든 항목을 다른 값으로 &lt;a href=&quot;qbytearray#replace&quot;&gt;바꾸&lt;/a&gt; 려면 두 매개 변수 replace () 오버로드 중 하나를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="24518665c949173b5a4db723c29cc8031141b05a" translate="yes" xml:space="preserve">
          <source>If you simply want to check whether a list contains a particular value, use &lt;a href=&quot;qlist#contains&quot;&gt;contains&lt;/a&gt;(). If you want to find out how many times a particular value occurs in the list, use &lt;a href=&quot;qlist#count-1&quot;&gt;count&lt;/a&gt;(). If you want to replace all occurrences of a particular value with another, use &lt;a href=&quot;qlist#replace&quot;&gt;replace&lt;/a&gt;().</source>
          <target state="translated">목록에 특정 값이 포함되어 있는지 확인하려면 &lt;a href=&quot;qlist#contains&quot;&gt;contains&lt;/a&gt; ()를 사용하십시오. 목록에서 특정 값이 몇 번이나 발생하는지 확인하려면 &lt;a href=&quot;qlist#count-1&quot;&gt;count&lt;/a&gt; ()를 사용하십시오. 특정 값의 모든 항목을 다른 값으로 &lt;a href=&quot;qlist#replace&quot;&gt;바꾸&lt;/a&gt; 려면 replace ()를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="ad6e5b02153501b6bb6236aff4d1862201610206" translate="yes" xml:space="preserve">
          <source>If you simply want to check whether a vector contains a particular value, use &lt;a href=&quot;qvector#contains&quot;&gt;contains&lt;/a&gt;(). If you want to find out how many times a particular value occurs in the vector, use &lt;a href=&quot;qvector#count-1&quot;&gt;count&lt;/a&gt;().</source>
          <target state="translated">벡터에 특정 값이 포함되어 있는지 간단히 확인하려면 &lt;a href=&quot;qvector#contains&quot;&gt;contains&lt;/a&gt; ()를 사용하십시오. 벡터에서 특정 값이 몇 번 나타나는지 알아 보려면 &lt;a href=&quot;qvector#count-1&quot;&gt;count&lt;/a&gt; ()를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="2e296f249be4339e6509618575b567b889bbaad2" translate="yes" xml:space="preserve">
          <source>If you specify a deployment target value lower than what Qt requires, the application will almost certainly crash somewhere in the Qt libraries when run on an older version than Qt supports. Therefore, make sure that the actual build system code reflects the minimum OS version that is actually required.</source>
          <target state="translated">Qt에 필요한 것보다 낮은 배포 대상 값을 지정하면 Qt가 지원하는 것보다 이전 버전에서 실행될 때 응용 프로그램이 Qt 라이브러리의 어딘가에서 거의 중단됩니다. 따라서 실제 빌드 시스템 코드가 실제로 필요한 최소 OS 버전을 반영하는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="7bcb3f27d98dc21bbbbdb2fca0feff41e2a96fee" translate="yes" xml:space="preserve">
          <source>If you specify a non-empty rect the tip will be hidden as soon as you move your cursor out of this area.</source>
          <target state="translated">비어 있지 않은 rect를 지정하면 커서를이 영역 밖으로 이동하면 팁이 숨겨집니다.</target>
        </trans-unit>
        <trans-unit id="5c568e1672c79d12d4f2fa5377fd0caa16da352f" translate="yes" xml:space="preserve">
          <source>If you specify a size of 0, the widget will be invisible. The size policies of the widgets are preserved. That is, a value smaller than the minimal size hint of the respective widget will be replaced by the value of the hint.</source>
          <target state="translated">크기를 0으로 지정하면 위젯이 보이지 않습니다. 위젯의 크기 정책이 유지됩니다. 즉, 각 위젯의 최소 크기 힌트보다 작은 값은 힌트 값으로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="c3fd839eb46fe8c9d85d7a5a8a27da4e517f92a1" translate="yes" xml:space="preserve">
          <source>If you specify an invalid format the format will not be set.</source>
          <target state="translated">유효하지 않은 형식을 지정하면 형식이 설정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fbc28d16ade9336d7264eba8457e21db3442a949" translate="yes" xml:space="preserve">
          <source>If you specify both DirsFirst and Reversed, directories are still put first, but in reverse order; the files will be listed after the directories, again in reverse order.</source>
          <target state="translated">DirsFirst와 Reversed를 모두 지정하면 디렉토리는 여전히 맨 앞에 있지만 역순으로 배치됩니다. 디렉토리 뒤에 파일이 다시 역순으로 나열됩니다.</target>
        </trans-unit>
        <trans-unit id="231c42a287b5db792543b45ee495ed920b2f5439" translate="yes" xml:space="preserve">
          <source>If you store types that &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; can't convert to &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; (e.g., &lt;a href=&quot;qpoint&quot;&gt;QPoint&lt;/a&gt;, &lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt;, and &lt;a href=&quot;qsize&quot;&gt;QSize&lt;/a&gt;), Qt uses an &lt;code&gt;@&lt;/code&gt;-based syntax to encode the type. For example:</source>
          <target state="translated">&lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; 가 &lt;a href=&quot;qstring&quot;&gt;QString으로&lt;/a&gt; 변환 할 수없는 유형 (예 : &lt;a href=&quot;qpoint&quot;&gt;QPoint&lt;/a&gt; , &lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt; 및 &lt;a href=&quot;qsize&quot;&gt;QSize&lt;/a&gt; )을 저장하면 Qt는 &lt;code&gt;@&lt;/code&gt; 기반 구문을 사용하여 유형을 인코딩합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c87ff348d61b82364184c96386b64b0cf54c3a7d" translate="yes" xml:space="preserve">
          <source>If you subclass &lt;a href=&quot;qabstractspinbox&quot;&gt;QAbstractSpinBox&lt;/a&gt; you will need to reimplement this function.</source>
          <target state="translated">&lt;a href=&quot;qabstractspinbox&quot;&gt;QAbstractSpinBox&lt;/a&gt; 를 서브 클래 싱하는 경우이 함수를 다시 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="ae78e35466488b5b971a806f36b2c10e455e5af7" translate="yes" xml:space="preserve">
          <source>If you subclass &lt;a href=&quot;qstandarditem&quot;&gt;QStandardItem&lt;/a&gt; and reimplement this function, your reimplementation should call &lt;a href=&quot;qstandarditem#emitDataChanged&quot;&gt;emitDataChanged&lt;/a&gt;() if you do not call the base implementation of setData(). This will ensure that e.g. views using the model are notified of the changes.</source>
          <target state="translated">당신이 서브 클래스 경우 &lt;a href=&quot;qstandarditem&quot;&gt;QStandardItem&lt;/a&gt; 이 기능을 다시 구현하고, 사용자의 재 구현을 호출해야합니다 &lt;a href=&quot;qstandarditem#emitDataChanged&quot;&gt;emitDataChanged을&lt;/a&gt; 당신 사항 setData의 기본 구현을 호출하지 않으면 () (). 이를 통해 예를 들어 모델을 사용하는 뷰에 변경 사항을 알릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc0b440d0989d912bb6682da839ae855b265651a" translate="yes" xml:space="preserve">
          <source>If you subclass &lt;code&gt;QAbstractSpinBox&lt;/code&gt; you must reimplement this function. Note that this function is called even if the resulting value will be outside the bounds of minimum and maximum. It's this function's job to handle these situations.</source>
          <target state="translated">&lt;code&gt;QAbstractSpinBox&lt;/code&gt; 를 서브 클래 싱하는 경우이 함수를 다시 구현해야합니다. 결과 값이 최소 및 최대 범위를 벗어나더라도이 함수가 호출됩니다. 이러한 상황을 처리하는 것이이 기능의 일입니다.</target>
        </trans-unit>
        <trans-unit id="9353c85818adf16a4bc1a52e583895bd302ea2de" translate="yes" xml:space="preserve">
          <source>If you subclass from &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt;, you need to provide a paintEvent for your custom &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; as below:</source>
          <target state="translated">&lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; 에서 서브 클래 싱하는 경우 다음 과 같이 사용자 정의 &lt;a href=&quot;qwidget&quot;&gt;QWidget에&lt;/a&gt; paintEvent를 제공해야 합니다.</target>
        </trans-unit>
        <trans-unit id="ece176f56b7b3a3ec40536468261faa29b795910" translate="yes" xml:space="preserve">
          <source>If you support drag and drop in your application, and want to start a drag and drop operation after the user has held down a mouse button for a certain amount of time, you should use this property's value as the delay.</source>
          <target state="translated">응용 프로그램에서 끌어서 놓기를 지원하고 사용자가 일정 시간 동안 마우스 단추를 누른 후 끌어서 놓기 작업을 시작하려면이 속성 값을 지연으로 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="8f148dd579171b7166c03213ee0d96a67bc0cade" translate="yes" xml:space="preserve">
          <source>If you support drag and drop in your application, and want to start a drag and drop operation after the user has moved the cursor a certain distance with a button held down, you should use this property's value as the minimum distance required.</source>
          <target state="translated">응용 프로그램에서 끌어서 놓기를 지원하고 사용자가 단추를 누른 상태에서 커서를 특정 거리로 이동 한 후 끌어서 놓기 작업을 시작하려면이 속성 값을 필요한 최소 거리로 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="8085f25bc7d3665287233d8b17e5b0d757de1c83" translate="yes" xml:space="preserve">
          <source>If you then set the goal state to the</source>
          <target state="translated">그런 다음 목표 상태를</target>
        </trans-unit>
        <trans-unit id="a1ca8967666264a51f7b4a705a3ff46be5298235" translate="yes" xml:space="preserve">
          <source>If you throw an exception that is not a subclass of &lt;a href=&quot;qexception&quot;&gt;QException&lt;/a&gt;, the Qt functions will throw a &lt;a href=&quot;qunhandledexception&quot;&gt;QUnhandledException&lt;/a&gt; in the receiver thread.</source>
          <target state="translated">&lt;a href=&quot;qexception&quot;&gt;QException&lt;/a&gt; 의 서브 클래스가 아닌 예외를 발생 시키면 Qt 함수는 수신자 스레드에서 &lt;a href=&quot;qunhandledexception&quot;&gt;QUnhandledException&lt;/a&gt; 을 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="027dcf6fa70f50b1e0fcca67f8e009d8475a3f1a" translate="yes" xml:space="preserve">
          <source>If you try to clear the error stack, make sure not just keep going until GL_NO_ERROR is returned but also break on GL_CONTEXT_LOST as that error value will keep repeating.</source>
          <target state="translated">오류 스택을 지우려고하면 GL_NO_ERROR가 반환 될 때까지 계속 진행해야 할뿐만 아니라 오류 값이 계속 반복되므로 GL_CONTEXT_LOST를 중단해야합니다.</target>
        </trans-unit>
        <trans-unit id="66d8fb540e390350ceab15ad11cb2d14cbfa76b0" translate="yes" xml:space="preserve">
          <source>If you try to pass a value from another enum or just a plain integer other than 0, the compiler will report an error. If you need to cast integer values to flags in a untyped fashion, you can use the explicit &lt;a href=&quot;qflags&quot;&gt;QFlags&lt;/a&gt; constructor as cast operator.</source>
          <target state="translated">다른 열거 형 또는 0 이외의 일반 정수에서 값을 전달하려고하면 컴파일러에서 오류를보고합니다. 유형이 지정되지 않은 방식으로 정수 값을 플래그 로 캐스트 &lt;a href=&quot;qflags&quot;&gt;해야하는&lt;/a&gt; 경우 명시적인 QFlags 생성자를 캐스트 연산자로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bb489276c3a79691beb36d8c22727f950ccbce1a" translate="yes" xml:space="preserve">
          <source>If you use &lt;a href=&quot;qabstractitemview#scrollDirtyRegion&quot;&gt;scrollDirtyRegion&lt;/a&gt;() and implement a &lt;a href=&quot;qabstractscrollarea#paintEvent&quot;&gt;paintEvent&lt;/a&gt;() in a subclass of &lt;a href=&quot;qabstractitemview&quot;&gt;QAbstractItemView&lt;/a&gt;, you should translate the area given by the paint event with the offset returned from this function.</source>
          <target state="translated">당신이 사용하는 경우 &lt;a href=&quot;qabstractitemview#scrollDirtyRegion&quot;&gt;scrollDirtyRegion을&lt;/a&gt; ()하고 구현 &lt;a href=&quot;qabstractscrollarea#paintEvent&quot;&gt;paintEvent을&lt;/a&gt; 의 서브 클래스에 () &lt;a href=&quot;qabstractitemview&quot;&gt;QAbstractItemView&lt;/a&gt; , 당신은이 함수에서 반환 오프셋과 페인트 이벤트에 의해 주어진 영역을 번역해야한다.</target>
        </trans-unit>
        <trans-unit id="e6aba7ba4a932684c2acb8eec62838cbcb85b7d7" translate="yes" xml:space="preserve">
          <source>If you use &lt;a href=&quot;qmake-manual&quot;&gt;qmake&lt;/a&gt; to build your projects, Qt GUI is included by default. To disable Qt GUI, add the following line to your &lt;code&gt;.pro&lt;/code&gt; file:</source>
          <target state="translated">&lt;a href=&quot;qmake-manual&quot;&gt;qmake&lt;/a&gt; 를 사용하여 프로젝트를 빌드 하면 기본적으로 Qt GUI가 포함됩니다. Qt GUI를 비활성화하려면 &lt;code&gt;.pro&lt;/code&gt; 파일에 다음 줄을 추가 하십시오.</target>
        </trans-unit>
        <trans-unit id="38adad0e80433ce5374cc3c78d3eeea7fbd65411" translate="yes" xml:space="preserve">
          <source>If you use &lt;a href=&quot;qmake-manual&quot;&gt;qmake&lt;/a&gt; to build your projects, Qt5Core is linked by default.</source>
          <target state="translated">당신이 사용하는 경우 &lt;a href=&quot;qmake-manual&quot;&gt;qmake를이&lt;/a&gt; 프로젝트를 구축, Qt5Core은 기본적으로 연결되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="5075d8a58cbccf2b19a18fc8f3d40ecfa88c3b3e" translate="yes" xml:space="preserve">
          <source>If you use &lt;a href=&quot;qmake-manual&quot;&gt;qmake&lt;/a&gt; to create your makefiles, build rules will be included that call the moc when required, so you will not need to use the moc directly. For more background information on &lt;code&gt;moc&lt;/code&gt;, see &lt;a href=&quot;why-moc#&quot;&gt;Why Does Qt Use Moc for Signals and Slots?&lt;/a&gt;</source>
          <target state="translated">당신이 사용하는 경우 &lt;a href=&quot;qmake-manual&quot;&gt;qmake를을&lt;/a&gt; 당신의 메이크 파일을 생성, 빌드 규칙은 직접 MOC를 사용할 필요가 없습니다 있도록 호출 MOC 것은, 필요한 경우 것이 포함됩니다. &lt;code&gt;moc&lt;/code&gt; 에 대한 자세한 배경 정보 &lt;a href=&quot;why-moc#&quot;&gt;는 신호 및 슬롯에 Qt가 Moc를 사용하는 이유를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b813a975620cedd1d63c1f6520825459dbde2ad0" translate="yes" xml:space="preserve">
          <source>If you use &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; from many places in your application, you might want to specify the organization name and the application name using &lt;a href=&quot;qcoreapplication#organizationName-prop&quot;&gt;QCoreApplication::setOrganizationName&lt;/a&gt;() and &lt;a href=&quot;qcoreapplication#applicationName-prop&quot;&gt;QCoreApplication::setApplicationName&lt;/a&gt;(), and then use the default &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; constructor:</source>
          <target state="translated">애플리케이션의 여러 위치에서 &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; 를 사용하는 경우 &lt;a href=&quot;qcoreapplication#organizationName-prop&quot;&gt;QCoreApplication :: setOrganizationName&lt;/a&gt; () 및 &lt;a href=&quot;qcoreapplication#applicationName-prop&quot;&gt;QCoreApplication :: setApplicationName&lt;/a&gt; () 을 사용하여 조직 이름 및 애플리케이션 이름을 지정한 후 기본 &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; 생성자 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="add980e843a7ddc5f181f430dafc7f2dc6cb6c8e" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;qmake&lt;/code&gt; and Makefiles, use the &lt;code&gt;QMAKE_LFLAGS_SONAME&lt;/code&gt; setting:</source>
          <target state="translated">당신이 사용하는 경우 &lt;code&gt;qmake&lt;/code&gt; 를 하고 메이크 파일을 사용 &lt;code&gt;QMAKE_LFLAGS_SONAME&lt;/code&gt; 의 설정을 :</target>
        </trans-unit>
        <trans-unit id="5ca554fbe42cc1b563f4e294b48a29dc639174dd" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;qmake&lt;/code&gt;, &lt;code&gt;uic&lt;/code&gt; will be invoked automatically for header files.</source>
          <target state="translated">당신이 사용하는 경우 &lt;code&gt;qmake&lt;/code&gt; 를을 , &lt;code&gt;uic&lt;/code&gt; 헤더 파일을 자동으로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="8046036d7c642b36de61fa7d4f65213dd3c58f67" translate="yes" xml:space="preserve">
          <source>If you use a brush with a &lt;a href=&quot;qgradient&quot;&gt;QGradient&lt;/a&gt;, the gradient is relative to the item's coordinate system.</source>
          <target state="translated">&lt;a href=&quot;qgradient&quot;&gt;QGradient&lt;/a&gt; 와 함께 브러시를 사용하는 경우 그라디언트는 항목의 좌표계를 기준으로합니다.</target>
        </trans-unit>
        <trans-unit id="c0c7225d70c96d951d167a22fe91ba16e501ed52" translate="yes" xml:space="preserve">
          <source>If you use a read-write &lt;a href=&quot;qsqlrelationaltablemodel&quot;&gt;QSqlRelationalTableModel&lt;/a&gt;, you probably want to use &lt;a href=&quot;qsqlrelationaldelegate&quot;&gt;QSqlRelationalDelegate&lt;/a&gt; on the view. Unlike the default delegate, &lt;a href=&quot;qsqlrelationaldelegate&quot;&gt;QSqlRelationalDelegate&lt;/a&gt; provides a combobox for fields that are foreign keys into other tables. To use the class, simply call &lt;a href=&quot;qabstractitemview#setItemDelegate&quot;&gt;QAbstractItemView::setItemDelegate&lt;/a&gt;() on the view with an instance of &lt;a href=&quot;qsqlrelationaldelegate&quot;&gt;QSqlRelationalDelegate&lt;/a&gt;:</source>
          <target state="translated">읽기 / 쓰기 &lt;a href=&quot;qsqlrelationaltablemodel&quot;&gt;QSqlRelationalTableModel&lt;/a&gt; 을 사용 하는 경우보기에서 &lt;a href=&quot;qsqlrelationaldelegate&quot;&gt;QSqlRelationalDelegate&lt;/a&gt; 를 사용 하려고 합니다. 기본 대리자와 달리 &lt;a href=&quot;qsqlrelationaldelegate&quot;&gt;QSqlRelationalDelegate&lt;/a&gt; 는 다른 테이블의 외래 키인 필드에 콤보 박스를 제공합니다. 클래스를 사용하려면 &lt;a href=&quot;qabstractitemview#setItemDelegate&quot;&gt;QSqlRelationalDelegate&lt;/a&gt; 인스턴스가있는보기에서 QAbstractItemView :: setItemDelegate ()를 호출 &lt;a href=&quot;qsqlrelationaldelegate&quot;&gt;하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c025e0f62d5d506b03891dcc3eaa3313b1ceb63f" translate="yes" xml:space="preserve">
          <source>If you use another build system, you can pass the following defines to the compiler:</source>
          <target state="translated">다른 빌드 시스템을 사용하는 경우 다음 정의를 컴파일러에 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="90bf696ac5affef197c98e800663b6802cd8d7c8" translate="yes" xml:space="preserve">
          <source>If you use the &lt;a href=&quot;qwidget#windowModified-prop&quot;&gt;windowModified&lt;/a&gt; mechanism, the window title must contain a &quot;[*]&quot; placeholder, which indicates where the '*' should appear. Normally, it should appear right after the file name (e.g., &quot;document1.txt[*] - Text Editor&quot;). If the &lt;a href=&quot;qwidget#windowModified-prop&quot;&gt;windowModified&lt;/a&gt; property is &lt;code&gt;false&lt;/code&gt; (the default), the placeholder is simply removed.</source>
          <target state="translated">&lt;a href=&quot;qwidget#windowModified-prop&quot;&gt;windowModified&lt;/a&gt; 메커니즘 을 사용하는 경우 창 제목에는 &quot;*&quot;가 나타나는 위치를 나타내는 &quot;[*]&quot;자리 표시자가 포함되어야합니다. 일반적으로 파일 이름 바로 뒤에 나타납니다 (예 : &quot;document1.txt [*]-텍스트 편집기&quot;). 는 IF &lt;a href=&quot;qwidget#windowModified-prop&quot;&gt;windowModified&lt;/a&gt; 특성이 &lt;code&gt;false&lt;/code&gt; (기본), 플레이스 홀더는 간단하게 제거된다.</target>
        </trans-unit>
        <trans-unit id="c104e6782e776da7461bb5c1aab379d1fa1f4f8b" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;Q_CLASSINFO()&lt;/code&gt; macro to provide the unique identifiers or other attributes for your class you can use the &lt;code&gt;QAXFACTORY_BEGIN()&lt;/code&gt;, &lt;code&gt;QAXCLASS()&lt;/code&gt; and &lt;code&gt;QAXFACTORY_END()&lt;/code&gt; macros to expose one or more classes as COM objects.</source>
          <target state="translated">당신이 사용하는 경우 &lt;code&gt;Q_CLASSINFO()&lt;/code&gt; 클래스의 고유 한 식별자 또는 다른 속성을 제공하기 위해 매크로를 당신은 사용할 수 있습니다 &lt;code&gt;QAXFACTORY_BEGIN()&lt;/code&gt; , &lt;code&gt;QAXCLASS()&lt;/code&gt; 및 &lt;code&gt;QAXFACTORY_END()&lt;/code&gt; COM 개체를 하나 개 이상의 클래스를 노출 매크로를.</target>
        </trans-unit>
        <trans-unit id="164b8c02eec01fef31a24f7930bbb2f55c2f7660" translate="yes" xml:space="preserve">
          <source>If you use the glBindFramebuffer() in &lt;a href=&quot;https://doc.qt.io/qt-5.13/qopenglfunctions.html&quot;&gt;QOpenGLFunctions&lt;/a&gt; you do not have to worry about this, as it automatically binds the current context's defaultFramebufferObject() when 0 is passed.</source>
          <target state="translated">당신의 glBindFramebuffer ()를 사용하는 경우 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qopenglfunctions.html&quot;&gt;QOpenGLFunctions&lt;/a&gt; 자동으로 현재 컨텍스트의 defaultFramebufferObject을 결합 당신이 이것에 대해 걱정할 필요가 없습니다 () 0이 전달 될 때.</target>
        </trans-unit>
        <trans-unit id="465dd22453cd823b86d8a7cec428c5c9a97d2db7" translate="yes" xml:space="preserve">
          <source>If you want a blocking lookup, use the &lt;a href=&quot;qhostinfo#fromName&quot;&gt;QHostInfo::fromName&lt;/a&gt;() function:</source>
          <target state="translated">차단 조회를 원하면 &lt;a href=&quot;qhostinfo#fromName&quot;&gt;QHostInfo :: fromName&lt;/a&gt; () 함수를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="78ed224dea9cfd5f1b0963e7c161808ef5c73770" translate="yes" xml:space="preserve">
          <source>If you want a specific button to be default you need to call &lt;a href=&quot;qpushbutton#default-prop&quot;&gt;QPushButton::setDefault&lt;/a&gt;() on it yourself. However, if there is no default button set and to preserve which button is the default button across platforms when using the &lt;a href=&quot;qpushbutton#autoDefault-prop&quot;&gt;QPushButton::autoDefault&lt;/a&gt; property, the first push button with the accept role is made the default button when the &lt;a href=&quot;qdialogbuttonbox&quot;&gt;QDialogButtonBox&lt;/a&gt; is shown,</source>
          <target state="translated">특정 버튼을 기본값으로 설정하려면 &lt;a href=&quot;qpushbutton#default-prop&quot;&gt;QPushButton :: setDefault&lt;/a&gt; ()를 직접 호출해야합니다 . 그러나 &lt;a href=&quot;qpushbutton#autoDefault-prop&quot;&gt;QPushButton :: autoDefault&lt;/a&gt; 속성을 사용할 때 기본 버튼이 설정되어 있지 않고 플랫폼에서 어떤 버튼이 기본 버튼인지 유지 하려면 &lt;a href=&quot;qdialogbuttonbox&quot;&gt;QDialogButtonBox&lt;/a&gt; 가 표시 될 때 accept 역할이있는 첫 번째 푸시 버튼이 기본 버튼이됩니다.</target>
        </trans-unit>
        <trans-unit id="d0ee116c48b7a25f03a5fdc1279c7c88d799aac8" translate="yes" xml:space="preserve">
          <source>If you want a table that uses your own data model you should use &lt;a href=&quot;qtableview&quot;&gt;QTableView&lt;/a&gt; rather than this class.</source>
          <target state="translated">자체 데이터 모델을 사용하는 테이블을 원하면 이 클래스 대신 &lt;a href=&quot;qtableview&quot;&gt;QTableView&lt;/a&gt; 를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="4066f30b49e877beb77fbbb1b03dbbd2aab03b4a" translate="yes" xml:space="preserve">
          <source>If you want all windows in a Mac application to share one menu bar, don't use this function to create it, because the menu bar created here will have this &lt;a href=&quot;qmainwindow&quot;&gt;QMainWindow&lt;/a&gt; as its parent. Instead, you must create a menu bar that does not have a parent, which you can then share among all the Mac windows. Create a parent-less menu bar this way:</source>
          <target state="translated">Mac 응용 프로그램의 모든 윈도우가 하나의 메뉴 막대를 공유하도록하려면 여기에 작성된 메뉴 막대에이 &lt;a href=&quot;qmainwindow&quot;&gt;QMainWindow&lt;/a&gt; 가 부모로 표시 되므로이 기능을 사용하여 메뉴 막대를 작성하지 마십시오 . 대신, 부모가없는 메뉴 막대를 작성하여 모든 Mac 창에서 공유 할 수 있습니다. 다음과 같이 부모없는 메뉴 표시 줄을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="31b95d83456383d9523b22a6f580deb4b0c226d2" translate="yes" xml:space="preserve">
          <source>If you want all windows in a Mac application to share one menu bar, you must create a menu bar that does not have a parent. Create a parent-less menu bar this way:</source>
          <target state="translated">Mac 응용 프로그램의 모든 윈도우가 하나의 메뉴 막대를 공유하도록하려면 부모가없는 메뉴 막대를 작성해야합니다. 다음과 같이 부모없는 메뉴 표시 줄을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="8ea9eff46c8438d5355c7754f5d314f0d0331659" translate="yes" xml:space="preserve">
          <source>If you want different graphics or audio for different geographical regions, you can use Qt.&lt;a href=&quot;technical-guide#locale&quot;&gt;locale&lt;/a&gt;() to get the current locale. Then you choose appropriate graphics or audio for that locale.</source>
          <target state="translated">지역별로 다른 그래픽 또는 오디오를 원한다면 Qt를 사용할 수 있습니다. &lt;a href=&quot;technical-guide#locale&quot;&gt;로케일&lt;/a&gt; ()은 현재 로케일을 가져옵니다. 그런 다음 해당 로캘에 적합한 그래픽 또는 오디오를 선택합니다.</target>
        </trans-unit>
        <trans-unit id="446f88c9cddd8c4474604644640db651614e76a6" translate="yes" xml:space="preserve">
          <source>If you want neither the default, nor the minimal QPA plugin to be linked automatically, use:</source>
          <target state="translated">기본값이나 최소 QPA 플러그인을 자동으로 연결하지 않으려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="0b89c527347aa3766219b2a3bded0796f0992a5d" translate="yes" xml:space="preserve">
          <source>If you want the items to occupy adjacent memory positions, use &lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt;.</source>
          <target state="translated">항목이 인접한 메모리 위치를 차지하게하려면 &lt;a href=&quot;qvector&quot;&gt;QVector를&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="9fdd7c36b6c3979f02bf13657853e90c75d56a84" translate="yes" xml:space="preserve">
          <source>If you want the plugin to be loadable then one approach is to create a subdirectory under the application, and place the plugin in that directory. If you distribute any of the plugins that come with Qt (the ones located in the &lt;code&gt;plugins&lt;/code&gt; directory), you must copy the subdirectory under &lt;code&gt;plugins&lt;/code&gt; where the plugin is located to your applications root folder (i.e., do not include the &lt;code&gt;plugins&lt;/code&gt; directory).</source>
          <target state="translated">플러그인을로드 할 수있게하려면 응용 프로그램 아래에 서브 디렉토리를 작성하고 해당 디렉토리에 플러그인을 배치하십시오. Qt와 함께 제공되는 &lt;code&gt;plugins&lt;/code&gt; 디렉토리 에있는 플러그인 ) 을 배포하는 경우 &lt;code&gt;plugins&lt;/code&gt; 이있는 플러그인 아래의 하위 디렉토리를 응용 프로그램 루트 폴더에 복사해야합니다 (즉, &lt;code&gt;plugins&lt;/code&gt; 디렉토리를 포함하지 않음 ).</target>
        </trans-unit>
        <trans-unit id="1547dbbe53958db51bfc0636fe2d9a75dcedc772" translate="yes" xml:space="preserve">
          <source>If you want the rest of the URL to be case insensitive, you will have to take care of that yourself inside your image provider.</source>
          <target state="translated">나머지 URL을 대소 문자를 구분하지 않으려면 이미지 공급자 내부에서 직접 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="b2ceee3ac5c8d581ed65d658427fc7dba2f3ab94" translate="yes" xml:space="preserve">
          <source>If you want the widget to be deleted when it is closed, create it with the &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt::WA_DeleteOnClose&lt;/a&gt; flag. This is very useful for independent top-level windows in a multi-window application.</source>
          <target state="translated">위젯을 닫을 때 위젯을 삭제하려면 &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt :: WA_DeleteOnClose&lt;/a&gt; 플래그를 사용하여 위젯을 작성하십시오 . 이것은 다중 창 응용 프로그램에서 독립적 인 최상위 창에 매우 유용합니다.</target>
        </trans-unit>
        <trans-unit id="f616738a391d1d34bf98d9064907be46ceb77ccb" translate="yes" xml:space="preserve">
          <source>If you want to abort the print job, &lt;a href=&quot;qprinter#abort&quot;&gt;abort&lt;/a&gt;() will try its best to stop printing. It may cancel the entire job or just part of it.</source>
          <target state="translated">인쇄 작업을 중단하려면 &lt;a href=&quot;qprinter#abort&quot;&gt;중단&lt;/a&gt; ()이 인쇄 중지를 위해 최선을 다합니다. 전체 작업을 취소하거나 일부만 취소 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="072f5ce0b0ae384f54c36e755b7c3114bd8b4caa" translate="yes" xml:space="preserve">
          <source>If you want to access the text of a node use &lt;a href=&quot;qdomelement#text&quot;&gt;text&lt;/a&gt;(), e.g.</source>
          <target state="translated">노드의 텍스트에 액세스하려면 &lt;a href=&quot;qdomelement#text&quot;&gt;텍스트&lt;/a&gt; ()를 사용 하십시오.</target>
        </trans-unit>
        <trans-unit id="af270e6549ee7a5853d9d59523cdb19eafa6e734" translate="yes" xml:space="preserve">
          <source>If you want to append a certain number of identical characters to the string, use the &lt;a href=&quot;qstring#resize-1&quot;&gt;resize&lt;/a&gt;(int, &lt;a href=&quot;qchar&quot;&gt;QChar&lt;/a&gt;) overload.</source>
          <target state="translated">문자열에 일정한 수의 동일한 문자를 추가하려면 &lt;a href=&quot;qstring#resize-1&quot;&gt;크기 조정&lt;/a&gt; (int, &lt;a href=&quot;qchar&quot;&gt;QChar&lt;/a&gt; ) 오버로드를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="74615ef5923d5f6bd1ef246221c633d243a15754" translate="yes" xml:space="preserve">
          <source>If you want to be notified when a state machine sends out an event, you can connect to the corresponding signal. For example, for a media player state machine which indicates that playback has stopped by sending an event, you can write:</source>
          <target state="translated">상태 머신이 이벤트를 보낼 때 알림을 받으려면 해당 신호에 연결할 수 있습니다. 예를 들어, 이벤트를 보내 재생이 중지되었음을 나타내는 미디어 플레이어 상태 시스템의 경우 다음과 같이 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="829cc87afe3eb42cae7ecff016f3497ad8d384a4" translate="yes" xml:space="preserve">
          <source>If you want to be sure not to lose any debug message, you must use real-time logging instead of calling this function. However, debug messages might still be generated in the timespan between context creation and activation of real-time logging (or, in general, when the real-time logging is disabled).</source>
          <target state="translated">디버그 메시지를 잃지 않으려면이 함수를 호출하는 대신 실시간 로깅을 사용해야합니다. 그러나 컨텍스트 메시지 작성과 실시간 로깅 활성화 사이 (또는 일반적으로 실시간 로깅이 비활성화 된 경우)의 기간에 디버그 메시지가 계속 생성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="edd46e63010e9398a3500347fb1d6ed771b6b5b7" translate="yes" xml:space="preserve">
          <source>If you want to build a new dynamic library combining the Qt 4 dynamic libraries, you need to introduce the &lt;code&gt;ld -r&lt;/code&gt; flag. Then relocation information is stored in the output file, so that this file could be the subject of another &lt;code&gt;ld&lt;/code&gt; run. This is done by setting the &lt;code&gt;-r&lt;/code&gt; flag in the &lt;code&gt;.pro&lt;/code&gt; file, and the &lt;code&gt;LFLAGS&lt;/code&gt; settings.</source>
          <target state="translated">Qt 4 동적 라이브러리를 결합한 새로운 동적 라이브러리를 빌드하려면 &lt;code&gt;ld -r&lt;/code&gt; 플래그 를 도입해야합니다 . 그런 다음 재배치 정보가 출력 파일에 저장되므로이 파일이 다른 &lt;code&gt;ld&lt;/code&gt; run 의 주제가 될 수 있습니다 . &lt;code&gt;-r&lt;/code&gt; 을 설정하면됩니다 에 플래그를 &lt;code&gt;.pro&lt;/code&gt; 파일 및이 &lt;code&gt;LFLAGS&lt;/code&gt; 설정을.</target>
        </trans-unit>
        <trans-unit id="843fe25910ba44929f16216b7ddc23cd36be1a71" translate="yes" xml:space="preserve">
          <source>If you want to build a project</source>
          <target state="translated">프로젝트를 빌드하려는 경우</target>
        </trans-unit>
        <trans-unit id="b52f7beae447ca8d6352804a7b7084b76da5b4fb" translate="yes" xml:space="preserve">
          <source>If you want to change the item's bounding rectangle, you must first call &lt;a href=&quot;qgraphicsitem#prepareGeometryChange&quot;&gt;prepareGeometryChange&lt;/a&gt;(). This notifies the scene of the imminent change, so that it can update its item geometry index; otherwise, the scene will be unaware of the item's new geometry, and the results are undefined (typically, rendering artifacts are left within the view).</source>
          <target state="translated">항목의 경계 사각형을 변경하려면 먼저 전화해야합니다 &lt;a href=&quot;qgraphicsitem#prepareGeometryChange&quot;&gt; PreparingGeometryChange&lt;/a&gt; ()를 . 이렇게하면 임박한 변경 장면을 알려주므로 항목 지오메트리 인덱스를 업데이트 할 수 있습니다. 그렇지 않으면 장면은 항목의 새로운 지오메트리를 인식하지 못하며 결과는 정의되지 않습니다 (일반적으로 렌더링 아티팩트는 뷰 내에 남아 있음).</target>
        </trans-unit>
        <trans-unit id="29b647f4eb645fd0ecb89a84fc729ec79f1f0b4a" translate="yes" xml:space="preserve">
          <source>If you want to check the peer's complete chain of certificates, use &lt;a href=&quot;qsslconfiguration#peerCertificateChain&quot;&gt;peerCertificateChain&lt;/a&gt;() to get them all at once.</source>
          <target state="translated">피어의 전체 인증서 체인을 확인하려면 다음을 사용하십시오. &lt;a href=&quot;qsslconfiguration#peerCertificateChain&quot;&gt; peerCertificateChain&lt;/a&gt; ()을 하여 한 번에 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="0a9b450069a96b0a6e8a58b97599d28425e77362" translate="yes" xml:space="preserve">
          <source>If you want to check the peer's complete chain of certificates, use &lt;a href=&quot;qsslsocket#peerCertificateChain&quot;&gt;peerCertificateChain&lt;/a&gt;() to get them all at once.</source>
          <target state="translated">피어의 전체 인증서 체인을 확인하려면 다음을 사용하십시오. &lt;a href=&quot;qsslsocket#peerCertificateChain&quot;&gt; peerCertificateChain&lt;/a&gt; ()을 하여 한 번에 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="c1930bdafa7c0b87829238cba843e2649235ef5e" translate="yes" xml:space="preserve">
          <source>If you want to check whether the hash contains a particular key, use &lt;a href=&quot;qhash#contains&quot;&gt;contains&lt;/a&gt;():</source>
          <target state="translated">해시에 특정 키가 포함되어 있는지 확인하려면 다음을 사용하십시오. &lt;a href=&quot;qhash#contains&quot;&gt; contains&lt;/a&gt; ()를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="23d935961b3f68a99328d654a216f4d3c0e893da" translate="yes" xml:space="preserve">
          <source>If you want to check whether the map contains a certain key, use &lt;a href=&quot;qmap#contains&quot;&gt;contains&lt;/a&gt;():</source>
          <target state="translated">지도에 특정 키가 포함되어 있는지 확인하려면 &lt;a href=&quot;qmap#contains&quot;&gt; contains&lt;/a&gt; ()를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="fdb3c94f4828e2e69eb0db0933e5d9bb481bdfda" translate="yes" xml:space="preserve">
          <source>If you want to compare</source>
          <target state="translated">비교하고 싶다면</target>
        </trans-unit>
        <trans-unit id="e82e2ac2e85f322df34660e42809cbc06868df5b" translate="yes" xml:space="preserve">
          <source>If you want to continue connecting despite the errors that have occurred, you must call &lt;a href=&quot;qdtls#ignoreVerificationErrors&quot;&gt;ignoreVerificationErrors&lt;/a&gt;().</source>
          <target state="translated">발생한 오류에도 불구하고 계속 연결하려면 &lt;a href=&quot;qdtls#ignoreVerificationErrors&quot;&gt;ignoreVerificationErrors&lt;/a&gt; 를 호출해야합니다. ()를 .</target>
        </trans-unit>
        <trans-unit id="593b23d3289a4ff04c05a350d8fd85bdefb223cc" translate="yes" xml:space="preserve">
          <source>If you want to continue connecting despite the errors that have occurred, you must call &lt;a href=&quot;qsslsocket#ignoreSslErrors&quot;&gt;QSslSocket::ignoreSslErrors&lt;/a&gt;() from inside a slot connected to this signal. If you need to access the error list at a later point, you can call &lt;a href=&quot;qsslsocket#sslErrors&quot;&gt;sslErrors&lt;/a&gt;() (without arguments).</source>
          <target state="translated">발생한 오류에도 불구하고 계속 연결 하려면이 신호에 연결된 슬롯 내부에서 &lt;a href=&quot;qsslsocket#ignoreSslErrors&quot;&gt;QSslSocket :: ignoreSslErrors&lt;/a&gt; ()를 호출해야합니다 . 나중에 오류 목록에 액세스해야하는 경우 인수없이 &lt;a href=&quot;qsslsocket#sslErrors&quot;&gt;sslErrors&lt;/a&gt; ()를 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7e824420bc3b83685fc893bd934a9bc6683d5906" translate="yes" xml:space="preserve">
          <source>If you want to control a tooltip's behavior, you can intercept the &lt;a href=&quot;qwidget#event&quot;&gt;event&lt;/a&gt;() function and catch the &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent::ToolTip&lt;/a&gt; event (e.g., if you want to customize the area for which the tooltip should be shown).</source>
          <target state="translated">툴팁의 동작을 제어하려면 &lt;a href=&quot;qwidget#event&quot;&gt;event&lt;/a&gt; () 함수를 가로 채고 &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent :: ToolTip&lt;/a&gt; 이벤트를 잡을 수 있습니다 (예 : 툴팁을 표시 할 영역을 사용자 정의하려는 경우).</target>
        </trans-unit>
        <trans-unit id="c2d5bf02509f579dcb98946a92761ca94da3aae3" translate="yes" xml:space="preserve">
          <source>If you want to control the &quot;What's This?&quot; behavior of a widget manually see &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt::WA_CustomWhatsThis&lt;/a&gt;.</source>
          <target state="translated">&quot;무엇입니까?&quot;를 제어하려면 위젯의 동작은 수동으로 &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt :: WA_CustomWhatsThis를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ed9d7672cfabd9a5697756d2b93c54e6a0ba7c97" translate="yes" xml:space="preserve">
          <source>If you want to create a &lt;a href=&quot;qsslsocket&quot;&gt;QSslSocket&lt;/a&gt; on the server side of a connection, you should instead call &lt;a href=&quot;qsslsocket#startServerEncryption&quot;&gt;startServerEncryption&lt;/a&gt;() upon receiving the incoming connection through &lt;a href=&quot;qtcpserver&quot;&gt;QTcpServer&lt;/a&gt;.</source>
          <target state="translated">당신이 만들려면 &lt;a href=&quot;qsslsocket&quot;&gt;QSslSocket을&lt;/a&gt; 연결의 서버 측에서 대신 호출해야 &lt;a href=&quot;qsslsocket#startServerEncryption&quot;&gt;startServerEncryption을&lt;/a&gt; 통해 들어오는 연결을 수신 할 때 () &lt;a href=&quot;qtcpserver&quot;&gt;QTcpServer를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6364a818a1ea0ef1877be04ba18d5b6f66a20bba" translate="yes" xml:space="preserve">
          <source>If you want to create a cursor with your own bitmap, either use the &lt;a href=&quot;qcursor&quot;&gt;QCursor&lt;/a&gt; constructor which takes a bitmap and a mask or the constructor which takes a pixmap as arguments.</source>
          <target state="translated">자신의 비트 맵으로 커서를 만들려면 비트 맵과 마스크 를 사용하는 &lt;a href=&quot;qcursor&quot;&gt;QCursor&lt;/a&gt; 생성자 또는 pixmap을 인수로 사용하는 생성자를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="130b75aa02ccf684bfd7c5f0b345cba58a662fc5" translate="yes" xml:space="preserve">
          <source>If you want to create a custom popup menu, reimplement this function and return a newly-created popup menu. Ownership of the popup menu is transferred to the caller.</source>
          <target state="translated">사용자 정의 팝업 메뉴를 만들려면이 기능을 다시 구현하고 새로 만든 팝업 메뉴를 반환하십시오. 팝업 메뉴의 소유권이 발신자에게 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="5ff7d1d9131c0f8103df914e4a7059bb6a8f90da" translate="yes" xml:space="preserve">
          <source>If you want to create your makefiles yourself, here are some tips on how to include moc handling.</source>
          <target state="translated">makefile을 직접 작성하려면 moc 처리를 포함시키는 방법에 대한 팁이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a707b4cc84c90bce7334604418a837b327eb07ee" translate="yes" xml:space="preserve">
          <source>If you want to create your own SQL drivers, you can subclass this class and reimplement its pure virtual functions and those virtual functions that you need. See &lt;a href=&quot;sql-driver#how-to-write-your-own-database-driver&quot;&gt;How to Write Your Own Database Driver&lt;/a&gt; for more information.</source>
          <target state="translated">고유 한 SQL 드라이버를 작성하려는 경우이 클래스를 서브 클래스 화하고 순수한 가상 기능 및 필요한 가상 기능을 다시 구현할 수 있습니다. &lt;a href=&quot;sql-driver#how-to-write-your-own-database-driver&quot;&gt;자신의 데이터베이스 드라이버 작성 방법을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4cd00e1cb4ef832c6d6c10ccd947e0dc976d42f2" translate="yes" xml:space="preserve">
          <source>If you want to create your own configurable transformation, you can create a subclass of &lt;a href=&quot;qgraphicstransform&quot;&gt;QGraphicsTransform&lt;/a&gt; (or any or the existing subclasses), and reimplement the pure virtual &lt;a href=&quot;qgraphicstransform#applyTo&quot;&gt;applyTo&lt;/a&gt;() function, which takes a pointer to a &lt;a href=&quot;qmatrix4x4&quot;&gt;QMatrix4x4&lt;/a&gt;. Each operation you would like to apply should be exposed as properties (e.g., customTransform-&amp;gt;setVerticalShear(2.5)). Inside you reimplementation of &lt;a href=&quot;qgraphicstransform#applyTo&quot;&gt;applyTo&lt;/a&gt;(), you can modify the provided transform respectively.</source>
          <target state="translated">자체 구성 가능한 변환을 작성하려는 경우 &lt;a href=&quot;qgraphicstransform&quot;&gt;QGraphicsTransform&lt;/a&gt; 의 서브 클래스 (또는 기존 서브 클래스)를 작성하고 순수 가상 &lt;a href=&quot;qgraphicstransform#applyTo&quot;&gt;applyTo&lt;/a&gt; () 함수를 다시 구현하여 QMatrix4x4에 대한 포인터를 가져 &lt;a href=&quot;qmatrix4x4&quot;&gt;옵니다&lt;/a&gt; . 적용하려는 각 작업은 속성으로 노출되어야합니다 (예 : customTransform-&amp;gt; setVerticalShear (2.5)). &lt;a href=&quot;qgraphicstransform#applyTo&quot;&gt;applyTo&lt;/a&gt; () 를 다시 구현 하면 제공된 변환을 각각 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="892e584524cab25e78f87f3d6a40b0ffd8130114" translate="yes" xml:space="preserve">
          <source>If you want to define code for specific versions of macOS, use the availability macros defined in</source>
          <target state="translated">특정 버전의 macOS에 대한 코드를 정의하려면에 정의 된 가용성 매크로를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="45df5b12dbd5aa838901a53b2069cb521cd37d58" translate="yes" xml:space="preserve">
          <source>If you want to define your own contentItem, use either a &lt;a href=&quot;qml-qtquick-listview&quot;&gt;ListView&lt;/a&gt; or &lt;a href=&quot;qml-qtquick-pathview&quot;&gt;PathView&lt;/a&gt; as the root item. For a wrapping Tumbler, use &lt;a href=&quot;qml-qtquick-pathview&quot;&gt;PathView&lt;/a&gt;:</source>
          <target state="translated">고유 한 contentItem을 정의 하려면 루트 항목으로 &lt;a href=&quot;qml-qtquick-listview&quot;&gt;ListView&lt;/a&gt; 또는 &lt;a href=&quot;qml-qtquick-pathview&quot;&gt;PathView&lt;/a&gt; 를 사용하십시오. 랩핑 텀블러의 경우 &lt;a href=&quot;qml-qtquick-pathview&quot;&gt;PathView를&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="3dd1a5bc4c7a4320ada8bf718a2be1299c978da2" translate="yes" xml:space="preserve">
          <source>If you want to display each label above its associated field (instead of next to it), set this property to &lt;a href=&quot;qformlayout#RowWrapPolicy-enum&quot;&gt;WrapAllRows&lt;/a&gt;.</source>
          <target state="translated">옆에있는 레이블 대신 연결된 필드 위에 각 레이블을 표시하려면이 속성을 &lt;a href=&quot;qformlayout#RowWrapPolicy-enum&quot;&gt;WrapAllRows로&lt;/a&gt; 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="98c56457474602455ea9e72ba790cac4f00decf0" translate="yes" xml:space="preserve">
          <source>If you want to display potentially long text in a limited space, you probably want to use &lt;code&gt;elide&lt;/code&gt; instead.</source>
          <target state="translated">제한된 공간에 긴 텍스트를 표시하려면 &lt;code&gt;elide&lt;/code&gt; 를 사용하고 싶을 것입니다 대신 것입니다.</target>
        </trans-unit>
        <trans-unit id="f618c1040caac6ca9177c4bb9135805b3dc92b79" translate="yes" xml:space="preserve">
          <source>If you want to do complex tree operations it is useful to have a lightweight class to store nodes and their relations. &lt;a href=&quot;qdomdocumentfragment&quot;&gt;QDomDocumentFragment&lt;/a&gt; stores a subtree of a document which does not necessarily represent a well-formed XML document.</source>
          <target state="translated">복잡한 트리 작업을 수행하려면 노드와 해당 관계를 저장하는 경량 클래스를 사용하는 것이 좋습니다. &lt;a href=&quot;qdomdocumentfragment&quot;&gt;QDomDocumentFragment&lt;/a&gt; 는 올바른 형식의 XML 문서를 나타내지 않아도되는 문서의 서브 트리를 저장합니다.</target>
        </trans-unit>
        <trans-unit id="9e6b9d0f74edcf13c88c150acd668db3566c2fe1" translate="yes" xml:space="preserve">
          <source>If you want to enable sorting in your table widget, do so after you have populated it with items, otherwise sorting may interfere with the insertion order (see &lt;a href=&quot;qtablewidget#setItem&quot;&gt;setItem&lt;/a&gt;() for details).</source>
          <target state="translated">테이블 위젯에서 정렬을 사용하려면 항목으로 채워진 후 그렇게하십시오. 그렇지 않으면 정렬이 삽입 순서를 방해 할 수 있습니다 (자세한 내용은 &lt;a href=&quot;qtablewidget#setItem&quot;&gt;setItem&lt;/a&gt; () 참조).</target>
        </trans-unit>
        <trans-unit id="6514036df6c7d55763ed7bf89f4062e33ae06d27" translate="yes" xml:space="preserve">
          <source>If you want to expand the string so that it reaches a certain width and fill the new positions with a particular character, use the &lt;a href=&quot;qstring#leftJustified&quot;&gt;leftJustified&lt;/a&gt;() function:</source>
          <target state="translated">문자열을 특정 너비에 도달하도록 확장하고 특정 문자로 새 위치를 채우려면 &lt;a href=&quot;qstring#leftJustified&quot;&gt;leftJustified&lt;/a&gt; () 함수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="87bc52b74dde73e1fdb370694004887ba136ffa6" translate="yes" xml:space="preserve">
          <source>If you want to find all occurrences of a particular character or substring in a &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt;, use &lt;a href=&quot;qbytearray#indexOf&quot;&gt;indexOf&lt;/a&gt;() or &lt;a href=&quot;qbytearray#lastIndexOf&quot;&gt;lastIndexOf&lt;/a&gt;(). The former searches forward starting from a given index position, the latter searches backward. Both return the index position of the character or substring if they find it; otherwise, they return -1. For example, here's a typical loop that finds all occurrences of a particular substring:</source>
          <target state="translated">당신이에 특정 문자 또는 부분 문자열의 모든 항목을 찾으려면 &lt;a href=&quot;qbytearray&quot;&gt;QByteArray을&lt;/a&gt; 사용 &lt;a href=&quot;qbytearray#indexOf&quot;&gt;같이 IndexOf&lt;/a&gt; () 또는 &lt;a href=&quot;qbytearray#lastIndexOf&quot;&gt;lastIndexOf에서도&lt;/a&gt; ()을. 전자는 주어진 인덱스 위치에서 시작하여 후자를 검색하고 후자는 뒤로 검색합니다. 둘 다 문자 또는 하위 문자열이있는 경우 색인 위치를 리턴합니다. 그렇지 않으면 -1을 반환합니다. 예를 들어, 다음은 특정 부분 문자열의 모든 항목을 찾는 일반적인 루프입니다.</target>
        </trans-unit>
        <trans-unit id="039ee666228be87bbc3c0658e63f25230c55feb4" translate="yes" xml:space="preserve">
          <source>If you want to find all occurrences of a particular character or substring in a &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;, use the &lt;a href=&quot;qstring#indexOf&quot;&gt;indexOf&lt;/a&gt;() or &lt;a href=&quot;qstring#lastIndexOf&quot;&gt;lastIndexOf&lt;/a&gt;() functions. The former searches forward starting from a given index position, the latter searches backward. Both return the index position of the character or substring if they find it; otherwise, they return -1. For example, here is a typical loop that finds all occurrences of a particular substring:</source>
          <target state="translated">특정 문자 나에 하위 문자열의 모든 항목을 찾으려면 &lt;a href=&quot;qstring&quot;&gt;QString을&lt;/a&gt; , 사용 &lt;a href=&quot;qstring#indexOf&quot;&gt;같이 IndexOf&lt;/a&gt; () 또는 &lt;a href=&quot;qstring#lastIndexOf&quot;&gt;lastIndexOf에서도&lt;/a&gt; () 함수를. 전자는 주어진 인덱스 위치에서 시작하여 후자를 검색하고 후자는 뒤로 검색합니다. 둘 다 문자 또는 하위 문자열이있는 경우 색인 위치를 리턴합니다. 그렇지 않으면 -1을 반환합니다. 예를 들어, 다음은 특정 부분 문자열의 모든 항목을 찾는 일반적인 루프입니다.</target>
        </trans-unit>
        <trans-unit id="27bdeff94521d79ebae9498359259da99a578304" translate="yes" xml:space="preserve">
          <source>If you want to find all occurrences of a particular value in a list, use &lt;a href=&quot;qlist#indexOf&quot;&gt;indexOf&lt;/a&gt;() or &lt;a href=&quot;qlist#lastIndexOf&quot;&gt;lastIndexOf&lt;/a&gt;(). The former searches forward starting from a given index position, the latter searches backward. Both return the index of a matching item if they find it; otherwise, they return -1. For example:</source>
          <target state="translated">목록에서 특정 값의 모든 항목을 찾으려면 &lt;a href=&quot;qlist#indexOf&quot;&gt;indexOf&lt;/a&gt; () 또는 &lt;a href=&quot;qlist#lastIndexOf&quot;&gt;lastIndexOf&lt;/a&gt; ()를 사용하십시오. 전자는 주어진 인덱스 위치에서 시작하여 후자를 검색하고 후자는 뒤로 검색합니다. 둘 다 일치하는 항목의 색인을 찾은 경우이를 리턴합니다. 그렇지 않으면 -1을 반환합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4fd1fe40bbf0af92b8be371546623b59516fd074" translate="yes" xml:space="preserve">
          <source>If you want to find all occurrences of a particular value in a vector, use &lt;a href=&quot;qvector#indexOf&quot;&gt;indexOf&lt;/a&gt;() or &lt;a href=&quot;qvector#lastIndexOf&quot;&gt;lastIndexOf&lt;/a&gt;(). The former searches forward starting from a given index position, the latter searches backward. Both return the index of the matching item if they found one; otherwise, they return -1. For example:</source>
          <target state="translated">벡터에서 특정 값의 모든 항목을 찾으려면 &lt;a href=&quot;qvector#indexOf&quot;&gt;indexOf&lt;/a&gt; () 또는 &lt;a href=&quot;qvector#lastIndexOf&quot;&gt;lastIndexOf&lt;/a&gt; ()를 사용하십시오. 전자는 주어진 인덱스 위치에서 시작하여 후자를 검색하고 후자는 뒤로 검색합니다. 둘 다 일치하는 항목의 색인을 찾은 경우이를 리턴합니다. 그렇지 않으면 -1을 반환합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a4c3e9969fbbaff4bfc63ca9b9594928ad5c07e3" translate="yes" xml:space="preserve">
          <source>If you want to find all occurrences of a particular value, use &lt;a href=&quot;qfutureiterator#findNext&quot;&gt;findNext&lt;/a&gt;() or &lt;a href=&quot;qfutureiterator#findPrevious&quot;&gt;findPrevious&lt;/a&gt;() in a loop.</source>
          <target state="translated">특정 값의 모든 항목을 찾으려면 루프에서 &lt;a href=&quot;qfutureiterator#findNext&quot;&gt;findNext&lt;/a&gt; () 또는 &lt;a href=&quot;qfutureiterator#findPrevious&quot;&gt;findPrevious&lt;/a&gt; ()를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="898951fabb2a0eafcd00294a33ae1f37a06ebddf" translate="yes" xml:space="preserve">
          <source>If you want to find all occurrences of a particular value, use &lt;a href=&quot;qhashiterator#findNext&quot;&gt;findNext&lt;/a&gt;() or &lt;a href=&quot;qhashiterator#findPrevious&quot;&gt;findPrevious&lt;/a&gt;() in a loop. For example:</source>
          <target state="translated">특정 값의 모든 항목을 찾으려면 루프에서 &lt;a href=&quot;qhashiterator#findNext&quot;&gt;findNext&lt;/a&gt; () 또는 &lt;a href=&quot;qhashiterator#findPrevious&quot;&gt;findPrevious&lt;/a&gt; ()를 사용하십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4b82cd87403265c3fee60ae6331015acbbe690bd" translate="yes" xml:space="preserve">
          <source>If you want to find all occurrences of a particular value, use &lt;a href=&quot;qlinkedlistiterator#findNext&quot;&gt;findNext&lt;/a&gt;() or &lt;a href=&quot;qlinkedlistiterator#findPrevious&quot;&gt;findPrevious&lt;/a&gt;() in a loop.</source>
          <target state="translated">특정 값의 모든 항목을 찾으려면 루프에서 &lt;a href=&quot;qlinkedlistiterator#findNext&quot;&gt;findNext&lt;/a&gt; () 또는 &lt;a href=&quot;qlinkedlistiterator#findPrevious&quot;&gt;findPrevious&lt;/a&gt; ()를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="3e2537f0565774525da7ed64dac47ab4a40e2305" translate="yes" xml:space="preserve">
          <source>If you want to find all occurrences of a particular value, use &lt;a href=&quot;qlistiterator#findNext&quot;&gt;findNext&lt;/a&gt;() or &lt;a href=&quot;qlistiterator#findPrevious&quot;&gt;findPrevious&lt;/a&gt;() in a loop.</source>
          <target state="translated">특정 값의 모든 항목을 찾으려면 루프에서 &lt;a href=&quot;qlistiterator#findNext&quot;&gt;findNext&lt;/a&gt; () 또는 &lt;a href=&quot;qlistiterator#findPrevious&quot;&gt;findPrevious&lt;/a&gt; ()를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="092c0df4a0b9fa279f43249c5212612d6ef96a38" translate="yes" xml:space="preserve">
          <source>If you want to find all occurrences of a particular value, use &lt;a href=&quot;qmapiterator#findNext&quot;&gt;findNext&lt;/a&gt;() or &lt;a href=&quot;qmapiterator#findPrevious&quot;&gt;findPrevious&lt;/a&gt;() in a loop. For example:</source>
          <target state="translated">특정 값의 모든 항목을 찾으려면 루프에서 &lt;a href=&quot;qmapiterator#findNext&quot;&gt;findNext&lt;/a&gt; () 또는 &lt;a href=&quot;qmapiterator#findPrevious&quot;&gt;findPrevious&lt;/a&gt; ()를 사용하십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b7c55e1a6cb9f3947aa66f6df9204c79725e274f" translate="yes" xml:space="preserve">
          <source>If you want to find all occurrences of a particular value, use &lt;a href=&quot;qmutablehashiterator#findNext&quot;&gt;findNext&lt;/a&gt;() or &lt;a href=&quot;qmutablehashiterator#findPrevious&quot;&gt;findPrevious&lt;/a&gt;() in a loop. For example:</source>
          <target state="translated">특정 값의 모든 항목을 찾으려면 루프에서 &lt;a href=&quot;qmutablehashiterator#findNext&quot;&gt;findNext&lt;/a&gt; () 또는 &lt;a href=&quot;qmutablehashiterator#findPrevious&quot;&gt;findPrevious&lt;/a&gt; ()를 사용하십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3f7a8dd0427879e3fd8e9577c8dfaa12e390a3ad" translate="yes" xml:space="preserve">
          <source>If you want to find all occurrences of a particular value, use &lt;a href=&quot;qmutablelinkedlistiterator#findNext&quot;&gt;findNext&lt;/a&gt;() or &lt;a href=&quot;qmutablelinkedlistiterator#findPrevious&quot;&gt;findPrevious&lt;/a&gt;() in a loop.</source>
          <target state="translated">특정 값의 모든 항목을 찾으려면 루프에서 &lt;a href=&quot;qmutablelinkedlistiterator#findNext&quot;&gt;findNext&lt;/a&gt; () 또는 &lt;a href=&quot;qmutablelinkedlistiterator#findPrevious&quot;&gt;findPrevious&lt;/a&gt; ()를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="d2c2d1220486fde408994dbb3f861d6a131310dd" translate="yes" xml:space="preserve">
          <source>If you want to find all occurrences of a particular value, use &lt;a href=&quot;qmutablelistiterator#findNext&quot;&gt;findNext&lt;/a&gt;() or &lt;a href=&quot;qmutablelistiterator#findPrevious&quot;&gt;findPrevious&lt;/a&gt;() in a loop.</source>
          <target state="translated">특정 값의 모든 항목을 찾으려면 루프에서 &lt;a href=&quot;qmutablelistiterator#findNext&quot;&gt;findNext&lt;/a&gt; () 또는 &lt;a href=&quot;qmutablelistiterator#findPrevious&quot;&gt;findPrevious&lt;/a&gt; ()를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="6c4574f8d03dabcd80250d9ff8bc30c171345919" translate="yes" xml:space="preserve">
          <source>If you want to find all occurrences of a particular value, use &lt;a href=&quot;qmutablemapiterator#findNext&quot;&gt;findNext&lt;/a&gt;() or &lt;a href=&quot;qmutablemapiterator#findPrevious&quot;&gt;findPrevious&lt;/a&gt;() in a loop. For example:</source>
          <target state="translated">특정 값의 모든 항목을 찾으려면 루프에서 &lt;a href=&quot;qmutablemapiterator#findNext&quot;&gt;findNext&lt;/a&gt; () 또는 &lt;a href=&quot;qmutablemapiterator#findPrevious&quot;&gt;findPrevious&lt;/a&gt; ()를 사용하십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="215948c402f89b1d0e279407c4317a276aa1d8e1" translate="yes" xml:space="preserve">
          <source>If you want to find all occurrences of a particular value, use &lt;a href=&quot;qmutablevectoriterator#findNext&quot;&gt;findNext&lt;/a&gt;() or &lt;a href=&quot;qmutablevectoriterator#findPrevious&quot;&gt;findPrevious&lt;/a&gt;() in a loop.</source>
          <target state="translated">특정 값의 모든 항목을 찾으려면 루프에서 &lt;a href=&quot;qmutablevectoriterator#findNext&quot;&gt;findNext&lt;/a&gt; () 또는 &lt;a href=&quot;qmutablevectoriterator#findPrevious&quot;&gt;findPrevious&lt;/a&gt; ()를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="2a53799d90a3f80407eb44d3086cc5e422647bd7" translate="yes" xml:space="preserve">
          <source>If you want to find all occurrences of a particular value, use &lt;a href=&quot;qsetiterator#findNext&quot;&gt;findNext&lt;/a&gt;() or &lt;a href=&quot;qsetiterator#findPrevious&quot;&gt;findPrevious&lt;/a&gt;() in a loop.</source>
          <target state="translated">특정 값의 모든 항목을 찾으려면 루프에서 &lt;a href=&quot;qsetiterator#findNext&quot;&gt;findNext&lt;/a&gt; () 또는 &lt;a href=&quot;qsetiterator#findPrevious&quot;&gt;findPrevious&lt;/a&gt; ()를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="24f67f821a227bf0a8d722bc4e53136270262bf1" translate="yes" xml:space="preserve">
          <source>If you want to find all occurrences of a particular value, use &lt;a href=&quot;qvectoriterator#findNext&quot;&gt;findNext&lt;/a&gt;() or &lt;a href=&quot;qvectoriterator#findPrevious&quot;&gt;findPrevious&lt;/a&gt;() in a loop.</source>
          <target state="translated">특정 값의 모든 항목을 찾으려면 루프에서 &lt;a href=&quot;qvectoriterator#findNext&quot;&gt;findNext&lt;/a&gt; () 또는 &lt;a href=&quot;qvectoriterator#findPrevious&quot;&gt;findPrevious&lt;/a&gt; ()를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ec7b23d25e51deabb1188265f05be9abd0cb9659" translate="yes" xml:space="preserve">
          <source>If you want to find the directory containing the application's executable, see &lt;a href=&quot;qcoreapplication#applicationDirPath&quot;&gt;QCoreApplication::applicationDirPath&lt;/a&gt;().</source>
          <target state="translated">응용 프로그램의 실행 파일이 들어있는 디렉토리를 찾으려면 &lt;a href=&quot;qcoreapplication#applicationDirPath&quot;&gt;QCoreApplication :: applicationDirPath&lt;/a&gt; ()를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="555f6e4ee413aca7be22902a76f9c68413d21a0b" translate="yes" xml:space="preserve">
          <source>If you want to get only the peer's immediate certificate, use &lt;a href=&quot;qsslconfiguration#peerCertificate&quot;&gt;peerCertificate&lt;/a&gt;().</source>
          <target state="translated">피어의 즉시 인증서 만 얻으려면 &lt;a href=&quot;qsslconfiguration#peerCertificate&quot;&gt;peerCertificate&lt;/a&gt; ()를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="5f588095f3464b16d49f361f0c4bfe90fc18f4b0" translate="yes" xml:space="preserve">
          <source>If you want to get only the peer's immediate certificate, use &lt;a href=&quot;qsslsocket#peerCertificate&quot;&gt;peerCertificate&lt;/a&gt;().</source>
          <target state="translated">피어의 즉시 인증서 만 얻으려면 &lt;a href=&quot;qsslsocket#peerCertificate&quot;&gt;peerCertificate&lt;/a&gt; ()를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="259fa74d33ed5c4b05c0e2870301509985e1ba3f" translate="yes" xml:space="preserve">
          <source>If you want to get the first or last item in a linked list, use &lt;a href=&quot;qlinkedlist#first&quot;&gt;first&lt;/a&gt;() or &lt;a href=&quot;qlinkedlist#last&quot;&gt;last&lt;/a&gt;(). If you want to remove an item from either end of the list, use &lt;a href=&quot;qlinkedlist#removeFirst&quot;&gt;removeFirst&lt;/a&gt;() or &lt;a href=&quot;qlinkedlist#removeLast&quot;&gt;removeLast&lt;/a&gt;(). If you want to remove all occurrences of a given value in the list, use &lt;a href=&quot;qlinkedlist#removeAll&quot;&gt;removeAll&lt;/a&gt;().</source>
          <target state="translated">링크 된 목록에서 첫 번째 또는 마지막 항목을 가져 오려면 &lt;a href=&quot;qlinkedlist#first&quot;&gt;first&lt;/a&gt; () 또는 &lt;a href=&quot;qlinkedlist#last&quot;&gt;last&lt;/a&gt; ()를 사용하십시오. 목록 끝에서 항목을 제거하려면 &lt;a href=&quot;qlinkedlist#removeFirst&quot;&gt;removeFirst&lt;/a&gt; () 또는 &lt;a href=&quot;qlinkedlist#removeLast&quot;&gt;removeLast&lt;/a&gt; ()를 사용하십시오. 목록에서 주어진 값을 모두 제거하려면 &lt;a href=&quot;qlinkedlist#removeAll&quot;&gt;removeAll&lt;/a&gt; ()을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="2230d8498d7120ad007e4bbdd51b64b890af4f49" translate="yes" xml:space="preserve">
          <source>If you want to give your users maximum freedom in what strings they can pass to your function, accompany the &lt;a href=&quot;qstringview&quot;&gt;QStringView&lt;/a&gt; overload with overloads for</source>
          <target state="translated">사용자에게 함수에 전달할 수있는 문자열을 최대한 자유롭게 제공하려면 &lt;a href=&quot;qstringview&quot;&gt;QStringView&lt;/a&gt; 오버로드에 과부하가 수반 됩니다.</target>
        </trans-unit>
        <trans-unit id="4246d6b83ef0b1afdc8b1a9f53698034957eb38a" translate="yes" xml:space="preserve">
          <source>If you want to insert many records at the same time, it is often more efficient to separate the query from the actual values being inserted. This can be done using placeholders. Qt supports two placeholder syntaxes: named binding and positional binding. Here's an example of named binding:</source>
          <target state="translated">동시에 많은 레코드를 삽입하려는 경우 삽입되는 실제 값과 쿼리를 분리하는 것이 더 효율적입니다. 자리 표시자를 사용하여 수행 할 수 있습니다. Qt는 명명 된 바인딩과 위치 바인딩의 두 자리 표시 자 구문을 지원합니다. 다음은 명명 된 바인딩의 예입니다.</target>
        </trans-unit>
        <trans-unit id="8320992c150ec7f0ac1d4db708fa844d42e7033e" translate="yes" xml:space="preserve">
          <source>If you want to insert, modify, or remove items in the middle of the list, you must use an iterator. &lt;a href=&quot;qlinkedlist&quot;&gt;QLinkedList&lt;/a&gt; provides both &lt;a href=&quot;containers#java-style-iterators&quot;&gt;Java-style iterators&lt;/a&gt; (&lt;a href=&quot;qlinkedlistiterator&quot;&gt;QLinkedListIterator&lt;/a&gt; and &lt;a href=&quot;qmutablelinkedlistiterator&quot;&gt;QMutableLinkedListIterator&lt;/a&gt;) and &lt;a href=&quot;containers#stl-style-iterators&quot;&gt;STL-style iterators&lt;/a&gt; (&lt;a href=&quot;qlinkedlist-const-iterator&quot;&gt;QLinkedList::const_iterator&lt;/a&gt; and &lt;a href=&quot;qlinkedlist-iterator&quot;&gt;QLinkedList::iterator&lt;/a&gt;). See the documentation for these classes for details.</source>
          <target state="translated">목록 중간에 항목을 삽입, 수정 또는 제거하려면 반복자를 사용해야합니다. &lt;a href=&quot;qlinkedlist&quot;&gt;QLinkedList&lt;/a&gt; 는 &lt;a href=&quot;containers#java-style-iterators&quot;&gt;Java 스타일 반복자&lt;/a&gt; ( &lt;a href=&quot;qlinkedlistiterator&quot;&gt;QLinkedListIterator&lt;/a&gt; 및 &lt;a href=&quot;qmutablelinkedlistiterator&quot;&gt;QMutableLinkedListIterator&lt;/a&gt; )와 &lt;a href=&quot;containers#stl-style-iterators&quot;&gt;STL 스타일 반복자&lt;/a&gt; ( &lt;a href=&quot;qlinkedlist-const-iterator&quot;&gt;QLinkedList :: const_iterator&lt;/a&gt; 및 &lt;a href=&quot;qlinkedlist-iterator&quot;&gt;QLinkedList :: iterator&lt;/a&gt; )를 모두 제공합니다. 자세한 내용은 해당 클래스의 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a3b3e33d661d3a733b124525ba2561b6b52910a0" translate="yes" xml:space="preserve">
          <source>If you want to iterate over the list, you can use the &lt;a href=&quot;containers#foreach&quot;&gt;foreach&lt;/a&gt; pseudo-keyword:</source>
          <target state="translated">목록을 반복하려면 &lt;a href=&quot;containers#foreach&quot;&gt;foreach&lt;/a&gt; 의사 키워드를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c92b86b63ccc1777115a271d645ee3bf2b6e9eee" translate="yes" xml:space="preserve">
          <source>If you want to iterate over the properties of a script object, use the &lt;a href=&quot;qjsvalueiterator&quot;&gt;QJSValueIterator&lt;/a&gt; class.</source>
          <target state="translated">스크립트 오브젝트의 특성을 반복하려면 &lt;a href=&quot;qjsvalueiterator&quot;&gt;QJSValueIterator&lt;/a&gt; 클래스를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="18af9e9094d839882658054a3f98e2243ae331c7" translate="yes" xml:space="preserve">
          <source>If you want to know about changes to items see the &lt;a href=&quot;qabstractitemview#dataChanged&quot;&gt;dataChanged&lt;/a&gt;() signal.</source>
          <target state="translated">항목 변경에 대해 알고 싶다면 &lt;a href=&quot;qabstractitemview#dataChanged&quot;&gt;dataChanged&lt;/a&gt; () 신호를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1c3819c472a114c60cfcc0efb6c8e2b33d8f4dc2" translate="yes" xml:space="preserve">
          <source>If you want to know the advance width of the string (to lay out a set of strings next to each other), use &lt;a href=&quot;qfontmetrics#horizontalAdvance&quot;&gt;horizontalAdvance&lt;/a&gt;() instead.</source>
          <target state="translated">문자열의 진행 폭을 알고 싶다면 (문자열 집합을 나란히 배치하기 위해 ) 대신 &lt;a href=&quot;qfontmetrics#horizontalAdvance&quot;&gt;horizontalAdvance&lt;/a&gt; ()를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="840aa119e2ce11cd80a3be1fcbcd6761cdfcfc1a" translate="yes" xml:space="preserve">
          <source>If you want to know the advance width of the string (to lay out a set of strings next to each other), use &lt;a href=&quot;qfontmetricsf#horizontalAdvance&quot;&gt;horizontalAdvance&lt;/a&gt;() instead.</source>
          <target state="translated">문자열의 진행 폭을 알고 싶다면 (문자열 집합을 나란히 배치하기 위해 ) 대신 &lt;a href=&quot;qfontmetricsf#horizontalAdvance&quot;&gt;horizontalAdvance&lt;/a&gt; ()를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="2eea2b62960c148390b6813c85f9525893b2d799" translate="yes" xml:space="preserve">
          <source>If you want to limit the total number of paragraphs in a &lt;a href=&quot;qplaintextedit&quot;&gt;QPlainTextEdit&lt;/a&gt;, as it is for example useful in a log viewer, then you can use the &lt;a href=&quot;qplaintextedit#maximumBlockCount-prop&quot;&gt;maximumBlockCount&lt;/a&gt; property. The combination of &lt;a href=&quot;qplaintextedit#maximumBlockCount-prop&quot;&gt;setMaximumBlockCount&lt;/a&gt;() and &lt;a href=&quot;qplaintextedit#appendPlainText&quot;&gt;appendPlainText&lt;/a&gt;() turns &lt;a href=&quot;qplaintextedit&quot;&gt;QPlainTextEdit&lt;/a&gt; into an efficient viewer for log text. The scrolling can be reduced with the &lt;a href=&quot;qplaintextedit#centerOnScroll-prop&quot;&gt;centerOnScroll&lt;/a&gt;() property, making the log viewer even faster. Text can be formatted in a limited way, either using a syntax highlighter (see below), or by appending html-formatted text with &lt;a href=&quot;qplaintextedit#appendHtml&quot;&gt;appendHtml&lt;/a&gt;(). While &lt;a href=&quot;qplaintextedit&quot;&gt;QPlainTextEdit&lt;/a&gt; does not support complex rich text rendering with tables and floats, it does support limited paragraph-based formatting that you may need in a log viewer.</source>
          <target state="translated">당신이 문단의 총 수를 제한하려면 &lt;a href=&quot;qplaintextedit&quot;&gt;QPlainTextEdit&lt;/a&gt; 는 예를 들어, 로그 뷰어에서 유용하기 때문에, 당신은 사용할 수 있습니다 &lt;a href=&quot;qplaintextedit#maximumBlockCount-prop&quot;&gt;maximumBlockCount의&lt;/a&gt; 속성을. &lt;a href=&quot;qplaintextedit#maximumBlockCount-prop&quot;&gt;setMaximumBlockCount&lt;/a&gt; ()와 &lt;a href=&quot;qplaintextedit#appendPlainText&quot;&gt;appendPlainText&lt;/a&gt; 의 조합 ()&lt;a href=&quot;qplaintextedit&quot;&gt; QPlainTextEdit로 바뀝니다.&lt;/a&gt; 을 로그 텍스트를위한 효율적인 뷰어로 만듭니다. &lt;a href=&quot;qplaintextedit#centerOnScroll-prop&quot;&gt;centerOnScroll&lt;/a&gt; () 속성을 사용하면 스크롤을 줄일 수있어 로그 뷰어가 훨씬 빨라집니다. 텍스트는 구문 &lt;a href=&quot;qplaintextedit#appendHtml&quot;&gt;하이 라이터&lt;/a&gt; ( 아래 참조)를 사용하거나 appendHtml ()을 사용하여 HTML 형식의 텍스트를 추가하여 제한된 방식으로 서식을 지정할 수 있습니다 . &lt;a href=&quot;qplaintextedit&quot;&gt;QPlainTextEdit&lt;/a&gt; 동안 테이블 및 부동 소수점을 사용한 복잡한 서식있는 텍스트 렌더링은 지원하지 않으며 로그 뷰어에 필요할 수있는 제한된 단락 기반 형식을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="c03b0d91f766b2476164685df4428c8b2781851d" translate="yes" xml:space="preserve">
          <source>If you want to limit the total number of paragraphs in a &lt;a href=&quot;qtextedit&quot;&gt;QTextEdit&lt;/a&gt;, as for example it is often useful in a log viewer, then you can use &lt;a href=&quot;qtextdocument&quot;&gt;QTextDocument&lt;/a&gt;'s maximumBlockCount property for that.</source>
          <target state="translated">에서 총 단락 수를 제한하려는 경우 &lt;a href=&quot;qtextedit&quot;&gt;QTextEdit&lt;/a&gt; 예 : 로그 뷰어에서 종종 유용함)&lt;a href=&quot;qtextdocument&quot;&gt; QTextDocument&lt;/a&gt; 의 maximumBlockCount 속성을 .</target>
        </trans-unit>
        <trans-unit id="958b74a332153748fcd377612a5ab6c6f94575c2" translate="yes" xml:space="preserve">
          <source>If you want to load documents stored in the Qt resource system use &lt;code&gt;qrc&lt;/code&gt; as the scheme in the URL to load. For example, for the document resource path &lt;code&gt;:/docs/index.html&lt;/code&gt; use &lt;code&gt;qrc:/docs/index.html&lt;/code&gt; as the URL with &lt;a href=&quot;qtextbrowser#source-prop&quot;&gt;setSource&lt;/a&gt;().</source>
          <target state="translated">Qt 자원 시스템에 저장된 문서를로드하려면로드 할 URL의 체계로 &lt;code&gt;qrc&lt;/code&gt; 를 사용 하십시오 . 예를 들어, 문서 자원 경로 &lt;code&gt;:/docs/index.html&lt;/code&gt; 의 경우 &lt;code&gt;qrc:/docs/index.html&lt;/code&gt; 을 &lt;a href=&quot;qtextbrowser#source-prop&quot;&gt;setSource&lt;/a&gt; ()가 있는 URL로 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="b12879b76a2aa0ce099bef336488f9360fde4a65" translate="yes" xml:space="preserve">
          <source>If you want to make a &lt;a href=&quot;qml-qtquick-controls2-textarea&quot;&gt;TextArea&lt;/a&gt; scrollable, for example, when it covers an entire application page, it can be placed inside a &lt;a href=&quot;qml-qtquick-controls2-scrollview&quot;&gt;ScrollView&lt;/a&gt;.</source>
          <target state="translated">당신이 만들고 싶다면 &lt;a href=&quot;qml-qtquick-controls2-textarea&quot;&gt;TextArea&lt;/a&gt;예를 들어 전체 응용 프로그램 페이지를 포함 할 때 스크롤 가능&lt;a href=&quot;qml-qtquick-controls2-scrollview&quot;&gt; ScrollView&lt;/a&gt; 안에 배치 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0420de4f97c6bd0d0460b7ae76d840ae331c84f5" translate="yes" xml:space="preserve">
          <source>If you want to modify a sequence in-place, use QtConcurrent::filter():</source>
          <target state="translated">현재 위치에서 시퀀스를 수정하려면 QtConcurrent :: filter ()를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="6dde1ff3076b0db9615214ba9185f8123aff9335" translate="yes" xml:space="preserve">
          <source>If you want to modify a sequence in-place, use QtConcurrent::map(). The map function must then be of the form:</source>
          <target state="translated">현재 위치에서 시퀀스를 수정하려면 QtConcurrent :: map ()을 사용하십시오. 그런 다음 맵 함수는 다음 형식이어야합니다.</target>
        </trans-unit>
        <trans-unit id="d8adeaac6d9eeb2f3e405e34bb22896e1c0e4730" translate="yes" xml:space="preserve">
          <source>If you want to navigate through all the (key, value) pairs stored in a &lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt;, you can use an iterator. &lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt; provides both &lt;a href=&quot;containers#java-style-iterators&quot;&gt;Java-style iterators&lt;/a&gt; (&lt;a href=&quot;qhashiterator&quot;&gt;QHashIterator&lt;/a&gt; and &lt;a href=&quot;qmutablehashiterator&quot;&gt;QMutableHashIterator&lt;/a&gt;) and &lt;a href=&quot;containers#stl-style-iterators&quot;&gt;STL-style iterators&lt;/a&gt; (&lt;a href=&quot;qhash-const-iterator&quot;&gt;QHash::const_iterator&lt;/a&gt; and &lt;a href=&quot;qhash-iterator&quot;&gt;QHash::iterator&lt;/a&gt;). Here's how to iterate over a &lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt;&amp;lt;&lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;, int&amp;gt; using a Java-style iterator:</source>
          <target state="translated">&lt;a href=&quot;qhash#qhash&quot;&gt;QHash에&lt;/a&gt; 저장된 모든 (키, 값) 쌍을 탐색 하려면 반복자를 사용할 수 있습니다. &lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt; 는 &lt;a href=&quot;containers#java-style-iterators&quot;&gt;Java 스타일 반복자&lt;/a&gt; ( &lt;a href=&quot;qhashiterator&quot;&gt;QHashIterator&lt;/a&gt; 및 &lt;a href=&quot;qmutablehashiterator&quot;&gt;QMutableHashIterator&lt;/a&gt; )와 &lt;a href=&quot;containers#stl-style-iterators&quot;&gt;STL 스타일 반복자&lt;/a&gt; ( &lt;a href=&quot;qhash-const-iterator&quot;&gt;QHash :: const_iterator&lt;/a&gt; 및 &lt;a href=&quot;qhash-iterator&quot;&gt;QHash :: iterator&lt;/a&gt; )를 모두 제공합니다. Java 스타일 반복자를 사용하여 &lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt; &amp;lt; &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; , int&amp;gt; 를 반복하는 방법은 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="ebc60af08240e3c0d4572b58b54204bd9cae77c9" translate="yes" xml:space="preserve">
          <source>If you want to navigate through all the (key, value) pairs stored in a &lt;a href=&quot;qmap&quot;&gt;QMap&lt;/a&gt;, you can use an iterator. &lt;a href=&quot;qmap&quot;&gt;QMap&lt;/a&gt; provides both &lt;a href=&quot;containers#java-style-iterators&quot;&gt;Java-style iterators&lt;/a&gt; (&lt;a href=&quot;qmapiterator&quot;&gt;QMapIterator&lt;/a&gt; and &lt;a href=&quot;qmutablemapiterator&quot;&gt;QMutableMapIterator&lt;/a&gt;) and &lt;a href=&quot;containers#stl-style-iterators&quot;&gt;STL-style iterators&lt;/a&gt; (&lt;a href=&quot;qmap-const-iterator&quot;&gt;QMap::const_iterator&lt;/a&gt; and &lt;a href=&quot;qmap-iterator&quot;&gt;QMap::iterator&lt;/a&gt;). Here's how to iterate over a &lt;a href=&quot;qmap&quot;&gt;QMap&lt;/a&gt;&amp;lt;&lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;, int&amp;gt; using a Java-style iterator:</source>
          <target state="translated">&lt;a href=&quot;qmap&quot;&gt;QMap에&lt;/a&gt; 저장된 모든 (키, 값) 쌍을 탐색 하려면 반복자를 사용할 수 있습니다. &lt;a href=&quot;qmap&quot;&gt;QMap&lt;/a&gt; 은 &lt;a href=&quot;containers#java-style-iterators&quot;&gt;Java 스타일 반복자&lt;/a&gt; ( &lt;a href=&quot;qmapiterator&quot;&gt;QMapIterator&lt;/a&gt; 및 &lt;a href=&quot;qmutablemapiterator&quot;&gt;QMutableMapIterator&lt;/a&gt; )와 &lt;a href=&quot;containers#stl-style-iterators&quot;&gt;STL 스타일 반복자&lt;/a&gt; ( &lt;a href=&quot;qmap-const-iterator&quot;&gt;QMap :: const_iterator&lt;/a&gt; 및 &lt;a href=&quot;qmap-iterator&quot;&gt;QMap :: iterator&lt;/a&gt; )를 모두 제공합니다. &lt;a href=&quot;qmap&quot;&gt;QMap&lt;/a&gt; &amp;lt; &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; 을 반복하는 방법은 다음과 같습니다. 은 Java 스타일 반복기를 사용하여 , int&amp;gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b20716bbd0aa09befd167b9400ee62464348694e" translate="yes" xml:space="preserve">
          <source>If you want to navigate through all the values stored in a &lt;a href=&quot;qset&quot;&gt;QSet&lt;/a&gt;, you can use an iterator. &lt;a href=&quot;qset&quot;&gt;QSet&lt;/a&gt; supports both &lt;a href=&quot;containers#java-style-iterators&quot;&gt;Java-style iterators&lt;/a&gt; (&lt;a href=&quot;qsetiterator&quot;&gt;QSetIterator&lt;/a&gt; and &lt;a href=&quot;qmutablesetiterator&quot;&gt;QMutableSetIterator&lt;/a&gt;) and &lt;a href=&quot;containers#stl-style-iterators&quot;&gt;STL-style iterators&lt;/a&gt; (&lt;a href=&quot;qset-iterator&quot;&gt;QSet::iterator&lt;/a&gt; and &lt;a href=&quot;qset-const-iterator&quot;&gt;QSet::const_iterator&lt;/a&gt;). Here's how to iterate over a &lt;a href=&quot;qset&quot;&gt;QSet&lt;/a&gt;&amp;lt;&lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; *&amp;gt; using a Java-style iterator:</source>
          <target state="translated">&lt;a href=&quot;qset&quot;&gt;QSet에&lt;/a&gt; 저장된 모든 값을 탐색 하려면 반복자를 사용할 수 있습니다. &lt;a href=&quot;qset&quot;&gt;QSet&lt;/a&gt; 은 &lt;a href=&quot;containers#java-style-iterators&quot;&gt;Java 스타일 반복자&lt;/a&gt; ( &lt;a href=&quot;qsetiterator&quot;&gt;QSetIterator&lt;/a&gt; 및 &lt;a href=&quot;qmutablesetiterator&quot;&gt;QMutableSetIterator&lt;/a&gt; )와 &lt;a href=&quot;containers#stl-style-iterators&quot;&gt;STL 스타일 반복자&lt;/a&gt; ( &lt;a href=&quot;qset-iterator&quot;&gt;QSet :: iterator&lt;/a&gt; 및 &lt;a href=&quot;qset-const-iterator&quot;&gt;QSet :: const_iterator&lt;/a&gt; )를 모두 지원합니다. 다음 은 Java 스타일 반복기를 사용하여 &lt;a href=&quot;qset&quot;&gt;QSet&lt;/a&gt; &amp;lt; &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; *&amp;gt; 을 반복하는 방법 입니다.</target>
        </trans-unit>
        <trans-unit id="fd6a6b3eb89e36681847d3a753e1b94077fbd42c" translate="yes" xml:space="preserve">
          <source>If you want to obtain the length of the data up to and excluding the first '\0' character, call &lt;a href=&quot;qbytearray#qstrlen&quot;&gt;qstrlen&lt;/a&gt;() on the byte array.</source>
          <target state="translated">첫 번째 '\ 0'문자까지의 데이터 길이를 얻으려면 바이트 배열에서 &lt;a href=&quot;qbytearray#qstrlen&quot;&gt;qstrlen&lt;/a&gt; ()을 호출 하십시오 .</target>
        </trans-unit>
        <trans-unit id="9dfae933ac79cc33edd3dbc61fb58a87498e4218" translate="yes" xml:space="preserve">
          <source>If you want to provide a guaranteed fallback for platforms that do not support theme icons, you can use the second argument:</source>
          <target state="translated">테마 아이콘을 지원하지 않는 플랫폼에 보장 된 폴백을 제공하려면 두 번째 인수를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1db9564dfa61dd28433eb70fca5b8e74b0cfc6e1" translate="yes" xml:space="preserve">
          <source>If you want to provide plugins for use with Qt Designer, see the Qt Designer module documentation.</source>
          <target state="translated">Qt Designer와 함께 사용할 플러그인을 제공하려면 Qt Designer 모듈 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d752ee6abc56ad70cc035e97e08c8c1a5bb8ed99" translate="yes" xml:space="preserve">
          <source>If you want to provide support for web sites that allow the user to open new windows, such as pop-up windows, you can subclass &lt;a href=&quot;qwebengineview&quot;&gt;QWebEngineView&lt;/a&gt; and reimplement the &lt;a href=&quot;qwebengineview#createWindow&quot;&gt;createWindow&lt;/a&gt;() function.</source>
          <target state="translated">사용자가 팝업 창과 같은 새 창을 열 수있는 웹 사이트를 지원하려면 &lt;a href=&quot;qwebengineview&quot;&gt;QWebEngineView&lt;/a&gt; 를 서브 클래스로 작성 하고 &lt;a href=&quot;qwebengineview#createWindow&quot;&gt;createWindow&lt;/a&gt; () 함수를 다시 구현하십시오 .</target>
        </trans-unit>
        <trans-unit id="1bfc523424c8243bdf30d15255ee2b9ba5b0b3c7" translate="yes" xml:space="preserve">
          <source>If you want to provide your users with an editable rich text editor, use &lt;a href=&quot;qtextedit&quot;&gt;QTextEdit&lt;/a&gt;. If you want a text browser without hypertext navigation use &lt;a href=&quot;qtextedit&quot;&gt;QTextEdit&lt;/a&gt;, and use &lt;a href=&quot;qtextedit#readOnly-prop&quot;&gt;QTextEdit::setReadOnly&lt;/a&gt;() to disable editing. If you just need to display a small piece of rich text use &lt;a href=&quot;qlabel&quot;&gt;QLabel&lt;/a&gt;.</source>
          <target state="translated">사용자에게 편집 가능한 서식있는 텍스트 편집기를 제공하려면 &lt;a href=&quot;qtextedit&quot;&gt;QTextEdit을&lt;/a&gt; 사용하십시오 . 하이퍼 텍스트 탐색이없는 텍스트 브라우저를 원하면 &lt;a href=&quot;qtextedit&quot;&gt;QTextEdit&lt;/a&gt; 을 사용하고 &lt;a href=&quot;qtextedit#readOnly-prop&quot;&gt;QTextEdit :: setReadOnly&lt;/a&gt; ()를 사용하여 편집을 비활성화하십시오. 작은 서식있는 텍스트를 표시해야 할 경우 &lt;a href=&quot;qlabel&quot;&gt;QLabel을&lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="3ee969597a0600019ade75416316647fc0e6d9d0" translate="yes" xml:space="preserve">
          <source>If you want to remove an object from the cache for a particular key, call &lt;a href=&quot;qcache#remove&quot;&gt;remove&lt;/a&gt;(). This will also delete the object. If you want to remove an object from the cache without the &lt;a href=&quot;qcache&quot;&gt;QCache&lt;/a&gt; deleting it, use &lt;a href=&quot;qcache#take&quot;&gt;take&lt;/a&gt;().</source>
          <target state="translated">특정 키의 캐시에서 객체를 제거하려면 &lt;a href=&quot;qcache#remove&quot;&gt;remove&lt;/a&gt; ()를 호출 하십시오 . 개체도 삭제됩니다. &lt;a href=&quot;qcache&quot;&gt;QCache&lt;/a&gt; 가 오브젝트를 삭제 하지 않고 캐시에서 오브젝트를 제거 하려면 &lt;a href=&quot;qcache#take&quot;&gt;take&lt;/a&gt; ()를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="de95e27c0ba8453eb485155237ef997413f9832c" translate="yes" xml:space="preserve">
          <source>If you want to remove characters from the</source>
          <target state="translated">에서 문자를 제거하려면</target>
        </trans-unit>
        <trans-unit id="ef371b9382f4cd607dccd67bf00e4dbc96b7c58a" translate="yes" xml:space="preserve">
          <source>If you want to remove items as you iterate over the hash, use &lt;a href=&quot;qmutablehashiterator#remove&quot;&gt;remove&lt;/a&gt;(). If you want to modify the value of an item, use &lt;a href=&quot;qmutablehashiterator#setValue&quot;&gt;setValue&lt;/a&gt;().</source>
          <target state="translated">해시를 반복하면서 항목을 제거하려면 &lt;a href=&quot;qmutablehashiterator#remove&quot;&gt;remove&lt;/a&gt; ()를 사용 하십시오 . 항목의 값을 수정하려면 &lt;a href=&quot;qmutablehashiterator#setValue&quot;&gt;setValue&lt;/a&gt; ()를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b8309cc38c8ce729c85673e89ad866ebb77ca098" translate="yes" xml:space="preserve">
          <source>If you want to remove items as you iterate over the list, use &lt;a href=&quot;qmutablelinkedlistiterator#remove&quot;&gt;remove&lt;/a&gt;(). If you want to modify the value of an item, use &lt;a href=&quot;qmutablelinkedlistiterator#setValue&quot;&gt;setValue&lt;/a&gt;(). If you want to insert a new item in the list, use &lt;a href=&quot;qmutablelinkedlistiterator#insert&quot;&gt;insert&lt;/a&gt;().</source>
          <target state="translated">목록을 반복하면서 항목을 제거하려면 &lt;a href=&quot;qmutablelinkedlistiterator#remove&quot;&gt;remove&lt;/a&gt; ()를 사용 하십시오 . 항목의 값을 수정하려면 &lt;a href=&quot;qmutablelinkedlistiterator#setValue&quot;&gt;setValue&lt;/a&gt; ()를 사용하십시오. 목록에 새 항목을 삽입하려면 &lt;a href=&quot;qmutablelinkedlistiterator#insert&quot;&gt;insert&lt;/a&gt; ()를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="10376d50da4d07a2e0e13c459ae06c0f3bdf15f1" translate="yes" xml:space="preserve">
          <source>If you want to remove items as you iterate over the list, use &lt;a href=&quot;qmutablelistiterator#remove&quot;&gt;remove&lt;/a&gt;(). If you want to modify the value of an item, use &lt;a href=&quot;qmutablelistiterator#setValue&quot;&gt;setValue&lt;/a&gt;(). If you want to insert a new item in the list, use &lt;a href=&quot;qmutablelistiterator#insert&quot;&gt;insert&lt;/a&gt;().</source>
          <target state="translated">목록을 반복하면서 항목을 제거하려면 &lt;a href=&quot;qmutablelistiterator#remove&quot;&gt;remove&lt;/a&gt; ()를 사용 하십시오 . 항목의 값을 수정하려면 &lt;a href=&quot;qmutablelistiterator#setValue&quot;&gt;setValue&lt;/a&gt; ()를 사용하십시오. 목록에 새 항목을 삽입하려면 &lt;a href=&quot;qmutablelistiterator#insert&quot;&gt;insert&lt;/a&gt; ()를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e79b00991d7411d8730611af60e4448d620be40f" translate="yes" xml:space="preserve">
          <source>If you want to remove items as you iterate over the map, use &lt;a href=&quot;qmutablemapiterator#remove&quot;&gt;remove&lt;/a&gt;(). If you want to modify the value of an item, use &lt;a href=&quot;qmutablemapiterator#setValue&quot;&gt;setValue&lt;/a&gt;().</source>
          <target state="translated">맵을 반복하면서 항목을 제거하려면 &lt;a href=&quot;qmutablemapiterator#remove&quot;&gt;remove&lt;/a&gt; ()를 사용 하십시오 . 항목의 값을 수정하려면 &lt;a href=&quot;qmutablemapiterator#setValue&quot;&gt;setValue를&lt;/a&gt; 사용하십시오. ()를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e3544fda3dbbc15c7c70a6df904991bf6f723fcf" translate="yes" xml:space="preserve">
          <source>If you want to remove items as you iterate over the set, use &lt;a href=&quot;qmutablesetiterator#remove&quot;&gt;remove&lt;/a&gt;().</source>
          <target state="translated">세트를 반복하면서 항목을 제거하려면 &lt;a href=&quot;qmutablesetiterator#remove&quot;&gt;제거를&lt;/a&gt; 사용 하십시오. ()를 .</target>
        </trans-unit>
        <trans-unit id="52adc96426aaf31b367417826338bf9e429eaab0" translate="yes" xml:space="preserve">
          <source>If you want to remove items as you iterate over the vector, use &lt;a href=&quot;qmutablevectoriterator#remove&quot;&gt;remove&lt;/a&gt;(). If you want to modify the value of an item, use &lt;a href=&quot;qmutablevectoriterator#setValue&quot;&gt;setValue&lt;/a&gt;(). If you want to insert a new item in the vector, use &lt;a href=&quot;qmutablevectoriterator#insert&quot;&gt;insert&lt;/a&gt;().</source>
          <target state="translated">벡터를 반복하면서 항목을 제거하려면 &lt;a href=&quot;qmutablevectoriterator#remove&quot;&gt;remove&lt;/a&gt; ()를 사용 하십시오 . 항목의 값을 수정하려면 &lt;a href=&quot;qmutablevectoriterator#setValue&quot;&gt;setValue&lt;/a&gt; ()를 사용하십시오. 벡터에 새 항목을 삽입하려면 &lt;a href=&quot;qmutablevectoriterator#insert&quot;&gt;insert를&lt;/a&gt; 사용하십시오. ()를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="6fda9fdf9261a6245582f8837e5859eea092ed4b" translate="yes" xml:space="preserve">
          <source>If you want to remove the row from the form layout and delete the inserted layout, use &lt;a href=&quot;qformlayout#removeRow&quot;&gt;removeRow&lt;/a&gt;() instead.</source>
          <target state="translated">양식 레이아웃에서 행을 제거하고 삽입 된 레이아웃을 삭제하려면 &lt;a href=&quot;qformlayout#removeRow&quot;&gt;removeRow를&lt;/a&gt; 사용하십시오. 대신 ()를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="5b5de4c69911fc30f9b82bfa504e693900ea36ee" translate="yes" xml:space="preserve">
          <source>If you want to remove the row from the form layout without deleting the inserted layout, use &lt;a href=&quot;qformlayout#takeRow&quot;&gt;takeRow&lt;/a&gt;() instead.</source>
          <target state="translated">삽입 된 레이아웃을 삭제하지 않고 양식 레이아웃에서 행을 제거하려면 &lt;a href=&quot;qformlayout#takeRow&quot;&gt;takeRow를&lt;/a&gt; 사용 하십시오. 대신 ()를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="fa1ce005f8df0dab7960ecac023bfee749fbe509" translate="yes" xml:space="preserve">
          <source>If you want to remove the row from the layout and delete the widgets, use &lt;a href=&quot;qformlayout#removeRow&quot;&gt;removeRow&lt;/a&gt;() instead.</source>
          <target state="translated">레이아웃에서 행을 제거하고 위젯을 삭제하려면 대신 &lt;a href=&quot;qformlayout#removeRow&quot;&gt;removeRow&lt;/a&gt; ()를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="a3f3d65e85e892eceb0bc7744f0008ea7233fffd" translate="yes" xml:space="preserve">
          <source>If you want to remove the row from the layout without deleting the widgets, use &lt;a href=&quot;qformlayout#takeRow&quot;&gt;takeRow&lt;/a&gt;() instead.</source>
          <target state="translated">위젯을 삭제하지 않고 레이아웃에서 행을 제거하려면 대신 &lt;a href=&quot;qformlayout#takeRow&quot;&gt;takeRow&lt;/a&gt; ()를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="64cdda339bec7f812dc4dd44c78a96f48277db67" translate="yes" xml:space="preserve">
          <source>If you want to replace the base class's function, you must implement everything yourself. However, if you only want to extend the base class's functionality, then you implement what you want and call the base class to obtain the default behavior for any cases you do not want to handle.</source>
          <target state="translated">기본 클래스의 기능을 바꾸려면 모든 것을 직접 구현해야합니다. 그러나 기본 클래스의 기능 만 확장하려는 경우 원하는 것을 구현하고 처리하지 않으려는 경우에 대한 기본 동작을 얻기 위해 기본 클래스를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="c7aa4540624b95acabdbadb09c58519aa35fef4c" translate="yes" xml:space="preserve">
          <source>If you want to retrieve all the values for a single key, you can use values(const Key &amp;amp;key), which returns a &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt;&amp;lt;T&amp;gt;:</source>
          <target state="translated">단일 키의 모든 값을 검색하려면 values ​​(const Key &amp;amp; key)를 사용하면 &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt; &amp;lt;T&amp;gt; 를 반환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e89eb3afeb225e87d907879175af3afcf126c9a5" translate="yes" xml:space="preserve">
          <source>If you want to save or restore many settings with the same prefix, you can specify the prefix using &lt;a href=&quot;qsettings#beginGroup&quot;&gt;beginGroup&lt;/a&gt;() and call &lt;a href=&quot;qsettings#endGroup&quot;&gt;endGroup&lt;/a&gt;() at the end. Here's the same example again, but this time using the group mechanism:</source>
          <target state="translated">저장하거나 같은 접두사로 많은 설정을 복원하려면 사용 접두사를 지정할 수 있습니다 &lt;a href=&quot;qsettings#beginGroup&quot;&gt;beginGroup&lt;/a&gt; ()와 전화를 &lt;a href=&quot;qsettings#endGroup&quot;&gt;말 단기&lt;/a&gt; 말을 (). 다음은 같은 예이지만 이번에는 그룹 메커니즘을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="a75869a744ee8993dcf20ae9c6b9a50d513b38ca" translate="yes" xml:space="preserve">
          <source>If you want to save your changes, and at the same time preserve the original contents, you can use the &lt;a href=&quot;qdesignerwidgetboxinterface#save&quot;&gt;save&lt;/a&gt;() function combined with the &lt;a href=&quot;qdesignerwidgetboxinterface#setFileName&quot;&gt;setFileName&lt;/a&gt;() function to save your changes into another file. Remember to store the name of the original file first:</source>
          <target state="translated">변경 사항을 저장하고, 동시에 원래 내용을 보존하기 위해 원하는 경우 사용할 수있는 &lt;a href=&quot;qdesignerwidgetboxinterface#save&quot;&gt;저장&lt;/a&gt; 와 함께 () 함수 &lt;a href=&quot;qdesignerwidgetboxinterface#setFileName&quot;&gt;setFileName&lt;/a&gt; 다른 파일에 변경 사항을 저장 () 함수를. 원본 파일의 이름을 먼저 저장해야합니다.</target>
        </trans-unit>
        <trans-unit id="c0905b1777f0fd800c421f7d245b1e5b746013b1" translate="yes" xml:space="preserve">
          <source>If you want to see if a &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; starts or ends with a particular substring use &lt;a href=&quot;qstring#startsWith&quot;&gt;startsWith&lt;/a&gt;() or &lt;a href=&quot;qstring#endsWith&quot;&gt;endsWith&lt;/a&gt;(). If you simply want to check whether a &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; contains a particular character or substring, use the &lt;a href=&quot;qstring#contains&quot;&gt;contains&lt;/a&gt;() function. If you want to find out how many times a particular character or substring occurs in the string, use &lt;a href=&quot;qstring#count-1&quot;&gt;count&lt;/a&gt;().</source>
          <target state="translated">당신이 있는지 확인하려면 &lt;a href=&quot;qstring&quot;&gt;QString가&lt;/a&gt; 특정 문자열을 사용하여 시작하거나 끝 &lt;a href=&quot;qstring#startsWith&quot;&gt;startsWith&lt;/a&gt; () 또는 &lt;a href=&quot;qstring#endsWith&quot;&gt;endsWith&lt;/a&gt; (). &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; 에 특정 문자 또는 하위 문자열이 포함되어 있는지 확인 하려면 &lt;a href=&quot;qstring#contains&quot;&gt;contains&lt;/a&gt; () 함수를 사용하십시오 . 문자열에서 특정 문자 나 부분 문자열이 몇 번 나오는지 알아 보려면 &lt;a href=&quot;qstring#count-1&quot;&gt;count를&lt;/a&gt; 사용하십시오. ()를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="9a8f9333a015252bd2352bd9fc0af4626df206b9" translate="yes" xml:space="preserve">
          <source>If you want to set several items of a particular row (say, by calling setItem() in a loop), you may want to turn off sorting before doing so, and turn it back on afterwards; this will allow you to use the same</source>
          <target state="translated">특정 행의 여러 항목을 설정하려면 (예 : 루프에서 setItem ()을 호출하여) 정렬하기 전에 정렬을 해제 한 다음 나중에 다시 설정해야합니다. 이것은 당신이 같은 것을 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="bbca6a7d342806310527b218a8084ddfb4bd37d3" translate="yes" xml:space="preserve">
          <source>If you want to show a tooltip immediately, while the mouse is moving (e.g., to get the mouse coordinates with &lt;a href=&quot;qmouseevent#pos&quot;&gt;QMouseEvent::pos&lt;/a&gt;() and show them as a tooltip), you must first enable mouse tracking as described above. Then, to ensure that the tooltip is updated immediately, you must call &lt;a href=&quot;qtooltip#showText&quot;&gt;QToolTip::showText&lt;/a&gt;() instead of &lt;a href=&quot;qwidget#toolTip-prop&quot;&gt;setToolTip&lt;/a&gt;() in your implementation of mouseMoveEvent().</source>
          <target state="translated">마우스가 움직이는 동안 툴팁을 즉시 표시하려면 (예 : &lt;a href=&quot;qmouseevent#pos&quot;&gt;QMouseEvent :: pos&lt;/a&gt; ()로 마우스 좌표를 가져 와서 툴팁으로 표시하려면) 위에서 설명한대로 먼저 마우스 추적을 활성화해야합니다. 그런 다음 툴팁이 즉시 업데이트되도록하려면 &lt;a href=&quot;qwidget#toolTip-prop&quot;&gt;setToolTip&lt;/a&gt; 대신 &lt;a href=&quot;qtooltip#showText&quot;&gt;QToolTip :: showText&lt;/a&gt; ()를 호출해야합니다. mouseMoveEvent () 구현에서 () .</target>
        </trans-unit>
        <trans-unit id="cfa70650fd011d8c6b69c7e7e3eebd7b65431d31" translate="yes" xml:space="preserve">
          <source>If you want to sort your strings in an arbitrary order, consider using the &lt;a href=&quot;qmap&quot;&gt;QMap&lt;/a&gt; class. For example, you could use a &lt;a href=&quot;qmap&quot;&gt;QMap&lt;/a&gt;&amp;lt;&lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;, &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;&amp;gt; to create a case-insensitive ordering (e.g. with the keys being lower-case versions of the strings, and the values being the strings), or a &lt;a href=&quot;qmap&quot;&gt;QMap&lt;/a&gt;&amp;lt;int, &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;&amp;gt; to sort the strings by some integer index.</source>
          <target state="translated">문자열을 임의의 순서로 정렬하려면 &lt;a href=&quot;qmap&quot;&gt;QMap&lt;/a&gt; 클래스 사용을 고려하십시오 . 예를 들어, &lt;a href=&quot;qmap&quot;&gt;QMap&lt;/a&gt; &amp;lt; &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; , &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; &amp;gt;을 사용하여 대소 문자를 구분하지 않는 순서를 만들 수 있습니다 (예 : 키가 문자열의 소문자 버전이고 값이 문자열 인 경우) 또는 &lt;a href=&quot;qmap&quot;&gt;QMap&lt;/a&gt; &amp;lt;int, &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; &amp;gt; 정수 인덱스로 문자열을 정렬합니다.</target>
        </trans-unit>
        <trans-unit id="f76a13f9a50f1cd7cbab92e1e2b73729d9143b78" translate="yes" xml:space="preserve">
          <source>If you want to specify the widget's size hint for a given width or height, you can provide the fixed dimension in</source>
          <target state="translated">주어진 너비 또는 높이에 대해 위젯의 크기 힌트를 지정하려는 경우 고정 크기를</target>
        </trans-unit>
        <trans-unit id="d0ee609e91b445855383ec2c6155845fa3a8bd55" translate="yes" xml:space="preserve">
          <source>If you want to store a single block of data (e.g., a comment), you can pass an empty key, or use a generic key like &quot;Description&quot;.</source>
          <target state="translated">단일 데이터 블록 (예 : 주석)을 저장하려면 빈 키를 전달하거나 &quot;설명&quot;과 같은 일반 키를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f81b7d8db42ec507d0dba034e10ab727008ab07" translate="yes" xml:space="preserve">
          <source>If you want to support several different architectures in your application, the recommendation is to build separate APKs for each architecture, so that each APK only contains the binaries required for the targeted architecture. For more information about this, see the Android documentation about &lt;a href=&quot;http://developer.android.com/google/play/publishing/multiple-apks.html&quot;&gt;Multiple APK Support&lt;/a&gt;.</source>
          <target state="translated">애플리케이션에서 여러 다른 아키텍처를 지원하려는 경우 각 아키텍처마다 별도의 APK를 빌드하여 각 APK에 대상 아키텍처에 필요한 바이너리 만 포함되도록하는 것이 좋습니다. 이에 대한 자세한 내용은 &lt;a href=&quot;http://developer.android.com/google/play/publishing/multiple-apks.html&quot;&gt;다중 APK 지원&lt;/a&gt; 에 대한 Android 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="72c5fa334893fab33e3b0b02a2877a1c1100827d" translate="yes" xml:space="preserve">
          <source>If you want to use &lt;a href=&quot;qflags&quot;&gt;QFlags&lt;/a&gt; for your own enum types, use the &lt;a href=&quot;qflags#Q_DECLARE_FLAGS&quot;&gt;Q_DECLARE_FLAGS&lt;/a&gt;() and &lt;a href=&quot;qflags#Q_DECLARE_OPERATORS_FOR_FLAGS&quot;&gt;Q_DECLARE_OPERATORS_FOR_FLAGS&lt;/a&gt;().</source>
          <target state="translated">당신이 사용하려는 경우 &lt;a href=&quot;qflags&quot;&gt;QFlags을&lt;/a&gt; 사용, 자신의 열거 유형 &lt;a href=&quot;qflags#Q_DECLARE_FLAGS&quot;&gt;Q_DECLARE_FLAGS을&lt;/a&gt; ()와 &lt;a href=&quot;qflags#Q_DECLARE_OPERATORS_FOR_FLAGS&quot;&gt;Q_DECLARE_OPERATORS_FOR_FLAGS&lt;/a&gt; ().</target>
        </trans-unit>
        <trans-unit id="6b463fe5232536dbaebee4ffdb67aea9757aa428" translate="yes" xml:space="preserve">
          <source>If you want to use INI files on all platforms instead of the native API, you can pass &lt;a href=&quot;qsettings#Format-enum&quot;&gt;QSettings::IniFormat&lt;/a&gt; as the first argument to the &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; constructor, followed by the scope, the organization name, and the application name:</source>
          <target state="translated">고유 API 대신 모든 플랫폼에서 INI 파일을 사용하려는 경우 &lt;a href=&quot;qsettings#Format-enum&quot;&gt;QSettings :: IniFormat&lt;/a&gt; 을 &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; 생성자에 대한 첫 번째 인수로 범위, 조직 이름 및 애플리케이션 이름을 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="503c6e60564c4b89c106e617da9c3ec82fdf48b5" translate="yes" xml:space="preserve">
          <source>If you want to use Q_DECLARE_INTERFACE with interface classes declared in a namespace then you have to make sure the Q_DECLARE_INTERFACE is not inside a namespace though. For example:</source>
          <target state="translated">네임 스페이스에 선언 된 인터페이스 클래스와 함께 Q_DECLARE_INTERFACE를 사용하려면 Q_DECLARE_INTERFACE가 네임 스페이스 내에 있지 않은지 확인해야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b35675b93a592dae0c6fee364af226250b2a5072" translate="yes" xml:space="preserve">
          <source>If you want to use a &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; to hold child widgets you will usually want to add a layout to the parent &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt;. See &lt;a href=&quot;layout#&quot;&gt;Layout Management&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; 을 사용하여 하위 위젯을 보유하려면 일반적으로 상위 &lt;a href=&quot;qwidget&quot;&gt;QWidget에&lt;/a&gt; 레이아웃을 추가하려고합니다 . 자세한 내용은 &lt;a href=&quot;layout#&quot;&gt;레이아웃 관리&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a75288387750d6649bbe76b48200a4459bccf73d" translate="yes" xml:space="preserve">
          <source>If you want to use a filter function takes more than one argument, you can use a lambda function or &lt;code&gt;std::bind()&lt;/code&gt; to transform it onto a function that takes one argument.</source>
          <target state="translated">필터 함수를 사용하려면 둘 이상의 인수를 사용하려면 람다 함수 또는 &lt;code&gt;std::bind()&lt;/code&gt; 를 사용하여 하나의 인수를 취하는 함수로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a895ee318b395fc5d95d98cb1fb6d4a4bd0d6d1" translate="yes" xml:space="preserve">
          <source>If you want to use a framebuffer object with multisampling enabled as a texture, you first need to copy from it to a regular framebuffer object using QOpenGLContext::blitFramebuffer().</source>
          <target state="translated">멀티 샘플링을 텍스처로 사용하도록 설정 한 프레임 버퍼 객체를 사용하려면 먼저 QOpenGLContext :: blitFramebuffer ()를 사용하여 일반 프레임 버퍼 객체로 복사해야합니다.</target>
        </trans-unit>
        <trans-unit id="75c598917b455b9d08c43e1b09257e52ee5de965" translate="yes" xml:space="preserve">
          <source>If you want to use a map function that takes more than one argument you can use a lambda function or &lt;code&gt;std::bind()&lt;/code&gt; to transform it onto a function that takes one argument.</source>
          <target state="translated">둘 이상의 인수를 사용하는 맵 함수를 사용하려면 lambda 함수 또는 &lt;code&gt;std::bind()&lt;/code&gt; 를 사용하여 하나의 인수를 취하는 함수로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf14b20ed394796f34b2a1defe39edffcae66ee0" translate="yes" xml:space="preserve">
          <source>If you want to use controls in your server in web-pages you need to make the server available to the browser used to view your page, and you need to specify the location of the server package in your page.</source>
          <target state="translated">웹 페이지에서 서버의 컨트롤을 사용하려면 페이지를 보는 데 사용되는 브라우저에서 서버를 사용할 수 있어야하고 페이지에서 서버 패키지의 위치를 ​​지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="0b59a35e51c3e470c7228aef4894f32e97ca9378" translate="yes" xml:space="preserve">
          <source>If you want to use multiple filters, separate each one with</source>
          <target state="translated">여러 필터를 사용하려면 각 필터를</target>
        </trans-unit>
        <trans-unit id="67acd904a6cfb20bf5d4ec9de62718a79958a636" translate="yes" xml:space="preserve">
          <source>If you want to use other QDoc commands within an argument that contains spaces, you always need to enclose the argument in braces. But QDoc is smart enough to count parentheses [3], so you don't need braces in cases like this:</source>
          <target state="translated">공백이 포함 된 인수에서 다른 QDoc 명령을 사용하려면 항상 인수를 중괄호로 묶어야합니다. 그러나 QDoc은 괄호를 세는 데 충분히 똑똑합니다 [3]. 다음과 같은 경우에는 중괄호가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e304f4d162cdd6b91149941db5a4861ae2782588" translate="yes" xml:space="preserve">
          <source>If you want to use other types as the key, make sure that you provide operator==() and a &lt;a href=&quot;qhash#qHashx&quot;&gt;qHash&lt;/a&gt;() implementation.</source>
          <target state="translated">다른 유형을 키로 사용하려면 operator == () 및 &lt;a href=&quot;qhash#qHashx&quot;&gt;qHash&lt;/a&gt; () 구현 을 제공해야합니다 .</target>
        </trans-unit>
        <trans-unit id="3f6c5acd529fc7e81ee3f63f1eabc430a55977a4" translate="yes" xml:space="preserve">
          <source>If you want to use some dynamic libraries in the macOS application bundle (the application directory), create a subdirectory named</source>
          <target state="translated">macOS 응용 프로그램 번들 (응용 프로그램 디렉토리)에서 일부 동적 라이브러리를 사용하려면 이름이 지정된 하위 디렉토리를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="5e38a66accf5331c873d39eb454d16cdef463f6e" translate="yes" xml:space="preserve">
          <source>If you want to wake up a specific thread, the solution is typically to use different wait conditions and have different threads wait on different conditions.</source>
          <target state="translated">특정 스레드를 깨우려면 솔루션은 일반적으로 다른 대기 조건을 사용하고 다른 스레드가 다른 조건에서 대기하도록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e9846382b615d7c2d8abab6b96cbfaebf6b28668" translate="yes" xml:space="preserve">
          <source>If you want to write portably, you can use individual rules of the following form:</source>
          <target state="translated">이식 가능하게 작성하려면 다음 형식의 개별 규칙을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1067ba1a8e8e88de78541f6de042b3358633a518" translate="yes" xml:space="preserve">
          <source>If you want your application to report errors to the user or to perform customized error handling, you should subclass this class.</source>
          <target state="translated">응용 프로그램이 사용자에게 오류를보고하거나 사용자 정의 된 오류 처리를 수행하려면이 클래스를 서브 클래 싱해야합니다.</target>
        </trans-unit>
        <trans-unit id="4b269b734135e0af61e1e0e9f959a070ded81c32" translate="yes" xml:space="preserve">
          <source>If you wish to build the OCI plugin manually with this method, the procedure looks like this:</source>
          <target state="translated">이 방법으로 OCI 플러그인을 수동으로 빌드하려는 경우 절차는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a81b48ae699cf322716c07ff38971ce61e6d019e" translate="yes" xml:space="preserve">
          <source>If you wish to change any of the bounding rectangles calculated by the style or the painting of check box indicators, you can subclass &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt;. Note, however, that the size of the items can also be affected by reimplementing &lt;a href=&quot;qstyleditemdelegate#sizeHint&quot;&gt;sizeHint&lt;/a&gt;().</source>
          <target state="translated">스타일 또는 확인란 표시기 그림으로 계산 된 경계 사각형을 변경하려는 경우 &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt; 을 서브 클래스 화할 수 있습니다 . 그러나 &lt;a href=&quot;qstyleditemdelegate#sizeHint&quot;&gt;sizeHint&lt;/a&gt; () 를 다시 구현하면 항목 크기도 영향을받을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="243c44ef42200392a025ddde85473dedd9e40e54" translate="yes" xml:space="preserve">
          <source>If you wish to create an object without setting a parent, specify &lt;code&gt;null&lt;/code&gt; for the</source>
          <target state="translated">당신이 부모를 설정하지 않고 객체를 생성하고자하는 경우, 지정 &lt;code&gt;null&lt;/code&gt; 를 들어</target>
        </trans-unit>
        <trans-unit id="7fb97e146e5862a6a33947d92bf8771517ccdc13" translate="yes" xml:space="preserve">
          <source>If you wish to customize the painting of item views, you should implement a custom style. Please see the &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt; class documentation for details.</source>
          <target state="translated">항목보기의 그림을 사용자 정의하려면 사용자 정의 스타일을 구현해야합니다. 자세한 내용은 &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt; 클래스 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0a69ca08ab96c13641a6508b794546aec257c0fa" translate="yes" xml:space="preserve">
          <source>If you wish to declare a property to store a list of values which are not necessarily QML object-type values, you should declare a &lt;a href=&quot;qml-var&quot;&gt;var&lt;/a&gt; property instead.</source>
          <target state="translated">반드시 QML 오브젝트 유형 값이 아닌 값 목록을 저장하도록 특성을 선언하려면 대신 &lt;a href=&quot;qml-var&quot;&gt;var&lt;/a&gt; 특성을 선언해야 합니다.</target>
        </trans-unit>
        <trans-unit id="a29175bb9c1cb3bbb036059c5f8bb1434c22ddb9" translate="yes" xml:space="preserve">
          <source>If you wish to have a command-line tool that does not use the GUI for example, &lt;code&gt;moc&lt;/code&gt;, &lt;code&gt;uic&lt;/code&gt; or &lt;code&gt;ls&lt;/code&gt;, you can tell qmake to disable bundle creation from the &lt;code&gt;CONFIG&lt;/code&gt; variable in the project file:</source>
          <target state="translated">GUI를 사용하지 않는 명령 줄 도구 ( &lt;code&gt;moc&lt;/code&gt; , &lt;code&gt;uic&lt;/code&gt; 또는 &lt;code&gt;ls&lt;/code&gt; )를 원한다면 qmake에게 프로젝트 파일 의 &lt;code&gt;CONFIG&lt;/code&gt; 변수에서 번들 생성을 비활성화하도록 지시 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e0b38ff477d19d2ca774b839b6974e90def6b73c" translate="yes" xml:space="preserve">
          <source>If you wish to introduce a delay between animations in a &lt;a href=&quot;qsequentialanimationgroup&quot;&gt;QSequentialAnimationGroup&lt;/a&gt;, you can insert a &lt;a href=&quot;qpauseanimation&quot;&gt;QPauseAnimation&lt;/a&gt;. This class does not animate anything, but does not &lt;a href=&quot;qabstractanimation#finished&quot;&gt;finish&lt;/a&gt; before a specified number of milliseconds have elapsed from when it was started. You specify the duration of the pause in the constructor. It can also be set directly with &lt;a href=&quot;qpauseanimation#duration-prop&quot;&gt;setDuration&lt;/a&gt;().</source>
          <target state="translated">당신이에 애니메이션 사이에 지연을 소개하고자하는 경우 &lt;a href=&quot;qsequentialanimationgroup&quot;&gt;QSequentialAnimationGroup&lt;/a&gt; , 당신은 삽입 할 수 있습니다 &lt;a href=&quot;qpauseanimation&quot;&gt;QPauseAnimation을&lt;/a&gt; . 이 클래스는 아무 것도 애니메이션하지 않지만 지정된 밀리 초가 시작된 후 경과하기 전에 &lt;a href=&quot;qabstractanimation#finished&quot;&gt;완료&lt;/a&gt; 되지 않습니다 . 생성자에서 일시 중지 기간을 지정합니다. &lt;a href=&quot;qpauseanimation#duration-prop&quot;&gt;setDuration&lt;/a&gt; ()으로 직접 설정할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="159d5838bcccb58b7af4b96b38caaf465a1b9c5d" translate="yes" xml:space="preserve">
          <source>If you wish to load an entire scene made of several objects, you should rather use the &lt;a href=&quot;qt3drender-qsceneloader&quot;&gt;Qt3DRender::QSceneLoader&lt;/a&gt; instead.</source>
          <target state="translated">여러 오브젝트로 구성된 전체 장면을로드하려면 대신 &lt;a href=&quot;qt3drender-qsceneloader&quot;&gt;Qt3DRender :: QSceneLoader를 사용해야&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="f84b7b6c5d543e62d3e7e0f79484d8066e3531f3" translate="yes" xml:space="preserve">
          <source>If you wish to make the context current in order to do clean-up, make sure to only connect to the signal using a direct connection.</source>
          <target state="translated">정리를 위해 컨텍스트를 현재 상태로 만들려면 직접 연결을 통해서만 신호에 연결해야합니다.</target>
        </trans-unit>
        <trans-unit id="e21582ab084164eddf1b291820920631b9959c06" translate="yes" xml:space="preserve">
          <source>If you wish to remove elements from a sequence rather than simply replace them with default constructed values, do not use the indexed delete operator (&quot;delete sequence[i]&quot;) but instead use the &lt;code&gt;splice&lt;/code&gt; function (&quot;sequence.splice(startIndex, deleteCount)&quot;).</source>
          <target state="translated">시퀀스에서 요소를 기본 생성 값으로 바꾸는 대신 시퀀스에서 요소를 제거하려면 색인화 된 삭제 연산자 ( &quot;delete sequence [i]&quot;)를 사용하지 말고 대신 &lt;code&gt;splice&lt;/code&gt; 함수 ( &quot;sequence.splice (startIndex, deleteCount)를 사용하십시오. ) &quot;).</target>
        </trans-unit>
        <trans-unit id="0b4e499bc4c5986671c6ef5dbd86bfbbc1b58f7e" translate="yes" xml:space="preserve">
          <source>If you wish to reset the decoded format to that of the original audio file, you can specify an invalid</source>
          <target state="translated">디코딩 된 형식을 원본 오디오 파일의 형식으로 재설정하려는 경우 잘못된 형식을 지정할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="815e2bd5cf4e2b9061fda121d653346b3e929a30" translate="yes" xml:space="preserve">
          <source>If you wish to take advantage of the features provided by the model/view approach while still using an item-based interface, consider using view classes, such as &lt;a href=&quot;qlistview&quot;&gt;QListView&lt;/a&gt;, &lt;a href=&quot;qtableview&quot;&gt;QTableView&lt;/a&gt;, and &lt;a href=&quot;qtreeview&quot;&gt;QTreeView&lt;/a&gt; with &lt;a href=&quot;qstandarditemmodel&quot;&gt;QStandardItemModel&lt;/a&gt;.</source>
          <target state="translated">당신은 여전히 같은 뷰 클래스, 사용을 고려 항목 기반 인터페이스를 사용하는 동안 모델 / 뷰 방식에 의해 제공되는 기능을 활용하고자하는 경우 &lt;a href=&quot;qlistview&quot;&gt;QListView&lt;/a&gt; , &lt;a href=&quot;qtableview&quot;&gt;QTableView&lt;/a&gt; 및 &lt;a href=&quot;qtreeview&quot;&gt;QTreeView&lt;/a&gt; 와 &lt;a href=&quot;qstandarditemmodel&quot;&gt;QStandardItemModel을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8e1f06dfa8cd5f427a710f53d1541f65623bd15f" translate="yes" xml:space="preserve">
          <source>If you would like the application's contents to stay where they are when the drawer is opened, don't apply a translation.</source>
          <target state="translated">서랍을 열 때 응용 프로그램의 내용이 그대로 유지되도록하려면 번역을 적용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="d913c5bfa651c86cfe9561db0fdfbd7bd0d1157f" translate="yes" xml:space="preserve">
          <source>If you would like to draw your own window decoration, you can set your own frame margins to override the default margins.</source>
          <target state="translated">자신 만의 창 장식을 그리려면 기본 여백을 재정의하도록 자체 프레임 여백을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d1e57f6a403b9d00ba20ede07640d663f94d9bb2" translate="yes" xml:space="preserve">
          <source>If you would prefer that the font and palette propagate to child widgets, you can set the &lt;a href=&quot;qt#ApplicationAttribute-enum&quot;&gt;Qt::AA_UseStyleSheetPropagationInWidgetStyles&lt;/a&gt; flag, like this:</source>
          <target state="translated">글꼴 및 팔레트가 하위 위젯으로 전파되도록하려면 다음과 같이 &lt;a href=&quot;qt#ApplicationAttribute-enum&quot;&gt;Qt :: AA_UseStyleSheetPropagationInWidgetStyles&lt;/a&gt; 플래그를 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="972ddea2508fd6833d6df718ba7d1b3bad696c8f" translate="yes" xml:space="preserve">
          <source>If you write your own widgets that have an option to set a small pixmap, consider allowing a &lt;a href=&quot;qicon&quot;&gt;QIcon&lt;/a&gt; to be set for that pixmap. The Qt class &lt;a href=&quot;qtoolbutton&quot;&gt;QToolButton&lt;/a&gt; is an example of such a widget.</source>
          <target state="translated">작은 픽스맵을 설정하는 옵션이있는 자체 위젯을 작성하는 경우 해당 픽스맵에 &lt;a href=&quot;qicon&quot;&gt;QIcon&lt;/a&gt; 을 설정 하도록 고려하십시오 . Qt 클래스 &lt;a href=&quot;qtoolbutton&quot;&gt;QToolButton&lt;/a&gt; 은 이러한 위젯의 예입니다.</target>
        </trans-unit>
        <trans-unit id="daabc7cf04dec890de4a59eed0e93f81b14b18c1" translate="yes" xml:space="preserve">
          <source>If you're developing on a 64-bit Linux machine, you must install the following dependencies in order to run 32-bit executables like &lt;code&gt;adb&lt;/code&gt;, which allows Qt Creator to find devices to deploy to:</source>
          <target state="translated">64 비트 Linux 시스템에서 개발중인 경우 &lt;code&gt;adb&lt;/code&gt; 와 같은 32 비트 실행 파일을 실행하려면 Qt Creator가 배포 할 장치를 찾을 수 있도록 다음 종속성을 설치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="7291b8f5e7b74175825eec8a86f93115af0aa7c0" translate="yes" xml:space="preserve">
          <source>If you're using the same application (.so file) for activity and also for service, you need to use &lt;code&gt;android.app.arguments&lt;/code&gt;&lt;code&gt;meta-data&lt;/code&gt; to pass some arguments to your &lt;code&gt;main&lt;/code&gt; function in order to know which one is which.</source>
          <target state="translated">활동과 서비스에 동일한 응용 프로그램 (.so 파일)을 사용하는 경우 &lt;code&gt;android.app.arguments&lt;/code&gt; &lt;code&gt;meta-data&lt;/code&gt; 를 사용 하여 어떤 인수 가 어떤 것인지 알기 위해 일부 인수를 &lt;code&gt;main&lt;/code&gt; 함수에 전달해야합니다 .</target>
        </trans-unit>
        <trans-unit id="eb4e00a828abcf6435bc775c3c853cc29a3dfb89" translate="yes" xml:space="preserve">
          <source>If you're worried about namespace pollution, you can disable these macros by adding the following line to your &lt;code&gt;.pro&lt;/code&gt; file:</source>
          <target state="translated">네임 스페이스 오염이 걱정되면 &lt;code&gt;.pro&lt;/code&gt; 파일에 다음 줄을 추가하여 이러한 매크로를 비활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6f24a1eec5e9c1e1ce83961a3e75273b1d21ddc2" translate="yes" xml:space="preserve">
          <source>If you're worried about namespace pollution, you can disable this macro by adding the following line to your &lt;code&gt;.pro&lt;/code&gt; file:</source>
          <target state="translated">네임 스페이스 오염이 걱정된다면 &lt;code&gt;.pro&lt;/code&gt; 파일에 다음 줄을 추가하여이 매크로를 비활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d0b10c56ece24e57b4de992cfac85be3d5c33c4a" translate="yes" xml:space="preserve">
          <source>If your &lt;code&gt;Info.plist&lt;/code&gt; file contains an entry for &lt;code&gt;NSPhotoLibraryUsageDescription&lt;/code&gt;, qmake will automatically include an extra plugin which enables access to the native image picker. If the directory in your &lt;a href=&quot;qfiledialog&quot;&gt;QFileDialog&lt;/a&gt; is set to:</source>
          <target state="translated">귀하의 경우 &lt;code&gt;Info.plist&lt;/code&gt; 파일에 대한 항목이 포함되어 &lt;code&gt;NSPhotoLibraryUsageDescription&lt;/code&gt; 을 , qmake를 네이티브 이미지 선택 도구에 액세스 할 수 있습니다 별도의 플러그인을 자동으로 포함됩니다. &lt;a href=&quot;qfiledialog&quot;&gt;QFileDialog&lt;/a&gt; 의 디렉토리 가 다음과 같이 설정된 경우 :</target>
        </trans-unit>
        <trans-unit id="612fb54a1db4926e1242c0e5627f6593e80562a3" translate="yes" xml:space="preserve">
          <source>If your Item uses the &lt;a href=&quot;qml-qtquick-behavior&quot;&gt;Behavior&lt;/a&gt; type to define animations for property changes, you should always use either &lt;a href=&quot;qobject#setProperty&quot;&gt;QObject::setProperty&lt;/a&gt;(), QQmlProperty(), or &lt;a href=&quot;qmetaproperty#write&quot;&gt;QMetaProperty::write&lt;/a&gt;() when you need to modify those properties from C++. This ensures that the QML engine knows about the property change. Otherwise, the engine won't be able to carry out your requested animation. Note that these functions incur a slight performance penalty. For more details, see &lt;a href=&quot;qtqml-cppintegration-interactqmlfromcpp#accessing-members-of-a-qml-object-type-from-c&quot;&gt;Accessing Members of a QML Object Type from C++&lt;/a&gt;.</source>
          <target state="translated">항목이 &lt;a href=&quot;qml-qtquick-behavior&quot;&gt;동작&lt;/a&gt; 유형을 사용하여 속성 변경에 대한 애니메이션을 정의하는 경우 C ++에서 해당 속성을 수정해야 할 때는 항상 &lt;a href=&quot;qobject#setProperty&quot;&gt;QObject :: setProperty&lt;/a&gt; (), QQmlProperty () 또는 &lt;a href=&quot;qmetaproperty#write&quot;&gt;QMetaProperty :: write&lt;/a&gt; ()를 사용해야합니다. 이를 통해 QML 엔진이 특성 변경에 대해 알 수 있습니다. 그렇지 않으면 엔진이 요청한 애니메이션을 수행 할 수 없습니다. 이러한 기능은 약간의 성능 저하를 초래합니다. 자세한 내용 &lt;a href=&quot;qtqml-cppintegration-interactqmlfromcpp#accessing-members-of-a-qml-object-type-from-c&quot;&gt;은 C ++에서 QML 객체 유형의 멤버 액세스를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="de85f7adb720be31015d2f53bdbdc47e962a6d98" translate="yes" xml:space="preserve">
          <source>If your OpenGL implementation supports the GL_EXT_texture_filter_anisotropic extension this function sets the maximum anisotropy level to</source>
          <target state="translated">OpenGL 구현이 GL_EXT_texture_filter_anisotropic 확장을 지원하는 경우이 함수는 최대 이방성 레벨을</target>
        </trans-unit>
        <trans-unit id="e2646f4e473d40bdf4424a95af63654825817e99" translate="yes" xml:space="preserve">
          <source>If your QML type is defined in a</source>
          <target state="translated">QML 유형이</target>
        </trans-unit>
        <trans-unit id="f689dbad9e71c2662095aa7b027ce2241d810411" translate="yes" xml:space="preserve">
          <source>If your XQuery can return atomic value items of type &lt;code&gt;xs:QName&lt;/code&gt;, they will appear in your &lt;a href=&quot;qxmlresultitems&quot;&gt;QXmlResultItems&lt;/a&gt; as instances of &lt;a href=&quot;qxmlname&quot;&gt;QXmlName&lt;/a&gt;. Since the &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; class does not support the &lt;a href=&quot;qxmlname&quot;&gt;QXmlName&lt;/a&gt; class directly, extracting them from &lt;a href=&quot;qxmlresultitems&quot;&gt;QXmlResultItems&lt;/a&gt; requires a bit of slight-of-hand using the &lt;a href=&quot;qmetatype&quot;&gt;Qt metatype system&lt;/a&gt;. We must modify our example to use a couple of template functions, a friend of &lt;a href=&quot;qmetatype&quot;&gt;QMetaType&lt;/a&gt; (&lt;a href=&quot;qmetatype#qMetaTypeId&quot;&gt;qMetaTypeId&lt;/a&gt;&amp;lt;T&amp;gt;()) and a friend of &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; (&lt;a href=&quot;qvariant#qvariant_cast&quot;&gt;qvariant_cast&lt;/a&gt;&amp;lt;T&amp;gt;()):</source>
          <target state="translated">귀하는 XQuery는 유형의 원자 값 항목을 반환 할 수있는 경우 &lt;code&gt;xs:QName&lt;/code&gt; , 그들은 당신에 나타납니다 &lt;a href=&quot;qxmlresultitems&quot;&gt;QXmlResultItems&lt;/a&gt; 의 인스턴스로 &lt;a href=&quot;qxmlname&quot;&gt;QXmlName&lt;/a&gt; . 이후 &lt;a href=&quot;qvariant&quot;&gt;QVariant의&lt;/a&gt; 클래스는 지원하지 않습니다 &lt;a href=&quot;qxmlname&quot;&gt;QXmlName의&lt;/a&gt; 에서 그들을 추출, 직접 클래스를 &lt;a href=&quot;qxmlresultitems&quot;&gt;QXmlResultItems 것은&lt;/a&gt; 약간의-의 손이 사용하는 비트가 필요 &lt;a href=&quot;qmetatype&quot;&gt;Qt는 메타 타입 시스템을&lt;/a&gt; . 우리는 템플릿 함수의 커플의 친구가 사용하는 예제를 수정해야합니다 &lt;a href=&quot;qmetatype&quot;&gt;QMetaType&lt;/a&gt; ( &lt;a href=&quot;qmetatype#qMetaTypeId&quot;&gt;qMetaTypeId&lt;/a&gt; &amp;lt;T&amp;gt; ())과의 친구 &lt;a href=&quot;qvariant&quot;&gt;QVariant을&lt;/a&gt; ( &lt;a href=&quot;qvariant#qvariant_cast&quot;&gt;qvariant_cast&lt;/a&gt; &amp;lt;T&amp;gt; ()) :</target>
        </trans-unit>
        <trans-unit id="c33b6b405c4832e4a47175cade4878c811a12def" translate="yes" xml:space="preserve">
          <source>If your application consists of multiple views (for example, multiple tabs) but only one is required at any one time, you can use lazy instantiation to minimize the amount of memory you need to have allocated at any given time. See the prior section on &lt;a href=&quot;#lazy-initialization&quot;&gt;Lazy Initialization&lt;/a&gt; for more information.</source>
          <target state="translated">애플리케이션이 여러보기 (예 : 여러 탭)로 구성되어 있지만 한 번에 하나만 필요한 경우 지연 인스턴스화를 사용하여 주어진 시간에 할당해야하는 메모리 양을 최소화 할 수 있습니다. 자세한 내용은 &lt;a href=&quot;#lazy-initialization&quot;&gt;지연 초기화에&lt;/a&gt; 대한 이전 섹션 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f6f5700ed93aaf0ac491f9cb45ab94a73d11e831" translate="yes" xml:space="preserve">
          <source>If your application has unlockable products, and does not store the purchase states of these products in a way which makes it possible to restore them when the user reinstalls the application, you should provide a way for the user to restore the purchases manually.</source>
          <target state="translated">응용 프로그램에 잠금 해제 가능한 제품이 있고 사용자가 응용 프로그램을 다시 설치할 때 제품을 복원 할 수있는 방식으로 이러한 제품의 구매 상태를 저장하지 않은 경우 사용자가 수동으로 구매를 복원 할 수있는 방법을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="d0175517087d7f87f877b49ec96ed43e9993e54b" translate="yes" xml:space="preserve">
          <source>If your application is very simple, it may be possible to store the entire application state in additional command line options. This is usually a very bad idea because command lines are often limited to a few hundred bytes. Instead, use &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt;, temporary files, or a database for this purpose. By marking the data with the unique &lt;a href=&quot;qsessionmanager#sessionId&quot;&gt;sessionId&lt;/a&gt;(), you will be able to restore the application in a future session.</source>
          <target state="translated">응용 프로그램이 매우 간단한 경우 추가 응용 프로그램 상태를 추가 명령 줄 옵션에 저장할 수 있습니다. 명령 행이 종종 수백 바이트로 제한되기 때문에 이것은 일반적으로 매우 나쁜 생각입니다. 대신 이 목적으로 &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; , 임시 파일 또는 데이터베이스를 사용하십시오. 고유 한 &lt;a href=&quot;qsessionmanager#sessionId&quot;&gt;sessionId&lt;/a&gt; ()로 데이터를 표시하면 향후 세션에서 응용 프로그램을 복원 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="00f996db434fbd4148cd3d64abf4c29be1ff38af" translate="yes" xml:space="preserve">
          <source>If your application loads a large image but displays it in a small-sized element, set the &quot;sourceSize&quot; property to the size of the element being rendered to ensure that the smaller-scaled version of the image is kept in memory, rather than the large one.</source>
          <target state="translated">응용 프로그램이 큰 이미지를로드하지만 작은 크기의 요소로 표시하는 경우 &quot;sourceSize&quot;속성을 렌더링 할 요소의 크기로 설정하여 이미지의 작은 크기 버전이 메모리의 크기보다 작은 크기로 유지되도록합니다. 큰 것.</target>
        </trans-unit>
        <trans-unit id="86f9b3e44da0ce922b11cc124e5a293028e87f8f" translate="yes" xml:space="preserve">
          <source>If your backend has already allocated a reading you should pass the address of this to the function. Otherwise you should pass 0 and the function will return the address of the reading your backend should use when it wants to notify the sensor API of new readings.</source>
          <target state="translated">백엔드가 이미 판독 값을 할당 한 경우이 주소를 함수에 전달해야합니다. 그렇지 않으면 0을 전달하면이 함수는 센서 API에 새로운 판독 값을 알리고 자 할 때 백엔드가 사용해야하는 판독 값의 주소를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8dad3ce2a056ce4e9de595ce577839ebdd7b32d3" translate="yes" xml:space="preserve">
          <source>If your compiler supports the C++11 standard, the three &lt;a href=&quot;qcommandlineparser#addOption&quot;&gt;addOption&lt;/a&gt;() calls in the above example can be simplified:</source>
          <target state="translated">컴파일러가 C ++ 11 표준을 지원하는 경우 위 예제에서 세 가지 &lt;a href=&quot;qcommandlineparser#addOption&quot;&gt;addOption&lt;/a&gt; () 호출을 단순화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c66f3be6bd529839255d9695af3e672dce04dbbb" translate="yes" xml:space="preserve">
          <source>If your effect changes, use &lt;a href=&quot;qgraphicseffect#update&quot;&gt;update&lt;/a&gt;() to request for a redraw. If your custom effect changes the bounding rectangle of the source, e.g., a radial glow effect may need to apply an extra margin, you can reimplement the virtual &lt;a href=&quot;qgraphicseffect#boundingRectFor&quot;&gt;boundingRectFor&lt;/a&gt;() function, and call &lt;a href=&quot;qgraphicseffect#updateBoundingRect&quot;&gt;updateBoundingRect&lt;/a&gt;() to notify the framework whenever this rectangle changes. The virtual &lt;a href=&quot;qgraphicseffect#sourceChanged&quot;&gt;sourceChanged&lt;/a&gt;() function is called to notify the effects that the source has changed in some way - e.g., if the source is a &lt;a href=&quot;qgraphicsrectitem&quot;&gt;QGraphicsRectItem&lt;/a&gt; and its rectangle parameters have changed.</source>
          <target state="translated">효과가 변경되면 &lt;a href=&quot;qgraphicseffect#update&quot;&gt;update&lt;/a&gt; ()를 사용 하여 다시 그리기를 요청하십시오. 사용자 지정 효과가 소스의 경계 사각형을 변경하는 경우 (예 : 방사형 광선 효과에 추가 여백을 적용해야 할 경우 ) virtual &lt;a href=&quot;qgraphicseffect#boundingRectFor&quot;&gt;boundingRectFor&lt;/a&gt; () 함수를 다시 구현 하고이 사각형이 변경 될 때마다 프레임 워크에 알리기 위해 &lt;a href=&quot;qgraphicseffect#updateBoundingRect&quot;&gt;updateBoundingRect&lt;/a&gt; ()를 호출 할 수 있습니다 . virtual &lt;a href=&quot;qgraphicseffect#sourceChanged&quot;&gt;sourceChanged&lt;/a&gt; () 함수는 소스가 &lt;a href=&quot;qgraphicsrectitem&quot;&gt;QGraphicsRectItem&lt;/a&gt; 이고 사각형 매개 변수가 변경된 경우와 같이 소스가 어떤 방식으로 변경되었는지를 알리기 위해 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="8e482e3ad7cd2848c95b1c63b9a6a5f87d71a074" translate="yes" xml:space="preserve">
          <source>If your goal is orthogonal surveillance of eventpoints, an older alternative was &lt;a href=&quot;qobject#installEventFilter&quot;&gt;QObject::installEventFilter()&lt;/a&gt;, but that has never been a built-in &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtquick-module.html&quot;&gt;QtQuick&lt;/a&gt; feature: it requires some C++ code, such as a &lt;a href=&quot;qquickitem&quot;&gt;QQuickItem&lt;/a&gt; subclass. &lt;a href=&quot;qml-qtquick-pointhandler&quot;&gt;PointHandler&lt;/a&gt; is more efficient than that, because only pointer events will be delivered to it, during the course of normal event delivery in &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt;; whereas an event filter needs to filter all QEvents of all types, and thus sets itself up as a potential event delivery bottleneck.</source>
          <target state="translated">목표가 이벤트 포인트의 직교 감시인 경우, 이전 대안은 &lt;a href=&quot;qobject#installEventFilter&quot;&gt;QObject :: installEventFilter ()&lt;/a&gt; 였지만 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtquick-module.html&quot;&gt;QtQuick&lt;/a&gt; 기능 은 내장되지 않았습니다 . &lt;a href=&quot;qquickitem&quot;&gt;QQuickItem&lt;/a&gt; 서브 클래스 와 같은 일부 C ++ 코드가 필요합니다 . &lt;a href=&quot;qml-qtquick-pointhandler&quot;&gt;PointHandler은&lt;/a&gt; 단지 포인터 이벤트는 정상 이벤트 전달의 과정 동안, 그것을 전달되기 때문에,보다 더 효율적입니다 &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt; ; 반면 이벤트 필터는 모든 유형의 모든 QEvent를 필터링해야하므로 잠재적 이벤트 전달 병목 현상으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="b6f54b2f4fa96edac6ea810d92d44a2ecacd96aa" translate="yes" xml:space="preserve">
          <source>If your item is displayed in several areas then visualRect should return the primary area that contains index and not the complete area that index might encompasses, touch or cause drawing.</source>
          <target state="translated">항목이 여러 영역에 표시되면 visualRect는 인덱스가 포함 된 전체 영역이 아닌 인덱스가 포함 된 기본 영역을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="72c337b2451ed3b8885c5abc8d5400ec57e41dc3" translate="yes" xml:space="preserve">
          <source>If your model is sortable, i.e, if it reimplements the &lt;a href=&quot;qabstractitemmodel#sort&quot;&gt;QAbstractItemModel::sort&lt;/a&gt;() function, both &lt;a href=&quot;qtableview&quot;&gt;QTableView&lt;/a&gt; and &lt;a href=&quot;qtreeview&quot;&gt;QTreeView&lt;/a&gt; provide an API that allows you to sort your model data programmatically. In addition, you can enable interactive sorting (i.e. allowing the users to sort the data by clicking the view's headers), by connecting the &lt;a href=&quot;qheaderview#sortIndicatorChanged&quot;&gt;QHeaderView::sortIndicatorChanged&lt;/a&gt;() signal to the &lt;a href=&quot;qtableview#sortByColumn&quot;&gt;QTableView::sortByColumn&lt;/a&gt;() slot or the &lt;a href=&quot;qtreeview#sortByColumn&quot;&gt;QTreeView::sortByColumn&lt;/a&gt;() slot, respectively.</source>
          <target state="translated">모델이 정렬 가능한 경우, 즉 &lt;a href=&quot;qabstractitemmodel#sort&quot;&gt;QAbstractItemModel :: sort&lt;/a&gt; () 함수를 다시 구현하는 경우 &lt;a href=&quot;qtableview&quot;&gt;QTableView&lt;/a&gt; 와 &lt;a href=&quot;qtreeview&quot;&gt;QTreeView&lt;/a&gt; 는 모두 모델 데이터를 프로그래밍 방식으로 정렬 할 수있는 API를 제공합니다. 또한 &lt;a href=&quot;qheaderview#sortIndicatorChanged&quot;&gt;QHeaderView :: sortIndicatorChanged&lt;/a&gt; () 신호를 &lt;a href=&quot;qtableview#sortByColumn&quot;&gt;QTableView :: sortByColumn&lt;/a&gt; () 슬롯에 연결하거나 &lt;a href=&quot;qtreeview#sortByColumn&quot;&gt;QTreeView :: sortByColumn&lt;/a&gt; ( ) 슬롯.</target>
        </trans-unit>
        <trans-unit id="6f98e8b5d221b3e2e8a7a394a8d830a40068ddc9" translate="yes" xml:space="preserve">
          <source>If your model is used within QML and requires roles other than the default ones provided by the &lt;a href=&quot;qabstractitemmodel#roleNames&quot;&gt;roleNames&lt;/a&gt;() function, you must override it.</source>
          <target state="translated">QML 내에서 모델을 사용하고 &lt;a href=&quot;qabstractitemmodel#roleNames&quot;&gt;roleNames&lt;/a&gt; () 함수에서 제공하는 기본 역할 이외의 역할 이 필요한 경우이를 대체해야합니다.</target>
        </trans-unit>
        <trans-unit id="c32e9f4943a6c23b62d891ccf355dae1b1293bb3" translate="yes" xml:space="preserve">
          <source>If your project has custom CMake build configurations, it may be necessary to set a mapping from your custom configuration to either the debug or release Qt configuration.</source>
          <target state="translated">프로젝트에 사용자 정의 CMake 빌드 구성이있는 경우 사용자 정의 구성에서 디버그 또는 릴리스 Qt 구성으로의 맵핑을 설정해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a412b7fbd30159b9499635e4236b0aa30262e5ff" translate="yes" xml:space="preserve">
          <source>If your project is a</source>
          <target state="translated">프로젝트가</target>
        </trans-unit>
        <trans-unit id="45ce7ce9273e622183118d4a8028a97f4b77a7d5" translate="yes" xml:space="preserve">
          <source>If your reimplementation of &lt;a href=&quot;qabstractitemmodel#fetchMore&quot;&gt;fetchMore()&lt;/a&gt; adds rows to the model, you need to call &lt;a href=&quot;qabstractitemmodel#beginInsertRows&quot;&gt;beginInsertRows()&lt;/a&gt; and &lt;a href=&quot;qabstractitemmodel#endInsertRows&quot;&gt;endInsertRows()&lt;/a&gt;. Also, both &lt;a href=&quot;qabstractitemmodel#canFetchMore&quot;&gt;canFetchMore()&lt;/a&gt; and &lt;a href=&quot;qabstractitemmodel#fetchMore&quot;&gt;fetchMore()&lt;/a&gt; must be reimplemented as their default implementation returns false and does nothing.</source>
          <target state="translated">&lt;a href=&quot;qabstractitemmodel#fetchMore&quot;&gt;fetchMore ()를&lt;/a&gt; 다시 구현 하면 모델에 행이 추가되면 &lt;a href=&quot;qabstractitemmodel#beginInsertRows&quot;&gt;beginInsertRows ()&lt;/a&gt; 및 &lt;a href=&quot;qabstractitemmodel#endInsertRows&quot;&gt;endInsertRows ()&lt;/a&gt; 를 호출해야합니다 . 또한 기본 구현이 false를 반환하고 아무 것도 수행하지 &lt;a href=&quot;qabstractitemmodel#canFetchMore&quot;&gt;않으므로 canFetchMore ()&lt;/a&gt; 및 &lt;a href=&quot;qabstractitemmodel#fetchMore&quot;&gt;fetchMore ()&lt;/a&gt; 를 모두 다시 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="6058b6b4398293fb98ebb9b0df37b61e7de26d54" translate="yes" xml:space="preserve">
          <source>If your test case needs QML imports, then you can add them as &lt;code&gt;-import&lt;/code&gt; options to the test program command-line.</source>
          <target state="translated">테스트 케이스에 QML 가져 오기가 필요한 경우 테스트 프로그램 명령 행에 &lt;code&gt;-import&lt;/code&gt; 옵션으로 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="47af96af8e00c193855c890bc0707a860e54d143" translate="yes" xml:space="preserve">
          <source>If your widget only contains child widgets, you probably do not need to implement any event handlers. If you want to detect a mouse click in a child widget call the child's &lt;a href=&quot;qwidget#underMouse&quot;&gt;underMouse&lt;/a&gt;() function inside the widget's &lt;a href=&quot;qwidget#mousePressEvent&quot;&gt;mousePressEvent&lt;/a&gt;().</source>
          <target state="translated">위젯에 하위 위젯 만 포함 된 경우 이벤트 핸들러를 구현하지 않아도됩니다. 자식 위젯에서 마우스 클릭을 감지 하려면 위젯의 &lt;a href=&quot;qwidget#mousePressEvent&quot;&gt;mousePressEvent&lt;/a&gt; () 내에서 자식의 &lt;a href=&quot;qwidget#underMouse&quot;&gt;underMouse&lt;/a&gt; () 함수를 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="efb98d3c8757c13c00568dad7341a60498040025" translate="yes" xml:space="preserve">
          <source>If, at a later time, the replica's node gets notified that the requested source is available from a connected node, it will at that point request the source and start the initialization process.</source>
          <target state="translated">나중에 요청 된 소스가 연결된 노드에서 사용 가능하다는 사실을 복제본의 노드에 통지하면 해당 시점에 소스를 요청하고 초기화 프로세스를 시작합니다.</target>
        </trans-unit>
        <trans-unit id="fe7b1ce59b4e0aa5b6b2c140336559a9b5893b11" translate="yes" xml:space="preserve">
          <source>If, for example, the OpenGL polygon mode is changed by the user inside a beginNativePaint()/&lt;a href=&quot;qpainter#endNativePainting&quot;&gt;endNativePainting&lt;/a&gt;() block, it will not be reset to the default state by &lt;a href=&quot;qpainter#endNativePainting&quot;&gt;endNativePainting&lt;/a&gt;(). Here is an example that shows intermixing of painter commands and raw OpenGL commands:</source>
          <target state="translated">예를 들어, OpenGL을 다각형 모드는 beginNativePaint () / 내부 사용자에 의해 변경되고있는 경우 &lt;a href=&quot;qpainter#endNativePainting&quot;&gt;endNativePainting&lt;/a&gt; () 블록이함으로써 초기 상태로 리셋하지 않을 것이다 &lt;a href=&quot;qpainter#endNativePainting&quot;&gt;endNativePainting&lt;/a&gt; (). 다음은 painter 명령과 raw OpenGL 명령의 혼합을 보여주는 예입니다.</target>
        </trans-unit>
        <trans-unit id="f4b93ae87fadd21a13fe26a4b1b7229793967d06" translate="yes" xml:space="preserve">
          <source>If, for instance, you want to connect to a server that uses a self-signed certificate, consider the following snippet:</source>
          <target state="translated">예를 들어 자체 서명 된 인증서를 사용하는 서버에 연결하려면 다음 코드 조각을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="a21a10cc6baa8fc7709ded12402fb06e21bc2e8d" translate="yes" xml:space="preserve">
          <source>If, within the document's directory, there is a &lt;code&gt;dummydata&lt;/code&gt; directory which contains a &lt;code&gt;lottoNumbers.qml&lt;/code&gt; file like this:</source>
          <target state="translated">경우 문서의 디렉토리 내에서,이 &lt;code&gt;dummydata&lt;/code&gt; 포함 디렉토리 &lt;code&gt;lottoNumbers.qml&lt;/code&gt; 의 이 같은 파일 :</target>
        </trans-unit>
        <trans-unit id="deb76489f9b5200ca7f43df75295b472c27ddb2f" translate="yes" xml:space="preserve">
          <source>Ignore any Unicode byte-order mark and don't generate any.</source>
          <target state="translated">유니 코드 바이트 순서 표시를 무시하고 아무 것도 생성하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="8b89e0c0fc34677d43ff0d0ac2650038d7cee304" translate="yes" xml:space="preserve">
          <source>Ignore any implicit or explicit &lt;code&gt;-nograb&lt;/code&gt;. &lt;code&gt;-dograb&lt;/code&gt; wins over &lt;code&gt;-nograb&lt;/code&gt; even when &lt;code&gt;-nograb&lt;/code&gt; is last on the command line.</source>
          <target state="translated">암시 적 또는 명시 적 &lt;code&gt;-nograb&lt;/code&gt; 를 무시하십시오 . &lt;code&gt;-dograb&lt;/code&gt; 이상 승리 &lt;code&gt;-nograb&lt;/code&gt; 도 &lt;code&gt;-nograb&lt;/code&gt; 는 명령 줄에서 마지막.</target>
        </trans-unit>
        <trans-unit id="a2ff2565c03de3852a8466f2d4f2afb8bf1ceb3d" translate="yes" xml:space="preserve">
          <source>Ignore the action (do nothing with the data).</source>
          <target state="translated">조치를 무시하십시오 (데이터와 함께 수행하지 마십시오).</target>
        </trans-unit>
        <trans-unit id="f8d389bf9f10dd7ee0995def4b935f1728b59794" translate="yes" xml:space="preserve">
          <source>Ignore the layout item rect from the style when laying out this widget with &lt;a href=&quot;qlayout&quot;&gt;QLayout&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qlayout&quot;&gt;QLayout&lt;/a&gt; 으로이 위젯을 배치 할 때 스타일에서 레이아웃 항목을 수정하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="d6dc167c9331f258371c27b269795d215b36d8f6" translate="yes" xml:space="preserve">
          <source>Ignores a navigation request.</source>
          <target state="translated">탐색 요청을 무시합니다.</target>
        </trans-unit>
        <trans-unit id="3b5991af665588b7019909a6819ff7f96fea5b14" translate="yes" xml:space="preserve">
          <source>Ignores messages created by &lt;a href=&quot;#qDebug&quot;&gt;qDebug&lt;/a&gt;(), &lt;a href=&quot;#qInfo&quot;&gt;qInfo&lt;/a&gt;() or &lt;a href=&quot;#qWarning&quot;&gt;qWarning&lt;/a&gt;(). If the</source>
          <target state="translated">&lt;a href=&quot;#qDebug&quot;&gt;qDebug&lt;/a&gt; (), &lt;a href=&quot;#qInfo&quot;&gt;qInfo&lt;/a&gt; () 또는 &lt;a href=&quot;#qWarning&quot;&gt;qWarning&lt;/a&gt; ()으로 작성된 메시지를 무시합니다 . 만약</target>
        </trans-unit>
        <trans-unit id="9a4ab3fd8e773e1c5a4c036f3e06e781ad87d7e7" translate="yes" xml:space="preserve">
          <source>Ignores messages created by &lt;a href=&quot;#qDebug&quot;&gt;qDebug&lt;/a&gt;(), &lt;a href=&quot;#qInfo&quot;&gt;qInfo&lt;/a&gt;() or &lt;a href=&quot;#qWarning&quot;&gt;qWarning&lt;/a&gt;(). If the message matching</source>
          <target state="translated">&lt;a href=&quot;#qDebug&quot;&gt;qDebug&lt;/a&gt; (), &lt;a href=&quot;#qInfo&quot;&gt;qInfo&lt;/a&gt; () 또는 &lt;a href=&quot;#qWarning&quot;&gt;qWarning&lt;/a&gt; ()으로 작성된 메시지를 무시합니다 . 메시지가 일치하는 경우</target>
        </trans-unit>
        <trans-unit id="c7b42c5e8793c4e11f5b0d98e83629eed9b662e4" translate="yes" xml:space="preserve">
          <source>Illegal</source>
          <target state="translated">Illegal</target>
        </trans-unit>
        <trans-unit id="1ae48c552e312029e7dd471fc7df5778829c9500" translate="yes" xml:space="preserve">
          <source>Illustrator</source>
          <target state="translated">Illustrator</target>
        </trans-unit>
        <trans-unit id="50e19fda0d5b4b74a4a1a1d584e56578693a4ea4" translate="yes" xml:space="preserve">
          <source>Image</source>
          <target state="translated">Image</target>
        </trans-unit>
        <trans-unit id="694a7d34908dab879c97aaa1a20efc15273c8f9a" translate="yes" xml:space="preserve">
          <source>Image (QML type)</source>
          <target state="translated">이미지 (QML 유형)</target>
        </trans-unit>
        <trans-unit id="79437dd7e3b6791d059634682f61cbf70ef60de0" translate="yes" xml:space="preserve">
          <source>Image Caching</source>
          <target state="translated">이미지 캐싱</target>
        </trans-unit>
        <trans-unit id="435ed9e69df99cb4a2651c265421f92dd8dbdb74" translate="yes" xml:space="preserve">
          <source>Image Composition Example</source>
          <target state="translated">이미지 구성 예</target>
        </trans-unit>
        <trans-unit id="9c804e7e28cc6e5f7931d50ba6b994cd4bb2c59f" translate="yes" xml:space="preserve">
          <source>Image Elements</source>
          <target state="translated">이미지 요소</target>
        </trans-unit>
        <trans-unit id="c8f6654a5156a1080fb81d03686a08b3810bb836" translate="yes" xml:space="preserve">
          <source>Image Formats</source>
          <target state="translated">이미지 형식</target>
        </trans-unit>
        <trans-unit id="020c26033d73e6845fa697166de8d81a0273c034" translate="yes" xml:space="preserve">
          <source>Image Information</source>
          <target state="translated">이미지 정보</target>
        </trans-unit>
        <trans-unit id="095667f1fcd46b132e81c4336dd2b0f23e1bc404" translate="yes" xml:space="preserve">
          <source>Image Loading</source>
          <target state="translated">이미지 로딩</target>
        </trans-unit>
        <trans-unit id="887e15fde467a33abf575d3973eec9f31b0f6acb" translate="yes" xml:space="preserve">
          <source>Image QML Type</source>
          <target state="translated">이미지 QML 유형</target>
        </trans-unit>
        <trans-unit id="3e3c60bcc53ebc1195757e000b7e24211c1032cb" translate="yes" xml:space="preserve">
          <source>Image Transformations</source>
          <target state="translated">이미지 변환</target>
        </trans-unit>
        <trans-unit id="c93acc3a97633745105d6cc43cef0f3052324c7f" translate="yes" xml:space="preserve">
          <source>Image and video attributes</source>
          <target state="translated">이미지 및 비디오 속성</target>
        </trans-unit>
        <trans-unit id="25ec2cd54333ae10dd0843f128a4c45de34a9e42" translate="yes" xml:space="preserve">
          <source>Image brightness adjustment.</source>
          <target state="translated">이미지 밝기 조정.</target>
        </trans-unit>
        <trans-unit id="95492d385542f3f54bea997ef816e6a4e12be9bd" translate="yes" xml:space="preserve">
          <source>Image brightness adjustment. Valid brightness adjustment values range between -1.0 and 1.0, with a default of 0.</source>
          <target state="translated">이미지 밝기 조정. 유효한 밝기 조정 값은 -1.0과 1.0 사이이며 기본값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="91707570630a91e9bff1ec54c38a0d9ec324c4f3" translate="yes" xml:space="preserve">
          <source>Image brightness.</source>
          <target state="translated">이미지 밝기.</target>
        </trans-unit>
        <trans-unit id="6ddeef6f06f0a2b4b7ad6dfce532c37fc3e01e43" translate="yes" xml:space="preserve">
          <source>Image can handle any image format supported by Qt, loaded from any URL scheme supported by Qt.</source>
          <target state="translated">이미지는 Qt가 지원하는 모든 URL 스키마에서로드 된 Qt가 지원하는 모든 이미지 형식을 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="a4208d4bbe29c2555b678741b5e94f5d75dc6684" translate="yes" xml:space="preserve">
          <source>Image contrast adjustment.</source>
          <target state="translated">이미지 대비 조정.</target>
        </trans-unit>
        <trans-unit id="73ac3b48d87bc88c249b538d2fac1bc8580d9661" translate="yes" xml:space="preserve">
          <source>Image contrast adjustment. Valid contrast adjustment values range between -1.0 and 1.0, with a default of 0.</source>
          <target state="translated">이미지 대비 조정. 유효한 대비 조정 값의 범위는 -1.0과 1.0이며 기본값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="ac31afc4738a10181084968969c4aef9c2fd6306" translate="yes" xml:space="preserve">
          <source>Image contrast.</source>
          <target state="translated">이미지 대비.</target>
        </trans-unit>
        <trans-unit id="69570f5a7752afa94ff2d8813e24aef45221acbd" translate="yes" xml:space="preserve">
          <source>Image elements with the &quot;asynchronous&quot; property set to &lt;code&gt;true&lt;/code&gt; will load images in a low-priority worker thread.</source>
          <target state="translated">&quot;비동기&quot;속성이 &lt;code&gt;true&lt;/code&gt; 로 설정된 이미지 요소는 우선 순위가 낮은 작업자 스레드에 이미지를로드합니다.</target>
        </trans-unit>
        <trans-unit id="9877178fec8f6b4da1432c696f45a4f0e551354a" translate="yes" xml:space="preserve">
          <source>Image encoder settings are changed, including resolution.</source>
          <target state="translated">해상도를 포함한 이미지 인코더 설정이 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="f3186d67ab09b9326a4f6f94f91614f075fb8d75" translate="yes" xml:space="preserve">
          <source>Image file for the &lt;code&gt;iconic&lt;/code&gt; tile template icon. Default provided by the mkspec.</source>
          <target state="translated">&lt;code&gt;iconic&lt;/code&gt; 타일 ​​템플릿 아이콘 의 이미지 파일 . mkspec에서 제공 한 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="275322b6c0dd9dbb459aac968ddec77ea63c6f97" translate="yes" xml:space="preserve">
          <source>Image file for the small &lt;code&gt;iconic&lt;/code&gt; tile template logo. Default provided by the mkspec.</source>
          <target state="translated">작은 &lt;code&gt;iconic&lt;/code&gt; 타일 ​​템플릿 로고 용 이미지 파일 . mkspec에서 제공 한 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="8b1b3e79d8e6deef1a97d6db9e0d8cf8a4856822" translate="yes" xml:space="preserve">
          <source>Image filter applied. Since 5.5</source>
          <target state="translated">이미지 필터가 적용되었습니다. 5.5 이후</target>
        </trans-unit>
        <trans-unit id="9bfe13d3bb7d52f768d03527bc5e63b414117605" translate="yes" xml:space="preserve">
          <source>Image formats that support animation return true for this value in &lt;a href=&quot;qimageiohandler#supportsOption&quot;&gt;supportsOption&lt;/a&gt;(); otherwise, false is returned.</source>
          <target state="translated">애니메이션을 지원하는 이미지 형식은 &lt;a href=&quot;qimageiohandler#supportsOption&quot;&gt;supportsOption&lt;/a&gt; () 에서이 값에 대해 true를 반환합니다 . 그렇지 않으면 false가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="e962ce20336f0d46a9be4c9caaed139b713a25df" translate="yes" xml:space="preserve">
          <source>Image formats that support different saving variants should return a list of supported variant names (&lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt;&amp;lt;&lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt;&amp;gt;) in this option.</source>
          <target state="translated">다른 저장 변형을 지원하는 이미지 형식 은이 옵션에서 지원되는 변형 이름 목록 ( &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt; &amp;lt; &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; &amp;gt;)을 반환해야합니다 .</target>
        </trans-unit>
        <trans-unit id="6e8f891038fc55e95d7ba0adc5e0d8152f2b87dd" translate="yes" xml:space="preserve">
          <source>Image plugins are queried first, based on either the optional format string, or the file name suffix (if the source device is a file). No content detection is done at this stage. &lt;a href=&quot;qimagereader&quot;&gt;QImageReader&lt;/a&gt; will choose the first plugin that supports reading for this format.</source>
          <target state="translated">선택적 형식 문자열 또는 파일 이름 접미사 (소스 장치가 파일 인 경우)를 기반으로 이미지 플러그인을 먼저 조회합니다. 이 단계에서는 컨텐츠 감지가 수행되지 않습니다. &lt;a href=&quot;qimagereader&quot;&gt;QImageReader&lt;/a&gt; 는이 형식의 읽기를 지원하는 첫 번째 플러그인을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="237651054978b2d4b607041a12a5a4d8fcf34177" translate="yes" xml:space="preserve">
          <source>Image properties</source>
          <target state="translated">이미지 속성</target>
        </trans-unit>
        <trans-unit id="fb6c2609830118b9111385555fc0bbdd0e3256c4" translate="yes" xml:space="preserve">
          <source>Image providers enable support for pixmap and threaded image requests. See the &lt;a href=&quot;qquickimageprovider&quot;&gt;QQuickImageProvider&lt;/a&gt; documentation for details on implementing and using image providers.</source>
          <target state="translated">이미지 공급자는 픽스맵 및 스레드 이미지 요청을 지원합니다. 이미지 제공자 구현 및 사용에 대한 자세한 내용은 &lt;a href=&quot;qquickimageprovider&quot;&gt;QQuickImageProvider&lt;/a&gt; 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="29d0591bf7c64915c032bdc01a04093207a8c33e" translate="yes" xml:space="preserve">
          <source>Image providers must be registered with the QML engine. The only information the QML engine knows about image providers is the type of image data they provide. To use an image provider to acquire image data, you must cast the &lt;a href=&quot;qqmlimageproviderbase&quot;&gt;QQmlImageProviderBase&lt;/a&gt; pointer to a &lt;a href=&quot;qquickimageprovider&quot;&gt;QQuickImageProvider&lt;/a&gt; pointer.</source>
          <target state="translated">이미지 제공자는 QML 엔진에 등록해야합니다. QML 엔진이 이미지 제공 업체에 대해 알고있는 유일한 정보는 제공하는 이미지 데이터 유형입니다. 획득 이미지 데이터에 이미지 제공자를 사용하려면 캐스트 할 필요가 &lt;a href=&quot;qqmlimageproviderbase&quot;&gt;QQmlImageProviderBase의&lt;/a&gt; A와 포인터를 &lt;a href=&quot;qquickimageprovider&quot;&gt;QQuickImageProvider의&lt;/a&gt; 포인터.</target>
        </trans-unit>
        <trans-unit id="e6f8d7e518013a08d011ed13bfea81eaebdb6afc" translate="yes" xml:space="preserve">
          <source>Image providers that support &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt; or Texture loading automatically include support for asychronous loading of images. To enable asynchronous loading for an image source, set the &lt;code&gt;asynchronous&lt;/code&gt; property to &lt;code&gt;true&lt;/code&gt; for the relevant &lt;a href=&quot;qqmlimageproviderbase#ImageType-enum&quot;&gt;Image&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-borderimage&quot;&gt;BorderImage&lt;/a&gt; or &lt;a href=&quot;qml-qtquick-animatedimage&quot;&gt;AnimatedImage&lt;/a&gt; object. When this is enabled, the image request to the provider is run in a low priority thread, allowing image loading to be executed in the background, and reducing the performance impact on the user interface.</source>
          <target state="translated">&lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt; 또는 Texture 로딩 을 지원하는 이미지 제공자는 자동으로 이미지의 비동기 로딩을 지원합니다. 이미지 소스에 대한 비동기 로딩을 활성화하려면 관련 &lt;a href=&quot;qqmlimageproviderbase#ImageType-enum&quot;&gt;Image&lt;/a&gt; , &lt;a href=&quot;qml-qtquick-borderimage&quot;&gt;BorderImage&lt;/a&gt; 또는 &lt;a href=&quot;qml-qtquick-animatedimage&quot;&gt;AnimatedImage&lt;/a&gt; 객체에 대해 &lt;code&gt;asynchronous&lt;/code&gt; 속성을 &lt;code&gt;true&lt;/code&gt; 로 설정하십시오 . 이 기능을 활성화하면 공급자에 대한 이미지 요청이 우선 순위가 낮은 스레드에서 실행되므로 이미지로드가 백그라운드에서 실행될 수 있으며 사용자 인터페이스에 대한 성능 영향이 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="3af7ea35d9fde4a078ea166b03f499ec47abe29b" translate="yes" xml:space="preserve">
          <source>Image saturation adjustment.</source>
          <target state="translated">이미지 채도 조정.</target>
        </trans-unit>
        <trans-unit id="3e65e85a090fb6e7477d5a3b1e7a2855a1326e06" translate="yes" xml:space="preserve">
          <source>Image saturation adjustment. Valid saturation adjustment values range between -1.0 and 1.0, the default is 0.</source>
          <target state="translated">이미지 채도 조정. 유효한 채도 조정 값 범위는 -1.0에서 1.0 사이이며 기본값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="bca26e88da3a7eee962836f0c298ce3b8db42011" translate="yes" xml:space="preserve">
          <source>Image saturation.</source>
          <target state="translated">이미지 채도.</target>
        </trans-unit>
        <trans-unit id="928b6c38c5c6ad5bc05175c8228da1b877e6d347" translate="yes" xml:space="preserve">
          <source>Image.Error - an error occurred while loading the image</source>
          <target state="translated">Image.Error-이미지를로드하는 동안 오류가 발생했습니다</target>
        </trans-unit>
        <trans-unit id="fdd798ed25fabe589c67ede96b0e7a5218283256" translate="yes" xml:space="preserve">
          <source>Image.Loading - the image is currently being loaded</source>
          <target state="translated">이미지로드 중-이미지가 현재로드 중입니다</target>
        </trans-unit>
        <trans-unit id="3ec8d7682cb58d6c6e548c37d5ae72911a9f4210" translate="yes" xml:space="preserve">
          <source>Image.Null - no image has been set</source>
          <target state="translated">Image.Null-이미지가 설정되지 않았습니다</target>
        </trans-unit>
        <trans-unit id="dcd8cd6d001a04bf784a8b8dc1c97305a40b6b39" translate="yes" xml:space="preserve">
          <source>Image.Pad - the image is not transformed</source>
          <target state="translated">이미지 패드-이미지가 변환되지 않습니다</target>
        </trans-unit>
        <trans-unit id="996dcd45b334e04253024ca0f51f128ebb8843f1" translate="yes" xml:space="preserve">
          <source>Image.PreserveAspectCrop - the image is scaled uniformly to fill, cropping if necessary</source>
          <target state="translated">Image.PreserveAspectCrop-이미지가 채워지도록 균일하게 조정되어 필요한 경우 자릅니다.</target>
        </trans-unit>
        <trans-unit id="456737d85a7affa731fda32cfd5344db5ea6b05c" translate="yes" xml:space="preserve">
          <source>Image.PreserveAspectFit - the image is scaled uniformly to fit without cropping</source>
          <target state="translated">Image.PreserveAspectFit-이미지가 자르지 않고 균일하게 조정됩니다.</target>
        </trans-unit>
        <trans-unit id="d5a9b4d7ee83a91af7204802450523ae3c12e4f6" translate="yes" xml:space="preserve">
          <source>Image.Ready - the image has been loaded</source>
          <target state="translated">이미지 준비-이미지가로드되었습니다</target>
        </trans-unit>
        <trans-unit id="3aebc538730d04d2a802dd11d430b80029a039ef" translate="yes" xml:space="preserve">
          <source>Image.Stretch - the image is scaled to fit</source>
          <target state="translated">Image.Stretch-이미지 크기가 맞도록 조정됩니다</target>
        </trans-unit>
        <trans-unit id="5866c887415282ccbe6ecdb3c5e22dad6029cf00" translate="yes" xml:space="preserve">
          <source>Image.Tile - the image is duplicated horizontally and vertically</source>
          <target state="translated">Image.Tile-이미지가 가로 및 세로로 복제됩니다</target>
        </trans-unit>
        <trans-unit id="6f9e2edb98f895ab18ccc4111c4efe4e41867eda" translate="yes" xml:space="preserve">
          <source>Image.TileHorizontally - the image is stretched vertically and tiled horizontally</source>
          <target state="translated">Image.TileHorizontally-이미지가 세로로 늘어나고 가로로 바둑판 식으로 배열됩니다</target>
        </trans-unit>
        <trans-unit id="391b47aa3cd271a9daddeda34eaf2b6aa3d626c1" translate="yes" xml:space="preserve">
          <source>Image.TileVertically - the image is stretched horizontally and tiled vertically</source>
          <target state="translated">Image.TileVertically-이미지가 가로로 늘어나고 세로로 바둑판 식으로 배열됩니다</target>
        </trans-unit>
        <trans-unit id="d6c38eebab4996faca39a61387f11734014ed745" translate="yes" xml:space="preserve">
          <source>Image.asynchronous</source>
          <target state="translated">Image.asynchronous</target>
        </trans-unit>
        <trans-unit id="ee13e88cc2d8429bd0e84569058745f8aaeb1a93" translate="yes" xml:space="preserve">
          <source>Image.autoTransform</source>
          <target state="translated">Image.autoTransform</target>
        </trans-unit>
        <trans-unit id="b0377717d7941893302faaf81814ed98ea2d7622" translate="yes" xml:space="preserve">
          <source>Image.cache</source>
          <target state="translated">Image.cache</target>
        </trans-unit>
        <trans-unit id="ab1255ca30a91f3cd25ab0e57ec660b4f5ecfeb4" translate="yes" xml:space="preserve">
          <source>Image.fillMode</source>
          <target state="translated">Image.fillMode</target>
        </trans-unit>
        <trans-unit id="ad573f968adee6878ec85a4abdaedccb5d6fa928" translate="yes" xml:space="preserve">
          <source>Image.horizontalAlignment</source>
          <target state="translated">Image.horizontalAlignment</target>
        </trans-unit>
        <trans-unit id="1facf1f35ca5349ae3b9ea70dd19c2ea04ac9b44" translate="yes" xml:space="preserve">
          <source>Image.mipmap</source>
          <target state="translated">Image.mipmap</target>
        </trans-unit>
        <trans-unit id="0e8cc6db33bc3c4ab271c7b726e57fb977391405" translate="yes" xml:space="preserve">
          <source>Image.mirror</source>
          <target state="translated">Image.mirror</target>
        </trans-unit>
        <trans-unit id="3b25ae29fc4d55eec7943b7ec5a498c62dcd74ff" translate="yes" xml:space="preserve">
          <source>Image.paintedWidth</source>
          <target state="translated">Image.paintedWidth</target>
        </trans-unit>
        <trans-unit id="de87aa3185b24ad1493103a100803dbb270c22b3" translate="yes" xml:space="preserve">
          <source>Image.progress</source>
          <target state="translated">Image.progress</target>
        </trans-unit>
        <trans-unit id="688db74617785d8792fd6dac0163d86491e68bf3" translate="yes" xml:space="preserve">
          <source>Image.smooth</source>
          <target state="translated">Image.smooth</target>
        </trans-unit>
        <trans-unit id="74321de2400f60219e4a107097684edb50af5a62" translate="yes" xml:space="preserve">
          <source>Image.source</source>
          <target state="translated">Image.source</target>
        </trans-unit>
        <trans-unit id="22ec86da187637e16793239f1f24227b28641cfd" translate="yes" xml:space="preserve">
          <source>Image.sourceSize</source>
          <target state="translated">Image.sourceSize</target>
        </trans-unit>
        <trans-unit id="3f0569c61b23bcc39889a1c5b87594abd2006728" translate="yes" xml:space="preserve">
          <source>Image.status</source>
          <target state="translated">Image.status</target>
        </trans-unit>
        <trans-unit id="c85483e061fb2550c5c3fa4c24fe316d19f82a74" translate="yes" xml:space="preserve">
          <source>ImageModel</source>
          <target state="translated">ImageModel</target>
        </trans-unit>
        <trans-unit id="c4bf499ce91167a244a40e33b3c5af2789d5fb0e" translate="yes" xml:space="preserve">
          <source>ImageModel (QML type)</source>
          <target state="translated">ImageModel (QML 유형)</target>
        </trans-unit>
        <trans-unit id="59950b3e811ed99a9c914e2377bb67082275677f" translate="yes" xml:space="preserve">
          <source>ImageModel QML Type</source>
          <target state="translated">ImageModel QML 유형</target>
        </trans-unit>
        <trans-unit id="aa559d902bbdfc074fc54e03683a47d9a68b0824" translate="yes" xml:space="preserve">
          <source>ImageModel.batchSize</source>
          <target state="translated">ImageModel.batchSize</target>
        </trans-unit>
        <trans-unit id="525461577fa14892f5e57d06e765998397832861" translate="yes" xml:space="preserve">
          <source>ImageModel.place</source>
          <target state="translated">ImageModel.place</target>
        </trans-unit>
        <trans-unit id="5019ba7443c773767aa6c273471e05caaea7efc1" translate="yes" xml:space="preserve">
          <source>ImageModel.totalCount</source>
          <target state="translated">ImageModel.totalCount</target>
        </trans-unit>
        <trans-unit id="c65cc34f2b07c05b2eed7123e24715503cca6a44" translate="yes" xml:space="preserve">
          <source>ImageParticle (QML type)</source>
          <target state="translated">ImageParticle (QML 유형)</target>
        </trans-unit>
        <trans-unit id="22edc8f820fa657012f9afa99e3a0b8cafda3b91" translate="yes" xml:space="preserve">
          <source>ImageParticle QML Type</source>
          <target state="translated">ImageParticle QML 유형</target>
        </trans-unit>
        <trans-unit id="2917331d3411d102098484d743240448fd34b97c" translate="yes" xml:space="preserve">
          <source>ImageParticle.alpha</source>
          <target state="translated">ImageParticle.alpha</target>
        </trans-unit>
        <trans-unit id="6cee5f1d50f09fc8f54ebd7a9367d1fd37b32cb1" translate="yes" xml:space="preserve">
          <source>ImageParticle.alphaVariation</source>
          <target state="translated">ImageParticle.alphaVariation</target>
        </trans-unit>
        <trans-unit id="a4e470c1f71bc70e2279d8b3b598887935f5683c" translate="yes" xml:space="preserve">
          <source>ImageParticle.autoRotation</source>
          <target state="translated">ImageParticle.autoRotation</target>
        </trans-unit>
        <trans-unit id="a94096d1c04919e35ed6abae4e9b770db2929035" translate="yes" xml:space="preserve">
          <source>ImageParticle.blueVariation</source>
          <target state="translated">ImageParticle.blueVariation</target>
        </trans-unit>
        <trans-unit id="99face9f1d2ee034dc7db9ff5d893245bc80bc8a" translate="yes" xml:space="preserve">
          <source>ImageParticle.color</source>
          <target state="translated">ImageParticle.color</target>
        </trans-unit>
        <trans-unit id="5ac102a43502def25e562873808fff18c7dce6f6" translate="yes" xml:space="preserve">
          <source>ImageParticle.colorTable</source>
          <target state="translated">ImageParticle.colorTable</target>
        </trans-unit>
        <trans-unit id="de229a30611ee4126745b75c2f4c677fb5b5847f" translate="yes" xml:space="preserve">
          <source>ImageParticle.colorVariation</source>
          <target state="translated">ImageParticle.colorVariation</target>
        </trans-unit>
        <trans-unit id="32a1d00b0c127f972c64016e56f284b4b6586bab" translate="yes" xml:space="preserve">
          <source>ImageParticle.entryEffect</source>
          <target state="translated">ImageParticle.entryEffect</target>
        </trans-unit>
        <trans-unit id="8ef54b955256c3e37fd5e3248ea107e1d234a749" translate="yes" xml:space="preserve">
          <source>ImageParticle.greenVariation</source>
          <target state="translated">ImageParticle.greenVariation</target>
        </trans-unit>
        <trans-unit id="660663b76e8f0edd070c8dc402599cba2603fa02" translate="yes" xml:space="preserve">
          <source>ImageParticle.opacityTable</source>
          <target state="translated">ImageParticle.opacityTable</target>
        </trans-unit>
        <trans-unit id="46db9a819d23ee76024933e7e57aa8ad2b527073" translate="yes" xml:space="preserve">
          <source>ImageParticle.redVariation</source>
          <target state="translated">ImageParticle.redVariation</target>
        </trans-unit>
        <trans-unit id="6633a6167fdf4a9062ef69bef27baf23a07249b3" translate="yes" xml:space="preserve">
          <source>ImageParticle.rotation</source>
          <target state="translated">ImageParticle.rotation</target>
        </trans-unit>
        <trans-unit id="668326488a064a3831192c97955baf88fd5cad18" translate="yes" xml:space="preserve">
          <source>ImageParticle.rotationVariation</source>
          <target state="translated">ImageParticle.rotationVariation</target>
        </trans-unit>
        <trans-unit id="13761192c94b70a0be32d6de5f07bb97c31d881d" translate="yes" xml:space="preserve">
          <source>ImageParticle.rotationVelocity</source>
          <target state="translated">ImageParticle.rotationVelocity</target>
        </trans-unit>
        <trans-unit id="26cf47b403b85871d3581bd5b23a297a0792e037" translate="yes" xml:space="preserve">
          <source>ImageParticle.rotationVelocityVariation</source>
          <target state="translated">ImageParticle.rotationVelocityVariation</target>
        </trans-unit>
        <trans-unit id="aa323ab2f7070ad7aaae17d04dacc88506528698" translate="yes" xml:space="preserve">
          <source>ImageParticle.sizeTable</source>
          <target state="translated">ImageParticle.sizeTable</target>
        </trans-unit>
        <trans-unit id="6352315790977a0a3e8476798ad5523a06670dfd" translate="yes" xml:space="preserve">
          <source>ImageParticle.source</source>
          <target state="translated">ImageParticle.source</target>
        </trans-unit>
        <trans-unit id="e53ab5f234349a98cd73f3443109ae3e9daf3710" translate="yes" xml:space="preserve">
          <source>ImageParticle.sprites</source>
          <target state="translated">ImageParticle.sprites</target>
        </trans-unit>
        <trans-unit id="33111124e4f659aafd87ca47db056e4060fd0cdf" translate="yes" xml:space="preserve">
          <source>ImageParticle.spritesInterpolate</source>
          <target state="translated">ImageParticle.spritesInterpolate</target>
        </trans-unit>
        <trans-unit id="95ef25e59a5efd4f664decc85ebb47b4ea273947" translate="yes" xml:space="preserve">
          <source>ImageParticle.status</source>
          <target state="translated">ImageParticle.status</target>
        </trans-unit>
        <trans-unit id="ce1f3bf01950470667d3b7925b9cfbdcf6f4b67d" translate="yes" xml:space="preserve">
          <source>ImageParticle.xVector</source>
          <target state="translated">ImageParticle.xVector</target>
        </trans-unit>
        <trans-unit id="ed72047b8155e46dc8f331b19b6568184e79c36a" translate="yes" xml:space="preserve">
          <source>ImageParticle.yVector</source>
          <target state="translated">ImageParticle.yVector</target>
        </trans-unit>
        <trans-unit id="acc969ec26a9fa09a95ee15e89ed5069dcd1f620" translate="yes" xml:space="preserve">
          <source>ImageParticles implictly share data on particles if multiple ImageParticles are painting the same logical particle group. This is broken down along the four capabilities listed above. So if one &lt;a href=&quot;qml-qtquick-particles-imageparticle&quot;&gt;ImageParticle&lt;/a&gt; defines data for rendering the particles in one of those capabilities, and the other does not, then both will draw the particles the same in that aspect automatically. This is primarily useful when there is some random variation on the particle which is supposed to stay with it when switching painters. If both ImageParticles define how they should appear for that aspect, they diverge and each appears as it is defined.</source>
          <target state="translated">여러 ImageParticle이 동일한 논리적 입자 그룹을 그리는 경우 ImageParticles는 입자에 대한 데이터를 암시 적으로 공유합니다. 이것은 위에 나열된 네 가지 기능으로 분류됩니다. 따라서 하나의 &lt;a href=&quot;qml-qtquick-particles-imageparticle&quot;&gt;ImageParticle&lt;/a&gt; 이 이러한 기능 중 하나에서 입자를 렌더링하기위한 데이터를 정의하고 다른 기능은 그렇지 않은 경우, 둘 다 해당 측면에서 입자를 자동으로 동일하게 그립니다. 이것은 주로 화가를 전환 할 때 입자에 남아있는 입자에 임의의 변형이있을 때 유용합니다. 두 ImageParticle이 해당 측면에 어떻게 표시되어야하는지 정의하는 경우, 서로 갈라져 정의 된대로 각각 나타납니다.</target>
        </trans-unit>
        <trans-unit id="09e871c98fef3b901a775def173e4126aaf73b42" translate="yes" xml:space="preserve">
          <source>Images</source>
          <target state="translated">Images</target>
        </trans-unit>
        <trans-unit id="9bba00ba7cfbf846512e4b84315d6e44095836f5" translate="yes" xml:space="preserve">
          <source>Images are a vital part of any user interface. Unfortunately, they are also a big source of problems due to the time it takes to load them, the amount of memory they consume, and the way in which they are used.</source>
          <target state="translated">이미지는 모든 사용자 인터페이스의 중요한 부분입니다. 불행히도,로드하는 데 걸리는 시간, 소비하는 메모리 양 및 사용 방식으로 인해 문제의 큰 원인이기도합니다.</target>
        </trans-unit>
        <trans-unit id="a734ad37e2d1f31fec162317151529307cd631ea" translate="yes" xml:space="preserve">
          <source>Images are cached and shared internally, so if several Image items have the same &lt;a href=&quot;qml-qtquick-image#source-prop&quot;&gt;source&lt;/a&gt;, only one copy of the image will be loaded.</source>
          <target state="translated">이미지는 내부적으로 캐시 및 공유되므로 여러 이미지 항목에 동일한 &lt;a href=&quot;qml-qtquick-image#source-prop&quot;&gt;소스&lt;/a&gt; 가있는 경우 이미지의 사본 하나만로드됩니다.</target>
        </trans-unit>
        <trans-unit id="1c5c0421bf41e3a0987ed37803b634b987e386ef" translate="yes" xml:space="preserve">
          <source>Images are often quite large, and so it is wise to ensure that loading an image doesn't block the UI thread. Set the &quot;asynchronous&quot; property of the QML Image element to &lt;code&gt;true&lt;/code&gt; to enable asynchronous loading of images from the local file system (remote images are always loaded asynchronously) where this would not result in a negative impact upon the aesthetics of the user interface.</source>
          <target state="translated">이미지는 종종 상당히 크므로 이미지를로드해도 UI 스레드가 차단되지 않는 것이 좋습니다. 사용자 인터페이스의 미학에 부정적인 영향을 미치지 않는 로컬 파일 시스템 (원격 이미지는 항상 비동기식으로로드 됨)에서 이미지를 비동기식으로로드 할 수있게 하려면 QML 이미지 요소의 &quot;비동기식&quot;특성을 &lt;code&gt;true&lt;/code&gt; 로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="f09ebb2d58c3eafe46a2586752de4caa7ca959c5" translate="yes" xml:space="preserve">
          <source>Images can be supplied in any format for which Qt has an image reader, so SVG drawings can be included alongside PNG, TIFF and other bitmap formats.</source>
          <target state="translated">이미지는 Qt에 이미지 리더가있는 모든 형식으로 제공 될 수 있으므로 PNG, TIFF 및 기타 비트 맵 형식과 함께 SVG 도면을 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bd391d8013e9e2002aff23680c469ff1379c7172" translate="yes" xml:space="preserve">
          <source>Images in &lt;a href=&quot;qtextdocument&quot;&gt;QTextDocument&lt;/a&gt; are represented by text fragments that reference external images via the resource mechanism. Images are created using the cursor interface, and can be modified later by changing the character format of the image's text fragment:</source>
          <target state="translated">이미지에서 &lt;a href=&quot;qtextdocument&quot;&gt;QTextDocument는&lt;/a&gt; 리소스 메커니즘을 통해 외부 영상을 참조 텍스트 단편에 의해 표현된다. 이미지는 커서 인터페이스를 사용하여 생성되며 이미지 텍스트 조각의 문자 형식을 변경하여 나중에 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1403bc6b73053c035d7035ed1d07b43737448bbc" translate="yes" xml:space="preserve">
          <source>Images returned by a &lt;a href=&quot;qquickimageprovider&quot;&gt;QQuickImageProvider&lt;/a&gt; are automatically cached, similar to any image loaded by the QML engine. When an image with a &quot;image://&quot; prefix is loaded from cache, &lt;a href=&quot;qquickimageprovider#requestImage&quot;&gt;requestImage&lt;/a&gt;() and &lt;a href=&quot;qquickimageprovider#requestPixmap&quot;&gt;requestPixmap&lt;/a&gt;() will not be called for the relevant image provider. If an image should always be fetched from the image provider, and should not be cached at all, set the &lt;code&gt;cache&lt;/code&gt; property to &lt;code&gt;false&lt;/code&gt; for the relevant &lt;a href=&quot;qqmlimageproviderbase#ImageType-enum&quot;&gt;Image&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-borderimage&quot;&gt;BorderImage&lt;/a&gt; or &lt;a href=&quot;qml-qtquick-animatedimage&quot;&gt;AnimatedImage&lt;/a&gt; object.</source>
          <target state="translated">&lt;a href=&quot;qquickimageprovider&quot;&gt;QQuickImageProvider&lt;/a&gt; 가 반환 한 이미지는 QML 엔진이로드 한 이미지와 유사하게 자동으로 캐시됩니다. &quot;image : //&quot;접두사가있는 이미지가 캐시에서로드 되면 관련 이미지 제공자에 대해 &lt;a href=&quot;qquickimageprovider#requestImage&quot;&gt;requestImage&lt;/a&gt; () 및 &lt;a href=&quot;qquickimageprovider#requestPixmap&quot;&gt;requestPixmap&lt;/a&gt; ()이 호출되지 않습니다. 이미지를 이미지 공급자로부터 항상 가져와야하며 전혀 캐시하지 않아야 하는 경우 관련 &lt;a href=&quot;qqmlimageproviderbase#ImageType-enum&quot;&gt;Image&lt;/a&gt; , &lt;a href=&quot;qml-qtquick-borderimage&quot;&gt;BorderImage&lt;/a&gt; 또는 &lt;a href=&quot;qml-qtquick-animatedimage&quot;&gt;AnimatedImage&lt;/a&gt; 객체에 대해 &lt;code&gt;cache&lt;/code&gt; 속성을 &lt;code&gt;false&lt;/code&gt; 로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="98054ab5470e957311b5d94c8723f2b9b9cb8aec" translate="yes" xml:space="preserve">
          <source>Imagine Section</source>
          <target state="translated">섹션 상상</target>
        </trans-unit>
        <trans-unit id="dad00638754ac36048fbd57bbed553cd6109f1e7" translate="yes" xml:space="preserve">
          <source>Imagine Style</source>
          <target state="translated">스타일 상상</target>
        </trans-unit>
        <trans-unit id="f3f1ce65c7d662de103f9b182bf637fc9badc9d7" translate="yes" xml:space="preserve">
          <source>Imagine Style.Imagine.path</source>
          <target state="translated">스타일을 상상해보세요.</target>
        </trans-unit>
        <trans-unit id="38e93318fb9a14392730f2d9e9abd6cc6b7227a1" translate="yes" xml:space="preserve">
          <source>Imagine that we wanted to add an &quot;interrupt&quot; mechanism to the example discussed in the previous section; the user should be able to click a button to have the state machine perform some non-related task, after which the state machine should resume whatever it was doing before (i.e. return to the old state, which is one of &lt;code&gt;s11&lt;/code&gt;, &lt;code&gt;s12&lt;/code&gt; and &lt;code&gt;s13&lt;/code&gt; in this case).</source>
          <target state="translated">이전 섹션에서 설명한 예에 &quot;인터럽트&quot;메커니즘을 추가하려고한다고 상상해보십시오. 사용자는 버튼을 클릭하여 상태 머신이 관련되지 않은 일부 작업을 수행하도록해야합니다. 그 후 상태 머신은 이전에 수행하던 모든 작업을 다시 시작해야합니다 (예 : &lt;code&gt;s11&lt;/code&gt; , &lt;code&gt;s12&lt;/code&gt; 및 &lt;code&gt;s13&lt;/code&gt; 중 하나 인 이전 상태로 돌아 가기) 이 경우).</target>
        </trans-unit>
        <trans-unit id="d46bf7f0635f256bb62b8e6e4435cce21887a239" translate="yes" xml:space="preserve">
          <source>Imagine that we wanted to add an &quot;interrupt&quot; mechanism to the example discussed in the previous section; the user should be able to click a button to have the state machine perform some non-related task, after which the state machine should resume whatever it was doing before (i.e. return to the old state, which is one of the three states in this case).</source>
          <target state="translated">이전 섹션에서 설명한 예에 &quot;인터럽트&quot;메커니즘을 추가하려고한다고 상상해보십시오. 사용자는 버튼을 클릭하여 상태 머신이 관련되지 않은 일부 작업을 수행하도록해야합니다. 그 후 상태 머신은 이전에 수행 한 모든 작업을 다시 시작해야합니다 (예 :이 상태의 세 가지 상태 중 하나 인 이전 상태로 돌아 가기) 케이스).</target>
        </trans-unit>
        <trans-unit id="9cace0481141bb12622f97fa076722e410411c47" translate="yes" xml:space="preserve">
          <source>Imagine.path : string</source>
          <target state="translated">Imagine.path : 문자열</target>
        </trans-unit>
        <trans-unit id="868930280894191b54d63d2127ac6fdebf557223" translate="yes" xml:space="preserve">
          <source>Immediate</source>
          <target state="translated">Immediate</target>
        </trans-unit>
        <trans-unit id="4cc0fc1bb9145c589383805a2b9e7642df617e2d" translate="yes" xml:space="preserve">
          <source>Immediate Alert UUID (service). The service exposes a control point to allow a peer device to cause the device to immediately alert.</source>
          <target state="translated">즉각적인 경고 UUID (서비스). 이 서비스는 제어 장치를 노출시켜 피어 장치가 장치에게 즉시 경고하도록합니다.</target>
        </trans-unit>
        <trans-unit id="8f74d40b0ddca001d8ec191cbc118ef0fc66bc1c" translate="yes" xml:space="preserve">
          <source>Immediate Property Changes in Transitions</source>
          <target state="translated">전환시 즉각적인 부동산 변경</target>
        </trans-unit>
        <trans-unit id="68339c6c58f9820acd9d75108c7f0576ba2cad11" translate="yes" xml:space="preserve">
          <source>Immediately completes any ongoing transition. /sa Animation.complete</source>
          <target state="translated">진행중인 전환을 즉시 완료합니다. / sa Animation.complete</target>
        </trans-unit>
        <trans-unit id="c5601651de7fcae66afe4aba0873b88413dde4f1" translate="yes" xml:space="preserve">
          <source>Immediately dispatches all events which have been previously queued with &lt;a href=&quot;qcoreapplication#postEvent&quot;&gt;QCoreApplication::postEvent&lt;/a&gt;() and which are for the object</source>
          <target state="translated">이전에 &lt;a href=&quot;qcoreapplication#postEvent&quot;&gt;QCoreApplication :: postEvent&lt;/a&gt; ()로 큐에 대기 했고 오브젝트에 대한 모든 이벤트를 즉시 전달 합니다.</target>
        </trans-unit>
        <trans-unit id="bda227a1a554a0d13546ebf5fcba2f685ff2cbe8" translate="yes" xml:space="preserve">
          <source>Immediately sets &lt;code&gt;isFullScreen&lt;/code&gt; property to &lt;code&gt;false&lt;/code&gt;. It can be used to notify the browser engine when the windowing system forces the application to leave fullscreen mode.</source>
          <target state="translated">&lt;code&gt;isFullScreen&lt;/code&gt; 속성을 즉시 &lt;code&gt;false&lt;/code&gt; 로 설정합니다 . 윈도우 시스템이 응용 프로그램을 전체 화면 모드로 강제 종료 할 때 브라우저 엔진에 알리는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d88a43ea93f14a1fa3a0d0d58d578a933a0f86b9" translate="yes" xml:space="preserve">
          <source>Imperative Value Assignment</source>
          <target state="translated">명령형 가치 할당</target>
        </trans-unit>
        <trans-unit id="7dffd111dffd7824c6ed8202c2f8de8f2971d5ad" translate="yes" xml:space="preserve">
          <source>Implement a new rendering technique without having to modify Qt 3D's internals</source>
          <target state="translated">Qt 3D의 내부를 수정하지 않고도 새로운 렌더링 기술 구현</target>
        </trans-unit>
        <trans-unit id="7e7520350429491e18c887be4f965b5bdd1d0d48" translate="yes" xml:space="preserve">
          <source>Implement an &lt;code&gt;onStatusChanged&lt;/code&gt; signal handler:</source>
          <target state="translated">&lt;code&gt;onStatusChanged&lt;/code&gt; 신호 핸들러를 구현하십시오 .</target>
        </trans-unit>
        <trans-unit id="e346f9fffc6ceccab78a2154371197615995d409" translate="yes" xml:space="preserve">
          <source>Implement new geoservices and positioning plugins.</source>
          <target state="translated">새로운 지오 서비스 및 포지셔닝 플러그인을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="bd323a55150b6fa8d2b20d8db4165a3936d48610" translate="yes" xml:space="preserve">
          <source>Implement the &lt;a href=&quot;qtextobjectinterface&quot;&gt;QTextObjectInterface&lt;/a&gt; class.</source>
          <target state="translated">&lt;a href=&quot;qtextobjectinterface&quot;&gt;QTextObjectInterface&lt;/a&gt; 클래스를 구현하십시오 .</target>
        </trans-unit>
        <trans-unit id="824c61e83f5938134d2ccf320782b112d83564ae" translate="yes" xml:space="preserve">
          <source>Implement the method to compare this texture data generator to</source>
          <target state="translated">이 텍스처 데이터 생성기를 비교하는 방법을 구현하십시오.</target>
        </trans-unit>
        <trans-unit id="77704c55abe49f13d980c280e8b0fc7c85fcb538" translate="yes" xml:space="preserve">
          <source>Implement the method to return the texture image data.</source>
          <target state="translated">텍스처 이미지 데이터를 반환하는 메소드를 구현하십시오.</target>
        </trans-unit>
        <trans-unit id="a355b7b38f031aa2b039a06b19988649aa6d14f6" translate="yes" xml:space="preserve">
          <source>Implement the methods of the COM interfaces, and use &lt;a href=&quot;qaxaggregated#object&quot;&gt;QAxAggregated::object&lt;/a&gt;() if you need to make calls to the &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; subclass implementing the control.</source>
          <target state="translated">COM 인터페이스의 메소드를 구현하고 제어를 구현하는 &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 서브 클래스를 호출해야하는 경우 &lt;a href=&quot;qaxaggregated#object&quot;&gt;QAxAggregated :: object&lt;/a&gt; ()를 사용 하십시오.</target>
        </trans-unit>
        <trans-unit id="406f172389da11abc4e5a7989bb113ad823f5e4d" translate="yes" xml:space="preserve">
          <source>Implement this factory once in your COM server to provide information about the components the server can create. Subclass &lt;a href=&quot;qaxfactory&quot;&gt;QAxFactory&lt;/a&gt; and implement the pure virtual functions in any implementation file (e.g. main.cpp), and export the factory using the &lt;code&gt;QAXFACTORY_EXPORT()&lt;/code&gt; macro.</source>
          <target state="translated">COM 서버에서이 팩토리를 한 번 구현하여 서버가 작성할 수있는 구성 요소에 대한 정보를 제공하십시오. &lt;a href=&quot;qaxfactory&quot;&gt;QAxFactory를&lt;/a&gt; 서브 클래스 하고 구현 파일 (예 : main.cpp)에서 순수한 가상 함수를 구현하고 &lt;code&gt;QAXFACTORY_EXPORT()&lt;/code&gt; 매크로를 사용하여 팩토리를 내보내십시오 .</target>
        </trans-unit>
        <trans-unit id="5f23feaf099c6971edc686af99d77cf8503cddd5" translate="yes" xml:space="preserve">
          <source>Implement this function to create a driver matching the type specified by the given</source>
          <target state="translated">주어진 함수에 의해 지정된 타입과 일치하는 드라이버를 생성하기 위해이 함수를 구현</target>
        </trans-unit>
        <trans-unit id="4c14c2fe30be49d5c733a53729dcc63f006d7a5e" translate="yes" xml:space="preserve">
          <source>Implement this method to return the QTextureImageDataGeneratorPtr, which will provide the data for the texture image.</source>
          <target state="translated">텍스처 이미지에 대한 데이터를 제공하는 QTextureImageDataGeneratorPtr을 리턴하도록이 메소드를 구현하십시오.</target>
        </trans-unit>
        <trans-unit id="3e089de4af7d9ddc1e6da0131bcd834096b8d142" translate="yes" xml:space="preserve">
          <source>Implement this method to return the image type supported by this image provider.</source>
          <target state="translated">이 이미지 제공자가 지원하는 이미지 유형을 리턴하려면이 메소드를 구현하십시오.</target>
        </trans-unit>
        <trans-unit id="2d352d18dc68af4a8806f9abd203677132d57e4c" translate="yes" xml:space="preserve">
          <source>Implement this method to return the image with</source>
          <target state="translated">이 메소드를 구현하여 이미지를 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="041a244fbd31fdc4f744aa3a7078f19300173476" translate="yes" xml:space="preserve">
          <source>Implement this method to return the job that will provide the texture with</source>
          <target state="translated">텍스처를 제공 할 작업을 반환하려면이 방법을 구현하십시오.</target>
        </trans-unit>
        <trans-unit id="6d0a303aa84f1afcec28a14303ec4efacff0ca6c" translate="yes" xml:space="preserve">
          <source>Implement this method to return the pixmap with</source>
          <target state="translated">이 메소드를 구현하여 pixmap을 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="69d72131ccbaa4ec47b90c0870e016e31fcbae0f" translate="yes" xml:space="preserve">
          <source>Implement this method to return the texture with</source>
          <target state="translated">이 메소드를 구현하여 텍스처를 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="e64cc5bcea5fe36b7f04f0ed3588d5c7d3924f08" translate="yes" xml:space="preserve">
          <source>Implement this pure virtual function in your subclass.</source>
          <target state="translated">서브 클래스에서이 순수한 가상 함수를 구현하십시오.</target>
        </trans-unit>
        <trans-unit id="ade43a8b3b00e99ac666e4cb294e52b6d22f6e46" translate="yes" xml:space="preserve">
          <source>Implement this to return the properties of this image provider.</source>
          <target state="translated">이 이미지 제공자의 특성을 리턴하려면이를 구현하십시오.</target>
        </trans-unit>
        <trans-unit id="8781d615fd77be9578225c40ac67b9471394cced" translate="yes" xml:space="preserve">
          <source>Implementation</source>
          <target state="translated">Implementation</target>
        </trans-unit>
        <trans-unit id="7a5b3d65c8b1ef6dfcd4d330d512a64c7e307980" translate="yes" xml:space="preserve">
          <source>Implementation &lt;a href=&quot;qtexttospeech#setLocale&quot;&gt;QTextToSpeech::setLocale&lt;/a&gt;(</source>
          <target state="translated">구현 &lt;a href=&quot;qtexttospeech#setLocale&quot;&gt;QTextToSpeech :: setLocale&lt;/a&gt; (</target>
        </trans-unit>
        <trans-unit id="768eca589194c251ad5053258cf35e3750aed13d" translate="yes" xml:space="preserve">
          <source>Implementation Issues</source>
          <target state="translated">구현 문제</target>
        </trans-unit>
        <trans-unit id="bac8c2f94d12883bc12d802245b943cdfe608152" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;a href=&quot;qtexttospeech#availableLocales&quot;&gt;QTextToSpeech::availableLocales&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qtexttospeech#availableLocales&quot;&gt;QTextToSpeech :: availableLocales&lt;/a&gt; ()의 구현 .</target>
        </trans-unit>
        <trans-unit id="252365b05ef1276e15ece6c3868d4b4d1312185c" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;a href=&quot;qtexttospeech#availableVoices&quot;&gt;QTextToSpeech::availableVoices&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qtexttospeech#availableVoices&quot;&gt;QTextToSpeech :: availableVoices&lt;/a&gt; ()의 구현 .</target>
        </trans-unit>
        <trans-unit id="8915b9793a0c76b65653decd9f3391b5b718cc01" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;a href=&quot;qtexttospeech#locale-prop&quot;&gt;QTextToSpeech::locale&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qtexttospeech#locale-prop&quot;&gt;QTextToSpeech :: locale&lt;/a&gt; ()의 구현 .</target>
        </trans-unit>
        <trans-unit id="6f3142270e620ef5d5695917fd099c3e16e4d4f7" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;a href=&quot;qtexttospeech#pause&quot;&gt;QTextToSpeech::pause&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qtexttospeech#pause&quot;&gt;QTextToSpeech :: pause&lt;/a&gt; () 구현 .</target>
        </trans-unit>
        <trans-unit id="5183464314eeea0721641bc39fe137ddb971f6a8" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;a href=&quot;qtexttospeech#pitch-prop&quot;&gt;QTextToSpeech::pitch&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qtexttospeech#pitch-prop&quot;&gt;QTextToSpeech :: pitch&lt;/a&gt; () 구현 .</target>
        </trans-unit>
        <trans-unit id="65270c60c0c4cc1a3b051c8c55c1da9a1ee2403c" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;a href=&quot;qtexttospeech#pitch-prop&quot;&gt;QTextToSpeech::setPitch&lt;/a&gt;(</source>
          <target state="translated">&lt;a href=&quot;qtexttospeech#pitch-prop&quot;&gt;QTextToSpeech :: setPitch&lt;/a&gt; 구현 (</target>
        </trans-unit>
        <trans-unit id="732cb6eaf2b5223b253b4065c81c85598c5188db" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;a href=&quot;qtexttospeech#rate-prop&quot;&gt;QTextToSpeech::rate&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qtexttospeech#rate-prop&quot;&gt;QTextToSpeech :: rate&lt;/a&gt; () 구현 .</target>
        </trans-unit>
        <trans-unit id="683a708a3cbf5e893a3adac0630fc2ed3d390a48" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;a href=&quot;qtexttospeech#rate-prop&quot;&gt;QTextToSpeech::setRate&lt;/a&gt;(</source>
          <target state="translated">구현 &lt;a href=&quot;qtexttospeech#rate-prop&quot;&gt;QTextToSpeech :: setRate&lt;/a&gt; (</target>
        </trans-unit>
        <trans-unit id="6c81f536d52969f0a1f6daadfe044b4f1679c8d4" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;a href=&quot;qtexttospeech#resume&quot;&gt;QTextToSpeech::resume&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qtexttospeech#resume&quot;&gt;QTextToSpeech :: resume&lt;/a&gt; ()의 구현 .</target>
        </trans-unit>
        <trans-unit id="d34333cb782ffdfedde949f5263cc3e9f3223d1b" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;a href=&quot;qtexttospeech#say&quot;&gt;QTextToSpeech::say&lt;/a&gt;(</source>
          <target state="translated">&lt;a href=&quot;qtexttospeech#say&quot;&gt;QTextToSpeech :: say의&lt;/a&gt; 구현 (</target>
        </trans-unit>
        <trans-unit id="0c04b71feeddae254af4e863df6c0a64a030f1b2" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;a href=&quot;qtexttospeech#setVoice&quot;&gt;QTextToSpeech::setVoice&lt;/a&gt;(</source>
          <target state="translated">&lt;a href=&quot;qtexttospeech#setVoice&quot;&gt;QTextToSpeech :: setVoice의&lt;/a&gt; 구현 (</target>
        </trans-unit>
        <trans-unit id="813cdd156d3a421694a5df93ffe85f18088d4859" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;a href=&quot;qtexttospeech#state-prop&quot;&gt;QTextToSpeech::state&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qtexttospeech#state-prop&quot;&gt;QTextToSpeech :: state&lt;/a&gt; ()의 구현 .</target>
        </trans-unit>
        <trans-unit id="58f6ecbddb418e3cc37e34f885c16afa614ed155" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;a href=&quot;qtexttospeech#stop&quot;&gt;QTextToSpeech::stop&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qtexttospeech#stop&quot;&gt;QTextToSpeech :: stop&lt;/a&gt; ()의 구현 .</target>
        </trans-unit>
        <trans-unit id="e9b90b10d7c8933fad8a80cbf878e2f12d1fe6b3" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;a href=&quot;qtexttospeech#voice-prop&quot;&gt;QTextToSpeech::voice&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qtexttospeech#voice-prop&quot;&gt;QTextToSpeech :: voice&lt;/a&gt; () 구현 .</target>
        </trans-unit>
        <trans-unit id="742124903e5f6679c84652579896852bd1d161d5" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;a href=&quot;qtexttospeech#volume-prop&quot;&gt;QTextToSpeech::setVolume&lt;/a&gt;(</source>
          <target state="translated">구현 &lt;a href=&quot;qtexttospeech#volume-prop&quot;&gt;QTextToSpeech :: setVolume&lt;/a&gt; (</target>
        </trans-unit>
        <trans-unit id="6f8bbfa959122fc74c77cd0e797f2e308faaefc2" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;a href=&quot;qtexttospeech#volume-prop&quot;&gt;QTextToSpeech::volume&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qtexttospeech#volume-prop&quot;&gt;QTextToSpeech :: volume&lt;/a&gt; ()의 구현 .</target>
        </trans-unit>
        <trans-unit id="f50927869456efd939126c6c4217e180c662927b" translate="yes" xml:space="preserve">
          <source>Implementation of a simple XML parser</source>
          <target state="translated">간단한 XML 파서 구현</target>
        </trans-unit>
        <trans-unit id="52a6aa695ff12612c420aa2b2acd3323473ecae0" translate="yes" xml:space="preserve">
          <source>Implementations of &lt;a href=&quot;qaccessibleinterface#statex&quot;&gt;QAccessibleInterface::state&lt;/a&gt;() return a combination of these flags.</source>
          <target state="translated">&lt;a href=&quot;qaccessibleinterface#statex&quot;&gt;QAccessibleInterface :: state&lt;/a&gt; () 구현은 이러한 플래그의 조합을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="62322beaafd8ec9a39b5baa61167ebb3ad7e6a17" translate="yes" xml:space="preserve">
          <source>Implementations of relations() return a combination of these flags. Some values are mutually exclusive.</source>
          <target state="translated">relations () 구현은 이러한 플래그의 조합을 반환합니다. 일부 값은 상호 배타적입니다.</target>
        </trans-unit>
        <trans-unit id="9b40982de342c9aa065e55edd172558d53cd6bcf" translate="yes" xml:space="preserve">
          <source>Implementations of this function are recommended to return the same instance for multiple calls to limit memory usage.</source>
          <target state="translated">메모리 사용을 제한하기 위해 여러 호출에 대해 동일한 인스턴스를 반환하려면이 함수를 구현하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="b949b5c89a7c002626b5129900e736b4b67b517b" translate="yes" xml:space="preserve">
          <source>Implementations that do not modify the video frame can simply return</source>
          <target state="translated">비디오 프레임을 수정하지 않은 구현은 단순히</target>
        </trans-unit>
        <trans-unit id="7ce635db6989f56f270c4c9da77887cc9ddbabbf" translate="yes" xml:space="preserve">
          <source>Implementations that store graphics resources outside the node tree, such as an item implementing &lt;a href=&quot;qquickitem#textureProvider&quot;&gt;QQuickItem::textureProvider&lt;/a&gt;(), will need to take care in cleaning it up correctly depending on how the item is used in QML. The situations to handle are:</source>
          <target state="translated">&lt;a href=&quot;qquickitem#textureProvider&quot;&gt;QQuickItem :: textureProvider&lt;/a&gt; ()를 구현하는 항목과 같이 그래픽 트리를 노드 트리 외부에 저장하는 구현 은 QML에서 항목이 사용되는 방식에 따라 올바르게 정리해야합니다. 처리해야 할 상황은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="45917572504116cc9d3aa541f552d3b9c98c9711" translate="yes" xml:space="preserve">
          <source>Implemented Categories</source>
          <target state="translated">구현 된 카테고리</target>
        </trans-unit>
        <trans-unit id="79e4fc5d855be3f3ef0e736af8f6d4efedb9d969" translate="yes" xml:space="preserve">
          <source>Implemented in subclasses to add an</source>
          <target state="translated">서브 클래스에 구현되어</target>
        </trans-unit>
        <trans-unit id="f0be64a6f2f844bf8edb3d02f82270333257e4ac" translate="yes" xml:space="preserve">
          <source>Implemented in subclasses to return the maximum size of this item.</source>
          <target state="translated">이 항목의 최대 크기를 반환하기 위해 서브 클래스로 구현되었습니다.</target>
        </trans-unit>
        <trans-unit id="99a9442344617bb0f8b2765b1c9268a73d0b2f75" translate="yes" xml:space="preserve">
          <source>Implemented in subclasses to return the minimum size of this item.</source>
          <target state="translated">이 아이템의 최소 사이즈를 돌려주기 위해서 서브 클래스에서 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="c3a89331232f593071f453b5cf4851f994ffbc17" translate="yes" xml:space="preserve">
          <source>Implemented in subclasses to return the preferred size of this item.</source>
          <target state="translated">이 아이템의 추천 사이즈를 돌려주기 위해서 서브 클래스에서 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="48a71464c037110bac9ac7e4e37c746810204c17" translate="yes" xml:space="preserve">
          <source>Implemented in subclasses to return whether this item is empty, i.e. whether it contains any widgets.</source>
          <target state="translated">이 항목이 비어 있는지, 즉 위젯을 포함하는지 여부를 리턴하기 위해 서브 클래스에 구현되었습니다.</target>
        </trans-unit>
        <trans-unit id="80f4138d0dc744a4ebbac34c57270cb9e3e0b348" translate="yes" xml:space="preserve">
          <source>Implemented in subclasses to set this item's geometry to</source>
          <target state="translated">이 아이템의 지오메트리를 다음과 같이 설정하기 위해 서브 클래스로 구현</target>
        </trans-unit>
        <trans-unit id="a13de6052d7908b65e5da5504abdf7a6b611fa94" translate="yes" xml:space="preserve">
          <source>Implemented using an FTP proxy, it is useful only in the context of FTP requests (see &lt;a href=&quot;qnetworkaccessmanager&quot;&gt;QNetworkAccessManager&lt;/a&gt;)</source>
          <target state="translated">FTP 프록시를 사용하여 구현되었으며, FTP 요청 컨텍스트에서만 유용합니다 ( &lt;a href=&quot;qnetworkaccessmanager&quot;&gt;QNetworkAccessManager&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="6f51578ba32a5f1095c7802cc7ac37ae56fabad4" translate="yes" xml:space="preserve">
          <source>Implemented using normal HTTP commands, it is useful only in the context of HTTP requests (see &lt;a href=&quot;qnetworkaccessmanager&quot;&gt;QNetworkAccessManager&lt;/a&gt;)</source>
          <target state="translated">일반 HTTP 명령을 사용하여 구현되며 HTTP 요청 컨텍스트에서만 유용합니다 ( &lt;a href=&quot;qnetworkaccessmanager&quot;&gt;QNetworkAccessManager&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="37eaa6052778fa54b8c36b894ab76b71c291e275" translate="yes" xml:space="preserve">
          <source>Implemented using the &quot;CONNECT&quot; command, supports only outgoing TCP connections; supports authentication.</source>
          <target state="translated">&quot;CONNECT&quot;명령을 사용하여 구현되며 발신 TCP 연결 만 지원합니다. 인증을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="c36f0570f5d32e2cbf0d6f246f67f04c076cc4ca" translate="yes" xml:space="preserve">
          <source>Implementers must provide a unique combination of providerName() and providerVersion() per plugin.</source>
          <target state="translated">구현자는 플러그인마다 providerName () 및 providerVersion ()의 고유 한 조합을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="89c6516a41c7f89456772eefae5063a8a95198cb" translate="yes" xml:space="preserve">
          <source>Implementing Accessibility</source>
          <target state="translated">접근성 구현</target>
        </trans-unit>
        <trans-unit id="37055ff4688db34b01056929097bdf4e9a1647a9" translate="yes" xml:space="preserve">
          <source>Implementing Accessible Plugins</source>
          <target state="translated">액세스 가능한 플러그인 구현</target>
        </trans-unit>
        <trans-unit id="62db8de0d5a43bd04c2e49c138c595d8be9bf39a" translate="yes" xml:space="preserve">
          <source>Implementing Attached Objects: An Example</source>
          <target state="translated">첨부 된 객체 구현 : 예</target>
        </trans-unit>
        <trans-unit id="1284919614dda5c4849a9d835fdf6246b454a23f" translate="yes" xml:space="preserve">
          <source>Implementing Containers</source>
          <target state="translated">컨테이너 구현</target>
        </trans-unit>
        <trans-unit id="88757e72266ba18e73a64b75a68b2a454adbda62" translate="yes" xml:space="preserve">
          <source>Implementing Controls</source>
          <target state="translated">컨트롤 구현</target>
        </trans-unit>
        <trans-unit id="da3c580339754281809a3e83b0ad26e13dd93a1a" translate="yes" xml:space="preserve">
          <source>Implementing Interface Factories</source>
          <target state="translated">인터페이스 팩토리 구현</target>
        </trans-unit>
        <trans-unit id="93a7e62b8b482382a12442f268a928d84247e783" translate="yes" xml:space="preserve">
          <source>Implementing New Back-Ends and Porting</source>
          <target state="translated">새로운 백엔드 및 포팅 구현</target>
        </trans-unit>
        <trans-unit id="a697df395e011b66cb0286f725767f5fb97c05d5" translate="yes" xml:space="preserve">
          <source>Implementing Plugins</source>
          <target state="translated">플러그인 구현</target>
        </trans-unit>
        <trans-unit id="105d092e17fec216e8d6c23e821004c74a0ffe87" translate="yes" xml:space="preserve">
          <source>Implementing a Custom CAN Plugin</source>
          <target state="translated">맞춤형 CAN 플러그인 구현</target>
        </trans-unit>
        <trans-unit id="3ac815e3336452c287cb246a2566818a76c57da8" translate="yes" xml:space="preserve">
          <source>Implementing a Custom Input Method</source>
          <target state="translated">커스텀 입력 방법 구현</target>
        </trans-unit>
        <trans-unit id="c3cad3660d34c8c4eb4fd640e52d906820ac9980" translate="yes" xml:space="preserve">
          <source>Implementing a Custom Style</source>
          <target state="translated">사용자 정의 스타일 구현</target>
        </trans-unit>
        <trans-unit id="2f1e6e2499a481cc5e8da70677aff24ce7688e68" translate="yes" xml:space="preserve">
          <source>Implementing a subclass of QAbstractVideoSurface</source>
          <target state="translated">QAbstractVideoSurface의 서브 클래스 구현</target>
        </trans-unit>
        <trans-unit id="9a8faa504839bd228eefcc80f99ef25836ebf8fb" translate="yes" xml:space="preserve">
          <source>Implementing the &lt;a href=&quot;qwebengineurlrequestinterceptor&quot;&gt;QWebEngineUrlRequestInterceptor&lt;/a&gt; interface and installing the interceptor on the profile enables intercepting, blocking, and modifying URL requests before they reach the networking stack of Chromium.</source>
          <target state="translated">&lt;a href=&quot;qwebengineurlrequestinterceptor&quot;&gt;QWebEngineUrlRequestInterceptor&lt;/a&gt; 인터페이스를 구현하고 프로파일에 인터셉터를 설치하면 URL 요청이 Chromium의 네트워킹 스택에 도달하기 전에 인터셉트, 차단 및 수정이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="4dd1cd2566050206f34018201521db4e116a53c7" translate="yes" xml:space="preserve">
          <source>Implementing the &lt;a href=&quot;qwebengineurlrequestinterceptor&quot;&gt;QWebEngineUrlRequestInterceptor&lt;/a&gt; interface and registering the interceptor on a profile by setRequestInterceptor() enables intercepting, blocking, and modifying URL requests (&lt;a href=&quot;qwebengineurlrequestinfo&quot;&gt;QWebEngineUrlRequestInfo&lt;/a&gt;) before they reach the networking stack of Chromium.</source>
          <target state="translated">&lt;a href=&quot;qwebengineurlrequestinterceptor&quot;&gt;QWebEngineUrlRequestInterceptor&lt;/a&gt; 인터페이스를 구현하고 setRequestInterceptor ()로 프로파일에 인터셉터를 등록하면 URL 요청 ( &lt;a href=&quot;qwebengineurlrequestinfo&quot;&gt;QWebEngineUrlRequestInfo&lt;/a&gt; )이 Chromium의 네트워킹 스택에 도달하기 전에 인터셉트, 차단 및 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2310b9fe383f075595e60e4e1744ab91d940d24f" translate="yes" xml:space="preserve">
          <source>Implementing the two constructors for class &lt;code&gt;Employee&lt;/code&gt; is also straightforward. Both create a new instance of &lt;code&gt;EmployeeData&lt;/code&gt; and assign it to the</source>
          <target state="translated">&lt;code&gt;Employee&lt;/code&gt; 클래스의 두 생성자를 구현하는 것도 간단합니다. 둘 다 &lt;code&gt;EmployeeData&lt;/code&gt; 의 새 인스턴스를 작성 하여</target>
        </trans-unit>
        <trans-unit id="8fedd5f9af10dcc2065402dce17c1a81d202eaa7" translate="yes" xml:space="preserve">
          <source>Implementing this is currently not feasible, because the Xcode concept of Active Build Configurations is conceptually different from the qmake idea of build targets.</source>
          <target state="translated">Active Build Configurations의 Xcode 개념이 빌드 대상의 qmake 아이디어와 개념적으로 다르기 때문에이를 구현하는 것은 현재 불가능합니다.</target>
        </trans-unit>
        <trans-unit id="a1d579b66264b8b69e731bda1e199f60583ec640" translate="yes" xml:space="preserve">
          <source>Implementing/Inheriting Reply Objects</source>
          <target state="translated">응답 객체 구현 / 상속</target>
        </trans-unit>
        <trans-unit id="a2c9281ebd86d2e5784c7a81af42b5a91f637f7d" translate="yes" xml:space="preserve">
          <source>Implementors should stop the sensors.</source>
          <target state="translated">구현자는 센서를 중지해야합니다.</target>
        </trans-unit>
        <trans-unit id="44b4324428af79c0b75bfdc681f936837b39bf38" translate="yes" xml:space="preserve">
          <source>Implementors would use this to instantiate QSensors and connect signals.</source>
          <target state="translated">구현자는이를 사용하여 QSensor를 인스턴스화하고 신호를 연결합니다.</target>
        </trans-unit>
        <trans-unit id="7ae338d79a5230e4b43efdab06001e96e0e0f071" translate="yes" xml:space="preserve">
          <source>Implements OAuth 1 signature methods. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">OAuth 1 서명 방법을 구현합니다. &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9dbab7cc5aaaa4d4e4728f3d8a25dde8406f8f83" translate="yes" xml:space="preserve">
          <source>Implements a TCP socket that talks the WebSocket protocol. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">WebSocket 프로토콜과 통신하는 TCP 소켓을 구현합니다. &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="07ce00efe44e974c973ad1854fbe7895987692e8" translate="yes" xml:space="preserve">
          <source>Implements a WebSocket-based server. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">WebSocket 기반 서버를 구현합니다. &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4bc4316bd595db94a09151c95ec09e3615ceda18" translate="yes" xml:space="preserve">
          <source>Implements a main() function that executes all tests in</source>
          <target state="translated">모든 테스트를 실행하는 main () 함수를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="11e5db6cf1adf659b0180252b6472dcbb09db170" translate="yes" xml:space="preserve">
          <source>Implements a main() function that instantiates a &lt;a href=&quot;qcoreapplication&quot;&gt;QCoreApplication&lt;/a&gt; object and the</source>
          <target state="translated">&lt;a href=&quot;qcoreapplication&quot;&gt;QCoreApplication&lt;/a&gt; 객체와 인스턴스를 인스턴스화하는 main () 함수를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="769582a411ec116dae3da4fce76e27f46a1e28f4" translate="yes" xml:space="preserve">
          <source>Implements a main() function that instantiates an application object and the</source>
          <target state="translated">응용 프로그램 객체를 인스턴스화하는 main () 함수를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="58df4016dcc0a1e6f025cd9c6e4efb4b5e74814c" translate="yes" xml:space="preserve">
          <source>Implements a plain text layout for QTextDocument</source>
          <target state="translated">QTextDocument에 대한 일반 텍스트 레이아웃을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="817d2e38832dc5e530d8da9e24d5f4c39ecc59c7" translate="yes" xml:space="preserve">
          <source>Implements a splitter widget</source>
          <target state="translated">스플리터 위젯을 구현합니다</target>
        </trans-unit>
        <trans-unit id="ed071f20bf56590f18c4cef7b3c7c4ffb71a5d5d" translate="yes" xml:space="preserve">
          <source>Implements the clipping functionality in the scene graph</source>
          <target state="translated">장면 그래프에서 클리핑 기능을 구현합니다</target>
        </trans-unit>
        <trans-unit id="360dfa2ecac7b96dfbfcd613fe35c133883f2811" translate="yes" xml:space="preserve">
          <source>Implements transformations in the scene graph</source>
          <target state="translated">장면 그래프에서 변환을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="4a4e5714e68750a6616682cf4332ca27085f7c07" translate="yes" xml:space="preserve">
          <source>Implications for Application Security</source>
          <target state="translated">응용 프로그램 보안에 대한 의미</target>
        </trans-unit>
        <trans-unit id="d1b0c2da64929c52614a0ea37031fc3f08a659ba" translate="yes" xml:space="preserve">
          <source>Implications of Garbage Collection</source>
          <target state="translated">가비지 콜렉션의 의미</target>
        </trans-unit>
        <trans-unit id="37cafc62e0335cc769516aaf21c4deb5286f0977" translate="yes" xml:space="preserve">
          <source>Implicit Sharing</source>
          <target state="translated">암시 적 공유</target>
        </trans-unit>
        <trans-unit id="008b49b9ffac23b845fdc5aceab2e0cf4741c4da" translate="yes" xml:space="preserve">
          <source>Implicit Sharing in Detail</source>
          <target state="translated">암시 적 공유 상세</target>
        </trans-unit>
        <trans-unit id="00704da9b767c062d791dbf94a3d54d1682ec9a5" translate="yes" xml:space="preserve">
          <source>Implicit conversions cannot be done between signals and slots.</source>
          <target state="translated">신호와 슬롯 간에는 암시 적 변환을 수행 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6c30cd01ca170437484abc595c9d9485ad31782e" translate="yes" xml:space="preserve">
          <source>Implicit sharing automatically detaches the object from a shared block if the object is about to change and the reference count is greater than one. (This is often called</source>
          <target state="translated">객체가 변경 되려고하고 참조 카운트가 1보다 크면 암시 적 공유가 공유 블록에서 객체를 자동으로 분리합니다. (이것은 종종</target>
        </trans-unit>
        <trans-unit id="af5545c5727bf3de7176b7b17f4242870d3a2817" translate="yes" xml:space="preserve">
          <source>Implicit sharing iterator problem</source>
          <target state="translated">암시 적 공유 반복자 문제</target>
        </trans-unit>
        <trans-unit id="601f1ceaa652300a5d75c64915d5edfc352c8ebb" translate="yes" xml:space="preserve">
          <source>Implicit sharing might not be right for the &lt;code&gt;Employee&lt;/code&gt; class. Consider a simple example that creates two instances of the implicitly shared &lt;code&gt;Employee&lt;/code&gt; class.</source>
          <target state="translated">&lt;code&gt;Employee&lt;/code&gt; 클래스 에는 암시 적 공유가 적합하지 않을 수 있습니다 . 내재적으로 공유 된 &lt;code&gt;Employee&lt;/code&gt; 클래스 의 두 인스턴스를 작성하는 간단한 예를 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="c9c4834109dffe1f19ab4a49e9550da5ca048239" translate="yes" xml:space="preserve">
          <source>Implicit sharing mostly takes place behind the scenes; the programmer rarely needs to worry about it. However, Qt's container iterators have different behavior than those from the STL. Read &lt;a href=&quot;containers#implicit-sharing-iterator-problem&quot;&gt;Implicit sharing iterator problem&lt;/a&gt;.</source>
          <target state="translated">암시 적 공유는 대부분 뒤에서 이루어집니다. 프로그래머는 거의 걱정할 필요가 없습니다. 그러나 Qt의 컨테이너 이터레이터는 STL과 다른 동작을합니다. &lt;a href=&quot;containers#implicit-sharing-iterator-problem&quot;&gt;암시 적 공유 반복자 문제를&lt;/a&gt; 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="01f8daedd3b6c5e9250fa35409773860241f5ac3" translate="yes" xml:space="preserve">
          <source>Implicit vs Explicit Sharing</source>
          <target state="translated">암시 적 공유와 명시 적 공유</target>
        </trans-unit>
        <trans-unit id="573dd3b4ab30316ae01dc2ccdd4c4c8c99b02418" translate="yes" xml:space="preserve">
          <source>Implicitly Shared Classes</source>
          <target state="translated">암시 적으로 공유 된 클래스</target>
        </trans-unit>
        <trans-unit id="0170645197d080aa6d0d99799c0d55e8e2b3f7b3" translate="yes" xml:space="preserve">
          <source>Import Statement:</source>
          <target state="translated">수입 명세서 :</target>
        </trans-unit>
        <trans-unit id="c84abb908c7f215124958ecd568ac8e0169e3de4" translate="yes" xml:space="preserve">
          <source>Import Statements</source>
          <target state="translated">수입 명세서</target>
        </trans-unit>
        <trans-unit id="cc9d210a6de060e7aa82158f000d6783d2ce29b2" translate="yes" xml:space="preserve">
          <source>Import Types</source>
          <target state="translated">수입 유형</target>
        </trans-unit>
        <trans-unit id="0c7e14afb3fc6058836716fb5b5da1b28b34671f" translate="yes" xml:space="preserve">
          <source>Import and Export Restrictions</source>
          <target state="translated">가져 오기 및 내보내기 제한</target>
        </trans-unit>
        <trans-unit id="dd3e917e0a6dfc3dfd19158b36b1be97ca89b8c0" translate="yes" xml:space="preserve">
          <source>Import the types using the the following statement:</source>
          <target state="translated">다음 명령문을 사용하여 유형을 가져 오십시오.</target>
        </trans-unit>
        <trans-unit id="5121b999d9c7ec346a3f31830e3f222e9d03a8b1" translate="yes" xml:space="preserve">
          <source>Important C++ Classes Provided By The Qt QML Module</source>
          <target state="translated">Qt QML 모듈이 제공하는 중요한 C ++ 클래스</target>
        </trans-unit>
        <trans-unit id="e62a4997192c1e818765bef08838d899ef08c24f" translate="yes" xml:space="preserve">
          <source>Important Classes</source>
          <target state="translated">중요한 수업</target>
        </trans-unit>
        <trans-unit id="61e87e57acb875ed2bbb75fd5ef43644845fe655" translate="yes" xml:space="preserve">
          <source>Important Concepts in Qt Quick</source>
          <target state="translated">Qt Quick의 중요한 개념</target>
        </trans-unit>
        <trans-unit id="38bb3266d02c231b329affcd4d6c0cb05bb6549a" translate="yes" xml:space="preserve">
          <source>Important inherited functions: &lt;a href=&quot;qabstractbutton#text-prop&quot;&gt;text&lt;/a&gt;(), &lt;a href=&quot;qabstractbutton#text-prop&quot;&gt;setText&lt;/a&gt;(), &lt;a href=&quot;qabstractbutton#text-prop&quot;&gt;text&lt;/a&gt;(), pixmap(), setPixmap(), accel(), setAccel(), isToggleButton(), &lt;a href=&quot;qabstractbutton#down-prop&quot;&gt;setDown&lt;/a&gt;(), &lt;a href=&quot;qabstractbutton#down-prop&quot;&gt;isDown&lt;/a&gt;(), isOn(), &lt;a href=&quot;qcheckbox#checkState&quot;&gt;checkState&lt;/a&gt;(), &lt;a href=&quot;qabstractbutton#autoRepeat-prop&quot;&gt;autoRepeat&lt;/a&gt;(), isExclusiveToggle(), &lt;a href=&quot;qabstractbutton#group&quot;&gt;group&lt;/a&gt;(), &lt;a href=&quot;qabstractbutton#autoRepeat-prop&quot;&gt;setAutoRepeat&lt;/a&gt;(), &lt;a href=&quot;qabstractbutton#toggle&quot;&gt;toggle&lt;/a&gt;(), &lt;a href=&quot;qabstractbutton#pressed&quot;&gt;pressed&lt;/a&gt;(), &lt;a href=&quot;qabstractbutton#released&quot;&gt;released&lt;/a&gt;(), &lt;a href=&quot;qabstractbutton#clicked&quot;&gt;clicked&lt;/a&gt;(), &lt;a href=&quot;qabstractbutton#toggled&quot;&gt;toggled&lt;/a&gt;(), &lt;a href=&quot;qcheckbox#checkState&quot;&gt;checkState&lt;/a&gt;(), and &lt;a href=&quot;qcheckbox#stateChanged&quot;&gt;stateChanged&lt;/a&gt;().</source>
          <target state="translated">상속되는 중요한 함수 : &lt;a href=&quot;qabstractbutton#text-prop&quot;&gt;text&lt;/a&gt; (), &lt;a href=&quot;qabstractbutton#text-prop&quot;&gt;setText&lt;/a&gt; (), &lt;a href=&quot;qabstractbutton#text-prop&quot;&gt;text&lt;/a&gt; (), pixmap (), setPixmap (), accel (), setAccel (), isToggleButton (), &lt;a href=&quot;qabstractbutton#down-prop&quot;&gt;setDown&lt;/a&gt; (), &lt;a href=&quot;qabstractbutton#down-prop&quot;&gt;isDown&lt;/a&gt; (), isOn (), &lt;a href=&quot;qcheckbox#checkState&quot;&gt;checkState&lt;/a&gt; ( ), &lt;a href=&quot;qabstractbutton#autoRepeat-prop&quot;&gt;autoRepeat&lt;/a&gt; (), isExclusiveToggle (), &lt;a href=&quot;qabstractbutton#group&quot;&gt;그룹&lt;/a&gt; (), &lt;a href=&quot;qabstractbutton#autoRepeat-prop&quot;&gt;setAutoRepeat&lt;/a&gt; (), &lt;a href=&quot;qabstractbutton#toggle&quot;&gt;토글&lt;/a&gt; (), &lt;a href=&quot;qabstractbutton#pressed&quot;&gt;눌림&lt;/a&gt; (), &lt;a href=&quot;qabstractbutton#released&quot;&gt;해제&lt;/a&gt; (), &lt;a href=&quot;qabstractbutton#clicked&quot;&gt;클릭&lt;/a&gt; (), &lt;a href=&quot;qabstractbutton#toggled&quot;&gt;토글&lt;/a&gt; (), &lt;a href=&quot;qcheckbox#checkState&quot;&gt;checkState&lt;/a&gt; () 및 &lt;a href=&quot;qcheckbox#stateChanged&quot;&gt;stateChanged&lt;/a&gt; ().</target>
        </trans-unit>
        <trans-unit id="e834ab849cfcf5fcf233f800c32a7947a1ab8d02" translate="yes" xml:space="preserve">
          <source>Important inherited members: &lt;a href=&quot;qabstractbutton#text-prop&quot;&gt;text&lt;/a&gt;(), &lt;a href=&quot;qabstractbutton#text-prop&quot;&gt;setText&lt;/a&gt;(), &lt;a href=&quot;qabstractbutton#text-prop&quot;&gt;text&lt;/a&gt;(), &lt;a href=&quot;qabstractbutton#down-prop&quot;&gt;setDown&lt;/a&gt;(), &lt;a href=&quot;qabstractbutton#down-prop&quot;&gt;isDown&lt;/a&gt;(), &lt;a href=&quot;qabstractbutton#autoRepeat-prop&quot;&gt;autoRepeat&lt;/a&gt;(), &lt;a href=&quot;qabstractbutton#group&quot;&gt;group&lt;/a&gt;(), &lt;a href=&quot;qabstractbutton#autoRepeat-prop&quot;&gt;setAutoRepeat&lt;/a&gt;(), &lt;a href=&quot;qabstractbutton#toggle&quot;&gt;toggle&lt;/a&gt;(), &lt;a href=&quot;qabstractbutton#pressed&quot;&gt;pressed&lt;/a&gt;(), &lt;a href=&quot;qabstractbutton#released&quot;&gt;released&lt;/a&gt;(), &lt;a href=&quot;qabstractbutton#clicked&quot;&gt;clicked&lt;/a&gt;(), and &lt;a href=&quot;qabstractbutton#toggled&quot;&gt;toggled&lt;/a&gt;().</source>
          <target state="translated">상속 된 중요한 멤버 : &lt;a href=&quot;qabstractbutton#text-prop&quot;&gt;text&lt;/a&gt; (), &lt;a href=&quot;qabstractbutton#text-prop&quot;&gt;setText&lt;/a&gt; (), &lt;a href=&quot;qabstractbutton#text-prop&quot;&gt;text&lt;/a&gt; (), &lt;a href=&quot;qabstractbutton#down-prop&quot;&gt;setDown&lt;/a&gt; (), &lt;a href=&quot;qabstractbutton#down-prop&quot;&gt;isDown&lt;/a&gt; (), &lt;a href=&quot;qabstractbutton#autoRepeat-prop&quot;&gt;autoRepeat&lt;/a&gt; (), &lt;a href=&quot;qabstractbutton#group&quot;&gt;group&lt;/a&gt; (), &lt;a href=&quot;qabstractbutton#autoRepeat-prop&quot;&gt;setAutoRepeat&lt;/a&gt; (), &lt;a href=&quot;qabstractbutton#toggle&quot;&gt;토글&lt;/a&gt; (), &lt;a href=&quot;qabstractbutton#pressed&quot;&gt;눌림&lt;/a&gt; (), &lt;a href=&quot;qabstractbutton#released&quot;&gt;해제&lt;/a&gt; (), &lt;a href=&quot;qabstractbutton#clicked&quot;&gt;클릭&lt;/a&gt; ( ) 및 &lt;a href=&quot;qabstractbutton#toggled&quot;&gt;전환&lt;/a&gt; ()</target>
        </trans-unit>
        <trans-unit id="037371a95f20d05f36a578d9da5d0b9b47ba7da4" translate="yes" xml:space="preserve">
          <source>Important: please note that this proxy only supports dragging a single row. It will assert if called with indexes from multiple rows, because dragging rows that might come from different source models cannot be implemented generically by this proxy model. Each piece of data in the &lt;a href=&quot;qmimedata&quot;&gt;QMimeData&lt;/a&gt; needs to be merged, which is data-type-specific. Reimplement this method in a subclass if you want to support dragging multiple rows.</source>
          <target state="translated">중요 :이 프록시는 단일 행 드래그 만 지원합니다. 여러 소스 모델에서 가져온 행을 끌어 오는 것은이 프록시 모델에서 일반적으로 구현할 수 없기 때문에 여러 행의 인덱스로 호출하면 주장됩니다. &lt;a href=&quot;qmimedata&quot;&gt;QMimeData&lt;/a&gt; 의 각 데이터 조각은 데이터 유형별 로 병합되어야합니다. 여러 행 드래그를 지원하려면 서브 클래스에서이 메소드를 다시 구현하십시오.</target>
        </trans-unit>
        <trans-unit id="d8596abf671da0c3ab4421f86863a266d9d9052b" translate="yes" xml:space="preserve">
          <source>Important: the</source>
          <target state="translated">중요 :</target>
        </trans-unit>
        <trans-unit id="421387e5ef6af9880ac182b025362e5f7a797ecf" translate="yes" xml:space="preserve">
          <source>Imported JavaScript resources are always qualified using the &quot;as&quot; keyword. The qualifier for JavaScript resources must start with an uppercase letter, and must be unique, so there is always a one-to-one mapping between qualifiers and JavaScript files. (This also means qualifiers cannot be named the same as built-in JavaScript objects such as &lt;code&gt;Date&lt;/code&gt; and &lt;code&gt;Math&lt;/code&gt;).</source>
          <target state="translated">가져온 JavaScript 자원은 항상 &quot;as&quot;키워드를 사용하여 규정됩니다. JavaScript 자원의 규정자는 대문자로 시작해야하며 고유해야하므로 규정 자와 JavaScript 파일 사이에는 항상 일대일 맵핑이 있습니다. 또한 한정자는 &lt;code&gt;Date&lt;/code&gt; 및 &lt;code&gt;Math&lt;/code&gt; 와 같은 내장 JavaScript 객체와 동일하게 이름을 지정할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="99d044d9c559cc35a01b48d24159e07faf855129" translate="yes" xml:space="preserve">
          <source>Imported targets</source>
          <target state="translated">가져온 대상</target>
        </trans-unit>
        <trans-unit id="11dafcf83eb318084b653400651f7c58f6eef584" translate="yes" xml:space="preserve">
          <source>Imported targets are created for each Qt module. Imported target names should be preferred instead of using a variable like Qt5&amp;lt;Module&amp;gt;&lt;a href=&quot;windows-requirements#libraries&quot;&gt;_LIBRARIES&lt;/a&gt; in CMake commands such as &lt;code&gt;target_link_libraries&lt;/code&gt;. The actual path to the library can be obtained using the &lt;a href=&quot;https://cmake.org/cmake/help/latest/prop_tgt/LOCATION.html#&quot;&gt;LOCATION property&lt;/a&gt;:</source>
          <target state="translated">가져온 대상은 각 Qt 모듈에 대해 생성됩니다. &lt;code&gt;target_link_libraries&lt;/code&gt; 와 같은 CMake 명령에서 Qt5 &amp;lt;Module&amp;gt; &lt;a href=&quot;windows-requirements#libraries&quot;&gt;_LIBRARIES&lt;/a&gt; 와 같은 변수를 사용하는 대신 가져온 대상 이름을 선호해야합니다 . 라이브러리의 실제 경로는 &lt;a href=&quot;https://cmake.org/cmake/help/latest/prop_tgt/LOCATION.html#&quot;&gt;LOCATION 속성을&lt;/a&gt; 사용하여 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="607d7e9258bfe0eecc003608448f1db24d5ec4d3" translate="yes" xml:space="preserve">
          <source>Imported targets are created with the configurations Qt was configured with. That is, if Qt was configured with the -debug switch, an imported target with the configuration DEBUG will be created. If Qt was configured with the -release switch an imported target with the configuration RELEASE will be created. If Qt was configured with the -debug-and-release switch (the default on windows), then imported targets will be created with both RELEASE and DEBUG configurations.</source>
          <target state="translated">가져온 대상은 Qt가 구성된 구성으로 생성됩니다. 즉, Qt가 -debug 스위치로 구성된 경우 구성 DEBUG를 사용하여 가져온 대상이 작성됩니다. Qt가 -release 스위치로 구성된 경우 구성 RELEASE를 사용하여 가져온 대상이 작성됩니다. Qt가 -debug-and-release 스위치 (Windows의 기본값)를 사용하여 구성된 경우 가져온 대상은 RELEASE 및 DEBUG 구성으로 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="2b572b92b7abf6a1404a9607ac9225599106712c" translate="yes" xml:space="preserve">
          <source>Importing JavaScript Resources In QML</source>
          <target state="translated">QML에서 JavaScript 리소스 가져 오기</target>
        </trans-unit>
        <trans-unit id="a07d3b9984c3a9bb2a032c822da70a93c7d5a86f" translate="yes" xml:space="preserve">
          <source>Importing JavaScript Resources in QML</source>
          <target state="translated">QML에서 JavaScript 리소스 가져 오기</target>
        </trans-unit>
        <trans-unit id="74f90fa59d49413174a28e0868f3b476bbe060db" translate="yes" xml:space="preserve">
          <source>Importing QML Document Directories</source>
          <target state="translated">QML 문서 디렉토리 가져 오기</target>
        </trans-unit>
        <trans-unit id="e614479e838d142f1dc08e45e6aa8226fbf00096" translate="yes" xml:space="preserve">
          <source>Importing Qt Widgets</source>
          <target state="translated">Qt 위젯 가져 오기</target>
        </trans-unit>
        <trans-unit id="d2dd5e07565ac8d8ed0199fb178fb1a5b42ff516" translate="yes" xml:space="preserve">
          <source>Importing Types Defined Outside the Current Directory</source>
          <target state="translated">현재 디렉토리 외부에 정의 된 유형 가져 오기</target>
        </trans-unit>
        <trans-unit id="6436b24c8b5937824d5797f0351890daff53b895" translate="yes" xml:space="preserve">
          <source>Importing a JavaScript Resource from Another JavaScript Resource</source>
          <target state="translated">다른 JavaScript 리소스에서 JavaScript 리소스 가져 오기</target>
        </trans-unit>
        <trans-unit id="c8de67a37292988e83a4969d75ac4ef4efa0ba8a" translate="yes" xml:space="preserve">
          <source>Importing a JavaScript Resource from a QML Document</source>
          <target state="translated">QML 문서에서 JavaScript 리소스 가져 오기</target>
        </trans-unit>
        <trans-unit id="2278e17098d88be8c7b169c057329a0036bb6869" translate="yes" xml:space="preserve">
          <source>Importing a QML Module from a JavaScript Resource</source>
          <target state="translated">JavaScript 리소스에서 QML 모듈 가져 오기</target>
        </trans-unit>
        <trans-unit id="6bba5262454eb84a52bf916ea0754dee9d03ca43" translate="yes" xml:space="preserve">
          <source>Importing and Using the QtQuick Module</source>
          <target state="translated">QtQuick 모듈 가져 오기 및 사용</target>
        </trans-unit>
        <trans-unit id="715536e90c655a21594c2ca6c3c6c79f182e85fc" translate="yes" xml:space="preserve">
          <source>Importing into a Qualified Local Namespace</source>
          <target state="translated">정규화 된 로컬 네임 스페이스로 가져 오기</target>
        </trans-unit>
        <trans-unit id="e42328ac01cd03a47978f064c93b392caf3861f0" translate="yes" xml:space="preserve">
          <source>Imports</source>
          <target state="translated">Imports</target>
        </trans-unit>
        <trans-unit id="206133b58740639c059f5c141eb877a2e5a78b92" translate="yes" xml:space="preserve">
          <source>Imports Within JavaScript Resources</source>
          <target state="translated">JavaScript 리소스 내에서 가져 오기</target>
        </trans-unit>
        <trans-unit id="20d1724dc0065a29a73e7b81b2e4c1ad97a8259e" translate="yes" xml:space="preserve">
          <source>Imports a PKCS#12 (pfx) file from the specified</source>
          <target state="translated">지정된 PKCS # 12 (pfx) 파일을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="6ec64477d61ce39f7adb564802340feafc5c3403" translate="yes" xml:space="preserve">
          <source>Imports the module located at</source>
          <target state="translated">에 위치한 모듈을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="a609773be3db299eb3ee92dbb63b3af44ab307f6" translate="yes" xml:space="preserve">
          <source>Imports the node</source>
          <target state="translated">노드를 가져옵니다</target>
        </trans-unit>
        <trans-unit id="c63b46833cf99c262fb11d741881043c6481c791" translate="yes" xml:space="preserve">
          <source>Imports the plugin named</source>
          <target state="translated">이름이 지정된 플러그인을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="47ee6ecf0c2b2b386e6e8d2bd53dba4baea22e01" translate="yes" xml:space="preserve">
          <source>Improving Performance</source>
          <target state="translated">성능 향상</target>
        </trans-unit>
        <trans-unit id="aef36502d67b0520654deb764dd055a7e905cfdd" translate="yes" xml:space="preserve">
          <source>In</source>
          <target state="translated">In</target>
        </trans-unit>
        <trans-unit id="ef7a9eb24298b4d4021043721623ae7468909079" translate="yes" xml:space="preserve">
          <source>In 4.6, an internal template class &lt;code&gt;QStringBuilder&lt;/code&gt; has been added along with a few helper functions. This class is marked internal and does not appear in the documentation, because you aren't meant to instantiate it in your code. Its use will be automatic, as described below. The class is found in &lt;code&gt;src/corelib/tools/qstringbuilder.cpp&lt;/code&gt; if you want to have a look at it.</source>
          <target state="translated">4.6에서는 내부 템플릿 클래스 &lt;code&gt;QStringBuilder&lt;/code&gt; 가 몇 가지 도우미 함수와 함께 추가되었습니다. 이 클래스는 내부로 표시되어 있으며 코드에서 인스턴스화하지 않기 때문에 설명서에 표시되지 않습니다. 아래 설명과 같이 자동으로 사용됩니다. 이 클래스는 &lt;code&gt;src/corelib/tools/qstringbuilder.cpp&lt;/code&gt; 에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="326df58c22c2f4d956b599d5c76613f97da612d3" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;21-2-qtgui-qdocconf#&quot;&gt;qtgui.qdocconf&lt;/a&gt;:</source>
          <target state="translated">에서 &lt;a href=&quot;21-2-qtgui-qdocconf#&quot;&gt;qtgui.qdocconf&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="fc97e869e1ad7c93a414a67faa3bae4ef8434220" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;designer-buddy-mode#&quot;&gt;Buddy Editing Mode&lt;/a&gt;, buddy widgets can be assigned to label widgets to help them handle keyboard focus correctly.</source>
          <target state="translated">에서 &lt;a href=&quot;designer-buddy-mode#&quot;&gt;버디 편집 모드&lt;/a&gt; , 친구 위젯은 그들을 제대로 키보드 포커스를 처리 할 수 있도록 라벨 위젯에 할당 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6dd39d6827fd65d615b8a4204e31b579aead189" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;designer-connection-mode#&quot;&gt;Signals and Slots&lt;/a&gt; mode, we can connect widgets together using Qt's signals and slots mechanism. To switch to this mode, press &lt;b&gt;F4&lt;/b&gt;.</source>
          <target state="translated">에서는 &lt;a href=&quot;designer-connection-mode#&quot;&gt;신호 구멍&lt;/a&gt; 모드, 함께 Qt의 신호 슬롯 메카니즘을 사용하여 위젯을 연결할 수있다. 이 모드로 전환하려면 &lt;b&gt;F4를&lt;/b&gt; 누르 &lt;b&gt;십시오&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="befa89ac4b712f09deabc1ee7047cb13c4cc7064" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;designer-tab-order#&quot;&gt;Tab Order Editing Mode&lt;/a&gt;, we can set the order in which widgets receive the keyboard focus.</source>
          <target state="translated">에서 &lt;a href=&quot;designer-tab-order#&quot;&gt;탭 순서 편집 모드&lt;/a&gt; , 우리는 위젯이 키보드 포커스를받는 순서를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="324244d6ee5e1a69e36c3fcbca02a16a7a7da391" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;designer-widget-mode#&quot;&gt;Edit&lt;/a&gt; mode, we can change the appearance of the form, add layouts, and edit the properties of each widget. To switch to this mode, press &lt;b&gt;F3&lt;/b&gt;. This is</source>
          <target state="translated">&lt;a href=&quot;designer-widget-mode#&quot;&gt;편집&lt;/a&gt; 모드 에서는 양식 모양을 변경하고 레이아웃을 추가하며 각 위젯의 속성을 편집 할 수 있습니다. 이 모드로 전환하려면 &lt;b&gt;F3을&lt;/b&gt; 누르 &lt;b&gt;십시오&lt;/b&gt; . 이것은</target>
        </trans-unit>
        <trans-unit id="9c2a2a6f0f93bfb60fe81fe8c040ede3a3427534" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtsql-attribution-sqlite.html#sqlite&quot;&gt;SQLite&lt;/a&gt; any column, with the exception of an INTEGER PRIMARY KEY column, may be used to store any type of value. For instance, a column declared as INTEGER may contain an integer value in one row and a text value in the next. This is due to &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtsql-attribution-sqlite.html#sqlite&quot;&gt;SQLite&lt;/a&gt; associating the type of a value with the value itself rather than with the column it is stored in. A consequence of this is that the type returned by &lt;a href=&quot;qsqlfield#type&quot;&gt;QSqlField::type&lt;/a&gt;() only indicates the field's recommended type. No assumption of the actual type should be made from this and the type of the individual values should be checked.</source>
          <target state="translated">&lt;a href=&quot;https://doc.qt.io/qt-5.13/qtsql-attribution-sqlite.html#sqlite&quot;&gt;SQLite&lt;/a&gt; 에서는 INTEGER PRIMARY KEY 열을 제외한 모든 열을 사용하여 모든 유형의 값을 저장할 수 있습니다. 예를 들어, INTEGER로 선언 된 열은 한 행에 정수 값을 포함하고 다음 행에 텍스트 값을 포함 할 수 있습니다. 이는 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtsql-attribution-sqlite.html#sqlite&quot;&gt;SQLite&lt;/a&gt; 가 값의 유형을 저장된 열이 아닌 값 자체와 연관시키기 때문입니다. 그 결과 &lt;a href=&quot;qsqlfield#type&quot;&gt;QSqlField :: type&lt;/a&gt; ()에 의해 리턴 된 유형 은 필드의 권장 유형 만 나타냅니다. 실제 유형을 가정해서는 안되며 개별 값의 유형을 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="1050c82e66e2ca15d3f9f7d14444d78564000618" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;q3dbars&quot;&gt;Q3DBars&lt;/a&gt; from CameraPresetFrontBelow onward these only work for graphs including negative values. They act as Preset...Low for positive-only values.</source>
          <target state="translated">CameraPresetFrontBelow 이후의 &lt;a href=&quot;q3dbars&quot;&gt;Q3DBar&lt;/a&gt; 에서는 음수 값을 포함한 그래프에서만 작동합니다. 양수 전용 값의 경우 사전 설정 ... 낮음으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="6b3db1c4c3e1f5b8b9327970bcaa1c06fbddd100" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt;, the notion of uppercase and lowercase and of which character is greater than or less than another character is locale dependent. This affects functions that support a case insensitive option or that compare or lowercase or uppercase their arguments. Case insensitive operations and comparisons will be accurate if both strings contain only ASCII characters. (If &lt;code&gt;$LC_CTYPE&lt;/code&gt; is set, most Unix systems do &quot;the right thing&quot;.) Functions that this affects include &lt;a href=&quot;qbytearray#contains&quot;&gt;contains&lt;/a&gt;(), &lt;a href=&quot;qbytearray#indexOf&quot;&gt;indexOf&lt;/a&gt;(), &lt;a href=&quot;qbytearray#lastIndexOf&quot;&gt;lastIndexOf&lt;/a&gt;(), operator&amp;lt;(), operator&amp;lt;=(), operator&amp;gt;(), operator&amp;gt;=(), &lt;a href=&quot;qbytearray#isLower&quot;&gt;isLower&lt;/a&gt;(), &lt;a href=&quot;qbytearray#isUpper&quot;&gt;isUpper&lt;/a&gt;(), &lt;a href=&quot;qbytearray#toLower&quot;&gt;toLower&lt;/a&gt;() and &lt;a href=&quot;qbytearray#toUpper&quot;&gt;toUpper&lt;/a&gt;().</source>
          <target state="translated">에서 &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; , 문자 이하 다른 문자보다 더 의존 로케일보다 큰 대문자와 소문자의 개념. 이것은 대소 문자를 구분하지 않는 옵션을 지원하거나 인수를 비교하거나 소문자 또는 대문자로하는 함수에 영향을줍니다. 두 문자열 모두 ASCII 문자 만 포함하면 대소 문자를 구분하지 않는 연산 및 비교가 정확합니다. ( &lt;code&gt;$LC_CTYPE&lt;/code&gt; 이 설정되면 대부분의 유닉스 시스템은 &quot;올바른 일&quot;을 수행합니다.)이 영향을 미치는 함수는 &lt;a href=&quot;qbytearray#contains&quot;&gt;contains&lt;/a&gt; (), &lt;a href=&quot;qbytearray#indexOf&quot;&gt;indexOf&lt;/a&gt; (), &lt;a href=&quot;qbytearray#lastIndexOf&quot;&gt;lastIndexOf&lt;/a&gt; (), operator &amp;lt;(), operator &amp;lt;= (), operator&amp;gt; ()를 포함합니다. , 연산자&amp;gt; = (), &lt;a href=&quot;qbytearray#isLower&quot;&gt;isLower&lt;/a&gt; (), &lt;a href=&quot;qbytearray#isUpper&quot;&gt;isUpper&lt;/a&gt; (), &lt;a href=&quot;qbytearray#toLower&quot;&gt;toLower&lt;/a&gt; () 및 &lt;a href=&quot;qbytearray#toUpper&quot;&gt;toUpper&lt;/a&gt; ().</target>
        </trans-unit>
        <trans-unit id="5bc9e99a66225747d294b3acd8055641ed98310b" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;qml-qtquick-borderimage&quot;&gt;BorderImage&lt;/a&gt;, this property is read-only.</source>
          <target state="translated">에서 &lt;a href=&quot;qml-qtquick-borderimage&quot;&gt;BorderImage&lt;/a&gt; 이 속성은 읽기 전용입니다.</target>
        </trans-unit>
        <trans-unit id="f4f7b3d5772d8f9ff07fed8bd3c99db10e91db64" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;qopenglwidget#paintGL&quot;&gt;paintGL&lt;/a&gt;() the current context is always accessible by caling &lt;a href=&quot;qopenglcontext#currentContext&quot;&gt;QOpenGLContext::currentContext&lt;/a&gt;(). From this context an already initialized, ready-to-be-used &lt;a href=&quot;https://doc.qt.io/qt-5.13/qopenglfunctions.html&quot;&gt;QOpenGLFunctions&lt;/a&gt; instance is retrievable by calling &lt;a href=&quot;qopenglcontext#functions&quot;&gt;QOpenGLContext::functions&lt;/a&gt;(). An alternative to prefixing every GL call is to inherit from &lt;a href=&quot;https://doc.qt.io/qt-5.13/qopenglfunctions.html&quot;&gt;QOpenGLFunctions&lt;/a&gt; and call &lt;a href=&quot;https://doc.qt.io/qt-5.13/qopenglfunctions.html#initializeOpenGLFunctions&quot;&gt;QOpenGLFunctions::initializeOpenGLFunctions&lt;/a&gt;() in &lt;a href=&quot;qopenglwidget#initializeGL&quot;&gt;initializeGL&lt;/a&gt;().</source>
          <target state="translated">에서 &lt;a href=&quot;qopenglwidget#paintGL&quot;&gt;paintGL&lt;/a&gt; () 현재의 상황은 항상 caling에서 액세스 할 수 &lt;a href=&quot;qopenglcontext#currentContext&quot;&gt;QOpenGLContext :: currentContext을&lt;/a&gt; (). 이 컨텍스트에서 &lt;a href=&quot;qopenglcontext#functions&quot;&gt;QOpenGLContext :: functions&lt;/a&gt; ()를 호출 하여 이미 초기화되어 사용할 수있는 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qopenglfunctions.html&quot;&gt;QOpenGLFunctions&lt;/a&gt; 인스턴스를 검색 할 수 있습니다 . 모든 GL 전화를 접두어로하는 또 다른 방법은에서 상속하는 것입니다 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qopenglfunctions.html&quot;&gt;QOpenGLFunctions&lt;/a&gt; 과 통화 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qopenglfunctions.html#initializeOpenGLFunctions&quot;&gt;QOpenGLFunctions :: initializeOpenGLFunctions&lt;/a&gt; 에서 () &lt;a href=&quot;qopenglwidget#initializeGL&quot;&gt;initializeGL&lt;/a&gt; ().</target>
        </trans-unit>
        <trans-unit id="e22d59b4ac15f2934ae0f539de702d29edbada1a" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;qopenglwidget#paintGL&quot;&gt;paintGL&lt;/a&gt;(), instead of issuing OpenGL commands, construct a &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; object for use on the widget.</source>
          <target state="translated">에서는 &lt;a href=&quot;qopenglwidget#paintGL&quot;&gt;paintGL&lt;/a&gt; (), OpenGL 대신 명령을 발행하는 구성 &lt;a href=&quot;qpainter&quot;&gt;QPainter가의&lt;/a&gt; 위젯에 사용하기위한 오브젝트.</target>
        </trans-unit>
        <trans-unit id="102f20572c1558e58f97f35a68a42d4742462282" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;qpagelayout#Mode-enum&quot;&gt;FullPageMode&lt;/a&gt; the current margins and minimum margins are not taken into account. The paintable rectangle is the full page rectangle, and the current margins can be set to any values regardless of the minimum margins and page size.</source>
          <target state="translated">에서 &lt;a href=&quot;qpagelayout#Mode-enum&quot;&gt;FullPageMode&lt;/a&gt; 현재 마진과 최소 마진은 고려되지 않습니다. 페인트 가능한 사각형은 전체 페이지 사각형이며 현재 여백은 최소 여백과 페이지 크기에 관계없이 모든 값으로 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4533bb0f381ac4db27f694953828d813df5eb651" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;qregexp&quot;&gt;QRegExp&lt;/a&gt;, apart from within character classes, &lt;code&gt;^&lt;/code&gt; always signifies the start of the string, so carets must always be escaped unless used for that purpose. In Perl the meaning of caret varies automagically depending on where it occurs so escaping it is rarely necessary. The same applies to &lt;code&gt;$&lt;/code&gt; which in &lt;a href=&quot;qregexp&quot;&gt;QRegExp&lt;/a&gt; always signifies the end of the string.</source>
          <target state="translated">에서 &lt;a href=&quot;qregexp&quot;&gt;QRegExp&lt;/a&gt; , 간격 문자 클래스 내에서, &lt;code&gt;^&lt;/code&gt; 항상 목적을 위해 사용하지 않는 캐럿 항상 이스케이프해야합니다, 그래서 문자열의 시작을 의미합니다. Perl에서 캐럿의 의미는 발생 위치에 따라 자동으로 달라 지므로 탈출이 거의 필요하지 않습니다. 동일 적용 &lt;code&gt;$&lt;/code&gt; 에있는 &lt;a href=&quot;qregexp&quot;&gt;QRegExp&lt;/a&gt; 항상 문자열의 끝을 의미한다.</target>
        </trans-unit>
        <trans-unit id="34c7461c83e0322301f1f0463aacd703e90a1ac4" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;qregexp&quot;&gt;QRegExp&lt;/a&gt;&lt;b&gt;.&lt;/b&gt; matches any character, therefore all &lt;a href=&quot;qregexp&quot;&gt;QRegExp&lt;/a&gt; regexps have the equivalent of Perl's &lt;code&gt;/s&lt;/code&gt; option. &lt;a href=&quot;qregexp&quot;&gt;QRegExp&lt;/a&gt; does not have an equivalent to Perl's &lt;code&gt;/m&lt;/code&gt; option, but this can be emulated in various ways for example by splitting the input into lines or by looping with a regexp that searches for newlines.</source>
          <target state="translated">에서 &lt;a href=&quot;qregexp&quot;&gt;QRegExp &lt;/a&gt;&lt;b&gt;. &lt;/b&gt;모든 문자와 일치하므로 모든 &lt;a href=&quot;qregexp&quot;&gt;QRegExp 정규 표현식&lt;/a&gt; 은 Perl의 &lt;code&gt;/s&lt;/code&gt; 옵션 과 동일 합니다. &lt;a href=&quot;qregexp&quot;&gt;QRegExp&lt;/a&gt; 는 Perl의 &lt;code&gt;/m&lt;/code&gt; 옵션 과 동일하지 않지만 입력을 행으로 분할하거나 개행을 검색하는 정규 표현식으로 반복하여 다양한 방법으로 에뮬레이트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d78103a0bf29f3ac831f14a2cce77ea4ec4d796b" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;qsqltablemodel#EditStrategy-enum&quot;&gt;OnManualSubmit&lt;/a&gt;, on success the model will be repopulated. Any views presenting it will lose their selections.</source>
          <target state="translated">에서 &lt;a href=&quot;qsqltablemodel#EditStrategy-enum&quot;&gt;OnManualSubmit&lt;/a&gt; , 성공 모델이 다시 채워집니다. 그것을 제시하는 모든 견해는 선택을 잃게됩니다.</target>
        </trans-unit>
        <trans-unit id="0f03eae54f7019c0beb9b13d3a72c5ddc05e8d46" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt;, all expressions evaluate to a sequence of items, where each item is either an XML node or an atomic value. The query in the following snippet evaluates to sequence of five items.</source>
          <target state="translated">에서 &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery를&lt;/a&gt; 모든 표현은 각 항목 중 XML 노드 또는 원자 값 항목의 순서에 평가합니다. 다음 스 니펫의 쿼리는 5 개의 항목 시퀀스로 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="6782b899ab6ca676331734f74e7c9e743ad57f85" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;Employee&lt;/code&gt;'s</source>
          <target state="translated">에서 &lt;code&gt;Employee&lt;/code&gt; 의</target>
        </trans-unit>
        <trans-unit id="e0b0f3a86f2a2b1ee87ffd729f3f0a5da1700e61" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;QtQuick 2.0&lt;/code&gt;, support has been added to allow JavaScript resources to import other JavaScript resources and also QML type namespaces using a variation of the standard QML import syntax (where all of the previously described rules and qualifications apply).</source>
          <target state="translated">&lt;code&gt;QtQuick 2.0&lt;/code&gt; 에서는 표준 QML 가져 오기 구문의 변형을 사용하여 JavaScript 자원이 다른 JavaScript 자원 및 QML 유형 네임 스페이스를 가져올 수 있도록 지원이 추가되었습니다 (이전에 설명 된 모든 규칙 및 규정 적용).</target>
        </trans-unit>
        <trans-unit id="f002fd20f8e2ac83f670273f937d744bfb5c712d" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;main.cpp&lt;/code&gt;, we use a &lt;a href=&quot;qsharedpointer&quot;&gt;QSharedPointer&lt;/a&gt; to hold a replica of the remote object, and then instantiate a replica requestor object:</source>
          <target state="translated">에서 &lt;code&gt;main.cpp&lt;/code&gt; , 우리는 사용 &lt;a href=&quot;qsharedpointer&quot;&gt;QSharedPointer를&lt;/a&gt; 원격 객체의 복제를 길게 누른 다음 복제 요청 객체의 인스턴스를 :</target>
        </trans-unit>
        <trans-unit id="7ee66d17b8b208295a43cee0e9053ad98a73d31d" translate="yes" xml:space="preserve">
          <source>In C++ and Java, we write nested &lt;code&gt;for&lt;/code&gt; loops and recursive functions to traverse XML trees in search of elements of interest. In &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt;, we write these iterative and recursive algorithms with</source>
          <target state="translated">C ++ 및 Java에서는 관심있는 요소를 찾기 위해 XML 트리를 순회하기 &lt;code&gt;for&lt;/code&gt; 중첩 된 for 루프 및 재귀 함수를 작성합니다. 에서 &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery에&lt;/a&gt; , 우리는 이러한 반복과 재귀 알고리즘을 쓰기</target>
        </trans-unit>
        <trans-unit id="b8246f73abc937e67247e5ba24850b15f3aaac07" translate="yes" xml:space="preserve">
          <source>In C++, a route query is performed using the &lt;a href=&quot;qgeoroutingmanager#calculateRoute&quot;&gt;calculate()&lt;/a&gt; method of the &lt;a href=&quot;qgeoroutingmanager&quot;&gt;QGeoRoutingManager&lt;/a&gt; class. The returned route reply can contain multiple routes to the same destination.</source>
          <target state="translated">C ++ 에서 &lt;a href=&quot;qgeoroutingmanager&quot;&gt;QGeoRoutingManager&lt;/a&gt; 클래스 의 &lt;a href=&quot;qgeoroutingmanager#calculateRoute&quot;&gt;calculate ()&lt;/a&gt; 메소드를 사용하여 라우트 조회가 수행됩니다 . 반환 된 경로 응답에는 동일한 대상에 대한 여러 경로가 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7523558bb10e86aa6ac1d9a9f29b12513317cc38" translate="yes" xml:space="preserve">
          <source>In C++, an address-to-coordinate query is performed using the &lt;a href=&quot;qgeocodingmanager#geocode&quot;&gt;geocode()&lt;/a&gt; method of the &lt;a href=&quot;qgeocodingmanager&quot;&gt;QGeoCodingManager&lt;/a&gt; class. For coordinate-to-address queries, the &lt;a href=&quot;qgeocodingmanager#reverseGeocode&quot;&gt;reverseGeocode()&lt;/a&gt; method is available on the same class. Instances of &lt;a href=&quot;qgeocodingmanager&quot;&gt;QGeoCodingManager&lt;/a&gt; are available via &lt;a href=&quot;qgeoserviceprovider&quot;&gt;QGeoServiceProvider&lt;/a&gt;.</source>
          <target state="translated">C ++에서 주소-좌표 쿼리는 &lt;a href=&quot;qgeocodingmanager&quot;&gt;QGeoCodingManager&lt;/a&gt; 클래스 의 &lt;a href=&quot;qgeocodingmanager#geocode&quot;&gt;geocode ()&lt;/a&gt; 메소드를 사용하여 수행됩니다 . 좌표 대 주소 쿼리의 경우 &lt;a href=&quot;qgeocodingmanager#reverseGeocode&quot;&gt;reverseGeocode ()&lt;/a&gt; 메서드를 동일한 클래스에서 사용할 수 있습니다. 의 인스턴스 &lt;a href=&quot;qgeocodingmanager&quot;&gt;QGeoCodingManager을&lt;/a&gt; 통해 사용할 수 있습니다 &lt;a href=&quot;qgeoserviceprovider&quot;&gt;QGeoServiceProvider&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9d63ba0bbdb26f139be11b6b67022482e1fc2523" translate="yes" xml:space="preserve">
          <source>In D-Bus, all method calls must generate a reply to the caller, unless the caller explicitly indicates otherwise (see &lt;a href=&quot;qdbusmessage#isReplyRequired&quot;&gt;isReplyRequired&lt;/a&gt;()). &lt;a href=&quot;qtdbus-index#&quot;&gt;QtDBus&lt;/a&gt; automatically generates such replies for any slots being called, but it also allows slots to indicate whether they will take responsibility of sending the reply at a later time, after the function has finished processing.</source>
          <target state="translated">D-Bus에서, 모든 메소드 호출은 호출자가 명시 적으로 다르게 지시하지 않는 한 호출자에게 응답을 생성해야합니다 ( &lt;a href=&quot;qdbusmessage#isReplyRequired&quot;&gt;isReplyRequired&lt;/a&gt; () 참조 ). &lt;a href=&quot;qtdbus-index#&quot;&gt;QtDBus&lt;/a&gt; 는 호출되는 모든 슬롯에 대해 자동으로 이러한 응답을 생성하지만, 슬롯이 함수 처리가 완료된 후 나중에 응답을 전송해야하는지 여부를 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0c48781818edf5ae7431830c82f2ce26575af0fa" translate="yes" xml:space="preserve">
          <source>In GUI programming, when we ...</source>
          <target state="translated">GUI 프로그래밍에서 우리가 ...</target>
        </trans-unit>
        <trans-unit id="31787f727b5520489db1141c1a2618ab4880194c" translate="yes" xml:space="preserve">
          <source>In GUI programming, when we change one widget, we often want another widget to be notified. More generally, we want objects of any kind to be able to communicate with one another. For example, if a user clicks a &lt;b&gt;Close&lt;/b&gt; button, we probably want the window's &lt;a href=&quot;qwidget#close&quot;&gt;close()&lt;/a&gt; function to be called.</source>
          <target state="translated">GUI 프로그래밍에서 하나의 위젯을 변경할 때 종종 다른 위젯에 알림을 보내려고합니다. 보다 일반적으로, 우리는 모든 종류의 객체가 서로 통신 할 수 있기를 원합니다. 예를 들어, 사용자가 &lt;b&gt;닫기&lt;/b&gt; 버튼을 클릭 하면 창의 &lt;a href=&quot;qwidget#close&quot;&gt;close ()&lt;/a&gt; 함수를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f84352494b204af5b471d74c1ca517b2a721430" translate="yes" xml:space="preserve">
          <source>In IDE integrations, a list of the project's resource (.qrc) file can be activated, making them available to</source>
          <target state="translated">IDE 통합에서 프로젝트의 리소스 (.qrc) 파일 목록을 활성화하여 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="62363fbd2cc3e4782808c14ad9017dcf0038e307" translate="yes" xml:space="preserve">
          <source>In INI files, &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; uses the &lt;code&gt;@&lt;/code&gt; character as a metacharacter in some contexts, to encode Qt-specific data types (e.g., &lt;code&gt;@Rect&lt;/code&gt;), and might therefore misinterpret it when it occurs in pure INI files.</source>
          <target state="translated">INI 파일에서 &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; 는 일부 컨텍스트에서 &lt;code&gt;@&lt;/code&gt; 문자를 메타 문자로 사용하여 Qt 관련 데이터 유형 (예 : &lt;code&gt;@Rect&lt;/code&gt; ) 을 인코딩 하므로 순수한 INI 파일에서 발생할 때 잘못 해석 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="905f97c6279f4dcfcd08709b37c0645cd9237913" translate="yes" xml:space="preserve">
          <source>In Linux/X11 platforms, Qt provides support for session management. Sessions allow events to be propagated to processes, for example, to notify when a shutdown occurs. The process and applications can then perform any necessary operations such as save open documents.</source>
          <target state="translated">Linux / X11 플랫폼에서 Qt는 세션 관리를 지원합니다. 세션을 통해 이벤트가 프로세스로 전파되어 예를 들어 종료가 발생했을 때 알릴 수 있습니다. 그런 다음 프로세스 및 응용 프로그램은 열린 문서 저장과 같은 필요한 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="73d12a549b6815a3e8aedfb9e069dc81f7801462" translate="yes" xml:space="preserve">
          <source>In Makefile mode, qmake will generate a Makefile that is used to build the project. Additionally, the following options may be used in this mode to influence the way the project file is generated:</source>
          <target state="translated">Makefile 모드에서 qmake는 프로젝트를 빌드하는 데 사용되는 Makefile을 생성합니다. 또한이 모드에서 다음 옵션을 사용하여 프로젝트 파일 생성 방식에 영향을 줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2bc0d992d39dfda70e0f80268f798c93a5d51ef0" translate="yes" xml:space="preserve">
          <source>In QML,</source>
          <target state="translated">QML에서</target>
        </trans-unit>
        <trans-unit id="fe5505bb833d413930f5af4b4c8cd44370f07e50" translate="yes" xml:space="preserve">
          <source>In QML, a</source>
          <target state="translated">QML에서</target>
        </trans-unit>
        <trans-unit id="22b722de1b0f5b29d1bf6d421694efa7e9f547a3" translate="yes" xml:space="preserve">
          <source>In QML, component instances connect their component scopes together to form a scope hierarchy. Component instances can directly access the component scopes of their ancestors.</source>
          <target state="translated">QML에서 구성 요소 인스턴스는 구성 요소 범위를 서로 연결하여 범위 계층을 형성합니다. 구성 요소 인스턴스는 조상의 구성 요소 범위에 직접 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4817b38a259ab07481a7c7925d3e1e9762e26743" translate="yes" xml:space="preserve">
          <source>In QML, property bindings result in a dependency between the properties of different objects.</source>
          <target state="translated">QML에서 특성 바인딩은 다른 오브젝트의 특성간에 종속성을 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="d17cf5cce9a4ef8a72686f5c9a62f3434aeff0d5" translate="yes" xml:space="preserve">
          <source>In QML, the global object is constant - existing properties cannot be modified or deleted, and no new properties may be created.</source>
          <target state="translated">QML에서 글로벌 오브젝트는 일정합니다. 기존 특성을 수정하거나 삭제할 수 없으며 새 특성을 작성할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="45f9c39be1612fa3a972201b91a8e35401843622" translate="yes" xml:space="preserve">
          <source>In QML, we assign a string to the &lt;code&gt;baz&lt;/code&gt; property of &lt;code&gt;bar&lt;/code&gt;:</source>
          <target state="translated">QML에서는 &lt;code&gt;bar&lt;/code&gt; 의 &lt;code&gt;baz&lt;/code&gt; 속성에 문자열을 할당 합니다 .</target>
        </trans-unit>
        <trans-unit id="75a5a20d18c763c9cbd9f4bc205562f8b91bd585" translate="yes" xml:space="preserve">
          <source>In Qt 4.2 and later, Qt Designer also includes a style sheet syntax highlighter and validator. The validator indicates if the syntax is valid or invalid, at the bottom left of the &lt;b&gt;Edit Style Sheet&lt;/b&gt; dialog.</source>
          <target state="translated">Qt 4.2 이상에서 Qt Designer에는 스타일 시트 구문 형광펜 및 유효성 검사기도 포함되어 있습니다. 유효성 검증기는 &lt;b&gt;스타일 시트 편집&lt;/b&gt; 대화 상자의 왼쪽 하단에 구문이 유효한지 여부를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="e21f38741bf64f98b29bb902de48f675160b07c2" translate="yes" xml:space="preserve">
          <source>In Qt 4.3 and later, the alignment of the image image's position can be specified using relative or absolute position.</source>
          <target state="translated">Qt 4.3 이상에서 이미지 이미지 위치의 정렬은 상대 또는 절대 위치를 사용하여 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2da1aaff06f6544e32c55ab157f670096cbb5521" translate="yes" xml:space="preserve">
          <source>In Qt 4.3 and later, the alignment of the image within the rectangle can be specified using &lt;a href=&quot;#image-position-prop&quot;&gt;image-position&lt;/a&gt;.</source>
          <target state="translated">Qt 4.3 이상에서 사각형 내 이미지의 정렬은 &lt;a href=&quot;#image-position-prop&quot;&gt;image-position을&lt;/a&gt; 사용하여 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8f5c9359a5865f79b998c5ec2448f1975acc0223" translate="yes" xml:space="preserve">
          <source>In Qt 4.4 and earlier, this disambiguation parameter was the preferred way to specify comments to translators.</source>
          <target state="translated">Qt 4.4 이하에서는이 명확성 매개 변수가 번역자에게 주석을 지정하는 데 선호되는 방법이었습니다.</target>
        </trans-unit>
        <trans-unit id="7bd37077ffde2457133567f5d209d5f0f95ac3ec" translate="yes" xml:space="preserve">
          <source>In Qt 4.4, it was possible to use the static functions to show a sheet on &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt;. This is no longer supported in Qt 4.5. If you want this functionality, use &lt;a href=&quot;qprintdialog#open&quot;&gt;QPrintDialog::open&lt;/a&gt;().</source>
          <target state="translated">Qt 4.4에서는 정적 함수를 사용하여 &lt;a href=&quot;internationalization#macos&quot;&gt;macOS에&lt;/a&gt; 시트를 표시 할 수 있었습니다. Qt 4.5에서는 더 이상 지원되지 않습니다. 이 기능을 원하면 &lt;a href=&quot;qprintdialog#open&quot;&gt;QPrintDialog :: open&lt;/a&gt; ()을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="9e1e9437c8cec7fc00d4f9e1a42fca433cba397e" translate="yes" xml:space="preserve">
          <source>In Qt 4.4, the capability was tied to the proxy type, but since Qt 4.5 it is possible to remove the capability of caching from a proxy by calling &lt;a href=&quot;qnetworkproxy#setCapabilities&quot;&gt;setCapabilities&lt;/a&gt;().</source>
          <target state="translated">Qt 4.4에서는이 기능이 프록시 유형에 연결되었지만 Qt 4.5부터 &lt;a href=&quot;qnetworkproxy#setCapabilities&quot;&gt;setCapabilities&lt;/a&gt; () 를 호출하여 프록시에서 캐싱 기능을 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1301a851a486167f117da749b4b68c3edbaa10b8" translate="yes" xml:space="preserve">
          <source>In Qt 5 all platforms are created using the &lt;a href=&quot;qpa#&quot;&gt;Qt Platform Abstraction&lt;/a&gt; (QPA), which makes it easy to port Qt into a new operating system.</source>
          <target state="translated">Qt 5에서는 모든 플랫폼이 &lt;a href=&quot;qpa#&quot;&gt;Qt&lt;/a&gt; ( Qt Platform Abstraction)를 사용하여 생성 되므로 Qt를 새로운 운영 체제로 쉽게 포팅 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d1c2da74233eacfd350077f4f5a0ec7d5f2a4f31" translate="yes" xml:space="preserve">
          <source>In Qt 5.10, these handlers were introduced in a separate Qt.labs.handlers module. Now they are included with Qt Quick since 5.12. The pre-existing &lt;a href=&quot;qml-qtquick-keys&quot;&gt;Keys&lt;/a&gt; attached property is similar in concept, so we refer to the pointing-device-oriented handlers plus &lt;code&gt;Keys&lt;/code&gt; together as the set of Input Handlers. We expect to offer more attached-property use cases in future versions of Qt.</source>
          <target state="translated">Qt 5.10에서는 이러한 핸들러가 별도의 Qt.labs.handlers 모듈에 도입되었습니다. 이제 5.12부터 Qt Quick에 포함되었습니다. 기존의 &lt;a href=&quot;qml-qtquick-keys&quot;&gt;키&lt;/a&gt; 연결 속성은 개념이 비슷하므로 포인팅 장치 지향 처리기와 더하기 &lt;code&gt;Keys&lt;/code&gt; 를 입력 처리기 집합이라고합니다. 향후 버전의 Qt에서 더 많은 첨부 속성 사용 사례를 제공 할 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="8ae3434f467261f2c591e28d7ac56fb2359d209d" translate="yes" xml:space="preserve">
          <source>In Qt Creator, tested examples on iOS can be looked up. Use the &lt;code&gt;ios&lt;/code&gt; keyword to search for examples in the Qt Creator Welcome mode. Note that some examples may have limited functionality.</source>
          <target state="translated">Qt Creator에서 iOS에서 테스트 된 예제를 찾을 수 있습니다. &lt;code&gt;ios&lt;/code&gt; 키워드를 사용하여 Qt Creator 시작 모드에서 예제를 검색하십시오. 일부 예는 기능이 제한 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f7cb963098912f7677e39836c1fdad9458b8dc8" translate="yes" xml:space="preserve">
          <source>In Qt Quick 2.0, this property has minimal impact on performance.</source>
          <target state="translated">Qt Quick 2.0에서이 속성은 성능에 미치는 영향을 최소화합니다.</target>
        </trans-unit>
        <trans-unit id="a8c1d5254603872065c8e6712d0092447f70f7c3" translate="yes" xml:space="preserve">
          <source>In Qt Quick Controls 2, a style is essentially an interchangeable set of QML files within a single directory. There are three requirements for a style to be &lt;a href=&quot;qtquickcontrols2-styles#using-styles-in-qt-quick-controls-2&quot;&gt;usable&lt;/a&gt;:</source>
          <target state="translated">Qt Quick Controls 2에서 스타일은 기본적으로 단일 디렉토리 내에서 교환 가능한 QML 파일 세트입니다. 스타일을 &lt;a href=&quot;qtquickcontrols2-styles#using-styles-in-qt-quick-controls-2&quot;&gt;사용&lt;/a&gt; 하려면 세 가지 요구 사항이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f58b06b0ad0e7908b9c680c9e77f233784db115a" translate="yes" xml:space="preserve">
          <source>In Qt Quick Controls 2, styles no longer provide components that are dynamically instantiated by controls, but controls themselves consist of item delegates that can be replaced. In effect, this means that delegates are Qt Quick items that are instantiated on the spot, as properties of the control, and are simply parented to the control.</source>
          <target state="translated">Qt Quick Controls 2에서 스타일은 더 이상 컨트롤에 의해 동적으로 인스턴스화되는 구성 요소를 제공하지 않지만 컨트롤 자체는 대체 할 수있는 항목 대리자로 구성됩니다. 실제로 이것은 델리게이트가 컨트롤의 속성으로 즉석에서 인스턴스화되고 단순히 컨트롤의 부모 역할을하는 Qt Quick 항목임을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="e0ddb22c783ba2635ae916d9e01be57f2657a418" translate="yes" xml:space="preserve">
          <source>In Qt there is a often a need to represent the layout of the pixels in a graphics buffer. Internally &lt;a href=&quot;qpixelformat&quot;&gt;QPixelFormat&lt;/a&gt; stores everything in a 64 bit datastructure. This gives performance but also some limitations.</source>
          <target state="translated">Qt에서는 종종 그래픽 버퍼에서 픽셀의 레이아웃을 표현할 필요가 있습니다. 내부적으로 &lt;a href=&quot;qpixelformat&quot;&gt;QPixelFormat&lt;/a&gt; 은 모든 것을 64 비트 데이터 구조로 저장합니다. 이는 성능뿐만 아니라 몇 가지 제한 사항도 제공합니다.</target>
        </trans-unit>
        <trans-unit id="63893ce74e6ced89c15bfc878e9d467f7a92faa1" translate="yes" xml:space="preserve">
          <source>In Qt versions before 5.4, this constructor was &lt;code&gt;explicit&lt;/code&gt;. In Qt 5.4 and later, it no longer is and can be used for C++11-style uniform initialization:</source>
          <target state="translated">5.4 이전의 Qt 버전에서는이 생성자가 &lt;code&gt;explicit&lt;/code&gt; 이었습니다 . Qt 5.4 이상에서는 더 이상 C ++ 11 스타일의 균일 초기화에 사용할 수 없으며 다음과 같이 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="414ba0c2c428e511ff72f14df0252cd424defcd3" translate="yes" xml:space="preserve">
          <source>In Qt, &lt;a href=&quot;qtabbar&quot;&gt;QTabBar&lt;/a&gt; uses the style to draw its tabs. Tabs exist either in a &lt;a href=&quot;qtabwidget&quot;&gt;QTabWidget&lt;/a&gt;, which contains a &lt;a href=&quot;qtabbar&quot;&gt;QTabBar&lt;/a&gt;, or as a separate bar. If the bar is not part of a tab widget, it draws its own base.</source>
          <target state="translated">Qt에서 &lt;a href=&quot;qtabbar&quot;&gt;QTabBar&lt;/a&gt; 는 스타일을 사용하여 탭을 그립니다. 탭은 &lt;a href=&quot;qtabwidget&quot;&gt;QTabBar&lt;/a&gt; 를 포함하는 &lt;a href=&quot;qtabbar&quot;&gt;QTabWidget&lt;/a&gt; 또는 별도의 막대로 존재합니다. 막대가 탭 위젯의 일부가 아닌 경우 자체 막대를 그립니다.</target>
        </trans-unit>
        <trans-unit id="53fc45ccf8ff6c2c17d0ddf9b72209c858a2c8b1" translate="yes" xml:space="preserve">
          <source>In Qt, Unicode characters are 16-bit entities without any markup or structure. This class represents such an entity. It is lightweight, so it can be used everywhere. Most compilers treat it like an &lt;code&gt;unsigned short&lt;/code&gt;.</source>
          <target state="translated">Qt에서 유니 코드 문자는 마크 업이나 구조가없는 16 비트 엔터티입니다. 이 클래스는 그러한 엔티티를 나타냅니다. 가볍기 때문에 어디에서나 사용할 수 있습니다. 대부분의 컴파일러는 이것을 &lt;code&gt;unsigned short&lt;/code&gt; 처럼 취급합니다 .</target>
        </trans-unit>
        <trans-unit id="c68161e5025664a0ac293a55a828704a0cbcad3a" translate="yes" xml:space="preserve">
          <source>In Qt, and in most applications that use Qt, most or all user-visible strings are stored using Unicode. Qt provides:</source>
          <target state="translated">Qt 및 Qt를 사용하는 대부분의 응용 프로그램에서 대부분 또는 모든 사용자가 볼 수있는 문자열은 유니 코드를 사용하여 저장됩니다. Qt는 다음을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="eac7144094ff090daf359b45347bdcb9efd80947" translate="yes" xml:space="preserve">
          <source>In Qt, events are objects, derived from the abstract &lt;a href=&quot;qevent&quot;&gt;QEvent&lt;/a&gt; class, that represent things that have happened either within an application or as a result of outside activity that the application needs to know about. Events can be received and handled by any instance of a &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; subclass, but they are especially relevant to widgets. This document describes how events are delivered and handled in a typical application.</source>
          <target state="translated">Qt에서 이벤트는 추상 &lt;a href=&quot;qevent&quot;&gt;QEvent&lt;/a&gt; 클래스 에서 파생 된 개체로, 응용 프로그램 내에서 또는 응용 프로그램이 알아야하는 외부 활동의 결과를 나타냅니다. &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 서브 클래스 의 모든 인스턴스에서 이벤트를 수신하고 처리 할 수 있지만 특히 위젯과 관련이 있습니다. 이 문서는 일반적인 응용 프로그램에서 이벤트가 전달되고 처리되는 방법을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="849b14dff590398aba602de88700a986333573d3" translate="yes" xml:space="preserve">
          <source>In Qt, only the &lt;a href=&quot;qwidget#focusPolicy-prop&quot;&gt;QWidget::setFocusPolicy&lt;/a&gt;() function affects click-to-focus.</source>
          <target state="translated">Qt에서는 &lt;a href=&quot;qwidget#focusPolicy-prop&quot;&gt;QWidget :: setFocusPolicy&lt;/a&gt; () 함수 만 클릭 투 포커스에 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="15fd12f867719ae4a4464c703001a54f55c8e80e" translate="yes" xml:space="preserve">
          <source>In Qt, printers are represented by &lt;a href=&quot;qprinter&quot;&gt;QPrinter&lt;/a&gt;, a paint device that provides functionality specific to printing, such as support for multiple pages and double-sided output. As a result, printing involves using a &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; to paint onto a series of pages in the same way that you would paint onto a custom widget or image.</source>
          <target state="translated">Qt에서 프린터는 여러 페이지 및 양면 출력 지원과 같이 인쇄 관련 기능을 제공하는 페인트 장치 인 &lt;a href=&quot;qprinter&quot;&gt;QPrinter&lt;/a&gt; 로 표시됩니다 . 결과적으로 인쇄에는 &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; 를 사용하여 사용자 정의 위젯 또는 이미지에 페인트하는 것과 같은 방식으로 일련의 페이지에 페인트하는 것이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="6249b7e9079795af469dac88f40752d05817431d" translate="yes" xml:space="preserve">
          <source>In Qt, the &lt;a href=&quot;qabstractbutton&quot;&gt;QAbstractButton&lt;/a&gt; base class provides most of the modes and other API, and &lt;a href=&quot;qpushbutton&quot;&gt;QPushButton&lt;/a&gt; provides GUI logic. See &lt;a href=&quot;qabstractbutton&quot;&gt;QAbstractButton&lt;/a&gt; for more information about the API.</source>
          <target state="translated">Qt에서 &lt;a href=&quot;qabstractbutton&quot;&gt;QAbstractButton&lt;/a&gt; 기본 클래스는 대부분의 모드와 기타 API를 제공 하고 &lt;a href=&quot;qpushbutton&quot;&gt;QPushButton&lt;/a&gt; 은 GUI 로직을 제공합니다. API에 대한 자세한 정보는 &lt;a href=&quot;qabstractbutton&quot;&gt;QAbstractButton&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="694d95eac501dc5a240807b6c9dd7ba788a59f47" translate="yes" xml:space="preserve">
          <source>In Qt, the &lt;a href=&quot;qvector3d&quot;&gt;QVector3D&lt;/a&gt; class was documented with the following QDoc comment:</source>
          <target state="translated">Qt에서 &lt;a href=&quot;qvector3d&quot;&gt;QVector3D&lt;/a&gt; 클래스는 다음 QDoc 주석과 함께 문서화되었습니다.</target>
        </trans-unit>
        <trans-unit id="81e7f13c19bd0db5d160904a2301522c68a90150" translate="yes" xml:space="preserve">
          <source>In Qt, we have an alternative to the callback technique: We use signals and slots. A signal is emitted when a particular event occurs. Qt's widgets have many predefined signals, but we can always subclass widgets to add our own signals to them. A slot is a function that is called in response to a particular signal. Qt's widgets have many pre-defined slots, but it is common practice to subclass widgets and add your own slots so that you can handle the signals that you are interested in.</source>
          <target state="translated">Qt에는 콜백 기술 대신 신호와 슬롯을 사용합니다. 특정 이벤트가 발생하면 신호가 발생합니다. Qt의 위젯에는 사전 정의 된 많은 신호가 있지만 언제든지 자체 신호를 추가하기 위해 위젯을 서브 클래 싱 할 수 있습니다. 슬롯은 특정 신호에 대한 응답으로 호출되는 기능입니다. Qt의 위젯에는 많은 사전 정의 된 슬롯이 있지만, 관심있는 신호를 처리 할 수 ​​있도록 위젯을 서브 클래 싱하고 자체 슬롯을 추가하는 것이 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="b54bd41df643a393d2a3ca28c846808bdce80dd0" translate="yes" xml:space="preserve">
          <source>In Qt3D 5.9, &lt;a href=&quot;qt3drender-qmesh&quot;&gt;QMesh&lt;/a&gt; supports the following formats:</source>
          <target state="translated">Qt3D 5.9에서 &lt;a href=&quot;qt3drender-qmesh&quot;&gt;QMesh&lt;/a&gt; 는 다음 형식을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="2126249dd3052dc8ea5cd46acab4c4eb0c44b8fb" translate="yes" xml:space="preserve">
          <source>In Qt3D 5.9, Mesh supports the following formats:</source>
          <target state="translated">Qt3D 5.9에서 Mesh는 다음 형식을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="c2523a8f7408dd870d0a1d43a52286838bb0d211" translate="yes" xml:space="preserve">
          <source>In RPC, the client makes a request and waits for the response.</source>
          <target state="translated">RPC에서 클라이언트는 요청을하고 응답을 기다립니다.</target>
        </trans-unit>
        <trans-unit id="3cbbfe5979b17f206686250eb3f92a1fa75e464a" translate="yes" xml:space="preserve">
          <source>In RPC, the server doesn't push anything to the client unless it's in response to a request.</source>
          <target state="translated">RPC에서 서버는 요청에 대한 응답이 없으면 클라이언트에 아무것도 푸시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="45d3485287b17067f45fc7f064c5ee0de5a2fcc3" translate="yes" xml:space="preserve">
          <source>In TCP emulation mode, accepted clients use a single continuous byte stream for data transmission, and &lt;a href=&quot;qsctpserver&quot;&gt;QSctpServer&lt;/a&gt; acts like a plain &lt;a href=&quot;qtcpserver&quot;&gt;QTcpServer&lt;/a&gt;. Call &lt;a href=&quot;qtcpserver#nextPendingConnection&quot;&gt;nextPendingConnection&lt;/a&gt;() to accept the pending connection as a connected &lt;a href=&quot;qtcpsocket&quot;&gt;QTcpSocket&lt;/a&gt;. The function returns a pointer to a &lt;a href=&quot;qtcpsocket&quot;&gt;QTcpSocket&lt;/a&gt; in &lt;a href=&quot;qabstractsocket#SocketState-enum&quot;&gt;QAbstractSocket::ConnectedState&lt;/a&gt; that you can use for communicating with the client. This mode gives access only to basic SCTP protocol features. The socket transmits SCTP packets over IP at system level and interacts through the &lt;a href=&quot;qtcpsocket&quot;&gt;QTcpSocket&lt;/a&gt; interface with the application.</source>
          <target state="translated">TCP 에뮬레이션 모드에서 허용 된 클라이언트는 데이터 전송에 단일 연속 바이트 스트림을 사용하며 &lt;a href=&quot;qsctpserver&quot;&gt;QSctpServer&lt;/a&gt; 는 일반 &lt;a href=&quot;qtcpserver&quot;&gt;QTcpServer&lt;/a&gt; 처럼 작동 합니다. 보류중인 연결을 연결된 &lt;a href=&quot;qtcpsocket&quot;&gt;QTcpSocket&lt;/a&gt; 으로 승인하려면 &lt;a href=&quot;qtcpserver#nextPendingConnection&quot;&gt;nextPendingConnection&lt;/a&gt; ()을 호출 하십시오 . 이 함수는 &lt;a href=&quot;qabstractsocket#SocketState-enum&quot;&gt;QAbstractSocket :: ConnectedState&lt;/a&gt; 에서 클라이언트와의 통신에 사용할 수 있는 &lt;a href=&quot;qtcpsocket&quot;&gt;QTcpSocket&lt;/a&gt; 에 대한 포인터를 리턴합니다 . 이 모드는 기본 SCTP 프로토콜 기능에만 액세스 할 수 있습니다. 소켓은 시스템 레벨에서 IP를 통해 SCTP 패킷을 전송하고 &lt;a href=&quot;qtcpsocket&quot;&gt;QTcpSocket&lt;/a&gt; 인터페이스를 통해 애플리케이션 과 상호 작용 합니다.</target>
        </trans-unit>
        <trans-unit id="44a49ce007c82f83e07df2ca6d842352ca2d5348" translate="yes" xml:space="preserve">
          <source>In TolerantMode, the parser has the following behaviour:</source>
          <target state="translated">TolerantMode에서 파서는 다음과 같은 동작을합니다.</target>
        </trans-unit>
        <trans-unit id="9ce703d78bc316e614736f30d7696a28179319d2" translate="yes" xml:space="preserve">
          <source>In Unicode, comparison is not necessarily possible and case conversion is very difficult at best. Unicode, covering the &quot;entire&quot; world, also includes most of the world's case and sorting problems. operator==() and friends will do comparison based purely on the numeric Unicode value (code point) of the characters, and &lt;a href=&quot;qchar#toUpper&quot;&gt;toUpper&lt;/a&gt;() and &lt;a href=&quot;qchar#toLower&quot;&gt;toLower&lt;/a&gt;() will do case changes when the character has a well-defined uppercase/lowercase equivalent. For locale-dependent comparisons, use &lt;a href=&quot;qstring#localeAwareCompare&quot;&gt;QString::localeAwareCompare&lt;/a&gt;().</source>
          <target state="translated">유니 코드에서는 비교가 반드시 필요한 것은 아니며 대소 문자 변환은 매우 어렵습니다. &quot;전체&quot;세계를 다루는 유니 코드에는 세계 대부분의 경우 및 정렬 문제도 포함됩니다. operator == () 및 friends는 문자의 숫자 유니 코드 값 (코드 포인트)을 기준으로 순전히 비교를 수행하며 문자에 잘 정의 된 대문자 / 소문자가있는 경우 &lt;a href=&quot;qchar#toUpper&quot;&gt;toUpper&lt;/a&gt; () 및 &lt;a href=&quot;qchar#toLower&quot;&gt;toLower&lt;/a&gt; ()는 대소 문자를 변경합니다. 로케일 종속 비교의 경우 &lt;a href=&quot;qstring#localeAwareCompare&quot;&gt;QString :: localeAwareCompare&lt;/a&gt; ()를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="2af810392d2eed210bbaa3693616186a26defb42" translate="yes" xml:space="preserve">
          <source>In Unix, if the</source>
          <target state="translated">유닉스에서는</target>
        </trans-unit>
        <trans-unit id="494e9f241ce2d3b45a99d226ba6b7caf13fad469" translate="yes" xml:space="preserve">
          <source>In Windows a request for the &quot;Courier&quot; font is automatically changed to &quot;Courier New&quot;, an improved version of Courier that allows for smooth scaling. The older &quot;Courier&quot; bitmap font can be selected by setting the &lt;a href=&quot;qfont#StyleStrategy-enum&quot;&gt;PreferBitmap&lt;/a&gt; style strategy (see &lt;a href=&quot;qfont#setStyleStrategy&quot;&gt;setStyleStrategy&lt;/a&gt;()).</source>
          <target state="translated">Windows에서는 &quot;Courier&quot;글꼴에 대한 요청이 자동으로 부드러운 크기 조정이 가능한 Courier의 개선 된 버전 인 &quot;Courier New&quot;로 자동 변경됩니다. &lt;a href=&quot;qfont#StyleStrategy-enum&quot;&gt;PreferBitmap&lt;/a&gt; 스타일 전략 을 설정하여 이전 &quot;Courier&quot;비트 맵 글꼴을 선택할 수 있습니다 ( &lt;a href=&quot;qfont#setStyleStrategy&quot;&gt;setStyleStrategy&lt;/a&gt; () 참조 ).</target>
        </trans-unit>
        <trans-unit id="6ce2ce9fe5778060c4194ef00f287de9d761cae7" translate="yes" xml:space="preserve">
          <source>In Windows,</source>
          <target state="translated">Windows에서는</target>
        </trans-unit>
        <trans-unit id="9bf983d41771df979f4153d3847cee83fa0e0748" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;https://doc.qt.io/qt-5.13/qmlexampletoggleswitch.html#transition&quot;&gt;Transition&lt;/a&gt;</source>
          <target state="translated">A의 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qmlexampletoggleswitch.html#transition&quot;&gt;전환&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6653e14008f4417e834970c4961ea469d9475daf" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; with stickyFocus set to true, focus will remain unchanged when the user clicks into the scene background or on an item that does not accept focus. Otherwise, focus will be cleared.</source>
          <target state="translated">A의 &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; 항목 장면 배경으로 또는 사용자가 클릭 초점을 허용하지 않는 경우 true로 stickyFocus 세트, 초점은 변경되지 않습니다. 그렇지 않으면 초점이 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="f7eb4b68c9bdf8cfec5b4299db1dd99f11fbebbc" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;qml-qtquick-behavior&quot;&gt;Behavior&lt;/a&gt;</source>
          <target state="translated">A의 &lt;a href=&quot;qml-qtquick-behavior&quot;&gt;행동&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9c4518881d0fae2553c0574fe79a4ce737d3d4d5" translate="yes" xml:space="preserve">
          <source>In a PSK handshake, the client must derive a key, which must match the key set on the server. The exact algorithm of deriving the key depends on the application; however, for this purpose, the server may send an</source>
          <target state="translated">PSK 핸드 셰이크에서 클라이언트는 서버에 설정된 키와 일치해야하는 키를 가져와야합니다. 키를 도출하는 정확한 알고리즘은 응용 프로그램에 따라 다릅니다. 그러나이 목적으로 서버는</target>
        </trans-unit>
        <trans-unit id="6218f8eee9e61e6aa5151636d0b2ccf7e487e310" translate="yes" xml:space="preserve">
          <source>In a Unicode context some positions in the text are not valid cursor positions, because the position is inside a Unicode surrogate or a grapheme cluster.</source>
          <target state="translated">유니 코드 컨텍스트에서 텍스트의 일부 위치는 유효한 커서 위치가 아닙니다. 위치가 유니 코드 대리자 또는 grapheme 클러스터 내에 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="5c39f0e8ca68705256be1acacf31347f7302d59a" translate="yes" xml:space="preserve">
          <source>In a Window without a tab bar, toolbar, or URL bar.</source>
          <target state="translated">탭 막대, 도구 모음 또는 URL 막대가없는 창에서.</target>
        </trans-unit>
        <trans-unit id="f5da8f790fb4231ba27c98ca26644ab6a296d548" translate="yes" xml:space="preserve">
          <source>In a class that uses &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtuitools-module.html&quot;&gt;QtUiTools&lt;/a&gt; to build its user interface at run time, we can locate objects in the form using &lt;a href=&quot;qobject#findChild&quot;&gt;QObject::findChild&lt;/a&gt;(). For example, in the following code, we locate some components based on their object names and widget types:</source>
          <target state="translated">&lt;a href=&quot;https://doc.qt.io/qt-5.13/qtuitools-module.html&quot;&gt;QtUiTools&lt;/a&gt; 를 사용하여 런타임에 사용자 인터페이스를 빌드 하는 클래스 에서 &lt;a href=&quot;qobject#findChild&quot;&gt;QObject :: findChild&lt;/a&gt; ()를 사용하여 양식에서 오브젝트를 찾을 수 있습니다 . 예를 들어 다음 코드에서 객체 이름과 위젯 유형을 기준으로 일부 구성 요소를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="5aa355897d713d5ad162616e9f25066da691a1b2" translate="yes" xml:space="preserve">
          <source>In a data-driven test, marks the row associated with</source>
          <target state="translated">데이터 기반 테스트에서 다음과 관련된 행을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="32b02425d9853ce65d20ccf60cd781de0c25f0fa" translate="yes" xml:space="preserve">
          <source>In a dialog, only one push button at a time can be the default button. This button is then displayed with an additional frame (depending on the GUI style).</source>
          <target state="translated">대화 상자에서 한 번에 하나의 푸시 버튼 만 기본 버튼이 될 수 있습니다. 그런 다음이 버튼은 GUI 스타일에 따라 추가 프레임과 함께 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="5840fc04c775cb5eafc17840ec2593d69d5e757d" translate="yes" xml:space="preserve">
          <source>In a dialog, you might create two data entry widgets and a label for each, and set up the geometry layout so each label is just to the left of its data entry widget (its &quot;buddy&quot;), for example:</source>
          <target state="translated">대화 상자에서 두 개의 데이터 입력 위젯과 각각에 대한 레이블을 작성하고 각 레이블이 데이터 입력 위젯의 왼쪽 ( &quot;버디&quot;)에 오도록 지오메트리 레이아웃을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0223a182442f7895c0406cf184e3f8f02061a818" translate="yes" xml:space="preserve">
          <source>In a directory listed in the &lt;code&gt;QMAKEFEATURES&lt;/code&gt; environment variable that contains a list of directories delimited by the platform's path list separator (colon for Unix, semicolon for Windows).</source>
          <target state="translated">플랫폼의 경로 목록 구분 기호 (UNIX의 경우 콜론, Windows의 경우 세미콜론)로 구분 된 디렉토리 목록을 포함하는 &lt;code&gt;QMAKEFEATURES&lt;/code&gt; 환경 변수에 나열된 디렉토리에서 .</target>
        </trans-unit>
        <trans-unit id="65e4400a6f0cc6b23439b153bd0bcdfaa94a1486" translate="yes" xml:space="preserve">
          <source>In a directory listed in the &lt;code&gt;QMAKEFEATURES&lt;/code&gt; property variable that contains a list of directories delimited by the platform's path list separator.</source>
          <target state="translated">플랫폼의 경로 목록 구분 기호로 구분 된 디렉토리 목록을 포함하는 &lt;code&gt;QMAKEFEATURES&lt;/code&gt; 특성 변수에 나열된 디렉토리에서 .</target>
        </trans-unit>
        <trans-unit id="3ff5c7a849ff5c8fe8062e09e1d7738485395550" translate="yes" xml:space="preserve">
          <source>In a features directory residing beneath the directory provided by the &lt;a href=&quot;qmake-environment-reference#qmakespec&quot;&gt;QMAKESPEC&lt;/a&gt; environment variable. For example: &lt;code&gt;$QMAKESPEC/&amp;lt;features&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;qmake-environment-reference#qmakespec&quot;&gt;QMAKESPEC&lt;/a&gt; 환경 변수가 제공하는 디렉토리 아래에있는 기능 디렉토리에서 . 예를 들어 &lt;code&gt;$QMAKESPEC/&amp;lt;features&amp;gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f60fa36c0fdf26b6763bb3e61aff44f2c4143e32" translate="yes" xml:space="preserve">
          <source>In a features directory residing in the &lt;code&gt;data_install/mkspecs&lt;/code&gt; directory. For example: &lt;code&gt;data_install/mkspecs/&amp;lt;features&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;data_install/mkspecs&lt;/code&gt; 디렉토리 에있는 기능 디렉토리에서 예를 들어 : &lt;code&gt;data_install/mkspecs/&amp;lt;features&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="074d7f8495491bc45054ca37812e0a8211941cb7" translate="yes" xml:space="preserve">
          <source>In a features directory residing within a &lt;code&gt;mkspecs&lt;/code&gt; directory. &lt;code&gt;mkspecs&lt;/code&gt; directories can be located beneath any of the directories listed in the &lt;code&gt;QMAKEPATH&lt;/code&gt; environment variable that contains a list of directories delimited by the platform's path list separator. For example: &lt;code&gt;$QMAKEPATH/mkspecs/&amp;lt;features&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mkspecs&lt;/code&gt; 디렉토리 내에있는 기능 디렉토리에서 . &lt;code&gt;mkspecs&lt;/code&gt; 디렉토리는 플랫폼의 경로 목록 분리 문자로 구분 된 디렉토리 목록을 포함하는 &lt;code&gt;QMAKEPATH&lt;/code&gt; 환경 변수에 나열된 디렉토리 아래에 위치 할 수 있습니다 . 예를 들어 &lt;code&gt;$QMAKEPATH/mkspecs/&amp;lt;features&amp;gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="057beeea1f96dcb8cf250e01fe97b0226a7d338e" translate="yes" xml:space="preserve">
          <source>In a features directory that exists as a sibling of the directory specified by the &lt;code&gt;QMAKESPEC&lt;/code&gt; environment variable. For example: &lt;code&gt;$QMAKESPEC/../&amp;lt;features&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;QMAKESPEC&lt;/code&gt; 환경 변수에 의해 지정된 디렉토리의 형제로 존재하는 기능 디렉토리에서 . 예를 들어 &lt;code&gt;$QMAKESPEC/../&amp;lt;features&amp;gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5456bb8b747a03034dc4d04d4a515509b5440144" translate="yes" xml:space="preserve">
          <source>In a framework project, this variable contains the name to be used for the framework that is built.</source>
          <target state="translated">프레임 워크 프로젝트에서이 변수에는 빌드 된 프레임 워크에 사용할 이름이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="cf0f5be9f92923592abdfcf59ee582bc84bb5458" translate="yes" xml:space="preserve">
          <source>In a future version, some may be marked as deploy-time static and be moved during the deployment step as an optimization. As selectors come with a performance cost, it is recommended to avoid their use in circumstances involving performance-critical code.</source>
          <target state="translated">향후 버전에서 일부는 배포시 정적으로 표시되고 배포 단계에서 최적화로 이동 될 수 있습니다. 선택기에 성능 비용이 발생하므로 성능에 중요한 코드가 포함 된 환경에서는 사용하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="57f591bcef10c6dbe2444406829777a8fc30da46" translate="yes" xml:space="preserve">
          <source>In a multi-process system, if one client has a memory leak and consumes lots of memory, that memory is recovered when that client exits. In contrast with single-process, the memory leak remains until the entire system restarts.</source>
          <target state="translated">다중 프로세스 시스템에서 한 클라이언트에 메모리 누수가 있고 많은 메모리를 사용하는 경우 해당 클라이언트가 종료 될 때 해당 메모리가 복구됩니다. 단일 프로세스와 달리 전체 시스템이 다시 시작될 때까지 메모리 누수가 남아 있습니다.</target>
        </trans-unit>
        <trans-unit id="b797d3e2bc0d1169f32746140230ecfa781372a8" translate="yes" xml:space="preserve">
          <source>In a non-const member function of &lt;code&gt;Employee&lt;/code&gt;, whenever the</source>
          <target state="translated">&lt;code&gt;Employee&lt;/code&gt; 의 비 const 멤버 함수 에서</target>
        </trans-unit>
        <trans-unit id="8af648be3237f594b90af346057fd024db5cd072" translate="yes" xml:space="preserve">
          <source>In a non-exclusive group, checking and unchecking actions does not affect the other actions in the group. Furthermore, the value of the &lt;a href=&quot;qml-qtquick-controls2-actiongroup#checkedAction-prop&quot;&gt;checkedAction&lt;/a&gt; property is &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">비 배타적 그룹에서 작업 확인 및 선택 해제는 그룹의 다른 작업에 영향을 미치지 않습니다. 또한 &lt;a href=&quot;qml-qtquick-controls2-actiongroup#checkedAction-prop&quot;&gt;checkedAction&lt;/a&gt; 속성 의 값 은 &lt;code&gt;null&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ecc1085249b660e214f6ce7b1f833baaba59a9dc" translate="yes" xml:space="preserve">
          <source>In a non-exclusive group, checking and unchecking buttons does not affect the other buttons in the group. Furthermore, the value of the &lt;a href=&quot;qml-qtquick-controls2-buttongroup#checkedButton-prop&quot;&gt;checkedButton&lt;/a&gt; property is &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">비 독점 그룹에서 버튼을 확인 및 선택 취소해도 그룹의 다른 버튼에는 영향을 미치지 않습니다. 또한 &lt;a href=&quot;qml-qtquick-controls2-buttongroup#checkedButton-prop&quot;&gt;checkedButton&lt;/a&gt; 속성 의 값 은 &lt;code&gt;null&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="47c8a951ead74ffc551cf228f129ac458a517bde" translate="yes" xml:space="preserve">
          <source>In a project file, variables are used to hold lists of strings. In the simplest projects, these variables inform qmake about the configuration options to use, or supply filenames and paths to use in the build process.</source>
          <target state="translated">프로젝트 파일에서 변수는 문자열 목록을 보유하는 데 사용됩니다. 가장 간단한 프로젝트에서이 변수는 qmake에게 사용할 구성 옵션을 알려주거나 빌드 프로세스에서 사용할 파일 이름과 경로를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c6d745760babbf9ff3b6f363a6bbf25b6fc4996b" translate="yes" xml:space="preserve">
          <source>In a project with multiple sub-projects (for example, Qt modules), each sub-project typically defines its own landing page while the same home page is used across all sub-projects.</source>
          <target state="translated">여러 하위 프로젝트 (예 : Qt 모듈)가있는 프로젝트에서 각 하위 프로젝트는 일반적으로 자체 방문 페이지를 정의하지만 모든 하위 프로젝트에서 동일한 홈 페이지가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="50a12001eea6b5a938330a3657e270c884c78bb9" translate="yes" xml:space="preserve">
          <source>In a read-only text edit the user can only navigate through the text and select text; modifying the text is not possible.</source>
          <target state="translated">읽기 전용 텍스트 편집에서 사용자는 텍스트를 탐색하고 텍스트 만 선택할 수 있습니다. 텍스트를 수정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="5c9aacdc19410c07bfb1fad74e785fca733026bd" translate="yes" xml:space="preserve">
          <source>In a real world scenario, you do not want to have dependencies of the application making use of the custom widgets to the</source>
          <target state="translated">실제 시나리오에서는 사용자 정의 위젯을 사용하는 애플리케이션이 애플리케이션에 종속되지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="35202bd5c646f9ca02c711f689dea2f022787aa8" translate="yes" xml:space="preserve">
          <source>In a separate Window.</source>
          <target state="translated">별도의 창에서.</target>
        </trans-unit>
        <trans-unit id="e66b37a78da29f7ea0ca0a0b99d6191a01fd3bdc" translate="yes" xml:space="preserve">
          <source>In a signal handler</source>
          <target state="translated">신호 처리기에서</target>
        </trans-unit>
        <trans-unit id="f70847208d54651f184f1d885d85b25a4cf196b7" translate="yes" xml:space="preserve">
          <source>In a similar manner only the center of a bounding box is taken into consideration when searching. The boundaries of the box are not honored.</source>
          <target state="translated">비슷한 방식으로 검색시 경계 상자의 중심 만 고려됩니다. 상자의 경계는 존중되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="124eb1a9a370c1e5f9d89da45e2d578d93580351" translate="yes" xml:space="preserve">
          <source>In a similar way, you can later use your customized XML file:</source>
          <target state="translated">비슷한 방식으로 나중에 사용자 정의 된 XML 파일을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3153a2a6f46323be3744bca7b05701c4ca2608a9" translate="yes" xml:space="preserve">
          <source>In a single-process system, all clients can access each other's memory. For example, there's no isolation for sensitive data transfer; every line of code must be equally trustworthy. This isolation is there, by design, in multi-process systems.</source>
          <target state="translated">단일 프로세스 시스템에서 모든 클라이언트는 서로의 메모리에 액세스 할 수 있습니다. 예를 들어 민감한 데이터 전송에 대한 격리는 없습니다. 모든 코드 줄은 똑같이 신뢰할 수 있어야합니다. 이러한 격리는 설계 상 다중 프로세스 시스템에 존재합니다.</target>
        </trans-unit>
        <trans-unit id="93cfe35695a7f4b787bebce9d4c376b5630c5bff" translate="yes" xml:space="preserve">
          <source>In a single-process system, all parts of the UI run in one, single process. In a multi-process system, all clients run in their own, dedicated process. With Qt, at any point in your development process, you can choose to switch between single-process and multi-process.</source>
          <target state="translated">단일 프로세스 시스템에서 UI의 모든 부분은 하나의 단일 프로세스에서 실행됩니다. 다중 프로세스 시스템에서 모든 클라이언트는 고유 한 전용 프로세스로 실행됩니다. Qt를 사용하면 개발 프로세스의 어느 시점에서나 단일 프로세스와 다중 프로세스간에 전환하도록 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="df30b4977c6a16aeadaeda81729eb4d5f6275427" translate="yes" xml:space="preserve">
          <source>In a single-process system, if you're using the same textures, background, or icons in many places, those images are only stored once. In contrast, if you use these images in a multi-process system, then you have to store them multiple times. In this case, one solution is to share graphical resource between clients. Qt already allows sharing image resources in main memory across processes without involving Wayland. Sharing GPU textures across processes, on the other hand, requires more intricate solutions. Such solutions are currently in development for the Qt Wayland Compositor.</source>
          <target state="translated">단일 프로세스 시스템에서 여러 곳에서 동일한 질감, 배경 또는 아이콘을 사용하는 경우 해당 이미지는 한 번만 저장됩니다. 반대로,이 이미지를 다중 프로세스 시스템에서 사용하는 경우 여러 번 저장해야합니다. 이 경우 한 솔루션은 클라이언트간에 그래픽 리소스를 공유하는 것입니다. Qt는 Wayland를 포함하지 않고 프로세스 전체에서 메인 메모리에 이미지 리소스를 공유 할 수 있습니다. 반면 프로세스간에 GPU 텍스처를 공유하려면보다 복잡한 솔루션이 필요합니다. 이러한 솔루션은 현재 Qt Wayland Compositor를 위해 개발 중입니다.</target>
        </trans-unit>
        <trans-unit id="0186a5ac830e37b10101828cfdbf3877f56f7125" translate="yes" xml:space="preserve">
          <source>In a situation such as the above, it is still possible to retrieve the actual matrix determinant by setting the RequiresDeterminant flag in the material and calling the &lt;a href=&quot;qsgmaterialshader-renderstate#determinant&quot;&gt;determinant&lt;/a&gt;() accessor.</source>
          <target state="translated">위와 같은 상황에서 머티리얼에 RequirementsDeterminant 플래그를 설정하고 &lt;a href=&quot;qsgmaterialshader-renderstate#determinant&quot;&gt;결정자&lt;/a&gt; () 접근 자를 호출하여 실제 행렬 결정자를 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="74ff351856fd5aa0b4dd6182c28bfc2e05f06733" translate="yes" xml:space="preserve">
          <source>In a tab of the same window, without hiding the currently visible web engine view.</source>
          <target state="translated">현재 보이는 웹 엔진보기를 숨기지 않고 동일한 창의 탭에서.</target>
        </trans-unit>
        <trans-unit id="ed375bcdf79a7ea9640ff4a86c37b210370ba4a7" translate="yes" xml:space="preserve">
          <source>In a tab of the same window.</source>
          <target state="translated">같은 창의 탭에서.</target>
        </trans-unit>
        <trans-unit id="2d5fcb572360924dfa9646ae46cfedc4060afe15" translate="yes" xml:space="preserve">
          <source>In a typical multi-head configuration, multiple physical monitors are combined in one X11 screen. This means this method returns the same number for each of the physical monitors. In such a setup you are interested in the monitor information as provided by the X11 RandR extension. This is available through QDesktopWidget and QScreen.</source>
          <target state="translated">일반적인 다중 헤드 구성에서는 여러 개의 물리적 모니터가 하나의 X11 화면에 결합됩니다. 이것은이 메소드가 각 물리적 모니터에 대해 동일한 수를 리턴 함을 의미합니다. 이러한 설정에서는 X11 RandR 확장에서 제공하는 모니터 정보에 관심이 있습니다. QDesktopWidget 및 QScreen을 통해 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="32434ce60c560ceb6a77ff3dda094acfb7645559" translate="yes" xml:space="preserve">
          <source>In a view, there is always a current item and a selected item - two independent states. An item can be the current item and selected at the same time. The view is responsible for ensuring that there is always a current item as keyboard navigation, for example, requires a current item.</source>
          <target state="translated">보기에는 항상 현재 항목과 선택한 항목 (두 개의 독립 상태)이 있습니다. 항목은 현재 항목 일 수 있으며 동시에 선택할 수 있습니다. 보기는 키보드 탐색으로 항상 현재 항목이 있는지 확인하는 역할을합니다 (예 : 현재 항목이 필요함).</target>
        </trans-unit>
        <trans-unit id="3af86b961f912e442202b68c4f0ceaec0a9a306c" translate="yes" xml:space="preserve">
          <source>In accordance with ISO 8601, weeks start on Monday and the first Thursday of a year is always in week 1 of that year. Most years have 52 weeks, but some have 53.</source>
          <target state="translated">ISO 8601에 따르면주는 월요일에 시작하여 일년의 첫 번째 목요일은 항상 그 해의 1 주에 있습니다. 대부분의 기간은 52 주이지만 일부는 53 주입니다.</target>
        </trans-unit>
        <trans-unit id="683d8c3e3a66c0acad5edcd82caa9ee007b84f7c" translate="yes" xml:space="preserve">
          <source>In addition &lt;a href=&quot;qaudiorecorder&quot;&gt;QAudioRecorder&lt;/a&gt; provides functionality for selecting the audio input.</source>
          <target state="translated">또한 &lt;a href=&quot;qaudiorecorder&quot;&gt;QAudioRecorder&lt;/a&gt; 는 오디오 입력을 선택하는 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c47cb2960d27520cc8cee5127eccd6ebc2460762" translate="yes" xml:space="preserve">
          <source>In addition &lt;a href=&quot;qpen&quot;&gt;QPen&lt;/a&gt; provides the &lt;a href=&quot;qpen#color&quot;&gt;color&lt;/a&gt;() and &lt;a href=&quot;qpen#setColor&quot;&gt;setColor&lt;/a&gt;() convenience functions to extract and set the color of the pen's brush, respectively. Pens may also be compared and streamed.</source>
          <target state="translated">또한 &lt;a href=&quot;qpen&quot;&gt;QPen&lt;/a&gt; 은 펜 브러시의 색상을 추출하고 설정 하는 &lt;a href=&quot;qpen#color&quot;&gt;색상&lt;/a&gt; () 및 &lt;a href=&quot;qpen#setColor&quot;&gt;setColor&lt;/a&gt; () 편의 기능을 각각 제공합니다. 펜을 비교하고 스트리밍 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a0379878d7d72c63efc971f1bdb08e5ede18e4c6" translate="yes" xml:space="preserve">
          <source>In addition the following expressions can be used to specify the time:</source>
          <target state="translated">또한 다음 표현식을 사용하여 시간을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="df9ef188c1cb674d205e023d5ddf6254baaafb97" translate="yes" xml:space="preserve">
          <source>In addition the type's QML file must have pragma Singleton statement among its import statements.</source>
          <target state="translated">또한 형식의 QML 파일에는 import 문 중 pragma Singleton 문이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="17d38f6932f39d7e48e129266f5198f583c62f19" translate="yes" xml:space="preserve">
          <source>In addition to &lt;a href=&quot;qaccessible&quot;&gt;QAccessible&lt;/a&gt;'s static functions, Qt offers one generic interface, &lt;a href=&quot;qaccessibleinterface&quot;&gt;QAccessibleInterface&lt;/a&gt;, that can be used to wrap all widgets and objects (e.g., &lt;a href=&quot;qpushbutton&quot;&gt;QPushButton&lt;/a&gt;). This single interface provides all the metadata necessary for the assistive technologies. Qt provides implementations of this interface for its built-in widgets as plugins.</source>
          <target state="translated">&lt;a href=&quot;qaccessible&quot;&gt;QAccessible&lt;/a&gt; 의 정적 함수 외에도 Qt는 모든 위젯과 객체 (예 : &lt;a href=&quot;qpushbutton&quot;&gt;QPushButton&lt;/a&gt; ) 를 래핑하는 데 사용할 수있는 하나의 일반 인터페이스 &lt;a href=&quot;qaccessibleinterface&quot;&gt;QAccessibleInterface를&lt;/a&gt; 제공합니다 . 이 단일 인터페이스는 보조 기술에 필요한 모든 메타 데이터를 제공합니다. Qt는 빌트인 위젯에 대해이 인터페이스의 구현을 플러그인으로 제공합니다.</target>
        </trans-unit>
        <trans-unit id="58764f3dc838568b7a78fe42c0db905846e95ebf" translate="yes" xml:space="preserve">
          <source>In addition to &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt;, Qt also provides the &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; class to store string data. For most purposes, &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; is the class you want to use. It stores 16-bit Unicode characters, making it easy to store non-ASCII/non-Latin-1 characters in your application. Furthermore, &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; is used throughout in the Qt API. The two main cases where &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; is appropriate are when you need to store raw binary data, and when memory conservation is critical (e.g., with Qt for Embedded Linux).</source>
          <target state="translated">&lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; 외에도 Qt는 문자열 데이터를 저장 하는 &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; 클래스를 제공합니다 . 대부분의 경우 &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; 은 사용하려는 클래스입니다. 16 비트 유니 코드 문자를 저장하므로 비 ASCII / 비 라틴 -1 문자를 응용 프로그램에 쉽게 저장할 수 있습니다. 또한 &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; 은 Qt API 전체에서 사용됩니다. &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; 가 적합한 두 가지 주요 경우 는 원시 이진 데이터를 저장해야 할 때와 메모리 절약이 중요한 경우입니다 (예 : 임베디드 Linux 용 Qt 사용).</target>
        </trans-unit>
        <trans-unit id="1fcc475fabc680f5d514ea0a74271c19204252af" translate="yes" xml:space="preserve">
          <source>In addition to &lt;a href=&quot;qsqlquery&quot;&gt;QSqlQuery&lt;/a&gt;, Qt offers three higher-level classes for accessing databases. These classes are &lt;a href=&quot;qsqlquerymodel&quot;&gt;QSqlQueryModel&lt;/a&gt;, &lt;a href=&quot;qsqltablemodel&quot;&gt;QSqlTableModel&lt;/a&gt;, and &lt;a href=&quot;qsqlrelationaltablemodel&quot;&gt;QSqlRelationalTableModel&lt;/a&gt;.</source>
          <target state="translated">Qt는 &lt;a href=&quot;qsqlquery&quot;&gt;QSqlQuery&lt;/a&gt; 외에도 데이터베이스에 액세스하기위한 3 가지 상위 레벨 클래스를 제공합니다. 이러한 클래스는 &lt;a href=&quot;qsqlquerymodel&quot;&gt;QSqlQueryModel&lt;/a&gt; , &lt;a href=&quot;qsqltablemodel&quot;&gt;QSqlTableModel&lt;/a&gt; 및 &lt;a href=&quot;qsqlrelationaltablemodel&quot;&gt;QSqlRelationalTableModel&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="bb0f23f32742c7c2e59f50364b2e13280c9d3869" translate="yes" xml:space="preserve">
          <source>In addition to &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;, Qt also provides the &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; class to store raw bytes and traditional 8-bit '\0'-terminated strings. For most purposes, &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; is the class you want to use. It is used throughout the Qt API, and the Unicode support ensures that your applications will be easy to translate if you want to expand your application's market at some point. The two main cases where &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; is appropriate are when you need to store raw binary data, and when memory conservation is critical (like in embedded systems).</source>
          <target state="translated">&lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; 외에도 Qt는 원시 바이트와 기존 8 비트 '\ 0'으로 끝나는 문자열을 저장 하는 &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; 클래스를 제공합니다 . 대부분의 경우 &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; 은 사용하려는 클래스입니다. Qt API 전체에서 사용되며 유니 코드 지원을 통해 특정 시점에서 애플리케이션 시장을 확장하려는 경우 애플리케이션을 쉽게 번역 할 수 있습니다. &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; 가 적합한 두 가지 주요 경우 는 원시 이진 데이터를 저장해야 할 때와 메모리 절약이 중요한 경우 (임베디드 시스템에서와 같이)입니다.</target>
        </trans-unit>
        <trans-unit id="0bb10a136edeed1290e419aec55791d22496b61f" translate="yes" xml:space="preserve">
          <source>In addition to &lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt;, Qt also provides &lt;a href=&quot;qvarlengtharray&quot;&gt;QVarLengthArray&lt;/a&gt;, a very low-level class with little functionality that is optimized for speed.</source>
          <target state="translated">&lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt; 외에도 Qt는 속도에 최적화 된 기능이 거의없는 매우 낮은 수준의 클래스 인 &lt;a href=&quot;qvarlengtharray&quot;&gt;QVarLengthArray&lt;/a&gt; 를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="f6dd8027e4df78dd3d3c0fe582211fdaf0b1a0fd" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;QT_QPA_EGLFS_DEBUG&lt;/code&gt;, &lt;code&gt;eglfs&lt;/code&gt; also supports Qt's modern categorized logging system. The following logging categories are available:</source>
          <target state="translated">뿐만 아니라 &lt;code&gt;QT_QPA_EGLFS_DEBUG&lt;/code&gt; , &lt;code&gt;eglfs&lt;/code&gt; 는 또한 Qt의 현대적인 분류 된 로깅 시스템을 지원합니다. 다음과 같은 로깅 범주를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="44b5febe92f9b7dabfe294b1a92afea290dc6cb8" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;QT_QPA_EGLFS_DEBUG&lt;/code&gt;, eglfs also supports the more modern categorized logging system of Qt. The following logging categories are available:</source>
          <target state="translated">뿐만 아니라 &lt;code&gt;QT_QPA_EGLFS_DEBUG&lt;/code&gt; , 또한 eglfs Qt는의 더 현대적인 분류 로깅 시스템을 지원합니다. 다음과 같은 로깅 범주를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9bf249f6281c6efae2c6fd1e64ccd58e52b76d3a" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;foreach&lt;/code&gt;, Qt also provides a &lt;code&gt;forever&lt;/code&gt; pseudo-keyword for infinite loops:</source>
          <target state="translated">&lt;code&gt;foreach&lt;/code&gt; 외에도 Qt는 무한 루프를위한 &lt;code&gt;forever&lt;/code&gt; 의사 키워드를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="c5cb3a1821f20774222d57b7872a2df90d980b43" translate="yes" xml:space="preserve">
          <source>In addition to OpenGL, the &lt;code&gt;software&lt;/code&gt; backend of Qt Quick also supports &lt;a href=&quot;qquickwidget&quot;&gt;QQuickWidget&lt;/a&gt;. Other backends, for example the Direct 3D 12 one, are not compatible however and attempting to construct a &lt;a href=&quot;qquickwidget&quot;&gt;QQuickWidget&lt;/a&gt; will lead to problems.</source>
          <target state="translated">Qt Quick 의 &lt;code&gt;software&lt;/code&gt; 백엔드는 OpenGL 외에도 &lt;a href=&quot;qquickwidget&quot;&gt;QQuickWidget&lt;/a&gt; 도 지원합니다 . Direct 3D 12와 같은 다른 백엔드는 호환되지 않으며 &lt;a href=&quot;qquickwidget&quot;&gt;QQuickWidget&lt;/a&gt; 을 구성하려고 하면 문제가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="325dae532505d0e5d00579590446e30e351abf77" translate="yes" xml:space="preserve">
          <source>In addition to being anchored to the map, the &lt;a href=&quot;qml-qtlocation-mapquickitem&quot;&gt;MapQuickItem&lt;/a&gt; can optionally follow the scale of the map, and change size when the Map is zoomed in or zoomed out. This behaviour is controlled by the &lt;a href=&quot;qml-qtlocation-mapquickitem#zoomLevel-prop&quot;&gt;zoomLevel&lt;/a&gt; property. The default behaviour if &lt;a href=&quot;qml-qtlocation-mapquickitem#zoomLevel-prop&quot;&gt;zoomLevel&lt;/a&gt; is not set is for the item to be drawn &quot;on the screen&quot; rather than &quot;on the map&quot;, so that its size remains the same regardless of the zoom level of the Map.</source>
          <target state="translated">&lt;a href=&quot;qml-qtlocation-mapquickitem&quot;&gt;MapQuickItem은지도&lt;/a&gt; 에 고정되어있을뿐만 아니라지도 의 배율을 따를 수 있으며지도가 확대 또는 축소 될 때 크기를 변경할 수 있습니다. 이 동작은 &lt;a href=&quot;qml-qtlocation-mapquickitem#zoomLevel-prop&quot;&gt;zoomLevel&lt;/a&gt; 속성으로 제어됩니다 . &lt;a href=&quot;qml-qtlocation-mapquickitem#zoomLevel-prop&quot;&gt;zoomLevel&lt;/a&gt; 이 설정되지 않은 경우 기본 동작 은 항목이 &quot;지도&quot;가 아닌 &quot;화면&quot;에 그려지는 것이므로 크기는지도의 확대 / 축소 수준에 관계없이 동일하게 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="222025e778efe8b0f64a49aca21af282baff2983" translate="yes" xml:space="preserve">
          <source>In addition to being used with &lt;a href=&quot;qopenglcontext#setNativeHandle&quot;&gt;QOpenGLContext::setNativeHandle&lt;/a&gt;(), this class is used also to retrieve the native context handle, that is, a HGLRC value, from a &lt;a href=&quot;qopenglcontext&quot;&gt;QOpenGLContext&lt;/a&gt;. Calling &lt;a href=&quot;qopenglcontext#nativeHandle&quot;&gt;QOpenGLContext::nativeHandle&lt;/a&gt;() returns a &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; which, on Windows with opengl32.dll at least, will contain a &lt;a href=&quot;qwglnativecontext&quot;&gt;QWGLNativeContext&lt;/a&gt;:</source>
          <target state="translated">함께 사용되는 외에 &lt;a href=&quot;qopenglcontext#setNativeHandle&quot;&gt;QOpenGLContext :: setNativeHandle&lt;/a&gt; ()이 클래스는에서하는 HGLRC 값입니다 기본 컨텍스트 핸들, 검색하는 데에도 사용됩니다 &lt;a href=&quot;qopenglcontext&quot;&gt;QOpenGLContext을&lt;/a&gt; . 호출 &lt;a href=&quot;qopenglcontext#nativeHandle&quot;&gt;QOpenGLContext :: nativeHandle는&lt;/a&gt; ()를 반환 &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; 이상에서, 포함 OPENGL32.DLL와, Windows에서 &lt;a href=&quot;qwglnativecontext&quot;&gt;QWGLNativeContext를&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="8821f95317c861f0b886a746e0a555a4702d6df9" translate="yes" xml:space="preserve">
          <source>In addition to calling the convenience event handlers, this function is responsible for converting mouse move events to hover events for when there is no mouse grabber item. Hover events are delivered directly to items; there is no convenience function for them.</source>
          <target state="translated">편의 이벤트 핸들러를 호출하는 것 외에도이 함수는 마우스 그래버 항목이 없을 때 마우스 이동 이벤트를 호버 이벤트로 변환합니다. 호버 이벤트는 항목으로 직접 전달됩니다. 그들에게는 편리한 기능이 없습니다.</target>
        </trans-unit>
        <trans-unit id="11c8e56658b7f7db09b4bc7da36d333b06677626" translate="yes" xml:space="preserve">
          <source>In addition to containing the item, scene, and screen coordinates of the event (as &lt;a href=&quot;qgraphicsscenemouseevent#pos&quot;&gt;pos&lt;/a&gt;(), &lt;a href=&quot;qgraphicsscenemouseevent#scenePos&quot;&gt;scenePos&lt;/a&gt;(), and &lt;a href=&quot;qgraphicsscenemouseevent#screenPos&quot;&gt;screenPos&lt;/a&gt;()), mouse events also contain the coordinates of the previous mouse event received by the view. These can be retrieved with &lt;a href=&quot;qgraphicsscenemouseevent#lastPos&quot;&gt;lastPos&lt;/a&gt;(), &lt;a href=&quot;qgraphicsscenemouseevent#lastScreenPos&quot;&gt;lastScreenPos&lt;/a&gt;(), and &lt;a href=&quot;qgraphicsscenemouseevent#lastScenePos&quot;&gt;lastScenePos&lt;/a&gt;().</source>
          <target state="translated">이벤트의 항목, 장면 및 화면 좌표 ( &lt;a href=&quot;qgraphicsscenemouseevent#pos&quot;&gt;pos&lt;/a&gt; (), &lt;a href=&quot;qgraphicsscenemouseevent#scenePos&quot;&gt;scenePos&lt;/a&gt; () 및 &lt;a href=&quot;qgraphicsscenemouseevent#screenPos&quot;&gt;screenPos&lt;/a&gt; ())를 포함하는 것 외에도 마우스 이벤트에는보기에서 수신 한 이전 마우스 이벤트의 좌표도 포함됩니다. 이들은 &lt;a href=&quot;qgraphicsscenemouseevent#lastPos&quot;&gt;lastPos&lt;/a&gt; (), &lt;a href=&quot;qgraphicsscenemouseevent#lastScreenPos&quot;&gt;lastScreenPos&lt;/a&gt; () 및 &lt;a href=&quot;qgraphicsscenemouseevent#lastScenePos&quot;&gt;lastScenePos&lt;/a&gt; () 로 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f539b7194ee987de596fca3b232ace808aad2ce7" translate="yes" xml:space="preserve">
          <source>In addition to controlling the management of widgets, you can control the current selection in the form window using the &lt;a href=&quot;qdesignerformwindowinterface#selectWidget&quot;&gt;selectWidget&lt;/a&gt;(), &lt;a href=&quot;qdesignerformwindowinterface#clearSelection&quot;&gt;clearSelection&lt;/a&gt;() and &lt;a href=&quot;qdesignerformwindowinterface#emitSelectionChanged&quot;&gt;emitSelectionChanged&lt;/a&gt;() functions, and the &lt;a href=&quot;qdesignerformwindowinterface#selectionChanged&quot;&gt;selectionChanged&lt;/a&gt;() signal.</source>
          <target state="translated">위젯 관리를 제어하는 ​​것 외에도 &lt;a href=&quot;qdesignerformwindowinterface#selectWidget&quot;&gt;selectWidget&lt;/a&gt; (), &lt;a href=&quot;qdesignerformwindowinterface#clearSelection&quot;&gt;clearSelection&lt;/a&gt; () 및 &lt;a href=&quot;qdesignerformwindowinterface#emitSelectionChanged&quot;&gt;emitSelectionChanged&lt;/a&gt; () 함수 및 &lt;a href=&quot;qdesignerformwindowinterface#selectionChanged&quot;&gt;selectionChanged&lt;/a&gt; () 신호를 사용하여 양식 창에서 현재 선택을 제어 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2749249d61fcba3d628135453123502aee7c5881" translate="yes" xml:space="preserve">
          <source>In addition to coordinate based data, it is possible to attach an arbitrary data channel for each data point.</source>
          <target state="translated">좌표 기반 데이터 외에도 각 데이터 포인트에 대해 임의의 데이터 채널을 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="860442a28b85ce7c77a454c3e2b9c8a9e8a96e88" translate="yes" xml:space="preserve">
          <source>In addition to core XML support, classes for higher level querying and manipulation of XML data are provided by the Qt XML Patterns module. In the Qt SVG module, the QSvgRenderer and QSvgGenerator classes can read and write a subset of SVG, an XML-based file format. Qt also provides helper functions that may be useful to those working with XML and XHTML: see Qt::escape() and Qt::convertFromPlainText().</source>
          <target state="translated">핵심 XML 지원 외에도 Qt XML 패턴 모듈에서 XML 데이터의 고급 쿼리 및 조작을위한 클래스를 제공합니다. Qt SVG 모듈에서 QSvgRenderer 및 QSvgGenerator 클래스는 XML 기반 파일 형식 인 SVG의 서브 세트를 읽고 쓸 수 있습니다. Qt는 또한 XML 및 XHTML로 작업하는 사람들에게 유용한 도우미 함수를 제공합니다. Qt :: escape () 및 Qt :: convertFromPlainText ()를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="96ab0ff9ab1deb68ff7f11842fa6faa44833ae75" translate="yes" xml:space="preserve">
          <source>In addition to data provided by the expression's &lt;a href=&quot;qqmlcontext&quot;&gt;QQmlContext&lt;/a&gt;, the scope object's properties are also in scope during the expression's evaluation.</source>
          <target state="translated">표현식의 &lt;a href=&quot;qqmlcontext&quot;&gt;QQmlContext가&lt;/a&gt; 제공하는 데이터 외에 , 표현식의 평가 중에 범위 오브젝트의 특성도 범위에 있습니다.</target>
        </trans-unit>
        <trans-unit id="30bca362e71a3024326276c40634885f8c55e764" translate="yes" xml:space="preserve">
          <source>In addition to defining which column the data belongs to, the value indicated by the column role is also set as the X-coordinate value of &lt;a href=&quot;qsurfacedataitem&quot;&gt;QSurfaceDataItem&lt;/a&gt; when model data is resolved, unless a separate x position role is also defined.</source>
          <target state="translated">데이터가 속하는 열을 정의하는 것 외에 , 별도의 x 위치 역할이 정의되지 않은 경우 모델 데이터가 해석 될 때 열 역할이 나타내는 값은 &lt;a href=&quot;qsurfacedataitem&quot;&gt;QSurfaceDataItem&lt;/a&gt; 의 X 좌표 값으로 설정 됩니다.</target>
        </trans-unit>
        <trans-unit id="3a366a9f9c645932396430dfd059e8111420d987" translate="yes" xml:space="preserve">
          <source>In addition to defining which row the data belongs to, the value indicated by the row role is also set as the Z-coordinate value of &lt;a href=&quot;qsurfacedataitem&quot;&gt;QSurfaceDataItem&lt;/a&gt; when model data is resolved, unless a separate z position role is also defined.</source>
          <target state="translated">데이터가 속하는 행을 정의하는 것 외에도 , 별도의 z 위치 역할이 정의되지 않은 경우 모델 데이터가 해석 될 때 행 역할이 나타내는 값은 &lt;a href=&quot;qsurfacedataitem&quot;&gt;QSurfaceDataItem&lt;/a&gt; 의 Z 좌표 값으로 설정 됩니다.</target>
        </trans-unit>
        <trans-unit id="cf401cf475e46f85bb0131da5516bd0be8251b32" translate="yes" xml:space="preserve">
          <source>In addition to drawing, the style needs to provide the widgets with information on which sub control (if any) a mouse press was made on. For instance, a &lt;a href=&quot;qscrollbar&quot;&gt;QScrollBar&lt;/a&gt; needs to know if the user pressed the slider, the slider groove, or one of the buttons.</source>
          <target state="translated">그리기 외에도 스타일은 위젯에 마우스를 누른 하위 제어 (있는 경우)에 대한 정보를 제공해야합니다. 예를 들어, &lt;a href=&quot;qscrollbar&quot;&gt;QScrollBar&lt;/a&gt; 는 사용자가 슬라이더, 슬라이더 그루브 또는 버튼 중 하나를 눌렀는지 알아야합니다.</target>
        </trans-unit>
        <trans-unit id="d9d9c59d69e027e39f0ec4fbe75766e3dadc6e3f" translate="yes" xml:space="preserve">
          <source>In addition to event handling, the &lt;a href=&quot;qvulkanwindow&quot;&gt;QVulkanWindow&lt;/a&gt; subclass is responsible for providing an implementation for &lt;a href=&quot;qvulkanwindow#createRenderer&quot;&gt;QVulkanWindow::createRenderer&lt;/a&gt;() as well. This is where the window and renderer get connected. A typical implementation will simply create a new instance of a subclass of &lt;a href=&quot;qvulkanwindowrenderer&quot;&gt;QVulkanWindowRenderer&lt;/a&gt;.</source>
          <target state="translated">이벤트 처리 외에도 &lt;a href=&quot;qvulkanwindow&quot;&gt;QVulkanWindow&lt;/a&gt; 서브 클래스는 &lt;a href=&quot;qvulkanwindow#createRenderer&quot;&gt;QVulkanWindow :: createRenderer&lt;/a&gt; ()에 대한 구현을 제공합니다 . 이것은 윈도우와 렌더러가 연결되는 곳입니다. 일반적인 구현은 &lt;a href=&quot;qvulkanwindowrenderer&quot;&gt;QVulkanWindowRenderer&lt;/a&gt; 의 서브 클래스의 새 인스턴스를 작성합니다 .</target>
        </trans-unit>
        <trans-unit id="6193b0f82c7728f2fba62b9bb5e211c3d6071a88" translate="yes" xml:space="preserve">
          <source>In addition to groups, &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; also supports an &quot;array&quot; concept. See &lt;a href=&quot;qsettings#beginReadArray&quot;&gt;beginReadArray&lt;/a&gt;() and &lt;a href=&quot;qsettings#beginWriteArray&quot;&gt;beginWriteArray&lt;/a&gt;() for details.</source>
          <target state="translated">그룹 외에도 &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; 는 &quot;배열&quot;개념도 지원합니다. 자세한 내용은 &lt;a href=&quot;qsettings#beginReadArray&quot;&gt;beginReadArray&lt;/a&gt; () 및 &lt;a href=&quot;qsettings#beginWriteArray&quot;&gt;beginWriteArray&lt;/a&gt; ()를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3868ec7d585a5a461a3c76d6bc8a4bbf85befd24" translate="yes" xml:space="preserve">
          <source>In addition to merging compatible primitives into batches, the default renderer also tries to minimize the amount of data that needs to be sent to the GPU for every frame. The default renderer identifies subtrees which belong together and tries to put these into separate batches. Once batches are identified, they are merged, uploaded and stored in GPU memory, using Vertex Buffer Objects.</source>
          <target state="translated">호환 가능한 프리미티브를 배치로 병합하는 것 외에도 기본 렌더러는 모든 프레임에 대해 GPU로 전송해야하는 데이터 양을 최소화하려고합니다. 기본 렌더러는 서로 속한 하위 트리를 식별하여 별도의 배치에 배치하려고합니다. 배치가 식별되면 버텍스 버퍼 객체를 사용하여 GPU 메모리에 병합, 업로드 및 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="ed5456d2bef1e65628af0ed642141020a0888549" translate="yes" xml:space="preserve">
          <source>In addition to normal file downloads, which consist simply of retrieving some raw bytes from the network and writing them to disk, Qt WebEngine also supports saving complete web pages, which involves parsing the page's HTML, downloading any dependent resources, and potentially packaging everything into a special file format (&lt;a href=&quot;qml-qtwebengine-webenginedownloaditem#savePageFormat-prop&quot;&gt;savePageFormat&lt;/a&gt;). To check if a download is for a file or a web page, use &lt;a href=&quot;qml-qtwebengine-webenginedownloaditem#isSavePageDownload-prop&quot;&gt;isSavePageDownload&lt;/a&gt;.</source>
          <target state="translated">Qt WebEngine은 네트워크에서 일부 원시 바이트를 검색하여 디스크에 쓰는 간단한 파일 다운로드 외에도 페이지의 HTML 구문 분석, 종속 리소스 다운로드 및 잠재적으로 모든 것을 패키징하는 완전한 웹 페이지 저장을 지원합니다. 특수 파일 형식 ( &lt;a href=&quot;qml-qtwebengine-webenginedownloaditem#savePageFormat-prop&quot;&gt;savePageFormat&lt;/a&gt; ) 다운로드가 파일 또는 웹 페이지 용인지 확인하려면 &lt;a href=&quot;qml-qtwebengine-webenginedownloaditem#isSavePageDownload-prop&quot;&gt;isSavePageDownload를&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="f8483c9f7066fd3ab82bade1bce9da25ae1c8d54" translate="yes" xml:space="preserve">
          <source>In addition to normal file downloads, which consist simply of retrieving some raw bytes from the network and writing them to disk, Qt WebEngine also supports saving complete web pages, which involves parsing the page's HTML, downloading any dependent resources, and potentially packaging everything into a special file format (&lt;a href=&quot;qwebenginedownloaditem#savePageFormat&quot;&gt;savePageFormat&lt;/a&gt;). To check if a download is for a file or a web page, use &lt;a href=&quot;qwebenginedownloaditem#isSavePageDownload&quot;&gt;isSavePageDownload&lt;/a&gt;.</source>
          <target state="translated">Qt WebEngine은 네트워크에서 일부 원시 바이트를 검색하여 디스크에 쓰는 간단한 파일 다운로드 외에도 페이지의 HTML 구문 분석, 종속 리소스 다운로드 및 잠재적으로 모든 것을 패키징하는 완전한 웹 페이지 저장을 지원합니다. 특수 파일 형식 ( &lt;a href=&quot;qwebenginedownloaditem#savePageFormat&quot;&gt;savePageFormat&lt;/a&gt; ) 다운로드가 파일 또는 웹 페이지 용인지 확인하려면 &lt;a href=&quot;qwebenginedownloaditem#isSavePageDownload&quot;&gt;isSavePageDownload를&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="76f5c232a66c386c0de18bdee8c0604283addb0f" translate="yes" xml:space="preserve">
          <source>In addition to parsing the options (like &lt;a href=&quot;qcommandlineparser#parse&quot;&gt;parse&lt;/a&gt;()), this function also handles the builtin options and handles errors.</source>
          <target state="translated">이 함수는 옵션 &lt;a href=&quot;qcommandlineparser#parse&quot;&gt;구문 분석&lt;/a&gt; (예 : 구문 분석 ()) 외에도 기본 제공 옵션을 처리하고 오류를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="4f4a60305692fbef8b1954acf1606abde5b6592e" translate="yes" xml:space="preserve">
          <source>In addition to perspective projection, orthographic projection can be used to create 2D graphs by replacing the default input handler with one that does not allow rotating the graph and setting the camera to view the graph directly from the side or from the top.</source>
          <target state="translated">투시 투영 외에도 직교 투영을 사용하여 기본 입력 핸들러를 그래프 회전을 허용하지 않는 것으로 대체하고 카메라를 측면 또는 상단에서 그래프를 직접 볼 수 있도록 설정하여 2D 그래프를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1361d6305eba16b69a305d034e7abe8e488775cb" translate="yes" xml:space="preserve">
          <source>In addition to providing the &lt;a href=&quot;signalsandslots#&quot;&gt;signals and slots&lt;/a&gt; mechanism for communication between objects (the main reason for introducing the system), the meta-object code provides the following additional features:</source>
          <target state="translated">메타 객체 코드는 객체 간 통신을위한 &lt;a href=&quot;signalsandslots#&quot;&gt;신호 및 슬롯&lt;/a&gt; 메커니즘 을 제공 할뿐만 아니라 (시스템을 도입 한 주된 이유) 다음과 같은 추가 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="608863a3b34aea5eafec5a706f8343d6c33db486" translate="yes" xml:space="preserve">
          <source>In addition to setting state flags the &lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption&lt;/a&gt; contains other information about the widget: &lt;code&gt;direction&lt;/code&gt; is the layout direction of the layout, &lt;code&gt;rect&lt;/code&gt; is the bounding rectangle of the widget (the area in which to draw), &lt;code&gt;palette&lt;/code&gt; is the &lt;a href=&quot;qpalette&quot;&gt;QPalette&lt;/a&gt; that should be used for drawing the widget, and &lt;code&gt;fontMetrics&lt;/code&gt; is the metrics of the font that is used by the widget.</source>
          <target state="translated">상태 플래그를 설정하는 것 외에도 &lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption&lt;/a&gt; 에는 위젯에 대한 다른 정보가 포함됩니다. &lt;code&gt;direction&lt;/code&gt; 은 레이아웃의 레이아웃 방향이고, &lt;code&gt;rect&lt;/code&gt; 는 위젯의 경계 사각형 (그리기 영역)이며, &lt;code&gt;palette&lt;/code&gt; 는 사용해야 하는 &lt;a href=&quot;qpalette&quot;&gt;QPalette&lt;/a&gt; 입니다. 위젯 그리기 및 &lt;code&gt;fontMetrics&lt;/code&gt; 는 위젯에서 사용하는 글꼴의 메트릭입니다.</target>
        </trans-unit>
        <trans-unit id="e97c71f5c8ffe70cd236c7a10dfbb4138631b3c2" translate="yes" xml:space="preserve">
          <source>In addition to sorting, &lt;a href=&quot;qsortfilterproxymodel&quot;&gt;QSortFilterProxyModel&lt;/a&gt; can be used to hide items that do not match a certain filter. The filter is specified using a &lt;a href=&quot;qregexp&quot;&gt;QRegExp&lt;/a&gt; object and is applied to the &lt;a href=&quot;qsortfilterproxymodel#filterRole-prop&quot;&gt;filterRole&lt;/a&gt;() (&lt;a href=&quot;qt#ItemDataRole-enum&quot;&gt;Qt::DisplayRole&lt;/a&gt; by default) of each item, for a given column. The &lt;a href=&quot;qregexp&quot;&gt;QRegExp&lt;/a&gt; object can be used to match a regular expression, a wildcard pattern, or a fixed string. For example:</source>
          <target state="translated">정렬 외에도 &lt;a href=&quot;qsortfilterproxymodel&quot;&gt;QSortFilterProxyModel&lt;/a&gt; 을 사용하여 특정 필터와 일치하지 않는 항목을 숨길 수 있습니다. 필터는 &lt;a href=&quot;qregexp&quot;&gt;QRegExp&lt;/a&gt; 객체를 사용하여 지정 되며 주어진 열에 대해 각 항목 의 &lt;a href=&quot;qsortfilterproxymodel#filterRole-prop&quot;&gt;filterRole&lt;/a&gt; () ( 기본적으로 &lt;a href=&quot;qt#ItemDataRole-enum&quot;&gt;Qt :: DisplayRole&lt;/a&gt; )에 적용 됩니다. &lt;a href=&quot;qregexp&quot;&gt;QRegExp의&lt;/a&gt; 객체는 정규 표현식 와일드 카드 패턴 또는 고정 된 문자열과 일치하는 데 사용할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5b8eb1ee7525ba77b95e29b40ab1fbfd79676d3b" translate="yes" xml:space="preserve">
          <source>In addition to specifying the attributes in QML, it is also possible to specify them via environment variables or in a configuration file. Attributes specified in QML take precedence over all other methods.</source>
          <target state="translated">QML에서 속성을 지정하는 것 외에도 환경 변수 또는 구성 파일을 통해 속성을 지정할 수도 있습니다. QML에 지정된 속성은 다른 모든 방법보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="0155e0a679d61241e117c2329f6d0d979bde7477" translate="yes" xml:space="preserve">
          <source>In addition to specifying the path in QML, it is also possible to specify it via an &lt;a href=&quot;#imagine-customization-environment-variable&quot;&gt;environment variable&lt;/a&gt; or in a &lt;a href=&quot;#imagine-customization-configuration-file&quot;&gt;configuration file&lt;/a&gt;. Attributes specified in QML take precedence over all other methods.</source>
          <target state="translated">QML에서 경로를 지정하는 것 외에도 &lt;a href=&quot;#imagine-customization-environment-variable&quot;&gt;환경 변수&lt;/a&gt; 또는 &lt;a href=&quot;#imagine-customization-configuration-file&quot;&gt;구성 파일을&lt;/a&gt; 통해 경로를 지정할 수도 있습니다 . QML에 지정된 속성은 다른 모든 방법보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="ec764b284bd78c68c070ec70cb6943f8decbe9f1" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;a href=&quot;qsensorgesture#detected&quot;&gt;QSensorGesture::detected&lt;/a&gt;() signal, Sensor Gesture Recognizers can have their own specific signals, and may be discovered through &lt;a href=&quot;qsensorgesture#gestureSignals&quot;&gt;QSensorGesture::gestureSignals&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qsensorgesture#detected&quot;&gt;QSensorGesture :: detected&lt;/a&gt; () 신호 외에도 Sensor Gesture Recognizer는 고유 한 특정 신호를 가질 수 있으며 &lt;a href=&quot;qsensorgesture#gestureSignals&quot;&gt;QSensorGesture :: gestureSignals&lt;/a&gt; ()를 통해 검색 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="52c782ad46d1294574253126cd5c9c5f784d753b" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;a href=&quot;qtqml-typesystem-basictypes#&quot;&gt;QML Basic Types&lt;/a&gt;, the module comes with the following QML object types:</source>
          <target state="translated">&lt;a href=&quot;qtqml-typesystem-basictypes#&quot;&gt;QML 기본 유형&lt;/a&gt; 외에도 모듈에는 다음과 같은 QML 오브젝트 유형이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="417e8f4aadd4e491d8bdc2da3b8079084ab4beec" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;code&gt;index&lt;/code&gt; property, a list of model data roles are available in the context of each delegate:</source>
          <target state="translated">&lt;code&gt;index&lt;/code&gt; 속성 외에도 각 대리인의 컨텍스트에서 모델 데이터 역할 목록을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a3ef24a6177217e50cdd9ee78dfc67377f72be66" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;code&gt;win32&lt;/code&gt;, &lt;code&gt;macx&lt;/code&gt;, and &lt;code&gt;unix&lt;/code&gt; values used in many scope conditions, various other built-in platform and compiler-specific values can be tested with scopes. These are based on platform specifications provided in Qt's &lt;code&gt;mkspecs&lt;/code&gt; directory. For example, the following lines from a project file show the current specification in use and test for the &lt;code&gt;linux-g++&lt;/code&gt; specification:</source>
          <target state="translated">받는 사람 또한 &lt;code&gt;win32&lt;/code&gt; , &lt;code&gt;macx&lt;/code&gt; 및 &lt;code&gt;unix&lt;/code&gt; 많은 범위의 조건에서 사용하는 값, 다양한 내장 플랫폼과 컴파일러 특정 값 범위로 테스트 할 수 있습니다. 이는 Qt의 &lt;code&gt;mkspecs&lt;/code&gt; 디렉토리에 제공된 플랫폼 사양을 기반으로합니다 . 예를 들어, 프로젝트 파일의 다음 줄은 현재 사용중인 사양을 표시하고 &lt;code&gt;linux-g++&lt;/code&gt; 사양을 테스트합니다 .</target>
        </trans-unit>
        <trans-unit id="7af3e3298d92ef46918d809b8a96064abbcc8ca4" translate="yes" xml:space="preserve">
          <source>In addition to the checked and unchecked states, there is a third state: partially checked. The partially checked state can be enabled using the &lt;a href=&quot;qml-qtquick-controls2-checkbox#tristate-prop&quot;&gt;tristate&lt;/a&gt; property. This state indicates that the regular checked/unchecked state can not be determined; generally because of other states that affect the checkbox. This state is useful when several child nodes are selected in a treeview, for example.</source>
          <target state="translated">확인 및 확인되지 않은 상태 외에도 세 번째 상태 인 부분 확인이 있습니다. &lt;a href=&quot;qml-qtquick-controls2-checkbox#tristate-prop&quot;&gt;tristate&lt;/a&gt; 속성을 사용하여 부분적으로 검사 된 상태를 활성화 할 수 있습니다 . 이 상태는 일반 점검 / 검사되지 않은 상태를 판별 할 수 없음을 나타냅니다. 일반적으로 확인란에 영향을 미치는 다른 상태 때문입니다. 이 상태는 예를 들어 트 리뷰에서 여러 자식 노드가 선택된 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="30fe8d793a4d1dc565113d3ae097c00698b55f22" translate="yes" xml:space="preserve">
          <source>In addition to the checked and unchecked states, there is a third state: partially checked. The partially checked state can be enabled using the &lt;a href=&quot;qml-qtquick-controls2-checkdelegate#tristate-prop&quot;&gt;tristate&lt;/a&gt; property. This state indicates that the regular checked/unchecked state can not be determined; generally because of other states that affect the check delegate. This state is useful when several child nodes are selected in a treeview, for example.</source>
          <target state="translated">확인 및 확인되지 않은 상태 외에도 세 번째 상태 인 부분 확인이 있습니다. &lt;a href=&quot;qml-qtquick-controls2-checkdelegate#tristate-prop&quot;&gt;tristate&lt;/a&gt; 속성을 사용하여 부분적으로 검사 된 상태를 활성화 할 수 있습니다 . 이 상태는 일반 점검 / 검사되지 않은 상태를 판별 할 수 없음을 나타냅니다. 일반적으로 수표 대리자에게 영향을주는 다른 상태 때문입니다. 이 상태는 예를 들어 트 리뷰에서 여러 자식 노드가 선택된 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="eab7e7dd6c4505763be2492ac8ad26d746b93263" translate="yes" xml:space="preserve">
          <source>In addition to the checked and unchecked states, there is a third state: partially checked. This state indicates that the regular checked/unchecked state can not be determined; generally because of other states that affect the checkbox. This state is useful when several child nodes are selected in a treeview, for example.</source>
          <target state="translated">확인 및 확인되지 않은 상태 외에도 세 번째 상태 인 부분 확인이 있습니다. 이 상태는 일반 점검 / 검사되지 않은 상태를 판별 할 수 없음을 나타냅니다. 일반적으로 확인란에 영향을 미치는 다른 상태 때문입니다. 이 상태는 예를 들어 트 리뷰에서 여러 자식 노드가 선택된 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="6a017e3c2b18cce999dbad22cc20e6564e42134b" translate="yes" xml:space="preserve">
          <source>In addition to the compiled-in</source>
          <target state="translated">컴파일 된 것 외에도</target>
        </trans-unit>
        <trans-unit id="9eaf3e7f3dcb62f52f067b4b06b4c1eb3965285c" translate="yes" xml:space="preserve">
          <source>In addition to the encoding, &lt;a href=&quot;qaudioformat&quot;&gt;QAudioFormat&lt;/a&gt; contains other parameters that further specify how the audio sample data is arranged. These are the frequency, the number of channels, the sample size, the sample type, and the byte order. The following table describes these in more detail.</source>
          <target state="translated">인코딩 외에도 &lt;a href=&quot;qaudioformat&quot;&gt;QAudioFormat&lt;/a&gt; 에는 오디오 샘플 데이터의 배열 방식을 추가로 지정하는 다른 매개 변수가 포함되어 있습니다. 주파수, 채널 수, 샘플 크기, 샘플 유형 및 바이트 순서입니다. 다음 표는 이들에 대해 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="01161f1235543028af2e64aca9b51ee52eb5c08f" translate="yes" xml:space="preserve">
          <source>In addition to the functions inherited from &lt;a href=&quot;qgradient&quot;&gt;QGradient&lt;/a&gt;, the &lt;a href=&quot;qconicalgradient&quot;&gt;QConicalGradient&lt;/a&gt; class provides the &lt;a href=&quot;qconicalgradient#angle&quot;&gt;angle&lt;/a&gt;() and &lt;a href=&quot;qconicalgradient#center&quot;&gt;center&lt;/a&gt;() functions returning the start angle and center of the gradient.</source>
          <target state="translated">&lt;a href=&quot;qgradient&quot;&gt;QGradient&lt;/a&gt; 에서 상속 된 함수 외에도 &lt;a href=&quot;qconicalgradient&quot;&gt;QConicalGradient&lt;/a&gt; 클래스는 그라디언트의 시작 각도와 중심을 반환하는 &lt;a href=&quot;qconicalgradient#angle&quot;&gt;각도&lt;/a&gt; () 및 &lt;a href=&quot;qconicalgradient#center&quot;&gt;중심&lt;/a&gt; () 함수를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="877fb9f84fc362bbe3e371e803b3b05e197b5c8f" translate="yes" xml:space="preserve">
          <source>In addition to the functions inherited from &lt;a href=&quot;qgradient&quot;&gt;QGradient&lt;/a&gt;, the &lt;a href=&quot;qlineargradient&quot;&gt;QLinearGradient&lt;/a&gt; class provides the &lt;a href=&quot;qlineargradient#finalStop&quot;&gt;finalStop&lt;/a&gt;() function which returns the final stop point of the gradient, and the &lt;a href=&quot;qlineargradient#start&quot;&gt;start&lt;/a&gt;() function returning the start point of the gradient.</source>
          <target state="translated">&lt;a href=&quot;qgradient&quot;&gt;QGradient&lt;/a&gt; 에서 상속 된 함수 외에도 &lt;a href=&quot;qlineargradient&quot;&gt;QLinearGradient&lt;/a&gt; 클래스는 그라디언트의 최종 정지 점을 반환 하는 &lt;a href=&quot;qlineargradient#finalStop&quot;&gt;finalStop&lt;/a&gt; () 함수와 그라디언트의 &lt;a href=&quot;qlineargradient#start&quot;&gt;시작점을&lt;/a&gt; 반환하는 start () 함수를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="ac59c2d44b382d3ea1218ff478b5b46bdb551e68" translate="yes" xml:space="preserve">
          <source>In addition to the functions inherited from &lt;a href=&quot;qgradient&quot;&gt;QGradient&lt;/a&gt;, the &lt;a href=&quot;qradialgradient&quot;&gt;QRadialGradient&lt;/a&gt; class provides the &lt;a href=&quot;qradialgradient#center&quot;&gt;center&lt;/a&gt;(), &lt;a href=&quot;qradialgradient#focalPoint&quot;&gt;focalPoint&lt;/a&gt;() and &lt;a href=&quot;qradialgradient#radius&quot;&gt;radius&lt;/a&gt;() functions returning the gradient's center, focal point and radius respectively.</source>
          <target state="translated">로부터 계승하는 기능 이외에 &lt;a href=&quot;qgradient&quot;&gt;QGradient&lt;/a&gt; 상기 &lt;a href=&quot;qradialgradient&quot;&gt;QRadialGradient의&lt;/a&gt; 클래스가 제공 &lt;a href=&quot;qradialgradient#center&quot;&gt;센터&lt;/a&gt; () &lt;a href=&quot;qradialgradient#focalPoint&quot;&gt;focalPoint&lt;/a&gt; () 및 &lt;a href=&quot;qradialgradient#radius&quot;&gt;반경&lt;/a&gt; () 각각의 경사 중심 초점 반경 복귀 기능.</target>
        </trans-unit>
        <trans-unit id="90cb87a4726b92cf26795c1b0b605c676ee538e3" translate="yes" xml:space="preserve">
          <source>In addition to the functions provided by &lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt;, &lt;a href=&quot;qpolygon&quot;&gt;QPolygon&lt;/a&gt; provides some point-specific functions.</source>
          <target state="translated">&lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt; 에서 제공하는 기능 외에도 &lt;a href=&quot;qpolygon&quot;&gt;QPolygon&lt;/a&gt; 은 일부 점별 기능을 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="0af4b5582ced69e4efe9d71c097c3238d24bc513" translate="yes" xml:space="preserve">
          <source>In addition to the functions provided by &lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt;, &lt;a href=&quot;qpolygonf&quot;&gt;QPolygonF&lt;/a&gt; provides the &lt;a href=&quot;qpolygonf#boundingRect&quot;&gt;boundingRect&lt;/a&gt;() and &lt;a href=&quot;qpolygonf#translate&quot;&gt;translate&lt;/a&gt;() functions for geometry operations. Use the &lt;a href=&quot;qmatrix#map&quot;&gt;QMatrix::map&lt;/a&gt;() function for more general transformations of QPolygonFs.</source>
          <target state="translated">&lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt; 에서 제공하는 함수 외에도 &lt;a href=&quot;qpolygonf&quot;&gt;QPolygonF&lt;/a&gt; 는 지오메트리 작업에 대한 &lt;a href=&quot;qpolygonf#boundingRect&quot;&gt;boundingRect&lt;/a&gt; () 및 &lt;a href=&quot;qpolygonf#translate&quot;&gt;translate&lt;/a&gt; () 함수를 제공합니다. QPolygonF의보다 일반적인 변환 에는 &lt;a href=&quot;qmatrix#map&quot;&gt;QMatrix :: map&lt;/a&gt; () 함수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="fe5baa5613db9a07f2d362e38916ab845c4f0edf" translate="yes" xml:space="preserve">
          <source>In addition to the locale and collation strategy, several optional flags can be set that influence the result of the collation.</source>
          <target state="translated">로캘 및 데이터 정렬 전략 외에도 데이터 정렬 결과에 영향을주는 몇 가지 선택적 플래그를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8f3f432050e4b246a5ff857a8616045f7e2d660" translate="yes" xml:space="preserve">
          <source>In addition to the more traditional &lt;a href=&quot;qml-qtquick-grid&quot;&gt;Grid&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-row&quot;&gt;Row&lt;/a&gt;, and &lt;a href=&quot;qml-qtquick-column&quot;&gt;Column&lt;/a&gt;, Qt Quick also provides a way to layout items using the concept of</source>
          <target state="translated">Qt Quick은 기존의 &lt;a href=&quot;qml-qtquick-grid&quot;&gt;Grid&lt;/a&gt; , &lt;a href=&quot;qml-qtquick-row&quot;&gt;Row&lt;/a&gt; 및 &lt;a href=&quot;qml-qtquick-column&quot;&gt;Column&lt;/a&gt; 외에도 다음 과 같은 개념을 사용하여 항목을 레이아웃하는 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="bd1769bbaee36477bcc222f28d1b3f1dc4fdbb46" translate="yes" xml:space="preserve">
          <source>In addition to the normal &lt;a href=&quot;qml-qtquick-text&quot;&gt;Text&lt;/a&gt; type, Label follows the font and color scheme of the system. Use the &lt;code&gt;text&lt;/code&gt; property to assign a text to the label. For other properties check &lt;a href=&quot;qml-qtquick-text&quot;&gt;Text&lt;/a&gt;.</source>
          <target state="translated">일반적인 &lt;a href=&quot;qml-qtquick-text&quot;&gt;텍스트&lt;/a&gt; 유형 외에도 Label은 시스템의 글꼴 및 색 구성표를 따릅니다. &lt;code&gt;text&lt;/code&gt; 속성을 사용하여 레이블에 텍스트를 할당하십시오. 다른 속성에 대해서는 &lt;a href=&quot;qml-qtquick-text&quot;&gt;Text를&lt;/a&gt; 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="3241102cc7dd4992b6edb728cbe2a9f013091640" translate="yes" xml:space="preserve">
          <source>In addition to the normal key event data, also contains</source>
          <target state="translated">일반 키 이벤트 데이터 외에도</target>
        </trans-unit>
        <trans-unit id="c5488ff097ad45e29b3b27b5e777318782f47ccb" translate="yes" xml:space="preserve">
          <source>In addition to the original behaviour of &lt;a href=&quot;qsslsocket#connectToHostEncrypted&quot;&gt;connectToHostEncrypted&lt;/a&gt;, this overloaded method enables the usage of a different hostname (</source>
          <target state="translated">&lt;a href=&quot;qsslsocket#connectToHostEncrypted&quot;&gt;connectToHostEncrypted&lt;/a&gt; 의 원래 동작 외에도이 오버로드 된 메소드는 다른 호스트 이름 (</target>
        </trans-unit>
        <trans-unit id="21fb91fa11606656b3adc5dc6835305200665c5d" translate="yes" xml:space="preserve">
          <source>In addition to the overloaded stream operators documented here, any Qt classes that you might want to serialize to a &lt;a href=&quot;qdatastream&quot;&gt;QDataStream&lt;/a&gt; will have appropriate stream operators declared as non-member of the class:</source>
          <target state="translated">여기에 문서화 된 오버로드 된 스트림 연산자 외에도 &lt;a href=&quot;qdatastream&quot;&gt;QDataStream&lt;/a&gt; 으로 직렬화하려는 Qt 클래스 에는 클래스의 비 멤버로 선언 된 적절한 스트림 연산자가 있습니다.</target>
        </trans-unit>
        <trans-unit id="82e5ba02ce74bd7c5fa0fb2e1d15e44165d43fb9" translate="yes" xml:space="preserve">
          <source>In addition to the public API, the scene graph has an adaptation layer which opens up the implementation to do hardware specific adaptations. This is an undocumented, internal and private plugin API, which lets hardware adaptation teams make the most of their hardware. It includes:</source>
          <target state="translated">공개 API 외에도 장면 그래프에는 하드웨어 별 적응을 수행하기위한 구현을 여는 적응 레이어가 있습니다. 이것은 문서화되지 않은 내부 및 개인 플러그인 API이며, 하드웨어 적응 팀이 하드웨어를 최대한 활용할 수 있습니다. 다음을 포함합니다 :</target>
        </trans-unit>
        <trans-unit id="6a6c3ce6d985ea5289aaa8da876be075c128e730" translate="yes" xml:space="preserve">
          <source>In addition to the signals and slots shown above, &lt;code&gt;moc&lt;/code&gt; also implements object properties as in the next example. The &lt;a href=&quot;qobject#Q_PROPERTY&quot;&gt;Q_PROPERTY&lt;/a&gt;() macro declares an object property, while &lt;a href=&quot;qobject#Q_ENUM&quot;&gt;Q_ENUM&lt;/a&gt;() declares a list of enumeration types within the class to be usable inside the &lt;a href=&quot;properties&quot;&gt;property system&lt;/a&gt;.</source>
          <target state="translated">위에 표시된 신호 및 슬롯 외에도 &lt;code&gt;moc&lt;/code&gt; 는 다음 예와 같이 객체 속성을 구현합니다. &lt;a href=&quot;qobject#Q_PROPERTY&quot;&gt;Q_PROPERTY&lt;/a&gt; 동안 () 매크로 객체 속성을 선언 &lt;a href=&quot;qobject#Q_ENUM&quot;&gt;Q_ENUM는&lt;/a&gt; () 내에 사용될 수 클래스 내에 열거 된 종류의리스트를 선언 &lt;a href=&quot;properties&quot;&gt;특성 시스템&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0dc3ccf2ba055573f41ffab03bf5059e4c36e6fe" translate="yes" xml:space="preserve">
          <source>In addition to the standard CMYK model, Qt provides an alpha-channel to feature &lt;a href=&quot;qcolor#alpha-blended-drawing&quot;&gt;alpha-blended drawing&lt;/a&gt;.</source>
          <target state="translated">Qt는 표준 CMYK 모델 외에도 &lt;a href=&quot;qcolor#alpha-blended-drawing&quot;&gt;알파 블렌드 드로잉&lt;/a&gt; 기능을 갖춘 알파 채널을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="0be17f054f12e2fb38a6a1f485ac2bf01fa897ed" translate="yes" xml:space="preserve">
          <source>In addition to the standard HSV model, Qt provides an alpha-channel to feature &lt;a href=&quot;qcolor#alpha-blended-drawing&quot;&gt;alpha-blended drawing&lt;/a&gt;.</source>
          <target state="translated">Qt는 표준 HSV 모델 외에도 &lt;a href=&quot;qcolor#alpha-blended-drawing&quot;&gt;알파 블렌드 드로잉&lt;/a&gt; 기능을 갖춘 알파 채널을 제공합니다 .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
