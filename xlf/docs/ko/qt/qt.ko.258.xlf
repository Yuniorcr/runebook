<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="qt">
    <body>
      <group id="qt">
        <trans-unit id="c2331b7f75357b1ee5e892039a4c5bc36abc3ebb" translate="yes" xml:space="preserve">
          <source>When used as an interface type, QAnyStringView allows a single function to accept a wide variety of string data sources. One function accepting QAnyStringView thus replaces five function overloads (taking &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;, &lt;code&gt;(const QChar*, int)&lt;/code&gt;, &lt;a href=&quot;qutf8stringview&quot;&gt;QUtf8StringView&lt;/a&gt;, &lt;a href=&quot;qlatin1string&quot;&gt;QLatin1String&lt;/a&gt; (but see above), and &lt;a href=&quot;qchar&quot;&gt;QChar&lt;/a&gt;), while at the same time enabling even more string data sources to be passed to the function, such as &lt;code&gt;u8&quot;Hello World&quot;&lt;/code&gt;, a &lt;code&gt;char8_t&lt;/code&gt; string literal.</source>
          <target state="translated">인터페이스 유형으로 사용되는 경우 QAnyStringView를 사용하면 단일 함수가 다양한 문자열 데이터 소스를 허용 할 수 있습니다. 따라서 QAnyStringView를 허용하는 하나의 함수는 5 개의 함수 오버로드 ( &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; , &lt;code&gt;(const QChar*, int)&lt;/code&gt; , &lt;a href=&quot;qutf8stringview&quot;&gt;QUtf8StringView&lt;/a&gt; , &lt;a href=&quot;qlatin1string&quot;&gt;QLatin1String&lt;/a&gt; (위 참조) 및 &lt;a href=&quot;qchar&quot;&gt;QChar&lt;/a&gt; )를 대체 하는 동시에 더 많은 문자열 데이터 소스를 함수 (예 : &lt;code&gt;u8&quot;Hello World&quot;&lt;/code&gt; , &lt;code&gt;char8_t&lt;/code&gt; 문자열 리터럴).</target>
        </trans-unit>
        <trans-unit id="cc4ca000bbdcd588a928f4c8ebed8bb2e8e1a089" translate="yes" xml:space="preserve">
          <source>When used as an interface type, QByteArrayView allows a single function to accept a wide variety of byte-array-like data sources. One function accepting QByteArrayView thus replaces several function overloads (taking, for example, &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt;, const char *, etc.) while at the same time enabling even more byte array data sources to be passed to the function.</source>
          <target state="translated">인터페이스 유형으로 사용되는 경우 QByteArrayView를 사용하면 단일 함수가 다양한 바이트 배열 유사 데이터 소스를 수용 할 수 있습니다. 따라서 QByteArrayView를받는 하나의 함수는 여러 함수 오버로드 (예 : &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; , const char * 등)를 대체 하는 동시에 더 많은 바이트 배열 데이터 소스를 함수에 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="daa321fda042d9ed390371715ca51be5b7197d06" translate="yes" xml:space="preserve">
          <source>When used as an interface type, QStringView allows a single function to accept a wide variety of UTF-16 string data sources. One function accepting QStringView thus replaces three function overloads (taking &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; and &lt;code&gt;(const QChar*, int)&lt;/code&gt;), while at the same time enabling even more string data sources to be passed to the function, such as &lt;code&gt;u&quot;Hello World&quot;&lt;/code&gt;, a &lt;code&gt;char16_t&lt;/code&gt; string literal.</source>
          <target state="translated">인터페이스 유형으로 사용되는 경우 QStringView를 사용하면 단일 함수가 다양한 UTF-16 문자열 데이터 소스를 허용 할 수 있습니다. 따라서 QStringView를 허용하는 하나의 함수는 3 개의 함수 오버로드 ( &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; 및 &lt;code&gt;(const QChar*, int)&lt;/code&gt; ) 를 대체 하는 동시에 &lt;code&gt;u&quot;Hello World&quot;&lt;/code&gt; , &lt;code&gt;char16_t&lt;/code&gt; 와 같은 더 많은 문자열 데이터 소스를 함수에 전달할 수 있습니다. 문자열 리터럴.</target>
        </trans-unit>
        <trans-unit id="3d30f2719e4dfd488693920afd51d738514f58fc" translate="yes" xml:space="preserve">
          <source>When used as an interface type, QStringView allows a single function to accept a wide variety of UTF-16 string data sources. One function accepting QStringView thus replaces three function overloads (taking &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;, &lt;a href=&quot;qstringref&quot;&gt;QStringRef&lt;/a&gt;, and &lt;code&gt;(const QChar*, int)&lt;/code&gt;), while at the same time enabling even more string data sources to be passed to the function, such as &lt;code&gt;u&quot;Hello World&quot;&lt;/code&gt;, a &lt;code&gt;char16_t&lt;/code&gt; string literal.</source>
          <target state="translated">인터페이스 유형으로 사용되는 경우 QStringView를 사용하면 단일 함수가 다양한 UTF-16 문자열 데이터 소스를 허용 할 수 있습니다. 따라서 QStringView를 허용하는 하나의 함수는 3 개의 함수 오버로드 ( &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; , &lt;a href=&quot;qstringref&quot;&gt;QStringRef&lt;/a&gt; 및 &lt;code&gt;(const QChar*, int)&lt;/code&gt; ) 를 대체 하는 동시에 &lt;code&gt;u&quot;Hello World&quot;&lt;/code&gt; 와 같은 더 많은 문자열 데이터 소스를 함수에 전달할 수 있습니다. , &lt;code&gt;char16_t&lt;/code&gt; 문자열 리터럴.</target>
        </trans-unit>
        <trans-unit id="b756621a27b88c05453eea04740bc04dc68c1ddb" translate="yes" xml:space="preserve">
          <source>When used as an interface type, QUtf8StringView allows a single function to accept a wide variety of UTF-8 string data sources. One function accepting QUtf8StringView thus replaces several function overloads (taking e.g. &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt;), while at the same time enabling even more string data sources to be passed to the function, such as &lt;code&gt;u8&quot;Hello World&quot;&lt;/code&gt;, a &lt;code&gt;char8_t&lt;/code&gt; (C++20) or &lt;code&gt;char&lt;/code&gt; (C++17) string literal. The &lt;code&gt;char8_t&lt;/code&gt; incompatibility between C++17 and C++20 goes away when using QUtf8StringView.</source>
          <target state="translated">인터페이스 유형으로 사용되는 경우 QUtf8StringView를 사용하면 단일 함수가 다양한 UTF-8 문자열 데이터 소스를 허용 할 수 있습니다. 따라서 QUtf8StringView를받는 하나의 함수는 여러 함수 오버로드 (예 : &lt;a href=&quot;qbytearray&quot;&gt;QByteArray 사용&lt;/a&gt; ) 를 대체 하는 동시에 &lt;code&gt;u8&quot;Hello World&quot;&lt;/code&gt; , &lt;code&gt;char8_t&lt;/code&gt; (C ++ 20) 또는 &lt;code&gt;char&lt;/code&gt; (C ++ 17) 문자열 리터럴. &lt;code&gt;char8_t&lt;/code&gt; 의 QUtf8StringView를 사용할 때 C ++ (17) 및 C ++ (20) 사이의 호환성이 떨어져 간다.</target>
        </trans-unit>
        <trans-unit id="2e868d59396f0fc788445bb00690275ea6245ac1" translate="yes" xml:space="preserve">
          <source>When used as flags, enumerators can be combined using the OR operator.</source>
          <target state="translated">플래그로 사용될 때 OR 연산자를 사용하여 열거자를 결합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="06c2c617a12597a994b108366e0d50cfb932d1fd" translate="yes" xml:space="preserve">
          <source>When used as part of a Transition, you can also target a specific &lt;a href=&quot;qml-qtquick-statechangescript&quot;&gt;StateChangeScript&lt;/a&gt; to run using the &lt;code&gt;scriptName&lt;/code&gt; property.</source>
          <target state="translated">전환의 일부로 사용되는 경우 &lt;code&gt;scriptName&lt;/code&gt; 속성을 사용하여 특정 &lt;a href=&quot;qml-qtquick-statechangescript&quot;&gt;StateChangeScript&lt;/a&gt; 를 실행하도록 대상을 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="59f0102a4ce38b4f2ee3e6dec5be09d72963e0c7" translate="yes" xml:space="preserve">
          <source>When used in a &lt;a href=&quot;qml-qtquick-sequentialanimation&quot;&gt;SequentialAnimation&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-pauseanimation&quot;&gt;PauseAnimation&lt;/a&gt; is a step when nothing happens, for a specified duration.</source>
          <target state="translated">A의 사용하는 경우 &lt;a href=&quot;qml-qtquick-sequentialanimation&quot;&gt;SequentialAnimation&lt;/a&gt; , &lt;a href=&quot;qml-qtquick-pauseanimation&quot;&gt;PauseAnimation는&lt;/a&gt; 아무것도 지정된 기간 동안, 일이 없을 때 단계입니다.</target>
        </trans-unit>
        <trans-unit id="32a85cc6f1a776a818b49cfac1cb9534a2a52415" translate="yes" xml:space="preserve">
          <source>When used in a &lt;a href=&quot;qml-qtquick-sequentialanimation&quot;&gt;SequentialAnimation&lt;/a&gt;, PauseAnimation is a step when nothing happens, for a specified duration.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-sequentialanimation&quot;&gt;SequentialAnimation&lt;/a&gt; 에서 사용하면 PauseAnimation은 지정된 기간 동안 아무 일도 일어나지 않는 단계입니다.</target>
        </trans-unit>
        <trans-unit id="a1ec54421dbb8796f81a74d96171dee0c22a448e" translate="yes" xml:space="preserve">
          <source>When used in a transition, a property animation is assumed to match</source>
          <target state="translated">전환에 사용될 때 속성 애니메이션이 일치하는 것으로 가정</target>
        </trans-unit>
        <trans-unit id="c62896cbdfc7c3f4c1df9f239489204e6ebe788a" translate="yes" xml:space="preserve">
          <source>When used in a transition, if no target is specified, all &lt;a href=&quot;qml-qtquick-parentchange&quot;&gt;ParentChange&lt;/a&gt; occurrences are animated by the &lt;a href=&quot;qml-qtquick-parentanimation&quot;&gt;ParentAnimation&lt;/a&gt;.</source>
          <target state="translated">전환에 사용될 때 대상을 지정하지 않으면 모든 &lt;a href=&quot;qml-qtquick-parentchange&quot;&gt;ParentChange&lt;/a&gt; 발생이 &lt;a href=&quot;qml-qtquick-parentanimation&quot;&gt;ParentAnimation에&lt;/a&gt; 의해 애니메이션됩니다 .</target>
        </trans-unit>
        <trans-unit id="28b437395e782784d83371eebd653fd7c3c66b90" translate="yes" xml:space="preserve">
          <source>When used in a transition, the path can be specified without start or end points, for example:</source>
          <target state="translated">전환에 사용될 때 경로는 시작점 또는 끝점없이 지정할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ad15b94076fc6d62e74b16ac21ba031bb2e8713a" translate="yes" xml:space="preserve">
          <source>When used in combination with &lt;a href=&quot;qtreeview&quot;&gt;QTreeView&lt;/a&gt;, the first column is not movable (since it contains the tree structure), by default. You can make it movable with &lt;a href=&quot;qheaderview#firstSectionMovable-prop&quot;&gt;setFirstSectionMovable&lt;/a&gt;(true).</source>
          <target state="translated">&lt;a href=&quot;qtreeview&quot;&gt;QTreeView&lt;/a&gt; 와 함께 사용하면 기본적 으로 첫 번째 열은 이동 가능하지 않습니다 (트리 구조를 포함하므로). &lt;a href=&quot;qheaderview#firstSectionMovable-prop&quot;&gt;setFirstSectionMovable&lt;/a&gt; (true)로 이동 가능하게 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="80921d8c37af7cbb33ff4de031ae482a77195e92" translate="yes" xml:space="preserve">
          <source>When used in conjunction with QTextureWrapMode::Repeat, textureScale provides a simple way to tile a texture across a surface. For example, a texture scale of &lt;code&gt;4.0&lt;/code&gt; would result in 16 (4x4) tiles.</source>
          <target state="translated">QTextureWrapMode :: Repeat와 함께 사용하면 textureScale은 표면에 텍스처를 타일링하는 간단한 방법을 제공합니다. 예를 들어 텍스처 배율이 &lt;code&gt;4.0&lt;/code&gt; 이면 16 (4x4) 타일이됩니다.</target>
        </trans-unit>
        <trans-unit id="8adf2789c382dae59470f104ac31491a01be4c17" translate="yes" xml:space="preserve">
          <source>When used in conjunction with WrapMode.Repeat, textureScale provides a simple way to tile a texture across a surface. For example, a texture scale of &lt;code&gt;4.0&lt;/code&gt; would result in 16 (4x4) tiles.</source>
          <target state="translated">WrapMode.Repeat와 함께 사용할 때 textureScale은 표면에 텍스처를 타일링하는 간단한 방법을 제공합니다. 예를 들어 텍스처 배율이 &lt;code&gt;4.0&lt;/code&gt; 이면 16 (4x4) 타일이됩니다.</target>
        </trans-unit>
        <trans-unit id="004dc51d90326bec6d46cfd29896a25f4617d992" translate="yes" xml:space="preserve">
          <source>When used in conjunction with the &lt;a href=&quot;qml-qtquick-loader#source-prop&quot;&gt;source&lt;/a&gt; property, loading and compilation will also be performed in a background thread.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-loader#source-prop&quot;&gt;source&lt;/a&gt; 속성 과 함께 사용 하면 백그라운드 스레드에서도로드 및 컴파일이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="50af634dadcc9340640490a9af221cd3bbb07199" translate="yes" xml:space="preserve">
          <source>When used in conjunction with the &lt;a href=&quot;qml-qtquick3d-loader3d#source-prop&quot;&gt;source&lt;/a&gt; property, loading and compilation will also be performed in a background thread.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick3d-loader3d#source-prop&quot;&gt;source&lt;/a&gt; 속성 과 함께 사용하면 로드 및 컴파일도 백그라운드 스레드에서 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="4b5ebb2f8eef3c956f23605775c3ca22ba3215b5" translate="yes" xml:space="preserve">
          <source>When used with list models, the first item in the returned list is used for matching.</source>
          <target state="translated">목록 모델과 함께 사용하면 반환 된 목록의 첫 번째 항목이 일치하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="dd791f890c76a8c37cce3455ef2668c607b23ee1" translate="yes" xml:space="preserve">
          <source>When user defines a new functor or generator, they need to implement the &lt;a href=&quot;qt3dcore-qabstractfunctor#id&quot;&gt;QAbstractFunctor::id&lt;/a&gt;() method, which should be done using the &lt;code&gt;QT3D_FUNCTOR&lt;/code&gt; macro in the class definition.</source>
          <target state="translated">사용자가 새 펑터 또는 생성기를 정의 할 때 &lt;a href=&quot;qt3dcore-qabstractfunctor#id&quot;&gt;QAbstractFunctor :: id&lt;/a&gt; () 메서드 를 구현 해야합니다 . 이는 클래스 정의에서 &lt;code&gt;QT3D_FUNCTOR&lt;/code&gt; 매크로를 사용하여 수행해야합니다 .</target>
        </trans-unit>
        <trans-unit id="2aa79e373766a60d20b2141aeac582a5a8df07d6" translate="yes" xml:space="preserve">
          <source>When user defines a new functor or generator, they need to implement the &lt;a href=&quot;qt3drender-qabstractfunctor#id&quot;&gt;QAbstractFunctor::id&lt;/a&gt;() method, which should be done using the &lt;code&gt;QT3D_FUNCTOR&lt;/code&gt; macro in the class definition.</source>
          <target state="translated">사용자가 새로운 functor 또는 generator를 정의 할 때 클래스 정의에서 &lt;code&gt;QT3D_FUNCTOR&lt;/code&gt; 매크로를 사용하여 수행해야하는 &lt;a href=&quot;qt3drender-qabstractfunctor#id&quot;&gt;QAbstractFunctor :: id&lt;/a&gt; () 메소드 를 구현 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="1426cfebd5b7719f33b6e2b9f2a97f042b4572ab" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;qabstractscrollarea&quot;&gt;QAbstractScrollArea&lt;/a&gt; based widgets, you should enable the &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt::WA_AcceptTouchEvents&lt;/a&gt; attribute on the scroll area's &lt;a href=&quot;qabstractscrollarea#viewport&quot;&gt;viewport&lt;/a&gt;.</source>
          <target state="translated">사용하는 경우 &lt;a href=&quot;qabstractscrollarea&quot;&gt;QAbstractScrollArea&lt;/a&gt; 기반의 위젯을, 당신은 활성화해야 &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt는 :: WA_AcceptTouchEvents의&lt;/a&gt; 스크롤 영역의에 속성 &lt;a href=&quot;qabstractscrollarea#viewport&quot;&gt;뷰포트를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="575c3ca33cbc8c0e49967dd6868de7d0cd46c7ed" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;qfuture&quot;&gt;QFuture&lt;/a&gt;, transferred exceptions will be thrown when calling the following functions:</source>
          <target state="translated">&lt;a href=&quot;qfuture&quot;&gt;QFuture를&lt;/a&gt; 사용 하면 다음 함수를 호출 할 때 전송 된 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6d8f6cec0c5597c992eb3a8a60ec3ad82996acf4" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;qml-qt3d-render-objectpicker&quot;&gt;ObjectPicker&lt;/a&gt; components, picking is triggered by mouse events.</source>
          <target state="translated">&lt;a href=&quot;qml-qt3d-render-objectpicker&quot;&gt;ObjectPicker&lt;/a&gt; 구성 요소를 사용 하는 경우 마우스 이벤트에 의해 피킹이 트리거됩니다.</target>
        </trans-unit>
        <trans-unit id="84a71d92671a35f5e7502b348babb72bc64cf8ed" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;qml-qt3d-render-raycaster&quot;&gt;RayCaster&lt;/a&gt; or &lt;a href=&quot;qml-qt3d-render-screenraycaster&quot;&gt;ScreenRayCaster&lt;/a&gt; components, picking can be explicitly triggered by the application.</source>
          <target state="translated">&lt;a href=&quot;qml-qt3d-render-raycaster&quot;&gt;RayCaster&lt;/a&gt; 또는 &lt;a href=&quot;qml-qt3d-render-screenraycaster&quot;&gt;ScreenRayCaster&lt;/a&gt; 구성 요소를 사용 하는 경우 응용 프로그램에서 피킹을 명시 적으로 트리거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b9d22db787646c3b272fef7eabbedc341942ce2" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;qpointer&quot;&gt;QPointer&lt;/a&gt; on a &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; (or a subclass of &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt;), previously the &lt;a href=&quot;qpointer&quot;&gt;QPointer&lt;/a&gt; would be cleared by the &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; destructor. Now, the &lt;a href=&quot;qpointer&quot;&gt;QPointer&lt;/a&gt; is cleared by the &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; destructor (since this is when &lt;a href=&quot;qweakpointer&quot;&gt;QWeakPointer&lt;/a&gt; objects are cleared). Any QPointers tracking a widget will &lt;b&gt;NOT&lt;/b&gt; be cleared before the &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; destructor destroys the children for the widget being tracked.</source>
          <target state="translated">사용하는 경우 &lt;a href=&quot;qpointer&quot;&gt;QPointer을&lt;/a&gt; A의 &lt;a href=&quot;qwidget&quot;&gt;는 QWidget&lt;/a&gt; (또는 서브 클래스 &lt;a href=&quot;qwidget&quot;&gt;는 QWidget&lt;/a&gt; ), 이전에 &lt;a href=&quot;qpointer&quot;&gt;QPointer는&lt;/a&gt; 에 의해 삭제 될 수 &lt;a href=&quot;qwidget&quot;&gt;는 QWidget의&lt;/a&gt; 소멸자. 이제, &lt;a href=&quot;qpointer&quot;&gt;QPointer는&lt;/a&gt; 에 의해 삭제됩니다 &lt;a href=&quot;qobject&quot;&gt;QObject를의&lt;/a&gt; (때이기 때문에 소멸자 &lt;a href=&quot;qweakpointer&quot;&gt;QWeakPointer의&lt;/a&gt; 객체가 지워집니다). 위젯을 추적하는 QPointer 는 &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; 소멸자가 추적중인 위젯의 하위를 파괴 하기 전에 지워지지 &lt;b&gt;않습니다&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="9cb101985a20e335f82bea2786675dac07ad4743" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;qquickrendercontrol&quot;&gt;QQuickRenderControl&lt;/a&gt;, the responsibility for driving the rendering loop is transferred to the application. In this case no built-in render loop is used. Instead, it is up to the application to invoke the polish, synchronize and rendering steps at the appropriate time. It is possible to implement either a threaded or non-threaded behavior similar to the ones shown above.</source>
          <target state="translated">&lt;a href=&quot;qquickrendercontrol&quot;&gt;QQuickRenderControl을&lt;/a&gt; 사용할 때 렌더링 루프를 구동하는 책임은 응용 프로그램으로 전송됩니다. 이 경우 내장 렌더 루프가 사용되지 않습니다. 대신, 적절한 시간에 연마, 호출 및 렌더링 단계를 호출하는 것은 애플리케이션에 달려 있습니다. 위에 표시된 것과 유사한 스레드 또는 비스 레드 동작을 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d012f8d1021f21cc24a25741a7fb9a69b828bff8" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;qregexp&quot;&gt;QRegExp&lt;/a&gt;, character classes such as &lt;code&gt;\w&lt;/code&gt;, &lt;code&gt;\d&lt;/code&gt;, etc. match characters with the corresponding Unicode property: for instance, &lt;code&gt;\d&lt;/code&gt; matches any character with the Unicode Nd (decimal digit) property.</source>
          <target state="translated">&lt;a href=&quot;qregexp&quot;&gt;QRegExp를&lt;/a&gt; 사용할 때 &lt;code&gt;\w&lt;/code&gt; , &lt;code&gt;\d&lt;/code&gt; 등의 문자 클래스 는 해당 유니 코드 속성과 문자를 일치시킵니다. 예를 들어, &lt;code&gt;\d&lt;/code&gt; 는 모든 문자를 유니 코드 Nd (10 진수) 속성과 일치시킵니다.</target>
        </trans-unit>
        <trans-unit id="ac6f985a54a309fa51d578fd26c8d0b4e738a09d" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;qregexp#exactMatch&quot;&gt;QRegExp::exactMatch&lt;/a&gt;(), if an exact match was not found, one could still find out how much of the subject string was matched by the regular expression by calling &lt;a href=&quot;qregexp#matchedLength&quot;&gt;QRegExp::matchedLength&lt;/a&gt;(). If the returned length was equal to the subject string's length, then one could conclude that a partial match was found.</source>
          <target state="translated">&lt;a href=&quot;qregexp#exactMatch&quot;&gt;QRegExp :: exactMatch&lt;/a&gt; ()를 사용할 때 정확히 일치하는 항목을 찾지 못하면 &lt;a href=&quot;qregexp#matchedLength&quot;&gt;QRegExp :: matchedLength&lt;/a&gt; ()를 호출하여 정규식과 일치하는 제목 문자열의 양을 여전히 알 수 있습니다 . 반환 된 길이가 주제 문자열의 길이와 같으면 부분적으로 일치하는 것으로 결론을 내릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d94095f2415c5876a4a1aa870624cea946f6341" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;qsqlrelationaltablemodel#setData&quot;&gt;setData&lt;/a&gt;() the role should always be &lt;a href=&quot;qt#ItemDataRole-enum&quot;&gt;Qt::EditRole&lt;/a&gt;, and when using &lt;a href=&quot;qsqlrelationaltablemodel#data&quot;&gt;data&lt;/a&gt;() the role should always be &lt;a href=&quot;qt#ItemDataRole-enum&quot;&gt;Qt::DisplayRole&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qsqlrelationaltablemodel#setData&quot;&gt;setData&lt;/a&gt; () 사용시 역할은 항상 &lt;a href=&quot;qt#ItemDataRole-enum&quot;&gt;Qt :: EditRole이어야&lt;/a&gt; 하고 &lt;a href=&quot;qsqlrelationaltablemodel#data&quot;&gt;data&lt;/a&gt; () 사용시 역할은 항상 &lt;a href=&quot;qt#ItemDataRole-enum&quot;&gt;Qt :: DisplayRole&lt;/a&gt; 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="a13ee32d4578c512ae1659dfec745b53cf236ec8" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;qt3drender-qobjectpicker&quot;&gt;QObjectPicker&lt;/a&gt; components, picking is triggered by mouse events.</source>
          <target state="translated">&lt;a href=&quot;qt3drender-qobjectpicker&quot;&gt;QObjectPicker&lt;/a&gt; 구성 요소를 사용할 때 마우스 이벤트에 의해 선택이 트리거됩니다.</target>
        </trans-unit>
        <trans-unit id="0f56fc20751ece8353bd515ce19ac51a3e3f37cf" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;qt3drender-qraycaster&quot;&gt;QRayCaster&lt;/a&gt; or &lt;a href=&quot;qt3drender-qscreenraycaster&quot;&gt;QScreenRayCaster&lt;/a&gt; components, picking can be explicitly triggered by the application.</source>
          <target state="translated">&lt;a href=&quot;qt3drender-qraycaster&quot;&gt;QRayCaster&lt;/a&gt; 또는 &lt;a href=&quot;qt3drender-qscreenraycaster&quot;&gt;QScreenRayCaster&lt;/a&gt; 컴포넌트를 사용 하는 경우 애플리케이션에서 피킹을 명시 적으로 트리거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0bc4fe98c52b381a2aadae88fd44cf619ed0b21e" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;qtcore-changes-qt6#qfuture&quot;&gt;QFuture&lt;/a&gt;, transferred exceptions will be thrown when calling the following functions:</source>
          <target state="translated">사용하는 경우 &lt;a href=&quot;qtcore-changes-qt6#qfuture&quot;&gt;QFuture을&lt;/a&gt; 다음과 같은 기능을 호출 할 때, 전송 예외가 발생합니다 :</target>
        </trans-unit>
        <trans-unit id="4bb450b8e4af0bd506a47d7330ff8573095a4a13" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;qvariant#canConvert-1&quot;&gt;canConvert&lt;/a&gt;() and &lt;a href=&quot;qvariant#convert&quot;&gt;convert&lt;/a&gt;() consecutively, it is possible for &lt;a href=&quot;qvariant#canConvert-1&quot;&gt;canConvert&lt;/a&gt;() to return true, but &lt;a href=&quot;qvariant#convert&quot;&gt;convert&lt;/a&gt;() to return false. This is typically because &lt;a href=&quot;qvariant#canConvert-1&quot;&gt;canConvert&lt;/a&gt;() only reports the general ability of &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; to convert between types given suitable data; it is still possible to supply data which cannot actually be converted.</source>
          <target state="translated">사용하는 경우 &lt;a href=&quot;qvariant#canConvert-1&quot;&gt;canConvert&lt;/a&gt; () 및 &lt;a href=&quot;qvariant#convert&quot;&gt;변환을&lt;/a&gt; 위해 () 연속, 그것은 가능하다 &lt;a href=&quot;qvariant#canConvert-1&quot;&gt;canConvert은&lt;/a&gt; ()가 true를 반환하지만, &lt;a href=&quot;qvariant#convert&quot;&gt;변환은&lt;/a&gt; ()가 false를 반환합니다. 일반적으로 &lt;a href=&quot;qvariant#canConvert-1&quot;&gt;canConvert&lt;/a&gt; ()는 &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; 가 적절한 데이터가 주어진 유형간에 변환 할 수있는 일반적인 기능 만보고 하기 때문입니다. 실제로 변환 할 수없는 데이터를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d37f68c0c35e188254d8435a84da82e74251cffd" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;qvariant#canConvert-1&quot;&gt;canConvert&lt;/a&gt;() and &lt;a href=&quot;qvariant#convert&quot;&gt;convert&lt;/a&gt;() consecutively, it is possible for &lt;a href=&quot;qvariant#canConvert-1&quot;&gt;canConvert&lt;/a&gt;() to return true, but &lt;a href=&quot;qvariant#convert&quot;&gt;convert&lt;/a&gt;() to return false. This is typically because &lt;a href=&quot;qvariant#canConvert-1&quot;&gt;canConvert&lt;/a&gt;() only reports the general ability of QVariant to convert between types given suitable data; it is still possible to supply data which cannot actually be converted.</source>
          <target state="translated">사용하는 경우 &lt;a href=&quot;qvariant#canConvert-1&quot;&gt;canConvert&lt;/a&gt; () 및 &lt;a href=&quot;qvariant#convert&quot;&gt;변환을&lt;/a&gt; 위해 () 연속, 그것은 가능하다 &lt;a href=&quot;qvariant#canConvert-1&quot;&gt;canConvert은&lt;/a&gt; ()가 true를 반환하지만, &lt;a href=&quot;qvariant#convert&quot;&gt;변환은&lt;/a&gt; ()가 false를 반환합니다. 이는 일반적으로 &lt;a href=&quot;qvariant#canConvert-1&quot;&gt;canConvert&lt;/a&gt; ()가 적절한 데이터가 제공된 유형간에 변환하는 QVariant의 일반적인 기능 만보고하기 때문입니다. 실제로 변환 할 수없는 데이터를 제공하는 것은 여전히 ​​가능합니다.</target>
        </trans-unit>
        <trans-unit id="93607a503a8f7f722105088c33d8d1a71ff17341" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;qvariant#canConvert-2&quot;&gt;canConvert&lt;/a&gt;() and &lt;a href=&quot;qvariant#convert&quot;&gt;convert&lt;/a&gt;() consecutively, it is possible for &lt;a href=&quot;qvariant#canConvert-2&quot;&gt;canConvert&lt;/a&gt;() to return true, but &lt;a href=&quot;qvariant#convert&quot;&gt;convert&lt;/a&gt;() to return false. This is typically because &lt;a href=&quot;qvariant#canConvert-2&quot;&gt;canConvert&lt;/a&gt;() only reports the general ability of QVariant to convert between types given suitable data; it is still possible to supply data which cannot actually be converted.</source>
          <target state="translated">사용하는 경우 &lt;a href=&quot;qvariant#canConvert-2&quot;&gt;canConvert&lt;/a&gt; () 및 &lt;a href=&quot;qvariant#convert&quot;&gt;변환을&lt;/a&gt; 위해 () 연속, 그것은 가능하다 &lt;a href=&quot;qvariant#canConvert-2&quot;&gt;canConvert은&lt;/a&gt; ()가 true를 반환하지만, &lt;a href=&quot;qvariant#convert&quot;&gt;변환은&lt;/a&gt; ()가 false를 반환합니다. 이는 일반적으로 &lt;a href=&quot;qvariant#canConvert-2&quot;&gt;canConvert&lt;/a&gt; ()가 적절한 데이터가 제공된 유형간에 변환 할 수있는 QVariant의 일반적인 기능 만보고하기 때문입니다. 실제로 변환 할 수없는 데이터를 제공하는 것은 여전히 ​​가능합니다.</target>
        </trans-unit>
        <trans-unit id="63a5b0e4cc7f8c24a778525455fed9bdd298ad8d" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;DefaultMaterial.FragmentLighting&lt;/code&gt;, diffuse and specular lighting are calculated for each rendered pixel. Certain effects (such as a Fresnel or bump map) require &lt;code&gt;DefaultMaterial.FragmentLighting&lt;/code&gt; to work.</source>
          <target state="translated">&lt;code&gt;DefaultMaterial.FragmentLighting&lt;/code&gt; 을 사용하면 렌더링 된 각 픽셀에 대해 확산 및 반사 조명이 계산됩니다. 프레 넬 또는 범프 맵과 같은 특정 효과 가 작동 하려면 &lt;code&gt;DefaultMaterial.FragmentLighting&lt;/code&gt; 이 필요 합니다.</target>
        </trans-unit>
        <trans-unit id="181a002e05e8272926d9351f95bbfbfb7cdf85dc" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;DefaultMaterial.NoLighting&lt;/code&gt; no lighting is calculated. This mode is (predictably) very fast, and quite effective when image maps are used that do not need to be shaded by lighting.</source>
          <target state="translated">&lt;code&gt;DefaultMaterial.NoLighting&lt;/code&gt; 을 사용하면 조명이 계산되지 않습니다. 이 모드는 (예측 가능) 매우 빠르며 조명으로 음영 처리 할 필요가없는 이미지 맵을 사용할 때 매우 효과적입니다.</target>
        </trans-unit>
        <trans-unit id="f5c98171bdab97a1919d644be562260acc1d76be" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;Drag.Automatic&lt;/code&gt; you should also define &lt;a href=&quot;qml-qtquick-drag#mimeData-attached-prop&quot;&gt;mimeData&lt;/a&gt; and bind the &lt;a href=&quot;qml-qtquick-drag#active-attached-prop&quot;&gt;active&lt;/a&gt; property to the active property of &lt;a href=&quot;qml-qtquick-mousearea&quot;&gt;MouseArea&lt;/a&gt; : &lt;a href=&quot;qml-qtquick-mousearea#drag.active-prop&quot;&gt;MouseArea::drag.active&lt;/a&gt;</source>
          <target state="translated">사용하는 경우 &lt;code&gt;Drag.Automatic&lt;/code&gt; 을 당신은 또한 정의해야 &lt;a href=&quot;qml-qtquick-drag#mimeData-attached-prop&quot;&gt;mimeData&lt;/a&gt; 및 바인드 &lt;a href=&quot;qml-qtquick-drag#active-attached-prop&quot;&gt;활성&lt;/a&gt; 의 활성 재산에 대한 재산 &lt;a href=&quot;qml-qtquick-mousearea&quot;&gt;MouseArea을&lt;/a&gt; : &lt;a href=&quot;qml-qtquick-mousearea#drag.active-prop&quot;&gt;MouseArea을 :: drag.active을&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f748b0d6e3f84aeeb3819d9034a189b81e556575" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;PrincipledMaterial.FragmentLighting&lt;/code&gt;, diffuse and specular lighting is calculated for each rendered pixel. Certain effects (such as a Fresnel or normal map) require &lt;code&gt;PrincipledMaterial.FragmentLighting&lt;/code&gt; to work.</source>
          <target state="translated">&lt;code&gt;PrincipledMaterial.FragmentLighting&lt;/code&gt; 을 사용하면 렌더링 된 각 픽셀에 대해 확산 및 반사광이 계산됩니다. 프레 넬 또는 노멀 맵과 같은 특정 효과 가 작동 하려면 &lt;code&gt;PrincipledMaterial.FragmentLighting&lt;/code&gt; 이 필요 합니다.</target>
        </trans-unit>
        <trans-unit id="12e29fd22ce81fc6972c0d59e6992cae2fc2597f" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;PrincipledMaterial.NoLighting&lt;/code&gt; no lighting is calculated. This mode is (predictably) very fast, and is quite effective when image maps are used that you do not need to be shaded by lighting.</source>
          <target state="translated">&lt;code&gt;PrincipledMaterial.NoLighting&lt;/code&gt; 을 사용하면 조명이 계산되지 않습니다. 이 모드는 (예측 가능) 매우 빠르며 조명으로 음영 처리 할 필요가없는 이미지 맵을 사용할 때 매우 효과적입니다.</target>
        </trans-unit>
        <trans-unit id="546e609f1fd18fd7bc410127d39e9e19ec5b16a8" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;PrincipledMaterial.NoLighting&lt;/code&gt; no lighting is calculated. This mode is (predictably) very fast, and is quite effective when image maps are used that you do not need to be shaded by lighting. All other shading properties except &lt;a href=&quot;qml-qtquick3d-principledmaterial#baseColor-prop&quot;&gt;baseColor&lt;/a&gt; values, alpha values, and vertex colors will be ignored.</source>
          <target state="translated">&lt;code&gt;PrincipledMaterial.NoLighting&lt;/code&gt; 을 사용하면 조명이 계산되지 않습니다. 이 모드는 (예측 가능) 매우 빠르며 조명으로 음영 처리 할 필요가없는 이미지 맵을 사용할 때 매우 효과적입니다. &lt;a href=&quot;qml-qtquick3d-principledmaterial#baseColor-prop&quot;&gt;baseColor&lt;/a&gt; 값, 알파 값 및 정점 색상을 제외한 다른 모든 음영 속성 은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="41f53f3fe7bbb3775a71ffa1e9c1e78f1fe5d53b" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;QRegExp::exactMatch()&lt;/code&gt;, if an exact match was not found, one could still find out how much of the subject string was matched by the regular expression by calling &lt;code&gt;QRegExp::matchedLength()&lt;/code&gt;. If the returned length was equal to the subject string's length, then one could conclude that a partial match was found. &lt;a href=&quot;qtcore-changes-qt6#qregularexpression&quot;&gt;QRegularExpression&lt;/a&gt; supports partial matching explicitly by means of the appropriate &lt;a href=&quot;qregularexpression#MatchType-enum&quot;&gt;QRegularExpression::MatchType&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;QRegExp::exactMatch()&lt;/code&gt; 사용할 때 정확히 일치하는 항목이없는 경우 &lt;code&gt;QRegExp::matchedLength()&lt;/code&gt; 호출하여 정규 표현식과 일치하는 제목 문자열의 양을 확인할 수 있습니다 . 반환 된 길이가 주제 문자열의 길이와 같으면 부분 일치가 발견되었다고 결론을 내릴 수 있습니다. &lt;a href=&quot;qtcore-changes-qt6#qregularexpression&quot;&gt;QRegularExpression&lt;/a&gt; 은 적절한 &lt;a href=&quot;qregularexpression#MatchType-enum&quot;&gt;QRegularExpression :: MatchType&lt;/a&gt; 을 통해 명시 적으로 부분 일치를 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="cb2aed55ec2520ea5e048890963966947598734b" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;QRegExp&lt;/code&gt;, character classes such as &lt;code&gt;\w&lt;/code&gt;, &lt;code&gt;\d&lt;/code&gt;, etc. match characters with the corresponding Unicode property: for instance, &lt;code&gt;\d&lt;/code&gt; matches any character with the Unicode Nd (decimal digit) property. Those character classes only match ASCII characters by default. When using &lt;a href=&quot;qtcore-changes-qt6#qregularexpression&quot;&gt;QRegularExpression&lt;/a&gt;: for instance, &lt;code&gt;\d&lt;/code&gt; matches exactly a character in the 0-9 ASCII range. It is possible to change this behavior by using the &lt;a href=&quot;qregularexpression#PatternOption-enum&quot;&gt;QRegularExpression::UseUnicodePropertiesOption&lt;/a&gt; pattern option.</source>
          <target state="translated">&lt;code&gt;QRegExp&lt;/code&gt; 를 사용할 때 &lt;code&gt;\w&lt;/code&gt; , &lt;code&gt;\d&lt;/code&gt; 등과 같은 문자 클래스 는 해당 유니 코드 속성이 있는 문자와 일치합니다. 예를 들어 &lt;code&gt;\d&lt;/code&gt; 는 유니 코드 Nd (10 진수) 속성이있는 모든 문자와 일치합니다. 이러한 문자 클래스는 기본적으로 ASCII 문자와 만 일치합니다. 예를 들어 &lt;a href=&quot;qtcore-changes-qt6#qregularexpression&quot;&gt;QRegularExpression을&lt;/a&gt; 사용할 때 &lt;code&gt;\d&lt;/code&gt; 는 0-9 ASCII 범위의 문자와 정확히 일치합니다. &lt;a href=&quot;qregularexpression#PatternOption-enum&quot;&gt;QRegularExpression :: UseUnicodePropertiesOption&lt;/a&gt; 패턴 옵션 을 사용하여이 동작을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb15798a6838b0b5d9ff2812930cc61f9da64382" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;swipe.left&lt;/code&gt; and &lt;code&gt;swipe.right&lt;/code&gt;, the control cannot be swiped past the left and right edges. To achieve this type of &quot;wrapping&quot; behavior, set &lt;code&gt;swipe.behind&lt;/code&gt; instead. This will result in the same item being shown regardless of which direction the control is swiped. For example, in the image below, we set &lt;code&gt;swipe.behind&lt;/code&gt; and then swipe the control repeatedly in both directions:</source>
          <target state="translated">사용하는 경우 &lt;code&gt;swipe.left&lt;/code&gt; 및 &lt;code&gt;swipe.right&lt;/code&gt; 를 컨트롤은 왼쪽과 오른쪽 가장자리를지나 쳤어요 할 수 없습니다. 이러한 유형의 &quot;래핑&quot;동작을 달성하려면 대신 &lt;code&gt;swipe.behind&lt;/code&gt; 를 설정 하십시오 . 컨트롤이 스 와이프되는 방향에 관계없이 동일한 항목이 표시됩니다. 예를 들어 아래 이미지에서 &lt;code&gt;swipe.behind&lt;/code&gt; 를 설정 한 다음 컨트롤을 양방향으로 반복해서 스 와이프합니다.</target>
        </trans-unit>
        <trans-unit id="61bedb3305669141647e1f5b49411e374f737ba6" translate="yes" xml:space="preserve">
          <source>When using BlockWithGui, applications must be prepared for reentrancy in any function.</source>
          <target state="translated">BlockWithGui를 사용하는 경우 응용 프로그램은 모든 기능에서 재진입을 위해 준비되어야합니다.</target>
        </trans-unit>
        <trans-unit id="62f4bd548f8779658ed7ed0fc958d3e08e13ec54" translate="yes" xml:space="preserve">
          <source>When using DBus in a peer-to-peer context (i.e., not on a bus), the</source>
          <target state="translated">피어 투 피어 컨텍스트에서 DBus를 사용할 때 (즉, 버스가 아닌)</target>
        </trans-unit>
        <trans-unit id="691c13e7d09d858f3074039dda4ddcb22ceb97bd" translate="yes" xml:space="preserve">
          <source>When using OpenGL directly, the default adaptation is capable of providing the full Qt Quick 2 feature set. For more details, see &lt;a href=&quot;qtquick-visualcanvas-scenegraph-renderer&quot;&gt;Default Adaptation&lt;/a&gt;.</source>
          <target state="translated">OpenGL을 직접 사용할 때 기본 적응은 전체 Qt Quick 2 기능 세트를 제공 할 수 있습니다. 자세한 내용은 &lt;a href=&quot;qtquick-visualcanvas-scenegraph-renderer&quot;&gt;기본 적응을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3443c88fd0bfeed377ff1535febbb39cfd07c48f" translate="yes" xml:space="preserve">
          <source>When using OpenGL, Vulkan, Metal, or Direct 3D via the RHI, the default adaptation is capable of providing most features, including the full batching renderer described in &lt;a href=&quot;qtquick-visualcanvas-scenegraph-renderer&quot;&gt;Default Adaptation&lt;/a&gt;, but some additional features may not be available as of Qt 5.14.</source>
          <target state="translated">RHI를 통해 OpenGL, Vulkan, Metal 또는 Direct 3D를 사용할 때 기본 적응은 &lt;a href=&quot;qtquick-visualcanvas-scenegraph-renderer&quot;&gt;Default Adaptation에&lt;/a&gt; 설명 된 전체 배치 렌더러를 포함하여 대부분의 기능을 제공 할 수 있지만 일부 추가 기능은 Qt 5.14부터 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e12fe5aed3159ac2d8ab33ab64fb58ad7f96fad6" translate="yes" xml:space="preserve">
          <source>When using OpenGL, the &lt;a href=&quot;gui-changes-qt6#qopenglcontext&quot;&gt;QOpenGLContext&lt;/a&gt; used for rendering by the scene graph will be bound at this point.</source>
          <target state="translated">OpenGL을 사용할 때 장면 그래프에서 렌더링하는 데 사용되는 &lt;a href=&quot;gui-changes-qt6#qopenglcontext&quot;&gt;QOpenGLContext&lt;/a&gt; 가이 지점에서 바인딩됩니다.</target>
        </trans-unit>
        <trans-unit id="1050985281b9ecb52ace1f9f25c0094bcb38a505" translate="yes" xml:space="preserve">
          <source>When using PSK, the client must send to the server a valid identity and a valid pre shared key, in order for the SSL handshake to continue. Applications can provide this information in a slot connected to this signal, by filling in the passed</source>
          <target state="translated">PSK를 사용할 때 SSL 핸드 셰이크를 계속하려면 클라이언트가 서버에 유효한 ID와 유효한 사전 공유 키를 보내야합니다. 응용 프로그램은 전달 된 정보를 채워서이 신호에 연결된 슬롯에이 정보를 제공 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="39ee444b0ae6c83e2b1c9912b7c4bafa58d26ba0" translate="yes" xml:space="preserve">
          <source>When using PSK, the client must send to the server a valid identity and a valid pre shared key, in order for the TLS handshake to continue. Applications can provide this information in a slot connected to this signal, by filling in the passed</source>
          <target state="translated">PSK를 사용하는 경우 TLS 핸드 셰이크를 계속하려면 클라이언트가 서버에 유효한 ID와 유효한 사전 공유 키를 보내야합니다. 어플리케이션은 전달 된 정보를 채워이 신호에 연결된 슬롯에이 정보를 제공 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="3ddef15731edb7f2ec01ffcdbebf9f233547ee7b" translate="yes" xml:space="preserve">
          <source>When using QPointer on a &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; (or a subclass of &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt;), previously the QPointer would be cleared by the &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; destructor. Now, the QPointer is cleared by the &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; destructor (since this is when &lt;a href=&quot;qweakpointer&quot;&gt;QWeakPointer&lt;/a&gt; objects are cleared). Any QPointers tracking a widget will &lt;b&gt;NOT&lt;/b&gt; be cleared before the &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; destructor destroys the children for the widget being tracked.</source>
          <target state="translated">A의 QPointer을 사용하는 경우 &lt;a href=&quot;qwidget&quot;&gt;는 QWidget&lt;/a&gt; (또는 서브 클래스 &lt;a href=&quot;qwidget&quot;&gt;는 QWidget&lt;/a&gt; ), 이전에 QPointer은 해제 할 것이라고 &lt;a href=&quot;qwidget&quot;&gt;는 QWidget의&lt;/a&gt; 소멸자. 이제 QPointer는 &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 소멸자에 의해 지워집니다 ( &lt;a href=&quot;qweakpointer&quot;&gt;QWeakPointer&lt;/a&gt; 객체가 지워질 때이기 때문에 ). 위젯을 추적하는 모든 QPointer 는 &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; 소멸자가 추적중인 위젯의 자식을 파괴 하기 전에 지워지지 &lt;b&gt;않습니다&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="f685ef46fe7dd6007175d02c9f869a4880a42cb0" translate="yes" xml:space="preserve">
          <source>When using QPointer on a &lt;a href=&quot;widgets-changes-qt6#qwidget&quot;&gt;QWidget&lt;/a&gt; (or a subclass of &lt;a href=&quot;widgets-changes-qt6#qwidget&quot;&gt;QWidget&lt;/a&gt;), previously the QPointer would be cleared by the &lt;a href=&quot;widgets-changes-qt6#qwidget&quot;&gt;QWidget&lt;/a&gt; destructor. Now, the QPointer is cleared by the &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; destructor (since this is when &lt;a href=&quot;qweakpointer&quot;&gt;QWeakPointer&lt;/a&gt; objects are cleared). Any QPointers tracking a widget will &lt;b&gt;NOT&lt;/b&gt; be cleared before the &lt;a href=&quot;widgets-changes-qt6#qwidget&quot;&gt;QWidget&lt;/a&gt; destructor destroys the children for the widget being tracked.</source>
          <target state="translated">A의 QPointer을 사용하는 경우 &lt;a href=&quot;widgets-changes-qt6#qwidget&quot;&gt;는 QWidget&lt;/a&gt; (또는 서브 클래스 &lt;a href=&quot;widgets-changes-qt6#qwidget&quot;&gt;는 QWidget&lt;/a&gt; ), 이전에 QPointer은 해제 할 것이라고 &lt;a href=&quot;widgets-changes-qt6#qwidget&quot;&gt;는 QWidget의&lt;/a&gt; 소멸자. 이제 QPointer는 &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 소멸자에 의해 지워집니다 ( &lt;a href=&quot;qweakpointer&quot;&gt;QWeakPointer&lt;/a&gt; 객체가 지워질 때이기 때문에 ). 위젯을 추적하는 모든 QPointers 는 &lt;a href=&quot;widgets-changes-qt6#qwidget&quot;&gt;QWidget&lt;/a&gt; 소멸자가 추적중인 위젯의 자식을 파괴 하기 전에 지워지지 &lt;b&gt;않습니다&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="40529dce9d600493e59329b79adee1882ab5990d" translate="yes" xml:space="preserve">
          <source>When using QRegExp, character classes such as &lt;code&gt;\w&lt;/code&gt;, &lt;code&gt;\d&lt;/code&gt;, etc. match characters with the corresponding Unicode property: for instance, &lt;code&gt;\d&lt;/code&gt; matches any character with the Unicode Nd (decimal digit) property.</source>
          <target state="translated">QRegExp를 사용할 때 &lt;code&gt;\w&lt;/code&gt; , &lt;code&gt;\d&lt;/code&gt; 등과 같은 문자 클래스 는 해당 유니 코드 속성이 있는 문자와 일치합니다. 예를 들어 &lt;code&gt;\d&lt;/code&gt; 는 유니 코드 Nd (10 진수) 속성이있는 모든 문자와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="255f0d84a345be8b50ad54e3ccc3e16895694fac" translate="yes" xml:space="preserve">
          <source>When using Qt Assistant as the help browser for an application, it should be possible to customize it to fit the application better, so that it does not look like an independent, standalone help browser. To achieve this, several additional properties can be set in a Qt help collection file, to change for example the title or application icon of Qt Assistant. For more information, see the &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtassistant-index.html&quot;&gt;Qt Assistant Manual&lt;/a&gt;.</source>
          <target state="translated">Qt Assistant를 응용 프로그램의 도움말 브라우저로 사용하는 경우 독립형 독립형 도움말 브라우저처럼 보이지 않도록 응용 프로그램에 더 잘 맞게 사용자 정의 할 수 있어야합니다. 이를 위해 Qt 지원 모음 파일에 몇 가지 추가 속성을 설정하여 Qt Assistant의 제목 또는 응용 프로그램 아이콘 등을 변경할 수 있습니다. 자세한 내용은 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtassistant-index.html&quot;&gt;Qt Assistant 매뉴얼을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2e885d834a3a8009f53361c87cc4af716e63bfd9" translate="yes" xml:space="preserve">
          <source>When using Qt Assistant as the help browser for an application, it should be possible to customize it to fit the application better, so that it does not look like an independent, standalone help browser. To achieve this, several additional properties can be set in a Qt help collection file, to change for example the title or application icon of Qt Assistant. For more information, see the &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtassistant-index.html&quot;&gt;Qt Assistant Manual&lt;/a&gt;.</source>
          <target state="translated">Qt Assistant를 응용 프로그램의 도움말 브라우저로 사용할 때, 응용 프로그램에 더 잘 맞도록 사용자 정의 할 수 있어야 독립적 인 독립형 도움말 브라우저처럼 보이지 않습니다. 이를 위해 Qt 도움말 모음 파일에 몇 가지 추가 속성을 설정하여 예를 들어 Qt Assistant의 제목 또는 응용 프로그램 아이콘을 변경할 수 있습니다. 자세한 내용은 &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtassistant-index.html&quot;&gt;Qt Assistant 설명서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="96485953fffbb5b7190077868fd5884bb7139bfb" translate="yes" xml:space="preserve">
          <source>When using Qt Quick 3D with OpenGL it is necessary to take extra steps to define what kind of &lt;a href=&quot;qsurfaceformat&quot;&gt;surface format&lt;/a&gt; is used when initializing Qt Quick. This is because by the time Qt Quick is aware that 3D content is being used, the OpenGL context and window surface has already been initialized. So this helper class is provided to request the ideal surface format from Qt Quick 3D so that it can be set as the default surface for Qt Quick before initialization.</source>
          <target state="translated">OpenGL과 함께 Qt Quick 3D를 사용하는 경우 Qt Quick을 초기화 할 때 어떤 종류의 &lt;a href=&quot;qsurfaceformat&quot;&gt;표면 형식&lt;/a&gt; 이 사용 되는지 정의하기 위해 추가 단계를 수행해야합니다 . 이는 Qt Quick이 3D 콘텐츠가 사용되고 있음을 인식 할 때까지 OpenGL 컨텍스트와 창 표면이 이미 초기화 되었기 때문입니다. 따라서이 도우미 클래스는 초기화 전에 Qt Quick의 기본 표면으로 설정할 수 있도록 Qt Quick 3D에서 이상적인 표면 형식을 요청하기 위해 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="18dc1be3da1b58f61947b20badaafabb7fb35324" translate="yes" xml:space="preserve">
          <source>When using Qt Virtual Keyboard in a &lt;a href=&quot;qquickwidget&quot;&gt;QQuickWidget&lt;/a&gt; on a touch device, it is necessary to set the &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt::WA_AcceptTouchEvents&lt;/a&gt; attribute via &lt;a href=&quot;qwidget#setAttribute&quot;&gt;QWidget::setAttribute&lt;/a&gt;(). Without this attribute set, events from a touch device will be converted into synthesized mouse events.</source>
          <target state="translated">터치 장치 의 &lt;a href=&quot;qquickwidget&quot;&gt;QQuickWidget&lt;/a&gt; 에서 Qt 가상 키보드를 사용하는 경우 &lt;a href=&quot;qwidget#setAttribute&quot;&gt;QWidget :: setAttribute&lt;/a&gt; () 를 통해 &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt :: WA_AcceptTouchEvents&lt;/a&gt; 속성 을 설정해야합니다 . 이 속성을 설정하지 않으면 터치 장치의 이벤트가 합성 된 마우스 이벤트로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="9bb69ac7d44bcdb70b16a6a8c3dec221adfbb779" translate="yes" xml:space="preserve">
          <source>When using QtConcurrent::filteredReduced() or QtConcurrent::blockingFilteredReduced(), you can mix the use of normal functions, member functions and lambda expressions freely.</source>
          <target state="translated">QtConcurrent :: filteredReduced () 또는 QtConcurrent :: blockingFilteredReduced ()를 사용할 때 일반 함수, 멤버 함수 및 람다 표현식을 자유롭게 혼합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a1c254e1d734f7df6f457b7084886f659ba24ae2" translate="yes" xml:space="preserve">
          <source>When using QtConcurrent::mappedReduced() or QtConcurrent::blockingMappedReduced(), you can mix the use of normal functions, member functions and lambda expressions freely.</source>
          <target state="translated">QtConcurrent :: mappedReduced () 또는 QtConcurrent :: blockingMappedReduced ()를 사용할 때 일반 함수, 멤버 함수 및 람다 표현식을 자유롭게 혼합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="59ae4dd2c93a30c9950ccf14f13424ea63eff467" translate="yes" xml:space="preserve">
          <source>When using RAII instead:</source>
          <target state="translated">RAII를 대신 사용하는 경우 :</target>
        </trans-unit>
        <trans-unit id="f80391d56bd8dbe1d1d5d1ff4b40d280c7727957" translate="yes" xml:space="preserve">
          <source>When using Scene3D with Scene3DViews the following conditions are expected:</source>
          <target state="translated">Scene3DViews와 함께 Scene3D를 사용하는 경우 다음 조건이 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="e422bafae46d9dd9ccf967b028eb5668db1686e3" translate="yes" xml:space="preserve">
          <source>When using Shape, it is important to be aware of potential performance implications:</source>
          <target state="translated">Shape를 사용할 때 잠재적 인 성능 영향을 알고 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="0c9b345b7b1fc2466da60489483904127a5bf06c" translate="yes" xml:space="preserve">
          <source>When using Vulkan, a QQuickWindow is automatically associated with a &lt;a href=&quot;qvulkaninstance&quot;&gt;QVulkanInstance&lt;/a&gt; that is created and managed internally by the scene graph. This way most applications do not need to worry about having a &lt;code&gt;VkInstance&lt;/code&gt; available since it all happens automatically. In advanced cases an application may wish to create its own &lt;a href=&quot;qvulkaninstance&quot;&gt;QVulkanInstance&lt;/a&gt;, in order to configure it in a specific way. That is possible as well. Calling &lt;a href=&quot;qwindow#setVulkanInstance&quot;&gt;setVulkanInstance()&lt;/a&gt; on the QQuickWindow right after construction, before making it visible, leads to using the application-supplied &lt;a href=&quot;qvulkaninstance&quot;&gt;QVulkanInstance&lt;/a&gt; (and the underlying &lt;code&gt;VkInstance&lt;/code&gt;). When redirecting via &lt;a href=&quot;qquickrendercontrol&quot;&gt;QQuickRenderControl&lt;/a&gt;, there is no &lt;a href=&quot;qvulkaninstance&quot;&gt;QVulkanInstance&lt;/a&gt; provided automatically, but rather the application is expected to provide its own and associate it with the QQuickWindow.</source>
          <target state="translated">Vulkan을 사용할 때 QQuickWindow는 장면 그래프에 의해 내부적으로 생성되고 관리되는 &lt;a href=&quot;qvulkaninstance&quot;&gt;QVulkanInstance&lt;/a&gt; 와 자동으로 연결됩니다 . 이렇게하면 대부분의 응용 프로그램은 &lt;code&gt;VkInstance&lt;/code&gt; 를 사용할 수 있는지 에 대해 걱정할 필요가 없습니다 . 모든 것이 자동으로 수행되기 때문입니다. 고급의 경우 애플리케이션은 특정 방식으로 구성하기 위해 자체 &lt;a href=&quot;qvulkaninstance&quot;&gt;QVulkanInstance&lt;/a&gt; 를 만들 수 있습니다 . 그것도 가능합니다. 생성 &lt;a href=&quot;qwindow#setVulkanInstance&quot;&gt;직후 QQuickWindow에서 setVulkanInstance ()&lt;/a&gt; 를 호출 하여 표시하기 전에 애플리케이션에서 제공하는 &lt;a href=&quot;qvulkaninstance&quot;&gt;QVulkanInstance&lt;/a&gt; (및 기본 &lt;code&gt;VkInstance&lt;/code&gt; )를 사용합니다. 를 통해 리디렉션하면 &lt;a href=&quot;qquickrendercontrol&quot;&gt;QQuickRenderControl&lt;/a&gt; , 어떤이 없습니다&lt;a href=&quot;qvulkaninstance&quot;&gt;QVulkanInstance&lt;/a&gt; 는 자동으로 제공되지만 애플리케이션은 자체를 제공하고이를 QQuickWindow와 연결해야합니다.</target>
        </trans-unit>
        <trans-unit id="a851e0e65e59f989e18111dd9dfcb0d6119a5f48" translate="yes" xml:space="preserve">
          <source>When using a &lt;a href=&quot;qmessagebox&quot;&gt;QMessageBox&lt;/a&gt; with standard buttons, this function returns a &lt;a href=&quot;qmessagebox#StandardButton-enum&quot;&gt;StandardButton&lt;/a&gt; value indicating the standard button that was clicked. When using &lt;a href=&quot;qmessagebox&quot;&gt;QMessageBox&lt;/a&gt; with custom buttons, this function returns an opaque value; use &lt;a href=&quot;qmessagebox#clickedButton&quot;&gt;clickedButton&lt;/a&gt;() to determine which button was clicked.</source>
          <target state="translated">표준 버튼과 함께 &lt;a href=&quot;qmessagebox&quot;&gt;QMessageBox&lt;/a&gt; 를 사용하는 경우이 함수 는 클릭 한 표준 버튼을 나타내는 &lt;a href=&quot;qmessagebox#StandardButton-enum&quot;&gt;StandardButton&lt;/a&gt; 값을 반환합니다 . 사용자 정의 버튼과 함께 &lt;a href=&quot;qmessagebox&quot;&gt;QMessageBox&lt;/a&gt; 를 사용하는 경우이 함수는 불투명 한 값을 반환합니다. &lt;a href=&quot;qmessagebox#clickedButton&quot;&gt;clickedButton&lt;/a&gt; ()을 사용하여 클릭 한 버튼을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="30651043e9ed73a939b318e30f3870f1b9b5bc98" translate="yes" xml:space="preserve">
          <source>When using a &lt;a href=&quot;qpropertyanimation&quot;&gt;QPropertyAnimation&lt;/a&gt;, the associated easing curve will be used to control the progress of the interpolation between startValue and endValue:</source>
          <target state="translated">&lt;a href=&quot;qpropertyanimation&quot;&gt;QPropertyAnimation을&lt;/a&gt; 사용할 때 관련된 여유 곡선을 사용하여 startValue와 endValue 사이의 보간 진행률을 제어합니다.</target>
        </trans-unit>
        <trans-unit id="5a31447cc9a9078502d4a9e972623e7f14cea339" translate="yes" xml:space="preserve">
          <source>When using a &lt;a href=&quot;qquickrendercontrol&quot;&gt;QQuickRenderControl&lt;/a&gt; to render a Qt Quick user interface to an OpenGL surface, the &lt;a href=&quot;qml-qtwebengine-webengineview&quot;&gt;WebEngineView&lt;/a&gt; type is not rendered correctly. The web engine view attempts to use a global OpenGL context created by &lt;a href=&quot;qtwebengine#initialize&quot;&gt;QtWebEngine::initialize&lt;/a&gt;, but there is no public API for accessing that context in order to share it with the &lt;code&gt;QQuickRenderControl&lt;/code&gt; context.</source>
          <target state="translated">사용하는 경우 &lt;a href=&quot;qquickrendercontrol&quot;&gt;QQuickRenderControl을&lt;/a&gt; OpenGL은 표면에 Qt는 빠른 사용자 인터페이스를 렌더링의 &lt;a href=&quot;qml-qtwebengine-webengineview&quot;&gt;WebEngineView의&lt;/a&gt; 유형은 제대로 렌더링되지 않습니다. 웹 엔진보기는 &lt;a href=&quot;qtwebengine#initialize&quot;&gt;QtWebEngine :: initialize에&lt;/a&gt; 의해 작성된 글로벌 OpenGL 컨텍스트를 사용하려고 시도 하지만 &lt;code&gt;QQuickRenderControl&lt;/code&gt; 컨텍스트 와 공유하기 위해 해당 컨텍스트에 액세스하기위한 공용 API는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="0a571dc6486203daf8731422c32ede8be4dfec57" translate="yes" xml:space="preserve">
          <source>When using a &lt;a href=&quot;qquickrendercontrol&quot;&gt;QQuickRenderControl&lt;/a&gt; to render a Qt Quick user interface to an OpenGL surface, the WebEngineView type is not rendered correctly. The web engine view attempts to use a global OpenGL context created by &lt;a href=&quot;qtwebengine#initialize&quot;&gt;QtWebEngine::initialize&lt;/a&gt;, but there is no public API for accessing that context in order to share it with the &lt;code&gt;QQuickRenderControl&lt;/code&gt; context.</source>
          <target state="translated">&lt;a href=&quot;qquickrendercontrol&quot;&gt;QQuickRenderControl&lt;/a&gt; 을 사용하여 Qt Quick 사용자 인터페이스를 OpenGL 표면에 렌더링 할 때 WebEngineView 유형이 올바르게 렌더링되지 않습니다. 웹 엔진 뷰는 &lt;a href=&quot;qtwebengine#initialize&quot;&gt;QtWebEngine :: initialize에&lt;/a&gt; 의해 생성 된 전역 OpenGL 컨텍스트를 사용하려고 시도 하지만 &lt;code&gt;QQuickRenderControl&lt;/code&gt; 컨텍스트 와 공유하기 위해 해당 컨텍스트에 액세스하기위한 공용 API가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="60e200581fc9c0dbc0f625c7881a7ac6d7e373bc" translate="yes" xml:space="preserve">
          <source>When using a &lt;a href=&quot;qquickrendercontrol&quot;&gt;QQuickRenderControl&lt;/a&gt;, the &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt; does not have to be shown or even created at all. This means there will not be an underlying native window for it. Instead, the &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt; instance is associated with the render control, using the overload of the &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt; constructor, and an OpenGL framebuffer object by calling &lt;a href=&quot;qquickwindow#setRenderTarget&quot;&gt;QQuickWindow::setRenderTarget&lt;/a&gt;().</source>
          <target state="translated">사용하는 경우 &lt;a href=&quot;qquickrendercontrol&quot;&gt;QQuickRenderControl을&lt;/a&gt; 의 &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow는&lt;/a&gt; 표시하거나 전혀 생성 할 필요가 없습니다. 이것은 기본 윈도우가 없다는 것을 의미합니다. 대신 &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt; 인스턴스는 &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt; 생성자 오버로드 와 &lt;a href=&quot;qquickwindow#setRenderTarget&quot;&gt;QQuickWindow :: setRenderTarget&lt;/a&gt; () 을 호출하여 OpenGL framebuffer 객체를 사용하여 렌더링 컨트롤과 연결됩니다 .</target>
        </trans-unit>
        <trans-unit id="9c0f7af3daf2a24d712370fbb31d193c69bdb078" translate="yes" xml:space="preserve">
          <source>When using a &lt;a href=&quot;qsortfilterproxymodel&quot;&gt;QSortFilterProxyModel&lt;/a&gt;, its indexes have their own internal pointer. It is not advisable to access this internal pointer outside of the model. Use the &lt;a href=&quot;qabstractitemmodel#data&quot;&gt;data&lt;/a&gt;() function instead.</source>
          <target state="translated">&lt;a href=&quot;qsortfilterproxymodel&quot;&gt;QSortFilterProxyModel을&lt;/a&gt; 사용할 때 색인에는 자체 내부 포인터가 있습니다. 모델 외부에서이 내부 포인터에 액세스하는 것은 좋지 않습니다. 사용 &lt;a href=&quot;qabstractitemmodel#data&quot;&gt;데이터&lt;/a&gt; 대신 () 함수를.</target>
        </trans-unit>
        <trans-unit id="3253f7be2be37eee03bfba036af9e50c1f08039e" translate="yes" xml:space="preserve">
          <source>When using a QQuickRenderControl, the &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt; does not have to be shown or even created at all. This means there will not be an underlying native window for it. Instead, the &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt; instance is associated with the render control, using the overload of the &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt; constructor, and a texture or image object specified via &lt;a href=&quot;qquickwindow#setRenderTarget&quot;&gt;QQuickWindow::setRenderTarget&lt;/a&gt;().</source>
          <target state="translated">QQuickRenderControl를 사용하는 경우, &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow는&lt;/a&gt; 표시하거나 전혀 생성 할 필요가 없습니다. 이것은 그것에 대한 기본 네이티브 창이 없다는 것을 의미합니다. 대신 &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt; 인스턴스는 &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt; 생성자 의 오버로드 와 &lt;a href=&quot;qquickwindow#setRenderTarget&quot;&gt;QQuickWindow :: setRenderTarget&lt;/a&gt; ()을 통해 지정된 텍스처 또는 이미지 개체를 사용하여 렌더링 컨트롤과 연결됩니다 .</target>
        </trans-unit>
        <trans-unit id="a88d7821b71c83767d5c98f6683690b451dd882b" translate="yes" xml:space="preserve">
          <source>When using a QQuickRenderControl, the &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt; does not have to be shown or even created at all. This means there will not be an underlying native window for it. Instead, the &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt; instance is associated with the render control, using the overload of the &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt; constructor, and an OpenGL framebuffer object by calling &lt;a href=&quot;qquickwindow#setRenderTarget&quot;&gt;QQuickWindow::setRenderTarget&lt;/a&gt;().</source>
          <target state="translated">QQuickRenderControl를 사용하는 경우, &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow는&lt;/a&gt; 표시하거나 전혀 생성 할 필요가 없습니다. 이것은 그것에 대한 기본 기본 창이 없다는 것을 의미합니다. 대신 &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt; 인스턴스는 &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt; 생성자 의 오버로드를 사용하여 렌더링 컨트롤과 연결되고 &lt;a href=&quot;qquickwindow#setRenderTarget&quot;&gt;QQuickWindow :: setRenderTarget&lt;/a&gt; () 을 호출하여 OpenGL 프레임 버퍼 개체를 사용 합니다 .</target>
        </trans-unit>
        <trans-unit id="cd633ea15d629a0822189477ace7c2e694f5b907" translate="yes" xml:space="preserve">
          <source>When using a camera, there are several times when some form of feedback to the user is given - for example, when an image is taken, or when recording is started. You can enable or disable some of this feedback, or adjust what sound might be played for these actions.</source>
          <target state="translated">카메라를 사용할 때 이미지가 촬영되거나 녹화가 시작되는 등 사용자에게 어떤 형태의 피드백이 제공 될 때가 여러 번 있습니다. 이 피드백 중 일부를 활성화 또는 비활성화하거나 이러한 동작에 대해 재생할 사운드를 조정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="57ef1cc43a22d3ee9d7ad2ec71b8d3288bb14e4d" translate="yes" xml:space="preserve">
          <source>When using a generator the data will be loaded asynchronously in a job. The loaded data can be read back if the &lt;a href=&quot;qt3drender-qbuffer#syncData-prop&quot;&gt;QBuffer::syncData&lt;/a&gt; flag is set to true.</source>
          <target state="translated">생성기를 사용할 때 데이터가 작업에 비동기 적으로로드됩니다. &lt;a href=&quot;qt3drender-qbuffer#syncData-prop&quot;&gt;QBuffer :: syncData&lt;/a&gt; 플래그가 true로 설정된 경우로드 된 데이터를 다시 읽을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4a99ea3d9c74b7bdbe4f19c498b2969932d3fbb5" translate="yes" xml:space="preserve">
          <source>When using a link-local or site-local address for IPv6 connections, you must specify the scope ID. The scope ID for a link-local address is usually the same as the interface name (e.g., &quot;eth0&quot;, &quot;en1&quot;) or number (e.g., &quot;1&quot;, &quot;2&quot;).</source>
          <target state="translated">IPv6 연결에 링크 로컬 또는 사이트 로컬 주소를 사용하는 경우 범위 ID를 지정해야합니다. 링크 로컬 주소의 범위 ID는 일반적으로 인터페이스 이름 (예 : &quot;eth0&quot;, &quot;en1&quot;) 또는 숫자 (예 : &quot;1&quot;, &quot;2&quot;)와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="a7f5a0c47b510324b9693fda936ac9e1340194e1" translate="yes" xml:space="preserve">
          <source>When using a local connection, a unique name must be used. For tcp connections, a unique address and port number combination much be used.</source>
          <target state="translated">로컬 연결을 사용할 때는 고유 한 이름을 사용해야합니다. TCP 연결의 경우 고유 한 주소와 포트 번호 조합이 많이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c2f9377446ae02ec808861ff5dcc31b378366901" translate="yes" xml:space="preserve">
          <source>When using a non-attached &lt;a href=&quot;qml-qtquick-controls2-scrollbar&quot;&gt;ScrollBar&lt;/a&gt;, the following must be done manually:</source>
          <target state="translated">첨부되지 않은 &lt;a href=&quot;qml-qtquick-controls2-scrollbar&quot;&gt;ScrollBar를&lt;/a&gt; 사용하는 경우 다음을 수동으로 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="6da62cb45d6ee1b90ef5d92ea4bb2964d3440f6e" translate="yes" xml:space="preserve">
          <source>When using a non-attached ScrollBar, the following must be done manually:</source>
          <target state="translated">연결되지 않은 ScrollBar를 사용하는 경우 다음을 수동으로 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="54441c60f964e66b066ac92b3af3ac7719c4b710" translate="yes" xml:space="preserve">
          <source>When using a scroll area to display the contents of a custom widget, it is important to ensure that the &lt;a href=&quot;qwidget#sizeHint-prop&quot;&gt;size hint&lt;/a&gt; of the child widget is set to a suitable value. If a standard &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; is used for the child widget, it may be necessary to call &lt;a href=&quot;qwidget#minimumSize-prop&quot;&gt;QWidget::setMinimumSize&lt;/a&gt;() to ensure that the contents of the widget are shown correctly within the scroll area.</source>
          <target state="translated">스크롤 영역을 사용하여 사용자 정의 위젯의 컨텐츠를 표시 할 때 하위 위젯 의 &lt;a href=&quot;qwidget#sizeHint-prop&quot;&gt;크기 힌트&lt;/a&gt; 가 적절한 값으로 설정되어 있는지 확인하는 것이 중요 합니다. 하위 위젯에 표준 &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; 을 사용하는 경우 위젯 컨텐츠가 스크롤 영역 내에 올바르게 표시되도록 &lt;a href=&quot;qwidget#minimumSize-prop&quot;&gt;QWidget :: setMinimumSize&lt;/a&gt; ()를 호출해야 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7bc88faa885d5cad5c7f827526a87ebbbef568f0" translate="yes" xml:space="preserve">
          <source>When using a scroll area to display the contents of a custom widget, it is important to ensure that the &lt;a href=&quot;qwidget#sizeHint-prop&quot;&gt;size hint&lt;/a&gt; of the child widget is set to a suitable value. If a standard &lt;a href=&quot;widgets-changes-qt6#qwidget&quot;&gt;QWidget&lt;/a&gt; is used for the child widget, it may be necessary to call &lt;a href=&quot;qwidget#minimumSize-prop&quot;&gt;QWidget::setMinimumSize&lt;/a&gt;() to ensure that the contents of the widget are shown correctly within the scroll area.</source>
          <target state="translated">스크롤 영역을 사용하여 사용자 정의 위젯의 내용을 표시 할 때 하위 위젯 의 &lt;a href=&quot;qwidget#sizeHint-prop&quot;&gt;크기 힌트&lt;/a&gt; 가 적절한 값으로 설정되어 있는지 확인하는 것이 중요 합니다. 하위 위젯에 표준 &lt;a href=&quot;widgets-changes-qt6#qwidget&quot;&gt;QWidget&lt;/a&gt; 을 사용하는 경우 위젯 의 내용이 스크롤 영역 내에서 올바르게 표시되도록하려면 &lt;a href=&quot;qwidget#minimumSize-prop&quot;&gt;QWidget :: setMinimumSize&lt;/a&gt; ()를 호출해야 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="237a8500ee38265470768b77eb9c5ecf303eea63" translate="yes" xml:space="preserve">
          <source>When using an &lt;a href=&quot;qpainter#RenderHint-enum&quot;&gt;anti-aliased&lt;/a&gt; painter, the boundary line of a &lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt; will be rendered symmetrically on both sides of the mathematical rectangle's boundary line. But when using an aliased painter (the default) other rules apply.</source>
          <target state="translated">&lt;a href=&quot;qpainter#RenderHint-enum&quot;&gt;앤티 앨리어싱 된&lt;/a&gt; 페인터를 사용하는 경우 &lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt; 의 경계선은 수학 사각형의 경계선 양쪽에 대칭으로 렌더링됩니다. 그러나 별명을 사용하는 화가 (기본값)를 사용하는 경우 다른 규칙이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="f114b9cf2bdf5128d5944856498efe44e97fd95c" translate="yes" xml:space="preserve">
          <source>When using an &lt;a href=&quot;qpainter#RenderHint-enum&quot;&gt;anti-aliased&lt;/a&gt; painter, the boundary line of a &lt;a href=&quot;qrectf&quot;&gt;QRectF&lt;/a&gt; will be rendered symmetrically on both sides of the mathematical rectangle's boundary line. But when using an aliased painter (the default) other rules apply.</source>
          <target state="translated">&lt;a href=&quot;qpainter#RenderHint-enum&quot;&gt;앤티 앨리어싱 된&lt;/a&gt; 페인터를 사용하는 경우 &lt;a href=&quot;qrectf&quot;&gt;QRectF&lt;/a&gt; 의 경계선은 수학 사각형의 경계선 양쪽에 대칭으로 렌더링됩니다. 그러나 별명을 사용하는 화가 (기본값)를 사용하는 경우 다른 규칙이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="329d3637523def7a6d1c7ee9fe4ece6f4bdc8c4b" translate="yes" xml:space="preserve">
          <source>When using an &lt;a href=&quot;qpainter#RenderHint-enum&quot;&gt;anti-aliased&lt;/a&gt; painter, the boundary line of a QRect will be rendered symmetrically on both sides of the mathematical rectangle's boundary line. But when using an aliased painter (the default) other rules apply.</source>
          <target state="translated">&lt;a href=&quot;qpainter#RenderHint-enum&quot;&gt;앤티 앨리어싱 된&lt;/a&gt; 페인터를 사용할 때 QRect의 경계선은 수학 직사각형의 경계선 양쪽에서 대칭으로 렌더링됩니다. 그러나 별칭이 지정된 화가 (기본값)를 사용할 때 다른 규칙이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="cccfc9b262e50cc0b347cae5b9d8220cd04d8f64" translate="yes" xml:space="preserve">
          <source>When using an &lt;a href=&quot;qpainter#RenderHint-enum&quot;&gt;anti-aliased&lt;/a&gt; painter, the boundary line of a QRectF will be rendered symmetrically on both sides of the mathematical rectangle's boundary line. But when using an aliased painter (the default) other rules apply.</source>
          <target state="translated">&lt;a href=&quot;qpainter#RenderHint-enum&quot;&gt;앤티 앨리어싱 된&lt;/a&gt; 페인터를 사용할 때 QRectF의 경계선은 수학 직사각형 경계선의 양쪽에서 대칭으로 렌더링됩니다. 그러나 별칭이 지정된 화가 (기본값)를 사용할 때 다른 규칙이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="8f28cb22408509ba937d73e207cf823f044e3c30" translate="yes" xml:space="preserve">
          <source>When using enum classes, there can be multiple enums using the same identifiers. The unscoped registration will be overwriten by the last registered enum. For classes that contain such name conficts it is possible to disable the unscoped registration by annotating your class with a special &lt;a href=&quot;qobject#Q_CLASSINFO&quot;&gt;Q_CLASSINFO&lt;/a&gt; macro. Use the name &lt;code&gt;RegisterEnumClassesUnscoped&lt;/code&gt; with the value &lt;code&gt;false&lt;/code&gt; to prevent scoped enums from being merged into the same name space.</source>
          <target state="translated">열거 형 클래스를 사용할 때 동일한 식별자를 사용하는 여러 열거 형이있을 수 있습니다. 범위가 지정되지 않은 등록은 마지막으로 등록 된 열거 형으로 덮어 씁니다. 이러한 이름이 포함 된 클래스의 경우 특수 &lt;a href=&quot;qobject#Q_CLASSINFO&quot;&gt;Q_CLASSINFO&lt;/a&gt; 매크로로 클래스에 주석을 달아 범위가 지정되지 않은 등록을 비활성화 할 수 있습니다 . 범위가 지정된 열거가 동일한 이름 공간에 병합되지 않도록 이름 &lt;code&gt;RegisterEnumClassesUnscoped&lt;/code&gt; 를 &lt;code&gt;false&lt;/code&gt; 값과 함께 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="b3126c9de4f125026d9844406caca004b124783e" translate="yes" xml:space="preserve">
          <source>When using files with relative paths, the path should be relative to the file where &lt;a href=&quot;qml-qtqml-qt#createComponent-method&quot;&gt;Qt.createComponent()&lt;/a&gt; is executed.</source>
          <target state="translated">상대 경로가있는 파일을 사용할 때 경로는 &lt;a href=&quot;qml-qtqml-qt#createComponent-method&quot;&gt;Qt.createComponent ()&lt;/a&gt; 가 실행되는 파일에 상대적인 경로 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="05136cc2fa83900ae89c6a84b5c5f5b066eb03d6" translate="yes" xml:space="preserve">
          <source>When using minimum and maximum extents, these are considered to be the opposite corners of an axis aligned bounding box, in the geometry's local coordinate system.</source>
          <target state="translated">최소 및 최대 범위를 사용하는 경우 지오메트리의 로컬 좌표계에서 축 정렬 경계 상자의 반대쪽 모서리로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="f5f60225ff679f2aec3bcaa7f21687a9cdf848c4" translate="yes" xml:space="preserve">
          <source>When using models that have multiple named roles, &lt;a href=&quot;qml-qtquick-controls2-combobox&quot;&gt;ComboBox&lt;/a&gt; must be configured to use a specific &lt;a href=&quot;qml-qtquick-controls2-combobox#textRole-prop&quot;&gt;text role&lt;/a&gt; for its &lt;a href=&quot;qml-qtquick-controls2-combobox#displayText-prop&quot;&gt;display text&lt;/a&gt; and &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtquickcontrols-chattutorial-example.html#delegate&quot;&gt;delegate&lt;/a&gt; instances.</source>
          <target state="translated">명명 된 여러 역할이 모델을 사용하는 경우, &lt;a href=&quot;qml-qtquick-controls2-combobox&quot;&gt;콤보는&lt;/a&gt; 특정의 사용하도록 구성해야합니다 &lt;a href=&quot;qml-qtquick-controls2-combobox#textRole-prop&quot;&gt;텍스트 역할을&lt;/a&gt; 자사에 대한 &lt;a href=&quot;qml-qtquick-controls2-combobox#displayText-prop&quot;&gt;표시 텍스트&lt;/a&gt; 및 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtquickcontrols-chattutorial-example.html#delegate&quot;&gt;위임&lt;/a&gt; 인스턴스.</target>
        </trans-unit>
        <trans-unit id="f9d8a722032ee00831331d0ac92b8b27597b4afb" translate="yes" xml:space="preserve">
          <source>When using models that have multiple named roles, ComboBox must be configured to use a specific &lt;a href=&quot;qml-qtquick-controls2-combobox#textRole-prop&quot;&gt;text role&lt;/a&gt; for its &lt;a href=&quot;qml-qtquick-controls2-combobox#displayText-prop&quot;&gt;display text&lt;/a&gt; and &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtquickcontrols-chattutorial-example.html#delegate&quot;&gt;delegate&lt;/a&gt; instances. If you want to use a role of the model item that corresponds to the text role, set &lt;a href=&quot;qml-qtquick-controls2-combobox#valueRole-prop&quot;&gt;valueRole&lt;/a&gt;. The &lt;a href=&quot;qml-qtquick-controls2-combobox#currentValue-prop&quot;&gt;currentValue&lt;/a&gt; property and &lt;a href=&quot;qml-qtquick-controls2-combobox#indexOfValue-method&quot;&gt;indexOfValue()&lt;/a&gt; method can then be used to get information about those values.</source>
          <target state="translated">여러 명명 된 역할이있는 모델을 사용하는 경우 &lt;a href=&quot;qml-qtquick-controls2-combobox#displayText-prop&quot;&gt;표시 텍스트&lt;/a&gt; 및 &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtquickcontrols-chattutorial-example.html#delegate&quot;&gt;위임&lt;/a&gt; 인스턴스에 대해 특정 &lt;a href=&quot;qml-qtquick-controls2-combobox#textRole-prop&quot;&gt;텍스트 역할&lt;/a&gt; 을 사용하도록 ComboBox를 구성해야합니다 . 텍스트 역할에 해당하는 모델 항목의 역할을 사용하려면 &lt;a href=&quot;qml-qtquick-controls2-combobox#valueRole-prop&quot;&gt;valueRole을&lt;/a&gt; 설정 하십시오 . 그런 다음 &lt;a href=&quot;qml-qtquick-controls2-combobox#currentValue-prop&quot;&gt;currentValue&lt;/a&gt; 속성 및 &lt;a href=&quot;qml-qtquick-controls2-combobox#indexOfValue-method&quot;&gt;indexOfValue ()&lt;/a&gt; 메서드를 사용하여 해당 값에 대한 정보를 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="592ced4892c306ac3db6fd37ad0058a8f5ee66f8" translate="yes" xml:space="preserve">
          <source>When using models that have multiple named roles, ComboBox must be configured to use a specific &lt;a href=&quot;qml-qtquick-controls2-combobox#textRole-prop&quot;&gt;text role&lt;/a&gt; for its &lt;a href=&quot;qml-qtquick-controls2-combobox#displayText-prop&quot;&gt;display text&lt;/a&gt; and &lt;a href=&quot;https://doc.qt.io/qt-6.0/qtquickcontrols-chattutorial-example.html#delegate&quot;&gt;delegate&lt;/a&gt; instances. If you want to use a role of the model item that corresponds to the text role, set &lt;a href=&quot;qml-qtquick-controls2-combobox#valueRole-prop&quot;&gt;valueRole&lt;/a&gt;. The &lt;a href=&quot;qml-qtquick-controls2-combobox#currentValue-prop&quot;&gt;currentValue&lt;/a&gt; property and &lt;a href=&quot;qml-qtquick-controls2-combobox#indexOfValue-method&quot;&gt;indexOfValue()&lt;/a&gt; method can then be used to get information about those values.</source>
          <target state="translated">여러 명명 된 역할이있는 모델을 사용하는 경우 &lt;a href=&quot;qml-qtquick-controls2-combobox#displayText-prop&quot;&gt;표시 텍스트&lt;/a&gt; 및 &lt;a href=&quot;https://doc.qt.io/qt-6.0/qtquickcontrols-chattutorial-example.html#delegate&quot;&gt;위임&lt;/a&gt; 인스턴스에 대해 특정 &lt;a href=&quot;qml-qtquick-controls2-combobox#textRole-prop&quot;&gt;텍스트 역할&lt;/a&gt; 을 사용하도록 ComboBox를 구성해야합니다 . 텍스트 역할에 해당하는 모델 항목의 역할을 사용하려면 &lt;a href=&quot;qml-qtquick-controls2-combobox#valueRole-prop&quot;&gt;valueRole을&lt;/a&gt; 설정 하십시오 . 그런 다음 &lt;a href=&quot;qml-qtquick-controls2-combobox#currentValue-prop&quot;&gt;currentValue&lt;/a&gt; 속성 및 &lt;a href=&quot;qml-qtquick-controls2-combobox#indexOfValue-method&quot;&gt;indexOfValue ()&lt;/a&gt; 메서드를 사용하여 해당 값에 대한 정보를 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="84026de8d0a3f70ccf99a3d61c901fae1dc693fe" translate="yes" xml:space="preserve">
          <source>When using more than one parameter, or when an argument contains whitespace, enclose each argument in braces:</source>
          <target state="translated">둘 이상의 매개 변수를 사용하거나 인수에 공백이 포함 된 경우 각 인수를 중괄호로 묶습니다.</target>
        </trans-unit>
        <trans-unit id="63464950e02567c5f6896365686d6ecf23afb027" translate="yes" xml:space="preserve">
          <source>When using multiple containers, such as &lt;a href=&quot;qml-qtquick-controls2-tabbar&quot;&gt;TabBar&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-controls2-swipeview&quot;&gt;SwipeView&lt;/a&gt;, together, their &lt;a href=&quot;qml-qtquick-controls2-container#currentIndex-prop&quot;&gt;currentIndex&lt;/a&gt; properties can be bound to each other to keep them in sync. When the user interacts with either container, its current index changes automatically propagate to the other container.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-controls2-tabbar&quot;&gt;TabBar&lt;/a&gt; 및 &lt;a href=&quot;qml-qtquick-controls2-swipeview&quot;&gt;SwipeView&lt;/a&gt; 와 같은 여러 컨테이너를 함께 사용하는 경우 &lt;a href=&quot;qml-qtquick-controls2-container#currentIndex-prop&quot;&gt;currentIndex&lt;/a&gt; 속성을 서로 바인딩하여 동기화 상태를 유지할 수 있습니다. 사용자가 두 컨테이너 중 하나와 상호 작용하면 현재 인덱스 변경 사항이 자동으로 다른 컨테이너로 전파됩니다.</target>
        </trans-unit>
        <trans-unit id="c02b1287c2c05e3b9d628e626b4034e4caa62387" translate="yes" xml:space="preserve">
          <source>When using multiple containers, such as &lt;a href=&quot;qtquickcontrols2-navigation#tabbar&quot;&gt;TabBar&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-controls2-swipeview&quot;&gt;SwipeView&lt;/a&gt;, together, their &lt;a href=&quot;qml-qtquick-controls2-container#currentIndex-prop&quot;&gt;currentIndex&lt;/a&gt; properties can be bound to each other to keep them in sync. When the user interacts with either container, its current index changes automatically propagate to the other container.</source>
          <target state="translated">&lt;a href=&quot;qtquickcontrols2-navigation#tabbar&quot;&gt;TabBar&lt;/a&gt; 및 &lt;a href=&quot;qml-qtquick-controls2-swipeview&quot;&gt;SwipeView&lt;/a&gt; 와 같은 여러 컨테이너를 함께 사용하는 경우 &lt;a href=&quot;qml-qtquick-controls2-container#currentIndex-prop&quot;&gt;currentIndex&lt;/a&gt; 속성을 서로 바인딩하여 동기화 상태를 유지할 수 있습니다. 사용자가 컨테이너 중 하나와 상호 작용하면 현재 색인 변경 사항이 다른 컨테이너에 자동으로 전파됩니다.</target>
        </trans-unit>
        <trans-unit id="ca9be1c0704ec7f9de07358b36382bb3fde46554" translate="yes" xml:space="preserve">
          <source>When using multiple subviewports in the FrameGraph, NoPicking can be useful to prevent picking conflicts between overlapping viewports or non visual ones. It can also be used as an optimization to prevent unnecessary work for hidden viewports or for sections of the scenes which don't require any picking.</source>
          <target state="translated">FrameGraph에서 여러 하위 뷰포트를 사용할 때 NoPicking은 겹치는 뷰포트 또는 비 시각적 뷰포트 간의 선택 충돌을 방지하는 데 유용 할 수 있습니다. 숨겨진 뷰포트 또는 선택이 필요하지 않은 장면 섹션에 대한 불필요한 작업을 방지하기위한 최적화로 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ba136a12eb6326be4975550c6ccf182f6dc733c" translate="yes" xml:space="preserve">
          <source>When using multiple subviewports in the FrameGraph, QNoPicking can be useful to prevent picking conflicts between overlapping viewports or non visual ones. It can also be used as an optimization to prevent unnecessary work for hidden viewports or for sections of the scenes which don't require any picking.</source>
          <target state="translated">FrameGraph에서 여러 하위 뷰포트를 사용할 때 QNoPicking은 겹치는 뷰포트 또는 비 시각적 뷰포트 간의 선택 충돌을 방지하는 데 유용 할 수 있습니다. 숨겨진 뷰포트 또는 선택이 필요하지 않은 장면 섹션에 대한 불필요한 작업을 방지하기위한 최적화로 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="641175720b4c0c2ab3449cc419129333b3bfdd72" translate="yes" xml:space="preserve">
          <source>When using one of the default names, you can call this function in &lt;a href=&quot;qaccessibleactioninterface&quot;&gt;QAccessibleActionInterface&lt;/a&gt; to get the localized string.</source>
          <target state="translated">기본 이름 중 하나를 사용하는 경우 &lt;a href=&quot;qaccessibleactioninterface&quot;&gt;QAccessibleActionInterface&lt;/a&gt; 에서이 함수를 호출 하여 현지화 된 문자열을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f1d4042297fd9e70e9779d429f6a3c3de84a9661" translate="yes" xml:space="preserve">
          <source>When using qmake to build just the Qt WebEngine module, the following command can be used (in this example, the Qt WebEngine source code is located in &lt;code&gt;C:\qt\qtwebengine&lt;/code&gt;):</source>
          <target state="translated">qmake를 사용하여 Qt WebEngine 모듈 만 빌드 할 때 다음 명령을 사용할 수 있습니다 (이 예에서 Qt WebEngine 소스 코드는 &lt;code&gt;C:\qt\qtwebengine&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="eed4f78c25ca0fa8144d6414eb478fa129284fb5" translate="yes" xml:space="preserve">
          <source>When using signals and slots with multiple threads, see &lt;a href=&quot;threads-qobject#signals-and-slots-across-threads&quot;&gt;Signals and Slots Across Threads&lt;/a&gt;.</source>
          <target state="translated">스레드가 여러 개인 신호 및 슬롯을 사용하는 경우 스레드 &lt;a href=&quot;threads-qobject#signals-and-slots-across-threads&quot;&gt;간 신호 및 슬롯을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e7ad568fc4f11eefe9c8b40e9b450dc9cb930b9a" translate="yes" xml:space="preserve">
          <source>When using style sheets, every widget is treated as a box with four concentric rectangles: the margin rectangle, the border rectangle, the padding rectangle, and the content rectangle. The box model describes this in further detail.</source>
          <target state="translated">스타일 시트를 사용할 때 모든 위젯은 여백 사각형, 테두리 사각형, 패딩 사각형 및 내용 사각형의 네 개의 동심 사각형이있는 상자로 처리됩니다. 박스 모델은이를 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="16c96094aa814c7a1c7563b4a9f7232f4480180a" translate="yes" xml:space="preserve">
          <source>When using the &quot;IJW&quot; method, in principle the only limitation is the time required to write the wrapper classes and data type conversion functions.</source>
          <target state="translated">&quot;IJW&quot;메소드를 사용할 때 원칙적으로 유일한 제한 사항은 랩퍼 클래스 및 데이터 유형 변환 함수를 작성하는 데 필요한 시간입니다.</target>
        </trans-unit>
        <trans-unit id="5d54c37317bd3e6ec2902ccadabbc8a4e682a663" translate="yes" xml:space="preserve">
          <source>When using the &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtwebengine-overview.html#qt-webengine-widgets-module&quot;&gt;Qt WebEngine Widgets Module&lt;/a&gt;, &lt;a href=&quot;qwebenginepage#acceptNavigationRequest&quot;&gt;QWebEnginePage::acceptNavigationRequest&lt;/a&gt;() offers further options to accept or block requests.</source>
          <target state="translated">사용하는 경우 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtwebengine-overview.html#qt-webengine-widgets-module&quot;&gt;Qt는 WebEngine 위젯 모듈&lt;/a&gt; , &lt;a href=&quot;qwebenginepage#acceptNavigationRequest&quot;&gt;QWebEnginePage :: acceptNavigationRequest&lt;/a&gt; () 이벤트 추가 옵션을 수락 또는 블록 요청합니다.</target>
        </trans-unit>
        <trans-unit id="754ebecc3841708d8e573d2b2f6eedc39b9c8a36" translate="yes" xml:space="preserve">
          <source>When using the &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtwebengine-overview.html#qt-webengine-widgets-module&quot;&gt;Qt WebEngine Widgets Module&lt;/a&gt;, &lt;a href=&quot;qwebenginepage#acceptNavigationRequest&quot;&gt;QWebEnginePage::acceptNavigationRequest&lt;/a&gt;() offers further options to accept or block requests.</source>
          <target state="translated">사용하는 경우 &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtwebengine-overview.html#qt-webengine-widgets-module&quot;&gt;Qt는 WebEngine 위젯 모듈&lt;/a&gt; , &lt;a href=&quot;qwebenginepage#acceptNavigationRequest&quot;&gt;QWebEnginePage :: acceptNavigationRequest&lt;/a&gt; () 이벤트 추가 옵션을 수락 또는 블록 요청합니다.</target>
        </trans-unit>
        <trans-unit id="6fb6ab57911172363d9a639cf841213adb489aa0" translate="yes" xml:space="preserve">
          <source>When using the &lt;a href=&quot;qml-qtquick3d-view3d#renderMode-prop&quot;&gt;Overlay&lt;/a&gt; mode the 3D scene is directly rendered to the &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt; containing the &lt;a href=&quot;qml-qtquick3d-view3d&quot;&gt;View3D&lt;/a&gt;. Rendering occurs as a result of the signal &lt;a href=&quot;qquickwindow#afterRenderPassRecording&quot;&gt;QQuickWindow::afterRenderPassRecording&lt;/a&gt;() which means that the 3D content will be rendered on top of all other Qt Quick content.</source>
          <target state="translated">사용하는 경우 &lt;a href=&quot;qml-qtquick3d-view3d#renderMode-prop&quot;&gt;오버레이&lt;/a&gt; 모드를 3D 장면을 직접으로 렌더링되는 &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt; 포함하는 &lt;a href=&quot;qml-qtquick3d-view3d&quot;&gt;View3D을&lt;/a&gt; . 렌더링은 &lt;a href=&quot;qquickwindow#afterRenderPassRecording&quot;&gt;QQuickWindow :: afterRenderPassRecording&lt;/a&gt; () 신호의 결과로 발생합니다. 이는 3D 콘텐츠가 다른 모든 Qt Quick 콘텐츠 위에 렌더링됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="0cc560cbad4fa2abdd3851fcc3a031341158f832" translate="yes" xml:space="preserve">
          <source>When using the &lt;a href=&quot;qml-qtquick3d-view3d#renderMode-prop&quot;&gt;Underlay&lt;/a&gt; mode the 3D scene is directly rendered to the &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt; containing the &lt;a href=&quot;qml-qtquick3d-view3d&quot;&gt;View3D&lt;/a&gt;. Rendering occurs as a result of the signal &lt;a href=&quot;qquickwindow#beforeRenderPassRecording&quot;&gt;QQuickWindow::beforeRenderPassRecording&lt;/a&gt;() which means that everything else in Qt Quick will be rendered on top of the 3D content.</source>
          <target state="translated">사용할 때 &lt;a href=&quot;qml-qtquick3d-view3d#renderMode-prop&quot;&gt;밑받침&lt;/a&gt; 모드를 3D 장면을 직접으로 렌더링되는 &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt; 포함하는 &lt;a href=&quot;qml-qtquick3d-view3d&quot;&gt;View3D을&lt;/a&gt; . 렌더링은 &lt;a href=&quot;qquickwindow#beforeRenderPassRecording&quot;&gt;QQuickWindow :: beforeRenderPassRecording&lt;/a&gt; () 신호의 결과로 발생합니다. 이는 Qt Quick의 다른 모든 항목이 3D 콘텐츠 위에 렌더링됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="8ef195bdee4cf1c4a71bf9effed3c312e0927143" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;QtQuick&lt;/code&gt; module, you will need to know how to write QML applications using the QML language. In particular, QML Basics and QML Essentials from the &lt;a href=&quot;qmlapplications&quot;&gt;QML Applications&lt;/a&gt; page.</source>
          <target state="translated">사용하는 경우 &lt;code&gt;QtQuick&lt;/code&gt; 의 모듈을, 당신은 QML 언어를 사용하여 QML 애플리케이션을 작성하는 방법을 알아야합니다. 특히 &lt;a href=&quot;qmlapplications&quot;&gt;QML Applications&lt;/a&gt; 페이지 의 QML Basics 및 QML Essentials .</target>
        </trans-unit>
        <trans-unit id="9dec366696ef07cbdd46b7724c483ed995ac86b0" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;lib&lt;/code&gt; template, the following options can be added to the &lt;a href=&quot;qmake-variable-reference#config&quot;&gt;CONFIG&lt;/a&gt; variable to determine the type of library that is built:</source>
          <target state="translated">&lt;code&gt;lib&lt;/code&gt; 템플리트를 사용할 때 다음 옵션을 &lt;a href=&quot;qmake-variable-reference#config&quot;&gt;CONFIG&lt;/a&gt; 변수에 추가하여 빌드 된 라이브러리 유형을 판별 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d153de69dddd03efc877a5be750870814c8a62b4" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;qt6_add_shaders&lt;/code&gt; function, the &lt;a href=&quot;qtshadertools-qsb&quot;&gt;qsb&lt;/a&gt; tool will get invokved automatically by the build system, and the resulting &lt;code&gt;.qsb&lt;/code&gt; files get added to the resource system implicitly.</source>
          <target state="translated">사용하는 경우 &lt;code&gt;qt6_add_shaders&lt;/code&gt; 이 기능의 &lt;a href=&quot;qtshadertools-qsb&quot;&gt;QSB의&lt;/a&gt; 도구는 빌드 시스템에 의해 자동으로 invokved 얻을 것이다, 그 결과 &lt;code&gt;.qsb&lt;/code&gt; 의 파일은 암시 적 자원 시스템에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="1accbb909d9654643b1007c4b005eaf944aacb54" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;subdirs&lt;/code&gt; template, this option specifies that the directories listed should be processed in the order in which they are given.</source>
          <target state="translated">사용하는 경우 &lt;code&gt;subdirs&lt;/code&gt; 템플릿을 디렉토리 나열이 옵션의 지정은 주어진 순서대로 처리해야한다.</target>
        </trans-unit>
        <trans-unit id="9302e4403ba3d658ded6f72d8e2eb9b0d3b0d85a" translate="yes" xml:space="preserve">
          <source>When using the OpenGL adaptation, the returned texture will be using &lt;code&gt;GL_TEXTURE_2D&lt;/code&gt; as texture target and &lt;code&gt;GL_RGBA&lt;/code&gt; as internal format. Reimplement &lt;a href=&quot;qsgtexture&quot;&gt;QSGTexture&lt;/a&gt; to create textures with different parameters.</source>
          <target state="translated">OpenGL 적응을 사용할 때 반환 된 텍스처는 &lt;code&gt;GL_TEXTURE_2D&lt;/code&gt; 를 텍스처 대상으로 사용하고 &lt;code&gt;GL_RGBA&lt;/code&gt; 를 내부 형식으로 사용합니다. &lt;a href=&quot;qsgtexture&quot;&gt;QSGTexture&lt;/a&gt; 를 다시 구현 하여 다른 매개 변수로 텍스처를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="5f5b2c24ae4c28b1f7b4b66c98b3d23e3e684245" translate="yes" xml:space="preserve">
          <source>When using the Qt Purchasing API in QML, the application should instantiate one Store and then instantiate products as children of this store. The products created as children of the Store object will automatically be queried from the external market place if one is available on the current platform.</source>
          <target state="translated">QML에서 Qt Purchasing API를 사용하는 경우 애플리케이션은 하나의 상점을 인스턴스화 한 후 제품을이 상점의 하위로 인스턴스화해야합니다. 상점 오브젝트의 하위로 작성된 제품은 현재 플랫폼에서 사용 가능한 경우 외부 마켓 플레이스에서 자동으로 조회됩니다.</target>
        </trans-unit>
        <trans-unit id="f6f72840bfb0e735f7adfc573a48c8e922aaa4b7" translate="yes" xml:space="preserve">
          <source>When using the Qt Quick Timeline there are no code changes required when porting to Qt 6.</source>
          <target state="translated">Qt Quick Timeline을 사용하는 경우 Qt 6으로 이식 할 때 코드를 변경할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="fd10ad4c60e4d2d39aa84088b49311a2cd15a737" translate="yes" xml:space="preserve">
          <source>When using the RHI, the signal is emitted after scene graph has added its commands to the command buffer, which is not yet submitted to the graphics queue. If desired, the slot function connected to this signal can query native resources, like the command buffer, before via &lt;a href=&quot;qsgrendererinterface&quot;&gt;QSGRendererInterface&lt;/a&gt;. Note however that the render pass (or passes) are already recorded at this point and it is not possible to add more commands within the scenegraph's pass. Instead, use &lt;a href=&quot;qquickwindow#afterRenderPassRecording&quot;&gt;afterRenderPassRecording&lt;/a&gt;() for that. This signal has therefore limited use and is rarely needed in an RHI-based setup. Rather, it is the combination of &lt;a href=&quot;qquickwindow#beforeRendering&quot;&gt;beforeRendering&lt;/a&gt;() + &lt;a href=&quot;qquickwindow#beforeRenderPassRecording&quot;&gt;beforeRenderPassRecording&lt;/a&gt;() or &lt;a href=&quot;qquickwindow#beforeRendering&quot;&gt;beforeRendering&lt;/a&gt;() + &lt;a href=&quot;qquickwindow#afterRenderPassRecording&quot;&gt;afterRenderPassRecording&lt;/a&gt;() that is typically used to achieve under- or overlaying of the custom rendering.</source>
          <target state="translated">RHI를 사용할 때 신호는 장면 그래프가 명령 버퍼에 명령을 추가 한 후 방출되며 아직 그래픽 대기열에 제출되지 않습니다. 원하는 경우이 신호에 연결된 슬롯 함수는 &lt;a href=&quot;qsgrendererinterface&quot;&gt;QSGRendererInterface&lt;/a&gt; 를 통해 전에 명령 버퍼와 같은 네이티브 리소스를 쿼리 할 수 ​​있습니다 . 그러나 렌더 패스 (또는 패스)는이 시점에서 이미 기록되었으며 장면 그래프의 패스 내에 더 많은 명령을 추가 할 수 없습니다. 대신 &lt;a href=&quot;qquickwindow#afterRenderPassRecording&quot;&gt;afterRenderPassRecording&lt;/a&gt; ()을 사용 하십시오 . 따라서이 신호는 제한적으로 사용되며 RHI 기반 설정에서는 거의 필요하지 않습니다. 오히려 &lt;a href=&quot;qquickwindow#beforeRendering&quot;&gt;beforeRendering&lt;/a&gt; () + &lt;a href=&quot;qquickwindow#beforeRenderPassRecording&quot;&gt;beforeRenderPassRecording&lt;/a&gt; () 또는 &lt;a href=&quot;qquickwindow#beforeRendering&quot;&gt;beforeRendering&lt;/a&gt; () + 의 조합입니다.&lt;a href=&quot;qquickwindow#afterRenderPassRecording&quot;&gt;afterRenderPassRecording&lt;/a&gt; ()은 일반적으로 커스텀 렌더링의 언더 또는 오버레이를 달성하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="25e692c03b3d10cf511b4d19105847b9627e4f18" translate="yes" xml:space="preserve">
          <source>When using the RHI, the signal is emitted after the preparations for the frame have been done, meaning there is a command buffer in recording mode, where applicable. If desired, the slot function connected to this signal can query native resources like the command before via &lt;a href=&quot;qsgrendererinterface&quot;&gt;QSGRendererInterface&lt;/a&gt;. Note however that the recording of the main render pass is not yet started at this point and it is not possible to add commands within that pass. Starting a pass means clearing the color, depth, and stencil buffers so it is not possible to achieve an underlay type of rendering by just connecting to this signal. Rather, connect to &lt;a href=&quot;qquickwindow#beforeRenderPassRecording&quot;&gt;beforeRenderPassRecording&lt;/a&gt;(). However, connecting to this signal is still important if the recording of copy type of commands is desired since those cannot be enqueued within a render pass.</source>
          <target state="translated">RHI를 사용하는 경우 프레임 준비가 완료된 후 신호가 방출됩니다. 이는 해당되는 경우 레코딩 모드에 명령 버퍼가 있음을 의미합니다. 원하는 경우이 신호에 연결된 슬롯 함수는 &lt;a href=&quot;qsgrendererinterface&quot;&gt;QSGRendererInterface&lt;/a&gt; 를 통해 이전 명령과 같은 네이티브 리소스를 쿼리 할 수 ​​있습니다 . 그러나 메인 렌더 패스의 기록은 아직이 시점에서 시작되지 않았으며 해당 패스 내에 명령을 추가 할 수 없습니다. 패스를 시작한다는 것은 색상, 깊이 및 스텐실 버퍼를 지우는 것을 의미하므로이 신호에 연결하는 것만으로는 언더 레이 유형의 렌더링을 얻을 수 없습니다. 오히려 &lt;a href=&quot;qquickwindow#beforeRenderPassRecording&quot;&gt;beforeRenderPassRecording에&lt;/a&gt; 연결하십시오.(). 그러나 렌더 패스 내에서 대기열에 넣을 수 없기 때문에 명령의 복사 유형을 기록하려는 경우이 신호에 연결하는 것이 여전히 중요합니다.</target>
        </trans-unit>
        <trans-unit id="c520b2944e06b29e0ffe182f18017f3df7a8cce9" translate="yes" xml:space="preserve">
          <source>When using the SAP HANA database, the connection has to be established using the option &quot;SCROLLABLERESULT=TRUE&quot;, as the HANA ODBC driver does not provide scrollable results by default, e.g.:</source>
          <target state="translated">SAP HANA 데이터베이스를 사용하는 경우 HANA ODBC 드라이버는 기본적으로 스크롤 가능한 결과를 제공하지 않으므로 &quot;SCROLLABLERESULT = TRUE&quot;옵션을 사용하여 연결을 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="f6512b3be0d117dfa21e663e8a3f57fcd47481b4" translate="yes" xml:space="preserve">
          <source>When using the attached property &lt;a href=&quot;qml-qtquick-layoutmirroring#enabled-prop&quot;&gt;LayoutMirroring::enabled&lt;/a&gt; for locale layouts, the visual layout direction of the grid positioner will be mirrored. However, the property &lt;a href=&quot;qml-qtquick-flow#layoutDirection-prop&quot;&gt;layoutDirection&lt;/a&gt; will remain unchanged.</source>
          <target state="translated">로케일 레이아웃에 첨부 된 &lt;a href=&quot;qml-qtquick-layoutmirroring#enabled-prop&quot;&gt;LayoutMirroring :: enabled&lt;/a&gt; 특성을 사용하면 그리드 포지셔너의 시각적 레이아웃 방향이 미러링됩니다. 그러나 &lt;a href=&quot;qml-qtquick-flow#layoutDirection-prop&quot;&gt;layoutDirection&lt;/a&gt; 속성 은 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ad819fcb35bbe53948b4887616213f681fcff7f9" translate="yes" xml:space="preserve">
          <source>When using the attached property &lt;a href=&quot;qml-qtquick-layoutmirroring#enabled-prop&quot;&gt;LayoutMirroring::enabled&lt;/a&gt; for locale layouts, the visual layout direction of the grid positioner will be mirrored. However, the property &lt;a href=&quot;qml-qtquick-grid#layoutDirection-prop&quot;&gt;layoutDirection&lt;/a&gt; will remain unchanged.</source>
          <target state="translated">로케일 레이아웃에 첨부 된 &lt;a href=&quot;qml-qtquick-layoutmirroring#enabled-prop&quot;&gt;LayoutMirroring :: enabled&lt;/a&gt; 특성을 사용하면 그리드 포지셔너의 시각적 레이아웃 방향이 미러링됩니다. 그러나 &lt;a href=&quot;qml-qtquick-grid#layoutDirection-prop&quot;&gt;layoutDirection&lt;/a&gt; 속성 은 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f834cbf23f423046bd6a4e706aba1ff65a30a170" translate="yes" xml:space="preserve">
          <source>When using the attached property &lt;a href=&quot;qml-qtquick-layoutmirroring#enabled-prop&quot;&gt;LayoutMirroring::enabled&lt;/a&gt; for locale layouts, the visual layout direction of the grid will be mirrored. However, the property &lt;a href=&quot;qml-qtquick-gridview#layoutDirection-prop&quot;&gt;layoutDirection&lt;/a&gt; will remain unchanged.</source>
          <target state="translated">로케일 레이아웃에 첨부 된 &lt;a href=&quot;qml-qtquick-layoutmirroring#enabled-prop&quot;&gt;LayoutMirroring :: enabled&lt;/a&gt; 특성을 사용 하면 그리드의 시각적 레이아웃 방향이 미러링됩니다. 그러나 &lt;a href=&quot;qml-qtquick-gridview#layoutDirection-prop&quot;&gt;layoutDirection&lt;/a&gt; 속성 은 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f36c0ab165b9200f9ec8aa1357d728964f40f2cc" translate="yes" xml:space="preserve">
          <source>When using the attached property &lt;a href=&quot;qml-qtquick-layoutmirroring#enabled-prop&quot;&gt;LayoutMirroring::enabled&lt;/a&gt; for locale layouts, the visual layout direction of the horizontal list will be mirrored. However, the property &lt;a href=&quot;qml-qtquick-listview#layoutDirection-prop&quot;&gt;layoutDirection&lt;/a&gt; will remain unchanged.</source>
          <target state="translated">로캘 레이아웃에 연결된 속성 &lt;a href=&quot;qml-qtquick-layoutmirroring#enabled-prop&quot;&gt;LayoutMirroring :: enabled&lt;/a&gt; 를 사용 하면 가로 목록의 시각적 레이아웃 방향이 미러링됩니다. 그러나 &lt;a href=&quot;qml-qtquick-listview#layoutDirection-prop&quot;&gt;layoutDirection&lt;/a&gt; 속성 은 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fb66c1b45ac982beb02c022093529fd3f56e9448" translate="yes" xml:space="preserve">
          <source>When using the attached property &lt;a href=&quot;qml-qtquick-layoutmirroring#enabled-prop&quot;&gt;LayoutMirroring::enabled&lt;/a&gt; for locale layouts, the visual layout direction of the row positioner will be mirrored. However, the property &lt;a href=&quot;qml-qtquick-row#layoutDirection-prop&quot;&gt;layoutDirection&lt;/a&gt; will remain unchanged.</source>
          <target state="translated">로케일 레이아웃에 연결된 속성 &lt;a href=&quot;qml-qtquick-layoutmirroring#enabled-prop&quot;&gt;LayoutMirroring :: enabled&lt;/a&gt; 를 사용 하면 행 포지셔너의 시각적 레이아웃 방향이 미러링됩니다. 그러나 &lt;a href=&quot;qml-qtquick-row#layoutDirection-prop&quot;&gt;layoutDirection&lt;/a&gt; 속성 은 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="69d87d4ee077dc734724b86f9fa8e15d248506e7" translate="yes" xml:space="preserve">
          <source>When using the attached property &lt;a href=&quot;qml-qtquick-layoutmirroring#enabled-prop&quot;&gt;LayoutMirroring::enabled&lt;/a&gt; to mirror application layouts, the horizontal alignment of text will also be mirrored. However, the property &lt;code&gt;horizontalAlignment&lt;/code&gt; will remain unchanged. To query the effective horizontal alignment of &lt;a href=&quot;qml-qtquick-controls-textarea&quot;&gt;TextArea&lt;/a&gt;, use the read-only property &lt;code&gt;effectiveHorizontalAlignment&lt;/code&gt;.</source>
          <target state="translated">첨부 된 속성 &lt;a href=&quot;qml-qtquick-layoutmirroring#enabled-prop&quot;&gt;LayoutMirroring :: enabled&lt;/a&gt; 를 사용 하여 응용 프로그램 레이아웃을 미러링하면 텍스트의 가로 정렬도 미러링됩니다. 그러나 &lt;code&gt;horizontalAlignment&lt;/code&gt; 속성 은 변경되지 않습니다. &lt;a href=&quot;qml-qtquick-controls-textarea&quot;&gt;TextArea&lt;/a&gt; 의 효과적인 가로 정렬을 쿼리하려면 읽기 전용 속성 인 &lt;code&gt;effectiveHorizontalAlignment&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="d651e972a8b73ac33b7c1d33d8d380ac2eceec38" translate="yes" xml:space="preserve">
          <source>When using the attached property &lt;a href=&quot;qml-qtquick-layoutmirroring#enabled-prop&quot;&gt;LayoutMirroring::enabled&lt;/a&gt; to mirror application layouts, the horizontal alignment of text will also be mirrored. However, the property &lt;code&gt;horizontalAlignment&lt;/code&gt; will remain unchanged. To query the effective horizontal alignment of &lt;a href=&quot;qml-qtquick-textedit&quot;&gt;TextEdit&lt;/a&gt;, use the read-only property &lt;code&gt;effectiveHorizontalAlignment&lt;/code&gt;.</source>
          <target state="translated">첨부 된 속성 &lt;a href=&quot;qml-qtquick-layoutmirroring#enabled-prop&quot;&gt;LayoutMirroring :: enabled&lt;/a&gt; 를 사용 하여 응용 프로그램 레이아웃을 미러링하면 텍스트의 가로 정렬도 미러링됩니다. 그러나 &lt;code&gt;horizontalAlignment&lt;/code&gt; 속성 은 변경되지 않습니다. &lt;a href=&quot;qml-qtquick-textedit&quot;&gt;TextEdit&lt;/a&gt; 의 효과적인 가로 정렬을 쿼리하려면 읽기 전용 속성 인 &lt;code&gt;effectiveHorizontalAlignment&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="35d324bfc12c5d6ba6efc643a3b1dde7d26fce03" translate="yes" xml:space="preserve">
          <source>When using the attached property &lt;a href=&quot;qml-qtquick-layoutmirroring#enabled-prop&quot;&gt;LayoutMirroring::enabled&lt;/a&gt; to mirror application layouts, the horizontal alignment of text will also be mirrored. However, the property &lt;code&gt;horizontalAlignment&lt;/code&gt; will remain unchanged. To query the effective horizontal alignment of &lt;a href=&quot;qml-qtquick-textinput&quot;&gt;TextInput&lt;/a&gt;, use the read-only property &lt;code&gt;effectiveHorizontalAlignment&lt;/code&gt;.</source>
          <target state="translated">첨부 된 속성 &lt;a href=&quot;qml-qtquick-layoutmirroring#enabled-prop&quot;&gt;LayoutMirroring :: enabled&lt;/a&gt; 를 사용 하여 응용 프로그램 레이아웃을 미러링하면 텍스트의 가로 정렬도 미러링됩니다. 그러나 &lt;code&gt;horizontalAlignment&lt;/code&gt; 속성 은 변경되지 않습니다. &lt;a href=&quot;qml-qtquick-textinput&quot;&gt;TextInput&lt;/a&gt; 의 효과적인 가로 정렬을 쿼리하려면 읽기 전용 속성 인 &lt;code&gt;effectiveHorizontalAlignment&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="d2b5e6a5d5f5d78d3c5d95616a1f194fccea4c23" translate="yes" xml:space="preserve">
          <source>When using the attached property &lt;a href=&quot;qml-qtquick-layoutmirroring#enabled-prop&quot;&gt;LayoutMirroring::enabled&lt;/a&gt; to mirror application layouts, the horizontal alignment of text will also be mirrored. However, the property &lt;code&gt;horizontalAlignment&lt;/code&gt; will remain unchanged. To query the effective horizontal alignment of Text, use the read-only property &lt;code&gt;effectiveHorizontalAlignment&lt;/code&gt;.</source>
          <target state="translated">첨부 된 속성 &lt;a href=&quot;qml-qtquick-layoutmirroring#enabled-prop&quot;&gt;LayoutMirroring :: enabled&lt;/a&gt; 를 사용 하여 응용 프로그램 레이아웃을 미러링하면 텍스트의 가로 정렬도 미러링됩니다. 그러나 &lt;code&gt;horizontalAlignment&lt;/code&gt; 속성 은 변경되지 않습니다. Text의 효과적인 가로 정렬을 쿼리하려면 읽기 전용 속성 인 &lt;code&gt;effectiveHorizontalAlignment&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="20616dd35d75d11331c9fc082c83b9be05505dab" translate="yes" xml:space="preserve">
          <source>When using the attached property, &lt;a href=&quot;qml-qtquick-layoutmirroring#enabled-prop&quot;&gt;LayoutMirroring::enabled&lt;/a&gt;, to mirror application layouts, the horizontal alignment of text will also be mirrored. However, the property &lt;code&gt;horizontalAlignment&lt;/code&gt; will remain unchanged. To query the effective horizontal alignment of &lt;a href=&quot;qml-qtquick-controls-textfield&quot;&gt;TextField&lt;/a&gt;, use the read-only property &lt;code&gt;effectiveHorizontalAlignment&lt;/code&gt;.</source>
          <target state="translated">응용 프로그램 레이아웃을 미러링하기 위해 연결된 속성 인 &lt;a href=&quot;qml-qtquick-layoutmirroring#enabled-prop&quot;&gt;LayoutMirroring :: enabled를 사용&lt;/a&gt; 하면 텍스트의 가로 정렬도 미러링됩니다. 그러나 &lt;code&gt;horizontalAlignment&lt;/code&gt; 속성 은 변경되지 않습니다. &lt;a href=&quot;qml-qtquick-controls-textfield&quot;&gt;TextField&lt;/a&gt; 의 효과적인 가로 정렬을 쿼리하려면 읽기 전용 속성 인 &lt;code&gt;effectiveHorizontalAlignment&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="9a3979e0f25e3b5cc70f71695bbc56f938aca359" translate="yes" xml:space="preserve">
          <source>When using the default OpenGL adaptation, it is possible to integrate OpenGL calls directly into the &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt; using the same OpenGL context as the Qt Quick Scene Graph. This is done by connecting to the &lt;a href=&quot;qquickwindow#beforeRendering&quot;&gt;QQuickWindow::beforeRendering&lt;/a&gt;() or &lt;a href=&quot;qquickwindow#afterRendering&quot;&gt;QQuickWindow::afterRendering&lt;/a&gt;() signal.</source>
          <target state="translated">기본 OpenGL 적응을 사용하는 경우 Qt 빠른 장면 그래프와 동일한 OpenGL 컨텍스트를 사용하여 OpenGL 호출을 &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow에&lt;/a&gt; 직접 통합 할 수 있습니다 . 이는 &lt;a href=&quot;qquickwindow#beforeRendering&quot;&gt;QQuickWindow :: beforeRendering&lt;/a&gt; () 또는 &lt;a href=&quot;qquickwindow#afterRendering&quot;&gt;QQuickWindow :: afterRendering&lt;/a&gt; () 신호 에 연결하여 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="97faf04114fa9f9416c91f1c23b496eb6915deef" translate="yes" xml:space="preserve">
          <source>When using the default OpenGL adaptation, it is possible to integrate OpenGL calls directly into the QQuickWindow using the same OpenGL context as the Qt Quick Scene Graph. This is done by connecting to the &lt;a href=&quot;qquickwindow#beforeRendering&quot;&gt;QQuickWindow::beforeRendering&lt;/a&gt;() or &lt;a href=&quot;qquickwindow#afterRendering&quot;&gt;QQuickWindow::afterRendering&lt;/a&gt;() signal.</source>
          <target state="translated">기본 OpenGL 적응을 사용하면 Qt Quick Scene Graph와 동일한 OpenGL 컨텍스트를 사용하여 OpenGL 호출을 QQuickWindow에 직접 통합 할 수 있습니다. 이는 &lt;a href=&quot;qquickwindow#beforeRendering&quot;&gt;QQuickWindow :: beforeRendering&lt;/a&gt; () 또는 &lt;a href=&quot;qquickwindow#afterRendering&quot;&gt;QQuickWindow :: afterRendering&lt;/a&gt; () 신호 에 연결하여 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="34f1d72237c8018c967d74b627ccc1dfb27d0ed2" translate="yes" xml:space="preserve">
          <source>When using the provided matrices, the coordinate system for vertex data follows the usual &lt;a href=&quot;qquickitem&quot;&gt;QQuickItem&lt;/a&gt; conventions: top-left is (0, 0), bottom-right is the corresponding &lt;a href=&quot;qquickitem&quot;&gt;QQuickItem&lt;/a&gt;'s width() and height() minus one. For example, assuming a two float (x-y) per vertex coordinate layout, a triangle covering half of the item can be specified as (width - 1, height - 1), (0, 0), (0, height - 1) using counter-clockwise direction.</source>
          <target state="translated">제공된 행렬을 사용할 때 정점 데이터의 좌표계는 일반적인 &lt;a href=&quot;qquickitem&quot;&gt;QQuickItem&lt;/a&gt; 규칙을 따릅니다. 왼쪽 위는 (0, 0), 오른쪽 아래는 해당 &lt;a href=&quot;qquickitem&quot;&gt;QQuickItem&lt;/a&gt; 의 너비 () 및 높이 ()에서 1을 뺀 것입니다. 예를 들어 정점 좌표 레이아웃 당 두 개의 부동 (xy)을 가정하면 항목의 절반을 덮는 삼각형을 (너비-1, 높이-1), (0, 0), (0, 높이-1)로 지정할 수 있습니다. 시계 반대 방향.</target>
        </trans-unit>
        <trans-unit id="68b907ff756cd93a73b7aa07652187badb219c5e" translate="yes" xml:space="preserve">
          <source>When using the resulting HBITMAP as application icon or a systray icon, the image should have the format &lt;a href=&quot;qimage#Format-enum&quot;&gt;QImage::Format_ARGB32&lt;/a&gt;.</source>
          <target state="translated">결과 HBITMAP을 응용 프로그램 아이콘 또는 시스템 트레이 아이콘으로 사용하는 경우 이미지는 &lt;a href=&quot;qimage#Format-enum&quot;&gt;QImage :: Format_ARGB32&lt;/a&gt; 형식 이어야 합니다.</target>
        </trans-unit>
        <trans-unit id="8ceb131bc2281e76736822d7b82ae8a5fdb44998" translate="yes" xml:space="preserve">
          <source>When using the resulting HBITMAP for the &lt;code&gt;AlphaBlend()&lt;/code&gt; GDI function, the image should have the format &lt;a href=&quot;qimage#Format-enum&quot;&gt;QImage::Format_ARGB32_Premultiplied&lt;/a&gt; (use &lt;a href=&quot;qimage#convertToFormat&quot;&gt;convertToFormat&lt;/a&gt;()).</source>
          <target state="translated">&lt;code&gt;AlphaBlend()&lt;/code&gt; GDI 함수에 결과 HBITMAP을 사용하는 경우 이미지의 형식은 &lt;a href=&quot;qimage#Format-enum&quot;&gt;QImage :: Format_ARGB32_Premultiplied 여야합니다&lt;/a&gt; ( &lt;a href=&quot;qimage#convertToFormat&quot;&gt;convertToFormat&lt;/a&gt; () 사용).</target>
        </trans-unit>
        <trans-unit id="a0b66cc2a5a4e3c2e1a7db60e140c73cb4965b48" translate="yes" xml:space="preserve">
          <source>When using the same &lt;code&gt;.so&lt;/code&gt; lib file, your application's &lt;code&gt;main()&lt;/code&gt; function is executed two times, one to start the main activity and the second time to start the service. Thus, you have to handle each execution according to the provided argument. One way to acheive that is as follows:</source>
          <target state="translated">동일한 &lt;code&gt;.so&lt;/code&gt; lib 파일을 사용하는 경우 애플리케이션의 &lt;code&gt;main()&lt;/code&gt; 함수가 두 번 실행됩니다. 하나는 기본 활동을 시작하고 두 번째는 서비스를 시작하는 것입니다. 따라서 제공된 인수에 따라 각 실행을 처리해야합니다. 이를 달성하는 한 가지 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9ab3c5753ca173c3d3ab6370d02e203aa5f107b9" translate="yes" xml:space="preserve">
          <source>When using the vcapp template this will put all the source files into the source group and the header files into the header group regardless of what directory they reside in. Turning this option off will group the files within the source/header group depending on the directory they reside. This is turned on by default.</source>
          <target state="translated">vcapp 템플릿을 사용할 때 모든 소스 파일을 소스 그룹에 넣고 헤더 파일을 헤더 그룹에 넣습니다.이 옵션을 끄면 디렉토리에 따라 소스 / 헤더 그룹 내의 파일이 그룹화됩니다. 그들은 거주한다. 이것은 기본적으로 켜져 있습니다.</target>
        </trans-unit>
        <trans-unit id="885cb4ce8dcd663d12b984998a03134539d02bc3" translate="yes" xml:space="preserve">
          <source>When using these functions be aware that they return data in &lt;b&gt;column-major&lt;/b&gt; format:</source>
          <target state="translated">이 함수를 사용할 때는 데이터를 &lt;b&gt;열 주요&lt;/b&gt; 형식으로 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="5f1afdca4aa38b214b00a782de3c5aa53f22b470" translate="yes" xml:space="preserve">
          <source>When using this class, be aware of the following platform differences:</source>
          <target state="translated">이 클래스를 사용할 때는 다음과 같은 플랫폼 차이점을 알고 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="0eb1d67852478a07e0591b585644fc15d3d64036" translate="yes" xml:space="preserve">
          <source>When using this function, one should not call &lt;code&gt;accept()&lt;/code&gt;.</source>
          <target state="translated">이 함수를 사용할 때 &lt;code&gt;accept()&lt;/code&gt; 호출하면 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="a04c05a9070969e9eb67d44a8928461707a0a965" translate="yes" xml:space="preserve">
          <source>When using this method, Qt WebEngine assumes that external resources, such as JavaScript programs or style sheets, are encoded in UTF-8 unless otherwise specified. For example, the encoding of an external script can be specified through the &lt;code&gt;charset&lt;/code&gt; attribute of the HTML script tag. Alternatively, the encoding can be specified by the web server.</source>
          <target state="translated">이 방법을 사용할 때 Qt WebEngine은 달리 지정되지 않는 한 JavaScript 프로그램 또는 스타일 시트와 같은 외부 자원이 UTF-8로 인코딩 된 것으로 가정합니다. 예를 들어 HTML 스크립트 태그 의 &lt;code&gt;charset&lt;/code&gt; 속성을 통해 외부 스크립트의 인코딩을 지정할 수 있습니다 . 또는 웹 서버에서 인코딩을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fdf1b54e645c47e0218c40636ac9436b5bcd1515" translate="yes" xml:space="preserve">
          <source>When using this method, the web engine assumes that external resources, such as JavaScript programs or style sheets, are encoded in UTF-8 unless otherwise specified. For example, the encoding of an external script can be specified through the charset attribute of the HTML script tag. It is also possible for the encoding to be specified by the web server.</source>
          <target state="translated">이 방법을 사용할 때 웹 엔진은 달리 지정되지 않는 한 JavaScript 프로그램 또는 스타일 시트와 같은 외부 자원이 UTF-8로 인코딩 된 것으로 가정합니다. 예를 들어 HTML 스크립트 태그의 charset 속성을 통해 외부 스크립트의 인코딩을 지정할 수 있습니다. 웹 서버에서 인코딩을 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a2a1ceb612d654821cdebdcfcb18990c549b921" translate="yes" xml:space="preserve">
          <source>When using this plugin, the &lt;a href=&quot;qml-qtlocation-routemaneuver&quot;&gt;RouteManeuver&lt;/a&gt; objects in the returned route may contain additional extended attributes (see &lt;a href=&quot;qml-qtlocation-routemaneuver#extendedAttributes-prop&quot;&gt;RouteManeuver::extendedAttributes&lt;/a&gt;), where available. These attributes are described in detail in the official &lt;a href=&quot;https://www.mapbox.com/api-documentation/#stepmaneuver-object&quot;&gt;Mapbox direction API documentation&lt;/a&gt;.</source>
          <target state="translated">이 플러그인을 사용할 때 반환 된 경로 의 &lt;a href=&quot;qml-qtlocation-routemaneuver&quot;&gt;RouteManeuver&lt;/a&gt; 객체는 사용 가능한 경우 추가 확장 속성을 포함 할 수 있습니다 ( &lt;a href=&quot;qml-qtlocation-routemaneuver#extendedAttributes-prop&quot;&gt;RouteManeuver :: extendedAttributes&lt;/a&gt; 참조 ). 이러한 속성은 공식 &lt;a href=&quot;https://www.mapbox.com/api-documentation/#stepmaneuver-object&quot;&gt;Mapbox 방향 API 설명서&lt;/a&gt; 에 자세히 설명되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9f4d4482c71183bdaf1a8256f7c7d2b382d163cc" translate="yes" xml:space="preserve">
          <source>When using this template, the following qmake system variables are recognized. You should use these in your .pro file to specify information about your application. For additional platform-dependent system variables, you could have a look at the &lt;a href=&quot;qmake-platform-notes&quot;&gt;Platform Notes&lt;/a&gt;.</source>
          <target state="translated">이 템플릿을 사용하면 다음 qmake 시스템 변수가 인식됩니다. .pro 파일에서이를 사용하여 애플리케이션에 대한 정보를 지정해야합니다. 추가 플랫폼 종속 시스템 변수의 경우 &lt;a href=&quot;qmake-platform-notes&quot;&gt;Platform Notes를 참조&lt;/a&gt; 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8de68a2cf4346e4f75f69795025d7ee380ea618b" translate="yes" xml:space="preserve">
          <source>When using this template, the following qmake system variables are recognized. You should use these in your .pro file to specify information about your application. For additional platform-dependent system variables, you could have a look at the &lt;a href=&quot;qmake-platform-notes#&quot;&gt;Platform Notes&lt;/a&gt;.</source>
          <target state="translated">이 템플리트를 사용할 때 다음 qmake 시스템 변수가 인식됩니다. .pro 파일에서이를 사용하여 응용 프로그램에 대한 정보를 지정해야합니다. 추가적인 플랫폼 종속 시스템 변수에 대해서는 &lt;a href=&quot;qmake-platform-notes#&quot;&gt;플랫폼 참고 사항을&lt;/a&gt; 살펴볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cc8e8e68b8ce727bee069d21cdb1bf990c4178a5" translate="yes" xml:space="preserve">
          <source>When we communicate with the assistive technologies, we need to describe Qt's user interface in a way that they can understand. Qt applications use &lt;a href=&quot;qaccessibleinterface&quot;&gt;QAccessibleInterface&lt;/a&gt; to expose information about the individual UI elements. Currently, Qt provides support for its widgets and widget parts, e.g., slider handles, but the interface could also be implemented for any &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; if necessary. &lt;a href=&quot;qaccessible&quot;&gt;QAccessible&lt;/a&gt; contains enums that describe the UI. We will examine the enums in the course of this document.</source>
          <target state="translated">보조 기술과 통신 할 때 Qt의 사용자 인터페이스를 이해할 수있는 방식으로 설명해야합니다. Qt 애플리케이션은 &lt;a href=&quot;qaccessibleinterface&quot;&gt;QAccessibleInterface&lt;/a&gt; 를 사용 하여 개별 UI 요소에 대한 정보를 노출합니다. 현재 Qt는 위젯 및 위젯 파트 (예 : 슬라이더 핸들)를 지원하지만 필요한 경우 모든 &lt;a href=&quot;qobject&quot;&gt;QObject에&lt;/a&gt; 대해 인터페이스를 구현할 수도 있습니다 . &lt;a href=&quot;qaccessible&quot;&gt;QAccessible&lt;/a&gt; 에는 UI를 설명하는 열거 형이 포함되어 있습니다. 이 문서 과정에서 열거 형을 살펴볼 것입니다.</target>
        </trans-unit>
        <trans-unit id="870d36a92f2ae13647e01707539daa266e80b994" translate="yes" xml:space="preserve">
          <source>When we create a field using &lt;a href=&quot;qwizardpage#registerField&quot;&gt;QWizardPage::registerField&lt;/a&gt;(), we pass a unique field name and a widget. We can also provide a Qt property name and a &quot;changed&quot; signal (a signal that is emitted when the property changes) as third and fourth arguments; however, this is not necessary for the most common Qt widgets, such as &lt;a href=&quot;qlineedit&quot;&gt;QLineEdit&lt;/a&gt;, &lt;a href=&quot;qcheckbox&quot;&gt;QCheckBox&lt;/a&gt;, and &lt;a href=&quot;qcombobox&quot;&gt;QComboBox&lt;/a&gt;, because &lt;a href=&quot;qwizard&quot;&gt;QWizard&lt;/a&gt; knows which properties to look for.</source>
          <target state="translated">&lt;a href=&quot;qwizardpage#registerField&quot;&gt;QWizardPage :: registerField&lt;/a&gt; ()를 사용하여 필드를 만들면 고유 한 필드 이름과 위젯이 전달됩니다. 또한 Qt 속성 이름과 &quot;변경된&quot;신호 (속성이 변경 될 때 발생하는 신호)를 세 번째 및 네 번째 인수로 제공 할 수 있습니다. 그러나,이 같은 가장 일반적인 Qt는 위젯, 필요하지 않습니다 &lt;a href=&quot;qlineedit&quot;&gt;QLineEdit&lt;/a&gt; , &lt;a href=&quot;qcheckbox&quot;&gt;QCheckBox&lt;/a&gt; 및 &lt;a href=&quot;qcombobox&quot;&gt;QComboBox&lt;/a&gt; 때문에, &lt;a href=&quot;qwizard&quot;&gt;QWizard이&lt;/a&gt; 찾을 수있는 속성을 알고있다.</target>
        </trans-unit>
        <trans-unit id="0ef0b64bff35974267abf786dcf1eda874d19d4b" translate="yes" xml:space="preserve">
          <source>When we create a field using &lt;a href=&quot;qwizardpage#registerField&quot;&gt;QWizardPage::registerField&lt;/a&gt;(), we pass a unique field name and a widget. We can also provide a Qt property name and a &quot;changed&quot; signal (a signal that is emitted when the property changes) as third and fourth arguments; however, this is not necessary for the most common Qt widgets, such as &lt;a href=&quot;qlineedit&quot;&gt;QLineEdit&lt;/a&gt;, &lt;a href=&quot;qcheckbox&quot;&gt;QCheckBox&lt;/a&gt;, and &lt;a href=&quot;qcombobox&quot;&gt;QComboBox&lt;/a&gt;, because QWizard knows which properties to look for.</source>
          <target state="translated">&lt;a href=&quot;qwizardpage#registerField&quot;&gt;QWizardPage :: registerField&lt;/a&gt; ()를 사용하여 필드를 만들 때 고유 한 필드 이름과 위젯을 전달합니다. 또한 Qt 속성 이름과 &quot;변경된&quot;신호 (속성이 변경 될 때 발생하는 신호)를 세 번째 및 네 번째 인수로 제공 할 수 있습니다. 그러나,이 같은 가장 일반적인 Qt는 위젯, 필요하지 않습니다 &lt;a href=&quot;qlineedit&quot;&gt;QLineEdit&lt;/a&gt; , &lt;a href=&quot;qcheckbox&quot;&gt;QCheckBox&lt;/a&gt; 및 &lt;a href=&quot;qcombobox&quot;&gt;QComboBox&lt;/a&gt; QWizard가 볼 수있는 속성 알고 있기 때문에.</target>
        </trans-unit>
        <trans-unit id="785fad77e6226d72185e1f1510c20471fd564951" translate="yes" xml:space="preserve">
          <source>When we create a field using &lt;a href=&quot;qwizardpage#registerField&quot;&gt;QWizardPage::registerField&lt;/a&gt;(), we pass a unique field name and a widget. We can also provide a Qt property name and a &quot;changed&quot; signal (a signal that is emitted when the property changes) as third and fourth arguments; however, this is not necessary for the most common Qt widgets, such as &lt;a href=&quot;qlineedit&quot;&gt;QLineEdit&lt;/a&gt;, &lt;a href=&quot;qcheckbox&quot;&gt;QCheckBox&lt;/a&gt;, and &lt;a href=&quot;widgets-changes-qt6#qcombobox&quot;&gt;QComboBox&lt;/a&gt;, because QWizard knows which properties to look for.</source>
          <target state="translated">&lt;a href=&quot;qwizardpage#registerField&quot;&gt;QWizardPage :: registerField&lt;/a&gt; ()를 사용하여 필드를 만들 때 고유 한 필드 이름과 위젯을 전달합니다. 또한 Qt 속성 이름과 &quot;변경된&quot;신호 (속성이 변경 될 때 방출되는 신호)를 세 번째 및 네 번째 인수로 제공 할 수 있습니다. 그러나,이 같은 가장 일반적인 Qt는 위젯, 필요하지 않습니다 &lt;a href=&quot;qlineedit&quot;&gt;QLineEdit&lt;/a&gt; , &lt;a href=&quot;qcheckbox&quot;&gt;QCheckBox&lt;/a&gt; 및 &lt;a href=&quot;widgets-changes-qt6#qcombobox&quot;&gt;QComboBox&lt;/a&gt; QWizard가 볼 수있는 속성 알고 있기 때문에.</target>
        </trans-unit>
        <trans-unit id="d28a9032eec48f88438cdec09fd45cc48b6758eb" translate="yes" xml:space="preserve">
          <source>When we select those widgets and close the dialog the two widgets will now be available from the toolbox as grey squares with their name next to it</source>
          <target state="translated">해당 위젯을 선택하고 대화 상자를 닫으면 도구 상자에서 두 개의 위젯이 이름 옆에 회색 사각형으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="3fd645480f7c8c8a441a005df178284bbfe8bf76" translate="yes" xml:space="preserve">
          <source>When we specify a value for the length of an element in a text document, we often need to provide some other information so that the length is used in the way we expect. For example, when we specify a table width, the value can represent a fixed number of pixels, or it can be a percentage value. This information changes both the meaning of the value and the way it is used.</source>
          <target state="translated">텍스트 문서에서 요소의 길이 값을 지정할 때 종종 길이가 예상 한 방식으로 사용되도록 다른 정보를 제공해야합니다. 예를 들어, 테이블 너비를 지정할 때 값은 고정 된 수의 픽셀을 나타내거나 백분율 값일 수 있습니다. 이 정보는 값의 의미와 사용 방법을 모두 변경합니다.</target>
        </trans-unit>
        <trans-unit id="284899e0845013f5c711a6352c8742fd3ae424f1" translate="yes" xml:space="preserve">
          <source>When working with MIME data, Qt will interate through all instances of &lt;a href=&quot;qmacpasteboardmime&quot;&gt;QMacPasteboardMime&lt;/a&gt; to find an instance that can convert to, or from, a specific MIME type. It will do this by calling &lt;a href=&quot;qmacpasteboardmime#canConvert&quot;&gt;canConvert&lt;/a&gt;() on each instance, starting with (and choosing) the last created instance first. The actual conversions will be done by using &lt;a href=&quot;qmacpasteboardmime#convertToMime&quot;&gt;convertToMime&lt;/a&gt;() and &lt;a href=&quot;qmacpasteboardmime#convertFromMime&quot;&gt;convertFromMime&lt;/a&gt;().</source>
          <target state="translated">MIME 데이터로 작업 할 때 Qt는 &lt;a href=&quot;qmacpasteboardmime&quot;&gt;QMacPasteboardMime의&lt;/a&gt; 모든 인스턴스를 통해 특정 MIME 형식으로 변환하거나 특정 MIME 형식에서 변환 할 수있는 인스턴스를 찾습니다. 각 인스턴스에서 &lt;a href=&quot;qmacpasteboardmime#canConvert&quot;&gt;canConvert&lt;/a&gt; ()를 호출 하고 마지막으로 생성 된 인스턴스부터 시작하여 선택하여이를 수행합니다. 실제 변환은 &lt;a href=&quot;qmacpasteboardmime#convertToMime&quot;&gt;convertToMime&lt;/a&gt; () 및 &lt;a href=&quot;qmacpasteboardmime#convertFromMime&quot;&gt;convertFromMime&lt;/a&gt; () 을 사용하여 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="571daad4b1080b726a23421270240a628454d741" translate="yes" xml:space="preserve">
          <source>When working with MIME data, Qt will interate through all instances of QMacPasteboardMime to find an instance that can convert to, or from, a specific MIME type. It will do this by calling &lt;a href=&quot;qmacpasteboardmime#canConvert&quot;&gt;canConvert&lt;/a&gt;() on each instance, starting with (and choosing) the last created instance first. The actual conversions will be done by using &lt;a href=&quot;qmacpasteboardmime#convertToMime&quot;&gt;convertToMime&lt;/a&gt;() and &lt;a href=&quot;qmacpasteboardmime#convertFromMime&quot;&gt;convertFromMime&lt;/a&gt;().</source>
          <target state="translated">MIME 데이터로 작업 할 때 Qt는 QMacPasteboardMime의 모든 인스턴스를 통해 상호 작용하여 특정 MIME 유형으로 변환 할 수있는 인스턴스를 찾습니다. 각 인스턴스에서 &lt;a href=&quot;qmacpasteboardmime#canConvert&quot;&gt;canConvert&lt;/a&gt; ()를 호출 하여 마지막으로 생성 된 인스턴스부터 시작 (선택)하여이를 수행합니다. 실제 변환은 &lt;a href=&quot;qmacpasteboardmime#convertToMime&quot;&gt;convertToMime&lt;/a&gt; () 및 &lt;a href=&quot;qmacpasteboardmime#convertFromMime&quot;&gt;convertFromMime&lt;/a&gt; () 을 사용하여 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="4e8e4ed4ccd8ff19293050034a255b064f2a3965" translate="yes" xml:space="preserve">
          <source>When working with sRGB framebuffers, it will be necessary to specify a format like &lt;code&gt;GL_SRGB8_ALPHA8&lt;/code&gt;. This can be achieved by calling this function.</source>
          <target state="translated">sRGB 프레임 버퍼로 작업 할 때는 &lt;code&gt;GL_SRGB8_ALPHA8&lt;/code&gt; 과 같은 형식을 지정해야합니다 . 이 함수를 호출하면됩니다.</target>
        </trans-unit>
        <trans-unit id="b6293b5ac5127952d6ebfc84cb05237b6185107b" translate="yes" xml:space="preserve">
          <source>When writing GLSL 450 shader code to use with Qt 3D's RHI backend, the default uniforms will be provided as 2 uniform buffer objects.</source>
          <target state="translated">Qt 3D의 RHI 백엔드와 함께 사용할 GLSL 450 셰이더 코드를 작성할 때 기본 uniform은 2 개의 uniform buffer object로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="6f312a263e4af61bbd702f1cea50f4bdda448b76" translate="yes" xml:space="preserve">
          <source>When writing a &lt;a href=&quot;qwaylandcompositor&quot;&gt;QWaylandCompositor&lt;/a&gt; in Qt Quick, this class can be used to display a client's contents on an output device and will pass user input to the client.</source>
          <target state="translated">Qt Quick에서 &lt;a href=&quot;qwaylandcompositor&quot;&gt;QWaylandCompositor&lt;/a&gt; 를 작성할 때이 클래스는 클라이언트의 컨텐츠를 출력 장치에 표시하고 사용자 입력을 클라이언트에 전달하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="410b86178a5dfdcde1c78964c7d14183b1876a0b" translate="yes" xml:space="preserve">
          <source>When you &lt;a href=&quot;qbytearray#append&quot;&gt;append&lt;/a&gt;() data to a non-empty array, the array will be reallocated and the new data copied to it. You can avoid this behavior by calling &lt;a href=&quot;qbytearray#reserve&quot;&gt;reserve&lt;/a&gt;(), which preallocates a certain amount of memory. You can also call &lt;a href=&quot;qbytearray#capacity&quot;&gt;capacity&lt;/a&gt;() to find out how much memory &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; actually allocated. Data appended to an empty array is not copied.</source>
          <target state="translated">때 당신이 &lt;a href=&quot;qbytearray#append&quot;&gt;APPEND&lt;/a&gt; 비어 있지 않은 배열 () 데이터 배열은 재 할당 및 새로운 데이터가 복사됩니다. &lt;a href=&quot;qbytearray#reserve&quot;&gt;reserve&lt;/a&gt; () 를 호출 하여 특정 양의 메모리를 미리 할당 하여이 동작을 피할 수 있습니다 . &lt;a href=&quot;qbytearray&quot;&gt;QByteArray가&lt;/a&gt; 실제로 할당 한 메모리 양을 확인하기 위해 &lt;a href=&quot;qbytearray#capacity&quot;&gt;capacity&lt;/a&gt; ()를 호출 할 수도 있습니다 . 빈 배열에 추가 된 데이터는 복사되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="706fe5a63795456778db27342449bdf7cabe6ed0" translate="yes" xml:space="preserve">
          <source>When you &lt;a href=&quot;qbytearray#append&quot;&gt;append&lt;/a&gt;() data to a non-empty array, the array will be reallocated and the new data copied to it. You can avoid this behavior by calling &lt;a href=&quot;qbytearray#reserve&quot;&gt;reserve&lt;/a&gt;(), which preallocates a certain amount of memory. You can also call &lt;a href=&quot;qbytearray#capacity&quot;&gt;capacity&lt;/a&gt;() to find out how much memory QByteArray actually allocated. Data appended to an empty array is not copied.</source>
          <target state="translated">때 당신이 &lt;a href=&quot;qbytearray#append&quot;&gt;APPEND&lt;/a&gt; 비어 있지 않은 배열 () 데이터 배열은 재 할당 및 새로운 데이터가 복사됩니다. 특정 양의 메모리를 미리 할당하는 &lt;a href=&quot;qbytearray#reserve&quot;&gt;reserve&lt;/a&gt; () 를 호출하여이 동작을 피할 수 있습니다 . 또한 &lt;a href=&quot;qbytearray#capacity&quot;&gt;capacity&lt;/a&gt; ()를 호출 하여 QByteArray가 실제로 할당 된 메모리 양을 확인할 수 있습니다 . 빈 배열에 추가 된 데이터는 복사되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e206e4859b01e1c09bb56347d89a744afe0086be" translate="yes" xml:space="preserve">
          <source>When you &lt;a href=&quot;qwidget#hide&quot;&gt;hide&lt;/a&gt;() a child, its space will be distributed among the other children. It will be reinstated when you &lt;a href=&quot;qwidget#show&quot;&gt;show&lt;/a&gt;() it again.</source>
          <target state="translated">아이 를 &lt;a href=&quot;qwidget#hide&quot;&gt;숨기면&lt;/a&gt; (), 다른 아이에게 공간이 분배됩니다. 다시 () &lt;a href=&quot;qwidget#show&quot;&gt;표시&lt;/a&gt; 하면 복원됩니다 .</target>
        </trans-unit>
        <trans-unit id="2ae32a06b61e1a7246efea4bce7751cf08c416ce" translate="yes" xml:space="preserve">
          <source>When you add widgets to a layout, the layout process works as follows:</source>
          <target state="translated">위젯을 레이아웃에 추가하면 레이아웃 프로세스는 다음과 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="90fb4ea82c0d848dd1c76043e760d581c3542117" translate="yes" xml:space="preserve">
          <source>When you are done, call &lt;a href=&quot;qinapptransaction#finalize&quot;&gt;QInAppTransaction::finalize&lt;/a&gt;(), regardless of its status. Transactions which are not finalized will be emitted again the next time your application calls &lt;a href=&quot;qinappstore#registerProduct&quot;&gt;registerProduct&lt;/a&gt;() for the same product.</source>
          <target state="translated">완료되면 상태에 관계없이 &lt;a href=&quot;qinapptransaction#finalize&quot;&gt;QInAppTransaction :: finalize&lt;/a&gt; ()를 호출 하십시오 . 완료되지 않은 트랜잭션은 다음에 응용 프로그램 이 동일한 제품에 대해 &lt;a href=&quot;qinappstore#registerProduct&quot;&gt;registerProduct&lt;/a&gt; ()를 호출 할 때 다시 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="ca9c1c1922961985d5b3578d590ea428455c5e94" translate="yes" xml:space="preserve">
          <source>When you assign a &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; sub-class to this property, the QML engine does the interface cast to &lt;code&gt;FooInterface*&lt;/code&gt; automatically.</source>
          <target state="translated">당신이 할당 할 때 &lt;a href=&quot;qobject&quot;&gt;QObject를의&lt;/a&gt; 이 속성을 하위 클래스는 QML 엔진의 인터페이스 캐스트하지 &lt;code&gt;FooInterface*&lt;/code&gt; 자동으로.</target>
        </trans-unit>
        <trans-unit id="203801501ed91c63352794b08170d38e294688a8" translate="yes" xml:space="preserve">
          <source>When you assign a new font to a widget, the properties from this font are combined with the widget's default font to form the widget's final font. You can call &lt;a href=&quot;qwidget#fontInfo&quot;&gt;fontInfo&lt;/a&gt;() to get a copy of the widget's final font. The final font is also used to initialize &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt;'s font.</source>
          <target state="translated">새 글꼴을 위젯에 지정하면이 글꼴의 특성이 위젯의 ​​기본 글꼴과 결합되어 위젯의 최종 글꼴이됩니다. &lt;a href=&quot;qwidget#fontInfo&quot;&gt;fontInfo&lt;/a&gt; ()를 호출 하여 위젯의 최종 글꼴 사본을 얻을 수 있습니다 . 마지막 글꼴은 &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; 의 글꼴 을 초기화하는 데에도 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="af2046c186d7103eac993dbd56c9ad5be66e4723" translate="yes" xml:space="preserve">
          <source>When you assign a new palette to a widget, the color roles from this palette are combined with the widget's default palette to form the widget's final palette. The palette entry for the widget's background role is used to fill the widget's background (see &lt;a href=&quot;qwidget#autoFillBackground-prop&quot;&gt;QWidget::autoFillBackground&lt;/a&gt;), and the foreground role initializes &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt;'s pen.</source>
          <target state="translated">새 팔레트를 위젯에 지정하면이 팔레트의 색상 역할이 위젯의 ​​기본 팔레트와 결합되어 위젯의 최종 팔레트를 형성합니다. 위젯의 배경 역할에 대한 팔레트 항목은 위젯의 배경을 채우는 데 사용되며 ( &lt;a href=&quot;qwidget#autoFillBackground-prop&quot;&gt;QWidget :: autoFillBackground&lt;/a&gt; 참조 ) 전경 역할은 &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; 의 펜 을 초기화 합니다.</target>
        </trans-unit>
        <trans-unit id="9e46f6202b38da8549f0268e4a4fe0abf934e7f4" translate="yes" xml:space="preserve">
          <source>When you build Qt, frameworks are built by default, and inside the framework you will find both a release and a debug version (e.g., &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtcore-module.html&quot;&gt;QtCore&lt;/a&gt; and QtCore_debug). If you pass the &lt;code&gt;-no-framework&lt;/code&gt; flag when you build Qt, two dylibs are built for each Qt library (e.g., libQtCore.4.dylib and libQtCore_debug.4.dylib).</source>
          <target state="translated">Qt를 빌드 할 때 기본적으로 프레임 워크가 빌드되며 프레임 워크 안에 릴리스 및 디버그 버전 (예 : &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtcore-module.html&quot;&gt;QtCore&lt;/a&gt; 및 QtCore_debug)이 있습니다. Qt를 빌드 할 때 &lt;code&gt;-no-framework&lt;/code&gt; 플래그 를 전달하면 각 Qt 라이브러리마다 두 개의 dylib가 작성됩니다 (예 : libQtCore.4.dylib 및 libQtCore_debug.4.dylib).</target>
        </trans-unit>
        <trans-unit id="51ec8bb6c1e25445908ed2540d53f85248b08802" translate="yes" xml:space="preserve">
          <source>When you build Qt, frameworks are built by default, and inside the framework you will find both a release and a debug version (e.g., &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtcore-module.html&quot;&gt;QtCore&lt;/a&gt; and QtCore_debug). If you pass the &lt;code&gt;-no-framework&lt;/code&gt; flag when you build Qt, two dylibs are built for each Qt library (e.g., libQtCore.4.dylib and libQtCore_debug.4.dylib).</source>
          <target state="translated">Qt를 빌드 할 때 기본적으로 프레임 워크가 빌드되며 프레임 워크 내에서 릴리스 및 디버그 버전 (예 : &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtcore-module.html&quot;&gt;QtCore&lt;/a&gt; 및 QtCore_debug)을 모두 찾을 수 있습니다 . Qt를 빌드 할 때 &lt;code&gt;-no-framework&lt;/code&gt; 플래그 를 전달하면 각 Qt 라이브러리에 대해 2 개의 dylib가 빌드됩니다 (예 : libQtCore.4.dylib 및 libQtCore_debug.4.dylib).</target>
        </trans-unit>
        <trans-unit id="1bfad1fe70413b2afa2e96ceeb6fb1c3147a98cc" translate="yes" xml:space="preserve">
          <source>When you build Qt, frameworks are built by default, and inside the framework you will find both a release and a debug version (e.g., &lt;a href=&quot;https://doc.qt.io/qt-6.0/qtcore-module.html&quot;&gt;QtCore&lt;/a&gt; and QtCore_debug). If you pass the &lt;code&gt;-no-framework&lt;/code&gt; flag when you build Qt, two dylibs are built for each Qt library (e.g., libQtCore.4.dylib and libQtCore_debug.4.dylib).</source>
          <target state="translated">Qt를 빌드하면 프레임 워크가 기본적으로 빌드되며 프레임 워크 내에서 릴리스 및 디버그 버전 (예 : &lt;a href=&quot;https://doc.qt.io/qt-6.0/qtcore-module.html&quot;&gt;QtCore&lt;/a&gt; 및 QtCore_debug)을 모두 찾을 수 있습니다 . Qt를 빌드 할 때 &lt;code&gt;-no-framework&lt;/code&gt; 플래그 를 전달하면 각 Qt 라이브러리에 대해 두 개의 dylib가 빌드됩니다 (예 : libQtCore.4.dylib 및 libQtCore_debug.4.dylib).</target>
        </trans-unit>
        <trans-unit id="0a87e705d339a4e673804de6e41e480ac5d48e14" translate="yes" xml:space="preserve">
          <source>When you call &lt;a href=&quot;qmutex#lock&quot;&gt;lock&lt;/a&gt;() in a thread, other threads that try to call &lt;a href=&quot;qmutex#lock&quot;&gt;lock&lt;/a&gt;() in the same place will block until the thread that got the lock calls &lt;a href=&quot;qmutex#unlock&quot;&gt;unlock&lt;/a&gt;(). A non-blocking alternative to &lt;a href=&quot;qmutex#lock&quot;&gt;lock&lt;/a&gt;() is &lt;a href=&quot;qmutex#tryLock&quot;&gt;tryLock&lt;/a&gt;().</source>
          <target state="translated">당신이 호출 할 때 &lt;a href=&quot;qmutex#lock&quot;&gt;잠금을&lt;/a&gt; 스레드에서 ()를 호출하려고 다른 스레드 &lt;a href=&quot;qmutex#lock&quot;&gt;잠금 장치를&lt;/a&gt; 잠금을 얻은 스레드를 호출 할 때까지 같은 장소에서 (가) 차단 &lt;a href=&quot;qmutex#unlock&quot;&gt;해제를&lt;/a&gt; (). &lt;a href=&quot;qmutex#lock&quot;&gt;잠금&lt;/a&gt; ()에 대한 비 차단 대안 은 &lt;a href=&quot;qmutex#tryLock&quot;&gt;tryLock&lt;/a&gt; ()입니다.</target>
        </trans-unit>
        <trans-unit id="3895403974f0e093b1adb4983c512e48803fc7c3" translate="yes" xml:space="preserve">
          <source>When you call &lt;a href=&quot;qmutex#lock&quot;&gt;lock&lt;/a&gt;() in a thread, other threads that try to call &lt;a href=&quot;qmutex#lock&quot;&gt;lock&lt;/a&gt;() in the same place will block until the thread that got the lock calls &lt;a href=&quot;qmutex#unlock&quot;&gt;unlock&lt;/a&gt;(). A non-blocking alternative to &lt;a href=&quot;qmutex#lock&quot;&gt;lock&lt;/a&gt;() is &lt;a href=&quot;qmutex#tryLock-1&quot;&gt;tryLock&lt;/a&gt;().</source>
          <target state="translated">당신이 호출 할 때 &lt;a href=&quot;qmutex#lock&quot;&gt;잠금을&lt;/a&gt; 스레드에서 ()를 호출하려고 다른 스레드 &lt;a href=&quot;qmutex#lock&quot;&gt;잠금 장치를&lt;/a&gt; 잠금을 얻은 스레드를 호출 할 때까지 같은 장소에서 (가) 차단 &lt;a href=&quot;qmutex#unlock&quot;&gt;해제를&lt;/a&gt; (). &lt;a href=&quot;qmutex#lock&quot;&gt;잠금&lt;/a&gt; ()에 대한 비 차단 대안 은 &lt;a href=&quot;qmutex#tryLock-1&quot;&gt;tryLock&lt;/a&gt; ()입니다.</target>
        </trans-unit>
        <trans-unit id="6c51b78ef404aa9256758848a787e698738ccda1" translate="yes" xml:space="preserve">
          <source>When you click &lt;b&gt;OK&lt;/b&gt; or &lt;b&gt;Apply&lt;/b&gt;, Qt Designer will automatically display the widget with its new stylesheet.</source>
          <target state="translated">&lt;b&gt;확인&lt;/b&gt; 또는 &lt;b&gt;적용&lt;/b&gt; 을 클릭하면 Qt Designer가 자동으로 새 스타일 시트와 함께 위젯을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="a29f5adc1b71f2d82537e70f37ce91b1e7581ebe" translate="yes" xml:space="preserve">
          <source>When you click on the slider and drag it to a certain value, you want the spin box to display the slider's position. To accomplish this behavior, you need to connect the slider's &lt;a href=&quot;qabstractslider#valueChanged&quot;&gt;valueChanged()&lt;/a&gt; signal to the spin box's &lt;a href=&quot;qspinbox#value-prop&quot;&gt;setValue()&lt;/a&gt; slot. You also need to make the reverse connections, e.g., connect the spin box's &lt;a href=&quot;qspinbox#valueChanged&quot;&gt;valueChanged()&lt;/a&gt; signal to the slider's &lt;a href=&quot;qabstractslider#value-prop&quot;&gt;setValue()&lt;/a&gt; slot.</source>
          <target state="translated">슬라이더를 클릭하고 특정 값으로 드래그하면 스핀 상자에 슬라이더의 위치가 표시되기를 원합니다. 이 동작을 수행하려면 슬라이더의 &lt;a href=&quot;qabstractslider#valueChanged&quot;&gt;valueChanged ()&lt;/a&gt; 신호를 스핀 상자의 &lt;a href=&quot;qspinbox#value-prop&quot;&gt;setValue ()&lt;/a&gt; 슬롯 에 연결해야 합니다. 스핀 박스의 &lt;a href=&quot;qspinbox#valueChanged&quot;&gt;valueChanged ()&lt;/a&gt; 신호를 슬라이더의 &lt;a href=&quot;qabstractslider#value-prop&quot;&gt;setValue ()&lt;/a&gt; 슬롯에 연결하는 것과 같이 역방향 연결도해야 합니다.</target>
        </trans-unit>
        <trans-unit id="16d343fa86e79c1573178210409175ac2c2a9e85" translate="yes" xml:space="preserve">
          <source>When you compile your application, you must explicitly enable the debugging infrastructure. If you use qmake, you can add the configuration parameters to the project &lt;code&gt;.pro&lt;/code&gt; file:</source>
          <target state="translated">응용 프로그램을 컴파일 할 때 디버깅 인프라를 명시 적으로 활성화해야합니다. qmake를 사용하는 경우 구성 매개 변수를 프로젝트 &lt;code&gt;.pro&lt;/code&gt; 파일에 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2aceba6d77a63e6f2b3b7fb5d2e861200bdf01c2" translate="yes" xml:space="preserve">
          <source>When you create a &lt;a href=&quot;qfont&quot;&gt;QFont&lt;/a&gt; object you specify various attributes that you want the font to have. Qt will use the font with the specified attributes, or if no matching font exists, Qt will use the closest matching installed font. The attributes of the font that is actually used are retrievable from a &lt;a href=&quot;qfontinfo&quot;&gt;QFontInfo&lt;/a&gt; object. If the window system provides an exact match &lt;a href=&quot;qfont#exactMatch&quot;&gt;exactMatch&lt;/a&gt;() returns &lt;code&gt;true&lt;/code&gt;. Use &lt;a href=&quot;qfontmetricsf&quot;&gt;QFontMetricsF&lt;/a&gt; to get measurements, e.g. the pixel length of a string using QFontMetrics::width().</source>
          <target state="translated">&lt;a href=&quot;qfont&quot;&gt;QFont&lt;/a&gt; 객체 를 만들 때 글꼴에 원하는 다양한 속성을 지정합니다. Qt는 지정된 속성으로 글꼴을 사용하거나 일치하는 글꼴이 없으면 가장 가까운 일치하는 설치된 글꼴을 사용합니다. 실제로 사용되는 글꼴의 속성은 &lt;a href=&quot;qfontinfo&quot;&gt;QFontInfo&lt;/a&gt; 객체 에서 검색 할 수 있습니다 . 윈도우 시스템이 정확히 일치하는 경우 &lt;a href=&quot;qfont#exactMatch&quot;&gt;exactMatch&lt;/a&gt; ()가 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 . QFontMetrics :: width ()를 사용하여 문자열의 픽셀 길이와 같은 측정 값을 얻으려면 &lt;a href=&quot;qfontmetricsf&quot;&gt;QFontMetricsF&lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="c60c2a106febe9d8810b691e03aaff098d3cba22" translate="yes" xml:space="preserve">
          <source>When you create a QFont object you specify various attributes that you want the font to have. Qt will use the font with the specified attributes, or if no matching font exists, Qt will use the closest matching installed font. The attributes of the font that is actually used are retrievable from a &lt;a href=&quot;qfontinfo&quot;&gt;QFontInfo&lt;/a&gt; object. If the window system provides an exact match &lt;a href=&quot;qfont#exactMatch&quot;&gt;exactMatch&lt;/a&gt;() returns &lt;code&gt;true&lt;/code&gt;. Use &lt;a href=&quot;qfontmetricsf&quot;&gt;QFontMetricsF&lt;/a&gt; to get measurements, e.g. the pixel length of a string using QFontMetrics::width().</source>
          <target state="translated">QFont 개체를 만들 때 글꼴에 포함 할 다양한 속성을 지정합니다. Qt는 지정된 속성을 가진 글꼴을 사용하거나 일치하는 글꼴이없는 경우 Qt는 가장 가까운 일치하는 설치된 글꼴을 사용합니다. 실제로 사용되는 글꼴의 속성은 &lt;a href=&quot;qfontinfo&quot;&gt;QFontInfo&lt;/a&gt; 개체 에서 검색 할 수 있습니다 . 윈도우 시스템이 정확히 일치하는 것을 제공하면 &lt;a href=&quot;qfont#exactMatch&quot;&gt;exactMatch&lt;/a&gt; ()는 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 . 사용 &lt;a href=&quot;qfontmetricsf&quot;&gt;QFontMetricsF이&lt;/a&gt; QFontMetrics :: 폭을 사용하여 문자열의 픽셀 길이 예, 측정 값을 얻을 수 있습니다 ().</target>
        </trans-unit>
        <trans-unit id="28ec5a0e3b20169c458bbcc9cde4d66c22062727" translate="yes" xml:space="preserve">
          <source>When you create an instance of your &lt;a href=&quot;qsyntaxhighlighter&quot;&gt;QSyntaxHighlighter&lt;/a&gt; subclass, pass it the &lt;a href=&quot;qtextdocument&quot;&gt;QTextDocument&lt;/a&gt; that you want the syntax highlighting to be applied to. For example:</source>
          <target state="translated">&lt;a href=&quot;qsyntaxhighlighter&quot;&gt;QSyntaxHighlighter&lt;/a&gt; 서브 클래스 의 인스턴스를 작성할 때 구문 강조 표시를 적용 할 &lt;a href=&quot;qtextdocument&quot;&gt;QTextDocument&lt;/a&gt; 를 전달하십시오 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="acf4ae51281130900b153e1649564a2683553896" translate="yes" xml:space="preserve">
          <source>When you create an instance of your QSyntaxHighlighter subclass, pass it the &lt;a href=&quot;qtextdocument&quot;&gt;QTextDocument&lt;/a&gt; that you want the syntax highlighting to be applied to. For example:</source>
          <target state="translated">QSyntaxHighlighter 하위 클래스의 인스턴스를 만들 때 구문 강조를 적용 할 &lt;a href=&quot;qtextdocument&quot;&gt;QTextDocument&lt;/a&gt; 를 전달합니다 . 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="6ca044dcc761989ec3d45fb4cbef2b702bc2b544" translate="yes" xml:space="preserve">
          <source>When you create your own subwindow, you must set the &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt::WA_DeleteOnClose&lt;/a&gt; widget attribute if you want the window to be deleted when closed in the MDI area. If not, the window will be hidden and the MDI area will not activate the next subwindow.</source>
          <target state="translated">자체 &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;하위&lt;/a&gt; 창을 만들 때 MDI 영역에서 창을 닫을 때 창을 삭제 하려면 Qt :: WA_DeleteOnClose 위젯 속성을 설정해야합니다 . 그렇지 않으면 창이 숨겨지고 MDI 영역이 다음 하위 창을 활성화하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="de40a9dc45275aef4c5df5f40038b770fe409001" translate="yes" xml:space="preserve">
          <source>When you define your filter, note that it can be called from different threads; but never concurrently. This filter cannot call any static functions from &lt;a href=&quot;qloggingcategory&quot;&gt;QLoggingCategory&lt;/a&gt;.</source>
          <target state="translated">필터를 정의 할 때 다른 스레드에서 호출 할 수 있습니다. 하지만 동시에는 없습니다. 이 필터는 &lt;a href=&quot;qloggingcategory&quot;&gt;QLoggingCategory&lt;/a&gt; 에서 정적 함수를 호출 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="84840db2f97361935bdbfd339750fb2aacff31cf" translate="yes" xml:space="preserve">
          <source>When you develop a BSP for your board, you should include the following utilities to enable Qt Creator to deploy, run, debug, and stop applications on QNX devices:</source>
          <target state="translated">보드 용 BSP를 개발할 때 Qt Creator가 QNX 장치에서 응용 프로그램을 배포, 실행, 디버깅 및 중지 할 수 있도록 다음 유틸리티를 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="4c480aff5cf79a86ac02aed41c87410316570513" translate="yes" xml:space="preserve">
          <source>When you develop an application for an Apple platform, you must set the deployment target. Various build tools within the Xcode toolchain all have a flag which you can use to set this value, including but not limited to the compiler and linker. By setting the deployment target value, you are explicitly declaring that your application must work on at least that version, and will not work with any earlier versions of the OS. It is then up to you to ensure that your use of the system APIs matches what you have declared. Since the compiler knows what you have declared, it can help in enforcing that.</source>
          <target state="translated">Apple 플랫폼 용 응용 프로그램을 개발할 때는 배포 대상을 설정해야합니다. Xcode 툴체인 내의 다양한 빌드 도구에는 모두 컴파일러 및 링커를 포함하여이 값을 설정하는 데 사용할 수있는 플래그가 있습니다. 배포 대상 값을 설정하면 응용 프로그램이 최소한 해당 버전에서 작동해야하며 이전 버전의 OS에서는 작동하지 않음을 명시 적으로 선언합니다. 시스템 API 사용이 선언 한 것과 일치하는지 확인하는 것은 사용자의 책임입니다. 컴파일러는 선언 한 내용을 알고 있으므로이를 적용하는 데 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e624447ece8794817624f7b1b843a60aecc9b62" translate="yes" xml:space="preserve">
          <source>When you develop an application for an Apple platform, you should always use the latest version of Xcode and the latest SDK available at the time of development. On some platforms, like iOS, you will actually be rejected from the App Store if you do not. Therefore, the SDK version is always greater than or equal to the deployment target.</source>
          <target state="translated">Apple 플랫폼 용 응용 프로그램을 개발할 때는 항상 최신 Xcode 버전과 개발 당시 사용 가능한 최신 SDK를 사용해야합니다. iOS와 같은 일부 플랫폼에서는 그렇지 않은 경우 실제로 App Store에서 거부됩니다. 따라서 SDK 버전은 항상 배포 대상보다 크거나 같습니다.</target>
        </trans-unit>
        <trans-unit id="4c7b64797b21f9f607e1ffa6f6ab445278f5f0b8" translate="yes" xml:space="preserve">
          <source>When you develop an application with QML, there are many ways to debug possible issues that you may face. The sections below describe the debugging tools available and how to use them.</source>
          <target state="translated">QML을 사용하여 애플리케이션을 개발할 때 발생할 수있는 문제를 디버깅하는 방법에는 여러 가지가 있습니다. 아래 섹션에서는 사용 가능한 디버깅 도구 및 사용 방법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="665dc5dbb39005e2b8624150def3c9dc88cec3b1" translate="yes" xml:space="preserve">
          <source>When you develop custom widgets, you can create custom subclasses of &lt;a href=&quot;qaccessibleinterface&quot;&gt;QAccessibleInterface&lt;/a&gt; and distribute them as plugins (using &lt;a href=&quot;qaccessibleplugin&quot;&gt;QAccessiblePlugin&lt;/a&gt;) or compile them into the application. Likewise, Qt's predefined accessibility support can be built as plugin (the default) or directly into the Qt library. The main advantage of using plugins is that the accessibility classes are only loaded into memory if they are actually used; they don't slow down the common case where no assistive technology is being used.</source>
          <target state="translated">사용자 정의 위젯을 개발할 때 &lt;a href=&quot;qaccessibleinterface&quot;&gt;QAccessibleInterface의&lt;/a&gt; 사용자 정의 서브 클래스를 작성 하고이를 플러그인 ( &lt;a href=&quot;qaccessibleplugin&quot;&gt;QAccessiblePlugin&lt;/a&gt; 사용 ) 으로 분배 하거나 애플리케이션으로 컴파일 할 수 있습니다. 마찬가지로, Qt의 사전 정의 된 내게 필요한 옵션 지원은 플러그인 (기본값)으로 또는 Qt 라이브러리에 직접 빌드 할 수 있습니다. 플러그인 사용의 주요 장점은 접근성 클래스가 실제로 사용되는 경우에만 메모리에로드된다는 것입니다. 보조 기술이 사용되지 않는 일반적인 경우를 늦추지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bd0d4bcaee27591a27f5364969032d286331c9d5" translate="yes" xml:space="preserve">
          <source>When you distribute your application, remember to include</source>
          <target state="translated">응용 프로그램을 배포 할 때 다음을 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="8f9dd307dc92d46d630aa224d3859e9783a0c824" translate="yes" xml:space="preserve">
          <source>When you distribute your application, remember to include libpq.dll in your installation package. It must be placed in the same folder as the application executable.</source>
          <target state="translated">응용 프로그램을 배포 할 때 설치 패키지에 libpq.dll을 포함시켜야합니다. 응용 프로그램 실행 파일과 동일한 폴더에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="5ea8acaa7e79eefa675682ec7a314c688674b2bb" translate="yes" xml:space="preserve">
          <source>When you do a &lt;code&gt;make install&lt;/code&gt;, and you don't have a build of the project yet, the project is first built, and then installed. If you don't want this behavior, set this config value to ensure that the build target is not added as a dependency to the install target.</source>
          <target state="translated">&lt;code&gt;make install&lt;/code&gt; 을 수행 할 때 아직 프로젝트 빌드가 없으면 프로젝트가 먼저 빌드 된 다음 설치됩니다. 이 동작을 원하지 않으면 빌드 대상이 설치 대상에 대한 종속성으로 추가되지 않도록이 구성 값을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="f239ccd84b95fa1bd3731891bc9b99327baddf53" translate="yes" xml:space="preserve">
          <source>When you have a data set that updates rapidly, it is important to handle data properly to ensure good performance. Since memory allocation is a costly operation, always use &lt;a href=&quot;qlist#reserve&quot;&gt;QList::reserve&lt;/a&gt;() and &lt;a href=&quot;qvector#resize&quot;&gt;QVector::resize&lt;/a&gt;() where possible to avoid unnecessary reallocations when constructing the array to give to the proxy. If you need to change the entire data set for each frame, it is in most cases best to reuse the existing array - especially if the array dimensions do not change. If you need to add, insert, remove, or change several rows or items for each frame, it is always more efficient to do it with one method call instead of multiple calls affecting a single row or item each. For example, adding ten rows with a single &lt;a href=&quot;qbardataproxy#addRows&quot;&gt;QBarDataProxy::addRows&lt;/a&gt;() call is much more efficient than ten separate &lt;a href=&quot;qbardataproxy#addRow&quot;&gt;QBarDataProxy::addRow&lt;/a&gt;() calls.</source>
          <target state="translated">빠르게 업데이트되는 데이터 세트가있는 경우 데이터를 올바르게 처리하여 성능을 향상시키는 것이 중요합니다. 메모리 할당은 비용이 많이 드는 작업이므로 프록시에 제공 할 배열을 구성 할 때 불필요한 재 할당을 피하려면 가능한 경우 항상 &lt;a href=&quot;qlist#reserve&quot;&gt;QList :: reserve&lt;/a&gt; () 및 &lt;a href=&quot;qvector#resize&quot;&gt;QVector :: resize&lt;/a&gt; ()를 사용하십시오. 각 프레임에 대해 전체 데이터 세트를 변경해야하는 경우, 특히 배열 크기가 변경되지 않는 경우 기존 배열을 재사용하는 것이 가장 좋습니다. 각 프레임에 대해 여러 행이나 항목을 추가, 삽입, 제거 또는 변경해야하는 경우 단일 행이나 항목에 각각 영향을 미치는 여러 호출 대신 하나의 메소드 호출로 수행하는 것이 항상 더 효율적입니다. 예를 들어, 단일 &lt;a href=&quot;qbardataproxy#addRows&quot;&gt;QBarDataProxy :: addRows로&lt;/a&gt; 10 개의 행 추가() 호출은 10 개의 개별 &lt;a href=&quot;qbardataproxy#addRow&quot;&gt;QBarDataProxy :: addRow&lt;/a&gt; () 호출 보다 훨씬 효율적 입니다.</target>
        </trans-unit>
        <trans-unit id="850eb12314b4562298a7215df379da3fe4b7c57c" translate="yes" xml:space="preserve">
          <source>When you have multiple displays connected, the level of support to target one or more of these displays from one single Qt application, varies between the platform plugins and often depends on the device and its graphics stack.</source>
          <target state="translated">여러 디스플레이가 연결되어있는 경우 단일 Qt 응용 프로그램에서 이러한 디스플레이 중 하나 이상을 대상으로하는 지원 수준은 플랫폼 플러그인마다 다르며 종종 장치와 그래픽 스택에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="f2c795f997957d917a037b7558d2111076f2f860" translate="yes" xml:space="preserve">
          <source>When you have set up your account, click on &lt;b&gt;Add new application&lt;/b&gt; in Google Play's developer console.</source>
          <target state="translated">계정을 설정했으면 Google Play 개발자 콘솔에서 &lt;b&gt;새 애플리케이션 추가를&lt;/b&gt; 클릭하십시오 .</target>
        </trans-unit>
        <trans-unit id="da2b2d3afb5483b4a1db7b7d7fb239c631a77696" translate="yes" xml:space="preserve">
          <source>When you implement styles, there are several issues to consider. We will give some hints and advice on implementation here.</source>
          <target state="translated">스타일을 구현할 때 고려해야 할 몇 가지 문제가 있습니다. 여기에 구현에 대한 힌트와 조언을 드리겠습니다.</target>
        </trans-unit>
        <trans-unit id="8212971e42c4deca42aba3c17bc98fcd36818d32" translate="yes" xml:space="preserve">
          <source>When you make your own widget class, you should also communicate its layout properties. If the widget uses one of Qt's layouts, this is already taken care of. If the widget does not have any child widgets, or uses a manual layout, you can change the behavior of the widget using any or all of the following mechanisms:</source>
          <target state="translated">자신 만의 위젯 클래스를 만들 때 레이아웃 속성도 전달해야합니다. 위젯이 Qt의 레이아웃 중 하나를 사용하는 경우 이미 처리되었습니다. 위젯에 하위 위젯이 없거나 수동 레이아웃을 사용하는 경우 다음 메커니즘 중 하나 또는 모두를 사용하여 위젯의 동작을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="11e1d05bbb73ce5b03a0982e43710997b6d84eef" translate="yes" xml:space="preserve">
          <source>When you need to invoke item functionality in a &lt;a href=&quot;qmodelindex&quot;&gt;QModelIndex&lt;/a&gt;-based API (e.g. &lt;a href=&quot;qabstractitemview&quot;&gt;QAbstractItemView&lt;/a&gt;), you can call this function to obtain an index that corresponds to the item's location in the model.</source>
          <target state="translated">&lt;a href=&quot;qmodelindex&quot;&gt;QModelIndex&lt;/a&gt; 기반 API (예 : &lt;a href=&quot;qabstractitemview&quot;&gt;QAbstractItemView&lt;/a&gt; ) 에서 항목 기능을 호출해야하는 경우이 함수를 호출하여 모델의 항목 위치에 해당하는 색인을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8810b0890f73b99ba2b69adf7bbab05a3b05df5c" translate="yes" xml:space="preserve">
          <source>When you publish a &lt;code&gt;QObject&lt;/code&gt; that has overloaded methods, &lt;a href=&quot;qwebchannel&quot;&gt;QWebChannel&lt;/a&gt; will resolve method invocations to the best match. Note that due to JavaScript's type system, there is only a single 'number' type which maps best to a C++ 'double'. When overloads differ only in the type of a number-like parameter, &lt;a href=&quot;qwebchannel&quot;&gt;QWebChannel&lt;/a&gt; will always choose that overload which best matches the JavaScript 'number' type. When you connect to an overloaded signal, the &lt;a href=&quot;qwebchannel&quot;&gt;QWebChannel&lt;/a&gt; client will by default only connect to the first signal overload of that name. Additionally, overloads of methods and signals can explicitly be requested by their complete &lt;code&gt;QMetaMethod&lt;/code&gt; signature. Assume we have the following &lt;code&gt;QObject&lt;/code&gt; subclass on the C++ side:</source>
          <target state="translated">오버로드 된 메서드가 있는 &lt;code&gt;QObject&lt;/code&gt; 를 게시하면 &lt;a href=&quot;qwebchannel&quot;&gt;QWebChannel&lt;/a&gt; 이 메서드 호출을 가장 일치하는 것으로 확인합니다. JavaScript의 유형 시스템으로 인해 C ++ 'double'에 가장 잘 매핑되는 단일 '숫자'유형 만 있습니다. 오버로드가 숫자와 유사한 매개 변수의 유형에서만 다를 경우 &lt;a href=&quot;qwebchannel&quot;&gt;QWebChannel&lt;/a&gt; 은 항상 JavaScript '숫자'유형과 가장 일치하는 오버로드를 선택합니다. 과부하 된 신호에 연결할 때 &lt;a href=&quot;qwebchannel&quot;&gt;QWebChannel&lt;/a&gt; 클라이언트는 기본적으로 해당 이름의 첫 번째 신호 과부하에만 연결됩니다. 또한 메서드 및 신호의 오버로드는 전체 &lt;code&gt;QMetaMethod&lt;/code&gt; 서명에 의해 명시 적으로 요청 될 수 있습니다 . 다음 &lt;code&gt;QObject&lt;/code&gt; 가 있다고 가정 합니다. C ++ 측의 하위 클래스 :</target>
        </trans-unit>
        <trans-unit id="fa3c3f800f477ad4b6074ff08c0beb3cbd07d4a4" translate="yes" xml:space="preserve">
          <source>When you receive the signal, you call &lt;a href=&quot;qstandarditemmodel#itemFromIndex&quot;&gt;itemFromIndex&lt;/a&gt;() on the given model index to get a pointer to the item:</source>
          <target state="translated">신호를 받으면 주어진 모델 인덱스에서 &lt;a href=&quot;qstandarditemmodel#itemFromIndex&quot;&gt;itemFromIndex&lt;/a&gt; () 를 호출 하여 항목에 대한 포인터를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="11bc559026d9ce92e05880b306679f8d18cde9a7" translate="yes" xml:space="preserve">
          <source>When you reimplement your own paint engine, you must reimplement &lt;a href=&quot;qpaintengine#drawTextItem&quot;&gt;QPaintEngine::drawTextItem&lt;/a&gt;(), a function that takes a &lt;a href=&quot;qtextitem&quot;&gt;QTextItem&lt;/a&gt; as one of its arguments.</source>
          <target state="translated">자체 페인트 엔진을 다시 구현할 때는 &lt;a href=&quot;qtextitem&quot;&gt;QTextItem&lt;/a&gt; 을 인수 중 하나로 사용 하는 함수 인 &lt;a href=&quot;qpaintengine#drawTextItem&quot;&gt;QPaintEngine :: drawTextItem&lt;/a&gt; ()을 다시 구현해야합니다 .</target>
        </trans-unit>
        <trans-unit id="48d1f1f930cc85404c3f11ae3d2fbe97abc80529" translate="yes" xml:space="preserve">
          <source>When you reimplement your own paint engine, you must reimplement &lt;a href=&quot;qpaintengine#drawTextItem&quot;&gt;QPaintEngine::drawTextItem&lt;/a&gt;(), a function that takes a QTextItem as one of its arguments.</source>
          <target state="translated">자신의 페인트 엔진을 다시 구현할 때는 QTextItem을 인수 중 하나로받는 함수 인 &lt;a href=&quot;qpaintengine#drawTextItem&quot;&gt;QPaintEngine :: drawTextItem&lt;/a&gt; ()을 다시 구현해야합니다 .</target>
        </trans-unit>
        <trans-unit id="cc3622a2958b0c7677184a6e7b09570f3e9ffbeb" translate="yes" xml:space="preserve">
          <source>When you retrieve a pixmap using pixmap(&lt;a href=&quot;qsize&quot;&gt;QSize&lt;/a&gt;, Mode, State), and no pixmap for this given size, mode and state has been added with &lt;a href=&quot;qicon#addFile&quot;&gt;addFile&lt;/a&gt;() or &lt;a href=&quot;qicon#addPixmap&quot;&gt;addPixmap&lt;/a&gt;(), then &lt;a href=&quot;qicon&quot;&gt;QIcon&lt;/a&gt; will generate one on the fly. This pixmap generation happens in a &lt;a href=&quot;qiconengine&quot;&gt;QIconEngine&lt;/a&gt;. The default engine scales pixmaps down if required, but never up, and it uses the current style to calculate a disabled appearance. By using custom icon engines, you can customize every aspect of generated icons. With &lt;a href=&quot;qiconengineplugin&quot;&gt;QIconEnginePlugin&lt;/a&gt; it is possible to register different icon engines for different file suffixes, making it possible for third parties to provide additional icon engines to those included with Qt.</source>
          <target state="translated">pixmap ( &lt;a href=&quot;qsize&quot;&gt;QSize&lt;/a&gt; , Mode, State)을 사용하여 pixmap을 검색 할 때이 주어진 크기, 모드 및 상태에 대해 pixmap이 &lt;a href=&quot;qicon#addFile&quot;&gt;addFile&lt;/a&gt; () 또는 &lt;a href=&quot;qicon#addPixmap&quot;&gt;addPixmap&lt;/a&gt; () 으로 추가되지 않은 경우 &lt;a href=&quot;qicon&quot;&gt;QIcon&lt;/a&gt; 은 즉시 생성합니다. 이 픽스맵 생성은 &lt;a href=&quot;qiconengine&quot;&gt;QIconEngine&lt;/a&gt; 에서 발생합니다 . 기본 엔진은 필요에 따라 픽스맵을 축소하지만 절대 확대하지 않으며 현재 스타일을 사용하여 비활성화 된 모양을 계산합니다. 사용자 정의 아이콘 엔진을 사용하여 생성 된 아이콘의 모든 측면을 사용자 정의 할 수 있습니다. &lt;a href=&quot;qiconengineplugin&quot;&gt;QIconEnginePlugin&lt;/a&gt; 을 사용하면 파일 접미사마다 다른 아이콘 엔진을 등록 할 수있어 타사가 Qt에 포함 된 아이콘 엔진에 추가 아이콘 엔진을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f0467d78e10463d2a8ba36f6d8d3579b988d37d" translate="yes" xml:space="preserve">
          <source>When you retrieve a pixmap using pixmap(&lt;a href=&quot;qsize&quot;&gt;QSize&lt;/a&gt;, Mode, State), and no pixmap for this given size, mode and state has been added with &lt;a href=&quot;qicon#addFile&quot;&gt;addFile&lt;/a&gt;() or &lt;a href=&quot;qicon#addPixmap&quot;&gt;addPixmap&lt;/a&gt;(), then QIcon will generate one on the fly. This pixmap generation happens in a &lt;a href=&quot;qiconengine&quot;&gt;QIconEngine&lt;/a&gt;. The default engine scales pixmaps down if required, but never up, and it uses the current style to calculate a disabled appearance. By using custom icon engines, you can customize every aspect of generated icons. With &lt;a href=&quot;qiconengineplugin&quot;&gt;QIconEnginePlugin&lt;/a&gt; it is possible to register different icon engines for different file suffixes, making it possible for third parties to provide additional icon engines to those included with Qt.</source>
          <target state="translated">pixmap ( &lt;a href=&quot;qsize&quot;&gt;QSize&lt;/a&gt; , Mode, State)을 사용하여 픽스맵을 검색 하고이 주어진 크기에 대한 픽스맵이없는 경우 &lt;a href=&quot;qicon#addFile&quot;&gt;addFile&lt;/a&gt; () 또는 &lt;a href=&quot;qicon#addPixmap&quot;&gt;addPixmap&lt;/a&gt; ()을 사용 하여 모드 및 상태가 추가 되지 않으면 QIcon이 즉시 생성합니다. 이 픽스맵 생성은 &lt;a href=&quot;qiconengine&quot;&gt;QIconEngine&lt;/a&gt; 에서 발생합니다 . 기본 엔진은 필요한 경우 픽스맵을 축소하지만 절대 확대하지 않으며 현재 스타일을 사용하여 비활성화 된 모양을 계산합니다. 사용자 정의 아이콘 엔진을 사용하여 생성 된 아이콘의 모든 측면을 사용자 정의 할 수 있습니다. &lt;a href=&quot;qiconengineplugin&quot;&gt;QIconEnginePlugin&lt;/a&gt; 을 사용하면 서로 다른 파일 접미사에 대해 서로 다른 아이콘 엔진을 등록 할 수 있으므로 타사가 Qt에 포함 된 엔진에 추가 아이콘 엔진을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="571197ffd60fff66160ddd0d5152ea57afa360f9" translate="yes" xml:space="preserve">
          <source>When you run a Qt application, you can specify several command-line options that can help with debugging. These are recognized by &lt;a href=&quot;qapplication&quot;&gt;QApplication&lt;/a&gt;.</source>
          <target state="translated">Qt 애플리케이션을 실행할 때 디버깅에 도움이되는 몇 가지 명령 줄 옵션을 지정할 수 있습니다. 이것들은 &lt;a href=&quot;qapplication&quot;&gt;QApplication에&lt;/a&gt; 의해 인식됩니다 .</target>
        </trans-unit>
        <trans-unit id="349b845c24584a63440e56578dc469286bd5d62e" translate="yes" xml:space="preserve">
          <source>When you run an &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt; using the C++ API in a Qt application, you will often want to bind program variables to $variables in the &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt;. After the query is evaluated, you will want to interpret the sequence of data items in the result set.</source>
          <target state="translated">Qt 애플리케이션에서 C ++ API를 사용하여 &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt; 를 실행할 때 종종 프로그램 변수를 &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery의&lt;/a&gt; $ variables에 바인딩하고 싶을 것 입니다. 쿼리가 평가 된 후 결과 집합의 데이터 항목 시퀀스를 해석하려고합니다.</target>
        </trans-unit>
        <trans-unit id="dcbc1472c5e4961da67399a01267a56000ea1f91" translate="yes" xml:space="preserve">
          <source>When you run an XQuery using the C++ API in a Qt application, you will often want to bind program variables to $variables in the XQuery. After the query is evaluated, you will want to interpret the sequence of data items in the result set.</source>
          <target state="translated">Qt 애플리케이션에서 C ++ API를 사용하여 XQuery를 실행할 때 종종 프로그램 변수를 XQuery의 $ variables에 바인딩하려고합니다. 쿼리를 평가 한 후 결과 집합의 데이터 항목 시퀀스를 해석하려고합니다.</target>
        </trans-unit>
        <trans-unit id="74898dc919ae9ab35b6672e91c4aea88a18f022f" translate="yes" xml:space="preserve">
          <source>When you run your application, you will also need to add the &lt;code&gt;oci.dll&lt;/code&gt; path to your &lt;code&gt;PATH&lt;/code&gt; environment variable:</source>
          <target state="translated">응용 프로그램을 실행할 때 &lt;code&gt;oci.dll&lt;/code&gt; 경로를 &lt;code&gt;PATH&lt;/code&gt; 환경 변수 에 추가해야 합니다.</target>
        </trans-unit>
        <trans-unit id="d0c6b234a298b905aa90c3eef8101c41b23a9179" translate="yes" xml:space="preserve">
          <source>When you start developing on a given embedded device, often it's necessary to verify the behavior of the device and drivers, and that the connected displays are working as they should. One easy way is to use the &lt;b&gt;hellowindow&lt;/b&gt; example. Launching it with the &lt;code&gt;-platform eglfs --multiscreen --timeout&lt;/code&gt; arguments shows a rotating Qt logo on each connected screen for a few seconds.</source>
          <target state="translated">특정 임베디드 장치에서 개발을 시작할 때 종종 장치 및 드라이버의 동작을 확인하고 연결된 디스플레이가 정상적으로 작동하는지 확인해야합니다. 한 가지 쉬운 방법은 &lt;b&gt;hellowindow&lt;/b&gt; 예제 를 사용하는 &lt;b&gt;것&lt;/b&gt; 입니다. &lt;code&gt;-platform eglfs --multiscreen --timeout&lt;/code&gt; 인수로 시작하면 연결된 각 화면에 몇 초 동안 회전하는 Qt 로고가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="ee8546a04dd2a56a0ac326f7d2e48820793cd419" translate="yes" xml:space="preserve">
          <source>When you tell</source>
          <target state="translated">말할 때</target>
        </trans-unit>
        <trans-unit id="1fa91e235bb1e0e43574ae5fec7e6d97da21cd4c" translate="yes" xml:space="preserve">
          <source>When you use &lt;a href=&quot;qfile&quot;&gt;QFile&lt;/a&gt;, &lt;a href=&quot;qfileinfo&quot;&gt;QFileInfo&lt;/a&gt;, and &lt;a href=&quot;qdir&quot;&gt;QDir&lt;/a&gt; to access the file system with Qt, you can use Unicode file names. On Unix, these file names are converted to an 8-bit encoding. If you want to use standard C++ APIs (&lt;code&gt;&amp;lt;cstdio&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;iostream&amp;gt;&lt;/code&gt;) or platform-specific APIs to access files instead of &lt;a href=&quot;qfile&quot;&gt;QFile&lt;/a&gt;, you can use the &lt;a href=&quot;qfile#encodeName&quot;&gt;encodeName&lt;/a&gt;() and &lt;a href=&quot;qfile#decodeName&quot;&gt;decodeName&lt;/a&gt;() functions to convert between Unicode file names and 8-bit file names.</source>
          <target state="translated">당신이 사용하는 경우 &lt;a href=&quot;qfile&quot;&gt;Qfile을&lt;/a&gt; , &lt;a href=&quot;qfileinfo&quot;&gt;QFileInfo&lt;/a&gt; 및 &lt;a href=&quot;qdir&quot;&gt;QDir을&lt;/a&gt; Qt를 사용하여 파일 시스템에 액세스하려면 유니 코드 파일 이름을 사용할 수 있습니다. Unix에서이 파일 이름은 8 비트 인코딩으로 변환됩니다. &lt;code&gt;&amp;lt;cstdio&amp;gt;&lt;/code&gt; 표준 C ++ API ( &amp;lt;cstdio&amp;gt; 또는 &lt;code&gt;&amp;lt;iostream&amp;gt;&lt;/code&gt; ) 또는 플랫폼 별 API를 사용하여 파일에 액세스 &lt;a href=&quot;qfile&quot;&gt;하려는&lt;/a&gt; 경우 &lt;a href=&quot;qfile#encodeName&quot;&gt;encodeName&lt;/a&gt; () 및 &lt;a href=&quot;qfile#decodeName&quot;&gt;decodeName&lt;/a&gt; () 함수를 사용하여 유니 코드 파일 이름과 8- 비트 파일 이름.</target>
        </trans-unit>
        <trans-unit id="219842d63fb103c1dd2829e0b37f7c43d7849402" translate="yes" xml:space="preserve">
          <source>When you use QFile, &lt;a href=&quot;qfileinfo&quot;&gt;QFileInfo&lt;/a&gt;, and &lt;a href=&quot;qdir&quot;&gt;QDir&lt;/a&gt; to access the file system with Qt, you can use Unicode file names. On Unix, these file names are converted to an 8-bit encoding. If you want to use standard C++ APIs (&lt;code&gt;&amp;lt;cstdio&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;iostream&amp;gt;&lt;/code&gt;) or platform-specific APIs to access files instead of QFile, you can use the &lt;a href=&quot;qfile#encodeName&quot;&gt;encodeName&lt;/a&gt;() and &lt;a href=&quot;qfile#decodeName&quot;&gt;decodeName&lt;/a&gt;() functions to convert between Unicode file names and 8-bit file names.</source>
          <target state="translated">QFile, &lt;a href=&quot;qfileinfo&quot;&gt;QFileInfo&lt;/a&gt; 및 &lt;a href=&quot;qdir&quot;&gt;QDir&lt;/a&gt; 을 사용하여 Qt로 파일 시스템에 액세스 할 때 유니 코드 파일 이름을 사용할 수 있습니다. Unix에서 이러한 파일 이름은 8 비트 인코딩으로 변환됩니다. 표준 C ++ API ( &lt;code&gt;&amp;lt;cstdio&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;&amp;lt;iostream&amp;gt;&lt;/code&gt; ) 또는 플랫폼 별 API를 사용하여 QFile 대신 파일에 액세스하려는 경우 &lt;a href=&quot;qfile#encodeName&quot;&gt;encodeName&lt;/a&gt; () 및 &lt;a href=&quot;qfile#decodeName&quot;&gt;decodeName&lt;/a&gt; () 함수를 사용하여 유니 코드 파일 이름과 8- 비트 파일 이름.</target>
        </trans-unit>
        <trans-unit id="80fb6f7c17f227081e6e0638953d3b9f7a80a55c" translate="yes" xml:space="preserve">
          <source>When you use a Button in your application, the &lt;code&gt;background&lt;/code&gt; and &lt;code&gt;contentItem&lt;/code&gt; items will be created and parented to the root &lt;code&gt;Button&lt;/code&gt; item:</source>
          <target state="translated">애플리케이션에서 Button을 사용하면 &lt;code&gt;background&lt;/code&gt; 및 &lt;code&gt;contentItem&lt;/code&gt; 항목이 생성되고 루트 &lt;code&gt;Button&lt;/code&gt; 항목의 상위 항목이됩니다 .</target>
        </trans-unit>
        <trans-unit id="6ed92c03ec92c021add70bc2437e374d7f1ddbaf" translate="yes" xml:space="preserve">
          <source>When you use a layout, you do not need to pass a parent when constructing the child widgets. The layout will automatically reparent the widgets (using &lt;a href=&quot;qwidget#setParent&quot;&gt;QWidget::setParent&lt;/a&gt;()) so that they are children of the widget on which the layout is installed.</source>
          <target state="translated">레이아웃을 사용할 때 자식 위젯을 구성 할 때 부모를 전달할 필요가 없습니다. 레이아웃은 위젯이 자동으로 보호되어 ( &lt;a href=&quot;qwidget#setParent&quot;&gt;QWidget :: setParent&lt;/a&gt; () 사용) 위젯이 레이아웃이 설치된 위젯의 하위가되도록합니다.</target>
        </trans-unit>
        <trans-unit id="da35347dbd73ff3a30bfc301345e76eff709d5d4" translate="yes" xml:space="preserve">
          <source>When you use the &lt;code&gt;debug_and_release&lt;/code&gt; option (which is the default under Windows), the project will be processed three times: one time to produce a &quot;meta&quot; Makefile, and two more times to produce a Makefile.Debug and a Makefile.Release.</source>
          <target state="translated">당신이 사용하는 경우 &lt;code&gt;debug_and_release&lt;/code&gt; 의 Makefile.Debug과 Makefile.Release을 생산하는 &quot;메타&quot;Makefile을 생산 한 번, 두 번 이상 (Windows에서 기본값) 옵션을,이 프로젝트는 세 번 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="60d4ef933d47b492272cf35cd6a80f96f67accbc" translate="yes" xml:space="preserve">
          <source>When you want a list or tree, you typically create an empty &lt;a href=&quot;qstandarditemmodel&quot;&gt;QStandardItemModel&lt;/a&gt; and use &lt;a href=&quot;qstandarditemmodel#appendRow&quot;&gt;appendRow&lt;/a&gt;() to add items to the model, and &lt;a href=&quot;qstandarditemmodel#item&quot;&gt;item&lt;/a&gt;() to access an item. If your model represents a table, you typically pass the dimensions of the table to the &lt;a href=&quot;qstandarditemmodel&quot;&gt;QStandardItemModel&lt;/a&gt; constructor and use &lt;a href=&quot;qstandarditemmodel#setItem&quot;&gt;setItem&lt;/a&gt;() to position items into the table. You can also use &lt;a href=&quot;qstandarditemmodel#setRowCount&quot;&gt;setRowCount&lt;/a&gt;() and &lt;a href=&quot;qstandarditemmodel#setColumnCount&quot;&gt;setColumnCount&lt;/a&gt;() to alter the dimensions of the model. To insert items, use &lt;a href=&quot;qstandarditemmodel#insertRow&quot;&gt;insertRow&lt;/a&gt;() or &lt;a href=&quot;qstandarditemmodel#insertColumn&quot;&gt;insertColumn&lt;/a&gt;(), and to remove items, use &lt;a href=&quot;qabstractitemmodel#removeRow&quot;&gt;removeRow&lt;/a&gt;() or &lt;a href=&quot;qabstractitemmodel#removeColumn&quot;&gt;removeColumn&lt;/a&gt;().</source>
          <target state="translated">목록이나 트리를 원할 경우 일반적으로 빈 &lt;a href=&quot;qstandarditemmodel&quot;&gt;QStandardItemModel을&lt;/a&gt; 작성하고 &lt;a href=&quot;qstandarditemmodel#appendRow&quot;&gt;appendRow&lt;/a&gt; ()를 사용 하여 모델에 항목을 추가하고 &lt;a href=&quot;qstandarditemmodel#item&quot;&gt;item&lt;/a&gt; ()을 사용하여 항목에 액세스하십시오. 모델이 테이블을 나타내는 경우 일반적으로 테이블의 차원을 &lt;a href=&quot;qstandarditemmodel&quot;&gt;QStandardItemModel&lt;/a&gt; 생성자에 전달하고 &lt;a href=&quot;qstandarditemmodel#setItem&quot;&gt;setItem&lt;/a&gt; ()을 사용 하여 항목을 테이블에 배치하십시오. 당신은 또한 사용할 수 있습니다 &lt;a href=&quot;qstandarditemmodel#setRowCount&quot;&gt;에 setRowCount&lt;/a&gt; ()와 &lt;a href=&quot;qstandarditemmodel#setColumnCount&quot;&gt;setColumnCount를&lt;/a&gt; 모델의 크기를 변경 (). 항목을 삽입하려면 &lt;a href=&quot;qstandarditemmodel#insertRow&quot;&gt;insertRow&lt;/a&gt; () 또는 &lt;a href=&quot;qstandarditemmodel#insertColumn&quot;&gt;insertColumn&lt;/a&gt; ()을 사용하고 항목을 제거하려면 &lt;a href=&quot;qabstractitemmodel#removeRow&quot;&gt;removeRow&lt;/a&gt; () 또는 &lt;a href=&quot;qabstractitemmodel#removeColumn&quot;&gt;removeColumn&lt;/a&gt; ()을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="4be51d41f9dcd2a63e9244eac2472e02cc98fe35" translate="yes" xml:space="preserve">
          <source>When you want a list or tree, you typically create an empty QStandardItemModel and use &lt;a href=&quot;qstandarditemmodel#appendRow&quot;&gt;appendRow&lt;/a&gt;() to add items to the model, and &lt;a href=&quot;qstandarditemmodel#item&quot;&gt;item&lt;/a&gt;() to access an item. If your model represents a table, you typically pass the dimensions of the table to the QStandardItemModel constructor and use &lt;a href=&quot;qstandarditemmodel#setItem&quot;&gt;setItem&lt;/a&gt;() to position items into the table. You can also use &lt;a href=&quot;qstandarditemmodel#setRowCount&quot;&gt;setRowCount&lt;/a&gt;() and &lt;a href=&quot;qstandarditemmodel#setColumnCount&quot;&gt;setColumnCount&lt;/a&gt;() to alter the dimensions of the model. To insert items, use &lt;a href=&quot;qstandarditemmodel#insertRow&quot;&gt;insertRow&lt;/a&gt;() or &lt;a href=&quot;qstandarditemmodel#insertColumn&quot;&gt;insertColumn&lt;/a&gt;(), and to remove items, use &lt;a href=&quot;qabstractitemmodel#removeRow&quot;&gt;removeRow&lt;/a&gt;() or &lt;a href=&quot;qabstractitemmodel#removeColumn&quot;&gt;removeColumn&lt;/a&gt;().</source>
          <target state="translated">목록이나 트리를 원할 때 일반적으로 빈 QStandardItemModel을 만들고 &lt;a href=&quot;qstandarditemmodel#appendRow&quot;&gt;appendRow&lt;/a&gt; ()를 사용 하여 모델에 항목을 추가하고 &lt;a href=&quot;qstandarditemmodel#item&quot;&gt;항목&lt;/a&gt; ()을 사용하여 항목에 액세스합니다. 모델이 테이블을 나타내는 경우 일반적으로 테이블의 차원을 QStandardItemModel 생성자에 전달하고 &lt;a href=&quot;qstandarditemmodel#setItem&quot;&gt;setItem&lt;/a&gt; ()을 사용 하여 항목을 테이블에 배치합니다. 당신은 또한 사용할 수 있습니다 &lt;a href=&quot;qstandarditemmodel#setRowCount&quot;&gt;에 setRowCount&lt;/a&gt; ()와 &lt;a href=&quot;qstandarditemmodel#setColumnCount&quot;&gt;setColumnCount를&lt;/a&gt; 모델의 크기를 변경 (). 항목을 삽입하려면 &lt;a href=&quot;qstandarditemmodel#insertRow&quot;&gt;insertRow&lt;/a&gt; () 또는 &lt;a href=&quot;qstandarditemmodel#insertColumn&quot;&gt;insertColumn&lt;/a&gt; ()을 사용하고 항목을 제거하려면 &lt;a href=&quot;qabstractitemmodel#removeRow&quot;&gt;removeRow&lt;/a&gt; () 또는 &lt;a href=&quot;qabstractitemmodel#removeColumn&quot;&gt;removeColumn&lt;/a&gt; ()을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="7170217aec4e1498546cac59074468c5f11f708f" translate="yes" xml:space="preserve">
          <source>When you want to run a parameterized &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt; from your Qt application, you will need to &lt;a href=&quot;qxmlquery#bindVariable&quot;&gt;bind variables&lt;/a&gt; in your program to $name variables in your &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt;.</source>
          <target state="translated">이 매개 변수가 실행할 때 &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery를&lt;/a&gt; 당신의 Qt는 응용 프로그램에서, 당신이 필요합니다 &lt;a href=&quot;qxmlquery#bindVariable&quot;&gt;바인드 변수&lt;/a&gt; 당신의 $ 이름 변수에 프로그램에서 &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2584a7ed7c056364ed2d913bf3cd8afc1f83ee3b" translate="yes" xml:space="preserve">
          <source>When you want to run a parameterized XQuery from your Qt application, you will need to &lt;a href=&quot;qxmlquery#bindVariable&quot;&gt;bind variables&lt;/a&gt; in your program to $name variables in your XQuery.</source>
          <target state="translated">Qt 애플리케이션에서 매개 변수화 된 XQuery를 실행하려면 프로그램의 변수를 XQuery의 $ name 변수에 &lt;a href=&quot;qxmlquery#bindVariable&quot;&gt;바인딩&lt;/a&gt; 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="78943cac7e531af0096129c5e938f47ed5b0b259" translate="yes" xml:space="preserve">
          <source>When you write your own text input controls, use &lt;a href=&quot;qtextlayout&quot;&gt;QTextLayout&lt;/a&gt;. In some languages (e.g. Arabic or languages from the Indian subcontinent), the width and shape of a glyph changes depending on the surrounding characters, which &lt;a href=&quot;qtextlayout&quot;&gt;QTextLayout&lt;/a&gt; takes into account. Writing input controls usually requires a certain knowledge of the scripts it is going to be used in. Usually the easiest way is to subclass &lt;a href=&quot;qlineedit&quot;&gt;QLineEdit&lt;/a&gt; or &lt;a href=&quot;qtextedit&quot;&gt;QTextEdit&lt;/a&gt;.</source>
          <target state="translated">자체 텍스트 입력 컨트롤을 작성할 때는 &lt;a href=&quot;qtextlayout&quot;&gt;QTextLayout을&lt;/a&gt; 사용 하십시오 . 일부 언어 (예 : 아랍어 또는 인도 아대륙의 언어)에서 글리프의 너비와 모양은 &lt;a href=&quot;qtextlayout&quot;&gt;QTextLayout&lt;/a&gt; 이 고려 하는 주변 문자에 따라 달라집니다 . 입력 컨트롤을 작성하려면 일반적으로 사용되는 스크립트에 대한 특정 지식이 필요합니다. 일반적으로 가장 쉬운 방법은 &lt;a href=&quot;qlineedit&quot;&gt;QLineEdit&lt;/a&gt; 또는 &lt;a href=&quot;qtextedit&quot;&gt;QTextEdit&lt;/a&gt; 를 서브 클래 싱하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="0fcbb31161cb56fe5288b022cf20ee3adfe4a05b" translate="yes" xml:space="preserve">
          <source>When you're finished changing a record, you should always call &lt;a href=&quot;qsqltablemodel#submitAll&quot;&gt;QSqlTableModel::submitAll&lt;/a&gt;() to ensure that the changes are written to the database.</source>
          <target state="translated">레코드 변경을 완료하면 항상 &lt;a href=&quot;qsqltablemodel#submitAll&quot;&gt;QSqlTableModel :: submitAll&lt;/a&gt; ()을 호출 하여 변경 사항이 데이터베이스에 기록되도록해야합니다.</target>
        </trans-unit>
        <trans-unit id="a73269c31e4068b1b206c35bf9e9ab6195ba01df" translate="yes" xml:space="preserve">
          <source>When you're reviewing a change, you can adapt this workflow to check that the change does indeed come with a test for a problem it does fix.</source>
          <target state="translated">변경 사항을 검토 할 때이 워크 플로를 조정하여 변경 사항이 실제로 수정되는 문제에 대한 테스트와 함께 제공되는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c483778adddb3d8e4d84a4e99e535203121a7d52" translate="yes" xml:space="preserve">
          <source>When your ActiveX server can also run as a stand-alone application, run the server executable with the &lt;code&gt;-regserver&lt;/code&gt; command line parameter after installing the executable on the target system. After that the controls provided by the server will be available to ActiveX clients.</source>
          <target state="translated">ActiveX 서버가 독립형 응용 프로그램으로도 실행될 수 있으면 대상 시스템에 실행 파일을 설치 한 후 &lt;code&gt;-regserver&lt;/code&gt; 명령 행 매개 변수를 사용하여 서버 실행 파일을 실행하십시오 . 그런 다음 서버에서 제공 한 컨트롤을 ActiveX 클라이언트에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="14bd0a3d9cc58e093620fbe1426775b51697ae9b" translate="yes" xml:space="preserve">
          <source>When your ActiveX server is part of an installation package, use the &lt;code&gt;regsvr32&lt;/code&gt; tool provided by Microsoft to register the controls on the target system. If this tool is not present, load the DLL into your installer process, resolve the &lt;code&gt;DllRegisterServer&lt;/code&gt; symbol and call the function:</source>
          <target state="translated">ActiveX 서버가 설치 패키지의 일부인 경우 Microsoft에서 제공 하는 &lt;code&gt;regsvr32&lt;/code&gt; 도구를 사용 하여 대상 시스템에 컨트롤을 등록하십시오. 이 도구가 없으면 DLL을 설치 프로그램 프로세스에로드하고 &lt;code&gt;DllRegisterServer&lt;/code&gt; 기호를 해결 한 후 함수를 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="65dc96c99575af20d0c9102011208535a2e1118f" translate="yes" xml:space="preserve">
          <source>When your application loads a QML or JavaScript file for the first time, the QML engine compiles the file into a byte code representation on the fly and runs it. The compiling process can be time consuming, and subsequent loads of the same document yield the same result. To optimize this step, the QML engine can cache the result. It stores the byte code in a cache file and later loads the cache file instead of re-compiling when the same file is requested again. Usually the files are stored in a subdirectory &lt;code&gt;qmlcache&lt;/code&gt; of the system's cache directory, as denoted by &lt;a href=&quot;qstandardpaths#StandardLocation-enum&quot;&gt;QStandardPaths::CacheLocation&lt;/a&gt;. Checks are in place to make sure that the cache files are only loaded if all of the following conditions are met:</source>
          <target state="translated">애플리케이션이 QML 또는 JavaScript 파일을 처음으로로드하면 QML 엔진은 파일을 즉시 바이트 코드 표현으로 컴파일하고 실행합니다. 컴파일 프로세스는 시간이 많이 소요될 수 있으며 동일한 문서를 후속로드하면 동일한 결과가 생성됩니다. 이 단계를 최적화하기 위해 QML 엔진은 결과를 캐시 할 수 있습니다. 캐시 파일에 바이트 코드를 저장하고 나중에 동일한 파일이 다시 요청 될 때 다시 컴파일하는 대신 캐시 파일을로드합니다. 일반적으로 파일은 하위 디렉토리에 저장됩니다 &lt;code&gt;qmlcache&lt;/code&gt; 로 표시로서, 시스템의 캐시 디렉토리의 &lt;a href=&quot;qstandardpaths#StandardLocation-enum&quot;&gt;QStandardPaths :: CacheLocation&lt;/a&gt; . 다음 조건이 모두 충족되는 경우에만 캐시 파일이로드되는지 확인하는 검사가 있습니다.</target>
        </trans-unit>
        <trans-unit id="ccc533c9390848ea4b2a56fc523e5772f7a9f05a" translate="yes" xml:space="preserve">
          <source>When your model has a consistent silhouette, you can apply an opacity map that makes the outer edge of the geometry transparent. Using a gradient for the opacity will let the edge of the object smoothly disappear. However, even if your opacity map transitions directly from fully-opaque to fully-transparent over the space of one pixel, the result will still provide anti-aliased edges as seen in the example above. This is because image maps, including opacity maps, use bilinear interpolation.</source>
          <target state="translated">모델에 일관된 실루엣이있는 경우 형상의 외부 가장자리를 투명하게 만드는 불투명 맵을 적용 할 수 있습니다. 불투명도에 그라디언트를 사용하면 개체의 가장자리가 부드럽게 사라집니다. 그러나 불투명도 맵이 한 픽셀의 공간에서 완전 불투명에서 완전 투명으로 직접 전환 되더라도 위의 예에서 볼 수 있듯이 결과는 여전히 앤티 앨리어싱 된 가장자리를 제공합니다. 불투명도 맵을 포함한 이미지 맵이 쌍 선형 보간을 사용하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="027ec3bc4d20f0e86797e47980aa9a9475deabbe" translate="yes" xml:space="preserve">
          <source>Whenever `processTextMessage()` is triggered, we retrieve the sender, and if valid, send back the original message (`sendTextMessage()`). The same is done with binary messages.</source>
          <target state="translated">`processTextMessage ()`가 트리거 될 때마다 발신자를 검색하고 유효한 경우 원래 메시지 (`sendTextMessage ()`)를 다시 보냅니다. 이진 메시지에서도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="3cd3563583d0b4557a8fb5a3af277b71d7d4fa6f" translate="yes" xml:space="preserve">
          <source>Whenever a &lt;a href=&quot;qml-qtquick-controls-checkbox&quot;&gt;CheckBox&lt;/a&gt; is clicked, it emits the &lt;a href=&quot;qml-qtquick-controls-checkbox#clicked-signal&quot;&gt;clicked()&lt;/a&gt; signal.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-controls-checkbox&quot;&gt;CheckBox&lt;/a&gt; 를 클릭 할 때마다 &lt;a href=&quot;qml-qtquick-controls-checkbox#clicked-signal&quot;&gt;clicked ()&lt;/a&gt; 신호가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="b506669184758650a5512c38b3282045fabaae85" translate="yes" xml:space="preserve">
          <source>Whenever a CheckBox is clicked, it emits the &lt;a href=&quot;qml-qtquick-controls-checkbox#clicked-signal&quot;&gt;clicked()&lt;/a&gt; signal.</source>
          <target state="translated">CheckBox를 클릭 할 때마다 &lt;a href=&quot;qml-qtquick-controls-checkbox#clicked-signal&quot;&gt;clicked ()&lt;/a&gt; 신호를 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="53a69c8a1f964bb9777baba93c7827da52f72065" translate="yes" xml:space="preserve">
          <source>Whenever a button is switched on or off, it emits the &lt;a href=&quot;qabstractbutton#toggled&quot;&gt;toggled&lt;/a&gt;() signal. Connect to this signal if you want to trigger an action each time the button changes state. Use &lt;a href=&quot;qabstractbutton#checked-prop&quot;&gt;isChecked&lt;/a&gt;() to see if a particular button is selected.</source>
          <target state="translated">버튼을 켜거나 끌 때마다 &lt;a href=&quot;qabstractbutton#toggled&quot;&gt;토글&lt;/a&gt; () 신호가 발생합니다 . 버튼 상태가 바뀔 때마다 동작을 트리거하려면이 신호에 연결하십시오. &lt;a href=&quot;qabstractbutton#checked-prop&quot;&gt;isChecked&lt;/a&gt; ()를 사용 하여 특정 버튼이 선택되어 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="98df15d5cd2ca206ae0b777515f1789f82058d70" translate="yes" xml:space="preserve">
          <source>Whenever a checkbox is checked or cleared, it emits the signal &lt;a href=&quot;qcheckbox#stateChanged&quot;&gt;stateChanged&lt;/a&gt;(). Connect to this signal if you want to trigger an action each time the checkbox changes state. You can use &lt;a href=&quot;qabstractbutton#checked-prop&quot;&gt;isChecked&lt;/a&gt;() to query whether or not a checkbox is checked.</source>
          <target state="translated">확인란을 선택하거나 지울 때마다 &lt;a href=&quot;qcheckbox#stateChanged&quot;&gt;stateChanged&lt;/a&gt; () 신호가 발생합니다 . 확인란의 상태가 바뀔 때마다 작업을 트리거하려면이 신호에 연결하십시오. &lt;a href=&quot;qabstractbutton#checked-prop&quot;&gt;isChecked&lt;/a&gt; ()를 사용 하여 확인란의 선택 여부를 쿼리 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="622050ab0f3753e8f422b1fec5fa59fed4693f03" translate="yes" xml:space="preserve">
          <source>Whenever a help event occurs, this function is called with the</source>
          <target state="translated">도움말 이벤트가 발생할 때마다이 함수는</target>
        </trans-unit>
        <trans-unit id="695fe6b59174187c21971601195bbbdc7ae00fac" translate="yes" xml:space="preserve">
          <source>Whenever a message is received, we write it out.</source>
          <target state="translated">메시지가 수신 될 때마다 메시지를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="90fe0cc17049ffdb58a0f22d6b9f296fcdc96921" translate="yes" xml:space="preserve">
          <source>Whenever a new frame is available in the movie, &lt;a href=&quot;qmovie&quot;&gt;QMovie&lt;/a&gt; will emit &lt;a href=&quot;qmovie#updated&quot;&gt;updated&lt;/a&gt;(). If the size of the frame changes, &lt;a href=&quot;qmovie#resized&quot;&gt;resized&lt;/a&gt;() is emitted. You can call &lt;a href=&quot;qmovie#currentImage&quot;&gt;currentImage&lt;/a&gt;() or &lt;a href=&quot;qmovie#currentPixmap&quot;&gt;currentPixmap&lt;/a&gt;() to get a copy of the current frame. When the movie is done, &lt;a href=&quot;qmovie&quot;&gt;QMovie&lt;/a&gt; emits &lt;a href=&quot;qmovie#finished&quot;&gt;finished&lt;/a&gt;(). If any error occurs during playback (i.e, the image file is corrupt), &lt;a href=&quot;qmovie&quot;&gt;QMovie&lt;/a&gt; will emit &lt;a href=&quot;qmovie#error&quot;&gt;error&lt;/a&gt;().</source>
          <target state="translated">동영상에서 새 프레임을 사용할 수있을 때마다 &lt;a href=&quot;qmovie&quot;&gt;QMovie&lt;/a&gt; 는 &lt;a href=&quot;qmovie#updated&quot;&gt;업데이트 된&lt;/a&gt; () 을 방출 합니다. 프레임 크기가 변경되면 &lt;a href=&quot;qmovie#resized&quot;&gt;크기 조정&lt;/a&gt; ()이 방출됩니다. &lt;a href=&quot;qmovie#currentImage&quot;&gt;currentImage&lt;/a&gt; () 또는 &lt;a href=&quot;qmovie#currentPixmap&quot;&gt;currentPixmap&lt;/a&gt; ()을 호출 하여 현재 프레임의 복사본을 얻을 수 있습니다. 동영상이 완료되면, &lt;a href=&quot;qmovie&quot;&gt;QMovie의&lt;/a&gt; 를 방출이 &lt;a href=&quot;qmovie#finished&quot;&gt;종료&lt;/a&gt; (). 오류가 (즉, 이미지 파일이 손상) 재생 중에 발생하면 &lt;a href=&quot;qmovie&quot;&gt;QMovie가&lt;/a&gt; 방출됩니다 &lt;a href=&quot;qmovie#error&quot;&gt;오류를&lt;/a&gt; ().</target>
        </trans-unit>
        <trans-unit id="dea4145ce4f75997826b07037b31828f8852e594" translate="yes" xml:space="preserve">
          <source>Whenever a new frame is available in the movie, QMovie will emit &lt;a href=&quot;qmovie#updated&quot;&gt;updated&lt;/a&gt;(). If the size of the frame changes, &lt;a href=&quot;qmovie#resized&quot;&gt;resized&lt;/a&gt;() is emitted. You can call &lt;a href=&quot;qmovie#currentImage&quot;&gt;currentImage&lt;/a&gt;() or &lt;a href=&quot;qmovie#currentPixmap&quot;&gt;currentPixmap&lt;/a&gt;() to get a copy of the current frame. When the movie is done, QMovie emits &lt;a href=&quot;qmovie#finished&quot;&gt;finished&lt;/a&gt;(). If any error occurs during playback (i.e, the image file is corrupt), QMovie will emit &lt;a href=&quot;qmovie#error&quot;&gt;error&lt;/a&gt;().</source>
          <target state="translated">영화에서 새 프레임을 사용할 수있을 때마다 QMovie는 &lt;a href=&quot;qmovie#updated&quot;&gt;업데이트 된&lt;/a&gt; ()을 내 보냅니다 . 프레임 크기가 변경되면 &lt;a href=&quot;qmovie#resized&quot;&gt;크기 조정&lt;/a&gt; ()이 방출됩니다. &lt;a href=&quot;qmovie#currentImage&quot;&gt;currentImage&lt;/a&gt; () 또는 &lt;a href=&quot;qmovie#currentPixmap&quot;&gt;currentPixmap&lt;/a&gt; ()을 호출 하여 현재 프레임의 복사본을 가져올 수 있습니다. 동영상이 완료되면 QMovie가 &lt;a href=&quot;qmovie#finished&quot;&gt;완료&lt;/a&gt; ()를 내 보냅니다 . 재생 중에 오류가 발생하면 (즉, 이미지 파일이 손상된 경우) QMovie에서 &lt;a href=&quot;qmovie#error&quot;&gt;오류&lt;/a&gt; () 가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="ce06d5f1ff8e225d1adc268c9cdd8c9e9dc54f82" translate="yes" xml:space="preserve">
          <source>Whenever a socket is disconnected, we remove it from the clients list and delete the socket. Note: it is best to use `deleteLater()` to delete the socket.</source>
          <target state="translated">소켓이 연결 해제 될 때마다 클라이언트 목록에서 소켓을 제거하고 소켓을 삭제합니다. 참고 : 소켓을 삭제하려면`deleteLater ()`를 사용하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="73df17f4d1de1623ad4e92d56228608091517aaf" translate="yes" xml:space="preserve">
          <source>Whenever a widget loses focus, the widget's current value is set to the item model.</source>
          <target state="translated">위젯이 포커스를 잃을 때마다 위젯의 현재 값이 항목 모델로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="aeeb8caf9d0b96887fbffb95f418d29cecb00031" translate="yes" xml:space="preserve">
          <source>Whenever an item is added to the above view, all items beneath the new item are displaced, causing them to move down (or sideways, if horizontally orientated) within the view. As this displacement occurs, the items' movement to their new x,y positions within the view will be animated by a &lt;a href=&quot;qml-qtquick-numberanimation&quot;&gt;NumberAnimation&lt;/a&gt; over one second, as specified. This transition is not applied to the new item that has been added to the view; to animate the added items, set the &lt;a href=&quot;qml-qtquick-gridview#add-signal&quot;&gt;add&lt;/a&gt; property.</source>
          <target state="translated">항목이 위의보기에 추가 될 때마다 새 항목 아래의 모든 항목이 이동하여보기 내에서 아래로 (또는 가로 방향 인 경우 옆으로) 이동합니다. 이 변위가 발생하면 뷰 내에서 새로운 x, y 위치로의 항목 이동 은 지정된대로 1 초 동안 &lt;a href=&quot;qml-qtquick-numberanimation&quot;&gt;NumberAnimation&lt;/a&gt; 에 의해 애니메이션됩니다 . 이 전환은보기에 추가 된 새 항목에는 적용되지 않습니다. 추가 된 항목에 애니메이션을 적용하려면 &lt;a href=&quot;qml-qtquick-gridview#add-signal&quot;&gt;add&lt;/a&gt; 속성을 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="78d2be573356e883c161ace1948bad51ebd33c75" translate="yes" xml:space="preserve">
          <source>Whenever an item is added to the above view, all items beneath the new item are displaced, causing them to move down (or sideways, if horizontally orientated) within the view. As this displacement occurs, the items' movement to their new x,y positions within the view will be animated by a &lt;a href=&quot;qml-qtquick-numberanimation&quot;&gt;NumberAnimation&lt;/a&gt; over one second, as specified. This transition is not applied to the new item that has been added to the view; to animate the added items, set the &lt;a href=&quot;qml-qtquick-listview#add-signal&quot;&gt;add&lt;/a&gt; property.</source>
          <target state="translated">항목이 위의보기에 추가 될 때마다 새 항목 아래의 모든 항목이 이동하여보기 내에서 아래로 (또는 가로 방향 인 경우 옆으로) 이동합니다. 이 변위가 발생하면 뷰 내에서 새로운 x, y 위치로의 항목 이동 은 지정된대로 1 초 동안 &lt;a href=&quot;qml-qtquick-numberanimation&quot;&gt;NumberAnimation&lt;/a&gt; 에 의해 애니메이션됩니다 . 이 전환은보기에 추가 된 새 항목에는 적용되지 않습니다. 추가 된 항목에 애니메이션을 적용하려면 &lt;a href=&quot;qml-qtquick-listview#add-signal&quot;&gt;add&lt;/a&gt; 속성을 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="a92651cada4705e95a6599aa36b9830bb5133d4d" translate="yes" xml:space="preserve">
          <source>Whenever an item is added to the above view, the item will be animated from the position (100,100) to its final x,y position within the view, over one second. The transition only applies to the new items that are added to the view; it does not apply to the items below that are displaced by the addition of the new items. To animate the displaced items, set the &lt;a href=&quot;qml-qtquick-gridview#displaced-prop&quot;&gt;displaced&lt;/a&gt; or &lt;a href=&quot;qml-qtquick-gridview#addDisplaced-prop&quot;&gt;addDisplaced&lt;/a&gt; properties.</source>
          <target state="translated">항목이 위의보기에 추가 될 때마다 항목이 위치 (100,100)에서보기 내의 마지막 x, y 위치로 1 초 이상 애니메이션됩니다. 전환은보기에 추가 된 새 항목에만 적용됩니다. 새 항목을 추가하여 대체 된 아래 항목에는 적용되지 않습니다. 변위 된 항목에 애니메이션을 적용하려면 &lt;a href=&quot;qml-qtquick-gridview#displaced-prop&quot;&gt;변위&lt;/a&gt; 또는 &lt;a href=&quot;qml-qtquick-gridview#addDisplaced-prop&quot;&gt;addDisplaced&lt;/a&gt; 속성을 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="fedd4c064ea3bd87026e3e226e4cb864f52ee584" translate="yes" xml:space="preserve">
          <source>Whenever an item is added to the above view, the item will be animated from the position (100,100) to its final x,y position within the view, over one second. The transition only applies to the new items that are added to the view; it does not apply to the items below that are displaced by the addition of the new items. To animate the displaced items, set the &lt;a href=&quot;qml-qtquick-listview#displaced-prop&quot;&gt;displaced&lt;/a&gt; or &lt;a href=&quot;qml-qtquick-listview#addDisplaced-prop&quot;&gt;addDisplaced&lt;/a&gt; properties.</source>
          <target state="translated">항목이 위의보기에 추가 될 때마다 항목이 위치 (100,100)에서보기 내의 마지막 x, y 위치로 1 초 이상 애니메이션됩니다. 전환은보기에 추가 된 새 항목에만 적용됩니다. 새 항목을 추가하여 대체 된 아래 항목에는 적용되지 않습니다. 변위 된 항목에 애니메이션을 적용하려면 &lt;a href=&quot;qml-qtquick-listview#displaced-prop&quot;&gt;변위&lt;/a&gt; 또는 &lt;a href=&quot;qml-qtquick-listview#addDisplaced-prop&quot;&gt;addDisplaced&lt;/a&gt; 속성을 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="9ee2054577a98ab0392d1b4d7970f9f828507766" translate="yes" xml:space="preserve">
          <source>Whenever an item is removed from the above view, all items beneath it are displaced, causing them to move upwards (or sideways, if horizontally orientated) within the view. As this displacement occurs, the items' movement to their new x,y positions within the view will be animated by a &lt;a href=&quot;qml-qtquick-numberanimation&quot;&gt;NumberAnimation&lt;/a&gt; over one second, as specified. This transition is not applied to the item that has actually been removed from the view; to animate the removed items, set the &lt;a href=&quot;qml-qtquick-gridview#remove-signal&quot;&gt;remove&lt;/a&gt; property.</source>
          <target state="translated">위의보기에서 항목을 제거 할 때마다 그 아래에있는 모든 항목이 이동하여보기 내에서 위쪽 (또는 가로 방향 인 경우 옆으로) 이동합니다. 이 변위가 발생하면 뷰 내에서 새로운 x, y 위치로의 항목 이동 은 지정된대로 1 초 동안 &lt;a href=&quot;qml-qtquick-numberanimation&quot;&gt;NumberAnimation&lt;/a&gt; 에 의해 애니메이션됩니다 . 이 전환은 실제로보기에서 제거 된 항목에는 적용되지 않습니다. 제거 된 항목에 애니메이션을 적용하려면 &lt;a href=&quot;qml-qtquick-gridview#remove-signal&quot;&gt;remove&lt;/a&gt; 속성을 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="cdeea51a30e773755896b273b1df58c42cfa78ae" translate="yes" xml:space="preserve">
          <source>Whenever an item is removed from the above view, all items beneath it are displaced, causing them to move upwards (or sideways, if horizontally orientated) within the view. As this displacement occurs, the items' movement to their new x,y positions within the view will be animated by a &lt;a href=&quot;qml-qtquick-numberanimation&quot;&gt;NumberAnimation&lt;/a&gt; over one second, as specified. This transition is not applied to the item that has actually been removed from the view; to animate the removed items, set the &lt;a href=&quot;qml-qtquick-listview#remove-signal&quot;&gt;remove&lt;/a&gt; property.</source>
          <target state="translated">위의보기에서 항목을 제거 할 때마다 그 아래에있는 모든 항목이 이동하여보기 내에서 위쪽 (또는 가로 방향 인 경우 옆으로) 이동합니다. 이 변위가 발생하면 뷰 내에서 새로운 x, y 위치로의 항목 이동 은 지정된대로 1 초 동안 &lt;a href=&quot;qml-qtquick-numberanimation&quot;&gt;NumberAnimation&lt;/a&gt; 에 의해 애니메이션됩니다 . 이 전환은 실제로보기에서 제거 된 항목에는 적용되지 않습니다. 제거 된 항목에 애니메이션을 적용하려면 &lt;a href=&quot;qml-qtquick-listview#remove-signal&quot;&gt;remove&lt;/a&gt; 속성을 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="67676ecbc12193a248e3d1903f192afb7d8ef887" translate="yes" xml:space="preserve">
          <source>Whenever an item is removed from the above view, the item will be animated to the position (100,100) over one second, and in parallel will also change its opacity to 0. The transition only applies to the items that are removed from the view; it does not apply to the items below them that are displaced by the removal of the items. To animate the displaced items, set the &lt;a href=&quot;qml-qtquick-gridview#displaced-prop&quot;&gt;displaced&lt;/a&gt; or &lt;a href=&quot;qml-qtquick-gridview#removeDisplaced-prop&quot;&gt;removeDisplaced&lt;/a&gt; properties.</source>
          <target state="translated">항목이 위의보기에서 제거 될 때마다 항목은 1 초에 걸쳐 위치 (100,100)로 애니메이션되며 불투명도 0으로 변경됩니다. 전환은보기에서 제거 된 항목에만 적용됩니다. 품목을 제거하여 대체 된 품목은 아래 품목에는 적용되지 않습니다. 실향민 항목을 애니메이션하려면 설정 &lt;a href=&quot;qml-qtquick-gridview#displaced-prop&quot;&gt;난민&lt;/a&gt; 또는 &lt;a href=&quot;qml-qtquick-gridview#removeDisplaced-prop&quot;&gt;removeDisplaced&lt;/a&gt; 속성을.</target>
        </trans-unit>
        <trans-unit id="2afd00d420f68d960660023e82ce1e61cc08329e" translate="yes" xml:space="preserve">
          <source>Whenever an item is removed from the above view, the item will be animated to the position (100,100) over one second, and in parallel will also change its opacity to 0. The transition only applies to the items that are removed from the view; it does not apply to the items below them that are displaced by the removal of the items. To animate the displaced items, set the &lt;a href=&quot;qml-qtquick-listview#displaced-prop&quot;&gt;displaced&lt;/a&gt; or &lt;a href=&quot;qml-qtquick-listview#removeDisplaced-prop&quot;&gt;removeDisplaced&lt;/a&gt; properties.</source>
          <target state="translated">항목이 위의보기에서 제거 될 때마다 항목은 1 초에 걸쳐 위치 (100,100)로 애니메이션되며 불투명도 0으로 변경됩니다. 전환은보기에서 제거 된 항목에만 적용됩니다. 품목을 제거하여 대체 된 품목은 아래 품목에는 적용되지 않습니다. 실향민 항목을 애니메이션하려면 설정 &lt;a href=&quot;qml-qtquick-listview#displaced-prop&quot;&gt;난민&lt;/a&gt; 또는 &lt;a href=&quot;qml-qtquick-listview#removeDisplaced-prop&quot;&gt;removeDisplaced&lt;/a&gt; 속성을.</target>
        </trans-unit>
        <trans-unit id="cfc98cc90a563ec8a39f14335a650018c11cc6a6" translate="yes" xml:space="preserve">
          <source>Whenever an object has a property of type URL (&lt;a href=&quot;qurl&quot;&gt;QUrl&lt;/a&gt;), assigning a string to that property will actually assign an absolute URL - by resolving the string against the URL of the document where the string is used.</source>
          <target state="translated">객체에 URL 유형 ( &lt;a href=&quot;qurl&quot;&gt;QUrl&lt;/a&gt; ) 의 속성이있을 때마다 해당 속성에 문자열을 할당하면 문자열이 사용되는 문서의 URL에 대해 문자열을 확인하여 실제로 절대 URL을 할당합니다.</target>
        </trans-unit>
        <trans-unit id="40cd1e35d67f7694a72feed5daaea2235bf6410d" translate="yes" xml:space="preserve">
          <source>Whenever making decisions regarding memory allocation or performance trade-offs, it is important to keep in mind the impact of CPU-cache performance, operating system paging, and JavaScript engine garbage collection. Potential solutions should be benchmarked carefully in order to ensure that the best one is selected.</source>
          <target state="translated">메모리 할당 또는 성능 균형에 관한 결정을 내릴 때마다 CPU 캐시 성능, 운영 체제 페이징 및 JavaScript 엔진 가비지 수집의 영향을 명심해야합니다. 최상의 솔루션을 선택하려면 잠재적 솔루션을 신중하게 벤치마킹해야합니다.</target>
        </trans-unit>
        <trans-unit id="6a3c3d9411e762b86fd3a5863bcca1bdd7dc8c51" translate="yes" xml:space="preserve">
          <source>Whenever possible, use the</source>
          <target state="translated">가능하면</target>
        </trans-unit>
        <trans-unit id="b69002a47278bca07bf9cc0356566ca80fcfbcc1" translate="yes" xml:space="preserve">
          <source>Whenever re-applying data obtained with QUrl::FullyDecoded into a &lt;a href=&quot;qurl&quot;&gt;QUrl&lt;/a&gt;, care must be taken to use the &lt;a href=&quot;qurl#ParsingMode-enum&quot;&gt;QUrl::DecodedMode&lt;/a&gt; parameter to the setters (like &lt;a href=&quot;qurl#setPath&quot;&gt;setPath&lt;/a&gt;() and &lt;a href=&quot;qurl#setUserName&quot;&gt;setUserName&lt;/a&gt;()). Failure to do so may cause re-interpretation of the percent character ('%') as the beginning of a percent-encoded sequence.</source>
          <target state="translated">QUrl 얻어 재 적용 데이터 :에 FullyDecoded 때마다 &lt;a href=&quot;qurl&quot;&gt;QUrl&lt;/a&gt; 주의는 사용주의해야합니다 &lt;a href=&quot;qurl#ParsingMode-enum&quot;&gt;QUrl :: DecodedMode의&lt;/a&gt; 세터 (등으로 매개 변수를 &lt;a href=&quot;qurl#setPath&quot;&gt;setPath&lt;/a&gt; () 및 &lt;a href=&quot;qurl#setUserName&quot;&gt;setUserName&lt;/a&gt; ()). 그렇지 않으면 퍼센트 인코딩 된 시퀀스의 시작으로 퍼센트 문자 ( '%')가 다시 해석 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7197f3cbde6d24213802f4f813e9afce6114c878" translate="yes" xml:space="preserve">
          <source>Whenever the &lt;a href=&quot;qml-qtquick-gridview#model-prop&quot;&gt;model&lt;/a&gt; performs a move operation to move a particular set of indexes, the items between the source and destination indexes of the move operation are displaced, causing them to move upwards or downwards (or sideways, if horizontally orientated) within the view. As this displacement occurs, the items' movement to their new x,y positions within the view will be animated by a &lt;a href=&quot;qml-qtquick-numberanimation&quot;&gt;NumberAnimation&lt;/a&gt; over one second, as specified. This transition is not applied to the items that are the actual subjects of the move operation; to animate the moved items, set the &lt;a href=&quot;qml-qtquick-gridview#move-prop&quot;&gt;move&lt;/a&gt; property.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-gridview#model-prop&quot;&gt;모델&lt;/a&gt; 이 특정 인덱스 집합을 이동하기 위해 이동 작업을 수행 할 때마다 이동 작업의 소스 및 대상 인덱스 사이의 항목이 이동하여 뷰 내에서 위쪽 또는 아래쪽 (또는 가로 방향 인 경우 옆으로) 이동합니다. 이 변위가 발생하면 뷰 내에서 새로운 x, y 위치로의 항목 이동 은 지정된대로 1 초 동안 &lt;a href=&quot;qml-qtquick-numberanimation&quot;&gt;NumberAnimation&lt;/a&gt; 에 의해 애니메이션됩니다 . 이 전환은 이동 작업의 실제 주제 인 항목에는 적용되지 않습니다. 이동 한 항목에 애니메이션을 적용하려면 &lt;a href=&quot;qml-qtquick-gridview#move-prop&quot;&gt;이동&lt;/a&gt; 속성을 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="4eafa499c61ca66b47ae5a64ffa25154048cdb36" translate="yes" xml:space="preserve">
          <source>Whenever the &lt;a href=&quot;qml-qtquick-gridview#model-prop&quot;&gt;model&lt;/a&gt; performs a move operation to move a particular set of indexes, the respective items in the view will be animated to their new positions in the view over one second. The transition only applies to the items that are the subject of the move operation in the model; it does not apply to items below them that are displaced by the move operation. To animate the displaced items, set the &lt;a href=&quot;qml-qtquick-gridview#displaced-prop&quot;&gt;displaced&lt;/a&gt; or &lt;a href=&quot;qml-qtquick-gridview#moveDisplaced-prop&quot;&gt;moveDisplaced&lt;/a&gt; properties.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-gridview#model-prop&quot;&gt;모델&lt;/a&gt; 이 특정 인덱스 집합을 이동하기 위해 이동 작업을 수행 할 때마다 뷰의 각 항목이 1 초 동안 뷰의 새로운 위치로 애니메이션됩니다. 전환은 모델에서 이동 작업의 대상이되는 항목에만 적용됩니다. 이동 조작으로 인해 변위 된 항목 아래에는 적용되지 않습니다. 변위 된 항목에 애니메이션을 적용하려면 &lt;a href=&quot;qml-qtquick-gridview#displaced-prop&quot;&gt;변위&lt;/a&gt; 또는 &lt;a href=&quot;qml-qtquick-gridview#moveDisplaced-prop&quot;&gt;moveDisplaced&lt;/a&gt; 속성을 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="c1337f1735bc8b49ad5d3a854d08f4521666286f" translate="yes" xml:space="preserve">
          <source>Whenever the &lt;a href=&quot;qml-qtquick-listview#model-prop&quot;&gt;model&lt;/a&gt; performs a move operation to move a particular set of indexes, the items between the source and destination indexes of the move operation are displaced, causing them to move upwards or downwards (or sideways, if horizontally orientated) within the view. As this displacement occurs, the items' movement to their new x,y positions within the view will be animated by a &lt;a href=&quot;qml-qtquick-numberanimation&quot;&gt;NumberAnimation&lt;/a&gt; over one second, as specified. This transition is not applied to the items that are the actual subjects of the move operation; to animate the moved items, set the &lt;a href=&quot;qml-qtquick-listview#move-prop&quot;&gt;move&lt;/a&gt; property.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-listview#model-prop&quot;&gt;모델&lt;/a&gt; 이 특정 인덱스 집합을 이동하기 위해 이동 작업을 수행 할 때마다 이동 작업의 소스 및 대상 인덱스 사이의 항목이 이동하여 뷰 내에서 위쪽 또는 아래쪽 (또는 가로 방향 인 경우 옆으로) 이동합니다. 이 변위가 발생하면 뷰 내에서 새로운 x, y 위치로의 항목 이동 은 지정된대로 1 초 동안 &lt;a href=&quot;qml-qtquick-numberanimation&quot;&gt;NumberAnimation&lt;/a&gt; 에 의해 애니메이션됩니다 . 이 전환은 이동 작업의 실제 주제 인 항목에는 적용되지 않습니다. 이동 한 항목에 애니메이션을 적용하려면 &lt;a href=&quot;qml-qtquick-listview#move-prop&quot;&gt;이동&lt;/a&gt; 속성을 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="ae168b2b3b3e8491daed829e8981a3546f712af4" translate="yes" xml:space="preserve">
          <source>Whenever the &lt;a href=&quot;qml-qtquick-listview#model-prop&quot;&gt;model&lt;/a&gt; performs a move operation to move a particular set of indexes, the respective items in the view will be animated to their new positions in the view over one second. The transition only applies to the items that are the subject of the move operation in the model; it does not apply to items below them that are displaced by the move operation. To animate the displaced items, set the &lt;a href=&quot;qml-qtquick-listview#displaced-prop&quot;&gt;displaced&lt;/a&gt; or &lt;a href=&quot;qml-qtquick-listview#moveDisplaced-prop&quot;&gt;moveDisplaced&lt;/a&gt; properties.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-listview#model-prop&quot;&gt;모델&lt;/a&gt; 이 특정 인덱스 집합을 이동하기 위해 이동 작업을 수행 할 때마다 뷰의 각 항목이 1 초 동안 뷰의 새로운 위치로 애니메이션됩니다. 전환은 모델에서 이동 작업의 대상이되는 항목에만 적용됩니다. 이동 조작으로 인해 변위 된 항목 아래에는 적용되지 않습니다. 변위 된 항목에 애니메이션을 적용하려면 &lt;a href=&quot;qml-qtquick-listview#displaced-prop&quot;&gt;변위&lt;/a&gt; 또는 &lt;a href=&quot;qml-qtquick-listview#moveDisplaced-prop&quot;&gt;moveDisplaced&lt;/a&gt; 속성을 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="312d51cc1df09e3da5c1a58d9d776f953d5789e4" translate="yes" xml:space="preserve">
          <source>Whenever the &lt;a href=&quot;qml-qtquick-taphandler&quot;&gt;TapHandler&lt;/a&gt;'s &lt;code&gt;tapped&lt;/code&gt; signal is emitted, the &lt;code&gt;send&lt;/code&gt; signal will automatically be emitted as well.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-taphandler&quot;&gt;TapHandler&lt;/a&gt; 의 &lt;code&gt;tapped&lt;/code&gt; 신호가 방출 될 때마다 &lt;code&gt;send&lt;/code&gt; 신호도 자동으로 방출됩니다.</target>
        </trans-unit>
        <trans-unit id="9576aa0bc72ea121c51b19950d20787edffca2bb" translate="yes" xml:space="preserve">
          <source>Whenever the current widget in the layout changes or a widget is removed from the layout, the &lt;a href=&quot;qstackedlayout#currentChanged&quot;&gt;currentChanged&lt;/a&gt;() and &lt;a href=&quot;qstackedlayout#widgetRemoved&quot;&gt;widgetRemoved&lt;/a&gt;() signals are emitted respectively.</source>
          <target state="translated">레이아웃의 현재 위젯이 변경되거나 위젯이 레이아웃에서 제거 될 때마다 &lt;a href=&quot;qstackedlayout#currentChanged&quot;&gt;currentChanged&lt;/a&gt; () 및 &lt;a href=&quot;qstackedlayout#widgetRemoved&quot;&gt;widgetRemoved&lt;/a&gt; () 신호가 각각 방출됩니다.</target>
        </trans-unit>
        <trans-unit id="2fcf7292f793de5fb0c3b7f25d1338a1fbc959c5" translate="yes" xml:space="preserve">
          <source>Whenever the current widget in the stacked widget changes or a widget is removed from the stacked widget, the &lt;a href=&quot;qstackedwidget#currentChanged&quot;&gt;currentChanged&lt;/a&gt;() and &lt;a href=&quot;qstackedwidget#widgetRemoved&quot;&gt;widgetRemoved&lt;/a&gt;() signals are emitted respectively.</source>
          <target state="translated">스택 위젯의 현재 위젯이 변경되거나 위젯이 스택 위젯에서 제거 될 때마다 &lt;a href=&quot;qstackedwidget#currentChanged&quot;&gt;currentChanged&lt;/a&gt; () 및 &lt;a href=&quot;qstackedwidget#widgetRemoved&quot;&gt;widgetRemoved&lt;/a&gt; () 신호가 각각 방출됩니다.</target>
        </trans-unit>
        <trans-unit id="1c80e7b5c4fae4e99cfb0927909f6c46e4768a09" translate="yes" xml:space="preserve">
          <source>Whenever the height of the parent rectangle changes, the height of the blue rectangle automatically updates to be of the same value.</source>
          <target state="translated">부모 사각형의 높이가 변경 될 때마다 파란색 사각형의 높이가 동일한 값으로 자동 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="6af29bff3595f2471deb90ce61a0ea67813b87c4" translate="yes" xml:space="preserve">
          <source>Whenever the stack returns to this state through the use of undo/redo commands, it emits the signal &lt;a href=&quot;qundostack#cleanChanged&quot;&gt;cleanChanged&lt;/a&gt;(). This signal is also emitted when the stack leaves the clean state.</source>
          <target state="translated">실행 취소 / 다시 실행 명령을 사용하여 스택이이 상태로 돌아올 때마다 &lt;a href=&quot;qundostack#cleanChanged&quot;&gt;cleanChanged&lt;/a&gt; () 신호가 발생합니다 . 이 신호는 스택이 클린 상태를 벗어날 때도 방출됩니다.</target>
        </trans-unit>
        <trans-unit id="1e1b23a9100f3611f6cf8c3c148eab441d5bca9d" translate="yes" xml:space="preserve">
          <source>Where &quot;example&quot; is the identifier to use to uniquely identify this set of tests. Finally, add &lt;code&gt;CONFIG += qmltestcase&lt;/code&gt; to the project file:</source>
          <target state="translated">여기서 &quot;example&quot;은이 테스트 집합을 고유하게 식별하는 데 사용되는 식별자입니다. 마지막으로, &lt;code&gt;CONFIG += qmltestcase&lt;/code&gt; 를 프로젝트 파일에 추가 하십시오 :</target>
        </trans-unit>
        <trans-unit id="9e105a40b89e83cd14ee624f6364465c2e91af73" translate="yes" xml:space="preserve">
          <source>Where &amp;lt;arch&amp;gt; can take a value of: &lt;code&gt;arm&lt;/code&gt;, &lt;code&gt;arm64&lt;/code&gt;, &lt;code&gt;x86&lt;/code&gt;, &lt;code&gt;x86_64&lt;/code&gt;.</source>
          <target state="translated">여기서 &amp;lt;arch&amp;gt;는 &lt;code&gt;arm&lt;/code&gt; , &lt;code&gt;arm64&lt;/code&gt; , &lt;code&gt;x86&lt;/code&gt; , &lt;code&gt;x86_64&lt;/code&gt; 값을 가질 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4e60e5656f07f947fa3b6795e9084ca0fb310950" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;&amp;lt;port_number&amp;gt;&lt;/code&gt; refers to a local network port. The web developer tools can then be accessed by launching a browser at the address &lt;code&gt;http://localhost:&amp;lt;port_number&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">여기서 &lt;code&gt;&amp;lt;port_number&amp;gt;&lt;/code&gt; 는 로컬 네트워크 포트를 나타냅니다. 그런 다음 &lt;code&gt;http://localhost:&amp;lt;port_number&amp;gt;&lt;/code&gt; 주소에서 브라우저를 시작하여 웹 개발자 도구에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1ccb20ef56eb59f145da42f8c73e2d50a4d5c84e" translate="yes" xml:space="preserve">
          <source>Where Java and C++ are</source>
          <target state="translated">Java와 C ++가있는 곳</target>
        </trans-unit>
        <trans-unit id="5fe26829762535c4f6607cb6eff88448d6a0cf28" translate="yes" xml:space="preserve">
          <source>Where To Go From Here</source>
          <target state="translated">여기에서 갈 곳</target>
        </trans-unit>
        <trans-unit id="a4126a2b85566e3cc6be9c07a1704ba767059ac6" translate="yes" xml:space="preserve">
          <source>Where a traditional 2D API, such as &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt;, Cairo or &lt;a href=&quot;qml-qtquick-context2d&quot;&gt;Context2D&lt;/a&gt;, is written to handle thousands of individual draw calls per frame, OpenGL is a pure hardware API and performs best when the number of draw calls is very low and state changes are kept to a minimum. Consider the following use case:</source>
          <target state="translated">&lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; , Cairo 또는 &lt;a href=&quot;qml-qtquick-context2d&quot;&gt;Context2D&lt;/a&gt; 와 같은 전통적인 2D API 가 프레임 당 수천 개의 개별 그리기 호출을 처리하도록 작성된 경우 OpenGL은 순수한 하드웨어 API이며 그리기 호출 수가 매우 적고 상태 변경이 유지 될 때 가장 잘 수행됩니다. 최소한. 다음 사용 사례를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="bd67edc7c5b1892b7a13306768dc165ddac00d26" translate="yes" xml:space="preserve">
          <source>Where applicable (Vulkan, Direct3D), enables the graphics API implementation's debug and/or validation layers, if available.</source>
          <target state="translated">해당하는 경우 (Vulkan, Direct3D), 그래픽 API 구현의 디버그 및 / 또는 유효성 검사 계층 (사용 가능한 경우)을 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="c0801f30b2ef37ca11d8e39aebcc01052b29ae10" translate="yes" xml:space="preserve">
          <source>Where possible, use programmatic means, such as verifying properties of objects and variables, instead of capturing and comparing bitmaps.</source>
          <target state="translated">가능하면 비트 맵을 캡처하고 비교하는 대신 개체 및 변수의 속성을 확인하는 것과 같은 프로그래밍 방식을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="d1c4c915ffa0d273da9dcbd143eb982e3969434e" translate="yes" xml:space="preserve">
          <source>Where rotation around an axis is used, the rotation shall be expressed as a Right Hand rotation.</source>
          <target state="translated">축을 중심으로 한 회전이 사용되는 경우 회전은 오른손 회전으로 표현됩니다.</target>
        </trans-unit>
        <trans-unit id="952ee39a9cfff990fc53dd4027e5610fab89057e" translate="yes" xml:space="preserve">
          <source>Where the &lt;a href=&quot;qsgmaterial&quot;&gt;QSGMaterial&lt;/a&gt; and &lt;a href=&quot;qsgmaterialshader&quot;&gt;QSGMaterialShader&lt;/a&gt; API requires a bit of boilerplate code to create a functioning material, the &lt;a href=&quot;qsgsimplematerialshader&quot;&gt;QSGSimpleMaterialShader&lt;/a&gt; tries to hide some of this through the use of templates.</source>
          <target state="translated">를 Where &lt;a href=&quot;qsgmaterial&quot;&gt;QSGMaterial&lt;/a&gt; 및 &lt;a href=&quot;qsgmaterialshader&quot;&gt;QSGMaterialShader&lt;/a&gt; API가 작동하는 자료를 작성하는 상용구 코드의 비트가 필요의 &lt;a href=&quot;qsgsimplematerialshader&quot;&gt;QSGSimpleMaterialShader는&lt;/a&gt; 템플릿의 사용을 통해이 중 일부를 숨길려고합니다.</target>
        </trans-unit>
        <trans-unit id="8fdf085fc05f049a1769f3683bf038d0dfa4f7f4" translate="yes" xml:space="preserve">
          <source>Where the &lt;a href=&quot;qsgmaterial&quot;&gt;QSGMaterial&lt;/a&gt; and &lt;a href=&quot;qsgmaterialshader&quot;&gt;QSGMaterialShader&lt;/a&gt; API requires a bit of boilerplate code to create a functioning material, the QSGSimpleMaterialShader tries to hide some of this through the use of templates.</source>
          <target state="translated">를 Where &lt;a href=&quot;qsgmaterial&quot;&gt;QSGMaterial&lt;/a&gt; 및 &lt;a href=&quot;qsgmaterialshader&quot;&gt;QSGMaterialShader&lt;/a&gt; API가 작동하는 자료를 작성하는 상용구 코드의 비트가 필요의 QSGSimpleMaterialShader 템플릿의 사용을 통해이 중 일부를 숨길려고합니다.</target>
        </trans-unit>
        <trans-unit id="ff4b3d1492ec67a940dc896fa1d87c9ba99f2fdd" translate="yes" xml:space="preserve">
          <source>Where the time zone display names have changed over time then the most recent names will be used.</source>
          <target state="translated">시간대 표시 이름이 시간이 지남에 따라 변경된 경우 가장 최근의 이름이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b8883f0096050f1e4dd29bf9f7b6190b35e33b6d" translate="yes" xml:space="preserve">
          <source>Where to Go from Here</source>
          <target state="translated">여기서 갈 곳</target>
        </trans-unit>
        <trans-unit id="ca2aed1ce9ee9fb4480d35e3c0166d266a031dfb" translate="yes" xml:space="preserve">
          <source>Where will the Qt build be deployed on the device? In the example we will use &lt;code&gt;/usr/local/qt6&lt;/code&gt;.</source>
          <target state="translated">Qt 빌드는 장치에서 어디에 배포됩니까? 이 예에서는 &lt;code&gt;/usr/local/qt6&lt;/code&gt; 을 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="20ff5fb97d054b614eee2ba69d3d9ff5254b0b75" translate="yes" xml:space="preserve">
          <source>Where will the Qt build be installed on the local system once the build completes? In the example we will use &lt;code&gt;$HOME/qt6-rpi&lt;/code&gt;.</source>
          <target state="translated">빌드가 완료되면 로컬 시스템에서 Qt 빌드가 어디에 설치됩니까? 이 예에서는 &lt;code&gt;$HOME/qt6-rpi&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="52d06efbef6698a9090cd765a2d437e704a1a5e2" translate="yes" xml:space="preserve">
          <source>Where with &lt;a href=&quot;qdbusreply&quot;&gt;QDBusReply&lt;/a&gt; you would write:</source>
          <target state="translated">&lt;a href=&quot;qdbusreply&quot;&gt;QDBusReply로&lt;/a&gt; 다음 과 같이 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="7e741bc3dcef0123eeda11543758853be2aac149" translate="yes" xml:space="preserve">
          <source>Where:</source>
          <target state="translated">Where:</target>
        </trans-unit>
        <trans-unit id="f4092a9df66ba8f2af73c5f2492f8269ffdc70eb" translate="yes" xml:space="preserve">
          <source>Whereas a &lt;a href=&quot;qml-qt3d-animation-clipanimator&quot;&gt;ClipAnimator&lt;/a&gt; gets its animation data from a single animation clip, &lt;a href=&quot;qml-qt3d-animation-blendedclipanimator&quot;&gt;BlendedClipAnimator&lt;/a&gt; can blend together multiple clips. The animation data is obtained by evaluating a so called</source>
          <target state="translated">반면 &lt;a href=&quot;qml-qt3d-animation-clipanimator&quot;&gt;ClipAnimator이&lt;/a&gt; 하나의 애니메이션 클립에서의 애니메이션 데이터를 가져, &lt;a href=&quot;qml-qt3d-animation-blendedclipanimator&quot;&gt;BlendedClipAnimator는&lt;/a&gt; 함께 여러 클립을 혼합 할 수 있습니다. 애니메이션 데이터는 소위</target>
        </trans-unit>
        <trans-unit id="129aad2c02bf5a9a4dd80cc4832a2669b5535e5f" translate="yes" xml:space="preserve">
          <source>Whereas a &lt;a href=&quot;qml-qt3d-animation-clipanimator&quot;&gt;ClipAnimator&lt;/a&gt; gets its animation data from a single animation clip, BlendedClipAnimator can blend together multiple clips. The animation data is obtained by evaluating a so called</source>
          <target state="translated">&lt;a href=&quot;qml-qt3d-animation-clipanimator&quot;&gt;ClipAnimator&lt;/a&gt; 는 단일 애니메이션 클립에서 애니메이션 데이터를 가져 오는 반면 BlendedClipAnimator 는 여러 클립을 혼합 할 수 있습니다. 애니메이션 데이터는 소위</target>
        </trans-unit>
        <trans-unit id="804bb2445f1402ea00ca4b54f378df57627e0205" translate="yes" xml:space="preserve">
          <source>Whereas a &lt;a href=&quot;qt3danimation-qclipanimator&quot;&gt;QClipAnimator&lt;/a&gt; gets its animation data from a single animation clip, &lt;a href=&quot;qt3danimation-qblendedclipanimator&quot;&gt;QBlendedClipAnimator&lt;/a&gt; can blend together multiple clips. The animation data is obtained by evaluating a so called</source>
          <target state="translated">반면 &lt;a href=&quot;qt3danimation-qclipanimator&quot;&gt;QClipAnimator이&lt;/a&gt; 하나의 애니메이션 클립에서의 애니메이션 데이터를 가져, &lt;a href=&quot;qt3danimation-qblendedclipanimator&quot;&gt;QBlendedClipAnimator는&lt;/a&gt; 함께 여러 클립을 혼합 할 수 있습니다. 애니메이션 데이터는 소위</target>
        </trans-unit>
        <trans-unit id="846f3e0882dcf22331fd8436d7896ee93de9c4e3" translate="yes" xml:space="preserve">
          <source>Whereas a &lt;a href=&quot;qt3danimation-qclipanimator&quot;&gt;QClipAnimator&lt;/a&gt; gets its animation data from a single animation clip, QBlendedClipAnimator can blend together multiple clips. The animation data is obtained by evaluating a so called</source>
          <target state="translated">&lt;a href=&quot;qt3danimation-qclipanimator&quot;&gt;QClipAnimator&lt;/a&gt; 는 단일 애니메이션 클립에서 애니메이션 데이터를 가져 오는 반면, QBlendedClipAnimator 는 여러 클립을 함께 블렌딩 할 수 있습니다. 애니메이션 데이터는 소위</target>
        </trans-unit>
        <trans-unit id="9e1667965fb72ff02c0f89f70ccdb72aa593f105" translate="yes" xml:space="preserve">
          <source>Whereas a traditional 2D API, such as &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt;, Cairo or &lt;a href=&quot;qml-qtquick-context2d&quot;&gt;Context2D&lt;/a&gt;, is written to handle thousands of individual draw calls per frame, OpenGL and other hardware accelerated APIs perform best when the number of draw calls is very low and state changes are kept to a minimum.</source>
          <target state="translated">&lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; , Cairo 또는 &lt;a href=&quot;qml-qtquick-context2d&quot;&gt;Context2D&lt;/a&gt; 와 같은 기존 2D API 는 프레임 당 수천 개의 개별 그리기 호출을 처리하도록 작성된 반면 , OpenGL 및 기타 하드웨어 가속 API는 그리기 호출 수가 매우 적고 상태 변경이 최저한의.</target>
        </trans-unit>
        <trans-unit id="df6677fe4ed41b6de2a02f43a28dc5ef92063aba" translate="yes" xml:space="preserve">
          <source>Wherever your program uses a string literal (quoted text) that will be presented to the user, ensure that it is processed by the &lt;a href=&quot;qcoreapplication#translate&quot;&gt;QCoreApplication::translate&lt;/a&gt;() function. Essentially all that is necessary to achieve this is to use the &lt;a href=&quot;qobject#tr&quot;&gt;tr()&lt;/a&gt; function to obtain translated text for your classes, typically for display purposes. This function is also used to indicate which text strings in an application are translatable.</source>
          <target state="translated">프로그램이 사용자에게 표시 될 문자열 리터럴 (인용 된 텍스트)을 사용하는 경우 &lt;a href=&quot;qcoreapplication#translate&quot;&gt;QCoreApplication :: translate&lt;/a&gt; () 함수로 처리되는지 확인하십시오 . 본질적으로 이것을 달성하기 위해 필요한 것은 &lt;a href=&quot;qobject#tr&quot;&gt;tr ()&lt;/a&gt; 함수를 사용하여 일반적으로 표시 목적으로 클래스에 대한 번역 된 텍스트를 얻는 것입니다. 이 함수는 응용 프로그램에서 어떤 텍스트 문자열을 번역 할 수 있는지 나타내는 데에도 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9a2b119e0e1b94041afad99d2082aedabe60692d" translate="yes" xml:space="preserve">
          <source>Whether &lt;a href=&quot;qtreeview&quot;&gt;QTreeView&lt;/a&gt; paints alternating row colors for the area that does not have any items.</source>
          <target state="translated">&lt;a href=&quot;qtreeview&quot;&gt;QTreeView&lt;/a&gt; 가 항목이없는 영역의 행 색상을 번갈아 페인트 하는지 여부 입니다.</target>
        </trans-unit>
        <trans-unit id="7479afd99480f623a47cad8dc7dc8c35d62ddf02" translate="yes" xml:space="preserve">
          <source>Whether a tab bar should suggest a size to prevent scoll arrows.</source>
          <target state="translated">탭 막대가 스캘 화살표를 방지하기위한 크기를 제안해야하는지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="27d2672fc5a7413ecd5e7f19492a53aff397d05c" translate="yes" xml:space="preserve">
          <source>Whether and how the background image is repeated to fill the &lt;code&gt;background-origin&lt;/code&gt; rectangle.</source>
          <target state="translated">&lt;code&gt;background-origin&lt;/code&gt; 사각형 으로 채워지도록 배경 이미지가 반복되는지 여부와 방법 .</target>
        </trans-unit>
        <trans-unit id="f522af9862a1abe54c91f2811e719d24e11b59a8" translate="yes" xml:space="preserve">
          <source>Whether anything will be available for reading from the returned object is protocol dependent. For HTTP, the server may send a small HTML page indicating the upload was successful (or not). Other protocols will probably have content in their replies.</source>
          <target state="translated">반환 된 객체에서 읽을 수있는 항목이 있는지 여부는 프로토콜에 따라 다릅니다. HTTP의 경우, 서버는 업로드 성공 또는 실패를 나타내는 작은 HTML 페이지를 보낼 수 있습니다. 다른 프로토콜은 아마도 답글에 내용이있을 것입니다.</target>
        </trans-unit>
        <trans-unit id="a6fc5303526351baac559d5b0c024e2b8b1e467d" translate="yes" xml:space="preserve">
          <source>Whether clipping is enabled or not is dirty and needs to be updated.</source>
          <target state="translated">클리핑 활성화 여부는 더티이므로 업데이트해야합니다.</target>
        </trans-unit>
        <trans-unit id="891d6c71b96dc92f38e7de49fa32354e43d7aa65" translate="yes" xml:space="preserve">
          <source>Whether cursor should blink when text is selected.</source>
          <target state="translated">텍스트를 선택할 때 커서가 깜박 여야하는지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="f536d64fe87af77f3302f5448b26e34a3608e7e7" translate="yes" xml:space="preserve">
          <source>Whether it's a 32- or 64-bit application. Possible values are: &quot;llp64&quot; (Windows 64-bit), &quot;lp64&quot; (Unix 64-bit), &quot;ilp32&quot; (32-bit)</source>
          <target state="translated">32 비트 또는 64 비트 응용 프로그램인지 여부 가능한 값은 &quot;llp64&quot;(Windows 64 비트), &quot;lp64&quot;(Unix 64 비트), &quot;ilp32&quot;(32 비트)입니다.</target>
        </trans-unit>
        <trans-unit id="88159a3d977ef502f02f2a123d6990749dcb7c82" translate="yes" xml:space="preserve">
          <source>Whether more than one filename can be selected.</source>
          <target state="translated">둘 이상의 파일 이름을 선택할 수 있는지 여부</target>
        </trans-unit>
        <trans-unit id="351fd14608eef6c08e17ef09a05f49229c55a5dc" translate="yes" xml:space="preserve">
          <source>Whether numbers are localized.</source>
          <target state="translated">숫자가 현지화되어 있는지 여부</target>
        </trans-unit>
        <trans-unit id="fdd3579e60a02aac738192bea12695a023ba77d5" translate="yes" xml:space="preserve">
          <source>Whether offsets specified using &lt;a href=&quot;#left-prop&quot;&gt;left&lt;/a&gt;, &lt;a href=&quot;#right-prop&quot;&gt;right&lt;/a&gt;, &lt;a href=&quot;#top-prop&quot;&gt;top&lt;/a&gt;, and &lt;a href=&quot;#bottom-prop&quot;&gt;bottom&lt;/a&gt; are relative or absolute coordinates.</source>
          <target state="translated">&lt;a href=&quot;#left-prop&quot;&gt;left&lt;/a&gt; , &lt;a href=&quot;#right-prop&quot;&gt;right&lt;/a&gt; , &lt;a href=&quot;#top-prop&quot;&gt;top&lt;/a&gt; 및 &lt;a href=&quot;#bottom-prop&quot;&gt;bottom을&lt;/a&gt; 사용하여 지정된 오프셋 이 상대 또는 절대 좌표인지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="3af21ab04403fdec385f370eafd737a810bb7461" translate="yes" xml:space="preserve">
          <source>Whether offsets specified using &lt;a href=&quot;stylesheet-reference#left-prop&quot;&gt;left&lt;/a&gt;, &lt;a href=&quot;stylesheet-reference#right-prop&quot;&gt;right&lt;/a&gt;, &lt;a href=&quot;stylesheet-reference#top-prop&quot;&gt;top&lt;/a&gt;, and &lt;a href=&quot;stylesheet-reference#bottom-prop&quot;&gt;bottom&lt;/a&gt; are relative or absolute coordinates.</source>
          <target state="translated">&lt;a href=&quot;stylesheet-reference#left-prop&quot;&gt;left&lt;/a&gt; , &lt;a href=&quot;stylesheet-reference#right-prop&quot;&gt;right&lt;/a&gt; , &lt;a href=&quot;stylesheet-reference#top-prop&quot;&gt;top&lt;/a&gt; 및 &lt;a href=&quot;stylesheet-reference#bottom-prop&quot;&gt;bottom을&lt;/a&gt; 사용하여 지정된 오프셋 이 상대 좌표인지 절대 좌표인지 여부.</target>
        </trans-unit>
        <trans-unit id="615c9e373bf582bda486791fb038c25503b09240" translate="yes" xml:space="preserve">
          <source>Whether only existing files or directories can be selected.</source>
          <target state="translated">기존 파일 또는 디렉토리 만 선택할 수 있는지 여부</target>
        </trans-unit>
        <trans-unit id="0fc0e926e626973c36cb23fef10be34740429705" translate="yes" xml:space="preserve">
          <source>Whether or not a scroll bar has a context menu.</source>
          <target state="translated">스크롤 바에 컨텍스트 메뉴가 있는지 여부</target>
        </trans-unit>
        <trans-unit id="e975490d1d1d8e036dbd88951f98d62fa4a9e421" translate="yes" xml:space="preserve">
          <source>Whether or not an &lt;a href=&quot;qml-qtquick-item&quot;&gt;Item&lt;/a&gt; has active focus can be queried through the &lt;code&gt;Item::activeFocus&lt;/code&gt; property. For example, here we have a &lt;a href=&quot;qml-qtquick-text&quot;&gt;Text&lt;/a&gt; type whose text is determined by whether or not it has active focus.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-item&quot;&gt;Item&lt;/a&gt; 에 활성 포커스가 있는지 여부 는 &lt;code&gt;Item::activeFocus&lt;/code&gt; 속성을 통해 쿼리 할 수 ​​있습니다 . 예를 들어, 여기에는 &lt;a href=&quot;qml-qtquick-text&quot;&gt;텍스트&lt;/a&gt; 가 활성 포커스의 유무에 따라 결정되는 텍스트 유형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ef85e6b7ba3ab7e4c00b4ec7423e9327a00a361" translate="yes" xml:space="preserve">
          <source>Whether or not end points are drawn when the pen width is 0 or 1 depends on the cap style. Using &lt;a href=&quot;qt#PenCapStyle-enum&quot;&gt;Qt::SquareCap&lt;/a&gt; or &lt;a href=&quot;qt#PenCapStyle-enum&quot;&gt;Qt::RoundCap&lt;/a&gt; they are drawn, using &lt;a href=&quot;qt#PenCapStyle-enum&quot;&gt;Qt::FlatCap&lt;/a&gt; they are not drawn.</source>
          <target state="translated">펜 너비가 0 또는 1 일 때 끝점을 그릴 지 여부는 캡 스타일에 따라 다릅니다. 사용 &lt;a href=&quot;qt#PenCapStyle-enum&quot;&gt;Qt는 :: SquareCap&lt;/a&gt; 또는 &lt;a href=&quot;qt#PenCapStyle-enum&quot;&gt;Qt는 :: RoundCap을&lt;/a&gt; 그들이 사용하여 그려 &lt;a href=&quot;qt#PenCapStyle-enum&quot;&gt;Qt는 :: FlatCap을&lt;/a&gt; 그들이 그려되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0fdef606fa391f439f4e94770a38e210051c3a1a" translate="yes" xml:space="preserve">
          <source>Whether or not the cache should be in-memory only. Valid values are &lt;b&gt;true&lt;/b&gt; and &lt;b&gt;false&lt;/b&gt;. The default value is &lt;b&gt;false&lt;/b&gt;. When set to &lt;b&gt;true&lt;/b&gt;, the disk cache is never created. The ambient cache will work in-memory, but the offline database cannot be used with this option enabled.</source>
          <target state="translated">캐시가 인 메모리 전용이어야하는지 여부입니다. 유효한 값은 &lt;b&gt;true&lt;/b&gt; 및 &lt;b&gt;false&lt;/b&gt; 입니다. 기본값은 &lt;b&gt;false&lt;/b&gt; 입니다. &lt;b&gt;true로&lt;/b&gt; 설정 하면 디스크 캐시가 작성되지 않습니다. 주변 캐시는 메모리 내에서 작동하지만이 옵션을 활성화하면 오프라인 데이터베이스를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e4800f01cf3f03c22bd30261d92d64c5bd92d1e7" translate="yes" xml:space="preserve">
          <source>Whether or not to request high dpi tiles. Valid values are &lt;b&gt;true&lt;/b&gt; and &lt;b&gt;false&lt;/b&gt;. The default value is &lt;b&gt;false&lt;/b&gt;.</source>
          <target state="translated">높은 dpi 타일을 요청할지 여부입니다. 유효한 값은 &lt;b&gt;true&lt;/b&gt; 및 &lt;b&gt;false&lt;/b&gt; 입니다. 기본값은 &lt;b&gt;false&lt;/b&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="fa6c99ad4b900578d7248fa09d22485bed6fda3e" translate="yes" xml:space="preserve">
          <source>Whether or not to request high dpi tiles. Valid values are &lt;b&gt;true&lt;/b&gt; and &lt;b&gt;false&lt;/b&gt;. The default value is &lt;b&gt;false&lt;/b&gt;. Please note that not all map types are available in high dpi. Setting this parameter to true might even have no effect if no map type is available in high dpi at the moment. Provider information files for high dpi tiles are named &lt;code&gt;street-hires&lt;/code&gt;, &lt;code&gt;satellite-hires&lt;/code&gt;, &lt;code&gt;cycle-hires&lt;/code&gt;, &lt;code&gt;transit-hires&lt;/code&gt;, &lt;code&gt;night-transit-hires&lt;/code&gt;, &lt;code&gt;terrain-hires&lt;/code&gt; and &lt;code&gt;hiking-hires&lt;/code&gt;. These are fetched from the same location used for the low dpi counterparts.</source>
          <target state="translated">높은 dpi 타일을 요청할지 여부입니다. 유효한 값은 &lt;b&gt;true&lt;/b&gt; 및 &lt;b&gt;false&lt;/b&gt; 입니다. 기본값은 &lt;b&gt;false&lt;/b&gt; 입니다. 모든지도 유형이 dpi가 높은 것은 아닙니다. 현재 높은 dpi에서지도 유형을 사용할 수없는 경우이 매개 변수를 true로 설정해도 효과가 없습니다. 고 dpi 타일에 대한 공급자 정보 파일의 이름은 &lt;code&gt;street-hires&lt;/code&gt; , &lt;code&gt;satellite-hires&lt;/code&gt; , &lt;code&gt;cycle-hires&lt;/code&gt; , &lt;code&gt;transit-hires&lt;/code&gt; , &lt;code&gt;night-transit-hires&lt;/code&gt; , &lt;code&gt;terrain-hires&lt;/code&gt; 및 &lt;code&gt;hiking-hires&lt;/code&gt; 입니다. 낮은 dpi 대응 물에 사용 된 것과 동일한 위치에서 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="1f50d751bdd0ca1e8cc3139cd93bda59afb6866e" translate="yes" xml:space="preserve">
          <source>Whether or not to reverse the direction of property change if QQuickPointerScrollEvent::inverted is true. The default is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">QQuickPointerScrollEvent :: inverted가 true 인 경우 속성 변경 방향을 반전할지 여부입니다. 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="14ccd186c3ee461482c7326fa36c9623c2a63da2" translate="yes" xml:space="preserve">
          <source>Whether popup menus must support scrolling.</source>
          <target state="translated">팝업 메뉴가 스크롤을 지원해야하는지 여부</target>
        </trans-unit>
        <trans-unit id="c355998709d5a91ea161e2e9efbdc94bd8c86622" translate="yes" xml:space="preserve">
          <source>Whether popup menus must support the user moving the mouse cursor to a submenu while crossing other items of the menu. This is supported on most modern desktop platforms.</source>
          <target state="translated">팝업 메뉴가 사용자가 메뉴의 다른 항목을 넘어 마우스 커서를 하위 메뉴로 이동하도록 지원해야하는지 여부입니다. 이것은 대부분의 최신 데스크탑 플랫폼에서 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="7bfd520185d930289c35d432ad81bff039435224" translate="yes" xml:space="preserve">
          <source>Whether popups should allow the selections to wrap, that is when selection should the next item be the first item.</source>
          <target state="translated">팝업에서 선택 항목을 래핑해야하는지 여부, 즉 다음 선택 항목이 첫 번째 항목이어야합니다.</target>
        </trans-unit>
        <trans-unit id="9a3d16ff05060262b6fe37cd15bdb7b02685468d" translate="yes" xml:space="preserve">
          <source>Whether reverse order is used for the markers in the legend. This property is &lt;code&gt;false&lt;/code&gt; by default.</source>
          <target state="translated">범례의 마커에 역순을 사용할지 여부입니다. 이 속성은 기본적으로 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5ff6b09ef26c0c42bd41a6e8d723830a76216c42" translate="yes" xml:space="preserve">
          <source>Whether richtext selections should extend to the full width of the document.</source>
          <target state="translated">서식있는 텍스트 선택이 문서의 전체 너비로 확장되어야하는지 여부</target>
        </trans-unit>
        <trans-unit id="5d92844548ddcee7f47f82c0d52f0d492b6551db" translate="yes" xml:space="preserve">
          <source>Whether scrolling popups should fill the screen as they are scrolled.</source>
          <target state="translated">스크롤 팝업이 스크롤 될 때 화면을 채워야하는지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="b7e9ec658e8e6fbee4a20e58cb2317e5a2859441" translate="yes" xml:space="preserve">
          <source>Whether scrollviews draw their frame only around contents (like Motif), or around contents, scroll bars and corner widgets (like Windows).</source>
          <target state="translated">스크롤보기가 내용 (예 : Motif) 또는 내용, 스크롤 막대 및 모서리 위젯 (Windows와 같은) 주위에만 프레임을 그릴 지 여부.</target>
        </trans-unit>
        <trans-unit id="008cc77dc296fe4b1f921abb283c4b2c99c1dfbd" translate="yes" xml:space="preserve">
          <source>Whether shortcuts are underlined.</source>
          <target state="translated">바로 가기에 밑줄이 표시되는지 여부</target>
        </trans-unit>
        <trans-unit id="f31f23419bacc3b9dd9493977a9ee560f48b4e25" translate="yes" xml:space="preserve">
          <source>Whether spacing is absolute or relative to bar thickness.</source>
          <target state="translated">간격이 막대 두께에 대해 절대인지 또는 상대적인지 여부</target>
        </trans-unit>
        <trans-unit id="14ccdf486541f6d046b78ebc3c46ca84f28aef3f" translate="yes" xml:space="preserve">
          <source>Whether text entered by the user will overwrite existing text.</source>
          <target state="translated">사용자가 입력 한 텍스트가 기존 텍스트를 덮어 쓸지 여부</target>
        </trans-unit>
        <trans-unit id="44ed9a68ce96302bd93afa75be5a913dc9974e1f" translate="yes" xml:space="preserve">
          <source>Whether the &lt;a href=&quot;qmake-variable-reference#target&quot;&gt;target&lt;/a&gt; should automatically be repositioned in such a way that it is transformed around the mouse cursor position while the &lt;a href=&quot;qml-qtquick-wheelhandler#property-prop&quot;&gt;property&lt;/a&gt; is adjusted. The default is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-wheelhandler#property-prop&quot;&gt;속성&lt;/a&gt; 이 조정 되는 동안 마우스 커서 위치 주변에서 변형되는 방식으로 &lt;a href=&quot;qmake-variable-reference#target&quot;&gt;대상&lt;/a&gt; 이 자동으로 재배치되어야 하는지 여부 입니다. 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="127d2d6dad872f802d502a5787fa664c518d7d37" translate="yes" xml:space="preserve">
          <source>Whether the &lt;a href=&quot;qml-qtquick-textedit&quot;&gt;TextEdit&lt;/a&gt; should gain active focus on a mouse press. By default this is set to true.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-textedit&quot;&gt;TextEdit&lt;/a&gt; 가 마우스 누르기에 초점을 맞출 지 여부 입니다. 기본적으로이 값은 true로 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e664258644cf6fce609f74537c27de9ea32e9ed" translate="yes" xml:space="preserve">
          <source>Whether the &lt;a href=&quot;qml-qtquick-textedit&quot;&gt;TextEdit&lt;/a&gt; should keep the selection visible when it loses active focus to another item in the scene. By default this is set to false.</source>
          <target state="translated">장면의 다른 항목에 대한 활성 초점을 잃을 때 &lt;a href=&quot;qml-qtquick-textedit&quot;&gt;TextEdit&lt;/a&gt; 에서 선택 항목을 표시해야하는지 여부 입니다. 기본적으로이 값은 false로 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="02b30757d1bfc1211e2b3c3bfa3a4b027191d826" translate="yes" xml:space="preserve">
          <source>Whether the &lt;a href=&quot;qml-qtquick-textinput&quot;&gt;TextInput&lt;/a&gt; should gain active focus on a mouse press. By default this is set to true.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-textinput&quot;&gt;TextInput&lt;/a&gt; 이 마우스 누르기에 초점을 맞출 지 여부 입니다. 기본적으로이 값은 true로 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="442e7401e06ac4bd53d35ebfcd0514393c01617d" translate="yes" xml:space="preserve">
          <source>Whether the &lt;a href=&quot;qml-qtquick-textinput&quot;&gt;TextInput&lt;/a&gt; should keep its selection when it loses active focus to another item in the scene. By default this is set to false;</source>
          <target state="translated">장면의 다른 항목에 대한 활성 초점을 잃을 때 &lt;a href=&quot;qml-qtquick-textinput&quot;&gt;TextInput에서&lt;/a&gt; 선택을 유지해야하는지 여부 기본적으로 이것은 false로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="2d56da9754f2d55c0bf314485e7193fadc26d78b" translate="yes" xml:space="preserve">
          <source>Whether the &lt;a href=&quot;qml-qtquick-textinput&quot;&gt;TextInput&lt;/a&gt; should scroll when the text is longer than the width. By default this is set to true.</source>
          <target state="translated">텍스트가 너비보다 길 때 &lt;a href=&quot;qml-qtquick-textinput&quot;&gt;TextInput&lt;/a&gt; 이 스크롤되어야 하는지 여부 입니다. 기본적으로이 값은 true로 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="b84569d2c058a1d40c8935ffb676582eb4339696" translate="yes" xml:space="preserve">
          <source>Whether the &lt;a href=&quot;qtreeview&quot;&gt;QTreeView&lt;/a&gt; paints alternating row colors for the empty area (i.e the area where there are no items)</source>
          <target state="translated">&lt;a href=&quot;qtreeview&quot;&gt;QTreeView&lt;/a&gt; 가 빈 영역 (즉, 항목이없는 영역)의 행 색상을 번갈아 페인트 하는지 여부</target>
        </trans-unit>
        <trans-unit id="15885eff30424361e27c06e3896534c4ffea6121" translate="yes" xml:space="preserve">
          <source>Whether the action is enabled, and can be triggered. Defaults to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">작업이 활성화되어 있고 트리거 될 수 있는지 여부 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3b63603a16b0a875dd05ed6eac90f935bb37e855" translate="yes" xml:space="preserve">
          <source>Whether the affected particles have their existing position/velocity/acceleration added to the new one.</source>
          <target state="translated">영향을받는 입자에 기존 위치 / 속도 / 가속이 새 입자에 추가되었는지 여부</target>
        </trans-unit>
        <trans-unit id="b51f81c2e2c5eb6252b205609801f5564200de49" translate="yes" xml:space="preserve">
          <source>Whether the animation is played backwards after it finishes. This is an easy way to create circular animations.</source>
          <target state="translated">애니메이션이 완료된 후 뒤로 재생되는지 여부입니다. 이것은 원형 애니메이션을 만드는 쉬운 방법입니다.</target>
        </trans-unit>
        <trans-unit id="5999480ac2251870246c63b5ba009ded8d924ae6" translate="yes" xml:space="preserve">
          <source>Whether the background drop shadow effect is enabled.</source>
          <target state="translated">배경 그림자 효과 사용 여부입니다.</target>
        </trans-unit>
        <trans-unit id="8830a5c00be149d6708cd3d5520bd56902a70ed9" translate="yes" xml:space="preserve">
          <source>Whether the button has active focus.</source>
          <target state="translated">버튼에 포커스가 있는지 여부</target>
        </trans-unit>
        <trans-unit id="d39bb8df504512eda2056344d9c178981fb5fc7e" translate="yes" xml:space="preserve">
          <source>Whether the button is hovered.</source>
          <target state="translated">버튼이 호버링되었는지 여부</target>
        </trans-unit>
        <trans-unit id="06019445aa3ae5cd4bf1f60ed6011fccfc4f6ab5" translate="yes" xml:space="preserve">
          <source>Whether the button is pressed.</source>
          <target state="translated">버튼을 눌렀는지 여부</target>
        </trans-unit>
        <trans-unit id="f36941b4851bd2c3920b4ff750fc4cc2ea2af042" translate="yes" xml:space="preserve">
          <source>Whether the buttons in a &lt;a href=&quot;qdialogbuttonbox&quot;&gt;QDialogButtonBox&lt;/a&gt; show icons</source>
          <target state="translated">&lt;a href=&quot;qdialogbuttonbox&quot;&gt;QDialogButtonBox&lt;/a&gt; 의 버튼에 아이콘이 표시 되는지 여부</target>
        </trans-unit>
        <trans-unit id="0445017d5d0d51a6a257d1970e1a509763b6ed2d" translate="yes" xml:space="preserve">
          <source>Whether the certificate is only self-signed.</source>
          <target state="translated">인증서 자체 서명 여부입니다.</target>
        </trans-unit>
        <trans-unit id="63e8eeda8f01dcbef8512ab31c579994488aba62" translate="yes" xml:space="preserve">
          <source>Whether the data points are visible and should be drawn.</source>
          <target state="translated">데이터 포인트가 표시되고 그려 져야하는지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="40b49f5eb966eb2a50a803b79429e9d47ed678fd" translate="yes" xml:space="preserve">
          <source>Whether the database is capable of reporting the size of a query. Note that some databases do not support returning the size (i.e. number of rows returned) of a query, in which case &lt;a href=&quot;qsqlquery#size&quot;&gt;QSqlQuery::size&lt;/a&gt;() will return -1.</source>
          <target state="translated">데이터베이스가 쿼리 크기를보고 할 수 있는지 여부 일부 데이터베이스는 쿼리의 크기 (즉, 반환 된 행 수) 반환을 지원하지 않습니다.이 경우 &lt;a href=&quot;qsqlquery#size&quot;&gt;QSqlQuery :: size&lt;/a&gt; ()는 -1을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="21c37b0f1a2eb0a2c3d7635acf315d721ff4cb14" translate="yes" xml:space="preserve">
          <source>Whether the default or static mode is used for rendering optimization.</source>
          <target state="translated">렌더링 최적화에 기본 모드 또는 정적 모드가 사용되는지 여부</target>
        </trans-unit>
        <trans-unit id="be688207dd50b674f91323550645b69bc6dd0334" translate="yes" xml:space="preserve">
          <source>Whether the delegate represents today</source>
          <target state="translated">대리인이 오늘 대표하는지 여부</target>
        </trans-unit>
        <trans-unit id="3a8755b16bb8d183f894885ca5c5dee9425d78f1" translate="yes" xml:space="preserve">
          <source>Whether the dialog should be shown modal with respect to the window containing the dialog's parent Item, modal with respect to the whole application, or non-modal.</source>
          <target state="translated">대화 상자의 상위 항목을 포함하는 창에 대해 대화 상자를 표시해야하는지, 전체 응용 프로그램에 대해 모달 또는 비 모달을 표시해야하는지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="adf54c46f7d89665f69a6765399db289b890d5de" translate="yes" xml:space="preserve">
          <source>Whether the dialog will provide a means of changing the opacity.</source>
          <target state="translated">대화 상자가 불투명도를 변경하는 수단을 제공하는지 여부</target>
        </trans-unit>
        <trans-unit id="81a0e45f8611929993879c1cfe29a62cf62d6198" translate="yes" xml:space="preserve">
          <source>Whether the dialog will show monospaced fonts or not.</source>
          <target state="translated">대화 상자에 고정 폭 글꼴이 표시되는지 여부</target>
        </trans-unit>
        <trans-unit id="5056ef7166f692cfde907604b07cee9df549b43e" translate="yes" xml:space="preserve">
          <source>Whether the dialog will show non scalable fonts or not.</source>
          <target state="translated">대화 상자에 확장 불가능한 글꼴이 표시되는지 여부</target>
        </trans-unit>
        <trans-unit id="bdc8e11957087489dc414aada8890efc5cf613cc" translate="yes" xml:space="preserve">
          <source>Whether the dialog will show proportional fonts or not.</source>
          <target state="translated">대화 상자에 비례 글꼴이 표시되는지 여부</target>
        </trans-unit>
        <trans-unit id="cf59371c1a2ab75dd88122e67ecd4d968653945f" translate="yes" xml:space="preserve">
          <source>Whether the dialog will show scalable fonts or not.</source>
          <target state="translated">대화 상자에 확장 가능한 글꼴이 표시되는지 여부</target>
        </trans-unit>
        <trans-unit id="a8096a1b98e7942757eb338dc4ac310987e368de" translate="yes" xml:space="preserve">
          <source>Whether the driver allows cancelling a running query.</source>
          <target state="translated">드라이버가 실행중인 쿼리를 취소 할 수 있는지 여부</target>
        </trans-unit>
        <trans-unit id="bad7dffba90736fb616a6a5b7d5ad2c46ea8a969" translate="yes" xml:space="preserve">
          <source>Whether the driver allows fetching numerical values with low precision.</source>
          <target state="translated">드라이버가 낮은 정밀도로 숫자 값을 가져올 수 있는지 여부</target>
        </trans-unit>
        <trans-unit id="3c7f787b2f9cd46ea9f39398ae0c7d4485ca5fc8" translate="yes" xml:space="preserve">
          <source>Whether the driver can access multiple result sets returned from batched statements or stored procedures.</source>
          <target state="translated">드라이버가 배치 명령문 또는 스토어드 프로 시저에서 리턴 된 여러 결과 세트에 액세스 할 수 있는지 여부</target>
        </trans-unit>
        <trans-unit id="ed4bc20d5aa787a8e008253aa117335c9aa08d81" translate="yes" xml:space="preserve">
          <source>Whether the driver can do any low-level resource cleanup when &lt;a href=&quot;qsqlquery#finish&quot;&gt;QSqlQuery::finish&lt;/a&gt;() is called.</source>
          <target state="translated">&lt;a href=&quot;qsqlquery#finish&quot;&gt;QSqlQuery :: finish&lt;/a&gt; ()가 호출 될 때 드라이버가 저수준 리소스 정리를 수행 할 수 있는지 여부</target>
        </trans-unit>
        <trans-unit id="210464c5de5626efc42d1df157c9de9e9c7d0158" translate="yes" xml:space="preserve">
          <source>Whether the driver disallows a write lock on a table while other queries have a read lock on it.</source>
          <target state="translated">다른 쿼리에 대한 읽기 잠금이있는 동안 드라이버가 테이블에서 쓰기 잠금을 허용하지 않는지 여부</target>
        </trans-unit>
        <trans-unit id="4e4f69b95b47bd4f3d99879fb2bd280a082c0786" translate="yes" xml:space="preserve">
          <source>Whether the driver supports Binary Large Object fields.</source>
          <target state="translated">드라이버가 Binary Large Object 필드를 지원하는지 여부</target>
        </trans-unit>
        <trans-unit id="1bd1162a270f0edcfe194947159af7188cd907e5" translate="yes" xml:space="preserve">
          <source>Whether the driver supports SQL transactions.</source>
          <target state="translated">드라이버가 SQL 트랜잭션을 지원하는지 여부</target>
        </trans-unit>
        <trans-unit id="845a4430bcc8fbfbbff1ac48b77c4dd33f0996d9" translate="yes" xml:space="preserve">
          <source>Whether the driver supports Unicode strings if the database server does.</source>
          <target state="translated">데이터베이스 서버에서 드라이버가 유니 코드 문자열을 지원하는지 여부</target>
        </trans-unit>
        <trans-unit id="99e2eef4a7afa6967f2bfdb3d2317bc8259b8b38" translate="yes" xml:space="preserve">
          <source>Whether the driver supports batched operations, see &lt;a href=&quot;qsqlquery#execBatch&quot;&gt;QSqlQuery::execBatch&lt;/a&gt;()</source>
          <target state="translated">드라이버가 일괄 작업을 지원하는지 여부는 &lt;a href=&quot;qsqlquery#execBatch&quot;&gt;QSqlQuery :: execBatch&lt;/a&gt; ()를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="cc692b7b64b01e95bec2490419dbacbec52f5ac5" translate="yes" xml:space="preserve">
          <source>Whether the driver supports database event notifications.</source>
          <target state="translated">드라이버가 데이터베이스 이벤트 알림을 지원하는지 여부</target>
        </trans-unit>
        <trans-unit id="628444820187e4c76acfe865374c57be9597b3c4" translate="yes" xml:space="preserve">
          <source>Whether the driver supports prepared query execution.</source>
          <target state="translated">드라이버가 준비된 쿼리 실행을 지원하는지 여부</target>
        </trans-unit>
        <trans-unit id="d578a8324e172000e823c2e578c26df8d857120a" translate="yes" xml:space="preserve">
          <source>Whether the driver supports returning the Id of the last touched row.</source>
          <target state="translated">드라이버가 마지막으로 터치 한 행의 ID 반환을 지원하는지 여부</target>
        </trans-unit>
        <trans-unit id="0c016f85910ee59575e37aaa781500e68ac6489e" translate="yes" xml:space="preserve">
          <source>Whether the driver supports the use of named placeholders.</source>
          <target state="translated">드라이버가 명명 된 자리 표시 자 사용을 지원하는지 여부</target>
        </trans-unit>
        <trans-unit id="f5fabd5d2f9f3ba4bba291487dcd50948e6e0eac" translate="yes" xml:space="preserve">
          <source>Whether the driver supports the use of positional placeholders.</source>
          <target state="translated">운전자가 위치 자리 표시 자 사용을 지원하는지 여부</target>
        </trans-unit>
        <trans-unit id="e7c605a10ccaa6b790d36479ca5cd3464b7e3e99" translate="yes" xml:space="preserve">
          <source>Whether the focus is is at the border or inside the widget.</source>
          <target state="translated">초점이 테두리에 있는지 또는 위젯 안에 있는지 여부</target>
        </trans-unit>
        <trans-unit id="fbd034ed932cf240c748ee945667de15e7a72c46" translate="yes" xml:space="preserve">
          <source>Whether the item is pressed</source>
          <target state="translated">항목을 눌렀는지 여부</target>
        </trans-unit>
        <trans-unit id="46ebf14697d16b952c232d4c529425aeba2ec058" translate="yes" xml:space="preserve">
          <source>Whether the label is drawn.</source>
          <target state="translated">라벨이 그려 졌는지 여부</target>
        </trans-unit>
        <trans-unit id="aaf559ded4da7eb7934bbeb8f5160f6fd7699b4b" translate="yes" xml:space="preserve">
          <source>Whether the legend background is visible.</source>
          <target state="translated">범례 배경이 표시되는지 여부</target>
        </trans-unit>
        <trans-unit id="37313d12a7a0be8af88693a899b7344efb257291" translate="yes" xml:space="preserve">
          <source>Whether the legend is visible.</source>
          <target state="translated">범례가 표시되는지 여부</target>
        </trans-unit>
        <trans-unit id="3144153f16d0769f79b9785e618f134de4aefa6a" translate="yes" xml:space="preserve">
          <source>Whether the line is the last. This property can change if you set the</source>
          <target state="translated">라인이 마지막인지 여부. 이 속성은</target>
        </trans-unit>
        <trans-unit id="9ea42eeadcc56647ffbc101f32710a47b1a0a933" translate="yes" xml:space="preserve">
          <source>Whether the map type is optimized for the use on a mobile device.</source>
          <target state="translated">지도 유형이 휴대 기기에서 사용하도록 최적화되었는지 여부</target>
        </trans-unit>
        <trans-unit id="03f0ed19d3ba562825d7a428e850d0d4ae79787e" translate="yes" xml:space="preserve">
          <source>Whether the map type is optimized for use at night.</source>
          <target state="translated">지도 유형이 야간에 사용하도록 최적화되었는지 여부</target>
        </trans-unit>
        <trans-unit id="621b2949699553f62dcb51e30d25da4b13f98472" translate="yes" xml:space="preserve">
          <source>Whether the menu is enabled, and responsive to user interaction as a submenu. Its value defaults to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">메뉴 사용 여부 및 하위 메뉴로서의 사용자 상호 작용에 응답합니다. 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="08f744dfb74a52e0e277283ba5907cc6f1378d72" translate="yes" xml:space="preserve">
          <source>Whether the menu item can be checked, or toggled. Defaults to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">메뉴 항목을 확인하거나 전환 할 수 있는지 여부 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4c1b888a2cec2b100297f179f869b0944945d49d" translate="yes" xml:space="preserve">
          <source>Whether the menu item is enabled, and responsive to user interaction. Defaults to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">메뉴 항목이 활성화되어 있고 사용자 상호 작용에 반응하는지 여부 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ce8fa3229c69c96181da21931047a6e1d51bf634" translate="yes" xml:space="preserve">
          <source>Whether the menu item should be visible. Defaults to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">메뉴 항목의 표시 여부 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="92a63e59bfc40ad15c5be2816466eb24eacc2ef5" translate="yes" xml:space="preserve">
          <source>Whether the menu separator should be visible.</source>
          <target state="translated">메뉴 구분 기호를 표시할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="3cf2e278ef17de70651570a3447bc45e677d370d" translate="yes" xml:space="preserve">
          <source>Whether the menu should be visible as a submenu of another Menu, or as a menu on a &lt;a href=&quot;qml-qtquick-controls-menubar&quot;&gt;MenuBar&lt;/a&gt;. Its value defaults to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">메뉴는 다른 메뉴의 하위 메뉴, 또는에 메뉴로 표시해야하는지 여부 &lt;a href=&quot;qml-qtquick-controls-menubar&quot;&gt;의 MenuBar&lt;/a&gt; . 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8088e05c590a3e0bf008c00d389801153a3d00b6" translate="yes" xml:space="preserve">
          <source>Whether the navigation issue is requested for a top level page.</source>
          <target state="translated">최상위 페이지에 탐색 문제가 요청되었는지 여부</target>
        </trans-unit>
        <trans-unit id="235d5328b4f194c49658a5369d777c354e0bc206" translate="yes" xml:space="preserve">
          <source>Whether the reimplementation of &lt;a href=&quot;qabstractitemmodel#hasChildren&quot;&gt;hasChildren()&lt;/a&gt; returns &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;, it may not be necessary for the view to call &lt;a href=&quot;qabstractitemmodel#rowCount&quot;&gt;rowCount()&lt;/a&gt; to find out how many children are present. For example, &lt;a href=&quot;qtreeview&quot;&gt;QTreeView&lt;/a&gt; does not need to know how many children there are if the parent item has not been expanded to show them.</source>
          <target state="translated">&lt;a href=&quot;qabstractitemmodel#hasChildren&quot;&gt;hasChildren ()&lt;/a&gt; 의 재 구현이 &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt; 를 돌려 주는지 , 뷰가 &lt;a href=&quot;qabstractitemmodel#rowCount&quot;&gt;rowCount ()&lt;/a&gt; 를 호출 해 존재하는 아이가 몇개인지를 알 필요는 없습니다 . 예를 들어, &lt;a href=&quot;qtreeview&quot;&gt;QTreeView&lt;/a&gt; 는 상위 항목이 확장되지 않은 경우 하위 항목 수를 알 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="538f44ad7b42229493c7d7d9e3ef2b46b9b9269d" translate="yes" xml:space="preserve">
          <source>Whether the selected item should be a folder.</source>
          <target state="translated">선택한 항목이 폴더 여야하는지 여부</target>
        </trans-unit>
        <trans-unit id="8b37630a9ab7e8561ccfcc973792499cdd1c2fc9" translate="yes" xml:space="preserve">
          <source>Whether the slice is separated from the pie.</source>
          <target state="translated">슬라이스가 파이와 분리되는지 여부</target>
        </trans-unit>
        <trans-unit id="1e51bb9bffd87efbffac7ced9051c8e36ae66ea8" translate="yes" xml:space="preserve">
          <source>Whether the sprite is animating or not.</source>
          <target state="translated">스프라이트가 애니메이션인지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="15b788e281bbb09b261892870f8a1722b24dac42" translate="yes" xml:space="preserve">
          <source>Whether the state machine was invoked from an outer state machine.</source>
          <target state="translated">상태 머신이 외부 상태 머신에서 호출되었는지 여부</target>
        </trans-unit>
        <trans-unit id="a0b1a3343f7c152c3d6e8ee37fef9d099e50a0ff" translate="yes" xml:space="preserve">
          <source>Whether the style should underline the menu item's label mnemonic.</source>
          <target state="translated">스타일이 메뉴 항목의 레이블 니모닉에 밑줄을 긋을지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="c38308bf37133d3debb54fd9749488e0eb788394" translate="yes" xml:space="preserve">
          <source>Whether the timeline is enabled.</source>
          <target state="translated">타임 라인 활성화 여부.</target>
        </trans-unit>
        <trans-unit id="6800a5d87cf42840acdc7fcb220f0eab7fdd1856" translate="yes" xml:space="preserve">
          <source>Whether the user can interact with the &lt;a href=&quot;qml-qtquick-controls-textarea&quot;&gt;TextArea&lt;/a&gt; item.</source>
          <target state="translated">사용자가 &lt;a href=&quot;qml-qtquick-controls-textarea&quot;&gt;TextArea&lt;/a&gt; 항목 과 상호 작용할 수 있는지 여부</target>
        </trans-unit>
        <trans-unit id="3404ae7c0bcb4ef4a1fedd302f33d359c7dbd904" translate="yes" xml:space="preserve">
          <source>Whether the user can interact with the &lt;a href=&quot;qml-qtquick-textedit&quot;&gt;TextEdit&lt;/a&gt; item. If this property is set to true the text cannot be edited by user interaction.</source>
          <target state="translated">사용자가 &lt;a href=&quot;qml-qtquick-textedit&quot;&gt;TextEdit&lt;/a&gt; 항목 과 상호 작용할 수 있는지 여부 이 특성을 true로 설정하면 사용자 상호 작용으로 텍스트를 편집 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="421117e08c0b75cdb15d7908f28bc054bc099c36" translate="yes" xml:space="preserve">
          <source>Whether the values are reported for dragging and/or flicking is determined by &lt;a href=&quot;qml-qtquick-flickable#boundsBehavior-prop&quot;&gt;boundsBehavior&lt;/a&gt;. The overshoot distance is reported even when &lt;a href=&quot;qml-qtquick-flickable#boundsMovement-prop&quot;&gt;boundsMovement&lt;/a&gt; is &lt;code&gt;Flickable.StopAtBounds&lt;/code&gt;.</source>
          <target state="translated">드래그 및 / 또는 플릭에 대한 값의보고 여부는 &lt;a href=&quot;qml-qtquick-flickable#boundsBehavior-prop&quot;&gt;boundsBehavior에&lt;/a&gt; 의해 결정됩니다 . &lt;a href=&quot;qml-qtquick-flickable#boundsMovement-prop&quot;&gt;boundsMovement&lt;/a&gt; 가 &lt;code&gt;Flickable.StopAtBounds&lt;/code&gt; 인 경우에도 오버 슈트 거리가보고됩니다 .</target>
        </trans-unit>
        <trans-unit id="e6ceaafbfc10047970bada881dcbd1c1197929a3" translate="yes" xml:space="preserve">
          <source>Whether the web engine profile is</source>
          <target state="translated">웹 엔진 프로파일이</target>
        </trans-unit>
        <trans-unit id="3415d4ca07d6a652c116c2d85a4d5f784d1a62b9" translate="yes" xml:space="preserve">
          <source>Whether the window has a custom background color set.</source>
          <target state="translated">창에 사용자 정의 배경색이 설정되어 있는지 여부</target>
        </trans-unit>
        <trans-unit id="3f356add3a289b463a5638963da464dcfa8cedbc" translate="yes" xml:space="preserve">
          <source>Whether the window is visible on the screen.</source>
          <target state="translated">화면이 창에 표시되는지 여부</target>
        </trans-unit>
        <trans-unit id="913fc48b2bd67968d18a833b0cf728c3541e7c15" translate="yes" xml:space="preserve">
          <source>Whether this download is finished (completed, cancelled, or non-resumable interrupted state).</source>
          <target state="translated">이 다운로드가 완료되었는지 여부 (완료, 취소 또는 재개 불가능 중단 상태).</target>
        </trans-unit>
        <trans-unit id="10665e34f2783f8fa2a19993bf61804f7d9d48e8" translate="yes" xml:space="preserve">
          <source>Whether this download is paused.</source>
          <target state="translated">이 다운로드가 일시 중지되었는지 여부</target>
        </trans-unit>
        <trans-unit id="c87f3e63dd21c4200bb479597f1ec7b574bdee0e" translate="yes" xml:space="preserve">
          <source>Whether this element should be disconnected from the previous Path element (or startX/Y).</source>
          <target state="translated">이 요소를 이전 Path 요소 (또는 startX / Y)와 연결 해제해야하는지 여부</target>
        </trans-unit>
        <trans-unit id="577931957ce048bb07933998686fe00fd1a4e569" translate="yes" xml:space="preserve">
          <source>Whether this is a download request for saving a web page or a file.</source>
          <target state="translated">웹 페이지 또는 파일 저장을위한 다운로드 요청인지 여부</target>
        </trans-unit>
        <trans-unit id="fb9cfcf1336fb0bab461c8a796b1628a9b1dba5b" translate="yes" xml:space="preserve">
          <source>Whether this window request was directly triggered as the result of a keyboard or mouse event.</source>
          <target state="translated">이 창 요청이 키보드 또는 마우스 이벤트의 결과로 직접 트리거되었는지 여부</target>
        </trans-unit>
        <trans-unit id="9f0457984bd91b6556f4c2015acaf5a05c1691bd" translate="yes" xml:space="preserve">
          <source>Whether to accept or ignore the navigation request.</source>
          <target state="translated">탐색 요청을 수락할지 또는 무시할지 여부</target>
        </trans-unit>
        <trans-unit id="1a30ac0ac903d864bd8a03b00460c0d402a09ff3" translate="yes" xml:space="preserve">
          <source>Whether to use a large arc as defined by the arc points.</source>
          <target state="translated">호 점으로 정의 된 큰 호를 사용할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="acf3d78a191e4a37d63681f2767dfaa3b23c48e5" translate="yes" xml:space="preserve">
          <source>Whether to use the instruction text that came with the response from the server (true) or the text generated by the plugin. The default value is true. Note that if instructions in a language that is not directly supported by Mapbox are needed (see &lt;a href=&quot;https://www.mapbox.com/api-documentation/#instructions-languages&quot;&gt;here&lt;/a&gt; for the supported languages), it is possible to use the &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtlinguist-index.html&quot;&gt;Qt Linguist&lt;/a&gt; to translate &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtlocation-module.html&quot;&gt;QtLocation&lt;/a&gt; to the desired language, and set this parameter to false in order to use the translated built-in instructions.</source>
          <target state="translated">서버의 응답과 함께 제공된 지침 텍스트 (true) 또는 플러그인에서 생성 된 텍스트를 사용할지 여부입니다. 기본값은 true입니다. Mapbox에서 직접 지원하지 않는 언어의 지침이 필요한 경우 ( 지원되는 언어는 &lt;a href=&quot;https://www.mapbox.com/api-documentation/#instructions-languages&quot;&gt;여기&lt;/a&gt; 참조 ) &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtlinguist-index.html&quot;&gt;Qt Linguist&lt;/a&gt; 를 사용하여 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtlocation-module.html&quot;&gt;QtLocation&lt;/a&gt; 을 원하는 언어 로 변환 하고이 매개 변수를 false로 설정하십시오. 번역 된 내장 명령어를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="1fcccc4a8ddc8959e8c2dd3a070f746efff6d17d" translate="yes" xml:space="preserve">
          <source>Whether to use the instruction text that came with the response from the server (true) or the text generated by the plugin. The default value is true. Note that if instructions in a language that is not directly supported by Mapbox are needed (see &lt;a href=&quot;https://www.mapbox.com/api-documentation/#instructions-languages&quot;&gt;here&lt;/a&gt; for the supported languages), it is possible to use the &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtlinguist-index.html&quot;&gt;Qt Linguist&lt;/a&gt; to translate &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtlocation-module.html&quot;&gt;QtLocation&lt;/a&gt; to the desired language, and set this parameter to false in order to use the translated built-in instructions.</source>
          <target state="translated">서버의 응답과 함께 제공된 지침 텍스트 (true) 또는 플러그인에서 생성 된 텍스트를 사용할지 여부입니다. 기본값은 true입니다. Mapbox에서 직접 지원하지 않는 언어로 된 지침이 필요한 경우 ( 지원되는 언어는 &lt;a href=&quot;https://www.mapbox.com/api-documentation/#instructions-languages&quot;&gt;여기&lt;/a&gt; 참조 ) &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtlinguist-index.html&quot;&gt;Qt Linguist&lt;/a&gt; 를 사용하여 &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtlocation-module.html&quot;&gt;QtLocation&lt;/a&gt; 을 원하는 언어 로 번역 하고이 매개 변수를 false로 설정하여 다음을 수행 할 수 있습니다. 번역 된 내장 지침을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="5ad7a9dbe1c579bd84d6196251c8df00e0a9061e" translate="yes" xml:space="preserve">
          <source>Whether tool tips are shown on window title bar buttons.</source>
          <target state="translated">도구 설명이 창 제목 표시 줄 단추에 표시되는지 여부</target>
        </trans-unit>
        <trans-unit id="13bccea668c4304e35b3c2648c61d13a84c0a8e9" translate="yes" xml:space="preserve">
          <source>Whether tooltips are shown when the text is truncated. This property is &lt;code&gt;false&lt;/code&gt; by default. This property currently has no effect as there is no support for tooltips in QML.</source>
          <target state="translated">텍스트가 잘릴 때 툴팁이 표시되는지 여부입니다. 이 속성은 기본적으로 &lt;code&gt;false&lt;/code&gt; 입니다. QML에서 툴팁을 지원하지 않으므로이 특성은 현재 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="31fad663cc5a6c9e201e536434fd859471a2a47c" translate="yes" xml:space="preserve">
          <source>Whether your COM server should run as a stand-alone executable or as a shared library in the client process depends mainly on the type of COM objects you want to provide in the server.</source>
          <target state="translated">COM 서버가 클라이언트 프로세스에서 독립 실행 형 실행 파일 또는 공유 라이브러리로 실행되어야하는지 여부는 주로 서버에 제공하려는 COM 개체의 유형에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="70bef61f89759f7b941e6e11ce1d973c5bf9fbe3" translate="yes" xml:space="preserve">
          <source>Which APIs of the COM object are available through scripting depends on the script language used.</source>
          <target state="translated">스크립팅을 통해 사용 가능한 COM 개체의 API는 사용되는 스크립트 언어에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="793d21dbade3ed082aff6e7f64034df5c8fb7bc4" translate="yes" xml:space="preserve">
          <source>Which button gets the default status in a dialog's button widget.</source>
          <target state="translated">대화 상자의 단추 위젯에서 기본 상태를 가져 오는 단추</target>
        </trans-unit>
        <trans-unit id="3db94e72d3b34a0e4e2719f79caf5739c7fca8b2" translate="yes" xml:space="preserve">
          <source>Which can then be used in a Qt Quick 3D project by using that QML Component:</source>
          <target state="translated">그런 다음 해당 QML 구성 요소를 사용하여 Qt Quick 3D 프로젝트에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c852b7c7494dc6886d8b68161e6704f86567c96f" translate="yes" xml:space="preserve">
          <source>Which content to show</source>
          <target state="translated">표시 할 콘텐츠</target>
        </trans-unit>
        <trans-unit id="c0b12e319739b053134fc0caec91714a71612d6b" translate="yes" xml:space="preserve">
          <source>Which include statement is needed to use this class?</source>
          <target state="translated">이 클래스를 사용하려면 어떤 include 문이 필요합니까?</target>
        </trans-unit>
        <trans-unit id="2db588c843f0fd8abd06af7fd113c24d90771081" translate="yes" xml:space="preserve">
          <source>Which is equivalent to the following, much more verbose code:</source>
          <target state="translated">다음은 훨씬 더 자세한 코드와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="608a0352c63aabee07da1f6a81bdd20076990125" translate="yes" xml:space="preserve">
          <source>Which logical particle groups will be affected.</source>
          <target state="translated">영향을받는 논리 파티클 그룹</target>
        </trans-unit>
        <trans-unit id="25e530a3452f532ae132324593d82cc6b8193cfd" translate="yes" xml:space="preserve">
          <source>Which logical particle groups will be painted.</source>
          <target state="translated">어떤 논리 파티클 그룹이 그려 질지</target>
        </trans-unit>
        <trans-unit id="3d4b605c5f5f983a4bd45171bb55ac43a2d266df" translate="yes" xml:space="preserve">
          <source>Which modifier keys are currently pressed</source>
          <target state="translated">현재 어떤 수정 자 키를 눌렀는지</target>
        </trans-unit>
        <trans-unit id="81602f452c808bea87345f9047105a0cca0c7c26" translate="yes" xml:space="preserve">
          <source>Which mouse buttons cause a slider to page step the value.</source>
          <target state="translated">슬라이더가 값을 페이지 단계로 만드는 마우스 버튼</target>
        </trans-unit>
        <trans-unit id="14b2d9e139d29168831e1c17e4d323900f8d3b0d" translate="yes" xml:space="preserve">
          <source>Which mouse buttons cause a slider to set the value to the position clicked on.</source>
          <target state="translated">슬라이더로 인해 클릭 한 위치로 값을 설정하는 마우스 버튼</target>
        </trans-unit>
        <trans-unit id="efdebfca3891aee71d0e4ed022793cc1b44becb2" translate="yes" xml:space="preserve">
          <source>Which mouse or stylus buttons are currently pressed</source>
          <target state="translated">현재 누른 마우스 또는 스타일러스 버튼</target>
        </trans-unit>
        <trans-unit id="1efe3552692d8bb927cb6e3656a6eb4fac500a0c" translate="yes" xml:space="preserve">
          <source>Which of the &lt;a href=&quot;qml-qtquick-dialogs-filedialog#nameFilters-prop&quot;&gt;nameFilters&lt;/a&gt; is currently selected.</source>
          <target state="translated">의 어느 &lt;a href=&quot;qml-qtquick-dialogs-filedialog#nameFilters-prop&quot;&gt;nameFilters은&lt;/a&gt; 현재 선택되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce70c525d60cbc2afd202f541aa3a5307f50aa58" translate="yes" xml:space="preserve">
          <source>Which properties that have changed can at any time be retrieved using the &lt;a href=&quot;qpaintenginestate#state&quot;&gt;state&lt;/a&gt;() function. This function returns an instance of the &lt;a href=&quot;qpaintengine#DirtyFlag-enum&quot;&gt;QPaintEngine::DirtyFlags&lt;/a&gt; type which stores an OR combination of &lt;a href=&quot;qpaintengine#DirtyFlag-enum&quot;&gt;QPaintEngine::DirtyFlag&lt;/a&gt; values. The &lt;a href=&quot;qpaintengine#DirtyFlag-enum&quot;&gt;QPaintEngine::DirtyFlag&lt;/a&gt; enum defines whether a property has changed since the last update or not.</source>
          <target state="translated">&lt;a href=&quot;qpaintenginestate#state&quot;&gt;state&lt;/a&gt; () 함수를 사용하여 언제라도 변경된 속성을 검색 할 수 있습니다 . 이 함수는 &lt;a href=&quot;qpaintengine#DirtyFlag-enum&quot;&gt;QPaintEngine :: DirtyFlag&lt;/a&gt; 값 의 OR 조합을 저장하는 &lt;a href=&quot;qpaintengine#DirtyFlag-enum&quot;&gt;QPaintEngine :: DirtyFlags&lt;/a&gt; 유형 의 인스턴스를 리턴 합니다. &lt;a href=&quot;qpaintengine#DirtyFlag-enum&quot;&gt;QPaintEngine :: DirtyFlag&lt;/a&gt; 열거 정의하는 속성이 마지막 업데이트 여부를 이후로 변경되었는지 여부.</target>
        </trans-unit>
        <trans-unit id="e1df1f5e64d59ab6dd483dbd8de2ec583fac2e6a" translate="yes" xml:space="preserve">
          <source>Which type of mouse event should cause a list view expansion to be selected.</source>
          <target state="translated">목록보기 확장을 선택해야하는 마우스 이벤트 유형</target>
        </trans-unit>
        <trans-unit id="ec4e8958dac6b783178c5d6e15aae8d62c60049e" translate="yes" xml:space="preserve">
          <source>Which type of mouse event should cause a tab to be selected.</source>
          <target state="translated">탭을 선택해야하는 마우스 이벤트 유형</target>
        </trans-unit>
        <trans-unit id="866ed4526e153c6c9530e1af557d9e77faec2523" translate="yes" xml:space="preserve">
          <source>Which wheel to react to. The default is &lt;code&gt;Qt.Vertical&lt;/code&gt;.</source>
          <target state="translated">반응 할 휠. 기본값은 &lt;code&gt;Qt.Vertical&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1d4a3d8f1568fbbfc148324db5db9d1ae0cc6949" translate="yes" xml:space="preserve">
          <source>Whichever type &lt;a href=&quot;qcborvalue#toJsonValue&quot;&gt;QCborValue::toJsonValue&lt;/a&gt;() returns.</source>
          <target state="translated">&lt;a href=&quot;qcborvalue#toJsonValue&quot;&gt;QCborValue :: toJsonValue&lt;/a&gt; () 유형이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="d86a5675cc6478e7030415aaa83cd72801292548" translate="yes" xml:space="preserve">
          <source>While</source>
          <target state="translated">While</target>
        </trans-unit>
        <trans-unit id="0c92333f95ca45dcb239bb12adff2c5c85e31dd7" translate="yes" xml:space="preserve">
          <source>While &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; attempts to smooth over the differences between the different supported platforms, there are still a few differences that you should be aware of when porting your application:</source>
          <target state="translated">&lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; 는 서로 다른 지원되는 플랫폼 간의 차이점을 완화하려고 시도 하지만 애플리케이션을 이식 할 때 알아야 할 몇 가지 차이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="916913c0cc31f207656b815c201c7061964f589f" translate="yes" xml:space="preserve">
          <source>While CMake is the only supported build system for building Qt itself, applications may still be built using &lt;code&gt;qmake&lt;/code&gt; in Qt 6.0. In order to get a &lt;code&gt;qmake&lt;/code&gt; setup that is functional with cross-compilation, one will need to specify some of the legacy arguments to CMake or to configure.</source>
          <target state="translated">CMake는 Qt 자체 빌드를 위해 지원되는 유일한 빌드 시스템이지만 Qt 6.0에서 &lt;code&gt;qmake&lt;/code&gt; 를 사용하여 애플리케이션을 빌드 할 수 있습니다 . 교차 컴파일로 작동 하는 &lt;code&gt;qmake&lt;/code&gt; 설정 을 얻으려면 일부 레거시 인수를 CMake에 지정하거나 구성해야합니다.</target>
        </trans-unit>
        <trans-unit id="0b071fa22d15d222cb6c92bb69c100ebbc5362ee" translate="yes" xml:space="preserve">
          <source>While FrameGraphNodes can be individually enabled and disabled via the &lt;code&gt;enabled&lt;/code&gt; property, this can become tedious when an entire path needs to be turned on or off. SubtreeEnabler is a convenience node that makes this use case trivial, allowing all of its children to be controlled by a single switch.</source>
          <target state="translated">&lt;code&gt;enabled&lt;/code&gt; 속성을 통해 FrameGraphNodes를 개별적으로 활성화 및 비활성화 할 수 있지만 전체 경로를 켜거나 꺼야 할 때 지루할 수 있습니다. SubtreeEnabler는이 사용 사례를 간단하게 만드는 편리한 노드로 모든 하위 항목을 단일 스위치로 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="80cc72a6fe5a9ef131329278224272da11157a25" translate="yes" xml:space="preserve">
          <source>While QFrameGraphNodes can be individually enabled and disabled via the &lt;code&gt;enabled&lt;/code&gt; property, this can become tedious when an entire path needs to be turned on or off. QSubtreeEnabler is a convenience node that makes this use case trivial, allowing all of its children to be controlled by a single switch.</source>
          <target state="translated">QFrameGraphNodes는 &lt;code&gt;enabled&lt;/code&gt; 속성을 통해 개별적으로 활성화 및 비활성화 할 수 있지만 전체 경로를 켜거나 꺼야 할 때 지루할 수 있습니다. QSubtreeEnabler는이 사용 사례를 사소하게 만들어 모든 하위 항목을 단일 스위치로 제어 할 수있는 편리한 노드입니다.</target>
        </trans-unit>
        <trans-unit id="805d12233c47b77ed4b3e62b7584c32850936965" translate="yes" xml:space="preserve">
          <source>While QML objects instantiated in a context are not strictly owned by that context, their bindings are. If a context is destroyed, the property bindings of outstanding QML objects will stop evaluating.</source>
          <target state="translated">컨텍스트에서 인스턴스화 된 QML 오브젝트는 해당 컨텍스트에서 엄격하게 소유하지 않지만 바인딩은 해당됩니다. 컨텍스트가 손상되면 미해결 QML 오브젝트의 특성 바인딩이 평가를 중지합니다.</target>
        </trans-unit>
        <trans-unit id="63d99cb7559ceb26aa76fb0f9748bade0a0e5027" translate="yes" xml:space="preserve">
          <source>While QSettings attempts to smooth over the differences between the different supported platforms, there are still a few differences that you should be aware of when porting your application:</source>
          <target state="translated">QSettings는 지원되는 서로 다른 플랫폼 간의 차이를 완화하려고 시도하지만 애플리케이션을 포팅 할 때 알아야 할 몇 가지 차이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="88b774c74a2776122de7b559a743e91ffaed05ef" translate="yes" xml:space="preserve">
          <source>While Qt Quick provides basic graphical elements, &lt;a href=&quot;qtquickcontrols-index&quot;&gt;Qt Quick Controls&lt;/a&gt; provides ready-made QML types for use within an application.</source>
          <target state="translated">Qt Quick은 기본 그래픽 요소를 제공하지만 Qt Quick &lt;a href=&quot;qtquickcontrols-index&quot;&gt;Controls&lt;/a&gt; 는 응용 프로그램 내에서 사용할 수있는 기성품 QML 유형을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="a5caad6194e0d31eb78a5652257e4bbde771723c" translate="yes" xml:space="preserve">
          <source>While Qt Remote Objects (QtRO) handles the initialization and synchronization of &lt;a href=&quot;qtremoteobjects-replica#replica&quot;&gt;Replica&lt;/a&gt; objects, there are numerous steps happening behind the scenes which can fail and that aren't encountered in single process Qt applications. See &lt;a href=&quot;qtremoteobjects-troubleshooting#troubleshooting&quot;&gt;Troubleshooting&lt;/a&gt; for advice on how to handle such issues when using a remote objects network.</source>
          <target state="translated">QtRO (Qt Remote Objects)는 &lt;a href=&quot;qtremoteobjects-replica#replica&quot;&gt;Replica&lt;/a&gt; 객체 의 초기화 및 동기화를 처리하지만 , 단일 프로세스 Qt 애플리케이션에서는 발생하지 않고 실패 할 수있는 많은 단계가 발생합니다. 원격 객체 네트워크를 사용할 때 이러한 문제를 처리하는 방법에 대한 조언 은 &lt;a href=&quot;qtremoteobjects-troubleshooting#troubleshooting&quot;&gt;문제 해결&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8dc3249320abae6037c56c4dfaf988c3e01c6b36" translate="yes" xml:space="preserve">
          <source>While Qt Remote Objects supports sharing any &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; over the network (using enableRemoting on the Source side and acquireDynamic on the Replica side), there are a couple of advantages to letting repc define your objects. First of all, while &lt;a href=&quot;qremoteobjectdynamicreplica&quot;&gt;DynamicReplicas&lt;/a&gt; are useful, they are more cumbersome to work with. The API is not known until the object is initialized, and using the API from C++ requires string lookups through &lt;a href=&quot;qmetaobject&quot;&gt;QMetaObject&lt;/a&gt;'s methods. Secondly, having the interface known at compile time finds any issues at compile vs. at runtime. Thirdly, the rep format supports default values, which can be handy if you are unable to ensure the Source is available when the Replica is instantiated.</source>
          <target state="translated">Qt Remote Objects는 네트워크를 통해 &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 공유를 지원하지만 (소스 측에서는 enableRemoting을 사용하고 Replica 측에서는 acquireDynamic을 사용하여) repc가 객체를 정의 할 수있게하는 몇 가지 장점이 있습니다. 우선, &lt;a href=&quot;qremoteobjectdynamicreplica&quot;&gt;DynamicReplica&lt;/a&gt; 는 유용하지만 작업하기가 더 번거 롭습니다. API는 객체가 초기화 될 때까지 알려져 있지 않으며 C ++의 API를 사용하려면 &lt;a href=&quot;qmetaobject&quot;&gt;QMetaObject&lt;/a&gt; 의 메소드를 통한 문자열 조회가 필요합니다 . 둘째, 컴파일 타임에 인터페이스를 알고 있으면 컴파일과 런타임에 문제가 발견됩니다. 세 번째로, rep 형식은 기본값을 지원하므로 복제본이 인스턴스화 될 때 소스를 사용할 수없는 경우 편리합니다.</target>
        </trans-unit>
        <trans-unit id="e457f9c50b36136e1b62d4d3cceb2a290ccb7e89" translate="yes" xml:space="preserve">
          <source>While Qt offers a lot of classes for writing your application, Apple's Cocoa frameworks offer functionality that is not currently available (or may never end up) in Qt. Using &lt;a href=&quot;qmaccocoaviewcontainer&quot;&gt;QMacCocoaViewContainer&lt;/a&gt;, it is possible to take an arbitrary NSView-derived class from Cocoa and put it in a Qt widgets hierarchy. Depending on the level of integration you need, you can use &lt;a href=&quot;qmaccocoaviewcontainer&quot;&gt;QMacCocoaViewContainer&lt;/a&gt; directly or subclass it to wrap more functionality of the underlying NSView.</source>
          <target state="translated">Qt는 응용 프로그램 작성을위한 많은 클래스를 제공하지만 Apple의 Cocoa 프레임 워크는 현재 Qt에서 사용할 수 없거나 끝날 수없는 기능을 제공합니다. &lt;a href=&quot;qmaccocoaviewcontainer&quot;&gt;QMacCocoaViewContainer를&lt;/a&gt; 사용하면 Cocoa에서 임의의 NSView 파생 클래스를 가져 와서 Qt 위젯 계층 구조에 넣을 수 있습니다. 필요한 통합 수준에 따라 &lt;a href=&quot;qmaccocoaviewcontainer&quot;&gt;QMacCocoaViewContainer를&lt;/a&gt; 직접 사용 하거나 서브 클래 싱하여 기본 NSView의 더 많은 기능을 래핑 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5c324cf8835a3580c511d22b5dd7d8641994d4b4" translate="yes" xml:space="preserve">
          <source>While Qt offers a lot of classes for writing your application, Apple's Cocoa frameworks offer functionality that is not currently available (or may never end up) in Qt. Using QMacCocoaViewContainer, it is possible to take an arbitrary NSView-derived class from Cocoa and put it in a Qt widgets hierarchy. Depending on the level of integration you need, you can use QMacCocoaViewContainer directly or subclass it to wrap more functionality of the underlying NSView.</source>
          <target state="translated">Qt는 애플리케이션 작성을위한 많은 클래스를 제공하지만 Apple의 Cocoa 프레임 워크는 Qt에서 현재 사용할 수없는 (또는 종료되지 않을 수있는) 기능을 제공합니다. QMacCocoaViewContainer를 사용하면 Cocoa에서 임의의 NSView 파생 클래스를 가져와 Qt 위젯 계층 구조에 넣을 수 있습니다. 필요한 통합 수준에 따라 QMacCocoaViewContainer를 직접 사용하거나이를 하위 클래스로 지정하여 기본 NSView의 더 많은 기능을 래핑 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e3a813065803d8f7f9a418b84f2a634dd5bb47f" translate="yes" xml:space="preserve">
          <source>While Qt solves many of the typical tasks of writing an application, there are always corner cases that Qt can not cover, or where it makes more sense to build a feature on top of the platform specific APIs, or another toolkit.</source>
          <target state="translated">Qt가 애플리케이션 작성의 일반적인 작업을 많이 해결하는 동안, Qt가 다룰 수없는 경우가 항상 있거나 플랫폼 별 API 또는 다른 툴킷 위에 기능을 빌드하는 것이 더 합리적입니다.</target>
        </trans-unit>
        <trans-unit id="639e47c0cc3c90dd85258bd8d0bd4929efba9b42" translate="yes" xml:space="preserve">
          <source>While a &lt;a href=&quot;qml-qtquick-multipointtoucharea&quot;&gt;MultiPointTouchArea&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-multipointtoucharea&quot;&gt;MultiPointTouchArea&lt;/a&gt; 동안</target>
        </trans-unit>
        <trans-unit id="9b959e54026f44244ceaee1db91eabf22b5bfbf5" translate="yes" xml:space="preserve">
          <source>While a MultiPointTouchArea</source>
          <target state="translated">MultiPointTouchArea 동안</target>
        </trans-unit>
        <trans-unit id="2be60205fdac058f6976a555c3e4b7cf8fccfd3c" translate="yes" xml:space="preserve">
          <source>While a drag is active any change in an item's position will send a QDragMove event with item's new position to the scene.</source>
          <target state="translated">드래그가 활성화 된 상태에서 항목 위치를 변경하면 항목의 새로운 위치가있는 QDragMove 이벤트가 장면에 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="64fdcb92b68611667252ebd05f072432ecdbc0e3" translate="yes" xml:space="preserve">
          <source>While a drag is active this property holds the last object to accept an enter event from the dragged item, if the current drag position doesn't intersect any accepting targets it is null.</source>
          <target state="translated">드래그가 활성화되어있는 동안이 속성은 드래그 한 항목에서 enter 이벤트를 수락하기 위해 마지막 객체를 유지합니다. 현재 드래그 위치가 허용되는 대상과 교차하지 않으면 null입니다.</target>
        </trans-unit>
        <trans-unit id="247ae0dc4720cc9ae6c9b6dc97a0b81e78b8ae50" translate="yes" xml:space="preserve">
          <source>While a macro is being composed, the stack is disabled. This means that:</source>
          <target state="translated">매크로가 구성되는 동안 스택이 비활성화됩니다. 이것은 다음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="22ccfc8a81c58bbd58008c5dfd34ce0aeb43404c" translate="yes" xml:space="preserve">
          <source>While adding a 2D item tree into the 3D scene is fairly cheap, excess amounts (hundreds or more) of 2D subtrees within the 3D scene should be avoided, because in large amounts this may lead to increased memory and graphics resource usage. Note that this refers to the number of separate &lt;a href=&quot;qml-qtquick-item&quot;&gt;Item&lt;/a&gt; subtrees under 3D nodes, not the total number of 2D items in those subtrees. For example, the QML snippet above contains only one 2D subtree.</source>
          <target state="translated">2D 항목 트리를 3D 장면에 추가하는 것은 상당히 저렴하지만 3D 장면 내에서 2D 하위 트리의 양 (수백 개 이상)을 초과하는 것은 피해야합니다. 이는 많은 양이 메모리 및 그래픽 리소스 사용량을 증가시킬 수 있기 때문입니다. 이는 해당 하위 트리의 총 2D 항목 수가 아니라 3D 노드 아래 의 개별 &lt;a href=&quot;qml-qtquick-item&quot;&gt;항목&lt;/a&gt; 하위 트리 수를 나타냅니다 . 예를 들어 위의 QML 스 니펫에는 2D 하위 트리가 하나만 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a2a381df229651fb2b9af1341ddde4ce9fc06a2" translate="yes" xml:space="preserve">
          <source>While an address is preferred, it may be used by the operating system as the source address for new, outgoing packets. After it becomes deprecated, it will remain valid for incoming packets for a while longer until finally removed (see &lt;a href=&quot;qnetworkaddressentry#validityLifetime&quot;&gt;validityLifetime&lt;/a&gt;()).</source>
          <target state="translated">주소가 선호되지만 운영 체제에서 새 발신 패킷의 소스 주소로 사용할 수 있습니다. 더 이상 사용되지 않는 후에는 마지막으로 제거 될 때까지 한동안 수신 패킷에 대해 계속 유효합니다 ( &lt;a href=&quot;qnetworkaddressentry#validityLifetime&quot;&gt;validityLifetime&lt;/a&gt; () 참조 ).</target>
        </trans-unit>
        <trans-unit id="a60f8140c28c40aa06364e2fef4119b3f1df6143" translate="yes" xml:space="preserve">
          <source>While an address is valid, it will be accepted by the operating system as a valid destination address for this machine. Whether it is used as a source address for new, outgoing packets is controlled by, among other rules, the preferred lifetime (see &lt;a href=&quot;qnetworkaddressentry#preferredLifetime&quot;&gt;preferredLifetime&lt;/a&gt;()).</source>
          <target state="translated">주소는 유효하지만 운영 체제에서는이 시스템의 유효한 대상 주소로 허용합니다. 새로운 발신 패킷의 소스 주소로 사용되는지 여부는 다른 규칙 중에서 선호 수명 ( &lt;a href=&quot;qnetworkaddressentry#preferredLifetime&quot;&gt;preferredLifetime&lt;/a&gt; () 참조 )에 의해 제어됩니다 .</target>
        </trans-unit>
        <trans-unit id="8e73dec0fd5276fb04a6a4d81f2ba3c17a6241b7" translate="yes" xml:space="preserve">
          <source>While both the left and the right mouse button are pressed, mouse movement along y-axis zooms the camera in and out without changing the view center.</source>
          <target state="translated">왼쪽 및 오른쪽 마우스 버튼을 모두 누른 상태에서 y 축을 따라 마우스를 움직이면 뷰 중심을 변경하지 않고 카메라를 확대 및 축소합니다.</target>
        </trans-unit>
        <trans-unit id="37dcf4f1f9a6dc145fe2352f6113680e83b3cfc9" translate="yes" xml:space="preserve">
          <source>While determining the line-break positions take into account the space added for drawing a separator character.</source>
          <target state="translated">줄 바꿈 위치를 결정하는 동안 구분 문자를 그리기 위해 추가 된 공간을 고려합니다.</target>
        </trans-unit>
        <trans-unit id="097e642748a4c03d61bb9e6313a60b0554cb6e9e" translate="yes" xml:space="preserve">
          <source>While disabled by default, multisample antialiasing is fully supported by &lt;a href=&quot;qvulkanwindow&quot;&gt;QVulkanWindow&lt;/a&gt;. Additional color buffers and resolving into the swapchain's non-multisample buffers are all managed automatically.</source>
          <target state="translated">기본적으로 비활성화되어 있지만 &lt;a href=&quot;qvulkanwindow&quot;&gt;다중&lt;/a&gt; 샘플 앤티 앨리어싱은 QVulkanWindow에서 완전히 지원됩니다 . 추가 컬러 버퍼 및 스왑 체인의 비 멀티 샘플 버퍼로의 해결은 모두 자동으로 관리됩니다.</target>
        </trans-unit>
        <trans-unit id="a4b0c4e696c9c6c84624775ee4ad3557f8221ec2" translate="yes" xml:space="preserve">
          <source>While disabled by default, multisample antialiasing is fully supported by QVulkanWindow. Additional color buffers and resolving into the swapchain's non-multisample buffers are all managed automatically.</source>
          <target state="translated">기본적으로 비활성화되어 있지만 멀티 샘플 안티 앨리어싱은 QVulkanWindow에서 완벽하게 지원됩니다. 추가 컬러 버퍼와 스왑 체인의 멀티 샘플이 아닌 버퍼로의 해석은 모두 자동으로 관리됩니다.</target>
        </trans-unit>
        <trans-unit id="cc493c81f134da0d8d432b045a7b6c1b96604a9a" translate="yes" xml:space="preserve">
          <source>While future versions of QML should be able to handle this situation more gracefully, there are currently several ways to rework your application to avoid this problem.</source>
          <target state="translated">향후 버전의 QML에서이 상황을보다 적절하게 처리 할 수 ​​있지만 현재이 문제를 피하기 위해 응용 프로그램을 재 작업하는 몇 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="15fb18a74816c4333c9f8ad309dfcbc4e6433902" translate="yes" xml:space="preserve">
          <source>While it is composing an input method may rely on mouse or key events from the &lt;a href=&quot;qml-qtquick-controls-combobox&quot;&gt;ComboBox&lt;/a&gt; to edit or commit the partial text. This property can be used to determine when to disable events handlers that may interfere with the correct operation of an input method.</source>
          <target state="translated">입력 방법을 구성하는 동안 입력 방법은 &lt;a href=&quot;qml-qtquick-controls-combobox&quot;&gt;ComboBox의&lt;/a&gt; 마우스 또는 키 이벤트를 사용 하여 부분 텍스트를 편집하거나 커밋 할 수 있습니다. 이 특성은 입력 메소드의 올바른 조작을 방해 할 수있는 이벤트 핸들러를 사용 불가능하게하는시기를 판별하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0466a621b603d8099a666cbf3e7b909d22a359a" translate="yes" xml:space="preserve">
          <source>While it is composing an input method may rely on mouse or key events from the &lt;a href=&quot;qml-qtquick-controls-spinbox&quot;&gt;SpinBox&lt;/a&gt; to edit or commit the partial text. This property can be used to determine when to disable events handlers that may interfere with the correct operation of an input method.</source>
          <target state="translated">입력 방법을 구성하는 동안 입력 방법은 &lt;a href=&quot;qml-qtquick-controls-spinbox&quot;&gt;SpinBox의&lt;/a&gt; 마우스 또는 키 이벤트에 의존 하여 부분 텍스트를 편집하거나 커밋 할 수 있습니다. 이 특성은 입력 메소드의 올바른 조작을 방해 할 수있는 이벤트 핸들러를 사용 불가능하게하는시기를 판별하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="67890a4a1a8bd48d3e98cca62e936d86fb94fba6" translate="yes" xml:space="preserve">
          <source>While it is composing an input method may rely on mouse or key events from the &lt;a href=&quot;qml-qtquick-controls-textarea&quot;&gt;TextArea&lt;/a&gt; to edit or commit the partial text. This property can be used to determine when to disable events handlers that may interfere with the correct operation of an input method.</source>
          <target state="translated">입력 방법을 구성하는 동안 입력 방법은 &lt;a href=&quot;qml-qtquick-controls-textarea&quot;&gt;TextArea의&lt;/a&gt; 마우스 또는 키 이벤트에 의존 하여 부분 텍스트를 편집하거나 커밋 할 수 있습니다. 이 특성은 입력 메소드의 올바른 조작을 방해 할 수있는 이벤트 핸들러를 사용 불가능하게하는시기를 판별하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee371465fb28bf9a9949849a252c923b3f791e81" translate="yes" xml:space="preserve">
          <source>While it is composing an input method may rely on mouse or key events from the &lt;a href=&quot;qml-qtquick-controls-textfield&quot;&gt;TextField&lt;/a&gt; to edit or commit the partial text. This property can be used to determine when to disable events handlers that may interfere with the correct operation of an input method.</source>
          <target state="translated">입력 방법을 구성하는 동안 입력 방법은 &lt;a href=&quot;qml-qtquick-controls-textfield&quot;&gt;TextField의&lt;/a&gt; 마우스 또는 키 이벤트를 사용 하여 부분 텍스트를 편집하거나 커밋 할 수 있습니다. 이 특성은 입력 메소드의 올바른 조작을 방해 할 수있는 이벤트 핸들러를 사용 불가능하게하는시기를 판별하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="906c9a011624e84967f351e402a95c8ae3f33f47" translate="yes" xml:space="preserve">
          <source>While it is composing an input method may rely on mouse or key events from the &lt;a href=&quot;qml-qtquick-textedit&quot;&gt;TextEdit&lt;/a&gt; to edit or commit the partial text. This property can be used to determine when to disable events handlers that may interfere with the correct operation of an input method.</source>
          <target state="translated">입력 방법을 구성하는 동안 입력 방법은 &lt;a href=&quot;qml-qtquick-textedit&quot;&gt;TextEdit의&lt;/a&gt; 마우스 또는 키 이벤트에 의존 하여 부분 텍스트를 편집하거나 커밋 할 수 있습니다. 이 특성은 입력 메소드의 올바른 조작을 방해 할 수있는 이벤트 핸들러를 사용 불가능하게하는시기를 판별하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="99aaa194e92ccb9db37b15111ae52bc3f39b615c" translate="yes" xml:space="preserve">
          <source>While it is composing an input method may rely on mouse or key events from the &lt;a href=&quot;qml-qtquick-textinput&quot;&gt;TextInput&lt;/a&gt; to edit or commit the partial text. This property can be used to determine when to disable events handlers that may interfere with the correct operation of an input method.</source>
          <target state="translated">이 입력 방법은에서 마우스 나 키 이벤트에 의존 할 수 구성하는 동안 &lt;a href=&quot;qml-qtquick-textinput&quot;&gt;의 TextInput&lt;/a&gt; 편집 또는 부분 텍스트를 커밋합니다. 이 특성은 입력 메소드의 올바른 조작을 방해 할 수있는 이벤트 핸들러를 사용 불가능하게하는시기를 판별하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="30b6907453cc980cea56c0043dbb5616963a3884" translate="yes" xml:space="preserve">
          <source>While it is composing, an input method may rely on mouse or key events from the combo box to edit or commit the partial text. This property can be used to determine when to disable event handlers that may interfere with the correct operation of an input method.</source>
          <target state="translated">작성하는 동안 입력 방법은 콤보 상자의 마우스 또는 키 이벤트를 사용하여 부분 텍스트를 편집하거나 커밋 할 수 있습니다. 이 특성은 입력 메소드의 올바른 조작을 방해 할 수있는 이벤트 핸들러를 사용 불가능하게하는시기를 판별하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f2dab60a71379a492f0e39b6fc63d2e821e5fdd4" translate="yes" xml:space="preserve">
          <source>While it is composing, an input method may rely on mouse or key events from the spin box to edit or commit the partial text. This property can be used to determine when to disable event handlers that may interfere with the correct operation of an input method.</source>
          <target state="translated">작성하는 동안 입력 방법은 스핀 상자의 마우스 또는 키 이벤트를 사용하여 부분 텍스트를 편집하거나 커밋 할 수 있습니다. 이 특성은 입력 메소드의 올바른 조작을 방해 할 수있는 이벤트 핸들러를 사용 불가능하게하는시기를 판별하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="069a6a0bb496e21a470f5f44072de4e196f8f174" translate="yes" xml:space="preserve">
          <source>While it is possible to create complex animations by nesting &lt;a href=&quot;qml-qtquick-sequentialanimation&quot;&gt;SequentialAnimation&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-parallelanimation&quot;&gt;ParallelAnimation&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-numberanimation&quot;&gt;NumberAnimation&lt;/a&gt;, it is generally more convenient to use &lt;a href=&quot;https://doc.qt.io/qt-6.0/qtquicktimeline-overview.html&quot;&gt;timeline animations&lt;/a&gt; for animating skinned models.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-sequentialanimation&quot;&gt;SequentialAnimation&lt;/a&gt; , &lt;a href=&quot;qml-qtquick-parallelanimation&quot;&gt;ParallelAnimation&lt;/a&gt; 및 &lt;a href=&quot;qml-qtquick-numberanimation&quot;&gt;NumberAnimation&lt;/a&gt; 을 중첩하여 복잡한 애니메이션을 만들 수 있지만 일반적으로 스킨 된 모델을 애니메이션 하는 데 &lt;a href=&quot;https://doc.qt.io/qt-6.0/qtquicktimeline-overview.html&quot;&gt;타임 라인 애니메이션&lt;/a&gt; 을 사용하는 것이 더 편리합니다 .</target>
        </trans-unit>
        <trans-unit id="c27c4b353a9047c17a52a5e4e759a2368954c6a2" translate="yes" xml:space="preserve">
          <source>While it is possible to implement this RPC-style behavior in QtRO, as Sources without properties, and slots that have return values, QtRO hides the fact that the processing is really remote. You let a node give you the Replica instead of creating it yourself, possibly use the status signals (&lt;a href=&quot;qremoteobjectreplica#isReplicaValid&quot;&gt;isReplicaValid()&lt;/a&gt;), but then interact with the object like you would with any other &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;-based type.</source>
          <target state="translated">QtRO에서이 RPC 스타일 동작을 속성이없는 소스 및 반환 값이있는 슬롯으로 구현할 수 있지만 QtRO는 처리가 실제로 원격이라는 사실을 숨 깁니다. 노드가 직접 복제하지 않고 복제본을 제공하도록하고 상태 신호 ( &lt;a href=&quot;qremoteobjectreplica#isReplicaValid&quot;&gt;isReplicaValid ()&lt;/a&gt; )를 사용하지만 다른 &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 기반 유형 과 마찬가지로 개체와 상호 작용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9c0e4e02be847126b0fd3cb6759e533d4badf024" translate="yes" xml:space="preserve">
          <source>While it is possible to specify a &lt;a href=&quot;qsurfaceformat&quot;&gt;QSurfaceFormat&lt;/a&gt; for every &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt; by calling the member function &lt;a href=&quot;qwindow#setFormat&quot;&gt;setFormat&lt;/a&gt;(), windows may also be created from QML by using the Window and &lt;a href=&quot;qml-qtquick-controls-applicationwindow&quot;&gt;ApplicationWindow&lt;/a&gt; elements. In this case there is no C++ code involved in the creation of the window instance, yet applications may still wish to set certain surface format values, for example to request a given OpenGL version or profile. Such applications can call the static function &lt;a href=&quot;qsurfaceformat#setDefaultFormat&quot;&gt;QSurfaceFormat::setDefaultFormat&lt;/a&gt;() at startup. The specified format will be used for all Quick windows created afterwards.</source>
          <target state="translated">멤버 함수 &lt;a href=&quot;qwindow#setFormat&quot;&gt;setFormat&lt;/a&gt; () 을 호출하여 모든 &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt; 에 대해 &lt;a href=&quot;qsurfaceformat&quot;&gt;QSurfaceFormat&lt;/a&gt; 을 지정할 수 있지만 Window 및 &lt;a href=&quot;qml-qtquick-controls-applicationwindow&quot;&gt;ApplicationWindow&lt;/a&gt; 요소를 사용하여 QML에서 창을 작성할 수도 있습니다 . 이 경우 윈도우 인스턴스 생성과 관련된 C ++ 코드는 없지만 응용 프로그램은 특정 OpenGL 버전 또는 프로파일을 요청하기 위해 특정 표면 형식 값을 설정하고자 할 수 있습니다. 이러한 응용 프로그램은 시작할 때 정적 함수 &lt;a href=&quot;qsurfaceformat#setDefaultFormat&quot;&gt;QSurfaceFormat :: setDefaultFormat&lt;/a&gt; ()을 호출 할 수 있습니다 . 지정된 형식은 이후에 생성 된 모든 빠른 창에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="588eb2b8408f7414400ddc0b28377391fa01e003" translate="yes" xml:space="preserve">
          <source>While it is possible to specify a &lt;a href=&quot;qsurfaceformat&quot;&gt;QSurfaceFormat&lt;/a&gt; for every QQuickWindow by calling the member function &lt;a href=&quot;qwindow#setFormat&quot;&gt;setFormat&lt;/a&gt;(), windows may also be created from QML by using the Window and &lt;a href=&quot;qml-qtquick-controls2-applicationwindow&quot;&gt;ApplicationWindow&lt;/a&gt; elements. In this case there is no C++ code involved in the creation of the window instance, yet applications may still wish to set certain surface format values, for example to request a given OpenGL version or profile. Such applications can call the static function &lt;a href=&quot;qsurfaceformat#setDefaultFormat&quot;&gt;QSurfaceFormat::setDefaultFormat&lt;/a&gt;() at startup. The specified format will be used for all Quick windows created afterwards.</source>
          <target state="translated">멤버 함수 &lt;a href=&quot;qwindow#setFormat&quot;&gt;setFormat&lt;/a&gt; () 을 호출하여 모든 QQuickWindow에 대해 &lt;a href=&quot;qsurfaceformat&quot;&gt;QSurfaceFormat&lt;/a&gt; 을 지정할 수 있지만 Window 및 &lt;a href=&quot;qml-qtquick-controls2-applicationwindow&quot;&gt;ApplicationWindow&lt;/a&gt; 요소를 사용하여 QML에서 창을 만들 수도 있습니다 . 이 경우 창 인스턴스 생성과 관련된 C ++ 코드가 없지만 응용 프로그램은 특정 표면 형식 값을 설정하려고 할 수 있습니다 (예 : 주어진 OpenGL 버전 또는 프로필 요청). 이러한 응용 프로그램은 시작시 정적 함수 &lt;a href=&quot;qsurfaceformat#setDefaultFormat&quot;&gt;QSurfaceFormat :: setDefaultFormat&lt;/a&gt; ()을 호출 할 수 있습니다 . 지정된 형식은 이후에 생성되는 모든 빠른 창에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5ffd992bca64b3df8820aad156dff57860726a0e" translate="yes" xml:space="preserve">
          <source>While it is possible to specify a &lt;a href=&quot;qsurfaceformat&quot;&gt;QSurfaceFormat&lt;/a&gt; for every QQuickWindow by calling the member function &lt;a href=&quot;qwindow#setFormat&quot;&gt;setFormat&lt;/a&gt;(), windows may also be created from QML by using the Window and &lt;a href=&quot;qtquickcontrols-changes-qt6#applicationwindow&quot;&gt;ApplicationWindow&lt;/a&gt; elements. In this case there is no C++ code involved in the creation of the window instance, yet applications may still wish to set certain surface format values, for example to request a given OpenGL version or profile. Such applications can call the static function &lt;a href=&quot;qsurfaceformat#setDefaultFormat&quot;&gt;QSurfaceFormat::setDefaultFormat&lt;/a&gt;() at startup. The specified format will be used for all Quick windows created afterwards.</source>
          <target state="translated">멤버 함수 &lt;a href=&quot;qwindow#setFormat&quot;&gt;setFormat&lt;/a&gt; () 을 호출하여 모든 QQuickWindow에 대해 &lt;a href=&quot;qsurfaceformat&quot;&gt;QSurfaceFormat&lt;/a&gt; 을 지정할 수 있지만 Window 및 &lt;a href=&quot;qtquickcontrols-changes-qt6#applicationwindow&quot;&gt;ApplicationWindow&lt;/a&gt; 요소를 사용하여 QML에서 창을 만들 수도 있습니다 . 이 경우 창 인스턴스 생성에 관련된 C ++ 코드가 없지만 응용 프로그램은 특정 표면 형식 값을 설정하려고 할 수 있습니다 (예 : 주어진 OpenGL 버전 또는 프로필 요청). 이러한 응용 프로그램은 시작시 정적 함수 &lt;a href=&quot;qsurfaceformat#setDefaultFormat&quot;&gt;QSurfaceFormat :: setDefaultFormat&lt;/a&gt; ()을 호출 할 수 있습니다 . 지정된 형식은 이후에 생성되는 모든 빠른 창에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d036a10c64b9ec62641a8f90891f12d594f9c476" translate="yes" xml:space="preserve">
          <source>While it is possible to use &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; as a base class without the &lt;a href=&quot;qobject#Q_OBJECT&quot;&gt;Q_OBJECT&lt;/a&gt; macro and without meta-object code, neither signals and slots nor the other features described here will be available if the &lt;a href=&quot;qobject#Q_OBJECT&quot;&gt;Q_OBJECT&lt;/a&gt; macro is not used. From the meta-object system's point of view, a &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; subclass without meta code is equivalent to its closest ancestor with meta-object code. This means for example, that &lt;a href=&quot;qmetaobject#className&quot;&gt;QMetaObject::className&lt;/a&gt;() will not return the actual name of your class, but the class name of this ancestor.</source>
          <target state="translated">사용 가능하지 않지만 &lt;a href=&quot;qobject&quot;&gt;있는 QObject를&lt;/a&gt; 를 빼고 기본 클래스 &lt;a href=&quot;qobject#Q_OBJECT&quot;&gt;Q_OBJECT의&lt;/a&gt; 매크로 메타 오브젝트 코드없이, 어느 쪽 신호 슬롯이나 다른 특징이 경우 사용할 수 여기서 설명 &lt;a href=&quot;qobject#Q_OBJECT&quot;&gt;Q_OBJECT의&lt;/a&gt; 매크로가 사용되지 않는다. 메타 오브젝트 시스템의 관점에서 메타 코드가없는 &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 서브 클래스는 메타 오브젝트 코드가있는 가장 가까운 조상과 같습니다. 예를 들어 &lt;a href=&quot;qmetaobject#className&quot;&gt;QMetaObject :: className&lt;/a&gt; ()은 클래스의 실제 이름을 반환하지 않고이 조상의 클래스 이름을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b1bd735d79c63a934856f518d3884332e545cd51" translate="yes" xml:space="preserve">
          <source>While it's not necessary for modern touch screens, some resistive, single-touch touch screens may require that you fallback to using &lt;code&gt;tslib&lt;/code&gt; instead of relying on the Linux multi-touch protocol and the event devices.</source>
          <target state="translated">최신 터치 스크린에는 필요하지 않지만 일부 저항성, 단일 터치 터치 스크린 에서는 Linux 멀티 터치 프로토콜 및 이벤트 장치에 의존하는 대신 &lt;code&gt;tslib&lt;/code&gt; 를 사용 하도록 대체해야 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="00116c5d770003a6be6fa449a53e06f8fa0b3b92" translate="yes" xml:space="preserve">
          <source>While many applications will be fine with the default behavior of &lt;a href=&quot;qvulkanwindow&quot;&gt;QVulkanWindow&lt;/a&gt; when it comes to swapchain image formats, &lt;a href=&quot;qvulkanwindow#setPreferredColorFormats&quot;&gt;setPreferredColorFormats&lt;/a&gt;() allows requesting a pre-defined format. This is useful most notably when working in the sRGB color space. Passing a format like &lt;code&gt;VK_FORMAT_B8G8R8A8_SRGB&lt;/code&gt; results in choosing an sRGB format, when available.</source>
          <target state="translated">&lt;a href=&quot;qvulkanwindow&quot;&gt;스왑 체인&lt;/a&gt; 이미지 형식과 관련하여 QVulkanWindow 의 기본 동작으로 많은 응용 프로그램이 적합하지만 &lt;a href=&quot;qvulkanwindow#setPreferredColorFormats&quot;&gt;setPreferredColorFormats&lt;/a&gt; ()를 사용하면 미리 정의 된 형식을 요청할 수 있습니다. sRGB 색상 공간에서 작업 할 때 가장 유용합니다. &lt;code&gt;VK_FORMAT_B8G8R8A8_SRGB&lt;/code&gt; 와 같은 형식을 전달 하면 사용 가능한 경우 sRGB 형식을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="8a2d57746c5d049a964b836436995db7b2faf9e5" translate="yes" xml:space="preserve">
          <source>While many applications will be fine with the default behavior of QVulkanWindow when it comes to swapchain image formats, &lt;a href=&quot;qvulkanwindow#setPreferredColorFormats&quot;&gt;setPreferredColorFormats&lt;/a&gt;() allows requesting a pre-defined format. This is useful most notably when working in the sRGB color space. Passing a format like &lt;code&gt;VK_FORMAT_B8G8R8A8_SRGB&lt;/code&gt; results in choosing an sRGB format, when available.</source>
          <target state="translated">스왑 체인 이미지 형식과 관련하여 많은 응용 프로그램이 QVulkanWindow의 기본 동작을 사용하는 것이 좋지만 &lt;a href=&quot;qvulkanwindow#setPreferredColorFormats&quot;&gt;setPreferredColorFormats&lt;/a&gt; ()를 사용하면 미리 정의 된 형식을 요청할 수 있습니다. 이것은 sRGB 색 공간에서 작업 할 때 특히 유용합니다. &lt;code&gt;VK_FORMAT_B8G8R8A8_SRGB&lt;/code&gt; 와 같은 형식을 전달 하면 사용 가능한 경우 sRGB 형식이 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="7caa3c55c15a9e4c6b92a5f5323d4e687f6eb1af" translate="yes" xml:space="preserve">
          <source>While mapped the contents of a video frame can be accessed directly through the pointer returned by the &lt;a href=&quot;qvideoframe#bits&quot;&gt;bits&lt;/a&gt;() function.</source>
          <target state="translated">매핑 된 동안 비디오 프레임의 내용은 &lt;a href=&quot;qvideoframe#bits&quot;&gt;비트&lt;/a&gt; () 함수에 의해 반환 된 포인터를 통해 직접 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="45e6d91218c65ba74df0c36e01a88a27f955cb3a" translate="yes" xml:space="preserve">
          <source>While navigating the results in forward-only mode, the handle of &lt;a href=&quot;qsqlresult&quot;&gt;QSqlResult&lt;/a&gt; may change. Applications that use the low-level handle of SQL result must get a new handle after each call to any of &lt;a href=&quot;qsqlresult&quot;&gt;QSqlResult&lt;/a&gt; fetch functions. Example:</source>
          <target state="translated">정방향 전용 모드에서 결과를 탐색하는 동안 &lt;a href=&quot;qsqlresult&quot;&gt;QSqlResult&lt;/a&gt; 의 핸들 이 변경 될 수 있습니다. 저수준 SQL 결과 핸들을 사용하는 응용 프로그램은 &lt;a href=&quot;qsqlresult&quot;&gt;QSqlResult&lt;/a&gt; 페치 함수를 호출 할 때마다 새 핸들을 가져와야합니다. 예:</target>
        </trans-unit>
        <trans-unit id="d5704d0e1830aca0738fcc7114f136a7e87d7f0e" translate="yes" xml:space="preserve">
          <source>While not strictly required, the typical usage is to inherit from this class. The subclass is then exposed to QML by registering it to the type system. The &lt;a href=&quot;qml-qtquick3d-model#geometry-prop&quot;&gt;geometry&lt;/a&gt; property of a Model can then be set to reference an instance of the registered type.</source>
          <target state="translated">꼭 필요한 것은 아니지만 일반적인 사용법은이 클래스에서 상속하는 것입니다. 그런 다음 하위 클래스를 유형 시스템에 등록하여 QML에 노출합니다. 그런 다음 등록 된 유형의 인스턴스를 참조하도록 모델 의 &lt;a href=&quot;qml-qtquick3d-model#geometry-prop&quot;&gt;지오메트리&lt;/a&gt; 속성을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="267b16b9caaea63b7c9b12c77bfdbff984b8309c" translate="yes" xml:space="preserve">
          <source>While not strictly required, the typical usage is to inherit from this class. The subclass is then exposed to QML by registering it to the type system. The &lt;a href=&quot;qml-qtquick3d-texture#textureData-prop&quot;&gt;textureData&lt;/a&gt; property of a &lt;a href=&quot;qml-qtquick3d-texture&quot;&gt;Texture&lt;/a&gt; can then be set to reference an instance of the registered type.</source>
          <target state="translated">꼭 필요한 것은 아니지만 일반적인 사용법은이 클래스에서 상속하는 것입니다. 그런 다음 하위 클래스를 유형 시스템에 등록하여 QML에 노출합니다. 그런 다음 &lt;a href=&quot;qml-qtquick3d-texture&quot;&gt;Texture&lt;/a&gt; 의 &lt;a href=&quot;qml-qtquick3d-texture#textureData-prop&quot;&gt;textureData&lt;/a&gt; 속성은 등록 된 유형의 인스턴스를 참조하도록 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e4eed71ab9ac65e6204cd8a210e65b08c5bb6b65" translate="yes" xml:space="preserve">
          <source>While not the default for &lt;a href=&quot;qtquick-index&quot;&gt;Qt Quick&lt;/a&gt;, OpenGL is still commonly used in many Qt applications, for example in &lt;a href=&quot;widgets-changes-qt6#qwidget&quot;&gt;QWidget&lt;/a&gt;-based applications building on &lt;a href=&quot;qopenglwindow&quot;&gt;QOpenGLWindow&lt;/a&gt; or &lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt;. The following sections cover some OpenGL specifics of a Qt build.</source>
          <target state="translated">&lt;a href=&quot;qtquick-index&quot;&gt;Qt Quick&lt;/a&gt; 의 기본값은 아니지만 OpenGL은 여전히 ​​많은 Qt 응용 프로그램에서 일반적으로 사용됩니다 (예 : &lt;a href=&quot;qopenglwindow&quot;&gt;QOpenGLWindow&lt;/a&gt; 또는 &lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt; 에서 빌드 되는 &lt;a href=&quot;widgets-changes-qt6#qwidget&quot;&gt;QWidget&lt;/a&gt; 기반 응용 프로그램) . 다음 섹션에서는 Qt 빌드의 일부 OpenGL 사양을 다룹니다.</target>
        </trans-unit>
        <trans-unit id="13af66f226f16c92acb9212a88a7d8e27f29fa0c" translate="yes" xml:space="preserve">
          <source>While on some platforms this will be a no-op, some may perform windowing system dependent synchronization. For example, on Wayland this will add send a wl_surface.frame request in order to prevent the driver from blocking for minimized windows.</source>
          <target state="translated">일부 플랫폼에서는 이것이 작동하지 않지만 일부는 윈도우 시스템 종속 동기화를 수행 할 수 있습니다. 예를 들어 Wayland에서는 드라이버가 최소화 된 창을 차단하는 것을 방지하기 위해 wl_surface.frame 요청을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="19a0ca3fe34ef687144b8c5cae796cac1b5dca67" translate="yes" xml:space="preserve">
          <source>While on some platforms this will be a no-op, some may perform windowing system dependent synchronization. For example, on X11 this will update &lt;code&gt;_NET_WM_SYNC_REQUEST_COUNTER&lt;/code&gt;.</source>
          <target state="translated">일부 플랫폼에서는 이것이 작동하지 않지만 일부는 윈도우 시스템 종속 동기화를 수행 할 수 있습니다. 예를 들어 X11에서는 &lt;code&gt;_NET_WM_SYNC_REQUEST_COUNTER&lt;/code&gt; 가 업데이트 됩니다 .</target>
        </trans-unit>
        <trans-unit id="ec118cf91cb7bab4a1355e9d50cae4dc0e6da10a" translate="yes" xml:space="preserve">
          <source>While reading the results of a forward-only query with PostgreSQL, the database connection cannot be used to execute other queries. This is a limitation of libpq library. Example:</source>
          <target state="translated">PostgreSQL로 정방향 쿼리의 결과를 읽는 동안 데이터베이스 연결을 사용하여 다른 쿼리를 실행할 수 없습니다. 이것은 libpq 라이브러리의 제한 사항입니다. 예:</target>
        </trans-unit>
        <trans-unit id="39b99b5cba25006c2627aba1051f9c2cb6e01931" translate="yes" xml:space="preserve">
          <source>While syntactically identical, the way 2D child items are handled is quite different internally. In Qt 6.0 there is no implicit render to texture step. Rather, the 2D Qt Quick content is rendered in line, with the appropriate perspective projection, in the same render pass, which provides better performance, lower resource usage, and in some cases potentially improved visual fidelity (with &lt;a href=&quot;qml-qtquick-text&quot;&gt;Text&lt;/a&gt;, for example). See &lt;a href=&quot;qtquick3d-2d&quot;&gt;Qt Quick 3D Scenes with 2D Content&lt;/a&gt; for an overview.</source>
          <target state="translated">구문은 동일하지만 2D 하위 항목이 처리되는 방식은 내부적으로 상당히 다릅니다. Qt 6.0에는 텍스처 단계에 대한 암시 적 렌더링이 없습니다. 오히려 2D Qt Quick 콘텐츠는 동일한 렌더 패스에서 적절한 원근 투영을 사용하여 일렬로 렌더링되어 더 나은 성능, 낮은 리소스 사용, 경우에 따라 잠재적으로 향상된 시각적 충실도 ( 예 : &lt;a href=&quot;qml-qtquick-text&quot;&gt;Text 사용&lt;/a&gt; )를 제공합니다. 개요 &lt;a href=&quot;qtquick3d-2d&quot;&gt;는 2D 콘텐츠&lt;/a&gt; 가있는 Qt 빠른 3D 장면을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3c8ae4c94f6e1a743964b2192598896bed81eaf5" translate="yes" xml:space="preserve">
          <source>While the 2D items are rended in-line with 3D objects, they do not participate in lighting, and will not be casting shadows.</source>
          <target state="translated">2D 항목은 3D 개체와 인라인으로 렌더링되지만 조명에 참여하지 않으며 그림자를 드리 우지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3f23969546517ae0fc928eb331bb4454b78e90fa" translate="yes" xml:space="preserve">
          <source>While the &lt;a href=&quot;qremoteobjecthostbase#proxy&quot;&gt;proxy&lt;/a&gt;() functionality allows &lt;a href=&quot;qtremoteobjects-source#source&quot;&gt;Source&lt;/a&gt; objects on another network to be acquired(), reverseProxy() allows &lt;a href=&quot;qtremoteobjects-source#source&quot;&gt;Source&lt;/a&gt; objects to be &quot;pushed&quot; to an otherwise inaccessible network.</source>
          <target state="translated">그동안 &lt;a href=&quot;qremoteobjecthostbase#proxy&quot;&gt;프록시&lt;/a&gt; () 기능을 허용 &lt;a href=&quot;qtremoteobjects-source#source&quot;&gt;자료가&lt;/a&gt; 다른 네트워크의 취득에 개체 () reverseProxy ()는 허용 &lt;a href=&quot;qtremoteobjects-source#source&quot;&gt;자료는&lt;/a&gt; 달리 액세스 네트워크로 &quot;푸시&quot;될 오브젝트.</target>
        </trans-unit>
        <trans-unit id="95dcf4df6cd449f4e72807f18f0a7e1c2207be7f" translate="yes" xml:space="preserve">
          <source>While the API is very similar, there is an important difference between the two: &lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt; always renders offscreen, using framebuffer objects. QGLWidget on the other hand uses a native window and surface. The latter causes issues when using it in complex user interfaces since, depending on the platform, such native child widgets may have various limitations, regarding stacking orders for example. &lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt; avoids this by not creating a separate native window.</source>
          <target state="translated">API는 매우 유사하지만이 둘 사이에는 중요한 차이점이 있습니다. &lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget은&lt;/a&gt; 항상 프레임 버퍼 객체를 사용하여 화면을 오프 스크린으로 렌더링합니다. 반면 QGLWidget은 기본 창과 표면을 사용합니다. 후자는 복잡한 사용자 인터페이스에서이를 사용할 때 문제를 일으킨다. 플랫폼에 따라 이러한 네이티브 하위 위젯은 예를 들어 스태킹 순서와 관련하여 다양한 제한이있을 수 있기 때문입니다. &lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt; 은 별도의 기본 창을 작성하지 않으므로 이를 방지합니다.</target>
        </trans-unit>
        <trans-unit id="45b78736fc537ea4149117477455ad4f321b16bb" translate="yes" xml:space="preserve">
          <source>While the API is very similar, there is an important difference between the two: QOpenGLWidget always renders offscreen, using framebuffer objects. QGLWidget on the other hand uses a native window and surface. The latter causes issues when using it in complex user interfaces since, depending on the platform, such native child widgets may have various limitations, regarding stacking orders for example. QOpenGLWidget avoids this by not creating a separate native window.</source>
          <target state="translated">API는 매우 유사하지만 둘 사이에는 중요한 차이점이 있습니다. QOpenGLWidget은 항상 프레임 버퍼 객체를 사용하여 화면 밖에서 렌더링합니다. 반면에 QGLWidget은 기본 창과 표면을 사용합니다. 후자는 복잡한 사용자 인터페이스에서 사용할 때 문제를 일으 킵니다. 플랫폼에 따라 이러한 기본 자식 위젯은 예를 들어 스택 순서와 관련하여 다양한 제한이있을 수 있기 때문입니다. QOpenGLWidget은 별도의 기본 창을 생성하지 않음으로써이를 방지합니다.</target>
        </trans-unit>
        <trans-unit id="217d5ce3e3111946893366d407e8970f2bee79c3" translate="yes" xml:space="preserve">
          <source>While the Navigator is in active tracking mode, this property tells whether the position from &lt;a href=&quot;qml-qt-labs-location-navigator#positionSource-prop&quot;&gt;positionSource&lt;/a&gt; is on the route or not.</source>
          <target state="translated">네비게이터가 활성 추적 모드에있는 동안이 속성은 positionSource의 &lt;a href=&quot;qml-qt-labs-location-navigator#positionSource-prop&quot;&gt;위치&lt;/a&gt; 가 경로에 있는지 여부를 알려줍니다 .</target>
        </trans-unit>
        <trans-unit id="b0c7bac6a26931f3dd8042bafc31473fb658a0dc" translate="yes" xml:space="preserve">
          <source>While the QML engine allows QML application to load images from filesystem or network resources, some applications may require the additional option of loading images from C++ based processes. This can be implemented through the &lt;a href=&quot;qquickimageprovider&quot;&gt;QQuickImageProvider&lt;/a&gt; class, which provides support for pixmap loading and threaded image requests for QML applications. Any QML application that requests an image through the special &quot;image:&quot; URL scheme will be directed to an appropriate image provider to load the image.</source>
          <target state="translated">QML 엔진을 사용하면 QML 애플리케이션이 파일 시스템 또는 네트워크 리소스에서 이미지를로드 할 수 있지만 일부 애플리케이션에는 C ++ 기반 프로세스에서 이미지를로드하는 추가 옵션이 필요할 수 있습니다. 이것은 &lt;a href=&quot;qquickimageprovider&quot;&gt;QQuickImageProvider&lt;/a&gt; 클래스를 통해 구현 될 수 있으며 , QML 애플리케이션에 대한 픽스맵 로딩 및 스레드 이미지 요청을 지원합니다. 특수한 &quot;image :&quot;URL 체계를 통해 이미지를 요청하는 모든 QML 응용 프로그램은 이미지를로드하기 위해 적절한 이미지 공급자로 보내집니다.</target>
        </trans-unit>
        <trans-unit id="ee656c10b36be3adf856d1d9d60459c249296f12" translate="yes" xml:space="preserve">
          <source>While the Qt Quick module already provides a rich library of visual item types for use in a QML application, some developers may wish to define their own item-derived types in C++ and expose them to the QML type system. The easiest way to do this is to subclass &lt;a href=&quot;qquickitem&quot;&gt;QQuickItem&lt;/a&gt;, which is the base type for all visual types in the Qt Quick module. See the &lt;a href=&quot;qquickitem&quot;&gt;QQuickItem&lt;/a&gt; documentation for more details.</source>
          <target state="translated">Qt Quick 모듈은 이미 QML 응용 프로그램에서 사용할 수있는 풍부한 시각적 항목 유형 라이브러리를 제공하지만 일부 개발자는 C ++에서 자체 항목 파생 유형을 정의하여 QML 유형 시스템에 노출하고자 할 수 있습니다. 가장 쉬운 방법 은 Qt Quick 모듈의 모든 비주얼 유형에 대한 기본 유형 인 &lt;a href=&quot;qquickitem&quot;&gt;QQuickItem&lt;/a&gt; 을 서브 클래 싱 하는 것입니다. 자세한 내용은 &lt;a href=&quot;qquickitem&quot;&gt;QQuickItem&lt;/a&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6b18fffad1b970f0544fddddb700de339361caab" translate="yes" xml:space="preserve">
          <source>While the RGB and HSV color models are used for display on computer monitors, the CMYK model is used in the four-color printing process of printing presses and some hard-copy devices.</source>
          <target state="translated">RGB 및 HSV 컬러 모델이 컴퓨터 모니터에 표시되는 데 사용되는 반면 CMYK 모델은 인쇄기 및 일부 하드 카피 장치의 4 색 인쇄 프로세스에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ea08020ac5982c94133bf1a8ad5929632038751a" translate="yes" xml:space="preserve">
          <source>While the built-in materials of Qt Quick 3D, &lt;a href=&quot;qml-qtquick3d-defaultmaterial&quot;&gt;DefaultMaterial&lt;/a&gt; and &lt;a href=&quot;qml-qtquick3d-principledmaterial&quot;&gt;PrincipledMaterial&lt;/a&gt;, allow a wide degree of customization via their properties, they do not provide programmability on the vertex and fragment shader level. To allow that, the &lt;a href=&quot;qml-qtquick3d-custommaterial&quot;&gt;CustomMaterial&lt;/a&gt; type is provided.</source>
          <target state="translated">Qt Quick 3D, &lt;a href=&quot;qml-qtquick3d-defaultmaterial&quot;&gt;DefaultMaterial&lt;/a&gt; 및 &lt;a href=&quot;qml-qtquick3d-principledmaterial&quot;&gt;PrincipledMaterial&lt;/a&gt; 의 기본 제공 재질은 속성을 통해 광범위한 사용자 정의를 허용하지만 정점 및 조각 셰이더 수준에서 프로그래밍 기능을 제공하지 않습니다. 이를 위해 &lt;a href=&quot;qml-qtquick3d-custommaterial&quot;&gt;CustomMaterial&lt;/a&gt; 유형이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="11e570f8e057d209301344726ad6db9a786ee25f" translate="yes" xml:space="preserve">
          <source>While the camera state is changed to &lt;a href=&quot;qcamera#State-enum&quot;&gt;QCamera::ActiveState&lt;/a&gt;, starting the camera service can be asynchronous with the actual status reported with &lt;a href=&quot;qcamera#status-prop&quot;&gt;QCamera::status&lt;/a&gt; property.</source>
          <target state="translated">카메라 상태가 &lt;a href=&quot;qcamera#State-enum&quot;&gt;QCamera :: ActiveState로&lt;/a&gt; 변경되는 동안 카메라 서비스 시작은 &lt;a href=&quot;qcamera#status-prop&quot;&gt;QCamera :: status&lt;/a&gt; 속성으로 보고 된 실제 상태와 비 동기화 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="214a66a92cca6a7dbdb605829f4f9982ba3fffe2" translate="yes" xml:space="preserve">
          <source>While the example is simple, there is a lot going on behind the scenes. Whenever the current item changes, the &lt;a href=&quot;qml-qtquick-listview&quot;&gt;ListView&lt;/a&gt; sets the delegate's &lt;code&gt;Item::focus&lt;/code&gt; property. As the &lt;a href=&quot;qml-qtquick-listview&quot;&gt;ListView&lt;/a&gt; is a focus scope, this doesn't affect the rest of the application. However, if the &lt;a href=&quot;qml-qtquick-listview&quot;&gt;ListView&lt;/a&gt; itself has active focus this causes the delegate itself to receive active focus. In this example, the root type of the delegate is also a focus scope, which in turn gives active focus to the &lt;code&gt;Text&lt;/code&gt; type that actually performs the work of handling the &lt;code&gt;Return&lt;/code&gt; key.</source>
          <target state="translated">예제는 간단하지만 뒤에서 많은 일이 있습니다. 현재 항목이 변경 될 때마다 &lt;a href=&quot;qml-qtquick-listview&quot;&gt;ListView&lt;/a&gt; 는 대리자의 &lt;code&gt;Item::focus&lt;/code&gt; 속성을 설정합니다 . 는 AS &lt;a href=&quot;qml-qtquick-listview&quot;&gt;의 ListView가&lt;/a&gt; 포커스 범위이며,이 응용 프로그램의 나머지 부분에 영향을주지 않습니다. 그러나 &lt;a href=&quot;qml-qtquick-listview&quot;&gt;ListView&lt;/a&gt; 자체에 포커스가 있으면 대리자 자체가 활성 포커스를받습니다. 이 예에서 델리게이트의 루트 유형은 포커스 범위이기도 하므로 &lt;code&gt;Return&lt;/code&gt; 키 를 처리하는 작업을 실제로 수행하는 &lt;code&gt;Text&lt;/code&gt; 유형에 포커스를 둡니다 .</target>
        </trans-unit>
        <trans-unit id="ff5c637f31b54b94be971c280f66902ea205e702" translate="yes" xml:space="preserve">
          <source>While the integer based functions take values in the range 0-255 (except &lt;a href=&quot;qcolor#hue&quot;&gt;hue&lt;/a&gt;() which must have values within the range 0-359), the floating point functions accept values in the range 0.0 - 1.0.</source>
          <target state="translated">정수 기반 함수는 0-255 범위의 값을 취하지 만 (0-359 범위 내의 값을 가져야하는 &lt;a href=&quot;qcolor#hue&quot;&gt;색조&lt;/a&gt; () 제외 ) 부동 소수점 함수는 0.0-1.0 범위의 값을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="7e88c44a246cc0acfeed178fecc66c12a45168dd" translate="yes" xml:space="preserve">
          <source>While the left mouse button is pressed, mouse movement along x-axis moves the camera left and right and movement along y-axis moves it up and down.</source>
          <target state="translated">마우스 왼쪽 버튼을 누르고있는 동안 x 축을 따라 마우스를 움직이면 카메라가 좌우로 움직이고 y 축을 따라 움직이면 위아래로 움직입니다.</target>
        </trans-unit>
        <trans-unit id="238539bec1e5de17e07b2d331eb50ed9a24ba8a1" translate="yes" xml:space="preserve">
          <source>While the left mouse button is pressed, mouse movement along x-axis pans the camera and movement along y-axis tilts it.</source>
          <target state="translated">마우스 왼쪽 버튼을 누르고있는 동안 x 축을 따라 마우스를 움직이면 카메라가 이동하고 y 축을 따라 움직이면 기울어집니다.</target>
        </trans-unit>
        <trans-unit id="956d26cf53341ebbab10aed503e09b8c67ae1e6c" translate="yes" xml:space="preserve">
          <source>While the macOS style fully supports high-DPI, the Windows desktop style currently has some limitations with certain scale factors. In these cases, consider using the Fusion style instead, which aims to support high-DPI in all cases.</source>
          <target state="translated">macOS 스타일은 높은 DPI를 완벽하게 지원하지만 Windows 데스크톱 스타일은 현재 특정 배율로 인해 일부 제한이 있습니다. 이 경우 모든 경우에 높은 DPI를 지원하는 Fusion 스타일을 대신 사용해보십시오.</target>
        </trans-unit>
        <trans-unit id="25ad61f405be913349b3f8c561eee5a0327bb8b2" translate="yes" xml:space="preserve">
          <source>While the macOS style fully supports high-DPI, the Windows desktop style currently has some limitations with certain scale factors. In these cases, consider using the Fusion style instead, which supports high-DPI in all cases.</source>
          <target state="translated">macOS 스타일은 높은 DPI를 완벽하게 지원하지만 Windows 데스크톱 스타일에는 현재 특정 배율 요소에 몇 가지 제한이 있습니다. 이 경우 모든 경우에 높은 DPI를 지원하는 Fusion 스타일을 대신 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="78d1e6aef8ef4ed7cd7b8d0163ca00a8f0d7bbd3" translate="yes" xml:space="preserve">
          <source>While the model is updating the &lt;a href=&quot;qml-qtlocation-placesearchmodel#status-prop&quot;&gt;status&lt;/a&gt; of the model is set to &lt;code&gt;PlaceSearchModel.Loading&lt;/code&gt;. If the model is successfully updated the &lt;a href=&quot;qml-qtlocation-placesearchmodel#status-prop&quot;&gt;status&lt;/a&gt; is set to &lt;code&gt;PlaceSearchModel.Ready&lt;/code&gt;, while if it unsuccessfully completes, the &lt;a href=&quot;qml-qtlocation-placesearchmodel#status-prop&quot;&gt;status&lt;/a&gt; is set to &lt;code&gt;PlaceSearchModel.Error&lt;/code&gt; and the model cleared.</source>
          <target state="translated">모델이 업데이트되는 동안 모델 &lt;a href=&quot;qml-qtlocation-placesearchmodel#status-prop&quot;&gt;상태&lt;/a&gt; 는 &lt;code&gt;PlaceSearchModel.Loading&lt;/code&gt; 으로 설정됩니다 . 모델이 성공적으로 업데이트되면 &lt;a href=&quot;qml-qtlocation-placesearchmodel#status-prop&quot;&gt;상태&lt;/a&gt; 가 &lt;code&gt;PlaceSearchModel.Ready&lt;/code&gt; 로 설정되고 , 실패하면 완료 &lt;a href=&quot;qml-qtlocation-placesearchmodel#status-prop&quot;&gt;상태&lt;/a&gt; 가 &lt;code&gt;PlaceSearchModel.Error&lt;/code&gt; 로 설정되고 모델이 지워집니다.</target>
        </trans-unit>
        <trans-unit id="82409defd12979c4c5e7be418ea87926591930b2" translate="yes" xml:space="preserve">
          <source>While the model is updating the &lt;a href=&quot;qml-qtlocation-placesearchsuggestionmodel#status-prop&quot;&gt;status&lt;/a&gt; of the model is set to &lt;code&gt;PlaceSearchSuggestionModel.Loading&lt;/code&gt;. If the model is successfully updated, the &lt;a href=&quot;qml-qtlocation-placesearchsuggestionmodel#status-prop&quot;&gt;status&lt;/a&gt; is set to &lt;code&gt;PlaceSearchSuggestionModel.Ready&lt;/code&gt;, while if it unsuccessfully completes, the &lt;a href=&quot;qml-qtlocation-placesearchsuggestionmodel#status-prop&quot;&gt;status&lt;/a&gt; is set to &lt;code&gt;PlaceSearchSuggestionModel.Error&lt;/code&gt; and the model cleared.</source>
          <target state="translated">모델이 업데이트되는 동안 모델 &lt;a href=&quot;qml-qtlocation-placesearchsuggestionmodel#status-prop&quot;&gt;상태&lt;/a&gt; 는 &lt;code&gt;PlaceSearchSuggestionModel.Loading&lt;/code&gt; 으로 설정됩니다 . 모델이 성공적으로 업데이트되면 &lt;a href=&quot;qml-qtlocation-placesearchsuggestionmodel#status-prop&quot;&gt;상태&lt;/a&gt; 가 &lt;code&gt;PlaceSearchSuggestionModel.Ready&lt;/code&gt; 로 설정되고 , 실패하면 완료 &lt;a href=&quot;qml-qtlocation-placesearchsuggestionmodel#status-prop&quot;&gt;상태&lt;/a&gt; 가 &lt;code&gt;PlaceSearchSuggestionModel.Error&lt;/code&gt; 로 설정되고 모델이 지워집니다.</target>
        </trans-unit>
        <trans-unit id="5c49b7bf8b7f523926345002ea02335ac0fed742" translate="yes" xml:space="preserve">
          <source>While the purpose of threads is to allow code to run in parallel, there are times where threads must stop and wait for other threads. For example, if two threads try to write to the same variable simultaneously, the result is undefined. The principle of forcing threads to wait for one another is called</source>
          <target state="translated">스레드의 목적은 코드가 병렬로 실행되도록하는 것이지만 스레드가 중지되고 다른 스레드를 기다려야하는 경우가 있습니다. 예를 들어, 두 스레드가 동일한 변수에 동시에 쓰려고하면 결과가 정의되지 않습니다. 스레드가 서로를 기다리도록하는 원리를</target>
        </trans-unit>
        <trans-unit id="8892b409c35b28da95d5741e0a7c085aa4772a1d" translate="yes" xml:space="preserve">
          <source>While the recorder state is changed immediately to &lt;a href=&quot;qmediarecorder#State-enum&quot;&gt;QMediaRecorder::RecordingState&lt;/a&gt;, recording may start asynchronously, with &lt;a href=&quot;qmediarecorder#status-prop&quot;&gt;statusChanged&lt;/a&gt;(&lt;a href=&quot;qmediarecorder#Status-enum&quot;&gt;QMediaRecorder::RecordingStatus&lt;/a&gt;) signal emitted when recording starts.</source>
          <target state="translated">레코더 상태가 즉시 &lt;a href=&quot;qmediarecorder#State-enum&quot;&gt;QMediaRecorder :: RecordingState로&lt;/a&gt; 변경되는 동안 , 레코딩이 시작될 때 방출되는 &lt;a href=&quot;qmediarecorder#status-prop&quot;&gt;statusChanged&lt;/a&gt; ( &lt;a href=&quot;qmediarecorder#Status-enum&quot;&gt;QMediaRecorder :: RecordingStatus&lt;/a&gt; ) 신호 와 함께 레코딩이 비동기 적으로 시작될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="378fb9d85b29aaa0bdd3082e5a9f0f6de11a9f08" translate="yes" xml:space="preserve">
          <source>While the render thread is preparing the new frame, the GUI thread calls &lt;a href=&quot;qquickitem#updatePolish&quot;&gt;QQuickItem::updatePolish&lt;/a&gt;() to do final touch-up of items before they are rendered.</source>
          <target state="translated">렌더 스레드가 새 프레임을 준비하는 동안 GUI 스레드는 &lt;a href=&quot;qquickitem#updatePolish&quot;&gt;QQuickItem :: updatePolish&lt;/a&gt; ()를 호출 하여 항목을 렌더링하기 전에 최종 수정 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="33b9994a33576273756053dd2bfc7d127452b698" translate="yes" xml:space="preserve">
          <source>While the render thread is rendering, the GUI is free to advance animations, process events, etc.</source>
          <target state="translated">렌더 스레드가 렌더링되는 동안 GUI는 애니메이션, 프로세스 이벤트 등을 진행시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2836e2c9a00364d76e8fc6eb4948bfa345cdd8bf" translate="yes" xml:space="preserve">
          <source>While the right mouse button is pressed, mouse movement along x-axis pans the camera around the camera view center and movement along y-axis tilts it around the camera view center.</source>
          <target state="translated">마우스 오른쪽 버튼을 누른 상태에서 x 축을 따라 마우스를 움직이면 카메라가 중앙을 중심으로 이동하고 y 축을 따라 움직이면 카메라가 중앙을 중심으로 기울입니다.</target>
        </trans-unit>
        <trans-unit id="62fe0b25f36e60029229d490f46787627435cfd5" translate="yes" xml:space="preserve">
          <source>While the scene manager is an internal API, it is important to know that the scene manager is responsible for calling updateSpatialNode on all objects that have been marked dirty by calling the update() method.</source>
          <target state="translated">장면 관리자는 내부 API이지만, 장면 관리자는 update () 메서드를 호출하여 더티로 표시된 모든 객체에서 updateSpatialNode를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="c73547bc5f11f1dcff2753df8c5f50a9d2d0b231" translate="yes" xml:space="preserve">
          <source>While the stream is playing, you can set a notify interval in milliseconds with &lt;a href=&quot;qaudiooutput#setNotifyInterval&quot;&gt;setNotifyInterval&lt;/a&gt;(). This interval specifies the time between two emissions of the &lt;a href=&quot;qaudiooutput#notify&quot;&gt;notify&lt;/a&gt;() signal. This is relative to the position in the stream, i.e., if the &lt;a href=&quot;qaudiooutput&quot;&gt;QAudioOutput&lt;/a&gt; is in the SuspendedState or the IdleState, the &lt;a href=&quot;qaudiooutput#notify&quot;&gt;notify&lt;/a&gt;() signal is not emitted. A typical use-case would be to update a &lt;a href=&quot;qslider&quot;&gt;slider&lt;/a&gt; that allows seeking in the stream. If you want the time since playback started regardless of which states the audio output has been in, &lt;a href=&quot;qaudiooutput#elapsedUSecs&quot;&gt;elapsedUSecs&lt;/a&gt;() is the function for you.</source>
          <target state="translated">스트림이 재생되는 동안 &lt;a href=&quot;qaudiooutput#setNotifyInterval&quot;&gt;setNotifyInterval&lt;/a&gt; ()을 사용하여 알림 간격을 밀리 초 단위로 설정할 수 있습니다 . 이 간격은 &lt;a href=&quot;qaudiooutput#notify&quot;&gt;통지&lt;/a&gt; () 신호 의 두 방출 사이의 시간을 지정합니다 . 이는 스트림의 위치와 관련이 있습니다. 즉, &lt;a href=&quot;qaudiooutput&quot;&gt;QAudioOutput&lt;/a&gt; 이 SuspendedState 또는 IdleState에있는 &lt;a href=&quot;qaudiooutput#notify&quot;&gt;경우 알림&lt;/a&gt; () 신호가 방출되지 않습니다. 일반적인 사용 사례는 스트림에서 탐색 할 수 있는 &lt;a href=&quot;qslider&quot;&gt;슬라이더&lt;/a&gt; 를 업데이트하는 것 입니다. 오디오 출력 상태에 관계없이 재생이 시작된 이후 시간을 원하면 &lt;a href=&quot;qaudiooutput#elapsedUSecs&quot;&gt;elapsedUSecs&lt;/a&gt; ()가 당신을위한 기능입니다.</target>
        </trans-unit>
        <trans-unit id="3f52ae25e878f476dc42b3fe4bc01a6ca0b253de" translate="yes" xml:space="preserve">
          <source>While the stream is playing, you can set a notify interval in milliseconds with &lt;a href=&quot;qaudiooutput#setNotifyInterval&quot;&gt;setNotifyInterval&lt;/a&gt;(). This interval specifies the time between two emissions of the &lt;a href=&quot;qaudiooutput#notify&quot;&gt;notify&lt;/a&gt;() signal. This is relative to the position in the stream, i.e., if the QAudioOutput is in the SuspendedState or the IdleState, the &lt;a href=&quot;qaudiooutput#notify&quot;&gt;notify&lt;/a&gt;() signal is not emitted. A typical use-case would be to update a &lt;a href=&quot;qslider&quot;&gt;slider&lt;/a&gt; that allows seeking in the stream. If you want the time since playback started regardless of which states the audio output has been in, &lt;a href=&quot;qaudiooutput#elapsedUSecs&quot;&gt;elapsedUSecs&lt;/a&gt;() is the function for you.</source>
          <target state="translated">스트림이 재생되는 동안 &lt;a href=&quot;qaudiooutput#setNotifyInterval&quot;&gt;setNotifyInterval&lt;/a&gt; ()을 사용하여 알림 간격을 밀리 초 단위로 설정할 수 있습니다 . 이 간격은 &lt;a href=&quot;qaudiooutput#notify&quot;&gt;알림&lt;/a&gt; () 신호 의 두 방출 사이의 시간을 지정합니다 . 이것은 스트림의 위치에 상대적입니다. 즉, QAudioOutput이 SuspendedState 또는 IdleState에있는 &lt;a href=&quot;qaudiooutput#notify&quot;&gt;경우 알림&lt;/a&gt; () 신호가 방출되지 않습니다. 일반적인 사용 사례는 스트림에서 검색을 허용 하는 &lt;a href=&quot;qslider&quot;&gt;슬라이더&lt;/a&gt; 를 업데이트하는 것 입니다. 오디오 출력 상태에 관계없이 재생이 시작된 이후의 시간을 원하면 &lt;a href=&quot;qaudiooutput#elapsedUSecs&quot;&gt;elapsedUSecs&lt;/a&gt; ()가 기능입니다.</target>
        </trans-unit>
        <trans-unit id="c8000f6c4a4a4fdf29886c2d5b63a829f3261e81" translate="yes" xml:space="preserve">
          <source>While the supported settings are unknown in this state, it's allowed to set the camera capture settings like codec, resolution, or frame rate.</source>
          <target state="translated">이 상태에서는 지원되는 설정을 알 수 없지만 코덱, 해상도 또는 프레임 속도와 같은 카메라 캡처 설정을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e63a013e47eab68d0585a4350fc0e24e27e3ba9" translate="yes" xml:space="preserve">
          <source>While the supported settings are unknown in this state, you can still set the camera capture settings like codec, resolution, or frame rate.</source>
          <target state="translated">이 상태에서는 지원되는 설정을 알 수 없지만 코덱, 해상도 또는 프레임 속도와 같은 카메라 캡처 설정을 계속 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="890d662caad82c18a023c4949978cc81f5a914ad" translate="yes" xml:space="preserve">
          <source>While the triggering of this signal may be considered an error condition, it does not imply the emission of the &lt;code&gt;error()&lt;/code&gt; signal. Only the emission of &lt;code&gt;requestTimeout()&lt;/code&gt; is required to indicate a timeout.</source>
          <target state="translated">이 신호의 트리거링은 오류 조건으로 간주 될 수 있지만 &lt;code&gt;error()&lt;/code&gt; 신호 의 방출을 의미하지는 않습니다 . 제한 시간을 표시하기 위해 &lt;code&gt;requestTimeout()&lt;/code&gt; 의 방출 만 필요합니다.</target>
        </trans-unit>
        <trans-unit id="3db5f5027c5bfbd27756e1a4d5f2db9c6ab87ab4" translate="yes" xml:space="preserve">
          <source>While the triggering of this signal may be considered an error condition, it does not imply the emission of the &lt;code&gt;error()&lt;/code&gt; signal. Only the emission of &lt;code&gt;updateTimeout()&lt;/code&gt; is required to indicate a timeout.</source>
          <target state="translated">이 신호의 트리거링은 오류 조건으로 간주 될 수 있지만 &lt;code&gt;error()&lt;/code&gt; 신호 의 방출을 의미하지는 않습니다 . 제한 시간을 표시하기 위해 &lt;code&gt;updateTimeout()&lt;/code&gt; 의 방출 만 필요합니다.</target>
        </trans-unit>
        <trans-unit id="1965514ae7dbcb22178d0c72da3b0f18ece39132" translate="yes" xml:space="preserve">
          <source>While the type has a name and a type, it cannot be created, and the given error</source>
          <target state="translated">유형에 이름과 유형이 있지만 작성할 수 없으며 주어진 오류</target>
        </trans-unit>
        <trans-unit id="b6cec89d64ecf87ac7795c052dd8a1107c1c1a45" translate="yes" xml:space="preserve">
          <source>While the type has a name and a type, it cannot be created. An error message with the given</source>
          <target state="translated">유형에 이름과 유형이 있지만 작성할 수 없습니다. 주어진 오류 메시지</target>
        </trans-unit>
        <trans-unit id="a01d732f1e6078a18b3d77f11f5920c2a0f80499" translate="yes" xml:space="preserve">
          <source>While this is a convenient way to store array and map-type values, you must be aware that the &lt;code&gt;items&lt;/code&gt; and &lt;code&gt;attributes&lt;/code&gt; properties above are</source>
          <target state="translated">이는 배열 및 맵 유형 값을 저장하는 편리한 방법이지만 위 의 &lt;code&gt;items&lt;/code&gt; 및 &lt;code&gt;attributes&lt;/code&gt; 속성은 다음 과 같습니다.</target>
        </trans-unit>
        <trans-unit id="19234880a4c7a1d117b722d68478a705dd237820" translate="yes" xml:space="preserve">
          <source>While this property is introduced in Qt 5.5, the related accessor functions exist since the first version of this class.</source>
          <target state="translated">이 속성은 Qt 5.5에 도입되었지만 관련 액세서 함수는이 클래스의 첫 번째 버전 이후에 존재합니다.</target>
        </trans-unit>
        <trans-unit id="14f55592618070d907f9667b31b4b236d2545fe0" translate="yes" xml:space="preserve">
          <source>While this property was introduced in 5.10, the corresponding accessor method has always been there.</source>
          <target state="translated">이 속성은 5.10에 도입되었지만 해당 접근 자 메서드는 항상 존재했습니다.</target>
        </trans-unit>
        <trans-unit id="7cb57e8a4fc04a5334c677b4e1587452ee29bf97" translate="yes" xml:space="preserve">
          <source>While unavoidable with techniques that need it, &lt;code&gt;DEPTH_TEXTURE&lt;/code&gt; implies an additional rendering pass to generate the contents of that texture, which can also present a hit on less capable hardware. Therefore, use &lt;code&gt;DEPTH_TEXTURE&lt;/code&gt; in the effect's shaders only when essential.</source>
          <target state="translated">필요한 기술로는 피할 수 없지만 &lt;code&gt;DEPTH_TEXTURE&lt;/code&gt; 는 해당 텍스처의 콘텐츠를 생성하기위한 추가 렌더링 패스를 의미하며, 이는 성능이 낮은 하드웨어에도 타격을 줄 수 있습니다. 따라서 필수적인 경우에만 효과의 셰이더에서 &lt;code&gt;DEPTH_TEXTURE&lt;/code&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="3487f0c2d4d848ba0d1eeb18fa26d7605ad3426b" translate="yes" xml:space="preserve">
          <source>While using &lt;a href=&quot;qml-qtremoteobjects-qtremoteobjects&quot;&gt;Qt Remote Objects&lt;/a&gt; for communication is a cross-platform solution, &lt;a href=&quot;qandroidbinder&quot;&gt;QAndroidBinder&lt;/a&gt; Class Reference} is Android specific. &lt;a href=&quot;qandroidbinder&quot;&gt;QAndroidBinder&lt;/a&gt; is a convenience class that implements the most important methods in &lt;a href=&quot;https://developer.android.com/reference/android/os/Binder.html&quot;&gt;Android: Binder&lt;/a&gt;. It allows sending &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; or &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; objcets between processes.</source>
          <target state="translated">통신을 위해 &lt;a href=&quot;qml-qtremoteobjects-qtremoteobjects&quot;&gt;Qt Remote Objects&lt;/a&gt; 를 사용 하는 것은 크로스 플랫폼 솔루션이지만 &lt;a href=&quot;qandroidbinder&quot;&gt;QAndroidBinder&lt;/a&gt; Class Reference}는 Android 전용입니다. &lt;a href=&quot;qandroidbinder&quot;&gt;QAndroidBinder&lt;/a&gt; 는 &lt;a href=&quot;https://developer.android.com/reference/android/os/Binder.html&quot;&gt;Android&lt;/a&gt; 에서 가장 중요한 메소드 인 Binder 를 구현하는 편의 클래스입니다 . 프로세스간에 &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; 또는 &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; 개체를 보낼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4bbe1a0f6b383349e0d6ab2f7de0714b0c79ce7c" translate="yes" xml:space="preserve">
          <source>While verifying test results by capturing and comparing bitmaps is sometimes necessary, it can be quite fragile and labor-intensive.</source>
          <target state="translated">비트 맵을 캡처하고 비교하여 테스트 결과를 확인해야하는 경우도 있지만 매우 취약하고 노동 집약적 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f22dbb245db35894cef5ae8f4a1c53d507430ac2" translate="yes" xml:space="preserve">
          <source>While we are at it, why not visualize normals as well, this time on a sphere. Like with UVs, if a custom vertex shader snippet were to alter the value of NORMAL, the interpolated per-fragment value in the fragment shader, also exposed under the name NORMAL, would reflect those adjustments.</source>
          <target state="translated">우리가 여기에있는 동안, 이번에는 구에서 법선도 시각화하는 것은 어떨까요? UV와 마찬가지로 커스텀 버텍스 셰이더 스 니펫이 NORMAL의 값을 변경하는 경우, NORMAL이라는 이름으로 노출 된 프래그먼트 셰이더의 보간 된 프래그먼트 별 값은 이러한 조정을 반영합니다.</target>
        </trans-unit>
        <trans-unit id="4a2a6a35c6ca4d0d3ac0d2ce600a59b30c8d8a82" translate="yes" xml:space="preserve">
          <source>While we prefer to name our C++ source files &lt;code&gt;.cpp&lt;/code&gt;, you can use any other extension, such as &lt;code&gt;.C&lt;/code&gt;, &lt;code&gt;.cc&lt;/code&gt;, &lt;code&gt;.CC&lt;/code&gt;, &lt;code&gt;.cxx&lt;/code&gt;, and &lt;code&gt;.c++&lt;/code&gt;, if you prefer.</source>
          <target state="translated">C ++ 소스 파일의 이름을 &lt;code&gt;.cpp&lt;/code&gt; 로 지정하는 것이 &lt;code&gt;.CC&lt;/code&gt; 원하는 경우 &lt;code&gt;.C&lt;/code&gt; , &lt;code&gt;.cc&lt;/code&gt; , .CC , &lt;code&gt;.cxx&lt;/code&gt; 및 &lt;code&gt;.c++&lt;/code&gt; 와 같은 다른 확장명을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="040a4d00e5bebdab30cb275ef54f205c01e7f2d8" translate="yes" xml:space="preserve">
          <source>While writing, the contents will be written to a temporary file, and if no error happened, &lt;a href=&quot;qsavefile#commit&quot;&gt;commit&lt;/a&gt;() will move it to the final file. This ensures that no data at the final file is lost in case an error happens while writing, and no partially-written file is ever present at the final location. Always use &lt;a href=&quot;qsavefile&quot;&gt;QSaveFile&lt;/a&gt; when saving entire documents to disk.</source>
          <target state="translated">기록하는 동안 내용은 임시 파일에 기록되며 오류가 발생하지 않으면 &lt;a href=&quot;qsavefile#commit&quot;&gt;commit&lt;/a&gt; ()은 최종 파일로 이동합니다. 이를 통해 쓰기 도중 오류가 발생하고 최종 위치에 부분적으로 작성된 파일이없는 경우 최종 파일의 데이터가 손실되지 않습니다. 전체 문서를 디스크에 저장할 때는 항상 &lt;a href=&quot;qsavefile&quot;&gt;QSaveFile을&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="83cb1a8109e22dda2f457728fc209701acd558d6" translate="yes" xml:space="preserve">
          <source>While writing, the contents will be written to a temporary file, and if no error happened, &lt;a href=&quot;qsavefile#commit&quot;&gt;commit&lt;/a&gt;() will move it to the final file. This ensures that no data at the final file is lost in case an error happens while writing, and no partially-written file is ever present at the final location. Always use QSaveFile when saving entire documents to disk.</source>
          <target state="translated">쓰는 동안 내용은 임시 파일에 기록되고, 오류가 발생하지 않으면 &lt;a href=&quot;qsavefile#commit&quot;&gt;commit&lt;/a&gt; () 은이 를 최종 파일로 옮깁니다. 이렇게하면 쓰기 중에 오류가 발생하는 경우 최종 파일의 데이터가 손실되지 않고 부분적으로 작성된 파일이 최종 위치에 존재하지 않습니다. 전체 문서를 디스크에 저장할 때 항상 QSaveFile을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b4261e57f9b901a912688d75b22edcb877eeea97" translate="yes" xml:space="preserve">
          <source>Whilst SAX2 leaves it to the user to define and implement whatever features are required, support for</source>
          <target state="translated">SAX2가 필요한 기능을 정의하고 구현하도록 사용자에게 맡기는 동안</target>
        </trans-unit>
        <trans-unit id="ee1c3d063ab64e3830ce46d40aa25b31fd6708f9" translate="yes" xml:space="preserve">
          <source>Whilst reading (a SAX2 parser is usually referred to as &quot;reader&quot;) the above document three events would be triggered:</source>
          <target state="translated">읽기 (SAX2 파서는 일반적으로 &quot;판독기&quot;라고 함) 위의 문서에서 세 가지 이벤트가 트리거됩니다.</target>
        </trans-unit>
        <trans-unit id="7aa362991263dbce17194eb62185c8c8a4149920" translate="yes" xml:space="preserve">
          <source>Whilst this class provides access to any type of extension, only some are guaranteed to be returned in a format that will remain unchanged between releases. The &lt;a href=&quot;qsslcertificateextension#isSupported&quot;&gt;isSupported&lt;/a&gt;() method returns &lt;code&gt;true&lt;/code&gt; for extensions where this is the case.</source>
          <target state="translated">이 클래스는 모든 유형의 확장에 대한 액세스를 제공하지만 일부는 릴리스간에 변경되지 않은 형식으로 반환되도록 보장됩니다. &lt;a href=&quot;qsslcertificateextension#isSupported&quot;&gt;가 isSupported&lt;/a&gt; () 메소드는 반환 &lt;code&gt;true&lt;/code&gt; 이 경우 확장을위한.</target>
        </trans-unit>
        <trans-unit id="4716b4e4fbe6f125c22cea63b8d59f96bd0d83c4" translate="yes" xml:space="preserve">
          <source>Whilst this is a fast and simple approach to read XML documents, manipulation is difficult because data is not stored, simply handled and discarded serially. The &lt;a href=&quot;xml-dom-tml#&quot;&gt;DOM interface&lt;/a&gt; reads in and stores the whole document in a tree structure; this takes more memory, but makes it easier to manipulate the document's structure.</source>
          <target state="translated">이것이 XML 문서를 읽는 빠르고 간단한 방법이지만 데이터는 저장되지 않고 단순히 처리 및 삭제되기 때문에 조작이 어렵습니다. &lt;a href=&quot;xml-dom-tml#&quot;&gt;DOM 인터페이스&lt;/a&gt; 에서 읽기 및 트리 구조로 전체 문서를 저장; 이것은 더 많은 메모리를 필요로하지만 문서의 구조를보다 쉽게 ​​조작 할 수있게합니다.</target>
        </trans-unit>
        <trans-unit id="37619fc13053f82b7cb7da3d24ceb1598ab6d05c" translate="yes" xml:space="preserve">
          <source>White</source>
          <target state="translated">White</target>
        </trans-unit>
        <trans-unit id="be119f3e9b0742347aed947d1e924019cdc133d2" translate="yes" xml:space="preserve">
          <source>WhiteBalance</source>
          <target state="translated">WhiteBalance</target>
        </trans-unit>
        <trans-unit id="4190ce86b53993cb85718f334bfe5be99c073792" translate="yes" xml:space="preserve">
          <source>WhiteBalanceAuto</source>
          <target state="translated">WhiteBalanceAuto</target>
        </trans-unit>
        <trans-unit id="8939e2ac028fecf3300eb31b7396ce21fc017d61" translate="yes" xml:space="preserve">
          <source>WhiteBalanceCloudy</source>
          <target state="translated">WhiteBalanceCloudy</target>
        </trans-unit>
        <trans-unit id="b90e622dfa822b4dbb410c3ab4b32c80a54c0986" translate="yes" xml:space="preserve">
          <source>WhiteBalanceFlash</source>
          <target state="translated">WhiteBalanceFlash</target>
        </trans-unit>
        <trans-unit id="c1eab86531fbb329775b9990bfbb92b507eff540" translate="yes" xml:space="preserve">
          <source>WhiteBalanceFluorescent</source>
          <target state="translated">WhiteBalanceFluorescent</target>
        </trans-unit>
        <trans-unit id="893c1c3eff47e7fe498e0c6a700c33fd7380079c" translate="yes" xml:space="preserve">
          <source>WhiteBalanceManual</source>
          <target state="translated">WhiteBalanceManual</target>
        </trans-unit>
        <trans-unit id="d166e9c2606b779a48db9dd1654fdcd0f3aff31f" translate="yes" xml:space="preserve">
          <source>WhiteBalanceShade</source>
          <target state="translated">WhiteBalanceShade</target>
        </trans-unit>
        <trans-unit id="28b156f19ce49170e930c3340ac5df603218a633" translate="yes" xml:space="preserve">
          <source>WhiteBalanceSunlight</source>
          <target state="translated">WhiteBalanceSunlight</target>
        </trans-unit>
        <trans-unit id="23d7b3ae856fedabb39a2ada5effb06748e4eccf" translate="yes" xml:space="preserve">
          <source>WhiteBalanceSunset</source>
          <target state="translated">WhiteBalanceSunset</target>
        </trans-unit>
        <trans-unit id="6ae0c09dcbe702fd9cf02b30e60a3b7a8ba80fa8" translate="yes" xml:space="preserve">
          <source>WhiteBalanceTungsten</source>
          <target state="translated">WhiteBalanceTungsten</target>
        </trans-unit>
        <trans-unit id="9f3680581edbf2de7a09abd43359e2ff52fb8c75" translate="yes" xml:space="preserve">
          <source>WhiteBalanceVendor</source>
          <target state="translated">WhiteBalanceVendor</target>
        </trans-unit>
        <trans-unit id="47b13cdb0607925057b8e9d36b0386d1a11eb54c" translate="yes" xml:space="preserve">
          <source>Whitespace</source>
          <target state="translated">Whitespace</target>
        </trans-unit>
        <trans-unit id="cf484dd6e26d5d8b523ce770ee700fdbc2cc42c0" translate="yes" xml:space="preserve">
          <source>Whitespace characters are all characters for which &lt;a href=&quot;qchar#isSpace&quot;&gt;QChar::isSpace&lt;/a&gt;() returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">공백 문자는 &lt;a href=&quot;qchar#isSpace&quot;&gt;QChar :: isSpace&lt;/a&gt; ()가 &lt;code&gt;true&lt;/code&gt; 를 리턴 하는 모든 문자입니다 .</target>
        </trans-unit>
        <trans-unit id="1bfce1148b8b147bf4f6c5c29d0b2ac864eccd7e" translate="yes" xml:space="preserve">
          <source>Whitespace is</source>
          <target state="translated">공백은</target>
        </trans-unit>
        <trans-unit id="619560393f5f70fda43352d58eaed0fa0beb1331" translate="yes" xml:space="preserve">
          <source>Whitespace means any character for which &lt;a href=&quot;qchar#isSpace&quot;&gt;QChar::isSpace&lt;/a&gt;() returns &lt;code&gt;true&lt;/code&gt;. This includes the ASCII characters '\t', '\n', '\v', '\f', '\r', and ' '.</source>
          <target state="translated">공백은 &lt;a href=&quot;qchar#isSpace&quot;&gt;QChar :: isSpace&lt;/a&gt; ()가 &lt;code&gt;true&lt;/code&gt; 를 리턴 하는 모든 문자를 의미 합니다 . 여기에는 ASCII 문자 '\ t', '\ n', '\ v', '\ f', '\ r'및 ''가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="7bb86b55ec209f85b6753199094e7094ccac938d" translate="yes" xml:space="preserve">
          <source>Whitespace means any character for which the standard C++ &lt;code&gt;isspace()&lt;/code&gt; function returns &lt;code&gt;true&lt;/code&gt; in the C locale. This includes the ASCII characters '\t', '\n', '\v', '\f', '\r', and ' '.</source>
          <target state="translated">공백은 표준 C ++ &lt;code&gt;isspace()&lt;/code&gt; 함수가 C 로켈에서 &lt;code&gt;true&lt;/code&gt; 를 반환 하는 모든 문자를 의미합니다 . 여기에는 ASCII 문자 '\ t', '\ n', '\ v', '\ f', '\ r'및 ''가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="761de1d78a55a5525fb526764547bc19aba5b107" translate="yes" xml:space="preserve">
          <source>Whitespace means any character for which the standard C++ &lt;code&gt;isspace()&lt;/code&gt; function returns &lt;code&gt;true&lt;/code&gt; in the C locale. This includes the ASCII isspace() function returns &lt;code&gt;true&lt;/code&gt; in the C locale. This includes the ASCII characters '\t', '\n', '\v', '\f', '\r', and ' '.</source>
          <target state="translated">공백은 표준 C ++ &lt;code&gt;isspace()&lt;/code&gt; 함수가 C 로켈에서 &lt;code&gt;true&lt;/code&gt; 를 반환 하는 모든 문자를 의미합니다 . 여기에는 C 로케일에서 ASCII isspace () 함수가 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 . 여기에는 ASCII 문자 '\ t', '\ n', '\ v', '\ f', '\ r'및 ''가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="2233df9a38ffce2a090e971a0244daca24a2351d" translate="yes" xml:space="preserve">
          <source>Whole number, e.g. 0, 10, or -20</source>
          <target state="translated">정수 (예 : 0, 10 또는 -20)</target>
        </trans-unit>
        <trans-unit id="94b58a9bbcda32cd58aa6773214ce8f8577f38f2" translate="yes" xml:space="preserve">
          <source>Why Does Qt Use Moc for Signals and Slots?</source>
          <target state="translated">Qt가 신호와 슬롯에 Moc를 사용하는 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="bf8ddd04f924762daf335c1039abb1518d5d7a00" translate="yes" xml:space="preserve">
          <source>Why Single Execution Mode Is Much Faster</source>
          <target state="translated">단일 실행 모드가 훨씬 빠른 이유</target>
        </trans-unit>
        <trans-unit id="6768deb223077e5a055916dae8c4c8a62d6eac6d" translate="yes" xml:space="preserve">
          <source>Why Standard Mode Is Slow</source>
          <target state="translated">표준 모드가 느린 이유</target>
        </trans-unit>
        <trans-unit id="d28289455c6a63f4c4d5e5674b844c64ced4953a" translate="yes" xml:space="preserve">
          <source>Why Use Multi-Process</source>
          <target state="translated">다중 프로세스를 사용해야하는 이유</target>
        </trans-unit>
        <trans-unit id="59c0f38fe6c70095f1fe1a57575de23f6686b98e" translate="yes" xml:space="preserve">
          <source>Why Use Wayland Instead of X11 or Custom Solutions</source>
          <target state="translated">X11 또는 사용자 지정 솔루션 대신 Wayland를 사용하는 이유</target>
        </trans-unit>
        <trans-unit id="75faf730d6357ede69847c7a7ca9b978b5db0d56" translate="yes" xml:space="preserve">
          <source>Why are my elements created in the wrong order?</source>
          <target state="translated">내 요소가 잘못된 순서로 작성된 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="6da49307967cc44ac3bddaa3c5b248c5bd424e9f" translate="yes" xml:space="preserve">
          <source>Why can't I use &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; in my XQuery?</source>
          <target state="translated">XQuery에서 &lt;code&gt;true&lt;/code&gt; 와 &lt;code&gt;false&lt;/code&gt; 를 사용할 수없는 이유는 무엇 입니까?</target>
        </trans-unit>
        <trans-unit id="8dd571ea364273914dcd00b60733716f9ef1f2fe" translate="yes" xml:space="preserve">
          <source>Why didn't my expression get evaluated?</source>
          <target state="translated">내 표현이 평가되지 않은 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="a4372bfde3e7592aabced7cd95c0ddefabee172a" translate="yes" xml:space="preserve">
          <source>Why didn't my path expression match anything?</source>
          <target state="translated">경로 표현이 왜 일치하지 않습니까?</target>
        </trans-unit>
        <trans-unit id="a247f5521396b787b90f7af1088f96f87e2bf597" translate="yes" xml:space="preserve">
          <source>Why doesn't my FLWOR behave as expected?</source>
          <target state="translated">FLWOR가 예상대로 작동하지 않는 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="83d0bcb2a31ec1e790fdb9b17582bad006644268" translate="yes" xml:space="preserve">
          <source>Why doesn't my return clause work?</source>
          <target state="translated">내 반품 조항이 작동하지 않는 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="9d863fbd4a4b35d1abc87eb5fac9e58af686e66b" translate="yes" xml:space="preserve">
          <source>Why is this?</source>
          <target state="translated">왜 이런거야?</target>
        </trans-unit>
        <trans-unit id="8c43626059ddc397faa99b3542a5abebf426b981" translate="yes" xml:space="preserve">
          <source>WiMAX</source>
          <target state="translated">WiMAX</target>
        </trans-unit>
        <trans-unit id="7d66c73954780bbe3b7d4d83a7707b18dddd48fc" translate="yes" xml:space="preserve">
          <source>Wide logo image file. This has to be 310x150 pixels. Supported on all Windows Store App platforms. Default provided by the mkspec.</source>
          <target state="translated">넓은 로고 이미지 파일. 310x150 픽셀이어야합니다. 모든 Windows 스토어 앱 플랫폼에서 지원됩니다. mkspec에서 제공 한 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="df15305cc141d8294713eba43aaee44d1edfe3bd" translate="yes" xml:space="preserve">
          <source>Widget</source>
          <target state="translated">Widget</target>
        </trans-unit>
        <trans-unit id="1e44fcf40bcd1a072dad4b1c2c9eb0730c5aab3a" translate="yes" xml:space="preserve">
          <source>Widget Appearance and Style Related Classes</source>
          <target state="translated">위젯 모양 및 스타일 관련 클래스</target>
        </trans-unit>
        <trans-unit id="16f89fdc158507a8c9b68b673198d439286de1d9" translate="yes" xml:space="preserve">
          <source>Widget Appearance and Style-Related Classes</source>
          <target state="translated">위젯 모양 및 스타일 관련 클래스</target>
        </trans-unit>
        <trans-unit id="31e064aa645d7208a9b4c1753e3e88ac210d308a" translate="yes" xml:space="preserve">
          <source>Widget Attribute</source>
          <target state="translated">위젯 속성</target>
        </trans-unit>
        <trans-unit id="8a5e70773dcc3d881bcad04771d137842fe11c48" translate="yes" xml:space="preserve">
          <source>Widget Editing Mode</source>
          <target state="translated">위젯 편집 모드</target>
        </trans-unit>
        <trans-unit id="82cba10de183bd2d066e4d81d2062e021a9ffc67" translate="yes" xml:space="preserve">
          <source>Widget Reference</source>
          <target state="translated">위젯 참조</target>
        </trans-unit>
        <trans-unit id="669cd26f040ce8a52269e10701598141be881183" translate="yes" xml:space="preserve">
          <source>Widget Style Sheets</source>
          <target state="translated">위젯 스타일 시트</target>
        </trans-unit>
        <trans-unit id="decfc1956f3c1dad2ed2b8ec3230103ae01f3cec" translate="yes" xml:space="preserve">
          <source>Widget Walkthrough</source>
          <target state="translated">위젯 연습</target>
        </trans-unit>
        <trans-unit id="3fb06c3da187ae118abe889db66ce6d91eba057e" translate="yes" xml:space="preserve">
          <source>Widget based examples layout incorrectly in iOS.</source>
          <target state="translated">iOS에서 위젯 기반 예제 레이아웃이 잘못되었습니다.</target>
        </trans-unit>
        <trans-unit id="bd612066fd6c8940320fa98b2cbea5a4a13e6ed1" translate="yes" xml:space="preserve">
          <source>Widget for displaying the contents of a QGraphicsScene</source>
          <target state="translated">QGraphicsScene의 내용을 표시하는 위젯</target>
        </trans-unit>
        <trans-unit id="4665d8fe3f895566ba2adc2b5e8336a1ac72d65b" translate="yes" xml:space="preserve">
          <source>Widget for editing dates and times</source>
          <target state="translated">날짜 및 시간 편집을위한 위젯</target>
        </trans-unit>
        <trans-unit id="e943a3b202aca7f181da9d270c259094ac6bfb6a" translate="yes" xml:space="preserve">
          <source>Widget for editing dates based on the QDateTimeEdit widget</source>
          <target state="translated">QDateTimeEdit 위젯을 기반으로 날짜를 편집하기위한 위젯</target>
        </trans-unit>
        <trans-unit id="40ecd7df1c60b8c35ece200872419d71bf64a6aa" translate="yes" xml:space="preserve">
          <source>Widget for editing times based on the QDateTimeEdit widget</source>
          <target state="translated">QDateTimeEdit 위젯을 기반으로 시간을 편집하기위한 위젯</target>
        </trans-unit>
        <trans-unit id="57fe7643fd42b7d71e68aafba7d777e70cececfe" translate="yes" xml:space="preserve">
          <source>Widget for macOS that can be used to wrap arbitrary Cocoa views (i.e., NSView subclasses) and insert them into Qt hierarchies</source>
          <target state="translated">임의의 Cocoa 뷰 (즉, NSView 서브 클래스)를 랩핑하여 Qt 계층 구조에 삽입하는 데 사용할 수있는 macOS 용 위젯</target>
        </trans-unit>
        <trans-unit id="ba8679b21e1cd84939151ffa87f19f70ed2e7abd" translate="yes" xml:space="preserve">
          <source>Widget for macOS that provides a way to put Qt widgets into Cocoa hierarchies</source>
          <target state="translated">Qt 위젯을 Cocoa 계층에 넣는 방법을 제공하는 macOS 용 위젯</target>
        </trans-unit>
        <trans-unit id="3ea7e844a83e697d848193d0d86e6fe16d53be8e" translate="yes" xml:space="preserve">
          <source>Widget for previewing page layouts for printer output</source>
          <target state="translated">프린터 출력을위한 페이지 레이아웃 미리보기를위한 위젯</target>
        </trans-unit>
        <trans-unit id="3f50b33af17dd83c26762db6efa9c0abf87ac76e" translate="yes" xml:space="preserve">
          <source>Widget items do not support modality.</source>
          <target state="translated">위젯 항목은 양식을 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="60e1290cd940a65020cfcf939c14de3016ab3930" translate="yes" xml:space="preserve">
          <source>Widget layout needs to be redone.</source>
          <target state="translated">위젯 레이아웃을 다시 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="ecb1b35e7261d239875412961edd8155c83fc298" translate="yes" xml:space="preserve">
          <source>Widget or Window focus is about to change (&lt;a href=&quot;qfocusevent&quot;&gt;QFocusEvent&lt;/a&gt;)</source>
          <target state="translated">위젯 또는 창 초점이 변경됩니다 ( &lt;a href=&quot;qfocusevent&quot;&gt;QFocusEvent&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="6a56d7d6d3eda0d0f9b2013bbf44fdd531ae93b6" translate="yes" xml:space="preserve">
          <source>Widget or Window gains keyboard focus (&lt;a href=&quot;qfocusevent&quot;&gt;QFocusEvent&lt;/a&gt;).</source>
          <target state="translated">위젯 또는 창은 키보드 포커스를 얻습니다 ( &lt;a href=&quot;qfocusevent&quot;&gt;QFocusEvent&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="b7260b87e9f172faa1c09738f92fd4ba736eceab" translate="yes" xml:space="preserve">
          <source>Widget or Window loses keyboard focus (&lt;a href=&quot;qfocusevent&quot;&gt;QFocusEvent&lt;/a&gt;).</source>
          <target state="translated">위젯 또는 창에서 키보드 포커스를 잃습니다 ( &lt;a href=&quot;qfocusevent&quot;&gt;QFocusEvent&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="7a5b139b81da872d2ffc1ade6fb2283143ea9618" translate="yes" xml:space="preserve">
          <source>Widget that can be docked inside a QMainWindow or floated as a top-level window on the desktop</source>
          <target state="translated">QMainWindow 내부에 도킹되거나 데스크탑에서 최상위 창으로 띄울 수있는 위젯</target>
        </trans-unit>
        <trans-unit id="e2ce56d39cc1d9d25a590bb2970603c4447d82ed" translate="yes" xml:space="preserve">
          <source>Widget that is used to display the contents of Scalable Vector Graphics (SVG) files</source>
          <target state="translated">SVG (Scalable Vector Graphics) 파일의 내용을 표시하는 데 사용되는 위젯</target>
        </trans-unit>
        <trans-unit id="66b55f4774ddd3de11f64896fb31548eea207c27" translate="yes" xml:space="preserve">
          <source>Widget that is used to edit and display both plain and rich text</source>
          <target state="translated">일반 텍스트와 서식있는 텍스트를 모두 편집하고 표시하는 데 사용되는 위젯</target>
        </trans-unit>
        <trans-unit id="548ced6612af891b2750ce5cb89c5f41ea5df05d" translate="yes" xml:space="preserve">
          <source>Widget that is used to edit and display plain text</source>
          <target state="translated">일반 텍스트를 편집하고 표시하는 데 사용되는 위젯</target>
        </trans-unit>
        <trans-unit id="cee9cdd37b180dbf0d8251a214ae81a450ff6719" translate="yes" xml:space="preserve">
          <source>Widget that presents buttons in a layout that is appropriate to the current widget style</source>
          <target state="translated">현재 위젯 스타일에 적합한 레이아웃에 버튼을 표시하는 위젯</target>
        </trans-unit>
        <trans-unit id="d339946ed5020f7b0aa387e1de734f5abb40c3bd" translate="yes" xml:space="preserve">
          <source>Widget was closed (&lt;a href=&quot;qcloseevent&quot;&gt;QCloseEvent&lt;/a&gt;).</source>
          <target state="translated">위젯이 닫혔습니다 ( &lt;a href=&quot;qcloseevent&quot;&gt;QCloseEvent&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="07985052ee7750ec4f2a85bcac585e5a9c4788a3" translate="yes" xml:space="preserve">
          <source>Widget was hidden (&lt;a href=&quot;qhideevent&quot;&gt;QHideEvent&lt;/a&gt;).</source>
          <target state="translated">위젯이 숨겨 &lt;a href=&quot;qhideevent&quot;&gt;졌습니다&lt;/a&gt; ( QHideEvent ).</target>
        </trans-unit>
        <trans-unit id="033bbc513d6dc62765474a6197875b4ced504eeb" translate="yes" xml:space="preserve">
          <source>Widget was moved (&lt;a href=&quot;qgraphicsscenemoveevent&quot;&gt;QGraphicsSceneMoveEvent&lt;/a&gt;).</source>
          <target state="translated">위젯이 이동되었습니다 ( &lt;a href=&quot;qgraphicsscenemoveevent&quot;&gt;QGraphicsSceneMoveEvent&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="518f7ec608083e16824e10a10b08f51fe6ab73b5" translate="yes" xml:space="preserve">
          <source>Widget was resized (&lt;a href=&quot;qgraphicssceneresizeevent&quot;&gt;QGraphicsSceneResizeEvent&lt;/a&gt;).</source>
          <target state="translated">위젯 크기가 조정되었습니다 ( &lt;a href=&quot;qgraphicssceneresizeevent&quot;&gt;QGraphicsSceneResizeEvent&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="5eab2ea2104372c35211fb62f52c62a0a93daa42" translate="yes" xml:space="preserve">
          <source>Widget was shown on screen (&lt;a href=&quot;qshowevent&quot;&gt;QShowEvent&lt;/a&gt;).</source>
          <target state="translated">위젯이 화면에 표시되었습니다 ( &lt;a href=&quot;qshowevent&quot;&gt;QShowEvent&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="9c7ef8d3feb63b591ee1fab94e628138b8697817" translate="yes" xml:space="preserve">
          <source>Widget's enabled state has changed.</source>
          <target state="translated">위젯의 사용 가능 상태가 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="7cb5faf0a4f21248e054a55edf6eabe09c1c8c5f" translate="yes" xml:space="preserve">
          <source>Widget's font has changed.</source>
          <target state="translated">위젯의 글꼴이 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="d4ac6f485c980b110b2956c14e39abda18f5f080" translate="yes" xml:space="preserve">
          <source>Widget's icon text has been changed. (Deprecated)</source>
          <target state="translated">위젯의 아이콘 텍스트가 변경되었습니다. (더 이상 사용되지 않음)</target>
        </trans-unit>
        <trans-unit id="41c8a56257c77412816e996cea5101822508caa2" translate="yes" xml:space="preserve">
          <source>Widget's position changed (&lt;a href=&quot;qmoveevent&quot;&gt;QMoveEvent&lt;/a&gt;).</source>
          <target state="translated">위젯의 위치가 변경되었습니다 ( &lt;a href=&quot;qmoveevent&quot;&gt;QMoveEvent&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="32744d45deebf14ce0ec6527d0dab358dc236133" translate="yes" xml:space="preserve">
          <source>Widget's read-only state has changed (since Qt 5.4).</source>
          <target state="translated">위젯의 읽기 전용 상태가 변경되었습니다 (Qt 5.4부터).</target>
        </trans-unit>
        <trans-unit id="54318932bd246e420fc1b5da13204b7213a11ddb" translate="yes" xml:space="preserve">
          <source>Widget's size changed (&lt;a href=&quot;qresizeevent&quot;&gt;QResizeEvent&lt;/a&gt;).</source>
          <target state="translated">위젯의 크기가 변경되었습니다 ( &lt;a href=&quot;qresizeevent&quot;&gt;QResizeEvent&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="29db40d8bb7ea1e90d1dbc18279543169a4ce3ed" translate="yes" xml:space="preserve">
          <source>Widget's style has been changed.</source>
          <target state="translated">위젯 스타일이 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="bf8a6678a1e36e3d2c45861b80308b477e3345ac" translate="yes" xml:space="preserve">
          <source>Widgets</source>
          <target state="translated">Widgets</target>
        </trans-unit>
        <trans-unit id="3f421c0aac098c418b50c5c3bcbd110589223e73" translate="yes" xml:space="preserve">
          <source>Widgets Classes</source>
          <target state="translated">위젯 클래스</target>
        </trans-unit>
        <trans-unit id="26e41ea52b5739b9e0ec9255510d6463dbaf9639" translate="yes" xml:space="preserve">
          <source>Widgets Inside C++ Namespaces</source>
          <target state="translated">C ++ 네임 스페이스 내부의 위젯</target>
        </trans-unit>
        <trans-unit id="008ecc276f0fa35c32ff2bf4e97c5a9ce8676de0" translate="yes" xml:space="preserve">
          <source>Widgets Tutorial</source>
          <target state="translated">위젯 튜토리얼</target>
        </trans-unit>
        <trans-unit id="a07d0d90d7eb4ac5ebbea3ebe5dd8d5d991c5eed" translate="yes" xml:space="preserve">
          <source>Widgets and Dialogs with Auto-Connect</source>
          <target state="translated">자동 연결 기능이있는 위젯 및 대화 상자</target>
        </trans-unit>
        <trans-unit id="344641154bdac90c3e210fb6d62e3c21264b495f" translate="yes" xml:space="preserve">
          <source>Widgets and Layouts</source>
          <target state="translated">위젯 및 레이아웃</target>
        </trans-unit>
        <trans-unit id="1a27ba46d254289b76d964159e27c5c9e7cb5eae" translate="yes" xml:space="preserve">
          <source>Widgets and forms created with</source>
          <target state="translated">로 작성된 위젯 및 양식</target>
        </trans-unit>
        <trans-unit id="a85fe50534a0d44188b440e220eb499d9e7f63b4" translate="yes" xml:space="preserve">
          <source>Widgets are hidden if:</source>
          <target state="translated">다음과 같은 경우 위젯이 숨겨집니다.</target>
        </trans-unit>
        <trans-unit id="5cc092b01f77dca9f63f3dd517ef7f260d13bdbe" translate="yes" xml:space="preserve">
          <source>Widgets are normally created without any stretch factor set. When they are laid out in a layout the widgets are given a share of space in accordance with their &lt;a href=&quot;qwidget#sizePolicy-prop&quot;&gt;QWidget::sizePolicy&lt;/a&gt;() or their minimum size hint whichever is the greater. Stretch factors are used to change how much space widgets are given in proportion to one another.</source>
          <target state="translated">위젯은 일반적으로 신축 계수를 설정하지 않고 생성됩니다. 이들이 레이아웃에 배치 될 때, 위젯에는 &lt;a href=&quot;qwidget#sizePolicy-prop&quot;&gt;QWidget :: sizePolicy&lt;/a&gt; () 또는 최소 크기 힌트 중 큰쪽에 따라 공간이 할당됩니다 . 스트레치 팩터는 서로에 비례하여 제공되는 공간 위젯의 양을 변경하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1ad1a58da08f3901a8a19b9940b1b58f5d1fc6c7" translate="yes" xml:space="preserve">
          <source>Widgets are not necessarily drawn by asking the style to draw only one element. Widgets can make several calls to the style to draw different elements. An example is &lt;a href=&quot;qtabwidget&quot;&gt;QTabWidget&lt;/a&gt;, which draws its tabs and frame individually.</source>
          <target state="translated">하나의 요소 만 그리도록 스타일을 요청하여 위젯을 반드시 그릴 필요는 없습니다. 위젯은 스타일을 여러 번 호출하여 다른 요소를 그릴 수 있습니다. 예를 들어 &lt;a href=&quot;qtabwidget&quot;&gt;QTabWidget&lt;/a&gt; 은 탭과 프레임을 개별적으로 그립니다.</target>
        </trans-unit>
        <trans-unit id="d86289290055f720dba269dd8dd2c2c63966ce9f" translate="yes" xml:space="preserve">
          <source>Widgets are not unique objects; you can make as many copies of them as you need. To quickly duplicate a widget, you can clone it by holding down the &lt;b&gt;Ctrl&lt;/b&gt; key and dragging it. This allows widgets to be copied and placed on the form more quickly than with clipboard operations.</source>
          <target state="translated">위젯은 고유 한 객체가 아닙니다. 필요한만큼 사본을 만들 수 있습니다. 위젯을 빠르게 복제하려면 &lt;b&gt;Ctrl&lt;/b&gt; 키를 누른 채 끌어 위젯을 복제 할 수 있습니다 . 이를 통해 클립 보드 작업보다 위젯을 빠르게 복사하여 양식에 배치 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="97be29d34b1e53ced8877c1f56afbe4b40018dba" translate="yes" xml:space="preserve">
          <source>Widgets are the primary elements for creating user interfaces in Qt. &lt;a href=&quot;widget-classes#the-widget-classes&quot;&gt;Widgets&lt;/a&gt; can display data and status information, receive user input, and provide a container for other widgets that should be grouped together. A widget that is not embedded in a parent widget is called a &lt;a href=&quot;application-windows&quot;&gt;window&lt;/a&gt;.</source>
          <target state="translated">위젯은 Qt에서 사용자 인터페이스를 생성하기위한 기본 요소입니다. &lt;a href=&quot;widget-classes#the-widget-classes&quot;&gt;위젯&lt;/a&gt; 은 데이터 및 상태 정보를 표시하고 사용자 입력을 수신하며 함께 그룹화해야하는 다른 위젯에 대한 컨테이너를 제공 할 수 있습니다. 상위 위젯에 포함되지 않은 위젯을 &lt;a href=&quot;application-windows&quot;&gt;창&lt;/a&gt; 이라고합니다 .</target>
        </trans-unit>
        <trans-unit id="fc7d42f09b3be487104e98c77490d831d6731b3f" translate="yes" xml:space="preserve">
          <source>Widgets are the primary elements for creating user interfaces in Qt. &lt;a href=&quot;widget-classes#the-widget-classes&quot;&gt;Widgets&lt;/a&gt; can display data and status information, receive user input, and provide a container for other widgets that should be grouped together. A widget that is not embedded in a parent widget is called a &lt;a href=&quot;application-windows#&quot;&gt;window&lt;/a&gt;.</source>
          <target state="translated">위젯은 Qt에서 사용자 인터페이스를 만들기위한 기본 요소입니다. &lt;a href=&quot;widget-classes#the-widget-classes&quot;&gt;위젯&lt;/a&gt; 은 데이터 및 상태 정보를 표시하고 사용자 입력을 수신하며 함께 그룹화해야하는 다른 위젯에 대한 컨테이너를 제공 할 수 있습니다. 부모 위젯에 포함되지 않은 위젯을 &lt;a href=&quot;application-windows#&quot;&gt;창&lt;/a&gt; 이라고합니다 .</target>
        </trans-unit>
        <trans-unit id="1375cc23552403a3c4ee37608323f1a1ac92fd07" translate="yes" xml:space="preserve">
          <source>Widgets automatically detect HTML markup and display rich text accordingly. For example, setting a label's &lt;a href=&quot;qlabel#text-prop&quot;&gt;text&lt;/a&gt; property with the string &lt;code&gt;&quot;&amp;lt;b&amp;gt;Hello&amp;lt;/b&amp;gt; &amp;lt;i&amp;gt;Qt!&amp;lt;/i&amp;gt;&quot;&lt;/code&gt; will result in the label displaying text like this: &lt;b&gt;Hello&lt;/b&gt;</source>
          <target state="translated">위젯은 자동으로 HTML 마크 업을 감지하고 그에 따라 리치 텍스트를 표시합니다. 예를 들어 문자열 &lt;code&gt;&quot;&amp;lt;b&amp;gt;Hello&amp;lt;/b&amp;gt; &amp;lt;i&amp;gt;Qt!&amp;lt;/i&amp;gt;&quot;&lt;/code&gt; 를 사용하여 레이블의 &lt;a href=&quot;qlabel#text-prop&quot;&gt;텍스트&lt;/a&gt; 속성을 설정하면 레이블 에 다음과 같은 텍스트가 표시됩니다. &lt;b&gt;Hello&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6c54f63c2c46258996ecf5d8a376b81d66276c95" translate="yes" xml:space="preserve">
          <source>Widgets can also be &quot;cloned&quot; on the form: Holding down &lt;b&gt;Ctrl&lt;/b&gt; and dragging the widget creates a copy of the widget that can be dragged to a new position.</source>
          <target state="translated">위젯은 양식에서 &quot;복제&quot;될 수도 있습니다. &lt;b&gt;Ctrl 키&lt;/b&gt; 를 누른 상태에서 위젯을 드래그하면 위젯의 사본이 만들어 새로운 위치로 드래그 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="26e7dd3385f17f40b7a475c739c5234561e03aa8" translate="yes" xml:space="preserve">
          <source>Widgets can be added to menus by using instances of the &lt;a href=&quot;qwidgetaction&quot;&gt;QWidgetAction&lt;/a&gt; class to hold them. These actions can then be inserted into menus in the usual way; see the &lt;a href=&quot;qmenu&quot;&gt;QMenu&lt;/a&gt; documentation for more details.</source>
          <target state="translated">&lt;a href=&quot;qwidgetaction&quot;&gt;QWidgetAction&lt;/a&gt; 클래스의 인스턴스를 사용하여 이를 보유 하여 메뉴에 위젯을 추가 할 수 있습니다 . 이러한 조치는 일반적인 방법으로 메뉴에 삽입 될 수 있습니다. 자세한 내용은 &lt;a href=&quot;qmenu&quot;&gt;QMenu&lt;/a&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="273dfa86751e5e4476bb799b555744e688a1a0b7" translate="yes" xml:space="preserve">
          <source>Widgets can be inserted into menus with the &lt;a href=&quot;qwidgetaction&quot;&gt;QWidgetAction&lt;/a&gt; class. Instances of this class are used to hold widgets, and are inserted into menus with the &lt;a href=&quot;qmenu#addAction&quot;&gt;addAction&lt;/a&gt;() overload that takes a &lt;a href=&quot;qaction&quot;&gt;QAction&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qwidgetaction&quot;&gt;QWidgetAction&lt;/a&gt; 클래스를 사용하여 위젯을 메뉴에 삽입 할 수 있습니다 . 이 클래스의 인스턴스는 위젯을 보유 하는 데 사용되며 &lt;a href=&quot;qaction&quot;&gt;QAction&lt;/a&gt; 을 취하는 &lt;a href=&quot;qmenu#addAction&quot;&gt;addAction&lt;/a&gt; () 오버로드 와 함께 메뉴에 삽입됩니다 .</target>
        </trans-unit>
        <trans-unit id="b8cde9c4e84fb4f449300f7ecf063ddbdc149db4" translate="yes" xml:space="preserve">
          <source>Widgets can be inserted into menus with the &lt;a href=&quot;qwidgetaction&quot;&gt;QWidgetAction&lt;/a&gt; class. Instances of this class are used to hold widgets, and are inserted into menus with the &lt;a href=&quot;qmenu#addAction&quot;&gt;addAction&lt;/a&gt;() overload that takes a &lt;a href=&quot;qaction&quot;&gt;QAction&lt;/a&gt;. If the &lt;a href=&quot;qwidgetaction&quot;&gt;QWidgetAction&lt;/a&gt; fires the &lt;a href=&quot;qmenu#triggered&quot;&gt;triggered&lt;/a&gt;() signal, the menu will close.</source>
          <target state="translated">&lt;a href=&quot;qwidgetaction&quot;&gt;QWidgetAction&lt;/a&gt; 클래스를 사용하여 위젯을 메뉴에 삽입 할 수 있습니다 . 이 클래스의 인스턴스는 위젯을 보유 하는 데 사용되며 &lt;a href=&quot;qaction&quot;&gt;QAction을&lt;/a&gt; 사용하는 &lt;a href=&quot;qmenu#addAction&quot;&gt;addAction&lt;/a&gt; () 오버로드 와 함께 메뉴에 삽입됩니다 . 는 IF &lt;a href=&quot;qwidgetaction&quot;&gt;QWidgetAction이&lt;/a&gt; 불 &lt;a href=&quot;qmenu#triggered&quot;&gt;트리거&lt;/a&gt; () 신호를 메뉴가 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="288931136cef5721a6fc4f71b7afc624ff77e8d9" translate="yes" xml:space="preserve">
          <source>Widgets for editing item data in views and delegates</source>
          <target state="translated">뷰 및 델리게이트에서 항목 데이터를 편집하기위한 위젯</target>
        </trans-unit>
        <trans-unit id="3bb11f9c59b3c02c1e6de3844683793b55cba22d" translate="yes" xml:space="preserve">
          <source>Widgets modification state has been changed.</source>
          <target state="translated">위젯 수정 상태가 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="242c88c452d76a5d4144f060e7e7ca1774e6c7d1" translate="yes" xml:space="preserve">
          <source>Widgets provided by Qt use this class to place tooltips, menus and dialog boxes on the correct screen for their parent or application widgets. Applications can use this class to obtain information that can be used to save window positions, or to place child widgets and dialogs on one particular screen.</source>
          <target state="translated">Qt에서 제공하는 위젯은이 클래스를 사용하여 툴팁, 메뉴 및 대화 상자를 부모 또는 응용 프로그램 위젯의 올바른 화면에 배치합니다. 응용 프로그램은이 클래스를 사용하여 창 위치를 저장하거나 하나의 특정 화면에 하위 위젯 및 대화 상자를 배치하는 데 사용할 수있는 정보를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8435adf39417939d470169f9dd634d2c7c95c2ce" translate="yes" xml:space="preserve">
          <source>Widgets respond to events that are typically caused by user actions. Qt delivers events to widgets by calling specific event handler functions with instances of &lt;a href=&quot;qevent&quot;&gt;QEvent&lt;/a&gt; subclasses containing information about each event.</source>
          <target state="translated">위젯은 일반적으로 사용자 조치로 인해 발생하는 이벤트에 응답합니다. Qt 는 각 이벤트에 대한 정보를 포함하는 &lt;a href=&quot;qevent&quot;&gt;QEvent&lt;/a&gt; 서브 클래스 인스턴스와 함께 특정 이벤트 핸들러 함수를 호출하여 위젯에 이벤트를 전달합니다 .</target>
        </trans-unit>
        <trans-unit id="2b8947d39fb6587b9472fef874de80f84ce0c6ae" translate="yes" xml:space="preserve">
          <source>Widgets that accept keyboard input need to reimplement a few more event handlers:</source>
          <target state="translated">키보드 입력을 허용하는 위젯은 몇 가지 이벤트 핸들러를 다시 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="13aa1b4026942b9bb6ce1d114f57043c15bb811a" translate="yes" xml:space="preserve">
          <source>Width of a check box indicator.</source>
          <target state="translated">확인란 표시기의 너비.</target>
        </trans-unit>
        <trans-unit id="92d4f7c9f5b5b6ac456fc0ee64663a9569268102" translate="yes" xml:space="preserve">
          <source>Width of a chunk in a progress bar indicator.</source>
          <target state="translated">진행률 표시 줄의 청크 너비입니다.</target>
        </trans-unit>
        <trans-unit id="1bbc2f9725c899cb0bb83f2ac435543faf31e492" translate="yes" xml:space="preserve">
          <source>Width of a minimized MDI window.</source>
          <target state="translated">최소화 된 MDI 창의 너비</target>
        </trans-unit>
        <trans-unit id="14711779662ca811a72137d0c1355bfa4f31084a" translate="yes" xml:space="preserve">
          <source>Width of a radio button indicator.</source>
          <target state="translated">라디오 버튼 표시기의 너비.</target>
        </trans-unit>
        <trans-unit id="474ac5fcafa931fe0fd6910ec15a46cc6c3ce29f" translate="yes" xml:space="preserve">
          <source>Width of a separator in a horizontal dock window and the height of a separator in a vertical dock window.</source>
          <target state="translated">수평 도크 윈도우에서 분리기의 너비 및 수직 도크 윈도우에서 분리기의 높이.</target>
        </trans-unit>
        <trans-unit id="f9cbd344f389b2fdebda9d82f10d6de85a07d4a5" translate="yes" xml:space="preserve">
          <source>Width of a single frame in this &lt;a href=&quot;qml-qtquick-animatedsprite&quot;&gt;AnimatedSprite&lt;/a&gt;.</source>
          <target state="translated">이 &lt;a href=&quot;qml-qtquick-animatedsprite&quot;&gt;AnimatedSprite&lt;/a&gt; 의 단일 프레임 너비입니다 .</target>
        </trans-unit>
        <trans-unit id="4a8fe03d63b5269a8ee17b3af8c19e9ab02f872f" translate="yes" xml:space="preserve">
          <source>Width of a single frame in this sprite.</source>
          <target state="translated">이 스프라이트에서 단일 프레임의 너비입니다.</target>
        </trans-unit>
        <trans-unit id="61f0e5039b4c2de4949e55939503187e4677dbee" translate="yes" xml:space="preserve">
          <source>Width of a splitter.</source>
          <target state="translated">스플리터의 너비.</target>
        </trans-unit>
        <trans-unit id="8f394f722525a92857f04c8b25a4ff0084fcc97b" translate="yes" xml:space="preserve">
          <source>Width of a toolbar extension button in a horizontal toolbar and the height of the button in a vertical toolbar.</source>
          <target state="translated">가로 도구 모음의 도구 모음 확장 단추 너비 및 세로 도구 모음의 단추 높이</target>
        </trans-unit>
        <trans-unit id="a276f4d87ef046e18ddd9eaa41ad0a5ce04c4153" translate="yes" xml:space="preserve">
          <source>Width of a toolbar handle in a horizontal toolbar and the height of the handle in a vertical toolbar.</source>
          <target state="translated">가로 도구 모음의 도구 모음 핸들 너비와 세로 도구 모음의 핸들 높이</target>
        </trans-unit>
        <trans-unit id="f6475409c1ca0bbf3519ed0b865993d83442f005" translate="yes" xml:space="preserve">
          <source>Width of a toolbar separator in a horizontal toolbar and the height of a separator in a vertical toolbar.</source>
          <target state="translated">가로 도구 모음의 도구 모음 구분자 너비와 세로 도구 모음의 구분자 높이입니다.</target>
        </trans-unit>
        <trans-unit id="f32cdf111f802f1e77076f374ad98edca36bb759" translate="yes" xml:space="preserve">
          <source>Width of a vertical scroll bar and the height of a horizontal scroll bar.</source>
          <target state="translated">세로 스크롤 막대의 너비와 가로 스크롤 막대의 높이입니다.</target>
        </trans-unit>
        <trans-unit id="b1b76acd84d65d7c89a34bfe549816feb6684e6e" translate="yes" xml:space="preserve">
          <source>Width of table or cell border</source>
          <target state="translated">표 또는 셀 테두리의 너비</target>
        </trans-unit>
        <trans-unit id="894a83e2504cfb44500a8d72eba1c5a9876f1107" translate="yes" xml:space="preserve">
          <source>Width of the alternate keys list item.</source>
          <target state="translated">대체 키 목록 항목의 너비</target>
        </trans-unit>
        <trans-unit id="ca01378df4fc7f57ef1854241261d4957d8070cb" translate="yes" xml:space="preserve">
          <source>Width of the default-button indicator frame.</source>
          <target state="translated">기본 버튼 표시기 프레임의 너비.</target>
        </trans-unit>
        <trans-unit id="bff587a72664f0ce6c24d49d77072e269e5af574" translate="yes" xml:space="preserve">
          <source>Width of the frame around toolbars.</source>
          <target state="translated">툴바 주위의 프레임 너비.</target>
        </trans-unit>
        <trans-unit id="32d20c7e2973072db1690d05d4a9bbb06c5587ac" translate="yes" xml:space="preserve">
          <source>Width of the handle in a horizontal dock window and the height of the handle in a vertical dock window.</source>
          <target state="translated">수평 독 창에서 핸들 너비와 수직 독 창에서 핸들 높이</target>
        </trans-unit>
        <trans-unit id="30d21fa5d9cb79597ff503bf1dbbb488b65a5ede" translate="yes" xml:space="preserve">
          <source>Width of the menu button indicator proportional to the widget height.</source>
          <target state="translated">위젯 높이에 비례하는 메뉴 버튼 표시기의 너비.</target>
        </trans-unit>
        <trans-unit id="4f983a660ea1223340ae32159c1ab35d5e29bd2f" translate="yes" xml:space="preserve">
          <source>Wiki</source>
          <target state="translated">Wiki</target>
        </trans-unit>
        <trans-unit id="641be895c08513d3bfd01d7c1a2ff3ca352244e4" translate="yes" xml:space="preserve">
          <source>Wildcard Matching</source>
          <target state="translated">와일드 카드 일치</target>
        </trans-unit>
        <trans-unit id="264c29d9ea22af548e907b36f322bb974b5a6976" translate="yes" xml:space="preserve">
          <source>Wildcard matching</source>
          <target state="translated">와일드 카드 일치</target>
        </trans-unit>
        <trans-unit id="0689321b58e7a5fc78253890378bdaabbc1eb587" translate="yes" xml:space="preserve">
          <source>Wildcard matching can be convenient because of its simplicity, but any wildcard regexp can be defined using full regexps, e.g. &lt;b&gt;.*\.html$&lt;/b&gt;. Notice that we can't match both &lt;code&gt;.html&lt;/code&gt; and &lt;code&gt;.htm&lt;/code&gt; files with a wildcard unless we use &lt;b&gt;*.htm*&lt;/b&gt; which will also match 'test.html.bak'. A full regexp gives us the precision we need, &lt;b&gt;.*\.html?$&lt;/b&gt;.</source>
          <target state="translated">와일드 카드 일치는 단순하기 때문에 편리 할 수 ​​있지만 모든 정규식을 사용하여 와일드 카드 정규식을 정의 할 수 있습니다 (예 : &lt;b&gt;. * \. html $)&lt;/b&gt; . 'test.html.bak'과도 일치하는 &lt;b&gt;* .htm *&lt;/b&gt; 을 사용하지 않으면 &lt;code&gt;.html&lt;/code&gt; 및 &lt;code&gt;.htm&lt;/code&gt; 파일을 모두 와일드 카드 와 일치시킬 수 없습니다 . 전체 정규 표현식은 우리에게 우리가 필요로하는 정밀도를 제공합니다 &lt;b&gt;. * \. html로? $&lt;/b&gt; .&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="842dc21d7451aa6ca7d995ac3b01dfa569693150" translate="yes" xml:space="preserve">
          <source>Wildcards in Name Tests</source>
          <target state="translated">이름 테스트의 와일드 카드</target>
        </trans-unit>
        <trans-unit id="6e5c972bd26124738ee77c46943b74e25b91eac4" translate="yes" xml:space="preserve">
          <source>Will apply kerning between adjacent glyphs. Note that OpenType GPOS based kerning is currently not supported.</source>
          <target state="translated">인접한 글리프 사이에 커닝을 적용합니다. OpenType GPOS 기반 커닝은 현재 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6adcd11c4e61fb7fcde2432b7a7de1f735d1edeb" translate="yes" xml:space="preserve">
          <source>Will be used when &lt;a href=&quot;qml-qtquick-controls-styles-menustyle#styledata-properties&quot;&gt;styleData.checkable&lt;/a&gt; is &lt;code&gt;true&lt;/code&gt; and its appearance may depend on &lt;a href=&quot;qml-qtquick-controls-styles-menustyle#styledata-properties&quot;&gt;styleData.exclusive&lt;/a&gt;, i.e., whether it will behave like a checkbox or a radio button. Use &lt;a href=&quot;qml-qtquick-controls-styles-menustyle#styledata-properties&quot;&gt;styleData.checked&lt;/a&gt; for the checked state.</source>
          <target state="translated">때 사용됩니다 &lt;a href=&quot;qml-qtquick-controls-styles-menustyle#styledata-properties&quot;&gt;styleData.checkable가&lt;/a&gt; 있다 &lt;code&gt;true&lt;/code&gt; 과 그 모양이에 따라 달라질 수 있습니다 &lt;a href=&quot;qml-qtquick-controls-styles-menustyle#styledata-properties&quot;&gt;styleData.exclusive&lt;/a&gt; 은 체크 박스 또는 라디오 버튼처럼 작동 여부, 즉,. 확인 된 상태에는 &lt;a href=&quot;qml-qtquick-controls-styles-menustyle#styledata-properties&quot;&gt;styleData.checked&lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="51a4364950010d7d1a3acb13be6215316f24c111" translate="yes" xml:space="preserve">
          <source>Will be used when &lt;a href=&quot;qml-qtquick-controls-styles-menustyle#styledata-properties&quot;&gt;styleData.type&lt;/a&gt; equals &lt;code&gt;MenuItemType.ScrollIndicator&lt;/code&gt;. Its appearance should follow &lt;a href=&quot;qml-qtquick-controls-styles-menustyle#styledata-properties&quot;&gt;styleData.scrollerDirection&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-controls-styles-menustyle#styledata-properties&quot;&gt;styleData.type&lt;/a&gt; 이 &lt;code&gt;MenuItemType.ScrollIndicator&lt;/code&gt; 와 같은 경우에 사용됩니다 . 모양은 &lt;a href=&quot;qml-qtquick-controls-styles-menustyle#styledata-properties&quot;&gt;styleData.scrollerDirection&lt;/a&gt; 을 따라야 합니다 .</target>
        </trans-unit>
        <trans-unit id="2d3d1b653fde72951f28f65e2262012bbda10fb4" translate="yes" xml:space="preserve">
          <source>Will be used when &lt;a href=&quot;qml-qtquick-controls-styles-menustyle#styledata-properties&quot;&gt;styleData.type&lt;/a&gt; equals &lt;code&gt;MenuItemType.Separator&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-controls-styles-menustyle#styledata-properties&quot;&gt;styleData.type&lt;/a&gt; 이 &lt;code&gt;MenuItemType.Separator&lt;/code&gt; 와 같은 경우에 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="2f33960d13f8f9fc04e9fc9347816f610864f0b2" translate="yes" xml:space="preserve">
          <source>Will calculate the advance for each glyph separately.</source>
          <target state="translated">각 글리프의 진행률을 별도로 계산합니다.</target>
        </trans-unit>
        <trans-unit id="4ce4d9e973b6847fa6d154ff1d851dfe8de757ff" translate="yes" xml:space="preserve">
          <source>Will emit the &lt;a href=&quot;qml-qtquick-controls-action#triggered-signal&quot;&gt;triggered&lt;/a&gt; signal if the action is enabled. You may provide a source object if the Action would benefit from knowing the origin of the triggering (e.g. for analytics). Will also emit the &lt;a href=&quot;qml-qtquick-controls-action#toggled-signal&quot;&gt;toggled&lt;/a&gt; signal if it is checkable.</source>
          <target state="translated">작업이 활성화 된 경우 &lt;a href=&quot;qml-qtquick-controls-action#triggered-signal&quot;&gt;트리거 된&lt;/a&gt; 신호를 방출합니다 . 액션이 트리거의 출처를 아는 것 (예 : 분석)을 통해 이익을 얻는 경우 소스 개체를 제공 할 수 있습니다. 확인 가능한 경우 &lt;a href=&quot;qml-qtquick-controls-action#toggled-signal&quot;&gt;토글 된&lt;/a&gt; 신호 도 방출합니다 .</target>
        </trans-unit>
        <trans-unit id="7301c83fbf138cebca4da71bad28da58a32bc6c1" translate="yes" xml:space="preserve">
          <source>Will emit the &lt;a href=&quot;qml-qtquick-controls-action#triggered-signal&quot;&gt;triggered&lt;/a&gt; signal on</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-controls-action#triggered-signal&quot;&gt;트리거 된&lt;/a&gt; 신호를 방출합니다 .</target>
        </trans-unit>
        <trans-unit id="d1fe5801cc23bc8576afb39d3f08ee6b2c234d3f" translate="yes" xml:space="preserve">
          <source>Will import to Qt Quick 3D as...</source>
          <target state="translated">Qt Quick 3D로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="992c93fbc65bfa4b132279890e307aebb42bb7f8" translate="yes" xml:space="preserve">
          <source>Will rasterize by measuring the coverage of each subpixel, returning a separate alpha value for each of the red, green and blue components of each pixel.</source>
          <target state="translated">각 하위 픽셀의 적용 범위를 측정하여 각 픽셀의 빨강, 녹색 및 파랑 구성 요소마다 별도의 알파 값을 반환하여 래스터 화합니다.</target>
        </trans-unit>
        <trans-unit id="9d68c46bc41f81a77f83f10f64be90ea8298c3af" translate="yes" xml:space="preserve">
          <source>Will rasterize by measuring the coverage of the shape on whole pixels. The returned image contains the alpha values of each pixel based on the coverage of the glyph shape.</source>
          <target state="translated">전체 픽셀에서 모양의 범위를 측정하여 래스터 화합니다. 반환 된 이미지에는 글리프 모양의 적용 범위를 기준으로 각 픽셀의 알파 값이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="cfd625b13d3522bd90aa1cf7729a05018cda7fe8" translate="yes" xml:space="preserve">
          <source>Will return &lt;code&gt;0&lt;/code&gt; if the size is automatically controlled by &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtwebengine-module.html&quot;&gt;QtWebEngine&lt;/a&gt;.</source>
          <target state="translated">반환 &lt;code&gt;0&lt;/code&gt; 크기가 자동으로 조절되는 경우 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtwebengine-module.html&quot;&gt;QtWebEngine&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bacdfcd8e58eaf720dc472b61c16ef6202195524" translate="yes" xml:space="preserve">
          <source>Will return &lt;code&gt;0&lt;/code&gt; if the size is automatically controlled by &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtwebengine-module.html&quot;&gt;QtWebEngine&lt;/a&gt;.</source>
          <target state="translated">반환 &lt;code&gt;0&lt;/code&gt; 크기가 자동으로 조절되는 경우 &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtwebengine-module.html&quot;&gt;QtWebEngine&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="694d20076668702064af4b5c6b9aab479e6fa21a" translate="yes" xml:space="preserve">
          <source>Will return an invalid &lt;a href=&quot;qgeomaneuver&quot;&gt;QGeoManeuver&lt;/a&gt; if no information has been attached to the starting point of this route segment.</source>
          <target state="translated">이 경로 세그먼트의 시작 지점에 정보가 첨부되지 않은 경우 유효하지 않은 &lt;a href=&quot;qgeomaneuver&quot;&gt;QGeoManeuver를&lt;/a&gt; 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="0a4ef5f5759743ffb735d1db3489350440cdf859" translate="yes" xml:space="preserve">
          <source>Will return an invalid route segment if there are no route segments associated with the route.</source>
          <target state="translated">경로와 연관된 경로 세그먼트가없는 경우 유효하지 않은 경로 세그먼트를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5159390ce4cc4497f2c1225b18cf5c8e403dd9f6" translate="yes" xml:space="preserve">
          <source>Will return an invalid route segment if this is the last route segment in the route.</source>
          <target state="translated">경로의 마지막 경로 세그먼트 인 경우 유효하지 않은 경로 세그먼트를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7ad1aafdccf8b805105c57c9e774c1ad40595b7a" translate="yes" xml:space="preserve">
          <source>Will return invalid maneuver if no information has been attached to the endpoint of this route segment.</source>
          <target state="translated">이 경로 세그먼트의 끝점에 정보가 첨부되지 않은 경우 유효하지 않은 기동을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7b653c1a1342f29b6e1ca16ef44b1d14c98a11e3" translate="yes" xml:space="preserve">
          <source>Win32</source>
          <target state="translated">Win32</target>
        </trans-unit>
        <trans-unit id="d2afd817a9a21d99da015861401e78ff2526d7a1" translate="yes" xml:space="preserve">
          <source>WinLayout</source>
          <target state="translated">WinLayout</target>
        </trans-unit>
        <trans-unit id="075ad31795be6f90667ef90b6e5605875ceafe6f" translate="yes" xml:space="preserve">
          <source>WinRT</source>
          <target state="translated">WinRT</target>
        </trans-unit>
        <trans-unit id="ee05c284cf8b3483c03d4f9413a6c2310a64206c" translate="yes" xml:space="preserve">
          <source>WinRT - Not supported</source>
          <target state="translated">WinRT-지원되지 않음</target>
        </trans-unit>
        <trans-unit id="6cc4e52a56e0ff55e5943fa5bda3b3d49ec65e52" translate="yes" xml:space="preserve">
          <source>WinRT - Not supported yet</source>
          <target state="translated">WinRT-아직 지원되지 않음</target>
        </trans-unit>
        <trans-unit id="b0ecf59b61b6d43691094d1b7be8be240577897f" translate="yes" xml:space="preserve">
          <source>WinRT Runner Tool</source>
          <target state="translated">WinRT 러너 도구</target>
        </trans-unit>
        <trans-unit id="b2b2b1b85fe8deb53a167363dcd5fa56d7734c79" translate="yes" xml:space="preserve">
          <source>WinRT and Windows Phone support</source>
          <target state="translated">WinRT 및 Windows Phone 지원</target>
        </trans-unit>
        <trans-unit id="41dfc0a6c92707948578891c51d98c6443be63cc" translate="yes" xml:space="preserve">
          <source>Window</source>
          <target state="translated">Window</target>
        </trans-unit>
        <trans-unit id="b30704d31f5e4aca87353b66ee27f0816caa9047" translate="yes" xml:space="preserve">
          <source>Window (QML type)</source>
          <target state="translated">창 (QML 유형)</target>
        </trans-unit>
        <trans-unit id="a6f90711f4f4ceeeabf6b9b10a46a7febed2ecf4" translate="yes" xml:space="preserve">
          <source>Window Embedding</source>
          <target state="translated">창 포함</target>
        </trans-unit>
        <trans-unit id="afaebc89cf3ada29e4b3c2ac4b9b1ed9b0776e61" translate="yes" xml:space="preserve">
          <source>Window Geometry</source>
          <target state="translated">창 형상</target>
        </trans-unit>
        <trans-unit id="8c70131ff98a78ebc4b38d71ff8aaf60f268bc44" translate="yes" xml:space="preserve">
          <source>Window Managers</source>
          <target state="translated">창 관리자</target>
        </trans-unit>
        <trans-unit id="25c90920abe1ae75b09c4a801a9be777978eb59e" translate="yes" xml:space="preserve">
          <source>Window QML Type</source>
          <target state="translated">창 QML 유형</target>
        </trans-unit>
        <trans-unit id="b99fcf0354e6f2b755b1cd4436f8833d7b57f92d" translate="yes" xml:space="preserve">
          <source>Window and Dialog Widgets</source>
          <target state="translated">창 및 대화 상자 위젯</target>
        </trans-unit>
        <trans-unit id="df2b265af4964191becf35116f05a11290f1a10a" translate="yes" xml:space="preserve">
          <source>Window contents</source>
          <target state="translated">창 내용</target>
        </trans-unit>
        <trans-unit id="0693d8804ff10e8ccf636d73f83dc84b2aebcac8" translate="yes" xml:space="preserve">
          <source>Window flags are a combination of a type (e.g. &lt;a href=&quot;qt#WindowType-enum&quot;&gt;Qt::Dialog&lt;/a&gt;) and zero or more hints to the window system (e.g. &lt;a href=&quot;qt#WindowType-enum&quot;&gt;Qt::FramelessWindowHint&lt;/a&gt;).</source>
          <target state="translated">창 플래그는 유형 (예 : &lt;a href=&quot;qt#WindowType-enum&quot;&gt;Qt :: Dialog&lt;/a&gt; )과 창 시스템에 대한 0 개 이상의 힌트 (예 : &lt;a href=&quot;qt#WindowType-enum&quot;&gt;Qt :: FramelessWindowHint&lt;/a&gt; )의 조합입니다.</target>
        </trans-unit>
        <trans-unit id="c757786995d9190138fd07f2d2690dd25188aab3" translate="yes" xml:space="preserve">
          <source>Window flags are a combination of a window type (e.g., &lt;a href=&quot;qt#WindowType-enum&quot;&gt;Qt::Dialog&lt;/a&gt;) and several flags giving hints on the behavior of the window. The behavior is platform-dependent.</source>
          <target state="translated">창 플래그는 창 유형 (예 : &lt;a href=&quot;qt#WindowType-enum&quot;&gt;Qt :: Dialog&lt;/a&gt; )과 창의 동작에 대한 힌트를 제공하는 여러 플래그 의 조합입니다 . 동작은 플랫폼에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="cec65d78532248828b5443e4752a3df7fc4931aa" translate="yes" xml:space="preserve">
          <source>Window functions</source>
          <target state="translated">창 기능</target>
        </trans-unit>
        <trans-unit id="3fa481de6469402233a67efbe0146e989104a11b" translate="yes" xml:space="preserve">
          <source>Window resize handle; see also &lt;a href=&quot;qsizegrip&quot;&gt;QSizeGrip&lt;/a&gt;.</source>
          <target state="translated">창 크기 조정 핸들; &lt;a href=&quot;qsizegrip&quot;&gt;QSizeGrip&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="dc2b89e9ddde77184a7e10f4c0458e6e48f4ab30" translate="yes" xml:space="preserve">
          <source>Window size for connection-level flow control is 65535 octets</source>
          <target state="translated">연결 수준 흐름 제어의 창 크기는 65535 옥텟입니다.</target>
        </trans-unit>
        <trans-unit id="20055eafb15abf4e19c72399a0ab5d4ef5aa99b6" translate="yes" xml:space="preserve">
          <source>Window size for connection-level flowcontrol is 2147483647 octets</source>
          <target state="translated">연결 수준 흐름 제어의 창 크기는 2147483647 옥텟입니다.</target>
        </trans-unit>
        <trans-unit id="4b26bc7091bc1c4af3f32a7ab5a2cefcc82220cb" translate="yes" xml:space="preserve">
          <source>Window size for stream-level flow control is 65535 octets</source>
          <target state="translated">스트림 수준 흐름 제어의 창 크기는 65535 옥텟입니다.</target>
        </trans-unit>
        <trans-unit id="e4bc6262ebe06c4edde4142238b17583c9cd16ce" translate="yes" xml:space="preserve">
          <source>Window size for stream-level flowcontrol is 21474836 octets</source>
          <target state="translated">스트림 수준 흐름 제어의 창 크기는 21474836 옥텟입니다.</target>
        </trans-unit>
        <trans-unit id="662302c92612f391c0343147262ec6b92216d67b" translate="yes" xml:space="preserve">
          <source>Window system integration</source>
          <target state="translated">윈도우 시스템 통합</target>
        </trans-unit>
        <trans-unit id="d18acd2371180466957c4dbeb8c95ca75708947a" translate="yes" xml:space="preserve">
          <source>Window title label.</source>
          <target state="translated">창 제목 레이블.</target>
        </trans-unit>
        <trans-unit id="1e7af5039c861fb07ace18801d508cb564adec81" translate="yes" xml:space="preserve">
          <source>Window was activated.</source>
          <target state="translated">창이 활성화되었습니다.</target>
        </trans-unit>
        <trans-unit id="11241d466e6bf788119916fe31fa36aaa7c680d9" translate="yes" xml:space="preserve">
          <source>Window was deactivated.</source>
          <target state="translated">창이 비활성화되었습니다.</target>
        </trans-unit>
        <trans-unit id="4e78ce50aed27fdd7018ad1a6b33852628dd8aaf" translate="yes" xml:space="preserve">
          <source>Window-Viewport Conversion</source>
          <target state="translated">창-뷰포트 변환</target>
        </trans-unit>
        <trans-unit id="9a56ea565b4ff2a96660fbe8df2fd15d5fb6f4db" translate="yes" xml:space="preserve">
          <source>Window. This will lead to the windowing system managing the clip of the window, so it will be clipped to the</source>
          <target state="translated">창문. 이것은 윈도우 클립을 윈도우 클립으로 관리하는 윈도우 시스템으로 이어질 것입니다.</target>
        </trans-unit>
        <trans-unit id="75aa12a30bbd7073b47f5f7cb99f4d1c6a2ea986" translate="yes" xml:space="preserve">
          <source>Window.Window.active</source>
          <target state="translated">Window.Window.active</target>
        </trans-unit>
        <trans-unit id="69cabe1a21fa926547a70fb8587746688fc196f1" translate="yes" xml:space="preserve">
          <source>Window.Window.activeFocusItem</source>
          <target state="translated">Window.Window.activeFocusItem</target>
        </trans-unit>
        <trans-unit id="616a52190bba5239135d8c4e401392811e83de3c" translate="yes" xml:space="preserve">
          <source>Window.Window.contentItem</source>
          <target state="translated">Window.Window.contentItem</target>
        </trans-unit>
        <trans-unit id="93e40620929c8582b0726b5723364e2d780aa677" translate="yes" xml:space="preserve">
          <source>Window.Window.height</source>
          <target state="translated">Window.Window.height</target>
        </trans-unit>
        <trans-unit id="22953b19762a43065d9148abdac6278d7ff2c104" translate="yes" xml:space="preserve">
          <source>Window.Window.visibility</source>
          <target state="translated">Window.Window.visibility</target>
        </trans-unit>
        <trans-unit id="84c607816af9ce44f380ed26c792699caaa61a38" translate="yes" xml:space="preserve">
          <source>Window.Window.width</source>
          <target state="translated">Window.Window.width</target>
        </trans-unit>
        <trans-unit id="0d4fed8f27b6cb28fb107fea7f57b40019985ce5" translate="yes" xml:space="preserve">
          <source>Window.Window.window</source>
          <target state="translated">Window.Window.window</target>
        </trans-unit>
        <trans-unit id="179cf5d5f2dd427ea72db08711aff317c829519c" translate="yes" xml:space="preserve">
          <source>Window.active</source>
          <target state="translated">Window.active</target>
        </trans-unit>
        <trans-unit id="2ec4c77567c5777d0776cd5af31f66116b105f3c" translate="yes" xml:space="preserve">
          <source>Window.active : &lt;a href=&quot;qml-bool&quot;&gt;bool&lt;/a&gt;</source>
          <target state="translated">Window.active : &lt;a href=&quot;qml-bool&quot;&gt;부울&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3bbff09b2773e67a67998e0160db3a070da2a71c" translate="yes" xml:space="preserve">
          <source>Window.activeFocusItem</source>
          <target state="translated">Window.activeFocusItem</target>
        </trans-unit>
        <trans-unit id="102676071e8f5b0b5bf6e797da1cc51a37367db6" translate="yes" xml:space="preserve">
          <source>Window.activeFocusItem : &lt;a href=&quot;qml-qtquick-item&quot;&gt;Item&lt;/a&gt;</source>
          <target state="translated">Window.activeFocusItem : &lt;a href=&quot;qml-qtquick-item&quot;&gt;항목&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="323f1a195c556f532788c13c5175ee9673596fa3" translate="yes" xml:space="preserve">
          <source>Window.afterAnimating()</source>
          <target state="translated">Window.afterAnimating()</target>
        </trans-unit>
        <trans-unit id="4f8be4631d56a2a94c008c796a3eb4aa92aca3cb" translate="yes" xml:space="preserve">
          <source>Window.alert()</source>
          <target state="translated">Window.alert()</target>
        </trans-unit>
        <trans-unit id="6b43e57fc6c8546f7d0a20f409e420ff5d4e65f9" translate="yes" xml:space="preserve">
          <source>Window.close()</source>
          <target state="translated">Window.close()</target>
        </trans-unit>
        <trans-unit id="a7c9eb3479ef7276390ef7962c488325517f5cbb" translate="yes" xml:space="preserve">
          <source>Window.closing()</source>
          <target state="translated">Window.closing()</target>
        </trans-unit>
        <trans-unit id="f3bde14aa0bf20f81ada76a1e414cbe06cc13469" translate="yes" xml:space="preserve">
          <source>Window.color</source>
          <target state="translated">Window.color</target>
        </trans-unit>
        <trans-unit id="f7faf5ce1f3058190f74f96458908c816c80839e" translate="yes" xml:space="preserve">
          <source>Window.contentItem</source>
          <target state="translated">Window.contentItem</target>
        </trans-unit>
        <trans-unit id="09dc7d67387c54c429eabc833a823f696fb935b5" translate="yes" xml:space="preserve">
          <source>Window.contentItem : &lt;a href=&quot;qml-qtquick-item&quot;&gt;Item&lt;/a&gt;</source>
          <target state="translated">Window.contentItem : &lt;a href=&quot;qml-qtquick-item&quot;&gt;아이템&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f032a1a0e9d0f20ee5939a3ea15f61dbe8f060f9" translate="yes" xml:space="preserve">
          <source>Window.contentOrientation</source>
          <target state="translated">Window.contentOrientation</target>
        </trans-unit>
        <trans-unit id="d613e60a74c019962e8dc76775ee501bcbf5920a" translate="yes" xml:space="preserve">
          <source>Window.data</source>
          <target state="translated">Window.data</target>
        </trans-unit>
        <trans-unit id="11fcb002371eb69617294814e444f487941c6fa1" translate="yes" xml:space="preserve">
          <source>Window.flags</source>
          <target state="translated">Window.flags</target>
        </trans-unit>
        <trans-unit id="fdef13059eb9fcd4647cf759253900561f86103a" translate="yes" xml:space="preserve">
          <source>Window.frameSwapped()</source>
          <target state="translated">Window.frameSwapped()</target>
        </trans-unit>
        <trans-unit id="a929ff2e9d86ab477a20d2aeeae60315aa00bfb2" translate="yes" xml:space="preserve">
          <source>Window.height</source>
          <target state="translated">Window.height</target>
        </trans-unit>
        <trans-unit id="793cfeb4fba43fe8d353fe472138623da6f45bc2" translate="yes" xml:space="preserve">
          <source>Window.height : &lt;a href=&quot;qml-int&quot;&gt;int&lt;/a&gt;</source>
          <target state="translated">Window.height : &lt;a href=&quot;qml-int&quot;&gt;int&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="76df9491595a49d076cf9f272b97202e15e48128" translate="yes" xml:space="preserve">
          <source>Window.hide()</source>
          <target state="translated">Window.hide()</target>
        </trans-unit>
        <trans-unit id="d1d8ee90db101d9aa7127f0ec7d71ef5b59327e6" translate="yes" xml:space="preserve">
          <source>Window.lower()</source>
          <target state="translated">Window.lower()</target>
        </trans-unit>
        <trans-unit id="811e064daed87f7ca3ccdfcb7526934f9e065065" translate="yes" xml:space="preserve">
          <source>Window.maximumHeight</source>
          <target state="translated">Window.maximumHeight</target>
        </trans-unit>
        <trans-unit id="ed13acfb5440376e7f9248628afa96f7cc080358" translate="yes" xml:space="preserve">
          <source>Window.maximumWidth</source>
          <target state="translated">Window.maximumWidth</target>
        </trans-unit>
        <trans-unit id="400afce45a5265eb1019dbc9d1f9bb720f661363" translate="yes" xml:space="preserve">
          <source>Window.minimumHeight</source>
          <target state="translated">Window.minimumHeight</target>
        </trans-unit>
        <trans-unit id="aebb18a4f2359f546fa8b333d847995d3a5ef4e8" translate="yes" xml:space="preserve">
          <source>Window.minimumWidth</source>
          <target state="translated">Window.minimumWidth</target>
        </trans-unit>
        <trans-unit id="215facd6841224bd8b80b0e006b6ac17f0950cbb" translate="yes" xml:space="preserve">
          <source>Window.modality</source>
          <target state="translated">Window.modality</target>
        </trans-unit>
        <trans-unit id="52b30f9332e30d272f1cbe7146d9734ff2e3a054" translate="yes" xml:space="preserve">
          <source>Window.opacity</source>
          <target state="translated">Window.opacity</target>
        </trans-unit>
        <trans-unit id="5c1a6d6492ac874f9e18f2d2de58a1ed70ac7075" translate="yes" xml:space="preserve">
          <source>Window.raise()</source>
          <target state="translated">Window.raise()</target>
        </trans-unit>
        <trans-unit id="500cae6ce1cd976b0844ee9632f2878e1490269c" translate="yes" xml:space="preserve">
          <source>Window.requestActivate()</source>
          <target state="translated">Window.requestActivate()</target>
        </trans-unit>
        <trans-unit id="eb32abc5b963808e0f1c4b506580bafb1dabdc33" translate="yes" xml:space="preserve">
          <source>Window.sceneGraphError()</source>
          <target state="translated">Window.sceneGraphError()</target>
        </trans-unit>
        <trans-unit id="962ec69a27517c38617be980e1a32ddfb58994c1" translate="yes" xml:space="preserve">
          <source>Window.screen</source>
          <target state="translated">Window.screen</target>
        </trans-unit>
        <trans-unit id="0836742cd959538d97470c7c5bb8e340e0e0b143" translate="yes" xml:space="preserve">
          <source>Window.show()</source>
          <target state="translated">Window.show()</target>
        </trans-unit>
        <trans-unit id="15504334bab2ba8401f9c0c42488a68ecf682d96" translate="yes" xml:space="preserve">
          <source>Window.showFullScreen()</source>
          <target state="translated">Window.showFullScreen()</target>
        </trans-unit>
        <trans-unit id="7a246186c9eb48c96b4f883f3c6ed5900df7bd62" translate="yes" xml:space="preserve">
          <source>Window.showMaximized()</source>
          <target state="translated">Window.showMaximized()</target>
        </trans-unit>
        <trans-unit id="9721d3ac26edfe36e03b800b63ea8a88c859ba6d" translate="yes" xml:space="preserve">
          <source>Window.showMinimized()</source>
          <target state="translated">Window.showMinimized()</target>
        </trans-unit>
        <trans-unit id="ecb33e6d10f93ea783d42c3441c123f5ac26ae90" translate="yes" xml:space="preserve">
          <source>Window.showNormal()</source>
          <target state="translated">Window.showNormal()</target>
        </trans-unit>
        <trans-unit id="b1a931100f91b3faa30216470bb54c3f9ef3a759" translate="yes" xml:space="preserve">
          <source>Window.title</source>
          <target state="translated">Window.title</target>
        </trans-unit>
        <trans-unit id="f84bfdc72053f81e11626d23f71d5a72df94234a" translate="yes" xml:space="preserve">
          <source>Window.transientParent</source>
          <target state="translated">Window.transientParent</target>
        </trans-unit>
        <trans-unit id="add5b572eae34b1475c4ac663ea27705fe0c5b75" translate="yes" xml:space="preserve">
          <source>Window.visibility</source>
          <target state="translated">Window.visibility</target>
        </trans-unit>
        <trans-unit id="31290646537daaae9feb4d0a6aa47fa2d4fe8dd1" translate="yes" xml:space="preserve">
          <source>Window.visibility : QWindow::Visibility</source>
          <target state="translated">Window.visibility : QWindow :: 가시성</target>
        </trans-unit>
        <trans-unit id="040ee819374dd276f63a974e22660242040fe0ef" translate="yes" xml:space="preserve">
          <source>Window.visible</source>
          <target state="translated">Window.visible</target>
        </trans-unit>
        <trans-unit id="e2b6f01ff5b633118333310b09ad9f8d07bb756c" translate="yes" xml:space="preserve">
          <source>Window.width : &lt;a href=&quot;qml-int&quot;&gt;int&lt;/a&gt;</source>
          <target state="translated">Window.width : &lt;a href=&quot;qml-int&quot;&gt;int&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ec9ee6d9fc2efb6ef3252fdd48706b294f871836" translate="yes" xml:space="preserve">
          <source>Window.window : &lt;a href=&quot;qml-qtquick-window-window&quot;&gt;Window&lt;/a&gt;</source>
          <target state="translated">Window.window : &lt;a href=&quot;qml-qtquick-window-window&quot;&gt;창&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bcec8455d55425584f2b15ec6321324bf53d5617" translate="yes" xml:space="preserve">
          <source>Window.x</source>
          <target state="translated">Window.x</target>
        </trans-unit>
        <trans-unit id="26d9c28d789c254f71ea99a3463b99a7ccc2f4fa" translate="yes" xml:space="preserve">
          <source>Windows</source>
          <target state="translated">Windows</target>
        </trans-unit>
        <trans-unit id="14bcdd30e3b008c3e7cd704a84f73d1bfd731c35" translate="yes" xml:space="preserve">
          <source>Windows (UWP)</source>
          <target state="translated">윈도우 (UWP)</target>
        </trans-unit>
        <trans-unit id="d1964a9d6c89b899acb90493c815573a0d6f6ea7" translate="yes" xml:space="preserve">
          <source>Windows (Win32 desktop, via XInput 1.3 &amp;amp; 1.4)</source>
          <target state="translated">Windows (Win32 데스크탑, XInput 1.3 및 1.4)</target>
        </trans-unit>
        <trans-unit id="964670c3979f39f09220262ac02382dcc43eb2c3" translate="yes" xml:space="preserve">
          <source>Windows (classic desktop)</source>
          <target state="translated">Windows (클래식 데스크탑)</target>
        </trans-unit>
        <trans-unit id="ba69620743da0d9dcd1d7e5dc758450978354d5d" translate="yes" xml:space="preserve">
          <source>Windows (desktop)</source>
          <target state="translated">Windows (데스크톱)</target>
        </trans-unit>
        <trans-unit id="cd2780c0a461f71c64280f5c562710d620fd6396" translate="yes" xml:space="preserve">
          <source>Windows - Intel(R) C++ Compiler for 32-bit applications, Version 9.1.040.</source>
          <target state="translated">Windows-32 비트 응용 프로그램 용 인텔 (R) C ++ 컴파일러, 버전 9.1.040.</target>
        </trans-unit>
        <trans-unit id="1cb7956bf146a8ba0806fced6a0163472a25a83e" translate="yes" xml:space="preserve">
          <source>Windows 10</source>
          <target state="translated">윈도우 10</target>
        </trans-unit>
        <trans-unit id="1afe86f5efcb6d9798deb38cbf3ecf0a9ebaf810" translate="yes" xml:space="preserve">
          <source>Windows 10 (1809) October 2018 Update</source>
          <target state="translated">Windows 10 (1809) 2018 년 10 월 업데이트</target>
        </trans-unit>
        <trans-unit id="d23b7faed6bed5922202a2b284d65aff84bf884f" translate="yes" xml:space="preserve">
          <source>Windows 10 Desktop</source>
          <target state="translated">Windows 10 데스크탑</target>
        </trans-unit>
        <trans-unit id="ad030707429da2bedc40732e3d358db41d7651fa" translate="yes" xml:space="preserve">
          <source>Windows 10 IoT</source>
          <target state="translated">Windows 10 IoT</target>
        </trans-unit>
        <trans-unit id="4db48ac648a42f512034fb991a7275e05d76ee88" translate="yes" xml:space="preserve">
          <source>Windows 10 Mobile</source>
          <target state="translated">윈도우 10 모바일</target>
        </trans-unit>
        <trans-unit id="8cb565cb88209e257041b93101044e961a66e53d" translate="yes" xml:space="preserve">
          <source>Windows 10 SDK version 10.0.18362 or later</source>
          <target state="translated">Windows 10 SDK 버전 10.0.18362 이상</target>
        </trans-unit>
        <trans-unit id="94cada20ad68e1ffe3678826da4a09dc6377e803" translate="yes" xml:space="preserve">
          <source>Windows 7</source>
          <target state="translated">윈도우 7</target>
        </trans-unit>
        <trans-unit id="2421598f872b2a34cd8e8c5cdad74ac27cddd334" translate="yes" xml:space="preserve">
          <source>Windows 7 and Windows Vista (w/Platform Update) and DirectWrite enabled in Qt</source>
          <target state="translated">Qt에서 Windows 7 및 Windows Vista (플랫폼 업데이트 포함) 및 DirectWrite 사용</target>
        </trans-unit>
        <trans-unit id="9fe8c734d18c33e1fe587ed88ac86891c9413013" translate="yes" xml:space="preserve">
          <source>Windows 8.1</source>
          <target state="translated">윈도우 8.1</target>
        </trans-unit>
        <trans-unit id="0059c3585082dc8d8fa84aace5dd9574f5a647b2" translate="yes" xml:space="preserve">
          <source>Windows Aero look</source>
          <target state="translated">윈도우 에어로 룩</target>
        </trans-unit>
        <trans-unit id="9603341802d381e4f5dc9450d5f60203fbb1367e" translate="yes" xml:space="preserve">
          <source>Windows Bitmap</source>
          <target state="translated">Windows 비트 맵</target>
        </trans-unit>
        <trans-unit id="b5752a2453d550da484c9d85a1aca88f944da161" translate="yes" xml:space="preserve">
          <source>Windows Format</source>
          <target state="translated">Windows 형식</target>
        </trans-unit>
        <trans-unit id="c779efcd40e07a5f099b994086b2eecbec95fdbf" translate="yes" xml:space="preserve">
          <source>Windows RT</source>
          <target state="translated">윈도우 RT</target>
        </trans-unit>
        <trans-unit id="176562ff7a9ca628c45f66dfe5d7eb18c0c0ff3c" translate="yes" xml:space="preserve">
          <source>Windows Runtime</source>
          <target state="translated">윈도우 런타임</target>
        </trans-unit>
        <trans-unit id="fb193893e70258d483f93a714af1f0fbcff9cfab" translate="yes" xml:space="preserve">
          <source>Windows Time Zones</source>
          <target state="translated">Windows 시간대</target>
        </trans-unit>
        <trans-unit id="abcf695d570ffe730c49f508b0e37f63d25ee587" translate="yes" xml:space="preserve">
          <source>Windows Vista (w/o Platform Update) and earlier</source>
          <target state="translated">Windows Vista (플랫폼 업데이트 없음) 및 이전</target>
        </trans-unit>
        <trans-unit id="76f20bccfe3512339ad2cea01fc1c7809e7d3d15" translate="yes" xml:space="preserve">
          <source>Windows XP</source>
          <target state="translated">윈도우 XP</target>
        </trans-unit>
        <trans-unit id="dd2494d5f30b3df0c2226e4d63b5a83102d7c014" translate="yes" xml:space="preserve">
          <source>Windows and &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; do not support the global mouse selection; they only supports the global clipboard, i.e. they only add text to the clipboard when an explicit copy or cut is made.</source>
          <target state="translated">Windows 및 &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; 는 전역 마우스 선택을 지원하지 않습니다. 글로벌 클립 보드 만 지원합니다. 즉, 명시 적으로 복사하거나 잘라낼 때 클립 보드에 텍스트 만 추가합니다.</target>
        </trans-unit>
        <trans-unit id="c6f63f1ca0009002926ff7190a74402cec32c6d5" translate="yes" xml:space="preserve">
          <source>Windows and &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; does not have the concept of ownership; the clipboard is a fully global resource so all applications are notified of changes.</source>
          <target state="translated">Windows와 &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; 에는 소유권 개념이 없습니다. 클립 보드는 완전한 글로벌 리소스이므로 모든 응용 프로그램에 변경 사항이 통보됩니다.</target>
        </trans-unit>
        <trans-unit id="88023dbcc508c8f7a7c5cbf262c9b6f719968ac5" translate="yes" xml:space="preserve">
          <source>Windows and Screen</source>
          <target state="translated">창과 스크린</target>
        </trans-unit>
        <trans-unit id="bbb43768d8d0148f00fdbeb53721d8cc5c4ca014" translate="yes" xml:space="preserve">
          <source>Windows and macOS do not support the global mouse selection; they only supports the global clipboard, i.e. they only add text to the clipboard when an explicit copy or cut is made.</source>
          <target state="translated">Windows 및 macOS는 전역 마우스 선택을 지원하지 않습니다. 글로벌 클립 보드 만 지원합니다. 즉, 명시적인 복사 또는 잘라내 기가 수행 될 때만 클립 보드에 텍스트를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="9e67941add41d372575cffb3e9bae73319fda15c" translate="yes" xml:space="preserve">
          <source>Windows and macOS does not have the concept of ownership; the clipboard is a fully global resource so all applications are notified of changes.</source>
          <target state="translated">Windows와 macOS에는 소유권 개념이 없습니다. 클립 보드는 완전한 글로벌 리소스이므로 모든 응용 프로그램에 변경 사항이 통보됩니다.</target>
        </trans-unit>
        <trans-unit id="4530472b3bdecaac3503faee0951ef1625f27946" translate="yes" xml:space="preserve">
          <source>Windows are panels. If you set the &lt;a href=&quot;qt#WindowType-enum&quot;&gt;Qt::Window&lt;/a&gt; flag, the &lt;a href=&quot;qgraphicsitem#GraphicsItemFlag-enum&quot;&gt;ItemIsPanel&lt;/a&gt; flag will be set automatically. If you clear the &lt;a href=&quot;qt#WindowType-enum&quot;&gt;Qt::Window&lt;/a&gt; flag, the &lt;a href=&quot;qgraphicsitem#GraphicsItemFlag-enum&quot;&gt;ItemIsPanel&lt;/a&gt; flag is also cleared. Note that the &lt;a href=&quot;qgraphicsitem#GraphicsItemFlag-enum&quot;&gt;ItemIsPanel&lt;/a&gt; flag can be set independently of &lt;a href=&quot;qt#WindowType-enum&quot;&gt;Qt::Window&lt;/a&gt;.</source>
          <target state="translated">Windows는 패널입니다. &lt;a href=&quot;qt#WindowType-enum&quot;&gt;Qt :: Window&lt;/a&gt; 플래그 를 설정하면 &lt;a href=&quot;qgraphicsitem#GraphicsItemFlag-enum&quot;&gt;ItemIsPanel&lt;/a&gt; 플래그가 자동으로 설정됩니다. &lt;a href=&quot;qt#WindowType-enum&quot;&gt;Qt :: Window&lt;/a&gt; 플래그 를 지우면 &lt;a href=&quot;qgraphicsitem#GraphicsItemFlag-enum&quot;&gt;ItemIsPanel&lt;/a&gt; 플래그도 지워집니다. 있습니다 &lt;a href=&quot;qgraphicsitem#GraphicsItemFlag-enum&quot;&gt;ItemIsPanel의&lt;/a&gt; 플래그가 독립적으로 설정할 수 있습니다 &lt;a href=&quot;qt#WindowType-enum&quot;&gt;Qt는 :: 창&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6864cc15af1f952f69248443d0f4dc03d3b25bb5" translate="yes" xml:space="preserve">
          <source>Windows can potentially use a lot of memory. A usual measurement is width times height times color depth. A window might also include multiple buffers to support double and triple buffering, as well as depth and stencil buffers. To release a window's memory resources, call the &lt;a href=&quot;qwindow#destroy&quot;&gt;destroy&lt;/a&gt;() function.</source>
          <target state="translated">Windows는 잠재적으로 많은 메모리를 사용할 수 있습니다. 일반적인 측정은 너비와 높이와 색상 깊이의 차이입니다. 창에는 이중 및 삼중 버퍼링뿐만 아니라 깊이 및 스텐실 버퍼를 지원하는 여러 버퍼가 포함될 수도 있습니다. 윈도우의 메모리 리소스를 해제하려면 &lt;a href=&quot;qwindow#destroy&quot;&gt;destroy&lt;/a&gt; () 함수를 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="80a5f06785e1b4d4f45cb3f6ff587163b46ba663" translate="yes" xml:space="preserve">
          <source>Windows created by the underlying platform APIs may be used as both parent containers for Qt windows, or embedded into Qt windows as child windows.</source>
          <target state="translated">기본 플랫폼 API로 만든 Windows는 Qt 창에 대한 부모 컨테이너로 사용하거나 Qt 창에 자식 창으로 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c001b9e66e2b63587d28dcdcba9f086ad6b8b570" translate="yes" xml:space="preserve">
          <source>Windows native time zone support is severely limited compared to the standard IANA TZ Database. Windows time zones cover larger geographic areas and are thus less accurate in their conversions. They also do not support as much historic conversion data and so may only be accurate for the current year.</source>
          <target state="translated">Windows 기본 시간대 지원은 표준 IANA TZ 데이터베이스에 비해 심각하게 제한됩니다. Windows 표준 시간대는 더 넓은 지역을 다루므로 변환시 정확도가 떨어집니다. 또한 많은 과거 전환 데이터를 지원하지 않으므로 현재 연도에만 정확할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc3313e9f2888acedb3a46ca240a29badb9ae9a8" translate="yes" xml:space="preserve">
          <source>Windows only, Direct2D based engine</source>
          <target state="translated">Windows 전용, Direct2D 기반 엔진</target>
        </trans-unit>
        <trans-unit id="a42fff1d14dd2ae9835c8ac0c2f009a4f65d20db" translate="yes" xml:space="preserve">
          <source>Windows only, Direct3D based engine</source>
          <target state="translated">Windows 전용, Direct3D 기반 엔진</target>
        </trans-unit>
        <trans-unit id="d199049029a1551cfb834f30df67ee5137b30d5f" translate="yes" xml:space="preserve">
          <source>Windows only. Creates a library project for Visual Studio.</source>
          <target state="translated">Windows 만 해당 Visual Studio 용 라이브러리 프로젝트를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="2e356099ec8eff63706235872ca98e82811f76e2" translate="yes" xml:space="preserve">
          <source>Windows only. Creates an application project for Visual Studio. See &lt;a href=&quot;qmake-platform-notes#creating-visual-studio-project-files&quot;&gt;Creating Visual Studio Project Files&lt;/a&gt; for more information.</source>
          <target state="translated">Windows 만 해당 Visual Studio 용 응용 프로그램 프로젝트를 만듭니다. 자세한 내용은 &lt;a href=&quot;qmake-platform-notes#creating-visual-studio-project-files&quot;&gt;Visual Studio 프로젝트 파일 만들기&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9a507b2bcfe2d1bdca3de1fb8ef440ea096e7258" translate="yes" xml:space="preserve">
          <source>Windows only. Specifies the codepage that should be specified in a generated .rc file. This is only utilized if the &lt;a href=&quot;#version&quot;&gt;VERSION&lt;/a&gt; or &lt;a href=&quot;#rc-icons&quot;&gt;RC_ICONS&lt;/a&gt; variable is set and the &lt;a href=&quot;#rc-file&quot;&gt;RC_FILE&lt;/a&gt; and &lt;a href=&quot;#res-file&quot;&gt;RES_FILE&lt;/a&gt; variables are not set.</source>
          <target state="translated">Windows 만 해당 생성 된 .rc 파일에 지정해야하는 코드 페이지를 지정합니다. 이것은 &lt;a href=&quot;#version&quot;&gt;VERSION&lt;/a&gt; 또는 &lt;a href=&quot;#rc-icons&quot;&gt;RC_ICONS&lt;/a&gt; 변수가 설정되고 &lt;a href=&quot;#rc-file&quot;&gt;RC_FILE&lt;/a&gt; 및 &lt;a href=&quot;#res-file&quot;&gt;RES_FILE&lt;/a&gt; 변수가 설정되지 않은 경우에만 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="3fdb2557cdee44b9fa5f8e3ee5e8c140653c66f4" translate="yes" xml:space="preserve">
          <source>Windows only. Specifies the codepage that should be specified in a generated .rc file. This is only utilized if the &lt;a href=&quot;qmake-variable-reference#version&quot;&gt;VERSION&lt;/a&gt; or &lt;a href=&quot;qmake-variable-reference#rc-icons&quot;&gt;RC_ICONS&lt;/a&gt; variable is set and the &lt;a href=&quot;qmake-variable-reference#rc-file&quot;&gt;RC_FILE&lt;/a&gt; and &lt;a href=&quot;qmake-variable-reference#res-file&quot;&gt;RES_FILE&lt;/a&gt; variables are not set.</source>
          <target state="translated">Windows에만 해당됩니다. 생성 된 .rc 파일에 지정되어야하는 코드 페이지를 지정합니다. &lt;a href=&quot;qmake-variable-reference#version&quot;&gt;VERSION&lt;/a&gt; 또는 &lt;a href=&quot;qmake-variable-reference#rc-icons&quot;&gt;RC_ICONS&lt;/a&gt; 변수가 설정되고 &lt;a href=&quot;qmake-variable-reference#rc-file&quot;&gt;RC_FILE&lt;/a&gt; 및 &lt;a href=&quot;qmake-variable-reference#res-file&quot;&gt;RES_FILE&lt;/a&gt; 변수가 설정되지 않은 경우에만 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="413e03f22d7a023136e0f546cc4f986f284360e2" translate="yes" xml:space="preserve">
          <source>Windows only. Specifies the comments for the project target; this is used where applicable for putting the comments in the application's properties. This is only utilized if the &lt;a href=&quot;qmake-variable-reference#version&quot;&gt;VERSION&lt;/a&gt; or &lt;a href=&quot;qmake-variable-reference#rc-icons&quot;&gt;RC_ICONS&lt;/a&gt; variable is set and the &lt;a href=&quot;qmake-variable-reference#rc-file&quot;&gt;RC_FILE&lt;/a&gt; and &lt;a href=&quot;qmake-variable-reference#res-file&quot;&gt;RES_FILE&lt;/a&gt; variables are not set.</source>
          <target state="translated">Windows에만 해당됩니다. 프로젝트 대상에 대한 설명을 지정합니다. 응용 프로그램의 속성에 주석을 넣기 위해 해당되는 경우 사용됩니다. &lt;a href=&quot;qmake-variable-reference#version&quot;&gt;VERSION&lt;/a&gt; 또는 &lt;a href=&quot;qmake-variable-reference#rc-icons&quot;&gt;RC_ICONS&lt;/a&gt; 변수가 설정되고 &lt;a href=&quot;qmake-variable-reference#rc-file&quot;&gt;RC_FILE&lt;/a&gt; 및 &lt;a href=&quot;qmake-variable-reference#res-file&quot;&gt;RES_FILE&lt;/a&gt; 변수가 설정되지 않은 경우에만 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="2243d54caddf6d062e1a834d48f6f71722158bf3" translate="yes" xml:space="preserve">
          <source>Windows only. Specifies the company for the project target; this is used where applicable for putting the company name in the application's properties. This is only utilized if the &lt;a href=&quot;#version&quot;&gt;VERSION&lt;/a&gt; or &lt;a href=&quot;#rc-icons&quot;&gt;RC_ICONS&lt;/a&gt; variable is set and the &lt;a href=&quot;#rc-file&quot;&gt;RC_FILE&lt;/a&gt; and &lt;a href=&quot;#res-file&quot;&gt;RES_FILE&lt;/a&gt; variables are not set.</source>
          <target state="translated">Windows 만 해당 프로젝트 대상의 회사를 지정합니다. 회사 이름을 응용 프로그램 속성에 넣을 때 적용됩니다. 이것은 &lt;a href=&quot;#version&quot;&gt;VERSION&lt;/a&gt; 또는 &lt;a href=&quot;#rc-icons&quot;&gt;RC_ICONS&lt;/a&gt; 변수가 설정되고 &lt;a href=&quot;#rc-file&quot;&gt;RC_FILE&lt;/a&gt; 및 &lt;a href=&quot;#res-file&quot;&gt;RES_FILE&lt;/a&gt; 변수가 설정되지 않은 경우에만 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="f385c9f8ae2cbe01cd516861e2aaf5494726c187" translate="yes" xml:space="preserve">
          <source>Windows only. Specifies the company for the project target; this is used where applicable for putting the company name in the application's properties. This is only utilized if the &lt;a href=&quot;qmake-variable-reference#version&quot;&gt;VERSION&lt;/a&gt; or &lt;a href=&quot;qmake-variable-reference#rc-icons&quot;&gt;RC_ICONS&lt;/a&gt; variable is set and the &lt;a href=&quot;qmake-variable-reference#rc-file&quot;&gt;RC_FILE&lt;/a&gt; and &lt;a href=&quot;qmake-variable-reference#res-file&quot;&gt;RES_FILE&lt;/a&gt; variables are not set.</source>
          <target state="translated">Windows에만 해당됩니다. 프로젝트 대상의 회사를 지정합니다. 응용 프로그램의 속성에 회사 이름을 입력 할 때 사용됩니다. &lt;a href=&quot;qmake-variable-reference#version&quot;&gt;VERSION&lt;/a&gt; 또는 &lt;a href=&quot;qmake-variable-reference#rc-icons&quot;&gt;RC_ICONS&lt;/a&gt; 변수가 설정되고 &lt;a href=&quot;qmake-variable-reference#rc-file&quot;&gt;RC_FILE&lt;/a&gt; 및 &lt;a href=&quot;qmake-variable-reference#res-file&quot;&gt;RES_FILE&lt;/a&gt; 변수가 설정되지 않은 경우에만 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="19bf01b86a10419b90ee1ccfb53e051d44003eb6" translate="yes" xml:space="preserve">
          <source>Windows only. Specifies the copyright information for the project target; this is used where applicable for putting the copyright information in the application's properties. This is only utilized if the &lt;a href=&quot;#version&quot;&gt;VERSION&lt;/a&gt; or &lt;a href=&quot;#rc-icons&quot;&gt;RC_ICONS&lt;/a&gt; variable is set and the &lt;a href=&quot;#rc-file&quot;&gt;RC_FILE&lt;/a&gt; and &lt;a href=&quot;#res-file&quot;&gt;RES_FILE&lt;/a&gt; variables are not set.</source>
          <target state="translated">Windows 만 해당 프로젝트 대상의 저작권 정보를 지정합니다. 응용 프로그램의 속성에 저작권 정보를 넣을 때 적용됩니다. 이것은 &lt;a href=&quot;#version&quot;&gt;VERSION&lt;/a&gt; 또는 &lt;a href=&quot;#rc-icons&quot;&gt;RC_ICONS&lt;/a&gt; 변수가 설정되고 &lt;a href=&quot;#rc-file&quot;&gt;RC_FILE&lt;/a&gt; 및 &lt;a href=&quot;#res-file&quot;&gt;RES_FILE&lt;/a&gt; 변수가 설정되지 않은 경우에만 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="980cb7321b9fed4018d18b965510753498662576" translate="yes" xml:space="preserve">
          <source>Windows only. Specifies the copyright information for the project target; this is used where applicable for putting the copyright information in the application's properties. This is only utilized if the &lt;a href=&quot;qmake-variable-reference#version&quot;&gt;VERSION&lt;/a&gt; or &lt;a href=&quot;qmake-variable-reference#rc-icons&quot;&gt;RC_ICONS&lt;/a&gt; variable is set and the &lt;a href=&quot;qmake-variable-reference#rc-file&quot;&gt;RC_FILE&lt;/a&gt; and &lt;a href=&quot;qmake-variable-reference#res-file&quot;&gt;RES_FILE&lt;/a&gt; variables are not set.</source>
          <target state="translated">Windows에만 해당됩니다. 프로젝트 대상에 대한 저작권 정보를 지정합니다. 이는 해당되는 경우 응용 프로그램의 속성에 저작권 정보를 넣는 데 사용됩니다. &lt;a href=&quot;qmake-variable-reference#version&quot;&gt;VERSION&lt;/a&gt; 또는 &lt;a href=&quot;qmake-variable-reference#rc-icons&quot;&gt;RC_ICONS&lt;/a&gt; 변수가 설정되고 &lt;a href=&quot;qmake-variable-reference#rc-file&quot;&gt;RC_FILE&lt;/a&gt; 및 &lt;a href=&quot;qmake-variable-reference#res-file&quot;&gt;RES_FILE&lt;/a&gt; 변수가 설정되지 않은 경우에만 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="c333020ab74e8a3179b0ccde29f65fc886d6230a" translate="yes" xml:space="preserve">
          <source>Windows only. Specifies the description for the project target; this is used where applicable for putting the description in the application's properties. This is only utilized if the &lt;a href=&quot;#version&quot;&gt;VERSION&lt;/a&gt; or &lt;a href=&quot;#rc-icons&quot;&gt;RC_ICONS&lt;/a&gt; variable is set and the &lt;a href=&quot;#rc-file&quot;&gt;RC_FILE&lt;/a&gt; and &lt;a href=&quot;#res-file&quot;&gt;RES_FILE&lt;/a&gt; variables are not set.</source>
          <target state="translated">Windows 만 해당 프로젝트 대상에 대한 설명을 지정합니다. 이것은 응용 프로그램의 속성에 설명을 넣을 때 적용됩니다. 이것은 &lt;a href=&quot;#version&quot;&gt;VERSION&lt;/a&gt; 또는 &lt;a href=&quot;#rc-icons&quot;&gt;RC_ICONS&lt;/a&gt; 변수가 설정되고 &lt;a href=&quot;#rc-file&quot;&gt;RC_FILE&lt;/a&gt; 및 &lt;a href=&quot;#res-file&quot;&gt;RES_FILE&lt;/a&gt; 변수가 설정되지 않은 경우에만 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="ab636508ffe15886e5a7dd50accae6ccbf38940d" translate="yes" xml:space="preserve">
          <source>Windows only. Specifies the description for the project target; this is used where applicable for putting the description in the application's properties. This is only utilized if the &lt;a href=&quot;qmake-variable-reference#version&quot;&gt;VERSION&lt;/a&gt; or &lt;a href=&quot;qmake-variable-reference#rc-icons&quot;&gt;RC_ICONS&lt;/a&gt; variable is set and the &lt;a href=&quot;qmake-variable-reference#rc-file&quot;&gt;RC_FILE&lt;/a&gt; and &lt;a href=&quot;qmake-variable-reference#res-file&quot;&gt;RES_FILE&lt;/a&gt; variables are not set.</source>
          <target state="translated">Windows에만 해당됩니다. 프로젝트 대상에 대한 설명을 지정합니다. 응용 프로그램의 속성에 설명을 넣는 데 해당하는 경우 사용됩니다. &lt;a href=&quot;qmake-variable-reference#version&quot;&gt;VERSION&lt;/a&gt; 또는 &lt;a href=&quot;qmake-variable-reference#rc-icons&quot;&gt;RC_ICONS&lt;/a&gt; 변수가 설정되고 &lt;a href=&quot;qmake-variable-reference#rc-file&quot;&gt;RC_FILE&lt;/a&gt; 및 &lt;a href=&quot;qmake-variable-reference#res-file&quot;&gt;RES_FILE&lt;/a&gt; 변수가 설정되지 않은 경우에만 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="147326ac5b89ba5b28c67ac522efbc70c06eb4e4" translate="yes" xml:space="preserve">
          <source>Windows only. Specifies the icons that should be included into a generated .rc file. This is only utilized if the &lt;a href=&quot;#rc-file&quot;&gt;RC_FILE&lt;/a&gt; and &lt;a href=&quot;#res-file&quot;&gt;RES_FILE&lt;/a&gt; variable are not set. More details about the generation of .rc files can be found in the &lt;a href=&quot;qmake-platform-notes#&quot;&gt;Platform Notes&lt;/a&gt;.</source>
          <target state="translated">Windows 만 해당 생성 된 .rc 파일에 포함되어야하는 아이콘을 지정합니다. &lt;a href=&quot;#rc-file&quot;&gt;RC_FILE&lt;/a&gt; 및 &lt;a href=&quot;#res-file&quot;&gt;RES_FILE&lt;/a&gt; 변수가 설정되지 않은 경우에만 사용됩니다 . .rc 파일 생성에 대한 자세한 내용은 &lt;a href=&quot;qmake-platform-notes#&quot;&gt;플랫폼 노트를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8a0c03c74a03f108cc96f855ca13c952c62ebd7d" translate="yes" xml:space="preserve">
          <source>Windows only. Specifies the icons that should be included into a generated .rc file. This is only utilized if the &lt;a href=&quot;qmake-variable-reference#rc-file&quot;&gt;RC_FILE&lt;/a&gt; and &lt;a href=&quot;qmake-variable-reference#res-file&quot;&gt;RES_FILE&lt;/a&gt; variable are not set. More details about the generation of .rc files can be found in the &lt;a href=&quot;qmake-platform-notes&quot;&gt;Platform Notes&lt;/a&gt;.</source>
          <target state="translated">Windows에만 해당됩니다. 생성 된 .rc 파일에 포함되어야하는 아이콘을 지정합니다. 이는 &lt;a href=&quot;qmake-variable-reference#rc-file&quot;&gt;RC_FILE&lt;/a&gt; 및 &lt;a href=&quot;qmake-variable-reference#res-file&quot;&gt;RES_FILE&lt;/a&gt; 변수가 설정되지 않은 경우에만 사용됩니다 . .rc 파일 생성에 대한 자세한 내용은 &lt;a href=&quot;qmake-platform-notes&quot;&gt;Platform Notes&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b9ca87a793eeb7ea22195138ad7a17fc1e456a8a" translate="yes" xml:space="preserve">
          <source>Windows only. Specifies the internal name for the project target; this is used where applicable for putting the internal name in the application's properties. This is only utilized if the &lt;a href=&quot;qmake-variable-reference#version&quot;&gt;VERSION&lt;/a&gt; or &lt;a href=&quot;qmake-variable-reference#rc-icons&quot;&gt;RC_ICONS&lt;/a&gt; variable is set and the &lt;a href=&quot;qmake-variable-reference#rc-file&quot;&gt;RC_FILE&lt;/a&gt; and &lt;a href=&quot;qmake-variable-reference#res-file&quot;&gt;RES_FILE&lt;/a&gt; variables are not set.</source>
          <target state="translated">Windows에만 해당됩니다. 프로젝트 대상의 내부 이름을 지정합니다. 응용 프로그램의 속성에 내부 이름을 넣을 때 사용됩니다. &lt;a href=&quot;qmake-variable-reference#version&quot;&gt;VERSION&lt;/a&gt; 또는 &lt;a href=&quot;qmake-variable-reference#rc-icons&quot;&gt;RC_ICONS&lt;/a&gt; 변수가 설정되고 &lt;a href=&quot;qmake-variable-reference#rc-file&quot;&gt;RC_FILE&lt;/a&gt; 및 &lt;a href=&quot;qmake-variable-reference#res-file&quot;&gt;RES_FILE&lt;/a&gt; 변수가 설정되지 않은 경우에만 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="40ae8a9f462e8bb651ff56c1c30dfab4c72ea64b" translate="yes" xml:space="preserve">
          <source>Windows only. Specifies the language that should be specified in a generated .rc file. This is only utilized if the &lt;a href=&quot;#version&quot;&gt;VERSION&lt;/a&gt; or &lt;a href=&quot;#rc-icons&quot;&gt;RC_ICONS&lt;/a&gt; variable is set and the &lt;a href=&quot;#rc-file&quot;&gt;RC_FILE&lt;/a&gt; and &lt;a href=&quot;#res-file&quot;&gt;RES_FILE&lt;/a&gt; variables are not set.</source>
          <target state="translated">Windows 만 해당 생성 된 .rc 파일에 지정해야 할 언어를 지정합니다. 이것은 &lt;a href=&quot;#version&quot;&gt;VERSION&lt;/a&gt; 또는 &lt;a href=&quot;#rc-icons&quot;&gt;RC_ICONS&lt;/a&gt; 변수가 설정되고 &lt;a href=&quot;#rc-file&quot;&gt;RC_FILE&lt;/a&gt; 및 &lt;a href=&quot;#res-file&quot;&gt;RES_FILE&lt;/a&gt; 변수가 설정되지 않은 경우에만 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="0fb789011f5e73b0a394ab15fdfb133db0b442e0" translate="yes" xml:space="preserve">
          <source>Windows only. Specifies the language that should be specified in a generated .rc file. This is only utilized if the &lt;a href=&quot;qmake-variable-reference#version&quot;&gt;VERSION&lt;/a&gt; or &lt;a href=&quot;qmake-variable-reference#rc-icons&quot;&gt;RC_ICONS&lt;/a&gt; variable is set and the &lt;a href=&quot;qmake-variable-reference#rc-file&quot;&gt;RC_FILE&lt;/a&gt; and &lt;a href=&quot;qmake-variable-reference#res-file&quot;&gt;RES_FILE&lt;/a&gt; variables are not set.</source>
          <target state="translated">Windows에만 해당됩니다. 생성 된 .rc 파일에 지정되어야하는 언어를 지정합니다. &lt;a href=&quot;qmake-variable-reference#version&quot;&gt;VERSION&lt;/a&gt; 또는 &lt;a href=&quot;qmake-variable-reference#rc-icons&quot;&gt;RC_ICONS&lt;/a&gt; 변수가 설정되고 &lt;a href=&quot;qmake-variable-reference#rc-file&quot;&gt;RC_FILE&lt;/a&gt; 및 &lt;a href=&quot;qmake-variable-reference#res-file&quot;&gt;RES_FILE&lt;/a&gt; 변수가 설정되지 않은 경우에만 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="98f8cb350c0780aa1e7ffe6f5b94989586bf657f" translate="yes" xml:space="preserve">
          <source>Windows only. Specifies the manifest file for the project target. This is only utilized if the &lt;a href=&quot;qmake-variable-reference#rc-file&quot;&gt;RC_FILE&lt;/a&gt; and &lt;a href=&quot;qmake-variable-reference#res-file&quot;&gt;RES_FILE&lt;/a&gt; variables are not set. Don't forget to remove embed_manifest_exe and embed_manifest_dll from the CONFIG variable, otherwise it will conflict with the compiler generated one.</source>
          <target state="translated">Windows에만 해당됩니다. 프로젝트 대상에 대한 매니페스트 파일을 지정합니다. 이는 &lt;a href=&quot;qmake-variable-reference#rc-file&quot;&gt;RC_FILE&lt;/a&gt; 및 &lt;a href=&quot;qmake-variable-reference#res-file&quot;&gt;RES_FILE&lt;/a&gt; 변수가 설정되지 않은 경우에만 활용됩니다 . CONFIG 변수에서 embed_manifest_exe 및 embed_manifest_dll을 제거하는 것을 잊지 마십시오. 그렇지 않으면 컴파일러에서 생성 한 변수와 충돌합니다.</target>
        </trans-unit>
        <trans-unit id="63a612f72a6e9db0d4224fac3f264427c04501e3" translate="yes" xml:space="preserve">
          <source>Windows only. Specifies the name of the Windows resource compiler's output file for this target. See &lt;a href=&quot;qmake-variable-reference#rc-file&quot;&gt;RC_FILE&lt;/a&gt; and &lt;a href=&quot;qmake-platform-notes#adding-windows-resource-files&quot;&gt;Adding Windows Resource Files&lt;/a&gt;.</source>
          <target state="translated">Windows에만 해당됩니다. 이 대상에 대한 Windows 리소스 컴파일러의 출력 파일 이름을 지정합니다. &lt;a href=&quot;qmake-variable-reference#rc-file&quot;&gt;RC_FILE&lt;/a&gt; 및 &lt;a href=&quot;qmake-platform-notes#adding-windows-resource-files&quot;&gt;Windows 리소스 파일 추가를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f37cbd28ad7237e4d71b047cdf422bdc4c74c5d6" translate="yes" xml:space="preserve">
          <source>Windows only. Specifies the name of the Windows resource file (.rc) for the target. See &lt;a href=&quot;qmake-platform-notes#adding-windows-resource-files&quot;&gt;Adding Windows Resource Files&lt;/a&gt;.</source>
          <target state="translated">Windows에만 해당됩니다. 대상에 대한 Windows 리소스 파일 (.rc)의 이름을 지정합니다. &lt;a href=&quot;qmake-platform-notes#adding-windows-resource-files&quot;&gt;Windows 리소스 파일 추가를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6082b0f9a070a75f28add48a4b799b292f12b26b" translate="yes" xml:space="preserve">
          <source>Windows only. Specifies the original file name for the project target; this is used where applicable for putting the original file name in the application's properties. This is only utilized if the &lt;a href=&quot;qmake-variable-reference#version&quot;&gt;VERSION&lt;/a&gt; or &lt;a href=&quot;qmake-variable-reference#rc-icons&quot;&gt;RC_ICONS&lt;/a&gt; variable is set and the &lt;a href=&quot;qmake-variable-reference#rc-file&quot;&gt;RC_FILE&lt;/a&gt; and &lt;a href=&quot;qmake-variable-reference#res-file&quot;&gt;RES_FILE&lt;/a&gt; variables are not set.</source>
          <target state="translated">Windows에만 해당됩니다. 프로젝트 대상의 원래 파일 이름을 지정합니다. 응용 프로그램의 속성에 원래 파일 이름을 넣는 데 해당하는 경우 사용됩니다. &lt;a href=&quot;qmake-variable-reference#version&quot;&gt;VERSION&lt;/a&gt; 또는 &lt;a href=&quot;qmake-variable-reference#rc-icons&quot;&gt;RC_ICONS&lt;/a&gt; 변수가 설정되고 &lt;a href=&quot;qmake-variable-reference#rc-file&quot;&gt;RC_FILE&lt;/a&gt; 및 &lt;a href=&quot;qmake-variable-reference#res-file&quot;&gt;RES_FILE&lt;/a&gt; 변수가 설정되지 않은 경우에만 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="52b3eb085c22889904a231f68cf350b66520f1d0" translate="yes" xml:space="preserve">
          <source>Windows only. Specifies the product for the project target; this is used where applicable for putting the product in the application's properties. This is only utilized if the &lt;a href=&quot;#version&quot;&gt;VERSION&lt;/a&gt; or &lt;a href=&quot;#rc-icons&quot;&gt;RC_ICONS&lt;/a&gt; variable is set and the &lt;a href=&quot;#rc-file&quot;&gt;RC_FILE&lt;/a&gt; and &lt;a href=&quot;#res-file&quot;&gt;RES_FILE&lt;/a&gt; variables are not set.</source>
          <target state="translated">Windows 만 해당 프로젝트 대상의 제품을 지정합니다. 응용 프로그램의 속성에 제품을 넣을 때 적용됩니다. 이것은 &lt;a href=&quot;#version&quot;&gt;VERSION&lt;/a&gt; 또는 &lt;a href=&quot;#rc-icons&quot;&gt;RC_ICONS&lt;/a&gt; 변수가 설정되고 &lt;a href=&quot;#rc-file&quot;&gt;RC_FILE&lt;/a&gt; 및 &lt;a href=&quot;#res-file&quot;&gt;RES_FILE&lt;/a&gt; 변수가 설정되지 않은 경우에만 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="e19f9e393f7d7e2821916ad1c1b0a5262a897b47" translate="yes" xml:space="preserve">
          <source>Windows only. Specifies the product for the project target; this is used where applicable for putting the product in the application's properties. This is only utilized if the &lt;a href=&quot;qmake-variable-reference#version&quot;&gt;VERSION&lt;/a&gt; or &lt;a href=&quot;qmake-variable-reference#rc-icons&quot;&gt;RC_ICONS&lt;/a&gt; variable is set and the &lt;a href=&quot;qmake-variable-reference#rc-file&quot;&gt;RC_FILE&lt;/a&gt; and &lt;a href=&quot;qmake-variable-reference#res-file&quot;&gt;RES_FILE&lt;/a&gt; variables are not set.</source>
          <target state="translated">Windows에만 해당됩니다. 프로젝트 대상의 제품을 지정합니다. 응용 프로그램의 속성에 제품을 넣는 데 해당되는 경우 사용됩니다. &lt;a href=&quot;qmake-variable-reference#version&quot;&gt;VERSION&lt;/a&gt; 또는 &lt;a href=&quot;qmake-variable-reference#rc-icons&quot;&gt;RC_ICONS&lt;/a&gt; 변수가 설정되고 &lt;a href=&quot;qmake-variable-reference#rc-file&quot;&gt;RC_FILE&lt;/a&gt; 및 &lt;a href=&quot;qmake-variable-reference#res-file&quot;&gt;RES_FILE&lt;/a&gt; 변수가 설정되지 않은 경우에만 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="546c2d2fbfa3458fba3a9ea511bf5b029c84b008" translate="yes" xml:space="preserve">
          <source>Windows only. Specifies the trademark information for the project target; this is used where applicable for putting the trademark information in the application's properties. This is only utilized if the &lt;a href=&quot;qmake-variable-reference#version&quot;&gt;VERSION&lt;/a&gt; or &lt;a href=&quot;qmake-variable-reference#rc-icons&quot;&gt;RC_ICONS&lt;/a&gt; variable is set and the &lt;a href=&quot;qmake-variable-reference#rc-file&quot;&gt;RC_FILE&lt;/a&gt; and &lt;a href=&quot;qmake-variable-reference#res-file&quot;&gt;RES_FILE&lt;/a&gt; variables are not set.</source>
          <target state="translated">Windows에만 해당됩니다. 프로젝트 대상에 대한 상표 정보를 지정합니다. 응용 프로그램의 속성에 상표 정보를 입력하는 데 사용됩니다. &lt;a href=&quot;qmake-variable-reference#version&quot;&gt;VERSION&lt;/a&gt; 또는 &lt;a href=&quot;qmake-variable-reference#rc-icons&quot;&gt;RC_ICONS&lt;/a&gt; 변수가 설정되고 &lt;a href=&quot;qmake-variable-reference#rc-file&quot;&gt;RC_FILE&lt;/a&gt; 및 &lt;a href=&quot;qmake-variable-reference#res-file&quot;&gt;RES_FILE&lt;/a&gt; 변수가 설정되지 않은 경우에만 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="e68c590bba3dc40637f317996ef3738619b01f03" translate="yes" xml:space="preserve">
          <source>Windows only. Specifies the version number, that the Windows linker puts into the header of the .exe or .dll file via the /VERSION option. Only a major and minor version may be specified. If &lt;a href=&quot;#version-pe-header&quot;&gt;VERSION_PE_HEADER&lt;/a&gt; is not set, it falls back to the major and minor version from &lt;a href=&quot;#version&quot;&gt;VERSION&lt;/a&gt; (if set).</source>
          <target state="translated">Windows 만 해당 Windows 링커가 / VERSION 옵션을 통해 .exe 또는 .dll 파일의 헤더에 넣는 버전 번호를 지정합니다. 메이저 버전과 마이너 버전 만 지정할 수 있습니다. 경우 &lt;a href=&quot;#version-pe-header&quot;&gt;VERSION_PE_HEADER이&lt;/a&gt; 설정되어 있지 않은, 그것의 메이저와 마이너 버전으로 다시 떨어질 &lt;a href=&quot;#version&quot;&gt;버전&lt;/a&gt; (있는 경우 설정).</target>
        </trans-unit>
        <trans-unit id="ce30491cc2abc691711575dbaede3ae3b2060619" translate="yes" xml:space="preserve">
          <source>Windows only. Specifies the version number, that the Windows linker puts into the header of the .exe or .dll file via the /VERSION option. Only a major and minor version may be specified. If &lt;a href=&quot;qmake-variable-reference#version-pe-header&quot;&gt;VERSION_PE_HEADER&lt;/a&gt; is not set, it falls back to the major and minor version from &lt;a href=&quot;qmake-variable-reference#version&quot;&gt;VERSION&lt;/a&gt; (if set).</source>
          <target state="translated">Windows에만 해당됩니다. Windows 링커가 / VERSION 옵션을 통해 .exe 또는 .dll 파일의 헤더에 넣는 버전 번호를 지정합니다. 주 버전과 부 버전 만 지정할 수 있습니다. 경우 &lt;a href=&quot;qmake-variable-reference#version-pe-header&quot;&gt;VERSION_PE_HEADER이&lt;/a&gt; 설정되어 있지 않은, 그것의 메이저와 마이너 버전으로 다시 떨어질 &lt;a href=&quot;qmake-variable-reference#version&quot;&gt;버전&lt;/a&gt; (있는 경우 설정).</target>
        </trans-unit>
        <trans-unit id="3155e904f0d062c5d534df0d5a48138de41c9b3f" translate="yes" xml:space="preserve">
          <source>Windows only. qmake adds the values of this variable as RC preprocessor macros (/d option). If this variable is not set, the &lt;a href=&quot;#defines&quot;&gt;DEFINES&lt;/a&gt; variable is used instead.</source>
          <target state="translated">Windows 만 해당 qmake는이 변수의 값을 RC 전 처리기 매크로 (/ d 옵션)로 추가합니다. 이 변수를 설정하지 않으면 &lt;a href=&quot;#defines&quot;&gt;DEFINES&lt;/a&gt; 변수가 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="46e6b3ff4863172bf8f5600c53e33bdeea31f93d" translate="yes" xml:space="preserve">
          <source>Windows only. qmake adds the values of this variable as RC preprocessor macros (/d option). If this variable is not set, the &lt;a href=&quot;qmake-variable-reference#defines&quot;&gt;DEFINES&lt;/a&gt; variable is used instead.</source>
          <target state="translated">Windows에만 해당됩니다. qmake는이 변수의 값을 RC 전 처리기 매크로 (/ d 옵션)로 추가합니다. 이 변수가 설정되지 않은 경우 &lt;a href=&quot;qmake-variable-reference#defines&quot;&gt;DEFINES&lt;/a&gt; 변수가 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4df68020be8317aea615b4ce4211f35ec1fa9587" translate="yes" xml:space="preserve">
          <source>Windows only: Explicitly access the 32-bit system registry from a 64-bit application running on 64-bit Windows. On 32-bit Windows or from a 32-bit application on 64-bit Windows, this works the same as specifying NativeFormat. This enum value was added in Qt 5.7.</source>
          <target state="translated">Windows 전용 : 64 비트 Windows에서 실행중인 64 비트 응용 프로그램에서 32 비트 시스템 레지스트리에 명시 적으로 액세스하십시오. 32 비트 Windows 또는 64 비트 Windows의 32 비트 응용 프로그램에서 NativeFormat을 지정하는 것과 동일하게 작동합니다. 이 열거 형 값은 Qt 5.7에 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="2f06158236694c4fb22e3870b5033f303b0fbab3" translate="yes" xml:space="preserve">
          <source>Windows only: Explicitly access the 64-bit system registry from a 32-bit application running on 64-bit Windows. On 32-bit Windows or from a 64-bit application on 64-bit Windows, this works the same as specifying NativeFormat. This enum value was added in Qt 5.7.</source>
          <target state="translated">Windows 전용 : 64 비트 Windows에서 실행중인 32 비트 응용 프로그램에서 64 비트 시스템 레지스트리에 명시 적으로 액세스하십시오. 32 비트 Windows 또는 64 비트 Windows의 64 비트 응용 프로그램에서 NativeFormat을 지정하는 것과 동일하게 작동합니다. 이 열거 형 값은 Qt 5.7에 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="c18ab2a2d650cd3f8fdeaea3ea846924ef5abbe6" translate="yes" xml:space="preserve">
          <source>Windows only: This option can be changed while printing and will take effect from the next call to &lt;a href=&quot;qprinter#newPage&quot;&gt;newPage&lt;/a&gt;()</source>
          <target state="translated">Windows에만 해당 :이 옵션은 인쇄하는 동안 변경 될 수 있으며 다음에 &lt;a href=&quot;qprinter#newPage&quot;&gt;newPage&lt;/a&gt; ()를 호출 할 때 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="46fafa0dbfc4874967bb0f32006cc0a4a53860bd" translate="yes" xml:space="preserve">
          <source>Windows support</source>
          <target state="translated">Windows 지원</target>
        </trans-unit>
        <trans-unit id="debbba0ec9e721880339c3e545c9bf4685ce620c" translate="yes" xml:space="preserve">
          <source>Windows, negate the scope like this:</source>
          <target state="translated">Windows의 경우 다음과 같이 범위를 부정하십시오.</target>
        </trans-unit>
        <trans-unit id="e965f498d5c0feaec41a51c2eed2e6e5bed73d1d" translate="yes" xml:space="preserve">
          <source>Windows-1250 to 1258</source>
          <target state="translated">Windows-1250에서 1258</target>
        </trans-unit>
        <trans-unit id="4e2bdcc5cbe8867b5cd90d673b89f74e83f179fd" translate="yes" xml:space="preserve">
          <source>Windows-specific code</source>
          <target state="translated">Windows 관련 코드</target>
        </trans-unit>
        <trans-unit id="d0a162f24e233795006248e6eceb7d0912e33599" translate="yes" xml:space="preserve">
          <source>Windows:</source>
          <target state="translated">Windows:</target>
        </trans-unit>
        <trans-unit id="aa7b1304c81faee53ec108e53104881c9fce6e95" translate="yes" xml:space="preserve">
          <source>Windows: &lt;a href=&quot;qsharedmemory&quot;&gt;QSharedMemory&lt;/a&gt; does not &quot;own&quot; the shared memory segment. When all threads or processes that have an instance of &lt;a href=&quot;qsharedmemory&quot;&gt;QSharedMemory&lt;/a&gt; attached to a particular shared memory segment have either destroyed their instance of &lt;a href=&quot;qsharedmemory&quot;&gt;QSharedMemory&lt;/a&gt; or exited, the Windows kernel releases the shared memory segment automatically.</source>
          <target state="translated">Windows : &lt;a href=&quot;qsharedmemory&quot;&gt;QSharedMemory&lt;/a&gt; 는 공유 메모리 세그먼트를 &quot;소유&quot;하지 않습니다. &lt;a href=&quot;qsharedmemory&quot;&gt;QSharedMemory&lt;/a&gt; 인스턴스가 특정 공유 메모리 세그먼트에 연결된 모든 스레드 또는 프로세스가 QSharedMemory 인스턴스를 &lt;a href=&quot;qsharedmemory&quot;&gt;손상&lt;/a&gt; 시키거나 종료하면 Windows 커널은 공유 메모리 세그먼트를 자동으로 해제합니다.</target>
        </trans-unit>
        <trans-unit id="0ab17fa1f1ae49296acf0a5cb27b4faef4228070" translate="yes" xml:space="preserve">
          <source>Windows: &lt;a href=&quot;qwizard#WizardOption-enum&quot;&gt;HelpButtonOnRight&lt;/a&gt;.</source>
          <target state="translated">윈도우 : &lt;a href=&quot;qwizard#WizardOption-enum&quot;&gt;HelpButtonOnRight&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2e08de05c9835cf627faedee69d075521758acaf" translate="yes" xml:space="preserve">
          <source>Windows: QSharedMemory does not &quot;own&quot; the shared memory segment. When all threads or processes that have an instance of QSharedMemory attached to a particular shared memory segment have either destroyed their instance of QSharedMemory or exited, the Windows kernel releases the shared memory segment automatically.</source>
          <target state="translated">Windows : QSharedMemory는 공유 메모리 세그먼트를 &quot;소유&quot;하지 않습니다. 특정 공유 메모리 세그먼트에 연결된 QSharedMemory 인스턴스가있는 모든 스레드 또는 프로세스가 QSharedMemory 인스턴스를 파괴하거나 종료하면 Windows 커널이 공유 메모리 세그먼트를 자동으로 해제합니다.</target>
        </trans-unit>
        <trans-unit id="d8a5137a288b0e5257034389ada56f6b151f603f" translate="yes" xml:space="preserve">
          <source>Windows: The widget needs to have the &lt;a href=&quot;qt#WindowType-enum&quot;&gt;Qt::FramelessWindowHint&lt;/a&gt; window flag set for the translucency to work.</source>
          <target state="translated">Windows : 반투명도가 작동하려면 위젯에 &lt;a href=&quot;qt#WindowType-enum&quot;&gt;Qt :: FramelessWindowHint&lt;/a&gt; 창 플래그가 설정되어 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="1a8958fde0dbaeb6b7046da3397ec4cf7d333856" translate="yes" xml:space="preserve">
          <source>Windows: Windows Style</source>
          <target state="translated">Windows : Windows 스타일</target>
        </trans-unit>
        <trans-unit id="db21ec9933009e8f5d8a3ced33dfe0db6cff791a" translate="yes" xml:space="preserve">
          <source>Wintab API</source>
          <target state="translated">Wintab API</target>
        </trans-unit>
        <trans-unit id="c8a331815c4cd7107e056ec349acd44bb2648bbd" translate="yes" xml:space="preserve">
          <source>Wireless Bitmap</source>
          <target state="translated">무선 비트 맵</target>
        </trans-unit>
        <trans-unit id="564f8c6e76fbd512be2e38dabdfdd61550d0c3cc" translate="yes" xml:space="preserve">
          <source>With</source>
          <target state="translated">With</target>
        </trans-unit>
        <trans-unit id="9e1ff6d984a1c8b1ff2b3f677866508350f3d8d5" translate="yes" xml:space="preserve">
          <source>With 'e', 'E', and 'f',</source>
          <target state="translated">'e', 'E'및 'f'를 사용하면</target>
        </trans-unit>
        <trans-unit id="a5fbd6fd302ea44886d8c44c601edc98b4db8d5b" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;qdomnodelist&quot;&gt;QDomNodeList&lt;/a&gt; and &lt;a href=&quot;qdomnamednodemap&quot;&gt;QDomNamedNodeMap&lt;/a&gt; two collection classes are provided: &lt;a href=&quot;qdomnodelist&quot;&gt;QDomNodeList&lt;/a&gt; is a list of nodes, and &lt;a href=&quot;qdomnamednodemap&quot;&gt;QDomNamedNodeMap&lt;/a&gt; is used to handle unordered sets of nodes (often used for attributes).</source>
          <target state="translated">로 &lt;a href=&quot;qdomnodelist&quot;&gt;QDomNodeList&lt;/a&gt; 및 &lt;a href=&quot;qdomnamednodemap&quot;&gt;QDomNamedNodeMap&lt;/a&gt; 이 컬렉션 클래스가 제공됩니다 &lt;a href=&quot;qdomnodelist&quot;&gt;QDomNodeList는&lt;/a&gt; 노드의 목록이며, &lt;a href=&quot;qdomnamednodemap&quot;&gt;QDomNamedNodeMap은&lt;/a&gt; (종종 속성에 사용) 노드의 정렬되지 않은 집합을 처리하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="103e578fcb9980940e23f0b7a4dd54c06d84b355" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;qgraphicsitem#pos&quot;&gt;QGraphicsItem::pos&lt;/a&gt;() being one of the few exceptions, &lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt;'s functions operate in item coordinates, regardless of the item, or any of its parents' transformation. For example, an item's bounding rect (i.e. &lt;a href=&quot;qgraphicsitem#boundingRect&quot;&gt;QGraphicsItem::boundingRect&lt;/a&gt;()) is always given in item coordinates.</source>
          <target state="translated">함께 &lt;a href=&quot;qgraphicsitem#pos&quot;&gt;QGraphicsItem :: POS&lt;/a&gt; 몇몇 예외 중 하나 인 () &lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt; 의 기능 항목에 관계없이 항목 좌표 동작, 또는 부모 중 '변형. 예를 들어, 항목의 경계 사각형 (예 : &lt;a href=&quot;qgraphicsitem#boundingRect&quot;&gt;QGraphicsItem :: boundingRect&lt;/a&gt; ())은 항상 항목 좌표로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="dbf704f8941efe3c1bde4073cf1727aa153b9865" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt;, &lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt;, and &lt;a href=&quot;qset&quot;&gt;QSet&lt;/a&gt;, the performance of appending items is amortized O(log</source>
          <target state="translated">함께 &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt; , &lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt; 및 &lt;a href=&quot;qset&quot;&gt;QSet&lt;/a&gt; , 추가 항목의 성능은 상각 O (로그 인</target>
        </trans-unit>
        <trans-unit id="64181e04407db65b3c028b6ce3f5b5b5318a1cb9" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;qmap&quot;&gt;QMap&lt;/a&gt; and &lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt;, &lt;code&gt;foreach&lt;/code&gt; accesses the value component of the (key, value) pairs automatically, so you should not call values() on the container (it would generate an unnecessary copy, see below). If you want to iterate over both the keys and the values, you can use iterators (which are faster), or you can obtain the keys, and use them to get the values too:</source>
          <target state="translated">함께 &lt;a href=&quot;qmap&quot;&gt;QMap&lt;/a&gt; 및 &lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt; , &lt;code&gt;foreach&lt;/code&gt; 는 사용자가 컨테이너 값 ()를 호출하지 않아야하므로, 자동 쌍 제 (키, 값)의 값 컴포넌트에 접근 (그것은 불필요한 복사를 생성 할 것이고, 아래 참조). 키와 값을 모두 반복하려면 반복기를 사용하거나 (더 빠른) 키를 가져 와서 값을 얻는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6025b132baf0dac3042c7392558ba4f5ba6759c7" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;qml-qtquick-listview&quot;&gt;ListView&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-gridview&quot;&gt;GridView&lt;/a&gt;, it is possible to specify transitions that should be applied whenever the items in the view change as a result of modifications to the view's model. They both have the following properties that can be set to the appropriate transitions to be run for various operations:</source>
          <target state="translated">으로 &lt;a href=&quot;qml-qtquick-listview&quot;&gt;의 ListView&lt;/a&gt; 과 &lt;a href=&quot;qml-qtquick-gridview&quot;&gt;의 GridView&lt;/a&gt; , 상기 도면의 변형 모델의 결과로 볼 때마다 변화 항목을 적용해야 전환을 지정하는 것이 가능하다. 둘 다 다음과 같은 속성을 가지며 다양한 작업에 대해 실행하기에 적합한 전환으로 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="16727313357abbd738b4912e8e0ced4d8dee6099" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;qprinter#setFullPage&quot;&gt;setFullPage&lt;/a&gt;(false) (the default), the metrics will be a bit smaller; how much depends on the printer in use.</source>
          <target state="translated">함께 &lt;a href=&quot;qprinter#setFullPage&quot;&gt;setFullPage&lt;/a&gt; (거짓) (기본값), 메트릭은 약간 작아집니다; 사용중인 프린터에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="d90a350b7015138fda882d26fb8d2f88e33cf36c" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;qtcpserver&quot;&gt;QTcpServer&lt;/a&gt; a call to &lt;a href=&quot;qtcpserver#listen&quot;&gt;listen()&lt;/a&gt; may fail with a timeout error. If a port number other than 0 is passed to &lt;a href=&quot;qtcpserver#listen&quot;&gt;listen()&lt;/a&gt;, then it is not guaranteed that it is the specified port that will be used. Use &lt;a href=&quot;qtcpserver#serverPort&quot;&gt;serverPort()&lt;/a&gt; and &lt;a href=&quot;qtcpserver#serverAddress&quot;&gt;serverAddress()&lt;/a&gt; to get the actual address and port used to listen for connections. SOCKS5 only supports one accepted connection per call to &lt;a href=&quot;qtcpserver#listen&quot;&gt;listen()&lt;/a&gt;, and each call is likely to result in a different &lt;a href=&quot;qtcpserver#serverPort&quot;&gt;serverPort()&lt;/a&gt; being used.</source>
          <target state="translated">&lt;a href=&quot;qtcpserver&quot;&gt;QTcpServer를&lt;/a&gt; 사용하면 &lt;a href=&quot;qtcpserver#listen&quot;&gt;listen ()&lt;/a&gt; 호출 이 시간 초과 오류와 함께 실패 할 수 있습니다. 0 이외의 포트 번호가 &lt;a href=&quot;qtcpserver#listen&quot;&gt;listen ()에&lt;/a&gt; 전달되면 , 그것이 지정된 포트임을 보증하지 않습니다. 사용 &lt;a href=&quot;qtcpserver#serverPort&quot;&gt;서버 포트 ()&lt;/a&gt; 와 &lt;a href=&quot;qtcpserver#serverAddress&quot;&gt;serverAddress ()는&lt;/a&gt; 실제 주소를 확인하고 포트 연결을 수신하는 데 사용됩니다. SOCKS5는 &lt;a href=&quot;qtcpserver#listen&quot;&gt;listen ()&lt;/a&gt; 호출 당 하나의 허용 된 연결 만 지원 하며 각 호출마다 다른 &lt;a href=&quot;qtcpserver#serverPort&quot;&gt;serverPort ()&lt;/a&gt; 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="872ba56ce042a47a6a6c319e65798f0a9e94df17" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;qtexttableformat#borderCollapse&quot;&gt;borderCollapse&lt;/a&gt; disabled, cell borders can still be styled using &lt;a href=&quot;qtexttablecellformat&quot;&gt;QTextTableCellFormat&lt;/a&gt; but styling will be applied only within the cell's frame, which is probably not very useful in practice.</source>
          <target state="translated">함께 &lt;a href=&quot;qtexttableformat#borderCollapse&quot;&gt;borderCollapse가&lt;/a&gt; 비활성화 셀 테두리는 여전히 사용하여 스타일을 지정할 수 &lt;a href=&quot;qtexttablecellformat&quot;&gt;QTextTableCellFormat을&lt;/a&gt; 하지만 아마 실제로 매우 유용하지 않습니다 셀의 프레임 내에서 적용됩니다 스타일.</target>
        </trans-unit>
        <trans-unit id="74231e7c06d3afefe1c7418ba883ce0704f875db" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;qudpsocket&quot;&gt;QUdpSocket&lt;/a&gt;, a call to &lt;a href=&quot;qabstractsocket#bind&quot;&gt;bind()&lt;/a&gt; may fail with a timeout error. If a port number other than 0 is passed to &lt;a href=&quot;qabstractsocket#bind&quot;&gt;bind()&lt;/a&gt;, it is not guaranteed that it is the specified port that will be used. Use &lt;a href=&quot;qabstractsocket#localPort&quot;&gt;localPort()&lt;/a&gt; and &lt;a href=&quot;qabstractsocket#localAddress&quot;&gt;localAddress()&lt;/a&gt; to get the actual address and port number in use. Because proxied UDP goes through two UDP connections, it is more likely that packets will be dropped.</source>
          <target state="translated">로 &lt;a href=&quot;qudpsocket&quot;&gt;QUdpSocket&lt;/a&gt; 의 호출 &lt;a href=&quot;qabstractsocket#bind&quot;&gt;바인딩 ()&lt;/a&gt; 시간 초과 오류와 함께 실패 할 수 있습니다. 0 이외의 포트 번호가 &lt;a href=&quot;qabstractsocket#bind&quot;&gt;bind ()로&lt;/a&gt; 전달되는 경우 , 사용되는 지정된 포트임을 보증하지 않습니다. 사용 &lt;a href=&quot;qabstractsocket#localPort&quot;&gt;localPort ()&lt;/a&gt; 및 &lt;a href=&quot;qabstractsocket#localAddress&quot;&gt;보이나 인근은 ()&lt;/a&gt; 사용의 실제 주소와 포트 번호를 얻을 수 있습니다. 프록시 된 UDP는 두 개의 UDP 연결을 거치므로 패킷이 손실 될 가능성이 높습니다.</target>
        </trans-unit>
        <trans-unit id="c9a076d67fba73a9b4410b9906e0667a40bc2584" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;qudpsocket&quot;&gt;QUdpSocket&lt;/a&gt;, you can also establish a virtual connection to a UDP server using &lt;a href=&quot;qabstractsocket#connectToHost&quot;&gt;connectToHost&lt;/a&gt;() and then use &lt;a href=&quot;qiodevice#read&quot;&gt;read&lt;/a&gt;() and &lt;a href=&quot;qiodevice#write&quot;&gt;write&lt;/a&gt;() to exchange datagrams without specifying the receiver for each datagram.</source>
          <target state="translated">로 &lt;a href=&quot;qudpsocket&quot;&gt;QUdpSocket&lt;/a&gt; , 당신은 또한 사용하여 UDP 서버에 가상 연결을 설정할 수 있습니다 &lt;a href=&quot;qabstractsocket#connectToHost&quot;&gt;connectToHost을&lt;/a&gt; 한 후 사용 ()와 &lt;a href=&quot;qiodevice#read&quot;&gt;읽기&lt;/a&gt; ()와 &lt;a href=&quot;qiodevice#write&quot;&gt;쓰기&lt;/a&gt; 각 데이터 그램에 대한 수신기를 지정하지 않고 교환 데이터 그램을 ().</target>
        </trans-unit>
        <trans-unit id="f1f73057832d43cc1f0b28576c1787b331ef4bc6" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;qurl#ComponentFormattingOption-enum&quot;&gt;QUrl::FullyDecoded&lt;/a&gt; formatting, all percent-encoded sequences will be decoded fully and the '%' character is used to represent itself. &lt;a href=&quot;qurl#ComponentFormattingOption-enum&quot;&gt;QUrl::FullyDecoded&lt;/a&gt; should be used with care, since it may cause data loss. See the documentation of &lt;a href=&quot;qurl#ComponentFormattingOption-enum&quot;&gt;QUrl::FullyDecoded&lt;/a&gt; for information on what data may be lost.</source>
          <target state="translated">함께 &lt;a href=&quot;qurl#ComponentFormattingOption-enum&quot;&gt;QUrl :: FullyDecoded&lt;/a&gt; 서식, 모든 퍼센트 인코딩 서열이 완전히 해독되고 '%'문자 자체를 표시하는 데 사용됩니다. &lt;a href=&quot;qurl#ComponentFormattingOption-enum&quot;&gt;QUrl :: FullyDecoded&lt;/a&gt; 는 데이터 손실을 일으킬 수 있으므로주의 해서 사용해야합니다. 손실 될 수있는 데이터에 대한 정보 는 &lt;a href=&quot;qurl#ComponentFormattingOption-enum&quot;&gt;QUrl :: FullyDecoded&lt;/a&gt; 의 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="aea815a02f618bd505e0018ce84688729e474818" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt;, &lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt;, and &lt;a href=&quot;qset&quot;&gt;QSet&lt;/a&gt;, the performance of appending items is amortized O(log</source>
          <target state="translated">함께 &lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt; , &lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt; 및 &lt;a href=&quot;qset&quot;&gt;QSet&lt;/a&gt; , 추가 항목의 성능은 상각 O (로그 인</target>
        </trans-unit>
        <trans-unit id="91b4e93e646576cbe861f8e8ff67b744e1ec1177" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;supported-platforms#winrt&quot;&gt;WinRT&lt;/a&gt; and on INTEGRITY, the returned value is the &lt;a href=&quot;qtcpserver&quot;&gt;QTcpServer&lt;/a&gt; socket descriptor and the type is defined by &lt;a href=&quot;qtcpserver#socketDescriptor&quot;&gt;socketDescriptor&lt;/a&gt;.</source>
          <target state="translated">로 &lt;a href=&quot;supported-platforms#winrt&quot;&gt;WinRT&lt;/a&gt; 와 INTEGRITY에, 반환 값은이다 &lt;a href=&quot;qtcpserver&quot;&gt;QTcpServer의&lt;/a&gt; 소켓 기술자와 유형에 의해 정의됩니다 &lt;a href=&quot;qtcpserver#socketDescriptor&quot;&gt;socketDescriptor&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e8688a16d1e596260602f5999a09f611bc3d5b43" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;supported-platforms#winrt&quot;&gt;WinRT&lt;/a&gt; and on INTEGRITY, the returned value is the &lt;a href=&quot;qtcpsocket&quot;&gt;QTcpSocket&lt;/a&gt; socket descriptor and the type is defined by &lt;a href=&quot;qabstractsocket#socketDescriptor&quot;&gt;socketDescriptor&lt;/a&gt;.</source>
          <target state="translated">로 &lt;a href=&quot;supported-platforms#winrt&quot;&gt;WinRT&lt;/a&gt; 와 INTEGRITY에, 반환 값은이다 &lt;a href=&quot;qtcpsocket&quot;&gt;QTcpSocket의&lt;/a&gt; 소켓 기술자와 유형에 의해 정의됩니다 &lt;a href=&quot;qabstractsocket#socketDescriptor&quot;&gt;socketDescriptor&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9248ebd5b1e0afba9784b19bd821110389b32c72" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;TextEdit.MarkdownText&lt;/code&gt;, checkboxes that result from using the &lt;a href=&quot;https://guides.github.com/features/mastering-markdown/#GitHub-flavored-markdown&quot;&gt;GitHub checkbox extension&lt;/a&gt; are interactively checkable.</source>
          <target state="translated">로 &lt;code&gt;TextEdit.MarkdownText&lt;/code&gt; 는 사용하여 발생하는 체크 박스 &lt;a href=&quot;https://guides.github.com/features/mastering-markdown/#GitHub-flavored-markdown&quot;&gt;GitHub의 체크 박스 확장은&lt;/a&gt; 대화 형으로 체크 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="03290e3e4ae717c4512a405c7c756059087b2a61" translate="yes" xml:space="preserve">
          <source>With APIs other than OpenGL the relevant states are only those that are set via the command list (for example, OMSetRenderTargets, RSSetViewports, RSSetScissorRects, OMSetBlendFactor, OMSetStencilRef in case of D3D12), and only when such commands were added to the scenegraph's command list queried via the QSGRendererInterface::CommandList resource enum. States set in pipeline state objects do not need to be reported here. Similarly, draw call related settings (root signature, descriptor heaps, etc.) are always set again by the scenegraph so &lt;a href=&quot;qsgrendernode#render&quot;&gt;render&lt;/a&gt;() can freely change them.</source>
          <target state="translated">OpenGL 이외의 API를 사용하는 경우 관련 상태는 명령 목록을 통해 설정된 상태 (예 : OMSetRenderTargets, RSSetViewports, RSSetScissorRects, OMSetBlendFactor, D3D12의 경우 OMSetStencilRef) 및 해당 명령이 장면 그래프의 명령 목록에 추가 된 경우에만 해당됩니다. QSGRendererInterface :: CommandList 자원 열거를 통해. 파이프 라인 상태 개체에 설정된 상태는 여기에보고 할 필요가 없습니다. 마찬가지로 드로우 콜 관련 설정 (루트 서명, 설명자 힙 등)은 항상 장면 그래프에 의해 다시 설정되므로 &lt;a href=&quot;qsgrendernode#render&quot;&gt;render&lt;/a&gt; ()는 자유롭게 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e70a3722f26658e32b513ebe4cd59190104116b" translate="yes" xml:space="preserve">
          <source>With APIs other than OpenGL, the only relevant values are the ones that correspond to dynamic state changes recorded on the command list/buffer. For example, RSSetViewports, RSSetScissorRects, OMSetBlendFactor, OMSetStencilRef in case of D3D12, or vkCmdSetViewport, vkCmdSetScissor, vkCmdSetBlendConstants, vkCmdSetStencilRef in case of Vulkan, and only when such commands were added to the scenegraph's command list queried via the QSGRendererInterface::CommandList resource enum. States set in pipeline state objects do not need to be reported here. Similarly, draw call related settings (pipeline states, descriptor sets, vertex or index buffer bindings, root signature, descriptor heaps, etc.) are always set again by the scenegraph so &lt;a href=&quot;qsgrendernode#render&quot;&gt;render&lt;/a&gt;() can freely change them.</source>
          <target state="translated">OpenGL 이외의 API를 사용하는 경우 관련 값은 명령 목록 / 버퍼에 기록 된 동적 상태 변경에 해당하는 값뿐입니다. 예를 들어 RSSetViewports, RSSetScissorRects, OMSetBlendFactor, OMSetStencilRef (D3D12의 경우) 또는 vkCmdSetViewport, vkCmdSetScissor, vkCmdSetBlendConstants, vkCmdSetStencilRef (GRenderumri의 경우 VkCmdSetStencilRef)가 VkCmdSetStencilRef의 경우 VkCmdSetStencilRef 명령이 Vulkanface에 추가되었습니다. 파이프 라인 상태 개체에 설정된 상태는 여기에보고 할 필요가 없습니다. 마찬가지로, draw call 관련 설정 (파이프 라인 상태, 설명자 세트, 정점 또는 인덱스 버퍼 바인딩, 루트 서명, 설명자 힙 등)은 항상 장면 그래프에 의해 다시 설정되므로 &lt;a href=&quot;qsgrendernode#render&quot;&gt;render&lt;/a&gt; ()에서 자유롭게 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="952e6d9f2d1c7eaf2f8ec67050132f418e63f61b" translate="yes" xml:space="preserve">
          <source>With APIs other than OpenGL, the only relevant values are the ones that correspond to dynamic state changes recorded on the command list/buffer. For example, RSSetViewports, RSSetScissorRects, OMSetBlendState, OMSetDepthStencilState in case of D3D11, or vkCmdSetViewport, vkCmdSetScissor, vkCmdSetBlendConstants, vkCmdSetStencilRef in case of Vulkan, and only when such commands were added to the scenegraph's command list queried via the QSGRendererInterface::CommandList resource enum. States set in pipeline state objects do not need to be reported here. Similarly, draw call related settings (pipeline states, descriptor sets, vertex or index buffer bindings, root signature, descriptor heaps, etc.) are always set again by the scenegraph so &lt;a href=&quot;qsgrendernode#render&quot;&gt;render&lt;/a&gt;() can freely change them.</source>
          <target state="translated">OpenGL 이외의 API를 사용하는 경우 관련 값은 명령 목록 / 버퍼에 기록 된 동적 상태 변경에 해당하는 값뿐입니다. 예를 들어, RSSetViewports, RSSetScissorRects, OMSetBlendState, OMSetDepthStencilState (D3D11의 경우) 또는 vkCmdSetViewport, vkCmdSetScissor, vkCmdSetBlendConstants, Vulkan의 경우 vkCmdSetStencilRef 명령이 Vulkan에 추가 된 경우 VkCmdSetStencilRef 명령이 Vulkan. 파이프 라인 상태 개체에 설정된 상태는 여기에보고 할 필요가 없습니다. 마찬가지로, draw call 관련 설정 (파이프 라인 상태, 설명자 세트, 정점 또는 인덱스 버퍼 바인딩, 루트 서명, 설명자 힙 등)은 항상 장면 그래프에 의해 다시 설정되므로 &lt;a href=&quot;qsgrendernode#render&quot;&gt;render&lt;/a&gt; ()에서 자유롭게 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8c62fbfaaff355a72036abc9d9e93ba575dd471" translate="yes" xml:space="preserve">
          <source>With CMake, use the generated &lt;code&gt;qt-cmake&lt;/code&gt; script in the &lt;code&gt;bin&lt;/code&gt; directory of the staging location (&lt;code&gt;$HOME/qt6-rpi&lt;/code&gt; in the example) to configure, then run &lt;code&gt;ninja&lt;/code&gt;. For example:</source>
          <target state="translated">CMake를 사용하여 스테이징 위치 의 &lt;code&gt;bin&lt;/code&gt; 디렉토리 ( 예제에서 &lt;code&gt;$HOME/qt6-rpi&lt;/code&gt; 에 생성 된 &lt;code&gt;qt-cmake&lt;/code&gt; 스크립트를 사용하여 구성한 다음 &lt;code&gt;ninja&lt;/code&gt; 를 실행 합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cafbf9271f9b132f25eceee442e07c6d15fe8061" translate="yes" xml:space="preserve">
          <source>With D3D12, these strings can either be a URL for a local file, a file in the resource system, or an HLSL source string. Using a URL for a local file or a file in the resource system indicates that the file in question contains pre-compiled D3D shader bytecode generated by the &lt;code&gt;fxc&lt;/code&gt; tool, or, alternatively, HLSL source code. The type of file is detected automatically. This means that the D3D12 backend supports all options from &lt;a href=&quot;qml-qtquick-graphicsinfo&quot;&gt;GraphicsInfo&lt;/a&gt;.shaderCompilationType and &lt;a href=&quot;qml-qtquick-graphicsinfo&quot;&gt;GraphicsInfo&lt;/a&gt;.shaderSourceType.</source>
          <target state="translated">D3D12에서 이러한 문자열은 로컬 파일의 URL, 자원 시스템의 파일 또는 HLSL 소스 문자열 일 수 있습니다. 로컬 파일 또는 자원 시스템의 파일에 URL을 사용하면 해당 파일에 &lt;code&gt;fxc&lt;/code&gt; 도구 또는 HLSL 소스 코드로 생성 된 사전 컴파일 된 D3D 셰이더 바이트 코드가 포함되어 있음을 나타냅니다 . 파일 형식이 자동으로 감지됩니다. 즉, D3D12 백엔드는 &lt;a href=&quot;qml-qtquick-graphicsinfo&quot;&gt;GraphicsInfo&lt;/a&gt; .shaderCompilationType 및 &lt;a href=&quot;qml-qtquick-graphicsinfo&quot;&gt;GraphicsInfo&lt;/a&gt; .shaderSourceType의 모든 옵션을 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="88a719a916cbdf9f54485acb3de11f5065e5756a" translate="yes" xml:space="preserve">
          <source>With Frameworks:</source>
          <target state="translated">프레임 워크로 :</target>
        </trans-unit>
        <trans-unit id="f74f1e0ed752fa79a313fb567cf4e0f1c85789a4" translate="yes" xml:space="preserve">
          <source>With GLSL the default shader expects the texture coordinate to be passed from the vertex shader as &lt;code&gt;varying highp vec2 qt_TexCoord0&lt;/code&gt;, and it samples from a sampler2D named &lt;code&gt;source&lt;/code&gt;. With HLSL the texture is named &lt;code&gt;source&lt;/code&gt;, while the vertex shader is expected to provide &lt;code&gt;float2 coord : TEXCOORD0&lt;/code&gt; in its output in addition to &lt;code&gt;float4 position : SV_POSITION&lt;/code&gt; (names can differ since linking is done based on the semantics).</source>
          <target state="translated">GLSL을 사용하면 기본 셰이더는 텍스처 좌표가 버텍스 셰이더에서 &lt;code&gt;varying highp vec2 qt_TexCoord0&lt;/code&gt; 으로 전달 될 것으로 예상하고 &lt;code&gt;source&lt;/code&gt; 라는 sampler2D에서 샘플링 합니다 . HLSL을 사용하면 텍스처 이름이 &lt;code&gt;source&lt;/code&gt; 이고 정점 셰이더는 &lt;code&gt;float4 position : SV_POSITION&lt;/code&gt; 외에도 출력에 &lt;code&gt;float2 coord : TEXCOORD0&lt;/code&gt; 을 제공해야 합니다 (시맨틱에 따라 링크가 수행되므로 이름이 다를 수 있음).</target>
        </trans-unit>
        <trans-unit id="06bb1d65a22341423f053582013a700a14cd0a62" translate="yes" xml:space="preserve">
          <source>With GLSL the default shader passes the texture coordinate along to the fragment shader as &lt;code&gt;varying highp vec2 qt_TexCoord0&lt;/code&gt;. With HLSL it is enough to use the standard &lt;code&gt;TEXCOORD0&lt;/code&gt; semantic, for example &lt;code&gt;float2 coord : TEXCOORD0&lt;/code&gt;.</source>
          <target state="translated">GLSL을 사용하면 기본 셰이더는 텍스처 좌표를 조각 셰이더에 &lt;code&gt;varying highp vec2 qt_TexCoord0&lt;/code&gt; 합니다. HLSL을 사용하면 표준 &lt;code&gt;TEXCOORD0&lt;/code&gt; 의미 를 사용하기에 충분합니다 ( 예 &lt;code&gt;float2 coord : TEXCOORD0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="432ffb8eb16488c3b464914ba3b76169484e8c79" translate="yes" xml:space="preserve">
          <source>With Microsoft SQL Server the result set returned by a stored procedure that uses the return statement, or returns multiple result sets, will be accessible only if you set the query's forward only mode to</source>
          <target state="translated">Microsoft SQL Server를 사용하면 쿼리의 전달 전용 모드를로 설정 한 경우에만 return 문을 사용하거나 여러 결과 집합을 반환하는 저장 프로 시저에서 반환 된 결과 집합에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ab92144418b0fd8935aca47560e5939a743472a" translate="yes" xml:space="preserve">
          <source>With OpenGL 3.0+ contexts, when portability is not important, the versioned &lt;a href=&quot;https://doc.qt.io/qt-5.13/qopenglfunctions.html&quot;&gt;QOpenGLFunctions&lt;/a&gt; variants give easy access to all the modern OpenGL functions available in a given version:</source>
          <target state="translated">이식성이 중요하지 않은 OpenGL 3.0+ 컨텍스트를 사용하면 버전이 지정된 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qopenglfunctions.html&quot;&gt;QOpenGLFunctions&lt;/a&gt; 변형을 통해 지정된 버전에서 사용 가능한 모든 최신 OpenGL 기능에 쉽게 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3e299c1f4a978eb904713ea8077150796fa08d67" translate="yes" xml:space="preserve">
          <source>With OpenGL 3.0+ contexts, when portability is not important, the versioned &lt;a href=&quot;https://doc.qt.io/qt-5.15/qopenglfunctions.html&quot;&gt;QOpenGLFunctions&lt;/a&gt; variants give easy access to all the modern OpenGL functions available in a given version:</source>
          <target state="translated">OpenGL 3.0+ 컨텍스트를 사용하면 이식성이 중요하지 않은 경우 버전이 지정된 &lt;a href=&quot;https://doc.qt.io/qt-5.15/qopenglfunctions.html&quot;&gt;QOpenGLFunctions&lt;/a&gt; 변형을 통해 주어진 버전에서 사용할 수있는 모든 최신 OpenGL 함수에 쉽게 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a4efeffaafad4ed76cb7c01f6203e6512392a14" translate="yes" xml:space="preserve">
          <source>With OpenGL 3.0+ contexts, when portability is not important, the versioned &lt;a href=&quot;https://doc.qt.io/qt-6.0/qopenglfunctions.html&quot;&gt;QOpenGLFunctions&lt;/a&gt; variants give easy access to all the modern OpenGL functions available in a given version:</source>
          <target state="translated">OpenGL 3.0+ 컨텍스트를 사용하면 이식성이 중요하지 않은 경우 버전이 지정된 &lt;a href=&quot;https://doc.qt.io/qt-6.0/qopenglfunctions.html&quot;&gt;QOpenGLFunctions&lt;/a&gt; 변형을 통해 주어진 버전에서 사용할 수있는 모든 최신 OpenGL 함수에 쉽게 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d99fbf67dac539e085a083af2978cf398c2b3dce" translate="yes" xml:space="preserve">
          <source>With OpenGL 3.2 the concept of profiles was introduced. Two profiles are currently defined for OpenGL: Core and Compatibility.</source>
          <target state="translated">OpenGL 3.2에서는 프로파일 개념이 도입되었습니다. OpenGL에 대해 현재 두 개의 프로파일 인 Core 및 Compatibility가 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0f1facb5ae8f9746481b734a9086c1e3d74f3a5" translate="yes" xml:space="preserve">
          <source>With OpenGL the default version is &lt;code&gt;2.0&lt;/code&gt;.</source>
          <target state="translated">OpenGL에서 기본 버전은 &lt;code&gt;2.0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="84bc76e9356158a46e5ae5149f27cd5b3c84721a" translate="yes" xml:space="preserve">
          <source>With OpenGL the value is &lt;a href=&quot;qml-qtquick-graphicsinfo&quot;&gt;GraphicsInfo&lt;/a&gt;.RuntimeCompilation, which corresponds to the traditional way of using &lt;a href=&quot;qml-qtquick-shadereffect&quot;&gt;ShaderEffect&lt;/a&gt;. Non-OpenGL backends are expected to focus more on &lt;a href=&quot;qml-qtquick-graphicsinfo&quot;&gt;GraphicsInfo&lt;/a&gt;.OfflineCompilation, however.</source>
          <target state="translated">OpenGL에서 값은 &lt;a href=&quot;qml-qtquick-graphicsinfo&quot;&gt;GraphicsInfo&lt;/a&gt; .RuntimeCompilation이며 이는 &lt;a href=&quot;qml-qtquick-shadereffect&quot;&gt;ShaderEffect&lt;/a&gt; 를 사용하는 전통적인 방법에 해당합니다 . 그러나 OpenGL이 아닌 백엔드는 &lt;a href=&quot;qml-qtquick-graphicsinfo&quot;&gt;GraphicsInfo&lt;/a&gt; .OfflineCompilation에 더 집중할 것으로 예상됩니다 .</target>
        </trans-unit>
        <trans-unit id="7de003d6b77d6796e19049db78d2434fccdf7e90" translate="yes" xml:space="preserve">
          <source>With OpenGL the value is &lt;a href=&quot;qml-qtquick-graphicsinfo&quot;&gt;GraphicsInfo&lt;/a&gt;.ShaderSourceString, which corresponds to the traditional way of inlining GLSL source code into QML. Other, non-OpenGL Qt Quick backends may however decide not to support inlined shader sources, or even shader sources at all. In this case shaders are expected to be pre-compiled into formats like SPIR-V or D3D shader bytecode.</source>
          <target state="translated">OpenGL에서 값은 &lt;a href=&quot;qml-qtquick-graphicsinfo&quot;&gt;GraphicsInfo&lt;/a&gt; .ShaderSourceString이며, 이는 GLSL 소스 코드를 QML에 인라인하는 전통적인 방법에 해당합니다. 그러나 OpenGL 이외의 Qt Quick 백엔드 이외의 다른 인라인 셰이더 소스 또는 셰이더 소스를 전혀 지원하지 않기로 결정할 수도 있습니다. 이 경우 셰이더는 SPIR-V 또는 D3D 셰이더 바이트 코드와 같은 형식으로 사전 컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="42c1b1cf3a8ec76910bd045e07dea06b5c135d27" translate="yes" xml:space="preserve">
          <source>With OpenGL, the native handle is a GLuint value, so &lt;code&gt;object&lt;/code&gt; is then a pointer to a GLuint. With Vulkan, the native handle is a VkImage, so &lt;code&gt;object&lt;/code&gt; is a pointer to a VkImage. With Direct3D 11 and Metal &lt;code&gt;object&lt;/code&gt; is a pointer to a ID3D11Texture2D or MTLTexture pointer, respectively.</source>
          <target state="translated">OpenGL에서 네이티브 핸들은 GLuint 값이므로 &lt;code&gt;object&lt;/code&gt; 는 GLuint에 대한 포인터입니다. Vulkan에서 네이티브 핸들은 VkImage이므로 &lt;code&gt;object&lt;/code&gt; 는 VkImage에 대한 포인터입니다. Direct3D 11 및 Metal &lt;code&gt;object&lt;/code&gt; 는 각각 ID3D11Texture2D 또는 MTLTexture 포인터에 대한 포인터입니다.</target>
        </trans-unit>
        <trans-unit id="447f8b0cd8714a7ba6f152254a9a2f10cb30db4e" translate="yes" xml:space="preserve">
          <source>With OpenGL, the scenegraph's OpenGL context will be current both when calling the destructor and this function.</source>
          <target state="translated">OpenGL을 사용하면 소멸자와이 함수를 호출 할 때 장면 그래프의 OpenGL 컨텍스트가 최신 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="681461a44bd3fc3f6ab0e940a488044968df90ae" translate="yes" xml:space="preserve">
          <source>With QUdpSocket, you can also establish a virtual connection to a UDP server using &lt;a href=&quot;qabstractsocket#connectToHost&quot;&gt;connectToHost&lt;/a&gt;() and then use &lt;a href=&quot;qiodevice#read&quot;&gt;read&lt;/a&gt;() and &lt;a href=&quot;qiodevice#write&quot;&gt;write&lt;/a&gt;() to exchange datagrams without specifying the receiver for each datagram.</source>
          <target state="translated">QUdpSocket을 사용하면 &lt;a href=&quot;qabstractsocket#connectToHost&quot;&gt;connectToHost&lt;/a&gt; ()를 사용 하여 UDP 서버에 가상 연결을 설정 한 다음 &lt;a href=&quot;qiodevice#read&quot;&gt;읽기&lt;/a&gt; () 및 &lt;a href=&quot;qiodevice#write&quot;&gt;쓰기&lt;/a&gt; ()를 사용하여 각 데이터 그램에 대한 수신자를 지정하지 않고도 데이터 그램을 교환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="56b427bae31a9ed757f6ae13bcca166dce5b0a5c" translate="yes" xml:space="preserve">
          <source>With Qt 6 and CMake, this approach is &lt;b&gt;no longer sufficient&lt;/b&gt; on its own. Rather, a &lt;a href=&quot;https://cmake.org/cmake/help/latest/manual/cmake-toolchains.7.html&quot;&gt;CMake toolchain file&lt;/a&gt; must be provided before configuring can happen. It is in this file where customization with regards to compiler and linker flags, and toolchain and sysroot specific quirks, happens.</source>
          <target state="translated">Qt 6 및 CMake를 사용하면이 접근 방식 &lt;b&gt;만으로는 더 이상 충분하지 않습니다&lt;/b&gt; . 대신 구성이 발생하기 전에 &lt;a href=&quot;https://cmake.org/cmake/help/latest/manual/cmake-toolchains.7.html&quot;&gt;CMake 도구 모음 파일&lt;/a&gt; 을 제공해야합니다. 이 파일에서 컴파일러 및 링커 플래그, 도구 체인 및 sysroot 특정 특성과 관련된 사용자 정의가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6d4000ff07b627f2f3cd8ff0559054e853b706b9" translate="yes" xml:space="preserve">
          <source>With Qt Quick Controls 2, declare an &lt;a href=&quot;qml-qtquick-controls2-applicationwindow&quot;&gt;ApplicationWindow&lt;/a&gt; as the root item of your application and launch it by using &lt;a href=&quot;qqmlapplicationengine&quot;&gt;QQmlApplicationEngine&lt;/a&gt; instead. This ensures that you can control top level window properties from QML.</source>
          <target state="translated">Qt Quick Controls 2를 사용하면 &lt;a href=&quot;qml-qtquick-controls2-applicationwindow&quot;&gt;ApplicationWindow&lt;/a&gt; 를 애플리케이션 의 루트 항목으로 선언하고 대신 &lt;a href=&quot;qqmlapplicationengine&quot;&gt;QQmlApplicationEngine&lt;/a&gt; 을 사용하여 시작하십시오 . 이를 통해 QML에서 최상위 창 속성을 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d4dbcde91ae4a65a5e8e42051d5c480bc878f00" translate="yes" xml:space="preserve">
          <source>With Qt Quick Controls, declare an &lt;a href=&quot;qml-qtquick-controls2-applicationwindow&quot;&gt;ApplicationWindow&lt;/a&gt; as the root item of your application and launch it by using &lt;a href=&quot;qqmlapplicationengine&quot;&gt;QQmlApplicationEngine&lt;/a&gt; instead. This ensures that you can control top level window properties from QML.</source>
          <target state="translated">Qt Quick Controls를 사용하면 &lt;a href=&quot;qml-qtquick-controls2-applicationwindow&quot;&gt;ApplicationWindow&lt;/a&gt; 를 애플리케이션 의 루트 항목으로 선언하고 대신 &lt;a href=&quot;qqmlapplicationengine&quot;&gt;QQmlApplicationEngine&lt;/a&gt; 을 사용하여 시작합니다 . 이렇게하면 QML에서 최상위 창 속성을 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e693cc082b720fd71881c66e314770011b15a068" translate="yes" xml:space="preserve">
          <source>With Qt Quick Controls, declare an &lt;a href=&quot;qtquickcontrols-changes-qt6#applicationwindow&quot;&gt;ApplicationWindow&lt;/a&gt; as the root item of your application and launch it by using &lt;a href=&quot;qqmlapplicationengine&quot;&gt;QQmlApplicationEngine&lt;/a&gt; instead. This ensures that you can control top level window properties from QML.</source>
          <target state="translated">Qt Quick Controls를 사용하면 &lt;a href=&quot;qtquickcontrols-changes-qt6#applicationwindow&quot;&gt;ApplicationWindow&lt;/a&gt; 를 애플리케이션 의 루트 항목으로 선언하고 대신 &lt;a href=&quot;qqmlapplicationengine&quot;&gt;QQmlApplicationEngine&lt;/a&gt; 을 사용하여 시작합니다 . 이렇게하면 QML에서 최상위 창 속성을 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ab58178f80111f6946c48a42f95bb6acc41459d3" translate="yes" xml:space="preserve">
          <source>With Qt XML Patterns, a standard way to present the initial focus to a query is to call &lt;a href=&quot;qxmlquery#setFocus&quot;&gt;QXmlQuery::setFocus&lt;/a&gt;(). Another common way is to let the &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt; itself create the initial focus by using the first step of the path expression to call the &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt;&lt;code&gt;doc()&lt;/code&gt; function. The &lt;code&gt;doc()&lt;/code&gt; function loads an XML document and returns the</source>
          <target state="translated">Qt XML 패턴을 사용하면 쿼리에 초기 초점을 표시하는 표준 방법은 &lt;a href=&quot;qxmlquery#setFocus&quot;&gt;QXmlQuery :: setFocus&lt;/a&gt; () 를 호출하는 것 입니다. 또 다른 일반적인 방법은 &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery &lt;/a&gt; &lt;code&gt;doc()&lt;/code&gt; 함수 를 호출하는 경로 표현식의 첫 번째 단계를 사용하여 &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt; 자체가 초기 포커스를 만들 도록하는 것 입니다. &lt;code&gt;doc()&lt;/code&gt; 함수를로드 XML 문서 및 반환</target>
        </trans-unit>
        <trans-unit id="294b78628ff463c80a1c17789150fe32ad463fe9" translate="yes" xml:space="preserve">
          <source>With Qt XML Patterns, a standard way to present the initial focus to a query is to call &lt;a href=&quot;qxmlquery#setFocus&quot;&gt;QXmlQuery::setFocus&lt;/a&gt;(). Another common way is to let the &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt; itself create the initial focus by using the first step of the path expression to call the &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt;&lt;code&gt;doc()&lt;/code&gt; function. The &lt;code&gt;doc()&lt;/code&gt; function loads an XML document and returns the</source>
          <target state="translated">Qt XML 패턴을 사용하여 쿼리에 초기 초점을 제시하는 표준 방법은 &lt;a href=&quot;qxmlquery#setFocus&quot;&gt;QXmlQuery :: setFocus&lt;/a&gt; () 를 호출하는 것 입니다. 또 다른 일반적인 방법은 &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt; 자체가 경로 표현식의 첫 번째 단계를 사용하여 &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery &lt;/a&gt; &lt;code&gt;doc()&lt;/code&gt; 함수 를 호출하여 초기 초점을 작성 하도록하는 것 입니다. &lt;code&gt;doc()&lt;/code&gt; 함수를로드 XML 문서 및 반환</target>
        </trans-unit>
        <trans-unit id="5200fea545520eec9315c9a63628fdd54aebc6ff" translate="yes" xml:space="preserve">
          <source>With Qt XML Patterns, subclassing &lt;a href=&quot;qabstractxmlnodemodel&quot;&gt;QAbstractXmlNodeModel&lt;/a&gt; eliminates the transformation required to convert the non-XML data model to the XML data model, because there is only ever one data model required. The non-XML data model presents the non-XML data to the query engine via the XML data model API. Also, since the query engine uses the API to access the &lt;a href=&quot;qabstractxmlnodemodel&quot;&gt;QAbstractXmlNodeModel&lt;/a&gt;, the data model subclass can construct the elements, attributes and other data on demand, responding to the query's specific requests. This can greatly improve efficiency, because it means the entire model might not have to be built. For example, in the file system model above, it is not necessary to build an instance for a whole XML file representing the whole file system. Instead nodes are created on demand, which also likely is a small subset of the file system.</source>
          <target state="translated">Qt XML 패턴을 사용하면 &lt;a href=&quot;qabstractxmlnodemodel&quot;&gt;QAbstractXmlNodeModel을&lt;/a&gt; 서브 클래 싱 하면 데이터 모델이 하나만 필요하므로 비 XML 데이터 모델을 XML 데이터 모델로 변환하는 데 필요한 변환이 제거됩니다. 비 XML 데이터 모델은 XML 데이터 모델 API를 통해 비 XML 데이터를 쿼리 엔진에 제공합니다. 또한 쿼리 엔진은 API를 사용하여 &lt;a href=&quot;qabstractxmlnodemodel&quot;&gt;QAbstractXmlNodeModel&lt;/a&gt; 에 액세스하므로데이터 모델 서브 클래스는 쿼리의 특정 요청에 응답하여 요청시 요소, 속성 및 기타 데이터를 구성 할 수 있습니다. 이는 전체 모델을 구축 할 필요가 없기 때문에 효율성을 크게 향상시킬 수 있습니다. 예를 들어, 위의 파일 시스템 모델에서는 전체 파일 시스템을 나타내는 전체 XML 파일에 대한 인스턴스를 작성할 필요가 없습니다. 대신 노드는 요청시 생성되며 파일 시스템의 작은 하위 집합 일 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c78c159fb1a47e011fbc4b1b7ed3ea8b59c8a82e" translate="yes" xml:space="preserve">
          <source>With Qt for INTEGRITY you can build and develop applications for the INTEGRITY RTOS. Qt for INTEGRITY supports most &lt;a href=&quot;qtwebassembly-platform-notes#supported-qt-modules&quot;&gt;Qt Modules&lt;/a&gt;. The development environment includes your target device and Qt sources that you need to build for your target device. See &lt;a href=&quot;#supported-development-hosts-and-boards&quot;&gt;Supported Development Hosts and Boards&lt;/a&gt; for detailed information about the supported development environment.</source>
          <target state="translated">INTEGRITY 용 Qt를 사용하면 INTEGRITY RTOS 용 애플리케이션을 빌드하고 개발할 수 있습니다. INTEGRITY 용 Qt는 대부분의 &lt;a href=&quot;qtwebassembly-platform-notes#supported-qt-modules&quot;&gt;Qt 모듈을&lt;/a&gt; 지원합니다 . 개발 환경에는 대상 장치 및 대상 장치를 위해 빌드해야하는 Qt 소스가 포함됩니다. 참조 &lt;a href=&quot;#supported-development-hosts-and-boards&quot;&gt;지원 개발 호스트 및 보드&lt;/a&gt; 지원되는 개발 환경에 대한 자세한 정보는.</target>
        </trans-unit>
        <trans-unit id="8f59c1714c7571ae8afd5652446f0ed08ecf749a" translate="yes" xml:space="preserve">
          <source>With Qt for INTEGRITY you can build and develop applications for the INTEGRITY RTOS. Qt for INTEGRITY supports most &lt;a href=&quot;qtwebassembly-platform-notes#supported-qt-modules&quot;&gt;Qt Modules&lt;/a&gt;. The development environment includes your target device and Qt sources that you need to build for your target device. See &lt;a href=&quot;integrity#supported-development-hosts-and-boards&quot;&gt;Supported Development Hosts and Boards&lt;/a&gt; for detailed information about the supported development environment.</source>
          <target state="translated">INTEGRITY 용 Qt를 사용하면 INTEGRITY RTOS 용 애플리케이션을 구축하고 개발할 수 있습니다. INTEGRITY 용 Qt는 대부분의 &lt;a href=&quot;qtwebassembly-platform-notes#supported-qt-modules&quot;&gt;Qt 모듈을&lt;/a&gt; 지원합니다 . 개발 환경에는 대상 장치 및 대상 장치 용으로 빌드해야하는 Qt 소스가 포함됩니다. 참조 &lt;a href=&quot;integrity#supported-development-hosts-and-boards&quot;&gt;지원 개발 호스트 및 보드&lt;/a&gt; 지원되는 개발 환경에 대한 자세한 정보는.</target>
        </trans-unit>
        <trans-unit id="69fb83e92c1f79f960bcc24dd540282df982418a" translate="yes" xml:space="preserve">
          <source>With Qt version 4.3 or higher, clipboard changes made by other applications will only be detected when the application is activated.</source>
          <target state="translated">Qt 버전 4.3 이상에서는 다른 응용 프로그램에서 수행 한 클립 보드 변경 사항이 응용 프로그램이 활성화 된 경우에만 감지됩니다.</target>
        </trans-unit>
        <trans-unit id="38c1bb6dacd5c65a7b7279214271a5b38f1f18ac" translate="yes" xml:space="preserve">
          <source>With WinRT and on INTEGRITY, the returned value is the &lt;a href=&quot;qtcpserver&quot;&gt;QTcpServer&lt;/a&gt; socket descriptor and the type is defined by &lt;a href=&quot;qtcpserver#socketDescriptor&quot;&gt;socketDescriptor&lt;/a&gt;.</source>
          <target state="translated">WinRT 및 INTEGRITY에서 반환 된 값은 &lt;a href=&quot;qtcpserver&quot;&gt;QTcpServer&lt;/a&gt; 소켓 설명자이고 형식은 &lt;a href=&quot;qtcpserver#socketDescriptor&quot;&gt;socketDescriptor에&lt;/a&gt; 의해 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="3276d2fcc5a01e5cb84d4dc7659ad61ff8ba72e1" translate="yes" xml:space="preserve">
          <source>With WinRT and on INTEGRITY, the returned value is the &lt;a href=&quot;qtcpsocket&quot;&gt;QTcpSocket&lt;/a&gt; socket descriptor and the type is defined by &lt;a href=&quot;qabstractsocket#socketDescriptor&quot;&gt;socketDescriptor&lt;/a&gt;.</source>
          <target state="translated">WinRT 및 INTEGRITY에서 반환 된 값은 &lt;a href=&quot;qtcpsocket&quot;&gt;QTcpSocket&lt;/a&gt; 소켓 설명자이고 형식은 &lt;a href=&quot;qabstractsocket#socketDescriptor&quot;&gt;socketDescriptor에&lt;/a&gt; 의해 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="94008095cf1b24661e83773e6fc0caa74124c0a4" translate="yes" xml:space="preserve">
          <source>With a &lt;a href=&quot;qml-qtquick3d-custommaterial&quot;&gt;CustomMaterial&lt;/a&gt; transforming the vertices</source>
          <target state="translated">A를 &lt;a href=&quot;qml-qtquick3d-custommaterial&quot;&gt;CustomMaterial&lt;/a&gt; 정점을 변환</target>
        </trans-unit>
        <trans-unit id="856d7b0adeb7edb46b8f14deecdbbcf56b759d07" translate="yes" xml:space="preserve">
          <source>With a camera determined, it is possible to calculate the projection matrix for this frame. The calculation is done at this point because each renderable needs to know how to be projected. This also means that it is now possible to calculate which renderable items should be rendered. Starting with the list of all renderable items, we remove all items that are not visible because they are either disabled or completely transparent. Then, if frustum culling is enabled on the active camera, each renderable item is checked to see if it is completely outside of the view of the camera's frustum, and if so it is removed from the renderable list.</source>
          <target state="translated">카메라가 결정되면이 프레임에 대한 투영 행렬을 계산할 수 있습니다. 각 렌더러 블은 투영 방법을 알아야하기 때문에이 시점에서 계산이 수행됩니다. 이는 또한 렌더링 할 렌더링 가능한 항목을 계산할 수 있음을 의미합니다. 렌더링 가능한 모든 항목 목록부터 시작하여 표시되지 않거나 완전히 투명하기 때문에 보이지 않는 모든 항목을 제거합니다. 그런 다음 활성 카메라에서 절두체 컬링이 활성화 된 경우 각 렌더링 가능한 항목이 카메라의 절두체 뷰에서 완전히 벗어 났는지 확인하고, 그렇다면 렌더링 가능 목록에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="c0055b7bd0044bac2582ebd0bfa65dec57fe1df3" translate="yes" xml:space="preserve">
          <source>With a scroll bar policy of &lt;a href=&quot;qt#ScrollBarPolicy-enum&quot;&gt;Qt::ScrollBarAsNeeded&lt;/a&gt; (the default), &lt;a href=&quot;qabstractscrollarea&quot;&gt;QAbstractScrollArea&lt;/a&gt; shows scroll bars when they provide a non-zero scrolling range, and hides them otherwise.</source>
          <target state="translated">&lt;a href=&quot;qt#ScrollBarPolicy-enum&quot;&gt;Qt :: ScrollBarAsNeeded&lt;/a&gt; (기본값) 의 스크롤 막대 정책을 사용하면 &lt;a href=&quot;qabstractscrollarea&quot;&gt;QAbstractScrollArea&lt;/a&gt; 는 0이 아닌 스크롤 범위를 제공 할 때 스크롤 막대를 표시하고 그렇지 않으면 스크롤 막대를 숨 깁니다.</target>
        </trans-unit>
        <trans-unit id="588817461689f4648aeaa1203fd38f984768ded4" translate="yes" xml:space="preserve">
          <source>With a scroll bar policy of &lt;a href=&quot;qt#ScrollBarPolicy-enum&quot;&gt;Qt::ScrollBarAsNeeded&lt;/a&gt; (the default), QAbstractScrollArea shows scroll bars when they provide a non-zero scrolling range, and hides them otherwise.</source>
          <target state="translated">스크롤 막대 정책이 &lt;a href=&quot;qt#ScrollBarPolicy-enum&quot;&gt;Qt :: ScrollBarAsNeeded&lt;/a&gt; (기본값) 인 경우 QAbstractScrollArea는 0이 아닌 스크롤 범위를 제공 할 때 스크롤 막대를 표시하고 그렇지 않으면 숨 깁니다.</target>
        </trans-unit>
        <trans-unit id="5b86fde7c459bcbfcfa267a5ff9e215a585397ef" translate="yes" xml:space="preserve">
          <source>With above definitions, &lt;code&gt;qmake&lt;/code&gt; invokes &lt;code&gt;qscxmlc&lt;/code&gt; to generate MyStatemachine.h and MyStatemachine.cpp, and adds them to &lt;a href=&quot;qmake-variable-reference#headers&quot;&gt;HEADERS&lt;/a&gt; and &lt;a href=&quot;qmake-variable-reference#sources&quot;&gt;SOURCES&lt;/a&gt; variables.</source>
          <target state="translated">위 정의에서 &lt;code&gt;qmake&lt;/code&gt; 는 &lt;code&gt;qscxmlc&lt;/code&gt; 를 호출 하여 MyStatemachine.h 및 MyStatemachine.cpp를 생성하고이를 &lt;a href=&quot;qmake-variable-reference#headers&quot;&gt;HEADERS&lt;/a&gt; 및 &lt;a href=&quot;qmake-variable-reference#sources&quot;&gt;SOURCES&lt;/a&gt; 변수에 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="23532dbc4d414bd26d528c80048829ff3523bbff" translate="yes" xml:space="preserve">
          <source>With above, QDoc will search for a file &lt;code&gt;$T_INSTALL_DOCS/qtdoc/qtdoc.index&lt;/code&gt; for a dependency to &lt;code&gt;qtdoc&lt;/code&gt;. If an index file for a dependency is not found, QDoc will output a warning.</source>
          <target state="translated">이상으로, QDOC은 파일을 검색합니다 &lt;code&gt;$T_INSTALL_DOCS/qtdoc/qtdoc.index&lt;/code&gt; 에 대한 종속성에 대한 &lt;code&gt;qtdoc&lt;/code&gt; . 종속성에 대한 색인 파일을 찾을 수없는 경우 QDoc은 경고를 출력합니다.</target>
        </trans-unit>
        <trans-unit id="90f3b749f81d01b2b5e2f0a5d8e087a29b49e2f8" translate="yes" xml:space="preserve">
          <source>With above, the output goes to &lt;code&gt;&amp;lt;outputdir&amp;gt;/html&lt;/code&gt;.</source>
          <target state="translated">위와 같이 출력은 &lt;code&gt;&amp;lt;outputdir&amp;gt;/html&lt;/code&gt; 로갑니다 .</target>
        </trans-unit>
        <trans-unit id="b15a21b29363c3b39cc0f6c7ee308ae9c4564e0b" translate="yes" xml:space="preserve">
          <source>With asynchronous method invocations, the parameters must be of types that are known to Qt's meta-object system, because Qt needs to copy the arguments to store them in an event behind the scenes. If you try to use a queued connection and get the error message</source>
          <target state="translated">비동기 메소드 호출의 경우 Qt는 메타 이벤트 시스템에 알려진 유형이어야합니다. Qt는 뒤에서 이벤트에 저장하기 위해 인수를 복사해야하기 때문입니다. 대기 연결을 사용하려고 시도하고 오류 메시지가 표시되는 경우</target>
        </trans-unit>
        <trans-unit id="e6de4d619d9110413879a282b274cd1a66b256e9" translate="yes" xml:space="preserve">
          <source>With every new key pressed, the input method will try to create a matching string for the text typed so far called preedit string. While the input context is active, the user can only move the cursor inside the string belonging to this input context.</source>
          <target state="translated">모든 새 키를 누를 때마다 입력 메소드는 지금까지 사전 편집 문자열이라고 입력 한 텍스트에 일치하는 문자열을 작성하려고 시도합니다. 입력 컨텍스트가 활성화되어있는 동안 사용자는이 입력 컨텍스트에 속하는 문자열 내에서만 커서를 이동할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="673d6b13ddc2d912706385fe78fc3d71c3d6e826" translate="yes" xml:space="preserve">
          <source>With exception of stretch this property is honored by all &lt;a href=&quot;qheaderview#ResizeMode-enum&quot;&gt;resize modes&lt;/a&gt;</source>
          <target state="translated">스트레치를 제외하고이 속성은 모든 &lt;a href=&quot;qheaderview#ResizeMode-enum&quot;&gt;크기 조정 모드에서 사용됩니다.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="41df9982939bf1be88fb0cdd6e6ef7ea4641826a" translate="yes" xml:space="preserve">
          <source>With focusOnTouch switched off, &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; behaves as one would expect on &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt;.</source>
          <target state="translated">focusOnTouch를 끄면 &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; 은 &lt;a href=&quot;internationalization#macos&quot;&gt;macOS에서&lt;/a&gt; 예상 한대로 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="ab1743a92e7b4813d9a91b3ed5e64db53f470a34" translate="yes" xml:space="preserve">
          <source>With focusOnTouch switched off, &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; behaves as one would expect on macOS.</source>
          <target state="translated">focusOnTouch를 끄면 &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; 이 macOS에서 예상하는대로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="821e71fdf72d781b71a1fbea52fb1d4c3002eb2f" translate="yes" xml:space="preserve">
          <source>With kinetic scrolling, the user can push the widget in a given direction and it will continue to scroll in this direction until it is stopped either by the user or by friction. Aspects of inertia, friction and other physical concepts can be changed in order to fine-tune an intuitive user experience.</source>
          <target state="translated">키네틱 스크롤을 사용하면 사용자는 위젯을 주어진 방향으로 밀 수 있으며 사용자가 또는 마찰에 의해 중지 될 때까지이 방향으로 계속 스크롤합니다. 직관적 인 사용자 경험을 미세 조정하기 위해 관성, 마찰 및 기타 물리적 개념의 측면을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b879995b4ecf5982d1f676e0d66843140979c2b" translate="yes" xml:space="preserve">
          <source>With named binding, the bound values can be examined in the following ways:</source>
          <target state="translated">명명 된 바인딩을 사용하면 다음과 같은 방법으로 바인딩 된 값을 검사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="51146c030055b1726d8afea222699007093e9f63" translate="yes" xml:space="preserve">
          <source>With one exception, once an &lt;a href=&quot;qxmlstreamreader#error&quot;&gt;error&lt;/a&gt;() is reported by readNext(), further reading of the XML stream is not possible. Then &lt;a href=&quot;qxmlstreamreader#atEnd&quot;&gt;atEnd&lt;/a&gt;() returns &lt;code&gt;true&lt;/code&gt;, &lt;a href=&quot;qxmlstreamreader#hasError&quot;&gt;hasError&lt;/a&gt;() returns &lt;code&gt;true&lt;/code&gt;, and this function returns &lt;a href=&quot;qxmlstreamreader#TokenType-enum&quot;&gt;QXmlStreamReader::Invalid&lt;/a&gt;.</source>
          <target state="translated">예외적으로, readNext ()에 의해 &lt;a href=&quot;qxmlstreamreader#error&quot;&gt;오류&lt;/a&gt; ()가보고되면 XML 스트림을 더 이상 읽을 수 없습니다. 그런 다음 &lt;a href=&quot;qxmlstreamreader#atEnd&quot;&gt;atEnd&lt;/a&gt; ()는 &lt;code&gt;true&lt;/code&gt; 를 반환 하고 &lt;a href=&quot;qxmlstreamreader#hasError&quot;&gt;hasError&lt;/a&gt; ()는 &lt;code&gt;true&lt;/code&gt; 를 반환 &lt;a href=&quot;qxmlstreamreader#TokenType-enum&quot;&gt;하며이&lt;/a&gt; 함수는 QXmlStreamReader :: Invalid를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="9aad0cbd983b7614d584843441c029b9cbdb475f" translate="yes" xml:space="preserve">
          <source>With pointer devices, however, it might be desired to show a tool tip as a result of hovering a button for a while. The following example presents how to show a tool tip after hovering a button for a second, and hide it after a timeout of five seconds.</source>
          <target state="translated">그러나 포인터 장치를 사용하면 버튼을 잠시 동안 움직여서 도구 설명을 표시하는 것이 좋습니다. 다음 예제는 버튼을 1 초간 움직 인 후 도구 설명을 표시하고 5 초의 시간 초과 후에 숨기는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="b07b9a0650c08801fb3ee24f13888eb52c25da23" translate="yes" xml:space="preserve">
          <source>With positional binding, the code becomes:</source>
          <target state="translated">위치 바인딩을 사용하면 코드가 다음과 같이됩니다.</target>
        </trans-unit>
        <trans-unit id="350e0215a00adf00788271d9e8529f364e45277e" translate="yes" xml:space="preserve">
          <source>With queued connections, the parameters must be of types that are known to Qt's meta-object system, because Qt needs to copy the arguments to store them in an event behind the scenes. If you try to use a queued connection and get the error message:</source>
          <target state="translated">큐 연결을 사용하면 매개 변수는 Qt의 메타 오브젝트 시스템에 알려진 유형이어야합니다. Qt는 장면 뒤의 이벤트에 매개 변수를 저장하기 위해 인수를 복사해야하기 때문입니다. 대기 연결을 사용하려고하면 오류 메시지가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="b74c8e9c91ca73f46a082cd5ab4871c9535f44d9" translate="yes" xml:space="preserve">
          <source>With regard to the frontend/backend separation, &lt;a href=&quot;qml-qtquick3d-view3d&quot;&gt;View3D&lt;/a&gt; is the separation point from the user perspective because a &lt;a href=&quot;qml-qtquick3d-view3d&quot;&gt;View3D&lt;/a&gt; is what defines what scene content to render. In the Qt Quick Spatial Scene Graph, the root node for a scene that will be rendered is a Layer node. Layer nodes are created by the &lt;a href=&quot;qml-qtquick3d-view3d&quot;&gt;View3D&lt;/a&gt; using a combination of the the &lt;a href=&quot;qml-qtquick3d-view3d&quot;&gt;View3D&lt;/a&gt;'s properties and the properties of the &lt;a href=&quot;qml-qtquick3d-sceneenvironment&quot;&gt;SceneEnvironment&lt;/a&gt;. When rendering a scene for a &lt;a href=&quot;qml-qtquick3d-view3d&quot;&gt;View3D&lt;/a&gt;, it is this Layer node that is being passed to the renderer to render a scene.</source>
          <target state="translated">프론트 엔드 / 백엔드 분리에 관해서는, &lt;a href=&quot;qml-qtquick3d-view3d&quot;&gt;View3D는&lt;/a&gt; 때문에 사용자 관점에서 분리 점은 &lt;a href=&quot;qml-qtquick3d-view3d&quot;&gt;View3D이&lt;/a&gt; 장면의 내용을 렌더링하는 작업을 정의하는 것이다. Qt Quick Spatial Scene Graph에서 렌더링 될 장면의 루트 노드는 레이어 노드입니다. 레이어 노드에 의해 생성 된 &lt;a href=&quot;qml-qtquick3d-view3d&quot;&gt;View3D&lt;/a&gt; 하여의 조합을 사용하여 &lt;a href=&quot;qml-qtquick3d-view3d&quot;&gt;View3D&lt;/a&gt; 의 속성과의 특성 &lt;a href=&quot;qml-qtquick3d-sceneenvironment&quot;&gt;SceneEnvironment을&lt;/a&gt; . &lt;a href=&quot;qml-qtquick3d-view3d&quot;&gt;View3D에&lt;/a&gt; 대한 장면을 렌더링 할 때 장면을 렌더링 하기 위해 렌더러에 전달되는 것은이 레이어 노드입니다.</target>
        </trans-unit>
        <trans-unit id="a6a070bcffff40c5594afefafc985c9414a6eb90" translate="yes" xml:space="preserve">
          <source>With some IR sensors, it is quite uncommon to reach the top and the bottom of the value range, and some parts of the range ends might not be obtainable at all. This is due to the behavior of the sensor hardware. With these sensors, the absolute value of reflectance should never be used directly. Instead, applications should react to the relative change of the reading values. Use &lt;a href=&quot;qproximitysensor&quot;&gt;QProximitySensor&lt;/a&gt; if it is only necessary to check if something is close to the device or not.</source>
          <target state="translated">일부 IR 센서의 경우 값 범위의 상단과 하단에 도달하는 것이 매우 드물며 범위 끝의 일부를 얻지 못할 수도 있습니다. 이것은 센서 하드웨어의 동작 때문입니다. 이 센서를 사용하면 절대 반사율 값을 직접 사용해서는 안됩니다. 대신, 어플리케이션은 판독 값의 상대적인 변화에 반응해야합니다. &lt;a href=&quot;qproximitysensor&quot;&gt;QProximitySensor를&lt;/a&gt; 사용 하여 장치에 가까운 것이 있는지 확인 해야하는 경우에만 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="98860aeaceada0d58cee21ee4f89dcc02a0a5c9c" translate="yes" xml:space="preserve">
          <source>With some graphics APIs it can be necessary to also connect to the &lt;a href=&quot;qquickwindow#beforeRendering&quot;&gt;QQuickWindow::beforeRendering&lt;/a&gt;() signal, because that is emitted before recording the beginning of a renderpass on the command buffer (vkCmdBeginRenderPass with Vulkan, or starting to encode via MTLRenderCommandEncoder in case of Metal). Recording copy operations cannot be done inside render() with such APIs. Rather, do it in the slot connected (with DirectConnection) to the beforeRendering signal.</source>
          <target state="translated">일부 그래픽 API의 경우 &lt;a href=&quot;qquickwindow#beforeRendering&quot;&gt;QQuickWindow :: beforeRendering&lt;/a&gt; () 신호 에도 연결해야 할 수 있습니다 . 이는 명령 버퍼 (Vulkan의 vkCmdBeginRenderPass 또는 금속). 이러한 API를 사용하여 render () 내에서 복사 작업을 기록 할 수 없습니다. 오히려 beforeRendering 신호에 연결된 슬롯 (DirectConnection 사용)에서 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="4d526548226a74231157fec5d123f22dd6139bca" translate="yes" xml:space="preserve">
          <source>With textures, the data that needs to be provided is a lot simpler structurally: it is the raw pixel data, with a varying number of bytes per pixel, depending on the texture format. For example, an &lt;code&gt;RGBA&lt;/code&gt; texture expects four bytes per pixel, whereas &lt;code&gt;RGBA16F&lt;/code&gt; is four half-floats per pixel. This is similar to what a &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt; stores internally. However, Qt Quick 3D textures can have formats the data for which cannot be represented by a &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt;. For example, floating point HDR textures, or compressed textures. Therefore the data for &lt;a href=&quot;qquick3dtexturedata&quot;&gt;QQuick3DTextureData&lt;/a&gt; is always provided as a raw sequence of bytes. This may seem familiar if one has worked with graphics APIs, such as OpenGL or Vulkan directly.</source>
          <target state="translated">텍스처를 사용하면 제공해야하는 데이터가 구조적으로 훨씬 더 간단합니다. 이는 텍스처 형식에 따라 픽셀 당 다양한 바이트 수를 갖는 원시 픽셀 데이터입니다. 예를 들어 &lt;code&gt;RGBA&lt;/code&gt; 텍스처는 픽셀 당 4 바이트를 예상하는 반면 &lt;code&gt;RGBA16F&lt;/code&gt; 는 픽셀 당 4 개의 half-floats입니다. 이것은 &lt;a href=&quot;qimage&quot;&gt;QImage가&lt;/a&gt; 내부적으로 저장 하는 것과 유사합니다 . 그러나 Qt Quick 3D 텍스처는 &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt; 로 표현할 수없는 데이터 형식을 가질 수 있습니다 . 예를 들어 부동 소수점 HDR 텍스처 또는 압축 된 텍스처입니다. 따라서 &lt;a href=&quot;qquick3dtexturedata&quot;&gt;QQuick3DTextureData&lt;/a&gt; 의 데이터 는 항상 원시 바이트 시퀀스로 제공됩니다. OpenGL 또는 Vulkan과 같은 그래픽 API로 직접 작업했다면 익숙해 보일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="221abf8769a746fc8a5d0c3cbda6329aff80f937" translate="yes" xml:space="preserve">
          <source>With that in place, we can run our example. To tell the application to use our new style, we pass &lt;code&gt;-style :/mystyle&lt;/code&gt; as an application argument, but there are &lt;a href=&quot;qtquickcontrols2-styles#using-styles-in-qt-quick-controls&quot;&gt;many ways&lt;/a&gt; to specify the style to use.</source>
          <target state="translated">그 자리에서 우리는 예제를 실행할 수 있습니다. 새로운 스타일을 사용하도록 응용 프로그램에 지시하려면 &lt;code&gt;-style :/mystyle&lt;/code&gt; 을 응용 프로그램 인수로 전달하지만 사용할 스타일을 지정하는 &lt;a href=&quot;qtquickcontrols2-styles#using-styles-in-qt-quick-controls&quot;&gt;방법&lt;/a&gt; 에는 여러 가지 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="20ed663ad7aa47554249fed415db68eab6505978" translate="yes" xml:space="preserve">
          <source>With that in place, we can run our example. To tell the application to use our new style, we pass &lt;code&gt;-style :/mystyle&lt;/code&gt; as an application argument, but there are &lt;a href=&quot;qtquickcontrols2-styles#using-styles-in-qt-quick-controls-2&quot;&gt;many ways&lt;/a&gt; to specify the style to use.</source>
          <target state="translated">그 자리에 예제를 실행할 수 있습니다. 애플리케이션에 새로운 스타일을 사용하도록하려면 &lt;code&gt;-style :/mystyle&lt;/code&gt; 을 애플리케이션 인수로 전달하지만 사용할 스타일을 지정하는 &lt;a href=&quot;qtquickcontrols2-styles#using-styles-in-qt-quick-controls-2&quot;&gt;방법&lt;/a&gt; 에는 여러 가지 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8ac63c9568d29ff6c69da12238521cc0fa8f7c1" translate="yes" xml:space="preserve">
          <source>With that in place, we can run our example. To tell the application to use our new style, we pass &lt;code&gt;-style MyStyle&lt;/code&gt; as an application argument, but there are &lt;a href=&quot;qtquickcontrols2-styles#using-styles-in-qt-quick-controls&quot;&gt;many ways&lt;/a&gt; to specify the style to use.</source>
          <target state="translated">그 자리에서 우리는 우리의 예를 실행할 수 있습니다. 응용 프로그램에 새 스타일을 사용하도록 지시하기 위해 &lt;code&gt;-style MyStyle&lt;/code&gt; 을 응용 프로그램 인수로 전달 하지만 사용할 스타일을 지정하는 &lt;a href=&quot;qtquickcontrols2-styles#using-styles-in-qt-quick-controls&quot;&gt;방법&lt;/a&gt; 에는 여러 가지 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="5fbed55f199978b95bb8be9cfaa32f1145085ad9" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;desktop&lt;/code&gt; option, Qt uses the OpenGL installed on Windows, requiring that the OpenGL in the target Windows machine is compatible with the application. The &lt;code&gt;-opengl&lt;/code&gt; option accepts two versions of OpenGL ES, &lt;code&gt;es2&lt;/code&gt; for OpenGL ES 2.0 or &lt;code&gt;es1&lt;/code&gt; for OpenGL ES Common Profile.</source>
          <target state="translated">으로 &lt;code&gt;desktop&lt;/code&gt; 옵션, Qt는 대상 Windows 시스템의 OpenGL을 응용 프로그램과 호환되는지 요구, 윈도우에 설치된 OpenGL을 사용합니다. &lt;code&gt;-opengl&lt;/code&gt; 옵션의 OpenGL ES, 두 가지 버전의 수용 &lt;code&gt;es2&lt;/code&gt; 는 OpenGL ES 2.0 또는 &lt;code&gt;es1&lt;/code&gt; 는 OpenGL ES 공통 프로파일에 대한합니다.</target>
        </trans-unit>
        <trans-unit id="fe042905e84c3d5fdcfaa8645b39f1c47f0fbe13" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;dynamic&lt;/code&gt; option, Qt will try to use native OpenGL first. If that fails, it will fall back to ANGLE and finally to software rendering in case of ANGLE failing as well.</source>
          <target state="translated">으로 &lt;code&gt;dynamic&lt;/code&gt; 옵션, Qt는 먼저 기본 OpenGL을 사용하려고합니다. 실패하면 ANGLE로 돌아가 ANGLE이 실패한 경우 소프트웨어 렌더링으로 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="9c564f0cac53211709d0377812b2fa7ac34743fe" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;evdev&lt;/code&gt; backend, to explicitly specify the input device to use, set the environment variable &lt;code&gt;QT_GAMEPAD_DEVICE&lt;/code&gt; to the desired /dev/input/event* node. This should not be needed normally, but can be useful in case multiple gamepads are connected and only one of them is interesting to the application.</source>
          <target state="translated">으로 &lt;code&gt;evdev&lt;/code&gt; 의 백엔드, 명시 적으로 설정, 사용하는 환경 변수의 입력 장치를 지정 &lt;code&gt;QT_GAMEPAD_DEVICE&lt;/code&gt; 소망 / 디바이스 / 입력 / 이벤트 * 노드를. 일반적으로 필요하지는 않지만 여러 게임 패드가 연결되어 있고 그 중 하나만 응용 프로그램에 흥미있는 경우 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="931e9e916ca3659002048961c97277bffef20b49" translate="yes" xml:space="preserve">
          <source>With the Desaturate effect, you can decrease the intensity of all colors in the scene.</source>
          <target state="translated">채도 감소 효과를 사용하면 장면에있는 모든 색상의 강도를 줄일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c4f9b7a9a12ad19f18e25c2d90f8b83e221b8ab" translate="yes" xml:space="preserve">
          <source>With the Maps API we can associate a position with a map in various formats supplied by a backend. Then the Places API could be used to populate places on the Map or even specify the current position as a place of interest and associate it with an icon, contact details and other information.</source>
          <target state="translated">Maps API를 사용하면 백엔드에서 제공하는 다양한 형식의지도와 위치를 연결할 수 있습니다. 그런 다음 Places API를 사용하여지도에 장소를 채우거나 현재 위치를 관심있는 장소로 지정하고 아이콘, 연락처 세부 정보 및 기타 정보와 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d3dd1511bb2506b5f01cd151fa5a1a2f06d1da5" translate="yes" xml:space="preserve">
          <source>With the Qt XML classes elements and attributes can be accessed in two ways: either by referring to their qualified names consisting of the namespace prefix and the &quot;real&quot; name (or</source>
          <target state="translated">Qt XML 클래스를 사용하면 네임 스페이스 접두사와 &quot;실제&quot;이름으로 구성된 정규화 된 이름을 참조하여 두 가지 방법으로 요소 및 속성에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="905157790ef1d40d0ff66af116456c111f9c52e1" translate="yes" xml:space="preserve">
          <source>With the Raspberry Pi 4 example, we expect that EGL, OpenGL ES and &lt;code&gt;EGLFS GBM&lt;/code&gt; are all reported as &lt;code&gt;yes&lt;/code&gt;, otherwise the EGLFS platform plugin and its &lt;b&gt;eglfs_kms&lt;/b&gt; backend will not be functional on the device. For getting function mouse, keyboard, and touch input, either &lt;code&gt;evdev&lt;/code&gt; or &lt;code&gt;libinput&lt;/code&gt; must be enabled.</source>
          <target state="translated">Raspberry Pi 4 예제에서는 EGL, OpenGL ES 및 &lt;code&gt;EGLFS GBM&lt;/code&gt; 이 모두 &lt;code&gt;yes&lt;/code&gt; 로보고 될 것으로 예상합니다 . 그렇지 않으면 EGLFS 플랫폼 플러그인과 &lt;b&gt;eglfs_kms&lt;/b&gt; 백엔드가 장치에서 작동하지 않습니다. 기능 마우스, 키보드 및 터치 입력을 &lt;code&gt;libinput&lt;/code&gt; 려면 &lt;code&gt;evdev&lt;/code&gt; 또는 libinput 을 활성화해야합니다.</target>
        </trans-unit>
        <trans-unit id="b02e908cf412444190b61dcfbc88106e96789821" translate="yes" xml:space="preserve">
          <source>With the Sensor Gestures classes, you are able to easily utilize device gesturing using sensors, such as the accelerometer and proximity.</source>
          <target state="translated">Sensor Gestures 클래스를 사용하면 가속도계 및 근접 센서와 같은 센서를 사용하여 장치 몸짓을 쉽게 활용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="869c294776bf9a426f97c9fa13c232b465ef28f4" translate="yes" xml:space="preserve">
          <source>With the above definitions, you can use a drop-in replacement for moc if one is available. The command is executed on all arguments given to the &lt;code&gt;NEW_HEADERS&lt;/code&gt; variable (from the &lt;code&gt;input&lt;/code&gt; member), and the result is written to the file defined by the &lt;code&gt;output&lt;/code&gt; member. This file is added to the other source files in the project. Additionally, qmake will execute &lt;code&gt;depend_command&lt;/code&gt; to generate dependency information, and place this information in the project as well.</source>
          <target state="translated">위의 정의를 사용하면 moc 대신 드롭 인 대체를 사용할 수 있습니다 (사용 가능한 경우). 명령은 &lt;code&gt;NEW_HEADERS&lt;/code&gt; 변수 ( &lt;code&gt;input&lt;/code&gt; 멤버 로부터)에 제공된 모든 인수에 대해 실행되며 결과는 &lt;code&gt;output&lt;/code&gt; 멤버에 의해 정의 된 파일에 기록됩니다 . 이 파일은 프로젝트의 다른 소스 파일에 추가됩니다. 또한 qmake는 &lt;code&gt;depend_command&lt;/code&gt; 를 실행 하여 종속성 정보를 생성하고이 정보를 프로젝트에도 배치합니다.</target>
        </trans-unit>
        <trans-unit id="0c9d9db8c01bcb8d9c2e413e21461cd2f445de92" translate="yes" xml:space="preserve">
          <source>With the above example, the &lt;a href=&quot;qml-qtquick3d-custommaterial#shadingMode-prop&quot;&gt;unshaded&lt;/a&gt; vertex and fragment shaders snippets could look like the following. Note how the shaders do not, and must not, declare uniforms or vertex inputs as that is taken care of by Qt when assembling the final shader code.</source>
          <target state="translated">위의 예에서 &lt;a href=&quot;qml-qtquick3d-custommaterial#shadingMode-prop&quot;&gt;음영 처리되지 않은&lt;/a&gt; 정점 및 조각 셰이더 스 니펫은 다음과 같을 수 있습니다. 최종 셰이더 코드를 어셈블 할 때 Qt에서 처리하므로 셰이더가 균일 또는 정점 입력을 선언하지 않고 선언해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="92b9763b1026f4efa2f3149590e32e26be57dc85" translate="yes" xml:space="preserve">
          <source>With the above shader program active, we can draw a green triangle as follows:</source>
          <target state="translated">위의 셰이더 프로그램이 활성화되면 다음과 같이 녹색 삼각형을 그릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8416fc42b96313b2b8aac317a84d59f62596f044" translate="yes" xml:space="preserve">
          <source>With the addition of the &lt;a href=&quot;bearer-management#&quot;&gt;Bearer Management&lt;/a&gt; API to Qt 4.7 &lt;a href=&quot;qnetworkaccessmanager&quot;&gt;QNetworkAccessManager&lt;/a&gt; gained the ability to manage network connections. &lt;a href=&quot;qnetworkaccessmanager&quot;&gt;QNetworkAccessManager&lt;/a&gt; can start the network interface if the device is offline and terminates the interface if the current process is the last one to use the uplink. Note that some platforms utilize grace periods from when the last application stops using a uplink until the system actually terminates the connectivity link. Roaming is equally transparent. Any queued/pending network requests are automatically transferred to the new access point.</source>
          <target state="translated">With the addition of the &lt;a href=&quot;bearer-management#&quot;&gt;Bearer Management&lt;/a&gt; API to Qt 4.7 &lt;a href=&quot;qnetworkaccessmanager&quot;&gt;QNetworkAccessManager&lt;/a&gt; gained the ability to manage network connections. &lt;a href=&quot;qnetworkaccessmanager&quot;&gt;QNetworkAccessManager&lt;/a&gt; can start the network interface if the device is offline and terminates the interface if the current process is the last one to use the uplink. Note that some platforms utilize grace periods from when the last application stops using a uplink until the system actually terminates the connectivity link. Roaming is equally transparent. Any queued/pending network requests are automatically transferred to the new access point.</target>
        </trans-unit>
        <trans-unit id="00822784ce3826dcb93570b51ca52a383b8f6c0b" translate="yes" xml:space="preserve">
          <source>With the advent of the new HKSCS-2001 standard, James Su &amp;lt;suzhe@turbolinux.com.cn&amp;gt; &amp;lt;suzhe@gnuchina.org&amp;gt; generated the Big5-HKSCS&amp;lt;-&amp;gt;Unicode tables with a very space-efficient algorithm. He generously donated his code to glibc in May 2002. Subsequently, James has generously allowed Anthony Fok to adapt the code for Qt-3.0.5.</source>
          <target state="translated">새로운 HKSCS-2001 표준의 출현으로 James Su &amp;lt;suzhe@turbolinux.com.cn&amp;gt; &amp;lt;suzhe@gnuchina.org&amp;gt;는 매우 공간 효율적인 알고리즘으로 Big5-HKSCS &amp;lt;-&amp;gt; Unicode 테이블을 생성했습니다. 그는 2002 년 5 월 자신의 코드를 glibc에 관대하게 기증했습니다. 그 후 James는 Anthony Fok이 Qt-3.0.5 코드를 관대하게 허용했습니다.</target>
        </trans-unit>
        <trans-unit id="34745d4b077570a08254cc752de60ff0f7330755" translate="yes" xml:space="preserve">
          <source>With the code above, the focus jumps to the Name field when the user presses Alt+N, and to the Phone field when the user presses Alt+P.</source>
          <target state="translated">위 코드를 사용하면 사용자가 Alt + N을 누르면 포커스가 이름 필드로 이동하고 Alt + P를 누르면 전화 필드로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="80e5712c1c33c1ece3ac23542a1c3eba7df1dfcc" translate="yes" xml:space="preserve">
          <source>With the default implementation, each QSGTexture is backed by a QRhiTexture, which in turn contains a native texture object, such as an OpenGL texture or a Vulkan image.</source>
          <target state="translated">기본 구현에서 각 QSGTexture는 QRhiTexture에 의해 지원되며, QRhiTexture는 OpenGL 텍스처 또는 Vulkan 이미지와 같은 기본 텍스처 객체를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="81038844e7a8b209f37aea7424f73ec83d1621b0" translate="yes" xml:space="preserve">
          <source>With the default options, the resulting &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; can be passed back to a &lt;a href=&quot;qurl&quot;&gt;QUrl&lt;/a&gt; later on, but any password that was present initially will be lost.</source>
          <target state="translated">기본 옵션을 사용하면 결과 &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; 을 나중에 &lt;a href=&quot;qurl&quot;&gt;QUrl로&lt;/a&gt; 다시 전달할 수 있지만 처음에 존재했던 모든 비밀번호는 손실됩니다.</target>
        </trans-unit>
        <trans-unit id="b7b06f1a1c686c3d07d35c0610bcd1bd5cb38bd9" translate="yes" xml:space="preserve">
          <source>With the exception of extrusion and data driven style properties, every property described at the &lt;a href=&quot;https://www.mapbox.com/mapbox-gl-js/style-spec/&quot;&gt;Mapbox Style Specification&lt;/a&gt; can be changed at runtime.</source>
          <target state="translated">돌출 및 데이터 기반 스타일 속성을 제외하고 &lt;a href=&quot;https://www.mapbox.com/mapbox-gl-js/style-spec/&quot;&gt;맵 박스 스타일 사양에&lt;/a&gt; 설명 된 모든 속성 을 런타임에 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="db713493bde5a89b6b2702af0419c2a819c6e1f0" translate="yes" xml:space="preserve">
          <source>With the features covered so far a wide range of possibilities are open for creating materials that shade the meshes in visually impressive ways. To finish the basic tour, let's look at an example that applies height and normal maps to a plane mesh. (a dedicated &lt;code&gt;.mesh&lt;/code&gt; file is used here because the builtin &lt;code&gt;#Rectangle&lt;/code&gt; does not have enough subdivisions) For better lighting results, we will use image based lighting with a 360 degree HDR image. The image is also set as the skybox to make it more clear what is happening.</source>
          <target state="translated">지금까지 다룬 기능을 통해 시각적으로 인상적인 방식으로 메시를 음영 처리하는 머티리얼을 만들 수있는 다양한 가능성이 열려 있습니다. 기본 둘러보기를 마치기 위해 높이와 노멀 맵을 평면 메시에 적용하는 예제를 살펴 보겠습니다. ( 내장 된 &lt;code&gt;#Rectangle&lt;/code&gt; 에 충분한 세분화가 없기 때문에 전용 &lt;code&gt;.mesh&lt;/code&gt; 파일이 여기에 사용됩니다. ) 더 나은 조명 결과를 위해 360도 HDR 이미지에 이미지 기반 조명을 사용합니다. 이미지는 또한 무슨 일이 일어나고 있는지 더 명확하게하기 위해 skybox로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="4e8eb7da73c7c3aa1b5265e6b3dba6817c1a8a76" translate="yes" xml:space="preserve">
          <source>With the general QDoc configuration variables, you can define where QDoc will find the various source files it needs to generate the documentation, as well as the directory to put the generated documentation. You can also do some minor manipulation of QDoc itself, controlling its output and processing behavior.</source>
          <target state="translated">일반적인 QDoc 구성 변수를 사용하면 QDoc이 문서를 생성하는 데 필요한 다양한 소스 파일과 생성 된 문서를 저장할 디렉토리를 찾을 위치를 정의 할 수 있습니다. QDoc 자체를 약간 조작하여 출력 및 처리 동작을 제어 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="d3207ec48047d1039819c90608ba318a3c17ce52" translate="yes" xml:space="preserve">
          <source>With the introduction of Qt RHI as the rendering foundation in Qt, most classes prefixed by &lt;code&gt;QOpenGL&lt;/code&gt; have been moved into the &lt;a href=&quot;https://doc.qt.io/qt-6.0/qtopengl-index.html&quot;&gt;Qt OpenGL&lt;/a&gt; module.</source>
          <target state="translated">Qt의 렌더링 기반으로 Qt RHI가 도입됨에 따라 &lt;code&gt;QOpenGL&lt;/code&gt; 이 접두사로 붙은 대부분의 클래스 가 &lt;a href=&quot;https://doc.qt.io/qt-6.0/qtopengl-index.html&quot;&gt;Qt OpenGL&lt;/a&gt; 모듈 로 이동되었습니다 .</target>
        </trans-unit>
        <trans-unit id="0f22d6143da7faf256f2f1ef0a1fc4b305512bb5" translate="yes" xml:space="preserve">
          <source>With the legacy, direct OpenGL based renderer, the following states are set on the render thread's context before this function is called:</source>
          <target state="translated">레거시 직접 OpenGL 기반 렌더러를 사용하면이 함수가 호출되기 전에 렌더 스레드의 컨텍스트에 다음 상태가 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="4630d50555ff84b84eb4d30fe9f9b8852a94a553" translate="yes" xml:space="preserve">
          <source>With the menu bar and the toolbars in place, it's time to populate them with actions. New actions for both menus and toolbars are created in the action editor window, simplifying the creation and management of actions.</source>
          <target state="translated">메뉴 표시 줄과 도구 모음이 제 위치에 있으면이를 작업으로 채울 차례입니다. 메뉴 및 도구 모음 모두에 대한 새 조치가 조치 편집기 창에 작성되어 조치 작성 및 관리가 단순화됩니다.</target>
        </trans-unit>
        <trans-unit id="69d6aed81f0026ce55a79e748bd89bed87b83e08" translate="yes" xml:space="preserve">
          <source>With the mesh object selected, triangulate the mesh by pressing</source>
          <target state="translated">메쉬 개체를 선택한 상태에서</target>
        </trans-unit>
        <trans-unit id="95eb9381e6072798a40389b86655d9fd401f0ce9" translate="yes" xml:space="preserve">
          <source>With the release of Qt 5.0, Qt no longer contains its own window system implementation: QWS is no longer a supported platform. For single-process use cases, the &lt;a href=&quot;qpa&quot;&gt;Qt Platform Abstraction&lt;/a&gt; is a superior solution.</source>
          <target state="translated">Qt 5.0이 출시되면서 Qt는 더 이상 자체 윈도우 시스템 구현을 포함하지 않습니다. QWS는 더 이상 지원되는 플랫폼이 아닙니다. 단일 프로세스 사용 사례의 경우 &lt;a href=&quot;qpa&quot;&gt;Qt Platform Abstraction&lt;/a&gt; 이 우수한 솔루션입니다.</target>
        </trans-unit>
        <trans-unit id="8ba8beaa5ccb89224ebb1e5279efd4bf120446ce" translate="yes" xml:space="preserve">
          <source>With the release of Qt 5.0, Qt no longer contains its own window system implementation: QWS is no longer a supported platform. For single-process use cases, the &lt;a href=&quot;qpa#&quot;&gt;Qt Platform Abstraction&lt;/a&gt; is a superior solution.</source>
          <target state="translated">Qt 5.0이 출시되면서 Qt는 더 이상 자체 윈도우 시스템 구현을 포함하지 않습니다. QWS는 더 이상 지원되는 플랫폼이 아닙니다. 단일 프로세스 사용 사례의 경우 &lt;a href=&quot;qpa#&quot;&gt;Qt 플랫폼 추상화&lt;/a&gt; 는 탁월한 솔루션입니다.</target>
        </trans-unit>
        <trans-unit id="226eafcb0be655108e453892716e9262e96c694f" translate="yes" xml:space="preserve">
          <source>With the string-based syntax, parameter types are explicitly specified. As a result, the desired instance of an overloaded signal or slot is unambiguous.</source>
          <target state="translated">문자열 기반 구문을 사용하면 매개 변수 유형이 명시 적으로 지정됩니다. 결과적으로, 오버로드 된 신호 또는 슬롯의 원하는 인스턴스는 분명하다.</target>
        </trans-unit>
        <trans-unit id="df559dccd3615f39a3779064c769730d95d87094" translate="yes" xml:space="preserve">
          <source>With this addition to the &lt;code&gt;CONFIG&lt;/code&gt; variable, qmake will search the locations listed above for the &lt;code&gt;myfeatures.prf&lt;/code&gt; file after it has finished parsing your project file. On Unix systems, it will look for the following file:</source>
          <target state="translated">&lt;code&gt;CONFIG&lt;/code&gt; 변수에 추가하여 qmake는 프로젝트 파일 구문 분석을 마친 후 &lt;code&gt;myfeatures.prf&lt;/code&gt; 파일에 대해 위에 나열된 위치를 검색 합니다. 유닉스 시스템에서는 다음 파일을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="6ff9e75675058b679f2eb7be7099aa17fe657039" translate="yes" xml:space="preserve">
          <source>With this approach, references to objects are &quot;pulled&quot; from QML. The problem with this is that the C++ logic layer depends on the QML presentation layer. If we were to refactor the QML in such a way that the &lt;code&gt;objectName&lt;/code&gt; changes, or some other change breaks the ability for the C++ to find the QML object, our workflow becomes much more complicated and tedious.</source>
          <target state="translated">이 접근 방식을 사용하면 QML에서 객체에 대한 참조를 &quot;풀&quot;합니다. 이것의 문제점은 C ++ 로직 레이어가 QML 프리젠 테이션 레이어에 의존한다는 것입니다. &lt;code&gt;objectName&lt;/code&gt; 이 변경 되는 방식으로 QML을 리팩토링 하거나 다른 변경으로 인해 C ++에서 QML 오브젝트를 찾는 기능이 손상되면 워크 플로우가 훨씬 더 복잡해지고 지루해집니다.</target>
        </trans-unit>
        <trans-unit id="9f2ab919194cff8766a6dcde52f34360c2fe234f" translate="yes" xml:space="preserve">
          <source>With this approach, the C++ remains unchanged in the event that the QML needs to be refactored in the future.</source>
          <target state="translated">이 접근 방식을 사용하면 향후 QML을 리팩터링해야하는 경우에도 C ++은 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a64fe6916545bea49b7932f628ee891ea8dbc494" translate="yes" xml:space="preserve">
          <source>With this code, every time a Button instance with a customized background is created, both backgrounds will be created, resulting in sub-optimal creation performance.</source>
          <target state="translated">이 코드를 사용하면 배경이 사용자 정의 된 Button 인스턴스가 생성 될 때마다 두 배경이 모두 생성되어 생성 성능이 최적화되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1d72e55e5902cdbd34e9a240ea81a0531c6f03eb" translate="yes" xml:space="preserve">
          <source>With this in mind, a good way to prepare for a migration to Qt Quick Controls 2 is to place each control that you have a custom style for in its own QML file. For example, the Qt Quick Controls 1 button above could be moved to a file named &lt;code&gt;Button.qml&lt;/code&gt; in a directory named &lt;code&gt;controls&lt;/code&gt;, and used in the following manner:</source>
          <target state="translated">이를 염두에두고 Qt Quick Controls 2 로의 마이그레이션을 준비하는 좋은 방법은 사용자 정의 스타일이있는 각 컨트롤을 자체 QML 파일에 배치하는 것입니다. 예를 들어, 위의 Qt Quick Controls 1 버튼 은 &lt;code&gt;controls&lt;/code&gt; 디렉토리에서 &lt;code&gt;Button.qml&lt;/code&gt; 파일로 이동 하여 다음과 같은 방식으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e40643349bff07a93acc7de2d9ba6544d9bed5c" translate="yes" xml:space="preserve">
          <source>With this in place, you can now instantiate nodes using this new custom protocol:</source>
          <target state="translated">이제이 새로운 사용자 지정 프로토콜을 사용하여 노드를 인스턴스화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b44a27f1ba83491906b0359bf1a34061110759e5" translate="yes" xml:space="preserve">
          <source>With this in place, your application's UI should scale depending on the display resolution on offer.</source>
          <target state="translated">이를 통해 제공되는 디스플레이 해상도에 따라 응용 프로그램의 UI가 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="1aaeb06eee8c7d2b3530ca50f98a4f7d9f67617d" translate="yes" xml:space="preserve">
          <source>With this method the web channel can be accessed by web page content. If the content is not under your control and might be hostile, this could be a security issue and you should consider installing it in a private JavaScript world.</source>
          <target state="translated">이 방법을 사용하면 웹 페이지 컨텐츠로 웹 채널에 액세스 할 수 있습니다. 컨텐츠가 통제 할 수없고 적대적인 경우, 이는 보안 문제 일 수 있으며 개인 JavaScript 환경에 설치하는 것을 고려해야합니다.</target>
        </trans-unit>
        <trans-unit id="a71904030ea175c80ffb79064c7c063e94b75ebe" translate="yes" xml:space="preserve">
          <source>With this syntax, the function returns a &lt;a href=&quot;qdebug&quot;&gt;QDebug&lt;/a&gt; object that is configured to use the &lt;a href=&quot;qtglobal#QtMsgType-enum&quot;&gt;QtDebugMsg&lt;/a&gt; message type. It automatically puts a single space between each item, and outputs a newline at the end. It supports many C++ and Qt types.</source>
          <target state="translated">이 구문을 사용하면이 함수는 &lt;a href=&quot;qtglobal#QtMsgType-enum&quot;&gt;QtDebugMsg&lt;/a&gt; 메시지 유형 을 사용하도록 구성된 &lt;a href=&quot;qdebug&quot;&gt;QDebug&lt;/a&gt; 오브젝트를 리턴합니다 . 각 항목 사이에 하나의 공백을 자동으로두고 끝에 줄 바꿈을 출력합니다. 많은 C ++ 및 Qt 유형을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="09e6570fb10b890d1ae82341959ca9e59abf00b3" translate="yes" xml:space="preserve">
          <source>With this syntax, the function returns a &lt;a href=&quot;qdebug&quot;&gt;QDebug&lt;/a&gt; object that is configured to use the &lt;a href=&quot;qtglobal#QtMsgType-enum&quot;&gt;QtInfoMsg&lt;/a&gt; message type. It automatically puts a single space between each item, and outputs a newline at the end. It supports many C++ and Qt types.</source>
          <target state="translated">이 구문을 사용하면 함수는 &lt;a href=&quot;qtglobal#QtMsgType-enum&quot;&gt;QtInfoMsg&lt;/a&gt; 메시지 유형 을 사용하도록 구성된 &lt;a href=&quot;qdebug&quot;&gt;QDebug&lt;/a&gt; 오브젝트를 리턴합니다 . 각 항목 사이에 하나의 공백을 자동으로두고 끝에 줄 바꿈을 출력합니다. 많은 C ++ 및 Qt 유형을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="ab50a0c6987873a38799562140997c8acee97a9b" translate="yes" xml:space="preserve">
          <source>With those files available, you would select a different file on the android platform, but only if the locale was en_GB.</source>
          <target state="translated">해당 파일을 사용할 수 있으면 Android 플랫폼에서 로케일이 en_GB 인 경우에만 다른 파일을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="866895372c80b4bdd3e62c8aef9547035f4c98ee" translate="yes" xml:space="preserve">
          <source>Within a QDoc comment, &lt;code&gt;//!&lt;/code&gt; is used as a single-line documentation comment; the comment itself and anything after it, until a newline, is omitted from the generated output.</source>
          <target state="translated">QDoc 주석 내에서 &lt;code&gt;//!&lt;/code&gt; 한 줄 문서 주석으로 사용됩니다. 줄 바꿈까지 주석 자체와 그 이후의 항목은 생성 된 출력에서 ​​생략됩니다.</target>
        </trans-unit>
        <trans-unit id="655a9796e8fb878a317a5f67cf23c2b1dbd01fee" translate="yes" xml:space="preserve">
          <source>Within a left-to-right text block, decrease cursor position when pressing left arrow key, increase cursor position when pressing the right arrow key. If the text block is right-to-left, the opposite behavior applies.</source>
          <target state="translated">왼쪽에서 오른쪽으로 쓰는 텍스트 블록 내에서 왼쪽 화살표 키를 누를 때 커서 위치를 줄이고 오른쪽 화살표 키를 누를 때 커서 위치를 늘리십시오. 텍스트 블록이 오른쪽에서 왼쪽이면 반대 동작이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="2be4fc252023b47779487c38f81570875da113b8" translate="yes" xml:space="preserve">
          <source>Within a mouse-driven interface, this signal is emitted when a mouse pointer passes over a link, corresponding to the &lt;code&gt;mouseover&lt;/code&gt; DOM event. This event may also occur in touch interfaces for &lt;code&gt;mouseover&lt;/code&gt; events that are not cancelled with &lt;code&gt;preventDefault()&lt;/code&gt;.</source>
          <target state="translated">마우스 구동 인터페이스 내에서이 신호는 마우스 포인터가 &lt;code&gt;mouseover&lt;/code&gt; DOM 이벤트에 해당하는 링크를 통과 할 때 발생합니다 . 이 이벤트는 &lt;code&gt;preventDefault()&lt;/code&gt; 취소되지 않은 &lt;code&gt;mouseover&lt;/code&gt; 이벤트의 터치 인터페이스에서도 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7475ef05b2ebf0cf6f98c2374da72ca3b31d77a3" translate="yes" xml:space="preserve">
          <source>Within a test program, test functions should be independent of each other and they should not rely upon previous test functions having been run. You can check this by running the test function on its own with &lt;code&gt;tst_foo testname&lt;/code&gt;.</source>
          <target state="translated">테스트 프로그램 내에서 테스트 기능은 서로 독립적이어야하며 이전에 실행 된 테스트 기능에 의존해서는 안됩니다. &lt;code&gt;tst_foo testname&lt;/code&gt; 으로 테스트 함수를 자체적으로 실행하여이를 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6b45d63a358e475e448bdb8871a6ca660c14056b" translate="yes" xml:space="preserve">
          <source>Within each area, different</source>
          <target state="translated">각 지역 내에서 다른</target>
        </trans-unit>
        <trans-unit id="e4059b684739705541b9624361d42e0f33def68e" translate="yes" xml:space="preserve">
          <source>Within each focus scope one object may have &lt;code&gt;Item::focus&lt;/code&gt; set to &lt;code&gt;true&lt;/code&gt;. If more than one &lt;a href=&quot;qml-qtquick-item&quot;&gt;Item&lt;/a&gt; has the &lt;code&gt;focus&lt;/code&gt; property set, the last type to set the &lt;code&gt;focus&lt;/code&gt; will have the focus and the others are unset, similar to when there are no focus scopes.</source>
          <target state="translated">각 포커스 범위 내에서 하나의 객체에 &lt;code&gt;Item::focus&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 로 설정되어 있을 수 있습니다 . 둘 이상의 &lt;a href=&quot;qml-qtquick-item&quot;&gt;항목&lt;/a&gt; 에 &lt;code&gt;focus&lt;/code&gt; 속성이 설정 되어 있으면 포커스 범위를 설정하지 않은 경우와 마찬가지로 &lt;code&gt;focus&lt;/code&gt; 를 설정하는 마지막 유형에 포커스 가 있고 나머지 유형 은 설정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="76b9b2e562bfe536134a9bb89d912ba8baa46477" translate="yes" xml:space="preserve">
          <source>Within the</source>
          <target state="translated">내</target>
        </trans-unit>
        <trans-unit id="cf2f4d425769454a3db62a8d6ae5b0475b3cf387" translate="yes" xml:space="preserve">
          <source>Within the FrameGraph tree, multiple &lt;a href=&quot;qml-qt3d-render-layerfilter&quot;&gt;LayerFilter&lt;/a&gt; nodes can be nested within a branch going from root to a leaf. In that case the filtering will first operate on all entities of the scene using the filtering method specified by the first declared &lt;a href=&quot;qml-qt3d-render-layerfilter&quot;&gt;LayerFilter&lt;/a&gt;. Then the filtered subset of entities will be filtered again based on the filtering method set on the second &lt;a href=&quot;qml-qt3d-render-layerfilter&quot;&gt;LayerFilter&lt;/a&gt; declared. This is then repeated until all &lt;a href=&quot;qml-qt3d-render-layerfilter&quot;&gt;LayerFilter&lt;/a&gt; nodes of the branch have been consumed.</source>
          <target state="translated">FrameGraph 트리 내에서 여러 &lt;a href=&quot;qml-qt3d-render-layerfilter&quot;&gt;LayerFilter&lt;/a&gt; 노드는 루트에서 리프로가는 분기 내에 중첩 될 수 있습니다. 이 경우 필터링은 먼저 선언 된 첫 번째 &lt;a href=&quot;qml-qt3d-render-layerfilter&quot;&gt;LayerFilter에&lt;/a&gt; 의해 지정된 필터링 방법을 사용하여 장면의 모든 엔티티에서 작동합니다 . 그런 다음 필터링 된 엔터티 하위 집합은 선언 된 두 번째 &lt;a href=&quot;qml-qt3d-render-layerfilter&quot;&gt;LayerFilter&lt;/a&gt; 에 설정된 필터링 방법을 기반으로 다시 필터링됩니다 . 그런 다음 분기의 모든 &lt;a href=&quot;qml-qt3d-render-layerfilter&quot;&gt;LayerFilter&lt;/a&gt; 노드가 사용될 때까지 반복 됩니다.</target>
        </trans-unit>
        <trans-unit id="6378d4ed60ae4d1598adb9c8f65226d0f664a289" translate="yes" xml:space="preserve">
          <source>Within the FrameGraph tree, multiple &lt;a href=&quot;qt3drender-qlayerfilter&quot;&gt;QLayerFilter&lt;/a&gt; nodes can be nested within a branch going from root to a leaf. In that case the filtering will first operate on all entities of the scene using the filtering method specified by the first declared &lt;a href=&quot;qt3drender-qlayerfilter&quot;&gt;QLayerFilter&lt;/a&gt;. Then the filtered subset of entities will be filtered again based on the filtering method set on the second &lt;a href=&quot;qt3drender-qlayerfilter&quot;&gt;QLayerFilter&lt;/a&gt; declared. This is then repeated until all &lt;a href=&quot;qt3drender-qlayerfilter&quot;&gt;QLayerFilter&lt;/a&gt; nodes of the branch have been consumed.</source>
          <target state="translated">FrameGraph 트리 내에서 여러 &lt;a href=&quot;qt3drender-qlayerfilter&quot;&gt;QLayerFilter&lt;/a&gt; 노드는 루트에서 리프로가는 분기 내에 중첩 될 수 있습니다. 이 경우 필터링은 먼저 선언 된 &lt;a href=&quot;qt3drender-qlayerfilter&quot;&gt;QLayerFilter에&lt;/a&gt; 의해 지정된 필터링 방법을 사용하여 장면의 모든 엔티티에서 먼저 작동합니다 . 그런 다음 필터링 된 엔터티 하위 집합은 선언 된 두 번째 &lt;a href=&quot;qt3drender-qlayerfilter&quot;&gt;QLayerFilter&lt;/a&gt; 에 설정된 필터링 방법을 기반으로 다시 필터링됩니다 . 그런 다음 분기의 모든 &lt;a href=&quot;qt3drender-qlayerfilter&quot;&gt;QLayerFilter&lt;/a&gt; 노드가 소비 될 때까지 반복 됩니다.</target>
        </trans-unit>
        <trans-unit id="1655c0eb21a2e07ff5223d5d7a39472255fe5562" translate="yes" xml:space="preserve">
          <source>Within the implementation file the &lt;a href=&quot;qqmlndefrecord#Q_DECLARE_NDEFRECORD&quot;&gt;Q_DECLARE_NDEFRECORD&lt;/a&gt;() macro is expanded:</source>
          <target state="translated">구현 파일 내에서 &lt;a href=&quot;qqmlndefrecord#Q_DECLARE_NDEFRECORD&quot;&gt;Q_DECLARE_NDEFRECORD&lt;/a&gt; () 매크로가 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="8d3f618935511b0a4e3b6291004128f0039ca294" translate="yes" xml:space="preserve">
          <source>Within the resource browser, you can open existing resource files or create new ones. Click the &lt;b&gt;Edit Resources&lt;/b&gt; button</source>
          <target state="translated">리소스 브라우저 내에서 기존 리소스 파일을 열거 나 새 리소스 파일을 만들 수 있습니다. &lt;b&gt;자원 편집&lt;/b&gt; 버튼을 클릭하십시오</target>
        </trans-unit>
        <trans-unit id="7c0ff9bb6c4a4970594fa0fdf0f22196036ebd45" translate="yes" xml:space="preserve">
          <source>Without &lt;code&gt;qt.conf&lt;/code&gt;, the Qt libraries will use the hard-coded paths to look for plugins, translations, and so on. These paths may not exist on the target system, or they may not be accessible. Because of this, you may need &lt;code&gt;qt.conf&lt;/code&gt; to make the Qt libraries look elsewhere.</source>
          <target state="translated">&lt;code&gt;qt.conf&lt;/code&gt; 가 없으면 Qt 라이브러리는 하드 코딩 된 경로를 사용하여 플러그인, 번역 등을 찾습니다. 이러한 경로는 대상 시스템에 존재하지 않거나 액세스 할 수 없습니다. 이 때문에 Qt 라이브러리를 다른 곳으로 보이게 하려면 &lt;code&gt;qt.conf&lt;/code&gt; 가 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ee6616a467cabc3f56d67dc3644d1c21d753d74" translate="yes" xml:space="preserve">
          <source>Without Frameworks:</source>
          <target state="translated">프레임 워크없이 :</target>
        </trans-unit>
        <trans-unit id="16a9269ca9ad5aa0bde29b428a5e12b622744b92" translate="yes" xml:space="preserve">
          <source>Without Qt XML Patterns, there is no simple way to solve this kind of problem. You might do it by writing a C++ program to traverse the file system, sniff out all the XML files, and submit each one to an XML parser to test that it contains valid XML. The C++ code required to write that program will probably be more complex than the C++ code required to subclass &lt;a href=&quot;qabstractxmlnodemodel&quot;&gt;QAbstractXmlNodeModel&lt;/a&gt;, but even if the two are comparable, your custom C++ program can be used only for that one task, while your custom XML node model can be used by any &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt; that must navigate the file system.</source>
          <target state="translated">Qt XML 패턴 없이는 이런 종류의 문제를 해결할 수있는 간단한 방법이 없습니다. C ++ 프로그램을 작성하여 파일 시스템을 탐색하고 모든 XML 파일을 스니핑하고 각 파일을 XML 파서에 제출하여 유효한 XML을 포함하는지 테스트 할 수 있습니다. 해당 프로그램을 작성하는 데 필요한 C ++ 코드는 &lt;a href=&quot;qabstractxmlnodemodel&quot;&gt;QAbstractXmlNodeModel&lt;/a&gt; 하위 클래스 화하는 데 필요한 C ++ 코드보다 더 복잡 할 수 있지만 둘이 비슷하더라도 사용자 지정 C ++ 프로그램은 해당 하나의 작업에만 사용할 수 있지만 사용자 지정 XML 노드 모델은 파일 시스템을 탐색해야하는 &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery에서&lt;/a&gt; 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="906a78d63fe98ad9fae7ceb3b7edb990374fbacd" translate="yes" xml:space="preserve">
          <source>Without Qt XML Patterns, there is no simple way to solve this kind of problem. You might do it by writing a C++ program to traverse the file system, sniff out all the XML files, and submit each one to an XML parser to test that it contains valid XML. The C++ code required to write that program will probably be more complex than the C++ code required to subclass &lt;a href=&quot;qabstractxmlnodemodel&quot;&gt;QAbstractXmlNodeModel&lt;/a&gt;, but even if the two are comparable, your custom C++ program can be used only for that one task, while your custom XML node model can be used by any XQuery that must navigate the file system.</source>
          <target state="translated">Qt XML 패턴이 없으면 이런 종류의 문제를 해결할 수있는 간단한 방법이 없습니다. 파일 시스템을 탐색하고 모든 XML 파일을 스니핑하고 각 파일을 XML 파서에 제출하여 유효한 XML이 포함되어 있는지 테스트하기 위해 C ++ 프로그램을 작성하여이를 수행 할 수 있습니다. 해당 프로그램을 작성하는 데 필요한 C ++ 코드는 아마도 &lt;a href=&quot;qabstractxmlnodemodel&quot;&gt;QAbstractXmlNodeModel&lt;/a&gt; 을 서브 클래스 화하는 데 필요한 C ++ 코드보다 더 복잡 할 수 있지만 두 개가 비교 가능하더라도 사용자 정의 C ++ 프로그램은 해당 한 작업에만 사용할 수 있지만 사용자 정의 XML 노드 모델은 파일 시스템을 탐색해야하는 모든 XQuery에서 사용합니다.</target>
        </trans-unit>
        <trans-unit id="fe06ce141a1168cf6c190a0812c8b6234dbf41b7" translate="yes" xml:space="preserve">
          <source>Without a</source>
          <target state="translated">없이</target>
        </trans-unit>
        <trans-unit id="e5fdab5262fd255a415115b28b6a0fa6a113884d" translate="yes" xml:space="preserve">
          <source>Without a suffix, Android 5 (API 21) will load the system libraries</source>
          <target state="translated">접미사가 없으면 Android 5 (API 21)는 시스템 라이브러리를로드합니다.</target>
        </trans-unit>
        <trans-unit id="93ba514d88ce37a6cb5e299bbd770c963f3f1977" translate="yes" xml:space="preserve">
          <source>Without any caching, performance may drop significantly.</source>
          <target state="translated">캐싱이 없으면 성능이 크게 떨어질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a883ba767e83883b1cf0350c4946504e817ac21" translate="yes" xml:space="preserve">
          <source>Without any lights and disabling light-related shading for the two meshes, we get the following:</source>
          <target state="translated">조명없이 두 메시에 대한 조명 관련 음영 처리를 비활성화하면 다음과 같은 결과를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="43f455544383fd6a5e1f4485e57cf34557ce7ae9" translate="yes" xml:space="preserve">
          <source>Without further delay, we present the widget walkthrough; each widget has its own sub-section.</source>
          <target state="translated">추가 지연없이 위젯 연습을 제공합니다. 각 위젯에는 자체 하위 섹션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="50655f37469a7bfe19c443ecfe5a49e929d9b820" translate="yes" xml:space="preserve">
          <source>Without the call to &lt;code&gt;isPolishScheduled()&lt;/code&gt; above, the call to &lt;code&gt;waitForItemPolished()&lt;/code&gt; might see that no polish was scheduled and therefore pass instantly, assuming that the item had already been polished. This function makes it obvious why an item wasn't polished and allows tests to fail early under such circumstances.</source>
          <target state="translated">위의 &lt;code&gt;isPolishScheduled()&lt;/code&gt; 호출하지 않으면 &lt;code&gt;waitForItemPolished()&lt;/code&gt; 호출하면 폴리싱이 예약되지 않았으므로 항목이 이미 폴리싱되었다고 가정하면 즉시 전달됩니다. 이 기능을 사용하면 왜 제품이 연마되지 않았는지 명확하게 알 수 있으며 이러한 상황에서 테스트가 일찍 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f06ecaacf74a50b9553cf59bf5d4e2830ceb1666" translate="yes" xml:space="preserve">
          <source>Without the call to &lt;code&gt;qIsPolishScheduled()&lt;/code&gt; above, the call to &lt;code&gt;qWaitForItemPolished()&lt;/code&gt; might see that no polish was scheduled and therefore pass instantly, assuming that the item had already been polished. This function makes it obvious why an item wasn't polished and allows tests to fail early under such circumstances.</source>
          <target state="translated">호출없이 &lt;code&gt;qIsPolishScheduled()&lt;/code&gt; 위의 호출 &lt;code&gt;qWaitForItemPolished()&lt;/code&gt; 더 폴란드어를 예약하지 따라서 항목이 이미 연마되었다고 가정하고, 즉시 통과 된 것을 볼 수 있습니다. 이 기능을 사용하면 왜 제품이 연마되지 않았는지 명확하게 알 수 있으며 이러한 상황에서 테스트가 일찍 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0824512bccf109ba84fe616af5c0dcdf35ac9ca8" translate="yes" xml:space="preserve">
          <source>Without the guidance in the</source>
          <target state="translated">지침없이</target>
        </trans-unit>
        <trans-unit id="4c0a02a4fd557e1f5547ba09fc6d37a119fe72d1" translate="yes" xml:space="preserve">
          <source>Without this, a generic &quot;Game is not a type&quot; message would be given.</source>
          <target state="translated">이것이 없으면 일반적인 &quot;Game is a type&quot;메시지가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="3193c510cba9467bc667c00acf704c64431c62ee" translate="yes" xml:space="preserve">
          <source>Wizard Look and Feel</source>
          <target state="translated">마법사 모양과 느낌</target>
        </trans-unit>
        <trans-unit id="5dcef5ebea03ffa0dd22c9949dde2011e5628e41" translate="yes" xml:space="preserve">
          <source>Wizards consist of a sequence of &lt;a href=&quot;qwizardpage&quot;&gt;QWizardPage&lt;/a&gt;s. At any time, only one page is shown. A page has the following attributes:</source>
          <target state="translated">마법사는 일련의 &lt;a href=&quot;qwizardpage&quot;&gt;QWizardPage&lt;/a&gt; 로 구성됩니다 . 언제든지 하나의 페이지 만 표시됩니다. 페이지에는 다음과 같은 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b6261b0f092158c08397020cfc1dbbc29f7e922b" translate="yes" xml:space="preserve">
          <source>WlScaler (QML type)</source>
          <target state="translated">WlScaler (QML 유형)</target>
        </trans-unit>
        <trans-unit id="b57bdbc1f007e6605e0c904fc272441772cf025c" translate="yes" xml:space="preserve">
          <source>WlScaler QML Type</source>
          <target state="translated">WlScaler QML 유형</target>
        </trans-unit>
        <trans-unit id="4ade3073a2b210ce8e9ac7f018f59f6299ff87f5" translate="yes" xml:space="preserve">
          <source>WlScaler corresponds to the Wayland interface, &lt;code&gt;wl_scaler&lt;/code&gt;.</source>
          <target state="translated">WAYLAND 인터페이스 WlScaler 대응하고, &lt;code&gt;wl_scaler&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="07b36481f2d528b274ee4ef8ded9960891eb760e" translate="yes" xml:space="preserve">
          <source>WlShell (QML type)</source>
          <target state="translated">WlShell (QML 유형)</target>
        </trans-unit>
        <trans-unit id="b6668b0bfe96f711b449cdfda3749bc2ecf51c24" translate="yes" xml:space="preserve">
          <source>WlShell QML Type</source>
          <target state="translated">WlShell QML 유형</target>
        </trans-unit>
        <trans-unit id="5caabff4047fc9e0ec581112e9d4a83acffca4f9" translate="yes" xml:space="preserve">
          <source>WlShell corresponds to the Wayland interface &lt;code&gt;wl_shell&lt;/code&gt;.</source>
          <target state="translated">WlShell는 WAYLAND 인터페이스에 대응 &lt;code&gt;wl_shell&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="42fc3ffb9c689fcc91fe318023d6cbe1e725cf51" translate="yes" xml:space="preserve">
          <source>WlShell.wlShellSurfaceCreated()</source>
          <target state="translated">WlShell.wlShellSurfaceCreated()</target>
        </trans-unit>
        <trans-unit id="ef822dc8547db076895749545273aa5a0d42d135" translate="yes" xml:space="preserve">
          <source>WlShell.wlShellSurfaceRequested()</source>
          <target state="translated">WlShell.wlShellSurfaceRequested()</target>
        </trans-unit>
        <trans-unit id="d2bfbfbbad3de59d0a961294644a89b410ef6d5a" translate="yes" xml:space="preserve">
          <source>WlShellSurface (QML type)</source>
          <target state="translated">WlShellSurface (QML 유형)</target>
        </trans-unit>
        <trans-unit id="e110dc4896fac279d93e7506893b457acc985adf" translate="yes" xml:space="preserve">
          <source>WlShellSurface QML Type</source>
          <target state="translated">WlShellSurface QML 유형</target>
        </trans-unit>
        <trans-unit id="48fcc081e064624479ecf0c1711d6fc48798ea77" translate="yes" xml:space="preserve">
          <source>WlShellSurface.className</source>
          <target state="translated">WlShellSurface.className</target>
        </trans-unit>
        <trans-unit id="2cef914ef3792ac59c00673fa463e6e279d0e5b1" translate="yes" xml:space="preserve">
          <source>WlShellSurface.initialize()</source>
          <target state="translated">WlShellSurface.initialize()</target>
        </trans-unit>
        <trans-unit id="1b6436e9c64dc8f3894eab1f20a93739c4e013c3" translate="yes" xml:space="preserve">
          <source>WlShellSurface.ping()</source>
          <target state="translated">WlShellSurface.ping()</target>
        </trans-unit>
        <trans-unit id="c1709f39c1328b38a0fd7548d86419ecc18e9844" translate="yes" xml:space="preserve">
          <source>WlShellSurface.sendConfigure()</source>
          <target state="translated">WlShellSurface.sendConfigure()</target>
        </trans-unit>
        <trans-unit id="ab0fe1c58fc6f74a085ce2f12576d1f032c82596" translate="yes" xml:space="preserve">
          <source>WlShellSurface.sendPopupDone()</source>
          <target state="translated">WlShellSurface.sendPopupDone()</target>
        </trans-unit>
        <trans-unit id="b7bf42c1307ac8700aebf1d11228f62d6a8f17fa" translate="yes" xml:space="preserve">
          <source>WlShellSurface.shell</source>
          <target state="translated">WlShellSurface.shell</target>
        </trans-unit>
        <trans-unit id="34313321892b7c04f1ccc13b6583e7b5f23187d5" translate="yes" xml:space="preserve">
          <source>WlShellSurface.surface</source>
          <target state="translated">WlShellSurface.surface</target>
        </trans-unit>
        <trans-unit id="d03be9356817ff47117f41e9d0285382e1f5fc71" translate="yes" xml:space="preserve">
          <source>WlShellSurface.title</source>
          <target state="translated">WlShellSurface.title</target>
        </trans-unit>
        <trans-unit id="bb56f0ba00293a640d27fdf80aaa35bf820d35f8" translate="yes" xml:space="preserve">
          <source>WlShellSurface.windowType</source>
          <target state="translated">WlShellSurface.windowType</target>
        </trans-unit>
        <trans-unit id="8ed9a26e1e0bd86a5734f7dbf8a8b38ec310f539" translate="yes" xml:space="preserve">
          <source>Word boundaries are there to locate the start and end of what a language considers to be a word (see &lt;a href=&quot;http://www.unicode.org/reports/tr29/#Word_Boundaries&quot;&gt;http://www.unicode.org/reports/tr29/#Word_Boundaries&lt;/a&gt;).</source>
          <target state="translated">단어 경계는 언어가 단어로 간주하는 것의 시작과 끝을 찾을 수있는 곳입니다 ( &lt;a href=&quot;http://www.unicode.org/reports/tr29/#Word_Boundaries&quot;&gt;http://www.unicode.org/reports/tr29/#Word_Boundaries 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="bb253144836dfa990bb98ead2d4aef93472eac9f" translate="yes" xml:space="preserve">
          <source>Word by word. &lt;a href=&quot;qtextstream&quot;&gt;QTextStream&lt;/a&gt; supports streaming into &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;s, &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt;s and char* buffers. Words are delimited by space, and leading white space is automatically skipped.</source>
          <target state="translated">단어 단어별로. &lt;a href=&quot;qtextstream&quot;&gt;QTextStream&lt;/a&gt; 은 &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; , &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; 및 char * 버퍼로의 스트리밍을 지원합니다 . 단어는 공백으로 구분되며 선행 공백은 자동으로 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="108a2f7ed609797b46cbd1ba460aa2c7ecb91509" translate="yes" xml:space="preserve">
          <source>Word by word. QTextStream supports streaming into &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;s, &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt;s and char* buffers. Words are delimited by space, and leading white space is automatically skipped.</source>
          <target state="translated">단어 단어별로. QTextStream은 &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; , &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; 및 char * 버퍼로의 스트리밍을 지원합니다 . 단어는 공백으로 구분되며 선행 공백은 자동으로 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="b40db3a882cfd89240242a70c035356550f54ada" translate="yes" xml:space="preserve">
          <source>Word size</source>
          <target state="translated">단어 크기</target>
        </trans-unit>
        <trans-unit id="536af22c45db1729570f13631c85a76152e074f4" translate="yes" xml:space="preserve">
          <source>Word spacing changes the default spacing between individual words. A positive value increases the word spacing by a corresponding amount of pixels, while a negative value decreases the inter-word spacing accordingly.</source>
          <target state="translated">단어 간격은 개별 단어 사이의 기본 간격을 변경합니다. 양수 값은 해당 간격의 픽셀만큼 단어 간격을 늘리고 음수 값은 그에 따라 단어 간 간격을 줄입니다.</target>
        </trans-unit>
        <trans-unit id="0069fab6f922d3e5cfb6199f7e1104d8cce60a16" translate="yes" xml:space="preserve">
          <source>Word spacing will not apply to writing systems, where indiviaul words are not separated by white space.</source>
          <target state="translated">단어 간격은 개별 단어가 공백으로 분리되지 않은 쓰기 시스템에는 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9b187a2614280ba9450d25073626d8391af19bcc" translate="yes" xml:space="preserve">
          <source>Worked Example</source>
          <target state="translated">작동 예</target>
        </trans-unit>
        <trans-unit id="ca1e06ded6779c45d8ce0e1785ae4b86657174de" translate="yes" xml:space="preserve">
          <source>Worker scripts that are plain JavaScript sources can not use &lt;a href=&quot;qtqml-javascript-imports&quot;&gt;.import&lt;/a&gt; syntax. Scripts that are ECMAScript modules can freely use import and export statements.</source>
          <target state="translated">일반 JavaScript 소스 인 작업자 스크립트는 &lt;a href=&quot;qtqml-javascript-imports&quot;&gt;.import&lt;/a&gt; 구문을 사용할 수 없습니다 . ECMAScript 모듈 인 스크립트는 import 및 export 문을 자유롭게 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e0eaa4ff41e676dd00c44372e1378b130957c0e" translate="yes" xml:space="preserve">
          <source>Worker scripts that are plain JavaScript sources can not use &lt;a href=&quot;qtqml-javascript-imports#&quot;&gt;.import&lt;/a&gt; syntax. Scripts that are ECMAScript modules can freely use import and export statements.</source>
          <target state="translated">일반 JavaScript 소스 인 작업자 스크립트는 &lt;a href=&quot;qtqml-javascript-imports#&quot;&gt;.import&lt;/a&gt; 구문을 사용할 수 없습니다 . ECMAScript 모듈 인 스크립트는 가져 오기 및 내보내기 문을 자유롭게 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a530934fe64bcc0a2fbc6b2eb19c8eee6434afd" translate="yes" xml:space="preserve">
          <source>WorkerScript</source>
          <target state="translated">WorkerScript</target>
        </trans-unit>
        <trans-unit id="fd088565fbfdd1fad6509f6f419e889c510a50a2" translate="yes" xml:space="preserve">
          <source>WorkerScript (QML type)</source>
          <target state="translated">WorkerScript (QML 유형)</target>
        </trans-unit>
        <trans-unit id="60aef30910707ab83bafa6a514cd2497880e4524" translate="yes" xml:space="preserve">
          <source>WorkerScript QML Type</source>
          <target state="translated">WorkerScript QML 유형</target>
        </trans-unit>
        <trans-unit id="abeebdfcd68a08212df1b2cd21546924ca0c33b3" translate="yes" xml:space="preserve">
          <source>WorkerScript.message()</source>
          <target state="translated">WorkerScript.message()</target>
        </trans-unit>
        <trans-unit id="d834c787e237a5d767a1e6e24914292b2c010582" translate="yes" xml:space="preserve">
          <source>WorkerScript.ready</source>
          <target state="translated">WorkerScript.ready</target>
        </trans-unit>
        <trans-unit id="ee6d6c2a7ca12046ee14ce7daff0c490de29eaa7" translate="yes" xml:space="preserve">
          <source>WorkerScript.sendMessage()</source>
          <target state="translated">WorkerScript.sendMessage()</target>
        </trans-unit>
        <trans-unit id="8ae9f004765542d8e99218e39c3301c815ffc5c5" translate="yes" xml:space="preserve">
          <source>WorkerScript.source</source>
          <target state="translated">WorkerScript.source</target>
        </trans-unit>
        <trans-unit id="742a795cfcef09d5fca0078214b531040466c57e" translate="yes" xml:space="preserve">
          <source>WorkerScript: Threading in QML</source>
          <target state="translated">WorkerScript : QML의 스레딩</target>
        </trans-unit>
        <trans-unit id="c016b2ba62db10eb134f62dc27e219f5ec415800" translate="yes" xml:space="preserve">
          <source>Working With Arrays</source>
          <target state="translated">배열 작업</target>
        </trans-unit>
        <trans-unit id="3e0156058f2d58d9828ee6710bcfff111dd0fae5" translate="yes" xml:space="preserve">
          <source>Working with existing Metal devices</source>
          <target state="translated">기존 금속 장치로 작업</target>
        </trans-unit>
        <trans-unit id="e3179360576d4f619d5134d86c6b5cd815bbfd34" translate="yes" xml:space="preserve">
          <source>Working with the DOM Tree</source>
          <target state="translated">DOM 트리 작업</target>
        </trans-unit>
        <trans-unit id="621c48ea175f57750086ad2674043c3857f9d3bf" translate="yes" xml:space="preserve">
          <source>Works on the given</source>
          <target state="translated">주어진 작품</target>
        </trans-unit>
        <trans-unit id="43a2a212ef9e306f1227d6c262fe7cb1e66e61fc" translate="yes" xml:space="preserve">
          <source>Works with moving images.</source>
          <target state="translated">움직이는 이미지와 함께 작동합니다.</target>
        </trans-unit>
        <trans-unit id="9aac26a929704d6521e46edde532ac2f089520c5" translate="yes" xml:space="preserve">
          <source>World normal vector</source>
          <target state="translated">세계 법선 벡터</target>
        </trans-unit>
        <trans-unit id="39283cfe47115a1783c04e50be8df740ad417973" translate="yes" xml:space="preserve">
          <source>World position vector</source>
          <target state="translated">세계 위치 벡터</target>
        </trans-unit>
        <trans-unit id="30292f5fea8a2145e412ec1542b2e1882d60b1db" translate="yes" xml:space="preserve">
          <source>Worst case</source>
          <target state="translated">최악의 경우</target>
        </trans-unit>
        <trans-unit id="a2bc9fcb013ef5ff52c6e0f302f433182054d0f1" translate="yes" xml:space="preserve">
          <source>Wrap the coordinate at the edges, but mirror the texture when tiling it.</source>
          <target state="translated">가장자리에서 좌표를 감싸지 만 타일링 할 때 텍스처를 미러링합니다.</target>
        </trans-unit>
        <trans-unit id="3932d9662b08569bc16f913c6cab600855beec2c" translate="yes" xml:space="preserve">
          <source>Wrap the coordinates at the edges to tile the texture.</source>
          <target state="translated">텍스처를 바둑판 식으로 배열하기 위해 가장자리에서 좌표를 감 쌉니다.</target>
        </trans-unit>
        <trans-unit id="4dd381ce6f1f7eec38158291208afc54d5c3e2c9" translate="yes" xml:space="preserve">
          <source>WrappedEvent Class</source>
          <target state="translated">WrappedEvent 클래스</target>
        </trans-unit>
        <trans-unit id="f7eaaeed34595d2de20d364a6b354ea80424d306" translate="yes" xml:space="preserve">
          <source>Wrapper Example (ActiveQt)</source>
          <target state="translated">래퍼 예 (ActiveQt)</target>
        </trans-unit>
        <trans-unit id="6fe8f9d6986840fa95d881f4a793e9f8f307cbce" translate="yes" xml:space="preserve">
          <source>Wrapping Functions that Take Multiple Arguments</source>
          <target state="translated">여러 인수를 취하는 랩핑 함수</target>
        </trans-unit>
        <trans-unit id="11877c34b11d19f8fca7be1d44c3a4274a08bac4" translate="yes" xml:space="preserve">
          <source>Wrapping other objects for the purpose of grouping them into components or sub-trees can be a convenient way to, for example, animated a group of nodes as a whole. This snippet shows how to use Node to animate a camera:</source>
          <target state="translated">다른 개체를 구성 요소 또는 하위 트리로 그룹화 할 목적으로 래핑하면 노드 그룹 전체를 애니메이션하는 편리한 방법이 될 수 있습니다. 이 스 니펫은 Node를 사용하여 카메라를 애니메이션하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="f660e7dcc715c259e3109185ed53b33ce2986532" translate="yes" xml:space="preserve">
          <source>Wraps Android positioning subsystem. Available only on Android.</source>
          <target state="translated">Android 위치 지정 하위 시스템을 래핑합니다. Android에서만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="18e1f8eef927d790db4197d551e90201eebb292f" translate="yes" xml:space="preserve">
          <source>Wraps WinRT positioning subsystem. Available only on WinRT and Windows10.</source>
          <target state="translated">WinRT 위치 지정 하위 시스템을 래핑합니다. WinRT 및 Windows10에서만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="38931fb06cd5db1a403cd002c454f6ea82391f8f" translate="yes" xml:space="preserve">
          <source>Wraps a sequence of OpenGL timer query objects</source>
          <target state="translated">일련의 OpenGL 타이머 쿼리 객체를 래핑합니다.</target>
        </trans-unit>
        <trans-unit id="18c2cbec6a0515b86f70bcf27bf4340409ef4863" translate="yes" xml:space="preserve">
          <source>Wraps an OpenGL Vertex Array Object</source>
          <target state="translated">OpenGL 정점 배열 객체 감싸기</target>
        </trans-unit>
        <trans-unit id="15a4a67a605d671d3c9e35eeee30225ef4cb4999" translate="yes" xml:space="preserve">
          <source>Wraps an OpenGL debug message</source>
          <target state="translated">OpenGL 디버그 메시지를 래핑합니다</target>
        </trans-unit>
        <trans-unit id="1a08856ef68ab0ac7fc717cf91ad30fbae25ec50" translate="yes" xml:space="preserve">
          <source>Wraps an OpenGL timer query object</source>
          <target state="translated">OpenGL 타이머 쿼리 객체를 래핑합니다</target>
        </trans-unit>
        <trans-unit id="c3fa0a57fa01c69420d61446a0eae2bbe84b4823" translate="yes" xml:space="preserve">
          <source>Wraps iOS and macOS positioning subsystems. Available only on Apple platforms supporting corelocation.</source>
          <target state="translated">iOS 및 macOS 위치 지정 하위 시스템을 래핑합니다. corelocation을 지원하는 Apple 플랫폼에서만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b20d8fb713c2bebd0f6fd23a09cb0ecf5e285d04" translate="yes" xml:space="preserve">
          <source>Wraps the</source>
          <target state="translated">랩</target>
        </trans-unit>
        <trans-unit id="316c0260a54a729b9a181fe2930ff1cbbd23aa03" translate="yes" xml:space="preserve">
          <source>Wraps the most important methods of Android Binder class. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">Android Binder 클래스의 가장 중요한 메서드를 래핑합니다. &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0f133d61508d26cd1934d08b12ed271c2b34f0c4" translate="yes" xml:space="preserve">
          <source>Wraps the most important methods of Android Intent class. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">Android Intent 클래스의 가장 중요한 메서드를 래핑합니다. &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ef7db36344598f7fcfcaf4fcd608818bf78f774c" translate="yes" xml:space="preserve">
          <source>Wraps the most important methods of Android Parcel class. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">Android Parcel 클래스의 가장 중요한 메서드를 래핑합니다. &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c608727db8e0e2802553a6ae57ea9fbb5560b6f8" translate="yes" xml:space="preserve">
          <source>Wraps the most important methods of Android Service class. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">Android 서비스 클래스의 가장 중요한 메서드를 래핑합니다. &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="45853dd0221668b8d47fd021076903fefc7f1019" translate="yes" xml:space="preserve">
          <source>Wraps the most important methods of Android ServiceConnection class. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">Android ServiceConnection 클래스의 가장 중요한 메서드를 래핑합니다. &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9cacfd6c2f56b1eb4a8993bf9bd456057d52e65f" translate="yes" xml:space="preserve">
          <source>Wraps the provided</source>
          <target state="translated">제공된 랩</target>
        </trans-unit>
        <trans-unit id="794b3c2fc0395934b72694e2ebb596cae40240be" translate="yes" xml:space="preserve">
          <source>Wraps the signed 64-bit integer</source>
          <target state="translated">부호있는 64 비트 정수를 감 쌉니다.</target>
        </trans-unit>
        <trans-unit id="72b7b9a4d5c7c2785fa3b6a073dee1962e436c2c" translate="yes" xml:space="preserve">
          <source>Wraps the unsigned 64-bit integer</source>
          <target state="translated">부호없는 64 비트 정수를 래핑합니다.</target>
        </trans-unit>
        <trans-unit id="27fd4473f892a9f8d28e8b368d4e7e3d38f05604" translate="yes" xml:space="preserve">
          <source>Write Self-contained Test Functions</source>
          <target state="translated">자체 포함 된 테스트 함수 작성</target>
        </trans-unit>
        <trans-unit id="b770bb53de054c2fe2b31d8da9f2a75e4f0159e4" translate="yes" xml:space="preserve">
          <source>Write Well-structured Diagnostic Code</source>
          <target state="translated">체계적인 진단 코드 작성</target>
        </trans-unit>
        <trans-unit id="b5f7b07f82467c99774abc79b879a0c8fe819e1e" translate="yes" xml:space="preserve">
          <source>Write a depfile with the .qrc dependencies to &amp;lt;file&amp;gt;.</source>
          <target state="translated">.qrc 종속성이있는 depfile을 &amp;lt;file&amp;gt;에 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="ab2726a3cc1f75c60b0eea1512f91412b9226ed7" translate="yes" xml:space="preserve">
          <source>Write a project file for the plugin</source>
          <target state="translated">플러그인 용 프로젝트 파일 작성</target>
        </trans-unit>
        <trans-unit id="11b5efa2d5a13568411e209f84157514c044e66b" translate="yes" xml:space="preserve">
          <source>Write a project file for the plugin. Add:</source>
          <target state="translated">플러그인 용 프로젝트 파일을 작성합니다. 더하다:</target>
        </trans-unit>
        <trans-unit id="a881b178da5b074e2d889eab1b001d181e29fbda" translate="yes" xml:space="preserve">
          <source>Write a test and fix the bug.</source>
          <target state="translated">테스트를 작성하고 버그를 수정합니다.</target>
        </trans-unit>
        <trans-unit id="94435f8e44b2a5ffbbe9a1a051a7fa8d40a1b104" translate="yes" xml:space="preserve">
          <source>Write access</source>
          <target state="translated">쓰기 권한</target>
        </trans-unit>
        <trans-unit id="f1bb131eaccae0c046736420225d1656db426322" translate="yes" xml:space="preserve">
          <source>Write and commit your tests along with your fix or new feature on a new branch. Once you're done, you can check out the branch on which your work is based, and then check out into this branch the test-files for your new tests. This enables you to verify that the tests do fail on the prior branch, and therefore actually do catch a bug or test a new feature.</source>
          <target state="translated">새 브랜치에서 수정 사항 또는 새 기능과 함께 테스트를 작성하고 커밋합니다. 완료되면 작업의 기반이되는 브랜치를 확인한 다음 새 테스트를위한 테스트 파일을이 브랜치에서 확인할 수 있습니다. 이를 통해 테스트가 이전 분기에서 실패했는지 확인할 수 있으므로 실제로 버그를 포착하거나 새로운 기능을 테스트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="47bea6187853239b43a7df6e6565f510705cc425" translate="yes" xml:space="preserve">
          <source>Write notifiers should normally be disabled immediately after the &lt;a href=&quot;qsocketnotifier#activated&quot;&gt;activated&lt;/a&gt;() signal has been emitted</source>
          <target state="translated">쓰기 알림은 일반적으로 &lt;a href=&quot;qsocketnotifier#activated&quot;&gt;활성화 된&lt;/a&gt; () 신호가 방출 된 직후 비활성화되어야합니다.</target>
        </trans-unit>
        <trans-unit id="196da289028b4498c4230c282ac726baee2c7c18" translate="yes" xml:space="preserve">
          <source>Write output to &lt;code&gt;&amp;lt;file&amp;gt;&lt;/code&gt; instead of to standard output.</source>
          <target state="translated">출력을 표준 출력 대신 &lt;code&gt;&amp;lt;file&amp;gt;&lt;/code&gt; 에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="1677c9974625fb733a6e7d18d261c338123d2eb9" translate="yes" xml:space="preserve">
          <source>Write output to &lt;code&gt;&amp;lt;file&amp;gt;&lt;/code&gt; rather than to standard output.</source>
          <target state="translated">출력을 표준 출력이 아닌 &lt;code&gt;&amp;lt;file&amp;gt;&lt;/code&gt; 에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="4380a30052d4a8f446c61d3532f27cb3d17c499a" translate="yes" xml:space="preserve">
          <source>Write output to &lt;code&gt;file&lt;/code&gt; rather than to stdout.</source>
          <target state="translated">표준 출력이 아닌 &lt;code&gt;file&lt;/code&gt; 출력을 씁니다 .</target>
        </trans-unit>
        <trans-unit id="a0516381df102bdc8fd4d44567b9570494009851" translate="yes" xml:space="preserve">
          <source>Write the infinite loop directly within a reimplementation of &lt;a href=&quot;qthread#run&quot;&gt;QThread::run&lt;/a&gt;(). Start the thread without an event loop. Let the thread emit signals to send data back to the GUI thread.</source>
          <target state="translated">&lt;a href=&quot;qthread#run&quot;&gt;QThread :: run&lt;/a&gt; ()을 다시 구현하여 무한 루프를 직접 작성하십시오 . 이벤트 루프없이 스레드를 시작하십시오. 스레드가 GUI 스레드로 데이터를 다시 보내도록 신호를 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="ef2fd1bfd74950a812a75e4a180064e84381952f" translate="yes" xml:space="preserve">
          <source>Write-functions for properties and other methods exposed by the object's IDispatch implementation can be called directly using &lt;a href=&quot;qaxbase#dynamicCall&quot;&gt;dynamicCall&lt;/a&gt;(), or indirectly as slots connected to a signal.</source>
          <target state="translated">객체의 IDispatch 구현에 의해 노출되는 속성 및 기타 메서드에 대한 쓰기 함수는 &lt;a href=&quot;qaxbase#dynamicCall&quot;&gt;dynamicCall&lt;/a&gt; ()을 사용하여 직접 또는 신호에 연결된 슬롯으로 간접적으로 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d35b6b65f165e1877f26c4e06cd3a5c64880f4a5" translate="yes" xml:space="preserve">
          <source>Write-only access.</source>
          <target state="translated">쓰기 전용 액세스.</target>
        </trans-unit>
        <trans-unit id="5f435830a7c07f19c4072a88821b38028c3f69e6" translate="yes" xml:space="preserve">
          <source>Writer</source>
          <target state="translated">Writer</target>
        </trans-unit>
        <trans-unit id="9b1ff2c96b99a1589923943cfd2a6cdcf1069090" translate="yes" xml:space="preserve">
          <source>Writes</source>
          <target state="translated">Writes</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
