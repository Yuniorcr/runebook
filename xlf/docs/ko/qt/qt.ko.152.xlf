<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="qt">
    <body>
      <group id="qt">
        <trans-unit id="eef19c54306daa69eda49c0272623bdb5e2b341f" translate="yes" xml:space="preserve">
          <source>NULL</source>
          <target state="translated">NULL</target>
        </trans-unit>
        <trans-unit id="325bf120e084b0cc411c72d5c2c974922f49cf5a" translate="yes" xml:space="preserve">
          <source>NULL value.</source>
          <target state="translated">NULL 값</target>
        </trans-unit>
        <trans-unit id="6c2496a022b02739f43ed430676315b0c3b34a08" translate="yes" xml:space="preserve">
          <source>NUMBER</source>
          <target state="translated">NUMBER</target>
        </trans-unit>
        <trans-unit id="ee7b754b390c5f5fa8ce1eb2937f01f02ff7588a" translate="yes" xml:space="preserve">
          <source>NUMBER(38)</source>
          <target state="translated">NUMBER(38)</target>
        </trans-unit>
        <trans-unit id="38a4d65861b01e13076452f5061bb43c6731bce6" translate="yes" xml:space="preserve">
          <source>NUMBER(p,s)</source>
          <target state="translated">NUMBER(p,s)</target>
        </trans-unit>
        <trans-unit id="bb06bce23e692e66a4ca03b74bb9f27464d4bfe0" translate="yes" xml:space="preserve">
          <source>NUMERIC VARIABLE</source>
          <target state="translated">다양한 변수</target>
        </trans-unit>
        <trans-unit id="9ec4f164e39862996dbba6c5425ef1ab760d8533" translate="yes" xml:space="preserve">
          <source>NUMERIC(p,s) DECIMAL(p,s)a</source>
          <target state="translated">숫자 (p, s) DECIMAL (p, s) a</target>
        </trans-unit>
        <trans-unit id="9aa0419e649fcf6272502cf063161b40f272c661" translate="yes" xml:space="preserve">
          <source>NVARACHAR</source>
          <target state="translated">NVARACHAR</target>
        </trans-unit>
        <trans-unit id="386441bbe0e4d666cad40d5b30532b7ce8624468" translate="yes" xml:space="preserve">
          <source>NVARCHAR2(n)</source>
          <target state="translated">NVARCHAR2(n)</target>
        </trans-unit>
        <trans-unit id="e05a082f8199b6dd28b1cfbfeedce51101a92cc8" translate="yes" xml:space="preserve">
          <source>NVIDIA Tegra X1</source>
          <target state="translated">엔비디아 테그 라 X1</target>
        </trans-unit>
        <trans-unit id="f7fd9c68f804acda665d2ab082217bb1583318f2" translate="yes" xml:space="preserve">
          <source>NaN</source>
          <target state="translated">NaN</target>
        </trans-unit>
        <trans-unit id="709a23220f2c3d64d1e1d6d18c4d5280f8d82fca" translate="yes" xml:space="preserve">
          <source>Name</source>
          <target state="translated">Name</target>
        </trans-unit>
        <trans-unit id="40639a7c0287be0627cf2d814f3914417a2ca937" translate="yes" xml:space="preserve">
          <source>Name - sort by filename</source>
          <target state="translated">이름-파일 이름으로 정렬</target>
        </trans-unit>
        <trans-unit id="bec6ec4bfa802c8a15024d0abb8ce02ce54f0da3" translate="yes" xml:space="preserve">
          <source>Name Tests</source>
          <target state="translated">이름 테스트</target>
        </trans-unit>
        <trans-unit id="52d917a608e102b41d4f284c117e5574ff5d1238" translate="yes" xml:space="preserve">
          <source>Name filters are lists of strings that are passed to &lt;a href=&quot;qdir#setNameFilters&quot;&gt;setNameFilters&lt;/a&gt;(). Attribute filters consist of a bitwise OR combination of Filters, and these are specified when calling &lt;a href=&quot;qdir#setFilter&quot;&gt;setFilter&lt;/a&gt;(). The sort order is specified using &lt;a href=&quot;qdir#setSorting&quot;&gt;setSorting&lt;/a&gt;() with a bitwise OR combination of &lt;a href=&quot;qdir#SortFlag-enum&quot;&gt;SortFlags&lt;/a&gt;.</source>
          <target state="translated">이름 필터는 &lt;a href=&quot;qdir#setNameFilters&quot;&gt;setNameFilters&lt;/a&gt; ()에 전달되는 문자열 목록입니다 . 속성 필터는 비트 단위 OR 필터 조합으로 구성되며 &lt;a href=&quot;qdir#setFilter&quot;&gt;setFilter&lt;/a&gt; ()를 호출 할 때 지정됩니다 . 정렬 순서는 비트 단위 OR &lt;a href=&quot;qdir#SortFlag-enum&quot;&gt;SortFlags&lt;/a&gt; 조합과 함께 &lt;a href=&quot;qdir#setSorting&quot;&gt;setSorting&lt;/a&gt; ()을 사용하여 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="5987261ca8e29be6cfcebff9545d268bfcf4516b" translate="yes" xml:space="preserve">
          <source>Name format</source>
          <target state="translated">이름 형식</target>
        </trans-unit>
        <trans-unit id="ab4875e33670e6edb54996145876e392bf26c6df" translate="yes" xml:space="preserve">
          <source>Name of the Bluetooth service in the primary language.</source>
          <target state="translated">기본 언어의 Bluetooth 서비스 이름입니다.</target>
        </trans-unit>
        <trans-unit id="2bb1a116466a16cd90ca3dc58f1b0ac50946dcf9" translate="yes" xml:space="preserve">
          <source>Name of the company / entity that provides the Bluetooth service primary language.</source>
          <target state="translated">Bluetooth 서비스 기본 언어를 제공하는 회사 / 기관의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="e62e5b19ea3e4caf476672d67d8ef6109546ab01" translate="yes" xml:space="preserve">
          <source>Name of the object being transferred. May be displayed in the UI of the remote device.</source>
          <target state="translated">전송중인 객체의 이름입니다. 원격 장치의 UI에 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b73c64ffbe29d51e0c9b907f556bf9c8dc15d2db" translate="yes" xml:space="preserve">
          <source>Name of the property</source>
          <target state="translated">부동산 이름</target>
        </trans-unit>
        <trans-unit id="f04d94651df2a925a17d5b8c99684b1cc98849c1" translate="yes" xml:space="preserve">
          <source>Name of the series</source>
          <target state="translated">시리즈 이름</target>
        </trans-unit>
        <trans-unit id="5b8f19dc05d804022185ca5cf118ed9e3ef5a8ba" translate="yes" xml:space="preserve">
          <source>Name-based, by using values from a name for all sections</source>
          <target state="translated">모든 섹션에 대해 이름의 값을 사용하여 이름 기반</target>
        </trans-unit>
        <trans-unit id="9b05f1cd82d1a0e95b7c1e80bcb8a10b169e27f6" translate="yes" xml:space="preserve">
          <source>Named enumeration value</source>
          <target state="translated">명명 된 열거 값</target>
        </trans-unit>
        <trans-unit id="0449e1003dd0cdd92ab163e844540614258e8b38" translate="yes" xml:space="preserve">
          <source>Namespace</source>
          <target state="translated">Namespace</target>
        </trans-unit>
        <trans-unit id="36880e562e15a6c8c0541e94a75080710be864fd" translate="yes" xml:space="preserve">
          <source>Namespace Node</source>
          <target state="translated">네임 스페이스 노드</target>
        </trans-unit>
        <trans-unit id="98730f0dc61b80aeb6ded7e1aa89e301f31f78a7" translate="yes" xml:space="preserve">
          <source>Namespace Nodes</source>
          <target state="translated">네임 스페이스 노드</target>
        </trans-unit>
        <trans-unit id="345669d74a27e8ec4ccdcf95191d5c8b73331bf4" translate="yes" xml:space="preserve">
          <source>Namespace Support via Features</source>
          <target state="translated">기능을 통한 네임 스페이스 지원</target>
        </trans-unit>
        <trans-unit id="fb4f839de12ee7f6e0dafdc7a2e8750a001ad436" translate="yes" xml:space="preserve">
          <source>Namespace nodes have no base URI.</source>
          <target state="translated">네임 스페이스 노드에는 기본 URI가 없습니다.</target>
        </trans-unit>
        <trans-unit id="82def0183fd1e73ba6d57b7b4b71283153dd78c2" translate="yes" xml:space="preserve">
          <source>Namespace prefix and local part</source>
          <target state="translated">네임 스페이스 접두사 및 로컬 부분</target>
        </trans-unit>
        <trans-unit id="46a86852d4a13065f6432cc149d45b115d989683" translate="yes" xml:space="preserve">
          <source>Namespace prefixes and local parts of elements and attributes can be reported.</source>
          <target state="translated">네임 스페이스 접두사와 요소 및 속성의 로컬 부분을보고 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="55023261a9e862c8080895911fbbd051b81d10f9" translate="yes" xml:space="preserve">
          <source>Namespace used for accessing the classes Renderer and QRenderPlugin. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">Renderer 및 QRenderPlugin 클래스에 액세스하는 데 사용되는 네임 스페이스입니다. &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="67912bb013c3031101e263ba2a4e710333afabae" translate="yes" xml:space="preserve">
          <source>Namespaced name</source>
          <target state="translated">네임 스페이스 이름</target>
        </trans-unit>
        <trans-unit id="be09a63bd1995e99cd22064cdc39a4bae464033d" translate="yes" xml:space="preserve">
          <source>Namespaces</source>
          <target state="translated">Namespaces</target>
        </trans-unit>
        <trans-unit id="01aa119f95c35bd9dad17fe5dcaa93f37ad092a7" translate="yes" xml:space="preserve">
          <source>Namespaces are URIs like</source>
          <target state="translated">네임 스페이스는 다음과 같은 URI입니다.</target>
        </trans-unit>
        <trans-unit id="14abb0751615fe89799e7e97430e3f1959df107f" translate="yes" xml:space="preserve">
          <source>Namespaces are a concept introduced into XML to allow a more modular design. With their help data processing software can easily resolve naming conflicts in XML documents.</source>
          <target state="translated">네임 스페이스는 XML에 도입 된 개념으로보다 모듈 식 디자인이 가능합니다. 데이터 처리 소프트웨어의 도움으로 XML 문서의 이름 충돌을 쉽게 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="45b150c33703661a4e069fa3f97c482cd27685ef" translate="yes" xml:space="preserve">
          <source>Naming Convention</source>
          <target state="translated">명명 규칙</target>
        </trans-unit>
        <trans-unit id="4b7f447fc4756274c95f3cf55b404efc9b3529fc" translate="yes" xml:space="preserve">
          <source>Naming Custom QML Object Types</source>
          <target state="translated">사용자 정의 QML 객체 유형 이름 지정</target>
        </trans-unit>
        <trans-unit id="273a0d30662970ff3c1562fa729c143a281a5505" translate="yes" xml:space="preserve">
          <source>Naming Things</source>
          <target state="translated">명명 것들</target>
        </trans-unit>
        <trans-unit id="4c92b4e7b0f1a52b1c88cb308a062c7843546981" translate="yes" xml:space="preserve">
          <source>Naming test cases is important. The test name appears in the failure report for a test run. For data-driven tests, the name of the data row also appears in the failure report. The names give those reading the report a first indication of what has gone wrong.</source>
          <target state="translated">테스트 케이스 이름 지정이 중요합니다. 테스트 실행에 대한 실패 보고서에 테스트 이름이 표시됩니다. 데이터 기반 테스트의 경우 데이터 행의 이름도 실패 보고서에 나타납니다. 이름은 보고서를 읽는 사람들에게 무엇이 잘못되었는지 첫 번째 표시를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="a543b63edecd551c2071897611e765d0a303fd06" translate="yes" xml:space="preserve">
          <source>NationalMusic</source>
          <target state="translated">NationalMusic</target>
        </trans-unit>
        <trans-unit id="182f50a3b7123e5010cfdfa785d2d62e0f695222" translate="yes" xml:space="preserve">
          <source>Native C++ Calls from Java Service</source>
          <target state="translated">Java 서비스에서 네이티브 C ++ 호출</target>
        </trans-unit>
        <trans-unit id="77e3a2e86495f45202ac1fb744f4d0a6487c34d2" translate="yes" xml:space="preserve">
          <source>Native Dialogs</source>
          <target state="translated">기본 대화 상자</target>
        </trans-unit>
        <trans-unit id="c7d5dd6e7dc5ff363b866c268e74d315b43d1577" translate="yes" xml:space="preserve">
          <source>Native Image Picker</source>
          <target state="translated">기본 이미지 피커</target>
        </trans-unit>
        <trans-unit id="351835a1109466b10be8c8b6374aadc77a9394bb" translate="yes" xml:space="preserve">
          <source>Native Interfaces</source>
          <target state="translated">네이티브 인터페이스</target>
        </trans-unit>
        <trans-unit id="2dace6a56b70836fd018d4642ef29b1218fbdfe8" translate="yes" xml:space="preserve">
          <source>Native Style for Android</source>
          <target state="translated">Android 용 기본 스타일</target>
        </trans-unit>
        <trans-unit id="7c01982392c5e0aafa3054249fe423c1e9d6601b" translate="yes" xml:space="preserve">
          <source>Native Widgets</source>
          <target state="translated">기본 위젯</target>
        </trans-unit>
        <trans-unit id="68a0b7063b537a54bff810ca80566e94c82468bb" translate="yes" xml:space="preserve">
          <source>Native Widgets vs Alien Widgets</source>
          <target state="translated">기본 위젯 및 외계인 위젯</target>
        </trans-unit>
        <trans-unit id="2c267eca96af17f3c5b9125c31930481652a3f15" translate="yes" xml:space="preserve">
          <source>Native dialogs and menus</source>
          <target state="translated">기본 대화 상자 및 메뉴</target>
        </trans-unit>
        <trans-unit id="bfee3bae203bd0a3b1dd6ffcb843dd0135821587" translate="yes" xml:space="preserve">
          <source>Native dictionaries - the &lt;a href=&quot;qtwebengine-platform-notes#macos&quot;&gt;macOS&lt;/a&gt; spellchecking APIs are used (which means the results will depend on the installed OS dictionaries)</source>
          <target state="translated">기본 사전 &lt;a href=&quot;qtwebengine-platform-notes#macos&quot;&gt;-macOS&lt;/a&gt; 맞춤법 검사 API가 사용됩니다 (결과는 설치된 OS 사전에 따라 결정됨)</target>
        </trans-unit>
        <trans-unit id="6ac0474e8d0e3adb054291843aa230802b3a3bf6" translate="yes" xml:space="preserve">
          <source>Native dictionaries - the macOS spellchecking APIs are used (which means the results will depend on the installed OS dictionaries)</source>
          <target state="translated">네이티브 사전-macOS 맞춤법 검사 API가 사용됩니다 (즉, 설치된 OS 사전에 따라 결과가 달라짐).</target>
        </trans-unit>
        <trans-unit id="5b38ef563ef35060bc2efe84d8a2fa898a2335b0" translate="yes" xml:space="preserve">
          <source>Native gesture events are generated by the operating system, typically by interpreting touch events. Gesture events are high-level events such as zoom or rotate.</source>
          <target state="translated">기본 제스처 이벤트는 일반적으로 터치 이벤트를 해석하여 운영 체제에 의해 생성됩니다. 제스처 이벤트는 확대 / 축소 또는 회전과 같은 고급 이벤트입니다.</target>
        </trans-unit>
        <trans-unit id="834f2e8f02d7e6df926436df212f72d79dcd7475" translate="yes" xml:space="preserve">
          <source>Native graphics objects (such as, graphics device, command buffer or encoder) are accessible via &lt;a href=&quot;qsgrendererinterface#getResource&quot;&gt;QSGRendererInterface::getResource&lt;/a&gt;().</source>
          <target state="translated">기본 그래픽 개체 (예 : 그래픽 장치, 명령 버퍼 또는 인코더)는 &lt;a href=&quot;qsgrendererinterface#getResource&quot;&gt;QSGRendererInterface :: getResource&lt;/a&gt; () 를 통해 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9846862d12fc830cf1c88393fae17b371256ea9f" translate="yes" xml:space="preserve">
          <source>Native interface to a GLX context</source>
          <target state="translated">GLX 컨텍스트에 대한 기본 인터페이스</target>
        </trans-unit>
        <trans-unit id="7e5efca9c1d4d87c9962eb4f0e8b7019a77dc6cb" translate="yes" xml:space="preserve">
          <source>Native interface to a GLX context. &lt;a href=&quot;https://doc.qt.io/qt-6.0/qnativeinterface-qglxcontext.html#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">GLX 컨텍스트에 대한 기본 인터페이스입니다. &lt;a href=&quot;https://doc.qt.io/qt-6.0/qnativeinterface-qglxcontext.html#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="828cd05b659ff853eeceb70ee78dad5248014d9e" translate="yes" xml:space="preserve">
          <source>Native interface to a WGL context on Windows</source>
          <target state="translated">Windows의 WGL 컨텍스트에 대한 기본 인터페이스</target>
        </trans-unit>
        <trans-unit id="6834822409f274dab830975e7a713d06818f0fcf" translate="yes" xml:space="preserve">
          <source>Native interface to a WGL context on Windows. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">Windows의 WGL 컨텍스트에 대한 기본 인터페이스입니다. &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="85ca51b1cb3a0df833676efc20f3fb4afc65c95e" translate="yes" xml:space="preserve">
          <source>Native interface to a WGL context on Windows. &lt;a href=&quot;qnativeinterface-qwglcontext#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">Windows의 WGL 컨텍스트에 대한 기본 인터페이스입니다. &lt;a href=&quot;qnativeinterface-qwglcontext#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="df2045f57163d7c9be96a70b4d70a1d67ca33ac7" translate="yes" xml:space="preserve">
          <source>Native interface to a offscreen surface on Android</source>
          <target state="translated">Android의 오프 스크린 표면에 대한 기본 인터페이스</target>
        </trans-unit>
        <trans-unit id="019ace87fff38326e2ed65b1658e2b51125cc983" translate="yes" xml:space="preserve">
          <source>Native interface to a offscreen surface on Android. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">Android의 오프 스크린 표면에 대한 기본 인터페이스입니다. &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="03c10c2cf172ec88f29b39510c89d9be07046fad" translate="yes" xml:space="preserve">
          <source>Native interface to a offscreen surface on Android. &lt;a href=&quot;qnativeinterface-qandroidoffscreensurface#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">Android의 오프 스크린 표면에 대한 기본 인터페이스입니다. &lt;a href=&quot;qnativeinterface-qandroidoffscreensurface#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="93acdd523ac406b1d491b9e2cc3c7a0d35f63104" translate="yes" xml:space="preserve">
          <source>Native interface to an EGL context</source>
          <target state="translated">EGL 컨텍스트에 대한 기본 인터페이스</target>
        </trans-unit>
        <trans-unit id="8916676d7b9b9e119789994704595b7927f4dd75" translate="yes" xml:space="preserve">
          <source>Native interface to an EGL context. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">EGL 컨텍스트에 대한 기본 인터페이스입니다. &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="49d10c81ee1eeefc2f606d7c90504aefa5b0b749" translate="yes" xml:space="preserve">
          <source>Native interface to an EGL context. &lt;a href=&quot;qnativeinterface-qeglcontext#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">EGL 컨텍스트에 대한 기본 인터페이스입니다. &lt;a href=&quot;qnativeinterface-qeglcontext#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d422ef35e356613f4596ca65c9bfa7ebf40c78f7" translate="yes" xml:space="preserve">
          <source>Native interface to an NSOpenGLContext on macOS</source>
          <target state="translated">macOS의 NSOpenGLContext에 대한 기본 인터페이스</target>
        </trans-unit>
        <trans-unit id="019d2800785f6e11dcdde5919d2b4968609b4753" translate="yes" xml:space="preserve">
          <source>Native interface to an NSOpenGLContext on macOS. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">macOS의 NSOpenGLContext에 대한 기본 인터페이스입니다. &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="96c89c4e4964792c8cfa28c6e74b5f39d77973e6" translate="yes" xml:space="preserve">
          <source>Native interface to an NSOpenGLContext on macOS. &lt;a href=&quot;qnativeinterface-qcocoaglcontext#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">macOS의 NSOpenGLContext에 대한 기본 인터페이스입니다. &lt;a href=&quot;qnativeinterface-qcocoaglcontext#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b583f085a62419e2aaf4d16e5d594d11c901fc7c" translate="yes" xml:space="preserve">
          <source>Native menus are implemented using Win32 API and are simpler than &lt;a href=&quot;qmenu&quot;&gt;QMenu&lt;/a&gt;-based menus in for example that they do allow for placing widgets on them or changing properties like fonts and do not provide hover signals. They are mainly intended for Qt Quick. By default, they will be used if the application is not an instance of &lt;a href=&quot;qapplication&quot;&gt;QApplication&lt;/a&gt; or for Qt Quick Controls 2 applications (since Qt 5.10).</source>
          <target state="translated">기본 메뉴는 Win32 API를 사용하여 구현 되며 예를 들어 위젯을 배치하거나 글꼴과 같은 속성을 변경할 수 있고 호버 신호를 제공하지 않는다는 점에서 &lt;a href=&quot;qmenu&quot;&gt;QMenu&lt;/a&gt; 기반 메뉴 보다 간단 합니다. 주로 Qt Quick 용입니다. 기본적으로 응용 프로그램이 &lt;a href=&quot;qapplication&quot;&gt;QApplication&lt;/a&gt; 의 인스턴스가 아니 거나 Qt Quick Controls 2 응용 프로그램 (Qt 5.10 이후)에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="bec732fae62aa36fed9d600a1789681a33e49cab" translate="yes" xml:space="preserve">
          <source>Native menus are implemented using Win32 API and are simpler than &lt;a href=&quot;qmenu&quot;&gt;QMenu&lt;/a&gt;-based menus in for example that they do allow for placing widgets on them or changing properties like fonts and do not provide hover signals. They are mainly intended for Qt Quick. By default, they will be used if the application is not an instance of &lt;a href=&quot;qapplication&quot;&gt;QApplication&lt;/a&gt; or for Qt Quick Controls 2 applications.</source>
          <target state="translated">기본 메뉴는 Win32 API를 사용하여 구현되며 &lt;a href=&quot;qmenu&quot;&gt;QMenu&lt;/a&gt; 기반 메뉴 보다 간단 합니다. 예를 들어 위젯을 배치하거나 글꼴과 같은 속성을 변경하고 호버 신호를 제공하지 않습니다. 주로 Qt Quick을위한 것입니다. 기본적으로 애플리케이션이 &lt;a href=&quot;qapplication&quot;&gt;QApplication&lt;/a&gt; 의 인스턴스가 아니 거나 Qt Quick Controls 2 애플리케이션에 사용되는 경우에 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="8ec04a131f93b14313e0bc818ebd2f15bec058c7" translate="yes" xml:space="preserve">
          <source>Native widgets include toplevel widgets, QGLWidget, and child widgets on which &lt;a href=&quot;qwidget#winId&quot;&gt;winId&lt;/a&gt;() was called.</source>
          <target state="translated">기본 위젯에는 최상위 위젯, QGLWidget 및 &lt;a href=&quot;qwidget#winId&quot;&gt;winId&lt;/a&gt; ()가 호출 된 하위 위젯이 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="6fdb0afeddf030bb96353404e9ddc01e5fb18163" translate="yes" xml:space="preserve">
          <source>NativeTexture Struct</source>
          <target state="translated">NativeTexture 구조</target>
        </trans-unit>
        <trans-unit id="13051a06e3ed8a247475754d28ea6ca38ec90fd7" translate="yes" xml:space="preserve">
          <source>NativeTexture::layout</source>
          <target state="translated">NativeTexture::layout</target>
        </trans-unit>
        <trans-unit id="459476f5275ab5911b6d2bacab2484f1eca1eb15" translate="yes" xml:space="preserve">
          <source>NativeTexture::object</source>
          <target state="translated">NativeTexture::object</target>
        </trans-unit>
        <trans-unit id="4a1d0e753708a7f91514d068d9689de9a6b6c64f" translate="yes" xml:space="preserve">
          <source>Naturally, the same could also be obtained by masking the result of &lt;a href=&quot;qrandomgenerator#generate&quot;&gt;generate&lt;/a&gt;() to only the lower 8 bits. Either solution is as efficient.</source>
          <target state="translated">당연히, &lt;a href=&quot;qrandomgenerator#generate&quot;&gt;생성&lt;/a&gt; () 의 결과를 하위 8 비트로 만 마스킹함으로써 동일하게 얻을 수있다 . 어느 솔루션이든 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="00f861a771e9dce33f9f1671aac988a4ba879041" translate="yes" xml:space="preserve">
          <source>Navigate back in the history of navigated links.</source>
          <target state="translated">탐색 된 링크 기록에서 다시 탐색하십시오.</target>
        </trans-unit>
        <trans-unit id="3a295e1333323b7e08ed30c29e28ba62633fd28d" translate="yes" xml:space="preserve">
          <source>Navigate back.</source>
          <target state="translated">다시 탐색하십시오.</target>
        </trans-unit>
        <trans-unit id="cd3638a97361ee2508acb62cae3caf21646789cf" translate="yes" xml:space="preserve">
          <source>Navigate forward in the history of navigated links.</source>
          <target state="translated">탐색 된 링크 히스토리에서 앞으로 탐색하십시오.</target>
        </trans-unit>
        <trans-unit id="f50421cbc18d592007956762300e156cfd35bafb" translate="yes" xml:space="preserve">
          <source>Navigate forward.</source>
          <target state="translated">앞으로 이동하십시오.</target>
        </trans-unit>
        <trans-unit id="fb620808dd352d6a35b9a08c4a1251fe727b9a48" translate="yes" xml:space="preserve">
          <source>Navigate to next tab or child window.</source>
          <target state="translated">다음 탭 또는 하위 창으로 이동하십시오.</target>
        </trans-unit>
        <trans-unit id="2e3d37b1c9e34d59d6f791a2afa9d1cc8ff48eb9" translate="yes" xml:space="preserve">
          <source>Navigate to previous tab or child window.</source>
          <target state="translated">이전 탭 또는 하위 창으로 이동하십시오.</target>
        </trans-unit>
        <trans-unit id="631969911c9584ffedad04d16df848467153f895" translate="yes" xml:space="preserve">
          <source>Navigate to the &lt;b&gt;Provisioning Profiles&lt;/b&gt; tab of the manager and click the &lt;b&gt;+&lt;/b&gt; button to create a new Provisioning Profile. Make sure that the &lt;b&gt;iOS App Development&lt;/b&gt; is selected and click the &lt;b&gt;Continue&lt;/b&gt; button.</source>
          <target state="translated">관리자 의 &lt;b&gt;프로비저닝 프로파일&lt;/b&gt; 탭으로 이동 하고 &lt;b&gt;+&lt;/b&gt; 버튼을 클릭하여 새 프로비저닝 프로파일을 만듭니다. &lt;b&gt;iOS 앱 개발&lt;/b&gt; 이 선택되어 있는지 확인 하고 &lt;b&gt;계속&lt;/b&gt; 버튼을 클릭하십시오 .</target>
        </trans-unit>
        <trans-unit id="575397ff4acc9bb71770ce496dba77a4f9f70b68" translate="yes" xml:space="preserve">
          <source>Navigates back in the web history.</source>
          <target state="translated">웹 기록을 다시 탐색합니다.</target>
        </trans-unit>
        <trans-unit id="61419c13b7b41b8c1f8a05b9fa7e3179ca129fa6" translate="yes" xml:space="preserve">
          <source>Navigates forward in the web history.</source>
          <target state="translated">웹 기록을 탐색합니다.</target>
        </trans-unit>
        <trans-unit id="91a58be8fe8db23ff324c64a64cefa03796fde4f" translate="yes" xml:space="preserve">
          <source>Navigates this page to an internal URL that is the developer tools of</source>
          <target state="translated">이 페이지를 개발자 도구 인 내부 URL로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="272f1fb0016a916a33ded1416d9af5ad65ac662c" translate="yes" xml:space="preserve">
          <source>Navigating records is performed with the following functions:</source>
          <target state="translated">레코드 탐색은 다음 기능으로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="71653d3461aafb34f1abe700412b11f3bb0dd52b" translate="yes" xml:space="preserve">
          <source>Navigating the Result Set</source>
          <target state="translated">결과 집합 탐색</target>
        </trans-unit>
        <trans-unit id="cf03cf2e9cdf95a20af09137dfb9071db0c31bf2" translate="yes" xml:space="preserve">
          <source>Navigation</source>
          <target state="translated">Navigation</target>
        </trans-unit>
        <trans-unit id="7ba01fa5b6c8500ec9e0b739b6b1a9720850d526" translate="yes" xml:space="preserve">
          <source>Navigation Controls</source>
          <target state="translated">네비게이션 컨트롤</target>
        </trans-unit>
        <trans-unit id="5a7e84a071d5f41cedff223811e42d43cf6fafdc" translate="yes" xml:space="preserve">
          <source>Navigation and Directory Operations</source>
          <target state="translated">탐색 및 디렉토리 작업</target>
        </trans-unit>
        <trans-unit id="30bf5bf3f3e9d07b001f59e287e2763ede23b438" translate="yes" xml:space="preserve">
          <source>Navigation and Views</source>
          <target state="translated">탐색 및 뷰</target>
        </trans-unit>
        <trans-unit id="9526cb750f209d5e3e3b004d730f28a7f6e2b6a5" translate="yes" xml:space="preserve">
          <source>Navigation and model index creation</source>
          <target state="translated">탐색 및 모델 색인 작성</target>
        </trans-unit>
        <trans-unit id="b86e475598d5f78977bcd7e6b0dbd13a7f7ac5e3" translate="yes" xml:space="preserve">
          <source>Navigation explicitly initiated by typing a URL.</source>
          <target state="translated">URL을 입력하여 탐색을 명시 적으로 시작했습니다.</target>
        </trans-unit>
        <trans-unit id="ea4450356d2c4936baa0675c0d2f38b8e27bced5" translate="yes" xml:space="preserve">
          <source>Navigation initiated by a history action.</source>
          <target state="translated">히스토리 조치로 시작된 탐색</target>
        </trans-unit>
        <trans-unit id="e28e29f62e751513b6e3b9558901b24b29960eaa" translate="yes" xml:space="preserve">
          <source>Navigation initiated by clicking a link.</source>
          <target state="translated">링크를 클릭하면 탐색이 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="3b219e7dea711da4d88e59d0728a6aeb991f8d76" translate="yes" xml:space="preserve">
          <source>Navigation initiated by refreshing the page.</source>
          <target state="translated">페이지를 새로 고침하여 탐색을 시작했습니다.</target>
        </trans-unit>
        <trans-unit id="8fb7b6c0ecefbaf075b61a1e2010ae90814c5d1b" translate="yes" xml:space="preserve">
          <source>Navigation is not supported by the service provider.</source>
          <target state="translated">서비스 제공 업체가 탐색을 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8c25535b15867d0f8702d6dfab531b54ac38bb5b" translate="yes" xml:space="preserve">
          <source>Navigation requests can be delegated to the Qt application instead of having the HTML handler engine process them by overloading this function. This is necessary when an HTML document is used as part of the user interface, and not to display external data, for example, when displaying a list of results.</source>
          <target state="translated">이 함수를 오버로드하여 HTML 처리기 엔진이 처리하도록하는 대신 탐색 요청을 Qt 응용 프로그램에 위임 할 수 있습니다. 이것은 HTML 문서가 사용자 인터페이스의 일부로 사용될 때 필요하며 예를 들어 결과 목록을 표시 할 때 외부 데이터를 표시하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="36748a76df57987b603a144e451c2ff22b4acf92" translate="yes" xml:space="preserve">
          <source>Navigation submits a form.</source>
          <target state="translated">탐색은 양식을 제출합니다.</target>
        </trans-unit>
        <trans-unit id="276ebe4dec017af77a4e30015335ee590c831c7e" translate="yes" xml:space="preserve">
          <source>Navigation triggered automatically by page content or remote server. (Added in Qt 5.14)</source>
          <target state="translated">페이지 콘텐츠 또는 원격 서버에 의해 자동으로 트리거되는 탐색. (Qt 5.14에 추가됨)</target>
        </trans-unit>
        <trans-unit id="c8e6f949b8ada118fdafbdc6ee8783d697f007cb" translate="yes" xml:space="preserve">
          <source>Navigator</source>
          <target state="translated">Navigator</target>
        </trans-unit>
        <trans-unit id="2a48cbb77710fc5318d5ca4bffcdf917ec1002b0" translate="yes" xml:space="preserve">
          <source>Navigator (QML type)</source>
          <target state="translated">네비게이터 (QML 유형)</target>
        </trans-unit>
        <trans-unit id="1d9d22dc00c311ebfb968e44f46674ce6d6d567a" translate="yes" xml:space="preserve">
          <source>Navigator QML Type</source>
          <target state="translated">네비게이터 QML 유형</target>
        </trans-unit>
        <trans-unit id="073f544731b2424ef29e08f92d0662a69080c0c9" translate="yes" xml:space="preserve">
          <source>Navigator plugins can also control this property directly e.g. user map interaction could trigger the property change. Honoring the user-specified value of this property is plugin dependent.</source>
          <target state="translated">네비게이터 플러그인은이 속성을 직접 제어 할 수도 있습니다. 예를 들어, 사용자 맵 상호 작용이 속성 변경을 트리거 할 수 있습니다. 이 속성의 사용자 지정 값을 존중하는 것은 플러그인에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="090d7f009f3fa4041fffc9b40098b611482ded42" translate="yes" xml:space="preserve">
          <source>Navigator.active</source>
          <target state="translated">Navigator.active</target>
        </trans-unit>
        <trans-unit id="40ba82f5a646a1978e78ddf5afb269b0807fb963" translate="yes" xml:space="preserve">
          <source>Navigator.automaticReroutingEnabled</source>
          <target state="translated">Navigator.automaticReroutingEnabled</target>
        </trans-unit>
        <trans-unit id="71a2431b3dd7484a6f958c2e5c10fb17445d3406" translate="yes" xml:space="preserve">
          <source>Navigator.directions.alternativeRoutes</source>
          <target state="translated">Navigator.directions.alternativeRoutes</target>
        </trans-unit>
        <trans-unit id="67a492b760770925385b7698922a3c7558595179" translate="yes" xml:space="preserve">
          <source>Navigator.directions.destinationReached()</source>
          <target state="translated">Navigator.directions.destinationReached()</target>
        </trans-unit>
        <trans-unit id="8fb32f2ec9e06980f2ad10cf3b17de3c34f8abce" translate="yes" xml:space="preserve">
          <source>Navigator.directions.nextManeuverIcon</source>
          <target state="translated">Navigator.directions.nextManeuverIcon</target>
        </trans-unit>
        <trans-unit id="9080dd68384a418616a5bcbee87e285a09d42820" translate="yes" xml:space="preserve">
          <source>Navigator.directions.waypointReached()</source>
          <target state="translated">Navigator.directions.waypointReached()</target>
        </trans-unit>
        <trans-unit id="1683633ab805492ab9e21f58ba7d8da7eab6449c" translate="yes" xml:space="preserve">
          <source>Navigator.error</source>
          <target state="translated">Navigator.error</target>
        </trans-unit>
        <trans-unit id="e093cc68e8f1de446faf010a509957db464140cb" translate="yes" xml:space="preserve">
          <source>Navigator.isOnRoute</source>
          <target state="translated">Navigator.isOnRoute</target>
        </trans-unit>
        <trans-unit id="3dc1777b583dc6f2d5d9202355b96957f52859ad" translate="yes" xml:space="preserve">
          <source>Navigator.map</source>
          <target state="translated">Navigator.map</target>
        </trans-unit>
        <trans-unit id="2b20443189e98836eea9d33d7b26b4dd3ba09ecc" translate="yes" xml:space="preserve">
          <source>Navigator.navigatorReady</source>
          <target state="translated">Navigator.navigatorReady</target>
        </trans-unit>
        <trans-unit id="ccce3d414f480f2ad070c976404eef8cc84061cc" translate="yes" xml:space="preserve">
          <source>Navigator.plugin</source>
          <target state="translated">Navigator.plugin</target>
        </trans-unit>
        <trans-unit id="df5634d281873f7fbb3d48f1f25a34ad048265a5" translate="yes" xml:space="preserve">
          <source>Navigator.positionSource</source>
          <target state="translated">Navigator.positionSource</target>
        </trans-unit>
        <trans-unit id="62afd25781390d69dda37342b810e9ee390d85d3" translate="yes" xml:space="preserve">
          <source>Navigator.recalculateRoutes()</source>
          <target state="translated">Navigator.recalculateRoutes()</target>
        </trans-unit>
        <trans-unit id="0481ea9fd6a6dc4b75b485471ee6a38c4a92c1b2" translate="yes" xml:space="preserve">
          <source>Navigator.route</source>
          <target state="translated">Navigator.route</target>
        </trans-unit>
        <trans-unit id="1ef382f3d652d36ecb3b3e468e2039e7baf4eb0f" translate="yes" xml:space="preserve">
          <source>Navigator.trackPositionSource</source>
          <target state="translated">Navigator.trackPositionSource</target>
        </trans-unit>
        <trans-unit id="001dbed5edff55e7cc410c6a5b86c4ccbedc7355" translate="yes" xml:space="preserve">
          <source>NdefFilter (QML type)</source>
          <target state="translated">NdefFilter (QML 유형)</target>
        </trans-unit>
        <trans-unit id="ec8110416e3f360fee9309d28b3e6e1a42ef9acc" translate="yes" xml:space="preserve">
          <source>NdefFilter QML Type</source>
          <target state="translated">NdefFilter QML 유형</target>
        </trans-unit>
        <trans-unit id="1302054e059ea463e34a28f79373e000eea30912" translate="yes" xml:space="preserve">
          <source>NdefFilter.maximum</source>
          <target state="translated">NdefFilter.maximum</target>
        </trans-unit>
        <trans-unit id="4c2b806846b984b4fedfa09d12f61e82e132b304" translate="yes" xml:space="preserve">
          <source>NdefFilter.minimum</source>
          <target state="translated">NdefFilter.minimum</target>
        </trans-unit>
        <trans-unit id="a49dda1eaa2700990fffdf5be0a140799b19e572" translate="yes" xml:space="preserve">
          <source>NdefFilter.type</source>
          <target state="translated">NdefFilter.type</target>
        </trans-unit>
        <trans-unit id="ad39bbf5f200ea55ca2b24a46551548fecc93051" translate="yes" xml:space="preserve">
          <source>NdefFilter.typeNameFormat</source>
          <target state="translated">NdefFilter.typeNameFormat</target>
        </trans-unit>
        <trans-unit id="7223594263a0937ffb5e62aeef97c61bac0c3713" translate="yes" xml:space="preserve">
          <source>NdefMimeRecord (QML type)</source>
          <target state="translated">NdefMimeRecord (QML 유형)</target>
        </trans-unit>
        <trans-unit id="2586769bec4fa921bef486fab45dd86b8ce45b1c" translate="yes" xml:space="preserve">
          <source>NdefMimeRecord QML Type</source>
          <target state="translated">NdefMimeRecord QML 유형</target>
        </trans-unit>
        <trans-unit id="706a1307c486b58bf1c95dc4b961d9f2f7cb1e7d" translate="yes" xml:space="preserve">
          <source>NdefMimeRecord.uri</source>
          <target state="translated">NdefMimeRecord.uri</target>
        </trans-unit>
        <trans-unit id="a9ca0285650316ef7978312da69bdbc26fe9ec97" translate="yes" xml:space="preserve">
          <source>NdefRecord</source>
          <target state="translated">NdefRecord</target>
        </trans-unit>
        <trans-unit id="ae4b328ff15ece0c980bf82a51b7fefa04475585" translate="yes" xml:space="preserve">
          <source>NdefRecord (QML type)</source>
          <target state="translated">NdefRecord (QML 유형)</target>
        </trans-unit>
        <trans-unit id="0076eb34a8bbb8e83614c165d20cfd957c4a8bc3" translate="yes" xml:space="preserve">
          <source>NdefRecord QML Type</source>
          <target state="translated">NdefRecord QML 유형</target>
        </trans-unit>
        <trans-unit id="1736b26a0931dc592e9a72cbae75f4c272343fe4" translate="yes" xml:space="preserve">
          <source>NdefRecord.record</source>
          <target state="translated">NdefRecord.record</target>
        </trans-unit>
        <trans-unit id="c2f8b2f5d463dac8f8dd232fe9448ac2613f7cd6" translate="yes" xml:space="preserve">
          <source>NdefRecord.type</source>
          <target state="translated">NdefRecord.type</target>
        </trans-unit>
        <trans-unit id="d229189cab008b7daff100d9dae7e3f60035e35b" translate="yes" xml:space="preserve">
          <source>NdefRecord.typeNameFormat</source>
          <target state="translated">NdefRecord.typeNameFormat</target>
        </trans-unit>
        <trans-unit id="cacd0bc1b7bd480b5a58a28434a46573821db2aa" translate="yes" xml:space="preserve">
          <source>NdefTextRecord (QML type)</source>
          <target state="translated">NdefTextRecord (QML 유형)</target>
        </trans-unit>
        <trans-unit id="d1e716b32328658debb418e24dc60a87e5a93804" translate="yes" xml:space="preserve">
          <source>NdefTextRecord QML Type</source>
          <target state="translated">NdefTextRecord QML 유형</target>
        </trans-unit>
        <trans-unit id="08abfa2a9a84b8db1e4bf245d2aeecdd09e15067" translate="yes" xml:space="preserve">
          <source>NdefTextRecord.locale</source>
          <target state="translated">NdefTextRecord.locale</target>
        </trans-unit>
        <trans-unit id="77a87ffd4b38f48297a2c1caa0c522997777fe83" translate="yes" xml:space="preserve">
          <source>NdefTextRecord.localeMatch</source>
          <target state="translated">NdefTextRecord.localeMatch</target>
        </trans-unit>
        <trans-unit id="5cb1a902d4fb2657aa706ced43da2152902eccf5" translate="yes" xml:space="preserve">
          <source>NdefTextRecord.text</source>
          <target state="translated">NdefTextRecord.text</target>
        </trans-unit>
        <trans-unit id="d3c25fab6eca8c7b8b7631effad357a45e90e1d1" translate="yes" xml:space="preserve">
          <source>NdefUriRecord (QML type)</source>
          <target state="translated">NdefUriRecord (QML 유형)</target>
        </trans-unit>
        <trans-unit id="d2d4a6360f8dfde16ea060534507af8a3f38322d" translate="yes" xml:space="preserve">
          <source>NdefUriRecord QML Type</source>
          <target state="translated">NdefUriRecord QML 유형</target>
        </trans-unit>
        <trans-unit id="01b8d83b0358d2f77cefaadd9f133fb49a7119b4" translate="yes" xml:space="preserve">
          <source>NdefUriRecord.uri</source>
          <target state="translated">NdefUriRecord.uri</target>
        </trans-unit>
        <trans-unit id="889bba69f12d99df6d4e5efbaf89f18141a7b091" translate="yes" xml:space="preserve">
          <source>Near field communication (NFC) support is provided by the Qt NFC module. The QML and C++ APIs sets up communication between NFC Forum Tags and NFC Forum Devices through the of NFC Logical Link Control Protocol (LLCP).</source>
          <target state="translated">근거리 무선 통신 (NFC) 지원은 Qt NFC 모듈에 의해 제공됩니다. QML 및 C ++ API는 NFC 논리 링크 제어 프로토콜 (LLCP)을 통해 NFC 포럼 태그와 NFC 포럼 장치 간의 통신을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="93d8e89fd6a4f5aa08040531b9bab200af86f17e" translate="yes" xml:space="preserve">
          <source>NearField (QML type)</source>
          <target state="translated">NearField (QML 유형)</target>
        </trans-unit>
        <trans-unit id="8dcade74f23d01aa2df772e2893517c9239bc19f" translate="yes" xml:space="preserve">
          <source>NearField QML Type</source>
          <target state="translated">NearField QML 유형</target>
        </trans-unit>
        <trans-unit id="63dbe784997e0390b60b39d787474856e163352f" translate="yes" xml:space="preserve">
          <source>NearField.filter</source>
          <target state="translated">NearField.filter</target>
        </trans-unit>
        <trans-unit id="44cc4e435e73ed24372a9be7fee888b4fdc7a8d1" translate="yes" xml:space="preserve">
          <source>NearField.messageRecords</source>
          <target state="translated">NearField.messageRecords</target>
        </trans-unit>
        <trans-unit id="7180ea995c64e7d10c2c61913dd44d8bb1e1d98b" translate="yes" xml:space="preserve">
          <source>NearField.orderMatch</source>
          <target state="translated">NearField.orderMatch</target>
        </trans-unit>
        <trans-unit id="92cb1c061109e4abb942f725176796f1017e2de5" translate="yes" xml:space="preserve">
          <source>NearField.polling</source>
          <target state="translated">NearField.polling</target>
        </trans-unit>
        <trans-unit id="81381bdaf43e4b849ed9717a9895b63ca7a391ab" translate="yes" xml:space="preserve">
          <source>NearField.tagFound()</source>
          <target state="translated">NearField.tagFound()</target>
        </trans-unit>
        <trans-unit id="02e3c7c7af3c398aa98d056e1308623feeca528c" translate="yes" xml:space="preserve">
          <source>NearField.tagRemoved()</source>
          <target state="translated">NearField.tagRemoved()</target>
        </trans-unit>
        <trans-unit id="7fac3ee37989e9cfe6d6ebf73c01fd86fd303790" translate="yes" xml:space="preserve">
          <source>Nearest-neighbor interpolation.</source>
          <target state="translated">최근 접 이웃 보간.</target>
        </trans-unit>
        <trans-unit id="17181bb091f2a00bba1c74cde372cf304fece6f6" translate="yes" xml:space="preserve">
          <source>Negated Pseudo-states may appear in Pseudo-state chains. For example, the following rule applies when the mouse hovers over a &lt;a href=&quot;qpushbutton&quot;&gt;QPushButton&lt;/a&gt; that is not pressed:</source>
          <target state="translated">부정 의사 상태는 의사 상태 체인에 나타날 수 있습니다. 예를 들어, 마우스를 누르지 않은 &lt;a href=&quot;qpushbutton&quot;&gt;QPushButton&lt;/a&gt; 위로 마우스를 가져 가면 다음 규칙이 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="256c1c5d900d8a9e31d3772aa76fe0799c854a52" translate="yes" xml:space="preserve">
          <source>Negative insets can be used to make the background larger than the control. The following example uses negative insets to place a shadow outside the control's boundaries:</source>
          <target state="translated">음수 삽입을 사용하여 배경을 컨트롤보다 크게 만들 수 있습니다. 다음 예제에서는 음수 삽입을 사용하여 그림자를 컨트롤 경계 바깥에 배치합니다.</target>
        </trans-unit>
        <trans-unit id="16266bd04db8fb6c44cd9af22c177a5298eb01e4" translate="yes" xml:space="preserve">
          <source>Negative insets can be used to make the background larger than the popup. The following example uses negative insets to place a shadow outside the popup's boundaries:</source>
          <target state="translated">네거티브 삽입을 사용하여 팝업보다 배경을 크게 만들 수 있습니다. 다음 예제는 네거티브 인셋을 사용하여 그림자를 팝업 경계 바깥에 배치합니다.</target>
        </trans-unit>
        <trans-unit id="e74630df7cfade92be128b56154c38adf7b0362c" translate="yes" xml:space="preserve">
          <source>Negative lookahead. This assertion is true if the expression does not match at this point in the regexp. For example, &lt;b&gt;const(?!\s+char)&lt;/b&gt; matches 'const'</source>
          <target state="translated">부정적인 예견. 정규식의 현재 시점에서 표현식이 일치하지 않으면이 어설 션이 적용됩니다. 예를 들어 &lt;b&gt;const (?! \ s + char)&lt;/b&gt; 는 'const'와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="0b247e3c8355086599e15be9efdc87a68cb4c92b" translate="yes" xml:space="preserve">
          <source>Negative numbers</source>
          <target state="translated">음수</target>
        </trans-unit>
        <trans-unit id="05f5b08f761e98e85014710a431f2f0a144a1de7" translate="yes" xml:space="preserve">
          <source>Negative numbers represent indices starting from the end of the list, with -1 being the last element.</source>
          <target state="translated">음수는 목록의 끝에서 시작하여 -1이 마지막 요소 인 인덱스를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="2d7d0e1fe15f6c93380ab2eb11ca3c4bec094672" translate="yes" xml:space="preserve">
          <source>Negative values of</source>
          <target state="translated">음수 값</target>
        </trans-unit>
        <trans-unit id="8ae2caf639983d15d9588b31d21d1fd8be5c9f0e" translate="yes" xml:space="preserve">
          <source>Nested Classes Cannot Have Signals or Slots</source>
          <target state="translated">중첩 클래스는 신호 또는 슬롯을 가질 수 없습니다</target>
        </trans-unit>
        <trans-unit id="f1e495b2f298753ea7d5bf88fea0500cf24f6f8d" translate="yes" xml:space="preserve">
          <source>Nested event loops are not supported. Applications should not call, for example, &lt;a href=&quot;qdialog#exec&quot;&gt;QDialog::exec&lt;/a&gt;() or create a new &lt;a href=&quot;qeventloop&quot;&gt;QEventLoop&lt;/a&gt; object.</source>
          <target state="translated">중첩 된 이벤트 루프는 지원되지 않습니다. 응용 프로그램은 &lt;a href=&quot;qdialog#exec&quot;&gt;QDialog :: exec&lt;/a&gt; ()와 같은 호출을 하거나 새로운 &lt;a href=&quot;qeventloop&quot;&gt;QEventLoop&lt;/a&gt; 객체를 생성 해서는 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="1947aa7b7a9c7d980cbdc5fb958af074f0d62277" translate="yes" xml:space="preserve">
          <source>Nested states are recorded. In this case a transition with the history state as its target will end up in the most deeply nested descendant state the parent was in the last time it was exited.</source>
          <target state="translated">중첩 된 상태가 기록됩니다. 이 경우 대상이 기록 상태 인 전환은 부모가 마지막으로 종료되었을 때 가장 깊이 중첩 된 하위 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="b5b87cecdcd168e1d8f912fb6b24e6ad8c785141" translate="yes" xml:space="preserve">
          <source>Nesting QGraphicsLayoutItems</source>
          <target state="translated">중첩 QGraphicsLayoutItems</target>
        </trans-unit>
        <trans-unit id="0d4e181facdb688c055456cc6919ff0e17d6bc07" translate="yes" xml:space="preserve">
          <source>Nesting State Machines</source>
          <target state="translated">중첩 상태 머신</target>
        </trans-unit>
        <trans-unit id="6d6b33f0992b931f8f96b31be698f3ce9041c4c9" translate="yes" xml:space="preserve">
          <source>Network Components</source>
          <target state="translated">네트워크 구성 요소</target>
        </trans-unit>
        <trans-unit id="c61a6ae975f9035192d8dadd77f37d00d00a7b99" translate="yes" xml:space="preserve">
          <source>Network Programming with Qt</source>
          <target state="translated">Qt를 이용한 네트워크 프로그래밍</target>
        </trans-unit>
        <trans-unit id="f0f8a72b41da917fe1a7f08b0d512bb4ea073f4b" translate="yes" xml:space="preserve">
          <source>Network access: the web sandbox limits network access to a subset of what is available for native apps.</source>
          <target state="translated">네트워크 액세스 : 웹 샌드 박스는 네트워크 액세스를 기본 앱에 사용 가능한 것의 하위 집합으로 제한합니다.</target>
        </trans-unit>
        <trans-unit id="1d6c26138613458b1f8b922e504e5674865f9609" translate="yes" xml:space="preserve">
          <source>Network and Roaming Support</source>
          <target state="translated">네트워크 및 로밍 지원</target>
        </trans-unit>
        <trans-unit id="8a243a58d4f23526507b4878410d0fa5df2b7268" translate="yes" xml:space="preserve">
          <source>Network communication with Qt can be performed through proxies, which direct or filter network traffic between local and remote connections.</source>
          <target state="translated">Qt와의 네트워크 통신은 프록시를 통해 수행 될 수 있습니다. 프록시는 로컬 및 원격 연결 간의 네트워크 트래픽을 지시하거나 필터링합니다.</target>
        </trans-unit>
        <trans-unit id="81ecd01907271e7f688bd82cbc9937114bed0d3f" translate="yes" xml:space="preserve">
          <source>Network control</source>
          <target state="translated">네트워크 제어</target>
        </trans-unit>
        <trans-unit id="781947d6acb9abf263e41c3861435aa616d54bde" translate="yes" xml:space="preserve">
          <source>Network error.</source>
          <target state="translated">네트워크 오류.</target>
        </trans-unit>
        <trans-unit id="2dd4b96238c65c1bb2414a376f185e3dd080958b" translate="yes" xml:space="preserve">
          <source>Network hostnames</source>
          <target state="translated">네트워크 호스트 이름</target>
        </trans-unit>
        <trans-unit id="5d0ad64918c87a645feba831dba00f15aac53b93" translate="yes" xml:space="preserve">
          <source>Network layer proxy</source>
          <target state="translated">네트워크 계층 프록시</target>
        </trans-unit>
        <trans-unit id="8acdb13ead0ecaeeb9089834d154f2b1d58ab3af" translate="yes" xml:space="preserve">
          <source>Network proxy is not used if the address used in &lt;a href=&quot;qabstractsocket#connectToHost&quot;&gt;connectToHost()&lt;/a&gt;, &lt;a href=&quot;qabstractsocket#bind&quot;&gt;bind()&lt;/a&gt; or &lt;a href=&quot;qtcpserver#listen&quot;&gt;listen()&lt;/a&gt; is equivalent to &lt;a href=&quot;qhostaddress#SpecialAddress-enum&quot;&gt;QHostAddress::LocalHost&lt;/a&gt; or &lt;a href=&quot;qhostaddress#SpecialAddress-enum&quot;&gt;QHostAddress::LocalHostIPv6&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qabstractsocket#connectToHost&quot;&gt;connectToHost ()&lt;/a&gt; , &lt;a href=&quot;qabstractsocket#bind&quot;&gt;bind ()&lt;/a&gt; 또는 &lt;a href=&quot;qtcpserver#listen&quot;&gt;listen ()에&lt;/a&gt; 사용 된 주소 가 &lt;a href=&quot;qhostaddress#SpecialAddress-enum&quot;&gt;QHostAddress :: LocalHost&lt;/a&gt; 또는 &lt;a href=&quot;qhostaddress#SpecialAddress-enum&quot;&gt;QHostAddress :: LocalHostIPv6&lt;/a&gt; 과 동일한 경우 네트워크 프록시가 사용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="dce7d134df4fe6b3b523f66beaffe5ed414846e9" translate="yes" xml:space="preserve">
          <source>Network requests are represented by the &lt;a href=&quot;qnetworkrequest&quot;&gt;QNetworkRequest&lt;/a&gt; class, which also acts as a general container for information associated with a request, such as any header information and the encryption used. The URL specified when a request object is constructed determines the protocol used for a request. Currently HTTP and local file URLs are supported for uploading and downloading.</source>
          <target state="translated">네트워크 요청은 &lt;a href=&quot;qnetworkrequest&quot;&gt;QNetworkRequest&lt;/a&gt; 클래스 로 표현되며, 헤더 정보 및 사용 된 암호화와 같은 요청과 관련된 정보에 대한 일반 컨테이너 역할도합니다. 요청 객체가 생성 될 때 지정된 URL은 요청에 사용되는 프로토콜을 결정합니다. 현재 HTTP 및 로컬 파일 URL은 업로드 및 다운로드에 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="4ae93f88b90fb554f1ec4ace44f8607c422018a9" translate="yes" xml:space="preserve">
          <source>Network requests are represented by the &lt;a href=&quot;qnetworkrequest&quot;&gt;QNetworkRequest&lt;/a&gt; class, which also acts as a general container for information associated with a request, such as any header information and the encryption used. The URL specified when a request object is constructed determines the protocol used for a request. Currently HTTP, FTP and local file URLs are supported for uploading and downloading.</source>
          <target state="translated">네트워크 요청은 &lt;a href=&quot;qnetworkrequest&quot;&gt;QNetworkRequest&lt;/a&gt; 클래스 로 표시되며 헤더 정보 및 사용 된 암호화와 같이 요청과 관련된 정보의 일반 컨테이너 역할도합니다. 요청 객체가 생성 될 때 지정된 URL에 따라 요청에 사용되는 프로토콜이 결정됩니다. 현재 HTTP, FTP 및 로컬 파일 URL이 업로드 및 다운로드를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="cd5740ff8ae4f7177682b3ddad6aeaefa7519f1b" translate="yes" xml:space="preserve">
          <source>Network requests can be re-enabled again, and this property will resume to reflect the actual device state by calling</source>
          <target state="translated">네트워크 요청을 다시 활성화 할 수 있으며이 속성은 호출하여 실제 장치 상태를 반영하도록 재개됩니다.</target>
        </trans-unit>
        <trans-unit id="c3843682b46348417c2347e94e0aff7fc484168d" translate="yes" xml:space="preserve">
          <source>Network sessions and their sockets can be bound to a particular network interface. Any packet that passes through the socket goes to the specified network interface and thus disregards standard routing table entries. This may be useful when two interfaces can reach overlapping IP ranges or an application has specific needs in regards to target networks. This option is platform specific and may not always be available.</source>
          <target state="translated">네트워크 세션 및 해당 소켓은 특정 네트워크 인터페이스에 바인딩 될 수 있습니다. 소켓을 통과하는 모든 패킷은 지정된 네트워크 인터페이스로 이동하여 표준 라우팅 테이블 항목을 무시합니다. 이는 두 개의 인터페이스가 겹치는 IP 범위에 도달 할 수 있거나 응용 프로그램이 대상 네트워크와 관련하여 특정 요구를 가질 때 유용 할 수 있습니다. 이 옵션은 플랫폼마다 다르며 항상 사용 가능한 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="9fbb4748621779ec7509721230f4503dd1d809a2" translate="yes" xml:space="preserve">
          <source>Network sessions and their underlying access points can be started and stopped. If this flag is not set &lt;a href=&quot;qnetworksession&quot;&gt;QNetworkSession&lt;/a&gt; can only monitor but not influence the state of access points. On some platforms this feature may require elevated user permissions. This option is platform specific and may not always be available.</source>
          <target state="translated">네트워크 세션 및 기본 액세스 포인트를 시작 및 중지 할 수 있습니다. 이 플래그를 설정하지 않으면 &lt;a href=&quot;qnetworksession&quot;&gt;QNetworkSession&lt;/a&gt; 은 액세스 포인트의 상태 만 모니터링 할 수 있지만 액세스 지점의 상태에는 영향을 미치지 않습니다. 일부 플랫폼에서이 기능을 사용하려면 관리자 권한이 필요할 수 있습니다. 이 옵션은 플랫폼마다 다르며 항상 사용 가능한 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="6ef8d5211bc6f52c757668554bc59adc2ff8b0d3" translate="yes" xml:space="preserve">
          <source>Network sessions and their underlying access points can be started and stopped. If this flag is not set QNetworkSession can only monitor but not influence the state of access points. On some platforms this feature may require elevated user permissions. This option is platform specific and may not always be available.</source>
          <target state="translated">네트워크 세션 및 기본 액세스 포인트를 시작하고 중지 할 수 있습니다. 이 플래그가 설정되지 않은 경우 QNetworkSession은 액세스 포인트의 상태를 모니터링 만 할 수 있지만 영향을주지 않습니다. 일부 플랫폼에서이 기능을 사용하려면 상승 된 사용자 권한이 필요할 수 있습니다. 이 옵션은 플랫폼에 따라 다르며 항상 사용할 수있는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="a69676fcdc1f2d151919e77d711a5028bc1333a7" translate="yes" xml:space="preserve">
          <source>Network transparency is supported throughout QML, for example, both the &lt;a href=&quot;qml-qtquick-fontloader&quot;&gt;FontLoader&lt;/a&gt; and Image elements support loading resources from a remote server.</source>
          <target state="translated">네트워크 투명성은 QML 전체에서 지원됩니다. 예를 들어 &lt;a href=&quot;qml-qtquick-fontloader&quot;&gt;FontLoader&lt;/a&gt; 와 Image 요소 는 모두 원격 서버에서 리소스로드를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="34779547842673e23547c90ab216735c476c2d2b" translate="yes" xml:space="preserve">
          <source>NetworkError</source>
          <target state="translated">NetworkError</target>
        </trans-unit>
        <trans-unit id="dea107426ef1db443907d1c3798ff6fa94b7e003" translate="yes" xml:space="preserve">
          <source>Never enable clipping on a delegate.</source>
          <target state="translated">델리게이트에서 클리핑을 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="58fe685cf90381161c20150a3b211841b8226735" translate="yes" xml:space="preserve">
          <source>Never pass alpha test</source>
          <target state="translated">알파 테스트를 통과하지 마십시오</target>
        </trans-unit>
        <trans-unit id="a5a0e91d171fd0fdc4657cae380224da9ca40d3b" translate="yes" xml:space="preserve">
          <source>Never pass depth test</source>
          <target state="translated">깊이 테스트를 통과하지 마십시오</target>
        </trans-unit>
        <trans-unit id="8d3605e2cfa415e50abb18eadca0727ed275e3fe" translate="yes" xml:space="preserve">
          <source>Never pass stencil test</source>
          <target state="translated">스텐실 테스트를 통과하지 마십시오</target>
        </trans-unit>
        <trans-unit id="6403f2b7eb2aaafe6de34cbf2a029b01afebc512" translate="yes" xml:space="preserve">
          <source>New</source>
          <target state="translated">New</target>
        </trans-unit>
        <trans-unit id="e692f48b2738f4d00602d796a97988fdb663f2c9" translate="yes" xml:space="preserve">
          <source>New &lt;a href=&quot;qmodelindex&quot;&gt;QModelIndex&lt;/a&gt; objects are created by the model using the &lt;a href=&quot;qabstractitemmodel#createIndex&quot;&gt;QAbstractItemModel::createIndex&lt;/a&gt;() function. An</source>
          <target state="translated">&lt;a href=&quot;qabstractitemmodel#createIndex&quot;&gt;QAbstractItemModel :: createIndex&lt;/a&gt; () 함수를 사용하여 모델에 의해 새로운 &lt;a href=&quot;qmodelindex&quot;&gt;QModelIndex&lt;/a&gt; 객체가 생성됩니다 . 안</target>
        </trans-unit>
        <trans-unit id="04d21f5a0f5485bf2ef2e4808496c8082ff1168d" translate="yes" xml:space="preserve">
          <source>New API</source>
          <target state="translated">새로운 API</target>
        </trans-unit>
        <trans-unit id="61fdf60db025e354e36ab5ade34865aa955dd73d" translate="yes" xml:space="preserve">
          <source>New Features by Qt Version</source>
          <target state="translated">Qt 버전 별 새로운 기능</target>
        </trans-unit>
        <trans-unit id="361050459eac59a904f8125c5e8a22df37d22eef" translate="yes" xml:space="preserve">
          <source>New QModelIndex objects are created by the model using the &lt;a href=&quot;qabstractitemmodel#createIndex&quot;&gt;QAbstractItemModel::createIndex&lt;/a&gt;() function. An</source>
          <target state="translated">새 QModelIndex 객체는 &lt;a href=&quot;qabstractitemmodel#createIndex&quot;&gt;QAbstractItemModel :: createIndex&lt;/a&gt; () 함수를 사용하여 모델에 의해 생성됩니다 . 안</target>
        </trans-unit>
        <trans-unit id="80967fb015a4e4ba38ebf8f9b739c05cbd696f17" translate="yes" xml:space="preserve">
          <source>New attributes can be added with &lt;a href=&quot;qxmlstreamattributes#append&quot;&gt;append&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qxmlstreamattributes#append&quot;&gt;추가&lt;/a&gt; ()를 사용 하여 새로운 속성을 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4e014265a9dabb6bd360017d64a872db38cce219" translate="yes" xml:space="preserve">
          <source>New columns have been inserted.</source>
          <target state="translated">새로운 열이 삽입되었습니다.</target>
        </trans-unit>
        <trans-unit id="7f02e6a14227b3e30e48fd333d46d61fd5d709f8" translate="yes" xml:space="preserve">
          <source>New commands are pushed on the stack using &lt;a href=&quot;qundostack#push&quot;&gt;push&lt;/a&gt;(). Commands can be undone and redone using &lt;a href=&quot;qundostack#undo&quot;&gt;undo&lt;/a&gt;() and &lt;a href=&quot;qundostack#redo&quot;&gt;redo&lt;/a&gt;(), or by triggering the actions returned by &lt;a href=&quot;qundostack#createUndoAction&quot;&gt;createUndoAction&lt;/a&gt;() and &lt;a href=&quot;qundostack#createRedoAction&quot;&gt;createRedoAction&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qundostack#push&quot;&gt;push&lt;/a&gt; ()를 사용하여 스택에서 새 명령을 푸시합니다 . &lt;a href=&quot;qundostack#undo&quot;&gt;undo&lt;/a&gt; () 및 &lt;a href=&quot;qundostack#redo&quot;&gt;redo&lt;/a&gt; ()를 사용하거나 &lt;a href=&quot;qundostack#createUndoAction&quot;&gt;createUndoAction&lt;/a&gt; () 및 &lt;a href=&quot;qundostack#createRedoAction&quot;&gt;createRedoAction&lt;/a&gt; ()에 의해 리턴 된 조치를 트리거하여 명령을 실행 취소 및 재실행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0014d9500233ac7b6c5e1d649091f020805e3278" translate="yes" xml:space="preserve">
          <source>New elements are created and inserted into the document programmatically &lt;a href=&quot;richtext-cursor&quot;&gt;with a QTextCursor&lt;/a&gt; or by using an editor widget, such as &lt;a href=&quot;qtextedit&quot;&gt;QTextEdit&lt;/a&gt;. Elements can be given a particular format when they are created; otherwise they take the cursor's current format for the element.</source>
          <target state="translated">&lt;a href=&quot;richtext-cursor&quot;&gt;QTextCursor&lt;/a&gt; 또는 &lt;a href=&quot;qtextedit&quot;&gt;QTextEdit&lt;/a&gt; 와 같은 편집기 위젯을 사용하여 프로그래밍 방식으로 새 요소가 작성되고 문서에 삽입됩니다 . 요소를 만들 때 특정 형식을 지정할 수 있습니다. 그렇지 않으면 요소에 대한 커서의 현재 형식을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="a058e02173269b9b582bdd9ec14678f854d88a07" translate="yes" xml:space="preserve">
          <source>New elements are created and inserted into the document programmatically &lt;a href=&quot;richtext-cursor#&quot;&gt;with a QTextCursor&lt;/a&gt; or by using an editor widget, such as &lt;a href=&quot;qtextedit&quot;&gt;QTextEdit&lt;/a&gt;. Elements can be given a particular format when they are created; otherwise they take the cursor's current format for the element.</source>
          <target state="translated">&lt;a href=&quot;richtext-cursor#&quot;&gt;QTextCursor&lt;/a&gt; 또는 &lt;a href=&quot;qtextedit&quot;&gt;QTextEdit&lt;/a&gt; 와 같은 편집기 위젯을 사용하여 프로그래밍 방식 으로 문서에 새 요소를 작성하고 삽입합니다 . 요소를 만들 때 특정 형식을 지정할 수 있습니다. 그렇지 않으면 요소의 커서의 현재 형식을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="0e9ecf8ee01c8dc951c9843de582a02711fa0ebf" translate="yes" xml:space="preserve">
          <source>New in Qt 5 are APIs for mobile platforms. These APIs access various hardware and mobile features. There are also APIs for extending support to other devices and platforms.</source>
          <target state="translated">Qt 5의 새로운 기능은 모바일 플랫폼 용 API입니다. 이 API는 다양한 하드웨어 및 모바일 기능에 액세스합니다. 다른 장치 및 플랫폼으로 지원을 확장하기위한 API도 있습니다.</target>
        </trans-unit>
        <trans-unit id="07e246fe0522072c5b9c92e8794e3d8295514c62" translate="yes" xml:space="preserve">
          <source>New in Qt 5.1, the model types are moved to a submodule, &lt;code&gt;QtQml.Models&lt;/code&gt;. The &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtqml-models-qmlmodule.html&quot;&gt;Qt QML Models&lt;/a&gt; page has more information.</source>
          <target state="translated">Qt 5.1의 새로운 기능으로 모델 유형이 하위 모듈 &lt;code&gt;QtQml.Models&lt;/code&gt; 로 이동되었습니다 . &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtqml-models-qmlmodule.html&quot;&gt;Qt는 QML 모델&lt;/a&gt; 페이지에 자세한 정보가 있습니다.</target>
        </trans-unit>
        <trans-unit id="d91497e9136cd7f9fffebebbf4fd19b562b73ab4" translate="yes" xml:space="preserve">
          <source>New in Qt 5.1, the model types are moved to a submodule, &lt;code&gt;QtQml.Models&lt;/code&gt;. The &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtqml-models-qmlmodule.html&quot;&gt;Qt QML Models&lt;/a&gt; page has more information.</source>
          <target state="translated">Qt 5.1의 새로운 기능으로 모델 유형이 하위 모듈 인 &lt;code&gt;QtQml.Models&lt;/code&gt; 로 이동되었습니다 . &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtqml-models-qmlmodule.html&quot;&gt;Qt는 QML 모델&lt;/a&gt; 페이지에 자세한 정보가 있습니다.</target>
        </trans-unit>
        <trans-unit id="156156de62c17525765e8d7134177033f7f7c86b" translate="yes" xml:space="preserve">
          <source>New in Qt 5.1, the model types are moved to a submodule, &lt;code&gt;QtQml.Models&lt;/code&gt;. The &lt;a href=&quot;https://doc.qt.io/qt-6.0/qtqml-models-qmlmodule.html&quot;&gt;Qt QML Models&lt;/a&gt; page has more information.</source>
          <target state="translated">Qt 5.1의 새로운 기능으로 모델 유형이 하위 모듈 인 &lt;code&gt;QtQml.Models&lt;/code&gt; 로 이동되었습니다 . &lt;a href=&quot;https://doc.qt.io/qt-6.0/qtqml-models-qmlmodule.html&quot;&gt;Qt는 QML 모델&lt;/a&gt; 페이지에 자세한 정보가 있습니다.</target>
        </trans-unit>
        <trans-unit id="51115f3a9ea394e340c0fc52dbd7e0185a63d0ff" translate="yes" xml:space="preserve">
          <source>New in Qt 5.4: &lt;a href=&quot;qtabletevent&quot;&gt;QTabletEvent&lt;/a&gt; includes all information available from the device, including &lt;a href=&quot;qtabletevent#buttons&quot;&gt;QTabletEvent::buttons&lt;/a&gt;(). Previously it was not possible to accept all tablet events and also know which stylus buttons were pressed.</source>
          <target state="translated">Qt 5.4의 새로운 기능 : &lt;a href=&quot;qtabletevent&quot;&gt;QTabletEvent&lt;/a&gt; 에는 &lt;a href=&quot;qtabletevent#buttons&quot;&gt;QTabletEvent :: buttons&lt;/a&gt; ()를 포함하여 장치에서 사용 가능한 모든 정보가 포함됩니다 . 이전에는 모든 태블릿 이벤트를 수락 할 수 없었으며 어떤 스타일러스 버튼을 눌렀는지 알 수 없었습니다.</target>
        </trans-unit>
        <trans-unit id="90966e35f30e2a81941d30cd8ad3fa8273c8338e" translate="yes" xml:space="preserve">
          <source>New in Qt 5.4: QTabletEvent includes all information available from the device, including &lt;a href=&quot;qtabletevent#buttons&quot;&gt;QTabletEvent::buttons&lt;/a&gt;(). Previously it was not possible to accept all tablet events and also know which stylus buttons were pressed.</source>
          <target state="translated">Qt 5.4의 새로운 기능 : QTabletEvent에는 &lt;a href=&quot;qtabletevent#buttons&quot;&gt;QTabletEvent :: buttons&lt;/a&gt; ()를 포함하여 장치에서 사용할 수있는 모든 정보가 포함됩니다 . 이전에는 모든 태블릿 이벤트를 수락하고 어떤 스타일러스 버튼을 눌렀는지 알 수 없었습니다.</target>
        </trans-unit>
        <trans-unit id="e30563ec05586a0d7ca77445292f3b96e1f4a0e2" translate="yes" xml:space="preserve">
          <source>New items are appended to playlist.</source>
          <target state="translated">새로운 아이템이 플레이리스트에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="35d125e4b3fc381f83e847a8e3cb48ad7d664850" translate="yes" xml:space="preserve">
          <source>New items are appended to the playlist.</source>
          <target state="translated">새 항목이 재생 목록에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="c1d2bcab6dc89047c4871e3c17194fa8e6db9790" translate="yes" xml:space="preserve">
          <source>New keys are added to the keyboard row using the Key type or one of the specialized key types. Below is the list of all key types:</source>
          <target state="translated">키 유형 또는 특수 키 유형 중 하나를 사용하여 새 키가 키보드 행에 추가됩니다. 다음은 모든 키 유형의 목록입니다.</target>
        </trans-unit>
        <trans-unit id="fb9d07655f7e10f46411baa452d99758979a8e3e" translate="yes" xml:space="preserve">
          <source>New models can be created by implementing the standard interface provided by &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt;. In the &lt;a href=&quot;#creating-new-models&quot;&gt;Creating New Models&lt;/a&gt; section, we demonstrate this by creating a convenient ready-to-use model for holding lists of strings.</source>
          <target state="translated">&lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel에서&lt;/a&gt; 제공하는 표준 인터페이스를 구현하여 새 모델을 작성할 수 있습니다 . 에서 &lt;a href=&quot;#creating-new-models&quot;&gt;만들기 새로운 모델&lt;/a&gt; 섹션, 우리는 문자열의 목록을 유지하기위한 편리한 바로 사용할 수있는 모델을 만들어이를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="572767d3f5d856d8dc6525093aea6d4d76e26f46" translate="yes" xml:space="preserve">
          <source>New models can be created by implementing the standard interface provided by &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt;. In the &lt;a href=&quot;model-view-programming#creating-new-models&quot;&gt;Creating New Models&lt;/a&gt; section, we demonstrate this by creating a convenient ready-to-use model for holding lists of strings.</source>
          <target state="translated">&lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel에서&lt;/a&gt; 제공하는 표준 인터페이스를 구현하여 새 모델을 만들 수 있습니다 . 에서 &lt;a href=&quot;model-view-programming#creating-new-models&quot;&gt;만들기 새로운 모델&lt;/a&gt; 섹션, 우리는 문자열의 목록을 유지하기위한 편리한 바로 사용할 수있는 모델을 만들어이를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="c1500b9bb97e79146482fd1717c74ee463083ffa" translate="yes" xml:space="preserve">
          <source>New notifications that have the same tag and origin URL as an existing one should replace or update the old notification with the same tag.</source>
          <target state="translated">기존 알림과 동일한 태그 및 원본 URL을 가진 새 알림은 기존 알림을 동일한 태그로 바꾸거나 업데이트해야합니다.</target>
        </trans-unit>
        <trans-unit id="04aa653edbc577a885862c83472e8cffe223796a" translate="yes" xml:space="preserve">
          <source>New rendering backend</source>
          <target state="translated">새로운 렌더링 백엔드</target>
        </trans-unit>
        <trans-unit id="3a621ccb1112ab557a38846c4ef75a04b6477595" translate="yes" xml:space="preserve">
          <source>New rows are added to the keyboard layout by using the &lt;a href=&quot;qml-qtquick-virtualkeyboard-keyboardrow&quot;&gt;KeyboardRow&lt;/a&gt; type. The &lt;a href=&quot;qml-qtquick-virtualkeyboard-keyboardrow&quot;&gt;KeyboardRow&lt;/a&gt; can also specify the default key weight for its child elements. Otherwise, the key weight is inherited from its parent element.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-virtualkeyboard-keyboardrow&quot;&gt;KeyboardRow&lt;/a&gt; 유형 을 사용하여 키보드 레이아웃에 새 행이 추가됩니다 . &lt;a href=&quot;qml-qtquick-virtualkeyboard-keyboardrow&quot;&gt;KeyboardRow는&lt;/a&gt; 또한 자식 요소에 대한 기본 키 무게를 지정할 수 있습니다. 그렇지 않으면 키 가중치가 부모 요소에서 상속됩니다.</target>
        </trans-unit>
        <trans-unit id="314d5e091046d422250753131c0eec56edfbd1be" translate="yes" xml:space="preserve">
          <source>New rows have been inserted.</source>
          <target state="translated">새로운 행이 삽입되었습니다.</target>
        </trans-unit>
        <trans-unit id="a9c243b8bd0a77f64fa2d07c4df3e263f15a5aca" translate="yes" xml:space="preserve">
          <source>New token credentials have been requested.</source>
          <target state="translated">새로운 토큰 자격 증명이 요청되었습니다.</target>
        </trans-unit>
        <trans-unit id="48a556328274c77e87cf68df5bdebcf9f606ca44" translate="yes" xml:space="preserve">
          <source>NewViewDestination : &lt;a href=&quot;qml-enumeration&quot;&gt;enumeration&lt;/a&gt;</source>
          <target state="translated">NewViewDestination : &lt;a href=&quot;qml-enumeration&quot;&gt;열거&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="18327acb0f1df9c5f31d85b301e4d796e2a2bce5" translate="yes" xml:space="preserve">
          <source>Newer versions of qmake will generate Info.plist's with the NSPrincipalClass key, which is sufficient since NSHighResolutionCapable is true by default.</source>
          <target state="translated">최신 버전의 qmake는 NSPrincipalClass 키를 사용하여 Info.plist를 생성합니다. NSHighResolutionCapable이 기본적으로 true이기 때문에 충분합니다.</target>
        </trans-unit>
        <trans-unit id="0ff6662e4ff3b9ee5c50dba9798a5a8ccfd7a011" translate="yes" xml:space="preserve">
          <source>Newer versions of qmake will generate an &lt;code&gt;Info.plist&lt;/code&gt; file with the NSPrincipalClass key; this is sufficient since NSHighResolutionCapable is true by default.</source>
          <target state="translated">최신 버전의 qmake는 NSPrincipalClass 키를 사용하여 &lt;code&gt;Info.plist&lt;/code&gt; 파일을 생성합니다 . NSHighResolutionCapable이 기본적으로 true이기 때문에 충분합니다.</target>
        </trans-unit>
        <trans-unit id="1c72f2306b72c5bd74a5f2655a324a7482895537" translate="yes" xml:space="preserve">
          <source>Newline characters are processed as line breaks.</source>
          <target state="translated">줄 바꿈 문자는 줄 바꿈으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="54997c392215fd56dfe5ea6e0de107f9aaa4ab98" translate="yes" xml:space="preserve">
          <source>Newline characters are processed as linebreaks.</source>
          <target state="translated">줄 바꿈 문자는 줄 바꿈으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="4adc08960da3bfd996a283b078b05315ab4444fd" translate="yes" xml:space="preserve">
          <source>Newline characters are processed as normal characters,</source>
          <target state="translated">줄 바꿈 문자는 일반 문자로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="34c808d0a63f277e04fb23a5f76cc83d0a3e024b" translate="yes" xml:space="preserve">
          <source>News</source>
          <target state="translated">News</target>
        </trans-unit>
        <trans-unit id="0d576c47b08b94f9ffe1e763609b2e21d10780b8" translate="yes" xml:space="preserve">
          <source>Next DST change UUID (service). The service defines how the information about an upcoming DST change can be exposed.</source>
          <target state="translated">다음 DST는 UUID (서비스)를 변경합니다. 이 서비스는 예정된 DST 변경에 대한 정보가 노출되는 방법을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="56a062053b89a63fdaba8b7b85a3fb8b0a19fb86" translate="yes" xml:space="preserve">
          <source>Next are the steps for creating the replica side of the network, which in this example gets the state of switch from the &lt;a href=&quot;qtremoteobjects-source#source&quot;&gt;Source&lt;/a&gt; and echoes it back.</source>
          <target state="translated">다음은 네트워크의 복제본 측을 작성하는 단계입니다.이 예에서는 &lt;a href=&quot;qtremoteobjects-source#source&quot;&gt;소스&lt;/a&gt; 에서 스위치 상태를 가져 와서 에코합니다.</target>
        </trans-unit>
        <trans-unit id="11fc14203dd0f4441645a9c34d5dd022905f56e4" translate="yes" xml:space="preserve">
          <source>Next steps</source>
          <target state="translated">다음 단계</target>
        </trans-unit>
        <trans-unit id="5c57a98602832ebc8af6cc6617c360cbe2241bbd" translate="yes" xml:space="preserve">
          <source>Next to the viewport is a vertical scroll bar, and below is a horizontal scroll bar. When all of the area contents fits in the viewport, each scroll bar can be either visible or hidden depending on the scroll bar's &lt;a href=&quot;qt#ScrollBarPolicy-enum&quot;&gt;Qt::ScrollBarPolicy&lt;/a&gt;. When a scroll bar is hidden, the viewport expands in order to cover all available space. When a scroll bar becomes visible again, the viewport shrinks in order to make room for the scroll bar.</source>
          <target state="translated">뷰포트 옆에는 세로 스크롤 막대가 있고 아래에는 가로 스크롤 막대가 있습니다. 모든 영역 내용이 뷰포트에 맞으면 스크롤 막대의 &lt;a href=&quot;qt#ScrollBarPolicy-enum&quot;&gt;Qt :: ScrollBarPolicy&lt;/a&gt; 에 따라 각 스크롤 막대를 표시하거나 숨길 수 있습니다 . 스크롤 막대가 숨겨지면 사용 가능한 모든 공간을 포함하기 위해 뷰포트가 확장됩니다. 스크롤 막대가 다시 표시되면 스크롤 막대를위한 공간을 만들기 위해 뷰포트가 축소됩니다.</target>
        </trans-unit>
        <trans-unit id="ff8e0538b6cdc84b7fb8de5a356ce2e6a4cc9a74" translate="yes" xml:space="preserve">
          <source>Next, QDoc uses the values of the &lt;a href=&quot;22-qdoc-configuration-generalvariables#headerdirs-variable&quot;&gt;headerdirs&lt;/a&gt; variable and/or the &lt;a href=&quot;22-qdoc-configuration-generalvariables#headers-variable&quot;&gt;headers&lt;/a&gt; variable to find and parse all the header files for your project. QDoc does</source>
          <target state="translated">다음으로 QDoc은 &lt;a href=&quot;22-qdoc-configuration-generalvariables#headerdirs-variable&quot;&gt;headerdirs&lt;/a&gt; 변수 및 / 또는 &lt;a href=&quot;22-qdoc-configuration-generalvariables#headers-variable&quot;&gt;headers&lt;/a&gt; 변수 의 값을 사용 하여 프로젝트의 모든 헤더 파일을 찾고 구문 분석합니다. QDoc은 않습니다</target>
        </trans-unit>
        <trans-unit id="b502e971b719551f31b749185d8552be58007ba0" translate="yes" xml:space="preserve">
          <source>Next, consider the</source>
          <target state="translated">다음으로,</target>
        </trans-unit>
        <trans-unit id="6c4fd65289cec57746939715b87c3b0c31700e54" translate="yes" xml:space="preserve">
          <source>Next, open the style.qml in your favorite editor and set the resourcePrefix property to an empty string. The resource prefix is not needed as the resources are contained in the same directory as the style.qml file.</source>
          <target state="translated">그런 다음 선호하는 편집기에서 style.qml을 열고 resourcePrefix 속성을 빈 문자열로 설정하십시오. 자원이 style.qml 파일과 동일한 디렉토리에 포함되므로 자원 접 두부가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3c39efb223c9bf4935c9875111393c2ca2485e60" translate="yes" xml:space="preserve">
          <source>Next, select &lt;b&gt;File &amp;gt; Export Selection&lt;/b&gt; and open the dialog box.</source>
          <target state="translated">다음으로 &lt;b&gt;파일&amp;gt; 선택 내보내기를 선택&lt;/b&gt; 하고 대화 상자를 엽니 다.</target>
        </trans-unit>
        <trans-unit id="b5bd8cc7178bbedf1bea2d0fd2c01d0df30e5d7b" translate="yes" xml:space="preserve">
          <source>Next, select &lt;b&gt;System &amp;gt; Preferences&lt;/b&gt; from the menu bar to configure the COLLADA exporter.</source>
          <target state="translated">그런 다음 메뉴 모음에서 &lt;b&gt;시스템&amp;gt; 기본 설정&lt;/b&gt; 을 선택 하여 COLLADA 내보내기를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="d7273da0c50871f28072ff67fe3db8a78261e0d4" translate="yes" xml:space="preserve">
          <source>Next, the accessible interface needs to return the &lt;a href=&quot;qaccessible-state&quot;&gt;states&lt;/a&gt; that the slider can be in. We look at parts of the &lt;code&gt;state()&lt;/code&gt; implementation to show how just a few of the states are handled:</source>
          <target state="translated">다음으로, 접근 가능한 인터페이스 는 슬라이더가있을 수있는 &lt;a href=&quot;qaccessible-state&quot;&gt;상태&lt;/a&gt; 를 반환해야합니다 . &lt;code&gt;state()&lt;/code&gt; 구현 의 일부를 살펴보고 몇 가지 상태 만 처리하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="e1fc4dd7af3dee434e7ae145a1d5d1fab45cf863" translate="yes" xml:space="preserve">
          <source>Next, to export as FBX, follow these steps:</source>
          <target state="translated">다음으로 FBX로 내보내려면 다음 단계를 따르십시오.</target>
        </trans-unit>
        <trans-unit id="0b23857f84005ab780e2792e176c6ca18c923515" translate="yes" xml:space="preserve">
          <source>Next, we add a drop shadow to the &lt;a href=&quot;qml-qtquick-controls2-control#background-prop&quot;&gt;background&lt;/a&gt; delegate of the Button:</source>
          <target state="translated">다음으로, Button 의 &lt;a href=&quot;qml-qtquick-controls2-control#background-prop&quot;&gt;백그라운드&lt;/a&gt; 델리게이트에 그림자를 추가합니다 :</target>
        </trans-unit>
        <trans-unit id="23cad55f2d72d89c0fb39979a296cd6c4e0ed76e" translate="yes" xml:space="preserve">
          <source>Next, we add the states to the machine and set the machine's initial state:</source>
          <target state="translated">다음으로 머신에 상태를 추가하고 머신의 초기 상태를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="9ef328a8b442909510e08a0779dd0bb8cf1f5c54" translate="yes" xml:space="preserve">
          <source>Next, we define a transition that only triggers when the event's string matches a particular string (a</source>
          <target state="translated">다음으로, 이벤트 문자열이 특정 문자열과 일치 할 때만 트리거되는 전환을 정의합니다 (</target>
        </trans-unit>
        <trans-unit id="b0a52f8833c80087adf66e547734b5fce510688f" translate="yes" xml:space="preserve">
          <source>Next, we do the drawing of the range using Canvas. We draw an arc between &lt;code&gt;80&lt;/code&gt; and &lt;code&gt;100&lt;/code&gt;, using the &lt;a href=&quot;qml-qtquick-controls-styles-circulargaugestyle#valueToAngle-method&quot;&gt;valueToAngle()&lt;/a&gt; function provided by &lt;a href=&quot;qml-qtquick-controls-styles-circulargaugestyle&quot;&gt;CircularGaugeStyle&lt;/a&gt;. Note that we subtract &lt;code&gt;90&lt;/code&gt; degrees before converting to radians, as our origin is north and Canvas' is east.</source>
          <target state="translated">다음으로 Canvas를 사용하여 범위를 그립니다. &lt;a href=&quot;qml-qtquick-controls-styles-circulargaugestyle&quot;&gt;CircularGaugeStyle에서&lt;/a&gt; 제공 하는 &lt;a href=&quot;qml-qtquick-controls-styles-circulargaugestyle#valueToAngle-method&quot;&gt;valueToAngle ()&lt;/a&gt; 함수를 사용하여 &lt;code&gt;80&lt;/code&gt; 에서 &lt;code&gt;100&lt;/code&gt; 사이의 호 를 그 립니다 . 원점이 북쪽이고 캔버스가 동쪽이므로 라디안으로 변환하기 전에 &lt;code&gt;90&lt;/code&gt; 도를 뺍니다 .</target>
        </trans-unit>
        <trans-unit id="ee7c14baa789f3e42cf1ce249b35e1936228b904" translate="yes" xml:space="preserve">
          <source>Next, you will be prompted with another set of options for the OpenCOLLADA exporter.</source>
          <target state="translated">다음으로 OpenCOLLADA 내보내기에 대한 다른 옵션 세트가 프롬프트됩니다.</target>
        </trans-unit>
        <trans-unit id="f9ac82c49effe69ef78eddce3c2ed11aa7a10076" translate="yes" xml:space="preserve">
          <source>NextChild</source>
          <target state="translated">NextChild</target>
        </trans-unit>
        <trans-unit id="e9fec9e65b91d5db209df0d19cfdb76a2c363232" translate="yes" xml:space="preserve">
          <source>Night mode.</source>
          <target state="translated">야간 모드.</target>
        </trans-unit>
        <trans-unit id="d1976440ed42093ae1726cd2f4f8b64eb6c47468" translate="yes" xml:space="preserve">
          <source>Night portrait exposure mode. Since 5.5</source>
          <target state="translated">야간 인물 노출 모드. 5.5 이후</target>
        </trans-unit>
        <trans-unit id="ef165312db87ccd0d24bacc7eec9dc0c2029a90a" translate="yes" xml:space="preserve">
          <source>Night portrait mode. Since 5.5</source>
          <target state="translated">야간 인물 모드. 5.5 이후</target>
        </trans-unit>
        <trans-unit id="6b02b7df1044b2c74b279fce00e1202b9e163aae" translate="yes" xml:space="preserve">
          <source>Nine transform origins are available, as shown in the image below. The default transform origin is &lt;code&gt;Item.Center&lt;/code&gt;.</source>
          <target state="translated">아래 이미지와 같이 9 개의 변형 원점이 제공됩니다. 기본 변형 원점은 &lt;code&gt;Item.Center&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="45890d738a7db6808f72171f4765dceb65e04b98" translate="yes" xml:space="preserve">
          <source>Nine transform origins are available, as shown in the image below. The default transform origin is &lt;code&gt;Popup.Center&lt;/code&gt;.</source>
          <target state="translated">아래 이미지와 같이 9 개의 변형 원점이 제공됩니다. 기본 변형 원점은 &lt;code&gt;Popup.Center&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3887b8f0439f9f3a31f85fb0bde22ac313a518b0" translate="yes" xml:space="preserve">
          <source>Ninja (available in the Qt online installer)</source>
          <target state="translated">Ninja (Qt 온라인 설치 프로그램에서 사용 가능)</target>
        </trans-unit>
        <trans-unit id="816c52fd2bdd94a63cd0944823a6c0aa9384c103" translate="yes" xml:space="preserve">
          <source>No</source>
          <target state="translated">No</target>
        </trans-unit>
        <trans-unit id="b675387782efab72197aa98a67a0afd145bb6448" translate="yes" xml:space="preserve">
          <source>No Copy Constructor or Assignment Operator</source>
          <target state="translated">복사 생성자 또는 할당 연산자가 없음</target>
        </trans-unit>
        <trans-unit id="bab4ee14cc6afec365b483534407ec3965c0e6c6" translate="yes" xml:space="preserve">
          <source>No Errors</source>
          <target state="translated">오류 없음</target>
        </trans-unit>
        <trans-unit id="141b747cda96c4546b7b11c5f4f2fe5e2f342cd9" translate="yes" xml:space="preserve">
          <source>No Errors.</source>
          <target state="translated">오류가 없습니다.</target>
        </trans-unit>
        <trans-unit id="4a248ecf468850aaa357493594e17912cb614a71" translate="yes" xml:space="preserve">
          <source>No IP addresses were found for the host.</source>
          <target state="translated">호스트의 IP 주소가 없습니다.</target>
        </trans-unit>
        <trans-unit id="139924b239f30c1775a930daa4efd2b561d02171" translate="yes" xml:space="preserve">
          <source>No Limits</source>
          <target state="translated">제한 없음</target>
        </trans-unit>
        <trans-unit id="8ea2b99bd7287035d40bf874de8ac4011e686daa" translate="yes" xml:space="preserve">
          <source>No Predecessor</source>
          <target state="translated">전임자 없음</target>
        </trans-unit>
        <trans-unit id="c7e9a767ec6a5a9b325c919e143ccdff6481f048" translate="yes" xml:space="preserve">
          <source>No QEventLoops will be started anymore in this thread until &lt;a href=&quot;qthread#exec&quot;&gt;QThread::exec&lt;/a&gt;() has been called again. If the eventloop in &lt;a href=&quot;qthread#exec&quot;&gt;QThread::exec&lt;/a&gt;() is not running then the next call to &lt;a href=&quot;qthread#exec&quot;&gt;QThread::exec&lt;/a&gt;() will also return immediately.</source>
          <target state="translated">&lt;a href=&quot;qthread#exec&quot;&gt;QThread :: exec&lt;/a&gt; ()가 다시 호출 될 때까지이 스레드에서 더 이상 QEventLoops가 시작되지 않습니다 . 에서 eventloop 경우 &lt;a href=&quot;qthread#exec&quot;&gt;QThread :: 간부는&lt;/a&gt; () 다음에 다음 호출 실행되지 &lt;a href=&quot;qthread#exec&quot;&gt;QThread :: 간부를&lt;/a&gt; () 즉시 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1c382e8186686538518fc13d7192925f6a2d01d3" translate="yes" xml:space="preserve">
          <source>No Translation</source>
          <target state="translated">번역 없음</target>
        </trans-unit>
        <trans-unit id="85c001fea2dc345212885b257f2f7d1f69a4d6df" translate="yes" xml:space="preserve">
          <source>No Year 0</source>
          <target state="translated">년 없음 0</target>
        </trans-unit>
        <trans-unit id="7b4ef7fc27480f9491fa97e2ac7e874856f22494" translate="yes" xml:space="preserve">
          <source>No access restrictions have been set.</source>
          <target state="translated">액세스 제한이 설정되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="04009cfb37629dd663905e3a6bba0030c7801b8c" translate="yes" xml:space="preserve">
          <source>No access restrictions.</source>
          <target state="translated">액세스 제한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="f6a5cc3d225bade067021b817572f4f5b3fb1339" translate="yes" xml:space="preserve">
          <source>No action is triggered.</source>
          <target state="translated">동작이 트리거되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e6168c5b0c4c8610d753397daa516d9f08362fb5" translate="yes" xml:space="preserve">
          <source>No anchor, i.e. the view leaves the scene's position unchanged.</source>
          <target state="translated">앵커가 없습니다. 즉, 뷰는 장면의 위치를 ​​변경하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4b11823279d6206d6996d599e10bfbabbfedb98a" translate="yes" xml:space="preserve">
          <source>No anisotropic filtering.</source>
          <target state="translated">이방성 필터링이 없습니다.</target>
        </trans-unit>
        <trans-unit id="2ea6435a49915355a708b0c4cbe29af050112b17" translate="yes" xml:space="preserve">
          <source>No antialiasing is applied.</source>
          <target state="translated">앤티 앨리어싱이 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e4e0f15c38295e273af7d4270ce2aade4f61a9f2" translate="yes" xml:space="preserve">
          <source>No application protocol has been negotiated (yet).</source>
          <target state="translated">응용 프로그램 프로토콜이 협상되지 않았습니다 (아직).</target>
        </trans-unit>
        <trans-unit id="264053098d4cff51b15a541994ab25a8a043f48d" translate="yes" xml:space="preserve">
          <source>No attachment is added to the framebuffer object. Note that the OpenGL depth and stencil tests won't work when rendering to a framebuffer object without any depth or stencil buffers. This is the default value.</source>
          <target state="translated">프레임 버퍼 객체에 첨부 파일이 추가되지 않습니다. OpenGL 깊이 및 스텐실 테스트는 깊이 또는 스텐실 버퍼가없는 프레임 버퍼 객체로 렌더링 할 때는 작동하지 않습니다. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="d079b13c09793ea5369fd9123867bd738a00db36" translate="yes" xml:space="preserve">
          <source>No automatic rotation is applied to the reading values.</source>
          <target state="translated">판독 값에는 자동 회전이 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6b88617c3bc86ff939aa39a1504db05c6d6378ec" translate="yes" xml:space="preserve">
          <source>No boundary (use the whole text).</source>
          <target state="translated">경계가 없습니다 (전체 텍스트 사용).</target>
        </trans-unit>
        <trans-unit id="4939272d7b5e43e143c38edff33f3f322046fe23" translate="yes" xml:space="preserve">
          <source>No brush pattern.</source>
          <target state="translated">브러시 패턴이 없습니다.</target>
        </trans-unit>
        <trans-unit id="c105c4bfbee6f6fa2975caf0b2d3ce8e8b20e08f" translate="yes" xml:space="preserve">
          <source>No buffers will be cleared</source>
          <target state="translated">버퍼가 지워지지 않습니다</target>
        </trans-unit>
        <trans-unit id="a11fe2d5e8ea396f13acf4eb2ea379ad79b07b57" translate="yes" xml:space="preserve">
          <source>No camera service available.</source>
          <target state="translated">카메라 서비스가 없습니다.</target>
        </trans-unit>
        <trans-unit id="dd31b7f1b31d0ff9fea98030dd38a63ade74042f" translate="yes" xml:space="preserve">
          <source>No capitalization change is applied.</source>
          <target state="translated">대소 문자 변경이 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4d235224df8d216b932e6c7ce54dfab263559dd1" translate="yes" xml:space="preserve">
          <source>No category fetch query has been executed. The model is empty.</source>
          <target state="translated">카테고리 페치 조회가 실행되지 않았습니다. 모델이 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef70b2a7a29159d99839ca60207426a164b0241c" translate="yes" xml:space="preserve">
          <source>No cells have been added or removed, but the data of the specified cell range is invalid.</source>
          <target state="translated">추가 또는 제거 된 셀이 없지만 지정된 셀 범위의 데이터가 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="67c96a977cfc9d134925bbc4ef08f3dafa3cfc4f" translate="yes" xml:space="preserve">
          <source>No change in interpretation; this tag can be used as the outermost tag in a CBOR stream as the file header.</source>
          <target state="translated">해석에는 변화가 없습니다. 이 태그는 CBOR 스트림에서 파일 헤더로 가장 바깥 쪽 태그로 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a5afe3485bbdcbfa9aec3b7b14a0e83ec94b0ecc" translate="yes" xml:space="preserve">
          <source>No check is made to ensure that a directory with this name actually exists; but see &lt;a href=&quot;qdir#exists-1&quot;&gt;exists&lt;/a&gt;().</source>
          <target state="translated">이 이름의 디렉토리가 실제로 존재하는지 확인하지 않습니다. 그러나 &lt;a href=&quot;qdir#exists-1&quot;&gt;존재&lt;/a&gt; ()를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="40d786a9defb8616cfb0a7c4cf5e9d5f76b5ed7b" translate="yes" xml:space="preserve">
          <source>No check options are specified.</source>
          <target state="translated">점검 옵션이 지정되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="574e02572bc511f5d7dd1f6a52d85d7e02c1a7af" translate="yes" xml:space="preserve">
          <source>No color space is specified.</source>
          <target state="translated">색 공간이 지정되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="dc56f47fa564c2bcc9ee4bebdde8838211d74d71" translate="yes" xml:space="preserve">
          <source>No content is currently set to be shared.</source>
          <target state="translated">현재 공유하도록 설정된 컨텐츠가 없습니다.</target>
        </trans-unit>
        <trans-unit id="939ac7ce158cdf95d68f8b029cbfcb78ede5c93d" translate="yes" xml:space="preserve">
          <source>No conversion options are set.</source>
          <target state="translated">변환 옵션이 설정되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="2072cd1a6c5cc937c3e053d8f7086a3ab6281073" translate="yes" xml:space="preserve">
          <source>No cutoff test is applied, but guarantees that alpha blending happens. The object with this material will therefore never be treated as opaque by the renderer.</source>
          <target state="translated">컷오프 테스트는 적용되지 않지만 알파 블렌딩이 발생하도록 보장합니다. 따라서이 재질이있는 오브젝트는 렌더러에서 불투명으로 취급되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6a099223a07e854be9e6513cd0825d1c28ab220b" translate="yes" xml:space="preserve">
          <source>No data is available.</source>
          <target state="translated">사용 가능한 데이터가 없습니다.</target>
        </trans-unit>
        <trans-unit id="666ad0ec21e013b6263533384d4a5ad0c1eeb533" translate="yes" xml:space="preserve">
          <source>No data loss possible</source>
          <target state="translated">가능한 데이터 손실 없음</target>
        </trans-unit>
        <trans-unit id="cdc6f08ea76fdcdb3b0b04b0e6a331497c954644" translate="yes" xml:space="preserve">
          <source>No data type.</source>
          <target state="translated">데이터 유형이 없습니다.</target>
        </trans-unit>
        <trans-unit id="e184267359c0456bc3ac6acf7ddf786a57c64d26" translate="yes" xml:space="preserve">
          <source>No defined element.</source>
          <target state="translated">정의 된 요소가 없습니다.</target>
        </trans-unit>
        <trans-unit id="2cff6611e5d5b95fb991ec425c9f1cab184b1aef" translate="yes" xml:space="preserve">
          <source>No device, or an unknown device.</source>
          <target state="translated">장치가 없거나 알 수없는 장치입니다.</target>
        </trans-unit>
        <trans-unit id="646a470976530b94c9a8e0ec1779382c646ec240" translate="yes" xml:space="preserve">
          <source>No dithering; closest color is used.</source>
          <target state="translated">디더링 없음; 가장 가까운 색이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="61beb52839dfb96786856b3d1fdd64dccb6b083a" translate="yes" xml:space="preserve">
          <source>No edge defined.</source>
          <target state="translated">정의 된 모서리가 없습니다.</target>
        </trans-unit>
        <trans-unit id="7d1b6ad5067f8d63b63c11a2e0234f14d6df136c" translate="yes" xml:space="preserve">
          <source>No edge.</source>
          <target state="translated">가장자리가 없습니다.</target>
        </trans-unit>
        <trans-unit id="31ecff337b26af4b7af6985ee5d9d62712ab7205" translate="yes" xml:space="preserve">
          <source>No editing possible.</source>
          <target state="translated">편집 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f686c517d76217d9cac13ca62f66efa6f61a18a7" translate="yes" xml:space="preserve">
          <source>No error has occurred</source>
          <target state="translated">오류가 발생하지 않았습니다</target>
        </trans-unit>
        <trans-unit id="b297df8f20cb042c6015714d6d62f91da3d77999" translate="yes" xml:space="preserve">
          <source>No error has occurred.</source>
          <target state="translated">오류가 발생하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="fc04fb845df75620ad37b0adde0194b02c1de048" translate="yes" xml:space="preserve">
          <source>No error has ocurred.</source>
          <target state="translated">오류가 발생하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="1d17c3343039e9ef19537cc72ba278d93078f748" translate="yes" xml:space="preserve">
          <source>No error occurred</source>
          <target state="translated">오류가 발생하지 않았습니다</target>
        </trans-unit>
        <trans-unit id="54362618eb30cb24ffaf007c0744b28f171163b3" translate="yes" xml:space="preserve">
          <source>No error occurred during the last operation, further operations may be performed on the category.</source>
          <target state="translated">마지막 작업 중에 오류가 발생하지 않았으므로 카테고리에서 추가 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="51b503f9f76f99f5545803f0c4a71dc531f17025" translate="yes" xml:space="preserve">
          <source>No error occurred during the last operation, further operations may be performed on the model.</source>
          <target state="translated">마지막 작업 중에 오류가 발생하지 않았으므로 모델에서 추가 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8402e6d7a81e23e60690e37e2bd8df7e0299088e" translate="yes" xml:space="preserve">
          <source>No error occurred during the last operation, further operations may be performed on the place.</source>
          <target state="translated">마지막 작업 중에 오류가 발생하지 않았으므로 해당 위치에서 추가 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eadca53bbf3975e5003a4dc25df2eaf833e00bfa" translate="yes" xml:space="preserve">
          <source>No error occurred, the last operation was successful.</source>
          <target state="translated">오류가 발생하지 않았으며 마지막 작업이 성공했습니다.</target>
        </trans-unit>
        <trans-unit id="281eed53295232d9bad65334e54a575ab5a0db5a" translate="yes" xml:space="preserve">
          <source>No error occurred.</source>
          <target state="translated">오류가 발생하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="9c2aca925e5e82770d198d24c0d9e6b051f92641" translate="yes" xml:space="preserve">
          <source>No error was detected.</source>
          <target state="translated">오류가 감지되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="b2f69b3d1ffe4476f9895565ab3c472eb9a4deae" translate="yes" xml:space="preserve">
          <source>No error.</source>
          <target state="translated">오류가 없습니다.</target>
        </trans-unit>
        <trans-unit id="c5eee9890ef65849861afc1be69d2e2747a38a42" translate="yes" xml:space="preserve">
          <source>No error. Used for testing.</source>
          <target state="translated">오류가 없습니다. 테스트에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="605256a55d0aaa5b8f371f89d7e258ce838bfef1" translate="yes" xml:space="preserve">
          <source>No errors</source>
          <target state="translated">오류 없음</target>
        </trans-unit>
        <trans-unit id="9f2e1ba38052da1b983266bfbc2c413575cd39ce" translate="yes" xml:space="preserve">
          <source>No errors have occurred</source>
          <target state="translated">오류가 발생하지 않았습니다</target>
        </trans-unit>
        <trans-unit id="cdf7ef05c0fdf47d6fcf496330a2b9cc8553655c" translate="yes" xml:space="preserve">
          <source>No errors have occurred.</source>
          <target state="translated">오류가 발생하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="737dae0b51bce2e6e2820bc9093ce3e83f60ff2e" translate="yes" xml:space="preserve">
          <source>No errors.</source>
          <target state="translated">오류가 없습니다.</target>
        </trans-unit>
        <trans-unit id="7892d6a502d5f2e2afd5b3f6dd7295506fe84c22" translate="yes" xml:space="preserve">
          <source>No explicit hint has been specified.</source>
          <target state="translated">명시적인 힌트가 지정되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="3cf9a8f6c1f780d068a5fd7c8081ef2c13395d28" translate="yes" xml:space="preserve">
          <source>No explicit visibility has been defined.</source>
          <target state="translated">명확한 가시성이 정의되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="2d0ec6cdeb3eeb22c10375761edf35b5b02d1748" translate="yes" xml:space="preserve">
          <source>No explicit visibility scope specified, places with any visibility may be part of search results.</source>
          <target state="translated">명확한 가시성 범위가 지정되지 않은 경우 가시성이있는 장소는 검색 결과의 일부일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f7ef0d0e0e908aa01729965419166a0afbbabe4" translate="yes" xml:space="preserve">
          <source>No filter is applied to images.</source>
          <target state="translated">이미지에 필터가 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="aa7fa771cab3010dd1711f91d38cd411a7ded9cf" translate="yes" xml:space="preserve">
          <source>No filtering should occur. This value is only used together with &lt;a href=&quot;qsgtexture#setMipmapFiltering&quot;&gt;setMipmapFiltering&lt;/a&gt;().</source>
          <target state="translated">필터링이 발생하지 않아야합니다. 이 값은 &lt;a href=&quot;qsgtexture#setMipmapFiltering&quot;&gt;setMipmapFiltering&lt;/a&gt; () 과 함께 만 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="37f264fdbe087a4fb4d54af8ea376b85fc60e465" translate="yes" xml:space="preserve">
          <source>No flag is set.</source>
          <target state="translated">플래그가 설정되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="71684007bf6a8ac7e3b2d2763f7e1fb0852894ef" translate="yes" xml:space="preserve">
          <source>No flow control.</source>
          <target state="translated">흐름 제어가 없습니다.</target>
        </trans-unit>
        <trans-unit id="dae09bdac8f896a136f3d3d20239e81c43fc27e1" translate="yes" xml:space="preserve">
          <source>No frames are cached (the default).</source>
          <target state="translated">캐시 된 프레임이 없습니다 (기본값).</target>
        </trans-unit>
        <trans-unit id="2ff64c461ab58e54ed3a56dae447964ba308a06c" translate="yes" xml:space="preserve">
          <source>No geocoding features are supported.</source>
          <target state="translated">지오 코딩 기능이 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="53cc84a746be056881b64eb02cd083428f84d818" translate="yes" xml:space="preserve">
          <source>No gesture has been detected.</source>
          <target state="translated">제스처가 감지되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="c42924007e146a414395e094d76cb5ff55950154" translate="yes" xml:space="preserve">
          <source>No gradient is used.</source>
          <target state="translated">그라디언트가 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="29e5224ed1bc66141eac60ece92d355288a0dda8" translate="yes" xml:space="preserve">
          <source>No hint is available.</source>
          <target state="translated">힌트가 없습니다.</target>
        </trans-unit>
        <trans-unit id="ff0efdbbb88b76c5cdb3d8137301c4f2fe8b9962" translate="yes" xml:space="preserve">
          <source>No hinting</source>
          <target state="translated">힌트 없음</target>
        </trans-unit>
        <trans-unit id="788be92192fa5af500fb8204c9a6b35ab2c5e990" translate="yes" xml:space="preserve">
          <source>No hints.</source>
          <target state="translated">힌트가 없습니다.</target>
        </trans-unit>
        <trans-unit id="18744b4973c73df2b0f4ca7cc6b899ac98036291" translate="yes" xml:space="preserve">
          <source>No icon is shown.</source>
          <target state="translated">아이콘이 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ee9c00230a5834194191d329277dd2640be52bcd" translate="yes" xml:space="preserve">
          <source>No index is applied. Item location is of linear complexity, as all items on the scene are searched. Adding, moving and removing items, however, is done in constant time. This approach is ideal for dynamic scenes, where many items are added, moved or removed continuously.</source>
          <target state="translated">인덱스가 적용되지 않습니다. 장면의 모든 항목이 검색되므로 항목 위치는 선형 적으로 복잡합니다. 그러나 항목 추가, 이동 및 제거는 일정한 시간에 수행됩니다. 이 방법은 많은 항목이 지속적으로 추가, 이동 또는 제거되는 동적 장면에 이상적입니다.</target>
        </trans-unit>
        <trans-unit id="a74b229a0eb985692cf3459b99e69f68d2423bf0" translate="yes" xml:space="preserve">
          <source>No information about input device capabilities available.</source>
          <target state="translated">사용 가능한 입력 장치 기능에 대한 정보가 없습니다.</target>
        </trans-unit>
        <trans-unit id="24d07d15b6d3ee4151c8cf27ab63d29ad684124a" translate="yes" xml:space="preserve">
          <source>No interaction with the text is possible.</source>
          <target state="translated">텍스트와 상호 작용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="bead389416b9cae0fc62d60976f0177c1e44c0da" translate="yes" xml:space="preserve">
          <source>No known error</source>
          <target state="translated">알려진 오류가 없습니다</target>
        </trans-unit>
        <trans-unit id="78f6148adc5f3f86ebeb4877f24e59e26fbbf6bd" translate="yes" xml:space="preserve">
          <source>No leading dot is included, so for instance this would return &quot;jpg&quot;, &quot;jpeg&quot; for image/jpeg.</source>
          <target state="translated">선행 점은 포함되지 않으므로 예를 들어 image / jpeg에 대해 &quot;jpg&quot;, &quot;jpeg&quot;를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f114ab2e9626a657b95d2569157e21280cbcd254" translate="yes" xml:space="preserve">
          <source>No leading dot is included, so for instance this would return &quot;pdf&quot; for application/pdf. The return value can be empty, for mime types which do not have any suffixes associated.</source>
          <target state="translated">선행 점은 포함되지 않으므로 application / pdf에 대해 &quot;pdf&quot;를 반환합니다. 접미사가 연결되지 않은 MIME 유형의 경우 반환 값은 비어있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f72352a059770ddf231d020c442e39e801b2bf6e" translate="yes" xml:space="preserve">
          <source>No lighting is calculated.</source>
          <target state="translated">조명이 계산되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5edccb05a63f42602fcfd2ed77457db67ca38bc0" translate="yes" xml:space="preserve">
          <source>No line active</source>
          <target state="translated">활성화 된 라인이 없습니다</target>
        </trans-unit>
        <trans-unit id="86a27994acabd7c66d6c4374e9a9dbf122340b4f" translate="yes" xml:space="preserve">
          <source>No longer used since 5.11, as Blink now renders Validation messages internally.</source>
          <target state="translated">Blink가 이제 유효성 검사 메시지를 내부적으로 렌더링하므로 5.11 이후로 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="98e89c7b75d879821bbf736637b6045bf4b333e1" translate="yes" xml:space="preserve">
          <source>No maneuvers should be included with the route</source>
          <target state="translated">경로에 기동을 포함해서는 안됩니다</target>
        </trans-unit>
        <trans-unit id="047d18dd35dadf1d78ffa79fcd2af93bfd0a9bdd" translate="yes" xml:space="preserve">
          <source>No maneuvers should be included with the route.</source>
          <target state="translated">경로에 기동이 포함되어서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="ebd7fc62ef0841f5d890ac57ce36345d601f5118" translate="yes" xml:space="preserve">
          <source>No mapping features are supported.</source>
          <target state="translated">매핑 기능이 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="066451f79a8b484dc7a17c033b7dddc688367462" translate="yes" xml:space="preserve">
          <source>No mapping for xs:time</source>
          <target state="translated">xs : time에 대한 매핑이 없습니다.</target>
        </trans-unit>
        <trans-unit id="8e6b8618c40994b5364d76d94166d0012155e298" translate="yes" xml:space="preserve">
          <source>No match options are set.</source>
          <target state="translated">일치 옵션이 설정되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="0f8f04b81b30ae3c2f432d78561aca3e893832e1" translate="yes" xml:space="preserve">
          <source>No matching is done. This value is returned as the match type by a default constructed &lt;a href=&quot;qregularexpressionmatch&quot;&gt;QRegularExpressionMatch&lt;/a&gt; or &lt;a href=&quot;qregularexpressionmatchiterator&quot;&gt;QRegularExpressionMatchIterator&lt;/a&gt;. Using this match type is not very useful for the user, as no matching ever happens. This enum value has been introduced in Qt 5.1.</source>
          <target state="translated">일치하지 않습니다. 이 값은 기본 생성 된 &lt;a href=&quot;qregularexpressionmatch&quot;&gt;QRegularExpressionMatch&lt;/a&gt; 또는 &lt;a href=&quot;qregularexpressionmatchiterator&quot;&gt;QRegularExpressionMatchIterator에&lt;/a&gt; 의해 일치 유형으로 리턴됩니다 . 이 일치 유형을 사용하면 일치하는 항목이 없으므로 사용자에게별로 유용하지 않습니다. 이 열거 형 값은 Qt 5.1에 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="7a33b0d386e03728be6df0dfacd7616c906cc003" translate="yes" xml:space="preserve">
          <source>No modifier key is allowed.</source>
          <target state="translated">수정 자 키는 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="10d3f3571010a8601447016b451078f1bc1569c2" translate="yes" xml:space="preserve">
          <source>No modifier key is pressed.</source>
          <target state="translated">수정 자 키를 누르지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="9cae50c43368e59db34118232fb5c5217eaddc23" translate="yes" xml:space="preserve">
          <source>No mouse events are propagated to this component, which means that controls like Button will not function when used within it. You can check if the mouse is over this section by comparing &lt;code&gt;control.currentIndex&lt;/code&gt; to &lt;code&gt;styleData.index&lt;/code&gt;.</source>
          <target state="translated">이 구성 요소에 마우스 이벤트가 전달되지 않습니다. 즉, Button과 같은 컨트롤은 그 안에 사용될 때 작동하지 않습니다. &lt;code&gt;control.currentIndex&lt;/code&gt; 와 &lt;code&gt;styleData.index&lt;/code&gt; 를 비교하여 마우스가이 섹션 위에 있는지 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b97adebe9defd3010d96532eff3566b234e4878e" translate="yes" xml:space="preserve">
          <source>No namespace processing is performed either.</source>
          <target state="translated">네임 스페이스 처리도 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0146cae24d5c20f8522eea9f5c83f1aa22f47d3a" translate="yes" xml:space="preserve">
          <source>No namespace processing is performed.</source>
          <target state="translated">네임 스페이스 처리가 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b96618c4ba871d4b2c23a2194d4dcf13bec37535" translate="yes" xml:space="preserve">
          <source>No navigation features are supported.</source>
          <target state="translated">탐색 기능이 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d748228335e67fc15628ed4c389937c097009213" translate="yes" xml:space="preserve">
          <source>No network service available.</source>
          <target state="translated">사용 가능한 네트워크 서비스가 없습니다.</target>
        </trans-unit>
        <trans-unit id="03ff0c460a1f05f7656e2e41100eb2323c306c73" translate="yes" xml:space="preserve">
          <source>No options.</source>
          <target state="translated">옵션이 없습니다.</target>
        </trans-unit>
        <trans-unit id="17702254fe2b7d0ef91d2b79f62958c5068b1c1f" translate="yes" xml:space="preserve">
          <source>No parity bit it sent. This is the most common parity setting. Error detection is handled by the communication protocol.</source>
          <target state="translated">보낸 패리티 비트가 없습니다. 이것이 가장 일반적인 패리티 설정입니다. 에러 검출은 통신 프로토콜에 의해 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="3e0862f9cc42f13cb6f43ecc8e9dcd64d09cfbf7" translate="yes" xml:space="preserve">
          <source>No pattern options are set.</source>
          <target state="translated">패턴 옵션이 설정되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="caa16e4097ff65e50ee690a6f020728719815fdb" translate="yes" xml:space="preserve">
          <source>No places features are supported.</source>
          <target state="translated">지원되는 장소 기능이 없습니다.</target>
        </trans-unit>
        <trans-unit id="694fa8555ee309a1fb67d6a1780f50a2ef325e04" translate="yes" xml:space="preserve">
          <source>No policy in force, usage is unrestricted.</source>
          <target state="translated">시행중인 정책이 없으며 사용이 제한되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6756b0ce5d9ee8658119bf895b6efbdeedb4e5da" translate="yes" xml:space="preserve">
          <source>No proxying is used</source>
          <target state="translated">프록 싱이 사용되지 않습니다</target>
        </trans-unit>
        <trans-unit id="096dc58878299f4c0ed278013a387f5506c14409" translate="yes" xml:space="preserve">
          <source>No relevance hint is given to the provider.</source>
          <target state="translated">제공자에게 관련 힌트가 제공되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e9b4583efdd1757a5f2728c734362b90ccfbe7f6" translate="yes" xml:space="preserve">
          <source>No resource is loaded, or the resource type is not known.</source>
          <target state="translated">리소스가로드되지 않았거나 리소스 유형을 알 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b67dc49dae957fcea58f42dc89f14745a3ea1e6d" translate="yes" xml:space="preserve">
          <source>No role; this special role is often used to indicate that a role has not been assigned.</source>
          <target state="translated">역할이 없습니다. 이 특수 역할은 역할이 할당되지 않았 음을 나타내는 데 종종 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="268ac35e888187b33ffc67afd63881719e10d9c6" translate="yes" xml:space="preserve">
          <source>No routing features are supported.</source>
          <target state="translated">라우팅 기능이 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="96cfc340f611ce8f57adc1566458e32d73ce5702" translate="yes" xml:space="preserve">
          <source>No search query has been executed. The model is empty.</source>
          <target state="translated">검색어가 실행되지 않았습니다. 모델이 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c721d5e74cb4de2f86b757017772ec7e6f23c03" translate="yes" xml:space="preserve">
          <source>No segment data should be included with the route</source>
          <target state="translated">경로에 구간 데이터를 포함해서는 안됩니다</target>
        </trans-unit>
        <trans-unit id="d7a6bd135aacf82dbfdd5ad18c41f0c4154c5d8c" translate="yes" xml:space="preserve">
          <source>No segment data should be included with the route. A route requested with this level of segment detail will initialize &lt;a href=&quot;qgeoroutesegment#path&quot;&gt;QGeoRouteSegment::path&lt;/a&gt;() as a straight line between the positions of the previous and next &lt;a href=&quot;qgeomaneuver&quot;&gt;QGeoManeuver&lt;/a&gt; instances.</source>
          <target state="translated">경로에 구간 데이터가 포함되어서는 안됩니다. 이 레벨의 세그먼트 세부 사항으로 요청 된 라우트는 &lt;a href=&quot;qgeoroutesegment#path&quot;&gt;QGeoRouteSegment :: path&lt;/a&gt; ()를 이전 및 다음 &lt;a href=&quot;qgeomaneuver&quot;&gt;QGeoManeuver&lt;/a&gt; 인스턴스 의 위치 사이의 직선으로 초기화 합니다.</target>
        </trans-unit>
        <trans-unit id="31f9ddb9116452c1585930342d4bf4fddf662dec" translate="yes" xml:space="preserve">
          <source>No selection will be made.</source>
          <target state="translated">선택하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="98479fc3edc81f1195f7c382688d28e029825a84" translate="yes" xml:space="preserve">
          <source>No series type.</source>
          <target state="translated">시리즈 타입이 없습니다.</target>
        </trans-unit>
        <trans-unit id="9ad94fe8cc7b13bffab416df7b852fb0145aabe0" translate="yes" xml:space="preserve">
          <source>No set of general guidelines can replace a solid understanding of the underlying principles of computer science combined with a practical knowledge of the implementation details of the platform for which the application developer is developing. Furthermore, no amount of theoretical calculation can replace a good set of benchmarks and analysis tools when making trade-off decisions.</source>
          <target state="translated">컴퓨터 개발자의 기본 원리에 대한 확실한 이해와 응용 프로그램 개발자가 개발중인 플랫폼의 구현 세부 사항에 대한 실질적인 지식을 대체 할 수있는 일반적인 지침은 없습니다. 게다가, 트레이드 오프 결정을 내릴 때 이론적 계산이 훌륭한 벤치 마크 및 분석 도구를 대체 할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="865209c45aa3054f6c1cb0d4d9701b9aad71dbc4" translate="yes" xml:space="preserve">
          <source>No sort indicator is needed</source>
          <target state="translated">정렬 표시기가 필요하지 않습니다</target>
        </trans-unit>
        <trans-unit id="621052f21cfc2d2892467691d2da3235e381d1f2" translate="yes" xml:space="preserve">
          <source>No source has been set or the source is null.</source>
          <target state="translated">소스가 설정되지 않았거나 소스가 널입니다.</target>
        </trans-unit>
        <trans-unit id="081a22c5415fe12b5b7e318a1fa27d489427f272" translate="yes" xml:space="preserve">
          <source>No space left on device.</source>
          <target state="translated">기기에 남은 공간이 없습니다.</target>
        </trans-unit>
        <trans-unit id="e7a2638e18d7a591f1869f806137afeca5514d9b" translate="yes" xml:space="preserve">
          <source>No special behavior.</source>
          <target state="translated">특별한 행동이 없습니다.</target>
        </trans-unit>
        <trans-unit id="cf33c4a137bca49d69d38325acb25bee6b6095c5" translate="yes" xml:space="preserve">
          <source>No specific sandboxing desired</source>
          <target state="translated">특정 샌드 박싱이 필요하지 않음</target>
        </trans-unit>
        <trans-unit id="2b2ac9ca8f524fad33b8d9ab919168320bdfcc46" translate="yes" xml:space="preserve">
          <source>No status received</source>
          <target state="translated">상태가 수신되지 않았습니다</target>
        </trans-unit>
        <trans-unit id="bb71062ee2968ca63ea391bb1ffa760541855677" translate="yes" xml:space="preserve">
          <source>No tessellation is used. This is the default.</source>
          <target state="translated">테셀레이션이 사용되지 않습니다. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="08cdecd63a66be52d85b208e5ebbf249464ab13c" translate="yes" xml:space="preserve">
          <source>No test is applied, the effective alpha value is passed on as-is. Note that a &lt;a href=&quot;qml-qtquick3d-principledmaterial#baseColor-prop&quot;&gt;baseColor&lt;/a&gt; alpha less than &lt;code&gt;1.0&lt;/code&gt; does not automatically imply alpha blending, the object with the material may still be treated as opaque, if no other relevant properties (such as, an opacity less than 1, or the presence of an opacity map) trigger treating the object as semi-transparent. To ensure alpha blending happens, set &lt;code&gt;Blend&lt;/code&gt; instead.</source>
          <target state="translated">테스트가 적용되지 않고 유효 알파 값이있는 그대로 전달됩니다. &lt;code&gt;1.0&lt;/code&gt; 미만 의 &lt;a href=&quot;qml-qtquick3d-principledmaterial#baseColor-prop&quot;&gt;baseColor&lt;/a&gt; 알파 는 알파 블렌딩을 자동으로 의미하지 않으며, 다른 관련 속성 (예 : 1 미만의 불투명도 또는 불투명 맵의 존재)이없는 경우 재질이있는 오브젝트는 여전히 불투명으로 처리 될 수 있습니다. 개체를 반투명으로 처리하는 트리거입니다. 알파 블렌딩이 발생하도록하려면 대신 &lt;code&gt;Blend&lt;/code&gt; 를 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="6adec22206eff7fcff8da47561b3516d0992c3d3" translate="yes" xml:space="preserve">
          <source>No token has been retrieved.</source>
          <target state="translated">검색된 토큰이 없습니다.</target>
        </trans-unit>
        <trans-unit id="bef4e0b6c03c149572ac12556a2bbf677e54978f" translate="yes" xml:space="preserve">
          <source>No transformation should be applied.</source>
          <target state="translated">변환이 적용되지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="34a2c4d64633c8663e79fbb1b6ca321adf4597e5" translate="yes" xml:space="preserve">
          <source>No triangles are discarded.</source>
          <target state="translated">삼각형은 버려지지 않습니다.</target>
        </trans-unit>
        <trans-unit id="32869ce3e4d64eb3b2952ad2b3e32e4f44b026b8" translate="yes" xml:space="preserve">
          <source>No two rectangles may abut horizontally (they should be combined into a single wider rectangle in that case).</source>
          <target state="translated">두 개의 사각형은 가로로 접할 수 없습니다 (이 경우 하나의 더 넓은 사각형으로 결합해야 함).</target>
        </trans-unit>
        <trans-unit id="06b4993408a9344fbb9b0e82e356178d0b27250e" translate="yes" xml:space="preserve">
          <source>No user interaction is possible</source>
          <target state="translated">사용자 상호 작용이 불가능합니다</target>
        </trans-unit>
        <trans-unit id="c1a32b7f5c829c20433e447ad31bb3c104ec7e08" translate="yes" xml:space="preserve">
          <source>No zooming area is specified, and therefore zooming is not enabled.</source>
          <target state="translated">확대 / 축소 영역이 지정되지 않았으므로 확대 / 축소를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3bb5ebfcbb80e9316141f0bb85274978a21e3731" translate="yes" xml:space="preserve">
          <source>No*</source>
          <target state="translated">No*</target>
        </trans-unit>
        <trans-unit id="1a89f4415d22ba352a84d748a0e43c3ae425cc45" translate="yes" xml:space="preserve">
          <source>NoDepthMask</source>
          <target state="translated">NoDepthMask</target>
        </trans-unit>
        <trans-unit id="1d2ced94c34321139a88468ac1234e070b9aa2e2" translate="yes" xml:space="preserve">
          <source>NoDepthMask (QML type)</source>
          <target state="translated">NoDepthMask (QML 유형)</target>
        </trans-unit>
        <trans-unit id="630a3fc3f70f4e4a3a36ad10b711a45c9cfdc919" translate="yes" xml:space="preserve">
          <source>NoDepthMask QML Type</source>
          <target state="translated">NoDepthMask QML 유형</target>
        </trans-unit>
        <trans-unit id="eae54b3dbd10acda4905362c06a79176211feba0" translate="yes" xml:space="preserve">
          <source>NoDraw</source>
          <target state="translated">NoDraw</target>
        </trans-unit>
        <trans-unit id="d1e3b7bd3b6e9c218d77cde1e9cce5c0ad2b329c" translate="yes" xml:space="preserve">
          <source>NoDraw (QML type)</source>
          <target state="translated">NoDraw (QML 유형)</target>
        </trans-unit>
        <trans-unit id="c87c1b49f4ff4c851d6976cbfbc2f3dd6ca9a9ee" translate="yes" xml:space="preserve">
          <source>NoDraw QML Type</source>
          <target state="translated">NoDraw QML 유형</target>
        </trans-unit>
        <trans-unit id="8015c6d37ca055203f5cf838336e4b603e9a8de7" translate="yes" xml:space="preserve">
          <source>NoDraw is usually used as a child of a &lt;a href=&quot;qml-qt3d-render-clearbuffers&quot;&gt;ClearBuffers&lt;/a&gt; node to prevent from drawing the scene when there are multiple render passes.</source>
          <target state="translated">NoDraw는 일반적으로 여러 렌더링 패스가있을 때 장면을 그리는 것을 방지하기 위해 &lt;a href=&quot;qml-qt3d-render-clearbuffers&quot;&gt;ClearBuffers&lt;/a&gt; 노드 의 자식으로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="e01b2c61ab3a508cf60e087ec0311fd99d2b395f" translate="yes" xml:space="preserve">
          <source>NoDraw should be used when the FrameGraph needs to set up some render states or clear some buffers without requiring any mesh to be drawn. It has the same effect as having a &lt;a href=&quot;qt3drender-qrenderpassfilter&quot;&gt;Qt3DRender::QRenderPassFilter&lt;/a&gt; that matches none of available &lt;a href=&quot;qt3drender-qrenderpass&quot;&gt;Qt3DRender::QRenderPass&lt;/a&gt; instances of the scene without the overhead cost of actually performing the filtering.</source>
          <target state="translated">NoDraw는 프레임 그래프가 일부 렌더링 상태를 설정하거나 메시를 그릴 필요없이 일부 버퍼를 지워야 할 때 사용해야합니다. 실제로 필터링을 수행하는 오버 헤드 비용없이 장면 의 사용 가능한 &lt;a href=&quot;qt3drender-qrenderpass&quot;&gt;Qt3DRender :: QRenderPass&lt;/a&gt; 인스턴스 와 일치하지 않는 &lt;a href=&quot;qt3drender-qrenderpassfilter&quot;&gt;Qt3DRender :: QRenderPassFilter&lt;/a&gt; 를 갖는 것과 동일한 효과 가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d2eb06022116ea8d4db65621e6edb4e108cf0bd0" translate="yes" xml:space="preserve">
          <source>NoError</source>
          <target state="translated">NoError</target>
        </trans-unit>
        <trans-unit id="d18527b73f860dcabfae30b7085ffcfb13d7b846" translate="yes" xml:space="preserve">
          <source>NoMedia - no media has been set.</source>
          <target state="translated">미디어 없음-미디어가 설정되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="9f7de05032015dc0e3875a87e5a388469c1a1512" translate="yes" xml:space="preserve">
          <source>NoPicking</source>
          <target state="translated">NoPicking</target>
        </trans-unit>
        <trans-unit id="3e4e85c1abf3f16380d5683ec71ba493f56819db" translate="yes" xml:space="preserve">
          <source>NoPicking (QML type)</source>
          <target state="translated">NoPicking (QML 유형)</target>
        </trans-unit>
        <trans-unit id="834644e6906fc44a036fac9fe199e29da7e5b8cc" translate="yes" xml:space="preserve">
          <source>NoPicking QML Type</source>
          <target state="translated">NoPicking QML 유형</target>
        </trans-unit>
        <trans-unit id="260f7a8cd4f6938b3cc185a619847cb83d670219" translate="yes" xml:space="preserve">
          <source>Node</source>
          <target state="translated">Node</target>
        </trans-unit>
        <trans-unit id="2faacd1c358246573b6c16f7102bfefb78cb3e48" translate="yes" xml:space="preserve">
          <source>Node (QML type)</source>
          <target state="translated">노드 (QML 유형)</target>
        </trans-unit>
        <trans-unit id="16a624bc363703f03066911e1d6ba07d27b248f8" translate="yes" xml:space="preserve">
          <source>Node Ownership</source>
          <target state="translated">노드 소유권</target>
        </trans-unit>
        <trans-unit id="7a1dcf429df5bf47d8c30238542017e90913b54b" translate="yes" xml:space="preserve">
          <source>Node QML Type</source>
          <target state="translated">노드 QML 유형</target>
        </trans-unit>
        <trans-unit id="5a65c8cd9db3a4c4f9b9783f1a02690f4a5e5ba2" translate="yes" xml:space="preserve">
          <source>Node Test</source>
          <target state="translated">노드 테스트</target>
        </trans-unit>
        <trans-unit id="ef1e6eaa9a5dc6b5208904520b59cf46cf059cdc" translate="yes" xml:space="preserve">
          <source>Node Tests</source>
          <target state="translated">노드 테스트</target>
        </trans-unit>
        <trans-unit id="33d6848a140f44110c77c4ebaec0484d26d02ccc" translate="yes" xml:space="preserve">
          <source>Node Type</source>
          <target state="translated">노드 유형</target>
        </trans-unit>
        <trans-unit id="ba12348a920384390a866b44c5cbf02e5743139f" translate="yes" xml:space="preserve">
          <source>Node has to be used also if creating a scene outside of &lt;a href=&quot;qml-qtquick3d-view3d&quot;&gt;View3D&lt;/a&gt;, for example for the purpose of switching scenes on the fly, or showing the same scene on multiple views.</source>
          <target state="translated">Node는 &lt;a href=&quot;qml-qtquick3d-view3d&quot;&gt;View3D&lt;/a&gt; 외부에서 장면을 만드는 경우에도 사용해야 합니다. 예를 들어 장면을 즉석에서 전환하거나 여러 뷰에서 동일한 장면을 표시 할 목적으로 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="d2cd68df3daaa20436783d7310961a7e2acd3b0a" translate="yes" xml:space="preserve">
          <source>Node type can be used to wrap other objects for the purpose of grouping them, or animating them. This snippet shows how to use Node to animate a camera.</source>
          <target state="translated">노드 유형은 그룹화하거나 애니메이션화 할 목적으로 다른 오브젝트를 래핑하는 데 사용할 수 있습니다. 이 스 니펫은 Node를 사용하여 카메라를 애니메이션하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="30fc3dca1dbd7568fb34fa2ad8afa7ad4dc8a227" translate="yes" xml:space="preserve">
          <source>Node-local: Addresses that are only used for communicating with services on the same interface (e.g., the loopback interface &quot;::1&quot;).</source>
          <target state="translated">노드 로컬 : 동일한 인터페이스에서 서비스와 통신하는 데만 사용되는 주소 (예 : 루프백 인터페이스 &quot;:: 1&quot;).</target>
        </trans-unit>
        <trans-unit id="9e2ed79267fc579d9fb06bddf1860dd663ff6344" translate="yes" xml:space="preserve">
          <source>Node.TransformSpace</source>
          <target state="translated">Node.TransformSpace</target>
        </trans-unit>
        <trans-unit id="9c13c4a041b14dc7616df500f6c4cfbd31bccb8f" translate="yes" xml:space="preserve">
          <source>Node.childNodes</source>
          <target state="translated">Node.childNodes</target>
        </trans-unit>
        <trans-unit id="c7415f545bb59efd83dc79c5ba3cf2ce1085d1ed" translate="yes" xml:space="preserve">
          <source>Node.data</source>
          <target state="translated">Node.data</target>
        </trans-unit>
        <trans-unit id="ae62d13af4a630dac2bc6f320a7c1e65c31f83c7" translate="yes" xml:space="preserve">
          <source>Node.eulerRotation</source>
          <target state="translated">Node.eulerRotation</target>
        </trans-unit>
        <trans-unit id="61c793e279fee0ad5991e8b989604bc89e2b2a0d" translate="yes" xml:space="preserve">
          <source>Node.forward</source>
          <target state="translated">Node.forward</target>
        </trans-unit>
        <trans-unit id="1d7185d40ac996e92020f97420b43962e6787e89" translate="yes" xml:space="preserve">
          <source>Node.heartbeatInterval</source>
          <target state="translated">Node.heartbeatInterval</target>
        </trans-unit>
        <trans-unit id="2541b101453fcbcfabfa3982217c56799fa78ba8" translate="yes" xml:space="preserve">
          <source>Node.mapDirectionFromNode()</source>
          <target state="translated">Node.mapDirectionFromNode()</target>
        </trans-unit>
        <trans-unit id="6ea264c4d7044cc4bd4a3dd4e0f3e5c87955dca9" translate="yes" xml:space="preserve">
          <source>Node.mapDirectionFromScene()</source>
          <target state="translated">Node.mapDirectionFromScene()</target>
        </trans-unit>
        <trans-unit id="eb57f75a9ce76fff14f6ceb3ef0866ee33440f2b" translate="yes" xml:space="preserve">
          <source>Node.mapDirectionToNode()</source>
          <target state="translated">Node.mapDirectionToNode()</target>
        </trans-unit>
        <trans-unit id="c981ecc92a056a42562012ca104fb7fbfea26d3b" translate="yes" xml:space="preserve">
          <source>Node.mapDirectionToScene()</source>
          <target state="translated">Node.mapDirectionToScene()</target>
        </trans-unit>
        <trans-unit id="1d56eaacfe0f26021bd12dccc0ecfbed471fb892" translate="yes" xml:space="preserve">
          <source>Node.mapPositionFromNode()</source>
          <target state="translated">Node.mapPositionFromNode()</target>
        </trans-unit>
        <trans-unit id="ecb3a5e0066851a499f1fa09a729c55eb4b46b3d" translate="yes" xml:space="preserve">
          <source>Node.mapPositionFromScene()</source>
          <target state="translated">Node.mapPositionFromScene()</target>
        </trans-unit>
        <trans-unit id="f497d00954d2e2313207b37fc534cb17afce3fa7" translate="yes" xml:space="preserve">
          <source>Node.mapPositionToNode()</source>
          <target state="translated">Node.mapPositionToNode()</target>
        </trans-unit>
        <trans-unit id="e8085ed3f008ae0426585e9af755e24c9d379747" translate="yes" xml:space="preserve">
          <source>Node.mapPositionToScene()</source>
          <target state="translated">Node.mapPositionToScene()</target>
        </trans-unit>
        <trans-unit id="8e4e5119ba49c6bd698cdf9d14c9530354f0bfb5" translate="yes" xml:space="preserve">
          <source>Node.opacity</source>
          <target state="translated">Node.opacity</target>
        </trans-unit>
        <trans-unit id="d7b66c9f183dc07487c68aa185b60760642c9a4b" translate="yes" xml:space="preserve">
          <source>Node.persistedStore</source>
          <target state="translated">Node.persistedStore</target>
        </trans-unit>
        <trans-unit id="ad9c2383c2de783ac4a6d2ecab40edd008027944" translate="yes" xml:space="preserve">
          <source>Node.pivot</source>
          <target state="translated">Node.pivot</target>
        </trans-unit>
        <trans-unit id="808321448f28274b008ad568c00caf88c8e0975a" translate="yes" xml:space="preserve">
          <source>Node.position</source>
          <target state="translated">Node.position</target>
        </trans-unit>
        <trans-unit id="222dd65a47477be664abe018586f315028c701c1" translate="yes" xml:space="preserve">
          <source>Node.propertyTrackingOverrides</source>
          <target state="translated">Node.propertyTrackingOverrides</target>
        </trans-unit>
        <trans-unit id="9d3ca3b690dff8f42ceb7d4d09a01580dfa72f15" translate="yes" xml:space="preserve">
          <source>Node.registryUrl</source>
          <target state="translated">Node.registryUrl</target>
        </trans-unit>
        <trans-unit id="a9620ba963ff9a994e1cee4e8040eca7cc709e48" translate="yes" xml:space="preserve">
          <source>Node.right</source>
          <target state="translated">Node.right</target>
        </trans-unit>
        <trans-unit id="881ed498a38d93a25ff12b190a5d4ba175fc1434" translate="yes" xml:space="preserve">
          <source>Node.rotate()</source>
          <target state="translated">Node.rotate()</target>
        </trans-unit>
        <trans-unit id="2a24824705409b90a93e806cd8c9ecb2546c24fa" translate="yes" xml:space="preserve">
          <source>Node.rotation</source>
          <target state="translated">Node.rotation</target>
        </trans-unit>
        <trans-unit id="0f62e8cd701d0405db03b4fe131838191160ad2f" translate="yes" xml:space="preserve">
          <source>Node.scale</source>
          <target state="translated">Node.scale</target>
        </trans-unit>
        <trans-unit id="373f9195ca60eea29b4d223df142bd24c03c8e06" translate="yes" xml:space="preserve">
          <source>Node.scenePosition</source>
          <target state="translated">Node.scenePosition</target>
        </trans-unit>
        <trans-unit id="bcf371fa9c4c69ae4fc66df0c6edd5bf0b0187bb" translate="yes" xml:space="preserve">
          <source>Node.sceneRotation</source>
          <target state="translated">Node.sceneRotation</target>
        </trans-unit>
        <trans-unit id="0f346502e49f73b8cc1eb62e944a0313b656e9f9" translate="yes" xml:space="preserve">
          <source>Node.sceneScale</source>
          <target state="translated">Node.sceneScale</target>
        </trans-unit>
        <trans-unit id="5a7c3bd15d73caa76b9f345b3270fa1126419401" translate="yes" xml:space="preserve">
          <source>Node.sceneTransform</source>
          <target state="translated">Node.sceneTransform</target>
        </trans-unit>
        <trans-unit id="78e27deabf0f25b3ade09b9a73115322319423e9" translate="yes" xml:space="preserve">
          <source>Node.staticFlags</source>
          <target state="translated">Node.staticFlags</target>
        </trans-unit>
        <trans-unit id="4e647822b786ace12e99f8d437f6cca6dfa44093" translate="yes" xml:space="preserve">
          <source>Node.up</source>
          <target state="translated">Node.up</target>
        </trans-unit>
        <trans-unit id="e7223adf225f63453ed1ce7962e6ac0c3f6205a4" translate="yes" xml:space="preserve">
          <source>Node.visible</source>
          <target state="translated">Node.visible</target>
        </trans-unit>
        <trans-unit id="367cdc607cecf7ddffd4d35d8ccb3a6c144d2f7e" translate="yes" xml:space="preserve">
          <source>Node.x</source>
          <target state="translated">Node.x</target>
        </trans-unit>
        <trans-unit id="b4150891ca57e122dfd91a7772929e5295571e23" translate="yes" xml:space="preserve">
          <source>Node.y</source>
          <target state="translated">Node.y</target>
        </trans-unit>
        <trans-unit id="1c44c3d546c014babc0be64f886f961b31d95739" translate="yes" xml:space="preserve">
          <source>Node.z</source>
          <target state="translated">Node.z</target>
        </trans-unit>
        <trans-unit id="39e5f316e9cf392f74d7d7909be35e85269bdff6" translate="yes" xml:space="preserve">
          <source>NodeInstantiator (QML type)</source>
          <target state="translated">NodeInstantiator (QML 유형)</target>
        </trans-unit>
        <trans-unit id="0929820fb528d66cdee90be834ad10fff7e30ae6" translate="yes" xml:space="preserve">
          <source>NodeInstantiator QML Type</source>
          <target state="translated">NodeInstantiator QML 유형</target>
        </trans-unit>
        <trans-unit id="bb0507832684c1125b9d413c16229e3c027bfe4f" translate="yes" xml:space="preserve">
          <source>NodeInstantiator.active</source>
          <target state="translated">NodeInstantiator.active</target>
        </trans-unit>
        <trans-unit id="1d7aa2549db829d685f42638779adc40043e2401" translate="yes" xml:space="preserve">
          <source>NodeInstantiator.asynchronous</source>
          <target state="translated">NodeInstantiator.asynchronous</target>
        </trans-unit>
        <trans-unit id="87a0fb697c7cd29367e1de4c9a9ac9529a11cccc" translate="yes" xml:space="preserve">
          <source>NodeInstantiator.count</source>
          <target state="translated">NodeInstantiator.count</target>
        </trans-unit>
        <trans-unit id="3672e6a585979e6414f3821c37f9e10688602e6f" translate="yes" xml:space="preserve">
          <source>NodeInstantiator.delegate</source>
          <target state="translated">NodeInstantiator.delegate</target>
        </trans-unit>
        <trans-unit id="e2c62517af76b546acd1804de4ad874076c9314b" translate="yes" xml:space="preserve">
          <source>NodeInstantiator.model</source>
          <target state="translated">NodeInstantiator.model</target>
        </trans-unit>
        <trans-unit id="81a12c361075a5db57dca08ef9dbe3f1ca584f7b" translate="yes" xml:space="preserve">
          <source>NodeInstantiator.object</source>
          <target state="translated">NodeInstantiator.object</target>
        </trans-unit>
        <trans-unit id="0e99591ea57745411e90ce42cc7f1b4177dbbb24" translate="yes" xml:space="preserve">
          <source>NodeInstantiator.objectAdded()</source>
          <target state="translated">NodeInstantiator.objectAdded()</target>
        </trans-unit>
        <trans-unit id="45147ed5e87238c05a143107e8450d0505b8147f" translate="yes" xml:space="preserve">
          <source>NodeInstantiator.objectAt()</source>
          <target state="translated">NodeInstantiator.objectAt()</target>
        </trans-unit>
        <trans-unit id="6163158e744b1be2755cf46aeafb5d9e4835f540" translate="yes" xml:space="preserve">
          <source>NodeInstantiator.objectRemoved()</source>
          <target state="translated">NodeInstantiator.objectRemoved()</target>
        </trans-unit>
        <trans-unit id="9e325452c6548fc2449564842660d75ef3b1eb73" translate="yes" xml:space="preserve">
          <source>Nodes</source>
          <target state="translated">Nodes</target>
        </trans-unit>
        <trans-unit id="73990f52ec49bd6a52dea794901f611e6b737886" translate="yes" xml:space="preserve">
          <source>Nodes are inserted with &lt;a href=&quot;qdomnode#insertBefore&quot;&gt;insertBefore&lt;/a&gt;(), &lt;a href=&quot;qdomnode#insertAfter&quot;&gt;insertAfter&lt;/a&gt;() or &lt;a href=&quot;qdomnode#appendChild&quot;&gt;appendChild&lt;/a&gt;(). You can replace one node with another using &lt;a href=&quot;qdomnode#replaceChild&quot;&gt;replaceChild&lt;/a&gt;() and remove a node with &lt;a href=&quot;qdomnode#removeChild&quot;&gt;removeChild&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qdomnode#insertBefore&quot;&gt;insertBefore&lt;/a&gt; (), &lt;a href=&quot;qdomnode#insertAfter&quot;&gt;insertAfter&lt;/a&gt; () 또는 &lt;a href=&quot;qdomnode#appendChild&quot;&gt;appendChild&lt;/a&gt; ()를 사용 하여 노드를 삽입 합니다. &lt;a href=&quot;qdomnode#replaceChild&quot;&gt;replaceChild&lt;/a&gt; ()를 사용하여 한 노드를 다른 노드로 바꾸고 &lt;a href=&quot;qdomnode#removeChild&quot;&gt;removeChild&lt;/a&gt; () 로 노드를 제거 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a890f0392a70ee43979c04a3a88baea3c91c7e07" translate="yes" xml:space="preserve">
          <source>Nodes have a couple of &lt;a href=&quot;qremoteobjecthostbase#enableRemoting&quot;&gt;enableRemoting()&lt;/a&gt; methods that are used to share objects on the network (this will produce an error if the Node is not a Host Node however). Other processes/devices that want to interact with a shared object use one of the &lt;a href=&quot;qremoteobjectnode#acquire&quot;&gt;node's acquire()&lt;/a&gt; methods to instantiate a replica.</source>
          <target state="translated">노드에는 네트워크에서 객체를 공유하는 데 사용되는 몇 가지 &lt;a href=&quot;qremoteobjecthostbase#enableRemoting&quot;&gt;enableRemoting ()&lt;/a&gt; 메소드가 있습니다 (그러나 노드가 호스트 노드가 아닌 경우 오류가 발생 함). 공유 객체와 상호 작용하려는 다른 프로세스 / 장치는 &lt;a href=&quot;qremoteobjectnode#acquire&quot;&gt;노드의 acquire ()&lt;/a&gt; 메소드 중 하나를 사용 하여 복제본을 인스턴스화합니다.</target>
        </trans-unit>
        <trans-unit id="53362e5acce6edfaf07e1d1aa56e0c13a94cd7d5" translate="yes" xml:space="preserve">
          <source>Nodes have a few &lt;a href=&quot;qremoteobjecthostbase#enableRemoting&quot;&gt;enableRemoting()&lt;/a&gt; methods that are used to share objects on the network. However, if the node is not a host node, an error is returned.</source>
          <target state="translated">노드에는 네트워크에서 개체를 공유하는 데 사용되는 몇 가지 &lt;a href=&quot;qremoteobjecthostbase#enableRemoting&quot;&gt;enableRemoting ()&lt;/a&gt; 메서드가 있습니다. 그러나 노드가 호스트 노드가 아니면 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="ff4644b03bcfa5fc36dc287e9eb8ebb71b8ea45f" translate="yes" xml:space="preserve">
          <source>Nodes have a virtual &lt;a href=&quot;qsgnode#preprocess&quot;&gt;QSGNode::preprocess&lt;/a&gt;() function, which will be called before the scene graph is rendered. Node subclasses can set the flag &lt;a href=&quot;qsgnode#Flag-enum&quot;&gt;QSGNode::UsePreprocess&lt;/a&gt; and override the &lt;a href=&quot;qsgnode#preprocess&quot;&gt;QSGNode::preprocess&lt;/a&gt;() function to do final preparation of their node. For example, dividing a bezier curve into the correct level of detail for the current scale factor or updating a section of a texture.</source>
          <target state="translated">노드에는 가상 &lt;a href=&quot;qsgnode#preprocess&quot;&gt;QSGNode :: preprocess&lt;/a&gt; () 함수가 있으며 장면 그래프가 렌더링되기 전에 호출됩니다. 노드 서브 클래스는 &lt;a href=&quot;qsgnode#Flag-enum&quot;&gt;QSGNode :: UsePreprocess&lt;/a&gt; 플래그를 설정하고 &lt;a href=&quot;qsgnode#preprocess&quot;&gt;QSGNode :: preprocess&lt;/a&gt; () 함수를 대체하여 노드의 최종 준비를 수행 할 수 있습니다. 예를 들어 베 지어 곡선을 현재 축척 비율에 대한 정확한 세부 수준으로 나누거나 텍스처 섹션을 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="1ebee72678859cff79a7fa65a52757fa5af07f91" translate="yes" xml:space="preserve">
          <source>Nodes may connect to each other directly using &lt;a href=&quot;qremoteobjectnode#connectToNode&quot;&gt;connectToNode&lt;/a&gt;, or they can use the &lt;a href=&quot;qremoteobjectregistry&quot;&gt;QRemoteObjectRegistry&lt;/a&gt; to simplify connections.</source>
          <target state="translated">노드는 &lt;a href=&quot;qremoteobjectnode#connectToNode&quot;&gt;connectToNode를&lt;/a&gt; 사용하여 직접 서로 연결 하거나 &lt;a href=&quot;qremoteobjectregistry&quot;&gt;QRemoteObjectRegistry&lt;/a&gt; 를 사용하여 연결을 단순화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ba0699ab58edd42a7d018746417fc4c82115a1ab" translate="yes" xml:space="preserve">
          <source>Nodes only support connection to one &lt;a href=&quot;qtremoteobjects-registry#registry&quot;&gt;registry&lt;/a&gt;, calling &lt;a href=&quot;qremoteobjectnode#registryUrl-prop&quot;&gt;QRemoteObjectNode::setRegistryUrl&lt;/a&gt; when a Registry is already set is considered an error. For something like a secure and insecure network (where different Registries would be applicable), the recommendation is to create separate Nodes to connect to each, in effect creating two independent Qt Remote Objects networks.</source>
          <target state="translated">노드 는 레지스트리가 이미 설정된 경우 &lt;a href=&quot;qremoteobjectnode#registryUrl-prop&quot;&gt;QRemoteObjectNode :: setRegistryUrl을&lt;/a&gt; 호출 하는 하나의 &lt;a href=&quot;qtremoteobjects-registry#registry&quot;&gt;레지스트리에&lt;/a&gt; 대한 연결 만 지원 하며 오류로 간주됩니다. 안전하고 안전하지 않은 네트워크 (다른 레지스트리가 적용되는 경우)와 같은 경우 별도의 노드를 만들어 서로 연결하여 두 개의 독립적 인 Qt 원격 개체 네트워크를 만드는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="fa5838313ca2079f797eeee330a781fb1d291955" translate="yes" xml:space="preserve">
          <source>Nodes, by themselves, don&amp;rsquo;t provide much use. But their value comes when you add &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; classes to a node to share. Then, any peer node can request a copy or instance of the shared object from the</source>
          <target state="translated">노드는 그 자체로 많은 사용을 제공하지 않습니다. 그러나 공유 할 노드에 &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 클래스를 추가하면 그 가치가 나타납니다 . 그런 다음 모든 피어 노드는 공유 객체의 사본 또는 인스턴스를</target>
        </trans-unit>
        <trans-unit id="d8a4d96815d59bde5bfd503fc3636f6ea9113162" translate="yes" xml:space="preserve">
          <source>Nodes, by themselves, don&amp;rsquo;t provide much use. The value comes from adding &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; classes to a node for sharing. Any peer node can then request a copy/instance of the shared object from the node that shares it (called the</source>
          <target state="translated">노드 자체는 그다지 유용하지 않습니다. 공유 할 노드에 &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 클래스를 추가하여 값을 가져옵니다 . 그런 다음 모든 피어 노드는 공유 노드를 공유하는 노드에서 공유 객체의 복사 / 인스턴스를 요청할 수 있습니다 (</target>
        </trans-unit>
        <trans-unit id="a6822e08a94ba41da49db5765612217e22f8105e" translate="yes" xml:space="preserve">
          <source>Noise coordinates. Default is &lt;code&gt;Qt.vector3d(1, 1, 1)&lt;/code&gt;.</source>
          <target state="translated">소음 좌표. 기본값은 &lt;code&gt;Qt.vector3d(1, 1, 1)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e9e1ec388c8a87e0fdc89562eac18adbb74a541e" translate="yes" xml:space="preserve">
          <source>Non null-terminated strings and strings containing &lt;code&gt;'\0'&lt;/code&gt;</source>
          <target state="translated">null로 끝나지 않는 문자열 및 &lt;code&gt;'\0'&lt;/code&gt; 포함하는 문자열</target>
        </trans-unit>
        <trans-unit id="e9e86256f7bad0dbd6828e7a90557c0d48737e41" translate="yes" xml:space="preserve">
          <source>Non-Item objects may use states through the &lt;a href=&quot;qml-qtquick-stategroup&quot;&gt;StateGroup&lt;/a&gt; type.</source>
          <target state="translated">비 항목 객체는 &lt;a href=&quot;qml-qtquick-stategroup&quot;&gt;StateGroup&lt;/a&gt; 유형을 통해 상태를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6276f0c299230b825417d3965c54f86f514952ec" translate="yes" xml:space="preserve">
          <source>Non-attached Scroll Bars</source>
          <target state="translated">부착되지 않은 스크롤 막대</target>
        </trans-unit>
        <trans-unit id="9362bd61b51d5152dfbae769699522c60b1649f3" translate="yes" xml:space="preserve">
          <source>Non-attached Scroll Indicators</source>
          <target state="translated">부착되지 않은 스크롤 표시기</target>
        </trans-unit>
        <trans-unit id="5223ee77cc19aabff1fc87ba38dc610a435ef809" translate="yes" xml:space="preserve">
          <source>Non-breakable text</source>
          <target state="translated">깨지지 않는 텍스트</target>
        </trans-unit>
        <trans-unit id="15bf21e487b389622890a596e34f6fc7e8f358bf" translate="yes" xml:space="preserve">
          <source>Non-breaking space.</source>
          <target state="translated">비파괴 공간.</target>
        </trans-unit>
        <trans-unit id="c5cadad8e7f92fdc6cc1afd5247d9c4d52cb2986" translate="yes" xml:space="preserve">
          <source>Non-capturing parentheses are also supported, with the same (?:pattern) syntax.</source>
          <target state="translated">동일한 (? : pattern) 구문을 사용하여 캡처하지 않는 괄호도 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="b7181cc7a6f1dca6a2d49d447bf66b160edb68ca" translate="yes" xml:space="preserve">
          <source>Non-configurable properties cannot be deleted.</source>
          <target state="translated">구성 할 수없는 속성은 삭제할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="fa4d03074c0b99b90528bfb67dc01ffcba2be859" translate="yes" xml:space="preserve">
          <source>Non-creatable abstract base for materials. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">재료에 대한 생성 불가능한 추상 기반. &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="edab9a2a25b22fc7c776469908f4910ac6788d01" translate="yes" xml:space="preserve">
          <source>Non-fatal alert message</source>
          <target state="translated">치명적이지 않은 경고 메시지</target>
        </trans-unit>
        <trans-unit id="7a038d7b18b864e7e3f5f81aa1f667340e63592c" translate="yes" xml:space="preserve">
          <source>Non-module Namespace Imports</source>
          <target state="translated">비 모듈 네임 스페이스 가져 오기</target>
        </trans-unit>
        <trans-unit id="fb8b24d7946f91e91d76f522345b8c44b842e4f4" translate="yes" xml:space="preserve">
          <source>Non-spontaneous show events are sent to widgets immediately before they are shown. The spontaneous show events of windows are delivered afterwards.</source>
          <target state="translated">자발적인 쇼 이벤트는 표시되기 직전에 위젯으로 전송됩니다. 자발적인 창문 쇼 이벤트가 나중에 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="58ff5229d38da23617ecee2d0708ea4305553037" translate="yes" xml:space="preserve">
          <source>Non-standard delimiters</source>
          <target state="translated">비표준 구분자</target>
        </trans-unit>
        <trans-unit id="73607959ac3fa3dd9656f59a604eea91937b1a5b" translate="yes" xml:space="preserve">
          <source>Non-standard delimiters should be chosen from among what RFC 3986 calls &quot;sub-delimiters&quot;. They are:</source>
          <target state="translated">비표준 구분 기호는 RFC 3986이 &quot;하위 구분 기호&quot;라고 부르는 것 중에서 선택해야합니다. 그들은:</target>
        </trans-unit>
        <trans-unit id="95b5beb380dada9cb130a15b619a021f4394910f" translate="yes" xml:space="preserve">
          <source>Non-threaded Render Loop ('basic')</source>
          <target state="translated">스레드되지 않은 렌더 루프 ( '기본')</target>
        </trans-unit>
        <trans-unit id="80dffdb056406d0c06286319912320a2ccc1a2c0" translate="yes" xml:space="preserve">
          <source>Non-threaded Render Loops (&quot;basic&quot; and &quot;windows&quot;)</source>
          <target state="translated">스레드되지 않은 렌더 루프 ( &quot;기본&quot;및 &quot;창&quot;)</target>
        </trans-unit>
        <trans-unit id="85379b4f454e1a1ec90576665b6330ebec5ecb17" translate="yes" xml:space="preserve">
          <source>Non-trivial program logic is best separated into a separate JavaScript file. This file can be imported into QML using an &lt;code&gt;import&lt;/code&gt; statement, like the QML &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtqml-modules-topic.html#&quot;&gt;modules&lt;/a&gt;.</source>
          <target state="translated">사소한 프로그램 논리는 별도의 JavaScript 파일로 분리하는 것이 가장 좋습니다. 이 파일은 QML &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtqml-modules-topic.html#&quot;&gt;모듈&lt;/a&gt; 과 같은 &lt;code&gt;import&lt;/code&gt; 문을 사용하여 QML로 가져올 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3d4f7d7ad4cdd7849196c2916c7c47d3b9f37de7" translate="yes" xml:space="preserve">
          <source>Non-trivial program logic is best separated into a separate JavaScript file. This file can be imported into QML using an &lt;code&gt;import&lt;/code&gt; statement, like the QML &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtqml-modules-topic.html&quot;&gt;modules&lt;/a&gt;.</source>
          <target state="translated">사소하지 않은 프로그램 논리는 별도의 JavaScript 파일로 분리하는 것이 가장 좋습니다. 이 파일은 QML &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtqml-modules-topic.html&quot;&gt;모듈&lt;/a&gt; 과 같은 &lt;code&gt;import&lt;/code&gt; 문을 사용하여 QML로 가져올 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e0849e1accc9772f46e3ad8bfe65b666f707d642" translate="yes" xml:space="preserve">
          <source>Non-trivial program logic is best separated into a separate JavaScript file. This file can be imported into QML using an &lt;code&gt;import&lt;/code&gt; statement, like the QML &lt;a href=&quot;https://doc.qt.io/qt-6.0/qtqml-modules-topic.html&quot;&gt;modules&lt;/a&gt;.</source>
          <target state="translated">사소하지 않은 프로그램 논리는 별도의 JavaScript 파일로 분리하는 것이 가장 좋습니다. 이 파일은 QML &lt;a href=&quot;https://doc.qt.io/qt-6.0/qtqml-modules-topic.html&quot;&gt;모듈&lt;/a&gt; 과 같은 &lt;code&gt;import&lt;/code&gt; 문을 사용하여 QML로 가져올 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0cae7d1907e1ec054bbcb462e9150a496a2aef41" translate="yes" xml:space="preserve">
          <source>Non-window widgets are child widgets, displayed within their parent widgets. Most widgets in Qt are mainly useful as child widgets. For example, it is possible to display a button as a top-level window, but most people prefer to put their buttons inside other widgets, such as &lt;a href=&quot;qdialog&quot;&gt;QDialog&lt;/a&gt;.</source>
          <target state="translated">비 창조 위젯은 상위 위젯 내에 표시되는 하위 위젯입니다. Qt의 대부분의 위젯은 주로 하위 위젯으로 유용합니다. 예를 들어, 단추를 최상위 창으로 표시 할 수 있지만 대부분의 사람들은 단추를 &lt;a href=&quot;qdialog&quot;&gt;QDialog&lt;/a&gt; 와 같은 다른 위젯에 배치하는 것을 선호합니다 .</target>
        </trans-unit>
        <trans-unit id="efd9fba9d8cf5c2911fd3637507059d2379a47cd" translate="yes" xml:space="preserve">
          <source>Non-zero winding fill rule.</source>
          <target state="translated">0이 아닌 와인딩 채우기 규칙.</target>
        </trans-unit>
        <trans-unit id="6eef6648406c333a4035cd5e60d0bf2ecf2606d7" translate="yes" xml:space="preserve">
          <source>None</source>
          <target state="translated">None</target>
        </trans-unit>
        <trans-unit id="f5a2b73ba7ff78806dc13321133e57fb1713be8f" translate="yes" xml:space="preserve">
          <source>None of the above.</source>
          <target state="translated">위의 어느 것도 아닙니다.</target>
        </trans-unit>
        <trans-unit id="7886314e8ebf0262af1d397f949489c67bb2ba1d" translate="yes" xml:space="preserve">
          <source>None of the buttons are checked.</source>
          <target state="translated">버튼이 확인되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="cf83a8cb40bb34fe81a6732864fb82cce5d11bdb" translate="yes" xml:space="preserve">
          <source>None of the options are enabled.</source>
          <target state="translated">활성화 된 옵션이 없습니다.</target>
        </trans-unit>
        <trans-unit id="0a892cc16753ffc8a2335b0c6b28684cfa10d535" translate="yes" xml:space="preserve">
          <source>None of the other layer properties have any effect when the layer is disabled.</source>
          <target state="translated">다른 레이어 속성은 레이어가 비활성화되어있을 때 아무런 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2c94a1d7df8a7b93c9aa610b38bcd712ead98797" translate="yes" xml:space="preserve">
          <source>None of the positioning methods.</source>
          <target state="translated">위치 결정 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="1461f445da137b2e6a0e80f578b4d32f6e79eec5" translate="yes" xml:space="preserve">
          <source>None of the values changed.</source>
          <target state="translated">값이 변경되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="c2a1b919b3200174dffbefe7bd662d030e2a57cf" translate="yes" xml:space="preserve">
          <source>Nonetheless, couldn't a template-based solution improve the performance of an application using signals and slots? While it is true that Qt adds a small overhead to the cost of calling a slot through a signal, the cost of the call is only a small proportion of the entire cost of a slot. Benchmarking against Qt's signals and slots system is typically done with empty slots. As soon as you do anything useful in your slots, for example a few simple string operations, the calling overhead becomes negligible. Qt's system is so optimized that anything that requires operator new or delete (for example, string operations or inserting/removing something from a template container) is significantly more expensive than emitting a signal.</source>
          <target state="translated">그럼에도 불구하고 템플릿 기반 솔루션이 신호와 슬롯을 사용하는 애플리케이션의 성능을 향상시킬 수 없었습니까? Qt가 신호를 통해 슬롯을 호출하는 비용에 작은 오버 헤드를 추가하는 것은 사실이지만, 호출 비용은 슬롯 전체 비용의 작은 비율에 지나지 않습니다. Qt의 신호 및 슬롯 시스템에 대한 벤치마킹은 일반적으로 빈 슬롯으로 수행됩니다. 몇 가지 간단한 문자열 작업과 같이 슬롯에서 유용한 작업을 수행하면 호출 오버 헤드는 무시할 수 있습니다. Qt의 시스템은 연산자 새로 만들기 또는 삭제 (예 : 문자열 작업 또는 템플릿 컨테이너에서 항목 삽입 / 제거)가 필요한 것이 신호를 방출하는 것보다 훨씬 비싸도록 최적화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="992352057ac7a1f4eb8027b59c17e1bc9040cdae" translate="yes" xml:space="preserve">
          <source>Nor does X11 provide a way to maximize a window. &lt;a href=&quot;qwidget#showMaximized&quot;&gt;QWidget::showMaximized&lt;/a&gt;() has to emulate the feature. Its result depends on the result of &lt;a href=&quot;qwidget#frameGeometry-prop&quot;&gt;QWidget::frameGeometry&lt;/a&gt;() and the capability of the window manager to do proper window placement, neither of which can be guaranteed.</source>
          <target state="translated">X11은 창을 최대화하는 방법도 제공하지 않습니다. &lt;a href=&quot;qwidget#showMaximized&quot;&gt;QWidget :: showMaximized&lt;/a&gt; ()는 기능을 에뮬레이션해야합니다. 결과는 &lt;a href=&quot;qwidget#frameGeometry-prop&quot;&gt;QWidget :: frameGeometry&lt;/a&gt; () 의 결과 와 적절한 창 배치를 수행 할 수있는 창 관리자의 기능에 따라 달라집니다 .</target>
        </trans-unit>
        <trans-unit id="45e118d0563ea8581f830f46e85b60ae714faae4" translate="yes" xml:space="preserve">
          <source>Normal</source>
          <target state="translated">Normal</target>
        </trans-unit>
        <trans-unit id="3736ee6b2e7fd5a4ab3b5f833cf7ec56e405db1b" translate="yes" xml:space="preserve">
          <source>Normal (restore) button on title bars.</source>
          <target state="translated">제목 표시 줄의 일반 (복원) 버튼</target>
        </trans-unit>
        <trans-unit id="7ec88960224e7a0b423ba63d8e01b01bc57e99b4" translate="yes" xml:space="preserve">
          <source>Normal (restore) button.</source>
          <target state="translated">일반 (복원) 버튼</target>
        </trans-unit>
        <trans-unit id="297dc61b5ef2fe08558d3653bd9498c73a39218e" translate="yes" xml:space="preserve">
          <source>Normal 2D rendering</source>
          <target state="translated">일반 2D 렌더링</target>
        </trans-unit>
        <trans-unit id="ac571a8104acf381b8dae28366bdb5dcd9e5cd3e" translate="yes" xml:space="preserve">
          <source>Normal 2D rendering with depth buffer disabled</source>
          <target state="translated">깊이 버퍼가 비활성화 된 일반 2D 렌더링</target>
        </trans-unit>
        <trans-unit id="f70f2dfa5661c4bda711e98df64e2d6cb2d69912" translate="yes" xml:space="preserve">
          <source>Normal C++ classes and functions can be used from managed .NET code by providing thin wrapper classes written in MC++. The wrapper class will take care of forwarding the calls to the normal C++ functions or methods, and converting parameter data as necessary. Since the wrapper class is a managed class, it can be used without further ado in any managed .NET application, whether written in C#, VB.NET, MC++ or other managed programming language.</source>
          <target state="translated">MC ++로 작성된 씬 래퍼 클래스를 제공하여 관리되는 .NET 코드에서 일반 C ++ 클래스 및 함수를 사용할 수 있습니다. 랩퍼 클래스는 호출을 일반 C ++ 함수 또는 메소드로 전달하고 필요에 따라 매개 변수 데이터를 변환합니다. 래퍼 클래스는 관리되는 클래스이므로 C #, VB.NET, MC ++ 또는 기타 관리되는 프로그래밍 언어로 작성된 관리되는 .NET 응용 프로그램에서 더 이상 사용하지 않고도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="346f25e5c8412dc95329f2a62136a44be69a0604" translate="yes" xml:space="preserve">
          <source>Normal Matching</source>
          <target state="translated">정상 매칭</target>
        </trans-unit>
        <trans-unit id="e504c4e197ed776f28166af32c8af402c7ec4f2d" translate="yes" xml:space="preserve">
          <source>Normal closure</source>
          <target state="translated">정상적인 폐쇄</target>
        </trans-unit>
        <trans-unit id="0739a40cb9287a423939c89161696333540e990c" translate="yes" xml:space="preserve">
          <source>Normal glyphs used in unstyled text.</source>
          <target state="translated">스타일이 지정되지 않은 텍스트에 사용되는 일반 글리프입니다.</target>
        </trans-unit>
        <trans-unit id="f604538414473b15cb5f94825afefbabc5f8a392" translate="yes" xml:space="preserve">
          <source>Normal priority</source>
          <target state="translated">보통 우선 순위</target>
        </trans-unit>
        <trans-unit id="52426b8e08a084fba86443b9a8b3ea50fc0b0f22" translate="yes" xml:space="preserve">
          <source>Normal sockets requesting a connection to a remote server, like &lt;a href=&quot;qtcpsocket&quot;&gt;QTcpSocket&lt;/a&gt;. The peer hostname and peer port match the values passed to &lt;a href=&quot;qabstractsocket#connectToHost&quot;&gt;QTcpSocket::connectToHost&lt;/a&gt;(). The local port is usually -1, indicating the socket has no preference in which port should be used. The URL component is not used.</source>
          <target state="translated">&lt;a href=&quot;qtcpsocket&quot;&gt;QTcpSocket&lt;/a&gt; 과 같은 원격 서버에 대한 연결을 요청하는 일반 소켓 . 피어 호스트 이름 및 피어 포트는 &lt;a href=&quot;qabstractsocket#connectToHost&quot;&gt;QTcpSocket :: connectToHost&lt;/a&gt; ()에 전달 된 값과 일치합니다 . 로컬 포트는 일반적으로 -1이며, 소켓이 어떤 포트를 사용해야하는지 선호하지 않음을 나타냅니다. URL 구성 요소가 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b62e75cc783d6fb62251f392452b3b96a0b0ef52" translate="yes" xml:space="preserve">
          <source>Normal state.</source>
          <target state="translated">상태.</target>
        </trans-unit>
        <trans-unit id="4ff02f66f03fbe63be4c8c1d700369b61036d472" translate="yes" xml:space="preserve">
          <source>NormalDiffuseMapAlphaMaterial (QML type)</source>
          <target state="translated">NormalDiffuseMapAlphaMaterial (QML 유형)</target>
        </trans-unit>
        <trans-unit id="9f0f121cb323bdb855c8723469a47189f966d0f8" translate="yes" xml:space="preserve">
          <source>NormalDiffuseMapAlphaMaterial QML Type</source>
          <target state="translated">NormalDiffuseMapAlphaMaterial QML 유형</target>
        </trans-unit>
        <trans-unit id="5ae319288fc94a97a4f67dfa2c1c04d648afaf6e" translate="yes" xml:space="preserve">
          <source>NormalDiffuseMapAlphaMaterial.ambient</source>
          <target state="translated">NormalDiffuseMapAlphaMaterial.ambient</target>
        </trans-unit>
        <trans-unit id="710e5b3f22e4421c693c654b298ef90bd80d05ff" translate="yes" xml:space="preserve">
          <source>NormalDiffuseMapAlphaMaterial.diffuse</source>
          <target state="translated">NormalDiffuseMapAlphaMaterial.diffuse</target>
        </trans-unit>
        <trans-unit id="d4f2559c734631d2c5768c310433dd849637de34" translate="yes" xml:space="preserve">
          <source>NormalDiffuseMapAlphaMaterial.normal</source>
          <target state="translated">NormalDiffuseMapAlphaMaterial.normal</target>
        </trans-unit>
        <trans-unit id="88f2036e028a542bc90994c0036213bec52e4b5a" translate="yes" xml:space="preserve">
          <source>NormalDiffuseMapAlphaMaterial.shininess</source>
          <target state="translated">NormalDiffuseMapAlphaMaterial.shininess</target>
        </trans-unit>
        <trans-unit id="138e4fe2584bb7d86515176bce248270af2c21b7" translate="yes" xml:space="preserve">
          <source>NormalDiffuseMapAlphaMaterial.specular</source>
          <target state="translated">NormalDiffuseMapAlphaMaterial.specular</target>
        </trans-unit>
        <trans-unit id="6412d6ffcc76c25f7259c1da7a2eb8cb4a7d3c96" translate="yes" xml:space="preserve">
          <source>NormalDiffuseMapAlphaMaterial.textureScale</source>
          <target state="translated">NormalDiffuseMapAlphaMaterial.textureScale</target>
        </trans-unit>
        <trans-unit id="1f1efe8e16003bd03110ada0eb5b942d5b92afe0" translate="yes" xml:space="preserve">
          <source>NormalDiffuseMapMaterial (QML type)</source>
          <target state="translated">NormalDiffuseMapMaterial (QML 유형)</target>
        </trans-unit>
        <trans-unit id="c9f858640dc19343b23e1dee61e715e14b3d865a" translate="yes" xml:space="preserve">
          <source>NormalDiffuseMapMaterial QML Type</source>
          <target state="translated">NormalDiffuseMapMaterial QML 유형</target>
        </trans-unit>
        <trans-unit id="a4df8fcb2fe1b05452320e7b13dbcd44d583326b" translate="yes" xml:space="preserve">
          <source>NormalDiffuseMapMaterial.ambient</source>
          <target state="translated">NormalDiffuseMapMaterial.ambient</target>
        </trans-unit>
        <trans-unit id="074a144d591cf62ed44ce237e1f97854af44bb68" translate="yes" xml:space="preserve">
          <source>NormalDiffuseMapMaterial.diffuse</source>
          <target state="translated">NormalDiffuseMapMaterial.diffuse</target>
        </trans-unit>
        <trans-unit id="74038be5a2ce0293770a04cd13a8699a0c7cae95" translate="yes" xml:space="preserve">
          <source>NormalDiffuseMapMaterial.normal</source>
          <target state="translated">NormalDiffuseMapMaterial.normal</target>
        </trans-unit>
        <trans-unit id="4c0e1ab0c0ee46fb07049ea120dbc215fc526fde" translate="yes" xml:space="preserve">
          <source>NormalDiffuseMapMaterial.shininess</source>
          <target state="translated">NormalDiffuseMapMaterial.shininess</target>
        </trans-unit>
        <trans-unit id="f36e677c53c02750e63d151cd4129ebe68aa8322" translate="yes" xml:space="preserve">
          <source>NormalDiffuseMapMaterial.specular</source>
          <target state="translated">NormalDiffuseMapMaterial.specular</target>
        </trans-unit>
        <trans-unit id="689767af391cf8bc30d11e9ad8907c3bbce0c825" translate="yes" xml:space="preserve">
          <source>NormalDiffuseMapMaterial.textureScale</source>
          <target state="translated">NormalDiffuseMapMaterial.textureScale</target>
        </trans-unit>
        <trans-unit id="349d9ac23c035ee66228850833eaf71713db27da" translate="yes" xml:space="preserve">
          <source>NormalDiffuseSpecularMapMaterial (QML type)</source>
          <target state="translated">NormalDiffuseSpecularMapMaterial (QML 유형)</target>
        </trans-unit>
        <trans-unit id="a1896022049eff48a9081f3e6d61d708881cd754" translate="yes" xml:space="preserve">
          <source>NormalDiffuseSpecularMapMaterial QML Type</source>
          <target state="translated">NormalDiffuseSpecularMapMaterial QML 유형</target>
        </trans-unit>
        <trans-unit id="f31602c9f426c050c4c90bb214c75ada84136386" translate="yes" xml:space="preserve">
          <source>NormalDiffuseSpecularMapMaterial.ambient</source>
          <target state="translated">NormalDiffuseSpecularMapMaterial.ambient</target>
        </trans-unit>
        <trans-unit id="91600070295a98f6add0d310a1922598f81afd3b" translate="yes" xml:space="preserve">
          <source>NormalDiffuseSpecularMapMaterial.diffuse</source>
          <target state="translated">NormalDiffuseSpecularMapMaterial.diffuse</target>
        </trans-unit>
        <trans-unit id="463c8c381f7f05843dddccfc6018ad5091bdbd54" translate="yes" xml:space="preserve">
          <source>NormalDiffuseSpecularMapMaterial.normal</source>
          <target state="translated">NormalDiffuseSpecularMapMaterial.normal</target>
        </trans-unit>
        <trans-unit id="cd0df550097f0660258725a30bd15f3adb75d0b6" translate="yes" xml:space="preserve">
          <source>NormalDiffuseSpecularMapMaterial.shininess</source>
          <target state="translated">NormalDiffuseSpecularMapMaterial.shininess</target>
        </trans-unit>
        <trans-unit id="5b2d87597e5dca03fc91a55bdbf3afbc59e91716" translate="yes" xml:space="preserve">
          <source>NormalDiffuseSpecularMapMaterial.specular</source>
          <target state="translated">NormalDiffuseSpecularMapMaterial.specular</target>
        </trans-unit>
        <trans-unit id="a761f40a784a0388b64a95c1fe1ab10481f2400a" translate="yes" xml:space="preserve">
          <source>NormalDiffuseSpecularMapMaterial.textureScale</source>
          <target state="translated">NormalDiffuseSpecularMapMaterial.textureScale</target>
        </trans-unit>
        <trans-unit id="39208c598f8f515fde64f9754eb85c702248a1b1" translate="yes" xml:space="preserve">
          <source>Normalized</source>
          <target state="translated">Normalized</target>
        </trans-unit>
        <trans-unit id="b9c34a63faa73cf80c734eac4bf0ccd7eef076a8" translate="yes" xml:space="preserve">
          <source>Normalized linear interpolation.</source>
          <target state="translated">정규화 된 선형 보간.</target>
        </trans-unit>
        <trans-unit id="2443adae128dbed73712a76e48f2046023f6ab74" translate="yes" xml:space="preserve">
          <source>Normalizes a</source>
          <target state="translated">정규화</target>
        </trans-unit>
        <trans-unit id="9560d5af79f830514f6451a7c9f1e6b5156b1ba4" translate="yes" xml:space="preserve">
          <source>Normalizes the currect vector in place. Nothing happens if this vector is a null vector or the length of the vector is very close to 1.</source>
          <target state="translated">정확한 벡터를 제자리로 정규화합니다. 이 벡터가 null 벡터이거나 벡터의 길이가 1에 매우 가까운 경우 아무 일도 일어나지 않습니다.</target>
        </trans-unit>
        <trans-unit id="84de5ff8cc5549fe0b2bd027b2bd47ff57a98b35" translate="yes" xml:space="preserve">
          <source>Normalizes the current quaternion in place. Nothing happens if this is a null quaternion or the length of the quaternion is very close to 1.</source>
          <target state="translated">현재 쿼터니언을 제자리로 정규화합니다. 이것이 null 쿼터니언이거나 쿼터니언의 길이가 1에 매우 가까운 경우 아무 일도 일어나지 않습니다.</target>
        </trans-unit>
        <trans-unit id="43ddcc6f2f9237bfc9ac9f9010e7d7dd3092f536" translate="yes" xml:space="preserve">
          <source>Normalizes the signature of the given</source>
          <target state="translated">주어진 서명을 정규화</target>
        </trans-unit>
        <trans-unit id="5029d632ac854071a43ce9d7c0fffddab82f2154" translate="yes" xml:space="preserve">
          <source>Normally &lt;code&gt;stop()&lt;/code&gt; stops the animation immediately, and the animation has no further influence on property values. In this example animation</source>
          <target state="translated">일반적으로 &lt;code&gt;stop()&lt;/code&gt; 은 애니메이션을 즉시 중지하며 애니메이션은 속성 값에 더 이상 영향을 미치지 않습니다. 이 예제에서는 애니메이션</target>
        </trans-unit>
        <trans-unit id="034d182db8d77526f8a2a9b256882c1c25192f94" translate="yes" xml:space="preserve">
          <source>Normally QML files can be loaded as types directly from other QML files, or using a qmldir file. This function allows registration of files to types from C++ code, such as when the type mapping needs to be procedurally determined at startup.</source>
          <target state="translated">일반적으로 QML 파일은 다른 QML 파일에서 직접 또는 qmldir 파일을 사용하여 유형으로로드 할 수 있습니다. 이 함수를 사용하면 시작시 형식 매핑을 절차 적으로 결정해야하는 경우와 같이 C ++ 코드에서 형식에 파일을 등록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6600d7d0393e89b9a7631e7bcbb16f238a29630b" translate="yes" xml:space="preserve">
          <source>Normally a slider increases as it moves up or to the right; upsideDown indicates that it should do the opposite (increase as it moves down or to the left). The default value is false, i.e. the slider increases as it moves up or to the right.</source>
          <target state="translated">일반적으로 슬라이더는 위쪽 또는 오른쪽으로 이동함에 따라 증가합니다. upsideDown은 반대 방향으로 수행해야 함을 나타냅니다 (아래 또는 왼쪽으로 이동함에 따라 증가). 기본값은 false입니다. 즉 슬라이더가 위로 또는 오른쪽으로 이동함에 따라 슬라이더가 증가합니다.</target>
        </trans-unit>
        <trans-unit id="435b01db9d98ea32e7c65115d1e7b78923d847ed" translate="yes" xml:space="preserve">
          <source>Normally an action is added to a group by creating it with the group as its parent, so this function is not usually used.</source>
          <target state="translated">일반적으로 그룹을 상위 그룹으로하여 조치를 작성하여 조치를 그룹에 추가하므로이 기능은 일반적으로 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b6e494520f7e1a277faacf10969bb6505206330f" translate="yes" xml:space="preserve">
          <source>Normally an action is added to a group by creating it with the group as parent, so this function is not usually used.</source>
          <target state="translated">일반적으로 그룹을 상위 그룹으로 작성하여 조치를 그룹에 추가하므로이 기능은 일반적으로 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ae59032e3f1b5647d4a56842863f96cbb6a59fdc" translate="yes" xml:space="preserve">
          <source>Normally an application will not need to create its own &lt;a href=&quot;qfocusframe&quot;&gt;QFocusFrame&lt;/a&gt; as &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt; will handle this detail for you. A style writer can optionally use a &lt;a href=&quot;qfocusframe&quot;&gt;QFocusFrame&lt;/a&gt; to have a focus area outside of the widget's paintable geometry. In this way space need not be reserved for the widget to have focus but only set on a &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; with &lt;a href=&quot;qfocusframe#setWidget&quot;&gt;QFocusFrame::setWidget&lt;/a&gt;. It is, however, legal to create your own &lt;a href=&quot;qfocusframe&quot;&gt;QFocusFrame&lt;/a&gt; on a custom widget and set its geometry manually via &lt;a href=&quot;qwidget#geometry-prop&quot;&gt;QWidget::setGeometry&lt;/a&gt; however you will not get auto-placement when the focused widget changes size or placement.</source>
          <target state="translated">일반적으로 응용 프로그램은 자신의 만들 필요가 없습니다 &lt;a href=&quot;qfocusframe&quot;&gt;QFocusFrame을&lt;/a&gt; 같이 &lt;a href=&quot;qstyle&quot;&gt;QStyle는&lt;/a&gt; 당신이 세부 사항을 처리합니다. 스타일 작성자는 선택적으로 &lt;a href=&quot;qfocusframe&quot;&gt;QFocusFrame&lt;/a&gt; 을 사용 하여 위젯의 페인트 가능한 지오메트리 외부에 초점 영역을 가질 수 있습니다 . 이런 식으로 공간에 초점을하는 위젯에 예약 할 필요는 있지만, 만에 설정된 &lt;a href=&quot;qwidget&quot;&gt;는 QWidget&lt;/a&gt; 과 &lt;a href=&quot;qfocusframe#setWidget&quot;&gt;QFocusFrame :: setWidget&lt;/a&gt; . 그러나 사용자 정의 위젯에서 사용자 고유의 &lt;a href=&quot;qfocusframe&quot;&gt;QFocusFrame&lt;/a&gt; 을 작성 하고 &lt;a href=&quot;qwidget#geometry-prop&quot;&gt;QWidget :: setGeometry&lt;/a&gt; 를 통해 해당 지오메트리를 수동으로 설정하는 것이 합법적 이지만 초점이 맞춰진 위젯의 크기 나 위치가 변경 될 때 자동 배치를 얻지 못합니다.</target>
        </trans-unit>
        <trans-unit id="c39dfaadd7098b4048e5c6936c5103e35195c9fa" translate="yes" xml:space="preserve">
          <source>Normally an application will not need to create its own QFocusFrame as &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt; will handle this detail for you. A style writer can optionally use a QFocusFrame to have a focus area outside of the widget's paintable geometry. In this way space need not be reserved for the widget to have focus but only set on a &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; with &lt;a href=&quot;qfocusframe#setWidget&quot;&gt;QFocusFrame::setWidget&lt;/a&gt;. It is, however, legal to create your own QFocusFrame on a custom widget and set its geometry manually via &lt;a href=&quot;qwidget#geometry-prop&quot;&gt;QWidget::setGeometry&lt;/a&gt; however you will not get auto-placement when the focused widget changes size or placement.</source>
          <target state="translated">일반적으로 응용 프로그램은 &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt; 이이 세부 사항을 처리 하므로 자체 QFocusFrame을 만들 필요가 없습니다 . 스타일 작성자는 선택적으로 QFocusFrame을 사용하여 위젯의 페인팅 가능한 지오메트리 외부에 초점 영역을 가질 수 있습니다. 이런 식으로 공간에 초점을하는 위젯에 예약 할 필요는 있지만, 만에 설정된 &lt;a href=&quot;qwidget&quot;&gt;는 QWidget&lt;/a&gt; 과 &lt;a href=&quot;qfocusframe#setWidget&quot;&gt;QFocusFrame :: setWidget&lt;/a&gt; . 그러나 사용자 정의 위젯에서 자신의 QFocusFrame을 만들고 &lt;a href=&quot;qwidget#geometry-prop&quot;&gt;QWidget :: setGeometry&lt;/a&gt; 를 통해 수동으로 지오메트리를 설정하는 것은 합법적 이지만 포커스가있는 위젯의 크기 나 배치가 변경 될 때 자동 배치되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5e398bbb1753b447c9936b5787874ea728b1486e" translate="yes" xml:space="preserve">
          <source>Normally an application will not need to create its own QFocusFrame as &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt; will handle this detail for you. A style writer can optionally use a QFocusFrame to have a focus area outside of the widget's paintable geometry. In this way space need not be reserved for the widget to have focus but only set on a &lt;a href=&quot;widgets-changes-qt6#qwidget&quot;&gt;QWidget&lt;/a&gt; with &lt;a href=&quot;qfocusframe#setWidget&quot;&gt;QFocusFrame::setWidget&lt;/a&gt;. It is, however, legal to create your own QFocusFrame on a custom widget and set its geometry manually via &lt;a href=&quot;qwidget#geometry-prop&quot;&gt;QWidget::setGeometry&lt;/a&gt; however you will not get auto-placement when the focused widget changes size or placement.</source>
          <target state="translated">일반적으로 응용 프로그램은 &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt; 이이 세부 정보를 처리 하므로 자체 QFocusFrame을 만들 필요가 없습니다 . 스타일 작성자는 선택적으로 QFocusFrame을 사용하여 위젯의 페인팅 가능한 지오메트리 외부에 초점 영역을 가질 수 있습니다. 이런 식으로 공간에 초점을하는 위젯에 예약 할 필요는 있지만, 만에 설정된 &lt;a href=&quot;widgets-changes-qt6#qwidget&quot;&gt;는 QWidget&lt;/a&gt; 과 &lt;a href=&quot;qfocusframe#setWidget&quot;&gt;QFocusFrame :: setWidget&lt;/a&gt; . 그러나 사용자 정의 위젯에서 자신의 QFocusFrame을 만들고 &lt;a href=&quot;qwidget#geometry-prop&quot;&gt;QWidget :: setGeometry&lt;/a&gt; 를 통해 수동으로 지오메트리를 설정하는 것은 합법적 이지만 포커스가있는 위젯의 크기 나 배치가 변경 될 때 자동 배치되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8ada750f68d5c889391a04aee92104e6aed25ac7" translate="yes" xml:space="preserve">
          <source>Normally animations are driven by an internal timer, but the &lt;a href=&quot;qml-qtquick-animationcontroller&quot;&gt;AnimationController&lt;/a&gt; allows the given</source>
          <target state="translated">일반적으로 애니메이션은 내부 타이머에 의해 구동되지만 &lt;a href=&quot;qml-qtquick-animationcontroller&quot;&gt;AnimationController&lt;/a&gt; 는</target>
        </trans-unit>
        <trans-unit id="578baacdba94b1239ae42e4b2b6da627c48ac596" translate="yes" xml:space="preserve">
          <source>Normally animations are driven by an internal timer, but the AnimationController allows the given</source>
          <target state="translated">일반적으로 애니메이션은 내부 타이머에 의해 구동되지만 AnimationController는 주어진</target>
        </trans-unit>
        <trans-unit id="64ca7d31ad558b522415835b4e918957ae665f71" translate="yes" xml:space="preserve">
          <source>Normally applications should not need to call this function, keyboard should automatically close when the text editor loses focus, for example when the parent view is closed.</source>
          <target state="translated">일반적으로 응용 프로그램은이 함수를 호출 할 필요가 없습니다. 예를 들어 부모보기가 닫히는 경우와 같이 텍스트 편집기에서 포커스를 잃으면 키보드가 자동으로 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="9cd08cb62d5640e08bba92fffe8f40e2b164a713" translate="yes" xml:space="preserve">
          <source>Normally applications should not need to call this function, keyboard should automatically open when the text editor gains focus.</source>
          <target state="translated">일반적으로 응용 프로그램은이 함수를 호출 할 필요가 없으며 텍스트 편집기에 포커스가 있으면 키보드가 자동으로 열립니다.</target>
        </trans-unit>
        <trans-unit id="08f59d367255c82db9315de7f997fdbedfbd186d" translate="yes" xml:space="preserve">
          <source>Normally if you declare a Window inside an Item or inside another Window, this relationship is deduced automatically. In that case, if you declare this window's &lt;a href=&quot;qml-qtquick-window-window#visible-prop&quot;&gt;visible&lt;/a&gt; property &lt;code&gt;true&lt;/code&gt;, it will not actually be shown until the &lt;code&gt;transientParent&lt;/code&gt; window is shown.</source>
          <target state="translated">일반적으로 Item 내부 또는 다른 Window 내부에 Window를 선언하면이 관계가 자동으로 추론됩니다. 이 경우이 창의 &lt;a href=&quot;qml-qtquick-window-window#visible-prop&quot;&gt;visible&lt;/a&gt; 속성을 &lt;code&gt;true&lt;/code&gt; 로 선언 하면 &lt;code&gt;transientParent&lt;/code&gt; 창이 표시 될 때까지 실제로 표시되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="e84be9131df481824013daf8b72b8b74d1f8d751" translate="yes" xml:space="preserve">
          <source>Normally if you declare a Window inside an Item or inside another Window, this relationship is deduced automatically. In that case, if you declare this window's &lt;a href=&quot;qml-window#visible-prop&quot;&gt;visible&lt;/a&gt; property &lt;code&gt;true&lt;/code&gt;, it will not actually be shown until the &lt;code&gt;transientParent&lt;/code&gt; window is shown.</source>
          <target state="translated">일반적으로 Item 내부 또는 다른 Window 내부에서 Window를 선언하면이 관계가 자동으로 추론됩니다. 이 경우이 창의 &lt;a href=&quot;qml-window#visible-prop&quot;&gt;visible&lt;/a&gt; 속성을 &lt;code&gt;true&lt;/code&gt; 로 선언 하면 &lt;code&gt;transientParent&lt;/code&gt; 창이 표시 될 때까지 실제로 표시되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="5a9a68fb9e734166f16a9fcc29bde0900b1f728c" translate="yes" xml:space="preserve">
          <source>Normally it should not be necessary to call this function directly as all functions that set properties of the texture object implicitly call create() on your behalf.</source>
          <target state="translated">일반적으로 텍스처 객체의 속성을 설정하는 모든 함수가 사용자를 대신하여 create ()를 암시 적으로 호출하므로이 함수를 직접 호출 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="0e085831bcebe6ac4481b5eb28a75e9ba40b52f0" translate="yes" xml:space="preserve">
          <source>Normally it will be used with &lt;a href=&quot;qml-qtquick-repeater&quot;&gt;Repeater&lt;/a&gt; to visualize the links and provide the ability to click them:</source>
          <target state="translated">일반적으로 링크를 시각화하고 클릭 할 수있는 기능을 제공하기 위해 &lt;a href=&quot;qml-qtquick-repeater&quot;&gt;Repeater&lt;/a&gt; 와 함께 사용 됩니다.</target>
        </trans-unit>
        <trans-unit id="275c0d961ccbc0995f2bbf5e3ff36d1d3cc9b298" translate="yes" xml:space="preserve">
          <source>Normally the &lt;a href=&quot;qmatrix4x4&quot;&gt;QMatrix4x4&lt;/a&gt; class keeps track of this special type internally as operations are performed. However, if the matrix is modified directly with {&lt;a href=&quot;qloggingcategory#operator-28-29&quot;&gt;QLoggingCategory::operator&lt;/a&gt;()}{&lt;a href=&quot;qmatrix4x4#operator-28-29&quot;&gt;operator&lt;/a&gt;()()} or &lt;a href=&quot;qmatrix4x4#data&quot;&gt;data&lt;/a&gt;(), then &lt;a href=&quot;qmatrix4x4&quot;&gt;QMatrix4x4&lt;/a&gt; will lose track of the special type and will revert to the safest but least efficient operations thereafter.</source>
          <target state="translated">일반적으로 &lt;a href=&quot;qmatrix4x4&quot;&gt;QMatrix4x4&lt;/a&gt; 클래스는 작업이 수행 될 때이 특수 유형을 내부적으로 추적합니다. 그러나 { &lt;a href=&quot;qloggingcategory#operator-28-29&quot;&gt;QLoggingCategory :: operator&lt;/a&gt; ()} { &lt;a href=&quot;qmatrix4x4#operator-28-29&quot;&gt;operator&lt;/a&gt; () ()} 또는 &lt;a href=&quot;qmatrix4x4#data&quot;&gt;data&lt;/a&gt; ()를 사용 하여 행렬을 직접 수정 하면 &lt;a href=&quot;qmatrix4x4&quot;&gt;QMatrix4x4&lt;/a&gt; 는 특수 유형의 추적을 잃고 이후 가장 안전하지만 가장 효율적인 작업으로 되돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="387b4de2a63d04ca9d9a0be1778bb07453a9cd45" translate="yes" xml:space="preserve">
          <source>Normally the shadergen tool should be run from your application's project folder, but it's also possible to instruct the tool to change its current working directory through the &lt;code&gt;-C&lt;/code&gt; argument.</source>
          <target state="translated">일반적으로 shadergen 도구는 애플리케이션의 프로젝트 폴더에서 실행되어야하지만 &lt;code&gt;-C&lt;/code&gt; 인수를 통해 현재 작업 디렉토리를 변경하도록 도구에 지시 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8ffa165ac355ed07b8f1e0fce3e1114bfa22d013" translate="yes" xml:space="preserve">
          <source>Normally there is no need to reimplement this function. However, there are cases that involve decisions based on both the physical device and the surface. These cannot normally be performed before making the &lt;a href=&quot;qvulkanwindow&quot;&gt;QVulkanWindow&lt;/a&gt; visible since the Vulkan surface is not retrievable at that stage.</source>
          <target state="translated">일반적으로이 기능을 다시 구현할 필요가 없습니다. 그러나 물리적 장치와 표면을 기반으로 한 결정이 필요한 경우가 있습니다. Vulkan 표면은 해당 단계에서 검색 할 수 없으므로 &lt;a href=&quot;qvulkanwindow&quot;&gt;QVulkanWindow를&lt;/a&gt; 표시 하기 전에 정상적으로 수행 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="0c79804f064f59f741448d289a2e56a335d5f732" translate="yes" xml:space="preserve">
          <source>Normally this operation is relatively fast (amortized &lt;a href=&quot;containers#constant-time&quot;&gt;constant time&lt;/a&gt;). &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt; is able to allocate extra memory at the beginning of the list data and grow in that direction without reallocating or moving the data on each operation. However if you want a container class with a guarantee of &lt;a href=&quot;containers#constant-time&quot;&gt;constant time&lt;/a&gt; prepend, use std::list instead, but prefer &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt; otherwise.</source>
          <target state="translated">일반적으로이 작업은 비교적 빠릅니다 (상각 된 &lt;a href=&quot;containers#constant-time&quot;&gt;일정 시간&lt;/a&gt; ). &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt; 는 목록 데이터의 시작 부분에 추가 메모리를 할당하고 각 작업에서 데이터를 재 할당하거나 이동하지 않고도 해당 방향으로 확장 할 수 있습니다. 그러나 &lt;a href=&quot;containers#constant-time&quot;&gt;일정한 시간&lt;/a&gt; 앞에 추가 되는 컨테이너 클래스를 원하면 std :: list를 대신 사용하고 그렇지 않으면 &lt;a href=&quot;qlist&quot;&gt;QList를&lt;/a&gt; 선호하십시오 .</target>
        </trans-unit>
        <trans-unit id="9c1808ddf5404b6ca0f89898cd8edfdcf0fc3b3b" translate="yes" xml:space="preserve">
          <source>Normally you do not need to use this class directly; &lt;a href=&quot;qshortcut&quot;&gt;QShortcut&lt;/a&gt; provides a higher-level interface to handle shortcut keys.</source>
          <target state="translated">일반적으로이 클래스를 직접 사용할 필요는 없습니다. &lt;a href=&quot;qshortcut&quot;&gt;QShortcut&lt;/a&gt; 은 단축키를 처리 할 수있는 고급 인터페이스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="7ebee225449cfe8007efa4ad6338a69a687adc79" translate="yes" xml:space="preserve">
          <source>Normally you don't need to call this function; the garbage collector will automatically be invoked when the &lt;a href=&quot;qjsengine&quot;&gt;QJSEngine&lt;/a&gt; decides that it's wise to do so (i.e. when a certain number of new objects have been created). However, you can call this function to explicitly request that garbage collection should be performed as soon as possible.</source>
          <target state="translated">일반적으로이 함수를 호출 할 필요는 없습니다. 가비지 컬렉터는 &lt;a href=&quot;qjsengine&quot;&gt;QJSEngine&lt;/a&gt; 이 현명하다고 판단 할 때 (즉, 특정 개수의 새 객체가 생성 된 경우) 자동으로 호출됩니다 . 그러나 가비지 수집을 최대한 빨리 수행하도록 명시 적으로 요청하려면이 함수를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c7cd878c5cc7d56b89aff14d674e560d2727fcdc" translate="yes" xml:space="preserve">
          <source>Normally you will use the function &lt;a href=&quot;qdomdocument#implementation&quot;&gt;QDomDocument::implementation&lt;/a&gt;() to get the implementation object.</source>
          <target state="translated">일반적으로 &lt;a href=&quot;qdomdocument#implementation&quot;&gt;QDomDocument :: implementation&lt;/a&gt; () 함수를 사용 하여 구현 객체를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="8309b748bdcda84bea59615ad4a33203f01d2759" translate="yes" xml:space="preserve">
          <source>Normally, &lt;a href=&quot;qdebug&quot;&gt;QDebug&lt;/a&gt; prints the data inside quotes and transforms control or non-US-ASCII characters to their C escape sequences (\xAB). This way, the output is always 7-bit clean and the string can be copied from the output and pasted back into C++ sources, if necessary.</source>
          <target state="translated">일반적으로 &lt;a href=&quot;qdebug&quot;&gt;QDebug&lt;/a&gt; 는 따옴표 안에 데이터를 인쇄하고 제어 또는 비 US-ASCII 문자를 C 이스케이프 시퀀스 (\ xAB)로 변환합니다. 이런 식으로 출력은 항상 7 비트 깨끗하며 필요한 경우 출력에서 ​​문자열을 복사하여 C ++ 소스에 다시 붙여 넣을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="88a5f83876d08c1481684fac2aeda79015b2da66" translate="yes" xml:space="preserve">
          <source>Normally, &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; draws in a &quot;natural&quot; coordinate system, but it is able to perform view and world transformations using the &lt;a href=&quot;qtransform&quot;&gt;QTransform&lt;/a&gt; class. For more information, see &lt;a href=&quot;coordsys&quot;&gt;Coordinate System&lt;/a&gt;, which also describes the rendering process, i.e. the relation between the logical representation and the rendered pixels, and the benefits of anti-aliased painting.</source>
          <target state="translated">일반적으로 &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; 는 &quot;자연스러운&quot;좌표계로 그려 &lt;a href=&quot;qtransform&quot;&gt;지지만 QTransform&lt;/a&gt; 클래스를 사용하여보기 및 세계 변환을 수행 할 수 있습니다 . 자세한 내용 은 렌더링 프로세스, 즉 논리적 표현과 렌더링 된 픽셀 간의 관계 및 앤티 앨리어싱 페인팅의 이점을 설명하는 &lt;a href=&quot;coordsys&quot;&gt;좌표계를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="83d5a3f187b1a9ae41765b7f3fae90d0fed93df3" translate="yes" xml:space="preserve">
          <source>Normally, &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; draws in a &quot;natural&quot; coordinate system, but it is able to perform view and world transformations using the &lt;a href=&quot;qtransform&quot;&gt;QTransform&lt;/a&gt; class. For more information, see &lt;a href=&quot;coordsys#&quot;&gt;Coordinate System&lt;/a&gt;, which also describes the rendering process, i.e. the relation between the logical representation and the rendered pixels, and the benefits of anti-aliased painting.</source>
          <target state="translated">일반적으로 &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; 는 &quot;자연적인&quot;좌표계를 사용하지만 &lt;a href=&quot;qtransform&quot;&gt;QTransform&lt;/a&gt; 클래스를 사용하여 뷰 및 월드 변환을 수행 할 수 있습니다 . 자세한 내용 은 렌더링 시스템, 즉 논리적 표현과 렌더링 된 픽셀 간의 관계, 앤티 앨리어싱 페인팅의 이점을 설명하는 &lt;a href=&quot;coordsys#&quot;&gt;좌표계를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="72a8598bacd9e49f8469b6ce38e663bdcd51ead0" translate="yes" xml:space="preserve">
          <source>Normally, Qt resources are unloaded automatically when the application terminates, but if the resources are located in a plugin that is being unloaded, call Q_CLEANUP_RESOURCE() to force removal of your resources.</source>
          <target state="translated">일반적으로 Qt 자원은 애플리케이션이 종료 될 때 자동으로 언로드되지만 자원이 언로드중인 플러그인에있는 경우 Q_CLEANUP_RESOURCE ()를 호출하여 자원을 강제로 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="993202340faaac0bf8b291e436f74673882b7900" translate="yes" xml:space="preserve">
          <source>Normally, a &lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt; allows only one value per key. If you call &lt;a href=&quot;qhash#insert&quot;&gt;insert&lt;/a&gt;() with a key that already exists in the &lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt;, the previous value is erased. For example:</source>
          <target state="translated">일반적으로 &lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt; 는 키당 하나 의 값만 허용합니다. &lt;a href=&quot;qhash#qhash&quot;&gt;QHash에&lt;/a&gt; 이미 존재하는 키로 &lt;a href=&quot;qhash#insert&quot;&gt;insert&lt;/a&gt; () 를 호출 하면 이전 값이 지워집니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e5db20f8abb737ce9d7db9c831837e2657fc20d9" translate="yes" xml:space="preserve">
          <source>Normally, a &lt;a href=&quot;qmap&quot;&gt;QMap&lt;/a&gt; allows only one value per key. If you call &lt;a href=&quot;qmap#insert&quot;&gt;insert&lt;/a&gt;() with a key that already exists in the &lt;a href=&quot;qmap&quot;&gt;QMap&lt;/a&gt;, the previous value will be erased. For example:</source>
          <target state="translated">일반적으로 &lt;a href=&quot;qmap&quot;&gt;QMap&lt;/a&gt; 은 키당 하나의 값만 허용합니다. &lt;a href=&quot;qmap&quot;&gt;QMap에&lt;/a&gt; 이미 존재하는 키로 &lt;a href=&quot;qmap#insert&quot;&gt;insert&lt;/a&gt; () 를 호출 하면 이전 값이 지워집니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="94906b95042e9807e666d9d5ad7671aaad6261f8" translate="yes" xml:space="preserve">
          <source>Normally, a QHash allows only one value per key. If you call &lt;a href=&quot;qhash#insert&quot;&gt;insert&lt;/a&gt;() with a key that already exists in the QHash, the previous value is erased. For example:</source>
          <target state="translated">일반적으로 QHash는 키당 하나의 값만 허용합니다. QHash에 이미 존재하는 키로 &lt;a href=&quot;qhash#insert&quot;&gt;insert&lt;/a&gt; () 를 호출 하면 이전 값이 지워집니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="9097424d65e28ddd7b6242592eeb67bd57fcd602" translate="yes" xml:space="preserve">
          <source>Normally, a QMap allows only one value per key. If you call &lt;a href=&quot;qmap#insert&quot;&gt;insert&lt;/a&gt;() with a key that already exists in the QMap, the previous value will be erased. For example:</source>
          <target state="translated">일반적으로 QMap은 키당 하나의 값만 허용합니다. QMap에 이미 존재하는 키로 &lt;a href=&quot;qmap#insert&quot;&gt;insert&lt;/a&gt; () 를 호출 하면 이전 값이 지워집니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="ac72a838b465a9384a844aab3287267eeebaf04e" translate="yes" xml:space="preserve">
          <source>Normally, a compositor application will have a single &lt;a href=&quot;qml-qtwayland-compositor-waylandcompositor&quot;&gt;WaylandCompositor&lt;/a&gt; instance, which can have several outputs as children.</source>
          <target state="translated">일반적으로 컴포 지터 응용 프로그램에는 단일 &lt;a href=&quot;qml-qtwayland-compositor-waylandcompositor&quot;&gt;WaylandCompositor&lt;/a&gt; 인스턴스가 있으며 자식으로 여러 출력을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c94ad304ce1e28eea2e073eb0f1ea82653e81da8" translate="yes" xml:space="preserve">
          <source>Normally, a compositor application will have a single &lt;a href=&quot;qml-qtwayland-compositor-waylandcompositor&quot;&gt;WaylandCompositor&lt;/a&gt; instance, which can have several outputs as children. When a client requests the compositor to create a surface, the request is handled by the onSurfaceRequested handler.</source>
          <target state="translated">일반적으로 컴포 지터 응용 프로그램에는 단일 &lt;a href=&quot;qml-qtwayland-compositor-waylandcompositor&quot;&gt;WaylandCompositor&lt;/a&gt; 인스턴스가 있으며 자식으로 여러 출력을 가질 수 있습니다. 클라이언트가 합성기를 요청하여 표면을 만들면 요청은 onSurfaceRequested 핸들러에 의해 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="877647bf9f1526a424122025558b1ee59c4165fc" translate="yes" xml:space="preserve">
          <source>Normally, a compositor application will have a single WaylandCompositor instance, which can have several outputs as children. When a client requests the compositor to create a surface, the request is handled by the onSurfaceRequested handler.</source>
          <target state="translated">일반적으로 컴포 지터 응용 프로그램에는 여러 출력을 자식으로 가질 수있는 단일 WaylandCompositor 인스턴스가 있습니다. 클라이언트가 컴포 지터에게 표면 생성을 요청하면 요청은 onSurfaceRequested 핸들러에 의해 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="b3914ae04937560a2eed2d77757caacc4db97a6c" translate="yes" xml:space="preserve">
          <source>Normally, a connection to a non-existent signal produces runtime errors.</source>
          <target state="translated">일반적으로 존재하지 않는 신호에 연결하면 런타임 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8a2ef996feb67014719a0dcf08ebe9cfda84a318" translate="yes" xml:space="preserve">
          <source>Normally, a timer is started just before a lengthy operation, such as:</source>
          <target state="translated">일반적으로 타이머는 다음과 같이 긴 작업 직전에 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="d81e1b320dc77399066735d12f329e24cb87a895" translate="yes" xml:space="preserve">
          <source>Normally, a vertical wheel will produce a &lt;a href=&quot;qml-qtquick-pointerscrollevent&quot;&gt;PointerScrollEvent&lt;/a&gt; with positive delta values if the top of the wheel is rotating away from the hand operating it. Similarly, a horizontal wheel movement will produce a &lt;a href=&quot;qml-qtquick-pointerscrollevent&quot;&gt;PointerScrollEvent&lt;/a&gt; with positive delta values if the top of the wheel is moved to the left.</source>
          <target state="translated">일반적으로 수직 휠은 휠 의 상단이 손에서 멀어지는 방향으로 회전하는 경우 양의 델타 값이 있는 &lt;a href=&quot;qml-qtquick-pointerscrollevent&quot;&gt;PointerScrollEvent&lt;/a&gt; 를 생성 합니다. 유사하게, 수평 휠 이동은 휠 의 상단이 왼쪽으로 이동하면 양의 델타 값을 가진 &lt;a href=&quot;qml-qtquick-pointerscrollevent&quot;&gt;PointerScrollEvent&lt;/a&gt; 를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="9a05f471957547d52ff859981b30edaa112685bb" translate="yes" xml:space="preserve">
          <source>Normally, a vertical wheel will produce a &lt;a href=&quot;qml-qtquick-wheelevent&quot;&gt;WheelEvent&lt;/a&gt; with positive delta values if the top of the wheel is rotating away from the hand operating it. Similarly, a horizontal wheel movement will produce a &lt;a href=&quot;qwheelevent&quot;&gt;QWheelEvent&lt;/a&gt; with positive delta values if the top of the wheel is moved to the left.</source>
          <target state="translated">일반적으로, 수직 휠은 휠 상단이 조작하는 손에서 멀어 질 경우 양수 델타 값 으로 &lt;a href=&quot;qml-qtquick-wheelevent&quot;&gt;WheelEvent&lt;/a&gt; 를 생성 합니다. 마찬가지로, 휠 의 상단이 왼쪽으로 이동하면 수평 휠 이동은 양의 델타 값을 갖는 &lt;a href=&quot;qwheelevent&quot;&gt;QWheelEvent&lt;/a&gt; 를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="7d40c273f0994972e11ffa208b103827d5d96da1" translate="yes" xml:space="preserve">
          <source>Normally, a vertical wheel will produce a &lt;a href=&quot;qwheelevent&quot;&gt;QWheelEvent&lt;/a&gt; with positive delta values if the top of the wheel is rotating away from the hand operating it. Similarly, a horizontal wheel movement will produce a &lt;a href=&quot;qwheelevent&quot;&gt;QWheelEvent&lt;/a&gt; with positive delta values if the top of the wheel is moved to the left.</source>
          <target state="translated">일반적으로, 수직 휠은 휠 상단이 조작하는 손에서 멀어 질 경우 양의 델타 값 으로 &lt;a href=&quot;qwheelevent&quot;&gt;QWheelEvent&lt;/a&gt; 를 생성 합니다. 마찬가지로, 휠 의 상단이 왼쪽으로 이동하면 수평 휠 이동은 양의 델타 값을 갖는 &lt;a href=&quot;qwheelevent&quot;&gt;QWheelEvent&lt;/a&gt; 를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="e9c1d94beea7d8a485b492de266055f95109686a" translate="yes" xml:space="preserve">
          <source>Normally, an empty line edit shows the placeholder text even when it has focus. However, if the content is horizontally centered, the placeholder text is not displayed under the cursor when the line edit has focus.</source>
          <target state="translated">일반적으로 빈 줄 편집은 자리 표시 자 텍스트에 포커스가있는 경우에도 표시됩니다. 그러나 내용이 가로 가운데에 있으면 행 편집에 포커스가있을 때 자리 표시 자 텍스트가 커서 아래에 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1c6a63ac34eb0549bc1aabdf82ca27369b2a0640" translate="yes" xml:space="preserve">
          <source>Normally, each managed widget or layout is put into a cell of its own using &lt;a href=&quot;qgridlayout#addWidget-1&quot;&gt;addWidget&lt;/a&gt;(). It is also possible for a widget to occupy multiple cells using the row and column spanning overloads of &lt;a href=&quot;qgridlayout#addItem&quot;&gt;addItem&lt;/a&gt;() and &lt;a href=&quot;qgridlayout#addWidget-1&quot;&gt;addWidget&lt;/a&gt;(). If you do this, &lt;a href=&quot;qgridlayout&quot;&gt;QGridLayout&lt;/a&gt; will guess how to distribute the size over the columns/rows (based on the stretch factors).</source>
          <target state="translated">일반적으로 각 관리되는 위젯 또는 레이아웃은 &lt;a href=&quot;qgridlayout#addWidget-1&quot;&gt;addWidget&lt;/a&gt; ()을 사용하여 자체 셀에 배치됩니다 . 위젯이 &lt;a href=&quot;qgridlayout#addItem&quot;&gt;addItem&lt;/a&gt; () 및 &lt;a href=&quot;qgridlayout#addWidget-1&quot;&gt;addWidget&lt;/a&gt; ()의 오버로드 및 행에 걸쳐 여러 셀을 차지할 수도 있습니다 . 이 작업을 수행하면 &lt;a href=&quot;qgridlayout&quot;&gt;QGridLayout&lt;/a&gt; 은 열 / 행에 크기를 분산시키는 방법을 추측합니다 (신축 계수를 기준으로).</target>
        </trans-unit>
        <trans-unit id="dbb174103b6c60c2c6aba1672578a76cf10eecd2" translate="yes" xml:space="preserve">
          <source>Normally, each managed widget or layout is put into a cell of its own using &lt;a href=&quot;qgridlayout#addWidget-1&quot;&gt;addWidget&lt;/a&gt;(). It is also possible for a widget to occupy multiple cells using the row and column spanning overloads of &lt;a href=&quot;qgridlayout#addItem&quot;&gt;addItem&lt;/a&gt;() and &lt;a href=&quot;qgridlayout#addWidget-1&quot;&gt;addWidget&lt;/a&gt;(). If you do this, QGridLayout will guess how to distribute the size over the columns/rows (based on the stretch factors).</source>
          <target state="translated">일반적으로 관리되는 각 위젯 또는 레이아웃은 &lt;a href=&quot;qgridlayout#addWidget-1&quot;&gt;addWidget&lt;/a&gt; ()을 사용하여 자체 셀에 배치됩니다 . &lt;a href=&quot;qgridlayout#addItem&quot;&gt;addItem&lt;/a&gt; () 및 &lt;a href=&quot;qgridlayout#addWidget-1&quot;&gt;addWidget&lt;/a&gt; ()의 오버로드에 걸친 행 및 열을 사용하여 위젯이 여러 셀을 차지할 수도 있습니다 . 이렇게하면 QGridLayout이 열 / 행에 크기를 분산하는 방법을 추측합니다 (스트레치 계수에 따라).</target>
        </trans-unit>
        <trans-unit id="99a0a3028bea9ca51e4922a9fb0a244e117179b7" translate="yes" xml:space="preserve">
          <source>Normally, it isn't necessary to call this function, because Qt sets the &lt;a href=&quot;qapplication&quot;&gt;QApplication&lt;/a&gt; object as the root object immediately before the event loop is entered in &lt;a href=&quot;qapplication#exec&quot;&gt;QApplication::exec&lt;/a&gt;().</source>
          <target state="translated">Qt는 &lt;a href=&quot;qapplication#exec&quot;&gt;QApplication :: exec&lt;/a&gt; () 에 이벤트 루프가 입력되기 직전에 &lt;a href=&quot;qapplication&quot;&gt;QApplication&lt;/a&gt; 객체를 루트 객체로 설정하기 때문에이 함수를 호출 할 필요는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="47bd08b136edd8a3a2443a550949234b45ce1b72" translate="yes" xml:space="preserve">
          <source>Normally, several datagrams are to be received and sent by both peers during the handshake phase. Upon reading datagrams, server and client must pass these datagrams to &lt;a href=&quot;qdtls#doHandshake&quot;&gt;doHandshake&lt;/a&gt;() until some error is found or &lt;a href=&quot;qdtls#handshakeState&quot;&gt;handshakeState&lt;/a&gt;() returns &lt;a href=&quot;qdtls#HandshakeState-enum&quot;&gt;HandshakeComplete&lt;/a&gt;:</source>
          <target state="translated">일반적으로 핸드 셰이크 단계 동안 두 피어가 여러 데이터 그램을 수신 및 전송합니다. 데이터 그램을 읽을 때 서버와 클라이언트는 오류가 발견되거나 &lt;a href=&quot;qdtls#handshakeState&quot;&gt;handshakeState&lt;/a&gt; ()가 &lt;a href=&quot;qdtls#HandshakeState-enum&quot;&gt;HandshakeComplete을&lt;/a&gt; 반환 할 때까지 이러한 데이터 그램을 &lt;a href=&quot;qdtls#doHandshake&quot;&gt;doHandshake&lt;/a&gt; ()에 전달해야합니다 .</target>
        </trans-unit>
        <trans-unit id="dd33f0d5c50e3a9cd7d25901809cc9962d9a7c2a" translate="yes" xml:space="preserve">
          <source>Normally, the &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; operates on the device's own coordinate system (usually pixels), but &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; has good support for coordinate transformations.</source>
          <target state="translated">일반적으로 &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; 는 장치의 자체 좌표계 (일반적으로 픽셀)에서 작동하지만 &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; 는 좌표 변환을 잘 지원합니다.</target>
        </trans-unit>
        <trans-unit id="86eef4b2fe95817bed11b581acba3859378fd997" translate="yes" xml:space="preserve">
          <source>Normally, the &lt;b&gt;Next&lt;/b&gt; button and the &lt;b&gt;Finish&lt;/b&gt; button of a wizard are mutually exclusive. If &lt;a href=&quot;qwizardpage#isFinalPage&quot;&gt;isFinalPage&lt;/a&gt;() returns &lt;code&gt;true&lt;/code&gt;, &lt;b&gt;Finish&lt;/b&gt; is available; otherwise, &lt;b&gt;Next&lt;/b&gt; is available. By default, &lt;a href=&quot;qwizardpage#isFinalPage&quot;&gt;isFinalPage&lt;/a&gt;() is true only when &lt;a href=&quot;qwizardpage#nextId&quot;&gt;nextId&lt;/a&gt;() returns -1. If you want to show &lt;b&gt;Next&lt;/b&gt; and &lt;b&gt;Final&lt;/b&gt; simultaneously for a page (letting the user perform an &quot;early finish&quot;), call &lt;a href=&quot;qwizardpage#setFinalPage&quot;&gt;setFinalPage&lt;/a&gt;(true) on that page. For wizards that support early finishes, you might also want to set the &lt;a href=&quot;qwizard#WizardOption-enum&quot;&gt;HaveNextButtonOnLastPage&lt;/a&gt; and &lt;a href=&quot;qwizard#WizardOption-enum&quot;&gt;HaveFinishButtonOnEarlyPages&lt;/a&gt; options on the wizard.</source>
          <target state="translated">일반적으로 마법사 의 &lt;b&gt;다음&lt;/b&gt; 버튼과 &lt;b&gt;마침&lt;/b&gt; 버튼은 상호 배타적입니다. 경우 &lt;a href=&quot;qwizardpage#isFinalPage&quot;&gt;isFinalPage은&lt;/a&gt; () 반환 &lt;code&gt;true&lt;/code&gt; , &lt;b&gt;마침&lt;/b&gt; 유효하다; 그렇지 않으면 &lt;b&gt;다음&lt;/b&gt; 을 사용할 수 있습니다. &lt;a href=&quot;qwizardpage#isFinalPage&quot;&gt;isIdinalPage&lt;/a&gt; ()는 &lt;a href=&quot;qwizardpage#nextId&quot;&gt;nextId&lt;/a&gt; ()가 -1을 반환 할 때만 기본적으로 true 입니다. 페이지에 대해 &lt;b&gt;다음&lt;/b&gt; 및 &lt;b&gt;최종을&lt;/b&gt; 동시에 표시 하려면 (사용자가 &quot;조기 완료&quot;를 수행하도록 함 ) 해당 페이지에서 &lt;a href=&quot;qwizardpage#setFinalPage&quot;&gt;setFinalPage&lt;/a&gt; (true)를 호출 하십시오. 조기 완료를 지원하는 마법사의 경우 &lt;a href=&quot;qwizard#WizardOption-enum&quot;&gt;HaveNextButtonOnLastPage&lt;/a&gt; 및 &lt;a href=&quot;qwizard#WizardOption-enum&quot;&gt;HaveFinishButtonOnEarlyPages&lt;/a&gt; 를 설정할 수도 있습니다. 마법사의 옵션.</target>
        </trans-unit>
        <trans-unit id="4f09695932810bb2fbe171a69bb8b3be1171cc50" translate="yes" xml:space="preserve">
          <source>Normally, the QPainter operates on the device's own coordinate system (usually pixels), but QPainter has good support for coordinate transformations.</source>
          <target state="translated">일반적으로 QPainter는 장치의 자체 좌표계 (일반적으로 픽셀)에서 작동하지만 QPainter는 좌표 변환을 잘 지원합니다.</target>
        </trans-unit>
        <trans-unit id="461f0ca5d70294382d65b1c0886d89e7af06c00e" translate="yes" xml:space="preserve">
          <source>Normally, the begin and end functions are capable of informing other components about changes to the model's underlying structure. For more complex changes to the model's structure, perhaps involving internal reorganization, sorting of data or any other structural change, it is necessary to perform the following sequence:</source>
          <target state="translated">일반적으로 begin 및 end 함수는 모델의 기본 구조에 대한 변경 사항을 다른 구성 요소에 알릴 수 있습니다. 내부 구조 조정, 데이터 정렬 또는 기타 구조적 변경을 포함하여 모델 구조를보다 복잡하게 변경하려면 다음 순서를 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="9a4bb5277245967a8842220e1408d91121bc17c1" translate="yes" xml:space="preserve">
          <source>Normally, the default message handler is sufficient. It writes compile and runtime messages to</source>
          <target state="translated">일반적으로 기본 메시지 핸들러로 충분합니다. 컴파일 및 런타임 메시지를</target>
        </trans-unit>
        <trans-unit id="c68852faed3a42b9182317237cc52b40cccd71e6" translate="yes" xml:space="preserve">
          <source>Normally, the default message handler is sufficient. It writes compile and validation messages to</source>
          <target state="translated">일반적으로 기본 메시지 핸들러로 충분합니다. 컴파일 및 유효성 검사 메시지를</target>
        </trans-unit>
        <trans-unit id="e07ea0a8dc744af847b9f3bfe71c9d1b592ad770" translate="yes" xml:space="preserve">
          <source>Normally, the following QML would result in a binding being established for the &lt;code&gt;script&lt;/code&gt; property; i.e. &lt;code&gt;script&lt;/code&gt; would be assigned the value obtained from running &lt;code&gt;myObj.value = Math.max(myValue, 100)&lt;/code&gt;</source>
          <target state="translated">일반적으로 다음 QML은 &lt;code&gt;script&lt;/code&gt; 특성 에 대한 바인딩을 설정 합니다. 즉, &lt;code&gt;script&lt;/code&gt; &lt;code&gt;myObj.value = Math.max(myValue, 100)&lt;/code&gt; 을 실행하여 얻은 값이 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="cb8705827a59b554cf2b2ebe0ba3ecae6e62cf06" translate="yes" xml:space="preserve">
          <source>Normally, the message is displayed immediately. However, if there are pending messages, it will be queued to be displayed later.</source>
          <target state="translated">일반적으로 메시지가 즉시 표시됩니다. 그러나 보류중인 메시지가 있으면 나중에 표시되도록 대기합니다.</target>
        </trans-unit>
        <trans-unit id="49f6fde1e345bd0df14097aa7109c2c857b173cc" translate="yes" xml:space="preserve">
          <source>Normally, the primary index is set automatically whenever you call &lt;a href=&quot;qsqltablemodel#setTable&quot;&gt;setTable&lt;/a&gt;().</source>
          <target state="translated">일반적으로 기본 인덱스는 &lt;a href=&quot;qsqltablemodel#setTable&quot;&gt;setTable&lt;/a&gt; () 을 호출 할 때마다 자동으로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="d59fe79943afb83a737f90f057eac5798cd4451e" translate="yes" xml:space="preserve">
          <source>Normally, the types exported by a module should be fixed. However, if a C++ type is not available, you should at least &quot;reserve&quot; the QML type name, and give the user of the unavailable type a meaningful error message.</source>
          <target state="translated">일반적으로 모듈에서 내 보낸 유형은 수정되어야합니다. 그러나 C ++ 유형을 사용할 수없는 경우 적어도 QML 유형 이름을 &quot;예약&quot;하고 사용할 수없는 유형의 사용자에게 의미있는 오류 메시지를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="9c998342d3bdb99fb398288ecc9113ba6b87a963" translate="yes" xml:space="preserve">
          <source>Normally, the types exported by a plugin should be fixed. However, if a C++ type is not available, you should at least &quot;reserve&quot; the QML type name, and give the user of the unavailable type a meaningful error message.</source>
          <target state="translated">일반적으로 플러그인에서 내 보낸 유형은 고정되어 있어야합니다. 그러나 C ++ 유형을 사용할 수없는 경우 최소한 QML 유형 이름을 &quot;예약&quot;하고 사용할 수없는 유형의 사용자에게 의미있는 오류 메시지를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="d71449d42cc72a47c0f371425ccca3c152d73efe" translate="yes" xml:space="preserve">
          <source>Normally, when a QML type is marked with</source>
          <target state="translated">일반적으로 QML 유형이</target>
        </trans-unit>
        <trans-unit id="1a836777bd8dd2bece616b86f836bfa00f0b0ec6" translate="yes" xml:space="preserve">
          <source>Normally, you connect each menu action to a single slot using &lt;a href=&quot;qaction#triggered&quot;&gt;QAction::triggered&lt;/a&gt;(), but sometimes you will want to connect several items to a single slot (most often if the user selects from an array). This signal is useful in such cases.</source>
          <target state="translated">일반적으로 &lt;a href=&quot;qaction#triggered&quot;&gt;QAction :: triggered&lt;/a&gt; ()를 사용하여 각 메뉴 작업을 단일 슬롯 에 연결하지만 때로는 여러 항목을 단일 슬롯에 연결하려고 할 수도 있습니다 (대부분 사용자가 배열에서 선택하는 경우). 이 신호는 그러한 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="abf747f6c10ce22773a2baecc7633c9241c9cb2c" translate="yes" xml:space="preserve">
          <source>Normally, you connect each menu action's &lt;a href=&quot;qaction#triggered&quot;&gt;triggered()&lt;/a&gt; signal to its own custom slot, but sometimes you will want to connect several actions to a single slot, for example, when you have a group of closely related actions, such as &quot;left justify&quot;, &quot;center&quot;, &quot;right justify&quot;.</source>
          <target state="translated">일반적으로 각 메뉴 작업의 &lt;a href=&quot;qaction#triggered&quot;&gt;triggered ()&lt;/a&gt; 신호를 자체 사용자 정의 슬롯에 연결하지만 &quot;왼쪽 정렬&quot;과 같이 밀접하게 관련된 작업 그룹이있는 경우와 같이 여러 작업을 단일 슬롯에 연결하려고 할 때가 있습니다. , &quot;중심&quot;, &quot;맞춤&quot;.</target>
        </trans-unit>
        <trans-unit id="4dc941c573fd53b44633539356bbe665fe347e14" translate="yes" xml:space="preserve">
          <source>Normally, you do not have to call this function.</source>
          <target state="translated">일반적으로이 함수를 호출 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="abaedf997f5c37ff234647646a76d4c100fff101" translate="yes" xml:space="preserve">
          <source>Normally, you do not need to create a &lt;a href=&quot;qtextinlineobject&quot;&gt;QTextInlineObject&lt;/a&gt;. It is used by &lt;a href=&quot;qabstracttextdocumentlayout&quot;&gt;QAbstractTextDocumentLayout&lt;/a&gt; to handle inline objects when implementing a custom layout.</source>
          <target state="translated">일반적으로 &lt;a href=&quot;qtextinlineobject&quot;&gt;QTextInlineObject&lt;/a&gt; 를 만들 필요가 없습니다 . &lt;a href=&quot;qabstracttextdocumentlayout&quot;&gt;QAbstractTextDocumentLayout&lt;/a&gt; 에서 사용자 정의 레이아웃을 구현할 때 인라인 객체를 처리 하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="bacd5754aafdea51bd133a7edee734aa508806eb" translate="yes" xml:space="preserve">
          <source>Normally, you do not need to create a QTextInlineObject. It is used by &lt;a href=&quot;qabstracttextdocumentlayout&quot;&gt;QAbstractTextDocumentLayout&lt;/a&gt; to handle inline objects when implementing a custom layout.</source>
          <target state="translated">일반적으로 QTextInlineObject를 만들 필요가 없습니다. &lt;a href=&quot;qabstracttextdocumentlayout&quot;&gt;QAbstractTextDocumentLayout&lt;/a&gt; 에서 사용자 지정 레이아웃을 구현할 때 인라인 개체를 처리 하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="44ca5d64975012afcf60db27fef71b2c13834941" translate="yes" xml:space="preserve">
          <source>Normally, you don't need to use these, since &lt;a href=&quot;qframe#frameShadow-prop&quot;&gt;frameShadow&lt;/a&gt;() and &lt;a href=&quot;qframe#frameShape-prop&quot;&gt;frameShape&lt;/a&gt;() already extract the &lt;a href=&quot;qframe#Shadow-enum&quot;&gt;Shadow&lt;/a&gt; and the &lt;a href=&quot;qframe#Shape-enum&quot;&gt;Shape&lt;/a&gt; parts of &lt;a href=&quot;qframe#frameStyle&quot;&gt;frameStyle&lt;/a&gt;().</source>
          <target state="translated">때문에 일반적으로, 당신은이를 사용할 필요가 없습니다 &lt;a href=&quot;qframe#frameShadow-prop&quot;&gt;frameShadow&lt;/a&gt; ()와 &lt;a href=&quot;qframe#frameShape-prop&quot;&gt;frameShape&lt;/a&gt; 이미 추출) ( &lt;a href=&quot;qframe#Shadow-enum&quot;&gt;그림자&lt;/a&gt; 와 &lt;a href=&quot;qframe#Shape-enum&quot;&gt;모양&lt;/a&gt; 의 부품 &lt;a href=&quot;qframe#frameStyle&quot;&gt;frameStyle을&lt;/a&gt; ().</target>
        </trans-unit>
        <trans-unit id="af24f129bb9e10af1b50349d21adf6015fae6cf8" translate="yes" xml:space="preserve">
          <source>Normally, you don't need to use this class directly. Qt's built-in layout managers provide the following functions for manipulating empty space in layouts:</source>
          <target state="translated">일반적으로이 클래스를 직접 사용할 필요는 없습니다. Qt의 내장 레이아웃 관리자는 레이아웃에서 빈 공간을 조작하기 위해 다음 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="7aae31543813b1d6a1de216548a4f86ad6d6c71b" translate="yes" xml:space="preserve">
          <source>Normally, you don't need to use this class directly. Qt's built-in layout managers provide the following functions for manipulating widgets in layouts:</source>
          <target state="translated">일반적으로이 클래스를 직접 사용할 필요는 없습니다. Qt의 내장 레이아웃 관리자는 레이아웃에서 위젯을 조작하기 위해 다음 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="3e2eca35f2d92998315829760f01bc6f5bc877df" translate="yes" xml:space="preserve">
          <source>Normally, you should not need to call this function directly. Instead, use &lt;a href=&quot;qmetatype#Type-enum&quot;&gt;QVariant&lt;/a&gt;'s &lt;code&gt;operator&amp;gt;&amp;gt;()&lt;/code&gt;, which relies on load() to stream custom types.</source>
          <target state="translated">일반적으로이 함수를 직접 호출 할 필요는 없습니다. 대신, &lt;a href=&quot;qmetatype#Type-enum&quot;&gt;QVariant&lt;/a&gt; 의 &lt;code&gt;operator&amp;gt;&amp;gt;()&lt;/code&gt; 사용자 정의 유형을 스트리밍하는 부하 ()에 의존한다.</target>
        </trans-unit>
        <trans-unit id="f76237e560731eff73fb94dcf12a24b9bdb84536" translate="yes" xml:space="preserve">
          <source>Normally, you should not need to call this function directly. Instead, use &lt;a href=&quot;qmetatype#Type-enum&quot;&gt;QVariant&lt;/a&gt;'s &lt;code&gt;operator&amp;lt;&amp;lt;()&lt;/code&gt;, which relies on save() to stream custom types.</source>
          <target state="translated">일반적으로이 함수를 직접 호출 할 필요는 없습니다. 대신, save ()를 사용하여 사용자 정의 유형을 스트리밍 하는 &lt;a href=&quot;qmetatype#Type-enum&quot;&gt;QVariant&lt;/a&gt; 의 &lt;code&gt;operator&amp;lt;&amp;lt;()&lt;/code&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="785dcadc3bca91b1cc5da91b5c98ae50509c15ca" translate="yes" xml:space="preserve">
          <source>Normally, you should not need to call this function directly. Instead, use &lt;a href=&quot;qtcore-changes-qt6#qvariant&quot;&gt;QVariant&lt;/a&gt;'s &lt;code&gt;operator&amp;gt;&amp;gt;()&lt;/code&gt;, which relies on load() to stream custom types.</source>
          <target state="translated">일반적으로이 함수를 직접 호출 할 필요는 없습니다. 대신, 사용자 정의 유형을 스트리밍하기 위해 load ()에 의존 하는 &lt;a href=&quot;qtcore-changes-qt6#qvariant&quot;&gt;QVariant&lt;/a&gt; 의 &lt;code&gt;operator&amp;gt;&amp;gt;()&lt;/code&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="4299a4b78f7260631f75a240e2575a713144571d" translate="yes" xml:space="preserve">
          <source>Normally, you should not need to call this function directly. Instead, use &lt;a href=&quot;qtcore-changes-qt6#qvariant&quot;&gt;QVariant&lt;/a&gt;'s &lt;code&gt;operator&amp;lt;&amp;lt;()&lt;/code&gt;, which relies on save() to stream custom types.</source>
          <target state="translated">일반적으로이 함수를 직접 호출 할 필요는 없습니다. 대신 save ()에 의존하여 사용자 정의 유형을 스트리밍 하는 &lt;a href=&quot;qtcore-changes-qt6#qvariant&quot;&gt;QVariant&lt;/a&gt; 의 &lt;code&gt;operator&amp;lt;&amp;lt;()&lt;/code&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b13731fadfd8d146fcc17b293da3c0d0a8c5c1e6" translate="yes" xml:space="preserve">
          <source>Normally, you should place calls using &lt;a href=&quot;qdbusabstractinterface#asyncCall&quot;&gt;asyncCall&lt;/a&gt;().</source>
          <target state="translated">일반적으로 &lt;a href=&quot;qdbusabstractinterface#asyncCall&quot;&gt;asyncCall&lt;/a&gt; ()을 사용하여 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="2fe406bc26f66bf6750e723a4c5b805ce74a083a" translate="yes" xml:space="preserve">
          <source>Normally, you should place calls using &lt;a href=&quot;qdbusabstractinterface#asyncCall-1&quot;&gt;asyncCall&lt;/a&gt;().</source>
          <target state="translated">일반적으로 &lt;a href=&quot;qdbusabstractinterface#asyncCall-1&quot;&gt;asyncCall&lt;/a&gt; ()을 사용하여 전화를 걸어야 합니다.</target>
        </trans-unit>
        <trans-unit id="22674d9378c4e52d6270ba30beaefeaebb573d97" translate="yes" xml:space="preserve">
          <source>Normally, you should place calls using &lt;a href=&quot;qdbusabstractinterface#call&quot;&gt;call&lt;/a&gt;().</source>
          <target state="translated">일반적으로 &lt;a href=&quot;qdbusabstractinterface#call&quot;&gt;call&lt;/a&gt; ()을 사용하여 전화를 걸어야합니다 .</target>
        </trans-unit>
        <trans-unit id="14d15a0bd38f467d63e963478b3c133ed9139046" translate="yes" xml:space="preserve">
          <source>Normally, you should place calls using &lt;a href=&quot;qdbusabstractinterface#call-1&quot;&gt;call&lt;/a&gt;().</source>
          <target state="translated">일반적으로 &lt;a href=&quot;qdbusabstractinterface#call-1&quot;&gt;call&lt;/a&gt; ()을 사용하여 전화를 걸어야합니다 .</target>
        </trans-unit>
        <trans-unit id="04d5dd001ea10805b9fb027667cc7127ffe6a2f8" translate="yes" xml:space="preserve">
          <source>Normally, you should pop the context at the end of each XML element. After popping the context, all namespace prefix mappings that were previously in force are restored.</source>
          <target state="translated">일반적으로 각 XML 요소의 끝에 컨텍스트를 표시해야합니다. 컨텍스트를 팝업 한 후에는 이전에 적용되었던 모든 네임 스페이스 접두사 매핑이 복원됩니다.</target>
        </trans-unit>
        <trans-unit id="6498540a59385527ffd2d47264cce3a09d751fc0" translate="yes" xml:space="preserve">
          <source>Normally, you should push a new context at the beginning of each XML element: the new context automatically inherits the declarations of its parent context, and it also keeps track of which declarations were made within this context.</source>
          <target state="translated">일반적으로 각 XML 요소의 시작 부분에 새 컨텍스트를 푸시해야합니다. 새 컨텍스트는 자동으로 상위 컨텍스트의 선언을 상속하며이 컨텍스트 내에서 어떤 선언이 이루어 졌는지 추적합니다.</target>
        </trans-unit>
        <trans-unit id="e8015199831ae98627ce192997b32d694753d088" translate="yes" xml:space="preserve">
          <source>Normally, you would use &lt;a href=&quot;qsqlquery&quot;&gt;QSqlQuery&lt;/a&gt; instead of &lt;a href=&quot;qsqlresult&quot;&gt;QSqlResult&lt;/a&gt;, since &lt;a href=&quot;qsqlquery&quot;&gt;QSqlQuery&lt;/a&gt; provides a generic wrapper for database-specific implementations of &lt;a href=&quot;qsqlresult&quot;&gt;QSqlResult&lt;/a&gt;.</source>
          <target state="translated">일반적으로, 사용하는 것이 &lt;a href=&quot;qsqlquery&quot;&gt;QSqlQuery&lt;/a&gt; 대신 &lt;a href=&quot;qsqlresult&quot;&gt;QSqlResult을&lt;/a&gt; 하기 때문에, &lt;a href=&quot;qsqlquery&quot;&gt;QSqlQuery가&lt;/a&gt; 의 데이터베이스 특정 구현에 대한 일반적인 래퍼를 제공 &lt;a href=&quot;qsqlresult&quot;&gt;QSqlResult&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a1699667e8407a5dcd45f03357755007bff38f44" translate="yes" xml:space="preserve">
          <source>Normally, you would use &lt;a href=&quot;qsqlquery&quot;&gt;QSqlQuery&lt;/a&gt; instead of QSqlResult, since &lt;a href=&quot;qsqlquery&quot;&gt;QSqlQuery&lt;/a&gt; provides a generic wrapper for database-specific implementations of QSqlResult.</source>
          <target state="translated">일반적으로 &lt;a href=&quot;qsqlquery&quot;&gt;QSqlQuery&lt;/a&gt; 는 QSqlResult의 데이터베이스 별 구현을위한 일반 래퍼를 제공 하므로 &lt;a href=&quot;qsqlquery&quot;&gt;QSqlResult&lt;/a&gt; 대신 QSqlQuery 를 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="49d907d8718f7a5de293f9d58894a673528f68a1" translate="yes" xml:space="preserve">
          <source>Normally, you would use &lt;a href=&quot;qtsql-changes-qt6#qsqlquery&quot;&gt;QSqlQuery&lt;/a&gt; instead of QSqlResult, since &lt;a href=&quot;qtsql-changes-qt6#qsqlquery&quot;&gt;QSqlQuery&lt;/a&gt; provides a generic wrapper for database-specific implementations of QSqlResult.</source>
          <target state="translated">일반적으로 &lt;a href=&quot;qtsql-changes-qt6#qsqlquery&quot;&gt;QSqlQuery&lt;/a&gt; 는 QSqlResult의 데이터베이스 특정 구현에 대한 일반 래퍼를 제공 하므로 &lt;a href=&quot;qtsql-changes-qt6#qsqlquery&quot;&gt;QSqlResult&lt;/a&gt; 대신 QSqlQuery 를 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="92d4f6dd0aa5e5a2038062afb7985262893acdb2" translate="yes" xml:space="preserve">
          <source>Normap map</source>
          <target state="translated">Normap지도</target>
        </trans-unit>
        <trans-unit id="79b723002f87708ebc11fd4f3b902a03f7c9a5c1" translate="yes" xml:space="preserve">
          <source>Norwegian</source>
          <target state="translated">Norwegian</target>
        </trans-unit>
        <trans-unit id="1de91415f70a00ed251cdd8383e078c13aa33c9b" translate="yes" xml:space="preserve">
          <source>Norwegian Layout</source>
          <target state="translated">노르웨이어 레이아웃</target>
        </trans-unit>
        <trans-unit id="23c9fe64cf8470df8244ce51b4904e00c7bf3b10" translate="yes" xml:space="preserve">
          <source>Norwegian, Nordic Bokmal</source>
          <target state="translated">노르웨이어, 노르딕 보크 말</target>
        </trans-unit>
        <trans-unit id="ef39cd57a569bb886190b06c9f33260005515160" translate="yes" xml:space="preserve">
          <source>Nostalgia</source>
          <target state="translated">Nostalgia</target>
        </trans-unit>
        <trans-unit id="d71eab6323b7c31e94cdd0d65a77dff04da7974b" translate="yes" xml:space="preserve">
          <source>Not Set</source>
          <target state="translated">미 설정</target>
        </trans-unit>
        <trans-unit id="b3034ec567c2321a383d655a57d2cb638f893719" translate="yes" xml:space="preserve">
          <source>Not Supported</source>
          <target state="translated">미지원</target>
        </trans-unit>
        <trans-unit id="6eccab182c97013c56d863cb44575fe3b4454c03" translate="yes" xml:space="preserve">
          <source>Not a media.</source>
          <target state="translated">미디어가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="946155f4955cb1c5bc87bdb5c6e5e28781930d68" translate="yes" xml:space="preserve">
          <source>Not a valid type, either due to parsing error or due to reaching the end of an array or map.</source>
          <target state="translated">구문 분석 오류 또는 배열 또는 맵의 끝에 도달하여 유효한 유형이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="5b14b5e2d599326c6356b9a5edd05dee9b4ac8c3" translate="yes" xml:space="preserve">
          <source>Not a valid value, this usually indicates a CBOR decoding error</source>
          <target state="translated">유효한 값이 아닙니다. 일반적으로 CBOR 디코딩 오류를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a1848e7c9e19ecda4f34cdfdfa1b530181e591a9" translate="yes" xml:space="preserve">
          <source>Not adjacent to the selected section</source>
          <target state="translated">선택한 섹션에 인접하지 않음</target>
        </trans-unit>
        <trans-unit id="b3d52dca42b7cd3ee33ee68b4b8618fda85a40d7" translate="yes" xml:space="preserve">
          <source>Not all &lt;a href=&quot;qt#ItemDataRole-enum&quot;&gt;ItemDataRole&lt;/a&gt;s will have an effect on a &lt;a href=&quot;qheaderview&quot;&gt;QHeaderView&lt;/a&gt;. If you need to draw other roles, you can subclass &lt;a href=&quot;qheaderview&quot;&gt;QHeaderView&lt;/a&gt; and reimplement &lt;a href=&quot;qheaderview#paintEvent&quot;&gt;paintEvent()&lt;/a&gt;. &lt;a href=&quot;qheaderview&quot;&gt;QHeaderView&lt;/a&gt; respects the following item data roles, unless they are in conflict with the style (which can happen for styles that follow the desktop theme):</source>
          <target state="translated">모든 &lt;a href=&quot;qt#ItemDataRole-enum&quot;&gt;ItemDataRole&lt;/a&gt; 이 &lt;a href=&quot;qheaderview&quot;&gt;QHeaderView에&lt;/a&gt; 영향을주는 것은 아닙니다 . 다른 역할을 &lt;a href=&quot;qheaderview&quot;&gt;가져와야하는 경우 QHeaderView&lt;/a&gt; 를 서브 클래스 화 하고 &lt;a href=&quot;qheaderview#paintEvent&quot;&gt;paintEvent ()를&lt;/a&gt; 다시 구현할 수 있습니다 . &lt;a href=&quot;qheaderview&quot;&gt;QHeaderView&lt;/a&gt; 는 스타일과 충돌하지 않는 한 다음 항목 데이터 역할을 존중합니다 (데스크탑 테마를 따르는 스타일에서 발생할 수 있음).</target>
        </trans-unit>
        <trans-unit id="fd412eea176d5395ff2e15ec2ef29443a6fe810f" translate="yes" xml:space="preserve">
          <source>Not all &lt;a href=&quot;qt#ItemDataRole-enum&quot;&gt;ItemDataRole&lt;/a&gt;s will have an effect on a QHeaderView. If you need to draw other roles, you can subclass QHeaderView and reimplement &lt;a href=&quot;qheaderview#paintEvent&quot;&gt;paintEvent()&lt;/a&gt;. QHeaderView respects the following item data roles, unless they are in conflict with the style (which can happen for styles that follow the desktop theme):</source>
          <target state="translated">모든 &lt;a href=&quot;qt#ItemDataRole-enum&quot;&gt;ItemDataRole&lt;/a&gt; 이 QHeaderView에 영향을주는 것은 아닙니다. 다른 역할을 그려야하는 경우 QHeaderView를 하위 클래스로 만들고 &lt;a href=&quot;qheaderview#paintEvent&quot;&gt;paintEvent ()를&lt;/a&gt; 다시 구현할 수 있습니다 . QHeaderView는 스타일과 충돌하지 않는 한 다음 항목 데이터 역할을 존중합니다 (데스크탑 테마를 따르는 스타일에서 발생할 수 있음).</target>
        </trans-unit>
        <trans-unit id="38c9bf2426ab484a5cf862cdd70c1b2068ded784" translate="yes" xml:space="preserve">
          <source>Not all &lt;a href=&quot;qtcore-changes-qt6#qvariant&quot;&gt;QVariant&lt;/a&gt; types are supported. Below is a list of currently supported &lt;a href=&quot;qtcore-changes-qt6#qvariant&quot;&gt;QVariant&lt;/a&gt; types:</source>
          <target state="translated">모든 &lt;a href=&quot;qtcore-changes-qt6#qvariant&quot;&gt;QVariant&lt;/a&gt; 유형이 지원되는 것은 아닙니다 . 다음은 현재 지원되는 &lt;a href=&quot;qtcore-changes-qt6#qvariant&quot;&gt;QVariant&lt;/a&gt; 유형 목록입니다 .</target>
        </trans-unit>
        <trans-unit id="dd36f248af501658c8b239322c1044a84f7b7ada" translate="yes" xml:space="preserve">
          <source>Not all &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; types are supported. Below is a list of currently supported &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; types:</source>
          <target state="translated">모든 &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; 유형이 지원되는 것은 아닙니다 . 다음은 현재 지원되는 &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; 유형 목록입니다 .</target>
        </trans-unit>
        <trans-unit id="6f9be1da6b6cb18e31561e26fd94d8a84c9dd871" translate="yes" xml:space="preserve">
          <source>Not all QML list properties support all operations. A set of methods, &lt;a href=&quot;qqmllistreference#canAppend&quot;&gt;canAppend&lt;/a&gt;(), &lt;a href=&quot;qqmllistreference#canAt&quot;&gt;canAt&lt;/a&gt;(), &lt;a href=&quot;qqmllistreference#canClear&quot;&gt;canClear&lt;/a&gt;() and &lt;a href=&quot;qqmllistreference#canCount&quot;&gt;canCount&lt;/a&gt;() allow programs to query whether an operation is supported on a given property.</source>
          <target state="translated">모든 QML 목록 특성이 모든 조작을 지원하는 것은 아닙니다. 방법의 세트 &lt;a href=&quot;qqmllistreference#canAppend&quot;&gt;canAppend&lt;/a&gt; () &lt;a href=&quot;qqmllistreference#canAt&quot;&gt;canAt&lt;/a&gt; () &lt;a href=&quot;qqmllistreference#canClear&quot;&gt;canClear&lt;/a&gt; () 및 &lt;a href=&quot;qqmllistreference#canCount&quot;&gt;canCount&lt;/a&gt; ()는 동작이 지정된 속성에 지원되는지 질의 프로그램을 허용한다.</target>
        </trans-unit>
        <trans-unit id="920a4ddd5ebd507cc29ac19cb6c5989b712760a1" translate="yes" xml:space="preserve">
          <source>Not all backends and devices might support setting the acceleration mode. For those cases, the default mode &lt;a href=&quot;qaccelerometer#AccelerationMode-enum&quot;&gt;QAccelerometer::Combined&lt;/a&gt; is used, changing it has no effect.</source>
          <target state="translated">모든 백엔드 및 장치가 가속 모드 설정을 지원하지는 않습니다. 이러한 경우 기본 모드 &lt;a href=&quot;qaccelerometer#AccelerationMode-enum&quot;&gt;QAccelerometer :: Combined&lt;/a&gt; 가 사용되며 변경해도 아무런 영향이 없습니다.</target>
        </trans-unit>
        <trans-unit id="0c3ef0e191ed651b5eb833765ea18844f8166d8b" translate="yes" xml:space="preserve">
          <source>Not all buffer implementations will map more than the first plane, if this returns a single plane for a planar format the additional planes will have to be calculated from the line stride of the first plane and the frame height. Mapping a buffer with &lt;a href=&quot;qvideoframe&quot;&gt;QVideoFrame&lt;/a&gt; will do this for you.</source>
          <target state="translated">모든 버퍼 구현이 첫 번째 평면 이상으로 매핑되는 것은 아닙니다. 평면 형식의 단일 평면을 반환하면 첫 번째 평면의 선 보폭과 프레임 높이에서 추가 평면을 계산해야합니다. &lt;a href=&quot;qvideoframe&quot;&gt;QVideoFrame&lt;/a&gt; 으로 버퍼를 매핑하면 이 작업이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="56ccf465d841877665b2e6bebae78a1235a092b6" translate="yes" xml:space="preserve">
          <source>Not all filesystems support this feature. In this case, the value returned by this method could be empty. An empty string is returned if the file system does not support labels, or if no label is set.</source>
          <target state="translated">모든 파일 시스템이이 기능을 지원하는 것은 아닙니다. 이 경우이 메서드에서 반환 한 값이 비어있을 수 있습니다. 파일 시스템이 레이블을 지원하지 않거나 레이블이 설정되지 않은 경우 빈 문자열이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="9855b33cf797230a4f2adf23ead2ccd496f06777" translate="yes" xml:space="preserve">
          <source>Not all image formats support embedded text. You can find out if a specific image or format supports embedding text by using &lt;a href=&quot;qimagewriter#supportsOption&quot;&gt;QImageWriter::supportsOption&lt;/a&gt;(). We give an example:</source>
          <target state="translated">모든 이미지 형식이 포함 된 텍스트를 지원하지는 않습니다. &lt;a href=&quot;qimagewriter#supportsOption&quot;&gt;QImageWriter :: supportsOption&lt;/a&gt; () 을 사용하여 특정 이미지 또는 형식이 텍스트 포함을 지원하는지 확인할 수 있습니다 . 예를 들어 보자.</target>
        </trans-unit>
        <trans-unit id="2a0033d81c61d850a7275618f9235c6796503f5d" translate="yes" xml:space="preserve">
          <source>Not all layouts should necessarily be mirrored. There are cases where a visual type is positioned to the right side of the screen for improved one-handed use, because most people are right-handed, and not because of the reading direction. In the case that a child type should not be affected by mirroring, set the &lt;a href=&quot;qml-qtquick-layoutmirroring#enabled-prop&quot;&gt;LayoutMirroring.enabled&lt;/a&gt; property for that type to false.</source>
          <target state="translated">모든 레이아웃이 반드시 미러링되어야하는 것은 아닙니다. 한 손으로 사용하기 위해 시각적 유형이 화면 오른쪽에 배치되는 경우가 있습니다. 대부분의 사람들은 읽기 방향이 아니라 오른 손잡이이기 때문입니다. 자식 형식이 미러링의 영향을받지 않아야하는 경우 해당 형식의 &lt;a href=&quot;qml-qtquick-layoutmirroring#enabled-prop&quot;&gt;LayoutMirroring.enabled&lt;/a&gt; 속성을 false로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="0a9217f7bb749bdd07b6006263d5caded9b191cc" translate="yes" xml:space="preserve">
          <source>Not all light sensor support retrieving their field of view. For sensors that don't support this property, the value will be 0. Whether the field of view is supported can be checked with &lt;a href=&quot;qsensor#isFeatureSupported&quot;&gt;QSensor::isFeatureSupported&lt;/a&gt;() and the &lt;a href=&quot;qsensor#Feature-enum&quot;&gt;QSensor::FieldOfView&lt;/a&gt; flag.</source>
          <target state="translated">모든 광 센서가 시야를 검색하는 것을 지원하지는 않습니다. 이 특성을 지원하지 않는 센서의 경우 값은 0입니다. 시야가 지원되는지 여부는 &lt;a href=&quot;qsensor#isFeatureSupported&quot;&gt;QSensor :: isFeatureSupported&lt;/a&gt; () 및 QSensor &lt;a href=&quot;qsensor#Feature-enum&quot;&gt;:: FieldOfView&lt;/a&gt; 플래그를 사용 하여 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1078dc10ef57f9878b22261107120d76133cc9f6" translate="yes" xml:space="preserve">
          <source>Not all operating systems support reporting all features. Only the IPv4 addresses are guaranteed to be listed by this class in all platforms. In particular, IPv6 address listing is only supported on Windows, Linux, &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; and the BSDs.</source>
          <target state="translated">모든 운영 체제가 모든 기능보고를 지원하지는 않습니다. 모든 플랫폼에서이 클래스는 IPv4 주소 만 나열하도록 보장합니다. 특히 IPv6 주소 목록은 Windows, Linux, &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; 및 BSD 에서만 지원됩니다 .</target>
        </trans-unit>
        <trans-unit id="e0f932087c1e94dfe660008e448241f71604cfc4" translate="yes" xml:space="preserve">
          <source>Not all operating systems support reporting all features. Only the IPv4 addresses are guaranteed to be listed by this class in all platforms. In particular, IPv6 address listing is only supported on Windows, Linux, macOS and the BSDs.</source>
          <target state="translated">모든 운영 체제가 모든 기능보고를 지원하는 것은 아닙니다. 이 클래스는 모든 플랫폼에서 IPv4 주소 만 나열됩니다. 특히 IPv6 주소 목록은 Windows, Linux, macOS 및 BSD에서만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="c33237b79325f11d19e938f45a8351c5c269d91f" translate="yes" xml:space="preserve">
          <source>Not all platforms distinguish the different positioning methods or communicate the current user configuration of the device. The following table provides an overview of the current platform situation:</source>
          <target state="translated">모든 플랫폼이 서로 다른 포지셔닝 방법을 구별하거나 장치의 현재 사용자 구성을 전달하는 것은 아닙니다. 다음 표는 현재 플랫폼 상황에 대한 개요를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="7f3207637552b92e0a597ec2f706c93ab560fb73" translate="yes" xml:space="preserve">
          <source>Not all platforms support &lt;a href=&quot;qbluetoothdevicediscoveryagent#InquiryType-enum&quot;&gt;LimitedInquiry&lt;/a&gt;.</source>
          <target state="translated">모든 플랫폼이 &lt;a href=&quot;qbluetoothdevicediscoveryagent#InquiryType-enum&quot;&gt;LimitedInquiry를&lt;/a&gt; 지원하는 것은 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="f20e8eed75ec9cded6bc7fde5a483471fe3805a9" translate="yes" xml:space="preserve">
          <source>Not all platforms support audio stream categorization. In this case, the function call will be ignored.</source>
          <target state="translated">모든 플랫폼이 오디오 스트림 분류를 지원하지는 않습니다. 이 경우 함수 호출은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="42267fb1f7d2ef3537901d7001dc8ee8045789da" translate="yes" xml:space="preserve">
          <source>Not all playback services support change of the playback rate. It is framework defined as to the status and quality of audio and video while fast forwarding or rewinding.</source>
          <target state="translated">모든 재생 서비스가 재생 속도 변경을 지원하는 것은 아닙니다. 빨리 감기 또는 되감기 동안 오디오 및 비디오의 상태와 품질에 대해 정의 된 프레임 워크입니다.</target>
        </trans-unit>
        <trans-unit id="5ae94eb1d9588b00c18119f53067f96c45eab7da" translate="yes" xml:space="preserve">
          <source>Not all properties of a Position object are necessarily valid or available (for example latitude and longitude may be valid, but speed update has not been received or set manually). As a result, corresponding &quot;valid&quot; properties are available (for example &lt;a href=&quot;qml-qtpositioning-position#coordinate-prop&quot;&gt;coordinate&lt;/a&gt; and &lt;a href=&quot;qml-qtpositioning-position#longitudeValid-prop&quot;&gt;longitudeValid&lt;/a&gt;, &lt;a href=&quot;qml-qtpositioning-position#latitudeValid-prop&quot;&gt;latitudeValid&lt;/a&gt; etc) to discern whether the data is available and valid in this position update.</source>
          <target state="translated">Position 객체의 모든 속성이 반드시 유효하거나 사용 가능한 것은 아닙니다 (예 : 위도와 경도는 유효하지만 속도 업데이트는 수동으로 받거나 설정하지 않았습니다). 결과적 으로이 위치 업데이트에서 데이터가 사용 가능하고 유효한지 여부를 식별하기 위해 해당 &quot;유효한&quot;속성 (예 : &lt;a href=&quot;qml-qtpositioning-position#coordinate-prop&quot;&gt;coordinate&lt;/a&gt; 및 &lt;a href=&quot;qml-qtpositioning-position#longitudeValid-prop&quot;&gt;longitudeValid&lt;/a&gt; , &lt;a href=&quot;qml-qtpositioning-position#latitudeValid-prop&quot;&gt;latitudeValid&lt;/a&gt; 등)을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b0d8841621d63d51d771e2e2c613af36d6311fa3" translate="yes" xml:space="preserve">
          <source>Not all properties of an Address are necessarily available or relevant in all parts of the world and all locales. The &lt;a href=&quot;qml-qtpositioning-address#district-prop&quot;&gt;district&lt;/a&gt;, &lt;a href=&quot;qml-qtpositioning-address#state-prop&quot;&gt;state&lt;/a&gt; and &lt;a href=&quot;qml-qtpositioning-address#county-prop&quot;&gt;county&lt;/a&gt; properties are particularly area-specific for many data sources, and often only one or two of these are available or useful.</source>
          <target state="translated">주소의 모든 속성이 전 세계 모든 지역과 모든 지역에서 반드시 사용 가능하거나 관련있는 것은 아닙니다. &lt;a href=&quot;qml-qtpositioning-address#district-prop&quot;&gt;지역&lt;/a&gt; , &lt;a href=&quot;qml-qtpositioning-address#state-prop&quot;&gt;주&lt;/a&gt; 및 &lt;a href=&quot;qml-qtpositioning-address#county-prop&quot;&gt;카운티&lt;/a&gt; 속성은 특히 많은 데이터 소스에 대한 영역 별, 그리고 종종 하나 또는이 두 가지가 가능하거나 유용합니다.</target>
        </trans-unit>
        <trans-unit id="962d6be12fe0eac2bdc039867712131ca6899413" translate="yes" xml:space="preserve">
          <source>Not all surfaces will block until the presentation of a frame has completed. Calling present() on a non-blocking surface may fail if called before the presentation of a previous frame has completed. In such cases the surface may not return to a ready state until it has had an opportunity to process events.</source>
          <target state="translated">프레임 표현이 완료 될 때까지 모든 표면이 차단되는 것은 아닙니다. 이전 프레임의 프리젠 테이션이 완료되기 전에 호출되면 비 블로킹 표면에서 present () 호출이 실패 할 수 있습니다. 이러한 경우 표면은 이벤트를 처리 할 기회가있을 때까지 준비 상태로 돌아 오지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3fc01800d08c9c3206cfa68087be7c2909531a14" translate="yes" xml:space="preserve">
          <source>Not all touch devices support velocity. If velocity is not supported, it will be reported as 0,0.</source>
          <target state="translated">모든 터치 장치가 속도를 지원하는 것은 아닙니다. 속도가 지원되지 않으면 0,0으로보고됩니다.</target>
        </trans-unit>
        <trans-unit id="6ba00239d6dc40ce03a913c0a89ce212b384ad4f" translate="yes" xml:space="preserve">
          <source>Not all valid PPD page sizes have a Windows equivalent, in which case 0 will be returned.</source>
          <target state="translated">유효한 모든 PPD 페이지 크기가 Windows에 해당하는 것은 아니며 0이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="3203211aa24373af4718f241bb6b795939f4c3b3" translate="yes" xml:space="preserve">
          <source>Not all views display headers with the item data, and those that do may be configured to hide them. Nonetheless, it is recommended that you implement the &lt;a href=&quot;qabstractitemmodel#headerData&quot;&gt;headerData()&lt;/a&gt; function to provide relevant information about the data provided by the model.</source>
          <target state="translated">모든보기에 항목 데이터가 포함 된 머리글이 표시되는 것은 아니며, 머리글이 숨겨 지도록 구성되어있을 수 있습니다. 그럼에도 불구하고 &lt;a href=&quot;qabstractitemmodel#headerData&quot;&gt;headerData ()&lt;/a&gt; 함수를 구현 하여 모델이 제공 한 데이터에 대한 관련 정보를 제공 하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="8b85856d4da04565a35cceabbe1540cc04131e83" translate="yes" xml:space="preserve">
          <source>Not all widgets have every state implemented. This goes for states that are common, e.g., &lt;code&gt;State_Disabled&lt;/code&gt;. Each state is, however, implemented for at least one widget.</source>
          <target state="translated">모든 위젯이 모든 상태를 구현하는 것은 아닙니다. 이것은 일반적인 상태, 예를 들어 &lt;code&gt;State_Disabled&lt;/code&gt; 입니다. 그러나 각 상태는 하나 이상의 위젯에 대해 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="8586cb1ea88fd85a6406b26c7b3c9748a4533c02" translate="yes" xml:space="preserve">
          <source>Not all widgets send a pointer to themselves. If the style option sent to the function does not contain the information you need, you should check the widget implementation to see if it sends a pointer to itself.</source>
          <target state="translated">모든 위젯이 자신에게 포인터를 보내는 것은 아닙니다. 함수에 전송 된 스타일 옵션에 필요한 정보가 포함되어 있지 않으면 위젯 구현이 자체 포인터를 보내는 지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="32d6504ce1831d0c3be30ad8947b92911e3d41b8" translate="yes" xml:space="preserve">
          <source>Not an event.</source>
          <target state="translated">이벤트가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="a1ec39debdd474dbcadef4bf3469aace2a9f7610" translate="yes" xml:space="preserve">
          <source>Not defined.</source>
          <target state="translated">정의되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="3cb7a7c83ec9a1625fafcb5ce83eec15fa26183e" translate="yes" xml:space="preserve">
          <source>Not every mouse has a &lt;code&gt;Horizontal&lt;/code&gt; wheel; sometimes it is emulated by tilting the wheel sideways. A touchpad can usually generate both vertical and horizontal wheel events.</source>
          <target state="translated">모든 마우스에 &lt;code&gt;Horizontal&lt;/code&gt; 휠 이있는 것은 아닙니다 . 때로는 휠을 옆으로 기울여 모방됩니다. 터치 패드는 일반적으로 수직 및 수평 휠 이벤트를 모두 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c90deb2ad72d2a8bfd7aeb6820f2189ef8d6418d" translate="yes" xml:space="preserve">
          <source>Not following any redirects.</source>
          <target state="translated">리디렉션을 따르지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dc92a0df32bc60ff9b92002606a6591f2491a20e" translate="yes" xml:space="preserve">
          <source>Not null-terminated varying binary string with 4-byte string length indicator</source>
          <target state="translated">4 바이트 문자열 길이 표시기가있는 널 (NULL)로 끝나지 않는 가변 2 진 문자열</target>
        </trans-unit>
        <trans-unit id="e77db16315b46f2991cd4a5abcd4cb31fcfd4a86" translate="yes" xml:space="preserve">
          <source>Not null-terminated varying length character string</source>
          <target state="translated">널로 끝나지 않는 가변 길이 문자열</target>
        </trans-unit>
        <trans-unit id="6f5d1b24713be7170c0b03bb40b3d5a1daee26d8" translate="yes" xml:space="preserve">
          <source>Not officially supported, but technically possible via private APIs</source>
          <target state="translated">공식적으로 지원되지는 않지만 비공개 API를 통해 기술적으로 가능</target>
        </trans-unit>
        <trans-unit id="3bd71a4e5bb2166baabf9a764f892d60a8def717" translate="yes" xml:space="preserve">
          <source>Not only Qt itself but also Qt application can be extended through plugins. This requires the application to detect and load plugins using &lt;a href=&quot;qpluginloader&quot;&gt;QPluginLoader&lt;/a&gt;. In that context, plugins may provide arbitrary functionality and are not limited to database drivers, image formats, text codecs, styles, and the other types of plugin that extend Qt's functionality.</source>
          <target state="translated">Qt 자체뿐만 아니라 Qt 애플리케이션도 플러그인을 통해 확장 할 수 있습니다. 이를 위해서는 애플리케이션이 &lt;a href=&quot;qpluginloader&quot;&gt;QPluginLoader를&lt;/a&gt; 사용하여 플러그인을 감지하고로드해야합니다 . 이러한 맥락에서 플러그인은 임의의 기능을 제공 할 수 있으며 데이터베이스 드라이버, 이미지 형식, 텍스트 코덱, 스타일 및 Qt의 기능을 확장하는 다른 유형의 플러그인으로 제한되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6e5eb7862f18509dcd08c5340ad8a1271009d10f" translate="yes" xml:space="preserve">
          <source>Not only does handling events and logic in C++ increase performance, but it allows the visual QML layer to be a simple, declarative layer on top. This is reflected in the structure of the controls project: all visual implementations sit in the</source>
          <target state="translated">C ++에서 이벤트와 로직을 처리하면 성능이 향상 될뿐만 아니라 시각적 QML 레이어가 단순하고 선언적인 레이어가 될 수 있습니다. 이는 컨트롤 프로젝트의 구조에 반영됩니다. 모든 시각적 구현은</target>
        </trans-unit>
        <trans-unit id="842027b4684d01f4e4724ce27f032db3a919a5c1" translate="yes" xml:space="preserve">
          <source>Not recommended formats: all mono formats (for example &lt;a href=&quot;qimage#Format-enum&quot;&gt;QImage::Format_Mono&lt;/a&gt;).</source>
          <target state="translated">권장하지 않는 형식 : 모든 모노 형식 (예 &lt;a href=&quot;qimage#Format-enum&quot;&gt;: QImage :: Format_Mono&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="e8f5f22e840b92fdc264fab87319e2f73fd95cd2" translate="yes" xml:space="preserve">
          <source>Not sorted by default.</source>
          <target state="translated">기본적으로 정렬되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8e635455c1c04acc72cc3cb8b3930fa2002922c7" translate="yes" xml:space="preserve">
          <source>Not supported</source>
          <target state="translated">미지원</target>
        </trans-unit>
        <trans-unit id="9f838ec4724e773fa7ddcc0fca00bde7f8d8e7e8" translate="yes" xml:space="preserve">
          <source>Not yet initialized.</source>
          <target state="translated">아직 초기화되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="e6573a76306929c393f0738d4800b0353387f0a7" translate="yes" xml:space="preserve">
          <source>Not yet known due to no window and scenegraph associated</source>
          <target state="translated">연결된 창 및 장면 그래프가 없기 때문에 아직 알 수 없음</target>
        </trans-unit>
        <trans-unit id="25a623900f7593067a8d488822842096b3bd57c8" translate="yes" xml:space="preserve">
          <source>NotSupportedFeatureError</source>
          <target state="translated">NotSupportedFeatureError</target>
        </trans-unit>
        <trans-unit id="9fffe5c2260d7d5a26d9fd3ce7dcc5d930796c0e" translate="yes" xml:space="preserve">
          <source>Notation nodes can be imported, but at the moment there is no way to use them since the document type is read-only in DOM level 2.</source>
          <target state="translated">표기법 노드는 가져올 수 있지만 DOM 레벨 2에서는 문서 유형이 읽기 전용이므로 현재 사용할 수있는 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="2c924e3088204ee77ba681f72be3444357932fca" translate="yes" xml:space="preserve">
          <source>Note</source>
          <target state="translated">Note</target>
        </trans-unit>
        <trans-unit id="015ff47a539abb636c5f0168d82db93affb30ed0" translate="yes" xml:space="preserve">
          <source>Note about casting to a signed integer: all bits returned by this function are random, so there's a 50% chance that the most significant bit will be set. If you wish to cast the returned value to qint64 and keep it positive, you should mask the sign bit off:</source>
          <target state="translated">부호있는 정수로 캐스트하는 것에 대한 참고 사항 :이 함수가 반환하는 모든 비트는 임의이므로 가장 중요한 비트가 설정 될 확률은 50 %입니다. 리턴 값을 qint64로 캐스트하고 양수로 유지하려면 부호 비트를 마스킹해야합니다.</target>
        </trans-unit>
        <trans-unit id="78291faee746794d3b970b21a4d9546cfce34381" translate="yes" xml:space="preserve">
          <source>Note also that if a &lt;code&gt;SelfDestroyingRect&lt;/code&gt; instance was created statically like this:</source>
          <target state="translated">&lt;code&gt;SelfDestroyingRect&lt;/code&gt; 인스턴스가 다음과 같이 정적으로 생성 된 경우에도 유의 하십시오.</target>
        </trans-unit>
        <trans-unit id="0627974e1728db3fb678d692db4eb32b9e6f0969" translate="yes" xml:space="preserve">
          <source>Note also that remote applications may not have support for Unix file descriptor passing. If you make a D-Bus to a remote application that cannot receive such a type, you will receive an error reply. If you try to send a signal containing a D-Bus file descriptor or return one from a method call, the message will be silently dropped.</source>
          <target state="translated">또한 원격 애플리케이션은 Unix 파일 디스크립터 전달을 지원하지 않을 수 있습니다. 이러한 유형을 수신 할 수없는 원격 애플리케이션에 D-Bus를 만들면 오류 응답이 수신됩니다. D-Bus 파일 디스크립터가 포함 된 신호를 보내거나 메소드 호출에서 신호를 보내려고하면 메시지가 자동으로 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="89784bf26a30700386d678dbbc8d5cf94bed0b4a" translate="yes" xml:space="preserve">
          <source>Note also that the indentation style used by &lt;a href=&quot;qxmlformatter&quot;&gt;QXmlFormatter&lt;/a&gt; remains loosely defined and may change in future versions of Qt. If a specific indentation style is required then either use the base class &lt;a href=&quot;qxmlserializer&quot;&gt;QXmlSerializer&lt;/a&gt; directly, or write your own subclass of &lt;a href=&quot;qxmlserializer&quot;&gt;QXmlSerializer&lt;/a&gt; or &lt;a href=&quot;qabstractxmlreceiver&quot;&gt;QAbstractXmlReceiver&lt;/a&gt;. Alternatively, you can subclass &lt;a href=&quot;qxmlformatter&quot;&gt;QXmlFormatter&lt;/a&gt; and reimplement the callbacks there.</source>
          <target state="translated">또한 &lt;a href=&quot;qxmlformatter&quot;&gt;QXmlFormatter에서&lt;/a&gt; 사용하는 들여 쓰기 스타일 은 느슨하게 정의되어 있으며 향후 Qt 버전에서 변경 될 수 있습니다. 특정 들여 쓰기 스타일이 필요한 경우 기본 클래스 &lt;a href=&quot;qxmlserializer&quot;&gt;QXmlSerializer를&lt;/a&gt; 직접 사용 하거나 &lt;a href=&quot;qxmlserializer&quot;&gt;QXmlSerializer&lt;/a&gt; 또는 &lt;a href=&quot;qabstractxmlreceiver&quot;&gt;QAbstractXmlReceiver&lt;/a&gt; 의 자체 서브 클래스를 작성하십시오 . 또는 &lt;a href=&quot;qxmlformatter&quot;&gt;QXmlFormatter&lt;/a&gt; 를 서브 클래 싱 하고 콜백을 다시 구현할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b40eae2e467d39e1270bea06e49ab32f2cdfb07b" translate="yes" xml:space="preserve">
          <source>Note also that the indentation style used by QXmlFormatter remains loosely defined and may change in future versions of Qt. If a specific indentation style is required then either use the base class &lt;a href=&quot;qxmlserializer&quot;&gt;QXmlSerializer&lt;/a&gt; directly, or write your own subclass of &lt;a href=&quot;qxmlserializer&quot;&gt;QXmlSerializer&lt;/a&gt; or &lt;a href=&quot;qabstractxmlreceiver&quot;&gt;QAbstractXmlReceiver&lt;/a&gt;. Alternatively, you can subclass QXmlFormatter and reimplement the callbacks there.</source>
          <target state="translated">QXmlFormatter에서 사용하는 들여 쓰기 스타일은 느슨하게 정의되어 있으며 Qt의 향후 버전에서 변경 될 수 있습니다. 특정 들여 쓰기 스타일이 필요한 경우 기본 클래스 &lt;a href=&quot;qxmlserializer&quot;&gt;QXmlSerializer를&lt;/a&gt; 직접 사용 하거나 &lt;a href=&quot;qxmlserializer&quot;&gt;QXmlSerializer&lt;/a&gt; 또는 &lt;a href=&quot;qabstractxmlreceiver&quot;&gt;QAbstractXmlReceiver&lt;/a&gt; 의 고유 한 하위 클래스를 작성하십시오 . 또는 QXmlFormatter를 하위 클래스로 만들고 거기에서 콜백을 다시 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b87c48561cb5f92c130577c1ff4494d6123f5fe" translate="yes" xml:space="preserve">
          <source>Note for &lt;a href=&quot;qt#DateFormat-enum&quot;&gt;Qt::TextDate&lt;/a&gt;: It is recommended that you use the English short month names (e.g. &quot;Jan&quot;). Although localized month names can also be used in Qt 5, they depend on the user's locale settings.</source>
          <target state="translated">&lt;a href=&quot;qt#DateFormat-enum&quot;&gt;Qt :: TextDate에&lt;/a&gt; 대한 참고 사항 : 영어의 짧은 월 이름 (예 : &quot;Jan&quot;)을 사용하는 것이 좋습니다. 현지화 된 월 이름은 Qt 5에서도 사용할 수 있지만 사용자의 로케일 설정에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="4adc44fe61d744fdea6ad839a8d2a9f882123a92" translate="yes" xml:space="preserve">
          <source>Note for &lt;a href=&quot;qt#DateFormat-enum&quot;&gt;Qt::TextDate&lt;/a&gt;: It is recommended that you use the English short month names (e.g. &quot;Jan&quot;). Although localized month names can also be used, they depend on the user's locale settings.</source>
          <target state="translated">&lt;a href=&quot;qt#DateFormat-enum&quot;&gt;Qt :: TextDate&lt;/a&gt; 참고 사항 : 영어 짧은 달 이름 (예 : &quot;Jan&quot;)을 사용하는 것이 좋습니다. 현지화 된 월 이름도 사용할 수 있지만 사용자의 로캘 설정에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="198534bd1303a97d477484264966b07eb9669aca" translate="yes" xml:space="preserve">
          <source>Note for &lt;a href=&quot;qt#DateFormat-enum&quot;&gt;Qt::TextDate&lt;/a&gt;: only English month names (e.g. &quot;Jan&quot; in short form or &quot;January&quot; in long form) are recognized.</source>
          <target state="translated">&lt;a href=&quot;qt#DateFormat-enum&quot;&gt;Qt :: TextDate에&lt;/a&gt; 대한 참고 사항 : 영어 월 이름 (예 : 짧은 형식의 &quot;Jan&quot;또는 긴 형식의 &quot;January&quot;) 만 인식됩니다.</target>
        </trans-unit>
        <trans-unit id="e0425702fea8b370cac2299a8f554496d23b37b6" translate="yes" xml:space="preserve">
          <source>Note for &lt;a href=&quot;qt#DateFormat-enum&quot;&gt;Qt::TextDate&lt;/a&gt;: only English short month names (e.g. &quot;Jan&quot; in short form or &quot;January&quot; in long form) are recognized.</source>
          <target state="translated">&lt;a href=&quot;qt#DateFormat-enum&quot;&gt;Qt :: TextDate에&lt;/a&gt; 대한 참고 사항 : 영어 짧은 월 이름 (예 : 짧은 형식의 &quot;Jan&quot;또는 긴 형식의 &quot;January&quot;) 만 인식됩니다.</target>
        </trans-unit>
        <trans-unit id="b0a83b7a7b11d41214a6405b90e122a37090858e" translate="yes" xml:space="preserve">
          <source>Note for C Programmers</source>
          <target state="translated">C 프로그래머를위한 참고 사항</target>
        </trans-unit>
        <trans-unit id="524e49516a5ab947844836fabb4089a6f771aca8" translate="yes" xml:space="preserve">
          <source>Note for developers implementing classes derived from &lt;a href=&quot;qiodevice&quot;&gt;QIODevice&lt;/a&gt;: you should always emit readyRead() when new data has arrived (do not emit it only because there's data still to be read in your buffers). Do not emit readyRead() in other conditions.</source>
          <target state="translated">&lt;a href=&quot;qiodevice&quot;&gt;QIODevice&lt;/a&gt; 에서 파생 된 클래스를 구현하는 개발자를위한 참고 사항 : 새 데이터가 도착하면 항상 readyRead ()를 방출해야합니다 (버퍼에서 여전히 읽을 데이터가 있으므로 방출하지 마십시오). 다른 조건에서는 readyRead ()를 방출하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="f91253173a5e49ac5f89db760edadba6b49d5551" translate="yes" xml:space="preserve">
          <source>Note how &lt;a href=&quot;qdebug&quot;&gt;QDebug&lt;/a&gt; needed to close and reopen the string in the way C and C++ languages concatenate string literals so that the letter 'b' is not interpreted as part of the previous hexadecimal escape sequence.</source>
          <target state="translated">C 및 C ++ 언어가 문자열 리터럴을 연결하여 문자 'b'가 이전 16 진 이스케이프 시퀀스의 일부로 해석되지 않도록 &lt;a href=&quot;qdebug&quot;&gt;QDebug&lt;/a&gt; 가 문자열을 닫았다가 다시 열어야 하는 방법에 주목 하십시오.</target>
        </trans-unit>
        <trans-unit id="6e5558a1173a10f4eb3c8958bec21ff87a7daf9c" translate="yes" xml:space="preserve">
          <source>Note how all target languages and versions now exist in two variants: Standard and a slightly modified Batchable.</source>
          <target state="translated">이제 모든 대상 언어와 버전이 표준 및 약간 수정 된 Batchable의 두 가지 변형에 어떻게 존재하는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="fbd56c9be9e27b30363c658a176dc95d30207896" translate="yes" xml:space="preserve">
          <source>Note how the &lt;code&gt;color&lt;/code&gt; assignment in each &lt;a href=&quot;qml-qtquick-controls2-control#background-prop&quot;&gt;background&lt;/a&gt; item qualifies the attached property with the &lt;code&gt;id&lt;/code&gt; of the label. This is important; using the attached properties on an item causes that item to accept events. Suppose we had left out the &lt;code&gt;id&lt;/code&gt; in the previous example:</source>
          <target state="translated">각 &lt;a href=&quot;qml-qtquick-controls2-control#background-prop&quot;&gt;배경&lt;/a&gt; 항목 의 &lt;code&gt;color&lt;/code&gt; 지정 이 레이블 의 &lt;code&gt;id&lt;/code&gt; 로 첨부 된 특성을 규정하는 방법에 유의하십시오 . 이건 중요하다; 항목에 첨부 된 특성을 사용하면 해당 항목이 이벤트를 승인합니다. 이전 예에서 &lt;code&gt;id&lt;/code&gt; 를 생략했다고 가정 해 봅시다 .</target>
        </trans-unit>
        <trans-unit id="b53fa905d92cc1c7fdfab7178af50424dd57a85e" translate="yes" xml:space="preserve">
          <source>Note how the cylinder is not present in &lt;code&gt;DEPTH_TEXTURE&lt;/code&gt; due to its reliance on semi-transparency, which puts it into a different category than the other objects that are all opaque. These objects do not write into the depth buffer, although they do test against the depth values written by opaque objects, and rely on being rendered in back to front order. Hence they are not present in &lt;code&gt;DEPTH_TEXTURE&lt;/code&gt; either.</source>
          <target state="translated">&lt;code&gt;DEPTH_TEXTURE&lt;/code&gt; 의존하기 때문에 DEPTH_TEXTURE에 실린더가 없는지 확인하십시오.이 때문에 모두 불투명 한 다른 개체와는 다른 범주에 속합니다. 이러한 객체는 불투명 객체에 의해 기록 된 깊이 값에 대해 테스트하고 앞뒤 순서로 렌더링되는 것에 의존하지만 깊이 버퍼에 쓰지 않습니다. 따라서 &lt;code&gt;DEPTH_TEXTURE&lt;/code&gt; 에도 없습니다 .</target>
        </trans-unit>
        <trans-unit id="676031fd8bdd1d3aa072d6ba96563b7ff17a35ac" translate="yes" xml:space="preserve">
          <source>Note how this function can be used to encode numbers that cannot fit a standard computer's 64-bit signed integer like &lt;a href=&quot;qtglobal#qint64-typedef&quot;&gt;qint64&lt;/a&gt;. That is, if</source>
          <target state="translated">이 함수를 사용하여 &lt;a href=&quot;qtglobal#qint64-typedef&quot;&gt;qint64&lt;/a&gt; 와 같은 표준 컴퓨터의 64 비트 부호있는 정수에 맞지 않는 숫자를 인코딩 할 수 있습니다 . 즉,</target>
        </trans-unit>
        <trans-unit id="22f88e3599162afb62355973cff16ea10f05035e" translate="yes" xml:space="preserve">
          <source>Note how, on Windows, environment variable names are case-insensitive.</source>
          <target state="translated">Windows에서 환경 변수 이름은 대소 문자를 구분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0c60e32b43b419a0e7d7483babc7759b41fe7acd" translate="yes" xml:space="preserve">
          <source>Note however that it is rare to require the full location to the library in &lt;code&gt;CMake&lt;/code&gt; code. Most &lt;code&gt;CMake&lt;/code&gt; APIs are aware of imported targets and can automatically use them instead of the full path.</source>
          <target state="translated">그러나 &lt;code&gt;CMake&lt;/code&gt; 코드 에서 라이브러리의 전체 위치를 요구하는 경우는 드 rare니다 . 대부분의 &lt;code&gt;CMake&lt;/code&gt; API는 가져온 대상을 알고 있으며 전체 경로 대신 자동으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea4769bf74eddade1742d3c53812aaead1c81bd2" translate="yes" xml:space="preserve">
          <source>Note it is the responsibility of the creator to delete any &lt;a href=&quot;qqmlcontext&quot;&gt;QQmlContext&lt;/a&gt; it constructs. If the &lt;code&gt;context&lt;/code&gt; object in the example is no longer needed when the &lt;code&gt;window&lt;/code&gt; component instance is destroyed, the &lt;code&gt;context&lt;/code&gt; must be destroyed explicitly. The simplest way to ensure this is to set &lt;code&gt;window&lt;/code&gt; as the parent of &lt;code&gt;context&lt;/code&gt;.</source>
          <target state="translated">생성 하는 &lt;a href=&quot;qqmlcontext&quot;&gt;QQmlContext&lt;/a&gt; 를 삭제하는 것은 작성자의 책임입니다 . &lt;code&gt;window&lt;/code&gt; 구성 요소 인스턴스가 삭제 될 때 예제 의 &lt;code&gt;context&lt;/code&gt; 객체가 더 이상 필요하지 않은 경우 &lt;code&gt;context&lt;/code&gt; 를 명시 적으로 삭제해야합니다. 이를 확인하는 가장 간단한 방법은 &lt;code&gt;window&lt;/code&gt; 를 &lt;code&gt;context&lt;/code&gt; 의 부모 로 설정 하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="9109f49671844cc3da22443653842bff7fd0dbbf" translate="yes" xml:space="preserve">
          <source>Note it is the responsibility of the creator to delete any QQmlContext it constructs. If the &lt;code&gt;context&lt;/code&gt; object in the example is no longer needed when the &lt;code&gt;window&lt;/code&gt; component instance is destroyed, the &lt;code&gt;context&lt;/code&gt; must be destroyed explicitly. The simplest way to ensure this is to set &lt;code&gt;window&lt;/code&gt; as the parent of &lt;code&gt;context&lt;/code&gt;.</source>
          <target state="translated">생성 한 QQmlContext를 삭제하는 것은 작성자의 책임입니다. &lt;code&gt;window&lt;/code&gt; 구성 요소 인스턴스가 소멸 될 때 예제 의 &lt;code&gt;context&lt;/code&gt; 객체가 더 이상 필요하지 않으면 &lt;code&gt;context&lt;/code&gt; 를 명시 적으로 소멸해야합니다. 이를 확인하는 가장 간단한 방법은 &lt;code&gt;window&lt;/code&gt; 를 &lt;code&gt;context&lt;/code&gt; 의 부모 로 설정 하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="31b1bc7a853c52f86f4dd2c153ca34a958ed01fa" translate="yes" xml:space="preserve">
          <source>Note on X11 that if the given</source>
          <target state="translated">X11에서 주어진 경우</target>
        </trans-unit>
        <trans-unit id="da7038b6159ab37164aeb7442907c881108aff7e" translate="yes" xml:space="preserve">
          <source>Note that</source>
          <target state="translated">참고</target>
        </trans-unit>
        <trans-unit id="4d648dcb6b3e559b87ec0c1071a256de4c4dbfdc" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;activeqt-dumpcpp&quot;&gt;dumpcpp&lt;/a&gt; might not be able to expose all APIs in the type library.</source>
          <target state="translated">참고 &lt;a href=&quot;activeqt-dumpcpp&quot;&gt;dumpcpp은&lt;/a&gt; 형식 라이브러리에있는 모든 API를 노출 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3db560280e1f6e816ba01598c91fee31d617f580" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;activeqt-dumpcpp#&quot;&gt;dumpcpp&lt;/a&gt; might not be able to expose all APIs in the type library.</source>
          <target state="translated">참고 &lt;a href=&quot;activeqt-dumpcpp#&quot;&gt;dumpcpp은&lt;/a&gt; 형식 라이브러리에있는 모든 API를 노출 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ce15d6a12865716fe729c4e422565bca37b33abe" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;dbus-changes-qt6#qdbusconnection&quot;&gt;QDBusConnection&lt;/a&gt; objects are reference counted: &lt;a href=&quot;qdbusservicewatcher&quot;&gt;QDBusServiceWatcher&lt;/a&gt; will keep a reference for this connection while it exists. The connection is not closed until the reference count drops to zero, so this will ensure that any notifications are received while this &lt;a href=&quot;qdbusservicewatcher&quot;&gt;QDBusServiceWatcher&lt;/a&gt; object exists.</source>
          <target state="translated">참고 &lt;a href=&quot;dbus-changes-qt6#qdbusconnection&quot;&gt;QDBusConnection의&lt;/a&gt; 객체 참조입니다 카운트 : &lt;a href=&quot;qdbusservicewatcher&quot;&gt;QDBusServiceWatcher이&lt;/a&gt; 존재하는 동안이 연결에 대한 참조를 유지합니다. 참조 횟수가 0으로 떨어질 때까지 연결이 닫히지 &lt;a href=&quot;qdbusservicewatcher&quot;&gt;않으므로이 QDBusServiceWatcher&lt;/a&gt; 객체가있는 동안 모든 알림이 수신 됩니다.</target>
        </trans-unit>
        <trans-unit id="967bbd9006ccd734539a9826f27b8eec4bea7016" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;http://doc.qt.io/qtcreator/index.html&quot;&gt;Qt Creator&lt;/a&gt; will handle this transparently for you.</source>
          <target state="translated">참고 &lt;a href=&quot;http://doc.qt.io/qtcreator/index.html&quot;&gt;Qt는 창조주가&lt;/a&gt; 투명하게 당신을 위해 이것을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="0a9c06cd50e70c72456a5d42a3654e7c8c51fe47" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtquick-animation-example.html#propertyanimation&quot;&gt;PropertyAnimation&lt;/a&gt; inherits the abstract &lt;a href=&quot;qml-qtquick-animation&quot;&gt;Animation&lt;/a&gt; type. This includes additional properties and methods for controlling the animation.</source>
          <target state="translated">참고 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtquick-animation-example.html#propertyanimation&quot;&gt;PropertyAnimation이&lt;/a&gt; 추상 상속 &lt;a href=&quot;qml-qtquick-animation&quot;&gt;애니메이션&lt;/a&gt; 유형입니다. 여기에는 애니메이션을 제어하기위한 추가 속성 및 방법이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="51112e83439ea9185236a49948d674a044a2d355" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;qabstractlistmodel&quot;&gt;QAbstractListModel&lt;/a&gt; provides a default implementation of &lt;a href=&quot;qabstractitemmodel#columnCount&quot;&gt;columnCount&lt;/a&gt;() that informs views that there is only a single column of items in this model.</source>
          <target state="translated">참고 것을 &lt;a href=&quot;qabstractlistmodel&quot;&gt;QAbstractListModel가&lt;/a&gt; 의 디폴트 구현을 제공 &lt;a href=&quot;qabstractitemmodel#columnCount&quot;&gt;열 개수를&lt;/a&gt; ()이 모델 항목의 단일 열이 있다는 정보 용의 전망이.</target>
        </trans-unit>
        <trans-unit id="04b3091c1ff527eddb1f5091d90cbcc4eb6aa25c" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;qdatawidgetmapper&quot;&gt;QDataWidgetMapper&lt;/a&gt; keeps track of external modifications. If the contents of the model are updated in another module of the application, the widgets are updated as well.</source>
          <target state="translated">참고 &lt;a href=&quot;qdatawidgetmapper&quot;&gt;QDataWidgetMapper는&lt;/a&gt; 외부 수정을 추적합니다. 모델의 컨텐츠가 애플리케이션의 다른 모듈에서 업데이트되면 위젯도 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="48a55db1c76a7d0a6dd409ddfa1de6ac6399ee72" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;qdbusconnection&quot;&gt;QDBusConnection&lt;/a&gt; objects are reference counted: &lt;a href=&quot;qdbusservicewatcher&quot;&gt;QDBusServiceWatcher&lt;/a&gt; will keep a reference for this connection while it exists. The connection is not closed until the reference count drops to zero, so this will ensure that any notifications are received while this &lt;a href=&quot;qdbusservicewatcher&quot;&gt;QDBusServiceWatcher&lt;/a&gt; object exists.</source>
          <target state="translated">참고 &lt;a href=&quot;qdbusconnection&quot;&gt;QDBusConnection의&lt;/a&gt; 객체 참조입니다 카운트 : &lt;a href=&quot;qdbusservicewatcher&quot;&gt;QDBusServiceWatcher이&lt;/a&gt; 존재하는 동안이 연결에 대한 참조를 유지합니다. 참조 카운트가 0으로 떨어질 때까지 연결이 닫히지 &lt;a href=&quot;qdbusservicewatcher&quot;&gt;않으므로이 QDBusServiceWatcher&lt;/a&gt; 오브젝트가 존재 하는 동안 모든 알림이 수신 됩니다.</target>
        </trans-unit>
        <trans-unit id="0939a2c7cd032c04beaaad8f3d5fb3a0d5bab849" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;qdbusunixfiledescriptor&quot;&gt;QDBusUnixFileDescriptor&lt;/a&gt; continues to operate even if this function returns &lt;code&gt;false&lt;/code&gt;. The only difference is that the &lt;a href=&quot;qdbusunixfiledescriptor&quot;&gt;QDBusUnixFileDescriptor&lt;/a&gt; objects will always be in the &lt;a href=&quot;qdbusunixfiledescriptor#isValid&quot;&gt;isValid&lt;/a&gt;() == false state and &lt;a href=&quot;qdbusunixfiledescriptor#fileDescriptor&quot;&gt;fileDescriptor&lt;/a&gt;() will always return -1. The class will not consume any operating system resources.</source>
          <target state="translated">참고 &lt;a href=&quot;qdbusunixfiledescriptor&quot;&gt;QDBusUnixFileDescriptor가&lt;/a&gt; 이 기능을 반환하는 경우에도 계속 작동 &lt;code&gt;false&lt;/code&gt; . 유일한 차이점은 &lt;a href=&quot;qdbusunixfiledescriptor&quot;&gt;QDBusUnixFileDescriptor&lt;/a&gt; 오브젝트가 항상 &lt;a href=&quot;qdbusunixfiledescriptor#isValid&quot;&gt;isValid&lt;/a&gt; () == false 상태이고 &lt;a href=&quot;qdbusunixfiledescriptor#fileDescriptor&quot;&gt;fileDescriptor&lt;/a&gt; ()가 항상 -1을 리턴한다는 것입니다. 이 클래스는 운영 체제 리소스를 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cd3d2cf05bbce22aa85a785f7e7823aac6ab3c8e" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;qdialog&quot;&gt;QDialog&lt;/a&gt; (and any other widget that has type &lt;code&gt;Qt::Dialog&lt;/code&gt;) uses the parent widget slightly differently from other classes in Qt. A dialog is always a top-level widget, but if it has a parent, its default location is centered on top of the parent's top-level widget (if it is not top-level itself). It will also share the parent's taskbar entry.</source>
          <target state="translated">참고 &lt;a href=&quot;qdialog&quot;&gt;인 QDialog&lt;/a&gt; (및 입력이 다른 위젯 &lt;code&gt;Qt::Dialog&lt;/code&gt; ) Qt는 다른 클래스에서 다른 위젯 약간의 부모를 사용합니다. 대화 상자는 항상 최상위 위젯이지만 부모가있는 경우 기본 위치는 부모의 최상위 위젯 (중앙 자체가 아닌 경우)의 상단에 위치합니다. 부모의 작업 표시 줄 항목도 공유합니다.</target>
        </trans-unit>
        <trans-unit id="b80777599e58e9446dc22937776b43054491f5ae" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;qdomnamednodemap&quot;&gt;QDomNamedNodeMap&lt;/a&gt; does not inherit from &lt;a href=&quot;qdomnodelist&quot;&gt;QDomNodeList&lt;/a&gt;. QDomNamedNodeMaps do not provide any specific node ordering. Although nodes in a &lt;a href=&quot;qdomnamednodemap&quot;&gt;QDomNamedNodeMap&lt;/a&gt; may be accessed by an ordinal index, this is simply to allow a convenient enumeration of the contents of a &lt;a href=&quot;qdomnamednodemap&quot;&gt;QDomNamedNodeMap&lt;/a&gt;, and does not imply that the DOM specifies an ordering of the nodes.</source>
          <target state="translated">참고 &lt;a href=&quot;qdomnamednodemap&quot;&gt;QDomNamedNodeMap이&lt;/a&gt; 상속되지 않습니다 &lt;a href=&quot;qdomnodelist&quot;&gt;QDomNodeList&lt;/a&gt; . QDomNamedNodeMaps는 특정 노드 순서를 제공하지 않습니다. &lt;a href=&quot;qdomnamednodemap&quot;&gt;QDomNamedNodeMap의&lt;/a&gt; 노드 는 서수 색인으로 액세스 할 수 있지만 이는 단순히 &lt;a href=&quot;qdomnamednodemap&quot;&gt;QDomNamedNodeMap&lt;/a&gt; 의 컨텐츠를 편리하게 열거 할 수 있도록하기위한 것이며 DOM이 노드의 순서를 지정한다는 것을 의미하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="243b04cbdaab0538fed1f2a736c93742d1cba34f" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;qdrag#setMimeData&quot;&gt;setMimeData&lt;/a&gt;() assigns ownership of the &lt;a href=&quot;qmimedata&quot;&gt;QMimeData&lt;/a&gt; object to the &lt;a href=&quot;qdrag&quot;&gt;QDrag&lt;/a&gt; object. The &lt;a href=&quot;qdrag&quot;&gt;QDrag&lt;/a&gt; must be constructed on the heap with a parent &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; to ensure that Qt can clean up after the drag and drop operation has been completed.</source>
          <target state="translated">참고 &lt;a href=&quot;qdrag#setMimeData&quot;&gt;setMimeData&lt;/a&gt; 의 () 양수인의 소유권 &lt;a href=&quot;qmimedata&quot;&gt;QMimeData를&lt;/a&gt; 받는 객체 &lt;a href=&quot;qdrag&quot;&gt;QDrag의&lt;/a&gt; 객체입니다. &lt;a href=&quot;qdrag&quot;&gt;QDrag는&lt;/a&gt; 부모와 힙에 건설해야 &lt;a href=&quot;qobject&quot;&gt;QObject를&lt;/a&gt; Qt는이 드래그 앤 드롭 작업을 완료 한 후 정리 할 수 있도록.</target>
        </trans-unit>
        <trans-unit id="a5ab2cc1bedb015893a0e569086c7a7d272f8381" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;qdrag#setMimeData&quot;&gt;setMimeData&lt;/a&gt;() assigns ownership of the &lt;a href=&quot;qmimedata&quot;&gt;QMimeData&lt;/a&gt; object to the QDrag object. The QDrag must be constructed on the heap with a parent &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; to ensure that Qt can clean up after the drag and drop operation has been completed.</source>
          <target state="translated">참고 &lt;a href=&quot;qdrag#setMimeData&quot;&gt;setMimeData&lt;/a&gt; 의 () 양수인의 소유권 &lt;a href=&quot;qmimedata&quot;&gt;QMimeData의&lt;/a&gt; QDrag 객체에 객체입니다. 드래그 앤 드롭 작업이 완료된 후 Qt가 정리할 수 있도록 부모 &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 를 사용 하여 힙에 QDrag를 구성해야합니다 .</target>
        </trans-unit>
        <trans-unit id="cdc428490fe635ea01799f32fec1b3776fcb4bc8" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;qfuture#result&quot;&gt;QFuture::result&lt;/a&gt;() is a blocking call, it waits for the result to become available. Use &lt;a href=&quot;qfuturewatcher&quot;&gt;QFutureWatcher&lt;/a&gt; to get a notification when the task has finished execution and the result is available.</source>
          <target state="translated">참고 &lt;a href=&quot;qfuture#result&quot;&gt;QFuture :: 결과는&lt;/a&gt; 결과가 사용할 수있게하는 () 차단 호출입니다, 그것은 기다립니다. &lt;a href=&quot;qfuturewatcher&quot;&gt;QFutureWatcher&lt;/a&gt; 를 사용 하여 작업 실행이 완료되고 결과를 사용할 수있을 때 알림을받습니다.</target>
        </trans-unit>
        <trans-unit id="a5adc6ccbaabdc9e07b310f22a81a308f7946bd1" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; has no visual appearance of its own; it only manages the items. You need to create a &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; widget to visualize the scene.</source>
          <target state="translated">참고 &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene는&lt;/a&gt; 자신의 시각적 외관이 없습니다; 항목 만 관리합니다. 장면을 시각화하려면 &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; 위젯 을 작성해야합니다 .</target>
        </trans-unit>
        <trans-unit id="86243ea5c2f4d1f7f91240687db5414e0045d3a1" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;qgraphicstextitem&quot;&gt;QGraphicsTextItem&lt;/a&gt; keeps a &lt;a href=&quot;qtextdocument&quot;&gt;QTextDocument&lt;/a&gt; internally, which is used to calculate the text width.</source>
          <target state="translated">참고 &lt;a href=&quot;qgraphicstextitem&quot;&gt;QGraphicsTextItem가&lt;/a&gt; 유지 &lt;a href=&quot;qtextdocument&quot;&gt;QTextDocument을&lt;/a&gt; 텍스트 폭을 계산하는 데 사용되는, 내부적으로.</target>
        </trans-unit>
        <trans-unit id="9d1654e3b6bd820612e41913f0754b999bb9eed0" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; currently supports background caching only (see &lt;a href=&quot;qgraphicsview#CacheModeFlag-enum&quot;&gt;QGraphicsView::CacheBackground&lt;/a&gt;). This function is equivalent to calling &lt;a href=&quot;qgraphicsscene#update&quot;&gt;update&lt;/a&gt;() if any layer but &lt;a href=&quot;qgraphicsscene#SceneLayer-enum&quot;&gt;BackgroundLayer&lt;/a&gt; is passed.</source>
          <target state="translated">주의 &lt;a href=&quot;qgraphicsview&quot;&gt;를 QGraphicsView가&lt;/a&gt; 현재는 배경 캐싱을 지원한다 (참조 &lt;a href=&quot;qgraphicsview#CacheModeFlag-enum&quot;&gt;를 QGraphicsView :: CacheBackground을&lt;/a&gt; ). 이 함수는 &lt;a href=&quot;qgraphicsscene#SceneLayer-enum&quot;&gt;BackgroundLayer&lt;/a&gt; 이외의 레이어 가 전달 된 경우 &lt;a href=&quot;qgraphicsscene#update&quot;&gt;update&lt;/a&gt; () 를 호출하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="603ca9427a566e53d85505314ccc6c860ead5030" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; currently supports background caching only (see &lt;a href=&quot;qgraphicsview#CacheModeFlag-enum&quot;&gt;QGraphicsView::CacheBackground&lt;/a&gt;). This function is equivalent to calling &lt;a href=&quot;qwidget#update&quot;&gt;update&lt;/a&gt;() if any layer but &lt;a href=&quot;qgraphicsscene#SceneLayer-enum&quot;&gt;QGraphicsScene::BackgroundLayer&lt;/a&gt; is passed.</source>
          <target state="translated">주의 &lt;a href=&quot;qgraphicsview&quot;&gt;를 QGraphicsView가&lt;/a&gt; 현재는 배경 캐싱을 지원한다 (참조 &lt;a href=&quot;qgraphicsview#CacheModeFlag-enum&quot;&gt;를 QGraphicsView :: CacheBackground을&lt;/a&gt; ). 이 함수는 &lt;a href=&quot;qgraphicsscene#SceneLayer-enum&quot;&gt;QGraphicsScene :: BackgroundLayer를&lt;/a&gt; 제외한 모든 레이어 가 전달 되면 &lt;a href=&quot;qwidget#update&quot;&gt;update&lt;/a&gt; () 를 호출하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="2b76c78b141e2ed8e8e803aa5356e7c411a6757e" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt; uses &lt;a href=&quot;implicit-sharing&quot;&gt;implicit data sharing&lt;/a&gt;, but this function does</source>
          <target state="translated">참고 것을 &lt;a href=&quot;qimage&quot;&gt;QImage는&lt;/a&gt; 사용 &lt;a href=&quot;implicit-sharing&quot;&gt;암시 적 데이터를 공유&lt;/a&gt; 하지만,이 기능을 수행합니다</target>
        </trans-unit>
        <trans-unit id="c11122ee827cea6787a4f72c0273362dcd876144" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt; uses &lt;a href=&quot;implicit-sharing&quot;&gt;implicit data sharing&lt;/a&gt;. This function performs a deep copy of the shared pixel data, thus ensuring that this &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt; is the only one using the current return value.</source>
          <target state="translated">참고 &lt;a href=&quot;qimage&quot;&gt;QImage가&lt;/a&gt; 사용하는 &lt;a href=&quot;implicit-sharing&quot;&gt;암시 적 데이터 공유를&lt;/a&gt; . 이 함수는 공유 픽셀 데이터의 딥 카피를 수행 &lt;a href=&quot;qimage&quot;&gt;하므로이 QImage&lt;/a&gt; 가 현재 반환 값을 사용하는 유일한 것입니다.</target>
        </trans-unit>
        <trans-unit id="7046dacd9d7f26f3b8a09121e6a1f869ebcdcc10" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;qjsvalueiterator&quot;&gt;QJSValueIterator&lt;/a&gt; only iterates over the &lt;a href=&quot;qjsvalue&quot;&gt;QJSValue&lt;/a&gt;'s own properties; i.e. it does not follow the prototype chain. You can use a loop like this to follow the prototype chain:</source>
          <target state="translated">참고 &lt;a href=&quot;qjsvalueiterator&quot;&gt;QJSValueIterator은&lt;/a&gt; 단지 반복 할 &lt;a href=&quot;qjsvalue&quot;&gt;QJSValue&lt;/a&gt; 의 자신의 특성; 즉, 프로토 타입 체인을 따르지 않습니다. 다음과 같은 루프를 사용하여 프로토 타입 체인을 따를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="def7c9812aa10f0017764277681b342cb59ef9c0" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;qkeyevent&quot;&gt;QKeyEvent&lt;/a&gt; starts with isAccepted() == true, so you do not need to call &lt;a href=&quot;qevent#accept&quot;&gt;QKeyEvent::accept&lt;/a&gt;() - just do not call the base class implementation if you act upon the key.</source>
          <target state="translated">참고 &lt;a href=&quot;qkeyevent&quot;&gt;QKeyEvent가&lt;/a&gt; 전화 할 필요가 없습니다, () == 사실 isAccepted 시작 &lt;a href=&quot;qevent#accept&quot;&gt;QKeyEvent이 : 동의&lt;/a&gt; 당신은 키에 따라 행동한다면 단지 기본 클래스 구현을 호출하지 않습니다 - ().</target>
        </trans-unit>
        <trans-unit id="3ae9933f28a68b82b83d2b8371342bc806c2ec90" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;qlabel&quot;&gt;QLabel&lt;/a&gt; is well-suited to display small rich text documents, such as small documents that get their document specific settings (font, text color, link color) from the label's palette and font properties. For large documents, use &lt;a href=&quot;qtextedit&quot;&gt;QTextEdit&lt;/a&gt; in read-only mode instead. &lt;a href=&quot;qtextedit&quot;&gt;QTextEdit&lt;/a&gt; can also provide a scroll bar when necessary.</source>
          <target state="translated">참고 &lt;a href=&quot;qlabel&quot;&gt;QLabel이&lt;/a&gt; 같은 자신의 문서의 특정 설정 (글꼴, 텍스트 색상, 링크 색상) 레이블의 팔레트 및 글꼴 속성에서 얻을 작은 문서 작은 리치 텍스트 문서를 표시하는 데 적합하다. 큰 문서의 경우 &lt;a href=&quot;qtextedit&quot;&gt;QTextEdit&lt;/a&gt; 을 읽기 전용 모드로 대신 사용하십시오. &lt;a href=&quot;qtextedit&quot;&gt;QTextEdit&lt;/a&gt; 은 필요할 때 스크롤 막대를 제공 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="368f567dca31b26ef7798f89c23de9aa24e60ea9" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt; uses 0-based indexes, just like C++ arrays. Negative indexes are not supported with the exception of the value mentioned above.</source>
          <target state="translated">참고 것을 &lt;a href=&quot;qlist&quot;&gt;QList은&lt;/a&gt; 단지 C ++ 배열과 같은 0 기반 인덱스를 사용합니다. 위에서 언급 한 값을 제외하고 음수 인덱스는 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="77f39a579a77378a4bdfabd2686075145245f760" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;qlockfile#tryLock&quot;&gt;tryLock&lt;/a&gt;() automatically deleted the file if there is no running application with this PID, so &lt;a href=&quot;qlockfile#LockError-enum&quot;&gt;LockFailedError&lt;/a&gt; can only happen if there is an application with this PID (it could be unrelated though).</source>
          <target state="translated">참고 &lt;a href=&quot;qlockfile#tryLock&quot;&gt;설정된 tryLock가&lt;/a&gt; 이 PID 아무런 실행중인 응용 프로그램이없는 경우, 그래서 () 자동으로 파일을 삭제 &lt;a href=&quot;qlockfile#LockError-enum&quot;&gt;LockFailedError가&lt;/a&gt; 이 PID를 사용하여 응용 프로그램이있는 경우에만 발생할 수 있습니다 (이것은 관련이없는 생각 될 수있다).</target>
        </trans-unit>
        <trans-unit id="9808fbc78b15d8973285a87ef11b6a5c37ce11bd" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;qmacnativewidget&quot;&gt;QMacNativeWidget&lt;/a&gt; requires knowledge of Cocoa. All it does is get the Qt hierarchy into a window not owned by Qt. It is then up to the programmer to ensure it is placed correctly in the window and responds correctly to events.</source>
          <target state="translated">참고 &lt;a href=&quot;qmacnativewidget&quot;&gt;QMacNativeWidget은&lt;/a&gt; 코코아의 지식이 필요합니다. Qt 계층 구조를 Qt가 소유하지 않은 창으로 가져 오기만하면됩니다. 그러면 창에 올바르게 배치되고 이벤트에 올바르게 응답하는지 확인하는 것은 프로그래머에게 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f44dab8449936746fcfdb72d394a1f684c24c4c" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;qml-qtquick-numberanimation&quot;&gt;NumberAnimation&lt;/a&gt; may not animate smoothly if there are irregular changes in the number value that it is tracking. If this is the case, use &lt;a href=&quot;qml-qtquick-smoothedanimation&quot;&gt;SmoothedAnimation&lt;/a&gt; instead.</source>
          <target state="translated">참고 &lt;a href=&quot;qml-qtquick-numberanimation&quot;&gt;NumberAnimation&lt;/a&gt; 하지 애니메이션 원활이 추적하고있는 숫자 값의 불규칙적 인 변화가있을 경우에 할 수있다. 이 경우 대신 &lt;a href=&quot;qml-qtquick-smoothedanimation&quot;&gt;SmoothedAnimation을&lt;/a&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="5ac02058d2a5cb6e6da39bb59bcf6f0dd036f75d" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt; expects a standard conformant implementation of resource sharing when it comes to the underlying graphics drivers. For example, some drivers, in particular for mobile and embedded hardware, have issues with setting up sharing between an existing context and others that are created later. Some other drivers may behave in unexpected ways when trying to utilize shared resources between different threads.</source>
          <target state="translated">참고 &lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget는&lt;/a&gt; 이 기본 그래픽 드라이버에 관해서 자원 공유의 표준 준수 구현을 기대하고있다. 예를 들어 일부 드라이버, 특히 모바일 및 임베디드 하드웨어의 경우 기존 컨텍스트와 나중에 생성되는 다른 컨텍스트간에 공유를 설정하는 데 문제가 있습니다. 다른 스레드간에 공유 리소스를 사용하려고 할 때 일부 다른 드라이버가 예기치 않은 방식으로 작동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f05a95f7a6d8dcb3b6d106c49597f8074ab9980a" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;qremoteobjectnode#acquire&quot;&gt;acquire()&lt;/a&gt; returns a pointer to the replica. However, it does not manage the pointer lifetime. This example uses the recommended process of wrapping the returned pointer in a &lt;a href=&quot;qsharedpointer&quot;&gt;QSharedPointer&lt;/a&gt; or &lt;a href=&quot;qscopedpointer&quot;&gt;QScopedPointer&lt;/a&gt; to ensure the pointer is properly deleted.</source>
          <target state="translated">그 주 &lt;a href=&quot;qremoteobjectnode#acquire&quot;&gt;() 취득을&lt;/a&gt; 복제에 대한 포인터를 반환한다. 그러나 포인터 수명은 관리하지 않습니다. 이 예에서는 반환 된 포인터를 &lt;a href=&quot;qsharedpointer&quot;&gt;QSharedPointer&lt;/a&gt; 또는 &lt;a href=&quot;qscopedpointer&quot;&gt;QScopedPointer&lt;/a&gt; 에 래핑하는 권장 프로세스 를 사용하여 포인터가 올바르게 삭제되도록합니다.</target>
        </trans-unit>
        <trans-unit id="eea61f71792f146e0b1526ff0917351d790205b9" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;qsensorreading&quot;&gt;QSensorReading&lt;/a&gt; is not particularly useful by itself. The interesting data for each sensor is defined in a sub-class of &lt;a href=&quot;qsensorreading&quot;&gt;QSensorReading&lt;/a&gt;.</source>
          <target state="translated">참고 &lt;a href=&quot;qsensorreading&quot;&gt;QSensorReading은&lt;/a&gt; 그 자체로 특히 유용하지 않습니다. 각 센서에 대한 흥미로운 데이터는 &lt;a href=&quot;qsensorreading&quot;&gt;QSensorReading&lt;/a&gt; 의 하위 클래스에 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="01568234e1fbad976c23a680e0ad6a9d79205ccd" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;qsettings#sync&quot;&gt;sync&lt;/a&gt;() imports changes made by other processes (in addition to writing the changes from this &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt;).</source>
          <target state="translated">참고 &lt;a href=&quot;qsettings#sync&quot;&gt;동기화&lt;/a&gt; (이 기록의 변경에 부가하여 다른 프로세스에 의해 () 수입 변화 &lt;a href=&quot;qsettings&quot;&gt;QSettings을&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="aba171d635321acc15a8e116f339e90da38c1267" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;qsettings#sync&quot;&gt;sync&lt;/a&gt;() imports changes made by other processes (in addition to writing the changes from this QSettings).</source>
          <target state="translated">참고 &lt;a href=&quot;qsettings#sync&quot;&gt;동기화&lt;/a&gt; (이 QSettings의 변화를 작성 이외에) 다른 프로세스에 의해 () 수입 변한다.</target>
        </trans-unit>
        <trans-unit id="e8b8113db50f572d9dc54559a37ae8d25b04cf34" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;qstatusbar&quot;&gt;QStatusBar&lt;/a&gt; already uses this widget, so if you have a status bar (e.g., you are using &lt;a href=&quot;qmainwindow&quot;&gt;QMainWindow&lt;/a&gt;), then you don't need to use this widget explicitly. The same goes for &lt;a href=&quot;qdialog&quot;&gt;QDialog&lt;/a&gt;, for which you can just call &lt;a href=&quot;qdialog#sizeGripEnabled-prop&quot;&gt;QDialog::setSizeGripEnabled()&lt;/a&gt;.</source>
          <target state="translated">참고 &lt;a href=&quot;qstatusbar&quot;&gt;QStatusBar가&lt;/a&gt; 이미이 상태 표시 줄 (예를 들어, 당신이 사용하고있는 그렇다면,이 위젯을 사용 &lt;a href=&quot;qmainwindow&quot;&gt;QMainWindow는&lt;/a&gt; ) 다음 위젯 명시 적으로이를 사용할 필요가 없습니다. 동일은 간다 &lt;a href=&quot;qdialog&quot;&gt;인 QDialog&lt;/a&gt; ,하는 당신은 그냥 호출 할 수 있습니다 &lt;a href=&quot;qdialog#sizeGripEnabled-prop&quot;&gt;인 QDialog :: setSizeGripEnabled ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e32d4052b402192b0bbc56d313b24e224eb18676" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;qstorageinfo#fileSystemType&quot;&gt;fileSystemType&lt;/a&gt;(), &lt;a href=&quot;qstorageinfo#name&quot;&gt;name&lt;/a&gt;(), &lt;a href=&quot;qstorageinfo#bytesTotal&quot;&gt;bytesTotal&lt;/a&gt;(), &lt;a href=&quot;qstorageinfo#bytesFree&quot;&gt;bytesFree&lt;/a&gt;(), and &lt;a href=&quot;qstorageinfo#bytesAvailable&quot;&gt;bytesAvailable&lt;/a&gt;() will return invalid data until the volume is ready.</source>
          <target state="translated">참고 &lt;a href=&quot;qstorageinfo#fileSystemType&quot;&gt;fileSystemType&lt;/a&gt; (), &lt;a href=&quot;qstorageinfo#name&quot;&gt;이름&lt;/a&gt; (), &lt;a href=&quot;qstorageinfo#bytesTotal&quot;&gt;bytesTotal이라는&lt;/a&gt; (), &lt;a href=&quot;qstorageinfo#bytesFree&quot;&gt;bytesFree&lt;/a&gt; () 및 &lt;a href=&quot;qstorageinfo#bytesAvailable&quot;&gt;됨 bytesAvailable&lt;/a&gt; () 볼륨이 준비가 될 때까지 유효하지 않은 데이터를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="13e44de3a15f99ed5e6ab5c45efb067e59ab7397" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;qthreadpool&quot;&gt;QThreadPool&lt;/a&gt; is a low-level class for managing threads, see the Qt Concurrent module for higher level alternatives.</source>
          <target state="translated">참고 것을 &lt;a href=&quot;qthreadpool&quot;&gt;QThreadPool가&lt;/a&gt; 스레드를 관리하기위한 낮은 수준의 클래스이며, 높은 수준의 대안을 Qt의 동시 모듈을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f7ae6afdce1a09ef8640e7890d29beadbbc60b34" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;qtimer&quot;&gt;QTimer&lt;/a&gt;'s accuracy depends on the underlying operating system and hardware. The</source>
          <target state="translated">참고 &lt;a href=&quot;qtimer&quot;&gt;QTimer&lt;/a&gt; 의 정확성은 기본 운영 체제 및 하드웨어에 따라 달라집니다. 그만큼</target>
        </trans-unit>
        <trans-unit id="8af2d579def40907b72f15358ae69a4874cc07f4" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;qurl#ComponentFormattingOption-enum&quot;&gt;QUrl::FullyDecoded&lt;/a&gt; may cause data loss if those non-representable sequences are present. It is recommended to use that value when the result will be used in a non-URL context, such as sending to an FTP server.</source>
          <target state="translated">참고 &lt;a href=&quot;qurl#ComponentFormattingOption-enum&quot;&gt;QUrl :: FullyDecoded는&lt;/a&gt; 그 비 표현할 서열이 존재하는 경우 데이터가 손실 될 수있다. 결과가 FTP 서버로 전송과 같은 비 URL 컨텍스트에서 사용될 경우이 값을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="73ff03aa05dc2cd5491aa46f27c722638ef5f927" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;qurl#ComponentFormattingOption-enum&quot;&gt;QUrl::FullyDecoded&lt;/a&gt; may cause data loss if those non-representable sequences are present. It is recommended to use that value when the result will be used in a non-URL context, such as setting in &lt;a href=&quot;qauthenticator&quot;&gt;QAuthenticator&lt;/a&gt; or negotiating a login.</source>
          <target state="translated">참고 &lt;a href=&quot;qurl#ComponentFormattingOption-enum&quot;&gt; QUrl :: FullyDecoded는&lt;/a&gt; 그 비 표현할 서열이 존재하는 경우 데이터가 손실 될 수있다. &lt;a href=&quot;qauthenticator&quot;&gt;QAuthenticator&lt;/a&gt; 설정 또는 로그인 협상 과 같이 URL 이외의 컨텍스트에서 결과를 사용할 경우이 값을 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="a83c0390d5bc660a116f87bfe6f13e3b2d3ba7b1" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;qurl#ComponentFormattingOption-enum&quot;&gt;QUrl::FullyDecoded&lt;/a&gt; may cause data loss if those non-representable sequences are present. It is recommended to use that value when the result will be used in a non-URL context.</source>
          <target state="translated">참고 &lt;a href=&quot;qurl#ComponentFormattingOption-enum&quot;&gt; QUrl :: FullyDecoded는&lt;/a&gt; 그 비 표현할 서열이 존재하는 경우 데이터가 손실 될 수있다. URL이 아닌 컨텍스트에서 결과가 사용될 때 해당 값을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="b29bacb16e32df19b6b77f4512b984fafca759f0" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;qwidget#event&quot;&gt;QWidget::event&lt;/a&gt;() is still called for all of the cases not handled, and that the return value indicates whether an event was dealt with; a &lt;code&gt;true&lt;/code&gt; value prevents the event from being sent on to other objects.</source>
          <target state="translated">참고 &lt;a href=&quot;qwidget#event&quot;&gt;는 QWidget :: 이벤트&lt;/a&gt; () 아직도 처리되는 모든 경우에 대해 호출하고, 반환 값은 이벤트가 처리되었는지 여부를 나타내는 것을; &lt;code&gt;true&lt;/code&gt; 값은 다른 개체에 전송되는 이벤트를 방지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa776dc890a079efeac9b44ee8914debf04d753c" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;qxmlname&quot;&gt;QXmlName&lt;/a&gt;'s default constructor constructs a null instance. It is typically used for allocating unused entries in collections of &lt;a href=&quot;qxmlname&quot;&gt;QXmlName&lt;/a&gt;.</source>
          <target state="translated">참고 &lt;a href=&quot;qxmlname&quot;&gt;QXmlName을&lt;/a&gt; 의 기본 생성자는 널 (null) 인스턴스를 구축합니다. 일반적으로 &lt;a href=&quot;qxmlname&quot;&gt;QXmlName&lt;/a&gt; 콜렉션에 사용되지 않은 항목을 할당하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="f8dad27f3d2cb0fd4c5e02be9e64cf9b6c042ccf" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;C:\interbase\bin&lt;/code&gt; must be in the &lt;code&gt;PATH&lt;/code&gt;.</source>
          <target state="translated">참고 &lt;code&gt;C:\interbase\bin&lt;/code&gt; 에 있어야합니다 &lt;code&gt;PATH&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6c04a10b1920f4a1282bcbfa24f33118ae0f4ab4" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;PE_FrameButtonTool&lt;/code&gt; and &lt;code&gt;PE_IndicatorArrowDown&lt;/code&gt; are included in the tree as the Java style draws them, but they can safely be omitted if you prefer it. The structure may also be different. &lt;a href=&quot;qcommonstyle&quot;&gt;QCommonStyle&lt;/a&gt;, for instance, draws both &lt;code&gt;PE_IndicatorButtonDropDown&lt;/code&gt; and &lt;code&gt;PE_IndicatorArrowDown&lt;/code&gt; in &lt;code&gt;CE_ToolButton&lt;/code&gt;.</source>
          <target state="translated">참고 &lt;code&gt;PE_FrameButtonTool&lt;/code&gt; 및 &lt;code&gt;PE_IndicatorArrowDown&lt;/code&gt; 는 자바 스타일을 그립니다 트리에 포함되어 있지만, 당신이 그것을 원하는 경우 그들이 안전하게 생략 할 수 있습니다. 구조도 다를 수 있습니다. &lt;a href=&quot;qcommonstyle&quot;&gt;QCommonStyle는&lt;/a&gt; , 예를 들어, 모두 그립니다 &lt;code&gt;PE_IndicatorButtonDropDown&lt;/code&gt; 및 &lt;code&gt;PE_IndicatorArrowDown&lt;/code&gt; 을 에 &lt;code&gt;CE_ToolButton&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="11afda57476cfc78973ae82e37c283a6c87e6782" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;VARYING&lt;/code&gt; declarations. The name and type must match, &lt;code&gt;uv&lt;/code&gt; in the fragment shader will expose the interpolated UV coordinate for the current fragment.</source>
          <target state="translated">&lt;code&gt;VARYING&lt;/code&gt; 선언에 유의하십시오 . 이름과 유형이 일치해야합니다 . 조각 셰이더의 &lt;code&gt;uv&lt;/code&gt; 는 현재 조각에 대한 보간 된 UV 좌표를 노출합니다.</target>
        </trans-unit>
        <trans-unit id="35ae86ee6466e131b71f30dd2f5eb239b213a6d0" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;WalltimeNanoseconds&lt;/code&gt; and &lt;code&gt;BytesAllocated&lt;/code&gt; are only provided for use via &lt;a href=&quot;qtest#setBenchmarkResult&quot;&gt;setBenchmarkResult&lt;/a&gt;(), and results in those metrics are not able to be provided automatically by the &lt;a href=&quot;qtest&quot;&gt;QTest&lt;/a&gt; framework.</source>
          <target state="translated">참고 &lt;code&gt;WalltimeNanoseconds&lt;/code&gt; 및 &lt;code&gt;BytesAllocated&lt;/code&gt; 이 단지를 통해 사용하기 위해 제공되는 &lt;a href=&quot;qtest#setBenchmarkResult&quot;&gt;setBenchmarkResult&lt;/a&gt; (), 그 측정 결과가 자동으로 제공 될 수 없습니다&lt;a href=&quot;qtest&quot;&gt; QTEST&lt;/a&gt; 프레임 워크.</target>
        </trans-unit>
        <trans-unit id="4a82b50510c508687b53c6253a664f503012e37e" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;X&lt;/code&gt; must have the same cv-qualifiers (&lt;code&gt;const&lt;/code&gt; and &lt;code&gt;volatile&lt;/code&gt;) that &lt;code&gt;T&lt;/code&gt; has, or the code will fail to compile. Use &lt;a href=&quot;qsharedpointer#qSharedPointerConstCast&quot;&gt;qSharedPointerConstCast&lt;/a&gt; to cast away the constness.</source>
          <target state="translated">참고 &lt;code&gt;X&lt;/code&gt; 는 같은 이력서 - 예선 (가 있어야 &lt;code&gt;const&lt;/code&gt; 및 &lt;code&gt;volatile&lt;/code&gt; 것을) &lt;code&gt;T&lt;/code&gt; 가 있다, 또는 코드가 컴파일에 실패합니다. 사용하다&lt;a href=&quot;qsharedpointer#qSharedPointerConstCast&quot;&gt;qSharedPointerConstCast&lt;/a&gt; 를 constness 를 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="166d97a68f8e6c844f9d79b5007a1faabc70973c" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;X&lt;/code&gt; must have the same cv-qualifiers (&lt;code&gt;const&lt;/code&gt; and &lt;code&gt;volatile&lt;/code&gt;) that &lt;code&gt;T&lt;/code&gt; has, or the code will fail to compile. Use const_pointer_cast to cast away the constness.</source>
          <target state="translated">참고 &lt;code&gt;X&lt;/code&gt; 는 같은 이력서 - 예선 (가 있어야 &lt;code&gt;const&lt;/code&gt; 및 &lt;code&gt;volatile&lt;/code&gt; 것을) &lt;code&gt;T&lt;/code&gt; 가 있다, 또는 코드가 컴파일에 실패합니다. const_pointer_cast를 사용하여 constness를 버리십시오.</target>
        </trans-unit>
        <trans-unit id="a0851ce87e24b9d912135926ad4cb459371064e3" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;clip&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; by default which means that the item might paint outside its bounding rectangle even if the fillMode is set to &lt;code&gt;PreserveAspectCrop&lt;/code&gt;.</source>
          <target state="translated">하는 것으로 &lt;code&gt;clip&lt;/code&gt; 입니다 &lt;code&gt;false&lt;/code&gt; 기본적으로 어떤 항목이 FILLMODE로 설정되는 경우에도 외부의 경계 사각형을 그릴 수 있음을 의미합니다 &lt;code&gt;PreserveAspectCrop&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="e176023dba0b41547930d1b84d688d1932d3b56f" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;display()&lt;/code&gt; is overloaded; Qt will select the appropriate version when you connect a signal to the slot. With callbacks, you'd have to find five different names and keep track of the types yourself.</source>
          <target state="translated">참고 &lt;code&gt;display()&lt;/code&gt; 가 오버로드됨에 . Qt는 신호를 슬롯에 연결할 때 적절한 버전을 선택합니다. 콜백을 사용하면 5 개의 다른 이름을 찾아서 직접 유형을 추적해야합니다.</target>
        </trans-unit>
        <trans-unit id="50cdf05965bfbcde32786c0bec9f1b8dabfa4034" translate="yes" xml:space="preserve">
          <source>Note that Attractor has the standard Item x,y,width and height properties. Like other affectors, these represent the affected area. They do not represent the 0x0 point which is the target of the attraction.</source>
          <target state="translated">Attractor에는 표준 Item x, y, width 및 height 속성이 있습니다. 다른 영향 요인과 마찬가지로 영향을받는 영역을 나타냅니다. 그들은 매력의 대상인 0x0 지점을 나타내지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d6ba0bc586df480f92f39a4e094bf9eae63c757d" translate="yes" xml:space="preserve">
          <source>Note that CBOR maps are unordered, which means that two maps containing the very same pairs but in different order will still compare differently. To avoid this, it is recommended to insert elements into the map in a predictable order, such as by ascending key value. In fact, maps with keys in sorted order are required for Canonical CBOR representation.</source>
          <target state="translated">CBOR 맵은 순서가 정렬되지 않았으므로 매우 동일한 쌍을 포함하지만 순서가 다른 두 맵은 여전히 ​​다르게 비교됩니다. 이를 피하려면 오름차순 키 값과 같이 예측 가능한 순서로 요소를 맵에 삽입하는 것이 좋습니다. 실제로, 정식 CBOR 표시에는 키가 정렬 된 맵이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="24c53f9788fb2700b09fb9edd4dc6433cc60b806" translate="yes" xml:space="preserve">
          <source>Note that IPv6 unique local unicast addresses are considered global addresses (see &lt;a href=&quot;qhostaddress#isUniqueLocalUnicast&quot;&gt;isUniqueLocalUnicast&lt;/a&gt;()), as are IPv4 addresses reserved for local networks by &lt;a href=&quot;https://tools.ietf.org/html/rfc1918&quot;&gt;RFC 1918&lt;/a&gt;.</source>
          <target state="translated">IPv6 고유 로컬 유니 캐스트 주소는 로컬 주소로 예약 된 IPv4 주소와 마찬가지로 전역 주소로 간주됩니다 ( &lt;a href=&quot;qhostaddress#isUniqueLocalUnicast&quot;&gt;isUniqueLocalUnicast&lt;/a&gt; () 참조 ).&lt;a href=&quot;https://tools.ietf.org/html/rfc1918&quot;&gt; RFC 1918에&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="38e413f39be2ca90e211925257d46b26f122d5bc" translate="yes" xml:space="preserve">
          <source>Note that InterBase requires you to specify the full path to the database file, no matter whether it is stored locally or on another server.</source>
          <target state="translated">InterBase에서는 데이터베이스 파일이 로컬로 저장되어 있는지 또는 다른 서버에 저장되어 있는지에 관계없이 데이터베이스 파일의 전체 경로를 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="5ebe4ee7293ae9a7b4e5c26a141696ffd1d51f72" translate="yes" xml:space="preserve">
          <source>Note that JavaScript is slower to execute, so it is not recommended to use this in high-volume particle systems.</source>
          <target state="translated">JavaScript는 실행 속도가 느리므로 대량 파티클 시스템에서는 사용하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="28f0e5a005061656c49f4b3dd754d8f6bf748b49" translate="yes" xml:space="preserve">
          <source>Note that LightLevel constants are exposed through the &lt;a href=&quot;qml-qtsensors-ambientlightreading&quot;&gt;AmbientLightReading&lt;/a&gt; class.</source>
          <target state="translated">LightLevel 상수는 &lt;a href=&quot;qml-qtsensors-ambientlightreading&quot;&gt;AmbientLightReading&lt;/a&gt; 클래스를 통해 노출됩니다 .</target>
        </trans-unit>
        <trans-unit id="944bb498c75fa41b9be05ccc4984febb7fd6afca" translate="yes" xml:space="preserve">
          <source>Note that Mac flavors must all be self-terminating. The input</source>
          <target state="translated">Mac 플레이버는 모두 자동 종료되어야합니다. 입력</target>
        </trans-unit>
        <trans-unit id="d4d3bf9d2e87d0a555824f6713467240ac6ccd79" translate="yes" xml:space="preserve">
          <source>Note that Mac flavors must all be self-terminating. The return value may contain trailing data.</source>
          <target state="translated">Mac 플레이버는 모두 자동 종료되어야합니다. 반환 값은 후행 데이터를 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ce969f04c00df5fb964a540c125a9baf641c17b" translate="yes" xml:space="preserve">
          <source>Note that NumberAnimation may not animate smoothly if there are irregular changes in the number value that it is tracking. If this is the case, use &lt;a href=&quot;qml-qtquick-smoothedanimation&quot;&gt;SmoothedAnimation&lt;/a&gt; instead.</source>
          <target state="translated">NumberAnimation은 추적중인 숫자 값에 불규칙한 변화가있는 경우 매끄럽게 애니메이션되지 않을 수 있습니다. 이 경우 대신 &lt;a href=&quot;qml-qtquick-smoothedanimation&quot;&gt;SmoothedAnimation을&lt;/a&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="3ed44264030a6c5caacd07abdd8eeb798a1da0dd" translate="yes" xml:space="preserve">
          <source>Note that OpenGL does not permit nesting or interleaving of multiple timer queries using &lt;a href=&quot;qopengltimerquery#begin&quot;&gt;begin&lt;/a&gt;() and &lt;a href=&quot;qopengltimerquery#end&quot;&gt;end&lt;/a&gt;(). Using multiple timer queries and &lt;a href=&quot;qopengltimerquery#recordTimestamp&quot;&gt;recordTimestamp&lt;/a&gt;() avoids this limitation. When using &lt;a href=&quot;qopengltimerquery#recordTimestamp&quot;&gt;recordTimestamp&lt;/a&gt;() the result can be obtained at some later time using &lt;a href=&quot;qopengltimerquery#isResultAvailable&quot;&gt;isResultAvailable&lt;/a&gt;() and &lt;a href=&quot;qopengltimerquery#waitForResult&quot;&gt;waitForResult&lt;/a&gt;(). Qt provides the convenience class &lt;a href=&quot;qopengltimemonitor&quot;&gt;QOpenGLTimeMonitor&lt;/a&gt; that helps with using multiple query objects.</source>
          <target state="translated">OpenGL은 &lt;a href=&quot;qopengltimerquery#begin&quot;&gt;begin&lt;/a&gt; () 및 &lt;a href=&quot;qopengltimerquery#end&quot;&gt;end&lt;/a&gt; ()를 사용하여 여러 타이머 쿼리의 중첩 또는 인터리빙을 허용하지 않습니다 . 여러 타이머 쿼리와 &lt;a href=&quot;qopengltimerquery#recordTimestamp&quot;&gt;recordTimestamp&lt;/a&gt; ()를 사용하면이 제한이 방지됩니다. &lt;a href=&quot;qopengltimerquery#recordTimestamp&quot;&gt;recordTimestamp&lt;/a&gt; ()를 사용할 때 &lt;a href=&quot;qopengltimerquery#isResultAvailable&quot;&gt;isResultAvailable&lt;/a&gt; () 및 &lt;a href=&quot;qopengltimerquery#waitForResult&quot;&gt;waitForResult&lt;/a&gt; ()를 사용하여 나중에 결과를 얻을 수 있습니다 . Qt는 여러 쿼리 개체를 사용하는 데 도움이 되는 편리한 클래스 &lt;a href=&quot;qopengltimemonitor&quot;&gt;QOpenGLTimeMonitor&lt;/a&gt; 를 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="2bf1775b46a575bb867c5a4e97c6baf40986363c" translate="yes" xml:space="preserve">
          <source>Note that OpenGL implementations have a vendor-specific limit to the length of the messages that can be inserted in the debug log. You can retrieve this length by calling the &lt;a href=&quot;qopengldebuglogger#maximumMessageLength&quot;&gt;maximumMessageLength&lt;/a&gt;() method; messages longer than the limit will automatically get truncated.</source>
          <target state="translated">OpenGL 구현에는 디버그 로그에 삽입 할 수있는 메시지 길이에 대한 공급 업체별 제한이 있습니다. &lt;a href=&quot;qopengldebuglogger#maximumMessageLength&quot;&gt;maximumMessageLength&lt;/a&gt; 를 호출하여이 길이를 검색 할 수 있습니다. () 메소드를 . 한도보다 긴 메시지는 자동으로 잘립니다.</target>
        </trans-unit>
        <trans-unit id="8aa39909c5b7e998a2d783eb3efed1ac10b1bcbb" translate="yes" xml:space="preserve">
          <source>Note that Orientation constants are exposed through the &lt;a href=&quot;qml-qtsensors-orientationreading&quot;&gt;OrientationReading&lt;/a&gt; class.</source>
          <target state="translated">오리엔테이션 상수는 &lt;a href=&quot;qml-qtsensors-orientationreading&quot;&gt;OrientationReading&lt;/a&gt; 클래스를 통해 노출됩니다 .</target>
        </trans-unit>
        <trans-unit id="46ea5844abac20deb070be45eb48c336300e329b" translate="yes" xml:space="preserve">
          <source>Note that PropertyAnimation inherits the abstract &lt;a href=&quot;qml-qtquick-animation&quot;&gt;Animation&lt;/a&gt; type. This includes additional properties and methods for controlling the animation.</source>
          <target state="translated">PropertyAnimation은 추상 &lt;a href=&quot;qml-qtquick-animation&quot;&gt;애니메이션&lt;/a&gt; 유형을 상속합니다 . 여기에는 애니메이션을 제어하기위한 추가 속성 및 메서드가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="c78b3e24dd217891b05b84f07df0e203024c326a" translate="yes" xml:space="preserve">
          <source>Note that QAbstractListModel provides a default implementation of &lt;a href=&quot;qabstractitemmodel#columnCount&quot;&gt;columnCount&lt;/a&gt;() that informs views that there is only a single column of items in this model.</source>
          <target state="translated">QAbstractListModel 은이 모델에 항목의 단일 열만 있음을보기에 알리는 &lt;a href=&quot;qabstractitemmodel#columnCount&quot;&gt;columnCount&lt;/a&gt; () 의 기본 구현을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="098ae9e616241b931990925e16c3136cff3b16ac" translate="yes" xml:space="preserve">
          <source>Note that QDataWidgetMapper keeps track of external modifications. If the contents of the model are updated in another module of the application, the widgets are updated as well.</source>
          <target state="translated">QDataWidgetMapper는 외부 수정 사항을 추적합니다. 모델의 컨텐츠가 애플리케이션의 다른 모듈에서 업데이트되면 위젯도 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="cf46290ca42cd98b94e7f513d09a879626082bfe" translate="yes" xml:space="preserve">
          <source>Note that QDialog (and any other widget that has type &lt;code&gt;Qt::Dialog&lt;/code&gt;) uses the parent widget slightly differently from other classes in Qt. A dialog is always a top-level widget, but if it has a parent, its default location is centered on top of the parent's top-level widget (if it is not top-level itself). It will also share the parent's taskbar entry.</source>
          <target state="translated">QDialog (및 &lt;code&gt;Qt::Dialog&lt;/code&gt; 유형의 다른 위젯 )는 Qt의 다른 클래스와 약간 다르게 부모 위젯을 사용합니다. 대화 상자는 항상 최상위 수준의 위젯이지만 부모가있는 경우 기본 위치는 부모의 최상위 수준 위젯 (최상위 자체가 아닌 경우)의 맨 위에 있습니다. 또한 부모의 작업 표시 줄 항목을 공유합니다.</target>
        </trans-unit>
        <trans-unit id="616e8260661f37ec7e2c76b30a63c8ca4e6e0bfe" translate="yes" xml:space="preserve">
          <source>Note that QDomNamedNodeMap does not inherit from &lt;a href=&quot;qdomnodelist&quot;&gt;QDomNodeList&lt;/a&gt;. QDomNamedNodeMaps do not provide any specific node ordering. Although nodes in a QDomNamedNodeMap may be accessed by an ordinal index, this is simply to allow a convenient enumeration of the contents of a QDomNamedNodeMap, and does not imply that the DOM specifies an ordering of the nodes.</source>
          <target state="translated">QDomNamedNodeMap로부터 상속하지 않습니다 &lt;a href=&quot;qdomnodelist&quot;&gt;QDomNodeList&lt;/a&gt; . QDomNamedNodeMaps는 특정 노드 순서를 제공하지 않습니다. QDomNamedNodeMap의 노드는 서수 인덱스로 액세스 할 수 있지만 이는 단순히 QDomNamedNodeMap의 콘텐츠를 편리하게 열거 할 수 있도록하기위한 것이며 DOM이 노드의 순서를 지정한다는 것을 의미하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="a1cf5f5fc29f9d528608e912284d4edae5ff8e8f" translate="yes" xml:space="preserve">
          <source>Note that QGraphicsScene has no visual appearance of its own; it only manages the items. You need to create a &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; widget to visualize the scene.</source>
          <target state="translated">QGraphicsScene은 그 자체의 시각적 모양이 없습니다. 항목 만 관리합니다. 장면을 시각화하려면 &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; 위젯 을 만들어야합니다 .</target>
        </trans-unit>
        <trans-unit id="3fc2eed66992faeb7f00d39c37e33785002a0b73" translate="yes" xml:space="preserve">
          <source>Note that QJSValueIterator only iterates over the &lt;a href=&quot;qjsvalue&quot;&gt;QJSValue&lt;/a&gt;'s own properties; i.e. it does not follow the prototype chain. You can use a loop like this to follow the prototype chain:</source>
          <target state="translated">QJSValueIterator는 &lt;a href=&quot;qjsvalue&quot;&gt;QJSValue&lt;/a&gt; 자체 속성에 대해서만 반복 합니다. 즉, 프로토 타입 체인을 따르지 않습니다. 다음과 같은 루프를 사용하여 프로토 타입 체인을 따라갈 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="22f51f71cb417a6621bb8b37ff844c5e29ed92d7" translate="yes" xml:space="preserve">
          <source>Note that QML makes the following modifications to native objects:</source>
          <target state="translated">QML은 기본 객체를 다음과 같이 수정합니다.</target>
        </trans-unit>
        <trans-unit id="b35af5870c36e6bd7bde1e8e0e0f9383d544a1ea" translate="yes" xml:space="preserve">
          <source>Note that QMacNativeWidget requires knowledge of Cocoa. All it does is get the Qt hierarchy into a window not owned by Qt. It is then up to the programmer to ensure it is placed correctly in the window and responds correctly to events.</source>
          <target state="translated">QMacNativeWidget은 Cocoa에 대한 지식이 필요합니다. 그것이하는 일은 Qt가 소유하지 않은 창으로 Qt 계층 구조를 가져 오는 것뿐입니다. 그런 다음 창에 올바르게 배치되고 이벤트에 올바르게 응답하는지 확인하는 것은 프로그래머에게 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="43fd93e4e1672d3c2165838ecb4900ff0581c7a5" translate="yes" xml:space="preserve">
          <source>Note that QOpenGLWidget expects a standard conformant implementation of resource sharing when it comes to the underlying graphics drivers. For example, some drivers, in particular for mobile and embedded hardware, have issues with setting up sharing between an existing context and others that are created later. Some other drivers may behave in unexpected ways when trying to utilize shared resources between different threads.</source>
          <target state="translated">QOpenGLWidget은 기본 그래픽 드라이버와 관련하여 리소스 공유의 표준 준수 구현을 기대합니다. 예를 들어, 일부 드라이버, 특히 모바일 및 임베디드 하드웨어의 경우 기존 컨텍스트와 나중에 생성되는 다른 컨텍스트 간의 공유 설정에 문제가 있습니다. 일부 다른 드라이버는 서로 다른 스레드간에 공유 리소스를 사용하려고 할 때 예기치 않은 방식으로 작동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="94ec8a387d5af3e6a7f83ce83475eed7cc355a03" translate="yes" xml:space="preserve">
          <source>Note that QPixmaps are automatically added to the &lt;a href=&quot;qpixmapcache&quot;&gt;QPixmapCache&lt;/a&gt; when loaded from a file in main thread; the key used is internal and cannot be acquired.</source>
          <target state="translated">QPixmaps가 자동으로 추가됩니다 참고 &lt;a href=&quot;qpixmapcache&quot;&gt;QPixmapCache&lt;/a&gt; 메인 쓰레드에서 파일에서로드; 사용 된 키는 내부 용이며 취득 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="39188c34d46f31bc7ca01ea5de6426ef89a32c48" translate="yes" xml:space="preserve">
          <source>Note that QSensorReading is not particularly useful by itself. The interesting data for each sensor is defined in a sub-class of QSensorReading.</source>
          <target state="translated">QSensorReading은 그 자체로는 특별히 유용하지 않습니다. 각 센서에 대한 흥미로운 데이터는 QSensorReading의 하위 클래스에 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c2a86b0bf880b6e9c663b3d42c3169930a1a5a6a" translate="yes" xml:space="preserve">
          <source>Note that QThreadPool is a low-level class for managing threads, see the Qt Concurrent module for higher level alternatives.</source>
          <target state="translated">QThreadPool은 스레드 관리를위한 저수준 클래스입니다. 더 높은 수준의 대안은 Qt Concurrent 모듈을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0e80fef4fcb29cfdc1a870663ce541e5d74e73f0" translate="yes" xml:space="preserve">
          <source>Note that QXmlName's default constructor constructs a null instance. It is typically used for allocating unused entries in collections of QXmlName.</source>
          <target state="translated">QXmlName의 기본 생성자는 null 인스턴스를 생성합니다. 일반적으로 QXmlName 컬렉션에서 사용되지 않는 항목을 할당하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e363844033d14815da9138531ee9c9f810bfff15" translate="yes" xml:space="preserve">
          <source>Note that Qt 5 introduces a slight change in behavior when using &lt;a href=&quot;qpointer&quot;&gt;QPointer&lt;/a&gt;.</source>
          <target state="translated">Qt 5는 &lt;a href=&quot;qpointer&quot;&gt;QPointer를&lt;/a&gt; 사용할 때 약간의 동작 변화를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="328f1a5cae93d6a51d1fdfdcd04b83fe4d020481" translate="yes" xml:space="preserve">
          <source>Note that Qt 5 introduces a slight change in behavior when using QPointer.</source>
          <target state="translated">Qt 5에서는 QPointer를 사용할 때 동작이 약간 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="7f7c75b4500d4fdeee658a1d4c1ee551d95e74b1" translate="yes" xml:space="preserve">
          <source>Note that Qt destroys a plugin automatically when it is no longer used, so there is no need for calling the destructor explicitly.</source>
          <target state="translated">Qt는 더 이상 사용하지 않으면 자동으로 플러그인을 제거하므로 소멸자를 명시 적으로 호출 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="6619b661dacad31641d75c928a1bcc6062c24c49" translate="yes" xml:space="preserve">
          <source>Note that Remote Objects behave differently from traditional Remote Procedure Call (RPC) implementations, for example:</source>
          <target state="translated">원격 객체는 다음과 같은 기존 RPC (원격 프로 시저 호출) 구현과 다르게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="9095bdc1a55db23a29dd7cac21a0063648039f5b" translate="yes" xml:space="preserve">
          <source>Note that TapDirection constants are exposed through the &lt;a href=&quot;qml-qtsensors-tapreading&quot;&gt;TapReading&lt;/a&gt; class.</source>
          <target state="translated">TapDirection 상수는 &lt;a href=&quot;qml-qtsensors-tapreading&quot;&gt;TapReading&lt;/a&gt; 클래스를 통해 노출됩니다 .</target>
        </trans-unit>
        <trans-unit id="43e7efd6a053f711419f8700bdde9332fda54aef" translate="yes" xml:space="preserve">
          <source>Note that TolerantMode is not usually enough for parsing user input, which often contains more errors and expectations than the parser can deal with. When dealing with data coming directly from the user -- as opposed to data coming from data-transfer sources, such as other programs -- it is recommended to use &lt;a href=&quot;qurl#fromUserInput&quot;&gt;fromUserInput&lt;/a&gt;().</source>
          <target state="translated">TolerantMode는 일반적으로 사용자 입력을 구문 분석하기에 충분하지 않으며, 종종 구문 분석기가 처리 할 수있는 것보다 더 많은 오류와 기대치를 포함합니다. 다른 프로그램과 같은 데이터 전송 소스에서 오는 데이터와 달리 사용자가 직접 가져 오는 데이터를 처리 할 때는 &lt;a href=&quot;qurl#fromUserInput&quot;&gt;fromUserInput&lt;/a&gt; () 을 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="711c6627a8bc56274b1474eb1cf1a438551ac1ee" translate="yes" xml:space="preserve">
          <source>Note that Unique local unicast addresses count as global addresses too. RFC 4193 says that, in practice, &quot;applications may treat these addresses like global scoped addresses.&quot; Only routers need care about the distinction.</source>
          <target state="translated">고유 한 로컬 유니 캐스트 주소도 전역 주소로 계산됩니다. RFC 4193은 실제로 &quot;응용 프로그램은 이러한 주소를 전역 범위 주소처럼 취급 할 수 있습니다&quot;라고 말합니다. 라우터 만이 구별에주의를 기울여야합니다.</target>
        </trans-unit>
        <trans-unit id="2357db77093b1cf01f9677aaaaab3656dcbc3a45" translate="yes" xml:space="preserve">
          <source>Note that VerticalSortHint and HorizontalSortHint carry the meaning that items are being moved within the same parent, not moved to a different parent in the model, and not filtered out or in.</source>
          <target state="translated">VerticalSortHint 및 HorizontalSortHint는 항목이 동일한 상위 내에서 이동되고 모델의 다른 상위로 이동되지 않으며 필터링되거나 필터링되지 않음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="10a747acc5e6513f31b235b7daa7ebf4a8499512" translate="yes" xml:space="preserve">
          <source>Note that You must add the layout of</source>
          <target state="translated">레이아웃을 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="30caf1f81652b6b1880f503033405b98f421e0e7" translate="yes" xml:space="preserve">
          <source>Note that a &lt;a href=&quot;qcoreapplication&quot;&gt;QCoreApplication&lt;/a&gt; object must be instantiated before using any of these classes.</source>
          <target state="translated">&amp;bull; 그래도 참고 &lt;a href=&quot;qcoreapplication&quot;&gt;QCoreApplication의&lt;/a&gt; 목적은 이러한 클래스 중 하나를 사용하기 전에 인스턴스화해야합니다.</target>
        </trans-unit>
        <trans-unit id="6a8a30295003de80bc20eb6dee1199ef6dbd4937" translate="yes" xml:space="preserve">
          <source>Note that a &lt;a href=&quot;qguiapplication&quot;&gt;QGuiApplication&lt;/a&gt; instance must exist before a &lt;a href=&quot;qfont&quot;&gt;QFont&lt;/a&gt; can be used. You can set the application's default font with &lt;a href=&quot;qguiapplication#setFont&quot;&gt;QGuiApplication::setFont&lt;/a&gt;().</source>
          <target state="translated">&amp;bull; 그래도 참고 &lt;a href=&quot;qguiapplication&quot;&gt;QGuiApplication의&lt;/a&gt; 전 (before) 인스턴스가 존재해야합니다 &lt;a href=&quot;qfont&quot;&gt;QFont가&lt;/a&gt; 사용할 수 있습니다. &lt;a href=&quot;qguiapplication#setFont&quot;&gt;QGuiApplication :: setFont&lt;/a&gt; ()를 사용하여 응용 프로그램의 기본 글꼴을 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="41f1ed540407531312c9c5e47ea2694680fbeedd" translate="yes" xml:space="preserve">
          <source>Note that a &lt;a href=&quot;qguiapplication&quot;&gt;QGuiApplication&lt;/a&gt; instance must exist before a QFont can be used. You can set the application's default font with &lt;a href=&quot;qguiapplication#setFont&quot;&gt;QGuiApplication::setFont&lt;/a&gt;().</source>
          <target state="translated">&amp;bull; 그래도 참고 &lt;a href=&quot;qguiapplication&quot;&gt;QGuiApplication의&lt;/a&gt; QFont 사용하기 전에 인스턴스가 존재해야합니다. &lt;a href=&quot;qguiapplication#setFont&quot;&gt;QGuiApplication :: setFont&lt;/a&gt; ()를 사용하여 애플리케이션의 기본 글꼴을 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="16b5d5f0d7184c93e062430936a86c5b4fa90eb5" translate="yes" xml:space="preserve">
          <source>Note that a &lt;a href=&quot;qjsvalue&quot;&gt;QJSValue&lt;/a&gt; for which &lt;a href=&quot;qjsvalue#isObject&quot;&gt;isObject&lt;/a&gt;() is true only carries a reference to an actual object; copying the &lt;a href=&quot;qjsvalue&quot;&gt;QJSValue&lt;/a&gt; will only copy the object reference, not the object itself. If you want to clone an object (i.e. copy an object's properties to another object), you can do so with the help of a &lt;code&gt;for-in&lt;/code&gt; statement in script code, or &lt;a href=&quot;qjsvalueiterator&quot;&gt;QJSValueIterator&lt;/a&gt; in C++.</source>
          <target state="translated">유의 &lt;a href=&quot;qjsvalue&quot;&gt;QJSValue&lt;/a&gt; 하는 &lt;a href=&quot;qjsvalue#isObject&quot;&gt;isObject는&lt;/a&gt; ()에 해당하는 경우에만 실제 객체에 대한 참조를 전달; 복사 &lt;a href=&quot;qjsvalue&quot;&gt;QJSValue 것은&lt;/a&gt; 단지 객체 참조가 아닌 객체 자체를 복사합니다. 오브젝트를 복제하려는 경우 (예 : 오브젝트의 특성을 다른 오브젝트에 복사) 스크립트 코드 의 &lt;code&gt;for-in&lt;/code&gt; 문 또는 &lt;a href=&quot;qjsvalueiterator&quot;&gt;QJSValueIterator를 사용하여이를 복제 할 수 있습니다.&lt;/a&gt; C ++의 를 .</target>
        </trans-unit>
        <trans-unit id="86addfca96d6e8599e241d136a2c78f5318415f9" translate="yes" xml:space="preserve">
          <source>Note that a &lt;a href=&quot;qml-qtlocation-placesearchmodel&quot;&gt;PlaceSearchModel&lt;/a&gt; will call &lt;a href=&quot;qml-qtlocation-place#getDetails-method&quot;&gt;Place::getDetails&lt;/a&gt; on any place that it detects an update on. A consequence of this is that whenever a Place from a &lt;a href=&quot;qml-qtlocation-placesearchmodel&quot;&gt;PlaceSearchModel&lt;/a&gt; is successfully saved, it will be followed by a fetch of place details, leading to a sequence of state changes of &lt;code&gt;Saving&lt;/code&gt;, &lt;code&gt;Ready&lt;/code&gt;, &lt;code&gt;Fetching&lt;/code&gt;, &lt;code&gt;Ready&lt;/code&gt;.</source>
          <target state="translated">참고는 것을 &lt;a href=&quot;qml-qtlocation-placesearchmodel&quot;&gt;PlaceSearchModel가&lt;/a&gt; 호출 &lt;a href=&quot;qml-qtlocation-place#getDetails-method&quot;&gt;장소 : getDetails를&lt;/a&gt; 이에 대한 업데이 트를 감지 한 장소에. 그 결과 &lt;a href=&quot;qml-qtlocation-placesearchmodel&quot;&gt;PlaceSearchModel&lt;/a&gt; 의 작업 공간 이 성공적으로 저장 될 때마다 작업 공간 세부 사항 페치가 이어지고 &lt;code&gt;Saving&lt;/code&gt; , &lt;code&gt;Ready&lt;/code&gt; , &lt;code&gt;Fetching&lt;/code&gt; , &lt;code&gt;Ready&lt;/code&gt; 중 상태가 순차적으로 변경 됩니다.</target>
        </trans-unit>
        <trans-unit id="503bbcd690e9d977d896f91d8e5d14f7d6af9af3" translate="yes" xml:space="preserve">
          <source>Note that a &lt;a href=&quot;qwebchannel&quot;&gt;QWebChannel&lt;/a&gt; is only fully operational once you connect it to a &lt;a href=&quot;qwebchannelabstracttransport&quot;&gt;QWebChannelAbstractTransport&lt;/a&gt;. The HTML clients also need to be setup appropriately using &lt;a href=&quot;qtwebchannel-javascript#&quot;&gt;&lt;code&gt;qwebchannel.js&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&amp;bull; 그래도 참고 &lt;a href=&quot;qwebchannel&quot;&gt;QWebChannel은&lt;/a&gt; 당신이에 연결 한 번만 완전히 작동 &lt;a href=&quot;qwebchannelabstracttransport&quot;&gt;QWebChannelAbstractTransport&lt;/a&gt; . HTML 클라이언트는 &lt;a href=&quot;qtwebchannel-javascript#&quot;&gt; &lt;code&gt;qwebchannel.js&lt;/code&gt; 를&lt;/a&gt; 사용하여 적절하게 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="0f361c945386e67e1853cdea5eed385b27efa122" translate="yes" xml:space="preserve">
          <source>Note that a &lt;a href=&quot;qxmlnamepool&quot;&gt;name pool&lt;/a&gt; is</source>
          <target state="translated">&amp;bull; 그래도 참고 &lt;a href=&quot;qxmlnamepool&quot;&gt;이름 풀이&lt;/a&gt; 입니다</target>
        </trans-unit>
        <trans-unit id="1e443635415726123c68a68e66bb1ddbb6a12afd" translate="yes" xml:space="preserve">
          <source>Note that a QJSValue for which &lt;a href=&quot;qjsvalue#isObject&quot;&gt;isObject&lt;/a&gt;() is true only carries a reference to an actual object; copying the QJSValue will only copy the object reference, not the object itself. If you want to clone an object (i.e. copy an object's properties to another object), you can do so with the help of a &lt;code&gt;for-in&lt;/code&gt; statement in script code, or &lt;a href=&quot;qjsvalueiterator&quot;&gt;QJSValueIterator&lt;/a&gt; in C++.</source>
          <target state="translated">&lt;a href=&quot;qjsvalue#isObject&quot;&gt;isObject&lt;/a&gt; ()가 true 인 QJSValue 는 실제 객체에 대한 참조 만 전달합니다. QJSValue를 복사하면 객체 자체가 아닌 객체 참조 만 복사됩니다. 객체를 복제하려는 경우 (즉, 객체의 속성을 다른 객체에 복사) 스크립트 코드 의 &lt;code&gt;for-in&lt;/code&gt; 문 또는 C ++의 &lt;a href=&quot;qjsvalueiterator&quot;&gt;QJSValueIterator&lt;/a&gt; 를 사용 하여 복제 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c50ccdfb8407eefd40a1dcbb732c2714210e8a68" translate="yes" xml:space="preserve">
          <source>Note that a QWebChannel is only fully operational once you connect it to a &lt;a href=&quot;qwebchannelabstracttransport&quot;&gt;QWebChannelAbstractTransport&lt;/a&gt;. The HTML clients also need to be setup appropriately using &lt;a href=&quot;qtwebchannel-javascript&quot;&gt;&lt;code&gt;qwebchannel.js&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">당신이에 연결 일단 QWebChannel은 완벽하게 작동하는지 참고 &lt;a href=&quot;qwebchannelabstracttransport&quot;&gt;QWebChannelAbstractTransport&lt;/a&gt; . HTML 클라이언트는 &lt;a href=&quot;qtwebchannel-javascript&quot;&gt; &lt;code&gt;qwebchannel.js&lt;/code&gt; 를&lt;/a&gt; 사용하여 적절하게 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="02637b0cd08e75d9af4e6bcfc682c63a7bb3a869" translate="yes" xml:space="preserve">
          <source>Note that a cursor always moves when text is inserted before the current position of the cursor, and it always keeps its position when text is inserted after the current position of the cursor.</source>
          <target state="translated">커서가 현재 커서 위치 앞에 텍스트가 삽입되면 커서가 항상 이동하고 커서가 현재 커서 위치 뒤에 텍스트가 삽입 될 때 항상 위치를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="6f76131721fa5c25db41f016753541beabf40984" translate="yes" xml:space="preserve">
          <source>Note that a moved-from &lt;a href=&quot;qcollator&quot;&gt;QCollator&lt;/a&gt; can only be destroyed or assigned to. The effect of calling other functions than the destructor or one of the assignment operators is undefined.</source>
          <target state="translated">이동 한 &lt;a href=&quot;qcollator&quot;&gt;QCollator&lt;/a&gt; 는 파기 또는 할당 만 할 수 있습니다. 소멸자 또는 대입 연산자 중 하나 이외의 다른 함수를 호출하는 효과는 정의되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e8a8d6006918f2dcadaf624c6ddb629fa5666854" translate="yes" xml:space="preserve">
          <source>Note that a moved-from QCollator can only be destroyed or assigned to. The effect of calling other functions than the destructor or one of the assignment operators is undefined.</source>
          <target state="translated">이동 된 QCollator는 폐기하거나 할당 만 할 수 있습니다. 소멸자 또는 할당 연산자 중 하나가 아닌 다른 함수를 호출하는 효과는 정의되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="9aac276e0a336240da5324f9483b107de4eddb1c" translate="yes" xml:space="preserve">
          <source>Note that a property cannot have more than one assigned Behavior. To provide multiple animations within a Behavior, use &lt;a href=&quot;qml-qtquick-parallelanimation&quot;&gt;ParallelAnimation&lt;/a&gt; or &lt;a href=&quot;qml-qtquick-sequentialanimation&quot;&gt;SequentialAnimation&lt;/a&gt;.</source>
          <target state="translated">속성에는 둘 이상의 할당 된 동작이있을 수 없습니다. 비헤이비어 내에 여러 애니메이션을 제공하려면 &lt;a href=&quot;qml-qtquick-parallelanimation&quot;&gt;ParallelAnimation&lt;/a&gt; 또는 &lt;a href=&quot;qml-qtquick-sequentialanimation&quot;&gt;SequentialAnimation을 사용하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cc61d6b1ef38590ae4a81734f3291bc3c66e63c0" translate="yes" xml:space="preserve">
          <source>Note that a property cannot have more than one assigned BoundaryRule.</source>
          <target state="translated">속성에는 둘 이상의 할당 된 BoundaryRule이있을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="70eba09345475938858eb55399c27d94c435c59f" translate="yes" xml:space="preserve">
          <source>Note that a single &lt;a href=&quot;qml-qtquick-patharc&quot;&gt;PathArc&lt;/a&gt; cannot be used to specify a circle. Instead, you can use two &lt;a href=&quot;qml-qtquick-patharc&quot;&gt;PathArc&lt;/a&gt; elements, each specifying half of the circle.</source>
          <target state="translated">단일 &lt;a href=&quot;qml-qtquick-patharc&quot;&gt;PathArc&lt;/a&gt; 를 사용하여 원을 지정할 수 없습니다. 대신 각각 원의 절반을 지정 하는 두 개의 &lt;a href=&quot;qml-qtquick-patharc&quot;&gt;PathArc&lt;/a&gt; 요소를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5548b568d6ec3fb1301e3d065f74135ce4aa01e7" translate="yes" xml:space="preserve">
          <source>Note that a single PathArc cannot be used to specify a circle. Instead, you can use two PathArc elements, each specifying half of the circle.</source>
          <target state="translated">단일 PathArc는 원을 지정하는 데 사용할 수 없습니다. 대신, 각각 원의 절반을 지정하는 두 개의 PathArc 요소를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5451eec835716891135e1dd10a6611eabb1a2b1e" translate="yes" xml:space="preserve">
          <source>Note that a window that is mapped to screen may still not be considered exposed if the window client area is completely covered by other windows, or if the window is otherwise not visible. This function will then time out when waiting for such a window.</source>
          <target state="translated">창 클라이언트 영역이 다른 창으로 완전히 덮여 있거나 창이 표시되지 않으면 화면에 매핑 된 창은 여전히 ​​노출 된 것으로 간주되지 않을 수 있습니다. 그런 다음이 창을 기다릴 때이 기능이 시간 초과됩니다.</target>
        </trans-unit>
        <trans-unit id="4c10711923ea12fa526d7cf2de9c4b286a7d51ed" translate="yes" xml:space="preserve">
          <source>Note that abbreviations may or may not be localized.</source>
          <target state="translated">약어는 현지화되거나 현지화되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5690be84d5b05770ff50486372be58d00e661165" translate="yes" xml:space="preserve">
          <source>Note that accepting the terms and conditions only applies those terms and conditions to the use of the HERE geo services plugin and does not limit the use of the other geo services plugins that may be included with Qt.</source>
          <target state="translated">이용 약관에 동의하면 해당 이용 약관은 HERE 지리 서비스 플러그인 사용에만 적용되며 Qt에 포함될 수있는 다른 지리 서비스 플러그인의 사용을 제한하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="438ae93e5434a3f3950b7259b62d264aa0402587" translate="yes" xml:space="preserve">
          <source>Note that all &lt;a href=&quot;qmimetype&quot;&gt;QMimeType&lt;/a&gt; instances refer to proper mimetypes, never to aliases directly.</source>
          <target state="translated">모든 &lt;a href=&quot;qmimetype&quot;&gt;QMimeType&lt;/a&gt; 인스턴스는 적절한 MIME 유형을 참조하며 직접 별명을 참조하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="1f3b0a52a328b2953b0765a0f48679098ff227c4" translate="yes" xml:space="preserve">
          <source>Note that all C++ types registered with the QML type system must be &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;-derived, even if they are non-instantiable.</source>
          <target state="translated">QML 유형 시스템에 등록 된 모든 C ++ 유형 은 인스턴스화 할 수없는 경우에도 &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 파생 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="050a7c7b96bddc3d6fb4f47173e48159713d6d47" translate="yes" xml:space="preserve">
          <source>Note that all active timers for the object will be reset. The timers are first stopped in the current thread and restarted (with the same interval) in the</source>
          <target state="translated">객체에 대한 모든 활성 타이머가 재설정됩니다. 타이머는 현재 스레드에서 먼저 중지 된 후 타이머에서 동일한 간격으로 다시 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="5754636c97a664ccc7e9d1341a009eb89beabfc1" translate="yes" xml:space="preserve">
          <source>Note that all effects are disabled on screens running at less than 16-bit color depth.</source>
          <target state="translated">16 비트 미만의 색 심도에서 실행되는 화면에서는 모든 효과가 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="ea977213302a8f0ed6f41631194ed6daac550753" translate="yes" xml:space="preserve">
          <source>Note that all formats may not be supported. The exact set of supported formats is dependent upon your OpenGL implementation and version.</source>
          <target state="translated">모든 형식이 지원되지 않을 수 있습니다. 지원되는 형식의 정확한 세트는 OpenGL 구현 및 버전에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="ff6a1db020ba1cf01fb635fddf116d3d4e4ea617" translate="yes" xml:space="preserve">
          <source>Note that all of the Qt associative containers already have built-in support, and it is not necessary to use this macro with them. The std::map container also has built-in support.</source>
          <target state="translated">모든 Qt 연관 컨테이너는 이미 지원 기능이 내장되어 있으므로이 매크로를 컨테이너와 함께 사용할 필요는 없습니다. std :: map 컨테이너도 내장 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="24d9874c65cee435e603256ae2fcc3121b49d711" translate="yes" xml:space="preserve">
          <source>Note that all of the Qt sequential containers already have built-in support, and it is not necessary to use this macro with them. The std::vector and std::list containers also have built-in support.</source>
          <target state="translated">모든 Qt 순차 컨테이너는 이미 기본 제공 지원을 가지고 있으므로이 매크로를 컨테이너와 함께 사용할 필요는 없습니다. std :: vector 및 std :: list 컨테이너도 기본적으로 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="4b12375ab6b3e35c3f931a1c5ca6b66a8ce4656c" translate="yes" xml:space="preserve">
          <source>Note that all signals are emitted as usual. If you connect a &lt;a href=&quot;qaction&quot;&gt;QAction&lt;/a&gt; to a slot and call the menu's &lt;a href=&quot;qmenu#exec&quot;&gt;exec&lt;/a&gt;(), you get the result both via the signal-slot connection and in the return value of &lt;a href=&quot;qmenu#exec&quot;&gt;exec&lt;/a&gt;().</source>
          <target state="translated">모든 신호는 평소대로 방출됩니다. &lt;a href=&quot;qaction&quot;&gt;QAction&lt;/a&gt; 을 슬롯에 연결 하고 메뉴의 &lt;a href=&quot;qmenu#exec&quot;&gt;exec&lt;/a&gt; ()를 호출 하면 신호 슬롯 연결과 &lt;a href=&quot;qmenu#exec&quot;&gt;exec&lt;/a&gt; () 의 반환 값을 통해 결과를 얻습니다 .</target>
        </trans-unit>
        <trans-unit id="9a6ac57fef7c96aa7469a6728114edffd88a6dd9" translate="yes" xml:space="preserve">
          <source>Note that all signals are emitted as usual. If you connect a &lt;a href=&quot;qaction&quot;&gt;QAction&lt;/a&gt; to a slot and call the menu's exec(), you get the result both via the signal-slot connection and in the return value of exec().</source>
          <target state="translated">모든 신호는 평소와 같이 방출됩니다. &lt;a href=&quot;qaction&quot;&gt;QAction&lt;/a&gt; 을 슬롯에 연결 하고 메뉴의 exec ()를 호출하면 신호 슬롯 연결과 exec ()의 반환 값을 통해 결과를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d542bf4f149ca0c53a59c4db2645120c7e71fa46" translate="yes" xml:space="preserve">
          <source>Note that all signals declared will be exported to the &lt;a href=&quot;qsensorgesture&quot;&gt;QSensorGesture&lt;/a&gt; object. If you need to use signals that are not exported, you should use a private class to do so.</source>
          <target state="translated">선언 된 모든 신호는 &lt;a href=&quot;qsensorgesture&quot;&gt;QSensorGesture&lt;/a&gt; 객체 로 내보내집니다 . 내 보내지 않은 신호를 사용해야하는 경우 개인 클래스를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="2f484d7c33046bb3903e38e027f0bf33e243912b" translate="yes" xml:space="preserve">
          <source>Note that all this is different from what you get in other JavaScript implementations which usually treat year 0 as valid in all string representations. As the date formats are &quot;implementation-dependent&quot; in the ECMAScript standard, this is still valid, though.</source>
          <target state="translated">이 모든 것은 일반적으로 0 년을 모든 문자열 표현에서 유효한 것으로 취급하는 다른 JavaScript 구현에서 얻는 것과 다릅니다. ECMAScript 표준에서 날짜 형식은 &quot;구현에 따라&quot;다르지만 여전히 유효합니다.</target>
        </trans-unit>
        <trans-unit id="1a6a5df26b499205ee6debbf2e1b4bed31eb6c0c" translate="yes" xml:space="preserve">
          <source>Note that an empty &lt;a href=&quot;qfileinfo&quot;&gt;QFileInfo&lt;/a&gt; object contain no file reference.</source>
          <target state="translated">빈 &lt;a href=&quot;qfileinfo&quot;&gt;QFileInfo&lt;/a&gt; 객체에는 파일 참조가 없습니다.</target>
        </trans-unit>
        <trans-unit id="325b20c8ab3f8f1af2ac33989b42b773ad6d4fdf" translate="yes" xml:space="preserve">
          <source>Note that an empty QFileInfo object contain no file reference.</source>
          <target state="translated">빈 QFileInfo 개체에는 파일 참조가 포함되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="553f1705d00f84aadbf3ccdc4a03163b3a8ce441" translate="yes" xml:space="preserve">
          <source>Note that an extra variable, index, will be available inside instances of the delegate. This variable refers to the index of the instance inside the Instantiator, and can be used to obtain the object through the &lt;a href=&quot;qml-qtqml-instantiator#objectAt-method&quot;&gt;objectAt&lt;/a&gt; method of the Instantiator.</source>
          <target state="translated">델리게이트 인스턴스 내에서 추가 변수 인 인덱스를 사용할 수 있습니다. 이 변수는 Instantiator 내부의 인스턴스 색인을 나타내며 Instantiator의 &lt;a href=&quot;qml-qtqml-instantiator#objectAt-method&quot;&gt;objectAt&lt;/a&gt; 메소드를 통해 객체를 얻는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="62688fe4c4a9349c279670ef4f9e1f625e497ad8" translate="yes" xml:space="preserve">
          <source>Note that an extra variable, index, will be available inside instances of the delegate. This variable refers to the index of the instance inside the Instantiator, and can be used to obtain the object through the &lt;a href=&quot;qml-qtqml-models-instantiator#objectAt-method&quot;&gt;objectAt&lt;/a&gt; method of the Instantiator.</source>
          <target state="translated">추가 변수 인 index는 델리게이트의 인스턴스 내에서 사용할 수 있습니다. 이 변수는 Instantiator 내부의 인스턴스 인덱스를 참조하며 Instantiator의 &lt;a href=&quot;qml-qtqml-models-instantiator#objectAt-method&quot;&gt;objectAt&lt;/a&gt; 메서드를 통해 객체를 가져 오는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b98003e5d7ec2ec30b0f0c4184a9224d537f52ad" translate="yes" xml:space="preserve">
          <source>Note that an extra variable, index, will be available inside instances of the delegate. This variable refers to the index of the instance inside the Instantiator, and can be used to obtain the object through the itemAt method of the Instantiator.</source>
          <target state="translated">델리게이트 인스턴스 내에서 추가 변수 인 인덱스를 사용할 수 있습니다. 이 변수는 Instantiator 내부의 인스턴스 색인을 나타내며 Instantiator의 itemAt 메소드를 통해 객체를 얻는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aeb4340ebaf439e5901a02b2a8650d0f6a833837" translate="yes" xml:space="preserve">
          <source>Note that an item will not receive double click events if it is neither &lt;a href=&quot;qgraphicsitem#GraphicsItemFlag-enum&quot;&gt;selectable&lt;/a&gt; nor &lt;a href=&quot;qgraphicsitem#GraphicsItemFlag-enum&quot;&gt;movable&lt;/a&gt; (single mouse clicks are ignored in this case, and that stops the generation of double clicks).</source>
          <target state="translated">항목을 &lt;a href=&quot;qgraphicsitem#GraphicsItemFlag-enum&quot;&gt;선택&lt;/a&gt; 하거나 &lt;a href=&quot;qgraphicsitem#GraphicsItemFlag-enum&quot;&gt;이동할 &lt;/a&gt;수 없는 경우 항목이 두 번 클릭 이벤트를 수신하지 않습니다 (이 경우 단일 마우스 클릭은 무시되고 두 번 클릭 생성이 중지됨).</target>
        </trans-unit>
        <trans-unit id="fd4c9fdddbbab080b96cf76514d83baa9822437b" translate="yes" xml:space="preserve">
          <source>Note that an object may have multiple children with the same &lt;code&gt;objectName&lt;/code&gt;. For example, &lt;a href=&quot;qml-qtquick-listview&quot;&gt;ListView&lt;/a&gt; creates multiple instances of its delegate, so if its delegate is declared with a particular objectName, the &lt;a href=&quot;qml-qtquick-listview&quot;&gt;ListView&lt;/a&gt; will have multiple children with the same &lt;code&gt;objectName&lt;/code&gt;. In this case, &lt;a href=&quot;qobject#findChildren&quot;&gt;QObject::findChildren&lt;/a&gt;() can be used to find all children with a matching &lt;code&gt;objectName&lt;/code&gt;.</source>
          <target state="translated">객체에는 동일한 &lt;code&gt;objectName&lt;/code&gt; 을 가진 여러 개의 자식이있을 수 있습니다 . 예를 들어 &lt;a href=&quot;qml-qtquick-listview&quot;&gt;ListView&lt;/a&gt; 는 대리자의 여러 인스턴스를 생성하므로 대리자가 특정 objectName으로 선언되면 &lt;a href=&quot;qml-qtquick-listview&quot;&gt;ListView&lt;/a&gt; 는 동일한 &lt;code&gt;objectName&lt;/code&gt; 을 가진 여러 개의 자식을 갖게됩니다 . 이 경우 &lt;a href=&quot;qobject#findChildren&quot;&gt;QObject :: findChildren&lt;/a&gt; ()을 사용하여 &lt;code&gt;objectName&lt;/code&gt; 과 일치하는 모든 자식을 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8073ea7abf3da3fc1f1485943f8c1bd609cdf904" translate="yes" xml:space="preserve">
          <source>Note that animations explicitly set on transitions will take precedence over any default animation for the given property.</source>
          <target state="translated">전환에 명시 적으로 설정된 애니메이션은 해당 속성의 기본 애니메이션보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="4d69f18d6df8ed3446103479905b103d8d960c24" translate="yes" xml:space="preserve">
          <source>Note that any of the &lt;code&gt;id&lt;/code&gt; values defined in &lt;code&gt;SquareButton.qml&lt;/code&gt; are not accessible to &lt;code&gt;SquareButton&lt;/code&gt; objects, as id values are only accessible from within the component scope in which a component is declared. The &lt;code&gt;SquareButton&lt;/code&gt; object definition above cannot refer to &lt;code&gt;mouseArea&lt;/code&gt; in order to refer to the &lt;a href=&quot;qml-qtquick-mousearea&quot;&gt;MouseArea&lt;/a&gt; child, and if it had an &lt;code&gt;id&lt;/code&gt; of &lt;code&gt;root&lt;/code&gt; rather than &lt;code&gt;squareButton&lt;/code&gt;, this would not conflict with the &lt;code&gt;id&lt;/code&gt; of the same value for the root object defined in &lt;code&gt;SquareButton.qml&lt;/code&gt; as the two would be declared within separate scopes.</source>
          <target state="translated">의 모든 점에 유의 &lt;code&gt;id&lt;/code&gt; 정의 값 &lt;code&gt;SquareButton.qml&lt;/code&gt; 가 접근하지 &lt;code&gt;SquareButton&lt;/code&gt; ID 값은 구성 요소가 선언 된 성분 범위 내에서만 액세스 할 수있는 바와 같이, 물체. &lt;code&gt;SquareButton&lt;/code&gt; 객체 정의는 위를 참조 할 수 없습니다 &lt;code&gt;mouseArea&lt;/code&gt; 참고하여주십시오하기 위해 &lt;a href=&quot;qml-qtquick-mousearea&quot;&gt;MouseArea의&lt;/a&gt; 아이, 그리고 그것은이 있다면 &lt;code&gt;id&lt;/code&gt; 의 &lt;code&gt;root&lt;/code&gt; 보다는 &lt;code&gt;squareButton&lt;/code&gt; 는이 것없는 충돌 &lt;code&gt;id&lt;/code&gt; 에 정의 된 루트 객체에 대해 동일한 값의 &lt;code&gt;SquareButton.qml&lt;/code&gt; 두 가지가 별도의 범위 내에서 선언되기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="b4ebad99420c37a8c2b95d62660414abf3d6fede" translate="yes" xml:space="preserve">
          <source>Note that application layouts and animations that are defined using &lt;a href=&quot;qml-qtquick-item#x-prop&quot;&gt;x&lt;/a&gt; property values (as opposed to anchors or positioner types) are not affected by the &lt;a href=&quot;qml-qtquick-layoutmirroring&quot;&gt;LayoutMirroring&lt;/a&gt; attached property. Therefore, adding right-to-left support to these types of layouts may require some code changes to your application, especially in views that rely on both the anchors and x coordinate-based positioning. Here is one way to use the &lt;a href=&quot;qml-qtquick-layoutmirroring&quot;&gt;LayoutMirroring&lt;/a&gt; attached property to apply mirroring to an item that is positioned using &lt;a href=&quot;qml-qtquick-item#x-prop&quot;&gt;x&lt;/a&gt; coordinates:</source>
          <target state="translated">앵커 또는 포지셔너 유형과 달리 &lt;a href=&quot;qml-qtquick-item#x-prop&quot;&gt;x&lt;/a&gt; 속성 값을 사용하여 정의 된 응용 프로그램 레이아웃 및 애니메이션 은 &lt;a href=&quot;qml-qtquick-layoutmirroring&quot;&gt;LayoutMirroring&lt;/a&gt; 연결된 속성의 영향을받지 않습니다 . 따라서 이러한 유형의 레이아웃에 오른쪽에서 왼쪽으로의 지원을 추가하려면 특히 앵커와 x 좌표 기반 위치 지정에 의존하는 뷰에서 응용 프로그램에 대한 일부 코드 변경이 필요할 수 있습니다. 다음은 &lt;a href=&quot;qml-qtquick-layoutmirroring&quot;&gt;LayoutMirroring&lt;/a&gt; 연결된 속성을 사용하여 &lt;a href=&quot;qml-qtquick-item#x-prop&quot;&gt;x&lt;/a&gt; 좌표를 사용하여 배치 된 항목에 미러링을 적용 하는 한 가지 방법입니다 .</target>
        </trans-unit>
        <trans-unit id="8a5b303f666ffa9a20260867f8c7d09ef5370a76" translate="yes" xml:space="preserve">
          <source>Note that application/octet-stream is the ultimate parent for all types of files (but not directories).</source>
          <target state="translated">application / octet-stream은 모든 유형의 파일 (디렉토리 제외)의 최종 상위 항목입니다.</target>
        </trans-unit>
        <trans-unit id="496bd244181378ffa2655a1f8e4da5d0cdea1087" translate="yes" xml:space="preserve">
          <source>Note that applying &lt;a href=&quot;qbrush#setTexture&quot;&gt;setTexture&lt;/a&gt;() makes &lt;a href=&quot;qbrush#style&quot;&gt;style&lt;/a&gt;() == &lt;a href=&quot;qt#BrushStyle-enum&quot;&gt;Qt::TexturePattern&lt;/a&gt;, regardless of previous style settings. Also, calling &lt;a href=&quot;qbrush#setColor&quot;&gt;setColor&lt;/a&gt;() will not make a difference if the style is a gradient. The same is the case if the style is &lt;a href=&quot;qt#BrushStyle-enum&quot;&gt;Qt::TexturePattern&lt;/a&gt; style unless the current texture is a &lt;a href=&quot;gui-changes-qt6#qbitmap&quot;&gt;QBitmap&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qbrush#setTexture&quot;&gt;setTexture&lt;/a&gt; () 를 적용 하면 이전 스타일 설정에 관계없이 &lt;a href=&quot;qbrush#style&quot;&gt;style&lt;/a&gt; () == &lt;a href=&quot;qt#BrushStyle-enum&quot;&gt;Qt :: TexturePattern이&lt;/a&gt; 됩니다. 또한 스타일이 그래디언트 인 경우 &lt;a href=&quot;qbrush#setColor&quot;&gt;setColor&lt;/a&gt; ()를 호출 해도 차이가 발생하지 않습니다. 현재 텍스처가 &lt;a href=&quot;gui-changes-qt6#qbitmap&quot;&gt;QBitmap&lt;/a&gt; 이 아니라면 스타일이 &lt;a href=&quot;qt#BrushStyle-enum&quot;&gt;Qt :: TexturePattern&lt;/a&gt; 스타일 인 경우도 마찬가지 입니다.</target>
        </trans-unit>
        <trans-unit id="d2468279dbc2cc1e7a0e182d9b08bf83dc261687" translate="yes" xml:space="preserve">
          <source>Note that applying &lt;a href=&quot;qbrush#setTexture&quot;&gt;setTexture&lt;/a&gt;() makes &lt;a href=&quot;qbrush#style&quot;&gt;style&lt;/a&gt;() == &lt;a href=&quot;qt#BrushStyle-enum&quot;&gt;Qt::TexturePattern&lt;/a&gt;, regardless of previous style settings. Also, calling &lt;a href=&quot;qbrush#setColor&quot;&gt;setColor&lt;/a&gt;() will not make a difference if the style is a gradient. The same is the case if the style is &lt;a href=&quot;qt#BrushStyle-enum&quot;&gt;Qt::TexturePattern&lt;/a&gt; style unless the current texture is a &lt;a href=&quot;qbitmap&quot;&gt;QBitmap&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qbrush#setTexture&quot;&gt;setTexture&lt;/a&gt; () 를 적용 하면 이전 스타일 설정에 관계없이 &lt;a href=&quot;qbrush#style&quot;&gt;style&lt;/a&gt; () == &lt;a href=&quot;qt#BrushStyle-enum&quot;&gt;Qt :: TexturePattern이&lt;/a&gt; 됩니다. 또한 스타일이 그라디언트 인 경우 &lt;a href=&quot;qbrush#setColor&quot;&gt;setColor&lt;/a&gt; ()를 호출 해도 차이가 없습니다. 현재 텍스처가 &lt;a href=&quot;qbitmap&quot;&gt;QBitmap&lt;/a&gt; 이 아닌 경우 스타일이 &lt;a href=&quot;qt#BrushStyle-enum&quot;&gt;Qt :: TexturePattern&lt;/a&gt; 스타일 인 경우에도 마찬가지 입니다.</target>
        </trans-unit>
        <trans-unit id="92c266e6ec839efc98e1887b023e21e41665d36f" translate="yes" xml:space="preserve">
          <source>Note that asking for a partial match can still lead to a complete match, if one is found; in this case, &lt;a href=&quot;qregularexpressionmatch#hasMatch&quot;&gt;hasMatch()&lt;/a&gt; will return &lt;code&gt;true&lt;/code&gt; and &lt;a href=&quot;qregularexpressionmatch#hasPartialMatch&quot;&gt;hasPartialMatch()&lt;/a&gt;&lt;code&gt;false&lt;/code&gt;. It never happens that a &lt;a href=&quot;qregularexpressionmatch&quot;&gt;QRegularExpressionMatch&lt;/a&gt; reports both a partial and a complete match.</source>
          <target state="translated">부분 일치를 요청하면 일치하는 경우 여전히 완전 일치로 이어질 수 있습니다. 이 경우 &lt;a href=&quot;qregularexpressionmatch#hasMatch&quot;&gt;hasMatch ()&lt;/a&gt; 는 &lt;code&gt;true&lt;/code&gt; 및 &lt;a href=&quot;qregularexpressionmatch#hasPartialMatch&quot;&gt;hasPartialMatch () &lt;/a&gt; &lt;code&gt;false&lt;/code&gt; 를 반환 합니다 . &lt;a href=&quot;qregularexpressionmatch&quot;&gt;QRegularExpressionMatch&lt;/a&gt; 가 부분 및 전체 일치를보고 하는 것은 결코 발생하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="de9873214397064878b74efe147f06e6da69a551" translate="yes" xml:space="preserve">
          <source>Note that attribute names are processed differently than element names: an unprefixed element name gets the default namespace (if any), while an unprefixed attribute name does not.</source>
          <target state="translated">속성 이름은 요소 이름과 다르게 처리됩니다. 접두사가없는 요소 이름은 기본 네임 스페이스 (있는 경우)를 가져오고 접두사가없는 속성 이름은 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="b85b7993606169f706161766359889c72df90bb2" translate="yes" xml:space="preserve">
          <source>Note that both keys and values are case sensitive.</source>
          <target state="translated">키와 값은 모두 대소 문자를 구분합니다.</target>
        </trans-unit>
        <trans-unit id="bb9553d45905abb81aa8a42aa3d067b35aaed56b" translate="yes" xml:space="preserve">
          <source>Note that both the QML engine and the JavaScript engine will automatically generate their own caches of type-data about observed types. Every component loaded by an application is a distinct (explicit) type, and every element (component instance) that defines its own custom properties in QML is an implicit type. Any element (instance of a component) that does not define any custom property is considered by the JavaScript and QML engines to be of the type explicitly defined by the component, rather than its own implicit type.</source>
          <target state="translated">QML 엔진과 JavaScript 엔진은 모두 관찰 된 유형에 대한 자체 유형 데이터 캐시를 자동으로 생성합니다. 응용 프로그램이로드 한 모든 구성 요소는 고유 한 (명시 적) 유형이며, QML에서 고유 한 사용자 정의 특성을 정의하는 모든 요소 (구성 요소 인스턴스)는 내재적 유형입니다. 사용자 정의 특성을 정의하지 않은 요소 (구성 요소의 인스턴스)는 JavaScript 및 QML 엔진에 의해 고유 한 암시 적 유형이 아니라 구성 요소가 명시 적으로 정의한 유형 인 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="f68c7700d4a779c84115d83ba195ba082d922f00" translate="yes" xml:space="preserve">
          <source>Note that buttons (such as &lt;a href=&quot;qpushbutton&quot;&gt;QPushButton&lt;/a&gt;) are often implemented not to care whether the press and release occur close together: if you press the button and then change your mind, you need to drag all the way off the edge of the button in order to cancel the click. For this use case, set the &lt;a href=&quot;qml-qtquick-taphandler#gesturePolicy-prop&quot;&gt;gesturePolicy&lt;/a&gt; to &lt;code&gt;TapHandler.ReleaseWithinBounds&lt;/code&gt;.</source>
          <target state="translated">버튼 (예 : &lt;a href=&quot;qpushbutton&quot;&gt;QPushButton&lt;/a&gt; )은 종종 눌림 과 눌림 이 서로 밀접하게 발생하는지 여부를 신경 쓰지 않기 위해 구현됩니다. 버튼을 눌렀다가 마음이 바뀌면 버튼 가장자리에서 끝까지 드래그해야합니다. 클릭을 취소하십시오. 이 사용 사례의 경우 &lt;a href=&quot;qml-qtquick-taphandler#gesturePolicy-prop&quot;&gt;gesturePolicy&lt;/a&gt; 를 &lt;code&gt;TapHandler.ReleaseWithinBounds&lt;/code&gt; 로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="0df67ea42533f0de938a1308386267d1cf340d7e" translate="yes" xml:space="preserve">
          <source>Note that by default tooltips are only shown for widgets that are children of the active window. You can change this behavior by setting the attribute &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt::WA_AlwaysShowToolTips&lt;/a&gt; on the</source>
          <target state="translated">기본적으로 툴팁은 활성 창의 하위 위젯에 대해서만 표시됩니다. &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt :: WA_AlwaysShowToolTips&lt;/a&gt; 속성을 설정하여이 동작을 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b41647324c8cf6343f280fbc90c75ff25cdcedfd" translate="yes" xml:space="preserve">
          <source>Note that by default, &lt;a href=&quot;qtimeline&quot;&gt;QTimeLine&lt;/a&gt; uses the EaseInOut curve shape, which provides a value that grows slowly, then grows steadily, and finally grows slowly. For a custom timeline, you can reimplement &lt;a href=&quot;qtimeline#valueForTime&quot;&gt;valueForTime&lt;/a&gt;(), in which case &lt;a href=&quot;qtimeline&quot;&gt;QTimeLine&lt;/a&gt;'s &lt;a href=&quot;qtimeline#curveShape-prop&quot;&gt;curveShape&lt;/a&gt; property is ignored.</source>
          <target state="translated">기본적으로 &lt;a href=&quot;qtimeline&quot;&gt;QTimeLine&lt;/a&gt; 은 EaseInOut 곡선 모양을 사용합니다.이 곡선 모양은 천천히 성장한 다음 꾸준히 성장하고 천천히 성장하는 값을 제공합니다. 사용자 정의 타임 라인의 경우 &lt;a href=&quot;qtimeline#valueForTime&quot;&gt;valueForTime&lt;/a&gt; ()을 다시 구현할 수 &lt;a href=&quot;qtimeline&quot;&gt;있으며이&lt;/a&gt; 경우 QTimeLine 의 &lt;a href=&quot;qtimeline#curveShape-prop&quot;&gt;curveShape&lt;/a&gt; 속성이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="2f39b8b314c76639f6ef8821437194b890ff7541" translate="yes" xml:space="preserve">
          <source>Note that by default, if not contradicted by the file metadata, the loaded texture will have the following properties set: - &lt;a href=&quot;qt3drender-qabstracttexture#wrapMode-prop&quot;&gt;wrapMode&lt;/a&gt; set to Repeat - &lt;a href=&quot;qt3drender-qabstracttexture#minificationFilter-prop&quot;&gt;minificationFilter&lt;/a&gt; set to &lt;a href=&quot;qt3drender-qabstracttexture#Filter-enum&quot;&gt;LinearMipMapLinear&lt;/a&gt; - &lt;a href=&quot;qt3drender-qabstracttexture#magnificationFilter-prop&quot;&gt;magnificationFilter&lt;/a&gt; set to Linear - &lt;a href=&quot;qt3drender-qabstracttexture#generateMipMaps-prop&quot;&gt;generateMipMaps&lt;/a&gt; set to true - &lt;a href=&quot;qt3drender-qabstracttexture#maximumAnisotropy&quot;&gt;maximumAnisotropy&lt;/a&gt; set to 16.0f - target set to &lt;a href=&quot;qt3drender-qabstracttexture#Target-enum&quot;&gt;TargetAutomatic&lt;/a&gt;</source>
          <target state="translated">참고 다음과 같은 속성이 설정된 파일 메타 데이터 모순되지 않을 경우 기본적으로,로드 된 텍스처가있는 것 : - &lt;a href=&quot;qt3drender-qabstracttexture#wrapMode-prop&quot;&gt;wrapMode의&lt;/a&gt; 세트를 반복하기 - &lt;a href=&quot;qt3drender-qabstracttexture#minificationFilter-prop&quot;&gt;minificationFilter의&lt;/a&gt; 집합에 &lt;a href=&quot;qt3drender-qabstracttexture#Filter-enum&quot;&gt;LinearMipMapLinear&lt;/a&gt; - &lt;a href=&quot;qt3drender-qabstracttexture#magnificationFilter-prop&quot;&gt;magnificationFilter의&lt;/a&gt; 세트를 선형으로 - &lt;a href=&quot;qt3drender-qabstracttexture#generateMipMaps-prop&quot;&gt;generateMipMaps이&lt;/a&gt; - true로 설정 &lt;a href=&quot;qt3drender-qabstracttexture#maximumAnisotropy&quot;&gt;maximumAnisotropy&lt;/a&gt; 16.0f로 설정 - 대상이 &lt;a href=&quot;qt3drender-qabstracttexture#Target-enum&quot;&gt;TargetAutomatic으로&lt;/a&gt; 설정</target>
        </trans-unit>
        <trans-unit id="d7fe1cd28fb1810a66e5be326babf87e758c5dbd" translate="yes" xml:space="preserve">
          <source>Note that by the time the transition is applied, the item has already been removed from the model; any references to the model data for the removed index will not be valid.</source>
          <target state="translated">전환이 적용될 때까지 항목은 이미 모델에서 제거되었습니다. 제거 된 인덱스의 모델 데이터에 대한 참조는 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cbaaac217d8f8c713e731d433f6e8b477105ec24" translate="yes" xml:space="preserve">
          <source>Note that cacheBuffer is not a pixel buffer - it only maintains additional instantiated delegates.</source>
          <target state="translated">cacheBuffer는 픽셀 버퍼가 아니며 추가 인스턴스화 된 델리게이트 만 유지합니다.</target>
        </trans-unit>
        <trans-unit id="2fac8da058a1b388aed534f8f48e7e096a3bc201" translate="yes" xml:space="preserve">
          <source>Note that calling setColor() will not make a difference if the style is a gradient. The same is the case if the style is &lt;a href=&quot;qt#BrushStyle-enum&quot;&gt;Qt::TexturePattern&lt;/a&gt; style unless the current texture is a &lt;a href=&quot;gui-changes-qt6#qbitmap&quot;&gt;QBitmap&lt;/a&gt;.</source>
          <target state="translated">스타일이 그래디언트 인 경우 setColor ()를 호출해도 차이가 발생하지 않는다는 점에 유의하세요. ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ 현재 텍스처가 &lt;a href=&quot;gui-changes-qt6#qbitmap&quot;&gt;QBitmap&lt;/a&gt; 이 아니라면 스타일이 &lt;a href=&quot;qt#BrushStyle-enum&quot;&gt;Qt :: TexturePattern&lt;/a&gt; 스타일 인 경우도 마찬가지 입니다.</target>
        </trans-unit>
        <trans-unit id="850791f60e2cee1adcc1bc3c46066512d1ba8575" translate="yes" xml:space="preserve">
          <source>Note that calling setColor() will not make a difference if the style is a gradient. The same is the case if the style is &lt;a href=&quot;qt#BrushStyle-enum&quot;&gt;Qt::TexturePattern&lt;/a&gt; style unless the current texture is a &lt;a href=&quot;qbitmap&quot;&gt;QBitmap&lt;/a&gt;.</source>
          <target state="translated">스타일이 그라디언트 인 경우 setColor ()를 호출해도 차이가 없습니다. 현재 텍스처가 &lt;a href=&quot;qbitmap&quot;&gt;QBitmap&lt;/a&gt; 이 아닌 경우 스타일이 &lt;a href=&quot;qt#BrushStyle-enum&quot;&gt;Qt :: TexturePattern&lt;/a&gt; 스타일 인 경우에도 마찬가지 입니다.</target>
        </trans-unit>
        <trans-unit id="f5fdfb615d5c90337b509849080d969b87e38585" translate="yes" xml:space="preserve">
          <source>Note that calling this function can be significantely slower than using call() on the respective &lt;a href=&quot;qaxscript&quot;&gt;QAxScript&lt;/a&gt; directly.</source>
          <target state="translated">이 함수를 호출하면 해당 &lt;a href=&quot;qaxscript&quot;&gt;QAxScript에서&lt;/a&gt; 직접 call ()을 사용하는 것보다 상당히 느릴 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="35b09cc9da84e41fd1034b0d5899c8c1a7c6edae" translate="yes" xml:space="preserve">
          <source>Note that calling this function repeatedly, for instance from a key event handler, may be slow. In such cases, you should use the &lt;code&gt;dataChanged()&lt;/code&gt; signal instead.</source>
          <target state="translated">예를 들어 키 이벤트 핸들러에서이 함수를 반복적으로 호출하면 속도가 느려질 수 있습니다. 이러한 경우 &lt;code&gt;dataChanged()&lt;/code&gt; 신호를 대신 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="733f8433d52671c788b2c43a44a517663d55aac1" translate="yes" xml:space="preserve">
          <source>Note that changing settings in &lt;a href=&quot;qsslconfiguration&quot;&gt;QSslConfiguration&lt;/a&gt; is not enough to change the settings in the related SSL connection. You must call setSslConfiguration on a modified &lt;a href=&quot;qsslconfiguration&quot;&gt;QSslConfiguration&lt;/a&gt; object to achieve that. The following example illustrates how to change the protocol to TLSv1_0 in a &lt;a href=&quot;qsslsocket&quot;&gt;QSslSocket&lt;/a&gt; object:</source>
          <target state="translated">의 설정을 변경합니다 &lt;a href=&quot;qsslconfiguration&quot;&gt;QSslConfiguration하는&lt;/a&gt; 관련 SSL 연결의 설정을 변경하는 것만으로는 충분하지 않습니다. 이를 위해서는 수정 된 &lt;a href=&quot;qsslconfiguration&quot;&gt;QSslConfiguration&lt;/a&gt; 오브젝트에서 setSslConfiguration을 호출해야합니다 . 다음 예제는 &lt;a href=&quot;qsslsocket&quot;&gt;QSslSocket&lt;/a&gt; 오브젝트 에서 프로토콜을 TLSv1_0으로 변경하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="259facd07c1f0057993c50b2a2fa76852d3d0d25" translate="yes" xml:space="preserve">
          <source>Note that changing settings in QSslConfiguration is not enough to change the settings in the related SSL connection. You must call setSslConfiguration on a modified QSslConfiguration object to achieve that. The following example illustrates how to change the protocol to TLSv1_0 in a &lt;a href=&quot;qsslsocket&quot;&gt;QSslSocket&lt;/a&gt; object:</source>
          <target state="translated">QSslConfiguration의 설정 변경은 관련 SSL 연결의 설정을 변경하는 데 충분하지 않습니다. 이를 위해서는 수정 된 QSslConfiguration 객체에서 setSslConfiguration을 호출해야합니다. 다음 예제는 &lt;a href=&quot;qsslsocket&quot;&gt;QSslSocket&lt;/a&gt; 객체 에서 프로토콜을 TLSv1_0로 변경하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="96391d8b54351dfc1ca9187d6ccd1f5f25b682eb" translate="yes" xml:space="preserve">
          <source>Note that changing the engines will reset the printer state and all its properties.</source>
          <target state="translated">엔진을 변경하면 프린터 상태와 모든 속성이 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="9b9b3830c0f47597047904fa3dceae48819e2f7f" translate="yes" xml:space="preserve">
          <source>Note that changing the message handler after the query has been compiled has no effect, i.e. the query uses the same message handler at runtime that it uses at compile time.</source>
          <target state="translated">쿼리가 컴파일 된 후 메시지 핸들러를 변경해도 아무런 영향을 미치지 않습니다. 즉, 쿼리시 런타임에 컴파일시 사용하는 것과 동일한 메시지 핸들러를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="28b264c661fc9cd1afbbdddaf26eb9cefa5f3f3f" translate="yes" xml:space="preserve">
          <source>Note that changing the type of a proxy does not change the set of capabilities this &lt;a href=&quot;qnetworkproxy&quot;&gt;QNetworkProxy&lt;/a&gt; object holds if any capabilities have been set with &lt;a href=&quot;qnetworkproxy#setCapabilities&quot;&gt;setCapabilities&lt;/a&gt;().</source>
          <target state="translated">프록시의 유형을 변경해도 &lt;a href=&quot;qnetworkproxy#setCapabilities&quot;&gt;setCapabilities&lt;/a&gt; () 로 설정된 기능이있는 &lt;a href=&quot;qnetworkproxy&quot;&gt;경우이 QNetworkProxy&lt;/a&gt; 객체가 보유하는 기능 세트는 변경되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="506d718d25aa1537cfc2dc0e0b14d1d97f55065e" translate="yes" xml:space="preserve">
          <source>Note that changing this value implicitly changes also the distance between the camera and the map, so that, at a tilting angle of 0 degrees, the resulting image is identical for any value used for this property.</source>
          <target state="translated">이 값을 변경하면 카메라와지도 사이의 거리도 암시 적으로 변경되므로 0 도의 기울기 각도에서 결과 이미지가이 속성에 사용 된 값과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="8fe56606380a91e0d8bd96ca3eb37d0ce62e8db0" translate="yes" xml:space="preserve">
          <source>Note that character references and references to predefined entities are expanded by the XML processor so that characters are represented by their Unicode equivalent rather than by an entity reference.</source>
          <target state="translated">문자 참조 및 사전 정의 된 엔티티에 대한 참조는 XML 프로세서에 의해 확장되므로 문자는 엔티티 참조가 아닌 해당 유니 코드로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="1dc911db5b6d31c867d442f2c1cc2fccf818912d" translate="yes" xml:space="preserve">
          <source>Note that checkable items need to be given both a suitable set of flags and an initial state, indicating whether the item is checked or not. This is handled automatically for model/view components, but needs to be explicitly set for instances of &lt;a href=&quot;qlistwidgetitem&quot;&gt;QListWidgetItem&lt;/a&gt;, &lt;a href=&quot;qtablewidgetitem&quot;&gt;QTableWidgetItem&lt;/a&gt;, and &lt;a href=&quot;qtreewidgetitem&quot;&gt;QTreeWidgetItem&lt;/a&gt;.</source>
          <target state="translated">확인 가능한 항목에는 적절한 플래그 세트와 초기 상태가 지정되어 항목을 확인했는지 여부를 나타냅니다. 이는 모델 / 뷰 컴포넌트에 대해 자동으로 처리되지만 &lt;a href=&quot;qlistwidgetitem&quot;&gt;QListWidgetItem&lt;/a&gt; , &lt;a href=&quot;qtablewidgetitem&quot;&gt;QTableWidgetItem&lt;/a&gt; 및 &lt;a href=&quot;qtreewidgetitem&quot;&gt;QTreeWidgetItem의&lt;/a&gt; 인스턴스에 대해 명시 적으로 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="2b49e639810a092fd5d83d12fed27ab02150e4f8" translate="yes" xml:space="preserve">
          <source>Note that class &lt;code&gt;Employee&lt;/code&gt; also has a trivial copy constructor defined, which is not strictly required in this case.</source>
          <target state="translated">&lt;code&gt;Employee&lt;/code&gt; 클래스 에도 간단한 복사 생성자가 정의되어 있으며이 경우에는 꼭 필요한 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="0f7a5540d96c26724a819254dbfe953cf985b0e3" translate="yes" xml:space="preserve">
          <source>Note that class &lt;code&gt;T&lt;/code&gt; must inherit &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;, or a compilation or link error will result.</source>
          <target state="translated">클래스 &lt;code&gt;T&lt;/code&gt; 는 &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 를 상속해야합니다. 그렇지 않으면 컴파일 또는 링크 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9c5cc19a0336a06096e6ba8b1756e4356755d2d9" translate="yes" xml:space="preserve">
          <source>Note that comparing paths may involve a per element comparison which can be slow for complex paths.</source>
          <target state="translated">경로를 비교하는 것은 복잡한 경로에 대해 느릴 수있는 요소 당 비교를 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="423656132077510fd1907b8f7df344aefd8f2a52" translate="yes" xml:space="preserve">
          <source>Note that comparing to &lt;code&gt;time_point&lt;/code&gt; is not as efficient as comparing to &lt;code&gt;duration&lt;/code&gt;, since &lt;a href=&quot;qdeadlinetimer&quot;&gt;QDeadlineTimer&lt;/a&gt; may need to convert from its own internal clock source to the clock source used by the &lt;code&gt;time_point&lt;/code&gt; object. Also note that, due to this conversion, the deadlines will not be precise, so the following code is not expected to compare equally:</source>
          <target state="translated">에 비해 유의 &lt;code&gt;time_point&lt;/code&gt; 하기 에 비해만큼 효율적이지 못하다 &lt;code&gt;duration&lt;/code&gt; 이후, &lt;a href=&quot;qdeadlinetimer&quot;&gt;QDeadlineTimer가&lt;/a&gt; 에 의해 사용되는 클럭 소스에 자체 내장 클럭 소스로 변환해야 할 수도 있습니다 &lt;code&gt;time_point&lt;/code&gt; 의 객체입니다. 또한이 변환으로 인해 마감일이 정확하지 않으므로 다음 코드는 동일하게 비교할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="169ba2c914e535451379eaab037370eb1c5198d4" translate="yes" xml:space="preserve">
          <source>Note that comparing to &lt;code&gt;time_point&lt;/code&gt; is not as efficient as comparing to &lt;code&gt;duration&lt;/code&gt;, since QDeadlineTimer may need to convert from its own internal clock source to the clock source used by the &lt;code&gt;time_point&lt;/code&gt; object. Also note that, due to this conversion, the deadlines will not be precise, so the following code is not expected to compare equally:</source>
          <target state="translated">에 비해 유의 &lt;code&gt;time_point&lt;/code&gt; 하기 에 비해만큼 효율적이지 못하다 &lt;code&gt;duration&lt;/code&gt; QDeadlineTimer이가 사용하는 클럭 소스에 자체 내장 클럭 소스로 변환해야 할 수도 있기 때문에, &lt;code&gt;time_point&lt;/code&gt; 의 객체입니다. 또한이 변환으로 인해 기한이 정확하지 않으므로 다음 코드가 동일하게 비교할 것으로 예상되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c71fcb8942e2ac0a9e997b63c5ef8e530f61d8c8" translate="yes" xml:space="preserve">
          <source>Note that comparing values where either</source>
          <target state="translated">값이 비교되는 경우</target>
        </trans-unit>
        <trans-unit id="61ad454c89c5d8b5cf4059acd78469532471749f" translate="yes" xml:space="preserve">
          <source>Note that composition transformation operates pixelwise. For that reason, there is a difference between using the graphic primitive itself and its bounding rectangle: The bounding rect contains pixels with alpha == 0 (i.e the pixels surrounding the primitive). These pixels will overwrite the other image's pixels, effectively clearing those, while the primitive only overwrites its own area.</source>
          <target state="translated">컴포지션 변환은 픽셀 단위로 작동합니다. 이러한 이유로 그래픽 프리미티브 자체와 그 경계 사각형을 사용하는 것에는 차이가 있습니다. 바운딩 rect는 alpha == 0 인 픽셀을 포함합니다 (즉, 프리미티브를 둘러싸는 픽셀). 이 픽셀은 다른 이미지의 픽셀을 덮어 쓰기하여 효과적으로 지우는 반면, 기본은 자신의 영역 만 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="4a93e55b1cf45a7fa51929bac385a9c6cfc7f660" translate="yes" xml:space="preserve">
          <source>Note that custom datatypes must be declared as &lt;a href=&quot;qmetaobject&quot;&gt;meta objects&lt;/a&gt; and that stream operators must be implemented for them. See the &lt;a href=&quot;qmetaobject&quot;&gt;QMetaObject&lt;/a&gt; class description for details.</source>
          <target state="translated">사용자 정의 데이터 유형은 &lt;a href=&quot;qmetaobject&quot;&gt;메타 오브젝트&lt;/a&gt; 로 선언해야하며 스트림 연산자는이를 구현해야합니다. 자세한 내용은 &lt;a href=&quot;qmetaobject&quot;&gt;QMetaObject&lt;/a&gt; 클래스 설명을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1e2743a9f2f37d3ec6ecd1f9bad8f8ac52079bb5" translate="yes" xml:space="preserve">
          <source>Note that custom datatypes used in item views must be declared as &lt;a href=&quot;qmetaobject&quot;&gt;meta objects&lt;/a&gt; and that stream operators for them must be implemented.</source>
          <target state="translated">항목보기에 사용 된 사용자 정의 데이터 유형은 &lt;a href=&quot;qmetaobject&quot;&gt;메타 오브젝트&lt;/a&gt; 로 선언되어야하며 해당 유형에 대한 스트림 연산자를 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="7ff8be836b633828f5d62b1ac450c5a59a213ff5" translate="yes" xml:space="preserve">
          <source>Note that custom views may interpret the concepts of next and previous differently.</source>
          <target state="translated">사용자 정의보기는 다음과 이전의 개념을 다르게 해석 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eacba435b9fceb3e8f81a22dc5846651c217050b" translate="yes" xml:space="preserve">
          <source>Note that data can be written to the socket immediately after the return from &lt;a href=&quot;qsslsocket#connectToHostEncrypted&quot;&gt;connectToHostEncrypted&lt;/a&gt;() (i.e., before the &lt;a href=&quot;qsslsocket#encrypted&quot;&gt;encrypted&lt;/a&gt;() signal is emitted). The data is queued in &lt;a href=&quot;qsslsocket&quot;&gt;QSslSocket&lt;/a&gt; until after the &lt;a href=&quot;qsslsocket#encrypted&quot;&gt;encrypted&lt;/a&gt;() signal is emitted.</source>
          <target state="translated">&lt;a href=&quot;qsslsocket#connectToHostEncrypted&quot;&gt;connectToHostEncrypted&lt;/a&gt; () 에서 리턴 한 직후 (즉, &lt;a href=&quot;qsslsocket#encrypted&quot;&gt;암호화 된&lt;/a&gt; () 신호가 생성 되기 전에) 소켓에 데이터를 쓸 수 있습니다 . 데이터는 &lt;a href=&quot;qsslsocket#encrypted&quot;&gt;암호화 된&lt;/a&gt; () 신호가 방출 될 때까지 &lt;a href=&quot;qsslsocket&quot;&gt;QSslSocket에&lt;/a&gt; 대기 합니다.</target>
        </trans-unit>
        <trans-unit id="d888b2f27b21247d23b9b0d29541265909c997a6" translate="yes" xml:space="preserve">
          <source>Note that data can be written to the socket immediately after the return from &lt;a href=&quot;qsslsocket#connectToHostEncrypted&quot;&gt;connectToHostEncrypted&lt;/a&gt;() (i.e., before the &lt;a href=&quot;qsslsocket#encrypted&quot;&gt;encrypted&lt;/a&gt;() signal is emitted). The data is queued in QSslSocket until after the &lt;a href=&quot;qsslsocket#encrypted&quot;&gt;encrypted&lt;/a&gt;() signal is emitted.</source>
          <target state="translated">데이터는 &lt;a href=&quot;qsslsocket#connectToHostEncrypted&quot;&gt;connectToHostEncrypted&lt;/a&gt; () 에서 반환 된 직후 (즉, &lt;a href=&quot;qsslsocket#encrypted&quot;&gt;암호화 된&lt;/a&gt; () 신호가 방출 되기 전에) 소켓에 기록 될 수 있습니다 . 데이터는 &lt;a href=&quot;qsslsocket#encrypted&quot;&gt;암호화 된&lt;/a&gt; () 신호가 방출 될 때까지 QSslSocket에 대기 합니다.</target>
        </trans-unit>
        <trans-unit id="0f3949d9d7e2d5ff3ff35b13974fc07186a04323" translate="yes" xml:space="preserve">
          <source>Note that datagrams can be transmitted with no data, so the returned &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; may be empty.</source>
          <target state="translated">데이터 그램은 데이터없이 전송 될 수 있으므로 반환 된 &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; 가 비어있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4efa978bda74fc870cadbf4bbf2827a4bc6f0d9e" translate="yes" xml:space="preserve">
          <source>Note that declaring a &lt;a href=&quot;qml-qtlocation-mapcopyrightnotice&quot;&gt;MapCopyrightNotice&lt;/a&gt; inside a &lt;a href=&quot;qml-qtlocation-map&quot;&gt;QtLocation::Map&lt;/a&gt; element is not possible, like for any other &lt;a href=&quot;qquickitem&quot;&gt;QQuickItem&lt;/a&gt;.</source>
          <target state="translated">다른 &lt;a href=&quot;qquickitem&quot;&gt;QQuickItem&lt;/a&gt; 과 마찬가지로 &lt;a href=&quot;qml-qtlocation-map&quot;&gt;QtLocation :: Map&lt;/a&gt; 요소 내에 &lt;a href=&quot;qml-qtlocation-mapcopyrightnotice&quot;&gt;MapCopyrightNotice&lt;/a&gt; 를 선언 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="588ad0c28b5d619808ad31e70fb16735a0bb641e" translate="yes" xml:space="preserve">
          <source>Note that declaring a MapCopyrightNotice inside a &lt;a href=&quot;qml-qtlocation-map&quot;&gt;QtLocation::Map&lt;/a&gt; element is not possible, like for any other &lt;a href=&quot;qquickitem&quot;&gt;QQuickItem&lt;/a&gt;.</source>
          <target state="translated">다른 &lt;a href=&quot;qquickitem&quot;&gt;QQuickItem&lt;/a&gt; 과 마찬가지로 &lt;a href=&quot;qml-qtlocation-map&quot;&gt;QtLocation :: Map&lt;/a&gt; 요소 내에서 MapCopyrightNotice 를 선언 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="690a376a1f59531760b717ba5655eef60fc40ee0" translate="yes" xml:space="preserve">
          <source>Note that deleting a &lt;a href=&quot;qthread&quot;&gt;QThread&lt;/a&gt; object will not stop the execution of the thread it manages. Deleting a running &lt;a href=&quot;qthread&quot;&gt;QThread&lt;/a&gt; (i.e. &lt;a href=&quot;qthread#isFinished&quot;&gt;isFinished&lt;/a&gt;() returns &lt;code&gt;false&lt;/code&gt;) will result in a program crash. Wait for the &lt;a href=&quot;qthread#finished&quot;&gt;finished&lt;/a&gt;() signal before deleting the &lt;a href=&quot;qthread&quot;&gt;QThread&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qthread&quot;&gt;QThread&lt;/a&gt; 객체 를 삭제 해도 관리하는 스레드의 실행이 중지되지는 않습니다. 실행중인 &lt;a href=&quot;qthread&quot;&gt;QThread를&lt;/a&gt; 삭제하면 (즉, &lt;a href=&quot;qthread#isFinished&quot;&gt;isFinished&lt;/a&gt; ()는 &lt;code&gt;false&lt;/code&gt; 를 반환 함 ) 프로그램 충돌이 발생합니다. &lt;a href=&quot;qthread&quot;&gt;QThread&lt;/a&gt; 를 삭제하기 전에 &lt;a href=&quot;qthread#finished&quot;&gt;완료&lt;/a&gt; () 신호를 기다 립니다.</target>
        </trans-unit>
        <trans-unit id="88be7f7359ef57ce9d46f02cd011581b72e7a4bd" translate="yes" xml:space="preserve">
          <source>Note that display of messages are dependent on the system configuration and user preferences, and that messages may not appear at all. Hence, it should not be relied upon as the sole means for providing critical information.</source>
          <target state="translated">메시지 표시는 시스템 구성 및 사용자 기본 설정에 따라 다르며 메시지가 전혀 표시되지 않을 수 있습니다. 따라서 중요한 정보를 제공하는 유일한 수단으로 의존해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="294085a0c6b4261e722d56e7979363ecac1974c8" translate="yes" xml:space="preserve">
          <source>Note that due to C++ literal strings rules, you must escape all backslashes inside the pattern string with another backslash:</source>
          <target state="translated">C ++ 리터럴 문자열 규칙으로 인해 패턴 문자열 내부의 모든 백 슬래시를 다른 백 슬래시로 이스케이프해야합니다.</target>
        </trans-unit>
        <trans-unit id="165292cbf6379c14bebcf68edabe701c1dc348b4" translate="yes" xml:space="preserve">
          <source>Note that due to the way &lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt; and &lt;a href=&quot;qrectf&quot;&gt;QRectF&lt;/a&gt; are defined, an empty &lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt; is defined in essentially the same way as &lt;a href=&quot;qrectf&quot;&gt;QRectF&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt; 및 &lt;a href=&quot;qrectf&quot;&gt;QRectF&lt;/a&gt; 가 정의 되는 방식으로 인해 빈 &lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt; 는 &lt;a href=&quot;qrectf&quot;&gt;QRectF&lt;/a&gt; 와 기본적으로 동일한 방식으로 정의 됩니다.</target>
        </trans-unit>
        <trans-unit id="c789f311ac4aaeb0c962769c47f5c3f619d8e737" translate="yes" xml:space="preserve">
          <source>Note that due to the way &lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt; and &lt;a href=&quot;qrectf&quot;&gt;QRectF&lt;/a&gt; are defined, an empty &lt;a href=&quot;qrectf&quot;&gt;QRectF&lt;/a&gt; is defined in essentially the same way as &lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt; 및 &lt;a href=&quot;qrectf&quot;&gt;QRectF&lt;/a&gt; 가 정의 된 방식으로 인해 빈 &lt;a href=&quot;qrectf&quot;&gt;QRectF&lt;/a&gt; 는 본질적으로 &lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt; 와 동일한 방식으로 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="bd887292a90c5d537453461d68f1a0a80930a8cf" translate="yes" xml:space="preserve">
          <source>Note that due to the way &lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt; and QRectF are defined, an empty QRectF is defined in essentially the same way as &lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt; 및 QRectF가 정의 되는 방식으로 인해 빈 QRectF는 본질적으로 &lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt; 와 동일한 방식으로 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="95ecef32749fa3dce5ff82856d6ae89484fd7efe" translate="yes" xml:space="preserve">
          <source>Note that due to the way QRect and &lt;a href=&quot;qrectf&quot;&gt;QRectF&lt;/a&gt; are defined, an empty QRect is defined in essentially the same way as &lt;a href=&quot;qrectf&quot;&gt;QRectF&lt;/a&gt;.</source>
          <target state="translated">QRect 및 &lt;a href=&quot;qrectf&quot;&gt;QRectF&lt;/a&gt; 가 정의 되는 방식으로 인해 빈 QRect는 본질적으로 &lt;a href=&quot;qrectf&quot;&gt;QRectF&lt;/a&gt; 와 동일한 방식으로 정의 됩니다.</target>
        </trans-unit>
        <trans-unit id="6681b016434e11ab7ee9f0c24b422487bc670111" translate="yes" xml:space="preserve">
          <source>Note that each &lt;a href=&quot;qml-qtqml-component&quot;&gt;Component&lt;/a&gt; object declaration creates its own</source>
          <target state="translated">각 &lt;a href=&quot;qml-qtqml-component&quot;&gt;Component&lt;/a&gt; 객체 선언은 고유 한</target>
        </trans-unit>
        <trans-unit id="809e98fdcdf42c64eb4aea334339ae2853cf16c9" translate="yes" xml:space="preserve">
          <source>Note that elements added as closed subpaths using the &lt;a href=&quot;qpainterpath#addEllipse&quot;&gt;addEllipse&lt;/a&gt;(), &lt;a href=&quot;qpainterpath#addPath&quot;&gt;addPath&lt;/a&gt;(), &lt;a href=&quot;qpainterpath#addPolygon&quot;&gt;addPolygon&lt;/a&gt;(), &lt;a href=&quot;qpainterpath#addRect&quot;&gt;addRect&lt;/a&gt;(), &lt;a href=&quot;qpainterpath#addRegion&quot;&gt;addRegion&lt;/a&gt;() and &lt;a href=&quot;qpainterpath#addText&quot;&gt;addText&lt;/a&gt;() convenience functions, is actually added to the path as a collection of separate elements using the &lt;a href=&quot;qpainterpath#moveTo&quot;&gt;moveTo&lt;/a&gt;(), &lt;a href=&quot;qpainterpath#lineTo&quot;&gt;lineTo&lt;/a&gt;() and &lt;a href=&quot;qpainterpath#cubicTo&quot;&gt;cubicTo&lt;/a&gt;() functions.</source>
          <target state="translated">요소가 사용 닫힌 윤곽선으로서 첨가 유의 &lt;a href=&quot;qpainterpath#addEllipse&quot;&gt;addEllipse&lt;/a&gt; () &lt;a href=&quot;qpainterpath#addPath&quot;&gt;addPath&lt;/a&gt; () &lt;a href=&quot;qpainterpath#addPolygon&quot;&gt;addPolygon&lt;/a&gt; () &lt;a href=&quot;qpainterpath#addRect&quot;&gt;addRect&lt;/a&gt; () &lt;a href=&quot;qpainterpath#addRegion&quot;&gt;addRegion&lt;/a&gt; () 및 &lt;a href=&quot;qpainterpath#addText&quot;&gt;addText&lt;/a&gt; () 편의 기능은 실제로 이용 개별 요소의 모음으로의 경로에 추가 &lt;a href=&quot;qpainterpath#moveTo&quot;&gt;의 moveTo을&lt;/a&gt; (), &lt;a href=&quot;qpainterpath#lineTo&quot;&gt;lineTo&lt;/a&gt; () 및 &lt;a href=&quot;qpainterpath#cubicTo&quot;&gt;cubicTo&lt;/a&gt; () 함수.</target>
        </trans-unit>
        <trans-unit id="efd9eaba1554d92c34691a74eca3d710c2c92e54" translate="yes" xml:space="preserve">
          <source>Note that entering and leaving a new event loop (e.g., by opening a modal dialog) will</source>
          <target state="translated">새 이벤트 루프를 시작하거나 종료하면 (예 : 모달 대화 상자를 열어서)</target>
        </trans-unit>
        <trans-unit id="170d411e8cec285c953b113a959808e290914f4d" translate="yes" xml:space="preserve">
          <source>Note that error codes are sensor-specific.</source>
          <target state="translated">오류 코드는 센서마다 다릅니다.</target>
        </trans-unit>
        <trans-unit id="16988d0fb5c4fbbaacace40238a420272a9f3879" translate="yes" xml:space="preserve">
          <source>Note that even a disabled tab/page may be visible. If the page is visible already, &lt;a href=&quot;qtabwidget&quot;&gt;QTabWidget&lt;/a&gt; will not hide it; if all the pages are disabled, &lt;a href=&quot;qtabwidget&quot;&gt;QTabWidget&lt;/a&gt; will show one of them.</source>
          <target state="translated">비활성화 된 탭 / 페이지도 표시 될 수 있습니다. 페이지가 이미 표시되어 있으면 &lt;a href=&quot;qtabwidget&quot;&gt;QTabWidget&lt;/a&gt; 은 해당 페이지를 숨기지 않습니다. 모든 페이지가 비활성화되면 &lt;a href=&quot;qtabwidget&quot;&gt;QTabWidget&lt;/a&gt; 이 그 중 하나를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="0cfaef1849684d1c22c183b120e39ba011fbaa2c" translate="yes" xml:space="preserve">
          <source>Note that even if &lt;a href=&quot;qlocale&quot;&gt;QLocale&lt;/a&gt; object was constructed with an explicit script, name() will not contain it for compatibility reasons. Use &lt;a href=&quot;qlocale#bcp47Name&quot;&gt;bcp47Name&lt;/a&gt;() instead if you need a full locale name.</source>
          <target state="translated">경우에도주의 &lt;a href=&quot;qlocale&quot;&gt;QLocale의&lt;/a&gt; 객체가 명시 적 스크립트로 구성되었으며, 이름 () 호환성을 위해 포함되지 않습니다. 전체 로케일 이름이 필요한 경우 &lt;a href=&quot;qlocale#bcp47Name&quot;&gt;bcp47Name&lt;/a&gt; ()을 대신 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="48d7284e7117b17d3277cc443cb0b82fc40cedfd" translate="yes" xml:space="preserve">
          <source>Note that even if successive tests return the exact same results (or empty results), a change notification will be emitted at every test.</source>
          <target state="translated">연속 테스트에서 정확히 동일한 결과 (또는 빈 결과)를 반환하더라도 모든 테스트에서 변경 알림이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="4608acbe844f1ebc93b49fb06e1cf1d2d02b89a5" translate="yes" xml:space="preserve">
          <source>Note that even if wrapping is enabled, the cell will not be expanded to fit all text. Ellipsis will be inserted according to the current &lt;a href=&quot;qabstractitemview#textElideMode-prop&quot;&gt;textElideMode&lt;/a&gt;.</source>
          <target state="translated">줄 바꿈을 사용하더라도 셀이 모든 텍스트에 맞게 확장되지는 않습니다. 현재 &lt;a href=&quot;qabstractitemview#textElideMode-prop&quot;&gt;textElideMode&lt;/a&gt; 에 따라 줄임표가 삽입됩니다 .</target>
        </trans-unit>
        <trans-unit id="186f8f25b38a9339b6c67c229a4831465b6e6056" translate="yes" xml:space="preserve">
          <source>Note that even of wrapping is enabled, the cell will not be expanded to fit all text. Ellipsis will be inserted according to the current &lt;a href=&quot;qabstractitemview#textElideMode-prop&quot;&gt;textElideMode&lt;/a&gt;.</source>
          <target state="translated">줄 바꿈을 사용하더라도 셀이 모든 텍스트에 맞게 확장되지는 않습니다. 현재 &lt;a href=&quot;qabstractitemview#textElideMode-prop&quot;&gt;textElideMode&lt;/a&gt; 에 따라 줄임표가 삽입됩니다 .</target>
        </trans-unit>
        <trans-unit id="f1ca8bae3895a72e4d03fb6c1cc2cb2fb34a4f9e" translate="yes" xml:space="preserve">
          <source>Note that even though only the element at index 2 is modified in the loop, the three bindings will all be re-evaluated since the granularity of the change signal is that the entire property has changed. As such, adding an intermediate binding can sometimes be beneficial:</source>
          <target state="translated">루프에서 인덱스 2의 요소 만 수정하더라도 변경 신호의 세분성이 전체 속성이 변경 되었기 때문에 세 개의 바인딩이 모두 재평가됩니다. 따라서 중간 바인딩을 추가하면 유익 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ffea268c20772709a879b295e77d493a9833aab" translate="yes" xml:space="preserve">
          <source>Note that for Oracle databases the row's ROWID will be returned, while for MySQL databases the row's auto-increment field will be returned.</source>
          <target state="translated">Oracle 데이터베이스의 경우 행의 ROWID가 반환되고 MySQL 데이터베이스의 경우 행의 자동 증가 필드가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="18f546d3685b9168b9ab54d5c053508f09d5260b" translate="yes" xml:space="preserve">
          <source>Note that for a single line of text, the size of the text is the area of the text. In this common case, all alignments are equivalent. If you want the text to be, say, centered in its parent, then you will need to either modify the &lt;a href=&quot;qml-qtquick-item#anchors-prop&quot;&gt;Item::anchors&lt;/a&gt;, or set &lt;a href=&quot;qml-qtquick-text#horizontalAlignment-prop&quot;&gt;horizontalAlignment&lt;/a&gt; to Text.AlignHCenter and bind the width to that of the parent.</source>
          <target state="translated">한 줄의 텍스트에서 텍스트의 크기는 텍스트의 영역입니다. 이 일반적인 경우 모든 정렬은 동일합니다. 텍스트를 부모의 가운데에 배치하려면 &lt;a href=&quot;qml-qtquick-item#anchors-prop&quot;&gt;Item :: anchors를&lt;/a&gt; 수정 하거나 &lt;a href=&quot;qml-qtquick-text#horizontalAlignment-prop&quot;&gt;horizontalAlignment&lt;/a&gt; 를 Text.AlignHCenter로 설정 하고 너비를 부모의 너비에 바인딩해야합니다.</target>
        </trans-unit>
        <trans-unit id="9c2346327725ea3e995ab331e4784543522316d1" translate="yes" xml:space="preserve">
          <source>Note that for an application- or module-wide cleanup, qAddPostRoutine() is often not suitable. For example, if the program is split into dynamically loaded modules, the relevant module may be unloaded long before the &lt;a href=&quot;qcoreapplication&quot;&gt;QCoreApplication&lt;/a&gt; destructor is called. In such cases, if using qAddPostRoutine() is still desirable, &lt;a href=&quot;qcoreapplication#qRemovePostRoutine&quot;&gt;qRemovePostRoutine&lt;/a&gt;() can be used to prevent a routine from being called by the &lt;a href=&quot;qcoreapplication&quot;&gt;QCoreApplication&lt;/a&gt; destructor. For example, if that routine was called before the module was unloaded.</source>
          <target state="translated">응용 프로그램 또는 모듈 전체 정리의 경우 qAddPostRoutine ()이 적합하지 않은 경우가 있습니다. 예를 들어, 프로그램이 동적으로로드 된 모듈로 분할 된 경우 &lt;a href=&quot;qcoreapplication&quot;&gt;QCoreApplication&lt;/a&gt; 소멸자가 호출 되기 훨씬 전에 관련 모듈이 언로드 될 수 있습니다 . 이러한 경우 qAddPostRoutine ()을 사용하는 것이 여전히 바람직한 경우 &lt;a href=&quot;qcoreapplication#qRemovePostRoutine&quot;&gt;qRemovePostRoutine&lt;/a&gt; ()을 사용하여 &lt;a href=&quot;qcoreapplication&quot;&gt;QCoreApplication&lt;/a&gt; 소멸자 가 루틴을 호출하지 못하게 할 수 있습니다 . 예를 들어, 모듈이 언로드되기 전에 해당 루틴이 호출 된 경우.</target>
        </trans-unit>
        <trans-unit id="d44de2f763b7121990e47a1e3c9eb266528f1709" translate="yes" xml:space="preserve">
          <source>Note that for efficiency, the local name string is not stored in the &lt;a href=&quot;qxmlname&quot;&gt;QXmlName&lt;/a&gt; but in the &lt;a href=&quot;qxmlnamepool&quot;&gt;QXmlNamePool&lt;/a&gt; that was passed to the constructor. Hence, that same</source>
          <target state="translated">효율성을 위해 로컬 이름 문자열은 &lt;a href=&quot;qxmlname&quot;&gt;QXmlName에&lt;/a&gt; 저장되지 않고 생성자에 전달 된 &lt;a href=&quot;qxmlnamepool&quot;&gt;QXmlNamePool&lt;/a&gt; 에 저장됩니다 . 따라서 동일</target>
        </trans-unit>
        <trans-unit id="4b06e79fc927f5bba4d2b8e7ce804bccd07a39e7" translate="yes" xml:space="preserve">
          <source>Note that for efficiency, the namespace URI string is not stored in the &lt;a href=&quot;qxmlname&quot;&gt;QXmlName&lt;/a&gt; but in the &lt;a href=&quot;qxmlnamepool&quot;&gt;QXmlNamePool&lt;/a&gt; that was passed to the constructor. Hence, that same</source>
          <target state="translated">효율성을 위해 네임 스페이스 URI 문자열은 &lt;a href=&quot;qxmlname&quot;&gt;QXmlName에&lt;/a&gt; 저장되지 않고 생성자에 전달 된 &lt;a href=&quot;qxmlnamepool&quot;&gt;QXmlNamePool&lt;/a&gt; 에 저장됩니다 . 따라서 동일</target>
        </trans-unit>
        <trans-unit id="a2da0c84ec79e2e522e648ad834973c633ded906" translate="yes" xml:space="preserve">
          <source>Note that for efficiency, the namespace URI, local name, and prefix strings are not stored in the &lt;a href=&quot;qxmlname&quot;&gt;QXmlName&lt;/a&gt; but in the &lt;a href=&quot;qxmlnamepool&quot;&gt;QXmlNamePool&lt;/a&gt; that was passed to the constructor. Hence, that same</source>
          <target state="translated">효율성을 위해 네임 스페이스 URI, 로컬 이름 및 접두사 문자열은 &lt;a href=&quot;qxmlname&quot;&gt;QXmlName이&lt;/a&gt; 아니라 생성자에 전달 된 &lt;a href=&quot;qxmlnamepool&quot;&gt;QXmlNamePool&lt;/a&gt; 에 저장됩니다 . 따라서 동일</target>
        </trans-unit>
        <trans-unit id="6967884a328e5a24bdd366889923f1ef1f6a1142" translate="yes" xml:space="preserve">
          <source>Note that for efficiency, the prefix string is not stored in the &lt;a href=&quot;qxmlname&quot;&gt;QXmlName&lt;/a&gt; but in the &lt;a href=&quot;qxmlnamepool&quot;&gt;QXmlNamePool&lt;/a&gt; that was passed to the constructor. Hence, that same</source>
          <target state="translated">효율성을 위해 접두사 문자열은 &lt;a href=&quot;qxmlname&quot;&gt;QXmlName에&lt;/a&gt; 저장되지 않고 생성자에 전달 된 &lt;a href=&quot;qxmlnamepool&quot;&gt;QXmlNamePool&lt;/a&gt; 에 저장됩니다 . 따라서 동일</target>
        </trans-unit>
        <trans-unit id="ac4c14f7f135949b9657e88babe097d9c5ffa0ac" translate="yes" xml:space="preserve">
          <source>Note that for historical reasons the return value of the &lt;a href=&quot;qrect#right&quot;&gt;QRect::right&lt;/a&gt;() and &lt;a href=&quot;qrect#bottom&quot;&gt;QRect::bottom&lt;/a&gt;() functions deviate from the true bottom-right corner of the rectangle.</source>
          <target state="translated">역사적 이유로 &lt;a href=&quot;qrect#right&quot;&gt;QRect :: right&lt;/a&gt; () 및 &lt;a href=&quot;qrect#bottom&quot;&gt;QRect :: bottom&lt;/a&gt; () 함수 의 반환 값은 사각형의 오른쪽 아래 모서리에서 벗어납니다.</target>
        </trans-unit>
        <trans-unit id="67b1031dd9528499dae500e642c3cbe6c63ed2c9" translate="yes" xml:space="preserve">
          <source>Note that for historical reasons the values returned by the &lt;a href=&quot;qrect#bottom&quot;&gt;bottom&lt;/a&gt;() and &lt;a href=&quot;qrect#right&quot;&gt;right&lt;/a&gt;() functions deviate from the true bottom-right corner of the rectangle: The &lt;a href=&quot;qrect#right&quot;&gt;right&lt;/a&gt;() function returns</source>
          <target state="translated">역사적 이유로 &lt;a href=&quot;qrect#bottom&quot;&gt;bottom&lt;/a&gt; () 및 &lt;a href=&quot;qrect#right&quot;&gt;right&lt;/a&gt; () 함수가 반환 한 값 은 사각형의 오른쪽 아래 모서리에서 벗어납니다. &lt;a href=&quot;qrect#right&quot;&gt;right&lt;/a&gt; () 함수는</target>
        </trans-unit>
        <trans-unit id="2df9678ea36558c501bb251a5c8de59ba618d277" translate="yes" xml:space="preserve">
          <source>Note that for historical reasons this function returns &lt;a href=&quot;qpoint&quot;&gt;QPoint&lt;/a&gt;(&lt;a href=&quot;qrect#left&quot;&gt;left&lt;/a&gt;() + &lt;a href=&quot;qrect#width&quot;&gt;width&lt;/a&gt;() -1, &lt;a href=&quot;qrect#top&quot;&gt;top&lt;/a&gt;() + &lt;a href=&quot;qrect#height&quot;&gt;height&lt;/a&gt;() - 1).</source>
          <target state="translated">역사적 이유로이 함수는 &lt;a href=&quot;qpoint&quot;&gt;QPoint&lt;/a&gt; ( &lt;a href=&quot;qrect#left&quot;&gt;left&lt;/a&gt; () + &lt;a href=&quot;qrect#width&quot;&gt;width&lt;/a&gt; () -1, &lt;a href=&quot;qrect#top&quot;&gt;top&lt;/a&gt; () + &lt;a href=&quot;qrect#height&quot;&gt;height&lt;/a&gt; () -1 )를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="7f3f7d27b0d7d166ef592bfdbdb2a46b466016d8" translate="yes" xml:space="preserve">
          <source>Note that for historical reasons this function returns &lt;a href=&quot;qpoint&quot;&gt;QPoint&lt;/a&gt;(&lt;a href=&quot;qrect#left&quot;&gt;left&lt;/a&gt;() + &lt;a href=&quot;qrect#width&quot;&gt;width&lt;/a&gt;() -1, &lt;a href=&quot;qrect#top&quot;&gt;top&lt;/a&gt;()).</source>
          <target state="translated">역사적 이유로이 함수는 &lt;a href=&quot;qpoint&quot;&gt;QPoint&lt;/a&gt; ( &lt;a href=&quot;qrect#left&quot;&gt;left&lt;/a&gt; () + &lt;a href=&quot;qrect#width&quot;&gt;width&lt;/a&gt; () -1, &lt;a href=&quot;qrect#top&quot;&gt;top&lt;/a&gt; ())를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="8f44d88685b93a80897173ff992bffbe612cc19f" translate="yes" xml:space="preserve">
          <source>Note that for historical reasons this function returns &lt;a href=&quot;qrect#left&quot;&gt;left&lt;/a&gt;() + &lt;a href=&quot;qrect#width&quot;&gt;width&lt;/a&gt;() - 1; use &lt;a href=&quot;qrect#x&quot;&gt;x&lt;/a&gt;() + &lt;a href=&quot;qrect#width&quot;&gt;width&lt;/a&gt;() to retrieve the true x-coordinate.</source>
          <target state="translated">역사적 이유로이 함수는 &lt;a href=&quot;qrect#left&quot;&gt;left&lt;/a&gt; () + &lt;a href=&quot;qrect#width&quot;&gt;width&lt;/a&gt; ()-1을 반환합니다 . 사용 &lt;a href=&quot;qrect#x&quot;&gt;X는&lt;/a&gt; () + &lt;a href=&quot;qrect#width&quot;&gt;폭&lt;/a&gt; () 실제 X 좌표를 검색한다.</target>
        </trans-unit>
        <trans-unit id="02017018df965bf31b87da8e65bbb30d100db747" translate="yes" xml:space="preserve">
          <source>Note that for historical reasons this function returns &lt;a href=&quot;qrect#top&quot;&gt;top&lt;/a&gt;() + &lt;a href=&quot;qrect#height&quot;&gt;height&lt;/a&gt;() - 1; use &lt;a href=&quot;qrect#y&quot;&gt;y&lt;/a&gt;() + &lt;a href=&quot;qrect#height&quot;&gt;height&lt;/a&gt;() to retrieve the true y-coordinate.</source>
          <target state="translated">역사적 이유로이 함수는 &lt;a href=&quot;qrect#top&quot;&gt;top&lt;/a&gt; () + &lt;a href=&quot;qrect#height&quot;&gt;height&lt;/a&gt; ()-1을 반환합니다 . 사용 &lt;a href=&quot;qrect#y&quot;&gt;예&lt;/a&gt; () + &lt;a href=&quot;qrect#height&quot;&gt;높이&lt;/a&gt; () 진정한 Y 좌표를 검색한다.</target>
        </trans-unit>
        <trans-unit id="a804c6a5236f49ec4666591cfc5c7ac7f089314b" translate="yes" xml:space="preserve">
          <source>Note that for icons to appear in buttons in a &lt;a href=&quot;qdialogbuttonbox&quot;&gt;QDialogButtonBox&lt;/a&gt;, you need to set the dialogbuttonbox-buttons-have-icons property to true. Also, to customize the size of the icons, use the icon-size property.</source>
          <target state="translated">&lt;a href=&quot;qdialogbuttonbox&quot;&gt;QDialogButtonBox의&lt;/a&gt; 버튼에 아이콘이 나타나 려면 dialogbuttonbox-buttons-have-icons 속성을 true로 설정해야합니다. 또한 아이콘 크기를 사용자 정의하려면 icon-size 특성을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="195e0d1bd485aca9927339619f04da751b46de00" translate="yes" xml:space="preserve">
          <source>Note that for nested Flickables with pressDelay set, the pressDelay of outer Flickables is overridden by the innermost Flickable. If the drag exceeds the platform drag threshold, the press event will be delivered regardless of this property.</source>
          <target state="translated">pressDelay가 설정된 중첩 된 Flickables의 경우 외부 Flickables의 pressDelay가 가장 안쪽 Flickable에 의해 재정의됩니다. 드래그가 플랫폼 드래그 임계 값을 초과하면이 속성에 관계없이 프레스 이벤트가 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="22e5e43cd11b59116f942d146d458caf124b3af7" translate="yes" xml:space="preserve">
          <source>Note that for some plain text strings containing XML meta-characters, the auto-text &lt;a href=&quot;qt-sub-qtgui#mightBeRichText&quot;&gt;rich text detection test&lt;/a&gt; may fail causing your plain text string to be interpreted incorrectly as rich text. In these rare cases, use &lt;a href=&quot;qt-sub-qtgui#convertFromPlainText&quot;&gt;Qt::convertFromPlainText&lt;/a&gt;() to convert your plain text string to a visually equivalent rich text string, or set the &lt;a href=&quot;qmessagebox#textFormat-prop&quot;&gt;text format&lt;/a&gt; property explicitly with &lt;a href=&quot;qmessagebox#textFormat-prop&quot;&gt;setTextFormat&lt;/a&gt;().</source>
          <target state="translated">XML 메타 문자를 포함하는 일부 일반 텍스트 문자열의 경우 자동 텍스트 &lt;a href=&quot;qt-sub-qtgui#mightBeRichText&quot;&gt;리치 텍스트 감지 테스트&lt;/a&gt; 가 실패하여 일반 텍스트 문자열이 리치 텍스트로 잘못 해석 될 수 있습니다. 드문 경우이지만 &lt;a href=&quot;qt-sub-qtgui#convertFromPlainText&quot;&gt;Qt :: convertFromPlainText&lt;/a&gt; ()를 사용하여 일반 텍스트 문자열을 시각적으로 동등한 리치 텍스트 문자열로 변환하거나 &lt;a href=&quot;qmessagebox#textFormat-prop&quot;&gt;setTextFormat&lt;/a&gt; ()을 사용하여 &lt;a href=&quot;qmessagebox#textFormat-prop&quot;&gt;텍스트 형식&lt;/a&gt; 속성을 명시 적으로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="6dba32cfff614823f0dfc07797ab56d35c15277f" translate="yes" xml:space="preserve">
          <source>Note that for the moment, alpha masks on monochrome images are ignored.</source>
          <target state="translated">현재 흑백 이미지의 알파 마스크는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="f505b1de5ccceadfb4a8ab01281bd656c0ca3ed5" translate="yes" xml:space="preserve">
          <source>Note that for the single selection mode, the current item will be in the selection. In the multi-selection and extended selection modes, the current item may not lie within the selection, depending on the way the user formed the selection.</source>
          <target state="translated">단일 선택 모드의 경우 현재 항목이 선택됩니다. 다중 선택 및 확장 선택 모드에서 사용자가 선택을 구성한 방식에 따라 현재 항목이 선택 내에 있지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f73cce5d7e5a062530a8de3a3893a4215374a83" translate="yes" xml:space="preserve">
          <source>Note that for the tool to generate the expected materials it will need to know about the whole scene and not just the material(s), for example the number of lights in the scene does also affect how the materials get generated, so all relevant qml files should be added to the list of files the tool needs to process.</source>
          <target state="translated">도구가 예상되는 재질을 생성하려면 재질뿐만 아니라 전체 장면에 대해 알아야합니다. 예를 들어 장면의 조명 수는 재질이 생성되는 방식에도 영향을 미치므로 모든 관련 qml 도구가 처리해야하는 파일 목록에 파일을 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="713c46fc3e762df83dfbe19f41638d9941f9e365" translate="yes" xml:space="preserve">
          <source>Note that for views with a large content size (more than 10 times the view size), the velocity of the flick may exceed the velocity of the touch in the case of multiple quick consecutive flicks. This allows the user to flick faster through large content.</source>
          <target state="translated">컨텐츠 크기가 큰 (뷰 크기의 10 배 이상) 뷰의 경우 연속으로 빠르게 여러 번 튕기는 경우 플릭 속도가 터치 속도를 초과 할 수 있습니다. 이를 통해 사용자는 대용량 콘텐츠를 빠르게 넘길 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b308372f575c8ed500a2abbac2963177ba7fc37c" translate="yes" xml:space="preserve">
          <source>Note that fromString() uses a &quot;C&quot; locale encoded string to convert milliseconds to a float value. If the default locale is not &quot;C&quot;, this may result in two conversion attempts (if the conversion fails for the default locale). This should be considered an implementation detail.</source>
          <target state="translated">fromString ()은 &quot;C&quot;로케일로 인코딩 된 문자열을 사용하여 밀리 초를 부동 소수점 값으로 변환합니다. 기본 로캘이 &quot;C&quot;가 아닌 경우 두 번의 변환 시도가 발생할 수 있습니다 (기본 로캘에 대한 변환이 실패한 경우). 이것은 구현 세부 사항으로 간주되어야합니다.</target>
        </trans-unit>
        <trans-unit id="603ca3815aa51d47d4fc3eda8695131e3460ea4f" translate="yes" xml:space="preserve">
          <source>Note that function values, variant values, and &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; values are objects, so this function returns true for such values.</source>
          <target state="translated">함수 값, 변형 값 및 &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 값은 객체 이므로이 함수는 해당 값에 대해 true를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e53b06f872020ebc0a54e119a7b976b3f16cd4e6" translate="yes" xml:space="preserve">
          <source>Note that if</source>
          <target state="translated">만약에</target>
        </trans-unit>
        <trans-unit id="eaf41539bdfb4fd3f39e405f8d3ea5c0f8a41de9" translate="yes" xml:space="preserve">
          <source>Note that if &lt;a href=&quot;qshareddatapointer#detach&quot;&gt;detach&lt;/a&gt;() is called more than once in a member function due to multiple dereferences of the</source>
          <target state="translated">경우 유의 &lt;a href=&quot;qshareddatapointer#detach&quot;&gt;분리가&lt;/a&gt; ()으로 인해 다수의 역 참조로 더 멤버 함수를 두 번 이상이라고</target>
        </trans-unit>
        <trans-unit id="e60d881f7285911354eed813f4214ff0ba97160b" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;highlightRangeMode&lt;/code&gt; is set to &lt;code&gt;StrictlyEnforceRange&lt;/code&gt; the currentIndex will be affected by dragging/flicking the view, since the view will always ensure that the &lt;code&gt;currentIndex&lt;/code&gt; is within the highlight range specified.</source>
          <target state="translated">&lt;code&gt;highlightRangeMode&lt;/code&gt; 가 &lt;code&gt;StrictlyEnforceRange&lt;/code&gt; 로 설정된 경우 뷰는 항상 &lt;code&gt;currentIndex&lt;/code&gt; 가 지정된 강조 표시 범위 내에 있도록 보장하기 때문에 뷰를 끌어서 이동하여 currentIndex에 영향을 줍니다.</target>
        </trans-unit>
        <trans-unit id="2123fa00aa289d952f9363835c1826907ba1d9e5" translate="yes" xml:space="preserve">
          <source>Note that if a &lt;a href=&quot;qml-qtquick-keynavigation&quot;&gt;KeyNavigation&lt;/a&gt; attached property receives the key press and release events for a requested arrow or tab key, the event is accepted and does not propagate any further.</source>
          <target state="translated">경우주의 &lt;a href=&quot;qml-qtquick-keynavigation&quot;&gt;KeyNavigation&lt;/a&gt; 연결된 속성이 요청 된 화살표 나 탭 키의 키 언론과 릴리스 이벤트를 수신, 이벤트가 인정되고 더 이상 전파되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0c5e52b7c561a34a89e642ef44a1b90b26b4a5df" translate="yes" xml:space="preserve">
          <source>Note that if a KeyNavigation attached property receives the key press and release events for a requested arrow or tab key, the event is accepted and does not propagate any further.</source>
          <target state="translated">KeyNavigation 연결된 속성이 요청 된 화살표 또는 탭 키에 대한 키 누르기 및 놓기 이벤트를 수신하면 해당 이벤트가 수락되고 더 이상 전파되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ad7e21b12dc235cb18f336676d4116dd6bb74b68" translate="yes" xml:space="preserve">
          <source>Note that if a QML document does not import a module which provides a particular QML object type, but attempts to use that object type anyway, an error will occur. For example, the following QML document does not import &lt;code&gt;QtQuick&lt;/code&gt; and thus attempting to use the &lt;code&gt;Rectangle&lt;/code&gt; type will fail:</source>
          <target state="translated">QML 문서가 특정 QML 오브젝트 유형을 제공하는 모듈을 가져 오지 않지만 해당 오브젝트 유형을 사용하려고 시도하면 오류가 발생합니다. 예를 들어, 다음 QML 문서는 &lt;code&gt;QtQuick&lt;/code&gt; 을 가져 오지 않으므로 &lt;code&gt;Rectangle&lt;/code&gt; 유형 을 사용하려고 하면 실패합니다.</target>
        </trans-unit>
        <trans-unit id="877239311b8229dbc42a6cb2a7dcd6874110fba9" translate="yes" xml:space="preserve">
          <source>Note that if a binding cannot be optimized by the QML engine's optimized binding expression evaluator, and thus must be evaluated by the full JavaScript environment, some of the tips listed above will no longer apply. For example, it can sometimes be beneficial to cache the result of property resolution in an intermediate JavaScript variable in a very complex binding. Upcoming sections have more information on these sorts of optimizations.</source>
          <target state="translated">QML 엔진의 최적화 된 바인딩 표현식 평가기로 바인딩을 최적화 할 수 없으므로 전체 JavaScript 환경에서 평가해야하는 경우 위에 나열된 일부 팁이 더 이상 적용되지 않습니다. 예를 들어, 속성 분석 결과를 매우 복잡한 바인딩으로 중간 JavaScript 변수에 캐시하는 것이 유익 할 수 있습니다. 다음 섹션에는 이러한 종류의 최적화에 대한 자세한 정보가 있습니다.</target>
        </trans-unit>
        <trans-unit id="4fc382e25e8b60dc9798023bb9fc0c80a890eae1" translate="yes" xml:space="preserve">
          <source>Note that if a control element is not listed here, it is because it uses a plain &lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption&lt;/a&gt; object.</source>
          <target state="translated">여기에 컨트롤 요소가 없으면 일반 &lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption&lt;/a&gt; 개체를 사용하기 때문 입니다.</target>
        </trans-unit>
        <trans-unit id="638909dd931eb31d278af6a5bfc249abbe52309c" translate="yes" xml:space="preserve">
          <source>Note that if a file with the name</source>
          <target state="translated">이름이 파일 인 경우</target>
        </trans-unit>
        <trans-unit id="d6c1f11ba9215a49c80cbd5fe0a97a1d1ed0dc1e" translate="yes" xml:space="preserve">
          <source>Note that if a model is reset it should be considered that all information previously retrieved from it is invalid. This includes but is not limited to the &lt;a href=&quot;qabstractitemmodel#rowCount&quot;&gt;rowCount&lt;/a&gt;() and &lt;a href=&quot;qabstractitemmodel#columnCount&quot;&gt;columnCount&lt;/a&gt;(), &lt;a href=&quot;qabstractitemmodel#flags&quot;&gt;flags&lt;/a&gt;(), data retrieved through &lt;a href=&quot;qabstractitemmodel#data&quot;&gt;data&lt;/a&gt;(), and &lt;a href=&quot;qabstractitemmodel#roleNames&quot;&gt;roleNames&lt;/a&gt;().</source>
          <target state="translated">모델이 재설정되면 이전에 검색된 모든 정보가 유효하지 않은 것으로 간주됩니다. 여기에는 &lt;a href=&quot;qabstractitemmodel#rowCount&quot;&gt;rowCount&lt;/a&gt; () 및 &lt;a href=&quot;qabstractitemmodel#columnCount&quot;&gt;columnCount&lt;/a&gt; (), &lt;a href=&quot;qabstractitemmodel#flags&quot;&gt;플래그&lt;/a&gt; (), 데이터를 통해 검색된 &lt;a href=&quot;qabstractitemmodel#data&quot;&gt;데이터&lt;/a&gt; () 및 &lt;a href=&quot;qabstractitemmodel#roleNames&quot;&gt;roleNames&lt;/a&gt; ()가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="19447e21c9dc73f42725507321637f24c8d00ddb" translate="yes" xml:space="preserve">
          <source>Note that if a primitive element is not listed here, it is because it uses a plain &lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption&lt;/a&gt; object.</source>
          <target state="translated">기본 요소가 여기에 나열되지 않으면 일반 &lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption&lt;/a&gt; 오브젝트를 사용하기 때문 입니다.</target>
        </trans-unit>
        <trans-unit id="8f08f14db1ddd0b5de168013033cf81834d446bb" translate="yes" xml:space="preserve">
          <source>Note that if a widget is set as modified, all its ancestors will also be set as modified. However, if you call &lt;code&gt;setWindowModified(false)&lt;/code&gt; on a widget, this will not propagate to its parent because other children of the parent might have been modified.</source>
          <target state="translated">위젯이 수정 된 것으로 설정되면 모든 조상도 수정 된 것으로 설정됩니다. 그러나 위젯에서 &lt;code&gt;setWindowModified(false)&lt;/code&gt; 를 호출하면 부모의 다른 자식이 수정되었을 수 있으므로 부모로 전파되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5346b31bf872a13afaf4e80d1b751badec8a81a7" translate="yes" xml:space="preserve">
          <source>Note that if changeSize() is called after the spacer item has been added to a layout, it is necessary to invalidate the layout in order for the spacer item's new size to take effect.</source>
          <target state="translated">스페이서 항목을 레이아웃에 추가 한 후 changeSize ()를 호출하면 스페이서 항목의 새 크기를 적용하기 위해 레이아웃을 무효화해야합니다.</target>
        </trans-unit>
        <trans-unit id="ee1094ec573e30a088a7bb2b6d5627c5f7267990" translate="yes" xml:space="preserve">
          <source>Note that if creating a functions object via this method that the &lt;a href=&quot;gui-changes-qt6#qopenglcontext&quot;&gt;QOpenGLContext&lt;/a&gt; retains ownership of the object. This is to allow the object to be cached and shared.</source>
          <target state="translated">이 메서드를 통해 함수 개체를 만드는 경우 &lt;a href=&quot;gui-changes-qt6#qopenglcontext&quot;&gt;QOpenGLContext&lt;/a&gt; 가 개체의 소유권을 유지합니다. 이는 객체를 캐시하고 공유 할 수 있도록하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="1e5f70ec4faf03fb5dc641cf495524bb3ff723a7" translate="yes" xml:space="preserve">
          <source>Note that if creating a functions object via this method that the &lt;a href=&quot;qopenglcontext&quot;&gt;QOpenGLContext&lt;/a&gt; retains ownership of the object. This is to allow the object to be cached and shared.</source>
          <target state="translated">이 메소드를 통해 함수 오브젝트를 작성하는 경우 &lt;a href=&quot;qopenglcontext&quot;&gt;QOpenGLContext&lt;/a&gt; 는 오브젝트의 소유권을 보유합니다. 이는 객체를 캐시하고 공유 할 수 있도록하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="3d756d73a6152d5591e4cba5c19d3a655e7f4da9" translate="yes" xml:space="preserve">
          <source>Note that if sorting is enabled (see &lt;a href=&quot;qtableview#sortingEnabled-prop&quot;&gt;sortingEnabled&lt;/a&gt;) and</source>
          <target state="translated">정렬이 활성화 된 경우 ( &lt;a href=&quot;qtableview#sortingEnabled-prop&quot;&gt;sortingEnabled&lt;/a&gt; 참조 ) 및</target>
        </trans-unit>
        <trans-unit id="4c0752adf733e36ba441ebb96a9cf5ae4de08dc3" translate="yes" xml:space="preserve">
          <source>Note that if the [begin, end) range refers to an area that can store more than 32 bits per element, the elements will still be initialized with only 32 bits of data. Any other bits will be zero. To fill the range with 64 bit quantities, one can write:</source>
          <target state="translated">[시작, 끝) 범위가 요소 당 32 비트 이상을 저장할 수있는 영역을 참조하는 경우 요소는 여전히 32 비트의 데이터로 초기화됩니다. 다른 비트는 0이됩니다. 64 비트 수량으로 범위를 채우려면 다음과 같이 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d12c9b32c43f70abe4ec220bd3a207e01e738123" translate="yes" xml:space="preserve">
          <source>Note that if the destination manager is to facilitate saving and cross-referencing from any arbitrary manager, it internally must accommodate saving of arbitrary key value pairs since we cannot know the provider names before hand, nor can we know what structure the ids will be.</source>
          <target state="translated">대상 관리자가 임의의 관리자로부터 저장 및 상호 참조를 용이하게하려면 내부적으로 사전에 공급자 이름을 알 수 없으며 ID가 어떤 구조인지 알 수 없으므로 내부적으로 임의의 키 값 쌍을 저장할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="741a69da66d912b10a2f088adf44a629179f8a66" translate="yes" xml:space="preserve">
          <source>Note that if the documentation immediately precedes the function or class in the source code, then it does not need to have a topic. QDoc will assume that the documentation above the code is the documentation for that code.</source>
          <target state="translated">문서가 소스 코드에서 함수 또는 클래스 바로 앞에 오는 경우 주제가 필요하지 않습니다. QDoc은 코드 위의 문서가 해당 코드의 문서라고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="c6edd1af5eb2b2dd156d3366d90f34eafec5cd1a" translate="yes" xml:space="preserve">
          <source>Note that if the entity is unknown, the reader reports it through &lt;a href=&quot;qxmlcontenthandler#skippedEntity&quot;&gt;QXmlContentHandler::skippedEntity&lt;/a&gt;() and not through this function.</source>
          <target state="translated">엔티티를 알 수없는 경우 리더는 이 함수가 아닌 &lt;a href=&quot;qxmlcontenthandler#skippedEntity&quot;&gt;QXmlContentHandler :: skippedEntity&lt;/a&gt; ()를 통해이를보고합니다.</target>
        </trans-unit>
        <trans-unit id="f343e94eccc7199c3315a074d3f87a85f8791ac2" translate="yes" xml:space="preserve">
          <source>Note that if the event is a multiple-key compressed event that is partly due to auto-repeat, this function could return either true or false indeterminately.</source>
          <target state="translated">이벤트가 부분적으로 자동 반복으로 인한 다중 키 압축 이벤트 인 경우이 함수는 true 또는 false를 확실하게 리턴 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cef7297e974a15ccaf6fbaee43930a2ccc59c6d7" translate="yes" xml:space="preserve">
          <source>Note that if the item is being moved, this property holds the index that the item is moving to, not from.</source>
          <target state="translated">항목을 이동하는 경우이 속성은 항목이 아닌 이동하는 색인을 보유합니다.</target>
        </trans-unit>
        <trans-unit id="69c0ccd401b1b617a8ae931aa71b7f6bcb063261" translate="yes" xml:space="preserve">
          <source>Note that if the logicalDpiX() doesn't equal the &lt;a href=&quot;qpaintdevice#physicalDpiX&quot;&gt;physicalDpiX&lt;/a&gt;(), the corresponding &lt;a href=&quot;qpaintengine&quot;&gt;QPaintEngine&lt;/a&gt; must handle the resolution mapping.</source>
          <target state="translated">logicalDpiX ()가 &lt;a href=&quot;qpaintdevice#physicalDpiX&quot;&gt;physicalDpiX&lt;/a&gt; ()와 &lt;a href=&quot;qpaintengine&quot;&gt;같지&lt;/a&gt; 않으면 해당 QPaintEngine 이 해상도 매핑을 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="a29e305295b0a56506ba753dd028ac493bc192e6" translate="yes" xml:space="preserve">
          <source>Note that if the logicalDpiY() doesn't equal the &lt;a href=&quot;qpaintdevice#physicalDpiY&quot;&gt;physicalDpiY&lt;/a&gt;(), the corresponding &lt;a href=&quot;qpaintengine&quot;&gt;QPaintEngine&lt;/a&gt; must handle the resolution mapping.</source>
          <target state="translated">logicalDpiY ()가 &lt;a href=&quot;qpaintdevice#physicalDpiY&quot;&gt;physicalDpiY&lt;/a&gt; ()와 &lt;a href=&quot;qpaintengine&quot;&gt;같지&lt;/a&gt; 않으면 해당 QPaintEngine 이 해상도 매핑을 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="cfde6b0e09e2851af02c6874b5e1c96035f01bd0" translate="yes" xml:space="preserve">
          <source>Note that if the physicalDpiX() doesn't equal the &lt;a href=&quot;qpaintdevice#logicalDpiX&quot;&gt;logicalDpiX&lt;/a&gt;(), the corresponding &lt;a href=&quot;qpaintengine&quot;&gt;QPaintEngine&lt;/a&gt; must handle the resolution mapping.</source>
          <target state="translated">physicalDpiX ()가 &lt;a href=&quot;qpaintdevice#logicalDpiX&quot;&gt;logicalDpiX&lt;/a&gt; ()와 &lt;a href=&quot;qpaintengine&quot;&gt;같지&lt;/a&gt; 않으면 해당 QPaintEngine 이 해상도 매핑을 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="29d67bdb2fe2911f9536eda5e4ec782acbd46127" translate="yes" xml:space="preserve">
          <source>Note that if the physicalDpiY() doesn't equal the &lt;a href=&quot;qpaintdevice#logicalDpiY&quot;&gt;logicalDpiY&lt;/a&gt;(), the corresponding &lt;a href=&quot;qpaintengine&quot;&gt;QPaintEngine&lt;/a&gt; must handle the resolution mapping.</source>
          <target state="translated">physicalDpiY ()가 &lt;a href=&quot;qpaintdevice#logicalDpiY&quot;&gt;logicalDpiY&lt;/a&gt; ()와 &lt;a href=&quot;qpaintengine&quot;&gt;같지&lt;/a&gt; 않으면 해당 QPaintEngine 이 해상도 매핑을 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="9f488157a26f9edd40a79b060c33bab470758daf" translate="yes" xml:space="preserve">
          <source>Note that if the source is a local file, the status will initially be Ready (or Error). While there will be no onStatusChanged signal in that case, the onLoaded will still be invoked.</source>
          <target state="translated">소스가 로컬 파일 인 경우 상태는 처음에 준비 (또는 오류)입니다. 이 경우에는 onStatusChanged 신호가 없지만 onLoaded는 계속 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="e7cd4703690030742475f046adc16b5b7ecaaa4f" translate="yes" xml:space="preserve">
          <source>Note that if the text does not fit in the bounding rectangle it will be abruptly chopped.</source>
          <target state="translated">텍스트가 경계 사각형에 맞지 않으면 갑자기 잘립니다.</target>
        </trans-unit>
        <trans-unit id="17323b153a52168d5f0cadbf730201f426d20354" translate="yes" xml:space="preserve">
          <source>Note that if the text encoding set when connecting to the database is not the same as in the database, problems with transliteration might arise.</source>
          <target state="translated">데이터베이스에 연결할 때 설정된 텍스트 인코딩이 데이터베이스와 동일하지 않으면 음역에 문제가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8cc48ed9abfec4852f0e4b391be765486a6d91e" translate="yes" xml:space="preserve">
          <source>Note that if there are still &lt;a href=&quot;dbus-changes-qt6#qdbusconnection&quot;&gt;QDBusConnection&lt;/a&gt; objects associated with the same connection, the connection will not be closed until all references are dropped. However, no further references can be created using the &lt;a href=&quot;dbus-changes-qt6#qdbusconnection&quot;&gt;QDBusConnection&lt;/a&gt; constructor.</source>
          <target state="translated">동일한 연결과 연관된 &lt;a href=&quot;dbus-changes-qt6#qdbusconnection&quot;&gt;QDBusConnection&lt;/a&gt; 객체 가 여전히있는 경우 모든 참조가 삭제 될 때까지 연결이 닫히지 않습니다. 그러나 &lt;a href=&quot;dbus-changes-qt6#qdbusconnection&quot;&gt;QDBusConnection&lt;/a&gt; 생성자를 사용하여 더 이상 참조를 만들 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="ce840200463e853f3b7b4873d4c522f8f65d350f" translate="yes" xml:space="preserve">
          <source>Note that if there are still &lt;a href=&quot;qdbusconnection&quot;&gt;QDBusConnection&lt;/a&gt; objects associated with the same connection, the connection will not be closed until all references are dropped. However, no further references can be created using the &lt;a href=&quot;qdbusconnection&quot;&gt;QDBusConnection&lt;/a&gt; constructor.</source>
          <target state="translated">동일한 연결과 연관된 &lt;a href=&quot;qdbusconnection&quot;&gt;QDBusConnection&lt;/a&gt; 오브젝트 가 여전히 있으면 모든 참조가 삭제 될 때까지 연결이 닫히지 않습니다. 그러나 &lt;a href=&quot;qdbusconnection&quot;&gt;QDBusConnection&lt;/a&gt; 생성자를 사용하여 추가 참조를 작성할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="d916af669cd84bb22d95d423b286403e2f10ad4b" translate="yes" xml:space="preserve">
          <source>Note that if there is a &lt;a href=&quot;qlineedit#validator&quot;&gt;validator&lt;/a&gt;() or &lt;a href=&quot;qlineedit#inputMask-prop&quot;&gt;inputMask&lt;/a&gt;() set on the line edit and enter/return is pressed, the editingFinished() signal will only be emitted if the input follows the &lt;a href=&quot;qlineedit#inputMask-prop&quot;&gt;inputMask&lt;/a&gt;() and the &lt;a href=&quot;qlineedit#validator&quot;&gt;validator&lt;/a&gt;() returns &lt;a href=&quot;qvalidator#State-enum&quot;&gt;QValidator::Acceptable&lt;/a&gt;.</source>
          <target state="translated">거기 경우 유의 &lt;a href=&quot;qlineedit#validator&quot;&gt;검사기&lt;/a&gt; () 또는 &lt;a href=&quot;qlineedit#inputMask-prop&quot;&gt;inputMask&lt;/a&gt; 라인 편집에 () 세트 및 / 입력 창은 입력은 다음 경우 editingFinished () 신호만을 방출한다 가압 &lt;a href=&quot;qlineedit#inputMask-prop&quot;&gt;inputMask&lt;/a&gt; () 및 &lt;a href=&quot;qlineedit#validator&quot;&gt;검사기&lt;/a&gt; () 반환 &lt;a href=&quot;qvalidator#State-enum&quot;&gt;QValidator을 : : 허용&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="262614ed4eb12cee45670955f7687c97f8bf6ca9" translate="yes" xml:space="preserve">
          <source>Note that if there is a validator set on the line edit, the &lt;a href=&quot;qlineedit#returnPressed&quot;&gt;returnPressed&lt;/a&gt;()/&lt;a href=&quot;qlineedit#editingFinished&quot;&gt;editingFinished&lt;/a&gt;() signals will only be emitted if the validator returns &lt;a href=&quot;qvalidator#State-enum&quot;&gt;QValidator::Acceptable&lt;/a&gt;.</source>
          <target state="translated">라인 편집에 유효성 검사기가 설정되어 &lt;a href=&quot;qlineedit#returnPressed&quot;&gt;있으면 returnPressed&lt;/a&gt; () / &lt;a href=&quot;qlineedit#editingFinished&quot;&gt;editingFinished&lt;/a&gt; () 신호는 유효성 검사기가 &lt;a href=&quot;qvalidator#State-enum&quot;&gt;QValidator :: Acceptable을&lt;/a&gt; 반환하는 경우에만 방출됩니다 .</target>
        </trans-unit>
        <trans-unit id="43ee271126f23dce62d77de4530a79039bc819ec" translate="yes" xml:space="preserve">
          <source>Note that if this &lt;a href=&quot;qjsvalue&quot;&gt;QJSValue&lt;/a&gt; is an object, calling this function has side effects on the script engine, since the engine will call the object's toString() function (and possibly valueOf()) in an attempt to convert the object to a primitive value (possibly resulting in an uncaught script exception).</source>
          <target state="translated">이 &lt;a href=&quot;qjsvalue&quot;&gt;QJSValue&lt;/a&gt; 가 객체 인 경우 엔진이 객체를 원시 값으로 변환하려고 시도 할 때 엔진이 객체의 toString () 함수 (및 valueOf ())를 호출하기 때문에이 함수를 호출하면 스크립트 엔진에 부작용이 있습니다. 캐치되지 않은 스크립트 예외가 발생할 수 있습니다).</target>
        </trans-unit>
        <trans-unit id="31ec4c2a1f54a2caf96d230c7c3ed5816d5ff9b3" translate="yes" xml:space="preserve">
          <source>Note that if this &lt;a href=&quot;qjsvalue&quot;&gt;QJSValue&lt;/a&gt; is an object, calling this function has side effects on the script engine, since the engine will call the object's valueOf() function (and possibly &lt;a href=&quot;qjsvalue#toString&quot;&gt;toString&lt;/a&gt;()) in an attempt to convert the object to a primitive value (possibly resulting in an uncaught script exception).</source>
          <target state="translated">이 경우 참고 것을 &lt;a href=&quot;qjsvalue&quot;&gt;QJSValue이&lt;/a&gt; 객체가 엔진 (아마도 및 객체의 valueOf () 함수를 호출하기 때문에,이 함수를 호출하면, 스크립트 엔진에 대한 부작용을 가지고 &lt;a href=&quot;qjsvalue#toString&quot;&gt;toString을&lt;/a&gt; (원시 값으로 개체를 변환하는 시도 ()) 캐치되지 않은 스크립트 예외가 발생할 수 있습니다).</target>
        </trans-unit>
        <trans-unit id="85c74bf3e1963ccca9996fae0b181d34183cb29c" translate="yes" xml:space="preserve">
          <source>Note that if this &lt;a href=&quot;qjsvalue&quot;&gt;QJSValue&lt;/a&gt; or the</source>
          <target state="translated">이 &lt;a href=&quot;qjsvalue&quot;&gt;QJSValue&lt;/a&gt; 또는</target>
        </trans-unit>
        <trans-unit id="dcba4e6d519ca6a5be152da39bd81b5b830a3fbe" translate="yes" xml:space="preserve">
          <source>Note that if you apply a &lt;a href=&quot;qmatrix&quot;&gt;QMatrix&lt;/a&gt; to a point defined in widget coordinates, the direction of the rotation will be clockwise because the y-axis points downwards.</source>
          <target state="translated">위젯 좌표에 정의 된 점에 &lt;a href=&quot;qmatrix&quot;&gt;QMatrix&lt;/a&gt; 를 적용 하면 y 축이 아래쪽을 향하기 때문에 회전 방향이 시계 방향이됩니다.</target>
        </trans-unit>
        <trans-unit id="79b7fc68d7c450da0aa0fe2c3d68264b44395c65" translate="yes" xml:space="preserve">
          <source>Note that if you apply a &lt;a href=&quot;qtransform&quot;&gt;QTransform&lt;/a&gt; to a point defined in widget coordinates, the direction of the rotation will be clockwise because the y-axis points downwards.</source>
          <target state="translated">위젯 좌표에 정의 된 점에 &lt;a href=&quot;qtransform&quot;&gt;QTransform&lt;/a&gt; 을 적용 하면 y 축이 아래쪽을 향하기 때문에 회전 방향이 시계 방향이됩니다.</target>
        </trans-unit>
        <trans-unit id="d502d17a0c45623bd56526d695c1c74f90ed8ff9" translate="yes" xml:space="preserve">
          <source>Note that if you are attempting to join an IPv4 group, your socket must not be bound using IPv6 (or in dual mode, using &lt;a href=&quot;qhostaddress#SpecialAddress-enum&quot;&gt;QHostAddress::Any&lt;/a&gt;). You must use &lt;a href=&quot;qhostaddress#SpecialAddress-enum&quot;&gt;QHostAddress::AnyIPv4&lt;/a&gt; instead.</source>
          <target state="translated">IPv4 그룹에 참여하려는 경우 소켓은 IPv6 (또는 &lt;a href=&quot;qhostaddress#SpecialAddress-enum&quot;&gt;QHostAddress :: Any를&lt;/a&gt; 사용하는 이중 모드)을 사용하여 바인드되어서는 안됩니다 . 당신은 사용해야합니다 &lt;a href=&quot;qhostaddress#SpecialAddress-enum&quot;&gt;QHostAddress :: AnyIPv4을&lt;/a&gt; 대신.</target>
        </trans-unit>
        <trans-unit id="350f58652ed28288f241bac209a37a31c0e37559" translate="yes" xml:space="preserve">
          <source>Note that if you call this function, you need to do so</source>
          <target state="translated">이 함수를 호출하면 그렇게해야합니다.</target>
        </trans-unit>
        <trans-unit id="8ec1c17deb82e766ddb593e203b068b097108dc9" translate="yes" xml:space="preserve">
          <source>Note that if you change the value of a property using the &lt;a href=&quot;qdesignerpropertysheetextension#setProperty&quot;&gt;QDesignerPropertySheetExtension::setProperty&lt;/a&gt;() function, the undo stack is not updated. To ensure that a property's value can be reverted using the undo stack, you must use the &lt;a href=&quot;qdesignerformwindowcursorinterface#setProperty&quot;&gt;QDesignerFormWindowCursorInterface::setProperty&lt;/a&gt;() function, or its buddy &lt;a href=&quot;qdesignerformwindowcursorinterface#setWidgetProperty&quot;&gt;setWidgetProperty()&lt;/a&gt;, instead.</source>
          <target state="translated">&lt;a href=&quot;qdesignerpropertysheetextension#setProperty&quot;&gt;QDesignerPropertySheetExtension :: setProperty&lt;/a&gt; () 함수를 사용하여 속성 값을 변경 하면 실행 취소 스택이 업데이트되지 않습니다. 실행 취소 스택을 사용하여 속성 값을 되돌리려면 &lt;a href=&quot;qdesignerformwindowcursorinterface#setProperty&quot;&gt;QDesignerFormWindowCursorInterface :: setProperty&lt;/a&gt; () 함수 또는 그 친구 인 &lt;a href=&quot;qdesignerformwindowcursorinterface#setWidgetProperty&quot;&gt;setWidgetProperty ()&lt;/a&gt; 를 대신 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="5c3c8287eec96e42400d79f073baf18536788e56" translate="yes" xml:space="preserve">
          <source>Note that if you have merged multiple columns and rows into one cell, you will not be able to split the merged cell into new cells spanning over more than one row or column. To be able to split cells spanning over several rows and columns you need to do this over several iterations.</source>
          <target state="translated">여러 열과 행을 하나의 셀로 병합 한 경우 병합 된 셀을 둘 이상의 행이나 열에 걸쳐있는 새 셀로 분할 할 수 없습니다. 여러 행과 열에 걸쳐있는 셀을 분할하려면 여러 번 반복하여이 작업을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="3994b18aaa7b6b61d0f1c66e538d4afa4f4158b0" translate="yes" xml:space="preserve">
          <source>Note that if you need to monitor both reads and writes for the same file descriptor, you must create two socket notifiers. Note also that it is not possible to install two socket notifiers of the same type (Read, Write, Exception) on the same socket.</source>
          <target state="translated">동일한 파일 디스크립터에 대한 읽기 및 쓰기를 모두 모니터해야하는 경우 두 개의 소켓 알리미를 작성해야합니다. 또한 동일한 소켓에 동일한 유형의 두 개의 소켓 알리미 (읽기, 쓰기, 예외)를 설치할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="71f133119fd7d20d5e3212539c6afdacaffbecdc" translate="yes" xml:space="preserve">
          <source>Note that if you require decimal values you will need to set the &lt;a href=&quot;qml-qtquick-controls-spinbox#decimals-prop&quot;&gt;decimals&lt;/a&gt; to a non 0 value.</source>
          <target state="translated">소수점 값이 필요한 경우 &lt;a href=&quot;qml-qtquick-controls-spinbox#decimals-prop&quot;&gt;소수점&lt;/a&gt; 을 0이 아닌 값 으로 설정해야 합니다.</target>
        </trans-unit>
        <trans-unit id="9aec82bfd39aaa480f7a47199a421213df02f772" translate="yes" xml:space="preserve">
          <source>Note that if you specify a two digit year, it will be interpreted to be in the century in which the date time edit was initialized. The default century is the 21 (2000-2099).</source>
          <target state="translated">두 자리 연도를 지정하면 날짜 시간 편집이 초기화 된 세기로 해석됩니다. 기본 세기는 21 (2000-2099)입니다.</target>
        </trans-unit>
        <trans-unit id="c6d54234ed70dafc56fee2ce938e97b6335e596c" translate="yes" xml:space="preserve">
          <source>Note that if you specify a two digit year, it will be interpreted to be in the century in which the date time edit was initialized. The default century is the 21st (2000-2099).</source>
          <target state="translated">두 자리 연도를 지정하면 날짜 시간 편집이 초기화 된 세기로 해석됩니다. 기본 세기는 21 세기 (2000-2099)입니다.</target>
        </trans-unit>
        <trans-unit id="a80b101c8f2e709931bcf80e8de0eaca7f502048" translate="yes" xml:space="preserve">
          <source>Note that if you use this class but find you are calling &lt;a href=&quot;qexplicitlyshareddatapointer#detach&quot;&gt;detach&lt;/a&gt;() a lot, you probably should be using &lt;a href=&quot;qshareddatapointer&quot;&gt;QSharedDataPointer&lt;/a&gt; instead.</source>
          <target state="translated">이 클래스를 사용하지만 &lt;a href=&quot;qexplicitlyshareddatapointer#detach&quot;&gt;detach&lt;/a&gt; ()를 많이 호출 하는 경우 &lt;a href=&quot;qshareddatapointer&quot;&gt;QSharedDataPointer를&lt;/a&gt; 대신 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="7fc7c2da823a8d26a0981c186b0e7a0573d89ddf" translate="yes" xml:space="preserve">
          <source>Note that if you want to iterate over the list, you should iterate over a copy, e.g.</source>
          <target state="translated">목록을 반복하려면 사본을 반복해야합니다.</target>
        </trans-unit>
        <trans-unit id="4585ac52c607286c0d4e6c4d682fb350463e8c38" translate="yes" xml:space="preserve">
          <source>Note that if you want to use a custom data type in an item view drag and drop operation, you must register it as a Qt &lt;a href=&quot;qmetatype&quot;&gt;meta type&lt;/a&gt;, using the &lt;a href=&quot;qmetatype#Q_DECLARE_METATYPE&quot;&gt;Q_DECLARE_METATYPE&lt;/a&gt;() macro, and implement stream operators for it. The stream operators must then be registered with the &lt;a href=&quot;qmetatype#qRegisterMetaTypeStreamOperators&quot;&gt;qRegisterMetaTypeStreamOperators&lt;/a&gt;() function.</source>
          <target state="translated">항목보기 끌어서 놓기 조작에서 사용자 정의 데이터 유형을 사용하려면 &lt;a href=&quot;qmetatype#Q_DECLARE_METATYPE&quot;&gt;Q_DECLARE_METATYPE&lt;/a&gt; () 매크로를 사용하여 Qt &lt;a href=&quot;qmetatype&quot;&gt;메타 유형&lt;/a&gt; 으로 등록하고 스트림 연산자를 구현해야합니다. 그런 다음 스트림 연산자는 &lt;a href=&quot;qmetatype#qRegisterMetaTypeStreamOperators&quot;&gt;qRegisterMetaTypeStreamOperators&lt;/a&gt; () 함수 로 등록해야합니다 .</target>
        </trans-unit>
        <trans-unit id="c17dc042ff7afdbd096d8674df906edcc10c385a" translate="yes" xml:space="preserve">
          <source>Note that if you want to use a custom data type in an item view drag and drop operation, you must register it as a Qt &lt;a href=&quot;qtcore-changes-qt6#qmetatype&quot;&gt;meta type&lt;/a&gt;, using the &lt;a href=&quot;qmetatype#Q_DECLARE_METATYPE&quot;&gt;Q_DECLARE_METATYPE&lt;/a&gt;() macro, and implement stream operators for it.</source>
          <target state="translated">항목보기 끌어서 놓기 작업에서 사용자 지정 데이터 유형을 사용하려면 &lt;a href=&quot;qmetatype#Q_DECLARE_METATYPE&quot;&gt;Q_DECLARE_METATYPE&lt;/a&gt; () 매크로를 사용하여 이를 Qt &lt;a href=&quot;qtcore-changes-qt6#qmetatype&quot;&gt;메타 유형&lt;/a&gt; 으로 등록하고 이에 대한 스트림 연산자를 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="09cd10ff0c0c8a4da165205e92716de033ec321b" translate="yes" xml:space="preserve">
          <source>Note that if your MyEvent class allocates memory (e.g. through a pointer-to-implementation pattern), then you will have to implement custom copy semantics.</source>
          <target state="translated">MyEvent 클래스가 메모리를 할당하는 경우 (예 : 포인터-구현 패턴을 통해) 사용자 정의 복사 의미를 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="c8ed0e048c6046a1e9b38bfa761a545a371ccf57" translate="yes" xml:space="preserve">
          <source>Note that in general regexps cannot be used to check for balanced brackets or tags. For example, a regexp can be written to match an opening html &lt;code&gt;&amp;lt;b&amp;gt;&lt;/code&gt; and its closing &lt;code&gt;&amp;lt;/b&amp;gt;&lt;/code&gt;, if the &lt;code&gt;&amp;lt;b&amp;gt;&lt;/code&gt; tags are not nested, but if the &lt;code&gt;&amp;lt;b&amp;gt;&lt;/code&gt; tags are nested, that same regexp will match an opening &lt;code&gt;&amp;lt;b&amp;gt;&lt;/code&gt; tag with the wrong closing &lt;code&gt;&amp;lt;/b&amp;gt;&lt;/code&gt;. For the fragment &lt;code&gt;&amp;lt;b&amp;gt;bold &amp;lt;b&amp;gt;bolder&amp;lt;/b&amp;gt;&amp;lt;/b&amp;gt;&lt;/code&gt;, the first &lt;code&gt;&amp;lt;b&amp;gt;&lt;/code&gt; would be matched with the first &lt;code&gt;&amp;lt;/b&amp;gt;&lt;/code&gt;, which is not correct. However, it is possible to write a regexp that will match nested brackets or tags correctly, but only if the number of nesting levels is fixed and known. If the number of nesting levels is not fixed and known, it is impossible to write a regexp that will not fail.</source>
          <target state="translated">일반적으로 정규 표현식을 사용하여 대괄호 또는 태그를 확인할 수는 없습니다. 예를 들면, 정규식은 개구 HTML에 맞게 기록 될 수있다 &lt;code&gt;&amp;lt;b&amp;gt;&lt;/code&gt; 와 폐쇄 &lt;code&gt;&amp;lt;/b&amp;gt;&lt;/code&gt; 을 상기 경우 &lt;code&gt;&amp;lt;b&amp;gt;&lt;/code&gt; 태그는 중첩되지 않고있는 경우 &lt;code&gt;&amp;lt;b&amp;gt;&lt;/code&gt; 태그는 중첩되고, 동일한 정규 표현식은 일치하는 것으로 개구 &lt;code&gt;&amp;lt;b&amp;gt;&lt;/code&gt; 잘못된 닫는 태그 &lt;code&gt;&amp;lt;/b&amp;gt;&lt;/code&gt; . &lt;code&gt;&amp;lt;b&amp;gt;bold &amp;lt;b&amp;gt;bolder&amp;lt;/b&amp;gt;&amp;lt;/b&amp;gt;&lt;/code&gt; 단편의 경우 첫 번째 &lt;code&gt;&amp;lt;b&amp;gt;&lt;/code&gt; 는 첫 번째 &amp;lt;b&amp;gt; 와 일치합니다 &lt;code&gt;&amp;lt;/b&amp;gt;&lt;/code&gt; 잘못되었습니다. 그러나 중첩 된 대괄호 나 태그와 올바르게 일치하는 정규 표현식을 작성할 수 있지만 중첩 수준의 수가 고정되어 알려진 경우에만 가능합니다. 중첩 수준의 수가 고정되어 있고 알려지지 않은 경우 실패하지 않는 정규식을 작성할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ae596454332ebd9b7d7a5f2ada16eb415528c1a5" translate="yes" xml:space="preserve">
          <source>Note that in order for the interpolation to work with a &lt;a href=&quot;qeasingcurve&quot;&gt;QEasingCurve&lt;/a&gt; that return a value smaller than 0 or larger than 1 (such as &lt;a href=&quot;qeasingcurve#Type-enum&quot;&gt;QEasingCurve::InBack&lt;/a&gt;) you should make sure that it can extrapolate. If the semantic of the datatype does not allow extrapolation this function should handle that gracefully.</source>
          <target state="translated">보간 이 0보다 작거나 1보다 큰 값 (예 : &lt;a href=&quot;qeasingcurve#Type-enum&quot;&gt;QEasingCurve :: InBack&lt;/a&gt; ) 을 리턴 하는 &lt;a href=&quot;qeasingcurve&quot;&gt;QEasingCurve&lt;/a&gt; 와 함께 작동 하려면 외삽이 가능한지 확인해야합니다. 데이터 유형의 시맨틱이 외삽을 허용하지 않는 경우이 함수는이를 적절하게 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="66b09e1429a4d031da74af48fcd7350b3ecf29c3" translate="yes" xml:space="preserve">
          <source>Note that in order to draw a bitmap or pixmap transparently, you must use &lt;a href=&quot;qpixmap#setMask&quot;&gt;QPixmap::setMask&lt;/a&gt;().</source>
          <target state="translated">비트 맵 또는 픽스맵을 투명하게 그리려면 &lt;a href=&quot;qpixmap#setMask&quot;&gt;QPixmap :: setMask&lt;/a&gt; () 를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="2aa7dfd22db0db2a9f9b46546a1e0ca403352b9f" translate="yes" xml:space="preserve">
          <source>Note that in some circumstances disabling a Transition may cause an alternative Transition to be used in its place. In the following example, although the first Transition has been set to animate changes from &quot;state1&quot; to &quot;state2&quot;, this transition has been disabled by setting &lt;code&gt;enabled&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt;, so any such state change will actually be animated by the second Transition instead.</source>
          <target state="translated">경우에 따라 전환을 비활성화하면 대체 전환이 대신 사용될 수 있습니다. 다음 예제에서는 첫 번째 전환이 &quot;state1&quot;에서 &quot;state2&quot;로 변경 사항을 애니메이션으로 설정했지만,이 전환은 &lt;code&gt;enabled&lt;/code&gt; 를 &lt;code&gt;false&lt;/code&gt; 로 설정 하여 비활성화 되었으므로 이러한 상태 변경은 실제로 두 번째 전환에 의해 애니메이션됩니다.</target>
        </trans-unit>
        <trans-unit id="8e4847690d899f38830b7c79b398d6615b761f3b" translate="yes" xml:space="preserve">
          <source>Note that in this case, the &lt;code&gt;index&lt;/code&gt; parameter passed to &lt;a href=&quot;qml-qtquick-controls-menu#insertItem-method&quot;&gt;insertItem()&lt;/a&gt; is relative to the position of the &lt;a href=&quot;qml-qtqml-instantiator&quot;&gt;Instantiator&lt;/a&gt; in the menu, as opposed to absolute position in the menu.</source>
          <target state="translated">이 경우 &lt;a href=&quot;qml-qtquick-controls-menu#insertItem-method&quot;&gt;insertItem ()에&lt;/a&gt; 전달 된 &lt;code&gt;index&lt;/code&gt; 매개 변수 는 메뉴의 절대 위치가 아니라 메뉴 의 &lt;a href=&quot;qml-qtqml-instantiator&quot;&gt;인스턴스 화기&lt;/a&gt; 위치에 상대적 입니다.</target>
        </trans-unit>
        <trans-unit id="f5c48ab7bc65be25e6c6f372b2a32c1d278ae9c0" translate="yes" xml:space="preserve">
          <source>Note that in this case, the &lt;code&gt;index&lt;/code&gt; parameter passed to &lt;a href=&quot;qml-qtquick-controls-menu#insertItem-method&quot;&gt;insertItem()&lt;/a&gt; is relative to the position of the Instantiator in the menu, as opposed to absolute position in the menu.</source>
          <target state="translated">이 경우 &lt;a href=&quot;qml-qtquick-controls-menu#insertItem-method&quot;&gt;insertItem ()에&lt;/a&gt; 전달 된 &lt;code&gt;index&lt;/code&gt; 매개 변수 는 메뉴의 절대 위치가 아니라 메뉴의 인스턴스 화기 위치에 상대적입니다.</target>
        </trans-unit>
        <trans-unit id="014cf3f8d0a544c5c6b5c5587112f651997b87ae" translate="yes" xml:space="preserve">
          <source>Note that individual tabs may be disabled even if the tab bar is not. The tab will be active if the tab bar is active.</source>
          <target state="translated">탭 막대가 아닌 경우에도 개별 탭이 비활성화 될 수 있습니다. 탭 표시 줄이 활성화되어 있으면 탭이 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="c04acf61f478879792345199d49305b0bf96b5c4" translate="yes" xml:space="preserve">
          <source>Note that instead of exporting each custom widget plugin using the &lt;a href=&quot;#Q_PLUGIN_METADATA&quot;&gt;Q_PLUGIN_METADATA&lt;/a&gt;() macro, you export the entire collection. The &lt;a href=&quot;#Q_PLUGIN_METADATA&quot;&gt;Q_PLUGIN_METADATA&lt;/a&gt;() macro ensures that</source>
          <target state="translated">&lt;a href=&quot;#Q_PLUGIN_METADATA&quot;&gt;Q_PLUGIN_METADATA&lt;/a&gt; () 매크로를 사용하여 각 사용자 정의 위젯 플러그인을 내보내는 대신 전체 콜렉션을 내 보냅니다. &lt;a href=&quot;#Q_PLUGIN_METADATA&quot;&gt;Q_PLUGIN_METADATA&lt;/a&gt; () 매크로 것을 보장</target>
        </trans-unit>
        <trans-unit id="4f83351dc2e4e3d121565352fbf8875034a8e712" translate="yes" xml:space="preserve">
          <source>Note that instead of exporting each custom widget plugin using the &lt;a href=&quot;qtplugin#Q_PLUGIN_METADATA&quot;&gt;Q_PLUGIN_METADATA&lt;/a&gt;() macro, you export the entire collection. The &lt;a href=&quot;qtplugin#Q_PLUGIN_METADATA&quot;&gt;Q_PLUGIN_METADATA&lt;/a&gt;() macro ensures that</source>
          <target state="translated">&lt;a href=&quot;qtplugin#Q_PLUGIN_METADATA&quot;&gt;Q_PLUGIN_METADATA&lt;/a&gt; () 매크로를 사용하여 각 사용자 정의 위젯 플러그인을 내보내는 대신 전체 컬렉션을 내 보냅니다. &lt;a href=&quot;qtplugin#Q_PLUGIN_METADATA&quot;&gt;Q_PLUGIN_METADATA&lt;/a&gt; () 매크로 것을 보장</target>
        </trans-unit>
        <trans-unit id="edef8e308d34fbdfa63e768f7afdf296c9279678" translate="yes" xml:space="preserve">
          <source>Note that invisible widgets have a size of 0.</source>
          <target state="translated">보이지 않는 위젯의 크기는 0입니다.</target>
        </trans-unit>
        <trans-unit id="c8fd89dda6269cf97aaafa1ab026a910f9508b1e" translate="yes" xml:space="preserve">
          <source>Note that is perfectly reasonable in some circumstances to overwrite bindings. Any message generated by the QML engine should be treated as a diagnostic aid, and not necessarily as evidence of a problem without further investigation.</source>
          <target state="translated">일부 환경에서는 바인딩을 덮어 쓰는 것이 합리적입니다. QML 엔진에 의해 생성 된 모든 메시지는 진단 보조 수단으로 취급되어야하며 추가 조사없이 문제의 증거가 될 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="1dd456ec5b64e9d8aced115ec7eb071d56172f72" translate="yes" xml:space="preserve">
          <source>Note that it does &lt;b&gt;not&lt;/b&gt; delete the text of the selection.</source>
          <target state="translated">선택 텍스트는 삭제 되지 &lt;b&gt;않습니다&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="3d754814a4e9a2a4d9f025eb47f0613c43220c7f" translate="yes" xml:space="preserve">
          <source>Note that it does not refer to the total number of search results available in the backend. The total number of search results is not currently supported by the API.</source>
          <target state="translated">백엔드에서 사용 가능한 총 검색 결과 수를 나타내지 않습니다. 총 검색 결과 수는 현재 API에서 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="76ffa54c7f0fb2b552d86c0b8b3a902008a62b73" translate="yes" xml:space="preserve">
          <source>Note that it is always possible to programmatically insert duplicate items into the combobox.</source>
          <target state="translated">프로그래밍 방식으로 중복 항목을 콤보 상자에 삽입하는 것이 항상 가능합니다.</target>
        </trans-unit>
        <trans-unit id="a03b1490e20d880eb4a4e7ca3d5e5bf21192e174" translate="yes" xml:space="preserve">
          <source>Note that it is equivalent to the following:</source>
          <target state="translated">다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0e3fe1406f8185fc21aacff1f60b868400445c93" translate="yes" xml:space="preserve">
          <source>Note that it is faster to get and set properties using &lt;a href=&quot;qobject#property&quot;&gt;QObject::property&lt;/a&gt;() and &lt;a href=&quot;qobject#setProperty&quot;&gt;QObject::setProperty&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qobject#property&quot;&gt;QObject :: property&lt;/a&gt; () 및 &lt;a href=&quot;qobject#setProperty&quot;&gt;QObject :: setProperty&lt;/a&gt; ()를 사용하여 속성을 가져오고 설정하는 것이 더 빠릅니다 .</target>
        </trans-unit>
        <trans-unit id="45f5cd7292cd3f5c99451db94e661001a03c2bb0" translate="yes" xml:space="preserve">
          <source>Note that it is generally not recommended to override this.</source>
          <target state="translated">일반적으로 이것을 무시하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="9994389808e10a69537039100c72675792686a29" translate="yes" xml:space="preserve">
          <source>Note that it is meaningless to compare two instances of &lt;a href=&quot;qxmlname&quot;&gt;QXmlName&lt;/a&gt; that were created with different &lt;a href=&quot;qxmlnamepool&quot;&gt;name pools&lt;/a&gt;, but the attempt is not detected and the behavior is undefined.</source>
          <target state="translated">다른 &lt;a href=&quot;qxmlnamepool&quot;&gt;이름 풀로&lt;/a&gt; 작성된 &lt;a href=&quot;qxmlname&quot;&gt;QXmlName의&lt;/a&gt; 두 인스턴스를 비교하는 것은 의미가 없지만 시도는 감지되지 않으며 동작은 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5f7fbfa363a05fe3dfa8cd5d6bc68451c187118d" translate="yes" xml:space="preserve">
          <source>Note that it is not necessary to keep the original &lt;a href=&quot;qdbuspendingcall&quot;&gt;QDBusPendingCall&lt;/a&gt; object around since &lt;a href=&quot;qdbuspendingcallwatcher&quot;&gt;QDBusPendingCallWatcher&lt;/a&gt; inherits from that class too.</source>
          <target state="translated">원래 유지할 필요가 없다고 주 &lt;a href=&quot;qdbuspendingcall&quot;&gt;QDBusPendingCall의&lt;/a&gt; 이후 개체 주위를 &lt;a href=&quot;qdbuspendingcallwatcher&quot;&gt;QDBusPendingCallWatcher의&lt;/a&gt; 너무 그 클래스에서 상속됩니다.</target>
        </trans-unit>
        <trans-unit id="b136aab2f6ec7ecb0209d6ec42316b0dd28016f6" translate="yes" xml:space="preserve">
          <source>Note that it is not necessary to keep the original &lt;a href=&quot;qdbuspendingcall&quot;&gt;QDBusPendingCall&lt;/a&gt; object around since QDBusPendingCallWatcher inherits from that class too.</source>
          <target state="translated">&lt;a href=&quot;qdbuspendingcall&quot;&gt;QDBusPendingCallWatcher&lt;/a&gt; 도 해당 클래스에서 상속되기 때문에 원래 QDBusPendingCall 객체 를 유지할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="90c0da1dda5fef40a6a9d98a2ed9a49f57a346b0" translate="yes" xml:space="preserve">
          <source>Note that it is not required to hold an open session in order to obtain the network interface state. A connected but closed session may be used to monitor network interfaces whereas an open and connected session object may prevent the network interface from being shut down.</source>
          <target state="translated">네트워크 인터페이스 상태를 얻기 위해 열린 세션을 유지할 필요는 없습니다. 연결되었지만 닫힌 세션은 네트워크 인터페이스를 모니터링하는 데 사용될 수 있지만 열려 있고 연결된 세션 개체는 네트워크 인터페이스가 종료되는 것을 방지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b70f4f23e90f384c5ea3b0155803a673b612222" translate="yes" xml:space="preserve">
          <source>Note that it is not usually necessary to call this function directly, as it will be implicitly called by &lt;a href=&quot;qwindow#show&quot;&gt;show&lt;/a&gt;(), &lt;a href=&quot;qwindow#visible-prop&quot;&gt;setVisible&lt;/a&gt;(), and other functions that require access to the platform resources.</source>
          <target state="translated">&lt;a href=&quot;qwindow#show&quot;&gt;show&lt;/a&gt; (), &lt;a href=&quot;qwindow#visible-prop&quot;&gt;setVisible&lt;/a&gt; () 및 플랫폼 리소스에 액세스해야하는 다른 함수에 의해 암시 적으로 호출되므로 일반적으로이 함수를 직접 호출 할 필요는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="044795d694e75e262f743accb2225dd2f2047c75" translate="yes" xml:space="preserve">
          <source>Note that it is safe to call destroy() on an object within that object. Objects are not destroyed the instant destroy() is called, but are cleaned up sometime between the end of that script block and the next frame (unless you specified a non-zero delay).</source>
          <target state="translated">해당 객체 내의 객체에서 destroy ()를 호출하는 것이 안전합니다. 객체는 파괴되지 않고 즉시 destroy ()가 호출되지만 스크립트 블록의 끝과 다음 프레임 사이에서 언젠가 정리됩니다 (0이 아닌 지연을 지정하지 않은 경우).</target>
        </trans-unit>
        <trans-unit id="1d0dc8bc1bd9ea87b26c8cd2bfd192657f6cc1db" translate="yes" xml:space="preserve">
          <source>Note that it is sometimes easier to configure a dock widget if it is added to a form before a layout is applied to the central widget. For example, it is possible to undock it and resize it, making it more convenient to add child widgets.</source>
          <target state="translated">레이아웃이 중앙 위젯에 적용되기 전에 독 위젯이 양식에 추가되는 경우 독 위젯을 구성하는 것이 더 쉬운 경우가 있습니다. 예를 들어, 도킹을 해제하고 크기를 조정하여 하위 위젯을 추가하는 것이 더 편리합니다.</target>
        </trans-unit>
        <trans-unit id="8c6950439738fd8cd8e665dd612aa5378d723440" translate="yes" xml:space="preserve">
          <source>Note that it is undefined behavior to reimplement &lt;a href=&quot;qabstractitemmodel#hasChildren&quot;&gt;QAbstractItemModel::hasChildren&lt;/a&gt; to return true for an index if that index has the Qt::ItemNeverHasChildren flag set.</source>
          <target state="translated">인덱스에 Qt :: ItemNeverHasChildren 플래그가 설정된 경우 인덱스에 대해 true를 반환하는 &lt;a href=&quot;qabstractitemmodel#hasChildren&quot;&gt;QAbstractItemModel :: hasChildren&lt;/a&gt; 을 다시 구현하는 것은 정의되지 않은 동작 입니다.</target>
        </trans-unit>
        <trans-unit id="178a1cf2aedf1ce043c81e5546961a3d4f7d52c1" translate="yes" xml:space="preserve">
          <source>Note that it is undefined behavior to report that a particular index hasChildren with this method if the same index has the flag &lt;a href=&quot;qt#ItemFlag-enum&quot;&gt;Qt::ItemNeverHasChildren&lt;/a&gt; set.</source>
          <target state="translated">동일한 인덱스에 플래그 &lt;a href=&quot;qt#ItemFlag-enum&quot;&gt;Qt :: ItemNeverHasChildren이&lt;/a&gt; 설정 되어있는 경우 특정 인덱스에이 메소드를 가진 childChildren 이 있다고보고하는 것은 정의되지 않은 동작 입니다.</target>
        </trans-unit>
        <trans-unit id="3ef290c88dc16648dd0d906fd9e3996628dbd5e4" translate="yes" xml:space="preserve">
          <source>Note that it is up to the widget to activate the action, for example by reimplementing mouse event handlers and calling &lt;a href=&quot;qaction#trigger&quot;&gt;QAction::trigger&lt;/a&gt;().</source>
          <target state="translated">마우스 이벤트 핸들러를 다시 구현하고 &lt;a href=&quot;qaction#trigger&quot;&gt;QAction :: trigger&lt;/a&gt; ()를 호출하는 등의 조치를 활성화하는 것은 위젯에 달려 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c3a503b2bd720fb23daae9d66f27f2e571147d7d" translate="yes" xml:space="preserve">
          <source>Note that it's perfectly reasonable for a library to register types to older versions than the actual version of the library. Indeed, it is normal for the new library to allow QML written to previous versions to continue to work, even if more advanced versions of some of its types are available.</source>
          <target state="translated">라이브러리가 실제 버전의 라이브러리보다 이전 버전에 유형을 등록하는 것이 합리적입니다. 실제로 새 라이브러리에서 일부 유형의 고급 버전을 사용할 수 있더라도 이전 버전으로 작성된 QML이 계속 작동하는 것이 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="0857371f3c04ced93f844f9eefaf9c9c8e01ee3d" translate="yes" xml:space="preserve">
          <source>Note that it's possible to squeeze the XPM variable a little bit by using an unusual declaration:</source>
          <target state="translated">특이한 선언을 사용하여 XPM 변수를 약간 짜낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f3b9a4c1772eba566baa9934da0af716117f8bea" translate="yes" xml:space="preserve">
          <source>Note that item dragging must be enabled in the view for dragging to work; see &lt;a href=&quot;qabstractitemview#dragEnabled-prop&quot;&gt;QAbstractItemView::dragEnabled&lt;/a&gt;.</source>
          <target state="translated">드래그가 작동하려면보기에서 항목 드래그를 활성화해야합니다. &lt;a href=&quot;qabstractitemview#dragEnabled-prop&quot;&gt;QAbstractItemView :: dragEnabled를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="172095200678d06c4918c5bfc7f4eb5204c75ccc" translate="yes" xml:space="preserve">
          <source>Note that items can be dropped into the top level of the model, but dragging is only enabled for valid items.</source>
          <target state="translated">아이템은 모델의 최상위 레벨에 놓을 수 있지만 드래그는 유효한 아이템에 대해서만 가능합니다.</target>
        </trans-unit>
        <trans-unit id="0ca11a203ca8aaa3b1d3b4d57d1c537a3a933b7d" translate="yes" xml:space="preserve">
          <source>Note that items in a Column can use the &lt;a href=&quot;qml-qtquick-positioner&quot;&gt;Positioner&lt;/a&gt; attached property to access more information about its position within the Column.</source>
          <target state="translated">열의 항목은 &lt;a href=&quot;qml-qtquick-positioner&quot;&gt;Positioner&lt;/a&gt; attached 속성을 사용하여 열 내의 위치에 대한 자세한 정보에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="55befcc16a0925c0f81b34f5adce462cd703af65" translate="yes" xml:space="preserve">
          <source>Note that items in a Row can use the &lt;a href=&quot;qml-qtquick-positioner&quot;&gt;Positioner&lt;/a&gt; attached property to access more information about its position within the Row.</source>
          <target state="translated">행의 항목은 &lt;a href=&quot;qml-qtquick-positioner&quot;&gt;Positioner&lt;/a&gt; attached 속성을 사용하여 행 내 위치에 대한 자세한 정보에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c1b59852db4fa29933ecc96aba78c3113d6cd262" translate="yes" xml:space="preserve">
          <source>Note that key events are only received for items that set the &lt;a href=&quot;qgraphicsitem#GraphicsItemFlag-enum&quot;&gt;ItemIsFocusable&lt;/a&gt; flag, and that have keyboard input focus.</source>
          <target state="translated">키 이벤트는 &lt;a href=&quot;qgraphicsitem#GraphicsItemFlag-enum&quot;&gt;ItemIsFocusable&lt;/a&gt; 플래그 를 설정하고 키보드 입력 포커스가 있는 항목에 대해서만 수신됩니다 .</target>
        </trans-unit>
        <trans-unit id="473a4f1d05c420468d738b00e7f26ca05db21503" translate="yes" xml:space="preserve">
          <source>Note that logging must have been started or the value of this property will be meaningless.</source>
          <target state="translated">로깅이 시작되었거나이 특성의 값은 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="c3d5d7cf0741edf09a82620a7543e312fdd7ccb1" translate="yes" xml:space="preserve">
          <source>Note that logical particles are not automatically rendered, you will need to have one or more &lt;a href=&quot;qml-qtquick-particles-particlepainter&quot;&gt;ParticlePainter&lt;/a&gt; elements visualizing them.</source>
          <target state="translated">논리 파티클은 자동으로 렌더링되지 않으므로 이를 시각화하는 하나 이상의 &lt;a href=&quot;qml-qtquick-particles-particlepainter&quot;&gt;ParticlePainter&lt;/a&gt; 요소 가 있어야 합니다.</target>
        </trans-unit>
        <trans-unit id="9c07830b9dab013575aa7bf01f12873edb367dce" translate="yes" xml:space="preserve">
          <source>Note that matrix multiplication is not commutative, i.e. a*b != b*a.</source>
          <target state="translated">행렬 곱셈은 순차적이지 않습니다. 즉 a * b! = b * a.</target>
        </trans-unit>
        <trans-unit id="66879cabe0a9acedd15541cda9915fe8a7d3143d" translate="yes" xml:space="preserve">
          <source>Note that models are not &lt;a href=&quot;qml-qtquick3d-model#pickable-prop&quot;&gt;pickable&lt;/a&gt; by default, so to be able to &lt;a href=&quot;qml-qtquick3d-view3d#pick-method&quot;&gt;pick&lt;/a&gt; a model in the scene, the model will need to make it self discoverable by setting the &lt;a href=&quot;qml-qtquick3d-model#pickable-prop&quot;&gt;pickable&lt;/a&gt; property to true. Visit the &lt;a href=&quot;https://doc.qt.io/qt-6.0/qtquick3d-picking-example.html&quot;&gt;Qt Quick 3D - Picking example&lt;/a&gt; to see how picking can be enabled.</source>
          <target state="translated">모델이되지 않도록주의 &lt;a href=&quot;qml-qtquick3d-model#pickable-prop&quot;&gt;pickable&lt;/a&gt; 그렇게 할 수 있도록 기본적으로 &lt;a href=&quot;qml-qtquick3d-view3d#pick-method&quot;&gt;선택&lt;/a&gt; 장면에서 모델을, 모델은 설정하여 자기를 검색 할 수 있도록해야합니다 &lt;a href=&quot;qml-qtquick3d-model#pickable-prop&quot;&gt;pickable&lt;/a&gt; 속성을 true로. &lt;a href=&quot;https://doc.qt.io/qt-6.0/qtquick3d-picking-example.html&quot;&gt;Qt Quick 3D-Picking 예제&lt;/a&gt; 를 방문하여 피킹 을 활성화하는 방법을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="1947c382d91d6d387c0924818c4231bade1bc0f9" translate="yes" xml:space="preserve">
          <source>Note that modifying this list with setServicesWatched() is an expensive operation. If you can, prefer to change it by way of &lt;a href=&quot;qdbusservicewatcher#addWatchedService&quot;&gt;addWatchedService&lt;/a&gt;() and &lt;a href=&quot;qdbusservicewatcher#removeWatchedService&quot;&gt;removeWatchedService&lt;/a&gt;().</source>
          <target state="translated">setServicesWatched ()로이 목록을 수정하면 많은 비용이 소요됩니다. 가능하면 &lt;a href=&quot;qdbusservicewatcher#addWatchedService&quot;&gt;addWatchedService&lt;/a&gt; () 및 &lt;a href=&quot;qdbusservicewatcher#removeWatchedService&quot;&gt;removeWatchedService&lt;/a&gt; () 를 통해 변경하는 것을 선호합니다 .</target>
        </trans-unit>
        <trans-unit id="d8b052ddd2b28b3097499ed0a8dac27c2ffd4aa0" translate="yes" xml:space="preserve">
          <source>Note that most of the time, you can use one of the constructors instead of begin(), and that &lt;a href=&quot;qpainter#end&quot;&gt;end&lt;/a&gt;() is automatically done at destruction.</source>
          <target state="translated">대부분의 경우 begin () 대신 생성자 중 하나를 사용할 수 있으며 &lt;a href=&quot;qpainter#end&quot;&gt;end&lt;/a&gt; ()는 자동으로 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="6b62ee01075b1fadb72e2f12d7d682fb0334f578" translate="yes" xml:space="preserve">
          <source>Note that most platforms require a pairing prior to connecting to the remote device. Otherwise the connection process may fail.</source>
          <target state="translated">대부분의 플랫폼은 원격 장치에 연결하기 전에 페어링이 필요합니다. 그렇지 않으면 연결 프로세스가 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="86fe514eddb3d068b2057d00d8fad0daec946b2c" translate="yes" xml:space="preserve">
          <source>Note that multiple QML documents can import &lt;code&gt;&quot;factorial.js&quot;&lt;/code&gt; and call the factorial and factorialCallCount functions that it provides. The state of the JavaScript import is shared across the QML documents which import it, and thus the return value of the factorialCallCount function may be non-zero when called within a QML document which never calls the factorial function.</source>
          <target state="translated">여러 QML 문서는 &lt;code&gt;&quot;factorial.js&quot;&lt;/code&gt; 를 가져 와서 제공하는 factorial 및 factorialCallCount 함수를 호출 할 수 있습니다. JavaScript 가져 오기 상태는이를 가져 오는 QML 문서에서 공유되므로 factorialCallCount 함수의 리턴 값은 factorial 함수를 호출하지 않는 QML 문서 내에서 호출 될 때 0이 아닐 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7db960726f88fb71ae7094c5dfd0d419814734e4" translate="yes" xml:space="preserve">
          <source>Note that multiple modules can be imported into the same namespace in the same way that multiple modules can be imported into the global namespace. For example:</source>
          <target state="translated">여러 개의 모듈을 전역 네임 스페이스로 가져올 수있는 것과 같은 방식으로 여러 개의 모듈을 동일한 네임 스페이스로 가져올 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f70ef22ca19e9551413a1063888d0c9f63c740da" translate="yes" xml:space="preserve">
          <source>Note that negative leading is ignored, it must be handled in the code using the text lines by letting the lines overlap.</source>
          <target state="translated">음의 선행은 무시되므로 행을 겹치게하여 텍스트 행을 사용하여 코드에서 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="69a2a56c9d8d93e92126e019689119ce8a45b57b" translate="yes" xml:space="preserve">
          <source>Note that no editor widgets are set up when the delegate is constructed. We only construct an editor widget when it is needed.</source>
          <target state="translated">델리게이트가 생성 될 때 편집기 위젯이 설정되지 않습니다. 필요한 경우에만 편집기 위젯을 구성합니다.</target>
        </trans-unit>
        <trans-unit id="056bb2a0f1eb0882ae87203fbd7b221c22b0c654" translate="yes" xml:space="preserve">
          <source>Note that no functions of the control are called.</source>
          <target state="translated">컨트롤의 기능은 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="85b82cc3d65c6ec49475ab50626000dbb32b7c81" translate="yes" xml:space="preserve">
          <source>Note that not all pixmaps will conform, in which case the returned pixmap is a plain copy.</source>
          <target state="translated">모든 픽스맵이 준수되는 것은 아니며 반환 된 픽스맵은 일반 사본입니다.</target>
        </trans-unit>
        <trans-unit id="13316a3020567da5899f78e5bfffa083824faf6b" translate="yes" xml:space="preserve">
          <source>Note that not all primitives use all of these flags, and that the flags may mean different things to different items.</source>
          <target state="translated">모든 프리미티브가 이러한 플래그를 모두 사용하는 것은 아니며 플래그는 항목마다 다른 것을 의미 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2fa67f67780e558e86642381d2f614fd1f7aba98" translate="yes" xml:space="preserve">
          <source>Note that objects cannot be individually added to or removed from the list once created; to modify the contents of a list, it must be reassigned to a new list.</source>
          <target state="translated">한 번 작성된 오브젝트는 목록에 개별적으로 추가하거나 제거 할 수 없습니다. 목록의 내용을 수정하려면 새 목록에 다시 할당해야합니다.</target>
        </trans-unit>
        <trans-unit id="f5a576825690b830885108256212dfd4f9090fc2" translate="yes" xml:space="preserve">
          <source>Note that on Mac OS X 10.3 (Panther), dynamic libraries cannot be unloaded.</source>
          <target state="translated">Mac OS X 10.3 (Panther)에서는 동적 라이브러리를 언로드 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="bd0da880e32abad642a2a9938c1336ba33bfff64" translate="yes" xml:space="preserve">
          <source>Note that on Windows and &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; custom paper sizes won't be reflected in the native page setup dialogs. Additionally, custom page margins set on a &lt;a href=&quot;qprinter&quot;&gt;QPrinter&lt;/a&gt; won't show in the native &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; page setup dialog.</source>
          <target state="translated">Windows 및 &lt;a href=&quot;internationalization#macos&quot;&gt;macOS에서&lt;/a&gt; 사용자 정의 용지 크기는 기본 페이지 설정 대화 상자에 반영되지 않습니다. 또한 &lt;a href=&quot;qprinter&quot;&gt;QPrinter에&lt;/a&gt; 설정된 사용자 정의 페이지 여백 은 기본 &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; 페이지 설정 대화 상자에 표시되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="1a55a7683169b806e72c91e6c8d4fc8ebdcb84b7" translate="yes" xml:space="preserve">
          <source>Note that on Windows and macOS custom paper sizes won't be reflected in the native page setup dialogs. Additionally, custom page margins set on a &lt;a href=&quot;qprinter&quot;&gt;QPrinter&lt;/a&gt; won't show in the native macOS page setup dialog.</source>
          <target state="translated">Windows 및 macOS에서 사용자 정의 용지 크기는 기본 페이지 설정 대화 상자에 반영되지 않습니다. 또한 &lt;a href=&quot;qprinter&quot;&gt;QPrinter에&lt;/a&gt; 설정된 사용자 정의 페이지 여백 은 기본 macOS 페이지 설정 대화 상자에 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="25c5da08d0c5962f18d2343364afc7d08ac2feb3" translate="yes" xml:space="preserve">
          <source>Note that on some systems, this value will persist across reboots and on some it will not. Applications should not blindly depend on this fact without verifying the OS capabilities. In particular, on Linux systems, this ID is usually permanent and it matches the D-Bus machine ID, except for nodes without their own storage (replicated nodes).</source>
          <target state="translated">일부 시스템에서는이 값이 재부팅 후에도 유지되고 일부 시스템에서는 유지되지 않습니다. OS 기능을 확인하지 않고 애플리케이션이이 사실에 맹목적으로 의존해서는 안됩니다. 특히 Linux 시스템에서이 ID는 일반적으로 영구적이며 자체 스토리지가없는 노드 (복제 된 노드)를 제외하고 D-Bus 시스템 ID와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="95f4b9053f1c1bf68110521e3f176ace7789df42" translate="yes" xml:space="preserve">
          <source>Note that on success the thread pool takes ownership of the</source>
          <target state="translated">성공하면 스레드 풀이</target>
        </trans-unit>
        <trans-unit id="7af4bdcdf60b2e34420d77afa5661e47c47c0503" translate="yes" xml:space="preserve">
          <source>Note that on systems that support system colors, the style's standard palette is not used. In particular, the Windows Vista and Mac styles do not use the standard palette, but make use of native theme engines. With these styles, you should not set the palette with &lt;a href=&quot;qapplication#setPalette&quot;&gt;QApplication::setPalette&lt;/a&gt;().</source>
          <target state="translated">시스템 색상을 지원하는 시스템에서는 스타일의 표준 팔레트가 사용되지 않습니다. 특히, Windows Vista 및 Mac 스타일은 표준 팔레트를 사용하지 않지만 기본 테마 엔진을 사용합니다. 이러한 스타일을 사용하면 &lt;a href=&quot;qapplication#setPalette&quot;&gt;QApplication :: setPalette&lt;/a&gt; ()로 팔레트를 설정하지 않아야합니다 .</target>
        </trans-unit>
        <trans-unit id="d8f83b0907014908753b595bf4b798092a00fe7b" translate="yes" xml:space="preserve">
          <source>Note that one network interface cannot be both broadcast-based and point-to-point.</source>
          <target state="translated">하나의 네트워크 인터페이스는 브로드 캐스트 기반 및 포인트 투 포인트가 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="42238f9e235502b13057c0dfb5d47fd4fae637f3" translate="yes" xml:space="preserve">
          <source>Note that only &lt;a href=&quot;qitemselectionmodel#SelectionFlag-enum&quot;&gt;QItemSelectionModel::Select&lt;/a&gt;, &lt;a href=&quot;qitemselectionmodel#SelectionFlag-enum&quot;&gt;QItemSelectionModel::Deselect&lt;/a&gt;, and &lt;a href=&quot;qitemselectionmodel#SelectionFlag-enum&quot;&gt;QItemSelectionModel::Toggle&lt;/a&gt; are supported.</source>
          <target state="translated">단지 참고 &lt;a href=&quot;qitemselectionmodel#SelectionFlag-enum&quot;&gt;QItemSelectionModel :: 선택&lt;/a&gt; , &lt;a href=&quot;qitemselectionmodel#SelectionFlag-enum&quot;&gt;QItemSelectionModel :: 선택을 취소&lt;/a&gt; 하고, &lt;a href=&quot;qitemselectionmodel#SelectionFlag-enum&quot;&gt;QItemSelectionModel :: 전환이&lt;/a&gt; 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="019a91b030a7adce406e921da4c19e56a2385765" translate="yes" xml:space="preserve">
          <source>Note that only &lt;a href=&quot;qmdisubwindow&quot;&gt;QMdiSubWindow&lt;/a&gt;s can be set as children of &lt;a href=&quot;qmdiarea&quot;&gt;QMdiArea&lt;/a&gt;; you cannot, for instance, write:</source>
          <target state="translated">오직주의 &lt;a href=&quot;qmdisubwindow&quot;&gt;QMdiSubWindow&lt;/a&gt; 의가의 자식으로 설정 될 수 &lt;a href=&quot;qmdiarea&quot;&gt;QMdiArea&lt;/a&gt; ; 예를 들어 다음과 같이 쓸 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e7521cb8b47b0e534d0429c4fecd792943d0515f" translate="yes" xml:space="preserve">
          <source>Note that only constructors that are declared with the &lt;a href=&quot;qobject#Q_INVOKABLE&quot;&gt;Q_INVOKABLE&lt;/a&gt; modifier are made available through the meta-object system.</source>
          <target state="translated">&lt;a href=&quot;qobject#Q_INVOKABLE&quot;&gt;Q_INVOKABLE&lt;/a&gt; 수정 자로 선언 된 생성자 만 메타 오브젝트 시스템을 통해 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="46b275c531122a8aabcaf3a48baf60fd5c98fd56" translate="yes" xml:space="preserve">
          <source>Note that only the Full form of the cookie can be parsed back into its original contents.</source>
          <target state="translated">쿠키의 전체 형식 만 원래 내용으로 다시 구문 분석 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f89d93871ba9550ac373f17887c88ee326f6f93b" translate="yes" xml:space="preserve">
          <source>Note that only the states the underlying paint engine changes will be reset to their respective default states. The states we reset may change from release to release. The following states are currently reset in the OpenGL 2 engine:</source>
          <target state="translated">기본 페인트 엔진 변경 상태 만 해당 기본 상태로 재설정됩니다. 재설정 한 상태는 릴리스마다 변경 될 수 있습니다. 다음 상태는 현재 OpenGL 2 엔진에서 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="18a00d29f533fc4c86f3fe70c6fa8c630c895ca2" translate="yes" xml:space="preserve">
          <source>Note that only values that are marked as generated will be updated. The generated flag can be set with &lt;a href=&quot;qsqlrecord#setGenerated&quot;&gt;QSqlRecord::setGenerated&lt;/a&gt;() and checked with &lt;a href=&quot;qsqlrecord#isGenerated&quot;&gt;QSqlRecord::isGenerated&lt;/a&gt;().</source>
          <target state="translated">생성 된 것으로 표시된 값만 업데이트됩니다. 생성 된 플래그는 &lt;a href=&quot;qsqlrecord#setGenerated&quot;&gt;QSqlRecord :: setGenerated&lt;/a&gt; () 로 설정 하고 &lt;a href=&quot;qsqlrecord#isGenerated&quot;&gt;QSqlRecord :: isGenerated&lt;/a&gt; ()로 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a01f29a1a6f0606343422579ba1e16c360a5991" translate="yes" xml:space="preserve">
          <source>Note that only values that have the generated-flag set are updated. The generated-flag can be set with &lt;a href=&quot;qsqlrecord#setGenerated&quot;&gt;QSqlRecord::setGenerated&lt;/a&gt;() and tested with &lt;a href=&quot;qsqlrecord#isGenerated&quot;&gt;QSqlRecord::isGenerated&lt;/a&gt;().</source>
          <target state="translated">생성 된 플래그가 설정된 값만 업데이트됩니다. 생성 된 플래그가 설정 될 수있다 &lt;a href=&quot;qsqlrecord#setGenerated&quot;&gt;: QSqlRecord setGenerated&lt;/a&gt; 와 () 및 시험 &lt;a href=&quot;qsqlrecord#isGenerated&quot;&gt;QSqlRecord :: isGenerated&lt;/a&gt; ().</target>
        </trans-unit>
        <trans-unit id="5a36357155ce3252c682c2eb197b9b80db2befb8" translate="yes" xml:space="preserve">
          <source>Note that only visible items can grab keyboard input. Calling grabKeyboard() on an invisible item has no effect.</source>
          <target state="translated">보이는 항목 만 키보드 입력을 잡을 수 있습니다. 보이지 않는 항목에서 grabKeyboard ()를 호출해도 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="f8c662b7df88ec37d3af44df064acbfc85cf07c2" translate="yes" xml:space="preserve">
          <source>Note that only visible items can grab mouse input. Calling grabMouse() on an invisible item has no effect.</source>
          <target state="translated">보이는 항목 만 마우스 입력을 잡을 수 있습니다. 보이지 않는 항목에서 grabMouse ()를 호출해도 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="3a22d6e64ad94731eabd37555675f63615789ad8" translate="yes" xml:space="preserve">
          <source>Note that other libraries that define variables called &lt;code&gt;signals&lt;/code&gt; or &lt;code&gt;slots&lt;/code&gt; may cause compiler warnings and errors when compiled alongside a Qt-based application. To solve this problem, &lt;code&gt;#undef&lt;/code&gt; the offending preprocessor symbol.</source>
          <target state="translated">&lt;code&gt;signals&lt;/code&gt; 또는 &lt;code&gt;slots&lt;/code&gt; 이라는 변수를 정의하는 다른 라이브러리 는 Qt 기반 응용 프로그램과 함께 컴파일 될 때 컴파일러 경고 및 오류를 유발할 수 있습니다. 이 문제를 해결하려면 문제 가되는 전 처리기 기호를 &lt;code&gt;#undef&lt;/code&gt; 로 지정 하십시오.</target>
        </trans-unit>
        <trans-unit id="d3c853c4ebb56d0d3b2d67511da4bdc9d0f8416a" translate="yes" xml:space="preserve">
          <source>Note that other rows may be displaced accordingly.</source>
          <target state="translated">다른 행도 그에 따라 대체 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="051375711d34ba24c18759e9f12bae9c1b8e9ba2" translate="yes" xml:space="preserve">
          <source>Note that other rows may be displaced accordingly. Note also that when moving items within the same parent you should not attempt invalid or no-op moves. In the above example, item 2 is at row 2 before the move, so it cannot be moved to row 2 (where it is already) or row 3 (no-op as row 3 means above row 3, where it is already)</source>
          <target state="translated">다른 행도 그에 따라 대체 될 수 있습니다. 또한 동일한 상위 내에서 항목을 이동할 때 유효하지 않거나 이동하지 않아야합니다. 위의 예에서 항목 2는 이동 전에 행 2에 있으므로 행 2 (이미있는 위치) 또는 행 3으로 이동할 수 없습니다 (행 3은 이미 행 3의 위를 의미하므로 작동하지 않음)</target>
        </trans-unit>
        <trans-unit id="7dbc30dd5c039e7142ab3b76bb62281f0cd3f3c8" translate="yes" xml:space="preserve">
          <source>Note that ownership must be taken care of by subclasses of &lt;a href=&quot;qgeoareamonitorsource&quot;&gt;QGeoAreaMonitorSource&lt;/a&gt;. Due to the singleton pattern behind this class</source>
          <target state="translated">소유권은 &lt;a href=&quot;qgeoareamonitorsource&quot;&gt;QGeoAreaMonitorSource의&lt;/a&gt; 서브 클래스에 의해 처리되어야합니다 . 이 클래스 뒤의 싱글 톤 패턴으로 인해</target>
        </trans-unit>
        <trans-unit id="aee666352f858e9d84e4b3a49616bb53cc6ea791" translate="yes" xml:space="preserve">
          <source>Note that particle count is often estimated by the particle system, and in some cases explicitly providing hints as to how many particles will be needed will improve performance. You can do this by setting maximumEmitted on an Emitter, and it is generally useful for Emitters which do not continuously emit particles.</source>
          <target state="translated">입자 수는 종종 입자 시스템에 의해 추정되며 경우에 따라 필요한 입자 수에 대한 힌트를 명시 적으로 제공하면 성능이 향상됩니다. 이미 터에서 maximumEmitted를 설정하여이 작업을 수행 할 수 있으며 일반적으로 입자를 계속 방출하지 않는 이미 터에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="90abf035ba0d267228983e9c29fcea516687263c" translate="yes" xml:space="preserve">
          <source>Note that passing the dot expression to the &lt;a href=&quot;http://www.w3.org/TR/xpath-functions/#func-string-length&quot;&gt;string-length()&lt;/a&gt; function is optional. When &lt;a href=&quot;http://www.w3.org/TR/xpath-functions/#func-string-length&quot;&gt;string-length()&lt;/a&gt; is called with no parameter, the context node is assumed:</source>
          <target state="translated">점 표현식을 &lt;a href=&quot;http://www.w3.org/TR/xpath-functions/#func-string-length&quot;&gt;string-length ()&lt;/a&gt; 함수에 전달하는 것은 선택 사항입니다. 경우 &lt;a href=&quot;http://www.w3.org/TR/xpath-functions/#func-string-length&quot;&gt;문자열 길이 ()는&lt;/a&gt; 매개 변수없이 호출 컨텍스트 노드 가정한다 :</target>
        </trans-unit>
        <trans-unit id="dafa43666581dee47cdf038f7227db7f47ad10c6" translate="yes" xml:space="preserve">
          <source>Note that passing the minimum of &lt;code&gt;qint64&lt;/code&gt; (&lt;code&gt;std::numeric_limits&amp;lt;qint64&amp;gt;::min()&lt;/code&gt;) to</source>
          <target state="translated">최소 &lt;code&gt;qint64&lt;/code&gt; ( &lt;code&gt;std::numeric_limits&amp;lt;qint64&amp;gt;::min()&lt;/code&gt; )를 전달하여</target>
        </trans-unit>
        <trans-unit id="b1b46ffc5079b476e597970c77761d7e4f161084" translate="yes" xml:space="preserve">
          <source>Note that passing the value &lt;code&gt;QSound::Infinite&lt;/code&gt; will cause the sound to loop indefinitely.</source>
          <target state="translated">&lt;code&gt;QSound::Infinite&lt;/code&gt; 값을 전달하면 사운드가 무한정 반복됩니다.</target>
        </trans-unit>
        <trans-unit id="5171e5ddc7d74edcc6d312d1fb226c8ba1ae84c0" translate="yes" xml:space="preserve">
          <source>Note that pressing the stylus button while the stylus hovers over the tablet will generate a button press on some types of tablets, while on other types it will be necessary to press the stylus against the tablet surface in order to register the simultaneous stylus button press.</source>
          <target state="translated">스타일러스가 태블릿 위로 마우스를 가져가는 동안 스타일러스 버튼을 누르면 일부 유형의 태블릿에서 버튼을 누르는 반면, 다른 유형의 경우 스타일러스 버튼을 동시에 등록하려면 스타일러스를 태블릿 표면에 눌러야합니다.</target>
        </trans-unit>
        <trans-unit id="3991f0be1309a9322720ebb4add2dce9a2bd9cc2" translate="yes" xml:space="preserve">
          <source>Note that properties of the returned object that are themselves objects will also be models, and this get() method is used to access elements:</source>
          <target state="translated">반환 된 객체 자체가 객체 인 속성도 모델이며이 get () 메서드는 요소에 액세스하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="acf4c296f084b0eb3fb482bde82066932d0bdcb3" translate="yes" xml:space="preserve">
          <source>Note that qintptr is signed. Use quintptr for unsigned values.</source>
          <target state="translated">qintptr이 서명되었습니다. 부호없는 값에 quintptr을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="8e433cdfc89082986e5808abb818280f92a244d3" translate="yes" xml:space="preserve">
          <source>Note that qptrdiff is signed. Use quintptr for unsigned values.</source>
          <target state="translated">qptrdiff가 서명되었습니다. 부호없는 값에 quintptr을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="73dcfa8bdd65361b28d32d1a093fcb8e8642f3f5" translate="yes" xml:space="preserve">
          <source>Note that qsizetype is signed. Use &lt;code&gt;size_t&lt;/code&gt; for unsigned values.</source>
          <target state="translated">qsizetype이 서명되었습니다. 부호없는 값 에는 &lt;code&gt;size_t&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
