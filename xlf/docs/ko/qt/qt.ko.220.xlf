<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="qt">
    <body>
      <group id="qt">
        <trans-unit id="19701840edc2433c984b872dd6df9cbe2004f821" translate="yes" xml:space="preserve">
          <source>The meaning of the fields is defined in &lt;a href=&quot;http://www.rfc-editor.org/rfc/rfc2782.txt&quot;&gt;RFC 2782&lt;/a&gt;.</source>
          <target state="translated">필드의 의미는 &lt;a href=&quot;http://www.rfc-editor.org/rfc/rfc2782.txt&quot;&gt;RFC 2782에&lt;/a&gt; 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="d20de4d8524584db0ecaae4e20946715d95ef73f" translate="yes" xml:space="preserve">
          <source>The meaning of the name depends on the subclass:</source>
          <target state="translated">이름의 의미는 서브 클래스에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="311e00646a258e7e2bb0d05a3d781995d6fc435d" translate="yes" xml:space="preserve">
          <source>The meaning of the pattern string can be modified by setting one or more</source>
          <target state="translated">패턴 문자열의 의미는 하나 이상을 설정하여 수정할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="5bfb32f0edb100dd13398c043b121b863e81e26b" translate="yes" xml:space="preserve">
          <source>The meaning of the value depends on the subclass:</source>
          <target state="translated">값의 의미는 서브 클래스에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="ef9d514fdd6504ae72cc243408db40464d18df7a" translate="yes" xml:space="preserve">
          <source>The means of making requests on the backend to supply route information.</source>
          <target state="translated">백엔드에서 경로 정보를 제공하도록 요청하는 수단입니다.</target>
        </trans-unit>
        <trans-unit id="24d612f2cc988c391d8654224cca392cb3aa9d8d" translate="yes" xml:space="preserve">
          <source>The measurement system can be set independently of the locale. Both &lt;a href=&quot;qgeoroutingmanager#setLocale&quot;&gt;setLocale&lt;/a&gt;() and this function set the measurement system. The value set by the last function called will be used.</source>
          <target state="translated">측정 시스템은 로케일과 독립적으로 설정할 수 있습니다. 모두 &lt;a href=&quot;qgeoroutingmanager#setLocale&quot;&gt;의 setLocale&lt;/a&gt; ()이 기능은 측정 시스템을 설정합니다. 마지막으로 호출 된 함수에서 설정 한 값이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6e5ba730b4df14a085e83dfab84f1dbb40a83071" translate="yes" xml:space="preserve">
          <source>The measurement system can be set independently of the locale. Both &lt;a href=&quot;qgeoroutingmanagerengine#setLocale&quot;&gt;setLocale&lt;/a&gt;() and this function set the measurement system. The value set by the last function called will be used.</source>
          <target state="translated">측정 시스템은 로케일과 독립적으로 설정할 수 있습니다. 모두 &lt;a href=&quot;qgeoroutingmanagerengine#setLocale&quot;&gt;의 setLocale&lt;/a&gt; ()이 기능은 측정 시스템을 설정합니다. 마지막으로 호출 된 함수에서 설정 한 값이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="45f7078718169f105867002a71156e562797a816" translate="yes" xml:space="preserve">
          <source>The mechanism for handling selections of items within views is provided by the &lt;a href=&quot;qitemselectionmodel&quot;&gt;QItemSelectionModel&lt;/a&gt; class. All of the standard views construct their own selection models by default, and interact with them in the normal way. The selection model being used by a view can be obtained through the &lt;a href=&quot;qabstractitemview#selectionModel&quot;&gt;selectionModel()&lt;/a&gt; function, and a replacement selection model can be specified with &lt;a href=&quot;qabstractitemview#setSelectionModel&quot;&gt;setSelectionModel()&lt;/a&gt;. The ability to control the selection model used by a view is useful when we want to provide multiple consistent views onto the same model data.</source>
          <target state="translated">뷰에서 항목 선택을 처리하는 메커니즘은 &lt;a href=&quot;qitemselectionmodel&quot;&gt;QItemSelectionModel&lt;/a&gt; 클래스에 의해 제공됩니다 . 모든 표준 뷰는 기본적으로 자체 선택 모델을 구성하고 일반적인 방식으로 상호 작용합니다. 뷰에서 사용하는 선택 모델은 &lt;a href=&quot;qabstractitemview#selectionModel&quot;&gt;selectionModel ()&lt;/a&gt; 함수를 통해 얻을 수 있으며 대체 선택 모델은 &lt;a href=&quot;qabstractitemview#setSelectionModel&quot;&gt;setSelectionModel ()&lt;/a&gt; 으로 지정할 수 있습니다 . 뷰에서 사용하는 선택 모델을 제어하는 ​​기능은 동일한 모델 데이터에 여러 개의 일관된 뷰를 제공하려는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="42ec9205de695c3d8566b16af2ec8adee491f6f9" translate="yes" xml:space="preserve">
          <source>The mechanisms for providing attached objects can be implemented from C++ by providing classes for the</source>
          <target state="translated">연결된 객체를 제공하는 메커니즘은 C ++에서 구현할 수있는 클래스를 제공하여 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c9383c800f3f465d9973d575f121aea06f1c80e2" translate="yes" xml:space="preserve">
          <source>The media is paused.</source>
          <target state="translated">미디어가 일시 중지되었습니다.</target>
        </trans-unit>
        <trans-unit id="fbead6078d52355d5af7ac6cd5f905e4d8a15a1a" translate="yes" xml:space="preserve">
          <source>The media player has paused playback, playback of the current track will resume from the position the player was paused at.</source>
          <target state="translated">미디어 플레이어가 재생을 일시 정지했습니다. 현재 트랙의 재생은 플레이어가 일시 정지 된 위치에서 다시 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="b51d32917f411da927c2c03af363645edb1ad00c" translate="yes" xml:space="preserve">
          <source>The media player is available to use.</source>
          <target state="translated">미디어 플레이어를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="22f32fb4ff17b92293963e1206eb9988adc5aa6c" translate="yes" xml:space="preserve">
          <source>The media player is currently playing content.</source>
          <target state="translated">미디어 플레이어가 현재 콘텐츠를 재생하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6fcea5d49cdad663aa138e1fa0a80c17b9916a9" translate="yes" xml:space="preserve">
          <source>The media player is not playing content, playback will begin from the start of the current track.</source>
          <target state="translated">미디어 플레이어가 컨텐츠를 재생하지 않고 현재 트랙의 시작 부분부터 재생이 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="7c5f9e6d2b784560c54cf11409149b99710867a0" translate="yes" xml:space="preserve">
          <source>The media player is usually available, but some other process is utilizing the hardware necessary to play media.</source>
          <target state="translated">미디어 플레이어는 일반적으로 사용 가능하지만 일부 다른 프로세스는 미디어를 재생하는 데 필요한 하드웨어를 사용하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="d39d7e6f73dfa5a6aabab3c970e4a330d95426f5" translate="yes" xml:space="preserve">
          <source>The media will first be processed to determine the characteristics, and then processed a second time allocating more bits to the areas that need it.</source>
          <target state="translated">미디어는 먼저 특성을 결정하기 위해 처리 된 다음 필요한 영역에 더 많은 비트를 할당하여 두 번째로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="b41f34e6681137e97157c2b2f79392f2e8b200f8" translate="yes" xml:space="preserve">
          <source>The media's copyright notice.</source>
          <target state="translated">미디어의 저작권 고지.</target>
        </trans-unit>
        <trans-unit id="6f95c0e9206b15d9d299f166da92d9662109a980" translate="yes" xml:space="preserve">
          <source>The median value of the box-and-whiskers item.</source>
          <target state="translated">상자 및 수염 품목의 중간 값.</target>
        </trans-unit>
        <trans-unit id="f4d53512884db0010396a757eb1fac4168079174" translate="yes" xml:space="preserve">
          <source>The median value of the lower half of the box-and-whiskers item.</source>
          <target state="translated">상자와 수염 항목의 아래쪽 절반의 중앙값입니다.</target>
        </trans-unit>
        <trans-unit id="483d0895a57266d12df8602d6b7801437f8b92ad" translate="yes" xml:space="preserve">
          <source>The median value of the upper half of the box-and-whiskers item.</source>
          <target state="translated">상자와 수염 항목의 상반부의 중간 값.</target>
        </trans-unit>
        <trans-unit id="0c1c9c77b87a26e416c1a8f6fef09817b7077c66" translate="yes" xml:space="preserve">
          <source>The member is invalid.</source>
          <target state="translated">회원이 잘못되었습니다.</target>
        </trans-unit>
        <trans-unit id="557b858b0bd542cbbfa368024ac0681f6eb2f659" translate="yes" xml:space="preserve">
          <source>The members and enums in &lt;a href=&quot;qaccessible&quot;&gt;QAccessible&lt;/a&gt; are used to describe accessible objects:</source>
          <target state="translated">&lt;a href=&quot;qaccessible&quot;&gt;QAccessible&lt;/a&gt; 의 멤버와 열거 형은 액세스 가능한 객체를 설명하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="fb5f753201f41f36cf02f9ca4a0a300e7af967f9" translate="yes" xml:space="preserve">
          <source>The memory usage of a QML application may be split into two parts: its C++ heap usage and its JavaScript heap usage. Some of the memory allocated in each will be unavoidable, as it is allocated by the QML engine or the JavaScript engine, while the rest is dependent upon decisions made by the application developer.</source>
          <target state="translated">QML 애플리케이션의 메모리 사용량은 C ++ 힙 사용량과 JavaScript 힙 사용량의 두 부분으로 나눌 수 있습니다. 각각에 할당 된 일부 메모리는 QML 엔진 또는 JavaScript 엔진에 의해 할당되므로 불가피하며 나머지는 애플리케이션 개발자의 결정에 따라 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="5d1a59e17f924d981b356499c5a4f26d64403c88" translate="yes" xml:space="preserve">
          <source>The menu bar item's text.</source>
          <target state="translated">메뉴 바 아이템의 텍스트입니다.</target>
        </trans-unit>
        <trans-unit id="27428bf0c5d8bc44e57c9ea266c458cffc3c3db4" translate="yes" xml:space="preserve">
          <source>The menu bar item.</source>
          <target state="translated">메뉴 바 아이템.</target>
        </trans-unit>
        <trans-unit id="f640de9a1fe0a35e766f929d5de8bea00eb60052" translate="yes" xml:space="preserve">
          <source>The menu bar provides all the standard actions for managing forms, using the clipboard, and accessing application-specific help. The current editing mode, the tool windows, and the forms in use can also be accessed via the menu bar.</source>
          <target state="translated">메뉴 모음은 양식 관리, 클립 보드 사용 및 응용 프로그램 별 도움말 액세스에 대한 모든 표준 작업을 제공합니다. 메뉴 표시 줄을 통해 현재 편집 모드, 도구 창 및 사용중인 양식에 액세스 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="758d160d313b158f8ba228dc6a0acc47b48fb4a1" translate="yes" xml:space="preserve">
          <source>The menu bar takes ownership of</source>
          <target state="translated">메뉴 막대는</target>
        </trans-unit>
        <trans-unit id="bc014a315f344646165e32d135ed14d907433def" translate="yes" xml:space="preserve">
          <source>The menu bar took focus.</source>
          <target state="translated">메뉴 막대에 초점이 맞춰졌습니다.</target>
        </trans-unit>
        <trans-unit id="416d4b6b805c2fdb263008a86621f15fa358d100" translate="yes" xml:space="preserve">
          <source>The menu button of a &lt;a href=&quot;qtoolbutton&quot;&gt;QToolButton&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qtoolbutton&quot;&gt;QToolButton&lt;/a&gt; 의 메뉴 버튼입니다 .</target>
        </trans-unit>
        <trans-unit id="d898207e3535df25f00343bd14d4e4d4ab1765e1" translate="yes" xml:space="preserve">
          <source>The menu can be optionally aligned to a specific menu</source>
          <target state="translated">메뉴는 선택적으로 특정 메뉴에 정렬 될 수 있습니다</target>
        </trans-unit>
        <trans-unit id="ba8b4ad271e2c9aa47914499a1db9b416a21d3b7" translate="yes" xml:space="preserve">
          <source>The menu entry's text is displayed using a line edit, and can be modified.</source>
          <target state="translated">메뉴 항목의 텍스트는 줄 편집을 사용하여 표시되며 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f459d64e463c2bab50f20d621001b7e6b915cbda" translate="yes" xml:space="preserve">
          <source>The menu indicator of a &lt;a href=&quot;qpushbutton&quot;&gt;QPushButton&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qpushbutton&quot;&gt;QPushButton&lt;/a&gt; 의 메뉴 표시기입니다 .</target>
        </trans-unit>
        <trans-unit id="72163ee2e3903d8a5dd1cdc5832eaf879ab3e268" translate="yes" xml:space="preserve">
          <source>The menu is displayed, without delay, when the tool button is pressed. In this mode, the button's own action is not triggered.</source>
          <target state="translated">도구 버튼을 누르면 메뉴가 지연없이 표시됩니다. 이 모드에서는 버튼 자체 동작이 트리거되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e7b8f3d9c6abd095db3aadc7beefd95b33303ae0" translate="yes" xml:space="preserve">
          <source>The menu item background component.</source>
          <target state="translated">메뉴 항목 배경 구성 요소</target>
        </trans-unit>
        <trans-unit id="f93a7370df5b5adf0e22f4e393ecc5f1b415b343" translate="yes" xml:space="preserve">
          <source>The menu item is currently selected item.</source>
          <target state="translated">메뉴 항목이 현재 선택된 항목입니다.</target>
        </trans-unit>
        <trans-unit id="356bfb693c199f1c5387eb6653f151ea270e0d04" translate="yes" xml:space="preserve">
          <source>The menu item that is currently under the mouse, or &lt;code&gt;null&lt;/code&gt; if there is no such item.</source>
          <target state="translated">현재 마우스 아래에있는 메뉴 항목이거나 해당 항목이 없으면 &lt;code&gt;null&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3b7215170d74f00a50b5a07ce165772759678758" translate="yes" xml:space="preserve">
          <source>The menu item's text, or title if it's a submenu.</source>
          <target state="translated">메뉴 항목의 텍스트 또는 하위 메뉴 인 경우 제목입니다.</target>
        </trans-unit>
        <trans-unit id="659b37dec9b18b58387468852de6e24958181452" translate="yes" xml:space="preserve">
          <source>The menu role can only be changed before the actions are put into the menu bar in &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; (usually just before the first application window is shown).</source>
          <target state="translated">메뉴 역할은 &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; 의 메뉴 표시 줄에 작업을 넣기 전에 만 (일반적으로 첫 번째 응용 프로그램 창이 표시되기 직전에) 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c5eebed6b219a3e81e41e56ab5b9aab329bb903d" translate="yes" xml:space="preserve">
          <source>The menu role can only be changed before the actions are put into the menu bar in macOS (usually just before the first application window is shown).</source>
          <target state="translated">메뉴 역할은 macOS의 메뉴 막대에 작업을 입력하기 전에 만 변경할 수 있습니다 (일반적으로 첫 번째 응용 프로그램 창이 표시되기 직전).</target>
        </trans-unit>
        <trans-unit id="0b015cfd565915125313a377cac8df5638c1f339" translate="yes" xml:space="preserve">
          <source>The menu will be shown according to the button's &lt;a href=&quot;qtoolbutton#popupMode-prop&quot;&gt;popupMode&lt;/a&gt;.</source>
          <target state="translated">메뉴는 버튼의 &lt;a href=&quot;qtoolbutton#popupMode-prop&quot;&gt;popupMode&lt;/a&gt; 에 따라 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="4ac399b7194ed2d833b636c5921cc8270c91850e" translate="yes" xml:space="preserve">
          <source>The menu will pop up when the user requests the context menu for the system tray icon by clicking the mouse button.</source>
          <target state="translated">사용자가 마우스 버튼을 클릭하여 시스템 트레이 아이콘의 상황에 맞는 메뉴를 요청하면 메뉴가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="d7f156829e5fc3f83a07d49c6ee78f901a5ee888" translate="yes" xml:space="preserve">
          <source>The menu's actions are specified by the list of</source>
          <target state="translated">메뉴의 동작은</target>
        </trans-unit>
        <trans-unit id="6f8f8a9face53b743749fa9672e43503e7f224c2" translate="yes" xml:space="preserve">
          <source>The mesh can be used in a &lt;a href=&quot;qml-qtquick-shadereffect&quot;&gt;ShaderEffect&lt;/a&gt; to define the shaded geometry. The geometry will be normalized before use, so the position and scale of the input objects have no impact on the result.</source>
          <target state="translated">메시를 &lt;a href=&quot;qml-qtquick-shadereffect&quot;&gt;ShaderEffect&lt;/a&gt; 에서 사용하여 음영 처리 된 형상을 정의 할 수 있습니다 . 지오메트리는 사용하기 전에 정규화되므로 입력 객체의 위치와 스케일은 결과에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="adbccc8932bc832cee4ec1b7c0e3f074468670dd" translate="yes" xml:space="preserve">
          <source>The mesh geometry is loading</source>
          <target state="translated">메시 지오메트리가로드 중입니다.</target>
        </trans-unit>
        <trans-unit id="367efb0cd0d0ccb604681aa5961679c142e10aaa" translate="yes" xml:space="preserve">
          <source>The mesh geometry was successfully loaded</source>
          <target state="translated">메쉬 형상이 성공적으로로드되었습니다.</target>
        </trans-unit>
        <trans-unit id="b82c22068b3821d3ce29a17f9fd0f767438aadad" translate="yes" xml:space="preserve">
          <source>The message box is an &lt;a href=&quot;qt#WindowModality-enum&quot;&gt;application modal&lt;/a&gt; dialog box.</source>
          <target state="translated">메시지 상자는 &lt;a href=&quot;qt#WindowModality-enum&quot;&gt;응용 프로그램 모달&lt;/a&gt; 대화 상자입니다.</target>
        </trans-unit>
        <trans-unit id="f67cf122cfab1bd75f0156ea137df008559cb6dc" translate="yes" xml:space="preserve">
          <source>The message box will be displayed each time the button is clicked, but the state machine will remain in its current state (s1). If the target state were explicitly set to s1, however, s1 would be exited and re-entered each time (e.g. the &lt;a href=&quot;qabstractstate#entered&quot;&gt;QAbstractState::entered&lt;/a&gt;() and &lt;a href=&quot;qabstractstate#exited&quot;&gt;QAbstractState::exited&lt;/a&gt;() signals would be emitted).</source>
          <target state="translated">버튼을 클릭 할 때마다 메시지 상자가 표시되지만 상태 머신은 현재 상태 (s1)로 유지됩니다. 그러나 대상 상태가 명시 적으로 s1로 설정되면 s1이 종료되고 매번 다시 입력됩니다 (예 : &lt;a href=&quot;qabstractstate#entered&quot;&gt;QAbstractState :: entered&lt;/a&gt; () 및 &lt;a href=&quot;qabstractstate#exited&quot;&gt;QAbstractState :: exited&lt;/a&gt; () 신호가 생성됨 ).</target>
        </trans-unit>
        <trans-unit id="e6fdbed8ae1560553d710edddb9e23499bbd3b1d" translate="yes" xml:space="preserve">
          <source>The message can also be obtained from a function call that produces a plain C string, such as &lt;a href=&quot;qtglobal#qPrintable&quot;&gt;qPrintable&lt;/a&gt;() applied to a &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;, which may be built in any of its usual ways, including applying &lt;code&gt;.args()&lt;/code&gt; to format some data.</source>
          <target state="translated">메시지는 &lt;a href=&quot;qstring&quot;&gt;QString에&lt;/a&gt; 적용된 &lt;a href=&quot;qtglobal#qPrintable&quot;&gt;qPrintable&lt;/a&gt; () 과 같은 일반 C 문자열을 생성하는 함수 호출에서도 얻을 수 있습니다 . QString 은 일부 데이터를 형식화하기 위해 &lt;code&gt;.args()&lt;/code&gt; 를 적용하는 등 일반적인 방법으로 빌드 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="561082357533f11cb9b91cccd433ec66c5f6a42b" translate="yes" xml:space="preserve">
          <source>The message handler is a function that prints out debug messages, warnings, critical and fatal error messages. The Qt library (debug mode) contains hundreds of warning messages that are printed when internal errors (usually invalid function arguments) occur. Qt built in release mode also contains such warnings unless QT_NO_WARNING_OUTPUT and/or QT_NO_DEBUG_OUTPUT have been set during compilation. If you implement your own message handler, you get total control of these messages.</source>
          <target state="translated">메시지 핸들러는 디버그 메시지, 경고, 치명적 및 치명적 오류 메시지를 인쇄하는 기능입니다. Qt 라이브러리 (디버그 모드)에는 내부 오류 (보통 잘못된 함수 인수)가 발생할 때 인쇄되는 수백 개의 경고 메시지가 포함되어 있습니다. 컴파일 중에 QT_NO_WARNING_OUTPUT 및 / 또는 QT_NO_DEBUG_OUTPUT을 설정하지 않은 경우 릴리스 모드에서 빌드 된 Qt에도 이러한 경고가 포함됩니다. 자체 메시지 처리기를 구현하면 이러한 메시지를 완전히 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6440ac822272d12a15045f9b39958881d208ced9" translate="yes" xml:space="preserve">
          <source>The message has a high severity.</source>
          <target state="translated">메시지의 심각도가 높습니다.</target>
        </trans-unit>
        <trans-unit id="4be773a6333a883fd21a9ee1ca9760e90550cb39" translate="yes" xml:space="preserve">
          <source>The message has a low severity.</source>
          <target state="translated">메시지의 심각도가 낮습니다.</target>
        </trans-unit>
        <trans-unit id="17e402b8f4edcfdbe631193fb6b8b9e2b74ed84d" translate="yes" xml:space="preserve">
          <source>The message has a medium severity.</source>
          <target state="translated">메시지의 심각도는 중간입니다.</target>
        </trans-unit>
        <trans-unit id="d8754fd0e3889a53ee5e640f8d28d4d4df0fb462" translate="yes" xml:space="preserve">
          <source>The message indicates there has been an error.</source>
          <target state="translated">오류가 발생했다는 메시지가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="0abac7418484975fc697978a48b7bb0a2edfad94" translate="yes" xml:space="preserve">
          <source>The message informs about unexpected behavior or errors that may need attention.</source>
          <target state="translated">이 메시지는 예기치 않은 동작이나주의가 필요한 오류를 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="08f559385e08161990fb12c516e4a211a8ee5dcb" translate="yes" xml:space="preserve">
          <source>The message is a notification.</source>
          <target state="translated">메시지는 알림입니다.</target>
        </trans-unit>
        <trans-unit id="f28cfe40dec8b3f5f5f232cfe468da7f712a5390" translate="yes" xml:space="preserve">
          <source>The message is purely informative and can safely be ignored.</source>
          <target state="translated">이 메시지는 정보를 제공하기 때문에 무시해도됩니다.</target>
        </trans-unit>
        <trans-unit id="8bb998cd1f08acedd37bb75f3bd5754521f51926" translate="yes" xml:space="preserve">
          <source>The message represents a debug group pop operation.</source>
          <target state="translated">메시지는 디버그 그룹 팝 조작을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="ad6caba5397825ce167d9b47084703aa082c0597" translate="yes" xml:space="preserve">
          <source>The message represents a debug group push operation.</source>
          <target state="translated">메시지는 디버그 그룹 푸시 조작을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="2893fbe7c5887a309bc1df7aaac49ba4145da321" translate="yes" xml:space="preserve">
          <source>The message represents a marker in the debug log.</source>
          <target state="translated">메시지는 디버그 로그의 마커를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="5131b14bde466904bca7cdd62ef7719a60f3f993" translate="yes" xml:space="preserve">
          <source>The message represents a performance issue.</source>
          <target state="translated">이 메시지는 성능 문제를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e3b010e3ef2ef6132862ebb43dc1ea4d1080d4cd" translate="yes" xml:space="preserve">
          <source>The message represents a type not included in this enumeration.</source>
          <target state="translated">메시지는이 열거에 포함되지 않은 유형을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="7962adc6670e6842150f86e9c1ff236a15fc1780" translate="yes" xml:space="preserve">
          <source>The message represents an error.</source>
          <target state="translated">메시지는 오류를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="11083905c6cfafcba687fc2d353c6a136c40c33a" translate="yes" xml:space="preserve">
          <source>The message represents an usage of deprecated behavior.</source>
          <target state="translated">이 메시지는 더 이상 사용되지 않는 동작의 사용법을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="5c4c737db37e454ca8462ef2d816d454f05af8e1" translate="yes" xml:space="preserve">
          <source>The message represents an usage of undefined behavior.</source>
          <target state="translated">이 메시지는 정의되지 않은 동작의 사용법을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="8c20cb8f2e3d134ff468e3a1018aae1fa4a8944d" translate="yes" xml:space="preserve">
          <source>The message represents an usage of vendor-specific behavior, that might pose portability concerns.</source>
          <target state="translated">이 메시지는 이식성 문제를 일으킬 수있는 공급 업체별 동작의 사용법을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="ee2493da1a3bebafddbfa0bd30dac7682b3c1ccb" translate="yes" xml:space="preserve">
          <source>The message to be shown to the user.</source>
          <target state="translated">사용자에게 표시 할 메시지입니다.</target>
        </trans-unit>
        <trans-unit id="7adefa65f4ff252eb6e0e367e898c12953354e14" translate="yes" xml:space="preserve">
          <source>The message was generated by a source not included in this enumeration.</source>
          <target state="translated">이 열거에 포함되지 않은 소스에서 메시지를 생성했습니다.</target>
        </trans-unit>
        <trans-unit id="6ef4bbd2f3a95b50ba64e328b693f9ed27312f9c" translate="yes" xml:space="preserve">
          <source>The message was generated by a third party, for instance an OpenGL framework a or debugging toolkit.</source>
          <target state="translated">메시지는 타사, 예를 들어 OpenGL 프레임 워크 또는 디버깅 툴킷에 의해 생성되었습니다.</target>
        </trans-unit>
        <trans-unit id="5822f2ac6014e57bc9b411a254361958e4530ccf" translate="yes" xml:space="preserve">
          <source>The message was generated by the application itself.</source>
          <target state="translated">메시지는 응용 프로그램 자체에서 생성되었습니다.</target>
        </trans-unit>
        <trans-unit id="d51f534460140950113f6df856f44a078c389a13" translate="yes" xml:space="preserve">
          <source>The message was generated by the shader compiler.</source>
          <target state="translated">메시지는 셰이더 컴파일러에 의해 생성되었습니다.</target>
        </trans-unit>
        <trans-unit id="2d2802fce6c93e83745f13ecfd9877dab2385cb4" translate="yes" xml:space="preserve">
          <source>The message was generated by the window system.</source>
          <target state="translated">메시지는 윈도우 시스템에 의해 생성되었습니다.</target>
        </trans-unit>
        <trans-unit id="ef72e475a999dc81b41e2adffa137e8967593ff4" translate="yes" xml:space="preserve">
          <source>The message was generated in response to OpenGL API calls.</source>
          <target state="translated">OpenGL API 호출에 대한 응답으로 메시지가 생성되었습니다.</target>
        </trans-unit>
        <trans-unit id="3ec141c43b6fc64a3a91e12c6db2fc74f09d5d92" translate="yes" xml:space="preserve">
          <source>The meta Makefile makes the sub-builds invokable via the &lt;code&gt;debug&lt;/code&gt; and &lt;code&gt;release&lt;/code&gt; targets, and a combined build via the &lt;code&gt;all&lt;/code&gt; target. When the &lt;code&gt;build_all&lt;/code&gt;&lt;code&gt;CONFIG&lt;/code&gt; option is used, the combined build is the default. Otherwise, the last specified &lt;code&gt;CONFIG&lt;/code&gt; option from the set (&lt;code&gt;debug&lt;/code&gt;, &lt;code&gt;release&lt;/code&gt;) determines the default. In this case, you can explicitly invoke the &lt;code&gt;all&lt;/code&gt; target to build both configurations at once:</source>
          <target state="translated">메타 Makefile은 &lt;code&gt;debug&lt;/code&gt; 및 &lt;code&gt;release&lt;/code&gt; 대상을 통해 하위 빌드를 호출 할 수있게하고 &lt;code&gt;all&lt;/code&gt; 대상을 통해 결합 된 빌드를 작성합니다 . 때 &lt;code&gt;build_all&lt;/code&gt; 의 &lt;code&gt;CONFIG&lt;/code&gt; 옵션을 사용, 결합 된 빌드가 기본값입니다. 그렇지 않으면 세트에서 마지막으로 지정된 &lt;code&gt;CONFIG&lt;/code&gt; 옵션 ( &lt;code&gt;debug&lt;/code&gt; , &lt;code&gt;release&lt;/code&gt; )이 기본값을 결정합니다. 이 경우 &lt;code&gt;all&lt;/code&gt; 대상을 명시 적으로 호출하여 두 구성을 한 번에 빌드 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="422dbf73a6205c93a5843c994f3ecc3a247ecfbf" translate="yes" xml:space="preserve">
          <source>The meta data can be queried in a fast and inexpensive way without actually loading the plugin. This makes it possible to e.g. store capabilities of the plugin in there, and make the decision whether to load the plugin dependent on this meta data.</source>
          <target state="translated">메타 데이터는 실제로 플러그인을로드하지 않고도 빠르고 저렴한 방법으로 쿼리 할 수 ​​있습니다. 이를 통해 예를 들어 플러그인의 기능을 저장할 수 있으며이 메타 데이터에 따라 플러그인을로드할지 여부를 결정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fbe7d9f7a917f40af64a6484dee90b70e8094bd0" translate="yes" xml:space="preserve">
          <source>The meta-object information is required by the signal/slot connection mechanism and the property system. The &lt;a href=&quot;qobject#inherits&quot;&gt;inherits&lt;/a&gt;() function also makes use of the meta-object.</source>
          <target state="translated">메타 객체 정보는 신호 / 슬롯 연결 메커니즘 및 속성 시스템에 필요합니다. &lt;a href=&quot;qobject#inherits&quot;&gt;상속&lt;/a&gt; () 함수는 메타 오브젝트를 사용한다.</target>
        </trans-unit>
        <trans-unit id="9532c115bca0b5e6dd6fdd22fe4902457af079ac" translate="yes" xml:space="preserve">
          <source>The meta-object system is a C++ extension that makes the language better suited to true component GUI programming.</source>
          <target state="translated">메타 객체 시스템은 언어를 진정한 컴포넌트 GUI 프로그래밍에 더 적합하게 만드는 C ++ 확장입니다.</target>
        </trans-unit>
        <trans-unit id="34025e16a4aa319fdb29d2f83f489a6e9d5e0b74" translate="yes" xml:space="preserve">
          <source>The meta-object system is based on three things:</source>
          <target state="translated">메타 객체 시스템은 다음 세 가지를 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="0dc503fb5ff7a5c68473f02852ac74f46528862f" translate="yes" xml:space="preserve">
          <source>The metalness property defines the</source>
          <target state="translated">금속성 속성은</target>
        </trans-unit>
        <trans-unit id="725ed97999a997f0ae9d01dfff9a95d493142600" translate="yes" xml:space="preserve">
          <source>The metering mode.</source>
          <target state="translated">측광 모드.</target>
        </trans-unit>
        <trans-unit id="33b305ede17b56971d11efb08ac28003cac2d4e5" translate="yes" xml:space="preserve">
          <source>The method &lt;a href=&quot;qtimezone#systemTimeZoneId&quot;&gt;systemTimeZoneId&lt;/a&gt;() returns the current system IANA time zone ID which on Unix-like systems will always be correct. On Windows this ID is translated from the Windows system ID using an internal translation table and the user's selected country. As a consequence there is a small chance any Windows install may have IDs not known by Qt, in which case &quot;UTC&quot; will be returned.</source>
          <target state="translated">&lt;a href=&quot;qtimezone#systemTimeZoneId&quot;&gt;systemTimeZoneId&lt;/a&gt; () 메소드 는 Unix 계열 시스템에서 항상 올바른 현재 시스템 IANA 시간대 ID를 리턴합니다. Windows에서이 ID는 내부 변환 테이블 및 사용자가 선택한 국가를 사용하여 Windows 시스템 ID에서 변환됩니다. 결과적으로 Windows 설치에 Qt에 의해 알려지지 않은 ID가있을 가능성이 적습니다.이 경우 &quot;UTC&quot;가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="12b43427dec208ae05e8586a5862c070c98e2e25" translate="yes" xml:space="preserve">
          <source>The method called was not found in this object/interface with the given parameters (&lt;code&gt;org.freedesktop.DBus.Error.UnknownMethod&lt;/code&gt;)</source>
          <target state="translated">지정된 매개 변수 ( &lt;code&gt;org.freedesktop.DBus.Error.UnknownMethod&lt;/code&gt; ) 와 함께이 오브젝트 / 인터페이스에서 호출 된 메소드를 찾을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="750cddc8577cb4c11fa851bf1b0ba68a4774f456" translate="yes" xml:space="preserve">
          <source>The method described works for all the supplied drivers. The only difference will be in the driver constructor arguments. Here is a table of the drivers included with Qt, their source code files, and their constructor arguments:</source>
          <target state="translated">설명 된 방법은 제공된 모든 드라이버에서 작동합니다. 유일한 차이점은 드라이버 생성자 인수에 있습니다. Qt에 포함 된 드라이버, 소스 코드 파일 및 생성자 인수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7eb713fcdbb4af68e3a34dfe95f6caf3e829392e" translate="yes" xml:space="preserve">
          <source>The method of simulation prefers to have the initial values changed, rather than determining and changing the value at a given time. Change initial values in CustomEmitters instead of the current values.</source>
          <target state="translated">시뮬레이션 방법은 주어진 시간에 값을 결정하고 변경하는 대신 초기 값을 변경하는 것을 선호합니다. 현재 값 대신 CustomEmitters에서 초기 값을 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="9845403e01b403378df9db102a2800e371dace77" translate="yes" xml:space="preserve">
          <source>The method returns &lt;code&gt;true&lt;/code&gt; if the trace interaction is accepted.</source>
          <target state="translated">추적 상호 작용이 승인되면 메소드는 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 .</target>
        </trans-unit>
        <trans-unit id="56bec4579303065d0856e13af6fa1786b5bd261f" translate="yes" xml:space="preserve">
          <source>The method returns &lt;code&gt;true&lt;/code&gt; if the word was successfully reselected.</source>
          <target state="translated">단어가 성공적으로 다시 선택되면 메소드는 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 .</target>
        </trans-unit>
        <trans-unit id="6ebcab3ad642212eddb9c354d03bc588b102324c" translate="yes" xml:space="preserve">
          <source>The method returns index of the point added, or -1 if the points cannot be added (i.e. the &lt;a href=&quot;qml-qtquick-virtualkeyboard-trace#final-prop&quot;&gt;final&lt;/a&gt; is true).</source>
          <target state="translated">이 메소드는 추가 된 포인트의 인덱스를 반환하거나, 포인트를 추가 할 수없는 경우 (즉, &lt;a href=&quot;qml-qtquick-virtualkeyboard-trace#final-prop&quot;&gt;최종 값&lt;/a&gt; 이 true 인 경우) -1을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="851736344c057f5f57a7b01ef9857f87329a594b" translate="yes" xml:space="preserve">
          <source>The method returns index of the point added, or -1 if the points cannot be added (i.e. the &lt;a href=&quot;qvirtualkeyboardtrace#final-prop&quot;&gt;final&lt;/a&gt; is true).</source>
          <target state="translated">이 메소드는 추가 된 포인트의 인덱스를 반환하거나, 포인트를 추가 할 수없는 경우 (즉, &lt;a href=&quot;qvirtualkeyboardtrace#final-prop&quot;&gt;최종 값&lt;/a&gt; 이 true 인 경우) -1을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="2f36f40ac7a3a02d2bb4330eeb2cc50f63939cdc" translate="yes" xml:space="preserve">
          <source>The method should return true if the registration of</source>
          <target state="translated">이 메소드는 등록시 true를 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="b3601c5edc1a1bf777d32b5b6ab9901b13494db9" translate="yes" xml:space="preserve">
          <source>The method used to navigate to a web page.</source>
          <target state="translated">웹 페이지를 탐색하는 데 사용되는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="2c6268ad523ea2efe519802d3f25927f4ae37d0d" translate="yes" xml:space="preserve">
          <source>The methods named isT() (e.g. &lt;a href=&quot;qjsvalue#isBool&quot;&gt;isBool&lt;/a&gt;(), &lt;a href=&quot;qjsvalue#isUndefined&quot;&gt;isUndefined&lt;/a&gt;()) can be used to test if a value is of a certain type. The methods named toT() (e.g. &lt;a href=&quot;qjsvalue#toBool&quot;&gt;toBool&lt;/a&gt;(), &lt;a href=&quot;qjsvalue#toString&quot;&gt;toString&lt;/a&gt;()) can be used to convert a &lt;a href=&quot;qjsvalue&quot;&gt;QJSValue&lt;/a&gt; to another type. You can also use the generic qjsvalue_cast() function.</source>
          <target state="translated">isT () 메소드 (예 : &lt;a href=&quot;qjsvalue#isBool&quot;&gt;isBool&lt;/a&gt; (), &lt;a href=&quot;qjsvalue#isUndefined&quot;&gt;isUndefined&lt;/a&gt; ())를 사용하여 값이 특정 유형인지 테스트 할 수 있습니다. toT ()라는 메소드 (예 : &lt;a href=&quot;qjsvalue#toBool&quot;&gt;toBool&lt;/a&gt; (), &lt;a href=&quot;qjsvalue#toString&quot;&gt;toString&lt;/a&gt; ())를 사용하여 &lt;a href=&quot;qjsvalue&quot;&gt;QJSValue&lt;/a&gt; 를 다른 유형 으로 변환 할 수 있습니다 . 일반 qjsvalue_cast () 함수를 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d17a7b2f83cdd9f79d37db7225f0e18d989203c" translate="yes" xml:space="preserve">
          <source>The methods named isT() (e.g. &lt;a href=&quot;qjsvalue#isBool&quot;&gt;isBool&lt;/a&gt;(), &lt;a href=&quot;qjsvalue#isUndefined&quot;&gt;isUndefined&lt;/a&gt;()) can be used to test if a value is of a certain type. The methods named toT() (e.g. &lt;a href=&quot;qjsvalue#toBool&quot;&gt;toBool&lt;/a&gt;(), &lt;a href=&quot;qjsvalue#toString&quot;&gt;toString&lt;/a&gt;()) can be used to convert a QJSValue to another type. You can also use the generic qjsvalue_cast() function.</source>
          <target state="translated">isT () (예 : &lt;a href=&quot;qjsvalue#isBool&quot;&gt;isBool&lt;/a&gt; (), &lt;a href=&quot;qjsvalue#isUndefined&quot;&gt;isUndefined&lt;/a&gt; ()) 라는 메서드 는 값이 특정 유형인지 테스트하는 데 사용할 수 있습니다. toT () (예 : &lt;a href=&quot;qjsvalue#toBool&quot;&gt;toBool&lt;/a&gt; (), &lt;a href=&quot;qjsvalue#toString&quot;&gt;toString&lt;/a&gt; ()) 라는 메서드를 사용하여 QJSValue를 다른 유형으로 변환 할 수 있습니다. 일반 qjsvalue_cast () 함수를 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="83d7321b8f03e439a2561937b0a766a2aa60aff1" translate="yes" xml:space="preserve">
          <source>The methods named toT() (e.g., &lt;a href=&quot;qvariant#toInt&quot;&gt;toInt&lt;/a&gt;(), &lt;a href=&quot;qvariant#toString&quot;&gt;toString&lt;/a&gt;()) are const. If you ask for the stored type, they return a copy of the stored object. If you ask for a type that can be generated from the stored type, toT() copies and converts and leaves the object itself unchanged. If you ask for a type that cannot be generated from the stored type, the result depends on the type; see the function documentation for details.</source>
          <target state="translated">toT ()라는 메소드 (예 : &lt;a href=&quot;qvariant#toInt&quot;&gt;toInt&lt;/a&gt; (), &lt;a href=&quot;qvariant#toString&quot;&gt;toString&lt;/a&gt; ())는 const입니다. 저장된 유형을 요청하면 저장된 객체의 사본을 반환합니다. 저장된 유형에서 생성 할 수있는 유형을 요청하면 toT ()는 객체 자체를 복사하고 변환하여 객체 자체를 변경하지 않습니다. 저장된 유형에서 생성 할 수없는 유형을 요청하면 결과는 유형에 따라 다릅니다. 자세한 내용은 기능 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c0548567a9f61b31407ca36253abd030d29075c3" translate="yes" xml:space="preserve">
          <source>The mid color of the current color group.</source>
          <target state="translated">현재 색상 그룹의 중간 색상입니다.</target>
        </trans-unit>
        <trans-unit id="c728db2b87c5f0f1245a442a976b83142c0e2f20" translate="yes" xml:space="preserve">
          <source>The mid line width is usually used in drawing sunken or raised frames. The default value is 0.</source>
          <target state="translated">중간 선 너비는 일반적으로 튀어 나온 프레임을 그릴 때 사용됩니다. 기본값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="3783257e3ed8b66a34d7364e75d4c08f9737b5bf" translate="yes" xml:space="preserve">
          <source>The mid-line width is usually used when drawing sunken or raised group box frames. The value of this variable is, currently, always 0.</source>
          <target state="translated">중간 선 너비는 일반적으로 움푹 들어간 그룹이나 돌출 된 그룹 상자 프레임을 그릴 때 사용됩니다. 이 변수의 값은 현재 항상 0입니다.</target>
        </trans-unit>
        <trans-unit id="9f3536fe6f7c68839e836b5571726bbd5d39aa96" translate="yes" xml:space="preserve">
          <source>The mid-line width specifies the width of an extra line in the middle of the frame, which uses a third color to obtain a special 3D effect. Notice that a mid-line is only drawn for &lt;a href=&quot;qframe#Shape-enum&quot;&gt;Box&lt;/a&gt;, &lt;a href=&quot;qframe#Shape-enum&quot;&gt;HLine&lt;/a&gt; and &lt;a href=&quot;qframe#Shape-enum&quot;&gt;VLine&lt;/a&gt; frames that are raised or sunken.</source>
          <target state="translated">중간 선 너비는 프레임 중간에 추가 선의 너비를 지정하며 세 번째 색을 사용하여 특수한 3D 효과를 얻습니다. 미드 라인은 &lt;a href=&quot;qframe#Shape-enum&quot;&gt;Box&lt;/a&gt; , &lt;a href=&quot;qframe#Shape-enum&quot;&gt;HLine&lt;/a&gt; 및 &lt;a href=&quot;qframe#Shape-enum&quot;&gt;VLine&lt;/a&gt; 프레임 에만 나타나 거나 튀어 나옵니다 .</target>
        </trans-unit>
        <trans-unit id="9a0bf723aa4a201722b4fc4f42166638ea779c29" translate="yes" xml:space="preserve">
          <source>The middle (region 5) is scaled according to both &lt;a href=&quot;qml-qtquick-borderimage#horizontalTileMode-prop&quot;&gt;horizontalTileMode&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-borderimage#verticalTileMode-prop&quot;&gt;verticalTileMode&lt;/a&gt;.</source>
          <target state="translated">가운데 (영역 5)는 &lt;a href=&quot;qml-qtquick-borderimage#horizontalTileMode-prop&quot;&gt;horizontalTileMode&lt;/a&gt; 및 &lt;a href=&quot;qml-qtquick-borderimage#verticalTileMode-prop&quot;&gt;verticalTileMode&lt;/a&gt; 에 따라 크기가 조정됩니다 .</target>
        </trans-unit>
        <trans-unit id="f4e8b0de0c563b3913bfceaf21feb223eba32e01" translate="yes" xml:space="preserve">
          <source>The middle button.</source>
          <target state="translated">중간 버튼.</target>
        </trans-unit>
        <trans-unit id="ecbee8a6b57e2dea4a180f352abaa0baaedf2c3c" translate="yes" xml:space="preserve">
          <source>The midlight color of the current color group.</source>
          <target state="translated">현재 색상 그룹의 중간 색상입니다.</target>
        </trans-unit>
        <trans-unit id="38c598c74ea8b04dd429f14cec1a9a06e69f5318" translate="yes" xml:space="preserve">
          <source>The minimal 3D mesh: a triangular pyramid. Usable only with &lt;a href=&quot;q3dscatter&quot;&gt;Q3DScatter&lt;/a&gt;.</source>
          <target state="translated">최소 3D 메쉬 : 삼각형 피라미드. &lt;a href=&quot;q3dscatter&quot;&gt;Q3DScatter&lt;/a&gt; 에서만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b0aeff6a596d59e85b0c01bc7ac036c0b322f68" translate="yes" xml:space="preserve">
          <source>The minimize button for a MDI subwindow in the menu bar.</source>
          <target state="translated">메뉴 표시 줄에서 MDI 하위 창의 최소화 버튼.</target>
        </trans-unit>
        <trans-unit id="dda76be85c113b8055ccadf7348c781bb283e43e" translate="yes" xml:space="preserve">
          <source>The minimize, close, and normal button in the menu bar for a maximized MDI subwindow.</source>
          <target state="translated">최대화 된 MDI 하위 창을위한 메뉴 표시 줄의 최소화, 닫기 및 일반 버튼.</target>
        </trans-unit>
        <trans-unit id="e8265a4cb099422da99a7c25269634d131f26757" translate="yes" xml:space="preserve">
          <source>The minimize, normal, and close button in the menu bar for a maximized MDI subwindow.</source>
          <target state="translated">최대화 된 MDI 하위 창을위한 메뉴 표시 줄의 최소화, 일반 및 닫기 버튼.</target>
        </trans-unit>
        <trans-unit id="9e34197b8a025dd96926bbd44e7603004c74960d" translate="yes" xml:space="preserve">
          <source>The minimum OS version can be expressed to the system by the compiler and linker flags that embed it into the Mach-O binary. In addition, the &lt;code&gt;LSMinimumSystemVersion&lt;/code&gt; key must be set in the application's app bundle. This value must be equal to the value passed to the compiler and linker, because on macOS it will allow the OS to display a user friendly error dialog that says the application requires a newer version of the OS as opposed to a crash dialog. The &lt;code&gt;LSMinimumSystemVersion&lt;/code&gt; is also the key that the App Store uses to display the required OS version; the compiler and linker flags have no power there.</source>
          <target state="translated">최소 OS 버전은이를 Mach-O 바이너리에 포함시키는 컴파일러 및 링커 플래그에 의해 시스템에 표현 될 수 있습니다. 또한 &lt;code&gt;LSMinimumSystemVersion&lt;/code&gt; 키는 응용 프로그램의 앱 번들에서 설정해야합니다. 이 값은 컴파일러와 링커에 전달 된 값과 같아야합니다. macOS에서는 OS가 충돌 대화 상자가 아닌 응용 프로그램에 최신 버전의 OS가 필요하다는 사용자 친화적 인 오류 대화 상자를 표시 할 수 있기 때문입니다. &lt;code&gt;LSMinimumSystemVersion&lt;/code&gt; 은 또한 응용 프로그램 저장소 필요한 OS 버전을 표시하는 데 사용되는 키이고; 컴파일러와 링커 플래그에는 전원이 없습니다.</target>
        </trans-unit>
        <trans-unit id="27c3c8494ac1068b85a0af60d017b661caa89c9b" translate="yes" xml:space="preserve">
          <source>The minimum X value for the generated surface points. Defaults to &lt;code&gt;0.0&lt;/code&gt;. When setting this property the corresponding maximum value is adjusted if necessary, to ensure that the range remains valid.</source>
          <target state="translated">생성 된 표면 점에 대한 최소 X 값입니다. 기본값은 &lt;code&gt;0.0&lt;/code&gt; 입니다. 이 속성을 설정할 때 필요한 경우 해당 최대 값이 조정되어 범위가 유효하게 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="22896de3ddf69bff6fadd895d77fc0291e26dabf" translate="yes" xml:space="preserve">
          <source>The minimum Z value for the generated surface points. Defaults to &lt;code&gt;0.0&lt;/code&gt;. When setting this property the corresponding maximum value is adjusted if necessary, to ensure that the range remains valid.</source>
          <target state="translated">생성 된 표면 점에 대한 최소 Z 값입니다. 기본값은 &lt;code&gt;0.0&lt;/code&gt; 입니다. 이 속성을 설정할 때 필요한 경우 해당 최대 값이 조정되어 범위가 유효하게 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="f4afbb4740ef1fb3040ba313d98c3a88917e5218" translate="yes" xml:space="preserve">
          <source>The minimum acceptable &lt;a href=&quot;qml-qtquick-item#rotation-prop&quot;&gt;rotation&lt;/a&gt; to be applied to the &lt;a href=&quot;qmake-variable-reference#target&quot;&gt;target&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qmake-variable-reference#target&quot;&gt;대상에&lt;/a&gt; 적용 할 수 있는 최소 &lt;a href=&quot;qml-qtquick-item#rotation-prop&quot;&gt;회전&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b298457c04ffff1b54a53df24cc836c40063274d" translate="yes" xml:space="preserve">
          <source>The minimum acceptable &lt;a href=&quot;qml-qtquick-item#scale-prop&quot;&gt;scale&lt;/a&gt; to be applied to the &lt;a href=&quot;qmake-variable-reference#target&quot;&gt;target&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qmake-variable-reference#target&quot;&gt;대상에&lt;/a&gt; 적용 할 최소 허용 &lt;a href=&quot;qml-qtquick-item#scale-prop&quot;&gt;스케일&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="628f9310dae5e07a1371fc80557bf731fe541ed9" translate="yes" xml:space="preserve">
          <source>The minimum and default value is -1 (number limited by the number of rows in the model).</source>
          <target state="translated">최소값과 기본값은 -1입니다 (숫자는 모델의 행 수로 제한됨).</target>
        </trans-unit>
        <trans-unit id="53a39ae872bb6239d8fe29670ebcc483823c1b41" translate="yes" xml:space="preserve">
          <source>The minimum and default value is -1 (number limited to the number of columns in the model).</source>
          <target state="translated">최소값과 기본값은 -1입니다 (숫자는 모델의 열 수로 제한됨).</target>
        </trans-unit>
        <trans-unit id="99dfbc9c8d3e8befe6efdb10b57e5e916db70016" translate="yes" xml:space="preserve">
          <source>The minimum and default value is -1 (number limited to the number of rows in the model).</source>
          <target state="translated">최소값과 기본값은 -1입니다 (숫자는 모델의 행 수로 제한됨).</target>
        </trans-unit>
        <trans-unit id="9cb687e711b5f725b05b015ceb709f2391bbd038" translate="yes" xml:space="preserve">
          <source>The minimum and default value is -1 (the number is limited by the number of columns in the model).</source>
          <target state="translated">최소값과 기본값은 -1입니다 (숫자는 모델의 열 수에 의해 제한됨).</target>
        </trans-unit>
        <trans-unit id="6ebde1eef107a512597162fb42664ad47c47dd62" translate="yes" xml:space="preserve">
          <source>The minimum and default value is -1 (the number is limited by the number of rows in the model).</source>
          <target state="translated">최소값과 기본값은 -1입니다 (숫자는 모델의 행 수에 의해 제한됨).</target>
        </trans-unit>
        <trans-unit id="161f068d7931a419861478220a8ef33234958656" translate="yes" xml:space="preserve">
          <source>The minimum and default value is 0.</source>
          <target state="translated">최소값과 기본값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="f3717c54c2e4830f63594e1ccf20827399bbf97a" translate="yes" xml:space="preserve">
          <source>The minimum and maximum number of steps can be specified by calling &lt;a href=&quot;qwintaskbarprogress#minimum-prop&quot;&gt;setMinimum&lt;/a&gt;() and &lt;a href=&quot;qwintaskbarprogress#maximum-prop&quot;&gt;setMaximum&lt;/a&gt;(). The current number of steps is set with &lt;a href=&quot;qwintaskbarprogress#value-prop&quot;&gt;setValue&lt;/a&gt;(). The progress indicator can be rewound to the beginning with &lt;a href=&quot;qwintaskbarprogress#reset&quot;&gt;reset&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qwintaskbarprogress#minimum-prop&quot;&gt;setMinimum&lt;/a&gt; () 및 &lt;a href=&quot;qwintaskbarprogress#maximum-prop&quot;&gt;setMaximum&lt;/a&gt; () 을 호출하여 최소 및 최대 단계 수를 지정할 수 있습니다 . 현재 단계 수는 &lt;a href=&quot;qwintaskbarprogress#value-prop&quot;&gt;setValue&lt;/a&gt; ()로 설정됩니다 . 진행 표시기는 &lt;a href=&quot;qwintaskbarprogress#reset&quot;&gt;리셋&lt;/a&gt; ()으로 시작 부분으로 되 감길 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2236e996e5fbcf40b56fb98fa7abb7c9d125e450" translate="yes" xml:space="preserve">
          <source>The minimum and maximum values are set in one call with &lt;a href=&quot;qintvalidator#setRange&quot;&gt;setRange&lt;/a&gt;(), or individually with &lt;a href=&quot;qintvalidator#bottom-prop&quot;&gt;setBottom&lt;/a&gt;() and &lt;a href=&quot;qintvalidator#top-prop&quot;&gt;setTop&lt;/a&gt;().</source>
          <target state="translated">최소값과 최대 값은 &lt;a href=&quot;qintvalidator#setRange&quot;&gt;setRange&lt;/a&gt; () 또는 &lt;a href=&quot;qintvalidator#bottom-prop&quot;&gt;setBottom&lt;/a&gt; () 및 &lt;a href=&quot;qintvalidator#top-prop&quot;&gt;setTop&lt;/a&gt; ()을 사용하여 한 번의 호출로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="4b7ebdb58ddf8dba755e237c76bbde227518646f" translate="yes" xml:space="preserve">
          <source>The minimum and maximum values displayable by the gauge can be set with the &lt;a href=&quot;qml-qtquick-extras-circulargauge#minimumValue-prop&quot;&gt;minimumValue&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-extras-circulargauge#maximumValue-prop&quot;&gt;maximumValue&lt;/a&gt; properties. The angle at which these values are displayed can be set with the &lt;a href=&quot;qml-qtquick-controls-styles-circulargaugestyle#minimumValueAngle-prop&quot;&gt;minimumValueAngle&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-controls-styles-circulargaugestyle#maximumValueAngle-prop&quot;&gt;maximumValueAngle&lt;/a&gt; properties of &lt;a href=&quot;qml-qtquick-controls-styles-circulargaugestyle&quot;&gt;CircularGaugeStyle&lt;/a&gt;.</source>
          <target state="translated">게이지가 표시 할 수있는 최소값과 최대 값은 &lt;a href=&quot;qml-qtquick-extras-circulargauge#minimumValue-prop&quot;&gt;minimumValue&lt;/a&gt; 및 &lt;a href=&quot;qml-qtquick-extras-circulargauge#maximumValue-prop&quot;&gt;maximumValue&lt;/a&gt; 속성 으로 설정할 수 있습니다 . 이 값이 표시되는 각도 는 &lt;a href=&quot;qml-qtquick-controls-styles-circulargaugestyle&quot;&gt;CircularGaugeStyle&lt;/a&gt; 의 &lt;a href=&quot;qml-qtquick-controls-styles-circulargaugestyle#minimumValueAngle-prop&quot;&gt;minimumValueAngle&lt;/a&gt; 및 &lt;a href=&quot;qml-qtquick-controls-styles-circulargaugestyle#maximumValueAngle-prop&quot;&gt;maximumValueAngle&lt;/a&gt; 속성을 사용하여 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fb95de6e38fd7661ca355c2ba6d1a4cd20237555" translate="yes" xml:space="preserve">
          <source>The minimum and maximum values displayable by the gauge can be set with the &lt;a href=&quot;qml-qtquick-extras-gauge#minimumValue-prop&quot;&gt;minimumValue&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-extras-gauge#maximumValue-prop&quot;&gt;maximumValue&lt;/a&gt; properties.</source>
          <target state="translated">게이지가 표시 할 수있는 최소값과 최대 값은 &lt;a href=&quot;qml-qtquick-extras-gauge#minimumValue-prop&quot;&gt;minimumValue&lt;/a&gt; 및 &lt;a href=&quot;qml-qtquick-extras-gauge#maximumValue-prop&quot;&gt;maximumValue&lt;/a&gt; 속성 으로 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="65024e30e6bfe907ce9523fd8aa87d38373c5f7c" translate="yes" xml:space="preserve">
          <source>The minimum deployment target for Qt applications is specified in &lt;a href=&quot;supported-platforms&quot;&gt;Supported Platforms&lt;/a&gt;.</source>
          <target state="translated">Qt 애플리케이션의 최소 배포 대상은 &lt;a href=&quot;supported-platforms&quot;&gt;지원되는 플랫폼에&lt;/a&gt; 지정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="06fa152c610e9ff1801e80cdddca27ace7867512" translate="yes" xml:space="preserve">
          <source>The minimum deployment target for Qt applications is specified in &lt;a href=&quot;supported-platforms#&quot;&gt;Supported Platforms&lt;/a&gt;.</source>
          <target state="translated">Qt 애플리케이션의 최소 배치 대상은 &lt;a href=&quot;supported-platforms#&quot;&gt;지원되는 플랫폼에&lt;/a&gt; 지정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="13c9d4653b43ce1071301848a34b4f06a5780c2b" translate="yes" xml:space="preserve">
          <source>The minimum frame rate supported by the range, in frames per second.</source>
          <target state="translated">범위에서 지원되는 최소 프레임 속도 (초당 프레임)입니다.</target>
        </trans-unit>
        <trans-unit id="647867d29d10f8028bf2b778788c2844696321da" translate="yes" xml:space="preserve">
          <source>The minimum frequency for the current &lt;a href=&quot;qml-qtmultimedia-radio#band-prop&quot;&gt;band&lt;/a&gt;.</source>
          <target state="translated">현재 &lt;a href=&quot;qml-qtmultimedia-radio#band-prop&quot;&gt;대역&lt;/a&gt; 의 최소 ​​주파수 .</target>
        </trans-unit>
        <trans-unit id="04e8fecee3e545682a34943a58b729bf1c63a865" translate="yes" xml:space="preserve">
          <source>The minimum height of a vertical scroll bar's slider and the minimum width of a horizontal scroll bar's slider.</source>
          <target state="translated">세로 스크롤 막대 슬라이더의 최소 높이와 가로 스크롤 막대 슬라이더의 최소 너비입니다.</target>
        </trans-unit>
        <trans-unit id="80a62b8764f82654f9126c9b70bfd9a2bd1086d3" translate="yes" xml:space="preserve">
          <source>The minimum height of the content item.</source>
          <target state="translated">컨텐츠 항목의 최소 높이입니다.</target>
        </trans-unit>
        <trans-unit id="1f9e4ba909e9a2e9687e4f842857f50aa8c5c041" translate="yes" xml:space="preserve">
          <source>The minimum logical font size that is applied when zooming out.</source>
          <target state="translated">축소 할 때 적용되는 최소 논리 글꼴 크기입니다.</target>
        </trans-unit>
        <trans-unit id="c8a13d5a14841090b6e494101ee4cc6cfd2539f8" translate="yes" xml:space="preserve">
          <source>The minimum margins allowed between the edge of the chart rectangle and the plot area. The margins are used for drawing the title, axes, and legend.</source>
          <target state="translated">차트 사각형의 가장자리와 플롯 영역 사이에 허용되는 최소 여백. 여백은 제목, 축 및 범례를 그리는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="707171370a9744ed8405971ca8e77b3173502692" translate="yes" xml:space="preserve">
          <source>The minimum margins can be defined for the layout but normally default to 0. When used in conjunction with Qt's printing support the minimum margins will reflect the minimum printable area defined by the printer.</source>
          <target state="translated">최소 여백은 레이아웃에 대해 정의 할 수 있지만 일반적으로 0으로 기본 설정됩니다. Qt의 인쇄 지원과 함께 사용되는 경우 최소 여백은 프린터에서 정의한 최소 인쇄 가능 영역을 반영합니다.</target>
        </trans-unit>
        <trans-unit id="f6d5d3669779c22104871d764d7da15334690c62" translate="yes" xml:space="preserve">
          <source>The minimum number of touchpoints required to activate this handler.</source>
          <target state="translated">이 핸들러를 활성화하는 데 필요한 최소 터치 포인트 수입니다.</target>
        </trans-unit>
        <trans-unit id="fe683a74f5807a5187c82860c42340f0888bc425" translate="yes" xml:space="preserve">
          <source>The minimum required Windows version to run the package. Defaults to &lt;code&gt;WINDOWS_TARGET_PLATFORM_VERSION&lt;/code&gt;.</source>
          <target state="translated">패키지를 실행하는 데 필요한 최소 Windows 버전입니다. 기본값은 &lt;code&gt;WINDOWS_TARGET_PLATFORM_VERSION&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7d67d0ad2d6585603a2872bd0ff18e0b1cb8e75d" translate="yes" xml:space="preserve">
          <source>The minimum section size is the smallest section size allowed. If the minimum section size is set to -1, &lt;a href=&quot;qheaderview&quot;&gt;QHeaderView&lt;/a&gt; will use the maximum of the &lt;a href=&quot;https://doc.qt.io/qt-5.15/qapplication-obsolete.html#globalStrut-prop&quot;&gt;global strut&lt;/a&gt; or the &lt;a href=&quot;qwidget#fontMetrics&quot;&gt;font metrics&lt;/a&gt; size.</source>
          <target state="translated">최소 섹션 크기는 허용되는 최소 섹션 크기입니다. 최소 섹션 크기가 -1로 설정되면 &lt;a href=&quot;qheaderview&quot;&gt;QHeaderView&lt;/a&gt; 는 &lt;a href=&quot;https://doc.qt.io/qt-5.15/qapplication-obsolete.html#globalStrut-prop&quot;&gt;전역 스트럿&lt;/a&gt; 또는 &lt;a href=&quot;qwidget#fontMetrics&quot;&gt;글꼴 메트릭&lt;/a&gt; 크기 의 최대 값을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="6b24914b5ce93e117e712a5fe86bcd9b5abf3d16" translate="yes" xml:space="preserve">
          <source>The minimum section size is the smallest section size allowed. If the minimum section size is set to -1, &lt;a href=&quot;qheaderview&quot;&gt;QHeaderView&lt;/a&gt; will use the maximum of the &lt;a href=&quot;qapplication#globalStrut-prop&quot;&gt;global strut&lt;/a&gt; or the &lt;a href=&quot;qwidget#fontMetrics&quot;&gt;font metrics&lt;/a&gt; size.</source>
          <target state="translated">최소 섹션 크기는 허용되는 최소 섹션 크기입니다. 최소 섹션 크기가 -1로 설정되면 &lt;a href=&quot;qheaderview&quot;&gt;QHeaderView&lt;/a&gt; 는 최대 &lt;a href=&quot;qapplication#globalStrut-prop&quot;&gt;전역 스트럿&lt;/a&gt; 또는 &lt;a href=&quot;qwidget#fontMetrics&quot;&gt;글꼴 메트릭&lt;/a&gt; 크기를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="2fdd9a27d3e5846a504d8d4c8b47a6cde3133c04" translate="yes" xml:space="preserve">
          <source>The minimum size set by this function will override the minimum size defined by &lt;a href=&quot;qlayout&quot;&gt;QLayout&lt;/a&gt;. In order to unset the minimum size, use a value of &lt;code&gt;QSize(0, 0)&lt;/code&gt;.</source>
          <target state="translated">이 함수에 의해 설정된 최소 크기는 &lt;a href=&quot;qlayout&quot;&gt;QLayout에&lt;/a&gt; 의해 정의 된 최소 크기보다 우선합니다 . 최소 크기를 설정 해제하려면 &lt;code&gt;QSize(0, 0)&lt;/code&gt; 값을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="4aebee72cacd0602207c8b6d775e5a3f3f8d9576" translate="yes" xml:space="preserve">
          <source>The minimum tilt defined by the &lt;a href=&quot;location-places-qml#plugin&quot;&gt;plugin&lt;/a&gt; used is a lower bound for this property. If the &lt;a href=&quot;location-places-qml#plugin&quot;&gt;plugin&lt;/a&gt; property is not set or the plugin does not support mapping, this property is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">사용 된 &lt;a href=&quot;location-places-qml#plugin&quot;&gt;플러그인에&lt;/a&gt; 의해 정의 된 최소 기울기 는이 속성의 하한입니다. 경우 &lt;a href=&quot;location-places-qml#plugin&quot;&gt;플러그인&lt;/a&gt; 속성이 설정되지 않았거나 플러그인 매핑을 지원하지 않습니다,이 속성은 &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="65ac8eda2848fbcd794b78ada19685ca03a1f68d" translate="yes" xml:space="preserve">
          <source>The minimum tilt field of view by the &lt;a href=&quot;location-places-qml#plugin&quot;&gt;plugin&lt;/a&gt; used is a lower bound for this property. If the &lt;a href=&quot;location-places-qml#plugin&quot;&gt;plugin&lt;/a&gt; property is not set or the plugin does not support mapping, this property is &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">사용되는 &lt;a href=&quot;location-places-qml#plugin&quot;&gt;플러그인&lt;/a&gt; 의 최소 ​​틸트 시야는 이 속성의 하한입니다. 경우 &lt;a href=&quot;location-places-qml#plugin&quot;&gt;플러그인&lt;/a&gt; 속성이 설정되지 않았거나 플러그인 매핑을 지원하지 않습니다,이 속성은 &lt;code&gt;1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f719e25e9a4664079100f83163de57fcc3acd5f" translate="yes" xml:space="preserve">
          <source>The minimum tilt field of view by the &lt;a href=&quot;location-places-qml#plugin&quot;&gt;plugin&lt;/a&gt; used is an upper bound for this property. If the &lt;a href=&quot;location-places-qml#plugin&quot;&gt;plugin&lt;/a&gt; property is not set or the plugin does not support mapping, this property is &lt;code&gt;179&lt;/code&gt;.</source>
          <target state="translated">사용 된 &lt;a href=&quot;location-places-qml#plugin&quot;&gt;플러그인&lt;/a&gt; 의 최소 ​​틸트 시야는 이 속성의 상한입니다. 경우 &lt;a href=&quot;location-places-qml#plugin&quot;&gt;플러그인&lt;/a&gt; 속성이 설정되지 않았거나 플러그인 매핑을 지원하지 않습니다,이 속성은 &lt;code&gt;179&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5fe823fc97e72331ae644d09d07baae83ebbc478" translate="yes" xml:space="preserve">
          <source>The minimum value for &lt;a href=&quot;qdatetimeedit&quot;&gt;QDateTimeEdit&lt;/a&gt; is 14 September 1752. You can change this by calling &lt;a href=&quot;qdatetimeedit#minimumDate-prop&quot;&gt;setMinimumDate&lt;/a&gt;(), taking into account that the minimum value for &lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt; is 2 January 4713BC.</source>
          <target state="translated">최소값 &lt;a href=&quot;qdatetimeedit&quot;&gt;QDateTimeEdit&lt;/a&gt; 은 1752 년 9 월 14 일 QDate 이 &lt;a href=&quot;qdate&quot;&gt;4713BC&lt;/a&gt; 1 월 2 일임 을 고려하여 &lt;a href=&quot;qdatetimeedit#minimumDate-prop&quot;&gt;setMinimumDate&lt;/a&gt; () 를 호출하여이를 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c03e3ffb70e270e7808e7e9135b21a64515ff295" translate="yes" xml:space="preserve">
          <source>The minimum value for custom types. Values below UserType are reserved by Qt.</source>
          <target state="translated">사용자 정의 유형의 최소값입니다. UserType 아래의 값은 Qt에 의해 예약됩니다.</target>
        </trans-unit>
        <trans-unit id="c321370dedd7e5fc99c10a41028923e0155b18c7" translate="yes" xml:space="preserve">
          <source>The minimum value of the &lt;a href=&quot;qml-qtquick-controls-spinbox&quot;&gt;SpinBox&lt;/a&gt; range. The &lt;a href=&quot;qml-qtquick-controls-spinbox#value-prop&quot;&gt;value&lt;/a&gt; is clamped to this value.</source>
          <target state="translated">최소값 &lt;a href=&quot;qml-qtquick-controls-spinbox&quot;&gt;SpinBox&lt;/a&gt; 범위 입니다. &lt;a href=&quot;qml-qtquick-controls-spinbox#value-prop&quot;&gt;값이&lt;/a&gt; 이 값으로 클램프된다.</target>
        </trans-unit>
        <trans-unit id="0cdeb63d3b83e25d2e8eb5d8ebc367a37e63796a" translate="yes" xml:space="preserve">
          <source>The minimum value of the bar.</source>
          <target state="translated">막대의 최소값입니다.</target>
        </trans-unit>
        <trans-unit id="0e7d5f7db64bca48bb34a0c0969685b219f404e2" translate="yes" xml:space="preserve">
          <source>The minimum value of the scroll bar.</source>
          <target state="translated">스크롤 막대의 최소값입니다.</target>
        </trans-unit>
        <trans-unit id="660f72476ddfc65ac5c3d43f7033f0a3776eb598" translate="yes" xml:space="preserve">
          <source>The minimum value of the slider.</source>
          <target state="translated">슬라이더의 최소값입니다.</target>
        </trans-unit>
        <trans-unit id="6c00fff3fdc4f8c7d00e879ecb03035342223772" translate="yes" xml:space="preserve">
          <source>The minimum value on the axis.</source>
          <target state="translated">축의 최소값입니다.</target>
        </trans-unit>
        <trans-unit id="022af7673278b1078b5a9c743559d46a5e2b8323" translate="yes" xml:space="preserve">
          <source>The minimum value on the axis. When setting this property, the maximum value is adjusted if necessary, to ensure that the range remains valid.</source>
          <target state="translated">축의 최소값입니다. 이 속성을 설정할 때 필요한 경우 최대 값이 조정되어 범위가 유효하게 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="6c709b8bce6aea7a8d888f708256c2d89e6f5fbe" translate="yes" xml:space="preserve">
          <source>The minimum velocity that is needed after ending the touch or releasing the mouse to start scrolling in &lt;code&gt;m/s&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;m/s&lt;/code&gt; 단위로 스크롤을 시작하기 위해 터치를 종료하거나 마우스를 놓은 후 필요한 최소 속도 .</target>
        </trans-unit>
        <trans-unit id="61c35cae38b0757708456b597500f3996c063bd6" translate="yes" xml:space="preserve">
          <source>The minimum version of &lt;a href=&quot;https://mingw-w64.org/&quot;&gt;MinGW&lt;/a&gt;-builds supported is GCC 5.1.0 (&lt;a href=&quot;https://sourceforge.net/projects/mingw-w64/files/Toolchains%20targetting%20Win64/Personal%20Builds/mingw-builds/5.1.0/threads-posix/sjlj/x86_64-5.1.0-release-posix-sjlj-rt_v4-rev0.7z/download&quot;&gt;64bit&lt;/a&gt;, &lt;a href=&quot;https://sourceforge.net/projects/mingw-w64/files/Toolchains%20targetting%20Win32/Personal%20Builds/mingw-builds/5.1.0/threads-posix/sjlj/i686-5.1.0-release-posix-sjlj-rt_v4-rev0.7z/download&quot;&gt;32bit&lt;/a&gt;), available from its &lt;a href=&quot;https://sourceforge.net/projects/mingw-w64/files&quot;&gt;download page&lt;/a&gt;.</source>
          <target state="translated">지원되는 &lt;a href=&quot;https://mingw-w64.org/&quot;&gt;MinGW&lt;/a&gt; 빌드 의 최소 ​​버전 은 GCC 5.1.0 ( &lt;a href=&quot;https://sourceforge.net/projects/mingw-w64/files/Toolchains%20targetting%20Win64/Personal%20Builds/mingw-builds/5.1.0/threads-posix/sjlj/x86_64-5.1.0-release-posix-sjlj-rt_v4-rev0.7z/download&quot;&gt;64bit&lt;/a&gt; , &lt;a href=&quot;https://sourceforge.net/projects/mingw-w64/files/Toolchains%20targetting%20Win32/Personal%20Builds/mingw-builds/5.1.0/threads-posix/sjlj/i686-5.1.0-release-posix-sjlj-rt_v4-rev0.7z/download&quot;&gt;32bit&lt;/a&gt; )이며 &lt;a href=&quot;https://sourceforge.net/projects/mingw-w64/files&quot;&gt;다운로드 페이지&lt;/a&gt; 에서 다운로드 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dde8e7940f9ae4a4bc30913dabd3d4eab4701f2d" translate="yes" xml:space="preserve">
          <source>The minimum width of the candlestick items in pixels. Setting a negative value means there is no minimum width. All negative values are converted to -1.0.</source>
          <target state="translated">촛대 항목의 최소 너비 (픽셀)입니다. 음수 값을 설정하면 최소 너비가 없습니다. 모든 음수 값은 -1.0으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="daaa31ad8591970e2178fdf085478c4d5cc202de" translate="yes" xml:space="preserve">
          <source>The minimum width of the content item.</source>
          <target state="translated">컨텐트 항목의 최소 너비입니다.</target>
        </trans-unit>
        <trans-unit id="47ffdfdf59602efe8e4db04e5b4a92b4ca633a62" translate="yes" xml:space="preserve">
          <source>The minimum width the layout needs. This is the width of the layout's smallest non-breakable substring.</source>
          <target state="translated">레이아웃에 필요한 최소 너비 이것은 레이아웃에서 깨지지 않는 가장 작은 부분 문자열의 너비입니다.</target>
        </trans-unit>
        <trans-unit id="6db9a4bdfe5cfaf5a28e3eba6ed3967ca1b43a6d" translate="yes" xml:space="preserve">
          <source>The minimum zoom level [double] at which the map is displayed</source>
          <target state="translated">지도가 표시되는 최소 줌 레벨 [double]</target>
        </trans-unit>
        <trans-unit id="8191b25f40432351556bd2c6a2e3756b221dc071" translate="yes" xml:space="preserve">
          <source>The minimum zoom level defined by the &lt;a href=&quot;location-places-qml#plugin&quot;&gt;plugin&lt;/a&gt; used is a lower bound for this property. However, the returned value is also canvas-size-dependent, and can be higher than the user-specified value, or than the minimum zoom level defined by the plugin used, to prevent the map from being smaller than the viewport in either dimension.</source>
          <target state="translated">사용 된 &lt;a href=&quot;location-places-qml#plugin&quot;&gt;플러그인에&lt;/a&gt; 의해 정의 된 최소 줌 레벨 은이 속성의 하한입니다. 그러나 반환되는 값은 캔버스 크기에 따라 다르며 맵이 어느 한 차원에서 뷰포트보다 작지 않도록 사용자 지정 값 또는 사용 된 플러그인에 의해 정의 된 최소 줌 레벨보다 높을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d5729a09d44b8863cb35670ed11df7e3978d0e3c" translate="yes" xml:space="preserve">
          <source>The minute with a leading zero (00 to 59)</source>
          <target state="translated">앞에 0이있는 분 (00-59)</target>
        </trans-unit>
        <trans-unit id="d68c6e92e55ada818c9d5d17a3330384e63de947" translate="yes" xml:space="preserve">
          <source>The minute without a leading zero (0 to 59)</source>
          <target state="translated">앞에 0이없는 분 (0 ~ 59)</target>
        </trans-unit>
        <trans-unit id="4f50c42b17da3509c4c207cf12c16b71f1eeff2b" translate="yes" xml:space="preserve">
          <source>The mipmap filtering mode is set on the texture instance just before the texture is bound for rendering.</source>
          <target state="translated">밉맵 필터링 모드는 텍스처가 렌더링을 위해 바인딩되기 직전에 텍스처 인스턴스에서 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="0aedd13d461157d56e0e429f7f02d09267bf11cf" translate="yes" xml:space="preserve">
          <source>The miter limit describes how far a miter join can extend from the join point. This is used to reduce artifacts between line joins where the lines are close to parallel.</source>
          <target state="translated">연귀 제한은 연귀 결합이 결합 지점에서 연장 될 수있는 거리를 나타냅니다. 이것은 선이 평행에 가까운 선 결합 사이의 아티팩트를 줄이는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c3356cdf8db3b1b8ca3a71d5eea899d64060d2f4" translate="yes" xml:space="preserve">
          <source>The miter limit describes how far from each join the miter join can extend. The limit is specified in units of the currently set width. So the pixelwise miter limit will be &lt;code&gt;miterlimit * width&lt;/code&gt;.</source>
          <target state="translated">연귀 한계는 연귀 결합이 연장 될 수있는 각 결합으로부터 얼마나 멀리 떨어져 있는지를 설명합니다. 한계는 현재 설정된 너비의 단위로 지정됩니다. 따라서 픽셀 단위 마이 터 제한은 &lt;code&gt;miterlimit * width&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a3c08f05258f2e551b33ea7549bd7f54459fe40b" translate="yes" xml:space="preserve">
          <source>The mnemonic character is prefixed by an ampersand in the original string.</source>
          <target state="translated">니모닉 문자 앞에는 원래 문자열에 앰퍼샌드가 붙습니다.</target>
        </trans-unit>
        <trans-unit id="7845a9684c48cf87179206ab1cfdf05c0f867a0d" translate="yes" xml:space="preserve">
          <source>The modality of the window.</source>
          <target state="translated">창의 양식입니다.</target>
        </trans-unit>
        <trans-unit id="44d8c0cb51f2748b578be47f6ddc7fe62cd2a8a9" translate="yes" xml:space="preserve">
          <source>The mode can be one of the following:</source>
          <target state="translated">모드는 다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b34e97a1dd56e8482fe5f15af3ab07888bb76173" translate="yes" xml:space="preserve">
          <source>The mode for the backend node.</source>
          <target state="translated">백엔드 노드의 모드입니다.</target>
        </trans-unit>
        <trans-unit id="65e13424a2402fbee16988ca6a95f644e7c4bf5e" translate="yes" xml:space="preserve">
          <source>The mode for unregistering an object path:</source>
          <target state="translated">객체 경로를 등록 해제하는 모드 :</target>
        </trans-unit>
        <trans-unit id="d675f75bc4d6b7c811bc7abbb02ec5f31d820b51" translate="yes" xml:space="preserve">
          <source>The mode of scattering calculations.</source>
          <target state="translated">산란 계산 모드.</target>
        </trans-unit>
        <trans-unit id="a183933639c00075f522d203f0fc1873e9b2ae52" translate="yes" xml:space="preserve">
          <source>The mode of the file dialog.</source>
          <target state="translated">파일 대화 상자의 모드입니다.</target>
        </trans-unit>
        <trans-unit id="a92db33777554cdd533cd1d076238084156a02ae" translate="yes" xml:space="preserve">
          <source>The model &lt;code&gt;role&lt;/code&gt; of the column.</source>
          <target state="translated">열의 모델 &lt;code&gt;role&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1235fc83921642165428375f442d9ca34db240ec" translate="yes" xml:space="preserve">
          <source>The model allows menu items to be statically declared as children of the menu.</source>
          <target state="translated">이 모델을 사용하면 메뉴 항목을 메뉴의 자식으로 정적으로 선언 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3197eb944862b8d704f75c4af122d2ba14c5af57" translate="yes" xml:space="preserve">
          <source>The model can be a &lt;a href=&quot;qabstractlistmodel&quot;&gt;list model&lt;/a&gt;, a &lt;a href=&quot;qabstracttablemodel&quot;&gt;table model&lt;/a&gt;, or a &lt;a href=&quot;qabstractitemmodel&quot;&gt;tree model&lt;/a&gt;. Completion on tree models is slightly more involved and is covered in the &lt;a href=&quot;qcompleter#handling-tree-models&quot;&gt;Handling Tree Models&lt;/a&gt; section below.</source>
          <target state="translated">모델은 &lt;a href=&quot;qabstractlistmodel&quot;&gt;목록 모델&lt;/a&gt; , &lt;a href=&quot;qabstracttablemodel&quot;&gt;테이블 모델&lt;/a&gt; 또는 &lt;a href=&quot;qabstractitemmodel&quot;&gt;트리 모델 일 수&lt;/a&gt; 있습니다. 트리 모델의 완성은 약간 더 복잡하며 &lt;a href=&quot;qcompleter#handling-tree-models&quot;&gt;처리 트리 모델&lt;/a&gt; 에서 다룹니다. 아래의 섹션에서 다룹니다.</target>
        </trans-unit>
        <trans-unit id="9dab2237617b7e9f0a89f04a1acc8da51ceec376" translate="yes" xml:space="preserve">
          <source>The model can be constructed with an existing string list, or strings can be set later with the &lt;a href=&quot;qstringlistmodel#setStringList&quot;&gt;setStringList&lt;/a&gt;() convenience function. Strings can also be inserted in the usual way with the &lt;a href=&quot;qstringlistmodel#insertRows&quot;&gt;insertRows&lt;/a&gt;() function, and removed with &lt;a href=&quot;qstringlistmodel#removeRows&quot;&gt;removeRows&lt;/a&gt;(). The contents of the string list can be retrieved with the &lt;a href=&quot;qstringlistmodel#stringList&quot;&gt;stringList&lt;/a&gt;() convenience function.</source>
          <target state="translated">기존 문자열 목록으로 모델을 구성하거나 나중에 &lt;a href=&quot;qstringlistmodel#setStringList&quot;&gt;setStringList&lt;/a&gt; () 편의 기능을 사용하여 문자열을 설정할 수 있습니다 . &lt;a href=&quot;qstringlistmodel#insertRows&quot;&gt;insertRows&lt;/a&gt; () 함수 를 사용하여 일반적인 방식으로 문자열을 삽입 하고 &lt;a href=&quot;qstringlistmodel#removeRows&quot;&gt;removeRows&lt;/a&gt; ()를 사용 하여 제거 할 수도 있습니다 . 문자열리스트의 내용은 &lt;a href=&quot;qstringlistmodel#stringList&quot;&gt;stringList&lt;/a&gt; () 편의 함수를 사용하여 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cb582fe6bf56668ff46fe252c5f29f01b479605b" translate="yes" xml:space="preserve">
          <source>The model can load static meshes from storage or one of the built-in primitive types. The mesh format used is a run-time format that's native to the engine, but additional formats are supported through the asset import tool Balsam.</source>
          <target state="translated">모델은 저장소 또는 기본 제공 기본 유형 중 하나에서 정적 메쉬를로드 할 수 있습니다. 사용되는 메시 형식은 엔진 고유의 런타임 형식이지만 자산 가져 오기 도구 Balsam을 통해 추가 형식이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="9fe3bfd9e90f5cb26ed5c7d0d5520ad529028cb5" translate="yes" xml:space="preserve">
          <source>The model communicates with a source of data, providing an</source>
          <target state="translated">이 모델은 데이터 소스와 통신하여</target>
        </trans-unit>
        <trans-unit id="523fbe6f07f8c8c09aed122f8f3c61b8bd155e0d" translate="yes" xml:space="preserve">
          <source>The model could be used in a &lt;a href=&quot;qml-qtquick-listview&quot;&gt;ListView&lt;/a&gt;, like this:</source>
          <target state="translated">모델은 다음 과 같이 &lt;a href=&quot;qml-qtquick-listview&quot;&gt;ListView&lt;/a&gt; 에서 사용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bc5cedf313ac5ce5f1297b5bd25cb5baf974fc81" translate="yes" xml:space="preserve">
          <source>The model emits signals to indicate changes. For example, &lt;a href=&quot;qabstractitemmodel#dataChanged&quot;&gt;dataChanged&lt;/a&gt;() is emitted whenever items of data made available by the model are changed. Changes to the headers supplied by the model cause &lt;a href=&quot;qabstractitemmodel#headerDataChanged&quot;&gt;headerDataChanged&lt;/a&gt;() to be emitted. If the structure of the underlying data changes, the model can emit &lt;a href=&quot;qabstractitemmodel#layoutChanged&quot;&gt;layoutChanged&lt;/a&gt;() to indicate to any attached views that they should redisplay any items shown, taking the new structure into account.</source>
          <target state="translated">모델은 변화를 나타내는 신호를 방출합니다. 예를 들어, &lt;a href=&quot;qabstractitemmodel#dataChanged&quot;&gt;dataChanged&lt;/a&gt; ()는 모델에서 사용 가능한 데이터 항목이 변경 될 때마다 생성됩니다. 모델이 제공 한 헤더를 변경하면 &lt;a href=&quot;qabstractitemmodel#headerDataChanged&quot;&gt;headerDataChanged&lt;/a&gt; ()가 생성됩니다. 기본 데이터의 구조가 변경되면 모델에서 &lt;a href=&quot;qabstractitemmodel#layoutChanged&quot;&gt;레이아웃을&lt;/a&gt; 방출 할 수 있습니다. ()를 하여 새 구조를 고려하여 표시된 항목을 다시 표시해야하는 연결된보기를 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9d9c169406c7ecb516c4ff9c6f5308acf11664c" translate="yes" xml:space="preserve">
          <source>The model exposes the following data roles for the list delegate:</source>
          <target state="translated">모델은 목록 대리자에 대한 다음 데이터 역할을 노출합니다.</target>
        </trans-unit>
        <trans-unit id="cb8c2f07edbcd991a6b8ff96d36b2d4e0aa386b4" translate="yes" xml:space="preserve">
          <source>The model first calls the &lt;a href=&quot;qabstractitemmodel#beginInsertRows&quot;&gt;beginInsertRows()&lt;/a&gt; function to inform other components that the number of rows is about to change. The function specifies the row numbers of the first and last new rows to be inserted, and the model index for their parent item. After changing the string list, it calls &lt;a href=&quot;qabstractitemmodel#endInsertRows&quot;&gt;endInsertRows()&lt;/a&gt; to complete the operation and inform other components that the dimensions of the model have changed, returning true to indicate success.</source>
          <target state="translated">모델은 먼저 &lt;a href=&quot;qabstractitemmodel#beginInsertRows&quot;&gt;beginInsertRows ()&lt;/a&gt; 함수를 호출하여 행 수를 변경하려고한다는 것을 다른 구성 요소에 알립니다. 이 함수는 삽입 할 첫 번째 및 마지막 새 행의 행 번호와 상위 항목의 모델 색인을 지정합니다. 문자열 목록을 변경 한 후 &lt;a href=&quot;qabstractitemmodel#endInsertRows&quot;&gt;endInsertRows ()를&lt;/a&gt; 호출합니다. 를 하여 작업을 완료하고 다른 구성 요소에 모델의 크기가 변경되었음을 알리고 성공을 나타내는 true를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5ef52d4ecf4ef9c029d59114998f9e846251082d" translate="yes" xml:space="preserve">
          <source>The model first has to make sure that the operation should be acted on, the data supplied is in a format that can be used, and that its destination within the model is valid:</source>
          <target state="translated">모델은 먼저 작업을 수행하고 제공된 데이터가 사용할 수있는 형식이며 모델 내 대상이 유효한지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="91eb002a1b5f7d3124c1ecdd770562cca0b8c2fa" translate="yes" xml:space="preserve">
          <source>The model has a &lt;a href=&quot;qabstractitemmodel#rowCount&quot;&gt;rowCount&lt;/a&gt;() and a &lt;a href=&quot;qabstractitemmodel#columnCount&quot;&gt;columnCount&lt;/a&gt;() for each level of the hierarchy. Rows and columns can be inserted and removed with &lt;a href=&quot;qabstractitemmodel#insertRows&quot;&gt;insertRows&lt;/a&gt;(), &lt;a href=&quot;qabstractitemmodel#insertColumns&quot;&gt;insertColumns&lt;/a&gt;(), &lt;a href=&quot;qabstractitemmodel#removeRows&quot;&gt;removeRows&lt;/a&gt;(), and &lt;a href=&quot;qabstractitemmodel#removeColumns&quot;&gt;removeColumns&lt;/a&gt;().</source>
          <target state="translated">모델에는 각 계층 구조 수준에 대한 &lt;a href=&quot;qabstractitemmodel#rowCount&quot;&gt;rowCount&lt;/a&gt; () 및 &lt;a href=&quot;qabstractitemmodel#columnCount&quot;&gt;columnCount&lt;/a&gt; ()가 있습니다. &lt;a href=&quot;qabstractitemmodel#insertRows&quot;&gt;insertRows&lt;/a&gt; (), &lt;a href=&quot;qabstractitemmodel#insertColumns&quot;&gt;insertColumns&lt;/a&gt; (), &lt;a href=&quot;qabstractitemmodel#removeRows&quot;&gt;removeRows&lt;/a&gt; () 및 &lt;a href=&quot;qabstractitemmodel#removeColumns&quot;&gt;removeColumns&lt;/a&gt; ()를 사용 하여 행과 열을 삽입하고 제거 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e9c22346e21a38807495e7231235ac8434da7aab" translate="yes" xml:space="preserve">
          <source>The model has been reset, all previous knowledge about the model is now invalid.</source>
          <target state="translated">모델이 재설정되었으며 이제 모델에 대한 모든 이전 지식이 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d0a7081aec71c8bc9c8c3cb7026e971396c5455d" translate="yes" xml:space="preserve">
          <source>The model implemented here is a simple, non-hierarchical, read-only data model based on the standard &lt;a href=&quot;qstringlistmodel&quot;&gt;QStringListModel&lt;/a&gt; class. It has a &lt;a href=&quot;qstringlist&quot;&gt;QStringList&lt;/a&gt; as its internal data source, and implements only what is needed to make a functioning model. To make the implementation easier, we subclass &lt;a href=&quot;qabstractlistmodel&quot;&gt;QAbstractListModel&lt;/a&gt; because it defines sensible default behavior for list models, and it exposes a simpler interface than the &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; class.</source>
          <target state="translated">여기에 구현 된 모델은 표준 &lt;a href=&quot;qstringlistmodel&quot;&gt;QStringListModel&lt;/a&gt; 클래스를 기반으로하는 비 계층 적 읽기 전용 데이터 모델 입니다. 그것은이 &lt;a href=&quot;qstringlist&quot;&gt;QStringList&lt;/a&gt; 작동하는 모델을 만드는 데 필요한 것만 내부 데이터 소스로, 그리고 구현합니다. &lt;a href=&quot;qabstractlistmodel&quot;&gt;QAbstractListModel을&lt;/a&gt; 구현하기 쉽도록 목록 모델에 대한 합리적인 기본 동작을 정의하고 &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; 클래스 보다 간단한 인터페이스를 제공하므로 구현이 더 쉬워집니다 .</target>
        </trans-unit>
        <trans-unit id="65a7d5b744123ab50204d57ed849ad9c2633c622" translate="yes" xml:space="preserve">
          <source>The model index of the current row in the tree view.</source>
          <target state="translated">트리 뷰에서 현재 행의 모델 색인입니다.</target>
        </trans-unit>
        <trans-unit id="211f5cd0ccbd3f9c702d0a118701190d64076ab6" translate="yes" xml:space="preserve">
          <source>The model index of the root item in the tree view. The root item is the parent item to the view's top-level items. Only items descending from the root item will be visible in the view.</source>
          <target state="translated">트리 뷰에서 루트 항목의 모델 색인입니다. 루트 항목은보기의 최상위 항목에 대한 상위 항목입니다. 루트 항목의 하위 항목 만보기에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="bd01d22d4d5c10545389bfaee91818f2bf17deac" translate="yes" xml:space="preserve">
          <source>The model index passed to &lt;a href=&quot;qabstractitemmodel#checkIndex&quot;&gt;QAbstractItemModel::checkIndex&lt;/a&gt;() is checked to be a valid model index.</source>
          <target state="translated">&lt;a href=&quot;qabstractitemmodel#checkIndex&quot;&gt;QAbstractItemModel :: checkIndex&lt;/a&gt; ()에 전달 된 모델 인덱스 가 유효한 모델 인덱스인지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="ae72eb9c40e206cf9942963d843e193afcafe0c4" translate="yes" xml:space="preserve">
          <source>The model index that is to be drawn.</source>
          <target state="translated">그려 질 모델 인덱스.</target>
        </trans-unit>
        <trans-unit id="75171c0b6be2fcd55def9f93443f9e0f4dc3f215" translate="yes" xml:space="preserve">
          <source>The model indexes stored in the selection model can be read using the &lt;a href=&quot;qitemselectionmodel#selectedIndexes&quot;&gt;selectedIndexes()&lt;/a&gt; function. This returns an unsorted list of model indexes that we can iterate over as long as we know which model they are for:</source>
          <target state="translated">선택 모델에 저장된 모델 인덱스는 &lt;a href=&quot;qitemselectionmodel#selectedIndexes&quot;&gt;selectedIndexes ()&lt;/a&gt; 함수를 사용하여 읽을 수 있습니다 . 이것은 모델이 어떤 모델인지 알고있는 한 반복 할 수있는 정렬되지 않은 모델 인덱스 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="aa90a76ca51299a7c8b25e82590df9bc4f1b0f79" translate="yes" xml:space="preserve">
          <source>The model is being updated, no other operations may be performed until complete.</source>
          <target state="translated">모델이 업데이트되고 있으며 완료 될 때까지 다른 작업을 수행 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="edc46f238d29121f82b340e783fbb52470cafa53" translate="yes" xml:space="preserve">
          <source>The model is not updated until &lt;a href=&quot;qdatawidgetmapper#submit&quot;&gt;submit&lt;/a&gt;() is called.</source>
          <target state="translated">&lt;a href=&quot;qdatawidgetmapper#submit&quot;&gt;제출&lt;/a&gt; ()이 호출 될 때까지 모델이 업데이트되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="8f7359ea2b6d8990e2e192b3f44f73a817071f2d" translate="yes" xml:space="preserve">
          <source>The model is read-only by default. To make it read-write, you must subclass it and reimplement &lt;a href=&quot;qabstractitemmodel#setData&quot;&gt;setData&lt;/a&gt;() and &lt;a href=&quot;qabstracttablemodel#flags&quot;&gt;flags&lt;/a&gt;(). Another option is to use &lt;a href=&quot;qsqltablemodel&quot;&gt;QSqlTableModel&lt;/a&gt;, which provides a read-write model based on a single database table.</source>
          <target state="translated">모델은 기본적으로 읽기 전용입니다. 읽기 / 쓰기를하려면 서브 클래스로 설정하고 &lt;a href=&quot;qabstractitemmodel#setData&quot;&gt;setData&lt;/a&gt; () 및 &lt;a href=&quot;qabstracttablemodel#flags&quot;&gt;플래그&lt;/a&gt; ()를 다시 구현해야합니다 . 다른 옵션은 &lt;a href=&quot;qsqltablemodel&quot;&gt;QSqlTableModel&lt;/a&gt; 을 사용하는 것입니다 단일 데이터베이스 테이블을 기반으로하는 읽기 / 쓰기 모델을 제공하는 하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="3c82c7f7a2413065389a85fa6915692d2ddc0aac" translate="yes" xml:space="preserve">
          <source>The model is set up to use data from a certain file system. The call to &lt;a href=&quot;qfilesystemmodel#setRootPath&quot;&gt;setRootPath()&lt;/a&gt; tells the model which drive on the file system to expose to the views.</source>
          <target state="translated">모델은 특정 파일 시스템의 데이터를 사용하도록 설정되었습니다. &lt;a href=&quot;qfilesystemmodel#setRootPath&quot;&gt;setRootPath ()&lt;/a&gt; 호출 은 파일 시스템에서 어떤 드라이브가 뷰에 노출되는지를 모델에 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="f13b8c8f18dd2654fde4f5904677f6415dcc9e9e" translate="yes" xml:space="preserve">
          <source>The model is sorted case insensitively.</source>
          <target state="translated">모델은 대소 문자를 구분하지 않고 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="eb523e4a1fbc466543e005d67f78c0dd83fcb5b4" translate="yes" xml:space="preserve">
          <source>The model is sorted case sensitively.</source>
          <target state="translated">모델은 대소 문자를 구분하여 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="cc3e9b7980ce86d4fa76e8691ed55b7adce71b66" translate="yes" xml:space="preserve">
          <source>The model is unsorted.</source>
          <target state="translated">모델이 정렬되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="38aec792b4693e26e17a0ed3fd36cc9b20d06dd9" translate="yes" xml:space="preserve">
          <source>The model items contained in the selection range can be obtained using the &lt;a href=&quot;qitemselectionrange#indexes&quot;&gt;indexes&lt;/a&gt;() function. Use &lt;a href=&quot;qitemselectionmodel#selectedIndexes&quot;&gt;QItemSelectionModel::selectedIndexes&lt;/a&gt;() to get a list of all selected items for a view.</source>
          <target state="translated">선택 범위에 포함 된 모델 항목은 &lt;a href=&quot;qitemselectionrange#indexes&quot;&gt;색인&lt;/a&gt; () 기능을 사용하여 얻을 수 있습니다 . &lt;a href=&quot;qitemselectionmodel#selectedIndexes&quot;&gt;QItemSelectionModel :: selectedIndexes&lt;/a&gt; ()를 사용 하여 뷰에 대해 선택된 모든 항목의 목록을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="9d423cdf76d195345eb3b36194323c106de6577c" translate="yes" xml:space="preserve">
          <source>The model mapper ensures that all the bar box-and-whiskers items in the box plot series have equal sizes. Therefore, adding or removing a value from a box-and-whiskers item causes the same change to be made in all the box-and-whiskers items in the box plot series.</source>
          <target state="translated">모델 맵퍼는 상자 그림 시리즈의 모든 막대 상자 수염 항목이 동일한 크기를 갖도록합니다. 따라서 상자 수염 항목에서 값을 추가하거나 제거하면 상자 그림 시리즈의 모든 상자 수염 항목에서 동일한 변경 사항이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="bc7dc0909408f70f46a22cf487b42c6733297892" translate="yes" xml:space="preserve">
          <source>The model mapper ensures that all the bar sets in the bar series have equal sizes. Therefore, adding or removing a value from a bar set causes the same change to be made in all the bar sets in the bar series.</source>
          <target state="translated">모델 매퍼는 막대 시리즈의 모든 막대 세트가 동일한 크기를 갖도록합니다. 따라서 막대 세트에서 값을 추가하거나 제거하면 막대 시리즈의 모든 막대 세트에서 동일한 변경이 이루어집니다.</target>
        </trans-unit>
        <trans-unit id="c752c3eb92bd1272be5409cf9ba200fbcdd3b374" translate="yes" xml:space="preserve">
          <source>The model mapper ensures that all the box-and-whiskers items in the box plot series have equal sizes. Therefore, adding or removing a value from a box-and-whiskers item causes the same change to be made in all the box-and-whiskers items in the box plot series.</source>
          <target state="translated">모델 매퍼는 상자 그림 시리즈의 모든 상자 및 수염 항목이 동일한 크기를 갖도록합니다. 따라서 상자 수염 항목에서 값을 추가하거나 제거하면 상자 그림 시리즈의 모든 상자 수염 항목에서 동일한 변경 사항이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="d0e853ff11d0967748a41797d03f3ad8d2a21dd8" translate="yes" xml:space="preserve">
          <source>The model mapper ensures that all the candlestick items in the candlestick series have equal sizes. Therefore, adding or removing a value from a candlestick item causes the same change to be made in all the candlestick items in the candlestick series.</source>
          <target state="translated">모델 매퍼는 촛대 시리즈의 모든 촛대 항목이 동일한 크기를 갖도록합니다. 따라서 촛대 항목에서 값을 추가하거나 제거하면 촛대 시리즈의 모든 촛대 항목에서 동일한 변경이 이루어집니다.</target>
        </trans-unit>
        <trans-unit id="34af41ec3b82ac0ebc5e7911eb152cd44e2848c1" translate="yes" xml:space="preserve">
          <source>The model may supply the value for rotation as either variant that is directly convertible to &lt;a href=&quot;qquaternion&quot;&gt;QQuaternion&lt;/a&gt;, or as one of the string representations: &lt;code&gt;&quot;scalar,x,y,z&quot;&lt;/code&gt; or &lt;code&gt;&quot;@angle,x,y,z&quot;&lt;/code&gt;. The first will construct the quaternion directly with given values, and the second one will construct the quaternion using &lt;a href=&quot;qquaternion#fromAxisAndAngle&quot;&gt;QQuaternion::fromAxisAndAngle&lt;/a&gt;() method.</source>
          <target state="translated">모델은 &lt;a href=&quot;qquaternion&quot;&gt;QQuaternion으로&lt;/a&gt; 직접 변환 가능한 변형 또는 문자열 표현 중 하나 인 &lt;code&gt;&quot;scalar,x,y,z&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;@angle,x,y,z&quot;&lt;/code&gt; 로 회전 값을 제공 할 수 있습니다 . 첫 번째는 주어진 값으로 쿼터니언을 직접 구성하고 두 번째는 &lt;a href=&quot;qquaternion#fromAxisAndAngle&quot;&gt;QQuaternion :: fromAxisAndAngle&lt;/a&gt; () 메소드를 사용하여 쿼터니언을 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="3f1511c4cb37df03e226c0ff0daca04a98f513c6" translate="yes" xml:space="preserve">
          <source>The model must also provide code to encode data in the advertised format. This is achieved by reimplementing the &lt;a href=&quot;qabstractitemmodel#mimeData&quot;&gt;QAbstractItemModel::mimeData&lt;/a&gt;() function to provide a &lt;a href=&quot;qmimedata&quot;&gt;QMimeData&lt;/a&gt; object, just as in any other drag and drop operation.</source>
          <target state="translated">모델은 또한 광고 형식으로 데이터를 인코딩하기위한 코드를 제공해야합니다. &lt;a href=&quot;qabstractitemmodel#mimeData&quot;&gt;QMimeData&lt;/a&gt; 를 제공하기 위해 QAbstractItemModel :: mimeData () 함수를 다시 구현하면 &lt;a href=&quot;qmimedata&quot;&gt;됩니다.&lt;/a&gt; 다른 드래그 앤 드롭 작업과 마찬가지로 객체 .</target>
        </trans-unit>
        <trans-unit id="ec3202fe5591a60f8cea0bedc4c203d34ff75afd" translate="yes" xml:space="preserve">
          <source>The model name of the device.</source>
          <target state="translated">장치의 모델명.</target>
        </trans-unit>
        <trans-unit id="8b4304fdf3aad1c1b797e5a72209b76b81b56bf7" translate="yes" xml:space="preserve">
          <source>The model of the camera used to capture the media.</source>
          <target state="translated">미디어를 캡처하는 데 사용되는 카메라 모델입니다.</target>
        </trans-unit>
        <trans-unit id="6f402e0e35b923865d2edbb17a952c996f065963" translate="yes" xml:space="preserve">
          <source>The model of the screen.</source>
          <target state="translated">화면의 모델입니다.</target>
        </trans-unit>
        <trans-unit id="dc582ebf925eeb320635570823d50cdd8cef85b2" translate="yes" xml:space="preserve">
          <source>The model provides a set of data that is used to create the items for a view. For large or dynamic datasets the model is usually provided by a C++ model object. The C++ model object must be a &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; subclass or a simple list.</source>
          <target state="translated">이 모델은보기 항목을 작성하는 데 사용되는 데이터 세트를 제공합니다. 크거나 동적 인 데이터 세트의 경우 모델은 일반적으로 C ++ 모델 객체에 의해 제공됩니다. C ++ 모델 오브젝트는 &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; 서브 클래스 또는 단순 목록 이어야 합니다.</target>
        </trans-unit>
        <trans-unit id="d0ebcd097c81dd05a9997c305f96405f5576736a" translate="yes" xml:space="preserve">
          <source>The model provides a set of data that is used to create the items for the view. For large or dynamic datasets the model is usually provided by a C++ model object. Models can also be created directly in QML, using the &lt;a href=&quot;qml-qtqml-models-listmodel&quot;&gt;ListModel&lt;/a&gt; type.</source>
          <target state="translated">이 모델은보기 항목을 작성하는 데 사용되는 데이터 세트를 제공합니다. 크거나 동적 인 데이터 세트의 경우 모델은 일반적으로 C ++ 모델 객체에 의해 제공됩니다. &lt;a href=&quot;qml-qtqml-models-listmodel&quot;&gt;ListModel을&lt;/a&gt; 사용하여 QML에서 직접 모델을 작성할 수도 있습니다. 유형을 .</target>
        </trans-unit>
        <trans-unit id="aadc44ddd98792a3a01e7ce5ab1213e4a59b1c25" translate="yes" xml:space="preserve">
          <source>The model provides all the standard functions of an editable model, representing the data in the string list as a model with one column and a number of rows equal to the number of items in the list.</source>
          <target state="translated">이 모델은 편집 가능한 모델의 모든 표준 기능을 제공하며, 문자열 목록의 데이터를 하나의 열과 목록의 항목 수와 동일한 행 수를 가진 모델로 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="297be0a9abccce547c762fc5cd71e264d610353e" translate="yes" xml:space="preserve">
          <source>The model provides the set of data that is displayed by the view. The &lt;a href=&quot;qml-qtquick-controls-treeview&quot;&gt;TreeView&lt;/a&gt; accept models derived from the &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; class.</source>
          <target state="translated">모델은보기로 표시되는 데이터 세트를 제공합니다. &lt;a href=&quot;qml-qtquick-controls-treeview&quot;&gt;트 리뷰는&lt;/a&gt; 으로부터 파생 모델 동의 &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel의&lt;/a&gt; 클래스를.</target>
        </trans-unit>
        <trans-unit id="5a7c5f984583f73ccb2df9de77c6d25efa2f4838" translate="yes" xml:space="preserve">
          <source>The model provides the set of data that is used to create the items in the view. Models can be created directly in QML using &lt;a href=&quot;qml-qt-labs-qmlmodels-tablemodel&quot;&gt;TableModel&lt;/a&gt;, &lt;a href=&quot;qml-qtqml-models-listmodel&quot;&gt;ListModel&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-xmllistmodel-xmllistmodel&quot;&gt;XmlListModel&lt;/a&gt;, or &lt;a href=&quot;qml-qtqml-models-objectmodel&quot;&gt;ObjectModel&lt;/a&gt;, or provided by a custom C++ model class. The C++ model must be a subclass of &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; or a simple list.</source>
          <target state="translated">모델은보기에서 항목을 작성하는 데 사용되는 데이터 세트를 제공합니다. 모델 사용 QML에서 직접 만들 수 있습니다 &lt;a href=&quot;qml-qt-labs-qmlmodels-tablemodel&quot;&gt;TableModel에&lt;/a&gt; , &lt;a href=&quot;qml-qtqml-models-listmodel&quot;&gt;의 ListModel&lt;/a&gt; , &lt;a href=&quot;qml-qtquick-xmllistmodel-xmllistmodel&quot;&gt;XmlListModel&lt;/a&gt; , 또는 &lt;a href=&quot;qml-qtqml-models-objectmodel&quot;&gt;objectModel를을&lt;/a&gt; , 또는 사용자 정의 C ++ 모델 클래스에서 제공. C ++ 모델은 &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; 의 하위 클래스 이거나 간단한 목록 이어야 합니다.</target>
        </trans-unit>
        <trans-unit id="7b0583a7a5fb4bca293b6f2543c55b297311d7ff" translate="yes" xml:space="preserve">
          <source>The model provides the set of data that is used to create the items in the view. Models can be created directly in QML using &lt;a href=&quot;qml-qtqml-models-listmodel&quot;&gt;ListModel&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-xmllistmodel-xmllistmodel&quot;&gt;XmlListModel&lt;/a&gt; or &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtquick-views-example.html#objectmodel&quot;&gt;ObjectModel&lt;/a&gt;, or provided by C++ model classes. If a C++ model class is used, it must be a subclass of &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; or a simple list.</source>
          <target state="translated">모델은보기에서 항목을 작성하는 데 사용되는 데이터 세트를 제공합니다. 모델 사용 QML에서 직접 만들어 질 수 &lt;a href=&quot;qml-qtqml-models-listmodel&quot;&gt;의 ListModel&lt;/a&gt; , &lt;a href=&quot;qml-qtquick-xmllistmodel-xmllistmodel&quot;&gt;XmlListModel&lt;/a&gt; 또는 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtquick-views-example.html#objectmodel&quot;&gt;objectModel를를&lt;/a&gt; 또는 C ++ 클래스 모델에 의해 제공. C ++ 모델 클래스가 사용되는 경우 &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; 의 서브 클래스 여야합니다. 이거나 간단한 목록 합니다.</target>
        </trans-unit>
        <trans-unit id="9e72eee64c93b0b7de836ed61542d99973158c0b" translate="yes" xml:space="preserve">
          <source>The model provides the set of data that is used to create the items in the view. Models can be created directly in QML using &lt;a href=&quot;qml-qtqml-models-listmodel&quot;&gt;ListModel&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-xmllistmodel-xmllistmodel&quot;&gt;XmlListModel&lt;/a&gt; or &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtquick-views-example.html#objectmodel&quot;&gt;ObjectModel&lt;/a&gt;, or provided by a custom C++ model class. If it is a C++ model, it must be a subclass of &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; or a simple list.</source>
          <target state="translated">모델은보기에서 항목을 작성하는 데 사용되는 데이터 세트를 제공합니다. 모델 사용 QML에서 직접 생성 할 수 &lt;a href=&quot;qml-qtqml-models-listmodel&quot;&gt;의 ListModel&lt;/a&gt; , &lt;a href=&quot;qml-qtquick-xmllistmodel-xmllistmodel&quot;&gt;XmlListModel&lt;/a&gt; 또는 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtquick-views-example.html#objectmodel&quot;&gt;objectModel를을&lt;/a&gt; , 또는 사용자 정의 C ++ 모델 클래스에서 제공. C ++ 모델 인 경우 &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; 의 서브 클래스 이거나 간단한 목록 이어야 합니다.</target>
        </trans-unit>
        <trans-unit id="9dde862028630a9a30772af0be0fb2eaf84c4bc5" translate="yes" xml:space="preserve">
          <source>The model provides the set of data that is used to create the items in the view. Models can be created directly in QML using &lt;a href=&quot;qml-qtqml-models-listmodel&quot;&gt;ListModel&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-xmllistmodel-xmllistmodel&quot;&gt;XmlListModel&lt;/a&gt; or &lt;a href=&quot;qml-qtqml-models-objectmodel&quot;&gt;ObjectModel&lt;/a&gt;, or provided by C++ model classes. If a C++ model class is used, it must be a subclass of &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; or a simple list.</source>
          <target state="translated">모델은보기에서 항목을 작성하는 데 사용되는 데이터 세트를 제공합니다. 모델 사용 QML에서 직접 만들어 질 수 &lt;a href=&quot;qml-qtqml-models-listmodel&quot;&gt;의 ListModel&lt;/a&gt; , &lt;a href=&quot;qml-qtquick-xmllistmodel-xmllistmodel&quot;&gt;XmlListModel&lt;/a&gt; 또는 &lt;a href=&quot;qml-qtqml-models-objectmodel&quot;&gt;objectModel를를&lt;/a&gt; 또는 C ++ 클래스 모델에 의해 제공. C ++ 모델 클래스가 사용되는 경우 &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; 의 하위 클래스 또는 단순 목록 이어야 합니다.</target>
        </trans-unit>
        <trans-unit id="34d465571c4c53fdbf72c4af02dd6efb75002bb4" translate="yes" xml:space="preserve">
          <source>The model provides the set of data that is used to create the items in the view. Models can be created directly in QML using &lt;a href=&quot;qml-qtqml-models-listmodel&quot;&gt;ListModel&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-xmllistmodel-xmllistmodel&quot;&gt;XmlListModel&lt;/a&gt;, &lt;a href=&quot;qml-qtqml-models-delegatemodel&quot;&gt;DelegateModel&lt;/a&gt;, or &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtquick-views-example.html#objectmodel&quot;&gt;ObjectModel&lt;/a&gt;, or provided by C++ model classes. If a C++ model class is used, it must be a subclass of &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; or a simple list.</source>
          <target state="translated">모델은보기에서 항목을 작성하는 데 사용되는 데이터 세트를 제공합니다. 모델 사용 QML에서 직접 만들어 질 수 &lt;a href=&quot;qml-qtqml-models-listmodel&quot;&gt;의 ListModel&lt;/a&gt; , &lt;a href=&quot;qml-qtquick-xmllistmodel-xmllistmodel&quot;&gt;XmlListModel&lt;/a&gt; , &lt;a href=&quot;qml-qtqml-models-delegatemodel&quot;&gt;DelegateModel&lt;/a&gt; 또는 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtquick-views-example.html#objectmodel&quot;&gt;objectModel를를&lt;/a&gt; 또는 C ++ 클래스 모델에 의해 제공. C ++ 모델 클래스가 사용되는 경우 &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; 의 서브 클래스 여야합니다. 이거나 간단한 목록 합니다.</target>
        </trans-unit>
        <trans-unit id="454a4f9406690875330acd0b86e243a581904f77" translate="yes" xml:space="preserve">
          <source>The model provides the set of data that is used to create the items in the view. Models can be created directly in QML using &lt;a href=&quot;qml-qtqml-models-listmodel&quot;&gt;ListModel&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-xmllistmodel-xmllistmodel&quot;&gt;XmlListModel&lt;/a&gt;, &lt;a href=&quot;qml-qtqml-models-delegatemodel&quot;&gt;DelegateModel&lt;/a&gt;, or &lt;a href=&quot;qml-qtqml-models-objectmodel&quot;&gt;ObjectModel&lt;/a&gt;, or provided by C++ model classes. If a C++ model class is used, it must be a subclass of &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; or a simple list.</source>
          <target state="translated">모델은보기에서 항목을 작성하는 데 사용되는 데이터 세트를 제공합니다. 모델 사용 QML에서 직접 만들어 질 수 &lt;a href=&quot;qml-qtqml-models-listmodel&quot;&gt;의 ListModel&lt;/a&gt; , &lt;a href=&quot;qml-qtquick-xmllistmodel-xmllistmodel&quot;&gt;XmlListModel&lt;/a&gt; , &lt;a href=&quot;qml-qtqml-models-delegatemodel&quot;&gt;DelegateModel&lt;/a&gt; 또는 &lt;a href=&quot;qml-qtqml-models-objectmodel&quot;&gt;objectModel를를&lt;/a&gt; 또는 C ++ 클래스 모델에 의해 제공. C ++ 모델 클래스가 사용되는 경우 &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; 의 하위 클래스 또는 단순 목록 이어야 합니다.</target>
        </trans-unit>
        <trans-unit id="9237759413ea11cf68c266f4f885d45ee50e3929" translate="yes" xml:space="preserve">
          <source>The model provides the set of data that is used to create the items in the view. Models can be created directly in QML using &lt;a href=&quot;qml-qtqml-models-listmodel&quot;&gt;ListModel&lt;/a&gt;, XmlListModel or VisualItemModel, or provided by C++ model classes.</source>
          <target state="translated">모델은보기에서 항목을 작성하는 데 사용되는 데이터 세트를 제공합니다. 모델은 &lt;a href=&quot;qml-qtqml-models-listmodel&quot;&gt;ListModel&lt;/a&gt; , XmlListModel 또는 VisualItemModel을 사용하여 QML에서 직접 작성 하거나 C ++ 모델 클래스에서 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fc030404d9114242afd267b89ebaee31b307c2f2" translate="yes" xml:space="preserve">
          <source>The model provides the set of data that is used to create the items in the view. Models can be created directly in QML using ListModel, XmlListModel or VisualItemModel, or provided by C++ model classes.</source>
          <target state="translated">모델은보기에서 항목을 작성하는 데 사용되는 데이터 세트를 제공합니다. 모델은 ListModel, XmlListModel 또는 VisualItemModel을 사용하여 QML에서 직접 생성하거나 C ++ 모델 클래스에서 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b0b50ca12213c32ecc63c7fe68a6f19b4b554af0" translate="yes" xml:space="preserve">
          <source>The model providing data for the repeater.</source>
          <target state="translated">리피터에 대한 데이터를 제공하는 모델입니다.</target>
        </trans-unit>
        <trans-unit id="f2f0c110f48d902839c45eb4bc9eb2fbd4e70e11" translate="yes" xml:space="preserve">
          <source>The model returns data for the following roles:</source>
          <target state="translated">모델은 다음 역할에 대한 데이터를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3eb0a95a24c3de85047536337e667aecf13d09bd" translate="yes" xml:space="preserve">
          <source>The model role used for populating the &lt;a href=&quot;qml-qtquick-controls-combobox&quot;&gt;ComboBox&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-controls-combobox&quot;&gt;ComboBox&lt;/a&gt; 를 채우는 데 사용되는 모델 역할 입니다.</target>
        </trans-unit>
        <trans-unit id="40db7d63c8b82bd61bb431a978e7a01f4fd58e37" translate="yes" xml:space="preserve">
          <source>The model roles</source>
          <target state="translated">모델 역할</target>
        </trans-unit>
        <trans-unit id="e28973ebd5a80df1e5e5fbec575f4ad2349f2d3f" translate="yes" xml:space="preserve">
          <source>The model roles provided by &lt;a href=&quot;qml-qtbluetooth-bluetoothdiscoverymodel&quot;&gt;BluetoothDiscoveryModel&lt;/a&gt; are &lt;code&gt;service&lt;/code&gt;, &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;remoteAddress&lt;/code&gt; and &lt;code&gt;deviceName&lt;/code&gt;. The meaning of the roles changes based on the current &lt;a href=&quot;qml-qtbluetooth-bluetoothdiscoverymodel#discoveryMode-prop&quot;&gt;discoveryMode&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qml-qtbluetooth-bluetoothdiscoverymodel&quot;&gt;BluetoothDiscoveryModel에서&lt;/a&gt; 제공하는 모델 역할 은 &lt;code&gt;service&lt;/code&gt; , &lt;code&gt;name&lt;/code&gt; , &lt;code&gt;remoteAddress&lt;/code&gt; 및 &lt;code&gt;deviceName&lt;/code&gt; 입니다. 현재 &lt;a href=&quot;qml-qtbluetooth-bluetoothdiscoverymodel#discoveryMode-prop&quot;&gt;discoveryMode&lt;/a&gt; 에 따라 역할의 의미가 변경됩니다. 됩니다.</target>
        </trans-unit>
        <trans-unit id="424a992c17c3211dd2405215b953396b20ddcf7f" translate="yes" xml:space="preserve">
          <source>The model roles provided by BluetoothDiscoveryModel are &lt;code&gt;service&lt;/code&gt;, &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;remoteAddress&lt;/code&gt; and &lt;code&gt;deviceName&lt;/code&gt;. The meaning of the roles changes based on the current &lt;a href=&quot;qml-qtbluetooth-bluetoothdiscoverymodel#discoveryMode-prop&quot;&gt;discoveryMode&lt;/a&gt;.</source>
          <target state="translated">BluetoothDiscoveryModel에서 제공하는 모델 역할은 &lt;code&gt;service&lt;/code&gt; , &lt;code&gt;name&lt;/code&gt; , &lt;code&gt;remoteAddress&lt;/code&gt; 및 &lt;code&gt;deviceName&lt;/code&gt; 입니다. 역할의 의미는 현재 &lt;a href=&quot;qml-qtbluetooth-bluetoothdiscoverymodel#discoveryMode-prop&quot;&gt;discoveryMode&lt;/a&gt; 에 따라 변경 됩니다.</target>
        </trans-unit>
        <trans-unit id="be6176ea1f21b82c7ed425d8c8ba539548bfa69a" translate="yes" xml:space="preserve">
          <source>The model supports the following roles:</source>
          <target state="translated">이 모델은 다음 역할을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="16b024a8ea8d5cdeb6eba00afdb74c74394eb615" translate="yes" xml:space="preserve">
          <source>The model to populate the &lt;a href=&quot;qml-qtquick-controls-combobox&quot;&gt;ComboBox&lt;/a&gt; from.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-controls-combobox&quot;&gt;ComboBox&lt;/a&gt; 를 채울 모델 입니다.</target>
        </trans-unit>
        <trans-unit id="5559116810fc3eb4cb2765c790b696f16fd7140a" translate="yes" xml:space="preserve">
          <source>The model's initial row data is set with either the &lt;a href=&quot;qml-qt-labs-qmlmodels-tablemodel#rows-prop&quot;&gt;rows&lt;/a&gt; property or by calling &lt;a href=&quot;qml-qt-labs-qmlmodels-tablemodel#appendRow-method&quot;&gt;appendRow()&lt;/a&gt;. Each column in the model is specified by declaring a &lt;a href=&quot;qml-qt-labs-qmlmodels-tablemodelcolumn&quot;&gt;TableModelColumn&lt;/a&gt; instance, where the order of each instance determines its column index. Once the model's &lt;a href=&quot;qml-qtqml-component#completed-signal&quot;&gt;Component::completed()&lt;/a&gt; signal has been emitted, the columns and roles will have been established and are then fixed for the lifetime of the model.</source>
          <target state="translated">모델의 초기 행 데이터는 &lt;a href=&quot;qml-qt-labs-qmlmodels-tablemodel#rows-prop&quot;&gt;rows&lt;/a&gt; 속성을 사용하거나 &lt;a href=&quot;qml-qt-labs-qmlmodels-tablemodel#appendRow-method&quot;&gt;appendRow ()&lt;/a&gt; 를 호출 하여 설정됩니다 . 모델의 각 열은 &lt;a href=&quot;qml-qt-labs-qmlmodels-tablemodelcolumn&quot;&gt;TableModelColumn&lt;/a&gt; 인스턴스 를 선언하여 지정되며 각 인스턴스의 순서에 따라 열 인덱스가 결정됩니다. 모델의 &lt;a href=&quot;qml-qtqml-component#completed-signal&quot;&gt;Component :: completed ()&lt;/a&gt; 신호가 방출되면 열과 역할이 설정되고 모델의 수명 동안 고정됩니다.</target>
        </trans-unit>
        <trans-unit id="70cb6fccdcd63c0527822267dcf8a1ed3d6d5010" translate="yes" xml:space="preserve">
          <source>The model/view architecture</source>
          <target state="translated">모델 / 뷰 아키텍처</target>
        </trans-unit>
        <trans-unit id="62a0f47dd83a7158c3d5d1f499a47880505a0601" translate="yes" xml:space="preserve">
          <source>The model/view architecture ensures that the contents of the tree view are updated as the model changes.</source>
          <target state="translated">모델 / 뷰 아키텍처는 모델이 변경 될 때 트리 뷰의 내용이 업데이트되도록합니다.</target>
        </trans-unit>
        <trans-unit id="c70b036c7a854467c85ffbbc2747471829c51972" translate="yes" xml:space="preserve">
          <source>The model/view classes support drag and drop operations, providing default behavior that is sufficient for many applications. However, it is also possible to customize the way items are encoded during drag and drop operations, whether they are copied or moved by default, and how they are inserted into existing models.</source>
          <target state="translated">모델 / 뷰 클래스는 드래그 앤 드롭 작업을 지원하여 많은 응용 프로그램에 충분한 기본 동작을 제공합니다. 그러나 끌어서 놓기 작업 중에 항목이 기본적으로 복사 또는 이동되는지 여부와 항목이 기존 모델에 삽입되는 방식에 따라 항목이 인코딩되는 방식을 사용자 정의 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="50e26cf81aa5927dc4862f4625dae0208d751d43" translate="yes" xml:space="preserve">
          <source>The modified flag is never read by &lt;a href=&quot;qlineedit&quot;&gt;QLineEdit&lt;/a&gt;; it has a default value of false and is changed to true whenever the user changes the line edit's contents.</source>
          <target state="translated">수정 된 플래그는 &lt;a href=&quot;qlineedit&quot;&gt;QLineEdit에서&lt;/a&gt; 읽지 않습니다 . 기본값은 false이며 사용자가 행 편집의 내용을 변경할 때마다 true로 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="5493947eaa76269a307233c0db43e6c1ca2ea3d8" translate="yes" xml:space="preserve">
          <source>The module also provides the framework for running QML applications. The QML framework allows QML code to contain JavaScript expressions and for the QML code to interact with C++ code.</source>
          <target state="translated">이 모듈은 또한 QML 애플리케이션을 실행하기위한 프레임 워크를 제공합니다. QML 프레임 워크를 통해 QML 코드는 JavaScript 표현식을 포함하고 QML 코드는 C ++ 코드와 상호 작용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="917beaf604c5a16cf1487203bb394e8c30910958" translate="yes" xml:space="preserve">
          <source>The module consists of six classes</source>
          <target state="translated">이 모듈은 6 개의 클래스로 구성됩니다</target>
        </trans-unit>
        <trans-unit id="4d258b524a4d5af69764b8cf1e9db1754a56160a" translate="yes" xml:space="preserve">
          <source>The module depends on Speech Dispatcher (libspeechd) on the Linux platform. On other platforms, it uses the native APIs to access the platform-specific text-to-speech engines.</source>
          <target state="translated">이 모듈은 Linux 플랫폼의 Speech Dispatcher (libspeechd)에 의존합니다. 다른 플랫폼에서는 고유 API를 사용하여 플랫폼 별 텍스트 음성 변환 엔진에 액세스합니다.</target>
        </trans-unit>
        <trans-unit id="49f6ce41863bfa09f4652674b59ae76a5d954da6" translate="yes" xml:space="preserve">
          <source>The module enables a Qt application to support accessibility features such as text-to-speech, which is useful for end-users who are visually challenged or cannot access the application for whatever reason. The most common use case where text-to-speech comes in handy is when the end-user is driving and cannot attend the incoming messages on the phone. In such a scenario, the messaging application can read out the incoming message.</source>
          <target state="translated">이 모듈을 통해 Qt 애플리케이션은 텍스트 음성 변환과 같은 접근성 기능을 지원할 수 있으며, 이는 시각적으로 문제가 있거나 어떤 이유로 든 애플리케이션에 액세스 할 수없는 최종 사용자에게 유용합니다. TTS (텍스트 음성 변환)가 유용한 가장 일반적인 사용 사례는 최종 사용자가 운전 중이고 전화로 들어오는 메시지에 참석할 수없는 경우입니다. 이러한 시나리오에서 메시징 응용 프로그램은 들어오는 메시지를 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="de50724900bd00bea051607250cc2838fbeef37f" translate="yes" xml:space="preserve">
          <source>The module is new in Qt 5.1 and requires &lt;a href=&quot;qtquick-index&quot;&gt;Qt Quick&lt;/a&gt; 2.1.</source>
          <target state="translated">이 모듈은 Qt 5.1의 새로운 기능이며 &lt;a href=&quot;qtquick-index&quot;&gt;Qt Quick&lt;/a&gt; 2.1이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="6de61c3340c46ec86e251f313ffd5776859732be" translate="yes" xml:space="preserve">
          <source>The module is new in Qt 5.1 and requires &lt;a href=&quot;qtquick-index#&quot;&gt;Qt Quick&lt;/a&gt; 2.1.</source>
          <target state="translated">이 모듈은 Qt 5.1의 새로운 기능이며 &lt;a href=&quot;qtquick-index#&quot;&gt;Qt Quick&lt;/a&gt; 2.1이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="f0b2ef1d0e3d44a455913dd08c4b211efe67b6d6" translate="yes" xml:space="preserve">
          <source>The module needs to be imported in the application:</source>
          <target state="translated">모듈은 애플리케이션에서 가져와야합니다.</target>
        </trans-unit>
        <trans-unit id="a54bd2f11634166e3df7c4ab847aef27d1d30756" translate="yes" xml:space="preserve">
          <source>The module provides a JavaScript library for seamless integration of C++ and QML applications with HTML/JavaScript and QML clients. The clients must use the JavaScript library to access the serialized QObjects published by the host applications.</source>
          <target state="translated">이 모듈은 C ++ 및 QML 애플리케이션과 HTML / JavaScript 및 QML 클라이언트와의 완벽한 통합을위한 JavaScript 라이브러리를 제공합니다. 클라이언트는 JavaScript 라이브러리를 사용하여 호스트 응용 프로그램이 게시 한 직렬화 된 QObject에 액세스해야합니다.</target>
        </trans-unit>
        <trans-unit id="5d371e8b797731021770b40733784fdb00abc3ea" translate="yes" xml:space="preserve">
          <source>The module provides a single QML component for displaying web content in the application: &lt;a href=&quot;qml-qtwebview-webview&quot;&gt;WebView&lt;/a&gt;.</source>
          <target state="translated">이 모듈은 애플리케이션에 웹 컨텐츠를 표시하기위한 단일 QML 구성 요소를 제공합니다 : &lt;a href=&quot;qml-qtwebview-webview&quot;&gt;WebView&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="46f3e294357111e08c52d8cece6ee6b1cdd01d7d" translate="yes" xml:space="preserve">
          <source>The module provides the QML and C++ alternatives for maps and navigation. The C++ alternative provides utility classes to get geocoding (finding a geographic coordinate from a street address) and navigation (including driving and walking directions) information, whereas its QML counterpart provides UI components to render the information.</source>
          <target state="translated">이 모듈은지도 및 탐색을위한 QML 및 C ++ 대안을 제공합니다. C ++ 대안은 지오 코딩 (거리 주소에서 지리적 좌표 찾기) 및 탐색 (운전 및 도보 경로 포함) 정보를 가져 오는 유틸리티 클래스를 제공하는 반면 QML 파트는 정보를 렌더링하는 UI 구성 요소를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="72660e57600d1d85ddab9251aa5a2a89031e37c9" translate="yes" xml:space="preserve">
          <source>The module provides the following &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtwebsockets-examples.html&quot;&gt;Examples&lt;/a&gt; as a guide to using the API.</source>
          <target state="translated">이 모듈은 API 사용에 대한 안내서로 다음 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtwebsockets-examples.html&quot;&gt;예&lt;/a&gt; 를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="2ce41dd87769ed954a5b387c74139f59e5275841" translate="yes" xml:space="preserve">
          <source>The module provides the following &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtwebsockets-examples.html&quot;&gt;Examples&lt;/a&gt; as a guide to using the API.</source>
          <target state="translated">이 모듈은 API 사용에 대한 가이드로 다음 &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtwebsockets-examples.html&quot;&gt;예제&lt;/a&gt; 를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="3e58dbd9dc2c2fff7b76c4097d14526163084211" translate="yes" xml:space="preserve">
          <source>The module was introduced in Qt 5.1.</source>
          <target state="translated">이 모듈은 Qt 5.1에 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="b28b347c2b824f815d8969d2cd4711cf79f8e694" translate="yes" xml:space="preserve">
          <source>The module was introduced in Qt 5.5.</source>
          <target state="translated">이 모듈은 Qt 5.5에 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="07d66bb5ba854a78169a507ba00574f07829273f" translate="yes" xml:space="preserve">
          <source>The module's documentation will likely contain HTML links to the documentation of one or more of the other Qt modules. For example, most Qt5 modules contain links to documentation in &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtcore-module.html&quot;&gt;QtCore&lt;/a&gt;. When a Qt module contains links into the documentation of other Qt module's, that module is said to depend on those other Qt modules. Hence when QDoc runs the</source>
          <target state="translated">모듈의 문서에는 하나 이상의 다른 Qt 모듈의 문서에 대한 HTML 링크가 포함되어있을 것입니다. 예를 들어, 대부분의 Qt5 모듈에는 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtcore-module.html&quot;&gt;QtCore의&lt;/a&gt; 문서에 대한 링크가 포함되어 있습니다 . Qt 모듈에 다른 Qt 모듈의 문서에 대한 링크가 포함 된 경우 해당 모듈은 다른 Qt 모듈에 의존한다고합니다. 따라서 QDoc이 실행될 때</target>
        </trans-unit>
        <trans-unit id="f196fc6634a9648745b9aa13e8faba42cca15e49" translate="yes" xml:space="preserve">
          <source>The module's documentation will likely contain HTML links to the documentation of one or more of the other Qt modules. For example, most Qt5 modules contain links to documentation in &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtcore-module.html&quot;&gt;QtCore&lt;/a&gt;. When a Qt module contains links into the documentation of other Qt module's, that module is said to depend on those other Qt modules. Hence when QDoc runs the</source>
          <target state="translated">모듈의 문서에는 하나 이상의 다른 Qt 모듈의 문서에 대한 HTML 링크가 포함될 수 있습니다. 예를 들어 대부분의 Qt5 모듈에는 &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtcore-module.html&quot;&gt;QtCore&lt;/a&gt; 문서에 대한 링크가 포함되어 있습니다 . Qt 모듈에 다른 Qt 모듈의 문서에 대한 링크가 포함되어 있으면 해당 모듈은 다른 Qt 모듈에 의존한다고합니다. 따라서 QDoc이</target>
        </trans-unit>
        <trans-unit id="8a76bd8d890bd76ade398768bbe72c3716fb3e10" translate="yes" xml:space="preserve">
          <source>The month as a number with a leading zero (01 to 12)</source>
          <target state="translated">앞에 0이있는 숫자로 표시되는 월 (01-12)</target>
        </trans-unit>
        <trans-unit id="dd32c875b4eab5b826b21d0e23e146962b85613e" translate="yes" xml:space="preserve">
          <source>The month as a number without a leading zero (1 to 12)</source>
          <target state="translated">앞에 0이없는 숫자로 표시되는 월 (1-12)</target>
        </trans-unit>
        <trans-unit id="e2f4bab1eca02b78c9a805b490b8c2d46711feda" translate="yes" xml:space="preserve">
          <source>The month is from &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;11&lt;/code&gt; to be consistent with the JavaScript Date object.</source>
          <target state="translated">JavaScript Date 객체와 일치 하는 달은 &lt;code&gt;0&lt;/code&gt; 에서 &lt;code&gt;11&lt;/code&gt; 사이입니다.</target>
        </trans-unit>
        <trans-unit id="42cf033a14b9e175bbb05961fc6fcd218aa4a1a3" translate="yes" xml:space="preserve">
          <source>The month is indicated by a number, with</source>
          <target state="translated">월은 숫자로 표시되며</target>
        </trans-unit>
        <trans-unit id="6ef021073bd7ebee52cec36d7b8531187f370eb2" translate="yes" xml:space="preserve">
          <source>The mood of the media.</source>
          <target state="translated">미디어의 분위기.</target>
        </trans-unit>
        <trans-unit id="077dd1b686b2885e09dff389e1899a9c1a9e370b" translate="yes" xml:space="preserve">
          <source>The most basic use case for a &lt;a href=&quot;qml-qtquick-dialogs-messagedialog&quot;&gt;MessageDialog&lt;/a&gt; is a popup alert. It also allows the user to respond in various ways depending on which buttons are enabled. The dialog is initially invisible. You need to set the properties as desired first, then set &lt;a href=&quot;qml-qtquick-dialogs-messagedialog#visible-prop&quot;&gt;visible&lt;/a&gt; to &lt;code&gt;true&lt;/code&gt; or call &lt;a href=&quot;qml-qtquick-dialogs-messagedialog#open-method&quot;&gt;open()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-dialogs-messagedialog&quot;&gt;MessageDialog&lt;/a&gt; 의 가장 기본적인 사용 사례 는 팝업 경고입니다. 또한 사용자가 활성화 된 버튼에 따라 다양한 방식으로 응답 할 수 있습니다. 대화 상자는 처음에는 보이지 않습니다. 먼저 원하는대로 속성을 설정 한 다음 &lt;a href=&quot;qml-qtquick-dialogs-messagedialog#visible-prop&quot;&gt;visible&lt;/a&gt; 을 &lt;code&gt;true&lt;/code&gt; 로 설정 하거나 &lt;a href=&quot;qml-qtquick-dialogs-messagedialog#open-method&quot;&gt;open ()을&lt;/a&gt; 호출 해야 합니다 .</target>
        </trans-unit>
        <trans-unit id="61c59f9a3fcf47ec091724d9d09b34c015954245" translate="yes" xml:space="preserve">
          <source>The most basic use case for a MessageDialog is a popup alert. It also allows the user to respond in various ways depending on which buttons are enabled. The dialog is initially invisible. You need to set the properties as desired first, then set &lt;a href=&quot;qml-qtquick-dialogs-messagedialog#visible-prop&quot;&gt;visible&lt;/a&gt; to &lt;code&gt;true&lt;/code&gt; or call &lt;a href=&quot;qml-qtquick-dialogs-messagedialog#open-method&quot;&gt;open()&lt;/a&gt;.</source>
          <target state="translated">MessageDialog의 가장 기본적인 사용 사례는 팝업 경고입니다. 또한 활성화 된 버튼에 따라 사용자가 다양한 방식으로 응답 할 수 있습니다. 대화 상자는 처음에는 보이지 않습니다. 먼저 원하는대로 속성을 설정 한 다음 &lt;a href=&quot;qml-qtquick-dialogs-messagedialog#visible-prop&quot;&gt;visible&lt;/a&gt; 을 &lt;code&gt;true&lt;/code&gt; 로 설정 하거나 &lt;a href=&quot;qml-qtquick-dialogs-messagedialog#open-method&quot;&gt;open ()을&lt;/a&gt; 호출 해야 합니다 .</target>
        </trans-unit>
        <trans-unit id="8a63e14c4cba98494a9dcd62a1c22b5ce094d95b" translate="yes" xml:space="preserve">
          <source>The most common and best supported use case for a multi-screen setup is to open a dedicated &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt; or &lt;a href=&quot;qquickview&quot;&gt;QQuickView&lt;/a&gt; for each screen. With the default &lt;code&gt;threaded&lt;/code&gt; render loop of the Qt Quick scenegraph, each of these windows will get its own dedicated render thread. This is good because the threads can be throttled independently based on vsync, and will not interfere with each other. With the &lt;code&gt;basic&lt;/code&gt; loop this can get problematic and animations may degrade as a result.</source>
          <target state="translated">멀티 스크린 설정에서 가장 일반적으로 지원되는 유스 케이스 는 각 화면에 대해 전용 &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt; 또는 &lt;a href=&quot;qquickview&quot;&gt;QQuickView&lt;/a&gt; 를 여는 것입니다 . Qt Quick 장면 그래프 의 기본 &lt;code&gt;threaded&lt;/code&gt; 렌더링 루프를 사용하면 이러한 각 창마다 고유의 전용 렌더링 스레드가 제공됩니다. 스레드는 vsync를 기반으로 독립적으로 조절할 수 있으며 서로 방해하지 않기 때문에 좋습니다. &lt;code&gt;basic&lt;/code&gt; 루프를 사용하면 문제가 발생할 수 있으며 결과적으로 애니메이션이 저하 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="280359ae1bd9828fce836d308e4f59fe3eaebe51" translate="yes" xml:space="preserve">
          <source>The most common and best supported use case for a multi-screen setup is to open a dedicated &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt; or &lt;a href=&quot;qquickview&quot;&gt;QQuickView&lt;/a&gt; for each screen. With the default &lt;code&gt;threaded&lt;/code&gt; render loop of the Qt Quick scenegraph, each of these windows will get its own dedicated render thread. This is good because the threads can be throttled independently based on vsync, and will not interfere with each other. With the &lt;code&gt;basic&lt;/code&gt; loop this can get problematic, causing animations to degrade.</source>
          <target state="translated">다중 화면 설정에 대해 가장 일반적이고 가장 잘 지원되는 사용 사례 는 각 화면에 대해 전용 &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt; 또는 &lt;a href=&quot;qquickview&quot;&gt;QQuickView&lt;/a&gt; 를 여는 것입니다 . Qt Quick 장면 그래프 의 기본 &lt;code&gt;threaded&lt;/code&gt; 렌더링 루프를 사용하면 이러한 각 창에 자체 전용 렌더링 스레드가 있습니다. 이것은 스레드가 vsync를 기반으로 독립적으로 조절 될 수 있고 서로 간섭하지 않기 때문에 좋습니다. &lt;code&gt;basic&lt;/code&gt; 루프를 사용하면 문제가 발생하여 애니메이션이 저하 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7002e0bca2cef5b9d2b7e2159b7b15a9701c9f5a" translate="yes" xml:space="preserve">
          <source>The most common cause of this bug is failure to declare one or more namespaces in your &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt;. Consider the following query for selecting all the examples in an XHTML document:</source>
          <target state="translated">이 버그의 가장 일반적인 원인은 &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt; 에서 하나 이상의 네임 스페이스를 선언하지 못하는 것 입니다. XHTML 문서의 모든 예제를 선택하려면 다음 쿼리를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="f656449d0ed9f3552f33eaf84e576568f588422d" translate="yes" xml:space="preserve">
          <source>The most common cause of this bug is failure to declare one or more namespaces in your &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt;. Consider the following query for selecting all the examples in an XHTML document:</source>
          <target state="translated">이 버그의 가장 일반적인 원인은 &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt; 에서 하나 이상의 네임 스페이스를 선언하지 못했기 때문입니다 . XHTML 문서에서 모든 예제를 선택하려면 다음 쿼리를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="503116ce121862f819a10cd5285bfb76ee2e76e1" translate="yes" xml:space="preserve">
          <source>The most common kind of path step is called an</source>
          <target state="translated">가장 일반적인 종류의 경로 단계는</target>
        </trans-unit>
        <trans-unit id="4d77885bbfd5cd4c32570c4908fb5d6c19f66ce2" translate="yes" xml:space="preserve">
          <source>The most common setting is &lt;a href=&quot;qlineedit#EchoMode-enum&quot;&gt;Normal&lt;/a&gt;, in which the text entered by the user is displayed verbatim, but &lt;a href=&quot;qlineedit&quot;&gt;QLineEdit&lt;/a&gt; also supports modes that allow the entered text to be suppressed or obscured: these include &lt;a href=&quot;qlineedit#EchoMode-enum&quot;&gt;NoEcho&lt;/a&gt;, &lt;a href=&quot;qlineedit#EchoMode-enum&quot;&gt;Password&lt;/a&gt; and &lt;a href=&quot;qlineedit#EchoMode-enum&quot;&gt;PasswordEchoOnEdit&lt;/a&gt;.</source>
          <target state="translated">가장 일반적인 설정은 &lt;a href=&quot;qlineedit#EchoMode-enum&quot;&gt;보통&lt;/a&gt; 이며 사용자가 입력 한 텍스트는 그대로 표시되지만 &lt;a href=&quot;qlineedit&quot;&gt;QLineEdit&lt;/a&gt; 은 입력 한 텍스트를 표시하지 않거나 숨길 수있는 모드도 지원합니다 ( &lt;a href=&quot;qlineedit#EchoMode-enum&quot;&gt;NoEcho&lt;/a&gt; , &lt;a href=&quot;qlineedit#EchoMode-enum&quot;&gt;Password&lt;/a&gt; 및 &lt;a href=&quot;qlineedit#EchoMode-enum&quot;&gt;PasswordEchoOnEdit 포함)&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bc1164e6c9b01688e13a86107452cb802d3f75f6" translate="yes" xml:space="preserve">
          <source>The most common type is SourceOver (often referred to as just alpha blending) where the source pixel is blended on top of the destination pixel in such a way that the alpha component of the source defines the translucency of the pixel.</source>
          <target state="translated">가장 일반적인 유형은 소스의 알파 구성 요소가 픽셀의 반투명도를 정의하는 방식으로 소스 픽셀이 대상 픽셀 위에 블렌딩되는 SourceOver (종종 알파 블렌딩이라고 함)입니다.</target>
        </trans-unit>
        <trans-unit id="7ebe8712af9de8113597b89bbd1296a0e6f7eb1c" translate="yes" xml:space="preserve">
          <source>The most common type of import is a module import. Clients can import &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtqml-modules-identifiedmodules.html#&quot;&gt;QML modules&lt;/a&gt; which register QML object types and JavaScript resources into a given namespace.</source>
          <target state="translated">가장 일반적인 유형의 가져 오기는 모듈 가져 오기입니다. 클라이언트는 QML 객체 유형과 JavaScript 리소스를 지정된 네임 스페이스로 등록하는 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtqml-modules-identifiedmodules.html#&quot;&gt;QML 모듈&lt;/a&gt; 을 가져올 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9afc99db1430fce10925ca97a6a859f7a06dd573" translate="yes" xml:space="preserve">
          <source>The most common type of import is a module import. Clients can import &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtqml-modules-identifiedmodules.html&quot;&gt;QML modules&lt;/a&gt; which register QML object types and JavaScript resources into a given namespace.</source>
          <target state="translated">가장 일반적인 가져 오기 유형은 모듈 가져 오기입니다. 클라이언트는 QML 객체 유형 및 JavaScript 리소스를 지정된 네임 스페이스에 등록하는 &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtqml-modules-identifiedmodules.html&quot;&gt;QML 모듈&lt;/a&gt; 을 가져올 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="19e8cc1e1548bf4247b9a91f81cd7e7c2ef02f82" translate="yes" xml:space="preserve">
          <source>The most common usage is to show a splash screen before the main widget is displayed on the screen. This is illustrated in the following code snippet in which a splash screen is displayed and some initialization tasks are performed before the application's main window is shown:</source>
          <target state="translated">가장 일반적인 사용법은 메인 위젯이 화면에 표시되기 전에 스플래시 화면을 표시하는 것입니다. 이는 스플래시 화면이 표시되고 응용 프로그램의 기본 창이 표시되기 전에 일부 초기화 작업이 수행되는 다음 코드 스 니펫에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe1babbc64ab8d5ff5a5c1ab2f52cc87b943cc26" translate="yes" xml:space="preserve">
          <source>The most common use of &lt;a href=&quot;qtranslator&quot;&gt;QTranslator&lt;/a&gt; is to: load a translation file, install it using &lt;a href=&quot;qcoreapplication#installTranslator&quot;&gt;QCoreApplication::installTranslator&lt;/a&gt;(), and use it via &lt;a href=&quot;qobject#tr&quot;&gt;QObject::tr&lt;/a&gt;(). Here's an example &lt;code&gt;main()&lt;/code&gt; function using the &lt;a href=&quot;qtranslator&quot;&gt;QTranslator&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;qtranslator&quot;&gt;QTranslator&lt;/a&gt; 의 가장 일반적인 용도 는 다음과 같습니다. 번역 파일을로드하고 &lt;a href=&quot;qcoreapplication#installTranslator&quot;&gt;QCoreApplication :: installTranslator&lt;/a&gt; ()를 사용하여 설치 한 후 &lt;a href=&quot;qobject#tr&quot;&gt;QObject :: tr&lt;/a&gt; ()을 통해 사용합니다 . 다음 은 &lt;a href=&quot;qtranslator&quot;&gt;QTranslator를&lt;/a&gt; 사용하는 &lt;code&gt;main()&lt;/code&gt; 함수 의 예입니다 .</target>
        </trans-unit>
        <trans-unit id="5aa2ec5b2b2c793786fc0e243a19e708a0692f4e" translate="yes" xml:space="preserve">
          <source>The most common use of QTranslator is to: load a translation file, and install it using &lt;a href=&quot;qcoreapplication#installTranslator&quot;&gt;QCoreApplication::installTranslator&lt;/a&gt;().</source>
          <target state="translated">QTranslator의 가장 일반적인 용도는 번역 파일을로드하고 &lt;a href=&quot;qcoreapplication#installTranslator&quot;&gt;QCoreApplication :: installTranslator&lt;/a&gt; ()를 사용하여 설치하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="0e625a517c3c200d2aff0b195a3b46e5f1b9a725" translate="yes" xml:space="preserve">
          <source>The most common use of the \inlineimage command is in lists and tables. Here is an example of including inline images in a list:</source>
          <target state="translated">\ inlineimage 명령의 가장 일반적인 사용은 목록과 테이블입니다. 다음은 목록에 인라인 이미지를 포함시키는 예입니다.</target>
        </trans-unit>
        <trans-unit id="d2ad20a71cc2cf5fbfc371656f6ffa0a688fc981" translate="yes" xml:space="preserve">
          <source>The most common uses of this class are to query the database for the list of font &lt;a href=&quot;qfontdatabase#families&quot;&gt;families&lt;/a&gt;() and for the &lt;a href=&quot;qfontdatabase#pointSizes&quot;&gt;pointSizes&lt;/a&gt;() and &lt;a href=&quot;qfontdatabase#styles&quot;&gt;styles&lt;/a&gt;() that are available for each family. An alternative to &lt;a href=&quot;qfontdatabase#pointSizes&quot;&gt;pointSizes&lt;/a&gt;() is &lt;a href=&quot;qfontdatabase#smoothSizes&quot;&gt;smoothSizes&lt;/a&gt;() which returns the sizes at which a given family and style will look attractive.</source>
          <target state="translated">이 클래스의 가장 일반적인 용도는 데이터베이스 에서 각 패밀리에 사용 가능한 글꼴 &lt;a href=&quot;qfontdatabase#families&quot;&gt;패밀리&lt;/a&gt; 목록 () 및 &lt;a href=&quot;qfontdatabase#pointSizes&quot;&gt;pointSizes&lt;/a&gt; () 및 &lt;a href=&quot;qfontdatabase#styles&quot;&gt;스타일&lt;/a&gt; () 을 쿼리하는 것 입니다. &lt;a href=&quot;qfontdatabase#pointSizes&quot;&gt;pointSizes&lt;/a&gt; () 의 대안 은 &lt;a href=&quot;qfontdatabase#smoothSizes&quot;&gt;smoothSizes&lt;/a&gt; ()로, 주어진 패밀리 및 스타일이 매력적으로 보일 크기를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c610c345f72ac9e6305497271f5abef4737abaa4" translate="yes" xml:space="preserve">
          <source>The most common uses of this class are to register and unregister service names on the bus using the &lt;a href=&quot;qdbusconnectioninterface#registerService&quot;&gt;registerService&lt;/a&gt;() and &lt;a href=&quot;qdbusconnectioninterface#unregisterService&quot;&gt;unregisterService&lt;/a&gt;() functions, query about existing names using the &lt;a href=&quot;qdbusconnectioninterface#isServiceRegistered&quot;&gt;isServiceRegistered&lt;/a&gt;(), &lt;a href=&quot;qdbusconnectioninterface#registeredServiceNames-prop&quot;&gt;registeredServiceNames&lt;/a&gt;() and &lt;a href=&quot;qdbusconnectioninterface#serviceOwner&quot;&gt;serviceOwner&lt;/a&gt;() functions, and to receive notification that a client has registered or de-registered through the &lt;a href=&quot;qdbusconnectioninterface#serviceRegistered&quot;&gt;serviceRegistered&lt;/a&gt;(), &lt;a href=&quot;qdbusconnectioninterface#serviceUnregistered&quot;&gt;serviceUnregistered&lt;/a&gt;() and serviceOwnerChanged() signals.</source>
          <target state="translated">이 클래스의 가장 일반적인 용도는 &lt;a href=&quot;qdbusconnectioninterface#registerService&quot;&gt;registerService&lt;/a&gt; () 및 &lt;a href=&quot;qdbusconnectioninterface#unregisterService&quot;&gt;unregisterService&lt;/a&gt; () 함수를 사용하여 버스에서 서비스 이름을 등록 및 등록 취소 하고 , &lt;a href=&quot;qdbusconnectioninterface#isServiceRegistered&quot;&gt;isServiceRegistered&lt;/a&gt; (), &lt;a href=&quot;qdbusconnectioninterface#registeredServiceNames-prop&quot;&gt;registeredServiceNames&lt;/a&gt; () 및 &lt;a href=&quot;qdbusconnectioninterface#serviceOwner&quot;&gt;serviceOwner&lt;/a&gt; () 함수를 사용하여 기존 이름에 대해 조회 하고 수신하는 것입니다. &lt;a href=&quot;qdbusconnectioninterface#serviceRegistered&quot;&gt;serviceRegistered&lt;/a&gt; (), &lt;a href=&quot;qdbusconnectioninterface#serviceUnregistered&quot;&gt;serviceUnregistered&lt;/a&gt; () 및 serviceOwnerChanged () 신호를 통해 클라이언트가 등록 또는 등록 취소되었음을 알립니다.</target>
        </trans-unit>
        <trans-unit id="0e775dbbf7315f2563ebf1def4a0f29911f41cfa" translate="yes" xml:space="preserve">
          <source>The most common value. On platforms where such information is available this value indicates that the event was generated in response to a genuine mouse event in the system.</source>
          <target state="translated">가장 일반적인 가치. 이러한 정보를 사용할 수있는 플랫폼에서이 값은 시스템에서 실제 마우스 이벤트에 대한 응답으로 이벤트가 생성되었음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="1fea0576104fe384670c4657cb0522b80219802a" translate="yes" xml:space="preserve">
          <source>The most common way of parsing a query string is to initialize it in the constructor by passing it the query string. Otherwise, the &lt;a href=&quot;qurlquery#setQuery&quot;&gt;setQuery&lt;/a&gt;() method can be used to set the query to be parsed. That method can also be used to parse a query with non-standard delimiters, after having set them using the &lt;a href=&quot;qurlquery#setQueryDelimiters&quot;&gt;setQueryDelimiters&lt;/a&gt;() function.</source>
          <target state="translated">쿼리 문자열을 구문 분석하는 가장 일반적인 방법은 생성자에서 쿼리 문자열을 전달하여 쿼리 문자열을 초기화하는 것입니다. 그렇지 않으면 &lt;a href=&quot;qurlquery#setQuery&quot;&gt;setQuery&lt;/a&gt; () 메소드를 사용하여 구문 분석 할 쿼리를 설정할 수 있습니다. &lt;a href=&quot;qurlquery#setQueryDelimiters&quot;&gt;setQueryDelimiters&lt;/a&gt; () 함수를 사용하여 설정 한 후 비표준 구분 기호로 쿼리를 구문 분석하는 데이 메소드를 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7f4f2fc761576a80c8825d7f0de604599245d982" translate="yes" xml:space="preserve">
          <source>The most common way to construct a &lt;a href=&quot;qmdisubwindow&quot;&gt;QMdiSubWindow&lt;/a&gt; is to call &lt;a href=&quot;qmdiarea#addSubWindow&quot;&gt;QMdiArea::addSubWindow&lt;/a&gt;() with the internal widget as the argument. You can also create a subwindow yourself, and set an internal widget by calling &lt;a href=&quot;qmdisubwindow#setWidget&quot;&gt;setWidget&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qmdisubwindow&quot;&gt;QMdiSubWindow&lt;/a&gt; 를 구성하는 가장 일반적인 방법 은 내부 위젯을 인수로 사용하여 &lt;a href=&quot;qmdiarea#addSubWindow&quot;&gt;QMdiArea :: addSubWindow&lt;/a&gt; () 를 호출 하는 것 입니다 . 하위 창을 직접 만들고 &lt;a href=&quot;qmdisubwindow#setWidget&quot;&gt;setWidget&lt;/a&gt; () 을 호출하여 내부 위젯을 설정할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="97cce76900b6f35a3a81171296d1519908472d2e" translate="yes" xml:space="preserve">
          <source>The most common way to construct a QMdiSubWindow is to call &lt;a href=&quot;qmdiarea#addSubWindow&quot;&gt;QMdiArea::addSubWindow&lt;/a&gt;() with the internal widget as the argument. You can also create a subwindow yourself, and set an internal widget by calling &lt;a href=&quot;qmdisubwindow#setWidget&quot;&gt;setWidget&lt;/a&gt;().</source>
          <target state="translated">QMdiSubWindow를 구성하는 가장 일반적인 방법 은 내부 위젯을 인수로 사용하여 &lt;a href=&quot;qmdiarea#addSubWindow&quot;&gt;QMdiArea :: addSubWindow&lt;/a&gt; () 를 호출하는 것입니다 . 직접 하위 창을 만들고 &lt;a href=&quot;qmdisubwindow#setWidget&quot;&gt;setWidget&lt;/a&gt; () 을 호출하여 내부 위젯을 설정할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="45a6938d1c43ca69992f84d52448822a70155892" translate="yes" xml:space="preserve">
          <source>The most common way to display a modal dialog is to call its &lt;a href=&quot;qdialog#exec&quot;&gt;exec&lt;/a&gt;() function. When the user closes the dialog, &lt;a href=&quot;qdialog#exec&quot;&gt;exec&lt;/a&gt;() will provide a useful &lt;a href=&quot;qdialog#return&quot;&gt;return value&lt;/a&gt;. To close the dialog and return the appropriate value, you must connect a default button, e.g. an &lt;b&gt;OK&lt;/b&gt; button to the &lt;a href=&quot;qdialog#accept&quot;&gt;accept&lt;/a&gt;() slot and a &lt;b&gt;Cancel&lt;/b&gt; button to the &lt;a href=&quot;qdialog#reject&quot;&gt;reject&lt;/a&gt;() slot. Alternatively, you can call the &lt;a href=&quot;qdialog#done&quot;&gt;done&lt;/a&gt;() slot with &lt;code&gt;Accepted&lt;/code&gt; or &lt;code&gt;Rejected&lt;/code&gt;.</source>
          <target state="translated">모달 대화 상자를 표시하는 가장 일반적인 방법은 &lt;a href=&quot;qdialog#exec&quot;&gt;exec&lt;/a&gt; () 함수 를 호출하는 것입니다. 사용자가 대화 상자를 닫으면 &lt;a href=&quot;qdialog#exec&quot;&gt;exec&lt;/a&gt; ()는 유용한 &lt;a href=&quot;qdialog#return&quot;&gt;반환 값을&lt;/a&gt; 제공 합니다 . 대화 상자를 닫고 적절한 값을 반환하려면 기본 버튼 (예 : &lt;b&gt;확인&lt;/b&gt; 버튼을 &lt;a href=&quot;qdialog#accept&quot;&gt;수락&lt;/a&gt; () 슬롯에 연결하고 &lt;b&gt;취소&lt;/b&gt; 버튼을 &lt;a href=&quot;qdialog#reject&quot;&gt;거부&lt;/a&gt; () 슬롯에 연결)을 연결해야합니다 . 또는 &lt;code&gt;Accepted&lt;/code&gt; 또는 &lt;code&gt;Rejected&lt;/code&gt; 로&lt;a href=&quot;qdialog#done&quot;&gt;done&lt;/a&gt; () 슬롯을 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4db904b38a94e7f55c718caafcf9a251ccb0d9bd" translate="yes" xml:space="preserve">
          <source>The most common way to display a modal dialog is to call its &lt;a href=&quot;qdialog#exec&quot;&gt;exec&lt;/a&gt;() function. When the user closes the dialog, &lt;a href=&quot;qdialog#exec&quot;&gt;exec&lt;/a&gt;() will provide a useful &lt;a href=&quot;qdialog#return&quot;&gt;return value&lt;/a&gt;. Typically, to get the dialog to close and return the appropriate value, we connect a default button, e.g. &lt;b&gt;OK&lt;/b&gt;, to the &lt;a href=&quot;qdialog#accept&quot;&gt;accept&lt;/a&gt;() slot and a &lt;b&gt;Cancel&lt;/b&gt; button to the &lt;a href=&quot;qdialog#reject&quot;&gt;reject&lt;/a&gt;() slot. Alternatively you can call the &lt;a href=&quot;qdialog#done&quot;&gt;done&lt;/a&gt;() slot with &lt;code&gt;Accepted&lt;/code&gt; or &lt;code&gt;Rejected&lt;/code&gt;.</source>
          <target state="translated">모달 대화 상자를 표시하는 가장 일반적인 방법은 &lt;a href=&quot;qdialog#exec&quot;&gt;exec&lt;/a&gt; () 함수 를 호출하는 것입니다. 사용자가 대화 상자를 닫으면 &lt;a href=&quot;qdialog#exec&quot;&gt;exec&lt;/a&gt; ()가 유용한 &lt;a href=&quot;qdialog#return&quot;&gt;반환 값을&lt;/a&gt; 제공 합니다 . 일반적으로 대화 상자를 닫고 적절한 값을 반환하기 위해 기본 버튼 (예 : &lt;b&gt;OK&lt;/b&gt; )을 &lt;a href=&quot;qdialog#accept&quot;&gt;수락&lt;/a&gt; () 슬롯에 연결하고 &lt;b&gt;취소&lt;/b&gt; 버튼을 &lt;a href=&quot;qdialog#reject&quot;&gt;거부&lt;/a&gt; () 슬롯에 연결합니다. 또는 &lt;code&gt;Accepted&lt;/code&gt; 또는 &lt;code&gt;Rejected&lt;/code&gt; 로&lt;a href=&quot;qdialog#done&quot;&gt;done&lt;/a&gt; () 슬롯을 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2ccd69948ac1c1cfd7c5d6e25649a074fade36ef" translate="yes" xml:space="preserve">
          <source>The most common way to implement an SSL server is to create a subclass of &lt;a href=&quot;qtcpserver&quot;&gt;QTcpServer&lt;/a&gt; and reimplement &lt;a href=&quot;qtcpserver#incomingConnection&quot;&gt;QTcpServer::incomingConnection&lt;/a&gt;(). The returned socket descriptor is then passed to &lt;a href=&quot;qsslsocket#setSocketDescriptor&quot;&gt;QSslSocket::setSocketDescriptor&lt;/a&gt;().</source>
          <target state="translated">SSL 서버를 구현하는 가장 일반적인 방법은 &lt;a href=&quot;qtcpserver&quot;&gt;QTcpServer&lt;/a&gt; 의 서브 클래스를 작성하고 &lt;a href=&quot;qtcpserver#incomingConnection&quot;&gt;QTcpServer :: incomingConnection&lt;/a&gt; ()을 다시 구현하는 것 입니다. 리턴 된 소켓 설명자는 &lt;a href=&quot;qsslsocket#setSocketDescriptor&quot;&gt;QSslSocket :: setSocketDescriptor&lt;/a&gt; () 로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="715c6c9e75a92560d0e30865303d9847b23aae43" translate="yes" xml:space="preserve">
          <source>The most common way to read images is through &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt; and &lt;a href=&quot;qpixmap&quot;&gt;QPixmap&lt;/a&gt;'s constructors, or by calling &lt;a href=&quot;qimage#load&quot;&gt;QImage::load&lt;/a&gt;() and &lt;a href=&quot;qpixmap#load&quot;&gt;QPixmap::load&lt;/a&gt;(). &lt;a href=&quot;qimagereader&quot;&gt;QImageReader&lt;/a&gt; is a specialized class which gives you more control when reading images. For example, you can read an image into a specific size by calling &lt;a href=&quot;qimagereader#setScaledSize&quot;&gt;setScaledSize&lt;/a&gt;(), and you can select a clip rect, effectively loading only parts of an image, by calling &lt;a href=&quot;qimagereader#setClipRect&quot;&gt;setClipRect&lt;/a&gt;(). Depending on the underlying support in the image format, this can save memory and speed up loading of images.</source>
          <target state="translated">이미지를 읽는 가장 일반적인 방법은 &lt;a href=&quot;qimage&quot;&gt; QImage&lt;/a&gt; 및 &lt;a href=&quot;qpixmap&quot;&gt;QPixmap&lt;/a&gt; 의 생성자를 통하거나 &lt;a href=&quot;qimage#load&quot;&gt;QImage :: load&lt;/a&gt; () 및 &lt;a href=&quot;qpixmap#load&quot;&gt;QPixmap :: load&lt;/a&gt; () 를 호출하는 것 입니다. &lt;a href=&quot;qimagereader&quot;&gt;QImageReader&lt;/a&gt; 는 이미지를 읽을 때 더 많은 컨트롤을 제공하는 특수 클래스입니다. 예를 들어 &lt;a href=&quot;qimagereader#setScaledSize&quot;&gt;setScaledSize&lt;/a&gt; () 를 호출하여 이미지를 특정 크기로 읽을 수 있으며 &lt;a href=&quot;qimagereader#setClipRect&quot;&gt;setClipRect&lt;/a&gt; () 를 호출하여 클립 rect를 선택하여 이미지의 일부만 효과적으로로드 할 수 있습니다 . 이미지 형식의 기본 지원에 따라 메모리를 절약하고 이미지 로딩 속도를 높일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3b84c1abe9fe3060f16d39b217d307da83574ae5" translate="yes" xml:space="preserve">
          <source>The most common way to read images is through &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt; and &lt;a href=&quot;qpixmap&quot;&gt;QPixmap&lt;/a&gt;'s constructors, or by calling &lt;a href=&quot;qimage#load&quot;&gt;QImage::load&lt;/a&gt;() and &lt;a href=&quot;qpixmap#load&quot;&gt;QPixmap::load&lt;/a&gt;(). QImageReader is a specialized class which gives you more control when reading images. For example, you can read an image into a specific size by calling &lt;a href=&quot;qimagereader#setScaledSize&quot;&gt;setScaledSize&lt;/a&gt;(), and you can select a clip rect, effectively loading only parts of an image, by calling &lt;a href=&quot;qimagereader#setClipRect&quot;&gt;setClipRect&lt;/a&gt;(). Depending on the underlying support in the image format, this can save memory and speed up loading of images.</source>
          <target state="translated">이미지를 읽는 가장 일반적인 방법은 &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt; 및 &lt;a href=&quot;qpixmap&quot;&gt;QPixmap&lt;/a&gt; 의 생성자를 통하거나 &lt;a href=&quot;qimage#load&quot;&gt;QImage :: load&lt;/a&gt; () 및 &lt;a href=&quot;qpixmap#load&quot;&gt;QPixmap :: load&lt;/a&gt; () 를 호출하는 것 입니다. QImageReader는 이미지를 읽을 때 더 많은 제어를 제공하는 특수 클래스입니다. 예를 들어 &lt;a href=&quot;qimagereader#setScaledSize&quot;&gt;setScaledSize&lt;/a&gt; () 를 호출하여 이미지를 특정 크기로 읽을 수 있으며 &lt;a href=&quot;qimagereader#setClipRect&quot;&gt;setClipRect&lt;/a&gt; () 를 호출하여 이미지의 일부만 효과적으로로드하는 클립 사각형을 선택할 수 있습니다. 이미지 형식의 기본 지원에 따라 메모리를 절약하고 이미지로드 속도를 높일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d729abd472431cdfa015363e3776a0ff7352c7c" translate="yes" xml:space="preserve">
          <source>The most common way to read images is through &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt; and &lt;a href=&quot;qpixmap&quot;&gt;QPixmap&lt;/a&gt;'s constructors, or by calling the &lt;a href=&quot;qimage#load&quot;&gt;QImage::load&lt;/a&gt;() and &lt;a href=&quot;qpixmap#load&quot;&gt;QPixmap::load&lt;/a&gt;() functions. In addition, Qt provides the &lt;a href=&quot;qimagereader&quot;&gt;QImageReader&lt;/a&gt; class which gives more control over the process. Depending on the underlying support in the image format, the functions provided by the class can save memory and speed up loading of images.</source>
          <target state="translated">이미지를 읽는 가장 일반적인 방법은 &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt; 및 &lt;a href=&quot;qpixmap&quot;&gt;QPixmap&lt;/a&gt; 의 생성자를 통하거나 &lt;a href=&quot;qimage#load&quot;&gt;QImage :: load&lt;/a&gt; () 및 &lt;a href=&quot;qpixmap#load&quot;&gt;QPixmap :: load&lt;/a&gt; () 함수를 호출하는 것입니다. 또한 Qt는 프로세스를보다 &lt;a href=&quot;qimagereader&quot;&gt;효과적으로&lt;/a&gt; 제어 할 수 있는 QImageReader 클래스를 제공합니다. 이미지 형식의 기본 지원에 따라 클래스에서 제공하는 기능으로 메모리를 절약하고 이미지로드 속도를 높일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="101a019fa46095f6c75cd38237cdb1411ecafd6c" translate="yes" xml:space="preserve">
          <source>The most common way to use &lt;a href=&quot;qgraphicsgridlayout&quot;&gt;QGraphicsGridLayout&lt;/a&gt; is to construct an object on the heap with no parent, add widgets and layouts by calling &lt;a href=&quot;qgraphicsgridlayout#addItem&quot;&gt;addItem&lt;/a&gt;(), and finally assign the layout to a widget by calling &lt;a href=&quot;qgraphicswidget#setLayout&quot;&gt;QGraphicsWidget::setLayout&lt;/a&gt;(). &lt;a href=&quot;qgraphicsgridlayout&quot;&gt;QGraphicsGridLayout&lt;/a&gt; automatically computes the dimensions of the grid as you add items.</source>
          <target state="translated">&lt;a href=&quot;qgraphicsgridlayout&quot;&gt;QGraphicsGridLayout&lt;/a&gt; 을 사용하는 가장 일반적인 방법 은 부모가없는 힙에 오브젝트를 구성하고 &lt;a href=&quot;qgraphicsgridlayout#addItem&quot;&gt;addItem&lt;/a&gt; () 을 호출하여 위젯 및 레이아웃을 추가 한 다음 &lt;a href=&quot;qgraphicswidget#setLayout&quot;&gt;QGraphicsWidget :: setLayout&lt;/a&gt; () 을 호출하여 위젯에 레이아웃을 지정하는 것 입니다. &lt;a href=&quot;qgraphicsgridlayout&quot;&gt;QGraphicsGridLayout&lt;/a&gt; 은 항목을 추가 할 때 그리드의 크기를 자동으로 계산합니다.</target>
        </trans-unit>
        <trans-unit id="c141e7d739966d5c5ee7f9540a000b59a61fe21a" translate="yes" xml:space="preserve">
          <source>The most common way to use &lt;a href=&quot;qgraphicslinearlayout&quot;&gt;QGraphicsLinearLayout&lt;/a&gt; is to construct an object on the heap with no parent, add widgets and layouts by calling &lt;a href=&quot;qgraphicslinearlayout#addItem&quot;&gt;addItem&lt;/a&gt;(), and finally assign the layout to a widget by calling &lt;a href=&quot;qgraphicswidget#setLayout&quot;&gt;QGraphicsWidget::setLayout&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qgraphicslinearlayout&quot;&gt;QGraphicsLinearLayout&lt;/a&gt; 을 사용하는 가장 일반적인 방법 은 부모가없는 힙에 객체를 생성하고 &lt;a href=&quot;qgraphicslinearlayout#addItem&quot;&gt;addItem&lt;/a&gt; () 을 호출하여 위젯 및 레이아웃을 추가 한 다음 &lt;a href=&quot;qgraphicswidget#setLayout&quot;&gt;QGraphicsWidget :: setLayout&lt;/a&gt; () 을 호출하여 위젯에 레이아웃을 할당하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="a2bf74e32885a141bd8a1e0688a065525463f9ef" translate="yes" xml:space="preserve">
          <source>The most common way to use &lt;a href=&quot;qsctpserver&quot;&gt;QSctpServer&lt;/a&gt; is to construct an object and set the maximum number of channels that the server is prepared to support, by calling &lt;a href=&quot;qsctpserver#setMaximumChannelCount&quot;&gt;setMaximumChannelCount&lt;/a&gt;(). You can set the TCP emulation mode by passing a negative argument in this call. Also, a special value of 0 (the default) indicates to use the peer's value as the actual number of channels. The new incoming connection inherits this number from the server socket descriptor and adjusts it according to the remote endpoint settings.</source>
          <target state="translated">&lt;a href=&quot;qsctpserver&quot;&gt;QSctpServer&lt;/a&gt; 를 사용하는 가장 일반적인 방법 은 &lt;a href=&quot;qsctpserver#setMaximumChannelCount&quot;&gt;setMaximumChannelCount&lt;/a&gt; () 를 호출하여 오브젝트를 구성하고 서버가 지원할 수있는 최대 채널 수를 설정하는 것 입니다. 이 호출에서 음수 인수를 전달하여 TCP 에뮬레이션 모드를 설정할 수 있습니다. 또한 특수 값 0 (기본값)은 피어의 값을 실제 채널 수로 사용함을 나타냅니다. 새 수신 연결은 서버 소켓 디스크립터에서이 번호를 상속하여 원격 엔드 포인트 설정에 따라 조정합니다.</target>
        </trans-unit>
        <trans-unit id="080a7df7369d9a041493304b79bf9386d8a53bc5" translate="yes" xml:space="preserve">
          <source>The most common way to use &lt;a href=&quot;qsslsocket&quot;&gt;QSslSocket&lt;/a&gt; is to construct an object and start a secure connection by calling &lt;a href=&quot;qsslsocket#connectToHostEncrypted&quot;&gt;connectToHostEncrypted&lt;/a&gt;(). This method starts an immediate SSL handshake once the connection has been established.</source>
          <target state="translated">&lt;a href=&quot;qsslsocket&quot;&gt;QSslSocket&lt;/a&gt; 을 사용하는 가장 일반적인 방법 은 &lt;a href=&quot;qsslsocket#connectToHostEncrypted&quot;&gt;connectToHostEncrypted&lt;/a&gt; () 를 호출하여 오브젝트를 구성하고 보안 연결을 시작하는 것 입니다. 이 방법은 연결이 설정되면 즉시 SSL 핸드 셰이크를 시작합니다.</target>
        </trans-unit>
        <trans-unit id="145c07f52f7a1794fe66e7cb9f11ab1638511073" translate="yes" xml:space="preserve">
          <source>The most common way to use &lt;a href=&quot;qurl&quot;&gt;QUrl&lt;/a&gt; is to initialize it via the constructor by passing a &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;. Otherwise, &lt;a href=&quot;qurl#setUrl&quot;&gt;setUrl&lt;/a&gt;() can also be used.</source>
          <target state="translated">&lt;a href=&quot;qurl&quot;&gt;QUrl&lt;/a&gt; 을 사용하는 가장 일반적인 방법 은 &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; 을 전달하여 생성자를 통해 초기화하는 것 입니다. 그렇지 않으면 &lt;a href=&quot;qurl#setUrl&quot;&gt;setUrl&lt;/a&gt; ()을 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="60de2727af42d173ea0a9d69ede828fce69cc60d" translate="yes" xml:space="preserve">
          <source>The most common way to use QGraphicsGridLayout is to construct an object on the heap with no parent, add widgets and layouts by calling &lt;a href=&quot;qgraphicsgridlayout#addItem&quot;&gt;addItem&lt;/a&gt;(), and finally assign the layout to a widget by calling &lt;a href=&quot;qgraphicswidget#setLayout&quot;&gt;QGraphicsWidget::setLayout&lt;/a&gt;(). QGraphicsGridLayout automatically computes the dimensions of the grid as you add items.</source>
          <target state="translated">QGraphicsGridLayout을 사용하는 가장 일반적인 방법은 부모가없는 힙에 객체를 생성하고 &lt;a href=&quot;qgraphicsgridlayout#addItem&quot;&gt;addItem&lt;/a&gt; () 을 호출하여 위젯과 레이아웃을 추가 한 다음 마지막으로 &lt;a href=&quot;qgraphicswidget#setLayout&quot;&gt;QGraphicsWidget :: setLayout&lt;/a&gt; () 을 호출하여 위젯에 레이아웃을 할당하는 것 입니다. QGraphicsGridLayout은 항목을 추가 할 때 그리드의 크기를 자동으로 계산합니다.</target>
        </trans-unit>
        <trans-unit id="604a64bb74085c001612f1eafaba0bb1e89b525e" translate="yes" xml:space="preserve">
          <source>The most common way to use QGraphicsLinearLayout is to construct an object on the heap with no parent, add widgets and layouts by calling &lt;a href=&quot;qgraphicslinearlayout#addItem&quot;&gt;addItem&lt;/a&gt;(), and finally assign the layout to a widget by calling &lt;a href=&quot;qgraphicswidget#setLayout&quot;&gt;QGraphicsWidget::setLayout&lt;/a&gt;().</source>
          <target state="translated">QGraphicsLinearLayout을 사용하는 가장 일반적인 방법은 부모가없는 힙에 객체를 생성하고 &lt;a href=&quot;qgraphicslinearlayout#addItem&quot;&gt;addItem&lt;/a&gt; () 을 호출하여 위젯과 레이아웃을 추가 한 다음 마지막으로 &lt;a href=&quot;qgraphicswidget#setLayout&quot;&gt;QGraphicsWidget :: setLayout&lt;/a&gt; () 을 호출하여 위젯에 레이아웃을 할당하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="65382f654bea386d614eaff1872eb0ca3063c204" translate="yes" xml:space="preserve">
          <source>The most common way to use QSctpServer is to construct an object and set the maximum number of channels that the server is prepared to support, by calling &lt;a href=&quot;qsctpserver#setMaximumChannelCount&quot;&gt;setMaximumChannelCount&lt;/a&gt;(). You can set the TCP emulation mode by passing a negative argument in this call. Also, a special value of 0 (the default) indicates to use the peer's value as the actual number of channels. The new incoming connection inherits this number from the server socket descriptor and adjusts it according to the remote endpoint settings.</source>
          <target state="translated">QSctpServer를 사용하는 가장 일반적인 방법은 &lt;a href=&quot;qsctpserver#setMaximumChannelCount&quot;&gt;setMaximumChannelCount&lt;/a&gt; () 를 호출하여 개체를 생성하고 서버가 지원할 수있는 최대 채널 수를 설정하는 것 입니다. 이 호출에서 음수 인수를 전달하여 TCP 에뮬레이션 모드를 설정할 수 있습니다. 또한 특수 값 0 (기본값)은 피어의 값을 실제 채널 수로 사용함을 나타냅니다. 새로 들어오는 연결은 서버 소켓 설명자에서이 번호를 상속하고 원격 끝점 설정에 따라 조정합니다.</target>
        </trans-unit>
        <trans-unit id="f549c8574faf01191cf3039bac624f5b23df9059" translate="yes" xml:space="preserve">
          <source>The most common way to use QSslSocket is to construct an object and start a secure connection by calling &lt;a href=&quot;qsslsocket#connectToHostEncrypted&quot;&gt;connectToHostEncrypted&lt;/a&gt;(). This method starts an immediate SSL handshake once the connection has been established.</source>
          <target state="translated">QSslSocket을 사용하는 가장 일반적인 방법은 객체를 생성하고 &lt;a href=&quot;qsslsocket#connectToHostEncrypted&quot;&gt;connectToHostEncrypted&lt;/a&gt; () 를 호출하여 보안 연결을 시작하는 것 입니다. 이 방법은 연결이 설정되면 즉시 SSL 핸드 셰이크를 시작합니다.</target>
        </trans-unit>
        <trans-unit id="57716c322454811b03f2dac2a888b9bfc78b16ea" translate="yes" xml:space="preserve">
          <source>The most common way to use QUrl is to initialize it via the constructor by passing a &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;. Otherwise, &lt;a href=&quot;qurl#setUrl&quot;&gt;setUrl&lt;/a&gt;() can also be used.</source>
          <target state="translated">QUrl을 사용하는 가장 일반적인 방법은 생성자를 통해 &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; 을 전달하여 초기화하는 것 입니다. 그렇지 않으면 &lt;a href=&quot;qurl#setUrl&quot;&gt;setUrl&lt;/a&gt; ()도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ef1f3c9d168542f53d1e3eb408ecbab6d6c9f1e" translate="yes" xml:space="preserve">
          <source>The most common way to use this class is to bind to an address and port using &lt;a href=&quot;qabstractsocket#bind&quot;&gt;bind&lt;/a&gt;(), then call &lt;a href=&quot;qudpsocket#writeDatagram&quot;&gt;writeDatagram&lt;/a&gt;() and &lt;a href=&quot;qudpsocket#readDatagram&quot;&gt;readDatagram&lt;/a&gt;() / &lt;a href=&quot;qudpsocket#receiveDatagram&quot;&gt;receiveDatagram&lt;/a&gt;() to transfer data. If you want to use the standard &lt;a href=&quot;qiodevice&quot;&gt;QIODevice&lt;/a&gt; functions &lt;a href=&quot;qiodevice#read&quot;&gt;read&lt;/a&gt;(), &lt;a href=&quot;qiodevice#readLine&quot;&gt;readLine&lt;/a&gt;(), &lt;a href=&quot;qiodevice#write&quot;&gt;write&lt;/a&gt;(), etc., you must first connect the socket directly to a peer by calling &lt;a href=&quot;qabstractsocket#connectToHost&quot;&gt;connectToHost&lt;/a&gt;().</source>
          <target state="translated">이 클래스를 사용하는 가장 일반적인 방법은 &lt;a href=&quot;qabstractsocket#bind&quot;&gt;bind&lt;/a&gt; ()를 사용하여 주소와 포트에 바인딩 한 다음 &lt;a href=&quot;qudpsocket#writeDatagram&quot;&gt;writeDatagram&lt;/a&gt; () 및 &lt;a href=&quot;qudpsocket#readDatagram&quot;&gt;readDatagram&lt;/a&gt; () / &lt;a href=&quot;qudpsocket#receiveDatagram&quot;&gt;receiveDatagram&lt;/a&gt; ()을 호출 하여 데이터를 전송하는 것입니다. 표준 &lt;a href=&quot;qiodevice&quot;&gt;QIODevice&lt;/a&gt; 함수 &lt;a href=&quot;qiodevice#read&quot;&gt;read&lt;/a&gt; (), &lt;a href=&quot;qiodevice#readLine&quot;&gt;readLine&lt;/a&gt; (),&lt;a href=&quot;qiodevice#write&quot;&gt; write&lt;/a&gt; () 등을 사용하려면 먼저 &lt;a href=&quot;qabstractsocket#connectToHost&quot;&gt;connectToHost&lt;/a&gt; () 를 호출하여 소켓을 피어에 직접 연결해야합니다 .</target>
        </trans-unit>
        <trans-unit id="c3df83c8653c29a2f372ccd5a983b4c4726e64ec" translate="yes" xml:space="preserve">
          <source>The most commonly used modes are SingleSelection and ExtendedSelection.</source>
          <target state="translated">가장 일반적으로 사용되는 모드는 SingleSelection 및 ExtendedSelection입니다.</target>
        </trans-unit>
        <trans-unit id="ecd692877318fed8774ed47e8945e6e3d95baeba" translate="yes" xml:space="preserve">
          <source>The most commonly used properties are:</source>
          <target state="translated">가장 일반적으로 사용되는 속성은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="50cd774ed04629a78087b6bacea7a024ddc49e31" translate="yes" xml:space="preserve">
          <source>The most commonly used transformations are scaling, rotation, translation and shearing. Use the &lt;a href=&quot;qpainter#scale&quot;&gt;scale&lt;/a&gt;() function to scale the coordinate system by a given offset, the &lt;a href=&quot;qpainter#rotate&quot;&gt;rotate&lt;/a&gt;() function to rotate it clockwise and &lt;a href=&quot;qpainter#translate&quot;&gt;translate&lt;/a&gt;() to translate it (i.e. adding a given offset to the points). You can also twist the coordinate system around the origin using the &lt;a href=&quot;qpainter#shear&quot;&gt;shear&lt;/a&gt;() function. See the &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtwidgets-painting-affine-example.html&quot;&gt;Affine Transformations&lt;/a&gt; example for a visualization of a sheared coordinate system.</source>
          <target state="translated">가장 일반적으로 사용되는 변형은 스케일링, 회전, 평행 이동 및 전단입니다. 사용 &lt;a href=&quot;qpainter#scale&quot;&gt;규모&lt;/a&gt; 오프셋 주어진에 의해 좌표 시스템을 확장 () 함수를 &lt;a href=&quot;qpainter#rotate&quot;&gt;회전&lt;/a&gt; 시계 방향으로 회전 () 함수 &lt;a href=&quot;qpainter#translate&quot;&gt;변환&lt;/a&gt; (이) 그것을 번역하는 (즉, 추가, 포인트에 지정된 오프셋 (offset)). &lt;a href=&quot;qpainter#shear&quot;&gt;shear&lt;/a&gt; () 함수를 사용하여 원점을 중심으로 좌표계를 비틀 수도 있습니다. 전단 좌표계의 시각화는 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtwidgets-painting-affine-example.html&quot;&gt;변환 정의&lt;/a&gt; 예를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0eace6feb8ed20f2daf53bb73fecc09e3cae4599" translate="yes" xml:space="preserve">
          <source>The most commonly used transformations are scaling, rotation, translation and shearing. Use the &lt;a href=&quot;qpainter#scale&quot;&gt;scale&lt;/a&gt;() function to scale the coordinate system by a given offset, the &lt;a href=&quot;qpainter#rotate&quot;&gt;rotate&lt;/a&gt;() function to rotate it clockwise and &lt;a href=&quot;qpainter#translate&quot;&gt;translate&lt;/a&gt;() to translate it (i.e. adding a given offset to the points). You can also twist the coordinate system around the origin using the &lt;a href=&quot;qpainter#shear&quot;&gt;shear&lt;/a&gt;() function. See the &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtwidgets-painting-affine-example.html&quot;&gt;Affine Transformations&lt;/a&gt; example for a visualization of a sheared coordinate system.</source>
          <target state="translated">가장 일반적으로 사용되는 변형은 크기 조정, 회전, 변환 및 기울이기입니다. &lt;a href=&quot;qpainter#scale&quot;&gt;scale&lt;/a&gt; () 함수를 사용하여 좌표계를 주어진 오프셋으로 배율을 조정하고 &lt;a href=&quot;qpainter#rotate&quot;&gt;rotate&lt;/a&gt; () 함수를 사용하여 시계 방향으로 회전하고 &lt;a href=&quot;qpainter#translate&quot;&gt;이동&lt;/a&gt; () 함수를 사용 하여 변환합니다 (즉, 지정된 오프셋을 점에 추가). &lt;a href=&quot;qpainter#shear&quot;&gt;전단&lt;/a&gt; () 함수를 사용하여 원점 주위로 좌표계를 비틀 수도 있습니다. 전단 좌표계의 시각화 는 &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtwidgets-painting-affine-example.html&quot;&gt;Affine Transformations&lt;/a&gt; 예제를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8aec22886ecded29c421e65588d616b64d41dc05" translate="yes" xml:space="preserve">
          <source>The most convenient way to handle the input is to read it in a single pass using the &lt;a href=&quot;qxmlsimplereader#parse&quot;&gt;parse&lt;/a&gt;() function with an argument that specifies the input source:</source>
          <target state="translated">입력을 처리하는 가장 편리한 방법 은 입력 소스를 지정하는 인수와 함께 &lt;a href=&quot;qxmlsimplereader#parse&quot;&gt;구문 분석&lt;/a&gt; () 함수를 사용하여 단일 패스로 입력을 읽는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="b443402c110cde9e7b21783b3e46bdcfa756f8d3" translate="yes" xml:space="preserve">
          <source>The most correct fix for this is to use &lt;a href=&quot;quick3d-asset-conditioning-anti-aliasing#multisample-aa&quot;&gt;Multisample Anti-Aliasing&lt;/a&gt;, as it gathers more geometric detail only as needed. Using &lt;a href=&quot;quick3d-asset-conditioning-anti-aliasing#temporal-aa&quot;&gt;Temporal Anti-Aliasing&lt;/a&gt; or &lt;a href=&quot;quick3d-asset-conditioning-anti-aliasing#progressive-aa&quot;&gt;Progressive Anti-Aliasing&lt;/a&gt; can also mitigate the issue in a correct manner.</source>
          <target state="translated">이에 대한 가장 정확한 수정은 필요에 따라 더 많은 기하학적 세부 사항을 수집 하므로 &lt;a href=&quot;quick3d-asset-conditioning-anti-aliasing#multisample-aa&quot;&gt;Multisample Anti-Aliasing&lt;/a&gt; 을 사용 하는 것입니다. &lt;a href=&quot;quick3d-asset-conditioning-anti-aliasing#temporal-aa&quot;&gt;임시 앨리어싱 제거&lt;/a&gt; 또는 &lt;a href=&quot;quick3d-asset-conditioning-anti-aliasing#progressive-aa&quot;&gt;프로그레시브 &lt;/a&gt;앨리어싱 제거를 사용 하면 올바른 방식으로 문제를 완화 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="177173621649b305955856124b97dc289090e623" translate="yes" xml:space="preserve">
          <source>The most correct solution in this case is using &lt;a href=&quot;quick3d-asset-conditioning-anti-aliasing#temporal-aa&quot;&gt;Temporal AA&lt;/a&gt; or &lt;a href=&quot;quick3d-asset-conditioning-anti-aliasing#progressive-aa&quot;&gt;Progressive AA&lt;/a&gt; to find the extra information.</source>
          <target state="translated">이 경우 가장 정확한 해결책은 &lt;a href=&quot;quick3d-asset-conditioning-anti-aliasing#temporal-aa&quot;&gt;임시 AA&lt;/a&gt; 또는 &lt;a href=&quot;quick3d-asset-conditioning-anti-aliasing#progressive-aa&quot;&gt;프로그레시브 AA&lt;/a&gt; 를 사용하여 추가 정보를 찾는 것입니다.</target>
        </trans-unit>
        <trans-unit id="34e71e3463bf5736f59ee0738079d0f66a536785" translate="yes" xml:space="preserve">
          <source>The most efficient way to set this property is by using the registered component's UUID, e.g.</source>
          <target state="translated">이 속성을 설정하는 가장 효율적인 방법은 등록 된 구성 요소의 UUID를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="fc8ed8ecee363f4eda84ea81735fde8b6a52e8a9" translate="yes" xml:space="preserve">
          <source>The most important classes in the Qt GUI module are &lt;a href=&quot;qguiapplication&quot;&gt;QGuiApplication&lt;/a&gt; and &lt;a href=&quot;qwindow&quot;&gt;QWindow&lt;/a&gt;. A Qt application that wants to show content on screen, will need to make use of these. &lt;a href=&quot;qguiapplication&quot;&gt;QGuiApplication&lt;/a&gt; contains the main event loop, where all events from the window system and other sources are processed and dispatched. It also handles the application's initialization and finalization.</source>
          <target state="translated">Qt GUI 모듈에서 가장 중요한 클래스는 &lt;a href=&quot;qguiapplication&quot;&gt;QGuiApplication&lt;/a&gt; 및 &lt;a href=&quot;qwindow&quot;&gt;QWindow&lt;/a&gt; 입니다. 화면에 콘텐츠를 표시하려는 Qt 응용 프로그램은 이러한 기능을 사용해야합니다. &lt;a href=&quot;qguiapplication&quot;&gt;QGuiApplication&lt;/a&gt; 에는 윈도우 시스템 및 기타 소스의 모든 이벤트가 처리 및 발송되는 기본 이벤트 루프가 포함되어 있습니다. 또한 응용 프로그램의 초기화 및 마무리를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="ba0626a0be1eb4a5cd315b64ee8d66bfbecc3f05" translate="yes" xml:space="preserve">
          <source>The most important feature of &lt;a href=&quot;qdomdocumentfragment&quot;&gt;QDomDocumentFragment&lt;/a&gt; is that it is treated in a special way by &lt;a href=&quot;qdomnode#insertAfter&quot;&gt;QDomNode::insertAfter&lt;/a&gt;(), &lt;a href=&quot;qdomnode#insertBefore&quot;&gt;QDomNode::insertBefore&lt;/a&gt;(), &lt;a href=&quot;qdomnode#replaceChild&quot;&gt;QDomNode::replaceChild&lt;/a&gt;() and &lt;a href=&quot;qdomnode#appendChild&quot;&gt;QDomNode::appendChild&lt;/a&gt;(): instead of inserting the fragment itself, all the fragment's children are inserted.</source>
          <target state="translated">&lt;a href=&quot;qdomdocumentfragment&quot;&gt;QDomDocumentFragment&lt;/a&gt; 의 가장 중요한 기능은 QDomNode &lt;a href=&quot;qdomnode#insertAfter&quot;&gt;:: insertAfter&lt;/a&gt; (), &lt;a href=&quot;qdomnode#insertBefore&quot;&gt;QDomNode :: insertBefore&lt;/a&gt; (), &lt;a href=&quot;qdomnode#replaceChild&quot;&gt;QDomNode :: replaceChild&lt;/a&gt; () 및 &lt;a href=&quot;qdomnode#appendChild&quot;&gt;QDomNode :: appendChild에&lt;/a&gt; 의해 특별한 방식으로 처리된다는 것입니다. 조각 자체를 삽입하는 대신 ()에 . , 조각의 모든 자식이 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="5618c4d44542c82c7f111fc81791ce0d048848d6" translate="yes" xml:space="preserve">
          <source>The most important feature of QDomDocumentFragment is that it is treated in a special way by &lt;a href=&quot;qdomnode#insertAfter&quot;&gt;QDomNode::insertAfter&lt;/a&gt;(), &lt;a href=&quot;qdomnode#insertBefore&quot;&gt;QDomNode::insertBefore&lt;/a&gt;(), &lt;a href=&quot;qdomnode#replaceChild&quot;&gt;QDomNode::replaceChild&lt;/a&gt;() and &lt;a href=&quot;qdomnode#appendChild&quot;&gt;QDomNode::appendChild&lt;/a&gt;(): instead of inserting the fragment itself, all the fragment's children are inserted.</source>
          <target state="translated">QDomDocumentFragment의 가장 중요한 기능은 조각 자체를 삽입하는 대신 &lt;a href=&quot;qdomnode#insertAfter&quot;&gt;QDomNode :: insertAfter&lt;/a&gt; (), &lt;a href=&quot;qdomnode#insertBefore&quot;&gt;QDomNode :: insertBefore&lt;/a&gt; (), &lt;a href=&quot;qdomnode#replaceChild&quot;&gt;QDomNode :: replaceChild&lt;/a&gt; () 및 &lt;a href=&quot;qdomnode#appendChild&quot;&gt;QDomNode :: appendChild&lt;/a&gt; () :에 의해 특별한 방식으로 처리된다는 것입니다 . , 모든 조각의 자식이 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="3895bf2c5a5d1e4e3c5fd9a6bba43c59be210d4b" translate="yes" xml:space="preserve">
          <source>The most important functions are &lt;a href=&quot;qlibrary#load&quot;&gt;load&lt;/a&gt;() to dynamically load the library file, &lt;a href=&quot;qlibrary#isLoaded&quot;&gt;isLoaded&lt;/a&gt;() to check whether loading was successful, and &lt;a href=&quot;qlibrary#resolve&quot;&gt;resolve&lt;/a&gt;() to resolve a symbol in the library. The &lt;a href=&quot;qlibrary#resolve&quot;&gt;resolve&lt;/a&gt;() function implicitly tries to load the library if it has not been loaded yet. Multiple instances of &lt;a href=&quot;qlibrary&quot;&gt;QLibrary&lt;/a&gt; can be used to access the same physical library. Once loaded, libraries remain in memory until the application terminates. You can attempt to unload a library using &lt;a href=&quot;qlibrary#unload&quot;&gt;unload&lt;/a&gt;(), but if other instances of &lt;a href=&quot;qlibrary&quot;&gt;QLibrary&lt;/a&gt; are using the same library, the call will fail, and unloading will only happen when every instance has called &lt;a href=&quot;qlibrary#unload&quot;&gt;unload&lt;/a&gt;().</source>
          <target state="translated">가장 중요한 함수는 라이브러리 파일을 동적으로로드하는 &lt;a href=&quot;qlibrary#load&quot;&gt;load&lt;/a&gt; (), 로드가 성공적인지 확인하는 &lt;a href=&quot;qlibrary#isLoaded&quot;&gt;isLoaded&lt;/a&gt; () 및 라이브러리의 심볼 을 확인하는 &lt;a href=&quot;qlibrary#resolve&quot;&gt;resolve&lt;/a&gt; ()입니다. &lt;a href=&quot;qlibrary#resolve&quot;&gt;해결&lt;/a&gt; () 함수는 암시가 아직로드되지 않은 경우 라이브러리를로드하려고합니다. &lt;a href=&quot;qlibrary&quot;&gt;QLibrary의&lt;/a&gt; 여러 인스턴스를 사용하여 동일한 실제 라이브러리에 액세스 할 수 있습니다. 라이브러리가로드되면 응용 프로그램이 종료 될 때까지 메모리에 남아 있습니다. &lt;a href=&quot;qlibrary#unload&quot;&gt;unload&lt;/a&gt; ()를 사용하여 라이브러리 언로드를 시도 할 수 있지만 &lt;a href=&quot;qlibrary&quot;&gt;QLibrary의&lt;/a&gt; 다른 인스턴스가 동일한 라이브러리를 사용하는 경우 호출이 실패하며 모든 인스턴스가 &lt;a href=&quot;qlibrary#unload&quot;&gt;unload&lt;/a&gt; ()를 호출 한 경우에만 언로드가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="f155d8b6b275ef994af1cd1418517f920ae8c5c5" translate="yes" xml:space="preserve">
          <source>The most important functions are &lt;a href=&quot;qlibrary#load&quot;&gt;load&lt;/a&gt;() to dynamically load the library file, &lt;a href=&quot;qlibrary#isLoaded&quot;&gt;isLoaded&lt;/a&gt;() to check whether loading was successful, and &lt;a href=&quot;qlibrary#resolve&quot;&gt;resolve&lt;/a&gt;() to resolve a symbol in the library. The &lt;a href=&quot;qlibrary#resolve&quot;&gt;resolve&lt;/a&gt;() function implicitly tries to load the library if it has not been loaded yet. Multiple instances of QLibrary can be used to access the same physical library. Once loaded, libraries remain in memory until the application terminates. You can attempt to unload a library using &lt;a href=&quot;qlibrary#unload&quot;&gt;unload&lt;/a&gt;(), but if other instances of QLibrary are using the same library, the call will fail, and unloading will only happen when every instance has called &lt;a href=&quot;qlibrary#unload&quot;&gt;unload&lt;/a&gt;().</source>
          <target state="translated">가장 중요한 함수는 라이브러리 파일을 동적으로로드하기위한 &lt;a href=&quot;qlibrary#load&quot;&gt;load&lt;/a&gt; (), 성공적으로로드되었는지 확인하기위한 &lt;a href=&quot;qlibrary#isLoaded&quot;&gt;isLoaded&lt;/a&gt; () , 라이브러리에서 심볼을 확인하기위한 &lt;a href=&quot;qlibrary#resolve&quot;&gt;해결&lt;/a&gt; ()입니다. &lt;a href=&quot;qlibrary#resolve&quot;&gt;해결&lt;/a&gt; () 함수는 암시가 아직로드되지 않은 경우 라이브러리를로드하려고합니다. QLibrary의 여러 인스턴스를 사용하여 동일한 물리적 라이브러리에 액세스 할 수 있습니다. 일단로드되면 라이브러리는 애플리케이션이 종료 될 때까지 메모리에 남아 있습니다. &lt;a href=&quot;qlibrary#unload&quot;&gt;unload&lt;/a&gt; ()를 사용하여 라이브러리를 언로드 할 수 있지만 QLibrary의 다른 인스턴스가 동일한 라이브러리를 사용하는 경우 호출이 실패하고 언로드는 모든 인스턴스가 &lt;a href=&quot;qlibrary#unload&quot;&gt;unload&lt;/a&gt; ()를 호출 한 경우에만 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="f90807f717846cf773e37b42d91c6444f06fc3a6" translate="yes" xml:space="preserve">
          <source>The most important functions are &lt;a href=&quot;qpluginloader#load&quot;&gt;load&lt;/a&gt;() to dynamically load the plugin file, &lt;a href=&quot;qpluginloader#isLoaded&quot;&gt;isLoaded&lt;/a&gt;() to check whether loading was successful, and &lt;a href=&quot;qpluginloader#instance&quot;&gt;instance&lt;/a&gt;() to access the root component in the plugin. The &lt;a href=&quot;qpluginloader#instance&quot;&gt;instance&lt;/a&gt;() function implicitly tries to load the plugin if it has not been loaded yet. Multiple instances of &lt;a href=&quot;qpluginloader&quot;&gt;QPluginLoader&lt;/a&gt; can be used to access the same physical plugin.</source>
          <target state="translated">가장 중요한 기능은 플러그인 파일을 동적으로로드하는 &lt;a href=&quot;qpluginloader#load&quot;&gt;load&lt;/a&gt; (), 로드가 성공했는지 확인하는 &lt;a href=&quot;qpluginloader#isLoaded&quot;&gt;isLoaded&lt;/a&gt; () 및 플러그인의 루트 구성 요소에 액세스하는 &lt;a href=&quot;qpluginloader#instance&quot;&gt;인스턴스&lt;/a&gt; ()입니다. &lt;a href=&quot;qpluginloader#instance&quot;&gt;예&lt;/a&gt; () 함수는 암시가 아직로드되지 않은 경우 플러그인을로드하려고합니다. &lt;a href=&quot;qpluginloader&quot;&gt;QPluginLoader의&lt;/a&gt; 여러 인스턴스를 사용하여 동일한 물리적 플러그인에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="542b80930ca2ed4ab337a43d4daa2174b91a012e" translate="yes" xml:space="preserve">
          <source>The most important functions are &lt;a href=&quot;qpluginloader#load&quot;&gt;load&lt;/a&gt;() to dynamically load the plugin file, &lt;a href=&quot;qpluginloader#isLoaded&quot;&gt;isLoaded&lt;/a&gt;() to check whether loading was successful, and &lt;a href=&quot;qpluginloader#instance&quot;&gt;instance&lt;/a&gt;() to access the root component in the plugin. The &lt;a href=&quot;qpluginloader#instance&quot;&gt;instance&lt;/a&gt;() function implicitly tries to load the plugin if it has not been loaded yet. Multiple instances of QPluginLoader can be used to access the same physical plugin.</source>
          <target state="translated">가장 중요한 기능은 플러그인 파일을 동적으로로드하기위한 &lt;a href=&quot;qpluginloader#load&quot;&gt;load&lt;/a&gt; (), 로드 성공 여부를 확인하기위한 &lt;a href=&quot;qpluginloader#isLoaded&quot;&gt;isLoaded&lt;/a&gt; () , 플러그인의 루트 구성 요소에 액세스하기위한 &lt;a href=&quot;qpluginloader#instance&quot;&gt;인스턴스&lt;/a&gt; ()입니다. &lt;a href=&quot;qpluginloader#instance&quot;&gt;예&lt;/a&gt; () 함수는 암시가 아직로드되지 않은 경우 플러그인을로드하려고합니다. QPluginLoader의 여러 인스턴스를 사용하여 동일한 물리적 플러그인에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a0bddd8488893a937bd7e98fed8d81cdac3c7160" translate="yes" xml:space="preserve">
          <source>The most important limitation is that the Qt build is static, and does not support threads.</source>
          <target state="translated">가장 중요한 제한은 Qt 빌드가 정적이며 스레드를 지원하지 않는다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="84a7920f760a9ea577836c1378cbbb816b41e993" translate="yes" xml:space="preserve">
          <source>The most important modes or states are:</source>
          <target state="translated">가장 중요한 모드 또는 상태는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ba1c0d24d5259fab8c98b33ad7f506aabad303a4" translate="yes" xml:space="preserve">
          <source>The most important node for users is the &lt;a href=&quot;qsggeometrynode&quot;&gt;QSGGeometryNode&lt;/a&gt;. It is used to define custom graphics by defining its geometry and material. The geometry is defined using &lt;a href=&quot;qsggeometry&quot;&gt;QSGGeometry&lt;/a&gt; and describes the shape or mesh of the graphical primitive. It can be a line, a rectangle, a polygon, many disconnected rectangles, or complex 3D mesh. The material defines how the pixels in this shape are filled.</source>
          <target state="translated">사용자에게 가장 중요한 노드는 &lt;a href=&quot;qsggeometrynode&quot;&gt;QSGGeometryNode&lt;/a&gt; 입니다. 지오메트리 및 재질을 정의하여 사용자 정의 그래픽을 정의하는 데 사용됩니다. 기하학은 &lt;a href=&quot;qsggeometry&quot;&gt;QSGGeometry를&lt;/a&gt; 사용하여 정의 되며 그래픽 기본 요소의 모양 또는 메시를 설명합니다. 선, 사각형, 다각형, 연결이 끊긴 사각형 또는 복잡한 3D 메쉬 일 수 있습니다. 재질은이 모양의 픽셀이 채워지는 방법을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="ff58163c9bd5f70dda347b25fbb1f00a48df31d9" translate="yes" xml:space="preserve">
          <source>The most important parameters are &lt;code&gt;-device&lt;/code&gt; and &lt;code&gt;-sysroot&lt;/code&gt;. By specifying &lt;code&gt;-sysroot&lt;/code&gt;, the include files and libraries used by &lt;code&gt;configure&lt;/code&gt;'s feature detection tests, as well as Qt itself, are taken from the specified location, instead of the host PC's standard locations. Consequently, installing development packages on the host machine has no relevance. For example, to get &lt;code&gt;libinput&lt;/code&gt; support, it is not sufficient or necessary to have the &lt;code&gt;libinput&lt;/code&gt; development headers and libraries installed on the host environment. Instead, the headers and the libraries for the target architecture, such as ARM, must be present in the &lt;code&gt;sysroot&lt;/code&gt;.</source>
          <target state="translated">가장 중요한 매개 변수는 &lt;code&gt;-device&lt;/code&gt; 및 &lt;code&gt;-sysroot&lt;/code&gt; 입니다. &lt;code&gt;-sysroot&lt;/code&gt; 를 지정 하면 Qt 자체뿐만 아니라 &lt;code&gt;configure&lt;/code&gt; 의 기능 감지 테스트에 사용되는 포함 파일 및 라이브러리 가 호스트 PC의 표준 위치 대신 지정된 위치에서 가져옵니다. 결과적으로 호스트 시스템에 개발 패키지를 설치하는 것은 관련이 없습니다. 예를 들어, &lt;code&gt;libinput&lt;/code&gt; 지원 을 받으려면 호스트 환경에 &lt;code&gt;libinput&lt;/code&gt; 개발 헤더 및 라이브러리를 설치 하는 것만 으로는 충분하지 않습니다 . 대신 대상 아키텍처 (예 : ARM)의 헤더 및 라이브러리가 &lt;code&gt;sysroot&lt;/code&gt; 에 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="db87671be54de68d316f00bfd770809b6606b886" translate="yes" xml:space="preserve">
          <source>The most important parameters are &lt;code&gt;-device&lt;/code&gt;, &lt;code&gt;-device-option&lt;/code&gt; CROSS_COMPILE=&amp;lt;arch&amp;gt;, &lt;code&gt;-sysroot&lt;/code&gt; and &lt;code&gt;-no-gcc-sysroot&lt;/code&gt;. By specifying &lt;code&gt;-sysroot&lt;/code&gt;, the include files and libraries used by &lt;code&gt;configure&lt;/code&gt;'s feature detection tests, as well as Qt itself, will be taken from the specified location, instead of the host PC's standard locations. This means that installing development packages on the host machine has no relevance. Instead, the headers and the libraries for the target architecture (e.g. ARM) have to be present in the sysroot.</source>
          <target state="translated">가장 중요한 매개 변수는 &lt;code&gt;-device&lt;/code&gt; , &lt;code&gt;-device-option&lt;/code&gt; CROSS_COMPILE = &amp;lt;arch&amp;gt;, &lt;code&gt;-sysroot&lt;/code&gt; 및 &lt;code&gt;-no-gcc-sysroot&lt;/code&gt; 입니다. &lt;code&gt;-sysroot&lt;/code&gt; 를 지정 하면 &lt;code&gt;configure&lt;/code&gt; 기능 검사 테스트에 사용 된 포함 파일 및 라이브러리 와 Qt 자체가 호스트 PC의 표준 위치 대신 지정된 위치에서 가져옵니다. 즉, 호스트 시스템에 개발 패키지를 설치하면 관련이 없습니다. 대신 대상 아키텍처 (예 : ARM)의 헤더 및 라이브러리가 sysroot에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="ca622b5fddbc29c66b9d38eb754c2ee834b40271" translate="yes" xml:space="preserve">
          <source>The most important parameters are:</source>
          <target state="translated">가장 중요한 매개 변수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="11194d8293cc08a60b190404c9b817b2a22c92f7" translate="yes" xml:space="preserve">
          <source>The most important part of &lt;a href=&quot;qtabbar&quot;&gt;QTabBar&lt;/a&gt;'s API is the &lt;a href=&quot;qtabbar#currentChanged&quot;&gt;currentChanged&lt;/a&gt;() signal. This is emitted whenever the current tab changes (even at startup, when the current tab changes from 'none'). There is also a slot, &lt;a href=&quot;qtabbar#currentIndex-prop&quot;&gt;setCurrentIndex&lt;/a&gt;(), which can be used to select a tab programmatically. The function &lt;a href=&quot;qtabbar#currentIndex-prop&quot;&gt;currentIndex&lt;/a&gt;() returns the index of the current tab, &lt;a href=&quot;qtabbar#count-prop&quot;&gt;count&lt;/a&gt; holds the number of tabs.</source>
          <target state="translated">&lt;a href=&quot;qtabbar&quot;&gt;QTabBar&lt;/a&gt; API 의 가장 중요한 부분은 &lt;a href=&quot;qtabbar#currentChanged&quot;&gt;currentChanged&lt;/a&gt; () 신호입니다. 현재 탭이 변경 될 때마다 (시작시에도 현재 탭이 '없음'에서 변경 될 때) 방출됩니다. 프로그래밍 방식으로 탭을 선택하는 데 사용할 수 있는 슬롯 &lt;a href=&quot;qtabbar#currentIndex-prop&quot;&gt;setCurrentIndex&lt;/a&gt; ()도 있습니다. &lt;a href=&quot;qtabbar#currentIndex-prop&quot;&gt;currentIndex&lt;/a&gt; () 함수 는 현재 탭의 인덱스를 반환하며 &lt;a href=&quot;qtabbar#count-prop&quot;&gt;count&lt;/a&gt; 는 탭 수를 보유합니다.</target>
        </trans-unit>
        <trans-unit id="0597cc4b3b112c9a63cd24d0d3460d043984dac9" translate="yes" xml:space="preserve">
          <source>The most important part of QTabBar's API is the &lt;a href=&quot;qtabbar#currentChanged&quot;&gt;currentChanged&lt;/a&gt;() signal. This is emitted whenever the current tab changes (even at startup, when the current tab changes from 'none'). There is also a slot, &lt;a href=&quot;qtabbar#currentIndex-prop&quot;&gt;setCurrentIndex&lt;/a&gt;(), which can be used to select a tab programmatically. The function &lt;a href=&quot;qtabbar#currentIndex-prop&quot;&gt;currentIndex&lt;/a&gt;() returns the index of the current tab, &lt;a href=&quot;qtabbar#count-prop&quot;&gt;count&lt;/a&gt; holds the number of tabs.</source>
          <target state="translated">QTabBar의 API에서 가장 중요한 부분은 &lt;a href=&quot;qtabbar#currentChanged&quot;&gt;currentChanged&lt;/a&gt; () 신호입니다. 현재 탭이 변경 될 때마다 (시작할 때에도 현재 탭이 '없음'에서 변경 될 때) 방출됩니다. 프로그래밍 방식으로 탭을 선택하는 데 사용할 수 있는 슬롯 인 &lt;a href=&quot;qtabbar#currentIndex-prop&quot;&gt;setCurrentIndex&lt;/a&gt; ()도 있습니다. &lt;a href=&quot;qtabbar#currentIndex-prop&quot;&gt;currentIndex&lt;/a&gt; () 함수 는 현재 탭의 인덱스를 반환하고 &lt;a href=&quot;qtabbar#count-prop&quot;&gt;count&lt;/a&gt; 는 탭 수를 보유합니다.</target>
        </trans-unit>
        <trans-unit id="6e3c4cd02f92d0ca8be0de1a2b5ea89990122b97" translate="yes" xml:space="preserve">
          <source>The most important properties are &lt;a href=&quot;qml-qtquick-accessible#name-prop&quot;&gt;name&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-accessible#description-prop&quot;&gt;description&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-accessible#role-prop&quot;&gt;role&lt;/a&gt;.</source>
          <target state="translated">가장 중요한 속성은 &lt;a href=&quot;qml-qtquick-accessible#name-prop&quot;&gt;이름&lt;/a&gt; , &lt;a href=&quot;qml-qtquick-accessible#description-prop&quot;&gt;설명&lt;/a&gt; 및 &lt;a href=&quot;qml-qtquick-accessible#role-prop&quot;&gt;역할&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9172997b55a23bcb7de482210f0f8efa5ee0f81e" translate="yes" xml:space="preserve">
          <source>The most important properties are &lt;a href=&quot;qml-qtquick-accessible#name-prop&quot;&gt;name&lt;/a&gt;, &lt;a href=&quot;qtqml-cmake-qt5-import-qml-plugins#description&quot;&gt;description&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-accessible#role-prop&quot;&gt;role&lt;/a&gt;.</source>
          <target state="translated">가장 중요한 속성은 &lt;a href=&quot;qml-qtquick-accessible#name-prop&quot;&gt;이름&lt;/a&gt; , &lt;a href=&quot;qtqml-cmake-qt5-import-qml-plugins#description&quot;&gt;설명&lt;/a&gt; 및 &lt;a href=&quot;qml-qtquick-accessible#role-prop&quot;&gt;역할&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8d4b3eab8a2c0a58659ef573fd7ab3da932ebe04" translate="yes" xml:space="preserve">
          <source>The most important properties of frames are &lt;code&gt;frameShape&lt;/code&gt;, &lt;code&gt;frameShadow&lt;/code&gt;, &lt;code&gt;lineWidth&lt;/code&gt;, and &lt;code&gt;midLineWidth&lt;/code&gt;. These are described in more detail in the &lt;a href=&quot;qframe&quot;&gt;QFrame&lt;/a&gt; class description.</source>
          <target state="translated">프레임의 가장 중요한 속성은 &lt;code&gt;frameShape&lt;/code&gt; , &lt;code&gt;frameShadow&lt;/code&gt; , &lt;code&gt;lineWidth&lt;/code&gt; 및 &lt;code&gt;midLineWidth&lt;/code&gt; 입니다. 이것들은 &lt;a href=&quot;qframe&quot;&gt;QFrame&lt;/a&gt; 클래스 설명 에 더 자세히 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="5fb53c0d52741963a4203438d52e2bf7eae2174f" translate="yes" xml:space="preserve">
          <source>The most important tip is: use the QML profiler included with Qt Creator. Knowing where time is spent in an application will allow you to focus on problem areas which actually exist, rather than problem areas which potentially exist. See the Qt Creator manual for more information on how to use the QML profiling tool.</source>
          <target state="translated">가장 중요한 팁은 Qt Creator에 포함 된 QML 프로파일 러를 사용하는 것입니다. 응용 프로그램에서 시간이 소비되는 위치를 알면 잠재적으로 존재하는 문제 영역이 아니라 실제로 존재하는 문제 영역에 집중할 수 있습니다. QML 프로파일 링 도구 사용 방법에 대한 자세한 내용은 Qt Creator 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="cf514f3fadcb63f428ee341023509db58307acaa" translate="yes" xml:space="preserve">
          <source>The most interesting information held in a &lt;a href=&quot;qml-qtlocation-routemaneuver&quot;&gt;RouteManeuver&lt;/a&gt; instance is normally the textual navigation to provide and the position at which to provide it, accessible by &lt;a href=&quot;qml-qtlocation-routemaneuver#instructionText-prop&quot;&gt;instructionText&lt;/a&gt; and &lt;a href=&quot;qml-qtlocation-routemaneuver#position-prop&quot;&gt;position&lt;/a&gt; respectively.</source>
          <target state="translated">&lt;a href=&quot;qml-qtlocation-routemaneuver&quot;&gt;RouteManeuver&lt;/a&gt; 인스턴스에 보유 된 가장 흥미로운 정보 는 일반적으로 제공 할 텍스트 탐색 및 제공 위치, &lt;a href=&quot;qml-qtlocation-routemaneuver#instructionText-prop&quot;&gt;instructionText&lt;/a&gt; 및 &lt;a href=&quot;qml-qtlocation-routemaneuver#position-prop&quot;&gt;위치에&lt;/a&gt; 의해 각각 액세스 가능합니다 .</target>
        </trans-unit>
        <trans-unit id="c5addd5aef850eff1d1bbf4bcd0dd53e91ea1190" translate="yes" xml:space="preserve">
          <source>The most interesting information held in a RouteManeuver instance is normally the textual navigation to provide and the position at which to provide it, accessible by &lt;a href=&quot;qml-qtlocation-routemaneuver#instructionText-prop&quot;&gt;instructionText&lt;/a&gt; and &lt;a href=&quot;qml-qtlocation-routemaneuver#position-prop&quot;&gt;position&lt;/a&gt; respectively.</source>
          <target state="translated">RouteManeuver 인스턴스에 포함 된 가장 흥미로운 정보는 일반적으로 제공 할 텍스트 탐색과이를 제공 할 &lt;a href=&quot;qml-qtlocation-routemaneuver#position-prop&quot;&gt;위치&lt;/a&gt; 이며 각각 &lt;a href=&quot;qml-qtlocation-routemaneuver#instructionText-prop&quot;&gt;instructionText&lt;/a&gt; 및 position으로 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9bba8a52a5116b760a5c50bf0c0410b2e4bbb4fd" translate="yes" xml:space="preserve">
          <source>The most interesting information help in a &lt;a href=&quot;qgeomaneuver&quot;&gt;QGeoManeuver&lt;/a&gt; instance is normally the textual navigation to provide and the position at which to provide it, accessible by &lt;a href=&quot;qgeomaneuver#instructionText&quot;&gt;instructionText&lt;/a&gt;() and &lt;a href=&quot;qgeomaneuver#position&quot;&gt;position&lt;/a&gt;() respectively.</source>
          <target state="translated">&lt;a href=&quot;qgeomaneuver&quot;&gt;QGeoManeuver&lt;/a&gt; 인스턴스 에서 가장 흥미로운 정보 도움말 은 일반적으로 제공 할 텍스트 탐색 및이를 제공 할 위치로, &lt;a href=&quot;qgeomaneuver#instructionText&quot;&gt;instructionText&lt;/a&gt; () 및 &lt;a href=&quot;qgeomaneuver#position&quot;&gt;position&lt;/a&gt; ()에 의해 각각 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee1e3eef5c25ece2cbb1e1cb035e83ac07d72c35" translate="yes" xml:space="preserve">
          <source>The most interesting information help in a QGeoManeuver instance is normally the textual navigation to provide and the position at which to provide it, accessible by &lt;a href=&quot;qgeomaneuver#instructionText&quot;&gt;instructionText&lt;/a&gt;() and &lt;a href=&quot;qgeomaneuver#position&quot;&gt;position&lt;/a&gt;() respectively.</source>
          <target state="translated">QGeoManeuver 인스턴스에서 가장 흥미로운 정보 도움말은 일반적으로 제공 할 텍스트 탐색 및 제공 할 &lt;a href=&quot;qgeomaneuver#position&quot;&gt;위치&lt;/a&gt; 이며 각각 &lt;a href=&quot;qgeomaneuver#instructionText&quot;&gt;instructionText&lt;/a&gt; () 및 position () 을 통해 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc614a22c7900279c2581c5dcff1b8a7bd96984b" translate="yes" xml:space="preserve">
          <source>The most specific delegates are declared first: the columns at index &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt; have &lt;code&gt;bool&lt;/code&gt; and &lt;code&gt;integer&lt;/code&gt; data types, so they use a &lt;a href=&quot;qml-qtquick-controls2-checkbox&quot;&gt;CheckBox&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-controls2-spinbox&quot;&gt;SpinBox&lt;/a&gt;, respectively. The remaining columns can simply use a &lt;a href=&quot;qml-qtquick-controls2-textfield&quot;&gt;TextField&lt;/a&gt;, and so that delegate is declared last as a fallback.</source>
          <target state="translated">가장 구체적인 대리자가 먼저 선언됩니다. 인덱스 &lt;code&gt;0&lt;/code&gt; 과 &lt;code&gt;1&lt;/code&gt; 의 열에 는 &lt;code&gt;bool&lt;/code&gt; 및 &lt;code&gt;integer&lt;/code&gt; 데이터 형식이 있으므로 각각 &lt;a href=&quot;qml-qtquick-controls2-checkbox&quot;&gt;CheckBox&lt;/a&gt; 및 &lt;a href=&quot;qml-qtquick-controls2-spinbox&quot;&gt;SpinBox&lt;/a&gt; 를 사용합니다 . 나머지 열은 단순히 &lt;a href=&quot;qml-qtquick-controls2-textfield&quot;&gt;TextField&lt;/a&gt; 를 사용할 수 있으므로 대리자는 마지막으로 대체로 선언됩니다.</target>
        </trans-unit>
        <trans-unit id="03e5f595b706dd89beb005f0216e8602ad8f1055" translate="yes" xml:space="preserve">
          <source>The most straight-forward way to setup tool tips for controls is to specify &lt;a href=&quot;qml-qtquick-controls2-tooltip#text-attached-prop&quot;&gt;text&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-controls2-tooltip#visible-attached-prop&quot;&gt;visibility&lt;/a&gt; via attached properties. The following example illustrates this approach:</source>
          <target state="translated">컨트롤에 대한 도구 설명을 설정하는 가장 간단한 방법은 첨부 된 속성을 통해 &lt;a href=&quot;qml-qtquick-controls2-tooltip#text-attached-prop&quot;&gt;텍스트&lt;/a&gt; 와 &lt;a href=&quot;qml-qtquick-controls2-tooltip#visible-attached-prop&quot;&gt;가시성&lt;/a&gt; 을 지정하는 것 입니다. 다음 예제는이 접근법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="a4d51d039fef172545b538c5020375d8f06650d1" translate="yes" xml:space="preserve">
          <source>The most straight-forward way to use &lt;a href=&quot;qml-qt-labs-platform-menuitemgroup&quot;&gt;MenuItemGroup&lt;/a&gt; is to assign a list of items.</source>
          <target state="translated">&lt;a href=&quot;qml-qt-labs-platform-menuitemgroup&quot;&gt;MenuItemGroup&lt;/a&gt; 을 사용하는 가장 간단한 방법 은 항목 목록을 지정하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="61b2fff50270b3a58495f59ce8c26aa34e491899" translate="yes" xml:space="preserve">
          <source>The most straight-forward way to use &lt;a href=&quot;qml-qtquick-controls2-actiongroup&quot;&gt;ActionGroup&lt;/a&gt; is to declare actions as children of the group.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-controls2-actiongroup&quot;&gt;ActionGroup&lt;/a&gt; 을 사용하는 가장 간단한 방법 은 조치를 그룹의 하위로 선언하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="d5497b94c89793e9a2a385d877dc29d0014e9f97" translate="yes" xml:space="preserve">
          <source>The most straight-forward way to use &lt;a href=&quot;qml-qtquick-controls2-buttongroup&quot;&gt;ButtonGroup&lt;/a&gt; is to assign a list of buttons. For example, the list of children of a &lt;a href=&quot;qtquick-positioning-layouts&quot;&gt;positioner&lt;/a&gt; or a &lt;a href=&quot;qtquicklayouts-index&quot;&gt;layout&lt;/a&gt; that manages a group of mutually exclusive buttons.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-controls2-buttongroup&quot;&gt;ButtonGroup&lt;/a&gt; 을 사용하는 가장 간단한 방법 은 버튼 목록을 지정하는 것입니다. 예를 들어 &lt;a href=&quot;qtquick-positioning-layouts&quot;&gt;포지셔너&lt;/a&gt; 의 하위 목록 또는 상호 배타적 인 버튼 그룹을 관리하는 &lt;a href=&quot;qtquicklayouts-index&quot;&gt;레이아웃&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6d223fab5d3501fdaa12da1d6d613aede8804caa" translate="yes" xml:space="preserve">
          <source>The most straight-forward way to use ActionGroup is to declare actions as children of the group.</source>
          <target state="translated">ActionGroup을 사용하는 가장 간단한 방법은 작업을 그룹의 자식으로 선언하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="b243340ac1714ceb2fcd1b088ac229d3093c1143" translate="yes" xml:space="preserve">
          <source>The most straight-forward way to use ButtonGroup is to assign a list of buttons. For example, the list of children of a &lt;a href=&quot;qtquick-positioning-layouts&quot;&gt;positioner&lt;/a&gt; or a &lt;a href=&quot;qtquicklayouts-index&quot;&gt;layout&lt;/a&gt; that manages a group of mutually exclusive buttons.</source>
          <target state="translated">ButtonGroup을 사용하는 가장 간단한 방법은 버튼 목록을 할당하는 것입니다. 예를 들어, &lt;a href=&quot;qtquick-positioning-layouts&quot;&gt;포지셔너&lt;/a&gt; 의 하위 목록 또는 상호 배타적 인 버튼 그룹을 관리하는 &lt;a href=&quot;qtquicklayouts-index&quot;&gt;레이아웃&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f763760370692df8d60b3c45932300661a71dd08" translate="yes" xml:space="preserve">
          <source>The most straight-forward way to use MenuItemGroup is to assign a list of items.</source>
          <target state="translated">MenuItemGroup을 사용하는 가장 간단한 방법은 항목 목록을 할당하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="bf1e9f532a7d2a326bbb5e05543ea5c9c2135759" translate="yes" xml:space="preserve">
          <source>The mouse</source>
          <target state="translated">마우스</target>
        </trans-unit>
        <trans-unit id="a0a5e9a726ae51e9830836fa9f673ee593ef7b4e" translate="yes" xml:space="preserve">
          <source>The mouse and keyboard states are specified by</source>
          <target state="translated">마우스 및 키보드 상태는</target>
        </trans-unit>
        <trans-unit id="3e6f9e24674f941d97192b30da97f7e8d51ca4d8" translate="yes" xml:space="preserve">
          <source>The mouse and keyboard states at the time of the event are specified by</source>
          <target state="translated">이벤트 시점의 마우스 및 키보드 상태는</target>
        </trans-unit>
        <trans-unit id="0389dd7ddb098da576180d61b8fa9c82c12bf721" translate="yes" xml:space="preserve">
          <source>The mouse axis.</source>
          <target state="translated">마우스 축</target>
        </trans-unit>
        <trans-unit id="0976ac36f70286d38ade73236d0f61b57bd4d940" translate="yes" xml:space="preserve">
          <source>The mouse buttons which can activate this Pointer Handler.</source>
          <target state="translated">이 포인터 핸들러를 활성화 할 수있는 마우스 버튼.</target>
        </trans-unit>
        <trans-unit id="140403094cb3346f15ed78bbb8faa0f9934ac757" translate="yes" xml:space="preserve">
          <source>The mouse caused the event to be sent. Normally this means the right mouse button was clicked, but this is platform dependent.</source>
          <target state="translated">마우스로 인해 이벤트가 전송되었습니다. 일반적으로 마우스 오른쪽 버튼을 클릭했지만 플랫폼에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="6cf56341d71cd346e5683a4bb68ad6c441d739c6" translate="yes" xml:space="preserve">
          <source>The mouse caused the event to be sent. On most platforms, this means the right mouse button was clicked.</source>
          <target state="translated">마우스로 인해 이벤트가 전송되었습니다. 대부분의 플랫폼에서 마우스 오른쪽 버튼을 클릭했음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="479e3b71636578ab0546fcd0b09252d3f13bc2bb" translate="yes" xml:space="preserve">
          <source>The mouse cursor enters a hover item in a graphics scene (&lt;a href=&quot;qgraphicsscenehoverevent&quot;&gt;QGraphicsSceneHoverEvent&lt;/a&gt;).</source>
          <target state="translated">마우스 커서는 그래픽 장면 ( &lt;a href=&quot;qgraphicsscenehoverevent&quot;&gt;QGraphicsSceneHoverEvent&lt;/a&gt; ) 에서 호버 항목을 입력합니다 .</target>
        </trans-unit>
        <trans-unit id="7f69f1581a82dfdf00c9c85699c28e98d438eed7" translate="yes" xml:space="preserve">
          <source>The mouse cursor enters a hover widget (&lt;a href=&quot;qhoverevent&quot;&gt;QHoverEvent&lt;/a&gt;).</source>
          <target state="translated">마우스 커서가 호버 위젯 ( &lt;a href=&quot;qhoverevent&quot;&gt;QHoverEvent&lt;/a&gt; )으로 들어갑니다 .</target>
        </trans-unit>
        <trans-unit id="58182c627a7b38977f43547a48e621a8830cfd0f" translate="yes" xml:space="preserve">
          <source>The mouse cursor is used to change focus, it is displayed only on non touchscreen devices. The keypad is used to implement a virtual cursor, unless the device has an analog mouse type of input device (e.g. touchpad). This is the recommended setting for an application such as a web browser that needs pointer control on both touch and non-touch devices.</source>
          <target state="translated">마우스 커서는 초점을 변경하는 데 사용되며 터치 스크린이 아닌 장치에만 표시됩니다. 장치에 아날로그 마우스 유형의 입력 장치 (예 : 터치 패드)가없는 경우 키패드는 가상 커서를 구현하는 데 사용됩니다. 터치 및 비 터치 장치 모두에서 포인터를 제어해야하는 웹 브라우저와 같은 응용 프로그램에 권장되는 설정입니다.</target>
        </trans-unit>
        <trans-unit id="e44018d62fb4442702780f0c28cec38aff1be1ba" translate="yes" xml:space="preserve">
          <source>The mouse cursor is used to change focus, it is displayed regardless of device type. The keypad is used to implement a virtual cursor, unless the device has an analog mouse type of input device (e.g. touchpad)</source>
          <target state="translated">마우스 커서는 초점을 변경하는 데 사용되며 장치 유형에 관계없이 표시됩니다. 장치에 아날로그 마우스 유형의 입력 장치 (예 : 터치 패드)가없는 경우 키패드는 가상 커서를 구현하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="813ebe6da355938f8cdbea6ff4078574af586789" translate="yes" xml:space="preserve">
          <source>The mouse cursor leaves a hover item in a graphics scene (&lt;a href=&quot;qgraphicsscenehoverevent&quot;&gt;QGraphicsSceneHoverEvent&lt;/a&gt;).</source>
          <target state="translated">마우스 커서는 그래픽 장면 ( &lt;a href=&quot;qgraphicsscenehoverevent&quot;&gt;QGraphicsSceneHoverEvent&lt;/a&gt; ) 에 호버 항목을 남깁니다 .</target>
        </trans-unit>
        <trans-unit id="9921a17d9b26e3aceb5ff0d5a4b3a81ca72bd2b4" translate="yes" xml:space="preserve">
          <source>The mouse cursor leaves a hover widget (&lt;a href=&quot;qhoverevent&quot;&gt;QHoverEvent&lt;/a&gt;).</source>
          <target state="translated">마우스 커서는 호버 위젯 ( &lt;a href=&quot;qhoverevent&quot;&gt;QHoverEvent&lt;/a&gt; )을 떠 납니다 .</target>
        </trans-unit>
        <trans-unit id="427ea11ac35e82b153aa7a41551f1d157631dea3" translate="yes" xml:space="preserve">
          <source>The mouse cursor moves inside a hover item in a graphics scene (&lt;a href=&quot;qgraphicsscenehoverevent&quot;&gt;QGraphicsSceneHoverEvent&lt;/a&gt;).</source>
          <target state="translated">마우스 커서는 그래픽 장면 ( &lt;a href=&quot;qgraphicsscenehoverevent&quot;&gt;QGraphicsSceneHoverEvent&lt;/a&gt; ) 에서 호버 항목 내부로 이동합니다 .</target>
        </trans-unit>
        <trans-unit id="dcaf274694a4dbde2f0cbf63cbdd7cd344504347" translate="yes" xml:space="preserve">
          <source>The mouse cursor moves inside a hover widget (&lt;a href=&quot;qhoverevent&quot;&gt;QHoverEvent&lt;/a&gt;).</source>
          <target state="translated">마우스 커서가 호버 위젯 ( &lt;a href=&quot;qhoverevent&quot;&gt;QHoverEvent&lt;/a&gt; ) 내에서 이동 합니다.</target>
        </trans-unit>
        <trans-unit id="8f9beb3f3aa1bcdc014b4c9804c53a8af32f98e3" translate="yes" xml:space="preserve">
          <source>The mouse cursor shows up whenever &lt;code&gt;QT_QPA_EGLFS_HIDECURSOR&lt;/code&gt; (for &lt;code&gt;eglfs&lt;/code&gt;) or &lt;code&gt;QT_QPA_FB_HIDECURSOR&lt;/code&gt; (for &lt;code&gt;linuxfb&lt;/code&gt;) isn't set and Qt's libudev-based device discovery reports that at least one mouse is available. When &lt;code&gt;libudev&lt;/code&gt; support is not present, the mouse cursor is always displayed; unless it's explicitly disabled via the environment variable.</source>
          <target state="translated">마우스 커서는 &lt;code&gt;QT_QPA_EGLFS_HIDECURSOR&lt;/code&gt; ( &lt;code&gt;eglfs&lt;/code&gt; 의 경우 ) 또는 &lt;code&gt;QT_QPA_FB_HIDECURSOR&lt;/code&gt; ( &lt;code&gt;linuxfb&lt;/code&gt; 의 경우 )가 설정되지 않고 Qt의 libudev 기반 장치 검색에서 하나 이상의 마우스를 사용할 수 있다고보고 할 때마다 표시됩니다 . 때 &lt;code&gt;libudev&lt;/code&gt; 의 지원이 존재하지 않는, 마우스 커서가 항상 표시됩니다; 환경 변수를 통해 명시 적으로 비활성화하지 않는 한.</target>
        </trans-unit>
        <trans-unit id="65971bcca08552a0b82589b9e45b4d11b27a629d" translate="yes" xml:space="preserve">
          <source>The mouse cursor shows up whenever &lt;code&gt;QT_QPA_EGLFS_HIDECURSOR&lt;/code&gt; (for eglfs) or &lt;code&gt;QT_QPA_FB_HIDECURSOR&lt;/code&gt; (for linuxfb) is not set and Qt's libudev-based device discovery reports that at least one mouse is available. When &lt;code&gt;libudev&lt;/code&gt; support is not present, the mouse cursor always show up unless explicitly disabled via the environment variable.</source>
          <target state="translated">마우스 커서는 &lt;code&gt;QT_QPA_EGLFS_HIDECURSOR&lt;/code&gt; (eglfs) 또는 &lt;code&gt;QT_QPA_FB_HIDECURSOR&lt;/code&gt; (linuxfb)가 설정되어 있지 않고 Qt의 libudev 기반 장치 발견에서 최소한 하나의 마우스를 사용할 수 있다고보고합니다. 때 &lt;code&gt;libudev&lt;/code&gt; 의 지원이 존재하지 않는 명시 적으로 환경 변수를 통해 해제하지 않는 한, 마우스 커서가 항상 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="a5f192e6b6baa262c4bb7c306a11d6042cacd095" translate="yes" xml:space="preserve">
          <source>The mouse cursor will assume this shape when it is over this item, unless an override cursor is set. See the &lt;a href=&quot;qt#CursorShape-enum&quot;&gt;list of predefined cursor objects&lt;/a&gt; for a range of useful shapes.</source>
          <target state="translated">재정의 커서가 설정되어 있지 않으면 마우스 커서는이 항목 위에있을 때이 모양을 가정합니다. 유용한 모양의 범위는 &lt;a href=&quot;qt#CursorShape-enum&quot;&gt;사전 정의 된 커서 객체 목록을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0a7df2929dc948955f28195935209b2efcf68216" translate="yes" xml:space="preserve">
          <source>The mouse cursor will assume this shape when it's over this widget. See the &lt;a href=&quot;qt#CursorShape-enum&quot;&gt;list of predefined cursor objects&lt;/a&gt; for a range of useful shapes.</source>
          <target state="translated">마우스 커서는이 위젯 위에있을 때이 모양을 가정합니다. 유용한 모양의 범위는 &lt;a href=&quot;qt#CursorShape-enum&quot;&gt;사전 정의 된 커서 객체 목록을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="596ed169391f55d7813ef8d821177c51489a917c" translate="yes" xml:space="preserve">
          <source>The mouse cursor will show up whenever &lt;code&gt;QT_QPA_EGLFS_HIDECURSOR&lt;/code&gt; (for eglfs) or &lt;code&gt;QT_QPA_FB_HIDECURSOR&lt;/code&gt; (for vxworksfb) is not set, the mouse cursor will always show up unless explicitly disabled via the environment variable.</source>
          <target state="translated">마우스 커서는 &lt;code&gt;QT_QPA_EGLFS_HIDECURSOR&lt;/code&gt; (eglfs) 또는 &lt;code&gt;QT_QPA_FB_HIDECURSOR&lt;/code&gt; (vxworksfb)가 설정되지 않은 경우 환경 변수를 통해 명시 적으로 비활성화되지 않은 경우 항상 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="0ae182011bb0516b2ef9a9ef751907cb0e92b16b" translate="yes" xml:space="preserve">
          <source>The mouse event flags provide additional information about a mouse event.</source>
          <target state="translated">마우스 이벤트 플래그는 마우스 이벤트에 대한 추가 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="3c8f88e42dc86c0ea4ee0447bec8f164b4f25545" translate="yes" xml:space="preserve">
          <source>The mouse event source can be used to distinguish between genuine and artificial mouse events. The latter are events that are synthesized from touch events by the operating system or Qt itself.</source>
          <target state="translated">마우스 이벤트 소스를 사용하여 정품 마우스 이벤트와 인공 마우스 이벤트를 구별 할 수 있습니다. 후자는 운영 체제 또는 Qt 자체에 의해 터치 이벤트로부터 합성 된 이벤트입니다.</target>
        </trans-unit>
        <trans-unit id="1c253f4e022979d6f8284e09fa5d0f9f525d0fe0" translate="yes" xml:space="preserve">
          <source>The mouse event source can be used to distinguish between genuine and artificial mouse events. When using other pointing devices such as touchscreens and graphics tablets, if the application does not make use of the actual touch or tablet events, mouse events may be synthesized by the operating system or by Qt itself.</source>
          <target state="translated">마우스 이벤트 소스를 사용하여 정품 마우스 이벤트와 인공 마우스 이벤트를 구별 할 수 있습니다. 터치 스크린 및 그래픽 태블릿과 같은 다른 포인팅 장치를 사용할 때 응용 프로그램에서 실제 터치 또는 태블릿 이벤트를 사용하지 않는 경우 마우스 이벤트는 운영 체제 또는 Qt 자체에 의해 합성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7494386dc21af75815eee436e0f798a06959b6b0" translate="yes" xml:space="preserve">
          <source>The mouse is hovering over the item.</source>
          <target state="translated">마우스를 항목 위로 가져갑니다.</target>
        </trans-unit>
        <trans-unit id="28a2bd0e77f249a2271f79c2956cd468d3cba2b7" translate="yes" xml:space="preserve">
          <source>The mouse is over the action and the action is not a separator.</source>
          <target state="translated">마우스가 동작 위에 있고 동작이 구분자가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="e68032e20d74f3e8a68fc3b3e70da4c86c5501e0" translate="yes" xml:space="preserve">
          <source>The mouse is pressed down on the menu item.</source>
          <target state="translated">메뉴 항목에서 마우스를 눌렀습니다.</target>
        </trans-unit>
        <trans-unit id="ded3b87d2f4e4d7a9149dbd29e84d52a298fa171" translate="yes" xml:space="preserve">
          <source>The mouse pointer has moved.</source>
          <target state="translated">마우스 포인터가 움직였습니다.</target>
        </trans-unit>
        <trans-unit id="e0292a88f29c53989407c1d3afb3f0d654bf491f" translate="yes" xml:space="preserve">
          <source>The mouse press event decides which item should become the mouse grabber (see &lt;a href=&quot;qgraphicsscene#mouseGrabberItem&quot;&gt;QGraphicsScene::mouseGrabberItem&lt;/a&gt;()). If you do not reimplement this function, the press event will propagate to any topmost item beneath this item, and no other mouse events will be delivered to this item.</source>
          <target state="translated">마우스 프레스 이벤트는 마우스 그래버가 될 항목을 결정합니다 ( &lt;a href=&quot;qgraphicsscene#mouseGrabberItem&quot;&gt;QGraphicsScene :: mouseGrabberItem&lt;/a&gt; () 참조). 이 기능을 다시 구현하지 않으면 프레스 이벤트가이 항목 아래의 최상위 항목으로 전파되고 다른 마우스 이벤트는이 항목으로 전달되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6649d33deeab3440914c09d1a01b95b261ecbda8" translate="yes" xml:space="preserve">
          <source>The mouse tracking state has changed.</source>
          <target state="translated">마우스 추적 상태가 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="387018774791ec6eb410da8b801bcb25e784b14e" translate="yes" xml:space="preserve">
          <source>The move velocity and duration properties are used to control movement due to index changes; for example, when &lt;a href=&quot;qml-qtquick-listview#incrementCurrentIndex-method&quot;&gt;incrementCurrentIndex()&lt;/a&gt; is called. When the user flicks a &lt;a href=&quot;qml-qtquick-listview&quot;&gt;ListView&lt;/a&gt;, the velocity from the flick is used to control the movement instead.</source>
          <target state="translated">이동 속도 및 지속 시간 속성은 인덱스 변경으로 인한 이동을 제어하는 ​​데 사용됩니다. 예를 들어 &lt;a href=&quot;qml-qtquick-listview#incrementCurrentIndex-method&quot;&gt;incrementCurrentIndex ()&lt;/a&gt; 가 호출 될 때 사용자가 &lt;a href=&quot;qml-qtquick-listview&quot;&gt;ListView를&lt;/a&gt; 튕기는 경우 긋기 속도가 대신 이동을 제어하는 ​​데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c519b2abd415be540972191a4e926fdc747e0400" translate="yes" xml:space="preserve">
          <source>The moved-from pen can only be assigned to, copied, or destroyed. Any other operation (prior to assignment) leads to undefined behavior.</source>
          <target state="translated">이동 한 펜은 할당, 복사 또는 파기 만 할 수 있습니다. 다른 작업 (할당 이전)은 정의되지 않은 동작으로 이어집니다.</target>
        </trans-unit>
        <trans-unit id="1958483ebe6252d065dcb4ffe52d80d5428df536" translate="yes" xml:space="preserve">
          <source>The movie is not running. This is &lt;a href=&quot;qmovie&quot;&gt;QMovie&lt;/a&gt;'s initial state, and the state it enters after &lt;a href=&quot;qmovie#stop&quot;&gt;stop&lt;/a&gt;() has been called or the movie is finished.</source>
          <target state="translated">영화가 작동하지 않습니다. 이것이 &lt;a href=&quot;qmovie&quot;&gt;QMovie&lt;/a&gt; 의 초기 상태이며 &lt;a href=&quot;qmovie#stop&quot;&gt;stop&lt;/a&gt; ()이 호출되거나 영화가 완료된 후에 들어가는 상태 입니다.</target>
        </trans-unit>
        <trans-unit id="a3d7ad4a1537000ce73b186c91921a8b85237403" translate="yes" xml:space="preserve">
          <source>The movie is paused, and &lt;a href=&quot;qmovie&quot;&gt;QMovie&lt;/a&gt; stops emitting &lt;a href=&quot;qmovie#updated&quot;&gt;updated&lt;/a&gt;() or &lt;a href=&quot;qmovie#resized&quot;&gt;resized&lt;/a&gt;(). This state is entered after calling pause() or &lt;a href=&quot;qmovie#setPaused&quot;&gt;setPaused&lt;/a&gt;(true). The current frame number it kept, and the movie will continue with the next frame when unpause() or &lt;a href=&quot;qmovie#setPaused&quot;&gt;setPaused&lt;/a&gt;(false) is called.</source>
          <target state="translated">동영상이 일시 정지되고 &lt;a href=&quot;qmovie&quot;&gt;QMovie&lt;/a&gt; 가 &lt;a href=&quot;qmovie#updated&quot;&gt;업데이트&lt;/a&gt; () 또는 &lt;a href=&quot;qmovie#resized&quot;&gt;크기 조정&lt;/a&gt; ()을 중지합니다 . 이 상태는 pause () 또는 &lt;a href=&quot;qmovie#setPaused&quot;&gt;setPaused&lt;/a&gt; (true)를 호출 한 후에 시작됩니다 . 현재 유지 한 프레임 번호이며, &lt;a href=&quot;qmovie#setPaused&quot;&gt;unpause&lt;/a&gt; ( ) 또는 setPaused (false)가 호출 되면 동영상은 다음 프레임으로 계속 진행됩니다 .</target>
        </trans-unit>
        <trans-unit id="096604b24a780e20864ac1dda490de5f7755909a" translate="yes" xml:space="preserve">
          <source>The movie is running.</source>
          <target state="translated">영화가 실행 중입니다.</target>
        </trans-unit>
        <trans-unit id="25d28c1809e05399df17b835331e9a7ba22b1642" translate="yes" xml:space="preserve">
          <source>The mutex is necessary because the results of two threads attempting to change the value of the same variable simultaneously are unpredictable.</source>
          <target state="translated">동일한 변수의 값을 동시에 변경하려는 두 스레드의 결과를 예측할 수 없기 때문에 뮤텍스가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="fd45e4a115221b68e9bd65770c7d2da61a0539b5" translate="yes" xml:space="preserve">
          <source>The name can be either short or long. If the name is one character in length, it is considered a short name. Option names must not be empty, must not start with a dash or a slash character, must not contain a &lt;code&gt;=&lt;/code&gt; and cannot be repeated.</source>
          <target state="translated">이름은 짧거나 길 수 있습니다. 이름이 한 문자 길이 인 경우 짧은 이름으로 간주됩니다. 옵션 이름은 비워 둘 수 없으며 대시 또는 슬래시 문자로 시작해서는 안되며 &lt;code&gt;=&lt;/code&gt; 를 포함해서는 안되며 반복 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="37f0e661c11ae4c3f573be4801e842e3703f05c3" translate="yes" xml:space="preserve">
          <source>The name can potentially be localized. The language is dependent on the entity that sets it, typically this is the &lt;a href=&quot;location-places-qml#plugin&quot;&gt;Plugin&lt;/a&gt;. The &lt;a href=&quot;qml-qtlocation-plugin#locales-prop&quot;&gt;Plugin::locales&lt;/a&gt; property defines what language is used.</source>
          <target state="translated">이름은 현지화 될 수 있습니다. 언어는 언어를 설정하는 엔티티에 따라 다르며 일반적으로 &lt;a href=&quot;location-places-qml#plugin&quot;&gt;Plugin&lt;/a&gt; 입니다. &lt;a href=&quot;qml-qtlocation-plugin#locales-prop&quot;&gt;플러그인 :: 로케일을&lt;/a&gt; 사용하는 어떤 언어 속성을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="721521ac23b10ac561715a35ef28dfa8274f3d3f" translate="yes" xml:space="preserve">
          <source>The name can potentially be localized. The language is dependent on the entity that sets it, typically this is the &lt;a href=&quot;qplacemanager&quot;&gt;QPlaceManager&lt;/a&gt;. The &lt;a href=&quot;qplacemanager#locales&quot;&gt;QPlaceManager::locales&lt;/a&gt;() field defines what language is used.</source>
          <target state="translated">이름은 현지화 될 수 있습니다. 언어는 언어를 설정하는 엔티티에 따라 다르며 일반적으로 &lt;a href=&quot;qplacemanager&quot;&gt;QPlaceManager&lt;/a&gt; 입니다. &lt;a href=&quot;qplacemanager#locales&quot;&gt;QPlaceManager :: 로케일에&lt;/a&gt; 사용되는 어떤 언어 () 필드를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="493c960272a1a862d5a54e161776877f7e832174" translate="yes" xml:space="preserve">
          <source>The name defaults to &lt;code&gt;Default&lt;/code&gt;, but qmake generates some of the images, so it is easier to use another name (for example LaunchImage as we did) to avoid clashes.</source>
          <target state="translated">이름의 기본값은 &lt;code&gt;Default&lt;/code&gt; 이지만 qmake는 일부 이미지를 생성하므로 충돌을 피하기 위해 다른 이름 (예 : LaunchImage)을 사용하는 것이 더 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="69941ca660818de7c2abb065f00977d1a8975f30" translate="yes" xml:space="preserve">
          <source>The name filter, file attribute filter, and sorting specification can be overridden using the</source>
          <target state="translated">이름 필터, 파일 속성 필터 및 정렬 사양은 다음을 사용하여 재정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="162278acabfc945b2763916765ec2e6f987b0b59" translate="yes" xml:space="preserve">
          <source>The name for the role. This name is used to access the model data for this role.</source>
          <target state="translated">역할의 이름입니다. 이 이름은이 역할의 모델 데이터에 액세스하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4c3d90a665e18979efd5f52473d8063e58bb83c1" translate="yes" xml:space="preserve">
          <source>The name is based on the characteristic's &lt;a href=&quot;qlowenergycharacteristic#uuid&quot;&gt;uuid&lt;/a&gt;() which must have been standardized. The complete list of characteristic types can be found under &lt;a href=&quot;https://developer.bluetooth.org/gatt/characteristics/Pages/CharacteristicsHome.aspx&quot;&gt;Bluetooth.org Characteristics&lt;/a&gt;.</source>
          <target state="translated">이름은 표준화해야하는 특성의 &lt;a href=&quot;qlowenergycharacteristic#uuid&quot;&gt;uuid&lt;/a&gt; ()를 기반으로합니다 . 특성 유형의 전체 목록은 &lt;a href=&quot;https://developer.bluetooth.org/gatt/characteristics/Pages/CharacteristicsHome.aspx&quot;&gt;Bluetooth.org 특성&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ae869c8c5af4faaa298203a3742cd4a205e1212c" translate="yes" xml:space="preserve">
          <source>The name is based on the descriptor's &lt;a href=&quot;qlowenergydescriptor#type&quot;&gt;type&lt;/a&gt;(). The complete list of descriptor types can be found under &lt;a href=&quot;https://developer.bluetooth.org/gatt/descriptors/Pages/DescriptorsHomePage.aspx&quot;&gt;Bluetooth.org Descriptors&lt;/a&gt;.</source>
          <target state="translated">이름은 설명자 &lt;a href=&quot;qlowenergydescriptor#type&quot;&gt;유형&lt;/a&gt; ()을 기반으로합니다 . 디스크립터 유형의 전체 목록은 &lt;a href=&quot;https://developer.bluetooth.org/gatt/descriptors/Pages/DescriptorsHomePage.aspx&quot;&gt;Bluetooth.org 디스크립터&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="792659accef8616599fa24407b72747526c2fa58" translate="yes" xml:space="preserve">
          <source>The name is displayed in the legend for the series and it supports HTML formatting.</source>
          <target state="translated">시리즈의 범례에 이름이 표시되며 HTML 형식을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="89010c4c29f23d0396424dc37977d5853ca02b93" translate="yes" xml:space="preserve">
          <source>The name is returned in the form that would be used in isolation (for example as a column heading in a calendar's tabular display of a month with successive weeks as rows) in the specified</source>
          <target state="translated">이름은 지정된 시간에 분리되어 사용되는 형식으로 반환됩니다 (예 : 달력의 표 형식의 월 표시에서 연속 주 행으로 표시).</target>
        </trans-unit>
        <trans-unit id="990395b668bd81040c1dd113b83c4feaf415a2c5" translate="yes" xml:space="preserve">
          <source>The name is returned in the form that would be used in isolation in the specified</source>
          <target state="translated">이름은 지정된 위치에서 분리하여 사용되는 형식으로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="a417dee03810e0a985f13a7135313074046def20" translate="yes" xml:space="preserve">
          <source>The name is returned in the form that would normally be used in a full date, in the specified</source>
          <target state="translated">이름은 지정된 날짜의 전체 날짜에 일반적으로 사용되는 형식으로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="30c9a629f94402d8ef484acc44ce433cc337194d" translate="yes" xml:space="preserve">
          <source>The name may either be the name of the underlying access point or the name for service network that this configuration represents.</source>
          <target state="translated">이름은 기본 액세스 포인트의 이름이거나이 구성이 나타내는 서비스 네트워크의 이름 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5ea99c02aa46a63f6c21f07f4ed425ff6b91e02" translate="yes" xml:space="preserve">
          <source>The name of a directory is found using the &lt;a href=&quot;qdir#dirName&quot;&gt;dirName&lt;/a&gt;() function. This typically returns the last element in the absolute path that specifies the location of the directory. However, it can also return &quot;.&quot; if the &lt;a href=&quot;qdir&quot;&gt;QDir&lt;/a&gt; represents the current directory.</source>
          <target state="translated">디렉토리의 이름은 &lt;a href=&quot;qdir#dirName&quot;&gt;dirName&lt;/a&gt; () 함수를 사용하여 찾을 수 있습니다. 일반적으로 디렉토리의 위치를 ​​지정하는 절대 경로의 마지막 요소를 반환합니다. 그러나 &quot;.&quot;을 반환 할 수도 있습니다. &lt;a href=&quot;qdir&quot;&gt;QDir&lt;/a&gt; 이 현재 디렉토리를 나타내는 경우</target>
        </trans-unit>
        <trans-unit id="8a4880254c6238de5c2448398e3a6c3a313e3a6e" translate="yes" xml:space="preserve">
          <source>The name of a directory is found using the &lt;a href=&quot;qdir#dirName&quot;&gt;dirName&lt;/a&gt;() function. This typically returns the last element in the absolute path that specifies the location of the directory. However, it can also return &quot;.&quot; if the QDir represents the current directory.</source>
          <target state="translated">디렉토리 이름은 &lt;a href=&quot;qdir#dirName&quot;&gt;dirName&lt;/a&gt; () 함수를 사용하여 찾을 수 있습니다. 일반적으로 디렉토리 위치를 지정하는 절대 경로의 마지막 요소를 반환합니다. 그러나 &quot;.&quot;를 반환 할 수도 있습니다. QDir이 현재 디렉토리를 나타내는 경우.</target>
        </trans-unit>
        <trans-unit id="f598e9c2763e0d9ea73ad0ff5811b5393c82c9d3" translate="yes" xml:space="preserve">
          <source>The name of a directory. Both files and directories are displayed. However, the native Windows file dialog does not support displaying files in the directory chooser.</source>
          <target state="translated">디렉토리의 이름입니다. 파일과 디렉토리가 모두 표시됩니다. 그러나 기본 Windows 파일 대화 상자는 디렉토리 선택기에 파일 표시를 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="470da9c91bae6694bd8760cd5001dddd4d4aa7be" translate="yes" xml:space="preserve">
          <source>The name of a file, whether it exists or not.</source>
          <target state="translated">파일의 존재 여부에 관계없이 파일의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="8c9c0b1af9db29e07dfb51532bbb784e1d613785" translate="yes" xml:space="preserve">
          <source>The name of a platform-compiler combination. In this case, qmake will search in the directory specified by the &lt;code&gt;mkspecs&lt;/code&gt; subdirectory of the data path specified when Qt was compiled (see &lt;a href=&quot;qlibraryinfo#LibraryLocation-enum&quot;&gt;QLibraryInfo::DataPath&lt;/a&gt;).</source>
          <target state="translated">플랫폼 컴파일러 조합의 이름입니다. 이 경우 qmake는 Qt가 컴파일 될 때 지정된 데이터 경로 의 &lt;code&gt;mkspecs&lt;/code&gt; 서브 디렉토리로 지정된 디렉토리에서 검색 합니다 ( &lt;a href=&quot;qlibraryinfo#LibraryLocation-enum&quot;&gt;QLibraryInfo :: DataPath&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="057c5952760f53903ecca8763e8070756d7a1f2a" translate="yes" xml:space="preserve">
          <source>The name of a single existing file.</source>
          <target state="translated">기존의 단일 파일 이름입니다.</target>
        </trans-unit>
        <trans-unit id="3b3b1fd5cbc50886ee9f5b177e0fbbac0dac1607" translate="yes" xml:space="preserve">
          <source>The name of an XML node has three components: The</source>
          <target state="translated">XML 노드의 이름에는 세 가지 구성 요소가 있습니다.</target>
        </trans-unit>
        <trans-unit id="f915b65243f55a415532880ee812220d2133fb57" translate="yes" xml:space="preserve">
          <source>The name of the &lt;a href=&quot;qml-qtquick-sprite&quot;&gt;Sprite&lt;/a&gt; that is currently animating.</source>
          <target state="translated">현재 애니메이션중인 &lt;a href=&quot;qml-qtquick-sprite&quot;&gt;Sprite&lt;/a&gt; 의 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="7d20469eadfd0ae52232e634b83dd3deb5c7f819" translate="yes" xml:space="preserve">
          <source>The name of the &lt;a href=&quot;qml-qtquick-sprite&quot;&gt;Sprite&lt;/a&gt; that the animation should move to.</source>
          <target state="translated">애니메이션이 이동해야하는 &lt;a href=&quot;qml-qtquick-sprite&quot;&gt;Sprite&lt;/a&gt; 의 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="e1456d1eb5ddae9f630d15fe63e210f076034f7f" translate="yes" xml:space="preserve">
          <source>The name of the GPS area.</source>
          <target state="translated">GPS 영역의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="aff2dbee6fdf31fb1675cca0b7954d251342792a" translate="yes" xml:space="preserve">
          <source>The name of the QDoc program is &lt;code&gt;qdoc&lt;/code&gt;. To run QDoc from the command line, give it the name of a configuration file:</source>
          <target state="translated">QDoc 프로그램의 이름은 &lt;code&gt;qdoc&lt;/code&gt; 입니다. 명령 줄에서 QDoc을 실행하려면 구성 파일의 이름을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="b2df46bf3b772eb8b849d2aaa7a1ba87009931bc" translate="yes" xml:space="preserve">
          <source>The name of the QDoc program is &lt;code&gt;qdoc&lt;/code&gt;. To run qdoc from the command line, give it the name of a configuration file:</source>
          <target state="translated">QDoc 프로그램의 이름은 &lt;code&gt;qdoc&lt;/code&gt; 입니다. 명령 행에서 qdoc를 실행하려면 구성 파일 이름을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="9c7f460a9a99667f9248df242628813633e25728" translate="yes" xml:space="preserve">
          <source>The name of the Sprite which the affected particles should move to.</source>
          <target state="translated">영향을받는 파티클이 이동해야하는 Sprite의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="40d2e11235855fab2d67d717fdf33aaa4aa7634f" translate="yes" xml:space="preserve">
          <source>The name of the attribute</source>
          <target state="translated">속성의 이름</target>
        </trans-unit>
        <trans-unit id="0eaa90811c61c0f2648a3f87ef60fa4962992e36" translate="yes" xml:space="preserve">
          <source>The name of the class that provides the widget.</source>
          <target state="translated">위젯을 제공하는 클래스의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="d64bd76544b38e5759393eca105fc3f110d37a93" translate="yes" xml:space="preserve">
          <source>The name of the custom build target.</source>
          <target state="translated">사용자 정의 빌드 대상의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="774d31ec0c73f8fc89a6444111ca0a13ccbf6694" translate="yes" xml:space="preserve">
          <source>The name of the device offering the service.</source>
          <target state="translated">서비스를 제공하는 장치의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="bca35cad89c68fcbec020e7d730f807427e41034" translate="yes" xml:space="preserve">
          <source>The name of the device.</source>
          <target state="translated">장치의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="b9696a9c5ef83a12e04b28d7411ded8437d4ec43" translate="yes" xml:space="preserve">
          <source>The name of the document type</source>
          <target state="translated">문서 유형의 이름</target>
        </trans-unit>
        <trans-unit id="f75476630adc7537ab0942d349040825c278cc3c" translate="yes" xml:space="preserve">
          <source>The name of the entity</source>
          <target state="translated">실체의 이름</target>
        </trans-unit>
        <trans-unit id="871b456901e6c0fc86df9d051e5822b4a47d265c" translate="yes" xml:space="preserve">
          <source>The name of the file used as a brush for the box-and-whiskers item.</source>
          <target state="translated">상자 및 수염 항목의 브러시로 사용되는 파일 이름입니다.</target>
        </trans-unit>
        <trans-unit id="24a73e4402ef805156d1d3cf96e422049c2f1a57" translate="yes" xml:space="preserve">
          <source>The name of the file used as a brush for the candlestick item.</source>
          <target state="translated">촛대 항목의 브러시로 사용되는 파일 이름입니다.</target>
        </trans-unit>
        <trans-unit id="d8da36b45b78b80bb84c7d15798846aac21374e9" translate="yes" xml:space="preserve">
          <source>The name of the file used as a brush for the series.</source>
          <target state="translated">시리즈의 브러시로 사용되는 파일 이름입니다.</target>
        </trans-unit>
        <trans-unit id="bbac53a6680ec8419bc5c1d32a5670fd66c07377" translate="yes" xml:space="preserve">
          <source>The name of the file used as a brush for the set.</source>
          <target state="translated">세트의 브러시로 사용되는 파일 이름입니다.</target>
        </trans-unit>
        <trans-unit id="16df2457f406583a7d94da875a7df8507edaa862" translate="yes" xml:space="preserve">
          <source>The name of the file used as a brush for the slice.</source>
          <target state="translated">슬라이스의 브러시로 사용되는 파일 이름입니다.</target>
        </trans-unit>
        <trans-unit id="15abed02c964965cedb9796d716f7c78f6faf659" translate="yes" xml:space="preserve">
          <source>The name of the file used as a brush image for the series.</source>
          <target state="translated">시리즈의 브러시 이미지로 사용되는 파일 이름입니다.</target>
        </trans-unit>
        <trans-unit id="957ecb2da7bf7f947df59c83007e25fafede1cdc" translate="yes" xml:space="preserve">
          <source>The name of the group which the affected particles should move to.</source>
          <target state="translated">영향을받는 입자가 이동해야하는 그룹의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="eefd9f0021b48b7b51df8dc461928c9d84b99fd8" translate="yes" xml:space="preserve">
          <source>The name of the image. A handler that supports this option is expected to read the name from the image metadata and return this as a &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;, or when writing an image it is expected to store the name in the image metadata.</source>
          <target state="translated">이미지의 이름입니다. 이 옵션을 지원하는 핸들러는 이미지 메타 데이터에서 이름을 읽고이를 &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; 으로 리턴 하거나 이미지를 작성할 때 이미지 메타 데이터에 이름을 저장해야합니다.</target>
        </trans-unit>
        <trans-unit id="6611a1e52e91cdfc0858c10ededebbc0da825857" translate="yes" xml:space="preserve">
          <source>The name of the imported target for the module: &lt;code&gt;Qt5::Widgets&lt;/code&gt;</source>
          <target state="translated">모듈에 대해 가져온 대상의 이름 : &lt;code&gt;Qt5::Widgets&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2002401ee533af92a6a3f7073075751dee8cd052" translate="yes" xml:space="preserve">
          <source>The name of the method used for location finding.</source>
          <target state="translated">위치 찾기에 사용 된 방법의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="53013d505236b97e5bf8ff25f307be740cbdf7db" translate="yes" xml:space="preserve">
          <source>The name of the notation</source>
          <target state="translated">표기법의 이름</target>
        </trans-unit>
        <trans-unit id="dc21017129d741fc7aa59d9f9dd7257f884d1f21" translate="yes" xml:space="preserve">
          <source>The name of the object. This can be used both as an identifier or a short description by accessible clients.</source>
          <target state="translated">객체의 이름입니다. 액세스 가능한 클라이언트는 식별자 또는 간단한 설명으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="253cd37ca9ec1e5a7913171ea3e0ad1708944fa9" translate="yes" xml:space="preserve">
          <source>The name of the option is set to</source>
          <target state="translated">옵션 이름이</target>
        </trans-unit>
        <trans-unit id="e05dc99e355e54f9724584c7f8ac352f6708368a" translate="yes" xml:space="preserve">
          <source>The name of the output header file. If none is specified, .cpp is added to the base name.</source>
          <target state="translated">출력 헤더 파일의 이름입니다. 아무것도 지정하지 않으면 .cpp가 기본 이름에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="4856abd8556594c945211145b00af0013766b393" translate="yes" xml:space="preserve">
          <source>The name of the output header file. If none is specified, .h is added to the base name.</source>
          <target state="translated">출력 헤더 파일의 이름입니다. 아무것도 지정하지 않으면 .h가 기본 이름에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="3b4d0278cfb52f1601579f9e0ab76c42b4fb0748" translate="yes" xml:space="preserve">
          <source>The name of the package as displayed to the user. Defaults to TARGET.</source>
          <target state="translated">사용자에게 표시되는 패키지 이름입니다. 기본값은 TARGET입니다.</target>
        </trans-unit>
        <trans-unit id="a00462e93a4f814c800aae06a71df1b36447a6a6" translate="yes" xml:space="preserve">
          <source>The name of the person who created the document as &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;.</source>
          <target state="translated">문서를 &lt;a href=&quot;qstring&quot;&gt;QString으로&lt;/a&gt; 만든 사람의 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="9f4441eea0dd7ac5a440dfbe4c68a5c449197d05" translate="yes" xml:space="preserve">
          <source>The name of the provider that a place is sourced from</source>
          <target state="translated">장소가 제공되는 제공 업체의 이름</target>
        </trans-unit>
        <trans-unit id="38fde4fe1ee2db50f1af5eba426a8ea74c239192" translate="yes" xml:space="preserve">
          <source>The name of the referenced entity</source>
          <target state="translated">참조 된 엔터티의 이름</target>
        </trans-unit>
        <trans-unit id="92a621f009bd38fc1dfa1047f1ed8b346452a146" translate="yes" xml:space="preserve">
          <source>The name of the screen.</source>
          <target state="translated">화면의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="037eef0b527e7175a45c4725b797bbe44c97ee7c" translate="yes" xml:space="preserve">
          <source>The name of the script. Can be useful to retrieve a particular script from &lt;a href=&quot;qml-qtwebengine-webengineview#userScripts-prop&quot;&gt;WebEngineView.userScripts&lt;/a&gt;.</source>
          <target state="translated">스크립트 이름 &lt;a href=&quot;qml-qtwebengine-webengineview#userScripts-prop&quot;&gt;WebEngineView.userScripts&lt;/a&gt; 에서 특정 스크립트를 검색하는 데 유용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c05f7b0b296e6a68807440901ed97741e050b829" translate="yes" xml:space="preserve">
          <source>The name of the serial port can be passed as either a short name or the long system location if necessary.</source>
          <target state="translated">직렬 포트의 이름은 필요한 경우 짧은 이름 또는 긴 시스템 위치로 전달 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="53d74a69c982cc05432742beb5b3cdc8a1e09366" translate="yes" xml:space="preserve">
          <source>The name of the series. It is displayed in the legend for the series and it supports HTML formatting.</source>
          <target state="translated">시리즈의 이름입니다. 시리즈의 범례에 표시되며 HTML 형식을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="9306af8b2ed4da66efedb5ea1289d09910001efc" translate="yes" xml:space="preserve">
          <source>The name of the state machine as set by the</source>
          <target state="translated">에 의해 설정된 상태 머신의 이름</target>
        </trans-unit>
        <trans-unit id="75bbae2505d04e29e52c11eca71a81e34ae7b5c9" translate="yes" xml:space="preserve">
          <source>The name of the target (.exe). Defaults to TARGET.</source>
          <target state="translated">대상 이름 (.exe) 기본값은 TARGET입니다.</target>
        </trans-unit>
        <trans-unit id="ffd3fd6b623e3a355b5c556f52a0c6f4dc871035" translate="yes" xml:space="preserve">
          <source>The name of this server used during the http handshake phase.</source>
          <target state="translated">http 핸드 셰이크 단계에서 사용 된이 서버의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="b28191a0c387b22dc248eba21b0b511634942d29" translate="yes" xml:space="preserve">
          <source>The name of this sprite, for use in the to property of other sprites.</source>
          <target state="translated">다른 스프라이트의 to 속성에 사용하기위한이 스프라이트의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="3e1166b2185c61ef70ff20aeb8d8f167ff7b72aa" translate="yes" xml:space="preserve">
          <source>The name provided can be any long or short name of any option that was added with &lt;code&gt;addOption()&lt;/code&gt;. All the option names are treated as being equivalent. If the name is not recognized or that option was not present, an empty string is returned.</source>
          <target state="translated">제공된 이름은 &lt;code&gt;addOption()&lt;/code&gt; 으로 추가 된 옵션의 길거나 짧은 이름 일 수 있습니다 . 모든 옵션 이름은 동등한 것으로 취급됩니다. 이름이 인식되지 않거나 해당 옵션이 없으면 빈 문자열이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="47de00fb621a2e3e07496846c18bbf9cd9e1dba6" translate="yes" xml:space="preserve">
          <source>The name provided can be any long or short name of any option that was added with &lt;code&gt;addOption()&lt;/code&gt;. All the options names are treated as being equivalent. If the name is not recognized or that option was not present, an empty list is returned.</source>
          <target state="translated">제공된 이름은 &lt;code&gt;addOption()&lt;/code&gt; 으로 추가 된 옵션의 길거나 짧은 이름 일 수 있습니다 . 모든 옵션 이름은 동등한 것으로 취급됩니다. 이름이 인식되지 않거나 해당 옵션이 없으면 빈 목록이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="1c482b8badd934f5446ddcab8b100b312d8301b3" translate="yes" xml:space="preserve">
          <source>The name provided can be any long or short name of any option that was added with &lt;code&gt;addOption()&lt;/code&gt;. All the options names are treated as being equivalent. If the name is not recognized or that option was not present, false is returned.</source>
          <target state="translated">제공된 이름은 &lt;code&gt;addOption()&lt;/code&gt; 으로 추가 된 옵션의 길거나 짧은 이름 일 수 있습니다 . 모든 옵션 이름은 동등한 것으로 취급됩니다. 이름이 인식되지 않거나 해당 옵션이 없으면 false가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="97794e5e4f3df96f5e845f85d9345947fd9337a1" translate="yes" xml:space="preserve">
          <source>The name returned</source>
          <target state="translated">반환 된 이름</target>
        </trans-unit>
        <trans-unit id="d2aa9e2ab4024c1075faad98603929a4f8c8ca0e" translate="yes" xml:space="preserve">
          <source>The name should have a specific format; see the &lt;a href=&quot;qserialport#setPort&quot;&gt;setPort&lt;/a&gt;() method.</source>
          <target state="translated">이름은 특정 형식이어야합니다. &lt;a href=&quot;qserialport#setPort&quot;&gt;setPort&lt;/a&gt; () 메소드를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="92bda07ed1e30f0a636159beae4aa824f57960d0" translate="yes" xml:space="preserve">
          <source>The name tests are the &lt;a href=&quot;#node-tests&quot;&gt;Node Tests&lt;/a&gt; that have the &lt;code&gt;name&lt;/code&gt; parameter. A name test must match the node</source>
          <target state="translated">이름 테스트는 &lt;code&gt;name&lt;/code&gt; 매개 변수 가있는 &lt;a href=&quot;#node-tests&quot;&gt;노드 테스트&lt;/a&gt; 입니다 . 이름 테스트는 노드와 일치해야합니다</target>
        </trans-unit>
        <trans-unit id="daa12d00971829b3685f2b603fc2eff178c0ca82" translate="yes" xml:space="preserve">
          <source>The name tests are the &lt;a href=&quot;xquery-introduction#node-tests&quot;&gt;Node Tests&lt;/a&gt; that have the &lt;code&gt;name&lt;/code&gt; parameter. A name test must match the node</source>
          <target state="translated">이름 테스트는 &lt;code&gt;name&lt;/code&gt; 매개 변수 가있는 &lt;a href=&quot;xquery-introduction#node-tests&quot;&gt;노드 테스트&lt;/a&gt; 입니다 . 이름 테스트는 노드와 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="98c081be5b5f55744b1af6faf82f9112e31fcd7c" translate="yes" xml:space="preserve">
          <source>The names can be either short or long. Any name in the list that is one character in length is a short name. Option names must not be empty, must not start with a dash or a slash character, must not contain a &lt;code&gt;=&lt;/code&gt; and cannot be repeated.</source>
          <target state="translated">이름은 짧거나 길 수 있습니다. 한 문자 길이 인 목록의 모든 이름은 짧은 이름입니다. 옵션 이름은 비워 둘 수 없으며 대시 또는 슬래시 문자로 시작해서는 안되며 &lt;code&gt;=&lt;/code&gt; 를 포함해서는 안되며 반복 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3f875220850d025c9b7939e92566533a7fb691b1" translate="yes" xml:space="preserve">
          <source>The names in this list do not include the preceding dash characters. Names may appear more than once in this list if they were encountered more than once by the parser.</source>
          <target state="translated">이 목록의 이름에는 앞의 대시 문자가 포함되지 않습니다. 구문 분석기가 두 번 이상 발견 한 경우이 목록에 이름이 두 번 이상 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dacf58225321ac9450f50648984b2e3b30c8aa37" translate="yes" xml:space="preserve">
          <source>The names of the option are set to</source>
          <target state="translated">옵션의 이름은</target>
        </trans-unit>
        <trans-unit id="5a0f0c8db1195536a121e6f7c2bb9b2108a3407d" translate="yes" xml:space="preserve">
          <source>The names of zero or more existing files.</source>
          <target state="translated">0 개 이상의 기존 파일 이름</target>
        </trans-unit>
        <trans-unit id="35813830616d61348f282c52b4c0f43692cc8d39" translate="yes" xml:space="preserve">
          <source>The names used for roles must begin with a lower-case letter and should be common to all elements in a given model. Values must be simple constants; either strings (quoted and optionally within a call to &lt;a href=&quot;#QT_TR_NOOP&quot;&gt;QT_TR_NOOP&lt;/a&gt;), boolean values (true, false), numbers, or enumeration values (such as AlignText.AlignHCenter).</source>
          <target state="translated">역할에 사용되는 이름은 소문자로 시작해야하며 주어진 모델의 모든 요소에 공통적이어야합니다. 값은 간단한 상수 여야합니다. 문자열 (따옴표가 있고 선택적으로 &lt;a href=&quot;#QT_TR_NOOP&quot;&gt;QT_TR_NOOP&lt;/a&gt; 호출 내 ), 부울 값 (true, false), 숫자 또는 열거 값 (예 : AlignText.AlignHCenter)</target>
        </trans-unit>
        <trans-unit id="506f543ce4f6d673b004470b2b7612ee8629a3ab" translate="yes" xml:space="preserve">
          <source>The names used for roles must begin with a lower-case letter and should be common to all elements in a given model. Values must be simple constants; either strings (quoted and optionally within a call to &lt;a href=&quot;qtglobal#QT_TR_NOOP&quot;&gt;QT_TR_NOOP&lt;/a&gt;), boolean values (true, false), numbers, or enumeration values (such as AlignText.AlignHCenter).</source>
          <target state="translated">역할에 사용되는 이름은 소문자로 시작해야하며 주어진 모델의 모든 요소에 공통되어야합니다. 값은 단순 상수 여야합니다. 문자열 (따옴표 및 선택적으로 &lt;a href=&quot;qtglobal#QT_TR_NOOP&quot;&gt;QT_TR_NOOP&lt;/a&gt; 호출 내 ), 부울 값 (true, false), 숫자 또는 열거 형 값 (예 : AlignText.AlignHCenter)</target>
        </trans-unit>
        <trans-unit id="0a26543a3e17cbc2f43ad389d2a0c455fbbd9412" translate="yes" xml:space="preserve">
          <source>The namespace declarations to be used in the XPath queries.</source>
          <target state="translated">XPath 쿼리에 사용될 네임 스페이스 선언</target>
        </trans-unit>
        <trans-unit id="4b098f5b94375d4757df529d3469244efc54ffa9" translate="yes" xml:space="preserve">
          <source>The namespace-processing flag of the stream reader</source>
          <target state="translated">스트림 리더의 네임 스페이스 처리 플래그</target>
        </trans-unit>
        <trans-unit id="f7c68f66e2ec9e38ff518a8e0152d65a3d42f59c" translate="yes" xml:space="preserve">
          <source>The namespaced import is useful if there is a requirement to use two QML types that have the same name but are located in different modules. In this case the two modules can be imported into different namespaces to ensure the code is referring to the correct type:</source>
          <target state="translated">네임 스페이스가있는 가져 오기는 이름은 같지만 다른 모듈에있는 두 개의 QML 유형을 사용해야하는 경우에 유용합니다. 이 경우 코드가 올바른 유형을 참조하도록하기 위해 두 개의 모듈을 다른 네임 스페이스로 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ebcab83be2219361064ced551bf6f24654a87786" translate="yes" xml:space="preserve">
          <source>The namespaces should be declared as in &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt;. For example, if a requested document at http://mysite.com/feed.xml uses the namespace &quot;http://www.w3.org/2005/Atom&quot;, this can be declared as the default namespace:</source>
          <target state="translated">네임 스페이스는 &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt; 에서와 같이 선언되어야합니다 . 예를 들어 http://mysite.com/feed.xml에서 요청 된 문서가 &quot;http://www.w3.org/2005/Atom&quot;네임 스페이스를 사용하는 경우 이는 기본 네임 스페이스로 선언 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="307c0ee2da33ecdca298e1dc7fc8bef9d1188f9f" translate="yes" xml:space="preserve">
          <source>The namespaces should be declared as in &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt;. For example, if a requested document at http://mysite.com/feed.xml uses the namespace &quot;http://www.w3.org/2005/Atom&quot;, this can be declared as the default namespace:</source>
          <target state="translated">네임 스페이스는 &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt; 와 같이 선언해야합니다 . 예를 들어 http://mysite.com/feed.xml의 요청 된 문서가 &quot;http://www.w3.org/2005/Atom&quot;네임 스페이스를 사용하는 경우 기본 네임 스페이스로 선언 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e145505b4d8fc1bdaea6df419694222d7877ed0" translate="yes" xml:space="preserve">
          <source>The native handle will be resolved in the &lt;a href=&quot;qoffscreensurface#create&quot;&gt;create&lt;/a&gt;() function. Calling this function after &lt;a href=&quot;qoffscreensurface#create&quot;&gt;create&lt;/a&gt;() will not re-create a native surface.</source>
          <target state="translated">기본 핸들은 &lt;a href=&quot;qoffscreensurface#create&quot;&gt;create&lt;/a&gt; () 함수 에서 해결됩니다 . &lt;a href=&quot;qoffscreensurface#create&quot;&gt;create&lt;/a&gt; () 후에이 함수를 호출하면 기본 표면이 다시 생성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7e251a8c5d2c91688e4abbd990e6fe3a589201c6" translate="yes" xml:space="preserve">
          <source>The native object is a 2D texture (OpenGL, Direct3D 11, Metal) or image (Vulkan).</source>
          <target state="translated">기본 개체는 2D 텍스처 (OpenGL, Direct3D 11, Metal) 또는 이미지 (Vulkan)입니다.</target>
        </trans-unit>
        <trans-unit id="7cf259d32a0722f48d1e6524a26f0564864afb8f" translate="yes" xml:space="preserve">
          <source>The native object is wrapped, but not owned, by the resulting &lt;a href=&quot;qsgtexture&quot;&gt;QSGTexture&lt;/a&gt;. The caller of the function is responsible for deleting the returned &lt;a href=&quot;qsgtexture&quot;&gt;QSGTexture&lt;/a&gt;, but that will not destroy the underlying native object.</source>
          <target state="translated">네이티브 개체는 결과 &lt;a href=&quot;qsgtexture&quot;&gt;QSGTexture에&lt;/a&gt; 의해 래핑되지만 소유되지는 않습니다 . 함수 호출자는 반환 된 &lt;a href=&quot;qsgtexture&quot;&gt;QSGTexture&lt;/a&gt; 를 삭제할 책임이 있지만 기본 네이티브 개체를 파괴하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="7007978410088b73c55ac2ab53c4ddc5ce3104d3" translate="yes" xml:space="preserve">
          <source>The native orientation is a property of the hardware, and does not change.</source>
          <target state="translated">기본 방향은 하드웨어의 속성이며 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="852163f5a4b8fbdb460e4c2a3c12edcbf0a402d2" translate="yes" xml:space="preserve">
          <source>The native orientation of the screen is the orientation where the logo sticker of the device appears the right way up, or &lt;a href=&quot;qt#ScreenOrientation-enum&quot;&gt;Qt::PrimaryOrientation&lt;/a&gt; if the platform does not support this functionality.</source>
          <target state="translated">화면의 기본 방향은 장치의 로고 스티커가 올바른 방향으로 나타나는 방향이거나 플랫폼이이 기능을 지원하지 않는 경우 &lt;a href=&quot;qt#ScreenOrientation-enum&quot;&gt;Qt :: PrimaryOrientation&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ca561eefdec66edbf564f67352e8e73e9269228f" translate="yes" xml:space="preserve">
          <source>The native resolution is not always known and can be changed during playback.</source>
          <target state="translated">기본 해상도는 항상 알려진 것은 아니며 재생 중에 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="db2d4d7b26e2187e398d2587859f879ccabebbc2" translate="yes" xml:space="preserve">
          <source>The native resolution of video surface. This is the resolution of video frames the surface can render with optimal quality and/or performance.</source>
          <target state="translated">비디오 표면의 기본 해상도. 표면이 최적의 품질 및 / 또는 성능으로 렌더링 할 수있는 비디오 프레임의 해상도입니다.</target>
        </trans-unit>
        <trans-unit id="e8e1f82b196ebece108f546c4fb827a2ba6b40da" translate="yes" xml:space="preserve">
          <source>The natural color system (NCS) blue theme.</source>
          <target state="translated">자연 색상 시스템 (NCS) 파란색 테마.</target>
        </trans-unit>
        <trans-unit id="53db99714ec2481588fb26487ee2dc2400b7a0d7" translate="yes" xml:space="preserve">
          <source>The navigation bar of the calendar.</source>
          <target state="translated">캘린더의 탐색 모음.</target>
        </trans-unit>
        <trans-unit id="d1a021f1fffdf97bb552e717a7106f11a3cff607" translate="yes" xml:space="preserve">
          <source>The navigation commands are for linking the pages of a document in a meaningful sequence. Below is a sequence of QDoc comments that shows a typical use of the navigation commands.</source>
          <target state="translated">탐색 명령은 문서의 페이지를 의미있는 순서로 연결하기위한 것입니다. 다음은 탐색 명령의 일반적인 사용법을 보여주는 일련의 QDoc 주석입니다.</target>
        </trans-unit>
        <trans-unit id="d896563239da0e253bc1a6f54077beeb40485c1b" translate="yes" xml:space="preserve">
          <source>The navigation history of the current view.</source>
          <target state="translated">현재보기의 탐색 기록.</target>
        </trans-unit>
        <trans-unit id="6aa419a1d999273f0b5d4e866bc00737f7ab11fe" translate="yes" xml:space="preserve">
          <source>The navigation information that joins segments.</source>
          <target state="translated">세그먼트를 결합하는 탐색 정보입니다.</target>
        </trans-unit>
        <trans-unit id="d323da35852bc78a1e7db8d678bdcbb8c70d395f" translate="yes" xml:space="preserve">
          <source>The navigation request resulted from a back or forward action.</source>
          <target state="translated">탐색 요청은 뒤로 또는 앞으로 조치로 인해 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="4670e4149a97c633e27bbc3892de517c5811847f" translate="yes" xml:space="preserve">
          <source>The navigation request resulted from a clicked link.</source>
          <target state="translated">탐색 요청이 클릭 된 링크에서 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="387bdbe0a1074d3bc4a5e1ffb8ec45f504579d3c" translate="yes" xml:space="preserve">
          <source>The navigation request resulted from a content or server controlled redirect. This also includes automatic reloads. (Added in Qt 5.14)</source>
          <target state="translated">탐색 요청은 콘텐츠 또는 서버 제어 리디렉션에서 발생했습니다. 여기에는 자동 재장 전도 포함됩니다. (Qt 5.14에 추가됨)</target>
        </trans-unit>
        <trans-unit id="4bf31c6ccb7f629f7642d238a9079f1c86c7f75b" translate="yes" xml:space="preserve">
          <source>The navigation request resulted from a form submission.</source>
          <target state="translated">탐색 요청은 양식 제출로 인해 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="70ffdcab200cad9d1ce939572493e249949181e3" translate="yes" xml:space="preserve">
          <source>The navigation request resulted from a reload action.</source>
          <target state="translated">탐색 요청으로 인해 다시로드 조치가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="fa0be68820ede9b17ec6243e4a64a28a660f8445" translate="yes" xml:space="preserve">
          <source>The navigation request resulted from an explicitly loaded URL.</source>
          <target state="translated">탐색 요청은 명시 적으로로드 된 URL에서 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="859d80d63f960e1231e23a6aaba9a9dc1b346957" translate="yes" xml:space="preserve">
          <source>The navigation request was triggered by other means not covered by the above.</source>
          <target state="translated">위의 내용을 다루지 않은 다른 방법으로 탐색 요청이 트리거되었습니다.</target>
        </trans-unit>
        <trans-unit id="8e8036ca806d21c5343f5ff30003793df20be6f3" translate="yes" xml:space="preserve">
          <source>The needle that points to the gauge's current value.</source>
          <target state="translated">게이지의 현재 값을 가리키는 바늘.</target>
        </trans-unit>
        <trans-unit id="a95b09270a060f20a52c11fde9b0c86ac4ebe7ab" translate="yes" xml:space="preserve">
          <source>The netWorker class delegates calls from the .NET code to the native code. Although the transition between those two worlds implies a small performance hit for each function call, and for the type conversion, this should be negligible since we are anyway going to run within the CLR.</source>
          <target state="translated">netWorker 클래스는 .NET 코드에서 네이티브 코드로 호출을 위임합니다. 이 두 세계 사이의 전환은 각 함수 호출 및 유형 변환에 대해 약간의 성능 저하를 의미하지만 CLR 내에서 실행되기 때문에 무시할 만합니다.</target>
        </trans-unit>
        <trans-unit id="c1e23c7e2ae7f968a86a62c33f9ffc66804674da" translate="yes" xml:space="preserve">
          <source>The network accessibility cannot be determined.</source>
          <target state="translated">네트워크 접근성을 확인할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6f648778c9164b8523453a01cbd1d5d4a1f4c391" translate="yes" xml:space="preserve">
          <source>The network configuration is used to create and open a network session before any request that requires network access is process. If no network configuration is explicitly set via this function the network configuration returned by &lt;a href=&quot;qnetworkconfigurationmanager#defaultConfiguration&quot;&gt;QNetworkConfigurationManager::defaultConfiguration&lt;/a&gt;() will be used.</source>
          <target state="translated">네트워크 구성은 네트워크 액세스가 필요한 요청이 처리되기 전에 네트워크 세션을 작성하고 여는 데 사용됩니다. 이 기능을 통해 네트워크 구성을 명시 적으로 설정하지 않으면 &lt;a href=&quot;qnetworkconfigurationmanager#defaultConfiguration&quot;&gt;QNetworkConfigurationManager :: defaultConfiguration&lt;/a&gt; ()에서 반환 한 네트워크 구성 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6c849b3f5ce1c393c26791ea146c8745524f0acf" translate="yes" xml:space="preserve">
          <source>The network configuration specifies which configuration to use, when bearer management is used. For example on a mobile phone the proxy settings are likely to be different for the cellular network vs WLAN.</source>
          <target state="translated">네트워크 구성은 베어러 관리가 사용될 때 사용할 구성을 지정합니다. 예를 들어 휴대 전화의 경우 셀룰러 네트워크와 WLAN의 프록시 설정이 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b8593ec77b0200567659c3e33b2c8dbbb995ad6" translate="yes" xml:space="preserve">
          <source>The network connection has been terminated.</source>
          <target state="translated">네트워크 연결이 종료되었습니다.</target>
        </trans-unit>
        <trans-unit id="2948422beac8ae290c317ef06848704c60999cb0" translate="yes" xml:space="preserve">
          <source>The network icon.</source>
          <target state="translated">네트워크 아이콘.</target>
        </trans-unit>
        <trans-unit id="8d91a5eafbfc719ff05e8aa37a61389cf8cd2f07" translate="yes" xml:space="preserve">
          <source>The network is accessible.</source>
          <target state="translated">네트워크에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="25cc8b23da061766d4f2de8852d8f04b382b47eb" translate="yes" xml:space="preserve">
          <source>The network is not currently accessible, either because there is currently no network coverage or network access has been explicitly disabled by a call to &lt;a href=&quot;qnetworkaccessmanager#setNetworkAccessible&quot;&gt;setNetworkAccessible&lt;/a&gt;().</source>
          <target state="translated">현재 네트워크 범위가 없거나 &lt;a href=&quot;qnetworkaccessmanager#setNetworkAccessible&quot;&gt;setNetworkAccessible&lt;/a&gt; () 호출로 네트워크 액세스가 명시 적으로 비활성화되어있어 네트워크에 액세스 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="042f3b1bddc3d3540c93a58d5e83f702b862563c" translate="yes" xml:space="preserve">
          <source>The network operation has timed out.</source>
          <target state="translated">네트워크 작동 시간이 초과되었습니다.</target>
        </trans-unit>
        <trans-unit id="d9cfee1e1cd3cd549154fd36b6b6b499e4fd875d" translate="yes" xml:space="preserve">
          <source>The network request was invalid (for example, the original or redirected URL is invalid, has an unsupported scheme, or is disallowed by policy).</source>
          <target state="translated">네트워크 요청이 잘못되었습니다 (예 : 원래 또는 리디렉션 된 URL이 잘못되었거나 지원되지 않는 체계가 있거나 정책에 의해 허용되지 않음).</target>
        </trans-unit>
        <trans-unit id="a1e5599472620628f8b4faf88e80efdf07aa9232" translate="yes" xml:space="preserve">
          <source>The network session is being established.</source>
          <target state="translated">네트워크 세션이 설정 중입니다.</target>
        </trans-unit>
        <trans-unit id="81481f4b25d45ba8197218f262db3a4909e5a21a" translate="yes" xml:space="preserve">
          <source>The network session is connected. If the current process wishes to use this session it has to register its interest by calling &lt;a href=&quot;qnetworksession#open&quot;&gt;open&lt;/a&gt;(). A network session is considered to be ready for socket operations if it &lt;a href=&quot;qnetworksession#isOpen&quot;&gt;isOpen&lt;/a&gt;() and connected.</source>
          <target state="translated">네트워크 세션이 연결되었습니다. 현재 프로세스가이 세션을 사용하려면 &lt;a href=&quot;qnetworksession#open&quot;&gt;open&lt;/a&gt; () 을 호출하여 관심을 등록해야 합니다. 소켓이 &lt;a href=&quot;qnetworksession#isOpen&quot;&gt;열려&lt;/a&gt; 있고 연결되어 있으면 네트워크 세션은 소켓 작동 준비가 된 것으로 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="7eb1e7478db6bb5ca883d0236ec54c8c8f42992b" translate="yes" xml:space="preserve">
          <source>The network session is in the process of being shut down.</source>
          <target state="translated">네트워크 세션이 종료되고 있습니다.</target>
        </trans-unit>
        <trans-unit id="f2b9e593cabe241b4541f1a1f42d53c172a41fac" translate="yes" xml:space="preserve">
          <source>The network session is not connected. The associated &lt;a href=&quot;qnetworkconfiguration&quot;&gt;QNetworkConfiguration&lt;/a&gt; has the state &lt;a href=&quot;qnetworkconfiguration#StateFlag-enum&quot;&gt;QNetworkConfiguration::Discovered&lt;/a&gt;.</source>
          <target state="translated">네트워크 세션이 연결되어 있지 않습니다. 연관된 &lt;a href=&quot;qnetworkconfiguration&quot;&gt;QNetworkConfiguration&lt;/a&gt; 의 상태는 &lt;a href=&quot;qnetworkconfiguration#StateFlag-enum&quot;&gt;QNetworkConfiguration :: Discovered&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c5359409e7661b702cde12a254446fab75a8da5f" translate="yes" xml:space="preserve">
          <source>The network session is not connected. The associated QNetworkConfiguration has the state &lt;a href=&quot;qnetworkconfiguration#StateFlag-enum&quot;&gt;QNetworkConfiguration::Discovered&lt;/a&gt;.</source>
          <target state="translated">네트워크 세션이 연결되지 않았습니다. 연결된 QNetworkConfiguration의 상태는 &lt;a href=&quot;qnetworkconfiguration#StateFlag-enum&quot;&gt;QNetworkConfiguration :: Discovered&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3b09d27d34d474e859e999abba7e56d70af68062" translate="yes" xml:space="preserve">
          <source>The network session is roaming from one access point to another access point.</source>
          <target state="translated">네트워크 세션이 한 액세스 지점에서 다른 액세스 지점으로 로밍 중입니다.</target>
        </trans-unit>
        <trans-unit id="3bc06e5f0a8359473c164b92a2906b37411b509f" translate="yes" xml:space="preserve">
          <source>The new</source>
          <target state="translated">새로운</target>
        </trans-unit>
        <trans-unit id="f30b45ed7bfe920ab4cb7e0dbb618d3b1fc693a6" translate="yes" xml:space="preserve">
          <source>The new &lt;a href=&quot;qml-qtquick-tableview&quot;&gt;TableView&lt;/a&gt; can be found in the Qt Quick module.</source>
          <target state="translated">새로운 &lt;a href=&quot;qml-qtquick-tableview&quot;&gt;TableView&lt;/a&gt; 는 Qt Quick 모듈에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa4d732b8ea6e5635fc8614a3f1067693913a41a" translate="yes" xml:space="preserve">
          <source>The new access point is not suitable for the application. By calling this function the session returns to the previous access point/configuration. This action may invalidate any socket that has been created via the not desired access point.</source>
          <target state="translated">새로운 액세스 포인트가 응용 프로그램에 적합하지 않습니다. 이 기능을 호출하면 세션이 이전 액세스 포인트 / 구성으로 돌아갑니다. 이 조치는 원하지 않는 액세스 포인트를 통해 작성된 소켓을 무효화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="40f74ea6322134c13f80f1c6249ec7ab91349e67" translate="yes" xml:space="preserve">
          <source>The new format is</source>
          <target state="translated">새로운 형식은</target>
        </trans-unit>
        <trans-unit id="fb1af2129332af898b4437051de95d5bcc8de7e1" translate="yes" xml:space="preserve">
          <source>The new parent to animate to.</source>
          <target state="translated">애니메이션 할 새 부모입니다.</target>
        </trans-unit>
        <trans-unit id="408e6a2d48e9c5d34ea489fcba4cfb056854d3b9" translate="yes" xml:space="preserve">
          <source>The new shape displays. The following shows how a clipping path can modify how an image displays:</source>
          <target state="translated">새로운 모양이 표시됩니다. 다음은 클리핑 경로가 이미지 표시 방법을 수정하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="5874121596e3ae5472b35339ec3769607fe4d3c3" translate="yes" xml:space="preserve">
          <source>The new thread is not started -- it must be started by an explicit call to &lt;a href=&quot;qthread#start&quot;&gt;start&lt;/a&gt;(). This allows you to connect to its signals, move QObjects to the thread, choose the new thread's priority and so on. The function</source>
          <target state="translated">새 스레드가 시작되지 않았습니다. 명시적인 &lt;a href=&quot;qthread#start&quot;&gt;start&lt;/a&gt; () 호출로 시작 해야합니다 . 이를 통해 신호에 연결하고 QObject를 스레드로 이동하고 새 스레드의 우선 순위 등을 선택할 수 있습니다. 함수</target>
        </trans-unit>
        <trans-unit id="f8425367069fe5701c0878b711b94f8d850698df" translate="yes" xml:space="preserve">
          <source>The new timeout value does not take effect until the device search is restarted. In addition the timeout does not affect the classic Bluetooth device search. Depending on the platform the classic search may add more time to the total discovery process beyond</source>
          <target state="translated">새 시간 초과 값은 장치 검색이 다시 시작될 때까지 적용되지 않습니다. 또한 시간 초과는 기존 Bluetooth 장치 검색에 영향을 미치지 않습니다. 플랫폼에 따라 클래식 검색은 전체 검색 프로세스에 더 많은 시간을 추가 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="57e04c618c6cf744e2b2c59da11320bda6b9110e" translate="yes" xml:space="preserve">
          <source>The new value is passed in</source>
          <target state="translated">새로운 가치가 전달됩니다</target>
        </trans-unit>
        <trans-unit id="234da685867a0dbb5ec03039c2ec00fcbe87c845" translate="yes" xml:space="preserve">
          <source>The newline character ('\n') is included in the buffer. If a newline is not encountered before maxSize - 1 bytes are read, a newline will not be inserted into the buffer. On windows newline characters are replaced with '\n'.</source>
          <target state="translated">개행 문자 ( '\ n')가 버퍼에 포함됩니다. maxSize-1 바이트를 읽기 전에 줄 바꿈이 발생하지 않으면 줄 바꿈이 버퍼에 삽입되지 않습니다. Windows에서 줄 바꿈 문자는 '\ n'으로 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="180c5b859beecd30804220ff7ba2a6b69693db8b" translate="yes" xml:space="preserve">
          <source>The newly added</source>
          <target state="translated">새로 추가 된</target>
        </trans-unit>
        <trans-unit id="ea124dd09b8ef16f5917522f38d0d590f6fa4256" translate="yes" xml:space="preserve">
          <source>The newly pushed group will inherit the same filtering settings of the group that was on the top of the stack; that is, the filtering will not be changed by pushing a new group.</source>
          <target state="translated">새로 푸시 된 그룹은 스택 맨 위에 있던 그룹의 동일한 필터링 설정을 상속합니다. 즉, 새 그룹을 푸시해도 필터링이 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fecd28a78f78c05dfba34a4a0d5cd009a14bdfd0" translate="yes" xml:space="preserve">
          <source>The next call to &lt;a href=&quot;qimagereader#read&quot;&gt;read&lt;/a&gt;() will attempt to read this image.</source>
          <target state="translated">다음 번에 &lt;a href=&quot;qimagereader#read&quot;&gt;읽기&lt;/a&gt; ()를 호출하면 이 이미지를 읽으려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="cd09c6acf2727a710756ad4c06ad85412cfa18cd" translate="yes" xml:space="preserve">
          <source>The next child of the context node</source>
          <target state="translated">컨텍스트 노드의 다음 자식</target>
        </trans-unit>
        <trans-unit id="1d53a5ecd15dc0623346157b9af81e4bab200587" translate="yes" xml:space="preserve">
          <source>The next example shows how to derive from an existing style to customize the look of a graphical element:</source>
          <target state="translated">다음 예제는 기존 스타일에서 파생하여 그래픽 요소의 모양을 사용자 정의하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="0ed7e001e3716975746d1659d2a6991bc3e84c00" translate="yes" xml:space="preserve">
          <source>The next example uses &lt;a href=&quot;qtextstream&quot;&gt;QTextStream&lt;/a&gt; to read a text file line by line:</source>
          <target state="translated">다음 예제는 &lt;a href=&quot;qtextstream&quot;&gt;QTextStream&lt;/a&gt; 을 사용 하여 텍스트 파일을 한 줄씩 읽습니다.</target>
        </trans-unit>
        <trans-unit id="63cfad7f04da72d044c14e611ec0a1127b5ba29e" translate="yes" xml:space="preserve">
          <source>The next item (in a list) is selected. For example, the selected tab of a &lt;a href=&quot;qtabbar&quot;&gt;QTabBar&lt;/a&gt; is next to this item.</source>
          <target state="translated">다음 항목 (목록에서)이 선택됩니다. 예를 들어, &lt;a href=&quot;qtabbar&quot;&gt;QTabBar&lt;/a&gt; 의 선택된 탭 이이 항목 옆에 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c709b70f6ef279f5e1695cdf659d3a4807de452" translate="yes" xml:space="preserve">
          <source>The next section is selected</source>
          <target state="translated">다음 섹션이 선택되었습니다</target>
        </trans-unit>
        <trans-unit id="5223163259f16945f949e9bfe24cfdfb8a1cbc2b" translate="yes" xml:space="preserve">
          <source>The next sections illustrate each layout.</source>
          <target state="translated">다음 섹션에서는 각 레이아웃에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="120aef0c983732dc94377e46d9152bc0aa489152" translate="yes" xml:space="preserve">
          <source>The next step is to combine all three layouts into one &lt;b&gt;main layout&lt;/b&gt;. The main layout is the top level widget's (in this case, the &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt;) layout. It is important that your top level widget has a layout; otherwise, the widgets on your window will not resize when your window is resized. To set the layout, &lt;b&gt;Right click&lt;/b&gt; anywhere on your form, outside of the three separate layouts, and select &lt;b&gt;Lay Out Horizontally&lt;/b&gt;. Alternatively, you could also select &lt;b&gt;Lay Out in a Grid&lt;/b&gt; -- you will still see the same arrangement (shown below).</source>
          <target state="translated">다음 단계는 세 가지 레이아웃을 모두 하나의 &lt;b&gt;기본 레이아웃&lt;/b&gt; 으로 결합하는 것 입니다. 기본 레이아웃은 최상위 위젯 (이 경우 &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; ) 레이아웃입니다. 최상위 위젯에는 레이아웃이 있어야합니다. 그렇지 않으면, 창의 크기를 조정할 때 창의 위젯 크기가 조정되지 않습니다. 레이아웃을 설정하려면 세 개의 개별 레이아웃 외부에서 양식의 아무 곳 이나 &lt;b&gt;마우스 오른쪽 단추로 클릭&lt;/b&gt; 하고 &lt;b&gt;가로&lt;/b&gt; 레이아웃을 선택하십시오 . 또는 &lt;b&gt;격자에서 배치&lt;/b&gt; 를 선택할 수도 있습니다. 여전히 같은 배열이 표시됩니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="87bebbcab0404856fc3e6acf0852fdf26d6b5fcf" translate="yes" xml:space="preserve">
          <source>The next step is to provide an implementation of &lt;a href=&quot;qcanbusdevice&quot;&gt;QCanBusDevice&lt;/a&gt;. At the very least, the following pure virtual functions must be implemented:</source>
          <target state="translated">다음 단계는 &lt;a href=&quot;qcanbusdevice&quot;&gt;QCanBusDevice&lt;/a&gt; 구현을 제공하는 것입니다 . 최소한 다음과 같은 순수한 가상 기능을 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="83bd1df0161bd7f457eb7261cc71e5cc6df6c4fb" translate="yes" xml:space="preserve">
          <source>The next tab (typically the tab on the right) is selected.</source>
          <target state="translated">다음 탭 (일반적으로 오른쪽의 탭)이 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="ca5492498925113c439977d17f8c560bdb9bc029" translate="yes" xml:space="preserve">
          <source>The next tab is selected.</source>
          <target state="translated">다음 탭이 선택되었습니다.</target>
        </trans-unit>
        <trans-unit id="d1d2100c26ca4513bcc47f5f5ea33877b1b919ca" translate="yes" xml:space="preserve">
          <source>The next() call in the loop is made every time. It jumps over the next item in the list. The &lt;a href=&quot;qmutablelistiterator#remove&quot;&gt;remove()&lt;/a&gt; function removes the last item that we jumped over from the list. The call to &lt;a href=&quot;qmutablelistiterator#remove&quot;&gt;remove()&lt;/a&gt; does not invalidate the iterator, so it is safe to continue using it. This works just as well when iterating backward:</source>
          <target state="translated">루프에서 next () 호출은 매번 수행됩니다. 목록에서 다음 항목으로 건너 뜁니다. &lt;a href=&quot;qmutablelistiterator#remove&quot;&gt;제거 ()&lt;/a&gt; 함수는 우리가 목록에서 이상 뛰어 것을 마지막 항목을 제거합니다. &lt;a href=&quot;qmutablelistiterator#remove&quot;&gt;remove ()를&lt;/a&gt; 호출 해도 반복자가 무효화되지 않으므로 계속 사용하는 것이 안전합니다. 이것은 거꾸로 반복 할 때에도 잘 작동합니다.</target>
        </trans-unit>
        <trans-unit id="cc27a83965d13061c10b3c456ea8e10bd3e74366" translate="yes" xml:space="preserve">
          <source>The nfc adapter is offline.</source>
          <target state="translated">NFC 어댑터가 오프라인 상태입니다.</target>
        </trans-unit>
        <trans-unit id="095753efcfbd86fa9bd561ca12b5539079a14054" translate="yes" xml:space="preserve">
          <source>The nfc adapter is online.</source>
          <target state="translated">NFC 어댑터가 온라인 상태입니다.</target>
        </trans-unit>
        <trans-unit id="e3d536b3b8eec50c6f8839017dfa7a09c7fd5522" translate="yes" xml:space="preserve">
          <source>The nfc adapter is turning off.</source>
          <target state="translated">NFC 어댑터가 꺼져 있습니다.</target>
        </trans-unit>
        <trans-unit id="811a5fab4b079f63c2d0bb380ecbd21149c01306" translate="yes" xml:space="preserve">
          <source>The nfc adapter is turning on.</source>
          <target state="translated">NFC 어댑터가 켜져 있습니다.</target>
        </trans-unit>
        <trans-unit id="763b4d6f240049e999bf330266f5859bb1f1d255" translate="yes" xml:space="preserve">
          <source>The nlerp() function is typically faster than &lt;a href=&quot;qquaternion#slerp&quot;&gt;slerp&lt;/a&gt;() and will give approximate results to spherical interpolation that are good enough for some applications.</source>
          <target state="translated">nlerp () 함수는 일반적으로 &lt;a href=&quot;qquaternion#slerp&quot;&gt;slerp&lt;/a&gt; () 보다 빠르며 일부 응용 프로그램에 충분한 구형 보간에 대한 대략적인 결과를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="e7935820ff8df21731b10d72b1b07e2393fc1dd6" translate="yes" xml:space="preserve">
          <source>The node and vertex threshold for a transform node to become a batch root can be overridden using the environment variables &lt;code&gt;QSG_RENDERER_BATCH_NODE_THRESHOLD=[count]&lt;/code&gt; and &lt;code&gt;QSG_RENDERER_BATCH_VERTEX_THRESHOLD=[count]&lt;/code&gt;. Overriding these flags will be mostly useful for platform vendors.</source>
          <target state="translated">변환 노드가 배치 루트가되는 노드 및 정점 임계 값은 환경 변수 &lt;code&gt;QSG_RENDERER_BATCH_NODE_THRESHOLD=[count]&lt;/code&gt; 및 &lt;code&gt;QSG_RENDERER_BATCH_VERTEX_THRESHOLD=[count]&lt;/code&gt; 를 사용하여 무시할 수 있습니다 . 이 플래그를 재정의하면 플랫폼 공급 업체에 주로 유용합니다.</target>
        </trans-unit>
        <trans-unit id="67268697060f412a1201c68674cd3080d62c015b" translate="yes" xml:space="preserve">
          <source>The node in the tree has a sibling (i.e., there is another node in the same column).</source>
          <target state="translated">트리의 노드에는 형제가 있습니다 (즉, 동일한 열에 다른 노드가 있습니다).</target>
        </trans-unit>
        <trans-unit id="45a01606c88802783d68e6fad6267f5918dc4fea" translate="yes" xml:space="preserve">
          <source>The node index returned will be the element node whose value is of type &lt;code&gt;ID&lt;/code&gt; and equals</source>
          <target state="translated">리턴 된 노드 인덱스는 값이 &lt;code&gt;ID&lt;/code&gt; 유형 이고 동일한 요소 노드입니다.</target>
        </trans-unit>
        <trans-unit id="19bb0523de44cfc56069dde60d3e382bf4656fbb" translate="yes" xml:space="preserve">
          <source>The node is owned by its parent and will be deleted when the parent is deleted.</source>
          <target state="translated">노드는 부모가 소유하며 부모가 삭제 될 때 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="ca0b88de427409a5fe31f0b0c90cab58229dc490" translate="yes" xml:space="preserve">
          <source>The node model represented by a subclass of &lt;a href=&quot;qabstractxmlnodemodel&quot;&gt;QAbstractXmlNodeModel&lt;/a&gt; is meant to be accessed by the Qt XML Patterns query engine. If the API seems a little strange in a few places, it is because the member functions are called by the query engine as it evaluates an &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt;. They aren't meant to be used programatically.</source>
          <target state="translated">&lt;a href=&quot;qabstractxmlnodemodel&quot;&gt;QAbstractXmlNodeModel&lt;/a&gt; 의 서브 클래스로 표시되는 노드 모델은 Qt XML 패턴 쿼리 엔진에 의해 액세스됩니다. API가 몇 군데에서 조금 이상해 보인다면 &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery를&lt;/a&gt; 평가할 때 쿼리 엔진이 멤버 함수를 호출하기 때문 입니다. 그것들은 프로그래밍 방식으로 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="934c8ec0ebced9af9cfa3d2bb42901de3680a32d" translate="yes" xml:space="preserve">
          <source>The node model represented by a subclass of QAbstractXmlNodeModel is meant to be accessed by the Qt XML Patterns query engine. If the API seems a little strange in a few places, it is because the member functions are called by the query engine as it evaluates an &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt;. They aren't meant to be used programatically.</source>
          <target state="translated">QAbstractXmlNodeModel의 하위 클래스로 표시되는 노드 모델은 Qt XML 패턴 쿼리 엔진에서 액세스 할 수 있습니다. API가 몇 군데 이상해 보인다면 &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery를&lt;/a&gt; 평가할 때 쿼리 엔진이 멤버 함수를 호출하기 때문 입니다. 프로그래밍 방식으로 사용하기위한 것이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="a2dff030f13a48a9e490dacaae5f63101c137094" translate="yes" xml:space="preserve">
          <source>The node type of the node containing this character data is returned by &lt;a href=&quot;qdomcharacterdata#nodeType&quot;&gt;nodeType&lt;/a&gt;().</source>
          <target state="translated">이 문자 데이터를 포함하는 노드의 노드 유형은 &lt;a href=&quot;qdomcharacterdata#nodeType&quot;&gt;nodeType&lt;/a&gt; ()에 의해 리턴됩니다 .</target>
        </trans-unit>
        <trans-unit id="84114eecbedca45b9fe469a65fae0a31515b6175" translate="yes" xml:space="preserve">
          <source>The node's name and value (the meaning of which varies depending on its type) is returned by &lt;a href=&quot;qdomnode#nodeName&quot;&gt;nodeName&lt;/a&gt;() and &lt;a href=&quot;qdomnode#nodeValue&quot;&gt;nodeValue&lt;/a&gt;() respectively. The node's type is returned by &lt;a href=&quot;qdomnode#nodeType&quot;&gt;nodeType&lt;/a&gt;(). The node's value can be set with &lt;a href=&quot;qdomnode#setNodeValue&quot;&gt;setNodeValue&lt;/a&gt;().</source>
          <target state="translated">노드 이름과 값 (유형에 따라 의미가 다름)은 각각 &lt;a href=&quot;qdomnode#nodeName&quot;&gt;nodeName&lt;/a&gt; () 및 &lt;a href=&quot;qdomnode#nodeValue&quot;&gt;nodeValue&lt;/a&gt; ()에 의해 반환됩니다 . 노드 유형은 &lt;a href=&quot;qdomnode#nodeType&quot;&gt;nodeType&lt;/a&gt; ()에 의해 리턴됩니다 . 노드의 값은 &lt;a href=&quot;qdomnode#setNodeValue&quot;&gt;setNodeValue&lt;/a&gt; () 로 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4d6f1d59cfdb6259b7c53f4eb77f5e8f9af65a28" translate="yes" xml:space="preserve">
          <source>The node's virtual &lt;a href=&quot;qsgnode#preprocess&quot;&gt;preprocess&lt;/a&gt;() function will be called before rendering starts.</source>
          <target state="translated">렌더링을 시작하기 전에 노드의 가상 &lt;a href=&quot;qsgnode#preprocess&quot;&gt;사전 프로세스&lt;/a&gt; () 함수가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="88486230cd76a912034951c993fc51b358d221d4" translate="yes" xml:space="preserve">
          <source>The nodes in the list are not copied; so changing the nodes in the list will also change the children of this node.</source>
          <target state="translated">목록의 노드는 복사되지 않습니다. 따라서 목록에서 노드를 변경하면이 노드의 자식도 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="78b07a01280dfbf202336d5ba331d16df7eee0e7" translate="yes" xml:space="preserve">
          <source>The non in-place modifying functions such as mapped() and filtered() makes a copy of the container when called. If you are using STL containers this copy operation might take some time, in this case we recommend specifying the begin and end iterators for the container instead.</source>
          <target state="translated">매핑 된 () 및 필터링 된 ()과 같은 비 위치 수정 함수는 호출 될 때 컨테이너의 사본을 만듭니다. STL 컨테이너를 사용하는 경우이 복사 작업에 다소 시간이 걸릴 수 있습니다.이 경우 컨테이너의 시작 및 종료 반복자를 대신 지정하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="34820a7e9ab7a07c8527a8194d403444c6443832" translate="yes" xml:space="preserve">
          <source>The non-blocking alternative is to connect to the &lt;a href=&quot;qlocalserver#newConnection&quot;&gt;newConnection&lt;/a&gt;() signal.</source>
          <target state="translated">비 차단 대안은 &lt;a href=&quot;qlocalserver#newConnection&quot;&gt;newConnection&lt;/a&gt; () 신호 에 연결하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="b0a0335fe95138ebab2e3eeeac12df8c9d41ae71" translate="yes" xml:space="preserve">
          <source>The non-blocking alternative is to connect to the &lt;a href=&quot;qtcpserver#newConnection&quot;&gt;newConnection&lt;/a&gt;() signal.</source>
          <target state="translated">비 차단 대안은 &lt;a href=&quot;qtcpserver#newConnection&quot;&gt;newConnection&lt;/a&gt; () 신호 에 연결하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="3e33d9cc2bf2587f6197f53c79b827dca970a3ca" translate="yes" xml:space="preserve">
          <source>The non-named capturing groups do not capture substrings; named capturing groups still work as intended, as well as the implicit capturing group number 0 corresponding to the entire match. There is no equivalent for this option in Perl regular expressions.</source>
          <target state="translated">명명되지 않은 캡처 그룹은 하위 문자열을 캡처하지 않습니다. 명명 된 캡처 그룹은 의도 한대로 작동하며 전체 일치에 해당하는 암시 적 캡처 그룹 번호 0입니다. Perl 정규식에는이 옵션에 해당하는 것이 없습니다.</target>
        </trans-unit>
        <trans-unit id="7f74443bb7ede8384da348e785ca78f1e9861beb" translate="yes" xml:space="preserve">
          <source>The non-threaded render loop is currently used by default on Windows with ANGLE or a non-default opengl32 implementation, &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt;, and Linux with Mesa drivers. For the latter this is mostly a precautionary measure, as not all combinations of OpenGL drivers and windowing systems have been tested. At the same time implementations like ANGLE or Mesa llvmpipe are not able to function properly with threaded rendering at all so not using threaded rendering is essential for these.</source>
          <target state="translated">스레드되지 않은 렌더 루프는 현재 ANGLE이있는 Windows 또는 기본이 아닌 opengl32 구현, &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; 및 Mesa 드라이버가있는 Linux에서 기본적으로 사용됩니다 . 후자의 경우 OpenGL 드라이버와 윈도우 시스템의 모든 조합이 테스트 된 것은 아니기 때문에 대부분 예방 조치입니다. 동시에 ANGLE 또는 Mesa llvmpipe와 같은 구현은 스레드 렌더링에서 제대로 작동하지 않으므로 스레드 렌더링을 사용하지 않는 것이 필수적입니다.</target>
        </trans-unit>
        <trans-unit id="8d1a35b52d05b49df6590371743b2018994bb6c0" translate="yes" xml:space="preserve">
          <source>The non-threaded render loop is currently used by default on Windows with ANGLE or a non-default opengl32 implementation, macOS with OpenGL, and Linux with some drivers. For the latter this is mostly a precautionary measure, as not all combinations of OpenGL drivers and windowing systems have been tested. At the same time implementations like ANGLE or Mesa llvmpipe are not able to function properly with threaded rendering at all so not using threaded rendering is essential for these.</source>
          <target state="translated">스레드되지 않은 렌더링 루프는 현재 ANGLE 또는 기본이 아닌 opengl32 구현이있는 Windows, OpenGL이있는 macOS 및 일부 드라이버가있는 Linux에서 기본적으로 사용됩니다. 후자의 경우 OpenGL 드라이버와 윈도우 시스템의 모든 조합이 테스트되지 않았기 때문에 이는 대부분 예방 조치입니다. 동시에 ANGLE 또는 Mesa llvmpipe와 같은 구현은 스레드 렌더링으로 제대로 작동하지 않으므로 스레드 렌더링을 사용하지 않는 것이 필수적입니다.</target>
        </trans-unit>
        <trans-unit id="f79d8c826fd17f79a4b4fbe50bcc0af4852f0af8" translate="yes" xml:space="preserve">
          <source>The normal Alt keys, but not keys like AltGr.</source>
          <target state="translated">일반적인 Alt 키는 AltGr과 같은 키는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="8af927f1bb322ad2c28b5d6d1f474c95f91b2c5c" translate="yes" xml:space="preserve">
          <source>The normal and most flexible way to include a plugin with an application is to compile it into a dynamic library that is shipped separately, and detected and loaded at runtime.</source>
          <target state="translated">애플리케이션에 플러그인을 포함시키는 일반적이고 가장 유연한 방법은 플러그인을 별도로 제공하고 런타임에 감지하여로드하는 동적 라이브러리로 컴파일하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="12731fb0f05a3b761b8613ee0df999976abe74e9" translate="yes" xml:space="preserve">
          <source>The normal button for a MDI subwindow in the menu bar.</source>
          <target state="translated">메뉴 표시 줄에있는 MDI 하위 창의 일반 버튼입니다.</target>
        </trans-unit>
        <trans-unit id="9d3fb606a6d9c73bae0a81916cfbdfc820fbc7a0" translate="yes" xml:space="preserve">
          <source>The normal rounded look above the pages</source>
          <target state="translated">페이지 위의 일반적인 둥근 모양</target>
        </trans-unit>
        <trans-unit id="69f2d0c6965eb6af402c27d5924108e3151288ed" translate="yes" xml:space="preserve">
          <source>The normal rounded look below the pages</source>
          <target state="translated">페이지 아래의 일반적인 둥근 모양</target>
        </trans-unit>
        <trans-unit id="1fda4ae93b249fd27cab68c2cef5e07982f0292a" translate="yes" xml:space="preserve">
          <source>The normal rounded look on the left side of the pages</source>
          <target state="translated">페이지 왼쪽의 일반적인 둥근 모양</target>
        </trans-unit>
        <trans-unit id="f79c8458c0ced2bb31ccf972d16feb71b1850178" translate="yes" xml:space="preserve">
          <source>The normal rounded look on the right side the pages</source>
          <target state="translated">페이지 오른쪽의 일반적인 둥근 모양</target>
        </trans-unit>
        <trans-unit id="212aa34d02c2050cdb884184fc3b7b7095588aeb" translate="yes" xml:space="preserve">
          <source>The normal way for an event to be delivered is by calling a virtual function. For example, &lt;a href=&quot;qpaintevent&quot;&gt;QPaintEvent&lt;/a&gt; is delivered by calling &lt;a href=&quot;qwidget#paintEvent&quot;&gt;QWidget::paintEvent&lt;/a&gt;(). This virtual function is responsible for reacting appropriately, normally by repainting the widget. If you do not perform all the necessary work in your implementation of the virtual function, you may need to call the base class's implementation.</source>
          <target state="translated">이벤트가 전달되는 일반적인 방법은 가상 함수를 호출하는 것입니다. 예를 들어 &lt;a href=&quot;qpaintevent&quot;&gt;QPaintEvent&lt;/a&gt; 는 &lt;a href=&quot;qwidget#paintEvent&quot;&gt;QWidget :: paintEvent&lt;/a&gt; ()를 호출하여 전달됩니다 . 이 가상 기능은 일반적으로 위젯을 다시 페인트하여 적절하게 반응합니다. 가상 함수 구현에서 필요한 모든 작업을 수행하지 않으면 기본 클래스의 구현을 호출해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="eff5ef7260be343d1828fd1fc09ea6b812a70fef" translate="yes" xml:space="preserve">
          <source>The normal way to use &lt;a href=&quot;qtabwidget&quot;&gt;QTabWidget&lt;/a&gt; is to do the following:</source>
          <target state="translated">&lt;a href=&quot;qtabwidget&quot;&gt;QTabWidget&lt;/a&gt; 을 사용하는 일반적인 방법 은 다음을 수행하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="cbf4ba278018eb2524fb763d4d128b001c1a1623" translate="yes" xml:space="preserve">
          <source>The normal way to use QTabWidget is to do the following:</source>
          <target state="translated">QTabWidget을 사용하는 일반적인 방법은 다음을 수행하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ce79893dfd7d722ed4d1a5016b44f6fc70996f52" translate="yes" xml:space="preserve">
          <source>The notation of the days can be altered to a single letter abbreviations (&quot;M&quot; for &quot;Monday&quot;) by setting the &lt;a href=&quot;qcalendarwidget#horizontalHeaderFormat-prop&quot;&gt;horizontalHeaderFormat&lt;/a&gt; property to &lt;a href=&quot;qcalendarwidget#HorizontalHeaderFormat-enum&quot;&gt;QCalendarWidget::SingleLetterDayNames&lt;/a&gt;. Setting the same property to &lt;a href=&quot;qcalendarwidget#HorizontalHeaderFormat-enum&quot;&gt;QCalendarWidget::LongDayNames&lt;/a&gt; makes the header display the complete day names. The week numbers can be removed by setting the &lt;a href=&quot;qcalendarwidget#verticalHeaderFormat-prop&quot;&gt;verticalHeaderFormat&lt;/a&gt; property to &lt;a href=&quot;qcalendarwidget#VerticalHeaderFormat-enum&quot;&gt;QCalendarWidget::NoVerticalHeader&lt;/a&gt;. The calendar grid can be turned on by setting the &lt;a href=&quot;qcalendarwidget#gridVisible-prop&quot;&gt;gridVisible&lt;/a&gt; property to true using the &lt;a href=&quot;qcalendarwidget#gridVisible-prop&quot;&gt;setGridVisible&lt;/a&gt;() function:</source>
          <target state="translated">&lt;a href=&quot;qcalendarwidget#horizontalHeaderFormat-prop&quot;&gt;horizontalHeaderFormat&lt;/a&gt; 속성을 &lt;a href=&quot;qcalendarwidget#HorizontalHeaderFormat-enum&quot;&gt;QCalendarWidget :: SingleLetterDayNames&lt;/a&gt; 로 설정하여 요일 표기를 단일 문자 약어 ( &quot;Monday&quot;의 경우 &quot;M&quot;)로 변경할 수 있습니다 . 동일한 특성을 &lt;a href=&quot;qcalendarwidget#HorizontalHeaderFormat-enum&quot;&gt;QCalendarWidget :: LongDayNames&lt;/a&gt; 로 설정하면 헤더에 완전한 요일 이름이 표시됩니다. &lt;a href=&quot;qcalendarwidget#verticalHeaderFormat-prop&quot;&gt;verticalHeaderFormat&lt;/a&gt; 속성을 &lt;a href=&quot;qcalendarwidget#VerticalHeaderFormat-enum&quot;&gt;QCalendarWidget :: NoVerticalHeader&lt;/a&gt; 로 설정하면 주 번호를 제거 할 수 있습니다 . &lt;a href=&quot;qcalendarwidget#gridVisible-prop&quot;&gt;setGridVisible&lt;/a&gt; () 함수를 사용하여 &lt;a href=&quot;qcalendarwidget#gridVisible-prop&quot;&gt;gridVisible&lt;/a&gt; 속성을 true 로 설정하면 캘린더 그리드를 켤 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="efe36def12999e05d1a5465ff7ea01122e29b0d1" translate="yes" xml:space="preserve">
          <source>The notch size is in range control units, not pixels, and if possible it is a multiple of &lt;a href=&quot;qabstractslider#singleStep-prop&quot;&gt;singleStep&lt;/a&gt;() that results in an on-screen notch size near &lt;a href=&quot;qdial#notchTarget-prop&quot;&gt;notchTarget&lt;/a&gt;().</source>
          <target state="translated">노치 크기 범위 제어 유닛이 아닌 픽셀에, 가능한 경우는의 배수 &lt;a href=&quot;qabstractslider#singleStep-prop&quot;&gt;singleStep&lt;/a&gt; 그 근처 화면 노치 크기 결과 () &lt;a href=&quot;qdial#notchTarget-prop&quot;&gt;notchTarget&lt;/a&gt; ().</target>
        </trans-unit>
        <trans-unit id="a5a5c0387f811179e1574c402b1f0c30661a916d" translate="yes" xml:space="preserve">
          <source>The notch target is the number of pixels &lt;a href=&quot;qdial&quot;&gt;QDial&lt;/a&gt; attempts to put between each notch.</source>
          <target state="translated">노치 대상은 &lt;a href=&quot;qdial&quot;&gt;QDial&lt;/a&gt; 이 각 노치 사이에 놓으 려는 픽셀 수입니다 .</target>
        </trans-unit>
        <trans-unit id="91bdcc27992d51ef56d1830d29b898258292d3bf" translate="yes" xml:space="preserve">
          <source>The notifiable properties are &lt;a href=&quot;qml-qtmultimedia-audio#position-prop&quot;&gt;position&lt;/a&gt; and &lt;a href=&quot;qml-qtmultimedia-audio#bufferProgress-prop&quot;&gt;bufferProgress&lt;/a&gt;.</source>
          <target state="translated">통지 가능한 프로퍼티는 &lt;a href=&quot;qml-qtmultimedia-audio#position-prop&quot;&gt;position&lt;/a&gt; 및 &lt;a href=&quot;qml-qtmultimedia-audio#bufferProgress-prop&quot;&gt;bufferProgress&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="464c974dde0d4913fcb9a01ad9005d20a42f3519" translate="yes" xml:space="preserve">
          <source>The notifiable properties are &lt;a href=&quot;qml-qtmultimedia-mediaplayer#position-prop&quot;&gt;position&lt;/a&gt; and &lt;a href=&quot;qml-qtmultimedia-mediaplayer#bufferProgress-prop&quot;&gt;bufferProgress&lt;/a&gt;.</source>
          <target state="translated">통지 가능한 프로퍼티는 &lt;a href=&quot;qml-qtmultimedia-mediaplayer#position-prop&quot;&gt;position&lt;/a&gt; 및 &lt;a href=&quot;qml-qtmultimedia-mediaplayer#bufferProgress-prop&quot;&gt;bufferProgress&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c27f6258b1f9c873a931075f103aaf6ade952e83" translate="yes" xml:space="preserve">
          <source>The notifiable properties are &lt;a href=&quot;qml-qtmultimedia-video#position-prop&quot;&gt;position&lt;/a&gt; and &lt;a href=&quot;qml-qtmultimedia-video#bufferProgress-prop&quot;&gt;bufferProgress&lt;/a&gt;.</source>
          <target state="translated">통지 가능한 프로퍼티는 &lt;a href=&quot;qml-qtmultimedia-video#position-prop&quot;&gt;position&lt;/a&gt; 및 &lt;a href=&quot;qml-qtmultimedia-video#bufferProgress-prop&quot;&gt;bufferProgress&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d5eeb529b6108251eada347ca92b14e153729655" translate="yes" xml:space="preserve">
          <source>The notification source is another connection</source>
          <target state="translated">알림 소스는 다른 연결입니다</target>
        </trans-unit>
        <trans-unit id="14b7d6ca415fdcad521c1d1f3a045057f41d34a4" translate="yes" xml:space="preserve">
          <source>The notification source is this connection</source>
          <target state="translated">알림 소스는이 연결입니다</target>
        </trans-unit>
        <trans-unit id="9e35631f144f66dfe38520320b09bf8c0e5ee073" translate="yes" xml:space="preserve">
          <source>The notification source is unknown</source>
          <target state="translated">알림 소스를 알 수 없습니다</target>
        </trans-unit>
        <trans-unit id="16431e607b888ee93039b1c0ac0abc8b4e33013a" translate="yes" xml:space="preserve">
          <source>The notifier is enabled by default, i.e. it emits the &lt;a href=&quot;qsocketnotifier#activated&quot;&gt;activated&lt;/a&gt;() signal whenever a socket event corresponding to its &lt;a href=&quot;qsocketnotifier#type&quot;&gt;type&lt;/a&gt; occurs. If it is disabled, it ignores socket events (the same effect as not creating the socket notifier).</source>
          <target state="translated">알리미는 기본적으로 활성화되어 있습니다. 즉, 해당 &lt;a href=&quot;qsocketnotifier#type&quot;&gt;유형에&lt;/a&gt; 해당하는 소켓 이벤트가 발생할 때마다 &lt;a href=&quot;qsocketnotifier#activated&quot;&gt;활성화 된&lt;/a&gt; () 신호를 방출 합니다. 비활성화 된 경우 소켓 이벤트를 무시합니다 (소켓 알리미를 작성하지 않는 것과 동일한 효과).</target>
        </trans-unit>
        <trans-unit id="358a58b400051a7bea47e1f56a23f8b50cb03431" translate="yes" xml:space="preserve">
          <source>The notifier is enabled by default, i.e. it emits the &lt;a href=&quot;qwineventnotifier#activated&quot;&gt;activated&lt;/a&gt;() signal whenever the corresponding event is signalled. However, it is generally advisable to explicitly enable or disable the event notifier.</source>
          <target state="translated">알리미는 기본적으로 활성화되어 있습니다. 즉 , 해당 이벤트가 시그널링 될 때마다 &lt;a href=&quot;qwineventnotifier#activated&quot;&gt;활성화 된&lt;/a&gt; () 신호를 방출합니다 . 그러나 일반적으로 이벤트 알리미를 명시 적으로 활성화 또는 비활성화하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="3d3dfbdf7e50b984830359c72e8ac1ffdf986ccc" translate="yes" xml:space="preserve">
          <source>The notifier signal was introduced in Qt 5.4.</source>
          <target state="translated">알리미 신호는 Qt 5.4에 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="0ba11c57bc1dd984f553636ddd794a7e38f2cfb3" translate="yes" xml:space="preserve">
          <source>The null address object. Equivalent to &lt;a href=&quot;qhostaddress#QHostAddress&quot;&gt;QHostAddress&lt;/a&gt;(). See also &lt;a href=&quot;qhostaddress#isNull&quot;&gt;QHostAddress::isNull&lt;/a&gt;().</source>
          <target state="translated">널 주소 오브젝트 &lt;a href=&quot;qhostaddress#QHostAddress&quot;&gt;QHostAddress&lt;/a&gt; () 와 같습니다 . &lt;a href=&quot;qhostaddress#isNull&quot;&gt;QHostAddress :: isNull&lt;/a&gt; () 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0e44bd7d96583f7ba5be76512c558b6c849d3b5f" translate="yes" xml:space="preserve">
          <source>The null device of the operating system.</source>
          <target state="translated">운영 체제의 널 디바이스입니다.</target>
        </trans-unit>
        <trans-unit id="e7e932e70622f346b2ae62e65d8fb3081929729e" translate="yes" xml:space="preserve">
          <source>The number</source>
          <target state="translated">수</target>
        </trans-unit>
        <trans-unit id="d5f7bb5cbab81190203970c5d80cc9b99971c863" translate="yes" xml:space="preserve">
          <source>The number by which to increase or decrease the slider's value (relative to the size of the slider and its value range) on page steps.</source>
          <target state="translated">페이지 단계에서 슬라이더의 값 (슬라이더 크기 및 값 범위에 상대적인 값)을 늘리거나 줄이는 수입니다.</target>
        </trans-unit>
        <trans-unit id="a9fbc4912bf693a305777da0684cd20edba104d1" translate="yes" xml:space="preserve">
          <source>The number by which to increase or decrease the slider's value on page steps.</source>
          <target state="translated">페이지 단계에서 슬라이더의 값을 늘리거나 줄이는 데 사용되는 숫자입니다.</target>
        </trans-unit>
        <trans-unit id="a7bd71b0b495400ca2f890a81d092cf4a5c3f080" translate="yes" xml:space="preserve">
          <source>The number by which to increase or decrease the slider's value on single (or line) steps.</source>
          <target state="translated">단일 (또는 라인) 단계에서 슬라이더 값을 늘리거나 줄이는 데 사용되는 숫자입니다.</target>
        </trans-unit>
        <trans-unit id="8535fba7bd050fac6b3d1dfa4a17b2072c4a2d35" translate="yes" xml:space="preserve">
          <source>The number is formatted according to the current locale.</source>
          <target state="translated">숫자는 현재 로케일에 따라 형식이 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="cfa7cf51c401677eaacdedc0c001c63245210aed" translate="yes" xml:space="preserve">
          <source>The number is not well formed</source>
          <target state="translated">숫자가 잘 형성되지 않았습니다</target>
        </trans-unit>
        <trans-unit id="97ebcad80a9bd0d9b9c98aa1493421ec325e3bb1" translate="yes" xml:space="preserve">
          <source>The number of 1 bits in each character, including the parity bit, is always even.</source>
          <target state="translated">패리티 비트를 포함하여 각 문자에서 1 비트의 수는 항상 짝수입니다.</target>
        </trans-unit>
        <trans-unit id="f82cb6e9ead7b377f44bbf3dbfeb79e0c06b7a2d" translate="yes" xml:space="preserve">
          <source>The number of 1 bits in each character, including the parity bit, is always odd. It ensures that at least one state transition occurs in each character.</source>
          <target state="translated">패리티 비트를 포함하여 각 문자의 1 비트 수는 항상 홀수입니다. 각 문자에서 하나 이상의 상태 전이가 발생하도록합니다.</target>
        </trans-unit>
        <trans-unit id="8beac30bc5a7d0349d481b53a941a45bfa9cffb1" translate="yes" xml:space="preserve">
          <source>The number of Hertz for each step when tuning the radio manually. The value is for the current &lt;a href=&quot;qml-qtmultimedia-radio#band-prop&quot;&gt;band&lt;/a&gt;.</source>
          <target state="translated">라디오를 수동으로 튜닝 할 때 각 단계의 헤르츠 수입니다. 값은 현재 &lt;a href=&quot;qml-qtmultimedia-radio#band-prop&quot;&gt;밴드에 대한 것&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8d4789a93fe843bb219ee92995f092c143659b5b" translate="yes" xml:space="preserve">
          <source>The number of alternative routes</source>
          <target state="translated">대체 경로의 수</target>
        </trans-unit>
        <trans-unit id="8bb9e07804201955d85ce0c9ee7d0e2043d6c1f4" translate="yes" xml:space="preserve">
          <source>The number of alternative routes requested when requesting routes. The default value is 0.</source>
          <target state="translated">경로를 요청할 때 요청 된 대체 경로의 수입니다. 기본값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="a60afbf12fd18c1db545c03db6c03747ed9ceb1a" translate="yes" xml:space="preserve">
          <source>The number of anchors in a hypertext link has changed, perhaps because the display text has been split to provide more than one link.</source>
          <target state="translated">하이퍼 텍스트 링크의 앵커 수가 변경되었습니다. 표시 텍스트가 둘 이상의 링크를 제공하도록 분할 되었기 때문일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb8066ee47be987d2903a5fe5aed68cf5a264ce6" translate="yes" xml:space="preserve">
          <source>The number of arguments the reply is expected to have</source>
          <target state="translated">회신에 필요한 인수 수</target>
        </trans-unit>
        <trans-unit id="a510889c3c450433a7dc538aa63881835dc3477f" translate="yes" xml:space="preserve">
          <source>The number of audio channels (typically one for mono or two for stereo)</source>
          <target state="translated">오디오 채널 수 (일반적으로 모노 용 또는 스테레오 용 하나)</target>
        </trans-unit>
        <trans-unit id="c1cb3732a7cf30acb05c2d449d3f6ecb48b95a37" translate="yes" xml:space="preserve">
          <source>The number of bar sets in a bar series.</source>
          <target state="translated">바 시리즈의 바 세트 수입니다.</target>
        </trans-unit>
        <trans-unit id="5b643cca95a9c64650fff869ba8878c15d627fae" translate="yes" xml:space="preserve">
          <source>The number of bit planes is the number of bits of color and transparency information for each pixel. This is different from (i.e. smaller than) the depth when the image format contains unused bits.</source>
          <target state="translated">비트 평면의 수는 각 픽셀의 색상 및 투명도 정보의 비트 수입니다. 이는 이미지 형식에 사용되지 않은 비트가 포함되어있을 때의 깊이와 다릅니다 (즉, 깊이보다 작습니다).</target>
        </trans-unit>
        <trans-unit id="a0135833776677b53eaf9a5f3c5faeca32f7d6cf" translate="yes" xml:space="preserve">
          <source>The number of box-and-whiskers items in a box plot series.</source>
          <target state="translated">상자 그림 시리즈의 상자 및 수염 항목 수입니다.</target>
        </trans-unit>
        <trans-unit id="ed55a8255f6491d38d47f5ae46846d23b2969ad7" translate="yes" xml:space="preserve">
          <source>The number of candlestick items in a series.</source>
          <target state="translated">일련의 촛대 항목 수입니다.</target>
        </trans-unit>
        <trans-unit id="a1e3f5a2286ce6a1dcd63aee80f921e76ae4c755" translate="yes" xml:space="preserve">
          <source>The number of categories of an axis.</source>
          <target state="translated">축의 범주 수입니다.</target>
        </trans-unit>
        <trans-unit id="04bb844dcd0242be6b35d7a04d1e7623cc55a0cc" translate="yes" xml:space="preserve">
          <source>The number of categories.</source>
          <target state="translated">카테고리 수</target>
        </trans-unit>
        <trans-unit id="56ac7be00c5520fda55ea4637ca7de0b8fdca0ef" translate="yes" xml:space="preserve">
          <source>The number of channels in the media's audio stream.</source>
          <target state="translated">미디어 오디오 스트림의 채널 수입니다.</target>
        </trans-unit>
        <trans-unit id="a2eda2a6bba42d84d2454f0aba34f43dfdf947d9" translate="yes" xml:space="preserve">
          <source>The number of columns in the Tumbler.</source>
          <target state="translated">텀블러의 열 수입니다.</target>
        </trans-unit>
        <trans-unit id="e7e102774e82a71199fcbf583ddbe5846a966d25" translate="yes" xml:space="preserve">
          <source>The number of columns in the data array.</source>
          <target state="translated">데이터 배열의 열 수입니다.</target>
        </trans-unit>
        <trans-unit id="e23bcef52cb0f5d8b6d1bd31ff0b38080601fe66" translate="yes" xml:space="preserve">
          <source>The number of columns is fixed for the lifetime of the model after the &lt;a href=&quot;qml-qt-labs-qmlmodels-tablemodel#rows-prop&quot;&gt;rows&lt;/a&gt; property is set or &lt;a href=&quot;qml-qt-labs-qmlmodels-tablemodel#appendRow-method&quot;&gt;appendRow()&lt;/a&gt; is called for the first time.</source>
          <target state="translated">열 수는 &lt;a href=&quot;qml-qt-labs-qmlmodels-tablemodel#rows-prop&quot;&gt;rows&lt;/a&gt; 속성이 설정되거나 &lt;a href=&quot;qml-qt-labs-qmlmodels-tablemodel#appendRow-method&quot;&gt;appendRow ()&lt;/a&gt; 가 처음으로 호출 된 후 모델의 수명 동안 고정 됩니다.</target>
        </trans-unit>
        <trans-unit id="16392168c66e75fd8ccd486c0bf642fa8b459f22" translate="yes" xml:space="preserve">
          <source>The number of columns of the model that are mapped as the data for series. The default value is -1 (the number is limited by the number of columns in the model).</source>
          <target state="translated">계열의 데이터로 매핑 된 모델의 열 수입니다. 기본값은 -1입니다 (숫자는 모델의 열 수로 제한됨).</target>
        </trans-unit>
        <trans-unit id="e060d14673b6564f9d9f196c1f7e62cb69e29147" translate="yes" xml:space="preserve">
          <source>The number of columns of the model that are mapped as the data for the bar series. The default value is -1 (number limited to the number of columns in the model).</source>
          <target state="translated">막대 계열의 데이터로 매핑 된 모델의 열 수입니다. 기본값은 -1입니다 (숫자는 모델의 열 수로 제한됨).</target>
        </trans-unit>
        <trans-unit id="9352390684f5d0c1998e8f1f41711598daec74a5" translate="yes" xml:space="preserve">
          <source>The number of columns of the model that are mapped as the data for the box plot series. The minimum and default value is -1 (number limited to the number of columns in the model).</source>
          <target state="translated">상자 그림 계열의 데이터로 매핑 된 모델의 열 수입니다. 최소값과 기본값은 -1입니다 (숫자는 모델의 열 수로 제한됨).</target>
        </trans-unit>
        <trans-unit id="002c84b39bc8347850ed4d5cdce1cdafd6a7d26b" translate="yes" xml:space="preserve">
          <source>The number of columns of the model that are mapped as the data for the pie series. The default value is -1 (number limited by the number of columns in the model).</source>
          <target state="translated">파이 계열의 데이터로 매핑 된 모델의 열 수입니다. 기본값은 -1입니다 (숫자는 모델의 열 수로 제한됨).</target>
        </trans-unit>
        <trans-unit id="9aa96702133dda84380ccecd177ada93e5a98eae" translate="yes" xml:space="preserve">
          <source>The number of data bits in each character is 5. It is used for Baudot code. It generally only makes sense with older equipment such as teleprinters.</source>
          <target state="translated">각 문자의 데이터 비트 수는 5입니다. Baudot 코드에 사용됩니다. 일반적으로 텔레 프린터와 같은 구형 장비에서만 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e8f831043ba7a4b760fec8a249bb705944ceae40" translate="yes" xml:space="preserve">
          <source>The number of data bits in each character is 6. It is rarely used.</source>
          <target state="translated">각 문자의 데이터 비트 수는 6입니다. 거의 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="86f4358c15362241dbcffa86b5cbac6283d93743" translate="yes" xml:space="preserve">
          <source>The number of data bits in each character is 7. It is used for true ASCII. It generally only makes sense with older equipment such as teleprinters.</source>
          <target state="translated">각 문자의 데이터 비트 수는 7입니다. 실제 ASCII에 사용됩니다. 일반적으로 텔레 프린터와 같은 구형 장비에서만 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="26fa94e8f86ff6d43c1557473bd35c3920a5f60f" translate="yes" xml:space="preserve">
          <source>The number of data bits in each character is 8. It is used for most kinds of data, as this size matches the size of a byte. It is almost universally used in newer applications.</source>
          <target state="translated">각 문자의 데이터 비트 수는 8입니다.이 크기는 바이트 크기와 일치하므로 대부분의 종류의 데이터에 사용됩니다. 최신 응용 프로그램에서 거의 보편적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="eecccec71a456acf84f3b5f880cdaf53d5e2ef81" translate="yes" xml:space="preserve">
          <source>The number of data entries in the model.</source>
          <target state="translated">모델의 데이터 항목 수입니다.</target>
        </trans-unit>
        <trans-unit id="cfe7093f06cd47d88caef2f807f2860660047847" translate="yes" xml:space="preserve">
          <source>The number of data points in the series.</source>
          <target state="translated">시리즈의 데이터 포인트 수입니다.</target>
        </trans-unit>
        <trans-unit id="a7b4b3b08cfb01f6989b45bd0792401d09b05b83" translate="yes" xml:space="preserve">
          <source>The number of different colors available for the paint device. See also &lt;a href=&quot;qpaintdevice#colorCount&quot;&gt;colorCount&lt;/a&gt;().</source>
          <target state="translated">페인트 장치에 사용할 수있는 다양한 색상 수입니다. &lt;a href=&quot;qpaintdevice#colorCount&quot;&gt;colorCount&lt;/a&gt; () 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="71e8d85d7c0fc98bf5fa9a5d8215984ccacfba28" translate="yes" xml:space="preserve">
          <source>The number of elements in the model can be obtained from its &lt;a href=&quot;qml-qtqml-models-listmodel#count-prop&quot;&gt;count&lt;/a&gt; property. A number of familiar methods are also provided to manipulate the contents of the model, including &lt;a href=&quot;qml-qtqml-models-listmodel#append-method&quot;&gt;append()&lt;/a&gt;, &lt;a href=&quot;qml-qtqml-models-listmodel#insert-method&quot;&gt;insert()&lt;/a&gt;, &lt;a href=&quot;qml-qtqml-models-listmodel#move-method&quot;&gt;move()&lt;/a&gt;, &lt;a href=&quot;qml-qtqml-models-listmodel#remove-method&quot;&gt;remove()&lt;/a&gt; and &lt;a href=&quot;qml-qtqml-models-listmodel#set-method&quot;&gt;set()&lt;/a&gt;. These methods accept dictionaries as their arguments; these are translated to &lt;a href=&quot;qml-qtqml-models-listelement&quot;&gt;ListElement&lt;/a&gt; objects by the model.</source>
          <target state="translated">모델의 요소 수는 &lt;a href=&quot;qml-qtqml-models-listmodel#count-prop&quot;&gt;count&lt;/a&gt; 속성 에서 얻을 수 있습니다. &lt;a href=&quot;qml-qtqml-models-listmodel#append-method&quot;&gt;append ()&lt;/a&gt; , &lt;a href=&quot;qml-qtqml-models-listmodel#insert-method&quot;&gt;insert ()&lt;/a&gt; , &lt;a href=&quot;qml-qtqml-models-listmodel#move-method&quot;&gt;move ()&lt;/a&gt; , &lt;a href=&quot;qml-qtqml-models-listmodel#remove-method&quot;&gt;remove ()&lt;/a&gt; 및 &lt;a href=&quot;qml-qtqml-models-listmodel#set-method&quot;&gt;set ()을&lt;/a&gt; 포함하여 모델의 내용을 조작하는 여러 가지 친숙한 방법도 제공됩니다 . 이 방법들은 사전을 인수로 받아들입니다. 이들은 모델에 의해 &lt;a href=&quot;qml-qtqml-models-listelement&quot;&gt;ListElement&lt;/a&gt; 객체로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="d713739e716ad1e21aefe0c120f013a9ebd34808" translate="yes" xml:space="preserve">
          <source>The number of frames per second is 0 if the current document is not animated.</source>
          <target state="translated">현재 문서에 애니메이션이 적용되지 않은 경우 초당 프레임 수는 0입니다.</target>
        </trans-unit>
        <trans-unit id="0450b49d5355e3104eafb20c359fcc410c02d66d" translate="yes" xml:space="preserve">
          <source>The number of frames prepared without blocking in range 1 - 4. The default value is 2. Present() starts blocking after queuing 3 frames (regardless of &lt;code&gt;QT_D3D_BUFFER_COUNT&lt;/code&gt;), unless the waitable object is in use. Every additional frame increases GPU resource usage since geometry and constant buffer data needs to be duplicated, and involves more bookkeeping on the CPU side.</source>
          <target state="translated">1-4 범위에서 차단하지 않고 준비된 프레임 수입니다. 기본값은 2입니다. Present ()는 대기 가능한 객체를 사용하지 않는 한 &lt;code&gt;QT_D3D_BUFFER_COUNT&lt;/code&gt; 에 관계없이 3 개의 프레임을 큐잉 한 후 차단을 시작 합니다. 지오메트리 및 상수 버퍼 데이터를 복제해야하고 CPU 측에 더 많은 부기를 포함하기 때문에 모든 추가 프레임은 GPU 리소스 사용량을 증가시킵니다.</target>
        </trans-unit>
        <trans-unit id="639cca155f18d916d8a83f081a6ae45dd473083e" translate="yes" xml:space="preserve">
          <source>The number of items created by a Repeater is held by its &lt;a href=&quot;qml-qtquick-repeater#count-prop&quot;&gt;count&lt;/a&gt; property. It is not possible to set this property to determine the number of items to be created. Instead, as in the above example, we use an integer as the model.</source>
          <target state="translated">Repeater가 작성한 항목 수는 &lt;a href=&quot;qml-qtquick-repeater#count-prop&quot;&gt;count&lt;/a&gt; 특성에 의해 유지됩니다 . 작성할 항목 수를 판별하기 위해이 특성을 설정할 수 없습니다. 대신 위의 예와 같이 정수를 모델로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="8dfcb42e5b8fa35b579d4ee32dcbf4c8ccc8e9f8" translate="yes" xml:space="preserve">
          <source>The number of items currently pushed onto the stack.</source>
          <target state="translated">스택에 현재 푸시 된 항목 수입니다.</target>
        </trans-unit>
        <trans-unit id="d4022de6c3cb01a1831af34a9d8b2d6735044d85" translate="yes" xml:space="preserve">
          <source>The number of items in a list is given by &lt;a href=&quot;qtextlist#count&quot;&gt;count&lt;/a&gt;(). Each item can be obtained by its index in the list with the &lt;a href=&quot;qtextlist#item&quot;&gt;item&lt;/a&gt;() function. Similarly, the index of a given item can be found with &lt;a href=&quot;qtextlist#itemNumber&quot;&gt;itemNumber&lt;/a&gt;(). The text of each item can be found with the &lt;a href=&quot;qtextlist#itemText&quot;&gt;itemText&lt;/a&gt;() function.</source>
          <target state="translated">목록의 항목 수는 &lt;a href=&quot;qtextlist#count&quot;&gt;개수&lt;/a&gt; ()로 제공됩니다. 각 항목은 &lt;a href=&quot;qtextlist#item&quot;&gt;item&lt;/a&gt; () 함수 를 사용하여 목록의 색인으로 얻을 수 있습니다 . 마찬가지로, 주어진 항목의 색인은 &lt;a href=&quot;qtextlist#itemNumber&quot;&gt;itemNumber&lt;/a&gt; () 로 찾을 수 있습니다 . 각 항목의 텍스트는 &lt;a href=&quot;qtextlist#itemText&quot;&gt;itemText&lt;/a&gt; () 함수 로 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3b0ec35c37c9bedffdb792ad75088830399024d2" translate="yes" xml:space="preserve">
          <source>The number of items in the array.</source>
          <target state="translated">배열의 항목 수입니다.</target>
        </trans-unit>
        <trans-unit id="092cefcce73e0324a4ecca8231916e0190c8849a" translate="yes" xml:space="preserve">
          <source>The number of items in the model. This property is readonly.</source>
          <target state="translated">모델의 항목 수입니다. 이 속성은 읽기 전용입니다.</target>
        </trans-unit>
        <trans-unit id="d9ecc7e5254249e6fe305dd9957632c197d91737" translate="yes" xml:space="preserve">
          <source>The number of matches found.</source>
          <target state="translated">찾은 일치 수입니다.</target>
        </trans-unit>
        <trans-unit id="3d1c8f5d364d44038430ab57ec1dc17d8c069a69" translate="yes" xml:space="preserve">
          <source>The number of milliseconds to wait before opening a submenu (256 on Windows, 96 on Motif).</source>
          <target state="translated">하위 메뉴를 열기 전에 대기 할 시간 (밀리 초)입니다 (Windows의 경우 256, Motif의 경우 96).</target>
        </trans-unit>
        <trans-unit id="554d6ef9863a27e419d400ed7f76158bfa73f9f9" translate="yes" xml:space="preserve">
          <source>The number of milliseconds to wait before opening a submenu.</source>
          <target state="translated">하위 메뉴를 열기 전에 대기 할 시간 (밀리 초)입니다.</target>
        </trans-unit>
        <trans-unit id="1112f97c71c22d8337408ea4cf7182d5538c000e" translate="yes" xml:space="preserve">
          <source>The number of minor tick marks on the axis. This indicates how many grid lines are drawn between major ticks on the chart. Labels are not drawn for minor ticks. The default value is 0.</source>
          <target state="translated">축의 작은 눈금 표시 수입니다. 차트의 주요 눈금 사이에 몇 개의 눈금 선이 그려 졌는지를 나타냅니다. 작은 눈금에는 레이블이 그려지지 않습니다. 기본값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="19b4d35c613ce31fea917373cc3c9af1ce57887f" translate="yes" xml:space="preserve">
          <source>The number of minor tick marks on the axis. This indicates how many grid lines are drawn between major ticks on the chart. Labels are not drawn for minor ticks. The default value is 0. Set the value to -1 and the number of grid lines between major ticks will be calculated automatically.</source>
          <target state="translated">축의 작은 눈금 표시 수입니다. 차트의 주요 눈금 사이에 몇 개의 눈금 선이 그려 졌는지를 나타냅니다. 작은 눈금에는 레이블이 그려지지 않습니다. 기본값은 0입니다. 값을 -1로 설정하면 주요 눈금 사이의 그리드 선 수가 자동으로 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="ad784c55393b36ab6130bc69b11c4d382077c1e8" translate="yes" xml:space="preserve">
          <source>The number of objects and bindings in the delegate has a direct effect on the flicking performance of the view when &lt;a href=&quot;qml-qtquick-pathview#pathItemCount-prop&quot;&gt;pathItemCount&lt;/a&gt; is specified. If at all possible, place functionality that is not needed for the normal display of the delegate in a &lt;a href=&quot;qml-qtquick-loader&quot;&gt;Loader&lt;/a&gt; which can load additional components when needed.</source>
          <target state="translated">대리자의 개체 및 바인딩 수는 &lt;a href=&quot;qml-qtquick-pathview#pathItemCount-prop&quot;&gt;pathItemCount&lt;/a&gt; 가 지정된 경우보기의 깜박임 성능에 직접적인 영향을 미칩니다 . 가능한 경우 &lt;a href=&quot;qml-qtquick-loader&quot;&gt;로더에&lt;/a&gt; 델리게이트를 정상적으로 표시하는 데 필요하지 않은 기능을 필요한 경우 추가 구성 요소를로드 할 수 있는 로더에 배치하십시오.</target>
        </trans-unit>
        <trans-unit id="d35ab879dd0fc090c9fa1969d326da7fc6781555" translate="yes" xml:space="preserve">
          <source>The number of objects and bindings in the delegate has a direct effect on the flicking performance of the view. If at all possible, place functionality that is not needed for the normal display of the delegate in a &lt;a href=&quot;qml-qtquick-loader&quot;&gt;Loader&lt;/a&gt; which can load additional components when needed.</source>
          <target state="translated">델리게이트의 객체 및 바인딩 수는 뷰의 깜박임 성능에 직접적인 영향을 미칩니다. 가능한 경우 &lt;a href=&quot;qml-qtquick-loader&quot;&gt;로더에&lt;/a&gt; 델리게이트를 정상적으로 표시하는 데 필요하지 않은 기능을 필요한 경우 추가 구성 요소를로드 할 수 있는 로더에 배치하십시오.</target>
        </trans-unit>
        <trans-unit id="a6d78243d246f165b37b9b3d714b1d26e5b07a4c" translate="yes" xml:space="preserve">
          <source>The number of objects the Instantiator is currently managing.</source>
          <target state="translated">Instantiator가 현재 관리하고있는 개체 수입니다.</target>
        </trans-unit>
        <trans-unit id="7d0e7d6e5a68615009a45ed2865fad3f64da1aa8" translate="yes" xml:space="preserve">
          <source>The number of physical pixels per millimeter.</source>
          <target state="translated">밀리미터 당 실제 픽셀 수입니다.</target>
        </trans-unit>
        <trans-unit id="a58414bd22062ad73cef816bb23073db7f7af61b" translate="yes" xml:space="preserve">
          <source>The number of pixels between notches.</source>
          <target state="translated">노치 사이의 픽셀 수입니다.</target>
        </trans-unit>
        <trans-unit id="979f13e43d50059f96a7f0ec27f8b71d06fb4886" translate="yes" xml:space="preserve">
          <source>The number of rows in the array.</source>
          <target state="translated">배열의 행 수입니다.</target>
        </trans-unit>
        <trans-unit id="e6a2eb65a4be0164e209ea432f686910e2b9a9b3" translate="yes" xml:space="preserve">
          <source>The number of rows in the data array.</source>
          <target state="translated">데이터 배열의 행 수입니다.</target>
        </trans-unit>
        <trans-unit id="83b0be21c420d48be8d435df3193f2fd823436da" translate="yes" xml:space="preserve">
          <source>The number of rows in the table can be found with &lt;a href=&quot;qtablewidget#rowCount&quot;&gt;rowCount&lt;/a&gt;(), and the number of columns with &lt;a href=&quot;qtablewidget#columnCount&quot;&gt;columnCount&lt;/a&gt;(). The table can be cleared with the &lt;a href=&quot;qtablewidget#clear&quot;&gt;clear&lt;/a&gt;() function.</source>
          <target state="translated">테이블의 행 수는 &lt;a href=&quot;qtablewidget#rowCount&quot;&gt;rowCount&lt;/a&gt; ()로, 열 수는 &lt;a href=&quot;qtablewidget#columnCount&quot;&gt;columnCount&lt;/a&gt; () 로 찾을 수 있습니다 . &lt;a href=&quot;qtablewidget#clear&quot;&gt;clear&lt;/a&gt; () 함수를 사용하여 테이블을 지울 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7ba8cc0fdcf4b62f67bc9986111e4e5e6dc9285a" translate="yes" xml:space="preserve">
          <source>The number of rows of the model that are mapped as the data for a pie series. The default value is -1 (number limited by the number of rows in the model).</source>
          <target state="translated">파이 계열의 데이터로 매핑 된 모델의 행 수입니다. 기본값은 -1입니다 (숫자는 모델의 행 수로 제한됨).</target>
        </trans-unit>
        <trans-unit id="22890f980bc3bc92a0259a76aefffb041b570053" translate="yes" xml:space="preserve">
          <source>The number of rows of the model that are mapped as the data for series. The default value is -1 (the number is limited by the number of rows in the model).</source>
          <target state="translated">계열의 데이터로 매핑 된 모델의 행 수입니다. 기본값은 -1입니다 (숫자는 모델의 행 수에 의해 제한됨).</target>
        </trans-unit>
        <trans-unit id="8e8aa3777340acbfba96473f34679e60dae3da59" translate="yes" xml:space="preserve">
          <source>The number of rows of the model that are mapped as the data for the bar series. The default value is -1 (number limited to the number of rows in the model).</source>
          <target state="translated">막대 계열의 데이터로 맵핑 된 모델의 행 수입니다. 기본값은 -1입니다 (숫자는 모델의 행 수로 제한됨).</target>
        </trans-unit>
        <trans-unit id="c3f0e4116acc040e7b5a1a5ec8f58b73009a9de2" translate="yes" xml:space="preserve">
          <source>The number of rows of the model that are mapped as the data for the box plot series.</source>
          <target state="translated">상자 그림 시리즈의 데이터로 매핑 된 모델의 행 수입니다.</target>
        </trans-unit>
        <trans-unit id="492b4be784ab19898e7d0e822492dddc55e09e16" translate="yes" xml:space="preserve">
          <source>The number of samples used in multisample antialiasing when &lt;a href=&quot;qml-qtdatavisualization-abstractgraph3d#renderingMode-prop&quot;&gt;renderingMode&lt;/a&gt; is &lt;code&gt;RenderIndirect&lt;/code&gt;. When &lt;a href=&quot;qml-qtdatavisualization-abstractgraph3d#renderingMode-prop&quot;&gt;renderingMode&lt;/a&gt; is &lt;code&gt;RenderDirectToBackground&lt;/code&gt; or &lt;code&gt;RenderDirectToBackground_NoClear&lt;/code&gt;, this property value is read-only and returns the number of samples specified by the window surface format. Defaults to &lt;code&gt;4&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;qml-qtdatavisualization-abstractgraph3d#renderingMode-prop&quot;&gt;renderingMode&lt;/a&gt; 가 &lt;code&gt;RenderIndirect&lt;/code&gt; 일 때 멀티 샘플 앤티 앨리어싱에 사용되는 샘플 수입니다 . 때 &lt;a href=&quot;qml-qtdatavisualization-abstractgraph3d#renderingMode-prop&quot;&gt;의 renderingMode가&lt;/a&gt; 있다 &lt;code&gt;RenderDirectToBackground&lt;/code&gt; 또는 &lt;code&gt;RenderDirectToBackground_NoClear&lt;/code&gt; ,이 속성 값은 읽기 전용 창 표면 형식에 의해 지정된 샘플의 수를 반환합니다. 기본값은 &lt;code&gt;4&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="431a4f8d0fafb285d04af42d7255e24445085489" translate="yes" xml:space="preserve">
          <source>The number of segments on the axis. This indicates how many labels are drawn. The number of grid lines to be drawn is calculated with the following formula: &lt;code&gt;segments * subsegments + 1&lt;/code&gt;. The preset default is &lt;code&gt;5&lt;/code&gt;. The value cannot be below &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">축의 세그먼트 수입니다. 이것은 얼마나 많은 레이블이 그려 졌는지를 나타냅니다. 그릴 그리드 선 수는 다음 공식으로 계산됩니다 : &lt;code&gt;segments * subsegments + 1&lt;/code&gt; . 사전 설정 기본값은 &lt;code&gt;5&lt;/code&gt; 입니다. 값은 &lt;code&gt;1&lt;/code&gt; 미만일 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="a1d1b45f7abe9b3c448201786cba8e5c83851ecd" translate="yes" xml:space="preserve">
          <source>The number of series added to the chart.</source>
          <target state="translated">차트에 추가 된 계열 수입니다.</target>
        </trans-unit>
        <trans-unit id="8e7ae4053c38fe01536587e40714cbcefc47257b" translate="yes" xml:space="preserve">
          <source>The number of slices in the series.</source>
          <target state="translated">시리즈의 슬라이스 수입니다.</target>
        </trans-unit>
        <trans-unit id="f6d9ccda80ae83ae7eb133cd4778c84b8f55c42f" translate="yes" xml:space="preserve">
          <source>The number of subsegments inside each segment on the axis. Grid lines are drawn between each subsegment, in addition to each segment. The preset default is &lt;code&gt;1&lt;/code&gt;. The value cannot be below &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">축의 각 세그먼트 내 하위 세그먼트 수입니다. 각 세그먼트 외에 각 하위 세그먼트 사이에 그리드 선이 그려집니다. 사전 설정 기본값은 &lt;code&gt;1&lt;/code&gt; 입니다. 값은 &lt;code&gt;1&lt;/code&gt; 미만일 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="2ff514ba82af94bbf5563e4f55bf4273b96ccf63" translate="yes" xml:space="preserve">
          <source>The number of swap chain buffers in range 2 - 4. The default value is 3.</source>
          <target state="translated">범위 2-4의 스왑 체인 버퍼 수 기본값은 3입니다.</target>
        </trans-unit>
        <trans-unit id="f27dd98426f7a08fa1b5f305fd46844127d4d710" translate="yes" xml:space="preserve">
          <source>The number of taps which have occurred within the time and space constraints to be considered a single gesture. For example, to detect a triple-tap, you can write:</source>
          <target state="translated">시간 및 공간 제한 내에서 발생한 탭 수는 단일 동작으로 간주됩니다. 예를 들어 트리플 탭을 감지하려면 다음과 같이 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b76127adbbf3e9cc455f122c2c698985609941f7" translate="yes" xml:space="preserve">
          <source>The number of the day</source>
          <target state="translated">일수</target>
        </trans-unit>
        <trans-unit id="8ff0be4f2d9794921821de17f01d21a87bf48f37" translate="yes" xml:space="preserve">
          <source>The number of the month</source>
          <target state="translated">월수</target>
        </trans-unit>
        <trans-unit id="b62517ec87d67a01a3e238738d057198e0aec6a4" translate="yes" xml:space="preserve">
          <source>The number of the week this delegate represents.</source>
          <target state="translated">이 대리인이 나타내는 주 수입니다.</target>
        </trans-unit>
        <trans-unit id="bafda84d524d8489a20ac2b57c9fbf2818cb88ce" translate="yes" xml:space="preserve">
          <source>The number of the year</source>
          <target state="translated">연도의 수</target>
        </trans-unit>
        <trans-unit id="aaeec13b0090e734bf3d565b093e88b0ec57bc50" translate="yes" xml:space="preserve">
          <source>The number of tick marks on the axis.</source>
          <target state="translated">축의 눈금 수입니다.</target>
        </trans-unit>
        <trans-unit id="c562891120ad536aa3bf840cd6a1e859dc0b3acc" translate="yes" xml:space="preserve">
          <source>The number of tick marks on the axis. This indicates how many grid lines are drawn on the chart. The default value is 5, and the number cannot be less than 2.</source>
          <target state="translated">축의 눈금 수입니다. 차트에 몇 개의 눈금 선이 그려져 있는지 나타냅니다. 기본값은 5이며 숫자는 2보다 작을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="4e0f371c3be6e053377ad371db3f0451639b63e8" translate="yes" xml:space="preserve">
          <source>The number of tick marks on the axis. This indicates how many grid lines are drawn on the chart. This value is read-only.</source>
          <target state="translated">축의 눈금 수입니다. 차트에 몇 개의 눈금 선이 그려져 있는지 나타냅니다. 이 값은 읽기 전용입니다.</target>
        </trans-unit>
        <trans-unit id="4f7b73df18263747b2134c682a804ddfde26e5a1" translate="yes" xml:space="preserve">
          <source>The number of tracks on the album containing the media.</source>
          <target state="translated">미디어가 포함 된 앨범의 트랙 수입니다.</target>
        </trans-unit>
        <trans-unit id="d7e9a40e1048ee1b89ae1545dcd5ceb5e654e746" translate="yes" xml:space="preserve">
          <source>The number of values in the bar set.</source>
          <target state="translated">막대 세트의 값 수입니다.</target>
        </trans-unit>
        <trans-unit id="a7e450e8ee331a4452d07c56caf922bd1715bb29" translate="yes" xml:space="preserve">
          <source>The number of values of the box-and-whiskers item.</source>
          <target state="translated">상자 및 수염 항목의 값 수입니다.</target>
        </trans-unit>
        <trans-unit id="e2a792101225a903928b7c268e69feb35adb0b4f" translate="yes" xml:space="preserve">
          <source>The numbers of &lt;a href=&quot;qsignalblocker#reblock&quot;&gt;reblock&lt;/a&gt;() and unblock() calls are not counted, so every unblock() undoes any number of &lt;a href=&quot;qsignalblocker#reblock&quot;&gt;reblock&lt;/a&gt;() calls.</source>
          <target state="translated">의 숫자 &lt;a href=&quot;qsignalblocker#reblock&quot;&gt;reblock&lt;/a&gt; ) (모든 차단 해제는 임의의 수의 실행 취소 있도록 () 및 차단 해제는 () 호출은 계산되지 않습니다 &lt;a href=&quot;qsignalblocker#reblock&quot;&gt;reblock를&lt;/a&gt; ()를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="1650fb5feef46643155e9035e23ad6cd562d7f76" translate="yes" xml:space="preserve">
          <source>The numbers of reblock() and &lt;a href=&quot;qsignalblocker#unblock&quot;&gt;unblock&lt;/a&gt;() calls are not counted, so every reblock() undoes any number of &lt;a href=&quot;qsignalblocker#unblock&quot;&gt;unblock&lt;/a&gt;() calls.</source>
          <target state="translated">reblock () 및 &lt;a href=&quot;qsignalblocker#unblock&quot;&gt;unblock&lt;/a&gt; () 호출 수는 계산되지 않으므로 모든 reblock ()은 임의의 수의 &lt;a href=&quot;qsignalblocker#unblock&quot;&gt;unblock&lt;/a&gt; () 호출을 취소 합니다.</target>
        </trans-unit>
        <trans-unit id="8d154d28cce241422d3b0306031f45ded38a66d5" translate="yes" xml:space="preserve">
          <source>The object allocate space for</source>
          <target state="translated">객체는 공간을 할당합니다</target>
        </trans-unit>
        <trans-unit id="08b12fe7677bd7a1cd61075f9cd376ecf32c47c5" translate="yes" xml:space="preserve">
          <source>The object also has one signal, aboutToQuit(), which is the same as &lt;a href=&quot;qcoreapplication#aboutToQuit&quot;&gt;QCoreApplication::aboutToQuit()&lt;/a&gt;.</source>
          <target state="translated">이 객체에는 aboutToQuit () 신호도 있는데 이는 &lt;a href=&quot;qcoreapplication#aboutToQuit&quot;&gt;QCoreApplication :: aboutToQuit ()&lt;/a&gt; 과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="f60341fd0842c1f035c24a1d38b7be9897966d93" translate="yes" xml:space="preserve">
          <source>The object blocks input from other objects.</source>
          <target state="translated">객체는 다른 객체의 입력을 차단합니다.</target>
        </trans-unit>
        <trans-unit id="4881199919720b970441bd3f11390bc4c8e5f423" translate="yes" xml:space="preserve">
          <source>The object can be moved.</source>
          <target state="translated">개체를 이동할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c914d58256abb5135c2101e70cc5a32b34c576f9" translate="yes" xml:space="preserve">
          <source>The object can be resized, e.g. top-level windows.</source>
          <target state="translated">최상위 창과 같은 개체의 크기를 조정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6adcb24c5f3d433b7d462254a271f3c0fde9d690" translate="yes" xml:space="preserve">
          <source>The object can handle data and files of the format specified in the value. The value has the format mime:extension:description. Multiple formats are separated by a semicolon.</source>
          <target state="translated">오브젝트는 값에 지정된 형식의 데이터 및 파일을 처리 할 수 ​​있습니다. 값은 mime : extension : description 형식입니다. 여러 형식은 세미콜론으로 구분됩니다.</target>
        </trans-unit>
        <trans-unit id="77fa9d5682507f1eeed3a50fcd85c458366cbbfd" translate="yes" xml:space="preserve">
          <source>The object can receive focus. Only objects in the active window can receive focus.</source>
          <target state="translated">초점을 맞출 수 있습니다. 활성 창의 개체 만 포커스를받을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4fc8b7ab14886cd1928f59c171dcbce8a624eff0" translate="yes" xml:space="preserve">
          <source>The object can usually be edited, but is explicitly set to read-only.</source>
          <target state="translated">일반적으로 개체를 편집 할 수 있지만 명시 적으로 읽기 전용으로 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="bdd1687cbdef9a6c6804461437e4cb943a47cb3e" translate="yes" xml:space="preserve">
          <source>The object cannot accept input at the moment.</source>
          <target state="translated">현재 개체가 입력을 받아 들일 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="0b397cfe20aabda8c737c01e402b8e116110ff28" translate="yes" xml:space="preserve">
          <source>The object changes frequently and needs to be refreshed when accessing it.</source>
          <target state="translated">개체는 자주 변경되므로 액세스 할 때 새로 고쳐야합니다.</target>
        </trans-unit>
        <trans-unit id="9833b90f07361b082a3174240aca12c113c7c23b" translate="yes" xml:space="preserve">
          <source>The object containing the menu item subcontrol components. These subcontrols are used for normal menu items only, i.e. not for separators or scroll indicators.</source>
          <target state="translated">메뉴 항목 하위 제어 구성 요소를 포함하는 오브젝트입니다. 이 하위 컨트롤은 일반 메뉴 항목에만 사용됩니다 (예 : 구분 기호 또는 스크롤 표시기는 사용하지 않음).</target>
        </trans-unit>
        <trans-unit id="e4362b0cf3fa4b1ae599a860a4e5d467193dc0ef" translate="yes" xml:space="preserve">
          <source>The object declaration in a QML document defines what will be displayed in the visual scene. &lt;a href=&quot;qtquick-index&quot;&gt;Qt Quick&lt;/a&gt; provides the basic building blocks for all user interfaces, such as the objects for displaying images and text and for handling user input.</source>
          <target state="translated">QML 문서의 객체 선언은 시각적 장면에 표시 될 내용을 정의합니다. &lt;a href=&quot;qtquick-index&quot;&gt;Qt Quick&lt;/a&gt; 은 이미지와 텍스트를 표시하고 사용자 입력을 처리하기위한 개체와 같은 모든 사용자 인터페이스를위한 기본 구성 요소를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="92b65e2ef6a06967fb42d70d396607c9917f5aec" translate="yes" xml:space="preserve">
          <source>The object describes itself through speech or sound.</source>
          <target state="translated">물체는 말이나 소리를 통해 자신을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="8a0cf8e6ce2754b6cca7332889c1e1c0f1b46777" translate="yes" xml:space="preserve">
          <source>The object displays scrolling contents, e.g. a log view.</source>
          <target state="translated">객체는 스크롤 내용 (예 : 로그보기)을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="ed5ed55f364b7c96af22bd4a5ca1ea2dd641016d" translate="yes" xml:space="preserve">
          <source>The object displays the progress of an operation in progress.</source>
          <target state="translated">객체는 진행중인 작업의 진행률을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="73b28ec2f16a4137b8c48eb24d8532f000c37f2d" translate="yes" xml:space="preserve">
          <source>The object formats a frame</source>
          <target state="translated">객체는 프레임을 포맷</target>
        </trans-unit>
        <trans-unit id="67781750f82a34bbf14e2a8dfe0921fef222710d" translate="yes" xml:space="preserve">
          <source>The object formats a list</source>
          <target state="translated">객체는 목록의 형식을 지정합니다</target>
        </trans-unit>
        <trans-unit id="5cbc64c12f12a77981a1a1a9056d3ac740dc3ae9" translate="yes" xml:space="preserve">
          <source>The object formats a single character</source>
          <target state="translated">객체는 단일 문자를 포맷</target>
        </trans-unit>
        <trans-unit id="e7953cf59993ac70dfe0b75fb18385f5a29ca57e" translate="yes" xml:space="preserve">
          <source>The object formats a text block</source>
          <target state="translated">객체는 텍스트 블록을 포맷</target>
        </trans-unit>
        <trans-unit id="0be1b58914c49d6a80ed9a2fbf6aadfe6cba2d86" translate="yes" xml:space="preserve">
          <source>The object has a text carret (and often implements the text interface).</source>
          <target state="translated">객체에는 텍스트 캐럿이 있으며 텍스트 인터페이스를 구현하는 경우가 많습니다.</target>
        </trans-unit>
        <trans-unit id="cb41a94ce183825fabfad03c26725e21410e1b45" translate="yes" xml:space="preserve">
          <source>The object has auto-completion, for example in line edits or combo boxes.</source>
          <target state="translated">개체에 자동 편집 기능이 있습니다 (예 : 줄 편집 또는 콤보 상자).</target>
        </trans-unit>
        <trans-unit id="7e2638e25adb7a3df106ef54ab03bfd07d498c77" translate="yes" xml:space="preserve">
          <source>The object has keyboard focus.</source>
          <target state="translated">객체에 키보드 포커스가 있습니다.</target>
        </trans-unit>
        <trans-unit id="f95fe8ecdf57f9f04226c5d081d4b8ada5a6ca77" translate="yes" xml:space="preserve">
          <source>The object has multiple lines of text (word wrap), as opposed to a single line.</source>
          <target state="translated">개체에는 한 줄이 아니라 여러 줄의 텍스트 (단어 줄 바꿈)가 있습니다.</target>
        </trans-unit>
        <trans-unit id="2eec1d4b383cb61e23eb5d5bd7dd2c6750457d30" translate="yes" xml:space="preserve">
          <source>The object has no role. This usually indicates an invalid object.</source>
          <target state="translated">개체는 역할이 없습니다. 일반적으로 유효하지 않은 개체를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="3f2277f8930041609314b3af9c20ffd928c860ed" translate="yes" xml:space="preserve">
          <source>The object has text which can be selected. This is different from selectable which refers to the object's children.</source>
          <target state="translated">개체에는 선택할 수있는 텍스트가 있습니다. 이것은 객체의 자식을 나타내는 선택 가능과 다릅니다.</target>
        </trans-unit>
        <trans-unit id="3ff196c140e0459d370a8f8b78c9d2a9cdf61c82" translate="yes" xml:space="preserve">
          <source>The object hierarchy is created, and constant values are assigned.</source>
          <target state="translated">객체 계층이 생성되고 상수 값이 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="8702044014de53e76ecc40149e9fb20f198ac40c" translate="yes" xml:space="preserve">
          <source>The object is a line edit that is the input for search queries.</source>
          <target state="translated">개체는 검색 쿼리에 대한 입력 인 줄 편집입니다.</target>
        </trans-unit>
        <trans-unit id="1e43afcb12e42ee4dd495a2e950b8d94e0d59528" translate="yes" xml:space="preserve">
          <source>The object is a password field, e.g. a line edit for entering a Password.</source>
          <target state="translated">객체는 비밀번호 필드입니다 (예 : 비밀번호 입력을위한 행 편집).</target>
        </trans-unit>
        <trans-unit id="334ce3a152fe10e5917713e50459b63558ef779c" translate="yes" xml:space="preserve">
          <source>The object is checkable.</source>
          <target state="translated">개체를 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="72da1947e21f5e916d924e32c8e3490db8f73cbc" translate="yes" xml:space="preserve">
          <source>The object is clipped by the visible area. Objects that are off screen are also invisible.</source>
          <target state="translated">보이는 영역에 의해 개체가 잘립니다. 화면 밖에있는 개체도 보이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8a315f865b8947718ee97d27d6c5418907bdfb71" translate="yes" xml:space="preserve">
          <source>The object is collapsed, e.g. a closed listview item, or an iconified window.</source>
          <target state="translated">닫힌 목록보기 항목 또는 아이콘 화 된 창과 같이 개체가 축소됩니다.</target>
        </trans-unit>
        <trans-unit id="4e17fb98e50677547cca9ce81d49950fd1d9bfde" translate="yes" xml:space="preserve">
          <source>The object is converted to a &lt;a href=&quot;qvariant#QVariantMap-typedef&quot;&gt;QVariantMap&lt;/a&gt;. Each property is converted to a &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt;, recursively; cyclic references are not followed.</source>
          <target state="translated">오브젝트가 &lt;a href=&quot;qvariant#QVariantMap-typedef&quot;&gt;QVariantMap&lt;/a&gt; 로 변환됩니다 . 각 속성은 &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; 로 재귀 적으로 변환됩니다 . 순환 참조는 따르지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6732797a6aacd1c20a9b5e1e680ba505beb43b58" translate="yes" xml:space="preserve">
          <source>The object is expandable, mostly used for cells in a tree view.</source>
          <target state="translated">개체는 확장 가능하며 주로 트리 뷰의 셀에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8f7e44f386163e5ae47dea9500052c82ea00fd28" translate="yes" xml:space="preserve">
          <source>The object is expanded, currently its children are visible.</source>
          <target state="translated">개체가 확장되어 현재 자식이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="7ed4c0740a1146f99fb42b57cde0a6afd7554ea9" translate="yes" xml:space="preserve">
          <source>The object is fully created and can be accessed by calling &lt;a href=&quot;qqmlincubator#object&quot;&gt;object&lt;/a&gt;().</source>
          <target state="translated">객체는 완전히 생성되며 &lt;a href=&quot;qqmlincubator#object&quot;&gt;object&lt;/a&gt; () 를 호출하여 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="72996d39ead105fcc0556570ad7a0a37c9222ed5" translate="yes" xml:space="preserve">
          <source>The object is in the process of being created.</source>
          <target state="translated">개체를 만드는 중입니다.</target>
        </trans-unit>
        <trans-unit id="5632603ecdcfa000659ee8b38cb3cc97d0d1eba3" translate="yes" xml:space="preserve">
          <source>The object is linked and has been visited.</source>
          <target state="translated">개체가 연결되어 방문했습니다.</target>
        </trans-unit>
        <trans-unit id="d7514ecb67352280f9223439a4419fdac0b3953b" translate="yes" xml:space="preserve">
          <source>The object is linked to another object, e.g. a hyperlink.</source>
          <target state="translated">객체는 다른 객체, 예를 들어 하이퍼 링크에 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="a4822af6c160c99dc50d8f071afe338919843b33" translate="yes" xml:space="preserve">
          <source>The object is moved to another thread. This is the last event sent to this object in the previous thread. See &lt;a href=&quot;qobject#moveToThread&quot;&gt;QObject::moveToThread&lt;/a&gt;().</source>
          <target state="translated">개체가 다른 스레드로 이동되었습니다. 이전 스레드에서이 객체로 전송 된 마지막 이벤트입니다. &lt;a href=&quot;qobject#moveToThread&quot;&gt;QObject :: moveToThread&lt;/a&gt; ()를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="69567fa0b9a96c21de070fe7b7d849b7f552b63c" translate="yes" xml:space="preserve">
          <source>The object is no longer valid (because it has been deleted).</source>
          <target state="translated">개체가 삭제되었으므로 더 이상 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b0f9ac0c0ac59d5931c4b8aa5f6b2c44e89c52bf" translate="yes" xml:space="preserve">
          <source>The object is not visible to the user.</source>
          <target state="translated">개체가 사용자에게 보이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="24a53f55bd98da338964e9775e3b25b72c9f9c34" translate="yes" xml:space="preserve">
          <source>The object is owned by C++ code and QML will never delete it. The JavaScript destroy() method cannot be used on these objects. This option is similar to &lt;a href=&quot;https://doc.qt.io/qt-5.13/qscriptengine.html#ValueOwnership-enum&quot;&gt;QScriptEngine::QtOwnership&lt;/a&gt;.</source>
          <target state="translated">오브젝트는 C ++ 코드가 소유하며 QML은이를 삭제하지 않습니다. 이러한 객체에는 JavaScript destroy () 메서드를 사용할 수 없습니다. 이 옵션은 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qscriptengine.html#ValueOwnership-enum&quot;&gt;QScriptEngine :: QtOwnership&lt;/a&gt; 과 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="ad1cd314a97a51cac3a244953b7398c3c9cd9a09" translate="yes" xml:space="preserve">
          <source>The object is owned by C++ code and QML will never delete it. The JavaScript destroy() method cannot be used on these objects. This option is similar to &lt;a href=&quot;https://doc.qt.io/qt-5.15/qscriptengine.html#ValueOwnership-enum&quot;&gt;QScriptEngine::QtOwnership&lt;/a&gt;.</source>
          <target state="translated">객체는 C ++ 코드가 소유하며 QML은 절대 삭제하지 않습니다. 이러한 객체에는 JavaScript destroy () 메서드를 사용할 수 없습니다. 이 옵션은 &lt;a href=&quot;https://doc.qt.io/qt-5.15/qscriptengine.html#ValueOwnership-enum&quot;&gt;QScriptEngine :: QtOwnership&lt;/a&gt; 과 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="cc86fa6f3c9d1cb2047fdca3f8a6491e727bd009" translate="yes" xml:space="preserve">
          <source>The object is owned by JavaScript. When the object is returned to QML as the return value of a method call, QML will track it and delete it if there are no remaining JavaScript references to it and it has no &lt;a href=&quot;qobject#parent&quot;&gt;QObject::parent&lt;/a&gt;(). An object tracked by one &lt;a href=&quot;qqmlengine&quot;&gt;QQmlEngine&lt;/a&gt; will be deleted during that &lt;a href=&quot;qqmlengine&quot;&gt;QQmlEngine&lt;/a&gt;'s destructor. Thus, JavaScript references between objects with JavaScriptOwnership from two different engines will not be valid if one of these engines is deleted. This option is similar to &lt;a href=&quot;https://doc.qt.io/qt-5.13/qscriptengine.html#ValueOwnership-enum&quot;&gt;QScriptEngine::ScriptOwnership&lt;/a&gt;.</source>
          <target state="translated">객체는 JavaScript가 소유합니다. 메소드 호출의 리턴 값으로 오브젝트가 QML에 리턴 될 때, QML은 오브젝트에 대한 나머지 JavaScript 참조가없고 &lt;a href=&quot;qobject#parent&quot;&gt;QObject :: parent&lt;/a&gt; () 가없는 경우이를 추적하고 삭제합니다 . 하나의 &lt;a href=&quot;qqmlengine&quot;&gt;QQmlEngine에&lt;/a&gt; 의해 추적 된 오브젝트 는 해당 &lt;a href=&quot;qqmlengine&quot;&gt;QQmlEngine&lt;/a&gt; 의 소멸자 중에 삭제됩니다 . 따라서 두 엔진 중 하나에서 JavaScriptOwnership이있는 객체 간의 JavaScript 참조는 이러한 엔진 중 하나가 삭제되면 유효하지 않습니다. 이 옵션은 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qscriptengine.html#ValueOwnership-enum&quot;&gt;QScriptEngine :: ScriptOwnership&lt;/a&gt; 과 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="cc1169cceb42a0cc42d851d08493fb68c3d3dba1" translate="yes" xml:space="preserve">
          <source>The object is owned by JavaScript. When the object is returned to QML as the return value of a method call, QML will track it and delete it if there are no remaining JavaScript references to it and it has no &lt;a href=&quot;qobject#parent&quot;&gt;QObject::parent&lt;/a&gt;(). An object tracked by one &lt;a href=&quot;qqmlengine&quot;&gt;QQmlEngine&lt;/a&gt; will be deleted during that &lt;a href=&quot;qqmlengine&quot;&gt;QQmlEngine&lt;/a&gt;'s destructor. Thus, JavaScript references between objects with JavaScriptOwnership from two different engines will not be valid if one of these engines is deleted. This option is similar to &lt;a href=&quot;https://doc.qt.io/qt-5.15/qscriptengine.html#ValueOwnership-enum&quot;&gt;QScriptEngine::ScriptOwnership&lt;/a&gt;.</source>
          <target state="translated">객체는 JavaScript가 소유합니다. 객체가 메서드 호출의 반환 값으로 QML에 반환 될 때 QML은 객체에 대한 나머지 JavaScript 참조가없고 &lt;a href=&quot;qobject#parent&quot;&gt;QObject :: parent&lt;/a&gt; () 가없는 경우 객체를 추적하고 삭제합니다 . 하나의 &lt;a href=&quot;qqmlengine&quot;&gt;QQmlEngine에&lt;/a&gt; 의해 추적되는 객체 는 해당 &lt;a href=&quot;qqmlengine&quot;&gt;QQmlEngine&lt;/a&gt; 의 소멸자 동안 삭제됩니다 . 따라서 두 개의 다른 엔진에서 JavaScriptOwnership이있는 개체 간의 JavaScript 참조는 이러한 엔진 중 하나가 삭제되면 유효하지 않습니다. 이 옵션은 &lt;a href=&quot;https://doc.qt.io/qt-5.15/qscriptengine.html#ValueOwnership-enum&quot;&gt;QScriptEngine :: ScriptOwnership&lt;/a&gt; 과 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="517d5f86f04dfcc83d7f9a31b88457a05e4f0b3a" translate="yes" xml:space="preserve">
          <source>The object is passed in the</source>
          <target state="translated">객체는</target>
        </trans-unit>
        <trans-unit id="f2af81a26ffd90e96852cf549aa10b742228ff1b" translate="yes" xml:space="preserve">
          <source>The object is pressed.</source>
          <target state="translated">개체가 눌 렸습니다.</target>
        </trans-unit>
        <trans-unit id="7ee37cb4994912cc6906dd5531d2a8c45a650f6d" translate="yes" xml:space="preserve">
          <source>The object is selectable.</source>
          <target state="translated">객체를 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="74e485ec7757cde78c6ba032571df9501b8a567e" translate="yes" xml:space="preserve">
          <source>The object is selected, this is independent of text selection.</source>
          <target state="translated">객체가 선택되며 텍스트 선택과 무관합니다.</target>
        </trans-unit>
        <trans-unit id="3517c3ceafc7031d57dc8acc9e29d1e2d9d49b5e" translate="yes" xml:space="preserve">
          <source>The object is the active window or the active sub-element in a container (that would get focus when focusing the container).</source>
          <target state="translated">객체는 컨테이너의 활성 창 또는 활성 하위 요소입니다 (컨테이너에 초점을 맞출 때 포커스가 있음).</target>
        </trans-unit>
        <trans-unit id="e52abd9ab7c4a87972ed8c9454c3c24be38d6ee3" translate="yes" xml:space="preserve">
          <source>The object is unavailable to the user, e.g. a disabled widget.</source>
          <target state="translated">비활성화 된 위젯과 같이 사용자가 오브젝트를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="bb0f58686cf9c24bdcf8a9c65692f341c2c5e9bd" translate="yes" xml:space="preserve">
          <source>The object mesh set via the &lt;a href=&quot;qabstract3dseries#mesh-prop&quot;&gt;QAbstract3DSeries::mesh&lt;/a&gt; property defines the selection pointer shape in a surface series.</source>
          <target state="translated">&lt;a href=&quot;qabstract3dseries#mesh-prop&quot;&gt;QAbstract3DSeries :: mesh&lt;/a&gt; 속성을 통해 설정된 객체 메시 는 표면 시리즈에서 선택 포인터 모양을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="be2b7826cb0256c457f4458c7d6b49197bc293e3" translate="yes" xml:space="preserve">
          <source>The object needs to fill in its geometry information (&lt;a href=&quot;qscrollprepareevent&quot;&gt;QScrollPrepareEvent&lt;/a&gt;).</source>
          <target state="translated">오브젝트는 지오메트리 정보 ( &lt;a href=&quot;qscrollprepareevent&quot;&gt;QScrollPrepareEvent&lt;/a&gt; )를 채워야 합니다.</target>
        </trans-unit>
        <trans-unit id="2aa662de20cec92e87f61c5e558814589b56efcd" translate="yes" xml:space="preserve">
          <source>The object needs to scroll to the supplied position (&lt;a href=&quot;qscrollevent&quot;&gt;QScrollEvent&lt;/a&gt;).</source>
          <target state="translated">제공된 위치 ( &lt;a href=&quot;qscrollevent&quot;&gt;QScrollEvent&lt;/a&gt; )로 오브젝트를 스크롤해야합니다 .</target>
        </trans-unit>
        <trans-unit id="5291d6aff00731ce983a25b6ac3d06c8b05dacd6" translate="yes" xml:space="preserve">
          <source>The object no longer exists.</source>
          <target state="translated">개체가 더 이상 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="98e6a0e27062a5d1e8513f36e893eb90b7609560" translate="yes" xml:space="preserve">
          <source>The object opens a popup.</source>
          <target state="translated">객체가 팝업을 엽니 다.</target>
        </trans-unit>
        <trans-unit id="68b9e1dec1cbea4da9901191bd37acedb73018cf" translate="yes" xml:space="preserve">
          <source>The object passed must implement the &lt;a href=&quot;qmediabindableinterface&quot;&gt;QMediaBindableInterface&lt;/a&gt; interface.</source>
          <target state="translated">전달 된 오브젝트는 &lt;a href=&quot;qmediabindableinterface&quot;&gt;QMediaBindableInterface&lt;/a&gt; 인터페이스를 구현해야합니다 .</target>
        </trans-unit>
        <trans-unit id="2749ffb2b69f0b9f10c7f8e05006062aa03abf2c" translate="yes" xml:space="preserve">
          <source>The object path points to an object that does not exist (&lt;code&gt;org.freedesktop.DBus.Error.UnknownObject&lt;/code&gt;)</source>
          <target state="translated">오브젝트 경로가 존재하지 않는 오브젝트를 가리 킵니다 ( &lt;code&gt;org.freedesktop.DBus.Error.UnknownObject&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="f484b2f8a8fb570a81b872e78168771dd99c1371" translate="yes" xml:space="preserve">
          <source>The object path provided is invalid.</source>
          <target state="translated">제공된 개체 경로가 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8454e7b179f6d6dc298df097cf8318a8229a42f2" translate="yes" xml:space="preserve">
          <source>The object produces sound when interacted with.</source>
          <target state="translated">객체는 상호 작용할 때 소리를냅니다.</target>
        </trans-unit>
        <trans-unit id="519488efc9912d2311a452ad772d00b590248a70" translate="yes" xml:space="preserve">
          <source>The object represents an adjustable value, e.g. sliders.</source>
          <target state="translated">객체는 슬라이더와 같은 조정 가능한 값을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="68ff8eb427553aa50d311c3ce1d87cab5c801dd1" translate="yes" xml:space="preserve">
          <source>The object represents the default button in a dialog.</source>
          <target state="translated">객체는 대화 상자의 기본 버튼을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="553c776ec8a6f7eca809a003098ef0c082b21886" translate="yes" xml:space="preserve">
          <source>The object represents the desktop or workspace.</source>
          <target state="translated">객체는 데스크탑 또는 작업 공간을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="857c20993ab089ce311718bcbf9d9703e30830de" translate="yes" xml:space="preserve">
          <source>The object returned by this function is thread-safe and may be used in any thread without locks. It may also be copied and the resulting &lt;a href=&quot;qrandomgenerator&quot;&gt;QRandomGenerator&lt;/a&gt; will also access the operating system facilities, but they will not generate the same sequence.</source>
          <target state="translated">이 함수가 반환 한 객체는 스레드로부터 안전하며 잠금이없는 모든 스레드에서 사용할 수 있습니다. 또한 복사 될 수 있으며 결과 &lt;a href=&quot;qrandomgenerator&quot;&gt;QRandomGenerator&lt;/a&gt; 도 운영 체제 기능에 액세스하지만 동일한 순서를 생성하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="486adff21dc6179e0bf2969351bdb66a2ef273e8" translate="yes" xml:space="preserve">
          <source>The object returned can be any descendant, including itself.</source>
          <target state="translated">반환 된 객체는 자신을 포함하여 모든 자손 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa94ee59cf3f5fe5c9c75b60363acc4d3d1d626a" translate="yes" xml:space="preserve">
          <source>The object should call &lt;a href=&quot;qinputmethodqueryevent#setValue&quot;&gt;setValue&lt;/a&gt;() on the event to fill in the requested data before calling &lt;a href=&quot;qevent#accept&quot;&gt;accept&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qevent#accept&quot;&gt;수락&lt;/a&gt; ()을 호출하기 전에 요청 된 데이터를 채우려면 이벤트에서 객체가 &lt;a href=&quot;qinputmethodqueryevent#setValue&quot;&gt;setValue&lt;/a&gt; ()를 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="a7d07650234b85fbec6754de329932a1b6719e2d" translate="yes" xml:space="preserve">
          <source>The object summarizes the state of the window and should be treated with priority.</source>
          <target state="translated">개체는 창의 상태를 요약하며 우선 순위로 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="6f7cf78da336d44bf1f179c09c56aa609e376699" translate="yes" xml:space="preserve">
          <source>The object supports extended selection.</source>
          <target state="translated">객체는 확장 된 선택을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="24d7ed8fb5c892e6f5f6ec3e723ac7ee4844ce37" translate="yes" xml:space="preserve">
          <source>The object supports multiple selected items.</source>
          <target state="translated">객체는 선택된 여러 항목을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="2d79f318cbb7dfccf8f51a52e51ea34e5bbaac5d" translate="yes" xml:space="preserve">
          <source>The object to be updated.</source>
          <target state="translated">업데이트 할 개체입니다.</target>
        </trans-unit>
        <trans-unit id="5e4b3837e89d938ea62f910ad0fa6dce294f1586" translate="yes" xml:space="preserve">
          <source>The object will be created asynchronously.</source>
          <target state="translated">객체가 비동기 적으로 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="214ade03e503fae795b985259a1a9e9f1b6746c7" translate="yes" xml:space="preserve">
          <source>The object will be created in the same context as the one in which the component was created. This function will always return null when called on components which were not created in QML.</source>
          <target state="translated">객체는 구성 요소가 작성된 것과 동일한 컨텍스트에서 작성됩니다. 이 함수는 QML에서 작성되지 않은 컴포넌트에서 호출 될 때 항상 널을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="8e8cfd3bacf00334856790abccd004a964bbdf96" translate="yes" xml:space="preserve">
          <source>The object will be created synchronously.</source>
          <target state="translated">객체가 동 기적으로 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="5841d2552b2c9e5075851f19e00532d4090c30f9" translate="yes" xml:space="preserve">
          <source>The object will be deleted after it has cleaned up (&lt;a href=&quot;qdeferreddeleteevent&quot;&gt;QDeferredDeleteEvent&lt;/a&gt;)</source>
          <target state="translated">정리 후 오브젝트가 삭제됩니다 ( &lt;a href=&quot;qdeferreddeleteevent&quot;&gt;QDeferredDeleteEvent&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="80ad2da8a80c230a5078b784e88e13e4bdc7e38f" translate="yes" xml:space="preserve">
          <source>The object will be deleted when control returns to the event loop. If the event loop is not running when this function is called (e.g. deleteLater() is called on an object before &lt;a href=&quot;qcoreapplication#exec&quot;&gt;QCoreApplication::exec&lt;/a&gt;()), the object will be deleted once the event loop is started. If deleteLater() is called after the main event loop has stopped, the object will not be deleted. Since Qt 4.8, if deleteLater() is called on an object that lives in a thread with no running event loop, the object will be destroyed when the thread finishes.</source>
          <target state="translated">제어가 이벤트 루프로 돌아 오면 오브젝트가 삭제됩니다. 이 함수가 호출 될 때 이벤트 루프가 실행 중이 아닌 경우 (예 : &lt;a href=&quot;qcoreapplication#exec&quot;&gt;QCoreApplication :: exec&lt;/a&gt; () 이전에 오브젝트에서 deleteLater ()가 호출 됨), 이벤트 루프가 시작되면 오브젝트가 삭제됩니다. 기본 이벤트 루프가 중지 된 후 deleteLater ()가 호출되면 객체가 삭제되지 않습니다. Qt 4.8부터 실행중인 이벤트 루프가없는 스레드에있는 객체에서 deleteLater ()를 호출하면 스레드가 완료 될 때 객체가 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="6c7329b367145649e655b5eb8fa62276ab3459b1" translate="yes" xml:space="preserve">
          <source>The object will report no match through the &lt;a href=&quot;qregularexpressionmatch#hasMatch&quot;&gt;hasMatch&lt;/a&gt;() and the &lt;a href=&quot;qregularexpressionmatch#hasPartialMatch&quot;&gt;hasPartialMatch&lt;/a&gt;() member functions.</source>
          <target state="translated">객체는 &lt;a href=&quot;qregularexpressionmatch#hasMatch&quot;&gt;hasMatch&lt;/a&gt; () 및 &lt;a href=&quot;qregularexpressionmatch#hasPartialMatch&quot;&gt;hasPartialMatch&lt;/a&gt; () 멤버 함수를 통해 일치하는 사항을보고하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="49a69657c4c58f8cb8bb1c3db646347365611b8e" translate="yes" xml:space="preserve">
          <source>The object's &lt;a href=&quot;qaccessible#Text-enum&quot;&gt;QAccessible::Description&lt;/a&gt; changed.</source>
          <target state="translated">개체의 &lt;a href=&quot;qaccessible#Text-enum&quot;&gt;QAccessible :: Description이&lt;/a&gt; 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="a90f06fbfc54e1a4d8a2af2b20830fa529a28554" translate="yes" xml:space="preserve">
          <source>The object's appearance changes frequently.</source>
          <target state="translated">개체의 모양이 자주 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="a1cc14451669fe1340173ace9727d2be3488eeee" translate="yes" xml:space="preserve">
          <source>The object's appearance is sensitive to the mouse cursor position.</source>
          <target state="translated">객체의 모양은 마우스 커서 위치에 민감합니다.</target>
        </trans-unit>
        <trans-unit id="36306b0cf8d702ef140dc0a86c356f106fb41a18" translate="yes" xml:space="preserve">
          <source>The object's check box is checked.</source>
          <target state="translated">개체의 확인란이 선택되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="420c00df68b4a04b4493b625789dcdce84f8f5eb" translate="yes" xml:space="preserve">
          <source>The object's signals this signal blocker was blocking prior to being moved to, if any, are unblocked</source>
          <target state="translated">이 신호 차단기가 이동하기 전에 차단 한 물체의 신호는 차단되지 않습니다</target>
        </trans-unit>
        <trans-unit id="e13e558fc1f2c740aa3a44e51518d724808a5ef0" translate="yes" xml:space="preserve">
          <source>The objects must have the attached &lt;a href=&quot;qml-qtwebchannel-webchannel#id-attached-prop&quot;&gt;id&lt;/a&gt; property set to an identifier, under which the object is then known on the HTML side.</source>
          <target state="translated">객체에는 첨부 된 &lt;a href=&quot;qml-qtwebchannel-webchannel#id-attached-prop&quot;&gt;id&lt;/a&gt; 속성이 식별자로 설정 되어 있어야하며 , 그 아래에서 객체는 HTML 측에서 알려집니다.</target>
        </trans-unit>
        <trans-unit id="010bfdd0c8f3c24b24932e053c20dc7d7d2739ca" translate="yes" xml:space="preserve">
          <source>The office paper material has the following properties:</source>
          <target state="translated">사무 용지 재료에는 다음과 같은 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b39e18c763310f5fdd2a5388ba219c03473c8fa" translate="yes" xml:space="preserve">
          <source>The offline installer is available &lt;a href=&quot;https://www.qt.io/offline-installer&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">오프라인 설치 프로그램은 &lt;a href=&quot;https://www.qt.io/offline-installer&quot;&gt;여기에서&lt;/a&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7ea4409ed34537dee3beb60d93328c2446afadc8" translate="yes" xml:space="preserve">
          <source>The offscreen surface is valid if the platform resources have been successfuly allocated.</source>
          <target state="translated">플랫폼 자원이 성공적으로 할당 된 경우 오프 스크린 화면이 유효합니다.</target>
        </trans-unit>
        <trans-unit id="3d710c9ed41b09587bca5ef22b8c3c3290293b11" translate="yes" xml:space="preserve">
          <source>The offset and size arguments are specified in device independent pixels. The returned pixmap may be larger than the requested size when grabbing from a high-DPI screen. Call &lt;a href=&quot;qpixmap#devicePixelRatio&quot;&gt;QPixmap::devicePixelRatio&lt;/a&gt;() to determine if this is the case.</source>
          <target state="translated">오프셋 및 크기 인수는 장치 독립적 픽셀로 지정됩니다. 높은 DPI 화면에서 캡처 할 때 반환 된 픽스맵이 요청 된 크기보다 클 수 있습니다. &lt;a href=&quot;qpixmap#devicePixelRatio&quot;&gt;QPixmap :: devicePixelRatio&lt;/a&gt; ()를 호출 하여이 경우인지 판별하십시오.</target>
        </trans-unit>
        <trans-unit id="70c3e20d9dc160641da53e9e4f8cb57e7a3b0eef" translate="yes" xml:space="preserve">
          <source>The offset between the tickmarks and the slider.</source>
          <target state="translated">눈금과 슬라이더 사이의 오프셋입니다.</target>
        </trans-unit>
        <trans-unit id="661a884d57e62052a9e8970fdb6f60e8c07a7d5f" translate="yes" xml:space="preserve">
          <source>The offset is given in device coordinates, which means it is unaffected by scale.</source>
          <target state="translated">오프셋은 장치 좌표로 제공되며 이는 스케일의 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="47b934d51dc6e8ffc126a6a48df273d8fc66ddcb" translate="yes" xml:space="preserve">
          <source>The offset is the sum of all the methods in the class's superclasses (which is always positive since &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; has the deleteLater() slot and a destroyed() signal).</source>
          <target state="translated">오프셋은 클래스의 슈퍼 클래스에있는 모든 메소드의 합입니다 ( &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 에 deleteLater () 슬롯과 destroyed () 신호가 있으므로 항상 양수입니다 ).</target>
        </trans-unit>
        <trans-unit id="e8c47dd654ff2895b141c35fb00255cf7ae38e8d" translate="yes" xml:space="preserve">
          <source>The offset is the sum of all the properties in the class's superclasses (which is always positive since &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; has the name() property).</source>
          <target state="translated">오프셋은 클래스의 슈퍼 클래스에있는 모든 속성의 합계입니다 ( &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 에 name () 속성이 있으므로 항상 양수 임).</target>
        </trans-unit>
        <trans-unit id="29e1db7f66dc9040990995b866b94d84975040f9" translate="yes" xml:space="preserve">
          <source>The offset measures the total change in position of the user's input covered by the gesture on the input device.</source>
          <target state="translated">오프셋은 입력 장치상의 제스처에 의해 커버되는 사용자 입력의 위치에서의 총 변화를 측정한다.</target>
        </trans-unit>
        <trans-unit id="3c1d1688f423a05bbfcaa1f9e2a8994c8f0529d5" translate="yes" xml:space="preserve">
          <source>The offset of each wave. Animate this property to see the waves move. Sensible values are in the range &lt;code&gt;[0...360]&lt;/code&gt;. &lt;code&gt;0&lt;/code&gt; by default.</source>
          <target state="translated">각 웨이브의 오프셋입니다. 이 속성에 애니메이션을 적용하여 파도가 움직이는 것을 확인합니다. 적절한 값은 &lt;code&gt;[0...360]&lt;/code&gt; 범위에 있습니다. 기본적으로 &lt;code&gt;0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="044aff06a7eb66865f43840bdfd7dfb175868dd5" translate="yes" xml:space="preserve">
          <source>The offset specifies how far along the path the items are from their initial positions. This is a real number that ranges from 0.0 to the count of items in the model.</source>
          <target state="translated">오프셋은 항목이 초기 위치에서 얼마나 멀리 떨어져 있는지 지정합니다. 0.0에서 모델의 항목 수까지의 실수입니다.</target>
        </trans-unit>
        <trans-unit id="266fbfacbb562c00bebfc74e302962bf473af503" translate="yes" xml:space="preserve">
          <source>The offset specifies how far along the path the items are from their initial positions. This is a real number that ranges from &lt;code&gt;0&lt;/code&gt; to the count of items in the model.</source>
          <target state="translated">오프셋은 항목이 초기 위치에서 경로를 따라 얼마나 멀리 떨어져 있는지 지정합니다. 이것은 &lt;code&gt;0&lt;/code&gt; 에서 모델의 항목 수 까지 범위의 실수 입니다.</target>
        </trans-unit>
        <trans-unit id="318eafc4cae0216b6f83b54dd9e4bb348cc809e7" translate="yes" xml:space="preserve">
          <source>The old access point may be closed in the process if there are no other network sessions for it. Therefore any open socket that still uses the old access point may become unusable and should be closed before completing the migration.</source>
          <target state="translated">다른 액세스 세션이없는 경우 프로세스에서 이전 액세스 포인트가 닫힐 수 있습니다. 따라서 여전히 기존 액세스 포인트를 사용하는 열린 소켓은 사용할 수 없게 될 수 있으므로 마이그레이션을 완료하기 전에 닫아야합니다.</target>
        </trans-unit>
        <trans-unit id="e773d61a89580dfd752f3a493bd535f0ee4dabd6" translate="yes" xml:space="preserve">
          <source>The old position is accessible through &lt;a href=&quot;qmoveevent#oldPos&quot;&gt;QMoveEvent::oldPos&lt;/a&gt;().</source>
          <target state="translated">이전 위치는 &lt;a href=&quot;qmoveevent#oldPos&quot;&gt;QMoveEvent :: oldPos&lt;/a&gt; ()를 통해 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5df7c78d0f1db3a033b0a91ca8960e55de84b141" translate="yes" xml:space="preserve">
          <source>The oldest pixmaps (least recently accessed in the cache) are deleted when more space is needed.</source>
          <target state="translated">더 많은 공간이 필요할 때 가장 오래된 픽스맵 (캐시에서 가장 최근에 액세스 한 것)이 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="f8d56487872748a3ac3cbce30065a84f2ea6865a" translate="yes" xml:space="preserve">
          <source>The online installer is available from the Qt &lt;a href=&quot;http://qt.io/download&quot;&gt;Downloads&lt;/a&gt; page.</source>
          <target state="translated">온라인 설치 프로그램은 Qt &lt;a href=&quot;http://qt.io/download&quot;&gt;다운로드&lt;/a&gt; 페이지 에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="247b508919fb5f44113f696f7e8434f84af7ba43" translate="yes" xml:space="preserve">
          <source>The online installer is available from the Qt &lt;a href=&quot;http://qt.io/download#&quot;&gt;Downloads&lt;/a&gt; page.</source>
          <target state="translated">온라인 설치 프로그램은 Qt &lt;a href=&quot;http://qt.io/download#&quot;&gt;다운로드&lt;/a&gt; 페이지에서 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="f8bfb3de0bbc77e4fd256fc7c6d1d76194e6784b" translate="yes" xml:space="preserve">
          <source>The online plugin uses the tiled map classes, which caches tile data in heap memory and texture memory.</source>
          <target state="translated">온라인 플러그인은 타일 맵 클래스를 사용하여 타일 데이터를 힙 메모리 및 텍스처 메모리에 캐시합니다.</target>
        </trans-unit>
        <trans-unit id="a8d9989f922f1a957e994a25a3a72e39d775f6f1" translate="yes" xml:space="preserve">
          <source>The only behavioral difference is that this class sets the type properly.</source>
          <target state="translated">동작상의 유일한 차이점은이 클래스가 유형을 올바르게 설정한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7ff2576cba9b0a8e4ef2e74f37f4b63ba885ff13" translate="yes" xml:space="preserve">
          <source>The only behavioural difference is that this class sets the type properly.</source>
          <target state="translated">동작상의 유일한 차이점은이 클래스가 유형을 올바르게 설정한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="9ec55d1ca759b9dc6d7ecd7a1ccb549b5714c3c7" translate="yes" xml:space="preserve">
          <source>The only behavioural difference is that this class sets the type properly.&lt;a href=&quot;qmetaobject#invokeMethod&quot;&gt;QMetaObject::invokeMethod&lt;/a&gt;(backend(), &quot;calibrate&quot;);</source>
          <target state="translated">동작상의 유일한 차이점은이 클래스가 유형을 올바르게 설정한다는 것입니다. &lt;a href=&quot;qmetaobject#invokeMethod&quot;&gt;QMetaObject :: invokeMethod&lt;/a&gt; (backend (), &quot;calibrate&quot;);</target>
        </trans-unit>
        <trans-unit id="44e47eb73293b1cb787437f112b186a0ee30e89f" translate="yes" xml:space="preserve">
          <source>The only cases in which the port may not be straightforward is if the old code relied on template specializations of the qLess() and/or the qSwap() functions, which were used internally by the implementations of the Qt algorithmic functions, but are instead ignored by the STL ones.</source>
          <target state="translated">포트가 간단하지 않은 유일한 경우는 이전 코드가 qLess () 및 / 또는 qSwap () 함수의 템플릿 전문화에 의존하고 Qt 알고리즘 함수의 구현에 의해 내부적으로 사용되었지만 대신 STL에 의해 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="2b719162f9966209c1b2d384b92f42eaaa670353" translate="yes" xml:space="preserve">
          <source>The only difference is that the &lt;a href=&quot;qaccelerometerfilter#filter&quot;&gt;filter&lt;/a&gt;() method features a pointer to &lt;a href=&quot;qaccelerometerreading&quot;&gt;QAccelerometerReading&lt;/a&gt; instead of &lt;a href=&quot;qsensorreading&quot;&gt;QSensorReading&lt;/a&gt;.</source>
          <target state="translated">유일한 차이는이다 &lt;a href=&quot;qaccelerometerfilter#filter&quot;&gt;필터&lt;/a&gt; () 메소드에 대한 포인터 기능 &lt;a href=&quot;qaccelerometerreading&quot;&gt;QAccelerometerReading&lt;/a&gt; 대신 &lt;a href=&quot;qsensorreading&quot;&gt;QSensorReading를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9daef753da659b876478bd690eb87f4297b7c7e4" translate="yes" xml:space="preserve">
          <source>The only difference is that the &lt;a href=&quot;qaltimeterfilter#filter&quot;&gt;filter&lt;/a&gt;() method features a pointer to &lt;a href=&quot;qaltimeterreading&quot;&gt;QAltimeterReading&lt;/a&gt; instead of &lt;a href=&quot;qsensorreading&quot;&gt;QSensorReading&lt;/a&gt;.</source>
          <target state="translated">유일한 차이점은 &lt;a href=&quot;qaltimeterfilter#filter&quot;&gt;filter&lt;/a&gt; () 메소드에 &lt;a href=&quot;qaltimeterreading&quot;&gt;QSensorReading&lt;/a&gt; 대신 QAltimeterReading에 대한 포인터가 있다는 &lt;a href=&quot;qsensorreading&quot;&gt;점&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="578332dd25747baae70bc590caa6bdbdafd588ff" translate="yes" xml:space="preserve">
          <source>The only difference is that the &lt;a href=&quot;qambientlightfilter#filter&quot;&gt;filter&lt;/a&gt;() method features a pointer to &lt;a href=&quot;qambientlightreading&quot;&gt;QAmbientLightReading&lt;/a&gt; instead of &lt;a href=&quot;qsensorreading&quot;&gt;QSensorReading&lt;/a&gt;.</source>
          <target state="translated">유일한 차이는이다 &lt;a href=&quot;qambientlightfilter#filter&quot;&gt;필터&lt;/a&gt; () 메소드에 대한 포인터 기능 &lt;a href=&quot;qambientlightreading&quot;&gt;QAmbientLightReading&lt;/a&gt; 대신 &lt;a href=&quot;qsensorreading&quot;&gt;QSensorReading를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="73c1e9c50a61616056cfee5149abcd1d5aa1fe0d" translate="yes" xml:space="preserve">
          <source>The only difference is that the &lt;a href=&quot;qambienttemperaturefilter#filter&quot;&gt;filter&lt;/a&gt;() method features a pointer to &lt;a href=&quot;qambienttemperaturereading&quot;&gt;QAmbientTemperatureReading&lt;/a&gt; instead of &lt;a href=&quot;qsensorreading&quot;&gt;QSensorReading&lt;/a&gt;.</source>
          <target state="translated">유일한 차이점은 &lt;a href=&quot;qambienttemperaturefilter#filter&quot;&gt;filter&lt;/a&gt; () 메소드에 &lt;a href=&quot;qambienttemperaturereading&quot;&gt;QSensorReading&lt;/a&gt; 대신 QAmbientTemperatureReading에 대한 포인터가 있다는 &lt;a href=&quot;qsensorreading&quot;&gt;점&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f552dd1b9446d511d56a28deef52d43d0c6f18d0" translate="yes" xml:space="preserve">
          <source>The only difference is that the &lt;a href=&quot;qcompassfilter#filter&quot;&gt;filter&lt;/a&gt;() method features a pointer to &lt;a href=&quot;qcompassreading&quot;&gt;QCompassReading&lt;/a&gt; instead of &lt;a href=&quot;qsensorreading&quot;&gt;QSensorReading&lt;/a&gt;.</source>
          <target state="translated">유일한 차이는이다 &lt;a href=&quot;qcompassfilter#filter&quot;&gt;필터&lt;/a&gt; () 메소드에 대한 포인터를 갖추고 &lt;a href=&quot;qcompassreading&quot;&gt;QCompassReading&lt;/a&gt; 대신 &lt;a href=&quot;qsensorreading&quot;&gt;QSensorReading&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a32c79221d53476c252c13b7620a9270327fabc4" translate="yes" xml:space="preserve">
          <source>The only difference is that the &lt;a href=&quot;qdistancefilter#filter&quot;&gt;filter&lt;/a&gt;() method features a pointer to &lt;a href=&quot;qdistancereading&quot;&gt;QDistanceReading&lt;/a&gt; instead of &lt;a href=&quot;qsensorreading&quot;&gt;QSensorReading&lt;/a&gt;.</source>
          <target state="translated">유일한 차이는이다 &lt;a href=&quot;qdistancefilter#filter&quot;&gt;필터&lt;/a&gt; () 메소드에 대한 포인터를 갖추고 &lt;a href=&quot;qdistancereading&quot;&gt;QDistanceReading&lt;/a&gt; 대신 &lt;a href=&quot;qsensorreading&quot;&gt;QSensorReading&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f5a6edd191292cd1e31a394295a9562f7d54accb" translate="yes" xml:space="preserve">
          <source>The only difference is that the &lt;a href=&quot;qgyroscopefilter#filter&quot;&gt;filter&lt;/a&gt;() method features a pointer to &lt;a href=&quot;qgyroscopereading&quot;&gt;QGyroscopeReading&lt;/a&gt; instead of &lt;a href=&quot;qsensorreading&quot;&gt;QSensorReading&lt;/a&gt;.</source>
          <target state="translated">유일한 차이는이다 &lt;a href=&quot;qgyroscopefilter#filter&quot;&gt;필터&lt;/a&gt; () 메소드에 대한 포인터를 갖추고 &lt;a href=&quot;qgyroscopereading&quot;&gt;QGyroscopeReading&lt;/a&gt; 대신 &lt;a href=&quot;qsensorreading&quot;&gt;QSensorReading&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0ec88a68b1a982fc1a077c01bce8f71daebb40ff" translate="yes" xml:space="preserve">
          <source>The only difference is that the &lt;a href=&quot;qholsterfilter#filter&quot;&gt;filter&lt;/a&gt;() method features a pointer to &lt;a href=&quot;qholsterreading&quot;&gt;QHolsterReading&lt;/a&gt; instead of &lt;a href=&quot;qsensorreading&quot;&gt;QSensorReading&lt;/a&gt;.</source>
          <target state="translated">유일한 차이는이다 &lt;a href=&quot;qholsterfilter#filter&quot;&gt;필터&lt;/a&gt; () 메소드에 대한 포인터를 갖추고 &lt;a href=&quot;qholsterreading&quot;&gt;QHolsterReading&lt;/a&gt; 대신 &lt;a href=&quot;qsensorreading&quot;&gt;QSensorReading&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e45937b1411421456b76fcbbd3eb61a0035b922b" translate="yes" xml:space="preserve">
          <source>The only difference is that the &lt;a href=&quot;qhumidityfilter#filter&quot;&gt;filter&lt;/a&gt;() method features a pointer to &lt;a href=&quot;qhumidityreading&quot;&gt;QHumidityReading&lt;/a&gt; instead of &lt;a href=&quot;qsensorreading&quot;&gt;QSensorReading&lt;/a&gt;.</source>
          <target state="translated">유일한 차이는이다 &lt;a href=&quot;qhumidityfilter#filter&quot;&gt;필터&lt;/a&gt; () 메소드에 대한 포인터를 갖추고 &lt;a href=&quot;qhumidityreading&quot;&gt;QHumidityReading&lt;/a&gt; 대신 &lt;a href=&quot;qsensorreading&quot;&gt;QSensorReading&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1940669079dbb950c31660aae3c8038ab90c3b3c" translate="yes" xml:space="preserve">
          <source>The only difference is that the &lt;a href=&quot;qirproximityfilter#filter&quot;&gt;filter&lt;/a&gt;() method features a pointer to &lt;a href=&quot;qirproximityreading&quot;&gt;QIRProximityReading&lt;/a&gt; instead of &lt;a href=&quot;qsensorreading&quot;&gt;QSensorReading&lt;/a&gt;.</source>
          <target state="translated">유일한 차이는이다 &lt;a href=&quot;qirproximityfilter#filter&quot;&gt;필터&lt;/a&gt; () 메소드에 대한 포인터 기능 &lt;a href=&quot;qirproximityreading&quot;&gt;QIRProximityReading&lt;/a&gt; 대신 &lt;a href=&quot;qsensorreading&quot;&gt;QSensorReading를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ab912ebebcd26bdef233ed6145710b63f9ef6798" translate="yes" xml:space="preserve">
          <source>The only difference is that the &lt;a href=&quot;qlidfilter#filter&quot;&gt;filter&lt;/a&gt;() method features a pointer to &lt;a href=&quot;qlidreading&quot;&gt;QLidReading&lt;/a&gt; instead of &lt;a href=&quot;qsensorreading&quot;&gt;QSensorReading&lt;/a&gt;.</source>
          <target state="translated">유일한 차이는이다 &lt;a href=&quot;qlidfilter#filter&quot;&gt;필터&lt;/a&gt; () 메소드에 대한 포인터 기능 &lt;a href=&quot;qlidreading&quot;&gt;QLidReading&lt;/a&gt; 대신 &lt;a href=&quot;qsensorreading&quot;&gt;QSensorReading를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="adcedeb1ceaed42f0cb8e68e463822104a8c8ed8" translate="yes" xml:space="preserve">
          <source>The only difference is that the &lt;a href=&quot;qlightfilter#filter&quot;&gt;filter&lt;/a&gt;() method features a pointer to &lt;a href=&quot;qlightreading&quot;&gt;QLightReading&lt;/a&gt; instead of &lt;a href=&quot;qsensorreading&quot;&gt;QSensorReading&lt;/a&gt;.</source>
          <target state="translated">유일한 차이는이다 &lt;a href=&quot;qlightfilter#filter&quot;&gt;필터&lt;/a&gt; () 메소드에 대한 포인터 기능 &lt;a href=&quot;qlightreading&quot;&gt;QLightReading&lt;/a&gt; 대신 &lt;a href=&quot;qsensorreading&quot;&gt;QSensorReading를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b43dad7308c5a1474ebcae75930c5ff5b0852862" translate="yes" xml:space="preserve">
          <source>The only difference is that the &lt;a href=&quot;qmagnetometerfilter#filter&quot;&gt;filter&lt;/a&gt;() method features a pointer to &lt;a href=&quot;qmagnetometerreading&quot;&gt;QMagnetometerReading&lt;/a&gt; instead of &lt;a href=&quot;qsensorreading&quot;&gt;QSensorReading&lt;/a&gt;.</source>
          <target state="translated">유일한 차이는이다 &lt;a href=&quot;qmagnetometerfilter#filter&quot;&gt;필터&lt;/a&gt; () 메소드에 대한 포인터를 갖추고 &lt;a href=&quot;qmagnetometerreading&quot;&gt;QMagnetometerReading&lt;/a&gt; 대신 &lt;a href=&quot;qsensorreading&quot;&gt;QSensorReading&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b1f4a6e4835939ebb3998398dd8c46489894c70c" translate="yes" xml:space="preserve">
          <source>The only difference is that the &lt;a href=&quot;qorientationfilter#filter&quot;&gt;filter&lt;/a&gt;() method features a pointer to &lt;a href=&quot;qorientationreading&quot;&gt;QOrientationReading&lt;/a&gt; instead of &lt;a href=&quot;qsensorreading&quot;&gt;QSensorReading&lt;/a&gt;.</source>
          <target state="translated">유일한 차이는이다 &lt;a href=&quot;qorientationfilter#filter&quot;&gt;필터&lt;/a&gt; () 메소드에 대한 포인터를 갖추고 &lt;a href=&quot;qorientationreading&quot;&gt;QOrientationReading&lt;/a&gt; 대신 &lt;a href=&quot;qsensorreading&quot;&gt;QSensorReading&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="896534475aa06c2f4c42b04f400815614cafc831" translate="yes" xml:space="preserve">
          <source>The only difference is that the &lt;a href=&quot;qpressurefilter#filter&quot;&gt;filter&lt;/a&gt;() method features a pointer to &lt;a href=&quot;qpressurereading&quot;&gt;QPressureReading&lt;/a&gt; instead of &lt;a href=&quot;qsensorreading&quot;&gt;QSensorReading&lt;/a&gt;.</source>
          <target state="translated">유일한 차이는이다 &lt;a href=&quot;qpressurefilter#filter&quot;&gt;필터&lt;/a&gt; () 메소드에 대한 포인터를 갖추고 &lt;a href=&quot;qpressurereading&quot;&gt;QPressureReading&lt;/a&gt; 대신 &lt;a href=&quot;qsensorreading&quot;&gt;QSensorReading&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d45afc9c60460512dd51d4c0d873365a002eefb2" translate="yes" xml:space="preserve">
          <source>The only difference is that the &lt;a href=&quot;qproximityfilter#filter&quot;&gt;filter&lt;/a&gt;() method features a pointer to &lt;a href=&quot;qproximityreading&quot;&gt;QProximityReading&lt;/a&gt; instead of &lt;a href=&quot;qsensorreading&quot;&gt;QSensorReading&lt;/a&gt;.</source>
          <target state="translated">유일한 차이는이다 &lt;a href=&quot;qproximityfilter#filter&quot;&gt;필터&lt;/a&gt; () 메소드에 대한 포인터를 갖추고 &lt;a href=&quot;qproximityreading&quot;&gt;QProximityReading&lt;/a&gt; 대신 &lt;a href=&quot;qsensorreading&quot;&gt;QSensorReading&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="519a7730838dc15fa99523c85b8ebca7d34b3af5" translate="yes" xml:space="preserve">
          <source>The only difference is that the &lt;a href=&quot;qrotationfilter#filter&quot;&gt;filter&lt;/a&gt;() method features a pointer to &lt;a href=&quot;qrotationreading&quot;&gt;QRotationReading&lt;/a&gt; instead of &lt;a href=&quot;qsensorreading&quot;&gt;QSensorReading&lt;/a&gt;.</source>
          <target state="translated">유일한 차이는이다 &lt;a href=&quot;qrotationfilter#filter&quot;&gt;필터&lt;/a&gt; () 메소드에 대한 포인터를 갖추고 &lt;a href=&quot;qrotationreading&quot;&gt;QRotationReading&lt;/a&gt; 대신 &lt;a href=&quot;qsensorreading&quot;&gt;QSensorReading&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a38e1513a22a76e73379117107a542ade6faac10" translate="yes" xml:space="preserve">
          <source>The only difference is that the &lt;a href=&quot;qtapfilter#filter&quot;&gt;filter&lt;/a&gt;() method features a pointer to &lt;a href=&quot;qtapreading&quot;&gt;QTapReading&lt;/a&gt; instead of &lt;a href=&quot;qsensorreading&quot;&gt;QSensorReading&lt;/a&gt;.</source>
          <target state="translated">유일한 차이는이다 &lt;a href=&quot;qtapfilter#filter&quot;&gt;필터&lt;/a&gt; () 메소드에 대한 포인터 기능 &lt;a href=&quot;qtapreading&quot;&gt;QTapReading&lt;/a&gt; 대신 &lt;a href=&quot;qsensorreading&quot;&gt;QSensorReading를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c17ea8e32c391c45ba9f702b8c3851b72d6804f2" translate="yes" xml:space="preserve">
          <source>The only difference is that the &lt;a href=&quot;qtiltfilter#filter&quot;&gt;filter&lt;/a&gt;() method features a pointer to &lt;a href=&quot;qtiltreading&quot;&gt;QTiltReading&lt;/a&gt; instead of &lt;a href=&quot;qsensorreading&quot;&gt;QSensorReading&lt;/a&gt;.</source>
          <target state="translated">유일한 차이는이다 &lt;a href=&quot;qtiltfilter#filter&quot;&gt;필터&lt;/a&gt; () 메소드에 대한 포인터 기능 &lt;a href=&quot;qtiltreading&quot;&gt;QTiltReading&lt;/a&gt; 대신 &lt;a href=&quot;qsensorreading&quot;&gt;QSensorReading를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0c162fbd7d5fb602e3b740d0bb1157f268e030d3" translate="yes" xml:space="preserve">
          <source>The only difference is that the message now is a &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; instead of a &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;.</source>
          <target state="translated">유일한 차이점은 메시지가 이제 &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; 대신 &lt;a href=&quot;qbytearray&quot;&gt;QByteArray라는&lt;/a&gt; 것입니다 .</target>
        </trans-unit>
        <trans-unit id="eb05b7811641d6adb93c940be02c124888bec2d8" translate="yes" xml:space="preserve">
          <source>The only drawback of the flexibility provided by QNX Neutrino RTOS is a risk that the run environment is slightly different on your target than what is expected by Qt. This is a common reason why a Qt application on a new target fails to start. A few generic environment variables can help locate the root cause for problems:</source>
          <target state="translated">QNX Neutrino RTOS가 제공하는 유연성의 유일한 단점은 실행 환경이 Qt에 의해 예상되는 것과 약간 다릅니다. 이것이 새 대상의 Qt 애플리케이션이 시작되지 않는 일반적인 이유입니다. 몇 가지 일반적인 환경 변수는 문제의 근본 원인을 찾는 데 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f630e06d3d18bacc44447e3d6369642553a096e" translate="yes" xml:space="preserve">
          <source>The only function that we need to implement is the constructor:</source>
          <target state="translated">구현해야하는 유일한 함수는 생성자입니다.</target>
        </trans-unit>
        <trans-unit id="8ffcf3549a8d6f8ee8496a3f08786efd70d007af" translate="yes" xml:space="preserve">
          <source>The only mandatory property of a &lt;a href=&quot;qmediaresource&quot;&gt;QMediaResource&lt;/a&gt; is the &lt;a href=&quot;qmediaresource#url&quot;&gt;url&lt;/a&gt;().</source>
          <target state="translated">a의 유일한 필수 특성 &lt;a href=&quot;qmediaresource&quot;&gt;QMediaResource이&lt;/a&gt; 는 IS &lt;a href=&quot;qmediaresource#url&quot;&gt;URL&lt;/a&gt; ().</target>
        </trans-unit>
        <trans-unit id="63d87437eb9e7ae7ed813acac99e3d9e23143abe" translate="yes" xml:space="preserve">
          <source>The only mandatory property of a QMediaResource is the &lt;a href=&quot;qmediaresource#url&quot;&gt;url&lt;/a&gt;().</source>
          <target state="translated">QMediaResource의 유일한 필수 속성은 &lt;a href=&quot;qmediaresource#url&quot;&gt;url&lt;/a&gt; ()입니다.</target>
        </trans-unit>
        <trans-unit id="7701e199c6ee5b615163c8b92be6672f0bf93ffc" translate="yes" xml:space="preserve">
          <source>The only modification is in &lt;code&gt;main.cpp&lt;/code&gt;: a &lt;a href=&quot;qtremoteobjects-registry#registry&quot;&gt;Registry&lt;/a&gt; node is created to acquire a &lt;a href=&quot;qtremoteobjects-replica#replica&quot;&gt;Replica&lt;/a&gt;:</source>
          <target state="translated">유일한 수정 사항은 &lt;code&gt;main.cpp&lt;/code&gt; 에 있습니다 . &lt;a href=&quot;qtremoteobjects-registry#registry&quot;&gt;레지스트리&lt;/a&gt; 노드는 &lt;a href=&quot;qtremoteobjects-replica#replica&quot;&gt;복제본&lt;/a&gt; 을 얻기 위해 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="5d7425dda43ef81933ff0d31260e0256ff998636" translate="yes" xml:space="preserve">
          <source>The only notification currently supported is &lt;a href=&quot;qwebsocket#sslErrors&quot;&gt;sslErrors&lt;/a&gt;(). If set to PauseOnSslErrors, data transfer on the socket will be paused and needs to be enabled explicitly again by calling &lt;a href=&quot;qwebsocket#resume&quot;&gt;resume&lt;/a&gt;(). By default, this option is set to PauseNever. This option must be called before connecting to the server, otherwise it will result in undefined behavior.</source>
          <target state="translated">현재 지원되는 유일한 알림은 &lt;a href=&quot;qwebsocket#sslErrors&quot;&gt;sslErrors&lt;/a&gt; ()입니다. PauseOnSslErrors로 설정하면 소켓의 데이터 전송이 일시 정지되며 &lt;a href=&quot;qwebsocket#resume&quot;&gt;resume&lt;/a&gt; () 을 호출하여 명시 적으로 다시 활성화해야합니다 . 기본적으로이 옵션은 PauseNever로 설정되어 있습니다. 서버에 연결하기 전에이 옵션을 호출해야합니다. 그렇지 않으면 정의되지 않은 동작이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7fdde9ea3c94b2a5742f062dc46a37471dd486f9" translate="yes" xml:space="preserve">
          <source>The only purpose of this macro is to provide an anchor for attaching meta data like to &lt;a href=&quot;qtglobal#qtTrId&quot;&gt;qtTrId&lt;/a&gt;().</source>
          <target state="translated">이 매크로의 유일한 목적은 &lt;a href=&quot;qtglobal#qtTrId&quot;&gt;qtTrId&lt;/a&gt; () 와 같은 메타 데이터를 첨부하기위한 앵커를 제공하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="e009d46caeed2faa5dfc9e9652f0f6735359ce64" translate="yes" xml:space="preserve">
          <source>The only recoverable error is &lt;a href=&quot;qcborerror#Code-enum&quot;&gt;QCborError::EndOfFile&lt;/a&gt;, which indicates that more data is required in order to complete the parsing. This situation is useful when data is being read from an asynchronous source, such as a pipe (&lt;a href=&quot;qprocess&quot;&gt;QProcess&lt;/a&gt;) or a socket (&lt;a href=&quot;qtcpsocket&quot;&gt;QTcpSocket&lt;/a&gt;, &lt;a href=&quot;qudpsocket&quot;&gt;QUdpSocket&lt;/a&gt;, &lt;a href=&quot;qnetworkreply&quot;&gt;QNetworkReply&lt;/a&gt;, etc.). When more data arrives, the surrounding code needs to call either &lt;a href=&quot;qcborstreamreader#addData&quot;&gt;addData&lt;/a&gt;(), if parsing from a &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt;, or &lt;a href=&quot;qcborstreamreader#reparse&quot;&gt;reparse&lt;/a&gt;(), if it is instead reading directly a the QIDOevice that now has more data available (see &lt;a href=&quot;qcborstreamreader#setDevice&quot;&gt;setDevice&lt;/a&gt;()).</source>
          <target state="translated">복구 가능한 유일한 오류는 &lt;a href=&quot;qcborerror#Code-enum&quot;&gt;QCborError :: EndOfFile입니다&lt;/a&gt; . 이는 구문 분석을 완료하기 위해 더 많은 데이터가 필요함을 나타냅니다. 이 상황은 파이프 ( &lt;a href=&quot;qprocess&quot;&gt;QProcess&lt;/a&gt; ) 또는 소켓 ( &lt;a href=&quot;qtcpsocket&quot;&gt;QTcpSocket&lt;/a&gt; , &lt;a href=&quot;qudpsocket&quot;&gt;QUdpSocket&lt;/a&gt; , &lt;a href=&quot;qnetworkreply&quot;&gt;QNetworkReply&lt;/a&gt; 등) 과 같은 비동기 소스에서 데이터를 읽을 때 유용합니다 . 더 많은 데이터가 도착하면, 주변의 코드 요구 호출 중 하나 &lt;a href=&quot;qcborstreamreader#addData&quot;&gt;는, addData&lt;/a&gt; (), A로부터 파싱 경우 &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; , 또는 &lt;a href=&quot;qcborstreamreader#reparse&quot;&gt;재분석&lt;/a&gt; 대신 사용할 더 많은 데이터를 가지고 직접 상기 QIDOevice를 읽는 경우 (), (참조 &lt;a href=&quot;qcborstreamreader#setDevice&quot;&gt;setDevice을&lt;/a&gt; ()).</target>
        </trans-unit>
        <trans-unit id="d0bc947719de04f6ab7404fbcebf0c8fb5d9ad7a" translate="yes" xml:space="preserve">
          <source>The only scenario in which you need to call it directly is if you implement a custom layout that supports nested layouts.</source>
          <target state="translated">중첩 된 레이아웃을 지원하는 사용자 정의 레이아웃을 구현하는 경우 직접 호출해야하는 유일한 시나리오입니다.</target>
        </trans-unit>
        <trans-unit id="49c1d91767db913abd1f8a5851e6284a5f6ce06e" translate="yes" xml:space="preserve">
          <source>The only service that can be instantiated with &lt;code&gt;&amp;lt;invoke&amp;gt;&lt;/code&gt; is another SCXML state machine.</source>
          <target state="translated">&lt;code&gt;&amp;lt;invoke&amp;gt;&lt;/code&gt; 로 인스턴스화 할 수있는 유일한 서비스 는 다른 SCXML 상태 시스템입니다.</target>
        </trans-unit>
        <trans-unit id="79ae1ba2ce5a75c2c915b2de78116e5cddbac6e7" translate="yes" xml:space="preserve">
          <source>The only useful thing you can do with the return value of this macro is to pass it to &lt;a href=&quot;qstring#asprintf&quot;&gt;QString::asprintf&lt;/a&gt;() for use in a &lt;code&gt;%ls&lt;/code&gt; conversion. In particular, the return value is</source>
          <target state="translated">이 매크로의 반환 값으로 수행 할 수있는 유일한 유용한 방법 은 &lt;code&gt;%ls&lt;/code&gt; 변환 에 사용 하기 위해 &lt;a href=&quot;qstring#asprintf&quot;&gt;QString :: asprintf&lt;/a&gt; ()에 전달하는 것 입니다. 특히 반환 값은</target>
        </trans-unit>
        <trans-unit id="d358fa245abdd7d3853d2b4cc1d7dad847371a84" translate="yes" xml:space="preserve">
          <source>The only way to be sure that no errors are being returned from the OpenGL implementation is checking with &lt;code&gt;glGetError&lt;/code&gt; after each and every API call. Moreover, OpenGL errors stack up, therefore glGetError should always be used in a loop like this:</source>
          <target state="translated">OpenGL 구현에서 오류가 리턴되지 않도록하는 유일한 방법은 모든 API 호출 후 &lt;code&gt;glGetError&lt;/code&gt; 로 확인하는 것 입니다. 또한 OpenGL 오류는 누적되므로 glGetError는 항상 다음과 같은 루프에서 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="93c227b696e5a88a63e904023f76f21d6444c434" translate="yes" xml:space="preserve">
          <source>The only way you can use a document type that was created this way, is in combination with the &lt;a href=&quot;qdomimplementation#createDocument&quot;&gt;createDocument&lt;/a&gt;() function to create a &lt;a href=&quot;qdomdocument&quot;&gt;QDomDocument&lt;/a&gt; with this document type.</source>
          <target state="translated">이 방법으로 작성된 문서 유형을 사용할 수있는 유일한 방법은 &lt;a href=&quot;qdomimplementation#createDocument&quot;&gt;createDocument&lt;/a&gt; () 함수 와 결합하여이 문서 유형으로 &lt;a href=&quot;qdomdocument&quot;&gt;QDomDocument&lt;/a&gt; 를 작성하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="d493e97bc7eeea2d4094fa7ad58da948fd30acc0" translate="yes" xml:space="preserve">
          <source>The only widget currently supporting this property is &lt;a href=&quot;qpushbutton&quot;&gt;QPushButton&lt;/a&gt;.</source>
          <target state="translated">현재이 속성을 지원하는 유일한 위젯은 &lt;a href=&quot;qpushbutton&quot;&gt;QPushButton&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="52aecd0534ffe96c2de7c85a73e9d57839da2432" translate="yes" xml:space="preserve">
          <source>The opacity for a widget. Possible values are from 0 (transparent) to 255 (opaque). For the moment, this is only supported for &lt;a href=&quot;qtooltip&quot;&gt;tooltips&lt;/a&gt;.</source>
          <target state="translated">위젯의 불투명도입니다. 가능한 값은 0 (투명)에서 255 (불투명)입니다. 현재로서는 &lt;a href=&quot;qtooltip&quot;&gt;툴팁에&lt;/a&gt; 대해서만 지원됩니다 .</target>
        </trans-unit>
        <trans-unit id="f10c8f2de221d162391e13defe043ad01aa8e01f" translate="yes" xml:space="preserve">
          <source>The opacity of a &lt;a href=&quot;qsgopacitynode&quot;&gt;QSGOpacityNode&lt;/a&gt; has changed.</source>
          <target state="translated">&lt;a href=&quot;qsgopacitynode&quot;&gt;QSGOpacityNode&lt;/a&gt; 의 불투명도 가 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="344a655f469ce4eea640b1509e892062175da0fd" translate="yes" xml:space="preserve">
          <source>The opacity of the series. By default, the opacity is 1.0. The valid values range from 0.0 (transparent) to 1.0 (opaque).</source>
          <target state="translated">시리즈의 불투명도 기본적으로 불투명도는 1.0입니다. 유효한 값의 범위는 0.0 (투명)에서 1.0 (불투명)입니다.</target>
        </trans-unit>
        <trans-unit id="413d0a064d28712d5237b7149defe1d720c46475" translate="yes" xml:space="preserve">
          <source>The opacity of the window.</source>
          <target state="translated">창의 불투명도입니다.</target>
        </trans-unit>
        <trans-unit id="38d2c212d7c7ad5d05ac90d07868ee2170703da0" translate="yes" xml:space="preserve">
          <source>The opacity property decides the state of the painter passed to the &lt;a href=&quot;qgraphicsitem#paint&quot;&gt;paint&lt;/a&gt;() function. If the item is cached, i.e., &lt;a href=&quot;qgraphicsitem#CacheMode-enum&quot;&gt;ItemCoordinateCache&lt;/a&gt; or &lt;a href=&quot;qgraphicsitem#CacheMode-enum&quot;&gt;DeviceCoordinateCache&lt;/a&gt;, the effective property will be applied to the item's cache as it is rendered.</source>
          <target state="translated">opacity 속성은 &lt;a href=&quot;qgraphicsitem#paint&quot;&gt;paint&lt;/a&gt; () 함수에 전달 된 페인터의 상태를 결정합니다 . 항목이 캐시되면 (예 : &lt;a href=&quot;qgraphicsitem#CacheMode-enum&quot;&gt;ItemCoordinateCache&lt;/a&gt; 또는 &lt;a href=&quot;qgraphicsitem#CacheMode-enum&quot;&gt;DeviceCoordinateCache&lt;/a&gt; ) 유효 속성은 렌더링 될 때 항목의 캐시에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="2208122841bfcefe9dc8190d11717d5f0b89a0c2" translate="yes" xml:space="preserve">
          <source>The opaque key facility allows applications to add support for facilities such as PKCS#11 that Qt does not currently offer natively.</source>
          <target state="translated">불투명 키 기능을 통해 응용 프로그램은 Qt가 현재 기본적으로 제공하지 않는 PKCS # 11과 같은 기능에 대한 지원을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a691fea4b6fa1932e238001006a3e59717b73361" translate="yes" xml:space="preserve">
          <source>The opaque material will be preferred by the renderer over the default material, as returned by the &lt;a href=&quot;qsggeometrynode#material&quot;&gt;material&lt;/a&gt;() function, if it is not null and the geometry item has an inherited opacity of 1.</source>
          <target state="translated">렌더러는 &lt;a href=&quot;qsggeometrynode#material&quot;&gt;머티리얼&lt;/a&gt; () 함수가 null이 아니고 지오메트리 항목의 상속 된 불투명도가 1 인 경우 렌더러가 기본 머티리얼보다 기본 머티리얼을 선호합니다 .</target>
        </trans-unit>
        <trans-unit id="6ab72afe8fcba5eb9053bab3e607f6492a75f3e4" translate="yes" xml:space="preserve">
          <source>The opaque textured material respects the current matrix and the alpha channel of the texture. It will disregard the accumulated opacity in the scenegraph.</source>
          <target state="translated">불투명 텍스처 된 재질은 현재 매트릭스와 텍스처의 알파 채널을 존중합니다. 장면 그래프에서 누적 된 불투명도를 무시합니다.</target>
        </trans-unit>
        <trans-unit id="93a5448849861cefe9b78f926ebb736fd556858d" translate="yes" xml:space="preserve">
          <source>The opaque textured material will fill every pixel in a geometry with the supplied texture. The material does not respect the opacity of the &lt;a href=&quot;qsgmaterialshader-renderstate&quot;&gt;QSGMaterialShader::RenderState&lt;/a&gt;, so opacity nodes in the parent chain of nodes using this material, have no effect.</source>
          <target state="translated">불투명 텍스처 재질은 제공된 텍스처로 지오메트리의 모든 픽셀을 채 웁니다. 머티리얼은 &lt;a href=&quot;qsgmaterialshader-renderstate&quot;&gt;QSGMaterialShader :: RenderState&lt;/a&gt; 의 불투명도를 존중하지 않으므로이 머티리얼을 사용하는 상위 노드 체인의 불투명 노드는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cf40cbb9fa314e5fed21a8bcca2d7cd97f3a42e7" translate="yes" xml:space="preserve">
          <source>The opaqueness refers to scene graph opacity, the material is still allowed to set &lt;a href=&quot;qsgmaterial#Flag-enum&quot;&gt;QSGMaterial::Blending&lt;/a&gt; to true and draw transparent pixels.</source>
          <target state="translated">불투명도는 장면 그래프 불투명도를 나타내며, 재료는 여전히 &lt;a href=&quot;qsgmaterial#Flag-enum&quot;&gt;QSGMaterial :: Blending&lt;/a&gt; 을 true 로 설정 하고 투명한 픽셀을 그릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2986fd124a74f62ab8eeee183dca2ee97d10dbf1" translate="yes" xml:space="preserve">
          <source>The open directory icon.</source>
          <target state="translated">열린 디렉토리 아이콘.</target>
        </trans-unit>
        <trans-unit id="84601f8bc9335bb4d34c5aef79bf09b69e86a10f" translate="yes" xml:space="preserve">
          <source>The open value of the candlestick item.</source>
          <target state="translated">촛대 항목의 시가입니다.</target>
        </trans-unit>
        <trans-unit id="b938b8f601ba2bde60c6102ee3efc51ea0d8c18e" translate="yes" xml:space="preserve">
          <source>The opening brace</source>
          <target state="translated">오프닝 버팀대</target>
        </trans-unit>
        <trans-unit id="50f0af6f7a605dce3d3fb436073b0e6862a0c94f" translate="yes" xml:space="preserve">
          <source>The operating systems supported by Qt offer the following support for high DPI displays:</source>
          <target state="translated">Qt가 지원하는 운영 체제는 높은 DPI 디스플레이에 대해 다음과 같은 지원을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c092106a825274dc045d1210ab136d11d2015430" translate="yes" xml:space="preserve">
          <source>The operation cannot currently be performed for the current configuration.</source>
          <target state="translated">현재 구성에 대한 작업을 현재 수행 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a195d3a1b208ab78fcfce1dbd937e994e8c87353" translate="yes" xml:space="preserve">
          <source>The operation failed because a system semaphore with the specified key already existed.</source>
          <target state="translated">지정된 키를 가진 시스템 세마포어가 이미 존재하여 작업이 실패했습니다.</target>
        </trans-unit>
        <trans-unit id="93cdced949d194326a31bc95183da44ab4352579" translate="yes" xml:space="preserve">
          <source>The operation failed because a system semaphore with the specified key could not be found.</source>
          <target state="translated">지정된 키를 가진 시스템 세마포어를 찾을 수 없어서 조작에 실패했습니다.</target>
        </trans-unit>
        <trans-unit id="5037356c5c05dd053d9b26283e6985983751e290" translate="yes" xml:space="preserve">
          <source>The operation failed because of an invalid key.</source>
          <target state="translated">키가 잘못되어 작업이 실패했습니다.</target>
        </trans-unit>
        <trans-unit id="e6414c64f8eca79345c16ffe919476ff4f67cb3b" translate="yes" xml:space="preserve">
          <source>The operation failed because of insufficient permissions.</source>
          <target state="translated">권한이 부족하여 작업이 실패했습니다.</target>
        </trans-unit>
        <trans-unit id="159f752a1bd5639a408af6997d2182e6b3d15e01" translate="yes" xml:space="preserve">
          <source>The operation failed because the caller didn't have the required permissions.</source>
          <target state="translated">호출자에게 필요한 권한이 없기 때문에 작업이 실패했습니다.</target>
        </trans-unit>
        <trans-unit id="23e082e5ac8d088be8c65b1b7e508d6a1ae5f17a" translate="yes" xml:space="preserve">
          <source>The operation failed because there was not enough memory available to fill the request.</source>
          <target state="translated">요청을 채우는 데 사용 가능한 메모리가 부족하여 작업이 실패했습니다.</target>
        </trans-unit>
        <trans-unit id="7f72ea32a6f475e22f40b8aea8a04d666e1c2ec2" translate="yes" xml:space="preserve">
          <source>The operation is not supported for current configuration.</source>
          <target state="translated">현재 구성에서는 작업이 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9a1685357ce5cb46eed5856132d2076c88395877" translate="yes" xml:space="preserve">
          <source>The operation is similar to painting</source>
          <target state="translated">작업은 페인팅과 유사합니다.</target>
        </trans-unit>
        <trans-unit id="1ce14c19abcf3183d9703b200ef0227aaa642018" translate="yes" xml:space="preserve">
          <source>The operation of adding and removing items preserves the items' scene-relative position and transformation, as opposed to calling &lt;a href=&quot;qgraphicsitem#setParentItem&quot;&gt;setParentItem&lt;/a&gt;(), where only the child item's parent-relative position and transformation are kept.</source>
          <target state="translated">항목을 추가하고 제거하는 작업은 하위 항목의 부모 기준 위치와 변환 만 유지되는 &lt;a href=&quot;qgraphicsitem#setParentItem&quot;&gt;setParentItem&lt;/a&gt; () 호출과 달리 항목의 장면 기준 위치와 변환을 유지합니다.</target>
        </trans-unit>
        <trans-unit id="a98c038b83c8cd3430486f27f7fa237dac2c317e" translate="yes" xml:space="preserve">
          <source>The operation was aborted.</source>
          <target state="translated">작업이 중단되었습니다.</target>
        </trans-unit>
        <trans-unit id="49f5cc194e751beeec38ece70da1908e9a004e89" translate="yes" xml:space="preserve">
          <source>The operation was canceled.</source>
          <target state="translated">작업이 취소되었습니다.</target>
        </trans-unit>
        <trans-unit id="52c8d918f7103932d6fe19894fb46590e5801f0f" translate="yes" xml:space="preserve">
          <source>The operation was not supported by the service provider.</source>
          <target state="translated">서비스 제공자가 조작을 지원하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="fe5f5d3519c68333f8881a59fde8fab02ef4f0ab" translate="yes" xml:space="preserve">
          <source>The opposite of the accept(const &lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt;&amp;amp;) function. Moves within the</source>
          <target state="translated">accept (const &lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt; &amp;amp;) 기능 의 반대입니다 . 내에서 이동</target>
        </trans-unit>
        <trans-unit id="82c396815c9508c77b53a85b40cd95877c031fad" translate="yes" xml:space="preserve">
          <source>The optimization hint for rendering.</source>
          <target state="translated">렌더링을위한 최적화 힌트.</target>
        </trans-unit>
        <trans-unit id="00d061c2f717d644793ed7614d8f2f71c412bf7b" translate="yes" xml:space="preserve">
          <source>The option will always be understood as a short option, regardless of what was set by &lt;a href=&quot;qcommandlineparser#setSingleDashWordOptionMode&quot;&gt;QCommandLineParser::setSingleDashWordOptionMode&lt;/a&gt;. This allows flags such as &lt;code&gt;-DDEFINE=VALUE&lt;/code&gt; or &lt;code&gt;-I/include/path&lt;/code&gt; to be interpreted as short flags even when the parser is in &lt;a href=&quot;qcommandlineparser#SingleDashWordOptionMode-enum&quot;&gt;QCommandLineParser::ParseAsLongOptions&lt;/a&gt; mode.</source>
          <target state="translated">이 옵션은 &lt;a href=&quot;qcommandlineparser#setSingleDashWordOptionMode&quot;&gt;QCommandLineParser :: setSingleDashWordOptionMode에&lt;/a&gt; 의해 설정된 내용에 관계없이 항상 짧은 옵션으로 이해됩니다 . 이는 구문 분석기가 &lt;a href=&quot;qcommandlineparser#SingleDashWordOptionMode-enum&quot;&gt;QCommandLineParser :: ParseAsLongOptions&lt;/a&gt; 모드에 있는 경우에도 &lt;code&gt;-DDEFINE=VALUE&lt;/code&gt; 또는 &lt;code&gt;-I/include/path&lt;/code&gt; 와 같은 플래그를 짧은 플래그로 해석 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="18b9f1ce4c729b2ded7edcf5db48cd7ab36a842d" translate="yes" xml:space="preserve">
          <source>The optional</source>
          <target state="translated">옵션</target>
        </trans-unit>
        <trans-unit id="bbd02b07622c25d39cc528c6ebf177ad64b7026f" translate="yes" xml:space="preserve">
          <source>The optional auto-generation of a suitably filled .rc file by qmake is triggered by setting at least one of the system variables &lt;a href=&quot;qmake-variable-reference#version&quot;&gt;VERSION&lt;/a&gt; and &lt;a href=&quot;qmake-variable-reference#rc-icons&quot;&gt;RC_ICONS&lt;/a&gt;. The generated .rc file is automatically compiled and linked. Elements that are added to the .rc file are defined by the system variables &lt;a href=&quot;qmake-variable-reference#qmake-target-company&quot;&gt;QMAKE_TARGET_COMPANY&lt;/a&gt;, &lt;a href=&quot;qmake-variable-reference#qmake-target-description&quot;&gt;QMAKE_TARGET_DESCRIPTION&lt;/a&gt;, &lt;a href=&quot;qmake-variable-reference#qmake-target-copyright&quot;&gt;QMAKE_TARGET_COPYRIGHT&lt;/a&gt;, &lt;a href=&quot;qmake-variable-reference#qmake-target-product&quot;&gt;QMAKE_TARGET_PRODUCT&lt;/a&gt;, &lt;a href=&quot;qmake-variable-reference#qmake-manifest&quot;&gt;QMAKE_MANIFEST&lt;/a&gt;, &lt;a href=&quot;qmake-variable-reference#rc-codepage&quot;&gt;RC_CODEPAGE&lt;/a&gt;, &lt;a href=&quot;qmake-variable-reference#rc-icons&quot;&gt;RC_ICONS&lt;/a&gt;, &lt;a href=&quot;qmake-variable-reference#rc-lang&quot;&gt;RC_LANG&lt;/a&gt; and &lt;a href=&quot;qmake-variable-reference#version&quot;&gt;VERSION&lt;/a&gt;.</source>
          <target state="translated">qmake에 의해 적절하게 채워진 .rc 파일의 선택적 자동 생성은 시스템 변수 &lt;a href=&quot;qmake-variable-reference#version&quot;&gt;VERSION&lt;/a&gt; 및 &lt;a href=&quot;qmake-variable-reference#rc-icons&quot;&gt;RC_ICONS&lt;/a&gt; 중 하나 이상을 설정하여 트리거됩니다 . 생성 된 .rc 파일은 자동으로 컴파일되고 링크됩니다. .rc 파일에 추가되는 요소는 시스템 변수 &lt;a href=&quot;qmake-variable-reference#qmake-target-company&quot;&gt;QMAKE_TARGET_COMPANY&lt;/a&gt; , &lt;a href=&quot;qmake-variable-reference#qmake-target-description&quot;&gt;QMAKE_TARGET_DESCRIPTION&lt;/a&gt; , &lt;a href=&quot;qmake-variable-reference#qmake-target-copyright&quot;&gt;QMAKE_TARGET_COPYRIGHT&lt;/a&gt; , &lt;a href=&quot;qmake-variable-reference#qmake-target-product&quot;&gt;QMAKE_TARGET_PRODUCT&lt;/a&gt; , &lt;a href=&quot;qmake-variable-reference#qmake-manifest&quot;&gt;QMAKE_MANIFEST&lt;/a&gt; , &lt;a href=&quot;qmake-variable-reference#rc-codepage&quot;&gt;RC_CODEPAGE&lt;/a&gt; , &lt;a href=&quot;qmake-variable-reference#rc-icons&quot;&gt;RC_ICONS&lt;/a&gt; , &lt;a href=&quot;qmake-variable-reference#rc-lang&quot;&gt;RC_LANG&lt;/a&gt; 및 &lt;a href=&quot;qmake-variable-reference#version&quot;&gt;VERSION으로 정의&lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="9b1b5c859cd0bd2a446d225f410e3233051dbced" translate="yes" xml:space="preserve">
          <source>The optional auto-generation of a suitably filled .rc file by qmake is triggered by setting at least one of the system variables &lt;a href=&quot;qmake-variable-reference#version&quot;&gt;VERSION&lt;/a&gt; and &lt;a href=&quot;qmake-variable-reference#rc-icons&quot;&gt;RC_ICONS&lt;/a&gt;. The generated .rc file is automatically compiled and linked. Elements that are added to the .rc file are defined by the system variables &lt;a href=&quot;qmake-variable-reference#qmake-target-company&quot;&gt;QMAKE_TARGET_COMPANY&lt;/a&gt;, &lt;a href=&quot;qmake-variable-reference#qmake-target-description&quot;&gt;QMAKE_TARGET_DESCRIPTION&lt;/a&gt;, &lt;a href=&quot;qmake-variable-reference#qmake-target-copyright&quot;&gt;QMAKE_TARGET_COPYRIGHT&lt;/a&gt;, &lt;a href=&quot;qmake-variable-reference#qmake-target-product&quot;&gt;QMAKE_TARGET_PRODUCT&lt;/a&gt;, &lt;a href=&quot;qmake-variable-reference#rc-codepage&quot;&gt;RC_CODEPAGE&lt;/a&gt;, &lt;a href=&quot;qmake-variable-reference#rc-icons&quot;&gt;RC_ICONS&lt;/a&gt;, &lt;a href=&quot;qmake-variable-reference#rc-lang&quot;&gt;RC_LANG&lt;/a&gt;,and &lt;a href=&quot;qmake-variable-reference#version&quot;&gt;VERSION&lt;/a&gt;.</source>
          <target state="translated">qmake에 의해 적절히 채워진 .rc 파일의 선택적 자동 생성은 시스템 변수 &lt;a href=&quot;qmake-variable-reference#version&quot;&gt;VERSION&lt;/a&gt; 및 &lt;a href=&quot;qmake-variable-reference#rc-icons&quot;&gt;RC_ICONS&lt;/a&gt; 중 하나 이상을 설정하여 트리거됩니다 . 생성 된 .rc 파일은 자동으로 컴파일 및 링크됩니다. .rc 파일에 추가 된 요소는 시스템 변수 &lt;a href=&quot;qmake-variable-reference#qmake-target-company&quot;&gt;QMAKE_TARGET_COMPANY&lt;/a&gt; , &lt;a href=&quot;qmake-variable-reference#qmake-target-description&quot;&gt;QMAKE_TARGET_DESCRIPTION&lt;/a&gt; , &lt;a href=&quot;qmake-variable-reference#qmake-target-copyright&quot;&gt;QMAKE_TARGET_COPYRIGHT&lt;/a&gt; , &lt;a href=&quot;qmake-variable-reference#qmake-target-product&quot;&gt;QMAKE_TARGET_PRODUCT&lt;/a&gt; , &lt;a href=&quot;qmake-variable-reference#rc-codepage&quot;&gt;RC_CODEPAGE&lt;/a&gt; , &lt;a href=&quot;qmake-variable-reference#rc-icons&quot;&gt;RC_ICONS&lt;/a&gt; , &lt;a href=&quot;qmake-variable-reference#rc-lang&quot;&gt;RC_LANG&lt;/a&gt; 및 &lt;a href=&quot;qmake-variable-reference#version&quot;&gt;VERSION에&lt;/a&gt; 의해 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="6de11b1c20367813dc279fe6f70db20e1c61c2a3" translate="yes" xml:space="preserve">
          <source>The optional check box of a group box.</source>
          <target state="translated">그룹 상자의 선택적 확인란입니다.</target>
        </trans-unit>
        <trans-unit id="9c2ea53f9f5ca1598eeddae6cd754cedc0ea1d51" translate="yes" xml:space="preserve">
          <source>The optional column labels for the array. Indexes in this array match column indexes in rows. If the list is shorter than the longest row, all columns will not get labels.</source>
          <target state="translated">배열의 선택적 열 레이블입니다. 이 배열의 인덱스는 행의 열 인덱스와 일치합니다. 목록이 가장 긴 행보다 짧은 경우 모든 열에 레이블이 없습니다.</target>
        </trans-unit>
        <trans-unit id="a284d0e801940972e80fcde3e193b00a4ff4bd36" translate="yes" xml:space="preserve">
          <source>The optional row labels for the array. Indexes in this array match the row indexes in the data array. If the list is shorter than the number of rows, all rows will not get labels.</source>
          <target state="translated">배열의 선택적 행 레이블. 이 배열의 인덱스는 데이터 배열의 행 인덱스와 일치합니다. 목록이 행 수보다 짧은 경우 모든 행에 레이블이 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ebee28756dc591194532cc3e7139de85f3122e7a" translate="yes" xml:space="preserve">
          <source>The options currently supported are the following:</source>
          <target state="translated">현재 지원되는 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6fd531dd72c16da72cf2ec0eaaa9b173ee846b50" translate="yes" xml:space="preserve">
          <source>The options from &lt;a href=&quot;qurl#ComponentFormattingOption-enum&quot;&gt;QUrl::ComponentFormattingOptions&lt;/a&gt; are also possible.</source>
          <target state="translated">&lt;a href=&quot;qurl#ComponentFormattingOption-enum&quot;&gt;QUrl :: ComponentFormattingOptions&lt;/a&gt; 의 옵션 도 가능합니다.</target>
        </trans-unit>
        <trans-unit id="b599705693aff386f339e097a22afa2e356d42b0" translate="yes" xml:space="preserve">
          <source>The options marked &quot;(default)&quot; are set if no other values from the list are included (since the defaults are zero):</source>
          <target state="translated">&quot;(기본값)&quot;으로 표시된 옵션은 목록의 다른 값이 포함되지 않은 경우 설정됩니다 (기본값은 0이므로).</target>
        </trans-unit>
        <trans-unit id="a4bd6349a1596e35a193c9a1f09784768190662c" translate="yes" xml:space="preserve">
          <source>The order in which the three threads are woken up is undefined. Also, if some of the threads are still in &lt;code&gt;do_something()&lt;/code&gt; when the key is pressed, they won't be woken up (since they're not waiting on the condition variable) and so the task will not be performed for that key press. This issue can be solved using a counter and a &lt;a href=&quot;qmutex&quot;&gt;QMutex&lt;/a&gt; to guard it. For example, here's the new code for the worker threads:</source>
          <target state="translated">세 개의 스레드가 깨어 난 순서는 정의되어 있지 않습니다. 또한 키를 누를 때 일부 스레드가 여전히 &lt;code&gt;do_something()&lt;/code&gt; 있으면 스레드가 깨어나지 않으므로 (조건 변수를 기다리지 않기 때문에) 해당 키 누름에 대한 작업이 수행되지 않습니다. . 이 문제는 카운터와 &lt;a href=&quot;qmutex&quot;&gt;QMutex&lt;/a&gt; 를 사용하여 해결할 수 있습니다 . 예를 들어 작업자 스레드의 새 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0312a5ad292da8b9cd50e12fe74655eb122b8270" translate="yes" xml:space="preserve">
          <source>The order is as follows:</source>
          <target state="translated">순서는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b80f02ee270b8f51aafc4021e911ed0f89c29b8c" translate="yes" xml:space="preserve">
          <source>The order is guaranteed to be the same as that used by &lt;a href=&quot;qhash#keys&quot;&gt;keys&lt;/a&gt;().</source>
          <target state="translated">순서는 &lt;a href=&quot;qhash#keys&quot;&gt;키&lt;/a&gt; () 가 사용하는 순서와 동일해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f594036127c47f9b2fbbeb407faf34c2cf24403e" translate="yes" xml:space="preserve">
          <source>The order is guaranteed to be the same as that used by &lt;a href=&quot;qhash#values&quot;&gt;values&lt;/a&gt;().</source>
          <target state="translated">순서는 &lt;a href=&quot;qhash#values&quot;&gt;값&lt;/a&gt; ()에서 사용 된 순서와 동일해야합니다 .</target>
        </trans-unit>
        <trans-unit id="fb65df26b27d4b6bfdda0e0f568d80c0a453f9e9" translate="yes" xml:space="preserve">
          <source>The order is guaranteed to be the same as that used by &lt;a href=&quot;qmap#values&quot;&gt;values&lt;/a&gt;().</source>
          <target state="translated">순서는 &lt;a href=&quot;qmap#values&quot;&gt;값&lt;/a&gt; ()에서 사용 된 순서와 동일해야합니다 .</target>
        </trans-unit>
        <trans-unit id="27b598de660e791cc1904ad689999e7145bc95e2" translate="yes" xml:space="preserve">
          <source>The order of elements in the array is not relevant. Outputs with unspecified virtual indices are placed after the others, with the original order in the DRM connector list preserved.</source>
          <target state="translated">배열의 요소 순서는 관련이 없습니다. 지정되지 않은 가상 인덱스가있는 출력은 DRM 커넥터 목록의 원래 순서가 유지 된 상태로 다른 것 뒤에 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="ee7d1e6803b691d6187a2a92328736d444fc57b3" translate="yes" xml:space="preserve">
          <source>The order of elements in the array is not relevant. Outputs with unspecified virtual indices will be placed after the others, with the original order in the DRM connector list preserved.</source>
          <target state="translated">배열의 요소 순서는 관련이 없습니다. 지정되지 않은 가상 인덱스가있는 출력은 DRM 커넥터 목록의 원래 순서가 유지 된 상태로 다른 인덱스 뒤에 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="36c0783770d2606eadbcab10c23e2a554e28050f" translate="yes" xml:space="preserve">
          <source>The order of elements in the string list is as follows. The first element is the entire matching string. Each subsequent element corresponds to the next capturing open left parentheses. Thus capturedTexts()[1] is the text of the first capturing parentheses, capturedTexts()[2] is the text of the second and so on (corresponding to $1, $2, etc., in some other regexp languages).</source>
          <target state="translated">문자열리스트의 요소 순서는 다음과 같습니다. 첫 번째 요소는 전체 일치 문자열입니다. 각 후속 요소는 다음 캡처 된 열린 왼쪽 괄호에 해당합니다. 따라서 capturedTexts () [1]은 첫 번째 캡처 괄호의 텍스트이고 capturedTexts () [2]는 두 번째 등의 텍스트입니다 (일부 다른 정규식 언어의 경우 $ 1, $ 2 등에 해당).</target>
        </trans-unit>
        <trans-unit id="b3c6a6265e7bc2491361e04c6fed8fe2f7be8150" translate="yes" xml:space="preserve">
          <source>The order of elements matched by cap() is as follows. The first element, cap(0), is the entire matching string. Each subsequent element corresponds to the next capturing open left parentheses. Thus cap(1) is the text of the first capturing parentheses, cap(2) is the text of the second, and so on.</source>
          <target state="translated">cap ()과 일치하는 요소의 순서는 다음과 같습니다. 첫 번째 요소 인 cap (0)은 전체 일치 문자열입니다. 각 후속 요소는 다음 캡처 된 열린 왼쪽 괄호에 해당합니다. 따라서 cap (1)은 첫 번째 캡처 괄호의 텍스트이고, cap (2)는 두 번째 텍스트입니다.</target>
        </trans-unit>
        <trans-unit id="473ac21de70831732dc9c0261c986382ed098a3d" translate="yes" xml:space="preserve">
          <source>The order of evaluation is as follows:</source>
          <target state="translated">The order of evaluation is as follows:</target>
        </trans-unit>
        <trans-unit id="fa93e0ec1c268a32fe62720345e9be2ee8c9cf9b" translate="yes" xml:space="preserve">
          <source>The order of events in this interface is very important, and mirrors the order of information in the document itself. For example, all of an element's content (character data, processing instructions, and sub-elements) appears, in order, between the &lt;a href=&quot;qxmlcontenthandler#startElement&quot;&gt;startElement&lt;/a&gt;() event and the corresponding &lt;a href=&quot;qxmlcontenthandler#endElement&quot;&gt;endElement&lt;/a&gt;() event.</source>
          <target state="translated">이 인터페이스의 이벤트 순서는 매우 중요하며 문서 자체의 정보 순서를 반영합니다. 예를 들어 &lt;a href=&quot;qxmlcontenthandler#startElement&quot;&gt;startElement&lt;/a&gt; () 이벤트와 해당 &lt;a href=&quot;qxmlcontenthandler#endElement&quot;&gt;endElement&lt;/a&gt; () 이벤트 사이에 요소의 모든 내용 (문자 데이터, 처리 명령 및 하위 요소)이 순서대로 나타납니다 .</target>
        </trans-unit>
        <trans-unit id="f4e0b3f6a8ac779350b2e32b538cd004f314ae75" translate="yes" xml:space="preserve">
          <source>The order of the aliases in the list is undefined.</source>
          <target state="translated">목록에서 별칭의 순서는 정의되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5761e91a48c25ce665a3165fba329cb492424df7" translate="yes" xml:space="preserve">
          <source>The order of the key-value pairs in the returned string is exactly the same as in the original query.</source>
          <target state="translated">반환 된 문자열에서 키-값 쌍의 순서는 원래 쿼리와 정확히 동일합니다.</target>
        </trans-unit>
        <trans-unit id="b39cd913537aa8420dc48f04c8b4830a3fe07ece" translate="yes" xml:space="preserve">
          <source>The order of the positions within a line starts at the top of a vertical line, and from the left within a horizontal line. The order of the positions for the lines is always from the parent widget's boundary edges.</source>
          <target state="translated">라인 내 위치의 순서는 수직선의 상단에서 시작하여 수평선의 왼쪽에서 시작합니다. 선의 위치 순서는 항상 부모 위젯의 경계 가장자리에서 나옵니다.</target>
        </trans-unit>
        <trans-unit id="640f9f4b44e38703fa036394e287a4cd79beac98" translate="yes" xml:space="preserve">
          <source>The organization responsible for the parental rating of the media.</source>
          <target state="translated">미디어의 부모 등급을 담당하는 조직입니다.</target>
        </trans-unit>
        <trans-unit id="550a8358452ff77cca132f5f43f21b34d325239d" translate="yes" xml:space="preserve">
          <source>The orientation change will also affect the mapping of coordinates from source to viewport.</source>
          <target state="translated">방향 변경은 소스에서 뷰포트로의 좌표 매핑에도 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="483e501d1c57b65bc1c79b72475dc19ae2427a0b" translate="yes" xml:space="preserve">
          <source>The orientation determines how the split items are laid out:</source>
          <target state="translated">방향은 분할 항목을 배치하는 방법을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="f829661de50b7dbf1216aecc9cf305a209f994d0" translate="yes" xml:space="preserve">
          <source>The orientation is mirrored, and rotated 180 degrees. *</source>
          <target state="translated">방향이 대칭되고 180도 회전합니다. *</target>
        </trans-unit>
        <trans-unit id="7d85c633c6477d41c4061af1b2d2e2b5e17de46c" translate="yes" xml:space="preserve">
          <source>The orientation is mirrored, and rotated 270 degrees. * *</source>
          <target state="translated">방향이 대칭되고 270도 회전합니다. * *</target>
        </trans-unit>
        <trans-unit id="ca5de3a9500b83a97c1a985762175b34ae622932" translate="yes" xml:space="preserve">
          <source>The orientation is mirrored, and rotated 90 degrees. *</source>
          <target state="translated">방향이 대칭되고 90도 회전합니다. *</target>
        </trans-unit>
        <trans-unit id="bb304c17acc555066fda750ed2aa71c061808e94" translate="yes" xml:space="preserve">
          <source>The orientation is mirrored. *</source>
          <target state="translated">방향이 미러링됩니다. *</target>
        </trans-unit>
        <trans-unit id="c2dee3f86a8c6b76765c0e9f72eafc4936b5605e" translate="yes" xml:space="preserve">
          <source>The orientation is normal. *</source>
          <target state="translated">방향이 정상입니다. *</target>
        </trans-unit>
        <trans-unit id="815104d1f948d82ec04b2ba54b5f8966564847fd" translate="yes" xml:space="preserve">
          <source>The orientation is rotated 180 degrees. *</source>
          <target state="translated">방향이 180도 회전합니다. *</target>
        </trans-unit>
        <trans-unit id="0ab2e060366e633486ebd85908f0e91845f1db92" translate="yes" xml:space="preserve">
          <source>The orientation is rotated 270 degrees. *</source>
          <target state="translated">방향이 270도 회전합니다. *</target>
        </trans-unit>
        <trans-unit id="85d787519322ec1221db321c389f7bee6046a7f5" translate="yes" xml:space="preserve">
          <source>The orientation is rotated 90 degrees. *</source>
          <target state="translated">방향이 90도 회전합니다. *</target>
        </trans-unit>
        <trans-unit id="c25b4814774f5f29e50624ceabb719d7b77729fd" translate="yes" xml:space="preserve">
          <source>The orientation is unknown.</source>
          <target state="translated">방향을 알 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3e585b64b832dcc211c1dc19ec4d8e4ff5ed1dd7" translate="yes" xml:space="preserve">
          <source>The orientation must be &lt;a href=&quot;qt#Orientation-enum&quot;&gt;Qt::Horizontal&lt;/a&gt; (the default) or &lt;a href=&quot;qt#Orientation-enum&quot;&gt;Qt::Vertical&lt;/a&gt;.</source>
          <target state="translated">방향은 &lt;a href=&quot;qt#Orientation-enum&quot;&gt;Qt :: Horizontal&lt;/a&gt; (기본값) 또는 &lt;a href=&quot;qt#Orientation-enum&quot;&gt;Qt :: Vertical&lt;/a&gt; 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="c010ed543937356233f98d7c731c765480465981" translate="yes" xml:space="preserve">
          <source>The orientation must be &lt;a href=&quot;qt#Orientation-enum&quot;&gt;Qt::Vertical&lt;/a&gt; (the default) or &lt;a href=&quot;qt#Orientation-enum&quot;&gt;Qt::Horizontal&lt;/a&gt;.</source>
          <target state="translated">방향은 &lt;a href=&quot;qt#Orientation-enum&quot;&gt;Qt :: Vertical&lt;/a&gt; (기본값) 또는 &lt;a href=&quot;qt#Orientation-enum&quot;&gt;Qt :: Horizontal&lt;/a&gt; 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="e9eede37764cb066b5377856e87f241b03c46309" translate="yes" xml:space="preserve">
          <source>The orientation of the &lt;code&gt;Video&lt;/code&gt; in degrees. Only multiples of 90 degrees is supported, that is 0, 90, 180, 270, 360, etc.</source>
          <target state="translated">&lt;code&gt;Video&lt;/code&gt; 의 방향 ( 도)입니다. 90 도의 배수, 즉 0, 90, 180, 270, 360 등 만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="9030d6b86a75cda6510254ab4662e15f41392d25" translate="yes" xml:space="preserve">
          <source>The orientation of the axis object.</source>
          <target state="translated">축 객체의 방향입니다.</target>
        </trans-unit>
        <trans-unit id="3bc9410033f892506b697119437fd1e03b7efb62" translate="yes" xml:space="preserve">
          <source>The orientation of the axis.</source>
          <target state="translated">축의 방향입니다.</target>
        </trans-unit>
        <trans-unit id="99ac394ab65b5a7fd30b7cff7dbae89320a47f86" translate="yes" xml:space="preserve">
          <source>The orientation of the axis. Fixed to either &lt;a href=&quot;qt#Orientation-enum&quot;&gt;Qt.Horizontal&lt;/a&gt; or &lt;a href=&quot;qt#Orientation-enum&quot;&gt;Qt.Vertical&lt;/a&gt; when the axis is set to a series.</source>
          <target state="translated">축의 방향입니다. 축이 시리즈로 설정된 경우 &lt;a href=&quot;qt#Orientation-enum&quot;&gt;Qt.Horizontal&lt;/a&gt; 또는 &lt;a href=&quot;qt#Orientation-enum&quot;&gt;Qt.Vertical로&lt;/a&gt; 고정됩니다 .</target>
        </trans-unit>
        <trans-unit id="d8f89e6ead264079497177470d9881ddd6e5acd8" translate="yes" xml:space="preserve">
          <source>The orientation sensor reports the orientation of the device. As it operates below the UI level it does not report on or even know how the UI is rotated. Most importantly this means that this sensor cannot be used to detect if a device is in portrait or landscape mode.</source>
          <target state="translated">방향 센서는 장치의 방향을보고합니다. UI 수준 아래에서 작동하므로 UI가 회전하는 방식을보고하거나 알지 못합니다. 가장 중요한 것은 장치가 세로 또는 가로 모드인지 여부를 감지하는 데이 센서를 사용할 수 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="8b94530b04cf01ec1b52299c9e982cffda4b2636" translate="yes" xml:space="preserve">
          <source>The orientation sensor returns the orientation of the device using the pre-defined values found in the &lt;a href=&quot;qorientationreading#Orientation-enum&quot;&gt;QOrientationReading::Orientation&lt;/a&gt; enum.</source>
          <target state="translated">방향 센서는 &lt;a href=&quot;qorientationreading#Orientation-enum&quot;&gt;QOrientationReading :: Orientation&lt;/a&gt; 열거 형 에있는 사전 정의 된 값을 사용하여 장치의 방향을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="350e595ee942f7a45758a4f3936251a64fdaf565" translate="yes" xml:space="preserve">
          <source>The orientation setting does not affect this rectangle.</source>
          <target state="translated">방향 설정은이 사각형에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="58c8ad3268b8190b195a9cd43899b9fb7bbecc6b" translate="yes" xml:space="preserve">
          <source>The orientation values here are always of the screen orientation, not the device orientation. The screen orientation is the orientation of the GUI. For example when rotating a device by 90 degrees counter-clockwise, the screen orientation compensates for that by rotating 90 degrees clockwise, to the effect that the GUI is still facing upright after the device has been rotated. Note that applications can lock the screen orientation, for example to force portrait or landscape mode. For locked orientations, orientable sensors will not react with reading changes if the device orientation is changed, as orientable sensors react to screen orientation changes only. This makes sense, as the purpose of orientable sensors is to keep the sensor orientation in sync with the screen orientation.</source>
          <target state="translated">여기의 방향 값은 항상 장치 방향이 아니라 화면 방향입니다. 화면 방향은 GUI의 방향입니다. 예를 들어 장치를 시계 반대 방향으로 90도 회전 할 때 화면 방향은 장치를 회전 한 후 GUI가 여전히 똑바로 향하는 효과를 위해 시계 방향으로 90도 회전하여이를 보정합니다. 응용 프로그램은 화면 방향을 잠글 수 있습니다 (예 : 세로 또는 가로 모드). 방향이 잠겨있는 경우 방향 센서는 화면 방향 변경에만 반응하므로 장치 방향이 변경되면 방향 센서가 판독 변경에 반응하지 않습니다. 오리 엔터 블 센서의 목적은 센서 방향을 화면 방향과 동기화하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a7b3beeafac2388893c9e8fd291c0535b08badc1" translate="yes" xml:space="preserve">
          <source>The orientation values range from 0 to 270 degrees. The orientation is applied in clockwise direction, e.g. an orientation value of 90 degrees means that the screen has been rotated 90 degress to the right from its origin position, to compensate a device rotation of 90 degrees to the left.</source>
          <target state="translated">방향 값의 범위는 0에서 270 도입니다. 방향은 시계 방향으로 적용됩니다. 예를 들어 90 도의 방향 값은 화면이 원래 위치에서 오른쪽으로 90도 회전하여 왼쪽으로 90도 회전하는 장치를 보정합니다.</target>
        </trans-unit>
        <trans-unit id="cbdda422aa28d1a169072a0cfac072df812ad68e" translate="yes" xml:space="preserve">
          <source>The orientations are shown here in order: TopUp, TopDown, LeftUp, RightUp, FaceUp, FaceDown.</source>
          <target state="translated">방향은 TopUp, TopDown, LeftUp, RightUp, FaceUp, FaceDown 순서로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="552762f271645b86100bff2fc673ee72a505b836" translate="yes" xml:space="preserve">
          <source>The origin is equivalent to the</source>
          <target state="translated">원점은</target>
        </trans-unit>
        <trans-unit id="e8ff3d7bb06d09c6ab66be19a03bf8f722db3900" translate="yes" xml:space="preserve">
          <source>The origin is the bottom left corner of the buffer.</source>
          <target state="translated">원점은 버퍼의 왼쪽 아래 모서리입니다.</target>
        </trans-unit>
        <trans-unit id="f28fc24938f47ea52e954ba4434519161c2c41bc" translate="yes" xml:space="preserve">
          <source>The origin is the point that the item is rotated around (i.e., it stays fixed relative to the parent as the rest of the item is rotated). By default the origin is &lt;a href=&quot;qpointf&quot;&gt;QPointF&lt;/a&gt;(0, 0).</source>
          <target state="translated">원점은 항목이 회전하는 지점입니다 (즉, 항목의 나머지 부분이 회전함에 따라 부모에 대해 고정 된 상태로 유지됨). 기본적으로 원점은 &lt;a href=&quot;qpointf&quot;&gt;QPointF&lt;/a&gt; (0, 0)입니다.</target>
        </trans-unit>
        <trans-unit id="12177e2e37bc9ab6d9d19f6683a400890adad62f" translate="yes" xml:space="preserve">
          <source>The origin is the point that the item is scaled from (i.e., it stays fixed relative to the parent as the rest of the item grows). By default the origin is &lt;a href=&quot;qpointf&quot;&gt;QPointF&lt;/a&gt;(0, 0).</source>
          <target state="translated">원점은 항목의 크기가 조정되는 지점입니다 (즉, 항목의 나머지 부분이 커질 때 부모에 대해 고정 된 상태로 유지됨). 기본적으로 원점은 &lt;a href=&quot;qpointf&quot;&gt;QPointF&lt;/a&gt; (0, 0)입니다.</target>
        </trans-unit>
        <trans-unit id="1cc4d612b237ee9db38cf57af035e9505666094f" translate="yes" xml:space="preserve">
          <source>The origin is the top left corner of the buffer.</source>
          <target state="translated">원점은 버퍼의 왼쪽 상단입니다.</target>
        </trans-unit>
        <trans-unit id="cc5eda91e7cff5355c7558f96a8c1b3889484e3d" translate="yes" xml:space="preserve">
          <source>The origin of the content of a plain text edit is always the top left corner of the first visible text block. The content offset is different from (0,0) when the text has been scrolled horizontally, or when the first visible block has been scrolled partially off the screen, i.e. the visible text does not start with the first line of the first visible block, or when the first visible block is the very first block and the editor displays a margin.</source>
          <target state="translated">일반 텍스트 편집 내용의 원점은 항상 첫 번째 보이는 텍스트 블록의 왼쪽 상단입니다. 텍스트가 가로로 스크롤되었거나 첫 번째 표시 블록이 화면에서 부분적으로 스크롤 된 경우 (즉, 표시 텍스트가 첫 번째 표시 블록의 첫 번째 줄로 시작하지 않는 경우) 컨텐츠 오프셋은 (0,0)과 다릅니다. 또는 첫 번째 보이는 블록이 첫 번째 블록 인 경우 편집기에 여백이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="79193ef789f1503c76389f0777dbb682938fdee0" translate="yes" xml:space="preserve">
          <source>The origin point of the rotation (i.e., the point that stays fixed relative to the parent as the rest of the item rotates). By default the origin is (0, 0).</source>
          <target state="translated">회전의 원점 (즉, 항목의 나머지 부분이 회전함에 따라 부모에 대해 고정 된 점) 기본적으로 원점은 (0, 0)입니다.</target>
        </trans-unit>
        <trans-unit id="31be72acad16867360baf78e0b008f39c853b62e" translate="yes" xml:space="preserve">
          <source>The origin rectangle of the subcontrol within the parent element.</source>
          <target state="translated">부모 요소 내 하위 컨트롤의 원점 사각형</target>
        </trans-unit>
        <trans-unit id="d4cf841e0eb0e78adf8a80af2a9157b0abfede68" translate="yes" xml:space="preserve">
          <source>The origin rectangle to be used can be changed using the &lt;a href=&quot;stylesheet-reference#subcontrol-origin-prop&quot;&gt;subcontrol-origin&lt;/a&gt; property. For example, if we want to place the drop-down in the margin rectangle of the &lt;a href=&quot;qcombobox&quot;&gt;QComboBox&lt;/a&gt; instead of the default Padding rectangle, we can specify:</source>
          <target state="translated">사용되는 원점 사각형은 &lt;a href=&quot;stylesheet-reference#subcontrol-origin-prop&quot;&gt;subcontrol-origin&lt;/a&gt; 속성을 사용하여 변경할 수 있습니다 . 예를 들어, 기본 패딩 사각형 대신 &lt;a href=&quot;qcombobox&quot;&gt;QComboBox&lt;/a&gt; 의 여백 사각형에 드롭 다운을 배치하려면 다음을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0df6a35f0f18c778205c627cabf329475bc150b" translate="yes" xml:space="preserve">
          <source>The origin type is equivalent to the</source>
          <target state="translated">원점 유형은</target>
        </trans-unit>
        <trans-unit id="85947cfc19b61a9c077c85fd29dd3e55e35b14fb" translate="yes" xml:space="preserve">
          <source>The original &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt; is not changed.</source>
          <target state="translated">원본 &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt; 는 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b2bc46b8b81dd99883bccf8893caf750ce6a566a" translate="yes" xml:space="preserve">
          <source>The original size of an image. A handler that supports this option is expected to read the size of the image from the image metadata, and return this size from &lt;a href=&quot;qimageiohandler#option&quot;&gt;option&lt;/a&gt;() as a &lt;a href=&quot;qsize&quot;&gt;QSize&lt;/a&gt;.</source>
          <target state="translated">이미지의 원래 크기입니다. 이 옵션을 지원하는 핸들러는 이미지 메타 데이터에서 이미지의 크기를 읽고 &lt;a href=&quot;qimageiohandler#option&quot;&gt;option&lt;/a&gt; () 에서이 크기를 &lt;a href=&quot;qsize&quot;&gt;QSize&lt;/a&gt; 로 반환해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f20cdda60b712b960bea57724a802695ec7a5e92" translate="yes" xml:space="preserve">
          <source>The other alternative is to create a &lt;a href=&quot;qquickframebufferobject&quot;&gt;QQuickFramebufferObject&lt;/a&gt;, render into it, and let it be displayed in the scene graph as a texture. The &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtquick-scenegraph-textureinsgnode-example.html#&quot;&gt;Scene Graph - Rendering FBOs&lt;/a&gt; example shows how this can be done. It is also possible to combine multiple rendering contexts and multiple threads to create content to be displayed in the scene graph. The &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtquick-scenegraph-textureinthread-example.html#&quot;&gt;Scene Graph - Rendering FBOs in a thread&lt;/a&gt; examples show how this can be done.</source>
          <target state="translated">다른 대안은 &lt;a href=&quot;qquickframebufferobject&quot;&gt;QQuickFramebufferObject&lt;/a&gt; 를 생성하여 렌더링 한 다음 장면 그래프에 텍스처로 표시하는 것입니다. &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtquick-scenegraph-textureinsgnode-example.html#&quot;&gt;장면 그래프 - 렌더링 식 코멘트에&lt;/a&gt; 이 작업을 수행 할 수있는 방법을 예를 보여줍니다. 장면 렌더링에 표시 할 내용을 만들기 위해 여러 렌더링 컨텍스트와 여러 스레드를 결합 할 수도 있습니다. &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtquick-scenegraph-textureinthread-example.html#&quot;&gt;스레드&lt;/a&gt; 예제 의 장면 그래프-렌더링 FBO는 이를 수행하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="d2312e59e2947a1cb9a9d855be3626ef2a3839a6" translate="yes" xml:space="preserve">
          <source>The other alternative, only available for OpenGL currently, is to create a &lt;a href=&quot;qquickframebufferobject&quot;&gt;QQuickFramebufferObject&lt;/a&gt;, render into it, and let it be displayed in the scene graph as a texture. The &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtquick-scenegraph-fboitem-example.html&quot;&gt;Scene Graph - Rendering FBOs&lt;/a&gt; example shows how this can be done. It is also possible to combine multiple rendering contexts and multiple threads to create content to be displayed in the scene graph. The &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtquick-scenegraph-textureinthread-example.html&quot;&gt;Scene Graph - Rendering FBOs in a thread&lt;/a&gt; examples show how this can be done.</source>
          <target state="translated">현재 OpenGL에서만 사용할 수있는 다른 대안은 &lt;a href=&quot;qquickframebufferobject&quot;&gt;QQuickFramebufferObject&lt;/a&gt; 를 만들고 렌더링 한 다음 장면 그래프에 텍스처로 표시되도록하는 것입니다. &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtquick-scenegraph-fboitem-example.html&quot;&gt;장면 그래프 - 렌더링 식 코멘트에&lt;/a&gt; 이 작업을 수행 할 수있는 방법을 예를 보여줍니다. 여러 렌더링 컨텍스트와 여러 스레드를 결합하여 장면 그래프에 표시 할 콘텐츠를 만들 수도 있습니다. &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtquick-scenegraph-textureinthread-example.html&quot;&gt;장면 그래프 - 스레드에서 렌더링 식 코멘트&lt;/a&gt; 예는이 작업을 수행 할 수있는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="e51f904cb00d38d7ea81d436a59469a0ca283810" translate="yes" xml:space="preserve">
          <source>The other attributes of the current text block, e.g. the font and background color, are reset to default values.</source>
          <target state="translated">현재 텍스트 블록의 다른 속성 (예 : 글꼴 및 배경색)이 기본값으로 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="65afb0f43133ad8ae530f99a0728fbf737687bfa" translate="yes" xml:space="preserve">
          <source>The other common members for widgets are:</source>
          <target state="translated">위젯의 다른 공통 멤버는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4cb226792a3f1ab071320212f0b10098ed3cd829" translate="yes" xml:space="preserve">
          <source>The other frequently used positional function is &lt;a href=&quot;http://www.w3.org/TR/xpath-functions/#func-last&quot;&gt;last()&lt;/a&gt;, which returns the numeric position of the last item in the focus set. Stated another way, &lt;a href=&quot;http://www.w3.org/TR/xpath-functions/#func-last&quot;&gt;last()&lt;/a&gt; returns the size of the focus set. This query returns the last recipe in the cookbook:</source>
          <target state="translated">자주 사용되는 다른 위치 함수는 &lt;a href=&quot;http://www.w3.org/TR/xpath-functions/#func-last&quot;&gt;last ()&lt;/a&gt; 이며 포커스 세트에서 마지막 항목의 숫자 위치를 반환합니다. 다른 방법으로 말하면 &lt;a href=&quot;http://www.w3.org/TR/xpath-functions/#func-last&quot;&gt;last ()&lt;/a&gt; 는 포커스 세트의 크기를 반환합니다. 이 쿼리는 요리 책의 마지막 레시피를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="61e01fcd154f1dd855b0124ae23a446d85079a6a" translate="yes" xml:space="preserve">
          <source>The other functions must be overridden by all plugins, other than sourcePriority() which defaults to returning 0. Higher values of priority will be preferred to lower ones.</source>
          <target state="translated">다른 함수는 기본적으로 0을 리턴하는 sourcePriority () 이외의 모든 플러그인으로 대체되어야합니다. 우선 순위가 높은 값은 낮은 값보다 선호됩니다.</target>
        </trans-unit>
        <trans-unit id="2df90243d36f873303b0f6cd0f4b424c9fe222c6" translate="yes" xml:space="preserve">
          <source>The other functions should be overridden if the plugin supports the associated set of functionality.</source>
          <target state="translated">플러그인이 관련 기능 세트를 지원하는 경우 다른 기능을 대체해야합니다.</target>
        </trans-unit>
        <trans-unit id="7763b78d05d1eefcddd7f20efdd8133c69db51a4" translate="yes" xml:space="preserve">
          <source>The other kind of predicate evaluates to</source>
          <target state="translated">다른 종류의 술어는</target>
        </trans-unit>
        <trans-unit id="ac5268f7e556761426b7326dd26f79da30451f3d" translate="yes" xml:space="preserve">
          <source>The other major use of drag actions is when using a reference type such as text/uri-list, where the dragged data are actually references to files or objects.</source>
          <target state="translated">드래그 동작의 다른 주요 용도는 텍스트 / uri-list와 같은 참조 유형을 사용할 때입니다. 여기서 드래그 된 데이터는 실제로 파일이나 객체에 대한 참조입니다.</target>
        </trans-unit>
        <trans-unit id="e620a36a9b90671b0f29787721c5f62005d03f84" translate="yes" xml:space="preserve">
          <source>The other two examples from the &lt;a href=&quot;#wildcards-in-name-tests&quot;&gt;wildcard&lt;/a&gt; section can be rewritten the same way. Here is the &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt; that selects all the &lt;code&gt;name&lt;/code&gt; attributes, regardless of namespace:</source>
          <target state="translated">&lt;a href=&quot;#wildcards-in-name-tests&quot;&gt;와일드 카드&lt;/a&gt; 섹션 의 다른 두 예제 는 같은 방식으로 다시 작성할 수 있습니다. 네임 스페이스에 관계없이 모든 &lt;code&gt;name&lt;/code&gt; 속성 을 선택 하는 &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt; 는 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="9bbd6e6e585ef7b3c6acff6f98761c78273f337a" translate="yes" xml:space="preserve">
          <source>The other two examples from the &lt;a href=&quot;xquery-introduction#wildcards-in-name-tests&quot;&gt;wildcard&lt;/a&gt; section can be rewritten the same way. Here is the &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt; that selects all the &lt;code&gt;name&lt;/code&gt; attributes, regardless of namespace:</source>
          <target state="translated">&lt;a href=&quot;xquery-introduction#wildcards-in-name-tests&quot;&gt;와일드 카드&lt;/a&gt; 섹션 의 다른 두 예 는 동일한 방식으로 다시 작성할 수 있습니다. 다음은 네임 스페이스에 관계없이 모든 &lt;code&gt;name&lt;/code&gt; 속성 을 선택 하는 &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="6660fe3780c5ce7f8658ca3283dfd9a9f070275f" translate="yes" xml:space="preserve">
          <source>The other way to connect a signal to a slot is to use &lt;a href=&quot;qobject#connect&quot;&gt;QObject::connect&lt;/a&gt;() and the &lt;code&gt;SIGNAL&lt;/code&gt; and &lt;code&gt;SLOT&lt;/code&gt; macros. The rule about whether to include arguments or not in the &lt;code&gt;SIGNAL()&lt;/code&gt; and &lt;code&gt;SLOT()&lt;/code&gt; macros, if the arguments have default values, is that the signature passed to the &lt;code&gt;SIGNAL()&lt;/code&gt; macro must</source>
          <target state="translated">신호를 슬롯에 연결하는 다른 방법은 &lt;a href=&quot;qobject#connect&quot;&gt;QObject :: connect&lt;/a&gt; () 및 &lt;code&gt;SIGNAL&lt;/code&gt; 및 &lt;code&gt;SLOT&lt;/code&gt; 매크로를 사용하는 것입니다. 인수에 기본값이있는 경우 &lt;code&gt;SIGNAL()&lt;/code&gt; 및 &lt;code&gt;SLOT()&lt;/code&gt; 매크로에 인수를 포함할지 여부에 대한 규칙은 &lt;code&gt;SIGNAL()&lt;/code&gt; 매크로에 전달 된 서명이</target>
        </trans-unit>
        <trans-unit id="17024a0a556fab6f3b04fac32d97cb9a922a472b" translate="yes" xml:space="preserve">
          <source>The outer edges of the lines are extended to meet at an angle, and this area is filled.</source>
          <target state="translated">선의 바깥 쪽 가장자리가 비스듬히 연장되어이 영역이 채워집니다.</target>
        </trans-unit>
        <trans-unit id="c26e3e033748d0970d424f801a7c2aa2c33e844b" translate="yes" xml:space="preserve">
          <source>The outline drawn around the object's border.</source>
          <target state="translated">객체의 테두리 주위에 그려진 윤곽선.</target>
        </trans-unit>
        <trans-unit id="da857b01236c6d172c2f3a10c35f1a74e8478ca0" translate="yes" xml:space="preserve">
          <source>The outline of a shape can vary depending on the width and style of the pen used when drawing. If you want to include this outline in the item's shape, you can create a shape from the stroke using &lt;a href=&quot;qpainterpathstroker&quot;&gt;QPainterPathStroker&lt;/a&gt;.</source>
          <target state="translated">도형의 윤곽은 그릴 때 사용되는 펜의 너비와 스타일에 따라 달라질 수 있습니다. 이 윤곽선을 항목 모양에 포함하려면 &lt;a href=&quot;qpainterpathstroker&quot;&gt;QPainterPathStroker를&lt;/a&gt; 사용하여 획에서 모양을 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a9da77e9a4723ab4462ce113c38b60bf1ea24711" translate="yes" xml:space="preserve">
          <source>The outline's offset from the border of the widget.</source>
          <target state="translated">위젯 테두리에서 아웃 라인의 오프셋입니다.</target>
        </trans-unit>
        <trans-unit id="867629a898a798615a5d5835de5c8b8ec45ac6a5" translate="yes" xml:space="preserve">
          <source>The outlines generated by Qt's stroker are only an approximation when dealing with curved shapes. It is in most cases impossible to represent the outline of a bezier curve segment using another bezier curve segment, and so Qt approximates the curve outlines by using several smaller curves. For performance reasons there is a limit to how many curves Qt uses for these outlines, and thus when using large pen widths or scales the outline error increases. To generate outlines with smaller errors it is possible to use the &lt;a href=&quot;qpainterpathstroker&quot;&gt;QPainterPathStroker&lt;/a&gt; class, which has the setCurveThreshold member function which let's the user specify the error tolerance. Another workaround is to convert the paths to polygons first and then draw the polygons instead.</source>
          <target state="translated">Qt의 스트로크에 의해 생성 된 윤곽은 곡선 모양을 다룰 때의 근사치 일뿐입니다. 대부분의 경우 다른 베 지어 곡선 세그먼트를 사용하여 베 지어 곡선 세그먼트의 윤곽선을 나타내는 것은 불가능하므로 Qt는 여러 개의 작은 곡선을 사용하여 곡선 윤곽선에 근접합니다. 성능상의 이유로 Qt가 이러한 윤곽선에 사용하는 곡선 수에는 제한이 있으므로 큰 펜 너비 또는 축척을 사용할 때 윤곽선 오류가 증가합니다. 더 작은 오류가있는 아웃 라인을 생성하기 위해 사용자가 오류 허용 오차를 지정할 수있는 setCurveThreshold 멤버 함수가있는 &lt;a href=&quot;qpainterpathstroker&quot;&gt;QPainterPathStroker&lt;/a&gt; 클래스 를 사용할 수 있습니다 . 다른 해결 방법은 경로를 먼저 다각형으로 변환 한 다음 대신 다각형을 그리는 것입니다.</target>
        </trans-unit>
        <trans-unit id="55cb474d8bd6cf01398254f86a8d909be7406374" translate="yes" xml:space="preserve">
          <source>The output contains one &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; element for each &lt;code&gt;xml:id&lt;/code&gt; attribute in the cookbook. Note that &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt; puts each attribute in the right place in its &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; element, despite the fact that in the</source>
          <target state="translated">출력에는 요리 책의 각 &lt;code&gt;xml:id&lt;/code&gt; 속성에 대해 하나의 &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; 요소 가 포함 됩니다. 참고 &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery를가&lt;/a&gt; 그 적절한 장소에 각 속성을두고 &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; 사실에도 불구하고, 요소의 해당</target>
        </trans-unit>
        <trans-unit id="bfd7f227d024c4ca96574c2818716e9c5deea964" translate="yes" xml:space="preserve">
          <source>The output contains one &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; element for each &lt;code&gt;xml:id&lt;/code&gt; attribute in the cookbook. Note that &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt; puts each attribute in the right place in its &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; element, despite the fact that in the</source>
          <target state="translated">출력 은 요리 책의 각 &lt;code&gt;xml:id&lt;/code&gt; 속성에 대해 하나의 &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; 요소를 포함 합니다. 참고 &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery를가&lt;/a&gt; 그 적절한 장소에 각 속성을두고 &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; 사실에도 불구하고, 요소의 해당</target>
        </trans-unit>
        <trans-unit id="411ab6817bdffdc71ef78ed59f78d2bdf2c45353" translate="yes" xml:space="preserve">
          <source>The output contains the CAN identifier in hexadecimal format, right adjusted to 32 bit, followed by the data length in square brackets and the payload in hexadecimal format.</source>
          <target state="translated">출력은 16 비트 형식의 CAN 식별자를 포함하고 오른쪽으로 32 비트로 조정 한 다음 대괄호로 묶은 데이터 길이와 16 진수 형식으로 된 페이로드를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="5f3292ce52901dd72bc842fbe3ca41e1d1588ed2" translate="yes" xml:space="preserve">
          <source>The output file name as a string. An empty file name indicates that the printer should not print to a file.</source>
          <target state="translated">출력 파일 이름을 문자열로 나타냅니다. 빈 파일 이름은 프린터가 파일로 인쇄하지 않아야 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="4d7cc3480d6a66ade4aa9aec728a051924b91606" translate="yes" xml:space="preserve">
          <source>The output from the .depend_command is interpreted to be one file per line. The default is to split on whitespace and is maintained only for backwards compatibility reasons.</source>
          <target state="translated">.depend_command의 출력은 한 줄에 하나의 파일로 해석됩니다. 기본값은 공백으로 분할되며 이전 버전과의 호환성을 위해서만 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="b29a2bb64d04d9ffe98c2b44d5b074cdfc43df7a" translate="yes" xml:space="preserve">
          <source>The output from the &lt;a href=&quot;qml-qtquick-shadereffect#fragmentShader-prop&quot;&gt;fragmentShader&lt;/a&gt; should be premultiplied. If &lt;a href=&quot;qml-qtquick-shadereffect#blending-prop&quot;&gt;blending&lt;/a&gt; is enabled, source-over blending is used. However, additive blending can be achieved by outputting zero in the alpha channel.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-shadereffect#fragmentShader-prop&quot;&gt;fragmentShader&lt;/a&gt; 의 출력은 미리 곱해야합니다. 경우 &lt;a href=&quot;qml-qtquick-shadereffect#blending-prop&quot;&gt;혼합이&lt;/a&gt; 활성화되어, 소스를 통해 혼합이 사용됩니다. 그러나, 알파 채널에서 0을 출력함으로써 부가적인 혼합이 달성 될 수있다.</target>
        </trans-unit>
        <trans-unit id="035299ec972b427c7bd8c7a7795a3a84b6dfbd83" translate="yes" xml:space="preserve">
          <source>The output is blended with the background.</source>
          <target state="translated">출력은 배경과 혼합됩니다.</target>
        </trans-unit>
        <trans-unit id="bbf5aaca41579c6247b1d105a9cc59592f44eb8a" translate="yes" xml:space="preserve">
          <source>The output is either fully transparent of fully opaque depending on the alpha value and the specified &lt;a href=&quot;qml-qtquick3d-principledmaterial#alphaCutoff-prop&quot;&gt;alphaCutoff&lt;/a&gt; value.</source>
          <target state="translated">출력은 알파 값과 지정된 &lt;a href=&quot;qml-qtquick3d-principledmaterial#alphaCutoff-prop&quot;&gt;alphaCutoff&lt;/a&gt; 값 에 따라 완전히 투명하거나 완전히 불투명 합니다.</target>
        </trans-unit>
        <trans-unit id="2e91ea88502097d3ef7d88e0dc4c024cc610bd6a" translate="yes" xml:space="preserve">
          <source>The output is generated using the &lt;a href=&quot;qloggingcategory#qCDebug&quot;&gt;qCDebug&lt;/a&gt;, &lt;a href=&quot;qloggingcategory#qCWarning&quot;&gt;qCWarning&lt;/a&gt;, or &lt;a href=&quot;qloggingcategory#qCCritical&quot;&gt;qCCritical&lt;/a&gt; methods in C++, with a category of &lt;code&gt;qml&lt;/code&gt; or &lt;code&gt;js&lt;/code&gt;, depending on the type of file doing the logging. See also &lt;a href=&quot;debug&quot;&gt;Debugging Techniques&lt;/a&gt;.</source>
          <target state="translated">출력은 로깅을 수행하는 파일 유형에 따라 &lt;code&gt;qml&lt;/code&gt; 또는 &lt;code&gt;js&lt;/code&gt; 범주로 C ++ 의 &lt;a href=&quot;qloggingcategory#qCDebug&quot;&gt;qCDebug&lt;/a&gt; , &lt;a href=&quot;qloggingcategory#qCWarning&quot;&gt;qCWarning&lt;/a&gt; 또는 &lt;a href=&quot;qloggingcategory#qCCritical&quot;&gt;qCCritical&lt;/a&gt; 메소드를 사용하여 생성됩니다 . &lt;a href=&quot;debug&quot;&gt;디버깅 기술을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="77a2e2658403564c58301e3e7304fc897c318918" translate="yes" xml:space="preserve">
          <source>The output is generated using the &lt;a href=&quot;qloggingcategory#qCDebug&quot;&gt;qCDebug&lt;/a&gt;, &lt;a href=&quot;qloggingcategory#qCWarning&quot;&gt;qCWarning&lt;/a&gt;, or &lt;a href=&quot;qloggingcategory#qCCritical&quot;&gt;qCCritical&lt;/a&gt; methods in C++, with a category of &lt;code&gt;qml&lt;/code&gt; or &lt;code&gt;js&lt;/code&gt;, depending on the type of file doing the logging. See also &lt;a href=&quot;debug#&quot;&gt;Debugging Techniques&lt;/a&gt;.</source>
          <target state="translated">로깅을 수행하는 파일 유형에 따라 &lt;code&gt;qml&lt;/code&gt; 또는 &lt;code&gt;js&lt;/code&gt; 범주의 C ++에서 &lt;a href=&quot;qloggingcategory#qCDebug&quot;&gt;qCDebug&lt;/a&gt; , &lt;a href=&quot;qloggingcategory#qCWarning&quot;&gt;qCWarning&lt;/a&gt; 또는 &lt;a href=&quot;qloggingcategory#qCCritical&quot;&gt;qCCritical&lt;/a&gt; 메소드를 사용하여 출력이 생성됩니다 . &lt;a href=&quot;debug#&quot;&gt;디버깅 기법&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="99d3951b4bf562c80fd9e0568b5c99ef8d76c772" translate="yes" xml:space="preserve">
          <source>The output is the destination pixel. This means that the blending has no effect. This mode is the inverse of CompositionMode_Source.</source>
          <target state="translated">출력은 대상 픽셀입니다. 이는 혼합이 효과가 없음을 의미합니다. 이 모드는 CompositionMode_Source와 반대입니다.</target>
        </trans-unit>
        <trans-unit id="a1dd1c85f70b94dc23efb45e4a5c63bb04789991" translate="yes" xml:space="preserve">
          <source>The output is the destination, where the alpha is reduced by that of the source. This mode is the inverse of CompositionMode_SourceIn.</source>
          <target state="translated">출력은 대상이며, 소스의 알파만큼 알파가 줄어 듭니다. 이 모드는 CompositionMode_SourceIn의 반대입니다.</target>
        </trans-unit>
        <trans-unit id="8100ae818f81dcc890be4cd54fdaff0c65cb92ed" translate="yes" xml:space="preserve">
          <source>The output is the destination, where the alpha is reduced by the inverse of the source. This mode is the inverse of CompositionMode_SourceOut.</source>
          <target state="translated">출력은 대상이며, 소스의 역수에 따라 알파가 줄어 듭니다. 이 모드는 CompositionMode_SourceOut과 반대입니다.</target>
        </trans-unit>
        <trans-unit id="26fb05444884e172dff424fb76479fd651fa6735" translate="yes" xml:space="preserve">
          <source>The output is the source color multiplied by the destination. Multiplying a color with white leaves the color unchanged, while multiplying a color with black produces black.</source>
          <target state="translated">출력은 소스 색상에 대상을 곱한 것입니다. 색상에 흰색을 곱하면 색상이 변경되지 않고 색상에 검정색을 곱하면 검정색이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="5f3d65818523e229e909fdfbc05d11514e547be4" translate="yes" xml:space="preserve">
          <source>The output is the source pixel. (This means a basic copy operation and is identical to SourceOver when the source pixel is opaque).</source>
          <target state="translated">출력은 소스 픽셀입니다. (이것은 기본 복사 작업을 의미하며 소스 픽셀이 불투명 한 경우 SourceOver와 동일합니다).</target>
        </trans-unit>
        <trans-unit id="a215ef12d0bb2eec025243b7191b6504ecd820bb" translate="yes" xml:space="preserve">
          <source>The output is the source, where the alpha is reduced by that of the destination.</source>
          <target state="translated">출력은 소스이며 알파는 대상의 알파만큼 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="4fad5f841deebaf789dadebb4b4e5716df4c0dc6" translate="yes" xml:space="preserve">
          <source>The output is the source, where the alpha is reduced by the inverse of destination.</source>
          <target state="translated">출력은 소스이며 대상의 역수에 따라 알파가 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="7e4ecf7084818db5ab94d367b5e1b0fe8fb9961b" translate="yes" xml:space="preserve">
          <source>The output list contains both items whose &lt;a href=&quot;qgraphicsitem#boundingRect&quot;&gt;bounding rectangle&lt;/a&gt; is fully contained inside the selection area, and items that intersect with the area's outline. This method is commonly used for determining areas that need redrawing.</source>
          <target state="translated">출력 목록에는 선택 영역 안에 &lt;a href=&quot;qgraphicsitem#boundingRect&quot;&gt;경계 사각형&lt;/a&gt; 이 완전히 포함 된 항목과 영역 개요와 교차하는 항목이 모두 포함됩니다. 이 방법은 일반적으로 다시 그리기가 필요한 영역을 결정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1f0070f2a900424d1f96b5d5e0b8501124f6ecd2" translate="yes" xml:space="preserve">
          <source>The output list contains both items whose &lt;a href=&quot;qgraphicsitem#shape&quot;&gt;shape&lt;/a&gt; is fully contained inside the selection area, and items that intersect with the area's outline. This is a common mode for rubber band selection.</source>
          <target state="translated">출력 목록에는 &lt;a href=&quot;qgraphicsitem#shape&quot;&gt;모양&lt;/a&gt; 이 선택 영역 안에 완전히 포함 된 항목과 영역의 외곽선과 교차하는 항목이 모두 포함됩니다. 이것은 고무 밴드 선택을위한 공통 모드입니다.</target>
        </trans-unit>
        <trans-unit id="3d331e459020cfb9fc66478237b344bcebffe9ee" translate="yes" xml:space="preserve">
          <source>The output list contains only items whose &lt;a href=&quot;qgraphicsitem#boundingRect&quot;&gt;bounding rectangle&lt;/a&gt; is fully contained inside the selection area. Items that intersect with the area's outline are not included.</source>
          <target state="translated">출력 목록에는 선택 영역 안에 &lt;a href=&quot;qgraphicsitem#boundingRect&quot;&gt;경계 사각형&lt;/a&gt; 이 완전히 포함 된 항목 만 포함됩니다 . 영역의 개요와 교차하는 항목은 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="04ed93c6f68ae01798fd7e29464bc10ccd7c5f39" translate="yes" xml:space="preserve">
          <source>The output list contains only items whose &lt;a href=&quot;qgraphicsitem#shape&quot;&gt;shape&lt;/a&gt; is fully contained inside the selection area. Items that intersect with the area's outline are not included.</source>
          <target state="translated">출력 목록에는 &lt;a href=&quot;qgraphicsitem#shape&quot;&gt;모양&lt;/a&gt; 이 선택 영역 안에 완전히 포함 된 항목 만 포함됩니다 . 영역의 개요와 교차하는 항목은 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4b776eacfd02ec256d4debba369cdca20c12c7a3" translate="yes" xml:space="preserve">
          <source>The output prefix is applied to file names for documentation on QML and JS types.</source>
          <target state="translated">출력 접 두부는 QML 및 JS 유형에 대한 문서화를 위해 파일 이름에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="6670e433d0d98333d102d91061e45a53981533a8" translate="yes" xml:space="preserve">
          <source>The output produced by &lt;code&gt;moc&lt;/code&gt; must be compiled and linked, just like the other C++ code in your program; otherwise, the build will fail in the final link phase. If you use &lt;code&gt;qmake&lt;/code&gt;, this is done automatically. Whenever &lt;code&gt;qmake&lt;/code&gt; is run, it parses the project's header files and generates make rules to invoke &lt;code&gt;moc&lt;/code&gt; for those files that contain a &lt;a href=&quot;qobject#Q_OBJECT&quot;&gt;Q_OBJECT&lt;/a&gt; macro.</source>
          <target state="translated">&lt;code&gt;moc&lt;/code&gt; 에 의해 생성 된 출력은 프로그램의 다른 C ++ 코드와 마찬가지로 컴파일 및 링크되어야합니다. 그렇지 않으면 최종 링크 단계에서 빌드가 실패합니다. &lt;code&gt;qmake&lt;/code&gt; 를 사용하면 자동으로 수행됩니다. &lt;code&gt;qmake&lt;/code&gt; 가 실행될 때마다 프로젝트의 헤더 파일을 구문 분석하고 &lt;a href=&quot;qobject#Q_OBJECT&quot;&gt;Q_OBJECT&lt;/a&gt; 매크로 가 포함 된 파일에 대해 &lt;code&gt;moc&lt;/code&gt; 를 호출하는 make 규칙을 생성 합니다 .</target>
        </trans-unit>
        <trans-unit id="4f15159db80897d53757992bd8e51c2586459ab5" translate="yes" xml:space="preserve">
          <source>The output sent to the debug stream can, of course, be made as simple or as complicated as you like. Note that the value returned by this function is the &lt;a href=&quot;qdebug&quot;&gt;QDebug&lt;/a&gt; object itself, though this is often obtained by calling the &lt;a href=&quot;qdebug#maybeSpace&quot;&gt;maybeSpace()&lt;/a&gt; member function of &lt;a href=&quot;qdebug&quot;&gt;QDebug&lt;/a&gt; that pads out the stream with space characters to make it more readable.</source>
          <target state="translated">물론 디버그 스트림으로 전송되는 출력은 원하는만큼 간단하거나 복잡하게 만들 수 있습니다. 이 함수가 리턴 한 값은 &lt;a href=&quot;qdebug&quot;&gt;QDebug&lt;/a&gt; 오브젝트 자체이지만 , 스트림 문자를보다 읽기 쉽게 만들기 위해 스트림 을 &lt;a href=&quot;qdebug&quot;&gt;채우는 QDebug&lt;/a&gt; 의 &lt;a href=&quot;qdebug#maybeSpace&quot;&gt;maybeSpace ()&lt;/a&gt; 멤버 함수를 호출하여 종종 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc1ea02ae3764ec112b24065a7a22a11fc8b7388" translate="yes" xml:space="preserve">
          <source>The overall saturation level of the tonemap. Range is &lt;code&gt;[0...2]&lt;/code&gt;, with &lt;code&gt;0&lt;/code&gt; being fully grayscale and &lt;code&gt;being&lt;/code&gt; very oversaturated. &lt;code&gt;1&lt;/code&gt; by default.</source>
          <target state="translated">톤맵의 전체 채도 수준입니다. 범위는 &lt;code&gt;[0...2]&lt;/code&gt; 로, &lt;code&gt;0&lt;/code&gt; 은 완전히 그레이 스케일 인 및 &lt;code&gt;being&lt;/code&gt; 매우 과포화. 기본적으로 &lt;code&gt;1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5fcce5e4a04185e08d10f94c13c4594d1dcc39e2" translate="yes" xml:space="preserve">
          <source>The overall size of the splitter widget is not affected. Instead, any additional/missing space is distributed amongst the widgets according to the relative weight of the sizes.</source>
          <target state="translated">스플리터 위젯의 전체 크기는 영향을받지 않습니다. 대신, 크기의 상대적 무게에 따라 위젯에 추가 / 누락 공간이 분배됩니다.</target>
        </trans-unit>
        <trans-unit id="fcef4e78961275c869f5460513bb25f1b748d6d9" translate="yes" xml:space="preserve">
          <source>The overlay icon and a description of the overlay for accessibility purposes.</source>
          <target state="translated">접근성 목적으로 오버레이 아이콘 및 오버레이에 대한 설명.</target>
        </trans-unit>
        <trans-unit id="0209f45bdbd868beb0be9e45c712a728d7885b93" translate="yes" xml:space="preserve">
          <source>The overlay is an ordinary Item that covers the entire window. It can be used as a visual parent to position a popup in scene coordinates.</source>
          <target state="translated">오버레이는 전체 창을 덮는 일반 항목입니다. 팝업을 장면 좌표에 배치하기 위해 시각적 부모로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d1ba447c44a32dec06ffb94ab6cf74010f4773a7" translate="yes" xml:space="preserve">
          <source>The overload of this function that accepts an argument is used to test for the presence of files and directories within a directory.</source>
          <target state="translated">인수를 허용하는이 함수의 과부하는 디렉토리 내에 파일 및 디렉토리가 있는지 테스트하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b820b1f4d905e35cff7da1a7b643140a4df95a22" translate="yes" xml:space="preserve">
          <source>The owernship of &lt;a href=&quot;qt3dcore-qnode&quot;&gt;QNode&lt;/a&gt; is determined by the &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; parent/child relationship between nodes. By itself, a &lt;a href=&quot;qt3dcore-qnode&quot;&gt;QNode&lt;/a&gt; has no visual appearance and no particular meaning, it is there as a way of building a node based tree structure.</source>
          <target state="translated">QNode의 &lt;a href=&quot;qt3dcore-qnode&quot;&gt;소유권&lt;/a&gt; 은 노드 간의 &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 상위 / 하위 관계에 의해 결정됩니다 . &lt;a href=&quot;qt3dcore-qnode&quot;&gt;QNode&lt;/a&gt; 자체 는 시각적 인 외관과 특별한 의미가 없으며, 노드 기반 트리 구조를 구축하는 방법으로 존재합니다.</target>
        </trans-unit>
        <trans-unit id="eda6bf0203f0a3f38f4b7b74359fa5a624d536c6" translate="yes" xml:space="preserve">
          <source>The owernship of QNode is determined by the &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; parent/child relationship between nodes. By itself, a QNode has no visual appearance and no particular meaning, it is there as a way of building a node based tree structure.</source>
          <target state="translated">QNode의 소유권은 노드 간의 &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 부모 / 자식 관계에 의해 결정됩니다 . 그 자체로 QNode는 시각적 인 모양과 특별한 의미가 없으며 노드 기반 트리 구조를 구축하는 방법으로 존재합니다.</target>
        </trans-unit>
        <trans-unit id="7b86c886e00dd8c181f2d24ed9d9d54fb81ef850" translate="yes" xml:space="preserve">
          <source>The owner element is set to 0 and the specified flag is set to true in the generated attribute. The whole subtree of</source>
          <target state="translated">소유자 요소는 0으로 설정되고 지정된 플래그는 생성 된 속성에서 true로 설정됩니다. 전체 하위 트리</target>
        </trans-unit>
        <trans-unit id="dfc16103a44fd4348bc49314e7234e04c7be2661" translate="yes" xml:space="preserve">
          <source>The ownership of</source>
          <target state="translated">의 소유권</target>
        </trans-unit>
        <trans-unit id="915ca6143be0f5c2d967d8019ec60ec2d57675aa" translate="yes" xml:space="preserve">
          <source>The ownership of the removed widget is passed to the caller.</source>
          <target state="translated">제거 된 위젯의 소유권은 호출자에게 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="8f98165e157901e57cce31c795497279a1288ac4" translate="yes" xml:space="preserve">
          <source>The ownership of the returned object instance is transferred to the caller.</source>
          <target state="translated">리턴 된 오브젝트 인스턴스의 소유권이 호출자에게 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="3c60aa5b0eecbb467101d8abb1892491a6814ed8" translate="yes" xml:space="preserve">
          <source>The ownership of the returned object is passed to the caller.</source>
          <target state="translated">반환 된 객체의 소유권은 호출자에게 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="6deb584b06771205152e92a514f797c827a055f5" translate="yes" xml:space="preserve">
          <source>The padding falls inside the border, between the border and the actual contents.</source>
          <target state="translated">패딩은 테두리와 실제 내용 사이의 테두리 안에 있습니다.</target>
        </trans-unit>
        <trans-unit id="a0555e0cd7611a281aabb191d7c690827e75e0ed" translate="yes" xml:space="preserve">
          <source>The padding properties are used to control the geometry of the &lt;a href=&quot;qml-qtquick-controls2-popup#contentItem-prop&quot;&gt;content item&lt;/a&gt;.</source>
          <target state="translated">패딩 속성은 &lt;a href=&quot;qml-qtquick-controls2-popup#contentItem-prop&quot;&gt;컨텐트 항목&lt;/a&gt; 의 형상을 제어하는 ​​데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="15756453c954fc25a5b79dd66e7fa0538ed2ed10" translate="yes" xml:space="preserve">
          <source>The padding properties of a table cell are controlled by &lt;a href=&quot;qtexttablecellformat#setLeftPadding&quot;&gt;setLeftPadding&lt;/a&gt;(), &lt;a href=&quot;qtexttablecellformat#setRightPadding&quot;&gt;setRightPadding&lt;/a&gt;(), &lt;a href=&quot;qtexttablecellformat#setTopPadding&quot;&gt;setTopPadding&lt;/a&gt;(), and &lt;a href=&quot;qtexttablecellformat#setBottomPadding&quot;&gt;setBottomPadding&lt;/a&gt;(). All the paddings can be set at once using &lt;a href=&quot;qtexttablecellformat#setPadding&quot;&gt;setPadding&lt;/a&gt;().</source>
          <target state="translated">테이블 셀의 패딩 속성은 &lt;a href=&quot;qtexttablecellformat#setLeftPadding&quot;&gt;setLeftPadding&lt;/a&gt; (), &lt;a href=&quot;qtexttablecellformat#setRightPadding&quot;&gt;setRightPadding&lt;/a&gt; (), &lt;a href=&quot;qtexttablecellformat#setTopPadding&quot;&gt;setTopPadding&lt;/a&gt; () 및 &lt;a href=&quot;qtexttablecellformat#setBottomPadding&quot;&gt;setBottomPadding&lt;/a&gt; ()에 의해 제어됩니다 . 모든 패딩은 &lt;a href=&quot;qtexttablecellformat#setPadding&quot;&gt;setPadding&lt;/a&gt; ()을 사용하여 한 번에 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="df74cc074d510d45f9e1c2b555263ef8227ab629" translate="yes" xml:space="preserve">
          <source>The page below covers specific issues and recommendations for creating macOS applications.</source>
          <target state="translated">아래 페이지는 macOS 응용 프로그램을 만들기위한 특정 문제 및 권장 사항을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="9b5093f3db5bc451c72959872bfb04c4a29b05c9" translate="yes" xml:space="preserve">
          <source>The page break is determined automatically depending on the available space on the current page</source>
          <target state="translated">페이지 나누기는 현재 페이지에서 사용 가능한 공간에 따라 자동으로 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="eda266ecfa89e828ef98dc69914bf210adbda05e" translate="yes" xml:space="preserve">
          <source>The page could not be loaded.</source>
          <target state="translated">페이지를로드 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="64204621edb7f31576bbe26715508d66e7923b60" translate="yes" xml:space="preserve">
          <source>The page does not take ownership of the pointer. This interceptor is called after any interceptors on the profile, and unlike profile interceptors, is run on the UI thread, making it thread-safer. Only URL requests from this page are intercepted.</source>
          <target state="translated">페이지가 포인터의 소유권을 갖지 않습니다. 이 인터셉터는 프로파일의 인터셉터가 호출 된 후 호출되며 프로파일 인터셉터와 달리 UI 스레드에서 실행되어 스레드를 스레드로 만듭니다. 이 페이지의 URL 요청 만 인터셉트됩니다.</target>
        </trans-unit>
        <trans-unit id="a522c080ed766ea096bd517d4383377cb594c198" translate="yes" xml:space="preserve">
          <source>The page does not take ownership of the pointer. This interceptor is called after any interceptors on the profile, and unlike profile interceptors, only URL requests from this page are intercepted.</source>
          <target state="translated">페이지는 포인터의 소유권을 갖지 않습니다. 이 인터셉터는 프로파일의 인터셉터 이후에 호출되며 프로파일 인터셉터와 달리이 페이지의 URL 요청 만 인터셉트됩니다.</target>
        </trans-unit>
        <trans-unit id="29c38f683dc2bfe87ea69b49b738a6151865430f" translate="yes" xml:space="preserve">
          <source>The page is always broken before the paragraph/table</source>
          <target state="translated">페이지는 항상 단락 / 테이블 앞에 나옵니다.</target>
        </trans-unit>
        <trans-unit id="88ed99f2efe483320c5a59d298c1e43f1a5cfca6" translate="yes" xml:space="preserve">
          <source>The page is currently loading.</source>
          <target state="translated">페이지가 현재로드 중입니다.</target>
        </trans-unit>
        <trans-unit id="8d9e53bc919e5d3dbfc7b207d9d028ec9f758722" translate="yes" xml:space="preserve">
          <source>The page is rendered grayscale.</source>
          <target state="translated">페이지가 회색조로 렌더링됩니다.</target>
        </trans-unit>
        <trans-unit id="4c0260666db7efb6d9ce0e590c9f196a91cf8a25" translate="yes" xml:space="preserve">
          <source>The page is rendered with annotations.</source>
          <target state="translated">페이지는 주석으로 렌더링됩니다.</target>
        </trans-unit>
        <trans-unit id="f4978602e624e1b74e6bcc2a0e3023146eb38d54" translate="yes" xml:space="preserve">
          <source>The page is saved as a complete HTML page, for example a directory containing the single HTML page and the resources.</source>
          <target state="translated">페이지는 완전한 HTML 페이지 (예 : 단일 HTML 페이지와 리소스를 포함하는 디렉토리)로 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="81ffe16fd35017568d391f4125f62dd12b1059e1" translate="yes" xml:space="preserve">
          <source>The page is saved as a complete web page in the MIME HTML format.</source>
          <target state="translated">페이지는 MIME HTML 형식의 완전한 웹 페이지로 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="eefc877ff381a978db10529b95d5418ec751fbb1" translate="yes" xml:space="preserve">
          <source>The page is saved as a single HTML page. Resources such as images are not saved.</source>
          <target state="translated">페이지는 단일 HTML 페이지로 저장됩니다. 이미지와 같은 리소스는 저장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2c0eddb08cdb3642cdd5fb4b873a9676877ec11d" translate="yes" xml:space="preserve">
          <source>The page itself (the &lt;a href=&quot;qwizardpage&quot;&gt;QWizardPage&lt;/a&gt; widget) occupies the area between the header, the watermark, and the button row. Typically, the page is a &lt;a href=&quot;qwizardpage&quot;&gt;QWizardPage&lt;/a&gt; on which a &lt;a href=&quot;qgridlayout&quot;&gt;QGridLayout&lt;/a&gt; is installed, with standard child widgets (&lt;a href=&quot;qlabel&quot;&gt;QLabel&lt;/a&gt;s, &lt;a href=&quot;qlineedit&quot;&gt;QLineEdit&lt;/a&gt;s, etc.).</source>
          <target state="translated">페이지 자체 ( &lt;a href=&quot;qwizardpage&quot;&gt;QWizardPage&lt;/a&gt; 위젯)는 헤더, 워터 마크 및 버튼 행 사이의 영역을 차지합니다. 일반적으로, 페이지가있다 &lt;a href=&quot;qwizardpage&quot;&gt;QWizardPage&lt;/a&gt; 되는 &lt;a href=&quot;qgridlayout&quot;&gt;QGridLayout은&lt;/a&gt; 표준 아이 위젯 (함께 설치되어 &lt;a href=&quot;qlabel&quot;&gt;QLabel&lt;/a&gt; S, &lt;a href=&quot;qlineedit&quot;&gt;QLineEdit&lt;/a&gt; S 등).</target>
        </trans-unit>
        <trans-unit id="64504327583a2bee9fb2c73e226b3e9300ec53a8" translate="yes" xml:space="preserve">
          <source>The page number on which to search.</source>
          <target state="translated">검색 할 페이지 번호입니다.</target>
        </trans-unit>
        <trans-unit id="8e227801db91891fd4476299769239bb76e0c208" translate="yes" xml:space="preserve">
          <source>The page on which currentMatchGeometry should provide filtered search results.</source>
          <target state="translated">currentMatchGeometry가 필터링 된 검색 결과를 제공해야하는 페이지입니다.</target>
        </trans-unit>
        <trans-unit id="e7c8312bf3b9248866b642035b9d2f1253f6ac41" translate="yes" xml:space="preserve">
          <source>The page order can be &lt;a href=&quot;qprinter#PageOrder-enum&quot;&gt;QPrinter::FirstPageFirst&lt;/a&gt; or &lt;a href=&quot;qprinter#PageOrder-enum&quot;&gt;QPrinter::LastPageFirst&lt;/a&gt;. The application is responsible for reading the page order and printing accordingly.</source>
          <target state="translated">페이지 순서는 &lt;a href=&quot;qprinter#PageOrder-enum&quot;&gt;QPrinter :: FirstPageFirst&lt;/a&gt; 또는 &lt;a href=&quot;qprinter#PageOrder-enum&quot;&gt;QPrinter :: LastPageFirst&lt;/a&gt; 입니다. 응용 프로그램은 페이지 순서를 읽고 그에 따라 인쇄해야합니다.</target>
        </trans-unit>
        <trans-unit id="562c595d74cb00bc6a9591fa9e21819a0a18aed5" translate="yes" xml:space="preserve">
          <source>The page orientation is used to define the orientation of the page size when obtaining the page rect.</source>
          <target state="translated">페이지 방향은 페이지 rect를 얻을 때 페이지 크기의 방향을 정의하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f82647c365557c247497bd6118dfab23ea9cb0ca" translate="yes" xml:space="preserve">
          <source>The page range selection option is enabled.</source>
          <target state="translated">페이지 범위 선택 옵션이 활성화되었습니다.</target>
        </trans-unit>
        <trans-unit id="68f9565a719f578f5234302eaa15f9f327fc35c7" translate="yes" xml:space="preserve">
          <source>The page rectangle takes into account the page size and page orientation, but not the page margins.</source>
          <target state="translated">페이지 사각형은 페이지 크기와 페이지 방향을 고려하지만 페이지 여백은 고려하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="141a33f1c581a8cb8a505a6c10fe2ea30591b4c2" translate="yes" xml:space="preserve">
          <source>The page size is defined by the &lt;a href=&quot;qpagesize&quot;&gt;QPageSize&lt;/a&gt; class which can be queried for page size attributes. Note that the &lt;a href=&quot;qpagesize&quot;&gt;QPageSize&lt;/a&gt; itself is always defined in a Portrait orientation.</source>
          <target state="translated">페이지 크기는 &lt;a href=&quot;qpagesize&quot;&gt;QPageSize&lt;/a&gt; 클래스에 의해 정의되며 페이지 크기 속성에 대해 쿼리 할 수 ​​있습니다. 있습니다 &lt;a href=&quot;qpagesize&quot;&gt;QPageSize&lt;/a&gt; 자체가 항상 세로 방향으로 정의된다.</target>
        </trans-unit>
        <trans-unit id="612a2ce64b5ac0190f6c20baa0e9d73a931fb023" translate="yes" xml:space="preserve">
          <source>The page size is rotated through 90 degrees</source>
          <target state="translated">페이지 크기가 90도 회전</target>
        </trans-unit>
        <trans-unit id="b2a522e93343be3a92a368236b91047d18c4e3c9" translate="yes" xml:space="preserve">
          <source>The page size is used in its default orientation</source>
          <target state="translated">페이지 크기는 기본 방향으로 사용됩니다</target>
        </trans-unit>
        <trans-unit id="e1b961c6f1be4675b15067ca55e4f924fa2849e6" translate="yes" xml:space="preserve">
          <source>The page size may be invalid if created with an invalid &lt;a href=&quot;qpagesize#PageSizeId-enum&quot;&gt;PageSizeId&lt;/a&gt;, or a negative or invalid &lt;a href=&quot;qsize&quot;&gt;QSize&lt;/a&gt; or &lt;a href=&quot;qsizef&quot;&gt;QSizeF&lt;/a&gt;, or the null constructor.</source>
          <target state="translated">유효하지 않은 &lt;a href=&quot;qpagesize#PageSizeId-enum&quot;&gt;PageSizeId&lt;/a&gt; 또는 음수 또는 유효하지 않은 &lt;a href=&quot;qsize&quot;&gt;QSize&lt;/a&gt; 또는 &lt;a href=&quot;qsizef&quot;&gt;QSizeF&lt;/a&gt; 또는 널 생성자로 작성된 경우 페이지 크기가 유효하지 않을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d1c18999d468199fce0bd86cea4df459b45f0440" translate="yes" xml:space="preserve">
          <source>The page was loaded successfully.</source>
          <target state="translated">페이지가 성공적으로로드되었습니다.</target>
        </trans-unit>
        <trans-unit id="cfd2ecc91c3780155ba977d2c36348f401070717" translate="yes" xml:space="preserve">
          <source>The pages are independent of each other (i.e., they don't derive values from each other).</source>
          <target state="translated">페이지는 서로 독립적입니다 (즉, 서로 값을 파생하지 않음).</target>
        </trans-unit>
        <trans-unit id="863018a2ca4efde2aaebf324da6606d7931937c6" translate="yes" xml:space="preserve">
          <source>The pages are inserted using &lt;a href=&quot;qwizard#setPage&quot;&gt;setPage&lt;/a&gt;(), which takes an ID and an instance of &lt;a href=&quot;qwizardpage&quot;&gt;QWizardPage&lt;/a&gt; (or of a subclass):</source>
          <target state="translated">페이지는 &lt;a href=&quot;qwizard#setPage&quot;&gt;setPage&lt;/a&gt; ()를 사용하여 삽입 되며, ID와 &lt;a href=&quot;qwizardpage&quot;&gt;QWizardPage&lt;/a&gt; 인스턴스 (또는 서브 클래스)를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="888c87a9e18107632e2e1cd7b6ec29c5887f7b87" translate="yes" xml:space="preserve">
          <source>The pages below covers specific issues and recommendations for creating Linux/X11 applications.</source>
          <target state="translated">아래 페이지는 Linux / X11 응용 프로그램 작성에 대한 특정 문제 및 권장 사항을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="552adb7722f0eb4e3a2bac3733b0f3573fe57ce4" translate="yes" xml:space="preserve">
          <source>The pages below covers specific issues and recommendations for creating Windows applications.</source>
          <target state="translated">아래 페이지는 Windows 응용 프로그램을 만들기위한 특정 문제 및 권장 사항을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="180353bf23f5714553635d368a2715196f1ae862" translate="yes" xml:space="preserve">
          <source>The paint system also provides the &lt;a href=&quot;qstylepainter&quot;&gt;QStylePainter&lt;/a&gt; class inheriting from &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt;. &lt;a href=&quot;qstylepainter&quot;&gt;QStylePainter&lt;/a&gt; is a convenience class for drawing &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt; elements inside a widget, and extends &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; with a set of high-level drawing functions implemented on top of &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt;'s API. The advantage of using &lt;a href=&quot;qstylepainter&quot;&gt;QStylePainter&lt;/a&gt; is that the parameter lists get considerably shorter.</source>
          <target state="translated">페인트 시스템 은 &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; 로부터 상속되는 &lt;a href=&quot;qstylepainter&quot;&gt;QStylePainter&lt;/a&gt; 클래스 도 제공합니다 . &lt;a href=&quot;qstylepainter&quot;&gt;QStylePainter&lt;/a&gt; 는 위젯 내에서 &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt; 요소 를 그리기위한 편리한 클래스 이며 &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt; 의 API 위에 구현 된 일련의 고급 그리기 기능 으로 &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; 를 확장 합니다. &lt;a href=&quot;qstylepainter&quot;&gt;QStylePainter&lt;/a&gt; 를 사용 하면 매개 변수 목록이 상당히 짧아 진다 는 이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="443f0ade94bfb5304bcc72677fad825252c9c904" translate="yes" xml:space="preserve">
          <source>The paint system automatically uses the correct device metrics when painting text but, if you need to position text using information obtained from font metrics, you need to ensure that the print device is specified when you construct &lt;a href=&quot;qfontmetrics&quot;&gt;QFontMetrics&lt;/a&gt; and &lt;a href=&quot;qfontmetricsf&quot;&gt;QFontMetricsF&lt;/a&gt; objects, or ensure that each &lt;a href=&quot;qfont&quot;&gt;QFont&lt;/a&gt; used is constructed using the form of the constructor that accepts a &lt;a href=&quot;qpaintdevice&quot;&gt;QPaintDevice&lt;/a&gt; argument.</source>
          <target state="translated">페인트 시스템은 텍스트를 페인팅 할 때 자동으로 올바른 장치 메트릭을 사용하지만 글꼴 메트릭에서 얻은 정보를 사용하여 텍스트를 배치해야하는 경우 &lt;a href=&quot;qfontmetrics&quot;&gt;QFontMetrics&lt;/a&gt; 및 &lt;a href=&quot;qfontmetricsf&quot;&gt;QFontMetricsF&lt;/a&gt; 객체 를 생성 할 때 인쇄 장치를 지정 하거나 각 &lt;a href=&quot;qfont&quot;&gt;QFont를&lt;/a&gt; 확인해야합니다 used는 &lt;a href=&quot;qpaintdevice&quot;&gt;QPaintDevice&lt;/a&gt; 인수 를 허용하는 생성자의 형식을 사용하여 구성 됩니다.</target>
        </trans-unit>
        <trans-unit id="f001ef2e2f9a36349371e10410b4ac83d4da4b32" translate="yes" xml:space="preserve">
          <source>The paintable rectangle takes into account the page size, orientation and margins.</source>
          <target state="translated">페인트 가능한 사각형은 페이지 크기, 방향 및 여백을 고려합니다.</target>
        </trans-unit>
        <trans-unit id="4123963d438c1cdc3e71f7749ada95f3b7c93e0c" translate="yes" xml:space="preserve">
          <source>The painter path generated by the &lt;a href=&quot;qpainterpathstroker#createStroke&quot;&gt;createStroke&lt;/a&gt;() function should only be used for outlining the given painter path. Otherwise it may cause unexpected behavior. Generated outlines also require the &lt;a href=&quot;qt#FillRule-enum&quot;&gt;Qt::WindingFill&lt;/a&gt; rule which is set by default.</source>
          <target state="translated">&lt;a href=&quot;qpainterpathstroker#createStroke&quot;&gt;createStroke&lt;/a&gt; () 함수에 의해 생성 된 페인터 경로는 주어진 페인터 경로를 나타내는 데만 사용해야합니다. 그렇지 않으면 예기치 않은 동작이 발생할 수 있습니다. 생성 된 아웃 라인에는 기본적으로 설정된 &lt;a href=&quot;qt#FillRule-enum&quot;&gt;Qt :: WindingFill&lt;/a&gt; 규칙 도 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="8d1d69c93bafeec830424ba8002f90bf9cb38951" translate="yes" xml:space="preserve">
          <source>The painter path is initially empty when constructed. We first add a rectangle, which is a closed subpath. Then we add two bezier curves which together form a closed subpath even though they are not closed individually. Finally we draw the entire path. The path is filled using the default fill rule, &lt;a href=&quot;qt#FillRule-enum&quot;&gt;Qt::OddEvenFill&lt;/a&gt;. Qt provides two methods for filling paths:</source>
          <target state="translated">페인터 경로는 처음에 비어 있습니다. 먼저 닫힌 서브 패스 인 사각형을 추가합니다. 그런 다음 개별적으로 닫히지 않더라도 닫힌 서브 패스를 형성하는 두 개의 베 지어 곡선을 추가합니다. 마지막으로 전체 경로를 그립니다. 경로는 기본 채우기 규칙 &lt;a href=&quot;qt#FillRule-enum&quot;&gt;Qt :: OddEvenFill을&lt;/a&gt; 사용하여 채워 집니다 . Qt는 경로를 채우는 두 가지 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="3cbe73ebbfc0f2f93fbd3d527f7ceedf2e8201b6" translate="yes" xml:space="preserve">
          <source>The painter's brush defines how shapes are filled.</source>
          <target state="translated">화가의 붓은 도형이 채워지는 방법을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="21a1a172af2938ddc5f90c3c1f73624b9d557d92" translate="yes" xml:space="preserve">
          <source>The painter's pen is 0-width by default, and its pen is initialized to the &lt;a href=&quot;qpalette#ColorRole-enum&quot;&gt;QPalette::Text&lt;/a&gt; brush from the paint device's palette. The brush is initialized to &lt;a href=&quot;qpalette#ColorRole-enum&quot;&gt;QPalette::Window&lt;/a&gt;.</source>
          <target state="translated">페인터의 펜은 기본적으로 너비가 0이며 펜은 페인트 장치의 팔레트에서 &lt;a href=&quot;qpalette#ColorRole-enum&quot;&gt;QPalette :: Text&lt;/a&gt; 브러시로 초기화됩니다 . 브러시는 &lt;a href=&quot;qpalette#ColorRole-enum&quot;&gt;QPalette :: Window로&lt;/a&gt; 초기화됩니다 .</target>
        </trans-unit>
        <trans-unit id="0106a6f0d3158fae33109041c59588aa489bccf3" translate="yes" xml:space="preserve">
          <source>The painting of check box indicators are performed by the current style. The style also specifies the size and the bounding rectangles in which to draw the data for the different data roles. The bounding rectangle of the item itself is also calculated by the style. When drawing already supported datatypes, it is therefore a good idea to ask the style for these bounding rectangles. The &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt; class description describes this in more detail.</source>
          <target state="translated">확인란 표시기 그림은 현재 스타일에 따라 수행됩니다. 스타일은 또한 다른 데이터 역할에 대한 데이터를 그릴 크기와 경계 사각형을 지정합니다. 항목 자체의 경계 사각형도 스타일로 계산됩니다. 이미 지원되는 데이터 유형을 그릴 때 이러한 경계 사각형의 스타일을 요청하는 것이 좋습니다. &lt;a href=&quot;qstyle&quot;&gt;QStyle의&lt;/a&gt; 클래스 설명을 더 자세하게 설명합니다.</target>
        </trans-unit>
        <trans-unit id="4f371b5e9aa91f2bc3a41c917308bdb48479b3b6" translate="yes" xml:space="preserve">
          <source>The painting of items in views is performed by a delegate. Qt's default delegate, &lt;a href=&quot;qstyleditemdelegate&quot;&gt;QStyledItemDelegate&lt;/a&gt;, is also used for calculating bounding rectangles of items, and their sub-elements for the various kind of item &lt;a href=&quot;qt#ItemDataRole-enum&quot;&gt;data roles&lt;/a&gt;&lt;a href=&quot;qstyleditemdelegate&quot;&gt;QStyledItemDelegate&lt;/a&gt; supports. See the &lt;a href=&quot;qstyleditemdelegate&quot;&gt;QStyledItemDelegate&lt;/a&gt; class description to find out which datatypes and roles are supported. You can read more about item data roles in &lt;a href=&quot;model-view-programming&quot;&gt;Model/View Programming&lt;/a&gt;.</source>
          <target state="translated">뷰의 항목 그리기는 대리자가 수행합니다. Qt의 기본 델리게이트 인 &lt;a href=&quot;qstyleditemdelegate&quot;&gt;QStyledItemDelegate&lt;/a&gt; 는 항목의 경계 사각형 및 &lt;a href=&quot;qstyleditemdelegate&quot;&gt;QStyledItemDelegate가&lt;/a&gt; 지원 하는 다양한 종류의 항목 &lt;a href=&quot;qt#ItemDataRole-enum&quot;&gt;데이터 역할에&lt;/a&gt; 대한 하위 요소를 계산하는데도 사용됩니다 . 어떤 데이터 유형과 역할이 지원되는지 알아 보려면 &lt;a href=&quot;qstyleditemdelegate&quot;&gt;QStyledItemDelegate&lt;/a&gt; 클래스 설명을 참조하십시오 . &lt;a href=&quot;model-view-programming&quot;&gt;모델 / 뷰 프로그래밍&lt;/a&gt; 에서 항목 데이터 역할에 대해 자세히 읽을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ddceefbb595f96897d0d773ae80e034a4001e747" translate="yes" xml:space="preserve">
          <source>The painting of items in views is performed by a delegate. Qt's default delegate, &lt;a href=&quot;qstyleditemdelegate&quot;&gt;QStyledItemDelegate&lt;/a&gt;, is also used for calculating bounding rectangles of items, and their sub-elements for the various kind of item &lt;a href=&quot;qt#ItemDataRole-enum&quot;&gt;data roles&lt;/a&gt;&lt;a href=&quot;qstyleditemdelegate&quot;&gt;QStyledItemDelegate&lt;/a&gt; supports. See the &lt;a href=&quot;qstyleditemdelegate&quot;&gt;QStyledItemDelegate&lt;/a&gt; class description to find out which datatypes and roles are supported. You can read more about item data roles in &lt;a href=&quot;model-view-programming#&quot;&gt;Model/View Programming&lt;/a&gt;.</source>
          <target state="translated">뷰의 항목 그림은 대리인이 수행합니다. Qt의 기본 대리자 인 &lt;a href=&quot;qstyleditemdelegate&quot;&gt;QStyledItemDelegate&lt;/a&gt; 는 항목의 경계 사각형 및 &lt;a href=&quot;qstyleditemdelegate&quot;&gt;QStyledItemDelegate가&lt;/a&gt; 지원 하는 다양한 종류의 항목 &lt;a href=&quot;qt#ItemDataRole-enum&quot;&gt;데이터 역할에&lt;/a&gt; 대한 하위 요소를 계산하는 데에도 사용됩니다 . 지원되는 데이터 유형 및 역할을 찾으 려면 &lt;a href=&quot;qstyleditemdelegate&quot;&gt;QStyledItemDelegate&lt;/a&gt; 클래스 설명을 참조하십시오 . &lt;a href=&quot;model-view-programming#&quot;&gt;모델 / 뷰 프로그래밍&lt;/a&gt; 에서 아이템 데이터 역할에 대한 자세한 내용을 읽을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2578f1526d1d3bc4e7da302ac64f8208da590a60" translate="yes" xml:space="preserve">
          <source>The palette may be changed according to the current GUI style in &lt;a href=&quot;qstyle#polish&quot;&gt;QStyle::polish&lt;/a&gt;().</source>
          <target state="translated">팔레트는 &lt;a href=&quot;qstyle#polish&quot;&gt;QStyle :: polish&lt;/a&gt; () 의 현재 GUI 스타일에 따라 변경 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="566bfb6d15bcaa55273b1d60a13fb33b21da202e" translate="yes" xml:space="preserve">
          <source>The pane (frame) of a &lt;a href=&quot;qtabwidget&quot;&gt;QTabWidget&lt;/a&gt;.</source>
          <target state="translated">(A)의 창 (프레임) &lt;a href=&quot;qtabwidget&quot;&gt;QTabWidget&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="42d5db4cda89bb4ff994f5b47830a116f33078d3" translate="yes" xml:space="preserve">
          <source>The panel and empty area are drawn after the menu items. The &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; that the &lt;a href=&quot;qmenubar&quot;&gt;QMenuBar&lt;/a&gt; sends to the style has the bounding rectangles of the items clipped out (i.e., clip region), so you don't need to worry about drawing over the items. The pixel metrics in &lt;a href=&quot;qmenubar&quot;&gt;QMenuBar&lt;/a&gt; are used when the bounding rectangles of the menu bar items are calculated.</source>
          <target state="translated">메뉴 항목 다음에 패널과 빈 영역이 그려집니다. &lt;a href=&quot;qpainter&quot;&gt;QPainter를&lt;/a&gt; 것을 &lt;a href=&quot;qmenubar&quot;&gt;QMenuBar는&lt;/a&gt; 당신이 항목을 통해 그림에 대해 걱정할 필요가 없습니다 스타일로 전송이 밖으로 잘린 항목 (즉, 클립 영역)의 경계 사각형을 가지고있다. &lt;a href=&quot;qmenubar&quot;&gt;QMenuBar&lt;/a&gt; 의 픽셀 메트릭 은 메뉴 막대 항목의 경계 사각형을 계산할 때 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2b8b64ca7f8d36b47f5f52585b11683dbb9fe2fa" translate="yes" xml:space="preserve">
          <source>The panel appears sunken if</source>
          <target state="translated">패널은 다음과 같은 경우 움푹 들어간 것처럼 보입니다.</target>
        </trans-unit>
        <trans-unit id="45c448239a0b44a927bb9010cbceff67cff90f8f" translate="yes" xml:space="preserve">
          <source>The panel component for this style.</source>
          <target state="translated">이 스타일의 패널 구성 요소입니다.</target>
        </trans-unit>
        <trans-unit id="72a22be1d2f81a89a5aeae9a573e69b63fa13743" translate="yes" xml:space="preserve">
          <source>The panel for a menu.</source>
          <target state="translated">메뉴의 패널입니다.</target>
        </trans-unit>
        <trans-unit id="88791e3f08e4bf476d1f4d95a3ded17aebc86be8" translate="yes" xml:space="preserve">
          <source>The panel for a status bar.</source>
          <target state="translated">상태 표시 줄의 패널입니다.</target>
        </trans-unit>
        <trans-unit id="e31287a67db81a5d9bba7da4605aa894db851a52" translate="yes" xml:space="preserve">
          <source>The panel for a tip label.</source>
          <target state="translated">팁 레이블의 패널입니다.</target>
        </trans-unit>
        <trans-unit id="92a48999619746b7ddc023b0d100a75e2fb3d8a2" translate="yes" xml:space="preserve">
          <source>The panel for a toolbar.</source>
          <target state="translated">툴바의 패널입니다.</target>
        </trans-unit>
        <trans-unit id="a96a55ff92d8936ba7df678fe54ad00d380ff7f9" translate="yes" xml:space="preserve">
          <source>The panel is modal to a single item hierarchy and blocks input to its parent pane, all grandparent panels, and all siblings of its parent and grandparent panels.</source>
          <target state="translated">이 패널은 단일 항목 계층 구조에 모달이며 상위 창, 모든 조부모 패널 및 상위 및 조부모 패널의 모든 형제에 대한 입력을 차단합니다.</target>
        </trans-unit>
        <trans-unit id="3af1c22846e50bfcc558ce9e04c711e5ac9e5115" translate="yes" xml:space="preserve">
          <source>The panel is not modal and does not block input to other panels. This is the default value for panels.</source>
          <target state="translated">이 패널은 모달이 아니며 다른 패널에 대한 입력을 차단하지 않습니다. 이것이 패널의 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="4b1bfd1216254568527a8ea615d71edeff564cc2" translate="yes" xml:space="preserve">
          <source>The panel is set into operation by setting the &lt;a href=&quot;qml-qtquick-virtualkeyboard-handwritinginputpanel#available-prop&quot;&gt;available&lt;/a&gt; property to &lt;code&gt;true&lt;/code&gt;. When the panel is in operation, the keyboard remains hidden when the input focus is set. When &lt;code&gt;available&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, handwriting input is activated by setting the &lt;a href=&quot;qml-qtquick-virtualkeyboard-handwritinginputpanel#active-prop&quot;&gt;active&lt;/a&gt; property to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-virtualkeyboard-handwritinginputpanel#available-prop&quot;&gt;available&lt;/a&gt; 속성을 &lt;code&gt;true&lt;/code&gt; 로 설정하면 패널이 작동 합니다 . 패널이 작동 중일 때 입력 포커스가 설정되면 키보드가 숨겨져 있습니다. 되면 &lt;code&gt;available&lt;/code&gt; 하다 &lt;code&gt;true&lt;/code&gt; 필기 입력을 상기 설정에 의해 활성화되어 &lt;a href=&quot;qml-qtquick-virtualkeyboard-handwritinginputpanel#active-prop&quot;&gt;활성&lt;/a&gt; 에 속성 &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="735dfe8f51791d3117d33ecc84c95f6803af8279" translate="yes" xml:space="preserve">
          <source>The parallelism in the State Machine framework follows an interleaved semantics. All parallel operations will be executed in a single, atomic step of the event processing, so no event can interrupt the parallel operations. However, events will still be processed sequentially, as the machine itself is single threaded. For example, consider the situation where there are two transitions that exit the same parallel state group, and their conditions become true simultaneously. In this case, the event that is processed last of the two will not have any effect.</source>
          <target state="translated">State Machine 프레임 워크의 병렬 처리는 인터리브 의미론을 따릅니다. 모든 병렬 작업은 이벤트 처리의 단일 원자 단계에서 실행되므로 이벤트가 병렬 작업을 중단 할 수 없습니다. 그러나 머신 자체는 단일 스레드이므로 이벤트는 계속 순차적으로 처리됩니다. 예를 들어, 동일한 병렬 상태 그룹을 종료하는 두 개의 전이가 있고 해당 조건이 동시에 참인 상황을 고려하십시오. 이 경우 두 가지 중 마지막으로 처리 된 이벤트는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b9c765e4bac1fd37cd3da05bed1efe3ac75c24c8" translate="yes" xml:space="preserve">
          <source>The parallelism in the State Machine framework follows an interleaved semantics. All parallel operations will be executed in a single, atomic step of the event processing, so no event can interrupt the parallel operations. However, events will still be processed sequentially, since the machine itself is single threaded. As an example: Consider the situation where there are two transitions that exit the same parallel state group, and their conditions become true simultaneously. In this case, the event that is processed last of the two will not have any effect, since the first event will already have caused the machine to exit from the parallel state.</source>
          <target state="translated">State Machine 프레임 워크의 병렬 처리는 인터리브 의미론을 따릅니다. 모든 병렬 작업은 이벤트 처리의 단일 원자 단계에서 실행되므로 이벤트가 병렬 작업을 중단 할 수 없습니다. 그러나 머신 자체는 단일 스레드이므로 이벤트는 계속 순차적으로 처리됩니다. 예를 들어, 동일한 병렬 상태 그룹을 종료하는 두 개의 전이가 있고 해당 조건이 동시에 적용되는 상황을 고려하십시오. 이 경우 두 이벤트 중 마지막으로 처리 된 이벤트는 아무런 영향을 미치지 않습니다. 첫 번째 이벤트로 인해 머신이 병렬 상태에서 이미 종료 되었기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="784cb28a84eb456a412592e7c8f03f7f73dee959" translate="yes" xml:space="preserve">
          <source>The parameter</source>
          <target state="translated">매개 변수</target>
        </trans-unit>
        <trans-unit id="7561eca069691e915947678d30e361f9de4f8013" translate="yes" xml:space="preserve">
          <source>The parameter given with the gestureStarted signal. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">gestureStarted 신호와 함께 제공된 매개 변수입니다. &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2ba944785a9a2fc710a85c160ba5a41b3628825d" translate="yes" xml:space="preserve">
          <source>The parameter holds the</source>
          <target state="translated">매개 변수는</target>
        </trans-unit>
        <trans-unit id="2a5a3bd056afed08e5aced10965ea2ba16bedae8" translate="yes" xml:space="preserve">
          <source>The parameter to this function should be one of the types reported by the &lt;a href=&quot;qaudiodeviceinfo#supportedCodecs&quot;&gt;QAudioDeviceInfo::supportedCodecs&lt;/a&gt;() function for the audio device you are working with.</source>
          <target state="translated">이 함수의 매개 변수 는 작업중인 오디오 장치 에 대한 &lt;a href=&quot;qaudiodeviceinfo#supportedCodecs&quot;&gt;QAudioDeviceInfo :: supportedCodecs&lt;/a&gt; () 함수에 의해보고되는 유형 중 하나 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="6b1ad09038b422ea553ab204de402529e9b64c23" translate="yes" xml:space="preserve">
          <source>The parameter value to be used with this key is a &lt;a href=&quot;qurl&quot;&gt;QUrl&lt;/a&gt;. An icon with this parameter set will always return the specified URL regardless of the requested size when &lt;a href=&quot;qplaceicon#url&quot;&gt;url&lt;/a&gt;() is called.</source>
          <target state="translated">이 키와 함께 사용되는 매개 변수 값은 &lt;a href=&quot;qurl&quot;&gt;QUrl&lt;/a&gt; 입니다. 이 매개 변수가 설정된 아이콘은 &lt;a href=&quot;qplaceicon#url&quot;&gt;url&lt;/a&gt; ()이 호출 될 때 요청 된 크기에 관계없이 항상 지정된 URL을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="694b17a392c48aafa85d73c8f3addc51dc5351be" translate="yes" xml:space="preserve">
          <source>The parameters</source>
          <target state="translated">매개 변수</target>
        </trans-unit>
        <trans-unit id="7ddad8d495816a1c4029ec1a45ce8e83e779b86c" translate="yes" xml:space="preserve">
          <source>The parameters &lt;a href=&quot;qgraphicsscale#xScale-prop&quot;&gt;xScale&lt;/a&gt;, &lt;a href=&quot;qgraphicsscale#yScale-prop&quot;&gt;yScale&lt;/a&gt;, and &lt;a href=&quot;qgraphicsscale#zScale-prop&quot;&gt;zScale&lt;/a&gt; describe the scale factors to apply in horizontal, vertical, and depth directions. They can take on any value, including 0 (to collapse the item to a point) or negative value. A negative &lt;a href=&quot;qgraphicsscale#xScale-prop&quot;&gt;xScale&lt;/a&gt; value will mirror the item horizontally. A negative &lt;a href=&quot;qgraphicsscale#yScale-prop&quot;&gt;yScale&lt;/a&gt; value will flip the item vertically. A negative &lt;a href=&quot;qgraphicsscale#zScale-prop&quot;&gt;zScale&lt;/a&gt; will flip the item end for end.</source>
          <target state="translated">&lt;a href=&quot;qgraphicsscale#xScale-prop&quot;&gt;xScale&lt;/a&gt; , &lt;a href=&quot;qgraphicsscale#yScale-prop&quot;&gt;yScale&lt;/a&gt; 및 &lt;a href=&quot;qgraphicsscale#zScale-prop&quot;&gt;zScale&lt;/a&gt; 매개 변수 는 가로, 세로 및 깊이 방향으로 적용 할 배율을 설명합니다. 0 (항목을 포인트로 축소) 또는 음수 값을 포함한 모든 값을 사용할 수 있습니다. 음의 &lt;a href=&quot;qgraphicsscale#xScale-prop&quot;&gt;xScale&lt;/a&gt; 값은 항목을 가로로 미러링합니다. 음의 &lt;a href=&quot;qgraphicsscale#yScale-prop&quot;&gt;yScale&lt;/a&gt; 값은 항목을 세로로 뒤집습니다. 음수 &lt;a href=&quot;qgraphicsscale#zScale-prop&quot;&gt;zScale&lt;/a&gt; 은 항목 끝을 뒤집습니다.</target>
        </trans-unit>
        <trans-unit id="7d6911c8bd17ced8d3ead7cc73277a5e16d1836b" translate="yes" xml:space="preserve">
          <source>The parameters to &lt;code&gt;call&lt;/code&gt; are passed on to the remote function via D-Bus as input arguments. Output arguments are returned in the &lt;a href=&quot;qdbusmessage&quot;&gt;QDBusMessage&lt;/a&gt; reply. If the reply is an error reply, &lt;a href=&quot;qdbusabstractinterface#lastError&quot;&gt;lastError&lt;/a&gt;() will also be set to the contents of the error message.</source>
          <target state="translated">&lt;code&gt;call&lt;/code&gt; 할 파라미터 는 입력 인수로 D-Bus를 통해 원격 기능에 전달됩니다. 출력 인수는 &lt;a href=&quot;qdbusmessage&quot;&gt;QDBusMessage&lt;/a&gt; 응답에 리턴됩니다 . 응답이 오류 응답 인 경우 &lt;a href=&quot;qdbusabstractinterface#lastError&quot;&gt;lastError&lt;/a&gt; ()도 오류 메시지의 내용으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="d41d9c64f20cf3635daea3fca256790b4b9b9f93" translate="yes" xml:space="preserve">
          <source>The parameters to &lt;code&gt;call&lt;/code&gt; are passed on to the remote function via D-Bus as input arguments. The returned &lt;a href=&quot;qdbuspendingcall&quot;&gt;QDBusPendingCall&lt;/a&gt; object can be used to find out information about the reply.</source>
          <target state="translated">&lt;code&gt;call&lt;/code&gt; 할 파라미터 는 입력 인수로 D-Bus를 통해 원격 기능에 전달됩니다. 리턴 된 &lt;a href=&quot;qdbuspendingcall&quot;&gt;QDBusPendingCall&lt;/a&gt; 오브젝트를 사용하여 응답에 대한 정보를 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="09c441c6459cf598b536986f53ef6daa3e551806" translate="yes" xml:space="preserve">
          <source>The parent &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; of the provided document remains the owner of the object. If the current document is a child of the text editor, then it is deleted.</source>
          <target state="translated">제공된 문서 의 상위 &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 는 오브젝트 소유자로 유지됩니다. 현재 문서가 텍스트 편집기의 하위 인 경우 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="428a3d496895536d4313a14d74d47af36b632cb2" translate="yes" xml:space="preserve">
          <source>The parent &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; of the provided page remains the owner of the object. If the current page is a child of the web view, it will be deleted.</source>
          <target state="translated">제공된 페이지 의 상위 &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 는 오브젝트의 소유자로 유지됩니다. 현재 페이지가 웹보기의 하위 인 경우 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="89ef80ca5aab15f94be8464d6b28a86241869e54" translate="yes" xml:space="preserve">
          <source>The parent in this case is usually an empty command, in that it doesn't provide its own implementation of &lt;a href=&quot;qundocommand#undo&quot;&gt;undo&lt;/a&gt;() and &lt;a href=&quot;qundocommand#redo&quot;&gt;redo&lt;/a&gt;(). Instead, it uses the base implementations of these functions, which simply call &lt;a href=&quot;qundocommand#undo&quot;&gt;undo&lt;/a&gt;() or &lt;a href=&quot;qundocommand#redo&quot;&gt;redo&lt;/a&gt;() on all its children. The parent should, however, have a meaningful &lt;a href=&quot;qundocommand#text&quot;&gt;text&lt;/a&gt;().</source>
          <target state="translated">이 경우 부모는 일반적으로 &lt;a href=&quot;qundocommand#undo&quot;&gt;실행 취소&lt;/a&gt; () 및 &lt;a href=&quot;qundocommand#redo&quot;&gt;다시 &lt;/a&gt;실행 () 의 자체 구현을 제공하지 않기 때문에 빈 명령 입니다. 대신이 함수의 기본 구현을 사용하며 모든 자식에 대해 단순히 &lt;a href=&quot;qundocommand#undo&quot;&gt;undo&lt;/a&gt; () 또는 &lt;a href=&quot;qundocommand#redo&quot;&gt;redo&lt;/a&gt; ()를 호출 합니다. 그러나 부모에게는 의미있는 &lt;a href=&quot;qundocommand#text&quot;&gt;텍스트&lt;/a&gt; () 가 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="4b1d3ca22b5d9e0a942f86877e5aab8d364696a8" translate="yes" xml:space="preserve">
          <source>The parent index is normally used to determine where in the model the rows should be added. In this case, we only have a single top-level list of strings, so we just insert empty strings into that list.</source>
          <target state="translated">부모 인덱스는 일반적으로 모델에서 행을 추가 할 위치를 결정하는 데 사용됩니다. 이 경우 단일 최상위 문자열 목록 만 있으므로 빈 문자열을 해당 목록에 삽입하기 만하면됩니다.</target>
        </trans-unit>
        <trans-unit id="a884c86adb626d4162142967a01eac98e2310e83" translate="yes" xml:space="preserve">
          <source>The parent of a &lt;a href=&quot;qt3dcore-qnode&quot;&gt;QNode&lt;/a&gt; instance can only be another &lt;a href=&quot;qt3dcore-qnode&quot;&gt;QNode&lt;/a&gt; instance.</source>
          <target state="translated">&lt;a href=&quot;qt3dcore-qnode&quot;&gt;QNode&lt;/a&gt; 인스턴스 의 상위는 다른 &lt;a href=&quot;qt3dcore-qnode&quot;&gt;QNode&lt;/a&gt; 인스턴스 만 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="de42e8e2e29cf1acc1fd0413fbc37b33267e9809" translate="yes" xml:space="preserve">
          <source>The parent of a QNode instance can only be another QNode instance.</source>
          <target state="translated">QNode 인스턴스의 부모는 다른 QNode 인스턴스 만 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9fa1048ed9775ca0943118cf45d39348b23d2626" translate="yes" xml:space="preserve">
          <source>The parent of an object may be viewed as the object's owner. For instance, a &lt;a href=&quot;qdialog&quot;&gt;dialog box&lt;/a&gt; is the parent of the &lt;b&gt;OK&lt;/b&gt; and &lt;b&gt;Cancel&lt;/b&gt; buttons it contains.</source>
          <target state="translated">객체의 부모는 객체의 소유자로 볼 수 있습니다. 예를 들어, &lt;a href=&quot;qdialog&quot;&gt;대화 상자&lt;/a&gt; 는 포함 된 &lt;b&gt;확인&lt;/b&gt; 및 &lt;b&gt;취소&lt;/b&gt; 버튼 의 부모입니다 .</target>
        </trans-unit>
        <trans-unit id="5688fa831352bb78f6c78602223947cf71fd880b" translate="yes" xml:space="preserve">
          <source>The parent of the context node</source>
          <target state="translated">컨텍스트 노드의 부모</target>
        </trans-unit>
        <trans-unit id="e1cae10b811de36ada11d61050b3183d81720f4f" translate="yes" xml:space="preserve">
          <source>The parent of the model index passed to &lt;a href=&quot;qabstractitemmodel#checkIndex&quot;&gt;QAbstractItemModel::checkIndex&lt;/a&gt;() is checked to be an invalid model index. If both this option and DoNotUseParent are specified, then this option is ignored.</source>
          <target state="translated">&lt;a href=&quot;qabstractitemmodel#checkIndex&quot;&gt;QAbstractItemModel :: checkIndex&lt;/a&gt; ()에 전달 된 모델 색인의 상위가 유효하지 않은 모델 색인인지 확인합니다. 이 옵션과 DoNotUseParent가 모두 지정된 경우이 옵션은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="0dff7fb5aaabe08b65ad1cfb3576c4981451b0d7" translate="yes" xml:space="preserve">
          <source>The parent state machine treats the child machine as an</source>
          <target state="translated">부모 상태 머신은 자식 머신을</target>
        </trans-unit>
        <trans-unit id="d3856d78dd1ad16d0b29b82acdf3ae6044d7590e" translate="yes" xml:space="preserve">
          <source>The parent's &lt;a href=&quot;qml-qtquick-item#children-prop&quot;&gt;children&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-item#childrenRect.x-prop&quot;&gt;childrenRect&lt;/a&gt; properties takes that child into account</source>
          <target state="translated">부모의 &lt;a href=&quot;qml-qtquick-item#children-prop&quot;&gt;children&lt;/a&gt; 및 &lt;a href=&quot;qml-qtquick-item#childrenRect.x-prop&quot;&gt;childrenRect&lt;/a&gt; 속성은 해당 자식을 고려합니다.</target>
        </trans-unit>
        <trans-unit id="4d1eeb99c65938013e508e170c1c60e284a4e99d" translate="yes" xml:space="preserve">
          <source>The parent, &lt;code&gt;window&lt;/code&gt;, and the child, &lt;code&gt;quit&lt;/code&gt;, are both &lt;a href=&quot;qobject&quot;&gt;QObjects&lt;/a&gt; because &lt;a href=&quot;qpushbutton&quot;&gt;QPushButton&lt;/a&gt; inherits &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt;, and &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; inherits &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;. This code is correct: the destructor of &lt;code&gt;quit&lt;/code&gt; is</source>
          <target state="translated">부모, &lt;code&gt;window&lt;/code&gt; , 그리고 아이는, &lt;code&gt;quit&lt;/code&gt; , 모두 &lt;a href=&quot;qobject&quot;&gt;QObjects&lt;/a&gt; 때문에 &lt;a href=&quot;qpushbutton&quot;&gt;QPushButton을가&lt;/a&gt; 상속 &lt;a href=&quot;qwidget&quot;&gt;는 QWidget을&lt;/a&gt; 하고 &lt;a href=&quot;qwidget&quot;&gt;는 QWidget&lt;/a&gt; 상속 &lt;a href=&quot;qobject&quot;&gt;QObject를&lt;/a&gt; . 이 코드는 정확합니다 : &lt;code&gt;quit&lt;/code&gt; 의 소멸자 는</target>
        </trans-unit>
        <trans-unit id="d558f902f9c96ec1568fc4e234bf4e7c4ac3d68f" translate="yes" xml:space="preserve">
          <source>The parental rating of the media.</source>
          <target state="translated">미디어의 보호자 등급입니다.</target>
        </trans-unit>
        <trans-unit id="60d88ba9be319f5f1d8aa1e88c099007a422284c" translate="yes" xml:space="preserve">
          <source>The parsed XML is represented internally by a tree of objects that can be accessed using the various QDom classes. All QDom classes only</source>
          <target state="translated">구문 분석 된 XML은 다양한 QDom 클래스를 사용하여 액세스 할 수있는 객체 트리로 내부적으로 표시됩니다. 모든 QDom 클래스 만</target>
        </trans-unit>
        <trans-unit id="04c28d15165bf347bec3a99485083d887a21e7b9" translate="yes" xml:space="preserve">
          <source>The parsed document contains additional garbage characters at the end</source>
          <target state="translated">파싱 ​​된 문서는 끝에 추가 가비지 문자를 포함합니다</target>
        </trans-unit>
        <trans-unit id="72399411668e43b93e124615dec9c44789d44e04" translate="yes" xml:space="preserve">
          <source>The parser does not automatically support negating or disabling long options by using the format &lt;code&gt;--disable-option&lt;/code&gt; or &lt;code&gt;--no-option&lt;/code&gt;. However, it is possible to handle this case explicitly by making an option with &lt;code&gt;no-option&lt;/code&gt; as one of its names, and handling the option explicitly.</source>
          <target state="translated">파서는 &lt;code&gt;--disable-option&lt;/code&gt; 또는 &lt;code&gt;--no-option&lt;/code&gt; 형식을 사용하여 긴 옵션 무시 또는 비활성화를 자동으로 지원하지 않습니다 . 그러나 &lt;code&gt;no-option&lt;/code&gt; 중 하나를 옵션 으로 사용 하지 않고 옵션을 명시 적으로 처리하여이 경우를 명시 적으로 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="a7288b44e527d71bfe35e964c3448b28051469d7" translate="yes" xml:space="preserve">
          <source>The parser does not support optional values - if an option is set to require a value, one must be present. If such an option is placed last and has no value, the option will be treated as if it had not been specified.</source>
          <target state="translated">구문 분석기는 선택적 값을 지원하지 않습니다. 옵션이 값을 요구하도록 설정되어 있으면 옵션이 있어야합니다. 이러한 옵션이 마지막에 배치되고 값이 없으면 옵션이 지정되지 않은 것처럼 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="dcb11afa0113e1364dd48addf04e1edfe61dd980" translate="yes" xml:space="preserve">
          <source>The parser encountered an element that was different to those it expected.</source>
          <target state="translated">구문 분석기가 예상 한 것과 다른 요소를 발견했습니다.</target>
        </trans-unit>
        <trans-unit id="de35c21561438919be50c5a3319dfee8db036714" translate="yes" xml:space="preserve">
          <source>The parser handles short names, long names, more than one name for the same option, and option values.</source>
          <target state="translated">파서는 짧은 이름, 긴 이름, 동일한 옵션에 대한 둘 이상의 이름 및 옵션 값을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="7275885a4e9bd2128ef144ae4e2a18965cca2cbc" translate="yes" xml:space="preserve">
          <source>The parser internally raised an error due to the read XML not being well-formed.</source>
          <target state="translated">읽기 XML의 형식이 잘못되어 구문 분석기에서 내부적으로 오류가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="75f0dfedc3a42760c71f4561f8b96097929e182d" translate="yes" xml:space="preserve">
          <source>The parser reads</source>
          <target state="translated">파서는 읽습니다</target>
        </trans-unit>
        <trans-unit id="4c3858d817558aad7eb6ec0ce08a2df086d1e16c" translate="yes" xml:space="preserve">
          <source>The parser supports only the features standardized by CommonMark</source>
          <target state="translated">파서는 CommonMark에서 표준화 한 기능 만 지원합니다.</target>
        </trans-unit>
        <trans-unit id="9584be660c9af9b39474dadfada5d2ddc1f0c742" translate="yes" xml:space="preserve">
          <source>The parser supports the GitHub dialect</source>
          <target state="translated">파서는 GitHub 언어를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="d2f68186cb6ec81aa92a34769541e54738a3b85d" translate="yes" xml:space="preserve">
          <source>The parsing for the string is complete, with no error.</source>
          <target state="translated">문자열의 구문 분석이 완료되었으며 오류는 없습니다.</target>
        </trans-unit>
        <trans-unit id="de0c3489181c8d4d60078ceb5cf9d8bdfeb95792" translate="yes" xml:space="preserve">
          <source>The parsing mode controls the way &lt;a href=&quot;qurl&quot;&gt;QUrl&lt;/a&gt; parses strings.</source>
          <target state="translated">구문 분석 모드는 &lt;a href=&quot;qurl&quot;&gt;QUrl이&lt;/a&gt; 문자열을 구문 분석 하는 방식을 제어합니다 .</target>
        </trans-unit>
        <trans-unit id="b40b40683a10c35c397bc8b68e06b5ba2c4bf325" translate="yes" xml:space="preserve">
          <source>The part of this document that does not concern the styling of individual widgets is meant to be read sequentially because later sections tend to depend on earlier ones. The description of the widgets can be used for reference while implementing a style. However, you may need to consult the Qt source code in some cases. The sequence in the styling process should become clear after reading this document, which will aid you in locating relevant code.</source>
          <target state="translated">개별 위젯의 스타일과 관련이없는이 문서의 일부는 이후 섹션이 이전 위젯에 의존하는 경향이 있으므로 순차적으로 읽도록되어 있습니다. 위젯 설명은 스타일을 구현하는 동안 참조 용으로 사용할 수 있습니다. 그러나 경우에 따라 Qt 소스 코드를 참조해야 할 수도 있습니다. 이 문서를 읽은 후에는 스타일링 과정의 순서가 명확 해 지므로 관련 코드를 찾는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="b972776876c0b50de3e070a4f52846bd33ea971d" translate="yes" xml:space="preserve">
          <source>The partial file did not match the expected hash.</source>
          <target state="translated">부분 파일이 예상 된 해시와 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b71bd4743b65c449af52f02f659464ce3bb5ac47" translate="yes" xml:space="preserve">
          <source>The partially checked state can be made available to the user by setting &lt;a href=&quot;qml-qtquick-controls-checkbox#partiallyCheckedEnabled-prop&quot;&gt;partiallyCheckedEnabled&lt;/a&gt; to &lt;code&gt;true&lt;/code&gt;, or set directly by setting &lt;a href=&quot;qml-qtquick-controls-checkbox#checkedState-prop&quot;&gt;checkedState&lt;/a&gt; to &lt;code&gt;Qt.PartiallyChecked&lt;/code&gt;. &lt;a href=&quot;qml-qtquick-controls-checkbox#checkedState-prop&quot;&gt;checkedState&lt;/a&gt; behaves identically to &lt;a href=&quot;qml-qtquick-controls-checkbox#checked-prop&quot;&gt;checked&lt;/a&gt; when &lt;a href=&quot;qml-qtquick-controls-checkbox#partiallyCheckedEnabled-prop&quot;&gt;partiallyCheckedEnabled&lt;/a&gt; is &lt;code&gt;false&lt;/code&gt;; setting one will appropriately set the other.</source>
          <target state="translated">부분적으로 선택 상태로 설정하여 사용자에게 제공 될 수 &lt;a href=&quot;qml-qtquick-controls-checkbox#partiallyCheckedEnabled-prop&quot;&gt;partiallyCheckedEnabled을&lt;/a&gt; 에 &lt;code&gt;true&lt;/code&gt; 또는 설정하여 설정 &lt;a href=&quot;qml-qtquick-controls-checkbox#checkedState-prop&quot;&gt;checkedState을&lt;/a&gt; 에 &lt;code&gt;Qt.PartiallyChecked&lt;/code&gt; . &lt;a href=&quot;qml-qtquick-controls-checkbox#checkedState-prop&quot;&gt;checkedState는&lt;/a&gt; 같은 동작을 &lt;a href=&quot;qml-qtquick-controls-checkbox#checked-prop&quot;&gt;확인할&lt;/a&gt; 때 &lt;a href=&quot;qml-qtquick-controls-checkbox#partiallyCheckedEnabled-prop&quot;&gt;partiallyCheckedEnabled이&lt;/a&gt; 있다 &lt;code&gt;false&lt;/code&gt; ; 하나를 설정하면 다른 하나가 적절하게 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="33540611ed5a6195ba73d97065f3e4cafec03dbc" translate="yes" xml:space="preserve">
          <source>The particle coordinates are not transformed.</source>
          <target state="translated">입자 좌표는 변환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="24ee4582a9fdebce90f1ab9fee343175c7b29bb0" translate="yes" xml:space="preserve">
          <source>The particle system contains several types which represent shapes. These types do not visualize shapes, and are used for the purpose of selecting a random point within the shape. If you want a specific point with no randomness, use a 0 width and 0 height shape (which is the default). Otherwise you can use the shape types to specify an area, so that the result can use a random point selected from that area.</source>
          <target state="translated">입자 시스템에는 모양을 나타내는 여러 유형이 있습니다. 이러한 유형은 모양을 시각화하지 않으며 모양 내에서 임의의 점을 선택하기 위해 사용됩니다. 임의의 점이없는 특정 점을 원하면 너비와 높이가 0 인 모양 (기본값)을 사용하십시오. 그렇지 않으면 모양 유형을 사용하여 영역을 지정하여 결과에서 해당 영역에서 선택한 임의의 점을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea5de140641ad1b4cdae8cf52e6b43d9fed96701" translate="yes" xml:space="preserve">
          <source>The passed local adapter address does not match the physical adapter address of any local Bluetooth device.</source>
          <target state="translated">전달 된 로컬 어댑터 주소가 로컬 Bluetooth 장치의 실제 어댑터 주소와 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="592b60c5fb4d8ceb70ca51a41fedca953cdf8bbe" translate="yes" xml:space="preserve">
          <source>The passed local adapter address does not match the physical adapter address of any local Bluetooth device. This value was introduced by Qt 5.3.</source>
          <target state="translated">전달 된 로컬 어댑터 주소가 로컬 Bluetooth 장치의 실제 어댑터 주소와 일치하지 않습니다. 이 값은 Qt 5.3에 의해 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="415b720033afe3ee63e252f88b60463d0cabc25f" translate="yes" xml:space="preserve">
          <source>The password and fragment are removed from the url.</source>
          <target state="translated">비밀번호와 조각이 URL에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="10a5d7e2131394ef0c0794e80200477ab57e4f74" translate="yes" xml:space="preserve">
          <source>The password character can be styled using the &lt;a href=&quot;#lineedit-password-character-prop&quot;&gt;lineedit-password-character&lt;/a&gt; property.</source>
          <target state="translated">암호 문자는 &lt;a href=&quot;#lineedit-password-character-prop&quot;&gt;lineedit-password-character&lt;/a&gt; 속성을 사용하여 스타일을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8b190d3dbe4b6b4bf9126735ea580f46b3d8bb64" translate="yes" xml:space="preserve">
          <source>The password character can be styled using the &lt;a href=&quot;stylesheet-reference#lineedit-password-character-prop&quot;&gt;lineedit-password-character&lt;/a&gt; property.</source>
          <target state="translated">암호 문자는 &lt;a href=&quot;stylesheet-reference#lineedit-password-character-prop&quot;&gt;lineedit-password-character&lt;/a&gt; 속성을 사용하여 스타일을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="68e81a5d440003bf217e4205aca07f8474c499ae" translate="yes" xml:space="preserve">
          <source>The password character that is displayed when echoMode on the &lt;a href=&quot;qml-qtquick-controls-textfield&quot;&gt;TextField&lt;/a&gt; is set to &lt;a href=&quot;qml-qtquick-textinput&quot;&gt;TextInput&lt;/a&gt;.Password or &lt;a href=&quot;qml-qtquick-textinput&quot;&gt;TextInput&lt;/a&gt;.PasswordEchoOnEdit.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-controls-textfield&quot;&gt;TextField의&lt;/a&gt; echoMode 가 &lt;a href=&quot;qml-qtquick-textinput&quot;&gt;TextInput&lt;/a&gt; .Password 또는 &lt;a href=&quot;qml-qtquick-textinput&quot;&gt;TextInput&lt;/a&gt; .PasswordEchoOnEdit으로 설정된 경우 표시되는 비밀번호 문자입니다 .</target>
        </trans-unit>
        <trans-unit id="6ba4acfef81ff084422c8b1c839393952ce5c081" translate="yes" xml:space="preserve">
          <source>The password mask delay can be changed using the &lt;a href=&quot;#lineedit-password-mask-delay-prop&quot;&gt;lineedit-password-mask-delay&lt;/a&gt;</source>
          <target state="translated">암호 마스크 지연은 &lt;a href=&quot;#lineedit-password-mask-delay-prop&quot;&gt;lineedit-password-mask-delay를&lt;/a&gt; 사용하여 변경할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="884b3d14cd582b7a8cb93e5ff89ba05f01f38938" translate="yes" xml:space="preserve">
          <source>The password mask delay can be changed using the &lt;a href=&quot;stylesheet-reference#lineedit-password-mask-delay-prop&quot;&gt;lineedit-password-mask-delay&lt;/a&gt;</source>
          <target state="translated">암호 마스크 지연은 다음 줄을 사용하여 변경할 수 있습니다 &lt;a href=&quot;stylesheet-reference#lineedit-password-mask-delay-prop&quot;&gt;.edit-password-mask-delay&lt;/a&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
