<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="qt">
    <body>
      <group id="qt">
        <trans-unit id="95a0ec35d37c15ab8940e0ae4a809d581531fb45" translate="yes" xml:space="preserve">
          <source>The following table lists values that can be used to configure the &lt;a href=&quot;qtquickcontrols2-universal#&quot;&gt;Universal style&lt;/a&gt; in a &lt;code&gt;Universal&lt;/code&gt; section of the configuration file:</source>
          <target state="translated">다음 표 는 구성 파일 의 &lt;code&gt;Universal&lt;/code&gt; 섹션 에서 &lt;a href=&quot;qtquickcontrols2-universal#&quot;&gt;범용 스타일&lt;/a&gt; 을 구성하는 데 사용할 수있는 값을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="c572c44c98d67fec56b617df3b7699e60f8701c4" translate="yes" xml:space="preserve">
          <source>The following table lists which elements are supported for each control, along with the possible states for that element, and the file extension that it expects. An element is an image that represents a certain visual part of the control. For example, &lt;code&gt;Button&lt;/code&gt;'s &lt;code&gt;&quot;background&quot;&lt;/code&gt; element represents its &lt;a href=&quot;qml-qtquick-controls2-control#background-prop&quot;&gt;background&lt;/a&gt;.</source>
          <target state="translated">다음 표에는 각 컨트롤에 지원되는 요소와 해당 요소의 가능한 상태 및 예상되는 파일 확장자가 나와 있습니다. 요소는 컨트롤의 특정 시각적 부분을 나타내는 이미지입니다. 예를 들어, &lt;code&gt;Button&lt;/code&gt; 의 &lt;code&gt;&quot;background&quot;&lt;/code&gt; 요소는 &lt;a href=&quot;qml-qtquick-controls2-control#background-prop&quot;&gt;배경을&lt;/a&gt; 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="22baee913eabf5fb3c81c02ff2a442feb273d5a1" translate="yes" xml:space="preserve">
          <source>The following table provides links to more detailed information on sections of the Qt Location C++ API.</source>
          <target state="translated">다음 표는 Qt Location C ++ API의 섹션에 대한 자세한 정보에 대한 링크를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="9521f9866f39c7e2113b0cd585be295f580b5772" translate="yes" xml:space="preserve">
          <source>The following table shows the mask and meta characters that can be used in an input mask.</source>
          <target state="translated">The following table shows the mask and meta characters that can be used in an input mask.</target>
        </trans-unit>
        <trans-unit id="5c5d386f6b62b05da5c220df70d0a345634b2eed" translate="yes" xml:space="preserve">
          <source>The following table shows which class and function are responsible for printing from a selection of different widgets. For widgets that do not expose printing functionality directly, the content handling classes containing this functionality can be obtained via a function in the corresponding widget's API.</source>
          <target state="translated">다음 표는 다양한 위젯 선택에서 인쇄를 담당하는 클래스와 함수를 보여줍니다. 인쇄 기능을 직접 노출하지 않는 위젯의 경우 해당 기능을 포함하는 컨텐츠 처리 클래스는 해당 위젯 API의 함수를 통해 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3cfd1e298fa6acb8f23478ac189c00bf5c25aac3" translate="yes" xml:space="preserve">
          <source>The following table summarizes the &lt;a href=&quot;qlistiterator&quot;&gt;QListIterator&lt;/a&gt; API:</source>
          <target state="translated">다음 표는 &lt;a href=&quot;qlistiterator&quot;&gt;QListIterator&lt;/a&gt; API를 요약 한 것입니다 .</target>
        </trans-unit>
        <trans-unit id="281c9ab04eb6f1f40aa7f48341b24ae13e7f4678" translate="yes" xml:space="preserve">
          <source>The following table summarizes the STL-style iterators' API:</source>
          <target state="translated">다음 표는 STL 스타일 반복자의 API를 요약 한 것입니다.</target>
        </trans-unit>
        <trans-unit id="d29f64a9ad6ce8cf47b1315849008df5bf9fc911" translate="yes" xml:space="preserve">
          <source>The following table summarizes the algorithmic complexity of Qt's associative containers and sets:</source>
          <target state="translated">다음 표는 Qt 연관 컨테이너 및 세트의 알고리즘 복잡성을 요약합니다.</target>
        </trans-unit>
        <trans-unit id="dd49aec97ed38f2041e59e13e5a27ccb302b781a" translate="yes" xml:space="preserve">
          <source>The following table summarizes the algorithmic complexity of Qt's sequential container classes:</source>
          <target state="translated">다음 표는 Qt의 순차적 컨테이너 클래스의 알고리즘 복잡성을 요약합니다.</target>
        </trans-unit>
        <trans-unit id="cb7fec406f7aa71f1da02bdff5598289857db119" translate="yes" xml:space="preserve">
          <source>The following table summarizes the algorithmic complexity of the sequential container &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt;&amp;lt;T&amp;gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36eed4145ee5a2b0d2bc0300a09f8b664db55fa0" translate="yes" xml:space="preserve">
          <source>The following table summarizes the platform plugins available for QPA:</source>
          <target state="translated">다음 표는 QPA에 사용 가능한 플랫폼 플러그인을 요약합니다.</target>
        </trans-unit>
        <trans-unit id="9d03b2c122f368e4fda5c1c39bc8f2a59bc74ef9" translate="yes" xml:space="preserve">
          <source>The following table summarizes the platform plugins available:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="519558fa67924f470afa0b1daf547246d9cf5e50" translate="yes" xml:space="preserve">
          <source>The following table summarizes the plugin base classes. Some of the classes are private, and are therefore not documented. You can use them, but there is no compatibility promise with later Qt versions.</source>
          <target state="translated">다음 표는 플러그인 기본 클래스를 요약합니다. 일부 수업은 개인 수업이므로 문서화되어 있지 않습니다. 그것들을 사용할 수는 있지만 이후 Qt 버전과의 호환성 약속은 없습니다.</target>
        </trans-unit>
        <trans-unit id="e13fa5fd99f165f3246925ba8ab1ab69811b3d58" translate="yes" xml:space="preserve">
          <source>The following table summarizes the syntax and meaning of the different property types.</source>
          <target state="translated">다음 표는 다양한 속성 유형의 구문과 의미를 요약 한 것입니다.</target>
        </trans-unit>
        <trans-unit id="4c79773c06aee7b0ae1108e4578659031fdd559f" translate="yes" xml:space="preserve">
          <source>The following table summarizes the types of projects available and describes the files that qmake will generate for each of them:</source>
          <target state="translated">다음 표는 사용 가능한 프로젝트 유형을 요약하고 qmake가 각 프로젝트에 대해 생성 할 파일을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="35e9679e8f13195ca97bc1052cdee8a6e6e0ff74" translate="yes" xml:space="preserve">
          <source>The following tables list known incoming options as well as accepted outgoing options. The list of incoming options is not exhaustive, since servers may include additional information at any time. The list of outgoing options is exhaustive, however, and no unknown options will be treated or sent back to the server.</source>
          <target state="translated">다음 표에는 알려진 수신 옵션과 허용되는 발신 옵션이 나와 있습니다. 서버는 언제든지 추가 정보를 포함 할 수 있으므로 들어오는 옵션 목록은 전체가 아닙니다. 나가는 옵션의 목록은 철저하지만 알 수없는 옵션은 처리되거나 서버로 다시 전송되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3c2291bbddd9030c243f4b2fc980d16ca2b41cf9" translate="yes" xml:space="preserve">
          <source>The following tags are interpreted by &lt;a href=&quot;qcborvalue&quot;&gt;QCborValue&lt;/a&gt; during decoding and will produce objects with extended Qt types, and it will use those tags when encoding the same extended types.</source>
          <target state="translated">다음 태그는 &lt;a href=&quot;qcborvalue&quot;&gt;QCborValue에&lt;/a&gt; 의해 해석됩니다 . 디코딩 중에 에 확장 Qt 유형의 오브젝트를 생성하며 동일한 확장 유형을 인코딩 할 때 해당 태그를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="f07a6f876bf38eb3a8fe285fa86c6c754f5b538c" translate="yes" xml:space="preserve">
          <source>The following terms are used to distinguish the parts of names within the context of namespaces:</source>
          <target state="translated">다음 용어는 네임 스페이스와 관련하여 이름 부분을 구별하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8c7ebce45ecb6c0a88cc595105ded86622cb04da" translate="yes" xml:space="preserve">
          <source>The following third-party libraries may be used when running Qt 5 applications on Windows.</source>
          <target state="translated">Windows에서 Qt 5 응용 프로그램을 실행할 때 다음 타사 라이브러리를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="efd39c0d106b700ec332870ad98c419cb7ba8a92" translate="yes" xml:space="preserve">
          <source>The following tools enable Qt integration with the ActiveX components.</source>
          <target state="translated">다음 툴은 ActiveX 컴포넌트와 Qt 통합을 가능하게합니다.</target>
        </trans-unit>
        <trans-unit id="e5c8d0467f5093c0bdf5fd5c9d04bfb37acff237" translate="yes" xml:space="preserve">
          <source>The following topics provide more details about Qt for iOS:</source>
          <target state="translated">다음 주제는 iOS 용 Qt에 대한 자세한 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="fd6c61efe7a7060e2d07b2db3439cee6e071139c" translate="yes" xml:space="preserve">
          <source>The following topics provide more details about how to use Qt for Android:</source>
          <target state="translated">다음 주제는 Android 용 Qt를 사용하는 방법에 대한 자세한 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="7ae77b74814654642862b64ee0a23e57aa1d45eb" translate="yes" xml:space="preserve">
          <source>The following tutorials show how a QML-based application can be combined with C++ code using the &lt;a href=&quot;qtqml-index&quot;&gt;Qt QML&lt;/a&gt; module. For information about extending QML, visit the &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtqml-cppintegration-topic.html&quot;&gt;Integrating QML and C++&lt;/a&gt; page.</source>
          <target state="translated">다음 학습서는 &lt;a href=&quot;qtqml-index&quot;&gt;Qt QML&lt;/a&gt; 모듈을 사용하여 QML 기반 애플리케이션을 C ++ 코드와 결합하는 방법을 보여줍니다 . QML 확장에 대한 정보는 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtqml-cppintegration-topic.html&quot;&gt;QML 및 C ++ 통합&lt;/a&gt; 페이지를 방문 하십시오.</target>
        </trans-unit>
        <trans-unit id="2b449a7dfdea9227d7ff6f0f5267e896541ee373" translate="yes" xml:space="preserve">
          <source>The following tutorials show how a QML-based application can be combined with C++ code using the &lt;a href=&quot;qtqml-index&quot;&gt;Qt QML&lt;/a&gt; module. For information about extending QML, visit the &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtqml-cppintegration-topic.html&quot;&gt;Integrating QML and C++&lt;/a&gt; page.</source>
          <target state="translated">The following tutorials show how a QML-based application can be combined with C++ code using the &lt;a href=&quot;qtqml-index&quot;&gt;Qt QML&lt;/a&gt; module. For information about extending QML, visit the &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtqml-cppintegration-topic.html&quot;&gt;Integrating QML and C++&lt;/a&gt; page.</target>
        </trans-unit>
        <trans-unit id="6ce736f895fbd77b221c11307ea72c6d3982dda5" translate="yes" xml:space="preserve">
          <source>The following tutorials show how a QML-based application can be combined with C++ code using the &lt;a href=&quot;qtqml-index&quot;&gt;Qt QML&lt;/a&gt; module. For information about extending QML, visit the &lt;a href=&quot;https://doc.qt.io/qt-6.0/qtqml-cppintegration-topic.html&quot;&gt;Integrating QML and C++&lt;/a&gt; page.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e39c46003c16ad92860c4159ea033312158a480b" translate="yes" xml:space="preserve">
          <source>The following two examples show how to create a HERE plugin instance with parameters supplied for an application id and token, which is required for authentication.</source>
          <target state="translated">다음 두 예제는 인증에 필요한 애플리케이션 ID 및 토큰에 제공된 매개 변수를 사용하여 HERE 플러그인 인스턴스를 작성하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="0d7e5d228c3fe53ef1004f6850718e4e2f21da9e" translate="yes" xml:space="preserve">
          <source>The following types are simple types and this function will return the listed values:</source>
          <target state="translated">다음 유형은 단순 유형이며이 함수는 나열된 값을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="78211023bb29ddef3c4f1ea3ffc9d9f06639ecbc" translate="yes" xml:space="preserve">
          <source>The following uniforms are predefined:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4af7247fb3e58d9957759fd30503e8355a3509f8" translate="yes" xml:space="preserve">
          <source>The following uniforms are provided to shaders.</source>
          <target state="translated">The following uniforms are provided to shaders.</target>
        </trans-unit>
        <trans-unit id="92316d6703008fd2194fe0f7cefb7ee0167b1afe" translate="yes" xml:space="preserve">
          <source>The following value is only useful when calling &lt;a href=&quot;qwizard#setButtonLayout&quot;&gt;setButtonLayout&lt;/a&gt;():</source>
          <target state="translated">다음 값은 &lt;a href=&quot;qwizard#setButtonLayout&quot;&gt;setButtonLayout&lt;/a&gt; ()을 호출 할 때만 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="9f3d657da06d446672eef2e43ba81e5861d08dc7" translate="yes" xml:space="preserve">
          <source>The following values are currently known:</source>
          <target state="translated">현재 알려진 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="48c5b83cfae8b9e925d7e942652765de18df0d4d" translate="yes" xml:space="preserve">
          <source>The following values are deprecated or obsolete:</source>
          <target state="translated">다음 값은 더 이상 사용되지 않거나 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="90117118a4d745bd607fea0d80360aff9b3506ae" translate="yes" xml:space="preserve">
          <source>The following values are obsolete:</source>
          <target state="translated">다음 값은 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2936d5adb9e240b503a66e2c87b97599cd38ff58" translate="yes" xml:space="preserve">
          <source>The following values are supported:</source>
          <target state="translated">다음과 같은 값이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="d36c1e2f853731708e7f9d631bb68af1a0125fbf" translate="yes" xml:space="preserve">
          <source>The following values are used for custom controls:</source>
          <target state="translated">다음 값은 사용자 지정 컨트롤에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="beb5ff224417421e0b6dc3e4fdb5dbb1705575b8" translate="yes" xml:space="preserve">
          <source>The following values can be specified in a &lt;code&gt;Controls&lt;/code&gt; section of the configuration file:</source>
          <target state="translated">구성 파일 의 &lt;code&gt;Controls&lt;/code&gt; 섹션 에서 다음 값을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f69b636a3426e1d9c588f4ff211b1bba02c5cc3e" translate="yes" xml:space="preserve">
          <source>The following variables can be used to redefine common file extensions recognized by qmake:</source>
          <target state="translated">qmake가 인식하는 공통 파일 확장자를 재정의하는 데 다음 변수를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="14b19cb3abeae1ddee9d1c3a0e72c732dfa39427" translate="yes" xml:space="preserve">
          <source>The following virtual functions may need to be reimplemented in order to tailor the look and feel or store extra data with each tab:</source>
          <target state="translated">각 탭에서 모양과 느낌을 조정하거나 추가 데이터를 저장하려면 다음 가상 기능을 다시 구현해야 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="40a6f49bd5a2954787e7162e958ca315fc9ef9ab" translate="yes" xml:space="preserve">
          <source>The following visualization type specific inherited classes are used instead of the base class: &lt;a href=&quot;qbardataproxy&quot;&gt;QBarDataProxy&lt;/a&gt;, &lt;a href=&quot;qscatterdataproxy&quot;&gt;QScatterDataProxy&lt;/a&gt;, and &lt;a href=&quot;qsurfacedataproxy&quot;&gt;QSurfaceDataProxy&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qbardataproxy&quot;&gt;QBarDataProxy&lt;/a&gt; , &lt;a href=&quot;qscatterdataproxy&quot;&gt;QScatterDataProxy&lt;/a&gt; 및 &lt;a href=&quot;qsurfacedataproxy&quot;&gt;QSurfaceDataProxy&lt;/a&gt; 기본 클래스 대신 다음 시각화 유형별 상속 클래스가 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="27adb412bc5dbc9e3b3d930d97e3db5fc56596c6" translate="yes" xml:space="preserve">
          <source>The font family.</source>
          <target state="translated">폰트 패밀리.</target>
        </trans-unit>
        <trans-unit id="9fd3e8e2115873636013e265df86a0b320959cc4" translate="yes" xml:space="preserve">
          <source>The font info object holds the information for the font that is passed in the constructor at the time it is created, and is not updated if the font's attributes are changed later.</source>
          <target state="translated">font info 객체는 생성시 생성자에 전달 된 글꼴에 대한 정보를 보유하며 글꼴의 속성이 나중에 변경되면 업데이트되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f40057f3557a21ff5bad6c521f227c0d59e50d0f" translate="yes" xml:space="preserve">
          <source>The font is dirty and needs to be updated.</source>
          <target state="translated">글꼴이 지저분하고 업데이트해야합니다.</target>
        </trans-unit>
        <trans-unit id="13d85e52c3610543c3a22a9cc4bf8b42f5c9b154" translate="yes" xml:space="preserve">
          <source>The font matching algorithm works as follows:</source>
          <target state="translated">글꼴 일치 알고리즘은 다음과 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="78c7e897b5467cf391e575b2119486c5f3c1c596" translate="yes" xml:space="preserve">
          <source>The font metrics object holds the information for the font that is passed in the constructor at the time it is created, and is not updated if the font's attributes are changed later.</source>
          <target state="translated">글꼴 메트릭 개체는 생성시 생성자에 전달 된 글꼴에 대한 정보를 보유하며 글꼴의 속성이 나중에 변경되면 업데이트되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fc43aad823a3ea0b8db4a63a4797c233eb130a26" translate="yes" xml:space="preserve">
          <source>The font metrics will be compatible with the paintdevice passed. If the</source>
          <target state="translated">글꼴 메트릭은 전달 된 페인트 장치와 호환됩니다. 만약</target>
        </trans-unit>
        <trans-unit id="c15a1cf89284c3c02f6baf205fe36c03be800c61" translate="yes" xml:space="preserve">
          <source>The font metrics will be compatible with the paintdevice used to create</source>
          <target state="translated">글꼴 메트릭은 생성에 사용 된 페인트 장치와 호환됩니다.</target>
        </trans-unit>
        <trans-unit id="52597303c029f6704decc5a8c9b44962b6e5f589" translate="yes" xml:space="preserve">
          <source>The font must be screen-compatible, i.e. a font you use when drawing text in &lt;a href=&quot;qwidget&quot;&gt;widgets&lt;/a&gt; or &lt;a href=&quot;qpixmap&quot;&gt;pixmaps&lt;/a&gt;, not &lt;a href=&quot;qpicture&quot;&gt;QPicture&lt;/a&gt; or QPrinter.</source>
          <target state="translated">글꼴은 화면과 호환 가능해야합니다. 즉 &lt;a href=&quot;qpicture&quot;&gt;QPicture&lt;/a&gt; 또는 QPrinter가 아닌 &lt;a href=&quot;qwidget&quot;&gt;위젯&lt;/a&gt; 또는 &lt;a href=&quot;qpixmap&quot;&gt;pixmaps&lt;/a&gt; 에서 텍스트를 그릴 때 사용하는 글꼴 이어야합니다.</target>
        </trans-unit>
        <trans-unit id="071509dc955bffedd92670fa673ed180e20666a3" translate="yes" xml:space="preserve">
          <source>The font must be screen-compatible, i.e. a font you use when drawing text in &lt;a href=&quot;widgets-changes-qt6#qwidget&quot;&gt;widgets&lt;/a&gt; or &lt;a href=&quot;qpixmap&quot;&gt;pixmaps&lt;/a&gt;, not &lt;a href=&quot;qpicture&quot;&gt;QPicture&lt;/a&gt; or &lt;a href=&quot;qprinter&quot;&gt;QPrinter&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9834c5f5091001c27f24fb863c66dd1f10b66fb1" translate="yes" xml:space="preserve">
          <source>The font of the &lt;a href=&quot;qml-qtquick-controls-textarea&quot;&gt;TextArea&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-controls-textarea&quot;&gt;TextArea&lt;/a&gt; 의 폰트입니다 .</target>
        </trans-unit>
        <trans-unit id="2af2f410d11cdd45bcdc98d5d6afb7d486351b4d" translate="yes" xml:space="preserve">
          <source>The font of the axis labels.</source>
          <target state="translated">축 레이블의 글꼴입니다.</target>
        </trans-unit>
        <trans-unit id="9cd99fd5db005e316efe58f3ef8adabab36027ce" translate="yes" xml:space="preserve">
          <source>The font of the control.</source>
          <target state="translated">컨트롤의 글꼴입니다.</target>
        </trans-unit>
        <trans-unit id="2d9fed71c31d718e7fc05fe6fd1b088035bf806a" translate="yes" xml:space="preserve">
          <source>The font of the markers used by the legend.</source>
          <target state="translated">범례에서 사용하는 마커의 글꼴입니다.</target>
        </trans-unit>
        <trans-unit id="422fb5379fc73747b9d3f85c4732bee736c28db9" translate="yes" xml:space="preserve">
          <source>The font of the title of the axis.</source>
          <target state="translated">축 제목의 글꼴입니다.</target>
        </trans-unit>
        <trans-unit id="0e589bd65f3499bbb06d3cd5926108eccafa29a7" translate="yes" xml:space="preserve">
          <source>The font property is used to render the text set on the &lt;a href=&quot;qaction&quot;&gt;QAction&lt;/a&gt;. The font can be considered a hint as it will not be consulted in all cases based upon application and style.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8816fd7612759b55be52ebda2f784a88b689ebce" translate="yes" xml:space="preserve">
          <source>The font property is used to render the text set on the &lt;a href=&quot;qaction&quot;&gt;QAction&lt;/a&gt;. The font will can be considered a hint as it will not be consulted in all cases based upon application and style.</source>
          <target state="translated">font 속성은 &lt;a href=&quot;qaction&quot;&gt;QAction에&lt;/a&gt; 설정된 텍스트를 렌더링하는 데 사용됩니다 . 글꼴은 응용 프로그램 및 스타일에 따라 모든 경우에 참조되지 않으므로 힌트로 간주 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="28feec6315458605d533205ac46f97e4f84694c3" translate="yes" xml:space="preserve">
          <source>The font size of fitted text has a minimum bound specified by the &lt;a href=&quot;qml-qtquick-text#minimumPointSize-prop&quot;&gt;minimumPointSize&lt;/a&gt; or &lt;a href=&quot;qml-qtquick-text#minimumPixelSize-prop&quot;&gt;minimumPixelSize&lt;/a&gt; property and maximum bound specified by either the &lt;a href=&quot;qml-qtquick-text#font.pointSize-prop&quot;&gt;font.pointSize&lt;/a&gt; or &lt;a href=&quot;qml-qtquick-text#font.pixelSize-prop&quot;&gt;font.pixelSize&lt;/a&gt; properties.</source>
          <target state="translated">적합한 텍스트의 글꼴 크기에는 &lt;a href=&quot;qml-qtquick-text#minimumPointSize-prop&quot;&gt;minimumPointSize&lt;/a&gt; 또는 &lt;a href=&quot;qml-qtquick-text#minimumPixelSize-prop&quot;&gt;minimumPixelSize&lt;/a&gt; 속성으로 지정된 최소 경계 와 &lt;a href=&quot;qml-qtquick-text#font.pointSize-prop&quot;&gt;font.pointSize&lt;/a&gt; 또는 &lt;a href=&quot;qml-qtquick-text#font.pixelSize-prop&quot;&gt;font.pixelSize&lt;/a&gt; 속성으로 지정된 최대 경계가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4081ea27b19d427c376ac51369aa16b4d184e31" translate="yes" xml:space="preserve">
          <source>The font size. In this version of Qt, only pt and px metrics are supported.</source>
          <target state="translated">글꼴 크기 이 Qt 버전에서는 pt 및 px 메트릭 만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="a0586f0ce2fbd5a870e42d965adef30cf8a65cca" translate="yes" xml:space="preserve">
          <source>The font style.</source>
          <target state="translated">폰트 스타일.</target>
        </trans-unit>
        <trans-unit id="bdab6510f71136564862d1ce762015d732c11de8" translate="yes" xml:space="preserve">
          <source>The font to be used for the label. Defaults to &lt;code&gt;Font {family: &quot;Arial&quot;; pointSize: 20}&lt;/code&gt;. Special formatting (for example, outlined) is not supported.</source>
          <target state="translated">레이블에 사용될 글꼴입니다. 기본 &lt;code&gt;Font {family: &quot;Arial&quot;; pointSize: 20}&lt;/code&gt; 입니다. 특수 형식 (예 : 개요)은 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="03ce3be0a8a86adc3f1d5ca73edf85ebdfde830f" translate="yes" xml:space="preserve">
          <source>The font to use for the tickmark text.</source>
          <target state="translated">눈금 표시 텍스트에 사용할 글꼴입니다.</target>
        </trans-unit>
        <trans-unit id="42f15fea3c8f912c0ae6d057aa4bc342ff287d93" translate="yes" xml:space="preserve">
          <source>The font used can be set by supplying a font to the &lt;a href=&quot;qtextcharformat#setFont&quot;&gt;setFont&lt;/a&gt;() function, and each aspect of its appearance can be adjusted to give the desired effect. &lt;a href=&quot;qtextcharformat#setFontFamily&quot;&gt;setFontFamily&lt;/a&gt;() and &lt;a href=&quot;qtextcharformat#setFontPointSize&quot;&gt;setFontPointSize&lt;/a&gt;() define the font's family (e.g. Times) and printed size; &lt;a href=&quot;qtextcharformat#setFontWeight&quot;&gt;setFontWeight&lt;/a&gt;() and &lt;a href=&quot;qtextcharformat#setFontItalic&quot;&gt;setFontItalic&lt;/a&gt;() provide control over the style of the font. &lt;a href=&quot;qtextcharformat#setFontUnderline&quot;&gt;setFontUnderline&lt;/a&gt;(), &lt;a href=&quot;qtextcharformat#setFontOverline&quot;&gt;setFontOverline&lt;/a&gt;(), &lt;a href=&quot;qtextcharformat#setFontStrikeOut&quot;&gt;setFontStrikeOut&lt;/a&gt;(), and &lt;a href=&quot;qtextcharformat#setFontFixedPitch&quot;&gt;setFontFixedPitch&lt;/a&gt;() provide additional effects for text.</source>
          <target state="translated">사용 된 글꼴은 &lt;a href=&quot;qtextcharformat#setFont&quot;&gt;setFont&lt;/a&gt; () 함수에 글꼴을 제공하여 설정할 수 있으며 각 모양의 모양을 조정하여 원하는 효과를 줄 수 있습니다. &lt;a href=&quot;qtextcharformat#setFontFamily&quot;&gt;setFontFamily&lt;/a&gt; () 및 &lt;a href=&quot;qtextcharformat#setFontPointSize&quot;&gt;setFontPointSize&lt;/a&gt; ()는 글꼴의 패밀리 (예 : 시간) 및 인쇄 크기를 정의합니다. &lt;a href=&quot;qtextcharformat#setFontWeight&quot;&gt;setFontWeight&lt;/a&gt; () 및 &lt;a href=&quot;qtextcharformat#setFontItalic&quot;&gt;setFontItalic&lt;/a&gt; ()은 글꼴 스타일을 제어합니다. &lt;a href=&quot;qtextcharformat#setFontUnderline&quot;&gt;setFontUnderline&lt;/a&gt; (), &lt;a href=&quot;qtextcharformat#setFontOverline&quot;&gt;setFontOverline&lt;/a&gt; (), &lt;a href=&quot;qtextcharformat#setFontStrikeOut&quot;&gt;setFontStrikeOut&lt;/a&gt; () 및 &lt;a href=&quot;qtextcharformat#setFontFixedPitch&quot;&gt;setFontFixedPitch&lt;/a&gt; ()는 텍스트에 대한 추가 효과를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="88ee2cfbda788addba287c68dbc11f4ce4d1930e" translate="yes" xml:space="preserve">
          <source>The font used for data point labels.</source>
          <target state="translated">데이터 포인트 레이블에 사용되는 글꼴입니다.</target>
        </trans-unit>
        <trans-unit id="4ef549980e0874a027c1dc7ed8c5fc56ee1437fe" translate="yes" xml:space="preserve">
          <source>The font used for items rendered with the default delegate. (&lt;a href=&quot;gui-changes-qt6#qfont&quot;&gt;QFont&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4875c23eb26fda940a4d500a8b0efb00187a02b1" translate="yes" xml:space="preserve">
          <source>The font used for items rendered with the default delegate. (&lt;a href=&quot;qfont&quot;&gt;QFont&lt;/a&gt;)</source>
          <target state="translated">기본 대리자로 렌더링 된 항목에 사용되는 글꼴입니다. ( &lt;a href=&quot;qfont&quot;&gt;QFont&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="4ab8746046062a9f91817d5ea66e05bf642b5430" translate="yes" xml:space="preserve">
          <source>The font used for the slice label.</source>
          <target state="translated">슬라이스 레이블에 사용되는 글꼴입니다.</target>
        </trans-unit>
        <trans-unit id="4a23ca5a9166af77aaccc137537b92d9ee4825ac" translate="yes" xml:space="preserve">
          <source>The font used to draw the bar set's label.</source>
          <target state="translated">막대 세트의 레이블을 그리는 데 사용되는 글꼴입니다.</target>
        </trans-unit>
        <trans-unit id="9d2083a6bf2a27fa87b22294cfc05310ffb8ffa8" translate="yes" xml:space="preserve">
          <source>The font which the user selected and accepted.</source>
          <target state="translated">사용자가 선택하고 승인 한 글꼴입니다.</target>
        </trans-unit>
        <trans-unit id="bbf8dfb6c2ec33ba44b367567c45bbcfc78a9f0a" translate="yes" xml:space="preserve">
          <source>The font which the user selected.</source>
          <target state="translated">사용자가 선택한 글꼴</target>
        </trans-unit>
        <trans-unit id="77a180350ac8b22167ae666675e431a6f0b7c222" translate="yes" xml:space="preserve">
          <source>The footer is positioned at the end of the view.</source>
          <target state="translated">The footer is positioned at the end of the view.</target>
        </trans-unit>
        <trans-unit id="80d0ec31539fbf7e8a613cf9b9f628781d8957b7" translate="yes" xml:space="preserve">
          <source>The footer is positioned at the end of the view. The footer can be pushed away by moving the content backwards, and pulled back by moving the content forwards.</source>
          <target state="translated">The footer is positioned at the end of the view. The footer can be pushed away by moving the content backwards, and pulled back by moving the content forwards.</target>
        </trans-unit>
        <trans-unit id="62af8d9a24dc96bdca488f4487df6988e74ce521" translate="yes" xml:space="preserve">
          <source>The footer is rendered at the bottom of the generated documentation page.</source>
          <target state="translated">바닥 글은 생성 된 문서 페이지의 맨 아래에 렌더링됩니다.</target>
        </trans-unit>
        <trans-unit id="67673e1ca4f2d3d4c7f31d671c8ad72beabfeb4c" translate="yes" xml:space="preserve">
          <source>The footnote is rendered at the bottom of the page.</source>
          <target state="translated">각주는 페이지 하단에 렌더링됩니다.</target>
        </trans-unit>
        <trans-unit id="8ad95d9c05e022a49e6e5d317267127422570052" translate="yes" xml:space="preserve">
          <source>The foreach Keyword</source>
          <target state="translated">foreach 키워드</target>
        </trans-unit>
        <trans-unit id="fd93b290e938e3eaecb86deeeecac7718e8e600e" translate="yes" xml:space="preserve">
          <source>The foreground brush (text color, typically) used for items rendered with the default delegate. (&lt;a href=&quot;qbrush&quot;&gt;QBrush&lt;/a&gt;)</source>
          <target state="translated">기본 대리자로 렌더링 된 항목에 사용되는 전경 브러시 (일반적으로 텍스트 색상)입니다. ( &lt;a href=&quot;qbrush&quot;&gt;QBrush&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="9b3a3fd166c583826d5666e1f93ee60af12b03b4" translate="yes" xml:space="preserve">
          <source>The foreground color used with &lt;code&gt;Base&lt;/code&gt;. This is usually the same as the &lt;code&gt;WindowText&lt;/code&gt;, in which case it must provide good contrast with &lt;code&gt;Window&lt;/code&gt; and &lt;code&gt;Base&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Base&lt;/code&gt; 와 함께 사용되는 전경색입니다 . 이것은 보통 &lt;code&gt;WindowText&lt;/code&gt; 와 동일 합니다.이 경우 &lt;code&gt;Window&lt;/code&gt; 와 &lt;code&gt;Base&lt;/code&gt; 와 잘 대비해야합니다 .</target>
        </trans-unit>
        <trans-unit id="74e1e6a199766dd10b340a4859cc36f8f0993feb" translate="yes" xml:space="preserve">
          <source>The foreground color used with &lt;code&gt;base&lt;/code&gt;. This is usually the same as the &lt;code&gt;windowText&lt;/code&gt;, in which case it must provide good contrast with &lt;code&gt;window&lt;/code&gt; and &lt;code&gt;base&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b680c33422df7f918fa8a1db4cc574ff628a8f82" translate="yes" xml:space="preserve">
          <source>The foreground color used with &lt;code&gt;palette.base&lt;/code&gt;. This is usually the same as the &lt;code&gt;palette.windowText&lt;/code&gt;, in which case it must provide good contrast with &lt;code&gt;palette.window&lt;/code&gt; and &lt;code&gt;palette.base&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;palette.base&lt;/code&gt; 와 함께 사용되는 전경색 . 이것은 일반적으로 &lt;code&gt;palette.windowText&lt;/code&gt; 와 동일하며 ,이 경우 &lt;code&gt;palette.window&lt;/code&gt; 및 &lt;code&gt;palette.base&lt;/code&gt; 와 좋은 대비를 제공해야합니다 .</target>
        </trans-unit>
        <trans-unit id="75711fb046f0dab941cb4389cbced8e4c694ac30" translate="yes" xml:space="preserve">
          <source>The foreground is drawn after (on top of) the items. The default foreground brush is &lt;a href=&quot;qt#BrushStyle-enum&quot;&gt;Qt::NoBrush&lt;/a&gt; ( i.e. the foreground is not drawn).</source>
          <target state="translated">항목 뒤 (위에) 전경이 그려집니다. 기본 전경 브러시는 &lt;a href=&quot;qt#BrushStyle-enum&quot;&gt;Qt :: NoBrush입니다&lt;/a&gt; (즉, 전경이 그려지지 않음).</target>
        </trans-unit>
        <trans-unit id="adecbdec218ba3485cdc5d829ca5eb2ffb5e9b07" translate="yes" xml:space="preserve">
          <source>The foreground layer. &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; renders the scene's foreground in this layer by calling the virtual function &lt;a href=&quot;qgraphicsscene#drawForeground&quot;&gt;drawForeground&lt;/a&gt;(). The foreground layer is drawn last of all layers.</source>
          <target state="translated">전경 레이어. &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; 은 가상 함수 &lt;a href=&quot;qgraphicsscene#drawForeground&quot;&gt;drawForeground&lt;/a&gt; ()를 호출하여이 레이어에서 장면의 전경을 렌더링합니다 . 전경 레이어는 모든 레이어의 마지막에 그려집니다.</target>
        </trans-unit>
        <trans-unit id="cebdda431e631d48bdeec7fdcccb03d02565c67c" translate="yes" xml:space="preserve">
          <source>The foreground of each column.</source>
          <target state="translated">각 열의 전경.</target>
        </trans-unit>
        <trans-unit id="b6d0efb9a9d1321a5f38bb93b347d39578e9eb8f" translate="yes" xml:space="preserve">
          <source>The foreground of selected text or items.</source>
          <target state="translated">선택된 텍스트 또는 항목의 전경.</target>
        </trans-unit>
        <trans-unit id="30ee75268645d9aeeab68b73ea058da7120fb0c5" translate="yes" xml:space="preserve">
          <source>The foreground of the button.</source>
          <target state="translated">버튼의 전경입니다.</target>
        </trans-unit>
        <trans-unit id="a4e3906333f202ba7ef284e3e50234dc49ee5541" translate="yes" xml:space="preserve">
          <source>The foreground of the gauge. This component is drawn above all others.</source>
          <target state="translated">게이지의 전경. 이 구성 요소는 다른 모든 요소 위에 그려집니다.</target>
        </trans-unit>
        <trans-unit id="86c52350c1392cff935e6b606aa5de0db5ea5a28" translate="yes" xml:space="preserve">
          <source>The foreground of the tumbler.</source>
          <target state="translated">텀블러의 전경.</target>
        </trans-unit>
        <trans-unit id="9e488f4d03d1e4e20b845dfb2b646b1dce476125" translate="yes" xml:space="preserve">
          <source>The foreground of this column.</source>
          <target state="translated">이 열의 전경.</target>
        </trans-unit>
        <trans-unit id="3c95089653c530d004516c50191aa668b4f8e1eb" translate="yes" xml:space="preserve">
          <source>The foreground role defines the color from the widget's &lt;a href=&quot;qwidget#palette-prop&quot;&gt;palette&lt;/a&gt; that is used to draw the foreground.</source>
          <target state="translated">전경 역할은 전경 을 그리는 데 사용되는 위젯 &lt;a href=&quot;qwidget#palette-prop&quot;&gt;팔레트&lt;/a&gt; 에서 색상을 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="24a12184081dcd62a42c9ce8e9bf76669d64e1f7" translate="yes" xml:space="preserve">
          <source>The forever keyword.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78d9d84528013c3ba0dfbb3b659cc56a253eaded" translate="yes" xml:space="preserve">
          <source>The form of this template function is:</source>
          <target state="translated">이 템플릿 함수의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f39c41db910f76430270ce5e01e6b69e4b83ebdd" translate="yes" xml:space="preserve">
          <source>The form styles can be also be overridden individually by calling &lt;a href=&quot;qformlayout#labelAlignment-prop&quot;&gt;setLabelAlignment&lt;/a&gt;(), &lt;a href=&quot;qformlayout#formAlignment-prop&quot;&gt;setFormAlignment&lt;/a&gt;(), &lt;a href=&quot;qformlayout#fieldGrowthPolicy-prop&quot;&gt;setFieldGrowthPolicy&lt;/a&gt;(), and &lt;a href=&quot;qformlayout#rowWrapPolicy-prop&quot;&gt;setRowWrapPolicy&lt;/a&gt;(). For example, to simulate the form layout appearance of QMacStyle on all platforms, but with left-aligned labels, you could write:</source>
          <target state="translated">&lt;a href=&quot;qformlayout#labelAlignment-prop&quot;&gt;setLabelAlignment&lt;/a&gt; (), &lt;a href=&quot;qformlayout#formAlignment-prop&quot;&gt;setFormAlignment&lt;/a&gt; (), &lt;a href=&quot;qformlayout#fieldGrowthPolicy-prop&quot;&gt;setFieldGrowthPolicy&lt;/a&gt; () 및 &lt;a href=&quot;qformlayout#rowWrapPolicy-prop&quot;&gt;setRowWrapPolicy&lt;/a&gt; () 를 호출 하여 양식 스타일을 개별적으로 대체 할 수도 있습니다 . 예를 들어, 모든 플랫폼에서 QMacStyle의 양식 레이아웃 모양을 시뮬레이션하지만 왼쪽 정렬 레이블을 사용하여 다음을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="415e5226103a41de0aea37a864338e2e1ef60ab2" translate="yes" xml:space="preserve">
          <source>The form validation message should be hidden.</source>
          <target state="translated">양식 유효성 검사 메시지를 숨겨야합니다.</target>
        </trans-unit>
        <trans-unit id="048575acb531740d12b67209192b992d47ec4fd7" translate="yes" xml:space="preserve">
          <source>The form validation message should be moved.</source>
          <target state="translated">양식 유효성 검사 메시지를 이동해야합니다.</target>
        </trans-unit>
        <trans-unit id="5a8f4795778ebb1c922c49b69b2a367ae9807a3d" translate="yes" xml:space="preserve">
          <source>The form validation message should be shown.</source>
          <target state="translated">양식 유효성 검사 메시지가 표시되어야합니다.</target>
        </trans-unit>
        <trans-unit id="61ab20befd5772f3e67bd4848a6a31f483648a37" translate="yes" xml:space="preserve">
          <source>The form window manager interface provides the &lt;a href=&quot;qdesignerformwindowmanagerinterface#createFormWindow&quot;&gt;createFormWindow&lt;/a&gt;() function that enables you to create a new form window which you can add to the collection of form windows that the manager maintains, using the &lt;a href=&quot;qdesignerformwindowmanagerinterface#addFormWindow&quot;&gt;addFormWindow&lt;/a&gt;() slot. It also provides the &lt;a href=&quot;qdesignerformwindowmanagerinterface#formWindowCount&quot;&gt;formWindowCount&lt;/a&gt;() function returning the number of form windows currently under the manager's control, the &lt;a href=&quot;qdesignerformwindowmanagerinterface#formWindow&quot;&gt;formWindow&lt;/a&gt;() function returning the form window associated with a given index, and the &lt;a href=&quot;qdesignerformwindowmanagerinterface#activeFormWindow&quot;&gt;activeFormWindow&lt;/a&gt;() function returning the currently selected form window. The &lt;a href=&quot;qdesignerformwindowmanagerinterface#removeFormWindow&quot;&gt;removeFormWindow&lt;/a&gt;() slot allows you to reduce the number of form windows the manager must maintain, and the &lt;a href=&quot;qdesignerformwindowmanagerinterface#setActiveFormWindow&quot;&gt;setActiveFormWindow&lt;/a&gt;() slot allows you to change the form window focus in</source>
          <target state="translated">양식 창 관리자 인터페이스는 &lt;a href=&quot;qdesignerformwindowmanagerinterface#addFormWindow&quot;&gt;addFormWindow&lt;/a&gt; () 슬롯을 사용하여 관리자가 유지 관리하는 양식 창 모음에 추가 할 수있는 새 양식 창을 만들 수 있는 &lt;a href=&quot;qdesignerformwindowmanagerinterface#createFormWindow&quot;&gt;createFormWindow&lt;/a&gt; () 함수를 제공합니다 . 또한 제공 &lt;a href=&quot;qdesignerformwindowmanagerinterface#formWindowCount&quot;&gt;formWindowCount&lt;/a&gt; 현재 관리자의 제어하에 폼 윈도우의 개수를 리턴 () 함수 &lt;a href=&quot;qdesignerformwindowmanagerinterface#formWindow&quot;&gt;formWindow&lt;/a&gt; 주어진 인덱스와 연관된 형태의 윈도우를 반환 () 함수 및 &lt;a href=&quot;qdesignerformwindowmanagerinterface#activeFormWindow&quot;&gt;activeFormWindow&lt;/a&gt; () 함수는 현재 선택된 형태 창을 반환. &lt;a href=&quot;qdesignerformwindowmanagerinterface#removeFormWindow&quot;&gt;removeFormWindow&lt;/a&gt; 슬롯을 사용하면 관리자가 관리해야 폼 창문의 수를 줄일 수 있습니다 (), 그리고 &lt;a href=&quot;qdesignerformwindowmanagerinterface#setActiveFormWindow&quot;&gt;setActiveFormWindow&lt;/a&gt;() 슬롯을 사용하면 양식 창 포커스를 변경할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="5183929e533ad8e07f235efbc97b9962e7de92c8" translate="yes" xml:space="preserve">
          <source>The form's top level layout can be set by clearing the selection (click the left mouse button on the form itself) and applying a layout. A top level layout is necessary to ensure that your widgets will resize correctly when its window is resized. To check if you have set a top level layout, preview your widget and attempt to resize the window by dragging the size grip.</source>
          <target state="translated">선택 항목을 지우고 (양식 자체에서 마우스 왼쪽 버튼을 클릭) 레이아웃을 적용하여 양식의 최상위 레이아웃을 설정할 수 있습니다. 창 크기를 조정할 때 위젯의 크기가 올바르게 조정되도록하려면 최상위 레벨 레이아웃이 필요합니다. 최상위 레벨 레이아웃을 설정했는지 확인하려면 위젯을 미리보고 크기 그립을 드래그하여 창 크기를 조정하십시오.</target>
        </trans-unit>
        <trans-unit id="72e4016028ce03ad3ba3ca263e457986e473df4a" translate="yes" xml:space="preserve">
          <source>The formal parameter name may be enclosed between curly brackets, but that isn't required.</source>
          <target state="translated">형식 매개 변수 이름은 중괄호로 묶을 수 있지만 필수는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="165e234f49d5bccec2441e39cf5d8cb017d08434" translate="yes" xml:space="preserve">
          <source>The format</source>
          <target state="translated">형식</target>
        </trans-unit>
        <trans-unit id="3cf148b1183aa497ae768bcf141a532913a49173" translate="yes" xml:space="preserve">
          <source>The format can be either a semicolon-separated list of scale factors in the same order as &lt;a href=&quot;qguiapplication#screens&quot;&gt;QGuiApplication::screens&lt;/a&gt;(), or a semicolon-separated list of &lt;code&gt;name=value&lt;/code&gt; pairs, where &lt;code&gt;name&lt;/code&gt; is the same as &lt;a href=&quot;qscreen#name-prop&quot;&gt;QScreen::name&lt;/a&gt;().</source>
          <target state="translated">형식은 &lt;a href=&quot;qguiapplication#screens&quot;&gt;QGuiApplication :: screens&lt;/a&gt; () 와 동일한 순서로 세미콜론으로 구분 된 스케일 팩터 목록 또는 &lt;code&gt;name=value&lt;/code&gt; 쌍 의 세미콜론으로 구분 된 목록 일 수 있습니다. 여기서 &lt;code&gt;name&lt;/code&gt; 은 &lt;a href=&quot;qscreen#name-prop&quot;&gt;QScreen :: name&lt;/a&gt; ()과 같습니다.</target>
        </trans-unit>
        <trans-unit id="62000a4841d12811cd6ac017f466ab492097e578" translate="yes" xml:space="preserve">
          <source>The format can either be a semicolon-separated list of scale factors in the same order as &lt;a href=&quot;qguiapplication#screens&quot;&gt;QGuiApplication::screens&lt;/a&gt;(), or a semicolon-separated list of &lt;code&gt;name=value&lt;/code&gt; pairs, where &lt;code&gt;name&lt;/code&gt; is the same as &lt;a href=&quot;qscreen#name-prop&quot;&gt;QScreen::name&lt;/a&gt;().</source>
          <target state="translated">The format can either be a semicolon-separated list of scale factors in the same order as &lt;a href=&quot;qguiapplication#screens&quot;&gt;QGuiApplication::screens&lt;/a&gt;(), or a semicolon-separated list of &lt;code&gt;name=value&lt;/code&gt; pairs, where &lt;code&gt;name&lt;/code&gt; is the same as &lt;a href=&quot;qscreen#name-prop&quot;&gt;QScreen::name&lt;/a&gt;().</target>
        </trans-unit>
        <trans-unit id="35f4727adffdaa0aa2fe90a81ab0cc6a4858ad70" translate="yes" xml:space="preserve">
          <source>The format determines properties such as color depth, alpha, depth and stencil buffer size, etc. For example, to give a window a transparent background (provided that the window system supports compositing, and provided that other content in the window does not make it opaque again):</source>
          <target state="translated">형식은 색 농도, 알파, 깊이 및 스텐실 버퍼 크기 등과 같은 속성을 결정합니다. 예를 들어, 창에 투명한 배경을 제공하기 위해 (창 시스템이 합성을 지원하고, 창의 다른 내용으로 만들지 않는 경우) 다시 불투명) :</target>
        </trans-unit>
        <trans-unit id="55ac4e73c153fe942ee5193e259e4ff653636570" translate="yes" xml:space="preserve">
          <source>The format doesn't have to be the same as the referenced texture's format. It however has to be compatible (matching in size but not necessarily by class type). For instance a texture of format R32F (size 32bits, class 1x32) could be used with an image of format RGBA8I (size 32bits, class 4x8). Table 8.27 of the &lt;a href=&quot;https://www.khronos.org/registry/OpenGL/specs/gl/glspec45.core.pdf&quot;&gt;OpenGL specifications&lt;/a&gt; shows the size and class for all supported Image formats.</source>
          <target state="translated">The format doesn't have to be the same as the referenced texture's format. It however has to be compatible (matching in size but not necessarily by class type). For instance a texture of format R32F (size 32bits, class 1x32) could be used with an image of format RGBA8I (size 32bits, class 4x8). Table 8.27 of the &lt;a href=&quot;https://www.khronos.org/registry/OpenGL/specs/gl/glspec45.core.pdf&quot;&gt;OpenGL specifications&lt;/a&gt; shows the size and class for all supported Image formats.</target>
        </trans-unit>
        <trans-unit id="25b3f9f9d241a30cb8a76d5c57275baf5272a74d" translate="yes" xml:space="preserve">
          <source>The format doesn't have to be the same as the referenced texture's format. It however has to be compatible (matching in size but not necessarily by class type). For instance a texture of format R32F (size 32bits, class 1x32) could be used with an image of format RGBA8I (size 32bits, class 4x8). Table 8.27 of the &lt;a href=&quot;https://www.khronos.org/registry/OpenGL/specs/gl/glspec45.core.pdf&quot;&gt;OpenGL specifications&lt;/a&gt; shows the size and class for all supported image formats.</source>
          <target state="translated">The format doesn't have to be the same as the referenced texture's format. It however has to be compatible (matching in size but not necessarily by class type). For instance a texture of format R32F (size 32bits, class 1x32) could be used with an image of format RGBA8I (size 32bits, class 4x8). Table 8.27 of the &lt;a href=&quot;https://www.khronos.org/registry/OpenGL/specs/gl/glspec45.core.pdf&quot;&gt;OpenGL specifications&lt;/a&gt; shows the size and class for all supported image formats.</target>
        </trans-unit>
        <trans-unit id="d6b2be01b8af7c747884af434b85d3e9eab19d80" translate="yes" xml:space="preserve">
          <source>The format for the displacement map is similar to the tangent space normal maps, which can be created with most 3D-modeling tools. Many image processing tools include the support for generating normal maps. Alternatively, the displacement map for this effect can also be a QML element which is colored appropriately. Like any QML element, it can be animated. It is recommended that the size of the diplacement map matches the size of the &lt;a href=&quot;qml-qtgraphicaleffects-displace#source-prop&quot;&gt;source&lt;/a&gt;.</source>
          <target state="translated">변위 맵의 형식은 탄젠트 공간 노멀 맵과 유사하며 대부분의 3D 모델링 도구로 만들 수 있습니다. 많은 이미지 처리 도구에는 노멀 맵 생성 지원이 포함되어 있습니다. 대안 적으로,이 효과에 대한 변위 맵은 또한 적절하게 채색 된 QML 요소 일 수있다. 다른 QML 요소와 마찬가지로 애니메이션을 적용 할 수 있습니다. 변위 맵의 크기는 &lt;a href=&quot;qml-qtgraphicaleffects-displace#source-prop&quot;&gt;소스&lt;/a&gt; 의 크기와 일치하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="4802123978c91e24724000ba2404721f7347affa" translate="yes" xml:space="preserve">
          <source>The format in which the days of the week (in the header) are displayed.</source>
          <target state="translated">머리글에 요일이 표시되는 형식입니다.</target>
        </trans-unit>
        <trans-unit id="302b06b6905d60bfc8bce5f48193940e1d599b00" translate="yes" xml:space="preserve">
          <source>The format includes the size of the color buffers, red, green, and blue; the size of the alpha buffer; the size of the depth and stencil buffers; and number of samples per pixel for multisampling. In addition, the format contains surface configuration parameters such as &lt;a href=&quot;qsurfaceformat#RenderableType-enum&quot;&gt;OpenGL&lt;/a&gt; profile and version for rendering, whether or not to enable stereo buffers, and swap behaviour.</source>
          <target state="translated">형식에는 컬러 버퍼의 크기, 빨강, 녹색 및 파랑이 포함됩니다. 알파 버퍼의 크기; 깊이 및 스텐실 버퍼의 크기; 및 멀티 샘플링을위한 픽셀 당 샘플 수. 또한이 형식에는 &lt;a href=&quot;qsurfaceformat#RenderableType-enum&quot;&gt;OpenGL&lt;/a&gt; 프로파일 및 렌더링 용 버전, 스테레오 버퍼 사용 여부 및 스왑 동작과 같은 표면 구성 매개 변수가 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="b16bfb5c76a40200deea8bb3d3566239b31e6ee8" translate="yes" xml:space="preserve">
          <source>The format includes the size of the color buffers, red, green, and blue; the size of the alpha buffer; the size of the depth and stencil buffers; and number of samples per pixel for multisampling. In addition, the format contains surface configuration parameters such as OpenGL profile and version for rendering, whether or not to enable stereo buffers, and swap behaviour.</source>
          <target state="translated">The format includes the size of the color buffers, red, green, and blue; the size of the alpha buffer; the size of the depth and stencil buffers; and number of samples per pixel for multisampling. In addition, the format contains surface configuration parameters such as OpenGL profile and version for rendering, whether or not to enable stereo buffers, and swap behaviour.</target>
        </trans-unit>
        <trans-unit id="cabdaab0724024176051246a31b1e5b46b678eaa" translate="yes" xml:space="preserve">
          <source>The format is documented in &lt;a href=&quot;#qSetMessagePattern&quot;&gt;qSetMessagePattern&lt;/a&gt;(). You can also install your own message handler using &lt;a href=&quot;#qInstallMessageHandler&quot;&gt;qInstallMessageHandler&lt;/a&gt;().</source>
          <target state="translated">형식은 &lt;a href=&quot;#qSetMessagePattern&quot;&gt;qSetMessagePattern&lt;/a&gt; ()에 문서화되어 있습니다. &lt;a href=&quot;#qInstallMessageHandler&quot;&gt;qInstallMessageHandler&lt;/a&gt; ()를 사용하여 고유 한 메시지 핸들러를 설치할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="abcf9b5529b1cd249c3182fdc4857b15d6d2c742" translate="yes" xml:space="preserve">
          <source>The format is documented in &lt;a href=&quot;qtglobal#qSetMessagePattern&quot;&gt;qSetMessagePattern&lt;/a&gt;(). You can also install your own message handler using &lt;a href=&quot;qtglobal#qInstallMessageHandler&quot;&gt;qInstallMessageHandler&lt;/a&gt;().</source>
          <target state="translated">The format is documented in &lt;a href=&quot;qtglobal#qSetMessagePattern&quot;&gt;qSetMessagePattern&lt;/a&gt;(). You can also install your own message handler using &lt;a href=&quot;qtglobal#qInstallMessageHandler&quot;&gt;qInstallMessageHandler&lt;/a&gt;().</target>
        </trans-unit>
        <trans-unit id="8acd5fa25e2d2639b59daf8f63c53f732d8cd6e6" translate="yes" xml:space="preserve">
          <source>The format is of type &lt;a href=&quot;qvideoframe#PixelFormat-enum&quot;&gt;QVideoFrame::PixelFormat&lt;/a&gt;.</source>
          <target state="translated">형식은 &lt;a href=&quot;qvideoframe#PixelFormat-enum&quot;&gt;QVideoFrame :: PixelFormat&lt;/a&gt; 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="e03467839c13297a57a5711ec311c465bc940bca" translate="yes" xml:space="preserve">
          <source>The format of</source>
          <target state="translated">형식</target>
        </trans-unit>
        <trans-unit id="800fe785ad4cac296feaae562b08740455665bb6" translate="yes" xml:space="preserve">
          <source>The format of a D-Bus service name is in fact very similar to a host name: it is a dot-separated sequence of letters and digits. The common practice is even to name one's service name according to the domain name of the organization that defined that service.</source>
          <target state="translated">D- 버스 서비스 이름의 형식은 실제로 호스트 이름과 매우 유사합니다. 점으로 구분 된 문자와 숫자의 순서입니다. 일반적인 관행은 해당 서비스를 정의한 조직의 도메인 이름에 따라 서비스 이름을 지정하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="97e0f96a6bad8ea596fa423b32dbbd88ff9773d4" translate="yes" xml:space="preserve">
          <source>The format of a media resource isn't (fully) supported. Playback may still be possible, but without an audio or video component.</source>
          <target state="translated">미디어 리소스의 형식이 (완전히) 지원되지 않습니다. 오디오 또는 비디오 구성 요소없이 재생할 수는 있습니다.</target>
        </trans-unit>
        <trans-unit id="b73155041bea822c024dd85f8c4df4188114a4b0" translate="yes" xml:space="preserve">
          <source>The format of a media resource isn't supported.</source>
          <target state="translated">미디어 리소스의 형식이 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="94657cde395d5da83edc6067e22a759dc81f2671" translate="yes" xml:space="preserve">
          <source>The format of the</source>
          <target state="translated">의 형식</target>
        </trans-unit>
        <trans-unit id="c73469c760e2eeeb738fa2263c947eb66fc0b828" translate="yes" xml:space="preserve">
          <source>The format of the URL is unchanged.</source>
          <target state="translated">URL 형식은 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4ce6c27568d572fbdc4012edbbf84a5c365560c6" translate="yes" xml:space="preserve">
          <source>The format specification is described at &lt;a href=&quot;qml-qtqml-qt#formatDateTime-method&quot;&gt;Qt.formatDateTime&lt;/a&gt;.</source>
          <target state="translated">형식 스펙은 &lt;a href=&quot;qml-qtqml-qt#formatDateTime-method&quot;&gt;Qt.formatDateTime에&lt;/a&gt; 설명되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3e43448ad1f2459623b389bceea3866c8ecf7a7b" translate="yes" xml:space="preserve">
          <source>The format string supports the conversion specifiers, length modifiers, and flags provided by printf() in the standard C++ library. The</source>
          <target state="translated">형식 문자열은 표준 C ++ 라이브러리에서 printf ()가 제공하는 변환 지정자, 길이 수정 자 및 플래그를 지원합니다. 그만큼</target>
        </trans-unit>
        <trans-unit id="d4c5d2077d70e2d19a8b041278149da34bb89642" translate="yes" xml:space="preserve">
          <source>The format string supports the following conversion specifiers, length modifiers, and flags provided by &lt;code&gt;printf()&lt;/code&gt; in the standard C++ library: d, i, o, x, X, f, F, e, E, g, G, c.</source>
          <target state="translated">형식 문자열은 표준 C ++ 라이브러리에서 &lt;code&gt;printf()&lt;/code&gt; 가 제공하는 d, i, o, x, X, f, F, e, E, g, G, c 와 같은 변환 지정자, 길이 수정 자 및 플래그를 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="cb7da9dc822d363db17c5940f8c96352b8491cd7" translate="yes" xml:space="preserve">
          <source>The format string that is used when creating the label for the axis out of a &lt;a href=&quot;qdatetime&quot;&gt;QDateTime&lt;/a&gt; object. See &lt;a href=&quot;qdatetime&quot;&gt;QDateTime&lt;/a&gt; documentation for information on how the string should be defined.</source>
          <target state="translated">&lt;a href=&quot;qdatetime&quot;&gt;QDateTime&lt;/a&gt; 오브젝트 에서 축의 레이블을 작성할 때 사용되는 형식 문자열입니다 . 문자열을 정의하는 방법에 대한 정보는 &lt;a href=&quot;qdatetime&quot;&gt;QDateTime&lt;/a&gt; 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b3710e9c24c132d64a67ddfc1560b4f20be2b2d0" translate="yes" xml:space="preserve">
          <source>The format that the enumerations represent will depend on your locale, but also the method that the enumeration is used for.</source>
          <target state="translated">The format that the enumerations represent will depend on your locale, but also the method that the enumeration is used for.</target>
        </trans-unit>
        <trans-unit id="c007bc2ee79a57b0f445b2e5c26a02697d4c108e" translate="yes" xml:space="preserve">
          <source>The format type is given by &lt;a href=&quot;qtextformat#type&quot;&gt;type&lt;/a&gt;(), and the format can be tested with &lt;a href=&quot;qtextformat#isCharFormat&quot;&gt;isCharFormat&lt;/a&gt;(), &lt;a href=&quot;qtextformat#isBlockFormat&quot;&gt;isBlockFormat&lt;/a&gt;(), &lt;a href=&quot;qtextformat#isListFormat&quot;&gt;isListFormat&lt;/a&gt;(), &lt;a href=&quot;qtextformat#isTableFormat&quot;&gt;isTableFormat&lt;/a&gt;(), &lt;a href=&quot;qtextformat#isFrameFormat&quot;&gt;isFrameFormat&lt;/a&gt;(), and &lt;a href=&quot;qtextformat#isImageFormat&quot;&gt;isImageFormat&lt;/a&gt;(). If the type is determined, it can be retrieved with &lt;a href=&quot;qtextformat#toCharFormat&quot;&gt;toCharFormat&lt;/a&gt;(), &lt;a href=&quot;qtextformat#toBlockFormat&quot;&gt;toBlockFormat&lt;/a&gt;(), &lt;a href=&quot;qtextformat#toListFormat&quot;&gt;toListFormat&lt;/a&gt;(), &lt;a href=&quot;qtextformat#toTableFormat&quot;&gt;toTableFormat&lt;/a&gt;(), &lt;a href=&quot;qtextformat#toFrameFormat&quot;&gt;toFrameFormat&lt;/a&gt;(), and &lt;a href=&quot;qtextformat#toImageFormat&quot;&gt;toImageFormat&lt;/a&gt;().</source>
          <target state="translated">형식 유형은 &lt;a href=&quot;qtextformat#type&quot;&gt;유형&lt;/a&gt; ()으로 제공되며 &lt;a href=&quot;qtextformat#isCharFormat&quot;&gt;isCharFormat&lt;/a&gt; (), &lt;a href=&quot;qtextformat#isBlockFormat&quot;&gt;isBlockFormat&lt;/a&gt; (), &lt;a href=&quot;qtextformat#isListFormat&quot;&gt;isListFormat&lt;/a&gt; (), &lt;a href=&quot;qtextformat#isTableFormat&quot;&gt;isTableFormat&lt;/a&gt; (), &lt;a href=&quot;qtextformat#isFrameFormat&quot;&gt;isFrameFormat&lt;/a&gt; () 및 &lt;a href=&quot;qtextformat#isImageFormat&quot;&gt;isImageFormat&lt;/a&gt; () 으로 형식을 테스트 할 수 있습니다 . 유형이 결정되면 &lt;a href=&quot;qtextformat#toCharFormat&quot;&gt;toCharFormat&lt;/a&gt; (), &lt;a href=&quot;qtextformat#toBlockFormat&quot;&gt;toBlockFormat&lt;/a&gt; (), &lt;a href=&quot;qtextformat#toListFormat&quot;&gt;toListFormat&lt;/a&gt; (), &lt;a href=&quot;qtextformat#toTableFormat&quot;&gt;toTableFormat&lt;/a&gt; (), &lt;a href=&quot;qtextformat#toFrameFormat&quot;&gt;toFrameFormat&lt;/a&gt; () 및 &lt;a href=&quot;qtextformat#toImageFormat&quot;&gt;toImageFormat&lt;/a&gt; ()을 사용 하여 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="24474565d4d17a8d58ba620b9918416cf8a79454" translate="yes" xml:space="preserve">
          <source>The format used for showing labels in a bar series.</source>
          <target state="translated">막대 시리즈에 레이블을 표시하는 데 사용되는 형식입니다.</target>
        </trans-unit>
        <trans-unit id="baae0991a25fe6dca7171f0b0a43fdff3bcfeef2" translate="yes" xml:space="preserve">
          <source>The format used for showing labels with data points.</source>
          <target state="translated">데이터 포인트가있는 레이블을 표시하는 데 사용되는 형식입니다.</target>
        </trans-unit>
        <trans-unit id="8debe8c0ad9ce823c0a439e537a668d8ba8f4e5e" translate="yes" xml:space="preserve">
          <source>The format used for showing labels with series points.</source>
          <target state="translated">시리즈 포인트가있는 레이블을 표시하는 데 사용되는 형식입니다.</target>
        </trans-unit>
        <trans-unit id="466f06f7f9019bd04a6a338e8cff80cd2ebc6c18" translate="yes" xml:space="preserve">
          <source>The format-specific configuration variables define the generated documentation's style, or define the contents of the documentation's footer or postheader.</source>
          <target state="translated">형식 별 구성 변수는 생성 된 문서 스타일을 정의하거나 문서 바닥 글 또는 포스트 헤더의 내용을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="b56490a88a65143b619c4e2dea348490533d1914" translate="yes" xml:space="preserve">
          <source>The formatted item label. If there is no selected item or the selected item is not visible, returns an empty string.</source>
          <target state="translated">서식이 지정된 항목 레이블 선택한 항목이 없거나 선택한 항목이 보이지 않으면 빈 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c2fe90ef82c6c0822da9584c31705f0c980339b4" translate="yes" xml:space="preserve">
          <source>The formatted string will appear as the name of this test data in the test output.</source>
          <target state="translated">형식화 된 문자열은 테스트 출력에서이 테스트 데이터의 이름으로 나타납니다.</target>
        </trans-unit>
        <trans-unit id="fec0bad7da60bc2d30f0a2b21b300fee241bd105" translate="yes" xml:space="preserve">
          <source>The formatted text can be drawn onto a paint device; in the above code, the text is drawn directly onto a widget.</source>
          <target state="translated">형식이 지정된 텍스트는 페인트 장치에 그릴 수 있습니다. 위 코드에서 텍스트는 위젯에 직접 그려집니다.</target>
        </trans-unit>
        <trans-unit id="cadd0ff427f5d08677f8c33b96da3f135dc9511b" translate="yes" xml:space="preserve">
          <source>The formatting always uses &lt;a href=&quot;qlocale#Language-enum&quot;&gt;QLocale::C&lt;/a&gt;, i.e., English/UnitedStates. To get a localized string representation of a number, use &lt;a href=&quot;qlocale#toString&quot;&gt;QLocale::toString&lt;/a&gt;() with the appropriate locale.</source>
          <target state="translated">서식은 항상 &lt;a href=&quot;qlocale#Language-enum&quot;&gt;QLocale :: C를&lt;/a&gt; 사용합니다 ( 예 : 영어 / 미국). 숫자의 지역화 된 문자열 표현을 얻으려면 적절한 로케일과 함께 &lt;a href=&quot;qlocale#toString&quot;&gt;QLocale :: toString&lt;/a&gt; ()을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="73d75d02927dceeb8ff8bc585415ffe2b87697c7" translate="yes" xml:space="preserve">
          <source>The formatting always uses &lt;a href=&quot;qlocale#Language-enum&quot;&gt;QLocale::C&lt;/a&gt;.</source>
          <target state="translated">The formatting always uses &lt;a href=&quot;qlocale#Language-enum&quot;&gt;QLocale::C&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="836c3c3988ae6708b9901f8270026fb114770b69" translate="yes" xml:space="preserve">
          <source>The formatting options define how the URL is formatted when written out as text.</source>
          <target state="translated">서식 옵션은 텍스트로 쓸 때 URL의 형식을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="25eff82c6dda33e9b770983f8f62e4183e511877" translate="yes" xml:space="preserve">
          <source>The former is the standard form which registers the type</source>
          <target state="translated">전자는 형식을 등록하는 표준 형식입니다</target>
        </trans-unit>
        <trans-unit id="a118635d2eec81a36d869e035b90bf5e966510cf" translate="yes" xml:space="preserve">
          <source>The former is useful if the application is mainly written using the native platform APIs, but where parts of the application uses Qt, for example to draw a specialized UI. To embed Qt into the window hierarchy of the native application, use &lt;a href=&quot;qwindow#winId&quot;&gt;QWindow::winId&lt;/a&gt;() to get the native handle for the Qt window, and then use the native APIs to re-parent the window into the native UI.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4ad161821594f9128ca604054e4c53cf0bee8eb" translate="yes" xml:space="preserve">
          <source>The four concentric rectangles appear conceptually as below:</source>
          <target state="translated">네 개의 동심원 사각형은 다음과 같이 개념적으로 나타납니다.</target>
        </trans-unit>
        <trans-unit id="d6b7c8d8837be7201d8493abb3caa32efa3f1a54" translate="yes" xml:space="preserve">
          <source>The fractional part of the second, to go after a decimal point, without trailing zeroes (0 to 999). Thus &quot;&lt;code&gt;s.z&lt;/code&gt;&quot; reports the seconds to full available (millisecond) precision without trailing zeroes.</source>
          <target state="translated">The fractional part of the second, to go after a decimal point, without trailing zeroes (0 to 999). Thus &quot; &lt;code&gt;s.z&lt;/code&gt; &quot; reports the seconds to full available (millisecond) precision without trailing zeroes.</target>
        </trans-unit>
        <trans-unit id="294a8c6c4111c415c911d83a31d4076b03a1669d" translate="yes" xml:space="preserve">
          <source>The fractional part of the second, to millisecond precision, including trailing zeroes where applicable (000 to 999).</source>
          <target state="translated">The fractional part of the second, to millisecond precision, including trailing zeroes where applicable (000 to 999).</target>
        </trans-unit>
        <trans-unit id="29059380c9e9c0064be97d84e2d0c7d5e5b39af4" translate="yes" xml:space="preserve">
          <source>The fragment is sometimes also referred to as the URL &quot;reference&quot;.</source>
          <target state="translated">이 조각을 URL &quot;참조&quot;라고도합니다.</target>
        </trans-unit>
        <trans-unit id="67ed4c45544cb9fa390688a53ba00bd6bd8fab82" translate="yes" xml:space="preserve">
          <source>The fragment shader must contain a function called &lt;code&gt;MAIN&lt;/code&gt;. The final fragment color is determined by &lt;code&gt;FRAGCOLOR&lt;/code&gt;. The main input texture, with the contents of the &lt;a href=&quot;qml-qtquick3d-view3d&quot;&gt;View3D&lt;/a&gt;'s scene, is accessible under a &lt;code&gt;sampler2D&lt;/code&gt; with the name &lt;code&gt;INPUT&lt;/code&gt;. The UV coordinates from the quad are in &lt;code&gt;INPUT_UV&lt;/code&gt;. These UV values are always suitable for sampling &lt;code&gt;INPUT&lt;/code&gt;, regardless of the underlying graphics API at run time (and so regardless of the Y axis direction in images since the necessary adjustments are applied automatically by Qt Quick 3D). Sampling the texture with our external image is done using &lt;code&gt;TEXTURE_UV&lt;/code&gt;. &lt;code&gt;INPUT_UV&lt;/code&gt; is not suitable in cross-platform applications since V needs to be flipped to cater for the coordinate system differences mentioned before, using a logic that is different for textures based on images and textures used as render targets. Fortunately this is all taken care of by the engine so the shader need no further logic for this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10717af969cd4aca9ade17943d063a4fa34788f2" translate="yes" xml:space="preserve">
          <source>The fragment that represents the image can be found by iterating over the fragments in the text block that contains the image.</source>
          <target state="translated">이미지를 나타내는 조각은 이미지가 포함 된 텍스트 블록의 조각을 반복하여 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bd447833fcd39a4e6c42491031b7a11afdd41681" translate="yes" xml:space="preserve">
          <source>The fragments within a given block can be examined by using a &lt;a href=&quot;qtextblock-iterator&quot;&gt;QTextBlock::iterator&lt;/a&gt; to traverse the block's internal structure:</source>
          <target state="translated">주어진 블록 내의 조각은 &lt;a href=&quot;qtextblock-iterator&quot;&gt;QTextBlock :: iterator&lt;/a&gt; 를 사용 하여 블록의 내부 구조를 순회 하여 검사 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="176d80370fc5742e0bc069e33a32483847e82c1d" translate="yes" xml:space="preserve">
          <source>The frame around the combobox can be styled using the &lt;a href=&quot;stylesheet-customizing#box-model&quot;&gt;box model&lt;/a&gt;. The drop-down button can be styled using the &lt;a href=&quot;#drop-down-sub&quot;&gt;::drop-down&lt;/a&gt; subcontrol. By default, the drop-down button is placed in the top right corner of the padding rectangle of the widget. The arrow mark inside the drop-down button can be styled using the &lt;a href=&quot;#down-arrow-sub&quot;&gt;::down-arrow&lt;/a&gt; subcontrol. By default, the arrow is placed in the center of the contents rectangle of the drop-down subcontrol.</source>
          <target state="translated">콤보 박스 주위의 프레임은 &lt;a href=&quot;stylesheet-customizing#box-model&quot;&gt;박스 모델을&lt;/a&gt; 사용하여 스타일을 지정할 수 있습니다 . &lt;a href=&quot;#drop-down-sub&quot;&gt;:: drop-down&lt;/a&gt; 하위 컨트롤을 사용하여 드롭 다운 버튼의 스타일을 지정할 수 있습니다 . 기본적으로 드롭 다운 단추는 위젯의 패딩 사각형 오른쪽 상단 모서리에 있습니다. &lt;a href=&quot;#down-arrow-sub&quot;&gt;:: down-arrow&lt;/a&gt; 하위 컨트롤을 사용하여 드롭 다운 버튼 안의 화살표를 스타일 지정할 수 있습니다 . 기본적으로 화살표는 드롭 다운 하위 컨트롤의 내용 사각형 가운데에 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="aad76f65aa09ea24322b693e6ae05e8b089247f4" translate="yes" xml:space="preserve">
          <source>The frame around the combobox can be styled using the &lt;a href=&quot;stylesheet-customizing#box-model&quot;&gt;box model&lt;/a&gt;. The drop-down button can be styled using the &lt;a href=&quot;stylesheet-reference#drop-down-sub&quot;&gt;::drop-down&lt;/a&gt; subcontrol. By default, the drop-down button is placed in the top right corner of the padding rectangle of the widget. The arrow mark inside the drop-down button can be styled using the &lt;a href=&quot;stylesheet-reference#down-arrow-sub&quot;&gt;::down-arrow&lt;/a&gt; subcontrol. By default, the arrow is placed in the center of the contents rectangle of the drop-down subcontrol.</source>
          <target state="translated">The frame around the combobox can be styled using the &lt;a href=&quot;stylesheet-customizing#box-model&quot;&gt;box model&lt;/a&gt;. The drop-down button can be styled using the &lt;a href=&quot;stylesheet-reference#drop-down-sub&quot;&gt;::drop-down&lt;/a&gt; subcontrol. By default, the drop-down button is placed in the top right corner of the padding rectangle of the widget. The arrow mark inside the drop-down button can be styled using the &lt;a href=&quot;stylesheet-reference#down-arrow-sub&quot;&gt;::down-arrow&lt;/a&gt; subcontrol. By default, the arrow is placed in the center of the contents rectangle of the drop-down subcontrol.</target>
        </trans-unit>
        <trans-unit id="613216ab47f8f4f39f395a80e5db74c0500c6229" translate="yes" xml:space="preserve">
          <source>The frame around the tumbler.</source>
          <target state="translated">텀블러 주위의 프레임입니다.</target>
        </trans-unit>
        <trans-unit id="9716fa1be4b2d451e652f75cb201a67f6bbb1cbe" translate="yes" xml:space="preserve">
          <source>The frame contains a bottom field.</source>
          <target state="translated">프레임은 하단 필드를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="63c7c1c082511d58bc286cf83f82777af2480612" translate="yes" xml:space="preserve">
          <source>The frame contains a merged top and bottom field.</source>
          <target state="translated">프레임은 병합 된 상단 및 하단 필드를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="3c07e3f9556df475923afa983be4ea2fd568d72f" translate="yes" xml:space="preserve">
          <source>The frame contains a top field.</source>
          <target state="translated">프레임은 상단 필드를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="a844033e407a45f0020aaeda36cb9c16229ec021" translate="yes" xml:space="preserve">
          <source>The frame could not be sent due to lost arbitration on the bus.</source>
          <target state="translated">버스에서 중재 손실로 인해 프레임을 전송할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="642e1e33a390aea152a3aaacb9654eaaf85c7518" translate="yes" xml:space="preserve">
          <source>The frame for tab widgets use &lt;a href=&quot;qstyleoptiontabwidgetframe&quot;&gt;QStyleOptionTabWidgetFrame&lt;/a&gt; as style option. We list its members here. It does not have states set besides the common flags.</source>
          <target state="translated">탭 위젯의 프레임은 &lt;a href=&quot;qstyleoptiontabwidgetframe&quot;&gt;QStyleOptionTabWidgetFrame&lt;/a&gt; 을 스타일 옵션으로 사용합니다. 우리는 여기에 회원을 나열합니다. 공통 플래그 외에 상태가 설정되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2c9c03d235c849d965a072f243de6b26113760e7" translate="yes" xml:space="preserve">
          <source>The frame format defines the &lt;a href=&quot;qtextframeformat#width&quot;&gt;width&lt;/a&gt;() and &lt;a href=&quot;qtextframeformat#height&quot;&gt;height&lt;/a&gt;() of the frame on the screen. Each frame can have a &lt;a href=&quot;qtextframeformat#border&quot;&gt;border&lt;/a&gt;() that surrounds its contents with a rectangular box. The border is surrounded by a &lt;a href=&quot;qtextframeformat#margin&quot;&gt;margin&lt;/a&gt;() around the frame, and the contents of the frame are kept separate from the border by the frame's &lt;a href=&quot;qtextframeformat#padding&quot;&gt;padding&lt;/a&gt;(). This scheme is similar to the box model used by Cascading Style Sheets for HTML pages.</source>
          <target state="translated">프레임 형식은 화면에서 프레임 의 &lt;a href=&quot;qtextframeformat#width&quot;&gt;너비&lt;/a&gt; () 및 &lt;a href=&quot;qtextframeformat#height&quot;&gt;높이&lt;/a&gt; ()를 정의합니다 . 각 프레임에는 내용물을 사각형 상자로 둘러싸 는 &lt;a href=&quot;qtextframeformat#border&quot;&gt;테두리&lt;/a&gt; ()가 있을 수 있습니다 . 테두리는 프레임 주위에 &lt;a href=&quot;qtextframeformat#margin&quot;&gt;여백&lt;/a&gt; ()으로 둘러싸여 있으며 프레임의 내용은 프레임의 &lt;a href=&quot;qtextframeformat#padding&quot;&gt;패딩&lt;/a&gt; ()으로 테두리와 분리되어 있습니다 . 이 체계는 HTML 페이지에 CSS (Cascading Style Sheets)에서 사용하는 상자 모델과 유사합니다.</target>
        </trans-unit>
        <trans-unit id="4ab66ba3abb05cb1366e2b77ebfee7e3bdb16e7a" translate="yes" xml:space="preserve">
          <source>The frame format will give the frame an external margin of 32 pixels, internal padding of 8 pixels, and a border that is 4 pixels wide. See the &lt;a href=&quot;qtextframeformat&quot;&gt;QTextFrameFormat&lt;/a&gt; documentation for more information about frame formats.</source>
          <target state="translated">프레임 형식은 프레임에 32 픽셀의 외부 여백, 8 픽셀의 내부 패딩 및 4 픽셀 너비의 테두리를 제공합니다. 참고 항목 &lt;a href=&quot;qtextframeformat&quot;&gt;QTextFrameFormat의&lt;/a&gt; 프레임 형식에 대한 자세한 내용은 문서를.</target>
        </trans-unit>
        <trans-unit id="5c4c351a45187b7a9fa06443424e7032b3c14d3d" translate="yes" xml:space="preserve">
          <source>The frame interface is useful for standard widgets, but &lt;a href=&quot;qtimeline&quot;&gt;QTimeLine&lt;/a&gt; can be used to control any type of animation. The heart of &lt;a href=&quot;qtimeline&quot;&gt;QTimeLine&lt;/a&gt; lies in the &lt;a href=&quot;qtimeline#valueForTime&quot;&gt;valueForTime&lt;/a&gt;() function, which generates a</source>
          <target state="translated">프레임 인터페이스는 표준 위젯에 유용하지만 &lt;a href=&quot;qtimeline&quot;&gt;QTimeLine&lt;/a&gt; 을 사용하여 모든 유형의 애니메이션을 제어 할 수 있습니다. 의 중심 &lt;a href=&quot;qtimeline&quot;&gt;QTimeLine는&lt;/a&gt; 에 놓여 &lt;a href=&quot;qtimeline#valueForTime&quot;&gt;valueForTime&lt;/a&gt; 으로서 a () 함수</target>
        </trans-unit>
        <trans-unit id="7ec7619c2c1c84a98860506118254a36698ce7bd" translate="yes" xml:space="preserve">
          <source>The frame interface is useful for standard widgets, but QTimeLine can be used to control any type of animation. The heart of QTimeLine lies in the &lt;a href=&quot;qtimeline#valueForTime&quot;&gt;valueForTime&lt;/a&gt;() function, which generates a</source>
          <target state="translated">The frame interface is useful for standard widgets, but QTimeLine can be used to control any type of animation. The heart of QTimeLine lies in the &lt;a href=&quot;qtimeline#valueForTime&quot;&gt;valueForTime&lt;/a&gt;() function, which generates a</target>
        </trans-unit>
        <trans-unit id="42171047631cbd6bd5dc10da58288b7ed5432546" translate="yes" xml:space="preserve">
          <source>The frame is flat by default.</source>
          <target state="translated">프레임은 기본적으로 평평합니다.</target>
        </trans-unit>
        <trans-unit id="d419c25974c89ce22ad36eb54c955fa895752938" translate="yes" xml:space="preserve">
          <source>The frame is inserted into the document after the preceding text:</source>
          <target state="translated">이전 텍스트 다음에 프레임이 문서에 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="9052457702c7e17e706f4a6330f637976448bd2d" translate="yes" xml:space="preserve">
          <source>The frame is invalid.</source>
          <target state="translated">프레임이 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4a39637219d8dd7fd5a95c4e89115b01d9f629ce" translate="yes" xml:space="preserve">
          <source>The frame is not interlaced.</source>
          <target state="translated">프레임이 인터레이스되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="14fe17316c7d93bb4e211bcb3cf4802b9654df65" translate="yes" xml:space="preserve">
          <source>The frame is now ready. The buffers are swapped (OpenGL), or a present command is recorded and the command buffers are submitted to a graphics queue (Vulkan, Metal). &lt;a href=&quot;qquickwindow#frameSwapped&quot;&gt;QQuickWindow::frameSwapped&lt;/a&gt;() is emitted.</source>
          <target state="translated">The frame is now ready. The buffers are swapped (OpenGL), or a present command is recorded and the command buffers are submitted to a graphics queue (Vulkan, Metal). &lt;a href=&quot;qquickwindow#frameSwapped&quot;&gt;QQuickWindow::frameSwapped&lt;/a&gt;() is emitted.</target>
        </trans-unit>
        <trans-unit id="8a0b42ad27d2073430b9747ce65548a775cdf37b" translate="yes" xml:space="preserve">
          <source>The frame is stored in compressed Jpeg format.</source>
          <target state="translated">프레임은 압축 Jpeg 형식으로 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="1ce7202b94f86d9eac0f20a6eeadc0759d3c1158" translate="yes" xml:space="preserve">
          <source>The frame is stored using a 16-bit BGR format (5-5-5).</source>
          <target state="translated">프레임은 16 비트 BGR 형식 (5-5-5)을 사용하여 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="20d54836baf90d344c7b0c3ea785c6cde9dbba26" translate="yes" xml:space="preserve">
          <source>The frame is stored using a 16-bit BGR format (5-6-5).</source>
          <target state="translated">프레임은 16 비트 BGR 형식 (5-6-5)을 사용하여 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="78e8cbffdbca1f78d2a8ed1ea169620c7440887c" translate="yes" xml:space="preserve">
          <source>The frame is stored using a 16-bit RGB format (5-5-5). This is equivalent to &lt;a href=&quot;qimage#Format-enum&quot;&gt;QImage::Format_RGB555&lt;/a&gt;.</source>
          <target state="translated">프레임은 16 비트 RGB 형식 (5-5-5)을 사용하여 저장됩니다. 이것은 &lt;a href=&quot;qimage#Format-enum&quot;&gt;QImage :: Format_RGB555&lt;/a&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="25cdc08f8a2642c7939c6414343aba045a7da624" translate="yes" xml:space="preserve">
          <source>The frame is stored using a 16-bit RGB format (5-6-5). This is equivalent to &lt;a href=&quot;qimage#Format-enum&quot;&gt;QImage::Format_RGB16&lt;/a&gt;.</source>
          <target state="translated">프레임은 16 비트 RGB 형식 (5-6-5)을 사용하여 저장됩니다. 이것은 &lt;a href=&quot;qimage#Format-enum&quot;&gt;QImage :: Format_RGB16&lt;/a&gt; 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="a5356d5061dc637ebce4bd79beb2d404656e0bce" translate="yes" xml:space="preserve">
          <source>The frame is stored using a 16-bit linear greyscale format. Little endian.</source>
          <target state="translated">프레임은 16 비트 선형 그레이 스케일 형식을 사용하여 저장됩니다. 리틀 엔디안.</target>
        </trans-unit>
        <trans-unit id="ba3c7d61f6aee2e1e49a1a026fba3940bce0b0b4" translate="yes" xml:space="preserve">
          <source>The frame is stored using a 24-bit BGR format (0xBBGGRR).</source>
          <target state="translated">프레임은 24 비트 BGR 형식 (0xBBGGRR)을 사용하여 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="889f06ef444d0a613bfbe8d8952832ca769a0097" translate="yes" xml:space="preserve">
          <source>The frame is stored using a 24-bit RGB format (8-8-8). This is equivalent to &lt;a href=&quot;qimage#Format-enum&quot;&gt;QImage::Format_RGB888&lt;/a&gt;</source>
          <target state="translated">프레임은 24 비트 RGB 형식 (8-8-8)을 사용하여 저장됩니다. 이것은 &lt;a href=&quot;qimage#Format-enum&quot;&gt;QImage :: Format_RGB888&lt;/a&gt; 과 같습니다.</target>
        </trans-unit>
        <trans-unit id="577a58092bc9f865cf05117f79d11d2a0d29e171" translate="yes" xml:space="preserve">
          <source>The frame is stored using a 24-bit packed YUV format (8-8-8).</source>
          <target state="translated">프레임은 24 비트 팩 YUV 형식 (8-8-8)을 사용하여 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="99fe35f459080b13e945183b389b8446bfb896a1" translate="yes" xml:space="preserve">
          <source>The frame is stored using a 24-bit premultiplied ARGB format (8-5-6-5).</source>
          <target state="translated">프레임은 24 비트 미리 곱한 ARGB 형식 (8-5-6-5)을 사용하여 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="780c5818506c6fdfa1644953ee5e644ec8cd8369" translate="yes" xml:space="preserve">
          <source>The frame is stored using a 24-bit premultiplied BGRA format (5-6-5-8).</source>
          <target state="translated">프레임은 24 비트 사전 곱한 BGRA 형식 (5-6-5-8)을 사용하여 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="f74089029d0cbee4df329fb11c5bae44203b4a52" translate="yes" xml:space="preserve">
          <source>The frame is stored using a 32-bit ABGR format (0xAABBGGRR).</source>
          <target state="translated">프레임은 32 비트 ABGR 형식 (0xAABBGGRR)을 사용하여 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="47736f2d007bf751b31d079f0cabdb7a5e82d2d3" translate="yes" xml:space="preserve">
          <source>The frame is stored using a 32-bit ARGB format (0xAARRGGBB). This is equivalent to &lt;a href=&quot;qimage#Format-enum&quot;&gt;QImage::Format_ARGB32&lt;/a&gt;.</source>
          <target state="translated">프레임은 32 비트 ARGB 형식 (0xAARRGGBB)을 사용하여 저장됩니다. 이것은 &lt;a href=&quot;qimage#Format-enum&quot;&gt;QImage :: Format_ARGB32&lt;/a&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="076cbfd2f9f726de9159e680e698a19be099bd21" translate="yes" xml:space="preserve">
          <source>The frame is stored using a 32-bit BGR format (0xBBGGRRff).</source>
          <target state="translated">프레임은 32 비트 BGR 형식 (0xBBGGRRff)을 사용하여 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="48cbf79ec2dc32655201e58a3d2696df3f351ba3" translate="yes" xml:space="preserve">
          <source>The frame is stored using a 32-bit BGRA format (0xBBGGRRAA).</source>
          <target state="translated">프레임은 32 비트 BGRA 형식 (0xBBGGRRAA)을 사용하여 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="8ef7e42861dda2927eecb3632b7714bfa8ab9ab3" translate="yes" xml:space="preserve">
          <source>The frame is stored using a device specific camera raw format.</source>
          <target state="translated">프레임은 장치 별 Camera Raw 형식을 사용하여 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="d9e509b4207373dff363ed05feac046756ab4aea" translate="yes" xml:space="preserve">
          <source>The frame is stored using a packed 32-bit AYUV format (0xAAYYUUVV).</source>
          <target state="translated">프레임은 압축 된 32 비트 AYUV 형식 (0xAAYYUUVV)을 사용하여 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="b10ad5cebf12053930d6a3112e7b4c0f74fb06b9" translate="yes" xml:space="preserve">
          <source>The frame is stored using a packed premultiplied 32-bit AYUV format (0xAAYYUUVV).</source>
          <target state="translated">프레임은 미리 곱셈 된 32 비트 AYUV 형식 (0xAAYYUUVV)을 사용하여 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="37508a5ad4e68cb6d389e651e8a1a69b04f67a57" translate="yes" xml:space="preserve">
          <source>The frame is stored using a premultiplied 32bit BGRA format.</source>
          <target state="translated">프레임은 미리 곱셈 된 32 비트 BGRA 형식을 사용하여 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="099f3a7a2ae7522572a3305b1f9ebb1d40a34c25" translate="yes" xml:space="preserve">
          <source>The frame is stored using an 8-bit greyscale format.</source>
          <target state="translated">프레임은 8 비트 그레이 스케일 형식으로 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="299c26040a16aba73b651a092cc4e0f3db407d0e" translate="yes" xml:space="preserve">
          <source>The frame is stored using an 8-bit per component packed YUV format with the U and V planes horizontally sub-sampled (U-Y-V-Y), i.e. two horizontally adjacent pixels are stored as a 32-bit macropixel which has a Y value for each pixel and common U and V values.</source>
          <target state="translated">프레임은 UYVY (Yorizontal sub-sampled) 평면과 U 및 V 평면과 함께 컴포넌트 단위 YUV 형식으로 8 비트 단위로 저장됩니다. 즉, 두 개의 수평으로 인접한 픽셀은 각 픽셀에 대해 Y 값을 가진 32 비트 매크로 픽셀 공통 U 및 V 값.</target>
        </trans-unit>
        <trans-unit id="7a3a6b71632a211c0884c90b5b264ac9d081e854" translate="yes" xml:space="preserve">
          <source>The frame is stored using an 8-bit per component packed YUV format with the U and V planes horizontally sub-sampled (Y-U-Y-V), i.e. two horizontally adjacent pixels are stored as a 32-bit macropixel which has a Y value for each pixel and common U and V values.</source>
          <target state="translated">프레임은 UY 및 V 평면 수평 서브 샘플링 (YUYV)과 함께 8 비트 컴포넌트 팩 YUV 형식을 사용하여 저장됩니다. 즉, 두 개의 수평으로 인접한 픽셀은 각 픽셀에 대해 Y 값을 갖는 32 비트 매크로 픽셀로 저장됩니다. 공통 U 및 V 값.</target>
        </trans-unit>
        <trans-unit id="6e44f4de1ec15a128da9b13b7f9ca0121497692b" translate="yes" xml:space="preserve">
          <source>The frame is stored using an 8-bit per component planar YUV format with the U and V planes horizontally and vertically sub-sampled, i.e. the height and width of the U and V planes are half that of the Y plane.</source>
          <target state="translated">프레임은 수평 및 수직 서브 샘플링 된 U 및 V 평면과 함께 구성 요소 평면 YUV 형식 당 8 비트를 사용하여 저장됩니다. 즉, U 및 V 평면의 높이와 너비는 Y 평면의 절반입니다.</target>
        </trans-unit>
        <trans-unit id="5da576d3d59a592e150eb8d5c29e0f73d3b05db2" translate="yes" xml:space="preserve">
          <source>The frame is stored using an 8-bit per component planar YUV format with the U and V planes horizontally and vertically sub-sampled. This is similar to the Format_YUV420P type, except that the bytes per line of the U and V planes are padded out to the same stride as the Y plane.</source>
          <target state="translated">프레임은 수평 및 수직 서브 샘플링 된 U 및 V 평면과 함께 구성 요소 평면 YUV 형식 당 8 비트를 사용하여 저장됩니다. 이것은 U 평면과 V 평면의 라인 당 바이트가 Y 평면과 동일한 보폭으로 채워진다는 점을 제외하면 Format_YUV420P 유형과 유사합니다.</target>
        </trans-unit>
        <trans-unit id="cf61507d1c02d262558bf11966ae859df83f32fd" translate="yes" xml:space="preserve">
          <source>The frame is stored using an 8-bit per component planar YUV format with the U and V planes horizontally and vertically sub-sampled. This is similar to the Format_YUV420P type, except that the lines of the U and V planes are interleaved, i.e. each line of U data is followed by a line of V data creating a single line of the same stride as the Y data.</source>
          <target state="translated">프레임은 수평 및 수직 서브 샘플링 된 U 및 V 평면과 함께 구성 요소 평면 YUV 형식 당 8 비트를 사용하여 저장됩니다. 이는 U 평면과 V 평면의 선이 인터리브된다는 점을 제외하면 Format_YUV420P 유형과 유사합니다. 즉, U 데이터의 각 선 뒤에 V 데이터 선이 이어지고 Y 데이터와 동일한 보폭의 단일 선이 만들어집니다.</target>
        </trans-unit>
        <trans-unit id="6216ed714b9b48b8fa817de950e66d4c8002dbc8" translate="yes" xml:space="preserve">
          <source>The frame is stored using an 8-bit per component planar YUV format with the U and V planes horizontally sub-sampled, i.e. the width of the U and V planes are half that of the Y plane, and height of U and V planes is the same as Y.</source>
          <target state="translated">The frame is stored using an 8-bit per component planar YUV format with the U and V planes horizontally sub-sampled, i.e. the width of the U and V planes are half that of the Y plane, and height of U and V planes is the same as Y.</target>
        </trans-unit>
        <trans-unit id="63f3b47f98ad73da545b35fc0fc7e7cda4a224ff" translate="yes" xml:space="preserve">
          <source>The frame is stored using an 8-bit per component planar YVU format with the V and U planes horizontally and vertically sub-sampled, i.e. the height and width of the V and U planes are half that of the Y plane.</source>
          <target state="translated">프레임은 수평 및 수직 서브 샘플링 된 V 및 U 평면, 즉 V 및 U 평면의 높이와 너비는 Y 평면의 절반과 절반으로 구성 요소 당 8 비트 평면 YVU 형식을 사용하여 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="1403c9cf381a1677d0945afe202ad8976f8c1353" translate="yes" xml:space="preserve">
          <source>The frame is stored using an 8-bit per component planar YVU format with the V and U planes horizontally and vertically sub-sampled. This is similar to the Format_YV12 type, except that the bytes per line of the V and U planes are padded out to the same stride as the Y plane.</source>
          <target state="translated">프레임은 수평 및 수직 서브 샘플링 된 V 및 U 평면과 함께 컴포넌트 별 평면 YVU 형식으로 8 비트를 사용하여 저장됩니다. 이는 V 및 U 평면의 행당 바이트가 Y 평면과 동일한 보폭으로 채워진다는 점을 제외하면 Format_YV12 유형과 유사합니다.</target>
        </trans-unit>
        <trans-unit id="af286c682a92d495b9e27efbff2886fd331b68e1" translate="yes" xml:space="preserve">
          <source>The frame is stored using an 8-bit per component planar YVU format with the V and U planes horizontally and vertically sub-sampled. This is similar to the Format_YV12 type, except that the lines of the V and U planes are interleaved, i.e. each line of V data is followed by a line of U data creating a single line of the same stride as the Y data.</source>
          <target state="translated">프레임은 수평 및 수직 서브 샘플링 된 V 및 U 평면과 함께 컴포넌트 별 평면 YVU 형식으로 8 비트를 사용하여 저장됩니다. 이는 V 및 U 평면의 선이 인터리브된다는 점을 제외하고는 Format_YV12 유형과 유사합니다. 즉, V 데이터의 각 선 뒤에 U 데이터 선이 이어지고 Y 데이터와 같은 보폭의 단일 선이 만들어집니다.</target>
        </trans-unit>
        <trans-unit id="3a1571cc09afeae6d1a5e578816b9f5b149a5a56" translate="yes" xml:space="preserve">
          <source>The frame is stored using an 8-bit per component semi-planar YUV format with a Y plane (Y) followed by a horizontally and vertically sub-sampled, packed UV plane (U-V).</source>
          <target state="translated">프레임은 Y 평면 (Y)과 수평 및 수직 서브 샘플링 된 UV 평면 (UV)이 뒤 따르는 구성 요소 당 8 비트 반평면 YUV 형식을 사용하여 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="b060df5e38b012b9db15701d22f7011f59765576" translate="yes" xml:space="preserve">
          <source>The frame is stored using an 8-bit per component semi-planar YUV format with a Y plane (Y) followed by a horizontally and vertically sub-sampled, packed VU plane (V-U).</source>
          <target state="translated">프레임은 Y 평면 (Y)과 수평 및 수직 서브 샘플링 된 VU 평면 (VU)이 뒤 따르는 구성 요소 당 8 비트 반평면 YUV 형식으로 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="4e62d6a3dac5634ac3422e1edfe245660eb90053" translate="yes" xml:space="preserve">
          <source>The frame is stored using raw Adobe Digital Negative (DNG) format.</source>
          <target state="translated">프레임은 원시 Adobe Digital Negative (DNG) 형식을 사용하여 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="d52f683a7c94c7be8ce7ef68e6e2489ecbeaedc2" translate="yes" xml:space="preserve">
          <source>The frame latency in range 1 - 16. The default value is 0 (disabled). Changes the limit for Present() and triggers a wait for an available swap chain buffer when beginning each frame. For a detailed discussion, see the article linked above.</source>
          <target state="translated">1-16 범위의 프레임 대기 시간입니다. 기본값은 0 (사용 안함)입니다. Present ()에 대한 제한을 변경하고 각 프레임을 시작할 때 사용 가능한 스왑 체인 버퍼에 대한 대기를 트리거합니다. 자세한 내용은 위에 링크 된 기사를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="992096b75b46b6fbde9c7160c563ea9e808c9a98" translate="yes" xml:space="preserve">
          <source>The frame of a group box.</source>
          <target state="translated">그룹 상자의 프레임입니다.</target>
        </trans-unit>
        <trans-unit id="7041fc5e173e3b0e762a11c051ee006f14884fb8" translate="yes" xml:space="preserve">
          <source>The frame of the spin box can be styled using the &lt;a href=&quot;stylesheet-customizing#box-model&quot;&gt;box model&lt;/a&gt;.</source>
          <target state="translated">스핀 상자의 프레임은 &lt;a href=&quot;stylesheet-customizing#box-model&quot;&gt;상자 모델을&lt;/a&gt; 사용하여 스타일을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="daf255bb3ecd535632738b6936b82d4a8d86d53a" translate="yes" xml:space="preserve">
          <source>The frame of the tab widget is styled using the &lt;a href=&quot;#pane-sub&quot;&gt;::pane&lt;/a&gt; subcontrol. The left and right corners are styled using the &lt;a href=&quot;#left-corner-sub&quot;&gt;::left-corner&lt;/a&gt; and &lt;a href=&quot;#right-corner-sub&quot;&gt;::right-corner&lt;/a&gt; respectively. The position of the tab bar is controlled using the &lt;a href=&quot;#tab-bar-sub&quot;&gt;::tab-bar&lt;/a&gt; subcontrol.</source>
          <target state="translated">탭 위젯의 프레임은 &lt;a href=&quot;#pane-sub&quot;&gt;:: pane&lt;/a&gt; 하위 컨트롤을 사용하여 스타일이 지정됩니다 . 왼쪽 및 오른쪽 모서리는 각각 &lt;a href=&quot;#left-corner-sub&quot;&gt;:: left-corner&lt;/a&gt; 및 &lt;a href=&quot;#right-corner-sub&quot;&gt;:: right-corner를&lt;/a&gt; 사용하여 스타일이 지정 됩니다. 탭 표시 줄의 위치는 &lt;a href=&quot;#tab-bar-sub&quot;&gt;:: tab-bar&lt;/a&gt; 하위 제어를 사용하여 제어됩니다 .</target>
        </trans-unit>
        <trans-unit id="13b1cc1b23805baf7793034991d5336dbedbc7b6" translate="yes" xml:space="preserve">
          <source>The frame of the tab widget is styled using the &lt;a href=&quot;stylesheet-reference#pane-sub&quot;&gt;::pane&lt;/a&gt; subcontrol. The left and right corners are styled using the &lt;a href=&quot;stylesheet-reference#left-corner-sub&quot;&gt;::left-corner&lt;/a&gt; and &lt;a href=&quot;stylesheet-reference#right-corner-sub&quot;&gt;::right-corner&lt;/a&gt; respectively. The position of the tab bar is controlled using the &lt;a href=&quot;stylesheet-reference#tab-bar-sub&quot;&gt;::tab-bar&lt;/a&gt; subcontrol.</source>
          <target state="translated">탭 위젯의 프레임은 &lt;a href=&quot;stylesheet-reference#pane-sub&quot;&gt;:: pane&lt;/a&gt; 하위 컨트롤을 사용하여 스타일이 지정됩니다 . 왼쪽 및 오른쪽 모서리는 각각 &lt;a href=&quot;stylesheet-reference#left-corner-sub&quot;&gt;:: left-corner&lt;/a&gt; 및 &lt;a href=&quot;stylesheet-reference#right-corner-sub&quot;&gt;:: right-corner를&lt;/a&gt; 사용하여 스타일이 지정 됩니다. 탭 표시 줄의 위치는 &lt;a href=&quot;stylesheet-reference#tab-bar-sub&quot;&gt;:: tab-bar&lt;/a&gt; 하위 컨트롤을 사용하여 제어됩니다 .</target>
        </trans-unit>
        <trans-unit id="baa9e7aa8351a485a4ceb30c1f08349411111a29" translate="yes" xml:space="preserve">
          <source>The frame rate between animations can vary by up to this amount. Variation will never decrease the length of the animation to less than 0.</source>
          <target state="translated">애니메이션 간의 프레임 속도는이 정도까지 변할 수 있습니다. 변형은 애니메이션 길이를 0보다 작게 줄이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6d7f544b4322f5adb7e978509e691dcd299b94cb" translate="yes" xml:space="preserve">
          <source>The frame rate of the media's video stream.</source>
          <target state="translated">미디어 비디오 스트림의 프레임 속도.</target>
        </trans-unit>
        <trans-unit id="99d557329c1c1e7da20285c150048f98728f6f71" translate="yes" xml:space="preserve">
          <source>The frame shapes are &lt;a href=&quot;qframe#Shape-enum&quot;&gt;NoFrame&lt;/a&gt;, &lt;a href=&quot;qframe#Shape-enum&quot;&gt;Box&lt;/a&gt;, &lt;a href=&quot;qframe#Shape-enum&quot;&gt;Panel&lt;/a&gt;, &lt;a href=&quot;qframe#Shape-enum&quot;&gt;StyledPanel&lt;/a&gt;, &lt;a href=&quot;qframe#Shape-enum&quot;&gt;HLine&lt;/a&gt; and &lt;a href=&quot;qframe#Shape-enum&quot;&gt;VLine&lt;/a&gt;; the shadow styles are &lt;a href=&quot;qframe#Shadow-enum&quot;&gt;Plain&lt;/a&gt;, &lt;a href=&quot;qframe#Shadow-enum&quot;&gt;Raised&lt;/a&gt; and &lt;a href=&quot;qframe#Shadow-enum&quot;&gt;Sunken&lt;/a&gt;.</source>
          <target state="translated">프레임 모양은 &lt;a href=&quot;qframe#Shape-enum&quot;&gt;NoFrame&lt;/a&gt; , &lt;a href=&quot;qframe#Shape-enum&quot;&gt;Box&lt;/a&gt; , &lt;a href=&quot;qframe#Shape-enum&quot;&gt;Panel&lt;/a&gt; , &lt;a href=&quot;qframe#Shape-enum&quot;&gt;StyledPanel&lt;/a&gt; , &lt;a href=&quot;qframe#Shape-enum&quot;&gt;HLine&lt;/a&gt; 및 &lt;a href=&quot;qframe#Shape-enum&quot;&gt;VLine입니다&lt;/a&gt; . 그림자 스타일은 &lt;a href=&quot;qframe#Shadow-enum&quot;&gt;Plain&lt;/a&gt; , &lt;a href=&quot;qframe#Shadow-enum&quot;&gt;Raised&lt;/a&gt; 및 &lt;a href=&quot;qframe#Shadow-enum&quot;&gt;Sunken&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6eb1e30cfc97e8d4256a00445cdffa67cbf1d028" translate="yes" xml:space="preserve">
          <source>The frame shapes are given in &lt;a href=&quot;qframe#Shape-enum&quot;&gt;QFrame::Shape&lt;/a&gt; and the shadow styles in &lt;a href=&quot;qframe#Shadow-enum&quot;&gt;QFrame::Shadow&lt;/a&gt;.</source>
          <target state="translated">프레임 모양은 &lt;a href=&quot;qframe#Shape-enum&quot;&gt;QFrame :: Shape&lt;/a&gt; 에, 그림자 스타일은 &lt;a href=&quot;qframe#Shadow-enum&quot;&gt;QFrame :: Shadow에 있습니다.&lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="eb576cbb1532163f39e6928273d74bd75ce38c9e" translate="yes" xml:space="preserve">
          <source>The frame stored using a 32-bit RGB format (0xffRRGGBB). This is equivalent to &lt;a href=&quot;qimage#Format-enum&quot;&gt;QImage::Format_RGB32&lt;/a&gt;</source>
          <target state="translated">프레임은 32 비트 RGB 형식 (0xffRRGGBB)을 사용하여 저장되었습니다. 이것은 &lt;a href=&quot;qimage#Format-enum&quot;&gt;QImage :: Format_RGB32&lt;/a&gt; 와 같습니다.</target>
        </trans-unit>
        <trans-unit id="49372d28fd78d90b19d197da7d90a4f96e79e1d4" translate="yes" xml:space="preserve">
          <source>The frame stored using a premultiplied 32-bit ARGB format (0xAARRGGBB). This is equivalent to &lt;a href=&quot;qimage#Format-enum&quot;&gt;QImage::Format_ARGB32_Premultiplied&lt;/a&gt;.</source>
          <target state="translated">프레임은 미리 곱셈 된 32 비트 ARGB 형식 (0xAARRGGBB)을 사용하여 저장됩니다. 이것은 &lt;a href=&quot;qimage#Format-enum&quot;&gt;QImage :: Format_ARGB32_Premultiplied&lt;/a&gt; 와 같습니다. .</target>
        </trans-unit>
        <trans-unit id="f30d9a13f29e2c9dce9e077352256688eea37dfb" translate="yes" xml:space="preserve">
          <source>The frame style is specified by a &lt;a href=&quot;qframe#Shape-enum&quot;&gt;frame shape&lt;/a&gt; and a &lt;a href=&quot;qframe#Shadow-enum&quot;&gt;shadow style&lt;/a&gt; that is used to visually separate the frame from surrounding widgets. These properties can be set together using the &lt;a href=&quot;qframe#setFrameStyle&quot;&gt;setFrameStyle&lt;/a&gt;() function and read with &lt;a href=&quot;qframe#frameStyle&quot;&gt;frameStyle&lt;/a&gt;().</source>
          <target state="translated">프레임 스타일은 &lt;a href=&quot;qframe#Shape-enum&quot;&gt;프레임 모양&lt;/a&gt; 과 &lt;a href=&quot;qframe#Shadow-enum&quot;&gt;그림자&lt;/a&gt; 스타일로 지정되어 프레임을 주변 위젯과 시각적으로 구분하는 데 사용됩니다. 이러한 속성은 &lt;a href=&quot;qframe#setFrameStyle&quot;&gt;setFrameStyle&lt;/a&gt; () 함수를 사용하여 함께 설정 하고 &lt;a href=&quot;qframe#frameStyle&quot;&gt;frameStyle로&lt;/a&gt; 읽을 수 있습니다 . ()로 .</target>
        </trans-unit>
        <trans-unit id="b1c883b098477df81fc3484872bc2b5baf8ba1a5" translate="yes" xml:space="preserve">
          <source>The frame style used when drawing a combobox popup menu.</source>
          <target state="translated">콤보 박스 팝업 메뉴를 그릴 때 사용되는 프레임 스타일입니다.</target>
        </trans-unit>
        <trans-unit id="badfc41cd08564dcf71235fd43ae863863beae5e" translate="yes" xml:space="preserve">
          <source>The frame that is drawn for a tab bar, ususally drawn for a tab bar that isn't part of a tab widget.</source>
          <target state="translated">탭 막대를 위해 그려진 프레임, 탭 위젯의 일부가 아닌 탭 막대를 위해 일반적으로 그려진 프레임.</target>
        </trans-unit>
        <trans-unit id="91876957ec9d4d2cbfc0462e256cf49987be0997" translate="yes" xml:space="preserve">
          <source>The frame type is unknown.</source>
          <target state="translated">프레임 유형을 알 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="5bced41815baee2ea1b329dba58f8d91d8d80bfc" translate="yes" xml:space="preserve">
          <source>The frame width for a tool tip label.</source>
          <target state="translated">툴팁 레이블의 프레임 너비입니다.</target>
        </trans-unit>
        <trans-unit id="7ac8135a9597d00a8817f2f2ecb971b694376fae" translate="yes" xml:space="preserve">
          <source>The frame width for the menu on the desktop.</source>
          <target state="translated">데스크탑 메뉴의 프레임 폭입니다.</target>
        </trans-unit>
        <trans-unit id="0679b6396c299c8cefaec3fd5ebca8909f080eb6" translate="yes" xml:space="preserve">
          <source>The frame width is determined by the frame style, and the &lt;a href=&quot;qframe#frameWidth-prop&quot;&gt;frameWidth&lt;/a&gt;() function is used to obtain the value defined for the style used.</source>
          <target state="translated">프레임 너비는 프레임 스타일과 &lt;a href=&quot;qframe#frameWidth-prop&quot;&gt;frameWidth에&lt;/a&gt; 의해 결정됩니다. () 함수는 사용 된 스타일에 정의 된 값을 얻는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="cef23a77ec04fcddabb92a1e4a41f5e1d764b8a9" translate="yes" xml:space="preserve">
          <source>The frame with the shape specified in the &lt;a href=&quot;qstyleoptionframe&quot;&gt;QStyleOptionFrame&lt;/a&gt;; see &lt;a href=&quot;qframe&quot;&gt;QFrame&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qstyleoptionframe&quot;&gt;QStyleOptionFrame에&lt;/a&gt; 지정된 형태의 프레임입니다 . &lt;a href=&quot;qframe&quot;&gt;QFrame&lt;/a&gt; 참조 .</target>
        </trans-unit>
        <trans-unit id="31751cbfdf0f3567dedd43595b93ab8f3f095bf1" translate="yes" xml:space="preserve">
          <source>The frame's rectangle is the rectangle the frame is drawn in. By default, this is the entire widget. Setting the rectangle does does</source>
          <target state="translated">프레임의 사각형은 프레임이 그려지는 사각형입니다. 기본적으로 전체 위젯입니다. 사각형을 설정하면</target>
        </trans-unit>
        <trans-unit id="1c571d6bd580a48af224876e51c4375b41e7b714" translate="yes" xml:space="preserve">
          <source>The frameId is used in conjunction with</source>
          <target state="translated">frameId는</target>
        </trans-unit>
        <trans-unit id="ee7ae7e2994f4620bac77396a299dc792c26eb14" translate="yes" xml:space="preserve">
          <source>The framebuffer can also become invalid if the &lt;a href=&quot;gui-changes-qt6#qopenglcontext&quot;&gt;QOpenGLContext&lt;/a&gt; that the framebuffer was created within is destroyed and there are no other shared contexts that can take over ownership of the framebuffer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74a621705fac7029f94984fbad6a7b0f9e3191fb" translate="yes" xml:space="preserve">
          <source>The framebuffer can also become invalid if the &lt;a href=&quot;qopenglcontext&quot;&gt;QOpenGLContext&lt;/a&gt; that the framebuffer was created within is destroyed and there are no other shared contexts that can take over ownership of the framebuffer.</source>
          <target state="translated">&lt;a href=&quot;qopenglcontext&quot;&gt;QOpenGLContext 인&lt;/a&gt; 경우에도 프레임 버퍼가 유효하지 않을 수 있습니다. 버퍼가 생성 된 가 파괴되고 프레임 버퍼의 소유권을 인수 할 수있는 다른 공유 컨텍스트가없는 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec4af2562cd0b73309290c377127a7f130a9a455" translate="yes" xml:space="preserve">
          <source>The framebuffer can become invalid if the initialization process fails, the user attaches an invalid buffer to the framebuffer object, or a non-power of two width/height is specified as the texture size if the texture target is &lt;code&gt;GL_TEXTURE_2D&lt;/code&gt;. The non-power of two limitation does not apply if the OpenGL version is 2.0 or higher, or if the GL_ARB_texture_non_power_of_two extension is present.</source>
          <target state="translated">초기화 프로세스가 실패하거나 사용자가 프레임 버퍼 객체에 유효하지 않은 버퍼를 연결하거나 텍스처 대상이 &lt;code&gt;GL_TEXTURE_2D&lt;/code&gt; 이면 너비 / 높이가 아닌 2를 텍스처 크기로 지정하면 프레임 버퍼가 무효화 될 수 있습니다 . OpenGL 버전이 2.0 이상이거나 GL_ARB_texture_non_power_of_two 확장이 존재하는 경우 두 가지의 제곱이 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="39ce6ae9f9aef23b6989886286a4777ea975cd0a" translate="yes" xml:space="preserve">
          <source>The framebuffer has two attachments (color, depth-stencil) when multisampling is not in use, and three (color resolve, depth-stencil, multisample color) when &lt;a href=&quot;qvulkanwindow#sampleCountFlagBits&quot;&gt;sampleCountFlagBits&lt;/a&gt;() is greater than &lt;code&gt;VK_SAMPLE_COUNT_1_BIT&lt;/code&gt;. Renderers must take this into account, for example when providing clear values.</source>
          <target state="translated">프레임 버퍼는 멀티 샘플링을 사용하지 않을 때 두 개의 첨부 파일 (색상, 깊이-스텐실)을 가지고 &lt;a href=&quot;qvulkanwindow#sampleCountFlagBits&quot;&gt;sampleCountFlagBits 일&lt;/a&gt; 때 세 가지 (색상, 깊이-스텐실, 멀티 샘플 색상)를 갖습니다. ()가 &lt;code&gt;VK_SAMPLE_COUNT_1_BIT&lt;/code&gt; 보다 큰 경우 습니다 . 렌더러는 예를 들어 명확한 값을 제공 할 때이를 고려해야합니다.</target>
        </trans-unit>
        <trans-unit id="c334b0d58e1a2672ca6181b3e4d0bd4b200ab643" translate="yes" xml:space="preserve">
          <source>The framebuffer object handle used by this window.</source>
          <target state="translated">이 윈도우가 사용하는 프레임 버퍼 객체 핸들.</target>
        </trans-unit>
        <trans-unit id="62002e7938e9cbf522efffdca8ee918086d121e1" translate="yes" xml:space="preserve">
          <source>The framebuffer objects color buffer and ancillary buffers are not invalidated between frames.</source>
          <target state="translated">프레임 버퍼 객체 컬러 버퍼 및 보조 버퍼는 프레임간에 무효화되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="be37cf12c0a20b9d503552da2541f348e4bd8d2d" translate="yes" xml:space="preserve">
          <source>The framebuffer specified by</source>
          <target state="translated">에 의해 지정된 프레임 버퍼</target>
        </trans-unit>
        <trans-unit id="6154645ee9e113a430792b9fe7b9f9926d720da9" translate="yes" xml:space="preserve">
          <source>The framework consists of four classes:</source>
          <target state="translated">프레임 워크는 4 가지 클래스로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="fdd55542a76dff4bd5dfeddb169a12c680afc72a" translate="yes" xml:space="preserve">
          <source>The framework includes an event propagation architecture that allows precise double-precision interaction capabilities for the items on the scene. Items can handle key events, mouse press, move, release and double click events, and they can also track mouse movement.</source>
          <target state="translated">이 프레임 워크에는 장면의 항목에 대한 정확한 배정도 상호 작용 기능을 허용하는 이벤트 전파 아키텍처가 포함되어 있습니다. 항목은 주요 이벤트, 마우스 누르기, 이동, 놓기 및 더블 클릭 이벤트를 처리 할 수 ​​있으며 마우스 움직임을 추적 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee5485b22d502fc81c7f85f9f02961dd4608e932" translate="yes" xml:space="preserve">
          <source>The framework itself is linked in by appending the &lt;code&gt;-framework&lt;/code&gt; options and the name of the framework to the &lt;a href=&quot;qmake-variable-reference#libs&quot;&gt;LIBS&lt;/a&gt; variable:</source>
          <target state="translated">프레임 워크 자체는 &lt;code&gt;-framework&lt;/code&gt; 옵션과 프레임 워크 이름을 &lt;a href=&quot;qmake-variable-reference#libs&quot;&gt;LIBS&lt;/a&gt; 에 추가하여 연결됩니다. 변수 .</target>
        </trans-unit>
        <trans-unit id="2d73db829f0f057723083f68c231d209a4ae346f" translate="yes" xml:space="preserve">
          <source>The frequent items category.</source>
          <target state="translated">빈번한 항목 범주</target>
        </trans-unit>
        <trans-unit id="a3f27ab1f7214fae60446b5f53a5fbae80bc53b8" translate="yes" xml:space="preserve">
          <source>The from and to ranges must exist; for example, to move the first 3 items to the end of the list:</source>
          <target state="translated">시작 및 종료 범위가 존재해야합니다. 예를 들어, 처음 3 개의 항목을 목록의 끝으로 이동하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="46b5c74464265be983e561e7e5433577bd2899da" translate="yes" xml:space="preserve">
          <source>The from and to ranges must exist; for example, to move the first 3 items to the end of the model:</source>
          <target state="translated">시작 및 종료 범위가 존재해야합니다. 예를 들어, 처음 3 개 항목을 모델 끝으로 이동하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="10981aa0a37eeee14dc6fa1d9d36a597b887ca1f" translate="yes" xml:space="preserve">
          <source>The front and back sides of the flipable.</source>
          <target state="translated">뒤집을 수있는 앞면과 뒷면.</target>
        </trans-unit>
        <trans-unit id="f59347fdeec796d075e4013bf7a004ca09b4d778" translate="yes" xml:space="preserve">
          <source>The frosted glass material has the following properties:</source>
          <target state="translated">젖빛 유리 재료는 다음과 같은 특성을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="2c588ceda509faf662d7e290364b4e4766a6c256" translate="yes" xml:space="preserve">
          <source>The frosted glass single-pass material has the following properties:</source>
          <target state="translated">젖빛 유리 단일 패스 재료는 다음과 같은 특성을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="bc4350d0e1ac318cddaee8d95a51edfcc7070fa7" translate="yes" xml:space="preserve">
          <source>The full list of supported formats can be determined with &lt;a href=&quot;qmovie#supportedFormats&quot;&gt;QMovie::supportedFormats()&lt;/a&gt;.</source>
          <target state="translated">지원되는 형식의 전체 목록은 &lt;a href=&quot;qmovie#supportedFormats&quot;&gt;QMovie :: supportedFormats ()&lt;/a&gt; 로 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e038b34ad1be483ea47541079901aabc1109562d" translate="yes" xml:space="preserve">
          <source>The full path to the first file or directory (depending on</source>
          <target state="translated">첫 번째 파일 또는 디렉토리의 전체 경로 (</target>
        </trans-unit>
        <trans-unit id="1ca65ecda5e57b36f88f930325268a9a33215249" translate="yes" xml:space="preserve">
          <source>The full range Y'CbCr color space used in JPEG files.</source>
          <target state="translated">JPEG 파일에 사용되는 전체 범위 Y'CbCr 색 공간.</target>
        </trans-unit>
        <trans-unit id="e50e25a9a4e9803df107860c2bbdc4a367251f1a" translate="yes" xml:space="preserve">
          <source>The full source code is available in the &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtqml-qmlextensionplugins-example.html#&quot;&gt;plugins example&lt;/a&gt;.</source>
          <target state="translated">전체 소스 코드는 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtqml-qmlextensionplugins-example.html#&quot;&gt;플러그인 예제&lt;/a&gt; 에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9712e82e83606fd742d824e968b0e7274e3766f7" translate="yes" xml:space="preserve">
          <source>The full source code is available in the &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtqml-qmlextensionplugins-example.html&quot;&gt;plugins example&lt;/a&gt;.</source>
          <target state="translated">전체 소스 코드는 &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtqml-qmlextensionplugins-example.html&quot;&gt;플러그인 예제&lt;/a&gt; 에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ef5df5dfe7cb95363d0c648bdab64d15f254fef3" translate="yes" xml:space="preserve">
          <source>The full source code is available in the &lt;a href=&quot;https://doc.qt.io/qt-6.0/qtqml-qmlextensionplugins-example.html&quot;&gt;plugins example&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa236d312afaa8c4a16e53052a063106603102ad" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;qgeopositioninfo#hasAttribute&quot;&gt;hasAttribute&lt;/a&gt;() should be used to determine whether or not a value has been set for an attribute.</source>
          <target state="translated">함수 &lt;a href=&quot;qgeopositioninfo#hasAttribute&quot;&gt;hasAttribute&lt;/a&gt; () 사용하여 속성에 값이 설정되었는지 여부를 판별해야합니다.</target>
        </trans-unit>
        <trans-unit id="ec9e87f62dd626636eb358518d6db0488afe0559" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;qhoverevent#pos&quot;&gt;pos&lt;/a&gt;() gives the current cursor position, while &lt;a href=&quot;qhoverevent#oldPos&quot;&gt;oldPos&lt;/a&gt;() gives the old mouse position.</source>
          <target state="translated">&lt;a href=&quot;qhoverevent#pos&quot;&gt;pos&lt;/a&gt; () 함수 는 현재 커서 위치를 제공하고 &lt;a href=&quot;qhoverevent#oldPos&quot;&gt;oldPos&lt;/a&gt; ()는 이전 마우스 위치를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b4d87f6e7cb9453ea1ef4fd8ff7e155520040051" translate="yes" xml:space="preserve">
          <source>The function assumes the geometry object contains a single triangle strip of &lt;a href=&quot;qsggeometry-coloredpoint2d&quot;&gt;QSGGeometry::ColoredPoint2D&lt;/a&gt; vertices</source>
          <target state="translated">이 함수는 지오메트리 객체에 &lt;a href=&quot;qsggeometry-coloredpoint2d&quot;&gt;QSGGeometry :: ColoredPoint2D&lt;/a&gt; 정점 의 단일 삼각형 스트립이 포함되어 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="488691c9570aaf071fedaa1884ee918c1b9f5b04" translate="yes" xml:space="preserve">
          <source>The function assumes the geometry object contains a single triangle strip of &lt;a href=&quot;qsggeometry-point2d&quot;&gt;QSGGeometry::Point2D&lt;/a&gt; vertices</source>
          <target state="translated">이 함수는 지오메트리 객체에 &lt;a href=&quot;qsggeometry-point2d&quot;&gt;QSGGeometry :: Point2D&lt;/a&gt; 정점 의 단일 삼각형 스트립이 포함되어 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="a0a24f9373a39a9bc6110bdbf9cb744f73a5b72c" translate="yes" xml:space="preserve">
          <source>The function calls all installed factory functions (from most recently installed to least recently installed) until one is found that provides an interface for the class of</source>
          <target state="translated">이 함수는 클래스의 인터페이스를 제공하는 함수가 발견 될 때까지 설치된 모든 팩토리 함수 (가장 최근에 설치된 것부터 가장 최근에 설치된 것까지)를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="4530418e911d0ee4a3c3809a561a8d5ed280418c" translate="yes" xml:space="preserve">
          <source>The function can also take a property list as argument - &lt;code&gt;Item StackView::pop(jsobject dict)&lt;/code&gt;, which can contain one or more of the following properties:</source>
          <target state="translated">이 함수는 속성 목록을 인수로 사용할 수도 있습니다.- &lt;code&gt;Item StackView::pop(jsobject dict)&lt;/code&gt; 로 사용할 수 있으며 다음 속성 중 하나 이상을 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b2985a291d90e0624cf5ed13e2e77c1da7cc6c5" translate="yes" xml:space="preserve">
          <source>The function can also take a property list as argument - &lt;code&gt;Item StackView::push(jsobject dict)&lt;/code&gt;, which should contain one or more of the following properties:</source>
          <target state="translated">이 함수는 속성 목록을 인수 &lt;code&gt;Item StackView::push(jsobject dict)&lt;/code&gt; 로 사용할 수 있으며 다음 속성 중 하나 이상을 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="fd35bbe830419713f1fba2a344bf918c312ca03b" translate="yes" xml:space="preserve">
          <source>The function can change both</source>
          <target state="translated">이 기능은 모두를 변경할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="5225565875706e07dd2bfb699879d62db851022e" translate="yes" xml:space="preserve">
          <source>The function can read the following special variables, in addition to the matrix (such as, &lt;code&gt;MODEL_MATRIX&lt;/code&gt;) and vector (such as, &lt;code&gt;CAMERA_POSITION&lt;/code&gt;) uniforms from the table above:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d1a890a117b6d9b45661bfff99eacc85c0c757d" translate="yes" xml:space="preserve">
          <source>The function can write to the following special variables. The values written to these will typically be either hardcoded or be calculated based on QML properties mapped to uniforms. The semantics are identical to &lt;a href=&quot;qml-qtquick3d-principledmaterial&quot;&gt;PrincipledMaterial&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5a65e493b4a5e71f5452fab15a7b2b14beb1d01" translate="yes" xml:space="preserve">
          <source>The function can write to the following special variables:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69a674e5dfaf01b905f1a5050b904660f405f5cd" translate="yes" xml:space="preserve">
          <source>The function concatenates &lt;a href=&quot;qxmlstreamreader#text&quot;&gt;text&lt;/a&gt;() when it reads either &lt;a href=&quot;qxmlstreamreader#TokenType-enum&quot;&gt;Characters&lt;/a&gt; or &lt;a href=&quot;qxmlstreamreader#TokenType-enum&quot;&gt;EntityReference&lt;/a&gt; tokens, but skips &lt;a href=&quot;qxmlstreamreader#TokenType-enum&quot;&gt;ProcessingInstruction&lt;/a&gt; and &lt;a href=&quot;qxmlstreamreader#TokenType-enum&quot;&gt;Comment&lt;/a&gt;. If the current token is not &lt;a href=&quot;qxmlstreamreader#TokenType-enum&quot;&gt;StartElement&lt;/a&gt;, an empty string is returned.</source>
          <target state="translated">이 함수 는 &lt;a href=&quot;qxmlstreamreader#TokenType-enum&quot;&gt;문자&lt;/a&gt; 또는 &lt;a href=&quot;qxmlstreamreader#TokenType-enum&quot;&gt;EntityReference&lt;/a&gt; 토큰을 읽을 때 &lt;a href=&quot;qxmlstreamreader#text&quot;&gt;text&lt;/a&gt; ()를 연결 하지만 &lt;a href=&quot;qxmlstreamreader#TokenType-enum&quot;&gt;ProcessingInstruction&lt;/a&gt; 및 &lt;a href=&quot;qxmlstreamreader#TokenType-enum&quot;&gt;Comment&lt;/a&gt; 는 건너 뜁니다 . 현재 토큰이 &lt;a href=&quot;qxmlstreamreader#TokenType-enum&quot;&gt;StartElement&lt;/a&gt; 가 아닌 경우 빈 문자열이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="60c0c8efa18ce31fc191998bfe7c75d6e657545f" translate="yes" xml:space="preserve">
          <source>The function converts the current RGB color to HSV, divides the value (V) component by factor and converts the color back to RGB.</source>
          <target state="translated">이 기능은 현재 RGB 색상을 HSV로 변환하고 값 (V) 구성 요소를 인자로 나누고 색상을 다시 RGB로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="f2975e5569fdf44cb11367e20462e1f95c836e77" translate="yes" xml:space="preserve">
          <source>The function converts the current RGB color to HSV, multiplies the value (V) component by factor and converts the color back to RGB.</source>
          <target state="translated">이 기능은 현재 RGB 색상을 HSV로 변환하고 값 (V) 구성 요소에 계수를 곱한 후 색상을 다시 RGB로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="b274abb766f7fbf1452d138e70448d1efeeef5a1" translate="yes" xml:space="preserve">
          <source>The function converts the current color to HSV, divides the value (V) component by</source>
          <target state="translated">이 기능은 현재 색상을 HSV로 변환하고 값 (V) 구성 요소를</target>
        </trans-unit>
        <trans-unit id="043c0ecb9e12804aa5c78c6a395b069bd87ca01d" translate="yes" xml:space="preserve">
          <source>The function converts the current color to HSV, multiplies the value (V) component by</source>
          <target state="translated">이 함수는 현재 색상을 HSV로 변환하고 값 (V) 성분에 곱합니다</target>
        </trans-unit>
        <trans-unit id="bf351c423ec7dc6aa718e4bbc3a2a871301aa245" translate="yes" xml:space="preserve">
          <source>The function creates a modal file dialog with the given</source>
          <target state="translated">이 함수는 주어진 모달 파일 대화 상자를 만듭니다</target>
        </trans-unit>
        <trans-unit id="1114a3e50fe8140f21fab41b1f2c5cea58e5df41" translate="yes" xml:space="preserve">
          <source>The function differs from the &lt;a href=&quot;qpainterpath#toFillPolygon&quot;&gt;toFillPolygon&lt;/a&gt;() function in that it creates several polygons. It is provided because it is usually faster to draw several small polygons than to draw one large polygon, even though the total number of points drawn is the same.</source>
          <target state="translated">이 함수는 여러 다각형을 생성한다는 점에서 &lt;a href=&quot;qpainterpath#toFillPolygon&quot;&gt;toFillPolygon&lt;/a&gt; () 함수와 다릅니다 . 총점 수는 동일하지만 일반적으로 하나의 큰 다각형을 그리는 것보다 여러 개의 작은 다각형을 그리는 것이 더 빠르기 때문에 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="bbaa1e8584918071a7af6e424d4927faea82689d" translate="yes" xml:space="preserve">
          <source>The function documentation must document:</source>
          <target state="translated">기능 문서는 다음을 문서화해야합니다.</target>
        </trans-unit>
        <trans-unit id="7ca0ffa8aa6b1b0b473724f19fdd941d7acb5868" translate="yes" xml:space="preserve">
          <source>The function documentation starts with a verb, indicating the operation the function performs.</source>
          <target state="translated">기능 문서는 기능이 수행하는 작업을 나타내는 동사로 시작합니다.</target>
        </trans-unit>
        <trans-unit id="a64d4ae3e40abf3302b54214814a33e7455d1179" translate="yes" xml:space="preserve">
          <source>The function documentation starts with a verb, indicating the operation the function performs. This also applies to constructors and destructors.</source>
          <target state="translated">기능 문서는 기능이 수행하는 작업을 나타내는 동사로 시작합니다. 이것은 생성자와 소멸자에도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="c6f1cb44d19efeb01b0504cacdf65212cdb6bbb0" translate="yes" xml:space="preserve">
          <source>The function does not give meaningful results if any of the arguments are &lt;code&gt;Infinite&lt;/code&gt; or &lt;code&gt;NaN&lt;/code&gt;. You can check for this by calling &lt;a href=&quot;qtglobal#qIsFinite&quot;&gt;qIsFinite&lt;/a&gt;().</source>
          <target state="translated">인수가 &lt;code&gt;Infinite&lt;/code&gt; 또는 &lt;code&gt;NaN&lt;/code&gt; 인 경우이 함수는 의미있는 결과를 제공하지 않습니다 . &lt;a href=&quot;qtglobal#qIsFinite&quot;&gt;qIsFinite&lt;/a&gt; () 를 호출하여이를 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f9be243a4a23ff4bcc3e73e5eb5d69241f165caa" translate="yes" xml:space="preserve">
          <source>The function does not need to be called when recording commands to the application's own command buffer (such as, a VkCommandBuffer or MTLCommandBuffer + MTLRenderCommandEncoder created and managed by the application, not retrieved from the scene graph). With graphics APIs where no native command buffer concept is exposed (OpenGL, Direct 3D 11), &lt;a href=&quot;qquickwindow#beginExternalCommands&quot;&gt;beginExternalCommands&lt;/a&gt;() and endExternalCommands() together provide a replacement for &lt;a href=&quot;qquickwindow#resetOpenGLState&quot;&gt;resetOpenGLState&lt;/a&gt;().</source>
          <target state="translated">응용 프로그램의 자체 명령 버퍼 (예 : 장면 그래프에서 검색하지 않고 응용 프로그램에서 생성 및 관리하는 VkCommandBuffer 또는 MTLCommandBuffer + MTLRenderCommandEncoder)에 명령을 기록 할 때 함수를 호출 할 필요가 없습니다. 그래픽 네이티브 명령 버퍼 개념이 노출되지 않은 API를 (OpenGL은, 다이렉트 3D 11)로 &lt;a href=&quot;qquickwindow#beginExternalCommands&quot;&gt;beginExternalCommands&lt;/a&gt; () 및 endExternalCommands () 서로에 대한 여분 제공 &lt;a href=&quot;qquickwindow#resetOpenGLState&quot;&gt;resetOpenGLState을&lt;/a&gt; ().</target>
        </trans-unit>
        <trans-unit id="8f810272d59ad9fe7ef1d144e391d681ff89816c" translate="yes" xml:space="preserve">
          <source>The function does not need to be called when recording commands to the application's own command buffer (such as, a VkCommandBuffer or MTLCommandBuffer + MTLRenderCommandEncoder created and managed by the application, not retrieved from the scene graph). With graphics APIs where no native command buffer concept is exposed (OpenGL, Direct 3D 11), &lt;a href=&quot;qquickwindow#beginExternalCommands&quot;&gt;beginExternalCommands&lt;/a&gt;() and endExternalCommands() together provide a replacement for the Qt 5 resetOpenGLState() function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="242bdda3706c7c46a7a4dc26276e47511a61710a" translate="yes" xml:space="preserve">
          <source>The function does not need to be called when recording commands to the application's own command buffer (such as, a VkCommandBuffer or MTLCommandBuffer + MTLRenderCommandEncoder created and managed by the application, not retrieved from the scene graph). With graphics APIs where no native command buffer concept is exposed (OpenGL, Direct 3D 11), beginExternalCommands() and &lt;a href=&quot;qquickwindow#endExternalCommands&quot;&gt;endExternalCommands&lt;/a&gt;() together provide a replacement for &lt;a href=&quot;qquickwindow#resetOpenGLState&quot;&gt;resetOpenGLState&lt;/a&gt;().</source>
          <target state="translated">응용 프로그램의 자체 명령 버퍼 (예 : 장면 그래프에서 검색하지 않고 응용 프로그램에서 생성 및 관리하는 VkCommandBuffer 또는 MTLCommandBuffer + MTLRenderCommandEncoder)에 명령을 기록 할 때 함수를 호출 할 필요가 없습니다. 그래픽 네이티브 명령 버퍼 개념이 노출되지 않은 API를 (OpenGL은, 다이렉트 3D 11) beginExternalCommands ()와 함께 &lt;a href=&quot;qquickwindow#endExternalCommands&quot;&gt;endExternalCommands&lt;/a&gt; () 서로에 대한 여분 제공 &lt;a href=&quot;qquickwindow#resetOpenGLState&quot;&gt;resetOpenGLState을&lt;/a&gt; ().</target>
        </trans-unit>
        <trans-unit id="4f6f11a0d7a11923f8b46d03ca25e13dc1c82834" translate="yes" xml:space="preserve">
          <source>The function does not need to be called when recording commands to the application's own command buffer (such as, a VkCommandBuffer or MTLCommandBuffer + MTLRenderCommandEncoder created and managed by the application, not retrieved from the scene graph). With graphics APIs where no native command buffer concept is exposed (OpenGL, Direct 3D 11), beginExternalCommands() and &lt;a href=&quot;qquickwindow#endExternalCommands&quot;&gt;endExternalCommands&lt;/a&gt;() together provide a replacement for the Qt 5 resetOpenGLState() function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47348bba0bc8c33b18ab8c8147830acd50550cae" translate="yes" xml:space="preserve">
          <source>The function has no effect when the blitter is not in created state.</source>
          <target state="translated">블 리터가 생성되지 않은 상태에서는이 기능이 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3c22661655dff7b4f69545cb01f24ffb67d6bc48" translate="yes" xml:space="preserve">
          <source>The function is a constructor.</source>
          <target state="translated">함수는 생성자입니다.</target>
        </trans-unit>
        <trans-unit id="a6f77df6b4fbcf932d68fa31f64c26eb67e058e6" translate="yes" xml:space="preserve">
          <source>The function is a plain member function.</source>
          <target state="translated">이 함수는 일반 멤버 함수입니다.</target>
        </trans-unit>
        <trans-unit id="767949cd8aa7f9f619baee2938331bb690c992ee" translate="yes" xml:space="preserve">
          <source>The function is a signal.</source>
          <target state="translated">기능은 신호입니다.</target>
        </trans-unit>
        <trans-unit id="899a168e8a16dcbdf9fb80bd85d8bbaabe0c920a" translate="yes" xml:space="preserve">
          <source>The function is a slot.</source>
          <target state="translated">기능은 슬롯입니다.</target>
        </trans-unit>
        <trans-unit id="82275c4ca8bd509fc6435f6490a16ea77e906841" translate="yes" xml:space="preserve">
          <source>The function is also used internally by the &lt;a href=&quot;quiloader&quot;&gt;QUiLoader&lt;/a&gt; class whenever it creates a widget. Hence, you can subclass &lt;a href=&quot;quiloader&quot;&gt;QUiLoader&lt;/a&gt; and reimplement this function to intervene process of constructing a user interface or widget. However, in your implementation, ensure that you call &lt;a href=&quot;quiloader&quot;&gt;QUiLoader&lt;/a&gt;'s version first.</source>
          <target state="translated">이 함수는 위젯을 &lt;a href=&quot;quiloader&quot;&gt;작성할&lt;/a&gt; 때마다 QUiLoader 클래스에서 내부적으로 사용됩니다 . 따라서 &lt;a href=&quot;quiloader&quot;&gt;QUiLoader&lt;/a&gt; 를 서브 클래 싱 하고이 함수를 다시 구현하여 사용자 인터페이스 또는 위젯 구성 프로세스를 개입 시킬 수 있습니다 . 그러나 구현시 &lt;a href=&quot;quiloader&quot;&gt;QUiLoader&lt;/a&gt; 버전을 먼저 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="3da90cb76e1f3d16af0572e292a8cbcae475684d" translate="yes" xml:space="preserve">
          <source>The function is asynchronous and returns immediately.</source>
          <target state="translated">이 함수는 비동기식이며 즉시 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="7e5861ecc881d99a809ee4a598101c2f37f9af6e" translate="yes" xml:space="preserve">
          <source>The function is asynchronous and returns immediately. The</source>
          <target state="translated">이 함수는 비동기식이며 즉시 반환됩니다. 그만큼</target>
        </trans-unit>
        <trans-unit id="4998e84a5bf2e5bf129e1fd4c9200a8fbba85e1c" translate="yes" xml:space="preserve">
          <source>The function is called after the item has been filled with the &lt;a href=&quot;qquickpainteditem#fillColor-prop&quot;&gt;fillColor&lt;/a&gt;.</source>
          <target state="translated">항목이 &lt;a href=&quot;qquickpainteditem#fillColor-prop&quot;&gt;fillColor&lt;/a&gt; 로 채워진 후에 함수가 호출 됩니다.</target>
        </trans-unit>
        <trans-unit id="d7bba79b60eef4a044c4a5457ea364a0f1eefb6c" translate="yes" xml:space="preserve">
          <source>The function is called as a result of &lt;a href=&quot;qquickitem#update&quot;&gt;QQuickItem::update&lt;/a&gt;(), if the user has set the &lt;a href=&quot;qquickitem#Flag-enum&quot;&gt;QQuickItem::ItemHasContents&lt;/a&gt; flag on the item.</source>
          <target state="translated">사용자가 항목에 &lt;a href=&quot;qquickitem#Flag-enum&quot;&gt;QQuickItem :: ItemHasContents&lt;/a&gt; 플래그를 설정 한 경우 &lt;a href=&quot;qquickitem#update&quot;&gt;QQuickItem :: update&lt;/a&gt; () 의 결과로 함수가 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="4a5298322df4e21fe5b4dd770cb38d532e7fb3d6" translate="yes" xml:space="preserve">
          <source>The function is called by the renderer so it can reset the states after rendering this node. This makes the implementation of &lt;a href=&quot;qsgrendernode#render&quot;&gt;render&lt;/a&gt;() simpler since it does not have to query and restore these states.</source>
          <target state="translated">이 함수는 렌더러에 의해 호출되므로이 노드를 렌더링 한 후 상태를 재설정 할 수 있습니다. 따라서 이러한 상태를 쿼리하고 복원 할 필요가 없으므로 &lt;a href=&quot;qsgrendernode#render&quot;&gt;render&lt;/a&gt; () 구현이 더 간단 해집니다.</target>
        </trans-unit>
        <trans-unit id="6363ca7bd84849037e6cabf412a262fd5469ffcf" translate="yes" xml:space="preserve">
          <source>The function is called on the GUI thread and the state of the rendering thread, when it is used, is unknown. Objects should not be deleted directly, but instead scheduled for cleanup using &lt;a href=&quot;qquickwindow#scheduleRenderJob&quot;&gt;QQuickWindow::scheduleRenderJob&lt;/a&gt;().</source>
          <target state="translated">이 함수는 GUI 스레드에서 호출되며 렌더링 스레드의 사용 상태는 알 수 없습니다. &lt;a href=&quot;qquickwindow#scheduleRenderJob&quot;&gt;QQuickWindow :: scheduleRenderJob&lt;/a&gt; ()을 사용하여 객체를 직접 삭제하지 말고 정리 예약합니다 .</target>
        </trans-unit>
        <trans-unit id="8fc1cb2731b703dfd08cbe3f6bbbb2be49f0d945" translate="yes" xml:space="preserve">
          <source>The function is called when the window has requested becoming visible.</source>
          <target state="translated">윈도우가 보이도록 요청하면이 함수가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="46469b06481f47a2e19749d23e12de91ebde23d0" translate="yes" xml:space="preserve">
          <source>The function is called when the window has requested being hidden in the windowing system.</source>
          <target state="translated">윈도우가 윈도우 시스템에서 숨겨 지도록 요청한 경우이 함수가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="80bb00273d6b21a7ff8fbb5de5f6dbe30a29dee8" translate="yes" xml:space="preserve">
          <source>The function is called when the window is requested to close. Call &lt;a href=&quot;qevent#ignore&quot;&gt;QEvent::ignore&lt;/a&gt;() on the event if you want to prevent the window from being closed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbc1342fc798ed788b1ae68c7b3b4f1d3cf048a4" translate="yes" xml:space="preserve">
          <source>The function is equivalent to &lt;code&gt;insert(i, QByteArrayView(s))&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39aea3f44c747d1647124a08912212dda35981b2" translate="yes" xml:space="preserve">
          <source>The function is named after the HTTP request associated (HEAD).</source>
          <target state="translated">함수는 HTTP 요청 연관 (HEAD)의 이름을 따서 명명됩니다.</target>
        </trans-unit>
        <trans-unit id="e4df1ff9082ee156c30418039520d5803692d0f2" translate="yes" xml:space="preserve">
          <source>The function is thread-safe.</source>
          <target state="translated">이 기능은 스레드로부터 안전합니다.</target>
        </trans-unit>
        <trans-unit id="8ca6e853839a76db996789752089bbd0696ccb3e" translate="yes" xml:space="preserve">
          <source>The function is used similarly to &lt;a href=&quot;qfiledialog#getExistingDirectory&quot;&gt;QFileDialog::getExistingDirectory&lt;/a&gt;(). In particular</source>
          <target state="translated">이 함수는 &lt;a href=&quot;qfiledialog#getExistingDirectory&quot;&gt;QFileDialog :: getExistingDirectory&lt;/a&gt; () 와 유사하게 사용됩니다 . 특히</target>
        </trans-unit>
        <trans-unit id="37e955abcb321632c553bce6a7042f2c77df6c6c" translate="yes" xml:space="preserve">
          <source>The function is used similarly to &lt;a href=&quot;qfiledialog#getOpenFileName&quot;&gt;QFileDialog::getOpenFileName&lt;/a&gt;(). In particular</source>
          <target state="translated">이 함수는 &lt;a href=&quot;qfiledialog#getOpenFileName&quot;&gt;QFileDialog :: getOpenFileName&lt;/a&gt; () 과 유사하게 사용됩니다 . 특히</target>
        </trans-unit>
        <trans-unit id="0390d29dbde73d8444242197396315662f4545ad" translate="yes" xml:space="preserve">
          <source>The function is used similarly to &lt;a href=&quot;qfiledialog#getOpenFileNames&quot;&gt;QFileDialog::getOpenFileNames&lt;/a&gt;(). In particular</source>
          <target state="translated">이 함수는 &lt;a href=&quot;qfiledialog#getOpenFileNames&quot;&gt;QFileDialog :: getOpenFileNames&lt;/a&gt; () 와 유사하게 사용됩니다 . 특히</target>
        </trans-unit>
        <trans-unit id="8e880d984584b2946af00aabaf22cef406556bf8" translate="yes" xml:space="preserve">
          <source>The function is used similarly to &lt;a href=&quot;qfiledialog#getSaveFileName&quot;&gt;QFileDialog::getSaveFileName&lt;/a&gt;(). In particular</source>
          <target state="translated">이 함수는 &lt;a href=&quot;qfiledialog#getSaveFileName&quot;&gt;QFileDialog :: getSaveFileName&lt;/a&gt; () 과 유사하게 사용됩니다 . 특히</target>
        </trans-unit>
        <trans-unit id="28d279bc704460f6e5fee02fe43572de06378a96" translate="yes" xml:space="preserve">
          <source>The function must be reimplemented to add actions to the list.</source>
          <target state="translated">목록에 조치를 추가하려면 함수를 다시 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="becedaa2f6cacb867e1d423cc99437e647029112" translate="yes" xml:space="preserve">
          <source>The function must return true on success and false on failure.</source>
          <target state="translated">함수는 성공하면 true를, 실패하면 false를 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="c17e27da28777c6253c62320f1ecefe6afc0cf90" translate="yes" xml:space="preserve">
          <source>The function passed as the first argument to Qt.&lt;a href=&quot;qml-qtqml-qt#callLater-method&quot;&gt;callLater()&lt;/a&gt; will be called later, once the QML engine returns to the event loop.</source>
          <target state="translated">이 함수는 첫 번째 인수로 Qt에 전달되었습니다. QML 엔진이 이벤트 루프로 돌아 오면 &lt;a href=&quot;qml-qtqml-qt#callLater-method&quot;&gt;callLater ()&lt;/a&gt; 가 나중에 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="f86e5fcf387e5f7b6e7fb537077f5a92e976d9a8" translate="yes" xml:space="preserve">
          <source>The function passed to &lt;a href=&quot;concurrent-changes-qt6#qtconcurrent-run&quot;&gt;QtConcurrent::run&lt;/a&gt;() in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f75a6a276abd8b04ad75b8439c49b3d6c7ab8502" translate="yes" xml:space="preserve">
          <source>The function passed to &lt;a href=&quot;concurrent-changes-qt6#qtconcurrent-run&quot;&gt;QtConcurrent::run&lt;/a&gt;() may report the result through its return value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab4b4744873b6af69a96f1644866d1d7b5cf11a6" translate="yes" xml:space="preserve">
          <source>The function receives a &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; and a &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; pointer, where the &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; is the key identifying the interface. The &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; is used to pass on to the &lt;a href=&quot;qaccessibleinterface&quot;&gt;QAccessibleInterface&lt;/a&gt; so that it can hold a reference to it.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; 과 &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 포인터를 받습니다. 여기서 &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; 은 인터페이스를 식별하는 키입니다. &lt;a href=&quot;qobject&quot;&gt;QObject를가&lt;/a&gt; 받는에 전달하는 데 사용된다 &lt;a href=&quot;qaccessibleinterface&quot;&gt;QAccessibleInterface&lt;/a&gt; 그것에 대한 참조를 저장할 수 있도록.</target>
        </trans-unit>
        <trans-unit id="edffacbbcbe21b1dc84aecf32c6e5f24f713e8b1" translate="yes" xml:space="preserve">
          <source>The function returned data; there was no error.</source>
          <target state="translated">함수가 데이터를 리턴했습니다. 오류가 없었습니다.</target>
        </trans-unit>
        <trans-unit id="550913fe82862821055d866169a8c8cc7235881f" translate="yes" xml:space="preserve">
          <source>The function returns -1 if the font could not be loaded.</source>
          <target state="translated">폰트를로드 할 수없는 경우 함수는 -1을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="ef857ba658e53903b734bc06309e18651c26dd5d" translate="yes" xml:space="preserve">
          <source>The function returns 0 if not even a default &lt;a href=&quot;qgeopositioninfosource&quot;&gt;QGeoPositionInfoSource&lt;/a&gt; exists.</source>
          <target state="translated">기본 &lt;a href=&quot;qgeopositioninfosource&quot;&gt;QGeoPositionInfoSource&lt;/a&gt; 가 존재 하지 않으면 함수는 0을 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="b08abe7dac4e769a7a607e3d8108c7ab7229cef0" translate="yes" xml:space="preserve">
          <source>The function returns &lt;code&gt;false&lt;/code&gt; if the &lt;code&gt;Q_PROPERTY()&lt;/code&gt;'s &lt;code&gt;STORED&lt;/code&gt; attribute is false; otherwise returns true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d19b8d0b951f24daf71169b6b2046c6386ee68cf" translate="yes" xml:space="preserve">
          <source>The function returns &lt;code&gt;nullptr&lt;/code&gt; if the symbol could not be resolved or if the library could not be loaded.</source>
          <target state="translated">이 함수는 기호를 확인할 수 없거나 라이브러리를로드 할 수없는 경우 &lt;code&gt;nullptr&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="164ac64dd815cc3ccdf87c5a5d72beb5b71b790f" translate="yes" xml:space="preserve">
          <source>The function returns &lt;code&gt;true&lt;/code&gt; if QDom implements the requested</source>
          <target state="translated">QDom이 요청 된 것을 구현하면 이 함수는 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="f816f44f702cf6ab83934673187408eb7ce77383" translate="yes" xml:space="preserve">
          <source>The function returns &lt;code&gt;true&lt;/code&gt; if data is available for reading; otherwise it returns &lt;code&gt;false&lt;/code&gt; (if an error occurred or the operation timed out).</source>
          <target state="translated">데이터를 읽을 수있는 경우 함수는 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 . 그렇지 않으면 오류가 발생하거나 작업 시간이 초과 된 경우 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="b1e9d7342515527363d9502b05897b5b8d4e7c9d" translate="yes" xml:space="preserve">
          <source>The function returns &lt;code&gt;true&lt;/code&gt; if the &lt;a href=&quot;qiodevice#bytesWritten&quot;&gt;bytesWritten&lt;/a&gt;() signal is emitted; otherwise it returns &lt;code&gt;false&lt;/code&gt; (if an error occurred or the operation timed out).</source>
          <target state="translated">&lt;a href=&quot;qiodevice#bytesWritten&quot;&gt;bytesWritten&lt;/a&gt; () 신호가 방출 되면 이 함수는 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 . 그렇지 않으면 오류가 발생하거나 작업 시간이 초과 된 경우 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="b59b5a539ab2d09431bbadfde9ab6c14fadffb45" translate="yes" xml:space="preserve">
          <source>The function returns &lt;code&gt;true&lt;/code&gt; if the &lt;a href=&quot;qiodevice#readyRead&quot;&gt;readyRead&lt;/a&gt;() signal is emitted and there is new data available for reading; otherwise it returns &lt;code&gt;false&lt;/code&gt; (if an error occurred or the operation timed out).</source>
          <target state="translated">&lt;a href=&quot;qiodevice#readyRead&quot;&gt;readyRead&lt;/a&gt; () 신호가 발생하고 읽을 수있는 새 데이터가있는 경우이 함수는 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 . 그렇지 않으면 오류가 발생하거나 작업 시간이 초과 된 경우 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="dc5e80b8d6bd690ff890fd0ad985640cb461112d" translate="yes" xml:space="preserve">
          <source>The function returns &lt;code&gt;true&lt;/code&gt; if the coils register contains the 8 bits required for storing and retrieving the status coils, otherwise &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">코일 레지스터에 상태 코일을 저장하고 검색하는 데 필요한 8 비트가 포함되어 있으면 &lt;code&gt;true&lt;/code&gt; 를 반환 하고, 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="17394cb86de6dc0c7f5b6b3582681ce32368492b" translate="yes" xml:space="preserve">
          <source>The function returns &lt;code&gt;true&lt;/code&gt; if the lock was obtained; otherwise it returns &lt;code&gt;false&lt;/code&gt;</source>
          <target state="translated">잠금이 확보되면 함수는 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 . 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 반환</target>
        </trans-unit>
        <trans-unit id="7e85c246c21c02c7ddd81e526d165d60647cf050" translate="yes" xml:space="preserve">
          <source>The function returns &lt;code&gt;true&lt;/code&gt; if the object was inserted into the cache; otherwise it returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">객체가 캐시에 삽입 된 경우 함수는 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 . 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="51254cb313d612d281d3eaa8d5a9bcb8c236a4d1" translate="yes" xml:space="preserve">
          <source>The function returns &lt;code&gt;true&lt;/code&gt; if the word was successfully reselected.</source>
          <target state="translated">단어가 다시 선택되면 함수는 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 .</target>
        </trans-unit>
        <trans-unit id="9fe78ee1c2efc7a55f1480204bc2417f5c1a5569" translate="yes" xml:space="preserve">
          <source>The function returns &lt;code&gt;true&lt;/code&gt; on success and false on failure.</source>
          <target state="translated">이 함수는 성공하면 true를, 실패하면 false를 반환 &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="564b420e3834d8dd9a8040def44120306abad0d4" translate="yes" xml:space="preserve">
          <source>The function returns a &lt;a href=&quot;qmetaobject-connection&quot;&gt;QMetaObject::Connection&lt;/a&gt; that represents a handle to a connection if it successfully connects the signal to the slot. The connection handle will be invalid if it cannot create the connection, for example, if &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; is unable to verify the existence of either</source>
          <target state="translated">이 함수는 신호가 슬롯에 성공적으로 연결되면 연결 핸들을 나타내는 &lt;a href=&quot;qmetaobject-connection&quot;&gt;QMetaObject :: Connection&lt;/a&gt; 을 반환 합니다. 연결 핸들이 연결을 생성 할 수없는 경우 (예 : &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 가 둘 중 하나의 존재를 확인할 수없는 경우) 연결 핸들이 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e8da9cfac0db405c35d3b07cbfe64499ff65e4fa" translate="yes" xml:space="preserve">
          <source>The function returns a pointer to the script engine for the code in</source>
          <target state="translated">이 함수는 코드의 스크립트 엔진에 대한 포인터를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c581bf06b0dd7953d325bb8691f3a8beade8df37" translate="yes" xml:space="preserve">
          <source>The function returns a pointer to the script for the given</source>
          <target state="translated">이 함수는 주어진 스크립트에 대한 포인터를 반환합니다</target>
        </trans-unit>
        <trans-unit id="11b1dba79e3ac5a795d9b4426ed417d5f9a8a9f8" translate="yes" xml:space="preserve">
          <source>The function returns an handle to a connection if it successfully connects the signal to the slot. The Connection handle will be invalid if it cannot create the connection, for example, if &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; is unable to verify the existence of</source>
          <target state="translated">신호가 슬롯에 성공적으로 연결되면이 함수는 핸들을 연결에 반환합니다. 연결 핸들이 연결을 생성 할 수없는 경우 (예 : &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 가 존재 여부를 확인할 수없는 경우) 연결 핸들이 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9f7dd70af06c0c9bbcc2b18955af596206d6ea72" translate="yes" xml:space="preserve">
          <source>The function returns immediately. Depending on the platform audio facilities, other sounds may stop or be mixed with the new sound. The sound can be played again at any time, possibly mixing or replacing previous plays of the sound.</source>
          <target state="translated">이 함수는 즉시 반환합니다. 플랫폼 오디오 기능에 따라 다른 사운드가 중지되거나 새 사운드와 혼합 될 수 있습니다. 사운드는 언제든지 다시 재생할 수 있으므로 이전 사운드 재생을 믹싱하거나 교체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="830c7791eb311fc5e4eaecbdf4298dea0657a988" translate="yes" xml:space="preserve">
          <source>The function returns the newly created object.</source>
          <target state="translated">이 함수는 새로 생성 된 객체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a755bd5e1bb4599f6bfa8ff1531087d8495f2b78" translate="yes" xml:space="preserve">
          <source>The function returns the number of bytes sent if it succeeded or -1 if it encountered an error.</source>
          <target state="translated">이 함수는 성공한 경우 전송 된 바이트 수를 리턴하고 오류가 발생한 경우 -1을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="aa023ae2c458341ab78ee5fa6821a7e68857b78e" translate="yes" xml:space="preserve">
          <source>The function returns the removed node or a &lt;a href=&quot;qdomnode#isNull&quot;&gt;null node&lt;/a&gt; if the map did not contain a node called</source>
          <target state="translated">맵에라는 노드가없는 경우 함수는 제거 된 노드 또는 &lt;a href=&quot;qdomnode#isNull&quot;&gt;널 노드를 리턴합니다.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="134c5b88ca21d894e6ffdb6e1ff78a456bb73d9b" translate="yes" xml:space="preserve">
          <source>The function returns the removed node or a &lt;a href=&quot;qdomnode#isNull&quot;&gt;null node&lt;/a&gt; if the map did not contain a node with the local name</source>
          <target state="translated">맵에 로컬 이름을 가진 노드가없는 경우 함수는 제거 된 노드 또는 &lt;a href=&quot;qdomnode#isNull&quot;&gt;널 노드를 리턴합니다.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7ad3cb7944f8037a9da4a143bb75a1a6a4f9c6a2" translate="yes" xml:space="preserve">
          <source>The function returns the triggered &lt;a href=&quot;qaction&quot;&gt;QAction&lt;/a&gt; in either the popup menu or one of its submenus, or &lt;code&gt;nullptr&lt;/code&gt; if no item was triggered (normally because the user pressed Esc).</source>
          <target state="translated">이 함수는 팝업 메뉴 또는 하위 메뉴 중 하나에서 트리거 된 &lt;a href=&quot;qaction&quot;&gt;QAction&lt;/a&gt; 을 반환하거나 트리거 된 항목이없는 경우 (일반적으로 사용자가 Esc를 눌렀 기 때문에) &lt;code&gt;nullptr&lt;/code&gt; 을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="03cb50e99323aa2004fd3cf76dc18919dec5c0aa" translate="yes" xml:space="preserve">
          <source>The function returns true if the object could perform the action, otherwise returns false.</source>
          <target state="translated">객체가 작업을 수행 할 수 있으면이 함수는 true를 반환하고, 그렇지 않으면 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7e885a7a058e8d52bf225bdca2b0d0481ca555b4" translate="yes" xml:space="preserve">
          <source>The function returns true if the texture was changed as a resul of the update; otherwise returns false.</source>
          <target state="translated">텍스처가 업데이트 결과로 변경되면이 함수는 true를 반환합니다. 그렇지 않으면 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b929cbfdce0dca71942e6bfbca8df96286aa7a6f" translate="yes" xml:space="preserve">
          <source>The function returns true if the trace interaction was accepted (i.e. the touch events should not be used for anything else).</source>
          <target state="translated">이 함수는 트레이스 상호 작용이 수락 된 경우 true를 반환합니다 (즉, 터치 이벤트를 다른 용도로 사용해서는 안 됨).</target>
        </trans-unit>
        <trans-unit id="503d8ade829f6955c7ce7613b8d4263d54a71d49" translate="yes" xml:space="preserve">
          <source>The function setSupportsRouteUpdates() is one of several functions which configure the reported capabilities of the engine. If the capabilities of an engine differ from the default values these functions should be used so that the reported capabilities are accurate.</source>
          <target state="translated">setSupportsRouteUpdates () 함수는 엔진의보고 된 기능을 구성하는 여러 함수 중 하나입니다. 엔진의 기능이 기본값과 다른 경우보고 된 기능이 정확하도록이 기능을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="db406f3bacec2bbac60f4bcc36add9d3ee8fec02" translate="yes" xml:space="preserve">
          <source>The function sets up a call to the &lt;a href=&quot;qdbusxml2cpp&quot;&gt;Qt D-Bus XML compiler (qdbusxml2cpp)&lt;/a&gt; in adaptor mode. The default file and class name are generated from the last segment in the &lt;code&gt;dbus_spec&lt;/code&gt; base name:</source>
          <target state="translated">이 함수는 어댑터 모드에서 &lt;a href=&quot;qdbusxml2cpp&quot;&gt;Qt D-Bus XML 컴파일러 (qdbusxml2cpp)&lt;/a&gt; 에 대한 호출을 설정 합니다. 기본 파일 및 클래스 이름은 &lt;code&gt;dbus_spec&lt;/code&gt; 기본 이름 의 마지막 세그먼트에서 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="bf30bd8c714e697119bde9c39a19e2be42d2f8c3" translate="yes" xml:space="preserve">
          <source>The function sets up a call to the &lt;a href=&quot;qdbusxml2cpp&quot;&gt;Qt D-Bus XML compiler (qdbusxml2cpp)&lt;/a&gt; in interface (proxy) mode. By default, &lt;code&gt;qdbusxml2cpp&lt;/code&gt; generates a C++ class named after the interface name, with a namespaced alias:</source>
          <target state="translated">이 함수는 인터페이스 (프록시) 모드에서 &lt;a href=&quot;qdbusxml2cpp&quot;&gt;Qt D-Bus XML 컴파일러 (qdbusxml2cpp)&lt;/a&gt; 에 대한 호출을 설정 합니다. 기본적으로 &lt;code&gt;qdbusxml2cpp&lt;/code&gt; 는 네임 스페이스 별명을 사용하여 인터페이스 이름 뒤에 이름이 지정된 C ++ 클래스를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="7e6637d4baf42ffea6967ef462e84d6d87eaa2c1" translate="yes" xml:space="preserve">
          <source>The function sets up a call to the &lt;a href=&quot;qdbusxml2cpp#&quot;&gt;Qt D-Bus XML compiler (qdbusxml2cpp)&lt;/a&gt; in adaptor mode. The default file and class name are generated from the last segment in the &lt;code&gt;dbus_spec&lt;/code&gt; base name:</source>
          <target state="translated">이 기능은 어댑터 모드에서 &lt;a href=&quot;qdbusxml2cpp#&quot;&gt;Qt D-Bus XML 컴파일러 (qdbusxml2cpp)&lt;/a&gt; 에 대한 호출을 설정 합니다. 기본 파일 및 클래스 이름은 &lt;code&gt;dbus_spec&lt;/code&gt; 기본 이름 의 마지막 세그먼트에서 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="8a48af6d7901fedb1351c3a8b400ae1dea89d33b" translate="yes" xml:space="preserve">
          <source>The function sets up a call to the &lt;a href=&quot;qdbusxml2cpp#&quot;&gt;Qt D-Bus XML compiler (qdbusxml2cpp)&lt;/a&gt; in interface (proxy) mode. By default, &lt;code&gt;qdbusxml2cpp&lt;/code&gt; generates a C++ class named after the interface name, with a namespaced alias:</source>
          <target state="translated">이 기능은 인터페이스 (프록시) 모드에서 &lt;a href=&quot;qdbusxml2cpp#&quot;&gt;Qt D-Bus XML 컴파일러 (qdbusxml2cpp)&lt;/a&gt; 에 대한 호출을 설정 합니다. 기본적으로 &lt;code&gt;qdbusxml2cpp&lt;/code&gt; 는 네임 스페이스가 지정된 별명을 사용하여 인터페이스 이름에 따라 이름이 지정된 C ++ 클래스를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="ae57e5aea569f2e4efc0a03435e2d2f1a7e8e4ac" translate="yes" xml:space="preserve">
          <source>The function sets up a call to the &lt;code&gt;qdbuscpp2xml&lt;/code&gt; command line tool. Further arguments to the tool can be set after &lt;code&gt;OPTIONS&lt;/code&gt;.</source>
          <target state="translated">이 함수는 &lt;code&gt;qdbuscpp2xml&lt;/code&gt; 명령 행 도구에 대한 호출을 설정합니다 . 도구에 대한 추가 인수는 &lt;code&gt;OPTIONS&lt;/code&gt; 후에 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b3644c8ad6b9e6aba513b1c78be9dc5d3f067e58" translate="yes" xml:space="preserve">
          <source>The function should at all times return the correct texture id.</source>
          <target state="translated">이 함수는 항상 올바른 텍스처 ID를 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="72652fb57f6a8d4729e58ad71991c6bd4507f3e3" translate="yes" xml:space="preserve">
          <source>The function should return &lt;code&gt;true&lt;/code&gt; if it handles the event. Otherwise the input falls back to &lt;a href=&quot;qml-qtquick-virtualkeyboard-inputmethod#reselect-method&quot;&gt;reselect()&lt;/a&gt; for further processing.</source>
          <target state="translated">함수가 이벤트를 처리하면 &lt;code&gt;true&lt;/code&gt; 를 반환해야합니다 . 그렇지 않으면 입력은 추가 처리를 위해 &lt;a href=&quot;qml-qtquick-virtualkeyboard-inputmethod#reselect-method&quot;&gt;reselect ()&lt;/a&gt; 로 돌아갑니다 .</target>
        </trans-unit>
        <trans-unit id="cf9966d607ba2748f77fc67af04e0525a4344540" translate="yes" xml:space="preserve">
          <source>The function should return &lt;code&gt;true&lt;/code&gt; if it handles the event. Otherwise the input falls back to &lt;a href=&quot;qvirtualkeyboardabstractinputmethod#reselect&quot;&gt;reselect&lt;/a&gt;() for further processing.</source>
          <target state="translated">함수가 이벤트를 처리하면 &lt;code&gt;true&lt;/code&gt; 를 반환해야합니다 . 그렇지 않으면 입력은 추가 처리를 위해 &lt;a href=&quot;qvirtualkeyboardabstractinputmethod#reselect&quot;&gt;다시 선택&lt;/a&gt; ()으로 돌아갑니다 .</target>
        </trans-unit>
        <trans-unit id="1cbf21f6d4481cfd8f4d7145dae3f3d8e3f37831" translate="yes" xml:space="preserve">
          <source>The function should return &lt;code&gt;true&lt;/code&gt; if the connection is to be accepted. Otherwise, the socket is closed/rejected.</source>
          <target state="translated">연결을 수락하려면 함수가 &lt;code&gt;true&lt;/code&gt; 를 반환해야합니다 . 그렇지 않으면 소켓이 닫히거나 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="d2474c2234028fa9db615f28e7cf40471be3d4d1" translate="yes" xml:space="preserve">
          <source>The function should return the root of the scene graph subtree for this item. Most implementations will return a single &lt;a href=&quot;qsggeometrynode&quot;&gt;QSGGeometryNode&lt;/a&gt; containing the visual representation of this item.</source>
          <target state="translated">함수는이 항목에 대한 장면 그래프 하위 트리의 루트를 반환해야합니다. 대부분의 구현은 이 항목의 시각적 표현을 포함 하는 단일 &lt;a href=&quot;qsggeometrynode&quot;&gt;QSGGeometryNode&lt;/a&gt; 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="c054041989dd35af31863855920280f8653c290f" translate="yes" xml:space="preserve">
          <source>The function specified by</source>
          <target state="translated">에 의해 지정된 기능</target>
        </trans-unit>
        <trans-unit id="1f05bb963259814db5820584e56ff88edf3bb992" translate="yes" xml:space="preserve">
          <source>The function text() of the &lt;a href=&quot;qdomelement&quot;&gt;QDomElement&lt;/a&gt; for the &lt;code&gt;&amp;lt;h1&amp;gt;&lt;/code&gt; tag, will return the following text:</source>
          <target state="translated">기능의 텍스트 () &lt;a href=&quot;qdomelement&quot;&gt;QDomElement&lt;/a&gt; 위한 &lt;code&gt;&amp;lt;h1&amp;gt;&lt;/code&gt; 태그는 다음 텍스트를 반환 :</target>
        </trans-unit>
        <trans-unit id="c43a02322182b85e506469aef0049ab611ada1d3" translate="yes" xml:space="preserve">
          <source>The function to remove rows from the model is also simple to write. The rows to be removed from the model are specified by the position and the number of rows given. We ignore the parent index to simplify our implementation, and just remove the corresponding items from the string list.</source>
          <target state="translated">모델에서 행을 제거하는 기능도 작성이 간단합니다. 모델에서 제거 할 행은 지정된 위치와 행 수로 지정됩니다. 구현을 단순화하기 위해 부모 인덱스를 무시하고 문자열 목록에서 해당 항목을 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="8c48a25237859b1dd3d4f41de135d750d72f4a8e" translate="yes" xml:space="preserve">
          <source>The function will be called only once for each combination of material type and</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0dd9863a52004e46fc4bf374b85af41e4bd8484" translate="yes" xml:space="preserve">
          <source>The function will be called only once for each material type that exists in the scene graph and will be cached internally.</source>
          <target state="translated">이 기능은 장면 그래프에 존재하는 각 재질 유형에 대해 한 번만 호출되며 내부적으로 캐시됩니다.</target>
        </trans-unit>
        <trans-unit id="29f920979f985f8c8baf52b4f4a1b2da57297f91" translate="yes" xml:space="preserve">
          <source>The function will create all parent directories necessary to create the directory.</source>
          <target state="translated">이 함수는 디렉토리를 작성하는 데 필요한 모든 상위 디렉토리를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="160833455c73cefdbdb06b15928fdb756d21819c" translate="yes" xml:space="preserve">
          <source>The function will remove all parent directories in</source>
          <target state="translated">이 함수는 모든 상위 디렉토리를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="c745e056b8befb24cf3e2dbb827e74c4c24754f9" translate="yes" xml:space="preserve">
          <source>The function works by selecting a color from one of the corners and then chipping away pixels of that color, starting at all the edges. If</source>
          <target state="translated">이 기능은 모서리 중 하나에서 색상을 선택한 다음 모든 가장자리에서 시작하여 해당 색상의 픽셀을 잘라냅니다. 만약</target>
        </trans-unit>
        <trans-unit id="0d16203ab7bd8488ebbd208c3bc0fa6faf9a2d39" translate="yes" xml:space="preserve">
          <source>The function works by selecting a color from one of the corners, then chipping away pixels of that color starting at all the edges. The four corners vote for which color is to be masked away. In case of a draw (this generally means that this function is not applicable to the image), the result is arbitrary.</source>
          <target state="translated">이 기능은 모서리 중 하나에서 색상을 선택한 다음 모든 가장자리에서 시작하여 해당 색상의 픽셀을 잘라냅니다. 네 모서리는 어떤 색이 가려 질 것인지 투표합니다. 드로우의 경우 (일반적으로이 기능을 이미지에 적용 할 수 없음을 의미) 결과는 임의적입니다.</target>
        </trans-unit>
        <trans-unit id="20967e620a01b50262662e397babb665090e6130" translate="yes" xml:space="preserve">
          <source>The functionality in Qt 3D is divided into the following C++ modules:</source>
          <target state="translated">Qt 3D의 기능은 다음 C ++ 모듈로 나뉩니다.</target>
        </trans-unit>
        <trans-unit id="ce6f331fc8be29ed7810f9c6be4e0b0be865ea6a" translate="yes" xml:space="preserve">
          <source>The functionality in Qt WebEngine is divided into the following modules:</source>
          <target state="translated">Qt WebEngine의 기능은 다음 모듈로 나뉩니다.</target>
        </trans-unit>
        <trans-unit id="e6b0dce780b652bb7deca16c8cdbbbcf58307291" translate="yes" xml:space="preserve">
          <source>The functionality of this is only available if it is supported by the backend and if the sensor is orientable, which can be checked by calling &lt;a href=&quot;qsensor#isFeatureSupported&quot;&gt;QSensor::isFeatureSupported&lt;/a&gt;() with the &lt;a href=&quot;qsensor#Feature-enum&quot;&gt;QSensor::AxesOrientation&lt;/a&gt; flag.</source>
          <target state="translated">이 기능은 백엔드에서 지원하고 센서가 방향을 지정할 수있는 경우에만 사용 가능하며, &lt;a href=&quot;qsensor#isFeatureSupported&quot;&gt;QSensor &lt;/a&gt;&lt;a href=&quot;qsensor#Feature-enum&quot;&gt;:: AxesOrientation&lt;/a&gt; 플래그 와 함께 QSensor :: isFeatureSupported ()를 호출하여 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4a82c491491566772c4b13f94228ca14d2194835" translate="yes" xml:space="preserve">
          <source>The functionality of this module is divided into the following submodules:</source>
          <target state="translated">이 모듈의 기능은 다음과 같은 하위 모듈로 나뉩니다.</target>
        </trans-unit>
        <trans-unit id="a90953a9b3736082e280a7b80219f1e35af913bb" translate="yes" xml:space="preserve">
          <source>The functionality provided by this control allows the setting of a Network Access Point.</source>
          <target state="translated">이 컨트롤에서 제공하는 기능으로 네트워크 액세스 포인트를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d129166a1db62c40a81805d92311108a8ead88b" translate="yes" xml:space="preserve">
          <source>The functionality provided by this control is exposed to application code by the meta-data members of &lt;a href=&quot;qmediaobject&quot;&gt;QMediaObject&lt;/a&gt;, and so meta-data access is potentially available in any of the media object classes. Any media service may implement &lt;a href=&quot;qmetadatareadercontrol&quot;&gt;QMetaDataReaderControl&lt;/a&gt;.</source>
          <target state="translated">이 컨트롤에서 제공하는 기능은 &lt;a href=&quot;qmediaobject&quot;&gt;QMediaObject&lt;/a&gt; 의 메타 데이터 멤버에 의해 애플리케이션 코드에 노출 되므로 메타 데이터 액세스는 모든 미디어 객체 클래스에서 잠재적으로 사용 가능합니다. 모든 미디어 서비스는 &lt;a href=&quot;qmetadatareadercontrol&quot;&gt;QMetaDataReaderControl을&lt;/a&gt; 구현할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1c18a3d8f1136de14db8f604db49bd3311a7dca8" translate="yes" xml:space="preserve">
          <source>The functionality provided by this control is exposed to application code by the meta-data members of &lt;a href=&quot;qmediaobject&quot;&gt;QMediaObject&lt;/a&gt;, and so meta-data access is potentially available in any of the media object classes. Any media service may implement QMetaDataControl.</source>
          <target state="translated">이 컨트롤에서 제공하는 기능은 &lt;a href=&quot;qmediaobject&quot;&gt;QMediaObject&lt;/a&gt; 의 메타 데이터 멤버에 의해 애플리케이션 코드에 노출 되므로 메타 데이터 액세스는 모든 미디어 객체 클래스에서 잠재적으로 사용 가능합니다. 모든 미디어 서비스는 QMetaDataControl을 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ddefcf770b805f3a70687895a05f30edece79787" translate="yes" xml:space="preserve">
          <source>The functionality provided by this control is exposed to application code by the meta-data members of &lt;a href=&quot;qmediaobject&quot;&gt;QMediaObject&lt;/a&gt;, and so meta-data access is potentially available in any of the media object classes. Any media service may implement QMetaDataReaderControl.</source>
          <target state="translated">이 컨트롤에서 제공하는 기능은 &lt;a href=&quot;qmediaobject&quot;&gt;QMediaObject&lt;/a&gt; 의 메타 데이터 멤버에 의해 애플리케이션 코드에 노출 되므로 메타 데이터 액세스는 잠재적으로 모든 미디어 개체 클래스에서 사용할 수 있습니다. 모든 미디어 서비스는 QMetaDataReaderControl을 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c71294d4582cd8c8dc0640aeac0d7baffa5e7fc" translate="yes" xml:space="preserve">
          <source>The functionality provided by this control is exposed to application code through the &lt;a href=&quot;qaudiodecoder&quot;&gt;QAudioDecoder&lt;/a&gt; class.</source>
          <target state="translated">이 컨트롤에서 제공하는 기능은 &lt;a href=&quot;qaudiodecoder&quot;&gt;QAudioDecoder&lt;/a&gt; 클래스를 통해 응용 프로그램 코드에 노출됩니다 .</target>
        </trans-unit>
        <trans-unit id="073d69916bfa1c94448909258763f290e9aa1580" translate="yes" xml:space="preserve">
          <source>The functionality provided by this control is exposed to application code through the &lt;a href=&quot;qcamera&quot;&gt;QCamera&lt;/a&gt; class.</source>
          <target state="translated">이 컨트롤에서 제공하는 기능은 &lt;a href=&quot;qcamera&quot;&gt;QCamera&lt;/a&gt; 클래스를 통해 응용 프로그램 코드에 노출됩니다 .</target>
        </trans-unit>
        <trans-unit id="b7bdb36f3970ccc509394b65f2f7869e01d5bf50" translate="yes" xml:space="preserve">
          <source>The functionality provided by this control is exposed to application code through the &lt;a href=&quot;qmediaplayer&quot;&gt;QMediaPlayer&lt;/a&gt; class.</source>
          <target state="translated">이 컨트롤에서 제공하는 기능은 &lt;a href=&quot;qmediaplayer&quot;&gt;QMediaPlayer&lt;/a&gt; 클래스를 통해 응용 프로그램 코드에 노출됩니다 .</target>
        </trans-unit>
        <trans-unit id="39cbfe078ebf90696771110a46c40650cdae1baf" translate="yes" xml:space="preserve">
          <source>The functionality provided by this control is exposed to application code through the &lt;a href=&quot;qmediarecorder&quot;&gt;QMediaRecorder&lt;/a&gt; class.</source>
          <target state="translated">이 컨트롤에서 제공하는 기능은 &lt;a href=&quot;qmediarecorder&quot;&gt;QMediaRecorder&lt;/a&gt; 클래스를 통해 응용 프로그램 코드에 노출됩니다 .</target>
        </trans-unit>
        <trans-unit id="8893dbd0fcd02ee6c2626ef4adcee4390c81a5b1" translate="yes" xml:space="preserve">
          <source>The functionality provided by this control is exposed to application code through the &lt;a href=&quot;qradiodata&quot;&gt;QRadioData&lt;/a&gt; class.</source>
          <target state="translated">이 제어에서 제공하는 기능은 &lt;a href=&quot;qradiodata&quot;&gt;QRadioData&lt;/a&gt; 클래스를 통해 애플리케이션 코드에 노출됩니다 .</target>
        </trans-unit>
        <trans-unit id="179b0aba92a56b198b550022bb4f5eacb16d7ca6" translate="yes" xml:space="preserve">
          <source>The functionality provided by this control is exposed to application code through the &lt;a href=&quot;qradiotuner&quot;&gt;QRadioTuner&lt;/a&gt; class.</source>
          <target state="translated">이 제어에서 제공하는 기능은 &lt;a href=&quot;qradiotuner&quot;&gt;QRadioTuner&lt;/a&gt; 클래스를 통해 애플리케이션 코드에 노출됩니다 .</target>
        </trans-unit>
        <trans-unit id="053e791ba89adbd932335232cfcc813caaa17188" translate="yes" xml:space="preserve">
          <source>The functions &lt;a href=&quot;qaccessibleinterface#childCount&quot;&gt;childCount&lt;/a&gt;() and &lt;a href=&quot;qaccessibleinterface#indexOfChild&quot;&gt;indexOfChild&lt;/a&gt;() return the number of children of an accessible object and the index a child object has in its parent. The &lt;a href=&quot;qaccessibleinterface#childAt&quot;&gt;childAt&lt;/a&gt;() function returns a child &lt;a href=&quot;qaccessibleinterface&quot;&gt;QAccessibleInterface&lt;/a&gt; that is found at a position. The child does not have to be a direct child. This allows bypassing intermediate layers when the parent already knows the top-most child. &lt;a href=&quot;qaccessibleinterface#childAt&quot;&gt;childAt&lt;/a&gt;() is used for hit testing (finding the object under the mouse).</source>
          <target state="translated">&lt;a href=&quot;qaccessibleinterface#childCount&quot;&gt;childCount&lt;/a&gt; () 및 &lt;a href=&quot;qaccessibleinterface#indexOfChild&quot;&gt;indexOfChild&lt;/a&gt; () 함수 는 액세스 가능한 객체의 자식 수와 자식 개체가 부모에있는 인덱스를 반환합니다. &lt;a href=&quot;qaccessibleinterface#childAt&quot;&gt;childAt&lt;/a&gt; () 함수는 자식 반환 &lt;a href=&quot;qaccessibleinterface&quot;&gt;QAccessibleInterface&lt;/a&gt; 위치에서 찾을 수 있습니다. 자녀는 직계 자녀 일 필요는 없습니다. 이렇게하면 부모가 이미 최상위 자식을 알고있을 때 중간 계층을 우회 할 수 있습니다. &lt;a href=&quot;qaccessibleinterface#childAt&quot;&gt;childAt&lt;/a&gt; ()는 적중 테스트에 사용됩니다 (마우스 아래에서 객체 찾기).</target>
        </trans-unit>
        <trans-unit id="6151e6108e2ca390dd21348bfabcc54330e13bbb" translate="yes" xml:space="preserve">
          <source>The functions &lt;a href=&quot;qaccessibleinterface#childCount&quot;&gt;childCount&lt;/a&gt;() and &lt;a href=&quot;qaccessibleinterface#indexOfChild&quot;&gt;indexOfChild&lt;/a&gt;() return the number of children of an accessible object and the index a child object has in its parent. The &lt;a href=&quot;qaccessibleinterface#childAt&quot;&gt;childAt&lt;/a&gt;() function returns a child QAccessibleInterface that is found at a position. The child does not have to be a direct child. This allows bypassing intermediate layers when the parent already knows the top-most child. &lt;a href=&quot;qaccessibleinterface#childAt&quot;&gt;childAt&lt;/a&gt;() is used for hit testing (finding the object under the mouse).</source>
          <target state="translated">&lt;a href=&quot;qaccessibleinterface#childCount&quot;&gt;childCount&lt;/a&gt; () 및 &lt;a href=&quot;qaccessibleinterface#indexOfChild&quot;&gt;indexOfChild&lt;/a&gt; () 함수 는 액세스 가능한 개체의 자식 수와 자식 개체가 부모에있는 인덱스를 반환합니다. &lt;a href=&quot;qaccessibleinterface#childAt&quot;&gt;childAt&lt;/a&gt; () 함수는 위치에 발견되는 자식 QAccessibleInterface을 반환합니다. 자녀가 직계 자녀 일 필요는 없습니다. 이렇게하면 부모가 이미 최상위 자식을 알고있을 때 중간 레이어를 우회 할 수 있습니다. &lt;a href=&quot;qaccessibleinterface#childAt&quot;&gt;childAt&lt;/a&gt; ()은 적중 테스트에 사용됩니다 (마우스 아래에서 개체 찾기).</target>
        </trans-unit>
        <trans-unit id="a14f5511fb8ca5152835461c850e3d9af8b392b8" translate="yes" xml:space="preserve">
          <source>The functions &lt;a href=&quot;qbitarray#testBit&quot;&gt;testBit&lt;/a&gt;(), &lt;a href=&quot;qbitarray#setBit&quot;&gt;setBit&lt;/a&gt;(), and &lt;a href=&quot;qbitarray#clearBit&quot;&gt;clearBit&lt;/a&gt;() are slightly faster.</source>
          <target state="translated">&lt;a href=&quot;qbitarray#testBit&quot;&gt;testBit&lt;/a&gt; (), &lt;a href=&quot;qbitarray#setBit&quot;&gt;setBit&lt;/a&gt; () 및 &lt;a href=&quot;qbitarray#clearBit&quot;&gt;clearBit&lt;/a&gt; () 함수 는 약간 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="810bb1fa452fa2ddced6f7aca6d337f36f03602b" translate="yes" xml:space="preserve">
          <source>The functions &lt;a href=&quot;qmouseevent#pos&quot;&gt;pos&lt;/a&gt;(), &lt;a href=&quot;qmouseevent#x&quot;&gt;x&lt;/a&gt;(), and &lt;a href=&quot;qmouseevent#y&quot;&gt;y&lt;/a&gt;() give the cursor position relative to the widget that receives the mouse event. If you move the widget as a result of the mouse event, use the global position returned by &lt;a href=&quot;qmouseevent#globalPos&quot;&gt;globalPos&lt;/a&gt;() to avoid a shaking motion.</source>
          <target state="translated">&lt;a href=&quot;qmouseevent#pos&quot;&gt;pos&lt;/a&gt; (), &lt;a href=&quot;qmouseevent#x&quot;&gt;x&lt;/a&gt; () 및 &lt;a href=&quot;qmouseevent#y&quot;&gt;y&lt;/a&gt; () 함수 는 마우스 이벤트를받는 위젯을 기준으로 커서 위치를 제공합니다. 마우스 이벤트의 결과로 위젯을 이동하는 경우 흔들리는 동작을 피하기 위해 &lt;a href=&quot;qmouseevent#globalPos&quot;&gt;globalPos&lt;/a&gt; ()에서 반환 한 전역 위치를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="638329aaffa623bf75939c71da1287e94463d845" translate="yes" xml:space="preserve">
          <source>The functions &lt;a href=&quot;qsinglepointevent#position&quot;&gt;position&lt;/a&gt;() and &lt;a href=&quot;qsinglepointevent#globalPosition&quot;&gt;globalPosition&lt;/a&gt;() return the mouse cursor's location at the time of the event.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef6e24d629b972fa546ba0945ce73754b2df6b02" translate="yes" xml:space="preserve">
          <source>The functions &lt;a href=&quot;qwheelevent#pos&quot;&gt;pos&lt;/a&gt;() and &lt;a href=&quot;qwheelevent#globalPos&quot;&gt;globalPos&lt;/a&gt;() return the mouse cursor's location at the time of the event.</source>
          <target state="translated">&lt;a href=&quot;qwheelevent#pos&quot;&gt;pos&lt;/a&gt; () 및 &lt;a href=&quot;qwheelevent#globalPos&quot;&gt;globalPos&lt;/a&gt; () 함수 는 이벤트시 마우스 커서의 위치를 ​​반환합니다.</target>
        </trans-unit>
        <trans-unit id="d56b4caf185b0972b331c01d724da0c3cd934f6e" translate="yes" xml:space="preserve">
          <source>The functions &lt;a href=&quot;qxmlinputsource#data&quot;&gt;data&lt;/a&gt;() and &lt;a href=&quot;qxmlinputsource#fetchData&quot;&gt;fetchData&lt;/a&gt;() are useful if you want to do something with the data other than parsing, e.g. displaying the raw XML file. The benefit of using the QXmlInputClass in such cases is that it tries to use the correct encoding.</source>
          <target state="translated">함수 &lt;a href=&quot;qxmlinputsource#data&quot;&gt;data&lt;/a&gt; () 및 &lt;a href=&quot;qxmlinputsource#fetchData&quot;&gt;fetchData&lt;/a&gt; ()는 구문 분석 이외의 데이터로 무언가를 수행하려는 경우에 유용합니다 (예 : 원시 XML 파일 표시). 이러한 경우 QXmlInputClass를 사용하면 올바른 인코딩을 사용하려고한다는 이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="524a24e42a067635bfaea415088014dce8e9ba1f" translate="yes" xml:space="preserve">
          <source>The functions accessing the property editor are the &lt;a href=&quot;qdesignerpropertyeditorinterface#core&quot;&gt;core&lt;/a&gt;() function that you can use to retrieve an interface to the form editor, the &lt;a href=&quot;qdesignerpropertyeditorinterface#currentPropertyName&quot;&gt;currentPropertyName&lt;/a&gt;() function that returns the name of the currently selected property in the property editor, the &lt;a href=&quot;qdesignerpropertyeditorinterface#object&quot;&gt;object&lt;/a&gt;() function that returns the currently selected object in</source>
          <target state="translated">속성 편집기에 액세스하는 기능이있는 &lt;a href=&quot;qdesignerpropertyeditorinterface#core&quot;&gt;핵심&lt;/a&gt; 양식 편집기에 대한 인터페이스를 검색하는 데 사용할 수있는 () 함수 &lt;a href=&quot;qdesignerpropertyeditorinterface#currentPropertyName&quot;&gt;currentPropertyName&lt;/a&gt; () 함수가 반환 속성 편집기에서 현재 선택된 속성의 이름, &lt;a href=&quot;qdesignerpropertyeditorinterface#object&quot;&gt;객체&lt;/a&gt; () 함수가 현재 선택된 객체를</target>
        </trans-unit>
        <trans-unit id="4eb5e31fbed10a5116cdb008a7514498ba9a1ed4" translate="yes" xml:space="preserve">
          <source>The functions and operators available with a &lt;a href=&quot;qpointer&quot;&gt;QPointer&lt;/a&gt; are the same as those available with a normal unguarded pointer, except the pointer arithmetic operators (&lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;++&lt;/code&gt;, and &lt;code&gt;--&lt;/code&gt;), which are normally used only with arrays of objects.</source>
          <target state="translated">&lt;a href=&quot;qpointer&quot;&gt;QPointer&lt;/a&gt; 와 함께 사용할 수있는 함수와 연산자 는 일반적으로 객체 배열에만 사용되는 포인터 산술 연산자 ( &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;++&lt;/code&gt; 및 &lt;code&gt;--&lt;/code&gt; )를 제외하고 일반 보호되지 않은 포인터에서 사용할 수있는 함수와 연산자와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="4384a5c0e6ee2294eca7f372ede213d7c8b1d794" translate="yes" xml:space="preserve">
          <source>The functions and operators available with a QPointer are the same as those available with a normal unguarded pointer, except the pointer arithmetic operators (&lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;++&lt;/code&gt;, and &lt;code&gt;--&lt;/code&gt;), which are normally used only with arrays of objects.</source>
          <target state="translated">QPointer에서 사용할 수있는 함수와 연산자 는 일반적으로 객체 배열에만 사용되는 포인터 산술 연산자 ( &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;++&lt;/code&gt; 및 &lt;code&gt;--&lt;/code&gt; )를 제외하고는 일반 비보호 포인터에서 사용할 수있는 것과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="d5ed49c284e805a53110515d7d90341d7e1a1ad8" translate="yes" xml:space="preserve">
          <source>The functions are divided into categories according to their type:</source>
          <target state="translated">기능은 유형에 따라 범주로 나뉩니다.</target>
        </trans-unit>
        <trans-unit id="a609d9b7d233d08025868318c7d43e0220070f3b" translate="yes" xml:space="preserve">
          <source>The functions defined in an imported JavaScript file are available to objects defined in the importing QML document, via the &lt;code&gt;&quot;Qualifier.functionName(params)&quot;&lt;/code&gt; syntax. Functions in JavaScript resources may take parameters whose type can be any of the supported QML basic types or object types, as well as normal JavaScript types. The normal &lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;data type conversion rules&lt;/a&gt; will apply to parameters and return values when calling such functions from QML.</source>
          <target state="translated">가져온 JavaScript 파일에 정의 된 함수는 &lt;code&gt;&quot;Qualifier.functionName(params)&quot;&lt;/code&gt; 구문을 통해 가져 오는 QML 문서에 정의 된 객체에서 사용할 수 있습니다 . JavaScript 리소스의 함수는 유형이 지원되는 QML 기본 유형 또는 객체 유형과 일반 JavaScript 유형 중 하나 일 수있는 매개 변수를 사용할 수 있습니다. 일반 &lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;데이터 유형 변환 규칙&lt;/a&gt; 은 QML에서 이러한 함수를 호출 할 때 매개 변수 및 반환 값에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="5d3c936e1bb7225f5b884bdd3ec70c3f3e3cd432" translate="yes" xml:space="preserve">
          <source>The functions defined in an imported JavaScript file are available to objects defined in the importing QML document, via the &lt;code&gt;&quot;Qualifier.functionName(params)&quot;&lt;/code&gt; syntax. Functions in JavaScript resources may take parameters whose type can be any of the supported QML basic types or object types, as well as normal JavaScript types. The normal &lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;data type conversion rules&lt;/a&gt; will apply to parameters and return values when calling such functions from QML.</source>
          <target state="translated">가져온 JavaScript 파일에 정의 된 함수는 &lt;code&gt;&quot;Qualifier.functionName(params)&quot;&lt;/code&gt; 구문을 통해 가져 오기 QML 문서에 정의 된 객체에서 사용할 수 있습니다 . JavaScript 자원의 함수는 유형이 지원되는 QML 기본 유형 또는 오브젝트 유형과 일반 JavaScript 유형 중 하나 일 수있는 매개 변수를 사용할 수 있습니다. 일반 &lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;데이터 유형 변환 규칙&lt;/a&gt; 은 QML에서 이러한 함수를 호출 할 때 매개 변수 및 리턴 값에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="a7acde652b7ddfa6d0a5b7e48b4818dd04078caa" translate="yes" xml:space="preserve">
          <source>The functions in this class are used for communication between accessible applications (also called AT Servers) and accessibility tools (AT Clients), such as screen readers and braille displays. Clients and servers communicate in the following way:</source>
          <target state="translated">이 클래스의 기능은 액세스 가능한 애플리케이션 (AT 서버라고도 함)과 스크린 리더 및 점자 디스플레이와 같은 액세스 가능성 도구 (AT 클라이언트) 간의 통신에 사용됩니다. 클라이언트와 서버는 다음과 같은 방식으로 통신합니다.</target>
        </trans-unit>
        <trans-unit id="18027954599843a0ca6fa5481591a6aaa5f2ee5e" translate="yes" xml:space="preserve">
          <source>The functions pos() and globalPos() return the mouse cursor's location at the time of the event.</source>
          <target state="translated">pos () 및 globalPos () 함수는 이벤트 발생시 마우스 커서의 위치를 ​​반환합니다.</target>
        </trans-unit>
        <trans-unit id="c75d81fafc0c205c6eb1b2da2d3b733247c0c931" translate="yes" xml:space="preserve">
          <source>The functions provided by this class allow an ActiveX control to communicate property changes to a client application. Inherit your control class from both &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; (directly or indirectly) and this class to get access to this class's functions. The &lt;a href=&quot;moc&quot;&gt;meta-object compiler&lt;/a&gt; requires you to inherit from &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; first.</source>
          <target state="translated">이 클래스에서 제공하는 함수를 사용하면 ActiveX 컨트롤이 속성 변경 내용을 클라이언트 응용 프로그램과 통신 할 수 있습니다. &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; (직접 또는 간접)과이 클래스에서 제어 클래스를 상속 하여이 클래스의 기능에 액세스하십시오. &lt;a href=&quot;moc&quot;&gt;메타 오브젝트 컴파일러&lt;/a&gt; 에서 상속 할 필요 &lt;a href=&quot;qwidget&quot;&gt;는 QWidget&lt;/a&gt; 첫째.</target>
        </trans-unit>
        <trans-unit id="1fd0b961902f409e02cf8daa692258ab7d82f484" translate="yes" xml:space="preserve">
          <source>The functions that need to be implemented in a model subclass can be divided into three groups:</source>
          <target state="translated">모델 서브 클래스에서 구현해야하는 함수는 세 그룹으로 나눌 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="58a707dfad3fd8f798f21698713709681c728cf9" translate="yes" xml:space="preserve">
          <source>The functions used to manipulate an image's pixels depend on the image format. The reason is that monochrome and 8-bit images are index-based and use a color lookup table, while 32-bit images store ARGB values directly. For more information on image formats, see the &lt;a href=&quot;qimage#image-formats&quot;&gt;Image Formats&lt;/a&gt; section.</source>
          <target state="translated">이미지의 픽셀을 조작하는 데 사용되는 기능은 이미지 형식에 따라 다릅니다. 그 이유는 단색 및 8 비트 이미지가 인덱스 기반이며 컬러 룩업 테이블을 사용하는 반면 32 비트 이미지는 ARGB 값을 직접 저장하기 때문입니다. 이미지 형식에 대한 자세한 내용은 &lt;a href=&quot;qimage#image-formats&quot;&gt;이미지 형식&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c3ace8911f115e082d7327265000d73ae3b01478" translate="yes" xml:space="preserve">
          <source>The functions you are most likely to find useful are these:</source>
          <target state="translated">가장 유용한 기능은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="371868672643811c095617a022bc27f6e4120234" translate="yes" xml:space="preserve">
          <source>The functor-based connection syntax can connect signals to C++11 lambda expressions, which are effectively inline slots. This feature is not available with the string-based syntax.</source>
          <target state="translated">functor 기반 연결 구문은 효과적으로 인라인 슬롯 인 C ++ 11 람다 식에 신호를 연결할 수 있습니다. 문자열 기반 구문에서는이 기능을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="4aa789641f96925637207fcf433e61c9e49da775" translate="yes" xml:space="preserve">
          <source>The fundamental behavior of qmake is influenced by variable declarations that define the build process of each project. Some of these declare resources, such as headers and source files, that are common to each platform. Others are used to customize the behavior of compilers and linkers on specific platforms.</source>
          <target state="translated">qmake의 기본 동작은 각 프로젝트의 빌드 프로세스를 정의하는 변수 선언의 영향을받습니다. 이들 중 일부는 각 플랫폼에 공통 인 헤더 및 소스 파일과 같은 자원을 선언합니다. 다른 플랫폼은 특정 플랫폼에서 컴파일러 및 링커의 동작을 사용자 정의하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ffad6395005d42f0f1c162b7d5d5df14dfb72d53" translate="yes" xml:space="preserve">
          <source>The gamma level of the image. A handler that supports this option is expected to set the image gamma level depending on the value of this option (a float) when writing.</source>
          <target state="translated">이미지의 감마 레벨. 이 옵션을 지원하는 핸들러는 쓸 때이 옵션의 값 (float)에 따라 이미지 감마 레벨을 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="01c8831d501dee8134a2d43e52279bca3d851d6d" translate="yes" xml:space="preserve">
          <source>The gamma of the tonemap. Sensible values are in the range &lt;code&gt;[0.1...8]&lt;/code&gt;. &lt;code&gt;2.2&lt;/code&gt; by default.</source>
          <target state="translated">톤맵의 감마입니다. 합리적인 값은 &lt;code&gt;[0.1...8]&lt;/code&gt; 범위에 있습니다. 기본적으로 &lt;code&gt;2.2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0f10c69982d940fc3609613e8ed66421e382b5e0" translate="yes" xml:space="preserve">
          <source>The gap can be different on different dimensions. The values are fractions of the volume thickness in the same dimension. The values cannot be negative.</source>
          <target state="translated">간격은 치수에 따라 다를 수 있습니다. 값은 동일한 치수에서 부피 두께의 분수입니다. 값은 음수 일 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="770a8dd229fe62d17af03053defb468e93bdb382" translate="yes" xml:space="preserve">
          <source>The garbage collector may be invoked manually by calling &lt;code&gt;gc()&lt;/code&gt; within JavaScript. This will cause a comprehensive collection cycle to be performed, which may take from between a few hundred to more than a thousand milliseconds to complete, and so should be avoided if at all possible.</source>
          <target state="translated">가비지 수집기는 JavaScript 내에서 &lt;code&gt;gc()&lt;/code&gt; 호출하여 수동으로 호출 할 수 있습니다 . 이로 인해 수백에서 수천 밀리 초 이상 걸리는 포괄적 인 수집주기가 수행 될 수 있으므로 가능하면 피해야합니다.</target>
        </trans-unit>
        <trans-unit id="56df07dea0717d9239293b21163182a7951154bc" translate="yes" xml:space="preserve">
          <source>The garbage collector will attempt to reclaim memory by locating and disposing of objects that are no longer reachable in the script environment.</source>
          <target state="translated">가비지 수집기는 스크립트 환경에서 더 이상 도달 할 수없는 객체를 찾아서 삭제하여 메모리를 회수하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="9c5d18d8fbfb59aa269b98dc6ec0f688d079fced" translate="yes" xml:space="preserve">
          <source>The gauge displaying values at various points during the animation.</source>
          <target state="translated">애니메이션 동안 다양한 지점에서 값을 표시하는 게이지입니다.</target>
        </trans-unit>
        <trans-unit id="60147ec05f158fa15d660e37a8a385691bd3ed38" translate="yes" xml:space="preserve">
          <source>The gender of a voice.</source>
          <target state="translated">목소리의 성별.</target>
        </trans-unit>
        <trans-unit id="c0a1a8818618be6fc39cffd05b4e64fa5dd32484" translate="yes" xml:space="preserve">
          <source>The general approach to using &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt; to perform queries on non-XML data has been a three step process. In the first step, the data is loaded into a non-XML data model. In the second step, the non-XML data model is serialized as XML and output to XML (text) files. In the final step, an XML tool loads the XML files into a second, XML data model, where the XQueries can be performed. The development cost of implementing this process is often high, and the three step system that results is inefficient because the two data models must be built and maintained separately.</source>
          <target state="translated">&lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt; 를 사용하여 비 XML 데이터에 대한 쿼리를 수행 하는 일반적인 접근 방식 은 3 단계 프로세스였습니다. 첫 번째 단계에서 데이터는 비 XML 데이터 모델로로드됩니다. 두 번째 단계에서는 비 XML 데이터 모델이 XML로 직렬화되고 XML (텍스트) 파일로 출력됩니다. 마지막 단계에서 XML 도구는 XQueries를 수행 할 수있는 두 번째 XML 데이터 모델로 XML 파일을로드합니다. 이 프로세스를 구현하는 데 드는 개발 비용은 높은 경우가 많으며 두 데이터 모델을 별도로 구축하고 유지 관리해야하기 때문에 결과적으로 발생하는 3 단계 시스템은 비효율적입니다.</target>
        </trans-unit>
        <trans-unit id="e49be487efd164bd60c630c28fb8df81a74b2521" translate="yes" xml:space="preserve">
          <source>The general approach to using XQuery to perform queries on non-XML data has been a three step process. In the first step, the data is loaded into a non-XML data model. In the second step, the non-XML data model is serialized as XML and output to XML (text) files. In the final step, an XML tool loads the XML files into a second, XML data model, where the XQueries can be performed. The development cost of implementing this process is often high, and the three step system that results is inefficient because the two data models must be built and maintained separately.</source>
          <target state="translated">XQuery를 사용하여 비 XML 데이터에 대한 쿼리를 수행하는 일반적인 방법은 3 단계 프로세스입니다. 첫 번째 단계에서 데이터는 비 XML 데이터 모델로로드됩니다. 두 번째 단계에서 비 XML 데이터 모델은 XML로 직렬화되어 XML (텍스트) 파일로 출력됩니다. 마지막 단계에서 XML 도구는 XML 파일을 XQueries를 수행 할 수있는 두 번째 XML 데이터 모델로로드합니다. 이 프로세스를 구현하는 개발 비용은 종종 높으며, 결과적으로 3 단계 시스템은 두 개의 데이터 모델을 별도로 구축하고 유지 보수해야하기 때문에 비효율적입니다.</target>
        </trans-unit>
        <trans-unit id="2ac0475dab6a4ffe89cfd7bc7291cac7972623ab" translate="yes" xml:space="preserve">
          <source>The general button background color. This background can be different from &lt;code&gt;Window&lt;/code&gt; as some styles require a different background color for buttons.</source>
          <target state="translated">일반적인 버튼 배경색입니다. 일부 스타일의 경우 버튼에 다른 배경색이 필요 &lt;code&gt;Window&lt;/code&gt; 배경은 창과 다를 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fe4da05bdd2fddc3132d1853bdfde442b429a5bd" translate="yes" xml:space="preserve">
          <source>The general button background color. This background can be different from &lt;code&gt;palette.window&lt;/code&gt; as some styles require a different background color for buttons.</source>
          <target state="translated">일반적인 버튼 배경색입니다. 일부 스타일의 경우 버튼에 다른 배경색이 필요 &lt;code&gt;palette.window&lt;/code&gt; 배경은 palette.window 와 다를 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f2f9d631ca199ce57db6c3e9cc69e72eef9c5d18" translate="yes" xml:space="preserve">
          <source>The general button background color. This background can be different from &lt;code&gt;window&lt;/code&gt; as some styles require a different background color for buttons.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e5eb95c9468860851009061f18f29418d2a30c1" translate="yes" xml:space="preserve">
          <source>The general purpose options (and the associated types) are:</source>
          <target state="translated">범용 옵션 및 관련 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="95f876c646745ca74a724ecd04c8a9fbb693567c" translate="yes" xml:space="preserve">
          <source>The general purpose roles (and the associated types) are:</source>
          <target state="translated">일반적인 역할 및 관련 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5f2b76eb60d9deae14e3dac0352b38ad3e33f940" translate="yes" xml:space="preserve">
          <source>The general purpose value (and the associated types) are:</source>
          <target state="translated">일반 용도 값 (및 관련 유형)은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b07042d4dc4c472f92029f05a887b9089bdfdb02" translate="yes" xml:space="preserve">
          <source>The general syntax is &lt;code&gt;alias.&lt;i&gt;original-command-name&lt;/i&gt; = &lt;i&gt;temporary-command-name&lt;/i&gt;&lt;/code&gt;.</source>
          <target state="translated">일반적인 구문은 &lt;code&gt;alias.&lt;i&gt;original-command-name&lt;/i&gt; = &lt;i&gt;temporary-command-name&lt;/i&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="863d712d705af45001e6841a91038d21ccc4c77f" translate="yes" xml:space="preserve">
          <source>The general syntax is &lt;code&gt;extraimages.&lt;i&gt;format&lt;/i&gt; = &lt;i&gt;image&lt;/i&gt;&lt;/code&gt;. The file extension is optional.</source>
          <target state="translated">일반적인 구문은 &lt;code&gt;extraimages.&lt;i&gt;format&lt;/i&gt; = &lt;i&gt;image&lt;/i&gt;&lt;/code&gt; . 파일 확장자는 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="b4e898eb287fe2699809596a231e449462ebcc0f" translate="yes" xml:space="preserve">
          <source>The generated C++ source files are named after the XML file: For the file &lt;code&gt;org.example.chat.xml&lt;/code&gt; the generated header will be named &lt;code&gt;orgexamplechatinterface.h&lt;/code&gt;.</source>
          <target state="translated">생성 된 C ++ 소스 파일의 이름은 XML 파일의 이름을 &lt;code&gt;orgexamplechatinterface.h&lt;/code&gt; . &lt;code&gt;org.example.chat.xml&lt;/code&gt; 파일의 경우 생성 된 헤더의 이름은 orgexamplechatinterface.h 입니다.</target>
        </trans-unit>
        <trans-unit id="2ce806c47a73feca4587dd6c721c5907a8d81666" translate="yes" xml:space="preserve">
          <source>The generated code can be included in your application and used directly from it. Alternatively, you can use it to extend subclasses of standard widgets.</source>
          <target state="translated">생성 된 코드는 애플리케이션에 포함되어 직접 사용할 수 있습니다. 또는이를 사용하여 표준 위젯의 서브 클래스를 확장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b1c2851cbd436891e0d9589e3653cb036b1ab27e" translate="yes" xml:space="preserve">
          <source>The generated file will be an HTML file using Qt documentation style.</source>
          <target state="translated">생성 된 파일은 Qt 문서 스타일을 사용하는 HTML 파일입니다.</target>
        </trans-unit>
        <trans-unit id="265c450972b403ed94a277e745c2781820397392" translate="yes" xml:space="preserve">
          <source>The generated file(s) will be of the form &lt;code&gt;rep_&amp;lt;replica file base&amp;gt;_replica.h&lt;/code&gt;.</source>
          <target state="translated">생성 된 파일은 &lt;code&gt;rep_&amp;lt;replica file base&amp;gt;_replica.h&lt;/code&gt; 형식 입니다.</target>
        </trans-unit>
        <trans-unit id="52991daf216ff415d5a2838cca7023b05097683b" translate="yes" xml:space="preserve">
          <source>The generated file(s) will be of the form &lt;code&gt;rep_&amp;lt;replica file base&amp;gt;_source.h&lt;/code&gt;.</source>
          <target state="translated">생성 된 파일은 &lt;code&gt;rep_&amp;lt;replica file base&amp;gt;_source.h&lt;/code&gt; 형식 입니다.</target>
        </trans-unit>
        <trans-unit id="3c0b026ed6d96c103189deeec223aed1cfff15b8" translate="yes" xml:space="preserve">
          <source>The generated flag in each field of</source>
          <target state="translated">의 각 필드에서 생성 된 플래그</target>
        </trans-unit>
        <trans-unit id="43bb01b271640e7f06ab24e49b3dd9eb3d694d41" translate="yes" xml:space="preserve">
          <source>The generated keys will have the form</source>
          <target state="translated">생성 된 키의 형태는</target>
        </trans-unit>
        <trans-unit id="19bf04e4788cc748784e14059647379eb65a954e" translate="yes" xml:space="preserve">
          <source>The generated namespace will declare all enumerations, as well as one &lt;a href=&quot;qaxobject&quot;&gt;QAxObject&lt;/a&gt; subclass for each &lt;code&gt;coclass&lt;/code&gt; and &lt;code&gt;interface&lt;/code&gt; declared in the type library. coclasses marked with the &lt;code&gt;control&lt;/code&gt; attribute will be wrapped by a &lt;a href=&quot;qaxwidget&quot;&gt;QAxWidget&lt;/a&gt; subclass.</source>
          <target state="translated">생성 된 네임 스페이스는 모든 열거 형 과 형식 라이브러리에 선언 된 각 &lt;code&gt;coclass&lt;/code&gt; 및 &lt;code&gt;interface&lt;/code&gt; 대한 하나의 &lt;a href=&quot;qaxobject&quot;&gt;QAxObject&lt;/a&gt; 서브 클래스를 선언합니다. &lt;code&gt;control&lt;/code&gt; 속성으로 표시된 코 클래스 는 &lt;a href=&quot;qaxwidget&quot;&gt;QAxWidget&lt;/a&gt; 서브 클래스에 의해 랩핑됩니다 .</target>
        </trans-unit>
        <trans-unit id="f409bdeaf2e501f5468e4a9d0dea03eb25f63a25" translate="yes" xml:space="preserve">
          <source>The generated outlines will extend approximately 50% of</source>
          <target state="translated">생성 된 아웃 라인은 약 50 %의</target>
        </trans-unit>
        <trans-unit id="b84b5ab2308ddd12f3b2ee60c4ca19fa1364a21a" translate="yes" xml:space="preserve">
          <source>The generated path should only be used for outlining the given painter path. Otherwise it may cause unexpected behavior. Generated outlines also require the &lt;a href=&quot;qt#FillRule-enum&quot;&gt;Qt::WindingFill&lt;/a&gt; rule which is set by default.</source>
          <target state="translated">생성 된 패스는 지정된 페인터 패스의 윤곽을 그리는 데만 사용해야합니다. 그렇지 않으면 예기치 않은 동작이 발생할 수 있습니다. 생성 된 아웃 라인에는 기본적으로 설정된 &lt;a href=&quot;qt#FillRule-enum&quot;&gt;Qt :: WindingFill&lt;/a&gt; 규칙 도 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="88945bed7ca86f709cfc89d91b5dacf22e9c8e9b" translate="yes" xml:space="preserve">
          <source>The generation of mipmaps to above</source>
          <target state="translated">위의 밉맵 생성</target>
        </trans-unit>
        <trans-unit id="73d5f3e89a898530d72ccb667f94313c0051fda2" translate="yes" xml:space="preserve">
          <source>The generic algorithms can be used on other container classes than those provided by Qt and STL. The syntax of STL-style iterators is modeled after C++ pointers, so it's possible to use plain arrays as containers and plain pointers as iterators. A common idiom is to use qBinaryFind() together with two static arrays: one that contains a list of keys, and another that contains a list of associated values. For example, the following code will look up an HTML entity (e.g., &lt;code&gt;&amp;amp;amp&lt;/code&gt;;) in the &lt;code&gt;name_table&lt;/code&gt; array and return the corresponding Unicode value from the &lt;code&gt;value_table&lt;/code&gt; if the entity is recognized:</source>
          <target state="translated">Qt 및 STL에서 제공하는 것 이외의 다른 컨테이너 클래스에서 일반 알고리즘을 사용할 수 있습니다. STL 스타일 반복자의 구문은 C ++ 포인터를 기반으로 모델링되므로 일반 배열을 컨테이너로 사용하고 일반 포인터를 반복자로 사용할 수 있습니다. 일반적인 관용구는 qBinaryFind ()를 두 개의 정적 배열과 함께 사용하는 것입니다. 하나는 키 목록을 포함하고 다른 하나는 관련 값 목록을 포함합니다. 예를 들어, 다음 코드는 &lt;code&gt;name_table&lt;/code&gt; 배열 에서 HTML 엔티티 (예 : &lt;code&gt;&amp;amp;amp&lt;/code&gt; ;)를 &lt;code&gt;value_table&lt;/code&gt; 하고 엔티티가 인식되면 value_table 에서 해당 유니 코드 값을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="b13d7d4fd7478bfaf08ea84cc4eaa8239667d40b" translate="yes" xml:space="preserve">
          <source>The generic form of a JavaScript resource import is as follows:</source>
          <target state="translated">JavaScript 리소스 가져 오기의 일반적인 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3b614d8f4f55588afbe9db5a31e8485e08ff8e58" translate="yes" xml:space="preserve">
          <source>The generic form of a directory import is as follows:</source>
          <target state="translated">디렉토리 가져 오기의 일반적인 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3cc317f8d2137826746e39665d5ae70642ffc0b9" translate="yes" xml:space="preserve">
          <source>The generic form of a module import is as follows:</source>
          <target state="translated">모듈 가져 오기의 일반적인 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="79ca6f29c8a5c95eac89d2de30a5985f58057db7" translate="yes" xml:space="preserve">
          <source>The generic form of the various imports are as follows:</source>
          <target state="translated">다양한 수입품의 일반적인 형태는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="731ef9246ea04be556e2242081e0ccb81b4470ab" translate="yes" xml:space="preserve">
          <source>The generic sensor backend provides emulation of some of the sensors that are not supported on the platform. For example, on a platform without a rotation sensor but with an accelerometer, the accelerometer is used to calculate the rotation, thus providing an emulated rotation sensor.</source>
          <target state="translated">일반 센서 백엔드는 플랫폼에서 지원되지 않는 일부 센서를 에뮬레이션합니다. 예를 들어, 회전 센서가없고 가속도계가있는 플랫폼에서는 가속도계를 사용하여 회전을 계산하여 에뮬레이트 된 회전 센서를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="8faaab0677ddbdc2b097d102e4beaae11fd65221" translate="yes" xml:space="preserve">
          <source>The generic, driver independent solution for OpenGL. Uses the same CPU-based triangulation approach as &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt;'s OpenGL 2 paint engine. This is the default on non-NVIDIA hardware when the default, OpenGL Qt Quick scenegraph backend is in use.</source>
          <target state="translated">OpenGL을위한 일반적인 드라이버 독립적 솔루션. &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; 의 OpenGL 2 페인트 엔진 과 동일한 CPU 기반 삼각 측량 방식을 사용합니다 . 기본 OpenGL Qt Quick 장면 그래프 백엔드를 사용하는 경우 비 NVIDIA 하드웨어의 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="bd24cc2020dd9c6da0017e8c2d6a2cebdc29aedb" translate="yes" xml:space="preserve">
          <source>The genre of the media.</source>
          <target state="translated">미디어의 장르.</target>
        </trans-unit>
        <trans-unit id="d38f03aefe2e599d8bf8e0d2f4d708c2679d609a" translate="yes" xml:space="preserve">
          <source>The geo coordinate is valid if the &lt;a href=&quot;qgeocoordinate#longitude&quot;&gt;longitude&lt;/a&gt; and &lt;a href=&quot;qgeocoordinate#latitude&quot;&gt;latitude&lt;/a&gt; properties have been set to valid values.</source>
          <target state="translated">&lt;a href=&quot;qgeocoordinate#longitude&quot;&gt;경도&lt;/a&gt; 및 &lt;a href=&quot;qgeocoordinate#latitude&quot;&gt;위도&lt;/a&gt; 속성이 유효한 값으로 설정된 경우 지리 좌표가 유효합니다.</target>
        </trans-unit>
        <trans-unit id="521e74d1f9c3bd24a5e69507a347abfbb63b1e73" translate="yes" xml:space="preserve">
          <source>The geocoding features are called from a higher level piece of code. In this snippet we see an &lt;a href=&quot;qml-qtpositioning-address&quot;&gt;Address&lt;/a&gt; object filled with the desired parameters.</source>
          <target state="translated">지오 코딩 기능은 상위 수준의 코드에서 호출됩니다. 이 스 니펫 에는 원하는 매개 변수로 채워진 &lt;a href=&quot;qml-qtpositioning-address&quot;&gt;Address&lt;/a&gt; 객체가 있습니다.</target>
        </trans-unit>
        <trans-unit id="ac650ab7a8656f20157a21811e2676f7990b5ba0" translate="yes" xml:space="preserve">
          <source>The geocoding manager that was used did not have a &lt;a href=&quot;qgeocodingmanagerengine&quot;&gt;QGeoCodingManagerEngine&lt;/a&gt; instance associated with it.</source>
          <target state="translated">사용 된 지오 코딩 관리자에 연결된 &lt;a href=&quot;qgeocodingmanagerengine&quot;&gt;QGeoCodingManagerEngine&lt;/a&gt; 인스턴스 가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="abde68ea3bc75c9cc86e500f833e5182d24a8e7d" translate="yes" xml:space="preserve">
          <source>The geographic region displayed in the Map item is referred to as its viewport, and this is defined by the properties &lt;a href=&quot;qml-qtlocation-map#center-prop&quot;&gt;center&lt;/a&gt;, and &lt;a href=&quot;qml-qtlocation-map#zoomLevel-prop&quot;&gt;zoomLevel&lt;/a&gt;. The &lt;a href=&quot;qml-qtlocation-map#center-prop&quot;&gt;center&lt;/a&gt; property contains a &lt;a href=&quot;qml-coordinate&quot;&gt;coordinate&lt;/a&gt; specifying the center of the viewport, while &lt;a href=&quot;qml-qtlocation-map#zoomLevel-prop&quot;&gt;zoomLevel&lt;/a&gt; controls the scale of the map. See each of these properties for further details about their values.</source>
          <target state="translated">지도 항목에 표시되는 지리적 영역을 뷰포트라고하며 속성 &lt;a href=&quot;qml-qtlocation-map#center-prop&quot;&gt;센터&lt;/a&gt; 및 &lt;a href=&quot;qml-qtlocation-map#zoomLevel-prop&quot;&gt;zoomLevel에&lt;/a&gt; 의해 정의됩니다 . &lt;a href=&quot;qml-qtlocation-map#center-prop&quot;&gt;센터&lt;/a&gt; 숙박 시설은 포함 된 &lt;a href=&quot;qml-coordinate&quot;&gt;좌표&lt;/a&gt; 하면서, 뷰포트의 중심을 지정 &lt;a href=&quot;qml-qtlocation-map#zoomLevel-prop&quot;&gt;개의 zoomLevel은&lt;/a&gt; 지도의 크기를 제어합니다. 해당 값에 대한 자세한 내용은 각 속성을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4478ac8af2a32d8d77a81d7923269a64801c7145" translate="yes" xml:space="preserve">
          <source>The geometry is identified with unique name, which is used by the engine to distinguish different models. Instances of same custom geometry type with different parameters should specify different unique id. The name can be used with &lt;a href=&quot;qml-qtquick3d-model#source-prop&quot;&gt;model source&lt;/a&gt; to share the same geometry with different models.</source>
          <target state="translated">지오메트리는 엔진에서 다른 모델을 구별하는 데 사용하는 고유 한 이름으로 식별됩니다. 매개 변수가 다른 동일한 사용자 지오메트리 유형의 인스턴스는 다른 고유 ID를 지정해야합니다. 이름을 &lt;a href=&quot;qml-qtquick3d-model#source-prop&quot;&gt;모델 소스&lt;/a&gt; 와 함께 사용 하여 다른 모델과 동일한 형상을 공유 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f6abc4a16728a73021b636806076fcfa904dd01d" translate="yes" xml:space="preserve">
          <source>The geometry is in relation to the virtualGeometry() of its screen.</source>
          <target state="translated">지오메트리는 화면의 virtualGeometry ()와 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="49e829f0e16c6706fdd9b4e0807e34f3fad22ca9" translate="yes" xml:space="preserve">
          <source>The geometry is normalized by the font's pointSize, so a larger pointSize will result in smoother, rather than larger, text. pixelSize should not be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05a53b20add9f0b323c4e3e8e9074286a2e3f6cd" translate="yes" xml:space="preserve">
          <source>The geometry is null by default.</source>
          <target state="translated">기하 도형은 기본적으로 null입니다.</target>
        </trans-unit>
        <trans-unit id="f85b833299b4ed05a4f52b0e40369abdd019ca1a" translate="yes" xml:space="preserve">
          <source>The geometry node supports two types of materials, the &lt;a href=&quot;qsggeometrynode#opaqueMaterial&quot;&gt;opaqueMaterial&lt;/a&gt; and the normal material. The &lt;a href=&quot;qsggeometrynode#opaqueMaterial&quot;&gt;opaqueMaterial&lt;/a&gt; is used when the accumulated scene graph opacity at the time of rendering is 1. The primary use case is to special case opaque rendering to avoid an extra operation in the fragment shader can have significant performance impact on embedded graphics chips. The opaque material is optional.</source>
          <target state="translated">지오메트리 노드는 두 가지 유형의 재질 인 &lt;a href=&quot;qsggeometrynode#opaqueMaterial&quot;&gt;opaqueMaterial&lt;/a&gt; 과 일반 재질을 지원합니다. &lt;a href=&quot;qsggeometrynode#opaqueMaterial&quot;&gt;opaqueMaterial는&lt;/a&gt; 렌더링시의 축적 된 장면 그래프 불투명도가 주요 사용 사례가 내장 된 그래픽 칩의 성능이 크게 영향을 미칠 수 프래그먼트 쉐이더에서 추가 작업을 피하기 위해 렌더링 불투명 특별한 경우에 1. 경우에 사용된다. 불투명 재질은 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="34883a45e654738fad36b8b49152a24edfbcc0a9" translate="yes" xml:space="preserve">
          <source>The geometry of a &lt;a href=&quot;qsggeometrynode&quot;&gt;QSGGeometryNode&lt;/a&gt; has changed.</source>
          <target state="translated">&lt;a href=&quot;qsggeometrynode&quot;&gt;QSGGeometryNode&lt;/a&gt; 의 기하학 이 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="0ae72c5661a5a4d9a26cffbe82f8f241875beada" translate="yes" xml:space="preserve">
          <source>The geometry of the &lt;a href=&quot;qml-qtquick-controls2-control#contentItem-prop&quot;&gt;contentItem&lt;/a&gt; is determined by the padding. The following example reserves 10px padding between the boundaries of the control and its content:</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-controls2-control#contentItem-prop&quot;&gt;contentItem&lt;/a&gt; 의 지오메트리 는 패딩에 의해 결정됩니다. 다음 예제는 컨트롤의 경계와 내용 사이에 10px 패딩을 예약합니다.</target>
        </trans-unit>
        <trans-unit id="21b37f8d148bb1bc427755e64b6f86e669b4374a" translate="yes" xml:space="preserve">
          <source>The geometry of the &lt;a href=&quot;qml-qtquick-controls2-popup#contentItem-prop&quot;&gt;contentItem&lt;/a&gt; is determined by the padding. The following example reserves 10px padding between the boundaries of the popup and its content:</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-controls2-popup#contentItem-prop&quot;&gt;contentItem&lt;/a&gt; 의 지오메트리 는 패딩에 의해 결정됩니다. 다음 예제는 팝업 경계와 컨텐츠 경계 사이에 10px 패딩을 예약합니다.</target>
        </trans-unit>
        <trans-unit id="41a0ae52cdaf6cff29cfdc7ceda557199bf6db60" translate="yes" xml:space="preserve">
          <source>The geometry of the newly inserted widget will be the same as the widget it replaces. Its visible and collapsed states are also inherited.</source>
          <target state="translated">새로 삽입 된 위젯의 지오메트리는 대체하는 위젯과 동일합니다. 눈에 보이는 상태와 접힌 상태도 상속됩니다.</target>
        </trans-unit>
        <trans-unit id="aedfbb06a96b74638f997ad8735746c7ea2afccf" translate="yes" xml:space="preserve">
          <source>The geometry to be rendered with a flat color material requires vertices in attribute location 0 in the &lt;a href=&quot;qsggeometry&quot;&gt;QSGGeometry&lt;/a&gt; object to render correctly. The &lt;a href=&quot;qsggeometry#defaultAttributes_Point2D&quot;&gt;QSGGeometry::defaultAttributes_Point2D&lt;/a&gt;() returns an attribute set compatible with this material.</source>
          <target state="translated">플랫 컬러 재질로 렌더링 할 형상은 &lt;a href=&quot;qsggeometry&quot;&gt;QSGGeometry&lt;/a&gt; 객체 의 속성 위치 0에 정점이 있어야 올바르게 렌더링됩니다. &lt;a href=&quot;qsggeometry#defaultAttributes_Point2D&quot;&gt;QSGGeometry :: defaultAttributes_Point2D은&lt;/a&gt; ()이 물질과 호환 속성 세트를 돌려줍니다.</target>
        </trans-unit>
        <trans-unit id="92112628508ad9444e8ce854ec94f960b1f5b681" translate="yes" xml:space="preserve">
          <source>The geometry to be rendered with a texture material requires vertices in attribute location 0 and texture coordinates in attribute location 1. The texture coordinate is a 2-dimensional floating-point tuple. The &lt;a href=&quot;qsggeometry#defaultAttributes_TexturedPoint2D&quot;&gt;QSGGeometry::defaultAttributes_TexturedPoint2D&lt;/a&gt; returns an attribute set compatible with this material.</source>
          <target state="translated">텍스처 재질로 렌더링 할 형상은 속성 위치 0에 정점과 속성 위치 1에 텍스처 좌표가 필요합니다. 텍스처 좌표는 2 차원 부동 소수점 튜플입니다. &lt;a href=&quot;qsggeometry#defaultAttributes_TexturedPoint2D&quot;&gt;QSGGeometry :: defaultAttributes_TexturedPoint2D은&lt;/a&gt; 이 자료와 호환 속성 세트를 돌려줍니다.</target>
        </trans-unit>
        <trans-unit id="aa2e70cb0f466ecc796f189137490fb2bdd45577" translate="yes" xml:space="preserve">
          <source>The geometry to be rendered with an opaque texture material requires vertices in attribute location 0 and texture coordinates in attribute location 1. The texture coordinate is a 2-dimensional floating-point tuple. The &lt;a href=&quot;qsggeometry#defaultAttributes_TexturedPoint2D&quot;&gt;QSGGeometry::defaultAttributes_TexturedPoint2D&lt;/a&gt; returns an attribute set compatible with this material.</source>
          <target state="translated">불투명 텍스처 재질로 렌더링 할 형상에는 속성 위치 0의 정점과 속성 위치 1의 텍스처 좌표가 필요합니다. 텍스처 좌표는 2 차원 부동 소수점 튜플입니다. &lt;a href=&quot;qsggeometry#defaultAttributes_TexturedPoint2D&quot;&gt;QSGGeometry :: defaultAttributes_TexturedPoint2D은&lt;/a&gt; 이 자료와 호환 속성 세트를 돌려줍니다.</target>
        </trans-unit>
        <trans-unit id="07f713db99d3380a340d008a1f4d8e0ec25c3be2" translate="yes" xml:space="preserve">
          <source>The geometry to be rendered with vertex color must have the following layout. Attribute position 0 must contain vertices. Attribute position 1 must contain colors, a tuple of 4 values with RGBA layout. Both floats in the range of 0 to 1 and unsigned bytes in the range 0 to 255 are valid for the color values.</source>
          <target state="translated">꼭짓점 색상으로 렌더링 할 지오메트리에는 다음 레이아웃이 있어야합니다. 속성 위치 0은 꼭짓점을 포함해야합니다. 속성 위치 1에는 RGBA 레이아웃의 4 가지 값의 튜플 인 색상이 포함되어야합니다. 0-1 범위의 부동 소수점과 0-255 범위의 부호없는 바이트는 색상 값에 유효합니다.</target>
        </trans-unit>
        <trans-unit id="c9bffdaa90bd0eae1b8b2005b465c320deb14a17" translate="yes" xml:space="preserve">
          <source>The geometry, size hint, and size policy affect the item's size and position. Calling &lt;a href=&quot;qgraphicslayoutitem#setGeometry&quot;&gt;setGeometry&lt;/a&gt;() will always resize and reposition the item immediately. Normally, this function is called by &lt;a href=&quot;graphicsview#qgraphicslayout&quot;&gt;QGraphicsLayout&lt;/a&gt; after the layout has been activated, but it can also be called by the item's user at any time.</source>
          <target state="translated">도형, 크기 힌트 및 크기 정책은 항목의 크기와 위치에 영향을줍니다. &lt;a href=&quot;qgraphicslayoutitem#setGeometry&quot;&gt;setGeometry&lt;/a&gt; ()를 호출 하면 항상 항목의 크기가 조정되고 위치가 변경됩니다. 일반적으로이 기능은 레이아웃이 활성화 된 후 &lt;a href=&quot;graphicsview#qgraphicslayout&quot;&gt;QGraphicsLayout에&lt;/a&gt; 의해 호출 되지만 언제든지 항목 사용자가 호출 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e6cd9029d4de8c46796cfd954de029510c8ac550" translate="yes" xml:space="preserve">
          <source>The geoservice provider library could not be loaded. Setting &lt;a href=&quot;plugins-howto&quot;&gt;QT_DEBUG_PLUGINS&lt;/a&gt; environment variable may help diagnosing the problem.</source>
          <target state="translated">지오 서비스 제공자 라이브러리를로드 할 수 없습니다. &lt;a href=&quot;plugins-howto&quot;&gt;QT_DEBUG_PLUGINS&lt;/a&gt; 환경 변수를 설정 하면 문제점을 진단하는 데 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4bdc51d526ee68f5d859dbabfa7546d1fbc305d" translate="yes" xml:space="preserve">
          <source>The gesture had no motion associated with it on a particular axis.</source>
          <target state="translated">제스처는 특정 축에서 동작과 관련이 없습니다.</target>
        </trans-unit>
        <trans-unit id="5a9b82502fc5330bcffa6609a455336dfc9dc5e1" translate="yes" xml:space="preserve">
          <source>The gesture has been finished successfully and the appropriate &lt;a href=&quot;qgesture&quot;&gt;QGesture&lt;/a&gt; object will be delivered to the target as a part of a &lt;a href=&quot;qgestureevent&quot;&gt;QGestureEvent&lt;/a&gt;.</source>
          <target state="translated">제스처가 성공적으로 완료되었고 적절한 &lt;a href=&quot;qgesture&quot;&gt;QGesture의&lt;/a&gt; 목적은 (A)의 일부로서 대상에게 전달 될 것이다 &lt;a href=&quot;qgestureevent&quot;&gt;QGestureEvent&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bf3b6d879f738e80b8e3f430ea3e11117478ad1b" translate="yes" xml:space="preserve">
          <source>The gesture has been triggered and the appropriate &lt;a href=&quot;qgesture&quot;&gt;QGesture&lt;/a&gt; object will be delivered to the target as a part of a &lt;a href=&quot;qgestureevent&quot;&gt;QGestureEvent&lt;/a&gt;.</source>
          <target state="translated">제스처는 트리거 된 적절한 &lt;a href=&quot;qgesture&quot;&gt;QGesture의&lt;/a&gt; 목적은 (A)의 일부로서 대상에게 전달 될 것이다 &lt;a href=&quot;qgestureevent&quot;&gt;QGestureEvent&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="718465547921e7d2562bbaaf17d158b0bc3549df" translate="yes" xml:space="preserve">
          <source>The gesture involved a downward vertical motion.</source>
          <target state="translated">제스처는 아래로 수직으로 움직였습니다.</target>
        </trans-unit>
        <trans-unit id="44437247a6ecf59ace2d6119286c882f3b9f297b" translate="yes" xml:space="preserve">
          <source>The gesture involved a horizontal motion to the left.</source>
          <target state="translated">제스처는 왼쪽으로 수평으로 움직였습니다.</target>
        </trans-unit>
        <trans-unit id="3a934b8f6910f65d0c3cf761cf9d5119a86a3cf3" translate="yes" xml:space="preserve">
          <source>The gesture involved a horizontal motion to the right.</source>
          <target state="translated">제스처는 오른쪽으로 수평으로 움직였습니다.</target>
        </trans-unit>
        <trans-unit id="60f4268d8bcf7393a6fd80479fc4eaf93f8f059a" translate="yes" xml:space="preserve">
          <source>The gesture involved an upward vertical motion.</source>
          <target state="translated">제스처는 위쪽으로 수직으로 움직였습니다.</target>
        </trans-unit>
        <trans-unit id="f956401628719f5cf62d4c534a9fee0a176d4e44" translate="yes" xml:space="preserve">
          <source>The gesture object also includes information on the current set of &lt;code&gt;touchPoints&lt;/code&gt; and the &lt;code&gt;dragThreshold&lt;/code&gt;.</source>
          <target state="translated">제스처는 또한 오브젝트의 현재 세트에 대한 정보를 포함하는 &lt;code&gt;touchPoints&lt;/code&gt; 및 &lt;code&gt;dragThreshold&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="9d42f142d23e8f4fac054b7e54de1878137d59b7" translate="yes" xml:space="preserve">
          <source>The gesture object may be delivered to the target object in a &lt;a href=&quot;qgestureevent&quot;&gt;QGestureEvent&lt;/a&gt; if the corresponding gesture is active or has just been canceled. Each event that is delivered contains a list of gesture objects, since support for more than one gesture may be enabled for the target object. Due to the way events are handled in Qt, gesture events may be filtered by other objects.</source>
          <target state="translated">해당 제스처가 활성화되었거나 방금 취소 된 경우 제스처 객체는 &lt;a href=&quot;qgestureevent&quot;&gt;QGestureEvent&lt;/a&gt; 에서 대상 객체로 전달 될 수 있습니다 . 전달되는 각 이벤트에는 제스처 객체 목록이 포함되어 있습니다. 대상 객체에 대해 둘 이상의 제스처 지원이 활성화되어 있기 때문입니다. Qt에서 이벤트가 처리되는 방식으로 인해 제스처 이벤트가 다른 객체에 의해 필터링 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7d52c525e563ea4e8f309aa11f10944356b4525" translate="yes" xml:space="preserve">
          <source>The gesture recognizer will only trigger on left mouse button events.</source>
          <target state="translated">제스처 인식기는 마우스 왼쪽 버튼 이벤트에서만 트리거됩니다.</target>
        </trans-unit>
        <trans-unit id="de19ccf024c557b59f24cdf32d8883c58b2f06bb" translate="yes" xml:space="preserve">
          <source>The gesture recognizer will only trigger on middle mouse button events.</source>
          <target state="translated">제스처 인식기는 마우스 가운데 버튼 이벤트에서만 트리거됩니다.</target>
        </trans-unit>
        <trans-unit id="c969105e1687bf96c5d4eeab930f8aebdf02244c" translate="yes" xml:space="preserve">
          <source>The gesture recognizer will only trigger on right mouse button events.</source>
          <target state="translated">제스처 인식기는 마우스 오른쪽 버튼 이벤트에서만 트리거됩니다.</target>
        </trans-unit>
        <trans-unit id="490146936443c80a0ec377272cde3a5ff404e0ba" translate="yes" xml:space="preserve">
          <source>The gesture recognizer will only trigger on touch events. Specifically it will react on single touch points when using a touch screen and dual touch points when using a touchpad.</source>
          <target state="translated">제스처 인식기는 터치 이벤트에서만 트리거됩니다. 특히 터치 스크린을 사용할 때는 단일 터치 점과 터치 패드를 사용할 때는 이중 터치 점에서 반응합니다.</target>
        </trans-unit>
        <trans-unit id="d10177835ae5454db07d664da5f0eb0d83240223" translate="yes" xml:space="preserve">
          <source>The gestures are either active or canceled. A list of those that are currently being executed can be obtained using the &lt;a href=&quot;qgestureevent#activeGestures&quot;&gt;activeGestures&lt;/a&gt;() function. A list of those which were previously active and have been canceled can be accessed using the &lt;a href=&quot;qgestureevent#canceledGestures&quot;&gt;canceledGestures&lt;/a&gt;() function. A gesture might be canceled if the current window loses focus, for example, or because of a timeout, or for other reasons.</source>
          <target state="translated">제스처가 활성화 또는 취소되었습니다. &lt;a href=&quot;qgestureevent#activeGestures&quot;&gt;activeGestures&lt;/a&gt; () 함수를 사용하여 현재 실행중인 목록을 얻을 수 있습니다 . 이전에 활성화되어 취소 된 목록은 &lt;a href=&quot;qgestureevent#canceledGestures&quot;&gt;canceledGestures&lt;/a&gt; () 함수를 사용하여 액세스 할 수 있습니다 . 현재 창에 포커스가없는 경우 (예 : 시간 초과 또는 기타 이유로) 제스처가 취소 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0842de2ad754c637198f0055756cc8e5d1a9f046" translate="yes" xml:space="preserve">
          <source>The given</source>
          <target state="translated">주어진</target>
        </trans-unit>
        <trans-unit id="b4f522b7abf42132284c8a57731b648460016eae" translate="yes" xml:space="preserve">
          <source>The given &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; does not have &lt;a href=&quot;qobject#objectName-prop&quot;&gt;objectName&lt;/a&gt;() set.</source>
          <target state="translated">지정된 &lt;a href=&quot;qobject&quot;&gt;QObject에 &lt;/a&gt;&lt;a href=&quot;qobject#objectName-prop&quot;&gt;objectName&lt;/a&gt; ()이 설정되어 있지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="c07ad0dddb0056d948f092f04c1c5a1deec17038" translate="yes" xml:space="preserve">
          <source>The given &lt;a href=&quot;qremoteobjectnode&quot;&gt;QRemoteObjectNode&lt;/a&gt; is not a host node.</source>
          <target state="translated">지정된 &lt;a href=&quot;qremoteobjectnode&quot;&gt;QRemoteObjectNode&lt;/a&gt; 가 호스트 노드가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="c6bd16805738b0a7ec4e88b7d2eb38ae31b22abc" translate="yes" xml:space="preserve">
          <source>The given QRemoteObjectSource is not registered on this node.</source>
          <target state="translated">주어진 QRemoteObjectSource가이 노드에 등록되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e10b0eadab407095319888109d3d71cd0d2ed78a" translate="yes" xml:space="preserve">
          <source>The given input data could not be used to construct a &lt;a href=&quot;qssldiffiehellmanparameters&quot;&gt;QSslDiffieHellmanParameters&lt;/a&gt; object.</source>
          <target state="translated">지정된 입력 데이터를 사용하여 &lt;a href=&quot;qssldiffiehellmanparameters&quot;&gt;QSslDiffieHellmanParameters&lt;/a&gt; 오브젝트 를 구성 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="48f4c89f2e0e949da236f91fc64066d8df6755a5" translate="yes" xml:space="preserve">
          <source>The given invert</source>
          <target state="translated">주어진 반전</target>
        </trans-unit>
        <trans-unit id="1db20d31436ea4055119b617edef38fd66b6bb6e" translate="yes" xml:space="preserve">
          <source>The given url has an invalid or unrecognized scheme.</source>
          <target state="translated">지정된 URL에 유효하지 않거나 인식 할 수없는 체계가 있습니다.</target>
        </trans-unit>
        <trans-unit id="563e72e52bda9996536fff859f4f922a1933f144" translate="yes" xml:space="preserve">
          <source>The given window</source>
          <target state="translated">주어진 창</target>
        </trans-unit>
        <trans-unit id="03a9f8d30da2da6f73a1771cea761f0d69b4524d" translate="yes" xml:space="preserve">
          <source>The glass material has the following properties:</source>
          <target state="translated">유리 재질에는 다음과 같은 특성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="75381847bd366b731aeecca5438e2f0b967716d9" translate="yes" xml:space="preserve">
          <source>The global &lt;code&gt;qApp&lt;/code&gt; pointer refers to this application object. Only one application object should be created.</source>
          <target state="translated">전역 &lt;code&gt;qApp&lt;/code&gt; 포인터는이 응용 프로그램 객체를 나타냅니다. 하나의 응용 프로그램 개체 만 만들어야합니다.</target>
        </trans-unit>
        <trans-unit id="98486003ade2d880c8983a0cb919aa713a433fc3" translate="yes" xml:space="preserve">
          <source>The global declarations include &lt;a href=&quot;qtglobal#types&quot;&gt;types&lt;/a&gt;, &lt;a href=&quot;qtglobal#functions&quot;&gt;functions&lt;/a&gt; and &lt;a href=&quot;qtglobal#macros&quot;&gt;macros&lt;/a&gt;.</source>
          <target state="translated">전역 선언에는 &lt;a href=&quot;qtglobal#types&quot;&gt;유형&lt;/a&gt; , &lt;a href=&quot;qtglobal#functions&quot;&gt;함수&lt;/a&gt; 및 &lt;a href=&quot;qtglobal#macros&quot;&gt;매크로가 포함&lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="293d6b65f02aebb00d6143f69704636476ead1f9" translate="yes" xml:space="preserve">
          <source>The global position is relative to the screen or virtual desktop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc7e33f2d465dc9ea415a523f453e6f1b68d072d" translate="yes" xml:space="preserve">
          <source>The global position of the layout. This is independent of the bounding rectangle and of the layout process.</source>
          <target state="translated">레이아웃의 글로벌 위치입니다. 이것은 경계 사각형 및 레이아웃 프로세스와 무관합니다.</target>
        </trans-unit>
        <trans-unit id="350a2b08e24849df59e21ba9d99f6b34999835f5" translate="yes" xml:space="preserve">
          <source>The glossiness of a surface depends on how smooth or irregular the surface is. A smooth surface will have a more intense light reflection then a rough surface, where the light reflection will be more spread out. In the Default material the material's glossiness is controlled through the &lt;a href=&quot;qml-qtquick3d-defaultmaterial#roughnessMap-prop&quot;&gt;roughness&lt;/a&gt; property.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b331fcf6a3a2940fee3a90c7ef2a7cc1c3b6aa64" translate="yes" xml:space="preserve">
          <source>The glow is created by blurring the image live using a gaussian blur. Performing blur live is a costly operation. Fullscreen gaussian blur with even a moderate number of samples will only run at 60 fps on highend graphics hardware.</source>
          <target state="translated">가우시안 블러를 사용하여 이미지를 실시간으로 흐리게 처리하여 글로우를 만듭니다. 블러 라이브를 수행하는 것은 비용이 많이 드는 작업입니다. 적당한 수의 샘플로도 전체 화면 가우시안 블러는 고급 그래픽 하드웨어에서 60fps로만 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="e00718d2768b75232708baf4f0d628143b167b83" translate="yes" xml:space="preserve">
          <source>The goal of this module is to provide a way to handle different authentication methods present on the Internet.</source>
          <target state="translated">이 모듈의 목표는 인터넷에 존재하는 다양한 인증 방법을 처리하는 방법을 제공하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="2f588cceeb1582ba4a09d77f704ee502a25fe039" translate="yes" xml:space="preserve">
          <source>The grab happens asynchronously and the JavaScript function</source>
          <target state="translated">횡령은 비동기 적으로 발생하고 JavaScript 기능</target>
        </trans-unit>
        <trans-unit id="6b3ec38fb2e7f0a6d60e459c79b965af0bc2af2c" translate="yes" xml:space="preserve">
          <source>The grab happens asynchronously and the signal &lt;a href=&quot;qquickitemgrabresult#ready&quot;&gt;QQuickItemGrabResult::ready&lt;/a&gt;() is emitted when the grab has been completed.</source>
          <target state="translated">그랩은 비동기 적으로 발생 하며 그랩이 완료되면 &lt;a href=&quot;qquickitemgrabresult#ready&quot;&gt;QQuickItemGrabResult :: ready&lt;/a&gt; () 신호 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="96804a79dab6eae0067e67eba5b2573d09177c55" translate="yes" xml:space="preserve">
          <source>The grabWindow() function grabs pixels from the screen, not from the window, i.e. if there is another window partially or entirely over the one you grab, you get pixels from the overlying window, too. The mouse cursor is generally not grabbed.</source>
          <target state="translated">grabWindow () 함수는 윈도우가 아닌 화면에서 픽셀을 가져옵니다. 즉, 다른 윈도우가 부분적으로 또는 전체적으로 잡고있는 윈도우 위에 있으면 위에있는 윈도우에서도 픽셀을 가져옵니다. 마우스 커서는 일반적으로 잡히지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c7c7e867a112dd5227e43fdabbbe02dd361931e7" translate="yes" xml:space="preserve">
          <source>The grabbed position within the scene</source>
          <target state="translated">장면 내에서 잡힌 위치</target>
        </trans-unit>
        <trans-unit id="cb8332871f881c410421f933a3c0301ee32e1afa" translate="yes" xml:space="preserve">
          <source>The gradient coordinates can be specified in logical coordinates, relative to device coordinates, or relative to object bounding box coordinates. The &lt;a href=&quot;qgradient#CoordinateMode-enum&quot;&gt;coordinate mode&lt;/a&gt; can be set using the &lt;a href=&quot;qgradient#setCoordinateMode&quot;&gt;setCoordinateMode&lt;/a&gt;() function. The default is &lt;a href=&quot;qgradient#CoordinateMode-enum&quot;&gt;LogicalMode&lt;/a&gt;, where the gradient coordinates are specified in the same way as the object coordinates. To retrieve the currently set &lt;a href=&quot;qgradient#CoordinateMode-enum&quot;&gt;coordinate mode&lt;/a&gt; use &lt;a href=&quot;qgradient#coordinateMode&quot;&gt;coordinateMode&lt;/a&gt;().</source>
          <target state="translated">그라디언트 좌표는 논리적 좌표, 장치 좌표 또는 객체 경계 상자 좌표를 기준으로 지정할 수 있습니다. &lt;a href=&quot;qgradient#CoordinateMode-enum&quot;&gt;좌표 모드&lt;/a&gt; 은 USING 설정할 수 &lt;a href=&quot;qgradient#setCoordinateMode&quot;&gt;setCoordinateMode&lt;/a&gt; () 함수. 기본값은 &lt;a href=&quot;qgradient#CoordinateMode-enum&quot;&gt;LogicalMode&lt;/a&gt; 이며, 여기서 그라디언트 좌표는 객체 좌표와 같은 방식으로 지정됩니다. 현재 설정되어있는 검색하려면 &lt;a href=&quot;qgradient#CoordinateMode-enum&quot;&gt;좌표 모드&lt;/a&gt; 사용 &lt;a href=&quot;qgradient#coordinateMode&quot;&gt;coordinateMode을&lt;/a&gt; ().</target>
        </trans-unit>
        <trans-unit id="110a03717fc27b950a5eddb42db6f526fd080e32" translate="yes" xml:space="preserve">
          <source>The gradient is reflected outside the gradient area.</source>
          <target state="translated">그라디언트는 그라디언트 영역 외부에 반영됩니다.</target>
        </trans-unit>
        <trans-unit id="50a894de0fb7093b5140abf4c44905a588d69374" translate="yes" xml:space="preserve">
          <source>The gradient is repeated outside the gradient area.</source>
          <target state="translated">그라디언트는 그라디언트 영역 외부에서 반복됩니다.</target>
        </trans-unit>
        <trans-unit id="3781fc8686e48c86f3663a14ece9da6d58ca4348" translate="yes" xml:space="preserve">
          <source>The gradient of the progress bar around the button.</source>
          <target state="translated">버튼 주위의 진행률 표시 줄의 그라디언트입니다.</target>
        </trans-unit>
        <trans-unit id="25bd5675762b447cfeb94861b8b988e093dea852" translate="yes" xml:space="preserve">
          <source>The gradient that is displayed on the checked state indicator.</source>
          <target state="translated">확인 된 상태 표시기에 표시되는 그라디언트.</target>
        </trans-unit>
        <trans-unit id="2a4a346bb6a6f54c79832f26a1baad8372551751" translate="yes" xml:space="preserve">
          <source>The gradient that is displayed on the inactive state indicator. The inactive state indicator will be the checked gradient when the button is unchecked, and the unchecked gradient when the button is checked.</source>
          <target state="translated">비활성 상태 표시기에 표시되는 그라디언트. 비활성 상태 표시기는 버튼을 선택하지 않은 경우 그라디언트를 확인하고 버튼을 선택하면 그라디언트를 선택하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="47a2db9ad00a26241c98f588799d03496e37d742" translate="yes" xml:space="preserve">
          <source>The gradient that is displayed on the unchecked state indicator.</source>
          <target state="translated">확인되지 않은 상태 표시기에 표시되는 그라디언트.</target>
        </trans-unit>
        <trans-unit id="625f876bcd7d9043c8cfbaf7be9889c1bca481a2" translate="yes" xml:space="preserve">
          <source>The gradient to use to fill the rectangle.</source>
          <target state="translated">사각형을 채우는 데 사용할 그라디언트.</target>
        </trans-unit>
        <trans-unit id="2bbf387d6186f96d3f2e748fe5859c5cb22d47bd" translate="yes" xml:space="preserve">
          <source>The granularity is used by &lt;a href=&quot;qgraphicsitem#boundingRegion&quot;&gt;boundingRegion&lt;/a&gt;() to calculate how fine the bounding region of the item should be. The highest achievable granularity is 1, where &lt;a href=&quot;qgraphicsitem#boundingRegion&quot;&gt;boundingRegion&lt;/a&gt;() will return the finest outline possible for the respective device (e.g., for a &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; viewport, this gives you a pixel-perfect bounding region). The lowest possible granularity is 0. The value of</source>
          <target state="translated">입도는 &lt;a href=&quot;qgraphicsitem#boundingRegion&quot;&gt;boundingRegion&lt;/a&gt; ()에서 항목의 경계 영역이 얼마나 미세해야 하는지를 계산하는 데 사용됩니다 . 달성 가능한 최고 입도는 1이며, &lt;a href=&quot;qgraphicsitem#boundingRegion&quot;&gt;boundingRegion&lt;/a&gt; ()은 각 장치에 대해 가능한 최고의 윤곽을 반환합니다 (예 : &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; 뷰포트의 경우 픽셀에 완벽한 경계 영역을 제공함). 가능한 가장 작은 입도는 0입니다.</target>
        </trans-unit>
        <trans-unit id="77c30a8852767ce18f08813ecfd760abcb9f242f" translate="yes" xml:space="preserve">
          <source>The graphic commands makes it possible to include images in the documentation. The images can be rendered as separate paragraphs, or within running text.</source>
          <target state="translated">그래픽 명령을 사용하면 설명서에 이미지를 포함시킬 수 있습니다. 이미지는 별도의 단락으로 또는 실행중인 텍스트 내에서 렌더링 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="34e552a1553256af691d11774037b1253b121be5" translate="yes" xml:space="preserve">
          <source>The graphics anchor provides an API that enables you to query and manipulate the properties an anchor has. When an anchor is added to the layout with &lt;a href=&quot;qgraphicsanchorlayout#addAnchor&quot;&gt;QGraphicsAnchorLayout::addAnchor&lt;/a&gt;(), a &lt;a href=&quot;qgraphicsanchor&quot;&gt;QGraphicsAnchor&lt;/a&gt; instance is returned where the properties are initialized to their default values. The properties can then be further changed, and they will be picked up the next time the layout is activated.</source>
          <target state="translated">그래픽 앵커는 앵커의 속성을 쿼리하고 조작 할 수있는 API를 제공합니다. &lt;a href=&quot;qgraphicsanchorlayout#addAnchor&quot;&gt;QGraphicsAnchorLayout :: addAnchor&lt;/a&gt; () 를 사용하여 앵커를 레이아웃에 추가 하면 속성이 기본값으로 초기화되는 &lt;a href=&quot;qgraphicsanchor&quot;&gt;QGraphicsAnchor&lt;/a&gt; 인스턴스가 반환됩니다. 그런 다음 속성을 추가로 변경할 수 있으며 다음에 레이아웃이 활성화 될 때 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="e4664b85815cc9e41fcc0a1eb8f2ea3d4c40db4b" translate="yes" xml:space="preserve">
          <source>The graphics anchor provides an API that enables you to query and manipulate the properties an anchor has. When an anchor is added to the layout with &lt;a href=&quot;qgraphicsanchorlayout#addAnchor&quot;&gt;QGraphicsAnchorLayout::addAnchor&lt;/a&gt;(), a QGraphicsAnchor instance is returned where the properties are initialized to their default values. The properties can then be further changed, and they will be picked up the next time the layout is activated.</source>
          <target state="translated">그래픽 앵커는 앵커의 속성을 쿼리하고 조작 할 수있는 API를 제공합니다. &lt;a href=&quot;qgraphicsanchorlayout#addAnchor&quot;&gt;QGraphicsAnchorLayout :: addAnchor&lt;/a&gt; () 를 사용하여 앵커가 레이아웃에 추가 되면 속성이 기본값으로 초기화되는 QGraphicsAnchor 인스턴스가 반환됩니다. 그런 다음 속성을 추가로 변경할 수 있으며 다음에 레이아웃이 활성화 될 때 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="7960a03584d1a63c74beff68541d05113b62d129" translate="yes" xml:space="preserve">
          <source>The graphics command queue used by the scenegraph, when applicable.</source>
          <target state="translated">해당되는 경우 장면 그래프에서 사용되는 그래픽 명령 대기열.</target>
        </trans-unit>
        <trans-unit id="cf52124f2937d467aba7dc2a9d246125947b1eaf" translate="yes" xml:space="preserve">
          <source>The graphics context used for rendering the scene graph will be bound at this point.</source>
          <target state="translated">장면 그래프를 렌더링하는 데 사용되는 그래픽 컨텍스트는이 시점에서 바인딩됩니다.</target>
        </trans-unit>
        <trans-unit id="61fba740b3fdc526325000c312da308a11562de9" translate="yes" xml:space="preserve">
          <source>The graphics device, when applicable.</source>
          <target state="translated">해당되는 경우 그래픽 장치.</target>
        </trans-unit>
        <trans-unit id="a0e0cd3c38929f0bfb416bf98882a4217bcf4458" translate="yes" xml:space="preserve">
          <source>The graphicsEffect function returns a pointer to the widget's graphics effect.</source>
          <target state="translated">graphicsEffect 함수는 위젯의 그래픽 효과에 대한 포인터를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="821f23f84e20ec8971ca9b3a38a116cd448cbede" translate="yes" xml:space="preserve">
          <source>The gray value is calculated using the formula (</source>
          <target state="translated">회색 값은 공식을 사용하여 계산됩니다 (</target>
        </trans-unit>
        <trans-unit id="2587b92bc1abbcc0d8fe66063766379c4e5ed79c" translate="yes" xml:space="preserve">
          <source>The gray value is calculated using the formula (R * 11 + G * 16 + B * 5)/32; the alpha-channel is ignored.</source>
          <target state="translated">그레이 값은 공식 (R * 11 + G * 16 + B * 5) / 32; 알파 채널은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="8c5874bfbf44048b7c58b47e41bac315f47117fc" translate="yes" xml:space="preserve">
          <source>The greediness of the quantifiers is inverted: &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;?&lt;/code&gt;, &lt;code&gt;{m,n}&lt;/code&gt;, etc. become lazy, while their lazy versions (&lt;code&gt;*?&lt;/code&gt;, &lt;code&gt;+?&lt;/code&gt;, &lt;code&gt;??&lt;/code&gt;, &lt;code&gt;{m,n}?&lt;/code&gt;, etc.) become greedy. There is no equivalent for this option in Perl regular expressions.</source>
          <target state="translated">: 수량 지시의 탐욕은 반전 &lt;code&gt;*&lt;/code&gt; 를 , &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;?&lt;/code&gt; , &lt;code&gt;{m,n}&lt;/code&gt; 그 지연 버전 (상태 등이 지연 될 &lt;code&gt;*?&lt;/code&gt; , &lt;code&gt;+?&lt;/code&gt; , &lt;code&gt;??&lt;/code&gt; , &lt;code&gt;{m,n}?&lt;/code&gt; 등) 욕심된다. Perl 정규식에는이 옵션에 해당하는 것이 없습니다.</target>
        </trans-unit>
        <trans-unit id="84e7916e8ad9348d1c19de0e0c087296eb58fc91" translate="yes" xml:space="preserve">
          <source>The green component. Equivalent to GL_TEXTURE_SWIZZLE_G</source>
          <target state="translated">녹색 구성 요소. GL_TEXTURE_SWIZZLE_G와 동일</target>
        </trans-unit>
        <trans-unit id="0af09da258a5eb2d3e119878e6b093c4f79b3ee7" translate="yes" xml:space="preserve">
          <source>The green rectangle has no x,y specified, so its position defaults to (0,0). Because it is at (0,0) in the coordinates of its parent, the blue rectangle, it is positioned at the top left corner of that rectangle. This is the same point as the white dot at (100,100) in the coordinates of the red rectangle.</source>
          <target state="translated">녹색 사각형에는 x, y가 지정되어 있지 않으므로 기본 위치는 (0,0)입니다. 부모의 좌표 인 파란색 사각형에서 (0,0)에 있기 때문에 해당 사각형의 왼쪽 위 모서리에 위치합니다. 이것은 빨간색 사각형의 좌표에서 (100,100)의 흰색 점과 같은 점입니다.</target>
        </trans-unit>
        <trans-unit id="c8d5485c522b6e55d38832b70917c6dfc9601395" translate="yes" xml:space="preserve">
          <source>The grip can be styled be using the &lt;a href=&quot;#image-prop&quot;&gt;image&lt;/a&gt; property. The arrow indicators can by styled using the &lt;a href=&quot;#left-arrow-sub&quot;&gt;::left-arrow&lt;/a&gt; subcontrol and the &lt;a href=&quot;#right-arrow-sub&quot;&gt;::right-arrow&lt;/a&gt; subcontrol.</source>
          <target state="translated">&lt;a href=&quot;#image-prop&quot;&gt;이미지&lt;/a&gt; 속성을 사용하여 그립 스타일을 지정할 수 있습니다 . 화살표 표시기는 &lt;a href=&quot;#left-arrow-sub&quot;&gt;:: left-arrow&lt;/a&gt; 하위 컨트롤과 &lt;a href=&quot;#right-arrow-sub&quot;&gt;:: right-arrow&lt;/a&gt; 하위 컨트롤을 사용하여 스타일을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d668fbdc06b2b34487d08beeb7682d38499730b7" translate="yes" xml:space="preserve">
          <source>The grip can be styled be using the &lt;a href=&quot;stylesheet-reference#image-prop&quot;&gt;image&lt;/a&gt; property. The arrow indicators can by styled using the &lt;a href=&quot;stylesheet-reference#left-arrow-sub&quot;&gt;::left-arrow&lt;/a&gt; subcontrol and the &lt;a href=&quot;stylesheet-reference#right-arrow-sub&quot;&gt;::right-arrow&lt;/a&gt; subcontrol.</source>
          <target state="translated">그립은 &lt;a href=&quot;stylesheet-reference#image-prop&quot;&gt;image&lt;/a&gt; 속성을 사용하여 스타일을 지정할 수 있습니다 . 화살표 표시기는 &lt;a href=&quot;stylesheet-reference#left-arrow-sub&quot;&gt;:: left-arrow&lt;/a&gt; 하위 컨트롤과 &lt;a href=&quot;stylesheet-reference#right-arrow-sub&quot;&gt;:: right-arrow&lt;/a&gt; 하위 컨트롤을 사용하여 스타일을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dddd465a668b84ce059b835ddf398a1526876892" translate="yes" xml:space="preserve">
          <source>The groove for the dial.</source>
          <target state="translated">다이얼의 홈.</target>
        </trans-unit>
        <trans-unit id="b4a52e963d8b2706ec8ab83802f31c0bdafa81f7" translate="yes" xml:space="preserve">
          <source>The groove of a &lt;a href=&quot;qslider&quot;&gt;QSlider&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qslider&quot;&gt;QSlider&lt;/a&gt; 의 홈 .</target>
        </trans-unit>
        <trans-unit id="ea0a11da6e2b8a40d3779641a5237e53417dc486" translate="yes" xml:space="preserve">
          <source>The groove of the slider is styled using the &lt;a href=&quot;#groove-sub&quot;&gt;::groove&lt;/a&gt;. The groove is positioned by default in the Contents rectangle of the widget. The thumb of the slider is styled using &lt;a href=&quot;#handle-sub&quot;&gt;::handle&lt;/a&gt; subcontrol. The subcontrol moves in the Contents rectangle of the groove subcontrol.</source>
          <target state="translated">슬라이더의 홈은 &lt;a href=&quot;#groove-sub&quot;&gt;:: groove를&lt;/a&gt; 사용하여 스타일이 지정됩니다 . 홈은 기본적으로 위젯의 목차 사각형에 위치합니다. 슬라이더의 썸은 &lt;a href=&quot;#handle-sub&quot;&gt;:: handle&lt;/a&gt; 하위 컨트롤을 사용하여 스타일이 지정됩니다 . 하위 제어는 홈 하위 제어의 목차 사각형에서 이동합니다.</target>
        </trans-unit>
        <trans-unit id="73bb64a0662a4a760537ae4546237445cf57e3fa" translate="yes" xml:space="preserve">
          <source>The groove of the slider is styled using the &lt;a href=&quot;stylesheet-reference#groove-sub&quot;&gt;::groove&lt;/a&gt;. The groove is positioned by default in the Contents rectangle of the widget. The thumb of the slider is styled using &lt;a href=&quot;stylesheet-reference#handle-sub&quot;&gt;::handle&lt;/a&gt; subcontrol. The subcontrol moves in the Contents rectangle of the groove subcontrol.</source>
          <target state="translated">슬라이더의 홈은 &lt;a href=&quot;stylesheet-reference#groove-sub&quot;&gt;:: groove를&lt;/a&gt; 사용하여 스타일이 지정됩니다 . 홈은 기본적으로 위젯의 콘텐츠 사각형에 배치됩니다. 슬라이더의 엄지는 &lt;a href=&quot;stylesheet-reference#handle-sub&quot;&gt;:: handle&lt;/a&gt; 하위 컨트롤을 사용하여 스타일이 지정됩니다 . 서브 컨트롤이 groove 서브 컨트롤의 Contents 사각형으로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="9ad9b5928666e99a1a11649086e0b67ac6e6d733" translate="yes" xml:space="preserve">
          <source>The groove where the progress indicator is drawn in a &lt;a href=&quot;qprogressbar&quot;&gt;QProgressBar&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qprogressbar&quot;&gt;QProgressBar&lt;/a&gt; 에서 진행률 표시기가 그려지는 그루브 .</target>
        </trans-unit>
        <trans-unit id="5abe808670e745da552c0d2d39c0478df47a64b7" translate="yes" xml:space="preserve">
          <source>The ground speed, in meters/sec.</source>
          <target state="translated">지상 속도 (미터 / 초)</target>
        </trans-unit>
        <trans-unit id="2cb8f47d03de5a7daab9c01416eff322fbcc1c06" translate="yes" xml:space="preserve">
          <source>The group box contents.</source>
          <target state="translated">그룹 상자 내용.</target>
        </trans-unit>
        <trans-unit id="8cc3584f33f46427b87b8d4baa7205b2ea2c0c7b" translate="yes" xml:space="preserve">
          <source>The group box title text will have a keyboard shortcut if the title contains an ampersand ('&amp;amp;') followed by a letter.</source>
          <target state="translated">제목에 앰퍼샌드 ( '&amp;amp;')와 문자가 있으면 그룹 상자 제목 텍스트에 바로 가기 키가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b1b935236032fa684027716e143e4a844123a69a" translate="yes" xml:space="preserve">
          <source>The group in</source>
          <target state="translated">의 그룹</target>
        </trans-unit>
        <trans-unit id="919bbd0c7df784f9407b75b2b5e16679febe12b0" translate="yes" xml:space="preserve">
          <source>The group is exclusive if the &lt;a href=&quot;qactiongroup#ExclusionPolicy-enum&quot;&gt;ExclusionPolicy&lt;/a&gt; is either Exclusive or ExclusionOptional.</source>
          <target state="translated">&lt;a href=&quot;qactiongroup#ExclusionPolicy-enum&quot;&gt;ExclusionPolicy&lt;/a&gt; 가 Exclusive 또는 ExclusionOptional 인 경우 그룹은 배타적 입니다.</target>
        </trans-unit>
        <trans-unit id="6936a051fb631cbf87dc7f47ad82ceabbc579dd1" translate="yes" xml:space="preserve">
          <source>The grouping commands relate classes to defined groups and modules. The groups are used when generating lists of related classes in the documentation, while the modules are elements of Qt's structure.</source>
          <target state="translated">그룹화 명령은 클래스를 정의 된 그룹 및 모듈과 관련시킵니다. 그룹은 문서에서 관련 클래스 목록을 생성 할 때 사용되는 반면 모듈은 Qt 구조의 요소입니다.</target>
        </trans-unit>
        <trans-unit id="04bf6dd4d5fe99abc711013c6b1714b5107aad60" translate="yes" xml:space="preserve">
          <source>The handle (slider) of a &lt;a href=&quot;qscrollbar&quot;&gt;QScrollBar&lt;/a&gt;, a &lt;a href=&quot;qsplitter&quot;&gt;QSplitter&lt;/a&gt;, or a &lt;a href=&quot;qslider&quot;&gt;QSlider&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qscrollbar&quot;&gt;QScrollBar&lt;/a&gt; , &lt;a href=&quot;qsplitter&quot;&gt;QSplitter&lt;/a&gt; 또는 &lt;a href=&quot;qslider&quot;&gt;QSlider&lt;/a&gt; 의 핸들 (슬라이더)입니다 .</target>
        </trans-unit>
        <trans-unit id="fd60b952b0b3e78070d10076646117b89b78bd1f" translate="yes" xml:space="preserve">
          <source>The handle (to move the toolbar) is styled using the &lt;a href=&quot;#handle-sub&quot;&gt;::handle&lt;/a&gt; subcontrol.</source>
          <target state="translated">&lt;a href=&quot;#handle-sub&quot;&gt;:: handle&lt;/a&gt; 하위 컨트롤을 사용하여 도구 모음을 이동하는 핸들의 스타일이 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="47ecfe944fffa5b0a5d99ca80bd8e158ae7f6008" translate="yes" xml:space="preserve">
          <source>The handle (to move the toolbar) is styled using the &lt;a href=&quot;stylesheet-reference#handle-sub&quot;&gt;::handle&lt;/a&gt; subcontrol.</source>
          <target state="translated">도구 모음을 이동하기 &lt;a href=&quot;stylesheet-reference#handle-sub&quot;&gt;위한 핸들&lt;/a&gt; 은 :: handle 하위 컨트롤을 사용하여 스타일이 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="5d9c9d10b385f6c69ee74cc9a89f6a6ce883c9f5" translate="yes" xml:space="preserve">
          <source>The handle acts as a visual indicator of the position of the dial.</source>
          <target state="translated">핸들은 다이얼 위치의 시각적 표시기 역할을합니다.</target>
        </trans-unit>
        <trans-unit id="5144c6a512c58293712f828acb10df737eeca3c1" translate="yes" xml:space="preserve">
          <source>The handle contains pointer to &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; CIImage.</source>
          <target state="translated">핸들에는 &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; CIImage에 대한 포인터가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6f7a58bfe51f616a8adbcc5eef8c090c8624b191" translate="yes" xml:space="preserve">
          <source>The handle contains pointer to macOS CIImage.</source>
          <target state="translated">핸들에는 macOS CIImage에 대한 포인터가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="bbb87ce288e3d7c1f8179591c25269f20a86e42e" translate="yes" xml:space="preserve">
          <source>The handle contains pointer to shared memory XVideo image.</source>
          <target state="translated">핸들에는 공유 메모리 XVideo 이미지에 대한 포인터가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ebc8065a10d21bc09d37174601fea2298c07bff" translate="yes" xml:space="preserve">
          <source>The handle is automatically positioned within the dial, based on the &lt;a href=&quot;qml-qtquick-controls-styles-dialstyle#handleInset-prop&quot;&gt;handleInset&lt;/a&gt; and the implicit width and height of the handle itself.</source>
          <target state="translated">핸들은 &lt;a href=&quot;qml-qtquick-controls-styles-dialstyle#handleInset-prop&quot;&gt;handleInset&lt;/a&gt; 과 핸들 자체의 암시 적 너비와 높이에 따라 다이얼 내에 자동으로 배치 됩니다.</target>
        </trans-unit>
        <trans-unit id="0cdfba6e839a50201fe6d728a4aafe309410cd0f" translate="yes" xml:space="preserve">
          <source>The handle is being dragged.</source>
          <target state="translated">핸들을 끌고 있습니다.</target>
        </trans-unit>
        <trans-unit id="bcdb5e289d7dd1e94d4c7a6bcb271053fbce36a5" translate="yes" xml:space="preserve">
          <source>The handle is being hovered.</source>
          <target state="translated">핸들을 가리키고 있습니다.</target>
        </trans-unit>
        <trans-unit id="48b1052c474401606b4714214437319f38229d8c" translate="yes" xml:space="preserve">
          <source>The handle is being pressed.</source>
          <target state="translated">핸들을 누르고 있습니다.</target>
        </trans-unit>
        <trans-unit id="8983a23c28fb8ce1de81b0259cfece282a0cfba2" translate="yes" xml:space="preserve">
          <source>The handle of a toolbar.</source>
          <target state="translated">툴바의 핸들입니다.</target>
        </trans-unit>
        <trans-unit id="54b9a7ead8e552a613ab30bb5bcc4f96d97e0f8c" translate="yes" xml:space="preserve">
          <source>The handle of the buffer is a &lt;a href=&quot;qpixmap&quot;&gt;QPixmap&lt;/a&gt;.</source>
          <target state="translated">버퍼의 핸들은 &lt;a href=&quot;qpixmap&quot;&gt;QPixmap&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="acb4a2475b7a37adf2ef2f9b6f4c1ccf4197a6c0" translate="yes" xml:space="preserve">
          <source>The handle of the buffer is an EGLImageKHR.</source>
          <target state="translated">버퍼의 핸들은 EGLImageKHR입니다.</target>
        </trans-unit>
        <trans-unit id="419a281b77cf5e9a1b221b087201d887acecc416" translate="yes" xml:space="preserve">
          <source>The handle of the buffer is an OpenGL texture ID.</source>
          <target state="translated">버퍼의 핸들은 OpenGL 텍스처 ID입니다.</target>
        </trans-unit>
        <trans-unit id="e1d58743949996e1fc4ef14341eea873d5b03e92" translate="yes" xml:space="preserve">
          <source>The handle of the dial (i.e. what you use to control the dial).</source>
          <target state="translated">다이얼의 핸들 (즉, 다이얼을 제어하는 ​​데 사용하는 것)</target>
        </trans-unit>
        <trans-unit id="d1549251d5c7bc12a773f9585d8c728403c663e0" translate="yes" xml:space="preserve">
          <source>The handle of the dial.</source>
          <target state="translated">다이얼의 핸들.</target>
        </trans-unit>
        <trans-unit id="77b196d1d41d9d005e47c16cac1a853790077568" translate="yes" xml:space="preserve">
          <source>The handle property will be updated once the renderer has created the underlying fence resource. The handle will remain valid as long as it remains in the unsignaled state. Once it has reached the signaled state, it will be destroyed and a new handle will be created. That means that depending on how long it takes for the fence to be signaled, the same handle could be used over several frames.</source>
          <target state="translated">렌더러가 기본 펜스 리소스를 생성하면 handle 속성이 업데이트됩니다. 핸들은 신호되지 않은 상태로 유지되는 한 유효합니다. 신호 상태에 도달하면 폐기되고 새 핸들이 생성됩니다. 즉, 울타리에 신호를 보내는 데 걸리는 시간에 따라 동일한 핸들을 여러 프레임에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c48321f495bd08a9c1fb0c67c154596e707f5bd" translate="yes" xml:space="preserve">
          <source>The handle returned here is database-dependent, you should query the type name of the variant before accessing it.</source>
          <target state="translated">여기에 반환 된 핸들은 데이터베이스에 따라 다르므로 액세스하기 전에 변형의 유형 이름을 쿼리해야합니다.</target>
        </trans-unit>
        <trans-unit id="59b4db653256b65a7fc9013849dfbad102eeb1a5" translate="yes" xml:space="preserve">
          <source>The handler does not care which modifiers are pressed.</source>
          <target state="translated">핸들러는 어떤 수정자를 눌렀는지 상관하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="76c19e5b1f1d38906a205d779f777c350ee977e7" translate="yes" xml:space="preserve">
          <source>The handler for these events is &lt;a href=&quot;qobject#childEvent&quot;&gt;QObject::childEvent&lt;/a&gt;().</source>
          <target state="translated">이러한 이벤트의 핸들러는 &lt;a href=&quot;qobject#childEvent&quot;&gt;QObject :: childEvent&lt;/a&gt; ()입니다.</target>
        </trans-unit>
        <trans-unit id="13e84d5531638ab3c6250a90eefd652702be0d1c" translate="yes" xml:space="preserve">
          <source>The handler is called when the widget's &lt;a href=&quot;qwidget#contextMenuPolicy-prop&quot;&gt;contextMenuPolicy&lt;/a&gt; is &lt;a href=&quot;qt#ContextMenuPolicy-enum&quot;&gt;Qt::DefaultContextMenu&lt;/a&gt;.</source>
          <target state="translated">핸들러는 &lt;a href=&quot;qwidget#contextMenuPolicy-prop&quot;&gt;contextContextPolicy&lt;/a&gt; 가 &lt;a href=&quot;qt#ContextMenuPolicy-enum&quot;&gt;Qt :: DefaultContextMenu 일&lt;/a&gt; 때 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="ade7e6dc5bbfc259b8853e759938d8492900000b" translate="yes" xml:space="preserve">
          <source>The handler is created with the parent</source>
          <target state="translated">핸들러는 부모와 함께 생성됩니다</target>
        </trans-unit>
        <trans-unit id="39f86c2d972d2a7780fb8f4037b9994ef56384d4" translate="yes" xml:space="preserve">
          <source>The handler should support being called multiple times for the same purchase. For example, the application execution might by accident be interrupted after saving the purchase information, but before finalizing the transaction. In this case, the handler should verify that the information is already stored in the persistent storage and then finalize the transaction.</source>
          <target state="translated">처리기는 동일한 구매에 대해 여러 번 호출되는 것을 지원해야합니다. 예를 들어, 구매 정보를 저장 한 후 트랜잭션을 완료하기 전에 실수로 응용 프로그램 실행이 중단 될 수 있습니다. 이 경우 처리기는 정보가 영구 저장소에 이미 저장되어 있는지 확인한 다음 트랜잭션을 마무리해야합니다.</target>
        </trans-unit>
        <trans-unit id="64bbee2d6b1a9c17abc1af00c4a6605eb522397d" translate="yes" xml:space="preserve">
          <source>The handwriting layout may also include &lt;a href=&quot;qml-qtquick-virtualkeyboard-changelanguagekey&quot;&gt;ChangeLanguageKey&lt;/a&gt;. For this purpose, it is important to use the &lt;a href=&quot;qml-qtquick-virtualkeyboard-changelanguagekey#customLayoutsOnly-prop&quot;&gt;customLayoutsOnly&lt;/a&gt; attribute, which will filter out languages that do not use handwriting.</source>
          <target state="translated">필기 레이아웃에는 &lt;a href=&quot;qml-qtquick-virtualkeyboard-changelanguagekey&quot;&gt;ChangeLanguageKey&lt;/a&gt; 도 포함될 수 있습니다 . 이를 위해 필기를 사용하지 않는 언어를 필터링 하는 &lt;a href=&quot;qml-qtquick-virtualkeyboard-changelanguagekey#customLayoutsOnly-prop&quot;&gt;customLayoutsOnly&lt;/a&gt; 속성 을 사용하는 것이 중요합니다 .</target>
        </trans-unit>
        <trans-unit id="4c29ce99e7b53563bc81552b6b4f51be6b22eb6f" translate="yes" xml:space="preserve">
          <source>The handwriting mode can be activated by pressing the handwriting key:</source>
          <target state="translated">필기 모드는 필기 키를 눌러 활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a25c98cd5df6cbaf15fd95734ab4c68c42a225c6" translate="yes" xml:space="preserve">
          <source>The hard minimum font size.</source>
          <target state="translated">하드 최소 글꼴 크기입니다.</target>
        </trans-unit>
        <trans-unit id="b5c13b7b9a740231a4b13bdb3e9b2b546ae56dc4" translate="yes" xml:space="preserve">
          <source>The harddrive icon.</source>
          <target state="translated">하드 드라이브 아이콘.</target>
        </trans-unit>
        <trans-unit id="8a2da3876986018e533656cec13a06df8b10f057" translate="yes" xml:space="preserve">
          <source>The hardware or platform is old and only supports X11; in which case you have no choice.</source>
          <target state="translated">하드웨어 또는 플랫폼이 오래되었으며 X11 만 지원합니다. 이 경우 선택의 여지가 없습니다.</target>
        </trans-unit>
        <trans-unit id="917a2436da3f29b504c1005546726069fe47137f" translate="yes" xml:space="preserve">
          <source>The hash value is independent of the order of elements in</source>
          <target state="translated">해시 값은 요소의 순서와 무관합니다.</target>
        </trans-unit>
        <trans-unit id="ab6c22a642edc1ad63815d46dd404d6b859b1115" translate="yes" xml:space="preserve">
          <source>The header displays ISO week numbers as described by &lt;a href=&quot;qdate#weekNumber&quot;&gt;QDate::weekNumber&lt;/a&gt;().</source>
          <target state="translated">헤더는 &lt;a href=&quot;qdate#weekNumber&quot;&gt;QDate :: weekNumber&lt;/a&gt; ()에 설명 된대로 ISO 주 번호를 표시합니다 .</target>
        </trans-unit>
        <trans-unit id="5d685bb6f33e24542f194a11a6fe08dea4f840f0" translate="yes" xml:space="preserve">
          <source>The header displays a short abbreviation for day names (e.g. Mon for Monday).</source>
          <target state="translated">머리글에는 요일 이름의 짧은 약어가 표시됩니다 (예 : 월요일은 월요일).</target>
        </trans-unit>
        <trans-unit id="966775cda2b251eeb1026160f450a1910e70c6ba" translate="yes" xml:space="preserve">
          <source>The header displays a single letter abbreviation for day names (e.g. M for Monday).</source>
          <target state="translated">머리글에는 요일 이름의 단일 문자 약어가 표시됩니다 (예 : 월요일의 경우 M).</target>
        </trans-unit>
        <trans-unit id="c1604785d3a78e2b2f5b73cc94e0a31f673d977a" translate="yes" xml:space="preserve">
          <source>The header displays complete day names (e.g. Monday).</source>
          <target state="translated">헤더에는 완전한 요일 이름 (예 : 월요일)이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="0b41191249ae3c7eee3462a44f9a4c31cf4d4e2e" translate="yes" xml:space="preserve">
          <source>The header displays data from the {&lt;a href=&quot;qml-qtquick-controls2-horizontalheaderview#syncView-prop&quot;&gt;syncView&lt;/a&gt;}'s model by default, but can also have its own model. If the model is a &lt;a href=&quot;qabstracttablemodel&quot;&gt;QAbstractTableModel&lt;/a&gt;, then the header will display the model's horizontal headerData(); otherwise, the model's data().</source>
          <target state="translated">헤더는 기본적으로 { &lt;a href=&quot;qml-qtquick-controls2-horizontalheaderview#syncView-prop&quot;&gt;syncView&lt;/a&gt; } 모델의 데이터를 표시 하지만 자체 모델을 가질 수도 있습니다. 모델이 &lt;a href=&quot;qabstracttablemodel&quot;&gt;QAbstractTableModel&lt;/a&gt; 이면 헤더에 모델의 수평 headerData (); 그렇지 않으면 모델의 data ().</target>
        </trans-unit>
        <trans-unit id="902925b75e904c648faab3f168213f8c11fa5e48" translate="yes" xml:space="preserve">
          <source>The header displays data from the {&lt;a href=&quot;qml-qtquick-controls2-verticalheaderview#syncView-prop&quot;&gt;syncView&lt;/a&gt;}'s model by default, but can also have its own model. If the model is a &lt;a href=&quot;qabstracttablemodel&quot;&gt;QAbstractTableModel&lt;/a&gt;, then the header will display the model's vertical headerData(); otherwise, the model's data().</source>
          <target state="translated">헤더는 기본적으로 { &lt;a href=&quot;qml-qtquick-controls2-verticalheaderview#syncView-prop&quot;&gt;syncView&lt;/a&gt; } 모델의 데이터를 표시 하지만 자체 모델을 가질 수도 있습니다. 모델이 &lt;a href=&quot;qabstracttablemodel&quot;&gt;QAbstractTableModel&lt;/a&gt; 이면 헤더에 모델의 수직 headerData (); 그렇지 않으면 모델의 data ().</target>
        </trans-unit>
        <trans-unit id="d36dba119c1ffbdf67d0ac0db959f00388c90e42" translate="yes" xml:space="preserve">
          <source>The header file &lt;code&gt;&amp;lt;QtGlobal&amp;gt;&lt;/code&gt; contains some debugging macros and &lt;code&gt;#define&lt;/code&gt;s.</source>
          <target state="translated">헤더 파일 &lt;code&gt;&amp;lt;QtGlobal&amp;gt;&lt;/code&gt; 에는 디버깅 매크로와 &lt;code&gt;#define&lt;/code&gt; 이 포함되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="eab5ec75d0c2883b104b8e4fa85468f11792c2a9" translate="yes" xml:space="preserve">
          <source>The header file associated with the</source>
          <target state="translated">관련 헤더 파일</target>
        </trans-unit>
        <trans-unit id="1f3a02d8311c0941ee3eacf121f058dd10862737" translate="yes" xml:space="preserve">
          <source>The header file declares several type definitions that guarantee a specified bit-size on all platforms supported by Qt for various basic types, for example &lt;a href=&quot;qtglobal#qint8-typedef&quot;&gt;qint8&lt;/a&gt; which is a signed char guaranteed to be 8-bit on all platforms supported by Qt. The header file also declares the &lt;a href=&quot;qtglobal#qlonglong-typedef&quot;&gt;qlonglong&lt;/a&gt; type definition for &lt;code&gt;long long int&lt;/code&gt; (&lt;code&gt;__int64&lt;/code&gt; on Windows).</source>
          <target state="translated">헤더 파일은 다양한 기본 유형에 대해 Qt에서 지원하는 모든 플랫폼에서 지정된 비트 크기를 보장하는 몇 가지 유형 정의를 선언합니다 (예 : Qt에서 지원하는 모든 플랫폼에서 8 비트로 보장되는 부호있는 문자 인 &lt;a href=&quot;qtglobal#qint8-typedef&quot;&gt;qint8)&lt;/a&gt; . 또한 헤더 파일은 &lt;code&gt;long long int&lt;/code&gt; ( Windows의 경우 &lt;code&gt;__int64&lt;/code&gt; ) 에 대한 &lt;a href=&quot;qtglobal#qlonglong-typedef&quot;&gt;qlonglong&lt;/a&gt; 유형 정의를 선언합니다 .</target>
        </trans-unit>
        <trans-unit id="6617750b2eb07db0651bc4fabf64619609e47dc4" translate="yes" xml:space="preserve">
          <source>The header file that must be included in applications that use this widget. This information is stored in UI files and will be used by &lt;code&gt;uic&lt;/code&gt; to create a suitable &lt;code&gt;#includes&lt;/code&gt; statement in the code it generates for the form containing the custom widget.</source>
          <target state="translated">이 위젯을 사용하는 애플리케이션에 포함되어야하는 헤더 파일입니다. 이 정보는 UI 파일에 저장되며 &lt;code&gt;uic&lt;/code&gt; 에서 사용자 정의 위젯이 포함 된 양식에 대해 생성 된 코드에 적절한 &lt;code&gt;#includes&lt;/code&gt; 문 을 작성하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="c499288542e52338c5d03219dba706dcabb0ab73" translate="yes" xml:space="preserve">
          <source>The header gets the data for each section from the model using the &lt;a href=&quot;qabstractitemmodel#headerData&quot;&gt;QAbstractItemModel::headerData&lt;/a&gt;() function. You can set the data by using &lt;a href=&quot;qabstractitemmodel#setHeaderData&quot;&gt;QAbstractItemModel::setHeaderData&lt;/a&gt;().</source>
          <target state="translated">헤더는 &lt;a href=&quot;qabstractitemmodel#headerData&quot;&gt;QAbstractItemModel :: headerData&lt;/a&gt; () 함수를 사용하여 모델에서 각 섹션의 데이터를 가져옵니다 . &lt;a href=&quot;qabstractitemmodel#setHeaderData&quot;&gt;QAbstractItemModel :: setHeaderData&lt;/a&gt; ()를 사용하여 데이터를 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0ea314ff332f4e360acc5e6eb5658b9d8d7b0afc" translate="yes" xml:space="preserve">
          <source>The header is hidden.</source>
          <target state="translated">헤더가 숨겨져 있습니다.</target>
        </trans-unit>
        <trans-unit id="8dfd4fd8ba7d77fc24ca3c8215f07df794b30e87" translate="yes" xml:space="preserve">
          <source>The header is positioned at the beginning of the view.</source>
          <target state="translated">헤더는보기의 시작 부분에 있습니다.</target>
        </trans-unit>
        <trans-unit id="c75ad54f34e717112435454f4d4578c52ddb3282" translate="yes" xml:space="preserve">
          <source>The header is positioned at the beginning of the view. The header can be pushed away by moving the content forwards, and pulled back by moving the content backwards.</source>
          <target state="translated">헤더는보기의 시작 부분에 있습니다. 콘텐츠를 앞으로 이동하면 헤더를 밀고 뒤로 이동하면 뒤로 당길 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b0b62d86e5d0263c9839d8d66fc2c9d6fce759ba" translate="yes" xml:space="preserve">
          <source>The header is rendered at the top of the generated documentation page.</source>
          <target state="translated">헤더는 생성 된 문서 페이지의 맨 위에 렌더링됩니다.</target>
        </trans-unit>
        <trans-unit id="cacbd744ad394f2cb2ebcf1d914dc3aa2406b9a3" translate="yes" xml:space="preserve">
          <source>The header sections are attached to values in the &lt;a href=&quot;qml-qtquick-controls-tableview#model-prop&quot;&gt;model&lt;/a&gt; by defining the model role they attach to. Each property in the model will then be shown in their corresponding column.</source>
          <target state="translated">헤더 부분은의 값에 부착 &lt;a href=&quot;qml-qtquick-controls-tableview#model-prop&quot;&gt;모델&lt;/a&gt; 들은 첨부 모델 역할을 정의하여. 그러면 모델의 각 속성이 해당 열에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="bd769fee6af9469de6403e241e05c25956697f58" translate="yes" xml:space="preserve">
          <source>The header sections are attached to values in the &lt;a href=&quot;qml-qtquick-controls-treeview#model-prop&quot;&gt;model&lt;/a&gt; by defining the model role they attach to. Each property in the model will then be shown in their corresponding column.</source>
          <target state="translated">헤더 부분은의 값에 부착 &lt;a href=&quot;qml-qtquick-controls-treeview#model-prop&quot;&gt;모델&lt;/a&gt; 들은 첨부 모델 역할을 정의하여. 그러면 모델의 각 속성이 해당 열에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="b75e4e130ffd089376ab8e7cbf68eadc5d13a41c" translate="yes" xml:space="preserve">
          <source>The header's label.</source>
          <target state="translated">헤더의 레이블입니다.</target>
        </trans-unit>
        <trans-unit id="d929b86b8be6c9adfd62ba62b7d340668c8f5418" translate="yes" xml:space="preserve">
          <source>The headers for the QVulkan classes may include &lt;code&gt;vulkan.h&lt;/code&gt; with &lt;code&gt;VK_NO_PROTOTYPES&lt;/code&gt; enabled. This can cause issues in C++ wrapper headers that rely on the prototypes. Hence in application code it may be necessary to include &lt;code&gt;vulkan.hpp&lt;/code&gt; or similar before any of the QVulkan headers.</source>
          <target state="translated">QVulkan 클래스의 헤더에는 &lt;code&gt;vulkan.h&lt;/code&gt; 가 활성화 된 vulkan.h 가 &lt;code&gt;VK_NO_PROTOTYPES&lt;/code&gt; 수 있습니다. 이로 인해 프로토 타입에 의존하는 C ++ 래퍼 헤더에 문제가 발생할 수 있습니다. 따라서 응용 프로그램 코드 에서는 QVulkan 헤더 앞에 &lt;code&gt;vulkan.hpp&lt;/code&gt; 등 을 포함해야 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="af759ad059e709296e4e2fc8931b9c2e40ae0394" translate="yes" xml:space="preserve">
          <source>The heartbeat (only helpful for socket connections) will periodically send a message to connected nodes to detect whether the connection was disrupted. Qt Remote Objects will try to reconnect automatically if it detects a dropped connection. This function can help with that detection since the client will only detect that the server is unavailable when it tries to send data.</source>
          <target state="translated">하트 비트 (소켓 연결에만 도움이 됨)는 연결이 중단되었는지 여부를 감지하기 위해 주기적으로 연결된 노드에 메시지를 보냅니다. Qt 원격 객체는 끊어진 연결을 감지하면 자동으로 다시 연결을 시도합니다. 이 기능은 클라이언트가 서버가 데이터를 보내려고 할 때 서버를 사용할 수 없다는 것을 감지하기 때문에 탐지에 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="e7fbdd72d90c12fa0ee1e89743e6ea134175f656" translate="yes" xml:space="preserve">
          <source>The height in pixels the &lt;a href=&quot;qml-qtquick-particles-trailemitter#emitShape-prop&quot;&gt;emitShape&lt;/a&gt; is scaled to. If set to &lt;a href=&quot;qml-qtquick-particles-trailemitter&quot;&gt;TrailEmitter&lt;/a&gt;.ParticleSize, the height will be the current size of the particle being followed.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-particles-trailemitter#emitShape-prop&quot;&gt;emitShape의&lt;/a&gt; 크기가 조절 되는 높이 (픽셀) 입니다. &lt;a href=&quot;qml-qtquick-particles-trailemitter&quot;&gt;TrailEmitter&lt;/a&gt; .ParticleSize로 설정하면 높이는 따라가는 입자의 현재 크기가됩니다.</target>
        </trans-unit>
        <trans-unit id="93b6a3d64efb146c7b9cc0eaae573379527394d2" translate="yes" xml:space="preserve">
          <source>The height is obtained from the first item in the view. It is updated when the data changes on that item.</source>
          <target state="translated">높이는 뷰의 첫 번째 항목에서 가져옵니다. 해당 항목의 데이터가 변경되면 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="cf7bea780348b6841b263895342e5daf98c5d38a" translate="yes" xml:space="preserve">
          <source>The height map is resolved asynchronously. &lt;a href=&quot;qsurfacedataproxy#arrayReset&quot;&gt;QSurfaceDataProxy::arrayReset&lt;/a&gt;() is emitted when the data has been resolved.</source>
          <target state="translated">높이 맵은 비동기 적으로 해결됩니다. 데이터가 분석되면 &lt;a href=&quot;qsurfacedataproxy#arrayReset&quot;&gt;QSurfaceDataProxy :: arrayReset&lt;/a&gt; ()이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2d183d6bf996fbe06f9ed6503ec595ed6d5309a3" translate="yes" xml:space="preserve">
          <source>The height of a split item with &lt;code&gt;fillHeight&lt;/code&gt; set to &lt;code&gt;true&lt;/code&gt; is still restricted within its &lt;a href=&quot;qml-qtquick-controls2-splitview#minimumHeight-attached-prop&quot;&gt;minimumHeight&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-controls2-splitview#maximumHeight-attached-prop&quot;&gt;maximumHeight&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;fillHeight&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 로 설정된 분할 항목의 높이는 여전히 &lt;a href=&quot;qml-qtquick-controls2-splitview#minimumHeight-attached-prop&quot;&gt;minimumHeight&lt;/a&gt; 및 &lt;a href=&quot;qml-qtquick-controls2-splitview#maximumHeight-attached-prop&quot;&gt;maximumHeight&lt;/a&gt; 내로 제한됩니다 .</target>
        </trans-unit>
        <trans-unit id="d39abfa59286bcc8517911adc6ca1263c10b560c" translate="yes" xml:space="preserve">
          <source>The height of a subcontrol (or in some case, a widget).</source>
          <target state="translated">하위 제어 (또는 경우에 따라 위젯)의 높이입니다.</target>
        </trans-unit>
        <trans-unit id="ac702dc261481dbe6a67f2dceec19cfa02febe73" translate="yes" xml:space="preserve">
          <source>The height of the</source>
          <target state="translated">높이</target>
        </trans-unit>
        <trans-unit id="ebf29444666b2b1799193c06df4fb702a1c88623" translate="yes" xml:space="preserve">
          <source>The height of the 3D texture defining the volume content in pixels. Defaults to &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">볼륨 내용을 픽셀 단위로 정의하는 3D 텍스처의 높이입니다. 기본값은 &lt;code&gt;0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4402ac92ed1e85e72b6ae0ea60ff9f5a859986c7" translate="yes" xml:space="preserve">
          <source>The height of the &lt;a href=&quot;qml-qtquick-controls2-splitview&quot;&gt;SplitView&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-controls2-splitview&quot;&gt;SplitView&lt;/a&gt; 높이입니다 .</target>
        </trans-unit>
        <trans-unit id="45ce0ee7e45c777d5bec4c41aa23d97cc967bb3d" translate="yes" xml:space="preserve">
          <source>The height of the bounding rectangle is at least as large as the value returned &lt;a href=&quot;qfontmetricsf#height&quot;&gt;height&lt;/a&gt;().</source>
          <target state="translated">경계 사각형의 높이는 최소한 반환 된 &lt;a href=&quot;qfontmetricsf#height&quot;&gt;높이&lt;/a&gt; () 값보다 큽니다 .</target>
        </trans-unit>
        <trans-unit id="a6f0f4063edb487c3068a4001f6262ebe56fcaf4" translate="yes" xml:space="preserve">
          <source>The height of the bounding rectangle is at least as large as the value returned by &lt;a href=&quot;qfontmetrics#height&quot;&gt;height&lt;/a&gt;().</source>
          <target state="translated">경계 사각형의 높이는 적어도 &lt;a href=&quot;qfontmetrics#height&quot;&gt;height&lt;/a&gt; ()에 의해 반환되는 값만큼 큽니다 .</target>
        </trans-unit>
        <trans-unit id="d019f22e96c50a3b2f1b0a18cdfe36bcbaccb5a4" translate="yes" xml:space="preserve">
          <source>The height of the image is read from the red component of the pixels if the image is in grayscale, otherwise it is an average calculated from red, green and blue components of the pixels. Using grayscale images may improve data conversion speed for large images.</source>
          <target state="translated">이미지가 회색조이면 이미지의 높이는 픽셀의 빨간색 구성 요소에서 읽습니다. 그렇지 않으면 픽셀의 빨간색, 녹색 및 파란색 구성 요소에서 계산 된 평균입니다. 그레이 스케일 이미지를 사용하면 큰 이미지의 데이터 변환 속도가 향상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="01c230044a1694f0543924672c559024ffd04fb8" translate="yes" xml:space="preserve">
          <source>The height of the optional spin box slider.</source>
          <target state="translated">선택적 스핀 상자 슬라이더의 높이입니다.</target>
        </trans-unit>
        <trans-unit id="f716716778abe345105464bda15c33d6f0000866" translate="yes" xml:space="preserve">
          <source>The height of the paint device in default coordinate system units (e.g. pixels for &lt;a href=&quot;qpixmap&quot;&gt;QPixmap&lt;/a&gt; and &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt;). See also &lt;a href=&quot;qpaintdevice#height&quot;&gt;height&lt;/a&gt;().</source>
          <target state="translated">기본 좌표계 단위 (예 : &lt;a href=&quot;qpixmap&quot;&gt;QPixmap&lt;/a&gt; 및 &lt;a href=&quot;qwidget&quot;&gt;QWidget의&lt;/a&gt; 픽셀)에서 페인트 장치의 높이입니다 . &lt;a href=&quot;qpaintdevice#height&quot;&gt;높이&lt;/a&gt; () 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a08270468bf48b96769f6ca858014966effcc468" translate="yes" xml:space="preserve">
          <source>The height of the paint device in default coordinate system units (e.g. pixels for &lt;a href=&quot;qpixmap&quot;&gt;QPixmap&lt;/a&gt; and &lt;a href=&quot;widgets-changes-qt6#qwidget&quot;&gt;QWidget&lt;/a&gt;). See also &lt;a href=&quot;qpaintdevice#height&quot;&gt;height&lt;/a&gt;().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6efd203d5e6a8ef2eb021e0c84fb87aed897cd2d" translate="yes" xml:space="preserve">
          <source>The height of the paint device in millimeters. See also &lt;a href=&quot;qpaintdevice#heightMM&quot;&gt;heightMM&lt;/a&gt;().</source>
          <target state="translated">페인트 장치의 높이 (밀리미터)입니다. &lt;a href=&quot;qpaintdevice#heightMM&quot;&gt;heightMM&lt;/a&gt; () 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8a1ddce1caaaff60a85fdd0b3705ac94926792d9" translate="yes" xml:space="preserve">
          <source>The height of the text content.</source>
          <target state="translated">텍스트 내용의 높이입니다.</target>
        </trans-unit>
        <trans-unit id="062cf6c0dfe9a35381aee5301ed0ba5f20e90566" translate="yes" xml:space="preserve">
          <source>The height of the weekday row is calculated based on the maximum implicit height of the delegates.</source>
          <target state="translated">요일 행의 높이는 대리자의 최대 암시 적 높이를 기준으로 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="251b1ebadb5b3172d46798a21d66b974b8c3c3ab" translate="yes" xml:space="preserve">
          <source>The height of the widget will be set to match the height of the scroll bar. To control the width of the widget, use &lt;a href=&quot;qwidget#minimumWidth-prop&quot;&gt;QWidget::setMinimumWidth&lt;/a&gt; and &lt;a href=&quot;qwidget#maximumWidth-prop&quot;&gt;QWidget::setMaximumWidth&lt;/a&gt;, or implement &lt;a href=&quot;qwidget#sizeHint-prop&quot;&gt;QWidget::sizeHint&lt;/a&gt;() and set a horizontal size policy. If you want a square widget, call &lt;a href=&quot;qstyle#pixelMetric&quot;&gt;QStyle::pixelMetric&lt;/a&gt;(&lt;a href=&quot;qstyle#PixelMetric-enum&quot;&gt;QStyle::PM_ScrollBarExtent&lt;/a&gt;) and set the width to this value.</source>
          <target state="translated">위젯의 높이는 스크롤 막대의 높이와 일치하도록 설정됩니다. 위젯의 너비를 제어하려면 &lt;a href=&quot;qwidget#minimumWidth-prop&quot;&gt;QWidget :: setMinimumWidth&lt;/a&gt; 및 &lt;a href=&quot;qwidget#maximumWidth-prop&quot;&gt;QWidget :: setMaximumWidth&lt;/a&gt; 를 사용하거나 &lt;a href=&quot;qwidget#sizeHint-prop&quot;&gt;QWidget :: sizeHint&lt;/a&gt; ()를 구현 하고 가로 크기 정책을 설정하십시오. 정사각형 위젯을 원하는 경우 &lt;a href=&quot;qstyle#pixelMetric&quot;&gt;QStyle :: pixelMetric&lt;/a&gt; ( &lt;a href=&quot;qstyle#PixelMetric-enum&quot;&gt;QStyle :: PM_ScrollBarExtent&lt;/a&gt; )을 호출 하고 너비를이 값으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="e059c42548baf7dc726a6440d57f4d208e764d08" translate="yes" xml:space="preserve">
          <source>The help collection file that &lt;a href=&quot;qhelpengine&quot;&gt;QHelpEngine&lt;/a&gt; operates on. It can contain references to any number of compressed help files as well as additional information, such as custom filters.</source>
          <target state="translated">&lt;a href=&quot;qhelpengine&quot;&gt;QHelpEngine이&lt;/a&gt; 작동 하는 도움말 콜렉션 파일 . 여기에는 사용자 정의 필터와 같은 추가 정보뿐만 아니라 여러 압축 도움말 파일에 대한 참조가 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3545deb1cba769f8f1145713b0607a65e9c42fcb" translate="yes" xml:space="preserve">
          <source>The help engine also offers the possibility to set and read values in a persistant way comparable to ini files or Windows registry entries. For more information see setValue() or value().</source>
          <target state="translated">또한 도움말 엔진은 ini 파일 또는 Windows 레지스트리 항목과 비슷한 지속적인 방식으로 값을 설정하고 읽을 수있는 가능성을 제공합니다. 자세한 내용은 setValue () 또는 value ()를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="32d91757b87737db568a31761c4e345f6596cd8c" translate="yes" xml:space="preserve">
          <source>The help engine also offers the possibility to set and read values in a persistent way comparable to ini files or Windows registry entries. For more information see setValue() or value().</source>
          <target state="translated">도움말 엔진은 또한 ini 파일 또는 Windows 레지스트리 항목과 유사한 영구적 인 방식으로 값을 설정하고 읽을 수있는 가능성을 제공합니다. 자세한 내용은 setValue () 또는 value ()를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="155499d119928971230d641118c31d7490e9d7cf" translate="yes" xml:space="preserve">
          <source>The help engine can contain any number of custom filters. The management of the filters, including adding new filters, changing filter definitions, or removing existing filters, is done through the &lt;a href=&quot;qhelpfilterengine&quot;&gt;QHelpFilterEngine&lt;/a&gt; class, which can be accessed by the &lt;a href=&quot;qhelpenginecore#filterEngine&quot;&gt;filterEngine&lt;/a&gt;() method.</source>
          <target state="translated">도움말 엔진에는 여러 사용자 정의 필터가 포함될 수 있습니다. 새 필터 추가, 필터 정의 변경 또는 기존 필터 제거를 포함한 필터 관리 는 &lt;a href=&quot;qhelpenginecore#filterEngine&quot;&gt;filterEngine&lt;/a&gt; () 메서드 로 액세스 할 수있는 &lt;a href=&quot;qhelpfilterengine&quot;&gt;QHelpFilterEngine&lt;/a&gt; 클래스를 통해 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="2537c486521f372d2898f63d82bf8deed6a6456a" translate="yes" xml:space="preserve">
          <source>The help engine can contain any number of custom filters. The management of the filters, including adding new filters, changing filter definitions, or removing existing filters, is done through the &lt;a href=&quot;qhelpfilterengine&quot;&gt;QHelpFilterEngine&lt;/a&gt; class, which can be accessed by the &lt;a href=&quot;qhelpenginecore#filterEngine&quot;&gt;filterEngine&lt;/a&gt;() method. This replaces older filter API that is deprecated since Qt 5.13. Please call &lt;a href=&quot;qhelpenginecore#setUsesFilterEngine&quot;&gt;setUsesFilterEngine&lt;/a&gt;() with &lt;code&gt;true&lt;/code&gt; to enable the new functionality.</source>
          <target state="translated">도움말 엔진은 여러 개의 사용자 정의 필터를 포함 할 수 있습니다. 새 필터 추가, 필터 정의 변경 또는 기존 필터 제거를 포함한 필터 관리 는 &lt;a href=&quot;qhelpenginecore#filterEngine&quot;&gt;filterEngine&lt;/a&gt; () 메소드 로 액세스 할 수있는 &lt;a href=&quot;qhelpfilterengine&quot;&gt;QHelpFilterEngine&lt;/a&gt; 클래스를 통해 수행됩니다 . 이것은 Qt 5.13부터 사용되지 않는 오래된 필터 API를 대체합니다. 새 기능을 사용하려면 &lt;a href=&quot;qhelpenginecore#setUsesFilterEngine&quot;&gt;setUsesFilterEngine&lt;/a&gt; ()을 &lt;code&gt;true&lt;/code&gt; 로 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="061119badb7630a928cd87b9fdeb084768304459" translate="yes" xml:space="preserve">
          <source>The hex encoding uses the numbers 0-9 and the letters a-f.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="533439c78ab74b1e8f52f080de2b4da974ecc50d" translate="yes" xml:space="preserve">
          <source>The hex encoding uses the numbers 0-9 and the uppercase letters A-F.</source>
          <target state="translated">16 진 인코딩은 숫자 0-9와 대문자 AF를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="1a69ff45e8c28a5ca2caf4d7b73ef9c4cb6efba3" translate="yes" xml:space="preserve">
          <source>The hierarchy (or graph) that links a set of HTML documents from a web crawler</source>
          <target state="translated">웹 크롤러에서 HTML 문서 세트를 연결하는 계층 (또는 그래프)</target>
        </trans-unit>
        <trans-unit id="58d2fea45abdd7baa6d6d64ea3adf0c4b55e2da6" translate="yes" xml:space="preserve">
          <source>The high contrast theme.</source>
          <target state="translated">고 대비 테마.</target>
        </trans-unit>
        <trans-unit id="09e73d31ce0addea07848bfc0f7e57e883904cd2" translate="yes" xml:space="preserve">
          <source>The high definition shader guarantees that every visible texel of the volume texture is sampled when the volume is rendered. The low definition shader renders only a rough approximation of the volume contents, but at a much higher frame rate. The low definition shader does not guarantee every texel of the volume texture is sampled, so there may be flickering if the volume contains distinct thin features.</source>
          <target state="translated">고해상도 셰이더는 볼륨이 렌더링 될 때 볼륨 텍스처의 모든 텍셀이 샘플링되도록합니다. 저해상도 셰이더는 볼륨 내용의 대략적인 근사치 만 렌더링하지만 훨씬 높은 프레임 속도로 렌더링합니다. 저해상도 셰이더는 볼륨 텍스처의 모든 텍셀이 샘플링되는 것을 보장하지 않으므로, 볼륨에 뚜렷한 얇은 피처가 포함 된 경우 깜박임이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d00942bb06804e2148eb422f4992f80f83e30280" translate="yes" xml:space="preserve">
          <source>The high definition shader guarantees that every visible texel of the volume texture is sampled when the volume is rendered. The low definition shader renders only a rough approximation of the volume contents, but at a much higher frame rate. The low definition shader does not guarantee that every texel of the volume texture is sampled, so there may be flickering if the volume contains distinct thin features.</source>
          <target state="translated">고해상도 셰이더는 볼륨이 렌더링 될 때 볼륨 텍스처의 모든 텍셀이 샘플링되도록합니다. 저해상도 셰이더는 볼륨 내용의 대략적인 근사치 만 렌더링하지만 훨씬 높은 프레임 속도로 렌더링합니다. 저해상도 셰이더는 볼륨 텍스처의 모든 텍셀이 샘플링되는 것을 보장하지 않으므로 볼륨에 뚜렷한 얇은 피처가 포함 된 경우 깜박임이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="83fe980f6909d6a4baa4216d0069bd5656edd3d5" translate="yes" xml:space="preserve">
          <source>The high end of the category.</source>
          <target state="translated">카테고리의 최고급.</target>
        </trans-unit>
        <trans-unit id="5bb48fab01fa6b9b5fafdf5325541678bfb99db6" translate="yes" xml:space="preserve">
          <source>The high level design and motivation for Qt 3D is described in the &lt;a href=&quot;https://doc.qt.io/qt-5.13/qt3d-overview.html#&quot;&gt;Qt 3D Overview&lt;/a&gt;. The Qt 3D Render aspect offers support for data-driven configuration as described in &lt;a href=&quot;qt3drender-framegraph#&quot;&gt;Qt 3D Render Framegraph&lt;/a&gt;.</source>
          <target state="translated">Qt 3D에 대한 높은 수준의 디자인과 동기 부여는 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qt3d-overview.html#&quot;&gt;Qt 3D 개요에&lt;/a&gt; 설명되어 있습니다. Qt 3D 렌더 측면은 &lt;a href=&quot;qt3drender-framegraph#&quot;&gt;Qt 3D 렌더 프레임 그래프에&lt;/a&gt; 설명 된대로 데이터 중심 구성을 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="01f211f017f3704f1face4e75dd70c6971c03efd" translate="yes" xml:space="preserve">
          <source>The high level design and motivation for Qt 3D is described in the &lt;a href=&quot;https://doc.qt.io/qt-5.15/qt3d-overview.html&quot;&gt;Qt 3D Overview&lt;/a&gt;. The Qt 3D Render aspect offers support for data-driven configuration as described in &lt;a href=&quot;qt3drender-framegraph&quot;&gt;Qt 3D Render Framegraph&lt;/a&gt;.</source>
          <target state="translated">Qt 3D에 대한 높은 수준의 설계 및 동기는 &lt;a href=&quot;https://doc.qt.io/qt-5.15/qt3d-overview.html&quot;&gt;Qt 3D 개요에&lt;/a&gt; 설명되어 있습니다. Qt 3D Render 측면은 &lt;a href=&quot;qt3drender-framegraph&quot;&gt;Qt 3D Render Framegraph에&lt;/a&gt; 설명 된대로 데이터 기반 구성을 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="41e55fdcd07936eff8b366da1aaf289ab7fa6c3f" translate="yes" xml:space="preserve">
          <source>The high level design and motivation for Qt 3D is described in the &lt;a href=&quot;https://doc.qt.io/qt-6.0/qt3d-overview.html&quot;&gt;Qt 3D Overview&lt;/a&gt;. The Qt 3D Render aspect offers support for data-driven configuration as described in &lt;a href=&quot;qt3drender-framegraph&quot;&gt;Qt 3D Render Framegraph&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d8297bc60ee2017d69030644d62f19287988755" translate="yes" xml:space="preserve">
          <source>The high precision coordinates delivered from the tablet expressed. Sub pixeling information is in the fractional part of the &lt;a href=&quot;qpointf&quot;&gt;QPointF&lt;/a&gt;.</source>
          <target state="translated">태블릿에서 전달 된 고정밀 좌표가 표현되었습니다. 서브 픽셀 링 정보는 &lt;a href=&quot;qpointf&quot;&gt;QPointF&lt;/a&gt; 의 소수 부분에 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae76edba1a98a68d1d0a1da9d3656ea07437fca7" translate="yes" xml:space="preserve">
          <source>The high precision x position of the tablet device.</source>
          <target state="translated">태블릿 장치의 고정밀 x 위치입니다.</target>
        </trans-unit>
        <trans-unit id="75de107382f4f7ed74f0bfeb39c0219676c55d90" translate="yes" xml:space="preserve">
          <source>The high precision y position of the tablet device.</source>
          <target state="translated">태블릿 장치의 고정밀 y 위치입니다.</target>
        </trans-unit>
        <trans-unit id="02107a729ee552e0fdc237720c2626e3d6b62646" translate="yes" xml:space="preserve">
          <source>The high resolution version is marked by the suffix &lt;code&gt;@2x&lt;/code&gt; on the base name. The image read will have its</source>
          <target state="translated">고해상도 버전은 기본 이름에 접미사 &lt;code&gt;@2x&lt;/code&gt; 로 표시됩니다 . 읽은 이미지는</target>
        </trans-unit>
        <trans-unit id="4caff36e42515d768760319eda72628b628b6df0" translate="yes" xml:space="preserve">
          <source>The high value of the candlestick item.</source>
          <target state="translated">촛대 아이템의 높은 가치.</target>
        </trans-unit>
        <trans-unit id="0bcadcd9b562bccd99cae08b94e6c3871e58cf16" translate="yes" xml:space="preserve">
          <source>The high-level structure of such a class is typically similar to the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81a0c8e60331e26a11580bf2d54e908c116b8bac" translate="yes" xml:space="preserve">
          <source>The high-resolution performance counter provided by Windows. This clock is monotonic and does not overflow.</source>
          <target state="translated">Windows에서 제공하는 고해상도 성능 카운터 이 시계는 단조롭고 넘치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bb5f6e8fd6deb399f9adc22b67681c6b640504b5" translate="yes" xml:space="preserve">
          <source>The higher level &lt;a href=&quot;qmediaobject&quot;&gt;QMediaObject&lt;/a&gt; derived classes provide the actual multimedia functionality, by internally using a &lt;a href=&quot;qmediaservice&quot;&gt;QMediaService&lt;/a&gt;. Each media object hosts a &lt;a href=&quot;qmediaservice&quot;&gt;QMediaService&lt;/a&gt; and uses the &lt;a href=&quot;qmediacontrol&quot;&gt;QMediaControl&lt;/a&gt; interfaces implemented by the service to implement its API. These controls can be accessed from the media object if necessary, but in general the useful functionality can be accessed from the higher level classes.</source>
          <target state="translated">더 높은 레벨의 &lt;a href=&quot;qmediaobject&quot;&gt;QMediaObject&lt;/a&gt; 파생 클래스는 내부적으로 &lt;a href=&quot;qmediaservice&quot;&gt;QMediaService를&lt;/a&gt; 사용하여 실제 멀티미디어 기능을 제공합니다 . 각 미디어 개체는 &lt;a href=&quot;qmediaservice&quot;&gt;QMediaService를&lt;/a&gt; 호스팅 하고 서비스에 의해 구현 된 &lt;a href=&quot;qmediacontrol&quot;&gt;QMediaControl&lt;/a&gt; 인터페이스를 사용하여 API를 구현합니다. 필요한 경우 미디어 개체에서 이러한 컨트롤에 액세스 할 수 있지만 일반적으로 상위 수준의 클래스에서 유용한 기능에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="db4c0969a011e62ef455d4256e9ff3ad11a33bc4" translate="yes" xml:space="preserve">
          <source>The higher level QMediaObject derived classes provide the actual multimedia functionality, by internally using a QMediaService. Each media object hosts a QMediaService and uses the QMediaControl interfaces implemented by the service to implement its API. These controls can be accessed from the media object if necessary, but in general the useful functionality can be accessed from the higher level classes.</source>
          <target state="translated">상위 수준의 QMediaObject 파생 클래스는 내부적으로 QMediaService를 사용하여 실제 멀티미디어 기능을 제공합니다. 각 미디어 개체는 QMediaService를 호스팅하고 서비스에서 구현 한 QMediaControl 인터페이스를 사용하여 API를 구현합니다. 이러한 컨트롤은 필요한 경우 미디어 개체에서 액세스 할 수 있지만 일반적으로 유용한 기능은 상위 수준 클래스에서 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9900ffb6f205311ab976a7070bda93f96021ee89" translate="yes" xml:space="preserve">
          <source>The higher luminance pixel rgb-value from source and &lt;a href=&quot;qml-qtgraphicaleffects-blend#foregroundSource-prop&quot;&gt;foregroundSource&lt;/a&gt; is written.</source>
          <target state="translated">소스 및 &lt;a href=&quot;qml-qtgraphicaleffects-blend#foregroundSource-prop&quot;&gt;포 그라운드&lt;/a&gt; 소스의 더 높은 휘도 픽셀 rgb- 값 이 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="925fe5672af0170025c61a99465ee77576aa8d51" translate="yes" xml:space="preserve">
          <source>The highest valid PaperSource value, currently CustomSource</source>
          <target state="translated">가장 유효한 유효한 PaperSource 값, 현재 CustomSource</target>
        </trans-unit>
        <trans-unit id="c4221e6df603705f9c4ea0d581f35be88c018a98" translate="yes" xml:space="preserve">
          <source>The highlight color for a selected object. Used if &lt;a href=&quot;qml-qtdatavisualization-abstractgraph3d#selectionMode-prop&quot;&gt;selectionMode&lt;/a&gt; has the &lt;code&gt;AbstractGraph3D.SelectionItem&lt;/code&gt; flag set.</source>
          <target state="translated">선택한 객체의 강조 색상입니다. &lt;a href=&quot;qml-qtdatavisualization-abstractgraph3d#selectionMode-prop&quot;&gt;selectionMode&lt;/a&gt; 에 &lt;code&gt;AbstractGraph3D.SelectionItem&lt;/code&gt; 플래그가 설정된 경우에 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="450f2e681a89fa6bc0b58ad31e4c49c4644655d7" translate="yes" xml:space="preserve">
          <source>The highlight color for selected objects. Used if &lt;a href=&quot;qml-qtdatavisualization-abstractgraph3d#selectionMode-prop&quot;&gt;selectionMode&lt;/a&gt; has the &lt;code&gt;AbstractGraph3D.SelectionRow&lt;/code&gt; or &lt;code&gt;AbstractGraph3D.SelectionColumn&lt;/code&gt; flag set.</source>
          <target state="translated">선택한 객체의 강조 색상입니다. &lt;a href=&quot;qml-qtdatavisualization-abstractgraph3d#selectionMode-prop&quot;&gt;selectionMode&lt;/a&gt; 에 &lt;code&gt;AbstractGraph3D.SelectionRow&lt;/code&gt; 또는 &lt;code&gt;AbstractGraph3D.SelectionColumn&lt;/code&gt; 플래그 세트 가있는 경우에 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="30a78459efcceb2ea3b439348c9fdb00ffc0465c" translate="yes" xml:space="preserve">
          <source>The highlight color of the current color group.</source>
          <target state="translated">현재 색상 그룹의 강조 색상입니다.</target>
        </trans-unit>
        <trans-unit id="8f4e33dc92d3d2f65575b4779aef647af6128b48" translate="yes" xml:space="preserve">
          <source>The highlight delegate for this column.</source>
          <target state="translated">이 열의 하이라이트 델리게이트</target>
        </trans-unit>
        <trans-unit id="078e765893d7e8b7566327f0b732573896d48aed" translate="yes" xml:space="preserve">
          <source>The highlight gradient for a selected object. Used if &lt;a href=&quot;qml-qtdatavisualization-abstractgraph3d#selectionMode-prop&quot;&gt;selectionMode&lt;/a&gt; has the &lt;code&gt;AbstractGraph3D.SelectionItem&lt;/code&gt; flag set.</source>
          <target state="translated">선택된 객체의 하이라이트 그라디언트. &lt;a href=&quot;qml-qtdatavisualization-abstractgraph3d#selectionMode-prop&quot;&gt;selectionMode&lt;/a&gt; 에 &lt;code&gt;AbstractGraph3D.SelectionItem&lt;/code&gt; 플래그가 설정된 경우에 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="f192991929780380682216e25c43c6cf036b41d2" translate="yes" xml:space="preserve">
          <source>The highlight gradient for selected objects. Used if &lt;a href=&quot;qml-qtdatavisualization-abstractgraph3d#selectionMode-prop&quot;&gt;selectionMode&lt;/a&gt; has the &lt;code&gt;AbstractGraph3D.SelectionRow&lt;/code&gt; or &lt;code&gt;AbstractGraph3D.SelectionColumn&lt;/code&gt; flag set.</source>
          <target state="translated">선택된 객체의 하이라이트 그라디언트. &lt;a href=&quot;qml-qtdatavisualization-abstractgraph3d#selectionMode-prop&quot;&gt;selectionMode&lt;/a&gt; 에 &lt;code&gt;AbstractGraph3D.SelectionRow&lt;/code&gt; 또는 &lt;code&gt;AbstractGraph3D.SelectionColumn&lt;/code&gt; 플래그 세트 가있는 경우에 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="7ffa79ae33556d9e63995651f5e69a0a97af5e04" translate="yes" xml:space="preserve">
          <source>The highlightItem is managed by the view unless &lt;a href=&quot;qml-qtquick-gridview#highlightFollowsCurrentItem-prop&quot;&gt;highlightFollowsCurrentItem&lt;/a&gt; is set to false. The default &lt;a href=&quot;qquickitem#z-prop&quot;&gt;stacking order&lt;/a&gt; of the highlight item is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">highlightFollowsCurrentItem이 false로 설정되어 있지 않으면 &lt;a href=&quot;qml-qtquick-gridview#highlightFollowsCurrentItem-prop&quot;&gt;highlightItem&lt;/a&gt; 은 보기에 의해 관리됩니다 . 강조 표시 항목 의 기본 &lt;a href=&quot;qquickitem#z-prop&quot;&gt;스태킹 순서&lt;/a&gt; 는 &lt;code&gt;0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8c2b580f524c9fb2d896c685a9ac2a7c2dd995e2" translate="yes" xml:space="preserve">
          <source>The highlighted signal is only emitted when the popup is open and an item is highlighted, but not necessarily &lt;a href=&quot;qml-qtquick-controls2-combobox#activated-signal&quot;&gt;activated&lt;/a&gt;.</source>
          <target state="translated">강조 표시된 신호는 팝업이 열려 있고 항목이 강조 표시 될 때만 방출되지만 반드시 &lt;a href=&quot;qml-qtquick-controls2-combobox#activated-signal&quot;&gt;활성화 될&lt;/a&gt; 필요 는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="185cb178fe71a67d255d76d691106f95ba97c3a2" translate="yes" xml:space="preserve">
          <source>The highlighted text color of the current color group.</source>
          <target state="translated">현재 색상 그룹의 강조 표시된 텍스트 색상입니다.</target>
        </trans-unit>
        <trans-unit id="7210de17f116cd27d14936ff1f8e37951604c0bb" translate="yes" xml:space="preserve">
          <source>The highlighted text color, used in selections.</source>
          <target state="translated">선택에 사용 된 강조 표시된 텍스트 색상입니다.</target>
        </trans-unit>
        <trans-unit id="92a2a8e3d3adac2f314fcabecfefb9fd800599d4" translate="yes" xml:space="preserve">
          <source>The hints can be used to integrate tighter with the underlying platform.</source>
          <target state="translated">힌트는 기본 플랫폼과 더 밀접하게 통합하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b19d295396b91f05586d430e30352847e78eda67" translate="yes" xml:space="preserve">
          <source>The hints for input method on expected input. (See &lt;a href=&quot;qt#InputMethodHint-enum&quot;&gt;Qt::InputMethodHints&lt;/a&gt;)</source>
          <target state="translated">예상 입력에 대한 입력 방법에 대한 힌트입니다. ( &lt;a href=&quot;qt#InputMethodHint-enum&quot;&gt;Qt :: InputMethodHints&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="eafe262b845c2e8f29f89b024d2e85efcdbf7950" translate="yes" xml:space="preserve">
          <source>The history is represented by a &lt;a href=&quot;qml-qtwebengine-webenginehistory&quot;&gt;WebEngineHistory&lt;/a&gt; data model that is held by the &lt;a href=&quot;qml-qtwebengine-webengineview#navigationHistory-prop&quot;&gt;navigationHistory&lt;/a&gt; property.</source>
          <target state="translated">히스토리는 &lt;a href=&quot;qml-qtwebengine-webengineview#navigationHistory-prop&quot;&gt;navigationHistory&lt;/a&gt; 특성 이 보유한 &lt;a href=&quot;qml-qtwebengine-webenginehistory&quot;&gt;WebEngineHistory&lt;/a&gt; 데이터 모델 로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="5b88957af13120ed8c5e7329f9c087eb744b6a07" translate="yes" xml:space="preserve">
          <source>The history uses the concept of a</source>
          <target state="translated">역사는</target>
        </trans-unit>
        <trans-unit id="f1a04d57398ea062cde00288438fd96614f7795f" translate="yes" xml:space="preserve">
          <source>The holster sensor can detect if a device is holstered or not. A holster is a pocket, similar to a gun holster, specifically made for the device. If the device is inside of this pocket, it is holstered. The holster supports the device in detecting whether the device is holstered or not.</source>
          <target state="translated">홀스터 센서는 장치의 홀스터 링 여부를 감지 할 수 있습니다. 홀스터는 건 홀스터와 유사하며 장치 용으로 특별히 제작 된 포켓입니다. 장치가이 주머니 안에 있으면 홀스터가됩니다. 홀스터는 장치가 홀스터 링되는지 여부를 검출하는 데있어서 장치를지지한다.</target>
        </trans-unit>
        <trans-unit id="ef898594da71941c8f558dfe7bc20a95183158f6" translate="yes" xml:space="preserve">
          <source>The home directory icon.</source>
          <target state="translated">홈 디렉토리 아이콘.</target>
        </trans-unit>
        <trans-unit id="87f6ec29584d939c7619b2e2456b2d926894f800" translate="yes" xml:space="preserve">
          <source>The home page for the standard</source>
          <target state="translated">표준 홈페이지</target>
        </trans-unit>
        <trans-unit id="221b556dca6eccb0e7ca9f4f9a8162b1c630623c" translate="yes" xml:space="preserve">
          <source>The hopCount() function contains, for a received datagram, the remaining hop count limit for the packet. When sending, it contains the hop count limit to be set. Most protocols will leave this value set to the default and let the operating system decide on the best value to be used. Multicasting over IPv4 often uses this field to indicate the scope of the multicast group (link-local, local to an organization or global).</source>
          <target state="translated">hopCount () 함수는 수신 된 데이터 그램에 대해 패킷의 나머지 홉 수 제한을 포함합니다. 전송할 때 설정할 홉 수 제한이 포함됩니다. 대부분의 프로토콜은이 값을 기본값으로 설정하고 운영 체제가 사용할 최상의 값을 결정하도록합니다. IPv4를 통한 멀티 캐스팅은 종종이 필드를 사용하여 멀티 캐스트 그룹의 범위 (링크 로컬, 로컬 로컬 또는 조직)를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="eb71886fdf87085570a20f4e482d5dd2bdc53851" translate="yes" xml:space="preserve">
          <source>The horizontal and vertical policies can be set in the constructor, and altered using the &lt;a href=&quot;qsizepolicy#setHorizontalPolicy&quot;&gt;setHorizontalPolicy&lt;/a&gt;() and &lt;a href=&quot;qsizepolicy#setVerticalPolicy&quot;&gt;setVerticalPolicy&lt;/a&gt;() functions. The stretch factors can be set using the &lt;a href=&quot;qsizepolicy#setHorizontalStretch&quot;&gt;setHorizontalStretch&lt;/a&gt;() and &lt;a href=&quot;qsizepolicy#setVerticalStretch&quot;&gt;setVerticalStretch&lt;/a&gt;() functions. The flag indicating whether the widget's &lt;a href=&quot;qwidget#sizeHint-prop&quot;&gt;sizeHint()&lt;/a&gt; is width-dependent (such as a menu bar or a word-wrapping label) can be set using the &lt;a href=&quot;qsizepolicy#setHeightForWidth&quot;&gt;setHeightForWidth&lt;/a&gt;() function.</source>
          <target state="translated">가로 및 세로 정책은 생성자에서 설정하고 &lt;a href=&quot;qsizepolicy#setHorizontalPolicy&quot;&gt;setHorizontalPolicy&lt;/a&gt; () 및 &lt;a href=&quot;qsizepolicy#setVerticalPolicy&quot;&gt;setVerticalPolicy&lt;/a&gt; () 함수를 사용하여 변경할 수 있습니다 . 신축 계수는 &lt;a href=&quot;qsizepolicy#setHorizontalStretch&quot;&gt;setHorizontalStretch&lt;/a&gt; () 및 &lt;a href=&quot;qsizepolicy#setVerticalStretch&quot;&gt;setVerticalStretch&lt;/a&gt; () 함수를 사용하여 설정할 수 있습니다 . &lt;a href=&quot;qsizepolicy#setHeightForWidth&quot;&gt;setHeightForWidth&lt;/a&gt; () 함수를 사용하여 위젯의 &lt;a href=&quot;qwidget#sizeHint-prop&quot;&gt;sizeHint ()&lt;/a&gt; 가 너비에 의존 하는지 (예 : 메뉴 막대 또는 단어 줄 바꿈 레이블)를 나타내는 플래그를 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="92f37615d808a7e90b4fb58ddd45344e663b2458" translate="yes" xml:space="preserve">
          <source>The horizontal and vertical scroll bars can be accessed and customized using the &lt;a href=&quot;qml-qtquick-controls2-scrollbar#horizontal-attached-prop&quot;&gt;ScrollBar.horizontal&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-controls2-scrollbar#vertical-attached-prop&quot;&gt;ScrollBar.vertical&lt;/a&gt; attached properties. The following example adjusts the scroll bar policies so that the horizontal scroll bar is always off, and the vertical scroll bar is always on.</source>
          <target state="translated">수평 및 수직 스크롤 막대는 &lt;a href=&quot;qml-qtquick-controls2-scrollbar#horizontal-attached-prop&quot;&gt;ScrollBar.horizontal&lt;/a&gt; 및 &lt;a href=&quot;qml-qtquick-controls2-scrollbar#vertical-attached-prop&quot;&gt;ScrollBar.vertical&lt;/a&gt; 첨부 속성을 사용하여 액세스하고 사용자 지정할 수 있습니다 . 다음 예제에서는 가로 스크롤 막대가 항상 꺼져 있고 세로 스크롤 막대가 항상 켜져 있도록 스크롤 막대 정책을 조정합니다.</target>
        </trans-unit>
        <trans-unit id="54959d0f9d1e1575e8723cf4b18ef9b28a622972" translate="yes" xml:space="preserve">
          <source>The horizontal direction. Equivalent to GL_TEXTURE_WRAP_S</source>
          <target state="translated">가로 방향. GL_TEXTURE_WRAP_S와 동일</target>
        </trans-unit>
        <trans-unit id="4775c07935b1b30a47d4aba5781c4ee9dbae0a8e" translate="yes" xml:space="preserve">
          <source>The horizontal extra space on the left/right of a menu.</source>
          <target state="translated">메뉴의 왼쪽 / 오른쪽에 수평 추가 공간.</target>
        </trans-unit>
        <trans-unit id="500b79f71ac7f2e393e3f4aaaafd71ab4c79b366" translate="yes" xml:space="preserve">
          <source>The horizontal flags are:</source>
          <target state="translated">수평 플래그는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="543d6c2440db5db9a4f14495b7fb06f397fe01e0" translate="yes" xml:space="preserve">
          <source>The horizontal layout direction can also be reversed through the &lt;a href=&quot;qml-qtquick-layoutmirroring&quot;&gt;LayoutMirroring&lt;/a&gt; attached property. This causes the effective &lt;code&gt;layoutDirection&lt;/code&gt; of positioners and views to be mirrored. Note the actual value of the &lt;code&gt;layoutDirection&lt;/code&gt; property will remain unchanged; the effective layout direction of positioners and views that takes the mirroring into account can be read from the &lt;code&gt;effectiveLayoutDirection&lt;/code&gt; property.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-layoutmirroring&quot;&gt;LayoutMirroring&lt;/a&gt; 연결된 속성을 통해 가로 레이아웃 방향을 바꿀 수도 있습니다 . 이로 인해 포지셔너와 뷰 의 효과적인 &lt;code&gt;layoutDirection&lt;/code&gt; 이 미러링됩니다. &lt;code&gt;layoutDirection&lt;/code&gt; 속성 의 실제 값 은 변경되지 않습니다. 미러링을 고려한 포지셔너 및 뷰의 효과적인 레이아웃 방향은 &lt;code&gt;effectiveLayoutDirection&lt;/code&gt; 속성 에서 읽을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e714ecccec169716610b48bfe94d19b7cbdb71d4" translate="yes" xml:space="preserve">
          <source>The horizontal overlap between a submenu and its parent.</source>
          <target state="translated">하위 메뉴와 부모 메뉴의 가로 겹침</target>
        </trans-unit>
        <trans-unit id="9dc02a9183724ce4f122dbb5f0815d3edd6904b6" translate="yes" xml:space="preserve">
          <source>The horizontal position of the &lt;a href=&quot;qml-qtquick-pathtext&quot;&gt;PathText&lt;/a&gt;'s baseline.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-pathtext&quot;&gt;PathText&lt;/a&gt; 기준선 의 수평 위치입니다 .</target>
        </trans-unit>
        <trans-unit id="26cac3cf7b33edee0a4840deba50c907c69a14c4" translate="yes" xml:space="preserve">
          <source>The horizontal position of the pie.</source>
          <target state="translated">파이의 가로 위치입니다.</target>
        </trans-unit>
        <trans-unit id="b5d8fafa9d06256610a9bff8b8a8a15c33398312" translate="yes" xml:space="preserve">
          <source>The horizontal resolution of the device in dots per inch. See also &lt;a href=&quot;qpaintdevice#logicalDpiX&quot;&gt;logicalDpiX&lt;/a&gt;().</source>
          <target state="translated">장치의 가로 해상도 (인치당 도트 수)입니다. &lt;a href=&quot;qpaintdevice#logicalDpiX&quot;&gt;logicalDpiX&lt;/a&gt; () 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f4a2e00b7479493fbbc6317c40d12434f5832657" translate="yes" xml:space="preserve">
          <source>The horizontal resolution of the device in dots per inch. See also &lt;a href=&quot;qpaintdevice#physicalDpiX&quot;&gt;physicalDpiX&lt;/a&gt;().</source>
          <target state="translated">장치의 가로 해상도 (인치당 도트 수)입니다. &lt;a href=&quot;qpaintdevice#physicalDpiX&quot;&gt;physicalDpiX&lt;/a&gt; () 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6e09cfa79366e7ef05aa7fa589389453b451d381" translate="yes" xml:space="preserve">
          <source>The horizontal roughness texture map. Default is a &lt;a href=&quot;qml-qtquick3d-texture&quot;&gt;Texture&lt;/a&gt; with source &lt;code&gt;&quot;maps/brushed_full_contrast.png&quot;&lt;/code&gt;.</source>
          <target state="translated">수평 거칠기 텍스처 맵입니다. 기본값은 소스가 &lt;code&gt;&quot;maps/brushed_full_contrast.png&quot;&lt;/code&gt; 인&lt;a href=&quot;qml-qtquick3d-texture&quot;&gt;텍스처&lt;/a&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="7b44a8d52093bfc19469ea1c6c50b756f623d3f2" translate="yes" xml:space="preserve">
          <source>The horizontal text alignment of the column. Allowed values are:</source>
          <target state="translated">열의 가로 텍스트 정렬입니다. 허용되는 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b45967c858d811b1b9cc251e9d6a26ef2e70c495" translate="yes" xml:space="preserve">
          <source>The horizontal wrap mode is set on the texture instance just before the texture is bound for rendering.</source>
          <target state="translated">수평 랩 모드는 텍스처가 렌더링을 위해 바인딩되기 직전에 텍스처 인스턴스에서 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="13ce06aef17160c1b7238f110449447b3f01f991" translate="yes" xml:space="preserve">
          <source>The horizontalOffset and &lt;a href=&quot;qml-qtgraphicaleffects-conicalgradient#verticalOffset-prop&quot;&gt;verticalOffset&lt;/a&gt; properties define the offset in pixels for the center point of the gradient compared to the item center.</source>
          <target state="translated">horizontalOffset 및 &lt;a href=&quot;qml-qtgraphicaleffects-conicalgradient#verticalOffset-prop&quot;&gt;verticalOffset&lt;/a&gt; 속성은 항목 중심과 비교하여 그래디언트의 중심점에 대한 오프셋을 픽셀 단위로 정의합니다.</target>
        </trans-unit>
        <trans-unit id="8031bf8a5eb2ae5224986e8223b2fb9d8d77d951" translate="yes" xml:space="preserve">
          <source>The horizontalOffset and &lt;a href=&quot;qml-qtgraphicaleffects-radialgradient#verticalOffset-prop&quot;&gt;verticalOffset&lt;/a&gt; properties define the offset in pixels for the center point of the gradient compared to the item center.</source>
          <target state="translated">horizontalOffset 및 &lt;a href=&quot;qml-qtgraphicaleffects-radialgradient#verticalOffset-prop&quot;&gt;verticalOffset&lt;/a&gt; 속성은 항목 중심과 비교하여 그래디언트의 중심점에 대한 오프셋을 픽셀 단위로 정의합니다.</target>
        </trans-unit>
        <trans-unit id="dc5dbb8c18052273a6c82a3bcf823a0cb57187cd" translate="yes" xml:space="preserve">
          <source>The horizontalRadius and &lt;a href=&quot;qml-qtgraphicaleffects-radialgradient#verticalRadius-prop&quot;&gt;verticalRadius&lt;/a&gt; properties define the shape and size of the radial gradient. If the radiuses are equal, the shape of the gradient is a circle. If the horizontal and vertical radiuses differ, the shape is elliptical. The radiuses are given in pixels.</source>
          <target state="translated">horizontalRadius 및 &lt;a href=&quot;qml-qtgraphicaleffects-radialgradient#verticalRadius-prop&quot;&gt;verticalRadius&lt;/a&gt; 속성은 방사형 그래디언트의 모양과 크기를 정의합니다. 반지름이 같으면 그라디언트 모양이 원입니다. 수평 및 수직 반경이 다른 경우 모양은 타원형입니다. 반경은 픽셀 단위로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="ffed06dab7962e8acd2c1115159091f3b467e133" translate="yes" xml:space="preserve">
          <source>The host address for the node.</source>
          <target state="translated">노드의 호스트 주소입니다.</target>
        </trans-unit>
        <trans-unit id="486da78a64c1ea0ffa5437644fdc349e29299591" translate="yes" xml:space="preserve">
          <source>The host address of the server. By default, localhost is used.</source>
          <target state="translated">서버의 호스트 주소 기본적으로 localhost가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="016829957022c280976985faa5527d5b4cab1177" translate="yes" xml:space="preserve">
          <source>The host address was not found.</source>
          <target state="translated">호스트 주소를 찾을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="518879bcd1d79ba7e7711ed8d268d6c7d0a03634" translate="yes" xml:space="preserve">
          <source>The host and port of the server requesting the client certificate.</source>
          <target state="translated">클라이언트 인증서를 요청하는 서버의 호스트 및 포트</target>
        </trans-unit>
        <trans-unit id="addfc2f3128b7e0a35c8d9b8e212161c834e5db8" translate="yes" xml:space="preserve">
          <source>The host name (or service name) is needed when constructing the QTDSDriver for creating new connections for internal queries. This is to prevent blocking when several &lt;a href=&quot;qsqlquery&quot;&gt;QSqlQuery&lt;/a&gt; objects are used simultaneously.</source>
          <target state="translated">내부 조회에 대한 새 연결을 작성하기 위해 QTDSDriver를 구성 할 때 호스트 이름 (또는 서비스 이름)이 필요합니다. 이것은 여러 &lt;a href=&quot;qsqlquery&quot;&gt;QSqlQuery&lt;/a&gt; 오브젝트가 동시에 사용될 때 블로킹을 방지하기위한 것 입니다.</target>
        </trans-unit>
        <trans-unit id="150acd1fa8e19d629c82910789a91ea7838b0e04" translate="yes" xml:space="preserve">
          <source>The host name specified in the certificate is not unique.</source>
          <target state="translated">인증서에 지정된 호스트 이름이 고유하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d07e522fbd24a3dae2ec2b36a6ee7d2775fbc7b1" translate="yes" xml:space="preserve">
          <source>The host node has already been initialized.</source>
          <target state="translated">호스트 노드가 이미 초기화되었습니다.</target>
        </trans-unit>
        <trans-unit id="62d263885c91782569e5da8674d5404e184ec84e" translate="yes" xml:space="preserve">
          <source>The host node is created as shown below:</source>
          <target state="translated">호스트 노드는 아래와 같이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="2500fae5f3d0907310d1e638d3ea5c5f185bad60" translate="yes" xml:space="preserve">
          <source>The hostname of the authentication proxy. Empty if &lt;a href=&quot;qml-qtwebengine-authenticationdialogrequest#type-prop&quot;&gt;type&lt;/a&gt; is AuthenticationTypeHTTP.</source>
          <target state="translated">인증 프록시의 호스트 이름입니다. &lt;a href=&quot;qml-qtwebengine-authenticationdialogrequest#type-prop&quot;&gt;유형&lt;/a&gt; 이 AuthenticationTypeHTTP 인 경우 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6e865f403bdb56a26126e5a2458e8aab4289a01" translate="yes" xml:space="preserve">
          <source>The hot-spot is a point in the global coordinate system, use &lt;a href=&quot;qwidget#mapFromGlobal&quot;&gt;QWidget::mapFromGlobal&lt;/a&gt;() or &lt;a href=&quot;qgestureevent#mapToGraphicsScene&quot;&gt;QGestureEvent::mapToGraphicsScene&lt;/a&gt;() to get a local hot-spot.</source>
          <target state="translated">핫스팟은 글로벌 좌표계의 한 지점입니다. &lt;a href=&quot;qwidget#mapFromGlobal&quot;&gt;QWidget :: mapFromGlobal&lt;/a&gt; () 또는 &lt;a href=&quot;qgestureevent#mapToGraphicsScene&quot;&gt;QGestureEvent :: mapToGraphicsScene&lt;/a&gt; ()을 사용하여 로컬 핫스팟을 가져 오십시오.</target>
        </trans-unit>
        <trans-unit id="2729d0feceda6eb47a200a8e7d7a4bcad0067547" translate="yes" xml:space="preserve">
          <source>The hot-spot should be set by the gesture recognizer to allow gesture event delivery to a &lt;a href=&quot;qgraphicsobject&quot;&gt;QGraphicsObject&lt;/a&gt;.</source>
          <target state="translated">핫스팟은 제스처 인식기가 &lt;a href=&quot;qgraphicsobject&quot;&gt;QGraphicsObject에&lt;/a&gt; 제스처 이벤트를 전달할 수 있도록 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="d98f5bf472f06248e5a869ca5c79cea61642d83f" translate="yes" xml:space="preserve">
          <source>The hour with a leading zero (00 to 23 or 01 to 12 if AM/PM display)</source>
          <target state="translated">앞에 0이있는 시간 (AM / PM이 표시되는 경우 00 ~ 23 또는 01 ~ 12)</target>
        </trans-unit>
        <trans-unit id="347a6105f6be99a7bf15d6ff2e67109f99d4d1c2" translate="yes" xml:space="preserve">
          <source>The hour with a leading zero (00 to 23, even with AM/PM display)</source>
          <target state="translated">앞에 0이있는 시간 (오전 / 오후 표시에서도 00-23)</target>
        </trans-unit>
        <trans-unit id="2fcd5392e17efdad530698356aa0f2847c21904f" translate="yes" xml:space="preserve">
          <source>The hour without a leading zero (0 to 23 or 1 to 12 if AM/PM display)</source>
          <target state="translated">앞에 0이없는 시간 (AM / PM이 표시되는 경우 0 ~ 23 또는 1 ~ 12)</target>
        </trans-unit>
        <trans-unit id="09f30bdce8d3f9027fa1b9adf1607ffc9787fe10" translate="yes" xml:space="preserve">
          <source>The hour without a leading zero (0 to 23, even with AM/PM display)</source>
          <target state="translated">앞에 0이없는 시간 (0 ~ 23, AM / PM 표시 포함)</target>
        </trans-unit>
        <trans-unit id="71201df39a119f63af40e95e71a3e443aac393fb" translate="yes" xml:space="preserve">
          <source>The hue value from &lt;a href=&quot;qml-qtgraphicaleffects-blend#foregroundSource-prop&quot;&gt;foregroundSource&lt;/a&gt; is combined with saturation and lightness from source and written.</source>
          <target state="translated">&lt;a href=&quot;qml-qtgraphicaleffects-blend#foregroundSource-prop&quot;&gt;foregroundSource&lt;/a&gt; 의 색조 값은 소스의 채도와 명도와 결합되어 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="d307f31b4a40bbeedd8de221759bb60142d9e784" translate="yes" xml:space="preserve">
          <source>The hue value is defined to be the same in HSL and HSV.</source>
          <target state="translated">색조 값은 HSL과 HSV에서 동일하게 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="c0a1464eb0fe6a0378d668d966cb51ea329c96ff" translate="yes" xml:space="preserve">
          <source>The human readable name of the extension, eg. 'basicConstraints'.</source>
          <target state="translated">확장명이 사람이 읽을 수있는 이름, 예 : '기본 제약 조건'.</target>
        </trans-unit>
        <trans-unit id="5e39e68c3c62972b6f16c4a2f87387359b92f5fc" translate="yes" xml:space="preserve">
          <source>The human readable representation of the URL is fetched with &lt;a href=&quot;qurl#toString&quot;&gt;toString&lt;/a&gt;(). This representation is appropriate for displaying a URL to a user in unencoded form. The encoded form however, as returned by &lt;a href=&quot;qurl#toEncoded&quot;&gt;toEncoded&lt;/a&gt;(), is for internal use, passing to web servers, mail clients and so on. Both forms are technically correct and represent the same URL unambiguously -- in fact, passing either form to &lt;a href=&quot;qurl&quot;&gt;QUrl&lt;/a&gt;'s constructor or to &lt;a href=&quot;qurl#setUrl&quot;&gt;setUrl&lt;/a&gt;() will yield the same &lt;a href=&quot;qurl&quot;&gt;QUrl&lt;/a&gt; object.</source>
          <target state="translated">사람이 읽을 수있는 URL 표현은 &lt;a href=&quot;qurl#toString&quot;&gt;toString&lt;/a&gt; ()으로 가져옵니다 . 이 표현은 인코딩되지 않은 형식으로 사용자에게 URL을 표시하는 데 적합합니다. 그러나 &lt;a href=&quot;qurl#toEncoded&quot;&gt;toEncoded&lt;/a&gt; ()에 의해 리턴 된 인코딩 된 양식 은 내부 용이며 웹 서버, 메일 클라이언트 등으로 전달됩니다. 두 형식 모두 기술적으로 정확하고 모호하지 않은 동일한 URL을 나타냅니다. 실제로 양식을 &lt;a href=&quot;qurl&quot;&gt;QUrl&lt;/a&gt; 의 생성자 또는 &lt;a href=&quot;qurl#setUrl&quot;&gt;setUrl&lt;/a&gt; ()에 전달하면 동일한 &lt;a href=&quot;qurl&quot;&gt;QUrl&lt;/a&gt; 객체 가 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="d7ecdde3729d50502b8871bd3481e18514db2391" translate="yes" xml:space="preserve">
          <source>The human readable representation of the URL is fetched with &lt;a href=&quot;qurl#toString&quot;&gt;toString&lt;/a&gt;(). This representation is appropriate for displaying a URL to a user in unencoded form. The encoded form however, as returned by &lt;a href=&quot;qurl#toEncoded&quot;&gt;toEncoded&lt;/a&gt;(), is for internal use, passing to web servers, mail clients and so on. Both forms are technically correct and represent the same URL unambiguously -- in fact, passing either form to QUrl's constructor or to &lt;a href=&quot;qurl#setUrl&quot;&gt;setUrl&lt;/a&gt;() will yield the same QUrl object.</source>
          <target state="translated">사람이 읽을 수있는 URL 표현은 &lt;a href=&quot;qurl#toString&quot;&gt;toString&lt;/a&gt; ()으로 가져옵니다 . 이 표현은 인코딩되지 않은 형식으로 사용자에게 URL을 표시하는 데 적합합니다. 그러나 &lt;a href=&quot;qurl#toEncoded&quot;&gt;toEncoded&lt;/a&gt; ()에 의해 반환 된 인코딩 된 형식 은 내부 용으로 웹 서버, 메일 클라이언트 등에 전달됩니다. 두 양식 모두 기술적으로 정확하고 동일한 URL을 모호하지 않게 나타냅니다. 사실 두 양식을 QUrl의 생성자 또는 &lt;a href=&quot;qurl#setUrl&quot;&gt;setUrl&lt;/a&gt; ()에 전달하면 동일한 QUrl 객체가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="851d3d8eec8d31a7c253c2bd0a2bc35a26213885" translate="yes" xml:space="preserve">
          <source>The human-readable system time. This clock is not monotonic.</source>
          <target state="translated">사람이 읽을 수있는 시스템 시간 이 시계는 단조롭지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3b93c43fd12c123e51c9da47b1c13f4b5dc03c7c" translate="yes" xml:space="preserve">
          <source>The humidity sensor returns the relative humidity as a percentage, and absolute humidity in grams per cubic meter (g/m3). Note that some sensors may not support absolute humidity, 0 will be returned in this case.</source>
          <target state="translated">습도 센서는 상대 습도를 백분율로 반환하고 절대 습도는 그램 / 그램 (g / m3)입니다. 일부 센서는 절대 습도를 지원하지 않을 수 있습니다.이 경우 0이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="82522a838764a6faca08b216a0fcef1e54fa4207" translate="yes" xml:space="preserve">
          <source>The icon (if any) to be drawn in the view item.</source>
          <target state="translated">보기 항목에 그릴 아이콘 (있는 경우).</target>
        </trans-unit>
        <trans-unit id="1b634f2b52a67165c792033374c88002da92df33" translate="yes" xml:space="preserve">
          <source>The icon class also has a key-value set of parameters. The precise key one needs to use depends on the &lt;a href=&quot;qtlocation-index#plugin-references-and-parameters&quot;&gt;plugin&lt;/a&gt; being used. These parameters influence which icon URL is returned by the manager and may also be used to specify icon URL locations when saving icons.</source>
          <target state="translated">아이콘 클래스에는 키-값 매개 변수 세트도 있습니다. 사용해야하는 정확한 키 는 사용중인 &lt;a href=&quot;qtlocation-index#plugin-references-and-parameters&quot;&gt;플러그인&lt;/a&gt; 에 따라 다릅니다 . 이 매개 변수는 관리자가 리턴하는 아이콘 URL에 영향을 미치며 아이콘을 저장할 때 아이콘 URL 위치를 지정하는 데 사용될 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea25a6c943f25e25002d6bf43e5f0cedb2cb186e" translate="yes" xml:space="preserve">
          <source>The icon color is specified by default so that it matches the text color in different states. In order to use an icon with the original colors, set the color to &lt;code&gt;&quot;transparent&quot;&lt;/code&gt;.</source>
          <target state="translated">아이콘 색상은 기본적으로 다른 상태의 텍스트 색상과 일치하도록 지정됩니다. 원래 색상의 아이콘을 사용하려면 색상을 &lt;code&gt;&quot;transparent&quot;&lt;/code&gt; 로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="ba4fe60e6f2c4e205383176928eddbeb7ca45716" translate="yes" xml:space="preserve">
          <source>The icon color.</source>
          <target state="translated">아이콘 색상.</target>
        </trans-unit>
        <trans-unit id="991f5806d464eb9ef50630bf0144be53c3142474" translate="yes" xml:space="preserve">
          <source>The icon currently used by the message box. Note that it's often hard to draw one pixmap that looks appropriate in all GUI styles; you may want to supply a different pixmap for each platform.</source>
          <target state="translated">메시지 상자에서 현재 사용하는 아이콘입니다. 모든 GUI 스타일에 적합한 하나의 픽스맵을 그리는 것은 종종 어려운 일입니다. 각 플랫폼마다 다른 pixmap을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5453975b65ac6a4cdf4665cd6a0537ce912b734e" translate="yes" xml:space="preserve">
          <source>The icon engine plugin is a simple plugin interface that makes it easy to create custom icon engines that can be loaded dynamically into applications through &lt;a href=&quot;qicon&quot;&gt;QIcon&lt;/a&gt;. &lt;a href=&quot;qicon&quot;&gt;QIcon&lt;/a&gt; uses the file or resource name's suffix to determine what icon engine to use.</source>
          <target state="translated">아이콘 엔진 플러그인은 간단한 플러그인 인터페이스로 &lt;a href=&quot;qicon&quot;&gt;QIcon을&lt;/a&gt; 통해 애플리케이션에 동적으로로드 할 수있는 사용자 정의 아이콘 엔진을 쉽게 만들 수 있습니다 . &lt;a href=&quot;qicon&quot;&gt;QIcon&lt;/a&gt; 은 파일 또는 리소스 이름의 접미사를 사용하여 사용할 아이콘 엔진을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="5bb7a9515a0abf06e5af8d221818cb3938e7de5b" translate="yes" xml:space="preserve">
          <source>The icon for the &amp;ldquo;Network Servers&amp;rdquo; place in the desktop's file manager, and workgroups within the network</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1839b014dc8dbbe5a1207b1aa7145c8cd270224d" translate="yes" xml:space="preserve">
          <source>The icon for the special &quot;Desktop&quot; directory of the user</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cda47b61ec23c0e5285667e03820d26e43fbd3f" translate="yes" xml:space="preserve">
          <source>The icon for the user's &quot;Trash&quot; place in the desktop's file manager</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cec783687f1ea64ece38558cf7c958faa1e2205" translate="yes" xml:space="preserve">
          <source>The icon is initially invisible.</source>
          <target state="translated">아이콘은 처음에는 보이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a6c6a051b3252fa97d65b781ca91a2ac17a6602d" translate="yes" xml:space="preserve">
          <source>The icon is rendered by the &lt;a href=&quot;qiconengine#paint&quot;&gt;paint&lt;/a&gt;() function, and the icon can additionally be obtained as a pixmap with the &lt;a href=&quot;qiconengine#pixmap&quot;&gt;pixmap&lt;/a&gt;() function (the default implementation simply uses &lt;a href=&quot;qiconengine#paint&quot;&gt;paint&lt;/a&gt;() to achieve this). The &lt;a href=&quot;qiconengine#addPixmap&quot;&gt;addPixmap&lt;/a&gt;() function can be used to add new pixmaps to the icon engine, and is used by &lt;a href=&quot;qicon&quot;&gt;QIcon&lt;/a&gt; to add specialized custom pixmaps.</source>
          <target state="translated">아이콘은 &lt;a href=&quot;qiconengine#paint&quot;&gt;paint&lt;/a&gt; () 함수에 의해 렌더링되며, &lt;a href=&quot;qiconengine#pixmap&quot;&gt;pixmap&lt;/a&gt; () 함수를 사용 하여 아이콘을 pixmap으로 추가로 얻을 수 있습니다 (기본 구현에서는 단순히 &lt;a href=&quot;qiconengine#paint&quot;&gt;paint&lt;/a&gt; ()을 사용 하여이를 수행함). &lt;a href=&quot;qiconengine#addPixmap&quot;&gt;addPixmap&lt;/a&gt; () 함수는 아이콘 엔진에 새 픽스맵을 추가 할 수 있습니다, 그리고에 의해 사용되는 &lt;a href=&quot;qicon&quot;&gt;QIcon&lt;/a&gt; 전문 사용자 정의 픽스맵을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2b52b2148b27639a62da3fa664448aba85f17a0d" translate="yes" xml:space="preserve">
          <source>The icon is tinted with the specified color, unless the color is set to &lt;code&gt;&quot;transparent&quot;&lt;/code&gt;.</source>
          <target state="translated">색상이 &lt;code&gt;&quot;transparent&quot;&lt;/code&gt; 설정되어 있지 않으면 아이콘에 지정된 색상이 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="d94a522831ec293708665ab236ac7503c3172747" translate="yes" xml:space="preserve">
          <source>The icon name can be given to &lt;a href=&quot;qicon#fromTheme&quot;&gt;QIcon::fromTheme&lt;/a&gt;() in order to load the icon.</source>
          <target state="translated">아이콘 을로드하기 위해 아이콘 이름을 &lt;a href=&quot;qicon#fromTheme&quot;&gt;QIcon :: fromTheme&lt;/a&gt; ()에 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="159ced877b144578b884b33f089f5d73ccf9fbc1" translate="yes" xml:space="preserve">
          <source>The icon of a &lt;a href=&quot;qabstractitemview&quot;&gt;QAbstractItemView&lt;/a&gt; or a &lt;a href=&quot;qmenu&quot;&gt;QMenu&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qabstractitemview&quot;&gt;QAbstractItemView&lt;/a&gt; 또는 &lt;a href=&quot;qmenu&quot;&gt;QMenu&lt;/a&gt; 의 아이콘입니다 .</target>
        </trans-unit>
        <trans-unit id="0b7c5ce2d5e2662ad837dd90ff77487e38bb59ce" translate="yes" xml:space="preserve">
          <source>The icon of a dock widget.</source>
          <target state="translated">독 위젯의 아이콘입니다.</target>
        </trans-unit>
        <trans-unit id="d6bfb12cb5307ee39ddb1988748888382a4f0809" translate="yes" xml:space="preserve">
          <source>The icon of the current (selected) item of the combo box.</source>
          <target state="translated">콤보 상자의 현재 (선택된) 항목 아이콘입니다.</target>
        </trans-unit>
        <trans-unit id="5893fb8d8cc36a5beba23c865c7d918a1875e0f7" translate="yes" xml:space="preserve">
          <source>The icon of the header (for section that is being drawn).</source>
          <target state="translated">머리글의 아이콘 (그리기중인 섹션).</target>
        </trans-unit>
        <trans-unit id="b834afe6b58219002d0ca2354d9caae0d17e6de6" translate="yes" xml:space="preserve">
          <source>The icon of the menu item (it is not common that styles draw this icon).</source>
          <target state="translated">메뉴 항목의 아이콘 (스타일이이 아이콘을 그리는 것은 일반적이지 않습니다).</target>
        </trans-unit>
        <trans-unit id="33f97ac8608b5187e4c9d7515b27959b50d49d29" translate="yes" xml:space="preserve">
          <source>The icon of the message box can be specified with one of the values:</source>
          <target state="translated">메시지 상자의 아이콘은 다음 값 중 하나로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="774634e2eda427a5a9b9069a5263a3e947b793da" translate="yes" xml:space="preserve">
          <source>The icon of the message box can be specified with one of these values:</source>
          <target state="translated">메시지 상자의 아이콘은 다음 값 중 하나로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1bc861caba0da2221c673961e27becf334f06e07" translate="yes" xml:space="preserve">
          <source>The icon on the toolbox tab.</source>
          <target state="translated">도구 상자 탭의 아이콘.</target>
        </trans-unit>
        <trans-unit id="0388cb12a31974020e9b943c7dd3feb739a49612" translate="yes" xml:space="preserve">
          <source>The icon size of the button's icon.</source>
          <target state="translated">버튼 아이콘의 아이콘 크기입니다.</target>
        </trans-unit>
        <trans-unit id="f55eb33fd0bd0d19bd186229af89f374ae86f4ce" translate="yes" xml:space="preserve">
          <source>The icon size of the following widgets can be set using this property.</source>
          <target state="translated">이 속성을 사용하여 다음 위젯의 아이콘 크기를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="61e59ccee1574df6a30c048f3a9b63d7cdeae19c" translate="yes" xml:space="preserve">
          <source>The icon that is used, for widgets that have an icon.</source>
          <target state="translated">아이콘이있는 위젯에 사용되는 아이콘입니다.</target>
        </trans-unit>
        <trans-unit id="7dcc4fd92ebabcf56a9ee0a74f1ed5fd9d66dbc3" translate="yes" xml:space="preserve">
          <source>The icon to display is set with the &lt;a href=&quot;qml-qtquick-extras-picture#source-prop&quot;&gt;source&lt;/a&gt; property.</source>
          <target state="translated">표시 할 아이콘은 &lt;a href=&quot;qml-qtquick-extras-picture#source-prop&quot;&gt;source&lt;/a&gt; 속성으로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="627e4fd451d76867f996515b02cabe412e5a609f" translate="yes" xml:space="preserve">
          <source>The icon used for disk drives</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="baf8c550e274f48c1c18722518c68f16439d50c6" translate="yes" xml:space="preserve">
          <source>The icon used for generic text file types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cb9258b1fafbff29962e7329240973415100a63" translate="yes" xml:space="preserve">
          <source>The icon used for the computing device as a whole</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da224894f523f345e8d5284c01c74f4a313eb8ce" translate="yes" xml:space="preserve">
          <source>The icon will be loaded as a regular image.</source>
          <target state="translated">아이콘은 일반 이미지로로드됩니다.</target>
        </trans-unit>
        <trans-unit id="67057978471d647825489ab4643e44c6efbbf47c" translate="yes" xml:space="preserve">
          <source>The icon will be loaded from the platform theme. If the icon is found in the theme, it will always be used; even if &lt;a href=&quot;qml-qtquick-controls2-abstractbutton#icon.source-prop&quot;&gt;icon.source&lt;/a&gt; is also set. If the icon is not found, &lt;a href=&quot;qml-qtquick-controls2-abstractbutton#icon.source-prop&quot;&gt;icon.source&lt;/a&gt; will be used instead.</source>
          <target state="translated">플랫폼 테마에서 아이콘이로드됩니다. 테마에 아이콘이 있으면 항상 사용됩니다. &lt;a href=&quot;qml-qtquick-controls2-abstractbutton#icon.source-prop&quot;&gt;icon.source&lt;/a&gt; 도 설정되어 있어도 아이콘이 없으면 &lt;a href=&quot;qml-qtquick-controls2-abstractbutton#icon.source-prop&quot;&gt;icon.source&lt;/a&gt; 가 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f1bac99d9a600e91453301fdd7e9cea6d8a5fef5" translate="yes" xml:space="preserve">
          <source>The icon will be loaded from the platform theme. If the icon is found in the theme, it will always be used; even if &lt;a href=&quot;qml-qtquick-controls2-action#icon.source-prop&quot;&gt;icon.source&lt;/a&gt; is also set. If the icon is not found, &lt;a href=&quot;qml-qtquick-controls2-action#icon.source-prop&quot;&gt;icon.source&lt;/a&gt; will be used instead.</source>
          <target state="translated">플랫폼 테마에서 아이콘이로드됩니다. 테마에 아이콘이 있으면 항상 사용됩니다. &lt;a href=&quot;qml-qtquick-controls2-action#icon.source-prop&quot;&gt;icon.source&lt;/a&gt; 도 설정되어 있어도 아이콘이 없으면 &lt;a href=&quot;qml-qtquick-controls2-action#icon.source-prop&quot;&gt;icon.source&lt;/a&gt; 가 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7cdc143325c03eb0fbb0d35943fe879bbf651c31" translate="yes" xml:space="preserve">
          <source>The icon's default size is defined by the GUI style, but can be adjusted by setting the &lt;a href=&quot;qabstractbutton#iconSize-prop&quot;&gt;iconSize&lt;/a&gt; property.</source>
          <target state="translated">아이콘의 기본 크기는 GUI 스타일에 의해 정의되지만 &lt;a href=&quot;qabstractbutton#iconSize-prop&quot;&gt;iconSize&lt;/a&gt; 속성 을 설정하여 조정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="30c574e8c79994b00618fae1884b533f4cd8c783" translate="yes" xml:space="preserve">
          <source>The icon's height will never exceed this value, though it will shrink when necessary.</source>
          <target state="translated">아이콘의 높이는이 값을 초과하지 않지만 필요한 경우 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="a6e0bb0cafc50006ae04c2f1a2e49d25915b2c3a" translate="yes" xml:space="preserve">
          <source>The icon's width will never exceed this value, though it will shrink when necessary.</source>
          <target state="translated">아이콘 너비는이 값을 초과하지 않지만 필요한 경우 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="329401e2211c58d1293f05795d037a6c0b041809" translate="yes" xml:space="preserve">
          <source>The icons are typically backend dependent, if a manager backend does not support a given size, the URL of the icon that most closely matches those parameters is returned.</source>
          <target state="translated">아이콘은 일반적으로 백엔드에 따라 다릅니다. 관리자 백엔드가 지정된 크기를 지원하지 않으면 해당 매개 변수와 가장 일치하는 아이콘의 URL이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="dc23075f8ab4fbaaccdd1cb561278e6ceab77df0" translate="yes" xml:space="preserve">
          <source>The icy blue theme.</source>
          <target state="translated">얼음 블루 테마.</target>
        </trans-unit>
        <trans-unit id="aadcb58aa510eff1fcec2eb86675c538454c117e" translate="yes" xml:space="preserve">
          <source>The idea is to enable different image format for different output format.</source>
          <target state="translated">아이디어는 다른 출력 형식에 대해 다른 이미지 형식을 활성화하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="58c01b1e1eb1b1f93f4cdad8a42c722b943019ae" translate="yes" xml:space="preserve">
          <source>The idea of unit testing is to use every class in isolation. Since many classes instantiate other classes, it is not possible to instantiate one class separately. Therefore, you should use a technique called</source>
          <target state="translated">단위 테스트의 아이디어는 모든 클래스를 격리하여 사용하는 것입니다. 많은 클래스가 다른 클래스를 인스턴스화하므로 하나의 클래스를 개별적으로 인스턴스화 할 수 없습니다. 따라서 다음과 같은 기술을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="08b4336fd53ae54afc09841d53cd0f878f8444e3" translate="yes" xml:space="preserve">
          <source>The ideal blur is achieved by selecting &lt;code&gt;samples&lt;/code&gt; and &lt;code&gt;radius&lt;/code&gt; such that &lt;code&gt;samples = 1 + radius * 2&lt;/code&gt;, such as:</source>
          <target state="translated">이상적인 흐림을 선택함으로써 달성된다 &lt;code&gt;samples&lt;/code&gt; 및 &lt;code&gt;radius&lt;/code&gt; 되도록 &lt;code&gt;samples = 1 + radius * 2&lt;/code&gt; 등 :</target>
        </trans-unit>
        <trans-unit id="384abf6172d7982942277a4a07649d4582b73085" translate="yes" xml:space="preserve">
          <source>The identifier of a development team to use for signing certificates and provisioning profiles.</source>
          <target state="translated">인증서 서명 및 프로비저닝 프로파일에 사용할 개발 팀의 식별자입니다.</target>
        </trans-unit>
        <trans-unit id="0519c99dc8c98dc802dcb483e74e4daf8ea4f438" translate="yes" xml:space="preserve">
          <source>The identifier of the image.</source>
          <target state="translated">이미지의 식별자입니다.</target>
        </trans-unit>
        <trans-unit id="38bf70fbee6fec489249517dbe19fa8f7866a0ae" translate="yes" xml:space="preserve">
          <source>The identifier of the review.</source>
          <target state="translated">리뷰의 식별자입니다.</target>
        </trans-unit>
        <trans-unit id="df654076d0c032a148f4dac0c0137cc5fda8de6c" translate="yes" xml:space="preserve">
          <source>The identifier of the server, &lt;b&gt;not&lt;/b&gt; the server address. &lt;code&gt;quint8&lt;/code&gt;</source>
          <target state="translated">서버 주소가 &lt;b&gt;아닌&lt;/b&gt; 서버의 식별자입니다 . &lt;code&gt;quint8&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b9387606e906423692393cb328eb25d148e03cce" translate="yes" xml:space="preserve">
          <source>The identifier under which an object, registered to a WebChannel, is known to remote clients.</source>
          <target state="translated">WebChannel에 등록 된 객체가 원격 클라이언트에게 알려진 식별자입니다.</target>
        </trans-unit>
        <trans-unit id="c8f779856c7325488a5aedec6af821770e285b2e" translate="yes" xml:space="preserve">
          <source>The identifiers prefixed by &lt;code&gt;FOLDERID_&lt;/code&gt; are special item ID lists to be passed to the Win32 API function &lt;code&gt;SHGetKnownFolderPath()&lt;/code&gt; to obtain the corresponding path.</source>
          <target state="translated">&lt;code&gt;FOLDERID_&lt;/code&gt; 접두사가 붙은 식별자 는 해당 경로를 얻기 위해 Win32 API 함수 &lt;code&gt;SHGetKnownFolderPath()&lt;/code&gt; 에 전달할 특수 항목 ID 목록 입니다.</target>
        </trans-unit>
        <trans-unit id="577461ba976c7779234669e24be929bf5d96a0bc" translate="yes" xml:space="preserve">
          <source>The identity hint is used in &lt;a href=&quot;qsslsocket#SslMode-enum&quot;&gt;QSslSocket::SslServerMode&lt;/a&gt; only!</source>
          <target state="translated">ID 힌트는 &lt;a href=&quot;qsslsocket#SslMode-enum&quot;&gt;QSslSocket :: SslServerMode&lt;/a&gt; 에서만 사용 됩니다!</target>
        </trans-unit>
        <trans-unit id="8450c19c91c4d645fca5b9e2a267d25c025a10d4" translate="yes" xml:space="preserve">
          <source>The identity hint, the identity and the key will be initialized to empty byte arrays; the maximum length for both the identity and the key will be initialized to 0.</source>
          <target state="translated">아이덴티티 힌트, 아이덴티티 및 키는 빈 바이트 배열로 초기화됩니다. 아이덴티티와 키의 최대 길이는 0으로 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="84161a766aa380287c1dc42771098cfcfd4b87ba" translate="yes" xml:space="preserve">
          <source>The identity of the peer can't be established.</source>
          <target state="translated">피어의 신원을 확인할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9851c420c8b6f24508a619ab4c1bbf57e4873f4f" translate="yes" xml:space="preserve">
          <source>The image above shows a ARGB pixel in memory read as an unsigned integer. However, if this pixel was read byte for byte on a little endian system the first byte would be the byte containing the B-channel. The next byte would be the G-channel, then the R-channel and finally the A-channel. This shows that on little endian systems, how each pixel is interpreted is significant for integer formats. This is not the case on big endian systems.</source>
          <target state="translated">위의 이미지는 메모리의 ARGB 픽셀을 부호없는 정수로 읽습니다. 그러나 리틀 엔디안 시스템에서이 픽셀을 바이트 단위로 읽은 경우 첫 번째 바이트는 B 채널을 포함하는 바이트입니다. 다음 바이트는 G 채널, R 채널 및 A 채널입니다. 이것은 리틀 엔디안 시스템에서 각 픽셀이 해석되는 방식이 정수 형식에 중요하다는 것을 보여줍니다. 빅 엔디안 시스템에서는 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d479512667421b7de480cc72a42b0b01de413490" translate="yes" xml:space="preserve">
          <source>The image above shows the Gaussian function with two different deviation values, yellow (1) and cyan (2.7). The y-axis shows the weights, the x-axis shows the pixel distance.</source>
          <target state="translated">위의 이미지는 노란색 (1)과 청록색 (2.7)의 두 가지 편차 값을 가진 가우스 함수를 보여줍니다. y 축은 가중치를, x 축은 픽셀 거리를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="83353174906d41b53588588c7405f2bafb8fd88e" translate="yes" xml:space="preserve">
          <source>The image below further illustrates the differences between exclusive and non-exclusive checkboxes.</source>
          <target state="translated">아래 이미지는 배타적 확인란과 비 독점적 확인란의 차이점을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="7ead47d3a97db11f3e03858e3cbead855ce78659" translate="yes" xml:space="preserve">
          <source>The image below is the output obtained with its contents margin and contents rect labeled.</source>
          <target state="translated">아래 이미지는 내용 여백과 내용 rect 레이블로 얻은 출력입니다.</target>
        </trans-unit>
        <trans-unit id="185dbd9825fe7fceb732768701a152a852803913" translate="yes" xml:space="preserve">
          <source>The image below shows the difference between geomagnetic (on the left) and raw (on the right) readings for a phone that is being subjected to magnetic interference.</source>
          <target state="translated">아래 이미지는 자기 간섭을받는 전화기의 지자기 (왼쪽)와 원시 (오른쪽) 판독 값의 차이를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="58e80698188aa682ccb69353be24c94cbfc611cd" translate="yes" xml:space="preserve">
          <source>The image can be inserted into the document using the &lt;a href=&quot;qtextcursor&quot;&gt;QTextCursor&lt;/a&gt; API:</source>
          <target state="translated">&lt;a href=&quot;qtextcursor&quot;&gt;QTextCursor&lt;/a&gt; API를 사용하여 이미지를 문서에 삽입 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="236435db3c4c4f35265fb868c92940f5b38c55ee" translate="yes" xml:space="preserve">
          <source>The image can be uploaded into a texture atlas.</source>
          <target state="translated">이미지를 텍스처 아틀라스에 업로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="35727aaf6cf3b524b140732ea43b01f5b226714d" translate="yes" xml:space="preserve">
          <source>The image data was invalid, and &lt;a href=&quot;qimagereader&quot;&gt;QImageReader&lt;/a&gt; was unable to read an image from it. The can happen if the image file is damaged.</source>
          <target state="translated">이미지 데이터가 유효하지 &lt;a href=&quot;qimagereader&quot;&gt;않아 QImageReader&lt;/a&gt; 가 이미지를 읽을 수 없습니다. 이미지 파일이 손상된 경우 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c634195e740ea54442073a3c6ba0dcb7d5286250" translate="yes" xml:space="preserve">
          <source>The image depth is the number of bits used to store a single pixel, also called bits per pixel (bpp).</source>
          <target state="translated">이미지 깊이는 단일 픽셀 (bpp)이라고도하는 단일 픽셀을 저장하는 데 사용되는 비트 수입니다.</target>
        </trans-unit>
        <trans-unit id="9ba08967be13b9325387fe53eafc54788a926001" translate="yes" xml:space="preserve">
          <source>The image description. Some image formats, such as GIF and PNG, allow embedding of text or comments into the image data (e.g., for storing copyright information). It's common that the text is stored in key-value pairs, but some formats store all text in one continuous block. &lt;a href=&quot;qimageiohandler&quot;&gt;QImageIOHandler&lt;/a&gt; returns the text as one &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;, where keys and values are separated by a ':', and keys-value pairs are separated by two newlines (\n\n). For example, &quot;Title: Sunset\n\nAuthor: Jim Smith\nSarah Jones\n\n&quot;. Formats that store text in a single block can use &quot;Description&quot; as the key.</source>
          <target state="translated">이미지 설명. GIF 및 PNG와 같은 일부 이미지 형식을 사용하면 이미지 데이터에 텍스트 또는 주석을 포함시킬 수 있습니다 (예 : 저작권 정보 저장). 텍스트는 키-값 쌍으로 저장되는 것이 일반적이지만 일부 형식은 모든 텍스트를 하나의 연속 블록에 저장합니다. &lt;a href=&quot;qimageiohandler&quot;&gt;QImageIOHandler&lt;/a&gt; 는 텍스트를 하나의 &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; 으로 반환합니다 . 여기서 키와 값은 ':'으로 구분되고 키-값 쌍은 두 줄 바꿈 (\ n \ n)으로 구분됩니다. 예를 들어 &quot;제목 : 일몰 \ n \ n 저자 : Jim Smith \ nSarah Jones \ n \ n&quot;입니다. 단일 블록에 텍스트를 저장하는 형식은 &quot;설명&quot;을 키로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="397ba2ca81fb9eeb5fe9cc116523614c1d5a6322" translate="yes" xml:space="preserve">
          <source>The image files are named using the following convention:</source>
          <target state="translated">이미지 파일은 다음 규칙을 사용하여 이름이 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="5b25b187d64272814e18c8098cbf5a5b5fa883fa" translate="yes" xml:space="preserve">
          <source>The image files can be found in the underlying directory &lt;code&gt;images&lt;/code&gt;.</source>
          <target state="translated">이미지 파일은 기본 디렉토리 &lt;code&gt;images&lt;/code&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2487ed5fc32f81c5dcfdf4180f2fb90286b51814" translate="yes" xml:space="preserve">
          <source>The image is invalid.</source>
          <target state="translated">이미지가 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2c61f5e0ea63c4e740300897bbde83eb25b12ed9" translate="yes" xml:space="preserve">
          <source>The image is stored using 1-bit per pixel. Bytes are packed with the less significant bit (LSB) first.</source>
          <target state="translated">이미지는 픽셀 당 1 비트를 사용하여 저장됩니다. 바이트는 LSB (Least Significant Bit)로 먼저 압축됩니다.</target>
        </trans-unit>
        <trans-unit id="8684c2bc2452e244c1e9bebdab7fd240cf39a13b" translate="yes" xml:space="preserve">
          <source>The image is stored using 1-bit per pixel. Bytes are packed with the most significant bit (MSB) first.</source>
          <target state="translated">이미지는 픽셀 당 1 비트를 사용하여 저장됩니다. 바이트는 최상위 비트 (MSB)로 먼저 압축됩니다.</target>
        </trans-unit>
        <trans-unit id="0cf01f97cefc622dea94c98119cc55677fb40ae3" translate="yes" xml:space="preserve">
          <source>The image is stored using 8-bit indexes into a colormap.</source>
          <target state="translated">이미지는 8 비트 인덱스를 사용하여 컬러 맵에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="125177b3843e58794fce9f4f21801b2e94d8d9d4" translate="yes" xml:space="preserve">
          <source>The image is stored using a 16-bit RGB format (4-4-4). The unused bits are always zero.</source>
          <target state="translated">이미지는 16 비트 RGB 형식 (4-4-4)을 사용하여 저장됩니다. 사용하지 않는 비트는 항상 0입니다.</target>
        </trans-unit>
        <trans-unit id="00041104be39572ef387821d73dc523437391474" translate="yes" xml:space="preserve">
          <source>The image is stored using a 16-bit RGB format (5-5-5). The unused most significant bit is always zero.</source>
          <target state="translated">이미지는 16 비트 RGB 형식 (5-5-5)을 사용하여 저장됩니다. 사용되지 않은 최상위 비트는 항상 0입니다.</target>
        </trans-unit>
        <trans-unit id="41344d5a9db6848922cdeb472276aaabd871507e" translate="yes" xml:space="preserve">
          <source>The image is stored using a 16-bit RGB format (5-6-5).</source>
          <target state="translated">이미지는 16 비트 RGB 형식 (5-6-5)을 사용하여 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="daa835a8d2d7191bab1a0ed956a60f9f26572a6d" translate="yes" xml:space="preserve">
          <source>The image is stored using a 24-bit BGR format. (added in Qt 5.14)</source>
          <target state="translated">이미지는 24 비트 BGR 형식을 사용하여 저장됩니다. (Qt 5.14에 추가됨)</target>
        </trans-unit>
        <trans-unit id="d1771ccd31a25cc136372496377bbbd18d33d495" translate="yes" xml:space="preserve">
          <source>The image is stored using a 24-bit RGB format (6-6-6). The unused most significant bits is always zero.</source>
          <target state="translated">이미지는 24 비트 RGB 형식 (6-6-6)을 사용하여 저장됩니다. 사용되지 않은 최상위 비트는 항상 0입니다.</target>
        </trans-unit>
        <trans-unit id="6cfd1a789555a7056e16b422e948605baffa26bd" translate="yes" xml:space="preserve">
          <source>The image is stored using a 24-bit RGB format (8-8-8).</source>
          <target state="translated">이미지는 24 비트 RGB 형식 (8-8-8)을 사용하여 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="354afea1a3914ef737517a05e160420b06a86ae2" translate="yes" xml:space="preserve">
          <source>The image is stored using a 32-bit ARGB format (0xAARRGGBB).</source>
          <target state="translated">이미지는 32 비트 ARGB 형식 (0xAARRGGBB)을 사용하여 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="04b3d796650274e446cee555ae0481487d52c3a4" translate="yes" xml:space="preserve">
          <source>The image is stored using a 32-bit BGR format (x-10-10-10). (added in Qt 5.4)</source>
          <target state="translated">이미지는 32 비트 BGR 형식 (x-10-10-10)을 사용하여 저장됩니다. (Qt 5.4에 추가)</target>
        </trans-unit>
        <trans-unit id="a15291d07b446da67dbd30ada0ce167e164b8b4a" translate="yes" xml:space="preserve">
          <source>The image is stored using a 32-bit RGB format (0xffRRGGBB).</source>
          <target state="translated">이미지는 32 비트 RGB 형식 (0xffRRGGBB)을 사용하여 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="b598e61fcc5c3bfcaa05e45b29676f89954bf4b0" translate="yes" xml:space="preserve">
          <source>The image is stored using a 32-bit RGB format (x-10-10-10). (added in Qt 5.4)</source>
          <target state="translated">이미지는 32 비트 RGB 형식 (x-10-10-10)을 사용하여 저장됩니다. (Qt 5.4에 추가)</target>
        </trans-unit>
        <trans-unit id="0cc29cbccb500d3a3fb7e38afaaafb2f89ffe2ab" translate="yes" xml:space="preserve">
          <source>The image is stored using a 32-bit byte-ordered RGB(x) format (8-8-8-8). This is the same as the Format_RGBA8888 except alpha must always be 255. (added in Qt 5.2)</source>
          <target state="translated">이미지는 32 비트 바이트 순서 RGB (x) 형식 (8-8-8-8)을 사용하여 저장됩니다. 알파는 항상 255 여야한다는 점을 제외하면 Format_RGBA8888과 동일합니다. (Qt 5.2에 추가됨)</target>
        </trans-unit>
        <trans-unit id="c798c85d9395aea0ac72a08ba4da9d07777ce091" translate="yes" xml:space="preserve">
          <source>The image is stored using a 32-bit byte-ordered RGBA format (8-8-8-8). Unlike ARGB32 this is a byte-ordered format, which means the 32bit encoding differs between big endian and little endian architectures, being respectively (0xRRGGBBAA) and (0xAABBGGRR). The order of the colors is the same on any architecture if read as bytes 0xRR,0xGG,0xBB,0xAA. (added in Qt 5.2)</source>
          <target state="translated">이미지는 32 비트 바이트 순서 RGBA 형식 (8-8-8-8)을 사용하여 저장됩니다. ARGB32와 달리 이것은 바이트 순서 형식으로, 32 비트 인코딩은 빅 엔디안 아키텍처와 리틀 엔디안 아키텍처가 각각 (0xRRGGBBAA)와 (0xAABBGGRR)입니다. 바이트 0xRR, 0xGG, 0xBB, 0xAA로 읽을 경우 색상의 순서는 모든 아키텍처에서 동일합니다. (Qt 5.2에 추가)</target>
        </trans-unit>
        <trans-unit id="3be7d0aa0554b79d1adbf4d14b86d8f7b77924a9" translate="yes" xml:space="preserve">
          <source>The image is stored using a 32-bit premultiplied ABGR format (2-10-10-10). (added in Qt 5.4)</source>
          <target state="translated">이미지는 32 비트 미리 곱한 ABGR 형식 (2-10-10-10)을 사용하여 저장됩니다. (Qt 5.4에 추가)</target>
        </trans-unit>
        <trans-unit id="361a2c5b7436b66725488b06c80364a94507bb6d" translate="yes" xml:space="preserve">
          <source>The image is stored using a 32-bit premultiplied ARGB format (2-10-10-10). (added in Qt 5.4)</source>
          <target state="translated">이미지는 32 비트 미리 곱한 ARGB 형식 (2-10-10-10)을 사용하여 저장됩니다. (Qt 5.4에 추가)</target>
        </trans-unit>
        <trans-unit id="e61672ae290e06d3ec15d2bec1883a393d5e1252" translate="yes" xml:space="preserve">
          <source>The image is stored using a 64-bit halfword-ordered RGB(x) format (16-16-16-16). This is the same as the Format_RGBA64 except alpha must always be 65535. (added in Qt 5.12)</source>
          <target state="translated">이미지는 64 비트 하프 워드로 정렬 된 RGB (x) 형식 (16-16-16-16)을 사용하여 저장됩니다. 알파가 항상 65535 여야한다는 점을 제외하면 Format_RGBA64와 동일합니다. (Qt 5.12에 추가됨)</target>
        </trans-unit>
        <trans-unit id="d6b2984c5edc75dd31659bc318211adff388093f" translate="yes" xml:space="preserve">
          <source>The image is stored using a 64-bit halfword-ordered RGB(x) format (16-16-16-16). This is the same as the Format_RGBX64 except alpha must always be 65535. (added in Qt 5.12)</source>
          <target state="translated">이미지는 64 비트 하프 워드 순서 RGB (x) 형식 (16-16-16-16)을 사용하여 저장됩니다. 알파는 항상 65535 여야한다는 점을 제외하면 Format_RGBX64와 동일합니다 (Qt 5.12에 추가됨).</target>
        </trans-unit>
        <trans-unit id="dca03347fd45a3db0c5528ffe3b0a2e99a19f0dd" translate="yes" xml:space="preserve">
          <source>The image is stored using a 64-bit halfword-ordered RGBA format (16-16-16-16). (added in Qt 5.12)</source>
          <target state="translated">이미지는 64 비트 하프 워드로 정렬 된 RGBA 형식 (16-16-16-16)을 사용하여 저장됩니다. (Qt 5.12에 추가)</target>
        </trans-unit>
        <trans-unit id="d59a6c8f2eeb2f6ef0dc86de7f444242df12f26d" translate="yes" xml:space="preserve">
          <source>The image is stored using a premultiplied 16-bit ARGB format (4-4-4-4).</source>
          <target state="translated">이미지는 미리 곱한 16 비트 ARGB 형식 (4-4-4-4)을 사용하여 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="f49b89c9d4a07e6a787545fa5b041ba3da4037ec" translate="yes" xml:space="preserve">
          <source>The image is stored using a premultiplied 24-bit ARGB format (6-6-6-6).</source>
          <target state="translated">이미지는 미리 곱한 24 비트 ARGB 형식 (6-6-6-6)을 사용하여 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="5000a37c7eaae3ad3f16c7989abe2a9af494f16f" translate="yes" xml:space="preserve">
          <source>The image is stored using a premultiplied 24-bit ARGB format (8-5-5-5).</source>
          <target state="translated">이미지는 미리 곱한 24 비트 ARGB 형식 (8-5-5-5)을 사용하여 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="cadb430d890d4558863776bc4cad47ed01c56918" translate="yes" xml:space="preserve">
          <source>The image is stored using a premultiplied 24-bit ARGB format (8-5-6-5).</source>
          <target state="translated">이미지는 미리 곱한 24 비트 ARGB 형식 (8-5-6-5)을 사용하여 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="3436ccaaf6c73f7176aa2c493267588dad095c10" translate="yes" xml:space="preserve">
          <source>The image is stored using a premultiplied 32-bit ARGB format (0xAARRGGBB), i.e. the red, green, and blue channels are multiplied by the alpha component divided by 255. (If RR, GG, or BB has a higher value than the alpha channel, the results are undefined.) Certain operations (such as image composition using alpha blending) are faster using premultiplied ARGB32 than with plain ARGB32.</source>
          <target state="translated">미리 곱한 32 비트 ARGB 형식 (0xAARRGGBB)을 사용하여 이미지가 저장됩니다. 즉, 빨강, 녹색 및 파랑 채널에 255로 나눈 알파 구성 요소가 곱해집니다 (RR, GG 또는 BB의 값이 알파보다 높은 경우) 알파 블렌딩을 사용한 이미지 구성과 같은 특정 작업은 일반 ARGB32보다 미리 곱한 ARGB32를 사용하는 것이 더 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="7ae680400d433c002058d604690d84659b7c4db6" translate="yes" xml:space="preserve">
          <source>The image is stored using a premultiplied 32-bit byte-ordered RGBA format (8-8-8-8). (added in Qt 5.2)</source>
          <target state="translated">이미지는 미리 곱셈 된 32 비트 바이트 순서 RGBA 형식 (8-8-8-8)을 사용하여 저장됩니다. (Qt 5.2에 추가)</target>
        </trans-unit>
        <trans-unit id="6ca44d5a972415c108450ca8d74ef49334111a1c" translate="yes" xml:space="preserve">
          <source>The image is stored using a premultiplied 64-bit halfword-ordered RGBA format (16-16-16-16). (added in Qt 5.12)</source>
          <target state="translated">이미지는 미리 곱셈 된 64 비트 하프 워드 순서 RGBA 형식 (16-16-16-16)을 사용하여 저장됩니다. (Qt 5.12에 추가)</target>
        </trans-unit>
        <trans-unit id="657f64dec19e60c3657a687ecc40ccf7755dea1f" translate="yes" xml:space="preserve">
          <source>The image is stored using an 16-bit grayscale format. (added in Qt 5.13)</source>
          <target state="translated">이미지는 16 비트 회색조 형식으로 저장됩니다. (Qt 5.13에 추가됨)</target>
        </trans-unit>
        <trans-unit id="16585830f608a37d439b9b2f4ef805ebc398596d" translate="yes" xml:space="preserve">
          <source>The image is stored using an 8-bit alpha only format. (added in Qt 5.5)</source>
          <target state="translated">이미지는 8 비트 알파 전용 형식으로 저장됩니다. (Qt 5.5에 추가)</target>
        </trans-unit>
        <trans-unit id="2518ad2f7a186c98b6954876d5026179dcf6321b" translate="yes" xml:space="preserve">
          <source>The image is stored using an 8-bit grayscale format. (added in Qt 5.5)</source>
          <target state="translated">이미지는 8 비트 회색조 형식으로 저장됩니다. (Qt 5.5에 추가)</target>
        </trans-unit>
        <trans-unit id="00899d46b60b3ead594ea4031c71af14dd9b982e" translate="yes" xml:space="preserve">
          <source>The image name refers to an entry in the application's resource file. The method used to derive this name is described in &lt;a href=&quot;resources&quot;&gt;The Qt Resource System&lt;/a&gt;.</source>
          <target state="translated">이미지 이름은 응용 프로그램의 리소스 파일에있는 항목을 나타냅니다. 이 이름을 파생시키는 데 사용되는 방법 &lt;a href=&quot;resources&quot;&gt;은 Qt 리소스 시스템에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed31930d270985d39df02b7418e62466d13b61fd" translate="yes" xml:space="preserve">
          <source>The image property accepts a list of &lt;a href=&quot;#url&quot;&gt;Url&lt;/a&gt;s or an &lt;code&gt;svg&lt;/code&gt;. The actual image that is drawn is determined using the same algorithm as &lt;a href=&quot;qicon&quot;&gt;QIcon&lt;/a&gt; (i.e) the image is never scaled up but always scaled down if necessary. If a &lt;code&gt;svg&lt;/code&gt; is specified, the image is scaled to the size of the contents rectangle.</source>
          <target state="translated">image 속성은 &lt;a href=&quot;#url&quot;&gt;Url&lt;/a&gt; 또는 &lt;code&gt;svg&lt;/code&gt; 목록을 허용합니다 . 그려진 실제 이미지는 &lt;a href=&quot;qicon&quot;&gt;QIcon&lt;/a&gt; 과 동일한 알고리즘을 사용하여 결정됩니다 (즉, 이미지는 절대 확대되지 않지만 필요한 경우 항상 축소됩니다. 경우 &lt;code&gt;svg&lt;/code&gt; 지정한 이미지가 내용 사각형의 크기로 조정됩니다.</target>
        </trans-unit>
        <trans-unit id="72766bd27c907fdc10f92b5887354e71244fc8aa" translate="yes" xml:space="preserve">
          <source>The image property accepts a list of &lt;a href=&quot;stylesheet-reference#url&quot;&gt;Url&lt;/a&gt;s or an &lt;code&gt;svg&lt;/code&gt;. The actual image that is drawn is determined using the same algorithm as &lt;a href=&quot;qicon&quot;&gt;QIcon&lt;/a&gt; (i.e) the image is never scaled up but always scaled down if necessary. If a &lt;code&gt;svg&lt;/code&gt; is specified, the image is scaled to the size of the contents rectangle.</source>
          <target state="translated">image 속성은 &lt;a href=&quot;stylesheet-reference#url&quot;&gt;Url&lt;/a&gt; 또는 &lt;code&gt;svg&lt;/code&gt; 목록을 허용합니다 . 그려지는 실제 이미지는 &lt;a href=&quot;qicon&quot;&gt;QIcon&lt;/a&gt; 과 동일한 알고리즘을 사용하여 결정됩니다. 즉, 이미지는 절대 확대되지 않지만 필요한 경우 항상 축소됩니다. 경우 &lt;code&gt;svg&lt;/code&gt; 지정한 이미지가 내용 사각형의 크기로 조정됩니다.</target>
        </trans-unit>
        <trans-unit id="b7bf33a7a0fa0f83dabce12735258a55e89ff2bf" translate="yes" xml:space="preserve">
          <source>The image source for the animation.</source>
          <target state="translated">애니메이션의 이미지 소스입니다.</target>
        </trans-unit>
        <trans-unit id="1da1c2a84bd5d3e7b2cb7403982498b0523b17bc" translate="yes" xml:space="preserve">
          <source>The image text is embedded into the image data when you call &lt;a href=&quot;qimage#save&quot;&gt;save&lt;/a&gt;() or &lt;a href=&quot;qimagewriter#write&quot;&gt;QImageWriter::write&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qimage#save&quot;&gt;save&lt;/a&gt; () 또는 &lt;a href=&quot;qimagewriter#write&quot;&gt;QImageWriter :: write&lt;/a&gt; () 를 호출 하면 이미지 텍스트가 이미지 데이터에 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="68b369cfb8824d8d0bad29cf5e58df451e191ed5" translate="yes" xml:space="preserve">
          <source>The image that is drawn in the contents rectangle of a subcontrol.</source>
          <target state="translated">하위 컨트롤의 내용 사각형에 그려진 이미지입니다.</target>
        </trans-unit>
        <trans-unit id="61c566431ecfaa78b8c6e3d93370ae248ded250d" translate="yes" xml:space="preserve">
          <source>The image that is loaded by an icon whose &lt;code&gt;width&lt;/code&gt; and &lt;code&gt;height&lt;/code&gt; are not set depends on the type of icon in use. For theme icons, the closest available size will be chosen. For regular icons, the behavior is the same as the &lt;a href=&quot;qml-qtquick-image#sourceSize-prop&quot;&gt;sourceSize&lt;/a&gt; property of &lt;a href=&quot;qml-qtquick-image&quot;&gt;Image&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;width&lt;/code&gt; 와 &lt;code&gt;height&lt;/code&gt; 가 설정되지 않은 아이콘으로로드되는 이미지 는 사용중인 아이콘 유형에 따라 다릅니다. 테마 아이콘의 경우 가장 가까운 크기가 선택됩니다. 일반 아이콘의 경우 동작은 &lt;a href=&quot;qml-qtquick-image&quot;&gt;Image&lt;/a&gt; 의 &lt;a href=&quot;qml-qtquick-image#sourceSize-prop&quot;&gt;sourceSize&lt;/a&gt; 속성과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="c59bf55f38121b6d6d5418fc865af585570756ee" translate="yes" xml:space="preserve">
          <source>The image to use as the mask. Areas with non-zero opacity will be considered inside the shape.</source>
          <target state="translated">마스크로 사용할 이미지입니다. 불투명도가 0이 아닌 영역은 모양 내부에서 고려됩니다.</target>
        </trans-unit>
        <trans-unit id="4df75488f73e5adb68699d0401de416da9770039" translate="yes" xml:space="preserve">
          <source>The image used to fill the border. The image is cut into nine parts and stretched appropriately if necessary. See &lt;a href=&quot;#border-image&quot;&gt;Border Image&lt;/a&gt; for details.</source>
          <target state="translated">테두리를 채우는 데 사용되는 이미지입니다. 이미지는 9 개의 부분으로 잘리고 필요한 경우 적절하게 늘어납니다. 자세한 내용은 &lt;a href=&quot;#border-image&quot;&gt;테두리 이미지&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c113b84889861bfca05320016a1a21e32a4f09b3" translate="yes" xml:space="preserve">
          <source>The image used to fill the border. The image is cut into nine parts and stretched appropriately if necessary. See &lt;a href=&quot;stylesheet-reference#border-image&quot;&gt;Border Image&lt;/a&gt; for details.</source>
          <target state="translated">테두리를 채우는 데 사용되는 이미지입니다. 이미지는 9 개 부분으로 잘리고 필요한 경우 적절하게 늘어납니다. 자세한 내용은 &lt;a href=&quot;stylesheet-reference#border-image&quot;&gt;테두리 이미지&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="bd5733e4d3bb29905160c42fc57781e57f3429d2" translate="yes" xml:space="preserve">
          <source>The image will be captured to the default system location, typically &lt;a href=&quot;qstandardpaths#writableLocation&quot;&gt;QStandardPaths::writableLocation&lt;/a&gt;(&lt;a href=&quot;qstandardpaths#StandardLocation-enum&quot;&gt;QStandardPaths::PicturesLocation&lt;/a&gt;) for still imaged or &lt;a href=&quot;qstandardpaths#writableLocation&quot;&gt;QStandardPaths::writableLocation&lt;/a&gt;(&lt;a href=&quot;qstandardpaths#StandardLocation-enum&quot;&gt;QStandardPaths::MoviesLocation&lt;/a&gt;) for video.</source>
          <target state="translated">이미지는 기본 시스템 위치에 캡처됩니다 일반적으로 &lt;a href=&quot;qstandardpaths#writableLocation&quot;&gt;QStandardPaths :: writableLocation&lt;/a&gt; ( &lt;a href=&quot;qstandardpaths#StandardLocation-enum&quot;&gt;QStandardPaths :: PicturesLocation&lt;/a&gt; ) 아직 몇 군데 나에 대한 &lt;a href=&quot;qstandardpaths#writableLocation&quot;&gt;QStandardPaths :: writableLocation&lt;/a&gt; ( &lt;a href=&quot;qstandardpaths#StandardLocation-enum&quot;&gt;QStandardPaths :: MoviesLocation&lt;/a&gt; ) 비디오.</target>
        </trans-unit>
        <trans-unit id="1da1e52926d21c0b3ed85294b73ca1d9c75db3f1" translate="yes" xml:space="preserve">
          <source>The image's data format returned by the handler. This can be any of the formats listed in &lt;a href=&quot;qimage#Format-enum&quot;&gt;QImage::Format&lt;/a&gt;.</source>
          <target state="translated">핸들러가 리턴 한 이미지의 데이터 형식입니다. 이것은 &lt;a href=&quot;qimage#Format-enum&quot;&gt;QImage :: Format에&lt;/a&gt; 나열된 형식 중 하나 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="14d4ce979843e26f822f55986fa416e15fa78852" translate="yes" xml:space="preserve">
          <source>The images and meta-data in an image collection</source>
          <target state="translated">이미지 콜렉션의 이미지 및 메타 데이터</target>
        </trans-unit>
        <trans-unit id="3310566f8d744b6c4c52ffba77442783049a039d" translate="yes" xml:space="preserve">
          <source>The images can be added to the Info.plist as follows:</source>
          <target state="translated">다음과 같이 이미지를 Info.plist에 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="38d7506bb442c3d4fbc9eae767b04f1092499ca1" translate="yes" xml:space="preserve">
          <source>The images.fileextensions variable filters the files within an image directory.</source>
          <target state="translated">images.fileextensions 변수는 이미지 디렉토리 내의 파일을 필터링합니다.</target>
        </trans-unit>
        <trans-unit id="33e9fc5abdf403f2a25a28e2ee6177b4801372b9" translate="yes" xml:space="preserve">
          <source>The immediate evaluation scope can be summarized by saying that it contains:</source>
          <target state="translated">즉각적인 평가 범위는 다음을 포함하여 요약 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f55dafc116cf8a5231ca4563b9980755233d1d39" translate="yes" xml:space="preserve">
          <source>The impatient reader, who right away wants to see a &lt;a href=&quot;qpushbutton&quot;&gt;QPushButton&lt;/a&gt; and a custom Qt widget (&lt;a href=&quot;https://doc.qt.io/qt-5.13/activeqt-activeqt-multiple-example.html#&quot;&gt;QAxWidget2&lt;/a&gt;) run in a .NET GUI application is referred to the example directory of &lt;a href=&quot;activeqt-index#&quot;&gt;ActiveQt&lt;/a&gt;. It contains the result of this walkthrough using both C# and VB.NET, created with Visual Studio .NET (not 2003). Load &lt;code&gt;examples/dotnet/walkthrough/csharp.csproj&lt;/code&gt;, &lt;code&gt;examples/dotnet/walkthrough/vb.vbproj&lt;/code&gt; or &lt;code&gt;examples/dotnet/wrapper/wrapper.sln&lt;/code&gt; into the IDE and run the solution.</source>
          <target state="translated">&lt;a href=&quot;qpushbutton&quot;&gt;QPushButton&lt;/a&gt; 및 .NET GUI 애플리케이션에서 실행 되는 사용자 정의 Qt 위젯 ( &lt;a href=&quot;https://doc.qt.io/qt-5.13/activeqt-activeqt-multiple-example.html#&quot;&gt;QAxWidget2&lt;/a&gt; ) 을 바로보고 싶어하는 초조 한 독자 는 &lt;a href=&quot;activeqt-index#&quot;&gt;ActiveQt&lt;/a&gt; 의 예제 디렉토리로 참조 됩니다. 여기에는 Visual Studio .NET (2003이 아님)으로 만든 C # 및 VB.NET을 사용한이 연습 결과가 포함되어 있습니다. 로드 &lt;code&gt;examples/dotnet/walkthrough/csharp.csproj&lt;/code&gt; , &lt;code&gt;examples/dotnet/walkthrough/vb.vbproj&lt;/code&gt; 또는 &lt;code&gt;examples/dotnet/wrapper/wrapper.sln&lt;/code&gt; IDE에와 솔루션을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="11806a9b7e2b569cd43c6e8d40bf74500a91f774" translate="yes" xml:space="preserve">
          <source>The impatient reader, who right away wants to see a &lt;a href=&quot;qpushbutton&quot;&gt;QPushButton&lt;/a&gt; and a custom Qt widget (&lt;a href=&quot;https://doc.qt.io/qt-5.15/activeqt-activeqt-multiple-example.html&quot;&gt;QAxWidget2&lt;/a&gt;) run in a .NET GUI application is referred to the example directory of &lt;a href=&quot;activeqt-index&quot;&gt;ActiveQt&lt;/a&gt;. It contains the result of this walkthrough using both C# and VB.NET, created with Visual Studio .NET (not 2003). Load &lt;code&gt;examples/dotnet/walkthrough/csharp.csproj&lt;/code&gt;, &lt;code&gt;examples/dotnet/walkthrough/vb.vbproj&lt;/code&gt; or &lt;code&gt;examples/dotnet/wrapper/wrapper.sln&lt;/code&gt; into the IDE and run the solution.</source>
          <target state="translated">.NET GUI 애플리케이션에서 실행 되는 &lt;a href=&quot;qpushbutton&quot;&gt;QPushButton&lt;/a&gt; 및 사용자 정의 Qt 위젯 ( &lt;a href=&quot;https://doc.qt.io/qt-5.15/activeqt-activeqt-multiple-example.html&quot;&gt;QAxWidget2&lt;/a&gt; ) 을 즉시보고 싶어하는 참을성이없는 독자 는 &lt;a href=&quot;activeqt-index&quot;&gt;ActiveQt&lt;/a&gt; 의 예제 디렉토리를 참조 합니다. 여기에는 Visual Studio .NET (2003이 아님)으로 만든 C # 및 VB.NET을 모두 사용한이 연습의 결과가 포함되어 있습니다. 로드 &lt;code&gt;examples/dotnet/walkthrough/csharp.csproj&lt;/code&gt; , &lt;code&gt;examples/dotnet/walkthrough/vb.vbproj&lt;/code&gt; 또는 &lt;code&gt;examples/dotnet/wrapper/wrapper.sln&lt;/code&gt; IDE에와 솔루션을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="3d93cf64b7db4d4bf0d426a787b20406d9ef9cf7" translate="yes" xml:space="preserve">
          <source>The implementation currently passes 42% of W3C's XSLT test suite, which focus on features introduced in XSLT 2.0.</source>
          <target state="translated">이 구현은 현재 XSLT 2.0에 도입 된 기능에 중점을 둔 W3C XSLT 테스트 스위트의 42 %를 통과했습니다.</target>
        </trans-unit>
        <trans-unit id="615a2a24d917d2baac4de6712a61c98ac3bf16b4" translate="yes" xml:space="preserve">
          <source>The implementation for the &lt;code&gt;Message&lt;/code&gt; type in the &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtcore-tools-customtype-example.html#&quot;&gt;Custom Type Example&lt;/a&gt; goes to some effort to make the printable representation as readable as possible:</source>
          <target state="translated">&lt;a href=&quot;https://doc.qt.io/qt-5.13/qtcore-tools-customtype-example.html#&quot;&gt;사용자 정의 유형 예&lt;/a&gt; 에서 &lt;code&gt;Message&lt;/code&gt; 유형에 대한 구현 은 인쇄 가능한 표현을 가능한 한 읽을 수 있도록하기 위해 노력합니다.</target>
        </trans-unit>
        <trans-unit id="5aaf2e2ecaac06d1f4458d60fb972b51372ae9f6" translate="yes" xml:space="preserve">
          <source>The implementation for the &lt;code&gt;Message&lt;/code&gt; type in the &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtcore-tools-customtype-example.html&quot;&gt;Custom Type Example&lt;/a&gt; goes to some effort to make the printable representation as readable as possible:</source>
          <target state="translated">&lt;a href=&quot;https://doc.qt.io/qt-5.15/qtcore-tools-customtype-example.html&quot;&gt;사용자 정의 유형 예제&lt;/a&gt; 에서 &lt;code&gt;Message&lt;/code&gt; 유형에 대한 구현 은 인쇄 가능한 표현을 가능한 한 읽기 쉽게 만들기 위해 노력합니다.</target>
        </trans-unit>
        <trans-unit id="41833b7611a5d964a6982d6b4b2ff6218a361c80" translate="yes" xml:space="preserve">
          <source>The implementation for the &lt;code&gt;Message&lt;/code&gt; type in the &lt;a href=&quot;https://doc.qt.io/qt-6.0/qtcore-tools-customtype-example.html&quot;&gt;Custom Type Example&lt;/a&gt; goes to some effort to make the printable representation as readable as possible:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e746d45215a497a1306946a89ee1736fab198b7" translate="yes" xml:space="preserve">
          <source>The implementation guarantees to return a valid &lt;a href=&quot;qurl&quot;&gt;QUrl&lt;/a&gt;, or a default constructed &lt;a href=&quot;qurl&quot;&gt;QUrl&lt;/a&gt;. If a node has no base URI, as in the case where a comment has no parent, a default constructed &lt;a href=&quot;qurl&quot;&gt;QUrl&lt;/a&gt; is returned.</source>
          <target state="translated">구현시 유효한 &lt;a href=&quot;qurl&quot;&gt;QUrl&lt;/a&gt; 또는 기본 생성 된 &lt;a href=&quot;qurl&quot;&gt;QUrl&lt;/a&gt; 을 반환합니다 . 주석에 부모가없는 경우와 같이 노드에 기본 URI가없는 경우 기본 생성 된 &lt;a href=&quot;qurl&quot;&gt;QUrl&lt;/a&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="84fee9b487ff911e732edf9b78f7b349a9f4a073" translate="yes" xml:space="preserve">
          <source>The implementation is handled in such a way that object slicing is not an issue.</source>
          <target state="translated">구현은 객체 슬라이싱이 문제가되지 않는 방식으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="ed2bbf359b2b56abcf76136db564e83285986e14" translate="yes" xml:space="preserve">
          <source>The implementation is handled in such a way that object slicing is not an issue. It is not expected that client applications or backend plugins instantiate a &lt;a href=&quot;qplacesearchresult&quot;&gt;QPlaceSearchResult&lt;/a&gt; directly, but rather client applications simply convert to search result subclasses and backend plugins only instantiate subclasses.</source>
          <target state="translated">구현은 객체 슬라이싱이 문제가되지 않는 방식으로 처리됩니다. 클라이언트 애플리케이션 또는 백엔드 플러그인이 &lt;a href=&quot;qplacesearchresult&quot;&gt;QPlaceSearchResult를&lt;/a&gt; 직접 인스턴스화 하지는 않지만 클라이언트 애플리케이션은 단순히 검색 결과 서브 클래스로 변환하고 백엔드 플러그인은 서브 클래스 만 인스턴스화합니다.</target>
        </trans-unit>
        <trans-unit id="7724575e64a5ea5be1e6fa0fad57c3c1fa11189a" translate="yes" xml:space="preserve">
          <source>The implementation is handled in such a way that object slicing is not an issue. It is not expected that client applications or backend plugins instantiate a QPlaceSearchResult directly, but rather client applications simply convert to search result subclasses and backend plugins only instantiate subclasses.</source>
          <target state="translated">구현은 객체 슬라이싱이 문제가되지 않는 방식으로 처리됩니다. 클라이언트 애플리케이션 또는 백엔드 플러그인이 QPlaceSearchResult를 직접 인스턴스화하는 것이 아니라 클라이언트 애플리케이션이 단순히 검색 결과 하위 클래스로 변환하고 백엔드 플러그인은 하위 클래스 만 인스턴스화합니다.</target>
        </trans-unit>
        <trans-unit id="7d54c4633e15d1c87b8ccf393ca10bb1c8d955d0" translate="yes" xml:space="preserve">
          <source>The implementation must be prepared that a call to this function may be followed by a new call to &lt;a href=&quot;qvulkanwindowrenderer#initSwapChainResources&quot;&gt;initSwapChainResources&lt;/a&gt;() at a later point.</source>
          <target state="translated">이 함수에 대한 호출 다음에 &lt;a href=&quot;qvulkanwindowrenderer#initSwapChainResources&quot;&gt;initSwapChainResources&lt;/a&gt; () 에 대한 새로운 호출이 뒤따를 수 있도록 구현을 준비해야합니다 .</target>
        </trans-unit>
        <trans-unit id="d6d1f47962631610e72f0bf909ce849d7acf4c76" translate="yes" xml:space="preserve">
          <source>The implementation must be prepared that a call to this function may be followed by an &lt;a href=&quot;qvulkanwindowrenderer#initResources&quot;&gt;initResources&lt;/a&gt;() at a later point.</source>
          <target state="translated">이 함수에 대한 호출 다음에 &lt;a href=&quot;qvulkanwindowrenderer#initResources&quot;&gt;initResources&lt;/a&gt; () 가 올 수 있도록 구현을 준비해야합니다 .</target>
        </trans-unit>
        <trans-unit id="4947079153612791e5c53404ac91ec8524abbee9" translate="yes" xml:space="preserve">
          <source>The implementation must ensure that the &lt;a href=&quot;qgraphicslayoutitem#parentLayoutItem&quot;&gt;parentLayoutItem&lt;/a&gt;() of the removed item does not point to this layout, since the item is considered to be removed from the layout hierarchy.</source>
          <target state="translated">항목이 레이아웃 계층 구조에서 제거 된 것으로 간주되므로 구현시 제거 된 항목 의 &lt;a href=&quot;qgraphicslayoutitem#parentLayoutItem&quot;&gt;parentLayoutItem&lt;/a&gt; ()이이 레이아웃을 가리 키지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="f70630cb9e2cf6c59354fe1793f810cc7a1d1163" translate="yes" xml:space="preserve">
          <source>The implementation must ensure that the instance's &lt;a href=&quot;qmodbusdevice#state&quot;&gt;state&lt;/a&gt;() is set to &lt;a href=&quot;qmodbusdevice#State-enum&quot;&gt;QModbusDevice::ConnectingState&lt;/a&gt; or &lt;a href=&quot;qmodbusdevice#State-enum&quot;&gt;QModbusDevice::ConnectedState&lt;/a&gt; upon success; otherwise &lt;a href=&quot;qmodbusdevice#State-enum&quot;&gt;QModbusDevice::UnconnectedState&lt;/a&gt;. Typically, &lt;a href=&quot;qmodbusdevice#State-enum&quot;&gt;QModbusDevice::ConnectingState&lt;/a&gt; is used when the connection process reports back asynchronously and &lt;a href=&quot;qmodbusdevice#State-enum&quot;&gt;QModbusDevice::ConnectedState&lt;/a&gt; in case of synchronous connect behavior.</source>
          <target state="translated">구현시 인스턴스 &lt;a href=&quot;qmodbusdevice#state&quot;&gt;상태&lt;/a&gt; ()가 &lt;a href=&quot;qmodbusdevice#State-enum&quot;&gt;QModbusDevice :: ConnectingState&lt;/a&gt; 또는 &lt;a href=&quot;qmodbusdevice#State-enum&quot;&gt;QModbusDevice :: ConnectedState로&lt;/a&gt; 설정되어 있는지 확인해야합니다 . 그렇지 않으면 &lt;a href=&quot;qmodbusdevice#State-enum&quot;&gt;QModbusDevice :: UnconnectedState&lt;/a&gt; 입니다. 일반적으로 &lt;a href=&quot;qmodbusdevice#State-enum&quot;&gt;QModbusDevice :: ConnectingState&lt;/a&gt; 는 연결 프로세스가 비동기 적으로 다시보고 할 때 사용되며 동기 연결 동작의 경우 &lt;a href=&quot;qmodbusdevice#State-enum&quot;&gt;QModbusDevice :: ConnectedState&lt;/a&gt; 가 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="0f3bd636c70c21dfd018bdc6be9a4cf39b9e54e3" translate="yes" xml:space="preserve">
          <source>The implementation must ensure that upon success the instance's &lt;a href=&quot;qcanbusdevice#state&quot;&gt;state&lt;/a&gt;() is set to &lt;a href=&quot;qcanbusdevice#CanBusDeviceState-enum&quot;&gt;QCanBusDevice::ConnectedState&lt;/a&gt;; otherwise &lt;a href=&quot;qcanbusdevice#CanBusDeviceState-enum&quot;&gt;QCanBusDevice::UnconnectedState&lt;/a&gt;. &lt;a href=&quot;qcanbusdevice#setState&quot;&gt;setState&lt;/a&gt;() must be used to set the new device state.</source>
          <target state="translated">구현시 인스턴스 &lt;a href=&quot;qcanbusdevice#state&quot;&gt;상태&lt;/a&gt; ()가 &lt;a href=&quot;qcanbusdevice#CanBusDeviceState-enum&quot;&gt;QCanBusDevice :: ConnectedState로&lt;/a&gt; 설정되어 있는지 확인해야합니다 . 그렇지 않으면 &lt;a href=&quot;qcanbusdevice#CanBusDeviceState-enum&quot;&gt;QCanBusDevice :: UnconnectedState&lt;/a&gt; 입니다. 새 장치 상태를 설정하려면 &lt;a href=&quot;qcanbusdevice#setState&quot;&gt;setState&lt;/a&gt; ()를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="a85b4f3da2349e4e6d9a4b3f141b601af62484c3" translate="yes" xml:space="preserve">
          <source>The implementation of &lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt; and &lt;a href=&quot;qmultihash&quot;&gt;QMultiHash&lt;/a&gt; in Qt 6 got changed from a node based approach to a two stage lookup table. This design allows to keep the memory overhead of a hash instance very small, while at the same time giving good performance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e323c83dd7f24c7303684409e38479f528878f78" translate="yes" xml:space="preserve">
          <source>The implementation of &lt;a href=&quot;qml-qtquick-dialogs-colordialog&quot;&gt;ColorDialog&lt;/a&gt; will be a platform color dialog if possible. If that isn't possible, then it will try to instantiate a &lt;a href=&quot;qcolordialog&quot;&gt;QColorDialog&lt;/a&gt;. If that also isn't possible, then it will fall back to a QML implementation, DefaultColorDialog.qml. In that case you can customize the appearance by editing this file. DefaultColorDialog.qml contains a Rectangle to hold the dialog's contents, because certain embedded systems do not support multiple top-level windows. When the dialog becomes visible, it will automatically be wrapped in a Window if possible, or simply reparented on top of the main window if there can only be one window.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-dialogs-colordialog&quot;&gt;ColorDialog&lt;/a&gt; 의 구현은 가능한 경우 플랫폼 색상 대화 상자가됩니다. 이것이 가능하지 않으면 &lt;a href=&quot;qcolordialog&quot;&gt;QColorDialog&lt;/a&gt; 를 인스턴스화하려고 시도합니다 . 이것이 가능하지 않으면 QML 구현 인 DefaultColorDialog.qml로 대체됩니다. 이 경우이 파일을 편집하여 모양을 사용자 정의 할 수 있습니다. DefaultColorDialog.qml에는 특정 내장 시스템이 여러 최상위 창을 지원하지 않기 때문에 대화 상자의 내용을 담는 Rectangle이 포함되어 있습니다. 대화 상자가 표시되면 가능하면 자동으로 창에 줄 바꿈되거나 하나의 창만있을 수있는 경우 기본 창 상단에 간단히 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="83f1d6bd2034c3e7eff2f38523cef45e176f2481" translate="yes" xml:space="preserve">
          <source>The implementation of &lt;a href=&quot;qml-qtquick-dialogs-filedialog&quot;&gt;FileDialog&lt;/a&gt; will be a platform file dialog if possible. If that isn't possible, then it will try to instantiate a &lt;a href=&quot;qfiledialog&quot;&gt;QFileDialog&lt;/a&gt;. If that also isn't possible, then it will fall back to a QML implementation, DefaultFileDialog.qml. In that case you can customize the appearance by editing this file. DefaultFileDialog.qml contains a Rectangle to hold the dialog's contents, because certain embedded systems do not support multiple top-level windows. When the dialog becomes visible, it will automatically be wrapped in a Window if possible, or simply reparented on top of the main window if there can only be one window.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-dialogs-filedialog&quot;&gt;FileDialog&lt;/a&gt; 의 구현은 가능한 경우 플랫폼 파일 대화 상자가됩니다. 이것이 가능하지 않으면 &lt;a href=&quot;qfiledialog&quot;&gt;QFileDialog&lt;/a&gt; 를 인스턴스화하려고 시도합니다 . 이것이 가능하지 않으면 QML 구현 인 DefaultFileDialog.qml로 대체됩니다. 이 경우이 파일을 편집하여 모양을 사용자 정의 할 수 있습니다. DefaultFileDialog.qml에는 특정 내장 시스템이 여러 최상위 창을 지원하지 않기 때문에 대화 상자 내용을 담을 수있는 Rectangle이 포함되어 있습니다. 대화 상자가 표시되면 가능하면 자동으로 창에 줄 바꿈되거나 하나의 창만있을 수있는 경우 기본 창 상단에 간단히 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="d1bdf50eb7752bb3390a51cae44e1ac6cb1c1c71" translate="yes" xml:space="preserve">
          <source>The implementation of &lt;a href=&quot;qml-qtquick-dialogs-fontdialog&quot;&gt;FontDialog&lt;/a&gt; will be a platform font dialog if possible. If that isn't possible, then it will try to instantiate a &lt;a href=&quot;qfontdialog&quot;&gt;QFontDialog&lt;/a&gt;. If that also isn't possible, then it will fall back to a QML implementation, DefaultFontDialog.qml. In that case you can customize the appearance by editing this file. DefaultFontDialog.qml contains a Rectangle to hold the dialog's contents, because certain embedded systems do not support multiple top-level windows. When the dialog becomes visible, it will automatically be wrapped in a Window if possible, or simply reparented on top of the main window if there can only be one window.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-dialogs-fontdialog&quot;&gt;FontDialog&lt;/a&gt; 의 구현은 가능한 경우 플랫폼 글꼴 대화 상자가됩니다. 이것이 가능하지 않으면 &lt;a href=&quot;qfontdialog&quot;&gt;QFontDialog&lt;/a&gt; 를 인스턴스화하려고 시도합니다 . 이것이 가능하지 않으면 QML 구현 인 DefaultFontDialog.qml로 대체됩니다. 이 경우이 파일을 편집하여 모양을 사용자 정의 할 수 있습니다. DefaultFontDialog.qml에는 특정 내장 시스템이 여러 최상위 창을 지원하지 않기 때문에 대화 상자의 내용을 담을 수있는 Rectangle이 포함되어 있습니다. 대화 상자가 표시되면 가능하면 자동으로 창에 줄 바꿈되거나 하나의 창만있을 수있는 경우 기본 창 상단에 간단히 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="bf32a282e06a10e0a4ea03591dc1cb825154010e" translate="yes" xml:space="preserve">
          <source>The implementation of &lt;a href=&quot;qml-qtquick-dialogs-messagedialog&quot;&gt;MessageDialog&lt;/a&gt; will be a platform message dialog if possible. If that isn't possible, then it will try to instantiate a &lt;a href=&quot;qmessagebox&quot;&gt;QMessageBox&lt;/a&gt;. If that also isn't possible, then it will fall back to a QML implementation, &lt;code&gt;DefaultMessageDialog.qml&lt;/code&gt;. In that case you can customize the appearance by editing this file. &lt;code&gt;DefaultMessageDialog.qml&lt;/code&gt; contains a &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt; to hold the dialog's contents, because certain embedded systems do not support multiple top-level windows. When the dialog becomes visible, it will automatically be wrapped in a &lt;a href=&quot;qml-qtquick-window-window&quot;&gt;Window&lt;/a&gt; if possible, or simply reparented on top of the main window if there can only be one window.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-dialogs-messagedialog&quot;&gt;MessageDialog&lt;/a&gt; 의 구현은 가능한 경우 플랫폼 메시지 대화 상자가됩니다. 이것이 가능하지 않으면 &lt;a href=&quot;qmessagebox&quot;&gt;QMessageBox&lt;/a&gt; 를 인스턴스화하려고 시도합니다 . 그렇게 할 수 없다면 QML 구현 인 &lt;code&gt;DefaultMessageDialog.qml&lt;/code&gt; 로 대체 됩니다. 이 경우이 파일을 편집하여 모양을 사용자 정의 할 수 있습니다. &lt;code&gt;DefaultMessageDialog.qml&lt;/code&gt; 에는 특정 임베디드 시스템이 여러 최상위 창을 지원하지 않기 때문에 대화 상자의 내용을 담을 수 있는 &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt; 이 포함되어 있습니다. 대화 상자가 표시되면 가능하면 자동으로 &lt;a href=&quot;qml-qtquick-window-window&quot;&gt;창에&lt;/a&gt; 줄 바꿈 되거나 하나의 창만있을 수있는 경우 기본 창 위에 간단히 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="45207d3ea139242276f1a1bb29ec6b14c52675fc" translate="yes" xml:space="preserve">
          <source>The implementation of ColorDialog will be a platform color dialog if possible. If that isn't possible, then it will try to instantiate a &lt;a href=&quot;qcolordialog&quot;&gt;QColorDialog&lt;/a&gt;. If that also isn't possible, then it will fall back to a QML implementation, DefaultColorDialog.qml. In that case you can customize the appearance by editing this file. DefaultColorDialog.qml contains a Rectangle to hold the dialog's contents, because certain embedded systems do not support multiple top-level windows. When the dialog becomes visible, it will automatically be wrapped in a Window if possible, or simply reparented on top of the main window if there can only be one window.</source>
          <target state="translated">ColorDialog의 구현은 가능한 경우 플랫폼 색상 대화 상자가됩니다. 이것이 가능하지 않으면 &lt;a href=&quot;qcolordialog&quot;&gt;QColorDialog&lt;/a&gt; 인스턴스화를 시도합니다 . 이것이 가능하지 않으면 QML 구현 인 DefaultColorDialog.qml로 대체됩니다. 이 경우이 파일을 편집하여 모양을 사용자 정의 할 수 있습니다. DefaultColorDialog.qml에는 특정 임베디드 시스템이 여러 최상위 창을 지원하지 않기 때문에 대화 상자의 내용을 보관하는 Rectangle이 포함되어 있습니다. 대화 상자가 표시되면 가능한 경우 자동으로 창에 래핑되거나 창이 하나만있을 수있는 경우 기본 창 위에 상위로 다시 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="7ed62119c5573e040acc99d99e0cf75c24356210" translate="yes" xml:space="preserve">
          <source>The implementation of FileDialog will be a platform file dialog if possible. If that isn't possible, then it will try to instantiate a &lt;a href=&quot;qfiledialog&quot;&gt;QFileDialog&lt;/a&gt;. If that also isn't possible, then it will fall back to a QML implementation, DefaultFileDialog.qml. In that case you can customize the appearance by editing this file. DefaultFileDialog.qml contains a Rectangle to hold the dialog's contents, because certain embedded systems do not support multiple top-level windows. When the dialog becomes visible, it will automatically be wrapped in a Window if possible, or simply reparented on top of the main window if there can only be one window.</source>
          <target state="translated">FileDialog의 구현은 가능한 경우 플랫폼 파일 대화 상자가됩니다. 이것이 가능하지 않다면 &lt;a href=&quot;qfiledialog&quot;&gt;QFileDialog&lt;/a&gt; 인스턴스화를 시도합니다 . 이것이 가능하지 않으면 QML 구현 인 DefaultFileDialog.qml로 대체됩니다. 이 경우이 파일을 편집하여 모양을 사용자 정의 할 수 있습니다. DefaultFileDialog.qml에는 특정 임베디드 시스템이 여러 최상위 창을 지원하지 않기 때문에 대화 상자의 내용을 보관하는 Rectangle이 포함되어 있습니다. 대화 상자가 표시되면 가능한 경우 자동으로 창에 래핑되거나 창이 하나만있을 수있는 경우 기본 창 위에 상위로 다시 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="c0a1902c927123bf7cc9d19cd9381b3ea701bc44" translate="yes" xml:space="preserve">
          <source>The implementation of FontDialog will be a platform font dialog if possible. If that isn't possible, then it will try to instantiate a &lt;a href=&quot;qfontdialog&quot;&gt;QFontDialog&lt;/a&gt;. If that also isn't possible, then it will fall back to a QML implementation, DefaultFontDialog.qml. In that case you can customize the appearance by editing this file. DefaultFontDialog.qml contains a Rectangle to hold the dialog's contents, because certain embedded systems do not support multiple top-level windows. When the dialog becomes visible, it will automatically be wrapped in a Window if possible, or simply reparented on top of the main window if there can only be one window.</source>
          <target state="translated">가능한 경우 FontDialog 구현은 플랫폼 글꼴 대화 상자가됩니다. 이것이 가능하지 않다면 &lt;a href=&quot;qfontdialog&quot;&gt;QFontDialog&lt;/a&gt; 인스턴스화를 시도합니다 . 이것이 가능하지 않으면 QML 구현 인 DefaultFontDialog.qml로 돌아갑니다. 이 경우이 파일을 편집하여 모양을 사용자 정의 할 수 있습니다. DefaultFontDialog.qml에는 특정 임베디드 시스템이 여러 최상위 창을 지원하지 않기 때문에 대화 상자의 내용을 보관하는 Rectangle이 포함되어 있습니다. 대화 상자가 표시되면 가능한 경우 자동으로 창에 래핑되거나 창이 하나만있을 수있는 경우 기본 창 위에 상위로 다시 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="ad1a79897f2838be63a67136101a3844de3465c1" translate="yes" xml:space="preserve">
          <source>The implementation of MessageDialog will be a platform message dialog if possible. If that isn't possible, then it will try to instantiate a &lt;a href=&quot;qmessagebox&quot;&gt;QMessageBox&lt;/a&gt;. If that also isn't possible, then it will fall back to a QML implementation, &lt;code&gt;DefaultMessageDialog.qml&lt;/code&gt;. In that case you can customize the appearance by editing this file. &lt;code&gt;DefaultMessageDialog.qml&lt;/code&gt; contains a &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt; to hold the dialog's contents, because certain embedded systems do not support multiple top-level windows. When the dialog becomes visible, it will automatically be wrapped in a &lt;a href=&quot;qml-qtquick-window-window&quot;&gt;Window&lt;/a&gt; if possible, or simply reparented on top of the main window if there can only be one window.</source>
          <target state="translated">MessageDialog의 구현은 가능한 경우 플랫폼 메시지 대화 상자가됩니다. 가능하지 않은 경우 &lt;a href=&quot;qmessagebox&quot;&gt;QMessageBox&lt;/a&gt; 인스턴스화를 시도합니다 . 이것이 가능하지 않은 경우 QML 구현 인 &lt;code&gt;DefaultMessageDialog.qml&lt;/code&gt; 로 대체 됩니다. 이 경우이 파일을 편집하여 모양을 사용자 정의 할 수 있습니다. &lt;code&gt;DefaultMessageDialog.qml&lt;/code&gt; 에는 특정 임베디드 시스템이 여러 최상위 창을 지원하지 않기 때문에 대화 상자의 내용을 보관 하는 &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt; 이 포함되어 있습니다. 대화 상자가 표시 되면 가능한 경우 자동으로 &lt;a href=&quot;qml-qtquick-window-window&quot;&gt;창에&lt;/a&gt; 래핑 되거나 창이 하나만있을 수있는 경우 기본 창 위에 상위로 다시 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="274369fb1e6ddb90ab66b13eee958dd8f44e6cd2" translate="yes" xml:space="preserve">
          <source>The implementation of a &lt;a href=&quot;qplacemanagerengine&quot;&gt;QPlaceManagerEngine&lt;/a&gt; must ensure that any signals emitted by the reply objects are delayed until the request functions have returned and the application code has a chance to connect those signals to slots. The typical approach is to use &lt;a href=&quot;qmetaobject#invokeMethod&quot;&gt;QMetaObject::invokeMethod&lt;/a&gt;() with a &lt;a href=&quot;qt#ConnectionType-enum&quot;&gt;Qt::QueuedConnection&lt;/a&gt; to emit the signals.</source>
          <target state="translated">&lt;a href=&quot;qplacemanagerengine&quot;&gt;QPlaceManagerEngine&lt;/a&gt; 의 구현은 응답 함수가 생성 한 모든 신호가 요청 함수가 리턴되고 응용 프로그램 코드가 해당 신호를 슬롯에 연결할 수있을 때까지 지연되도록해야합니다. 일반적인 접근 방식은 &lt;a href=&quot;qt#ConnectionType-enum&quot;&gt;Qt :: QueuedConnection&lt;/a&gt; 과 함께 &lt;a href=&quot;qmetaobject#invokeMethod&quot;&gt;QMetaObject :: invokeMethod&lt;/a&gt; () 를 사용 하여 신호를 내보내는 것입니다.</target>
        </trans-unit>
        <trans-unit id="748e2ca0999b955301c1b33cbf9e6cadadbaae35" translate="yes" xml:space="preserve">
          <source>The implementation of input methods starts by deciding which interface is used; QML or C++. In this example the QML interface is used.</source>
          <target state="translated">입력 방법의 구현은 사용되는 인터페이스를 결정하는 것으로 시작됩니다. QML 또는 C ++. 이 예에서는 QML 인터페이스가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ee1a800908d0c1caacdd8f5869b9281805921b25" translate="yes" xml:space="preserve">
          <source>The implementation of the &lt;a href=&quot;qaccessibleinterface#role&quot;&gt;role()&lt;/a&gt; function is straightforward:</source>
          <target state="translated">&lt;a href=&quot;qaccessibleinterface#role&quot;&gt;role ()&lt;/a&gt; 함수 의 구현 은 간단합니다.</target>
        </trans-unit>
        <trans-unit id="db27d8e51e95424f34dcdb84f858ffb5e4215228" translate="yes" xml:space="preserve">
          <source>The implementation of the slot prints basic information about the addresses returned by the lookup, or reports an error if it failed:</source>
          <target state="translated">슬롯을 구현하면 조회에서 반환 한 주소에 대한 기본 정보를 인쇄하거나 실패한 경우 오류를보고합니다.</target>
        </trans-unit>
        <trans-unit id="d3b8602611b8b7d1c0f40d0c9566631183dc6c92" translate="yes" xml:space="preserve">
          <source>The implementor guarantees that the nodes identified by the returned indexes are elements or attributes.</source>
          <target state="translated">구현자는 리턴 된 인덱스로 식별 된 노드가 요소 또는 속성임을 보증합니다.</target>
        </trans-unit>
        <trans-unit id="d8e5e88ceb3333fe8c3e1cbe387c5f69488e8861" translate="yes" xml:space="preserve">
          <source>The implicit conversion from &lt;code&gt;QFuture&amp;lt;T&amp;gt;&lt;/code&gt; to &lt;code&gt;QFuture&amp;lt;void&amp;gt;&lt;/code&gt; has been also disabled. If you really intend to do the conversion, use the explicit &lt;code&gt;QFuture&amp;lt;void&amp;gt;(const QFuture&amp;lt;T&amp;gt; &amp;amp;)&lt;/code&gt; constructor:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12de27510a1c8cf334ae3c7cf3599fd9a3db6595" translate="yes" xml:space="preserve">
          <source>The implicit height of the content item.</source>
          <target state="translated">내용 항목의 암시 적 높이입니다.</target>
        </trans-unit>
        <trans-unit id="a7223ec38a03c71e10d48cff6db75009e17f41c8" translate="yes" xml:space="preserve">
          <source>The implicit size of the &lt;a href=&quot;qml-qtquick-controls-groupbox&quot;&gt;GroupBox&lt;/a&gt; is calculated based on the size of its content. If you want to anchor items inside the group box, you must specify an explicit width and height on the &lt;a href=&quot;qml-qtquick-controls-groupbox&quot;&gt;GroupBox&lt;/a&gt; itself.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-controls-groupbox&quot;&gt;GroupBox&lt;/a&gt; 의 암시 적 크기 는 내용의 크기에 따라 계산됩니다. 그룹 상자 안에 항목을 고정하려면 &lt;a href=&quot;qml-qtquick-controls-groupbox&quot;&gt;GroupBox&lt;/a&gt; 자체 에 명시적인 너비와 높이를 지정해야 합니다.</target>
        </trans-unit>
        <trans-unit id="8f8b1a0c9d65b0a8cd90ba51470979aafd840301" translate="yes" xml:space="preserve">
          <source>The implicit size of the GroupBox is calculated based on the size of its content. If you want to anchor items inside the group box, you must specify an explicit width and height on the GroupBox itself.</source>
          <target state="translated">GroupBox의 암시 적 크기는 콘텐츠의 크기에 따라 계산됩니다. 그룹 상자 안에 항목을 고정하려면 GroupBox 자체에 명시적인 너비와 높이를 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="8c0001f14aed93d96945463f211cfc298419647c" translate="yes" xml:space="preserve">
          <source>The implicit size of the calendar is calculated based on the implicit size of the background delegate.</source>
          <target state="translated">캘린더의 암시 적 크기는 백그라운드 대리자의 암시 적 크기를 기반으로 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="d9cd8a852090f8d50b58198960854b12a3dacb5d" translate="yes" xml:space="preserve">
          <source>The implicit size of the dial is taken from this component.</source>
          <target state="translated">다이얼의 암시 적 크기는이 구성 요소에서 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="1423f9c904005753e9682c4cb89a4ae8d8b77eb7" translate="yes" xml:space="preserve">
          <source>The implicit size of the slider is calculated based on the maximum implicit size of the &lt;code&gt;background&lt;/code&gt; and &lt;code&gt;handle&lt;/code&gt; delegates combined.</source>
          <target state="translated">슬라이더의 암시 적 크기는 &lt;code&gt;background&lt;/code&gt; 및 &lt;code&gt;handle&lt;/code&gt; 대리자 의 최대 암시 적 크기를 기준으로 계산 됩니다.</target>
        </trans-unit>
        <trans-unit id="4c056a53114b41e23b2f2188b59c5cd555cb6465" translate="yes" xml:space="preserve">
          <source>The implicit width of the content item.</source>
          <target state="translated">내용 항목의 암시 적 너비</target>
        </trans-unit>
        <trans-unit id="c69bff64cf1fd49fa43f50f7cf3ea57c0bda7b0e" translate="yes" xml:space="preserve">
          <source>The implicitContentWidth will be set to the implicit width of the the largest text for the given &lt;a href=&quot;qml-qtquick-controls2-combobox#textRole-prop&quot;&gt;textRole&lt;/a&gt; every time the model changes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08a4e0caa668abb418e3265faf7546978b48dcba" translate="yes" xml:space="preserve">
          <source>The implicitContentWidth will be set to the implicit width of the the largest text for the given &lt;a href=&quot;qml-qtquick-controls2-combobox#textRole-prop&quot;&gt;textRole&lt;/a&gt; once after &lt;a href=&quot;qqmlparserstatus#componentComplete&quot;&gt;component completion&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cf342c9d0747ea7b5fe017ea613947ffc4bd165" translate="yes" xml:space="preserve">
          <source>The implicitContentWidth will default to that of the &lt;a href=&quot;qml-qtquick-controls2-control#contentItem-prop&quot;&gt;contentItem&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="919a5890a86fe1dd229db5844218a84dda9d0912" translate="yes" xml:space="preserve">
          <source>The important feature of the class is the private &lt;code&gt;ui&lt;/code&gt; object which provides the code for setting up and managing the user interface.</source>
          <target state="translated">이 클래스의 중요한 기능은 사용자 인터페이스를 설정하고 관리하기위한 코드를 제공하는 전용 &lt;code&gt;ui&lt;/code&gt; 객체입니다.</target>
        </trans-unit>
        <trans-unit id="11ed2962650e35a5e2065ada5102f1ab96adff50" translate="yes" xml:space="preserve">
          <source>The in-app products must be registered in the target stores, before they can be queried or purchased in an application. We recommend using the same identifiers for the products in each store, as it simplifies the code to query and purchase the products.</source>
          <target state="translated">인앱 상품은 대상 스토어에 등록해야 애플리케이션에서 쿼리하거나 구매할 수 있습니다. 제품을 쿼리하고 구매하는 코드를 단순화하므로 각 상점에서 제품에 대해 동일한 식별자를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="4bbec7806477655afe84b840ee290c6094f79882" translate="yes" xml:space="preserve">
          <source>The included file, &lt;code&gt;dataloader.mjs&lt;/code&gt;, looks like this:</source>
          <target state="translated">포함 된 파일 &lt;code&gt;dataloader.mjs&lt;/code&gt; 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0caf658d3e996f9ebd69102e7608a3a8622f9e6f" translate="yes" xml:space="preserve">
          <source>The incubator will remain in the Loading state until either the creation is complete or an error occurs. The &lt;a href=&quot;qqmlincubator#statusChanged&quot;&gt;statusChanged&lt;/a&gt;() callback can be used to be notified of status changes.</source>
          <target state="translated">인큐베이터는 생성이 완료되거나 오류가 발생할 때까지 로딩 상태를 유지합니다. &lt;a href=&quot;qqmlincubator#statusChanged&quot;&gt;statusChanged&lt;/a&gt; () 콜백 상태 변화를 통지 할 수있다.</target>
        </trans-unit>
        <trans-unit id="c545623433c7fdd1b35d9fcf1aed3e7817e88567" translate="yes" xml:space="preserve">
          <source>The indent properties of &lt;a href=&quot;qtextlistformat&quot;&gt;QTextListFormat&lt;/a&gt; and &lt;a href=&quot;qtextblockformat&quot;&gt;QTextBlockFormat&lt;/a&gt; specify multiples of this value. The default indent width is 40 .</source>
          <target state="translated">&lt;a href=&quot;qtextlistformat&quot;&gt;QTextListFormat&lt;/a&gt; 및 &lt;a href=&quot;qtextblockformat&quot;&gt;QTextBlockFormat&lt;/a&gt; 의 들여 쓰기 속성 은이 값의 배수를 지정합니다. 기본 들여 쓰기 너비는 40입니다.</target>
        </trans-unit>
        <trans-unit id="7bc03f143eaa054eb6c1561ed1bd3cd66eca2e47" translate="yes" xml:space="preserve">
          <source>The indent properties of &lt;a href=&quot;qtextlistformat&quot;&gt;QTextListFormat&lt;/a&gt; and &lt;a href=&quot;qtextblockformat&quot;&gt;QTextBlockFormat&lt;/a&gt; specify multiples of this value. The default indent width is 40.</source>
          <target state="translated">&lt;a href=&quot;qtextlistformat&quot;&gt;QTextListFormat&lt;/a&gt; 및 &lt;a href=&quot;qtextblockformat&quot;&gt;QTextBlockFormat&lt;/a&gt; 의 들여 쓰기 속성 은이 값의 배수를 지정합니다. 기본 들여 쓰기 너비는 40입니다.</target>
        </trans-unit>
        <trans-unit id="97315a716bc556c1bebbac212f816876e0c21939" translate="yes" xml:space="preserve">
          <source>The indentation of items in a tree view. This enum value has been introduced in Qt 5.4.</source>
          <target state="translated">트리 뷰에서 항목 들여 쓰기 이 열거 형 값은 Qt 5.4에서 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="b3aa907c497f0bc4181977acf9e62771608c108e" translate="yes" xml:space="preserve">
          <source>The indentation of the items is an integer value that causes each item to be offset from the left margin by a certain amount. This value is read with &lt;a href=&quot;qtextlistformat#indent&quot;&gt;indent&lt;/a&gt;() and set with &lt;a href=&quot;qtextlistformat#setIndent&quot;&gt;setIndent&lt;/a&gt;().</source>
          <target state="translated">항목 들여 쓰기는 각 항목이 왼쪽 여백에서 특정 양만큼 오프셋되도록하는 정수 값입니다. 이 값은 &lt;a href=&quot;qtextlistformat#indent&quot;&gt;들여 쓰기&lt;/a&gt; () 로 읽고 &lt;a href=&quot;qtextlistformat#setIndent&quot;&gt;setIndent&lt;/a&gt; ()로 설정 합니다.</target>
        </trans-unit>
        <trans-unit id="35483984f625ceabe7d27564657fe5557d502f24" translate="yes" xml:space="preserve">
          <source>The indeterminate mode is similar to a &lt;a href=&quot;qml-qtquick-controls2-busyindicator&quot;&gt;BusyIndicator&lt;/a&gt;. Both can be used to indicate background activity. The main difference is visual, and that &lt;a href=&quot;qml-qtquick-controls2-progressbar&quot;&gt;ProgressBar&lt;/a&gt; can also present a concrete amount of progress (when it can be determined). Due to the visual difference, indeterminate progress bars and busy indicators fit different places in user interfaces. Typical places for an indeterminate progress bar:</source>
          <target state="translated">불확정 모드는 &lt;a href=&quot;qml-qtquick-controls2-busyindicator&quot;&gt;BusyIndicator&lt;/a&gt; 와 유사합니다 . 둘 다 백그라운드 활동을 나타내는 데 사용할 수 있습니다. 주요 차이점은 시각적이며 &lt;a href=&quot;qml-qtquick-controls2-progressbar&quot;&gt;ProgressBar&lt;/a&gt; 는 구체적인 양의 진행률을 나타낼 수도 있습니다 (결정될 수있는 경우). 시각적 차이로 인해 불확실한 진행률 표시 줄과 통화 중 표시기는 사용자 인터페이스의 다른 위치에 적합합니다. 불확실한 진행률 표시 줄의 일반적인 위치 :</target>
        </trans-unit>
        <trans-unit id="b15ceb87e0381c48ec6b95decf2d1e53dfbd14f6" translate="yes" xml:space="preserve">
          <source>The indeterminate mode is similar to a &lt;a href=&quot;qml-qtquick-controls2-busyindicator&quot;&gt;BusyIndicator&lt;/a&gt;. Both can be used to indicate background activity. The main difference is visual, and that ProgressBar can also present a concrete amount of progress (when it can be determined). Due to the visual difference, indeterminate progress bars and busy indicators fit different places in user interfaces. Typical places for an indeterminate progress bar:</source>
          <target state="translated">불확정 모드는 &lt;a href=&quot;qml-qtquick-controls2-busyindicator&quot;&gt;BusyIndicator&lt;/a&gt; 와 유사합니다 . 둘 다 백그라운드 활동을 표시하는 데 사용할 수 있습니다. 주요 차이점은 시각적이며 ProgressBar는 구체적인 진행률 (결정 가능한 경우)도 표시 할 수 있습니다. 시각적 차이로 인해 불확실한 진행률 표시 줄과 사용 중 표시기는 사용자 인터페이스의 다른 위치에 적합합니다. 불확실한 진행률 표시 줄의 일반적인 위치 :</target>
        </trans-unit>
        <trans-unit id="66d52730cf4d9ec863dcef9977398ff2165c19fd" translate="yes" xml:space="preserve">
          <source>The index (0-5) of the delegate.</source>
          <target state="translated">델리게이트의 인덱스 (0-5)입니다.</target>
        </trans-unit>
        <trans-unit id="42ed32b373d5f6458a94dccb8c61f7841f810b75" translate="yes" xml:space="preserve">
          <source>The index (0-6) of the delegate.</source>
          <target state="translated">델리게이트의 인덱스 (0-6)입니다.</target>
        </trans-unit>
        <trans-unit id="bc28af89df4f81195cff01a075e6aa5ade7aeac1" translate="yes" xml:space="preserve">
          <source>The index functions &lt;a href=&quot;qmetaobject#indexOfConstructor&quot;&gt;indexOfConstructor&lt;/a&gt;(), &lt;a href=&quot;qmetaobject#indexOfMethod&quot;&gt;indexOfMethod&lt;/a&gt;(), &lt;a href=&quot;qmetaobject#indexOfEnumerator&quot;&gt;indexOfEnumerator&lt;/a&gt;(), and &lt;a href=&quot;qmetaobject#indexOfProperty&quot;&gt;indexOfProperty&lt;/a&gt;() map names of constructors, member functions, enumerators, or properties to indexes in the meta-object. For example, Qt uses &lt;a href=&quot;qmetaobject#indexOfMethod&quot;&gt;indexOfMethod&lt;/a&gt;() internally when you connect a signal to a slot.</source>
          <target state="translated">인덱스 함수 &lt;a href=&quot;qmetaobject#indexOfConstructor&quot;&gt;indexOfConstructor&lt;/a&gt; (), &lt;a href=&quot;qmetaobject#indexOfMethod&quot;&gt;indexOfMethod&lt;/a&gt; (), &lt;a href=&quot;qmetaobject#indexOfEnumerator&quot;&gt;indexOfEnumerator&lt;/a&gt; () 및 &lt;a href=&quot;qmetaobject#indexOfProperty&quot;&gt;indexOfProperty&lt;/a&gt; ()는 생성자, 멤버 함수, 열거 자 또는 속성의 이름을 메타 개체의 인덱스에 매핑합니다. 예를 들어, Qt는 신호를 슬롯에 연결할 때 &lt;a href=&quot;qmetaobject#indexOfMethod&quot;&gt;indexOfMethod&lt;/a&gt; ()를 내부적으로 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="7dc6e6bd99cf2e92dd7b16335095b3c92615bf75" translate="yes" xml:space="preserve">
          <source>The index in the range array which matches the current distance to the camera or screen size.</source>
          <target state="translated">카메라 또는 화면 크기까지의 현재 거리와 일치하는 범위 배열의 인덱스입니다.</target>
        </trans-unit>
        <trans-unit id="8e4b85294b9c86f479c1df9f81a5f4c8792b0d48" translate="yes" xml:space="preserve">
          <source>The index is calculated from the index of the key &lt;code&gt;text&lt;/code&gt; in the &lt;code&gt;alternativeKeys&lt;/code&gt;.</source>
          <target state="translated">인덱스는 키의 인덱스로부터 계산된다 &lt;code&gt;text&lt;/code&gt; 에 &lt;code&gt;alternativeKeys&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aa2b47437bae1959208c1aee4e6504819072458d" translate="yes" xml:space="preserve">
          <source>The index is the current array size if the rows were removed from the end of the array. If rows are removed from the array without calling &lt;a href=&quot;qbardataproxy#removeRows&quot;&gt;removeRows&lt;/a&gt;(), this signal needs to be emitted to update the graph.</source>
          <target state="translated">행이 배열 끝에서 제거 된 경우 인덱스는 현재 배열 크기입니다. &lt;a href=&quot;qbardataproxy#removeRows&quot;&gt;removeRows&lt;/a&gt; () 를 호출하지 않고 배열에서 행을 제거 하면 그래프를 업데이트하기 위해이 신호를 내 보내야 합니다.</target>
        </trans-unit>
        <trans-unit id="ce605cd3a794206daf93ff6251f40510b86cf8a2" translate="yes" xml:space="preserve">
          <source>The index is the current array size if the rows were removed from the end of the array. If rows are removed from the array without calling &lt;a href=&quot;qsurfacedataproxy#removeRows&quot;&gt;removeRows&lt;/a&gt;(), this signal needs to be emitted to update the graph.</source>
          <target state="translated">행이 배열 끝에서 제거 된 경우 인덱스는 현재 배열 크기입니다. &lt;a href=&quot;qsurfacedataproxy#removeRows&quot;&gt;removeRows&lt;/a&gt; () 를 호출하지 않고 배열에서 행을 제거 하면 그래프를 업데이트하기 위해이 신호를 내 보내야 합니다.</target>
        </trans-unit>
        <trans-unit id="960275527b1abc60f75b779124ee104e8163ed20" translate="yes" xml:space="preserve">
          <source>The index of &quot;Item 0&quot; within the model following the add operation</source>
          <target state="translated">추가 작업 후 모델 내 &quot;Item 0&quot;의 인덱스</target>
        </trans-unit>
        <trans-unit id="f26d96529853bd0d2393c14715810dfde03e3fd2" translate="yes" xml:space="preserve">
          <source>The index of &quot;Item 4&quot;, the new item added to the view</source>
          <target state="translated">뷰에 추가 된 새 항목 &quot;항목 4&quot;의 색인</target>
        </trans-unit>
        <trans-unit id="f381a3c920c276b11a69d9a8ee3040dcb7aa0182" translate="yes" xml:space="preserve">
          <source>The index of the column that contains this highlight.</source>
          <target state="translated">이 강조 표시가 포함 된 열의 색인입니다.</target>
        </trans-unit>
        <trans-unit id="7b62722ef9d1fc6a3b8e7236481aa04ff5c67398" translate="yes" xml:space="preserve">
          <source>The index of the column that contains this item.</source>
          <target state="translated">이 항목을 포함하는 열의 색인입니다.</target>
        </trans-unit>
        <trans-unit id="3e9b253f8aa87f1f4480bd871ebe053deeaadd65" translate="yes" xml:space="preserve">
          <source>The index of the current item widget is returned by &lt;a href=&quot;qtoolbox#currentIndex-prop&quot;&gt;currentIndex&lt;/a&gt;(), and set with &lt;a href=&quot;qtoolbox#currentIndex-prop&quot;&gt;setCurrentIndex&lt;/a&gt;(). The index of a particular item can be found using &lt;a href=&quot;qtoolbox#indexOf&quot;&gt;indexOf&lt;/a&gt;(), and the item at a given index is returned by item().</source>
          <target state="translated">현재 항목 위젯의 색인은 &lt;a href=&quot;qtoolbox#currentIndex-prop&quot;&gt;currentIndex&lt;/a&gt; ()에 의해 리턴되며 &lt;a href=&quot;qtoolbox#currentIndex-prop&quot;&gt;setCurrentIndex&lt;/a&gt; ()로 설정됩니다 . 특정 항목의 색인은 &lt;a href=&quot;qtoolbox#indexOf&quot;&gt;indexOf&lt;/a&gt; ()를 사용하여 찾을 수 있으며 주어진 색인의 항목은 item ()에 의해 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="3ed783d31d4b7074ba4b8ca415b69d5ae0cef078" translate="yes" xml:space="preserve">
          <source>The index of the currently highlighted match.</source>
          <target state="translated">현재 강조 표시된 일치 항목의 색인입니다.</target>
        </trans-unit>
        <trans-unit id="ed7143807e8c7147f26e697450e2cb1b36370259" translate="yes" xml:space="preserve">
          <source>The index of the currently selected item in the &lt;a href=&quot;qml-qtquick-controls-combobox&quot;&gt;ComboBox&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-controls-combobox&quot;&gt;ComboBox&lt;/a&gt; 에서 현재 선택된 항목의 인덱스입니다 .</target>
        </trans-unit>
        <trans-unit id="90c89026e65a6ecf666127fa37f41f8c2e64452f" translate="yes" xml:space="preserve">
          <source>The index of the formatted object. See &lt;a href=&quot;qtextformat#objectIndex&quot;&gt;objectIndex&lt;/a&gt;().</source>
          <target state="translated">서식이 지정된 객체의 인덱스입니다. &lt;a href=&quot;qtextformat#objectIndex&quot;&gt;objectIndex&lt;/a&gt; ()를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ebfbaa5eccd892c261e29a56d90c29eaea0fa1fe" translate="yes" xml:space="preserve">
          <source>The index of the item</source>
          <target state="translated">품목의 색인</target>
        </trans-unit>
        <trans-unit id="a3f7f6ead09a947c0ec94e8e6816f4d4213b36a5" translate="yes" xml:space="preserve">
          <source>The index of the menu item in its menu.</source>
          <target state="translated">메뉴에서 메뉴 항목의 색인입니다.</target>
        </trans-unit>
        <trans-unit id="9b4e8aa507d1ccdba197aece96022c5de575f491" translate="yes" xml:space="preserve">
          <source>The index of the presently selected child entity.</source>
          <target state="translated">현재 선택된 자식 엔터티의 인덱스입니다.</target>
        </trans-unit>
        <trans-unit id="e3349671d087d91f5046272e264177494423ac74" translate="yes" xml:space="preserve">
          <source>The index of the the menu item that is currently under the mouse, or &lt;code&gt;-1&lt;/code&gt; if there is no such item.</source>
          <target state="translated">현재 마우스 아래에있는 메뉴 항목의 색인이거나 그러한 항목이없는 경우 &lt;code&gt;-1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d71d2b0a0208f1ae1caa1b4bd68b68ac664c5f5a" translate="yes" xml:space="preserve">
          <source>The index of this column in the tumbler.</source>
          <target state="translated">텀블러에서이 열의 색인입니다.</target>
        </trans-unit>
        <trans-unit id="9ee89f39c03bf698368e77aed49c93cd8a99cadc" translate="yes" xml:space="preserve">
          <source>The index of this delegate in the model.</source>
          <target state="translated">모델에서이 대리자의 색인입니다.</target>
        </trans-unit>
        <trans-unit id="5ceb8f33e3ec925ef2692ffa5a29189e7037dc6b" translate="yes" xml:space="preserve">
          <source>The index of this delegate.</source>
          <target state="translated">이 대리자의 색인입니다.</target>
        </trans-unit>
        <trans-unit id="2d5e67d5a80ae5557e2318034f4281883a7543af" translate="yes" xml:space="preserve">
          <source>The index of this label.</source>
          <target state="translated">이 라벨의 인덱스입니다.</target>
        </trans-unit>
        <trans-unit id="4868b7d6f0ec8d2c45c64d46b9b95cfd19d2b922" translate="yes" xml:space="preserve">
          <source>The index of this menu item.</source>
          <target state="translated">이 메뉴 아이템의 인덱스입니다.</target>
        </trans-unit>
        <trans-unit id="3ebaac1a2757d02b9c121e04a4621afcdacbfa6d" translate="yes" xml:space="preserve">
          <source>The index of this minor tickmark.</source>
          <target state="translated">이 작은 체크 표시의 색인입니다.</target>
        </trans-unit>
        <trans-unit id="6077dc2af33680a0e56a92ae5480258cffe55844" translate="yes" xml:space="preserve">
          <source>The index of this tickmark.</source>
          <target state="translated">이 눈금 표시의 색인입니다.</target>
        </trans-unit>
        <trans-unit id="51e19570612c14dc90d2484de0a2c2874db269ed" translate="yes" xml:space="preserve">
          <source>The index property can be useful if you have another model that contains images to display for each index, for example.</source>
          <target state="translated">예를 들어, 인덱스 속성은 각 인덱스에 대해 표시 할 이미지가 포함 된 다른 모델이있는 경우 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="04586e122a42128a74a99bf4076ff564f4c8ec8f" translate="yes" xml:space="preserve">
          <source>The indexes in the cache refer to the number of positions the item is from the first item appended into the cache. That is to say a cache with a capacity of 100, that has had 150 items appended will have a valid index range of 50 to 149. This allows inserting and retrieving items into the cache based on a theoretical infinite list</source>
          <target state="translated">캐시의 색인은 항목이 캐시에 추가 된 첫 번째 항목의 위치 수를 나타냅니다. 즉, 용량이 100 인 캐시에 150 개의 항목이 추가 된 캐시의 유효 색인 범위는 50-149입니다. 이는 이론적 무한 목록을 기반으로 캐시에 항목을 삽입하고 검색 할 수있게합니다.</target>
        </trans-unit>
        <trans-unit id="b9e47ab36f7a7b5dfec4d25e32626ba5bbdf55a4" translate="yes" xml:space="preserve">
          <source>The indicator of a &lt;a href=&quot;qabstractitemview&quot;&gt;QAbstractItemView&lt;/a&gt;, a &lt;a href=&quot;qcheckbox&quot;&gt;QCheckBox&lt;/a&gt;, a &lt;a href=&quot;qradiobutton&quot;&gt;QRadioButton&lt;/a&gt;, a checkable &lt;a href=&quot;qmenu&quot;&gt;QMenu&lt;/a&gt; item or a checkable &lt;a href=&quot;qgroupbox&quot;&gt;QGroupBox&lt;/a&gt;.</source>
          <target state="translated">a의 표시 &lt;a href=&quot;qabstractitemview&quot;&gt;QAbstractItemView&lt;/a&gt; 하는 &lt;a href=&quot;qcheckbox&quot;&gt;QCheckBox&lt;/a&gt; 하는 &lt;a href=&quot;qradiobutton&quot;&gt;QRadioButton&lt;/a&gt; 하는 체크 할 &lt;a href=&quot;qmenu&quot;&gt;QMenu를의&lt;/a&gt; 항목 또는 체크 가능 &lt;a href=&quot;qgroupbox&quot;&gt;QGroupBox&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8b4faac203adce63aa353b4841a7f171f09e092f" translate="yes" xml:space="preserve">
          <source>The indicator of checkable menu items is styled using the &lt;a href=&quot;#indicator-sub&quot;&gt;::indicator&lt;/a&gt; subcontrol.</source>
          <target state="translated">확인 가능한 메뉴 항목의 표시기는 &lt;a href=&quot;#indicator-sub&quot;&gt;:: indicator&lt;/a&gt; 하위 제어를 사용하여 스타일이 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="8aac02d3f85517fe8ff4bf9891946770f6b81da9" translate="yes" xml:space="preserve">
          <source>The indicator of checkable menu items is styled using the &lt;a href=&quot;stylesheet-reference#indicator-sub&quot;&gt;::indicator&lt;/a&gt; subcontrol.</source>
          <target state="translated">확인 가능한 메뉴 항목의 표시기는 &lt;a href=&quot;stylesheet-reference#indicator-sub&quot;&gt;:: indicator&lt;/a&gt; 하위 제어를 사용하여 스타일이 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="275ab480e7cddc4b9261f4c6e9380c5479ee2666" translate="yes" xml:space="preserve">
          <source>The individual components of a route.</source>
          <target state="translated">경로의 개별 구성 요소</target>
        </trans-unit>
        <trans-unit id="05fa2e85b2ee9a0a4d5a41ecb2c545ff6fe8dcee" translate="yes" xml:space="preserve">
          <source>The individual padding properties assume the value of the &lt;code&gt;padding&lt;/code&gt; property unless they are set explicitly. For example, if &lt;code&gt;padding&lt;/code&gt; is set to &lt;code&gt;4&lt;/code&gt; and &lt;code&gt;leftPadding&lt;/code&gt; to &lt;code&gt;8&lt;/code&gt;, &lt;code&gt;8&lt;/code&gt; will be used as the left padding.</source>
          <target state="translated">개별 패딩 속성 은 명시 적으로 설정되지 않는 한 &lt;code&gt;padding&lt;/code&gt; 속성 의 값을 가정합니다 . 예를 들어 &lt;code&gt;padding&lt;/code&gt; 을 &lt;code&gt;4&lt;/code&gt; 로 설정 하고 &lt;code&gt;leftPadding&lt;/code&gt; 을 &lt;code&gt;8&lt;/code&gt; 로 설정 하면 &lt;code&gt;8&lt;/code&gt; 이 왼쪽 패딩으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ef9ac32630f1cfe301619dc750b3e7466b96b893" translate="yes" xml:space="preserve">
          <source>The individual tabs can by styled using the &lt;a href=&quot;#tab-sub&quot;&gt;::tab&lt;/a&gt; subcontrol. The tabs support the &lt;a href=&quot;#only-one-ps&quot;&gt;:only-one&lt;/a&gt;, &lt;a href=&quot;#first-ps&quot;&gt;:first&lt;/a&gt;, &lt;a href=&quot;#last-ps&quot;&gt;:last&lt;/a&gt;, &lt;a href=&quot;#middle-ps&quot;&gt;:middle&lt;/a&gt;, &lt;a href=&quot;#previous-selected-ps&quot;&gt;:previous-selected&lt;/a&gt;, &lt;a href=&quot;#next-selected-ps&quot;&gt;:next-selected&lt;/a&gt;, &lt;a href=&quot;#selected-ps&quot;&gt;:selected&lt;/a&gt; pseudo states.</source>
          <target state="translated">개별 탭은 &lt;a href=&quot;#tab-sub&quot;&gt;:: tab&lt;/a&gt; 하위 컨트롤을 사용하여 스타일을 지정할 수 있습니다 . 이 탭은 &lt;a href=&quot;#only-one-ps&quot;&gt;: only-one&lt;/a&gt; , &lt;a href=&quot;#first-ps&quot;&gt;: first&lt;/a&gt; , &lt;a href=&quot;#last-ps&quot;&gt;: last&lt;/a&gt; , &lt;a href=&quot;#middle-ps&quot;&gt;: middle&lt;/a&gt; , &lt;a href=&quot;#previous-selected-ps&quot;&gt;: previous-selected&lt;/a&gt; , &lt;a href=&quot;#next-selected-ps&quot;&gt;: next-selected&lt;/a&gt; , &lt;a href=&quot;#selected-ps&quot;&gt;: selected&lt;/a&gt; pseudo state를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="e09f3cc7b5557724ba5a29987e0fce5589e1e89e" translate="yes" xml:space="preserve">
          <source>The individual tabs can by styled using the &lt;a href=&quot;stylesheet-reference#tab-sub&quot;&gt;::tab&lt;/a&gt; subcontrol. The tabs support the &lt;a href=&quot;stylesheet-reference#only-one-ps&quot;&gt;:only-one&lt;/a&gt;, &lt;a href=&quot;stylesheet-reference#first-ps&quot;&gt;:first&lt;/a&gt;, &lt;a href=&quot;stylesheet-reference#last-ps&quot;&gt;:last&lt;/a&gt;, &lt;a href=&quot;stylesheet-reference#middle-ps&quot;&gt;:middle&lt;/a&gt;, &lt;a href=&quot;stylesheet-reference#previous-selected-ps&quot;&gt;:previous-selected&lt;/a&gt;, &lt;a href=&quot;stylesheet-reference#next-selected-ps&quot;&gt;:next-selected&lt;/a&gt;, &lt;a href=&quot;stylesheet-reference#selected-ps&quot;&gt;:selected&lt;/a&gt; pseudo states.</source>
          <target state="translated">개별 탭은 &lt;a href=&quot;stylesheet-reference#tab-sub&quot;&gt;:: tab&lt;/a&gt; 하위 컨트롤을 사용하여 스타일을 지정할 수 있습니다 . 탭은 &lt;a href=&quot;stylesheet-reference#only-one-ps&quot;&gt;: only-one&lt;/a&gt; , &lt;a href=&quot;stylesheet-reference#first-ps&quot;&gt;: first&lt;/a&gt; , &lt;a href=&quot;stylesheet-reference#last-ps&quot;&gt;: last&lt;/a&gt; , &lt;a href=&quot;stylesheet-reference#middle-ps&quot;&gt;: middle&lt;/a&gt; , &lt;a href=&quot;stylesheet-reference#previous-selected-ps&quot;&gt;: previous-selected&lt;/a&gt; , &lt;a href=&quot;stylesheet-reference#next-selected-ps&quot;&gt;: next-selected&lt;/a&gt; , &lt;a href=&quot;stylesheet-reference#selected-ps&quot;&gt;: selected&lt;/a&gt; 유사 상태를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="02cf5069a688c2b6ae46714aae5def872d53cced" translate="yes" xml:space="preserve">
          <source>The information is stored in the system registry on Windows, and in XML preferences files on &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt;. On other Unix systems, in the absence of a standard, INI text files are used. See &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; documentation for more details.</source>
          <target state="translated">정보는 Windows의 시스템 레지스트리 및 &lt;a href=&quot;internationalization#macos&quot;&gt;macOS의&lt;/a&gt; XML 환경 설정 파일에 저장 됩니다 . 다른 유닉스 시스템에서는 표준이 없으면 INI 텍스트 파일이 사용됩니다. 자세한 내용은 &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5e90f1faad372880239a2826725789825979637c" translate="yes" xml:space="preserve">
          <source>The information is stored in the system registry on Windows, and in XML preferences files on macOS. On other Unix systems, in the absence of a standard, INI text files are used. See &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; documentation for more details.</source>
          <target state="translated">정보는 Windows의 시스템 레지스트리와 macOS의 XML 기본 설정 파일에 저장됩니다. 다른 Unix 시스템에서는 표준이없는 경우 INI 텍스트 파일이 사용됩니다. 자세한 내용은 &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b940381f7e031c20b30f9a865a2379cfeba54aa3" translate="yes" xml:space="preserve">
          <source>The information on which clocks types may overflow and how to remedy that issue is documented along with the clock types.</source>
          <target state="translated">어떤 시계 유형이 오버플로 될 수 있는지와 해당 문제를 해결하는 방법에 대한 정보는 시계 유형과 함께 문서화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="527d7a5d657e52f3d8611912548b9497109607a2" translate="yes" xml:space="preserve">
          <source>The information within a document can be accessed via two complementary interfaces: A cursor-based interface is used for editing, and a read-only hierarchical interface provides a high level overview of the document structure. The main advantage of the cursor-based interface is that the text can be edited using operations that mimic a user's interaction with an editor, without losing the underlying structure of the document. The read-only hierarchical interface is most useful when performing operations such as searching and document export.</source>
          <target state="translated">문서 내의 정보는 두 가지 보완 인터페이스를 통해 액세스 할 수 있습니다. 커서 기반 인터페이스는 편집에 사용되며 읽기 전용 계층 인터페이스는 문서 구조에 대한 개괄적 인 개요를 제공합니다. 커서 기반 인터페이스의 주요 장점은 문서의 기본 구조를 그대로 유지하면서 편집기와 사용자의 상호 작용을 모방하는 작업을 사용하여 텍스트를 편집 할 수 있다는 것입니다. 읽기 전용 계층 인터페이스는 검색 및 문서 내보내기와 같은 작업을 수행 할 때 가장 유용합니다.</target>
        </trans-unit>
        <trans-unit id="c3435f4a04ccab9192bd0afa2de8f02680435993" translate="yes" xml:space="preserve">
          <source>The informative text that provides a fuller description for the message.</source>
          <target state="translated">메시지에 대한 자세한 설명을 제공하는 유익한 텍스트입니다.</target>
        </trans-unit>
        <trans-unit id="7332c47e748c943058b7e15ed98f04b0d312af72" translate="yes" xml:space="preserve">
          <source>The initial I/O device is usually set in the constructor, but can be changed with &lt;a href=&quot;qdatastream#setDevice&quot;&gt;setDevice&lt;/a&gt;(). If you've reached the end of the data (or if there is no I/O device set) &lt;a href=&quot;qdatastream#atEnd&quot;&gt;atEnd&lt;/a&gt;() will return true.</source>
          <target state="translated">초기 I / O 장치는 일반적으로 생성자에서 설정되지만 &lt;a href=&quot;qdatastream#setDevice&quot;&gt;setDevice&lt;/a&gt; () 로 변경할 수 있습니다 . 데이터의 끝에 도달했거나 I / O 장치가 설정되지 않은 경우 &lt;a href=&quot;qdatastream#atEnd&quot;&gt;atEnd&lt;/a&gt; ()는 true를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="dbff8415d28196d14aa8816ee5fe2111b11dbc0d" translate="yes" xml:space="preserve">
          <source>The initial camera state, with camera not loaded, the camera capabilities except of supported capture modes are unknown.</source>
          <target state="translated">카메라가로드되지 않은 초기 카메라 상태는 지원되는 캡처 모드를 제외한 카메라 기능을 알 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1951a628d164e8aae0893ffdca347547deb6e2cb" translate="yes" xml:space="preserve">
          <source>The initial camera state, with camera not loaded. The camera capabilities, except supported capture modes, are unknown. While the supported settings are unknown in this state, it's allowed to set the camera capture settings like codec, resolution, or frame rate.</source>
          <target state="translated">카메라가로드되지 않은 초기 카메라 상태입니다. 지원되는 캡처 모드를 제외한 카메라 기능은 알 수 없습니다. 이 상태에서는 지원되는 설정을 알 수 없지만 코덱, 해상도 또는 프레임 속도와 같은 카메라 캡처 설정을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="12982f28b5117c7ec01ff31f4217f3c549b5dcdf" translate="yes" xml:space="preserve">
          <source>The initial camera state, with the camera not loaded. The camera capabilities (with the exception of supported capture modes) are unknown. This state saves the most power, but takes the longest time to be ready for capture.</source>
          <target state="translated">카메라가로드되지 않은 초기 카메라 상태입니다. 지원되는 캡처 모드를 제외한 카메라 기능은 알려져 있지 않습니다. 이 상태는 최대 전력을 절약하지만 캡처 준비에 가장 오랜 시간이 걸립니다.</target>
        </trans-unit>
        <trans-unit id="2fb9c6b0609caa13b1912eec359de7c11fdcfd30" translate="yes" xml:space="preserve">
          <source>The initial camera state, with the camera not loaded. The camera capabilities (with the exception of supported capture modes) are unknown. This state saves the most power, but takes the longest time to be ready for capture. While the supported settings are unknown in this state, you can still set the camera capture settings like codec, resolution, or frame rate.</source>
          <target state="translated">카메라가로드되지 않은 초기 카메라 상태입니다. 카메라 기능 (지원되는 캡처 모드 제외)을 알 수 없습니다. 이 상태는 가장 많은 전력을 절약하지만 캡처 준비에 가장 오랜 시간이 걸립니다. 이 상태에서는 지원되는 설정을 알 수 없지만 코덱, 해상도 또는 프레임 속도와 같은 카메라 캡처 설정을 계속 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dcd09948e40ad3cc0a808da25331e438a8d30b6d" translate="yes" xml:space="preserve">
          <source>The initial camera status, with camera not loaded. The camera capabilities including supported capture settings may be unknown.</source>
          <target state="translated">카메라가로드되지 않은 초기 카메라 상태입니다. 지원되는 캡처 설정을 포함한 카메라 기능을 알 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b458e27a5919e8b03c34533d8cbe0055ca726689" translate="yes" xml:space="preserve">
          <source>The initial delay and the repetition interval are defined in milliseconds by &lt;a href=&quot;qml-qtquick-controls2-abstractbutton#autoRepeatDelay-prop&quot;&gt;autoRepeatDelay&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-controls2-abstractbutton#autoRepeatInterval-prop&quot;&gt;autoRepeatInterval&lt;/a&gt;.</source>
          <target state="translated">초기 지연 및 반복 간격은 &lt;a href=&quot;qml-qtquick-controls2-abstractbutton#autoRepeatDelay-prop&quot;&gt;autoRepeatDelay&lt;/a&gt; 및 &lt;a href=&quot;qml-qtquick-controls2-abstractbutton#autoRepeatInterval-prop&quot;&gt;autoRepeatInterval에&lt;/a&gt; 의해 밀리 초 단위로 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="f89bf08539914e9a6de13245a0b4a1e7d740637b" translate="yes" xml:space="preserve">
          <source>The initial distribution of size between the widgets is determined by multiplying the initial size with the stretch factor. You can also use &lt;a href=&quot;qsplitter#setSizes&quot;&gt;setSizes&lt;/a&gt;() to set the sizes of all the widgets. The function &lt;a href=&quot;qsplitter#sizes&quot;&gt;sizes&lt;/a&gt;() returns the sizes set by the user. Alternatively, you can save and restore the sizes of the widgets from a &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; using &lt;a href=&quot;qsplitter#saveState&quot;&gt;saveState&lt;/a&gt;() and &lt;a href=&quot;qsplitter#restoreState&quot;&gt;restoreState&lt;/a&gt;() respectively.</source>
          <target state="translated">위젯 사이의 초기 크기 분포는 초기 크기에 신축 계수를 곱하여 결정됩니다. &lt;a href=&quot;qsplitter#setSizes&quot;&gt;setSizes&lt;/a&gt; ()를 사용하여 모든 위젯의 크기를 설정할 수도 있습니다 . 함수 &lt;a href=&quot;qsplitter#sizes&quot;&gt;크기&lt;/a&gt; ()는 사용자가 설정 한 크기를 반환합니다. 또는 각각 &lt;a href=&quot;qsplitter#saveState&quot;&gt;saveState&lt;/a&gt; () 및 &lt;a href=&quot;qsplitter#restoreState&quot;&gt;restoreState&lt;/a&gt; ()를 사용하여 &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; 에서 위젯의 크기를 저장하고 복원 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cce314e73345d9e93d482a95c6baa9aafbdaf384" translate="yes" xml:space="preserve">
          <source>The initial drag position is defined by</source>
          <target state="translated">초기 드래그 위치는</target>
        </trans-unit>
        <trans-unit id="514d3443121065eb0b44ffd4504385958ed78a36" translate="yes" xml:space="preserve">
          <source>The initial linking of the server includes a temporary type library resource</source>
          <target state="translated">서버의 초기 링크에는 임시 유형 라이브러리 자원이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="62c80e1a7dd5a70767db49bcf0f62e79e1cb6cc5" translate="yes" xml:space="preserve">
          <source>The initial set of instantiable delegate items in a &lt;a href=&quot;qml-qtqml-models-delegatemodel&quot;&gt;DelegateModel&lt;/a&gt; is represented by its &lt;a href=&quot;qml-qtqml-models-delegatemodel#items-prop&quot;&gt;items&lt;/a&gt; group, which normally directly reflects the contents of the model assigned to &lt;a href=&quot;qml-qtqml-models-delegatemodel#model-attached-prop&quot;&gt;DelegateModel::model&lt;/a&gt;. This set can be changed to the contents of any other member of &lt;a href=&quot;qml-qtqml-models-delegatemodel#groups-attached-prop&quot;&gt;DelegateModel::groups&lt;/a&gt; by assigning the &lt;a href=&quot;qml-qtqml-models-delegatemodelgroup#name-prop&quot;&gt;name&lt;/a&gt; of that &lt;a href=&quot;qml-qtqml-models-delegatemodelgroup&quot;&gt;DelegateModelGroup&lt;/a&gt; to the &lt;a href=&quot;qml-qtqml-models-delegatemodel#filterOnGroup-prop&quot;&gt;DelegateModel::filterOnGroup&lt;/a&gt; property.</source>
          <target state="translated">A의 인스턴스화 위임 항목의 초기 설정 &lt;a href=&quot;qml-qtqml-models-delegatemodel&quot;&gt;DelegateModel는&lt;/a&gt; 자사에 의해 표현되는 &lt;a href=&quot;qml-qtqml-models-delegatemodel#items-prop&quot;&gt;항목&lt;/a&gt; 일반적으로 직접 할당 모델의 내용을 반영 그룹, &lt;a href=&quot;qml-qtqml-models-delegatemodel#model-attached-prop&quot;&gt;DelegateModel :: 모델&lt;/a&gt; . 이 세트의 다른 멤버의 내용을 변경할 수 있습니다 &lt;a href=&quot;qml-qtqml-models-delegatemodel#groups-attached-prop&quot;&gt;DelegateModel : 그룹&lt;/a&gt; 할당하는 의해 &lt;a href=&quot;qml-qtqml-models-delegatemodelgroup#name-prop&quot;&gt;이름&lt;/a&gt; 이의 &lt;a href=&quot;qml-qtqml-models-delegatemodelgroup&quot;&gt;DelegateModelGroup&lt;/a&gt; 받는 &lt;a href=&quot;qml-qtqml-models-delegatemodel#filterOnGroup-prop&quot;&gt;DelegateModel :: filterOnGroup의&lt;/a&gt; 속성을.</target>
        </trans-unit>
        <trans-unit id="4119ff786c8db609d5d73f4ceb20cbd25c7cf7b3" translate="yes" xml:space="preserve">
          <source>The initial set of instantiable delegate items in a &lt;a href=&quot;qml-qtqml-models-delegatemodel&quot;&gt;DelegateModel&lt;/a&gt; is represented by its &lt;a href=&quot;qml-qtqml-models-delegatemodel#items-prop&quot;&gt;items&lt;/a&gt; group, which normally directly reflects the contents of the model assigned to &lt;a href=&quot;qml-qtqml-models-delegatemodel#model-attached-prop&quot;&gt;DelegateModel::model&lt;/a&gt;. This set can be changed to the contents of any other member of &lt;a href=&quot;qml-qtqml-models-delegatemodel#groups-attached-prop&quot;&gt;DelegateModel::groups&lt;/a&gt; by assigning the &lt;a href=&quot;qml-qtqml-models-delegatemodelgroup#name-prop&quot;&gt;name&lt;/a&gt; of that DelegateModelGroup to the &lt;a href=&quot;qml-qtqml-models-delegatemodel#filterOnGroup-prop&quot;&gt;DelegateModel::filterOnGroup&lt;/a&gt; property.</source>
          <target state="translated">A의 인스턴스화 위임 항목의 초기 설정 &lt;a href=&quot;qml-qtqml-models-delegatemodel&quot;&gt;DelegateModel는&lt;/a&gt; 자사에 의해 표현되는 &lt;a href=&quot;qml-qtqml-models-delegatemodel#items-prop&quot;&gt;항목&lt;/a&gt; 일반적으로 직접 할당 모델의 내용을 반영 그룹, &lt;a href=&quot;qml-qtqml-models-delegatemodel#model-attached-prop&quot;&gt;DelegateModel :: 모델&lt;/a&gt; . 이 집합은 &lt;a href=&quot;qml-qtqml-models-delegatemodel#filterOnGroup-prop&quot;&gt;DelegateModel :: filterOnGroup&lt;/a&gt; 속성 에 해당 DelegateModelGroup 의 &lt;a href=&quot;qml-qtqml-models-delegatemodelgroup#name-prop&quot;&gt;이름&lt;/a&gt; 을 할당하여 &lt;a href=&quot;qml-qtqml-models-delegatemodel#groups-attached-prop&quot;&gt;DelegateModel :: groups&lt;/a&gt; 의 다른 멤버의 내용으로 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="238deb3f1efe99167ae9606b2beb247754212bd2" translate="yes" xml:space="preserve">
          <source>The initial state of this state (one of its child states).</source>
          <target state="translated">이 상태의 초기 상태 (자식 상태 중 하나).</target>
        </trans-unit>
        <trans-unit id="c776a2f06d440b4beff49b0000f192c7384e2135" translate="yes" xml:space="preserve">
          <source>The initial status after the document has been created or after it has been closed.</source>
          <target state="translated">문서가 생성 된 후 또는 마감 된 후의 초기 상태입니다.</target>
        </trans-unit>
        <trans-unit id="250df61ad103390251f1e559a22826210bbf6e5e" translate="yes" xml:space="preserve">
          <source>The initial value is &lt;code&gt;Triangles&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e8255b60f992ec130408acf6566ec22ad1889a1" translate="yes" xml:space="preserve">
          <source>The initial values to be used for setting up the data model.</source>
          <target state="translated">데이터 모델 설정에 사용되는 초기 값입니다.</target>
        </trans-unit>
        <trans-unit id="e2437a8592b92c2b9c4ff8c30b6290221ae79e8a" translate="yes" xml:space="preserve">
          <source>The ink levels and printer status would be monitored by &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; properties. Updates to these properties would emit property changed signals.</source>
          <target state="translated">잉크 수준 및 프린터 상태는 &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 속성 으로 모니터링됩니다 . 이러한 속성을 업데이트하면 속성 변경 신호가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9f205d9160bb531041657e0c951a4773e3d6c348" translate="yes" xml:space="preserve">
          <source>The inline object has various attributes that can be set, for example using, &lt;a href=&quot;qtextinlineobject#setWidth&quot;&gt;setWidth&lt;/a&gt;(), &lt;a href=&quot;qtextinlineobject#setAscent&quot;&gt;setAscent&lt;/a&gt;(), and &lt;a href=&quot;qtextinlineobject#setDescent&quot;&gt;setDescent&lt;/a&gt;(). The rectangle it occupies is given by &lt;a href=&quot;qtextinlineobject#rect&quot;&gt;rect&lt;/a&gt;(), and its direction by &lt;a href=&quot;qtextinlineobject#textDirection&quot;&gt;textDirection&lt;/a&gt;(). Its position in the text layout is given by &lt;a href=&quot;qtextinlineobject#textPosition&quot;&gt;textPosition&lt;/a&gt;(), and its format is given by &lt;a href=&quot;qtextinlineobject#format&quot;&gt;format&lt;/a&gt;().</source>
          <target state="translated">인라인 객체에는 &lt;a href=&quot;qtextinlineobject#setWidth&quot;&gt;setWidth&lt;/a&gt; (), &lt;a href=&quot;qtextinlineobject#setAscent&quot;&gt;setAscent&lt;/a&gt; () 및 &lt;a href=&quot;qtextinlineobject#setDescent&quot;&gt;setDescent&lt;/a&gt; () 등을 사용하여 설정할 수있는 다양한 속성이 있습니다 . 차지하는 사각형은 &lt;a href=&quot;qtextinlineobject#rect&quot;&gt;rect&lt;/a&gt; ()로, 방향은 &lt;a href=&quot;qtextinlineobject#textDirection&quot;&gt;textDirection&lt;/a&gt; ()으로 표시됩니다. 텍스트 레이아웃에서의 위치는 &lt;a href=&quot;qtextinlineobject#textPosition&quot;&gt;textPosition&lt;/a&gt; ()으로 지정되고 &lt;a href=&quot;qtextinlineobject#format&quot;&gt;형식&lt;/a&gt; 은 format () 으로 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="0ad4fa09391444f02f32e29b6c1849d6961d11f1" translate="yes" xml:space="preserve">
          <source>The input context is used by the keyboard as well as concrete input methods. &lt;a href=&quot;qml-qtquick-virtualkeyboard-inputcontext&quot;&gt;InputContext&lt;/a&gt; is a singleton instance hosted by QML. An application should not directly interact with the input context.</source>
          <target state="translated">입력 컨텍스트는 구체적인 입력 방법뿐만 아니라 키보드에서도 사용됩니다. &lt;a href=&quot;qml-qtquick-virtualkeyboard-inputcontext&quot;&gt;InputContext&lt;/a&gt; 는 QML이 호스팅하는 싱글 톤 인스턴스입니다. 응용 프로그램은 입력 컨텍스트와 직접 상호 작용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="53a139dafffb40fb9b0e147ac36c1f271bd423c1" translate="yes" xml:space="preserve">
          <source>The input context provides access to contextual information that originates from the application. This information includes, but is not limited to:</source>
          <target state="translated">입력 컨텍스트는 애플리케이션에서 발생하는 컨텍스트 정보에 대한 액세스를 제공합니다. 이 정보에는 다음이 포함되지만 이에 국한되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="f3296be6a6dbf420c3997f9195782c7180dd4e8f" translate="yes" xml:space="preserve">
          <source>The input context.</source>
          <target state="translated">입력 컨텍스트</target>
        </trans-unit>
        <trans-unit id="f306be8488b7817bb58f54dd5bebf3d39a63928d" translate="yes" xml:space="preserve">
          <source>The input data for the QXmlReader subclasses</source>
          <target state="translated">QXmlReader 서브 클래스의 입력 데이터</target>
        </trans-unit>
        <trans-unit id="eaecfee86901cc0f1cc93b263f49cc624c388a00" translate="yes" xml:space="preserve">
          <source>The input data should not be processed from the Traces whose &lt;code&gt;canceled&lt;/code&gt; property set to true.</source>
          <target state="translated">&lt;code&gt;canceled&lt;/code&gt; 특성이 true로 설정된 추적에서 입력 데이터를 처리해서는 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="c34c4a015d42bcc6a0fa9185c442979b83542604" translate="yes" xml:space="preserve">
          <source>The input device doesn't support scroll phase. This value was introduced in Qt 5.7.</source>
          <target state="translated">입력 장치가 스크롤 단계를 지원하지 않습니다. 이 값은 Qt 5.7에 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="740658ab6bd08f7ea238ebdc5a12f2ccdcb20c08" translate="yes" xml:space="preserve">
          <source>The input engine also includes the default input method, which takes care of default processing if the active input method does not handle the event.</source>
          <target state="translated">입력 엔진에는 기본 입력 방법도 포함되어 있는데, 활성 입력 방법이 이벤트를 처리하지 않으면 기본 처리를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="8356fbfffc7e37e3826b18c68547a693955d04f6" translate="yes" xml:space="preserve">
          <source>The input engine is responsible for routing input events to input methods. The actual input logic is implemented by the input methods.</source>
          <target state="translated">입력 엔진은 입력 이벤트를 입력 방법으로 라우팅하는 역할을합니다. 실제 입력 로직은 입력 방법으로 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="4b313d501166870a2b6d841be4e82ae9dfed7dfc" translate="yes" xml:space="preserve">
          <source>The input engine object is owned by &lt;a href=&quot;qml-qtquick-virtualkeyboard-inputcontext&quot;&gt;InputContext&lt;/a&gt;. Like the &lt;a href=&quot;qml-qtquick-virtualkeyboard-inputcontext&quot;&gt;InputContext&lt;/a&gt;, there is only one instance of the &lt;a href=&quot;qvirtualkeyboardinputengine&quot;&gt;QVirtualKeyboardInputEngine&lt;/a&gt;. The input engine contains API functions which the keyboard uses to map user interactions, such as key press and release events, to the input method.</source>
          <target state="translated">입력 엔진 객체는 &lt;a href=&quot;qml-qtquick-virtualkeyboard-inputcontext&quot;&gt;InputContext&lt;/a&gt; 소유 입니다. &lt;a href=&quot;qml-qtquick-virtualkeyboard-inputcontext&quot;&gt;InputContext&lt;/a&gt; 와 마찬가지로 &lt;a href=&quot;qvirtualkeyboardinputengine&quot;&gt;QVirtualKeyboardInputEngine&lt;/a&gt; 인스턴스는 하나만 있습니다. 입력 엔진에는 키보드가 키 누르기 및 놓기 이벤트와 같은 사용자 상호 작용을 입력 방법에 매핑하는 데 사용하는 API 기능이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae3761b36504cc3096b9a2f4cc41f82284ed3f29" translate="yes" xml:space="preserve">
          <source>The input engine.</source>
          <target state="translated">입력 엔진.</target>
        </trans-unit>
        <trans-unit id="abc88d39a7469da945658aedce043dee59737c27" translate="yes" xml:space="preserve">
          <source>The input framework makes it easy to write custom input methods or to integrate 3rd party input engines. The input methods can be implemented in C++ or QML.</source>
          <target state="translated">입력 프레임 워크를 사용하면 사용자 지정 입력 방법을 쉽게 작성하거나 타사 입력 엔진을 통합 할 수 있습니다. 입력 방법은 C ++ 또는 QML로 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="34668dab04e4b94e535251a39f74af4c60f04fc7" translate="yes" xml:space="preserve">
          <source>The input framework provides the following main interfaces:</source>
          <target state="translated">입력 프레임 워크는 다음과 같은 기본 인터페이스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="909b6e037a93f6766de0bfe3596a57c1897d90b2" translate="yes" xml:space="preserve">
          <source>The input mask is an input template string. It can contain the following elements:</source>
          <target state="translated">입력 마스크는 입력 템플릿 문자열입니다. 다음 요소를 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="357a0cef5a1fe3aa1546a9a79743e4b0e9e6b570" translate="yes" xml:space="preserve">
          <source>The input method can collect as many traces as it sees fit and it can begin processing them when necessary. The processing can even be performed in parallel while sampling the data, although it is not recommended because of the potential performance issues. The recommended way is to start processing in a background thread after a suitable delay from the last input, so that the processing does not affect negatively to the user interface.</source>
          <target state="translated">입력 방법은 적합하다고 생각되는만큼 많은 추적을 수집 할 수 있으며 필요할 때 처리를 시작할 수 있습니다. 잠재적 인 성능 문제로 인해 권장되지는 않지만 데이터를 샘플링하는 동안 처리를 병렬로 수행 할 수도 있습니다. 권장되는 방법은 마지막 입력에서 적절한 지연 후에 백그라운드 스레드에서 처리를 시작하여 처리가 사용자 인터페이스에 부정적인 영향을 미치지 않도록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f29627c583515721686349635d981861a6f47456" translate="yes" xml:space="preserve">
          <source>The input method can either be set separately for each keyboard layout, or commonly at this context. If set separately, then this property should not be modified.</source>
          <target state="translated">입력 방법은 각 키보드 레이아웃마다 별도로 설정하거나 일반적으로이 컨텍스트에서 설정할 수 있습니다. 별도로 설정된 경우이 속성을 수정해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="949dc7d280f9521708259f1d83cf3dc81bbc7bff" translate="yes" xml:space="preserve">
          <source>The input method does not participate in the actual collection of trace data. However, the input method has full control over the input since it can either accept or reject a &lt;a href=&quot;qvirtualkeyboardtrace&quot;&gt;QVirtualKeyboardTrace&lt;/a&gt; (e.g. if there are too many instances to handle). This also allows for precise control over how many fingers can be used simultaneously.</source>
          <target state="translated">입력 방법은 실제 추적 데이터 콜렉션에 참여하지 않습니다. 그러나 입력 메소드는 &lt;a href=&quot;qvirtualkeyboardtrace&quot;&gt;QVirtualKeyboardTrace를&lt;/a&gt; 승인하거나 거부 할 수 있으므로 입력을 완전히 제어 할 수 있습니다 (예 : 처리 할 인스턴스가 너무 많은 경우). 또한 동시에 사용할 수있는 손가락 수를 정확하게 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d12b8ba1cd7038a71fe632a52f1585619155e74b" translate="yes" xml:space="preserve">
          <source>The input method emits this signal when the contents of the selection list are changed. The</source>
          <target state="translated">입력 방법은 선택 목록의 내용이 변경 될 때이 신호를 내 보냅니다. 그만큼</target>
        </trans-unit>
        <trans-unit id="1df179701c7f72a876f3acb160c1782b041d5e16" translate="yes" xml:space="preserve">
          <source>The input method emits this signal when the contents of the selection list has changed. The</source>
          <target state="translated">입력 방법은 선택 목록의 내용이 변경되면이 신호를 내 보냅니다. 그만큼</target>
        </trans-unit>
        <trans-unit id="bfa4df650e15538b268114e0edd4e46805b352b1" translate="yes" xml:space="preserve">
          <source>The input method emits this signal when the current</source>
          <target state="translated">입력 방식은 전류가</target>
        </trans-unit>
        <trans-unit id="541348aef8a21db34627e95299ab4b29125fca67" translate="yes" xml:space="preserve">
          <source>The input method emits this signal when the selection list types have changed. This signal will trigger a call to &lt;a href=&quot;qml-qtquick-virtualkeyboard-inputmethod#selectionLists-method&quot;&gt;selectionLists()&lt;/a&gt; method, allowing the input method to update the selection list types.</source>
          <target state="translated">입력 방법은 선택 목록 유형이 변경되면이 신호를 방출합니다. 이 신호는 &lt;a href=&quot;qml-qtquick-virtualkeyboard-inputmethod#selectionLists-method&quot;&gt;selectionLists ()&lt;/a&gt; 메소드에 대한 호출을 트리거 하여 입력 메소드가 선택 목록 유형을 업데이트 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="2f6fa0088b1a82a5bebb19790a19798499ee4e2e" translate="yes" xml:space="preserve">
          <source>The input method emits this signal when the selection list types have changed. This signal will trigger a call to &lt;a href=&quot;qvirtualkeyboardabstractinputmethod#selectionLists&quot;&gt;selectionLists&lt;/a&gt;() method, allowing the input method to update the selection list types.</source>
          <target state="translated">입력 방법은 선택 목록 유형이 변경되면이 신호를 방출합니다. 이 신호는 &lt;a href=&quot;qvirtualkeyboardabstractinputmethod#selectionLists&quot;&gt;selectionLists&lt;/a&gt; () 메소드에 대한 호출을 트리거 하여 입력 메소드가 선택 목록 유형을 업데이트 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="3d2a36836f78af3ca5f8d8bea1eff596347b7749" translate="yes" xml:space="preserve">
          <source>The input method instance can be created in various ways, depending on the use case:</source>
          <target state="translated">사용 방법에 따라 다양한 방법으로 입력 메소드 인스턴스를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="23096ce69358e8027a1aba2a65a63e6c651a5756" translate="yes" xml:space="preserve">
          <source>The input method is a concrete implementation of the keypress handler. It's main function is to handle keypress events and maintain state information for the user input. It interacts with the text editor through &lt;a href=&quot;qvirtualkeyboardinputcontext&quot;&gt;QVirtualKeyboardInputContext&lt;/a&gt; via pre-edit text or key events.</source>
          <target state="translated">입력 방법은 키 누르기 처리기의 구체적인 구현입니다. 주요 기능은 키 누르기 이벤트를 처리하고 사용자 입력에 대한 상태 정보를 유지하는 것입니다. 사전 편집 텍스트 또는 키 이벤트를 통해 &lt;a href=&quot;qvirtualkeyboardinputcontext&quot;&gt;QVirtualKeyboardInputContext&lt;/a&gt; 를 통해 텍스트 편집기와 상호 작용 합니다.</target>
        </trans-unit>
        <trans-unit id="38f3bd38d606df4342e9822a104196915295a4d8" translate="yes" xml:space="preserve">
          <source>The input method may request the input engine to update the selection lists at any time by emitting &lt;a href=&quot;qml-qtquick-virtualkeyboard-inputmethod#selectionListsChanged-signal&quot;&gt;selectionListsChanged()&lt;/a&gt; signal. This signal will trigger a call to this method, allowing the input method to update the selection list types.</source>
          <target state="translated">입력 방법은 &lt;a href=&quot;qml-qtquick-virtualkeyboard-inputmethod#selectionListsChanged-signal&quot;&gt;selectionListsChanged ()&lt;/a&gt; 신호를 방출하여 언제든지 입력 엔진이 선택 목록을 업데이트하도록 요청할 수 있습니다 . 이 신호는이 메소드에 대한 호출을 트리거하여 입력 메소드가 선택 목록 유형을 업데이트 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="4d66246e61c3f8f3e19a95f595e1ab81fb43ebc3" translate="yes" xml:space="preserve">
          <source>The input method may request the input engine to update the selection lists at any time by emitting &lt;a href=&quot;qvirtualkeyboardabstractinputmethod#selectionListsChanged&quot;&gt;selectionListsChanged&lt;/a&gt;() signal. This signal will trigger a call to this method, allowing the input method to update the selection list types.</source>
          <target state="translated">입력 방법은 &lt;a href=&quot;qvirtualkeyboardabstractinputmethod#selectionListsChanged&quot;&gt;selectionListsChanged&lt;/a&gt; () 신호를 방출함으로써 언제든지 입력 엔진이 선택리스트를 업데이트하도록 요청할 수있다 . 이 신호는이 메소드에 대한 호출을 트리거하여 입력 메소드가 선택 목록 유형을 업데이트 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="cc37af8ac35d240484e231bf23787529280e02b1" translate="yes" xml:space="preserve">
          <source>The input method must implement &lt;a href=&quot;qvirtualkeyboardabstractinputmethod&quot;&gt;QVirtualKeyboardAbstractInputMethod&lt;/a&gt; (C++) or &lt;a href=&quot;qml-qtquick-virtualkeyboard-inputmethod&quot;&gt;InputMethod&lt;/a&gt; (QML) interface and the plugin must register it as a QML type in {&lt;a href=&quot;qvirtualkeyboardextensionplugin#registerTypes&quot;&gt;QVirtualKeyboardExtensionPlugin::registerTypes&lt;/a&gt;} method.</source>
          <target state="translated">입력 메소드는 &lt;a href=&quot;qvirtualkeyboardabstractinputmethod&quot;&gt;QVirtualKeyboardAbstractInputMethod&lt;/a&gt; (C ++) 또는 &lt;a href=&quot;qml-qtquick-virtualkeyboard-inputmethod&quot;&gt;InputMethod&lt;/a&gt; (QML) 인터페이스 를 구현해야 하며 플러그인은이를 { &lt;a href=&quot;qvirtualkeyboardextensionplugin#registerTypes&quot;&gt;QVirtualKeyboardExtensionPlugin :: registerTypes&lt;/a&gt; } 메소드 에서 QML 유형으로 등록해야합니다 .</target>
        </trans-unit>
        <trans-unit id="ccf7e13987a1627099a30a50e4d464f07572fd43" translate="yes" xml:space="preserve">
          <source>The input method object created by this function can outlive keyboard layout transitions in certain cases. In particular, this applies to the transitions between the layouts listed in the &lt;a href=&quot;qml-qtquick-virtualkeyboard-keyboardlayout#sharedLayouts-prop&quot;&gt;sharedLayouts&lt;/a&gt; property.</source>
          <target state="translated">이 기능으로 생성 된 입력 방법 객체는 특정 경우 키보드 레이아웃 전환보다 오래 지속될 수 있습니다. 특히 이것은 &lt;a href=&quot;qml-qtquick-virtualkeyboard-keyboardlayout#sharedLayouts-prop&quot;&gt;sharedLayouts&lt;/a&gt; 속성에 나열된 레이아웃 간 전환에 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="db6eb82ec8b895e52bd45aa8ccf7f7fa268203e3" translate="yes" xml:space="preserve">
          <source>The input method object created by this function can outlive keyboard layout transitions in certain cases. In particular, this applies to the transitions between the layouts listed in the &lt;a href=&quot;qml-qtquick-virtualkeyboard-keyboardlayoutloader#sharedLayouts-prop&quot;&gt;sharedLayouts&lt;/a&gt; property.</source>
          <target state="translated">이 기능으로 생성 된 입력 방법 객체는 특정 경우 키보드 레이아웃 전환보다 오래 지속될 수 있습니다. 특히 이것은 &lt;a href=&quot;qml-qtquick-virtualkeyboard-keyboardlayoutloader#sharedLayouts-prop&quot;&gt;sharedLayouts&lt;/a&gt; 속성에 나열된 레이아웃 간 전환에 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="695caaf1a9487e1c2d3fb8c8f16ce5d1d0fbe9e5" translate="yes" xml:space="preserve">
          <source>The input method processes the data and discards the object when it is no longer needed.</source>
          <target state="translated">입력 방법은 데이터를 처리하고 더 이상 필요하지 않은 객체를 버립니다.</target>
        </trans-unit>
        <trans-unit id="3319a216ca608b85e71e0edc9caeefaee6b3af8b" translate="yes" xml:space="preserve">
          <source>The input method returns properties about the state and position of the virtual keyboard. It also provides information about the position of the current focused input element.</source>
          <target state="translated">입력 방법은 가상 키보드의 상태 및 위치에 대한 속성을 반환합니다. 또한 현재 집중된 입력 요소의 위치에 대한 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="fd70a0b56a924ac9e5c4003c9211b3aff16c6d65" translate="yes" xml:space="preserve">
          <source>The input method should not show the characters while typing. This is automatically set when setting &lt;a href=&quot;qlineedit#echoMode-prop&quot;&gt;QLineEdit::echoMode&lt;/a&gt; to &lt;code&gt;Password&lt;/code&gt;. Note that setting &lt;code&gt;ImhHiddenText&lt;/code&gt; does not change the echo mode.</source>
          <target state="translated">입력하는 동안 입력 방법에 문자가 표시되지 않아야합니다. 이것은 &lt;a href=&quot;qlineedit#echoMode-prop&quot;&gt;QLineEdit :: echoMode&lt;/a&gt; 를 &lt;code&gt;Password&lt;/code&gt; 로 설정할 때 자동으로 설정됩니다 . &lt;code&gt;ImhHiddenText&lt;/code&gt; 를 설정해도 에코 모드가 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="34bb43c25fb9450f17a568b7f48e608d7b919671" translate="yes" xml:space="preserve">
          <source>The input method should not try to automatically switch to upper case when a sentence ends.</source>
          <target state="translated">문장이 끝날 때 입력 방법이 대문자로 자동 전환되지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="863f9d21d6acf6df3c47e3705e004730f94b8e00" translate="yes" xml:space="preserve">
          <source>The input mode can either be set separately for each keyboard layout, or commonly at this context. If set separately, then this property should not be modified.</source>
          <target state="translated">입력 모드는 각 키보드 레이아웃마다 별도로 설정하거나 일반적으로이 상황에서 설정할 수 있습니다. 별도로 설정된 경우이 속성을 수정해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="bf48e121e62256b4d96dd7d38df4e01498b24817" translate="yes" xml:space="preserve">
          <source>The input should be opaque or unpremultiplied.</source>
          <target state="translated">입력은 불투명하거나 미리 곱해지지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="77cca2f785530181391a6340d93e17853d41469a" translate="yes" xml:space="preserve">
          <source>The input stream ended before a well-formed XML document was parsed. Recovery from this error is possible if more XML arrives in the stream, either by calling &lt;a href=&quot;qxmlstreamreader#addData&quot;&gt;addData&lt;/a&gt;() or by waiting for it to arrive on the &lt;a href=&quot;qxmlstreamreader#device&quot;&gt;device&lt;/a&gt;().</source>
          <target state="translated">올바른 형식의 XML 문서가 구문 분석되기 전에 입력 스트림이 종료되었습니다. &lt;a href=&quot;qxmlstreamreader#addData&quot;&gt;addData&lt;/a&gt; () 를 호출 하거나 &lt;a href=&quot;qxmlstreamreader#device&quot;&gt;장치&lt;/a&gt; () 에 도착하기를 기다리면서 더 많은 XML이 스트림에 도착하면이 오류를 복구 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b422f02124ada6a1585169dae33731440edce205" translate="yes" xml:space="preserve">
          <source>The input stream ended while parsing a number</source>
          <target state="translated">숫자를 파싱하는 동안 입력 스트림이 종료되었습니다</target>
        </trans-unit>
        <trans-unit id="5ab446b51067a13e7c700453f446f5e2f2fb1f72" translate="yes" xml:space="preserve">
          <source>The input value can be a string, a number or an item from a list. A label must be set to tell the user what they should enter.</source>
          <target state="translated">입력 값은 문자열, 숫자 또는 목록의 항목 일 수 있습니다. 사용자에게 입력해야하는 내용을 알려주는 레이블을 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="d14964cf2ad85edc4a9747112e191d3b46bf6eb7" translate="yes" xml:space="preserve">
          <source>The installation process is straightforward. The Qt Online Installer gives you the choice of installing only the modules and tools you need.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb59cd74a1a42a9a0206181b2bdc5c1122a58f9f" translate="yes" xml:space="preserve">
          <source>The installers allow you to download and install the following components:</source>
          <target state="translated">설치 관리자를 사용하면 다음 구성 요소를 다운로드하고 설치할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e8fa34239dc39edf218727f5b2b1f32d44cad4c" translate="yes" xml:space="preserve">
          <source>The instance is only valid inside a call to &lt;a href=&quot;qsgmaterialshader#updateState&quot;&gt;QSGMaterialShader::updateState&lt;/a&gt;() and should not be used outisde this function.</source>
          <target state="translated">인스턴스는 &lt;a href=&quot;qsgmaterialshader#updateState&quot;&gt;QSGMaterialShader :: updateState&lt;/a&gt; ()에 대한 호출 내에서만 유효 하며이 함수보다 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="cb9bf01ce5ee8dce0d3012ea73fc73805a86a4fd" translate="yes" xml:space="preserve">
          <source>The instance of &lt;a href=&quot;qradiodata&quot;&gt;QRadioData&lt;/a&gt; is already bound to this instance of &lt;a href=&quot;qradiotuner&quot;&gt;QRadioTuner&lt;/a&gt;.</source>
          <target state="translated">의 인스턴스 &lt;a href=&quot;qradiodata&quot;&gt;QRadioData은&lt;/a&gt; 이미의이 인스턴스에 바인딩 &lt;a href=&quot;qradiotuner&quot;&gt;QRadioTuner&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fd093841cfe4e4f3888af1d4939bcb563f2d1627" translate="yes" xml:space="preserve">
          <source>The instance of QHelpFilterSettingsWidget may be a part of a preferences dialog. Before showing the dialog, &lt;a href=&quot;qhelpfiltersettingswidget#setAvailableComponents&quot;&gt;setAvailableComponents&lt;/a&gt;() and &lt;a href=&quot;qhelpfiltersettingswidget#setAvailableVersions&quot;&gt;setAvailableVersions&lt;/a&gt;() should be called, otherwise the filter settings widget will only offer a creation of empty filters, which wouldn't be useful. In addition, &lt;a href=&quot;qhelpfiltersettingswidget#readSettings&quot;&gt;readSettings&lt;/a&gt; should also be called to fill up the filter settings widget with the list of filters already stored in the filter engine. The creation of new filters, modifications to existing filters and removal of unneeded filters are handled by the widget automatically. If you want to store the current state of the widget and apply it to the filter engine e.g. after the user clicked the apply button - call &lt;a href=&quot;qhelpfiltersettingswidget#applySettings&quot;&gt;applySettings&lt;/a&gt;().</source>
          <target state="translated">QHelpFilterSettingsWidget의 인스턴스는 환경 설정 대화 상자의 일부일 수 있습니다. 대화 상자를 표시하기 전에 &lt;a href=&quot;qhelpfiltersettingswidget#setAvailableComponents&quot;&gt;setAvailableComponents&lt;/a&gt; () 및 &lt;a href=&quot;qhelpfiltersettingswidget#setAvailableVersions&quot;&gt;setAvailableVersions&lt;/a&gt; ()를 호출해야합니다. 그렇지 않으면 필터 설정 위젯이 빈 필터 생성 만 제공하므로 유용하지 않습니다. 또한 &lt;a href=&quot;qhelpfiltersettingswidget#readSettings&quot;&gt;readSettings&lt;/a&gt; 를 호출하여 필터 엔진에 이미 저장된 필터 목록으로 필터 설정 위젯을 채워야합니다. 새 필터 생성, 기존 필터 수정 및 불필요한 필터 제거는 위젯에 의해 자동으로 처리됩니다. 위젯의 현재 상태를 저장하고 필터 엔진에 적용하려면 (예 : 사용자가 적용 버튼을 클릭 한 후 ) &lt;a href=&quot;qhelpfiltersettingswidget#applySettings&quot;&gt;applySettings&lt;/a&gt; ()를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="48f98173ba97557619fb7150e067fc4319cb4e47" translate="yes" xml:space="preserve">
          <source>The instance of QRadioData is already bound to this instance of &lt;a href=&quot;qradiotuner&quot;&gt;QRadioTuner&lt;/a&gt;.</source>
          <target state="translated">QRadioData의 인스턴스가 이미의이 인스턴스에 바인딩 &lt;a href=&quot;qradiotuner&quot;&gt;QRadioTuner&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="59dea54a86ab58360f463c2852bccfe26d4360a3" translate="yes" xml:space="preserve">
          <source>The instantaneous velocity of movement along the x and y axes, in pixels/sec.</source>
          <target state="translated">x 및 y 축을 따른 순간 이동 속도 (픽셀 / 초)입니다.</target>
        </trans-unit>
        <trans-unit id="878be06089bfd6c104e539f1a753ebbb89c440e2" translate="yes" xml:space="preserve">
          <source>The instruction indicates that a hard turn to the left is required.</source>
          <target state="translated">이 지시 사항은 왼쪽으로 세게 회전해야 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="308169b4bd8fa80c8090b014d6202cba91e1244a" translate="yes" xml:space="preserve">
          <source>The instruction indicates that a hard turn to the right is required.</source>
          <target state="translated">지시 사항은 오른쪽으로 향한 회전이 필요함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9cfbb5dc5d984946d57e5b94335b573e37af716f" translate="yes" xml:space="preserve">
          <source>The instruction indicates that a light turn to the left is required.</source>
          <target state="translated">이 지시 사항은 왼쪽으로 빛을 돌려야한다는 것을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c58297cc5d0fca23664d6e1142ba95a5d47660d7" translate="yes" xml:space="preserve">
          <source>The instruction indicates that a light turn to the right is required.</source>
          <target state="translated">지시 사항은 오른쪽으로 빛을 돌려야한다는 것을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="84768ca87baf39f89bfc825f4fcf850ba5dd56b3" translate="yes" xml:space="preserve">
          <source>The instruction indicates that a turn to the left is required.</source>
          <target state="translated">이 지시 사항은 왼쪽으로 돌아야 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="1e8eee8df2fa1d49b862fd211c834223dd6be1b7" translate="yes" xml:space="preserve">
          <source>The instruction indicates that a turn to the right is required.</source>
          <target state="translated">지시는 오른쪽으로 돌릴 필요가 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="4faf13bea06ca2289e3453445f6dcfa99bdcd034" translate="yes" xml:space="preserve">
          <source>The instruction indicates that a u-turn to the left is required.</source>
          <target state="translated">이 지시 사항은 왼쪽으로 돌아 가야 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="59606bf409b896dd83739e41b6adb140ac8f941a" translate="yes" xml:space="preserve">
          <source>The instruction indicates that a u-turn to the right is required.</source>
          <target state="translated">지시 사항은 오른쪽으로 u 턴해야 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="03867e2a31c9001ecfd653e6e9bc358dc94136e4" translate="yes" xml:space="preserve">
          <source>The instruction indicates that the direction of travel does not need to change.</source>
          <target state="translated">지시 사항은 이동 방향을 변경할 필요가 없음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b675a80e81dd7ab3860988de97603964ea06c5ac" translate="yes" xml:space="preserve">
          <source>The instruction indicates that the direction of travel should bear to the left.</source>
          <target state="translated">지시 사항은 이동 방향이 왼쪽을 향해야 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="7f80ba28529c4e7a18e40ecb20dd55fef40611cd" translate="yes" xml:space="preserve">
          <source>The instruction indicates that the direction of travel should bear to the right.</source>
          <target state="translated">지시 사항은 여행 방향이 오른쪽을 향해야 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="0c7e707fa867a79ac1d673aa20c929291ce6366b" translate="yes" xml:space="preserve">
          <source>The integration between the Qt Quick 3D components of the stack and the Qt Quick stack are described below in the next sections.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b65155e8cd33b027705b1a91febfdb81005b1654" translate="yes" xml:space="preserve">
          <source>The intended usage is that a &lt;a href=&quot;qplacesearchresult&quot;&gt;QPlaceSearchResult&lt;/a&gt; can be converted into a &lt;a href=&quot;qplaceresult&quot;&gt;QPlaceResult&lt;/a&gt; like so:</source>
          <target state="translated">의도 된 용도는 점이다 &lt;a href=&quot;qplacesearchresult&quot;&gt;QPlaceSearchResult가&lt;/a&gt; 로 변환 할 수 &lt;a href=&quot;qplaceresult&quot;&gt;QPlaceResult&lt;/a&gt; 과 같이 :</target>
        </trans-unit>
        <trans-unit id="71d70cf2af413cef687894b8ca3d75f7618aa42c" translate="yes" xml:space="preserve">
          <source>The intended usage is that a &lt;a href=&quot;qplacesearchresult&quot;&gt;QPlaceSearchResult&lt;/a&gt; can be converted into a QPlaceResult like so:</source>
          <target state="translated">의도 된 용도는 점이다 &lt;a href=&quot;qplacesearchresult&quot;&gt;QPlaceSearchResult이&lt;/a&gt; 때문에 같은 QPlaceResult로 변환 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="5922bbf545574099262c60dc8af92a6e8ff0a0c7" translate="yes" xml:space="preserve">
          <source>The intended usage is that depending on the &lt;a href=&quot;qplacesearchresult#type&quot;&gt;type&lt;/a&gt;, the search result can be converted to a more detailed subclass like so:</source>
          <target state="translated">의도 된 사용법은 &lt;a href=&quot;qplacesearchresult#type&quot;&gt;type&lt;/a&gt; 에 따라 검색 결과가 다음과 같이 더 자세한 하위 클래스로 변환 될 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="4b9ae68557c108227e29131c6756e4c58a5aee2a" translate="yes" xml:space="preserve">
          <source>The intended use-case is that you just plug it into a ranged for loop:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f6ef802828443023caec83cd3fb5ae26a81a072" translate="yes" xml:space="preserve">
          <source>The intensity of the emission. Default is &lt;code&gt;1.0&lt;/code&gt;.</source>
          <target state="translated">방출의 강도. 기본값은 &lt;code&gt;1.0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5d622dc2f32c8a8e6e615069bb50eb18c13f4dd8" translate="yes" xml:space="preserve">
          <source>The inter-digit space is made slightly wider when the decimal point is drawn between the digits.</source>
          <target state="translated">숫자 사이에 소수점이 그려 질 때 숫자 간 간격이 약간 넓어집니다.</target>
        </trans-unit>
        <trans-unit id="be3a30b60cb7a332ed94dac8f4a14b469151f45d" translate="yes" xml:space="preserve">
          <source>The interaction behavior for text in a message box. Possible values are based on &lt;a href=&quot;qt#TextInteractionFlag-enum&quot;&gt;Qt::TextInteractionFlags&lt;/a&gt;.</source>
          <target state="translated">메시지 상자의 텍스트에 대한 상호 작용 동작 가능한 값은 &lt;a href=&quot;qt#TextInteractionFlag-enum&quot;&gt;Qt :: TextInteractionFlags를&lt;/a&gt; 기반으로 합니다.</target>
        </trans-unit>
        <trans-unit id="e768f81929bf44d721633a5c8790735581ec6a5f" translate="yes" xml:space="preserve">
          <source>The interface ID. You must reimplement &lt;a href=&quot;qaxfactory#interfaceID&quot;&gt;QAxFactory::interfaceID&lt;/a&gt; if not specified.</source>
          <target state="translated">인터페이스 ID 지정하지 않으면 &lt;a href=&quot;qaxfactory#interfaceID&quot;&gt;QAxFactory :: interfaceID를&lt;/a&gt; 다시 구현해야 합니다.</target>
        </trans-unit>
        <trans-unit id="084eac0c10c32b267f9c93139d7406fe50757f03" translate="yes" xml:space="preserve">
          <source>The interface is invalid.</source>
          <target state="translated">인터페이스가 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fab10e3e9e2318dfe5b46b1243309cec9de149f7" translate="yes" xml:space="preserve">
          <source>The interface is not intended to be instantiated directly, but to provide access to the selections and widgets of</source>
          <target state="translated">인터페이스는 직접 인스턴스화하기위한 것이 아니라 다음의 선택 및 위젯에 대한 액세스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="8781b6f6be8b82399e3df3efa0de9fd16aeb0d8b" translate="yes" xml:space="preserve">
          <source>The interface is not known in this object (&lt;code&gt;org.freedesktop.DBus.Error.UnknownInterface&lt;/code&gt;)</source>
          <target state="translated">이 객체에서 인터페이스를 알 수 없습니다 ( &lt;code&gt;org.freedesktop.DBus.Error.UnknownInterface&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="9008a6bd1ba26dbd8c831922c4c92cfe53564c0d" translate="yes" xml:space="preserve">
          <source>The interface must be able to calculate bounding rectangles of itself and any children that do not provide an interface of their own. The &lt;code&gt;QAccessibleSlider&lt;/code&gt; has three such children identified by the private enum, &lt;code&gt;SliderElements&lt;/code&gt;, which has the following values: &lt;code&gt;PageLeft&lt;/code&gt; (the rectangle on the left hand side of the slider handle), &lt;code&gt;PageRight&lt;/code&gt; (the rectangle on the right hand side of the handle), and &lt;code&gt;Position&lt;/code&gt; (the slider handle). Here is the implementation of &lt;a href=&quot;qaccessibleinterface#rect&quot;&gt;rect()&lt;/a&gt;:</source>
          <target state="translated">인터페이스는 자체의 경계 사각형과 자체 인터페이스를 제공하지 않는 모든 하위 사각형을 계산할 수 있어야합니다. &lt;code&gt;QAccessibleSlider&lt;/code&gt; 는 개인 ENUM 의해 식별 세 그러한 아이들 갖는다 &lt;code&gt;SliderElements&lt;/code&gt; 다음 값을 갖는다 : &lt;code&gt;PageLeft&lt;/code&gt; (슬라이더 핸들 왼쪽의 직사각형) &lt;code&gt;PageRight&lt;/code&gt; (핸들의 오른쪽의 직사각형) 및 &lt;code&gt;Position&lt;/code&gt; (슬라이더 핸들). &lt;a href=&quot;qaccessibleinterface#rect&quot;&gt;rect ()&lt;/a&gt; 구현은 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="10efb8813624d7fc33727faf597345f253c6d838" translate="yes" xml:space="preserve">
          <source>The interface must be implemented by the developer to be able to monitor every incoming TCP connection from another Modbus client.</source>
          <target state="translated">다른 Modbus 클라이언트에서 들어오는 모든 TCP 연결을 모니터링하려면 개발자가 인터페이스를 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="6f2c6b479a703c487d81e136684d1c4532315906" translate="yes" xml:space="preserve">
          <source>The interface name of &lt;a href=&quot;qaudiodecodercontrol&quot;&gt;QAudioDecoderControl&lt;/a&gt; is &lt;code&gt;org.qt-project.qt.audiodecodercontrol/5.0&lt;/code&gt; as defined in &lt;a href=&quot;qaudiodecodercontrol#QAudioDecoderControl_iid&quot;&gt;QAudioDecoderControl_iid&lt;/a&gt;.</source>
          <target state="translated">인터페이스의 이름 &lt;a href=&quot;qaudiodecodercontrol&quot;&gt;QAudioDecoderControl가&lt;/a&gt; 있다 &lt;code&gt;org.qt-project.qt.audiodecodercontrol/5.0&lt;/code&gt; 에 정의 &lt;a href=&quot;qaudiodecodercontrol#QAudioDecoderControl_iid&quot;&gt;QAudioDecoderControl_iid&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="366b45bce836168038031604ec64de08222e2ae8" translate="yes" xml:space="preserve">
          <source>The interface name of &lt;a href=&quot;qaudioencodersettingscontrol&quot;&gt;QAudioEncoderSettingsControl&lt;/a&gt; is &lt;code&gt;org.qt-project.qt.audioencodersettingscontrol/5.0&lt;/code&gt; as defined in &lt;a href=&quot;qaudioencodersettingscontrol#QAudioEncoderSettingsControl_iid&quot;&gt;QAudioEncoderSettingsControl_iid&lt;/a&gt;.</source>
          <target state="translated">인터페이스의 이름 &lt;a href=&quot;qaudioencodersettingscontrol&quot;&gt;QAudioEncoderSettingsControl가&lt;/a&gt; 있다 &lt;code&gt;org.qt-project.qt.audioencodersettingscontrol/5.0&lt;/code&gt; 에 정의 &lt;a href=&quot;qaudioencodersettingscontrol#QAudioEncoderSettingsControl_iid&quot;&gt;QAudioEncoderSettingsControl_iid&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7ef71286b060abd9b6bf74c852fedac08fb4b7c8" translate="yes" xml:space="preserve">
          <source>The interface name of &lt;a href=&quot;qaudioinputselectorcontrol&quot;&gt;QAudioInputSelectorControl&lt;/a&gt; is &lt;code&gt;org.qt-project.qt.audioinputselectorcontrol/5.0&lt;/code&gt; as defined in &lt;a href=&quot;qaudioinputselectorcontrol#QAudioInputSelectorControl_iid&quot;&gt;QAudioInputSelectorControl_iid&lt;/a&gt;.</source>
          <target state="translated">인터페이스의 이름 &lt;a href=&quot;qaudioinputselectorcontrol&quot;&gt;QAudioInputSelectorControl가&lt;/a&gt; 있다 &lt;code&gt;org.qt-project.qt.audioinputselectorcontrol/5.0&lt;/code&gt; 에 정의 &lt;a href=&quot;qaudioinputselectorcontrol#QAudioInputSelectorControl_iid&quot;&gt;QAudioInputSelectorControl_iid&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7f3eaf9d0cf9bc27625a5d4e1d706aeaaad1ec0b" translate="yes" xml:space="preserve">
          <source>The interface name of &lt;a href=&quot;qaudiooutputselectorcontrol&quot;&gt;QAudioOutputSelectorControl&lt;/a&gt; is &lt;code&gt;org.qt-project.qt.audiooutputselectorcontrol/5.0&lt;/code&gt; as defined in &lt;a href=&quot;qaudiooutputselectorcontrol#QAudioOutputSelectorControl_iid&quot;&gt;QAudioOutputSelectorControl_iid&lt;/a&gt;.</source>
          <target state="translated">인터페이스의 이름 &lt;a href=&quot;qaudiooutputselectorcontrol&quot;&gt;QAudioOutputSelectorControl가&lt;/a&gt; 있다 &lt;code&gt;org.qt-project.qt.audiooutputselectorcontrol/5.0&lt;/code&gt; 에 정의 &lt;a href=&quot;qaudiooutputselectorcontrol#QAudioOutputSelectorControl_iid&quot;&gt;QAudioOutputSelectorControl_iid&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="66e06f0d74ddd042300f4278b48aa012e99d735c" translate="yes" xml:space="preserve">
          <source>The interface name of &lt;a href=&quot;qaudiorolecontrol&quot;&gt;QAudioRoleControl&lt;/a&gt; is &lt;code&gt;org.qt-project.qt.audiorolecontrol/5.6&lt;/code&gt; as defined in &lt;a href=&quot;qaudiorolecontrol#QAudioRoleControl_iid&quot;&gt;QAudioRoleControl_iid&lt;/a&gt;.</source>
          <target state="translated">의 인터페이스 이름 &lt;a href=&quot;qaudiorolecontrol&quot;&gt;QAudioRoleControl은&lt;/a&gt; 입니다 &lt;code&gt;org.qt-project.qt.audiorolecontrol/5.6&lt;/code&gt; 에 정의 된 &lt;a href=&quot;qaudiorolecontrol#QAudioRoleControl_iid&quot;&gt;QAudioRoleControl_iid&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f451c6248869ef9e65c8a62ec95cfd030f2259c8" translate="yes" xml:space="preserve">
          <source>The interface name of &lt;a href=&quot;qcameracapturebufferformatcontrol&quot;&gt;QCameraCaptureBufferFormatControl&lt;/a&gt; is &lt;code&gt;org.qt-project.qt.cameracapturebufferformatcontrol/5.0&lt;/code&gt; as defined in &lt;a href=&quot;qcameracapturebufferformatcontrol#QCameraCaptureBufferFormatControl_iid&quot;&gt;QCameraCaptureBufferFormatControl_iid&lt;/a&gt;.</source>
          <target state="translated">인터페이스의 이름 &lt;a href=&quot;qcameracapturebufferformatcontrol&quot;&gt;QCameraCaptureBufferFormatControl가&lt;/a&gt; 있다 &lt;code&gt;org.qt-project.qt.cameracapturebufferformatcontrol/5.0&lt;/code&gt; 에 정의 &lt;a href=&quot;qcameracapturebufferformatcontrol#QCameraCaptureBufferFormatControl_iid&quot;&gt;QCameraCaptureBufferFormatControl_iid&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="885040ba089ea9a4578c8b227a5ec8480b834da6" translate="yes" xml:space="preserve">
          <source>The interface name of &lt;a href=&quot;qcameracapturedestinationcontrol&quot;&gt;QCameraCaptureDestinationControl&lt;/a&gt; is &lt;code&gt;org.qt-project.qt.cameracapturedestinationcontrol/5.0&lt;/code&gt; as defined in &lt;a href=&quot;qcameracapturedestinationcontrol#QCameraCaptureDestinationControl_iid&quot;&gt;QCameraCaptureDestinationControl_iid&lt;/a&gt;.</source>
          <target state="translated">인터페이스의 이름 &lt;a href=&quot;qcameracapturedestinationcontrol&quot;&gt;QCameraCaptureDestinationControl가&lt;/a&gt; 있다 &lt;code&gt;org.qt-project.qt.cameracapturedestinationcontrol/5.0&lt;/code&gt; 에 정의 &lt;a href=&quot;qcameracapturedestinationcontrol#QCameraCaptureDestinationControl_iid&quot;&gt;QCameraCaptureDestinationControl_iid&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2882d853d209685b0727e6ee3530ded084a08325" translate="yes" xml:space="preserve">
          <source>The interface name of &lt;a href=&quot;qcameracontrol&quot;&gt;QCameraControl&lt;/a&gt; is &lt;code&gt;org.qt-project.qt.cameracontrol/5.0&lt;/code&gt; as defined in &lt;a href=&quot;qcameracontrol#QCameraControl_iid&quot;&gt;QCameraControl_iid&lt;/a&gt;.</source>
          <target state="translated">인터페이스의 이름 &lt;a href=&quot;qcameracontrol&quot;&gt;QCameraControl가&lt;/a&gt; 있다 &lt;code&gt;org.qt-project.qt.cameracontrol/5.0&lt;/code&gt; 에 정의 &lt;a href=&quot;qcameracontrol#QCameraControl_iid&quot;&gt;QCameraControl_iid&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="89be0c6351e9b7f2b3bed5fc6ef4c3e5844078b5" translate="yes" xml:space="preserve">
          <source>The interface name of &lt;a href=&quot;qcameraexposurecontrol&quot;&gt;QCameraExposureControl&lt;/a&gt; is &lt;code&gt;org.qt-project.qt.cameraexposurecontrol/5.0&lt;/code&gt; as defined in &lt;a href=&quot;qcameraexposurecontrol#QCameraExposureControl_iid&quot;&gt;QCameraExposureControl_iid&lt;/a&gt;.</source>
          <target state="translated">인터페이스의 이름 &lt;a href=&quot;qcameraexposurecontrol&quot;&gt;QCameraExposureControl가&lt;/a&gt; 있다 &lt;code&gt;org.qt-project.qt.cameraexposurecontrol/5.0&lt;/code&gt; 에 정의 &lt;a href=&quot;qcameraexposurecontrol#QCameraExposureControl_iid&quot;&gt;QCameraExposureControl_iid&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b5ddeb00429125673442d2d555bb6a5d8aace648" translate="yes" xml:space="preserve">
          <source>The interface name of &lt;a href=&quot;qcamerafeedbackcontrol&quot;&gt;QCameraFeedbackControl&lt;/a&gt; is &lt;code&gt;org.qt-project.qt.camerafeedbackcontrol/5.0&lt;/code&gt; as defined in &lt;a href=&quot;qcamerafeedbackcontrol#QCameraFeedbackControl_iid&quot;&gt;QCameraFeedbackControl_iid&lt;/a&gt;.</source>
          <target state="translated">인터페이스의 이름 &lt;a href=&quot;qcamerafeedbackcontrol&quot;&gt;QCameraFeedbackControl가&lt;/a&gt; 있다 &lt;code&gt;org.qt-project.qt.camerafeedbackcontrol/5.0&lt;/code&gt; 에 정의 &lt;a href=&quot;qcamerafeedbackcontrol#QCameraFeedbackControl_iid&quot;&gt;QCameraFeedbackControl_iid&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1cda2841cee54aa5ac6f37cc93f94f01220c1397" translate="yes" xml:space="preserve">
          <source>The interface name of &lt;a href=&quot;qcameraflashcontrol&quot;&gt;QCameraFlashControl&lt;/a&gt; is &lt;code&gt;org.qt-project.qt.cameraflashcontrol/5.0&lt;/code&gt; as defined in &lt;a href=&quot;qcameraflashcontrol#QCameraFlashControl_iid&quot;&gt;QCameraFlashControl_iid&lt;/a&gt;.</source>
          <target state="translated">인터페이스의 이름 &lt;a href=&quot;qcameraflashcontrol&quot;&gt;QCameraFlashControl가&lt;/a&gt; 있다 &lt;code&gt;org.qt-project.qt.cameraflashcontrol/5.0&lt;/code&gt; 에 정의 &lt;a href=&quot;qcameraflashcontrol#QCameraFlashControl_iid&quot;&gt;QCameraFlashControl_iid&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="477aa9dd9b030ba637f159110fedcf18c2f62e86" translate="yes" xml:space="preserve">
          <source>The interface name of &lt;a href=&quot;qcamerafocuscontrol&quot;&gt;QCameraFocusControl&lt;/a&gt; is &lt;code&gt;org.qt-project.qt.camerafocuscontrol/5.0&lt;/code&gt; as defined in &lt;a href=&quot;qcamerafocuscontrol#QCameraFocusControl_iid&quot;&gt;QCameraFocusControl_iid&lt;/a&gt;.</source>
          <target state="translated">인터페이스의 이름 &lt;a href=&quot;qcamerafocuscontrol&quot;&gt;QCameraFocusControl가&lt;/a&gt; 있다 &lt;code&gt;org.qt-project.qt.camerafocuscontrol/5.0&lt;/code&gt; 에 정의 &lt;a href=&quot;qcamerafocuscontrol#QCameraFocusControl_iid&quot;&gt;QCameraFocusControl_iid&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="22f6de328c14190fec0219ad638eb08ae36a29e1" translate="yes" xml:space="preserve">
          <source>The interface name of &lt;a href=&quot;qcameraimagecapturecontrol&quot;&gt;QCameraImageCaptureControl&lt;/a&gt; is &lt;code&gt;org.qt-project.qt.cameraimagecapturecontrol/5.0&lt;/code&gt; as defined in &lt;a href=&quot;qcameraimagecapturecontrol#QCameraImageCaptureControl_iid&quot;&gt;QCameraImageCaptureControl_iid&lt;/a&gt;.</source>
          <target state="translated">인터페이스의 이름 &lt;a href=&quot;qcameraimagecapturecontrol&quot;&gt;QCameraImageCaptureControl가&lt;/a&gt; 있다 &lt;code&gt;org.qt-project.qt.cameraimagecapturecontrol/5.0&lt;/code&gt; 에 정의 &lt;a href=&quot;qcameraimagecapturecontrol#QCameraImageCaptureControl_iid&quot;&gt;QCameraImageCaptureControl_iid&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6bfc14639279f1eed71746a7ad10f174f561cbdb" translate="yes" xml:space="preserve">
          <source>The interface name of &lt;a href=&quot;qcameraimageprocessingcontrol&quot;&gt;QCameraImageProcessingControl&lt;/a&gt; is &lt;code&gt;org.qt-project.qt.cameraimageprocessingcontrol/5.0&lt;/code&gt; as defined in &lt;a href=&quot;qcameraimageprocessingcontrol#QCameraImageProcessingControl_iid&quot;&gt;QCameraImageProcessingControl_iid&lt;/a&gt;.</source>
          <target state="translated">인터페이스의 이름 &lt;a href=&quot;qcameraimageprocessingcontrol&quot;&gt;QCameraImageProcessingControl가&lt;/a&gt; 있다 &lt;code&gt;org.qt-project.qt.cameraimageprocessingcontrol/5.0&lt;/code&gt; 에 정의 &lt;a href=&quot;qcameraimageprocessingcontrol#QCameraImageProcessingControl_iid&quot;&gt;QCameraImageProcessingControl_iid&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="79803e1c80e9432ce4ed83b9f3afc3f52a1342be" translate="yes" xml:space="preserve">
          <source>The interface name of &lt;a href=&quot;qcamerainfocontrol&quot;&gt;QCameraInfoControl&lt;/a&gt; is &lt;code&gt;org.qt-project.qt.camerainfocontrol/5.3&lt;/code&gt; as defined in &lt;a href=&quot;qvideodeviceselectorcontrol#QCameraInfoControl_iid&quot;&gt;QCameraInfoControl_iid&lt;/a&gt;.</source>
          <target state="translated">의 인터페이스 이름 &lt;a href=&quot;qcamerainfocontrol&quot;&gt;QCameraInfoControl은&lt;/a&gt; 입니다 &lt;code&gt;org.qt-project.qt.camerainfocontrol/5.3&lt;/code&gt; 에 정의 된 &lt;a href=&quot;qvideodeviceselectorcontrol#QCameraInfoControl_iid&quot;&gt;QCameraInfoControl_iid&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c4e45536951a6fad01e1f4a05e27a6e86c1c9426" translate="yes" xml:space="preserve">
          <source>The interface name of &lt;a href=&quot;qcameralockscontrol&quot;&gt;QCameraLocksControl&lt;/a&gt; is &lt;code&gt;org.qt-project.qt.cameralockscontrol/5.0&lt;/code&gt; as defined in &lt;a href=&quot;qcameralockscontrol#QCameraLocksControl_iid&quot;&gt;QCameraLocksControl_iid&lt;/a&gt;.</source>
          <target state="translated">인터페이스의 이름 &lt;a href=&quot;qcameralockscontrol&quot;&gt;QCameraLocksControl가&lt;/a&gt; 있다 &lt;code&gt;org.qt-project.qt.cameralockscontrol/5.0&lt;/code&gt; 에 정의 &lt;a href=&quot;qcameralockscontrol#QCameraLocksControl_iid&quot;&gt;QCameraLocksControl_iid&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="03a3571e2f3be94d4afc8dbead8635b0ff166bc9" translate="yes" xml:space="preserve">
          <source>The interface name of &lt;a href=&quot;qcameraviewfindersettingscontrol&quot;&gt;QCameraViewfinderSettingsControl&lt;/a&gt; is &lt;code&gt;org.qt-project.qt.cameraviewfindersettingscontrol/5.0&lt;/code&gt; as defined in &lt;a href=&quot;qcameraviewfindersettingscontrol#QCameraViewfinderSettingsControl_iid&quot;&gt;QCameraViewfinderSettingsControl_iid&lt;/a&gt;.</source>
          <target state="translated">인터페이스의 이름 &lt;a href=&quot;qcameraviewfindersettingscontrol&quot;&gt;QCameraViewfinderSettingsControl가&lt;/a&gt; 있다 &lt;code&gt;org.qt-project.qt.cameraviewfindersettingscontrol/5.0&lt;/code&gt; 에 정의 &lt;a href=&quot;qcameraviewfindersettingscontrol#QCameraViewfinderSettingsControl_iid&quot;&gt;QCameraViewfinderSettingsControl_iid&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bf05ae950b397f332d78c52e2302f06eabaaec1a" translate="yes" xml:space="preserve">
          <source>The interface name of &lt;a href=&quot;qcameraviewfindersettingscontrol2&quot;&gt;QCameraViewfinderSettingsControl2&lt;/a&gt; is &lt;code&gt;org.qt-project.qt.cameraviewfindersettingscontrol2/5.5&lt;/code&gt; as defined in &lt;a href=&quot;qcameraviewfindersettingscontrol2#QCameraViewfinderSettingsControl2_iid&quot;&gt;QCameraViewfinderSettingsControl2_iid&lt;/a&gt;.</source>
          <target state="translated">의 인터페이스 이름 &lt;a href=&quot;qcameraviewfindersettingscontrol2&quot;&gt;QCameraViewfinderSettingsControl2은&lt;/a&gt; 입니다 &lt;code&gt;org.qt-project.qt.cameraviewfindersettingscontrol2/5.5&lt;/code&gt; 에 정의 된 &lt;a href=&quot;qcameraviewfindersettingscontrol2#QCameraViewfinderSettingsControl2_iid&quot;&gt;QCameraViewfinderSettingsControl2_iid&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c103cbcae68f36d13bad505bfdbc1633e0b76b90" translate="yes" xml:space="preserve">
          <source>The interface name of &lt;a href=&quot;qcamerazoomcontrol&quot;&gt;QCameraZoomControl&lt;/a&gt; is &lt;code&gt;org.qt-project.qt.camerazoomcontrol/5.0&lt;/code&gt; as defined in &lt;a href=&quot;qcamerazoomcontrol#QCameraZoomControl_iid&quot;&gt;QCameraZoomControl_iid&lt;/a&gt;.</source>
          <target state="translated">인터페이스의 이름 &lt;a href=&quot;qcamerazoomcontrol&quot;&gt;QCameraZoomControl가&lt;/a&gt; 있다 &lt;code&gt;org.qt-project.qt.camerazoomcontrol/5.0&lt;/code&gt; 에 정의 &lt;a href=&quot;qcamerazoomcontrol#QCameraZoomControl_iid&quot;&gt;QCameraZoomControl_iid&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8376beeddc41aff7180ffbcfc9f40789a5bb8e58" translate="yes" xml:space="preserve">
          <source>The interface name of &lt;a href=&quot;qcustomaudiorolecontrol&quot;&gt;QCustomAudioRoleControl&lt;/a&gt; is &lt;code&gt;org.qt-project.qt.customaudiorolecontrol/5.11&lt;/code&gt; as defined in &lt;a href=&quot;qcustomaudiorolecontrol#QCustomAudioRoleControl_iid&quot;&gt;QCustomAudioRoleControl_iid&lt;/a&gt;.</source>
          <target state="translated">의 인터페이스 이름 &lt;a href=&quot;qcustomaudiorolecontrol&quot;&gt;QCustomAudioRoleControl은&lt;/a&gt; 입니다 &lt;code&gt;org.qt-project.qt.customaudiorolecontrol/5.11&lt;/code&gt; 에 정의 된 &lt;a href=&quot;qcustomaudiorolecontrol#QCustomAudioRoleControl_iid&quot;&gt;QCustomAudioRoleControl_iid&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d55840940a4d9b7c7f4ce249aa82aa353a5ec175" translate="yes" xml:space="preserve">
          <source>The interface name of &lt;a href=&quot;qimageencodercontrol&quot;&gt;QImageEncoderControl&lt;/a&gt; is &lt;code&gt;org.qt-project.qt.imageencodercontrol/5.0&lt;/code&gt; as defined in &lt;a href=&quot;qimageencodercontrol#QImageEncoderControl_iid&quot;&gt;QImageEncoderControl_iid&lt;/a&gt;.</source>
          <target state="translated">인터페이스의 이름 &lt;a href=&quot;qimageencodercontrol&quot;&gt;QImageEncoderControl가&lt;/a&gt; 있다 &lt;code&gt;org.qt-project.qt.imageencodercontrol/5.0&lt;/code&gt; 에 정의 &lt;a href=&quot;qimageencodercontrol#QImageEncoderControl_iid&quot;&gt;QImageEncoderControl_iid&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1e309c845e8c9546bcb24c6093349a8facf027bc" translate="yes" xml:space="preserve">
          <source>The interface name of &lt;a href=&quot;qmediaaudioprobecontrol&quot;&gt;QMediaAudioProbeControl&lt;/a&gt; is &lt;code&gt;org.qt-project.qt.mediaaudioprobecontrol/5.0&lt;/code&gt; as defined in &lt;a href=&quot;qmediaaudioprobecontrol#QMediaAudioProbeControl_iid&quot;&gt;QMediaAudioProbeControl_iid&lt;/a&gt;.</source>
          <target state="translated">인터페이스의 이름 &lt;a href=&quot;qmediaaudioprobecontrol&quot;&gt;QMediaAudioProbeControl가&lt;/a&gt; 있다 &lt;code&gt;org.qt-project.qt.mediaaudioprobecontrol/5.0&lt;/code&gt; 에 정의 &lt;a href=&quot;qmediaaudioprobecontrol#QMediaAudioProbeControl_iid&quot;&gt;QMediaAudioProbeControl_iid&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5c4e69faf09d3620c72f3c93dee55bfcf6add097" translate="yes" xml:space="preserve">
          <source>The interface name of &lt;a href=&quot;qmediaavailabilitycontrol&quot;&gt;QMediaAvailabilityControl&lt;/a&gt; is &lt;code&gt;org.qt-project.qt.mediaavailabilitycontrol/5.0&lt;/code&gt; as defined in &lt;a href=&quot;qmediaavailabilitycontrol#QMediaAvailabilityControl_iid&quot;&gt;QMediaAvailabilityControl_iid&lt;/a&gt;.</source>
          <target state="translated">인터페이스의 이름 &lt;a href=&quot;qmediaavailabilitycontrol&quot;&gt;QMediaAvailabilityControl가&lt;/a&gt; 있다 &lt;code&gt;org.qt-project.qt.mediaavailabilitycontrol/5.0&lt;/code&gt; 에 정의 &lt;a href=&quot;qmediaavailabilitycontrol#QMediaAvailabilityControl_iid&quot;&gt;QMediaAvailabilityControl_iid&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d268be1e8f45de8666b1adf6786fecafe999fe47" translate="yes" xml:space="preserve">
          <source>The interface name of &lt;a href=&quot;qmediacontainercontrol&quot;&gt;QMediaContainerControl&lt;/a&gt; is &lt;code&gt;org.qt-project.qt.mediacontainercontrol/5.0&lt;/code&gt; as defined in &lt;a href=&quot;qmediacontainercontrol#QMediaContainerControl_iid&quot;&gt;QMediaContainerControl_iid&lt;/a&gt;.</source>
          <target state="translated">인터페이스의 이름 &lt;a href=&quot;qmediacontainercontrol&quot;&gt;QMediaContainerControl가&lt;/a&gt; 있다 &lt;code&gt;org.qt-project.qt.mediacontainercontrol/5.0&lt;/code&gt; 에 정의 &lt;a href=&quot;qmediacontainercontrol#QMediaContainerControl_iid&quot;&gt;QMediaContainerControl_iid&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="15fe804d4297e49e0096971a2c32203776f4b81a" translate="yes" xml:space="preserve">
          <source>The interface name of &lt;a href=&quot;qmediagaplessplaybackcontrol&quot;&gt;QMediaGaplessPlaybackControl&lt;/a&gt; is &lt;code&gt;org.qt-project.qt.mediagaplessplaybackcontrol/5.0&lt;/code&gt; as defined in &lt;a href=&quot;qmediagaplessplaybackcontrol#QMediaGaplessPlaybackControl_iid&quot;&gt;QMediaGaplessPlaybackControl_iid&lt;/a&gt;.</source>
          <target state="translated">인터페이스의 이름 &lt;a href=&quot;qmediagaplessplaybackcontrol&quot;&gt;QMediaGaplessPlaybackControl가&lt;/a&gt; 있다 &lt;code&gt;org.qt-project.qt.mediagaplessplaybackcontrol/5.0&lt;/code&gt; 에 정의 &lt;a href=&quot;qmediagaplessplaybackcontrol#QMediaGaplessPlaybackControl_iid&quot;&gt;QMediaGaplessPlaybackControl_iid&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6ee38947d5d9da1ba020c467f685a4d6096a7c95" translate="yes" xml:space="preserve">
          <source>The interface name of &lt;a href=&quot;qmediaplayercontrol&quot;&gt;QMediaPlayerControl&lt;/a&gt; is &lt;code&gt;org.qt-project.qt.mediaplayercontrol/5.0&lt;/code&gt; as defined in &lt;a href=&quot;qmediaplayercontrol#QMediaPlayerControl_iid&quot;&gt;QMediaPlayerControl_iid&lt;/a&gt;.</source>
          <target state="translated">인터페이스의 이름 &lt;a href=&quot;qmediaplayercontrol&quot;&gt;QMediaPlayerControl가&lt;/a&gt; 있다 &lt;code&gt;org.qt-project.qt.mediaplayercontrol/5.0&lt;/code&gt; 에 정의 &lt;a href=&quot;qmediaplayercontrol#QMediaPlayerControl_iid&quot;&gt;QMediaPlayerControl_iid&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4fdbaa263a6cbddb0a00bd08514bacd805ff8c20" translate="yes" xml:space="preserve">
          <source>The interface name of &lt;a href=&quot;qmediarecordercontrol&quot;&gt;QMediaRecorderControl&lt;/a&gt; is &lt;code&gt;org.qt-project.qt.mediarecordercontrol/5.0&lt;/code&gt; as defined in &lt;a href=&quot;qmediarecordercontrol#QMediaRecorderControl_iid&quot;&gt;QMediaRecorderControl_iid&lt;/a&gt;.</source>
          <target state="translated">인터페이스의 이름 &lt;a href=&quot;qmediarecordercontrol&quot;&gt;QMediaRecorderControl가&lt;/a&gt; 있다 &lt;code&gt;org.qt-project.qt.mediarecordercontrol/5.0&lt;/code&gt; 에 정의 &lt;a href=&quot;qmediarecordercontrol#QMediaRecorderControl_iid&quot;&gt;QMediaRecorderControl_iid&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3c19d0a1ccea88e8eee09618996d9837c6620a5c" translate="yes" xml:space="preserve">
          <source>The interface name of &lt;a href=&quot;qmediastreamscontrol&quot;&gt;QMediaStreamsControl&lt;/a&gt; is &lt;code&gt;org.qt-project.qt.mediastreamscontrol/5.0&lt;/code&gt; as defined in &lt;a href=&quot;qmediastreamscontrol#QMediaStreamsControl_iid&quot;&gt;QMediaStreamsControl_iid&lt;/a&gt;.</source>
          <target state="translated">인터페이스의 이름 &lt;a href=&quot;qmediastreamscontrol&quot;&gt;QMediaStreamsControl가&lt;/a&gt; 있다 &lt;code&gt;org.qt-project.qt.mediastreamscontrol/5.0&lt;/code&gt; 에 정의 &lt;a href=&quot;qmediastreamscontrol#QMediaStreamsControl_iid&quot;&gt;QMediaStreamsControl_iid&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d16e15482bcb2a6394b06f367d81dfa796732021" translate="yes" xml:space="preserve">
          <source>The interface name of &lt;a href=&quot;qmediavideoprobecontrol&quot;&gt;QMediaVideoProbeControl&lt;/a&gt; is &lt;code&gt;org.qt-project.qt.mediavideoprobecontrol/5.0&lt;/code&gt; as defined in &lt;a href=&quot;qmediavideoprobecontrol#QMediaVideoProbeControl_iid&quot;&gt;QMediaVideoProbeControl_iid&lt;/a&gt;.</source>
          <target state="translated">인터페이스의 이름 &lt;a href=&quot;qmediavideoprobecontrol&quot;&gt;QMediaVideoProbeControl가&lt;/a&gt; 있다 &lt;code&gt;org.qt-project.qt.mediavideoprobecontrol/5.0&lt;/code&gt; 에 정의 &lt;a href=&quot;qmediavideoprobecontrol#QMediaVideoProbeControl_iid&quot;&gt;QMediaVideoProbeControl_iid&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1b5ca20815aaea7765a4871ade31def4d3a093b3" translate="yes" xml:space="preserve">
          <source>The interface name of &lt;a href=&quot;qmetadatareadercontrol&quot;&gt;QMetaDataReaderControl&lt;/a&gt; is &lt;code&gt;org.qt-project.qt.metadatareadercontrol/5.0&lt;/code&gt; as defined in &lt;a href=&quot;qmetadatareadercontrol#QMetaDataReaderControl_iid&quot;&gt;QMetaDataReaderControl_iid&lt;/a&gt;.</source>
          <target state="translated">인터페이스의 이름 &lt;a href=&quot;qmetadatareadercontrol&quot;&gt;QMetaDataReaderControl가&lt;/a&gt; 있다 &lt;code&gt;org.qt-project.qt.metadatareadercontrol/5.0&lt;/code&gt; 에 정의 &lt;a href=&quot;qmetadatareadercontrol#QMetaDataReaderControl_iid&quot;&gt;QMetaDataReaderControl_iid&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bfceb164ee31113bdb6aeee689414fff9ca6addd" translate="yes" xml:space="preserve">
          <source>The interface name of &lt;a href=&quot;qmetadatawritercontrol&quot;&gt;QMetaDataWriterControl&lt;/a&gt; is &lt;code&gt;org.qt-project.qt.metadatawritercontrol/5.0&lt;/code&gt; as defined in &lt;a href=&quot;qmetadatawritercontrol#QMetaDataWriterControl_iid&quot;&gt;QMetaDataWriterControl_iid&lt;/a&gt;.</source>
          <target state="translated">인터페이스의 이름 &lt;a href=&quot;qmetadatawritercontrol&quot;&gt;QMetaDataWriterControl가&lt;/a&gt; 있다 &lt;code&gt;org.qt-project.qt.metadatawritercontrol/5.0&lt;/code&gt; 에 정의 &lt;a href=&quot;qmetadatawritercontrol#QMetaDataWriterControl_iid&quot;&gt;QMetaDataWriterControl_iid&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="79fd46ee071e218f44fcb04f0f9ea4f9f91f7eb1" translate="yes" xml:space="preserve">
          <source>The interface name of &lt;a href=&quot;qradiodatacontrol&quot;&gt;QRadioDataControl&lt;/a&gt; is &lt;code&gt;org.qt-project.qt.radiodatacontrol/5.0&lt;/code&gt; as defined in &lt;a href=&quot;qradiodatacontrol#QRadioDataControl_iid&quot;&gt;QRadioDataControl_iid&lt;/a&gt;.</source>
          <target state="translated">인터페이스의 이름 &lt;a href=&quot;qradiodatacontrol&quot;&gt;QRadioDataControl가&lt;/a&gt; 있다 &lt;code&gt;org.qt-project.qt.radiodatacontrol/5.0&lt;/code&gt; 에 정의 &lt;a href=&quot;qradiodatacontrol#QRadioDataControl_iid&quot;&gt;QRadioDataControl_iid&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="285b89a1d1b21f43f605a5628f2073a2249080e0" translate="yes" xml:space="preserve">
          <source>The interface name of &lt;a href=&quot;qradiotunercontrol&quot;&gt;QRadioTunerControl&lt;/a&gt; is &lt;code&gt;org.qt-project.qt.radiotunercontrol/5.0&lt;/code&gt; as defined in &lt;a href=&quot;qradiotunercontrol#QRadioTunerControl_iid&quot;&gt;QRadioTunerControl_iid&lt;/a&gt;.</source>
          <target state="translated">인터페이스의 이름 &lt;a href=&quot;qradiotunercontrol&quot;&gt;QRadioTunerControl가&lt;/a&gt; 있다 &lt;code&gt;org.qt-project.qt.radiotunercontrol/5.0&lt;/code&gt; 에 정의 &lt;a href=&quot;qradiotunercontrol#QRadioTunerControl_iid&quot;&gt;QRadioTunerControl_iid&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="be5aed83bec7b4f11cb1144fd4382297f56cf149" translate="yes" xml:space="preserve">
          <source>The interface name of &lt;a href=&quot;qvideodeviceselectorcontrol&quot;&gt;QVideoDeviceSelectorControl&lt;/a&gt; is &lt;code&gt;org.qt-project.qt.videodeviceselectorcontrol/5.0&lt;/code&gt; as defined in &lt;a href=&quot;qvideodeviceselectorcontrol#QVideoDeviceSelectorControl_iid&quot;&gt;QVideoDeviceSelectorControl_iid&lt;/a&gt;.</source>
          <target state="translated">인터페이스의 이름 &lt;a href=&quot;qvideodeviceselectorcontrol&quot;&gt;QVideoDeviceSelectorControl가&lt;/a&gt; 있다 &lt;code&gt;org.qt-project.qt.videodeviceselectorcontrol/5.0&lt;/code&gt; 에 정의 &lt;a href=&quot;qvideodeviceselectorcontrol#QVideoDeviceSelectorControl_iid&quot;&gt;QVideoDeviceSelectorControl_iid&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="10fd86b3bc4394aea63230f1d4d293c039f42b30" translate="yes" xml:space="preserve">
          <source>The interface name of &lt;a href=&quot;qvideoencodersettingscontrol&quot;&gt;QVideoEncoderSettingsControl&lt;/a&gt; is &lt;code&gt;org.qt-project.qt.videoencodersettingscontrol/5.0&lt;/code&gt; as defined in &lt;a href=&quot;qvideoencodersettingscontrol#QVideoEncoderSettingsControl_iid&quot;&gt;QVideoEncoderSettingsControl_iid&lt;/a&gt;.</source>
          <target state="translated">인터페이스의 이름 &lt;a href=&quot;qvideoencodersettingscontrol&quot;&gt;QVideoEncoderSettingsControl가&lt;/a&gt; 있다 &lt;code&gt;org.qt-project.qt.videoencodersettingscontrol/5.0&lt;/code&gt; 에 정의 &lt;a href=&quot;qvideoencodersettingscontrol#QVideoEncoderSettingsControl_iid&quot;&gt;QVideoEncoderSettingsControl_iid&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="54afb19c9f32d91d8d890b736e0ebbe507f4dbe6" translate="yes" xml:space="preserve">
          <source>The interface name of &lt;a href=&quot;qvideorenderercontrol&quot;&gt;QVideoRendererControl&lt;/a&gt; is &lt;code&gt;org.qt-project.qt.videorenderercontrol/5.0&lt;/code&gt; as defined in &lt;a href=&quot;qvideorenderercontrol#QVideoRendererControl_iid&quot;&gt;QVideoRendererControl_iid&lt;/a&gt;.</source>
          <target state="translated">인터페이스의 이름 &lt;a href=&quot;qvideorenderercontrol&quot;&gt;QVideoRendererControl가&lt;/a&gt; 있다 &lt;code&gt;org.qt-project.qt.videorenderercontrol/5.0&lt;/code&gt; 에 정의 &lt;a href=&quot;qvideorenderercontrol#QVideoRendererControl_iid&quot;&gt;QVideoRendererControl_iid&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e264067bc86e428ef6bb14714be0b1cc361f407c" translate="yes" xml:space="preserve">
          <source>The interface name of &lt;a href=&quot;qvideowidgetcontrol&quot;&gt;QVideoWidgetControl&lt;/a&gt; is &lt;code&gt;org.qt-project.qt.videowidgetcontrol/5.0&lt;/code&gt; as defined in &lt;a href=&quot;qvideowidgetcontrol#QVideoWidgetControl_iid&quot;&gt;QVideoWidgetControl_iid&lt;/a&gt;.</source>
          <target state="translated">인터페이스의 이름 &lt;a href=&quot;qvideowidgetcontrol&quot;&gt;QVideoWidgetControl가&lt;/a&gt; 있다 &lt;code&gt;org.qt-project.qt.videowidgetcontrol/5.0&lt;/code&gt; 에 정의 &lt;a href=&quot;qvideowidgetcontrol#QVideoWidgetControl_iid&quot;&gt;QVideoWidgetControl_iid&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fd272ce5af334e98a14d5b2369ffae3ae1629a06" translate="yes" xml:space="preserve">
          <source>The interface name of &lt;a href=&quot;qvideowindowcontrol&quot;&gt;QVideoWindowControl&lt;/a&gt; is &lt;code&gt;org.qt-project.qt.videowindowcontrol/5.0&lt;/code&gt; as defined in &lt;a href=&quot;qvideowindowcontrol#QVideoWindowControl_iid&quot;&gt;QVideoWindowControl_iid&lt;/a&gt;.</source>
          <target state="translated">인터페이스의 이름 &lt;a href=&quot;qvideowindowcontrol&quot;&gt;QVideoWindowControl가&lt;/a&gt; 있다 &lt;code&gt;org.qt-project.qt.videowindowcontrol/5.0&lt;/code&gt; 에 정의 &lt;a href=&quot;qvideowindowcontrol#QVideoWindowControl_iid&quot;&gt;QVideoWindowControl_iid&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3a7539df547caa4bc3bc6ae58769a69b62674dae" translate="yes" xml:space="preserve">
          <source>The interface name of QAudioDecoderControl is &lt;code&gt;org.qt-project.qt.audiodecodercontrol/5.0&lt;/code&gt; as defined in &lt;a href=&quot;qaudiodecodercontrol#QAudioDecoderControl_iid&quot;&gt;QAudioDecoderControl_iid&lt;/a&gt;.</source>
          <target state="translated">QAudioDecoderControl의 인터페이스 이름이다 &lt;code&gt;org.qt-project.qt.audiodecodercontrol/5.0&lt;/code&gt; 에 정의 &lt;a href=&quot;qaudiodecodercontrol#QAudioDecoderControl_iid&quot;&gt;QAudioDecoderControl_iid&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="84a35df6ae9e1f6b09624879e0a46a5fb6c0b10c" translate="yes" xml:space="preserve">
          <source>The interface name of QAudioEncoderSettingsControl is &lt;code&gt;org.qt-project.qt.audioencodersettingscontrol/5.0&lt;/code&gt; as defined in &lt;a href=&quot;qaudioencodersettingscontrol#QAudioEncoderSettingsControl_iid&quot;&gt;QAudioEncoderSettingsControl_iid&lt;/a&gt;.</source>
          <target state="translated">QAudioEncoderSettingsControl의 인터페이스 이름이다 &lt;code&gt;org.qt-project.qt.audioencodersettingscontrol/5.0&lt;/code&gt; 에 정의 &lt;a href=&quot;qaudioencodersettingscontrol#QAudioEncoderSettingsControl_iid&quot;&gt;QAudioEncoderSettingsControl_iid&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a8356c473021b7eddd3cadbd6f76491b6fb4af29" translate="yes" xml:space="preserve">
          <source>The interface name of QAudioInputSelectorControl is &lt;code&gt;org.qt-project.qt.audioinputselectorcontrol/5.0&lt;/code&gt; as defined in &lt;a href=&quot;qaudioinputselectorcontrol#QAudioInputSelectorControl_iid&quot;&gt;QAudioInputSelectorControl_iid&lt;/a&gt;.</source>
          <target state="translated">QAudioInputSelectorControl의 인터페이스 이름이다 &lt;code&gt;org.qt-project.qt.audioinputselectorcontrol/5.0&lt;/code&gt; 에 정의 &lt;a href=&quot;qaudioinputselectorcontrol#QAudioInputSelectorControl_iid&quot;&gt;QAudioInputSelectorControl_iid&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3798c9c588e71c6183576a532ac4f480c0832dec" translate="yes" xml:space="preserve">
          <source>The interface name of QAudioOutputSelectorControl is &lt;code&gt;org.qt-project.qt.audiooutputselectorcontrol/5.0&lt;/code&gt; as defined in &lt;a href=&quot;qaudiooutputselectorcontrol#QAudioOutputSelectorControl_iid&quot;&gt;QAudioOutputSelectorControl_iid&lt;/a&gt;.</source>
          <target state="translated">QAudioOutputSelectorControl의 인터페이스 이름이다 &lt;code&gt;org.qt-project.qt.audiooutputselectorcontrol/5.0&lt;/code&gt; 에 정의 &lt;a href=&quot;qaudiooutputselectorcontrol#QAudioOutputSelectorControl_iid&quot;&gt;QAudioOutputSelectorControl_iid&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4af28f53685e7e218ffb841cfb7d17b3086f889d" translate="yes" xml:space="preserve">
          <source>The interface name of QAudioRoleControl is &lt;code&gt;org.qt-project.qt.audiorolecontrol/5.6&lt;/code&gt; as defined in &lt;a href=&quot;qaudiorolecontrol#QAudioRoleControl_iid&quot;&gt;QAudioRoleControl_iid&lt;/a&gt;.</source>
          <target state="translated">QAudioRoleControl의 인터페이스 이름은 &lt;code&gt;org.qt-project.qt.audiorolecontrol/5.6&lt;/code&gt; 에 정의 된 &lt;a href=&quot;qaudiorolecontrol#QAudioRoleControl_iid&quot;&gt;QAudioRoleControl_iid&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a3fcd1a7f6c818eb403c1224d36e173cdd7e8d17" translate="yes" xml:space="preserve">
          <source>The interface name of QCameraCaptureBufferFormatControl is &lt;code&gt;org.qt-project.qt.cameracapturebufferformatcontrol/5.0&lt;/code&gt; as defined in &lt;a href=&quot;qcameracapturebufferformatcontrol#QCameraCaptureBufferFormatControl_iid&quot;&gt;QCameraCaptureBufferFormatControl_iid&lt;/a&gt;.</source>
          <target state="translated">QCameraCaptureBufferFormatControl의 인터페이스 이름이다 &lt;code&gt;org.qt-project.qt.cameracapturebufferformatcontrol/5.0&lt;/code&gt; 에 정의 &lt;a href=&quot;qcameracapturebufferformatcontrol#QCameraCaptureBufferFormatControl_iid&quot;&gt;QCameraCaptureBufferFormatControl_iid&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6972099409014d36a5c14d31210ee93acc8acbee" translate="yes" xml:space="preserve">
          <source>The interface name of QCameraCaptureDestinationControl is &lt;code&gt;org.qt-project.qt.cameracapturedestinationcontrol/5.0&lt;/code&gt; as defined in &lt;a href=&quot;qcameracapturedestinationcontrol#QCameraCaptureDestinationControl_iid&quot;&gt;QCameraCaptureDestinationControl_iid&lt;/a&gt;.</source>
          <target state="translated">QCameraCaptureDestinationControl의 인터페이스 이름이다 &lt;code&gt;org.qt-project.qt.cameracapturedestinationcontrol/5.0&lt;/code&gt; 에 정의 &lt;a href=&quot;qcameracapturedestinationcontrol#QCameraCaptureDestinationControl_iid&quot;&gt;QCameraCaptureDestinationControl_iid&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ac07a9b99c424f7b5b00fab886e51b4fd6a1fa8a" translate="yes" xml:space="preserve">
          <source>The interface name of QCameraControl is &lt;code&gt;org.qt-project.qt.cameracontrol/5.0&lt;/code&gt; as defined in &lt;a href=&quot;qcameracontrol#QCameraControl_iid&quot;&gt;QCameraControl_iid&lt;/a&gt;.</source>
          <target state="translated">QCameraControl의 인터페이스 이름이다 &lt;code&gt;org.qt-project.qt.cameracontrol/5.0&lt;/code&gt; 에 정의 &lt;a href=&quot;qcameracontrol#QCameraControl_iid&quot;&gt;QCameraControl_iid&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ddca6f1ae438b46c59de1b94b785b04c6ac1ba7f" translate="yes" xml:space="preserve">
          <source>The interface name of QCameraExposureControl is &lt;code&gt;org.qt-project.qt.cameraexposurecontrol/5.0&lt;/code&gt; as defined in &lt;a href=&quot;qcameraexposurecontrol#QCameraExposureControl_iid&quot;&gt;QCameraExposureControl_iid&lt;/a&gt;.</source>
          <target state="translated">QCameraExposureControl의 인터페이스 이름이다 &lt;code&gt;org.qt-project.qt.cameraexposurecontrol/5.0&lt;/code&gt; 에 정의 &lt;a href=&quot;qcameraexposurecontrol#QCameraExposureControl_iid&quot;&gt;QCameraExposureControl_iid&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a69c94c47a9dd7fbd18da81aed1c37aa85187f51" translate="yes" xml:space="preserve">
          <source>The interface name of QCameraFeedbackControl is &lt;code&gt;org.qt-project.qt.camerafeedbackcontrol/5.0&lt;/code&gt; as defined in &lt;a href=&quot;qcamerafeedbackcontrol#QCameraFeedbackControl_iid&quot;&gt;QCameraFeedbackControl_iid&lt;/a&gt;.</source>
          <target state="translated">QCameraFeedbackControl의 인터페이스 이름이다 &lt;code&gt;org.qt-project.qt.camerafeedbackcontrol/5.0&lt;/code&gt; 에 정의 &lt;a href=&quot;qcamerafeedbackcontrol#QCameraFeedbackControl_iid&quot;&gt;QCameraFeedbackControl_iid&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bd98e7f3776a65528acd84a9152f21203ebe750a" translate="yes" xml:space="preserve">
          <source>The interface name of QCameraFlashControl is &lt;code&gt;org.qt-project.qt.cameraflashcontrol/5.0&lt;/code&gt; as defined in &lt;a href=&quot;qcameraflashcontrol#QCameraFlashControl_iid&quot;&gt;QCameraFlashControl_iid&lt;/a&gt;.</source>
          <target state="translated">QCameraFlashControl의 인터페이스 이름이다 &lt;code&gt;org.qt-project.qt.cameraflashcontrol/5.0&lt;/code&gt; 에 정의 &lt;a href=&quot;qcameraflashcontrol#QCameraFlashControl_iid&quot;&gt;QCameraFlashControl_iid&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e86ce1b8c88ec1b902d7d0e7bab6a286d720cd48" translate="yes" xml:space="preserve">
          <source>The interface name of QCameraFocusControl is &lt;code&gt;org.qt-project.qt.camerafocuscontrol/5.0&lt;/code&gt; as defined in &lt;a href=&quot;qcamerafocuscontrol#QCameraFocusControl_iid&quot;&gt;QCameraFocusControl_iid&lt;/a&gt;.</source>
          <target state="translated">QCameraFocusControl의 인터페이스 이름이다 &lt;code&gt;org.qt-project.qt.camerafocuscontrol/5.0&lt;/code&gt; 에 정의 &lt;a href=&quot;qcamerafocuscontrol#QCameraFocusControl_iid&quot;&gt;QCameraFocusControl_iid&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5a81a3202fc886efc8cebd6a1ff7de9ff35826a1" translate="yes" xml:space="preserve">
          <source>The interface name of QCameraImageCaptureControl is &lt;code&gt;org.qt-project.qt.cameraimagecapturecontrol/5.0&lt;/code&gt; as defined in &lt;a href=&quot;qcameraimagecapturecontrol#QCameraImageCaptureControl_iid&quot;&gt;QCameraImageCaptureControl_iid&lt;/a&gt;.</source>
          <target state="translated">QCameraImageCaptureControl의 인터페이스 이름이다 &lt;code&gt;org.qt-project.qt.cameraimagecapturecontrol/5.0&lt;/code&gt; 에 정의 &lt;a href=&quot;qcameraimagecapturecontrol#QCameraImageCaptureControl_iid&quot;&gt;QCameraImageCaptureControl_iid&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="25d2546ea55faeb550b1a7ee964ed782aa739a37" translate="yes" xml:space="preserve">
          <source>The interface name of QCameraImageProcessingControl is &lt;code&gt;org.qt-project.qt.cameraimageprocessingcontrol/5.0&lt;/code&gt; as defined in &lt;a href=&quot;qcameraimageprocessingcontrol#QCameraImageProcessingControl_iid&quot;&gt;QCameraImageProcessingControl_iid&lt;/a&gt;.</source>
          <target state="translated">QCameraImageProcessingControl의 인터페이스 이름이다 &lt;code&gt;org.qt-project.qt.cameraimageprocessingcontrol/5.0&lt;/code&gt; 에 정의 &lt;a href=&quot;qcameraimageprocessingcontrol#QCameraImageProcessingControl_iid&quot;&gt;QCameraImageProcessingControl_iid&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ed80de6a2bce51eccadf73140f938ab7f34a8829" translate="yes" xml:space="preserve">
          <source>The interface name of QCameraInfoControl is &lt;code&gt;org.qt-project.qt.camerainfocontrol/5.3&lt;/code&gt; as defined in &lt;a href=&quot;qvideodeviceselectorcontrol#QCameraInfoControl_iid&quot;&gt;QCameraInfoControl_iid&lt;/a&gt;.</source>
          <target state="translated">QCameraInfoControl의 인터페이스 이름은 &lt;code&gt;org.qt-project.qt.camerainfocontrol/5.3&lt;/code&gt; 에 정의 된 &lt;a href=&quot;qvideodeviceselectorcontrol#QCameraInfoControl_iid&quot;&gt;QCameraInfoControl_iid&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5ca32de2c7b60e267a54c42adce9b07f57c293d9" translate="yes" xml:space="preserve">
          <source>The interface name of QCameraLocksControl is &lt;code&gt;org.qt-project.qt.cameralockscontrol/5.0&lt;/code&gt; as defined in &lt;a href=&quot;qcameralockscontrol#QCameraLocksControl_iid&quot;&gt;QCameraLocksControl_iid&lt;/a&gt;.</source>
          <target state="translated">QCameraLocksControl의 인터페이스 이름이다 &lt;code&gt;org.qt-project.qt.cameralockscontrol/5.0&lt;/code&gt; 에 정의 &lt;a href=&quot;qcameralockscontrol#QCameraLocksControl_iid&quot;&gt;QCameraLocksControl_iid&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b3ebc3b089dfd62df3ec08444079fda5c183e517" translate="yes" xml:space="preserve">
          <source>The interface name of QCameraViewfinderSettingsControl is &lt;code&gt;org.qt-project.qt.cameraviewfindersettingscontrol/5.0&lt;/code&gt; as defined in &lt;a href=&quot;qcameraviewfindersettingscontrol#QCameraViewfinderSettingsControl_iid&quot;&gt;QCameraViewfinderSettingsControl_iid&lt;/a&gt;.</source>
          <target state="translated">QCameraViewfinderSettingsControl의 인터페이스 이름이다 &lt;code&gt;org.qt-project.qt.cameraviewfindersettingscontrol/5.0&lt;/code&gt; 에 정의 &lt;a href=&quot;qcameraviewfindersettingscontrol#QCameraViewfinderSettingsControl_iid&quot;&gt;QCameraViewfinderSettingsControl_iid&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="68c9ff8ab3f48b3158aac033c0e1eeaf6020be49" translate="yes" xml:space="preserve">
          <source>The interface name of QCameraViewfinderSettingsControl2 is &lt;code&gt;org.qt-project.qt.cameraviewfindersettingscontrol2/5.5&lt;/code&gt; as defined in &lt;a href=&quot;qcameraviewfindersettingscontrol2#QCameraViewfinderSettingsControl2_iid&quot;&gt;QCameraViewfinderSettingsControl2_iid&lt;/a&gt;.</source>
          <target state="translated">QCameraViewfinderSettingsControl2의 인터페이스 이름은 &lt;code&gt;org.qt-project.qt.cameraviewfindersettingscontrol2/5.5&lt;/code&gt; 에 정의 된 &lt;a href=&quot;qcameraviewfindersettingscontrol2#QCameraViewfinderSettingsControl2_iid&quot;&gt;QCameraViewfinderSettingsControl2_iid&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0b07fb1a262a86f56458301c0c1ddef83be4f62c" translate="yes" xml:space="preserve">
          <source>The interface name of QCameraZoomControl is &lt;code&gt;org.qt-project.qt.camerazoomcontrol/5.0&lt;/code&gt; as defined in &lt;a href=&quot;qcamerazoomcontrol#QCameraZoomControl_iid&quot;&gt;QCameraZoomControl_iid&lt;/a&gt;.</source>
          <target state="translated">QCameraZoomControl의 인터페이스 이름이다 &lt;code&gt;org.qt-project.qt.camerazoomcontrol/5.0&lt;/code&gt; 에 정의 &lt;a href=&quot;qcamerazoomcontrol#QCameraZoomControl_iid&quot;&gt;QCameraZoomControl_iid&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="989855295cd5858c98d7ac27e3b2c075ea1f9b90" translate="yes" xml:space="preserve">
          <source>The interface name of QCustomAudioRoleControl is &lt;code&gt;org.qt-project.qt.customaudiorolecontrol/5.11&lt;/code&gt; as defined in &lt;a href=&quot;qcustomaudiorolecontrol#QCustomAudioRoleControl_iid&quot;&gt;QCustomAudioRoleControl_iid&lt;/a&gt;.</source>
          <target state="translated">QCustomAudioRoleControl의 인터페이스 이름은 &lt;code&gt;org.qt-project.qt.customaudiorolecontrol/5.11&lt;/code&gt; 에 정의 된 &lt;a href=&quot;qcustomaudiorolecontrol#QCustomAudioRoleControl_iid&quot;&gt;QCustomAudioRoleControl_iid&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="03130db716272d81f9b241a5cc8d30aa96334602" translate="yes" xml:space="preserve">
          <source>The interface name of QImageEncoderControl is &lt;code&gt;org.qt-project.qt.imageencodercontrol/5.0&lt;/code&gt; as defined in &lt;a href=&quot;qimageencodercontrol#QImageEncoderControl_iid&quot;&gt;QImageEncoderControl_iid&lt;/a&gt;.</source>
          <target state="translated">QImageEncoderControl의 인터페이스 이름이다 &lt;code&gt;org.qt-project.qt.imageencodercontrol/5.0&lt;/code&gt; 에 정의 &lt;a href=&quot;qimageencodercontrol#QImageEncoderControl_iid&quot;&gt;QImageEncoderControl_iid&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="08cd9c4ea478e74cb2531871bfcc620436b8c579" translate="yes" xml:space="preserve">
          <source>The interface name of QMediaAudioProbeControl is &lt;code&gt;org.qt-project.qt.mediaaudioprobecontrol/5.0&lt;/code&gt; as defined in &lt;a href=&quot;qmediaaudioprobecontrol#QMediaAudioProbeControl_iid&quot;&gt;QMediaAudioProbeControl_iid&lt;/a&gt;.</source>
          <target state="translated">QMediaAudioProbeControl의 인터페이스 이름이다 &lt;code&gt;org.qt-project.qt.mediaaudioprobecontrol/5.0&lt;/code&gt; 에 정의 &lt;a href=&quot;qmediaaudioprobecontrol#QMediaAudioProbeControl_iid&quot;&gt;QMediaAudioProbeControl_iid&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7f20685d6651fe51e6d846e8539b0ea27d467efd" translate="yes" xml:space="preserve">
          <source>The interface name of QMediaAvailabilityControl is &lt;code&gt;org.qt-project.qt.mediaavailabilitycontrol/5.0&lt;/code&gt; as defined in &lt;a href=&quot;qmediaavailabilitycontrol#QMediaAvailabilityControl_iid&quot;&gt;QMediaAvailabilityControl_iid&lt;/a&gt;.</source>
          <target state="translated">QMediaAvailabilityControl의 인터페이스 이름이다 &lt;code&gt;org.qt-project.qt.mediaavailabilitycontrol/5.0&lt;/code&gt; 에 정의 &lt;a href=&quot;qmediaavailabilitycontrol#QMediaAvailabilityControl_iid&quot;&gt;QMediaAvailabilityControl_iid&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e145b52d8c41c2b6441252d255018093e5fb9b62" translate="yes" xml:space="preserve">
          <source>The interface name of QMediaContainerControl is &lt;code&gt;org.qt-project.qt.mediacontainercontrol/5.0&lt;/code&gt; as defined in &lt;a href=&quot;qmediacontainercontrol#QMediaContainerControl_iid&quot;&gt;QMediaContainerControl_iid&lt;/a&gt;.</source>
          <target state="translated">QMediaContainerControl의 인터페이스 이름이다 &lt;code&gt;org.qt-project.qt.mediacontainercontrol/5.0&lt;/code&gt; 에 정의 &lt;a href=&quot;qmediacontainercontrol#QMediaContainerControl_iid&quot;&gt;QMediaContainerControl_iid&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2f983834252b8699626005f71236e8afa5d16651" translate="yes" xml:space="preserve">
          <source>The interface name of QMediaGaplessPlaybackControl is &lt;code&gt;org.qt-project.qt.mediagaplessplaybackcontrol/5.0&lt;/code&gt; as defined in &lt;a href=&quot;qmediagaplessplaybackcontrol#QMediaGaplessPlaybackControl_iid&quot;&gt;QMediaGaplessPlaybackControl_iid&lt;/a&gt;.</source>
          <target state="translated">QMediaGaplessPlaybackControl의 인터페이스 이름이다 &lt;code&gt;org.qt-project.qt.mediagaplessplaybackcontrol/5.0&lt;/code&gt; 에 정의 &lt;a href=&quot;qmediagaplessplaybackcontrol#QMediaGaplessPlaybackControl_iid&quot;&gt;QMediaGaplessPlaybackControl_iid&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6ce70e879acf7d5409e9961fb10040af2d148f36" translate="yes" xml:space="preserve">
          <source>The interface name of QMediaPlayerControl is &lt;code&gt;org.qt-project.qt.mediaplayercontrol/5.0&lt;/code&gt; as defined in &lt;a href=&quot;qmediaplayercontrol#QMediaPlayerControl_iid&quot;&gt;QMediaPlayerControl_iid&lt;/a&gt;.</source>
          <target state="translated">QMediaPlayerControl의 인터페이스 이름이다 &lt;code&gt;org.qt-project.qt.mediaplayercontrol/5.0&lt;/code&gt; 에 정의 &lt;a href=&quot;qmediaplayercontrol#QMediaPlayerControl_iid&quot;&gt;QMediaPlayerControl_iid&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e0363d5e56c6c587f4f68a42363d11336a0af448" translate="yes" xml:space="preserve">
          <source>The interface name of QMediaRecorderControl is &lt;code&gt;org.qt-project.qt.mediarecordercontrol/5.0&lt;/code&gt; as defined in &lt;a href=&quot;qmediarecordercontrol#QMediaRecorderControl_iid&quot;&gt;QMediaRecorderControl_iid&lt;/a&gt;.</source>
          <target state="translated">QMediaRecorderControl의 인터페이스 이름이다 &lt;code&gt;org.qt-project.qt.mediarecordercontrol/5.0&lt;/code&gt; 에 정의 &lt;a href=&quot;qmediarecordercontrol#QMediaRecorderControl_iid&quot;&gt;QMediaRecorderControl_iid&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4410b06926410c1e1363052d73c4784f5725af47" translate="yes" xml:space="preserve">
          <source>The interface name of QMediaStreamsControl is &lt;code&gt;org.qt-project.qt.mediastreamscontrol/5.0&lt;/code&gt; as defined in &lt;a href=&quot;qmediastreamscontrol#QMediaStreamsControl_iid&quot;&gt;QMediaStreamsControl_iid&lt;/a&gt;.</source>
          <target state="translated">QMediaStreamsControl의 인터페이스 이름이다 &lt;code&gt;org.qt-project.qt.mediastreamscontrol/5.0&lt;/code&gt; 에 정의 &lt;a href=&quot;qmediastreamscontrol#QMediaStreamsControl_iid&quot;&gt;QMediaStreamsControl_iid&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0fc2fb3c2c1dc4cce7d6d38ce4497c30e1b468d9" translate="yes" xml:space="preserve">
          <source>The interface name of QMediaVideoProbeControl is &lt;code&gt;org.qt-project.qt.mediavideoprobecontrol/5.0&lt;/code&gt; as defined in &lt;a href=&quot;qmediavideoprobecontrol#QMediaVideoProbeControl_iid&quot;&gt;QMediaVideoProbeControl_iid&lt;/a&gt;.</source>
          <target state="translated">QMediaVideoProbeControl의 인터페이스 이름이다 &lt;code&gt;org.qt-project.qt.mediavideoprobecontrol/5.0&lt;/code&gt; 에 정의 &lt;a href=&quot;qmediavideoprobecontrol#QMediaVideoProbeControl_iid&quot;&gt;QMediaVideoProbeControl_iid&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c975f4a18e0c1281ce46d04ea5b86f77111c95ff" translate="yes" xml:space="preserve">
          <source>The interface name of QMetaDataReaderControl is &lt;code&gt;org.qt-project.qt.metadatareadercontrol/5.0&lt;/code&gt; as defined in &lt;a href=&quot;qmetadatareadercontrol#QMetaDataReaderControl_iid&quot;&gt;QMetaDataReaderControl_iid&lt;/a&gt;.</source>
          <target state="translated">QMetaDataReaderControl의 인터페이스 이름이다 &lt;code&gt;org.qt-project.qt.metadatareadercontrol/5.0&lt;/code&gt; 에 정의 &lt;a href=&quot;qmetadatareadercontrol#QMetaDataReaderControl_iid&quot;&gt;QMetaDataReaderControl_iid&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="670186f238d9ac4bc073badae522f1b199bb0527" translate="yes" xml:space="preserve">
          <source>The interface name of QMetaDataWriterControl is &lt;code&gt;org.qt-project.qt.metadatawritercontrol/5.0&lt;/code&gt; as defined in &lt;a href=&quot;qmetadatawritercontrol#QMetaDataWriterControl_iid&quot;&gt;QMetaDataWriterControl_iid&lt;/a&gt;.</source>
          <target state="translated">QMetaDataWriterControl의 인터페이스 이름이다 &lt;code&gt;org.qt-project.qt.metadatawritercontrol/5.0&lt;/code&gt; 에 정의 &lt;a href=&quot;qmetadatawritercontrol#QMetaDataWriterControl_iid&quot;&gt;QMetaDataWriterControl_iid&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a38cec9a572103c873622ea56d7d0723cf5522e6" translate="yes" xml:space="preserve">
          <source>The interface name of QRadioDataControl is &lt;code&gt;org.qt-project.qt.radiodatacontrol/5.0&lt;/code&gt; as defined in &lt;a href=&quot;qradiodatacontrol#QRadioDataControl_iid&quot;&gt;QRadioDataControl_iid&lt;/a&gt;.</source>
          <target state="translated">QRadioDataControl의 인터페이스 이름이다 &lt;code&gt;org.qt-project.qt.radiodatacontrol/5.0&lt;/code&gt; 에 정의 &lt;a href=&quot;qradiodatacontrol#QRadioDataControl_iid&quot;&gt;QRadioDataControl_iid&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9313387f245aff8a8141edb4b27e0e0b259186f7" translate="yes" xml:space="preserve">
          <source>The interface name of QRadioTunerControl is &lt;code&gt;org.qt-project.qt.radiotunercontrol/5.0&lt;/code&gt; as defined in &lt;a href=&quot;qradiotunercontrol#QRadioTunerControl_iid&quot;&gt;QRadioTunerControl_iid&lt;/a&gt;.</source>
          <target state="translated">QRadioTunerControl의 인터페이스 이름이다 &lt;code&gt;org.qt-project.qt.radiotunercontrol/5.0&lt;/code&gt; 에 정의 &lt;a href=&quot;qradiotunercontrol#QRadioTunerControl_iid&quot;&gt;QRadioTunerControl_iid&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="392d700e2b542a06521919df9d8ddb5ef2d8f9ff" translate="yes" xml:space="preserve">
          <source>The interface name of QVideoDeviceSelectorControl is &lt;code&gt;org.qt-project.qt.videodeviceselectorcontrol/5.0&lt;/code&gt; as defined in &lt;a href=&quot;qvideodeviceselectorcontrol#QVideoDeviceSelectorControl_iid&quot;&gt;QVideoDeviceSelectorControl_iid&lt;/a&gt;.</source>
          <target state="translated">QVideoDeviceSelectorControl의 인터페이스 이름이다 &lt;code&gt;org.qt-project.qt.videodeviceselectorcontrol/5.0&lt;/code&gt; 에 정의 &lt;a href=&quot;qvideodeviceselectorcontrol#QVideoDeviceSelectorControl_iid&quot;&gt;QVideoDeviceSelectorControl_iid&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ee058ae7f3da7af1cca42add463e748135edaa24" translate="yes" xml:space="preserve">
          <source>The interface name of QVideoEncoderSettingsControl is &lt;code&gt;org.qt-project.qt.videoencodersettingscontrol/5.0&lt;/code&gt; as defined in &lt;a href=&quot;qvideoencodersettingscontrol#QVideoEncoderSettingsControl_iid&quot;&gt;QVideoEncoderSettingsControl_iid&lt;/a&gt;.</source>
          <target state="translated">QVideoEncoderSettingsControl의 인터페이스 이름이다 &lt;code&gt;org.qt-project.qt.videoencodersettingscontrol/5.0&lt;/code&gt; 에 정의 &lt;a href=&quot;qvideoencodersettingscontrol#QVideoEncoderSettingsControl_iid&quot;&gt;QVideoEncoderSettingsControl_iid&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="94c1811ae1f4d41199fe81db6f57e7663407072b" translate="yes" xml:space="preserve">
          <source>The interface name of QVideoRendererControl is &lt;code&gt;org.qt-project.qt.videorenderercontrol/5.0&lt;/code&gt; as defined in &lt;a href=&quot;qvideorenderercontrol#QVideoRendererControl_iid&quot;&gt;QVideoRendererControl_iid&lt;/a&gt;.</source>
          <target state="translated">QVideoRendererControl의 인터페이스 이름이다 &lt;code&gt;org.qt-project.qt.videorenderercontrol/5.0&lt;/code&gt; 에 정의 &lt;a href=&quot;qvideorenderercontrol#QVideoRendererControl_iid&quot;&gt;QVideoRendererControl_iid&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="aa5742856bbdb78493191586763e22a87752311a" translate="yes" xml:space="preserve">
          <source>The interface name of QVideoWidgetControl is &lt;code&gt;org.qt-project.qt.videowidgetcontrol/5.0&lt;/code&gt; as defined in &lt;a href=&quot;qvideowidgetcontrol#QVideoWidgetControl_iid&quot;&gt;QVideoWidgetControl_iid&lt;/a&gt;.</source>
          <target state="translated">QVideoWidgetControl의 인터페이스 이름이다 &lt;code&gt;org.qt-project.qt.videowidgetcontrol/5.0&lt;/code&gt; 에 정의 &lt;a href=&quot;qvideowidgetcontrol#QVideoWidgetControl_iid&quot;&gt;QVideoWidgetControl_iid&lt;/a&gt; .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
