<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="d">
    <body>
      <group id="d">
        <trans-unit id="b0fa593fc6719274022ebaa7f2cbe343124a2468" translate="yes" xml:space="preserve">
          <source>T &lt;strong id=&quot;emplace&quot;&gt;emplace&lt;/strong&gt;(T, Args...)(T chunk, auto ref Args args)</source>
          <target state="translated">T &lt;strong id=&quot;emplace&quot;&gt;emplace&lt;/strong&gt; (T, Args ...) (T 청크, 자동 참조 Args args)</target>
        </trans-unit>
        <trans-unit id="9c8b46882c8348d7824a8bd6910cdd4a5c4fec9a" translate="yes" xml:space="preserve">
          <source>T &lt;strong id=&quot;emplace&quot;&gt;emplace&lt;/strong&gt;(T, Args...)(void[] chunk, auto ref Args args)</source>
          <target state="translated">T &lt;strong id=&quot;emplace&quot;&gt;emplace&lt;/strong&gt; (T, Args ...) (void [] 청크, 자동 참조 Args args)</target>
        </trans-unit>
        <trans-unit id="b740d91fc72165a9cb3536d7aa64e6ab1c4bb313" translate="yes" xml:space="preserve">
          <source>T &lt;strong id=&quot;enforce&quot;&gt;enforce&lt;/strong&gt;(T)(T value, lazy Throwable ex);</source>
          <target state="translated">T &lt;strong id=&quot;enforce&quot;&gt;집행&lt;/strong&gt; (T) (T 값, 게으른 Throwable ex);</target>
        </trans-unit>
        <trans-unit id="fbdd2c4062981837d7726866a941f2f115ba32d2" translate="yes" xml:space="preserve">
          <source>T &lt;strong id=&quot;enforce&quot;&gt;enforce&lt;/strong&gt;(T)(T value, lazy const(char)[] msg = null, string file = __FILE__, size_t line = __LINE__)</source>
          <target state="translated">T &lt;strong id=&quot;enforce&quot;&gt;강제&lt;/strong&gt; (T) (T 값, 게으른 const (char) [] msg = null, 문자열 파일 = __FILE__, size_t 줄 = __LINE__)</target>
        </trans-unit>
        <trans-unit id="f8ecfa820dbcb85701bb8f100c712fc72173f821" translate="yes" xml:space="preserve">
          <source>T &lt;strong id=&quot;enforce&quot;&gt;enforce&lt;/strong&gt;(T, Dg, string file = __FILE__, size_t line = __LINE__)(T value, scope Dg dg)</source>
          <target state="translated">T &lt;strong id=&quot;enforce&quot;&gt;시행&lt;/strong&gt; (T, Dg, 문자열 파일 = __FILE__, size_t line = __LINE __) (T 값, 범위 Dg dg)</target>
        </trans-unit>
        <trans-unit id="060ef2bb9ce8ac5eed673dd3c0a50f3ce740bb82" translate="yes" xml:space="preserve">
          <source>T &lt;strong id=&quot;enforceEx&quot;&gt;enforceEx&lt;/strong&gt;(T)(T value, lazy string msg = &quot;&quot;, string file = __FILE__, size_t line = __LINE__);</source>
          <target state="translated">T &lt;strong id=&quot;enforceEx&quot;&gt;enforceEx&lt;/strong&gt; (T) (T 값, 지연 문자열 msg = &quot;&quot;, 문자열 파일 = __FILE__, size_t line = __LINE__);</target>
        </trans-unit>
        <trans-unit id="beb7cd7d343dc972eb43b39e1e960fd8fdb40d95" translate="yes" xml:space="preserve">
          <source>T &lt;strong id=&quot;findRoot&quot;&gt;findRoot&lt;/strong&gt;(T, DF)(scope DF f, in T a, in T b);</source>
          <target state="translated">T &lt;strong id=&quot;findRoot&quot;&gt;findRoot&lt;/strong&gt; (T, DF) (범위 DF f, T a, T b);</target>
        </trans-unit>
        <trans-unit id="e86327ee5110d3521411c00ef8b7d9a49b0a9988" translate="yes" xml:space="preserve">
          <source>T &lt;strong id=&quot;findRoot&quot;&gt;findRoot&lt;/strong&gt;(T, DF, DT)(scope DF f, in T a, in T b, scope DT tolerance)</source>
          <target state="translated">T &lt;strong id=&quot;findRoot&quot;&gt;findRoot&lt;/strong&gt; (T, DF, DT) (범위 DF f, T a, T b, 범위 DT 공차)</target>
        </trans-unit>
        <trans-unit id="bedb827f66e2b4807f5499cea53661000993d6e1" translate="yes" xml:space="preserve">
          <source>T &lt;strong id=&quot;findRoot&quot;&gt;findRoot&lt;/strong&gt;(T, R)(scope R delegate(T) f, in T a, in T b, scope bool delegate(T lo, T hi) tolerance = (T a, T b) =&amp;gt; false);</source>
          <target state="translated">T &lt;strong id=&quot;findRoot&quot;&gt;findRoot&lt;/strong&gt; (T, R) (범위 R 위임 범위 (T lo, T hi) 공차 = (T a, T b) =&amp;gt; 거짓);</target>
        </trans-unit>
        <trans-unit id="44c7175aba68c1013b437a78e0027a7ae8caf201" translate="yes" xml:space="preserve">
          <source>T &lt;strong id=&quot;gcd&quot;&gt;gcd&lt;/strong&gt;(T)(T a, T b)</source>
          <target state="translated">T &lt;strong id=&quot;gcd&quot;&gt;gcd&lt;/strong&gt; (T) (T a, T b)</target>
        </trans-unit>
        <trans-unit id="979921cb227d5ccf4c5ed98fedcd1901e07ed4e0" translate="yes" xml:space="preserve">
          <source>T &lt;strong id=&quot;im&quot;&gt;im&lt;/strong&gt;;</source>
          <target state="translated">T의 &lt;strong id=&quot;im&quot;&gt;메신저&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="9cad5c83f25c4882e3a677d659d2604d59606327" translate="yes" xml:space="preserve">
          <source>T &lt;strong id=&quot;mean&quot;&gt;mean&lt;/strong&gt;(T = double, R)(R r)</source>
          <target state="translated">T &lt;strong id=&quot;mean&quot;&gt;평균&lt;/strong&gt; (T = 이중, R) (R r)</target>
        </trans-unit>
        <trans-unit id="2299764690bdac724b123e781d35887b2fcb51d3" translate="yes" xml:space="preserve">
          <source>T &lt;strong id=&quot;move&quot;&gt;move&lt;/strong&gt;(T)(return ref scope T source);</source>
          <target state="translated">T &lt;strong id=&quot;move&quot;&gt;이동&lt;/strong&gt; (T) (반환 기준 범위 T 소스);</target>
        </trans-unit>
        <trans-unit id="741dfb5a8f583ede0e9b9c19c304b70e11195c9b" translate="yes" xml:space="preserve">
          <source>T &lt;strong id=&quot;moveAt&quot;&gt;moveAt&lt;/strong&gt;(size_t i);</source>
          <target state="translated">T &lt;strong id=&quot;moveAt&quot;&gt;moveAt&lt;/strong&gt; (size_t i);</target>
        </trans-unit>
        <trans-unit id="138561cda610d6330387ce3abbea86f8d565ec2a" translate="yes" xml:space="preserve">
          <source>T &lt;strong id=&quot;moveBack&quot;&gt;moveBack&lt;/strong&gt;();</source>
          <target state="translated">T &lt;strong id=&quot;moveBack&quot;&gt;이동&lt;/strong&gt; ();</target>
        </trans-unit>
        <trans-unit id="0d9cd7fb8bcb915127fe7213b93a4a5ed072d96f" translate="yes" xml:space="preserve">
          <source>T &lt;strong id=&quot;moveFront&quot;&gt;moveFront&lt;/strong&gt;();</source>
          <target state="translated">T &lt;strong id=&quot;moveFront&quot;&gt;moveFront&lt;/strong&gt; ();</target>
        </trans-unit>
        <trans-unit id="6b2c2339ed22213258d8d20213b2687470c91c6d" translate="yes" xml:space="preserve">
          <source>T &lt;strong id=&quot;nextPow2&quot;&gt;nextPow2&lt;/strong&gt;(T)(const T val)</source>
          <target state="translated">T &lt;strong id=&quot;nextPow2&quot;&gt;nextPow2&lt;/strong&gt; (T) (const T val)</target>
        </trans-unit>
        <trans-unit id="65a21b166486c5ec0e7f62449c3b0420a5e256d8" translate="yes" xml:space="preserve">
          <source>T &lt;strong id=&quot;onLowerBound&quot;&gt;onLowerBound&lt;/strong&gt;(Rhs, T)(Rhs rhs, T bound);</source>
          <target state="translated">T &lt;strong id=&quot;onLowerBound&quot;&gt;onLowerBound&lt;/strong&gt; (Rhs, T) (Rhs rhs, T 바운드);</target>
        </trans-unit>
        <trans-unit id="aad72a3f1def7e51423c4e74b3c42395595a9355" translate="yes" xml:space="preserve">
          <source>T &lt;strong id=&quot;onUpperBound&quot;&gt;onUpperBound&lt;/strong&gt;(Rhs, T)(Rhs rhs, T bound);</source>
          <target state="translated">T &lt;strong id=&quot;onUpperBound&quot;&gt;onUpperBound&lt;/strong&gt; (Rhs, T) (Rhs rhs, T 바운드);</target>
        </trans-unit>
        <trans-unit id="c8236d7e82d0415dbd4816e6babfc84449835c2f" translate="yes" xml:space="preserve">
          <source>T &lt;strong id=&quot;opCast&quot;&gt;opCast&lt;/strong&gt;(T : bool)();</source>
          <target state="translated">T &lt;strong id=&quot;opCast&quot;&gt;opCast&lt;/strong&gt; (T : 불) ();</target>
        </trans-unit>
        <trans-unit id="8c95ddda92bb68022ced41c4341f8084f809a8eb" translate="yes" xml:space="preserve">
          <source>T &lt;strong id=&quot;opIndex&quot;&gt;opIndex&lt;/strong&gt;(size_t i);</source>
          <target state="translated">T &lt;strong id=&quot;opIndex&quot;&gt;opIndex&lt;/strong&gt; (size_t i);</target>
        </trans-unit>
        <trans-unit id="449ae6e0fc7dc910b744a5fba7d534a6f2a1be6d" translate="yes" xml:space="preserve">
          <source>T &lt;strong id=&quot;peek&quot;&gt;peek&lt;/strong&gt;(T, Endian endianness = Endian.bigEndian, R)(R range)</source>
          <target state="translated">T &lt;strong id=&quot;peek&quot;&gt;peek&lt;/strong&gt; (T, 엔디안 엔디안 = 엔디안. 빅 엔디안, R) (R 범위)</target>
        </trans-unit>
        <trans-unit id="ab50fbfdecddf6fb1e6af5e75fd193110b7be394" translate="yes" xml:space="preserve">
          <source>T &lt;strong id=&quot;peek&quot;&gt;peek&lt;/strong&gt;(T, Endian endianness = Endian.bigEndian, R)(R range, size_t index)</source>
          <target state="translated">T &lt;strong id=&quot;peek&quot;&gt;peek&lt;/strong&gt; (T, 엔디안 엔디안 = 엔디안. 빅 엔디안, R) (R 범위, size_t 지수)</target>
        </trans-unit>
        <trans-unit id="cfd78a630212f9345951f093d04e67134480f460" translate="yes" xml:space="preserve">
          <source>T &lt;strong id=&quot;peek&quot;&gt;peek&lt;/strong&gt;(T, Endian endianness = Endian.bigEndian, R)(R range, size_t* index)</source>
          <target state="translated">T &lt;strong id=&quot;peek&quot;&gt;peek&lt;/strong&gt; (T, 엔디안 엔디안 = 엔디안. 빅 엔디안, R) (R 범위, size_t * 인덱스)</target>
        </trans-unit>
        <trans-unit id="06175f3f50cb3491bafe12cd51e9de0b7bb71b7b" translate="yes" xml:space="preserve">
          <source>T &lt;strong id=&quot;re&quot;&gt;re&lt;/strong&gt;;</source>
          <target state="translated">T는 &lt;strong id=&quot;re&quot;&gt;다시&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="a67757ebb04f606116494725c45c2d65ad59e1da" translate="yes" xml:space="preserve">
          <source>T &lt;strong id=&quot;read&quot;&gt;read&lt;/strong&gt;(T, Endian endianness = Endian.bigEndian, R)(ref R range)</source>
          <target state="translated">T &lt;strong id=&quot;read&quot;&gt;판독&lt;/strong&gt; (T, 엔디안 엔디안 = 엔디안. 빅 엔디안, R) (참조 R 범위)</target>
        </trans-unit>
        <trans-unit id="f34a45966231e81104b0676067b194e2270aad73" translate="yes" xml:space="preserve">
          <source>T &lt;strong id=&quot;rehash&quot;&gt;rehash&lt;/strong&gt;(T : Value[Key], Value, Key)(T aa);</source>
          <target state="translated">T &lt;strong id=&quot;rehash&quot;&gt;리해시&lt;/strong&gt; (T : Value [Key], Value, Key) (T aa);</target>
        </trans-unit>
        <trans-unit id="7bead4f5a3df0c8d884579f81e691b6c8415e6de" translate="yes" xml:space="preserve">
          <source>T &lt;strong id=&quot;removeAny&quot;&gt;removeAny&lt;/strong&gt;();</source>
          <target state="translated">T &lt;strong id=&quot;removeAny&quot;&gt;removeAny&lt;/strong&gt; ();</target>
        </trans-unit>
        <trans-unit id="381f551f8c2e25dd0a064562875896cf35171e6e" translate="yes" xml:space="preserve">
          <source>T &lt;strong id=&quot;toPrec&quot;&gt;toPrec&lt;/strong&gt;(T : double)(double f);</source>
          <target state="translated">T &lt;strong id=&quot;toPrec&quot;&gt;toPrec&lt;/strong&gt;(T : double)(double f);</target>
        </trans-unit>
        <trans-unit id="c9418f1f3252cbfb5a44ab6bc3a2cfe7f1e081cd" translate="yes" xml:space="preserve">
          <source>T &lt;strong id=&quot;toPrec&quot;&gt;toPrec&lt;/strong&gt;(T : double)(float f);</source>
          <target state="translated">T &lt;strong id=&quot;toPrec&quot;&gt;toPrec&lt;/strong&gt;(T : double)(float f);</target>
        </trans-unit>
        <trans-unit id="489f7cb17f1757e1f63ff69310463c6c3ecd98ce" translate="yes" xml:space="preserve">
          <source>T &lt;strong id=&quot;toPrec&quot;&gt;toPrec&lt;/strong&gt;(T : double)(real f);</source>
          <target state="translated">T &lt;strong id=&quot;toPrec&quot;&gt;toPrec&lt;/strong&gt; (T : double) (실수 f);</target>
        </trans-unit>
        <trans-unit id="93317a199c6b6814c2aca079d37c946c89d8b9b4" translate="yes" xml:space="preserve">
          <source>T &lt;strong id=&quot;toPrec&quot;&gt;toPrec&lt;/strong&gt;(T : float)(double f);</source>
          <target state="translated">T &lt;strong id=&quot;toPrec&quot;&gt;toPrec&lt;/strong&gt;(T : float)(double f);</target>
        </trans-unit>
        <trans-unit id="8e622e61a218a09734f79f4737a11ecfa4eaa64c" translate="yes" xml:space="preserve">
          <source>T &lt;strong id=&quot;toPrec&quot;&gt;toPrec&lt;/strong&gt;(T : float)(float f);</source>
          <target state="translated">T &lt;strong id=&quot;toPrec&quot;&gt;toPrec&lt;/strong&gt;(T : float)(float f);</target>
        </trans-unit>
        <trans-unit id="b375c89db1e5f4a4b8ee39390bba3a8586f1b9c4" translate="yes" xml:space="preserve">
          <source>T &lt;strong id=&quot;toPrec&quot;&gt;toPrec&lt;/strong&gt;(T : float)(real f);</source>
          <target state="translated">T &lt;strong id=&quot;toPrec&quot;&gt;toPrec&lt;/strong&gt; (T : float) (실수 f);</target>
        </trans-unit>
        <trans-unit id="9463492ed96af74f6ae02df857ba33cf74bbd019" translate="yes" xml:space="preserve">
          <source>T &lt;strong id=&quot;toPrec&quot;&gt;toPrec&lt;/strong&gt;(T : real)(double f);</source>
          <target state="translated">T &lt;strong id=&quot;toPrec&quot;&gt;toPrec&lt;/strong&gt; (T : 실수) (double f);</target>
        </trans-unit>
        <trans-unit id="9408c78d39273985eb996cdd1c3dad78f88b396a" translate="yes" xml:space="preserve">
          <source>T &lt;strong id=&quot;toPrec&quot;&gt;toPrec&lt;/strong&gt;(T : real)(float f);</source>
          <target state="translated">T &lt;strong id=&quot;toPrec&quot;&gt;toPrec&lt;/strong&gt; (T : 실수) (float f);</target>
        </trans-unit>
        <trans-unit id="edf909e0071cbf2a7c95511adbc4ee4cf9f6c478" translate="yes" xml:space="preserve">
          <source>T &lt;strong id=&quot;toPrec&quot;&gt;toPrec&lt;/strong&gt;(T : real)(real f);</source>
          <target state="translated">T &lt;strong id=&quot;toPrec&quot;&gt;toPrec&lt;/strong&gt; (T : 실수) (실수 f);</target>
        </trans-unit>
        <trans-unit id="2d60be838022f278b9224bd51072476a01487050" translate="yes" xml:space="preserve">
          <source>T &lt;strong id=&quot;truncPow2&quot;&gt;truncPow2&lt;/strong&gt;(T)(const T val)</source>
          <target state="translated">T &lt;strong id=&quot;truncPow2&quot;&gt;truncPow2&lt;/strong&gt; (T) (const T val)</target>
        </trans-unit>
        <trans-unit id="eb95f063eb8c8c2812cf42219458ee2aa577031f" translate="yes" xml:space="preserve">
          <source>T &lt;strong id=&quot;unformatValue&quot;&gt;unformatValue&lt;/strong&gt;(T, Range, Char)(ref Range input, ref scope const FormatSpec!Char spec);</source>
          <target state="translated">T &lt;strong id=&quot;unformatValue&quot;&gt;unformatValue&lt;/strong&gt; (T, Range, Char) (참조 범위 입력, 참조 범위 const FormatSpec! Char spec);</target>
        </trans-unit>
        <trans-unit id="f023d191de1d03753b07ba7065eb9151699c807d" translate="yes" xml:space="preserve">
          <source>T &lt;strong id=&quot;uniform01&quot;&gt;uniform01&lt;/strong&gt;(T = double)()</source>
          <target state="translated">T &lt;strong id=&quot;uniform01&quot;&gt;제복 01&lt;/strong&gt; (T = double) ()</target>
        </trans-unit>
        <trans-unit id="7d7e54d7d49ee87843e2d80949da00354e40a628" translate="yes" xml:space="preserve">
          <source>T &lt;strong id=&quot;uniform01&quot;&gt;uniform01&lt;/strong&gt;(T = double, UniformRNG)(ref UniformRNG rng)</source>
          <target state="translated">T &lt;strong id=&quot;uniform01&quot;&gt;uniform01&lt;/strong&gt; (T = 이중, UniformRNG) (ref UniformRNG rng)</target>
        </trans-unit>
        <trans-unit id="b68f137daa7796395115fea6ee3aeac37a675dd2" translate="yes" xml:space="preserve">
          <source>T &lt;strong id=&quot;va_arg&quot;&gt;va_arg&lt;/strong&gt;(T)(ref va_list ap);</source>
          <target state="translated">T &lt;strong id=&quot;va_arg&quot;&gt;va_arg&lt;/strong&gt;(T)(ref va_list ap);</target>
        </trans-unit>
        <trans-unit id="76e77f93676b41373d8241851cfa9772a1b976b9" translate="yes" xml:space="preserve">
          <source>T &lt;strong id=&quot;va_arg&quot;&gt;va_arg&lt;/strong&gt;(T)(va_list ap);</source>
          <target state="translated">T &lt;strong id=&quot;va_arg&quot;&gt;va_arg&lt;/strong&gt; (T) (va_list ap);</target>
        </trans-unit>
        <trans-unit id="3e6bae5b77c8ba7c9d54770f73bf7499abc63cd3" translate="yes" xml:space="preserve">
          <source>T = one of double[2], float[4], void[16], byte[16], ubyte[16], short[8], ushort[8], int[4], uint[4], long[2], ulong[2]. For 256 bit vectors, one of double[4], float[8], void[32], byte[32], ubyte[32], short[16], ushort[16], int[8], uint[8], long[4], ulong[4]</source>
          <target state="translated">T = double [2], float [4], void [16], byte [16], ubyte [16], short [8], ushort [8], int [4], uint [4], long 중 하나 [2], 울롱 [2]. 256 비트 벡터의 경우 double [4], float [8], void [32], byte [32], ubyte [32], short [16], ushort [16], int [8], uint [8 중 하나 ], 길게 [4], 우롱 [4]</target>
        </trans-unit>
        <trans-unit id="28785f4922eaddfa7af25f9b49c63d8cf063e95a" translate="yes" xml:space="preserve">
          <source>T a, b; Can we bitwise assign: a = b; ?</source>
          <target state="translated">탭; 비트 단위로 할당 할 수 있습니까 : a = b; ?</target>
        </trans-unit>
        <trans-unit id="ef60954b8a0fad62ec6fcb4559177ba5037bb25d" translate="yes" xml:space="preserve">
          <source>T t</source>
          <target state="translated">티</target>
        </trans-unit>
        <trans-unit id="b00d43df0747b95ab79c800cbcd1cf12290eecd1" translate="yes" xml:space="preserve">
          <source>T value</source>
          <target state="translated">T 값</target>
        </trans-unit>
        <trans-unit id="4dab5f38124bc3c128b0a3ac5e78293cb0689c8b" translate="yes" xml:space="preserve">
          <source>T* &lt;code&gt;here&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;here&lt;/code&gt; T *</target>
        </trans-unit>
        <trans-unit id="1952152ad742f4df5017d4c86cebb6d33b5b8cad" translate="yes" xml:space="preserve">
          <source>T* &lt;code&gt;ifThis&lt;/code&gt;</source>
          <target state="translated">T* &lt;code&gt;ifThis&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="84e07d1335aa0056f3363258602e219e5380b25a" translate="yes" xml:space="preserve">
          <source>T* &lt;code&gt;value&lt;/code&gt;</source>
          <target state="translated">T * &lt;code&gt;value&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2d52df2ddb0c9d003019726d5bcffd43cd6037c3" translate="yes" xml:space="preserve">
          <source>T* &lt;strong id=&quot;cpp_new&quot;&gt;cpp_new&lt;/strong&gt;(T, Args...)(auto ref Args args)</source>
          <target state="translated">T * &lt;strong id=&quot;cpp_new&quot;&gt;cpp_new&lt;/strong&gt; (T, Args ...) (자동 참조 Args 인수)</target>
        </trans-unit>
        <trans-unit id="81b5804598ccd8faaa4f770ccee3dae0d05ec291" translate="yes" xml:space="preserve">
          <source>T* &lt;strong id=&quot;emplace&quot;&gt;emplace&lt;/strong&gt;(T, Args...)(T* chunk, auto ref Args args)</source>
          <target state="translated">T * &lt;strong id=&quot;emplace&quot;&gt;엠 플레이스&lt;/strong&gt; (T, Args ...) (T * 청크, 자동 참조 Args args)</target>
        </trans-unit>
        <trans-unit id="7fb02d039771dad441620b1e19b5e4095b502fb5" translate="yes" xml:space="preserve">
          <source>T* &lt;strong id=&quot;emplace&quot;&gt;emplace&lt;/strong&gt;(T, Args...)(void[] chunk, auto ref Args args)</source>
          <target state="translated">T * &lt;strong id=&quot;emplace&quot;&gt;Emplace&lt;/strong&gt; (T, Args ...) (void [] 청크, 자동 참조 Args args)</target>
        </trans-unit>
        <trans-unit id="5bcff875c001699be03431a6effca033195496bb" translate="yes" xml:space="preserve">
          <source>T* here</source>
          <target state="translated">여기에 T *</target>
        </trans-unit>
        <trans-unit id="e2398779d5a199b7adb4917fab0cbe5660e3c52f" translate="yes" xml:space="preserve">
          <source>T1</source>
          <target state="translated">T1</target>
        </trans-unit>
        <trans-unit id="17be188212710bce4274756f00b864fb15194e00" translate="yes" xml:space="preserve">
          <source>T1 &lt;code&gt;a&lt;/code&gt;</source>
          <target state="translated">T1의 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ddb5372b6f6fcd29c1ef3b030b66f86fe23c4e19" translate="yes" xml:space="preserve">
          <source>T1 &lt;code&gt;expression&lt;/code&gt;</source>
          <target state="translated">T1 &lt;code&gt;expression&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="db5698102e93cebdc2311f3cc380947b12ba4b70" translate="yes" xml:space="preserve">
          <source>T1 &lt;code&gt;val&lt;/code&gt;</source>
          <target state="translated">T1 &lt;code&gt;val&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="efc0d1f1bd8f13729e48772ae5288019ca8a7b5d" translate="yes" xml:space="preserve">
          <source>T1 &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">T1 &lt;code&gt;x&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f8cf5510c304dce728fc496fb7e48b5e2deed00d" translate="yes" xml:space="preserve">
          <source>T2</source>
          <target state="translated">T2</target>
        </trans-unit>
        <trans-unit id="b49fbd4c10e416f189247e016ae225e063ba25f5" translate="yes" xml:space="preserve">
          <source>T2 &lt;code&gt;b&lt;/code&gt;</source>
          <target state="translated">T2 &lt;code&gt;b&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c28b4585582cd5f94bb5b5bc384bcac2a92c58d7" translate="yes" xml:space="preserve">
          <source>T2 &lt;code&gt;errorHandler&lt;/code&gt;</source>
          <target state="translated">T2 오류 &lt;code&gt;errorHandler&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ac82bb62e560126eff7132d176c5ba7fb50cdefe" translate="yes" xml:space="preserve">
          <source>T2 &lt;code&gt;lower&lt;/code&gt;</source>
          <target state="translated">T2 &lt;code&gt;lower&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dd5806e6a9ab9bf781aefdb9eb738844d8677ad1" translate="yes" xml:space="preserve">
          <source>T2[] &lt;code&gt;A&lt;/code&gt;</source>
          <target state="translated">T2 [] &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b2bd537bcdafb5b633e098c54aed99b622220a54" translate="yes" xml:space="preserve">
          <source>T3 &lt;code&gt;upper&lt;/code&gt;</source>
          <target state="translated">T3 &lt;code&gt;upper&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="68fe7aac5d573e9585adda75c50df34f808d3a49" translate="yes" xml:space="preserve">
          <source>TFrom[] &lt;code&gt;from&lt;/code&gt;</source>
          <target state="translated">TFrom [] &lt;code&gt;from&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bf654c3810ca0b523f0f93cae09ad8edf4349ba7" translate="yes" xml:space="preserve">
          <source>TITLE</source>
          <target state="translated">TITLE</target>
        </trans-unit>
        <trans-unit id="538db3a21f8d8c35e28587c194108040aa54e96d" translate="yes" xml:space="preserve">
          <source>TLS data is being scanned.</source>
          <target state="translated">TLS 데이터가 스캔되고 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f8cd9cabe4061b8d944e108a45880e837ca829c" translate="yes" xml:space="preserve">
          <source>TLS-SRP auth is supported</source>
          <target state="translated">TLS-SRP 인증이 지원됩니다</target>
        </trans-unit>
        <trans-unit id="b698c11e84460ed5999bfeb5cbf25b865c238f3c" translate="yes" xml:space="preserve">
          <source>TODO</source>
          <target state="translated">TODO</target>
        </trans-unit>
        <trans-unit id="a5a149798d7357cf426dbe5a0ae5edff38cd86d5" translate="yes" xml:space="preserve">
          <source>TOK* &lt;code&gt;pop&lt;/code&gt;</source>
          <target state="translated">TOK * &lt;code&gt;pop&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1b03b9d87b845c22c1a14aac3364656836c0ceb2" translate="yes" xml:space="preserve">
          <source>TOK.concatenateAssign - appending T[] to T[] TOK.concatenateElemAssign - appending T to T[] TOK.concatenateDcharAssign - appending dchar to T[]</source>
          <target state="translated">TOK.concatenateAssign-T []를 T []에 추가 TOK.concatenateElemAssign-T를 T에 추가 [TOK.concatenateDcharAssign-dchar를 T []에 추가</target>
        </trans-unit>
        <trans-unit id="2fb3ab741dd2b13f731b96e6373ede3d6363328b" translate="yes" xml:space="preserve">
          <source>TOK.equal and TOK.notEqual</source>
          <target state="translated">TOK.equal 및 TOK.notEqual</target>
        </trans-unit>
        <trans-unit id="418e909c0f89afb5070d5fa971f4c294eade012b" translate="yes" xml:space="preserve">
          <source>TOK.identity and TOK.notIdentity</source>
          <target state="translated">TOK.identity 및 TOK.notIdentity</target>
        </trans-unit>
        <trans-unit id="7aeab465f73c2aa74e5693c47f082f035e66a529" translate="yes" xml:space="preserve">
          <source>TP &lt;code&gt;begin&lt;/code&gt;</source>
          <target state="translated">TP &lt;code&gt;begin&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="299f9b451adf8acbcc193f52847a7ef370b521a4" translate="yes" xml:space="preserve">
          <source>TP &lt;code&gt;end&lt;/code&gt;</source>
          <target state="translated">TP &lt;code&gt;end&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="baca7d4b4dc925dc311b0a5bed3090cd9ce00549" translate="yes" xml:space="preserve">
          <source>TP &lt;code&gt;timePoint&lt;/code&gt;</source>
          <target state="translated">TP &lt;code&gt;timePoint&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="af84cbdd031518c415f85cb7d5839785ce28675b" translate="yes" xml:space="preserve">
          <source>TP delegate(scope const TP) &lt;code&gt;func&lt;/code&gt;</source>
          <target state="translated">TP 대리자 (scope const TP) &lt;code&gt;func&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b48f29281e3bf6f5ea68841ca180598159d28e6e" translate="yes" xml:space="preserve">
          <source>TP delegate(scope const TP) &lt;strong id=&quot;everyMonth&quot;&gt;everyMonth&lt;/strong&gt;(TP, Direction dir = Direction.fwd)(int month)</source>
          <target state="translated">TP 델리게이트 (scope const TP) &lt;strong id=&quot;everyMonth&quot;&gt;everyMonth&lt;/strong&gt; (TP, Direction dir = Direction.fwd) (int month)</target>
        </trans-unit>
        <trans-unit id="170f57e4abff5e251a00678ce76950e80c70b366" translate="yes" xml:space="preserve">
          <source>TRange &lt;code&gt;target&lt;/code&gt;</source>
          <target state="translated">탱글 &lt;code&gt;target&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="212e92f29c990679b0bef813a13d9e7b041c7f8d" translate="yes" xml:space="preserve">
          <source>TRange &lt;strong id=&quot;topNCopy&quot;&gt;topNCopy&lt;/strong&gt;(alias less = &quot;a &amp;lt; b&quot;, SRange, TRange)(SRange source, TRange target, SortOutput sorted = No.sortOutput)</source>
          <target state="translated">TRange &lt;strong id=&quot;topNCopy&quot;&gt;topNCopy&lt;/strong&gt; (별칭 = &quot;a &amp;lt;b&quot;, SRange, TRange) (SRange 소스, TRange 대상, SortOutput 정렬 = No.sortOutput)</target>
        </trans-unit>
        <trans-unit id="69e120c063bfe3e46feba63d960b83cccaade336" translate="yes" xml:space="preserve">
          <source>TYPE* &lt;strong id=&quot;getParentClosureType&quot;&gt;getParentClosureType&lt;/strong&gt;(Symbol* sthis, FuncDeclaration fd);</source>
          <target state="translated">TYPE * &lt;strong id=&quot;getParentClosureType&quot;&gt;getParentClosureType&lt;/strong&gt; (Symbol * sthis, FuncDeclaration fd);</target>
        </trans-unit>
        <trans-unit id="fd129cb8840933a8ef2b54d2afbf2de578d2074b" translate="yes" xml:space="preserve">
          <source>T[] &lt;code&gt;a&lt;/code&gt;</source>
          <target state="translated">T [] &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c099518b9c3f286f78a1e450a210be6c49d770e4" translate="yes" xml:space="preserve">
          <source>T[] &lt;code&gt;arr&lt;/code&gt;</source>
          <target state="translated">T [] &lt;code&gt;arr&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6bfe6a19007538ec5fb08ccab743a444622cb793" translate="yes" xml:space="preserve">
          <source>T[] &lt;code&gt;array&lt;/code&gt;</source>
          <target state="translated">T [] &lt;code&gt;array&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="58134bf5b6f19712d50178d7749ea496b0d8daa3" translate="yes" xml:space="preserve">
          <source>T[] &lt;code&gt;lhs&lt;/code&gt;</source>
          <target state="translated">T [] &lt;code&gt;lhs&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5628d2ab43a70ae870937d06e7d3037b58e0cf33" translate="yes" xml:space="preserve">
          <source>T[] &lt;code&gt;replacement&lt;/code&gt;</source>
          <target state="translated">T [] &lt;code&gt;replacement&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="57c829d6e8cd9f927bd53d42c0d143e633794f49" translate="yes" xml:space="preserve">
          <source>T[] &lt;code&gt;rhs&lt;/code&gt;</source>
          <target state="translated">T [] &lt;code&gt;rhs&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="501f823afa00c9166d3e9cb28fa2878a5b00a78e" translate="yes" xml:space="preserve">
          <source>T[] &lt;code&gt;s&lt;/code&gt;</source>
          <target state="translated">T [] &lt;code&gt;s&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ef449c44efbe8fddbae967e91aa6274a74626ff8" translate="yes" xml:space="preserve">
          <source>T[] &lt;code&gt;slice&lt;/code&gt;</source>
          <target state="translated">T [] &lt;code&gt;slice&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d1804b6d6b2c349e294fb0fda2e8153de174d6ad" translate="yes" xml:space="preserve">
          <source>T[] &lt;code&gt;subject&lt;/code&gt;</source>
          <target state="translated">T [] &lt;code&gt;subject&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="39d36ff03b89ba5bfa7e455dc369a059c1e6093f" translate="yes" xml:space="preserve">
          <source>T[] &lt;strong id=&quot;connect&quot;&gt;connect&lt;/strong&gt;(T = char)(const(char)[] url, HTTP conn = HTTP())</source>
          <target state="translated">T [] &lt;strong id=&quot;connect&quot;&gt;연결&lt;/strong&gt; (T = char) (const (char) [] url, HTTP conn = HTTP ())</target>
        </trans-unit>
        <trans-unit id="9e84e03dda650697e32dd99a729937cca5635e79" translate="yes" xml:space="preserve">
          <source>T[] &lt;strong id=&quot;get&quot;&gt;get&lt;/strong&gt;(Conn = AutoProtocol, T = char)(const(char)[] url, Conn conn = Conn())</source>
          <target state="translated">T [] &lt;strong id=&quot;get&quot;&gt;get&lt;/strong&gt; (Conn = 자동 프로토콜, T = char) (const (char) [] url, Conn conn = Conn ())</target>
        </trans-unit>
        <trans-unit id="23707f9ff44ba5ae268af6dda7ba0b79e6271047" translate="yes" xml:space="preserve">
          <source>T[] &lt;strong id=&quot;makeArray&quot;&gt;makeArray&lt;/strong&gt;(T)(size_t length);</source>
          <target state="translated">T [] &lt;strong id=&quot;makeArray&quot;&gt;makeArray&lt;/strong&gt; (T) (크기 &lt;strong id=&quot;makeArray&quot;&gt;_t&lt;/strong&gt; 길이);</target>
        </trans-unit>
        <trans-unit id="2286dc1437b885cda24f9e84258dbd32d8500a9e" translate="yes" xml:space="preserve">
          <source>T[] &lt;strong id=&quot;makeArray&quot;&gt;makeArray&lt;/strong&gt;(T)(size_t length, auto ref T init);</source>
          <target state="translated">T [] &lt;strong id=&quot;makeArray&quot;&gt;makeArray&lt;/strong&gt; (T) (size_t 길이, 자동 참조 T init);</target>
        </trans-unit>
        <trans-unit id="4cc2d288f77e69c585187c3762094065271e4238" translate="yes" xml:space="preserve">
          <source>T[] &lt;strong id=&quot;makeArray&quot;&gt;makeArray&lt;/strong&gt;(T, Allocator)(auto ref Allocator alloc, size_t length);</source>
          <target state="translated">T [] &lt;strong id=&quot;makeArray&quot;&gt;makeArray&lt;/strong&gt; (T, Allocator) (자동 참조 할당 자 할당, size_t 길이);</target>
        </trans-unit>
        <trans-unit id="441d57515cdfb2c4d594443d1f59adafce8fb900" translate="yes" xml:space="preserve">
          <source>T[] &lt;strong id=&quot;makeArray&quot;&gt;makeArray&lt;/strong&gt;(T, Allocator)(auto ref Allocator alloc, size_t length, T init);</source>
          <target state="translated">T [] &lt;strong id=&quot;makeArray&quot;&gt;makeArray&lt;/strong&gt; (T, Allocator) (자동 참조 할당 자 할당, size_t 길이, T init);</target>
        </trans-unit>
        <trans-unit id="7de9c6c9311491f56903128d2dd9fb5d765bb18c" translate="yes" xml:space="preserve">
          <source>T[] &lt;strong id=&quot;makeArray&quot;&gt;makeArray&lt;/strong&gt;(T, Allocator, R)(auto ref Allocator alloc, R range)</source>
          <target state="translated">T [] &lt;strong id=&quot;makeArray&quot;&gt;makeArray&lt;/strong&gt; (T, 할당 자, R) (자동 참조 할당 자 할당, R 범위)</target>
        </trans-unit>
        <trans-unit id="8ccab52df8f98925f09cc3d4aae30ea4efdf5ce9" translate="yes" xml:space="preserve">
          <source>T[] &lt;strong id=&quot;makeArray&quot;&gt;makeArray&lt;/strong&gt;(T, R)(R range)</source>
          <target state="translated">T [] &lt;strong id=&quot;makeArray&quot;&gt;makeArray&lt;/strong&gt; (T, R) (R 범위)</target>
        </trans-unit>
        <trans-unit id="5d5fd762ffac4fb324635761b8ee3701aab68e05" translate="yes" xml:space="preserve">
          <source>T[] &lt;strong id=&quot;options&quot;&gt;options&lt;/strong&gt;(T = char)(const(char)[] url, HTTP conn = HTTP())</source>
          <target state="translated">T [] &lt;strong id=&quot;options&quot;&gt;옵션&lt;/strong&gt; (T = char) (const (char) [] url, HTTP conn = HTTP ())</target>
        </trans-unit>
        <trans-unit id="f9910bacb7b28cb9aa88edb856c9847168e57f32" translate="yes" xml:space="preserve">
          <source>T[] &lt;strong id=&quot;patch&quot;&gt;patch&lt;/strong&gt;(T = char, PatchUnit)(const(char)[] url, const(PatchUnit)[] patchData, HTTP conn = HTTP())</source>
          <target state="translated">T [] &lt;strong id=&quot;patch&quot;&gt;패치&lt;/strong&gt; (T = char, PatchUnit) (const (char) [] url, const (PatchUnit) [] patchData, HTTP conn = HTTP ())</target>
        </trans-unit>
        <trans-unit id="7a3b67182bc94df15db5010b2f5ad18882dfdd00" translate="yes" xml:space="preserve">
          <source>T[] &lt;strong id=&quot;post&quot;&gt;post&lt;/strong&gt;(T = char)(const(char)[] url, string[string] postDict, HTTP conn = HTTP())</source>
          <target state="translated">T [] &lt;strong id=&quot;post&quot;&gt;post&lt;/strong&gt; (T = char) (const (char) [] url, string [string] postDict, HTTP conn = HTTP ())</target>
        </trans-unit>
        <trans-unit id="f3438696601d859117c27da9faa14db225b6ffce" translate="yes" xml:space="preserve">
          <source>T[] &lt;strong id=&quot;post&quot;&gt;post&lt;/strong&gt;(T = char, PostUnit)(const(char)[] url, const(PostUnit)[] postData, HTTP conn = HTTP())</source>
          <target state="translated">T [] &lt;strong id=&quot;post&quot;&gt;소식&lt;/strong&gt; (T = char, PostUnit) (const (char) [] url, const (PostUnit) [] postData, HTTP conn = HTTP ())</target>
        </trans-unit>
        <trans-unit id="c81de9d49f0559469a46607c70ad280808942df2" translate="yes" xml:space="preserve">
          <source>T[] &lt;strong id=&quot;put&quot;&gt;put&lt;/strong&gt;(Conn = AutoProtocol, T = char, PutUnit)(const(char)[] url, const(PutUnit)[] putData, Conn conn = Conn())</source>
          <target state="translated">T [] &lt;strong id=&quot;put&quot;&gt;put&lt;/strong&gt; (Conn = AutoProtocol, T = char, PutUnit) (const (char) [] url, const (PutUnit) [] putData, Conn conn = Conn ())</target>
        </trans-unit>
        <trans-unit id="2c18b59a8dad7a9dcf2731ea48247cd6b5e44982" translate="yes" xml:space="preserve">
          <source>T[] &lt;strong id=&quot;rawRead&quot;&gt;rawRead&lt;/strong&gt;(T)(T[] buffer);</source>
          <target state="translated">T [] &lt;strong id=&quot;rawRead&quot;&gt;rawRead&lt;/strong&gt; (T) (T [] 버퍼);</target>
        </trans-unit>
        <trans-unit id="5a4cdbd372aee8131ac98774adf20f2ab3c8f5e2" translate="yes" xml:space="preserve">
          <source>T[] &lt;strong id=&quot;replace&quot;&gt;replace&lt;/strong&gt;(T, Range)(T[] subject, size_t from, size_t to, Range stuff)</source>
          <target state="translated">T [] &lt;strong id=&quot;replace&quot;&gt;바꾸기&lt;/strong&gt; (T, Range) (T [] 주제, size_t에서 size_t에서 Range까지)</target>
        </trans-unit>
        <trans-unit id="29721e59572223e4ecc843236b113543787687cc" translate="yes" xml:space="preserve">
          <source>T[] &lt;strong id=&quot;trace&quot;&gt;trace&lt;/strong&gt;(T = char)(const(char)[] url, HTTP conn = HTTP())</source>
          <target state="translated">T [] &lt;strong id=&quot;trace&quot;&gt;추적&lt;/strong&gt; (T = char) (const (char) [] url, HTTP conn = HTTP ())</target>
        </trans-unit>
        <trans-unit id="da59e680a9e89d5cf733c59b79b9e33fc313ddfa" translate="yes" xml:space="preserve">
          <source>T[n] &lt;code&gt;a&lt;/code&gt;</source>
          <target state="translated">T [N] &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c6413140250927d3c3028e4b389cd331873b013b" translate="yes" xml:space="preserve">
          <source>T[n] &lt;strong id=&quot;staticArray&quot;&gt;staticArray&lt;/strong&gt;(T, size_t n)(auto ref T[n] a);</source>
          <target state="translated">T [n] &lt;strong id=&quot;staticArray&quot;&gt;staticArray&lt;/strong&gt; (T, size_t n) (자동 참조 T [n] a);</target>
        </trans-unit>
        <trans-unit id="1e17bd5e027f9395f0fbc66fc2872113ef975af6" translate="yes" xml:space="preserve">
          <source>Tab characters are expanded into enough spaces to bring the column number to the next multiple of tabsize. If there are multiple lines in the string, the column number of the last line is returned.</source>
          <target state="translated">탭 문자는 충분한 수의 공백으로 확장되어 열 번호를 다음 다중 탭 크기로 가져옵니다. 문자열에 여러 줄이 있으면 마지막 줄의 열 번호가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="3fd7f55fffe71e8c3dc62e1b7fa8700d0ebfd5fd" translate="yes" xml:space="preserve">
          <source>Tab columns are &lt;code&gt;tabSize&lt;/code&gt; spaces apart.</source>
          <target state="translated">탭 열은 &lt;code&gt;tabSize&lt;/code&gt; 공백으로 구분됩니다.</target>
        </trans-unit>
        <trans-unit id="4c796b0a55684b05bf0ed9597882213077eccf5e" translate="yes" xml:space="preserve">
          <source>Table Name Column Name</source>
          <target state="translated">테이블 이름 열 이름</target>
        </trans-unit>
        <trans-unit id="4e7e670649780289d0438a29a3d0ea861c4276d1" translate="yes" xml:space="preserve">
          <source>Table Name Module Name</source>
          <target state="translated">테이블 이름 모듈 이름</target>
        </trans-unit>
        <trans-unit id="5d11fac764197db4540d89ad29b394fafd9762a3" translate="yes" xml:space="preserve">
          <source>Table Name NULL</source>
          <target state="translated">테이블 이름 NULL</target>
        </trans-unit>
        <trans-unit id="a161936c303706124f7c19a878abfd8ff2c93a27" translate="yes" xml:space="preserve">
          <source>Table of Dsymbol's</source>
          <target state="translated">Dymbol의 표</target>
        </trans-unit>
        <trans-unit id="3eeff86d55fcc208134d68ad71a8213654fc3e35" translate="yes" xml:space="preserve">
          <source>Table of WHERE clause constraints</source>
          <target state="translated">WHERE 절 제약 조건 표</target>
        </trans-unit>
        <trans-unit id="193daf137ed8b89de36d47c3df5fd8f66c0e1d14" translate="yes" xml:space="preserve">
          <source>Tables</source>
          <target state="translated">Tables</target>
        </trans-unit>
        <trans-unit id="612331b5145e99bb4f26a3c75fd45f5ee2f15d43" translate="yes" xml:space="preserve">
          <source>Tag &lt;strong id=&quot;tag&quot;&gt;tag&lt;/strong&gt;;</source>
          <target state="translated">태그 &lt;strong id=&quot;tag&quot;&gt;태그&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="fcf2d565ce96b099f77ff84306963c104e330946" translate="yes" xml:space="preserve">
          <source>Tag name</source>
          <target state="translated">태그 이름</target>
        </trans-unit>
        <trans-unit id="45433dd83b3add2fc055c8b55b54bcb84c5efce1" translate="yes" xml:space="preserve">
          <source>Tag types.</source>
          <target state="translated">태그 유형.</target>
        </trans-unit>
        <trans-unit id="ec44347be28a87e8e74c0a208c3212420fd927c4" translate="yes" xml:space="preserve">
          <source>TagType &lt;code&gt;type&lt;/code&gt;</source>
          <target state="translated">태그 &lt;code&gt;type&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="07de510038162b6e6f2223208fce3b66b4ed2a21" translate="yes" xml:space="preserve">
          <source>TagType &lt;strong id=&quot;type&quot;&gt;type&lt;/strong&gt;;</source>
          <target state="translated">TagType &lt;strong id=&quot;type&quot;&gt;유형&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="68ddd91d0b9671a791224a07e7c4440e749e446a" translate="yes" xml:space="preserve">
          <source>Tagalog</source>
          <target state="translated">Tagalog</target>
        </trans-unit>
        <trans-unit id="d97ec9a0d0dd8012061bd1e25a018f7d246bc720" translate="yes" xml:space="preserve">
          <source>Tagbanwa</source>
          <target state="translated">Tagbanwa</target>
        </trans-unit>
        <trans-unit id="19a746b6a9f44b25060cdd716c403e005d486882" translate="yes" xml:space="preserve">
          <source>Tagging</source>
          <target state="translated">Tagging</target>
        </trans-unit>
        <trans-unit id="848eed0fbd5429f556b2982dec3ea87136e33e44" translate="yes" xml:space="preserve">
          <source>Tags</source>
          <target state="translated">Tags</target>
        </trans-unit>
        <trans-unit id="4b135b3e53c5cc145239c3187b94ca62dbd6cb7b" translate="yes" xml:space="preserve">
          <source>Tai Le</source>
          <target state="translated">타이 레</target>
        </trans-unit>
        <trans-unit id="1db9539327d3176ae71a5b761731fb4af48a8fe9" translate="yes" xml:space="preserve">
          <source>Tai Tham</source>
          <target state="translated">타이 탐</target>
        </trans-unit>
        <trans-unit id="d7e1ab091f083eeaf83b355b06db2c427c04167e" translate="yes" xml:space="preserve">
          <source>Tai Viet</source>
          <target state="translated">타이 베트</target>
        </trans-unit>
        <trans-unit id="e4265e63ead3083812dc6301eaeef90cd14be23b" translate="yes" xml:space="preserve">
          <source>Tai Xuan Jing Symbols</source>
          <target state="translated">타이 수안 징 기호</target>
        </trans-unit>
        <trans-unit id="7ce68ff3f210c997cf191cc3047dad75cfbe97db" translate="yes" xml:space="preserve">
          <source>Tai_Le</source>
          <target state="translated">Tai_Le</target>
        </trans-unit>
        <trans-unit id="30754c9b404b9f791325a342fd0c615c1607ad6a" translate="yes" xml:space="preserve">
          <source>Tai_Tham</source>
          <target state="translated">Tai_Tham</target>
        </trans-unit>
        <trans-unit id="d56a5ea60a6f1aee9d29df15fa3ff172f1ecef8f" translate="yes" xml:space="preserve">
          <source>Tai_Viet</source>
          <target state="translated">Tai_Viet</target>
        </trans-unit>
        <trans-unit id="3a6e9628faafbb48e8084c900458a1167e9901de" translate="yes" xml:space="preserve">
          <source>Take address of an elem.</source>
          <target state="translated">엘렘의 주소를 가져 가라.</target>
        </trans-unit>
        <trans-unit id="7ed2423541f92187f81ba89c0e47dc2169fa6d1b" translate="yes" xml:space="preserve">
          <source>Take address of expression.</source>
          <target state="translated">표현의 주소를 취하십시오.</target>
        </trans-unit>
        <trans-unit id="f3023d6f80703c78f22d59777d1a8edb85e49ba7" translate="yes" xml:space="preserve">
          <source>Take the specified storage class for p, and use the function signature to infer whether STC.scope_ and STC.return_ should be OR'd in. (This will not affect the name mangling.)</source>
          <target state="translated">p에 대해 지정된 스토리지 클래스를 가져 와서 함수 시그니처를 사용하여 STC.scope_ 및 STC.return_을 OR로 입력해야하는지 여부를 추론하십시오. 이는 이름 변경에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2ae7d68c9a8ce32022cbc269f8e6256fee39b3dd" translate="yes" xml:space="preserve">
          <source>Take!(Repeat!T) &lt;strong id=&quot;repeat&quot;&gt;repeat&lt;/strong&gt;(T)(T value, size_t n);</source>
          <target state="translated">Take! (Repeat! T) &lt;strong id=&quot;repeat&quot;&gt;반복&lt;/strong&gt; (T) (T 값, size_t n);</target>
        </trans-unit>
        <trans-unit id="6e6b86dc5f1d2d2d57fc97574f2a4df039b4926f" translate="yes" xml:space="preserve">
          <source>Take!R &lt;strong id=&quot;take&quot;&gt;take&lt;/strong&gt;(R)(R input, size_t n)</source>
          <target state="translated">Take! R &lt;strong id=&quot;take&quot;&gt;take&lt;/strong&gt; (R) (R 입력, size_t n)</target>
        </trans-unit>
        <trans-unit id="ed426f3fc7832efa21a6b239d16998d7c8fcfe33" translate="yes" xml:space="preserve">
          <source>Takes a function of (potentially) many arguments, and returns a function taking one argument and returns a callable taking the rest. f(x, y) == curry(f)(x)(y)</source>
          <target state="translated">(잠재적으로) 많은 인수의 함수를 취하고 하나의 인수를 취하는 함수를 반환하고 나머지를 취하는 콜 러블을 반환합니다. f (x, y) == 카레 (f) (x) (y)</target>
        </trans-unit>
        <trans-unit id="c666be996a9eb590eb7e759fbeb5c019d402f50e" translate="yes" xml:space="preserve">
          <source>Takes a path, and escapes '(', ')' and backslashes</source>
          <target state="translated">경로를 가져 와서 '(', ')'및 백 슬래시를 이스케이프 처리</target>
        </trans-unit>
        <trans-unit id="a768ec454ff2fc5699748e2729d50567f9d815a8" translate="yes" xml:space="preserve">
          <source>Takes a range of &lt;code&gt;ubyte&lt;/code&gt;s and converts the first &lt;code&gt;T.sizeof&lt;/code&gt; bytes to &lt;code&gt;T&lt;/code&gt;. The value returned is converted from the given endianness to the native endianness. The &lt;code&gt;T.sizeof&lt;/code&gt; bytes which are read are consumed from the range.</source>
          <target state="translated">&lt;code&gt;ubyte&lt;/code&gt; 의 범위를 취하고 첫 번째 &lt;code&gt;T.sizeof&lt;/code&gt; 바이트를 &lt;code&gt;T&lt;/code&gt; 로 변환합니다 . 반환 된 값은 주어진 엔디안에서 네이티브 엔디안으로 변환됩니다. &lt;code&gt;T.sizeof&lt;/code&gt; 의 읽기 바이트 범위에서 소비된다.</target>
        </trans-unit>
        <trans-unit id="c3eec28def54a57b1683c0b7d90328ed87f45f4b" translate="yes" xml:space="preserve">
          <source>Takes a range of &lt;code&gt;ubyte&lt;/code&gt;s and converts the first &lt;code&gt;T.sizeof&lt;/code&gt; bytes to &lt;code&gt;T&lt;/code&gt;. The value returned is converted from the given endianness to the native endianness. The range is not consumed.</source>
          <target state="translated">&lt;code&gt;ubyte&lt;/code&gt; 의 범위를 취하고 첫 번째 &lt;code&gt;T.sizeof&lt;/code&gt; 바이트를 &lt;code&gt;T&lt;/code&gt; 로 변환합니다 . 반환 된 값은 주어진 엔디안에서 네이티브 엔디안으로 변환됩니다. 범위가 소비되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c0931566b54e0e12b0cc2d830152964f82a5e6a1" translate="yes" xml:space="preserve">
          <source>Takes a single argument which must evaluate to a function. The result is a &lt;code&gt;ptrdiff_t&lt;/code&gt; containing the index of that function within the vtable of the parent type. If the function passed in is final and does not override a virtual function, &lt;code&gt;-1&lt;/code&gt; is returned instead.</source>
          <target state="translated">함수로 평가해야하는 단일 인수를 사용합니다. 결과는 부모 유형의 vtable 내에 해당 함수의 색인을 포함 하는 &lt;code&gt;ptrdiff_t&lt;/code&gt; 입니다. 전달 된 함수가 final이고 가상 함수를 대체하지 않으면 대신 &lt;code&gt;-1&lt;/code&gt; 이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="73485bb17b87f8ff91e94fd45a73f9b37ff413f9" translate="yes" xml:space="preserve">
          <source>Takes a single argument which must evaluate to a symbol. The result is the symbol that is the parent of it.</source>
          <target state="translated">기호로 평가해야하는 단일 인수를 사용합니다. 결과는 부모의 심볼입니다.</target>
        </trans-unit>
        <trans-unit id="68b555869649e369e2a9c66bc322b4d069cde15d" translate="yes" xml:space="preserve">
          <source>Takes a single argument, which must evaluate to either a class type or an expression of class type. The result is of type &lt;code&gt;size_t&lt;/code&gt;, and the value is the number of bytes in the runtime instance of the class type. It is based on the static type of a class, not the polymorphic type.</source>
          <target state="translated">클래스 유형 또는 클래스 유형의 표현식으로 평가되어야하는 단일 인수를 사용합니다. 결과는 &lt;code&gt;size_t&lt;/code&gt; 유형 이며 값은 클래스 유형의 런타임 인스턴스에있는 바이트 수입니다. 다형성 유형이 아니라 클래스의 정적 유형을 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="2d8031cf5851eb003db968a3a2a2df09d81b77be" translate="yes" xml:space="preserve">
          <source>Takes a single argument, which must evaluate to either a type or an expression of type. A tuple of string literals is returned, each of which is the name of a member of that type combined with all of the members of the base classes (if the type is a class). No name is repeated. Builtin properties are not included.</source>
          <target state="translated">단일 인수를 사용합니다.이 인수는 유형 또는 유형의 표현식으로 평가되어야합니다. 문자열 리터럴의 튜플이 반환되는데, 각 문자열 리터럴은 해당 유형의 멤버 이름으로 기본 클래스의 모든 멤버와 결합됩니다 (유형이 클래스 인 경우). 이름이 반복되지 않습니다. 내장 속성은 포함되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dd40783a2279d0463b2d5c0633686ce7b34449f6" translate="yes" xml:space="preserve">
          <source>Takes a single argument, which must evaluate to either a type or an expression of type. A tuple of string literals is returned, each of which is the name of a member of that type. No name is repeated. Base class member names are not included. Builtin properties are not included.</source>
          <target state="translated">단일 인수를 사용합니다.이 인수는 유형 또는 유형의 표현식으로 평가되어야합니다. 튜플 문자열 리터럴이 반환되며 각 문자열 리터럴은 해당 유형의 멤버 이름입니다. 이름이 반복되지 않습니다. 기본 클래스 멤버 이름은 포함되지 않습니다. 내장 속성은 포함되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d5f20921df9fc539092cb622f3740141e759deec" translate="yes" xml:space="preserve">
          <source>Takes a slice by-reference of this &lt;code&gt;Tuple&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;Tuple&lt;/code&gt; 을 참조하여 슬라이스를 가져 옵니다 .</target>
        </trans-unit>
        <trans-unit id="e25d6abbab89b8445585cd2745b5291b0bc5276e" translate="yes" xml:space="preserve">
          <source>Takes a string &lt;code&gt;s&lt;/code&gt; and determines if it represents a number. This function also takes an optional parameter, &lt;code&gt;bAllowSep&lt;/code&gt;, which will accept the separator characters &lt;code&gt;','&lt;/code&gt; and &lt;code&gt;'__'&lt;/code&gt; within the string. But these characters should be stripped from the string before using any of the conversion functions like &lt;code&gt;to!int()&lt;/code&gt;, &lt;code&gt;to!float()&lt;/code&gt;, and etc else an error will occur.</source>
          <target state="translated">문자열 걸린다 &lt;code&gt;s&lt;/code&gt; 과 그 수를 나타내는지를 결정. 이 함수는 또한 선택적 매개 변수 인 &lt;code&gt;bAllowSep&lt;/code&gt; 를 사용합니다 .이 매개 변수 는 문자열 내에 구분 문자 &lt;code&gt;','&lt;/code&gt; 및 &lt;code&gt;'__'&lt;/code&gt; 을 사용할 수 있습니다. 그러나 &lt;code&gt;to!int()&lt;/code&gt; , &lt;code&gt;to!float()&lt;/code&gt; 등 의 변환 함수를 사용하기 전에 이러한 문자를 문자열에서 제거해야 합니다. 그렇지 않으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="ac51856e75b266498c386996a6664e4b6791447a" translate="yes" xml:space="preserve">
          <source>Takes a string made of hexadecimal digits and returns the matching string by converting each pair of digits to a character. The input string can also include white characters, which can be used to keep the literal string readable in the source code.</source>
          <target state="translated">16 진수로 만든 문자열을 가져와 각 숫자 쌍을 문자로 변환하여 일치하는 문자열을 반환합니다. 입력 문자열에는 소스 문자에서 리터럴 문자열을 읽을 수있게하는 데 사용할 수있는 흰색 문자도 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b16a8ab6116807bf9a5b760fe03433d82fb6f8c4" translate="yes" xml:space="preserve">
          <source>Takes a string representing an &lt;code&gt;enum&lt;/code&gt; type and returns that type.</source>
          <target state="translated">&lt;code&gt;enum&lt;/code&gt; 형을 나타내는 문자열을 가져와 해당 형식을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="80fe0d5034b8dfd00b1ac310a8dc1895ce2c160f" translate="yes" xml:space="preserve">
          <source>Takes a tree of JSON values and returns the serialized string.</source>
          <target state="translated">JSON 값의 트리를 가져와 직렬화 된 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b07c2a231c3b1270c1dff6d10774e91b99c52a4f" translate="yes" xml:space="preserve">
          <source>Takes an integral value, converts it to the given endianness, and appends it to the given range of &lt;code&gt;ubyte&lt;/code&gt;s (using &lt;code&gt;put&lt;/code&gt;) as a sequence of &lt;code&gt;T.sizeof&lt;/code&gt;&lt;code&gt;ubyte&lt;/code&gt;s starting at index. &lt;code&gt;hasSlicing!R&lt;/code&gt; must be &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">정수 값을 가져 와서 주어진 엔디안으로 변환 한 후 인덱스에서 시작하여 &lt;code&gt;T.sizeof&lt;/code&gt; &lt;code&gt;ubyte&lt;/code&gt; 시퀀스로 주어진 &lt;code&gt;ubyte&lt;/code&gt; 범위 ( &lt;code&gt;put&lt;/code&gt; 사용 )에 추가합니다 . &lt;code&gt;hasSlicing!R&lt;/code&gt; 은 &lt;code&gt;true&lt;/code&gt; 여야 합니다 .</target>
        </trans-unit>
        <trans-unit id="9785884790cecbf82ffb0a5c883b32c0d173b2c3" translate="yes" xml:space="preserve">
          <source>Takes an integral value, converts it to the given endianness, and writes it to the given range of &lt;code&gt;ubyte&lt;/code&gt;s as a sequence of &lt;code&gt;T.sizeof&lt;/code&gt;&lt;code&gt;ubyte&lt;/code&gt;s starting at index. &lt;code&gt;hasSlicing!R&lt;/code&gt; must be &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">정수 값을 가져 와서 주어진 엔디안 (endianness)으로 변환 한 후 인덱스에서 시작 하는 일련의 &lt;code&gt;T.sizeof&lt;/code&gt; &lt;code&gt;ubyte&lt;/code&gt; 시퀀스로 지정된 &lt;code&gt;ubyte&lt;/code&gt; 범위에 씁니다 . &lt;code&gt;hasSlicing!R&lt;/code&gt; 은 &lt;code&gt;true&lt;/code&gt; 여야 합니다 .</target>
        </trans-unit>
        <trans-unit id="a33070f25e55dd5ef7e3c244a5b7a594a908421f" translate="yes" xml:space="preserve">
          <source>Takes multiple functions and adjoins them together.</source>
          <target state="translated">여러 기능을 취해 서로 연결합니다.</target>
        </trans-unit>
        <trans-unit id="ddab590de70993e13bcdedefd109e98917efe98a" translate="yes" xml:space="preserve">
          <source>Takes one argument and returns &lt;code&gt;true&lt;/code&gt; if it's a function declaration marked with &lt;code&gt;@disable&lt;/code&gt;.</source>
          <target state="translated">하나의 인수 를 &lt;code&gt;@disable&lt;/code&gt; 로 표시된 함수 선언 인 경우 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 .</target>
        </trans-unit>
        <trans-unit id="67386c885ba4735db9bc829789113fd7d2afe5a4" translate="yes" xml:space="preserve">
          <source>Takes one argument which is a symbol. To disambiguate between overloads, pass the result of &lt;a href=&quot;#getOverloads&quot;&gt;&lt;i&gt;getOverloads&lt;/i&gt;&lt;/a&gt; with the desired index, to &lt;code&gt;getLocation&lt;/code&gt;. Returns a &lt;code&gt;tuple(string, int, int)&lt;/code&gt; whose entries correspond to the filename, line number and column number where the argument was declared.</source>
          <target state="translated">하나의 인수 인 인수를 사용합니다. 오버로드를 명확하게하려면 &lt;a href=&quot;#getOverloads&quot;&gt;&lt;i&gt;getOverloads&lt;/i&gt;&lt;/a&gt; 결과를 원하는 인덱스로 &lt;code&gt;getLocation&lt;/code&gt; 에 전달하십시오 . 인수가 선언 된 파일 이름, 행 번호 및 열 번호에 해당하는 항목을 가진 &lt;code&gt;tuple(string, int, int)&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="7c1d6e615645b724c794c3938303d3973c03a63c" translate="yes" xml:space="preserve">
          <source>Takes one argument which must be a type. If the type's &lt;a href=&quot;property#init&quot;&gt;default initializer&lt;/a&gt; is all zero bits then &lt;code&gt;true&lt;/code&gt; is returned, otherwise &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">유형이어야하는 하나의 인수를 사용합니다. 형식의 &lt;a href=&quot;property#init&quot;&gt;기본 이니셜 라이저&lt;/a&gt; 가 모두 0 비트이면 &lt;code&gt;true&lt;/code&gt; 가 반환되고, 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 가 반환 됩니다.</target>
        </trans-unit>
        <trans-unit id="87bc2cf5ee35cc01493547ac01dad3a717d14b91" translate="yes" xml:space="preserve">
          <source>Takes one argument which must either be a function symbol, function literal, a delegate, or a function pointer. It returns a &lt;code&gt;bool&lt;/code&gt; which is &lt;code&gt;true&lt;/code&gt; if the return value of the function is returned on the stack via a pointer to it passed as a hidden extra parameter to the function.</source>
          <target state="translated">함수 심볼, 함수 리터럴, 델리게이트 또는 함수 포인터 여야하는 하나의 인수를 사용합니다. 그것은 반환 &lt;code&gt;bool&lt;/code&gt; 입니다 &lt;code&gt;true&lt;/code&gt; 은 함수에 숨겨진 별도의 매개 변수로 전달에 함수의 반환 값이 포인터를 통해 스택에 반환되는 경우입니다.</target>
        </trans-unit>
        <trans-unit id="97621cd19225b41beff6e5155d8b9ca36fc90d28" translate="yes" xml:space="preserve">
          <source>Takes one argument which must either be a function symbol, function literal, or a function pointer. It returns a string tuple of all the attributes of that function &lt;b&gt;excluding&lt;/b&gt; any user-defined attributes (UDAs can be retrieved with the &lt;a href=&quot;#get-attributes&quot;&gt;getAttributes&lt;/a&gt; trait). If no attributes exist it will return an empty tuple.</source>
          <target state="translated">함수 심볼, 함수 리터럴 또는 함수 포인터 여야하는 하나의 인수를 사용합니다. 사용자 정의 속성을 &lt;b&gt;제외한&lt;/b&gt; 해당 함수의 모든 속성의 문자열 튜플을 리턴 합니다 (UDA는 &lt;a href=&quot;#get-attributes&quot;&gt;getAttributes&lt;/a&gt; 특성 으로 검색 할 수 있음 ). 속성이 존재하지 않으면 빈 튜플을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="39c92455342775a9094aa1d1cdeba48c5cda2b3b" translate="yes" xml:space="preserve">
          <source>Takes one argument which must either be a function symbol, or a type that is a function, delegate or a function pointer. It returns a string identifying the kind of &lt;a href=&quot;function#variadic&quot;&gt;variadic arguments&lt;/a&gt; that are supported.</source>
          <target state="translated">함수 심볼이거나 함수, 대리자 또는 함수 포인터 인 형식이어야하는 하나의 인수를 사용합니다. 지원되는 &lt;a href=&quot;function#variadic&quot;&gt;variadic 인수&lt;/a&gt; 의 종류를 식별하는 문자열을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="0e8e3f521873e107568842419f21bb4537549307" translate="yes" xml:space="preserve">
          <source>Takes one argument, a symbol of an aggregate (e.g. struct/class/module). The result is a tuple of all the unit test functions of that aggregate. The functions returned are like normal nested static functions, &lt;a href=&quot;https://dlang.org/glossary.html#ctfe&quot;&gt;CTFE&lt;/a&gt; will work and &lt;a href=&quot;attribute#uda&quot;&gt;UDAs&lt;/a&gt; will be accessible.</source>
          <target state="translated">집합의 상징 인 하나의 인수를 취합니다 (예 : struct / class / module). 결과는 해당 집계의 모든 단위 테스트 기능의 튜플입니다. 반환 된 함수는 일반 중첩 정적 함수와 같으며 &lt;a href=&quot;https://dlang.org/glossary.html#ctfe&quot;&gt;CTFE&lt;/a&gt; 가 작동하며 &lt;a href=&quot;attribute#uda&quot;&gt;UDA에&lt;/a&gt; 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e645c3eaf27b6e127c4e64f1c5e718743c0c0f0e" translate="yes" xml:space="preserve">
          <source>Takes one argument, a symbol. Returns a tuple of all attached user-defined attributes. If no UDAs exist it will return an empty tuple.</source>
          <target state="translated">하나의 인수, 상징을 취합니다. 연결된 모든 사용자 정의 속성의 튜플을 반환합니다. UDA가 없으면 빈 튜플을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2156779dbfc3bbcd9c3c0f15b3c1104b1d55fa5e" translate="yes" xml:space="preserve">
          <source>Takes one argument, a symbol. Returns the identifier for that symbol as a string literal.</source>
          <target state="translated">하나의 인수, 상징을 취합니다. 해당 기호의 식별자를 문자열 리터럴로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="341c32de0417883510f5908fdfb5d1408b6c6386" translate="yes" xml:space="preserve">
          <source>Takes one argument, a type. If the type has &lt;code&gt;alias this&lt;/code&gt; declarations, returns a sequence of the names (as &lt;code&gt;string&lt;/code&gt;s) of the members used in those declarations. Otherwise returns an empty sequence.</source>
          <target state="translated">하나의 인수, 유형을 취합니다. 형식 &lt;code&gt;alias this&lt;/code&gt; 선언 이 별칭 인 경우 해당 선언에 사용 된 멤버의 이름 시퀀스 ( &lt;code&gt;string&lt;/code&gt; s)를 반환합니다 . 그렇지 않으면 빈 시퀀스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="438ba37cf3e2477c1f85c28f97e1be1e2147103a" translate="yes" xml:space="preserve">
          <source>Takes one argument, which is a declaration symbol, or the type of a function, delegate, pointer to function, struct, class, or interface. Returns a string representing the &lt;a href=&quot;attribute#LinkageAttribute&quot;&gt;LinkageAttribute&lt;/a&gt; of the declaration. The string is one of:</source>
          <target state="translated">선언 기호 또는 함수, 대리자, 함수에 대한 포인터, 구조체, 클래스 또는 인터페이스의 유형 인 하나의 인수를 사용합니다. 선언 의 &lt;a href=&quot;attribute#LinkageAttribute&quot;&gt;LinkageAttribute&lt;/a&gt; 를 나타내는 문자열을 반환합니다 . 문자열은 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="ba131648e1c6eb1f568b6cae116365dae307ac96" translate="yes" xml:space="preserve">
          <source>Takes one argument, which must be a type. It returns &lt;code&gt;true&lt;/code&gt; if the type is a &lt;a href=&quot;https://dlang.org/glossary.html#pod&quot;&gt;POD&lt;/a&gt; type, otherwise &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">하나의 인수를 취하는데, 이는 유형이어야합니다. 형식이 &lt;a href=&quot;https://dlang.org/glossary.html#pod&quot;&gt;POD&lt;/a&gt; 형식 &lt;code&gt;true&lt;/code&gt; 반환하고 , 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="0441a02e332399ff202e6021026cd897a933b46b" translate="yes" xml:space="preserve">
          <source>Takes one argument. If that argument is a declaration, &lt;code&gt;true&lt;/code&gt; is returned if it is ref, out, or lazy, otherwise &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">하나의 주장을 취합니다. 해당 인수가 선언 &lt;code&gt;true&lt;/code&gt; ref, out 또는 lazy 이면 true 가 반환되고, 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 가 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="1e2989333da89d1f14258e33489aab152f4d814e" translate="yes" xml:space="preserve">
          <source>Takes one argument. If that argument is a final function, &lt;code&gt;true&lt;/code&gt; is returned, otherwise &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">하나의 주장을 취합니다. 해당 인수가 최종 함수이면 &lt;code&gt;true&lt;/code&gt; 가 반환되고 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 가 반환 됩니다.</target>
        </trans-unit>
        <trans-unit id="ddec073d306dd4ca03018c32b117f3e1e7f2351a" translate="yes" xml:space="preserve">
          <source>Takes one argument. If that argument is a function marked with override, &lt;code&gt;true&lt;/code&gt; is returned, otherwise &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">하나의 주장을 취합니다. 해당 인수가 override로 표시된 함수 &lt;code&gt;true&lt;/code&gt; 가 리턴되고 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 가 리턴 됩니다.</target>
        </trans-unit>
        <trans-unit id="e068a9eb9df6980a9e0034c3f00e31a3c1deea42" translate="yes" xml:space="preserve">
          <source>Takes one argument. If that argument is a static function, meaning it has no context pointer, &lt;code&gt;true&lt;/code&gt; is returned, otherwise &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">하나의 주장을 취합니다. 해당 인수가 정적 함수 인 경우 컨텍스트 포인터가 없으면 &lt;code&gt;true&lt;/code&gt; 가 리턴되고 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 가 리턴 됩니다.</target>
        </trans-unit>
        <trans-unit id="d262441198edcdb862064f2f1b47b17c36638664" translate="yes" xml:space="preserve">
          <source>Takes one argument. If that argument is a symbol that refers to a &lt;a href=&quot;module&quot;&gt;spec/module, module&lt;/a&gt; then &lt;code&gt;true&lt;/code&gt; is returned, otherwise &lt;code&gt;false&lt;/code&gt;. &lt;a href=&quot;module#package-module&quot;&gt;Package modules&lt;/a&gt; are considered to be modules even if they have not been directly imported as modules.</source>
          <target state="translated">하나의 주장을 취합니다. 그 인수가 참조하는 심볼 인 경우 &lt;a href=&quot;module&quot;&gt;사양 / 모듈, 모듈&lt;/a&gt; 다음 &lt;code&gt;true&lt;/code&gt; 그렇지 않으면 반환 &lt;code&gt;false&lt;/code&gt; . &lt;a href=&quot;module#package-module&quot;&gt;패키지 모듈&lt;/a&gt; 은 모듈로 직접 가져 오지 않은 경우에도 모듈 로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="e8489b031e8d252fd5210cb21ca32120b6e151d6" translate="yes" xml:space="preserve">
          <source>Takes one argument. If that argument is a symbol that refers to a &lt;a href=&quot;module&quot;&gt;spec/module, package&lt;/a&gt; then &lt;code&gt;true&lt;/code&gt; is returned, otherwise &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">하나의 주장을 취합니다. 그 인수가 참조하는 심볼 인 경우 &lt;a href=&quot;module&quot;&gt;사양 / 모듈, 패키지&lt;/a&gt; 다음 &lt;code&gt;true&lt;/code&gt; 그렇지 않으면 반환 &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ae0191e839c839921bd4e31032678c9d66e77c33" translate="yes" xml:space="preserve">
          <source>Takes one argument. If that argument is a template then &lt;code&gt;true&lt;/code&gt; is returned, otherwise &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">하나의 주장을 취합니다. 해당 인수가 템플릿이면 &lt;code&gt;true&lt;/code&gt; 가 반환되고 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 가 반환 됩니다.</target>
        </trans-unit>
        <trans-unit id="7ebe41dcd3dd8de1d463ea4bcbb0107229ca8ba7" translate="yes" xml:space="preserve">
          <source>Takes one argument. If that argument is a virtual function, &lt;code&gt;true&lt;/code&gt; is returned, otherwise &lt;code&gt;false&lt;/code&gt;. Final functions that don't override anything return false.</source>
          <target state="translated">하나의 주장을 취합니다. 해당 인수가 가상 함수이면 &lt;code&gt;true&lt;/code&gt; 가 반환되고, 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 입니다. 아무것도 재정의하지 않는 최종 함수는 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="863c570d92b83c67f55f3e7188a134a725cf3bf6" translate="yes" xml:space="preserve">
          <source>Takes one argument. If that argument is an abstract function, &lt;code&gt;true&lt;/code&gt; is returned, otherwise &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">하나의 주장을 취합니다. 해당 인수가 추상 함수이면 &lt;code&gt;true&lt;/code&gt; 가 반환되고 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 가 반환 됩니다.</target>
        </trans-unit>
        <trans-unit id="61eb2f0952d80546e2227df1b6d3e1f066986474" translate="yes" xml:space="preserve">
          <source>Takes one argument. It returns &lt;code&gt;true&lt;/code&gt; if the argument is a nested type which internally stores a context pointer, otherwise it returns &lt;code&gt;false&lt;/code&gt;. Nested types can be &lt;a href=&quot;class#nested&quot;&gt;classes&lt;/a&gt;, &lt;a href=&quot;struct#nested&quot;&gt;structs&lt;/a&gt;, and &lt;a href=&quot;function#variadicnested&quot;&gt;functions&lt;/a&gt;.</source>
          <target state="translated">하나의 주장을 취합니다. 인수가 내부적으로 컨텍스트 포인터를 저장하는 중첩 유형 인 경우 &lt;code&gt;true&lt;/code&gt; 를 리턴 하고 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 리턴합니다 . 중첩 형식은 &lt;a href=&quot;class#nested&quot;&gt;클래스&lt;/a&gt; , &lt;a href=&quot;struct#nested&quot;&gt;구조체&lt;/a&gt; 및 &lt;a href=&quot;function#variadicnested&quot;&gt;함수일&lt;/a&gt; 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3e2a814d0c6c5c43dbdb1aa3794de3e4f7e8cebe" translate="yes" xml:space="preserve">
          <source>Takes one argument. It returns &lt;code&gt;true&lt;/code&gt; if the argument is a symbol marked with the &lt;code&gt;@future&lt;/code&gt; keyword, otherwise &lt;code&gt;false&lt;/code&gt;. Currently, only functions and variable declarations have support for the &lt;code&gt;@future&lt;/code&gt; keyword.</source>
          <target state="translated">하나의 주장을 취합니다. 그것은 반환 &lt;code&gt;true&lt;/code&gt; 인수가 표시 기호 인 경우 &lt;code&gt;@future&lt;/code&gt; 의 키워드, 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; . 현재 함수와 변수 선언 만 &lt;code&gt;@future&lt;/code&gt; 키워드를 지원 합니다.</target>
        </trans-unit>
        <trans-unit id="b92fd55104f993e0c852b4df6c0429c26903b7ef" translate="yes" xml:space="preserve">
          <source>Takes one argument. It returns &lt;code&gt;true&lt;/code&gt; if the argument is a symbol marked with the &lt;code&gt;deprecated&lt;/code&gt; keyword, otherwise &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">하나의 주장을 취합니다. 인수가 &lt;code&gt;deprecated&lt;/code&gt; 키워드 로 표시된 기호 인 경우 &lt;code&gt;true&lt;/code&gt; 를 리턴 하고 , 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 리턴 합니다 .</target>
        </trans-unit>
        <trans-unit id="f348e74b9607daf851a06d094877b94982d44164" translate="yes" xml:space="preserve">
          <source>Takes ownership of a store assuming it already was organized as a heap.</source>
          <target state="translated">상점이 이미 힙으로 구성되어 있다고 가정하면 상점의 소유권을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="abf275e8fde1a93863fd7e002f7fe18e1771a7d8" translate="yes" xml:space="preserve">
          <source>Takes ownership of a store. After this, manipulating &lt;code&gt;s&lt;/code&gt; may make the heap work incorrectly.</source>
          <target state="translated">상점의 소유권을 갖습니다. 이 후 &lt;code&gt;s&lt;/code&gt; 를 조작 하면 힙이 제대로 작동하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba241c43b9e67f71ff3c0ddfe5c1f8f084092339" translate="yes" xml:space="preserve">
          <source>Takes the number of hnsecs (100 ns) since midnight, January 1st, 1 A.D. in UTC time (i.e. std time) and converts it to this time zone's time.</source>
          <target state="translated">1 월 1 일 AD 1 월 자정 (UTC 시간) 이후 hnsec (100ns)의 수를 가져 와서이 표준 시간대 시간으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="4065d089b4e20bd1ee13267e586cbcfef7117537" translate="yes" xml:space="preserve">
          <source>Takes the number of hnsecs (100 ns) since midnight, January 1st, 1 A.D. in UTC time (i.e. std time) and returns whether DST is effect in this time zone at the given point in time.</source>
          <target state="translated">1 월 1 일 AD 1 월 1 일 자정 (UTC 시간) 이후 hnsec (100ns)의 수를 가져 와서 주어진 시간에 DST가이 시간대에 적용되는지 여부를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="848786fb1221dc1ebb6ce572a55838f0543e640b" translate="yes" xml:space="preserve">
          <source>Takes the number of hnsecs (100 ns) since midnight, January 1st, 1 A.D. in UTC time (i.e. std time) and returns whether DST is in effect in this time zone at the given point in time.</source>
          <target state="translated">1 월 1 일 1 일 자정 (UTC) (태평양 표준시) (1 월 1 일 자정) 이후 hnsec (100ns)의 수를 가져와 주어진 시간대에이 표준 시간대에서 DST가 적용되는지 여부를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a17f6231d4d687b48dc77dac8c8037b006a58d20" translate="yes" xml:space="preserve">
          <source>Takes the number of hnsecs (100 ns) since midnight, January 1st, 1 A.D. in this time zone's time and converts it to UTC (i.e. std time).</source>
          <target state="translated">이 표준 시간대로 AD 1 월 1 일 자정 이후의 hnsec (100ns) 수를 가져와 UTC (즉, 표준 시간)로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="b91b3f492592d4dd757b6ee3c4c2c67f1195b458" translate="yes" xml:space="preserve">
          <source>Takes two arguments and returns bool &lt;code&gt;true&lt;/code&gt; if they are the same symbol, &lt;code&gt;false&lt;/code&gt; if not.</source>
          <target state="translated">두 개의 인수를 사용하고 동일한 기호 인 경우 bool &lt;code&gt;true&lt;/code&gt; 를 리턴하고 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="1fd6b734070147ebd7e778bead2ddc672a61abd2" translate="yes" xml:space="preserve">
          <source>Takes two arguments, the second must be a string. The result is an expression formed from the first argument, followed by a &amp;lsquo;.&amp;rsquo;, followed by the second argument as an identifier.</source>
          <target state="translated">두 개의 인수를 취합니다. 두 번째는 문자열이어야합니다. 결과는 첫 번째 인수, '.', 식별자로 사용되는 두 번째 인수로 구성된 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="6091a04c8d0ceed563c5ac0a0c00d4d331dce18d" translate="yes" xml:space="preserve">
          <source>Takes two arguments. The first must be a symbol or expression. The second is a symbol, such as an alias to a member of the first argument. The result is the second argument interpreted with its &lt;code&gt;this&lt;/code&gt; context set to the value of the first argument.</source>
          <target state="translated">두 개의 인수를받습니다. 첫 번째는 기호 또는 표현식이어야합니다. 두 번째는 첫 번째 인수의 멤버에 대한 별칭과 같은 기호입니다. 결과는 &lt;code&gt;this&lt;/code&gt; 컨텍스트가 첫 번째 인수의 값으로 설정된 두 번째 인수입니다.</target>
        </trans-unit>
        <trans-unit id="d2d8ce9f86ea0164b3d45e729c421e562a767a2b" translate="yes" xml:space="preserve">
          <source>Takes two arguments. The first must either be a function symbol, or a type that is a function, delegate or a function pointer. The second is an integer identifying which parameter, where the first parameter is 0. It returns a tuple of strings representing the storage classes of that parameter.</source>
          <target state="translated">두 가지 주장을 취합니다. 첫 번째는 함수 기호이거나 함수, 대리자 또는 함수 포인터 인 형식이어야합니다. 두 번째는 어떤 매개 변수를 식별하는 정수이며 첫 번째 매개 변수는 0입니다. 해당 매개 변수의 스토리지 클래스를 나타내는 문자열 튜플을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="088b6ccbc4dc304c0a15b65acceb41e52684a26d" translate="yes" xml:space="preserve">
          <source>Taking a 2-level Trie as an example the principle of operation is as follows. Split the number of bits in a key (code point, 21 bits) into 2 components (e.g. 15 and 8). The first is the number of bits in the index of the trie and the other is number of bits in each page of the trie. The layout of the trie is then an array of size 2^^bits-of-index followed an array of memory chunks of size 2^^bits-of-page/bits-per-element.</source>
          <target state="translated">2 단계 Trie를 예로 들어 작동 원리는 다음과 같습니다. 키의 비트 수 (코드 포인트, 21 비트)를 2 개의 구성 요소 (예 : 15 및 8)로 분할하십시오. 첫 번째는 trie의 인덱스에있는 비트 수이고 다른 하나는 trie의 각 페이지에있는 비트 수입니다. trie의 레이아웃은 크기가 2 ^^ 비트의 배열이고, 요소 당 2 비트의 페이지 / 비트의 메모리 청크 배열이 뒤 따릅니다.</target>
        </trans-unit>
        <trans-unit id="cdebdf3e1f27466bf5788aea765d124954770adc" translate="yes" xml:space="preserve">
          <source>Taking a &lt;code&gt;ubyte[n]&lt;/code&gt; helps prevent accidentally using a swapped value as a regular one (and in the case of floating point values, it's necessary, because the FPU will mess up any swapped floating point values. So, you can't actually have swapped floating point values as floating point values).</source>
          <target state="translated">복용하는 &lt;code&gt;ubyte[n]&lt;/code&gt; 스왑 된 부동 소수점 값. 그래서 최대 FPU의 의지 혼란, 당신은 실제로있을 수 없기 때문에, (그리고 부동 소수점 값의 경우, 필요의 정기적 인 하나 같이 교체 값을 사용하여 실수 방지하는 데 도움이 부동 소수점 값을 부동 소수점 값으로 바)).</target>
        </trans-unit>
        <trans-unit id="12c7df23cc8d75b166a89e7a81c239e1eaa5fc9d" translate="yes" xml:space="preserve">
          <source>Taking the address of (i.e. making a delegate to) a nested function that accesses variables in an outer scope</source>
          <target state="translated">외부 범위의 변수에 액세스하는 중첩 함수의 주소를 가져옵니다 (즉, 델리게이트 만들기).</target>
        </trans-unit>
        <trans-unit id="4f571f8c15567583b37693f78ef5f80a807f7cd4" translate="yes" xml:space="preserve">
          <source>Taking the address of a local variable or function parameter.</source>
          <target state="translated">지역 변수 또는 함수 매개 변수의 주소를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="3d44d06fda277fec8865be5e542736e38ae54f97" translate="yes" xml:space="preserve">
          <source>Takri</source>
          <target state="translated">Takri</target>
        </trans-unit>
        <trans-unit id="86c2b6275f076b31c4be9812e835dab2a6f07ccf" translate="yes" xml:space="preserve">
          <source>Tamil</source>
          <target state="translated">Tamil</target>
        </trans-unit>
        <trans-unit id="61ad50a9b9189cc3cf1874568e35e7901ff4c982" translate="yes" xml:space="preserve">
          <source>Target</source>
          <target state="translated">Target</target>
        </trans-unit>
        <trans-unit id="e2ae5bcbc5b7ffd68695f52a7585c89c8969aab3" translate="yes" xml:space="preserve">
          <source>Target &lt;strong id=&quot;parse&quot;&gt;parse&lt;/strong&gt;(Target, Source)(ref Source s)</source>
          <target state="translated">대상 &lt;strong id=&quot;parse&quot;&gt;구문 분석&lt;/strong&gt; (대상, 소스) (참조 소스 s)</target>
        </trans-unit>
        <trans-unit id="b514ae24a3aa7e92170dd30b3670d799fc2ddaa0" translate="yes" xml:space="preserve">
          <source>Target &lt;strong id=&quot;parse&quot;&gt;parse&lt;/strong&gt;(Target, Source)(ref Source s, dchar lbracket = '[', dchar rbracket = ']', dchar comma = ',')</source>
          <target state="translated">대상 &lt;strong id=&quot;parse&quot;&gt;구문 분석&lt;/strong&gt; (대상, 소스) (참조 소스 s, dchar lbracket = '[', dchar rbracket = ']', dchar 쉼표 = ',')</target>
        </trans-unit>
        <trans-unit id="88b8c449e785e82ac31d743cbd6ec6d0cecb908c" translate="yes" xml:space="preserve">
          <source>Target &lt;strong id=&quot;parse&quot;&gt;parse&lt;/strong&gt;(Target, Source)(ref Source s, dchar lbracket = '[', dchar rbracket = ']', dchar keyval = ':', dchar comma = ',')</source>
          <target state="translated">대상 &lt;strong id=&quot;parse&quot;&gt;구문 분석&lt;/strong&gt; (대상, 소스) (참조 소스 s, dchar lbracket = '[', dchar rbracket = ']', dchar keyval = ':', dchar 쉼표 = ',')</target>
        </trans-unit>
        <trans-unit id="ababb58bd98453af215c7078c2bf13ec699efd22" translate="yes" xml:space="preserve">
          <source>Target &lt;strong id=&quot;parse&quot;&gt;parse&lt;/strong&gt;(Target, Source)(ref Source source)</source>
          <target state="translated">타겟 &lt;strong id=&quot;parse&quot;&gt;파싱&lt;/strong&gt; (타겟, 소스) (참조 소스 소스)</target>
        </trans-unit>
        <trans-unit id="6e89e3cf2e5369ad578243ee86873fbe19e0d25b" translate="yes" xml:space="preserve">
          <source>Target &lt;strong id=&quot;parse&quot;&gt;parse&lt;/strong&gt;(Target, Source)(ref Source source, uint radix)</source>
          <target state="translated">대상 &lt;strong id=&quot;parse&quot;&gt;구문 분석&lt;/strong&gt; (대상, 소스) (참조 소스 소스, uint 기수)</target>
        </trans-unit>
        <trans-unit id="d5afbc0e9237897788f0f2a802fb65dde3d350c3" translate="yes" xml:space="preserve">
          <source>Target &lt;strong id=&quot;target&quot;&gt;target&lt;/strong&gt;;</source>
          <target state="translated">목표 &lt;strong id=&quot;target&quot;&gt;목표&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="ad45e9e6809eb415ba34b6b16cb00ee54f97882b" translate="yes" xml:space="preserve">
          <source>TargetOS &lt;code&gt;os&lt;/code&gt;</source>
          <target state="translated">TargetOS &lt;code&gt;os&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2d43f3dda84c1737bbb2ff924a8ba890d1d06511" translate="yes" xml:space="preserve">
          <source>TargetOS &lt;strong id=&quot;os&quot;&gt;os&lt;/strong&gt;;</source>
          <target state="translated">TargetOS &lt;strong id=&quot;os&quot;&gt;os&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="6c4ef0b4f99b87e3c1020b8cae3d6c26c8e6f085" translate="yes" xml:space="preserve">
          <source>TargetRange &lt;code&gt;target&lt;/code&gt;</source>
          <target state="translated">TargetRange &lt;code&gt;target&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fb6a59f9131000cf28fe97282bcb28c63b9e4757" translate="yes" xml:space="preserve">
          <source>TargetRange &lt;strong id=&quot;copy&quot;&gt;copy&lt;/strong&gt;(SourceRange, TargetRange)(SourceRange source, TargetRange target)</source>
          <target state="translated">TargetRange &lt;strong id=&quot;copy&quot;&gt;사본&lt;/strong&gt; (SourceRange, TargetRange) (SourceRange 소스, TargetRange 대상)</target>
        </trans-unit>
        <trans-unit id="0ac7d0e93a32f99695c525a23b3d79466599bc63" translate="yes" xml:space="preserve">
          <source>Tarr &lt;code&gt;arr&lt;/code&gt;</source>
          <target state="translated">타르 &lt;code&gt;arr&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cbc5a0ebe859225371131257cf9afaa28a3ac017" translate="yes" xml:space="preserve">
          <source>Tarr &lt;code&gt;arrs&lt;/code&gt;</source>
          <target state="translated">타르 &lt;code&gt;arrs&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a3f39998ffdb8d442c80697d22b06e7ac5f3819d" translate="yes" xml:space="preserve">
          <source>Tarr &lt;code&gt;from&lt;/code&gt;</source>
          <target state="translated">타르 &lt;code&gt;from&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cf87ba10bfa3c6aec9ccdfb8418fb56c922287f3" translate="yes" xml:space="preserve">
          <source>Tarr &lt;code&gt;p&lt;/code&gt;</source>
          <target state="translated">타르 &lt;code&gt;p&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="44ca406f8c2b438a9883f43dbecea26d13faa9c5" translate="yes" xml:space="preserve">
          <source>Tarr &lt;code&gt;px&lt;/code&gt;</source>
          <target state="translated">타르 &lt;code&gt;px&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c66f7fbc59602165b2e59871d84a099eca281157" translate="yes" xml:space="preserve">
          <source>Tarr &lt;code&gt;to&lt;/code&gt;</source>
          <target state="translated">타르 &lt;code&gt;to&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="15764660dbf51678e961f9da7c77d238282a048f" translate="yes" xml:space="preserve">
          <source>Tarr &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">타르 &lt;code&gt;x&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="953418f76b8ef3144338e8d854335c95fd12fbea" translate="yes" xml:space="preserve">
          <source>Tarr &lt;code&gt;y&lt;/code&gt;</source>
          <target state="translated">타르의 &lt;code&gt;y&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2de521eff8a440c1a72d2890be1048326ca20663" translate="yes" xml:space="preserve">
          <source>Technically the memoized function should be pure because &lt;code&gt;memoize&lt;/code&gt; assumes it will always return the same result for a given tuple of arguments. However, &lt;code&gt;memoize&lt;/code&gt; does not enforce that because sometimes it is useful to memoize an impure function, too.</source>
          <target state="translated">기술적으로 memoized 함수는 순수해야합니다. &lt;code&gt;memoize&lt;/code&gt; 는 주어진 튜플에 대해 항상 동일한 결과를 반환한다고 가정 하기 때문 입니다. 그러나 &lt;code&gt;memoize&lt;/code&gt; 는 때로는 불순한 기능을 메모하는 것이 유용하기 때문에이를 강제하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1e1d246b5e426f01e5402235b114a3eca1d4204f" translate="yes" xml:space="preserve">
          <source>Tells whether a type &lt;code&gt;T&lt;/code&gt; is statically allowed for storage inside a &lt;code&gt;VariantN&lt;/code&gt; object by looking &lt;code&gt;T&lt;/code&gt; up in &lt;code&gt;AllowedTypes&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;AllowedTypes&lt;/code&gt; 에서 &lt;code&gt;T&lt;/code&gt; up을 검색 하여 유형 &lt;code&gt;T&lt;/code&gt; 가 &lt;code&gt;VariantN&lt;/code&gt; 객체 내부에 저장되도록 정적으로 허용 되는지 여부를 알려줍니다 .</target>
        </trans-unit>
        <trans-unit id="ea6c03461dc3a543514f149ca6bb793d0a9e158a" translate="yes" xml:space="preserve">
          <source>Telugu</source>
          <target state="translated">Telugu</target>
        </trans-unit>
        <trans-unit id="3ec1ae061c27325c7ecb543adf91235e22cbc9ed" translate="yes" xml:space="preserve">
          <source>Template</source>
          <target state="translated">Template</target>
        </trans-unit>
        <trans-unit id="e6f1ec42ae0af9f2599a77525cba82e65dfc5e18" translate="yes" xml:space="preserve">
          <source>Template API</source>
          <target state="translated">템플릿 API</target>
        </trans-unit>
        <trans-unit id="e522f15415ec8661bc2e6e1609fc4f30a391c0b7" translate="yes" xml:space="preserve">
          <source>Template API CRC32 implementation. See &lt;code&gt;std.digest&lt;/code&gt; for differences between template and OOP API.</source>
          <target state="translated">템플릿 API CRC32 구현. 템플릿과 OOP API의 차이점에 대해서는 &lt;code&gt;std.digest&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8437ae9d6af39ff3da2624003e6f14a20f425560" translate="yes" xml:space="preserve">
          <source>Template API CRC64-ECMA implementation. See &lt;code&gt;std.digest.digest&lt;/code&gt; for differences between template and OOP API.</source>
          <target state="translated">템플릿 API CRC64-ECMA 구현 템플릿과 OOP API의 차이점에 대해서는 &lt;code&gt;std.digest.digest&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8e42beabacb6072d0abaf212b35f9041a76331e7" translate="yes" xml:space="preserve">
          <source>Template API CRC64-ECMA implementation. See &lt;code&gt;std.digest&lt;/code&gt; for differences between template and OOP API.</source>
          <target state="translated">템플릿 API CRC64-ECMA 구현. 템플릿과 OOP API의 차이점 은 &lt;code&gt;std.digest&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c9cf433918e6809484068ba2a4633144d8783e12" translate="yes" xml:space="preserve">
          <source>Template API CRC64-ISO implementation. See &lt;code&gt;std.digest.digest&lt;/code&gt; for differences between template and OOP API.</source>
          <target state="translated">템플릿 API CRC64-ISO 구현. 템플릿과 OOP API의 차이점에 대해서는 &lt;code&gt;std.digest.digest&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="90d0a62e41df3264404eee56347b930553948824" translate="yes" xml:space="preserve">
          <source>Template API CRC64-ISO implementation. See &lt;code&gt;std.digest&lt;/code&gt; for differences between template and OOP API.</source>
          <target state="translated">템플릿 API CRC64-ISO 구현. 템플릿과 OOP API의 차이점 은 &lt;code&gt;std.digest&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="377ef92c355bfb9804e95e132cfdf2caf2a2cf42" translate="yes" xml:space="preserve">
          <source>Template API HMAC implementation.  This implements an HMAC over the digest H. If H doesn't provide information about the block size, it can be supplied explicitly using the second overload.  This type conforms to &lt;a href=&quot;std_digest#isDigest&quot;&gt;&lt;code&gt;std.digest.isDigest&lt;/code&gt;&lt;/a&gt;.  Compute HMAC over an input string</source>
          <target state="translated">템플릿 API HMAC 구현. 다이제스트 H에 HMAC를 구현합니다. H가 블록 크기에 대한 정보를 제공하지 않으면 두 번째 오버로드를 사용하여 명시 적으로 제공 할 수 있습니다. 이 유형은 &lt;a href=&quot;std_digest#isDigest&quot;&gt; &lt;code&gt;std.digest.isDigest&lt;/code&gt; 를&lt;/a&gt; 준수합니다 . 입력 문자열을 통한 HMAC 계산</target>
        </trans-unit>
        <trans-unit id="80c37626c0104765b3f472dfcf7c74d67406698a" translate="yes" xml:space="preserve">
          <source>Template API MD5 implementation. See &lt;code&gt;std.digest&lt;/code&gt; for differences between template and OOP API.</source>
          <target state="translated">템플릿 API MD5 구현. 템플릿과 OOP API의 차이점에 대해서는 &lt;code&gt;std.digest&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9baa26a4e441be15d1a0026335d4968924c76983" translate="yes" xml:space="preserve">
          <source>Template API RIPEMD160 implementation. See &lt;code&gt;std.digest&lt;/code&gt; for differences between template and OOP API.</source>
          <target state="translated">템플릿 API RIPEMD160 구현. 템플릿과 OOP API의 차이점에 대해서는 &lt;code&gt;std.digest&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3b1b330b49ad8ca244de89c95f975aa04b55c181" translate="yes" xml:space="preserve">
          <source>Template API SHA1/SHA2 implementation. Supports: SHA-1, SHA-224, SHA-256, SHA-384, SHA-512, SHA-512/224 and SHA-512/256.</source>
          <target state="translated">템플릿 API SHA1 / SHA2 구현 지원 : SHA-1, SHA-224, SHA-256, SHA-384, SHA-512, SHA-512 / 224 및 SHA-512 / 256.</target>
        </trans-unit>
        <trans-unit id="f62ed7169159e611b14c3e7949b6b6e1a7e655cd" translate="yes" xml:space="preserve">
          <source>Template Alias Parameters</source>
          <target state="translated">템플릿 별명 매개 변수</target>
        </trans-unit>
        <trans-unit id="d18303084ca65e4a94354ae1840dc40df28605aa" translate="yes" xml:space="preserve">
          <source>Template Constraints</source>
          <target state="translated">템플릿 제약</target>
        </trans-unit>
        <trans-unit id="fb7a9c95d4ed67c8b1553e4381f99167b917a11f" translate="yes" xml:space="preserve">
          <source>Template Constructors</source>
          <target state="translated">템플릿 생성자</target>
        </trans-unit>
        <trans-unit id="38e266fe765270ed7c964e156080fde6579d7894" translate="yes" xml:space="preserve">
          <source>Template Instance Names have the types and values of its parameters encoded into it:</source>
          <target state="translated">템플릿 인스턴스 이름에는 매개 변수의 유형과 값이 인코딩되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="30f85684a878aa9af8afa40283325beae87c4aa0" translate="yes" xml:space="preserve">
          <source>Template Mixins</source>
          <target state="translated">템플릿 믹스 인</target>
        </trans-unit>
        <trans-unit id="bc3b3525b364d27d5b3900862241bda1d3596e67" translate="yes" xml:space="preserve">
          <source>Template Parameter Default Values</source>
          <target state="translated">템플릿 매개 변수 기본값</target>
        </trans-unit>
        <trans-unit id="eb06de1f01f060cf9430e79280ee0699d4203e25" translate="yes" xml:space="preserve">
          <source>Template Sequence Parameters</source>
          <target state="translated">템플릿 시퀀스 파라미터</target>
        </trans-unit>
        <trans-unit id="e7ca209f8d14b1abb05f80fa798822ceaa811571" translate="yes" xml:space="preserve">
          <source>Template This Parameters</source>
          <target state="translated">이 매개 변수 템플릿</target>
        </trans-unit>
        <trans-unit id="82084cfe35a73bcd4625e0721e2f57a23701a271" translate="yes" xml:space="preserve">
          <source>Template Type Parameters</source>
          <target state="translated">템플릿 유형 매개 변수</target>
        </trans-unit>
        <trans-unit id="779713d88fde73c5e64b672f1774ec90dca0ab03" translate="yes" xml:space="preserve">
          <source>Template Value Parameters</source>
          <target state="translated">템플릿 값 매개 변수</target>
        </trans-unit>
        <trans-unit id="26171c395cd3bc136eb63e6249860cab45283f92" translate="yes" xml:space="preserve">
          <source>Template arguments not implicitly deduced can have default values:</source>
          <target state="translated">암시 적으로 추론되지 않은 템플릿 인수는 기본값을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d14578ab93cdc97bb3a362ef20b3ffe126a7918" translate="yes" xml:space="preserve">
          <source>Template arguments.</source>
          <target state="translated">템플릿 인수.</target>
        </trans-unit>
        <trans-unit id="19c8f3dce2a89300350e2d7666fb3e86f4a6b7f2" translate="yes" xml:space="preserve">
          <source>Template constraints can be used with aggregate types (structs, classes, unions). Constraints are effectively used with library module &quot;std.traits&quot;:</source>
          <target state="translated">템플릿 제약 조건은 집계 유형 (구조, 클래스, 공용체)과 함께 사용할 수 있습니다. 제약 조건은 라이브러리 모듈 &quot;std.traits&quot;와 함께 효과적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="bf64bd05317e164be7848210935f1949fa7269a4" translate="yes" xml:space="preserve">
          <source>Template constraints can be used with aggregate types (structs, classes, unions). Constraints are effectively used with library module &lt;a href=&quot;https://dlang.org/phobos/std_traits.html&quot;&gt;&lt;code&gt;std.traits&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">템플릿 제약 조건은 집계 형식 (구조, 클래스, 공용체)과 함께 사용할 수 있습니다. 제약 조건은 라이브러리 모듈 &lt;a href=&quot;https://dlang.org/phobos/std_traits.html&quot;&gt; &lt;code&gt;std.traits&lt;/code&gt; &lt;/a&gt; 와 함께 효과적으로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="1691afafe951d535cce0c8181934e0f030a369a1" translate="yes" xml:space="preserve">
          <source>Template features can be combined to produce some interesting effects, such as compile time evaluation of non-trivial functions. For example, a factorial template can be written:</source>
          <target state="translated">템플릿 기능을 결합하여 사소한 기능의 컴파일 시간 평가와 같은 흥미로운 효과를 얻을 수 있습니다. 예를 들어, 계승 템플릿을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ba9b580c30519089e0945b54f1c0ea578e0a06a" translate="yes" xml:space="preserve">
          <source>Template for implementing Base64 encoding and decoding.</source>
          <target state="translated">Base64 인코딩 및 디코딩을 구현하기위한 템플릿입니다.</target>
        </trans-unit>
        <trans-unit id="f6c583c1ff7413acce9779ce3bde7a23b883e82e" translate="yes" xml:space="preserve">
          <source>Template functions are useful for avoiding code duplication - instead of writing several copies of a function, each with a different parameter type, a single function template can be sufficient. For example:</source>
          <target state="translated">템플릿 함수는 코드 중복을 피하는 데 유용합니다. 각기 다른 매개 변수 유형을 가진 함수의 여러 복사본을 작성하는 대신 단일 함수 템플릿으로 충분할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ce9ed1b4180abeab3ceea25b15bb1a299cbee42c" translate="yes" xml:space="preserve">
          <source>Template functions, auto functions, nested functions and lambdas can deduce the &lt;code&gt;return scope&lt;/code&gt; attribute.</source>
          <target state="translated">템플릿 함수, 자동 함수, 중첩 함수 및 람다는 &lt;code&gt;return scope&lt;/code&gt; 속성을 추론 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a5e7b8c0a5e4e1f334cd544200e05d17c0c0f0ab" translate="yes" xml:space="preserve">
          <source>Template functions, auto functions, nested functions and lambdas can deduce the &lt;code&gt;return&lt;/code&gt; attribute.</source>
          <target state="translated">템플릿 함수, 자동 함수, 중첩 함수 및 람다는 &lt;code&gt;return&lt;/code&gt; 속성을 추론 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="25478b27ac38cf28dffdb029b491087b8937cf14" translate="yes" xml:space="preserve">
          <source>Template implementation.</source>
          <target state="translated">템플릿 구현.</target>
        </trans-unit>
        <trans-unit id="dae7857caeb9fd343ac0c8dc8bd3c01ab768ee59" translate="yes" xml:space="preserve">
          <source>Template instance names</source>
          <target state="translated">템플릿 인스턴스 이름</target>
        </trans-unit>
        <trans-unit id="4498c6e2d0d9903363598d28a52a34b1e0d3c903" translate="yes" xml:space="preserve">
          <source>Template instantiation</source>
          <target state="translated">템플릿 인스턴스화</target>
        </trans-unit>
        <trans-unit id="e148426eaf0fc75b319929a7514c305716d2cf43" translate="yes" xml:space="preserve">
          <source>Template names</source>
          <target state="translated">템플릿 이름</target>
        </trans-unit>
        <trans-unit id="93a56d0fe88789d1d0c70b3ee943a36512557c8d" translate="yes" xml:space="preserve">
          <source>Template parameter defaults are the value or type to use for the</source>
          <target state="translated">템플릿 매개 변수 기본값은</target>
        </trans-unit>
        <trans-unit id="c042a73bca6c8bc4a4a5a2fd8b459e9ee19ba60f" translate="yes" xml:space="preserve">
          <source>Template parameter specializations constrain the values or types the</source>
          <target state="translated">템플릿 매개 변수 전문화는 값 또는 유형을 제한합니다.</target>
        </trans-unit>
        <trans-unit id="f1b7c3f55de7f3a6405e167ee5a977c3f7b9a92e" translate="yes" xml:space="preserve">
          <source>Template parameter; the type of the allocated buffer, and the type returned. Defaults to &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">템플릿 파라미터; 할당 된 버퍼의 유형 및 반환 된 유형 기본값은 &lt;code&gt;string&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a5585272334e1084961cfa161efdc30cdbc9f449" translate="yes" xml:space="preserve">
          <source>Template parameters can be types, values, symbols, or sequences. Types can be any type. Value parameters must be of an integral type, floating point type, or string type and specializations for them must resolve to an integral constant, floating point constant, null, or a string literal. Symbols can be any non-local symbol. Sequences can contain zero or more types, values or symbols.</source>
          <target state="translated">템플릿 매개 변수는 유형, 값, 기호 또는 시퀀스 일 수 있습니다. 유형은 모든 유형이 될 수 있습니다. 값 매개 변수는 정수 유형, 부동 소수점 유형 또는 문자열 유형이어야하며 매개 변수에 대한 전문화는 정수, 부동 소수점 상수, 널 또는 문자열 리터럴로 해석되어야합니다. 심볼은 로컬이 아닌 심볼 일 수 있습니다. 시퀀스에는 0 개 이상의 유형, 값 또는 기호가 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3053d10b710a4345e1d2a806a5a0d892919d438c" translate="yes" xml:space="preserve">
          <source>Template parameters.</source>
          <target state="translated">템플릿 매개 변수.</target>
        </trans-unit>
        <trans-unit id="f2eaecce2004457caafb0a566e6258478e0c81e3" translate="yes" xml:space="preserve">
          <source>Template predicates</source>
          <target state="translated">템플리트 술어</target>
        </trans-unit>
        <trans-unit id="3c6f35922df22ba3979c846bfb66fd5f925df11c" translate="yes" xml:space="preserve">
          <source>Template value parameter types can be any type which can be statically initialized at compile time. Template value arguments can be integer values, floating point values, nulls, string values, array literals of template value arguments, associative array literals of template value arguments, or struct literals of template value arguments.</source>
          <target state="translated">템플릿 값 매개 변수 유형은 컴파일 타임에 정적으로 초기화 될 수있는 모든 유형이 될 수 있습니다. 템플릿 값 인수는 정수 값, 부동 소수점 값, null, 문자열 값, 템플릿 값 인수의 배열 리터럴, 템플릿 값 인수의 연관 배열 리터럴 또는 템플릿 값 인수의 구조체 리터럴 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4f76ae41610f265b87249bfa826fc772c21ffbd" translate="yes" xml:space="preserve">
          <source>Template with arity smaller than or equal to Template</source>
          <target state="translated">아리 티지가 템플릿보다 작거나 같은 템플릿</target>
        </trans-unit>
        <trans-unit id="3db96bd3c4b157efb5c6bcf06af65bf6679fe917" translate="yes" xml:space="preserve">
          <source>TemplateArgumentList</source>
          <target state="translated">TemplateArgumentList</target>
        </trans-unit>
        <trans-unit id="a6a7d2669effca80a1c7fac717de9a8b2a82ba1a" translate="yes" xml:space="preserve">
          <source>TemplateDeclaration</source>
          <target state="translated">TemplateDeclaration</target>
        </trans-unit>
        <trans-unit id="9029a1aca4f28b513baec9b6439e6636b063cf0c" translate="yes" xml:space="preserve">
          <source>TemplateDeclaration &lt;strong id=&quot;getFuncTemplateDecl&quot;&gt;getFuncTemplateDecl&lt;/strong&gt;(Dsymbol s);</source>
          <target state="translated">TemplateDeclaration &lt;strong id=&quot;getFuncTemplateDecl&quot;&gt;getFuncTemplateDecl&lt;/strong&gt; (심볼 s);</target>
        </trans-unit>
        <trans-unit id="6517815fe52a5a1aa2089d12b1bbf085f56454ad" translate="yes" xml:space="preserve">
          <source>TemplateInstance</source>
          <target state="translated">TemplateInstance</target>
        </trans-unit>
        <trans-unit id="3d1fc910d66b4cf59b41a83bd1f011148439a47f" translate="yes" xml:space="preserve">
          <source>TemplateInstance &lt;code&gt;ti&lt;/code&gt;</source>
          <target state="translated">TemplateInstance &lt;code&gt;ti&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="32f6a07ecefd7064d208c91c6d529d1eabf6fae0" translate="yes" xml:space="preserve">
          <source>TemplateInstance &lt;strong id=&quot;addInstance&quot;&gt;addInstance&lt;/strong&gt;(TemplateInstance ti);</source>
          <target state="translated">TemplateInstance &lt;strong id=&quot;addInstance&quot;&gt;addInstance&lt;/strong&gt; (TemplateInstance ti);</target>
        </trans-unit>
        <trans-unit id="5626cce6b123c95bbf147668ea277a06194dbd7b" translate="yes" xml:space="preserve">
          <source>TemplateInstance &lt;strong id=&quot;findExistingInstance&quot;&gt;findExistingInstance&lt;/strong&gt;(TemplateInstance tithis, Expressions* fargs);</source>
          <target state="translated">TemplateInstance &lt;strong id=&quot;findExistingInstance&quot;&gt;findExistingInstance&lt;/strong&gt; (TemplateInstance tithis, Expressions * fargs);</target>
        </trans-unit>
        <trans-unit id="fdcd96c0f2459103878b2413ec2c601fc1498f4a" translate="yes" xml:space="preserve">
          <source>TemplateMixin</source>
          <target state="translated">TemplateMixin</target>
        </trans-unit>
        <trans-unit id="b981d77c6daa310cf9f7bc1dffb15d121423d2f9" translate="yes" xml:space="preserve">
          <source>TemplateMixinDeclaration</source>
          <target state="translated">TemplateMixinDeclaration</target>
        </trans-unit>
        <trans-unit id="1098903e5f4fc2ff49f206b24ec3f9c1c949a0da" translate="yes" xml:space="preserve">
          <source>TemplateParameter</source>
          <target state="translated">TemplateParameter</target>
        </trans-unit>
        <trans-unit id="6b0a43baab11f444c6db7f8fbb993842fcd75ba0" translate="yes" xml:space="preserve">
          <source>TemplateParameter &lt;code&gt;tp&lt;/code&gt;</source>
          <target state="translated">TemplateParameter &lt;code&gt;tp&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a724f289f948ed94a3864202a97f7192ac4bdd96" translate="yes" xml:space="preserve">
          <source>TemplateParameterList</source>
          <target state="translated">TemplateParameterList</target>
        </trans-unit>
        <trans-unit id="583de77cc39af83d745b866a4f4097143e9876ee" translate="yes" xml:space="preserve">
          <source>TemplateParameters* &lt;code&gt;parameters&lt;/code&gt;</source>
          <target state="translated">TemplateParameters * &lt;code&gt;parameters&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f1918bba11e5a6f5b4fc7ad6ef48b8652a0887d7" translate="yes" xml:space="preserve">
          <source>TemplateParameters* &lt;code&gt;tparams&lt;/code&gt;</source>
          <target state="translated">TemplateParameters * &lt;code&gt;tparams&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8d9b2f66638d335347804a4c0613b67636525619" translate="yes" xml:space="preserve">
          <source>TemplateSequenceParameter</source>
          <target state="translated">TemplateSequenceParameter</target>
        </trans-unit>
        <trans-unit id="991a882d2c6a34560908a425e97dee08f5240a1c" translate="yes" xml:space="preserve">
          <source>TemplateThisParameter</source>
          <target state="translated">TemplateThisParameter</target>
        </trans-unit>
        <trans-unit id="fa08af40a67e00ef14408a29a123247531c65448" translate="yes" xml:space="preserve">
          <source>TemplateTupleParameter &lt;strong id=&quot;isVariadic&quot;&gt;isVariadic&lt;/strong&gt;();</source>
          <target state="translated">TemplateTupleParameter &lt;strong id=&quot;isVariadic&quot;&gt;isVariadic&lt;/strong&gt; ();</target>
        </trans-unit>
        <trans-unit id="f25b700ed9f092123a43acb205a6869342cf9dd6" translate="yes" xml:space="preserve">
          <source>Templates</source>
          <target state="translated">Templates</target>
        </trans-unit>
        <trans-unit id="d492087ea67943dc74c840e6365eee707931cb08" translate="yes" xml:space="preserve">
          <source>Templates are D's approach to generic programming. Templates are defined with a</source>
          <target state="translated">템플릿은 일반 프로그래밍에 대한 D의 접근 방식입니다. 템플릿은</target>
        </trans-unit>
        <trans-unit id="0831437711dff1dd4780cf1794113d3fdb3f80b9" translate="yes" xml:space="preserve">
          <source>Templates are explicitly instantiated with:</source>
          <target state="translated">템플릿은 다음과 같이 명시 적으로 인스턴스화됩니다.</target>
        </trans-unit>
        <trans-unit id="feb605d755d6a50ca7339b029a5943f74ea943f9" translate="yes" xml:space="preserve">
          <source>Templates can be used to form constructors for classes and structs.</source>
          <target state="translated">템플릿은 클래스와 구조체의 생성자를 구성하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="70f39a950e78ed5adbca12f692738cfb53d2d504" translate="yes" xml:space="preserve">
          <source>Templates cannot be used to add non-static fields or virtual functions to classes or interfaces. For example:</source>
          <target state="translated">비 정적 필드 또는 가상 함수를 클래스 나 인터페이스에 추가하는 데 템플릿을 사용할 수 없습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1f6b57f6b00b0efba650f385fe51544b694a5cc2" translate="yes" xml:space="preserve">
          <source>Templates may be specialized for particular types of arguments by following the template parameter identifier with a : and the specialized type. For example:</source>
          <target state="translated">템플릿 매개 변수 식별자 뒤에 : 및 특수 유형을 지정하여 특정 유형의 인수에 대해 템플릿을 특수화 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="245b3c3a28c4f221260e8b2fc590aa377be27a3f" translate="yes" xml:space="preserve">
          <source>Templates to manipulate &lt;a href=&quot;https://dlang.org/spec/template.html#variadic-templates&quot;&gt;template parameter sequences&lt;/a&gt; (also known as</source>
          <target state="translated">템플릿 &lt;a href=&quot;https://dlang.org/spec/template.html#variadic-templates&quot;&gt;매개 변수 시퀀스&lt;/a&gt; 를 조작하기위한 템플릿 (</target>
        </trans-unit>
        <trans-unit id="78e0050e55634b09275bdf582f1537bb23a50bfb" translate="yes" xml:space="preserve">
          <source>Templates which extract information about types and symbols at compile time.</source>
          <target state="translated">컴파일시 유형 및 기호에 대한 정보를 추출하는 템플릿.</target>
        </trans-unit>
        <trans-unit id="76d1df55eaac0e27ead23332cd68424965e0b265" translate="yes" xml:space="preserve">
          <source>Temporary closure variable.</source>
          <target state="translated">임시 폐쇄 변수.</target>
        </trans-unit>
        <trans-unit id="a030983d955bce3f66592d4d8fed011c5c3f0b4f" translate="yes" xml:space="preserve">
          <source>Temporary hack to initialize a dt_t* for C.</source>
          <target state="translated">C에 대한 dt_t *를 초기화하기위한 임시 해킹</target>
        </trans-unit>
        <trans-unit id="c4ebc55b69363bbb720e6062538fba3f91d7cabe" translate="yes" xml:space="preserve">
          <source>Temporary variable to enable / disable deprecation of comma expression depending on the context. Since most constructor calls are rewritting, the only place where false will be passed will be from the parser.</source>
          <target state="translated">컨텍스트에 따라 쉼표 표현식의 사용 중단을 활성화 / 비활성화하는 임시 변수입니다. 대부분의 생성자 호출은 다시 작성되므로 false가 전달되는 유일한 위치는 파서에서 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c88ab2b908a10ea30dbe26e3cf3a97fa4e5eb4bd" translate="yes" xml:space="preserve">
          <source>Terminal_Punctuation</source>
          <target state="translated">Terminal_Punctuation</target>
        </trans-unit>
        <trans-unit id="aa9f431bdd778a9da48093314c8721383c9ae18d" translate="yes" xml:space="preserve">
          <source>Terminate list package.</source>
          <target state="translated">목록 패키지를 종료합니다.</target>
        </trans-unit>
        <trans-unit id="265d2f5524a2ac16dca5c32fabd93e669260517c" translate="yes" xml:space="preserve">
          <source>Terminate use of druntime.</source>
          <target state="translated">druntime 사용을 종료합니다.</target>
        </trans-unit>
        <trans-unit id="41856428796ae48815fa332eab1db153dc019979" translate="yes" xml:space="preserve">
          <source>Terminates the runtime. This call is to be used in instances where the standard program termination process will not be not executed. This is most often in shared libraries or in libraries linked to a C program. If the runtime was not successfully initialized the function returns false.</source>
          <target state="translated">런타임을 종료합니다. 이 호출은 표준 프로그램 종료 프로세스가 실행되지 않는 경우에 사용됩니다. 이것은 대부분 공유 라이브러리 또는 C 프로그램에 연결된 라이브러리에 있습니다. 런타임이 성공적으로 초기화되지 않은 경우 함수는 false를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="56cb46ccab827174a1e1b86effcb3d5d6cefbd35" translate="yes" xml:space="preserve">
          <source>Terminates the thread module. No other thread routine may be called afterwards.</source>
          <target state="translated">스레드 모듈을 종료합니다. 이후에는 다른 스레드 루틴을 호출 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b932645dfbe2f4cc7e54421fac789485495785ed" translate="yes" xml:space="preserve">
          <source>Termination of lifetime of temporaries does not obey the customary scoping rules and is defined as follows:</source>
          <target state="translated">임시 수명의 종료는 관례 범위 지정 규칙을 따르지 않으며 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="54b9edf1c19c21867b1c6f5a0d516af236d00cc3" translate="yes" xml:space="preserve">
          <source>Terminator &lt;code&gt;terminator&lt;/code&gt;</source>
          <target state="translated">터미네이터 &lt;code&gt;terminator&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="21d278837034557e7a9b46210d42d6e7b8075142" translate="yes" xml:space="preserve">
          <source>Terminology</source>
          <target state="translated">Terminology</target>
        </trans-unit>
        <trans-unit id="e7d472b76d10887c103dda92fc35b9bb978b5299" translate="yes" xml:space="preserve">
          <source>Ternary &lt;strong id=&quot;empty&quot;&gt;empty&lt;/strong&gt;();</source>
          <target state="translated">삼항 &lt;strong id=&quot;empty&quot;&gt;빈&lt;/strong&gt; ();</target>
        </trans-unit>
        <trans-unit id="5408a6547343b9801c7549a99e5188840858fa05" translate="yes" xml:space="preserve">
          <source>Ternary &lt;strong id=&quot;opBinary&quot;&gt;opBinary&lt;/strong&gt;(string s)(Ternary rhs)</source>
          <target state="translated">3 차 &lt;strong id=&quot;opBinary&quot;&gt;opBinary&lt;/strong&gt; (문자열 s) (Ternary rhs)</target>
        </trans-unit>
        <trans-unit id="61a734dfd14bc5bb5ac25f18ac9cb8682858064c" translate="yes" xml:space="preserve">
          <source>Ternary &lt;strong id=&quot;opBinary&quot;&gt;opBinary&lt;/strong&gt;(string s)(bool rhs)</source>
          <target state="translated">삼항 &lt;strong id=&quot;opBinary&quot;&gt;opBinary&lt;/strong&gt; (string s) (bool rhs)</target>
        </trans-unit>
        <trans-unit id="abd25e300e86acc270bc7f7f32a0f16e698447aa" translate="yes" xml:space="preserve">
          <source>Ternary &lt;strong id=&quot;opUnary&quot;&gt;opUnary&lt;/strong&gt;(string s)()</source>
          <target state="translated">삼항 &lt;strong id=&quot;opUnary&quot;&gt;opUnary&lt;/strong&gt; (문자열 s) ()</target>
        </trans-unit>
        <trans-unit id="380135dec6752a5219efd128ceee397c71493e97" translate="yes" xml:space="preserve">
          <source>Ternary &lt;strong id=&quot;owns&quot;&gt;owns&lt;/strong&gt;(void[] b);</source>
          <target state="translated">3 차 &lt;strong id=&quot;owns&quot;&gt;소유&lt;/strong&gt; (void [] b);</target>
        </trans-unit>
        <trans-unit id="5fe840824f09b55cc8873c5c40f4982d7db99dfc" translate="yes" xml:space="preserve">
          <source>Ternary &lt;strong id=&quot;owns&quot;&gt;owns&lt;/strong&gt;(void[]);</source>
          <target state="translated">3 차 &lt;strong id=&quot;owns&quot;&gt;소유&lt;/strong&gt; (void []);</target>
        </trans-unit>
        <trans-unit id="c9e4ebe582a67a767403a28daa93cef99c8de556" translate="yes" xml:space="preserve">
          <source>Ternary &lt;strong id=&quot;resolveInternalPointer&quot;&gt;resolveInternalPointer&lt;/strong&gt;(const void* p, ref void[] result);</source>
          <target state="translated">3 차 &lt;strong id=&quot;resolveInternalPointer&quot;&gt;resolveInternalPointer&lt;/strong&gt; (const void * p, ref void [] 결과);</target>
        </trans-unit>
        <trans-unit id="807671195e85d5bec2aa478b814e406eda646d28" translate="yes" xml:space="preserve">
          <source>Ternary type with three truth values:</source>
          <target state="translated">세 가지 진리 값을 가진 삼항 유형 :</target>
        </trans-unit>
        <trans-unit id="640ab2bae07bedc4c163f679a746f7ab7fb5d1fa" translate="yes" xml:space="preserve">
          <source>Test</source>
          <target state="translated">Test</target>
        </trans-unit>
        <trans-unit id="a76dd0a3dd495aa45fe2a39614c44782afcb01ca" translate="yes" xml:space="preserve">
          <source>Test For Auto-Commit Mode</source>
          <target state="translated">자동 커밋 모드 테스트</target>
        </trans-unit>
        <trans-unit id="c05597ed0dba53dda21d6b294858039879f34b2b" translate="yes" xml:space="preserve">
          <source>Test To See If The Library Is Threadsafe</source>
          <target state="translated">라이브러리가 스레드로부터 안전한지 테스트</target>
        </trans-unit>
        <trans-unit id="f4260e1148419ceb90540c404dc73c9d27bb1bb8" translate="yes" xml:space="preserve">
          <source>Test an enum with default (consecutive) values</source>
          <target state="translated">기본 (연속) 값으로 열거 형 테스트</target>
        </trans-unit>
        <trans-unit id="7c6eb409a640870d68be20ffb89dc0f97c36f86b" translate="yes" xml:space="preserve">
          <source>Test an enum with non-integral values</source>
          <target state="translated">비 적분 값으로 열거 형 테스트</target>
        </trans-unit>
        <trans-unit id="f4b150c2686c8f7e7ab220003a574d693a5d95e2" translate="yes" xml:space="preserve">
          <source>Test if &lt;code&gt;M&lt;/code&gt; is an UTF Matcher for ranges of &lt;code&gt;Char&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;M&lt;/code&gt; 이 &lt;code&gt;Char&lt;/code&gt; 범위의 UTF 매처 인지 테스트하십시오 .</target>
        </trans-unit>
        <trans-unit id="b5df7066b55b0c74120435614aa37ac6677d2d60" translate="yes" xml:space="preserve">
          <source>Test if Rng is a random-number generator. The overload taking a ElementType also makes sure that the Rng generates values of that type.</source>
          <target state="translated">Rng이 난수 생성기인지 테스트하십시오. ElementType을 사용하는 과부하는 Rng가 해당 유형의 값을 생성하도록합니다.</target>
        </trans-unit>
        <trans-unit id="c36e2d0840f1f824df374ea5595d9aff6c4e947f" translate="yes" xml:space="preserve">
          <source>Test if Rng is seedable. The overload taking a SeedType also makes sure that the Rng can be seeded with SeedType.</source>
          <target state="translated">Rng가 시드 가능한지 테스트하십시오. SeedType을 사용하는 과부하로 인해 Rng에 SeedType을 시드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="771271d8873c3b21a601bf2c675f90a9ccc0ffc3" translate="yes" xml:space="preserve">
          <source>Test if expression is a binary array op.</source>
          <target state="translated">expression이 이진 배열 op인지 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="172aaae7f6f97929a4cfc47c9d74eb4946f350af" translate="yes" xml:space="preserve">
          <source>Test if expression is a binary assignment array op.</source>
          <target state="translated">expression이 이진 할당 배열 op인지 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="9300c8ec9a186273606279dfa9449d5d455cf04a" translate="yes" xml:space="preserve">
          <source>Test if expression is a unary array op.</source>
          <target state="translated">expression이 단항 배열 op인지 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="0d5244f0d0c7df2a1da58431bfc78e379751a7b9" translate="yes" xml:space="preserve">
          <source>Test if operand is a valid array op operand.</source>
          <target state="translated">피연산자가 유효한 배열 op 피연산자인지 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="875918357eabc46eb0a1c92bac320980adb8c720" translate="yes" xml:space="preserve">
          <source>Test if this match object is empty.</source>
          <target state="translated">이 일치 오브젝트가 비어 있는지 테스트하십시오.</target>
        </trans-unit>
        <trans-unit id="df4149695689c92ee359aa248e67d88ff5ec18df" translate="yes" xml:space="preserve">
          <source>Test if this object doesn't contain any compiled pattern.</source>
          <target state="translated">이 객체에 컴파일 된 패턴이 없는지 테스트하십시오.</target>
        </trans-unit>
        <trans-unit id="3a1ea05315421beb7c90d273402899ae913a7b04" translate="yes" xml:space="preserve">
          <source>Test to see if two reals are the same. Regard NaN's as equivalent. Regard +0 and -0 as different.</source>
          <target state="translated">두 실수가 동일한 지 테스트합니다. NaN을 동등한 것으로 간주하십시오. +0과 -0을 다른 것으로 간주하십시오.</target>
        </trans-unit>
        <trans-unit id="c6494d0db23bcdb573d84113943853295de919f8" translate="yes" xml:space="preserve">
          <source>Test whether &lt;code&gt;this&lt;/code&gt; is equal to &lt;code&gt;o&lt;/code&gt;. The default implementation only compares by identity (using the &lt;code&gt;is&lt;/code&gt; operator). Generally, overrides for &lt;code&gt;opEquals&lt;/code&gt; should attempt to compare objects by their contents.</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; &lt;code&gt;o&lt;/code&gt; 와 같은지 테스트합니다 . 기본 구현은 ID로만 비교합니다 ( &lt;code&gt;is&lt;/code&gt; 연산자 사용). 일반적으로 &lt;code&gt;opEquals&lt;/code&gt; 에 대한 재정의는 내용으로 객체를 비교해야합니다.</target>
        </trans-unit>
        <trans-unit id="5e332eb1e9dbd61d5d3e51a56d3c413e1056f0ba" translate="yes" xml:space="preserve">
          <source>Test whether the type is &lt;code&gt;JSONType.null_&lt;/code&gt;</source>
          <target state="translated">형식이 &lt;code&gt;JSONType.null_&lt;/code&gt; 인지 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="32dc0f341af79e76ca913dc9eb0ce7bac1d243c2" translate="yes" xml:space="preserve">
          <source>Test. The range is left unaffected regardless of the result of test.</source>
          <target state="translated">테스트. 테스트 결과에 관계없이 범위는 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f97153344fc6b5fd92539a5489c67be660fa5094" translate="yes" xml:space="preserve">
          <source>Tested type, if null, returns false.</source>
          <target state="translated">테스트 된 유형이 널인 경우 false를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="c5d38ba7cbc400f9b209719e16e540214a64776c" translate="yes" xml:space="preserve">
          <source>Testing Interface</source>
          <target state="translated">테스트 인터페이스</target>
        </trans-unit>
        <trans-unit id="525b0e690ec5250557a58b08a062c12274d2c8b7" translate="yes" xml:space="preserve">
          <source>Testing Membership</source>
          <target state="translated">멤버십 테스트</target>
        </trans-unit>
        <trans-unit id="25a68a83b7176082f5e2ba19053a23bf236d5547" translate="yes" xml:space="preserve">
          <source>Testing that the compiler does this correctly is normally hackish and awkward, this enables efficient, direct, and simple testing.</source>
          <target state="translated">컴파일러가이 작업을 올바르게 수행하는지 테스트하는 것은 일반적으로 어렵고 어색하므로 효율적이고 직접적이며 간단한 테스트가 가능합니다.</target>
        </trans-unit>
        <trans-unit id="1c56215ea968cf5b1786a762d8686e735aad09cd" translate="yes" xml:space="preserve">
          <source>Tests and complements the bit.</source>
          <target state="translated">비트를 테스트하고 보완합니다.</target>
        </trans-unit>
        <trans-unit id="e5215a5973bd1ea3d7098ee9d049ca3355401493" translate="yes" xml:space="preserve">
          <source>Tests and resets (sets to 0) the bit.</source>
          <target state="translated">비트를 테스트하고 재설정합니다 (0으로 설정).</target>
        </trans-unit>
        <trans-unit id="2075b541b1f6f9a0cf3777e52df712b18587a41c" translate="yes" xml:space="preserve">
          <source>Tests and sets the bit.</source>
          <target state="translated">비트를 테스트하고 설정합니다.</target>
        </trans-unit>
        <trans-unit id="20b58f47c6fc10d3a84014b226d9ef1a294ea115" translate="yes" xml:space="preserve">
          <source>Tests for this functionality can be found in test/profile/src/profilegc.d</source>
          <target state="translated">이 기능에 대한 테스트는 test / profile / src / profilegc.d에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9449703c24169141bbb52227e05dcb6756b6aff1" translate="yes" xml:space="preserve">
          <source>Tests have proven that 20K is a very bad buffer size for uploads on Windows, while 16K for some odd reason performed a lot better. We do the ifndef check to allow this value to easier be changed at build time for those who feel adventurous. The practical minimum is about 400 bytes since libcurl uses a buffer of this size as a scratch area (unrelated to network send operations).</source>
          <target state="translated">테스트 결과 20K는 Windows 업로드에 매우 나쁜 버퍼 크기 인 반면, 16K는 이상한 이유로 성능이 훨씬 뛰어나다는 것이 입증되었습니다. 우리는 ifndef 검사를 수행하여 모험을 느끼는 사람들을 위해 빌드 타임 에이 값을 쉽게 변경할 수 있습니다. libcurl이이 크기의 버퍼를 스크래치 영역 (네트워크 전송 작업과 관련이 없음)으로 사용하기 때문에 실제 최소값은 약 400 바이트입니다.</target>
        </trans-unit>
        <trans-unit id="7b9ef0e0de0e0d2ca2aef3f77f084bb252817141" translate="yes" xml:space="preserve">
          <source>Tests if &lt;code&gt;T&lt;/code&gt; is a pair of integers that implicitly convert to &lt;code&gt;V&lt;/code&gt;. The following code must compile for any pair &lt;code&gt;T&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 가 암시 적으로 &lt;code&gt;V&lt;/code&gt; 로 변환되는 정수 쌍 인지 테스트합니다 . 다음 코드는 모든 쌍 &lt;code&gt;T&lt;/code&gt; 에 대해 컴파일해야합니다 .</target>
        </trans-unit>
        <trans-unit id="8c8c256b6a901137e3b17d0d394473f1bf0010ea" translate="yes" xml:space="preserve">
          <source>Tests if T is some kind a set of code points. Intended for template constraints.</source>
          <target state="translated">T가 일종의 코드 포인트인지 테스트합니다. 템플릿 제약 조건을위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="411bf491c2bca7ef9ade77af4f87a2c548c0bdbb" translate="yes" xml:space="preserve">
          <source>Tests if a given range has the &lt;code&gt;length&lt;/code&gt; attribute.</source>
          <target state="translated">주어진 범위에 &lt;code&gt;length&lt;/code&gt; 속성 이 있는지 테스트 합니다.</target>
        </trans-unit>
        <trans-unit id="c1e815d9ade99ef4137d6edf65d9041c8257f49b" translate="yes" xml:space="preserve">
          <source>Tests if a given range is an</source>
          <target state="translated">주어진 범위가</target>
        </trans-unit>
        <trans-unit id="bde4f156e05ca670bc0e67e4a240e0963bde7076" translate="yes" xml:space="preserve">
          <source>Tests if a given range supports the array slicing operation &lt;code&gt; R[x .. y]&lt;/code&gt;.</source>
          <target state="translated">지정된 범위가 배열 슬라이싱 작업 &lt;code&gt; R[x .. y]&lt;/code&gt; 지원하는지 테스트합니다 .</target>
        </trans-unit>
        <trans-unit id="ad84d76bbe9e61a1d8ded8b282719c6188de299e" translate="yes" xml:space="preserve">
          <source>Tests if a given range's elements can be moved around using the primitives &lt;code&gt;moveFront&lt;/code&gt;, &lt;code&gt;moveBack&lt;/code&gt;, or &lt;code&gt;moveAt&lt;/code&gt;.</source>
          <target state="translated">기본 요소 &lt;code&gt;moveFront&lt;/code&gt; , &lt;code&gt;moveBack&lt;/code&gt; 또는 &lt;code&gt;moveAt&lt;/code&gt; 를 사용하여 지정된 범위의 요소를 이동할 수 있는지 테스트합니다 .</target>
        </trans-unit>
        <trans-unit id="8d793f3a6e7c2e95eb378beac167385719ab59f4" translate="yes" xml:space="preserve">
          <source>Tests if a range is a forward range with elements that can be passed by reference and have their address taken.</source>
          <target state="translated">범위가 참조로 전달되고 해당 주소를 가질 수있는 요소가있는 순방향 범위인지 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="e6eb69ba4d2881e64e415a05071a9f103fe521a9" translate="yes" xml:space="preserve">
          <source>Tests if a range is a forward range with mutable elements.</source>
          <target state="translated">범위가 변경 가능한 요소가있는 순방향 범위인지 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="3514cf116bc5ed9d238a3b0f2c416cbf1406ecde" translate="yes" xml:space="preserve">
          <source>Tests if a range is a forward range with swappable elements.</source>
          <target state="translated">범위가 교체 가능한 요소가있는 순방향 범위인지 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="7f3207abc4ab79cdb9c483585f3e941b9bfaa437" translate="yes" xml:space="preserve">
          <source>Tests if dchar &lt;code&gt;ch&lt;/code&gt; is always allowed (Quick_Check=YES) in normalization form &lt;code&gt;norm&lt;/code&gt;.</source>
          <target state="translated">정규화 형식 &lt;code&gt;norm&lt;/code&gt; 에서 dchar &lt;code&gt;ch&lt;/code&gt; 가 항상 허용되는지 (Quick_Check = YES) 테스트합니다 .</target>
        </trans-unit>
        <trans-unit id="befffce91c09f40925fffacf854b40c946df8776" translate="yes" xml:space="preserve">
          <source>Tests if something is a</source>
          <target state="translated">무언가가 있는지 테스트</target>
        </trans-unit>
        <trans-unit id="8d6f89518da90279816a90c9471e395bd384796c" translate="yes" xml:space="preserve">
          <source>Tests if something is an</source>
          <target state="translated">무언가가 있는지 테스트</target>
        </trans-unit>
        <trans-unit id="0e1c0aed1d62ba9121fe6b94c90661bd5940a3af" translate="yes" xml:space="preserve">
          <source>Tests the bit. (No longer an intrisic - the compiler recognizes the patterns in the body.)</source>
          <target state="translated">비트를 테스트합니다. (더 이상 흥미롭지 않습니다. 컴파일러는 본문의 패턴을 인식합니다.)</target>
        </trans-unit>
        <trans-unit id="f4f4ed66a37a54d3a46278ee76a6c98108f32780" translate="yes" xml:space="preserve">
          <source>Tests the presence of code point &lt;code&gt;val&lt;/code&gt; in this set.</source>
          <target state="translated">이 세트 에 코드 포인트 &lt;code&gt;val&lt;/code&gt; 이 있는지 테스트합니다 .</target>
        </trans-unit>
        <trans-unit id="de8256fe3c8079a8a7b38b1ce5150ffcc1923b62" translate="yes" xml:space="preserve">
          <source>Tests the presence of codepoint &lt;code&gt;ch&lt;/code&gt; in this set, the same as &lt;a href=&quot;#opIndex&quot;&gt;&lt;code&gt;opIndex&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 세트에있는 코드 포인트 &lt;code&gt;ch&lt;/code&gt; 의 존재를 테스트합니다 ( &lt;a href=&quot;#opIndex&quot;&gt; &lt;code&gt;opIndex&lt;/code&gt; &lt;/a&gt; 와 동일) .</target>
        </trans-unit>
        <trans-unit id="3f2f444fc7b5cd93b5daa924863d3256099d8d1c" translate="yes" xml:space="preserve">
          <source>Tests wether a key can be found in an object.</source>
          <target state="translated">객체에서 키를 찾을 수 있는지 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="5596cf2178863d7426683848832032923843383b" translate="yes" xml:space="preserve">
          <source>Tests whether all given items satisfy a template predicate, i.e. evaluates to &lt;code&gt;F!(T[0]) &amp;amp;&amp;amp; F!(T[1]) &amp;amp;&amp;amp; ... &amp;amp;&amp;amp; F!(T[$ - 1])&lt;/code&gt;.</source>
          <target state="translated">주어진 모든 항목이 템플리트 술어를 만족하는지 테스트합니다. 즉, &lt;code&gt;F!(T[0]) &amp;amp;&amp;amp; F!(T[1]) &amp;amp;&amp;amp; ... &amp;amp;&amp;amp; F!(T[$ - 1])&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="0596e9e3cf69628efa950fe1bab0382b0dcf95bf" translate="yes" xml:space="preserve">
          <source>Tests whether any given items satisfy a template predicate, i.e. evaluates to &lt;code&gt;F!(T[0]) || F!(T[1]) || ... || F!(T[$ - 1])&lt;/code&gt;.</source>
          <target state="translated">주어진 항목이 템플리트 술어를 만족시키는 지 테스트합니다. 즉, &lt;code&gt;F!(T[0]) || F!(T[1]) || ... || F!(T[$ - 1])&lt;/code&gt; 평가합니다 (T [0]) || F! (T [1]) || ... || F! (T [$-1]) .</target>
        </trans-unit>
        <trans-unit id="686a7f263d59c9bc77e08d103e41e6b6097dc4c3" translate="yes" xml:space="preserve">
          <source>Tests whether the range &lt;code&gt;R&lt;/code&gt; has lvalue elements. These are defined as elements that can be passed by reference and have their address taken. The following code should compile for any range with lvalue elements.</source>
          <target state="translated">범위 &lt;code&gt;R&lt;/code&gt; 에 lvalue 요소가 있는지 테스트합니다 . 이들은 참조로 전달 될 수있는 요소로 정의되며 주소를 가져옵니다. 다음 코드는 lvalue 요소가있는 모든 범위에 대해 컴파일해야합니다.</target>
        </trans-unit>
        <trans-unit id="8bb780b7b4639e513de207eee9ca6ebb52198df1" translate="yes" xml:space="preserve">
          <source>Tests whether this thread is running.</source>
          <target state="translated">이 스레드가 실행 중인지 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="6949ea6aea1405f5da836774097338b86c14cca4" translate="yes" xml:space="preserve">
          <source>Tests whether this thread is the main thread, i.e. the thread that initialized the runtime</source>
          <target state="translated">이 스레드가 기본 스레드인지, 즉 런타임을 초기화 한 스레드인지 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="d1687cd16c0f03bc3b975bceb7e1a93532d5c303" translate="yes" xml:space="preserve">
          <source>Text &lt;code&gt;item&lt;/code&gt;</source>
          <target state="translated">텍스트 &lt;code&gt;item&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cfc7e26dd5428580328070e7a06fd7ebcbd47226" translate="yes" xml:space="preserve">
          <source>Text Emphasis</source>
          <target state="translated">텍스트 강조</target>
        </trans-unit>
        <trans-unit id="9740ffa930b7e0e5dc6d8da6cefed313549c2227" translate="yes" xml:space="preserve">
          <source>Text files: Either zero, or a value returned by &lt;a href=&quot;#tell&quot;&gt;&lt;code&gt;tell&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">텍스트 파일 : 어느 제로, 또는에 의해 반환 된 값 &lt;a href=&quot;#tell&quot;&gt; &lt;code&gt;tell&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4e0ff0523679bae8dae7ddd108d53202236baa1a" translate="yes" xml:space="preserve">
          <source>Text files: Shall necessarily be &lt;a href=&quot;core_stdc_stdio#SEEK_SET&quot;&gt;SEEK_SET&lt;/a&gt;.</source>
          <target state="translated">텍스트 파일 : 반드시 &lt;a href=&quot;core_stdc_stdio#SEEK_SET&quot;&gt;SEEK_SET&lt;/a&gt; 이어야 합니다.</target>
        </trans-unit>
        <trans-unit id="110569c98af1b7ca83bf2a55e559b2c9de2f1d74" translate="yes" xml:space="preserve">
          <source>Text inside these sections will be escaped according to the rules described above, then wrapped in a &lt;code&gt;&amp;amp;dollar;(DDOC_BACKQUOTED)&lt;/code&gt; macro. By default, this macro expands to be displayed as an inline text span, formatted as code.</source>
          <target state="translated">이 섹션 내부의 텍스트는 위에서 설명한 규칙에 따라 이스케이프 된 후 &lt;code&gt;&amp;amp;dollar;(DDOC_BACKQUOTED)&lt;/code&gt; 매크로 로 래핑됩니다 . 기본적으로이 매크로는 코드 형식으로 인라인 텍스트 범위로 표시되도록 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="550f1724580a5ba0d175052f9a3cc57e962a9a42" translate="yes" xml:space="preserve">
          <source>Text[] &lt;strong id=&quot;texts&quot;&gt;texts&lt;/strong&gt;;</source>
          <target state="translated">텍스트 [] &lt;strong id=&quot;texts&quot;&gt;텍스트&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="02878ee8de0350d99773d9bfa9119f737b2c432e" translate="yes" xml:space="preserve">
          <source>Tgt</source>
          <target state="translated">Tgt</target>
        </trans-unit>
        <trans-unit id="2f72bba0ea07edaf4c51d66fc5bb6bab86a6ccd2" translate="yes" xml:space="preserve">
          <source>Thaana</source>
          <target state="translated">Thaana</target>
        </trans-unit>
        <trans-unit id="c32767e0541fe7038ff8d87e7b8aed17f49474f8" translate="yes" xml:space="preserve">
          <source>Thai</source>
          <target state="translated">Thai</target>
        </trans-unit>
        <trans-unit id="2b049d162a2da7d605f5f60c67f0b2c875a54367" translate="yes" xml:space="preserve">
          <source>That means a particular care should be taken when passing an array of a type different than &lt;code&gt;size_t&lt;/code&gt;, firstly because its length should be a multiple of &lt;code&gt;size_t.sizeof&lt;/code&gt;, and secondly because how the bits are mapped:</source>
          <target state="translated">즉 , &lt;code&gt;size_t&lt;/code&gt; 가 아닌 다른 유형의 배열을 전달할 때는 특히 길이가 &lt;code&gt;size_t.sizeof&lt;/code&gt; 의 배수 여야 하고 두 번째로 비트가 매핑되는 방식이기 때문에 특별한주의를 기울여야합니다 .</target>
        </trans-unit>
        <trans-unit id="93ef0dd827103681fcee453b78be2ff14e1a261d" translate="yes" xml:space="preserve">
          <source>The</source>
          <target state="translated">The</target>
        </trans-unit>
        <trans-unit id="841034a66867088852b691ee577602f956ee6d30" translate="yes" xml:space="preserve">
          <source>The &quot;default&quot;, &quot;favorite&quot;, &quot;suggested&quot; random number generator type on the current platform. It is an alias for one of the previously-defined generators. You may want to use it if (1) you need to generate some nice random numbers, and (2) you don't care for the minutiae of the method being used.</source>
          <target state="translated">현재 플랫폼에서 &quot;default&quot;, &quot;favorite&quot;, &quot;suggeded&quot;난수 생성기 유형입니다. 이전에 정의 된 생성기 중 하나의 별명입니다. (1) 멋진 임의의 숫자를 생성해야하고 (2) 사용중인 방법의 세부 사항을 신경 쓰지 않는 경우에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b0187c6c3cc333e3b63fdd6f3f40abbfebecf5ce" translate="yes" xml:space="preserve">
          <source>The 'CURLVERSION_NOW' is the symbolic name meant to be used by basically all programs ever that want to get version information. It is meant to be a built-in version number for what kind of struct the caller expects. If the struct ever changes, we redefine the NOW to another enum from above.</source>
          <target state="translated">'CURLVERSION_NOW'는 기본적으로 버전 정보를 얻으려는 모든 프로그램에서 사용되는 기호 이름입니다. 호출자가 어떤 종류의 구조체를 기대하는지에 대한 기본 제공 버전 번호입니다. 구조체가 변경되면 NOW를 다른 열거 형으로 재정의합니다.</target>
        </trans-unit>
        <trans-unit id="d1f8d29986e592eb2309b74e7ba9f1ad07481d10" translate="yes" xml:space="preserve">
          <source>The 'op=' versions of the above overloaded operators.</source>
          <target state="translated">오버로드 된 연산자의 'op ='버전</target>
        </trans-unit>
        <trans-unit id="3a976ead2fa957aa078bdc5c148ef317d271794a" translate="yes" xml:space="preserve">
          <source>The 'path' in -conf=path, which is the path to the config file to use</source>
          <target state="translated">사용할 구성 파일의 경로 인 -conf = path의 'path'</target>
        </trans-unit>
        <trans-unit id="31c7a95d829cacee9ae6a883506beeedd2134baa" translate="yes" xml:space="preserve">
          <source>The -unittest flag needs to be passed to the compiler. If the flag is not passed &lt;code&gt;__traits(getUnitTests)&lt;/code&gt; will always return an empty tuple.</source>
          <target state="translated">-unittest 플래그는 컴파일러로 전달되어야합니다. 플래그가 전달되지 않으면 &lt;code&gt;__traits(getUnitTests)&lt;/code&gt; 는 항상 빈 튜플을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="723454678858263ffe8d6a6ec7de6d5f571a19fc" translate="yes" xml:space="preserve">
          <source>The .netrc will never be read. This is the default.</source>
          <target state="translated">.netrc는 읽히지 않습니다. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="5fc56dfb80dd68bb355d005695826ac631cdc022" translate="yes" xml:space="preserve">
          <source>The 16-bit Windows system directory.</source>
          <target state="translated">16 비트 Windows 시스템 디렉토리</target>
        </trans-unit>
        <trans-unit id="5aed8640844a3d20118fd4844ea5d066ae035774" translate="yes" xml:space="preserve">
          <source>The 32-bit Windows system directory.</source>
          <target state="translated">32 비트 Windows 시스템 디렉토리</target>
        </trans-unit>
        <trans-unit id="3822c06d82d04b0602bcb4a74379105b3119d9a8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#Address&quot;&gt;&lt;code&gt;Address&lt;/code&gt;&lt;/a&gt; to associate this socket with.</source>
          <target state="translated">&lt;a href=&quot;#Address&quot;&gt; &lt;code&gt;Address&lt;/code&gt; &lt;/a&gt; 이 소켓을 연결합니다.</target>
        </trans-unit>
        <trans-unit id="34d87623f07a3df5b3f286e1571b6960ff3c3a80" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; to subtract from this one.</source>
          <target state="translated">이 &lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 에서 빼는 날짜 입니다.</target>
        </trans-unit>
        <trans-unit id="5ea785f46b5e279a5fe31d9bcbc3fe5daaf562c2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; to subtract from this one.</source>
          <target state="translated">이 &lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 에서 빼는 DateTime 입니다.</target>
        </trans-unit>
        <trans-unit id="d0e37d9857c458a95dd085ddb2d77157413d4e72" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#DirEntry&quot;&gt;&lt;code&gt;DirEntry&lt;/code&gt;&lt;/a&gt; to remove</source>
          <target state="translated">&lt;a href=&quot;#DirEntry&quot;&gt; &lt;code&gt;DirEntry&lt;/code&gt; &lt;/a&gt; 제거하려면</target>
        </trans-unit>
        <trans-unit id="34c1a1f06a34f8fc1a3c2e67067eaacabd34869e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#EmailStatusCode&quot;&gt;&lt;code&gt;EmailStatusCode&lt;/code&gt;&lt;/a&gt; to read</source>
          <target state="translated">&lt;a href=&quot;#EmailStatusCode&quot;&gt; &lt;code&gt;EmailStatusCode&lt;/code&gt; 은&lt;/a&gt; 읽기</target>
        </trans-unit>
        <trans-unit id="78ee8056a7cc493671dbfe1dc57a34b10deb9e1b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#EnumBaseType&quot;&gt;&lt;i&gt;EnumBaseType&lt;/i&gt;&lt;/a&gt; of named enums must support comparison in order to compute the &lt;code&gt;.max&lt;/code&gt; and &lt;code&gt;.min&lt;/code&gt; properties.</source>
          <target state="translated">명명 된 열거 형 의 &lt;a href=&quot;#EnumBaseType&quot;&gt;&lt;i&gt;EnumBaseType&lt;/i&gt;&lt;/a&gt; 은 &lt;code&gt;.max&lt;/code&gt; 및 &lt;code&gt;.min&lt;/code&gt; 속성 을 계산하기 위해 비교를 지원해야합니다 .</target>
        </trans-unit>
        <trans-unit id="b5f3720a1adb0f3176194f3917579d377aa449f9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#Initializer&quot;&gt;&lt;i&gt;Initializer&lt;/i&gt;&lt;/a&gt; for a global or static variable must be evaluatable at compile time. Runtime initialization is done with static constructors.</source>
          <target state="translated">전역 또는 정적 변수 의 &lt;a href=&quot;#Initializer&quot;&gt;&lt;i&gt;초기화 프로그램&lt;/i&gt;&lt;/a&gt; 은 컴파일 타임에 평가 가능해야합니다. 런타임 초기화는 정적 생성자로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="80545d65ce3ac684ca91f02582517a26ef753e16" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#Interval&quot;&gt;&lt;code&gt;Interval&lt;/code&gt;&lt;/a&gt; to assign to this one.</source>
          <target state="translated">이것 에 할당 할 &lt;a href=&quot;#Interval&quot;&gt; &lt;code&gt;Interval&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f7647e4b267ecf7e3a76571ada3fdacd698012ed" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#Pid&quot;&gt;&lt;code&gt;Pid&lt;/code&gt;&lt;/a&gt; of the child process.</source>
          <target state="translated">자식 프로세스 의 &lt;a href=&quot;#Pid&quot;&gt; &lt;code&gt;Pid&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a7d45e276c1157a48db1764d13a939e845c33bc9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ScopeStatementList&quot;&gt;&lt;i&gt;ScopeStatementList&lt;/i&gt;&lt;/a&gt; introduces a new scope.</source>
          <target state="translated">&lt;a href=&quot;#ScopeStatementList&quot;&gt;&lt;i&gt;ScopeStatementList는&lt;/i&gt;&lt;/a&gt; 새로운 범위를 소개합니다.</target>
        </trans-unit>
        <trans-unit id="66ec6d2fcb103334da9a8b894f800e0431548606" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#StaticAssert&quot;&gt;&lt;i&gt;StaticAssert&lt;/i&gt;&lt;/a&gt; can be used to issue errors at compilation time for branches of the conditional compilation that are errors.</source>
          <target state="translated">&lt;a href=&quot;#StaticAssert&quot;&gt;&lt;i&gt;StaticAssert는&lt;/i&gt;&lt;/a&gt; 오류가있는 조건부 컴파일의 지점에 대한 컴파일시에 문제 오류로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="06e17380102c60dcb03f8837a22d0093ff7cde88" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; to assign to this one.</source>
          <target state="translated">&lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; 이 하나에 할당합니다.</target>
        </trans-unit>
        <trans-unit id="207dd1b8a4f95c054bf6246935ea41770d996fac" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; to convert.</source>
          <target state="translated">&lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; 변환합니다.</target>
        </trans-unit>
        <trans-unit id="8a4c34034a2cb8149059ccb52e1b31889b6ee383" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; to subtract from this one.</source>
          <target state="translated">이것을 빼기 위한 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cff9eb5299e33a3aaa4866e20fa3a6deb4e87d8b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; which is returned is in UTC.</source>
          <target state="translated">반환 되는 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; 은 UTC입니다.</target>
        </trans-unit>
        <trans-unit id="2c089e8236fdabd8d9be544307b70b1cf9caaa13" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#Tid&quot;&gt;&lt;code&gt;Tid&lt;/code&gt;&lt;/a&gt; of the caller's thread.</source>
          <target state="translated">호출자의 스레드 의 &lt;a href=&quot;#Tid&quot;&gt; &lt;code&gt;Tid&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="13239abac4fc6f880e927488a37426d1988f0906" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#TimeOfDay&quot;&gt;&lt;code&gt;TimeOfDay&lt;/code&gt;&lt;/a&gt; to subtract from this one.</source>
          <target state="translated">&lt;a href=&quot;#TimeOfDay&quot;&gt; &lt;code&gt;TimeOfDay&lt;/code&gt; 는&lt;/a&gt; 이 일에서 뺄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5568c800d11447839caafcd858afac1c90ab999a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#Type&quot;&gt;&lt;i&gt;Type&lt;/i&gt;&lt;/a&gt; above is the type of a variable or the return type of a function. This is never a &lt;a href=&quot;#TypeFunction&quot;&gt;&lt;i&gt;TypeFunction&lt;/i&gt;&lt;/a&gt;, as the latter can only be bound to a value via a pointer to a function or a delegate.</source>
          <target state="translated">&lt;a href=&quot;#Type&quot;&gt;&lt;i&gt;종류&lt;/i&gt;&lt;/a&gt; 이상의 변수 또는 함수의 리턴 형의 형태이다. 후자는 함수 또는 대리자에 대한 포인터를 통해서만 값에 바인딩 될 수 &lt;a href=&quot;#TypeFunction&quot;&gt;&lt;i&gt;있으므로&lt;/i&gt;&lt;/a&gt; 이것은 결코 &lt;i&gt;TypeFunction&lt;/i&gt; 이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="582962af3aa815ce568eaa34305272d8bb55ca09" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#selector-attribute&quot;&gt;&lt;code&gt;@selector&lt;/code&gt;&lt;/a&gt; attribute indicates which Objective-C selector should be used when calling this method. This attribute needs to be attached to all methods with the &lt;code&gt;Objective-C&lt;/code&gt; linkage.</source>
          <target state="translated">&lt;a href=&quot;#selector-attribute&quot;&gt; &lt;code&gt;@selector&lt;/code&gt; 의&lt;/a&gt; 속성은이 메소드를 호출 할 때 사용되어야하는 목표 - C 선택기 나타낸다. 이 속성은 &lt;code&gt;Objective-C&lt;/code&gt; 링크 가있는 모든 메소드에 첨부되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="1e4dae8c55a4019bd019df8cbf97d7672b905097" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#static_struct_init&quot;&gt;static initializer syntax&lt;/a&gt; can also be used to initialize non-static variables. The initializer need not be evaluable at compile time.</source>
          <target state="translated">&lt;a href=&quot;#static_struct_init&quot;&gt;정적 초기화 구문은&lt;/a&gt; 또한 비 정적 변수를 초기화 할 수있다. 이니셜 라이저는 컴파일 타임에 평가할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="8169d1266bc065db8156bf51397ae1c6ddebcd45" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;core_time#ClockType&quot;&gt;&lt;code&gt;core.time.ClockType&lt;/code&gt;&lt;/a&gt; indicates which system clock to use to get the current time. Very few programs need to use anything other than the default.</source>
          <target state="translated">&lt;a href=&quot;core_time#ClockType&quot;&gt; &lt;code&gt;core.time.ClockType&lt;/code&gt; 는&lt;/a&gt; 현재 시간을 얻기 위해 사용하는 시스템 클럭을 나타냅니다. 기본값 이외의 다른 프로그램을 사용해야하는 프로그램은 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="bd3bdabdeefd481383f96f2a3801bfd145044b4a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt; to add to or subtract from this &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; 은&lt;/a&gt; 추가하거나 뺄하는 &lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="75b962fb808beadc99e9b25a573d63d541dd58e9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt; to add to or subtract from this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; 은&lt;/a&gt; 추가하거나이에서 뺄 &lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1d75eebdd136326278ed1ff54a462d66c8152ff9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt; to add to or subtract from this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 &lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; &lt;/a&gt; 에 더하거나 빼기위한 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="802357de02f2910abfaab4969e438b3d74aa6db1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt; to add to or subtract from this &lt;a href=&quot;#TimeOfDay&quot;&gt;&lt;code&gt;TimeOfDay&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 &lt;a href=&quot;#TimeOfDay&quot;&gt; &lt;code&gt;TimeOfDay&lt;/code&gt; 에&lt;/a&gt; 더하거나 빼기 위한 &lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a6a5b45b3146e53f75b07950ca620f3168d2deba" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;declaration#VectorBaseType&quot;&gt;&lt;i&gt;VectorBaseType&lt;/i&gt;&lt;/a&gt; must be a &lt;a href=&quot;https://dlang.org/arrays.html#static-arrays&quot;&gt;Static Array&lt;/a&gt;. The &lt;a id=&quot;VectorElementType&quot;&gt;VectorElementType&lt;/a&gt; is the unqualified element type of the static array. The dimension of the static array is the number of elements in the vector.</source>
          <target state="translated">&lt;a href=&quot;declaration#VectorBaseType&quot;&gt;&lt;i&gt;VectorBaseType는&lt;/i&gt;&lt;/a&gt; 해야합니다 &lt;a href=&quot;https://dlang.org/arrays.html#static-arrays&quot;&gt;정적 배열&lt;/a&gt; . &lt;a id=&quot;VectorElementType&quot;&gt;VectorElementType는&lt;/a&gt; 정적 어레이의 규정되지 않은 요소 유형이다. 정적 배열의 차원은 벡터의 요소 수입니다.</target>
        </trans-unit>
        <trans-unit id="effa6c75295cbc49f2bd14a0813e7c7b20ad36aa" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;expression#InExpression&quot;&gt;&lt;i&gt;InExpression&lt;/i&gt;&lt;/a&gt; yields a pointer to the value if the key is in the associative array, or &lt;code&gt;null&lt;/code&gt; if not:</source>
          <target state="translated">&lt;a href=&quot;expression#InExpression&quot;&gt;&lt;i&gt;InExpression는&lt;/i&gt;&lt;/a&gt; 키 연관 배열 인 경우, 또는 값에 대한 포인터를 산출 &lt;code&gt;null&lt;/code&gt; 이 아니라면 :</target>
        </trans-unit>
        <trans-unit id="d10d2c3a02c91a9eaadda4648e8839a3ba8463c1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://ddili.org/ders/d.en/files.html&quot;&gt;official tutorial&lt;/a&gt; for an introduction to working with files in D, module &lt;a href=&quot;std_stdio&quot;&gt;&lt;code&gt;std.stdio&lt;/code&gt;&lt;/a&gt; for opening files and manipulating them via handles, and module &lt;a href=&quot;std_path&quot;&gt;&lt;code&gt;std.path&lt;/code&gt;&lt;/a&gt; for manipulating path strings.</source>
          <target state="translated">&lt;a href=&quot;http://ddili.org/ders/d.en/files.html&quot;&gt;공식 튜토리얼&lt;/a&gt; D 조에서 파일, 모듈 작업에 도입 &lt;a href=&quot;std_stdio&quot;&gt; &lt;code&gt;std.stdio&lt;/code&gt; &lt;/a&gt; 개방 파일과 핸들을 통해 그들을 조작 및 모듈 &lt;a href=&quot;std_path&quot;&gt; &lt;code&gt;std.path&lt;/code&gt; &lt;/a&gt; 경로 문자열을 조작합니다.</target>
        </trans-unit>
        <trans-unit id="7f10e36fd0934caf1d07c4486428d20fe9704f09" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://digitalmars.com/d/1.0/operatoroverloading.html&quot;&gt;D1 operator overload mechanisms&lt;/a&gt; are deprecated.</source>
          <target state="translated">&lt;a href=&quot;http://digitalmars.com/d/1.0/operatoroverloading.html&quot;&gt;D1 연산자 오버로드 메커니즘이&lt;/a&gt; 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8aed6127995bd75e76ecf6bfc0fe20f221a52ef0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://en.wikipedia.org/wiki/Julian_day&quot;&gt;Julian day&lt;/a&gt; for this &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; at noon (since the Julian day changes at noon).</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Julian_day&quot;&gt;율리우스 일&lt;/a&gt; 이에 대한 &lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 정오 (율리우스 일 정오에 변경 이후).</target>
        </trans-unit>
        <trans-unit id="6f9693a97556000512811c0be3654e4711f8c9f3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://en.wikipedia.org/wiki/Julian_day&quot;&gt;Julian day&lt;/a&gt; for this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; at the given time. For example, prior to noon, 1996-03-31 would be the Julian day number 2_450_173, so this function returns 2_450_173, while from noon onward, the julian day number would be 2_450_174, so this function returns 2_450_174.</source>
          <target state="translated">주어진 시간 에이 &lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;http://en.wikipedia.org/wiki/Julian_day&quot;&gt;율리우스 일&lt;/a&gt; 입니다 . 예를 들어, 정오 이전에 1996-03-31은 Julian 일 수 2_450_173이되므로이 함수는 2_450_173을 리턴하고 정오 이후에는 julian 일 수는 2_450_174가되므로이 함수는 2_450_174를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="9ebaf21b57e868005b0da3f2c282e36d7b90e06c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://en.wikipedia.org/wiki/Julian_day&quot;&gt;Julian day&lt;/a&gt; for this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; at the given time. For example, prior to noon, 1996-03-31 would be the Julian day number 2_450_173, so this function returns 2_450_173, while from noon onward, the Julian day number would be 2_450_174, so this function returns 2_450_174.</source>
          <target state="translated">주어진 시간 에이 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;http://en.wikipedia.org/wiki/Julian_day&quot;&gt;율리우스 일&lt;/a&gt; . 예를 들어, 정오 이전에 1996-03-31은 율리우스 일 번호 2_450_173이되므로이 함수는 2_450_173을 리턴하고 정오 이후에는 율리우스 일 수는 2_450_174가되므로이 함수는 2_450_174를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="f1315c501ab7c8abc5b3669ec5fc148fef194077" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://en.wikipedia.org/wiki/Endianness&quot;&gt;endianness&lt;/a&gt; (byte order) of the layout of the data will conform to the endianness of the target machine. The Intel x86 CPUs are</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Endianness&quot;&gt;엔디안&lt;/a&gt; 데이터 레이아웃 (바이트 순서)는 타겟 시스템의 엔디안에 부합 할 것이다. 인텔 x86 CPU는</target>
        </trans-unit>
        <trans-unit id="6a73d189b3abb4382b6807f2586136519fc591d4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://en.wikipedia.org/wiki/Julian_day&quot;&gt;Julian day&lt;/a&gt; for this &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; at noon (since the Julian day changes at noon).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15ddbf9eb9632cc4d5cb9a47bbe354212c7dadf6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://en.wikipedia.org/wiki/Julian_day&quot;&gt;Julian day&lt;/a&gt; for this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; at the given time. For example, prior to noon, 1996-03-31 would be the Julian day number 2_450_173, so this function returns 2_450_173, while from noon onward, the julian day number would be 2_450_174, so this function returns 2_450_174.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efef95f6d1522e76a66734a5a359cd8ae2b18bc3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://en.wikipedia.org/wiki/Julian_day&quot;&gt;Julian day&lt;/a&gt; for this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; at the given time. For example, prior to noon, 1996-03-31 would be the Julian day number 2_450_173, so this function returns 2_450_173, while from noon onward, the Julian day number would be 2_450_174, so this function returns 2_450_174.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38e38f26969116e49ca5ad61cb9c0c6b7110d3e8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://en.wikipedia.org/wiki/Mersenne_Twister&quot;&gt;Mersenne Twister&lt;/a&gt; generator.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Mersenne_Twister&quot;&gt;메르 센 트위스터&lt;/a&gt; 발전기.</target>
        </trans-unit>
        <trans-unit id="c9f82d023b95ffa80b2f699e9e809a3c89a026b0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;std%20format_#formattedWrite&quot;&gt;format string&lt;/a&gt;. When passed as a compile-time argument, the string will be statically checked against the argument types passed.</source>
          <target state="translated">&lt;a href=&quot;std%20format_#formattedWrite&quot;&gt;형식 문자열&lt;/a&gt; . 컴파일 타임 인수로 전달되면 전달 된 인수 유형에 대해 문자열이 정적으로 검사됩니다.</target>
        </trans-unit>
        <trans-unit id="481e9a24c24efd34a009264a7e75b75ffae8d4de" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;std_container_array&quot;&gt;&lt;code&gt;std.container.array&lt;/code&gt;&lt;/a&gt; module provides an array type with deterministic control of memory, not reliant on the GC unlike built-in arrays.</source>
          <target state="translated">&lt;a href=&quot;std_container_array&quot;&gt; &lt;code&gt;std.container.array&lt;/code&gt; &lt;/a&gt; 모듈은 메모리의 결정 제어의 내장 어레이 달리 GC에 의존하지 갖는 어레이 형을 제공한다.</target>
        </trans-unit>
        <trans-unit id="dfa5a280cf90a28fa7e0eef541fa14d62e72889f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;std_container_binaryheap&quot;&gt;&lt;code&gt;std.container.binaryheap&lt;/code&gt;&lt;/a&gt; module provides a binary heap implementation that can be applied to any user-provided random-access range.</source>
          <target state="translated">&lt;a href=&quot;std_container_binaryheap&quot;&gt; &lt;code&gt;std.container.binaryheap&lt;/code&gt; &lt;/a&gt; 모듈은 사용자가 제공 한 랜덤 액세스 범위에 적용 할 수있는 바이너리 힙 구현을 제공한다.</target>
        </trans-unit>
        <trans-unit id="2119b8da972da345ec79612705fb31e169986f77" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;std_container_dlist&quot;&gt;&lt;code&gt;std.container.dlist&lt;/code&gt;&lt;/a&gt; module provides a doubly-linked list implementation.</source>
          <target state="translated">&lt;a href=&quot;std_container_dlist&quot;&gt; &lt;code&gt;std.container.dlist&lt;/code&gt; &lt;/a&gt; 모듈은 이중 연결리스트 구현을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f5fb0146d19f80ce350def73e46817f3153f1ed2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;std_container_rbtree&quot;&gt;&lt;code&gt;std.container.rbtree&lt;/code&gt;&lt;/a&gt; module implements red-black trees.</source>
          <target state="translated">&lt;a href=&quot;std_container_rbtree&quot;&gt; &lt;code&gt;std.container.rbtree&lt;/code&gt; &lt;/a&gt; 모듈 구현은 레드 - 블랙 트리를.</target>
        </trans-unit>
        <trans-unit id="e298b015d33d43064046aea1f114005ecd3146c0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;std_container_slist&quot;&gt;&lt;code&gt;std.container.slist&lt;/code&gt;&lt;/a&gt; module implements singly-linked lists.</source>
          <target state="translated">&lt;a href=&quot;std_container_slist&quot;&gt; &lt;code&gt;std.container.slist&lt;/code&gt; 의&lt;/a&gt; 모듈 구현이 목록을 단독으로 연결된.</target>
        </trans-unit>
        <trans-unit id="93d548eb67721f59514b3a9fcf6295da94bb0b20" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;std_container_util&quot;&gt;&lt;code&gt;std.container.util&lt;/code&gt;&lt;/a&gt; module contains some generic tools commonly used by container implementations.</source>
          <target state="translated">&lt;a href=&quot;std_container_util&quot;&gt; &lt;code&gt;std.container.util&lt;/code&gt; &lt;/a&gt; 모듈은 일반적으로 컨테이너 구현으로 사용되는 몇 가지 일반적인 도구가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="25369d56bc9c24a5642f926b4c95112802f3c450" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;std_datetime_date#Date&quot;&gt;&lt;code&gt;std.datetime.date.Date&lt;/code&gt;&lt;/a&gt; to use to set this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;'s internal std time. As &lt;a href=&quot;std_datetime_date#Date&quot;&gt;&lt;code&gt;std.datetime.date.Date&lt;/code&gt;&lt;/a&gt; has no concept of time zone, tz is used as its time zone.</source>
          <target state="translated">&lt;a href=&quot;std_datetime_date#Date&quot;&gt; &lt;code&gt;std.datetime.date.Date&lt;/code&gt; 는&lt;/a&gt; 이 설정에 사용하는 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; 의 내부 표준 시간을. 마찬가지로 &lt;a href=&quot;std_datetime_date#Date&quot;&gt; &lt;code&gt;std.datetime.date.Date&lt;/code&gt; 이&lt;/a&gt; 시간대의 개념이없고, TZ는 그 시간대를 사용한다.</target>
        </trans-unit>
        <trans-unit id="40b6cce9339f7a4c6635b21b800c941d34791b3b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;std_datetime_date#DateTime&quot;&gt;&lt;code&gt;std.datetime.date.DateTime&lt;/code&gt;&lt;/a&gt; to use to set this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;'s internal std time. As &lt;a href=&quot;std_datetime_date#DateTime&quot;&gt;&lt;code&gt;std.datetime.date.DateTime&lt;/code&gt;&lt;/a&gt; has no concept of time zone, tz is used as its time zone.</source>
          <target state="translated">이 &lt;a href=&quot;std_datetime_date#DateTime&quot;&gt; &lt;code&gt;std.datetime.date.DateTime&lt;/code&gt; &lt;/a&gt; 의 내부 표준 시간 을 설정하는 데 사용되는 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; 입니다. 마찬가지로 &lt;a href=&quot;std_datetime_date#DateTime&quot;&gt; &lt;code&gt;std.datetime.date.DateTime&lt;/code&gt; 이&lt;/a&gt; 시간대의 개념이없고, TZ는 그 시간대를 사용한다.</target>
        </trans-unit>
        <trans-unit id="6e43d0d7ff46bcb20c2dae1597b0a93ebe575980" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;std_datetime_date#TimeOfDay&quot;&gt;&lt;code&gt;std.datetime.date.TimeOfDay&lt;/code&gt;&lt;/a&gt; to set this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;'s time portion to.</source>
          <target state="translated">이 &lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 시간 부분을 설정 하는 &lt;a href=&quot;std_datetime_date#TimeOfDay&quot;&gt; &lt;code&gt;std.datetime.date.TimeOfDay&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1ca7e1a66704d1b5289d51285f4b82f1cff387b1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;std_datetime_timezone#TimeZone&quot;&gt;&lt;code&gt;std.datetime.timezone.TimeZone&lt;/code&gt;&lt;/a&gt; to set this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;'s time zone to.</source>
          <target state="translated">&lt;a href=&quot;std_datetime_timezone#TimeZone&quot;&gt; &lt;code&gt;std.datetime.timezone.TimeZone&lt;/code&gt; 는&lt;/a&gt; 이 설정 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; 까지의 시간대를.</target>
        </trans-unit>
        <trans-unit id="81c02825b5b14c0f10a52b089c01fa05ef0129bb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;std_datetime_timezone#TimeZone&quot;&gt;&lt;code&gt;std.datetime.timezone.TimeZone&lt;/code&gt;&lt;/a&gt; to use for this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;. If null, &lt;a href=&quot;std_datetime_timezone#LocalTime&quot;&gt;&lt;code&gt;std.datetime.timezone.LocalTime&lt;/code&gt;&lt;/a&gt; will be used.</source>
          <target state="translated">이 &lt;a href=&quot;std_datetime_timezone#TimeZone&quot;&gt; &lt;code&gt;std.datetime.timezone.TimeZone&lt;/code&gt; &lt;/a&gt; 에 사용할 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; 입니다. null 인 경우 &lt;a href=&quot;std_datetime_timezone#LocalTime&quot;&gt; &lt;code&gt;std.datetime.timezone.LocalTime&lt;/code&gt; &lt;/a&gt; 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5ddd6c581df9a07885fdff9c9d57f3a0dd8af7cc" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;std_datetime_timezone#TimeZone&quot;&gt;&lt;code&gt;std.datetime.timezone.TimeZone&lt;/code&gt;&lt;/a&gt; to use for this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;. If null, &lt;a href=&quot;std_datetime_timezone#LocalTime&quot;&gt;&lt;code&gt;std.datetime.timezone.LocalTime&lt;/code&gt;&lt;/a&gt; will be used. The given &lt;a href=&quot;std_datetime_date#Date&quot;&gt;&lt;code&gt;std.datetime.date.Date&lt;/code&gt;&lt;/a&gt; is assumed to be in the given time zone.</source>
          <target state="translated">이 &lt;a href=&quot;std_datetime_timezone#TimeZone&quot;&gt; &lt;code&gt;std.datetime.timezone.TimeZone&lt;/code&gt; &lt;/a&gt; 에 사용할 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; 입니다. null 인 경우 &lt;a href=&quot;std_datetime_timezone#LocalTime&quot;&gt; &lt;code&gt;std.datetime.timezone.LocalTime&lt;/code&gt; &lt;/a&gt; 이 사용됩니다. 주어진 &lt;a href=&quot;std_datetime_date#Date&quot;&gt; &lt;code&gt;std.datetime.date.Date&lt;/code&gt; &lt;/a&gt; 는 주어진 시간대 에 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="1fcfa02211ca223ce042227e6e460db112358e19" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;std_datetime_timezone#TimeZone&quot;&gt;&lt;code&gt;std.datetime.timezone.TimeZone&lt;/code&gt;&lt;/a&gt; to use for this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;. If null, &lt;a href=&quot;std_datetime_timezone#LocalTime&quot;&gt;&lt;code&gt;std.datetime.timezone.LocalTime&lt;/code&gt;&lt;/a&gt; will be used. The given &lt;a href=&quot;std_datetime_date#DateTime&quot;&gt;&lt;code&gt;std.datetime.date.DateTime&lt;/code&gt;&lt;/a&gt; is assumed to be in the given time zone.</source>
          <target state="translated">이 &lt;a href=&quot;std_datetime_timezone#TimeZone&quot;&gt; &lt;code&gt;std.datetime.timezone.TimeZone&lt;/code&gt; &lt;/a&gt; 에 사용할 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; 입니다. null 인 경우 &lt;a href=&quot;std_datetime_timezone#LocalTime&quot;&gt; &lt;code&gt;std.datetime.timezone.LocalTime&lt;/code&gt; &lt;/a&gt; 이 사용됩니다. 주어진 &lt;a href=&quot;std_datetime_date#DateTime&quot;&gt; &lt;code&gt;std.datetime.date.DateTime&lt;/code&gt; &lt;/a&gt; 은 주어진 시간대 에 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="08defa52d0f78153c4cad926f82b67c861f1be23" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;std_format#FormatSpec&quot;&gt;&lt;code&gt;std.format.FormatSpec&lt;/code&gt;&lt;/a&gt; defining how to write the value.</source>
          <target state="translated">&lt;a href=&quot;std_format#FormatSpec&quot;&gt; &lt;code&gt;std.format.FormatSpec&lt;/code&gt; 는&lt;/a&gt; 값을 작성하는 방법을 정의.</target>
        </trans-unit>
        <trans-unit id="da7dc5894bf45c46b28c38bfbe1e06829d7ea9b4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;std_format#formattedWrite&quot;&gt;format string&lt;/a&gt;. When passed as a compile-time argument, the string will be statically checked against the argument types passed.</source>
          <target state="translated">&lt;a href=&quot;std_format#formattedWrite&quot;&gt;형식 문자열&lt;/a&gt; . 컴파일 타임 인수로 전달되면 전달 된 인수 유형에 대해 문자열이 정적으로 검사됩니다.</target>
        </trans-unit>
        <trans-unit id="996e3f7bfd240f0b6638a423c48f3771a90ccfd7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;std_parallelism#task&quot;&gt;&lt;code&gt;std.parallelism.task&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;std_parallelism#scopedTask&quot;&gt;&lt;code&gt;std.parallelism.scopedTask&lt;/code&gt;&lt;/a&gt; functions can be used to create an instance of this struct. See &lt;code&gt;task&lt;/code&gt; for usage examples.</source>
          <target state="translated">&lt;a href=&quot;std_parallelism#task&quot;&gt; &lt;code&gt;std.parallelism.task&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;std_parallelism#scopedTask&quot;&gt; &lt;code&gt;std.parallelism.scopedTask&lt;/code&gt; 의&lt;/a&gt; 기능이 구조체의 인스턴스를 만들 수 있습니다. 사용 예는 &lt;code&gt;task&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="17a7dba8fb267a6bf56ea097ca9bbf1d8c9db713" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;std_range_primitives&quot;&gt;&lt;code&gt;std.range.primitives&lt;/code&gt;&lt;/a&gt; submodule provides basic range functionality. It defines several templates for testing whether a given object is a range, what kind of range it is, and provides some common range operations.  The &lt;a href=&quot;std_range_interfaces&quot;&gt;&lt;code&gt;std.range.interfaces&lt;/code&gt;&lt;/a&gt; submodule provides object-based interfaces for working with ranges via runtime polymorphism.  The remainder of this module provides a rich set of range creation and composition templates that let you construct new ranges out of existing ranges:</source>
          <target state="translated">&lt;a href=&quot;std_range_primitives&quot;&gt; &lt;code&gt;std.range.primitives&lt;/code&gt; 의&lt;/a&gt; 서브 모듈은 기본 범위의 기능을 제공합니다. 주어진 객체가 범위인지, 어떤 종류의 범위인지, 그리고 일반적인 범위 작업을 제공하기 위해 몇 가지 템플릿을 정의합니다. &lt;a href=&quot;std_range_interfaces&quot;&gt; &lt;code&gt;std.range.interfaces&lt;/code&gt; 의&lt;/a&gt; 서브 모듈 런타임 다형성 통해 작업 범위에 대해 오브젝트 기반의 인터페이스를 제공한다. 이 모듈의 나머지 부분은 기존 범위에서 새 범위를 구성 할 수있는 다양한 범위 작성 및 구성 템플릿 세트를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="8bc9200c08dfc6228f7d505663f83af0f17d9fbb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;std_range_primitives#isBidirectionalRange&quot;&gt;bidirectional range&lt;/a&gt; to check.</source>
          <target state="translated">&lt;a href=&quot;std_range_primitives#isBidirectionalRange&quot;&gt;양방향 범위를&lt;/a&gt; 확인합니다.</target>
        </trans-unit>
        <trans-unit id="b431ca8d283d375b7c8a22210b546a6efef61b11" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward range&lt;/a&gt; to move forward.</source>
          <target state="translated">&lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;앞으로 범위는&lt;/a&gt; 앞으로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="369ec9042a7546e2cad9bbf6e6a080f3772b0c25" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward range&lt;/a&gt; to search for.</source>
          <target state="translated">&lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;앞으로 범위&lt;/a&gt; 를 검색합니다.</target>
        </trans-unit>
        <trans-unit id="8ec17c85557100072993cd5c068790742349c464" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward range&lt;/a&gt; to search in.</source>
          <target state="translated">&lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;앞으로 범위&lt;/a&gt; 에서 검색합니다.</target>
        </trans-unit>
        <trans-unit id="b8760be6cdf077df34f28a96eae1b9c765d650e0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward range&lt;/a&gt; to search.</source>
          <target state="translated">&lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;전진 기어를&lt;/a&gt; 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="15ac7337e01f1d9ab183d6ae25d5a20a312c2083" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; searched in.</source>
          <target state="translated">&lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;입력 범위&lt;/a&gt; 에서 검색.</target>
        </trans-unit>
        <trans-unit id="7eb60916c92bf64de177162de8e5c1050d35606a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; to be counted.</source>
          <target state="translated">&lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;입력 범위를&lt;/a&gt; 계산한다.</target>
        </trans-unit>
        <trans-unit id="54ec01abf5c0ea4698d52f36cd4ccc451206d4dd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; to be mapped. If &lt;code&gt;source&lt;/code&gt; is not random access it will be lazily buffered to an array of size &lt;code&gt;bufSize&lt;/code&gt; before the map function is evaluated. (For an exception to this rule, see Notes.)</source>
          <target state="translated">&lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;입력 범위&lt;/a&gt; 에 매핑한다. &lt;code&gt;source&lt;/code&gt; 가 랜덤 액세스가 아닌 경우 , 맵 함수가 평가되기 전에 &lt;code&gt;bufSize&lt;/code&gt; 크기의 배열로 지연 버퍼링됩니다 . 이 규칙에 대한 예외는 참고를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7fcb4bb2ee90251c35487c12566eec5095d57613" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; to be split. Must support slicing and &lt;code&gt;.length&lt;/code&gt; or be a narrow string type.</source>
          <target state="translated">&lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;입력 범위는&lt;/a&gt; 분할된다. 슬라이싱 및 &lt;code&gt;.length&lt;/code&gt; 를 지원 하거나 좁은 문자열 유형 이어야 합니다.</target>
        </trans-unit>
        <trans-unit id="952eb645f806f4e8722eb0d2cd942129dfd0ddf5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; to count.</source>
          <target state="translated">&lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;입력 범위를&lt;/a&gt; 계산한다.</target>
        </trans-unit>
        <trans-unit id="2c3f0a3ca624d2dffa57f0bed2a0b2870eb60a2e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; to decode.</source>
          <target state="translated">&lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;입력 범위는&lt;/a&gt; 디코딩한다.</target>
        </trans-unit>
        <trans-unit id="4e73a5f21eb9f220fe4a413efefe2e08d57d2486" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; to encode.</source>
          <target state="translated">&lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;입력 범위를&lt;/a&gt; 인코딩하도록.</target>
        </trans-unit>
        <trans-unit id="8d96bd41d136cd6247adb3fa26dee3b86c4089e3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; to iterate over.</source>
          <target state="translated">&lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;입력 범위는&lt;/a&gt; 반복한다.</target>
        </trans-unit>
        <trans-unit id="dbb5a95b7ba0669a172e47e1723f9cfc7c2ea498" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; to search.</source>
          <target state="translated">&lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;입력 범위&lt;/a&gt; 를 검색한다.</target>
        </trans-unit>
        <trans-unit id="8c359e89eaa705ac18cac67cf8b6402278719d14" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input ranges&lt;/a&gt; representing the prefix of &lt;code&gt;r1&lt;/code&gt; to skip over.</source>
          <target state="translated">&lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;입력 범위&lt;/a&gt; 의 프리픽스 나타내는 &lt;code&gt;r1&lt;/code&gt; 스킵.</target>
        </trans-unit>
        <trans-unit id="c37be58cc17319441d46aeb5f1996c8581894cf3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;std_range_primitives#isOutputRange&quot;&gt;output range&lt;/a&gt; to store the decoded result.</source>
          <target state="translated">디코딩 된 결과를 저장하기 위한 &lt;a href=&quot;std_range_primitives#isOutputRange&quot;&gt;출력 범위&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c13c7cb92037b15fc161b95f9af9172d148b4a5e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;std_range_primitives#isOutputRange&quot;&gt;output range&lt;/a&gt; to store the encoded result.</source>
          <target state="translated">&lt;a href=&quot;std_range_primitives#isOutputRange&quot;&gt;출력 범위는&lt;/a&gt; 인코딩 된 결과를 저장한다.</target>
        </trans-unit>
        <trans-unit id="77c0f3bce9137a040efd3771cfb0616a86cd7cd5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;std_range_primitives#isOutputRange&quot;&gt;output range&lt;/a&gt; to write to.</source>
          <target state="translated">&lt;a href=&quot;std_range_primitives#isOutputRange&quot;&gt;출력 범위&lt;/a&gt; 에 쓰기.</target>
        </trans-unit>
        <trans-unit id="49142d8fd68c9b3c53741f925ebe20a7b56a8f58" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;%d&lt;/b&gt; format is used.</source>
          <target state="translated">&lt;b&gt;% d 개의&lt;/b&gt; 형식이 사용된다.</target>
        </trans-unit>
        <trans-unit id="51044429589e6e99a3db526e744ad9e76e4f0d6d" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;%g&lt;/b&gt; format is used.</source>
          <target state="translated">&lt;b&gt;%의 g의&lt;/b&gt; 포맷이 사용된다.</target>
        </trans-unit>
        <trans-unit id="6011bed86258fb25beea867d98c6c8f61613da53" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;M&lt;/b&gt; means that the symbol is a function that requires a &lt;code&gt;this&lt;/code&gt; pointer. Class or struct fields are mangled without &lt;b&gt;M&lt;/b&gt;. To disambiguate &lt;b&gt;M&lt;/b&gt; from being a &lt;a href=&quot;#Parameter&quot;&gt;&lt;i&gt;Parameter&lt;/i&gt;&lt;/a&gt; with modifier &lt;code&gt;scope&lt;/code&gt;, the following type needs to be checked for being a &lt;a href=&quot;#TypeFunction&quot;&gt;&lt;i&gt;TypeFunction&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;b&gt;M의&lt;/b&gt; 수단 기호는 필요한 기능 있음 &lt;code&gt;this&lt;/code&gt; 포인터. 클래스 또는 구조체 필드는 &lt;b&gt;M&lt;/b&gt; 없이 엉망 입니다. &lt;b&gt;M&lt;/b&gt; 이 수정 자 &lt;code&gt;scope&lt;/code&gt; 갖는 &lt;a href=&quot;#Parameter&quot;&gt;&lt;i&gt;매개 변수&lt;/i&gt;&lt;/a&gt; 가 되는 것을 명확하게하려면 &lt;a href=&quot;#TypeFunction&quot;&gt;&lt;i&gt;TypeFunction인지&lt;/i&gt;&lt;/a&gt; 확인하려면 다음 유형을 확인해야합니다 .&lt;i&gt;&lt;/i&gt;</target>
        </trans-unit>
        <trans-unit id="8b62ad940fbeb2c5789e6f8cc722fdbfa7da5ba7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;!in&lt;/code&gt; expression is the logical negation of the &lt;code&gt;in&lt;/code&gt; operation.</source>
          <target state="translated">&lt;code&gt;!in&lt;/code&gt; 표현식의 논리 부정이다 &lt;code&gt;in&lt;/code&gt; 작동.</target>
        </trans-unit>
        <trans-unit id="949f738dd41deb163c516ad01a068ab33816218e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.funcptr&lt;/code&gt; property of a delegate will return the</source>
          <target state="translated">델리게이트 의 &lt;code&gt;.funcptr&lt;/code&gt; 속성은</target>
        </trans-unit>
        <trans-unit id="a927ff60b0c832aca1d0deb1c1d68c1daa79dc5d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.idup&lt;/code&gt; property is a convenient way to create an immutable copy of an array:</source>
          <target state="translated">&lt;code&gt;.idup&lt;/code&gt; 속성은 배열의 불변의 복사본을 만들 수있는 편리한 방법입니다 :</target>
        </trans-unit>
        <trans-unit id="cd8b8d3fc90c04cca56a82b84eb7386d0bdfe47f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.init&lt;/code&gt; property of an enum type is the value of the first member of that enum. This is also the default initializer for the enum type.</source>
          <target state="translated">열거 형 의 &lt;code&gt;.init&lt;/code&gt; 프로퍼티는 그 열거의 최초 멤버의 값입니다. 이것은 열거 형의 기본 이니셜 라이저이기도합니다.</target>
        </trans-unit>
        <trans-unit id="3859b962f71ebd6e5c9c1b0719a79ab297661c17" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.length&lt;/code&gt; property of a dynamic array can be set as the left-hand side of an = operator:</source>
          <target state="translated">동적 배열 의 &lt;code&gt;.length&lt;/code&gt; 속성은 = 연산자의 왼쪽으로 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6aa34068a5d22ab8aa9bd9b191c719d0f01d956d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.length&lt;/code&gt;, &lt;code&gt;.size&lt;/code&gt;, &lt;code&gt;.sizeof&lt;/code&gt;, &lt;code&gt;.offsetof&lt;/code&gt; and &lt;code&gt;.alignof&lt;/code&gt; properties will be of type &lt;code&gt;size_t&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;.length&lt;/code&gt; 는 , &lt;code&gt;.size&lt;/code&gt; , &lt;code&gt;.sizeof&lt;/code&gt; , &lt;code&gt;.offsetof&lt;/code&gt; 및 &lt;code&gt;.alignof&lt;/code&gt; 속성 형식이 될 것 &lt;code&gt;size_t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4fdbd1b27908707173a1edaf4525112b28d20cd0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.offsetof&lt;/code&gt; property gives the offset in bytes of the field from the beginning of the class instantiation. &lt;code&gt;.offsetof&lt;/code&gt; is not available for fields of &lt;code&gt;extern(Objective-C)&lt;/code&gt; classes due to their fields having a dynamic offset. &lt;code&gt;.offsetof&lt;/code&gt; can only be applied to expressions which produce the type of the field itself, not the class type:</source>
          <target state="translated">&lt;code&gt;.offsetof&lt;/code&gt; 속성은 클래스 인스턴스의 시작 부분에서 필드의 바이트 오프셋을 제공합니다. &lt;code&gt;.offsetof&lt;/code&gt; 는 &lt;code&gt;extern(Objective-C)&lt;/code&gt; 클래스의 필드에는 동적 오프셋이 있으므로 사용할 수 없습니다 . &lt;code&gt;.offsetof&lt;/code&gt; 는 클래스 유형이 아닌 필드 자체의 유형을 생성하는 표현식에만 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="95c8eacd4f051efc8e34b0ec28e0fb9f11aa27b4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.ptr&lt;/code&gt; property of a delegate will return the</source>
          <target state="translated">델리게이트 의 &lt;code&gt;.ptr&lt;/code&gt; 속성은</target>
        </trans-unit>
        <trans-unit id="1724903b9c0188aab384fe5f52257faa0acb7527" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.tupleof&lt;/code&gt; property is an &lt;a href=&quot;template#variadic-templates&quot;&gt;expression sequence&lt;/a&gt; of all the fields in the class, excluding the hidden fields and the fields in the base class. &lt;code&gt;.tupleof&lt;/code&gt; is not available for &lt;code&gt;extern(Objective-C)&lt;/code&gt; classes due to their fields having a dynamic offset.</source>
          <target state="translated">&lt;code&gt;.tupleof&lt;/code&gt; 속성은 인 &lt;a href=&quot;template#variadic-templates&quot;&gt;표현 순서&lt;/a&gt; 숨겨진 필드와 기본 클래스의 필드를 제외한 클래스의 모든 필드의. &lt;code&gt;.tupleof&lt;/code&gt; 는 필드에 동적 오프셋이 있으므로 &lt;code&gt;extern(Objective-C)&lt;/code&gt; 클래스에 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="c137d6dcdc8a762b857eac8c07b0096c836f30d9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@nogc&lt;/code&gt; and &lt;code&gt;nothrow&lt;/code&gt; attributes cannot be inferred for the &lt;code&gt;Zip&lt;/code&gt; struct because &lt;a href=&quot;#StoppingPolicy&quot;&gt;&lt;code&gt;StoppingPolicy&lt;/code&gt;&lt;/a&gt; can vary at runtime. This limitation is not shared by the anonymous range returned by the &lt;code&gt;zip&lt;/code&gt; function when not given an explicit &lt;code&gt;StoppingPolicy&lt;/code&gt; as an argument.</source>
          <target state="translated">&lt;code&gt;@nogc&lt;/code&gt; 및 &lt;code&gt;nothrow&lt;/code&gt; 속성은 대한 유추 할 수없는 &lt;code&gt;Zip&lt;/code&gt; 있기 때문에 구조체 &lt;a href=&quot;#StoppingPolicy&quot;&gt; &lt;code&gt;StoppingPolicy&lt;/code&gt; 가&lt;/a&gt; 런타임시 다를 수 있습니다. 명시적인 &lt;code&gt;StoppingPolicy&lt;/code&gt; 를 인수로 제공하지 않으면 &lt;code&gt;zip&lt;/code&gt; 함수가 반환 한 익명 범위는이 제한을 공유 하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="6e96abc33603d8bc05abf167e42cc4e98db8045c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@selector&lt;/code&gt; Attribute</source>
          <target state="translated">&lt;code&gt;@selector&lt;/code&gt; 의 특성</target>
        </trans-unit>
        <trans-unit id="f6c9ba4e329884202e2c96c75ddebb8190fe3bde" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@selector&lt;/code&gt; attribute is a compiler recognized &lt;a href=&quot;attribute#uda&quot;&gt;UDA&lt;/a&gt;. It is used to tell the compiler which selector to use when calling an Objective-C method.</source>
          <target state="translated">&lt;code&gt;@selector&lt;/code&gt; 속성은 인식 컴파일러 &lt;a href=&quot;attribute#uda&quot;&gt;UDA&lt;/a&gt; . Objective-C 메소드를 호출 할 때 사용할 선택기를 컴파일러에 알리는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="752216458653e1cbb6c9e963c946448d7d235321" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;AliasThis&lt;/code&gt; object to check</source>
          <target state="translated">&lt;code&gt;AliasThis&lt;/code&gt; 는 확인하는 객체</target>
        </trans-unit>
        <trans-unit id="fa92561e469bdb1ad4026066da03e96fe41ac12f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BigInt&lt;/code&gt; to convert to a decimal &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;BigInt&lt;/code&gt; 소수의로 변환하는 &lt;code&gt;string&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="762bae96b280038efb5744e1f69ff2a9b9fe8924" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BigInt&lt;/code&gt; to convert to a hexadecimal &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;BigInt&lt;/code&gt; 16 진수로 변환하는 &lt;code&gt;string&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="09048bfa6c458cec6891287f0bfdf5fb775fc807" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Contents&lt;/code&gt; of the input can be provided if all the records are the same type such as all integer data:</source>
          <target state="translated">&lt;code&gt;Contents&lt;/code&gt; 모든 레코드는 모두 정수 데이터와 동일한 종류 인 경우의 상기 입력을 제공 할 수있다 :</target>
        </trans-unit>
        <trans-unit id="c5b29392956ba29c0adb988c34e23412ed24102e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;D_ObjectiveC&lt;/code&gt; Version Identifier</source>
          <target state="translated">&lt;code&gt;D_ObjectiveC&lt;/code&gt; 버전 식별자</target>
        </trans-unit>
        <trans-unit id="3bdc294730714ec15d2e01301a3e08098956d705" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;D_ObjectiveC&lt;/code&gt; version identifier is a predefined version identifier. It is enabled if Objective-C support is available for the target.</source>
          <target state="translated">&lt;code&gt;D_ObjectiveC&lt;/code&gt; 의 버전 식별자는 소정의 버전 식별자이다. 대상에 Objective-C 지원이 사용 가능한 경우 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="9652b1793eda4a74a34bea7d01c1ae4dc455d00a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Direction&lt;/code&gt; that this range iterates in.</source>
          <target state="translated">이 범위가 반복 되는 &lt;code&gt;Direction&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f23dc3e300f8de1a7b5dc2f858ee4c1f0c10fa66" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;FILETIME&lt;/code&gt; struct to convert.</source>
          <target state="translated">&lt;code&gt;FILETIME&lt;/code&gt; 의 구조체 변환합니다.</target>
        </trans-unit>
        <trans-unit id="f223850e7d1f3a227dbc68e1f6ccb4db9d2a70e8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;File&lt;/code&gt; log messages are written to.</source>
          <target state="translated">&lt;code&gt;File&lt;/code&gt; 로그 메시지가 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="9505f486ff94c8cc96955cd21faa5ea522c0488b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;File&lt;/code&gt; passed must be open for all the log call to the &lt;code&gt;FileLogger&lt;/code&gt;. If the &lt;code&gt;File&lt;/code&gt; gets closed, using the &lt;code&gt;FileLogger&lt;/code&gt; for logging will result in undefined behaviour.</source>
          <target state="translated">&lt;code&gt;FileLogger&lt;/code&gt; 에 대한 모든 로그 호출에 대해 전달 된 &lt;code&gt;File&lt;/code&gt; 이 열려 있어야합니다 . 경우 &lt;code&gt;File&lt;/code&gt; 폐쇄됩니다의 사용 &lt;code&gt;FileLogger&lt;/code&gt; 를 로깅하는 것은 정의되지 않은 동작이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1adc74023b21a71faedb9fb2198865c8c868c0b0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;FreeTree&lt;/code&gt; is word aligned.</source>
          <target state="translated">&lt;code&gt;FreeTree&lt;/code&gt; 은 단어 정렬입니다.</target>
        </trans-unit>
        <trans-unit id="5a599fec73312b1e2c7a29eeb97f84d65ba31e02" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;IntervalRange&lt;/code&gt; to assign to this one.</source>
          <target state="translated">이것 에 할당 할 &lt;code&gt;IntervalRange&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="bae87f67fc76bb340f7ddbd109d8144f57f7a78f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LogLevel&lt;/code&gt; determines if the log call are processed or dropped by the &lt;code&gt;Logger&lt;/code&gt;. In order for the log call to be processed the &lt;code&gt;LogLevel&lt;/code&gt; of the log call must be greater or equal to the &lt;code&gt;LogLevel&lt;/code&gt; of the &lt;code&gt;logger&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;LogLevel&lt;/code&gt; 로그 호 처리 또는 하락하는 경우를 판단 &lt;code&gt;Logger&lt;/code&gt; . 로그 호출 위해서 처리 될 &lt;code&gt;LogLevel&lt;/code&gt; 에 커야 로그 통화를하거나 동일 &lt;code&gt;LogLevel&lt;/code&gt; 에 의 &lt;code&gt;logger&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="189baec1a3c41b98e162f7ebced93220628a714a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LogLevel&lt;/code&gt; for the &lt;code&gt;FileLogger&lt;/code&gt;. By default the</source>
          <target state="translated">&lt;code&gt;FileLogger&lt;/code&gt; 의 &lt;code&gt;LogLevel&lt;/code&gt; 입니다 . 기본적으로</target>
        </trans-unit>
        <trans-unit id="d018b0b265c186bb486a9c743eef113b007d5db9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LogLevel&lt;/code&gt; for the &lt;code&gt;FileLogger&lt;/code&gt;. By default the &lt;code&gt;LogLevel&lt;/code&gt; for &lt;code&gt;FileLogger&lt;/code&gt; is &lt;code&gt;LogLevel.all&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;FileLogger&lt;/code&gt; 의 &lt;code&gt;LogLevel&lt;/code&gt; 입니다 . 기본적으로 &lt;code&gt;LogLevel&lt;/code&gt; 에 대한 &lt;code&gt;FileLogger&lt;/code&gt; 이 있다 &lt;code&gt;LogLevel.all&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ae9ecb75d6ace04d1eacabcc1bcd9b6183ff7cad" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LogLevel&lt;/code&gt; for the &lt;code&gt;MultiLogger&lt;/code&gt;. By default the &lt;code&gt; LogLevel&lt;/code&gt; is &lt;code&gt;all&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;LogLevel&lt;/code&gt; 에 에 대한 &lt;code&gt;MultiLogger&lt;/code&gt; . 기본적으로 &lt;code&gt; LogLevel&lt;/code&gt; 은 &lt;code&gt;all&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="641b844c924242bfa7b7f12639ba8204d0cf1b18" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LogLevel&lt;/code&gt; for the &lt;code&gt;MultiLogger&lt;/code&gt;. By default the &lt;code&gt;LogLevel&lt;/code&gt; for &lt;code&gt;MultiLogger&lt;/code&gt; is &lt;code&gt;LogLevel.all&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;LogLevel&lt;/code&gt; 에 에 대한 &lt;code&gt;MultiLogger&lt;/code&gt; . 기본적으로 &lt;code&gt;LogLevel&lt;/code&gt; 에 대한 &lt;code&gt;MultiLogger&lt;/code&gt; 이 있다 &lt;code&gt;LogLevel.all&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3603b7e77aae4ad9627a9afeed3ce61445cb60ca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LogLevel&lt;/code&gt; for the &lt;code&gt;NullLogger&lt;/code&gt;. By default the &lt;code&gt;LogLevel&lt;/code&gt; for &lt;code&gt;NullLogger&lt;/code&gt; is &lt;code&gt;LogLevel.all&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NullLogger&lt;/code&gt; 의 &lt;code&gt;LogLevel&lt;/code&gt; 입니다 . 기본적으로 &lt;code&gt;LogLevel&lt;/code&gt; 에 대한 &lt;code&gt;NullLogger&lt;/code&gt; 이 있다 &lt;code&gt;LogLevel.all&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d2af39a6062628b2e279264f9a73f14181c2c5ac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LogLevel&lt;/code&gt; of a log call can be defined in two ways. The first is by calling &lt;code&gt;log&lt;/code&gt; and passing the &lt;code&gt;LogLevel&lt;/code&gt; explicitly as the first argument. The second way of setting the &lt;code&gt;LogLevel&lt;/code&gt; of a log call, is by calling either &lt;code&gt;trace&lt;/code&gt;, &lt;code&gt;info&lt;/code&gt;, &lt;code&gt;warning&lt;/code&gt;, &lt;code&gt;critical&lt;/code&gt;, or &lt;code&gt;fatal&lt;/code&gt;. The log call will then have the respective &lt;code&gt;LogLevel&lt;/code&gt;. If no &lt;code&gt;LogLevel&lt;/code&gt; is defined the log call will use the current &lt;code&gt;LogLevel&lt;/code&gt; of the used &lt;code&gt;Logger&lt;/code&gt;. If data is logged with &lt;code&gt;LogLevel&lt;/code&gt;&lt;code&gt;fatal&lt;/code&gt; by default an &lt;code&gt;Error&lt;/code&gt; will be thrown. This behaviour can be modified by using the member &lt;code&gt;fatalHandler&lt;/code&gt; to assign a custom delegate to handle log call with &lt;code&gt;LogLevel&lt;/code&gt;&lt;code&gt;fatal&lt;/code&gt;.</source>
          <target state="translated">로그 호출 의 &lt;code&gt;LogLevel&lt;/code&gt; 은 두 가지 방법으로 정의 할 수 있습니다. 첫 번째는 &lt;code&gt;log&lt;/code&gt; 를 호출 하고 &lt;code&gt;LogLevel&lt;/code&gt; 을 첫 번째 인수로 명시 적으로 전달하는 것 입니다. 로그 호출 의 &lt;code&gt;LogLevel&lt;/code&gt; 을 설정하는 두 번째 방법은 &lt;code&gt;trace&lt;/code&gt; , &lt;code&gt;info&lt;/code&gt; , &lt;code&gt;warning&lt;/code&gt; , &lt;code&gt;critical&lt;/code&gt; 또는 &lt;code&gt;fatal&lt;/code&gt; 을 호출하는 것 입니다. 그런 다음 로그 호출에는 해당 &lt;code&gt;LogLevel&lt;/code&gt; 이 있습니다. &lt;code&gt;LogLevel&lt;/code&gt; 이 정의되어 있지 않으면 로그 호출은 사용 된 &lt;code&gt;Logger&lt;/code&gt; 의 현재 &lt;code&gt;LogLevel&lt;/code&gt; 을 사용 합니다. 기본적 으로 &lt;code&gt;LogLevel&lt;/code&gt; &lt;code&gt;fatal&lt;/code&gt; 데이터로 기록 된 경우 &lt;code&gt;Error&lt;/code&gt; 던져 질 것이다. 이 동작은 &lt;code&gt;fatalHandler&lt;/code&gt; 멤버를 사용하여 &lt;code&gt;LogLevel&lt;/code&gt; &lt;code&gt;fatal&lt;/code&gt; 로 로그 호출을 처리 할 사용자 정의 대리자를 지정 하여 수정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0a0d434e25b47fdaafcef338f132ea275bc847f4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LogLevel&lt;/code&gt; used by this log call.</source>
          <target state="translated">&lt;code&gt;LogLevel&lt;/code&gt; 이 로그 호출에 의해 사용.</target>
        </trans-unit>
        <trans-unit id="8892f147c371745dae355ae476344696ac6a8bd9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Logger&lt;/code&gt; to insert.</source>
          <target state="translated">&lt;code&gt;Logger&lt;/code&gt; 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="80178593879baa963d3ea8ccb8419d3049b3fd6c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NegInfInterval&lt;/code&gt; to assign to this one.</source>
          <target state="translated">&lt;code&gt;NegInfInterval&lt;/code&gt; 는 이 하나에 할당합니다.</target>
        </trans-unit>
        <trans-unit id="45d1956c384b5b3fb5b0e73f346cf797ea06f1fc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NegInfIntervalRange&lt;/code&gt; to assign to this one.</source>
          <target state="translated">&lt;code&gt;NegInfIntervalRange&lt;/code&gt; 는 이 하나에 할당합니다.</target>
        </trans-unit>
        <trans-unit id="80594f56560776213c82536e7c5835856110de27" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NullLogger&lt;/code&gt; will not process any log messages.</source>
          <target state="translated">&lt;code&gt;NullLogger&lt;/code&gt; 은 모든 로그 메시지를 처리하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a481e02ed96f28efe58cf2e89023a7611a07a100" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Option&lt;/code&gt; extracted from the &lt;code&gt;getopt&lt;/code&gt; parameter.</source>
          <target state="translated">&lt;code&gt;Option&lt;/code&gt; 으로부터 추출 &lt;code&gt;getopt&lt;/code&gt; 는 파라미터.</target>
        </trans-unit>
        <trans-unit id="af853ab18e8359e92cea25ba5f1faea6ad6630ad" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ParentAllocator&lt;/code&gt; type parameter is the type of the allocator used to allocate the memory chunk underlying the &lt;code&gt;KRRegion&lt;/code&gt; object. Choosing the default (&lt;code&gt;NullAllocator&lt;/code&gt;) means the user is responsible for passing a buffer at construction (and for deallocating it if necessary). Otherwise, &lt;code&gt;KRRegion&lt;/code&gt; automatically deallocates the buffer during destruction. For that reason, if &lt;code&gt;ParentAllocator&lt;/code&gt; is not &lt;code&gt;NullAllocator&lt;/code&gt;, then &lt;code&gt;KRRegion&lt;/code&gt; is not copyable.</source>
          <target state="translated">&lt;code&gt;ParentAllocator&lt;/code&gt; 의 입력 파라미터는 기본 메모리 청크 할당하는데 사용되는 할당의 타입 &lt;code&gt;KRRegion&lt;/code&gt; 의 개체. 기본값 ( &lt;code&gt;NullAllocator&lt;/code&gt; )을 선택하면 구성시 버퍼를 전달하고 필요한 경우 할당을 해제해야합니다. 그렇지 않으면 &lt;code&gt;KRRegion&lt;/code&gt; 은 파괴 중에 자동으로 버퍼 할당을 해제합니다. 경우 이러한 이유로, &lt;code&gt;ParentAllocator&lt;/code&gt; 가 아닌 &lt;code&gt;NullAllocator&lt;/code&gt; , 다음 &lt;code&gt;KRRegion&lt;/code&gt; 는 복사 가능한 없습니다.</target>
        </trans-unit>
        <trans-unit id="9458766e7479b6cf51af26d50b9dd02e20ae49ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PosInfInterval&lt;/code&gt; to assign to this one.</source>
          <target state="translated">&lt;code&gt;PosInfInterval&lt;/code&gt; 는 이 하나에 할당합니다.</target>
        </trans-unit>
        <trans-unit id="34136f36fcc4fdb9d0545b5f2dc626ce604274eb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PosInfIntervalRange&lt;/code&gt; to assign to this one.</source>
          <target state="translated">&lt;code&gt;PosInfIntervalRange&lt;/code&gt; 는 이 하나에 할당합니다.</target>
        </trans-unit>
        <trans-unit id="8f8c2b1b9fe06bcd45111f1a16dae6ec3e0c641b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SYSTEMTIME&lt;/code&gt; struct to convert.</source>
          <target state="translated">&lt;code&gt;SYSTEMTIME&lt;/code&gt; 의 구조체 변환합니다.</target>
        </trans-unit>
        <trans-unit id="55a36b01203d0bdffacc2ecd4ebaccb88912f8ae" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SYSTEMTIME&lt;/code&gt; which is returned will be set using the given &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;'s time zone, so to get the &lt;code&gt;SYSTEMTIME&lt;/code&gt; in UTC, set the &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;'s time zone to UTC.</source>
          <target state="translated">반환 된 &lt;code&gt;SYSTEMTIME&lt;/code&gt; 은 지정된 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; 시간대를 사용하여 설정 되므로 &lt;code&gt;SYSTEMTIME&lt;/code&gt; 을 UTC 로 가져 오려면 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; 시간대를 UTC로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="17d66eac131ebc5a304d01033bb87ca88a11dafd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SharedBitmappedBlock&lt;/code&gt; cannot allocate more than the given block size. Allocations are satisfied by searching the first unset bit in the bitmap, and atomically setting it. In rare memory pressure scenarios, the allocation could fail.</source>
          <target state="translated">&lt;code&gt;SharedBitmappedBlock&lt;/code&gt; 는 주어진 블록 크기보다 더 많은 할당 할 수 없습니다. 비트 맵에서 첫 번째 설정되지 않은 비트를 검색하고 원자 적으로 설정하여 할당이 충족됩니다. 드문 메모리 압박 시나리오에서는 할당이 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7f50e878b8609c1691f2dd746d7c582ae1ecc004" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Source&lt;/code&gt; range must be at least a &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;ForwardRange&lt;/a&gt; and the &lt;code&gt;windowSize&lt;/code&gt; must be greater than zero.</source>
          <target state="translated">&lt;code&gt;Source&lt;/code&gt; 범위는 적어도 있어야 &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;ForwardRange&lt;/a&gt; 및 &lt;code&gt;windowSize&lt;/code&gt; 은 0보다 커야한다.</target>
        </trans-unit>
        <trans-unit id="c577f5db0ed86295cccdd2e366fd7fb31e9735fc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;StdForwardLogger&lt;/code&gt; will always forward anything to the sharedLog.</source>
          <target state="translated">&lt;code&gt;StdForwardLogger&lt;/code&gt; sharedLog 항상 앞으로 어떤 것이다.</target>
        </trans-unit>
        <trans-unit id="38094d128287502d265daa3f32ff92398be4f485" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;StdForwardLogger&lt;/code&gt; will not throw if data is logged with &lt;code&gt;LogLevel.fatal&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;StdForwardLogger&lt;/code&gt; 는 데이터와 함께 기록되는 경우가 발생하지 않습니다 &lt;code&gt;LogLevel.fatal&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="28d0dc72c49b2f56027f834e227217c1c2c52a44" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Throwable&lt;/code&gt; to test for.</source>
          <target state="translated">&lt;code&gt;Throwable&lt;/code&gt; 에 대한 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="aa29abc0b02ca4a75f09d69735038e1ca2f9e6e7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;TickDuration&lt;/code&gt; to add to or subtract from this &lt;code&gt;TickDuration&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;TickDuration&lt;/code&gt; 에 더하거나 뺄 &lt;code&gt;TickDuration&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="591dfa55a54985010905ae5e062c1737f6d7dd60" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;TickDuration&lt;/code&gt; to add to this &lt;code&gt;Duration&lt;/code&gt; or to subtract this &lt;code&gt;Duration&lt;/code&gt; from.</source>
          <target state="translated">&lt;code&gt;TickDuration&lt;/code&gt; 는 이에 추가 할 &lt;code&gt;Duration&lt;/code&gt; 하거나 뺄 &lt;code&gt;Duration&lt;/code&gt; 에서합니다.</target>
        </trans-unit>
        <trans-unit id="b9bc2f1c8ad28754bf0913173be3fcf66000ab29" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Tuple&lt;/code&gt; to compare against. It must meet the criteria for comparison between &lt;code&gt;Tuple&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;Tuple&lt;/code&gt; 비교할 수 있습니다. &lt;code&gt;Tuple&lt;/code&gt; 간의 비교 기준을 충족해야합니다 .</target>
        </trans-unit>
        <trans-unit id="ae3d87816f53e10c3340c3a534bb4bebe8efe634" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Tuple&lt;/code&gt; to compare against. It must meeting the criteria for comparison between &lt;code&gt;Tuple&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;Tuple&lt;/code&gt; 비교할 수 있습니다. &lt;code&gt;Tuple&lt;/code&gt; 간의 비교 기준을 충족해야합니다 .</target>
        </trans-unit>
        <trans-unit id="71d8abf8af5ee26843c72e0eca8e058ef93a5a47" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Tuple&lt;/code&gt; to concatenate with</source>
          <target state="translated">&lt;code&gt;Tuple&lt;/code&gt; 연결하는과</target>
        </trans-unit>
        <trans-unit id="db6b88026ed5f84aaeb159851306acbc0805b6fb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Tuple&lt;/code&gt; to copy.</source>
          <target state="translated">&lt;code&gt;Tuple&lt;/code&gt; 복사합니다.</target>
        </trans-unit>
        <trans-unit id="cdd1176cdf3efa8b361fda3a58ad58a8bc166a3c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\0&lt;/code&gt; terminated string which is the combination of &lt;code&gt;path&lt;/code&gt; and &lt;code&gt;name&lt;/code&gt; and a valid path.</source>
          <target state="translated">&lt;code&gt;\0&lt;/code&gt; 의 조합으로 끝나는 문자열 &lt;code&gt;path&lt;/code&gt; 와 &lt;code&gt;name&lt;/code&gt; 과 유효한 경로.</target>
        </trans-unit>
        <trans-unit id="6a8b6a5ff2de1aee07ec0a045bd35434cd690030" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__ctfe&lt;/code&gt; boolean pseudo-variable, which evaluates to true in CTFE, but false otherwise, can be used to provide an alternative execution path to avoid operations which are forbidden in CTFE. Every usage of &lt;code&gt;__ctfe&lt;/code&gt; is evaluated before code generation and therefore has no run-time cost, even if no optimizer is used.</source>
          <target state="translated">&lt;code&gt;__ctfe&lt;/code&gt; CTFE의 사실이지만, 그렇지 않으면 거짓으로 평가 의사 부울 변수, CTFE에서 금지 된 피 연산으로 대체 실행 경로를 제공하는데 사용될 수있다. &lt;code&gt;__ctfe&lt;/code&gt; 의 모든 사용법은 코드 생성 전에 평가되므로 최적화 프로그램을 사용하지 않더라도 런타임 비용이 없습니다.</target>
        </trans-unit>
        <trans-unit id="56395a2d3e5a7a87d6c397c8da676b69152f6f63" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;args&lt;/code&gt;/&lt;code&gt;program&lt;/code&gt;/&lt;code&gt;command&lt;/code&gt;, &lt;code&gt;env&lt;/code&gt; and &lt;code&gt;config&lt;/code&gt; parameters are forwarded straight to the underlying spawn functions, and we refer to their documentation for details.</source>
          <target state="translated">&lt;code&gt;args&lt;/code&gt; / &lt;code&gt;program&lt;/code&gt; / &lt;code&gt;command&lt;/code&gt; , &lt;code&gt;env&lt;/code&gt; 및 &lt;code&gt;config&lt;/code&gt; 매개 변수는 기본 스폰 기능에 바로 전달됩니다, 우리는 세부 사항에 대한 자신의 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7314f1cfec56db10eb004f9f77fe84c2b7324dc7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;auto&lt;/code&gt; attribute is used when there are no other attributes and type inference is desired.</source>
          <target state="translated">&lt;code&gt;auto&lt;/code&gt; 다른 속성이없는 경우 속성이 사용됩니다 및 형식 유추가 요구되고있다.</target>
        </trans-unit>
        <trans-unit id="ea97c5895efda9e921b7a4dc07c8ee96fea88239" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;autoInit&lt;/code&gt; option makes the object ensure the store is automatically initialized. Leaving &lt;code&gt;autoInit == RefCountedAutoInitialize.yes&lt;/code&gt; (the default option) is convenient but has the cost of a test whenever the payload is accessed. If &lt;code&gt;autoInit == RefCountedAutoInitialize.no&lt;/code&gt;, user code must call either &lt;code&gt;refCountedStore.isInitialized&lt;/code&gt; or &lt;code&gt;refCountedStore.ensureInitialized&lt;/code&gt; before attempting to access the payload. Not doing so results in null pointer dereference.</source>
          <target state="translated">&lt;code&gt;autoInit&lt;/code&gt; 의 옵션은 객체 저장소가 자동으로 초기화되어 있는지 확인합니다. &lt;code&gt;autoInit == RefCountedAutoInitialize.yes&lt;/code&gt; (기본 옵션)를 그대로 두면 편리하지만 페이로드에 액세스 할 때마다 테스트 비용이 발생합니다. 경우 &lt;code&gt;autoInit == RefCountedAutoInitialize.no&lt;/code&gt; , 사용자 코드 중 하나를 호출해야합니다 &lt;code&gt;refCountedStore.isInitialized&lt;/code&gt; 또는 &lt;code&gt;refCountedStore.ensureInitialized&lt;/code&gt; 을 페이로드에 액세스하기 전에. 그렇게하지 않으면 널 포인터 역 참조가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="69bb3e95d96c480cf1bef8a9a3edaddbb9f73b6b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bringToFront&lt;/code&gt; function can rotate elements in one buffer left or right, swap buffers of equal length, and even move elements across disjoint buffers of different types and different lengths.</source>
          <target state="translated">&lt;code&gt;bringToFront&lt;/code&gt; 의 함수 왼쪽 한 버퍼 소자를 회전 수 또는 오른쪽, 스왑 버퍼와 동일한 길이의, 그리고 심지어는 서로 다른 종류와 다른 길이의 분리 된 버퍼 전체 요소를 움직인다.</target>
        </trans-unit>
        <trans-unit id="cd8ac112f697888bd40d877ce34ac401e4af6717" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bringToFront&lt;/code&gt; function treats strings at the code unit level and it is not concerned with Unicode character integrity. &lt;code&gt;bringToFront&lt;/code&gt; is designed as a function for moving elements in ranges, not as a string function.</source>
          <target state="translated">&lt;code&gt;bringToFront&lt;/code&gt; 기능 취급 코드 단위 수준에서 문자열과은 유니 코드 문자의 무결성과 관련되지 않습니다. &lt;code&gt;bringToFront&lt;/code&gt; 는 문자열 함수가 아닌 범위 내에서 요소를 이동하는 함수로 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="b8d8753eda77a47c9e419e9821af6545c1329322" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;char[]&lt;/code&gt; buffer to store the encoded result.</source>
          <target state="translated">인코딩 된 결과를 저장하기 위한 &lt;code&gt;char[]&lt;/code&gt; 버퍼.</target>
        </trans-unit>
        <trans-unit id="33f594b9c5df8cb09804ec69586a77bc07cf37cc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;choices&lt;/code&gt; needs to be composed of function or delegate handlers that accept one argument. There can also be a choice that accepts zero arguments. That choice will be invoked if the &lt;code&gt; switchObject&lt;/code&gt; is null.</source>
          <target state="translated">&lt;code&gt;choices&lt;/code&gt; 하나 개의 인수를 받아 기능이나 위임 핸들러로 구성 될 필요가있다. 0 개의 인수를 허용하는 선택이있을 수도 있습니다. &lt;code&gt; switchObject&lt;/code&gt; 가 null 인 경우 해당 선택이 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="a7c187f05ee2ebdce065cbd4f9fb2247ea951270" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;class&lt;/code&gt; or &lt;code&gt;interface&lt;/code&gt; to search.</source>
          <target state="translated">&lt;code&gt;class&lt;/code&gt; 또는 &lt;code&gt;interface&lt;/code&gt; 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="861b0eb3583fe72750b180c107e9a74e26b3d067" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;const&lt;/code&gt; attribute changes the type of the declared symbol from &lt;code&gt;T&lt;/code&gt; to &lt;code&gt;const(T)&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; is the type specified (or inferred) for the introduced symbol in the absence of &lt;code&gt;const&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; 속성에서 선언 된 기호의 종류로 변경 &lt;code&gt;T&lt;/code&gt; 에 &lt;code&gt;const(T)&lt;/code&gt; , &lt;code&gt;T&lt;/code&gt; 는 이 없을 도입 심볼의 종류를 지정 (또는 추정)는 &lt;code&gt;const&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d7fc3d859d8514b14477602cc68bff5574b689c8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;deallocate&lt;/code&gt; method only works (and returns &lt;code&gt;true&lt;/code&gt;) on systems that support reducing the break address (i.e. accept calls to &lt;code&gt;sbrk&lt;/code&gt; with negative offsets). OSX does not accept such. In addition the argument must be the last block allocated.</source>
          <target state="translated">&lt;code&gt;deallocate&lt;/code&gt; 방법에만 작동 (반환 &lt;code&gt;true&lt;/code&gt; (즉, 호출을 받아) 지원이 중단 주소를 줄이는 것을 시스템에서 &lt;code&gt;sbrk&lt;/code&gt; 부정적인 오프셋 (offset)). OSX는 그러한 사항을 받아들이지 않습니다. 또한 인수는 마지막으로 할당 된 블록이어야합니다.</target>
        </trans-unit>
        <trans-unit id="3a71092d77b054a66bd8e1792beb78410bdbbbd6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;deallocateAll&lt;/code&gt; method only works (and returns &lt;code&gt;true&lt;/code&gt;) on systems that support reducing the break address (i.e. accept calls to &lt;code&gt;sbrk&lt;/code&gt; with negative offsets). OSX does not accept such.</source>
          <target state="translated">&lt;code&gt;deallocateAll&lt;/code&gt; 의 방법은 (반환 작동 &lt;code&gt;true&lt;/code&gt; (즉, 호출을 받아 지원이 중단 주소를 줄이는 것을 시스템을) &lt;code&gt;sbrk&lt;/code&gt; 음의 오프셋 (offset)를 참조). OSX는 그러한 사항을 받아들이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="48410e02dc31153d6c2f0d60374f83b8eb37aa64" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;debug (&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;debug (&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="315ad37794f53bbab85663b01e324e6f7bf74c8e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;debug&lt;/code&gt; condition is satisfied when the &lt;code&gt;-debug&lt;/code&gt; switch is passed to the compiler or when the debug level is &amp;gt;= 1.</source>
          <target state="translated">&lt;code&gt;debug&lt;/code&gt; 때 조건이 만족된다 &lt;code&gt;-debug&lt;/code&gt; 의 스위치가 컴파일러에 전달 또는 디버그 수준은&amp;gt; = 1이다.</target>
        </trans-unit>
        <trans-unit id="6bda4710254bb8ebb3470f77de80d7eaa7a4b247" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;delete&lt;/code&gt; keyword allowed to free GC-allocated memory. As this is inherently not &lt;code&gt;@safe&lt;/code&gt;, it has been deprecated. This function has been added to provide an easy transition from &lt;code&gt;delete&lt;/code&gt;. It performs the same functionality as the former &lt;code&gt;delete&lt;/code&gt; keyword.</source>
          <target state="translated">&lt;code&gt;delete&lt;/code&gt; 키워드는 무료 GC-할당 된 메모리에 허용했다. 이것은 본질적으로 &lt;code&gt;@safe&lt;/code&gt; 가 아니기 때문에 더 이상 사용되지 않습니다. 이 기능은 &lt;code&gt;delete&lt;/code&gt; 에서 쉽게 전환 할 수 있도록 추가되었습니다 . 이전 &lt;code&gt;delete&lt;/code&gt; 키워드 와 동일한 기능을 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="c34a0df7e835662fcb397ba5e97c59daf56aaba4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;expand&lt;/code&gt; method may only succeed if the argument is the last block allocated. In that case, &lt;code&gt;expand&lt;/code&gt; attempts to push the break pointer to the right.</source>
          <target state="translated">&lt;code&gt;expand&lt;/code&gt; 인수가 할당 된 마지막 블록 인 경우 방법은 성공할 수 있습니다. 이 경우 &lt;code&gt;expand&lt;/code&gt; 은 중단 포인터를 오른쪽으로 밉니다.</target>
        </trans-unit>
        <trans-unit id="cd7ee8c32dffef3320d0fa27b6f6cd2136b61369" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extern (C)&lt;/code&gt; and &lt;code&gt;extern (D)&lt;/code&gt; calling convention matches the C calling convention used by the supported C compiler on the host system. Except that the extern (D) calling convention for Windows x86 is described here.</source>
          <target state="translated">&lt;code&gt;extern (C)&lt;/code&gt; 와 &lt;code&gt;extern (D)&lt;/code&gt; 호출 규칙은 호스트 시스템의 지원 C 컴파일러에 의해 사용되는 C 호출 규칙 일치한다. Windows x86에 대한 extern (D) 호출 규칙은 여기에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="4519ff29f42d0f82fe2fe7d0d145b74eddd798f8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;front&lt;/code&gt; range may actually &quot;step over&quot; the &lt;code&gt;back&lt;/code&gt; range. This is very useful with forward ranges that cannot compute comfortably right-bounded subranges like &lt;code&gt;arr[0 .. 4]&lt;/code&gt; above. In the example below, &lt;code&gt;r2&lt;/code&gt; is a right subrange of &lt;code&gt;r1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;front&lt;/code&gt; 의 범위 일 수있다 실제로 &quot;을 통해 단계&quot; &lt;code&gt;back&lt;/code&gt; 범위. 이는 위의 &lt;code&gt;arr[0 .. 4]&lt;/code&gt; 와 같이 편안하게 오른쪽 범위의 하위 범위를 계산할 수없는 순방향 범위에서 매우 유용합니다 . 아래 예에서 &lt;code&gt;r2&lt;/code&gt; 는 &lt;code&gt;r1&lt;/code&gt; 의 오른쪽 하위 범위입니다 .</target>
        </trans-unit>
        <trans-unit id="a422bf2058400dcd9c56ae2c4fe51eb12fcec1c2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;getopt&lt;/code&gt; function takes a reference to the command line (as received by &lt;code&gt;main&lt;/code&gt;) as its first argument, and an unbounded number of pairs of strings and pointers. Each string is an option meant to &quot;fill&quot; the value referenced by the pointer to its right (the &quot;bound&quot; pointer). The option string in the call to &lt;code&gt;getopt&lt;/code&gt; should not start with a dash.  In all cases, the command-line options that were parsed and used by &lt;code&gt;getopt&lt;/code&gt; are removed from &lt;code&gt;args&lt;/code&gt;. Whatever in the arguments did not look like an option is left in &lt;code&gt;args&lt;/code&gt; for further processing by the program. Values that were unaffected by the options are not touched, so a common idiom is to initialize options to their defaults and then invoke &lt;code&gt;getopt&lt;/code&gt;. If a command-line argument is recognized as an option with a parameter and the parameter cannot be parsed properly (e.g., a number is expected but not present), a &lt;code&gt;ConvException&lt;/code&gt; exception is thrown. If &lt;code&gt;std.getopt.config.passThrough&lt;/code&gt; was not passed to &lt;code&gt;getopt&lt;/code&gt; and an unrecognized command-line argument is found, a &lt;code&gt;GetOptException&lt;/code&gt; is thrown.  Depending on the type of the pointer being bound, &lt;code&gt;getopt&lt;/code&gt; recognizes the following kinds of options:</source>
          <target state="translated">&lt;code&gt;getopt&lt;/code&gt; 는 함수 (AS에 의해 수신 된 명령 라인에 대한 참조 얻어 &lt;code&gt;main&lt;/code&gt; 첫번째 인수) 및 문자열과 포인터 쌍의 수를 무제한. 각 문자열은 오른쪽 포인터 ( &quot;바운드&quot;포인터)가 참조하는 값을 &quot;채우기&quot;위한 옵션입니다. &lt;code&gt;getopt&lt;/code&gt; 호출의 옵션 문자열 은 대시로 시작해서는 안됩니다. 모든 경우에 &lt;code&gt;getopt&lt;/code&gt; 에 의해 구문 분석되고 사용 된 명령 행 옵션 은 &lt;code&gt;args&lt;/code&gt; 에서 제거됩니다 . 인수에서 옵션처럼 보이지 않는 것은 프로그램에 의한 추가 처리를 위해 &lt;code&gt;args&lt;/code&gt; 에 남아 있습니다. 옵션에 영향을받지 않은 값은 건드리지 않으므로 일반적인 관용구는 옵션을 기본값으로 초기화 한 다음 호출하는 것입니다. &lt;code&gt;getopt&lt;/code&gt; . 명령 행 인수가 매개 변수가있는 옵션으로 인식되고 매개 변수를 올바르게 구문 분석 할 수없는 경우 (예 : 숫자가 예상되지만 존재하지 않는 경우) &lt;code&gt;ConvException&lt;/code&gt; 예외가 발생합니다. 경우 &lt;code&gt;std.getopt.config.passThrough&lt;/code&gt; 가 전달되지 &lt;code&gt;getopt&lt;/code&gt; 를 하고 알 수없는 명령 줄 인수가 발견하는 &lt;code&gt;GetOptException&lt;/code&gt; 가 발생합니다. 바인딩되는 포인터의 유형에 따라 &lt;code&gt;getopt&lt;/code&gt; 는 다음과 같은 옵션을 인식합니다.</target>
        </trans-unit>
        <trans-unit id="7b73bb7244dae978ce076efe98de379e4d338f0d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;immutable&lt;/code&gt; attribute modifies the type from &lt;code&gt;T&lt;/code&gt; to &lt;code&gt;immutable(T)&lt;/code&gt;, the same way as &lt;code&gt;const&lt;/code&gt; does.</source>
          <target state="translated">&lt;code&gt;immutable&lt;/code&gt; 특성 수정의 타입 &lt;code&gt;T&lt;/code&gt; 에 &lt;code&gt;immutable(T)&lt;/code&gt; 과 동일한 방법 &lt;code&gt;const&lt;/code&gt; 않는다.</target>
        </trans-unit>
        <trans-unit id="0664217c953262d37218988e224b35fd637e53a6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;in&lt;/code&gt; and &lt;code&gt;out&lt;/code&gt; blocks or expressions of a function declaration specify the pre- and post-conditions of the function. They are used in &lt;a href=&quot;contracts&quot;&gt;Contract Programming&lt;/a&gt;. The code inside these blocks should not have any side-effects, including modifying function parameters and/or return values.</source>
          <target state="translated">&lt;code&gt;in&lt;/code&gt; 와 &lt;code&gt;out&lt;/code&gt; 블록 또는 함수 선언의 표현은 함수의 사전 및 사후 조건을 지정합니다. 이들은 &lt;a href=&quot;contracts&quot;&gt;계약 프로그래밍에&lt;/a&gt; 사용됩니다 . 이 블록 내부의 코드는 함수 매개 변수 및 / 또는 반환 값 수정을 포함하여 부작용이 없어야합니다.</target>
        </trans-unit>
        <trans-unit id="6872874b153fc0effbd03e646763ee703dd8bc2f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;in&lt;/code&gt; expression has the same precedence as the relational expressions &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;, etc. The return value of the</source>
          <target state="translated">&lt;code&gt;in&lt;/code&gt; 발현은 관계식 같은 우선 갖는 &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;code&gt;=&lt;/code&gt; 등의 반환 값</target>
        </trans-unit>
        <trans-unit id="b4eb3584bffc0aa6958eaab390a905eaa7fcc692" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;inout&lt;/code&gt; attribute modifies the type from &lt;code&gt;T&lt;/code&gt; to &lt;code&gt;inout(T)&lt;/code&gt;, the same way as &lt;code&gt;const&lt;/code&gt; does.</source>
          <target state="translated">&lt;code&gt;inout&lt;/code&gt; 특성 수정의 타입 &lt;code&gt;T&lt;/code&gt; 에 &lt;code&gt;inout(T)&lt;/code&gt; 과 동일한 방법 &lt;code&gt;const&lt;/code&gt; 않는다.</target>
        </trans-unit>
        <trans-unit id="968551598c2a43f06e8bf24ad9377e47b780c3d6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;inout&lt;/code&gt; qualifier may be applied to the copy constructor parameter in order to specify that mutable, &lt;code&gt;const&lt;/code&gt;, or &lt;code&gt;immutable&lt;/code&gt; types are treated the same:</source>
          <target state="translated">&lt;code&gt;inout&lt;/code&gt; 규정은 그 가변 지정하기 위해 복사 생성자 파라미터에 적용될 수있다 &lt;code&gt;const&lt;/code&gt; 하거나 &lt;code&gt;immutable&lt;/code&gt; 유형은 동일하게 취급된다 :</target>
        </trans-unit>
        <trans-unit id="22a687fc90a97249a3ef72c2d4b1df43d3df5e8e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;instance&lt;/code&gt; singleton is defined if and only if the parent allocator has no state and defines its own &lt;code&gt;it&lt;/code&gt; object.</source>
          <target state="translated">&lt;code&gt;instance&lt;/code&gt; 싱글이 정의 된 경우 부모의 할당이 더 상태가없고 자신의 정의에만 &lt;code&gt;it&lt;/code&gt; 개체를.</target>
        </trans-unit>
        <trans-unit id="ec8dde286332c5aa08ae3177ee5fc7a106f040a5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;is&lt;/code&gt; compares for identity. To compare for nonidentity, use &lt;code&gt;e1 !is e2&lt;/code&gt;. The type of the result is &lt;code&gt;bool&lt;/code&gt;. The operands undergo the &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;Usual Arithmetic Conversions&lt;/a&gt; to bring them to a common type before comparison.</source>
          <target state="translated">&lt;code&gt;is&lt;/code&gt; ID에 대해 비교합니다. 비 식별성을 비교하려면 &lt;code&gt;e1 !is e2&lt;/code&gt; . 결과 유형은 &lt;code&gt;bool&lt;/code&gt; 입니다. 피연산자는 &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;일반적인 산술 변환&lt;/a&gt; 을 거쳐 비교 전에 공통 유형으로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="9ae177266bdeb39f87e4a184c6c378055487c7b3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;main()&lt;/code&gt; function to be written in D, to ensure that the required runtime library support is properly initialized.</source>
          <target state="translated">필수 런타임 라이브러리 지원이 올바르게 초기화되도록 D로 작성 되는 &lt;code&gt;main()&lt;/code&gt; 함수</target>
        </trans-unit>
        <trans-unit id="891cbd158fc64142d63f3931abe9b04d4c81c222" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;minAlign&lt;/code&gt; parameter establishes alignment. If &lt;code&gt;minAlign &amp;gt; 1&lt;/code&gt;, the sizes of all allocation requests are rounded up to a multiple of &lt;code&gt;minAlign&lt;/code&gt;. Applications aiming at maximum speed may want to choose &lt;code&gt;minAlign = 1&lt;/code&gt; and control alignment externally.</source>
          <target state="translated">&lt;code&gt;minAlign&lt;/code&gt; 파라미터 설정 정렬. 경우 &lt;code&gt;minAlign &amp;gt; 1&lt;/code&gt; , 모든 할당 요청의 크기는의 배수로 올림 &lt;code&gt;minAlign&lt;/code&gt; . 최대 속도를 목표로하는 응용 프로그램은 &lt;code&gt;minAlign = 1&lt;/code&gt; 을 선택 하고 외부에서 정렬을 제어 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ed92125a36b5eb56c36761322b3938f1b464f6a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;node&lt;/code&gt; parameter passed to &lt;code&gt;getAddressInfo&lt;/code&gt; must be a numeric string. This will suppress any potentially lengthy network host address lookups.</source>
          <target state="translated">&lt;code&gt;getAddressInfo&lt;/code&gt; 에 전달 된 &lt;code&gt;node&lt;/code&gt; 매개 변수 는 숫자 문자열이어야합니다. 이렇게하면 잠재적으로 긴 네트워크 호스트 주소 조회가 억제됩니다.</target>
        </trans-unit>
        <trans-unit id="23d6155dbf6f6df9508b72a12de4d979d7730735" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;octal&lt;/code&gt; facility provides a means to declare a number in base 8. Using &lt;code&gt;octal!177&lt;/code&gt; or &lt;code&gt;octal!&quot;177&quot;&lt;/code&gt; for 127 represented in octal (same as 0177 in C).</source>
          <target state="translated">&lt;code&gt;octal&lt;/code&gt; 시설 수단 사용베이스 제에 숫자를 선언 제공 &lt;code&gt;octal!177&lt;/code&gt; 또는 &lt;code&gt;octal!&quot;177&quot;&lt;/code&gt; 진수 (C 0177에서와 같음)로 표시되는 127.</target>
        </trans-unit>
        <trans-unit id="129480b440f262e2ead128e12ea6c5cdcf95c4b4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;override&lt;/code&gt; attribute applies to virtual functions. It means that the function must override a function with the same name and parameters in a base class. The override attribute is useful for catching errors when a base class's member function gets its parameters changed, and all derived classes need to have their overriding functions updated.</source>
          <target state="translated">&lt;code&gt;override&lt;/code&gt; 속성은 가상 함수에 적용됩니다. 이는 함수가 기본 클래스에서 이름과 매개 변수가 동일한 함수를 대체해야 함을 의미합니다. override 속성은 기본 클래스의 멤버 함수가 매개 변수를 변경하고 모든 파생 클래스가 재정의 함수를 업데이트해야 할 때 오류를 잡는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="4c39c9bb95cd597c07eafdff4f38811d99e1f3d6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;parent&lt;/code&gt; keyword is actually a delegate to the super class' corresponding member function. [&lt;a href=&quot;https://issues.dlang.org/show_bug.cgi?id=2540&quot;&gt;Bugzilla 2540&lt;/a&gt;]</source>
          <target state="translated">&lt;code&gt;parent&lt;/code&gt; 키워드는 실제로 멤버 함수를 해당 수퍼 클래스 '에 대리자입니다. [ &lt;a href=&quot;https://issues.dlang.org/show_bug.cgi?id=2540&quot;&gt;Bugzilla 2540&lt;/a&gt; ]</target>
        </trans-unit>
        <trans-unit id="5345bebedd7933fe7e2ab3bb75fb53c48ea8dd27" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;parse&lt;/code&gt; family of functions works quite like the &lt;code&gt;to&lt;/code&gt; family, except that:</source>
          <target state="translated">&lt;code&gt;parse&lt;/code&gt; 기능의 제품군은 꽤처럼 작동 &lt;code&gt;to&lt;/code&gt; 것을 제외하고, 가족 :</target>
        </trans-unit>
        <trans-unit id="53d890775a2e90ce1cd5bfe92ca5bcf1994e918a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;printf&lt;/code&gt; format string literal in the example doesn't end with &lt;code&gt;'\0'&lt;/code&gt;. This is because string literals, when they are not part of an initializer to a larger data structure, have a &lt;code&gt;'\0'&lt;/code&gt; character helpfully stored after the end of them.</source>
          <target state="translated">예제 의 &lt;code&gt;printf&lt;/code&gt; 형식 문자열 리터럴은 &lt;code&gt;'\0'&lt;/code&gt; 끝나지 않습니다 . 이는 문자열 리터럴이 더 큰 데이터 구조에 대한 이니셜 라이저의 일부가 아닌 경우 종료 후 &lt;code&gt;'\0'&lt;/code&gt; 문자를 유용하게 저장하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="c2194ef1e4ad8716f788317053d9495fb71b6327" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;printf&lt;/code&gt;-style string.</source>
          <target state="translated">&lt;code&gt;printf&lt;/code&gt; 스타일의 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="645634d091eae4e17c9ec0b97603c409a84aae33" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pure&lt;/code&gt;, &lt;code&gt;@safe&lt;/code&gt;, &lt;code&gt;@nogc&lt;/code&gt;, or &lt;code&gt;nothrow&lt;/code&gt; attributes cannot be inferred for &lt;code&gt;lockstep&lt;/code&gt; iteration. &lt;a href=&quot;#zip&quot;&gt;&lt;code&gt;zip&lt;/code&gt;&lt;/a&gt; can infer the first two due to a different implementation.</source>
          <target state="translated">&lt;code&gt;pure&lt;/code&gt; , &lt;code&gt;@safe&lt;/code&gt; , &lt;code&gt;@nogc&lt;/code&gt; , 또는 &lt;code&gt;nothrow&lt;/code&gt; 속성에 대해 추론 할 수 없습니다 &lt;code&gt;lockstep&lt;/code&gt; 반복. &lt;a href=&quot;#zip&quot;&gt; &lt;code&gt;zip&lt;/code&gt; &lt;/a&gt; 은 다른 구현으로 인해 처음 두 개를 유추 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2882b6054016e631f0c09f82c6edaf8c162ba826" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;range&lt;/code&gt; must be a &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward range&lt;/a&gt;. The separator can be a value of the same type as the elements in &lt;code&gt;range&lt;/code&gt; or it can be another forward &lt;code&gt;range&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;range&lt;/code&gt; 해야 &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;전진 기어&lt;/a&gt; . 구분 기호는 &lt;code&gt;range&lt;/code&gt; 의 요소와 동일한 유형의 값 이거나 다른 포워드 &lt;code&gt;range&lt;/code&gt; 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="796a30adc82abcfecaf4ae7e5c2930fc3ed789ba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;schwartzSort&lt;/code&gt; function might require less temporary data and be faster than the Perl idiom or the decorate-sort-undecorate idiom present in Python and Lisp. This is because sorting is done in-place and only minimal extra data (one array of transformed elements) is created.  To check whether an array was sorted and benefit of the speedup of Schwartz sorting, a function &lt;code&gt;schwartzIsSorted&lt;/code&gt; is not provided because the effect can be achieved by calling &lt;code&gt;isSorted!less(map!transform(r))&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;schwartzSort&lt;/code&gt; 의 기능은 덜 임시 데이터를 필요로 빠르게 펄 관용구 나 파이썬과 리스프의 장식-정렬 undecorate 관용구 존재하는 것보다 수 있습니다. 정렬이 제자리에서 이루어지고 최소한의 추가 데이터 (한 개의 변환 된 요소 배열)가 만들어지기 때문입니다. 배열이 정렬되었는지와 Schwartz 정렬 속도를 향상시키는 이점을 확인 하기 위해 &lt;code&gt;isSorted!less(map!transform(r))&lt;/code&gt; 를 호출하여 효과를 얻을 수 있으므로 &lt;code&gt;schwartzIsSorted&lt;/code&gt; 함수 가 제공되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="2fddaad8a8ed56f77847f6655dad35e2662c33eb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;scope&lt;/code&gt; attribute is used for local variables and for class declarations. For class declarations, the &lt;code&gt;scope&lt;/code&gt; attribute creates a</source>
          <target state="translated">&lt;code&gt;scope&lt;/code&gt; 속성은 지역 변수와 클래스 선언에 사용됩니다. 클래스 선언의 경우 &lt;code&gt;scope&lt;/code&gt; 속성은</target>
        </trans-unit>
        <trans-unit id="3fa8f7d1b74d1a9ee8b770bcbe3131eb50e5e608" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;scope&lt;/code&gt; storage class on the</source>
          <target state="translated">의 &lt;code&gt;scope&lt;/code&gt; 스토리지 클래스</target>
        </trans-unit>
        <trans-unit id="7e245aa06638dcfada88df8c50a10a266377829d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;seg&lt;/code&gt; means load the segment number that the symbol is in. This is not relevant for flat model code. Instead, do a move from the relevant segment register.</source>
          <target state="translated">&lt;code&gt;seg&lt;/code&gt; 수단은 기호에 있는지 세그먼트 번호를 넣습니다.이 평면 모델 코드와 관련이 없습니다. 대신 관련 세그먼트 레지스터에서 이동하십시오.</target>
        </trans-unit>
        <trans-unit id="f1165047c539bab5d19432fe9cd8e8d0c00bd8b6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;shared&lt;/code&gt; attribute modifies the type from &lt;code&gt;T&lt;/code&gt; to &lt;code&gt;shared(T)&lt;/code&gt;, the same way as &lt;code&gt;const&lt;/code&gt; does.</source>
          <target state="translated">&lt;code&gt;shared&lt;/code&gt; 속성 수정의 타입 &lt;code&gt;T&lt;/code&gt; 에 &lt;code&gt;shared(T)&lt;/code&gt; ,와 같은 방법으로 &lt;code&gt;const&lt;/code&gt; 않습니다.</target>
        </trans-unit>
        <trans-unit id="1e208afb75193f3bc51ca510ccfe04a767a6a006" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;stat&lt;/code&gt; struct gotten from calling &lt;code&gt;stat&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;stat&lt;/code&gt; 구조체 호출에서받은 &lt;code&gt;stat&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8ee90ec4fd6fa01114c3ec0cf16e2c2fffb84458" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;static&lt;/code&gt; attribute applies to functions and data. It means that the declaration does not apply to a particular instance of an object, but to the type of the object. In other words, it means there is no &lt;code&gt;this&lt;/code&gt; reference. &lt;code&gt;static&lt;/code&gt; is ignored when applied to other declarations.</source>
          <target state="translated">&lt;code&gt;static&lt;/code&gt; 특성 함수와 데이터에 적용된다. 이는 선언이 객체의 특정 인스턴스에 적용되지 않고 객체 유형에 적용됨을 의미합니다. 즉, &lt;code&gt;this&lt;/code&gt; 참조 가 없음을 의미 합니다. 다른 선언에 적용될 때는 &lt;code&gt;static&lt;/code&gt; 이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="a7bd38d68869d8f5055deb4d9c87d32c72ed47d5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;static&lt;/code&gt; in the static constructor declaration is not an attribute, it must appear immediately before the &lt;code&gt;this&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;static&lt;/code&gt; 정적 생성자 선언 그것이 바로 앞에 나타나야합니다, 속성없는 &lt;code&gt;this&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="78a76bba5ffa9cb0f5429288aefeb29752e20041" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;static&lt;/code&gt; in the static destructor declaration is not an attribute, it must appear immediately before the &lt;code&gt;~this&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;static&lt;/code&gt; 정적 소멸자 선언은이 직전에 표시해야하는 속성 아니다 &lt;code&gt;~this&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="6bca96c9851b526872a5466004ed8fbfdad08557" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;std.uni&lt;/code&gt; module provides an implementation of fundamental Unicode algorithms and data structures. This doesn't include UTF encoding and decoding primitives, see &lt;a href=&quot;std_utf#decode&quot;&gt;&lt;code&gt;std.utf.decode&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;std_utf#encode&quot;&gt;&lt;code&gt;std.utf.encode&lt;/code&gt;&lt;/a&gt; in &lt;a href=&quot;std_utf&quot;&gt;&lt;code&gt;std.utf&lt;/code&gt;&lt;/a&gt; for this functionality.</source>
          <target state="translated">&lt;code&gt;std.uni&lt;/code&gt; 모듈은 유니 기본적인 알고리즘 및 데이터 구조들의 구현을 제공한다. 이것은, UTF 인코딩 및 디코딩을 포함 프리미티브 보지 않는다 &lt;a href=&quot;std_utf#decode&quot;&gt; &lt;code&gt;std.utf.decode&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;std_utf#encode&quot;&gt; &lt;code&gt;std.utf.encode&lt;/code&gt; &lt;/a&gt; 에 &lt;a href=&quot;std_utf&quot;&gt; &lt;code&gt;std.utf&lt;/code&gt; 를&lt;/a&gt; 이 기능에 대한.</target>
        </trans-unit>
        <trans-unit id="e752dcef30e45214ff3e8ec23bf1ea7507c8d89b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;stdName&lt;/code&gt; for this time zone.</source>
          <target state="translated">이 시간대 의 &lt;code&gt;stdName&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="050f0ed338278e2be6b6c047057d2f449c86d2d0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;stripLeft&lt;/code&gt; function will strip the &lt;code&gt;front&lt;/code&gt; of the range, the &lt;code&gt;stripRight&lt;/code&gt; function will strip the &lt;code&gt;back&lt;/code&gt; of the range, while the &lt;code&gt;strip&lt;/code&gt; function will strip both the &lt;code&gt;front&lt;/code&gt; and &lt;code&gt;back&lt;/code&gt; of the range.</source>
          <target state="translated">&lt;code&gt;stripLeft&lt;/code&gt; 의 스트립 것이다 함수 &lt;code&gt;front&lt;/code&gt; 범위는 &lt;code&gt;stripRight&lt;/code&gt; 의 함수 벗길 &lt;code&gt;back&lt;/code&gt; 그동안, 범위를 &lt;code&gt;strip&lt;/code&gt; 기능을 모두 제거한다 &lt;code&gt;front&lt;/code&gt; 과 &lt;code&gt;back&lt;/code&gt; 범위를.</target>
        </trans-unit>
        <trans-unit id="839ed0bb56b103a8eece57297954fc01f25ea05d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;synchronized&lt;/code&gt; attribute can only be applied to classes, structs cannot be marked to be synchronized.</source>
          <target state="translated">&lt;code&gt;synchronized&lt;/code&gt; 특성 클래스 만에 적용될 수 구조체 동기화되도록 표시 될 수 없다.</target>
        </trans-unit>
        <trans-unit id="9011fa2589704334e3e103c4c208b6c05b6bc3a9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;this&lt;/code&gt; of this &lt;code&gt;SysTime&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; 이것의 &lt;code&gt;SysTime&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="771910a8002a7122d3a609081a9732bd40452d54" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;this&lt;/code&gt; parameter for methods or nested functions.</source>
          <target state="translated">메소드 또는 중첩 함수 의 &lt;code&gt;this&lt;/code&gt; 매개 변수입니다.</target>
        </trans-unit>
        <trans-unit id="86abf02caae05395778f7a7acd623fbca99d9de9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;to&lt;/code&gt; template converts a value from one type to another. The source type is deduced and the target type must be specified, for example the expression &lt;code&gt;to!int(42.0)&lt;/code&gt; converts the number 42 from &lt;code&gt;double&lt;/code&gt; to &lt;code&gt;int&lt;/code&gt;. The conversion is &quot;safe&quot;, i.e., it checks for overflow; &lt;code&gt;to!int(4.2e10)&lt;/code&gt; would throw the &lt;code&gt;ConvOverflowException&lt;/code&gt; exception. Overflow checks are only inserted when necessary, e.g., &lt;code&gt;to!double(42)&lt;/code&gt; does not do any checking because any &lt;code&gt;int&lt;/code&gt; fits in a &lt;code&gt;double&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;to&lt;/code&gt; 템플릿은 한 가지 유형에서 다른 값을 변환합니다. 소스 유형이 추론되고 대상 유형을 지정해야합니다. 예를 들어, 표현식 &lt;code&gt;to!int(42.0)&lt;/code&gt; 은 숫자 42를 &lt;code&gt;double&lt;/code&gt; 에서 &lt;code&gt;int&lt;/code&gt; 로 변환합니다 . 변환은 &quot;안전&quot;합니다. 즉, 오버플로를 확인합니다. &lt;code&gt;to!int(4.2e10)&lt;/code&gt; 은 &lt;code&gt;ConvOverflowException&lt;/code&gt; 예외를 발생시킵니다. 오버플로 검사는 필요한 경우에만 삽입됩니다. 예를 들어, &lt;code&gt;int&lt;/code&gt; 가 &lt;code&gt;double&lt;/code&gt; 에 맞기 때문에 &lt;code&gt;to!double(42)&lt;/code&gt; 은 검사를 수행하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="c72681bce14ab24a3265bfe0c7fc387d069da68a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;upTo&lt;/code&gt; parameter is useful to &quot;cut the losses&quot; in case the interest is in seeing whether the range has at least some number of elements. If the parameter &lt;code&gt;upTo&lt;/code&gt; is specified, stops if &lt;code&gt;upTo&lt;/code&gt; steps have been taken and returns &lt;code&gt;upTo&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;upTo&lt;/code&gt; 파라미터는 관심 범위 원소 중 적어도 일부를 수 있는지 여부를 보는 것이다 경우 &quot;손실을 절단&quot;하는 것이 유용하다. 매개 변수 경우 &lt;code&gt;upTo&lt;/code&gt; 지정되어있는 경우 중지 &lt;code&gt;upTo&lt;/code&gt; 단계를 촬영 한 리턴 &lt;code&gt;upTo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ec39fe5b28d95636f3cf30df0999156fd8536f9f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;version(unittest)&lt;/code&gt; is satisfied if and only if the code is compiled with unit tests enabled (the &lt;a href=&quot;https://dlang.org/dmd.html#switch-unittest&quot;&gt;&lt;em&gt;-unittest&lt;/em&gt;&lt;/a&gt; option on &lt;em&gt;dmd&lt;/em&gt;).</source>
          <target state="translated">&lt;code&gt;version(unittest)&lt;/code&gt; 코드가 단위 테스트로 컴파일 만하고 (활성화 된 경우 만족 &lt;a href=&quot;https://dlang.org/dmd.html#switch-unittest&quot;&gt;&lt;em&gt;-unittest&lt;/em&gt;&lt;/a&gt; 에 옵션 &lt;em&gt;DMD를&lt;/em&gt; ).</target>
        </trans-unit>
        <trans-unit id="a777caaefbb263c6a96ad677845f9139788a6836" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;with&lt;/code&gt; statement is a way to simplify repeated references to the same object.</source>
          <target state="translated">&lt;code&gt;with&lt;/code&gt; 문은 동일한 개체에 반복 참조를 단순화하는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="b5c453abc4924350428091525f5adaaf66e0085f" translate="yes" xml:space="preserve">
          <source>The AA indicating which characters to replace and what to replace them with.</source>
          <target state="translated">대체 할 문자와 대체 할 문자를 나타내는 AA.</target>
        </trans-unit>
        <trans-unit id="3cd598fe8a3a2f9cbd7fd135237f3d6a48d2526a" translate="yes" xml:space="preserve">
          <source>The ARM &lt;code&gt;hardfp&lt;/code&gt; floating point ABI</source>
          <target state="translated">ARM &lt;code&gt;hardfp&lt;/code&gt; 부동 소수점 ABI</target>
        </trans-unit>
        <trans-unit id="080cd6006fb8edfc56cbc88495f7c0f1e4064bf0" translate="yes" xml:space="preserve">
          <source>The ARM &lt;code&gt;soft&lt;/code&gt; floating point ABI</source>
          <target state="translated">ARM &lt;code&gt;soft&lt;/code&gt; 부동 소수점 ABI</target>
        </trans-unit>
        <trans-unit id="4315576cc7f55930516266d81e5293d6035553b5" translate="yes" xml:space="preserve">
          <source>The ARM &lt;code&gt;softfp&lt;/code&gt; floating point ABI</source>
          <target state="translated">ARM &lt;code&gt;softfp&lt;/code&gt; 부동 소수점 ABI</target>
        </trans-unit>
        <trans-unit id="1aee526a398ffb0d8989324764e692631fcec3dc" translate="yes" xml:space="preserve">
          <source>The ARM architecture (32-bit) (AArch32 et al)</source>
          <target state="translated">ARM 아키텍처 (32 비트) (AArch32 외)</target>
        </trans-unit>
        <trans-unit id="140d76b4f076d2fb8060abf8ae55a752d2839ebb" translate="yes" xml:space="preserve">
          <source>The ASTBase family defines a family of AST nodes appropriate for parsing with no semantic information. It defines all the AST nodes that the parser needs and also all the conveniance methods and variables. The resulting AST can be visited with the strict, permissive and transitive visitors. The ASTBase family is used to instantiate the parser in the parser library.</source>
          <target state="translated">ASTBase 제품군은 의미 정보가없는 구문 분석에 적합한 AST 노드 제품군을 정의합니다. 파서에 필요한 모든 AST 노드와 모든 편의 방법 및 변수를 정의합니다. 결과 AST는 엄격하고 허용 적이며 전이적인 방문자와 함께 방문 할 수 있습니다. ASTBase 제품군은 파서 라이브러리에서 파서를 인스턴스화하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c3be1c951cff3d8aa070819c54cb8919e689dc11" translate="yes" xml:space="preserve">
          <source>The Advanced RISC Machine architecture (64-bit)</source>
          <target state="translated">고급 RISC 머신 아키텍처 (64 비트)</target>
        </trans-unit>
        <trans-unit id="7ad070d4c966b73f1a0e81ee952f683fc75493b1" translate="yes" xml:space="preserve">
          <source>The Alpha architecture</source>
          <target state="translated">알파 아키텍처</target>
        </trans-unit>
        <trans-unit id="75879c280e92f1cb9eedc61a237d7ab029b22e63" translate="yes" xml:space="preserve">
          <source>The Alpha hard float ABI</source>
          <target state="translated">알파 하드 플로트 ABI</target>
        </trans-unit>
        <trans-unit id="62c77bede3b6cdc2acf3c10062577e4523986150" translate="yes" xml:space="preserve">
          <source>The Alpha soft float ABI</source>
          <target state="translated">알파 소프트 플로트 ABI</target>
        </trans-unit>
        <trans-unit id="c01dada0c094f9d64c05e42515804aed98403159" translate="yes" xml:space="preserve">
          <source>The Android platform</source>
          <target state="translated">안드로이드 플랫폼</target>
        </trans-unit>
        <trans-unit id="6f8a189af46fa6b0fd80d35f5b80e9c56ef0f48e" translate="yes" xml:space="preserve">
          <source>The C ABI referred to in this specification means the C Application Binary Interface of the target system. C and D code should be freely linkable together, in particular, D code shall have access to the entire C ABI runtime library.</source>
          <target state="translated">본 명세서에서 언급 된 C ABI는 대상 시스템의 C 애플리케이션 바이너리 인터페이스를 의미한다. C와 D 코드는 자유롭게 연결 가능해야하며, 특히 D 코드는 전체 C ABI 런타임 라이브러리에 액세스 할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="b31779cdd7255c8710f71ffcb42a8c3c176e037b" translate="yes" xml:space="preserve">
          <source>The C function must be declared and given a calling convention, most likely the &quot;C&quot; calling convention, for example:</source>
          <target state="translated">C 함수는 다음과 같이 호출 규칙, &quot;C&quot;호출 규칙과 같이 선언되어야합니다.</target>
        </trans-unit>
        <trans-unit id="b73111d71bd053626a250414ea9482ee128f3a9d" translate="yes" xml:space="preserve">
          <source>The C heap allocator, a.k.a. &lt;code&gt;malloc&lt;/code&gt;/&lt;code&gt;realloc&lt;/code&gt;/&lt;code&gt;free&lt;/code&gt;. Use sparingly and only for code that is unlikely to leak.</source>
          <target state="translated">C 힙 할당 자, 일명 &lt;code&gt;malloc&lt;/code&gt; / &lt;code&gt;realloc&lt;/code&gt; / &lt;code&gt;free&lt;/code&gt; . 누출 가능성이 적은 코드에만 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="9bcae0904b97d122e7ac2cf8f770976e290fa9d4" translate="yes" xml:space="preserve">
          <source>The C heap allocator.</source>
          <target state="translated">C 힙 할당 자.</target>
        </trans-unit>
        <trans-unit id="d3d9a3eb3d745c74b8f9c5ffaed6de680eef5f7e" translate="yes" xml:space="preserve">
          <source>The C standard does not specify the representation of time_t, so it is implementation defined. On POSIX systems, unix time is equivalent to time_t, but that's not necessarily true on other systems (e.g. it is not true for the Digital Mars C runtime). So, be careful when using unix time with C functions on non-POSIX systems.</source>
          <target state="translated">C 표준은 time_t의 표현을 지정하지 않으므로 구현이 정의됩니다. POSIX 시스템에서 유닉스 시간은 time_t와 동일하지만 다른 시스템에서는 반드시 그렇지는 않습니다 (예 : Digital Mars C 런타임에서는 그렇지 않습니다). 따라서 비 POSIX 시스템에서 C 함수와 함께 유닉스 시간을 사용할 때주의하십시오.</target>
        </trans-unit>
        <trans-unit id="268d31350a547e3c72b722824c24bd316ded8af7" translate="yes" xml:space="preserve">
          <source>The C style syntax for declaring pointers to functions is deprecated:</source>
          <target state="translated">함수에 대한 포인터를 선언하기위한 C 스타일 구문은 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fe2a0b7eccecf9a4981d7246d1ba9612d79f4687" translate="yes" xml:space="preserve">
          <source>The C++ calling convention is the default convention for its member functions, rather than the D calling convention.</source>
          <target state="translated">C ++ 호출 규칙은 D 호출 규칙이 아니라 멤버 함수의 기본 규칙입니다.</target>
        </trans-unit>
        <trans-unit id="8e79898d7d2dc499b7d995326a3a49d8e19d01cf" translate="yes" xml:space="preserve">
          <source>The C++ code to access it looks like:</source>
          <target state="translated">액세스하는 C ++ 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="744ee5429ee5de2789ebe3998584f1507a9905e0" translate="yes" xml:space="preserve">
          <source>The C++ end looks like:</source>
          <target state="translated">C ++ 끝은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fd9a5a8084540da9e33cf1c4a0dafe5ab694bd12" translate="yes" xml:space="preserve">
          <source>The C++ version of D's ExceptionHeader wrapper</source>
          <target state="translated">D의 ExceptionHeader 래퍼의 C ++ 버전</target>
        </trans-unit>
        <trans-unit id="8095ddeea5e0e04c215a664a1828938a9f629b34" translate="yes" xml:space="preserve">
          <source>The CApath directory used to validate the peer certificate this option is used only if SSL_VERIFYPEER is true</source>
          <target state="translated">피어 인증서의 유효성을 검증하는 데 사용되는 CApath 디렉토리이 옵션은 SSL_VERIFYPEER가 true 인 경우에만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0f5b63bc94368c961989a6c61e45ef163a38eec9" translate="yes" xml:space="preserve">
          <source>The CApath or CAfile used to validate the peer certificate this option is used only if SSL_VERIFYPEER is true</source>
          <target state="translated">피어 인증서의 유효성을 검증하는 데 사용되는 CApath 또는 CA 파일이 옵션은 SSL_VERIFYPEER가 true 인 경우에만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2735c767df771513d95177efb3609e6484a0ab5e" translate="yes" xml:space="preserve">
          <source>The CLI flag without leading &lt;code&gt;-&lt;/code&gt;, e.g. &lt;code&gt;color&lt;/code&gt;</source>
          <target state="translated">선두없는 CLI 플래그 &lt;code&gt;-&lt;/code&gt; 예 &lt;code&gt;color&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="204d490b010260c1f0d9da99a97fcbf057fe1425" translate="yes" xml:space="preserve">
          <source>The ClassKind enum is used in AggregateDeclaration AST nodes to specify the linkage type of the struct/class/interface or if it is an anonymous class. If the class is anonymous it is also considered to be a D class.</source>
          <target state="translated">ClassKind 열거 형은 AggregateDeclaration AST 노드에서 구조체 / 클래스 / 인터페이스의 연결 유형을 지정하거나 익명 클래스 인 경우에 사용됩니다. 클래스가 익명 인 경우 D 클래스로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="19b53b7f22b6ad230e9b7d3050f57e3d9ed3e6a2" translate="yes" xml:space="preserve">
          <source>The Cygwin environment</source>
          <target state="translated">Cygwin 환경</target>
        </trans-unit>
        <trans-unit id="4cedce22f0215a765398ea9fe9f300cfe9ad0637" translate="yes" xml:space="preserve">
          <source>The D &lt;b&gt;dchar&lt;/b&gt; type is represented by the special primitive type 0x78.</source>
          <target state="translated">D &lt;b&gt;dchar&lt;/b&gt; 유형은 특수 기본 유형 0x78로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="c3537395621b252f9ec47bd7365cace4c8165f58" translate="yes" xml:space="preserve">
          <source>The D Error Handling Solution</source>
          <target state="translated">D 오류 처리 솔루션</target>
        </trans-unit>
        <trans-unit id="981d02056effa5ba62bb1118da0c8017aedaaf90" translate="yes" xml:space="preserve">
          <source>The D compiler is free to rearrange the order of fields in a class to optimally pack them in an implementation-defined manner. Consider the fields much like the local variables in a function - the compiler assigns some to registers and shuffles others around all to get the optimal stack frame layout. This frees the code designer to organize the fields in a manner that makes the code more readable rather than being forced to organize it according to machine optimization rules. Explicit control of field layout is provided by struct/union types, not classes.</source>
          <target state="translated">D 컴파일러는 클래스에서 필드 순서를 자유롭게 재정렬하여 구현 정의 방식으로 필드를 최적으로 압축합니다. 함수의 로컬 변수와 매우 유사한 필드를 고려하십시오. 컴파일러는 일부를 레지스터에 할당하고 다른 모든 것을 섞어서 최적의 스택 프레임 레이아웃을 얻습니다. 이를 통해 코드 디자이너는 기계 최적화 규칙에 따라 코드를 구성하는 대신 코드를 더 읽기 쉽게 만드는 방식으로 필드를 구성 할 수 있습니다. 필드 레이아웃의 명시 적 제어는 클래스가 아닌 struct / union 유형에 의해 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="66c7fe3af0cd825203fe720c8fa067ea0a5678d5" translate="yes" xml:space="preserve">
          <source>The D implementation is a direct translation of the ANSI C implementation by Antoon Bosselaers.</source>
          <target state="translated">D 구현은 Antoon Bosselaers가 ANSI C 구현을 직접 번역 한 것입니다.</target>
        </trans-unit>
        <trans-unit id="0eb8727502196b9e0eeb264d99cb49da0fe24a5d" translate="yes" xml:space="preserve">
          <source>The D programming language enables embedding both contracts and test code along side the actual code, which helps to keep them all consistent with each other. One thing lacking is the documentation, as ordinary comments are usually unsuitable for automated extraction and formatting into manual pages. Embedding the user documentation into the source code has important advantages, such as not having to write the documentation twice, and the likelihood of the documentation staying consistent with the code.</source>
          <target state="translated">D 프로그래밍 언어를 사용하면 실제 코드와 함께 계약 및 테스트 코드를 모두 포함 할 수 있으므로 서로 일관성을 유지하는 데 도움이됩니다. 일반 주석은 일반적으로 자동 추출 및 매뉴얼 페이지로의 형식 지정에 적합하지 않으므로 문서가 부족합니다. 사용자 문서를 소스 코드에 포함하면 문서를 두 번 작성할 필요가없고 문서가 코드와 일관성을 유지할 가능성과 같은 중요한 이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="802c45703e5b78c2f572e30e6188af81443e60af" translate="yes" xml:space="preserve">
          <source>The D runtime library to be linked in, because many features of the core language require runtime library support.</source>
          <target state="translated">핵심 언어의 많은 기능이 런타임 라이브러리 지원을 필요로하기 때문에 링크 될 D 런타임 라이브러리.</target>
        </trans-unit>
        <trans-unit id="5618198d08f630b6e32a4e2871006e5750e7b402" translate="yes" xml:space="preserve">
          <source>The DDoc description &lt;code&gt;ddoxText&lt;/code&gt; is only available when compiled with &lt;code&gt;-version=DdocOptions&lt;/code&gt;.</source>
          <target state="translated">DDoc 설명 &lt;code&gt;ddoxText&lt;/code&gt; 는 &lt;code&gt;-version=DdocOptions&lt;/code&gt; 로 컴파일 된 경우에만 사용 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="7fb61f59ea8c90dd27a6926b8a592e6ead829fcc" translate="yes" xml:space="preserve">
          <source>The DLang Tour's &lt;a href=&quot;http://tour.dlang.org/tour/en/basics/ranges&quot;&gt;chapter on ranges&lt;/a&gt; for an interactive introduction.</source>
          <target state="translated">대화식 소개를위한 &lt;a href=&quot;http://tour.dlang.org/tour/en/basics/ranges&quot;&gt;범위에&lt;/a&gt; 대한 DLang Tour의 장 .</target>
        </trans-unit>
        <trans-unit id="cf140ab3f9e536cec445868430509f0cac2d46fc" translate="yes" xml:space="preserve">
          <source>The DNS check is currently not implemented.</source>
          <target state="translated">DNS 확인은 현재 구현되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="56d9ffa8426e25e0a3a48c7232e3304c44908db1" translate="yes" xml:space="preserve">
          <source>The DOS file time to convert.</source>
          <target state="translated">변환 할 DOS 파일 시간.</target>
        </trans-unit>
        <trans-unit id="15ae789bb8d9a2910a1013b01a8410a64b26b8d3" translate="yes" xml:space="preserve">
          <source>The Darwin operating system; use &lt;code&gt;OSX&lt;/code&gt; instead</source>
          <target state="translated">다윈 운영 체제; 사용 &lt;code&gt;OSX&lt;/code&gt; 대신</target>
        </trans-unit>
        <trans-unit id="0c5d193fbc258ff579f3a37e19e9cc2430e7b7ab" translate="yes" xml:space="preserve">
          <source>The Date to set this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;'s date portion to.</source>
          <target state="translated">이 &lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 의 날짜 부분을 설정할 날짜입니다.</target>
        </trans-unit>
        <trans-unit id="00fdc9fbd5322b30129c9d99ab189c9c104eb677" translate="yes" xml:space="preserve">
          <source>The Digest interface is the base interface which is implemented by all digests.</source>
          <target state="translated">다이제스트 인터페이스는 모든 다이제스트에 의해 구현되는 기본 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="2ce0bb02d358ab6addf0222f9fba8a86b6896e28" translate="yes" xml:space="preserve">
          <source>The EH table entries are placed into the following special segments, which are concatenated by the linker.</source>
          <target state="translated">EH 테이블 항목은 다음 특수 세그먼트에 배치되며 링커에 의해 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="89d37e362d131df02b90f0756029490076b33ab7" translate="yes" xml:space="preserve">
          <source>The EXEC state will be set for any fiber that is currently executing.</source>
          <target state="translated">EXEC 상태는 현재 실행중인 모든 파이버에 대해 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="1ccc5057903fdcfbcc510be952b9d5d37edada1d" translate="yes" xml:space="preserve">
          <source>The Emscripten platform</source>
          <target state="translated">Emscripten 플랫폼</target>
        </trans-unit>
        <trans-unit id="b55fb20708d967172c74318116b38ef62263da2d" translate="yes" xml:space="preserve">
          <source>The Epiphany architecture</source>
          <target state="translated">주현절 아키텍처</target>
        </trans-unit>
        <trans-unit id="40b8a913038e25b6c9bffa97642d1772e1aab6db" translate="yes" xml:space="preserve">
          <source>The Error Handling Problem</source>
          <target state="translated">오류 처리 문제</target>
        </trans-unit>
        <trans-unit id="eaf7066f86536efb6667615a8c705264f2359588" translate="yes" xml:space="preserve">
          <source>The Executable and Linkable Format v1</source>
          <target state="translated">실행 가능하고 링크 가능한 형식 v1</target>
        </trans-unit>
        <trans-unit id="a8995e2abee214cdd0937cb4114af84984101e63" translate="yes" xml:space="preserve">
          <source>The Executable and Linkable Format v2</source>
          <target state="translated">실행 가능하고 링크 가능한 형식 v2</target>
        </trans-unit>
        <trans-unit id="b797d89bcc3a1d38587d03c438f6923075c38d2a" translate="yes" xml:space="preserve">
          <source>The FE_INEXACT and FE_OVERFLOW exceptions will be raised if x is finite and the function result is infinite. The FE_INEXACT and FE_UNDERFLOW exceptions will be raised if the function value is subnormal, and x is not equal to y.</source>
          <target state="translated">x가 유한하고 함수 결과가 무한하면 FE_INEXACT 및 FE_OVERFLOW 예외가 발생합니다. 함수 값이 비정규이고 x가 y와 같지 않으면 FE_INEXACT 및 FE_UNDERFLOW 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2cc30ae8daa2c51e73b2400207e079f98f496883" translate="yes" xml:space="preserve">
          <source>The FPU control word must be preserved across function calls.</source>
          <target state="translated">FPU 제어 단어는 함수 호출에서 유지되어야합니다.</target>
        </trans-unit>
        <trans-unit id="fa883c84fbc6dfcd4baaa0ba51f4b62fb823c921" translate="yes" xml:space="preserve">
          <source>The FPU stack must be empty when calling a function.</source>
          <target state="translated">함수를 호출 할 때는 FPU 스택이 비어 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="66be60482d61ed5145b549ed903a83bb0c71ea95" translate="yes" xml:space="preserve">
          <source>The FQDN corresponding to this &lt;code&gt;Address&lt;/code&gt;, or &lt;code&gt;null&lt;/code&gt; if the host name did not resolve.</source>
          <target state="translated">FQDN은이에 해당하는 &lt;code&gt;Address&lt;/code&gt; 또는 &lt;code&gt;null&lt;/code&gt; 호스트 이름이 해결되지 않으면.</target>
        </trans-unit>
        <trans-unit id="8d41f60329bdc4eca1fcd11caa66e4edfbd09ff0" translate="yes" xml:space="preserve">
          <source>The FQDN corresponding to this &lt;code&gt;InternetAddress&lt;/code&gt;, or &lt;code&gt;null&lt;/code&gt; if the host name did not resolve.</source>
          <target state="translated">FQDN은이에 해당 &lt;code&gt;InternetAddress&lt;/code&gt; , 또는 &lt;code&gt;null&lt;/code&gt; 의 호스트 이름이 해결되지 않은 경우.</target>
        </trans-unit>
        <trans-unit id="d604d40fa57017daad3764bad77115c1ca0fdd67" translate="yes" xml:space="preserve">
          <source>The Free Tree allocator, stackable on top of any other allocator, bears similarity with the free list allocator. Instead of a singly-linked list of previously freed blocks, it maintains a binary search tree. This allows the Free Tree allocator to manage blocks of arbitrary lengths and search them efficiently.</source>
          <target state="translated">다른 할당 자 위에 쌓을 수있는 Free Tree 할당자는 사용 가능한리스트 할당 자와 유사합니다. 이전에 해제 된 블록의 단일 링크 목록 대신 이진 검색 트리를 유지 관리합니다. 이를 통해 프리 트리 할당자는 임의 길이의 블록을 관리하고 효율적으로 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="66f9b21030c9cfea4f858014e8954ebf1f3aae2a" translate="yes" xml:space="preserve">
          <source>The GC does not know about threads that were created by directly calling the OS/C runtime thread creation APIs and D threads that were detached from the D runtime after creation. Such threads will not be paused for a GC collection, and the GC might not detect references to GC allocated data held by them. This can cause memory corruption. There are several ways to resolve this issue:</source>
          <target state="translated">GC는 OS / C 런타임 스레드 작성 API 및 작성 후 D 런타임에서 분리 된 D 스레드를 직접 호출하여 작성된 스레드에 대해 알지 못합니다. 이러한 스레드는 GC 콜렉션에 대해 일시 정지되지 않으며 GC는 해당 스레드가 보유한 GC 할당 데이터에 대한 참조를 감지하지 못할 수 있습니다. 메모리 손상이 발생할 수 있습니다. 이 문제를 해결하는 방법에는 여러 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="09265af251af541f24fa02df354e6c627eeab43b" translate="yes" xml:space="preserve">
          <source>The GC is a conservative mark-and-sweep collector. It only runs a collection cycle when an allocation is requested of it, never otherwise. Hence, if the program is not doing allocations, there will be no GC collection pauses. The pauses occur because all threads the GC knows about are halted so the threads' stacks and registers can be scanned for references to GC allocated data.</source>
          <target state="translated">GC는 보수적 인 마크 앤 스윕 수집기입니다. 할당이 요청 될 때만 수집주기를 실행합니다. 따라서 프로그램이 할당을 수행하지 않으면 GC 수집 일시 중지가 없습니다. GC가 알고있는 모든 스레드가 중지되어 스레드의 스택 및 레지스터에서 GC 할당 데이터에 대한 참조를 스캔 할 수 있기 때문에 일시 정지가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3621ad3c024741748106435d6839670def09513e" translate="yes" xml:space="preserve">
          <source>The GC works by:</source>
          <target state="translated">GC는 다음과 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="01be7ac14383dc55322950a93747b509b1d25d34" translate="yes" xml:space="preserve">
          <source>The Gamma function, &amp;Gamma;(x)</source>
          <target state="translated">감마 함수, &amp;Gamma; (x)</target>
        </trans-unit>
        <trans-unit id="7f9dd1ba3610a4fa3692ac332748a174db7a2c97" translate="yes" xml:space="preserve">
          <source>The General Idea</source>
          <target state="translated">일반적인 아이디어</target>
        </trans-unit>
        <trans-unit id="09c260551ce83481dd94ee562ae20c29d2cbfbcd" translate="yes" xml:space="preserve">
          <source>The HOLD state applies to any fiber that is suspended and ready to be called.</source>
          <target state="translated">HOLD 상태는 일시 중단되어 호출 할 수있는 모든 광섬유에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="f79c18f74d62562ad1f7c03592165873d3b1261e" translate="yes" xml:space="preserve">
          <source>The HP PA-RISC architecture, 32-bit</source>
          <target state="translated">HP PA-RISC 아키텍처, 32 비트</target>
        </trans-unit>
        <trans-unit id="7286f6510b88f99f7add4a6c2608a7eee35a2efd" translate="yes" xml:space="preserve">
          <source>The HP PA-RISC architecture, 64-bit</source>
          <target state="translated">HP PA-RISC 아키텍처, 64 비트</target>
        </trans-unit>
        <trans-unit id="5270e504f2e810bcb80b698fc095abb55c5262a9" translate="yes" xml:space="preserve">
          <source>The HTTP status code</source>
          <target state="translated">HTTP 상태 코드</target>
        </trans-unit>
        <trans-unit id="00d3a26093b532d414271679dbec9e6e2a73f34f" translate="yes" xml:space="preserve">
          <source>The HTTP status code.</source>
          <target state="translated">HTTP 상태 코드</target>
        </trans-unit>
        <trans-unit id="7122ee727a4a9c43a0c4b374f8af52b6a3d4cb29" translate="yes" xml:space="preserve">
          <source>The Haiku operating system</source>
          <target state="translated">하이쿠 운영 체제</target>
        </trans-unit>
        <trans-unit id="754ea5395a39abae7ed60f21d5519e88e6165ab7" translate="yes" xml:space="preserve">
          <source>The IPv4 address to resolve, in host byte order.</source>
          <target state="translated">호스트 바이트 순서로 확인할 IPv4 주소입니다.</target>
        </trans-unit>
        <trans-unit id="0b97447540254f088f748027ca72f36ef505114e" translate="yes" xml:space="preserve">
          <source>The IPv6 address contains an illegal group of characters</source>
          <target state="translated">IPv6 주소에 잘못된 문자 그룹이 포함되어 있습니다</target>
        </trans-unit>
        <trans-unit id="939c03178f2358d0df8918d3f727b4b5275338a9" translate="yes" xml:space="preserve">
          <source>The IPv6 address has too many groups</source>
          <target state="translated">IPv6 주소에 그룹이 너무 많습니다</target>
        </trans-unit>
        <trans-unit id="b524ba697022923dfd3280c242c2f5c008ed3014" translate="yes" xml:space="preserve">
          <source>The IPv6 literal address contains the wrong number of groups</source>
          <target state="translated">IPv6 리터럴 주소에 잘못된 수의 그룹이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e504cc6edc640db7967795f40b8ee6b3c54fc358" translate="yes" xml:space="preserve">
          <source>The IPv6 literal address contains too many :: sequences</source>
          <target state="translated">IPv6 리터럴 주소에 너무 많은 :: 시퀀스가 ​​포함되어 있습니다</target>
        </trans-unit>
        <trans-unit id="4484ea847d299a869e106746e76b93aab4ed4c63" translate="yes" xml:space="preserve">
          <source>The ISO 8601 week and year of the year that this &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; is in.</source>
          <target state="translated">이 &lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 가 속한 연도의 ISO 8601 주 및 연도입니다 .</target>
        </trans-unit>
        <trans-unit id="32301a3821496f197f80c8f798e0ea4f8cc4adc2" translate="yes" xml:space="preserve">
          <source>The ISO 8601 week of the year that this &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; is in.</source>
          <target state="translated">이 &lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 가 속한 연도의 ISO 8601 주입니다 .</target>
        </trans-unit>
        <trans-unit id="f553bfd947d975047033c96897725e1b54f28cb8" translate="yes" xml:space="preserve">
          <source>The ISO 8601 week of the year that this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; is in.</source>
          <target state="translated">이 &lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 이 포함 된 연중 ISO 8601 주입니다 .</target>
        </trans-unit>
        <trans-unit id="609c718075ac3c5f30e12392b88a12278c90c113" translate="yes" xml:space="preserve">
          <source>The ISO 8601 week of the year that this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; is in.</source>
          <target state="translated">이 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; 이 포함 된 연중 ISO 8601 주입니다 .</target>
        </trans-unit>
        <trans-unit id="5d4b2d1662b082964162c97fb5d0dcbe255cddc9" translate="yes" xml:space="preserve">
          <source>The Intel mappings are:</source>
          <target state="translated">인텔 매핑은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4e12f496455b58ad8f60123b3271f9b244d4d784" translate="yes" xml:space="preserve">
          <source>The Itanium architecture (64-bit)</source>
          <target state="translated">Itanium 아키텍처 (64 비트)</target>
        </trans-unit>
        <trans-unit id="eafe9f7a037c5e67f3da70a6b91c37b61b30b815" translate="yes" xml:space="preserve">
          <source>The LARGE version of the standard POSTFIELDSIZE option</source>
          <target state="translated">표준 POSTFIELDSIZE 옵션의 큰 버전</target>
        </trans-unit>
        <trans-unit id="9134d1977034f57d1f687c818551bb851d95680b" translate="yes" xml:space="preserve">
          <source>The MIPS &lt;code&gt;hard-float&lt;/code&gt; ABI</source>
          <target state="translated">MIPS &lt;code&gt;hard-float&lt;/code&gt; ABI</target>
        </trans-unit>
        <trans-unit id="0886aaa5bcac19d0d348397019786e1f00a24cbe" translate="yes" xml:space="preserve">
          <source>The MIPS &lt;code&gt;soft-float&lt;/code&gt; ABI</source>
          <target state="translated">MIPS &lt;code&gt;soft-float&lt;/code&gt; ABI</target>
        </trans-unit>
        <trans-unit id="3c9add972d2d135b53fbf340e836225309a3b85b" translate="yes" xml:space="preserve">
          <source>The MIPS EABI</source>
          <target state="translated">MIPS EABI</target>
        </trans-unit>
        <trans-unit id="61483ec276697778dec9b8f31845f4c0b43841b3" translate="yes" xml:space="preserve">
          <source>The MIPS N32 ABI</source>
          <target state="translated">MIPS N32 ABI</target>
        </trans-unit>
        <trans-unit id="e879e3a8741fac0b79bfe9a6fa792af183d21455" translate="yes" xml:space="preserve">
          <source>The MIPS N64 ABI</source>
          <target state="translated">MIPS N64 ABI</target>
        </trans-unit>
        <trans-unit id="d4e8f04e3b51f7a111a0b6bd1b36a079abe2873b" translate="yes" xml:space="preserve">
          <source>The MIPS O32 ABI</source>
          <target state="translated">MIPS O32 ABI</target>
        </trans-unit>
        <trans-unit id="bef14bbb878c09e8ee5dc32d3da00729ccb93501" translate="yes" xml:space="preserve">
          <source>The MIPS O64 ABI</source>
          <target state="translated">MIPS O64 ABI</target>
        </trans-unit>
        <trans-unit id="0fc57735dcd8256e5e59ac6395a31b083346ff43" translate="yes" xml:space="preserve">
          <source>The MIPS architecture, 32-bit</source>
          <target state="translated">MIPS 아키텍처, 32 비트</target>
        </trans-unit>
        <trans-unit id="17e1b519534bdd70840a0f61f4f110bf2c163b10" translate="yes" xml:space="preserve">
          <source>The MIPS architecture, 64-bit</source>
          <target state="translated">MIPS 아키텍처, 64 비트</target>
        </trans-unit>
        <trans-unit id="c3e4c70686693b89b9dd6f86ff1c297d3c0e0be4" translate="yes" xml:space="preserve">
          <source>The MSP430 architecture</source>
          <target state="translated">MSP430 아키텍처</target>
        </trans-unit>
        <trans-unit id="356126ab1aa2384bb41e6bc4ebe8dbef50cceecb" translate="yes" xml:space="preserve">
          <source>The MinGW environment</source>
          <target state="translated">MinGW 환경</target>
        </trans-unit>
        <trans-unit id="0f46aebab81731ecc7971e216c920d74155e16b2" translate="yes" xml:space="preserve">
          <source>The Mutex that will be associated with this condition. It will be locked prior to any operation on the condition, and so in some cases a Scheduler may need to hold this reference and unlock the mutex before yielding execution to another logical thread.</source>
          <target state="translated">이 조건과 관련된 Mutex입니다. 조건에 대한 조작 전에 잠금 상태가되므로 스케줄러는 다른 논리 스레드로 실행하기 전에이 참조를 보유하고 뮤텍스를 잠금 해제해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a87cbf0b095ac8eab76a631ffec330584de63e97" translate="yes" xml:space="preserve">
          <source>The N parameter indicate the size of the hash in bits. The parameter P specify the polynomial to be used for reduction.</source>
          <target state="translated">N 매개 변수는 해시의 크기를 비트 단위로 나타냅니다. 매개 변수 P는 축소에 사용될 다항식을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="e2508e2f024c9fbc95d61d6996efa639c0414a7f" translate="yes" xml:space="preserve">
          <source>The Nvidia Parallel Thread Execution (PTX) architecture, 32-bit</source>
          <target state="translated">Nvidia Parallel Thread Execution (PTX) 아키텍처, 32 비트</target>
        </trans-unit>
        <trans-unit id="43afd253995cf155cd46e72aca1c4d14f27edda9" translate="yes" xml:space="preserve">
          <source>The Nvidia Parallel Thread Execution (PTX) architecture, 64-bit</source>
          <target state="translated">Nvidia Parallel Thread Execution (PTX) 아키텍처, 64 비트</target>
        </trans-unit>
        <trans-unit id="6b89001c9eee7cbf1eb78ebd06f2cdba52573b8f" translate="yes" xml:space="preserve">
          <source>The ODBC library itself not a part of the &lt;code&gt;dmd&lt;/code&gt; distribution (and typically not a part of the distribution packages of other compilers such as &lt;code&gt;gdc&lt;/code&gt; and &lt;code&gt;ldc&lt;/code&gt;). To use ODBC, install it per the vendor- and platform-specific instructions and then use the appropriate command-line flags (e.g. for dmd, &lt;code&gt;-L-lodbc&lt;/code&gt; on Posix and &lt;code&gt;-Lodbc32.lib&lt;/code&gt; on Windows) to link with the ODBC library. On Windows, using &lt;code&gt;pragma(lib, &quot;odbc32&quot;)&lt;/code&gt; in D code at top level is also appropriate.</source>
          <target state="translated">는 ODBC 라이브러리 자체가 아니라의 일부 &lt;code&gt;dmd&lt;/code&gt; (일반적으로이 아니라 같은 다른 컴파일러의 배포 패키지의 일부 유통 &lt;code&gt;gdc&lt;/code&gt; 및 &lt;code&gt;ldc&lt;/code&gt; ). ODBC를 사용하려면 공급 업체 및 플랫폼 별 지침에 따라 ODBC를 설치 한 다음 적절한 명령 줄 플래그 (예 : dmd, Posix의 &lt;code&gt;-L-lodbc&lt;/code&gt; 및 Windows의 경우 &lt;code&gt;-Lodbc32.lib&lt;/code&gt; )를 사용하여 ODBC 라이브러리와 연결하십시오. Windows에서는 최상위 레벨의 D 코드에서 &lt;code&gt;pragma(lib, &quot;odbc32&quot;)&lt;/code&gt; 를 사용하는 것도 적합합니다.</target>
        </trans-unit>
        <trans-unit id="3cfee8a3cdd0f5ece05fc4719284d9ca35cb1ece" translate="yes" xml:space="preserve">
          <source>The ORDER BY clause</source>
          <target state="translated">ORDER BY 절</target>
        </trans-unit>
        <trans-unit id="e14ee41921816523befa01909d94c5e1726b3657" translate="yes" xml:space="preserve">
          <source>The OS that the program was compiled for.</source>
          <target state="translated">프로그램이 컴파일 된 OS</target>
        </trans-unit>
        <trans-unit id="acb9d25ece84bce22fb8212a22f84954077a7a34" translate="yes" xml:space="preserve">
          <source>The ObjectiveC interface recognizes &lt;code&gt;@property&lt;/code&gt; setter functions as special and modifies them accordingly.</source>
          <target state="translated">ObjectiveC 인터페이스는 &lt;code&gt;@property&lt;/code&gt; setter 함수를 특수한 것으로 인식 하고 그에 따라 수정합니다.</target>
        </trans-unit>
        <trans-unit id="9d3e4b21e5a04eb6fbe9f2397109b2139a475f5c" translate="yes" xml:space="preserve">
          <source>The POSIX &lt;code&gt;tempDir&lt;/code&gt; algorithm is inspired by Python's &lt;a href=&quot;http://docs.python.org/library/tempfile.html#tempfile.tempdir&quot;&gt;&lt;code&gt;tempfile.tempdir&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">POSIX &lt;code&gt;tempDir&lt;/code&gt; 알고리즘은 Python의 &lt;a href=&quot;http://docs.python.org/library/tempfile.html#tempfile.tempdir&quot;&gt; &lt;code&gt;tempfile.tempdir&lt;/code&gt; 에서&lt;/a&gt; 영감을 받았습니다 .</target>
        </trans-unit>
        <trans-unit id="1c563a1ca0669b82c82cd26bf7fb6686fa6636d8" translate="yes" xml:space="preserve">
          <source>The POSIX &lt;code&gt;tempDir&lt;/code&gt; algorithm is inspired by Python's &lt;a href=&quot;https://docs.python.org/library/tempfile.html#tempfile.tempdir&quot;&gt;&lt;code&gt;tempfile.tempdir&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31d8872f92578235b233b51b76c476d7fea1f8da" translate="yes" xml:space="preserve">
          <source>The PermissiveVisitor overrides the root AST nodes with empty visiting methods.</source>
          <target state="translated">PermissiveVisitor는 비어있는 방문 메소드로 루트 AST 노드를 대체합니다.</target>
        </trans-unit>
        <trans-unit id="b4f6f3e26f3ff3126b16496a184e46c78d9cba02" translate="yes" xml:space="preserve">
          <source>The PlayStation 4 platform</source>
          <target state="translated">PlayStation 4 플랫폼</target>
        </trans-unit>
        <trans-unit id="70399824984e6ff6449a6e9c505ed7dd24f48905" translate="yes" xml:space="preserve">
          <source>The PlayStation platform</source>
          <target state="translated">PlayStation 플랫폼</target>
        </trans-unit>
        <trans-unit id="cc67c3f1b66652b129c77acf7df61ddd9416b905" translate="yes" xml:space="preserve">
          <source>The PowerPC architecture, 32-bit</source>
          <target state="translated">PowerPC 아키텍처, 32 비트</target>
        </trans-unit>
        <trans-unit id="11d7c845ab07a5d6a42e06f125f4373f5e764a25" translate="yes" xml:space="preserve">
          <source>The PowerPC architecture, 64-bit</source>
          <target state="translated">PowerPC 아키텍처, 64 비트</target>
        </trans-unit>
        <trans-unit id="75f5b736eefcd29872adaf37d46e108c07f8ec67" translate="yes" xml:space="preserve">
          <source>The PowerPC hard float ABI</source>
          <target state="translated">PowerPC 하드 플로트 ABI</target>
        </trans-unit>
        <trans-unit id="2c60a35ae353caf4915f17f56e813cbc9a9912c4" translate="yes" xml:space="preserve">
          <source>The PowerPC soft float ABI</source>
          <target state="translated">PowerPC 소프트 플로트 ABI</target>
        </trans-unit>
        <trans-unit id="5435e45bdc0c51d8e23529dc87ba62fac99d8b9a" translate="yes" xml:space="preserve">
          <source>The RISC-V architecture, 32-bit</source>
          <target state="translated">RISC-V 아키텍처, 32 비트</target>
        </trans-unit>
        <trans-unit id="b9fe578ae2efbaf9e508542e117f5ee508458c96" translate="yes" xml:space="preserve">
          <source>The RISC-V architecture, 64-bit</source>
          <target state="translated">RISC-V 아키텍처, 64 비트</target>
        </trans-unit>
        <trans-unit id="90ccc79b25ba88c383a0b919bf25a08cc0fc464c" translate="yes" xml:space="preserve">
          <source>The RTSP session identifier</source>
          <target state="translated">RTSP 세션 식별자</target>
        </trans-unit>
        <trans-unit id="23b016dcf33e16db8ffaf83deb1005e7587906e4" translate="yes" xml:space="preserve">
          <source>The RTSP stream URI</source>
          <target state="translated">RTSP 스트림 URI</target>
        </trans-unit>
        <trans-unit id="cd04b56dd323b56cf68cf7a1c2c623b5bbf96a33" translate="yes" xml:space="preserve">
          <source>The Range to permute. The original ordering will be lost.</source>
          <target state="translated">퍼 뮤트 할 범위입니다. 원래 주문이 손실됩니다.</target>
        </trans-unit>
        <trans-unit id="781a90481fca7ce8311f6dc9aaa241c6dbb23d12" translate="yes" xml:space="preserve">
          <source>The SPARC architecture, 32-bit</source>
          <target state="translated">SPARC 아키텍처, 32 비트</target>
        </trans-unit>
        <trans-unit id="1034834d5e21d8f03f302305ed4219d634887791" translate="yes" xml:space="preserve">
          <source>The SPARC architecture, 64-bit</source>
          <target state="translated">SPARC 아키텍처, 64 비트</target>
        </trans-unit>
        <trans-unit id="5f5c3aba9207be74c2868dc1673d5d4051edce52" translate="yes" xml:space="preserve">
          <source>The SPARC hard float ABI</source>
          <target state="translated">SPARC 하드 플로트 ABI</target>
        </trans-unit>
        <trans-unit id="c02e4fc0e65c5858009152aee0c28acf93d5875b" translate="yes" xml:space="preserve">
          <source>The SPARC soft float ABI</source>
          <target state="translated">SPARC 소프트 플로트 ABI</target>
        </trans-unit>
        <trans-unit id="f49a391f9f9d3680aaef70c1a255c3dd843e400b" translate="yes" xml:space="preserve">
          <source>The SPARC v8+ ABI</source>
          <target state="translated">SPARC v8 + ABI</target>
        </trans-unit>
        <trans-unit id="51f88ae48e3d052b49fccac8f3b93fc0fdc92beb" translate="yes" xml:space="preserve">
          <source>The SkyOS operating system</source>
          <target state="translated">SkyOS 운영 체제</target>
        </trans-unit>
        <trans-unit id="2332cfeec9b82b4c089b42655778df17ede056d5" translate="yes" xml:space="preserve">
          <source>The Soundex algorithm converts a word into 4 characters based on how the word sounds phonetically. The idea is that two spellings that sound alike will have the same Soundex value, which means that Soundex can be used for fuzzy matching of names.</source>
          <target state="translated">Soundex 알고리즘은 단어가 소리 나는 방식에 따라 단어를 4 자로 변환합니다. 아이디어는 비슷하게 들리는 두 개의 철자가 동일한 Soundex 값을 가지므로 Soundex를 이름의 퍼지 일치에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="268f1657c076d3627d3dea23877501be858e04fe" translate="yes" xml:space="preserve">
          <source>The StopWatch can be reset while it's running, and resetting it while it's running will not cause it to stop.</source>
          <target state="translated">StopWatch는 실행중인 동안 재설정 할 수 있으며 실행중인 동안 재설정하면 중지되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ef49511070e620b95e825c1c86d96261c9c95a00" translate="yes" xml:space="preserve">
          <source>The StopWatch does not have to be stopped for setTimeElapsed to be called, nor will calling it cause the StopWatch to stop.</source>
          <target state="translated">setTimeElapsed를 호출하기 위해 StopWatch를 중지 할 필요가 없으며이를 호출해도 StopWatch가 중지되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b0a9b6a2bbd967f7e916f635e74331784867ef32" translate="yes" xml:space="preserve">
          <source>The StrictVisitor asserts 0 an all visiting functions in order to make sure that all the nodes are visited.</source>
          <target state="translated">StrictVisitor는 모든 노드가 방문되도록 모든 방문 기능을 0으로 지정합니다.</target>
        </trans-unit>
        <trans-unit id="38a628b9d86064e9b5321ad3bcd830e114572d5b" translate="yes" xml:space="preserve">
          <source>The SuperH architecture, 32-bit</source>
          <target state="translated">SuperH 아키텍처, 32 비트</target>
        </trans-unit>
        <trans-unit id="766bcffdaef3f631903919b1d19fc7f6bbe507ed" translate="yes" xml:space="preserve">
          <source>The System Z architecture, 64-bit</source>
          <target state="translated">System Z 아키텍처, 64 비트</target>
        </trans-unit>
        <trans-unit id="60329427da56af2758e2ca1d40d12d8553a7de59" translate="yes" xml:space="preserve">
          <source>The System/390 architecture, 32-bit</source>
          <target state="translated">System / 390 아키텍처, 32 비트</target>
        </trans-unit>
        <trans-unit id="4b2f7d9d9f4c13907ce79769575d22c87fc28c16" translate="yes" xml:space="preserve">
          <source>The System/390X architecture</source>
          <target state="translated">System / 390X 아키텍처</target>
        </trans-unit>
        <trans-unit id="f3602277188b5a4b62cb2b9c0bc9fd8221ea73de" translate="yes" xml:space="preserve">
          <source>The TERM state is set when a fiber terminates. Once a fiber terminates, it must be reset before it may be called again.</source>
          <target state="translated">TERM 상태는 파이버가 종료 될 때 설정됩니다. 파이버가 종료되면 다시 호출하기 전에 재설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="cf15cedd50ebb05ffc304f6b6e9727e5f84f91f4" translate="yes" xml:space="preserve">
          <source>The TZ Database files and Windows' time zone information frequently do not match. Windows has many errors with regards to when DST switches occur (especially for historical dates). Also, the TZ Database files include far more time zones than Windows does. So, for accurate time zone information, use the TZ Database files with &lt;a href=&quot;#PosixTimeZone&quot;&gt;&lt;code&gt;PosixTimeZone&lt;/code&gt;&lt;/a&gt; rather than &lt;code&gt;WindowsTimeZone&lt;/code&gt;. However, because &lt;code&gt;WindowsTimeZone&lt;/code&gt; uses Windows system calls to deal with the time, it's far more likely to match the behavior of other Windows programs. Be aware of the differences when selecting a method.</source>
          <target state="translated">TZ 데이터베이스 파일과 Windows 시간대 정보가 자주 일치하지 않습니다. Windows에는 DST 스위치가 발생할 때 (특히 기록 날짜와 관련하여) 많은 오류가 있습니다. 또한 TZ 데이터베이스 파일에는 Windows보다 훨씬 많은 시간대가 포함되어 있습니다. 따라서 정확한 시간대 정보를 &lt;a href=&quot;#PosixTimeZone&quot;&gt; &lt;code&gt;PosixTimeZone&lt;/code&gt; &lt;/a&gt; &lt;code&gt;WindowsTimeZone&lt;/code&gt; 대신 PosixTimeZone 과 함께 TZ 데이터베이스 파일을 사용하십시오 . 그러나 &lt;code&gt;WindowsTimeZone&lt;/code&gt; 은 Windows 시스템 호출을 사용하여 시간을 처리하므로 다른 Windows 프로그램의 동작과 훨씬 일치 할 가능성이 큽니다. 분석법을 선택할 때의 차이점에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="748abfca6b1790f0685eea195232448ad41a5fc1" translate="yes" xml:space="preserve">
          <source>The TZ Database name of the desired time zone</source>
          <target state="translated">원하는 시간대의 TZ 데이터베이스 이름</target>
        </trans-unit>
        <trans-unit id="132cc31d74b99e25b094510d883e3a16e5485de5" translate="yes" xml:space="preserve">
          <source>The TZ Database name of the desired time zone.</source>
          <target state="translated">원하는 시간대의 TZ 데이터베이스 이름입니다.</target>
        </trans-unit>
        <trans-unit id="00d89e73108126666266d03f62559f8c79154621" translate="yes" xml:space="preserve">
          <source>The Tag at the start of the element being parsed. You can read this to determine the tag's name and attributes.</source>
          <target state="translated">구문 분석중인 요소의 시작 부분에있는 태그입니다. 이것을 읽고 태그 이름과 속성을 결정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3bca6c83fc63fdf211790976e397694f0843b940" translate="yes" xml:space="preserve">
          <source>The Throwable hierarchy uses a toString overload that takes a sink delegate to avoid GC allocations, which cannot be performed in certain error situations. Override this &lt;code&gt; toString&lt;/code&gt; method to customize the error message.</source>
          <target state="translated">Throwable 계층은 특정 오류 상황에서는 수행 할 수없는 GC 할당을 피하기 위해 싱크 대리자를받는 toString 오버로드를 사용합니다. 이 &lt;code&gt; toString&lt;/code&gt; 메소드를 대체 하여 오류 메시지를 사용자 정의하십시오.</target>
        </trans-unit>
        <trans-unit id="3c9d356da0ae96a0d8c3d76a7a7ffe030a9facc8" translate="yes" xml:space="preserve">
          <source>The TickDuration to convert</source>
          <target state="translated">변환 할 TickDuration</target>
        </trans-unit>
        <trans-unit id="9077c94c094dacf17fb2adfb8e0611d26cac59ad" translate="yes" xml:space="preserve">
          <source>The Tid of the thread for which this limit should be set.</source>
          <target state="translated">이 한계를 설정해야하는 스레드의 Tid.</target>
        </trans-unit>
        <trans-unit id="273ec04a5b49ef584d98bd13fd62b3b6a4d686b4" translate="yes" xml:space="preserve">
          <source>The TransitiveVisitor implements the AST traversal logic for all AST nodes.</source>
          <target state="translated">TransitiveVisitor는 모든 AST 노드에 대한 AST 순회 로직을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="375aa2306db2f0ad24248c06c7fd81f749f9b2fc" translate="yes" xml:space="preserve">
          <source>The Transport: header to use in RTSP requests</source>
          <target state="translated">RTSP 요청에 사용할 Transport : 헤더</target>
        </trans-unit>
        <trans-unit id="1e2dcc313af4acaeeb4cf0d38aa3925c59b78d65" translate="yes" xml:space="preserve">
          <source>The TypeInfo instance for the object that failed finalization.</source>
          <target state="translated">종료에 실패한 개체의 TypeInfo 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="e267c9583ddc10478f4a6152d7e5f3bb902c9328" translate="yes" xml:space="preserve">
          <source>The URL to specify the location of the resource.</source>
          <target state="translated">자원의 위치를 ​​지정하는 URL입니다.</target>
        </trans-unit>
        <trans-unit id="6e8939f6e58f5cd6da0eecfd60bdd7601fb2d72d" translate="yes" xml:space="preserve">
          <source>The UTC time for which to get the offset from UTC for this time zone.</source>
          <target state="translated">이 시간대의 UTC에서 오프셋을 가져올 UTC 시간입니다.</target>
        </trans-unit>
        <trans-unit id="baa72debfc3513a96e5ab531e18bfe7afe12a6e6" translate="yes" xml:space="preserve">
          <source>The UTC time that needs to be adjusted to this time zone's time.</source>
          <target state="translated">이 시간대 시간으로 조정해야하는 UTC 시간입니다.</target>
        </trans-unit>
        <trans-unit id="f66b265ec18c3d9162f9d2f9c326e937acb66094" translate="yes" xml:space="preserve">
          <source>The UTC time that needs to be checked for DST in this time zone.</source>
          <target state="translated">이 시간대에서 DST를 확인해야하는 UTC 시간입니다.</target>
        </trans-unit>
        <trans-unit id="d87edef215a8752e6ecf907380fee61fdf55f0b6" translate="yes" xml:space="preserve">
          <source>The Unicode Standard specifies four normalization forms. Informally, two of these forms are defined by maximal decomposition of equivalent sequences, and two of these forms are defined by maximal</source>
          <target state="translated">유니 코드 표준은 네 가지 정규화 형식을 지정합니다. 비공식적으로, 이들 형태 중 2 개는 등가 서열의 최대 분해에 의해 정의되고,이 형태 중 2 개는 최대에 의해 정의된다</target>
        </trans-unit>
        <trans-unit id="33f138b95a9dfb5155c8e0a90293fab0aba64c92" translate="yes" xml:space="preserve">
          <source>The Unicode code space is the range of code points [0x000000,0x10FFFF] except the UTF-16 surrogate pairs in the range [0xD800,0xDFFF]</source>
          <target state="translated">유니 코드 코드 공간은 [0xD800,0xDFFF] 범위의 UTF-16 서로 게이트 쌍을 제외하고 코드 포인트 [0x000000,0x10FFFF]의 범위입니다.</target>
        </trans-unit>
        <trans-unit id="b8ad7131caaca8a595f3745023534a437f4e5026" translate="yes" xml:space="preserve">
          <source>The Unicode standard describes a set of algorithms that depend on having the ability to quickly look up various properties of a code point. Given the the codespace of about 1 million &lt;a href=&quot;#Code%20point&quot;&gt;code points&lt;/a&gt;, it is not a trivial task to provide a space-efficient solution for the multitude of properties.</source>
          <target state="translated">유니 코드 표준은 코드 포인트의 다양한 속성을 신속하게 조회 할 수있는 능력에 의존하는 일련의 알고리즘을 설명합니다. 약 100 만 개의 &lt;a href=&quot;#Code%20point&quot;&gt;코드 포인트&lt;/a&gt; 의 코드 공간을 감안할 때, 여러 속성에 공간 효율적인 솔루션을 제공하는 것은 쉬운 일이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="632f1d4d9869b7133b4ab86d451bf673c847817f" translate="yes" xml:space="preserve">
          <source>The WebAssembly System Interface</source>
          <target state="translated">WebAssembly 시스템 인터페이스</target>
        </trans-unit>
        <trans-unit id="ffe88cf3bb8bf5313b7bf6ff81667f38d4331b4a" translate="yes" xml:space="preserve">
          <source>The WebAssembly virtual ISA (instruction set architecture), 32-bit</source>
          <target state="translated">WebAssembly 가상 ISA (명령 세트 아키텍처), 32 비트</target>
        </trans-unit>
        <trans-unit id="7218859784e706d4ce7421f54be346d3a0c8a1e1" translate="yes" xml:space="preserve">
          <source>The Windows convention is distinct from the C convention only on Win32 platforms, where it is equivalent to the &lt;a href=&quot;https://en.wikipedia.org/wiki/X86_calling_conventions&quot;&gt;stdcall&lt;/a&gt; convention.</source>
          <target state="translated">Windows 규칙은 &lt;a href=&quot;https://en.wikipedia.org/wiki/X86_calling_conventions&quot;&gt;stdcall&lt;/a&gt; 규칙 과 동등한 Win32 플랫폼에서만 C 규칙과 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="49f93641b1c1925cc9dd3d11b2fd5da7bb48b174" translate="yes" xml:space="preserve">
          <source>The Windows directory.</source>
          <target state="translated">Windows 디렉토리</target>
        </trans-unit>
        <trans-unit id="c2f11ed3900be0870fe44d5da590840874b32a51" translate="yes" xml:space="preserve">
          <source>The Xth day of the Gregorian Calendar that the constructed &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; will be for.</source>
          <target state="translated">생성 된 &lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 가 될 그레고리력의 X 번째 날입니다 .</target>
        </trans-unit>
        <trans-unit id="078b1c7105fbdd3c92634660aca6a999419f2df5" translate="yes" xml:space="preserve">
          <source>The Xth day of the Gregorian Calendar that this &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; is on.</source>
          <target state="translated">이 &lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 가 있는 그레고리력의 X 번째 날입니다 .</target>
        </trans-unit>
        <trans-unit id="6a538d97dc5e4f2c73e76335c5f71bdb3a58dff3" translate="yes" xml:space="preserve">
          <source>The Xth day of the Gregorian Calendar that this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; is on.</source>
          <target state="translated">이 &lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 이 설정된 그레고리력의 X 번째 날입니다 .</target>
        </trans-unit>
        <trans-unit id="35dba2f96bb894868d65591da08ba057a166fba5" translate="yes" xml:space="preserve">
          <source>The Xth day of the Gregorian Calendar that this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; is on. Setting this property does not affect the time portion of &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 &lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 이 설정된 그레고리력의 X 번째 날입니다 . 이 속성을 설정해도 &lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 의 시간 부분에는 영향을 미치지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="fc06a78f3518f5838e5230bd6dc9922cf974ff7b" translate="yes" xml:space="preserve">
          <source>The Xth day of the Gregorian Calendar that this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; is on.</source>
          <target state="translated">이 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; 이 있는 그레고리력의 X 번째 날입니다 .</target>
        </trans-unit>
        <trans-unit id="4075f06941052a1ee790fc11b1f2d7e20edf61db" translate="yes" xml:space="preserve">
          <source>The Xth day of the Gregorian Calendar that this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; is on. Setting this property does not affect the time portion of &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; 이 있는 그레고리력의 X 번째 날입니다 . 이 속성을 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; 의 시간 부분에는 영향을 미치지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="ad98437030654ff114036805bc5d6ac8a441a5fb" translate="yes" xml:space="preserve">
          <source>The [] is shorthand for a slice of the entire array. For example, the assignments to b:</source>
          <target state="translated">[]는 전체 배열의 슬라이스에 대한 약어입니다. 예를 들어, b에 할당 :</target>
        </trans-unit>
        <trans-unit id="9b28a421f1b16c658e8f7a2c5614f59f19a2b533" translate="yes" xml:space="preserve">
          <source>The abbreviation for the time zone during DST.</source>
          <target state="translated">DST 동안 시간대의 약어입니다.</target>
        </trans-unit>
        <trans-unit id="0c94ff584e3706234c838771e26f1f43c96e3d6d" translate="yes" xml:space="preserve">
          <source>The abbreviation for the time zone during std time.</source>
          <target state="translated">표준 시간 동안 시간대의 약어입니다.</target>
        </trans-unit>
        <trans-unit id="0a6c7a99e42d574e059c43a16588f2b20bec46f2" translate="yes" xml:space="preserve">
          <source>The ability to cast away immutable-correctness is necessary in some cases where the static typing is incorrect and not fixable, such as when referencing code in a library one cannot change. Casting is, as always, a blunt and effective instrument, and when using it to cast away immutable-correctness, one must assume the responsibility to ensure the immutability of the data, as the compiler will no longer be able to statically do so.</source>
          <target state="translated">정적 타이핑이 잘못되어 라이브러리에서 코드를 참조 할 수없는 경우와 같이 정적 타이핑이 올바르지 않고 수정할 수없는 경우 불변 정정을 캐스트하는 기능이 필요합니다. 캐스팅은 언제나 그렇듯이 둔하고 효과적인 도구이며, 불변 정정을 캐스트하기 위해 사용할 때, 컴파일러는 더 이상 정적으로 그렇게 할 수 없으므로 데이터의 불변성을 보장 할 책임을 져야합니다.</target>
        </trans-unit>
        <trans-unit id="a174b7c1633f2b2750afdacf56529479a613162e" translate="yes" xml:space="preserve">
          <source>The above allocation can also be written as:</source>
          <target state="translated">위의 할당은 다음과 같이 쓸 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="680ec1f70249732d24260b5f89033a1cd3b8827b" translate="yes" xml:space="preserve">
          <source>The above outputs something along the lines of:</source>
          <target state="translated">위의 라인을 따라 뭔가를 출력합니다.</target>
        </trans-unit>
        <trans-unit id="0d7dd549d6036f484842f3fd47adff55e907a5d5" translate="yes" xml:space="preserve">
          <source>The above will generate the following documentation:</source>
          <target state="translated">위의 내용은 다음과 같은 문서를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="4bf0047ab0e970e724128a48338bb914be2e1061" translate="yes" xml:space="preserve">
          <source>The above would generate the following output:</source>
          <target state="translated">위의 결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="208ff0335cf2cb5e612c95ae6f246572f3c94853" translate="yes" xml:space="preserve">
          <source>The absence of a read method means that the property is write-only. The absence of a write method means that the property is read-only. Multiple write methods can exist; the correct one is selected using the usual function overloading rules.</source>
          <target state="translated">read 메소드가 없으면 특성이 쓰기 전용임을 의미합니다. 쓰기 방법이 없으면 속성이 읽기 전용임을 의미합니다. 여러 쓰기 방법이 존재할 수 있습니다. 일반적인 기능 오버로드 규칙을 사용하여 올바른 것이 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="bbd1050f43721b458863affe5a5a5e861a667b8a" translate="yes" xml:space="preserve">
          <source>The absolute value (or modulus) of &lt;code&gt;z&lt;/code&gt;.</source>
          <target state="translated">의 절대 값 (또는 계수) &lt;code&gt;z&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fe0c6e37bd2f8400a5d77c17be3e831a3fea0f03" translate="yes" xml:space="preserve">
          <source>The absolute value of the number. If floating-point or integral, the return type will be the same as the input.</source>
          <target state="translated">숫자의 절대 값입니다. 부동 소수점 또는 정수인 경우 반환 유형은 입력과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="d56c6a5e3d224c87e43181c1736dec49b0ab78e1" translate="yes" xml:space="preserve">
          <source>The absolute value of the number. If floating-point or integral, the return type will be the same as the input;</source>
          <target state="translated">숫자의 절대 값입니다. 부동 소수점 또는 정수인 경우 반환 유형은 입력과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="3188af20fea3638f7caeebf06aec7601348a4f70" translate="yes" xml:space="preserve">
          <source>The absolute value of x.</source>
          <target state="translated">x의 절대 값.</target>
        </trans-unit>
        <trans-unit id="9f934ce1770ad6d4aa496d65f6bc75a1edc1d979" translate="yes" xml:space="preserve">
          <source>The abstract characters encoded (see Encoded character) are known as Unicode abstract characters.</source>
          <target state="translated">인코딩 된 추상 문자 (인코딩 된 문자 참조)를 유니 코드 추상 문자라고합니다.</target>
        </trans-unit>
        <trans-unit id="6c9de70b08239cfc0c4a2733279e0d13dac73829" translate="yes" xml:space="preserve">
          <source>The accepted formats for time zone offsets are +HH, -HH, +HH:MM, and -HH:MM.</source>
          <target state="translated">표준 시간대 오프셋에 허용되는 형식은 + HH, -HH, + HH : MM 및 -HH : MM입니다.</target>
        </trans-unit>
        <trans-unit id="dd25098e5d82952dd16830d9163303d08a3443ae" translate="yes" xml:space="preserve">
          <source>The accepted formats for time zone offsets are +HH, -HH, +HHMM, and -HHMM.</source>
          <target state="translated">표준 시간대 오프셋에 허용되는 형식은 + HH, -HH, + HHMM 및 -HHMM입니다.</target>
        </trans-unit>
        <trans-unit id="2d7573dbe1c2c2ccc6dca31634fec877c6b4f215" translate="yes" xml:space="preserve">
          <source>The accumulated result as a single value for single function and as a tuple of values for multiple functions</source>
          <target state="translated">단일 함수의 단일 값과 여러 함수의 튜플로서 누적 된 결과</target>
        </trans-unit>
        <trans-unit id="4db4cabffe5c361c6e601148a12482be66dbf628" translate="yes" xml:space="preserve">
          <source>The actual format specifier, &lt;code&gt;'s'&lt;/code&gt; by default.</source>
          <target state="translated">실제 형식 지정자 인 기본적으로 &lt;code&gt;'s'&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f5f83ea5a9cae8cf7d4f8c99a06116a8136c6d2a" translate="yes" xml:space="preserve">
          <source>The actual number of bytes reserved or zero on error.</source>
          <target state="translated">예약 된 실제 바이트 수 또는 오류시 0입니다.</target>
        </trans-unit>
        <trans-unit id="c94429a916344c916935b70d1849630909c5126c" translate="yes" xml:space="preserve">
          <source>The actual type returned by finish depends on the digest implementation. &lt;code&gt;ubyte[16]&lt;/code&gt; is just used as an example. It is guaranteed that the type is a static array of ubytes.</source>
          <target state="translated">finish에 의해 리턴되는 실제 유형은 다이제스트 구현에 따라 다릅니다. &lt;code&gt;ubyte[16]&lt;/code&gt; 이 예로 사용되었습니다. 유형이 ubyte의 정적 배열임을 보장합니다.</target>
        </trans-unit>
        <trans-unit id="f965eddb5678c40e85f299ebf4bff7ff25ff635d" translate="yes" xml:space="preserve">
          <source>The additional letterCase parameter can be used to specify the case of the output data. By default the output is in upper case. To change it to the lower case pass LetterCase.lower as a parameter.</source>
          <target state="translated">추가 letterCase 매개 변수를 사용하여 출력 데이터의 대소 문자를 지정할 수 있습니다. 기본적으로 출력은 대문자입니다. 소문자로 변경하려면 LetterCase.lower를 매개 변수로 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="a85f612c9ea70b654d6d0689b427262b594b828d" translate="yes" xml:space="preserve">
          <source>The additional order parameter can be used to specify the order of the input data. By default the data is processed in increasing order, starting at index 0. To process it in the opposite order, pass Order.decreasing as a parameter.</source>
          <target state="translated">추가 주문 매개 변수를 사용하여 입력 데이터의 주문을 지정할 수 있습니다. 기본적으로 데이터는 인덱스 0에서 시작하여 증가하는 순서로 처리됩니다. 반대 순서로 처리하려면 Order.decreasing을 매개 변수로 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="5957f81d5474beefa7065939b0cc1473131ad62e" translate="yes" xml:space="preserve">
          <source>The address cannot end with a backslash</source>
          <target state="translated">주소는 백 슬래시로 끝날 수 없습니다</target>
        </trans-unit>
        <trans-unit id="884473b76201e4868789c53f5ad5333ae6e63e04" translate="yes" xml:space="preserve">
          <source>The address contains a character that is not allowed in a quoted pair</source>
          <target state="translated">주소에 따옴표로 묶을 수없는 문자가 포함되어 있습니다</target>
        </trans-unit>
        <trans-unit id="8c9a5ff6c7f32f248ada10269768a9f567d3a6d9" translate="yes" xml:space="preserve">
          <source>The address is only valid according to the broad definition of RFC 5322. It is otherwise invalid</source>
          <target state="translated">주소는 RFC 5322의 광범위한 정의에 따라서 만 유효합니다. 그렇지 않으면 유효하지 않습니다</target>
        </trans-unit>
        <trans-unit id="612f02a9ea5a91c0f5d3bab0d248e35b8e08d288" translate="yes" xml:space="preserve">
          <source>The address may not contain consecutive dots</source>
          <target state="translated">주소는 연속 된 점을 포함 할 수 없습니다</target>
        </trans-unit>
        <trans-unit id="f2ec315916ee72c713d94760053a490c4200261c" translate="yes" xml:space="preserve">
          <source>The address of the destination variable.</source>
          <target state="translated">대상 변수의 주소입니다.</target>
        </trans-unit>
        <trans-unit id="eb5d226a327a58219779ec6f85c14805039c0902" translate="yes" xml:space="preserve">
          <source>The address of the stack bottom.</source>
          <target state="translated">스택 하단의 주소입니다.</target>
        </trans-unit>
        <trans-unit id="6d486d434e5db9fa409133a5d2911ad3ba926ad2" translate="yes" xml:space="preserve">
          <source>The address of the stack top.</source>
          <target state="translated">스택 상단의 주소입니다.</target>
        </trans-unit>
        <trans-unit id="573e0fdfafaaaa6327f4d3ad798c62e0ac496505" translate="yes" xml:space="preserve">
          <source>The address of the value to compare, and receives the prior value of &lt;code&gt;here&lt;/code&gt; as output.</source>
          <target state="translated">비교할 값의 주소이며 &lt;code&gt;here&lt;/code&gt; 에서 이전 값을 출력으로받습니다.</target>
        </trans-unit>
        <trans-unit id="100ae837312c2864dadfce5bae741844606a1fdc" translate="yes" xml:space="preserve">
          <source>The aggregate it is a member of, or null.</source>
          <target state="translated">멤버가 속한 집계 또는 null입니다.</target>
        </trans-unit>
        <trans-unit id="99842dfccac0d88c0dc49fd2be32200c326ae7be" translate="yes" xml:space="preserve">
          <source>The aggregate itself must not be resized, reallocated, free'd, reassigned or destructed while the foreach is iterating over the elements.</source>
          <target state="translated">foreach가 요소를 반복하는 동안 집계 자체의 크기를 조정, 재 할당, 해제, 재 할당 또는 파괴해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="6dd852d4a388be331d9744743f8822707966e7c3" translate="yes" xml:space="preserve">
          <source>The aggregate must be loop invariant, meaning that elements to the aggregate cannot be added or removed from it in the &lt;a href=&quot;#NoScopeNonEmptyStatement&quot;&gt;&lt;i&gt;NoScopeNonEmptyStatement&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">집계는 루프 불변이어야합니다. 즉, &lt;a href=&quot;#NoScopeNonEmptyStatement&quot;&gt;&lt;i&gt;NoScopeNonEmptyStatement&lt;/i&gt;&lt;/a&gt; 에서 집계의 요소를 추가하거나 제거 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="72fbef103c621727ad68ac10218864ed5c7ca8cf" translate="yes" xml:space="preserve">
          <source>The aggregate type or module to search</source>
          <target state="translated">검색 할 집계 유형 또는 모듈</target>
        </trans-unit>
        <trans-unit id="a40360593993a6e7d8a1dd4dee1078680e89ae6d" translate="yes" xml:space="preserve">
          <source>The aggregate type to search</source>
          <target state="translated">검색 할 집계 유형</target>
        </trans-unit>
        <trans-unit id="be4d7abfbf6a487ccbcd0c016363e65c1e7e3e7f" translate="yes" xml:space="preserve">
          <source>The aggregate/range bounds are evaluated at compile time and turned into a sequence of compile-time entities by evaluating corresponding code with a &lt;a href=&quot;statement#ForeachStatement&quot;&gt;&lt;i&gt;ForeachStatement&lt;/i&gt;&lt;/a&gt;/&lt;a href=&quot;statement#ForeachRangeStatement&quot;&gt;&lt;i&gt;ForeachRangeStatement&lt;/i&gt;&lt;/a&gt; at compile time. The body of the &lt;code&gt;static foreach&lt;/code&gt; is then copied a number of times that corresponds to the number of elements of the sequence. Within the i-th copy, the name of the &lt;code&gt;static foreach&lt;/code&gt; variable is bound to the i-th entry of the sequence, either as an &lt;code&gt;enum&lt;/code&gt; variable declaration (for constants) or an &lt;code&gt;alias&lt;/code&gt; declaration (for symbols). (In particular, &lt;code&gt;static foreach&lt;/code&gt; variables are never runtime variables.)</source>
          <target state="translated">집계 / 범위 경계는 컴파일 타임에 평가되며 컴파일 타임에 &lt;a href=&quot;statement#ForeachStatement&quot;&gt;&lt;i&gt;ForeachStatement&lt;/i&gt;&lt;/a&gt; / &lt;a href=&quot;statement#ForeachRangeStatement&quot;&gt;&lt;i&gt;ForeachRangeStatement&lt;/i&gt;&lt;/a&gt; 를 사용 하여 해당 코드를 평가하여 컴파일 타임 엔터티 시퀀스로 &lt;i&gt;바뀝니다&lt;/i&gt; . &lt;code&gt;static foreach&lt;/code&gt; 의 본문은 시퀀스의 요소 수에 해당하는 여러 번 복사됩니다. i 번째 사본 내에서 &lt;code&gt;static foreach&lt;/code&gt; 변수 의 이름은 &lt;code&gt;enum&lt;/code&gt; 변수 선언 (상수) 또는 &lt;code&gt;alias&lt;/code&gt; 선언 (기호) 으로 시퀀스의 i 번째 항목에 바인딩됩니다 . 특히 &lt;code&gt;static foreach&lt;/code&gt; 변수는 런타임 변수가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="7524e87df0e2bd2478aea3589a41e1a028d60509" translate="yes" xml:space="preserve">
          <source>The algorithm was designed by Hans Dobbertin, Antoon Bosselaers, and Bart Preneel.</source>
          <target state="translated">알고리즘은 Hans Dobbertin, Antoon Bosselaers 및 Bart Preneel에 의해 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="4c2bfa97d67b17e650534b7eef10e7ad4c0bcc79" translate="yes" xml:space="preserve">
          <source>The algorithm works as follows:</source>
          <target state="translated">알고리즘은 다음과 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="48a9b12ecf15252f0b5157732b6ca9173b4931d2" translate="yes" xml:space="preserve">
          <source>The aliases are:</source>
          <target state="translated">별명은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="81631da16100dd8478c92e814bda7bbba00ac288" translate="yes" xml:space="preserve">
          <source>The aliases following this template create the public names of the log functions.</source>
          <target state="translated">이 템플리트 다음에 오는 별명은 로그 함수의 공용 이름을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="bcbe81e1130e17fc3109bc8509350a184b24f288" translate="yes" xml:space="preserve">
          <source>The aliases following this template create the public names of these log functions.</source>
          <target state="translated">이 템플릿 다음에 오는 별칭은 이러한 로그 함수의 공개 이름을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="c567df7009dd19d930ebcb716790130e92399528" translate="yes" xml:space="preserve">
          <source>The alignment for the fields of an aggregate does not affect the alignment of the aggregate itself - that is affected by the alignment setting outside of the aggregate.</source>
          <target state="translated">집계 필드의 정렬은 집계 자체의 정렬에 영향을 미치지 않습니다. 이는 집계 외부의 정렬 설정에 영향을받습니다.</target>
        </trans-unit>
        <trans-unit id="f093103ea9ccde93c26257d52a8ebe06d2563d51" translate="yes" xml:space="preserve">
          <source>The alignment is a static constant equal to &lt;code&gt;platformAlignment&lt;/code&gt;, which ensures proper alignment for any D data type.</source>
          <target state="translated">정렬은 &lt;code&gt;platformAlignment&lt;/code&gt; 와 동일한 정적 상수 이며 모든 D 데이터 유형에 대한 올바른 정렬을 보장합니다.</target>
        </trans-unit>
        <trans-unit id="15ebd1ca8e45d31f001b9c11ace8a2913c42cd0b" translate="yes" xml:space="preserve">
          <source>The alignment offered is the minimum of the two allocators' alignment.</source>
          <target state="translated">제공되는 정렬은 두 할당 자의 정렬 중 최소입니다.</target>
        </trans-unit>
        <trans-unit id="98d787b597dca14b1cd2aa32405fb6769c33f39f" translate="yes" xml:space="preserve">
          <source>The alignment offered is the same as &lt;code&gt;Allocator.alignment&lt;/code&gt;.</source>
          <target state="translated">제공되는 정렬은 &lt;code&gt;Allocator.alignment&lt;/code&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="2d9bcfc1fe50fa247260c84039c4e52f5cc8339c" translate="yes" xml:space="preserve">
          <source>The alignment offered is user-configurable statically through parameter &lt;code&gt;theAlignment&lt;/code&gt;, defaulted to &lt;code&gt;platformAlignment&lt;/code&gt;.</source>
          <target state="translated">제공되는 정렬은 매개 변수 &lt;code&gt;theAlignment&lt;/code&gt; 를 통해 정적으로 사용자가 구성 할 수 있으며 &lt;code&gt;platformAlignment&lt;/code&gt; 로 기본 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="55ae38068c659d6482341d5f2a9544d2084b247f" translate="yes" xml:space="preserve">
          <source>The alignment offered.</source>
          <target state="translated">정렬이 제공되었습니다.</target>
        </trans-unit>
        <trans-unit id="0f037bbde370840fb51ae0cd55e297a5ad94c4c1" translate="yes" xml:space="preserve">
          <source>The alignment that is guaranteed to accommodate any D object allocation on the current platform.</source>
          <target state="translated">현재 플랫폼에서 D 객체 할당을 수용 할 수있는 정렬입니다.</target>
        </trans-unit>
        <trans-unit id="ffaeeba22bc74fcd6590cff49e1181655746149d" translate="yes" xml:space="preserve">
          <source>The allocated block looks like this for blocks &amp;lt; PAGESIZE:</source>
          <target state="translated">할당 된 블록은 &amp;lt;PAGESIZE 블록에 대해 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1e6e16df97f3afd43394873bd1850208370d0247" translate="yes" xml:space="preserve">
          <source>The allocated block, or &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">할당 된 블록, 또는 &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4d585ec1807a2dc496ab963634c47b6fc38f63ce" translate="yes" xml:space="preserve">
          <source>The allocated memory is aligned to the specified alignment &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">할당 된 메모리는 지정된 정렬 &lt;code&gt;a&lt;/code&gt; 에 정렬 됩니다.</target>
        </trans-unit>
        <trans-unit id="26fd1cc82ed45b7bca2ff3a406ac59e252c10871" translate="yes" xml:space="preserve">
          <source>The allocator used for getting the needed memory. It may be an object implementing the static interface for allocators, or an &lt;code&gt;IAllocator&lt;/code&gt; reference.</source>
          <target state="translated">할당자는 필요한 메모리를 얻는 데 사용됩니다. 할당 자에 대한 정적 인터페이스를 구현하는 객체이거나 &lt;code&gt;IAllocator&lt;/code&gt; 참조 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a162642b55adf8c70cb72e78e6a91ca645573ee" translate="yes" xml:space="preserve">
          <source>The amount of time (as a &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt;) that it took to call each function &lt;code&gt;n&lt;/code&gt; times. The first value is the length of time that it took to call &lt;code&gt;fun[0]&lt;/code&gt;&lt;code&gt;n&lt;/code&gt; times. The second value is the length of time it took to call &lt;code&gt;fun[1]&lt;/code&gt;&lt;code&gt;n&lt;/code&gt; times. Etc.</source>
          <target state="translated">각 함수를 &lt;code&gt;n&lt;/code&gt; 번 호출하는 데 걸린 시간 ( &lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; &lt;/a&gt; )입니다 . 첫 번째 값은 &lt;code&gt;fun[0]&lt;/code&gt; &lt;code&gt;n&lt;/code&gt; 번 호출하는 데 걸린 시간입니다. 두 번째 값은 &lt;code&gt;fun[1]&lt;/code&gt; &lt;code&gt;n&lt;/code&gt; 번 호출하는 데 걸린 시간입니다. 기타.</target>
        </trans-unit>
        <trans-unit id="679e02f2df98ca53eb58d9358d749fc6899efa4f" translate="yes" xml:space="preserve">
          <source>The amount of time (as a &lt;a href=&quot;core_time#TickDuration&quot;&gt;&lt;code&gt;core.time.TickDuration&lt;/code&gt;&lt;/a&gt;) that it took to call each function &lt;code&gt;n&lt;/code&gt; times. The first value is the length of time that it took to call &lt;code&gt;fun[0]&lt;/code&gt;&lt;code&gt;n&lt;/code&gt; times. The second value is the length of time it took to call &lt;code&gt;fun[1]&lt;/code&gt;&lt;code&gt;n&lt;/code&gt; times. Etc.  Note that casting the TickDurations to &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt;s will make the results easier to deal with (and it may change in the future that benchmark will return an array of Durations rather than TickDurations).</source>
          <target state="translated">각 함수를 &lt;code&gt;n&lt;/code&gt; 번 호출하는 데 걸린 시간 ( &lt;a href=&quot;core_time#TickDuration&quot;&gt; &lt;code&gt;core.time.TickDuration&lt;/code&gt; &lt;/a&gt; )입니다 . 첫 번째 값은 &lt;code&gt;fun[0]&lt;/code&gt; &lt;code&gt;n&lt;/code&gt; 번 호출하는 데 걸린 시간입니다. 두 번째 값은 &lt;code&gt;fun[1]&lt;/code&gt; &lt;code&gt;n&lt;/code&gt; 번 호출하는 데 걸린 시간입니다. 기타 TickDurations를 &lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; 으로&lt;/a&gt; 캐스팅하면 결과를보다 쉽게 ​​처리 할 수 ​​있습니다 (그리고 나중에 벤치 마크에서 TickDurations가 아닌 지속 시간 배열이 반환 될 수 있음).</target>
        </trans-unit>
        <trans-unit id="5f2ab544dd26a15cec91af6687d533c4df3410af" translate="yes" xml:space="preserve">
          <source>The amount of time the offset from UTC is (negative is west of UTC, positive is east).</source>
          <target state="translated">UTC와의 오프셋 시간은 양입니다 (음수는 UTC 서쪽, 양수는 동쪽).</target>
        </trans-unit>
        <trans-unit id="0de54a6c1586b1ff3ca3aeac336a823fab853f7c" translate="yes" xml:space="preserve">
          <source>The analysis assumes no exceptions are thrown.</source>
          <target state="translated">분석에서는 예외가 발생하지 않는다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="e47e36cb20f66676952eedf4d640b1eab6c9c3bb" translate="yes" xml:space="preserve">
          <source>The archive comment. Must be less than 65536 bytes in length.</source>
          <target state="translated">아카이브 주석입니다. 길이는 65536 바이트 미만이어야합니다.</target>
        </trans-unit>
        <trans-unit id="6ca92b99392b2201548ac94076929186c2729bd5" translate="yes" xml:space="preserve">
          <source>The argument</source>
          <target state="translated">논쟁 거리</target>
        </trans-unit>
        <trans-unit id="95ad1044a61a4a355c884ad9c8beb68fea8cbf9e" translate="yes" xml:space="preserve">
          <source>The argument (or phase) of &lt;code&gt;z&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;z&lt;/code&gt; 의 인수 (또는 위상) .</target>
        </trans-unit>
        <trans-unit id="c58aecc00ef7e3c30bc80ddf70bce576b8c7b76a" translate="yes" xml:space="preserve">
          <source>The argument count.</source>
          <target state="translated">인수 개수</target>
        </trans-unit>
        <trans-unit id="d38f16231ac42e003a0a7d9c3c817f7a78c027ca" translate="yes" xml:space="preserve">
          <source>The argument is a symbol. The result is a string giving its protection level: &quot;public&quot;, &quot;private&quot;, &quot;protected&quot;, &quot;export&quot;, or &quot;package&quot;.</source>
          <target state="translated">논쟁은 상징이다. 결과는 &quot;public&quot;, &quot;private&quot;, &quot;protected&quot;, &quot;export&quot;또는 &quot;package&quot;와 같은 보호 수준을 제공하는 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="f839ff49cca61a7255e899d71e5de5d86a208b6a" translate="yes" xml:space="preserve">
          <source>The argument is a symbol. The result is a tuple of strings, possibly empty, that correspond to the namespaces the symbol resides in.</source>
          <target state="translated">인수는 상징입니다. 결과는 심볼이있는 네임 스페이스에 해당하는 문자열의 튜플 (비어있을 수 있음)입니다.</target>
        </trans-unit>
        <trans-unit id="ce7b440e5dab60852de91e6b031523ab897d0a94" translate="yes" xml:space="preserve">
          <source>The argument is a type. If it is a struct with a copy constructor, returns &lt;code&gt;true&lt;/code&gt;. Otherwise, return &lt;code&gt;false&lt;/code&gt;. Note that a copy constructor is distinct from a postblit.</source>
          <target state="translated">인수는 유형입니다. 복사 생성자가있는 구조체 &lt;code&gt;true&lt;/code&gt; 반환 합니다 . 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 반환 합니다. 복사 생성자는 postblit과 다릅니다.</target>
        </trans-unit>
        <trans-unit id="c52932bea1c79c41627f35fa183681937db58518" translate="yes" xml:space="preserve">
          <source>The argument is a type. If it is a struct with a postblit, returns &lt;code&gt;true&lt;/code&gt;. Otherwise, return &lt;code&gt;false&lt;/code&gt;. Note a postblit is distinct from a copy constructor.</source>
          <target state="translated">인수는 유형입니다. postblit이있는 구조체 &lt;code&gt;true&lt;/code&gt; 반환 합니다 . 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 반환 합니다. postblit은 복사 생성자와 구별됩니다.</target>
        </trans-unit>
        <trans-unit id="b7bee920123d48f748fd063723855b9cdf7fc70e" translate="yes" xml:space="preserve">
          <source>The argument is a type. The result is an array of &lt;code&gt;size_t&lt;/code&gt; describing the memory used by an instance of the given type.</source>
          <target state="translated">인수는 유형입니다. 결과는 주어진 유형의 인스턴스가 사용하는 메모리를 설명하는 &lt;code&gt;size_t&lt;/code&gt; 배열입니다 .</target>
        </trans-unit>
        <trans-unit id="b2ad70160d7b242b67aa98a2d5cf38772a405118" translate="yes" xml:space="preserve">
          <source>The argument must be an lvalue, which will be passed by reference and initialized upon function entry with the default value (&lt;code&gt;T.init&lt;/code&gt;) of its type</source>
          <target state="translated">인수는 lvalue 여야합니다.이 값은 참조로 전달되고 해당 유형 의 기본값 ( &lt;code&gt;T.init&lt;/code&gt; )을 사용 하여 함수 입력시 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="46d2fa2d1e3a9c3efc618f0f297d3295d7b93652" translate="yes" xml:space="preserve">
          <source>The argument pointer type.</source>
          <target state="translated">인수 포인터 유형입니다.</target>
        </trans-unit>
        <trans-unit id="bd0d0e4c2f22549c04310e29901bafb6d89f2cbb" translate="yes" xml:space="preserve">
          <source>The argument to &lt;code&gt;dg&lt;/code&gt; is &lt;code&gt;scope&lt;/code&gt;. To keep the data around after &lt;code&gt;dg&lt;/code&gt; exits, one has to copy it.</source>
          <target state="translated">&lt;code&gt;dg&lt;/code&gt; 에 대한 인수 는 &lt;code&gt;scope&lt;/code&gt; 입니다. &lt;code&gt;dg&lt;/code&gt; 종료 후 데이터를 유지하려면 복사해야합니다.</target>
        </trans-unit>
        <trans-unit id="d6506a51a0d81317d36c0b3931580ed4ae34e0c1" translate="yes" xml:space="preserve">
          <source>The arguments as a C array of strings.</source>
          <target state="translated">문자열의 C 배열로서의 인수.</target>
        </trans-unit>
        <trans-unit id="9a539cbbe8582d8d5d90be89210dc5f77ab9a858" translate="yes" xml:space="preserve">
          <source>The arguments supplied when this process was started.</source>
          <target state="translated">이 프로세스가 시작될 때 제공된 인수입니다.</target>
        </trans-unit>
        <trans-unit id="afc42ff1b01f9fdceb0afc9990aeafdba8561cdc" translate="yes" xml:space="preserve">
          <source>The arguments the function was called with. Changes to &lt;code&gt;out&lt;/code&gt; and &lt;code&gt;ref&lt;/code&gt; arguments will be visible here.</source>
          <target state="translated">함수가 호출 된 인수 &lt;code&gt;out&lt;/code&gt; 및 &lt;code&gt;ref&lt;/code&gt; 인수에 대한 변경 사항이 여기에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="63025a0e656a03617731632fd0d058123f82e206" translate="yes" xml:space="preserve">
          <source>The array generated by &lt;code&gt;makeTransTable&lt;/code&gt; is &lt;code&gt;256&lt;/code&gt; elements long such that the index is equal to the ASCII character being replaced and the value is equal to the character that it's being replaced with. Note that translate does not decode any of the characters, so you can actually pass it Extended ASCII characters if you want to (ASCII only actually uses &lt;code&gt;128&lt;/code&gt; characters), but be warned that Extended ASCII characters are not valid Unicode and therefore will result in a &lt;code&gt;UTFException&lt;/code&gt; being thrown from most other Phobos functions.</source>
          <target state="translated">&lt;code&gt;makeTransTable&lt;/code&gt; 에 의해 생성 된 배열의 길이 는 &lt;code&gt;256&lt;/code&gt; 요소 이므로 색인은 교체 될 ASCII 문자와 같고 값은 교체되는 문자와 같습니다. translate는 문자를 해독하지 않으므로 원하는 경우 확장 ASCII 문자를 실제로 전달할 수 있지만 (ASCII는 실제로 &lt;code&gt;128&lt;/code&gt; 자만 사용함 ) 확장 ASCII 문자는 유효한 유니 코드가 아니므로 경고가 표시됩니다. 대부분의 다른 Phobos 함수에서 &lt;code&gt;UTFException&lt;/code&gt; 이 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="1e36bd34216b4fb890e4b17cc00a08b3fe10bf73" translate="yes" xml:space="preserve">
          <source>The array indexing and slicing operators are overloaded by implementing the &lt;code&gt;opIndex&lt;/code&gt;, &lt;code&gt;opSlice&lt;/code&gt;, and &lt;code&gt;opDollar&lt;/code&gt; methods. These may be combined to implement multidimensional arrays.</source>
          <target state="translated">&lt;code&gt;opIndex&lt;/code&gt; , &lt;code&gt;opSlice&lt;/code&gt; 및 &lt;code&gt;opDollar&lt;/code&gt; 메서드 를 구현하면 배열 인덱싱 및 슬라이싱 연산자가 오버로드됩니다 . 이들은 다차원 어레이를 구현하기 위해 결합 될 수있다.</target>
        </trans-unit>
        <trans-unit id="1b2a7128d2d832c1302cb48d5006b21f210a2eeb" translate="yes" xml:space="preserve">
          <source>The array of &lt;code&gt;Statements&lt;/code&gt;, or &lt;code&gt;null&lt;/code&gt; if no flattening necessary</source>
          <target state="translated">어레이의 &lt;code&gt;Statements&lt;/code&gt; , 또는 &lt;code&gt;null&lt;/code&gt; 더 필요한 평탄화 없으면</target>
        </trans-unit>
        <trans-unit id="45a797de9ee37043ed5d9c3044ead0d769c8dfec" translate="yes" xml:space="preserve">
          <source>The array of allocators is publicly available for e.g. initialization and inspection.</source>
          <target state="translated">할당 자 배열은 초기화 및 검사 등을 위해 공개적으로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="78465f24447e3c88a59d9835a9423a9e3ebd4f18" translate="yes" xml:space="preserve">
          <source>The array of bits to iterate over</source>
          <target state="translated">반복 할 비트 배열</target>
        </trans-unit>
        <trans-unit id="4ca952de23045dd7d8a84c57a2dc3a2d3b262893" translate="yes" xml:space="preserve">
          <source>The array that &lt;code&gt;stuff&lt;/code&gt; will be inserted into.</source>
          <target state="translated">&lt;code&gt;stuff&lt;/code&gt; 이 삽입되는 배열입니다 .</target>
        </trans-unit>
        <trans-unit id="4321c353e1c32d604816547a52f50f3db51eff04" translate="yes" xml:space="preserve">
          <source>The array to cast to immutable.</source>
          <target state="translated">불변으로 캐스트 할 배열입니다.</target>
        </trans-unit>
        <trans-unit id="c1207d2a97f985ed8f1d6e838bce196b8c261949" translate="yes" xml:space="preserve">
          <source>The array to store the factorial number. The array is of size 21 as &lt;code&gt;ulong.max&lt;/code&gt; requires 21 digits in the factorial number system.</source>
          <target state="translated">계승 수를 저장할 배열입니다. &lt;code&gt;ulong.max&lt;/code&gt; 는 계승 수 시스템에서 21 자리가 필요하므로 배열의 크기는 21 입니다.</target>
        </trans-unit>
        <trans-unit id="2e58d1006cb20d5f3840c703c981f56532e89433" translate="yes" xml:space="preserve">
          <source>The array type to simulate</source>
          <target state="translated">시뮬레이션 할 배열 유형</target>
        </trans-unit>
        <trans-unit id="5eff91e039ba4d6d8d23f84bae72af3efca47e6c" translate="yes" xml:space="preserve">
          <source>The asm.js intermediate programming language</source>
          <target state="translated">asm.js 중간 프로그래밍 언어</target>
        </trans-unit>
        <trans-unit id="9e1495896a8171a6a847812d0360c297c1cf65a4" translate="yes" xml:space="preserve">
          <source>The assembled path.</source>
          <target state="translated">조립 된 경로.</target>
        </trans-unit>
        <trans-unit id="1e2b85b82e92a3856a1e1c2b72d37fa265091420" translate="yes" xml:space="preserve">
          <source>The assertion is independent from -release, by abort()ing. Regular assertions throw an AssertError and thus require an initialized GC, which might not be the case (yet or anymore) for the startup/shutdown code in this package (called by CRT ctors/dtors etc.).</source>
          <target state="translated">어설 션은 abort () ing에 의해 -release와 독립적입니다. 일반 어설 션에서는 AssertError가 발생하므로 초기화 된 GC가 필요합니다.이 패키지의 시작 / 종료 코드 (CRT ctors / dtors 등)의 경우에는 아직 그렇지 않을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd468c6bd7b4f24fe4681661a1f4c1bf9f53f209" translate="yes" xml:space="preserve">
          <source>The assignment character used in options with parameters (default '=').</source>
          <target state="translated">매개 변수와 함께 옵션에 사용되는 대입 문자 (기본값 '=')</target>
        </trans-unit>
        <trans-unit id="d1cc08d2be4a1f3b1bcdb0c1a5ad7e06c61f4a9a" translate="yes" xml:space="preserve">
          <source>The assignment operator &lt;code&gt;=&lt;/code&gt; can be overloaded if the left hand side is a struct aggregate, and &lt;code&gt;opAssign&lt;/code&gt; is a member function of that aggregate.</source>
          <target state="translated">왼쪽이 구조체 집계이고 &lt;code&gt;opAssign&lt;/code&gt; 이 해당 집계의 멤버 함수 인 경우 대입 연산자 &lt;code&gt;=&lt;/code&gt; 가 오버로드 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9ca96b2dca99020e1c9332c4a525410f5467c7f8" translate="yes" xml:space="preserve">
          <source>The associated Tid or Tid.init if name is not registered.</source>
          <target state="translated">이름이 등록되지 않은 경우 관련된 Tid 또는 Tid.init</target>
        </trans-unit>
        <trans-unit id="d2c138793e6130d41176963ee803d482cbf6ac55" translate="yes" xml:space="preserve">
          <source>The associative array to iterate over.</source>
          <target state="translated">반복 할 연관 배열입니다.</target>
        </trans-unit>
        <trans-unit id="3f8e903e0ceb75b15c10ccad54194376c61bbba7" translate="yes" xml:space="preserve">
          <source>The associative array.</source>
          <target state="translated">연관 배열.</target>
        </trans-unit>
        <trans-unit id="7878f31bd1a31b1a2cfd5e7a52ffdc7c9ecd24a9" translate="yes" xml:space="preserve">
          <source>The assumption is that &lt;code&gt;first&lt;/code&gt; comes before &lt;code&gt;second&lt;/code&gt; in the original text, usually meaning that the first is a starter.</source>
          <target state="translated">원래 텍스트에서 &lt;code&gt;first&lt;/code&gt; 가 &lt;code&gt;second&lt;/code&gt; 보다 먼저 나오는 것으로 가정 합니다. 일반적으로 첫 번째가 시작임을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="61806db12d64abe42691b62a374e038f9ecaadda" translate="yes" xml:space="preserve">
          <source>The atomic module provides basic support for lock-free concurrent programming.</source>
          <target state="translated">원자 모듈은 잠금없는 동시 프로그래밍에 대한 기본 지원을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="75eef2eb2a8bfe31e731a278f35f0ceb7c55d5e5" translate="yes" xml:space="preserve">
          <source>The attack happens as follows:</source>
          <target state="translated">공격은 다음과 같이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f7c54a735163e7d571809eeacaa1471999099ee3" translate="yes" xml:space="preserve">
          <source>The attribute can only be attached once to a method</source>
          <target state="translated">속성은 메소드에 한 번만 첨부 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="be7f7827649a01848c8244186acaf8539a9b85f0" translate="yes" xml:space="preserve">
          <source>The attribute can only be attached to an &lt;code&gt;extern(C++)&lt;/code&gt; symbol (&lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;class&lt;/code&gt;, &lt;code&gt;enum&lt;/code&gt;, function, and their templated counterparts).</source>
          <target state="translated">속성은 &lt;code&gt;extern(C++)&lt;/code&gt; 기호 ( &lt;code&gt;struct&lt;/code&gt; , &lt;code&gt;class&lt;/code&gt; , &lt;code&gt;enum&lt;/code&gt; , 함수 및 해당 템플릿 대응 요소) 에만 첨부 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="79ccd1c77d9bb55894eeaf0ddb5f8bb5f1442f97" translate="yes" xml:space="preserve">
          <source>The attribute can only be attached to methods or constructors which have Objective-C linkage. That is, a method or a constructor in a class or interface declared as</source>
          <target state="translated">이 속성은 Objective-C 링크가있는 메소드 또는 생성자에만 첨부 할 수 있습니다. 즉, 클래스 또는 인터페이스의 메소드 또는 생성자로 선언 된</target>
        </trans-unit>
        <trans-unit id="9e6a8c7917aafe6dd89c5b3da037ce8ce791dcd0" translate="yes" xml:space="preserve">
          <source>The attribute can only be attached to methods with Objective-C linkage</source>
          <target state="translated">이 속성은 Objective-C 연결이있는 메소드에만 첨부 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="200c85ea31972c691820bf6057378a72c8b709b9" translate="yes" xml:space="preserve">
          <source>The attribute cannot be applied to C++ namespaces. This is to prevent confusion with the C++ semantic, which allows it to be applied to namespaces.</source>
          <target state="translated">속성은 C ++ 네임 스페이스에 적용 할 수 없습니다. 이는 네임 스페이스에 적용 할 수있는 C ++ 의미 체계와의 혼동을 방지하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="0cc4b73eb5ab20f789654491f3d1669a5a798998" translate="yes" xml:space="preserve">
          <source>The attribute cannot be attached to a template method</source>
          <target state="translated">속성을 템플릿 메소드에 첨부 할 수 없습니다</target>
        </trans-unit>
        <trans-unit id="c3e58f213e4368a17eae0f25fdb580af5f953648" translate="yes" xml:space="preserve">
          <source>The attribute is defined in druntime in &lt;a href=&quot;https://dlang.org/phobos/core_attribute.html&quot;&gt;&lt;code&gt;core.attribute&lt;/code&gt;&lt;/a&gt; and aliased in &lt;a href=&quot;https://dlang.org/phobos/object.html&quot;&gt;&lt;code&gt;object&lt;/code&gt;&lt;/a&gt;, meaning it will be implicitly imported. The attribute is only defined when the version identifier &lt;a href=&quot;#objc-version-identifier&quot;&gt;&lt;code&gt;D_ObjectiveC&lt;/code&gt;&lt;/a&gt; is enabled.</source>
          <target state="translated">이 속성은에서 druntime에 정의되어 &lt;a href=&quot;https://dlang.org/phobos/core_attribute.html&quot;&gt; &lt;code&gt;core.attribute&lt;/code&gt; &lt;/a&gt; 과의 별명 &lt;a href=&quot;https://dlang.org/phobos/object.html&quot;&gt; &lt;code&gt;object&lt;/code&gt; &lt;/a&gt; 가 암시 적으로 가져옵니다 의미한다. 이 속성은 버전 식별자 &lt;a href=&quot;#objc-version-identifier&quot;&gt; &lt;code&gt;D_ObjectiveC&lt;/code&gt; &lt;/a&gt; 가 활성화 된 경우에만 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="1be7aa83910532921b956bd7ed61bdd6a250dfb0" translate="yes" xml:space="preserve">
          <source>The attribute is defined in druntime in &lt;a href=&quot;https://dlang.org/phobos/core_attribute.html&quot;&gt;&lt;code&gt;core.attribute&lt;/code&gt;&lt;/a&gt;. The attribute is only defined when the version identifier &lt;a href=&quot;#objc-version-identifier&quot;&gt;&lt;code&gt;D_ObjectiveC&lt;/code&gt;&lt;/a&gt; is enabled.</source>
          <target state="translated">속성은에서 druntime에 정의되어 &lt;a href=&quot;https://dlang.org/phobos/core_attribute.html&quot;&gt; &lt;code&gt;core.attribute&lt;/code&gt; &lt;/a&gt; . 이 속성은 버전 식별자 &lt;a href=&quot;#objc-version-identifier&quot;&gt; &lt;code&gt;D_ObjectiveC&lt;/code&gt; &lt;/a&gt; 가 활성화 된 경우에만 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="96eac9336921a98926c132d1b4d9806462791d58" translate="yes" xml:space="preserve">
          <source>The attribute of the type name is not the same as the attribute of the variable:</source>
          <target state="translated">유형 이름의 속성이 변수의 속성과 동일하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="24cd99fe8bbe482a8a5a81e7f4b51e39455ae56f" translate="yes" xml:space="preserve">
          <source>The attributes (g, i, m, s and x accepted)</source>
          <target state="translated">속성 (g, i, m, s 및 x가 허용됨)</target>
        </trans-unit>
        <trans-unit id="4ee39b3b86f5106a3fdc7e1ea7775bb7c85ac176" translate="yes" xml:space="preserve">
          <source>The attributes of the &lt;a href=&quot;expression#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression&lt;/i&gt;&lt;/a&gt; are applied where the default expression is used.</source>
          <target state="translated">&lt;a href=&quot;expression#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression&lt;/i&gt;&lt;/a&gt; 의 속성은 기본 표현식이 사용되는 곳에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="06da5fd89d1e09344f5502c88832d0079ac5062c" translate="yes" xml:space="preserve">
          <source>The attributes of the file as a &lt;code&gt;uint&lt;/code&gt;.</source>
          <target state="translated">파일의 속성을 &lt;code&gt;uint&lt;/code&gt; 로 나타 냅니다.</target>
        </trans-unit>
        <trans-unit id="ab103bac227f27736507e49db9f68f7e1c3bdf17" translate="yes" xml:space="preserve">
          <source>The background thread will buffer up to transmitBuffers number of chunks before is stops receiving data from network. When the main thread reads the chunks from the range it frees up buffers and allows for the background thread to receive more data from the network.</source>
          <target state="translated">백그라운드 스레드는 네트워크에서 데이터 수신을 중지하기 전에 최대 전송 버퍼 수의 청크까지 버퍼링합니다. 메인 스레드가 범위에서 청크를 읽으면 버퍼를 비우고 백그라운드 스레드가 네트워크에서 더 많은 데이터를 수신 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f49fc1ac2fa753eb385adebbde8c5e3739e3eb5" translate="yes" xml:space="preserve">
          <source>The background thread will buffer up to transmitBuffers number of lines before it stops receiving data from network. When the main thread reads the lines from the range it frees up buffers and allows for the background thread to receive more data from the network.</source>
          <target state="translated">백그라운드 스레드는 네트워크에서 데이터 수신을 중지하기 전에 최대 전송 버퍼 수의 라인까지 버퍼링합니다. 메인 스레드가 범위에서 라인을 읽으면 버퍼를 비우고 백그라운드 스레드가 네트워크에서 더 많은 데이터를 수신 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="df002316032ff2e092a1cc3a410d04df468eda1d" translate="yes" xml:space="preserve">
          <source>The backslash character is not treated specially inside &lt;a href=&quot;#Filespec&quot;&gt;&lt;i&gt;Filespec&lt;/i&gt;&lt;/a&gt; strings.</source>
          <target state="translated">백 슬래시 문자는 &lt;a href=&quot;#Filespec&quot;&gt;&lt;i&gt;Filespec&lt;/i&gt;&lt;/a&gt; 문자열 내에서 특별히 처리되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="a707c2f980ce4edb81a7e52be4d3486a20f75970" translate="yes" xml:space="preserve">
          <source>The barrier module provides a primitive for synchronizing the progress of a group of threads.</source>
          <target state="translated">배리어 모듈은 스레드 그룹의 진행 상황을 동기화하기위한 기본 요소를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="0f16b21bd145c48ee38391d193636c622ee32ed4" translate="yes" xml:space="preserve">
          <source>The base address of the memory block referenced by p or null on error.</source>
          <target state="translated">p가 참조하는 메모리 블록의 기본 주소 또는 오류시 null.</target>
        </trans-unit>
        <trans-unit id="202abe43b53a16dc33ac200ec72cb69c866674c7" translate="yes" xml:space="preserve">
          <source>The base class for exceptions thrown by this module</source>
          <target state="translated">이 모듈에 의해 발생 된 예외의 기본 클래스</target>
        </trans-unit>
        <trans-unit id="1a2d8f5221992ec16fa6b9228ee8706ba1b5f8a3" translate="yes" xml:space="preserve">
          <source>The base class of all AST nodes.</source>
          <target state="translated">모든 AST 노드의 기본 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="2c62b6527d85866989d96fc04ef66293021bf4e4" translate="yes" xml:space="preserve">
          <source>The base class of all errors that are safe to catch and handle.</source>
          <target state="translated">파악하고 처리하기에 안전한 모든 오류의 기본 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="3d510f9f0a1f647c90ed3c0e84e9bc68e62fbef9" translate="yes" xml:space="preserve">
          <source>The base class of all thrown objects.</source>
          <target state="translated">던져진 모든 객체의 기본 클래스.</target>
        </trans-unit>
        <trans-unit id="f59893c50b7d9f6fccbb634dce991efa1ec27e2a" translate="yes" xml:space="preserve">
          <source>The base class of all unrecoverable runtime errors.</source>
          <target state="translated">복구 할 수없는 모든 런타임 오류의 기본 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="2ae564b78fab59c5ea57c135e5d25f9a2f2f9e56" translate="yes" xml:space="preserve">
          <source>The base path to construct the relative path from.</source>
          <target state="translated">상대 경로를 구성 할 기본 경로입니다.</target>
        </trans-unit>
        <trans-unit id="7b8c780a7aaf44d0ec25e2d71c9d91275146dbb5" translate="yes" xml:space="preserve">
          <source>The base ptr in this struct can be cleared asynchronously by the GC, so any use of the returned BlkInfo should copy it and then check the base ptr of the copy before actually using it.</source>
          <target state="translated">이 구조체의 기본 ptr은 GC에 의해 비동기 적으로 지워질 수 있으므로 반환 된 BlkInfo를 사용하면이를 복사 한 다음 실제로 사용하기 전에 복사본의 기본 ptr을 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="8690f4437635a1d2bf0002da1660f73ae69c67e5" translate="yes" xml:space="preserve">
          <source>The base type.</source>
          <target state="translated">기본 유형입니다.</target>
        </trans-unit>
        <trans-unit id="dbcf092daafa8f2354629e2a622f62afa3a72b3b" translate="yes" xml:space="preserve">
          <source>The basetype must be one of: byte[16],ubyte[16],short[8],ushort[8],int[4],uint[4],long[2],ulong[2],float[4],double[2] For AVX: byte[32],ubyte[32],short[16],ushort[16],int[8],uint[8],long[4],ulong[4],float[8],double[4]</source>
          <target state="translated">기본 유형은 byte [16], ubyte [16], short [8], ushort [8], int [4], uint [4], long [2], ulong [2], float [4 중 하나 여야합니다. ], double [2] AVX의 경우 : byte [32], ubyte [32], short [16], ushort [16], int [8], uint [8], long [4], ulong [4], float [8], 더블 [4]</target>
        </trans-unit>
        <trans-unit id="399482d1c370eb1ac5e16d0aa1eed3cdd1c42d74" translate="yes" xml:space="preserve">
          <source>The basic architecture of this module is that there are standalone functions, classes for constructing an XML document from scratch (Tag, Element and Document), and also classes for parsing a pre-existing XML file (ElementParser and DocumentParser). The parsing classes</source>
          <target state="translated">이 모듈의 기본 아키텍처는 독립형 함수, 처음부터 XML 문서를 작성하기위한 클래스 (태그, 요소 및 문서) 및 기존 XML 파일 (ElementParser 및 DocumentParser)을 구문 분석하기위한 클래스가 있다는 것입니다. 파싱 ​​클래스</target>
        </trans-unit>
        <trans-unit id="bd83f1731835a7762685d9b1b4c80ae22caa482b" translate="yes" xml:space="preserve">
          <source>The basic syntax shouldn't surprise experienced users of regular expressions. For an introduction to &lt;code&gt;std.regex&lt;/code&gt; see a &lt;a href=&quot;http://dlang.org/regular-expression.html&quot;&gt;short tour&lt;/a&gt; of the module API and its abilities.</source>
          <target state="translated">기본 구문은 숙련 된 정규 표현식 사용자에게 놀라지 않아야합니다. &lt;code&gt;std.regex&lt;/code&gt; 에 대한 소개 는 모듈 API와 그 기능에 대한 &lt;a href=&quot;http://dlang.org/regular-expression.html&quot;&gt;간단한 둘러보기&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b9f946834349060b2d8968db7cae4357e2830a42" translate="yes" xml:space="preserve">
          <source>The basic syntax shouldn't surprise experienced users of regular expressions. For an introduction to &lt;code&gt;std.regex&lt;/code&gt; see a &lt;a href=&quot;https://dlang.org/regular-expression.html&quot;&gt;short tour&lt;/a&gt; of the module API and its abilities.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="234f6e28893085e219de1f945a7e3dc32736e80c" translate="yes" xml:space="preserve">
          <source>The behavior executed when a message is sent to a full mailbox.</source>
          <target state="translated">메시지가 전체 사서함으로 전송 될 때 실행되는 동작입니다.</target>
        </trans-unit>
        <trans-unit id="ab5c4600b299e121274047c9c50598443a05a652" translate="yes" xml:space="preserve">
          <source>The behavior when a</source>
          <target state="translated">때 행동</target>
        </trans-unit>
        <trans-unit id="10d232650e9a8e91839d30ef0b07aa3a7812c3ee" translate="yes" xml:space="preserve">
          <source>The behavior when the invariant does not hold is typically the same as for when &lt;a href=&quot;expression#AssertExpression&quot;&gt;&lt;i&gt;AssertExpression&lt;/i&gt;&lt;/a&gt;s fail.</source>
          <target state="translated">불변 값이 유지되지 않을 때의 동작은 일반적으로 &lt;a href=&quot;expression#AssertExpression&quot;&gt;&lt;i&gt;AssertExpression이&lt;/i&gt;&lt;/a&gt; 실패한 경우와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="32c253b8b8075fafad7db46ce9573fe20079099e" translate="yes" xml:space="preserve">
          <source>The best way is to use std.stdio.writefln, which can handle D strings:</source>
          <target state="translated">가장 좋은 방법은 std.stdio.writefln을 사용하는 것입니다.이 문자열은 D 문자열을 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="074a4ed5e1cf5284566f4613af5758030a468edf" translate="yes" xml:space="preserve">
          <source>The beta function is defined as</source>
          <target state="translated">베타 기능은 다음과 같이 정의됩니다</target>
        </trans-unit>
        <trans-unit id="776df6b9101ffe92329a9ec86d4f259d56f6f5cd" translate="yes" xml:space="preserve">
          <source>The binary heap induces structure over the underlying store such that accessing the largest element (by using the &lt;code&gt;front&lt;/code&gt; property) is a &amp;Omicron;(&lt;code&gt;1&lt;/code&gt;) operation and extracting it (by using the &lt;code&gt;removeFront()&lt;/code&gt; method) is done fast in &amp;Omicron;(&lt;code&gt;log n&lt;/code&gt;) time.</source>
          <target state="translated">이진 힙은 가장 큰 요소에 액세스하는 경우 ( &lt;code&gt;front&lt;/code&gt; 속성 을 사용하여 ) &amp;Omicron; ( &lt;code&gt;1&lt;/code&gt; ) 연산이고 추출 ( &lt;code&gt;removeFront()&lt;/code&gt; 메서드 를 사용하여)을 추출하는 것이 &amp;Omicron; ( &lt;code&gt;log n&lt;/code&gt; ) 에서 빠르게 수행 되도록 기본 저장소에 대한 구조를 유도 합니다. 시각.</target>
        </trans-unit>
        <trans-unit id="4c8ec4e4b9635f6e100188d75e888fd06cd8e192" translate="yes" xml:space="preserve">
          <source>The binary operator involved, e.g. &lt;code&gt;/&lt;/code&gt;</source>
          <target state="translated">관련된 이진 연산자, 예를 들어 &lt;code&gt;/&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d68c85a934ba6bb56625f3815258575a45ac4309" translate="yes" xml:space="preserve">
          <source>The binary operator ~ is the</source>
          <target state="translated">이항 연산자 ~는</target>
        </trans-unit>
        <trans-unit id="97c48bbd4c951e34df677fdb5ba8d5cff4f6b9ee" translate="yes" xml:space="preserve">
          <source>The binary predicate to compare the elements of the two ranges.</source>
          <target state="translated">이 범위 술어는 두 범위의 요소를 비교합니다.</target>
        </trans-unit>
        <trans-unit id="c0f1385da3c1b4c526f08c5b626218775066160e" translate="yes" xml:space="preserve">
          <source>The bit number of the first bit set. The return value is undefined if v is zero.</source>
          <target state="translated">첫 번째 비트 세트의 비트 번호입니다. v가 0이면 리턴 값이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f465b8408295f09e1e80dc77dc9289f124c8a06a" translate="yes" xml:space="preserve">
          <source>The bitwise OR of the equivalent &lt;a href=&quot;#ParameterStorageClass&quot;&gt;&lt;code&gt;ParameterStorageClass&lt;/code&gt;&lt;/a&gt;&lt;code&gt;enum&lt;/code&gt;s.</source>
          <target state="translated">동등한 &lt;a href=&quot;#ParameterStorageClass&quot;&gt; &lt;code&gt;ParameterStorageClass&lt;/code&gt; &lt;/a&gt; &lt;code&gt;enum&lt;/code&gt; 의 비트 단위 OR입니다 .</target>
        </trans-unit>
        <trans-unit id="4fdcc0b7027ad4b488f80691f340dd0dc77ff487" translate="yes" xml:space="preserve">
          <source>The block statement form is:</source>
          <target state="translated">블록 설명 양식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="dd4bbefc576334b8b13692b8e44bc6ee98e6f364" translate="yes" xml:space="preserve">
          <source>The body of the</source>
          <target state="translated">몸</target>
        </trans-unit>
        <trans-unit id="96cd6fd8f2e0864106740818ab2710f9f6ce82f8" translate="yes" xml:space="preserve">
          <source>The body of the constructor is executed.</source>
          <target state="translated">생성자의 본문이 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="6863a629a6b6532a62dd2be0fcf0c83cbe0ecc4b" translate="yes" xml:space="preserve">
          <source>The bool type is a byte-size type that can only hold the value &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">bool 유형은 &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt; 값만 보유 할 수있는 바이트 크기 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="595a315b8710f1cdf54c5c5a89b18ff6fdc7c01a" translate="yes" xml:space="preserve">
          <source>The bound being violated</source>
          <target state="translated">위반되는 경계</target>
        </trans-unit>
        <trans-unit id="58bf9949e91d1f67475ea8dd8dc1479acb9a7b6c" translate="yes" xml:space="preserve">
          <source>The buffer to store decoded result.</source>
          <target state="translated">디코딩 된 결과를 저장할 버퍼입니다.</target>
        </trans-unit>
        <trans-unit id="cbd8e18ccd6c72e47f49142b87596eb0b37a2753" translate="yes" xml:space="preserve">
          <source>The buffer to write to</source>
          <target state="translated">쓸 버퍼</target>
        </trans-unit>
        <trans-unit id="d4158bf50efe732ca75d7c0746df60cf6a107caa" translate="yes" xml:space="preserve">
          <source>The built in properties &lt;code&gt;.sizeof&lt;/code&gt;, &lt;code&gt;.alignof&lt;/code&gt;, and &lt;code&gt;.mangleof&lt;/code&gt; may not be declared as fields or methods in structs, unions, classes or enums.</source>
          <target state="translated">내장 속성 &lt;code&gt;.sizeof&lt;/code&gt; , &lt;code&gt;.alignof&lt;/code&gt; 및 &lt;code&gt;.mangleof&lt;/code&gt; 는 구조체, 공용체, 클래스 또는 열거 형의 필드 또는 메서드로 선언 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="cb37eb5828bb8f76b215ba701695af10297cc319" translate="yes" xml:space="preserve">
          <source>The built-in address-of operator (unary &lt;code&gt;&amp;amp;&lt;/code&gt;) may only be applied to lvalues.</source>
          <target state="translated">기본 제공 주소 연산자 (단항 &lt;code&gt;&amp;amp;&lt;/code&gt; )는 lvalue에만 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="01d529a280bedf8d2329f923f87f28d6d2414970" translate="yes" xml:space="preserve">
          <source>The built-in char types are any of &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;wchar&lt;/code&gt; or &lt;code&gt;dchar&lt;/code&gt;, with or without qualifiers.</source>
          <target state="translated">내장 문자 유형은 규정자가 있거나없는 &lt;code&gt;char&lt;/code&gt; , &lt;code&gt;wchar&lt;/code&gt; 또는 &lt;code&gt;dchar&lt;/code&gt; 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="26447929ba19118cb6719911318de883e533656a" translate="yes" xml:space="preserve">
          <source>The built-in string types are &lt;code&gt;Char[]&lt;/code&gt;, where &lt;code&gt;Char&lt;/code&gt; is any of &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;wchar&lt;/code&gt; or &lt;code&gt;dchar&lt;/code&gt;, with or without qualifiers.</source>
          <target state="translated">내장 문자열 유형은 &lt;code&gt;Char[]&lt;/code&gt; 이며, 여기서 &lt;code&gt;Char&lt;/code&gt; 는 한정자가 있거나없는 &lt;code&gt;char&lt;/code&gt; , &lt;code&gt;wchar&lt;/code&gt; 또는 &lt;code&gt;dchar&lt;/code&gt; 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="985d41f10ebe09bea42e87e43e676a34b5b701c9" translate="yes" xml:space="preserve">
          <source>The call &lt;code&gt;gapWeightedSimilarity(s, t, 1)&lt;/code&gt; simply counts all of these matches and adds them up, returning 7.</source>
          <target state="translated">&lt;code&gt;gapWeightedSimilarity(s, t, 1)&lt;/code&gt; 호출은 단순히 이러한 모든 일치 항목을 계산하고 합산하여 7을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9504202f5ac0a1e1b308309ee50027e163c8c607" translate="yes" xml:space="preserve">
          <source>The call above eliminated the gapped matches (&lt;code&gt;&quot;Hello&quot;, &quot;new&quot;&lt;/code&gt;), (&lt;code&gt;&quot;Hello&quot;, &quot;world&quot;&lt;/code&gt;), and (&lt;code&gt;&quot;Hello&quot;, &quot;new&quot;, &quot;world&quot;&lt;/code&gt;) from the tally. That leaves only 4 matches.</source>
          <target state="translated">위의 호출은 집계에서 일치하지 않는 일치 항목 ( &lt;code&gt;&quot;Hello&quot;, &quot;new&quot;&lt;/code&gt; ), &lt;code&gt;&quot;Hello&quot;, &quot;world&quot;&lt;/code&gt; ) 및 ( &lt;code&gt;&quot;Hello&quot;, &quot;new&quot;, &quot;world&quot;&lt;/code&gt; )를 제거했습니다. 그것은 4 경기 만 남습니다.</target>
        </trans-unit>
        <trans-unit id="a0a65d3fa68c14100a930ea8ba7a95c4b2425c75" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;func()&lt;/code&gt; is ambiguous because Foo.func and Bar.func are in different scopes.</source>
          <target state="translated">Foo.func와 Bar.func의 범위가 다르기 때문에 &lt;code&gt;func()&lt;/code&gt; 호출 이 모호합니다.</target>
        </trans-unit>
        <trans-unit id="e538f3dd7f1bdd1b474917678b37be623289cdfe" translate="yes" xml:space="preserve">
          <source>The call will duplicate the array appropriately.  Note that checking for uniqueness during compilation is possible in certain cases, especially when a function is marked as a pure function. The following example does not need to call assumeUnique because the compiler can infer the uniqueness of the array in the pure function:</source>
          <target state="translated">호출은 배열을 적절히 복제합니다. 컴파일 중 고유성을 검사하는 것은 특정 경우, 특히 함수가 순수한 함수로 표시 될 때 가능합니다. 컴파일러가 순수 함수에서 배열의 고유성을 유추 할 수 있으므로 다음 예제에서는 assumeUnique를 호출 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="242f08d2b1a1a758366f7a48d7e4dad847e662cb" translate="yes" xml:space="preserve">
          <source>The callable that is called when a handled primitive throws a &lt;code&gt;Throwable&lt;/code&gt; of type &lt;code&gt;E&lt;/code&gt;. The handler must accept arguments of the form &lt;code&gt;E, ref IRange&lt;/code&gt; and its return value is used as the primitive's return value whenever &lt;code&gt;E&lt;/code&gt; is thrown. For &lt;code&gt;opIndex&lt;/code&gt;, the handler can optionally recieve a third argument; the index that caused the exception.</source>
          <target state="translated">처리 된 기본 요소가 &lt;code&gt;E&lt;/code&gt; 유형 의 &lt;code&gt;Throwable&lt;/code&gt; 을 던질 때 호출되는 콜 러블 . 핸들러는 &lt;code&gt;E, ref IRange&lt;/code&gt; 형식의 인수를 허용해야하며 &lt;code&gt;E&lt;/code&gt; 가 발생할 때마다 해당 리턴 값이 기본 요소의 리턴 값으로 사용됩니다 . 들면 &lt;code&gt;opIndex&lt;/code&gt; 핸들러는 임의로 번째 인수를받을 수있다; 예외의 원인이 된 인덱스</target>
        </trans-unit>
        <trans-unit id="8595a4fb5e8942c865e60e579f4bc97ae9361768" translate="yes" xml:space="preserve">
          <source>The callable to apply on create.</source>
          <target state="translated">작성시 적용 할 호출 가능.</target>
        </trans-unit>
        <trans-unit id="9e7cb4c784340dbcc9223bb09fc5bd0008d15a78" translate="yes" xml:space="preserve">
          <source>The callable to apply on update.</source>
          <target state="translated">업데이트시 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="47f8d3d3341c2f3859f008d663d7d39abed383a3" translate="yes" xml:space="preserve">
          <source>The callback returns the incoming bytes read. If not the entire array is the request will abort. The special value .pauseRequest can be returned in order to pause the current request.</source>
          <target state="translated">콜백은 읽은 수신 바이트를 반환합니다. 전체 배열이 아닌 경우 요청이 중단됩니다. 현재 요청을 일시 정지하기 위해 특수 값 .pauseRequest를 리턴 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ff970a770b2ff7a8a51d3f9664a81966555d9c0" translate="yes" xml:space="preserve">
          <source>The callback returns the incoming bytes read. If not the entire array is the request will abort. The special value HTTP.pauseRequest can be returned in order to pause the current request.</source>
          <target state="translated">콜백은 읽은 수신 바이트를 반환합니다. 전체 배열이 아닌 경우 요청이 중단됩니다. 현재 요청을 일시 정지하기 위해 특수 값 HTTP.pauseRequest를 리턴 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e149c07dded4d56d5080da41c572390f4d5c4e3" translate="yes" xml:space="preserve">
          <source>The callback returns the number of elements in the buffer that have been filled and are ready to send. The special value &lt;code&gt;.abortRequest&lt;/code&gt; can be returned in order to abort the current request. The special value &lt;code&gt;.pauseRequest&lt;/code&gt; can be returned in order to pause the current request.</source>
          <target state="translated">콜백은 버퍼에 채워져 보낼 준비가 된 요소 수를 반환합니다. 현재 요청을 중단하기 위해 특수 값 &lt;code&gt;.abortRequest&lt;/code&gt; 를 리턴 할 수 있습니다. 현재 요청을 일시 정지하기 위해 특수 값 &lt;code&gt;.pauseRequest&lt;/code&gt; 를 리턴 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2137ada3ae84929eb868bf721851f3520aa621f8" translate="yes" xml:space="preserve">
          <source>The callback returns the number of elements in the buffer that have been filled and are ready to send. The special value &lt;code&gt;Curl.abortRequest&lt;/code&gt; can be returned in order to abort the current request. The special value &lt;code&gt;Curl.pauseRequest&lt;/code&gt; can be returned in order to pause the current request.</source>
          <target state="translated">콜백은 버퍼에 채워져 보낼 준비가 된 요소 수를 반환합니다. 현재 요청을 중단하기 위해 &lt;code&gt;Curl.abortRequest&lt;/code&gt; 특수 값을 리턴 할 수 있습니다. 현재 요청을 일시 정지하기 위해 특수 값 &lt;code&gt;Curl.pauseRequest&lt;/code&gt; 를 리턴 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="559652851d8e835ca6e4e25200037a9b2b88d7e9" translate="yes" xml:space="preserve">
          <source>The callback returns the success state of the seeking &lt;a href=&quot;etc_c_curl#CurlSeek&quot;&gt;&lt;code&gt;etc.c.curl.CurlSeek&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">콜백은 탐색 등의 성공 상태를 반환합니다 &lt;a href=&quot;etc_c_curl#CurlSeek&quot;&gt; &lt;code&gt;etc.c.curl.CurlSeek&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4f77b46c5f5f6357c24d9647b815993a85d323b8" translate="yes" xml:space="preserve">
          <source>The callback should return zero.</source>
          <target state="translated">콜백은 0을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="bf29eeac01c5a4dd86a6df695ab4b58778a8d6c6" translate="yes" xml:space="preserve">
          <source>The callback will receive a header field key, value as parameter. The &lt;code&gt;const(char)[]&lt;/code&gt; arrays are not valid after the delegate has returned.</source>
          <target state="translated">콜백은 헤더 필드 키, 값을 매개 변수로받습니다. &lt;code&gt;const(char)[]&lt;/code&gt; 대리자가 리턴 한 후 어레이는 유효하지 않다.</target>
        </trans-unit>
        <trans-unit id="0479a0d5e5b9b6df459258bae677881c90ce0ee0" translate="yes" xml:space="preserve">
          <source>The callee cleans the stack.</source>
          <target state="translated">수신자가 스택을 청소합니다.</target>
        </trans-unit>
        <trans-unit id="969d6b1248484a0e1ba90ba5ae45f38dfe225ca5" translate="yes" xml:space="preserve">
          <source>The caller guarantees that there are no other live pointers to the passed memory block, still it might not be freed immediately by &lt;code&gt;realloc&lt;/code&gt;. The garbage collector can reclaim the memory block in a later collection if it is unused. If allocation fails, this function will throw an &lt;code&gt;OutOfMemoryError&lt;/code&gt;.</source>
          <target state="translated">호출자는 전달 된 메모리 블록에 대한 다른 라이브 포인터가 없음을 보장하지만 여전히 &lt;code&gt;realloc&lt;/code&gt; 에 의해 즉시 해제되지 않을 수 있습니다 . 가비지 수집기는 메모리 블록이 사용되지 않는 경우 이후 컬렉션에서 메모리 블록을 회수 할 수 있습니다. 할당이 실패하면이 함수는 &lt;code&gt;OutOfMemoryError&lt;/code&gt; 를 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="42c8382f8ef7fb6520cb3687eb152b34b852d9fc" translate="yes" xml:space="preserve">
          <source>The caller is expected to clean the stack. &lt;code&gt;_argptr&lt;/code&gt; is not passed, it is computed by the callee.</source>
          <target state="translated">호출자는 스택을 청소해야합니다. &lt;code&gt;_argptr&lt;/code&gt; 은 전달되지 않으며, 수신자가 계산합니다.</target>
        </trans-unit>
        <trans-unit id="71f4f46b73c55f9c109f0c80b9ef8abbb104d1fb" translate="yes" xml:space="preserve">
          <source>The calling thread must be attached to the runtime.</source>
          <target state="translated">호출 스레드는 런타임에 연결되어야합니다.</target>
        </trans-unit>
        <trans-unit id="958f07aa30dc8c63baec5ad6b7a6ab8de498d71d" translate="yes" xml:space="preserve">
          <source>The canonical name is returned in &lt;code&gt;canonicalName&lt;/code&gt; member in the first &lt;code&gt;AddressInfo&lt;/code&gt;.</source>
          <target state="translated">표준 이름은 첫 번째 &lt;code&gt;AddressInfo&lt;/code&gt; 의 &lt;code&gt;canonicalName&lt;/code&gt; 멤버에 리턴됩니다 .</target>
        </trans-unit>
        <trans-unit id="5578f20f728ef7ea894f9c8485dc8375879fa1eb" translate="yes" xml:space="preserve">
          <source>The capacity of a slice may be impacted by operations on other slices.</source>
          <target state="translated">슬라이스의 용량은 다른 슬라이스의 작업에 영향을받을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="107b78d2e608ef92e8a7f001aab1e580890d2636" translate="yes" xml:space="preserve">
          <source>The capitalized string.</source>
          <target state="translated">대문자 문자열</target>
        </trans-unit>
        <trans-unit id="a02d900e092203fe7acb10d7253e6c7295d71b57" translate="yes" xml:space="preserve">
          <source>The case expressions cannot evaluate to a run time initialized value.</source>
          <target state="translated">케이스 표현식은 런타임 초기화 값으로 평가할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c660de992148409122dcd32983da08c9290b863c" translate="yes" xml:space="preserve">
          <source>The case expressions must all evaluate to a constant value or array, or a runtime initialized const or immutable variable of integral type. They must be implicitly convertible to the type of the switch &lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;Expression&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">대소 문자 표현식은 모두 상수 값 또는 배열 또는 런타임으로 초기화 된 const 또는 정수 유형의 불변 변수로 평가되어야합니다. 스위치 &lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;Expression&lt;/i&gt;&lt;/a&gt; 형식으로 암시 적으로 변환 할 수 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="5f4e6b9553e729310217386d882aa9d464ad3e08" translate="yes" xml:space="preserve">
          <source>The case expressions, &lt;a href=&quot;expression#ArgumentList&quot;&gt;&lt;i&gt;ArgumentList&lt;/i&gt;&lt;/a&gt;, are a comma separated list of expressions.</source>
          <target state="translated">대소 문자 표현식 &lt;a href=&quot;expression#ArgumentList&quot;&gt;&lt;i&gt;ArgumentList&lt;/i&gt;&lt;/a&gt; 는 쉼표로 구분 된 표현식 목록입니다.</target>
        </trans-unit>
        <trans-unit id="ed530c7eb728f8fa72fe143a48d1125946f28cef" translate="yes" xml:space="preserve">
          <source>The cast to &lt;code&gt;int&lt;/code&gt; is required.</source>
          <target state="translated">&lt;code&gt;int&lt;/code&gt; 로의 캐스트 가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="5c065923e841d97029a1a1a23e3c446aaf97b033" translate="yes" xml:space="preserve">
          <source>The character that terminates a line</source>
          <target state="translated">줄을 끝내는 문자</target>
        </trans-unit>
        <trans-unit id="629001ed0c4dadc576ebea811f98cc1aed6e90df" translate="yes" xml:space="preserve">
          <source>The character to represent a comma in the specification</source>
          <target state="translated">사양에서 쉼표를 나타내는 문자</target>
        </trans-unit>
        <trans-unit id="ec12026df227efabbda621551d1564e02d496853" translate="yes" xml:space="preserve">
          <source>The character to represent a quote in the specification</source>
          <target state="translated">사양에서 인용을 나타내는 문자</target>
        </trans-unit>
        <trans-unit id="ed980b4c59776662298660727d4c9f56b2f99259" translate="yes" xml:space="preserve">
          <source>The character to test.</source>
          <target state="translated">테스트 할 캐릭터입니다.</target>
        </trans-unit>
        <trans-unit id="f806bb97e00ae2a4d1965414bf699f20536e139e" translate="yes" xml:space="preserve">
          <source>The character to use for filling excess space in the field</source>
          <target state="translated">필드에서 여분의 공간을 채우는 데 사용할 문자</target>
        </trans-unit>
        <trans-unit id="7954bf846b49b756c8f7adbc1f7bb59d31d8fe0f" translate="yes" xml:space="preserve">
          <source>The character-based range to be split. Must be a string, or a random-access range of character types.</source>
          <target state="translated">분할 할 문자 기반 범위입니다. 문자열이거나 임의 액세스 범위의 문자 유형이어야합니다.</target>
        </trans-unit>
        <trans-unit id="da430ad7582915a68166d7b59e0099addfd5c754" translate="yes" xml:space="preserve">
          <source>The characters to remove from the string.</source>
          <target state="translated">문자열에서 제거 할 문자입니다.</target>
        </trans-unit>
        <trans-unit id="0bc92faf6490d5bb1265aa7a3286ff3cc0386eb8" translate="yes" xml:space="preserve">
          <source>The characters to replace with.</source>
          <target state="translated">바꿀 문자입니다.</target>
        </trans-unit>
        <trans-unit id="b24b1e6a036609d0af960c16ec68d51a3e145307" translate="yes" xml:space="preserve">
          <source>The characters to replace.</source>
          <target state="translated">바꿀 문자입니다.</target>
        </trans-unit>
        <trans-unit id="da530bf40507c33ab0ce7b6f55c2e0bfe50af65c" translate="yes" xml:space="preserve">
          <source>The choice of the normalization form depends on the particular use case. NFC is the best form for general text, since it's more compatible with strings converted from legacy encodings. NFKC is the preferred form for identifiers, especially where there are security concerns. NFD and NFKD are the most useful for internal processing.</source>
          <target state="translated">정규화 양식의 선택은 특정 사용 사례에 따라 다릅니다. NFC는 레거시 인코딩에서 변환 된 문자열과 더 호환되므로 일반 텍스트에 가장 적합한 형식입니다. NFKC는 특히 보안 문제가있는 경우 선호되는 식별자 형식입니다. NFD 및 NFKD는 내부 처리에 가장 유용합니다.</target>
        </trans-unit>
        <trans-unit id="f5c734e10fd22e90551eca30f40d587d99f0c42a" translate="yes" xml:space="preserve">
          <source>The class allocator is not called if the instance is created on the stack.</source>
          <target state="translated">인스턴스가 스택에서 작성되면 클래스 할당자가 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="888d63439c91bbcddad644e4c7db9438fc2745dc" translate="yes" xml:space="preserve">
          <source>The class declaration this belongs to.</source>
          <target state="translated">이것에 속하는 클래스 선언.</target>
        </trans-unit>
        <trans-unit id="9821e074c45da0757bbe913fb06d396a19d66ece" translate="yes" xml:space="preserve">
          <source>The class definition:</source>
          <target state="translated">클래스 정의 :</target>
        </trans-unit>
        <trans-unit id="6cd8612310d940ff26e5edb5b4fcdb1ec41c2ab8" translate="yes" xml:space="preserve">
          <source>The class destructor will be called when the result of &lt;code&gt;scoped()&lt;/code&gt; is itself destroyed.</source>
          <target state="translated">&lt;code&gt;scoped()&lt;/code&gt; 결과 자체가 소멸 되면 클래스 소멸자가 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="c93c7a1d79db5f0e6fcfb2d97ac7ab27199857e4" translate="yes" xml:space="preserve">
          <source>The code above is equivalent to:</source>
          <target state="translated">위의 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5b07f3ff2ae08c1115f9318187e98dfad8b61d12" translate="yes" xml:space="preserve">
          <source>The code below defines a scalable allocator consisting of 1 MB (or larger) blocks fetched from the garbage-collected heap. Each block is organized as a KR-style heap. More blocks are allocated and freed on a need basis.  This is the closest example to the allocator introduced in the K&amp;amp;R book. It should perform slightly better because instead of searching through one large free list, it searches through several shorter lists in LRU order. Also, it actually returns memory to the operating system when possible.</source>
          <target state="translated">아래 코드는 가비지 수집 힙에서 가져온 1MB 이상의 블록으로 구성된 확장 가능 할당자를 정의합니다. 각 블록은 KR 스타일 힙으로 구성됩니다. 더 많은 블록이 필요에 따라 할당되고 해제됩니다. 이것은 K &amp;amp; R 책에서 소개 된 할당 자에 가장 가까운 예입니다. 하나의 큰 사용 가능한 목록을 검색하는 대신 LRU 순서로 여러 개의 짧은 목록을 검색하므로 약간 더 성능이 좋아야합니다. 또한 가능한 경우 실제로 운영 체제로 메모리를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="12ac0fdde9cbd45bcf0987afae5cbf0bd1ef3d0f" translate="yes" xml:space="preserve">
          <source>The code example below shows a simple implementation of a 2-dimensional array with overloaded indexing and slicing operators. The explanations of the various constructs employed are given in the sections following.</source>
          <target state="translated">아래 코드 예제는 오버로드 된 인덱싱 및 슬라이싱 연산자를 사용하여 2 차원 배열의 간단한 구현을 보여줍니다. 사용 된 다양한 구성에 대한 설명은 다음 섹션에 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ef6a79ff5d24e866faf6946cbbd2a6330b8fc2c" translate="yes" xml:space="preserve">
          <source>The code generated by these three functions is identical. To indicate that these can be one function, the inout type constructor is employed:</source>
          <target state="translated">이 세 가지 기능으로 생성 된 코드는 동일합니다. 이것이 하나의 함수가 될 수 있음을 나타 내기 위해 inout 유형 생성자가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a7b0bdcbeba131b0b10ad17da0e5e625fbde9d3f" translate="yes" xml:space="preserve">
          <source>The code in the invariant may not call any public non-static members of the class or struct, either directly or indirectly. Doing so will result in a stack overflow, as the invariant will wind up being called in an infinitely recursive manner.</source>
          <target state="translated">불변의 코드는 직간접 적으로 클래스 또는 구조체의 정적이 아닌 공용 멤버를 호출 할 수 없습니다. 이렇게하면 고정 재귀적인 방식으로 불변 값이 호출되므로 스택 오버플로가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5567d3893a01342e1a0bc105518655a6faaaab38" translate="yes" xml:space="preserve">
          <source>The code that detects an error knows more about the error than the code that must recover from the error.</source>
          <target state="translated">오류를 감지하는 코드는 오류에서 복구해야하는 코드보다 오류에 대해 더 많이 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="820bb6ee9e6aba52c669ddd54299d0ca78f94c71" translate="yes" xml:space="preserve">
          <source>The code to implement this API is not available in the public release of SQLite.</source>
          <target state="translated">이 API를 구현하는 코드는 SQLite의 공개 릴리스에서 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="0b173c608e91ac1dd9ab1e2ebbf859ba8dcba5c7" translate="yes" xml:space="preserve">
          <source>The comment form must match the D language comments.</source>
          <target state="translated">주석 양식은 D 언어 주석과 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="2a6df46d142eee7bea5f31e6c40f2872f6843d42" translate="yes" xml:space="preserve">
          <source>The common use case for printing a stack trace is when &lt;code&gt;toString&lt;/code&gt; is called on a &lt;code&gt;Throwable&lt;/code&gt; (see &lt;code&gt;object.d&lt;/code&gt;). It will iterate on what is likely to be the default trace handler (see &lt;code&gt;core.runtime : defaultTraceHandler&lt;/code&gt;). The class returned by &lt;code&gt;defaultTraceHandler&lt;/code&gt; is what ends up calling into this module, through the use of &lt;code&gt;core.internal.traits : externDFunc&lt;/code&gt;.</source>
          <target state="translated">스택 추적을 인쇄하는 일반적인 사용 사례 는 &lt;code&gt;Throwable&lt;/code&gt; 에서 &lt;code&gt;toString&lt;/code&gt; 이 호출되는 경우입니다 ( &lt;code&gt;object.d&lt;/code&gt; 참조 ). 기본 추적 핸들러가 될 가능성이있는 항목을 반복합니다 ( &lt;code&gt;core.runtime : defaultTraceHandler&lt;/code&gt; 참조 ). &lt;code&gt;defaultTraceHandler&lt;/code&gt; 에 의해 반환 된 클래스 는 &lt;code&gt;core.internal.traits : externDFunc&lt;/code&gt; 사용을 통해이 모듈을 호출하게됩니다 .</target>
        </trans-unit>
        <trans-unit id="c27e68ae34b416356827d090284f419f63369dc7" translate="yes" xml:space="preserve">
          <source>The communication domain used to resolve an address.</source>
          <target state="translated">주소를 확인하는 데 사용되는 통신 도메인</target>
        </trans-unit>
        <trans-unit id="a8ad0e630b8b0da66aee6c7edb8a63daad73619d" translate="yes" xml:space="preserve">
          <source>The comparison predicate</source>
          <target state="translated">비교 술어</target>
        </trans-unit>
        <trans-unit id="8236e0769cfa2f3f369ae0002ca893f3e532ba5d" translate="yes" xml:space="preserve">
          <source>The comparison to use.</source>
          <target state="translated">사용할 비교입니다.</target>
        </trans-unit>
        <trans-unit id="5dabbbc6b85984f7c631dd31a40e4692958581a7" translate="yes" xml:space="preserve">
          <source>The comparison value.</source>
          <target state="translated">비교 값.</target>
        </trans-unit>
        <trans-unit id="1884ff0398391fb51645ddf67a895753f5f23bb8" translate="yes" xml:space="preserve">
          <source>The compile time length of &lt;code&gt;arr&lt;/code&gt; if it's known.</source>
          <target state="translated">알려진 경우 &lt;code&gt;arr&lt;/code&gt; 의 컴파일 시간 길이입니다 .</target>
        </trans-unit>
        <trans-unit id="20e21ca3ed0c66cb684853be4c9050ce61bc28b7" translate="yes" xml:space="preserve">
          <source>The compiler is free to assume the assert expression is true and optimize subsequent code accordingly.</source>
          <target state="translated">컴파일러는 어설 션 표현식이 참이라고 가정하고 그에 따라 후속 코드를 최적화합니다.</target>
        </trans-unit>
        <trans-unit id="7c2be101920c07dfed2a3b2ae4e783a017a150b5" translate="yes" xml:space="preserve">
          <source>The compiler lowers expressions of &lt;code&gt;cast(TTo[])TFrom[]&lt;/code&gt; to this implementation.</source>
          <target state="translated">컴파일러는 &lt;code&gt;cast(TTo[])TFrom[]&lt;/code&gt; 표현식 을이 구현으로 낮 춥니 다 .</target>
        </trans-unit>
        <trans-unit id="3119e558dc9b76ce9fd8e624bacd61cca8100ec6" translate="yes" xml:space="preserve">
          <source>The compiler makes the decision whether to inline a function or not. This decision may be controlled by &lt;a href=&quot;pragma#inline&quot;&gt;&lt;code&gt;pragma(inline)&lt;/code&gt;&lt;/a&gt;, assuming that the compiler implements it, which is not mandatory.</source>
          <target state="translated">컴파일러는 함수를 인라인할지 여부를 결정합니다. 이 결정은 컴파일러가이를 구현한다고 가정하고 &lt;a href=&quot;pragma#inline&quot;&gt; &lt;code&gt;pragma(inline)&lt;/code&gt; &lt;/a&gt; 의해 제어 될 수 있습니다 ( 필수 아님).</target>
        </trans-unit>
        <trans-unit id="291025563ce73c7bc11eafe0442e20ca4b9ab725" translate="yes" xml:space="preserve">
          <source>The compiler performs the following checks to enforce the correct usage of the &lt;code&gt;@selector&lt;/code&gt; attribute:</source>
          <target state="translated">컴파일러는 다음과 같은 검사를 수행하여 &lt;code&gt;@selector&lt;/code&gt; 속성을 올바르게 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="634747431ffe30a4862ec872dad71a6eb253993f" translate="yes" xml:space="preserve">
          <source>The compiler will not give an error if the hidden function is disjoint, as far as overloading is concerned, from all the other virtual functions is the inheritance hierarchy.</source>
          <target state="translated">오버로드와 관련하여 숨겨진 함수가 분리되어 있으면 다른 모든 가상 함수에서 상속 계층 구조가 컴파일러에서 오류를 발생시키지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7e55718066f0afe8bf9a0cce63044c7450d60879" translate="yes" xml:space="preserve">
          <source>The compiler will then know to use the symbols from std.datetime.stopwatch rather than the deprecated ones from std.datetime.package.</source>
          <target state="translated">그러면 컴파일러는 더 이상 사용되지 않는 std.datetime.package가 아닌 std.datetime.stopwatch의 기호를 사용하는 것을 알게됩니다.</target>
        </trans-unit>
        <trans-unit id="1213489b3c94adf580de8081b13190aa4c164fbb" translate="yes" xml:space="preserve">
          <source>The complex base 10 logarithm of &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 복소 밑이 10 인 로그</target>
        </trans-unit>
        <trans-unit id="4bb19e5db380a52dd063f45e3673e8d6790eab39" translate="yes" xml:space="preserve">
          <source>The complex base e exponential of &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 복소수 e 지수</target>
        </trans-unit>
        <trans-unit id="473d434a9b1e1fa3c3fa95983b0cf370022ebc41" translate="yes" xml:space="preserve">
          <source>The complex conjugate of &lt;code&gt;z&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;z&lt;/code&gt; 의 켤레 복소수입니다 .</target>
        </trans-unit>
        <trans-unit id="6139a83329c7e8e7601513a9054b1b269eca88d9" translate="yes" xml:space="preserve">
          <source>The complex natural logarithm of &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 복잡한 자연 로그</target>
        </trans-unit>
        <trans-unit id="0c3998eac6614ebf21d49abc1e3b482249568f18" translate="yes" xml:space="preserve">
          <source>The complex number with the given modulus and argument.</source>
          <target state="translated">주어진 계수와 인수가있는 복소수입니다.</target>
        </trans-unit>
        <trans-unit id="ffd55f19d01437a4948ba1ff58d0011690958c82" translate="yes" xml:space="preserve">
          <source>The concepts of &lt;a href=&quot;#Canonical%20equivalent&quot;&gt;canonical equivalent&lt;/a&gt; or &lt;a href=&quot;#Compatibility%20equivalent&quot;&gt;compatibility equivalent&lt;/a&gt; characters in the Unicode Standard make it necessary to have a full, formal definition of equivalence for Unicode strings. String equivalence is determined by a process called normalization, whereby strings are converted into forms which are compared directly for identity. This is the primary goal of the normalization process, see the function &lt;a href=&quot;#normalize&quot;&gt;&lt;code&gt;normalize&lt;/code&gt;&lt;/a&gt; to convert into any of the four defined forms.</source>
          <target state="translated">유니 코드 표준에서 &lt;a href=&quot;#Canonical%20equivalent&quot;&gt;정식 등가&lt;/a&gt; 또는 &lt;a href=&quot;#Compatibility%20equivalent&quot;&gt;호환성 등가&lt;/a&gt; 문자 의 개념은 유니 코드 문자열에 대한 등가의 완전하고 공식적인 정의가 필요합니다. 문자열 동등성은 정규화라고하는 프로세스에 의해 결정되며, 이로 인해 문자열은 식별을 위해 직접 비교되는 형식으로 변환됩니다. 이것이 정규화 프로세스의 주요 목표입니다. 함수가 &lt;a href=&quot;#normalize&quot;&gt; &lt;code&gt;normalize&lt;/code&gt; &lt;/a&gt; 네 가지 형식 중 하나로 변환을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2abedb352be4b4cad8d77bc09501301df20a32a4" translate="yes" xml:space="preserve">
          <source>The condition is satisfied if</source>
          <target state="translated">조건이 충족되면</target>
        </trans-unit>
        <trans-unit id="2f916d19cc4604e724f8fa53e2900b77b6ea76e6" translate="yes" xml:space="preserve">
          <source>The condition is satisfied if &lt;code&gt;Type&lt;/code&gt; is semantically correct (it must be syntactically correct regardless).</source>
          <target state="translated">&lt;code&gt;Type&lt;/code&gt; 이 의미 적으로 올바른 경우 조건이 충족됩니다 (구문 적으로 구문에 상관없이).</target>
        </trans-unit>
        <trans-unit id="e653b278fd905a7f3ea022f157c287cd4a9f01c9" translate="yes" xml:space="preserve">
          <source>The condition module provides a primitive for synchronized condition checking.</source>
          <target state="translated">조건 모듈은 동기화 된 조건 확인을위한 기본 요소를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="6ccd24f12a395f85abd20793c28ab1014d198ff2" translate="yes" xml:space="preserve">
          <source>The condition must be &lt;code&gt;true&lt;/code&gt; for the data to be logged.</source>
          <target state="translated">데이터가 기록 되려면 조건이 &lt;code&gt;true&lt;/code&gt; 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="7f67746204d06208bb04d7be048bff0edfd1312d" translate="yes" xml:space="preserve">
          <source>The conditions for the two-range case are as follows:</source>
          <target state="translated">두 가지 범위의 조건은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9db8141e8da442e0a29cf9a7252671c3c3646d9b" translate="yes" xml:space="preserve">
          <source>The config module contains utility routines and configuration information specific to this package.</source>
          <target state="translated">구성 모듈에는이 패키지와 관련된 유틸리티 루틴 및 구성 정보가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="25247015a813aa1799daef3d9f06262e98658698" translate="yes" xml:space="preserve">
          <source>The connection to use e.g. HTTP or FTP.</source>
          <target state="translated">HTTP 또는 FTP와 같은 연결.</target>
        </trans-unit>
        <trans-unit id="150a6335aad7ff29ac857e269ddb2bcb66d82956" translate="yes" xml:space="preserve">
          <source>The constructed &lt;code&gt;to&lt;/code&gt;</source>
          <target state="translated">구축 된 &lt;code&gt;to&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="76163a15ff5da4a6811b7d818ac307640ccf574e" translate="yes" xml:space="preserve">
          <source>The constructor does not initialize the attributes. To initialize the attributes, you access the &lt;b&gt;attr&lt;/b&gt; member variable.</source>
          <target state="translated">생성자는 속성을 초기화하지 않습니다. 속성을 초기화하려면 &lt;b&gt;attr&lt;/b&gt; 멤버 변수에 액세스하십시오 .</target>
        </trans-unit>
        <trans-unit id="bca7fb1c9668c6b5381caf14aec377df51a6a261" translate="yes" xml:space="preserve">
          <source>The constructor leaves the digest in an initialized state, so that this method only needs to be called if an unfinished digest is to be reused.</source>
          <target state="translated">생성자는 다이제스트를 초기화 된 상태로 유지하므로 완료되지 않은 다이제스트를 다시 사용해야하는 경우에만이 메소드를 호출하면됩니다.</target>
        </trans-unit>
        <trans-unit id="70a470b379ed3334099897b9dc79f34ba48d24b6" translate="yes" xml:space="preserve">
          <source>The content length in bytes of the ftp data.</source>
          <target state="translated">ftp 데이터의 컨텐츠 길이 (바이트)입니다.</target>
        </trans-unit>
        <trans-unit id="d2356d15b14610202018dcbb7e4c8229b54b1b8a" translate="yes" xml:space="preserve">
          <source>The content length in bytes when using request that has content e.g. POST/PUT and not using chunked transfer. Is set as the &quot;Content-Length&quot; header. Set to ulong.max to reset to chunked transfer.</source>
          <target state="translated">POST / PUT과 같이 콘텐츠가 있고 청크 전송을 사용하지 않는 요청을 사용할 때 콘텐츠 길이 (바이트)입니다. &quot;Content-Length&quot;헤더로 설정됩니다. 청크 전송으로 재설정하려면 ulong.max로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="c5718211c764df7e99cb685b897ebad52a7de67a" translate="yes" xml:space="preserve">
          <source>The content of &lt;code&gt;buffer&lt;/code&gt; is reused across calls. In the example above, &lt;code&gt;buffer.length&lt;/code&gt; is 4096 for all iterations, except for the last one, in which case &lt;code&gt;buffer.length&lt;/code&gt; may be less than 4096 (but always greater than zero).  In case of an I/O error, an &lt;code&gt;StdioException&lt;/code&gt; is thrown.</source>
          <target state="translated">&lt;code&gt;buffer&lt;/code&gt; 의 내용은 모든 호출에서 재사용됩니다. 위의 예에서 &lt;code&gt;buffer.length&lt;/code&gt; 는 마지막 반복을 제외하고 모든 반복에 대해 4096입니다.이 경우 &lt;code&gt;buffer.length&lt;/code&gt; 는 4096보다 작을 수 있지만 항상 0보다 큽니다. I / O 오류 가 발생 하면 &lt;code&gt;StdioException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2138553c63d001080b141495fda74a55a8794df5" translate="yes" xml:space="preserve">
          <source>The content of an environment variable</source>
          <target state="translated">환경 변수의 내용</target>
        </trans-unit>
        <trans-unit id="1b303287508120b2a69f862e57e4ac40cec3a22f" translate="yes" xml:space="preserve">
          <source>The content of the extra data field for this member. See &lt;a href=&quot;https://pkware.cachefly.net/webdocs/casestudies/APPNOTE.TXT&quot;&gt; original documentation&lt;/a&gt; for a description of the general format of this data. May contain undocumented 3rd-party data.</source>
          <target state="translated">이 멤버에 대한 추가 데이터 필드의 내용입니다. 이 데이터의 일반 형식에 대한 설명은 &lt;a href=&quot;https://pkware.cachefly.net/webdocs/casestudies/APPNOTE.TXT&quot;&gt;원본 문서&lt;/a&gt; 를 참조하십시오 . 문서화되지 않은 타사 데이터가 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e9be2c8175e2abe02a707a8002878697ac86dfd" translate="yes" xml:space="preserve">
          <source>The contents of strings and comments are not tokenized. Consequently, comment openings occurring within a string do not begin a comment, and string delimiters within a comment do not affect the recognition of comment closings and nested &lt;code&gt;/+&lt;/code&gt; comment openings. With the exception of &lt;code&gt;/+&lt;/code&gt; occurring within a &lt;code&gt;/+&lt;/code&gt; comment, comment openings within a comment are ignored.</source>
          <target state="translated">문자열과 주석의 내용은 토큰 화되지 않습니다. 결과적으로 문자열 내에서 발생하는 주석 열기는 주석을 시작하지 않으며 주석 내의 문자열 분리 문자는 주석 닫기 및 중첩 된 &lt;code&gt;/+&lt;/code&gt; 주석 열기 의 인식에 영향을 미치지 않습니다 . &lt;code&gt;/+&lt;/code&gt; 주석 내에서 발생하는 &lt;code&gt;/+&lt;/code&gt; 를 제외 하고 주석 내 주석 열기는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="acc47ba92e60a8eb6a7f0995cfd09e1266cb2c0b" translate="yes" xml:space="preserve">
          <source>The convenient digest template allows for quick hashing of any data.</source>
          <target state="translated">편리한 다이제스트 템플릿을 사용하면 모든 데이터를 빠르게 해싱 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9df1871b1d5b6cf09ccc48d6467fcecce1d269f6" translate="yes" xml:space="preserve">
          <source>The converted associative array initializer or ErrorExp if &lt;code&gt;ai&lt;/code&gt; is not an associative array initializer.</source>
          <target state="translated">변환 된 연관 배열 이니셜 라이저 또는 &lt;code&gt;ai&lt;/code&gt; 가 연관 배열 이니셜 라이저가 아닌 경우 ErrorExp</target>
        </trans-unit>
        <trans-unit id="f43effea59b8beccdd892ba167ecb555ed8c79da" translate="yes" xml:space="preserve">
          <source>The copy constructor can be overloaded with different qualifiers applied to the parameter (copying from a qualified source) or to the copy constructor itself (copying to a qualified destination):</source>
          <target state="translated">복사 생성자는 매개 변수 (적격 한 소스에서 복사) 또는 복사 생성자 자체 (적격 대상으로 복사)에 적용된 다른 규정 자로 과부하 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="190d6795cdd5f40388f14ac3afa87aeffbee0f68" translate="yes" xml:space="preserve">
          <source>The copy constructor is type checked as a normal constructor.</source>
          <target state="translated">복사 생성자는 일반 생성자로 유형 검사됩니다.</target>
        </trans-unit>
        <trans-unit id="8ce4fd58f0ef3f442e38a96e86e12b71ac036747" translate="yes" xml:space="preserve">
          <source>The corresponding argument is formatted in a manner consistent with its type:</source>
          <target state="translated">해당 인수는 형식과 일치하는 방식으로 형식이 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="48e51bdf1a95a79ac6426f7eff677cbb11ecae43" translate="yes" xml:space="preserve">
          <source>The corresponding argument must be a character type.</source>
          <target state="translated">해당 인수는 문자 유형이어야합니다.</target>
        </trans-unit>
        <trans-unit id="0274ce33cba3929bfbdf7475c2fd6fc9d51d564e" translate="yes" xml:space="preserve">
          <source>The corresponding argument must be an integral type and is formatted as an integer. If the argument is a signed type and the</source>
          <target state="translated">해당 인수는 정수 유형이어야하며 정수 형식입니다. 인수가 부호있는 유형이고</target>
        </trans-unit>
        <trans-unit id="0178a031a9f0514977acc39575ef4aaa0e2662a0" translate="yes" xml:space="preserve">
          <source>The corresponding lowercase letter, if &lt;code&gt;c&lt;/code&gt; is an uppercase ASCII character, otherwise &lt;code&gt;c&lt;/code&gt; itself.</source>
          <target state="translated">&lt;code&gt;c&lt;/code&gt; 가 대문자 ASCII 문자 이면 해당 소문자 , 그렇지 않으면 &lt;code&gt;c&lt;/code&gt; 자체</target>
        </trans-unit>
        <trans-unit id="69cee4c45eeccc903fcf47055f5f19036cae6663" translate="yes" xml:space="preserve">
          <source>The corresponding unsigned numeric type for &lt;code&gt;T&lt;/code&gt; with the same type qualifiers.  If &lt;code&gt;T&lt;/code&gt; is not a integral or vector, a compile-time error is given.</source>
          <target state="translated">형식 한정자가 동일한 &lt;code&gt;T&lt;/code&gt; 에 해당하는 부호없는 숫자 형식입니다 . &lt;code&gt;T&lt;/code&gt; 가 정수 또는 벡터가 아닌 경우 컴파일 타임 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="65ac2725a8076a2b686ff66848f84c573dbad022" translate="yes" xml:space="preserve">
          <source>The corresponding uppercase letter, if &lt;code&gt;c&lt;/code&gt; is a lowercase ASCII character, otherwise &lt;code&gt;c&lt;/code&gt; itself.</source>
          <target state="translated">&lt;code&gt;c&lt;/code&gt; 가 소문자 ASCII 문자 이면 해당 대문자 , 그렇지 않으면 &lt;code&gt;c&lt;/code&gt; 자체</target>
        </trans-unit>
        <trans-unit id="c9ce88bd48ff277e4bfb8bb20fde5641ab64da29" translate="yes" xml:space="preserve">
          <source>The coverage callback.</source>
          <target state="translated">적용 범위 콜백</target>
        </trans-unit>
        <trans-unit id="fe4e5d3b2725d57149f74ea4401dddd72e356025" translate="yes" xml:space="preserve">
          <source>The created GC instance or &lt;code&gt;null&lt;/code&gt; if no factory for that name was registered</source>
          <target state="translated">생성 된 GC 인스턴스 또는 &lt;code&gt;null&lt;/code&gt; 해당 이름의 팩토리가 등록되지 않은 경우</target>
        </trans-unit>
        <trans-unit id="25c75bcefa05f1c507f7f1fc6ff9cd42539bbd75" translate="yes" xml:space="preserve">
          <source>The curl_easy_pause function pauses or unpauses transfers. Select the new state by setting the bitmask, use the convenience defines below.</source>
          <target state="translated">curl_easy_pause 함수는 전송을 일시 정지 또는 일시 정지 해제합니다. 비트 마스크를 설정하여 새 상태를 선택하고 아래 정의 된 편의를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="153bfd2d6b2d30ac140c40feedadba5366f389ef" translate="yes" xml:space="preserve">
          <source>The curl_easy_strerror function may be used to turn a CURLcode value into the equivalent human readable error string. This is useful for printing meaningful error messages.</source>
          <target state="translated">curl_easy_strerror 함수는 CURLcode 값을 사람이 읽을 수있는 동등한 오류 문자열로 변환하는 데 사용될 수 있습니다. 의미있는 오류 메시지를 인쇄 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="e7d8cb9ade20ed61c82c1a60ebe359477845f192" translate="yes" xml:space="preserve">
          <source>The curl_multi_strerror function may be used to turn a CURLMcode value into the equivalent human readable error string. This is useful for printing meaningful error messages.</source>
          <target state="translated">curl_multi_strerror 함수는 CURLMcode 값을 사람이 읽을 수있는 동등한 오류 문자열로 변환하는 데 사용될 수 있습니다. 의미있는 오류 메시지를 인쇄 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="8ac8c7edec906e82e20cff95e57160d4c2ae8742" translate="yes" xml:space="preserve">
          <source>The curl_share_strerror function may be used to turn a CURLSHcode value into the equivalent human readable error string. This is useful for printing meaningful error messages.</source>
          <target state="translated">curl_share_strerror 함수는 CURLSHcode 값을 사람이 읽을 수있는 동등한 오류 문자열로 변환하는 데 사용될 수 있습니다. 의미있는 오류 메시지를 인쇄 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="12b95a210f2fd732ae6323a477ee3db950ce1e48" translate="yes" xml:space="preserve">
          <source>The current capacity of this &lt;code&gt;SocketSet&lt;/code&gt;. The exact meaning of the return value varies from platform to platform.</source>
          <target state="translated">이 &lt;code&gt;SocketSet&lt;/code&gt; 의 현재 용량 . 반환 값의 정확한 의미는 플랫폼마다 다릅니다.</target>
        </trans-unit>
        <trans-unit id="b7e8d20bcf3e91b443f49906cb7f9c26202d7b33" translate="yes" xml:space="preserve">
          <source>The current chunk of encoded data.</source>
          <target state="translated">인코딩 된 데이터의 현재 청크</target>
        </trans-unit>
        <trans-unit id="5f09ff18e0bf3e3a50451c990acfd44da2f4d0cf" translate="yes" xml:space="preserve">
          <source>The current collect handler or null if none has been set.</source>
          <target state="translated">현재의 수집 핸들러. 설정되어 있지 않은 경우는 null</target>
        </trans-unit>
        <trans-unit id="ff00e2ec15ad157fa0acd49db009126af4219c9c" translate="yes" xml:space="preserve">
          <source>The current day of the week.</source>
          <target state="translated">요일.</target>
        </trans-unit>
        <trans-unit id="5445bb4bc1730b9d0cce5b36844644b773e9edcb" translate="yes" xml:space="preserve">
          <source>The current decoded byte.</source>
          <target state="translated">현재 디코딩 된 바이트입니다.</target>
        </trans-unit>
        <trans-unit id="d4f2882db12d78c2fc4e970047ad93065891fe53" translate="yes" xml:space="preserve">
          <source>The current directory for the parent process.</source>
          <target state="translated">상위 프로세스의 현재 디렉토리</target>
        </trans-unit>
        <trans-unit id="62615ccff9de65abffb1ae1e70b58ec0562e8494" translate="yes" xml:space="preserve">
          <source>The current encoded character.</source>
          <target state="translated">현재 인코딩 된 문자입니다.</target>
        </trans-unit>
        <trans-unit id="2bcc037a390d8689344ebfd625c83c159bbdaa3a" translate="yes" xml:space="preserve">
          <source>The current implementation is contained in and defined by &lt;a href=&quot;https://github.com/dlang/druntime/blob/master/src/rt/aaA.d&quot;&gt;rt/aaA.d&lt;/a&gt;.</source>
          <target state="translated">현재 구현은 &lt;a href=&quot;https://github.com/dlang/druntime/blob/master/src/rt/aaA.d&quot;&gt;rt / aaA.d&lt;/a&gt; 에 포함되어 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="135564ffafda532e35fa0b7d48812ffee033cd42" translate="yes" xml:space="preserve">
          <source>The current implementation is optimized for little endian architectures. It will exhibit different results on big endian architectures and a slightly less uniform distribution.</source>
          <target state="translated">현재 구현은 리틀 엔디안 아키텍처에 최적화되어 있습니다. 빅 엔디안 아키텍처와 약간 덜 균일 한 분포에서 다른 결과를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="5d6f2623d60fb655268313ce604e66563648e710" translate="yes" xml:space="preserve">
          <source>The current implementation makes use of the zlib compression library.</source>
          <target state="translated">현재 구현은 zlib 압축 라이브러리를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="225274ac2b2419e7addd684159bba23d3f813f5d" translate="yes" xml:space="preserve">
          <source>The current implementation mostly conforms to &lt;a href=&quot;https://www.iso.org/standard/60101.html&quot;&gt;ISO/IEC 21320-1:2015&lt;/a&gt;, which means,</source>
          <target state="translated">현재 구현은 대부분 &lt;a href=&quot;https://www.iso.org/standard/60101.html&quot;&gt;ISO / IEC 21320-1 : 2015를&lt;/a&gt; 준수합니다 . 즉,</target>
        </trans-unit>
        <trans-unit id="8b386bdee0746666a56a36200a693020a21530e4" translate="yes" xml:space="preserve">
          <source>The current legacy module unit tester handler or null if none has been set.</source>
          <target state="translated">현재 레거시 모듈 단위 테스터 핸들러 또는 설정되지 않은 경우 null입니다.</target>
        </trans-unit>
        <trans-unit id="8ef65e94b9168b0ff7203f6b263d0e8b2bd6eeac" translate="yes" xml:space="preserve">
          <source>The current module unit tester handler or null if none has been set.</source>
          <target state="translated">현재의 모듈 유닛 테스터 핸들러. 설정되어 있지 않은 경우는 null</target>
        </trans-unit>
        <trans-unit id="6f8938955ef3df10335744a73b91094b9fffec70" translate="yes" xml:space="preserve">
          <source>The current month of the year.</source>
          <target state="translated">올해의 현재 달.</target>
        </trans-unit>
        <trans-unit id="67943f85151903b71f2ef45fecfce18f374500bf" translate="yes" xml:space="preserve">
          <source>The current system tick. The number of ticks per second varies from system to system. &lt;code&gt;currSystemTick&lt;/code&gt; uses a monotonic clock, so it's intended for precision timing by comparing relative time values, not for getting the current system time.</source>
          <target state="translated">현재 시스템 틱. 초당 틱 수는 시스템마다 다릅니다. &lt;code&gt;currSystemTick&lt;/code&gt; 은 모노 토닉 클록을 사용하므로 현재 시스템 시간을 얻는 것이 아니라 상대 시간 값을 비교하여 정밀한 타이밍을 위해 고안되었습니다.</target>
        </trans-unit>
        <trans-unit id="222a86bbae85929301dc215f9e9c008965d24955" translate="yes" xml:space="preserve">
          <source>The current time of the system's monotonic clock. This has no relation to the wall clock time, as the wall clock time can be adjusted (e.g. by NTP), whereas the monotonic clock always moves forward. The source of the monotonic time is system-specific.</source>
          <target state="translated">시스템의 단조로운 시계의 현재 시간입니다. 벽시계 시간은 (예를 들어 NTP에 의해) 조정될 수있는 반면, 단조로운 시계는 항상 앞으로 이동하기 때문에 이것은 벽시계 시간과 관련이 없다. 단조로운 시간의 근원은 시스템에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="6d131b2d67d2e2d0708dd4d35e46ff7bb470d695" translate="yes" xml:space="preserve">
          <source>The current time zone of this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;. It's internal time is always kept in UTC, so there are no conversion issues between time zones due to DST. Functions which return all or part of the time - such as hours - adjust the time to this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;'s time zone before returning.</source>
          <target state="translated">이것의 현재 시간대 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; . 내부 시간은 항상 UTC로 유지되므로 DST로 인해 시간대간에 변환 문제가 없습니다. 시간과 같이 시간의 일부 또는 전부를 반환하는 함수는 반환하기 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; 표준 시간대로 시간을 조정합니다 .</target>
        </trans-unit>
        <trans-unit id="92e4138ca0558ee1a8d76b41157b476bc178803c" translate="yes" xml:space="preserve">
          <source>The current time zone of this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;. Its internal time is always kept in UTC, so there are no conversion issues between time zones due to DST. Functions which return all or part of the time - such as hours - adjust the time to this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;'s time zone before returning.</source>
          <target state="translated">이것의 현재 시간대 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; . 내부 시간은 항상 UTC로 유지되므로 DST로 인해 시간대간에 변환 문제가 없습니다. 시간과 같이 시간의 일부 또는 전부를 반환하는 함수는 반환하기 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; 표준 시간대로 시간을 조정합니다 .</target>
        </trans-unit>
        <trans-unit id="73b94772e416a8ec2451e84a4f045bcf0b0bd2f8" translate="yes" xml:space="preserve">
          <source>The current trace handler or null if none has been set.</source>
          <target state="translated">현재의 트레이스 핸들러. 설정되어 있지 않은 경우는 null</target>
        </trans-unit>
        <trans-unit id="1168fa07ec5310179d0a7d8dd293fdee5d851995" translate="yes" xml:space="preserve">
          <source>The current version is MurmurHash3, which yields a 32-bit or 128-bit hash value. The older MurmurHash 1 and 2 are currently not supported.</source>
          <target state="translated">현재 버전은 MurmurHash3이며 32 비트 또는 128 비트 해시 값을 생성합니다. 이전 MurmurHash 1 및 2는 현재 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f46d4edbe0670620eb95290f8f2a6487face97bc" translate="yes" xml:space="preserve">
          <source>The data caches. If there are fewer than 5 physical caches levels, the remaining levels are set to size_t.max (== entire memory space)</source>
          <target state="translated">데이터 캐시 실제 캐시 레벨이 5 미만인 경우 나머지 레벨은 size_t.max (== 전체 메모리 공간)로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="a6ef57ac8d9ec9aa6eaa6d13ed88211ab558ef56" translate="yes" xml:space="preserve">
          <source>The data is NOT copied by the library. Content-Type will default to application/octet-stream. Data is not converted or encoded by this method.</source>
          <target state="translated">라이브러리는 데이터를 복사하지 않습니다. Content-Type은 기본적으로 application / octet-stream이됩니다. 이 방법으로 데이터를 변환하거나 인코딩하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6bcbd37c2c2ac85eb1356e64319455a6bd36b26b" translate="yes" xml:space="preserve">
          <source>The data is NOT copied by the library. Content-Type will default to text/plain. Data is not converted or encoded by this method.</source>
          <target state="translated">라이브러리는 데이터를 복사하지 않습니다. Content-Type은 기본적으로 text / plain으로 설정됩니다. 이 방법으로 데이터를 변환하거나 인코딩하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cce9ef674e018900e5c73c744a07e56499cc18a7" translate="yes" xml:space="preserve">
          <source>The data is always shareable across threads. Even if the data is &lt;code&gt;const&lt;/code&gt;, the affix is modifiable by the same reasoning as for &lt;code&gt;immutable&lt;/code&gt;.</source>
          <target state="translated">데이터는 항상 스레드간에 공유 할 수 있습니다. 데이터가 &lt;code&gt;const&lt;/code&gt; 인 경우에도 &lt;code&gt;immutable&lt;/code&gt; 경우와 동일한 추론으로 접미사를 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="493973138a3d3f979064d5411c98ae5301a703dd" translate="yes" xml:space="preserve">
          <source>The data that is to be logged.</source>
          <target state="translated">기록 될 데이터.</target>
        </trans-unit>
        <trans-unit id="ca2344350b8df2bdd7d03df57b987d64c46b085c" translate="yes" xml:space="preserve">
          <source>The data that should be logged.</source>
          <target state="translated">기록해야 할 데이터.</target>
        </trans-unit>
        <trans-unit id="78b3f17895b8c6a1ec55d26a5815c6b3e2f691ad" translate="yes" xml:space="preserve">
          <source>The database disk image is malformed</source>
          <target state="translated">데이터베이스 디스크 이미지가 잘못되었습니다</target>
        </trans-unit>
        <trans-unit id="99b3c2c49461425bf6cff4391127f75d483d0614" translate="yes" xml:space="preserve">
          <source>The database file is locked</source>
          <target state="translated">데이터베이스 파일이 잠겨 있습니다</target>
        </trans-unit>
        <trans-unit id="5e44b1ae3d4ce260d0b6e54dfe79b9e83c8a047e" translate="yes" xml:space="preserve">
          <source>The database schema changed</source>
          <target state="translated">데이터베이스 스키마가 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="8c85f90f34182d4804f085ae127ba5dcaa363aac" translate="yes" xml:space="preserve">
          <source>The date portion of &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 의 날짜 부분입니다 .</target>
        </trans-unit>
        <trans-unit id="afe331c3b8358f5c9f6aa03d6d996e549edd7dd9" translate="yes" xml:space="preserve">
          <source>The day of the Gregorian Calendar to set this &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; to.</source>
          <target state="translated">이 &lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 를 설정할 그레고리력 일입니다 .</target>
        </trans-unit>
        <trans-unit id="4ae0c452a064fb3ca47b7a7c9701724ac4dce1ca" translate="yes" xml:space="preserve">
          <source>The day of the Gregorian Calendar to set this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; to.</source>
          <target state="translated">이 &lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 을 설정할 그레고리력의 요일입니다 .</target>
        </trans-unit>
        <trans-unit id="bd19a7c8e8386d921c721461757d18c3618278c9" translate="yes" xml:space="preserve">
          <source>The day of the Gregorian Calendar to set this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; to.</source>
          <target state="translated">이 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; 을 설정하는 그레고리력 일입니다 .</target>
        </trans-unit>
        <trans-unit id="0b0bd119a12bf4f397ebf472b36184d281c6821c" translate="yes" xml:space="preserve">
          <source>The day of the month to set this &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt;'s day to.</source>
          <target state="translated">이 &lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 를 설정할 날짜 입니다.</target>
        </trans-unit>
        <trans-unit id="5240ff1dc8c3d7350efab2ccc0dcbc8c48902add" translate="yes" xml:space="preserve">
          <source>The day of the month to set this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;'s day to.</source>
          <target state="translated">이 &lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 의 요일을 설정하는 달 입니다.</target>
        </trans-unit>
        <trans-unit id="54dc94925cf86835f631cdafa18de7d7060f146b" translate="yes" xml:space="preserve">
          <source>The day of the month to set this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;'s day to.</source>
          <target state="translated">이 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; 의 요일을 설정할 요일입니다.</target>
        </trans-unit>
        <trans-unit id="f06065ad9961deec3076217123d1f3724a43ad9e" translate="yes" xml:space="preserve">
          <source>The day of the week is ignored beyond verifying that it's a valid day of the week, as the day of the week can be inferred from the date. It is not checked whether the given day of the week matches the actual day of the week of the given date (though it is technically invalid per the spec if the day of the week doesn't match the actual day of the week of the given date).</source>
          <target state="translated">요일은 날짜로부터 유추 될 수 있으므로 유효한 요일임을 확인하는 것 외에는 무시됩니다. 주어진 요일이 주어진 날짜의 실제 요일과 일치하는지 여부는 확인되지 않습니다 (요일이 주어진 요일과 일치하지 않으면 스펙에 따라 기술적으로 유효하지 않습니다). 데이트).</target>
        </trans-unit>
        <trans-unit id="5e854e19e24462bd8df16bbd3e656946dc758006" translate="yes" xml:space="preserve">
          <source>The day of the week to get the number of days to.</source>
          <target state="translated">일 수를 얻는 요일입니다.</target>
        </trans-unit>
        <trans-unit id="9b2b14b5c754fd8843dde38b4959242869b20add" translate="yes" xml:space="preserve">
          <source>The day of the year to set which day of the year this &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; is on.</source>
          <target state="translated">이 &lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 가있는 날짜 를 설정하기위한 날짜 입니다.</target>
        </trans-unit>
        <trans-unit id="ccf6b0017db205f1a9b8b83cdf38246cf64f3b0f" translate="yes" xml:space="preserve">
          <source>The day of the year to set which day of the year this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; is on.</source>
          <target state="translated">이 &lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 이 켜져 있는 날짜를 설정하는 날짜입니다 .</target>
        </trans-unit>
        <trans-unit id="8dcb327ec830e9013bbcabf4579c3b122dd13db5" translate="yes" xml:space="preserve">
          <source>The day of the year to set which day of the year this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; is on.</source>
          <target state="translated">이 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; 이 작동 하는 날짜를 설정하는 날짜입니다 .</target>
        </trans-unit>
        <trans-unit id="1ca7f565ccafa6d910e84ff93887a8b0d0bb5eea" translate="yes" xml:space="preserve">
          <source>The day portion of the date.</source>
          <target state="translated">날짜의 일 부분.</target>
        </trans-unit>
        <trans-unit id="5ad71e8507c7301863c1c60659bd8b3c6b7f0dc6" translate="yes" xml:space="preserve">
          <source>The day to validate.</source>
          <target state="translated">검증 할 요일입니다.</target>
        </trans-unit>
        <trans-unit id="99ff0048fa491b367eccc6b67cb9b69f2ad2defa" translate="yes" xml:space="preserve">
          <source>The decimal value to convert into the factorial number system.</source>
          <target state="translated">계승 시스템으로 변환 할 10 진수 값입니다.</target>
        </trans-unit>
        <trans-unit id="112d499aea5e8fc601570782799d1151e557b4de" translate="yes" xml:space="preserve">
          <source>The declarations in a mixin are placed in a nested scope and then &amp;lsquo;imported&amp;rsquo; into the surrounding scope. If the name of a declaration in a mixin is the same as a declaration in the surrounding scope, the surrounding declaration overrides the mixin one:</source>
          <target state="translated">믹스 인의 선언은 중첩 범위에 배치 된 다음 주변 범위로 '가져 오기'됩니다. 믹스 인의 선언 이름이 주변 범위의 선언과 동일하면 주변 선언이 믹스 인을 재정의합니다.</target>
        </trans-unit>
        <trans-unit id="1c2cdcf3cf79afdc906fde394e5c2b865521f41b" translate="yes" xml:space="preserve">
          <source>The decoded string</source>
          <target state="translated">디코딩 된 문자열</target>
        </trans-unit>
        <trans-unit id="945488b25e8ef473c0f2b20f9c6b8b8c99511eb5" translate="yes" xml:space="preserve">
          <source>The decoding of the current element in the input.</source>
          <target state="translated">입력에서 현재 요소의 디코딩</target>
        </trans-unit>
        <trans-unit id="4f67de430c432c552831b7793db0a2c0326b2d16" translate="yes" xml:space="preserve">
          <source>The deduced type parameter for dynamic array and pointer arguments has an unqualified head:</source>
          <target state="translated">동적 배열 및 포인터 인수에 대한 추론 된 유형 매개 변수에는 규정되지 않은 헤드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc7258b7cd7137907e6fca7bf0fc234fc2e2ce18" translate="yes" xml:space="preserve">
          <source>The default &quot;User-Agent&quot; value send with a request. It has the form &quot;Phobos-std.net.curl/</source>
          <target state="translated">기본 &quot;User-Agent&quot;값은 요청과 함께 보냅니다. &quot;Phobos-std.net.curl / 형식입니다.</target>
        </trans-unit>
        <trans-unit id="c3a368bff4f38586882207610a2dc73a031ba862" translate="yes" xml:space="preserve">
          <source>The default (or most common) setting for the current platform. That is, &lt;code&gt;no&lt;/code&gt; on Windows and Mac OS X, and &lt;code&gt;yes&lt;/code&gt; on all POSIX systems except Darwin (Linux, *BSD, etc.).</source>
          <target state="translated">현재 플랫폼에 대한 기본 (또는 가장 일반적인) 설정입니다. 즉, Windows 및 Mac OS X 에서는 &lt;code&gt;no&lt;/code&gt; , Darwin (Linux, * BSD 등)을 제외한 모든 POSIX 시스템에서는 &lt;code&gt;yes&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7a46984a3f96d58aec5d4d9868c2110f34d995ba" translate="yes" xml:space="preserve">
          <source>The default (or most common) setting for the current platform. That is, &lt;code&gt;no&lt;/code&gt; on Windows and Mac OS X, and &lt;code&gt;yes&lt;/code&gt; on all POSIX systems except OS X (Linux, *BSD, etc.).</source>
          <target state="translated">현재 플랫폼의 기본 (또는 가장 일반적인) 설정입니다. 즉,하지 &lt;code&gt;no&lt;/code&gt; Windows 및 Mac OS X, 그리고에 &lt;code&gt;yes&lt;/code&gt; OS X (리눅스, * BSD 등)를 제외한 모든 POSIX 시스템에서.</target>
        </trans-unit>
        <trans-unit id="87b0a2695d56ceaeb7eb9433e1d06841db861c10" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;Logger&lt;/code&gt; will by default log to &lt;code&gt;stderr&lt;/code&gt; and has a default &lt;code&gt;LogLevel&lt;/code&gt; of &lt;code&gt;LogLevel.all&lt;/code&gt;. The default Logger can be accessed by using the property called &lt;code&gt;sharedLog&lt;/code&gt;. This property is a reference to the current default &lt;code&gt;Logger&lt;/code&gt;. This reference can be used to assign a new default &lt;code&gt;Logger&lt;/code&gt;.</source>
          <target state="translated">기본 &lt;code&gt;Logger&lt;/code&gt; 는 기본적으로 &lt;code&gt;stderr&lt;/code&gt; 에 로그 하며 기본 &lt;code&gt;LogLevel&lt;/code&gt; 은 &lt;code&gt;LogLevel.all&lt;/code&gt; 입니다. &lt;code&gt;sharedLog&lt;/code&gt; 라는 속성을 사용하여 기본 로거에 액세스 할 수 있습니다 . 이 속성은 현재 기본 &lt;code&gt;Logger&lt;/code&gt; 대한 참조 입니다. 이 참조는 새로운 기본 &lt;code&gt;Logger&lt;/code&gt; 를 할당하는 데 사용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b72f9c3623b76d776ddcc9d314e5ca75b551f9a9" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;alignedReallocate&lt;/code&gt; function first attempts to use &lt;code&gt;expand&lt;/code&gt;. If &lt;code&gt;Allocator.expand&lt;/code&gt; is not defined or returns &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;alignedReallocate&lt;/code&gt; allocates a new block of memory of appropriate size and copies data from the old block to the new block. Finally, if &lt;code&gt;Allocator&lt;/code&gt; defines &lt;code&gt;deallocate&lt;/code&gt;, &lt;code&gt;alignedReallocate&lt;/code&gt; uses it to free the old memory block.</source>
          <target state="translated">기본 &lt;code&gt;alignedReallocate&lt;/code&gt; 함수는 먼저 &lt;code&gt;expand&lt;/code&gt; 사용을 시도합니다 . &lt;code&gt;Allocator.expand&lt;/code&gt; 가 정의되지 않았거나 &lt;code&gt;false&lt;/code&gt; 를 반환하는 경우 , &lt;code&gt;alignedReallocate&lt;/code&gt; 할당 새로운 블록 이전 블록에서 적절한 크기 및 사본 데이터 메모리의 새로운 블록. 마지막으로 &lt;code&gt;Allocator&lt;/code&gt; 가 &lt;code&gt;deallocate&lt;/code&gt; 를 정의 하면 &lt;code&gt;alignedReallocate&lt;/code&gt; 는 할당을 사용하여 이전 메모리 블록을 해제합니다.</target>
        </trans-unit>
        <trans-unit id="11d5f052dd46a2986ac861f2bb2c8694b1113749" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;reallocate&lt;/code&gt; function first attempts to use &lt;code&gt;expand&lt;/code&gt;. If &lt;code&gt;Allocator.expand&lt;/code&gt; is not defined or returns &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;reallocate&lt;/code&gt; allocates a new block of memory of appropriate size and copies data from the old block to the new block. Finally, if &lt;code&gt;Allocator&lt;/code&gt; defines &lt;code&gt;deallocate&lt;/code&gt;, &lt;code&gt;reallocate&lt;/code&gt; uses it to free the old memory block.</source>
          <target state="translated">기본 &lt;code&gt;reallocate&lt;/code&gt; 기능은 먼저 &lt;code&gt;expand&lt;/code&gt; 사용을 시도합니다 . 경우 &lt;code&gt;Allocator.expand&lt;/code&gt; 이 정의되거나 반환되지 않은 &lt;code&gt;false&lt;/code&gt; , &lt;code&gt;reallocate&lt;/code&gt; 할당 새로운 블록 이전 블록에서 적절한 크기와 데이터를 복사 메모리의 새로운 블록. 마지막으로 &lt;code&gt;Allocator&lt;/code&gt; 가 &lt;code&gt;deallocate&lt;/code&gt; 를 정의 하면 &lt;code&gt;reallocate&lt;/code&gt; 는이를 사용하여 이전 메모리 블록을 해제합니다.</target>
        </trans-unit>
        <trans-unit id="b4b278f4d2972020f4ba9b115cb1013b58d050b9" translate="yes" xml:space="preserve">
          <source>The default alignment is &lt;code&gt;platformAlignment&lt;/code&gt;.</source>
          <target state="translated">기본 정렬은 &lt;code&gt;platformAlignment&lt;/code&gt; 입니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
