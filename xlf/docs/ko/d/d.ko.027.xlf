<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="d">
    <body>
      <group id="d">
        <trans-unit id="bfcc76451138cf6e179bded66babeafecdbfe06a" translate="yes" xml:space="preserve">
          <source>The element to stop at.</source>
          <target state="translated">멈출 요소.</target>
        </trans-unit>
        <trans-unit id="b80bff8085fdd511cb9c4d9e05da48019bf3dd74" translate="yes" xml:space="preserve">
          <source>The element type for 32-bit implementation.</source>
          <target state="translated">32 비트 구현을위한 요소 유형입니다.</target>
        </trans-unit>
        <trans-unit id="218ef2dcaf3b3057dc646bab34be48640fa2fc83" translate="yes" xml:space="preserve">
          <source>The element type for the range will be &lt;code&gt;Char[]&lt;/code&gt;. Range primitives may throw &lt;code&gt;StdioException&lt;/code&gt; on I/O error.</source>
          <target state="translated">범위의 요소 유형은 &lt;code&gt;Char[]&lt;/code&gt; 입니다. 범위 프리미티브는 I / O 오류에서 &lt;code&gt;StdioException&lt;/code&gt; 을 발생시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c8e0ad7d182f093115b2321024fb0d43eeab8ccb" translate="yes" xml:space="preserve">
          <source>The element type for the range will be &lt;code&gt;ubyte[]&lt;/code&gt;. Range primitives may throw &lt;code&gt;StdioException&lt;/code&gt; on I/O error.</source>
          <target state="translated">범위의 요소 유형은 &lt;code&gt;ubyte[]&lt;/code&gt; 입니다. 범위 프리미티브는 I / O 오류에서 &lt;code&gt;StdioException&lt;/code&gt; 을 발생시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="146f6e63904487c6bc88a456ffe5bb5d872efab2" translate="yes" xml:space="preserve">
          <source>The element type of &lt;code&gt;R&lt;/code&gt;. &lt;code&gt;R&lt;/code&gt; does not have to be a range. The element type is determined as the type yielded by &lt;code&gt;r.front&lt;/code&gt; for an object &lt;code&gt;r&lt;/code&gt; of type &lt;code&gt;R&lt;/code&gt;. For example, &lt;code&gt;ElementType!(T[])&lt;/code&gt; is &lt;code&gt;T&lt;/code&gt; if &lt;code&gt;T[]&lt;/code&gt; isn't a narrow string; if it is, the element type is &lt;code&gt;dchar&lt;/code&gt;. If &lt;code&gt;R&lt;/code&gt; doesn't have &lt;code&gt;front&lt;/code&gt;, &lt;code&gt;ElementType!R&lt;/code&gt; is &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">의 요소 타입 &lt;code&gt;R&lt;/code&gt; . &lt;code&gt;R&lt;/code&gt; 은 범위 일 필요는 없습니다. 유형에 의해 수득으로하는 요소 타입이 결정된다 &lt;code&gt;r.front&lt;/code&gt; 객체에 대한 &lt;code&gt;r&lt;/code&gt; 형의 &lt;code&gt;R&lt;/code&gt; . 예를 들어, &lt;code&gt;ElementType!(T[])&lt;/code&gt; 이고 &lt;code&gt;T&lt;/code&gt; 는 경우 &lt;code&gt;T[]&lt;/code&gt; 좁은 문자열 아니다; 있는 경우 요소 유형은 &lt;code&gt;dchar&lt;/code&gt; 입니다. 경우 &lt;code&gt;R&lt;/code&gt; 이 없는 &lt;code&gt;front&lt;/code&gt; , &lt;code&gt;ElementType!R&lt;/code&gt; 이다 &lt;code&gt;void&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="242b60e2b158a7060db8baf4f6cc26e6d87af9f3" translate="yes" xml:space="preserve">
          <source>The element's CData items</source>
          <target state="translated">요소의 CData 항목</target>
        </trans-unit>
        <trans-unit id="c3b9d2b70df47460f19754a079e90ba32c948935" translate="yes" xml:space="preserve">
          <source>The element's child elements</source>
          <target state="translated">요소의 자식 요소</target>
        </trans-unit>
        <trans-unit id="a931fa1a5c6e1ac62a1fb67480e5e8ac09b9bdb7" translate="yes" xml:space="preserve">
          <source>The element's comments</source>
          <target state="translated">요소의 의견</target>
        </trans-unit>
        <trans-unit id="a2b54c10854bacd9d44680700556c9e99d65c27d" translate="yes" xml:space="preserve">
          <source>The element's items</source>
          <target state="translated">요소의 항목</target>
        </trans-unit>
        <trans-unit id="585ede5c120291a9643e02011ada89b79cd9d6f7" translate="yes" xml:space="preserve">
          <source>The element's processing instructions</source>
          <target state="translated">요소의 처리 지침</target>
        </trans-unit>
        <trans-unit id="eb70f51eec72df5d60ca23b74395601f21da9c66" translate="yes" xml:space="preserve">
          <source>The element's text items</source>
          <target state="translated">요소의 텍스트 항목</target>
        </trans-unit>
        <trans-unit id="e5bc2ae39e4f9e29954c5367c1c69157fdd19e00" translate="yes" xml:space="preserve">
          <source>The email address to check</source>
          <target state="translated">확인할 이메일 주소</target>
        </trans-unit>
        <trans-unit id="48e5305233fe3d75b0443ee1f50818a6d648fd6c" translate="yes" xml:space="preserve">
          <source>The email status code</source>
          <target state="translated">이메일 상태 코드</target>
        </trans-unit>
        <trans-unit id="4346e3e9e5e3a95198a31c78de02c8e03150e933" translate="yes" xml:space="preserve">
          <source>The encoded string</source>
          <target state="translated">인코딩 된 문자열</target>
        </trans-unit>
        <trans-unit id="381ff9274ef41642af8e81eebffce945d9f4f6ee" translate="yes" xml:space="preserve">
          <source>The encoding element type of &lt;code&gt;R&lt;/code&gt;. For narrow strings (&lt;code&gt;char[]&lt;/code&gt;, &lt;code&gt;wchar[]&lt;/code&gt; and their qualified variants including &lt;code&gt;string&lt;/code&gt; and &lt;code&gt;wstring&lt;/code&gt;), &lt;code&gt;ElementEncodingType&lt;/code&gt; is the character type of the string. For all other types, &lt;code&gt;ElementEncodingType&lt;/code&gt; is the same as &lt;code&gt;ElementType&lt;/code&gt;.</source>
          <target state="translated">인코딩 요소 타입 &lt;code&gt;R&lt;/code&gt; . 좁은 문자열 ( &lt;code&gt;char[]&lt;/code&gt; , &lt;code&gt;wchar[]&lt;/code&gt; 및 &lt;code&gt;string&lt;/code&gt; 및 &lt;code&gt;wstring&lt;/code&gt; 을 포함한 정규화 된 변형 )의 경우 &lt;code&gt;ElementEncodingType&lt;/code&gt; 은 문자열의 문자 유형입니다. 다른 모든 유형의 경우 &lt;code&gt;ElementEncodingType&lt;/code&gt; 은 &lt;code&gt;ElementType&lt;/code&gt; 과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="8ddaa2a73311c2a472b8bde0c140d7d16072aef8" translate="yes" xml:space="preserve">
          <source>The end point of the interval. It is excluded from the interval.</source>
          <target state="translated">간격의 끝점입니다. 간격에서 제외됩니다.</target>
        </trans-unit>
        <trans-unit id="3045098b74bc924c86c93e1e08406b98332239d1" translate="yes" xml:space="preserve">
          <source>The endianness that the bytes are assumed to be in.</source>
          <target state="translated">바이트가있는 것으로 간주되는 엔디안입니다.</target>
        </trans-unit>
        <trans-unit id="d625680f2f5053e8d89e9dc8332e606f7d3ff5c0" translate="yes" xml:space="preserve">
          <source>The endianness that the program was compiled for.</source>
          <target state="translated">프로그램이 컴파일 된 엔디안.</target>
        </trans-unit>
        <trans-unit id="2c31e59fa05bc473d51ba9ff8b1fbea71679f185" translate="yes" xml:space="preserve">
          <source>The endianness to write the bytes in.</source>
          <target state="translated">바이트를 쓸 엔디안</target>
        </trans-unit>
        <trans-unit id="4b673a6e15bd55d6aa4a35d2bd69a88952502624" translate="yes" xml:space="preserve">
          <source>The entire contents of the archive.</source>
          <target state="translated">아카이브의 전체 내용.</target>
        </trans-unit>
        <trans-unit id="598292bc5270606189fdedc665ef492ceced68f0" translate="yes" xml:space="preserve">
          <source>The entire random number library architecture is derived from the excellent &lt;a href=&quot;http://open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2461.pdf&quot;&gt;C++0X&lt;/a&gt; random number facility proposed by Jens Maurer and contributed to by researchers at the Fermi laboratory (excluding Xorshift).</source>
          <target state="translated">전체 난수 라이브러리 아키텍처는 Jens Maurer가 제안한 우수한 &lt;a href=&quot;http://open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2461.pdf&quot;&gt;C ++ 0X&lt;/a&gt; 난수 기능 에서 파생되었으며 Fermi 연구소의 연구원 (Xorshift 제외)이 제공했습니다.</target>
        </trans-unit>
        <trans-unit id="694779fd846cde08f1b1e4968157c26de84e61a0" translate="yes" xml:space="preserve">
          <source>The entry point of this module is &lt;code&gt;traceHandlerOpApplyImpl&lt;/code&gt;, and the only really &quot;public&quot; symbol (since all &lt;code&gt;rt&lt;/code&gt; symbols are private). In the future, this implementation should probably be made idiomatic, so that it can for example work with attributes.</source>
          <target state="translated">이 모듈의 진입 점은 &lt;code&gt;traceHandlerOpApplyImpl&lt;/code&gt; 이며 유일한 &quot;공용&quot;기호입니다 (모든 &lt;code&gt;rt&lt;/code&gt; 기호가 개인용 이므로 ). 앞으로이 구현은 예를 들어 속성과 함께 작동 할 수 있도록 관용적으로 만들어야합니다.</target>
        </trans-unit>
        <trans-unit id="888201d962022c79856dc1d83803a781978d38cd" translate="yes" xml:space="preserve">
          <source>The equality and inequality operators are treated separately because while practically all user-defined types can be compared for equality, only a subset of types have a meaningful ordering. For example, while it makes sense to determine if two RGB color vectors are equal, it is not meaningful to say that one color is greater than another, because colors do not have an ordering. Thus, one would define &lt;code&gt;opEquals&lt;/code&gt; for a &lt;code&gt;Color&lt;/code&gt; type, but not &lt;code&gt;opCmp&lt;/code&gt;.</source>
          <target state="translated">동등성 및 부등식 연산자는 실질적으로 모든 사용자 정의 형식을 동일하게 비교할 수 있지만 형식의 하위 집합 만 의미있는 순서를 갖기 때문에 개별적으로 처리됩니다. 예를 들어, 두 RGB 색상 벡터가 같은지 확인하는 것이 합리적이지만 색상에는 순서가 없기 때문에 한 색상이 다른 색상보다 크다고 말하는 것은 의미가 없습니다. 따라서 &lt;code&gt;Color&lt;/code&gt; 유형에 대해서는 &lt;code&gt;opEquals&lt;/code&gt; 를 정의 하지만 &lt;code&gt;opCmp&lt;/code&gt; 는 정의 하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="8b1ab6f47e6e402fb3a24bfb9f554e1d0036e9f7" translate="yes" xml:space="preserve">
          <source>The equivalent of member function pointers can be constructed using anonymous lambda functions:</source>
          <target state="translated">익명의 람다 함수를 사용하여 동등한 멤버 함수 포인터를 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b934e5ce8d172dbc9fefc885ad8f4ba875129f8a" translate="yes" xml:space="preserve">
          <source>The error message incase &lt;code&gt;version != D_TypeInfo&lt;/code&gt;</source>
          <target state="translated">오류 메시지 incase &lt;code&gt;version != D_TypeInfo&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="74494fb82c47edd9793007790b8ec76ed5efb325" translate="yes" xml:space="preserve">
          <source>The error message to put in the exception if it is thrown.</source>
          <target state="translated">예외가 발생하면 예외에 넣을 오류 메시지입니다.</target>
        </trans-unit>
        <trans-unit id="ac179c7a25f054b9a84b196608bf4de9e907b671" translate="yes" xml:space="preserve">
          <source>The error number.</source>
          <target state="translated">오류 번호</target>
        </trans-unit>
        <trans-unit id="bb2bfcd8d277ad988cd58683c68c61867529b4d8" translate="yes" xml:space="preserve">
          <source>The escape sequences listed in &lt;a href=&quot;#EscapeSequence&quot;&gt;&lt;i&gt;EscapeSequence&lt;/i&gt;&lt;/a&gt; are:</source>
          <target state="translated">&lt;a href=&quot;#EscapeSequence&quot;&gt;&lt;i&gt;EscapeSequence&lt;/i&gt;&lt;/a&gt; 에 나열된 이스케이프 시퀀스는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="813068399b629e54556fe2331c136edacd43967a" translate="yes" xml:space="preserve">
          <source>The escapes section is a series of substitutions which replace special characters with a string. It's useful when the output format requires escaping of certain characters, for example in HTML &lt;b&gt;&amp;amp;&lt;/b&gt; should be escaped with &lt;b&gt;&amp;amp;amp;&lt;/b&gt;.</source>
          <target state="translated">이스케이프 섹션은 특수 문자를 문자열로 대체하는 일련의 대체입니다. 출력 형식이 특정 문자를 이스케이프해야하는 경우에 유용합니다 (예 : HTML에서 &lt;b&gt;&amp;amp;&lt;/b&gt; 는 &lt;b&gt;&amp;amp; amp; &lt;/b&gt;.</target>
        </trans-unit>
        <trans-unit id="75a80775312b743d79dc5f0458ad6638745e66ff" translate="yes" xml:space="preserve">
          <source>The event handler that gets called to inform of upload/download progress.</source>
          <target state="translated">업로드 / 다운로드 진행률을 알리기 위해 호출되는 이벤트 핸들러입니다.</target>
        </trans-unit>
        <trans-unit id="28ee4bbd0a86e9401b5c283e4626c6777888197c" translate="yes" xml:space="preserve">
          <source>The event handler that gets called when data is needed for sending.</source>
          <target state="translated">전송에 데이터가 필요할 때 호출되는 이벤트 핸들러입니다.</target>
        </trans-unit>
        <trans-unit id="ec0b1eb03ea092eed8857727c86d04dbd3bf6621" translate="yes" xml:space="preserve">
          <source>The event handler that gets called when data is needed for sending. The length of the &lt;code&gt;void[]&lt;/code&gt; specifies the maximum number of bytes that can be sent.</source>
          <target state="translated">전송에 데이터가 필요할 때 호출되는 이벤트 핸들러입니다. &lt;code&gt;void[]&lt;/code&gt; 의 길이는 보낼 수있는 최대 바이트 수를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="c126a38e12f3ea900a6ea7dfdda2e34138f69566" translate="yes" xml:space="preserve">
          <source>The event handler that gets called when the curl backend needs to seek the data to be sent.</source>
          <target state="translated">curl 백엔드가 전송 될 데이터를 찾아야 할 때 호출되는 이벤트 핸들러입니다.</target>
        </trans-unit>
        <trans-unit id="c7e1c85c7ca7e98c1826ed981521b324453ed7c7" translate="yes" xml:space="preserve">
          <source>The event handler that gets called when the net socket has been created but a &lt;code&gt;connect()&lt;/code&gt; call has not yet been done. This makes it possible to set misc. socket options.</source>
          <target state="translated">net 소켓이 작성되었지만 &lt;code&gt;connect()&lt;/code&gt; 호출이 아직 완료되지 않았을 때 호출되는 이벤트 핸들러 . 기타를 설정할 수 있습니다. 소켓 옵션.</target>
        </trans-unit>
        <trans-unit id="02f312ca0b7e961f5a4f5917e4aa7edb41e07360" translate="yes" xml:space="preserve">
          <source>The event handler that receives incoming data.</source>
          <target state="translated">들어오는 데이터를받는 이벤트 핸들러입니다.</target>
        </trans-unit>
        <trans-unit id="b87e0289d3effbf7cf04a5f7cfbfced82cc1d3d4" translate="yes" xml:space="preserve">
          <source>The event handler that receives incoming data. Be sure to copy the incoming ubyte[] since it is not guaranteed to be valid after the callback returns.</source>
          <target state="translated">들어오는 데이터를받는 이벤트 핸들러입니다. 콜백이 리턴 된 후에는 수신 ubyte []가 유효하지 않으므로 반드시 복사하십시오.</target>
        </trans-unit>
        <trans-unit id="4c604b49f0361c7bde910df7da9e4d17ed0e24e3" translate="yes" xml:space="preserve">
          <source>The event handler that receives incoming headers for protocols that uses headers.</source>
          <target state="translated">헤더를 사용하는 프로토콜에 대한 수신 헤더를받는 이벤트 핸들러입니다.</target>
        </trans-unit>
        <trans-unit id="52a6be95e3d2f965951f9ddade7c43108c67742d" translate="yes" xml:space="preserve">
          <source>The event module provides a primitive for lightweight signaling of other threads (emulating Windows events on Posix)</source>
          <target state="translated">이벤트 모듈은 다른 스레드 (Posix에서 Windows 이벤트 에뮬레이션)의 간단한 신호 전달을위한 기본 요소를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="76cbd20f024df6b80d67a632d5c0a1a01fd91d83" translate="yes" xml:space="preserve">
          <source>The exact format is exactly as described in &lt;code&gt;toISOExtString&lt;/code&gt; except that trailing zeroes are permitted - including having fractional seconds with all zeroes. However, a decimal point with nothing following it is invalid. Also, while &lt;a href=&quot;#toISOExtString&quot;&gt;&lt;code&gt;toISOExtString&lt;/code&gt;&lt;/a&gt; will never generate a string with more than 7 digits in the fractional seconds (because that's the limit with hecto-nanosecond precision), it will allow more than 7 digits in order to read strings from other sources that have higher precision (however, any digits beyond 7 will be truncated).</source>
          <target state="translated">정확한 형식은 모든 0으로 소수 초를 포함하여 후행 0이 허용 &lt;code&gt;toISOExtString&lt;/code&gt; 점을 제외하고 는 toISOExtString에 설명 된 것과 동일합니다. 그러나 그 뒤에 아무것도없는 소수점은 유효하지 않습니다. 또한 &lt;a href=&quot;#toISOExtString&quot;&gt; &lt;code&gt;toISOExtString&lt;/code&gt; &lt;/a&gt; 은 분수 초 단위로 7 자리를 초과하는 문자열을 생성하지 않지만 (정수 나 초 단위 정밀도의 한계이기 때문에) 더 높은 정밀도를 가진 다른 소스에서 문자열을 읽으려면 7 자리를 초과 할 수 있습니다 ( 그러나 7보다 큰 숫자는 잘립니다.)</target>
        </trans-unit>
        <trans-unit id="dbfdac6af98f1a47c12d787fa314f16848732e36" translate="yes" xml:space="preserve">
          <source>The exact format is exactly as described in &lt;code&gt;toISOString&lt;/code&gt; except that trailing zeroes are permitted - including having fractional seconds with all zeroes. However, a decimal point with nothing following it is invalid. Also, while &lt;a href=&quot;#toISOString&quot;&gt;&lt;code&gt;toISOString&lt;/code&gt;&lt;/a&gt; will never generate a string with more than 7 digits in the fractional seconds (because that's the limit with hecto-nanosecond precision), it will allow more than 7 digits in order to read strings from other sources that have higher precision (however, any digits beyond 7 will be truncated).</source>
          <target state="translated">정확한 형식은 모든 0이있는 소수 초를 포함하여 후행 0이 허용 &lt;code&gt;toISOString&lt;/code&gt; 점을 제외하고 는 toISOString에 설명 된 것과 동일합니다. 그러나 그 뒤에 아무것도없는 소수점은 유효하지 않습니다. 또한 &lt;a href=&quot;#toISOString&quot;&gt; &lt;code&gt;toISOString&lt;/code&gt; &lt;/a&gt; 은 소수 초에 7 자리를 초과하는 문자열을 생성하지 않지만 (정수 나 초 단위 정밀도의 한계이므로) 정밀도가 높은 다른 소스에서 문자열을 읽으려면 7 자리를 초과 할 수 있습니다 ( 그러나 7보다 큰 숫자는 잘립니다.)</target>
        </trans-unit>
        <trans-unit id="8035aabeb60ff48fad9d3507168fac10a852f522" translate="yes" xml:space="preserve">
          <source>The exact format is exactly as described in &lt;code&gt;toSimpleString&lt;/code&gt; except that trailing zeroes are permitted - including having fractional seconds with all zeroes. However, a decimal point with nothing following it is invalid. Also, while &lt;a href=&quot;#toSimpleString&quot;&gt;&lt;code&gt;toSimpleString&lt;/code&gt;&lt;/a&gt; will never generate a string with more than 7 digits in the fractional seconds (because that's the limit with hecto-nanosecond precision), it will allow more than 7 digits in order to read strings from other sources that have higher precision (however, any digits beyond 7 will be truncated).</source>
          <target state="translated">정확한 형식은 &lt;code&gt;toSimpleString&lt;/code&gt; 에 설명 된 것과 동일합니다. 단, 모든 0이있는 소수 초를 포함하여 후행 0이 허용됩니다. 그러나 그 뒤에 아무것도없는 소수점은 유효하지 않습니다. 또한 &lt;a href=&quot;#toSimpleString&quot;&gt; &lt;code&gt;toSimpleString&lt;/code&gt; &lt;/a&gt; 은 분수 초 단위로 7 자리를 초과하는 문자열을 생성하지 않지만 (정수 나 초 단위 정밀도의 한계이기 때문에) 정밀도가 높은 다른 소스에서 문자열을 읽으려면 7 자리를 초과 할 수 있습니다 ( 그러나 7보다 큰 숫자는 잘립니다.)</target>
        </trans-unit>
        <trans-unit id="65836ccc655a37d33dfc806f525851b4dc381228" translate="yes" xml:space="preserve">
          <source>The example above creates a tagged pointer in the struct A. The pointer is of type &lt;code&gt;uint*&lt;/code&gt; as specified by the first argument, and is named x, as specified by the second argument.</source>
          <target state="translated">위의 예제는 구조체 A에 태그가 지정된 포인터를 만듭니다. 포인터는 첫 번째 인수에 의해 지정된 &lt;code&gt;uint*&lt;/code&gt; 유형 이고 두 번째 인수에 의해 지정된 x라는 이름입니다.</target>
        </trans-unit>
        <trans-unit id="a8289a8de27bbcdd9e4b7b9885e6899b4349a782" translate="yes" xml:space="preserve">
          <source>The example above creates a tagged reference to an Object in the struct A. This expects the same parameters as &lt;code&gt;taggedPointer&lt;/code&gt;, except the first argument which must be a class type instead of a pointer type.</source>
          <target state="translated">위의 예제는 구조체 A에서 Object에 태그가 지정된 참조를 만듭니다. 이는 포인터 유형 대신 클래스 유형이어야하는 첫 번째 인수를 제외하고 &lt;code&gt;taggedPointer&lt;/code&gt; 와 동일한 매개 변수를 예상합니다 .</target>
        </trans-unit>
        <trans-unit id="95c0102684861c4577b62ad69eb70ff34b2390d6" translate="yes" xml:space="preserve">
          <source>The example above wreaks havoc on client code because it is modifying arrays that callers considered immutable. To obtain an immutable array from the writable array &lt;code&gt;buffer&lt;/code&gt;, replace the last line with:</source>
          <target state="translated">위의 예제는 호출자가 불변으로 간주되는 배열을 수정하기 때문에 클라이언트 코드를 혼란스럽게 만듭니다. 쓰기 가능한 배열 &lt;code&gt;buffer&lt;/code&gt; 에서 불변 배열을 얻으려면 마지막 행을 다음으로 바꾸십시오.</target>
        </trans-unit>
        <trans-unit id="399a22d99c9e7b3b5ee30ddef81ec062aec6bdce" translate="yes" xml:space="preserve">
          <source>The example below features an allocator modeled after &lt;a href=&quot;http://goo.gl/m7329l&quot;&gt;jemalloc&lt;/a&gt;, which uses a battery of free-list allocators spaced so as to keep internal fragmentation to a minimum. The &lt;code&gt;FList&lt;/code&gt; definitions specify no bounds for the freelist because the &lt;code&gt;Segregator&lt;/code&gt; does all size selection in advance.</source>
          <target state="translated">아래 예는 &lt;a href=&quot;http://goo.gl/m7329l&quot;&gt;jemalloc을&lt;/a&gt; 모델로 한 할당자를 특징으로하며 , 이는 내부 조각화를 최소로 유지하기 위해 여유 목록 할당 자의 배터리를 사용합니다. &lt;code&gt;Segregator&lt;/code&gt; 가 모든 크기 선택을 미리 수행 하므로 &lt;code&gt;FList&lt;/code&gt; 정의 는 자유 목록에 대한 경계를 지정하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="03c82011a176c73b7fd2e55e8d4ca5d5e5bc2671" translate="yes" xml:space="preserve">
          <source>The example sets a new &lt;code&gt;FileLogger&lt;/code&gt; as new &lt;code&gt;sharedLog&lt;/code&gt;.  If at some point you want to use the original default logger again, you can use &lt;code&gt;sharedLog = null;&lt;/code&gt;. This will put back the original.</source>
          <target state="translated">이 예에서는 새 &lt;code&gt;FileLogger&lt;/code&gt; 를 new &lt;code&gt;sharedLog&lt;/code&gt; 로 설정합니다 . 어느 시점에서 원래 기본 로거를 다시 사용하려는 경우 &lt;code&gt;sharedLog = null;&lt;/code&gt; . 원본이 다시 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="ad582bc954e72accfcbe7e749d32e98547d0b17c" translate="yes" xml:space="preserve">
          <source>The exception module defines all system-level exceptions and provides a mechanism to alter system-level error handling.</source>
          <target state="translated">예외 모듈은 모든 시스템 수준 예외를 정의하고 시스템 수준 오류 처리를 변경하는 메커니즘을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="7a6c8dd2c388cd128d91f81fff3c160065b3f34b" translate="yes" xml:space="preserve">
          <source>The exception thrown during finalization.</source>
          <target state="translated">종료하는 동안 예외가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="9e6c1b1caa6f537b3b32ae230a3319f2a84949f0" translate="yes" xml:space="preserve">
          <source>The exception to throw if the value evaluates to false.</source>
          <target state="translated">값이 false로 평가되면 발생하는 예외입니다.</target>
        </trans-unit>
        <trans-unit id="10d46feeb5a300f1f28f6d3818a7a14193d2059d" translate="yes" xml:space="preserve">
          <source>The expanded data.</source>
          <target state="translated">확장 된 데이터입니다.</target>
        </trans-unit>
        <trans-unit id="cbc3d84209a76290f33343978e317c76e214fa4c" translate="yes" xml:space="preserve">
          <source>The exponent is negative and the factor is one, i.e., output[j] := sum[ exp(-2 PI i j k / N) input[k] ].</source>
          <target state="translated">지수는 음수이고 인수는 1입니다. 즉 출력 [j] : = sum [exp (-2 PI ijk / N) 입력 [k]].</target>
        </trans-unit>
        <trans-unit id="08786360cdc12838546c00b5767cf2cab959b50c" translate="yes" xml:space="preserve">
          <source>The exponent is positive and the factor is 1/N, i.e., output[j] := (1 / N) sum[ exp(+2 PI i j k / N) input[k] ].</source>
          <target state="translated">지수는 양수이고 계수는 1 / N입니다. 즉, 출력 [j] : = (1 / N) 합 [exp (+2 PI ijk / N) 입력 [k]].</target>
        </trans-unit>
        <trans-unit id="c871c5d07aafe7ec6925f7e7fae1500b032e2b52" translate="yes" xml:space="preserve">
          <source>The expression and the errorHandler must have a common type they can both be implicitly casted to, and that type will be the type of the compound expression.</source>
          <target state="translated">표현식과 errorHandler는 내재적으로 캐스트 될 수있는 공통 유형을 가져야하며 해당 유형은 복합 표현식의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="34375c5ee3f5635a2e38da6b0e76fc609894c573" translate="yes" xml:space="preserve">
          <source>The expression asserted not to throw.</source>
          <target state="translated">그 표현은 던지지 말 것을 주장했다.</target>
        </trans-unit>
        <trans-unit id="940dd3375faca27ce190b8fb03def99092a3aab1" translate="yes" xml:space="preserve">
          <source>The expression form is:</source>
          <target state="translated">표현 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cc54de17f165e5e9a2ba7fa962f4eecaa39f90b2" translate="yes" xml:space="preserve">
          <source>The expression is evaluated.</source>
          <target state="translated">식이 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="22a556158ebfbc64522a677428ab0391c34f8183" translate="yes" xml:space="preserve">
          <source>The expression that copy constructs or moves the value.</source>
          <target state="translated">복사하는 표현식은 값을 구성하거나 이동합니다.</target>
        </trans-unit>
        <trans-unit id="91f707cf0e8e3128051036fb96ff3b7693733b1d" translate="yes" xml:space="preserve">
          <source>The expression to resolve as type or symbol.</source>
          <target state="translated">유형 또는 기호로 해석 할 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="29c4204e99277952fc7a54ab66543bc42d61a803" translate="yes" xml:space="preserve">
          <source>The expression to run and return its result.</source>
          <target state="translated">실행하고 결과를 리턴하는 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="92d0bb2bd94dd52b7503e678d48be02f028860ef" translate="yes" xml:space="preserve">
          <source>The expression to test.</source>
          <target state="translated">테스트 할 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="3ba5f3fe8e3c4ad3783ea96faee9ce1e4526ddb4" translate="yes" xml:space="preserve">
          <source>The expression which may throw an exception.</source>
          <target state="translated">예외가 발생할 수있는 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="646fe39033d4569a34021185a6750173a3852965" translate="yes" xml:space="preserve">
          <source>The expression:</source>
          <target state="translated">표현식:</target>
        </trans-unit>
        <trans-unit id="24968438ed1fc3f9aa123f08e882cf9dcb629a30" translate="yes" xml:space="preserve">
          <source>The extension part of a file name, including the dot.  If there is no extension, &lt;code&gt;null&lt;/code&gt; is returned.</source>
          <target state="translated">점을 포함하여 파일 이름의 확장자 부분. 확장명이 없으면 &lt;code&gt;null&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="001c41a8faed92276e0710e5f77bacf1f43befe9" translate="yes" xml:space="preserve">
          <source>The extra *'s and +'s on the comment opening, closing and left margin are ignored and are not part of the embedded documentation. Comments not following one of those forms are not documentation comments.</source>
          <target state="translated">주석 열기, 닫기 및 왼쪽 여백에있는 여분의 *와 +는 무시되며 내장 문서의 일부가 아닙니다. 이러한 양식 중 하나를 따르지 않는 주석은 문서 ​​주석이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="60cbf9a8b6c782eeaf3b240238aaad4006024e93" translate="yes" xml:space="preserve">
          <source>The factory should print an error and abort the program if it cannot successfully initialize the GC instance.</source>
          <target state="translated">팩토리는 GC 인스턴스를 성공적으로 초기화 할 수없는 경우 오류를 인쇄하고 프로그램을 중단해야합니다.</target>
        </trans-unit>
        <trans-unit id="f5a2d7b1faf4a00e391206a0b6d040b1dd55f507" translate="yes" xml:space="preserve">
          <source>The fallback allocator.</source>
          <target state="translated">대체 할당 자.</target>
        </trans-unit>
        <trans-unit id="6444c34b4999b63334e3fe1c10565688c176440d" translate="yes" xml:space="preserve">
          <source>The fiber function.</source>
          <target state="translated">섬유 기능.</target>
        </trans-unit>
        <trans-unit id="c0e4569946778edcb0cfe73790a6deb0f483408e" translate="yes" xml:space="preserve">
          <source>The fiber module provides OS-indepedent lightweight threads aka fibers.</source>
          <target state="translated">파이버 모듈은 OS와 무관 한 경량 스레드 (파이버)를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="4ebf4ba0f41676101df65de78d14565377976d26" translate="yes" xml:space="preserve">
          <source>The fiber object representing the calling fiber or null if no fiber is currently active within this thread. The result of deleting this object is undefined.</source>
          <target state="translated">호출 파이버를 나타내는 파이버 객체. 현재이 스레드에서 활성화 된 파이버가없는 경우 null입니다. 이 객체를 삭제 한 결과는 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7163e2b220c5c73c7ee35da99996a1282317d054" translate="yes" xml:space="preserve">
          <source>The field is ended when there is no input, even if the quote was not closed.</source>
          <target state="translated">따옴표가 닫히지 않아도 입력이 없으면 필드가 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="779d09c98e4cfcdaab8d2edfcd062b2bc1c5fe62" translate="yes" xml:space="preserve">
          <source>The fields below this were added in CURLVERSION_SECOND</source>
          <target state="translated">이 아래의 필드는 CURLVERSION_SECOND에 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="7fb4d8eebf35f6bbc1f833a412d5cc7420dea229" translate="yes" xml:space="preserve">
          <source>The file (or directory) to get a DirEntry for.</source>
          <target state="translated">DirEntry를 가져올 파일 (또는 디렉토리)입니다.</target>
        </trans-unit>
        <trans-unit id="40dabb9eb8e81154153036d71178601514e1f7f3" translate="yes" xml:space="preserve">
          <source>The file and line of the call.</source>
          <target state="translated">통화의 파일과 회선.</target>
        </trans-unit>
        <trans-unit id="e2f6f4f187fd62357491cbe8478aa3ae4cefb31e" translate="yes" xml:space="preserve">
          <source>The file attributes or 0 if the file attributes were encoded for an incompatible OS (Windows vs. POSIX).</source>
          <target state="translated">파일 속성 또는 호환되지 않는 OS (Windows 대 POSIX)에 대해 파일 속성이 인코딩 된 경우 0입니다.</target>
        </trans-unit>
        <trans-unit id="2587d80da404ef88f56c1d45c26f059538ee948c" translate="yes" xml:space="preserve">
          <source>The file attributes or 0 if the file attributes were encoded for an incompatible OS (Windows vs. Posix).</source>
          <target state="translated">파일 속성 또는 파일 속성이 호환되지 않는 OS (Windows와 Posix)로 인코딩 된 경우 0입니다.</target>
        </trans-unit>
        <trans-unit id="f357296885e979c9eb815032610719a979731bd8" translate="yes" xml:space="preserve">
          <source>The file attributes.</source>
          <target state="translated">파일 속성</target>
        </trans-unit>
        <trans-unit id="f692a5a95eb19a88be916cc17fd3a299fdb0b4c2" translate="yes" xml:space="preserve">
          <source>The file data in compressed form.</source>
          <target state="translated">압축 된 형식의 파일 데이터입니다.</target>
        </trans-unit>
        <trans-unit id="11cc9842d65b87247a394d2db23ff2854dbd2625" translate="yes" xml:space="preserve">
          <source>The file data.</source>
          <target state="translated">파일 데이터.</target>
        </trans-unit>
        <trans-unit id="21cf4d39fea8701f9ccea1f6e9c33a8dca629be0" translate="yes" xml:space="preserve">
          <source>The file name of the D source code corresponding with where the error was thrown from.</source>
          <target state="translated">오류가 발생한 위치에 해당하는 D 소스 코드의 파일 이름입니다.</target>
        </trans-unit>
        <trans-unit id="b64522363b929d137710605ff07b8daf334bc620" translate="yes" xml:space="preserve">
          <source>The file name to show. If not set, the actual file name will be used (if this is a file part)</source>
          <target state="translated">표시 할 파일 이름입니다. 설정하지 않으면 실제 파일 이름이 사용됩니다 (파일 부분 인 경우).</target>
        </trans-unit>
        <trans-unit id="bf8ad1ee8706b576c3d861ca4c35b04004625b5d" translate="yes" xml:space="preserve">
          <source>The file names for packages and modules should also be composed of the ASCII characters lower case letters, digits or &lt;code&gt;_&lt;/code&gt; and should not be a &lt;a href=&quot;lex#Keyword&quot;&gt;&lt;i&gt;Keyword&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">패키지 및 모듈의 파일 이름은 ASCII 문자 소문자, 숫자 또는 &lt;code&gt;_&lt;/code&gt; 로 구성되어야하며 &lt;a href=&quot;lex#Keyword&quot;&gt;&lt;i&gt;키워드&lt;/i&gt;&lt;/a&gt; 가 아니어야합니다 .</target>
        </trans-unit>
        <trans-unit id="568163d3852e8f82e9cc9864a262f9868cd7a80a" translate="yes" xml:space="preserve">
          <source>The file names for packages and modules should be composed only of the ASCII lower case letters, digits, and &lt;code&gt;_&lt;/code&gt;s, and should not be a &lt;a href=&quot;lex#Keyword&quot;&gt;&lt;i&gt;Keyword&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">패키지 및 모듈의 파일 이름은 ASCII 소문자, 숫자 및 &lt;code&gt;_&lt;/code&gt; 로만 구성 되어야하며 &lt;a href=&quot;lex#Keyword&quot;&gt;&lt;i&gt;Keyword&lt;/i&gt;&lt;/a&gt; 가 아니어야합니다 .</target>
        </trans-unit>
        <trans-unit id="27e521d84e71e057af31f6b16036a8dda6098775" translate="yes" xml:space="preserve">
          <source>The file that is being linked. This is the target path that's stored in the symlink. A relative path is relative to the created symlink.</source>
          <target state="translated">링크되는 파일입니다. 심볼릭 링크에 저장된 대상 경로입니다. 상대 경로는 생성 된 심볼릭 링크를 기준으로합니다.</target>
        </trans-unit>
        <trans-unit id="a48d130bf6ed7fe001b9b68c13bd4356b06eb640" translate="yes" xml:space="preserve">
          <source>The file that the &lt;a href=&quot;#DateTimeException&quot;&gt;&lt;code&gt;DateTimeException&lt;/code&gt;&lt;/a&gt; will list if thrown.</source>
          <target state="translated">발생 된 경우 &lt;a href=&quot;#DateTimeException&quot;&gt; &lt;code&gt;DateTimeException&lt;/code&gt; &lt;/a&gt; 이 나열 할 파일입니다 .</target>
        </trans-unit>
        <trans-unit id="886ddc5df982fa3a52b4dae1cc5e097e3fae8531" translate="yes" xml:space="preserve">
          <source>The file to get the attributes of.</source>
          <target state="translated">속성을 가져올 파일입니다.</target>
        </trans-unit>
        <trans-unit id="c5856ac3b9ed35958ce9f401bbff0c265bcd66da" translate="yes" xml:space="preserve">
          <source>The file to get the symbolic link attributes of.</source>
          <target state="translated">기호 링크 속성을 가져올 파일입니다.</target>
        </trans-unit>
        <trans-unit id="d5a902223a6a641c14dbfbc008db96721d6af330" translate="yes" xml:space="preserve">
          <source>The file used for logging.</source>
          <target state="translated">로깅에 사용되는 파일입니다.</target>
        </trans-unit>
        <trans-unit id="f7969ce864cdb7d64da59da6dfc8b40cf28ba7bb" translate="yes" xml:space="preserve">
          <source>The file where the error occurred.</source>
          <target state="translated">오류가 발생한 파일입니다.</target>
        </trans-unit>
        <trans-unit id="3ff1fcb05fd162b545299ba30ad59377c1eb86a5" translate="yes" xml:space="preserve">
          <source>The file where the error occurred. Defaults to &lt;code&gt;__FILE__&lt;/code&gt;.</source>
          <target state="translated">오류가 발생한 파일입니다. 기본값은 &lt;code&gt;__FILE__&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9a7b4c097e4526bdecb31861d25a87231f1a612b" translate="yes" xml:space="preserve">
          <source>The file where the exception occurred.</source>
          <target state="translated">예외가 발생한 파일입니다.</target>
        </trans-unit>
        <trans-unit id="2a8a857ec47a034acf4c2fcaed0de229c31869d5" translate="yes" xml:space="preserve">
          <source>The filename of the &lt;code&gt;File&lt;/code&gt; log messages are written to.</source>
          <target state="translated">&lt;code&gt;File&lt;/code&gt; 로그 메시지 의 파일 이름 이 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="37dc45c1af7cba50c135f406c906822e95a5938d" translate="yes" xml:space="preserve">
          <source>The filename of the output file of the &lt;code&gt;FileLogger&lt;/code&gt;. If that file can not be opened for writting an exception will be thrown.</source>
          <target state="translated">&lt;code&gt;FileLogger&lt;/code&gt; 출력 파일의 파일 이름입니다 . 해당 파일을 쓰기 위해 열 수 없으면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3910614447549528bc2d2fc1be565210c1526e11" translate="yes" xml:space="preserve">
          <source>The finish function returns the final hash sum and resets the Digest.</source>
          <target state="translated">finish 함수는 최종 해시 합계를 반환하고 다이제스트를 재설정합니다.</target>
        </trans-unit>
        <trans-unit id="133d5dd83ff02e493d05a0e47c1deb319a8252d7" translate="yes" xml:space="preserve">
          <source>The finish function returns the hash value. It takes an optional buffer to copy the data into. If a buffer is passed, it must be at least &lt;a href=&quot;#length&quot;&gt;&lt;code&gt;length&lt;/code&gt;&lt;/a&gt; bytes big.</source>
          <target state="translated">finish 함수는 해시 값을 반환합니다. 데이터를 복사하려면 선택적 버퍼가 필요합니다. 버퍼가 전달되면 최소한 &lt;a href=&quot;#length&quot;&gt; &lt;code&gt;length&lt;/code&gt; &lt;/a&gt; 바이트 이상이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="22bbeb22c4ba0a11e694a3fb88ce4ce66c1aa8c4" translate="yes" xml:space="preserve">
          <source>The finish function returns the hash value. It takes an optional buffer to copy the data into. If a buffer is passed, it must have a length at least &lt;a href=&quot;#length&quot;&gt;&lt;code&gt;length&lt;/code&gt;&lt;/a&gt; bytes.</source>
          <target state="translated">finish 함수는 해시 값을 반환합니다. 데이터를 복사하려면 선택적 버퍼가 필요합니다. 버퍼가 전달되면 길이는 최소한 &lt;a href=&quot;#length&quot;&gt; &lt;code&gt;length&lt;/code&gt; &lt;/a&gt; 바이트 이상이어야 합니다.</target>
        </trans-unit>
        <trans-unit id="957dc77c438abefa8c77eaf7563108a790ce4d94" translate="yes" xml:space="preserve">
          <source>The first</source>
          <target state="translated">첫번째</target>
        </trans-unit>
        <trans-unit id="fb47524b87677bd448123bb56b7daf118be97145" translate="yes" xml:space="preserve">
          <source>The first &lt;a href=&quot;expression#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression&lt;/i&gt;&lt;/a&gt; is evaluated at compile time, and converted to a boolean value. If the value is true, the static assert is ignored. If the value is false, an error diagnostic is issued and the compile fails.</source>
          <target state="translated">첫 번째 &lt;a href=&quot;expression#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression&lt;/i&gt;&lt;/a&gt; 은 컴파일 타임에 평가되고 부울 값으로 변환됩니다. 값이 true이면 정적 어설 션이 무시됩니다. 값이 false이면 오류 진단이 실행되고 컴파일이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="a33576b80d4f4e8bd604397c308091bd4d49eeac" translate="yes" xml:space="preserve">
          <source>The first &lt;code&gt;Exception&lt;/code&gt; which was bypassed when this Error was thrown, or &lt;code&gt;null&lt;/code&gt; if no &lt;code&gt;Exception&lt;/code&gt;s were pending.</source>
          <target state="translated">이 오류가 발생했을 때 무시 된 최초의 &lt;code&gt;Exception&lt;/code&gt; . 보류중인 &lt;code&gt;Exception&lt;/code&gt; &lt;code&gt;null&lt;/code&gt; 경우는 null</target>
        </trans-unit>
        <trans-unit id="83bd533ac7ce9ad8a841e8cf9ee5bfbb37b7a8f6" translate="yes" xml:space="preserve">
          <source>The first &lt;code&gt;v1&lt;/code&gt; for which &lt;code&gt;v1 &amp;gt; v2&lt;/code&gt; is true determines the result. This could lead to unexpected behaviour.</source>
          <target state="translated">제 &lt;code&gt;v1&lt;/code&gt; 되는 &lt;code&gt;v1 &amp;gt; v2&lt;/code&gt; 참이 결과를 판정한다. 예기치 않은 동작이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba9501cbc71e13c8461adcfc7cfb46ad49a3228f" translate="yes" xml:space="preserve">
          <source>The first argument for the predicate.</source>
          <target state="translated">술어에 대한 첫 번째 인수.</target>
        </trans-unit>
        <trans-unit id="d76b59c9568cb4d5adeddeb8e61ac34ba34641de" translate="yes" xml:space="preserve">
          <source>The first argument is a class type or an expression of class type. The second argument is a string that matches the name of one of the functions of that class. The result is a tuple of the virtual overloads of that function. It does not include final functions that do not override anything.</source>
          <target state="translated">첫 번째 인수는 클래스 유형 또는 클래스 유형의 표현식입니다. 두 번째 인수는 해당 클래스의 함수 중 하나의 이름과 일치하는 문자열입니다. 결과적으로 해당 기능의 가상 과부하가 터플됩니다. 대체하지 않는 최종 기능은 포함하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dd726d5af5bf0120b5bd49b63370601b230f8cd3" translate="yes" xml:space="preserve">
          <source>The first argument is a type that has members, or is an expression of a type that has members. The second argument is a string. If the string is a valid property of the type, &lt;code&gt;true&lt;/code&gt; is returned, otherwise &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">첫 번째 인수는 멤버가있는 유형이거나 멤버가있는 유형의 표현식입니다. 두 번째 인수는 문자열입니다. 문자열이 유효한 유형의 속성 &lt;code&gt;true&lt;/code&gt; 가 반환되고 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 가 반환 됩니다.</target>
        </trans-unit>
        <trans-unit id="1a43e4ec8b9b76809401c1e8287827f1c5ded36c" translate="yes" xml:space="preserve">
          <source>The first argument is an aggregate (e.g. struct/class/module). The second argument is a &lt;code&gt;string&lt;/code&gt; that matches the name of the member(s) to return. The third argument is a &lt;code&gt;bool&lt;/code&gt;, and is optional. If &lt;code&gt;true&lt;/code&gt;, the result will also include template overloads. The result is a tuple of all the overloads of the supplied name.</source>
          <target state="translated">첫 번째 인수는 집계입니다 (예 : struct / class / module). 두 번째 인수는 반환 할 멤버의 이름과 일치 하는 &lt;code&gt;string&lt;/code&gt; 입니다. 세 번째 인수는 &lt;code&gt;bool&lt;/code&gt; 이며 선택 사항입니다. 경우 &lt;code&gt;true&lt;/code&gt; 결과는 템플릿 과부하도 포함됩니다. 결과는 제공된 이름의 모든 과부하의 튜플입니다.</target>
        </trans-unit>
        <trans-unit id="2a174554ed3bb0d11c52209ee3ed7c598d6bcaa6" translate="yes" xml:space="preserve">
          <source>The first argument of &lt;code&gt;Checked&lt;/code&gt;, e.g. &lt;code&gt;int&lt;/code&gt; if the left-hand side of the operator is &lt;code&gt;Checked!int&lt;/code&gt;</source>
          <target state="translated">첫 번째 인수 &lt;code&gt;Checked&lt;/code&gt; 예 &lt;code&gt;int&lt;/code&gt; 오퍼레이터의 좌측이 경우 &lt;code&gt;Checked!int&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8841f05f16f8289043fb3adb8a0d9f6c62e9f3bb" translate="yes" xml:space="preserve">
          <source>The first argument that passes the test &lt;code&gt;pred&lt;/code&gt;.</source>
          <target state="translated">테스트 &lt;code&gt;pred&lt;/code&gt; 를 통과 한 첫 번째 인수입니다 .</target>
        </trans-unit>
        <trans-unit id="6f69babce0033893a00ba9dd4fdded8c5d91d428" translate="yes" xml:space="preserve">
          <source>The first argument to apply to &lt;code&gt;fun&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;fun&lt;/code&gt; 에 적용 할 첫 번째 주장</target>
        </trans-unit>
        <trans-unit id="5e0881d9245470375fca9c2a63d7fd75c1ab511d" translate="yes" xml:space="preserve">
          <source>The first array to compare</source>
          <target state="translated">비교할 첫 번째 배열</target>
        </trans-unit>
        <trans-unit id="6402ea9c3911f868771a9ad2ee306a3ff47b76c7" translate="yes" xml:space="preserve">
          <source>The first choice that &lt;code&gt;switchObject&lt;/code&gt; can be casted to the type of argument it accepts will be called with &lt;code&gt;switchObject&lt;/code&gt; casted to that type, and the value it'll return will be returned by &lt;code&gt;castSwitch&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;switchObject&lt;/code&gt; 가 허용하는 인수 유형으로 캐스트 될 수있는 첫 번째 선택은 해당 유형으로 캐스트 된 &lt;code&gt;switchObject&lt;/code&gt; 와 함께 호출되며 , 리턴 할 값은 &lt;code&gt;castSwitch&lt;/code&gt; 에 의해 리턴됩니다 .</target>
        </trans-unit>
        <trans-unit id="8c0a3698b1be7dcab735cd7cac7d279e510c1569" translate="yes" xml:space="preserve">
          <source>The first element of the array is the size of the type (for classes it is the &lt;a href=&quot;#classInstanceSize&quot;&gt;&lt;i&gt;classInstanceSize&lt;/i&gt;&lt;/a&gt;).</source>
          <target state="translated">배열의 첫 번째 요소는 유형의 크기입니다 (클래스의 경우 &lt;a href=&quot;#classInstanceSize&quot;&gt;&lt;i&gt;classInstanceSize입니다&lt;/i&gt;&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="d156d92ea93ea0bd49c4929ebca8565a10591e92" translate="yes" xml:space="preserve">
          <source>The first element of the array.</source>
          <target state="translated">배열의 첫 번째 요소</target>
        </trans-unit>
        <trans-unit id="d8e16b70885d5121ddc9494a6960e6bb4c96cb43" translate="yes" xml:space="preserve">
          <source>The first expression is converted to &lt;code&gt;bool&lt;/code&gt;, and is evaluated.</source>
          <target state="translated">첫 번째 표현식은 &lt;code&gt;bool&lt;/code&gt; 로 변환되어 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="cf9e5f533fce6e846463f393ddd35d42bb1f1cd6" translate="yes" xml:space="preserve">
          <source>The first field in the input</source>
          <target state="translated">입력의 첫 번째 필드</target>
        </trans-unit>
        <trans-unit id="d4d950398e4d3043c7b4cad357808ae2f4342dfd" translate="yes" xml:space="preserve">
          <source>The first form attaches the &lt;code&gt;return&lt;/code&gt; to the &lt;code&gt;scope&lt;/code&gt;, and has &lt;a href=&quot;#return-scope-parameters&quot;&gt;return scope parameter&lt;/a&gt; semantics for the value of the &lt;code&gt;ref&lt;/code&gt; parameter.</source>
          <target state="translated">첫 번째 형태는 첨부 &lt;code&gt;return&lt;/code&gt; 받는 &lt;code&gt;scope&lt;/code&gt; 및 보유 &lt;a href=&quot;#return-scope-parameters&quot;&gt;복귀 범위 매개 변수&lt;/a&gt; 의 값에 대한 의미 &lt;code&gt;ref&lt;/code&gt; 파라미터.</target>
        </trans-unit>
        <trans-unit id="8b1ce77e77b315411f0f72483fe564f04bb631f4" translate="yes" xml:space="preserve">
          <source>The first function</source>
          <target state="translated">첫 번째 기능</target>
        </trans-unit>
        <trans-unit id="f3024cc5ecfa3c08bdbe44b263a51764ec97fd6f" translate="yes" xml:space="preserve">
          <source>The first member of the &lt;code&gt;vtbl[]&lt;/code&gt; is not the pointer to the &lt;code&gt;Interface&lt;/code&gt;, but the first virtual function pointer.</source>
          <target state="translated">&lt;code&gt;vtbl[]&lt;/code&gt; 의 첫 번째 멤버 는 &lt;code&gt;Interface&lt;/code&gt; 에 대한 포인터가 아니라 첫 번째 가상 함수 포인터입니다.</target>
        </trans-unit>
        <trans-unit id="847d6d02e0c1f522b786c8972c9a6146a642fa90" translate="yes" xml:space="preserve">
          <source>The first member of the &lt;code&gt;vtbl[]&lt;/code&gt; is not the pointer to the InterfaceInfo, but the first virtual function pointer.</source>
          <target state="translated">&lt;code&gt;vtbl[]&lt;/code&gt; 의 첫 번째 멤버 는 InterfaceInfo에 대한 포인터가 아니라 첫 번째 가상 함수 포인터입니다.</target>
        </trans-unit>
        <trans-unit id="c2d2ce897245ef2180a0c50b1783471cf2be4244" translate="yes" xml:space="preserve">
          <source>The first overload exists only if &lt;code&gt;autoInit == RefCountedAutoInitialize.yes&lt;/code&gt;. So if &lt;code&gt;autoInit == RefCountedAutoInitialize.no&lt;/code&gt; or called for a constant or immutable object, then &lt;code&gt;refCountedPayload&lt;/code&gt; will also be qualified as safe and nothrow (but will still assert if not initialized).</source>
          <target state="translated">첫 번째 과부하는 &lt;code&gt;autoInit == RefCountedAutoInitialize.yes&lt;/code&gt; 경우에만 존재합니다 . 따라서 &lt;code&gt;autoInit == RefCountedAutoInitialize.no&lt;/code&gt; 또는 상수 또는 불변의 객체를 &lt;code&gt;refCountedPayload&lt;/code&gt; 하면 refCountedPayload 도 안전하고 문제가없는 것으로 규정됩니다 (그러나 초기화되지 않은 경우에는 여전히 주장됩니다).</target>
        </trans-unit>
        <trans-unit id="dfd8266058456fb8b44a614fe1b78098bba5c6d8" translate="yes" xml:space="preserve">
          <source>The first overload of &lt;code&gt;makeIndex&lt;/code&gt; writes to a range containing pointers, and the second writes to a range containing offsets. The first overload requires &lt;code&gt;Range&lt;/code&gt; to be a &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward range&lt;/a&gt;, and the latter requires it to be a random-access range.</source>
          <target state="translated">&lt;code&gt;makeIndex&lt;/code&gt; 의 첫 번째 오버로드는 포인터를 포함하는 범위에 쓰고 두 번째는 오프셋을 포함하는 범위에 씁니다. 첫 번째 과부하는 &lt;code&gt;Range&lt;/code&gt; 가 &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;순방향 범위&lt;/a&gt; 여야 하고 후자는 랜덤 액세스 범위 여야합니다.</target>
        </trans-unit>
        <trans-unit id="2797f8bab40930285c67d69e0f78f4ff6b12f672" translate="yes" xml:space="preserve">
          <source>The first overload of this function will return &lt;code&gt;T.init&lt;/code&gt; if the range is empty. However, the second overload will return &lt;code&gt;seed&lt;/code&gt; on empty ranges.</source>
          <target state="translated">이 함수의 첫 번째 과부하 는 범위가 비어 있으면 &lt;code&gt;T.init&lt;/code&gt; 를 반환 합니다. 그러나 두 번째 과부하는 빈 범위에서 &lt;code&gt;seed&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="fa15d56dc093902b6572dae74b23ea12e4df8659" translate="yes" xml:space="preserve">
          <source>The first part is done automatically by the language, the second part is done if a postblit function is defined for the struct. The postblit has access only to the destination struct object, not the source. Its job is to &amp;lsquo;fix up&amp;rsquo; the destination as necessary, such as making copies of referenced data, incrementing reference counts, etc. For example:</source>
          <target state="translated">첫 번째 부분은 언어에 의해 자동으로 수행되고 두 번째 부분은 포스트 블릿 기능이 구조체에 대해 정의 된 경우 수행됩니다. 포스트 블릿은 소스가 아닌 대상 구조체 객체에만 액세스 할 수 있습니다. 이 작업은 참조 데이터의 사본 작성, 참조 횟수 증가 등과 같이 필요에 따라 대상을 '수정'하는 것입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b6a25e3471beef6bed20eb948a4b0de3cefb170f" translate="yes" xml:space="preserve">
          <source>The first part of the desired time zones.</source>
          <target state="translated">원하는 시간대의 첫 부분.</target>
        </trans-unit>
        <trans-unit id="f479a5f1dc2ec5b3e8f93d2c246a61132b592fa7" translate="yes" xml:space="preserve">
          <source>The first range</source>
          <target state="translated">첫 번째 범위</target>
        </trans-unit>
        <trans-unit id="978014a33cbc746b950a93b0f0736f4203ea8def" translate="yes" xml:space="preserve">
          <source>The first range to be compared.</source>
          <target state="translated">비교할 첫 번째 범위입니다.</target>
        </trans-unit>
        <trans-unit id="ca9cc691843153958d1dfce3f9f135428053bc03" translate="yes" xml:space="preserve">
          <source>The first range.</source>
          <target state="translated">첫 번째 범위.</target>
        </trans-unit>
        <trans-unit id="376b0679101f4b59ef8dcfe360d9831914d2f062" translate="yes" xml:space="preserve">
          <source>The first section is the</source>
          <target state="translated">첫 번째 섹션은</target>
        </trans-unit>
        <trans-unit id="0a2ac8281c00878fb6aeb93d4c1aa8543d1c7cdd" translate="yes" xml:space="preserve">
          <source>The first template argument is the size of the region and the second is the needed alignment. Depending on the alignment requested and platform details, the actual available storage may be smaller than the compile-time parameter. To make sure that at least &lt;code&gt;n&lt;/code&gt; bytes are available in the region, use &lt;code&gt;InSituRegion!(n + a - 1, a)&lt;/code&gt;.</source>
          <target state="translated">첫 번째 템플릿 인수는 영역의 크기이고 두 번째 템플릿은 필요한 정렬입니다. 요청 된 정렬 및 플랫폼 세부 사항에 따라 실제 사용 가능한 스토리지는 컴파일 타임 매개 변수보다 작을 수 있습니다. 리전에서 &lt;code&gt;n&lt;/code&gt; 바이트 이상 을 사용할 수있게하려면 &lt;code&gt;InSituRegion!(n + a - 1, a)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f09dcfe52dd359d217c384efcd5e2b579c11d4d5" translate="yes" xml:space="preserve">
          <source>The first thing a catch handler does is call this.</source>
          <target state="translated">캐치 핸들러가 가장 먼저하는 일은 이것을 호출하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="06bc16353a0bd43b921f8f9a4d6fe2a9b273859a" translate="yes" xml:space="preserve">
          <source>The first time point in the range.</source>
          <target state="translated">범위의 첫 번째 시점</target>
        </trans-unit>
        <trans-unit id="ee856ba33815edde83d3ab4573c1bb58ec0e2ba8" translate="yes" xml:space="preserve">
          <source>The first two overloads throw only if &lt;code&gt;alloc&lt;/code&gt;'s primitives do. The overloads that involve copy initialization deallocate memory and propagate the exception if the copy operation throws.</source>
          <target state="translated">처음 두 개의 과부하는 &lt;code&gt;alloc&lt;/code&gt; 의 프리미티브가 수행하는 경우에만 발생 합니다. 복사 초기화와 관련된 오버로드는 메모리를 할당 해제하고 복사 작업이 발생하면 예외를 전파합니다.</target>
        </trans-unit>
        <trans-unit id="333231d0183ec9a4310007ffcf10aa12ccaa5deb" translate="yes" xml:space="preserve">
          <source>The first two overloads throw only if the used allocator's primitives do. The overloads that involve copy initialization deallocate memory and propagate the exception if the copy operation throws.</source>
          <target state="translated">처음 두 개의 과부하는 사용 된 할당 자의 프리미티브가 수행하는 경우에만 발생합니다. 복사 초기화와 관련된 오버로드는 메모리를 할당 해제하고 복사 작업이 발생하면 예외를 전파합니다.</target>
        </trans-unit>
        <trans-unit id="8adbee74bf4af885c51ba2cdd7ef319e8a5ccd70" translate="yes" xml:space="preserve">
          <source>The first type to receive the type name for</source>
          <target state="translated">유형 이름을받는 첫 번째 유형</target>
        </trans-unit>
        <trans-unit id="24a327b5e33473298dc52e8aa179b1270880d206" translate="yes" xml:space="preserve">
          <source>The first version counts the number of elements &lt;code&gt;x&lt;/code&gt; in &lt;code&gt;r&lt;/code&gt; for which &lt;code&gt;pred(x, value)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;. &lt;code&gt;pred&lt;/code&gt; defaults to equality. Performs &amp;Omicron;(&lt;code&gt;haystack.length&lt;/code&gt;) evaluations of &lt;code&gt;pred&lt;/code&gt;.</source>
          <target state="translated">소자의 수는 제 버전 카운트 &lt;code&gt;x&lt;/code&gt; 에서 &lt;code&gt;r&lt;/code&gt; 되는 &lt;code&gt;pred(x, value)&lt;/code&gt; 이다 &lt;code&gt;true&lt;/code&gt; . &lt;code&gt;pred&lt;/code&gt; 는 평등으로 기본 설정됩니다. &lt;code&gt;pred&lt;/code&gt; 의 &amp;Omicron; ( &lt;code&gt;haystack.length&lt;/code&gt; ) 평가를 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="c9816b3b28ee2e6c5406da992bb1cbb42be32059" translate="yes" xml:space="preserve">
          <source>The first way is to use a literal that is already immutable, such as string literals. String literals are always immutable.</source>
          <target state="translated">첫 번째 방법은 문자열 리터럴과 같이 이미 변경할 수없는 리터럴을 사용하는 것입니다. 문자열 리터럴은 항상 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b05e9e189cc2bf7e6e8a6f344ff95d0591fc3a0f" translate="yes" xml:space="preserve">
          <source>The first will queue writers until no readers hold the mutex, then pass the writers through one at a time. If a reader acquires the mutex while there are still writers queued, the reader will take precedence.</source>
          <target state="translated">첫 번째는 뮤텍스를 보유한 독자가 없을 때까지 작성자를 대기시킨 다음 한 번에 하나씩 작성자를 통과시킵니다. 대기중인 기록기가 여전히있는 동안 판독기가 뮤텍스를 획득하면 판독기가 우선합니다.</target>
        </trans-unit>
        <trans-unit id="1b1951cc36673198c26cd910de69ac59cf5f6d05" translate="yes" xml:space="preserve">
          <source>The focus of this module is the core needs of developing Unicode-aware applications. To that effect it provides the following optimized primitives:</source>
          <target state="translated">이 모듈의 초점은 유니 코드 인식 응용 프로그램 개발의 핵심 요구 사항입니다. 이를 위해 다음과 같은 최적화 된 프리미티브를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="6fa1fe0d7308c90108a99d43bd343885cf39b2f7" translate="yes" xml:space="preserve">
          <source>The following IEEE 'real' formats are currently supported:</source>
          <target state="translated">다음과 같은 IEEE '실제'형식이 현재 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="fd79ad5ff3bdc8ea5cc9c7e973de1494e808a075" translate="yes" xml:space="preserve">
          <source>The following algorithm is used:</source>
          <target state="translated">다음 알고리즘이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3781d7d912eacb6b194d6abe4908fafb2e1b7d5d" translate="yes" xml:space="preserve">
          <source>The following algorithms are currently implemented:</source>
          <target state="translated">다음 알고리즘이 현재 구현되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="d55ceaf72919876c8f40561d12b134a3ea66a2f7" translate="yes" xml:space="preserve">
          <source>The following alias declarations are valid:</source>
          <target state="translated">다음과 같은 별명 선언이 유효합니다.</target>
        </trans-unit>
        <trans-unit id="3cfdc04ab915c01ce32c8d0e68bf6bc781aec0c7" translate="yes" xml:space="preserve">
          <source>The following are all embedded documentation comments:</source>
          <target state="translated">다음은 모두 포함 된 설명서 주석입니다.</target>
        </trans-unit>
        <trans-unit id="98d73aa2fbdeacfd5d17519697402797329a5e39" translate="yes" xml:space="preserve">
          <source>The following are rules of input ranges are assumed to hold true in all Phobos code. These rules are not checkable at compile-time, so not conforming to these rules when writing ranges or range based code will result in undefined behavior.</source>
          <target state="translated">다음은 모든 Phobo 코드에서 적용되는 입력 범위 규칙입니다. 이러한 규칙은 컴파일 타임에 확인할 수 없으므로 범위 나 범위 기반 코드를 작성할 때 이러한 규칙을 준수하지 않으면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="eabfe29dc68817824868f2b1cc59ea44b7368f75" translate="yes" xml:space="preserve">
          <source>The following are what the Unicode standard considers as line terminators:</source>
          <target state="translated">다음은 유니 코드 표준이 줄 종결 자로 간주하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="21052e7f487ea1e8da6a5dfd837062e0257bbb6f" translate="yes" xml:space="preserve">
          <source>The following binary operators are overloadable:</source>
          <target state="translated">다음과 같은 이진 연산자를 오버로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="85cad5d1bff24fce98bfd578ab9c72fa9869b15d" translate="yes" xml:space="preserve">
          <source>The following code compares the use of &lt;code&gt;formatValue&lt;/code&gt; and &lt;code&gt;formattedWrite&lt;/code&gt;.</source>
          <target state="translated">다음 코드는 &lt;code&gt;formatValue&lt;/code&gt; 와 &lt;code&gt;formattedWrite&lt;/code&gt; 의 사용을 비교합니다 .</target>
        </trans-unit>
        <trans-unit id="36006625c3fb62c010db1770cfe9a955d1abc844" translate="yes" xml:space="preserve">
          <source>The following code does a full unzip</source>
          <target state="translated">다음 코드는 전체 압축을 해제합니다</target>
        </trans-unit>
        <trans-unit id="707a5e8dae71e24794f64d11490781d72f147427" translate="yes" xml:space="preserve">
          <source>The following code should compile for any forward range.</source>
          <target state="translated">다음 코드는 모든 포워드 범위에 대해 컴파일해야합니다.</target>
        </trans-unit>
        <trans-unit id="b75b3b21bc4ed533a6d7d4185c0635676c150be0" translate="yes" xml:space="preserve">
          <source>The following describes the behavior of the qualified postblit definitions:</source>
          <target state="translated">다음은 규정 된 포스트 블리트 정의의 동작을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="cc1ef4d0137291a52b36237f0a56da4b9479ab3e" translate="yes" xml:space="preserve">
          <source>The following describes the specific implementation of the vector types for the X86 and X86_64 architectures.</source>
          <target state="translated">다음은 X86 및 X86_64 아키텍처에 대한 벡터 유형의 특정 구현에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="105f7db9c11f1b737bfecc2ad34e6e665b2f7c19" translate="yes" xml:space="preserve">
          <source>The following divide or modulus integral operands:</source>
          <target state="translated">다음 나누기 또는 계수 정수 피연산자 :</target>
        </trans-unit>
        <trans-unit id="f4a4096a1a2c3a608e01b521d07c483d3463c6b6" translate="yes" xml:space="preserve">
          <source>The following elements describe the locations of GC managed pointers within the memory occupied by an instance of the type. For type T, there are &lt;code&gt;T.sizeof / size_t.sizeof&lt;/code&gt; possible pointers represented by the bits of the array values.</source>
          <target state="translated">다음 요소는 유형의 인스턴스가 차지하는 메모리 내의 GC 관리 포인터의 위치를 ​​설명합니다. 타입 T 의 경우, 배열 값의 비트로 표현되는 가능한 포인터의 &lt;code&gt;T.sizeof / size_t.sizeof&lt;/code&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="64e995a24781ca67ad26542b15d464819ff2f49a" translate="yes" xml:space="preserve">
          <source>The following example shows binding of a pure virtual function, its implementation in a derived class, a non-virtual member function, and a member field:</source>
          <target state="translated">다음 예제는 순수 가상 함수 바인딩, 파생 클래스에서의 구현, 비가 상 멤버 함수 및 멤버 필드를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="7394f4cff4af73de38cdcc123f9d9cc433c49d32" translate="yes" xml:space="preserve">
          <source>The following expression must be true for &lt;code&gt;hasSlicing&lt;/code&gt; to be &lt;code&gt;true&lt;/code&gt;:</source>
          <target state="translated">에 대해 다음 식을 충족해야 &lt;code&gt;hasSlicing&lt;/code&gt; 이 될 &lt;code&gt;true&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="9182b2bc4da6786571366018715b092f896d0a9d" translate="yes" xml:space="preserve">
          <source>The following flag from DMD can be used to add a new path in which to search for frameworks:</source>
          <target state="translated">DMD의 다음 플래그를 사용하여 프레임 워크를 검색 할 새 경로를 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f255eea7299aed827ce99b1b18680817e56fa6aa" translate="yes" xml:space="preserve">
          <source>The following forms of slice expression can be convertible to a static array type:</source>
          <target state="translated">다음 형식의 슬라이스 식을 정적 배열 유형으로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b112356e7e4259c722c195a6e095476ecaa2fdb9" translate="yes" xml:space="preserve">
          <source>The following functions are publicly imported:</source>
          <target state="translated">다음 기능을 공개적으로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="37498d7cc50ed898202c2748c98849d1a32c6302" translate="yes" xml:space="preserve">
          <source>The following identifiers are defined, but are deprecated:</source>
          <target state="translated">다음 식별자가 정의되었지만 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4b758467388bb94c690cea1fb26de17875ff1787" translate="yes" xml:space="preserve">
          <source>The following information might be of help with choosing the appropriate block size. Actual allocation occurs in sizes multiple of the block size. Allocating one block is the fastest because only one 0 bit needs to be found in the metadata. Allocating 2 through 64 blocks is the next cheapest because it affects a maximum of two &lt;code&gt;ulong&lt;/code&gt; in the metadata. Allocations greater than 64 blocks require a multiword search through the metadata.</source>
          <target state="translated">다음 정보는 적절한 블록 크기를 선택하는 데 도움이 될 수 있습니다. 실제 할당은 블록 크기의 배수로 발생합니다. 메타 데이터에서 하나의 0 비트 만 찾으면되므로 하나의 블록을 할당하는 것이 가장 빠릅니다. 2-64 개의 블록을 할당하는 것이 메타 데이터에서 최대 2 개의 &lt;code&gt;ulong&lt;/code&gt; 에 영향을 미치므로 가장 저렴 합니다. 64 개보다 큰 할당에는 메타 데이터를 통한 다중 단어 검색이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="3576cbb0f30565829c9a8b467650fa45b457f446" translate="yes" xml:space="preserve">
          <source>The following is a list of important Unicode notions and definitions. Any conventions used specifically in this module alone are marked as such. The descriptions are based on the formal definition as found in &lt;a href=&quot;http://www.unicode.org/versions/Unicode6.2.0/ch03.pdf&quot;&gt; chapter three of The Unicode Standard Core Specification.&lt;/a&gt;</source>
          <target state="translated">다음은 중요한 유니 코드 개념 및 정의 목록입니다. 이 모듈에서만 사용되는 모든 규칙은 그대로 표시됩니다. 이 설명은 &lt;a href=&quot;http://www.unicode.org/versions/Unicode6.2.0/ch03.pdf&quot;&gt;The Unicode Standard Core Specification의 3 장&lt;/a&gt; 에있는 공식적인 정의를 기반으로합니다 .</target>
        </trans-unit>
        <trans-unit id="ee35f7e05bf101609042076d8164187dce2ce440" translate="yes" xml:space="preserve">
          <source>The following methods are defined if &lt;code&gt;Allocator&lt;/code&gt; defines them, and forward to it: &lt;code&gt;deallocateAll&lt;/code&gt;, &lt;code&gt;empty&lt;/code&gt;, &lt;code&gt;owns&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Allocator&lt;/code&gt; 가이를 정의하고 전달하는 경우 다음 메소드가 정의됩니다 . &lt;code&gt;deallocateAll&lt;/code&gt; , &lt;code&gt;empty&lt;/code&gt; , &lt;code&gt;owns&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="91a10c7b038d71ce23d47d4e91b5d6d57a0c0ec0" translate="yes" xml:space="preserve">
          <source>The following methods are defined if &lt;code&gt;ParentAllocator&lt;/code&gt; defines them, and forward to it: &lt;code&gt;allocateAll&lt;/code&gt;, &lt;code&gt;expand&lt;/code&gt;, &lt;code&gt;owns&lt;/code&gt;, &lt;code&gt;reallocate&lt;/code&gt;.</source>
          <target state="translated">다음 방법은 경우에 정의되어 &lt;code&gt;ParentAllocator&lt;/code&gt; 이 그것을 기대를 정의하고, : &lt;code&gt;allocateAll&lt;/code&gt; 는 , &lt;code&gt;expand&lt;/code&gt; , &lt;code&gt;owns&lt;/code&gt; , &lt;code&gt;reallocate&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="14685afb8641a641e101312bd747ad3ce716f779" translate="yes" xml:space="preserve">
          <source>The following methods are defined if &lt;code&gt;ParentAllocator&lt;/code&gt; defines them, and forward to it: &lt;code&gt;expand&lt;/code&gt;, &lt;code&gt;owns&lt;/code&gt;, &lt;code&gt;reallocate&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ParentAllocator&lt;/code&gt; 가 정의하고이를 전달하는 경우 다음 메소드가 정의됩니다 . &lt;code&gt;expand&lt;/code&gt; , &lt;code&gt;owns&lt;/code&gt; , &lt;code&gt;reallocate&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d5e999922ed0b2b38ea541add7eceec13e307896" translate="yes" xml:space="preserve">
          <source>The following methods are forwarded to the parent allocator if present: &lt;code&gt;allocateAll&lt;/code&gt;, &lt;code&gt;owns&lt;/code&gt;, &lt;code&gt;deallocateAll&lt;/code&gt;, &lt;code&gt;empty&lt;/code&gt;.</source>
          <target state="translated">다음과 같은 메소드가 존재하는 경우 상위 할당 자에게 전달됩니다 : &lt;code&gt;allocateAll&lt;/code&gt; , &lt;code&gt;owns&lt;/code&gt; , &lt;code&gt;deallocateAll&lt;/code&gt; , &lt;code&gt;empty&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="90832fc606780913417ad9424b5b78d805e2f1c9" translate="yes" xml:space="preserve">
          <source>The following must not compile:</source>
          <target state="translated">다음은 컴파일해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="151cf7cc11e7e2474415594512b78561ff78c2e4" translate="yes" xml:space="preserve">
          <source>The following op assignment operators are overloadable:</source>
          <target state="translated">다음 op 할당 연산자는 오버로드 가능합니다.</target>
        </trans-unit>
        <trans-unit id="1686f8bc7687029bb8df07eb18087ba36d800516" translate="yes" xml:space="preserve">
          <source>The following operations are not allowed in safe functions:</source>
          <target state="translated">안전 기능에서는 다음 작업이 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="74510166d7dbf32dd076c82ed552fa55a6bbe522" translate="yes" xml:space="preserve">
          <source>The following part &lt;code&gt;=&amp;gt;&lt;/code&gt;</source>
          <target state="translated">다음 부분 &lt;code&gt;=&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5f46ca3cf008a6a798269fad6d3b26dd55f13657" translate="yes" xml:space="preserve">
          <source>The following registers are supported. Register names are always in upper case.</source>
          <target state="translated">다음 레지스터가 지원됩니다. 레지스터 이름은 항상 대문자입니다.</target>
        </trans-unit>
        <trans-unit id="747c928a756931b0ee0b7f4bfca0b996d4e0288f" translate="yes" xml:space="preserve">
          <source>The following restrictions apply to class construction:</source>
          <target state="translated">수업 구성에는 다음과 같은 제한 사항이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="b257030ef10af45e49786ee89d857d61ed4e94b9" translate="yes" xml:space="preserve">
          <source>The following restrictions apply to struct construction:</source>
          <target state="translated">구조체 생성에는 다음과 같은 제한 사항이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="35dabc106beeab4a557770a611849cc8c36d5347" translate="yes" xml:space="preserve">
          <source>The following restrictions apply:</source>
          <target state="translated">다음 제한 사항이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="2f5e979077d2f3caabdbb4640da99e0c00a00749" translate="yes" xml:space="preserve">
          <source>The following steps happen:</source>
          <target state="translated">다음 단계가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="b441496fc086e7e8d354986714d6c04ebf32cc29" translate="yes" xml:space="preserve">
          <source>The following table compactly summarises the different process creation functions and how they relate to each other:</source>
          <target state="translated">다음 표는 다양한 프로세스 생성 기능과 기능 간의 관계를 간략하게 요약 한 것입니다.</target>
        </trans-unit>
        <trans-unit id="05b248b2126c26cb91a89762582c19941d257e43" translate="yes" xml:space="preserve">
          <source>The following table is a quick reference guide for which Phobos modules to use for a given category of functionality. Note that some modules may appear in more than one category, as some Phobos modules are quite generic and can be applied in a variety of situations.</source>
          <target state="translated">다음 표는 특정 기능 범주에 Phobos 모듈을 사용하기위한 빠른 참조 안내서입니다. 일부 Phobos 모듈은 매우 일반적이며 다양한 상황에 적용 할 수 있으므로 일부 모듈은 둘 이상의 범주에 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a2cf73cb06dd66656b8e69a1d451407dbc663bbe" translate="yes" xml:space="preserve">
          <source>The following table lists all the possibilities of grouping qualifiers for a postblit associated with the type of object that needs to be used in order to succesfully invoke the postblit:</source>
          <target state="translated">다음 표는 포스트 블릿을 성공적으로 호출하기 위해 사용해야하는 오브젝트 유형과 연관된 포스트 블릿에 대한 규정자를 그룹화 할 수있는 모든 가능성을 나열합니다.</target>
        </trans-unit>
        <trans-unit id="45f0025d65c3c173c7ccd0fb97c1cf0de30e0385" translate="yes" xml:space="preserve">
          <source>The following table lists all the possibilities of grouping qualifiers for a postblit associated with the type of object that needs to be used in order to successfully invoke the postblit:</source>
          <target state="translated">다음 표에는 postblit을 성공적으로 호출하기 위해 사용해야하는 객체 유형과 관련된 postblit에 대한 한정자를 그룹화 할 수있는 모든 가능성이 나열되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="824da93e42b4013db578b67b46a78528e680f556" translate="yes" xml:space="preserve">
          <source>The following transformations of floating point expressions are not allowed because under IEEE rules they could produce different results.</source>
          <target state="translated">IEEE 규칙에서 다른 결과를 생성 할 수 있으므로 다음과 같은 부동 소수점 표현식 변환은 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a206952bbb005ee76451476eb55d6acde4281a6d" translate="yes" xml:space="preserve">
          <source>The following typedef's are signatures of malloc, free, realloc, strdup and calloc respectively. Function pointers of these types can be passed to the curl_global_init_mem() function to set user defined memory management callback routines.</source>
          <target state="translated">다음 typedef는 각각 malloc, free, realloc, strdup 및 calloc의 서명입니다. 이러한 유형의 함수 포인터는 curl_global_init_mem () 함수에 전달되어 사용자 정의 메모리 관리 콜백 루틴을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6266d602387c0c2612f1f18ac8c95fc02fe3bb5d" translate="yes" xml:space="preserve">
          <source>The format &lt;code&gt;inner&lt;/code&gt; is applied the expanded &lt;code&gt;Tuple&lt;/code&gt;, so it may contain as many formats as the &lt;code&gt;Tuple&lt;/code&gt; has fields.</source>
          <target state="translated">&lt;code&gt;inner&lt;/code&gt; 형식 은 확장 된 &lt;code&gt;Tuple&lt;/code&gt; 에 적용 되므로 &lt;code&gt;Tuple&lt;/code&gt; 의 필드 수만큼 많은 형식을 포함 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d91cc2eaba6a476564c6ddbd8124208fde7d92fe" translate="yes" xml:space="preserve">
          <source>The format &lt;code&gt;inner&lt;/code&gt; is one format, that is applied on all fields of the &lt;code&gt;Tuple&lt;/code&gt;. The inner format must be compatible to all of them.</source>
          <target state="translated">포맷 &lt;code&gt;inner&lt;/code&gt; 의 모든 필드에 적용되는 하나의 포맷 인 &lt;code&gt;Tuple&lt;/code&gt; . 내부 형식은 모든 형식과 호환 가능해야합니다.</target>
        </trans-unit>
        <trans-unit id="b804a9979bb24328a2b2b5b25616b3fc268adff1" translate="yes" xml:space="preserve">
          <source>The format of the data to read.</source>
          <target state="translated">읽을 데이터의 형식입니다.</target>
        </trans-unit>
        <trans-unit id="0a7a62414c21f47b50a1e92c766dda1b08a5910c" translate="yes" xml:space="preserve">
          <source>The format of the date should follow this template:</source>
          <target state="translated">날짜 형식은 다음 템플릿을 따라야합니다.</target>
        </trans-unit>
        <trans-unit id="659e106c79a7ed685e316895f1b36b5ece514b7f" translate="yes" xml:space="preserve">
          <source>The format of the instructions is, of course, highly dependent on the native instruction set of the target CPU, and so is &lt;a href=&quot;iasm&quot;&gt;implementation defined&lt;/a&gt;. But, the format will follow the following conventions:</source>
          <target state="translated">물론 명령어의 형식은 대상 CPU의 기본 명령어 세트에 따라 크게 달라 지므로 &lt;a href=&quot;iasm&quot;&gt;구현도 정의됩니다&lt;/a&gt; . 그러나 형식은 다음 규칙을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="d00ef203b4bd1ca0d23b1201e668116dd138801d" translate="yes" xml:space="preserve">
          <source>The format of the string is purposefully unspecified, and code that cares about the format of the string should use &lt;code&gt;toISOString&lt;/code&gt;, &lt;code&gt;toISOExtString&lt;/code&gt;, &lt;code&gt;toSimpleString&lt;/code&gt;, or some other custom formatting function that explicitly generates the format that the code needs. The reason is that the code is then clear about what format it's using, making it less error-prone to maintain the code and interact with other software that consumes the generated strings. It's for this same reason &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; has no &lt;code&gt;fromString&lt;/code&gt; function, whereas it does have &lt;code&gt;fromISOString&lt;/code&gt;, &lt;code&gt;fromISOExtString&lt;/code&gt;, and &lt;code&gt;fromSimpleString&lt;/code&gt;.</source>
          <target state="translated">문자열의 형식은 의도적으로 지정되어 있지 않으며 문자열 형식을 관리하는 코드는 &lt;code&gt;toISOString&lt;/code&gt; , &lt;code&gt;toISOExtString&lt;/code&gt; , &lt;code&gt;toSimpleString&lt;/code&gt; 또는 코드에 필요한 형식을 명시 적으로 생성하는 다른 사용자 지정 형식 지정 함수를 사용해야합니다. 그 이유는 코드가 어떤 형식을 사용하고 있는지 명확하게 알 수 있기 때문에 코드를 유지 관리하고 생성 된 문자열을 사용하는 다른 소프트웨어와 상호 작용하기에 오류가 덜 발생하기 때문입니다. 같은 이유로 &lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 에는 &lt;code&gt;fromString&lt;/code&gt; 함수가 &lt;code&gt;fromISOString&lt;/code&gt; , &lt;code&gt;fromISOExtString&lt;/code&gt; 및 &lt;code&gt;fromSimpleString&lt;/code&gt; 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e82eb1994e0d2ee7e98c5b8f8c20cfd78e8b067" translate="yes" xml:space="preserve">
          <source>The format of the string is purposefully unspecified, and code that cares about the format of the string should use &lt;code&gt;toISOString&lt;/code&gt;, &lt;code&gt;toISOExtString&lt;/code&gt;, &lt;code&gt;toSimpleString&lt;/code&gt;, or some other custom formatting function that explicitly generates the format that the code needs. The reason is that the code is then clear about what format it's using, making it less error-prone to maintain the code and interact with other software that consumes the generated strings. It's for this same reason that &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; has no &lt;code&gt;fromString&lt;/code&gt; function, whereas it does have &lt;code&gt;fromISOString&lt;/code&gt;, &lt;code&gt;fromISOExtString&lt;/code&gt;, and &lt;code&gt;fromSimpleString&lt;/code&gt;.</source>
          <target state="translated">문자열의 형식은 의도적으로 지정되어 있지 않으며 문자열 형식을 관리하는 코드는 &lt;code&gt;toISOString&lt;/code&gt; , &lt;code&gt;toISOExtString&lt;/code&gt; , &lt;code&gt;toSimpleString&lt;/code&gt; 또는 코드에 필요한 형식을 명시 적으로 생성하는 다른 사용자 지정 형식 지정 함수를 사용해야합니다. 그 이유는 코드가 어떤 형식을 사용하고 있는지 명확하게 알 수 있기 때문에 코드를 유지 관리하고 생성 된 문자열을 사용하는 다른 소프트웨어와 상호 작용하기에 오류가 덜 발생하기 때문입니다. &lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 에는 &lt;code&gt;fromString&lt;/code&gt; 함수 가없는 것과 같은 이유로 &lt;code&gt;fromISOString&lt;/code&gt; , &lt;code&gt;fromISOExtString&lt;/code&gt; 및 &lt;code&gt;fromSimpleString&lt;/code&gt; 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="96cf4abaa3ec73526e49a27860bcadf20906a190" translate="yes" xml:space="preserve">
          <source>The format of the string is purposefully unspecified, and code that cares about the format of the string should use &lt;code&gt;toISOString&lt;/code&gt;, &lt;code&gt;toISOExtString&lt;/code&gt;, &lt;code&gt;toSimpleString&lt;/code&gt;, or some other custom formatting function that explicitly generates the format that the code needs. The reason is that the code is then clear about what format it's using, making it less error-prone to maintain the code and interact with other software that consumes the generated strings. It's for this same reason that &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; has no &lt;code&gt;fromString&lt;/code&gt; function, whereas it does have &lt;code&gt;fromISOString&lt;/code&gt;, &lt;code&gt;fromISOExtString&lt;/code&gt;, and &lt;code&gt;fromSimpleString&lt;/code&gt;.</source>
          <target state="translated">문자열의 형식은 의도적으로 지정되어 있지 않으며 문자열 형식을 관리하는 코드는 &lt;code&gt;toISOString&lt;/code&gt; , &lt;code&gt;toISOExtString&lt;/code&gt; , &lt;code&gt;toSimpleString&lt;/code&gt; 또는 코드에 필요한 형식을 명시 적으로 생성하는 다른 사용자 지정 형식 지정 함수를 사용해야합니다. 그 이유는 코드가 어떤 형식을 사용하고 있는지 명확하게 알 수 있기 때문에 코드를 유지 관리하고 생성 된 문자열을 사용하는 다른 소프트웨어와 상호 작용하기에 오류가 덜 발생하기 때문입니다. &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; 에는 &lt;code&gt;fromString&lt;/code&gt; 함수가 &lt;code&gt;fromISOString&lt;/code&gt; , &lt;code&gt;fromISOExtString&lt;/code&gt; 및 &lt;code&gt;fromSimpleString&lt;/code&gt; 이 같은 이유입니다 .</target>
        </trans-unit>
        <trans-unit id="02a7f64095e841cf54dadcac2f9cbc728022a8d4" translate="yes" xml:space="preserve">
          <source>The format of the string is purposefully unspecified, and code that cares about the format of the string should use &lt;code&gt;toISOString&lt;/code&gt;, &lt;code&gt;toISOExtString&lt;/code&gt;, or some other custom formatting function that explicitly generates the format that the code needs. The reason is that the code is then clear about what format it's using, making it less error-prone to maintain the code and interact with other software that consumes the generated strings. It's for this same reason that &lt;a href=&quot;#TimeOfDay&quot;&gt;&lt;code&gt;TimeOfDay&lt;/code&gt;&lt;/a&gt; has no &lt;code&gt;fromString&lt;/code&gt; function, whereas it does have &lt;code&gt;fromISOString&lt;/code&gt; and &lt;code&gt;fromISOExtString&lt;/code&gt;.</source>
          <target state="translated">문자열의 형식은 의도적으로 지정되어 있지 않으며 문자열 형식을 관리하는 코드는 &lt;code&gt;toISOString&lt;/code&gt; , &lt;code&gt;toISOExtString&lt;/code&gt; 또는 코드에 필요한 형식을 명시 적으로 생성하는 다른 사용자 지정 형식 지정 함수를 사용해야합니다. 그 이유는 코드가 어떤 형식을 사용하고 있는지 명확하게 알 수 있기 때문에 코드를 유지 관리하고 생성 된 문자열을 사용하는 다른 소프트웨어와 상호 작용하기에 오류가 덜 발생하기 때문입니다. 같은 이유로 &lt;a href=&quot;#TimeOfDay&quot;&gt; &lt;code&gt;TimeOfDay&lt;/code&gt; &lt;/a&gt; 에는 &lt;code&gt;fromString&lt;/code&gt; 함수 가없고 &lt;code&gt;fromISOString&lt;/code&gt; 및 &lt;code&gt;fromISOExtString&lt;/code&gt; 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ffca9618faa656329893915994f22e9af2d88357" translate="yes" xml:space="preserve">
          <source>The format returned by toString may or may not change in the future.</source>
          <target state="translated">toString에 의해 반환되는 형식은 나중에 변경 될 수도 있고 변경되지 않을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="03b68c7b67ac69b6f5b3f857c44f365ee971e450" translate="yes" xml:space="preserve">
          <source>The format specifier contained a &lt;code&gt;' '&lt;/code&gt; (&lt;code&gt;printf&lt;/code&gt; compatibility).</source>
          <target state="translated">형식 지정자에는 &lt;code&gt;' '&lt;/code&gt; ( &lt;code&gt;printf&lt;/code&gt; 호환성)가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="f06eba7969af19af6a609393b286c72694c125a1" translate="yes" xml:space="preserve">
          <source>The format specifier contained a &lt;code&gt;'#'&lt;/code&gt; (&lt;code&gt;printf&lt;/code&gt; compatibility).</source>
          <target state="translated">형식 지정자에는 &lt;code&gt;'#'&lt;/code&gt; ( &lt;code&gt;printf&lt;/code&gt; 호환성)이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="2b3efef6165630dae7b0c5941cb57f0ff6fb2723" translate="yes" xml:space="preserve">
          <source>The format specifier contained a &lt;code&gt;'+'&lt;/code&gt; (&lt;code&gt;printf&lt;/code&gt; compatibility).</source>
          <target state="translated">형식 지정자에는 &lt;code&gt;'+'&lt;/code&gt; ( &lt;code&gt;printf&lt;/code&gt; 호환성)가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="6460ee5bc9ce27cd4f9cfd713bf8f2494817b14f" translate="yes" xml:space="preserve">
          <source>The format specifier contained a &lt;code&gt;','&lt;/code&gt;</source>
          <target state="translated">형식 지정자에는 &lt;code&gt;','&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="962882364923635b105d5f54d8d7565b59680ac3" translate="yes" xml:space="preserve">
          <source>The format specifier contained a &lt;code&gt;'-'&lt;/code&gt; (&lt;code&gt;printf&lt;/code&gt; compatibility).</source>
          <target state="translated">형식 지정자에는 &lt;code&gt;'-'&lt;/code&gt; ( &lt;code&gt;printf&lt;/code&gt; 호환성)가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="d34bdd42fd319223df703e24b238ea323c66c17e" translate="yes" xml:space="preserve">
          <source>The format specifier contained a &lt;code&gt;'0'&lt;/code&gt; (&lt;code&gt;printf&lt;/code&gt; compatibility).</source>
          <target state="translated">형식 지정자에는 &lt;code&gt;'0'&lt;/code&gt; ( &lt;code&gt;printf&lt;/code&gt; 호환성)이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e47d83ed9645d662de3546c090652b44c5fa2bb" translate="yes" xml:space="preserve">
          <source>The format string can be checked at compile-time (see &lt;a href=&quot;#format&quot;&gt;&lt;code&gt;format&lt;/code&gt;&lt;/a&gt; for details):</source>
          <target state="translated">형식 문자열은 컴파일 타임에 확인할 수 있습니다 (자세한 내용은 &lt;a href=&quot;#format&quot;&gt; &lt;code&gt;format&lt;/code&gt; &lt;/a&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="bd749ebde47823b6d49d60691dec84566b639bf8" translate="yes" xml:space="preserve">
          <source>The format string can reference parts of match using the following notation.</source>
          <target state="translated">형식 문자열은 다음 표기법을 사용하여 일치하는 부분을 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d3aec5d983c44f1af503ee811b2266d3dca8cd3" translate="yes" xml:space="preserve">
          <source>The format string has the following grammar:</source>
          <target state="translated">형식 문자열에는 다음과 같은 문법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="0625c7ec1018d088678495be9b57d04b31498a03" translate="yes" xml:space="preserve">
          <source>The format string supports the formatting of array and nested array elements via the grouping format specifiers &lt;b&gt;%(&lt;/b&gt; and &lt;b&gt;%)&lt;/b&gt;. Each matching pair of &lt;b&gt;%(&lt;/b&gt; and &lt;b&gt;%)&lt;/b&gt; corresponds with a single array argument. The enclosed sub-format string is applied to individual array elements. The trailing portion of the sub-format string following the conversion specifier for the array element is interpreted as the array delimiter, and is therefore omitted following the last array element. The &lt;b&gt;%|&lt;/b&gt; specifier may be used to explicitly indicate the start of the delimiter, so that the preceding portion of the string will be included following the last array element. (See below for explicit examples.)</source>
          <target state="translated">형식화 문자열은 그룹화 형식 지정자 &lt;b&gt;% (&lt;/b&gt; 및 &lt;b&gt;%)&lt;/b&gt; 를 통해 배열 및 중첩 배열 요소의 형식화를 지원합니다 . &lt;b&gt;% (&lt;/b&gt; 와 &lt;b&gt;%)&lt;/b&gt; 의 각 일치 쌍은 단일 배열 인수에 해당합니다. 동봉 된 하위 형식 문자열은 개별 배열 요소에 적용됩니다. 배열 요소의 변환 지정자 다음에 오는 하위 형식 문자열의 후미 부분은 배열 구분 기호로 해석되므로 마지막 배열 요소 다음에는 생략됩니다. &lt;b&gt;% | &lt;/b&gt;지정자는 구분 기호의 시작을 명시 적으로 표시하는 데 사용될 수 있으므로 문자열의 앞 부분이 마지막 배열 요소 다음에 포함됩니다. (명시적인 예는 아래를 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="693a71e5dd0ab926d97018418f98a27b3e174029" translate="yes" xml:space="preserve">
          <source>The format string used for this log call.</source>
          <target state="translated">이 로그 호출에 사용되는 형식 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="9fa2fc4abd1b83aca1055ee06f982cdb131c59e5" translate="yes" xml:space="preserve">
          <source>The formatting flag is applied individually to each value, for example:</source>
          <target state="translated">형식 플래그는 다음과 같이 각 값에 개별적으로 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="d26ac44ffe5a86909c11c81e0ef71d3888da5c4c" translate="yes" xml:space="preserve">
          <source>The forms of the</source>
          <target state="translated">의 형태</target>
        </trans-unit>
        <trans-unit id="38e88fa7315be494a88a395eb056b9ace726e37c" translate="yes" xml:space="preserve">
          <source>The four character array with the Soundex result in it. Returns null if there is no Soundex representation for the string.</source>
          <target state="translated">Soundex를 사용한 4 개의 문자 배열이 결과입니다. 문자열에 대한 Soundex 표현이 없으면 null을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0480c3df77ed33fc07e614d2d8de8fc045910624" translate="yes" xml:space="preserve">
          <source>The four character array with the Soundex result in it. The array has zero's in it if there is no Soundex representation for the string.</source>
          <target state="translated">Soundex를 사용한 4 개의 문자 배열이 결과입니다. 문자열에 대한 Soundex 표현이없는 경우 배열에 0이 있습니다.</target>
        </trans-unit>
        <trans-unit id="5766013bffb3825b0abbe1d083667aa11616b979" translate="yes" xml:space="preserve">
          <source>The fourth form, &lt;code&gt;goto case&lt;/code&gt;&lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;Expression&lt;/i&gt;&lt;/a&gt;&lt;code&gt;;&lt;/code&gt;, transfers to the &lt;a href=&quot;#CaseStatement&quot;&gt;&lt;i&gt;CaseStatement&lt;/i&gt;&lt;/a&gt; of the innermost enclosing &lt;a href=&quot;#SwitchStatement&quot;&gt;&lt;i&gt;SwitchStatement&lt;/i&gt;&lt;/a&gt; with a matching &lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;Expression&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">네 번째 형태 인 &lt;code&gt;goto case&lt;/code&gt; &lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;Expression&lt;/i&gt;&lt;/a&gt; &lt;code&gt;;&lt;/code&gt; , 일치하는 &lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;Expression&lt;/i&gt;&lt;/a&gt; 을 사용하여 가장 안쪽에있는 &lt;a href=&quot;#SwitchStatement&quot;&gt;&lt;i&gt;SwitchStatement&lt;/i&gt;&lt;/a&gt; 의 &lt;a href=&quot;#CaseStatement&quot;&gt;&lt;i&gt;CaseStatement&lt;/i&gt;&lt;/a&gt; 로 전송합니다 .&lt;i&gt;&lt;/i&gt;&lt;i&gt;&lt;/i&gt;</target>
        </trans-unit>
        <trans-unit id="13efbc5e672643becc355867b63d8f22b9e474d7" translate="yes" xml:space="preserve">
          <source>The fourth version counts the number of elements in a range. It is an optimization for the third version: if the given range has the &lt;code&gt;length&lt;/code&gt; property the count is returned right away, otherwise performs &amp;Omicron;(&lt;code&gt;haystack.length&lt;/code&gt;) to walk the range.</source>
          <target state="translated">네 번째 버전은 범위 내의 요소 수를 계산합니다. 주어진 범위에 &lt;code&gt;length&lt;/code&gt; 속성 이 있으면 카운트가 즉시 반환되고, 그렇지 않으면 &amp;Omicron; ( &lt;code&gt;haystack.length&lt;/code&gt; )를 수행 하여 범위를 걷습니다.</target>
        </trans-unit>
        <trans-unit id="48edc0798b06f223cb1ddbda6fdb31f83f4e14ab" translate="yes" xml:space="preserve">
          <source>The fractional part of x.</source>
          <target state="translated">x의 소수 부분.</target>
        </trans-unit>
        <trans-unit id="afaeb9378608c5260a3259e8f02e82dbd938d6f1" translate="yes" xml:space="preserve">
          <source>The fractional seconds portion of the time.</source>
          <target state="translated">시간의 소수 초입니다.</target>
        </trans-unit>
        <trans-unit id="a033f1a65da2c07804aca3b53ca406684bb91d81" translate="yes" xml:space="preserve">
          <source>The free list is circular, with the last node pointing back to the first.</source>
          <target state="translated">자유 목록은 원형이며 마지막 노드는 첫 번째 노드를 다시 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="c4517bc5d244bf2185e9745bb334e09ef6af1ee0" translate="yes" xml:space="preserve">
          <source>The free tree has special handling of duplicates (a singly-linked list per node) in anticipation of large number of duplicates. Allocation time from the free tree is expected to be &amp;Omicron;(&lt;code&gt;log n&lt;/code&gt;) where &lt;code&gt;n&lt;/code&gt; is the number of distinct sizes (not total nodes) kept in the free tree.</source>
          <target state="translated">사용 가능한 트리에는 많은 수의 중복을 예상하여 중복 (노드 당 단일 연결 목록)에 대한 특수 처리가 있습니다. 사용 가능한 트리에서 할당 시간은 &amp;Omicron; ( &lt;code&gt;log n&lt;/code&gt; ) 이어야합니다. 여기서 &lt;code&gt;n&lt;/code&gt; 은 사용 가능한 트리에 보관 된 고유 한 크기 (총 노드 아님)의 수입니다.</target>
        </trans-unit>
        <trans-unit id="ee4d09c6e55b89fcf5b3563176298a96aa717ff4" translate="yes" xml:space="preserve">
          <source>The freelist is maintained in increasing address order, which makes coalescing easy.</source>
          <target state="translated">프리리스트는 증가하는 주소 순서로 유지되므로 통합이 쉬워집니다.</target>
        </trans-unit>
        <trans-unit id="8fea8f11f99f1f8b366c244a4de1a614fd67b29c" translate="yes" xml:space="preserve">
          <source>The front element in the container</source>
          <target state="translated">컨테이너의 앞면 요소</target>
        </trans-unit>
        <trans-unit id="13da137fb2ab48bf4928214ec4fc5ac7d9dd7e0b" translate="yes" xml:space="preserve">
          <source>The full URL to get/put</source>
          <target state="translated">가져 오거나 넣을 전체 URL</target>
        </trans-unit>
        <trans-unit id="bdda625bfb1430028e4b6006d0968612c21121d6" translate="yes" xml:space="preserve">
          <source>The full list of named character entities from the &lt;a href=&quot;https://w3.org/TR/html5/syntax.html#named-character-references&quot;&gt;HTML 5 Spec&lt;/a&gt; is supported except for the named entities which contain multiple code points. Below is a</source>
          <target state="translated">여러 코드 포인트를 포함하는 명명 된 엔터티를 제외하고 &lt;a href=&quot;https://w3.org/TR/html5/syntax.html#named-character-references&quot;&gt;HTML 5 사양&lt;/a&gt; 의 명명 된 문자 엔터티 전체 목록 이 지원됩니다. 아래는</target>
        </trans-unit>
        <trans-unit id="53abcf6f821b2e7ec7e516af58f09e5bd8d1aff5" translate="yes" xml:space="preserve">
          <source>The full module system</source>
          <target state="translated">전체 모듈 시스템</target>
        </trans-unit>
        <trans-unit id="ee63124c4c066661e689e48b06ebee05399673e5" translate="yes" xml:space="preserve">
          <source>The fully qualified name of the symbol.</source>
          <target state="translated">정규화 된 기호 이름입니다.</target>
        </trans-unit>
        <trans-unit id="4d00150ca0468a4f7743a4f3a38c13aec942337c" translate="yes" xml:space="preserve">
          <source>The fully-qualified names of both types if the two type names are not the same, or the unqualified names of both types if the two type names are the same.</source>
          <target state="translated">두 유형 이름이 동일하지 않은 경우 두 유형의 완전한 이름이거나 두 유형 이름이 동일한 경우 두 유형의 규정되지 않은 이름입니다.</target>
        </trans-unit>
        <trans-unit id="38a1580a58c3012db59e4a8a700c45c0c6b1674d" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;fd&lt;/code&gt; is added to the nested references of the newly created variable such that a closure is made for the variable when the address of &lt;code&gt;fd&lt;/code&gt; is taken.</source>
          <target state="translated">함수 &lt;code&gt;fd&lt;/code&gt; 주소가 폐쇄 될 때 가변 만들어 지도록 새롭게 생성 된 변수의 중첩 된 참조에 첨가 &lt;code&gt;fd&lt;/code&gt; 취해진 다.</target>
        </trans-unit>
        <trans-unit id="1bc8d00dffc62265a3b988178c4153a69f61f3ec" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;remove&lt;/code&gt; works on bidirectional ranges that have assignable lvalue elements. The moving strategy is (listed from fastest to slowest):</source>
          <target state="translated">&lt;code&gt;remove&lt;/code&gt; 기능 은 할당 가능한 lvalue 요소가있는 양방향 범위에서 작동합니다. 이동 전략은 다음과 같습니다 (가장 빠름에서 느림).</target>
        </trans-unit>
        <trans-unit id="dfdecb6a33548c2c3a57ed9788619ffcbcd64fcd" translate="yes" xml:space="preserve">
          <source>The function allocates memory if and only if it gets to the third stage of this algorithm.</source>
          <target state="translated">이 알고리즘의 세 번째 단계에 도달하는 경우에만 함수가 메모리를 할당합니다.</target>
        </trans-unit>
        <trans-unit id="59d7ef7bccfe8628462077a719a53074c919f8fa" translate="yes" xml:space="preserve">
          <source>The function call operator, &lt;code&gt;()&lt;/code&gt;, can be overloaded by declaring a function named &lt;code&gt;opCall&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;opCall&lt;/code&gt; 이라는 함수를 선언하면 함수 호출 연산자 &lt;code&gt;()&lt;/code&gt; 가 오버로드 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="75414fa30a8eeadba0f9df43d9a81faffe1eb302" translate="yes" xml:space="preserve">
          <source>The function declaration makes it clear what the inputs and outputs to the function are.</source>
          <target state="translated">함수 선언은 함수의 입력과 출력이 무엇인지 명확하게합니다.</target>
        </trans-unit>
        <trans-unit id="36bd72a87a6fb51210593d16c9d3850d26ad2813" translate="yes" xml:space="preserve">
          <source>The function generated tests if the &lt;a href=&quot;#Code%20point&quot;&gt;code point&lt;/a&gt; passed belongs to this set or not. The result is to be used with string mixin. The intended usage area is aggressive optimization via meta programming in parser generators and the like.</source>
          <target state="translated">함수는 전달 된 &lt;a href=&quot;#Code%20point&quot;&gt;코드 포인트&lt;/a&gt; 가이 세트에 속 하는지 테스트합니다 . 결과는 문자열 믹스 인과 함께 사용됩니다. 의도 된 사용 영역은 파서 생성기 등에서의 메타 프로그래밍을 통한 적극적인 최적화이다.</target>
        </trans-unit>
        <trans-unit id="98e31cd639a66b786829a51b07b196c9eb02f441" translate="yes" xml:space="preserve">
          <source>The function is doing something impure, so mark it as impure. If there's a purity error, return true.</source>
          <target state="translated">함수가 불완전한 작업을 수행하고 있으므로 불완전한 것으로 표시하십시오. 순도 오류가 있으면 true를 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="78716a8e02a777fde55cd9f5bd9506b86f2cd433" translate="yes" xml:space="preserve">
          <source>The function is doing something that may allocate with the GC, so mark it as not nogc (not no-how).</source>
          <target state="translated">함수가 GC에 할당 할 수있는 작업을 수행하고 있으므로 nogc가 아닌 것으로 표시하십시오 (노하우 아님).</target>
        </trans-unit>
        <trans-unit id="1582435911618910fd1cebd4a56e5bade73d2f42" translate="yes" xml:space="preserve">
          <source>The function is doing something unsafe, so mark it as unsafe. If there's a safe error, return true.</source>
          <target state="translated">함수가 안전하지 않은 작업을 수행하고 있으므로 안전하지 않은 것으로 표시하십시오. 안전한 오류가 있으면 true를 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="185793595bc4f7b5898c63f905d91abe291e2c5e" translate="yes" xml:space="preserve">
          <source>The function is explicitly annotated &lt;code&gt;@nogc&lt;/code&gt; because inference could fail, see &lt;a href=&quot;https://issues.dlang.org/show_bug.cgi?id=17084&quot;&gt;issue 17084&lt;/a&gt;.</source>
          <target state="translated">이 함수는 추론이 실패 할 수 있기 때문에 &lt;code&gt;@nogc&lt;/code&gt; 에 명시 적으로 주석이 달려 있습니다 ( &lt;a href=&quot;https://issues.dlang.org/show_bug.cgi?id=17084&quot;&gt;문제 17084&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="94377b90d447230e8a5ccf1a52d33d616f20136c" translate="yes" xml:space="preserve">
          <source>The function is intended to replace the hexadecimal literal strings starting with &lt;code&gt;'x'&lt;/code&gt;, which could be removed to simplify the core language.</source>
          <target state="translated">이 함수는 핵심 언어를 단순화하기 위해 제거 할 수있는 &lt;code&gt;'x'&lt;/code&gt; 로 시작하는 16 진 리터럴 문자열을 대체하기위한 것 입니다.</target>
        </trans-unit>
        <trans-unit id="408608d2bfc199a6a551d83606a62872252fdf6d" translate="yes" xml:space="preserve">
          <source>The function overloads returning a string allocate their return values using the GC. The versions returning static arrays use pass-by-value for the return value, effectively avoiding dynamic allocation.</source>
          <target state="translated">문자열을 반환하는 함수 오버로드는 GC를 사용하여 반환 값을 할당합니다. 정적 배열을 반환하는 버전은 동적 할당을 효과적으로 피하면서 반환 값에 값별 패스를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="7b0e25cbd51eccc8cf3fde77bb9a906902973f49" translate="yes" xml:space="preserve">
          <source>The function parameter attributes &lt;code&gt;return&lt;/code&gt; and &lt;code&gt;scope&lt;/code&gt; are used to track what happens to low-level pointers passed to functions. Such pointers include: raw pointers, arrays, &lt;code&gt;this&lt;/code&gt;, classes, &lt;code&gt;ref&lt;/code&gt; parameters, delegate/lazy parameters, and aggregates containing a pointer.</source>
          <target state="translated">함수 매개 변수 속성 &lt;code&gt;return&lt;/code&gt; 및 &lt;code&gt;scope&lt;/code&gt; 는 함수에 전달 된 하위 레벨 포인터에서 발생하는 상황을 추적하는 데 사용됩니다. 이러한 포인터에는 원시 포인터, 배열, &lt;code&gt;this&lt;/code&gt; , 클래스, &lt;code&gt;ref&lt;/code&gt; 매개 변수, 대리자 / 지연 매개 변수 및 포인터가 포함 된 집계가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="6e994bfc1a839ed290d4129f0f5733e981d5373e" translate="yes" xml:space="preserve">
          <source>The function returns a range containing the consecutive reduced values. If there is more than one &lt;code&gt;fun&lt;/code&gt;, the element type will be &lt;a href=&quot;std_typecons#Tuple&quot;&gt;&lt;code&gt; std.typecons.Tuple&lt;/code&gt;&lt;/a&gt; containing one element for each &lt;code&gt;fun&lt;/code&gt;.</source>
          <target state="translated">이 함수는 연속 감소 값이 포함 된 범위를 반환합니다. &lt;code&gt;fun&lt;/code&gt; 이 하나 이상인 경우 요소 유형은 &lt;a href=&quot;std_typecons#Tuple&quot;&gt; &lt;code&gt; std.typecons.Tuple&lt;/code&gt; &lt;/a&gt; 로 각 &lt;code&gt;fun&lt;/code&gt; 에 대해 하나의 요소를 포함 합니다.</target>
        </trans-unit>
        <trans-unit id="f1de9581bb40aa0605e1d4f2b900b32c62cf6dcb" translate="yes" xml:space="preserve">
          <source>The function returns immediately, leaving the child process to execute in parallel with its parent. It is recommended to always call &lt;a href=&quot;#wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; on the returned &lt;a href=&quot;#Pid&quot;&gt;&lt;code&gt;Pid&lt;/code&gt;&lt;/a&gt; unless the process was spawned with &lt;code&gt;Config.detached&lt;/code&gt; flag, as detailed in the documentation for &lt;code&gt;wait&lt;/code&gt;.</source>
          <target state="translated">이 함수는 즉시 반환되어 자식 프로세스가 부모 프로세스와 병렬로 실행되도록합니다. 그것은 항상 호출에 추천 &lt;a href=&quot;#wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; 반환에 &lt;a href=&quot;#Pid&quot;&gt; &lt;code&gt;Pid&lt;/code&gt; &lt;/a&gt; 프로세스로 양산하지 않는 한 &lt;code&gt;Config.detached&lt;/code&gt; 플래그에 대한 설명서에 따라 &lt;code&gt;wait&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d1462ec35dc456ac6ff3045ecdc8148b89412c36" translate="yes" xml:space="preserve">
          <source>The function source code must be available to the compiler. Functions which exist in the source code only as extern declarations cannot be executed in CTFE.</source>
          <target state="translated">함수 소스 코드는 컴파일러에서 사용할 수 있어야합니다. 소스 코드에 extern 선언으로 만 존재하는 함수는 CTFE에서 실행할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c99c9ccaa6aadf1ddb21d118ac9a2b39a2936c1d" translate="yes" xml:space="preserve">
          <source>The function that wants to measure speed.</source>
          <target state="translated">속도를 측정하려는 기능입니다.</target>
        </trans-unit>
        <trans-unit id="411ac38391245e7bd9f2d61489a0679e909d3705" translate="yes" xml:space="preserve">
          <source>The function to become the base of the speed.</source>
          <target state="translated">속도의 기초가되는 기능.</target>
        </trans-unit>
        <trans-unit id="ca30c519a6a156f76c6573e841573612bc2aad51" translate="yes" xml:space="preserve">
          <source>The function to execute.</source>
          <target state="translated">실행할 함수입니다.</target>
        </trans-unit>
        <trans-unit id="38560d673ec14174a5201f65e942b10ff886f6eb" translate="yes" xml:space="preserve">
          <source>The function to execute. This may be the actual function passed by the user to spawn itself, or may be a wrapper function.</source>
          <target state="translated">실행할 함수입니다. 이것은 사용자가 자신을 스폰하기 위해 전달한 실제 함수이거나 래퍼 함수일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="67a64604c4717ec6e34e3f3a6e53ee63c3039ae1" translate="yes" xml:space="preserve">
          <source>The function used to check if &lt;code&gt;addr&lt;/code&gt; is marked.</source>
          <target state="translated">&lt;code&gt;addr&lt;/code&gt; 가 표시되어 있는지 확인하는 데 사용되는 기능 입니다.</target>
        </trans-unit>
        <trans-unit id="a4a8105c562ae246a8ce7c12b0a3320ba9511dc7" translate="yes" xml:space="preserve">
          <source>The function used to generate the next time point in the range.</source>
          <target state="translated">범위에서 다음 시점을 생성하는 데 사용되는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="dc715bdc2551fef5137debdc9a1fe82c19568021" translate="yes" xml:space="preserve">
          <source>The function used to generate the time points of the range over the interval.</source>
          <target state="translated">간격에 걸쳐 범위의 시점을 생성하는 데 사용되는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="f3d2158936e817ae5d4b5a34d016e49a32ca1146" translate="yes" xml:space="preserve">
          <source>The function will not return if any enclosing finally clause does a return, goto or throw that exits the finally clause.</source>
          <target state="translated">엔 클로징 finally 절이 finally 절을 종료하는 return, goto 또는 throw를 수행하면 함수가 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="46f3e02eaaa99bc9ca72c46c606ddf965d307189" translate="yes" xml:space="preserve">
          <source>The functionality closely follows the IEEE754-2008 standard for floating-point arithmetic, including the use of camelCase names rather than C99-style lower case names. All of these functions behave correctly when presented with an infinity or NaN.</source>
          <target state="translated">이 기능은 C99 스타일의 소문자 이름이 아닌 카멜 케이스 이름 사용을 포함하여 부동 소수점 산술에 대한 IEEE754-2008 표준을 밀접하게 따릅니다. 이러한 기능은 모두 무한대 또는 NaN으로 표시 될 때 올바르게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="a8b49dde8278905e1da61afa2345291851916bc1" translate="yes" xml:space="preserve">
          <source>The functionally is based on &lt;a href=&quot;http://curl.haxx.se/libcurl&quot;&gt;libcurl&lt;/a&gt;. LibCurl is licensed under an MIT/X derivative license.</source>
          <target state="translated">기능적으로는 &lt;a href=&quot;http://curl.haxx.se/libcurl&quot;&gt;libcurl을&lt;/a&gt; 기반으로 합니다. LibCurl은 MIT / X 파생 라이센스에 따라 라이센스가 부여됩니다.</target>
        </trans-unit>
        <trans-unit id="4e9193abd91f293a360c49af75182f625a029338" translate="yes" xml:space="preserve">
          <source>The functions &lt;a href=&quot;#formatValue&quot;&gt;&lt;code&gt;formatValue&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#unformatValue&quot;&gt;&lt;code&gt;unformatValue&lt;/code&gt;&lt;/a&gt; are used for the plumbing.</source>
          <target state="translated">&lt;a href=&quot;#formatValue&quot;&gt; &lt;code&gt;formatValue&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#unformatValue&quot;&gt; &lt;code&gt;unformatValue&lt;/code&gt; &lt;/a&gt; 함수 는 배관에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="09d84b61f63134826318f5b038f0d9e7c6a89164" translate="yes" xml:space="preserve">
          <source>The functions &lt;a href=&quot;#multiwayMerge&quot;&gt;&lt;code&gt;multiwayMerge&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#multiwayUnion&quot;&gt;&lt;code&gt;multiwayUnion&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#setDifference&quot;&gt;&lt;code&gt;setDifference&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#setIntersection&quot;&gt;&lt;code&gt;setIntersection&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#setSymmetricDifference&quot;&gt;&lt;code&gt;setSymmetricDifference&lt;/code&gt;&lt;/a&gt; expect a range of sorted ranges as input.</source>
          <target state="translated">기능은 &lt;a href=&quot;#multiwayMerge&quot;&gt; &lt;code&gt;multiwayMerge&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#multiwayUnion&quot;&gt; &lt;code&gt;multiwayUnion&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#setDifference&quot;&gt; &lt;code&gt;setDifference&lt;/code&gt; 는&lt;/a&gt; , &lt;a href=&quot;#setIntersection&quot;&gt; &lt;code&gt;setIntersection&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#setSymmetricDifference&quot;&gt; &lt;code&gt;setSymmetricDifference&lt;/code&gt; 는&lt;/a&gt; 입력으로 정렬 범위의 범위를 기대한다.</target>
        </trans-unit>
        <trans-unit id="4fde7de03cdc04e15dde2a51577db6987e675d9f" translate="yes" xml:space="preserve">
          <source>The functions can use &lt;code&gt;@trusted&lt;/code&gt; instead of &lt;code&gt;@safe&lt;/code&gt;.</source>
          <target state="translated">기능을 사용할 수 있습니다 &lt;code&gt;@trusted&lt;/code&gt; 대신 &lt;code&gt;@safe&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="30a160975f83d4201f4fd65daf1113007bc807be" translate="yes" xml:space="preserve">
          <source>The gamma and related functions, and the error function are crucial for mathematical statistics. The Bessel and related functions arise in problems involving wave propagation (especially in optics). Other major categories of special functions include the elliptic integrals (related to the arc length of an ellipse), and the hypergeometric functions.</source>
          <target state="translated">감마 및 관련 함수와 오류 함수는 수학 통계에 중요합니다. 베셀 및 관련 기능은 웨이브 전파와 관련된 문제 (특히 광학 분야)에서 발생합니다. 특수 함수의 다른 주요 범주에는 타원 적분 (타원의 호 길이와 관련) 및 초기 하 함수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="447281d1324337b15482dcfc848c6a78d28256cf" translate="yes" xml:space="preserve">
          <source>The gapped similarity at the current match length (initially 1, grows with each call to &lt;code&gt;popFront&lt;/code&gt;).</source>
          <target state="translated">현재 일치 길이에서의 갭 유사성 (처음에는 1, &lt;code&gt;popFront&lt;/code&gt; 에 대한 호출마다 증가 )</target>
        </trans-unit>
        <trans-unit id="05176e7bf5bf611688f908ea258370d40d6b3039" translate="yes" xml:space="preserve">
          <source>The garbage collector calls the destructor function when the object is deleted. The syntax is:</source>
          <target state="translated">가비지 콜렉터는 오브젝트가 삭제 될 때 소멸자 함수를 호출합니다. 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8162594fc1e13b54530b98ac255177e2a9d2ab78" translate="yes" xml:space="preserve">
          <source>The garbage collector does not scan non-pointer fields for GC pointers.</source>
          <target state="translated">가비지 수집기는 포인터가 아닌 필드에서 GC 포인터를 검색하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bace0715c82c9b149257399e18cc90537b20fbf1" translate="yes" xml:space="preserve">
          <source>The garbage collector does not scan the stacks of threads not created by the D Thread interface. Nor does it scan the data segments of other DLLs, etc.</source>
          <target state="translated">가비지 콜렉터는 D 스레드 인터페이스로 작성되지 않은 스레드 스택을 스캔하지 않습니다. 다른 DLL 등의 데이터 세그먼트도 스캔하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="679912e5f590d3f8f03034fbcabdaff8e29c8cba" translate="yes" xml:space="preserve">
          <source>The garbage collector does not scan the stacks of threads not registered with the D runtime, nor does it scan the data segments of shared libraries that aren't registered with the D runtime.</source>
          <target state="translated">가비지 수집기는 D 런타임에 등록되지 않은 스레드 스택을 검색하지 않으며 D 런타임에 등록되지 않은 공유 라이브러리의 데이터 세그먼트를 검색하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="248f5f617e65210251e2aceaf897cfac6784a5ad" translate="yes" xml:space="preserve">
          <source>The garbage collector is not guaranteed to run the destructor for all unreferenced objects. Furthermore, the order in which the garbage collector calls destructors for unreferenced objects is not specified. This means that when the garbage collector calls a destructor for an object of a class that has members which are references to garbage collected objects, those references may no longer be valid. This means that destructors cannot reference sub objects. This rule does not apply to auto objects or objects destructed with &lt;a href=&quot;https://dlang.org/phobos/object.html#destroy&quot;&gt;&lt;code&gt;destroy&lt;/code&gt;&lt;/a&gt;, as the destructor is not being run by the garbage collector, meaning all references are valid.</source>
          <target state="translated">가비지 수집기는 참조되지 않은 모든 객체에 대해 소멸자를 실행한다고 보장하지는 않습니다. 또한 가비지 수집기가 참조되지 않은 객체에 대한 소멸자를 호출하는 순서는 지정되지 않습니다. 이것은 가비지 수집기가 가비지 수집 된 객체에 대한 참조 인 멤버가있는 클래스의 객체에 대한 소멸자를 호출 할 때 해당 참조가 더 이상 유효하지 않을 수 있음을 의미합니다. 이는 소멸자가 하위 오브젝트를 참조 할 수 없음을 의미합니다. 가비지 수집기가 소멸자를 실행 하지 않으므로 자동 참조 또는 &lt;a href=&quot;https://dlang.org/phobos/object.html#destroy&quot;&gt; &lt;code&gt;destroy&lt;/code&gt; 로&lt;/a&gt; 소멸 된 객체에는이 규칙이 적용되지 않으므로 모든 참조가 유효합니다.</target>
        </trans-unit>
        <trans-unit id="7ed0a2988d2028482af5b70f4886f714e874cd68" translate="yes" xml:space="preserve">
          <source>The garbage collector looks for roots in:</source>
          <target state="translated">가비지 수집기는 다음에서 루트를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="a61608c994e8531817d927f16b69cb4ec2652687" translate="yes" xml:space="preserve">
          <source>The general usage guideline is to keep regex complexity on the side of simplicity, as its capabilities reside in purely character-level manipulation. As such it's ill-suited for tasks involving higher level invariants like matching an integer number &lt;em&gt;bounded&lt;/em&gt; in an [a,b] interval. Checks of this sort of are better addressed by additional post-processing.</source>
          <target state="translated">일반적인 사용법 지침은 정규식의 복잡성을 단순성 측면에서 유지하는 것인데, 그 기능은 순전히 문자 수준 조작에 있기 때문입니다. 따라서 [a, b] 간격으로 &lt;em&gt;경계를 정하는&lt;/em&gt; 정수와 일치하는 것과 같이 더 높은 수준의 불변 값을 포함하는 작업에는 적합하지 않습니다 . 이러한 종류의 검사는 추가 사후 처리로 해결하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="587ae2153e1cd24d01fed6ce88e2ec32ff8c2014" translate="yes" xml:space="preserve">
          <source>The generated &lt;code&gt;opAssign&lt;/code&gt; function has the following signature:</source>
          <target state="translated">생성 된 &lt;code&gt;opAssign&lt;/code&gt; 함수에는 다음과 같은 서명이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e40de6a32624f7e6b5379975d2cd46fa3f2fa94f" translate="yes" xml:space="preserve">
          <source>The generated links to D symbols are relative if they have the same root package as the module being documented. If not, their URLs are preceded by a &lt;code&gt;&amp;amp;dollar;(DDOC_ROOT_pkg)&lt;/code&gt; macro, where &lt;code&gt;pkg&lt;/code&gt; is the root package of the symbol being linked to. Links to D symbols are generated with a &lt;code&gt;&amp;amp;dollar;(DOC_EXTENSION)&lt;/code&gt; macro after the module name. So the generated URL for &lt;code&gt;[Object]&lt;/code&gt; in the above example is as if you had written:</source>
          <target state="translated">D 심볼에 대한 생성 된 링크는 문서화되는 모듈과 동일한 루트 패키지가있는 경우 상대적입니다. 그렇지 않은 경우 URL 앞에 &lt;code&gt;&amp;amp;dollar;(DDOC_ROOT_pkg)&lt;/code&gt; 매크로 가옵니다. 여기서 &lt;code&gt;pkg&lt;/code&gt; 는 링크되는 심볼의 루트 패키지입니다. D 기호에 대한 링크 는 모듈 이름 뒤에 &lt;code&gt;&amp;amp;dollar;(DOC_EXTENSION)&lt;/code&gt; 매크로를 사용하여 생성됩니다 . 따라서 위 예제에서 &lt;code&gt;[Object]&lt;/code&gt; 에 대해 생성 된 URL은 다음 과 같이 작성했습니다.</target>
        </trans-unit>
        <trans-unit id="b65a1da736509a9381ee000758f5d850e508e3e2" translate="yes" xml:space="preserve">
          <source>The generated links to D symbols are relative if they have the same root package as the module being documented. If not, their URLs are preceeded by a &lt;code&gt;&amp;amp;dollar;(DDOC_ROOT_pkg)&lt;/code&gt; macro, where &lt;code&gt;pkg&lt;/code&gt; is the root package of the symbol being linked to. Links to D symbols are generated with a &lt;code&gt;&amp;amp;dollar;(DOC_EXTENSION)&lt;/code&gt; macro after the module name. So the generated URL for &lt;code&gt;[Object]&lt;/code&gt; in the above example is as if you had written:</source>
          <target state="translated">생성 된 D 심볼에 대한 링크는 문서화 할 모듈과 동일한 루트 패키지가있는 경우 상대적입니다. 그렇지 않은 경우 URL 앞에 &lt;code&gt;&amp;amp;dollar;(DDOC_ROOT_pkg)&lt;/code&gt; 매크로 가옵니다. 여기서 &lt;code&gt;pkg&lt;/code&gt; 는 연결된 심볼의 루트 패키지입니다. D 기호에 대한 링크 는 모듈 이름 뒤에 &lt;code&gt;&amp;amp;dollar;(DOC_EXTENSION)&lt;/code&gt; 매크로를 사용하여 생성됩니다 . 따라서 위 예제에서 &lt;code&gt;[Object]&lt;/code&gt; 에 대해 생성 된 URL 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="adc505580a3e3a25fed9b9c63e6f0745b68f08fa" translate="yes" xml:space="preserve">
          <source>The getopt module implements a &lt;code&gt;getopt&lt;/code&gt; function, which adheres to the POSIX syntax for command line options. GNU extensions are supported in the form of long options introduced by a double dash (&quot;--&quot;). Support for bundling of command line options, as was the case with the more traditional single-letter approach, is provided but not enabled by default.</source>
          <target state="translated">getopt 모듈은 &lt;code&gt;getopt&lt;/code&gt; 기능을 구현하며 명령 행 옵션에 대한 POSIX 구문을 준수합니다. GNU 확장은 이중 대시 ( &quot;-&quot;)로 도입 된 긴 옵션의 형태로 지원됩니다. 보다 전통적인 단일 문자 접근 방식과 마찬가지로 명령 줄 옵션 번들 지원이 제공되지만 기본적으로 활성화되어 있지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="38436bf13581d96cda14b3d712a9839eef76ade6" translate="yes" xml:space="preserve">
          <source>The given HMAC token is compared with the expected token using the &lt;code&gt;==&lt;/code&gt; string comparison, which returns &lt;code&gt;false&lt;/code&gt; as soon as the first wrong element is found. If a wrong element is found, then a rejection is sent back to the sender.</source>
          <target state="translated">주어진 HMAC 토큰은 &lt;code&gt;==&lt;/code&gt; 문자열 비교를 사용하여 예상 토큰과 비교 되며, 첫 번째 잘못된 요소가 발견되면 즉시 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 . 잘못된 요소가 발견되면 거부가 발신자에게 다시 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="262b74b064f7ed4973ae2acf3633f01634ced6b1" translate="yes" xml:space="preserve">
          <source>The given array exposed to a standard D array.</source>
          <target state="translated">주어진 배열은 표준 D 배열에 노출됩니다.</target>
        </trans-unit>
        <trans-unit id="8bc950de5698dccabc99a10c52424998aec0c7a6" translate="yes" xml:space="preserve">
          <source>The given array of &lt;code&gt;char&lt;/code&gt; or random-access range of &lt;code&gt;char&lt;/code&gt; or &lt;code&gt;ubyte&lt;/code&gt; is expected to be in the format specified in &lt;a href=&quot;http://tools.ietf.org/html/rfc5322&quot;&gt;RFC 5322&lt;/a&gt; section 3.3 with the grammar rule</source>
          <target state="translated">주어진 &lt;code&gt;char&lt;/code&gt; 배열 또는 &lt;code&gt;char&lt;/code&gt; 또는 &lt;code&gt;ubyte&lt;/code&gt; 의 임의 액세스 범위 는 문법 규칙과 함께 &lt;a href=&quot;http://tools.ietf.org/html/rfc5322&quot;&gt;RFC 5322&lt;/a&gt; 섹션 3.3에 지정된 형식이어야합니다.</target>
        </trans-unit>
        <trans-unit id="12501a73a540c686a37f4823a66a820dabde2f39" translate="yes" xml:space="preserve">
          <source>The glob pattern</source>
          <target state="translated">글로브 패턴</target>
        </trans-unit>
        <trans-unit id="496ff2fc921b0a5cf99d9a4227ed4bf96d90c632" translate="yes" xml:space="preserve">
          <source>The grapheme cluster represents a horizontally segmentable unit of text, consisting of some grapheme base (which may consist of a Korean syllable) together with any number of nonspacing marks applied to it.</source>
          <target state="translated">grapheme 클러스터는 수평으로 분할 가능한 텍스트 단위를 나타내며, 일부 grapheme base (한국어 음절로 구성 될 수 있음)와 적용되는 임의의 비 간격 표시로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="37af0a5e629675000a6dfa7103d088d3ddd62dac" translate="yes" xml:space="preserve">
          <source>The greatest common divisor of the given arguments.</source>
          <target state="translated">주어진 인수의 최대 공약수입니다.</target>
        </trans-unit>
        <trans-unit id="8b3e1c284ef7e8df3ea6a61551c667aeed265141" translate="yes" xml:space="preserve">
          <source>The hack for bugzilla 4820 case is still questionable. Perhaps would have to handle a delegate expression with 'null' context properly in front-end.</source>
          <target state="translated">bugzilla 4820 사례에 대한 해킹은 여전히 ​​의문입니다. 프런트 엔드에서 'null'컨텍스트를 사용하여 대리자 식을 처리해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="38f5b63c8a583d4d295cf756159c50490e54c13e" translate="yes" xml:space="preserve">
          <source>The handle to an array is specified by naming the array, as in p, s or a:</source>
          <target state="translated">배열 핸들은 p, s 또는 a와 같이 배열의 이름을 지정하여 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="06b9457ea3f4fa7b2cb019db8602c7584d3ac0a3" translate="yes" xml:space="preserve">
          <source>The handler to run if the expression throwed.</source>
          <target state="translated">표현식이 발생하면 실행할 핸들러입니다.</target>
        </trans-unit>
        <trans-unit id="bb782c4330787617d4fce577aae35ea8ac20fb68" translate="yes" xml:space="preserve">
          <source>The hash function RIPEMD-160</source>
          <target state="translated">해시 함수 RIPEMD-160</target>
        </trans-unit>
        <trans-unit id="1a548321e03af2d162f5b6fb8172e4e75095c3be" translate="yes" xml:space="preserve">
          <source>The hashBlockSize and digestSize are in bits. However, it's likely easier to simply use the convenience aliases: SHA1, SHA224, SHA256, SHA384, SHA512, SHA512_224 and SHA512_256.</source>
          <target state="translated">hashBlockSize 및 digestSize는 비트 단위입니다. 그러나 편의 별칭 (SHA1, SHA224, SHA256, SHA384, SHA512, SHA512_224 및 SHA512_256)을 사용하는 것이 더 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="71c022924374f373de8247c9ee1154db2efdf429" translate="yes" xml:space="preserve">
          <source>The header can also be left empty if the input contains a header row and all columns should be iterated. The header from the input can always be accessed from the &lt;code&gt;header&lt;/code&gt; field.</source>
          <target state="translated">입력에 헤더 행이 포함되어 있고 모든 열을 반복해야하는 경우 헤더를 비워 둘 수도 있습니다. 입력의 헤더는 항상 &lt;code&gt;header&lt;/code&gt; 필드 에서 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="23806478590a3d73211d3f9cfeab9ec2c30f42f5" translate="yes" xml:space="preserve">
          <source>The header of &lt;a href=&quot;std_range&quot;&gt;&lt;code&gt;std.range&lt;/code&gt;&lt;/a&gt; for tutorials on ranges.</source>
          <target state="translated">범위에 대한 학습서를위한 &lt;a href=&quot;std_range&quot;&gt; &lt;code&gt;std.range&lt;/code&gt; &lt;/a&gt; 의 헤더입니다 .</target>
        </trans-unit>
        <trans-unit id="a73e614d706951342951d40aeeb01697424cadb7" translate="yes" xml:space="preserve">
          <source>The headers read from a successful response.</source>
          <target state="translated">성공적인 응답에서 헤더를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="1ba658c4da138d5aa67105b1d7cc27b3cfde13e6" translate="yes" xml:space="preserve">
          <source>The highlighting macros start with &lt;code&gt;DDOC_&lt;/code&gt;. They control the formatting of individual parts of the presentation.</source>
          <target state="translated">강조 표시 매크로는 &lt;code&gt;DDOC_&lt;/code&gt; 로 시작 합니다. 프리젠 테이션의 개별 부분의 형식을 제어합니다.</target>
        </trans-unit>
        <trans-unit id="7850bd95e95bab4d64e3c6d1c398982e32639f37" translate="yes" xml:space="preserve">
          <source>The hook to wrap</source>
          <target state="translated">포장 고리</target>
        </trans-unit>
        <trans-unit id="8f90c58c05f3db77fe848d30cab0798e3f6b00e3" translate="yes" xml:space="preserve">
          <source>The hook's members are looked up statically in a Design by Introspection manner and are all optional. The table below illustrates the members that a hook type may define and their influence over the behavior of the &lt;code&gt;Checked&lt;/code&gt; type using it. In the table, &lt;code&gt;hook&lt;/code&gt; is an alias for &lt;code&gt;Hook&lt;/code&gt; if the type &lt;code&gt;Hook&lt;/code&gt; does not introduce any state, or an object of type &lt;code&gt;Hook&lt;/code&gt; otherwise.</source>
          <target state="translated">후크의 멤버는 Design by Introspection 방식으로 정적으로 조회되며 모두 선택 사항입니다. 아래 표는 후크 유형이 정의 할 수있는 멤버와 이를 사용하여 &lt;code&gt;Checked&lt;/code&gt; 유형 의 동작에 미치는 영향을 보여줍니다 . 표에서 &lt;code&gt;hook&lt;/code&gt; 유형 이 상태를 도입하지 않으면 &lt;code&gt;Hook&lt;/code&gt; 는 &lt;code&gt;Hook&lt;/code&gt; 의 별명 이거나 그렇지 않으면 &lt;code&gt;Hook&lt;/code&gt; 유형의 오브젝트입니다 .</target>
        </trans-unit>
        <trans-unit id="c351eba3d013581a191d3a885a49968be29fd469" translate="yes" xml:space="preserve">
          <source>The hour of the day to set this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;'s hour to.</source>
          <target state="translated">이 &lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; 시간&lt;/a&gt; 을 설정할 시간입니다.</target>
        </trans-unit>
        <trans-unit id="66136c779346b036c2def79ac7f0dfb73004b7bb" translate="yes" xml:space="preserve">
          <source>The hour of the day to set this &lt;a href=&quot;#TimeOfDay&quot;&gt;&lt;code&gt;TimeOfDay&lt;/code&gt;&lt;/a&gt;'s hour to.</source>
          <target state="translated">이 &lt;a href=&quot;#TimeOfDay&quot;&gt; &lt;code&gt;TimeOfDay&lt;/code&gt; &lt;/a&gt; 시간을 설정할 시간입니다.</target>
        </trans-unit>
        <trans-unit id="a6a4e60304c50d5e98aa115b78722f98c55537a4" translate="yes" xml:space="preserve">
          <source>The hour portion of the time;</source>
          <target state="translated">시간의 시간 부분;</target>
        </trans-unit>
        <trans-unit id="ae576aa7ec4954f0a9eb6186b74173801d58e446" translate="yes" xml:space="preserve">
          <source>The hours to set this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;'s hour to.</source>
          <target state="translated">이 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; 시간을 설정하는 시간 입니다.</target>
        </trans-unit>
        <trans-unit id="dc9947af90e8e00095ff57d0a5f1abb3e951dbc5" translate="yes" xml:space="preserve">
          <source>The idea being these are compatible with C structs.</source>
          <target state="translated">이것에 대한 아이디어는 C 구조체와 호환됩니다.</target>
        </trans-unit>
        <trans-unit id="1355f078be2cb8440aa75f9a09689cdae9f0217b" translate="yes" xml:space="preserve">
          <source>The idea of a contract is simple - it's just an expression that must evaluate to true. If it does not, the contract is broken, and by definition, the program has a bug in it. Contracts form part of the specification for a program, moving it from the documentation to the code itself. And as every programmer knows, documentation tends to be incomplete, out of date, wrong, or non-existent. Moving the contracts into the code makes them verifiable against the program.</source>
          <target state="translated">계약의 아이디어는 간단합니다. 이는 참으로 평가되어야하는 표현 일뿐입니다. 그렇지 않은 경우 계약이 중단되고 정의에 따라 프로그램에 버그가 있습니다. 계약은 프로그램 스펙의 일부를 문서에서 코드 자체로 이동하여 프로그램에 적용합니다. 그리고 모든 프로그래머가 알고 있듯이 문서는 불완전하거나 오래되었거나 잘못되었거나 존재하지 않는 경향이 있습니다. 계약을 코드로 옮기면 프로그램에 대해 검증 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6757769fd791ee402dbfe3e43c1aa10845db21c" translate="yes" xml:space="preserve">
          <source>The identity operator &lt;code&gt;is&lt;/code&gt; cannot be overloaded.</source>
          <target state="translated">아이디 연산자 &lt;code&gt;is&lt;/code&gt; 오버로드 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1a6dd428d8629e97cfcace7f86b78f24c85c36c4" translate="yes" xml:space="preserve">
          <source>The imaginary part of the number.</source>
          <target state="translated">숫자의 허수 부.</target>
        </trans-unit>
        <trans-unit id="1ac7f7e21c56da918de0900c242a59f862e477cf" translate="yes" xml:space="preserve">
          <source>The immutable applies to the type within the following parentheses. So, while &lt;code&gt;s&lt;/code&gt; can be assigned new values, the contents of &lt;code&gt;s[]&lt;/code&gt; cannot be:</source>
          <target state="translated">불변은 다음 괄호 안의 유형에 적용됩니다. 따라서 &lt;code&gt;s&lt;/code&gt; 에 새로운 값을 할당 할 수 있지만 &lt;code&gt;s[]&lt;/code&gt; 의 내용은 다음과 같을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b076480db50c8a69f17ceccfb8074a2146342dec" translate="yes" xml:space="preserve">
          <source>The immutable array.</source>
          <target state="translated">불변 배열.</target>
        </trans-unit>
        <trans-unit id="d4da7504d70ac035ecf312cd124c3e9b875475b7" translate="yes" xml:space="preserve">
          <source>The implementation exploits properties of types and operations to minimize additional work.</source>
          <target state="translated">이 구현은 유형 및 작업의 속성을 활용하여 추가 작업을 최소화합니다.</target>
        </trans-unit>
        <trans-unit id="94333a362aef71aa736007c1291437cf4a5d5675" translate="yes" xml:space="preserve">
          <source>The implementation guarantees that all threads simultaneously calling initOnce with the same var argument block until var is fully initialized. All side-effects of init are globally visible afterwards.</source>
          <target state="translated">구현은 모든 스레드가 var가 완전히 초기화 될 때까지 동일한 var 인수 블록으로 initOnce를 동시에 호출하도록 보장합니다. init의 모든 부작용은 나중에 세계적으로 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e2b0dbd8c35c5a1541392596f49b59f590b7d4b" translate="yes" xml:space="preserve">
          <source>The implementation is available as a public member.</source>
          <target state="translated">구현은 공개 멤버로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="61a0fdac2dd135b95e81234f7a42c96423c9eb12" translate="yes" xml:space="preserve">
          <source>The implementation is based on the pseudocode in Fig. 4 of the paper &lt;a href=&quot;http://jmlr.csail.mit.edu/papers/volume6/rousu05a/rousu05a.pdf&quot;&gt;&quot;Efﬁcient Computation of Gapped Substring Kernels on Large Alphabets&quot;&lt;/a&gt; by Rousu et al., with additional algorithmic and systems-level optimizations.</source>
          <target state="translated">이 구현은 Rousu 등 의 논문 &lt;a href=&quot;http://jmlr.csail.mit.edu/papers/volume6/rousu05a/rousu05a.pdf&quot;&gt;&quot;큰 알파벳에서 갭이있는 서브 스트링 커널의 효율적인 계산&quot;&lt;/a&gt; 의 그림 4의 의사 코드를 기반으로하며 추가적인 알고리즘 및 시스템 수준 최적화를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c3c79f00444b1a8f6b8dd0d247228e66376bb4b5" translate="yes" xml:space="preserve">
          <source>The implementation may handle the case of the first</source>
          <target state="translated">구현은 첫 번째 경우를 처리 할 수 ​​있습니다</target>
        </trans-unit>
        <trans-unit id="3f62d25116bc0232c42a3fb96db6f12be7eef293" translate="yes" xml:space="preserve">
          <source>The implementations of all predefined macros are implementation-defined. The reference implementation's macro definitions can be found &lt;a href=&quot;https://github.com/dlang/dmd/blob/master/res/default_ddoc_theme.ddoc&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">사전 정의 된 모든 매크로의 구현은 구현 정의됩니다. 참조 구현의 매크로 정의는 &lt;a href=&quot;https://github.com/dlang/dmd/blob/master/res/default_ddoc_theme.ddoc&quot;&gt;여기&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ce44ea558c01cd44607fe7bfdaba1c3db8da7616" translate="yes" xml:space="preserve">
          <source>The implicit conversions of built-in scalar types can be explicitly represented by using function call syntax. For example:</source>
          <target state="translated">내장 스칼라 유형의 암시 적 변환은 함수 호출 구문을 사용하여 명시 적으로 나타낼 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8663ba6f06eeb782a371db21df4acbb1af0c444b" translate="yes" xml:space="preserve">
          <source>The importance of component programming (properties, signals and slots, etc)</source>
          <target state="translated">컴포넌트 프로그래밍의 중요성 (속성, 신호 및 슬롯 등)</target>
        </trans-unit>
        <trans-unit id="c5712d89ed6b6b5326913e6635b003b614c7a5c4" translate="yes" xml:space="preserve">
          <source>The imports are looked up to satisfy any unresolved symbols at that scope. Imported symbols may hide symbols from outer scopes.</source>
          <target state="translated">가져 오기는 해당 범위에서 해결되지 않은 기호를 충족시키기 위해 조회됩니다. 가져온 심볼은 외부 범위에서 심볼을 숨길 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="28c93ed79edf143da68c0f3519f73741ba79046d" translate="yes" xml:space="preserve">
          <source>The index of the element that should be in sorted position after the function is done.</source>
          <target state="translated">함수가 완료된 후 정렬 된 위치에 있어야하는 요소의 색인입니다.</target>
        </trans-unit>
        <trans-unit id="7b8cbc4deacf04830f34d38905f8ffd00330c728" translate="yes" xml:space="preserve">
          <source>The index of the first encounter of the maximum in &lt;code&gt;range&lt;/code&gt;. If the &lt;code&gt;range&lt;/code&gt; is empty, -1 is returned.</source>
          <target state="translated">&lt;code&gt;range&lt;/code&gt; 에서 최대 값의 첫 번째 색인입니다 . 는 IF &lt;code&gt;range&lt;/code&gt; 비어, -1이 돌려 주어집니다.</target>
        </trans-unit>
        <trans-unit id="1a84eb9548c30b563a95a1fcfb270886bdd52d9e" translate="yes" xml:space="preserve">
          <source>The index of the first encounter of the minimum element in &lt;code&gt;range&lt;/code&gt;. If the &lt;code&gt;range&lt;/code&gt; is empty, -1 is returned.</source>
          <target state="translated">&lt;code&gt;range&lt;/code&gt; 에서 최소 요소가 처음 발견 된 인덱스입니다 . 는 IF &lt;code&gt;range&lt;/code&gt; 비어, -1이 돌려 주어집니다.</target>
        </trans-unit>
        <trans-unit id="33a0038a0fcaf095d5057aead72f83713739fc8b" translate="yes" xml:space="preserve">
          <source>The index of the last occurrence of &lt;code&gt;c&lt;/code&gt; in &lt;code&gt;s&lt;/code&gt;. If &lt;code&gt;c&lt;/code&gt; is not found, then &lt;code&gt;-1&lt;/code&gt; is returned. The &lt;code&gt;startIdx&lt;/code&gt; slices &lt;code&gt;s&lt;/code&gt; in the following way &lt;code&gt;s[0 .. startIdx]&lt;/code&gt;. &lt;code&gt;startIdx&lt;/code&gt; represents a codeunit index in &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; 에서 &lt;code&gt;c&lt;/code&gt; 가 마지막으로 발생한 인덱스입니다 . 경우 &lt;code&gt;c&lt;/code&gt; 발견되지 않는, 다음 &lt;code&gt;-1&lt;/code&gt; 반환됩니다. &lt;code&gt;startIdx&lt;/code&gt; 의 슬라이스 &lt;code&gt;s&lt;/code&gt; 다음과 같은 방법으로 &lt;code&gt;s[0 .. startIdx]&lt;/code&gt; . &lt;code&gt;startIdx&lt;/code&gt; 는 &lt;code&gt;s&lt;/code&gt; 의 코드 단위 색인을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="c2e5baf3f6abe9b83760e32cef1632ac5f67ea47" translate="yes" xml:space="preserve">
          <source>The index of the pivot for partitioning, must be less than &lt;code&gt;r.length&lt;/code&gt; or &lt;code&gt;0&lt;/code&gt; if &lt;code&gt;r.length&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;</source>
          <target state="translated">파티셔닝을위한 피벗의 인덱스는 &lt;code&gt;r.length&lt;/code&gt; 보다 작 거나 &lt;code&gt;r.length&lt;/code&gt; 가 &lt;code&gt;0&lt;/code&gt; 인 경우 &lt;code&gt;0&lt;/code&gt; 보다 작아야 합니다.</target>
        </trans-unit>
        <trans-unit id="f4e8d4da6e42c851e373823697d10ed8eae4adf3" translate="yes" xml:space="preserve">
          <source>The index of the type among &lt;code&gt;AllowedTypesParam&lt;/code&gt;, zero-based.</source>
          <target state="translated">&lt;code&gt;AllowedTypesParam&lt;/code&gt; 중 유형의 인덱스 ( 0부터 시작)입니다.</target>
        </trans-unit>
        <trans-unit id="6f4d7d5591308d1987c179c707865f7263b2522b" translate="yes" xml:space="preserve">
          <source>The index of this archive member within the archive.</source>
          <target state="translated">아카이브 내에서이 아카이브 멤버의 색인입니다.</target>
        </trans-unit>
        <trans-unit id="6bca3732803cf0cac5bd51a87fe2e1e77dd22909" translate="yes" xml:space="preserve">
          <source>The index of this archive member within the archive. Set this to a different value for reordering the members of an archive.</source>
          <target state="translated">아카이브 내에서이 아카이브 멤버의 인덱스입니다. 아카이브의 구성원을 재정렬하려면이 값을 다른 값으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="9b3efb64d9c8c3a8462cc2762d6a92ac26c24dcc" translate="yes" xml:space="preserve">
          <source>The index starts at &lt;code&gt;start&lt;/code&gt; and is incremented by one on every iteration.</source>
          <target state="translated">인덱스는 시작시 &lt;code&gt;start&lt;/code&gt; 하여 반복 할 때마다 하나씩 증가합니다.</target>
        </trans-unit>
        <trans-unit id="86fe7372a9779ec608c645bda74b3617bd2f68d1" translate="yes" xml:space="preserve">
          <source>The index to start reading from (instead of starting at the front). If index is a pointer, then it is updated to the index after the bytes read. The overloads with index are only available if &lt;code&gt;hasSlicing!R&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">읽기 시작 색인 (앞에서 시작하는 대신). index가 포인터이면 바이트를 읽은 후에 인덱스로 업데이트됩니다. &lt;code&gt;hasSlicing!R&lt;/code&gt; 이 &lt;code&gt;true&lt;/code&gt; 인 경우에만 인덱스가있는 과부하를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3b0d5226f25947ab0cd2172717539dced2cf1ca0" translate="yes" xml:space="preserve">
          <source>The index to start writing to. If index is a pointer, then it is updated to the index after the bytes read.</source>
          <target state="translated">쓸 인덱스입니다. index가 포인터이면 바이트를 읽은 후에 인덱스로 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="4dd9df4788f29de75fb62d913aea700844f5ed25" translate="yes" xml:space="preserve">
          <source>The index.</source>
          <target state="translated">색인.</target>
        </trans-unit>
        <trans-unit id="f9ffb074b766c5938ff8b7357963618eaf462bcb" translate="yes" xml:space="preserve">
          <source>The indexed range. If rs consists of only one range, the return type is an alias of that range's type.</source>
          <target state="translated">인덱스 범위. rs가 하나의 범위로만 구성된 경우 리턴 유형은 해당 범위 유형의 별명입니다.</target>
        </trans-unit>
        <trans-unit id="619765ffdaa0071187a8f77abd362e7dda091d2c" translate="yes" xml:space="preserve">
          <source>The inference is done by determining if the function body follows the rules of the particular attribute.</source>
          <target state="translated">함수 본문이 특정 속성의 규칙을 따르는 지 여부를 판별하여 추론을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="44470f7ce0660d4121c31a312118ccb100fd5b58" translate="yes" xml:space="preserve">
          <source>The initial count for the semaphore.</source>
          <target state="translated">세마포어의 초기 카운트</target>
        </trans-unit>
        <trans-unit id="8c9e853ca955ba71f49e1626fd9e59d97a172b5c" translate="yes" xml:space="preserve">
          <source>The initial range wrapped as a &lt;code&gt;SortedRange&lt;/code&gt; with its predicates converted to an equivalent single predicate.</source>
          <target state="translated">술어를 동등한 단일 술어로 변환하여 &lt;code&gt;SortedRange&lt;/code&gt; 로 랩핑 된 초기 범위 .</target>
        </trans-unit>
        <trans-unit id="47bf51e4f2c2e73e2360a982a3dcd26ed977c3bb" translate="yes" xml:space="preserve">
          <source>The initial range wrapped as a &lt;code&gt;SortedRange&lt;/code&gt; with the predicate &lt;code&gt;(a, b) =&amp;gt; binaryFun!less(transform(a), transform(b))&lt;/code&gt;.</source>
          <target state="translated">초기 범위 는 술어 &lt;code&gt;(a, b) =&amp;gt; binaryFun!less(transform(a), transform(b))&lt;/code&gt; 와 함께 &lt;code&gt;SortedRange&lt;/code&gt; 로 래핑됩니다 .</target>
        </trans-unit>
        <trans-unit id="ae187df68ec47146dca1715d3e3c373579beb355" translate="yes" xml:space="preserve">
          <source>The initial range wrapped as a &lt;code&gt;SortedRange&lt;/code&gt; with the predicate &lt;code&gt;binaryFun!less&lt;/code&gt;.</source>
          <target state="translated">초기 범위 는 술어 &lt;code&gt;binaryFun!less&lt;/code&gt; 와 함께 &lt;code&gt;SortedRange&lt;/code&gt; 로 랩핑되었습니다 .</target>
        </trans-unit>
        <trans-unit id="80d1aad4ad1e534532ce1e885f47d8eb7c78b11f" translate="yes" xml:space="preserve">
          <source>The initial size of each buffer. If &lt;code&gt;next&lt;/code&gt; takes its array by reference, it may resize the buffers.</source>
          <target state="translated">각 버퍼의 초기 크기 &lt;code&gt;next&lt;/code&gt; 으로 참조로 배열을 가져 오면 버퍼 크기를 조정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="06bcd9aed8f8362952958dfe41f57dcc25fe7b79" translate="yes" xml:space="preserve">
          <source>The initialization expression for the type.</source>
          <target state="translated">유형의 초기화 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="ef4a846934e7e3a7c6fada2c58784a67e938dc53" translate="yes" xml:space="preserve">
          <source>The initializer for a manifest constant is evaluated using compile time function evaluation.</source>
          <target state="translated">매니페스트 상수의 이니셜 라이저는 컴파일 시간 함수 평가를 사용하여 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="4866f78cdd0450f210abe845a0008dc25126137c" translate="yes" xml:space="preserve">
          <source>The initializer for a non-local immutable declaration must be evaluatable at compile time:</source>
          <target state="translated">로컬이 아닌 불변 선언의 이니셜 라이저는 컴파일 타임에 평가할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="c3ff76d4230d39e88bec6a17e3fa23c6428b640f" translate="yes" xml:space="preserve">
          <source>The initializer for a non-static local immutable declaration is evaluated at run time:</source>
          <target state="translated">정적이 아닌 로컬 불변 선언의 이니셜 라이저는 런타임에 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="8f27ed7b518832024e3d6a15cbe377f8e47f39ab" translate="yes" xml:space="preserve">
          <source>The initializer for a static variable must be evaluatable at compile time, and they are initialized upon the start of the thread (or the start of the program for &lt;code&gt;__gshared&lt;/code&gt;). There are no static constructors or static destructors for static local variables.</source>
          <target state="translated">정적 변수의 이니셜 라이저는 컴파일 타임에 &lt;code&gt;__gshared&lt;/code&gt; 하며 스레드 시작시 (또는 __gshared 의 프로그램 시작시) 초기화됩니다 . 정적 로컬 변수에 대한 정적 생성자 또는 정적 소멸자가 없습니다.</target>
        </trans-unit>
        <trans-unit id="56398784568892251b9dcc7b9a121fdad0fc1209" translate="yes" xml:space="preserve">
          <source>The inout forms a wildcard that stands in for any of mutable, const, immutable, inout, or inout const. When the function is called, the inout of the return type is changed to whatever the mutable, const, immutable, inout, or inout const status of the argument type to the parameter inout was.</source>
          <target state="translated">입력은 변경 가능, const, 불변, 입력 또는 입력 const 중 하나를 나타내는 와일드 카드를 형성합니다. 함수가 호출되면 리턴 유형의 입력이 매개 변수 inout에 대한 인수 유형의 가변, const, 불변, inout 또는 inout const 상태로 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="47e39fe3c6321bc48452728017762afb10e65931" translate="yes" xml:space="preserve">
          <source>The inout in the return type is then rewritten to be the inout matched qualifiers:</source>
          <target state="translated">그런 다음 리턴 유형의 입력은 입력 일치 된 규정 자로 다시 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="894e5ecc4ff73411cc66384f9e949e3263a04d5e" translate="yes" xml:space="preserve">
          <source>The input data is too long (There's no guarantee the first part of the data is valid)</source>
          <target state="translated">입력 데이터가 너무 깁니다 (데이터의 첫 부분이 유효하다는 보장은 없습니다)</target>
        </trans-unit>
        <trans-unit id="37721cea9b7ff856cc5a0d72da55bfcef8342f2c" translate="yes" xml:space="preserve">
          <source>The input elements. If there are less elements than the specified length of the static array, the rest of it is default-initialized. If there are more than specified, the first elements up to the specified length are used.</source>
          <target state="translated">입력 요소. 정적 배열의 지정된 길이보다 적은 수의 요소가 있으면 나머지는 기본적으로 초기화됩니다. 지정된 것보다 많으면 지정된 길이까지 첫 번째 요소가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4b42c37fa56b476654b6a22d064c38aab28dcdfc" translate="yes" xml:space="preserve">
          <source>The input is returned.</source>
          <target state="translated">입력이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="fb78206bd59b576b51359aab6e37d1fe64780809" translate="yes" xml:space="preserve">
          <source>The input may have originated from &lt;code&gt;U[]&lt;/code&gt; or &lt;code&gt;immutable(U)[]&lt;/code&gt;, so it may be actually shared or not. Returning an unqualified affix may result in race conditions, whereas returning a &lt;code&gt;shared&lt;/code&gt; affix may result in inadvertent sharing of mutable thread-local data across multiple threads. So the returned type is conservatively &lt;code&gt;ref const&lt;/code&gt;.</source>
          <target state="translated">입력이 &lt;code&gt;U[]&lt;/code&gt; 또는 &lt;code&gt;immutable(U)[]&lt;/code&gt; 에서 시작되었을 수 있으므로 실제로 공유되거나 공유되지 않을 수 있습니다. 규정되지 않은 접두어를 반환하면 경쟁 조건이 발생할 수 있지만 &lt;code&gt;shared&lt;/code&gt; 접두어를 반환하면 여러 스레드에서 변경 가능한 스레드 로컬 데이터를 실수로 공유 할 수 있습니다. 따라서 반환 된 유형은 보수적으로 &lt;code&gt;ref const&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ab7802e78bae021ec9f77bb19cdbefc46c138fde" translate="yes" xml:space="preserve">
          <source>The input range being passed through.</source>
          <target state="translated">통과되는 입력 범위.</target>
        </trans-unit>
        <trans-unit id="c0225247a221452c012002a0bc4a76423e77fd6b" translate="yes" xml:space="preserve">
          <source>The input range must not be empty.</source>
          <target state="translated">입력 범위는 비워 둘 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="786f6ba29b51fa6818ec422c83e424f885e18b3d" translate="yes" xml:space="preserve">
          <source>The input range set up to parse one line at a time into a record tuple.</source>
          <target state="translated">입력 범위는 한 번에 한 줄씩 레코드 튜플로 구문 분석하도록 설정되었습니다.</target>
        </trans-unit>
        <trans-unit id="4c83aa414329fad18718e6fa488a3b442df22d1b" translate="yes" xml:space="preserve">
          <source>The input range to check.</source>
          <target state="translated">확인할 입력 범위.</target>
        </trans-unit>
        <trans-unit id="4dd476cc824391e088069cbddbb750e2eef61f40" translate="yes" xml:space="preserve">
          <source>The input text string s is formed into a paragraph by breaking it up into a sequence of lines, delineated by \n, such that the number of columns is not exceeded on each line. The last line is terminated with a \n.</source>
          <target state="translated">입력 텍스트 문자열 s는 각 행에서 열 수가 초과되지 않도록 \ n으로 구분 된 일련의 행으로 구분하여 단락으로 구성됩니다. 마지막 줄은 \ n으로 끝납니다.</target>
        </trans-unit>
        <trans-unit id="93424042a1977cf3da75467c8916a2a7eddec8a8" translate="yes" xml:space="preserve">
          <source>The input to this function MUST be a valid code point.</source>
          <target state="translated">이 함수의 입력은 유효한 코드 포인트 여야합니다.</target>
        </trans-unit>
        <trans-unit id="44b890bb7f50ef5e291775cda4bfde289081100b" translate="yes" xml:space="preserve">
          <source>The input to this function MUST be a valid code point. This is enforced by the function's in-contract.</source>
          <target state="translated">이 함수의 입력은 유효한 코드 포인트 여야합니다. 이는 계약의 계약에 의해 시행됩니다.</target>
        </trans-unit>
        <trans-unit id="c67615e6ffc16592b049d69cbff653f9fe85f2f3" translate="yes" xml:space="preserve">
          <source>The input to this function MUST be valid XML. This is enforced by DocumentParser's in contract.</source>
          <target state="translated">이 함수의 입력은 유효한 XML이어야합니다. 이것은 DocumentParser의 계약에 의해 시행됩니다.</target>
        </trans-unit>
        <trans-unit id="4bb4a25af5340195ef134855f808d1711e956a9a" translate="yes" xml:space="preserve">
          <source>The input to this function MUST be valid XML. This is enforced by the function's in contract.</source>
          <target state="translated">이 함수의 입력은 유효한 XML이어야합니다. 이것은 계약의 기능에 의해 시행됩니다.</target>
        </trans-unit>
        <trans-unit id="323b8c9102f07dbc17e6156b32bdb18e8608c8b5" translate="yes" xml:space="preserve">
          <source>The input to this function MUST be validly encoded.</source>
          <target state="translated">이 함수의 입력은 반드시 올바르게 인코딩되어야합니다.</target>
        </trans-unit>
        <trans-unit id="d4a76f46d20716b9c53fd13981afb49f20693850" translate="yes" xml:space="preserve">
          <source>The input to this function MUST be validly encoded. This is enforced by the function's in-contract.</source>
          <target state="translated">이 함수의 입력은 반드시 올바르게 인코딩되어야합니다. 이는 계약의 계약에 의해 시행됩니다.</target>
        </trans-unit>
        <trans-unit id="52bc0973d7be9145a7f9c10120f8ee1522aa2643" translate="yes" xml:space="preserve">
          <source>The instantiated template.</source>
          <target state="translated">인스턴스화 된 템플릿.</target>
        </trans-unit>
        <trans-unit id="caa69ad6f2cd188077c7e982e4e11f26b6cdf5a4" translate="yes" xml:space="preserve">
          <source>The integral and floating type sizes should be considered as minimums. Algorithms should be designed to continue to work properly if the type size increases.</source>
          <target state="translated">정수 및 부동 유형 크기는 최소값으로 고려해야합니다. 알고리즘은 유형 크기가 커지면 계속 제대로 작동하도록 설계되어야합니다.</target>
        </trans-unit>
        <trans-unit id="bfaa650f603081ed06b593e3b4e5c458c3260e28" translate="yes" xml:space="preserve">
          <source>The integral is</source>
          <target state="translated">적분은</target>
        </trans-unit>
        <trans-unit id="d07416a83435e11558037f6cda4d47f4d33fe73e" translate="yes" xml:space="preserve">
          <source>The integral is evaluated by a continued fraction expansion or, when b * x is small, by a power series.</source>
          <target state="translated">적분은 지속적인 분수 팽창, 또는 b * x가 작을 때, 전력 계열에 의해 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="4502af3e801c133bfaf7193afbee4f48610ef881" translate="yes" xml:space="preserve">
          <source>The integral type to convert the first &lt;code&gt;T.sizeof&lt;/code&gt; bytes to.</source>
          <target state="translated">첫 번째 &lt;code&gt;T.sizeof&lt;/code&gt; 바이트를 변환 할 정수 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="51127e20341aada7d08b3905487eaefce7dd284a" translate="yes" xml:space="preserve">
          <source>The integral value to return the absolute value of.</source>
          <target state="translated">절대 값을 반환하는 정수 값입니다.</target>
        </trans-unit>
        <trans-unit id="54f14afee26358f556f656a70b82a5a8901a5411" translate="yes" xml:space="preserve">
          <source>The intent of this function is to provide an allocation-less way to call a C function using a D slice. The function internally allocates a buffer if needed, but frees it on exit.</source>
          <target state="translated">이 함수의 목적은 D 슬라이스를 사용하여 C 함수를 호출하는 할당없는 방법을 제공하는 것입니다. 이 함수는 필요한 경우 내부적으로 버퍼를 할당하지만 종료시 버퍼를 해제합니다.</target>
        </trans-unit>
        <trans-unit id="aa32bace5214cedb20ff140ded35da64a7980bf0" translate="yes" xml:space="preserve">
          <source>The intention is that &lt;code&gt;opDollar!i&lt;/code&gt; should return the length of the array along its &lt;code&gt;i&lt;/code&gt;'th dimension, or a user-defined object representing the end of the array along that dimension, that is understood by &lt;code&gt;opSlice&lt;/code&gt; and &lt;code&gt;opIndex&lt;/code&gt;.</source>
          <target state="translated">의도이다 &lt;code&gt;opDollar!i&lt;/code&gt; 그 따라 배열 길이 돌려 &lt;code&gt;i&lt;/code&gt; '번째 차원 또는 이해되는 사이즈에 따라 배열의 끝을 나타내는 사용자 정의 물체 &lt;code&gt;opSlice&lt;/code&gt; 및 &lt;code&gt;opIndex&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="7ed569bfceb9bac4ccf7954c87c2cc7395c8f770" translate="yes" xml:space="preserve">
          <source>The intention is that &lt;code&gt;opSlice!i&lt;/code&gt; should return a user-defined object that represents an interval of indices along the &lt;code&gt;i&lt;/code&gt;'th dimension of the array. This object is then passed to &lt;code&gt;opIndex&lt;/code&gt; to perform the actual slicing operation. If only one-dimensional slicing is desired, &lt;code&gt;opSlice&lt;/code&gt; may be declared without the compile-time parameter &lt;code&gt;i&lt;/code&gt;.</source>
          <target state="translated">의도이다 &lt;code&gt;opSlice!i&lt;/code&gt; 따라 인덱스의 간격 나타내는 사용자 정의 물체 돌려 &lt;code&gt;i&lt;/code&gt; '어레이의 일 차원을. 그런 다음이 객체를 &lt;code&gt;opIndex&lt;/code&gt; 로 전달 하여 실제 슬라이싱 작업을 수행합니다. 1 차원 슬라이싱 만 필요한 경우 컴파일 타임 매개 변수 &lt;code&gt;i&lt;/code&gt; 없이 &lt;code&gt;opSlice&lt;/code&gt; 를 선언 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cf6066b8690ba4fa47007edd6d83a6b71547ae35" translate="yes" xml:space="preserve">
          <source>The interface to the virtual-table mechanism defined above (back up to a comment remarkably similar to this one) is currently considered to be experimental. The interface might change in incompatible ways. If this is a problem for you, do not use the interface at this time.</source>
          <target state="translated">위에서 정의한 가상 테이블 메커니즘에 대한 인터페이스 (이것과 상당히 유사한 주석까지)는 현재 실험적인 것으로 간주됩니다. 인터페이스가 호환되지 않는 방식으로 변경 될 수 있습니다. 이것이 문제인 경우, 지금 인터페이스를 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="6250bca0465ce111dcc80945b2149f4168412958" translate="yes" xml:space="preserve">
          <source>The interface to the virtual-table mechanism is currently considered to be experimental. The interface might change in incompatible ways. If this is a problem for you, do not use the interface at this time.</source>
          <target state="translated">가상 테이블 메커니즘에 대한 인터페이스는 현재 실험적인 것으로 간주됩니다. 인터페이스가 호환되지 않는 방식으로 변경 될 수 있습니다. 이것이 문제인 경우, 지금 인터페이스를 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="8d2e293904f5395fe014c79325ed5dca620f1643" translate="yes" xml:space="preserve">
          <source>The interface to this is found in Druntime's &lt;a href=&quot;https://github.com/dlang/druntime/blob/master/src/gc/gcinterface.d&quot;&gt;gc/gcinterface.d&lt;/a&gt;.</source>
          <target state="translated">이것에 대한 인터페이스는 Druntime의 &lt;a href=&quot;https://github.com/dlang/druntime/blob/master/src/gc/gcinterface.d&quot;&gt;gc / gcinterface.d에&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="70ba1bd45dceaea5f1daa9192d952a7efda4639e" translate="yes" xml:space="preserve">
          <source>The interval that this &lt;code&gt;IntervalRange&lt;/code&gt; currently covers.</source>
          <target state="translated">이 &lt;code&gt;IntervalRange&lt;/code&gt; 가 현재 다루는 간격입니다 .</target>
        </trans-unit>
        <trans-unit id="b1b8b6efa0b6085f29ca02a503001474bd874de3" translate="yes" xml:space="preserve">
          <source>The interval that this range currently covers.</source>
          <target state="translated">이 범위가 현재 포함하는 간격입니다.</target>
        </trans-unit>
        <trans-unit id="99ed0102a151474509c2f50c80c6a8fd9abde664" translate="yes" xml:space="preserve">
          <source>The interval to check against this interval.</source>
          <target state="translated">이 간격과 비교할 간격입니다.</target>
        </trans-unit>
        <trans-unit id="e9709ec7167a6294d35ca54cb0db7b761b6bd4bb" translate="yes" xml:space="preserve">
          <source>The interval to check for against this interval.</source>
          <target state="translated">이 간격에 대해 확인할 간격입니다.</target>
        </trans-unit>
        <trans-unit id="c93a05b54bf8db01ca44894e1b6574520f0f25cd" translate="yes" xml:space="preserve">
          <source>The interval to check for inclusion in this interval.</source>
          <target state="translated">이 간격에 포함되는지 확인할 간격입니다.</target>
        </trans-unit>
        <trans-unit id="7af5c560175f78550b8fa16520f8bceb2478bd1e" translate="yes" xml:space="preserve">
          <source>The interval to check for intersection with this interval.</source>
          <target state="translated">이 간격과의 교차점을 확인할 간격입니다.</target>
        </trans-unit>
        <trans-unit id="758e2e8521e78873ca075d9d09978b3e79b23a85" translate="yes" xml:space="preserve">
          <source>The interval to check whether its adjecent to this interval.</source>
          <target state="translated">이 간격에 적합한 지 여부를 확인하는 간격입니다.</target>
        </trans-unit>
        <trans-unit id="ec8c525abec811d6fafbe3af351dcf7c933228a1" translate="yes" xml:space="preserve">
          <source>The interval to create a span together with this interval.</source>
          <target state="translated">이 간격과 함께 범위를 만드는 간격입니다.</target>
        </trans-unit>
        <trans-unit id="ffa8edd7fe1af9b169dddd595e3c77f03e44244d" translate="yes" xml:space="preserve">
          <source>The interval to intersect with this interval.</source>
          <target state="translated">이 간격과 교차 할 간격입니다.</target>
        </trans-unit>
        <trans-unit id="450cf7fb1673450b11d1c6b4254176a2488c262a" translate="yes" xml:space="preserve">
          <source>The interval to merge with this interval.</source>
          <target state="translated">이 간격과 병합 할 간격입니다.</target>
        </trans-unit>
        <trans-unit id="6dd87bff580699a73195a62f3312346bd1ffd61d" translate="yes" xml:space="preserve">
          <source>The invariant can be checked with an &lt;code&gt;assert()&lt;/code&gt; expression:</source>
          <target state="translated">불변량은 &lt;code&gt;assert()&lt;/code&gt; 표현식 으로 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3d1bc4f7a43b5f2dfbf63c4d45e4f9ad2787305a" translate="yes" xml:space="preserve">
          <source>The invariant is a contract saying that the &lt;code&gt;assert&lt;/code&gt;s must hold true. The invariant is checked when a class or struct constructor completes, and at the start of the class or struct destructor. For public or exported functions, the order of execution is:</source>
          <target state="translated">불변은 &lt;code&gt;assert&lt;/code&gt; 진실이어야 한다는 계약 입니다. 불변량은 클래스 또는 구조체 생성자가 완료되고 클래스 또는 구조체 소멸자가 시작될 때 확인됩니다. 공개 또는 내 보낸 함수의 경우 실행 순서는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="db3237f4b413cd2d050f8846cd6a9cf6b11b5b9b" translate="yes" xml:space="preserve">
          <source>The invariant is in the form of a &lt;code&gt;const&lt;/code&gt; member function. The invariant is defined to</source>
          <target state="translated">불변은 &lt;code&gt;const&lt;/code&gt; 멤버 함수 의 형태입니다 . 불변량은</target>
        </trans-unit>
        <trans-unit id="4013ec9a85db3fcab85de75b73cedbcdfe5398d3" translate="yes" xml:space="preserve">
          <source>The invariant is not checked if the class or struct is implicitly constructed using the default &lt;code&gt;.init&lt;/code&gt; value.</source>
          <target state="translated">클래스 또는 구조체가 기본 &lt;code&gt;.init&lt;/code&gt; 값을 사용하여 암시 적으로 생성 된 경우 불변은 확인되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="b006ea59664dde8c9966b0ba37f0d9de49867d7b" translate="yes" xml:space="preserve">
          <source>The invariant need not hold if the class instance is implicitly constructed using the default &lt;code&gt;.init&lt;/code&gt; value.</source>
          <target state="translated">클래스 인스턴스가 기본 &lt;code&gt;.init&lt;/code&gt; 값을 사용하여 암시 적으로 생성 된 경우 고정 변수를 유지할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="90d62a6c20b7727a896f3c7231e895bd333ec112" translate="yes" xml:space="preserve">
          <source>The invariant need not hold if the struct instance is implicitly constructed using the default &lt;code&gt;.init&lt;/code&gt; value.</source>
          <target state="translated">구조체 인스턴스가 기본 &lt;code&gt;.init&lt;/code&gt; 값을 사용하여 암시 적으로 생성 된 경우 고정 변수를 유지할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="ae2f7e963cff5e59d45cd356ad6b537b6f9c2bbf" translate="yes" xml:space="preserve">
          <source>The isMarked callback function.</source>
          <target state="translated">isMarked 콜백 함수</target>
        </trans-unit>
        <trans-unit id="b53b0d99e692dbe7d750a9e3a8ec485970e1fe1a" translate="yes" xml:space="preserve">
          <source>The issue remains of calling &lt;code&gt;a.deallocate(b)&lt;/code&gt; from a different thread than the one that allocated &lt;code&gt;b&lt;/code&gt;. It follows that both threads must have access to the same instance &lt;code&gt;a&lt;/code&gt; of the respective allocator type. By definition of D, this is possible only if &lt;code&gt;a&lt;/code&gt; has the &lt;code&gt;shared&lt;/code&gt; qualifier. It follows that the allocator type must implement &lt;code&gt;allocate&lt;/code&gt; and &lt;code&gt;deallocate&lt;/code&gt; as &lt;code&gt;shared&lt;/code&gt; methods. That way, the allocator commits to allowing usable &lt;code&gt;shared&lt;/code&gt; instances.</source>
          <target state="translated">호출하는 문제가 남아 &lt;code&gt;a.deallocate(b)&lt;/code&gt; 에 할당하는 것과 다른 스레드로부터 &lt;code&gt;b&lt;/code&gt; . 두 스레드 모두 각각의 할당 자 유형 의 동일한 인스턴스 &lt;code&gt;a&lt;/code&gt; 에 액세스 할 수 있어야합니다 . 에만 D의 정의에 따라이 가능 &lt;code&gt;a&lt;/code&gt; 가지고 &lt;code&gt;shared&lt;/code&gt; 규정. 할당 자 유형은 &lt;code&gt;shared&lt;/code&gt; 메소드 로 &lt;code&gt;allocate&lt;/code&gt; 및 &lt;code&gt;deallocate&lt;/code&gt; 를 구현해야합니다 . 이렇게하면 할당자는 사용 가능한 &lt;code&gt;shared&lt;/code&gt; 인스턴스 를 허용 합니다.</target>
        </trans-unit>
        <trans-unit id="f906deb3cb569875f4c530161fd80e93b9be746c" translate="yes" xml:space="preserve">
          <source>The key is the IANA time zone database name, and the value is a list of Windows time zone names which are close (usually only one, but it could be multiple).</source>
          <target state="translated">키는 IANA 표준 시간대 데이터베이스 이름이고 값은 가까운 Windows 표준 시간대 이름 목록입니다 (일반적으로 하나이지만 여러 개일 수 있음).</target>
        </trans-unit>
        <trans-unit id="0cdd5bd88b6b5b8af271fba7af0cd3f24ac411a0" translate="yes" xml:space="preserve">
          <source>The key is the Windows time zone name, and the value is a list of IANA TZ database names which are close (currently only ever one, but it allows for multiple in case it's ever necessary).</source>
          <target state="translated">키는 Windows 표준 시간대 이름이고 값은 가까운 IANA TZ 데이터베이스 이름 목록입니다 (현재는 하나만 필요하지만 필요한 경우 여러 개를 허용 함).</target>
        </trans-unit>
        <trans-unit id="07021616652b4190834cc6f5cd3d6a99828ab34d" translate="yes" xml:space="preserve">
          <source>The key.</source>
          <target state="translated">열쇠.</target>
        </trans-unit>
        <trans-unit id="a80046e2f9e469e161e9b64d7a84ab6bec7ee185" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;do&lt;/code&gt; can be used to announce the function body. Although any number of pre or post contracts of any form may follow each other, &lt;code&gt;do&lt;/code&gt; is required only when the last contract before the body is a block statement. (Before the acceptance of &lt;a href=&quot;https://github.com/dlang/DIPs/blob/master/DIPs/accepted/DIP1003.md&quot;&gt;DIP1003&lt;/a&gt;, the keyword &lt;code&gt;body&lt;/code&gt; was required instead of &lt;code&gt;do&lt;/code&gt;, and may still be encountered in old code bases. In the long term, &lt;code&gt;body&lt;/code&gt; may be deprecated, but for now it's allowed both as a keyword in this context and as an identifier elsewhere, although &lt;code&gt;do&lt;/code&gt; is preferred.)</source>
          <target state="translated">키워드 &lt;code&gt;do&lt;/code&gt; 는 함수 본문을 알리는 데 사용될 수 있습니다. 어떤 형태의 사전 또는 사후 계약의 숫자가 서로를 따를 수 있지만, &lt;code&gt;do&lt;/code&gt; 신체 전에 마지막 계약이 블록 문 경우에만 필요합니다. ( &lt;a href=&quot;https://github.com/dlang/DIPs/blob/master/DIPs/accepted/DIP1003.md&quot;&gt;DIP1003을&lt;/a&gt; 수락하기 전에 키워드 &lt;code&gt;body&lt;/code&gt; 이 &lt;code&gt;do&lt;/code&gt; 대신 필요 했지만 여전히 오래된 코드 기반에서 발견 될 수 있습니다. 장기적으로 &lt;code&gt;body&lt;/code&gt; 은 더 이상 사용되지 않을 수 있지만 현재로서는이 문맥에서 키워드로 허용됩니다. 다른 식별자 있지만 &lt;code&gt;do&lt;/code&gt; 바람직하다.)</target>
        </trans-unit>
        <trans-unit id="d0cf199fa5ede60a30e00df7068d936c5578eb01" translate="yes" xml:space="preserve">
          <source>The kind of pragma it is determined by the</source>
          <target state="translated">그것은 pragma의 종류에 의해 결정됩니다</target>
        </trans-unit>
        <trans-unit id="8c29b92f234fc529a35e51b203804649a01ac419" translate="yes" xml:space="preserve">
          <source>The lambda function arguments must not have a template instantiation as an explicit argument type. Any other argument types (basic, user-defined, template) are supported.</source>
          <target state="translated">람다 함수 인수에는 명시 적 인수 유형으로 템플릿 인스턴스화가 없어야합니다. 다른 인수 유형 (기본, 사용자 정의, 템플릿)이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="bdcf91e0f4f606e17a112c301f88ad8c5b2c10fe" translate="yes" xml:space="preserve">
          <source>The lambda function body must contain a single expression (no return statement) which contains only numeric values, manifest constants, enum values, function arguments and function calls. If the expression contains local variables or return statements, the function is considered incomparable.</source>
          <target state="translated">람다 함수 본문에는 숫자 값, 매니페스트 상수, 열거 형 값, 함수 인수 및 함수 호출 만 포함하는 단일 표현식 (반환 문 없음)이 포함되어야합니다. 식에 지역 변수 나 return 문이 포함 된 경우 함수는 비교할 수없는 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="95be9f6bb557ebac60c617f8309a121bd86960bc" translate="yes" xml:space="preserve">
          <source>The last day in the month that this &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; is in.</source>
          <target state="translated">이 &lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 가 있는 달의 마지막 날 입니다.</target>
        </trans-unit>
        <trans-unit id="7a278dbcde6702c093900cb5053e8bf5709be9d8" translate="yes" xml:space="preserve">
          <source>The last day in the month that this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; is in.</source>
          <target state="translated">이 &lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 이 있는 달의 마지막 날 입니다.</target>
        </trans-unit>
        <trans-unit id="49136c9e4ea103b38fd972475d00bbb19f727989" translate="yes" xml:space="preserve">
          <source>The last day in the month that this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; is in.</source>
          <target state="translated">이 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; 이 있는 달의 마지막 날 입니다.</target>
        </trans-unit>
        <trans-unit id="a7a9289af76d268aef34222393a4318b6b13e368" translate="yes" xml:space="preserve">
          <source>The last element in the container</source>
          <target state="translated">컨테이너의 마지막 요소</target>
        </trans-unit>
        <trans-unit id="6a4a00d2337afbe6c2df52717b98e8e13215bd50" translate="yes" xml:space="preserve">
          <source>The last element of the array.</source>
          <target state="translated">배열의 마지막 요소</target>
        </trans-unit>
        <trans-unit id="9093baea1e3cf86fea0c4e3a6b9e58ab2a97f5a2" translate="yes" xml:space="preserve">
          <source>The last modification time in DosFileFormat.</source>
          <target state="translated">DosFileFormat의 마지막 수정 시간입니다.</target>
        </trans-unit>
        <trans-unit id="bdc0ac79d31e7752c2d29a6d8b9bf43609b17c83" translate="yes" xml:space="preserve">
          <source>The last parameter is passed in EAX rather than being pushed on the stack if the following conditions are met:</source>
          <target state="translated">다음 조건이 충족되면 마지막 매개 변수는 스택에서 푸시되지 않고 EAX로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="746b4bdff136b3fa913bf1eeb63d7355bf56ba56" translate="yes" xml:space="preserve">
          <source>The last template parameter if it's a &lt;code&gt;TemplateTupleParameter&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;TemplateTupleParameter&lt;/code&gt; 인 경우 마지막 템플리트 매개 변수</target>
        </trans-unit>
        <trans-unit id="81aad1de98ee0f65f497fb989a25778e1871d9df" translate="yes" xml:space="preserve">
          <source>The lazy initializer value</source>
          <target state="translated">게으른 이니셜 라이저 값</target>
        </trans-unit>
        <trans-unit id="ea4b5c8a99ea43d9dec4f2b203a2486705eaedf1" translate="yes" xml:space="preserve">
          <source>The lazy variadic delegate solution is preferable to using a lazy variadic array, because each array index would evaluate every element:</source>
          <target state="translated">각 배열 인덱스는 모든 요소를 ​​평가하므로, 게으른 가변 배열을 사용하는 것보다 게으른 가변 배열 대리 솔루션이 선호됩니다.</target>
        </trans-unit>
        <trans-unit id="421c4166a84b43c53a129a72090df266fc5436fb" translate="yes" xml:space="preserve">
          <source>The least significant bit in any &lt;code&gt;size_t&lt;/code&gt; unit is the starting bit of this unit, and the most significant bit is the last bit of this unit. Therefore, passing e.g. an array of &lt;code&gt;int&lt;/code&gt;s may result in a different &lt;code&gt;BitArray&lt;/code&gt; depending on the processor's endianness.</source>
          <target state="translated">&lt;code&gt;size_t&lt;/code&gt; 단위의 최하위 비트 는이 장치의 시작 비트이며, 최상위 비트는이 장치의 마지막 비트입니다. 따라서 &lt;code&gt;int&lt;/code&gt; 배열을 전달 하면 프로세서의 엔디안에 따라 다른 &lt;code&gt;BitArray&lt;/code&gt; 가 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="eeb9274b7abe5ec5313e249b7496b6be61a66b8b" translate="yes" xml:space="preserve">
          <source>The left operand of the &lt;code&gt;,&lt;/code&gt; is evaluated, then the right operand is evaluated. The type of the expression is the type of the right operand, and the result is the result of the right operand. Using the result of comma expressions isn't allowed.</source>
          <target state="translated">의 왼쪽 피연산자는 &lt;code&gt;,&lt;/code&gt; 다음 오른쪽 피연산자가 평가되고 평가된다. 표현식의 유형은 오른쪽 피연산자의 유형이며 결과는 오른쪽 피연산자의 결과입니다. 쉼표 표현식의 결과를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f0716ee491b6b3f2e07375f7797e5c102ad33bdc" translate="yes" xml:space="preserve">
          <source>The left-hand side (or sole) argument</source>
          <target state="translated">왼쪽 (또는 단독) 인수</target>
        </trans-unit>
        <trans-unit id="4d310cf569bfdf7161ed54cffc976e1b48e7851c" translate="yes" xml:space="preserve">
          <source>The left-hand side of the comparison (&lt;code&gt;Lhs&lt;/code&gt; is the first argument to &lt;code&gt;Checked&lt;/code&gt;)</source>
          <target state="translated">비교의 왼쪽 ( &lt;code&gt;Lhs&lt;/code&gt; 는 &lt;code&gt;Checked&lt;/code&gt; 의 첫 번째 인수입니다 )</target>
        </trans-unit>
        <trans-unit id="204d5f370e11576f0fecb8929fdcdb88b117af5c" translate="yes" xml:space="preserve">
          <source>The left-hand side of the comparison (&lt;code&gt;T&lt;/code&gt; is the first argument to &lt;code&gt;Checked&lt;/code&gt;)</source>
          <target state="translated">비교의 왼쪽 ( &lt;code&gt;T&lt;/code&gt; 는 &lt;code&gt;Checked&lt;/code&gt; 의 첫 번째 인수 )</target>
        </trans-unit>
        <trans-unit id="4fefd353c917f9a3bb60b52cf3d51cddee41a3f3" translate="yes" xml:space="preserve">
          <source>The left-hand side of the comparison for equality</source>
          <target state="translated">평등 비교의 왼쪽</target>
        </trans-unit>
        <trans-unit id="2b109cf29bece1affa9b23e640454252b8ecd16d" translate="yes" xml:space="preserve">
          <source>The left-hand side of the comparison for ordering</source>
          <target state="translated">주문 비교를위한 왼쪽</target>
        </trans-unit>
        <trans-unit id="ae7fc7c90c99a250cd16f28bd7d7dbc3b81e86a8" translate="yes" xml:space="preserve">
          <source>The left-hand side of the operator</source>
          <target state="translated">운전자의 왼쪽</target>
        </trans-unit>
        <trans-unit id="b4517c6bf6d758579387be92cded7d53dd545722" translate="yes" xml:space="preserve">
          <source>The left-hand side of the operator (&lt;code&gt;Lhs&lt;/code&gt; is the first argument to &lt;code&gt;Checked&lt;/code&gt;)</source>
          <target state="translated">연산자의 왼쪽입니다 ( &lt;code&gt;Lhs&lt;/code&gt; 는 &lt;code&gt;Checked&lt;/code&gt; 의 첫 번째 인수입니다 )</target>
        </trans-unit>
        <trans-unit id="1d155e4a7561179c70fb7012ae70744e878991c7" translate="yes" xml:space="preserve">
          <source>The left-hand side operand</source>
          <target state="translated">왼쪽 피연산자</target>
        </trans-unit>
        <trans-unit id="56ecf39f32678f6ba12fdb543c053bc2a2538cfe" translate="yes" xml:space="preserve">
          <source>The left-hand side operand (&lt;code&gt;Lhs&lt;/code&gt; is the first argument to &lt;code&gt;Checked&lt;/code&gt;)</source>
          <target state="translated">왼쪽 피연산자 ( &lt;code&gt;Lhs&lt;/code&gt; 는 &lt;code&gt;Checked&lt;/code&gt; 의 첫 번째 인수입니다 )</target>
        </trans-unit>
        <trans-unit id="fdc93a0d76b637886498906e463f3074234e7249" translate="yes" xml:space="preserve">
          <source>The leftmost side of the inheritance graph of the interfaces all share their vptrs, this is the single inheritance model. Every time the inheritance graph forks (for multiple inheritance) a new vptr is created and stored in the class' instance. Every time a virtual method is overridden, a new vtbl[] must be created with the updated method pointers in it.</source>
          <target state="translated">인터페이스의 상속 그래프의 가장 왼쪽은 모두 vptr을 공유합니다. 이것이 단일 상속 모델입니다. 상속 그래프가 다중 상속을 위해 분기 될 때마다 새로운 vptr이 생성되어 클래스의 인스턴스에 저장됩니다. 가상 메서드를 재정의 할 때마다 업데이트 된 메서드 포인터를 사용하여 새로운 vtbl []을 만들어야합니다.</target>
        </trans-unit>
        <trans-unit id="f8ab85ff43a9b405f7f858dd6bd44661050bcbfb" translate="yes" xml:space="preserve">
          <source>The leftover portion of &lt;code&gt;tgt&lt;/code&gt; after all elements from &lt;code&gt;src&lt;/code&gt; have been moved.</source>
          <target state="translated">&lt;code&gt;src&lt;/code&gt; 의 모든 요소 가 이동 한 후 &lt;code&gt;tgt&lt;/code&gt; 의 남은 부분 .</target>
        </trans-unit>
        <trans-unit id="ff1f6ec0205e886692fcbf4cdbd24c49883d76fd" translate="yes" xml:space="preserve">
          <source>The leftover portions of the two ranges after one or the other of the ranges have been exhausted.</source>
          <target state="translated">하나 또는 다른 범위가 소진 된 후 두 범위의 남은 부분.</target>
        </trans-unit>
        <trans-unit id="4aa5bf288555be6562c9b8eb71a2ee00b9edbaea" translate="yes" xml:space="preserve">
          <source>The legal types of arithmetic for &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; using this operator are</source>
          <target state="translated">이 연산자를 사용 하는 &lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 의 유효한 산술 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="06d117fb1568b3c185b1dd70cf5e4111bec8c49d" translate="yes" xml:space="preserve">
          <source>The legal types of arithmetic for &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; using this operator are</source>
          <target state="translated">이 연산자를 사용 하는 &lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 의 유효한 산술 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="31c5da3679aa5d6d97a971e899c7a8329e3f0d92" translate="yes" xml:space="preserve">
          <source>The legal types of arithmetic for &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; using this operator are</source>
          <target state="translated">이 연산자를 사용 하는 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; 에&lt;/a&gt; 대한 올바른 유형의 산술</target>
        </trans-unit>
        <trans-unit id="1d00a55c762fc066020331efbb630b4cfc23721c" translate="yes" xml:space="preserve">
          <source>The legal types of arithmetic for &lt;a href=&quot;#TimeOfDay&quot;&gt;&lt;code&gt;TimeOfDay&lt;/code&gt;&lt;/a&gt; using this operator are</source>
          <target state="translated">이 연산자를 사용 하는 &lt;a href=&quot;#TimeOfDay&quot;&gt; &lt;code&gt;TimeOfDay&lt;/code&gt; &lt;/a&gt; 에 대한 유효한 산술 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e029991ebf163a2ec03f499fc47cd21941b26f69" translate="yes" xml:space="preserve">
          <source>The legal types of arithmetic for &lt;code&gt;Duration&lt;/code&gt; using this operator are</source>
          <target state="translated">이 연산자를 사용 하는 &lt;code&gt;Duration&lt;/code&gt; 동안 유효한 산술 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2131ddc8b843bbfb7a2f56781e6183f4a90599d7" translate="yes" xml:space="preserve">
          <source>The legal types of arithmetic for &lt;code&gt;Duration&lt;/code&gt; using this operator overload are</source>
          <target state="translated">이 연산자 오버로드를 사용 하는 &lt;code&gt;Duration&lt;/code&gt; 의 유효한 산술 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5584f88d5b275ee008fabf19cf9bf9477c6ef1e2" translate="yes" xml:space="preserve">
          <source>The legal types of arithmetic for &lt;code&gt;TickDuration&lt;/code&gt; using this operator are</source>
          <target state="translated">이 연산자를 사용 하는 &lt;code&gt;TickDuration&lt;/code&gt; 의 올바른 유형의 산술은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c5479006c238183b17f8e4535d66092bdb92a1fe" translate="yes" xml:space="preserve">
          <source>The legal types of arithmetic for &lt;code&gt;TickDuration&lt;/code&gt; using this operator overload are</source>
          <target state="translated">이 연산자 오버로드를 사용 하는 &lt;code&gt;TickDuration&lt;/code&gt; 의 올바른 유형의 산술은 다음 과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0bd23cc00d282f158f381c5c9ffe519dc3f30f3b" translate="yes" xml:space="preserve">
          <source>The length dimension(s) of the resulting array</source>
          <target state="translated">결과 배열의 길이 치수</target>
        </trans-unit>
        <trans-unit id="44d89bfdd05d1a58a582eeedae0d9a14e3912d91" translate="yes" xml:space="preserve">
          <source>The length of a Base64 encoding of an array of the given length.</source>
          <target state="translated">주어진 길이의 배열에 대한 Base64 인코딩의 길이입니다.</target>
        </trans-unit>
        <trans-unit id="a5db64910ec8c3458fc1370fda6dd6afe4df6242" translate="yes" xml:space="preserve">
          <source>The length of the Base64 encoding.</source>
          <target state="translated">Base64 인코딩의 길이입니다.</target>
        </trans-unit>
        <trans-unit id="a6c0235529e0d9db5d811993877bcc8428ae8800" translate="yes" xml:space="preserve">
          <source>The length of the decoded string corresponding to a Base64 encoding of length sourceLength.</source>
          <target state="translated">길이 sourceLength의 Base64 인코딩에 해당하는 디코딩 된 문자열의 길이입니다.</target>
        </trans-unit>
        <trans-unit id="11a141a49e0a68aaa17cb7bd6222ca0a80676913" translate="yes" xml:space="preserve">
          <source>The length of the initial segment of &lt;code&gt;r&lt;/code&gt; to sort.</source>
          <target state="translated">정렬 할 &lt;code&gt;r&lt;/code&gt; 의 초기 세그먼트 길이입니다 .</target>
        </trans-unit>
        <trans-unit id="79633e883a28c37fc7cd1efc3c868307222fbc17" translate="yes" xml:space="preserve">
          <source>The length of the resulting range is the sum of all lengths of the ranges passed as input. This means that all elements (duplicates included) are transferred to the resulting range.</source>
          <target state="translated">결과 범위의 길이는 입력으로 전달 된 범위의 모든 길이의 합입니다. 이는 모든 요소 (중복 포함)가 결과 범위로 전송됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="e1ae840eb910889a7516866d4d199999a725e819" translate="yes" xml:space="preserve">
          <source>The length of the token is known to be 40 characters long due to its format, so the attacker first sends &lt;code&gt;&quot;0000000000000000000000000000000000000000&quot;&lt;/code&gt;, then &lt;code&gt;&quot;1000000000000000000000000000000000000000&quot;&lt;/code&gt;, and so on.</source>
          <target state="translated">토큰 길이는 형식으로 인해 길이가 40자인 것으로 알려져 있으므로 공격자는 먼저 &lt;code&gt;&quot;0000000000000000000000000000000000000000&quot;&lt;/code&gt; 을 보낸 다음 &lt;code&gt;&quot;1000000000000000000000000000000000000000&quot;&lt;/code&gt; 등 을 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="1987089f20ee0b5d2ec2f8112d140a36df239f5b" translate="yes" xml:space="preserve">
          <source>The level at which a socket option is defined.</source>
          <target state="translated">소켓 옵션이 정의되는 수준.</target>
        </trans-unit>
        <trans-unit id="b86bd023c662d4e208c258be711aadc0b1b2efae" translate="yes" xml:space="preserve">
          <source>The level at which a socket option is defined:</source>
          <target state="translated">소켓 옵션이 정의되는 레벨 :</target>
        </trans-unit>
        <trans-unit id="2ae0654a2a0ebe273a0d01c5f266e55c0eaa1eb7" translate="yes" xml:space="preserve">
          <source>The lexical analysis is independent of the syntax parsing and the semantic analysis. The lexical analyzer splits the source text up into tokens. The lexical grammar describes the syntax of these tokens. The grammar is designed to be suitable for high speed scanning and to make it easy to write a correct scanner. It has a minimum of special case rules and there is only one phase of translation.</source>
          <target state="translated">어휘 분석은 구문 분석 및 의미 분석과 독립적입니다. 어휘 분석기는 소스 텍스트를 토큰으로 분할합니다. 어휘 문법은 이러한 토큰의 구문을 설명합니다. 문법은 고속 스캔에 적합하고 올바른 스캐너를 쉽게 작성할 수 있도록 설계되었습니다. 최소한의 특수 사례 규칙이 있으며 번역 단계가 하나뿐입니다.</target>
        </trans-unit>
        <trans-unit id="f491d891c138db3f9bceff46473b495e216f49dc" translate="yes" xml:space="preserve">
          <source>The lexical analysis is independent of the syntax parsing and the semantic analysis. The lexical analyzer splits the source text up into tokens. The lexical grammar describes the syntax of those tokens. The grammar is designed to be suitable for high speed scanning and to make it easy to write a correct scanner for it. It has a minimum of special case rules and there is only one phase of translation.</source>
          <target state="translated">어휘 분석은 구문 분석 및 의미 분석과 무관합니다. 어휘 분석기는 소스 텍스트를 토큰으로 분할합니다. 어휘 문법은 이러한 토큰의 구문을 설명합니다. 문법은 고속 스캔에 적합하고 올바른 스캐너를 쉽게 작성할 수 있도록 설계되었습니다. 특수한 경우 최소 규칙이 있으며 번역의 한 단계 만 있습니다.</target>
        </trans-unit>
        <trans-unit id="64fc62f1647f32635083b06c594d00bb08d6c211" translate="yes" xml:space="preserve">
          <source>The lexical order of the attributes &lt;code&gt;ref&lt;/code&gt;, &lt;code&gt;return&lt;/code&gt;, and &lt;code&gt;scope&lt;/code&gt; is not significant.</source>
          <target state="translated">&lt;code&gt;ref&lt;/code&gt; , &lt;code&gt;return&lt;/code&gt; 및 &lt;code&gt;scope&lt;/code&gt; 속성의 어휘 순서는 중요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ecb003b0d2de026222073a3d8a4296c476e97462" translate="yes" xml:space="preserve">
          <source>The lifetime of a Borrowed or Readonly pointer value starts when it is assigned a value from an Owner or another Borrowed pointer, and ends at the last read of that value.</source>
          <target state="translated">Borrowed 또는 Readonly 포인터 값의 수명은 Owner 또는 다른 Borrowed 포인터의 값이 할당 될 때 시작되고 해당 값의 마지막 읽기에서 끝납니다.</target>
        </trans-unit>
        <trans-unit id="f68c7b698966b101a1a595982c2044cc2a404192" translate="yes" xml:space="preserve">
          <source>The line number information from where the call originates</source>
          <target state="translated">통화가 시작된 회선 번호 정보</target>
        </trans-unit>
        <trans-unit id="630ea807f4230ab332463ca98ac961bf9f44e6d5" translate="yes" xml:space="preserve">
          <source>The line number of the D source code corresponding with where the error was thrown from.</source>
          <target state="translated">오류가 발생한 위치에 해당하는 D 소스 코드의 행 번호입니다.</target>
        </trans-unit>
        <trans-unit id="229e0a2bdd93317a19e4a68e09629b3b6f154aca" translate="yes" xml:space="preserve">
          <source>The line number of the caller.</source>
          <target state="translated">발신자의 회선 번호입니다.</target>
        </trans-unit>
        <trans-unit id="0ad55de99f59d99a8ffdf4bac1fdfeed484559cb" translate="yes" xml:space="preserve">
          <source>The line number on which this error occurred.</source>
          <target state="translated">이 오류가 발생한 줄 번호입니다.</target>
        </trans-unit>
        <trans-unit id="b99341808eb5c2aeef537e3bc3ba23e7d2391ae4" translate="yes" xml:space="preserve">
          <source>The line number that the &lt;a href=&quot;#DateTimeException&quot;&gt;&lt;code&gt;DateTimeException&lt;/code&gt;&lt;/a&gt; will list if thrown.</source>
          <target state="translated">발생 된 경우 &lt;a href=&quot;#DateTimeException&quot;&gt; &lt;code&gt;DateTimeException&lt;/code&gt; &lt;/a&gt; 이 나열 할 행 번호입니다 .</target>
        </trans-unit>
        <trans-unit id="f269870f6d1360520fe00512e2c2e3c4c0c50b6e" translate="yes" xml:space="preserve">
          <source>The line number where the exception occurred.</source>
          <target state="translated">예외가 발생한 줄 번호입니다.</target>
        </trans-unit>
        <trans-unit id="f737b0208cdb15cf160156fb11b96cdbc64efed4" translate="yes" xml:space="preserve">
          <source>The line terminator (&lt;code&gt;'\n'&lt;/code&gt; by default) is part of the string read (it could be missing in the last line of the file). Several types are supported for &lt;code&gt;line&lt;/code&gt;, and the behavior of &lt;code&gt;lines&lt;/code&gt; changes accordingly:</source>
          <target state="translated">줄 종결 자 ( 기본적으로 &lt;code&gt;'\n'&lt;/code&gt; )는 읽은 문자열의 일부입니다 (파일의 마지막 줄에서 누락 될 수 있음). &lt;code&gt;line&lt;/code&gt; 에 여러 유형이 지원되며 그에 따라 &lt;code&gt;lines&lt;/code&gt; 의 동작이 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="4223574eefbbf292923ac805daa2d742c2ceff1c" translate="yes" xml:space="preserve">
          <source>The line that was read, including the line terminator character.</source>
          <target state="translated">줄 종결 자 문자를 포함하여 읽은 줄.</target>
        </trans-unit>
        <trans-unit id="0c791857d998bbf0bb74dbde8821e8c09defc3d6" translate="yes" xml:space="preserve">
          <source>The line where the error occurred.</source>
          <target state="translated">오류가 발생한 줄입니다.</target>
        </trans-unit>
        <trans-unit id="5ba806293f71618709ac5ca5570d100d47098201" translate="yes" xml:space="preserve">
          <source>The line where the error occurred. Defaults to &lt;code&gt;__LINE__&lt;/code&gt;.</source>
          <target state="translated">오류가 발생한 줄입니다. 기본값은 &lt;code&gt;__LINE__&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c9ec5dcfd170a3e54aa2b0486e8b3a659ecba856" translate="yes" xml:space="preserve">
          <source>The linkage form &lt;code&gt;extern (C++, &lt;/code&gt;</source>
          <target state="translated">연결 형식 &lt;code&gt;extern (C++, &lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1a68509fefd64796f7d1a07f49a259470873e621" translate="yes" xml:space="preserve">
          <source>The linkage is recognized on all platforms but will issue a compile error if it is used on a platform where Objective-C support is not available. This allows to easily hide Objective-C declarations from platforms where it is not available using the &lt;a href=&quot;version#version&quot;&gt;&lt;code&gt;version&lt;/code&gt;&lt;/a&gt; statement, without resorting to string mixins or other workarounds.</source>
          <target state="translated">연결은 모든 플랫폼에서 인식되지만 Objective-C 지원을 사용할 수없는 플랫폼에서 사용되는 경우 컴파일 오류가 발생합니다. 따라서 문자열 믹스 인 또는 다른 해결 방법을 사용하지 않고 &lt;a href=&quot;version#version&quot;&gt; &lt;code&gt;version&lt;/code&gt; &lt;/a&gt; 문을 사용하여 사용할 수없는 플랫폼에서 Objective-C 선언을 쉽게 숨길 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ee2dc34efb622f40653a49dbfe76ceb8d1ee0eff" translate="yes" xml:space="preserve">
          <source>The list of allowed types. If empty, any type is allowed.</source>
          <target state="translated">허용되는 유형의 목록입니다. 비어 있으면 모든 유형이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="7d752b3e0c165ac9972ad67362f39567c19601ad" translate="yes" xml:space="preserve">
          <source>The literal may not exceed the range of the type. The literal is rounded to fit into the significant digits of the type.</source>
          <target state="translated">리터럴은 유형의 범위를 초과 할 수 없습니다. 리터럴은 유형의 유효 숫자에 맞게 반올림됩니다.</target>
        </trans-unit>
        <trans-unit id="cfda6f32ee8182b11470321e18429ff54847d85e" translate="yes" xml:space="preserve">
          <source>The local part is in a deprecated form</source>
          <target state="translated">로컬 부분은 더 이상 사용되지 않는 형식입니다.</target>
        </trans-unit>
        <trans-unit id="6f51eadb663d2759618c2c7f55ed73ce81e81662" translate="yes" xml:space="preserve">
          <source>The local part of the address is too long</source>
          <target state="translated">주소의 로컬 부분이 너무 깁니다</target>
        </trans-unit>
        <trans-unit id="d43703ab62f0fdfb0730decc44b9accfe993fc48" translate="yes" xml:space="preserve">
          <source>The local part of the email address, that is, the part before the @ sign.</source>
          <target state="translated">이메일 주소의 로컬 부분, 즉 @ 기호 앞 부분입니다.</target>
        </trans-unit>
        <trans-unit id="fb2b16bfeb403dd9d23822ef47a96282d2506733" translate="yes" xml:space="preserve">
          <source>The logger used by the logging function as reference.</source>
          <target state="translated">로깅 기능이 참조로 사용하는 로거.</target>
        </trans-unit>
        <trans-unit id="9dc35ce16bcd5e0f3997b30f4a3a933ead8e2be7" translate="yes" xml:space="preserve">
          <source>The long</source>
          <target state="translated">긴</target>
        </trans-unit>
        <trans-unit id="cdce859b555eda9a366f161871fcdb633ee5b0eb" translate="yes" xml:space="preserve">
          <source>The long symbol for this option</source>
          <target state="translated">이 옵션의 긴 기호</target>
        </trans-unit>
        <trans-unit id="eb826857f96e2fa8c72d4f984e7520701feb3d3d" translate="yes" xml:space="preserve">
          <source>The loop is correctly written:</source>
          <target state="translated">루프가 올바르게 작성되었습니다.</target>
        </trans-unit>
        <trans-unit id="80cd3f025f71ab9fb6d037c50456d7fb59577d15" translate="yes" xml:space="preserve">
          <source>The lower bound of the clamp.</source>
          <target state="translated">클램프의 하한.</target>
        </trans-unit>
        <trans-unit id="c3ba355fcfd258cdc3b0962e2c92c7fd02aec3ad" translate="yes" xml:space="preserve">
          <source>The macro &quot;##&quot; is ISO C, we assume pre-ISO C doesn't support it.</source>
          <target state="translated">매크로 &quot;##&quot;는 ISO C입니다. ISO C 이전은 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4493cedee574dfabffbc81a40e14a5b6a3a6b77b" translate="yes" xml:space="preserve">
          <source>The macros section follows the same syntax as the &lt;b&gt;Params:&lt;/b&gt; section. It's a series of</source>
          <target state="translated">매크로 섹션은 &lt;b&gt;Params :&lt;/b&gt; 섹션 과 동일한 구문을 따릅니다 . 일련의</target>
        </trans-unit>
        <trans-unit id="cf6c8468c449f6bacda719f4e15ba7d61861d0e7" translate="yes" xml:space="preserve">
          <source>The magnitude is an &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; of unsigned integers that satisfies either &lt;a href=&quot;std_range_primitives#hasLength&quot;&gt;&lt;code&gt;std.range.primitives.hasLength&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;&lt;code&gt;std.range.primitives.isForwardRange&lt;/code&gt;&lt;/a&gt;. The first (leftmost) element of the magnitude is considered the most significant.</source>
          <target state="translated">크기는 &lt;a href=&quot;std_range_primitives#hasLength&quot;&gt; &lt;code&gt;std.range.primitives.hasLength&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt; &lt;code&gt;std.range.primitives.isForwardRange&lt;/code&gt; &lt;/a&gt; 를 충족하는 부호없는 정수 의 &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;입력 범위&lt;/a&gt; 입니다 . 크기의 첫 번째 (가장 왼쪽) 요소가 가장 중요한 요소로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="7ae8a3b1299a2612db122fcc08bc88452fa0e22f" translate="yes" xml:space="preserve">
          <source>The magnitude of x is limited to about 106.56 for IEEE 80-bit arithmetic; 1 or -1 is returned outside this range.</source>
          <target state="translated">x의 크기는 IEEE 80 비트 산술의 경우 약 106.56으로 제한됩니다. 이 범위를 벗어나면 1 또는 -1이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="327523b3c0bae538d6dd857c0b63c542d4c2e3ff" translate="yes" xml:space="preserve">
          <source>The main &lt;a href=&quot;std_range&quot;&gt;&lt;code&gt;std.range&lt;/code&gt;&lt;/a&gt; module provides template-based tools for working with ranges, but sometimes an object-based interface for ranges is needed, such as when runtime polymorphism is required. For this purpose, this submodule provides a number of object and &lt;code&gt;interface&lt;/code&gt; definitions that can be used to wrap around range objects created by the &lt;a href=&quot;std_range&quot;&gt;&lt;code&gt;std.range&lt;/code&gt;&lt;/a&gt; templates.</source>
          <target state="translated">기본 &lt;a href=&quot;std_range&quot;&gt; &lt;code&gt;std.range&lt;/code&gt; &lt;/a&gt; 모듈은 범위 작업을위한 템플릿 기반 도구를 제공하지만 때로는 런타임 다형성이 필요한 경우와 같이 범위에 대한 객체 기반 인터페이스가 필요합니다. 이를 위해이 서브 모듈은 &lt;a href=&quot;std_range&quot;&gt; &lt;code&gt;std.range&lt;/code&gt; &lt;/a&gt; 템플리트로 작성된 범위 오브젝트를 랩핑하는 데 사용할 수 있는 많은 오브젝트 및 &lt;code&gt;interface&lt;/code&gt; 정의를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="3c02f05cd38724c7e8cb17756e9c5152cd9c1060" translate="yes" xml:space="preserve">
          <source>The main entry point for garbage collection. The supplied delegate will be passed ranges representing both stack and register values.</source>
          <target state="translated">가비지 수집의 주요 진입 점입니다. 제공된 델리게이트에는 스택 및 레지스터 값을 모두 나타내는 범위가 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="70a5f20578712db84e71fcdbe8fd245260ba0674" translate="yes" xml:space="preserve">
          <source>The main reasons that a program might need to use ticks directly is if the system clock has higher precision than hnsecs, and the program needs that higher precision, or if the program needs to avoid the rounding errors caused by converting to hnsecs.</source>
          <target state="translated">프로그램에서 틱을 직접 사용해야하는 주된 이유는 시스템 클럭의 정밀도가 hnsecs보다 높고 프로그램의 정밀도가 높거나 프로그램이 hnsecs로 변환하여 발생하는 반올림 오류를 피해야하는 경우입니다.</target>
        </trans-unit>
        <trans-unit id="99346c9361ee044918b5692d75d84b05203809b4" translate="yes" xml:space="preserve">
          <source>The main uses cases for &lt;code&gt;WorkerLocalStorageStorage&lt;/code&gt; are:</source>
          <target state="translated">&lt;code&gt;WorkerLocalStorageStorage&lt;/code&gt; 의 주요 사용 사례는 다음 과 같습니다.</target>
        </trans-unit>
        <trans-unit id="37721286eae1f656c81db469ea0c2aa0407bd201" translate="yes" xml:space="preserve">
          <source>The major 32-bit x86 microarchitecture 'dynasties' have been:</source>
          <target state="translated">주요 32 비트 x86 마이크로 아키텍처 'dynaties'는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="982a1e7c4fc73fa370e90c954afb1f355930cd55" translate="yes" xml:space="preserve">
          <source>The managed array.</source>
          <target state="translated">관리 형 배열.</target>
        </trans-unit>
        <trans-unit id="24b3c10fb402cc3696f43a7e032402872866e5ae" translate="yes" xml:space="preserve">
          <source>The mangled name for a function with function pointer type T and the given fully qualified name.</source>
          <target state="translated">함수 포인터 유형이 T이고 주어진 정규화 된 이름을 가진 함수의 맹 글링 된 이름입니다.</target>
        </trans-unit>
        <trans-unit id="2222f24e9ff7ad414fdd6df5db1a3a27354c9552" translate="yes" xml:space="preserve">
          <source>The mangled name for a symbols of type T and the given fully qualified name.</source>
          <target state="translated">T 유형의 기호에 대한 맹 글링 된 이름과 지정된 정규화 된 이름.</target>
        </trans-unit>
        <trans-unit id="582a49c9af38036e1960cd170f7932701e0fb6f3" translate="yes" xml:space="preserve">
          <source>The mangled name with deduplicated identifiers</source>
          <target state="translated">중복 제거 된 식별자가있는 맹 글링 된 이름</target>
        </trans-unit>
        <trans-unit id="08774dd4c4d75e3bd42a748ee71506481a4f0a1b" translate="yes" xml:space="preserve">
          <source>The mangled string representing the type</source>
          <target state="translated">유형을 나타내는 맹 글링 된 문자열</target>
        </trans-unit>
        <trans-unit id="40a84060f0327e9db3cfd8bbb21dc9782f40397c" translate="yes" xml:space="preserve">
          <source>The manner in which to display the output of each &lt;code&gt;Option.&lt;/code&gt;</source>
          <target state="translated">각 &lt;code&gt;Option.&lt;/code&gt; 의 출력을 표시하는 방법입니다 .</target>
        </trans-unit>
        <trans-unit id="aa7ae029a5326a80d32c23d17dde2c45ccbc8321" translate="yes" xml:space="preserve">
          <source>The mapping of package and module identifiers to directory and file names.</source>
          <target state="translated">패키지 및 모듈 식별자를 디렉토리 및 파일 이름에 매핑</target>
        </trans-unit>
        <trans-unit id="43effc8161287353136863e8d2f53a67a4ef703b" translate="yes" xml:space="preserve">
          <source>The max aliases are the largest integral types:</source>
          <target state="translated">최대 별칭은 가장 큰 정수 유형입니다.</target>
        </trans-unit>
        <trans-unit id="986ee926972449f806f769e32d7dd4ba24b84874" translate="yes" xml:space="preserve">
          <source>The maximal element of the passed-in range.</source>
          <target state="translated">전달 된 범위의 최대 요소입니다.</target>
        </trans-unit>
        <trans-unit id="ae723b7ad52bbfa1e17cf08fd49aa1b7abbdc458" translate="yes" xml:space="preserve">
          <source>The maximum allowed nesting level.</source>
          <target state="translated">허용되는 최대 중첩 수준입니다.</target>
        </trans-unit>
        <trans-unit id="c15b5870b72ff9ade8671f564f3ad47e5d8703b2" translate="yes" xml:space="preserve">
          <source>The maximum guarantee of &lt;code&gt;pure&lt;/code&gt; is called &quot;strong purity&quot;. It can enable optimizations based on the fact that a function is guaranteed to not mutate anything which isn't passed to it. For cases where the compiler can guarantee that a pure function cannot alter its arguments, it can enable full, functional purity (i.e. the guarantee that the function will always return the same result for the same arguments). To that end, a pure function:</source>
          <target state="translated">&lt;code&gt;pure&lt;/code&gt; 의 최대 보증을 &quot;강한 순도&quot;라고합니다. 함수가 전달되지 않은 것을 변경하지 않도록 보장한다는 사실을 기반으로 최적화를 활성화 할 수 있습니다. 컴파일러가 순수 함수가 인수를 변경할 수 없음을 보장 할 수있는 경우 완전한 기능 순도를 사용할 수 있습니다 (즉, 함수가 항상 동일한 인수에 대해 동일한 결과를 리턴하도록 보장 할 수 있음). 이를 위해 순수한 기능 :</target>
        </trans-unit>
        <trans-unit id="c855c6313f529356306d651f3e145813bb160323" translate="yes" xml:space="preserve">
          <source>The maximum length of &lt;code&gt;filename&lt;/code&gt; is given by the constant &lt;code&gt;core.stdc.stdio.FILENAME_MAX&lt;/code&gt;. (On Windows, this number is defined as the maximum number of UTF-16 code points, and the test will therefore only yield strictly correct results when &lt;code&gt;filename&lt;/code&gt; is a string of &lt;code&gt;wchar&lt;/code&gt;s.)</source>
          <target state="translated">&lt;code&gt;filename&lt;/code&gt; 의 최대 길이 는 상수 &lt;code&gt;core.stdc.stdio.FILENAME_MAX&lt;/code&gt; 에 의해 제공됩니다 . (Windows에서이 숫자는 최대 UTF-16 코드 포인트 수로 정의되므로 &lt;code&gt;filename&lt;/code&gt; 이 &lt;code&gt;wchar&lt;/code&gt; 문자열 인 경우 테스트에서 정확한 결과 만 제공 합니다.)</target>
        </trans-unit>
        <trans-unit id="05e735a756b3fa2f43497424f8b3020883222ceb" translate="yes" xml:space="preserve">
          <source>The maximum number of bytes of output that should be captured.</source>
          <target state="translated">캡처해야하는 최대 출력 바이트 수입니다.</target>
        </trans-unit>
        <trans-unit id="f3e3e4f751fc559f30cd92f8522a3febd435ec99" translate="yes" xml:space="preserve">
          <source>The maximum number of elements the array can store without reallocating memory and invalidating iterators upon insertion.</source>
          <target state="translated">삽입시 메모리를 재 할당하고 반복자를 무효화하지 않고 어레이가 저장할 수있는 최대 요소 수입니다.</target>
        </trans-unit>
        <trans-unit id="ff490f34a5e2c376eac774681e1598898ac5391d" translate="yes" xml:space="preserve">
          <source>The maximum number of messages or zero if no limit.</source>
          <target state="translated">최대 메시지 수 또는 제한이 없으면 0입니다.</target>
        </trans-unit>
        <trans-unit id="23ffb3d6838b02986026c5eeb543b889e4e64af2" translate="yes" xml:space="preserve">
          <source>The maximum of the passed-in args. The type of the returned value is the type among the passed arguments that is able to store the largest value.</source>
          <target state="translated">전달 된 인수의 최대 값입니다. 리턴 된 값의 유형은 가장 큰 값을 저장할 수있는 전달 된 인수 중 유형입니다.</target>
        </trans-unit>
        <trans-unit id="e3f981b26c63cbef1dde8cf88e0c6fd5a78eba99" translate="yes" xml:space="preserve">
          <source>The maximum of the passed-in values. The type of the returned value is the type among the passed arguments that is able to store the largest value. If at least one of the arguments is NaN, the result is an unspecified value. See &lt;a href=&quot;std_algorithm_searching#maxElement&quot;&gt;&lt;code&gt;std.algorithm.searching.maxElement&lt;/code&gt;&lt;/a&gt; for examples on how to cope with NaNs.</source>
          <target state="translated">전달 된 값의 최대 값입니다. 반환되는 값의 유형은 전달 된 인수 중 가장 큰 값을 저장할 수있는 유형입니다. 인수 중 하나 이상이 NaN이면 결과는 지정되지 않은 값입니다. NaN에 대처하는 방법에 대한 예제는 &lt;a href=&quot;std_algorithm_searching#maxElement&quot;&gt; &lt;code&gt;std.algorithm.searching.maxElement&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7eb2470a27937a3494cee9a54b8062f651c54299" translate="yes" xml:space="preserve">
          <source>The maximum scheduling priority that may be set for a thread. On systems where multiple scheduling policies are defined, this value represents the maximum valid priority for the scheduling policy of the process.</source>
          <target state="translated">스레드에 대해 설정 될 수있는 최대 스케줄링 우선 순위. 다중 스케줄링 정책이 정의 된 시스템에서이 값은 프로세스의 스케줄링 정책에 대한 최대 유효 우선 순위를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f397747108afabbaad398b1bbfbbdd699e4c5ce8" translate="yes" xml:space="preserve">
          <source>The maximum size of the GC buffer to hold the return values</source>
          <target state="translated">리턴 값을 보유 할 GC 버퍼의 최대 크기</target>
        </trans-unit>
        <trans-unit id="075c481912178c8ac79090ee5b3669c3def2fbb2" translate="yes" xml:space="preserve">
          <source>The maximum value representable is &lt;code&gt;T.max&lt;/code&gt; for signed integrals, &lt;code&gt; T.max - 1&lt;/code&gt; for unsigned integrals. The minimum value representable is &lt;code&gt; T.min + 1&lt;/code&gt; for signed integrals, &lt;code&gt;0&lt;/code&gt; for unsigned integrals.</source>
          <target state="translated">최대 값 표현할 수는 &lt;code&gt;T.max&lt;/code&gt; , 서명 적분에 대한 &lt;code&gt; T.max - 1&lt;/code&gt; 부호 적분합니다. 표현 가능한 최소값 은 부호있는 적분의 경우 &lt;code&gt; T.min + 1&lt;/code&gt; , 부호없는 적분의 경우 &lt;code&gt;0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4957d9a3700ae6f7d93e51da85b7d5a4964d27b2" translate="yes" xml:space="preserve">
          <source>The mean of &lt;code&gt;r&lt;/code&gt; when &lt;code&gt;r&lt;/code&gt; is non-empty.</source>
          <target state="translated">의 평균 &lt;code&gt;r&lt;/code&gt; &lt;code&gt;r&lt;/code&gt; 은 비 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c587177906e3358831db8b1c6944ffdb24226077" translate="yes" xml:space="preserve">
          <source>The members are completely hidden to the user, and so the only operations on those types are ones that do not require any knowledge of the contents of those types. For example:</source>
          <target state="translated">멤버는 사용자에게 완전히 숨겨져 있으므로 해당 유형에 대한 유일한 조작은 해당 유형의 컨텐츠에 대한 지식이 필요하지 않은 조작입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="00dd946dd7ec09c0536b1658fc7e8ead520e7c8e" translate="yes" xml:space="preserve">
          <source>The memory is obtained from &lt;code&gt;SmallAllocator&lt;/code&gt; if &lt;code&gt;s &amp;lt;= threshold&lt;/code&gt;, or &lt;code&gt;LargeAllocator&lt;/code&gt; otherwise.</source>
          <target state="translated">메모리은 얻을 &lt;code&gt;SmallAllocator&lt;/code&gt; 만약 &lt;code&gt;s &amp;lt;= threshold&lt;/code&gt; 또는 &lt;code&gt;LargeAllocator&lt;/code&gt; 그렇지.</target>
        </trans-unit>
        <trans-unit id="f8c96911fea13cb1c02d9f105c0c295fa2deb239" translate="yes" xml:space="preserve">
          <source>The memory location of different memory blocks is not defined. Ordered comparison (&lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;) between two pointers is permitted when both pointers point to the same array, or when at least one pointer is &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">다른 메모리 블록의 메모리 위치는 정의되어 있지 않습니다. 두 포인터가 같은 배열을 가리 키거나 하나 이상의 포인터가 &lt;code&gt;null&lt;/code&gt; 인 경우 두 포인터 간의 순서 비교 ( &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;code&gt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;gt;=&lt;/code&gt; )가 허용됩니다 .</target>
        </trans-unit>
        <trans-unit id="fe0b84897743c23c53a5e9577a10299a7a7b020c" translate="yes" xml:space="preserve">
          <source>The memory usage of this implementation is guaranteed to be constant in &lt;code&gt;range.length&lt;/code&gt;.</source>
          <target state="translated">이 구현의 메모리 사용량은 &lt;code&gt;range.length&lt;/code&gt; 에서 일정하게 보장됩니다 .</target>
        </trans-unit>
        <trans-unit id="7609ac8f3cf653b1ce0270fa8139880a547a9eea" translate="yes" xml:space="preserve">
          <source>The message for the exception.</source>
          <target state="translated">예외 메시지입니다.</target>
        </trans-unit>
        <trans-unit id="4c338cd37584d6e6e69bd4c24d1ae2acb50b8634" translate="yes" xml:space="preserve">
          <source>The message that was sent.</source>
          <target state="translated">보낸 메시지입니다.</target>
        </trans-unit>
        <trans-unit id="68d612f02557a1940b9b2866c12015c2578745a2" translate="yes" xml:space="preserve">
          <source>The message to include in the &lt;code&gt;AssertError&lt;/code&gt; if the assumption turns out to be false.</source>
          <target state="translated">가정이 거짓으로 판명 된 경우 &lt;code&gt;AssertError&lt;/code&gt; 에 포함 할 메시지 입니다.</target>
        </trans-unit>
        <trans-unit id="488aa84d557c1a01800a687e8f424ca1dc36fdd6" translate="yes" xml:space="preserve">
          <source>The message to include in the &lt;code&gt;ErrnoException&lt;/code&gt; if it is thrown.</source>
          <target state="translated">던져 질 경우 &lt;code&gt;ErrnoException&lt;/code&gt; 에 포함 할 메시지 .</target>
        </trans-unit>
        <trans-unit id="79b8f8765c27119a953cd29d5a9f80179e617637" translate="yes" xml:space="preserve">
          <source>The metaclass of this class.</source>
          <target state="translated">이 클래스의 메타 클래스</target>
        </trans-unit>
        <trans-unit id="93cc36b0067843c6450f0911a4ca8b3ad0ea0493" translate="yes" xml:space="preserve">
          <source>The method used to enable or disable the unit tests. Use of a compiler switch such as &lt;a href=&quot;https://dlang.org/dmd.html#switch-unittest&quot;&gt;&lt;b&gt;-unittest&lt;/b&gt;&lt;/a&gt; to enable them is suggested.</source>
          <target state="translated">단위 테스트를 활성화 또는 비활성화하는 데 사용되는 방법입니다. &lt;a href=&quot;https://dlang.org/dmd.html#switch-unittest&quot;&gt;&lt;b&gt;-unittest&lt;/b&gt;&lt;/a&gt; 와 같은 컴파일러 스위치 를 사용하여 활성화하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="c6a75cd2237917d2ed85214e205b4f1cf25efd9f" translate="yes" xml:space="preserve">
          <source>The minimal element of the passed-in range.</source>
          <target state="translated">전달 된 범위의 최소 요소입니다.</target>
        </trans-unit>
        <trans-unit id="ab6714e3fe053113da2960956c8eb82b3e5bbc67" translate="yes" xml:space="preserve">
          <source>The minimal number of edits to transform s into t.  Does not allocate GC memory.</source>
          <target state="translated">s를 t로 변환하는 최소 편집 횟수입니다. GC 메모리를 할당하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="10a4be4f3adcabd3abe79325f2076e9b9a100888" translate="yes" xml:space="preserve">
          <source>The minimum duration the calling thread should be suspended.</source>
          <target state="translated">호출 스레드가 일시 중단되어야하는 최소 기간입니다.</target>
        </trans-unit>
        <trans-unit id="28711c27ca983081eb31b72306fa4a118f39be3b" translate="yes" xml:space="preserve">
          <source>The minimum extension size in bytes.</source>
          <target state="translated">바이트 단위의 최소 확장 크기입니다.</target>
        </trans-unit>
        <trans-unit id="c06ab7e4e215252c3c928d52e3071658c4a68764" translate="yes" xml:space="preserve">
          <source>The minimum of the passed-in values.</source>
          <target state="translated">전달 된 값의 최소값입니다.</target>
        </trans-unit>
        <trans-unit id="edffbb1612aecedbb9b2455ef9f7bc186445862c" translate="yes" xml:space="preserve">
          <source>The minimum of the passed-in values. The type of the returned value is the type among the passed arguments that is able to store the smallest value. If at least one of the arguments is NaN, the result is an unspecified value. See &lt;a href=&quot;std_algorithm_searching#minElement&quot;&gt;&lt;code&gt;std.algorithm.searching.minElement&lt;/code&gt;&lt;/a&gt; for examples on how to cope with NaNs.</source>
          <target state="translated">전달 된 값의 최소값입니다. 반환되는 값의 유형은 전달 된 인수 중 가장 작은 값을 저장할 수있는 유형입니다. 인수 중 하나 이상이 NaN이면 결과는 지정되지 않은 값입니다. NaN에 대처하는 방법에 대한 예제는 &lt;a href=&quot;std_algorithm_searching#minElement&quot;&gt; &lt;code&gt;std.algorithm.searching.minElement&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="95346b92b5307b71b43fcd27332d111b5c7b81cb" translate="yes" xml:space="preserve">
          <source>The minimum scheduling priority that may be set for a thread. On systems where multiple scheduling policies are defined, this value represents the minimum valid priority for the scheduling policy of the process.</source>
          <target state="translated">스레드에 대해 설정 될 수있는 최소 스케줄링 우선 순위. 다중 스케줄링 정책이 정의 된 시스템에서이 값은 프로세스의 스케줄링 정책에 대한 최소 유효 우선 순위를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="91d9db5c5ad3a0f6b05ff83250575799825e9e6d" translate="yes" xml:space="preserve">
          <source>The minimum, respectively maximum element of a range together with the number it occurs in the range.</source>
          <target state="translated">범위에서 발생하는 숫자와 함께 범위의 최소, 최대 요소.</target>
        </trans-unit>
        <trans-unit id="4776ba2a4d44664c280371c94d75db0a68aa7f47" translate="yes" xml:space="preserve">
          <source>The minute portion of the time;</source>
          <target state="translated">시간의 분;</target>
        </trans-unit>
        <trans-unit id="804dde72e3fca52bb6fee9e6c9a891f7a218393e" translate="yes" xml:space="preserve">
          <source>The minute to set this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;'s minute to.</source>
          <target state="translated">이 &lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 분을 설정하는 분 입니다.</target>
        </trans-unit>
        <trans-unit id="fd8186f6e2f846fa308524ef0f64113f0d7289dd" translate="yes" xml:space="preserve">
          <source>The minute to set this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;'s minute to.</source>
          <target state="translated">이 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; 분을 설정하는 분 입니다.</target>
        </trans-unit>
        <trans-unit id="80d86d248f3ac806d407ff7069134427130713b0" translate="yes" xml:space="preserve">
          <source>The minute to set this &lt;a href=&quot;#TimeOfDay&quot;&gt;&lt;code&gt;TimeOfDay&lt;/code&gt;&lt;/a&gt;'s minute to.</source>
          <target state="translated">이 &lt;a href=&quot;#TimeOfDay&quot;&gt; &lt;code&gt;TimeOfDay&lt;/code&gt; &lt;/a&gt; 분을 설정하는 분 입니다.</target>
        </trans-unit>
        <trans-unit id="de600cb5888514e99355f24b957b0d7134a283a8" translate="yes" xml:space="preserve">
          <source>The mode must be compatible with the mode of the file descriptor.</source>
          <target state="translated">모드는 파일 설명 자의 모드와 호환되어야합니다.</target>
        </trans-unit>
        <trans-unit id="204cac3357eeb22cb6ce425410ebf52a7b2c34ef" translate="yes" xml:space="preserve">
          <source>The mode the memory mapped file is opened with.</source>
          <target state="translated">메모리 매핑 된 파일을 여는 모드입니다.</target>
        </trans-unit>
        <trans-unit id="973816115210d9c45eb2bc6fdd4a572e4108483e" translate="yes" xml:space="preserve">
          <source>The modified &lt;a href=&quot;http://en.wikipedia.org/wiki/Julian_day&quot;&gt;Julian day&lt;/a&gt; for any time on this date (since, the modified Julian day changes at midnight).</source>
          <target state="translated">수정 된 &lt;a href=&quot;http://en.wikipedia.org/wiki/Julian_day&quot;&gt;율리우스 일&lt;/a&gt; 이 날짜에 언제든지 (이후 수정 된 율리우스 일 자정에 변경)합니다.</target>
        </trans-unit>
        <trans-unit id="860d6be9b0cf54ee441891db4a2fd6202c776fe2" translate="yes" xml:space="preserve">
          <source>The modifier to apply.</source>
          <target state="translated">적용 할 수정 자입니다.</target>
        </trans-unit>
        <trans-unit id="124f2941f2e52ecf62ccffc3b7646e3953931e7d" translate="yes" xml:space="preserve">
          <source>The modifiers of the &lt;code&gt;lhsMod&lt;/code&gt; mismatching the ones with the &lt;code&gt;rhsMod&lt;/code&gt; are printed, i.e. lhs(shared) vs. rhs() prints &quot;&lt;code&gt;shared&lt;/code&gt;&quot;, wheras lhs() vs rhs(shared) prints &quot;non-shared&quot;.</source>
          <target state="translated">의 수정 자 &lt;code&gt;lhsMod&lt;/code&gt; 을 가진 사람이 일치하지 &lt;code&gt;rhsMod&lt;/code&gt; 가 인쇄됩니다, 즉, 좌 (공유) 대 우 () 인쇄는 &quot; &lt;code&gt;shared&lt;/code&gt; 우 대 좌 ()가 (공유) 인쇄는&quot;비는 공유 &quot;wheras&quot;.</target>
        </trans-unit>
        <trans-unit id="95523edab7d804c0b6ab6eed37c8c3cadada1694" translate="yes" xml:space="preserve">
          <source>The module edges as found in the &lt;code&gt;importedModules&lt;/code&gt; member of each ModuleInfo. Generated in sortCtors.</source>
          <target state="translated">에서 발견 모듈은 에지 &lt;code&gt;importedModules&lt;/code&gt; 의 각 부재의 ModuleInfo. sortCtors에서 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="47af20b56ee3955f4fd47d6c7951eb2d036d5a4c" translate="yes" xml:space="preserve">
          <source>The module for this virtual table</source>
          <target state="translated">이 가상 테이블의 모듈</target>
        </trans-unit>
        <trans-unit id="cab05c206d3bb715fd01c040c88f5fe361c942e4" translate="yes" xml:space="preserve">
          <source>The modulus</source>
          <target state="translated">계수</target>
        </trans-unit>
        <trans-unit id="82131155f810a5f75ba3764eb1563b749deb3cf3" translate="yes" xml:space="preserve">
          <source>The monotonic clock has no relation to wall clock time. Rather, it holds its time as the number of ticks of the clock which have occurred since the clock started (typically when the system booted up). So, to determine how much time has passed between two points in time, one monotonic time is subtracted from the other to determine the number of ticks which occurred between the two points of time, and those ticks are divided by the number of ticks that occur every second (as represented by MonoTime.ticksPerSecond) to get a meaningful duration of time. Normally, MonoTime does these calculations for the programmer, but the &lt;code&gt;ticks&lt;/code&gt; and &lt;code&gt;ticksPerSecond&lt;/code&gt; properties are provided for those who require direct access to the system ticks. The normal way that MonoTime would be used is</source>
          <target state="translated">단조로운 시계는 벽시계 시간과 관련이 없습니다. 오히려, 시계가 시작된 이후 (일반적으로 시스템이 부팅 될 때) 발생한 시계의 틱 수로 시간을 유지합니다. 따라서 두 시점 사이에 경과 한 시간을 결정하기 위해 두 시점 사이에 발생한 틱 수를 결정하기 위해 한 단조 시간을 다른 시간에서 빼고 그 틱을 발생하는 틱 수로 나눕니다. 의미있는 시간을 얻기 위해 매초 (MonoTime.ticksPerSecond로 표시) 일반적으로 MonoTime은 프로그래머에 대해 이러한 계산을 수행하지만 시스템 눈금에 직접 액세스해야하는 사용자를 위해 &lt;code&gt;ticks&lt;/code&gt; 및 &lt;code&gt;ticksPerSecond&lt;/code&gt; 속성이 제공됩니다. MonoTime이 사용되는 일반적인 방법은</target>
        </trans-unit>
        <trans-unit id="d74977e8496820ecedeff19e20ade1b05de3e4b6" translate="yes" xml:space="preserve">
          <source>The month of the day to validate (January is 1).</source>
          <target state="translated">확인할 월 (1 월은 1)입니다.</target>
        </trans-unit>
        <trans-unit id="6ebaf2163e939c5ad1bf15c5f8dae4f8a043e786" translate="yes" xml:space="preserve">
          <source>The month of the day to validate.</source>
          <target state="translated">확인할 월입니다.</target>
        </trans-unit>
        <trans-unit id="d4d21752a92d87f995da2fa4e777f8856076f4d2" translate="yes" xml:space="preserve">
          <source>The month of the year to get the number of months to.</source>
          <target state="translated">개월 수를 구할 연도의 월입니다.</target>
        </trans-unit>
        <trans-unit id="3b03ba6279034200ca13bdea73b6dd032c6515f6" translate="yes" xml:space="preserve">
          <source>The month portion of the date (January is 1).</source>
          <target state="translated">날짜의 월 부분 (1 월은 1)입니다.</target>
        </trans-unit>
        <trans-unit id="e6fd335018a8476e0b61c3352fc0e3562dbfcc53" translate="yes" xml:space="preserve">
          <source>The month that each time point in the range will be in (January is 1).</source>
          <target state="translated">범위의 각 시점이있는 달 (1 월은 1)입니다.</target>
        </trans-unit>
        <trans-unit id="3a058535cdaf9aa70980ff68790ecdb70d352df1" translate="yes" xml:space="preserve">
          <source>The month to set this &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt;'s month to.</source>
          <target state="translated">이 &lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 월을 설정할 월입니다.</target>
        </trans-unit>
        <trans-unit id="b85e045063e5ffa8ef021269a9798226e87028d9" translate="yes" xml:space="preserve">
          <source>The month to set this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;'s month to.</source>
          <target state="translated">이 &lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 월을 설정할 월입니다.</target>
        </trans-unit>
        <trans-unit id="a9daf4d7ebc51fc3e649125b409fa21bb86aa474" translate="yes" xml:space="preserve">
          <source>The month to set this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;'s month to.</source>
          <target state="translated">이 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; 의 월을 설정할 월입니다.</target>
        </trans-unit>
        <trans-unit id="cf6b4f0b397f7fd7fb57c763984e8789cb54772a" translate="yes" xml:space="preserve">
          <source>The most basic contract is the &lt;a href=&quot;expression#AssertExpression&quot;&gt;&lt;i&gt;AssertExpression&lt;/i&gt;&lt;/a&gt;. An &lt;b&gt;assert&lt;/b&gt; declares an expression that must evaluate to true, with an optional failure string as a second argument:</source>
          <target state="translated">가장 기본적인 계약은 &lt;a href=&quot;expression#AssertExpression&quot;&gt;&lt;i&gt;AssertExpression&lt;/i&gt;&lt;/a&gt; 입니다. &lt;b&gt;어설&lt;/b&gt; 두 번째 인수로 옵션 실패 문자열로, true로 평가해야하는 식을 선언합니다 :</target>
        </trans-unit>
        <trans-unit id="8a6bd68f79c5b13e9b7d8eaf7293f850cd2e0e6d" translate="yes" xml:space="preserve">
          <source>The most conservative/general allocation: memory may be shared, deallocated in a different thread, may or may not be resized, and may embed references.</source>
          <target state="translated">가장 보수적 / 일반 할당 : 메모리는 공유 될 수 있고, 다른 스레드에서 할당 해제 될 수 있으며, 크기가 조정되거나 조정되지 않을 수 있으며, 참조를 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f6880935884c96d8b2634bfd6b4fbc9dbe4652c" translate="yes" xml:space="preserve">
          <source>The most interesting case is when gapped matches still participate in the result, but not as strongly as ungapped matches. The result will be a smooth, fine-grained similarity measure between the input strings. This is where values of &lt;code&gt;lambda&lt;/code&gt; between 0 and 1 enter into play: gapped matches are</source>
          <target state="translated">가장 흥미로운 경우는 갭 매치가 결과에 여전히 참여하지만 홉핑 된 매치만큼 강하지 않은 경우입니다. 결과는 입력 문자열 사이에서 부드럽고 세분화 된 유사성 측정 값이됩니다. 이것은 0과 1 사이 의 &lt;code&gt;lambda&lt;/code&gt; 값이 작용하는 곳입니다 .</target>
        </trans-unit>
        <trans-unit id="9317ec6cdc50605b3f7ad3a0a9efb80f09d16bb9" translate="yes" xml:space="preserve">
          <source>The mutex associated with this condition.</source>
          <target state="translated">이 조건과 관련된 뮤텍스.</target>
        </trans-unit>
        <trans-unit id="8402314bcd0aba6dacdd48ffde4057ad88f89bec" translate="yes" xml:space="preserve">
          <source>The mutex module provides a primitive for maintaining mutually exclusive access.</source>
          <target state="translated">뮤텍스 모듈은 상호 배타적 인 액세스를 유지하기위한 프리미티브를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="437cb228e7e76ab9ff7feb1b0fb4ca0971be7ae2" translate="yes" xml:space="preserve">
          <source>The mutex with which this condition will be associated.</source>
          <target state="translated">이 조건과 관련된 뮤텍스.</target>
        </trans-unit>
        <trans-unit id="4d5ce17987e89e660e90474cca14f7f4718221ad" translate="yes" xml:space="preserve">
          <source>The name &lt;code&gt;string&lt;/code&gt; is aliased to &lt;code&gt;immutable(char)[]&lt;/code&gt;, so the above declarations could be equivalently written as:</source>
          <target state="translated">이름 &lt;code&gt;string&lt;/code&gt; 은 &lt;code&gt;immutable(char)[]&lt;/code&gt; 로 별칭이 지정 되므로 위 선언을 다음과 같이 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="abdfc7dd54ebeb228e02bc4ac46894950c3ebbee" translate="yes" xml:space="preserve">
          <source>The name came from &lt;a href=&quot;http://search.cpan.org/~mschwern/Class-WhiteHole-0.04/lib/Class/WhiteHole.pm&quot;&gt;Class::WhiteHole&lt;/a&gt; Perl module by Michael G Schwern.</source>
          <target state="translated">그 이름은 Michael G Schwern의 &lt;a href=&quot;http://search.cpan.org/~mschwern/Class-WhiteHole-0.04/lib/Class/WhiteHole.pm&quot;&gt;Class :: WhiteHole&lt;/a&gt; Perl 모듈에서 유래했습니다 .</target>
        </trans-unit>
        <trans-unit id="173aa229bfebb13b14fcecd5dd6654d108541499" translate="yes" xml:space="preserve">
          <source>The name came from &lt;a href=&quot;http://search.cpan.org/~sburke/Class-BlackHole-0.04/lib/Class/BlackHole.pm&quot;&gt;Class::BlackHole&lt;/a&gt; Perl module by Sean M. Burke.</source>
          <target state="translated">이름은 Sean M. Burke의 &lt;a href=&quot;http://search.cpan.org/~sburke/Class-BlackHole-0.04/lib/Class/BlackHole.pm&quot;&gt;Class :: BlackHole&lt;/a&gt; Perl 모듈 에서 유래했습니다 .</target>
        </trans-unit>
        <trans-unit id="ba677412cf6055cfe046fa4f2b82702d23be25af" translate="yes" xml:space="preserve">
          <source>The name if the &lt;code&gt;Logger&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Logger&lt;/code&gt; 의 이름</target>
        </trans-unit>
        <trans-unit id="b2072d20b70963efec270cc1f87503a1f3984cd8" translate="yes" xml:space="preserve">
          <source>The name last used to initialize this this file, or &lt;code&gt;null&lt;/code&gt; otherwise.</source>
          <target state="translated">이 파일을 초기화하는 데 마지막으로 사용 된 이름, 그렇지 않으면 &lt;code&gt;null&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ef45a06b2c7cb94d26e3df83157cd1f979d10e1a" translate="yes" xml:space="preserve">
          <source>The name of the &lt;code&gt;Logger&lt;/code&gt; to insert.</source>
          <target state="translated">삽입 할 &lt;code&gt;Logger&lt;/code&gt; 의 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="dd55ce2538ac752361cbfd21c951f733e9d094b0" translate="yes" xml:space="preserve">
          <source>The name of the &lt;code&gt;Logger&lt;/code&gt; to remove. If the &lt;code&gt;Logger&lt;/code&gt; is not found &lt;code&gt;null&lt;/code&gt; will be returned. Only the first occurrence of a &lt;code&gt;Logger&lt;/code&gt; with the given name will be removed.</source>
          <target state="translated">제거 할 &lt;code&gt;Logger&lt;/code&gt; 의 이름입니다 . 경우 &lt;code&gt;Logger&lt;/code&gt; 발견되지 않는 &lt;code&gt;null&lt;/code&gt; 가 반환됩니다. 이름이 지정된 &lt;code&gt;Logger&lt;/code&gt; 의 첫 번째 항목 만 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="cc826e0e638f15943c2d93a5fc1dee8020c30510" translate="yes" xml:space="preserve">
          <source>The name of the archive member; it is used to index the archive directory for the member. Each member must have a unique name. Do not change without removing member from the directory first.</source>
          <target state="translated">아카이브 멤버의 이름. 구성원의 아카이브 디렉토리를 색인화하는 데 사용됩니다. 각 구성원은 고유 한 이름을 가져야합니다. 먼저 디렉토리에서 구성원을 제거하지 않고 변경하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="9ee544165e4b0ac751c5682d99380143dea28b21" translate="yes" xml:space="preserve">
          <source>The name of the coverage file.</source>
          <target state="translated">적용 범위 파일의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="8ede299dc9f0c5729961ad67f198075314269cda" translate="yes" xml:space="preserve">
          <source>The name of the dynamic library to load.</source>
          <target state="translated">로드 할 동적 라이브러리의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="eb57c5ab9b22c7728fcb5026ae94a8f672f4064a" translate="yes" xml:space="preserve">
          <source>The name of the file in the path name, without any leading directory and with an optional suffix chopped off.  If &lt;code&gt;suffix&lt;/code&gt; is specified, it will be compared to &lt;code&gt;path&lt;/code&gt; using &lt;code&gt;filenameCmp!cs&lt;/code&gt;, where &lt;code&gt;cs&lt;/code&gt; is an optional template parameter determining whether the comparison is case sensitive or not. See the &lt;a href=&quot;#filenameCmp&quot;&gt;&lt;code&gt;filenameCmp&lt;/code&gt;&lt;/a&gt; documentation for details.</source>
          <target state="translated">선행 디렉토리가없고 옵션 접미사가 잘린 경로 이름의 파일 이름입니다. 경우 &lt;code&gt;suffix&lt;/code&gt; 지정되어, 그것은 비교됩니다 &lt;code&gt;path&lt;/code&gt; 사용 &lt;code&gt;filenameCmp!cs&lt;/code&gt; , &lt;code&gt;cs&lt;/code&gt; 비교가 대소 문자를 구분 여부를 결정하는 옵션 템플릿 매개 변수입니다. 자세한 내용은 &lt;a href=&quot;#filenameCmp&quot;&gt; &lt;code&gt;filenameCmp&lt;/code&gt; &lt;/a&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="300f2fc600e9d7ddc4bfc394a66a2e870cf5e607" translate="yes" xml:space="preserve">
          <source>The name of the file that signaled this error.</source>
          <target state="translated">이 오류를 표시 한 파일의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="c3104c1d832397234efa203c02c8d138f5d9f9fd" translate="yes" xml:space="preserve">
          <source>The name of the file to get the modification time for.</source>
          <target state="translated">수정 시간을 가져올 파일의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="e8109b9ee879cd4547f4e2ca59c0889a944b8289" translate="yes" xml:space="preserve">
          <source>The name of the time zone.</source>
          <target state="translated">시간대의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="f27bf1b63b731926e3cb9f283408921e662cdceb" translate="yes" xml:space="preserve">
          <source>The name of the time zone. Exactly how the time zone name is formatted depends on the derived class. In the case of &lt;a href=&quot;#PosixTimeZone&quot;&gt;&lt;code&gt;PosixTimeZone&lt;/code&gt;&lt;/a&gt;, it's the TZ Database name, whereas with &lt;a href=&quot;#WindowsTimeZone&quot;&gt;&lt;code&gt;WindowsTimeZone&lt;/code&gt;&lt;/a&gt;, it's the name that Windows chose to give the registry key for that time zone (typically the name that they give &lt;a href=&quot;#stdTime&quot;&gt;&lt;code&gt;stdTime&lt;/code&gt;&lt;/a&gt; if the OS is in English). For other time zone types, what it is depends on how they're implemented.</source>
          <target state="translated">시간대의 이름입니다. 표준 시간대 이름의 형식은 파생 클래스에 따라 다릅니다. 의 경우 &lt;a href=&quot;#PosixTimeZone&quot;&gt; &lt;code&gt;PosixTimeZone&lt;/code&gt; &lt;/a&gt; , 그것과 함께, 반면 TZ 데이터베이스 이름입니다 &lt;a href=&quot;#WindowsTimeZone&quot;&gt; &lt;code&gt;WindowsTimeZone&lt;/code&gt; &lt;/a&gt; , 그것은 Windows가 그 시간대에 대한 레지스트리 키 (그들이 제공하는 일반적으로 이름을 부여하기로 결정하는 이름의 &lt;a href=&quot;#stdTime&quot;&gt; &lt;code&gt;stdTime&lt;/code&gt; 를&lt;/a&gt; OS가 영어 인 경우는). 다른 시간대 유형의 경우 구현 방식에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="7356c9b705dbe74fbd4051d488c2e6132abcd4c9" translate="yes" xml:space="preserve">
          <source>The name of this thread.</source>
          <target state="translated">이 스레드의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="c1776179bbf96730aef0ae7bbd1e4946315a478b" translate="yes" xml:space="preserve">
          <source>The name to associate with tid.</source>
          <target state="translated">tid와 연관시킬 이름입니다.</target>
        </trans-unit>
        <trans-unit id="6450e623e92fd399a84552aa61d8d22ade4cc69a" translate="yes" xml:space="preserve">
          <source>The name to locate within the registry.</source>
          <target state="translated">레지스트리 내에서 찾을 이름입니다.</target>
        </trans-unit>
        <trans-unit id="2b6764cf8c6facb0fec9b546a291b7a2d4a5f2ee" translate="yes" xml:space="preserve">
          <source>The name to unregister.</source>
          <target state="translated">등록을 취소 할 이름입니다.</target>
        </trans-unit>
        <trans-unit id="237ed33d70031f44c43457be931f956373047992" translate="yes" xml:space="preserve">
          <source>The names of the &lt;code&gt;Tuple&lt;/code&gt;'s components. Unnamed fields have empty names.</source>
          <target state="translated">&lt;code&gt;Tuple&lt;/code&gt; 구성 요소 의 이름입니다 . 이름이없는 필드에는 빈 이름이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ad8dfc5a740c084b53b8cdd123ef24e70479c04" translate="yes" xml:space="preserve">
          <source>The names of the fields that are to be aligned.</source>
          <target state="translated">정렬 할 필드의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="32748ca9205b0eda60d1a2b3377d67735262b73b" translate="yes" xml:space="preserve">
          <source>The natural alignment of an aggregate is the maximum alignment of its fields. It can be overridden by setting the alignment outside of the aggregate.</source>
          <target state="translated">집계의 자연스러운 정렬은 필드의 최대 정렬입니다. 집계 외부에서 정렬을 설정하여 재정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d205145a6dee0cb48fa4896fcd5718737412eec" translate="yes" xml:space="preserve">
          <source>The necessity of &lt;code&gt;FPTemporary&lt;/code&gt; stems from the optimized floating-point operations and registers present in virtually all processors. When adding numbers in the example above, the addition may in fact be done in &lt;code&gt;real&lt;/code&gt; precision internally. In that case, storing the intermediate &lt;code&gt;result&lt;/code&gt; in &lt;code&gt;double format&lt;/code&gt; is not only less precise, it is also (surprisingly) slower, because a conversion from &lt;code&gt;real&lt;/code&gt; to &lt;code&gt;double&lt;/code&gt; is performed every pass through the loop. This being a lose-lose situation, &lt;code&gt;FPTemporary!F&lt;/code&gt; has been defined as the</source>
          <target state="translated">&lt;code&gt;FPTemporary&lt;/code&gt; 의 필요성은 거의 모든 프로세서에 존재하는 최적화 된 부동 소수점 연산 및 레지스터에서 비롯됩니다. 위의 예에서 번호를 추가 할 때 추가는 사실에 수행 할 수 있습니다 &lt;code&gt;real&lt;/code&gt; 내부적으로 정밀. 이 경우, 기억 중간 &lt;code&gt;result&lt;/code&gt; 의 &lt;code&gt;double format&lt;/code&gt; 행 변환 있기 때문에, (놀랍게도) 느도뿐만 아니라, 덜 정확 &lt;code&gt;real&lt;/code&gt; 으로 &lt;code&gt;double&lt;/code&gt; IS 루프를 통해 모든 패스를 수행 하였다. 이것은 잃어버린 잃어버린 상황입니다. &lt;code&gt;FPTemporary!F&lt;/code&gt; 는</target>
        </trans-unit>
        <trans-unit id="ce69a83fa824acdbab753bf226be620b99f45d75" translate="yes" xml:space="preserve">
          <source>The needles against which the range is to be checked, which may be individual elements or input ranges of elements.</source>
          <target state="translated">범위를 점검 할 바늘. 개별 요소 또는 요소의 입력 범위 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bfdb89ae3952e0ebbdb470ec1b2208c20a477858" translate="yes" xml:space="preserve">
          <source>The needles to check against, which may be single elements, or bidirectional ranges of elements.</source>
          <target state="translated">점검 할 바늘은 단일 요소 또는 양방향 요소 범위 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aadc952b806bed5663dabd85a1e647a24a59b7a9" translate="yes" xml:space="preserve">
          <source>The network interface to use in form of the the IP of the interface.</source>
          <target state="translated">인터페이스의 IP 형식으로 사용할 네트워크 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="d0400083bef2e7ef7cc46b24ddfeddfeb8ab8c14" translate="yes" xml:space="preserve">
          <source>The new GC is added to the list of available garbage collectors that can be selected via the usual configuration options, e.g. by embedding &lt;code&gt;rt_options&lt;/code&gt; into the binary:</source>
          <target state="translated">새로운 GC는 일반적인 구성 옵션을 통해 선택할 수있는 가비지 수집기 목록에 추가됩니다 (예 : &lt;code&gt;rt_options&lt;/code&gt; 를 이진 파일에 포함).</target>
        </trans-unit>
        <trans-unit id="9669eec52fe11c4d6bad1a51de754d4e92f468df" translate="yes" xml:space="preserve">
          <source>The new capacity of the array (which may be larger than the requested capacity).</source>
          <target state="translated">어레이의 새로운 용량 (요청 된 용량보다 클 수 있음).</target>
        </trans-unit>
        <trans-unit id="1cf6198accddd14ad946cf8a5d9d64fbb23a0e02" translate="yes" xml:space="preserve">
          <source>The new collect handler. Set to null to use the default handler.</source>
          <target state="translated">새로운 수집 처리기 기본 핸들러를 사용하려면 널로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="0c74f8b0b947d138316f600a118f4af837db2c6f" translate="yes" xml:space="preserve">
          <source>The new daemon status for this thread.</source>
          <target state="translated">이 스레드의 새로운 데몬 상태.</target>
        </trans-unit>
        <trans-unit id="cc66954b4cb782475e75068053434548b84f648b" translate="yes" xml:space="preserve">
          <source>The new extension</source>
          <target state="translated">새로운 확장</target>
        </trans-unit>
        <trans-unit id="6c6fed22d3bfa6cee371ded07b99f5fc419355ad" translate="yes" xml:space="preserve">
          <source>The new handle will have all options set as the one it was duplicated from. An exception to this is that all options that cannot be shared across threads are reset thereby making it safe to use the duplicate in a new thread.</source>
          <target state="translated">새 핸들에는 모든 옵션이 복제 된 것으로 설정됩니다. 이에 대한 예외는 스레드간에 공유 할 수없는 모든 옵션이 재설정되어 새 스레드에서 복제본을 안전하게 사용할 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="acc5bddfa65365c1a41f6c814bd0b6ebf529b8b6" translate="yes" xml:space="preserve">
          <source>The new length of the array</source>
          <target state="translated">배열의 새로운 길이</target>
        </trans-unit>
        <trans-unit id="44a43ff11b1752259ff91b328a916debf3f4639d" translate="yes" xml:space="preserve">
          <source>The new name of this thread.</source>
          <target state="translated">이 스레드의 새로운 이름입니다.</target>
        </trans-unit>
        <trans-unit id="06d8bda027bfab1541ebec46a9bfa9f862174683" translate="yes" xml:space="preserve">
          <source>The new path name.</source>
          <target state="translated">새로운 경로 이름.</target>
        </trans-unit>
        <trans-unit id="69ac0b91bb8b9e837548ad9dd2ea12af0f0c91cd" translate="yes" xml:space="preserve">
          <source>The new position of the pivot</source>
          <target state="translated">피벗의 새로운 위치</target>
        </trans-unit>
        <trans-unit id="66818226d4d8e1db31b172237309a1e18f4a385a" translate="yes" xml:space="preserve">
          <source>The new scheduling priority of this thread.</source>
          <target state="translated">이 스레드의 새로운 스케줄링 우선 순위.</target>
        </trans-unit>
        <trans-unit id="bd1e49caf2a8a204c7259f45e5e91918594335cb" translate="yes" xml:space="preserve">
          <source>The new trace handler. Set to null to use the default handler.</source>
          <target state="translated">새로운 추적 핸들러 기본 핸들러를 사용하려면 널로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="ef32f36ed520dab3a13bb8e95c2b955f22dc9b02" translate="yes" xml:space="preserve">
          <source>The new type supports all operations that the underlying type does, including all operators such as &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;--&lt;/code&gt;, &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;[]&lt;/code&gt;, etc.</source>
          <target state="translated">새 유형은 &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;--&lt;/code&gt; , &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;[]&lt;/code&gt; 등과 같은 모든 연산자를 포함하여 기본 유형이 수행하는 모든 작업을 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="4c2af0bb285d74b0268707c20367567927c3ffc7" translate="yes" xml:space="preserve">
          <source>The new unit tester. Set both to null to use the default unit tester.</source>
          <target state="translated">새로운 단위 테스터. 기본 단위 테스터를 사용하려면 둘 다 null로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="6444785f7ab11942d704329e47346be10efdb756" translate="yes" xml:space="preserve">
          <source>The new value of &lt;code&gt;px&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;px&lt;/code&gt; 의 새로운 가치</target>
        </trans-unit>
        <trans-unit id="a51d15a8fa704020915ee450c5caa4010f6aa779" translate="yes" xml:space="preserve">
          <source>The new value of &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 새로운 가치</target>
        </trans-unit>
        <trans-unit id="e4e6a0eafbf606dbc06607e9b4455a1bb56b0445" translate="yes" xml:space="preserve">
          <source>The new-style generator objects hold their own state so they are immune of threading issues. The generators feature a number of well-known and well-documented methods of generating random numbers. An overall fast and reliable means to generate random numbers is the Mt19937 generator, which derives its name from &quot;&lt;a href=&quot;https://en.wikipedia.org/wiki/Mersenne_Twister&quot;&gt;Mersenne Twister&lt;/a&gt; with a period of 2 to the power of 19937&quot;. In memory-constrained situations, &lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_congruential_generator&quot;&gt;linear congruential generators&lt;/a&gt; such as &lt;code&gt;MinstdRand0&lt;/code&gt; and &lt;code&gt;MinstdRand&lt;/code&gt; might be useful. The standard library provides an alias Random for whichever generator it considers the most fit for the target environment.</source>
          <target state="translated">새로운 스타일 생성기 객체는 자체 상태를 유지하므로 스레드 문제에 영향을받지 않습니다. 생성기는 난수를 생성하는 잘 알려지고 잘 문서화 된 여러 가지 방법을 제공합니다. 난수를 생성하는 전체 빠르고 신뢰할 수있는 수단은 Mt19937 생성기이며, &quot; 2의 기간 인 &lt;a href=&quot;https://en.wikipedia.org/wiki/Mersenne_Twister&quot;&gt;Mersenne Twister&lt;/a&gt; 에서 19937의 거듭 제곱&quot; 이라는 이름에서 유래합니다 . 메모리가 제한된 상황에서는 &lt;code&gt;MinstdRand0&lt;/code&gt; 및 &lt;code&gt;MinstdRand&lt;/code&gt; 와 같은 &lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_congruential_generator&quot;&gt;선형 합동 생성기&lt;/a&gt; 가 유용 할 수 있습니다. 표준 라이브러리는 대상 환경에 가장 적합한 것으로 생각되는 생성기에 임의의 별칭을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="6e04d5ec9d8b3f77749de3ac5300639b2dab8407" translate="yes" xml:space="preserve">
          <source>The newline following the opening identifier is not part of the string, but the last newline before the closing identifier is part of the string. The closing identifier must be placed on its own line at the leftmost column.</source>
          <target state="translated">여는 식별자 뒤에 오는 줄 바꿈은 문자열의 일부가 아니지만 닫는 식별자 앞의 마지막 줄 바꿈은 문자열의 일부입니다. 닫는 식별자는 가장 왼쪽 열의 자체 줄에 배치해야합니다.</target>
        </trans-unit>
        <trans-unit id="51929efa4bba26701d3e4c3aa50f3e9c95ba7e57" translate="yes" xml:space="preserve">
          <source>The newly constructed object.</source>
          <target state="translated">새로 생성 된 객체.</target>
        </trans-unit>
        <trans-unit id="c4d7c48e5f93c9ad9f6d35527dbfa50a57849838" translate="yes" xml:space="preserve">
          <source>The newly-created array, or &lt;code&gt;null&lt;/code&gt; if either &lt;code&gt;length&lt;/code&gt; was &lt;code&gt;0&lt;/code&gt; or allocation failed.</source>
          <target state="translated">새로 생성 된 배열. &lt;code&gt;length&lt;/code&gt; 가 &lt;code&gt;0&lt;/code&gt; 이거나 할당에 실패한 경우 &lt;code&gt;null&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b81ee0139f4bf3ca132aff416b4badbbfb8df40c" translate="yes" xml:space="preserve">
          <source>The next unnamed section is the</source>
          <target state="translated">이름이없는 다음 섹션은</target>
        </trans-unit>
        <trans-unit id="4c1d1956fd234c462fed35c0d040ec6b5d07b95f" translate="yes" xml:space="preserve">
          <source>The non-static data members of a struct are called</source>
          <target state="translated">구조체의 비 정적 데이터 멤버를</target>
        </trans-unit>
        <trans-unit id="604fdea6e74692fe9e13e9f5a58a3d2b1b6ac2cf" translate="yes" xml:space="preserve">
          <source>The normal (or Gaussian, or bell-shaped) distribution is defined as:</source>
          <target state="translated">정규 (또는 가우스 또는 종 모양) 분포는 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="eff21418db566bf6deaa5b9e66141af90f3d37fd" translate="yes" xml:space="preserve">
          <source>The normal flow of program logic is performance critical.</source>
          <target state="translated">프로그램 논리의 정상적인 흐름은 성능에 중요합니다.</target>
        </trans-unit>
        <trans-unit id="7d10d0ff78a75299a167b0002f609034c9aaa171" translate="yes" xml:space="preserve">
          <source>The nth &lt;code&gt;ulong&lt;/code&gt; in the representation of this &lt;code&gt;BigInt&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;BigInt&lt;/code&gt; 의 표현의 n 번째 &lt;code&gt;ulong&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="bb3057bb9b7c5b0a70e9ce3b421bd111159e0bc0" translate="yes" xml:space="preserve">
          <source>The nth number to retrieve. Must be less than &lt;a href=&quot;#ulongLength&quot;&gt;&lt;code&gt;ulongLength&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#uintLength&quot;&gt;&lt;code&gt;uintLength&lt;/code&gt;&lt;/a&gt; with respect to &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">검색 할 n 번째 숫자입니다. &lt;code&gt;T&lt;/code&gt; 와 관련하여 &lt;a href=&quot;#ulongLength&quot;&gt; &lt;code&gt;ulongLength&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#uintLength&quot;&gt; &lt;code&gt;uintLength&lt;/code&gt; &lt;/a&gt; 보다 작아야 합니다.</target>
        </trans-unit>
        <trans-unit id="b76d5847a278447b3f3920d9aa794bc68c09f466" translate="yes" xml:space="preserve">
          <source>The null value which denotes the null state of this &lt;code&gt;Nullable&lt;/code&gt;. Must be of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">이러한 널 (null) 상태이다 NULL 값 &lt;code&gt;Nullable&lt;/code&gt; . &lt;code&gt;T&lt;/code&gt; 유형이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="199b0fb0977641f832ecd7a38d40b0a14f3dad41" translate="yes" xml:space="preserve">
          <source>The number of &lt;code&gt;Tgt&lt;/code&gt; elements written.</source>
          <target state="translated">쓰여진 &lt;code&gt;Tgt&lt;/code&gt; 요소 의 수</target>
        </trans-unit>
        <trans-unit id="95368522e59bb86a89704bd4d6738e476908f01e" translate="yes" xml:space="preserve">
          <source>The number of bits of state of this generator. This must be a positive multiple of the size in bits of UIntType. If nbits is large this struct may occupy slightly more memory than this so it can use a circular counter instead of shifting the entire array.</source>
          <target state="translated">이 생성기의 상태 비트 수입니다. UIntType의 비트 단위 크기의 양의 배수 여야합니다. nbit가 크면이 구조체는 이것보다 약간 더 많은 메모리를 차지할 수 있으므로 전체 배열을 이동하는 대신 원형 카운터를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed0599417ff90656d7b8a7db044e9965e3ca5970" translate="yes" xml:space="preserve">
          <source>The number of buffers to cycle through when calling &lt;code&gt;next&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;next&lt;/code&gt; 를 호출 할 때 순환 할 버퍼 수입니다 .</target>
        </trans-unit>
        <trans-unit id="30308060113660277e7be67f08fdce3f91011c41" translate="yes" xml:space="preserve">
          <source>The number of bytes actually received, &lt;code&gt;0&lt;/code&gt; if the remote side has closed the connection, or &lt;code&gt;Socket.ERROR&lt;/code&gt; on failure.</source>
          <target state="translated">실제로 수신 된 바이트 수 , 원격 측이 연결을 닫은 경우 &lt;code&gt;0&lt;/code&gt; 또는 실패시 &lt;code&gt;Socket.ERROR&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="52771a2599e853e22c9997ae74caf507a27e6674" translate="yes" xml:space="preserve">
          <source>The number of bytes actually sent, or &lt;code&gt;Socket.ERROR&lt;/code&gt; on failure.</source>
          <target state="translated">실제로 전송 된 바이트 수 또는 실패시 &lt;code&gt;Socket.ERROR&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cb4925770f917957f95841228cf7a081251584ac" translate="yes" xml:space="preserve">
          <source>The number of bytes written to &lt;code&gt;result&lt;/code&gt;. The length, in bytes, of the actual result - very different from getsockopt()</source>
          <target state="translated">&lt;code&gt;result&lt;/code&gt; 에 쓴 바이트 수입니다 . 실제 결과의 길이 (바이트)-getsockopt ()와는 매우 다릅니다</target>
        </trans-unit>
        <trans-unit id="18e0b014069c5b9a5015fd8266605137eb19d431" translate="yes" xml:space="preserve">
          <source>The number of cache levels in the CPU.</source>
          <target state="translated">CPU의 캐시 레벨 수입니다.</target>
        </trans-unit>
        <trans-unit id="4e1a5c7628d25ca94f5309da0ccfd2a5e3544707" translate="yes" xml:space="preserve">
          <source>The number of chunks buffered asynchronously</source>
          <target state="translated">비동기 적으로 버퍼링 된 청크 수</target>
        </trans-unit>
        <trans-unit id="d794552fb711e9d13296816f458408c772152acf" translate="yes" xml:space="preserve">
          <source>The number of code units in &lt;code&gt;input&lt;/code&gt; when encoded to &lt;code&gt;C&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;C&lt;/code&gt; 로 인코딩 될 때 &lt;code&gt;input&lt;/code&gt; 된 코드 단위 수</target>
        </trans-unit>
        <trans-unit id="4af8e22ffe4686545114fe30d8267cec1e21b38c" translate="yes" xml:space="preserve">
          <source>The number of code units in the UTF sequence. For UTF-8, this is a value between 1 and 4 (as per &lt;a href=&quot;http://tools.ietf.org/html/rfc3629#section-3&quot;&gt;RFC 3629, section 3&lt;/a&gt;). For UTF-16, it is either 1 or 2. For UTF-32, it is always 1.</source>
          <target state="translated">UTF 시퀀스의 코드 단위 수입니다. UTF-8의 경우, 이것은 1과 4 사이의 값입니다 ( &lt;a href=&quot;http://tools.ietf.org/html/rfc3629#section-3&quot;&gt;RFC 3629, 섹션 3에 따라&lt;/a&gt; ). UTF-16의 경우 1 또는 2입니다. UTF-32의 경우 항상 1입니다.</target>
        </trans-unit>
        <trans-unit id="5eb0aafa3d3443973bc7f248675786f305586655" translate="yes" xml:space="preserve">
          <source>The number of colons in the selector needs to match the number of parameters the method is declared with</source>
          <target state="translated">선택기의 콜론 수는 메소드가 선언 된 매개 변수 수와 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="cf1a54117f4160455c190793bfbc5f270d3ef431" translate="yes" xml:space="preserve">
          <source>The number of colons in the string need to match the number of arguments the method accept.</source>
          <target state="translated">문자열의 콜론 수는 메소드가 허용하는 인수 수와 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="74867ebd8619c3c9f54bb7be26778ccc990cfd33" translate="yes" xml:space="preserve">
          <source>The number of days to add to this &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 &lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 에 추가 할 일수 입니다.</target>
        </trans-unit>
        <trans-unit id="17519ebe025dfa827b2543290a321667b7bbfac2" translate="yes" xml:space="preserve">
          <source>The number of elements brought to the front, i.e., the length of &lt;code&gt;back&lt;/code&gt;.</source>
          <target state="translated">요소의 수는 앞의 예, 길이에 데리고 &lt;code&gt;back&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="30c9197d75a0a694e962a609bbc59e4ba11be6f0" translate="yes" xml:space="preserve">
          <source>The number of elements in an</source>
          <target state="translated">의 요소 수</target>
        </trans-unit>
        <trans-unit id="0419481cf5884d86b99e61181cced8b51e95c26d" translate="yes" xml:space="preserve">
          <source>The number of elements in the array.</source>
          <target state="translated">배열의 요소 수</target>
        </trans-unit>
        <trans-unit id="325aeffb680232bb5eba0a4534994930400a1165" translate="yes" xml:space="preserve">
          <source>The number of elements inserted</source>
          <target state="translated">삽입 된 요소 수</target>
        </trans-unit>
        <trans-unit id="4f13d3392d3b50fea45a81fe242fa67f3021e8e8" translate="yes" xml:space="preserve">
          <source>The number of elements inserted.</source>
          <target state="translated">삽입 된 요소 수</target>
        </trans-unit>
        <trans-unit id="c6d6d4be5d1980bfa9a3ce44b333a124372b6ae3" translate="yes" xml:space="preserve">
          <source>The number of elements removed</source>
          <target state="translated">제거 된 요소 수</target>
        </trans-unit>
        <trans-unit id="20396f56c8e3a0c13e5e36b7f2622f3b64ae5d64" translate="yes" xml:space="preserve">
          <source>The number of elements removed.</source>
          <target state="translated">제거 된 요소 수</target>
        </trans-unit>
        <trans-unit id="a147df2d8f03d61a2cbd49ca985ab3c09c4946c0" translate="yes" xml:space="preserve">
          <source>The number of elements to evaluate in a single &lt;code&gt;Task&lt;/code&gt;. Must be less than or equal to &lt;code&gt;bufSize&lt;/code&gt;, and should be a fraction of &lt;code&gt;bufSize&lt;/code&gt; such that all worker threads can be used. If the default of size_t.max is used, workUnitSize will be set to the pool-wide default.</source>
          <target state="translated">단일 &lt;code&gt;Task&lt;/code&gt; 에서 평가할 요소 수입니다 . &lt;code&gt;bufSize&lt;/code&gt; 이하이어야하며 모든 작업자 스레드를 사용할 수 있도록 &lt;code&gt;bufSize&lt;/code&gt; 의 일부 여야합니다 . size_t.max의 기본값을 사용하면 workUnitSize가 풀 전체 기본값으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="9de93b8e68b06f4138b723f65ba57f9135fbd680" translate="yes" xml:space="preserve">
          <source>The number of elements which must be popped from the front of &lt;code&gt;haystack&lt;/code&gt; before reaching an element for which &lt;code&gt;startsWith!pred(haystack, needles)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;. If &lt;code&gt;startsWith!pred(haystack, needles)&lt;/code&gt; is not &lt;code&gt;true&lt;/code&gt; for any element in &lt;code&gt;haystack&lt;/code&gt;, then &lt;code&gt;-1&lt;/code&gt; is returned. If only &lt;code&gt;pred&lt;/code&gt; is provided, &lt;code&gt;pred(haystack)&lt;/code&gt; is tested for each element.</source>
          <target state="translated">&lt;code&gt;startsWith!pred(haystack, needles)&lt;/code&gt; 에 &lt;code&gt;true&lt;/code&gt; 하는 요소에 도달하기 전에 &lt;code&gt;haystack&lt;/code&gt; 의 전면에서 튀어 나와야 하는 요소 수 는 true 입니다. 경우 &lt;code&gt;startsWith!pred(haystack, needles)&lt;/code&gt; 아닌 &lt;code&gt;true&lt;/code&gt; 의 모든 요소에 대한 &lt;code&gt;haystack&lt;/code&gt; , 다음 &lt;code&gt;-1&lt;/code&gt; 반환됩니다. &lt;code&gt;pred&lt;/code&gt; 만 제공되면 각 요소에 대해 &lt;code&gt;pred(haystack)&lt;/code&gt; 가 테스트됩니다.</target>
        </trans-unit>
        <trans-unit id="11ccb90c9b9e42a2c399f8ec744f0b51f68401b5" translate="yes" xml:space="preserve">
          <source>The number of files in this archive.</source>
          <target state="translated">이 아카이브의 파일 수입니다.</target>
        </trans-unit>
        <trans-unit id="495bce27f099960a19a7f2777229fe07b08dc353" translate="yes" xml:space="preserve">
          <source>The number of hnsecs since January 1st, 1 A.D. UTC.</source>
          <target state="translated">AD UTC 1 월 1 일 이후의 hnsec 수</target>
        </trans-unit>
        <trans-unit id="0128cf9b280876e985f5bc63b3c33b05eec8b671" translate="yes" xml:space="preserve">
          <source>The number of hnsecs since midnight, January 1st, 1 A.D. UTC.</source>
          <target state="translated">AD UTC 1 월 1 일 자정 이후의 hnsecs 수입니다.</target>
        </trans-unit>
        <trans-unit id="dfa696143d106fe9221db705fdd3a015ad40f3ab" translate="yes" xml:space="preserve">
          <source>The number of lines buffered asynchronously</source>
          <target state="translated">비동기식으로 버퍼링 된 라인 수</target>
        </trans-unit>
        <trans-unit id="9bd6f12f8ce1f299c0d0263b77bcc143be77d073" translate="yes" xml:space="preserve">
          <source>The number of months or years to add to this &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 &lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 에 추가 할 개월 또는 년 수입니다 .</target>
        </trans-unit>
        <trans-unit id="b9c39f066ee7dbe68f94fd81f8c5f3cf00396747" translate="yes" xml:space="preserve">
          <source>The number of months or years to add to this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 &lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 에 추가 할 개월 또는 년 수입니다 .</target>
        </trans-unit>
        <trans-unit id="57340a14727c652a36c1e1fc1ba3e2830bbfa123" translate="yes" xml:space="preserve">
          <source>The number of months or years to add to this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; 에 추가 할 개월 또는 년 수입니다 .</target>
        </trans-unit>
        <trans-unit id="02485194b1dc362bace73e65c9372da46a13c61b" translate="yes" xml:space="preserve">
          <source>The number of months to add to the time point passed to the delegate.</source>
          <target state="translated">대리인에게 전달 된 시점에 추가 할 개월 수입니다.</target>
        </trans-unit>
        <trans-unit id="aca30d94828d21a4c6a8ef3a42e227aa33b46f16" translate="yes" xml:space="preserve">
          <source>The number of months to expand the interval by.</source>
          <target state="translated">간격을 확장 할 개월 수입니다.</target>
        </trans-unit>
        <trans-unit id="4f7751ef3f5968bb794d3b81c43237882d9d52ee" translate="yes" xml:space="preserve">
          <source>The number of months to shift the interval by.</source>
          <target state="translated">간격을 변경하는 개월 수입니다.</target>
        </trans-unit>
        <trans-unit id="63a68d030d7307514d07c50786c06b3b1b3f26d9" translate="yes" xml:space="preserve">
          <source>The number of pages is variable (but not less then 1) unlike the number of entries in the index. The slots of the index all have to contain a number of a page that is present. The lookup is then just a couple of operations - slice the upper bits, lookup an index for these, take a page at this index and use the lower bits as an offset within this page.</source>
          <target state="translated">페이지 수는 색인의 항목 수와 달리 가변적이지만 1보다 작습니다. 색인의 슬롯에는 모두 여러 페이지가 있어야합니다. 조회는 단지 두 개의 연산입니다-상위 비트를 슬라이스하고, 이들을위한 인덱스를 조회하고,이 인덱스에서 페이지를 가져 와서이 페이지 내에서 하위 비트를 오프셋으로 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="a4a9d929861b7f4540e0616b20649c026af1b75f" translate="yes" xml:space="preserve">
          <source>The number of positions in the &lt;code&gt;haystack&lt;/code&gt; for which &lt;code&gt;pred&lt;/code&gt; returned true.</source>
          <target state="translated">의 위치의 수 &lt;code&gt;haystack&lt;/code&gt; 있는 &lt;code&gt;pred&lt;/code&gt; 사실 돌아왔다.</target>
        </trans-unit>
        <trans-unit id="e5d60a9e70df9e4591b2299d06f99ccc91195edd" translate="yes" xml:space="preserve">
          <source>The number of sockets with status changes, &lt;code&gt;0&lt;/code&gt; on timeout, or &lt;code&gt;-1&lt;/code&gt; on interruption. If the return value is greater than &lt;code&gt;0&lt;/code&gt;, the &lt;code&gt;SocketSets&lt;/code&gt; are updated to only contain the sockets having status changes. For a connecting socket, a write status change means the connection is established and it's able to send. For a listening socket, a read status change means there is an incoming connection request and it's able to accept.  &lt;code&gt;SocketSet&lt;/code&gt;'s updated to include only those sockets which an event occured. For a &lt;code&gt;connect()&lt;/code&gt;ing socket, writeability means connected. For a &lt;code&gt;listen()&lt;/code&gt;ing socket, readability means listening &lt;code&gt;Winsock&lt;/code&gt;; possibly internally limited to 64 sockets per set.</source>
          <target state="translated">상태가 변경된 소켓 수, 시간 종료시 &lt;code&gt;0&lt;/code&gt; 또는 중단시 &lt;code&gt;-1&lt;/code&gt; 반환 값이보다 큰 경우 &lt;code&gt;0&lt;/code&gt; 의 &lt;code&gt;SocketSets&lt;/code&gt; 는 전용 상태 변화를 갖는 소켓을 포함하도록 업데이트됩니다. 연결 소켓의 경우 쓰기 상태 변경은 연결이 설정되어 전송할 수 있음을 의미합니다. 청취 소켓의 경우 읽기 상태 변경은 들어오는 연결 요청이 있으며 수락 할 수 있음을 의미합니다. &lt;code&gt;SocketSet&lt;/code&gt; 가 이벤트가 발생한 소켓 만 포함하도록 업데이트되었습니다. A에 대한 &lt;code&gt;connect()&lt;/code&gt; ING 소켓 writeability 수단이 접속되어있다. A가 들어 &lt;code&gt;listen()&lt;/code&gt; 소켓, 가독성 수단 듣기를 보내고 &lt;code&gt;Winsock&lt;/code&gt; ; 내부적으로 세트당 64 개의 소켓으로 제한 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="92623bd7d09398f80bbab3bb0f5f2ef38d3da421" translate="yes" xml:space="preserve">
          <source>The number of system ticks in this &lt;code&gt;TickDuration&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;TickDuration&lt;/code&gt; 의 시스템 틱 수입니다 .</target>
        </trans-unit>
        <trans-unit id="7611dde88762f088b010293dbcd7b4751f9ec60a" translate="yes" xml:space="preserve">
          <source>The number of the disk where this member can be found.</source>
          <target state="translated">이 멤버를 찾을 수있는 디스크 번호입니다.</target>
        </trans-unit>
        <trans-unit id="8f11ee7d7d27eb3d41061b45eac584df0b5f1cfe" translate="yes" xml:space="preserve">
          <source>The number of ticks in the TickDuration.</source>
          <target state="translated">TickDuration의 틱 수입니다.</target>
        </trans-unit>
        <trans-unit id="c3535c21516c22bad36e4ae79f60e710279eebd0" translate="yes" xml:space="preserve">
          <source>The number of ticks in the monotonic time.</source>
          <target state="translated">단조로운 시간의 틱 수입니다.</target>
        </trans-unit>
        <trans-unit id="133c2247d181f5eb459c19f2950580ed684e418a" translate="yes" xml:space="preserve">
          <source>The number of ticks that MonoTime has per second - i.e. the resolution or frequency of the system's monotonic clock.</source>
          <target state="translated">MonoTime의 초당 틱 수-시스템의 단조로운 클럭의 해상도 또는 주파수.</target>
        </trans-unit>
        <trans-unit id="8271982f8f2afc20c964508f18ca6b32767857e7" translate="yes" xml:space="preserve">
          <source>The number of ticks that the system clock has in one second.</source>
          <target state="translated">시스템 시계의 틱 수는 1 초입니다.</target>
        </trans-unit>
        <trans-unit id="8b51266ea49a500bd86819d90d5f5babd9fda252" translate="yes" xml:space="preserve">
          <source>The number of times each function is to be executed.</source>
          <target state="translated">각 기능이 실행되는 횟수입니다.</target>
        </trans-unit>
        <trans-unit id="f1050ae226927365357fc51efba9b81760d7056b" translate="yes" xml:space="preserve">
          <source>The number of times the output range's &lt;code&gt;put&lt;/code&gt; method was invoked.</source>
          <target state="translated">출력 범위의 &lt;code&gt;put&lt;/code&gt; 메소드가 호출 된 횟수입니다 .</target>
        </trans-unit>
        <trans-unit id="4d82522805f2ebbbf559fec74a61f5c7cb9cc3a6" translate="yes" xml:space="preserve">
          <source>The number of units in the &lt;code&gt;Duration&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Duration&lt;/code&gt; 의 단위 수입니다 .</target>
        </trans-unit>
        <trans-unit id="794f084381c766ea0ff9fffa3e14bba305b1eb34" translate="yes" xml:space="preserve">
          <source>The number of units in the &lt;code&gt;TickDuration&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;TickDuration&lt;/code&gt; 의 단위 수입니다 .</target>
        </trans-unit>
        <trans-unit id="22c3d0c8685c468fadcdccd79c29727ddf2e7e9a" translate="yes" xml:space="preserve">
          <source>The number of units to add to this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 &lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 에 추가 할 단위 수입니다 .</target>
        </trans-unit>
        <trans-unit id="9b148446ca97774856b435f40497b3469e8ca6ab" translate="yes" xml:space="preserve">
          <source>The number of units to add to this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; 에 추가 할 단위 수입니다 .</target>
        </trans-unit>
        <trans-unit id="b3b24aff6aba1d0b2f312ff80d7560f7feabc059" translate="yes" xml:space="preserve">
          <source>The number of units to add to this &lt;a href=&quot;#TimeOfDay&quot;&gt;&lt;code&gt;TimeOfDay&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 &lt;a href=&quot;#TimeOfDay&quot;&gt; &lt;code&gt;TimeOfDay&lt;/code&gt; &lt;/a&gt; 에 추가 할 단위 수입니다 .</target>
        </trans-unit>
        <trans-unit id="37c2540cc1f38510b5307fd0d898532d4c17f0e5" translate="yes" xml:space="preserve">
          <source>The number of units to multiply this &lt;code&gt;Duration&lt;/code&gt; by.</source>
          <target state="translated">이 &lt;code&gt;Duration&lt;/code&gt; 에 곱할 단위 수입니다 .</target>
        </trans-unit>
        <trans-unit id="5f6b34534215487ddb13229d1e9eb704abfb659b" translate="yes" xml:space="preserve">
          <source>The number of values inserted.</source>
          <target state="translated">삽입 된 값의 수입니다.</target>
        </trans-unit>
        <trans-unit id="d14be6e779a48d8faa82f80e4dc078722606651d" translate="yes" xml:space="preserve">
          <source>The number of waiting threads to release in unison.</source>
          <target state="translated">한꺼번에 해제 대기 스레드 수입니다.</target>
        </trans-unit>
        <trans-unit id="365cb2c08dafe42960332e827da68e53b00a9bd8" translate="yes" xml:space="preserve">
          <source>The number of years to add to the time point passed to the delegate.</source>
          <target state="translated">대리인에게 전달 된 시점에 추가 할 연수입니다.</target>
        </trans-unit>
        <trans-unit id="fcc2e5d2212e8d8be70b8d4677e493fc3848a020" translate="yes" xml:space="preserve">
          <source>The number of years to expand the interval by.</source>
          <target state="translated">간격을 연장하는 연도입니다.</target>
        </trans-unit>
        <trans-unit id="2241ab252f8a5484883abb33a8af4a6dad25eb69" translate="yes" xml:space="preserve">
          <source>The number of years to shift the interval by.</source>
          <target state="translated">간격을 옮길 년 수입니다.</target>
        </trans-unit>
        <trans-unit id="ab33e33805a08eda08dd986381c2b8f8b862f93b" translate="yes" xml:space="preserve">
          <source>The number to validate.</source>
          <target state="translated">검증 할 번호입니다.</target>
        </trans-unit>
        <trans-unit id="b28803e23c2f1bebd73a4d48e79b273e730f7db3" translate="yes" xml:space="preserve">
          <source>The numeric literals &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt; can be implicitly converted to the &lt;code&gt;bool&lt;/code&gt; values &lt;code&gt;false&lt;/code&gt; and &lt;code&gt;true&lt;/code&gt;, respectively. Casting an expression to &lt;code&gt;bool&lt;/code&gt; means testing for &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;!=0&lt;/code&gt; for arithmetic types, and &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;!=null&lt;/code&gt; for pointers or references.</source>
          <target state="translated">숫자 리터럴 &lt;code&gt;0&lt;/code&gt; 과 &lt;code&gt;1&lt;/code&gt; 은 각각 &lt;code&gt;bool&lt;/code&gt; 값 &lt;code&gt;false&lt;/code&gt; 및 &lt;code&gt;true&lt;/code&gt; 로 암시 적으로 변환 될 수 있습니다 . 식을 &lt;code&gt;bool&lt;/code&gt; 캐스팅 한다는 것은 산술 형식에 대해 &lt;code&gt;0&lt;/code&gt; 또는 &lt;code&gt;!=0&lt;/code&gt; 을 테스트 하고 포인터 또는 참조에 대해서는 &lt;code&gt;null&lt;/code&gt; 또는 &lt;code&gt;!=null&lt;/code&gt; 을 테스트하는 것을 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="fe0da3c8ef7d3c766ce89becdf0b23671a0397f9" translate="yes" xml:space="preserve">
          <source>The numeric version number is also available &quot;in parts&quot; by using these constants</source>
          <target state="translated">이 상수를 사용하여 숫자 버전 번호를 &quot;부분적으로&quot;사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="126529265bda77a1ffa31840d1614e6dc6547606" translate="yes" xml:space="preserve">
          <source>The object to throw.</source>
          <target state="translated">던질 객체.</target>
        </trans-unit>
        <trans-unit id="917127d4e18a9f0f96c8fddb70a363dd7f1bb7b1" translate="yes" xml:space="preserve">
          <source>The object-oriented features of D all come from classes. The class hierarchy has as its root the class Object. Object defines a minimum level of functionality that each derived class has, and a default implementation for that functionality.</source>
          <target state="translated">D의 객체 지향 기능은 모두 클래스에서 비롯됩니다. 클래스 계층 구조는 그 루트가 Object 클래스입니다. Object는 각 파생 클래스가 갖는 최소 수준의 기능과 해당 기능에 대한 기본 구현을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="83450785309cc6865682ad266cad8f967bd48d27" translate="yes" xml:space="preserve">
          <source>The old benchmarking functionality in std.datetime (which uses &lt;a href=&quot;core_time#TickDuration&quot;&gt;&lt;code&gt;core.time.TickDuration&lt;/code&gt;&lt;/a&gt;) has been deprecated. Use what's in std.datetime.stopwatch instead. It uses &lt;a href=&quot;core_time#MonoTime&quot;&gt;&lt;code&gt;core.time.MonoTime&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt;. Note that comparingBenchmark has not been ported over, because it's a trivial wrapper around benchmark. See &lt;a href=&quot;std_datetime_stopwatch#benchmark&quot;&gt;&lt;code&gt;std.datetime.stopwatch.benchmark&lt;/code&gt;&lt;/a&gt;. This symbol will be removed from the documentation in October 2018 and fully removed from Phobos in October 2019.</source>
          <target state="translated">std.datetime ( &lt;a href=&quot;core_time#TickDuration&quot;&gt; &lt;code&gt;core.time.TickDuration&lt;/code&gt; &lt;/a&gt; 사용 ) 의 이전 벤치마킹 기능은 더 이상 사용되지 않습니다. 대신 std.datetime.stopwatch에있는 것을 사용하십시오. &lt;a href=&quot;core_time#MonoTime&quot;&gt; &lt;code&gt;core.time.MonoTime&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; 을&lt;/a&gt; 사용합니다 . 비교 벤치 마크는 벤치마킹에 대한 간단한 래퍼이기 때문에 포팅되지 않았습니다. &lt;a href=&quot;std_datetime_stopwatch#benchmark&quot;&gt; &lt;code&gt;std.datetime.stopwatch.benchmark&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 . 이 기호는 2018 년 10 월 설명서에서 제거되고 2019 년 10 월 Phobos에서 완전히 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="efeb1eab4dde5b659a31f85b9f2c2ca05099ac2d" translate="yes" xml:space="preserve">
          <source>The old benchmarking functionality in std.datetime (which uses &lt;a href=&quot;core_time#TickDuration&quot;&gt;&lt;code&gt;core.time.TickDuration&lt;/code&gt;&lt;/a&gt;) has been deprecated. Use what's in std.datetime.stopwatch instead. It uses &lt;a href=&quot;core_time#MonoTime&quot;&gt;&lt;code&gt;core.time.MonoTime&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt;. Note that measureTime has not been ported over, because it's a trivial wrapper around StopWatch. See &lt;a href=&quot;std_datetime_stopwatch#StopWatch&quot;&gt;&lt;code&gt;std.datetime.stopwatch.StopWatch&lt;/code&gt;&lt;/a&gt;. This symbol will be removed from the documentation in October 2018 and fully removed from Phobos in October 2019.</source>
          <target state="translated">std.datetime의 이전 벤치마킹 기능 ( &lt;a href=&quot;core_time#TickDuration&quot;&gt; &lt;code&gt;core.time.TickDuration&lt;/code&gt; &lt;/a&gt;)더 이상 사용되지 않습니다. 대신 std.datetime.stopwatch에있는 것을 사용하십시오.&lt;a href=&quot;core_time#MonoTime&quot;&gt; &lt;code&gt;core.time.MonoTime&lt;/code&gt; &lt;/a&gt; 및&lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; 을&lt;/a&gt; 사용합니다. measureTime은 StopWatch를 둘러싼 간단한 래퍼이기 때문에 포팅되지 않았습니다.&lt;a href=&quot;std_datetime_stopwatch#StopWatch&quot;&gt; &lt;code&gt;std.datetime.stopwatch.StopWatch&lt;/code&gt; 를&lt;/a&gt; 참조하십시오. 이 기호는 2018 년 10 월 설명서에서 제거되고 2019 년 10 월 Phobos에서 완전히 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="8251e06b859fc1bf7834e47982a51786233d653a" translate="yes" xml:space="preserve">
          <source>The old benchmarking functionality in std.datetime (which uses &lt;a href=&quot;core_time#TickDuration&quot;&gt;&lt;code&gt;core.time.TickDuration&lt;/code&gt;&lt;/a&gt;) has been deprecated. Use what's in std.datetime.stopwatch instead. It uses &lt;a href=&quot;core_time#MonoTime&quot;&gt;&lt;code&gt;core.time.MonoTime&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt;. See &lt;a href=&quot;std_datetime_stopwatch#AutoStart&quot;&gt;&lt;code&gt;std.datetime.stopwatch.AutoStart&lt;/code&gt;&lt;/a&gt;. This symbol will be removed from the documentation in October 2018 and fully removed from Phobos in October 2019.</source>
          <target state="translated">std.datetime의 이전 벤치마킹 기능 ( &lt;a href=&quot;core_time#TickDuration&quot;&gt; &lt;code&gt;core.time.TickDuration&lt;/code&gt; &lt;/a&gt;)더 이상 사용되지 않습니다. 대신 std.datetime.stopwatch에있는 것을 사용하십시오.&lt;a href=&quot;core_time#MonoTime&quot;&gt; &lt;code&gt;core.time.MonoTime&lt;/code&gt; &lt;/a&gt; 및&lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; 을&lt;/a&gt; 사용합니다.&lt;a href=&quot;std_datetime_stopwatch#AutoStart&quot;&gt; &lt;code&gt;std.datetime.stopwatch.AutoStart&lt;/code&gt; 를&lt;/a&gt; 참조하십시오. 이 기호는 2018 년 10 월 설명서에서 제거되고 2019 년 10 월 Phobos에서 완전히 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="3836851ebe09983822b4948475513fd0ffdb5b68" translate="yes" xml:space="preserve">
          <source>The old benchmarking functionality in std.datetime (which uses &lt;a href=&quot;core_time#TickDuration&quot;&gt;&lt;code&gt;core.time.TickDuration&lt;/code&gt;&lt;/a&gt;) has been deprecated. Use what's in std.datetime.stopwatch instead. It uses &lt;a href=&quot;core_time#MonoTime&quot;&gt;&lt;code&gt;core.time.MonoTime&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt;. See &lt;a href=&quot;std_datetime_stopwatch#StopWatch&quot;&gt;&lt;code&gt;std.datetime.stopwatch.StopWatch&lt;/code&gt;&lt;/a&gt;. This symbol will be removed from the documentation in October 2018 and fully removed from Phobos in October 2019.</source>
          <target state="translated">std.datetime의 이전 벤치마킹 기능 ( &lt;a href=&quot;core_time#TickDuration&quot;&gt; &lt;code&gt;core.time.TickDuration&lt;/code&gt; 을 사용함)&lt;/a&gt; ) 더 이상 사용되지 않습니다. 대신 std.datetime.stopwatch에있는 것을 사용하십시오. &lt;a href=&quot;core_time#MonoTime&quot;&gt; &lt;code&gt;core.time.MonoTime&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; 을&lt;/a&gt; 사용합니다 . &lt;a href=&quot;std_datetime_stopwatch#StopWatch&quot;&gt; &lt;code&gt;std.datetime.stopwatch.StopWatch&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 . 이 기호는 2018 년 10 월 설명서에서 제거되고 2019 년 10 월 Phobos에서 완전히 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="852cd69a4d8476a6740350b9e4fa04e022f147f2" translate="yes" xml:space="preserve">
          <source>The old benchmarking functionality in std.datetime (which uses &lt;a href=&quot;core_time#TickDuration&quot;&gt;&lt;code&gt;core.time.TickDuration&lt;/code&gt;&lt;/a&gt;) has been deprecated. Use what's in std.datetime.stopwatch instead. It uses &lt;a href=&quot;core_time#MonoTime&quot;&gt;&lt;code&gt;core.time.MonoTime&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt;. See &lt;a href=&quot;std_datetime_stopwatch#benchmark&quot;&gt;&lt;code&gt;std.datetime.stopwatch.benchmark&lt;/code&gt;&lt;/a&gt;. This symbol will be removed from the documentation in October 2018 and fully removed from Phobos in October 2019.</source>
          <target state="translated">std.datetime ( &lt;a href=&quot;core_time#TickDuration&quot;&gt; &lt;code&gt;core.time.TickDuration&lt;/code&gt; &lt;/a&gt; 사용 ) 의 이전 벤치마킹 기능은 더 이상 사용되지 않습니다. 대신 std.datetime.stopwatch에있는 것을 사용하십시오. 사용합니다&lt;a href=&quot;core_time#MonoTime&quot;&gt; &lt;code&gt;core.time.MonoTime&lt;/code&gt; &lt;/a&gt; 및&lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; 을&lt;/a&gt;. &lt;a href=&quot;std_datetime_stopwatch#benchmark&quot;&gt; &lt;code&gt;std.datetime.stopwatch.benchmark&lt;/code&gt; 를&lt;/a&gt; 참조하십시오. 이 기호는 2018 년 10 월 설명서에서 제거되고 2019 년 10 월 Phobos에서 완전히 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="e2b766119f4b2cc6bf40fa4a91668ec3bf749415" translate="yes" xml:space="preserve">
          <source>The one area in which this function violates RFC 5322 is that it accepts &lt;code&gt;&quot;\n&quot;&lt;/code&gt; in folding whitespace in the place of &lt;code&gt;&quot;\r\n&quot;&lt;/code&gt;, because the HTTP spec requires it.</source>
          <target state="translated">이 함수가 RFC 5322를 위반하는 한 가지 영역 은 HTTP 스펙에서 요구하기 때문에 &lt;code&gt;&quot;\r\n&quot;&lt;/code&gt; 대신 공백을 접는 경우 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 을 허용한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="1e2e3dd788c39da352fad71950c0b91387508356" translate="yes" xml:space="preserve">
          <source>The one shared instance.</source>
          <target state="translated">하나의 공유 인스턴스</target>
        </trans-unit>
        <trans-unit id="c72b10055e71a8b6b107b05c7231e9b97b023ff1" translate="yes" xml:space="preserve">
          <source>The only accepted units are &lt;code&gt;&quot;days&quot;&lt;/code&gt;.</source>
          <target state="translated">허용되는 단위는 &lt;code&gt;&quot;days&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c5649b3ae07a628e1e89097ca2f1b006efdc1767" translate="yes" xml:space="preserve">
          <source>The only operators that can accept operands of type bool are: &lt;code&gt;&amp;amp;&lt;/code&gt;&lt;code&gt;|&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;, &lt;code&gt;^=&lt;/code&gt;, !, &lt;code&gt;&amp;amp;&lt;/code&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;&lt;code&gt;|&lt;/code&gt;, and &lt;code&gt;?:&lt;/code&gt;.</source>
          <target state="translated">bool 유형의 피연산자를 허용 할 수있는 유일한 연산자는 다음 &lt;code&gt;&amp;amp;&lt;/code&gt; 같습니다. &amp;amp; &lt;code&gt;|&lt;/code&gt; , &lt;code&gt;^&lt;/code&gt; , &lt;code&gt;&amp;amp;&lt;/code&gt; &lt;code&gt;=&lt;/code&gt; , &lt;code&gt;|&lt;/code&gt; &lt;code&gt;=&lt;/code&gt; , &lt;code&gt;^=&lt;/code&gt; ,!, &lt;code&gt;&amp;amp;&lt;/code&gt; &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;|&lt;/code&gt; &lt;code&gt;|&lt;/code&gt; , 및 &lt;code&gt;?:&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8437a6599312b98a4f8ede285a1950b78c0b6f0d" translate="yes" xml:space="preserve">
          <source>The only operators that can accept operands of type bool are: &lt;code&gt;&amp;amp;&lt;/code&gt;&lt;code&gt;|&lt;/code&gt;&lt;code&gt;^&lt;/code&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;&lt;code&gt;|&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;&lt;code&gt;^=&lt;/code&gt; ! &lt;code&gt;&amp;amp;&lt;/code&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;code&gt;|&lt;/code&gt;&lt;code&gt;|&lt;/code&gt;&lt;code&gt;?:&lt;/code&gt;.</source>
          <target state="translated">bool 유형의 피연산자를 허용 할 수있는 유일한 연산자는 다음 &lt;code&gt;&amp;amp;&lt;/code&gt; 같습니다. &amp;amp; &lt;code&gt;|&lt;/code&gt; &lt;code&gt;^&lt;/code&gt; &lt;code&gt;&amp;amp;&lt;/code&gt; &lt;code&gt;=&lt;/code&gt; &lt;code&gt;|&lt;/code&gt; &lt;code&gt;=&lt;/code&gt; &lt;code&gt;^=&lt;/code&gt; ! &lt;code&gt;&amp;amp;&lt;/code&gt; &lt;code&gt;&amp;amp;&lt;/code&gt; &lt;code&gt;|&lt;/code&gt; &lt;code&gt;|&lt;/code&gt; &lt;code&gt;?:&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1537443715ac19491a620a6f1ab8a8c13f12a2ec" translate="yes" xml:space="preserve">
          <source>The only pointers that are tracked are those declared in the &lt;code&gt;@live&lt;/code&gt; function as &lt;code&gt;this&lt;/code&gt;, function parameters or local variables. Variables from other functions are not tracked, even &lt;code&gt;@live&lt;/code&gt; ones, as the analysis of interactions with other functions depends entirely on that function signature, not its internals. Parameters that are &lt;code&gt;const&lt;/code&gt; are not tracked.</source>
          <target state="translated">추적되는 유일한 포인터는 &lt;code&gt;@live&lt;/code&gt; 함수에서 &lt;code&gt;this&lt;/code&gt; , 함수 매개 변수 또는 지역 변수 로 선언 된 포인터입니다 . 다른 함수 와의 상호 작용 분석은 내부가 아니라 해당 함수 시그니처에 전적으로 의존하기 때문에 다른 함수의 변수, 심지어 &lt;code&gt;@live&lt;/code&gt; 변수는 추적 되지 않습니다. &lt;code&gt;const&lt;/code&gt; 인 매개 변수는 추적되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="984e1c71edfda04f82606405d232f57e26747587" translate="yes" xml:space="preserve">
          <source>The only reason to have a max limit for this is to avoid the risk of a bad server feeding libcurl with a never-ending header that will cause reallocs infinitely</source>
          <target state="translated">이것에 대한 최대 제한을 갖는 유일한 이유는 끝없는 헤더로 libcurl을 공급하는 나쁜 서버의 위험을 피하여 재 할당을 무한정 발생시키는 것입니다</target>
        </trans-unit>
        <trans-unit id="6b3469bf6885e1dc5e98c3245a18dbbf237d2baa" translate="yes" xml:space="preserve">
          <source>The opAssign function will be built for a struct &lt;code&gt;S&lt;/code&gt; if the following constraints are met:</source>
          <target state="translated">opAssign 함수는 구조체를 위해 만들어 질 것입니다 &lt;code&gt;S&lt;/code&gt; 다음 제약 조건이 충족되면 S에 .</target>
        </trans-unit>
        <trans-unit id="7e056906d7315529b66ec021904f0bc134465c13" translate="yes" xml:space="preserve">
          <source>The operand syntax more or less follows the Intel CPU documentation conventions. In particular, the convention is that for two operand instructions the source is the right operand and the destination is the left operand. The syntax differs from that of Intel's in order to be compatible with the D language tokenizer and to simplify parsing.</source>
          <target state="translated">피연산자 구문은 인텔 CPU 설명서 규칙을 어느 정도 따릅니다. 특히, 두 개의 피연산자 명령어의 경우 소스는 오른쪽 피연산자이고 대상은 왼쪽 피연산자입니다. 구문은 D 언어 토크 나이저와 호환되고 구문 분석을 단순화하기 위해 인텔의 구문과 다릅니다.</target>
        </trans-unit>
        <trans-unit id="73d4a21766587b932de571c9748f396e770947d7" translate="yes" xml:space="preserve">
          <source>The operands are AND'd together.</source>
          <target state="translated">피연산자는 함께 AND됩니다.</target>
        </trans-unit>
        <trans-unit id="8d68364ecd5a5efc98bbefe2167cf9e02f879955" translate="yes" xml:space="preserve">
          <source>The operands are OR'd together.</source>
          <target state="translated">피연산자는 함께 OR됩니다.</target>
        </trans-unit>
        <trans-unit id="164b0a5deb7171b65940816115319c8c761747b7" translate="yes" xml:space="preserve">
          <source>The operands are XOR'd together.</source>
          <target state="translated">피연산자는 함께 XOR됩니다.</target>
        </trans-unit>
        <trans-unit id="efb02cff4c27dc22b01308f5fbd88aaf28eb4b20" translate="yes" xml:space="preserve">
          <source>The operands must be arithmetic types. They undergo the &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;Usual Arithmetic Conversions&lt;/a&gt;.</source>
          <target state="translated">피연산자는 산술 유형이어야합니다. 그들은 &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;일상적인 산술 변환을&lt;/a&gt; 겪습니다 .</target>
        </trans-unit>
        <trans-unit id="1d66ba90561dbdef784a715ae4ab9b7cee0e0776" translate="yes" xml:space="preserve">
          <source>The operands must be integral types, and undergo the &lt;a href=&quot;type#integer-promotions&quot;&gt;Integer Promotions&lt;/a&gt;. The result type is the type of the left operand after the promotions. The result value is the result of shifting the bits by the right operand's value.</source>
          <target state="translated">피연산자는 정수 유형이어야하며 &lt;a href=&quot;type#integer-promotions&quot;&gt;정수 프로모션을&lt;/a&gt; 받아야합니다 . 결과 유형은 승격 후 왼쪽 피연산자의 유형입니다. 결과 값은 비트를 오른쪽 피연산자 값만큼 이동 한 결과입니다.</target>
        </trans-unit>
        <trans-unit id="194f20d5a432fe368709d99fb1ac7743c7e38bcc" translate="yes" xml:space="preserve">
          <source>The operation takes time proportional to the number of adjacent free blocks at the front of the free list. These blocks get coalesced, whether &lt;code&gt;allocateAll&lt;/code&gt; succeeds or fails due to fragmentation.</source>
          <target state="translated">작업은 사용 가능한 목록의 앞쪽에있는 인접한 사용 가능한 블록 수에 비례하여 시간이 걸립니다. 여부를이 블록은, 합체 얻을 &lt;code&gt;allocateAll&lt;/code&gt; 이 성공하거나 단편화로 인해 실패합니다.</target>
        </trans-unit>
        <trans-unit id="f1c4e404ec78b75726373485d13f7546b584f7c2" translate="yes" xml:space="preserve">
          <source>The operator involved</source>
          <target state="translated">관련된 운영자</target>
        </trans-unit>
        <trans-unit id="56d4f8f0aeb6a713fa59381e88345eb1ab065529" translate="yes" xml:space="preserve">
          <source>The operator involved (without the &lt;code&gt;&quot;=&quot;&lt;/code&gt;, e.g. &lt;code&gt;&quot;+&quot;&lt;/code&gt; for &lt;code&gt;&quot;+=&quot;&lt;/code&gt; etc)</source>
          <target state="translated">관련된 연산자 ( 예 : &lt;code&gt;&quot;+&quot;&lt;/code&gt; &lt;code&gt;&quot;=&quot;&lt;/code&gt; 없이 ( 예 : &lt;code&gt;&quot;+=&quot;&lt;/code&gt; 등의 경우 &quot;+&quot; ))</target>
        </trans-unit>
        <trans-unit id="141e2b7ce22914ac93e27f77aab194720297a6c0" translate="yes" xml:space="preserve">
          <source>The operator involved in the &lt;code&gt;opAssign&lt;/code&gt; operation</source>
          <target state="translated">&lt;code&gt;opAssign&lt;/code&gt; 작업에 관련된 연산자</target>
        </trans-unit>
        <trans-unit id="c70edf6dccf2f2bcea3add3cefb68aaf253c7966" translate="yes" xml:space="preserve">
          <source>The operator symbol</source>
          <target state="translated">연산자 기호</target>
        </trans-unit>
        <trans-unit id="a647036ebf74c7864e90900632a3906ffefe590e" translate="yes" xml:space="preserve">
          <source>The operator symbol (without the &lt;code&gt;=&lt;/code&gt;)</source>
          <target state="translated">연산자 기호 ( &lt;code&gt;=&lt;/code&gt; 제외)</target>
        </trans-unit>
        <trans-unit id="e53e52b5f08d1bbd687148f6992aae7c464c1b9d" translate="yes" xml:space="preserve">
          <source>The operator, e.g. &lt;code&gt;-&lt;/code&gt;</source>
          <target state="translated">연산자, 예 : &lt;code&gt;-&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="638907907a566c0abcca8d70105d1f419f1a935d" translate="yes" xml:space="preserve">
          <source>The option &quot;--Foo&quot; is rejected due to &lt;code&gt;std.getopt.config.caseSensitive&lt;/code&gt;, but not &quot;--Bar&quot;, &quot;--bAr&quot; etc. because the directive &lt;code&gt;std.getopt.config.caseInsensitive&lt;/code&gt; turned sensitivity off before option &quot;bar&quot; was parsed.</source>
          <target state="translated">옵션 &quot;--Foo은&quot;인해 거부 &lt;code&gt;std.getopt.config.caseSensitive&lt;/code&gt; 있지만 &quot;--Bar&quot;, &quot;--bAr&quot;등을 지시 때문에 &lt;code&gt;std.getopt.config.caseInsensitive&lt;/code&gt; 옵션 전에 떨어져 감도 설정 &quot; bar &quot;가 파싱되었습니다.</target>
        </trans-unit>
        <trans-unit id="ca52d0f89f2c76dbc26910f2e62e7d1ae6cb85b2" translate="yes" xml:space="preserve">
          <source>The option character (default '-').</source>
          <target state="translated">옵션 문자 (기본값 '-')</target>
        </trans-unit>
        <trans-unit id="18b9f1ce4c729b2ded7edcf5db48cd7ab36a842d" translate="yes" xml:space="preserve">
          <source>The optional</source>
          <target state="translated">옵션</target>
        </trans-unit>
        <trans-unit id="2c9d42a79cf23316432c06818064db7b0873ce86" translate="yes" xml:space="preserve">
          <source>The optional arguments &lt;code&gt;stdin&lt;/code&gt;, &lt;code&gt;stdout&lt;/code&gt; and &lt;code&gt;stderr&lt;/code&gt; may be used to assign arbitrary &lt;a href=&quot;std_stdio#File&quot;&gt;&lt;code&gt;std.stdio.File&lt;/code&gt;&lt;/a&gt; objects as the standard input, output and error streams, respectively, of the child process. The former must be opened for reading, while the latter two must be opened for writing. The default is for the child process to inherit the standard streams of its parent.</source>
          <target state="translated">선택적 인수 &lt;code&gt;stdin&lt;/code&gt; , &lt;code&gt;stdout&lt;/code&gt; 및 &lt;code&gt;stderr&lt;/code&gt; 을 사용하여 임의의 &lt;a href=&quot;std_stdio#File&quot;&gt; &lt;code&gt;std.stdio.File&lt;/code&gt; &lt;/a&gt; 을 지정할 수 있습니다. 오브젝트를 하위 프로세스의 표준 입력, 출력 및 오류 스트림으로 각각 . 전자는 읽기 위해 열어야하고, 후자는 쓰기 위해 열어야합니다. 디폴트는 자식 프로세스가 부모의 표준 스트림을 상속하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="fa35856038ac4a3b33d6b7f25cf0f4d58ca154fb" translate="yes" xml:space="preserve">
          <source>The optional identifier in either type of &lt;code&gt;out&lt;/code&gt; contract is set to the return value of the function.</source>
          <target state="translated">유형 중 하나의 옵션 식별자 &lt;code&gt;out&lt;/code&gt; 계약 함수의 리턴 값으로 설정된다.</target>
        </trans-unit>
        <trans-unit id="2a198d0d9bb81399553ce901d094fc3b34485c1e" translate="yes" xml:space="preserve">
          <source>The optional parameters &lt;code&gt;sSelfSim&lt;/code&gt; and &lt;code&gt;tSelfSim&lt;/code&gt; are meant for avoiding duplicate computation. Many applications may have already computed &lt;code&gt;gapWeightedSimilarity(s, s, lambda)&lt;/code&gt; and/or &lt;code&gt;gapWeightedSimilarity(t, t, lambda)&lt;/code&gt;. In that case, they can be passed as &lt;code&gt;sSelfSim&lt;/code&gt; and &lt;code&gt;tSelfSim&lt;/code&gt;, respectively.</source>
          <target state="translated">선택적 매개 변수 &lt;code&gt;sSelfSim&lt;/code&gt; 및 &lt;code&gt;tSelfSim&lt;/code&gt; 은 중복 계산을 피하기위한 것입니다. 많은 응용 프로그램에서 이미 &lt;code&gt;gapWeightedSimilarity(s, s, lambda)&lt;/code&gt; 및 / 또는 &lt;code&gt;gapWeightedSimilarity(t, t, lambda)&lt;/code&gt; 계산 했을 수 있습니다 . 이 경우 각각 &lt;code&gt;sSelfSim&lt;/code&gt; 및 &lt;code&gt;tSelfSim&lt;/code&gt; 으로 전달 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5c87a0f28ba13b43a3c29d6c4b297e44986adfc3" translate="yes" xml:space="preserve">
          <source>The optional second &lt;a href=&quot;expression#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression&lt;/i&gt;&lt;/a&gt; can be used to supply additional information, such as a text string, that will be printed out along with the error diagnostic.</source>
          <target state="translated">선택적인 두 번째 &lt;a href=&quot;expression#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression&lt;/i&gt;&lt;/a&gt; 을 사용하면 오류 진단과 함께 인쇄 될 텍스트 문자열과 같은 추가 정보를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c53af2790b7d2658a475ec200743c6decbbbabb1" translate="yes" xml:space="preserve">
          <source>The options &lt;code&gt;minSize == unbounded&lt;/code&gt; and &lt;code&gt;maxSize == unbounded&lt;/code&gt; are not available for &lt;code&gt;ContiguousFreeList&lt;/code&gt;.</source>
          <target state="translated">옵션 &lt;code&gt;minSize == unbounded&lt;/code&gt; 및 &lt;code&gt;maxSize == unbounded&lt;/code&gt; 사용할 수 없습니다 &lt;code&gt;ContiguousFreeList&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="908f73a8a6b26eae214ea14d01c95ac8e585a696" translate="yes" xml:space="preserve">
          <source>The options corresponding to the statistics collected.</source>
          <target state="translated">수집 된 통계에 해당하는 옵션입니다.</target>
        </trans-unit>
        <trans-unit id="9f44bfb42bea099b410e3ae043b64bf941a3d3a9" translate="yes" xml:space="preserve">
          <source>The order in which</source>
          <target state="translated">순서</target>
        </trans-unit>
        <trans-unit id="b05eb5dee9e8e5735c1321572abe7fba26d328c8" translate="yes" xml:space="preserve">
          <source>The order in which modules are called to run their unit tests.</source>
          <target state="translated">단위 테스트를 실행하기 위해 모듈을 호출하는 순서입니다.</target>
        </trans-unit>
        <trans-unit id="ded62be1138c956a50d03fffedad7ec44e6f9533" translate="yes" xml:space="preserve">
          <source>The order in which modules are imported does not affect the semantics.</source>
          <target state="translated">모듈을 가져 오는 순서는 의미에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="506073a2cdf721a37f43310020509dea0ea03bee" translate="yes" xml:space="preserve">
          <source>The order in which the array elements are computed is implementation defined, and may even occur in parallel. An application must not depend on this order.</source>
          <target state="translated">배열 요소가 계산되는 순서는 구현 정의이며 병렬로 발생할 수도 있습니다. 응용 프로그램은이 순서에 의존해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="fae272dd73f8d57ce9c199e28861d6ffb1d9af6c" translate="yes" xml:space="preserve">
          <source>The order in which the strings appear in the result is not defined.</source>
          <target state="translated">문자열이 결과에 나타나는 순서는 정의되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ce7e17de4cb24469d3444a40e36096efcb9cbfd4" translate="yes" xml:space="preserve">
          <source>The order is defined as follows:</source>
          <target state="translated">순서는 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="29a373653e2bfc1cca0d961f259da0c1298ecbea" translate="yes" xml:space="preserve">
          <source>The order of evaluation of function arguments for functions with linkage other than &lt;code&gt;extern (D)&lt;/code&gt;.</source>
          <target state="translated">이외의 기능과 연동 기능 인자 평가 순서 &lt;code&gt;extern (D)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a021fc1e222d6a27aea27e4b5f97128841b9a128" translate="yes" xml:space="preserve">
          <source>The order of evaluation of the operands of &lt;a href=&quot;#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression&lt;/i&gt;&lt;/a&gt; 피연산자의 평가 순서입니다 .</target>
        </trans-unit>
        <trans-unit id="2d093662468f96c13ae9c5b9d6116c7cabff1635" translate="yes" xml:space="preserve">
          <source>The order of execution within a function is controlled by &lt;a href=&quot;#Statement&quot;&gt;&lt;i&gt;Statement&lt;/i&gt;&lt;/a&gt;s. A function's body consists of a sequence of zero or more</source>
          <target state="translated">함수 내에서의 실행 순서는 &lt;a href=&quot;#Statement&quot;&gt;&lt;i&gt;Statement에&lt;/i&gt;&lt;/a&gt; 의해 제어됩니다&lt;i&gt;&lt;/i&gt; . 함수의 본문은 0 이상의 시퀀스로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="86b67a2b0c6a048e601645470c096d4bbf2604b6" translate="yes" xml:space="preserve">
          <source>The order of static initialization is implicitly determined by the</source>
          <target state="translated">정적 초기화 순서는 다음과 같이 암시 적으로 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="24e23dd7191b5b1c5bce0de2b67d0f3911ebed53" translate="yes" xml:space="preserve">
          <source>The ordering predicate to use to determine the extremum (minimum or maximum) element.</source>
          <target state="translated">극단 (최소 또는 최대) 요소를 판별하는 데 사용하는 순서 술어.</target>
        </trans-unit>
        <trans-unit id="15fe5b10e5755a86213c0dc1ab135ad913a77ba2" translate="yes" xml:space="preserve">
          <source>The ordering predicate to use to determine the extremum (minimum or maximum).</source>
          <target state="translated">극단 (최소 또는 최대)을 결정하는 데 사용하는 순서 술어.</target>
        </trans-unit>
        <trans-unit id="15cad23161bf9aec9c429568dd291ae988b53252" translate="yes" xml:space="preserve">
          <source>The ordering predicate to use to determine the maximum element.</source>
          <target state="translated">최대 요소를 결정하는 데 사용할 순서 술어.</target>
        </trans-unit>
        <trans-unit id="c31f591c19316494ae227e4269b1bc55d8071c12" translate="yes" xml:space="preserve">
          <source>The ordering predicate to use to determine the minimum element.</source>
          <target state="translated">최소 요소를 결정하는 데 사용할 순서 술어.</target>
        </trans-unit>
        <trans-unit id="c29760283ce7793aa4d7bc71616456fe1b03fbb5" translate="yes" xml:space="preserve">
          <source>The ordering to be used to determine lexicographical ordering of the permutations.</source>
          <target state="translated">순열의 사전 순서를 결정하는 데 사용되는 순서입니다.</target>
        </trans-unit>
        <trans-unit id="e1d7ba6a0bf70661c8825f1616095c8946712ba1" translate="yes" xml:space="preserve">
          <source>The original input string which should have been parsed.</source>
          <target state="translated">파싱해야 할 원래 입력 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="d69e475dd9b96313d02abbca4307d1659af41d28" translate="yes" xml:space="preserve">
          <source>The original range.</source>
          <target state="translated">원래 범위.</target>
        </trans-unit>
        <trans-unit id="8724db772d60fec4013f34182f1e847ecec76068" translate="yes" xml:space="preserve">
          <source>The original string.</source>
          <target state="translated">원래 문자열.</target>
        </trans-unit>
        <trans-unit id="59de85bb0dd2a62ce448e919359e8b24cc7a90ea" translate="yes" xml:space="preserve">
          <source>The osthread module provides low-level, OS-dependent code for thread creation and management.</source>
          <target state="translated">osthread 모듈은 스레드 생성 및 관리를위한 하위 수준의 OS 종속 코드를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="2c0e83de5dd344b677213345fa51e9db2eed3ab8" translate="yes" xml:space="preserve">
          <source>The other &lt;code&gt;ClockType&lt;/code&gt;s are provided so that other clocks provided by the underlying C, system calls can be used with &lt;a href=&quot;#MonoTimeImpl&quot;&gt;&lt;code&gt;MonoTimeImpl&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;std.datetime.Clock.currTime&lt;/code&gt; without having to use the C API directly.</source>
          <target state="translated">다른 &lt;code&gt;ClockType&lt;/code&gt; 은 기본 C에서 제공하는 다른 시계가 제공되므로 C API를 직접 사용할 필요없이 시스템 호출을 &lt;a href=&quot;#MonoTimeImpl&quot;&gt; &lt;code&gt;MonoTimeImpl&lt;/code&gt; &lt;/a&gt; 또는 &lt;code&gt;std.datetime.Clock.currTime&lt;/code&gt; 과 함께 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c97e71bfcc50324ba20390fc9837bc308a37f3b9" translate="yes" xml:space="preserve">
          <source>The other piece of data used is the DWARF &lt;code&gt;.debug_line&lt;/code&gt; section, which contains the line informations of a program, necessary to associate the instruction address with its (file, line) information.  Since debug lines informations are quite large, they are encoded using a program that is to be fed to a finite state machine. See &lt;code&gt;runStateMachine&lt;/code&gt; and &lt;code&gt;readLineNumberProgram&lt;/code&gt; for more details.</source>
          <target state="translated">사용되는 다른 데이터는 DWARF &lt;code&gt;.debug_line&lt;/code&gt; 섹션으로, 프로그램의 행 정보를 포함하며 명령어 주소를 (파일, 행) 정보와 연관시키는 데 필요합니다. 디버그 라인 정보는 매우 크기 때문에 유한 상태 머신에 제공되는 프로그램을 사용하여 인코딩됩니다. 자세한 내용은 &lt;code&gt;runStateMachine&lt;/code&gt; 및 &lt;code&gt;readLineNumberProgram&lt;/code&gt; 을 참조하세요.</target>
        </trans-unit>
        <trans-unit id="b74ff8ee45b0b8f3cea227a5cb8b0ca2512e0fa1" translate="yes" xml:space="preserve">
          <source>The output is:</source>
          <target state="translated">출력은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a69373623c7518d00fa36ea24366f398f8ce8bad" translate="yes" xml:space="preserve">
          <source>The output of the code above is:</source>
          <target state="translated">위 코드의 결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="515b77d0f9f95e74d1d9b053ac5339be1c82aca5" translate="yes" xml:space="preserve">
          <source>The output range used to write the help information.</source>
          <target state="translated">도움말 정보를 작성하는 데 사용되는 출력 범위.</target>
        </trans-unit>
        <trans-unit id="708e6e32f4bb4d910b35568c24af1ecbdd8ae5b7" translate="yes" xml:space="preserve">
          <source>The overflow indicator (assigned &lt;code&gt;true&lt;/code&gt; in case there's an error)</source>
          <target state="translated">오버플로 표시기 ( 오류가있는 경우 &lt;code&gt;true&lt;/code&gt; 로 지정됨 )</target>
        </trans-unit>
        <trans-unit id="49d360d20fd79e75a1f6f41c1f5efdbc589a5b18" translate="yes" xml:space="preserve">
          <source>The overflow is sticky, meaning a sequence of operations can be done and overflow need only be checked at the end.</source>
          <target state="translated">오버플로는 고정적이므로 일련의 작업을 수행 할 수 있으며 오버플로는 끝에서만 확인하면됩니다.</target>
        </trans-unit>
        <trans-unit id="ef93ac8e948c5ada2f00084b4ec036473c66f367" translate="yes" xml:space="preserve">
          <source>The overlapping portion of the two arrays.</source>
          <target state="translated">두 배열의 겹치는 부분.</target>
        </trans-unit>
        <trans-unit id="fae150090ecb0366b43d58bfc4a6f3010da8d11c" translate="yes" xml:space="preserve">
          <source>The overload which accepts function arguments takes integral types in the order that the time unit strings were given, and those integers are passed by &lt;code&gt;ref&lt;/code&gt;. split assigns the values for the units to each corresponding integer. Any integral type may be used, but no attempt is made to prevent integer overflow, so don't use small integral types in circumstances where the values for those units aren't likely to fit in an integral type that small.</source>
          <target state="translated">함수 인수를 허용하는 오버로드에는 시간 단위 문자열이 제공된 순서대로 정수 유형이 사용되며 해당 정수는 &lt;code&gt;ref&lt;/code&gt; 로 전달됩니다 . split은 단위 값을 각 해당 정수에 할당합니다. 모든 정수 유형을 사용할 수 있지만 정수 오버플로를 방지하려는 시도는 없으므로 해당 단위의 값이 작은 정수 유형에 맞지 않는 상황에서는 작은 정수 유형을 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="8a27d36415963d11bb0a2a74d725380e58b5b81a" translate="yes" xml:space="preserve">
          <source>The overload with no arguments returns the values for the units in a struct with members whose names are the same as the given time unit strings. The members are all &lt;code&gt;long&lt;/code&gt;s. This overload will also work with no time strings being given, in which case</source>
          <target state="translated">인수가없는 오버로드는 주어진 시간 단위 문자열과 이름이 같은 멤버를 가진 구조체의 단위 값을 반환합니다. 멤버는 모두 &lt;code&gt;long&lt;/code&gt; . 이 오버로드는 시간 문자열이 제공되지 않은 상태에서도 작동합니다.</target>
        </trans-unit>
        <trans-unit id="36651e7ea0b89af408ad5149a0f7f1de2f23e2a1" translate="yes" xml:space="preserve">
          <source>The owner is the sole pointer to a memory object graph. An Owner pointer normally does not have a &lt;code&gt;scope&lt;/code&gt; attribute. If a pointer with the &lt;code&gt;scope&lt;/code&gt; attribute is initialized with an expression not derived from a tracked pointer, it is an Owner.  If an Owner pointer is assigned to another Owner pointer, the former enters the Undefined state.</source>
          <target state="translated">소유자는 메모리 개체 그래프에 대한 유일한 포인터입니다. 일반적으로 소유자 포인터에는 &lt;code&gt;scope&lt;/code&gt; 속성 이 없습니다 . &lt;code&gt;scope&lt;/code&gt; 속성이 있는 포인터가 추적 된 포인터에서 파생되지 않은 표현식으로 초기화되면 소유자가됩니다. 소유자 포인터가 다른 소유자 포인터에 할당되면 전자는 정의되지 않음 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="260af145e3cbda28a26f16fe1989f4e1c8d1a0d0" translate="yes" xml:space="preserve">
          <source>The package module can then be imported with the standard module import declaration:</source>
          <target state="translated">그런 다음 표준 모듈 가져 오기 선언으로 패키지 모듈을 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5512330e5fcd74efc6dbc5aca616099f51685035" translate="yes" xml:space="preserve">
          <source>The package module must have the file name &lt;code&gt;package.d&lt;/code&gt;. The module name is declared to be the fully qualified name of the package. Package modules can be imported just like any other modules:</source>
          <target state="translated">패키지 모듈에는 파일 이름 &lt;code&gt;package.d&lt;/code&gt; 가 있어야합니다 . 모듈 이름은 패키지의 완전한 이름으로 선언됩니다. 패키지 모듈은 다른 모듈과 마찬가지로 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e03b2152cc1b6a58ba8032733b5d2def3eb73480" translate="yes" xml:space="preserve">
          <source>The package module's file name must be &lt;code&gt;package.d&lt;/code&gt;. The module name is declared to be the fully qualified name of the package. Package modules can be imported just like any other modules:</source>
          <target state="translated">패키지 모듈의 파일 이름은 &lt;code&gt;package.d&lt;/code&gt; 여야합니다 . 모듈 이름은 패키지의 완전한 이름으로 선언됩니다. 패키지 모듈은 다른 모듈과 마찬가지로 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="136770d3c4f96881a7cd83ac52b3b200de071989" translate="yes" xml:space="preserve">
          <source>The padding data can be accessed, but its contents are undefined.</source>
          <target state="translated">패딩 데이터에 액세스 할 수 있지만 해당 내용은 정의되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c23637ad29e92d690ee7e91ffa4bbac52dae1105" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;level&lt;/code&gt; indicates the number of trie levels to use, allowed values are: 1, 2, 3 or 4. Levels represent different trade-offs speed-size wise.</source>
          <target state="translated">파라미터 &lt;code&gt;level&lt;/code&gt; 은 사용할 트리 레벨의 수를 나타내며 허용되는 값은 1, 2, 3 또는 4입니다. 레벨은 속도 크기에 따라 다른 절충점을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="0ee7ae2b2ebe38b1747e38029361876a0bcd2e42" translate="yes" xml:space="preserve">
          <source>The parameter is an</source>
          <target state="translated">매개 변수는</target>
        </trans-unit>
        <trans-unit id="14dbb4daa817a9a1b69f1e2b66e17c6c825d9628" translate="yes" xml:space="preserve">
          <source>The parameter is an input to the function. Input parameters behaves as if they have the &lt;code&gt;const scope&lt;/code&gt; storage classes. Input parameters may be passed by reference by the compiler. Unlike &lt;code&gt;ref&lt;/code&gt; parameters, &lt;code&gt;in&lt;/code&gt; parameters can bind to both lvalues and rvalues (such as literals). Types that would trigger a side effect if passed by value (such as types with postblit, copy constructor, or destructor), and types which cannot be copied, e.g. if their copy constructor is marked as &lt;code&gt;@disable&lt;/code&gt;, will always be passed by reference. Dynamic arrays, classes, associative arrays, function pointers, and delegates will always be passed by value, to allow for covariance. If the type of the parameter does not fall in one of those categories, whether or not it is passed by reference is implementation defined, and the backend is free to choose the method that will best fit the ABI of the platform. Note: This requires the &lt;code&gt;-preview=in&lt;/code&gt; switch, available in v2.094.0 or higher.</source>
          <target state="translated">매개 변수는 함수에 대한 입력입니다. 입력 매개 변수는 마치 &lt;code&gt;const scope&lt;/code&gt; 스토리지 클래스 가있는 것처럼 작동 합니다. 입력 매개 변수는 컴파일러에서 참조로 전달할 수 있습니다. &lt;code&gt;ref&lt;/code&gt; 매개 변수 와 달리 &lt;code&gt;in&lt;/code&gt; 매개 변수는 lvalue와 rvalue (예 : 리터럴) 모두에 바인딩 할 수 있습니다. 값으로 전달되면 부작용을 유발하는 유형 (예 : postblit, 복사 생성자 또는 소멸자가있는 유형) 및 복사 할 수없는 유형 (예 : 복사 생성자가 &lt;code&gt;@disable&lt;/code&gt; 로 표시된 경우), 항상 참조로 전달됩니다. 동적 배열, 클래스, 연관 배열, 함수 포인터 및 대리자는 공분산을 허용하기 위해 항상 값으로 전달됩니다. 매개 변수 유형이 이러한 범주 중 하나에 속하지 않는 경우 참조로 전달되는지 여부는 구현에 의해 정의되며 백엔드는 플랫폼의 ABI에 가장 적합한 방법을 자유롭게 선택할 수 있습니다. 참고 : v2.094.0 이상에서 사용 가능한 &lt;code&gt;-preview=in&lt;/code&gt; 스위치 가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="0758911fe007939762ea0a98ab73ee500552cb01" translate="yes" xml:space="preserve">
          <source>The parameter may be a number (as shown in the example above) dictating the size of each chunk. Alternatively, &lt;code&gt;byChunk&lt;/code&gt; accepts a user-provided buffer that it uses directly.</source>
          <target state="translated">파라미터는 각 청크의 크기를 지시하는 숫자 일 수있다 (상기 예에 도시 된 바와 같이). 또는 &lt;code&gt;byChunk&lt;/code&gt; 는 직접 사용하는 사용자 제공 버퍼를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="3a7b9fcbdd08c7e12be96a35248bec20128f934f" translate="yes" xml:space="preserve">
          <source>The parameter must not escape the function call (e.g. by being assigned to a global variable). Ignored for any parameter that is not a reference type.</source>
          <target state="translated">매개 변수는 함수 호출을 이스케이프해서는 안됩니다 (예 : 전역 변수에 할당 됨). 참조 유형이 아닌 모든 매개 변수에 대해서는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="da7a5827114de776669ef80597ccf4da04a43fa6" translate="yes" xml:space="preserve">
          <source>The parameter will be a mutable copy of its argument</source>
          <target state="translated">매개 변수는 인수의 변경 가능한 사본이됩니다.</target>
        </trans-unit>
        <trans-unit id="c903948dffd2abfd68770b5195aac5d542b83003" translate="yes" xml:space="preserve">
          <source>The parameters of this distribution. The random number is x = (x * multipler + increment) % modulus.</source>
          <target state="translated">이 분포의 모수. 난수는 x = (x * 멀티플렉서 + 증분) % 계수입니다.</target>
        </trans-unit>
        <trans-unit id="2c7bb35e4246e498ccd1516d5c0a045c041414c6" translate="yes" xml:space="preserve">
          <source>The parameters to the non-variadic function:</source>
          <target state="translated">비 변형 함수에 대한 매개 변수 :</target>
        </trans-unit>
        <trans-unit id="8c00f330278c8a3688d755f58c6ef387d6c281e7" translate="yes" xml:space="preserve">
          <source>The parameters to the variadic function:</source>
          <target state="translated">variadic 함수에 대한 매개 변수 :</target>
        </trans-unit>
        <trans-unit id="5ebad486f6049114c19bd433cacf524aaf10fabc" translate="yes" xml:space="preserve">
          <source>The parameters with which to instantiate the template.</source>
          <target state="translated">템플릿을 인스턴스화하는 데 사용되는 매개 변수입니다.</target>
        </trans-unit>
        <trans-unit id="4fbe12ec5cf422714865a37fd1864dec27719969" translate="yes" xml:space="preserve">
          <source>The parent allocator is publicly accessible either as a direct member if it holds state, or as an alias to &lt;code&gt;Allocator.instance&lt;/code&gt; otherwise. One may use it for making calls that won't count toward statistics collection.</source>
          <target state="translated">부모 할당자는 상태를 유지하는 경우 직접 멤버로, 그렇지 않으면 &lt;code&gt;Allocator.instance&lt;/code&gt; 의 별칭으로 공개적으로 액세스 할 수 있습니다 . 통계 수집에 포함되지 않는 전화를 걸 때 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a7916e9fe1cbcecc9e5b2265b50cee59f409bc09" translate="yes" xml:space="preserve">
          <source>The parent allocator. Depending on whether &lt;code&gt;ParentAllocator&lt;/code&gt; holds state or not, this is a member variable or an alias for &lt;code&gt;ParentAllocator.instance&lt;/code&gt;.</source>
          <target state="translated">부모 할당 자. 여부에 따라 &lt;code&gt;ParentAllocator&lt;/code&gt; 이 상태를 유지 여부,이 멤버 변수 또는 별칭이다 &lt;code&gt;ParentAllocator.instance&lt;/code&gt; 이 .</target>
        </trans-unit>
        <trans-unit id="6a766f10bdfc11306f72dafd5b728bd7317c675f" translate="yes" xml:space="preserve">
          <source>The parser initially sets it to TOK.concatenateAssign, and semantic() later decides which of the three it will be set to.</source>
          <target state="translated">파서는 처음에이를 TOK.concatenateAssign으로 설정하고, semantic ()은 나중에 세 가지 중 어느 것을 설정 할지를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="8ca59cb5bd26311e5307aeb5f44c313335ea3580" translate="yes" xml:space="preserve">
          <source>The passed in input was correct, but more input was expected.</source>
          <target state="translated">전달 된 입력이 정확했지만 더 많은 입력이 예상되었습니다.</target>
        </trans-unit>
        <trans-unit id="04a94fe6ab7793bd68edc946edd3c4d4f906c623" translate="yes" xml:space="preserve">
          <source>The passed text will be printed first, followed by a newline, then the short and long version of every option will be printed. The short and long version will be aligned to the longest option of every &lt;code&gt;Option&lt;/code&gt; passed. If the option is required, then &quot;Required:&quot; will be printed after the long version of the &lt;code&gt;Option&lt;/code&gt;. If a help message is present it will be printed next. The format is illustrated by this code:</source>
          <target state="translated">전달 된 텍스트가 먼저 인쇄되고 줄 바꿈이 인쇄 된 다음 모든 옵션의 짧고 긴 버전이 인쇄됩니다. 짧고 긴 버전은 전달 된 모든 &lt;code&gt;Option&lt;/code&gt; 의 가장 긴 옵션에 맞춰집니다 . 옵션이 필요한 경우, 긴 버전의 &lt;code&gt;Option&lt;/code&gt; 후에 &quot;필수 :&quot;가 인쇄됩니다 . 도움말 메시지가 있으면 다음에 인쇄됩니다. 형식은 다음 코드로 설명됩니다.</target>
        </trans-unit>
        <trans-unit id="ae0176808c4338a2b32bdc055054955a47109b3c" translate="yes" xml:space="preserve">
          <source>The path given by &lt;code&gt;path&lt;/code&gt;, with the extension given by &lt;code&gt;ext&lt;/code&gt; appended if the path doesn't already have one.  Including the dot in the extension is optional.  This function always allocates a new string, except in the case when path is immutable and already has an extension.</source>
          <target state="translated">경로는 주어진 &lt;code&gt;path&lt;/code&gt; 로 지정된 확장자를 가진, &lt;code&gt;ext&lt;/code&gt; 경로가 이미이없는 경우 추가. 확장에 점을 포함시키는 것은 선택 사항입니다. 이 함수는 경로가 변경 불가능하고 이미 확장자가있는 경우를 제외하고 항상 새 문자열을 할당합니다.</target>
        </trans-unit>
        <trans-unit id="9978fd2b7b1c58a32b59d2d933a84ff2eeb9cad1" translate="yes" xml:space="preserve">
          <source>The path name to expand.</source>
          <target state="translated">확장 할 경로 이름입니다.</target>
        </trans-unit>
        <trans-unit id="dba74006c9911dd825361c79175c3816c02f4fd6" translate="yes" xml:space="preserve">
          <source>The path of the executable as a &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; 로 실행 파일의 경로입니다 .</target>
        </trans-unit>
        <trans-unit id="8c35dcd32a0cd2b956596caddc202c46a4ae3354" translate="yes" xml:space="preserve">
          <source>The path to be matched against</source>
          <target state="translated">일치하는 경로</target>
        </trans-unit>
        <trans-unit id="a5d7f6c37fe93af27b88af304f713208b3e7e43a" translate="yes" xml:space="preserve">
          <source>The path to the file.</source>
          <target state="translated">파일의 경로입니다.</target>
        </trans-unit>
        <trans-unit id="b9caa4476a8447e566c7b52e6155891828512bf8" translate="yes" xml:space="preserve">
          <source>The path to the shell to use to run the specified program. By default this is &lt;a href=&quot;#nativeShell&quot;&gt;&lt;code&gt;nativeShell&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">지정된 프로그램을 실행하는 데 사용할 쉘 경로입니다. 기본적으로 이것은 &lt;a href=&quot;#nativeShell&quot;&gt; &lt;code&gt;nativeShell&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a791a6dee2401c3ac563dc595efe14cc5ee858e9" translate="yes" xml:space="preserve">
          <source>The permutation to permutate &lt;code&gt;range&lt;/code&gt; to.</source>
          <target state="translated">순열 &lt;code&gt;range&lt;/code&gt; 의 순열 입니다.</target>
        </trans-unit>
        <trans-unit id="3bf6df59e4efc6178ad86ce4d172dd74e35f57bc" translate="yes" xml:space="preserve">
          <source>The permuted range.</source>
          <target state="translated">순열 된 범위입니다.</target>
        </trans-unit>
        <trans-unit id="b51b8abc388ed1faa0574f36244673bca9d03127" translate="yes" xml:space="preserve">
          <source>The pivot element.</source>
          <target state="translated">피벗 요소.</target>
        </trans-unit>
        <trans-unit id="2141dbd9249b3127ee2311abb3285ea6f62646d8" translate="yes" xml:space="preserve">
          <source>The plan is to support all of the above except throwing D exceptions directly in C++ code (but they will be throwable indirectly by calling into a D function with C++ linkage).</source>
          <target state="translated">계획은 C ++ 코드에서 D 예외를 직접 던지는 것을 제외하고는 위의 모든 것을 지원하는 것입니다 (그러나 C ++ 연결로 D 함수를 호출하여 간접적으로 throw 할 수 있습니다).</target>
        </trans-unit>
        <trans-unit id="5e9fcc91fd47a551fe2c3ec3018788e0626a6afc" translate="yes" xml:space="preserve">
          <source>The platform-specific native shell path.</source>
          <target state="translated">플랫폼 별 고유 셸 경로입니다.</target>
        </trans-unit>
        <trans-unit id="c744ae6de5a0c2342c1ec26c71bf9d84af5482c5" translate="yes" xml:space="preserve">
          <source>The point is to allow AliasDeclarationY to use &lt;code&gt;__traits()&lt;/code&gt;, see issue 7804.</source>
          <target state="translated">요점은 AliasDeclarationY가 &lt;code&gt;__traits()&lt;/code&gt; 를 사용하도록 허용하는 것입니다 ( 문제 7804 참조 ) .</target>
        </trans-unit>
        <trans-unit id="0b4bb95d6a8d2b3e99a53954eaab5d58c7eb10b4" translate="yes" xml:space="preserve">
          <source>The pointer</source>
          <target state="translated">포인터</target>
        </trans-unit>
        <trans-unit id="cf7acba2bb0e0c6f04c4c0cb72022cca37ae2438" translate="yes" xml:space="preserve">
          <source>The pointer is in an invalid state. Dereferencing such a pointer is an error.</source>
          <target state="translated">포인터가 잘못된 상태에 있습니다. 그러한 포인터를 역 참조하는 것은 오류입니다.</target>
        </trans-unit>
        <trans-unit id="fd5b5206507758892b71f3f58e5e23e1c1f7f65c" translate="yes" xml:space="preserve">
          <source>The pointer, dynamic array, or reference is set to &lt;code&gt;null&lt;/code&gt; after the delete is performed. Any attempt to reference the data after the deletion via another reference to it will result in undefined behavior.</source>
          <target state="translated">삭제가 수행 된 후 포인터, 동적 배열 또는 참조가 &lt;code&gt;null&lt;/code&gt; 설정됩니다 . 다른 참조를 통해 삭제 후 데이터를 참조하려고하면 정의되지 않은 동작이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="594f71d424c88492080e5062a3ecf8853308a43e" translate="yes" xml:space="preserve">
          <source>The pointer-based version returns a &lt;code&gt;SortedRange&lt;/code&gt; wrapper over index, of type &lt;code&gt;SortedRange!(RangeIndex, (a, b) =&amp;gt; binaryFun!less(*a, *b))&lt;/code&gt; thus reflecting the ordering of the index. The index-based version returns &lt;code&gt;void&lt;/code&gt; because the ordering relation involves not only &lt;code&gt;index&lt;/code&gt; but also &lt;code&gt;r&lt;/code&gt;.</source>
          <target state="translated">포인터 기반 버전은 &lt;code&gt;SortedRange!(RangeIndex, (a, b) =&amp;gt; binaryFun!less(*a, *b))&lt;/code&gt; 유형의 인덱스에 대해 &lt;code&gt;SortedRange&lt;/code&gt; 래퍼를 반환 하므로 인덱스의 순서가 반영됩니다. 순서 관계에는 &lt;code&gt;index&lt;/code&gt; 뿐만 아니라 &lt;code&gt;r&lt;/code&gt; 도 포함되므로 인덱스 기반 버전은 &lt;code&gt;void&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="4c0b6520bd81ff00673e639fb3748bb290589c44" translate="yes" xml:space="preserve">
          <source>The policy to use.</source>
          <target state="translated">사용할 정책.</target>
        </trans-unit>
        <trans-unit id="5bfa0d8b059a39ab26c6f284f964719eecf94f69" translate="yes" xml:space="preserve">
          <source>The policy used by this mutex.</source>
          <target state="translated">이 뮤텍스가 사용하는 정책.</target>
        </trans-unit>
        <trans-unit id="8629893a44c9c276074edd00bae067e6b519cbda" translate="yes" xml:space="preserve">
          <source>The position in &lt;code&gt;array&lt;/code&gt; to insert the &lt;code&gt;stuff&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;stuff&lt;/code&gt; 를 삽입 할 &lt;code&gt;array&lt;/code&gt; 의 위치입니다 .</target>
        </trans-unit>
        <trans-unit id="e9eb86610993ddd6856217e1e6d70c91e6f75dbc" translate="yes" xml:space="preserve">
          <source>The position in the input string where the error occurred.</source>
          <target state="translated">오류가 발생한 입력 문자열의 위치입니다.</target>
        </trans-unit>
        <trans-unit id="f421096d1588c50f7ea09d98220627162688c28b" translate="yes" xml:space="preserve">
          <source>The position of the minimum (respectively maximum) element of forward range &lt;code&gt;range&lt;/code&gt;, i.e. a subrange of &lt;code&gt;range&lt;/code&gt; starting at the position of its smallest (respectively largest) element and with the same ending as &lt;code&gt;range&lt;/code&gt;.</source>
          <target state="translated">최소의 기대 범위 (각각 최대)의 요소의 위치 &lt;code&gt;range&lt;/code&gt; , 즉, 부분 범위의 &lt;code&gt;range&lt;/code&gt; 는 최소 (각각 최대)의 요소의 위치와 같은 끝에서 시작 &lt;code&gt;range&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="51fc654e8d5c11108a73d4836e9e77c133dfb257" translate="yes" xml:space="preserve">
          <source>The possible states of the &lt;code&gt;Ternary&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Ternary&lt;/code&gt; 의 가능한 상태</target>
        </trans-unit>
        <trans-unit id="76c6cabbb86643a051bf73c292aa98533c672138" translate="yes" xml:space="preserve">
          <source>The possible targets are computed more conservatively than the language allows, eliminating all dangerous conversions. For example, &lt;code&gt;ImplicitConversionTargets!double&lt;/code&gt; does not include &lt;code&gt;float&lt;/code&gt;.</source>
          <target state="translated">가능한 목표는 언어가 허용하는 것보다 더 보수적으로 계산되어 위험한 변환을 모두 제거합니다. 예를 들어 &lt;code&gt;ImplicitConversionTargets!double&lt;/code&gt; 에는 &lt;code&gt;float&lt;/code&gt; 이 포함되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="11d29604df18454624b74cfa89078e0417260306" translate="yes" xml:space="preserve">
          <source>The possible values for units are &lt;code&gt;&quot;weeks&quot;&lt;/code&gt;, &lt;code&gt;&quot;days&quot;&lt;/code&gt;, &lt;code&gt;&quot;hours&quot;&lt;/code&gt;, &lt;code&gt;&quot;minutes&quot;&lt;/code&gt;, &lt;code&gt;&quot;seconds&quot;&lt;/code&gt;, &lt;code&gt;&quot;msecs&quot;&lt;/code&gt; (milliseconds), &lt;code&gt;&quot;usecs&quot;&lt;/code&gt;, (microseconds), &lt;code&gt;&quot;hnsecs&quot;&lt;/code&gt; (hecto-nanoseconds, i.e. 100 ns), and &lt;code&gt;&quot;nsecs&quot;&lt;/code&gt;.</source>
          <target state="translated">가능한 단위 값은 &lt;code&gt;&quot;weeks&quot;&lt;/code&gt; , &lt;code&gt;&quot;days&quot;&lt;/code&gt; , &lt;code&gt;&quot;hours&quot;&lt;/code&gt; , &lt;code&gt;&quot;minutes&quot;&lt;/code&gt; , &lt;code&gt;&quot;seconds&quot;&lt;/code&gt; , &lt;code&gt;&quot;msecs&quot;&lt;/code&gt; (milliseconds), &lt;code&gt;&quot;usecs&quot;&lt;/code&gt; , (microseconds), &lt;code&gt;&quot;hnsecs&quot;&lt;/code&gt; ( hecto -nanoseconds, 즉 100 ns) 및 &lt;code&gt;&quot;nsecs&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4c4f82ffde3ae1f423f2307932836a1e645ef668" translate="yes" xml:space="preserve">
          <source>The postblits &lt;code&gt;__fieldPostblit&lt;/code&gt; and &lt;code&gt;__aggrPostblit&lt;/code&gt; are generated without any implicit qualifiers and are not considered struct members. This leads to the situation where qualifying an entire struct declaration with &lt;code&gt;const&lt;/code&gt; or &lt;code&gt;immutable&lt;/code&gt; does not have any impact on the above-mentioned postblits. However, since &lt;code&gt;__xpostblit&lt;/code&gt; is a member of the struct and an alias of one of the other postblits, the qualifiers applied to the struct will affect the aliased postblit.</source>
          <target state="translated">postblits &lt;code&gt;__fieldPostblit&lt;/code&gt; 및 &lt;code&gt;__aggrPostblit&lt;/code&gt; 은 암시 적 한정자없이 생성되며 구조체 멤버로 간주되지 않습니다. 이는 &lt;code&gt;const&lt;/code&gt; 또는 &lt;code&gt;immutable&lt;/code&gt; 전체 구조체 선언을 규정하는 것이 위에서 언급 한 포스트 블리트에 영향을 미치지 않는 상황으로 이어집니다 . 그러나 &lt;code&gt;__xpostblit&lt;/code&gt; 은 구조체의 멤버이고 다른 포스트 블리트 중 하나의 별칭이므로 구조체에 적용된 한정자가 앨리어싱 된 포스트 블리트에 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="d47161252adc52b1f430344a53bb4997710446f2" translate="yes" xml:space="preserve">
          <source>The power modulus value of (base ^ exponent) % modulus.</source>
          <target state="translated">(base ^ exponent) % modulus의 거듭 제곱 계수 값입니다.</target>
        </trans-unit>
        <trans-unit id="309c3d73f76b800f2ba5fd6059ce5bcf824a5c98" translate="yes" xml:space="preserve">
          <source>The pre contracts specify the preconditions before a statement is executed. The most typical use of this would be in validating the parameters to a function. The post contracts validate the result of the statement. The most typical use of this would be in validating the return value of a function and of any side effects it has. In D, pre contracts begin with &lt;code&gt;in&lt;/code&gt;, and post contracts begin with &lt;code&gt;out&lt;/code&gt;. They come at the end of the function signature and before the opening brace of the function body.</source>
          <target state="translated">사전 계약은 명령문이 실행되기 전에 사전 조건을 지정합니다. 이를 사용하는 가장 일반적인 용도는 매개 변수를 함수로 검증하는 것입니다. 사후 계약은 명세서의 결과를 검증합니다. 가장 일반적인 용도는 함수의 반환 값과 함수의 부작용을 확인하는 것입니다. D에서 사전 계약은 &lt;code&gt;in&lt;/code&gt; 로 시작 하고 사후 계약은 &lt;code&gt;out&lt;/code&gt; 로 시작 합니다 . 그것들은 함수 서명의 끝과 함수 몸체의 열기 괄호 앞에옵니다.</target>
        </trans-unit>
        <trans-unit id="bad3757e2d3ea8e03615372cc42932fa498e0342" translate="yes" xml:space="preserve">
          <source>The predicate &lt;code&gt;less&lt;/code&gt; defines the lexicographical ordering to be used on the range.</source>
          <target state="translated">술어 는 범위에서 사용되는 사전 순을 &lt;code&gt;less&lt;/code&gt; 정의합니다.</target>
        </trans-unit>
        <trans-unit id="75eafad6126e4b32c7a8770becfcb1f1b009b4fa" translate="yes" xml:space="preserve">
          <source>The predicate &lt;code&gt;pred&lt;/code&gt; needs to accept an element of &lt;code&gt;r&lt;/code&gt; and the separator &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">술어 &lt;code&gt;pred&lt;/code&gt; 는 &lt;code&gt;r&lt;/code&gt; 의 요소 와 구분 기호 &lt;code&gt;s&lt;/code&gt; 를 허용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="73639f6f297aaeaa7398fc5473b39c5c235bf984" translate="yes" xml:space="preserve">
          <source>The predicate for comparing each element with the needle, defaulting to equality &lt;code&gt;&quot;a == b&quot;&lt;/code&gt;. The negated predicate &lt;code&gt;&quot;a != b&quot;&lt;/code&gt; can be used to search instead for the first element</source>
          <target state="translated">각 요소를 바늘과 비교하기위한 술어, 기본값은 &lt;code&gt;&quot;a == b&quot;&lt;/code&gt; 입니다. 부정 된 술어 &lt;code&gt;&quot;a != b&quot;&lt;/code&gt; 를 사용하여 첫 번째 요소를 대신 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad19c283f2ff0ef86cf40f35fd842064c7bd010d" translate="yes" xml:space="preserve">
          <source>The predicate for comparing each element with the separator, defaulting to &lt;code&gt;&quot;a == b&quot;&lt;/code&gt;.</source>
          <target state="translated">각 요소를 구분 기호와 비교하기위한 술어. 기본값은 &lt;code&gt;&quot;a == b&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c5a87643179e233709de5c2f1a144d80a09a77b5" translate="yes" xml:space="preserve">
          <source>The predicate for deciding where to split the range when no separator is passed</source>
          <target state="translated">분리자가 전달되지 않을 때 범위를 분할 할 위치를 결정하기위한 술어</target>
        </trans-unit>
        <trans-unit id="e35b33251882d624f933a2c1b64ccb5eb65ade7b" translate="yes" xml:space="preserve">
          <source>The predicate for determining when to stop counting.</source>
          <target state="translated">계산을 중지 할시기를 결정하는 술어.</target>
        </trans-unit>
        <trans-unit id="0c33296dd22cd76b6c27b1beb8636640e4665dda" translate="yes" xml:space="preserve">
          <source>The predicate is expected to satisfy certain rules in order for &lt;code&gt;sort&lt;/code&gt; to behave as expected - otherwise, the program may fail on certain inputs (but not others) when not compiled in release mode, due to the cursory &lt;code&gt;assumeSorted&lt;/code&gt; check. Specifically, &lt;code&gt;sort&lt;/code&gt; expects &lt;code&gt;less(a,b) &amp;amp;&amp;amp; less(b,c)&lt;/code&gt; to imply &lt;code&gt;less(a,c)&lt;/code&gt; (transitivity), and, conversely, &lt;code&gt;!less(a,b) &amp;amp;&amp;amp; !less(b,c)&lt;/code&gt; to imply &lt;code&gt;!less(a,c)&lt;/code&gt;. Note that the default predicate (&lt;code&gt;&quot;a &amp;lt; b&quot;&lt;/code&gt;) does not always satisfy these conditions for floating point types, because the expression will always be &lt;code&gt;false&lt;/code&gt; when either &lt;code&gt;a&lt;/code&gt; or &lt;code&gt;b&lt;/code&gt; is NaN. Use &lt;a href=&quot;std_math#cmp&quot;&gt;&lt;code&gt;std.math.cmp&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">술어는 &lt;code&gt;sort&lt;/code&gt; 이 예상대로 작동 하기 위해 특정 규칙을 충족 해야합니다. 그렇지 않으면, 릴리스 가정에서 컴파일되지 않은 경우 커서 &lt;code&gt;assumeSorted&lt;/code&gt; 검사 로 인해 특정 입력에서 (다른 입력은 제외) 프로그램이 실패 할 수 있습니다 . 특히, &lt;code&gt;sort&lt;/code&gt; 는 &lt;code&gt;less(a,b) &amp;amp;&amp;amp; less(b,c)&lt;/code&gt; 는 &lt;code&gt;less(a,c)&lt;/code&gt; (transitivity) 를 의미 하고 반대로 &lt;code&gt;!less(a,b) &amp;amp;&amp;amp; !less(b,c)&lt;/code&gt; 는 의미합니다 &lt;code&gt;!less(a,c)&lt;/code&gt; . 기본 술어 ( &lt;code&gt;&quot;a &amp;lt; b&quot;&lt;/code&gt; )가 부동 소수점 유형에 대해 이러한 조건을 항상 만족시키는 것은 아닙니다. &lt;code&gt;a&lt;/code&gt; 또는 &lt;code&gt;b&lt;/code&gt; 일 때 표현식이 항상 &lt;code&gt;false&lt;/code&gt; 이므로NaN입니다. 대신 &lt;a href=&quot;std_math#cmp&quot;&gt; &lt;code&gt;std.math.cmp&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="27f1015c9d3c968b66e69f35344a3e7b0807ccce" translate="yes" xml:space="preserve">
          <source>The predicate is passed to &lt;a href=&quot;std_functional#binaryFun&quot;&gt;&lt;code&gt;std.functional.binaryFun&lt;/code&gt;&lt;/a&gt; and accepts any callable function that can be executed via &lt;code&gt;pred(element, s)&lt;/code&gt;.</source>
          <target state="translated">술어는 &lt;a href=&quot;std_functional#binaryFun&quot;&gt; &lt;code&gt;std.functional.binaryFun&lt;/code&gt; 에&lt;/a&gt; 전달 되며 &lt;code&gt;pred(element, s)&lt;/code&gt; 를 통해 실행할 수있는 호출 가능한 함수를 승인합니다 .</target>
        </trans-unit>
        <trans-unit id="2040ad77d27bfa42d579b0732a628553443b56b4" translate="yes" xml:space="preserve">
          <source>The predicate is passed to &lt;a href=&quot;std_functional#binaryFun&quot;&gt;&lt;code&gt;std.functional.binaryFun&lt;/code&gt;&lt;/a&gt;, and can either accept a string, or any callable that can be executed via &lt;code&gt;pred(element, element)&lt;/code&gt;.</source>
          <target state="translated">술어는 &lt;a href=&quot;std_functional#binaryFun&quot;&gt; &lt;code&gt;std.functional.binaryFun&lt;/code&gt; 에&lt;/a&gt; 전달되며 문자열 또는 &lt;code&gt;pred(element, element)&lt;/code&gt; 를 통해 실행할 수있는 호출 가능 항목을 승인 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c1cc6d6782bb5ddbb272e878b0a97cd35ebd9643" translate="yes" xml:space="preserve">
          <source>The predicate is passed to &lt;a href=&quot;std_functional#unaryFun&quot;&gt;&lt;code&gt;std.functional.unaryFun&lt;/code&gt;&lt;/a&gt;, and can either accept a string, or any callable that can be executed via &lt;code&gt;pred(element)&lt;/code&gt;.</source>
          <target state="translated">술어는 &lt;a href=&quot;std_functional#unaryFun&quot;&gt; &lt;code&gt;std.functional.unaryFun&lt;/code&gt; 에&lt;/a&gt; 전달되며 문자열 또는 &lt;code&gt;pred(element)&lt;/code&gt; 를 통해 실행할 수있는 호출 가능 항목을 승인 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="30b49793439ff4c8d008cc1bf8471d003e4d8abc" translate="yes" xml:space="preserve">
          <source>The predicate that determines whether elements from each respective range match. Defaults to equality &lt;code&gt;&quot;a == b&quot;&lt;/code&gt;.</source>
          <target state="translated">각 범위의 요소가 일치하는지 판별하는 술어. 기본값은 같음 &lt;code&gt;&quot;a == b&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="11c0e0e174294f0d039166c9a6e153edb402dcf7" translate="yes" xml:space="preserve">
          <source>The predicate that the range should be partitioned by.</source>
          <target state="translated">범위가 분할되어야한다는 조건 자.</target>
        </trans-unit>
        <trans-unit id="efb36bba668de1092c1769f6aab990aa0cb00922" translate="yes" xml:space="preserve">
          <source>The predicate the ranges are sorted by.</source>
          <target state="translated">범위가 정렬 된 술어.</target>
        </trans-unit>
        <trans-unit id="87bdd1f3ad180a36d78f0b0a9fe20115fabf7d4e" translate="yes" xml:space="preserve">
          <source>The predicate to evaluate.</source>
          <target state="translated">평가할 술어.</target>
        </trans-unit>
        <trans-unit id="793b27dece0d99ba7788014f7bf7dd0fb1085592" translate="yes" xml:space="preserve">
          <source>The predicate to partition by.</source>
          <target state="translated">파티션 기준 술어.</target>
        </trans-unit>
        <trans-unit id="d5491576ad03ca04a8526c028f920296327ac77a" translate="yes" xml:space="preserve">
          <source>The predicate to satisfy.</source>
          <target state="translated">만족할 술어.</target>
        </trans-unit>
        <trans-unit id="c929e818343f11140b434407d7b74c242dda71fa" translate="yes" xml:space="preserve">
          <source>The predicate to sort by.</source>
          <target state="translated">정렬 할 술어.</target>
        </trans-unit>
        <trans-unit id="1d648ec381e9cf43fb0241bd298676f64d9af32e" translate="yes" xml:space="preserve">
          <source>The predicate to sort the transformed elements by.</source>
          <target state="translated">변환 된 요소를 정렬하는 조건 자입니다.</target>
        </trans-unit>
        <trans-unit id="04024868be7f287d2663bbef1dbf103a8da3cc6b" translate="yes" xml:space="preserve">
          <source>The predicate to use for comparing elements between the range and the needle(s).</source>
          <target state="translated">범위와 바늘 (들) 사이의 요소를 비교하는 데 사용할 술어.</target>
        </trans-unit>
        <trans-unit id="28f32071ce8ed6579de4bc0673c1fb09d434c803" translate="yes" xml:space="preserve">
          <source>The predicate to use for comparing elements.</source>
          <target state="translated">요소 비교에 사용할 술어.</target>
        </trans-unit>
        <trans-unit id="8e5598b5509b9c6eafc0eab8a5a91702947d0e63" translate="yes" xml:space="preserve">
          <source>The predicate to use for determining a match.</source>
          <target state="translated">일치를 판별하는 데 사용할 술어.</target>
        </trans-unit>
        <trans-unit id="89fd4b4f61967cf71a560e54be19f8d76cbb1cde" translate="yes" xml:space="preserve">
          <source>The predicate to use for the rearrangement.</source>
          <target state="translated">재배치에 사용할 술어.</target>
        </trans-unit>
        <trans-unit id="aafedf7f211b6bcd89cdb1a78ec67451cd224b87" translate="yes" xml:space="preserve">
          <source>The predicate to use in comparing elements for commonality. Defaults to equality &lt;code&gt;&quot;a == b&quot;&lt;/code&gt;.</source>
          <target state="translated">공통성을 위해 요소를 비교하는 데 사용할 술어입니다. 기본값은 같음 &lt;code&gt;&quot;a == b&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0d6ef6e2289f7e8b2fa887a80d23adf75d1641e1" translate="yes" xml:space="preserve">
          <source>The predicate used for comparison, modeled as a &lt;a href=&quot;https://en.wikipedia.org/wiki/Weak_ordering#Strict_weak_orderings&quot;&gt; strict weak ordering&lt;/a&gt; (irreflexive, antisymmetric, transitive, and implying a transitive equivalence)</source>
          <target state="translated">비교에 사용 된 술어는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Weak_ordering#Strict_weak_orderings&quot;&gt;엄격한 약한 순서&lt;/a&gt; 로 모델링됩니다 (비 반사, 비대칭, 전이 및 전 이적 동등성을 암시)</target>
        </trans-unit>
        <trans-unit id="7f8c0f3692256237f756958104cf2f7dfb39d06e" translate="yes" xml:space="preserve">
          <source>The predicate used to compare the values.</source>
          <target state="translated">값을 비교하는 데 사용되는 술어.</target>
        </trans-unit>
        <trans-unit id="97370c26d71acf94352a17fb62d152e3830e5289" translate="yes" xml:space="preserve">
          <source>The predicates are evaluated from left to right, aborting evaluation in a short-cut manner if a false result is encountered, in which case the latter instantiations do not need to compile.</source>
          <target state="translated">술어는 왼쪽에서 오른쪽으로 평가되어 잘못된 결과가 발생하면 바로 가기 방식으로 평가를 중단하며,이 경우 후자의 인스턴스화는 컴파일 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="1d7464c6a5c260ac34ab99c016228d6b560c3e52" translate="yes" xml:space="preserve">
          <source>The predicates are evaluated from left to right, aborting evaluation in a short-cut manner if a true result is encountered, in which case the latter instantiations do not need to compile.</source>
          <target state="translated">술어는 왼쪽에서 오른쪽으로 평가되어 실제 결과가 발생하면 바로 가기 방식으로 평가를 중단하며,이 경우 후자의 인스턴스화는 컴파일 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="c330fdecec36e8afd7824dda6b681cda50cda735" translate="yes" xml:space="preserve">
          <source>The preferred way to do memory management in Objective-C is to use Automatic Reference Counting, &lt;a href=&quot;https://developer.apple.com/library/mac/releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html&quot;&gt;ARC&lt;/a&gt;. This is not supported in D, therefore manual memory management is required to be used instead. This is achieved by calling &lt;a href=&quot;https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Protocols/NSObject_Protocol/index.html#//apple_ref/occ/intfm/NSObject/release&quot;&gt;&lt;code&gt;release&lt;/code&gt;&lt;/a&gt; on an Objective-C instance, like in the old days of Objective-C.</source>
          <target state="translated">Objective-C에서 메모리 관리를 수행하는 선호되는 방법은 &lt;a href=&quot;https://developer.apple.com/library/mac/releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html&quot;&gt;ARC (&lt;/a&gt; Automatic Reference Counting)를 사용하는 것 입니다. D에서는 지원되지 않으므로 대신 수동 메모리 관리를 사용해야합니다. 이는 Objective-C 이전과 같이 Objective-C 인스턴스에서 &lt;a href=&quot;https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Protocols/NSObject_Protocol/index.html#//apple_ref/occ/intfm/NSObject/release&quot;&gt; &lt;code&gt;release&lt;/code&gt; &lt;/a&gt; 를 호출하여 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="9c5a92eca5579a36fc2d0481a3b2f7e8a916467c" translate="yes" xml:space="preserve">
          <source>The presentation of unit test results to the user.</source>
          <target state="translated">단위 테스트 결과를 사용자에게 제시합니다.</target>
        </trans-unit>
        <trans-unit id="8662f0b9530b0402d97b53b894f53167be45df40" translate="yes" xml:space="preserve">
          <source>The previous exception in the chain of exceptions, if any.</source>
          <target state="translated">예외 체인의 이전 예외 (있는 경우)</target>
        </trans-unit>
        <trans-unit id="279b676cef017bbf61d78e4700dc992f1809ccb0" translate="yes" xml:space="preserve">
          <source>The previous exception in the chain of exceptions.</source>
          <target state="translated">예외 체인의 이전 예외</target>
        </trans-unit>
        <trans-unit id="e3fc0517fe6d8889b123aa839a1f6e19c03962c2" translate="yes" xml:space="preserve">
          <source>The primary allocator.</source>
          <target state="translated">기본 할당 자.</target>
        </trans-unit>
        <trans-unit id="4f0154c15aa8860cab6cca5d166473b2dfba4c14" translate="yes" xml:space="preserve">
          <source>The primary range of a container</source>
          <target state="translated">컨테이너의 기본 범위</target>
        </trans-unit>
        <trans-unit id="ab5e84bf7b0a53be5c65c8499a656cc503de367a" translate="yes" xml:space="preserve">
          <source>The primary range type associated with the container.</source>
          <target state="translated">컨테이너와 관련된 기본 범위 유형입니다.</target>
        </trans-unit>
        <trans-unit id="33a169f7cc45c68212a77c63178f168570e503e4" translate="yes" xml:space="preserve">
          <source>The primary usefulness of</source>
          <target state="translated">의 주요 유용성</target>
        </trans-unit>
        <trans-unit id="6d1a3cd0b06a0c49d350401e273d786a65d53304" translate="yes" xml:space="preserve">
          <source>The primary way that programs should time how long something takes is to do</source>
          <target state="translated">프로그램이 시간이 오래 걸리는 주요 방법은 수행하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="c12de0da440bbe44b6cbc2ce06649502cfbb1a15" translate="yes" xml:space="preserve">
          <source>The process ID number.</source>
          <target state="translated">프로세스 ID 번호</target>
        </trans-unit>
        <trans-unit id="57ea5f74d898ca9f45c60b0cceb17881be0464f6" translate="yes" xml:space="preserve">
          <source>The process of compiling is divided into multiple phases. Each phase has no dependence on subsequent phases. For example, the scanner is not perturbed by the semantic analyzer. This separation of the passes makes language tools like syntax directed editors relatively easy to produce. It also is possible to compress D source by storing it in &amp;lsquo;tokenized&amp;rsquo; form.</source>
          <target state="translated">컴파일 과정은 여러 단계로 나뉩니다. 각 단계는 후속 단계에 의존하지 않습니다. 예를 들어, 시맨틱 분석기에 의해 스캐너가 교란되지 않습니다. 패스를 분리하면 구문 지정 편집기와 같은 언어 도구를 비교적 쉽게 만들 수 있습니다. 또한 D 토큰을 '토큰 화 된'형식으로 저장하여 압축 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea34e4c27e6af1bb0e75da5e0e23701dae05bbf4" translate="yes" xml:space="preserve">
          <source>The process of compiling is divided into multiple phases. Each phase is independent of subsequent phases. For example, the scanner is not affected by the semantic analyzer. This separation of passes makes language tools like syntax-directed editors relatively easy to create. It is also possible to compress D source by storing it in &amp;lsquo;tokenized&amp;rsquo; form.</source>
          <target state="translated">컴파일 과정은 여러 단계로 나뉩니다. 각 단계는 후속 단계와 독립적입니다. 예를 들어 스캐너는 의미 분석기의 영향을받지 않습니다. 이렇게 패스를 분리하면 구문 지향 편집기와 같은 언어 도구를 비교적 쉽게 만들 수 있습니다. D 소스를 '토큰 화 된'형태로 저장하여 압축하는 것도 가능합니다.</target>
        </trans-unit>
        <trans-unit id="28114859ca08917818ce7134f60ebbc9ff108b7d" translate="yes" xml:space="preserve">
          <source>The process of constructing a trie is more involved and is hidden from the user in a form of the convenience functions &lt;a href=&quot;#codepointTrie&quot;&gt;&lt;code&gt;codepointTrie&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#codepointSetTrie&quot;&gt;&lt;code&gt;codepointSetTrie&lt;/code&gt;&lt;/a&gt; and the even more convenient &lt;a href=&quot;#toTrie&quot;&gt;&lt;code&gt;toTrie&lt;/code&gt;&lt;/a&gt;. In general a set or built-in AA with &lt;code&gt;dchar&lt;/code&gt; type can be turned into a trie. The trie object in this module is read-only (immutable); it's effectively frozen after construction.</source>
          <target state="translated">트라이를 구성하는 프로세스는 더 편리하고 편리한 함수 &lt;a href=&quot;#codepointTrie&quot;&gt; &lt;code&gt;codepointTrie&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#codepointSetTrie&quot;&gt; &lt;code&gt;codepointSetTrie&lt;/code&gt; &lt;/a&gt; 및 훨씬 더 편리한 &lt;a href=&quot;#toTrie&quot;&gt; &lt;code&gt;toTrie&lt;/code&gt; &lt;/a&gt; 의 형태로 사용자에게 숨겨져 있습니다 . 일반적으로 &lt;code&gt;dchar&lt;/code&gt; 유형 의 세트 또는 내장 AA를 trie로 전환 할 수 있습니다. 이 모듈의 trie 객체는 읽기 전용입니다 (불변). 시공 후 효과적으로 냉동됩니다.</target>
        </trans-unit>
        <trans-unit id="d2a069ebee0eb3fc705692f747a2a23547f8a461" translate="yes" xml:space="preserve">
          <source>The process of deducing template type parameters from function arguments is called Implicit Function Template Instantiation (IFTI).</source>
          <target state="translated">함수 인수에서 템플릿 유형 매개 변수를 추론하는 과정을 IFTI (암시 적 함수 템플릿 인스턴스화)라고합니다.</target>
        </trans-unit>
        <trans-unit id="a65917e549f3ee7bf2fcc111ebfc87ae282e8929" translate="yes" xml:space="preserve">
          <source>The process will be &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/windows/desktop/ms686714%28v=vs.100%29.aspx&quot;&gt;forcefully and abruptly terminated&lt;/a&gt;. If &lt;code&gt;codeOrSignal&lt;/code&gt; is specified, it must be a nonnegative number which will be used as the exit code of the process. If not, the process wil exit with code 1. Do not use &lt;code&gt;codeOrSignal = 259&lt;/code&gt;, as this is a special value (aka. &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/windows/desktop/ms683189.aspx&quot;&gt;STILL_ACTIVE&lt;/a&gt;) used by Windows to signal that a process has in fact</source>
          <target state="translated">프로세스가 &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/windows/desktop/ms686714%28v=vs.100%29.aspx&quot;&gt;강제로 갑자기 종료됩니다&lt;/a&gt; . 경우 &lt;code&gt;codeOrSignal&lt;/code&gt; 가 지정되어, 그것은 프로세스의 종료 코드로 사용되는 음수가 아닌 숫자 여야합니다. 그렇지 않은 경우 프로세스는 코드 1로 종료됩니다. &lt;code&gt;codeOrSignal = 259&lt;/code&gt; 사용하지 마십시오. 이 값 은 프로세스가 실제로 프로세스를 가지고 있음을 나타 내기 위해 Windows에서 사용 하는 특수 값 (일명 &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/windows/desktop/ms683189.aspx&quot;&gt;STILL_ACTIVE&lt;/a&gt; )이므로</target>
        </trans-unit>
        <trans-unit id="a52379dcfb4fdf54c286085a8d7b935d4c3bf51f" translate="yes" xml:space="preserve">
          <source>The program can explicitly inform the garbage collector that an object is no longer referred to with &lt;a href=&quot;https://dlang.org/phobos/object.html#destroy&quot;&gt;&lt;code&gt;destroy&lt;/code&gt;&lt;/a&gt;, and then the garbage collector calls the destructor immediately. The destructor is guaranteed to never be called twice.</source>
          <target state="translated">프로그램은 객체가 더 이상 &lt;a href=&quot;https://dlang.org/phobos/object.html#destroy&quot;&gt; &lt;code&gt;destroy&lt;/code&gt; 로&lt;/a&gt; 참조되지 않는다는 것을 가비지 수집기에 명시 적으로 알려준 다음 가비지 수집기가 즉시 소멸자를 호출합니다. 소멸자는 결코 두 번 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="da8f18e43875ff3b21ffb3a65f1d74da9627baee" translate="yes" xml:space="preserve">
          <source>The program name,</source>
          <target state="translated">프로그램 이름</target>
        </trans-unit>
        <trans-unit id="75fd342f2dff09b71b21a32efe312806ee1c88b1" translate="yes" xml:space="preserve">
          <source>The projection of &lt;code&gt;z&lt;/code&gt; onto the Riemann sphere.</source>
          <target state="translated">리만 구 에 &lt;code&gt;z&lt;/code&gt; 의 투영 .</target>
        </trans-unit>
        <trans-unit id="212a3b865b9d39089a835e861cd51456362e9629" translate="yes" xml:space="preserve">
          <source>The proper way to instantiate this object is to call &lt;code&gt;WorkerLocalStorage.toRange&lt;/code&gt;. Once instantiated, this object behaves as a finite random-access range with assignable, lvalue elements and a length equal to the number of worker threads in the &lt;code&gt;TaskPool&lt;/code&gt; that created it plus 1.</source>
          <target state="translated">이 객체를 인스턴스화하는 올바른 방법은 &lt;code&gt;WorkerLocalStorage.toRange&lt;/code&gt; 를 호출하는 것 입니다. 일단 인스턴스화되면,이 객체는 할당 가능한 lvalue 요소와 &lt;code&gt;TaskPool&lt;/code&gt; 에서 생성 된 작업자 스레드 수에 1을 더한 1 을 갖는 유한 랜덤 액세스 범위로 동작 합니다.</target>
        </trans-unit>
        <trans-unit id="06cb3e37f16148a51f8965d4f1cdc4ea883f0365" translate="yes" xml:space="preserve">
          <source>The properties &lt;code&gt;.__vptr&lt;/code&gt; and &lt;code&gt;.__monitor&lt;/code&gt; give access to the class object's vtbl[] and monitor, respectively, but should not be used in user code.</source>
          <target state="translated">&lt;code&gt;.__vptr&lt;/code&gt; 및 &lt;code&gt;.__monitor&lt;/code&gt; 속성 은 클래스 객체의 vtbl [] 및 모니터에 각각 액세스 할 수 있지만 사용자 코드에는 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="465978af9e7d0929cd7aec7d44ae79ba13368247" translate="yes" xml:space="preserve">
          <source>The property &lt;code&gt;.outer&lt;/code&gt; used in a nested class gives the &lt;code&gt;this&lt;/code&gt; pointer to its enclosing class. If there is no enclosing class context, &lt;code&gt;.outer&lt;/code&gt; would return a pointer to enclosing function frame with &lt;code&gt;void*&lt;/code&gt;.</source>
          <target state="translated">중첩 클래스에서 사용되는 &lt;code&gt;.outer&lt;/code&gt; 속성 은 &lt;code&gt;this&lt;/code&gt; 포인터를 둘러싸 는 클래스에 제공합니다 . 엔 클로징 클래스 컨텍스트가없는 경우 &lt;code&gt;.outer&lt;/code&gt; 는 &lt;code&gt;void*&lt;/code&gt; 가있는 엔 클로징 함수 프레임에 대한 포인터를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="18230b4e21a7c31cb0b0a527787c1242f4f98838" translate="yes" xml:space="preserve">
          <source>The proxied value must be an &lt;b&gt;lvalue&lt;/b&gt;.</source>
          <target state="translated">프록시 값은 &lt;b&gt;lvalue&lt;/b&gt; 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="2aa3e8b16a5d628661af4b4300a9494770cb4fda" translate="yes" xml:space="preserve">
          <source>The ptr aliases are integral types guaranteed to be large enough to hold a pointer without losing bits:</source>
          <target state="translated">ptr 별명은 비트를 잃지 않고 포인터를 보유 할 수있을 정도로 충분히 커야하는 정수 유형입니다.</target>
        </trans-unit>
        <trans-unit id="5110028f04b358ea03cfe31d14fda076a20fecde" translate="yes" xml:space="preserve">
          <source>The purpose is to bypass the special case decoding that &lt;a href=&quot;std_range_primitives#front&quot;&gt;&lt;code&gt;std.range.primitives.front&lt;/code&gt;&lt;/a&gt; does to character arrays. As a result, using ranges with &lt;code&gt;byCodeUnit&lt;/code&gt; can be &lt;code&gt;nothrow&lt;/code&gt; while &lt;a href=&quot;std_range_primitives#front&quot;&gt;&lt;code&gt;std.range.primitives.front&lt;/code&gt;&lt;/a&gt; throws when it encounters invalid Unicode sequences.</source>
          <target state="translated">목적은 &lt;a href=&quot;std_range_primitives#front&quot;&gt; &lt;code&gt;std.range.primitives.front&lt;/code&gt; &lt;/a&gt; 가 문자 배열에 수행 하는 특수 사례 디코딩을 무시하는 것입니다 . 결과와 범위를 사용 &lt;code&gt;byCodeUnit&lt;/code&gt; 것이 될 수 &lt;code&gt;nothrow&lt;/code&gt; 동안 &lt;a href=&quot;std_range_primitives#front&quot;&gt; &lt;code&gt;std.range.primitives.front&lt;/code&gt; 가&lt;/a&gt; 그것이 무효 유니 코드 시퀀스가 발생할 때 발생.</target>
        </trans-unit>
        <trans-unit id="c265a2d12f1e7e5cd63d17026023fdb0d5f3f129" translate="yes" xml:space="preserve">
          <source>The purpose of this is so that continue will go to the next of the statements, and break will go to the end of the statements.</source>
          <target state="translated">이것의 목적은 계속해서 진술의 다음으로 갈 것이고, 중단은 진술의 끝으로 갈 것입니다.</target>
        </trans-unit>
        <trans-unit id="1651c6e27b3326d67f792a155dd955abdff9b39f" translate="yes" xml:space="preserve">
          <source>The qualifier template from the given type &lt;code&gt;T&lt;/code&gt;</source>
          <target state="translated">주어진 유형 &lt;code&gt;T&lt;/code&gt; 의 한정자 템플릿</target>
        </trans-unit>
        <trans-unit id="e09036cabacde1d4e95f44667e0017f4b4c08158" translate="yes" xml:space="preserve">
          <source>The qualifiers of the affix are not always the same as the qualifiers of the argument. This is because the affixes are not part of the data itself, but instead are just</source>
          <target state="translated">접미사의 한정자가 인수의 규정 자와 항상 같은 것은 아닙니다. 이것은 접두사가 데이터 자체의 일부가 아니라 단지</target>
        </trans-unit>
        <trans-unit id="0c6a006eb9560342bd14cc8557e22fb25a226fd2" translate="yes" xml:space="preserve">
          <source>The random-access range to partition.</source>
          <target state="translated">파티셔닝 할 랜덤 액세스 범위.</target>
        </trans-unit>
        <trans-unit id="97092cfd186fb5b900f835cf73b9eb2468215664" translate="yes" xml:space="preserve">
          <source>The random-access range to rearrange.</source>
          <target state="translated">재 배열 할 랜덤 액세스 범위.</target>
        </trans-unit>
        <trans-unit id="e4ce54dd9a7b88e5f2bf201fe3fb2e94f16d9fa9" translate="yes" xml:space="preserve">
          <source>The random-access range to reorder.</source>
          <target state="translated">재정렬 할 랜덤 액세스 범위입니다.</target>
        </trans-unit>
        <trans-unit id="9759b91222e0376d244c7fe53ea2166dd785b989" translate="yes" xml:space="preserve">
          <source>The range API is supported for both encoding and decoding:</source>
          <target state="translated">범위 API는 인코딩 및 디코딩에 모두 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="f827934761dc7cbd89045f8928d650c1c6adfe0d" translate="yes" xml:space="preserve">
          <source>The range being partitioned</source>
          <target state="translated">분할되는 범위</target>
        </trans-unit>
        <trans-unit id="ff34249e986a29860f6c5d437ad8145efcb4a0b9" translate="yes" xml:space="preserve">
          <source>The range primitives that the resulting range provides depends whether or not &lt;code&gt;r&lt;/code&gt; provides them. Except the functions &lt;code&gt;back&lt;/code&gt; and &lt;code&gt;popBack&lt;/code&gt;, which also require the range to have a length as well as &lt;code&gt;back&lt;/code&gt; and &lt;code&gt;popBack&lt;/code&gt;</source>
          <target state="translated">결과 범위가 제공하는 범위 기본 요소는 &lt;code&gt;r&lt;/code&gt; 이 제공 하는지 여부에 따라 다릅니다 . &lt;code&gt;back&lt;/code&gt; 및 &lt;code&gt;popBack&lt;/code&gt; 함수를 제외하고 범위는 &lt;code&gt;back&lt;/code&gt; 및 &lt;code&gt;popBack&lt;/code&gt; 뿐만 아니라 길이를 가져야합니다.</target>
        </trans-unit>
        <trans-unit id="3e867771f52adb05da2dc3c29c4eccce7ead17be" translate="yes" xml:space="preserve">
          <source>The range to append to.</source>
          <target state="translated">추가 할 범위입니다.</target>
        </trans-unit>
        <trans-unit id="b8f92036ba2322967a7c304f2680091886c10a9f" translate="yes" xml:space="preserve">
          <source>The range to check.</source>
          <target state="translated">확인할 범위입니다.</target>
        </trans-unit>
        <trans-unit id="92faab42363803d3ec822fdd1af0c67c9ba8588a" translate="yes" xml:space="preserve">
          <source>The range to count.</source>
          <target state="translated">계산할 범위입니다.</target>
        </trans-unit>
        <trans-unit id="2a5042de5707ed27e3cd38336bffdd36cd0572c7" translate="yes" xml:space="preserve">
          <source>The range to handle.</source>
          <target state="translated">처리 할 범위입니다.</target>
        </trans-unit>
        <trans-unit id="e058b4d6c31bc35cf580da1ebefcc71d18f5d1ca" translate="yes" xml:space="preserve">
          <source>The range to index.</source>
          <target state="translated">색인화 할 범위입니다.</target>
        </trans-unit>
        <trans-unit id="80d973acf722de6a5268aeaa4c8fc9646330d9bc" translate="yes" xml:space="preserve">
          <source>The range to permute.</source>
          <target state="translated">퍼 뮤트 할 범위입니다.</target>
        </trans-unit>
        <trans-unit id="804c985240d645660c7de05e2788995416dc345a" translate="yes" xml:space="preserve">
          <source>The range to read from.</source>
          <target state="translated">읽을 범위입니다.</target>
        </trans-unit>
        <trans-unit id="8b4ec9a859bd18ea04f9de73b722dd789467f7e7" translate="yes" xml:space="preserve">
          <source>The range to search.</source>
          <target state="translated">검색 할 범위입니다.</target>
        </trans-unit>
        <trans-unit id="121036e1b0b497292221a25f49b6dd27cc53e9e1" translate="yes" xml:space="preserve">
          <source>The range to sort.</source>
          <target state="translated">정렬 할 범위입니다.</target>
        </trans-unit>
        <trans-unit id="cc147be5451f6cfb0b41f5b2277bb929ce23d7db" translate="yes" xml:space="preserve">
          <source>The range to subtract from &lt;code&gt;r1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;r1&lt;/code&gt; 에서 빼는 범위 입니다.</target>
        </trans-unit>
        <trans-unit id="49d274ac9ff8b631f4dc3f4b09f1138c62b7ffc0" translate="yes" xml:space="preserve">
          <source>The range to write to.</source>
          <target state="translated">쓸 범위입니다.</target>
        </trans-unit>
        <trans-unit id="49360fcd22b248a482a8ca2592193dd9241be2ca" translate="yes" xml:space="preserve">
          <source>The range type</source>
          <target state="translated">범위 유형</target>
        </trans-unit>
        <trans-unit id="802ba550fbcee32bf81ae1613d2bfa286e1456a5" translate="yes" xml:space="preserve">
          <source>The range types for &lt;code&gt;RedBlackTree&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;RedBlackTree&lt;/code&gt; 의 범위 유형</target>
        </trans-unit>
        <trans-unit id="a11d808dfbdf148bbb169a6a95255aca3179a47b" translate="yes" xml:space="preserve">
          <source>The range's &lt;code&gt;front&lt;/code&gt; is the interval's &lt;code&gt;begin&lt;/code&gt;. func is used to generate the next &lt;code&gt;front&lt;/code&gt; when &lt;code&gt;popFront&lt;/code&gt; is called. If popFirst is &lt;code&gt;PopFirst.yes&lt;/code&gt;, then &lt;code&gt;popFront&lt;/code&gt; is called before the range is returned (so that &lt;code&gt;front&lt;/code&gt; is a time point which func would generate).</source>
          <target state="translated">범위의 &lt;code&gt;front&lt;/code&gt; 은 간격의 &lt;code&gt;begin&lt;/code&gt; 입니다. &lt;code&gt;popFront&lt;/code&gt; 는 popFront 가 호출 될 때 다음 &lt;code&gt;front&lt;/code&gt; 를 생성하는 데 사용됩니다 . popFirst가 &lt;code&gt;PopFirst.yes&lt;/code&gt; 이면 범위가 리턴되기 전에 &lt;code&gt;popFront&lt;/code&gt; 가 호출됩니다 (따라서 &lt;code&gt;front&lt;/code&gt; 는 func이 생성하는 시점입니다).</target>
        </trans-unit>
        <trans-unit id="2230a6c9d63e9a6e8252220108f18931ca810d49" translate="yes" xml:space="preserve">
          <source>The range's &lt;code&gt;front&lt;/code&gt; is the interval's &lt;code&gt;end&lt;/code&gt;. func is used to generate the next &lt;code&gt;front&lt;/code&gt; when &lt;code&gt;popFront&lt;/code&gt; is called. If popFirst is &lt;code&gt;PopFirst.yes&lt;/code&gt;, then &lt;code&gt;popFront&lt;/code&gt; is called before the range is returned (so that &lt;code&gt;front&lt;/code&gt; is a time point which func would generate).</source>
          <target state="translated">범위의 &lt;code&gt;front&lt;/code&gt; 은 간격의 &lt;code&gt;end&lt;/code&gt; 입니다. &lt;code&gt;popFront&lt;/code&gt; 는 popFront 가 호출 될 때 다음 &lt;code&gt;front&lt;/code&gt; 를 생성하는 데 사용됩니다 . popFirst가 &lt;code&gt;PopFirst.yes&lt;/code&gt; 이면 범위가 리턴되기 전에 &lt;code&gt;popFront&lt;/code&gt; 가 호출됩니다 (따라서 &lt;code&gt;front&lt;/code&gt; 는 func이 생성하는 시점입니다).</target>
        </trans-unit>
        <trans-unit id="bc87d893530544a1088c66c1a3ebadf8aa8d14c3" translate="yes" xml:space="preserve">
          <source>The ranges may be different, but they must have compatible element types (i.e. &lt;code&gt;CommonType&lt;/code&gt; must exist for the two element types). The result is a range that offers the weakest capabilities of the two (e.g. &lt;code&gt;ForwardRange&lt;/code&gt; if &lt;code&gt;R1&lt;/code&gt; is a random-access range and &lt;code&gt;R2&lt;/code&gt; is a forward range).</source>
          <target state="translated">범위는 다를 수 있지만 호환 가능한 요소 유형이 있어야합니다 (즉 , 두 요소 유형에 대해 &lt;code&gt;CommonType&lt;/code&gt; 이 있어야 함). 결과는 두 가지 중에서 가장 약한 기능을 제공하는 범위입니다 (예 : &lt;code&gt;R1&lt;/code&gt; 이 임의 액세스 범위이고 &lt;code&gt;R2&lt;/code&gt; 가 순방향 범위 인 경우 &lt;code&gt;ForwardRange&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="3f573b0cbf92f973f94497f03f6ff76a63fec72f" translate="yes" xml:space="preserve">
          <source>The ranges may be different, but they must have compatible element types. The result is a range that offers the weakest capabilities of all &lt;code&gt;Ranges&lt;/code&gt;.</source>
          <target state="translated">범위는 다를 수 있지만 호환 가능한 요소 유형이 있어야합니다. 그 결과 모든 &lt;code&gt;Ranges&lt;/code&gt; 중에서 가장 약한 기능을 제공하는 범위가 됩니다.</target>
        </trans-unit>
        <trans-unit id="b730db3bfe83c0cd05e43737d06094aae7960b40" translate="yes" xml:space="preserve">
          <source>The ranges to compute the intersection for.</source>
          <target state="translated">교집합을 계산할 범위입니다.</target>
        </trans-unit>
        <trans-unit id="46baca537890237a1942208ed4eade3a2e0fe13d" translate="yes" xml:space="preserve">
          <source>The ranges to compute the union for.</source>
          <target state="translated">공용체를 계산할 범위입니다.</target>
        </trans-unit>
        <trans-unit id="5497d81d16c2927140f25a4c1006f37fea2563ca" translate="yes" xml:space="preserve">
          <source>The raw data is statically initialized using the values provided in the class definition. The pointer to the vtbl[] (the array of pointers to virtual functions) is assigned. Constructors are passed fully formed objects for which virtual functions can be called. This operation is equivalent to doing a memory copy of a static version of the object onto the newly allocated one.</source>
          <target state="translated">원시 데이터는 클래스 정의에 제공된 값을 사용하여 정적으로 초기화됩니다. vtbl []에 대한 포인터 (가상 함수에 대한 포인터 배열)가 할당됩니다. 생성자는 가상 함수를 호출 할 수있는 완전히 형성된 객체로 전달됩니다. 이 작업은 새로 할당 된 객체에 정적 버전의 객체에 대한 메모리 사본을 수행하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fcae8af2965ab59e0bb8589c5d279780cbfa5e92" translate="yes" xml:space="preserve">
          <source>The raw data is statically initialized using the values provided in the struct definition. This operation is equivalent to doing a memory copy of a static version of the object onto the newly allocated one.</source>
          <target state="translated">원시 데이터는 구조체 정의에 제공된 값을 사용하여 정적으로 초기화됩니다. 이 작업은 새로 할당 된 객체에 정적 버전의 객체에 대한 메모리 사본을 수행하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b86128a6bd2767acc00fa6def304105cbf1e478d" translate="yes" xml:space="preserve">
          <source>The read end of the pipe.</source>
          <target state="translated">파이프의 읽기 끝.</target>
        </trans-unit>
        <trans-unit id="13a2374af67fe26dbb9c14a59fb5ce5f9e9d781a" translate="yes" xml:space="preserve">
          <source>The read/write mutex module provides a primitive for maintaining shared read access and mutually exclusive write access.</source>
          <target state="translated">읽기 / 쓰기 뮤텍스 모듈은 공유 읽기 액세스 및 상호 배타적 인 쓰기 액세스를 유지하기위한 기본 요소를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="1ea37ce134dc82d56b80e1186c5f0aadafbf2545" translate="yes" xml:space="preserve">
          <source>The real part of the number.</source>
          <target state="translated">숫자의 실제 부분.</target>
        </trans-unit>
        <trans-unit id="d84af79636d58f1538ce03a4ef706cc4269fc0ca" translate="yes" xml:space="preserve">
          <source>The reason why local symbols are not considered by UFCS, is to avoid unexpected name conflicts. See below problematic examples.</source>
          <target state="translated">UFCS에서 로컬 기호를 고려하지 않는 이유는 예기치 않은 이름 충돌을 피하기위한 것입니다. 아래의 문제가있는 예를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6e1a9e9d57c1e11e3c0d69a36fca45727647f054" translate="yes" xml:space="preserve">
          <source>The reason why parsing the UUID string failed (if known)</source>
          <target state="translated">UUID 문자열 구문 분석에 실패한 이유 (알고있는 경우)</target>
        </trans-unit>
        <trans-unit id="444ce1c54b9e6e4aeb187c02bb491ead21cc3157" translate="yes" xml:space="preserve">
          <source>The received message. If &lt;code&gt;T.length&lt;/code&gt; is greater than one, the message will be packed into a &lt;a href=&quot;std_typecons#Tuple&quot;&gt;&lt;code&gt;std.typecons.Tuple&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">받은 메시지 경우 &lt;code&gt;T.length&lt;/code&gt; 이 보다 큰 메시지는로 포장됩니다 &lt;a href=&quot;std_typecons#Tuple&quot;&gt; &lt;code&gt;std.typecons.Tuple&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ca01b3f617c720041b0621fa546228daeb7a4c84" translate="yes" xml:space="preserve">
          <source>The received message. If &lt;code&gt;T&lt;/code&gt; has more than one entry, the message will be packed into a &lt;a href=&quot;std_typecons#Tuple&quot;&gt;&lt;code&gt;std.typecons.Tuple&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">수신 된 메시지입니다. 경우 &lt;code&gt;T&lt;/code&gt; 는 두 개 이상의 항목이 해당 메시지는로 포장됩니다 &lt;a href=&quot;std_typecons#Tuple&quot;&gt; &lt;code&gt;std.typecons.Tuple&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="629439e6d0394e525c1da0e460386c227bde37f1" translate="yes" xml:space="preserve">
          <source>The recommended default type for set of &lt;a href=&quot;#Code%20point&quot;&gt;code points&lt;/a&gt;. For details, see the current implementation: &lt;a href=&quot;#InversionList&quot;&gt;&lt;code&gt;InversionList&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#Code%20point&quot;&gt;코드 포인트&lt;/a&gt; 세트에 권장되는 기본 유형입니다 . 자세한 내용은 현재 구현 : &lt;a href=&quot;#InversionList&quot;&gt; &lt;code&gt;InversionList&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a1dc42bd6a98f128cb04e650caf0c66b2c441a15" translate="yes" xml:space="preserve">
          <source>The recommended solution (see Unicode Implementation Guidelines) is using multi-stage tables that are an implementation of the &lt;a href=&quot;http://en.wikipedia.org/wiki/Trie&quot;&gt;Trie&lt;/a&gt; data structure with integer keys and a fixed number of stages. For the remainder of the section this will be called a fixed trie. The following describes a particular implementation that is aimed for the speed of access at the expense of ideal size savings.</source>
          <target state="translated">권장 솔루션 (유니 코드 구현 지침 참조)은 정수 키와 고정 된 수의 스테이지로 &lt;a href=&quot;http://en.wikipedia.org/wiki/Trie&quot;&gt;Trie&lt;/a&gt; 데이터 구조를 구현하는 다단계 테이블을 사용하는 것입니다 . 이 섹션의 나머지 부분에서는이를 고정 트라이라고합니다. 다음은 이상적인 크기 절약을 위해 액세스 속도를 목표로하는 특정 구현을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="64d2cded1f6173c486fb7ad21ff19a0763451581" translate="yes" xml:space="preserve">
          <source>The recommended type of &lt;a href=&quot;std_typecons#Tuple&quot;&gt;&lt;code&gt;std.typecons.Tuple&lt;/code&gt;&lt;/a&gt; to represent [a, b) intervals of &lt;a href=&quot;#Code%20point&quot;&gt;code points&lt;/a&gt;. As used in &lt;a href=&quot;#InversionList&quot;&gt;&lt;code&gt;InversionList&lt;/code&gt;&lt;/a&gt;. Any interval type should pass &lt;a href=&quot;#isIntegralPair&quot;&gt;&lt;code&gt;isIntegralPair&lt;/code&gt;&lt;/a&gt; trait.</source>
          <target state="translated">권장되는 &lt;a href=&quot;std_typecons#Tuple&quot;&gt; &lt;code&gt;std.typecons.Tuple&lt;/code&gt; &lt;/a&gt; 유형은 [a, b) &lt;a href=&quot;#Code%20point&quot;&gt;코드 포인트&lt;/a&gt; 간격을 나타냅니다 . &lt;a href=&quot;#InversionList&quot;&gt; &lt;code&gt;InversionList&lt;/code&gt; &lt;/a&gt; 에서 사용됩니다 . 모든 간격 유형은 &lt;a href=&quot;#isIntegralPair&quot;&gt; &lt;code&gt;isIntegralPair&lt;/code&gt; &lt;/a&gt; 특성을 전달해야합니다 .</target>
        </trans-unit>
        <trans-unit id="859ae610f623e658d3afadb3f75618929c558560" translate="yes" xml:space="preserve">
          <source>The recommended use of &lt;code&gt;KRRegion&lt;/code&gt; is as a</source>
          <target state="translated">의 권장 사용 &lt;code&gt;KRRegion&lt;/code&gt; 는 A와이다</target>
        </trans-unit>
        <trans-unit id="388d2ad6c415253a61a360bde9d489b23f6dc8d0" translate="yes" xml:space="preserve">
          <source>The ref-ness of a function is determined from all &lt;a href=&quot;statement#ReturnStatement&quot;&gt;&lt;i&gt;ReturnStatement&lt;/i&gt;&lt;/a&gt;s in the function body:</source>
          <target state="translated">함수의 참조 는 함수 본문의 모든 &lt;a href=&quot;statement#ReturnStatement&quot;&gt;&lt;i&gt;ReturnStatement&lt;/i&gt;&lt;/a&gt; 에서 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="3b502b2fed948d53834e6a08aa36762dc04287b2" translate="yes" xml:space="preserve">
          <source>The reference label must match a reference defined elsewhere. This may be a D symbol in scope of the source code being documented, like &lt;code&gt;[Object]&lt;/code&gt; in the example above, or it may be an explicit reference that is defined in the same documentation comment, like &lt;code&gt;[ref]&lt;/code&gt; in the example above. In the example both instances of &lt;code&gt;[ref]&lt;/code&gt; in item &lt;code&gt;1.&lt;/code&gt; will be replaced with the URL and title text from the matching definition at the bottom of the example. The first link will read &lt;code&gt;reference link&lt;/code&gt; and the second will read &lt;code&gt;ref&lt;/code&gt;.</source>
          <target state="translated">참조 레이블은 다른 곳에 정의 된 참조와 일치해야합니다. 위의 예에서 &lt;code&gt;[Object]&lt;/code&gt; 와 같이 문서화되고있는 소스 코드의 범위에있는 D 기호 이거나 위의 예에서 &lt;code&gt;[ref]&lt;/code&gt; 와 같은 동일한 문서 주석에 정의 된 명시 적 참조 일 수 있습니다 . 예제 에서 항목 &lt;code&gt;1.&lt;/code&gt; 의 &lt;code&gt;[ref]&lt;/code&gt; 의 두 인스턴스 는 예제 하단의 일치하는 정의에서 URL 및 제목 텍스트로 바뀝니다. 첫 번째 링크는 &lt;code&gt;reference link&lt;/code&gt; 링크를 읽고 두 번째 링크는 &lt;code&gt;ref&lt;/code&gt; 를 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="c7f3a52223d62265f3e1ec0b1d084d2cc36a6550" translate="yes" xml:space="preserve">
          <source>The region only stores three pointers, corresponding to the current position in the store and the limits. One allocation entails rounding up the allocation size for alignment purposes, bumping the current pointer, and comparing it against the limit.</source>
          <target state="translated">영역은 상점의 현재 위치와 한계에 해당하는 세 개의 포인터 만 저장합니다. 하나의 할당은 정렬 목적으로 할당 크기를 반올림하고, 현재 포인터를 충돌시키고, 한계와 비교하는 것을 수반합니다.</target>
        </trans-unit>
        <trans-unit id="8dfea884780d568afe3690e3e3875bf9d38d17dd" translate="yes" xml:space="preserve">
          <source>The registry does not perform synchronization, as registration is assumed to be executed serially, as is the case for C constructors.</source>
          <target state="translated">C 생성자의 경우와 마찬가지로 등록이 직렬로 실행되는 것으로 가정되므로 레지스트리는 동기화를 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="323d86762a22443df4223066c5d79a8182348cc7" translate="yes" xml:space="preserve">
          <source>The rehashed associative array.</source>
          <target state="translated">다시 해시 된 연관 배열.</target>
        </trans-unit>
        <trans-unit id="2287a637460b49ec8f0775da73953a50ae5c2dbd" translate="yes" xml:space="preserve">
          <source>The relative path.</source>
          <target state="translated">상대 경로.</target>
        </trans-unit>
        <trans-unit id="6288b454d7838d0a858531ccb0a8c1a5187d7261" translate="yes" xml:space="preserve">
          <source>The removed &lt;code&gt;Logger&lt;/code&gt;.</source>
          <target state="translated">제거 된 &lt;code&gt;Logger&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2c0fe435252d4242a9ba6f628f9c2050e5381799" translate="yes" xml:space="preserve">
          <source>The replacement text is recursively scanned for more macros. If a macro is recursively encountered, with no argument or with the same argument text as the enclosing macro, it is replaced with no text. Macro invocations that cut across replacement text boundaries are not expanded. If the macro name is undefined, the replacement text has no characters in it. If a &amp;amp;dollar;(NAME) is desired to exist in the output without being macro expanded, the &amp;amp;dollar; should be &lt;a href=&quot;#punctuation_escapes&quot;&gt; backslash-escaped&lt;/a&gt;: &lt;code&gt;\$&lt;/code&gt;.</source>
          <target state="translated">더 많은 매크로가 있는지 대체 텍스트를 재귀 적으로 스캔합니다. 인수없이 또는 둘러싼 매크로와 동일한 인수 텍스트를 사용하여 매크로가 반복적으로 발생하면 텍스트가없는 것으로 대체됩니다. 대체 텍스트 경계를 가로 지르는 매크로 호출은 확장되지 않습니다. 매크로 이름이 정의되지 않은 경우 대체 텍스트에 문자가 없습니다. 매크로 확장없이 &amp;amp; dollar; (NAME)을 (를) 출력에 존재 시키려면 &amp;amp; dollar; &lt;a href=&quot;#punctuation_escapes&quot;&gt;백 슬래시 이스케이프&lt;/a&gt; 되어야합니다 : &lt;code&gt;\$&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="00c0559f793b29523699536174f193f79d1404f9" translate="yes" xml:space="preserve">
          <source>The representation of the passed string.</source>
          <target state="translated">전달 된 문자열의 표현</target>
        </trans-unit>
        <trans-unit id="541a2ee308f80899ed39d343b6df8bc566dc23af" translate="yes" xml:space="preserve">
          <source>The requested type. The currently stored value must implicitly convert to the requested type, in fact &lt;code&gt;DecayStaticToDynamicArray!T&lt;/code&gt;. If an implicit conversion is not possible, throws a &lt;code&gt;VariantException&lt;/code&gt;.</source>
          <target state="translated">요청 된 유형입니다. 현재 저장된 값은 요청 된 유형 (사실 &lt;code&gt;DecayStaticToDynamicArray!T&lt;/code&gt; 암시 적으로 변환되어야합니다 . 암시 적 변환이 불가능하면 &lt;code&gt;VariantException&lt;/code&gt; 을 발생시킵니다 .</target>
        </trans-unit>
        <trans-unit id="5eb7b072c5ec5c51e2bc9f0c47309355a93d189e" translate="yes" xml:space="preserve">
          <source>The required value.</source>
          <target state="translated">필요한 값입니다.</target>
        </trans-unit>
        <trans-unit id="2b92c124327023d2112fc02de9225ba21a0e356f" translate="yes" xml:space="preserve">
          <source>The rest of the EH data can be placed anywhere, it is immutable.</source>
          <target state="translated">나머지 EH 데이터는 어디에나 배치 할 수 있으며 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="bc76ec74ecd985115be5a95df44e330a29c95a31" translate="yes" xml:space="preserve">
          <source>The result cannot be represented exactly, so rounding occurred.</source>
          <target state="translated">결과를 정확하게 표현할 수 없으므로 반올림이 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="ab324d21f7bc55d7dd8b6c95008f59bdf991ab91" translate="yes" xml:space="preserve">
          <source>The result is &lt;code&gt;&quot;true&quot;&lt;/code&gt; or &lt;code&gt;&quot;false&quot;&lt;/code&gt;.</source>
          <target state="translated">결과는 &lt;code&gt;&quot;true&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;false&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b4130bb4d8bac0fbef0c07bb06c97970f537d8b6" translate="yes" xml:space="preserve">
          <source>The result is [s&lt;sub&gt;0&lt;/sub&gt;, s&lt;sub&gt;1&lt;/sub&gt;, ...] where s&lt;sub&gt;n&lt;/sub&gt; is the nth element formatted with the default format.</source>
          <target state="translated">결과는 [s &lt;sub&gt;0&lt;/sub&gt; , s &lt;sub&gt;1&lt;/sub&gt; , ...]입니다. 여기서 s &lt;sub&gt;n&lt;/sub&gt; 은 기본 형식으로 형식이 지정된 n 번째 요소입니다.</target>
        </trans-unit>
        <trans-unit id="2b142e927d8266a5d73b4c96f242e530946b4181" translate="yes" xml:space="preserve">
          <source>The result is reasonable even if the programmer fails to check for errors.</source>
          <target state="translated">프로그래머가 오류를 확인하지 않아도 결과는 합리적입니다.</target>
        </trans-unit>
        <trans-unit id="e6fee708ae88c1f8ca73e67b83e15b2edc455c01" translate="yes" xml:space="preserve">
          <source>The result is reasonable result even if the programmer fails to check for errors.</source>
          <target state="translated">프로그래머가 오류를 확인하지 않아도 결과는 합리적입니다.</target>
        </trans-unit>
        <trans-unit id="5df04c97a049ab6feec7de9282693846423b4f8b" translate="yes" xml:space="preserve">
          <source>The result is the equivalent of what the initializer would look like for the contents of the associative array, e.g.: [&quot;red&quot; : 10, &quot;blue&quot; : 20].</source>
          <target state="translated">결과는 이니셜 라이저가 연관 배열의 내용에 대해 보이는 것과 동일합니다 (예 : [ &quot;red&quot;: 10, &quot;blue&quot;: 20]).</target>
        </trans-unit>
        <trans-unit id="08ac164a7aed36036f9bcf755150a74df3d7b24f" translate="yes" xml:space="preserve">
          <source>The result is the string converted to UTF-8. A</source>
          <target state="translated">결과는 UTF-8로 변환 된 문자열입니다. ㅏ</target>
        </trans-unit>
        <trans-unit id="1509a90746b95e562f0978b9e4493748f60d91cb" translate="yes" xml:space="preserve">
          <source>The result is the string returned from the class instance's &lt;b&gt;.toString()&lt;/b&gt; method. A</source>
          <target state="translated">결과는 클래스 인스턴스의 &lt;b&gt;.toString ()&lt;/b&gt; 메서드 에서 반환 된 문자열 입니다. ㅏ</target>
        </trans-unit>
        <trans-unit id="778aba0a364d09c18b371bc8036e82626d093a0a" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;takeExactly&lt;/code&gt; is identical to that of &lt;a href=&quot;#take&quot;&gt;&lt;code&gt;take&lt;/code&gt;&lt;/a&gt; in cases where the original range defines &lt;code&gt;length&lt;/code&gt; or is infinite.</source>
          <target state="translated">&lt;code&gt;takeExactly&lt;/code&gt; 의 결과는 원래 범위가 &lt;code&gt;length&lt;/code&gt; 정의 하거나 무한정 인 경우 &lt;a href=&quot;#take&quot;&gt; &lt;code&gt;take&lt;/code&gt; &lt;/a&gt; 의 결과와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="07564cb52ad1e727fc81a3311ff06a2d773285ae" translate="yes" xml:space="preserve">
          <source>The result of a call to getAttr after the specified bits have been cleared.</source>
          <target state="translated">지정된 비트가 지워진 후 getAttr에 대한 호출 결과.</target>
        </trans-unit>
        <trans-unit id="f30cfdc760b36139b0f53b5d0be507ea3d824ed7" translate="yes" xml:space="preserve">
          <source>The result of a call to getAttr after the specified bits have been set.</source>
          <target state="translated">지정된 비트가 설정된 후 getAttr에 대한 호출 결과.</target>
        </trans-unit>
        <trans-unit id="445b97c22b054bdd6ff54c4dae46c9df7f4357c6" translate="yes" xml:space="preserve">
          <source>The result of the &lt;code&gt;getopt&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;getopt&lt;/code&gt; 함수 의 결과입니다 .</target>
        </trans-unit>
        <trans-unit id="c4e35be57e8c5a96f93fd5bad1cb28bc557187a1" translate="yes" xml:space="preserve">
          <source>The result of the cast operation.</source>
          <target state="translated">캐스트 조작의 결과.</target>
        </trans-unit>
        <trans-unit id="83715d44bc2b7900f8b6419b6c4fbc003acad08e" translate="yes" xml:space="preserve">
          <source>The result of the comparison (negative if &lt;code&gt;lhs &amp;lt; rhs&lt;/code&gt;, positive if &lt;code&gt; lhs &amp;gt; rhs&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt; if the values are equal)</source>
          <target state="translated">비교 결과 (음수 일 경우 &lt;code&gt;lhs &amp;lt; rhs&lt;/code&gt; , 양수일 경우 &lt;code&gt; lhs &amp;gt; rhs&lt;/code&gt; , &lt;code&gt;0&lt;/code&gt; 의 값이 동일한 경우)</target>
        </trans-unit>
        <trans-unit id="b2ab3e5031cd5a46b28a9645ebcd2ff7f110159a" translate="yes" xml:space="preserve">
          <source>The result of the comparison, &lt;code&gt;true&lt;/code&gt; if the values are equal</source>
          <target state="translated">비교 결과 , 값이 같으면 &lt;code&gt;true&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0c6e42e7ac37e1c83ed4b193d1c4849e41daad91" translate="yes" xml:space="preserve">
          <source>The result of the comparison.</source>
          <target state="translated">비교 결과.</target>
        </trans-unit>
        <trans-unit id="6c6d52fd3aff83619b0b5496c6e3c7be89c2a3aa" translate="yes" xml:space="preserve">
          <source>The result of the expression if no exception is thrown.</source>
          <target state="translated">예외가 발생하지 않으면 표현식의 결과입니다.</target>
        </trans-unit>
        <trans-unit id="0c56ce95759c8e42c05e176cc9b231a6a3180930" translate="yes" xml:space="preserve">
          <source>The result of the operation, which is the same as the built-in operator</source>
          <target state="translated">내장 연산자와 동일한 작업 결과</target>
        </trans-unit>
        <trans-unit id="5b1c264300cd8b658cc8b4e315b7758a06a23af7" translate="yes" xml:space="preserve">
          <source>The result of the operation.</source>
          <target state="translated">작업 결과.</target>
        </trans-unit>
        <trans-unit id="9d8e130938ba904bc8f047659f58c659ed670a0b" translate="yes" xml:space="preserve">
          <source>The result of this expression will be discarded. Print error messages if the operation has no side effects (and hence is meaningless).</source>
          <target state="translated">이 표현식의 결과는 삭제됩니다. 작업에 부작용이없는 경우 (따라서 의미가없는 경우) 오류 메시지를 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="2a7cfc7639682da470adfb6b183264f1a3b8552c" translate="yes" xml:space="preserve">
          <source>The result type of an</source>
          <target state="translated">의 결과 유형</target>
        </trans-unit>
        <trans-unit id="4056040f4fa407b267fad8cbca77b5fc61b11543" translate="yes" xml:space="preserve">
          <source>The resulting addresses will be used in a call to &lt;code&gt;Socket.bind&lt;/code&gt;.</source>
          <target state="translated">결과 주소는 &lt;code&gt;Socket.bind&lt;/code&gt; 호출에 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="3b20f209f4a7f010b51d8af08450b0f594e3ca06" translate="yes" xml:space="preserve">
          <source>The resulting center-justified string. The returned string is GC-allocated. To avoid GC allocation, use &lt;a href=&quot;#centerJustifier&quot;&gt;&lt;code&gt;centerJustifier&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">결과 중심 맞춤 문자열입니다. 반환 된 문자열은 GC 할당입니다. GC 할당을 피하려면 대신 &lt;a href=&quot;#centerJustifier&quot;&gt; &lt;code&gt;centerJustifier&lt;/code&gt; 를&lt;/a&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="6de191dd7ab6e3535ad839e47c65dfd4fc76b1d8" translate="yes" xml:space="preserve">
          <source>The resulting index.</source>
          <target state="translated">결과 색인.</target>
        </trans-unit>
        <trans-unit id="3934e1c05473de8755d2bda617c6973f102e169c" translate="yes" xml:space="preserve">
          <source>The return code of the operation. The value stored in val should be used only if the return value is &lt;code&gt;etc.c.curl.CurlInfo.ok&lt;/code&gt;.</source>
          <target state="translated">오퍼레이션의 리턴 코드 val에 저장된 값은 반환 값이 &lt;code&gt;etc.c.curl.CurlInfo.ok&lt;/code&gt; 인 경우에만 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="1da37adfbfe4961b78a217ba2c3b5022d249608b" translate="yes" xml:space="preserve">
          <source>The return expression associated with the first test expression that made the predicate yield true, or the default return expression if no test expression matched.</source>
          <target state="translated">술어 산출량을 true로 만든 첫 번째 테스트 표현식과 연관된 리턴 표현식 또는 일치하는 테스트 표현식이없는 경우 기본 리턴 표현식.</target>
        </trans-unit>
        <trans-unit id="96d68b6363dece3bf1b664aecfe8cf00504e56f0" translate="yes" xml:space="preserve">
          <source>The return type (int or long). It defaults to time_t, which is normally 32 bits on a 32-bit system and 64 bits on a 64-bit system.</source>
          <target state="translated">반환 유형 (int 또는 long) 기본적으로 time_t는 32 비트 시스템에서 32 비트, 64 비트 시스템에서 64 비트입니다.</target>
        </trans-unit>
        <trans-unit id="205ac1a8649e05600dd566c06cc715bf690a04c6" translate="yes" xml:space="preserve">
          <source>The return type must not have unshared aliasing unless &lt;code&gt;fun&lt;/code&gt; is &lt;code&gt;pure&lt;/code&gt; or the &lt;code&gt;Task&lt;/code&gt; is executed via &lt;code&gt;executeInNewThread&lt;/code&gt; instead of using a &lt;code&gt;TaskPool&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;fun&lt;/code&gt; 이 &lt;code&gt;pure&lt;/code&gt; 하거나 &lt;code&gt;TaskPool&lt;/code&gt; 대신 &lt;code&gt;executeInNewThread&lt;/code&gt; 를 통해 &lt;code&gt;Task&lt;/code&gt; 을 실행 하지 않는 한 반환 유형에는 공유 별칭이 없어야합니다 .</target>
        </trans-unit>
        <trans-unit id="0e9168599ed0b4047c1160546ea0dbeb54368257" translate="yes" xml:space="preserve">
          <source>The return type of the error handler.</source>
          <target state="translated">오류 처리기의 반환 유형입니다.</target>
        </trans-unit>
        <trans-unit id="97a463467304a89d6cd8cb9cc6d419fcfa020151" translate="yes" xml:space="preserve">
          <source>The return type of the function called by this &lt;code&gt;Task&lt;/code&gt;. This can be &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;Task&lt;/code&gt; 가 호출 한 함수의 반환 유형입니다 . 이것은 &lt;code&gt;void&lt;/code&gt; 가 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f5cb9f689236bc6a0892c16310f01988eb2264f8" translate="yes" xml:space="preserve">
          <source>The return type of tryVisit is deduced from the visiting functions and must be the same across all overloads.</source>
          <target state="translated">tryVisit의 리턴 유형은 방문 기능에서 추론되며 모든 과부하에서 동일해야합니다.</target>
        </trans-unit>
        <trans-unit id="1337a5d1a9830872413420563b85bf03297ab386" translate="yes" xml:space="preserve">
          <source>The return type of visit is deduced from the visiting functions and must be the same across all overloads.</source>
          <target state="translated">방문 유형은 방문 기능에서 추론되며 모든 과부하에서 동일해야합니다.</target>
        </trans-unit>
        <trans-unit id="1ae63b720e25e931777a9598eac602b1cc909af8" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;T&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 의 반환 값</target>
        </trans-unit>
        <trans-unit id="463c16879da8ce6d09697a58e7475146e16150d1" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;__traits(getParameterStorageClasses)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;__traits(getParameterStorageClasses)&lt;/code&gt; 의 반환 값</target>
        </trans-unit>
        <trans-unit id="c060f61f5611e03952bbbab3e92b4fea17da134a" translate="yes" xml:space="preserve">
          <source>The return value of the function is cached, so the procedures described below will only be performed the first time the function is called. All subsequent runs will return the same string, regardless of whether environment variables and directory structures have changed in the meantime.</source>
          <target state="translated">함수의 반환 값이 캐시되므로 아래 설명 된 절차는 함수가 처음 호출 될 때만 수행됩니다. 이후의 모든 실행은 환경 변수와 디렉토리 구조가 그 동안 변경되었는지 여부에 관계없이 동일한 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1adffc51f8315eaf8be8bf12efa55eccecc130de" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;#File&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt; wraps &lt;a href=&quot;core_stdc_stdio#stderr&quot;&gt;&lt;code&gt;core.stdc.stdio.stderr&lt;/code&gt;&lt;/a&gt;, and is therefore thread global. Reassigning &lt;code&gt;stderr&lt;/code&gt; to a different &lt;code&gt;File&lt;/code&gt; must be done in a single-threaded or locked context in order to avoid race conditions.</source>
          <target state="translated">반환 된 &lt;a href=&quot;#File&quot;&gt; &lt;code&gt;File&lt;/code&gt; &lt;/a&gt; 은 &lt;a href=&quot;core_stdc_stdio#stderr&quot;&gt; &lt;code&gt;core.stdc.stdio.stderr&lt;/code&gt; 를&lt;/a&gt; 래핑 하므로 스레드 전역입니다. 경쟁 조건을 피하기 위해 &lt;code&gt;stderr&lt;/code&gt; 을 다른 &lt;code&gt;File&lt;/code&gt; 재 할당 하는 것은 단일 스레드 또는 잠금 컨텍스트에서 수행되어야합니다.</target>
        </trans-unit>
        <trans-unit id="25646bf2b751680fc9f348ccd8f6fea18202d8c1" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;#File&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt; wraps &lt;a href=&quot;core_stdc_stdio#stdin&quot;&gt;&lt;code&gt;core.stdc.stdio.stdin&lt;/code&gt;&lt;/a&gt;, and is therefore thread global. Reassigning &lt;code&gt;stdin&lt;/code&gt; to a different &lt;code&gt;File&lt;/code&gt; must be done in a single-threaded or locked context in order to avoid race conditions.</source>
          <target state="translated">반환 된 &lt;a href=&quot;#File&quot;&gt; &lt;code&gt;File&lt;/code&gt; &lt;/a&gt; 은 &lt;a href=&quot;core_stdc_stdio#stdin&quot;&gt; &lt;code&gt;core.stdc.stdio.stdin&lt;/code&gt; 을&lt;/a&gt; 래핑 하므로 스레드 전역입니다. 경합 상태를 피하기 위해 &lt;code&gt;stdin&lt;/code&gt; 을 다른 &lt;code&gt;File&lt;/code&gt; 할당 하는 작업은 단일 스레드 또는 잠금 컨텍스트에서 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="70b78c3af2ae7539b55d9cf5b58f2854c458dd90" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;#File&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt; wraps &lt;a href=&quot;core_stdc_stdio#stdout&quot;&gt;&lt;code&gt;core.stdc.stdio.stdout&lt;/code&gt;&lt;/a&gt;, and is therefore thread global. Reassigning &lt;code&gt;stdout&lt;/code&gt; to a different &lt;code&gt;File&lt;/code&gt; must be done in a single-threaded or locked context in order to avoid race conditions.</source>
          <target state="translated">반환 된 &lt;a href=&quot;#File&quot;&gt; &lt;code&gt;File&lt;/code&gt; &lt;/a&gt; 은 &lt;a href=&quot;core_stdc_stdio#stdout&quot;&gt; &lt;code&gt;core.stdc.stdio.stdout&lt;/code&gt; 을&lt;/a&gt; 래핑 하므로 스레드 전역입니다. 경쟁 조건을 피하기 위해 &lt;code&gt;stdout&lt;/code&gt; 을 다른 &lt;code&gt;File&lt;/code&gt; 할당 하는 작업은 단일 스레드 또는 잠금 컨텍스트에서 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="818fa28d06533d229f1e780afce11dd92bba71cd" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;#File&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt; wraps &lt;a href=&quot;core_stdio#stderr&quot;&gt;&lt;code&gt;core.stdio.stderr&lt;/code&gt;&lt;/a&gt;, and is therefore thread global. Reassigning &lt;code&gt;stderr&lt;/code&gt; to a different &lt;code&gt;File&lt;/code&gt; must be done in a single-threaded or locked context in order to avoid race conditions.</source>
          <target state="translated">리턴 된 &lt;a href=&quot;#File&quot;&gt; &lt;code&gt;File&lt;/code&gt; &lt;/a&gt; 은 &lt;a href=&quot;core_stdio#stderr&quot;&gt; &lt;code&gt;core.stdio.stderr&lt;/code&gt; 를&lt;/a&gt; 랩핑 하므로 스레드 글로벌입니다. 경쟁 조건을 피하기 위해 &lt;code&gt;stderr&lt;/code&gt; 을 다른 &lt;code&gt;File&lt;/code&gt; 재 할당 하려면 단일 스레드 또는 잠금 컨텍스트에서 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="c5c6e553a95738c70b1b18bed8de44ea5bcf8eb1" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;#File&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt; wraps &lt;a href=&quot;core_stdio#stdin&quot;&gt;&lt;code&gt;core.stdio.stdin&lt;/code&gt;&lt;/a&gt;, and is therefore thread global. Reassigning &lt;code&gt;stdin&lt;/code&gt; to a different &lt;code&gt;File&lt;/code&gt; must be done in a single-threaded or locked context in order to avoid race conditions.</source>
          <target state="translated">리턴 된 &lt;a href=&quot;#File&quot;&gt; &lt;code&gt;File&lt;/code&gt; &lt;/a&gt; 은 &lt;a href=&quot;core_stdio#stdin&quot;&gt; &lt;code&gt;core.stdio.stdin&lt;/code&gt; 을&lt;/a&gt; 랩핑 하므로 스레드 글로벌입니다. 경쟁 조건을 피하기 위해 &lt;code&gt;stdin&lt;/code&gt; 을 다른 &lt;code&gt;File&lt;/code&gt; 재 할당 하려면 단일 스레드 또는 잠긴 컨텍스트에서 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="58bd0e7417109f330774ab518ccd7daa1f03d122" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;#File&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt; wraps &lt;a href=&quot;core_stdio#stdout&quot;&gt;&lt;code&gt;core.stdio.stdout&lt;/code&gt;&lt;/a&gt;, and is therefore thread global. Reassigning &lt;code&gt;stdout&lt;/code&gt; to a different &lt;code&gt;File&lt;/code&gt; must be done in a single-threaded or locked context in order to avoid race conditions.</source>
          <target state="translated">리턴 된 &lt;a href=&quot;#File&quot;&gt; &lt;code&gt;File&lt;/code&gt; &lt;/a&gt; 은 &lt;a href=&quot;core_stdio#stdout&quot;&gt; &lt;code&gt;core.stdio.stdout&lt;/code&gt; 을&lt;/a&gt; 랩핑 하므로 스레드 글로벌입니다. 경쟁 조건을 피하기 위해 &lt;code&gt;stdout&lt;/code&gt; 을 다른 &lt;code&gt;File&lt;/code&gt; 재 할당 하려면 단일 스레드 또는 잠금 컨텍스트에서 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="ac381e0220e927fc50320b0674e141c6fbd265c5" translate="yes" xml:space="preserve">
          <source>The returned object additionally supports &lt;a href=&quot;#unwrap&quot;&gt;&lt;code&gt;unwrap&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">반환 된 객체는 &lt;a href=&quot;#unwrap&quot;&gt; &lt;code&gt;unwrap&lt;/code&gt; 을&lt;/a&gt; 추가로 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="6492e8cd4172777485864f95c54fa9ab563046c6" translate="yes" xml:space="preserve">
          <source>The returned path is relative to &lt;code&gt;base&lt;/code&gt;, which is by default taken to be the current working directory. If specified, &lt;code&gt;base&lt;/code&gt; must be an absolute path, and it is always assumed to refer to a directory. If &lt;code&gt;path&lt;/code&gt; and &lt;code&gt;base&lt;/code&gt; refer to the same directory, the function returns &lt;code&gt;.&lt;/code&gt;.</source>
          <target state="translated">리턴 된 경로는 &lt;code&gt;base&lt;/code&gt; 에 상대적 이며, 기본적으로 현재 작업 디렉토리로 사용됩니다. 지정된 경우 &lt;code&gt;base&lt;/code&gt; 는 절대 경로 여야하며 항상 디렉토리를 참조한다고 가정합니다. 경우 &lt;code&gt;path&lt;/code&gt; 와 &lt;code&gt;base&lt;/code&gt; 같은 디렉토리, 함수가 반환을 참조하십시오 &lt;code&gt;.&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="27a61535d29f02d1215deba5ffbffddc1e97e7db" translate="yes" xml:space="preserve">
          <source>The returned path is relative to &lt;code&gt;base&lt;/code&gt;, which is usually the current working directory. &lt;code&gt;base&lt;/code&gt; must be an absolute path, and it is always assumed to refer to a directory. If &lt;code&gt;path&lt;/code&gt; and &lt;code&gt;base&lt;/code&gt; refer to the same directory, the function returns &lt;code&gt;'.'&lt;/code&gt;.</source>
          <target state="translated">리턴 된 경로는 &lt;code&gt;base&lt;/code&gt; 에 상대적 이며, 일반적으로 현재 작업 디렉토리입니다. &lt;code&gt;base&lt;/code&gt; 는 절대 경로 여야하며 항상 디렉토리를 참조한다고 가정합니다. 경우 &lt;code&gt;path&lt;/code&gt; 와 &lt;code&gt;base&lt;/code&gt; , 함수가 반환 같은 디렉토리를 참조 &lt;code&gt;'.'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e221dcc2a55e6ae3990cde11462a83ddb8c59e57" translate="yes" xml:space="preserve">
          <source>The reverse of &lt;a href=&quot;#ticksToNSecs&quot;&gt;&lt;code&gt;ticksToNSecs&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#ticksToNSecs&quot;&gt; &lt;code&gt;ticksToNSecs&lt;/code&gt; &lt;/a&gt; 의 반대입니다 .</target>
        </trans-unit>
        <trans-unit id="c6ea2f4408254d943e5179ee3bbfade7f366fbe9" translate="yes" xml:space="preserve">
          <source>The right part of &lt;code&gt;r&lt;/code&gt; after partitioning.  If &lt;code&gt;ss == SwapStrategy.stable&lt;/code&gt;, &lt;code&gt;partition&lt;/code&gt; preserves the relative ordering of all elements &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; in &lt;code&gt;r&lt;/code&gt; for which &lt;code&gt;predicate(a) == predicate(b)&lt;/code&gt;. If &lt;code&gt;ss == SwapStrategy.semistable&lt;/code&gt;, &lt;code&gt;partition&lt;/code&gt; preserves the relative ordering of all elements &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; in the left part of &lt;code&gt;r&lt;/code&gt; for which &lt;code&gt;predicate(a) == predicate(b)&lt;/code&gt;.</source>
          <target state="translated">파티셔닝 후 &lt;code&gt;r&lt;/code&gt; 의 오른쪽 부분 . 경우 &lt;code&gt;ss == SwapStrategy.stable&lt;/code&gt; , &lt;code&gt;partition&lt;/code&gt; 의 모든 요소의 상대적인 순서를 유지 , &lt;code&gt;b&lt;/code&gt; 에서 &lt;code&gt;r&lt;/code&gt; 하는 &lt;code&gt;predicate(a) == predicate(b)&lt;/code&gt; . 경우 &lt;code&gt;ss == SwapStrategy.semistable&lt;/code&gt; , &lt;code&gt;partition&lt;/code&gt; 의 모든 요소의 상대적인 순서를 유지 , &lt;code&gt;b&lt;/code&gt; 왼쪽의 &lt;code&gt;r&lt;/code&gt; 하는 &lt;code&gt;predicate(a) == predicate(b)&lt;/code&gt; . &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="74483ebbb544d307348c8757c03b1bb648258bec" translate="yes" xml:space="preserve">
          <source>The right-hand side of the comparison</source>
          <target state="translated">비교의 오른쪽</target>
        </trans-unit>
        <trans-unit id="0e9a080e28a8d91db65b56c19e48812d639eb325" translate="yes" xml:space="preserve">
          <source>The right-hand side of the comparison for equality</source>
          <target state="translated">평등에 대한 비교의 오른쪽</target>
        </trans-unit>
        <trans-unit id="82b77c8515d584392179571806e80acab0df8e0e" translate="yes" xml:space="preserve">
          <source>The right-hand side of the comparison for ordering</source>
          <target state="translated">주문 비교를위한 오른쪽</target>
        </trans-unit>
        <trans-unit id="ce77342cf014dfbdd37bba884529bb7b1ea8eb76" translate="yes" xml:space="preserve">
          <source>The right-hand side of the operator</source>
          <target state="translated">운전자의 오른쪽</target>
        </trans-unit>
        <trans-unit id="9e41eb8c1a87bc5b03b6c14f9d03728097407757" translate="yes" xml:space="preserve">
          <source>The right-hand side of the operator (left-hand side is &lt;code&gt;this&lt;/code&gt;)</source>
          <target state="translated">조작자의 오른쪽 (왼쪽은 &lt;code&gt;this&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="44c8baae8e4b1cafc92c8edb1f1a4bc6398dfd3a" translate="yes" xml:space="preserve">
          <source>The right-hand side operand</source>
          <target state="translated">오른쪽 피연산자</target>
        </trans-unit>
        <trans-unit id="ac11224128b70935424423a8a77fd6fd68210ba1" translate="yes" xml:space="preserve">
          <source>The right-hand side operand (&lt;code&gt;Rhs&lt;/code&gt; is the first argument to &lt;code&gt;Checked&lt;/code&gt;)</source>
          <target state="translated">오른쪽 피연산자 ( &lt;code&gt;Rhs&lt;/code&gt; 는 &lt;code&gt;Checked&lt;/code&gt; 의 첫 번째 인수입니다. )</target>
        </trans-unit>
        <trans-unit id="0295cf674c21bae7e541254ba48b44bd641bdb8f" translate="yes" xml:space="preserve">
          <source>The right-hand side type in the assignment, after the operation has been computed</source>
          <target state="translated">연산이 계산 된 후 할당의 오른쪽 유형</target>
        </trans-unit>
        <trans-unit id="718e1f58f1f55d464000d479f6fd938c33906894" translate="yes" xml:space="preserve">
          <source>The right-hand side type in the operator</source>
          <target state="translated">연산자의 오른쪽 유형</target>
        </trans-unit>
        <trans-unit id="a73d548c23060689342ba25b61016e797895c8bb" translate="yes" xml:space="preserve">
          <source>The right-hand side type involved in the operator</source>
          <target state="translated">운전자와 관련된 오른쪽 유형</target>
        </trans-unit>
        <trans-unit id="e3fed9dabe35a6b8579a8bd12124493c72510d8b" translate="yes" xml:space="preserve">
          <source>The right-hand side value in the assignment, after the operator has been evaluated</source>
          <target state="translated">연산자가 평가 된 후 할당의 오른쪽 값</target>
        </trans-unit>
        <trans-unit id="cd88512e1e583ed536b72443b9651f20abee0041" translate="yes" xml:space="preserve">
          <source>The routine called when a message is sent to a full mailbox.</source>
          <target state="translated">메시지가 전체 사서함으로 전송 될 때 호출되는 루틴입니다.</target>
        </trans-unit>
        <trans-unit id="b66d87a6c0e08abdd807f5a483f6da0a435298a3" translate="yes" xml:space="preserve">
          <source>The routines and algorithms are derived from the</source>
          <target state="translated">루틴과 알고리즘은</target>
        </trans-unit>
        <trans-unit id="89f0c0488274c89f59fab106ec127c844449805c" translate="yes" xml:space="preserve">
          <source>The rules for strings are the usual for literals: If it can fit in an &lt;code&gt;int&lt;/code&gt;, it is an &lt;code&gt;int&lt;/code&gt;. Otherwise, it is a &lt;code&gt;long&lt;/code&gt;. But, if the user specifically asks for a &lt;code&gt;long&lt;/code&gt; with the &lt;code&gt;L&lt;/code&gt; suffix, always give the &lt;code&gt;long&lt;/code&gt;. Give an unsigned iff it is asked for with the &lt;code&gt;U&lt;/code&gt; or &lt;code&gt;u&lt;/code&gt; suffix. Octals created from integers preserve the type of the passed-in integral.</source>
          <target state="translated">문자열에 대한 규칙은 리터럴 보통이다 : 그것은에 들어갈 수 있다면 &lt;code&gt;int&lt;/code&gt; , 그것이이다 &lt;code&gt;int&lt;/code&gt; . 그렇지 않으면 &lt;code&gt;long&lt;/code&gt; . 사용자가 특별히 요청하지만, &lt;code&gt;long&lt;/code&gt; 와 &lt;code&gt;L&lt;/code&gt; 의 접미사, 항상 줄 &lt;code&gt;long&lt;/code&gt; . &lt;code&gt;U&lt;/code&gt; 또는 &lt;code&gt;u&lt;/code&gt; 접미사로 요청하면 서명되지 않은 iff를 제공하십시오 . 정수로 만든 8 진수는 전달 된 정수의 유형을 유지합니다.</target>
        </trans-unit>
        <trans-unit id="e32ff39ea4f694316ee9d2d062e0ec9da6e2270f" translate="yes" xml:space="preserve">
          <source>The runtime might have been terminated and not be usable anymore when the destructors are called. Otherwise, usage and requirements of &lt;code&gt;crt_destructor&lt;/code&gt; are similar to those of &lt;code&gt;crt_constructor&lt;/code&gt;.</source>
          <target state="translated">런타임이 종료되어 소멸자가 호출 될 때 더 이상 사용할 수 없습니다. 그렇지 않으면, 사용 및 요구 사항 &lt;code&gt;crt_destructor&lt;/code&gt; 은 유사하다 &lt;code&gt;crt_constructor&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e0dffdc084b14542b868ac2c2fcdcfbf771ea55f" translate="yes" xml:space="preserve">
          <source>The runtime module exposes information specific to the D runtime code.</source>
          <target state="translated">런타임 모듈은 D 런타임 코드에 특정한 정보를 노출합니다.</target>
        </trans-unit>
        <trans-unit id="1e0c7d670da430e1c2fcc83076d681bba14efcaf" translate="yes" xml:space="preserve">
          <source>The safety level of this function is faked. It shows itself as &lt;code&gt;@trusted pure nothrow&lt;/code&gt; to not break existing code.</source>
          <target state="translated">이 기능의 안전 수준이 위조되었습니다. 기존 코드를 위반하지 않기 위해 &lt;code&gt;@trusted pure nothrow&lt;/code&gt; 로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="269ccafe0cbb6bd48c0c364d60e7c6c6e04d5947" translate="yes" xml:space="preserve">
          <source>The same applies to other &lt;code&gt;Object&lt;/code&gt; methods such as &lt;code&gt;opCmp&lt;/code&gt;, &lt;code&gt;toHash&lt;/code&gt;, etc.</source>
          <target state="translated">&lt;code&gt;opCmp&lt;/code&gt; , &lt;code&gt;toHash&lt;/code&gt; 와 같은 다른 &lt;code&gt;Object&lt;/code&gt; 메소드 에도 동일하게 적용됩니다. .</target>
        </trans-unit>
        <trans-unit id="e9e9404807d647f780072b029fb88dbb6d89a0b9" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#getVirtualMethods&quot;&gt;&lt;i&gt;getVirtualMethods&lt;/i&gt;&lt;/a&gt;, except that final functions that do not override anything are included.</source>
          <target state="translated">같은 &lt;a href=&quot;#getVirtualMethods&quot;&gt;&lt;i&gt;getVirtualMethods&lt;/i&gt;&lt;/a&gt; 아무것도 무시하지 않는 최종 기능을 제외하고는, 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="93baf85b2a1ff9ebbdedf5ac60d17440ac90bad4" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#isVirtualMethod&quot;&gt;&lt;i&gt;isVirtualMethod&lt;/i&gt;&lt;/a&gt;, except that final functions that don't override anything return true.</source>
          <target state="translated">아무것도 무시하지 않는 최종 함수가 true를 반환한다는 점을 제외하면 &lt;a href=&quot;#isVirtualMethod&quot;&gt;&lt;i&gt;isVirtualMethod&lt;/i&gt;&lt;/a&gt; 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="484feea935bb2f51a17677737f5a18c29ab34260" translate="yes" xml:space="preserve">
          <source>The same is true for structs.</source>
          <target state="translated">구조체도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="daa76d61107754eb643bbf2894986cd43d9f6292" translate="yes" xml:space="preserve">
          <source>The same lookup across blocks, scripts, or binary properties, but performed at run-time. This version is provided for cases where &lt;code&gt;name&lt;/code&gt; is not known beforehand; otherwise compile-time checked &lt;a href=&quot;#opDispatch&quot;&gt;&lt;code&gt;opDispatch&lt;/code&gt;&lt;/a&gt; is typically a better choice.</source>
          <target state="translated">블록, 스크립트 또는 이진 속성에서 동일한 조회이지만 런타임에 수행됩니다. 이 버전은 &lt;code&gt;name&lt;/code&gt; 미리 알 수없는 경우에 제공됩니다 . 그렇지 않으면 컴파일 타임 검사 &lt;a href=&quot;#opDispatch&quot;&gt; &lt;code&gt;opDispatch&lt;/code&gt; &lt;/a&gt; 가 일반적으로 더 나은 선택입니다.</target>
        </trans-unit>
        <trans-unit id="bed255bb45839fece8e5cb2e49994a8474ab1390" translate="yes" xml:space="preserve">
          <source>The saturated result of the operator.</source>
          <target state="translated">운영자의 포화 결과.</target>
        </trans-unit>
        <trans-unit id="44ebf5442f3ff515c11231f709e48f19fb0fd8ce" translate="yes" xml:space="preserve">
          <source>The scanner function. It should scan from p1 through p2 - 1.</source>
          <target state="translated">스캐너 기능. p1에서 p2-1까지 스캔해야합니다.</target>
        </trans-unit>
        <trans-unit id="2b5611ba00d0c5303ec080902ad8f7d6474ce6c0" translate="yes" xml:space="preserve">
          <source>The scanning function.</source>
          <target state="translated">스캔 기능.</target>
        </trans-unit>
        <trans-unit id="6c94bc26dd8e2388a5758b02c027326a48e92c3c" translate="yes" xml:space="preserve">
          <source>The scheduling priority of this thread.</source>
          <target state="translated">이 스레드의 스케줄링 우선 순위.</target>
        </trans-unit>
        <trans-unit id="bce914b8aac817557e08a2a5b7b1a5b382065247" translate="yes" xml:space="preserve">
          <source>The scope characteristic is inherited, so any classes derived from a scope class are also scope.</source>
          <target state="translated">범위 특성이 상속되므로 범위 클래스에서 파생 된 모든 클래스도 범위입니다.</target>
        </trans-unit>
        <trans-unit id="bece65d16e0da3cd8d963615575ef27d8569dde0" translate="yes" xml:space="preserve">
          <source>The second</source>
          <target state="translated">두번째</target>
        </trans-unit>
        <trans-unit id="f0aa270a7ba151a0f73151e3a972f6dc7bf0ee07" translate="yes" xml:space="preserve">
          <source>The second array to compare</source>
          <target state="translated">비교할 두 번째 배열</target>
        </trans-unit>
        <trans-unit id="970cba63abb463ea9e374f88bdbe56bd7fb71605" translate="yes" xml:space="preserve">
          <source>The second form attaches the &lt;code&gt;return&lt;/code&gt; to the &lt;code&gt;ref&lt;/code&gt;, and has &lt;a href=&quot;#return-ref-parameters&quot;&gt;return ref parameter&lt;/a&gt; semantics with additional &lt;a href=&quot;memory-safe-d#scope-return-params&quot;&gt;scope parameter&lt;/a&gt; semantics.</source>
          <target state="translated">두 번째 형식은 &lt;code&gt;return&lt;/code&gt; 을 &lt;code&gt;ref&lt;/code&gt; 에 첨부하고 추가 &lt;a href=&quot;memory-safe-d#scope-return-params&quot;&gt;범위 매개 &lt;/a&gt;&lt;a href=&quot;#return-ref-parameters&quot;&gt;변수&lt;/a&gt; 의미를 갖는 리턴 ref 매개 변수 의미를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="061d4f927a4a2679d380b604c58cb6c22d22e3d1" translate="yes" xml:space="preserve">
          <source>The second form of this function is usually not called directly; instead, it is used via &lt;a href=&quot;std_string#format&quot;&gt;&lt;code&gt;std.string.format&lt;/code&gt;&lt;/a&gt;, as shown in the examples below. Supported format characters are 'e', 'f', 'g', 'a', and 's'.</source>
          <target state="translated">이 함수의 두 번째 형식은 일반적으로 직접 호출되지 않습니다. 대신 아래 예제와 같이 &lt;a href=&quot;std_string#format&quot;&gt; &lt;code&gt;std.string.format&lt;/code&gt; 을&lt;/a&gt; 통해 사용 됩니다. 지원되는 형식 문자는 'e', ​​'f', 'g', 'a'및 's'입니다.</target>
        </trans-unit>
        <trans-unit id="6175891dc518c6e785380cc43703fbdbef055ecb" translate="yes" xml:space="preserve">
          <source>The second form, &lt;code&gt;goto default;&lt;/code&gt;, transfers to the innermost &lt;a href=&quot;#DefaultStatement&quot;&gt;&lt;i&gt;DefaultStatement&lt;/i&gt;&lt;/a&gt; of an enclosing &lt;a href=&quot;#SwitchStatement&quot;&gt;&lt;i&gt;SwitchStatement&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">두 번째 양식은 &lt;code&gt;goto default;&lt;/code&gt; , 둘러싸는 &lt;a href=&quot;#SwitchStatement&quot;&gt;&lt;i&gt;SwitchStatement&lt;/i&gt;&lt;/a&gt; 의 가장 안쪽 &lt;a href=&quot;#DefaultStatement&quot;&gt;&lt;i&gt;DefaultStatement&lt;/i&gt;&lt;/a&gt; 로 전송합니다 .&lt;i&gt;&lt;/i&gt;</target>
        </trans-unit>
        <trans-unit id="1b51588d42d45bcafc26dcdf68b259620359d8f6" translate="yes" xml:space="preserve">
          <source>The second function</source>
          <target state="translated">두 번째 기능</target>
        </trans-unit>
        <trans-unit id="9a381cf5b12ec2751302d71f1f36bb254a3a2a6d" translate="yes" xml:space="preserve">
          <source>The second makes use of template mixins:</source>
          <target state="translated">두 번째는 템플릿 믹스 인을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="b6d7d023028752f2dd5e8e8741a79baee2991163" translate="yes" xml:space="preserve">
          <source>The second portion of the time;</source>
          <target state="translated">시간의 두 번째 부분;</target>
        </trans-unit>
        <trans-unit id="d17baa58ea7c9cb2b5fdeeba1668762e0d314080" translate="yes" xml:space="preserve">
          <source>The second range</source>
          <target state="translated">두 번째 범위</target>
        </trans-unit>
        <trans-unit id="03495ddd562bb985866c15203033cded1697fdb5" translate="yes" xml:space="preserve">
          <source>The second range to be compared.</source>
          <target state="translated">비교할 두 번째 범위입니다.</target>
        </trans-unit>
        <trans-unit id="17805909c78bc23c485d6d0eee55678a2626d3ec" translate="yes" xml:space="preserve">
          <source>The second range.</source>
          <target state="translated">두 번째 범위.</target>
        </trans-unit>
        <trans-unit id="b5c0d389b19e84b52a4b93582ba1ef6275bab88b" translate="yes" xml:space="preserve">
          <source>The second to set this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;'s second to.</source>
          <target state="translated">이 &lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 의 초를 설정하는 초 입니다.</target>
        </trans-unit>
        <trans-unit id="ca5f5f8367bfce8ad586cc8594d3c281eb469bd2" translate="yes" xml:space="preserve">
          <source>The second to set this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;'s second to.</source>
          <target state="translated">이 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; 의 초를 설정하는 초 입니다.</target>
        </trans-unit>
        <trans-unit id="996418c92be5b452f3de4ff986e1cee8b8da9918" translate="yes" xml:space="preserve">
          <source>The second to set this &lt;a href=&quot;#TimeOfDay&quot;&gt;&lt;code&gt;TimeOfDay&lt;/code&gt;&lt;/a&gt;'s second to.</source>
          <target state="translated">이 &lt;a href=&quot;#TimeOfDay&quot;&gt; &lt;code&gt;TimeOfDay&lt;/code&gt; &lt;/a&gt; 초를 설정하는 초 입니다.</target>
        </trans-unit>
        <trans-unit id="fb3c67e4431bd2d01f2e0a28a1a5ab4c776bb0a0" translate="yes" xml:space="preserve">
          <source>The second type to receive the type name for</source>
          <target state="translated">유형 이름을받는 두 번째 유형</target>
        </trans-unit>
        <trans-unit id="572604b99f4f13c97178a7bb83d0a01c9c1fdbf8" translate="yes" xml:space="preserve">
          <source>The second version of &lt;code&gt;AutoImplement&lt;/code&gt; automatically implements &lt;code&gt;Interface&lt;/code&gt;, while deriving from &lt;code&gt;BaseClass&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;AutoImplement&lt;/code&gt; 의 두 번째 버전은 &lt;code&gt;BaseClass&lt;/code&gt; 에서 파생되는 동안 자동으로 &lt;code&gt;Interface&lt;/code&gt; 를 구현 합니다.</target>
        </trans-unit>
        <trans-unit id="9922ebb56662094439fd0982652299a78a77cb79" translate="yes" xml:space="preserve">
          <source>The second version of the function logs data to the &lt;code&gt;sharedLog&lt;/code&gt; in a &lt;code&gt;printf&lt;/code&gt;-style manner.  In order for the resulting log message to be logged the &lt;code&gt;LogLevel&lt;/code&gt; must be greater or equal than the &lt;code&gt;LogLevel&lt;/code&gt; of the &lt;code&gt;sharedLog&lt;/code&gt; and must be greater or equal than the global &lt;code&gt;LogLevel&lt;/code&gt;. Additionally the &lt;code&gt;LogLevel&lt;/code&gt; must be greater or equal than the &lt;code&gt;LogLevel&lt;/code&gt; of the &lt;code&gt;stdSharedLogger&lt;/code&gt;.</source>
          <target state="translated">함수의 두 번째 버전은 &lt;code&gt;printf&lt;/code&gt; 스타일 방식으로 데이터를 &lt;code&gt;sharedLog&lt;/code&gt; 에 기록합니다 . 결과 로그 메시지를 기록하려면 &lt;code&gt;LogLevel&lt;/code&gt; 이 &lt;code&gt;sharedLog&lt;/code&gt; 의 &lt;code&gt;LogLevel&lt;/code&gt; 보다 크거나 같아야하며 전역 &lt;code&gt;LogLevel&lt;/code&gt; 보다 크거나 같아야합니다 . 추가적으로 &lt;code&gt;LogLevel&lt;/code&gt; 크거나 같해야 &lt;code&gt;LogLevel&lt;/code&gt; 에 의 &lt;code&gt;stdSharedLogger&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fca00f96f63ee8d1d8ffcc6e490cc9b3f2af7ff1" translate="yes" xml:space="preserve">
          <source>The second version returns the number of times &lt;code&gt;needle&lt;/code&gt; occurs in &lt;code&gt;haystack&lt;/code&gt;. Throws an exception if &lt;code&gt;needle.empty&lt;/code&gt;, as the count of the empty range in any range would be infinite. Overlapped counts are not considered, for example &lt;code&gt;count(&quot;aaa&quot;, &quot;aa&quot;)&lt;/code&gt; is &lt;code&gt;1&lt;/code&gt;, not &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="translated">두 번째 버전은 &lt;code&gt;haystack&lt;/code&gt; 에서 &lt;code&gt;needle&lt;/code&gt; 이 발생한 횟수를 반환합니다 . 임의의 범위에서 빈 범위의 개수가 무한 &lt;code&gt;needle.empty&lt;/code&gt; 인 경우 예외를 발생 시킵니다 . 겹친 카운트는 고려되지 않습니다. 예를 들어 &lt;code&gt;count(&quot;aaa&quot;, &quot;aa&quot;)&lt;/code&gt; 는 &lt;code&gt;1&lt;/code&gt; 가 아니라 &lt;code&gt;2&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c0ad6e5d9828f85ec68413d4266b0a775c993286" translate="yes" xml:space="preserve">
          <source>The second way is to cast data to immutable. When doing so, it is up to the programmer to ensure that any mutable references to the same data are not used to modify the data after the cast.</source>
          <target state="translated">두 번째 방법은 데이터를 불변으로 캐스트하는 것입니다. 그렇게 할 때, 동일한 데이터에 대한 변경 가능한 참조가 캐스트 후 데이터를 수정하는 데 사용되지 않도록하는 것은 프로그래머의 몫입니다.</target>
        </trans-unit>
        <trans-unit id="98a2a2f9f0974d5cf21ef2c42fb8d7b511ec7622" translate="yes" xml:space="preserve">
          <source>The second way is to use the precision specifier. The length comes first, followed by the pointer:</source>
          <target state="translated">두 번째 방법은 정밀도 지정자를 사용하는 것입니다. 길이가 먼저오고 포인터가옵니다.</target>
        </trans-unit>
        <trans-unit id="6258e42911fadc579ef629cac8b879505c815405" translate="yes" xml:space="preserve">
          <source>The second will queue readers if there are any writers queued. Writers are passed through one at a time, and once there are no writers present, all queued readers will be alerted.</source>
          <target state="translated">대기중인 기록기가 있으면 두 번째는 판독기를 대기시킵니다. 작가는 한 번에 하나씩 통과하고 작가가 없으면 대기중인 모든 독자에게 경고합니다.</target>
        </trans-unit>
        <trans-unit id="222f9be8417077b869fc4ec2ffe85613dca810b0" translate="yes" xml:space="preserve">
          <source>The selector parameter for Objective-C methods.</source>
          <target state="translated">Objective-C 메소드의 선택기 매개 변수입니다.</target>
        </trans-unit>
        <trans-unit id="c7b62a580f33ebf95a2e808ad6d0fddcde51f3ed" translate="yes" xml:space="preserve">
          <source>The semantics of a bidirectional range (not checkable during compilation) are assumed to be the following (&lt;code&gt;r&lt;/code&gt; is an object of type &lt;code&gt;R&lt;/code&gt;):</source>
          <target state="translated">양방향 범위의 의미 (컴파일 중에는 확인할 수 없음)는 다음과 같다고 가정합니다 ( &lt;code&gt;r&lt;/code&gt; 은 &lt;code&gt;R&lt;/code&gt; 유형의 객체 임 ).</target>
        </trans-unit>
        <trans-unit id="17817f0aec7117e53dffc5a42bb0ce81b624678f" translate="yes" xml:space="preserve">
          <source>The semantics of a forward range (not checkable during compilation) are the same as for an input range, with the additional requirement that backtracking must be possible by saving a copy of the range object with &lt;code&gt;save&lt;/code&gt; and using it later.</source>
          <target state="translated">포워드 범위의 의미 (컴파일 중에는 확인할 수 없음)는 입력 범위와 동일하며, 범위 오브젝트의 사본을 &lt;code&gt;save&lt;/code&gt; 과 함께 저장 한 후 나중에 사용하여 역 추적이 가능해야하는 추가 요구 사항이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9ad7ef472479146863a20e103ea6caeaec90cbb2" translate="yes" xml:space="preserve">
          <source>The semantics of a module are not affected by what imports it.</source>
          <target state="translated">모듈의 의미는 가져 오는 대상의 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1896dacb2ba5ac95d6272bdae742dc30f30d5318" translate="yes" xml:space="preserve">
          <source>The semantics of a random-access range (not checkable during compilation) are assumed to be the following (&lt;code&gt;r&lt;/code&gt; is an object of type &lt;code&gt;R&lt;/code&gt;):</source>
          <target state="translated">랜덤 액세스 범위의 의미 (컴파일 중에는 확인할 수 없음)는 다음과 같다고 가정합니다 ( &lt;code&gt;r&lt;/code&gt; 은 &lt;code&gt;R&lt;/code&gt; 유형의 오브젝트 임 ).</target>
        </trans-unit>
        <trans-unit id="a29d19e0a1c63b8d3f0187e1b535c432966dec4b" translate="yes" xml:space="preserve">
          <source>The semaphore module provides a general use semaphore for synchronization.</source>
          <target state="translated">세마포어 모듈은 동기화를 위해 일반적으로 사용되는 세마포어를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="0cb8e57171fd0fa8e03b5c22f3ff466ddf864a6e" translate="yes" xml:space="preserve">
          <source>The sequence of tokens is parsed to form syntax trees.</source>
          <target state="translated">토큰 시퀀스는 구문 분석 트리를 구성하기 위해 구문 분석됩니다.</target>
        </trans-unit>
        <trans-unit id="438ac8d829e20acc25c07ebf7273d7538987132c" translate="yes" xml:space="preserve">
          <source>The sequence to check for the &lt;code&gt;BOM&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;BOM&lt;/code&gt; 을 확인하는 순서</target>
        </trans-unit>
        <trans-unit id="aec41afa837cbb030bd78ed48712b8225ab720a9" translate="yes" xml:space="preserve">
          <source>The short symbol for this option</source>
          <target state="translated">이 옵션의 짧은 기호</target>
        </trans-unit>
        <trans-unit id="14ab0adc14c1851e03d1a893322666eb1605f066" translate="yes" xml:space="preserve">
          <source>The shuffled random-access range.</source>
          <target state="translated">뒤섞인 임의 접근 범위.</target>
        </trans-unit>
        <trans-unit id="b938bafa6a37b04fed1bbf8b758bf0a54b828b83" translate="yes" xml:space="preserve">
          <source>The sign of &amp;Gamma;(x).</source>
          <target state="translated">&amp;Gamma; (x)의 부호.</target>
        </trans-unit>
        <trans-unit id="691fa1f516ff445955097300abb84801c17ce9af" translate="yes" xml:space="preserve">
          <source>The signature of this function should be:</source>
          <target state="translated">이 함수의 서명은 다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="1c551bae643970a0fd547169fd9a9d141dddbbc8" translate="yes" xml:space="preserve">
          <source>The signed type is converted to the unsigned type.</source>
          <target state="translated">부호있는 유형이 부호없는 유형으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="ee800310ad7741a1c2a988b7683af21966b44816" translate="yes" xml:space="preserve">
          <source>The similarity per &lt;code&gt;gapWeightedSimilarity&lt;/code&gt; has an issue in that it grows with the lengths of the two strings, even though the strings are not actually very similar. For example, the range &lt;code&gt;[&quot;Hello&quot;, &quot;world&quot;]&lt;/code&gt; is increasingly similar with the range &lt;code&gt;[&quot;Hello&quot;, &quot;world&quot;, &quot;world&quot;, &quot;world&quot;,...]&lt;/code&gt; as more instances of &lt;code&gt;&quot;world&quot;&lt;/code&gt; are appended. To prevent that, &lt;code&gt;gapWeightedSimilarityNormalized&lt;/code&gt; computes a normalized version of the similarity that is computed as &lt;code&gt;gapWeightedSimilarity(s, t, lambda) / sqrt(gapWeightedSimilarity(s, t, lambda) * gapWeightedSimilarity(s, t, lambda))&lt;/code&gt;. The function &lt;code&gt;gapWeightedSimilarityNormalized&lt;/code&gt; (a so-called normalized kernel) is bounded in &lt;code&gt;[0, 1]&lt;/code&gt;, reaches &lt;code&gt;0&lt;/code&gt; only for ranges that don't match in any position, and &lt;code&gt;1&lt;/code&gt; only for identical ranges.</source>
          <target state="translated">&lt;code&gt;gapWeightedSimilarity&lt;/code&gt; 당 유사성 은 문자열이 실제로 매우 유사하지 않더라도 두 문자열의 길이에 따라 증가한다는 문제가 있습니다. 예를 들어, 범위는 &lt;code&gt;[&quot;Hello&quot;, &quot;world&quot;]&lt;/code&gt; 범위 점점 비슷 &lt;code&gt;[&quot;Hello&quot;, &quot;world&quot;, &quot;world&quot;, &quot;world&quot;,...]&lt;/code&gt; 의 이상의 인스턴스로서 &lt;code&gt;&quot;world&quot;&lt;/code&gt; 첨부되고 . 이를 방지하기 위해 &lt;code&gt;gapWeightedSimilarityNormalized&lt;/code&gt; 는 &lt;code&gt;gapWeightedSimilarity(s, t, lambda) / sqrt(gapWeightedSimilarity(s, t, lambda) * gapWeightedSimilarity(s, t, lambda))&lt;/code&gt; 로 계산 된 유사성의 정규화 된 버전을 계산 합니다. &lt;code&gt;gapWeightedSimilarityNormalized&lt;/code&gt; (소위 정규화 된 커널) 함수 는 함수 &lt;code&gt;0&lt;/code&gt; &lt;code&gt;[0, 1]&lt;/code&gt; 은 어떤 위치에서도 일치하지 않는 범위에 대해서만, 동일한 범위에 대해서는 &lt;code&gt;1&lt;/code&gt; 에 도달 합니다.</target>
        </trans-unit>
        <trans-unit id="88799e576696dc3374489d7e5f75d72056dc1dfa" translate="yes" xml:space="preserve">
          <source>The simplest form of importing is to just list the modules being imported:</source>
          <target state="translated">가져 오기의 가장 간단한 형태는 가져올 모듈을 나열하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e2009ad4b4c0d89d88051ad98575cc82bbbcf921" translate="yes" xml:space="preserve">
          <source>The simplest immutable declarations use it as a storage class. It can be used to declare manifest constants.</source>
          <target state="translated">가장 간단한 불변 선언은이를 저장 클래스로 사용합니다. 매니페스트 상수를 선언하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b20f562102f67ba45af181d477da8263c4656fad" translate="yes" xml:space="preserve">
          <source>The simplest use of &lt;code&gt;bringToFront&lt;/code&gt; is for rotating elements in a buffer. For example:</source>
          <target state="translated">&lt;code&gt;bringToFront&lt;/code&gt; 의 가장 간단한 사용법은 버퍼에서 요소를 회전시키는 것입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="87bc4b882bb607c1c565d6a1ffe9da4b18a9935d" translate="yes" xml:space="preserve">
          <source>The sine and cosine of &lt;code&gt;z&lt;/code&gt;, respectively.</source>
          <target state="translated">사인 및 코사인 &lt;code&gt;z&lt;/code&gt; 각각.</target>
        </trans-unit>
        <trans-unit id="1ad591c3d3f25fb3fd9de0046684571acd9030d0" translate="yes" xml:space="preserve">
          <source>The sine, cosine and tangent of &lt;code&gt;z&lt;/code&gt;, respectively.</source>
          <target state="translated">&lt;code&gt;z&lt;/code&gt; 의 사인, 코사인 및 탄젠트입니다 .</target>
        </trans-unit>
        <trans-unit id="4beb2d03043706421491257b91174cce75401dc3" translate="yes" xml:space="preserve">
          <source>The single element to check.</source>
          <target state="translated">확인할 단일 요소입니다.</target>
        </trans-unit>
        <trans-unit id="e20b632a66e4a0973d296fc8dc97c6e7878340fa" translate="yes" xml:space="preserve">
          <source>The single needle to check, which may be either a single element or an input range of elements.</source>
          <target state="translated">검사 할 단일 바늘로, 단일 요소 또는 요소의 입력 범위 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="936e0c490ea32a66488b88e6407723c37e53055d" translate="yes" xml:space="preserve">
          <source>The size in bytes of the block to add. If sz is zero then the no operation will occur. If p is null then sz must be zero.</source>
          <target state="translated">추가 할 블록의 크기 (바이트)입니다. sz가 0이면 아무 작업도 수행되지 않습니다. p가 null이면 sz는 0이어야합니다.</target>
        </trans-unit>
        <trans-unit id="d5f548166d575892e245b5d531ead88e195d968a" translate="yes" xml:space="preserve">
          <source>The size in bytes of the extended memory block referenced by p or zero if no extension occurred.</source>
          <target state="translated">확장이 발생하지 않은 경우 p 또는 0으로 참조되는 확장 메모리 블록의 크기 (바이트)입니다.</target>
        </trans-unit>
        <trans-unit id="f5a5bf7ffaae9ea0e47a648c75ab38577c22cdee" translate="yes" xml:space="preserve">
          <source>The size in bytes of the memory block referenced by p or zero on error.</source>
          <target state="translated">오류시 p 또는 0으로 참조되는 메모리 블록의 크기 (바이트)입니다.</target>
        </trans-unit>
        <trans-unit id="a5ec735b95eb9947e1d6e43682f1263ddf71f814" translate="yes" xml:space="preserve">
          <source>The size of a system page in bytes.</source>
          <target state="translated">시스템 페이지의 크기 (바이트)입니다.</target>
        </trans-unit>
        <trans-unit id="47c428b4443aaffa87ab01d194f64c1d9938dadd" translate="yes" xml:space="preserve">
          <source>The size of each block can be selected either during compilation or at run time. Statically-known block sizes are frequent in practice and yield slightly better performance. To choose a block size statically, pass it as the &lt;code&gt;blockSize&lt;/code&gt; parameter as in &lt;code&gt;BitmappedBlock!(4096)&lt;/code&gt;. To choose a block size parameter, use &lt;code&gt;BitmappedBlock!(chooseAtRuntime)&lt;/code&gt; and pass the block size to the constructor.</source>
          <target state="translated">각 블록의 크기는 컴파일 중 또는 런타임 중에 선택할 수 있습니다. 정적으로 알려진 블록 크기는 실제로 빈번하며 성능이 약간 향상됩니다. 블록 크기를 정적으로 선택하려면 &lt;code&gt;BitmappedBlock!(4096)&lt;/code&gt; 에서 와 같이 블록 크기를 &lt;code&gt;blockSize&lt;/code&gt; 매개 변수로 전달하십시오 . 블록 크기 매개 변수를 선택하려면 &lt;code&gt;BitmappedBlock!(chooseAtRuntime)&lt;/code&gt; 사용 하고 블록 크기를 생성자에 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="a8db79a8cc24d1fb50ebc2a5392b4de19bea96fb" translate="yes" xml:space="preserve">
          <source>The size of each chunk</source>
          <target state="translated">각 청크의 크기</target>
        </trans-unit>
        <trans-unit id="812d083ae4b6202df6ef9285312c396838fbce8c" translate="yes" xml:space="preserve">
          <source>The size of file in bytes.</source>
          <target state="translated">바이트 단위의 파일 크기입니다.</target>
        </trans-unit>
        <trans-unit id="5299bf2c3bb77629866128b69aa3cd98cc936e97" translate="yes" xml:space="preserve">
          <source>The size of the allocated length at the end depends on the block size:</source>
          <target state="translated">끝에 할당 된 길이의 크기는 블록 크기에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="a507a2fd30a698197eb87aec60496407de2cc9b4" translate="yes" xml:space="preserve">
          <source>The size of the buffer to store the evaluated elements.</source>
          <target state="translated">평가 된 요소를 저장할 버퍼의 크기입니다.</target>
        </trans-unit>
        <trans-unit id="f51f328cc82fa5e1146c1bcd8d39f77ba7f1a772" translate="yes" xml:space="preserve">
          <source>The size of the chunks</source>
          <target state="translated">청크의 크기</target>
        </trans-unit>
        <trans-unit id="f95ddc1cb4621988d676a326385232a6d69ff6df" translate="yes" xml:space="preserve">
          <source>The slice of &lt;code&gt;buf&lt;/code&gt; containing the formatted string.</source>
          <target state="translated">형식화 된 문자열을 포함하는 &lt;code&gt;buf&lt;/code&gt; 조각입니다 .</target>
        </trans-unit>
        <trans-unit id="c76fb8fffafacca9cf978997fee5c7ec6adb0669" translate="yes" xml:space="preserve">
          <source>The slice of &lt;code&gt;buffer&lt;/code&gt; containing the data that was actually read. This will be shorter than &lt;code&gt;buffer&lt;/code&gt; if EOF was reached before the buffer could be filled.</source>
          <target state="translated">실제로 읽은 데이터를 포함하는 &lt;code&gt;buffer&lt;/code&gt; 조각입니다 . 버퍼가 채워지기 전에 EOF에 도달하면 &lt;code&gt;buffer&lt;/code&gt; 보다 짧습니다 .</target>
        </trans-unit>
        <trans-unit id="25175c4c04d78f4f21e72598ea69bd88d569188a" translate="yes" xml:space="preserve">
          <source>The slice of &lt;code&gt;target&lt;/code&gt; containing the copied elements.</source>
          <target state="translated">복사 된 요소를 포함하는 &lt;code&gt;target&lt;/code&gt; 조각입니다 .</target>
        </trans-unit>
        <trans-unit id="ad4934ab24ff890e3942dd0930dacb128284b747" translate="yes" xml:space="preserve">
          <source>The slice of buffer containing the decoded result.</source>
          <target state="translated">디코딩 된 결과를 포함하는 버퍼 슬라이스입니다.</target>
        </trans-unit>
        <trans-unit id="2493c4fc7b08258cd8cb15270e3f883e67df77ba" translate="yes" xml:space="preserve">
          <source>The slice of buffer that contains the encoded string.</source>
          <target state="translated">인코딩 된 문자열을 포함하는 버퍼 조각입니다.</target>
        </trans-unit>
        <trans-unit id="ad35a55effab17cdb298d4bb62b7946a0a05ee95" translate="yes" xml:space="preserve">
          <source>The slice on the left and any slices on the right must not overlap. All operands are evaluated exactly once, even if the array slice has zero elements in it.</source>
          <target state="translated">왼쪽의 슬라이스와 오른쪽의 슬라이스는 겹치지 않아야합니다. 배열 슬라이스에 요소가없는 경우에도 모든 피연산자가 정확히 한 번 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="7d8c2f61d4c506e7a291057e4bc000a710aed4c4" translate="yes" xml:space="preserve">
          <source>The slice's usable size will not match the block size. Use &lt;a href=&quot;#capacity&quot;&gt;&lt;code&gt;capacity&lt;/code&gt;&lt;/a&gt; to retrieve actual usable capacity.</source>
          <target state="translated">슬라이스의 사용 가능한 크기가 블록 크기와 일치하지 않습니다. 실제 사용 가능한 &lt;a href=&quot;#capacity&quot;&gt; &lt;code&gt;capacity&lt;/code&gt; &lt;/a&gt; 을 검색 하려면 용량 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="bba8f7aecbe8029037e1ea79aca03fd651b20234" translate="yes" xml:space="preserve">
          <source>The smallest size that can be allocated is two words (16 bytes on 64-bit systems, 8 bytes on 32-bit systems). This is because the free list management needs two words (one for the length, the other for the next pointer in the singly-linked list).</source>
          <target state="translated">할당 할 수있는 가장 작은 크기는 2 워드 (64 비트 시스템의 경우 16 바이트, 32 비트 시스템의 경우 8 바이트)입니다. 자유 목록 관리에는 두 단어가 필요하기 때문입니다 (하나는 길이, 다른 하나는 단일 링크 목록의 다음 포인터).</target>
        </trans-unit>
        <trans-unit id="c8f2935f9d51846f40ce3a8ff14ea8411e17c417" translate="yes" xml:space="preserve">
          <source>The so-called &quot;all-lengths gap-weighted string kernel&quot; computes a similarity measure between &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;t&lt;/code&gt; based on all of their common subsequences of all lengths. Gapped subsequences are also included.</source>
          <target state="translated">소위 &quot;전장 간격 가중 문자열 커널&quot;은 다음과 같은 유사성을 계산합니다. &lt;code&gt;s&lt;/code&gt; 모든 길이의 공통 하위 시퀀스를 모두 기반으로 s 와 &lt;code&gt;t&lt;/code&gt; 의 . 갭 서브 시퀀스도 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="b69c2f4a1b196deb3a8f2c9757a25cc977da4151" translate="yes" xml:space="preserve">
          <source>The solution is to use exception handling to report errors. All errors are objects derived from abstract class &lt;code&gt;Error&lt;/code&gt;. &lt;code&gt;Error&lt;/code&gt; has a pure virtual function called toString() which produces a &lt;code&gt;string&lt;/code&gt; with a human readable description of the error.</source>
          <target state="translated">해결책은 예외 처리를 사용하여 오류를보고하는 것입니다. 모든 에러는 추상 클래스 &lt;code&gt;Error&lt;/code&gt; 에서 파생 된 객체 입니다. &lt;code&gt;Error&lt;/code&gt; 에는 toString ()이라는 순수한 가상 함수 가 있으며 사람이 읽을 수있는 오류에 대한 설명이 포함 된 &lt;code&gt;string&lt;/code&gt; 을 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="869eb1c2ddd5095ece630ff3cd9aa908770a28d3" translate="yes" xml:space="preserve">
          <source>The sorted alias sequence</source>
          <target state="translated">정렬 된 별칭 시퀀스</target>
        </trans-unit>
        <trans-unit id="5890e22a27a487c3d84b74c6aadd83e7f574f4f1" translate="yes" xml:space="preserve">
          <source>The sorted, left-hand side of the random access range to be sorted.</source>
          <target state="translated">정렬 할 랜덤 액세스 범위의 정렬 된 왼쪽입니다.</target>
        </trans-unit>
        <trans-unit id="327825eee250d31d85788280f6649c7f91900518" translate="yes" xml:space="preserve">
          <source>The source &lt;code&gt;Tuple&lt;/code&gt; to assign from. Each element of the source &lt;code&gt;Tuple&lt;/code&gt; must be implicitly assignable to each respective element of the target &lt;code&gt;Tuple&lt;/code&gt;.</source>
          <target state="translated">할당 할 소스 &lt;code&gt;Tuple&lt;/code&gt; 입니다. 소스 &lt;code&gt;Tuple&lt;/code&gt; 의 각 요소는 대상 &lt;code&gt;Tuple&lt;/code&gt; 의 각 요소에 내재적으로 지정 가능해야합니다. .</target>
        </trans-unit>
        <trans-unit id="04c2f4edcae02e1187a2d950f9afa01879a679fc" translate="yes" xml:space="preserve">
          <source>The source file is checked to determine its encoding and the appropriate scanner is loaded. 7-bit ASCII and UTF encodings are accepted.</source>
          <target state="translated">소스 파일을 검사하여 인코딩을 확인하고 적절한 스캐너가로드됩니다. 7 비트 ASCII 및 UTF 인코딩이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="5030b9b136204dc20df5dd72c92bea98a422bbd5" translate="yes" xml:space="preserve">
          <source>The source file is checked to see what character set it is, and the appropriate scanner is loaded. ASCII and UTF formats are accepted.</source>
          <target state="translated">소스 파일에서 문자 세트를 확인하고 적절한 스캐너가로드되었는지 확인합니다. ASCII 및 UTF 형식이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="720cc790393ba54be158f390e51929cd3fbb4795" translate="yes" xml:space="preserve">
          <source>The source file is divided into a sequence of tokens. &lt;a href=&quot;lex#specialtokens&quot;&gt;Special tokens&lt;/a&gt; are replaced with other tokens. &lt;a href=&quot;lex#SpecialTokenSequence&quot;&gt;&lt;i&gt;SpecialTokenSequence&lt;/i&gt;&lt;/a&gt;s are processed and removed.</source>
          <target state="translated">소스 파일은 일련의 토큰으로 나뉩니다. &lt;a href=&quot;lex#specialtokens&quot;&gt;특수 토큰&lt;/a&gt; 은 다른 토큰 으로 대체됩니다. &lt;a href=&quot;lex#SpecialTokenSequence&quot;&gt;&lt;i&gt;SpecialTokenSequence&lt;/i&gt;&lt;/a&gt; 는 처리 및 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="dfdc9b54ae3eba8ba8704bc6e8f6a3bd3398e870" translate="yes" xml:space="preserve">
          <source>The source file is divided up into a sequence of tokens. &lt;a href=&quot;lex#specialtokens&quot;&gt;Special tokens&lt;/a&gt; are replaced with other tokens. &lt;a href=&quot;lex#SpecialTokenSequence&quot;&gt;&lt;i&gt;SpecialTokenSequence&lt;/i&gt;&lt;/a&gt;s are processed and removed.</source>
          <target state="translated">소스 파일은 일련의 토큰으로 나뉩니다. &lt;a href=&quot;lex#specialtokens&quot;&gt;특수 토큰&lt;/a&gt; 은 다른 토큰 으로 대체됩니다. &lt;a href=&quot;lex#SpecialTokenSequence&quot;&gt;&lt;i&gt;특별 토큰 순서&lt;/i&gt;&lt;/a&gt; 가 처리 및 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="81874a58d9273e37ffa0ff4c91450536e1226f36" translate="yes" xml:space="preserve">
          <source>The source file name of the caller.</source>
          <target state="translated">발신자의 소스 파일 이름입니다.</target>
        </trans-unit>
        <trans-unit id="63c931360a6dacfd65be2e57e259c4c016ac5c72" translate="yes" xml:space="preserve">
          <source>The source file of the caller.</source>
          <target state="translated">발신자의 소스 파일입니다.</target>
        </trans-unit>
        <trans-unit id="5e1d1c43260b49fce3e8356d81c8f39a6eaf6f86" translate="yes" xml:space="preserve">
          <source>The source location.</source>
          <target state="translated">소스 위치</target>
        </trans-unit>
        <trans-unit id="57597d8f1413ea294f9a97a53e7900b691ef6e36" translate="yes" xml:space="preserve">
          <source>The source object</source>
          <target state="translated">소스 객체</target>
        </trans-unit>
        <trans-unit id="a8df6910eb6a7836cdf1dd95711fe44c7f692e87" translate="yes" xml:space="preserve">
          <source>The source of the cast</source>
          <target state="translated">캐스트의 소스</target>
        </trans-unit>
        <trans-unit id="79f7b5f01174bbbd5d3e9abcd1ae8cab2d28d824" translate="yes" xml:space="preserve">
          <source>The source range.</source>
          <target state="translated">소스 범위.</target>
        </trans-unit>
        <trans-unit id="139f7114b9b6fbeefdd429dfd8ce09ec26e9b7ae" translate="yes" xml:space="preserve">
          <source>The source text is decoded from its source representation into Unicode &lt;a href=&quot;#Character&quot;&gt;&lt;i&gt;Character&lt;/i&gt;&lt;/a&gt;s. The &lt;a href=&quot;#Character&quot;&gt;&lt;i&gt;Character&lt;/i&gt;&lt;/a&gt;s are further divided into: &lt;a href=&quot;#WhiteSpace&quot;&gt;&lt;i&gt;WhiteSpace&lt;/i&gt;&lt;/a&gt;, &lt;a href=&quot;#EndOfLine&quot;&gt;&lt;i&gt;EndOfLine&lt;/i&gt;&lt;/a&gt;, &lt;a href=&quot;#Comment&quot;&gt;&lt;i&gt;Comment&lt;/i&gt;&lt;/a&gt;s, &lt;a href=&quot;#SpecialTokenSequence&quot;&gt;&lt;i&gt;SpecialTokenSequence&lt;/i&gt;&lt;/a&gt;s, &lt;a href=&quot;#Token&quot;&gt;&lt;i&gt;Token&lt;/i&gt;&lt;/a&gt;s, all followed by &lt;a href=&quot;#EndOfFile&quot;&gt;&lt;i&gt;EndOfFile&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">소스 텍스트는 소스 표현에서 유니 코드 &lt;a href=&quot;#Character&quot;&gt;&lt;i&gt;문자&lt;/i&gt;&lt;/a&gt; 로 디코딩됩니다 . &lt;a href=&quot;#Character&quot;&gt;&lt;i&gt;캐릭터&lt;/i&gt;&lt;/a&gt; : S 추가로 분할된다 &lt;a href=&quot;#WhiteSpace&quot;&gt;&lt;i&gt;공백&lt;/i&gt;&lt;/a&gt; , &lt;a href=&quot;#EndOfLine&quot;&gt;&lt;i&gt;EndOfLine&lt;/i&gt;&lt;/a&gt; , &lt;a href=&quot;#Comment&quot;&gt;&lt;i&gt;코멘트&lt;/i&gt;&lt;/a&gt; 들, &lt;a href=&quot;#SpecialTokenSequence&quot;&gt;&lt;i&gt;SpecialTokenSequence&lt;/i&gt;&lt;/a&gt; S, &lt;a href=&quot;#Token&quot;&gt;&lt;i&gt;토큰&lt;/i&gt;&lt;/a&gt; 모든 이어 S &lt;a href=&quot;#EndOfFile&quot;&gt;&lt;i&gt;EndOfFile&lt;/i&gt;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="80e2eeed7c3f3243964c7d881365f7f9018dc7a1" translate="yes" xml:space="preserve">
          <source>The source text is decoded from its source representation into Unicode &lt;a href=&quot;#Character&quot;&gt;&lt;i&gt;Character&lt;/i&gt;&lt;/a&gt;s. The &lt;a href=&quot;#Character&quot;&gt;&lt;i&gt;Character&lt;/i&gt;&lt;/a&gt;s are further divided into: &lt;a href=&quot;#WhiteSpace&quot;&gt;&lt;i&gt;WhiteSpace&lt;/i&gt;&lt;/a&gt;, &lt;a href=&quot;#EndOfLine&quot;&gt;&lt;i&gt;EndOfLine&lt;/i&gt;&lt;/a&gt;, &lt;a href=&quot;#Comment&quot;&gt;&lt;i&gt;Comment&lt;/i&gt;&lt;/a&gt;s, &lt;a href=&quot;#SpecialTokenSequence&quot;&gt;&lt;i&gt;SpecialTokenSequence&lt;/i&gt;&lt;/a&gt;s, and &lt;a href=&quot;#Token&quot;&gt;&lt;i&gt;Token&lt;/i&gt;&lt;/a&gt;s, with the source terminated by an &lt;a href=&quot;#EndOfFile&quot;&gt;&lt;i&gt;EndOfFile&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">소스 텍스트는 소스 표현에서 Unicode &lt;a href=&quot;#Character&quot;&gt;&lt;i&gt;Character&lt;/i&gt;&lt;/a&gt; 로 디코딩됩니다 . &lt;a href=&quot;#Character&quot;&gt;&lt;i&gt;캐릭터&lt;/i&gt;&lt;/a&gt; : S 추가로 분할된다 &lt;a href=&quot;#WhiteSpace&quot;&gt;&lt;i&gt;공백&lt;/i&gt;&lt;/a&gt; , &lt;a href=&quot;#EndOfLine&quot;&gt;&lt;i&gt;EndOfLine&lt;/i&gt;&lt;/a&gt; , &lt;a href=&quot;#Comment&quot;&gt;&lt;i&gt;코멘트&lt;/i&gt;&lt;/a&gt; 들, &lt;a href=&quot;#SpecialTokenSequence&quot;&gt;&lt;i&gt;SpecialTokenSequence&lt;/i&gt;&lt;/a&gt; S 및 &lt;a href=&quot;#Token&quot;&gt;&lt;i&gt;토큰&lt;/i&gt;&lt;/a&gt; 종료 소스와 S &lt;a href=&quot;#EndOfFile&quot;&gt;&lt;i&gt;EndOfFile&lt;/i&gt;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b3bd371bebb79ced3649c783e9ef8bd79386c89d" translate="yes" xml:space="preserve">
          <source>The source text is split into tokens using the maximal munch algorithm, i.e., the lexical analyzer makes the longest possible token. For example &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; is a right shift token, not two greater than tokens. There are two exceptions to this rule:</source>
          <target state="translated">소스 텍스트는 최대 뭉크 알고리즘을 사용하여 토큰으로 분할됩니다. 즉, 어휘 분석기가 가능한 가장 긴 토큰을 만듭니다. 예를 들어 &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 는 오른쪽 시프트 토큰이며 토큰보다 두 개가 크지 않습니다. 이 규칙에는 두 가지 예외가 있습니다.</target>
        </trans-unit>
        <trans-unit id="21e734d8ecbd4a33f2c2bfd5df8fb1b69390624d" translate="yes" xml:space="preserve">
          <source>The source text is split into tokens using the maximal munch technique, i.e., the lexical analyzer makes the longest token it can. For example &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; is a right shift token, not two greater than tokens. There are two exceptions to this rule:</source>
          <target state="translated">소스 텍스트는 최대 뭉크 기술을 사용하여 토큰으로 분할됩니다. 즉, 어휘 분석기는 가능한 가장 긴 토큰을 만듭니다. 예를 들어 &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 는 토큰보다 2보다 크지 않은 올바른 시프트 토큰입니다. 이 규칙에는 두 가지 예외가 있습니다.</target>
        </trans-unit>
        <trans-unit id="262fd934f3ad11cda48e320770c23b6cbce4d978" translate="yes" xml:space="preserve">
          <source>The source text is terminated by whichever comes first.</source>
          <target state="translated">소스 텍스트는 둘 중 먼저 오는 것으로 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="81738bf1b1d3def6ac2869102bc650c16fdd9cf9" translate="yes" xml:space="preserve">
          <source>The source type in the conversion or comparison</source>
          <target state="translated">변환 또는 비교의 소스 유형</target>
        </trans-unit>
        <trans-unit id="7363cb9e0bea89a84f2ef7322159cb48984847e8" translate="yes" xml:space="preserve">
          <source>The specific &lt;code&gt;LogLevel&lt;/code&gt; used for logging the log message.</source>
          <target state="translated">로그 메시지를 기록하는 데 사용되는 특정 &lt;code&gt;LogLevel&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="02d763555333f9cf77c0541a37bf5b34481db397" translate="yes" xml:space="preserve">
          <source>The specification for the form of embedded documentation comments only specifies how information is to be presented to the compiler. It is implementation-defined how that information is used and the form of the final presentation. Whether the final presentation form is an HTML web page, a man page, a PDF file, etc. is not specified as part of the D Programming Language.</source>
          <target state="translated">임베디드 문서 주석 형태의 스펙은 컴파일러에 정보를 제공하는 방법 만 지정합니다. 정보가 사용되는 방법과 최종 프레젠테이션 형식에 따라 구현 정의됩니다. 최종 프리젠 테이션 양식이 HTML 웹 페이지인지 맨 페이지인지 PDF 파일인지 등은 D 프로그래밍 언어의 일부로 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c631213db2c74550b3a422d0caf42968e12b014d" translate="yes" xml:space="preserve">
          <source>The square root of &lt;code&gt;z&lt;/code&gt;.</source>
          <target state="translated">의 제곱근 &lt;code&gt;z&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2f0df139a9fed00ace05dd03db279a17a8b348a2" translate="yes" xml:space="preserve">
          <source>The squared magnitude of &lt;code&gt;z&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;z&lt;/code&gt; 의 제곱 크기입니다 .</target>
        </trans-unit>
        <trans-unit id="b54a2e145a2a6ad88bd2025575b8d9841ee25294" translate="yes" xml:space="preserve">
          <source>The squared modulus of &lt;code&gt;z&lt;/code&gt;. For genericity, if called on a real number, returns its square.</source>
          <target state="translated">&lt;code&gt;z&lt;/code&gt; 의 제곱 계수입니다 . 일반성을 위해 실수로 호출하면 제곱을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d04cf6152ee5948faeb5107c99bbd4c4ee9e3f00" translate="yes" xml:space="preserve">
          <source>The stack and/or registers are being scanned.</source>
          <target state="translated">스택 및 / 또는 레지스터를 스캔 중입니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
