<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="d">
    <body>
      <group id="d">
        <trans-unit id="cb1503c554d562fcb4fdd362460ca0e88facc2f1" translate="yes" xml:space="preserve">
          <source>Get as a tuple the types of the fields of a struct, class, or union. This consists of the fields that take up memory space, excluding the hidden fields like the virtual function table pointer or a context pointer for nested types. If &lt;code&gt;T&lt;/code&gt; isn't a struct, class, or union returns a tuple with one element &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">구조체, 클래스 또는 공용체의 필드 유형을 튜플로 가져옵니다. 이것은 가상 함수 테이블 포인터 또는 중첩 유형에 대한 컨텍스트 포인터와 같은 숨겨진 필드를 제외하고 메모리 공간을 차지하는 필드로 구성됩니다. &lt;code&gt;T&lt;/code&gt; 가 구조체, 클래스 또는 공용체가 아닌 경우 하나의 요소 &lt;code&gt;T&lt;/code&gt; 가있는 튜플을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="8352810d8951fe7d425bf1322ba1521329088590" translate="yes" xml:space="preserve">
          <source>Get as an expression tuple the names of the fields of a struct, class, or union. This consists of the fields that take up memory space, excluding the hidden fields like the virtual function table pointer or a context pointer for nested types. Inherited fields (for classes) are not included. If &lt;code&gt;T&lt;/code&gt; isn't a struct, class, or union, an expression tuple with an empty string is returned.</source>
          <target state="translated">구조체, 클래스 또는 공용체의 필드 이름을 튜플로 표현하십시오. 이것은 가상 함수 테이블 포인터 또는 중첩 유형에 대한 컨텍스트 포인터와 같은 숨겨진 필드를 제외하고 메모리 공간을 차지하는 필드로 구성됩니다. 상속 된 필드 (클래스 용)는 포함되지 않습니다. &lt;code&gt;T&lt;/code&gt; 가 구조체, 클래스 또는 공용체가 아닌 경우 빈 문자열이있는 표현식 튜플이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="a198ff5da76a4a9aab19b26589c9b2c10f34f479" translate="yes" xml:space="preserve">
          <source>Get creation/access/modified times of file &lt;code&gt;name&lt;/code&gt;.</source>
          <target state="translated">파일 &lt;code&gt;name&lt;/code&gt; 의 생성 / 액세스 / 수정 된 시간을 가져 옵니다 .</target>
        </trans-unit>
        <trans-unit id="691bafc770aff46bbe0856f713e81a3d1edbf405" translate="yes" xml:space="preserve">
          <source>Get flags for type: 1 means GC should scan for pointers, 2 means arg of this type is passed in SIMD register(s) if available</source>
          <target state="translated">유형에 대한 플래그 가져 오기 : 1은 GC가 포인터를 스캔해야 함을 의미하고, 2는이 유형의 arg가 가능한 경우 SIMD 레지스터에 전달됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="d0005ffe3affeeb682da9580156ed97b001d178e" translate="yes" xml:space="preserve">
          <source>Get flags for type: 1 means GC should scan for pointers, 2 means arg of this type is passed in XMM register</source>
          <target state="translated">유형에 대한 플래그 가져 오기 : 1은 GC가 포인터를 스캔해야 함을 의미하고 2는이 유형의 arg가 XMM 레지스터에 전달됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="d67dceb8ecd32907f4c80efef5b62cf3e873c8e4" translate="yes" xml:space="preserve">
          <source>Get index of field. Returns -1 if not found.</source>
          <target state="translated">필드 인덱스를 가져옵니다. 찾지 못하면 -1을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7cbd98494450e74ae712eba7afdee4e2a97eaec8" translate="yes" xml:space="preserve">
          <source>Get nth Parameter, folding in tuples.</source>
          <target state="translated">튜플로 접는 n 번째 매개 변수를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="b0d99cd151ddfeaf2b13f0d9a95c891f89fbb223" translate="yes" xml:space="preserve">
          <source>Get offset of base class's vtbl[] initializer from start of csym. Returns ~0 if not this csym.</source>
          <target state="translated">csym 시작에서 기본 클래스의 vtbl [] 이니셜 라이저 오프셋을 가져옵니다. 이 csym이 아닌 경우 ~ 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="188a425106e789190ec847f6a6792e93a54341a7" translate="yes" xml:space="preserve">
          <source>Get or set compression method used for this member.</source>
          <target state="translated">이 멤버에 사용되는 압축 방법을 가져 오거나 설정합니다.</target>
        </trans-unit>
        <trans-unit id="2ee99e17347439a45b11edd2de3c4f3e29784dd4" translate="yes" xml:space="preserve">
          <source>Get or set data of member in uncompressed form. When an existing archive is read &lt;code&gt;ZipArchive.expand&lt;/code&gt; needs to be called before this can be accessed.</source>
          <target state="translated">압축되지 않은 형태로 멤버의 데이터를 가져 오거나 설정합니다. 기존 아카이브를 읽을 때 &lt;code&gt;ZipArchive.expand&lt;/code&gt; 를 호출해야 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c7d46f4532c87d8a4e544df5791739440cc36ce" translate="yes" xml:space="preserve">
          <source>Get or set the OS specific file attributes for this archive member.</source>
          <target state="translated">이 아카이브 멤버에 대한 OS 특정 파일 속성을 가져 오거나 설정합니다.</target>
        </trans-unit>
        <trans-unit id="1296d6fdc83b6b554050c4b4aa7fef3699ac90e1" translate="yes" xml:space="preserve">
          <source>Get or set the last modification time for this member.</source>
          <target state="translated">이 멤버의 마지막 수정 시간을 가져 오거나 설정합니다.</target>
        </trans-unit>
        <trans-unit id="a4feb1bf141a1d88be78b9a3366a4467fa93a965" translate="yes" xml:space="preserve">
          <source>Get range that spans all of the &lt;a href=&quot;#Code%20point&quot;&gt;code point&lt;/a&gt; intervals in this &lt;a href=&quot;#InversionList&quot;&gt;&lt;code&gt;InversionList&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 &lt;a href=&quot;#InversionList&quot;&gt; &lt;code&gt;InversionList&lt;/code&gt; 의&lt;/a&gt; 모든 &lt;a href=&quot;#Code%20point&quot;&gt;코드 포인트&lt;/a&gt; 간격에 걸쳐있는 범위를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="f03d5bd32538b64243f7cd6441ecfa2b2622dbab" translate="yes" xml:space="preserve">
          <source>Get size of file &lt;code&gt;name&lt;/code&gt; in bytes.</source>
          <target state="translated">파일 &lt;code&gt;name&lt;/code&gt; 크기를 바이트 단위로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="461490b8f32608cfbfd66725579129263619bc8c" translate="yes" xml:space="preserve">
          <source>Get size of ty</source>
          <target state="translated">타이의 크기를 얻으십시오</target>
        </trans-unit>
        <trans-unit id="be155f80e71c94e749bac3dc7da0073ca4565577" translate="yes" xml:space="preserve">
          <source>Get targetInfo by key</source>
          <target state="translated">키로 targetInfo 가져 오기</target>
        </trans-unit>
        <trans-unit id="73796f5728cf9c28582274f26067b749361695c9" translate="yes" xml:space="preserve">
          <source>Get the Key type of an Associative Array.</source>
          <target state="translated">연관 배열의 키 유형을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="d22a099130780c3f0f5de0e5b8d691ed79199316" translate="yes" xml:space="preserve">
          <source>Get the OS specific file attributes for the archive member.</source>
          <target state="translated">아카이브 멤버의 OS 특정 파일 속성을 가져 오십시오.</target>
        </trans-unit>
        <trans-unit id="79ecfb6529a74964e1e68cd5ab4d563b90f3da7a" translate="yes" xml:space="preserve">
          <source>Get the Value type of an Associative Array.</source>
          <target state="translated">연관 배열의 값 유형을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="98635513b7474e13e846f5ff833241b41e74887e" translate="yes" xml:space="preserve">
          <source>Get the access and modified times of file or folder &lt;code&gt;name&lt;/code&gt;.</source>
          <target state="translated">파일 또는 폴더 &lt;code&gt;name&lt;/code&gt; 의 액세스 및 수정 시간을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="5e205b38d81166876ff783947529f334bd179d77" translate="yes" xml:space="preserve">
          <source>Get the cached block info of an interior pointer. Returns null if the interior pointer's block is not cached.</source>
          <target state="translated">내부 포인터의 캐시 된 블록 정보를 가져옵니다. 내부 포인터의 블록이 캐시되지 않은 경우 null을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4282bb82ffa1bb1dd9a0f9f0f2bf4c8c171f011b" translate="yes" xml:space="preserve">
          <source>Get the code unit at index i</source>
          <target state="translated">인덱스 i에서 코드 단위 가져 오기</target>
        </trans-unit>
        <trans-unit id="7c3dd3625eabe5a78ecd2dfc079c83bf66c607d8" translate="yes" xml:space="preserve">
          <source>Get the current thread's instance. Returns by ref. Note that calling &lt;code&gt;get&lt;/code&gt; from any thread outside the &lt;code&gt;TaskPool&lt;/code&gt; that created this instance will return the same reference, so an instance of worker-local storage should only be accessed from one thread outside the pool that created it. If this rule is violated, undefined behavior will result.</source>
          <target state="translated">현재 스레드의 인스턴스를 가져옵니다. 심판에 의해 반환합니다. 이 인스턴스를 만든 &lt;code&gt;TaskPool&lt;/code&gt; 외부의 스레드에서 &lt;code&gt;get&lt;/code&gt; 을 호출 하면 동일한 참조가 반환되므로 작업자 로컬 저장소의 인스턴스는 해당 인스턴스를 만든 풀 외부의 한 스레드에서만 액세스해야합니다. 이 규칙을 위반하면 정의되지 않은 동작이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2fa40eed5d4831ba4894fa0d2f99824123d18451" translate="yes" xml:space="preserve">
          <source>Get the current time as a &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; 으로 현재 시간 가져 오기</target>
        </trans-unit>
        <trans-unit id="f8dce800f00dab2a31ba905f4b229d5e41f026c6" translate="yes" xml:space="preserve">
          <source>Get the current time from the system clock</source>
          <target state="translated">시스템 시계에서 현재 시간을 가져옵니다</target>
        </trans-unit>
        <trans-unit id="7d101e5841a77867eef23ee238263d38f724a6f3" translate="yes" xml:space="preserve">
          <source>Get the current working directory.</source>
          <target state="translated">현재 작업 디렉토리를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="b3b0d480375a5d6d1deedae54218ae4809699a35" translate="yes" xml:space="preserve">
          <source>Get the default &lt;code&gt;Throwable.TraceInfo&lt;/code&gt; implementation for the platform</source>
          <target state="translated">플랫폼에 대한 기본 &lt;code&gt;Throwable.TraceInfo&lt;/code&gt; 구현을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="1a4ef6fd99cfc2a1e29f50c6d9ba5ed116754be8" translate="yes" xml:space="preserve">
          <source>Get the drive portion of a path.</source>
          <target state="translated">경로의 드라이브 부분을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="c1d426ae9f2d48f1089e0e4fbe50dd7b4c9abc89" translate="yes" xml:space="preserve">
          <source>Get the first argument &lt;code&gt;a&lt;/code&gt; that passes an &lt;code&gt;if (unaryFun!pred(a))&lt;/code&gt; test. If no argument passes the test, return the last argument.</source>
          <target state="translated">&lt;code&gt;if (unaryFun!pred(a))&lt;/code&gt; 테스트 를 통과 한 첫 번째 인수 &lt;code&gt;a&lt;/code&gt; 를 가져옵니다 . 인수가 테스트를 통과하지 못하면 마지막 인수를 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="71fd3b068f374669047aed8f9838bd5650f74328" translate="yes" xml:space="preserve">
          <source>Get the full package name for the given symbol.</source>
          <target state="translated">주어진 기호에 대한 전체 패키지 이름을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="e88db6759fbbcb530d5bab26ba3ec77a124f346e" translate="yes" xml:space="preserve">
          <source>Get the fully qualified name of a type or a symbol. Can act as an intelligent type/symbol to string converter.</source>
          <target state="translated">형식이나 기호의 정규화 된 이름을 가져옵니다. 지능형 유형 / 기호-문자열 변환기로 작동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e02735fcab968c6e59f5f8bdf04603517f7d65eb" translate="yes" xml:space="preserve">
          <source>Get the function type from a callable object &lt;code&gt;func&lt;/code&gt;.</source>
          <target state="translated">호출 가능한 객체 &lt;code&gt;func&lt;/code&gt; 에서 함수 유형을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="0126813350919cfa23ae233f4d4ec97faf37d1f5" translate="yes" xml:space="preserve">
          <source>Get the last modification time for this member.</source>
          <target state="translated">이 멤버의 마지막 수정 시간을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="2b55b05c55c5a5fab2ff26e964d410c035b4ab1b" translate="yes" xml:space="preserve">
          <source>Get the linger option.</source>
          <target state="translated">느린 옵션을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="2731449c54e0db2efeec9062c6ec93a54eb72587" translate="yes" xml:space="preserve">
          <source>Get the message describing the error. Base behavior is to return the &lt;code&gt;Throwable.msg&lt;/code&gt; field. Override to return some other error message.</source>
          <target state="translated">오류를 설명하는 메시지를 받으십시오. 기본 동작은 &lt;code&gt;Throwable.msg&lt;/code&gt; 필드 를 반환하는 것 입니다. 다른 오류 메시지를 반환하도록 재정의하십시오.</target>
        </trans-unit>
        <trans-unit id="4b21108b2b9de9b6cbf7e566c0a2ddc0c0ca72f0" translate="yes" xml:space="preserve">
          <source>Get the module name (including package) for the given symbol.</source>
          <target state="translated">주어진 기호에 대한 모듈 이름 (패키지 포함)을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="3288e20d4e0a2e8cea872e1f5d70b8c2b93389f8" translate="yes" xml:space="preserve">
          <source>Get the primitive types of the fields of a struct or class, in topological order.</source>
          <target state="translated">구조체 또는 클래스 필드의 기본 유형을 토폴로지 순서대로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="3543b05579b2dbf35e3b0cd1e4b2b942a6076e5c" translate="yes" xml:space="preserve">
          <source>Get the size of the file, ulong.max if file is not searchable, but still throws if an actual error occurs.</source>
          <target state="translated">파일의 크기를 가져옵니다. 파일을 검색 할 수없는 경우 ulong.max이지만 실제 오류가 발생하면 계속 발생합니다.</target>
        </trans-unit>
        <trans-unit id="79a49f491dcc81c94695a311e67110f25317cf05" translate="yes" xml:space="preserve">
          <source>Get the socket's address family.</source>
          <target state="translated">소켓의 주소 패밀리를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="4e5a697008886f18598415a18e551017ef50a8a2" translate="yes" xml:space="preserve">
          <source>Get the the default initialization expression for a type.</source>
          <target state="translated">형식의 기본 초기화 식을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="ebb8fbb5373a6b9ecc71521fb5c82104b76b2dda" translate="yes" xml:space="preserve">
          <source>Get the type of the return value from a function, a pointer to function, a delegate, a struct with an opCall, a pointer to a struct with an opCall, or a class with an &lt;code&gt;opCall&lt;/code&gt;. Please note that ref is not part of a type, but the attribute of the function (see template &lt;a href=&quot;#functionAttributes&quot;&gt;&lt;code&gt;functionAttributes&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">함수의 반환 값의 유형, 함수에 대한 포인터, 대리인, opCall, opCall, 또는있는 클래스와 구조체에 대한 포인터와 구조체 가져 &lt;code&gt;opCall&lt;/code&gt; 을 . 그 심판 유형의 일부가 아닌 참고하지만, 함수의 속성 (템플릿 참조하십시오 &lt;a href=&quot;#functionAttributes&quot;&gt; &lt;code&gt;functionAttributes&lt;/code&gt; 을&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="2f15e792b4182f5761446203a960686f6a1fd8cb" translate="yes" xml:space="preserve">
          <source>Get the type that a scalar type &lt;code&gt;T&lt;/code&gt; will &lt;a href=&quot;https://dlang.org/spec/type.html#integer-promotions&quot;&gt;promote&lt;/a&gt; to in multi-term arithmetic expressions.</source>
          <target state="translated">다항 산술 식에서 스칼라 형식 &lt;code&gt;T&lt;/code&gt; 가 &lt;a href=&quot;https://dlang.org/spec/type.html#integer-promotions&quot;&gt;승격시킬&lt;/a&gt; 형식을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="d86851901246015e180e22d937a94cdd4a67d0cf" translate="yes" xml:space="preserve">
          <source>Get the type that all types can be implicitly converted to. Useful e.g. in figuring out an array type from a bunch of initializing values. Returns void if passed an empty list, or if the types have no common type.</source>
          <target state="translated">모든 유형을 암시 적으로 변환 할 수있는 유형을 가져옵니다. 많은 초기화 값에서 배열 유형을 알아내는 데 유용합니다. 빈 목록을 전달했거나 형식에 공통 형식이없는 경우 void를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d8834c0e5c45f02dee115c0af5916029dd3645eb" translate="yes" xml:space="preserve">
          <source>Get the type that will really be used for passing the given argument to an &lt;code&gt;extern(C++)&lt;/code&gt; function.</source>
          <target state="translated">주어진 인수를 &lt;code&gt;extern(C++)&lt;/code&gt; 함수 에 전달하는 데 실제로 사용될 유형을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="1a8db062181587e0a37ac18deba2e6a2d99a21b8" translate="yes" xml:space="preserve">
          <source>Get the underlying path.</source>
          <target state="translated">기본 경로를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="8aa89601daef2aac5d5712f9ccfde65d17aeb883" translate="yes" xml:space="preserve">
          <source>Get the underlying type which a &lt;code&gt;Typedef&lt;/code&gt; wraps. If &lt;code&gt;T&lt;/code&gt; is not a &lt;code&gt;Typedef&lt;/code&gt; it will alias itself to &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Typedef&lt;/code&gt; 가 랩핑 하는 기본 유형을 가져옵니다 . 경우 &lt;code&gt;T&lt;/code&gt; 는 하지 않은 것입니다 &lt;code&gt;Typedef&lt;/code&gt; 는 자체의 별명합니다 &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bc66c2f8e24da37f6181d5e17247039b03831383" translate="yes" xml:space="preserve">
          <source>Get the value of the .max/.min property as an Expression. Lazily computes the value and caches it in maxval/minval. Reports any errors.</source>
          <target state="translated">.max / .min 속성 값을 Expression으로 가져옵니다. Lazily는 값을 계산하고 maxval / minval로 캐시합니다. 오류를보고합니다.</target>
        </trans-unit>
        <trans-unit id="bb25c1e8984031c906b57204ab00dc5ad735d012" translate="yes" xml:space="preserve">
          <source>Get the various timings like name lookup time, total time, connect time etc. The timed category is passed through the timing parameter while the timing value is stored at val. The value is usable only if res is equal to &lt;code&gt;etc.c.curl.CurlError.ok&lt;/code&gt;.</source>
          <target state="translated">이름 조회 시간, 총 시간, 연결 시간 등과 같은 다양한 타이밍을 가져옵니다. 타이밍 값이 val에 저장되는 동안 타이밍 범주가 타이밍 매개 변수를 통과합니다. res가 &lt;code&gt;etc.c.curl.CurlError.ok&lt;/code&gt; 와 같은 경우에만 값을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="912a474bb0a0204ed6b0e20848237a640087bf6c" translate="yes" xml:space="preserve">
          <source>Get tuple, one per function parameter, of the storage classes of the parameters.</source>
          <target state="translated">매개 변수의 스토리지 클래스에 대해 함수 매개 변수 당 하나씩 튜플을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="36c705a4549f55994270c31cf59dc15c22af56b1" translate="yes" xml:space="preserve">
          <source>Get type information on the contents of the type; null if not available</source>
          <target state="translated">유형의 내용에 대한 유형 정보를 가져옵니다. 사용할 수없는 경우는 null</target>
        </trans-unit>
        <trans-unit id="96f72b00f8ed83794b8d1d1ca2272471a19aedec" translate="yes" xml:space="preserve">
          <source>Get underlying socket handle.</source>
          <target state="translated">기본 소켓 핸들을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="48ec336cb3c23da76d213eaa7aef8a04ca5f0b14" translate="yes" xml:space="preserve">
          <source>Get various timings defined in &lt;a href=&quot;etc_c_curl#CurlInfo&quot;&gt;&lt;code&gt;etc.c.curl.CurlInfo&lt;/code&gt;&lt;/a&gt;. The value is usable only if the return value is equal to &lt;code&gt;etc.c.curl.CurlError.ok&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;etc_c_curl#CurlInfo&quot;&gt; &lt;code&gt;etc.c.curl.CurlInfo&lt;/code&gt; 에&lt;/a&gt; 정의 된 다양한 타이밍을 가져옵니다 . 반환 값이 &lt;code&gt;etc.c.curl.CurlError.ok&lt;/code&gt; 와 같은 경우에만 값을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="efecd1a1ec18ed172626c58e06a872720a3ea949" translate="yes" xml:space="preserve">
          <source>Get with custom data receivers:</source>
          <target state="translated">사용자 지정 데이터 수신기로 가져 오기 :</target>
        </trans-unit>
        <trans-unit id="bb969faa69556a50edb8b7474adfcb5288a0eabc" translate="yes" xml:space="preserve">
          <source>Get, as a tuple, the default value of the parameters to a function symbol. If a parameter doesn't have the default value, &lt;code&gt;void&lt;/code&gt; is returned instead.</source>
          <target state="translated">매개 변수의 기본값을 함수 기호로 튜플로 가져옵니다. 매개 변수에 기본값이 없으면 &lt;code&gt;void&lt;/code&gt; 가 대신 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="6e5eb1b88f56e22db495838fb23d06aff7902858" translate="yes" xml:space="preserve">
          <source>Get, as a tuple, the identifiers of the parameters to a function symbol.</source>
          <target state="translated">함수 식별자에 매개 변수의 식별자를 튜플로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="0d9be8cea698e918f8f5553c38491cc55f980684" translate="yes" xml:space="preserve">
          <source>Get, as a tuple, the types of the parameters to a function, a pointer to function, a delegate, a struct with an &lt;code&gt;opCall&lt;/code&gt;, a pointer to a struct with an &lt;code&gt;opCall&lt;/code&gt;, or a class with an &lt;code&gt;opCall&lt;/code&gt;.</source>
          <target state="translated">튜플로서 함수에 대한 매개 변수 유형, 함수에 대한 포인터, 대리자, &lt;code&gt;opCall&lt;/code&gt; 이있는 구조체, &lt;code&gt;opCall&lt;/code&gt; 이있는 구조체에 대한 포인터 또는 opCall이 있는 클래스를 &lt;code&gt;opCall&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4a2a322d7843413da4411904750627b588381236" translate="yes" xml:space="preserve">
          <source>Get/set number of elements in the array. It is of type &lt;code&gt;size_t&lt;/code&gt;.</source>
          <target state="translated">배열의 요소 수를 가져 오거나 설정합니다. &lt;code&gt;size_t&lt;/code&gt; 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="e903dced1589591dccd55f4a2a573704d37b25f7" translate="yes" xml:space="preserve">
          <source>Get/set socket's blocking flag.</source>
          <target state="translated">소켓의 블로킹 플래그를 가져 오거나 설정합니다.</target>
        </trans-unit>
        <trans-unit id="8143cfad11bbcb508b2faa890c629adbe90a1326" translate="yes" xml:space="preserve">
          <source>GetoptResult &lt;strong id=&quot;getopt&quot;&gt;getopt&lt;/strong&gt;(T...)(ref string[] args, T opts);</source>
          <target state="translated">GetoptResult &lt;strong id=&quot;getopt&quot;&gt;getopt&lt;/strong&gt; (T ...) (참조 문자열 [] args, T opts);</target>
        </trans-unit>
        <trans-unit id="3639898092fae686744daf985b5a5af78426e672" translate="yes" xml:space="preserve">
          <source>Gets a &lt;a href=&quot;#Code%20point&quot;&gt;code point&lt;/a&gt; at the given index in this cluster.</source>
          <target state="translated">이 클러스터의 지정된 인덱스에서 &lt;a href=&quot;#Code%20point&quot;&gt;코드 포인트&lt;/a&gt; 를 가져 옵니다.</target>
        </trans-unit>
        <trans-unit id="3b7dd24ad864c772981b0d66dc0022feced1b999" translate="yes" xml:space="preserve">
          <source>Gets a larger buffer &lt;code&gt;buf&lt;/code&gt; by calling &lt;code&gt;parent.allocate(goodAllocSize(n))&lt;/code&gt;. If &lt;code&gt;buf&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, returns &lt;code&gt;null&lt;/code&gt;. Otherwise, returns &lt;code&gt;buf[0 .. n]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;parent.allocate(goodAllocSize(n))&lt;/code&gt; 을 호출 하여 더 큰 버퍼 &lt;code&gt;buf&lt;/code&gt; 를 가져 옵니다 . &lt;code&gt;buf&lt;/code&gt; 가 &lt;code&gt;null&lt;/code&gt; 의 경우 는 null 를 돌려 &lt;code&gt;null&lt;/code&gt; . 그렇지 않으면 &lt;code&gt;buf[0 .. n]&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="b2c0f14712193b76cf9f29f4a2238a646ef9482c" translate="yes" xml:space="preserve">
          <source>Gets a range of key/values for &lt;code&gt;aa&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;aa&lt;/code&gt; 의 키 / 값 범위를 가져 옵니다 .</target>
        </trans-unit>
        <trans-unit id="0f00eae4c2ff9337f7291213da97c9dc6aebf8d8" translate="yes" xml:space="preserve">
          <source>Gets a thread-local instance of ThreadInfo, which should be used as the default instance when info is requested for a thread not created by the Scheduler.</source>
          <target state="translated">스케줄러가 작성하지 않은 스레드에 대한 정보가 요청 될 때 기본 인스턴스로 사용해야하는 ThreadInfo의 스레드 로컬 인스턴스를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="f6f18bccfb576e34d7b5fa60615448449996ea12" translate="yes" xml:space="preserve">
          <source>Gets a thread-local instance of ThreadInfo.</source>
          <target state="translated">ThreadInfo의 스레드 로컬 인스턴스를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="b472fcab365d2a6ba9fdba822432b62db948d127" translate="yes" xml:space="preserve">
          <source>Gets an object representing the reader lock for the associated mutex.</source>
          <target state="translated">연결된 뮤텍스의 판독기 잠금을 나타내는 개체를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="2bad6a1697863b959c51608194a08c6aaf894ca4" translate="yes" xml:space="preserve">
          <source>Gets an object representing the writer lock for the associated mutex.</source>
          <target state="translated">연결된 뮤텍스의 작성기 잠금을 나타내는 개체를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="c2134c8e8821e26937fe2aedd4aa0e2891a164f8" translate="yes" xml:space="preserve">
          <source>Gets called on program shutdown just after GC is terminated.</source>
          <target state="translated">GC가 종료 된 직후 프로그램 종료시 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="3863a33d5ec162d09008cccc833b8dbca9f1864e" translate="yes" xml:space="preserve">
          <source>Gets called on program startup just before GC is initialized.</source>
          <target state="translated">GC가 초기화되기 직전에 프로그램 시작시 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="fdc75e27ba04f67b552a395ef0dbfb72c8501519" translate="yes" xml:space="preserve">
          <source>Gets expression at offset of type. Returns NULL if not found.</source>
          <target state="translated">형식의 오프셋에서 식을 가져옵니다. 찾을 수 없으면 NULL을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="cc94d4edefc014f546538ff3e9cb05bec4999447" translate="yes" xml:space="preserve">
          <source>Gets the &lt;code&gt;i&lt;/code&gt;'th bit in the &lt;code&gt;BitArray&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;BitArray&lt;/code&gt; 에서 &lt;code&gt;i&lt;/code&gt; 번째 비트를 가져 옵니다 .</target>
        </trans-unit>
        <trans-unit id="8011563ddbd748ff521930918dc8bcb499b269a2" translate="yes" xml:space="preserve">
          <source>Gets the OS identifier for this thread.</source>
          <target state="translated">이 스레드의 OS 식별자를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="685489f583759f962fe7c1daab0034a07cb9d516" translate="yes" xml:space="preserve">
          <source>Gets the Tid associated with name.</source>
          <target state="translated">이름과 관련된 Tid를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="5c6e15b07949cc6ff89428732b9e3b99b89bcdc8" translate="yes" xml:space="preserve">
          <source>Gets the current collect handler.</source>
          <target state="translated">현재 수집 처리기를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="4ee9c2ec9df011130e3394bc652f9b3e7978ed43" translate="yes" xml:space="preserve">
          <source>Gets the current legacy module unit tester.</source>
          <target state="translated">현재 레거시 모듈 장치 테스터를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="b9fd850a635cce1ec806814a7cb5c442887ef8c8" translate="yes" xml:space="preserve">
          <source>Gets the current module unit tester.</source>
          <target state="translated">현재 모듈 단위 테스터를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="e72b94a5c6c1c6b67ed9a2ba11a48dec6fb51fea" translate="yes" xml:space="preserve">
          <source>Gets the current state of this fiber.</source>
          <target state="translated">이 파이버의 현재 상태를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="86b54a37d38df76c69490341ad477a651e752312" translate="yes" xml:space="preserve">
          <source>Gets the current trace handler.</source>
          <target state="translated">현재 추적 핸들러를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="48b50302326e46ace0f0f71974024ade98c4d812" translate="yes" xml:space="preserve">
          <source>Gets the daemon status for this thread. While the runtime will wait for all normal threads to complete before tearing down the process, daemon threads are effectively ignored and thus will not prevent the process from terminating. In effect, daemon threads will be terminated automatically by the OS when the process exits.</source>
          <target state="translated">이 스레드의 데몬 상태를 가져옵니다. 런타임은 프로세스를 해제하기 전에 모든 일반 스레드가 완료되기를 기다리는 동안 데몬 스레드는 효과적으로 무시되므로 프로세스가 종료되지 않습니다. 실제로 데몬 스레드는 프로세스가 종료 될 때 OS에 의해 자동으로 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="6388b81675e677f57fc44bb674c4998dc61bbf09" translate="yes" xml:space="preserve">
          <source>Gets the index of the current thread relative to this &lt;code&gt;TaskPool&lt;/code&gt;. Any thread not in this pool will receive an index of 0. The worker threads in this pool receive unique indices of 1 through &lt;code&gt;this.size&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;TaskPool&lt;/code&gt; 에 상대적인 현재 스레드의 인덱스를 가져옵니다 . 이 풀에없는 스레드는 인덱스 0을 &lt;code&gt;this.size&lt;/code&gt; . 이 풀의 작업자 스레드는 1부터 this.size 까지의 고유 인덱스를 받습니다 .</target>
        </trans-unit>
        <trans-unit id="397d4288bd9f56373ed42093b36baf0cf34c80d4" translate="yes" xml:space="preserve">
          <source>Gets the matching &lt;a href=&quot;https://dlang.org/spec/attribute.html#uda&quot;&gt;user-defined attributes&lt;/a&gt; from the given symbol.</source>
          <target state="translated">주어진 기호에서 일치하는 &lt;a href=&quot;https://dlang.org/spec/attribute.html#uda&quot;&gt;사용자 정의 속성&lt;/a&gt; 을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="ff4bb9618e0f172c3deb93f3fe4c73732cb67c80" translate="yes" xml:space="preserve">
          <source>Gets the mutex associated with this condition.</source>
          <target state="translated">이 조건과 관련된 뮤텍스를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="b1cafc8d1ad4c93a1519578fd6ef07cfbae8c0d4" translate="yes" xml:space="preserve">
          <source>Gets the nth number in the underlying representation that makes up the whole &lt;code&gt;BigInt&lt;/code&gt;.</source>
          <target state="translated">전체 &lt;code&gt;BigInt&lt;/code&gt; 를 구성하는 기본 표현에서 n 번째 숫자를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="801e40683c25723cacc6326aca38101be95c4627" translate="yes" xml:space="preserve">
          <source>Gets the policy used by this mutex.</source>
          <target state="translated">이 뮤텍스가 사용하는 정책을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="8aba27c226485427875db239e8c2e09071484ea6" translate="yes" xml:space="preserve">
          <source>Gets the scheduling priority for the associated thread.</source>
          <target state="translated">연결된 스레드의 예약 우선 순위를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="cf58bd5c03eda3fe4cc7594124c4b61e9c109dc9" translate="yes" xml:space="preserve">
          <source>Gets the type of the &lt;code&gt;TypeInfo&lt;/code&gt; object associated with &lt;code&gt;t&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;t&lt;/code&gt; 와 관련된 &lt;code&gt;TypeInfo&lt;/code&gt; 개체 의 형식을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="9211b2fb8e24a472f1780790cfdc50455081852e" translate="yes" xml:space="preserve">
          <source>Gets the user-readable label for this thread.</source>
          <target state="translated">이 스레드에 대한 사용자가 읽을 수있는 레이블을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="611d2080794dfc9ee82363d9d9da4aa9a138b19f" translate="yes" xml:space="preserve">
          <source>Gets the value if not null. If &lt;code&gt;this&lt;/code&gt; is in the null state, and the optional parameter &lt;code&gt;fallback&lt;/code&gt; was provided, it will be returned. Without &lt;code&gt;fallback&lt;/code&gt;, calling &lt;code&gt;get&lt;/code&gt; with a null state is invalid.</source>
          <target state="translated">null이 아닌 경우는 값을 가져옵니다. 경우 &lt;code&gt;this&lt;/code&gt; 널 상태이며, 선택적 매개 변수 &lt;code&gt;fallback&lt;/code&gt; 제공되었다, 그것은 반환됩니다. &lt;code&gt;fallback&lt;/code&gt; 이 없으면 null 상태의 &lt;code&gt;get&lt;/code&gt; 호출 이 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7ce43e8e9e8874c455bc1d408b4db63789ae5ade" translate="yes" xml:space="preserve">
          <source>Gets the value. &lt;code&gt;this&lt;/code&gt; must not be in the null state. This function is also called for the implicit conversion to &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">값을 가져옵니다. &lt;code&gt;this&lt;/code&gt; null 상태가 아니어야합니다. 이 함수는 또한 &lt;code&gt;T&lt;/code&gt; 로의 암시 적 변환을 위해 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="27ec2c5053941a53ff7bc20b3630c9aa87b310af" translate="yes" xml:space="preserve">
          <source>Gets vendor-specific type mangling for C++ ABI.</source>
          <target state="translated">C ++ ABI에 대한 공급 업체별 유형 처리를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="7e2612461374b070bc3713b89e3df4f4c33fbf6f" translate="yes" xml:space="preserve">
          <source>Gets/sets assert hander. null means the default handler is used.</source>
          <target state="translated">어설 션 처리기를 가져 오거나 설정합니다. null은 기본 처리기가 사용됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="8a46199cc00d346a1fe72a372a1bcb52b3b1947f" translate="yes" xml:space="preserve">
          <source>Gets/sets the allocator for the current process. This allocator must be used for allocating memory shared across threads. Objects created using this allocator can be cast to &lt;code&gt;shared&lt;/code&gt;.</source>
          <target state="translated">현재 프로세스의 할당자를 가져 오거나 설정합니다. 이 할당자는 스레드간에 공유되는 메모리를 할당하는 데 사용해야합니다. 이 할당자를 사용하여 생성 된 객체는 &lt;code&gt;shared&lt;/code&gt; 로 캐스트 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b3f3fc74fb3ec91a1abfd15e2f2178014ba02b91" translate="yes" xml:space="preserve">
          <source>Gets/sets the allocator for the current thread. This is the default allocator that should be used for allocating thread-local memory. For allocating memory to be shared across threads, use &lt;code&gt;processAllocator&lt;/code&gt; (below). By default, &lt;code&gt;theAllocator&lt;/code&gt; ultimately fetches memory from &lt;code&gt;processAllocator&lt;/code&gt;, which in turn uses the garbage collected heap.</source>
          <target state="translated">현재 스레드의 할당자를 가져 오거나 설정합니다. 스레드 로컬 메모리를 할당하는 데 사용해야하는 기본 할당 자입니다. 스레드간에 메모리가 공유되도록 할당하려면 &lt;code&gt;processAllocator&lt;/code&gt; (아래)를 사용하십시오. 기본적으로 &lt;code&gt;theAllocator&lt;/code&gt; 궁극적으로 가비지 수집 힙을 사용하는 &lt;code&gt;processAllocator&lt;/code&gt; 에서 메모리를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="ce0e5e384b0423d01fbe02461b7f604937af05a9" translate="yes" xml:space="preserve">
          <source>Getting a range of all the named captures in the regex.</source>
          <target state="translated">정규식에서 명명 된 모든 캡처 범위를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="3239f451b140324af46d3a3db896ec8a5a618fbd" translate="yes" xml:space="preserve">
          <source>Getting the benefits of multiple adaptable freelists that do not need to be tuned for one specific size but insted automatically adapts itself to frequently used sizes.</source>
          <target state="translated">하나의 특정 크기로 조정할 필요는 없지만 insted는 자주 사용되는 크기에 자동으로 적응하는 여러 개의 조정 가능한 프리리스트의 이점을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="c7ae27f036579182bace286ba1e0cf636e5ff36f" translate="yes" xml:space="preserve">
          <source>Getting the priority of a thread that already terminated might return the default priority.</source>
          <target state="translated">이미 종료 된 스레드의 우선 순위를 가져 오면 기본 우선 순위를 리턴 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d5546b9dfb555ac771be9469163d9af49686adbe" translate="yes" xml:space="preserve">
          <source>Give error if we're not an lvalue. If we can, convert expression to be an lvalue.</source>
          <target state="translated">lvalue가 아닌 경우 오류를 제공하십시오. 가능하면 expression을 lvalue로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="74474e23aa26985e7a98ca671962a908920e33b2" translate="yes" xml:space="preserve">
          <source>Give up.</source>
          <target state="translated">포기 해</target>
        </trans-unit>
        <trans-unit id="6839d82e03f5268d9a7cc97802db76c48c8cce6e" translate="yes" xml:space="preserve">
          <source>Given</source>
          <target state="translated">Given</target>
        </trans-unit>
        <trans-unit id="545c45c89bb40c5d7b7b442770eb2c94a5c06899" translate="yes" xml:space="preserve">
          <source>Given &lt;code&gt;a == b&lt;/code&gt; :</source>
          <target state="translated">주어진 &lt;code&gt;a == b&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="53726705da0088ae9fbab83c8c50c091febc70d1" translate="yes" xml:space="preserve">
          <source>Given &lt;code&gt;flags&lt;/code&gt; as a combination of &lt;code&gt;AllocFlag&lt;/code&gt; values, or a type &lt;code&gt;T&lt;/code&gt;, returns the allocator that's a closest fit in capabilities.</source>
          <target state="translated">감안할 때 &lt;code&gt;flags&lt;/code&gt; 의 조합으로 &lt;code&gt;AllocFlag&lt;/code&gt; 의 값 또는 유형 &lt;code&gt;T&lt;/code&gt; , 기능에 가장 가까운 적합의 할당자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="62b1bd97df8e740424d65deb5d1e60e2802ffce0" translate="yes" xml:space="preserve">
          <source>Given &lt;code&gt;index&lt;/code&gt; into &lt;code&gt;str&lt;/code&gt; and assuming that &lt;code&gt;index&lt;/code&gt; is at the start of a UTF sequence, &lt;code&gt;toUCSindex&lt;/code&gt; determines the number of UCS characters up to &lt;code&gt;index&lt;/code&gt;. So, &lt;code&gt;index&lt;/code&gt; is the index of a code unit at the beginning of a code point, and the return value is how many code points into the string that that code point is.</source>
          <target state="translated">&lt;code&gt;str&lt;/code&gt; 에 &lt;code&gt;index&lt;/code&gt; 가 주어 지고 &lt;code&gt;index&lt;/code&gt; 가 UTF 시퀀스의 시작에 있다고 가정하면 &lt;code&gt;toUCSindex&lt;/code&gt; 는 &lt;code&gt;index&lt;/code&gt; 까지 UCS 문자 수를 판별합니다 . 따라서 &lt;code&gt;index&lt;/code&gt; 는 코드 포인트의 시작 부분에있는 코드 단위의 인덱스이며 반환 값은 해당 코드 포인트가 문자열에있는 코드 포인트 수입니다.</target>
        </trans-unit>
        <trans-unit id="bb7cf3072f3bd953aeae94de343ed5c6b8a94867" translate="yes" xml:space="preserve">
          <source>Given D code like:</source>
          <target state="translated">주어진 D 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d736ecdf41cd9fce2597d330cc34519b6b941a39" translate="yes" xml:space="preserve">
          <source>Given EBP, find return address to caller, and caller's EBP.</source>
          <target state="translated">EBP가 주어지면 발신자에게 반송 주소와 발신자의 EBP를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="eb6400b34d9067d59b3f43922d46e893c8d36002" translate="yes" xml:space="preserve">
          <source>Given a &lt;code&gt;source&lt;/code&gt; range that is expensive to iterate over, returns an &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; that asynchronously buffers the contents of &lt;code&gt;source&lt;/code&gt; into a buffer of &lt;code&gt;bufSize&lt;/code&gt; elements in a worker thread, while making previously buffered elements from a second buffer, also of size &lt;code&gt;bufSize&lt;/code&gt;, available via the range interface of the returned object. The returned range has a length iff &lt;code&gt;hasLength!S&lt;/code&gt;. &lt;code&gt;asyncBuf&lt;/code&gt; is useful, for example, when performing expensive operations on the elements of ranges that represent data on a disk or network.</source>
          <target state="translated">주어진 &lt;code&gt;source&lt;/code&gt; 반복 비싸다 범위 반환 &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;입력 범위&lt;/a&gt; 비동기의 내용 버퍼 것을 &lt;code&gt;source&lt;/code&gt; 를 버퍼로 &lt;code&gt;bufSize&lt;/code&gt; buf의의 같은 크기의 제 2 버퍼로부터 이전에 버퍼링 엘리먼트하면서, 작업자 스레드 요소 &lt;code&gt;bufSize&lt;/code&gt; buf의를 통해 사용할 반환 된 객체의 범위 인터페이스 반환 된 범위의 길이는 iff &lt;code&gt;hasLength!S&lt;/code&gt; 입니다. &lt;code&gt;asyncBuf&lt;/code&gt; 는 예를 들어 디스크 또는 네트워크의 데이터를 나타내는 범위의 요소에 대해 비싼 작업을 수행 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="699c74248abd14b4250ad690ede845e5aad24631" translate="yes" xml:space="preserve">
          <source>Given a Base64 encoded string, calculates the length of the decoded string.</source>
          <target state="translated">Base64로 인코딩 된 문자열이 제공되면 디코딩 된 문자열의 길이를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="bc7d61e132762100a6e8861609dacf0581eebca4" translate="yes" xml:space="preserve">
          <source>Given a C++ function in a C++ source file:</source>
          <target state="translated">C ++ 소스 파일에 C ++ 함수가 제공된 경우 :</target>
        </trans-unit>
        <trans-unit id="7de884353daa1d02f969775316b89c9805864eba" translate="yes" xml:space="preserve">
          <source>Given a UCS index &lt;code&gt;n&lt;/code&gt; into &lt;code&gt;str&lt;/code&gt;, returns the UTF index. So, &lt;code&gt;n&lt;/code&gt; is how many code points into the string the code point is, and the array index of the code unit is returned.</source>
          <target state="translated">UCS 인덱스 감안할 때 &lt;code&gt;n&lt;/code&gt; 에 &lt;code&gt;str&lt;/code&gt; 의 UTF 인덱스를 돌려줍니다. 따라서 &lt;code&gt;n&lt;/code&gt; 은 코드 포인트가있는 문자열의 코드 포인트 수이며 코드 단위의 배열 인덱스가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="3aa76f9d8ead49fe4c4634dcc93f9d715d5abf9c" translate="yes" xml:space="preserve">
          <source>Given a and p, the function finds x such that</source>
          <target state="translated">a와 p가 주어지면 함수는 x를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="97696594fbe0457c99be87ef93b37c947e4a5703" translate="yes" xml:space="preserve">
          <source>Given a callable object &lt;code&gt;next&lt;/code&gt; that writes to a user-provided buffer and a second callable object &lt;code&gt;empty&lt;/code&gt; that determines whether more data is available to write via &lt;code&gt;next&lt;/code&gt;, returns an input range that asynchronously calls &lt;code&gt;next&lt;/code&gt; with a set of size &lt;code&gt;nBuffers&lt;/code&gt; of buffers and makes the results available in the order they were obtained via the input range interface of the returned object. Similarly to the input range overload of &lt;code&gt;asyncBuf&lt;/code&gt;, the first half of the buffers are made available via the range interface while the second half are filled and vice-versa.</source>
          <target state="translated">호출 가능한 객체 주어 &lt;code&gt;next&lt;/code&gt; 사용자 제공 버퍼 및 제 호출 객체 쓴다 &lt;code&gt;empty&lt;/code&gt; 즉 통해 기록에 사용할 수 많은 데이터의 여부를 판정 &lt;code&gt;next&lt;/code&gt; 비동기 호출하는 입력 범위 리턴 &lt;code&gt;next&lt;/code&gt; 크기의 세트와 &lt;code&gt;nBuffers&lt;/code&gt; 버퍼와한다을 반환 된 객체의 입력 범위 인터페이스를 통해 얻은 순서대로 결과를 사용할 수 있습니다. &lt;code&gt;asyncBuf&lt;/code&gt; 의 입력 범위 과부하와 유사하게 , 버퍼의 전반부는 범위 인터페이스를 통해 사용 가능하게되고 후반은 채워지고 그 반대도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="f4bc9912c00cf7ade5e6f59f3c7bafa79a0098bb" translate="yes" xml:space="preserve">
          <source>Given a function &lt;code&gt;f&lt;/code&gt; and a range &lt;code&gt;[a .. b]&lt;/code&gt; such that &lt;code&gt;f(a)&lt;/code&gt; and &lt;code&gt;f(b)&lt;/code&gt; have opposite signs or at least one of them equals &amp;plusmn;0, returns the value of &lt;code&gt;x&lt;/code&gt; in the range which is closest to a root of &lt;code&gt;f(x)&lt;/code&gt;. If &lt;code&gt;f(x)&lt;/code&gt; has more than one root in the range, one will be chosen arbitrarily. If &lt;code&gt;f(x)&lt;/code&gt; returns NaN, NaN will be returned; otherwise, this algorithm is guaranteed to succeed.</source>
          <target state="translated">&lt;code&gt;f(a)&lt;/code&gt; 와 &lt;code&gt;f(b)&lt;/code&gt; 가 반대 부호를 갖거나 그 중 적어도 하나가 &amp;plusmn; 0 과 같은 함수 &lt;code&gt;f&lt;/code&gt; 와 범위 &lt;code&gt;[a .. b]&lt;/code&gt; 주어지면 a 에 가장 가까운 범위에서 &lt;code&gt;x&lt;/code&gt; 의 값을 반환합니다 . 뿌리 &lt;code&gt;f(x)&lt;/code&gt; . 경우 &lt;code&gt;f(x)&lt;/code&gt; 범위 내에 하나 개 이상의 루트를 갖고, 하나는 임의로 선택된다. 경우 &lt;code&gt;f(x)&lt;/code&gt; NaN의를 반환 NaN이 반환됩니다; 그렇지 않으면이 알고리즘이 성공합니다.</target>
        </trans-unit>
        <trans-unit id="b3d905355b0b0e68c40d2c94bafa678611e3caae" translate="yes" xml:space="preserve">
          <source>Given a new instance tithis of this TemplateDeclaration, see if there already exists an instance. If so, return that existing instance.</source>
          <target state="translated">이 TemplateDeclaration의 새로운 인스턴스가 주어지면 이미 인스턴스가 있는지 확인하십시오. 그렇다면 기존 인스턴스를 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="7902cf88ea3243b9d5f9eb153e89c6c4585563c1" translate="yes" xml:space="preserve">
          <source>Given a pointer &lt;code&gt;chunk&lt;/code&gt; to uninitialized memory (but already typed as &lt;code&gt;T&lt;/code&gt;), constructs an object of non-&lt;code&gt;class&lt;/code&gt; type &lt;code&gt;T&lt;/code&gt; at that address. If &lt;code&gt;T&lt;/code&gt; is a class, initializes the class reference to null.</source>
          <target state="translated">초기화되지 않은 메모리 (이미 &lt;code&gt;T&lt;/code&gt; 로 입력 됨 )에 대한 포인터 &lt;code&gt;chunk&lt;/code&gt; 가 주어지면 해당 주소에서 &lt;code&gt;class&lt;/code&gt; 가 아닌 유형 &lt;code&gt;T&lt;/code&gt; 의 객체를 구성합니다 . 경우 &lt;code&gt;T&lt;/code&gt; 는 클래스이며, null로 클래스 참조를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="abaa134bbbf8060e8ac6344879f8e8d611739ebe" translate="yes" xml:space="preserve">
          <source>Given a pointer &lt;code&gt;chunk&lt;/code&gt; to uninitialized memory (but already typed as a non-class type &lt;code&gt;T&lt;/code&gt;), constructs an object of type &lt;code&gt;T&lt;/code&gt; at that address from arguments &lt;code&gt;args&lt;/code&gt;. If &lt;code&gt;T&lt;/code&gt; is a class, initializes the class reference to &lt;code&gt;args[0]&lt;/code&gt;.</source>
          <target state="translated">초기화되지 않은 메모리에 대한 포인터 &lt;code&gt;chunk&lt;/code&gt; 가 주어 졌지만 (이미 클래스가 아닌 유형 &lt;code&gt;T&lt;/code&gt; 로 입력 된 경우) 인수 &lt;code&gt;args&lt;/code&gt; 에서 해당 주소에 &lt;code&gt;T&lt;/code&gt; 유형의 객체를 구성합니다 . &lt;code&gt;T&lt;/code&gt; 가 클래스 인 경우 &lt;code&gt;args[0]&lt;/code&gt; 대한 클래스 참조를 초기화합니다 .</target>
        </trans-unit>
        <trans-unit id="58557c048614c0f1ce20fdb67b5db3ba6bf2d1b4" translate="yes" xml:space="preserve">
          <source>Given a pointer &lt;code&gt;chunk&lt;/code&gt; to uninitialized memory (but already typed as a non-class type &lt;code&gt;T&lt;/code&gt;), constructs an object of type &lt;code&gt;T&lt;/code&gt; at that address from arguments &lt;code&gt;args&lt;/code&gt;. If &lt;code&gt;T&lt;/code&gt; is a class, initializes the class reference to &lt;code&gt;args[0]&lt;/code&gt;. This function can be &lt;code&gt;@trusted&lt;/code&gt; if the corresponding constructor of &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;@safe&lt;/code&gt;.</source>
          <target state="translated">초기화되지 않은 메모리에 대한 포인터 &lt;code&gt;chunk&lt;/code&gt; 가 주어 졌지만 (이미 클래스가 아닌 유형 &lt;code&gt;T&lt;/code&gt; 로 입력 된 경우) 인수 &lt;code&gt;args&lt;/code&gt; 에서 해당 주소에 &lt;code&gt;T&lt;/code&gt; 유형의 객체를 구성합니다 . &lt;code&gt;T&lt;/code&gt; 가 클래스 인 경우 &lt;code&gt;args[0]&lt;/code&gt; 대한 클래스 참조를 초기화합니다 . 이 기능 할 수 &lt;code&gt;@trusted&lt;/code&gt; 의 대응 생성자 경우 &lt;code&gt;T&lt;/code&gt; 는 이다 &lt;code&gt;@safe&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="18ffdf892cf328d6d063a845b68a6520844d64c2" translate="yes" xml:space="preserve">
          <source>Given a pointer: If it is an Object, return that Object. If it is an interface, return the Object implementing the interface. If it is null, return null. Else, undefined crash</source>
          <target state="translated">포인터가 주어지면 : Object 인 경우 해당 Object를 반환하십시오. 인터페이스 인 경우 인터페이스를 구현하는 Object를 반환합니다. 널인 경우 널을 리턴하십시오. 그렇지 않으면 정의되지 않은 충돌</target>
        </trans-unit>
        <trans-unit id="a2a17bffc5b9d113dc0183d4777b121f1563c333" translate="yes" xml:space="preserve">
          <source>Given a random-access range and a starting point, creates a range that alternately returns the next left and next right element to the starting point.</source>
          <target state="translated">랜덤 액세스 범위와 시작점이 주어지면 다음 왼쪽 및 다음 오른쪽 요소를 시작점으로 교대로 반환하는 범위를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="cf77f4783176c69f24bf5139063bed48dbcdbc05" translate="yes" xml:space="preserve">
          <source>Given a range of elements, constructs an index of its top</source>
          <target state="translated">다양한 요소가 주어지면 최상위 인덱스를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="f82f27390a9cc6295ef9d3e2c499d003645adbcb" translate="yes" xml:space="preserve">
          <source>Given a range of ranges, iterate transversally through the &lt;code&gt;n&lt;/code&gt;th element of each of the enclosed ranges. This function is similar to &lt;code&gt;unzip&lt;/code&gt; in other languages.</source>
          <target state="translated">범위의 범위가 주어지면 , 닫힌 범위 각각의 &lt;code&gt;n&lt;/code&gt; 번째 요소를 가로로 반복 합니다. 이 기능은 다른 언어의 &lt;code&gt;unzip&lt;/code&gt; 와 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="99d831c39b761ba6173d077a392b684dab424593" translate="yes" xml:space="preserve">
          <source>Given a range of ranges, iterate transversally through the first elements of each of the enclosed ranges.</source>
          <target state="translated">범위의 범위가 주어지면 닫힌 범위 각각의 첫 번째 요소를 가로로 반복합니다.</target>
        </trans-unit>
        <trans-unit id="76deeb26e0b9b94a659a1c8d77489812eb190823" translate="yes" xml:space="preserve">
          <source>Given a range of ranges, returns a range of ranges where the</source>
          <target state="translated">범위의 범위가 주어지면 범위의 범위를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="23b1b22050fe1a6a85e37baec0da8ef5a908711a" translate="yes" xml:space="preserve">
          <source>Given a range of sorted &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward ranges&lt;/a&gt;&lt;code&gt;ror&lt;/code&gt;, copies to &lt;code&gt;tgt&lt;/code&gt; the elements that are common to most ranges, along with their number of occurrences. All ranges in &lt;code&gt;ror&lt;/code&gt; are assumed to be sorted by &lt;code&gt;less&lt;/code&gt;. Only the most frequent &lt;code&gt;tgt.length&lt;/code&gt; elements are returned.</source>
          <target state="translated">정렬 된 &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;순방향 범위가 &lt;/a&gt; &lt;code&gt;ror&lt;/code&gt; 인 경우, 발생 횟수와 함께 대부분의 범위에 공통 인 요소 를 &lt;code&gt;tgt&lt;/code&gt; 에 복사합니다 . &lt;code&gt;ror&lt;/code&gt; 의 모든 범위는 &lt;code&gt;less&lt;/code&gt; 정렬 된 것으로 가정합니다 . 가장 빈번한 &lt;code&gt;tgt.length&lt;/code&gt; 요소 만 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="6cadfddfad656a52536264d1af9f3900d194ed5c" translate="yes" xml:space="preserve">
          <source>Given a raw memory area &lt;code&gt;chunk&lt;/code&gt; (but already typed as a class type &lt;code&gt;T&lt;/code&gt;), constructs an object of &lt;code&gt;class&lt;/code&gt; type &lt;code&gt;T&lt;/code&gt; at that address. The constructor is passed the arguments &lt;code&gt;Args&lt;/code&gt;.</source>
          <target state="translated">원시 메모리 영역 &lt;code&gt;chunk&lt;/code&gt; 주어 졌지만 (이미 클래스 유형 &lt;code&gt;T&lt;/code&gt; 로 입력 됨 ) 해당 주소에서 &lt;code&gt;class&lt;/code&gt; 유형 &lt;code&gt;T&lt;/code&gt; 의 객체를 구성합니다 . 생성자에는 &lt;code&gt;Args&lt;/code&gt; 인수가 전달 됩니다.</target>
        </trans-unit>
        <trans-unit id="adbee075f1252282f1c423c0af02edd4265ab66b" translate="yes" xml:space="preserve">
          <source>Given a raw memory area &lt;code&gt;chunk&lt;/code&gt; (but already typed as a class type &lt;code&gt;T&lt;/code&gt;), constructs an object of &lt;code&gt;class&lt;/code&gt; type &lt;code&gt;T&lt;/code&gt; at that address. The constructor is passed the arguments &lt;code&gt;Args&lt;/code&gt;. If &lt;code&gt;T&lt;/code&gt; is an inner class whose &lt;code&gt;outer&lt;/code&gt; field can be used to access an instance of the enclosing class, then &lt;code&gt;Args&lt;/code&gt; must not be empty, and the first member of it must be a valid initializer for that &lt;code&gt;outer&lt;/code&gt; field. Correct initialization of this field is essential to access members of the outer class inside &lt;code&gt;T&lt;/code&gt; methods.</source>
          <target state="translated">원시 메모리 영역 &lt;code&gt;chunk&lt;/code&gt; 주어 졌지만 (이미 클래스 유형 &lt;code&gt;T&lt;/code&gt; 로 입력 됨 ) 해당 주소에서 &lt;code&gt;class&lt;/code&gt; 유형 &lt;code&gt;T&lt;/code&gt; 의 객체를 구성합니다 . 생성자에는 &lt;code&gt;Args&lt;/code&gt; 인수가 전달 됩니다. 경우 &lt;code&gt;T&lt;/code&gt; 는 그 내부 클래스 &lt;code&gt;outer&lt;/code&gt; 필드를 둘러싸는 클래스의 인스턴스에 액세스하는 데 사용될 수는 다음 &lt;code&gt;Args&lt;/code&gt; 비어 있지 않아야하고 그것의 제 1 부재에는 해당하는 유효 초기화 있어야 &lt;code&gt;outer&lt;/code&gt; 필드. 이 필드의 올바른 초기화는 &lt;code&gt;T&lt;/code&gt; 메소드 내부의 외부 클래스 멤버에 액세스하는 데 필수적 입니다.</target>
        </trans-unit>
        <trans-unit id="0653a1ab81721bb4c49575b0fcabecb4d629612a" translate="yes" xml:space="preserve">
          <source>Given a raw memory area &lt;code&gt;chunk&lt;/code&gt;, constructs an object of &lt;code&gt;class&lt;/code&gt; type &lt;code&gt;T&lt;/code&gt; at that address. The constructor is passed the arguments &lt;code&gt;Args&lt;/code&gt;.</source>
          <target state="translated">원시 메모리 영역 &lt;code&gt;chunk&lt;/code&gt; 주어지면 해당 주소에서 &lt;code&gt;class&lt;/code&gt; 유형 &lt;code&gt;T&lt;/code&gt; 의 객체를 구성합니다 . 생성자에는 &lt;code&gt;Args&lt;/code&gt; 인수가 전달 됩니다.</target>
        </trans-unit>
        <trans-unit id="74cf19c0277fb6a57dd8ab3cb630a33bfe4fee0c" translate="yes" xml:space="preserve">
          <source>Given a raw memory area &lt;code&gt;chunk&lt;/code&gt;, constructs an object of &lt;code&gt;class&lt;/code&gt; type &lt;code&gt;T&lt;/code&gt; at that address. The constructor is passed the arguments &lt;code&gt;Args&lt;/code&gt;. If &lt;code&gt;T&lt;/code&gt; is an inner class whose &lt;code&gt;outer&lt;/code&gt; field can be used to access an instance of the enclosing class, then &lt;code&gt;Args&lt;/code&gt; must not be empty, and the first member of it must be a valid initializer for that &lt;code&gt;outer&lt;/code&gt; field. Correct initialization of this field is essential to access members of the outer class inside &lt;code&gt;T&lt;/code&gt; methods.</source>
          <target state="translated">원시 메모리 영역 &lt;code&gt;chunk&lt;/code&gt; 주어지면 해당 주소에서 &lt;code&gt;class&lt;/code&gt; 유형 &lt;code&gt;T&lt;/code&gt; 의 객체를 구성합니다 . 생성자에는 &lt;code&gt;Args&lt;/code&gt; 인수가 전달 됩니다. 경우 &lt;code&gt;T&lt;/code&gt; 는 그 내부 클래스 &lt;code&gt;outer&lt;/code&gt; 필드를 둘러싸는 클래스의 인스턴스에 액세스하는 데 사용될 수는 다음 &lt;code&gt;Args&lt;/code&gt; 비어 있지 않아야하고 그것의 제 1 부재에는 해당하는 유효 초기화 있어야 &lt;code&gt;outer&lt;/code&gt; 필드. 이 필드의 올바른 초기화는 &lt;code&gt;T&lt;/code&gt; 메소드 내부의 외부 클래스 멤버에 액세스하는 데 필수적 입니다.</target>
        </trans-unit>
        <trans-unit id="e137ad6b52d9b560e6ecf089479316e86462ce01" translate="yes" xml:space="preserve">
          <source>Given a raw memory area &lt;code&gt;chunk&lt;/code&gt;, constructs an object of non-&lt;code&gt;class&lt;/code&gt; type &lt;code&gt;T&lt;/code&gt; at that address. The constructor is passed the arguments &lt;code&gt;args&lt;/code&gt;, if any.</source>
          <target state="translated">원시 메모리 영역 &lt;code&gt;chunk&lt;/code&gt; 주어지면 해당 주소에서 &lt;code&gt;class&lt;/code&gt; 가 아닌 유형 &lt;code&gt;T&lt;/code&gt; 의 객체를 구성합니다 . 생성자에는 인수 &lt;code&gt;args&lt;/code&gt; 가 전달 됩니다 (있는 경우).</target>
        </trans-unit>
        <trans-unit id="f8745e4f392d96921746aba6d016d8b75a3eaf5b" translate="yes" xml:space="preserve">
          <source>Given a symbol that could be either a FuncDeclaration or a function template, resolve it to a function symbol.</source>
          <target state="translated">FuncDeclaration 또는 함수 템플릿 일 수있는 기호가 있으면 함수 기호로 해석하십시오.</target>
        </trans-unit>
        <trans-unit id="3ec7e3b2070dd15d8c86e7da24a716e09d94b001" translate="yes" xml:space="preserve">
          <source>Given a type &lt;code&gt;S&lt;/code&gt; that is one of:</source>
          <target state="translated">다음 중 하나 인 &lt;code&gt;S&lt;/code&gt; 유형 이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="5bf486ff307c1ac9da00abda18e996a0151d6f51" translate="yes" xml:space="preserve">
          <source>Given a type &lt;code&gt;T&lt;/code&gt;, returns its allocation-related flags as a combination of &lt;code&gt;AllocFlag&lt;/code&gt; values.</source>
          <target state="translated">유형 &lt;code&gt;T&lt;/code&gt; 가 주어지면 할당 관련 플래그를 &lt;code&gt;AllocFlag&lt;/code&gt; 값 의 조합으로 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="1ec656f1b47e3a570669cfd79e664b45a8112e7a" translate="yes" xml:space="preserve">
          <source>Given address that is inside a function, figure out which function it is in. Return DHandlerTable if there is one, NULL if not.</source>
          <target state="translated">함수 안에있는 주소가 있다면, 어떤 함수 안에 있는지 알아 내십시오. DHandlerTable이 있으면 리턴하고, 없으면 NULL을 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="84fb4bae252188c74a52ee250ba7895934a71e72" translate="yes" xml:space="preserve">
          <source>Given an &lt;a href=&quot;https://en.wikipedia.org/wiki/Factory_(object-oriented_programming)&quot;&gt;object factory&lt;/a&gt; of type &lt;code&gt;Factory&lt;/code&gt; or a factory function &lt;code&gt;factoryFunction&lt;/code&gt;, and optionally also &lt;code&gt;BookkeepingAllocator&lt;/code&gt; as a supplemental allocator for bookkeeping, &lt;code&gt;AllocatorList&lt;/code&gt; creates an allocator that lazily creates as many allocators are needed for satisfying client allocation requests.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Factory_(object-oriented_programming)&quot;&gt;팩토리&lt;/a&gt; 유형의 &lt;code&gt;Factory&lt;/code&gt; 또는 팩토리 함수 &lt;code&gt;factoryFunction&lt;/code&gt; 의 오브젝트 팩토리 및 선택적으로 &lt;code&gt;BookkeepingAllocator&lt;/code&gt; (예약 유지 를위한 보충 할당 자)가 지정되면 &lt;code&gt;AllocatorList&lt;/code&gt; 는 클라이언트 할당 요청을 충족시키기 위해 필요한만큼 많은 할당자가 느리게 작성되는 할당자를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="2c2ffbad9b196900545a99b58a4a8084fb8e968f" translate="yes" xml:space="preserve">
          <source>Given an &lt;code&gt;AssignExp&lt;/code&gt;, determine if the lvalue will cause the contents of the rvalue to escape. Print error messages when these are detected. Infer &lt;code&gt;scope&lt;/code&gt; attribute for the lvalue where possible, in order to eliminate the error.</source>
          <target state="translated">&lt;code&gt;AssignExp&lt;/code&gt; 가 주어지면 lvalue로 인해 rvalue의 내용이 이스케이프되는지 확인하십시오. 오류 메시지가 감지되면 인쇄하십시오. 추론의 &lt;code&gt;scope&lt;/code&gt; 오류를 제거하기 위해 가능하면 좌변에 대한 속성.</target>
        </trans-unit>
        <trans-unit id="f4edc9674fd3041f4bd8fcdf8c36704d26537a1f" translate="yes" xml:space="preserve">
          <source>Given an Expression, find the variable it really is.</source>
          <target state="translated">식이 주어지면 실제로 변수를 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="10135b6f779b47ff66661cf2060528825cdb0465" translate="yes" xml:space="preserve">
          <source>Given an allocator factory, lazily creates as many allocators as needed to satisfy allocation requests. The allocators are stored in a linked list. Requests for allocation are satisfied by searching the list in a linear manner.</source>
          <target state="translated">할당 자 팩토리가 주어지면 할당 요청을 충족시키기 위해 필요한만큼 할당자를 느리게 만듭니다. 할당자는 연결된 목록에 저장됩니다. 할당 요청은 목록을 선형으로 검색하여 충족됩니다.</target>
        </trans-unit>
        <trans-unit id="c68fd4e0d6a4caa1cbbef6c7b7cc84e1b16b2800" translate="yes" xml:space="preserve">
          <source>Given an error instantiating the TemplateInstance, give the nested TemplateInstance instantiations that got us here. Those are a list threaded into the nested scopes.</source>
          <target state="translated">TemplateInstance를 인스턴스화하는 중 오류가 발생하면 중첩 된 TemplateInstance 인스턴스를 제공하십시오. 이들은 중첩 된 범위에 스레드 된 목록입니다.</target>
        </trans-unit>
        <trans-unit id="0d192178ddf2961ae655bd11083f31d24b553ec6" translate="yes" xml:space="preserve">
          <source>Given an expression e that is an array, determine and set the 'length' variable.</source>
          <target state="translated">배열 인 표현식 e가 주어지면 'length'변수를 결정하고 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="13b4b240c1888ba281f7a8d067f704fc09eba179" translate="yes" xml:space="preserve">
          <source>Given array literal oldval of type ArrayLiteralExp or StringExp, of length oldlen, change its length to newlen. If the newlen is longer than oldlen, all new elements will be set to the default initializer for the element type.</source>
          <target state="translated">ArrayLiteralExp 또는 StringExp 유형의 배열 리터럴 oldval이 oldlen 인 경우 길이를 newlen로 변경하십시오. newlen이 oldlen보다 길면 모든 새 요소가 요소 유형의 기본 이니셜 라이저로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="4fe6c27981ac387048ac652b298a3c233afd1136" translate="yes" xml:space="preserve">
          <source>Given array of foreach parameters and an aggregate type, find best opApply overload, if any of the parameter types are missing, attempt to infer them from the aggregate type.</source>
          <target state="translated">foreach 매개 변수와 집계 유형의 배열이 제공되면 매개 변수 유형이 누락 된 경우 가장 적합한 opApply 과부하를 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="548081a2237345a0383114c21603c8b8dab1f303" translate="yes" xml:space="preserve">
          <source>Given callable (&lt;a href=&quot;std_traits#isCallable&quot;&gt;&lt;code&gt;std.traits.isCallable&lt;/code&gt;&lt;/a&gt;) &lt;code&gt;fun&lt;/code&gt;, create as a range whose front is defined by successive calls to &lt;code&gt;fun()&lt;/code&gt;. This is especially useful to call function with global side effects (random functions), or to create ranges expressed as a single delegate, rather than an entire &lt;code&gt;front&lt;/code&gt;/&lt;code&gt;popFront&lt;/code&gt;/&lt;code&gt;empty&lt;/code&gt; structure. &lt;code&gt;fun&lt;/code&gt; maybe be passed either a template alias parameter (existing function, delegate, struct type defining &lt;code&gt;static opCall&lt;/code&gt;) or a run-time value argument (delegate, function object). The result range models an InputRange (&lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;&lt;code&gt;std.range.primitives.isInputRange&lt;/code&gt;&lt;/a&gt;). The resulting range will call &lt;code&gt;fun()&lt;/code&gt; on construction, and every call to &lt;code&gt;popFront&lt;/code&gt;, and the cached value will be returned when &lt;code&gt;front&lt;/code&gt; is called.</source>
          <target state="translated">callable ( &lt;a href=&quot;std_traits#isCallable&quot;&gt; &lt;code&gt;std.traits.isCallable&lt;/code&gt; &lt;/a&gt; ) &lt;code&gt;fun&lt;/code&gt; 이 주어지면 &lt;code&gt;fun()&lt;/code&gt; 을 연속적으로 호출하여 범위를 정의하는 범위로 작성하십시오 . 전역 부작용 (임의 함수)을 사용하여 함수를 호출하거나 전체 &lt;code&gt;front&lt;/code&gt; / &lt;code&gt;popFront&lt;/code&gt; / &lt;code&gt;empty&lt;/code&gt; 구조가 아닌 단일 델리게이트로 표현 된 범위를 만드는 데 특히 유용합니다 . &lt;code&gt;fun&lt;/code&gt; 은 템플릿 별칭 매개 변수 (기존 함수, 대리자, &lt;code&gt;static opCall&lt;/code&gt; 정의하는 구조체 유형 ) 또는 런타임 값 인수 (대리자, 함수 객체)로 전달 될 수 있습니다. 결과 범위는 InputRange ( &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt; &lt;code&gt;std.range.primitives.isInputRange&lt;/code&gt; &lt;/a&gt; )를 모델링 합니다. 결과 범위는 &lt;code&gt;fun()&lt;/code&gt; 을 호출합니다.구성 및 &lt;code&gt;popFront&lt;/code&gt; 에 대한 모든 호출 에서 캐시 된 값은 &lt;code&gt;front&lt;/code&gt; 가 호출 될 때 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="a6cdf45c5874188e502ef446c2f299954ad8e06e" translate="yes" xml:space="preserve">
          <source>Given function arguments, figure out which template function to expand, and return matching result.</source>
          <target state="translated">함수 인수가 주어지면 확장 할 템플릿 함수를 찾아서 일치하는 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2c41e0d5b6e5292f4394dbada3bf0e11b9965e54" translate="yes" xml:space="preserve">
          <source>Given that it is only called with &lt;a href=&quot;#safe-values&quot;&gt;safe values&lt;/a&gt; and &lt;a href=&quot;#safe-aliasing&quot;&gt;safe aliasing&lt;/a&gt;, a function has a safe interface when:</source>
          <target state="translated">&lt;a href=&quot;#safe-values&quot;&gt;안전한 값&lt;/a&gt; 과 &lt;a href=&quot;#safe-aliasing&quot;&gt;안전한 앨리어싱으로&lt;/a&gt; 만 호출된다는 점을 감안 하면 함수는 다음과 같은 경우 안전한 인터페이스를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="f1c0666f9da353f9c6f10f1cf5edecb5189140bb" translate="yes" xml:space="preserve">
          <source>Given that the most frequent use of &lt;code&gt;InSituRegion&lt;/code&gt; is as a stack allocator, it allocates starting at the end on systems where stack grows downwards, such that hot memory is used first.</source>
          <target state="translated">&lt;code&gt;InSituRegion&lt;/code&gt; 의 가장 빈번한 사용은 스택 할당 자로 사용 되므로 핫 메모리가 먼저 사용되도록 스택이 아래쪽으로 커지는 시스템에서 시작부터 할당합니다.</target>
        </trans-unit>
        <trans-unit id="433dfce23255598b88ff3eee832e615faf6acb1f" translate="yes" xml:space="preserve">
          <source>Given that ti is an instance of this TemplateDeclaration, deduce the types of the parameters to this, and store those deduced types in dedtypes[].</source>
          <target state="translated">ti가이 TemplateDeclaration의 인스턴스라고 가정하면 이에 대한 매개 변수 유형을 추론하고 추론 된 유형을 dedtypes []에 저장하십시오.</target>
        </trans-unit>
        <trans-unit id="de6b7e538358277d4d77d0a6dfdd22d328ebcdc2" translate="yes" xml:space="preserve">
          <source>Given y, the function finds x such log(x) - digamma(x) = y.</source>
          <target state="translated">y가 주어지면 함수는 x와 같은 log (x)-digamma (x) = y를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="992b94a2b2bacb1095a0b111a75eb520df8ea274" translate="yes" xml:space="preserve">
          <source>Given y, the function finds x such that</source>
          <target state="translated">y가 주어지면 함수는 x를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="b5ce07b779103b2800f63623f7d95755262b29ac" translate="yes" xml:space="preserve">
          <source>Gives a hint to the processor that the calling thread is in a 'spin-wait' loop, allowing to more efficiently allocate resources.</source>
          <target state="translated">프로세서에 호출 스레드가 'spin-wait'루프에 있다는 힌트를 제공하여 리소스를보다 효율적으로 할당 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6d6838e980e7d735fe427a6cf2d72e4e8647a21" translate="yes" xml:space="preserve">
          <source>Gives a string containing all of the member variables on their own line.</source>
          <target state="translated">모든 멤버 변수를 포함하는 문자열을 자체 줄에 제공합니다.</target>
        </trans-unit>
        <trans-unit id="7913f0379d403503a25672003418cf5f3eca8630" translate="yes" xml:space="preserve">
          <source>Gives a string in the form of &lt;code&gt;Appender!(A)(data)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Appender!(A)(data)&lt;/code&gt; 형식의 문자열을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="e8ea4a4989f9ed3007485f30bc4c477cf8cf78af" translate="yes" xml:space="preserve">
          <source>Gives a template that can be used to apply the same attributes that are on the given type &lt;code&gt;T&lt;/code&gt;. E.g. passing &lt;code&gt;inout shared int&lt;/code&gt; will return &lt;code&gt;SharedInoutOf&lt;/code&gt;.</source>
          <target state="translated">주어진 유형 &lt;code&gt;T&lt;/code&gt; 와 동일한 속성을 적용하는 데 사용할 수있는 템플리트를 제공합니다 . 예를 들어 &lt;code&gt;inout shared int&lt;/code&gt; 를 전달 하면 &lt;code&gt;SharedInoutOf&lt;/code&gt; 가 반환 됩니다 .</target>
        </trans-unit>
        <trans-unit id="a2633d057ea2e2d5df044edc1a3e53e74d5c07e4" translate="yes" xml:space="preserve">
          <source>Gives size in bytes of the memory mapped file.</source>
          <target state="translated">메모리 맵핑 된 파일의 크기를 바이트 단위로 제공합니다.</target>
        </trans-unit>
        <trans-unit id="16bbae332a1e2ca617ea29aad4cae716be022cf2" translate="yes" xml:space="preserve">
          <source>Gives the &lt;code&gt;sizeof&lt;/code&gt; the largest type given.</source>
          <target state="translated">부여 &lt;code&gt;sizeof&lt;/code&gt; 주어진 가장 큰 유형입니다.</target>
        </trans-unit>
        <trans-unit id="83055a3a0dd1a147d856955312d10beee008598a" translate="yes" xml:space="preserve">
          <source>Gives the difference between two &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt;s.</source>
          <target state="translated">두 &lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 사이의 차이를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="7aeb61024a32a4be6fbe1fa0169b6dc0e34e0c60" translate="yes" xml:space="preserve">
          <source>Gives the difference between two &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;s.</source>
          <target state="translated">두 &lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 의 차이를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="a3e5e3dc87d1abe001240e5d15a0f4c35cd6e9f2" translate="yes" xml:space="preserve">
          <source>Gives the difference between two &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;s.</source>
          <target state="translated">두 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; 의 차이를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="e0ddf7ec5492699d7655f4aa024331ee0d174c96" translate="yes" xml:space="preserve">
          <source>Gives the difference between two &lt;a href=&quot;#TimeOfDay&quot;&gt;&lt;code&gt;TimeOfDay&lt;/code&gt;&lt;/a&gt;s.</source>
          <target state="translated">두 &lt;a href=&quot;#TimeOfDay&quot;&gt; &lt;code&gt;TimeOfDay&lt;/code&gt; &lt;/a&gt; 의 차이를 나타 냅니다.</target>
        </trans-unit>
        <trans-unit id="23a706ac15ae0a2795d3b9540c47b5bd8f3ce3a4" translate="yes" xml:space="preserve">
          <source>Gives the last power of two before &lt;code&gt;val&lt;/code&gt;. &amp;lt;&amp;gt;&amp;gt; can be any built-in numerical type.</source>
          <target state="translated">&lt;code&gt;val&lt;/code&gt; 이전에 2의 ​​마지막 거듭 제곱을 제공합니다 . &amp;lt;&amp;gt;&amp;gt;는 모든 내장 숫자 유형이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5eba15a4a12033f10f76ecaeb54e9264300c3d84" translate="yes" xml:space="preserve">
          <source>Gives the next power of two after &lt;code&gt;val&lt;/code&gt;. &lt;code&gt;T&lt;/code&gt; can be any built-in numerical type.</source>
          <target state="translated">&lt;code&gt;val&lt;/code&gt; 다음에 2의 다음 거듭 제곱을 제공합니다 . &lt;code&gt;T&lt;/code&gt; 는 모든 내장 숫자 유형이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5dcd127d912205c801dfa9fd55aab21bc7540488" translate="yes" xml:space="preserve">
          <source>Gives the precision for numeric conversions. If the precision is a &lt;b&gt;*&lt;/b&gt;, an additional argument of type &lt;b&gt;int&lt;/b&gt;, preceding the actual argument, is taken as the precision. If it is negative, it is as if there was no</source>
          <target state="translated">숫자 변환의 정밀도를 제공합니다. 정밀도가 &lt;b&gt;*&lt;/b&gt; 이면 실제 인수 앞에있는 &lt;b&gt;int&lt;/b&gt; 유형의 추가 인수가 정밀도로 사용됩니다. 음수이면없는 것처럼</target>
        </trans-unit>
        <trans-unit id="066636e1bed1369dff6efcd3fab1c1e8776d7710" translate="yes" xml:space="preserve">
          <source>Gives the result of adding or subtracting a &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt; from</source>
          <target state="translated">&lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; &lt;/a&gt; 을 더하거나 뺀 결과를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="13fd9f69f64522f3bd20d1184529d631b3677431" translate="yes" xml:space="preserve">
          <source>Gives the result of adding or subtracting a &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt; from this &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt;, as well as assigning the result to this &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 &lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 에서 &lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; &lt;/a&gt; 을 더하거나 뺀 결과를이 &lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; 에&lt;/a&gt; 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="f3c64b6298caea8c356268035bf6bb2213d1e63d" translate="yes" xml:space="preserve">
          <source>Gives the result of adding or subtracting a &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt; from this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 &lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 에서 &lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; &lt;/a&gt; 을 더하거나 뺀 결과를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="a1405f5ebc75767bb0c5bcf744b2d2f96a676122" translate="yes" xml:space="preserve">
          <source>Gives the result of adding or subtracting a &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt; from this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;, as well as assigning the result to this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; 에서 &lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; &lt;/a&gt; 을 더하거나 빼고 결과를이 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; 에&lt;/a&gt; 할당 한 결과를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="aea621df7ee3b5185f92bf03dc43838e74f11ab8" translate="yes" xml:space="preserve">
          <source>Gives the result of adding or subtracting a &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt; from this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; 에서 &lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; &lt;/a&gt; 을 더하거나 뺀 결과를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="3d5dfde7603919eee6582396d3e52686e64f60c3" translate="yes" xml:space="preserve">
          <source>Gives the result of adding or subtracting a &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt; from this &lt;a href=&quot;#TimeOfDay&quot;&gt;&lt;code&gt;TimeOfDay&lt;/code&gt;&lt;/a&gt;, as well as assigning the result to this &lt;a href=&quot;#TimeOfDay&quot;&gt;&lt;code&gt;TimeOfDay&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 &lt;a href=&quot;#TimeOfDay&quot;&gt; &lt;code&gt;TimeOfDay&lt;/code&gt; &lt;/a&gt; 에서 &lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; &lt;/a&gt; 을 더하거나 빼고 결과를이 &lt;a href=&quot;#TimeOfDay&quot;&gt; &lt;code&gt;TimeOfDay&lt;/code&gt; 에&lt;/a&gt; 할당 한 결과를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="c1b9fd1a6e616c022dd85e5f596721b33e55dad9" translate="yes" xml:space="preserve">
          <source>Gives the result of adding or subtracting a &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt; from this &lt;a href=&quot;#TimeOfDay&quot;&gt;&lt;code&gt;TimeOfDay&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 &lt;a href=&quot;#TimeOfDay&quot;&gt; &lt;code&gt;TimeOfDay&lt;/code&gt; &lt;/a&gt; 에서 &lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; &lt;/a&gt; 을 더하거나 뺀 결과를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="d7bb55c3ac43c11992ce982a465028a297070c37" translate="yes" xml:space="preserve">
          <source>Gives the result of adding or subtracting a duration from this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;, as well as assigning the result to this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 &lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 에서 기간을 더하거나 빼고 결과를이 &lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; 에&lt;/a&gt; 할당 한 결과를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="b010645431226eb0d475a6508504f6360118e2aa" translate="yes" xml:space="preserve">
          <source>Gives the string &lt;code&gt;&quot;Nullable.null&quot;&lt;/code&gt; if &lt;code&gt;isNull&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;. Otherwise, the result is equivalent to calling &lt;a href=&quot;std_format#formattedWrite&quot;&gt;&lt;code&gt;std.format.formattedWrite&lt;/code&gt;&lt;/a&gt; on the underlying value.</source>
          <target state="translated">&lt;code&gt;isNull&lt;/code&gt; 이 &lt;code&gt;true&lt;/code&gt; 인 경우 &lt;code&gt;&quot;Nullable.null&quot;&lt;/code&gt; 문자열을 제공 합니다 . 그렇지 않으면 결과는 기본 값에서 &lt;a href=&quot;std_format#formattedWrite&quot;&gt; &lt;code&gt;std.format.formattedWrite&lt;/code&gt; &lt;/a&gt; 를 호출하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="ee3ba1f4d58b51dacaf77da9e736c2398dd52211" translate="yes" xml:space="preserve">
          <source>Giving better error messages inside generic code than the sometimes hard to follow compiler ones.</source>
          <target state="translated">때때로 따르기 어려운 컴파일러보다 일반적인 코드 내에 더 나은 오류 메시지를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="fe40132df9803a579f2616316fd9f36e8b76b6f5" translate="yes" xml:space="preserve">
          <source>Glagolitic</source>
          <target state="translated">Glagolitic</target>
        </trans-unit>
        <trans-unit id="52d16b8e3607d3a956a90dad397b270e88b2a626" translate="yes" xml:space="preserve">
          <source>Glibc C runtime</source>
          <target state="translated">Glibc C 런타임</target>
        </trans-unit>
        <trans-unit id="5f1184f7df96c5928092ad9c6b550699bf887826" translate="yes" xml:space="preserve">
          <source>Global</source>
          <target state="translated">Global</target>
        </trans-unit>
        <trans-unit id="ae4f56ae4da16df74b3d2aeca8b4352281e7be45" translate="yes" xml:space="preserve">
          <source>Global Functions</source>
          <target state="translated">글로벌 함수</target>
        </trans-unit>
        <trans-unit id="60d510ca3fec034b096ecb101e79c44baa3bcfa4" translate="yes" xml:space="preserve">
          <source>Global and Static Initializers</source>
          <target state="translated">글로벌 및 정적 이니셜 라이저</target>
        </trans-unit>
        <trans-unit id="ad8992e0e77b510d8dd8c9f31b8493285307157f" translate="yes" xml:space="preserve">
          <source>Global names</source>
          <target state="translated">글로벌 이름</target>
        </trans-unit>
        <trans-unit id="fb160cab6ebf08ae16224b7387fbe010ff67af79" translate="yes" xml:space="preserve">
          <source>Global random number generator used by various functions in this module whenever no generator is specified. It is allocated per-thread and initialized to an unpredictable value for each thread.</source>
          <target state="translated">생성기가 지정되지 않은 경우이 모듈의 다양한 기능에서 사용되는 전역 난수 생성기. 스레드 당 할당되며 각 스레드에 대해 예측할 수없는 값으로 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="359a7909d420e528181333df942be655d355c0d2" translate="yes" xml:space="preserve">
          <source>Global regex, repeat over the whole input.</source>
          <target state="translated">글로벌 정규 표현식, 전체 입력에 대해 반복하십시오.</target>
        </trans-unit>
        <trans-unit id="9d8204544b72aac8944f7aa50f34d5f2b83ebda7" translate="yes" xml:space="preserve">
          <source>Global status of the CTFE engine. Mostly used for performance diagnostics</source>
          <target state="translated">CTFE 엔진의 글로벌 상태. 성능 진단에 주로 사용</target>
        </trans-unit>
        <trans-unit id="3bb8f4a4ce9e8fc53902a34f5711af6100354847" translate="yes" xml:space="preserve">
          <source>Global variables.</source>
          <target state="translated">글로벌 변수.</target>
        </trans-unit>
        <trans-unit id="322346956002b43d1272ba3ca4fad36e87acf31f" translate="yes" xml:space="preserve">
          <source>Go through the variables in function fd that are to be allocated in a closure, and set the .offset fields for those variables to their positions relative to the start of the closure instance. Also turns off nrvo for closure variables.</source>
          <target state="translated">클로저에 할당 될 함수 fd의 변수를 살펴보고 해당 변수의 .offset 필드를 클로저 인스턴스의 시작과 관련된 위치로 설정하십시오. 또한 클로저 변수에 대해 nrvo를 끕니다.</target>
        </trans-unit>
        <trans-unit id="83644e2182412c095ed367b8519c41f7f1a72b2f" translate="yes" xml:space="preserve">
          <source>Good error handling code tends to clutter up what otherwise would be a neat and clean looking implementation.</source>
          <target state="translated">좋은 오류 처리 코드는 깔끔하고 깔끔한 구현을 혼란스럽게 만드는 경향이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4cc20ddddd5df91dbeeeac20e28069cdc6d35d5" translate="yes" xml:space="preserve">
          <source>Gothic</source>
          <target state="translated">Gothic</target>
        </trans-unit>
        <trans-unit id="523bd87e510be4584eb678bda56047b4e81b4e41" translate="yes" xml:space="preserve">
          <source>Goto Statement</source>
          <target state="translated">고토 진술</target>
        </trans-unit>
        <trans-unit id="d153d2afa0d10e789b42decd9c86f4c6ba7c4b32" translate="yes" xml:space="preserve">
          <source>GotoCaseStatements &lt;strong id=&quot;gotoCases&quot;&gt;gotoCases&lt;/strong&gt;;</source>
          <target state="translated">GotoCaseStatements &lt;strong id=&quot;gotoCases&quot;&gt;gotoCases&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="2d75a452fb197b862328ddf89077f60c5411007e" translate="yes" xml:space="preserve">
          <source>GotoStatement</source>
          <target state="translated">GotoStatement</target>
        </trans-unit>
        <trans-unit id="469b09861974ba8cba6608f5b50f5a4378e847aa" translate="yes" xml:space="preserve">
          <source>GotoStatements* &lt;strong id=&quot;gotos&quot;&gt;gotos&lt;/strong&gt;;</source>
          <target state="translated">GotoStatements * &lt;strong id=&quot;gotos&quot;&gt;gotos&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="b1b76e26ed39195055923abbd6da5da5869145b4" translate="yes" xml:space="preserve">
          <source>Gotos with forward references</source>
          <target state="translated">전방 참조가있는 Gotos</target>
        </trans-unit>
        <trans-unit id="dd17342cb47b948d64f169d73cfeec3f8b3e3f31" translate="yes" xml:space="preserve">
          <source>Grammar</source>
          <target state="translated">Grammar</target>
        </trans-unit>
        <trans-unit id="40e6976321b98f0050106aca23fe0094f3e12aec" translate="yes" xml:space="preserve">
          <source>Grapheme &lt;strong id=&quot;decodeGrapheme&quot;&gt;decodeGrapheme&lt;/strong&gt;(Input)(ref Input inp)</source>
          <target state="translated">Grapheme &lt;strong id=&quot;decodeGrapheme&quot;&gt;decodeGrapheme&lt;/strong&gt; (입력) (ref 입력 inp)</target>
        </trans-unit>
        <trans-unit id="09e21aefbc5d72becfb6e61403ad83558925c509" translate="yes" xml:space="preserve">
          <source>Grapheme cluster length in &lt;a href=&quot;#Code%20point&quot;&gt;code points&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#Code%20point&quot;&gt;코드 포인트의&lt;/a&gt; Grapheme 클러스터 길이 .</target>
        </trans-unit>
        <trans-unit id="85a58af54a6759d4a9d1a773cb4f960185f26fe4" translate="yes" xml:space="preserve">
          <source>Grapheme_Base</source>
          <target state="translated">Grapheme_Base</target>
        </trans-unit>
        <trans-unit id="9aa96ceeca035f99f4979af4785877395b3fcca9" translate="yes" xml:space="preserve">
          <source>Grapheme_Extend</source>
          <target state="translated">Grapheme_Extend</target>
        </trans-unit>
        <trans-unit id="2299a70876b7b20196c0e232824b6e303cf0f817" translate="yes" xml:space="preserve">
          <source>Grapheme_Link</source>
          <target state="translated">Grapheme_Link</target>
        </trans-unit>
        <trans-unit id="59d5f5b13f13f6d5e8e88a5a92e137f7d64b2954" translate="yes" xml:space="preserve">
          <source>Greek</source>
          <target state="translated">Greek</target>
        </trans-unit>
        <trans-unit id="305ccd272b16a96e13db1c4faa38b1913caf51d8" translate="yes" xml:space="preserve">
          <source>Greek Extended</source>
          <target state="translated">그리스어 확장</target>
        </trans-unit>
        <trans-unit id="63e0451063c60d5f6eae102313ee1b6d993a1f76" translate="yes" xml:space="preserve">
          <source>Greek and Coptic</source>
          <target state="translated">그리스와 콥트어</target>
        </trans-unit>
        <trans-unit id="73fb2dd5cc2643e9f02bc351410b98713e0c50c9" translate="yes" xml:space="preserve">
          <source>Group separator</source>
          <target state="translated">그룹 분리기</target>
        </trans-unit>
        <trans-unit id="10986e5fcbdd40c81d3e51dfc3ad691df9a6347c" translate="yes" xml:space="preserve">
          <source>Group!(pred, Range) &lt;strong id=&quot;group&quot;&gt;group&lt;/strong&gt;(alias pred = &quot;a == b&quot;, Range)(Range r);</source>
          <target state="translated">Group! (사전, 범위) &lt;strong id=&quot;group&quot;&gt;그룹&lt;/strong&gt; (별칭 pred = &quot;a == b&quot;, 범위) (범위 r);</target>
        </trans-unit>
        <trans-unit id="83af1301254c2810b776d48cab533ffdca19f557" translate="yes" xml:space="preserve">
          <source>Groups consecutively equivalent elements into a single tuple of the element and the number of its repetitions.</source>
          <target state="translated">연속적으로 동등한 요소를 요소의 단일 튜플과 반복 횟수로 그룹화합니다.</target>
        </trans-unit>
        <trans-unit id="afb8bcba7055a53eb0c5db950f6c2af39388fdf2" translate="yes" xml:space="preserve">
          <source>Grows &lt;code&gt;array&lt;/code&gt; by appending &lt;code&gt;delta&lt;/code&gt; more elements. The needed memory is allocated using &lt;code&gt;alloc&lt;/code&gt;. The extra elements added are either default- initialized, filled with copies of &lt;code&gt;init&lt;/code&gt;, or initialized with values fetched from &lt;code&gt;range&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;delta&lt;/code&gt; 더 많은 요소 를 추가하여 &lt;code&gt;array&lt;/code&gt; 을 확장 합니다. 필요한 메모리는 &lt;code&gt;alloc&lt;/code&gt; 을 사용하여 할당 됩니다. 추가 된 추가 요소는 기본적으로 초기화 되거나, &lt;code&gt;init&lt;/code&gt; 사본으로 채워지 거나, &lt;code&gt;range&lt;/code&gt; 에서 가져온 값으로 초기화됩니다 .</target>
        </trans-unit>
        <trans-unit id="e03f30a2f53aecda689ec68c63bc0d88b73542a6" translate="yes" xml:space="preserve">
          <source>Grows &lt;code&gt;array&lt;/code&gt; by appending &lt;code&gt;delta&lt;/code&gt; more elements. The needed memory is allocated using the same allocator that was used for the array type. The extra elements added are either default-initialized, filled with copies of &lt;code&gt;init&lt;/code&gt;, or initialized with values fetched from &lt;code&gt;range&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;delta&lt;/code&gt; 더 많은 요소 를 추가하여 &lt;code&gt;array&lt;/code&gt; 을 확장 합니다. 필요한 메모리는 배열 유형에 사용 된 것과 동일한 할당자를 사용하여 할당됩니다. 추가 된 추가 요소는 기본적으로 초기화 되거나 &lt;code&gt;init&lt;/code&gt; 사본으로 채워지 거나 &lt;code&gt;range&lt;/code&gt; 에서 가져온 값으로 초기화됩니다 .</target>
        </trans-unit>
        <trans-unit id="77afda6ffc95cc0f06adb904e94cef0fc69add7d" translate="yes" xml:space="preserve">
          <source>Guaranteed &amp;Omicron;(&lt;code&gt;abs(length - newLength)&lt;/code&gt;) if &lt;code&gt;capacity &amp;gt;= newLength&lt;/code&gt;. If &lt;code&gt;capacity &amp;lt; newLength&lt;/code&gt; the worst case is &amp;Omicron;(&lt;code&gt;newLength&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;capacity &amp;gt;= newLength&lt;/code&gt; 경우 &amp;Omicron; ( &lt;code&gt;abs(length - newLength)&lt;/code&gt; )가 보장 됩니다 . 경우 &lt;code&gt;capacity &amp;lt; newLength&lt;/code&gt; 최악의 경우는 &amp;Omicron; (이다 &lt;code&gt;newLength&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="929a28d261428029e61c0f81c6161fd71ba0b2fe" translate="yes" xml:space="preserve">
          <source>Guides</source>
          <target state="translated">Guides</target>
        </trans-unit>
        <trans-unit id="35776951606a73d6ff2bfb1c43d6ba2de2721cad" translate="yes" xml:space="preserve">
          <source>Guillaume Chatelet</source>
          <target state="translated">기 illa 샤 틀레</target>
        </trans-unit>
        <trans-unit id="971317803587830757efb436fa41eeb1d9292828" translate="yes" xml:space="preserve">
          <source>Guillaume Chatelet Manu Evans</source>
          <target state="translated">기 illa 샤 틀레 마누 에반스</target>
        </trans-unit>
        <trans-unit id="c06c55a5bcd005bf56c5234eb953099ffc1de3f1" translate="yes" xml:space="preserve">
          <source>Gujarati</source>
          <target state="translated">Gujarati</target>
        </trans-unit>
        <trans-unit id="265e1c23debf982bad1eb28dbf1fb86580b82eab" translate="yes" xml:space="preserve">
          <source>Gurmukhi</source>
          <target state="translated">Gurmukhi</target>
        </trans-unit>
        <trans-unit id="72c5d728b8c5e13d38cf050220cb41c1803704d1" translate="yes" xml:space="preserve">
          <source>H &lt;code&gt;m&lt;/code&gt;</source>
          <target state="translated">H의 &lt;code&gt;m&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d44602ce53397cc7e3837311abb7db1d03042b84" translate="yes" xml:space="preserve">
          <source>H. S. Teoh's &lt;a href=&quot;http://wiki.dlang.org/Component_programming_with_ranges&quot;&gt;tutorial on component programming with ranges&lt;/a&gt; for a real-world showcase of the influence of range-based programming on complex algorithms.</source>
          <target state="translated">복잡한 알고리즘에 대한 범위 기반 프로그래밍의 영향에 대한 실제 쇼케이스를위한 &lt;a href=&quot;http://wiki.dlang.org/Component_programming_with_ranges&quot;&gt;범위&lt;/a&gt; 가있는 컴포넌트 프로그래밍에 대한 HS Teoh의 튜토리얼 .</target>
        </trans-unit>
        <trans-unit id="bbe1ea5931e3b073b2c3409ef7882568b8096068" translate="yes" xml:space="preserve">
          <source>H. S. Teoh's &lt;a href=&quot;https://wiki.dlang.org/Component_programming_with_ranges&quot;&gt;tutorial on component programming with ranges&lt;/a&gt; for a real-world showcase of the influence of range-based programming on complex algorithms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fa36c2d12dc8308dd96737ca9539591241ccb57" translate="yes" xml:space="preserve">
          <source>HTML can be embedded into the documentation comments, and it will be passed through to the HTML output unchanged. However, since it is not necessarily true that HTML will be the desired output format of the embedded documentation comment extractor, it is best to avoid using it where practical.</source>
          <target state="translated">HTML은 문서 주석에 포함될 수 있으며 변경되지 않은 HTML 출력으로 전달됩니다. 그러나 HTML이 포함 된 문서 주석 추출기의 원하는 출력 형식 일 필요는 없지만 반드시 실제로 사용하지 않는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="f40b27d6b8b9a4fc3827264c1da16a04ecf4d094" translate="yes" xml:space="preserve">
          <source>HTTP</source>
          <target state="translated">HTTP</target>
        </trans-unit>
        <trans-unit id="0481530df63832f72dfdebbe0c7a51d57e32da26" translate="yes" xml:space="preserve">
          <source>HTTP &lt;code&gt;conn&lt;/code&gt;</source>
          <target state="translated">HTTP &lt;code&gt;conn&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ca83e4b247db9f9a4bf080067c192c5cb65a0d61" translate="yes" xml:space="preserve">
          <source>HTTP &lt;strong id=&quot;dup&quot;&gt;dup&lt;/strong&gt;();</source>
          <target state="translated">HTTP &lt;strong id=&quot;dup&quot;&gt;dup&lt;/strong&gt; ();</target>
        </trans-unit>
        <trans-unit id="e4e09a7d12cb155ba460134c8bdd1f1479d801ce" translate="yes" xml:space="preserve">
          <source>HTTP POST method</source>
          <target state="translated">HTTP POST 방법</target>
        </trans-unit>
        <trans-unit id="923988ff39d0e3042c9df0f259d1de84a01fde11" translate="yes" xml:space="preserve">
          <source>HTTP PUT</source>
          <target state="translated">HTTP PUT</target>
        </trans-unit>
        <trans-unit id="cc2478137d7b71e72935b2fddc027880593e756f" translate="yes" xml:space="preserve">
          <source>HTTP client functionality.</source>
          <target state="translated">HTTP 클라이언트 기능.</target>
        </trans-unit>
        <trans-unit id="827e4a67a71c875b43e732a905d1fd8e7200d6d6" translate="yes" xml:space="preserve">
          <source>HTTP connect request.</source>
          <target state="translated">HTTP 연결 요청</target>
        </trans-unit>
        <trans-unit id="51449b9a0615713cbd19f5f01e23d5f58e4358b0" translate="yes" xml:space="preserve">
          <source>HTTP connection to use</source>
          <target state="translated">사용할 HTTP 연결</target>
        </trans-unit>
        <trans-unit id="797634e3b267b6d81699bf16ac8a0f81dc1a1ba6" translate="yes" xml:space="preserve">
          <source>HTTP connection to use  The template parameter &lt;code&gt;T&lt;/code&gt; specifies the type to return. Possible values are &lt;code&gt;char&lt;/code&gt; and &lt;code&gt;ubyte&lt;/code&gt; to return &lt;code&gt;char[]&lt;/code&gt; or &lt;code&gt;ubyte[]&lt;/code&gt;.</source>
          <target state="translated">사용할 HTTP 연결 템플리트 매개 변수 &lt;code&gt;T&lt;/code&gt; 는 리턴 할 유형을 지정합니다. &lt;code&gt;char[]&lt;/code&gt; 또는 &lt;code&gt;ubyte[]&lt;/code&gt; 를 리턴하기위한 가능한 값은 &lt;code&gt;char&lt;/code&gt; 및 &lt;code&gt;ubyte&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e5b69d980b7b8a0f8d5057989430d112ecf22206" translate="yes" xml:space="preserve">
          <source>HTTP method used.</source>
          <target state="translated">사용 된 HTTP 메소드.</target>
        </trans-unit>
        <trans-unit id="bedfc3b8a98f74436dfffc470905a4cb727d6eb4" translate="yes" xml:space="preserve">
          <source>HTTP options request.</source>
          <target state="translated">HTTP 옵션 요청</target>
        </trans-unit>
        <trans-unit id="eca27a5fb0f79404f93ba2b2ff7621d850fa94c3" translate="yes" xml:space="preserve">
          <source>HTTP patch content.</source>
          <target state="translated">HTTP 패치 내용.</target>
        </trans-unit>
        <trans-unit id="0f24bcb381b514379fb794061233a0fac483e67d" translate="yes" xml:space="preserve">
          <source>HTTP post content.</source>
          <target state="translated">HTTP 게시물 내용.</target>
        </trans-unit>
        <trans-unit id="fd473bd4cc525d8634b2d06223e94be806e9169e" translate="yes" xml:space="preserve">
          <source>HTTP request, for odd commands like DELETE, TRACE and others</source>
          <target state="translated">DELETE, TRACE 등과 같은 이상한 명령에 대한 HTTP 요청</target>
        </trans-unit>
        <trans-unit id="7c360b79abb627a8a4c93e546c995b917aedbbb1" translate="yes" xml:space="preserve">
          <source>HTTP status line code e.g. 200.</source>
          <target state="translated">HTTP 상태 라인 코드 (예 : 200)</target>
        </trans-unit>
        <trans-unit id="7fb8b94d5f23dd0fd12704704bd5724a9a81dd11" translate="yes" xml:space="preserve">
          <source>HTTP status line ie. the first line returned in an HTTP response.</source>
          <target state="translated">HTTP 상태 줄 즉 첫 번째 줄은 HTTP 응답으로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="5c1ee2091ce3bea9e5a23e0562f6b6fd7953de16" translate="yes" xml:space="preserve">
          <source>HTTP status line of last response. One call to perform may result in several requests because of redirection.</source>
          <target state="translated">마지막 응답의 HTTP 상태 라인. 한 번의 호출로 리디렉션 때문에 여러 요청이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="45f917922bd09e11086c274630d2415137d36f0f" translate="yes" xml:space="preserve">
          <source>HTTP status line reason string.</source>
          <target state="translated">HTTP 상태 행 이유 문자열</target>
        </trans-unit>
        <trans-unit id="1909e6b2261783a8d317d6f55a66a50ec6cfafb1" translate="yes" xml:space="preserve">
          <source>HTTP trace request.</source>
          <target state="translated">HTTP 추적 요청</target>
        </trans-unit>
        <trans-unit id="52f8dbc2c259a9731d9751db65ced2bb8937f72a" translate="yes" xml:space="preserve">
          <source>HTTP.TimeCond &lt;code&gt;cond&lt;/code&gt;</source>
          <target state="translated">HTTP.TimeCond &lt;code&gt;cond&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a59dd0563a7efe56dbe888a8e6b63f08d0ec7b1a" translate="yes" xml:space="preserve">
          <source>HTTP/FTP delete content.</source>
          <target state="translated">HTTP / FTP는 컨텐츠를 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="c911addb5a09d460fe739f0ee6699cd1115b2ceb" translate="yes" xml:space="preserve">
          <source>HTTP/FTP download to local file system.</source>
          <target state="translated">로컬 파일 시스템으로 HTTP / FTP 다운로드</target>
        </trans-unit>
        <trans-unit id="444e75970e6f6b8a13c7660b530b8789eb9d1688" translate="yes" xml:space="preserve">
          <source>HTTP/FTP fetch content as a range of chunks asynchronously.</source>
          <target state="translated">HTTP / FTP는 비동기 적으로 청크 범위로 컨텐츠를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="067f2a38c032292745289e6d568747297c1eb36d" translate="yes" xml:space="preserve">
          <source>HTTP/FTP fetch content as a range of chunks.</source>
          <target state="translated">HTTP / FTP는 다양한 청크로 콘텐츠를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="ba7a6201d2a706377c412c319526144deec7201e" translate="yes" xml:space="preserve">
          <source>HTTP/FTP fetch content as a range of lines asynchronously.</source>
          <target state="translated">HTTP / FTP는 컨텐츠를 비동기 적으로 라인 범위로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="a30ab80f3f96882837554330daf0f4a6aaa048ff" translate="yes" xml:space="preserve">
          <source>HTTP/FTP fetch content as a range of lines.</source>
          <target state="translated">HTTP / FTP는 컨텐츠를 여러 줄로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="0a0a651b4d9a70a2c11401ce60fa08020ea7c52c" translate="yes" xml:space="preserve">
          <source>HTTP/FTP get content.</source>
          <target state="translated">HTTP / FTP는 컨텐츠를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="a18566ddab985dc1d64ecd1c3e55c7fe0283f6cd" translate="yes" xml:space="preserve">
          <source>HTTP/FTP put content.</source>
          <target state="translated">HTTP / FTP는 내용을 넣습니다.</target>
        </trans-unit>
        <trans-unit id="fd41ab93c5537d58968dc08902626f4aedcfc790" translate="yes" xml:space="preserve">
          <source>Halfwidth and Fullwidth Forms</source>
          <target state="translated">반자 및 전각 양식</target>
        </trans-unit>
        <trans-unit id="15710324ddc14a3ddc719e414d041bb782d93764" translate="yes" xml:space="preserve">
          <source>Han</source>
          <target state="translated">Han</target>
        </trans-unit>
        <trans-unit id="495fba644d4dd3d28a3df2c5e262bc0aa344bdc1" translate="yes" xml:space="preserve">
          <source>Handle and transcode between various text encodings.</source>
          <target state="translated">다양한 텍스트 인코딩 간 처리 및 코드 변환</target>
        </trans-unit>
        <trans-unit id="4cae35b945ed013183aeec759fb173f2b5e74ee5" translate="yes" xml:space="preserve">
          <source>Handle enums.</source>
          <target state="translated">열거 형을 처리하십시오.</target>
        </trans-unit>
        <trans-unit id="70c0fd2c64cbbc7d9a73e18bc0fd02b46b142b9f" translate="yes" xml:space="preserve">
          <source>Handle exceptions thrown from range primitives.</source>
          <target state="translated">범위 기본 요소에서 발생한 예외를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="ed3da861f4c68bd404277c3815bb4277903ee0c7" translate="yes" xml:space="preserve">
          <source>Handle the postblit call on lvalue, or the move of rvalue.</source>
          <target state="translated">lvalue 또는 rvalue 이동에 대한 포스트 블리치 호출을 처리하십시오.</target>
        </trans-unit>
        <trans-unit id="e61477ad33d711243071181209298dcaac99b754" translate="yes" xml:space="preserve">
          <source>Handle to the system-specific semaphore.</source>
          <target state="translated">시스템 별 세마포어를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="362f233bfd36bbe9ffba21ece507104cececa24e" translate="yes" xml:space="preserve">
          <source>Handlers</source>
          <target state="translated">Handlers</target>
        </trans-unit>
        <trans-unit id="bd7d4b95fcd93ad906141f781368bc43c7c7f10a" translate="yes" xml:space="preserve">
          <source>Hangul</source>
          <target state="translated">Hangul</target>
        </trans-unit>
        <trans-unit id="46a74e921ed0b81734815d203a76d63ac9b445e2" translate="yes" xml:space="preserve">
          <source>Hangul Compatibility Jamo</source>
          <target state="translated">한글 호환성 자모</target>
        </trans-unit>
        <trans-unit id="6e435e03b7ff7b49d783dd12f4139eb337e88129" translate="yes" xml:space="preserve">
          <source>Hangul Jamo</source>
          <target state="translated">한글 자모</target>
        </trans-unit>
        <trans-unit id="1af30ae437546a0c8f4e8c904b38e9e32c465cd5" translate="yes" xml:space="preserve">
          <source>Hangul Jamo Extended-A</source>
          <target state="translated">한글 자모 확장 -A</target>
        </trans-unit>
        <trans-unit id="7f76ea3a5ca65b3f7be6271028b86fb4c24ad5b4" translate="yes" xml:space="preserve">
          <source>Hangul Jamo Extended-B</source>
          <target state="translated">한글 자모 확장 B</target>
        </trans-unit>
        <trans-unit id="a3c09f1beeeb5e6518d7a5aa130f9229a5bab1c8" translate="yes" xml:space="preserve">
          <source>Hangul Syllables</source>
          <target state="translated">한글 음절</target>
        </trans-unit>
        <trans-unit id="9649db5db6338c7bb1ab5215b20988c58817b67a" translate="yes" xml:space="preserve">
          <source>Hangul syllables are not covered by this function. See &lt;code&gt;composeJamo&lt;/code&gt; below.</source>
          <target state="translated">한글 음절에는이 기능이 적용되지 않습니다. 아래의 &lt;code&gt;composeJamo&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ed413af43425a39818253cc0c5de7394d4a39735" translate="yes" xml:space="preserve">
          <source>Hanunoo</source>
          <target state="translated">Hanunoo</target>
        </trans-unit>
        <trans-unit id="e938944cea2d9cc40e1f9955e4a0cfe8a2544308" translate="yes" xml:space="preserve">
          <source>Hardware Control</source>
          <target state="translated">하드웨어 제어</target>
        </trans-unit>
        <trans-unit id="624a7b201d0ea02f7b27a09976e5469ea739a9e3" translate="yes" xml:space="preserve">
          <source>Has the same meaning as outside of a character class.</source>
          <target state="translated">문자 클래스 외부와 동일한 의미를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="ff69afc8afb157be53fcca5d806ead0afca8f54a" translate="yes" xml:space="preserve">
          <source>Hash &lt;strong id=&quot;makeDigest&quot;&gt;makeDigest&lt;/strong&gt;(Hash)();</source>
          <target state="translated">해시 &lt;strong id=&quot;makeDigest&quot;&gt;makeDigest&lt;/strong&gt; (해시) ();</target>
        </trans-unit>
        <trans-unit id="512530e2001855653aa805d74cb64a05638ad3fd" translate="yes" xml:space="preserve">
          <source>Hash options.</source>
          <target state="translated">해시 옵션.</target>
        </trans-unit>
        <trans-unit id="82c3b55a6e6190b4ea897a708e89b49564008ef7" translate="yes" xml:space="preserve">
          <source>Hash syntax for json objects.</source>
          <target state="translated">json 객체의 해시 구문.</target>
        </trans-unit>
        <trans-unit id="8d05adeedcb7aa54cc03e4f260b3e38d1479ae1c" translate="yes" xml:space="preserve">
          <source>HashTab container for internal usage.</source>
          <target state="translated">내부 사용을위한 HashTab 컨테이너.</target>
        </trans-unit>
        <trans-unit id="201cd54dff7c562fa04665ce3ec7f389323b7356" translate="yes" xml:space="preserve">
          <source>Have some variables that are maybescopes that were assigned values from other maybescope variables. Now that semantic analysis of the function is complete, we can finalize this by turning off maybescope for array elements that cannot be scope.</source>
          <target state="translated">다른 범위 변수의 값이 지정된 범위 범위 변수 일 수 있습니다. 함수의 의미 론적 분석이 완료되었으므로 범위가 될 수없는 배열 요소에 대해 maybescope를 해제하여이를 마무리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="dea56ebbd4737b0cd9262ab0c819e3683d0b5416" translate="yes" xml:space="preserve">
          <source>Having unmatched parentheses can hose the output of Ddoc, as the macros depend on properly nested parentheses. This function replaces all ( with ( and ) with ) to preserve text literally. This also means macros in the text won't be expanded.</source>
          <target state="translated">매크로가 올바르게 중첩 된 괄호에 의존하므로 일치하지 않는 괄호를 사용하면 Ddoc의 출력을 막을 수 있습니다. 이 함수는 문자를 그대로 유지하기 위해 모든 (와 (및)을)로 대체합니다. 이것은 또한 텍스트의 매크로가 확장되지 않음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="71653e5271aa72abad98ba52f8927b0be428b96b" translate="yes" xml:space="preserve">
          <source>Haystack &lt;code&gt;haystack&lt;/code&gt;</source>
          <target state="translated">건초 &lt;code&gt;haystack&lt;/code&gt; 건초 더미</target>
        </trans-unit>
        <trans-unit id="e0403de1effb4e88849c3d2d079f299e89f093ed" translate="yes" xml:space="preserve">
          <source>HeaderFormat &lt;code&gt;header&lt;/code&gt;</source>
          <target state="translated">HeaderFormat &lt;code&gt;header&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c97d4c3dede14ee24bc42018c52f19917fd481c9" translate="yes" xml:space="preserve">
          <source>Headings</source>
          <target state="translated">Headings</target>
        </trans-unit>
        <trans-unit id="348d00693e12bc983bd092677b90434b5a4d869e" translate="yes" xml:space="preserve">
          <source>Hebrew</source>
          <target state="translated">Hebrew</target>
        </trans-unit>
        <trans-unit id="fbea2ec13adcf999e380e13a429a4e17dc3d8090" translate="yes" xml:space="preserve">
          <source>Help Information Generation</source>
          <target state="translated">정보 생성 도움말</target>
        </trans-unit>
        <trans-unit id="1e7eebdb08c9dbf27c7668e2badd51e667707d3c" translate="yes" xml:space="preserve">
          <source>Helper</source>
          <target state="translated">Helper</target>
        </trans-unit>
        <trans-unit id="5e31a530e83afec402c4c09898e79e56b473dc7d" translate="yes" xml:space="preserve">
          <source>Helper for NewExp Create a string literal consisting of 'value' duplicated 'dim' times.</source>
          <target state="translated">NewExp에 대한 도우미 '값'복제 된 'dim'시간으로 구성된 문자열 리터럴을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="766c386647e8e48a9fcd435724f1d350167f7ed5" translate="yes" xml:space="preserve">
          <source>Helper for NewExp Create an array literal consisting of 'elem' duplicated 'dim' times.</source>
          <target state="translated">NewExp의 도우미 'elem'복제 된 'dim'시간으로 구성된 배열 리터럴을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="c02c79263e4ed8c5595da2dd0c63a6d49edcd0eb" translate="yes" xml:space="preserve">
          <source>Helper function for &lt;code&gt;getRightThis()&lt;/code&gt;. Gets &lt;code&gt;this&lt;/code&gt; of the next outer aggregate.</source>
          <target state="translated">&lt;code&gt;getRightThis()&lt;/code&gt; 헬퍼 함수 . 다음 외부 집계의 &lt;code&gt;this&lt;/code&gt; 가져 옵니다.</target>
        </trans-unit>
        <trans-unit id="467531459771317152c9703e3f120447d81f80b5" translate="yes" xml:space="preserve">
          <source>Helper function for easy error propagation. If error occurs, returns ErrorExp. Otherwise returns NULL.</source>
          <target state="translated">쉬운 오류 전파를위한 도우미 기능. 오류가 발생하면 ErrorExp를 반환합니다. 그렇지 않으면 NULL을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3576c823fa70ffbb40f146b4e65274f6dc08a676" translate="yes" xml:space="preserve">
          <source>Helper function for the expansion of manifest constant.</source>
          <target state="translated">매니페스트 상수의 확장을위한 도우미 기능</target>
        </trans-unit>
        <trans-unit id="f45a0f048cca01c298f3e28147b97707c3bec7c9" translate="yes" xml:space="preserve">
          <source>Helper function that returns a &lt;code&gt;FormatSpec&lt;/code&gt; for a single specifier given in &lt;code&gt;fmt&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;fmt&lt;/code&gt; 에 제공된 단일 지정자에 대한 &lt;code&gt;FormatSpec&lt;/code&gt; 을 리턴하는 헬퍼 함수입니다 .</target>
        </trans-unit>
        <trans-unit id="10a93d4497e85393cb5499fb73d96c729ebc3ddb" translate="yes" xml:space="preserve">
          <source>Helper function that returns a complex number with the specified real and imaginary parts.</source>
          <target state="translated">지정된 실수 부와 허수 부를 가진 복소수를 반환하는 도우미 함수입니다.</target>
        </trans-unit>
        <trans-unit id="b43936919328317134bad177cd4f68d6f84246ac" translate="yes" xml:space="preserve">
          <source>Helper function to turn operator into template argument list</source>
          <target state="translated">연산자를 템플릿 인수 목록으로 바꾸는 도우미 기능</target>
        </trans-unit>
        <trans-unit id="934835a36e88b263f02948e4dbd8c5dd04401bc0" translate="yes" xml:space="preserve">
          <source>Helper functions</source>
          <target state="translated">도우미 기능</target>
        </trans-unit>
        <trans-unit id="3c9b3433e6f225e4ae00ef2041d44d91bfbf7113" translate="yes" xml:space="preserve">
          <source>Helpers</source>
          <target state="translated">Helpers</target>
        </trans-unit>
        <trans-unit id="736e7e325114a8cd6d30377592f7bf25b8688457" translate="yes" xml:space="preserve">
          <source>Hence, the following errors can be statically detected:</source>
          <target state="translated">따라서 다음 오류가 정적으로 감지 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e9e62a53ff4cde1bc51ffbf3814a1010c7743286" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;o&lt;/code&gt; supplies the</source>
          <target state="translated">여기에 &lt;code&gt;o&lt;/code&gt; 공급한다</target>
        </trans-unit>
        <trans-unit id="1ede5efd1d10c5200eb2a32aa68abb7fc6f76c2f" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;o&lt;/code&gt; supplies the &lt;code&gt;this&lt;/code&gt; reference to the inner class instance of &lt;code&gt;Outer&lt;/code&gt;.</source>
          <target state="translated">여기서 &lt;code&gt;o&lt;/code&gt; 는 &lt;code&gt;Outer&lt;/code&gt; 의 내부 클래스 인스턴스에 &lt;code&gt;this&lt;/code&gt; 참조를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="8cf320d31b7dd0774140c8f2ed90c8c274ff772d" translate="yes" xml:space="preserve">
          <source>Here block names are unambiguous as no scripts are searched and thus to search use simply &lt;code&gt;unicode.block.BlockName&lt;/code&gt; notation.</source>
          <target state="translated">여기서는 스크립트를 검색하지 않으므로 블록 이름이 명확하므로 &lt;code&gt;unicode.block.BlockName&lt;/code&gt; 표기법을 사용하여 검색하십시오 .</target>
        </trans-unit>
        <trans-unit id="6dcb204b7bfbc922a65c81d29d2d9fe0db1b0d9c" translate="yes" xml:space="preserve">
          <source>Here is an example function in both forms:</source>
          <target state="translated">다음은 두 가지 형태의 함수 예제입니다.</target>
        </trans-unit>
        <trans-unit id="d0b4b9e647805e60f485e34136037cafd1a89034" translate="yes" xml:space="preserve">
          <source>Here the method &lt;code&gt;add&lt;/code&gt; returns the base type, which doesn't implement the &lt;code&gt;remove&lt;/code&gt; method. The &lt;code&gt;template this&lt;/code&gt; parameter can be used for this purpose:</source>
          <target state="translated">여기서 &lt;code&gt;add&lt;/code&gt; 메소드 는 &lt;code&gt;remove&lt;/code&gt; 메소드를 구현하지 않는 기본 유형을 리턴합니다 . &lt;code&gt;template this&lt;/code&gt; 매개 변수는이 목적을 위해 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="c4a0b731de4fd47e1ec934359b73224f54545eef" translate="yes" xml:space="preserve">
          <source>Here the method &lt;code&gt;initWith&lt;/code&gt; is overloaded with two versions, one accepting &lt;code&gt;in char*&lt;/code&gt;, the other one &lt;code&gt;NSString&lt;/code&gt;. These two methods are mapped to two different Objective-C selectors, &lt;code&gt;initWithUTF8String:&lt;/code&gt; and &lt;code&gt;initWithString:&lt;/code&gt;.</source>
          <target state="translated">여기에서 &lt;code&gt;initWith&lt;/code&gt; 메소드 는 두 가지 버전으로 오버로드 되는데 , 하나 &lt;code&gt;in char*&lt;/code&gt; 에서, 다른 하나는 &lt;code&gt;NSString&lt;/code&gt; 입니다. 이 두 메소드는 두 개의 다른 Objective-C 선택기 ( &lt;code&gt;initWithUTF8String:&lt;/code&gt; 및 &lt;code&gt;initWithString:&lt;/code&gt; :)에 맵핑됩니다 .</target>
        </trans-unit>
        <trans-unit id="7394eed5672426c0a80d302b8f8393ed7eec5e66" translate="yes" xml:space="preserve">
          <source>Here's an example of C code providing a callback to D code:</source>
          <target state="translated">다음은 D 코드에 콜백을 제공하는 C 코드의 예입니다.</target>
        </trans-unit>
        <trans-unit id="ca207d127693f0056dad58049c5cee1c802022ff" translate="yes" xml:space="preserve">
          <source>Here's an example of a</source>
          <target state="translated">여기에 예가 있습니다</target>
        </trans-unit>
        <trans-unit id="62b798df4ae2b665a95d9fcc9f504deddb178a54" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;S&lt;/code&gt; has a temporary workspace &lt;code&gt;buf[]&lt;/code&gt;. The normal postblit will pointlessly free and reallocate it. The custom &lt;code&gt;opAssign&lt;/code&gt; will reuse the existing storage.</source>
          <target state="translated">여기서 &lt;code&gt;S&lt;/code&gt; 에는 임시 작업 공간 &lt;code&gt;buf[]&lt;/code&gt; 있습니다. 정상적인 포스트 블릿은 무의미하게 해제되고 재 할당됩니다. 사용자 지정 &lt;code&gt;opAssign&lt;/code&gt; 은 기존 스토리지를 재사용합니다.</target>
        </trans-unit>
        <trans-unit id="8062e6745c830b66848176f824bd120bb6ff6bff" translate="yes" xml:space="preserve">
          <source>Here, an implementation may assume (without having knowledge of the body of &lt;code&gt;make&lt;/code&gt;) that all references in &lt;code&gt;make&lt;/code&gt;'s result refer to other &lt;code&gt;List&lt;/code&gt; objects created by &lt;code&gt;make&lt;/code&gt;, and that no other part of the program refers to any of these objects.</source>
          <target state="translated">여기에서, 구현은 (의 몸에 대한 지식없이 가정 수 있습니다 &lt;code&gt;make&lt;/code&gt; 모두 참조하는) &lt;code&gt;make&lt;/code&gt; 결과의 다른 참조 &lt;code&gt;List&lt;/code&gt; 에 의해 만들어진 객체 &lt;code&gt;make&lt;/code&gt; , 프로그램의 다른 부분은 이러한 개체 중 하나를 의미 없다.</target>
        </trans-unit>
        <trans-unit id="aa7249d3729c33470954c40f7854c88ac6ea3626" translate="yes" xml:space="preserve">
          <source>Hex Strings</source>
          <target state="translated">16 진 현</target>
        </trans-unit>
        <trans-unit id="55d1c93cb26fa4369bf6dcef06802017d907bd51" translate="yes" xml:space="preserve">
          <source>Hex strings allow string literals to be created using hex data. The hex data need not form valid UTF characters.</source>
          <target state="translated">16 진 문자열을 사용하면 16 진 데이터를 사용하여 문자열 리터럴을 작성할 수 있습니다. 16 진 데이터는 유효한 UTF 문자를 형성 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="d39bdde77ca95b7a4b0450ffc2d016efdeac30d3" translate="yes" xml:space="preserve">
          <source>Hex_Digit</source>
          <target state="translated">Hex_Digit</target>
        </trans-unit>
        <trans-unit id="c45ee0a2d08a303c51fd2da33a102a3979857332" translate="yes" xml:space="preserve">
          <source>Hexadecimal floats are preceded by a &lt;b&gt;0x&lt;/b&gt; or &lt;b&gt;0X&lt;/b&gt; and the exponent is a &lt;b&gt;p&lt;/b&gt; or &lt;b&gt;P&lt;/b&gt; followed by a decimal number serving as the exponent of 2.</source>
          <target state="translated">16 진 부동 소수점 앞에는 &lt;b&gt;0x&lt;/b&gt; 또는 &lt;b&gt;0X가&lt;/b&gt; 있고 지수는 &lt;b&gt;p&lt;/b&gt; 또는 &lt;b&gt;P에&lt;/b&gt; 이어 2의 지수로 사용되는 10 진수입니다.</target>
        </trans-unit>
        <trans-unit id="f16858a5f250d36219d82e048f143333094b2747" translate="yes" xml:space="preserve">
          <source>Hexadecimal integers are a sequence of hexadecimal digits preceded by a &amp;lsquo;0x&amp;rsquo; or &amp;lsquo;0X&amp;rsquo;.</source>
          <target state="translated">16 진 정수는 '0x'또는 '0X'가 앞에 오는 16 진 숫자의 순서입니다.</target>
        </trans-unit>
        <trans-unit id="11ddb91ab70b44df8f22cc56bf0f33cd3a59aeec" translate="yes" xml:space="preserve">
          <source>Hexadecimal notation</source>
          <target state="translated">16 진법</target>
        </trans-unit>
        <trans-unit id="66364879eee2501137250fec2b98de691bb34dff" translate="yes" xml:space="preserve">
          <source>Hexadecimal notation with explicit suffixes</source>
          <target state="translated">명시적인 접미사가있는 16 진 표기법</target>
        </trans-unit>
        <trans-unit id="4606d5486909f59f9ecd950c1b17f287693253b2" translate="yes" xml:space="preserve">
          <source>Hexadecimal, lower case</source>
          <target state="translated">16 진, 소문자</target>
        </trans-unit>
        <trans-unit id="bf0117ce1416e40b23cca8ffd7b3aa016afb333f" translate="yes" xml:space="preserve">
          <source>Hexadecimal, upper case</source>
          <target state="translated">16 진 대문자</target>
        </trans-unit>
        <trans-unit id="30b3eea9819f7439bb0562c0c53437f8d9a50617" translate="yes" xml:space="preserve">
          <source>Hidden parameters include the &lt;code&gt;this&lt;/code&gt; parameter of a class, struct or nested function and the selector parameter for Objective-C methods.</source>
          <target state="translated">숨겨진 매개 변수에는 클래스, 구조체 또는 중첩 함수 의 &lt;code&gt;this&lt;/code&gt; 매개 변수와 Objective-C 메서드의 선택기 매개 변수가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="53541869fd4c351759ad332d3244e2355b446808" translate="yes" xml:space="preserve">
          <source>High Private Use Surrogates</source>
          <target state="translated">높은 개인 사용 대리</target>
        </trans-unit>
        <trans-unit id="a2c5b830397db70f03f56d26786a97a92aad7755" translate="yes" xml:space="preserve">
          <source>High Surrogates</source>
          <target state="translated">대리모</target>
        </trans-unit>
        <trans-unit id="f8ac1be04c27612db7a3ef64fd5edd48a9cbefb5" translate="yes" xml:space="preserve">
          <source>High level</source>
          <target state="translated">높은 레벨</target>
        </trans-unit>
        <trans-unit id="0720fad238d3af6e0d988b6041fc7aff02b725de" translate="yes" xml:space="preserve">
          <source>High level bit level manipulation, bit arrays, bit fields.</source>
          <target state="translated">높은 수준의 비트 수준 조작, 비트 배열, 비트 필드.</target>
        </trans-unit>
        <trans-unit id="a05a4fbe2b607cf88b24dc00ca5c949b2b6f1756" translate="yes" xml:space="preserve">
          <source>High level primitives for SMP parallelism.</source>
          <target state="translated">SMP 병렬 처리를위한 고급 프리미티브.</target>
        </trans-unit>
        <trans-unit id="2ced0d4c7e1faee3d9f900306c2e846112d18012" translate="yes" xml:space="preserve">
          <source>High-level interface for allocators. Implements bundled allocation/creation and destruction/deallocation of data including &lt;code&gt;struct&lt;/code&gt;s and &lt;code&gt;class&lt;/code&gt;es, and also array primitives related to allocation. This module is the entry point for both making use of allocators and for their documentation.</source>
          <target state="translated">할당자를위한 고급 인터페이스. &lt;code&gt;struct&lt;/code&gt; 및 &lt;code&gt;class&lt;/code&gt; es를 포함하여 데이터의 번들 할당 / 생성 및 파기 / 할당을 구현 하고 할당과 관련된 배열 프리미티브도 구현합니다. 이 모듈은 할당자를 사용하고 문서화하기위한 시작점입니다.</target>
        </trans-unit>
        <trans-unit id="e4a71da2c94aa8ebb4eabe525bf9bfaf87c49456" translate="yes" xml:space="preserve">
          <source>Highest generated value (&lt;code&gt;modulus - 1&lt;/code&gt;).</source>
          <target state="translated">가장 높은 생성 값 ( &lt;code&gt;modulus - 1&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="9a7ebfdbeeab34f9a74c5ea30182aae05ebb58ca" translate="yes" xml:space="preserve">
          <source>Highest possible &lt;code&gt;LogLevel&lt;/code&gt;.</source>
          <target state="translated">가능한 가장 높은 &lt;code&gt;LogLevel&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="464c7e7834d9d7bd5320fc6bf866ca1e41042986" translate="yes" xml:space="preserve">
          <source>Highlighting</source>
          <target state="translated">Highlighting</target>
        </trans-unit>
        <trans-unit id="b95101e7e46150f6462631854125e5fff96c059a" translate="yes" xml:space="preserve">
          <source>Highlighting of D code is performed by the following macros:</source>
          <target state="translated">D 코드 강조 표시는 다음 매크로에 의해 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="683f475e2ebb85d31bca86c12acb027ecf0e8eb2" translate="yes" xml:space="preserve">
          <source>Highlighting of D keywords</source>
          <target state="translated">D 키워드 강조</target>
        </trans-unit>
        <trans-unit id="c4ca1644d89763135e446cfbeade41acbff8ee52" translate="yes" xml:space="preserve">
          <source>Highlighting of D keywords.</source>
          <target state="translated">D 키워드 강조</target>
        </trans-unit>
        <trans-unit id="935e04346b38d14f49040acb6c379fad11a7bf81" translate="yes" xml:space="preserve">
          <source>Highlighting of a function parameter section.</source>
          <target state="translated">기능 파라미터 섹션의 하이라이트.</target>
        </trans-unit>
        <trans-unit id="826389bac96eaeab4717271d63b43c94f3297c72" translate="yes" xml:space="preserve">
          <source>Highlighting of a name=value function parameter.</source>
          <target state="translated">이름 = 값 함수 매개 변수 강조 표시.</target>
        </trans-unit>
        <trans-unit id="51eda7a8eeff739d414894834699b4db25dca6d2" translate="yes" xml:space="preserve">
          <source>Highlighting of a template constraint.</source>
          <target state="translated">템플릿 제약 조건 강조</target>
        </trans-unit>
        <trans-unit id="cc13dc42b045774509fcd534fa3f901ea5ee4636" translate="yes" xml:space="preserve">
          <source>Highlighting of a template's individual parameters.</source>
          <target state="translated">템플릿의 개별 매개 변수를 강조 표시합니다.</target>
        </trans-unit>
        <trans-unit id="61100e35b4349aa073e0605d9e5a97e7d22147a5" translate="yes" xml:space="preserve">
          <source>Highlighting of a template's parameter list.</source>
          <target state="translated">템플릿 매개 변수 목록 강조</target>
        </trans-unit>
        <trans-unit id="c13fcc9292d599790bf9edbd77af674db96191fd" translate="yes" xml:space="preserve">
          <source>Highlighting of all the members of a class.</source>
          <target state="translated">수업의 모든 구성원을 강조합니다.</target>
        </trans-unit>
        <trans-unit id="e4ae17c8f2cb1ec34256f6f0903677d6b391295e" translate="yes" xml:space="preserve">
          <source>Highlighting of all the members of a module.</source>
          <target state="translated">모듈의 모든 멤버를 강조 표시합니다.</target>
        </trans-unit>
        <trans-unit id="c09feb09e99ce22a8559d127647547ccdb5c7c15" translate="yes" xml:space="preserve">
          <source>Highlighting of all the members of a struct.</source>
          <target state="translated">구조체의 모든 멤버를 강조 표시합니다.</target>
        </trans-unit>
        <trans-unit id="cbef76e4daad8898695a45761c2de54a52f8635b" translate="yes" xml:space="preserve">
          <source>Highlighting of all the members of a template.</source>
          <target state="translated">템플릿의 모든 멤버를 강조 표시합니다.</target>
        </trans-unit>
        <trans-unit id="0faf83c3ae32ade36ccd67312a59a723e525d473" translate="yes" xml:space="preserve">
          <source>Highlighting of all the members of an enum.</source>
          <target state="translated">열거 형의 모든 멤버를 강조 표시합니다.</target>
        </trans-unit>
        <trans-unit id="e8d93f96992576e6ba1194d00e53b1efd8bd3019" translate="yes" xml:space="preserve">
          <source>Highlighting of all the sections.</source>
          <target state="translated">모든 섹션을 강조 표시합니다.</target>
        </trans-unit>
        <trans-unit id="4778b67265bf5d04ac6df97ab091affb27b022ea" translate="yes" xml:space="preserve">
          <source>Highlighting of auto-detected keywords</source>
          <target state="translated">자동 감지 된 키워드 강조</target>
        </trans-unit>
        <trans-unit id="dd81b3fecd0f20ab2c7c2cd23019f77363841968" translate="yes" xml:space="preserve">
          <source>Highlighting of auto-detected parameters</source>
          <target state="translated">자동 감지 매개 변수 강조</target>
        </trans-unit>
        <trans-unit id="2d5dbc630aa84bc9b06ad40e57222a60ed6a293a" translate="yes" xml:space="preserve">
          <source>Highlighting of auto-detected symbol</source>
          <target state="translated">자동 감지 기호 강조</target>
        </trans-unit>
        <trans-unit id="5a59602c4760ed030bee0db0f8f2fc1e157c8fe6" translate="yes" xml:space="preserve">
          <source>Highlighting of auto-detected symbol that starts with underscore</source>
          <target state="translated">밑줄로 시작하는 자동 감지 기호 강조</target>
        </trans-unit>
        <trans-unit id="03eeb845c1ab1c169a400e57021a9975be5fcd70" translate="yes" xml:space="preserve">
          <source>Highlighting of comments</source>
          <target state="translated">주석 강조</target>
        </trans-unit>
        <trans-unit id="b342620229626113c8bd37f08c3e00019479575f" translate="yes" xml:space="preserve">
          <source>Highlighting of current declaration name</source>
          <target state="translated">현재 선언 이름 강조</target>
        </trans-unit>
        <trans-unit id="176f12498ba670eeda224994c2d82350441886fe" translate="yes" xml:space="preserve">
          <source>Highlighting of current function declaration parameters</source>
          <target state="translated">현재 함수 선언 파라미터의 하이라이트</target>
        </trans-unit>
        <trans-unit id="6b99cfaf4826b1d374574b650af15bdd57440bdb" translate="yes" xml:space="preserve">
          <source>Highlighting of declaration name to which a particular section is referring.</source>
          <target state="translated">특정 섹션이 참조하는 선언 이름 강조</target>
        </trans-unit>
        <trans-unit id="0ccd215d873103285e575951e68bee16377784a3" translate="yes" xml:space="preserve">
          <source>Highlighting of ditto declarations.</source>
          <target state="translated">ditto 선언 강조</target>
        </trans-unit>
        <trans-unit id="e60176b3b0d8bba6525dbfb5d2184816b026c16d" translate="yes" xml:space="preserve">
          <source>Highlighting of function parameters.</source>
          <target state="translated">기능 매개 변수 강조 표시.</target>
        </trans-unit>
        <trans-unit id="738f3d1a73adb20a6fc751e428562fd5770c4fbf" translate="yes" xml:space="preserve">
          <source>Highlighting of non-special sections is done.</source>
          <target state="translated">비 특수 섹션의 강조 표시가 완료되었습니다.</target>
        </trans-unit>
        <trans-unit id="4e9319188986e049a769be81e81ed23eb17972c2" translate="yes" xml:space="preserve">
          <source>Highlighting of string literals</source>
          <target state="translated">문자열 리터럴 강조</target>
        </trans-unit>
        <trans-unit id="9dc393c818c0c8fcccd04642b35f2031235608ef" translate="yes" xml:space="preserve">
          <source>Highlighting of the authors section.</source>
          <target state="translated">저자 섹션의 하이라이트.</target>
        </trans-unit>
        <trans-unit id="c04db9dc0d813c1ccd8c3f2345ab8b620b85f230" translate="yes" xml:space="preserve">
          <source>Highlighting of the base type of a class.</source>
          <target state="translated">클래스의 기본 유형을 강조합니다.</target>
        </trans-unit>
        <trans-unit id="a07587fe4175acb9782fe36fd142c60cdfdd6da4" translate="yes" xml:space="preserve">
          <source>Highlighting of the bugs section.</source>
          <target state="translated">버그 섹션 강조</target>
        </trans-unit>
        <trans-unit id="7882769ed43990ada8c8b23f2c29f9e27cd0f71b" translate="yes" xml:space="preserve">
          <source>Highlighting of the contents of a non-standard section.</source>
          <target state="translated">비표준 섹션의 내용을 강조 표시합니다.</target>
        </trans-unit>
        <trans-unit id="4f9d3c220f1308abbd19a33e68d9159fe1a7bcac" translate="yes" xml:space="preserve">
          <source>Highlighting of the copyright section.</source>
          <target state="translated">저작권 섹션 강조</target>
        </trans-unit>
        <trans-unit id="7d6e48fe7e09c72518d7c42b2053ac6afd252e38" translate="yes" xml:space="preserve">
          <source>Highlighting of the date section.</source>
          <target state="translated">날짜 섹션을 강조 표시합니다.</target>
        </trans-unit>
        <trans-unit id="895c3d9b137fe00aae27a823464b74cfac8c6e8b" translate="yes" xml:space="preserve">
          <source>Highlighting of the declaration.</source>
          <target state="translated">선언의 강조.</target>
        </trans-unit>
        <trans-unit id="63dc31f05686ee2516c9b1d4403bc34707de916c" translate="yes" xml:space="preserve">
          <source>Highlighting of the deprecated section.</source>
          <target state="translated">더 이상 사용되지 않는 섹션 강조 표시</target>
        </trans-unit>
        <trans-unit id="c8decd9303e1480e7050896c2d68e41aba55a19d" translate="yes" xml:space="preserve">
          <source>Highlighting of the description of a declaration.</source>
          <target state="translated">선언의 설명을 강조합니다.</target>
        </trans-unit>
        <trans-unit id="c34c68b3feaf8a8af047b5dc0b27284ee8a4a976" translate="yes" xml:space="preserve">
          <source>Highlighting of the description section.</source>
          <target state="translated">설명 섹션 강조 표시</target>
        </trans-unit>
        <trans-unit id="66395af507be6d2f2c64374c4dcc34d87ba08e37" translate="yes" xml:space="preserve">
          <source>Highlighting of the examples section.</source>
          <target state="translated">예제 섹션의 하이라이트.</target>
        </trans-unit>
        <trans-unit id="6c9891d5d62ba75e6f4bc3861099aa91d8757c3e" translate="yes" xml:space="preserve">
          <source>Highlighting of the history section.</source>
          <target state="translated">역사 섹션의 하이라이트.</target>
        </trans-unit>
        <trans-unit id="b7f85e62f0cd3405e5bd64486a1604e80fdbaccf" translate="yes" xml:space="preserve">
          <source>Highlighting of the license section.</source>
          <target state="translated">라이센스 섹션 강조</target>
        </trans-unit>
        <trans-unit id="a1bf0eef04a7e415262c4a93c4981e89e888edcc" translate="yes" xml:space="preserve">
          <source>Highlighting of the parameter name.</source>
          <target state="translated">매개 변수 이름 강조 표시.</target>
        </trans-unit>
        <trans-unit id="f88d01cfff7b61b2efa32b18d2de859fdd295ab7" translate="yes" xml:space="preserve">
          <source>Highlighting of the parameter value.</source>
          <target state="translated">매개 변수 값 강조 표시.</target>
        </trans-unit>
        <trans-unit id="e1964e06337cb784d3309fe34806373d2ea7eb8f" translate="yes" xml:space="preserve">
          <source>Highlighting of the returns section.</source>
          <target state="translated">반품 섹션 강조</target>
        </trans-unit>
        <trans-unit id="833453d17a268f3c235ee74c7f3da2609550d437" translate="yes" xml:space="preserve">
          <source>Highlighting of the section name of a non-standard section.</source>
          <target state="translated">비표준 섹션의 섹션 이름을 강조 표시합니다.</target>
        </trans-unit>
        <trans-unit id="c7903d232b908137bafe89e336276f896f569fc5" translate="yes" xml:space="preserve">
          <source>Highlighting of the see-also section.</source>
          <target state="translated">참조 섹션 강조 표시.</target>
        </trans-unit>
        <trans-unit id="df390d31d75e9b616a073ce0adb1eeb2634d7fd5" translate="yes" xml:space="preserve">
          <source>Highlighting of the standards section.</source>
          <target state="translated">표준 섹션 강조</target>
        </trans-unit>
        <trans-unit id="f0d2af38c35f5e37acd97274204555972b2988bd" translate="yes" xml:space="preserve">
          <source>Highlighting of the summary section.</source>
          <target state="translated">요약 섹션 강조</target>
        </trans-unit>
        <trans-unit id="21e5f168213fe615e9ee4675e90cca4182bf4f11" translate="yes" xml:space="preserve">
          <source>Highlighting of the throws section.</source>
          <target state="translated">던지기 섹션의 하이라이트.</target>
        </trans-unit>
        <trans-unit id="0dff0c156a9e500788193fc7d13465ffae833297" translate="yes" xml:space="preserve">
          <source>Highlighting of the type an enum is based upon</source>
          <target state="translated">열거 형이 기반한 유형의 강조</target>
        </trans-unit>
        <trans-unit id="6b50d26c177d3621167352e70fcbe2f923cd28c3" translate="yes" xml:space="preserve">
          <source>Highlighting of the version section.</source>
          <target state="translated">버전 섹션 강조</target>
        </trans-unit>
        <trans-unit id="ba1d0a643c81d860412a884b89435cac1cf023d7" translate="yes" xml:space="preserve">
          <source>Hiragana</source>
          <target state="translated">Hiragana</target>
        </trans-unit>
        <trans-unit id="835fe32e11d06c07988640ea18d5a882081aeaae" translate="yes" xml:space="preserve">
          <source>History:</source>
          <target state="translated">History:</target>
        </trans-unit>
        <trans-unit id="b44fed8b2ad60db45d1dfeb77fbed8d582ca1505" translate="yes" xml:space="preserve">
          <source>Hoist-load + hoist-store barrier. Corresponds to &lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquire&quot;&gt;LLVM AtomicOrdering.Acquire&lt;/a&gt; and C++11/C11 &lt;code&gt;memory_order_acquire&lt;/code&gt;.</source>
          <target state="translated">호이스트 하중 + 호이스트 매장 장벽. 에 해당하는 &lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquire&quot;&gt;LLVM AtomicOrdering.Acquire&lt;/a&gt; 및 C ++ 11 / C11의 &lt;code&gt;memory_order_acquire&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8e61310c65ecb57873a154d2408b9cc4403ad4a2" translate="yes" xml:space="preserve">
          <source>Holds information about a socket address retrieved by &lt;code&gt;getAddressInfo&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;getAddressInfo&lt;/code&gt; 로 검색된 소켓 주소에 대한 정보를 보유합니다 .</target>
        </trans-unit>
        <trans-unit id="c10ba96a990de4f937f02e9f283e74796b47e3f8" translate="yes" xml:space="preserve">
          <source>Home of the TZ Database files</source>
          <target state="translated">TZ 데이터베이스 파일의 홈</target>
        </trans-unit>
        <trans-unit id="b3e0a103daa9ae3f375b2654f0a482c7c0d36297" translate="yes" xml:space="preserve">
          <source>Hook</source>
          <target state="translated">Hook</target>
        </trans-unit>
        <trans-unit id="df83ba56b9bf84a7f6828386bfb0ec0b4ea31298" translate="yes" xml:space="preserve">
          <source>Hook &lt;strong id=&quot;hook&quot;&gt;hook&lt;/strong&gt;;</source>
          <target state="translated">훅 &lt;strong id=&quot;hook&quot;&gt;훅&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="c491dcee1ba5406ded29938b72d3efa58c8898bc" translate="yes" xml:space="preserve">
          <source>Hook for &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;gt;=&lt;/code&gt; that ensures comparison against integral values has the behavior expected by the usual arithmetic rules. The built-in semantics yield surprising behavior when comparing signed values against unsigned values, for example &lt;code&gt;0u &amp;lt; -1&lt;/code&gt;. The call &lt;code&gt;hookOpCmp(x, y)&lt;/code&gt; returns &lt;code&gt;-1&lt;/code&gt; if and only if &lt;code&gt;x&lt;/code&gt; is smaller than &lt;code&gt;y&lt;/code&gt; in abstract arithmetic sense.</source>
          <target state="translated">적분 값과의 비교를 보장 하는 &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;gt;=&lt;/code&gt; 에 대한 후크 는 일반적인 산술 규칙에서 예상되는 동작을 갖습니다. 내장 의미론은 부호있는 값과 부호없는 값 (예 : &lt;code&gt;0u &amp;lt; -1&lt;/code&gt; 비교할 때 놀라운 동작을 생성 합니다. 호출 &lt;code&gt;hookOpCmp(x, y)&lt;/code&gt; 는 &lt;code&gt;x&lt;/code&gt; 가 추상 산술적 의미에서 &lt;code&gt;y&lt;/code&gt; 보다 작은 경우에만 &lt;code&gt;-1&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="9cf42c2609ccf8480c4c29b09d1eeb015d535402" translate="yes" xml:space="preserve">
          <source>Hook for &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt; that ensures comparison against integral values has the behavior expected by the usual arithmetic rules. The built-in semantics yield surprising behavior when comparing signed values against unsigned values for equality, for example &lt;code&gt;uint.max == -1&lt;/code&gt; or &lt;code&gt;-1_294_967_296 == 3_000_000_000u&lt;/code&gt;. The call &lt;code&gt;hookOpEquals(x, y)&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; if and only if &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; represent the same arithmetic number.</source>
          <target state="translated">적분 값과의 비교를 보장하는 &lt;code&gt;==&lt;/code&gt; 및 &lt;code&gt;!=&lt;/code&gt; 용 후크 에는 일반적인 산술 규칙에서 예상되는 동작이 있습니다. 내장 된 시맨틱은 부호있는 값과 부호없는 값을 &lt;code&gt;uint.max == -1&lt;/code&gt; 예 : uint.max == -1 또는 &lt;code&gt;-1_294_967_296 == 3_000_000_000u&lt;/code&gt; 비교할 때 놀라운 동작을 생성 합니다. &lt;code&gt;hookOpEquals(x, y)&lt;/code&gt; 호출 은 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 가 동일한 산술 숫자를 나타내는 경우에만 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="041c61fdd24218cf59730fd0cdbaa1de754b6893" translate="yes" xml:space="preserve">
          <source>Hook that implements</source>
          <target state="translated">구현하는 후크</target>
        </trans-unit>
        <trans-unit id="b449d04fd061c7af394902d015ecf01abcf02e96" translate="yes" xml:space="preserve">
          <source>Hook that prints to &lt;code&gt;stderr&lt;/code&gt; a trace of all integral errors, without affecting default behavior.</source>
          <target state="translated">기본 동작에 영향을주지 않으면 서 모든 필수 오류의 흔적 을 &lt;code&gt;stderr&lt;/code&gt; 에 인쇄하는 후크 .</target>
        </trans-unit>
        <trans-unit id="efbf28167139074d8823a898190b189c85ea78aa" translate="yes" xml:space="preserve">
          <source>Hook that provides arithmetically correct comparisons for equality and ordering. Comparing an object of type &lt;code&gt;Checked!(X, ProperCompare)&lt;/code&gt; against another integral (for equality or ordering) ensures that no surprising conversions from signed to unsigned integral occur before the comparison. Using &lt;code&gt;Checked!(X, ProperCompare)&lt;/code&gt; on either side of a comparison for equality against a floating-point number makes sure the integral can be properly converted to the floating point type, thus making sure equality is transitive.</source>
          <target state="translated">평등과 순서에 대해 산술적으로 올바른 비교를 제공하는 후크. &lt;code&gt;Checked!(X, ProperCompare)&lt;/code&gt; 유형의 객체를 다른 적분 (동일 또는 순서)과 비교하면 비교 전에 부호있는 적분에서 부호없는 적분으로의 놀라운 변환이 발생하지 않습니다. 사용 &lt;code&gt;Checked!(X, ProperCompare)&lt;/code&gt; 부동 소수점 숫자 같은지 비교의 양쪽에있는 것은 따라서 반드시 평등 이행되게 부동 소수점 입력해야합니다 적분이 제대로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d806e6661a85f88dc9eaa221319b2117db0f755d" translate="yes" xml:space="preserve">
          <source>Hook that reserves a special value as a &quot;Not a Number&quot; representative. For signed integrals, the reserved value is &lt;code&gt;T.min&lt;/code&gt;. For signed integrals, the reserved value is &lt;code&gt;T.max&lt;/code&gt;.</source>
          <target state="translated">&quot;숫자가 아님&quot;담당자로서 특별한 가치를 보유하는 후크. 부호있는 적분의 경우 예약 된 값은 &lt;code&gt;T.min&lt;/code&gt; 입니다. 부호있는 적분의 경우 예약 된 값은 &lt;code&gt;T.max&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="33488d4b3cbb5ba16b0673469e60db7094fb670e" translate="yes" xml:space="preserve">
          <source>Horizontal Rules</source>
          <target state="translated">수평 규칙</target>
        </trans-unit>
        <trans-unit id="7212f381e90838fabdee36fb0501fbba0ed9cd58" translate="yes" xml:space="preserve">
          <source>Horizontal tab</source>
          <target state="translated">가로 탭</target>
        </trans-unit>
        <trans-unit id="3ac6fafe4ab0f338471b45cb71f20d044e5f5cc2" translate="yes" xml:space="preserve">
          <source>Horizontal tab (U+0009).</source>
          <target state="translated">가로 탭 (U + 0009).</target>
        </trans-unit>
        <trans-unit id="bbb1b4f452c31b5eb2b5c0983d50e71cb342831f" translate="yes" xml:space="preserve">
          <source>Host compiler vendor string and language version.</source>
          <target state="translated">호스트 컴파일러 공급 업체 문자열 및 언어 버전.</target>
        </trans-unit>
        <trans-unit id="e118cd39d323f526da5b0f63e4f3c3b86e96af36" translate="yes" xml:space="preserve">
          <source>Hour of the day [0 - 24).</source>
          <target state="translated">하루 중 시간 [0-24).</target>
        </trans-unit>
        <trans-unit id="47f45a8e9beb5422f5775e424c56239ab38cf0a6" translate="yes" xml:space="preserve">
          <source>Hours past midnight.</source>
          <target state="translated">자정이 지난 시간.</target>
        </trans-unit>
        <trans-unit id="aea1f84448c4cd135127feb893d3e5b86649ead7" translate="yes" xml:space="preserve">
          <source>How Garbage Collection Works</source>
          <target state="translated">가비지 콜렉션 작동 방식</target>
        </trans-unit>
        <trans-unit id="5e1ecfe3dd4c1b701a8f4295c2bd308de6db519e" translate="yes" xml:space="preserve">
          <source>How a socket is shutdown:</source>
          <target state="translated">소켓이 종료되는 방법 :</target>
        </trans-unit>
        <trans-unit id="14072cd783ee679dcd4faa9d6011722e64957f7d" translate="yes" xml:space="preserve">
          <source>How does this meet our assumptions about errors?</source>
          <target state="translated">이것이 오류에 대한 우리의 가정을 어떻게 충족 시키는가?</target>
        </trans-unit>
        <trans-unit id="2cef028c4c427db32ab248fb0fa09f711b8938d4" translate="yes" xml:space="preserve">
          <source>How does this meet our criteria?</source>
          <target state="translated">이것이 우리의 기준을 어떻게 충족 시키는가?</target>
        </trans-unit>
        <trans-unit id="46c019e7726b602bf175d16d3e47d3c9855717af" translate="yes" xml:space="preserve">
          <source>How much &lt;code&gt;r&lt;/code&gt; was actually advanced, which may be less than &lt;code&gt;n&lt;/code&gt; if &lt;code&gt;r&lt;/code&gt; did not have at least &lt;code&gt;n&lt;/code&gt; elements.</source>
          <target state="translated">실제로 &lt;code&gt;r&lt;/code&gt; 이 얼마나 많이 진행 되었는지, &lt;code&gt;r&lt;/code&gt; 에 &lt;code&gt;n&lt;/code&gt; 개 이상의 요소 가없는 경우 &lt;code&gt;n&lt;/code&gt; 보다 작을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="39a1caec9f5c9eff0c38eb6253af004f14eeaf48" translate="yes" xml:space="preserve">
          <source>How the deprecation messages are presented to the user.</source>
          <target state="translated">사용 중단 메시지가 사용자에게 표시되는 방법</target>
        </trans-unit>
        <trans-unit id="45ad0b30a0ba21c8300555e31b930fb7fa5c8e56" translate="yes" xml:space="preserve">
          <source>How to check an entire string</source>
          <target state="translated">전체 문자열을 확인하는 방법</target>
        </trans-unit>
        <trans-unit id="3944bdd486c5b281b0d76b6fea24f7aa42d88928" translate="yes" xml:space="preserve">
          <source>However for class types, identity assignment is not allowed. All class types have reference semantics, so identity assignment by default rebinds the left-hand-side to the argument at the right, and this is not overridable.</source>
          <target state="translated">그러나 클래스 유형의 경우 ID 할당이 허용되지 않습니다. 모든 클래스 유형에는 참조 시맨틱이 있으므로 기본적으로 ID 지정은 왼쪽을 오른쪽의 인수에 리 바인드하며 이는 무시할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d81485ead3a03b09d4ef041206a388f9ba3d1726" translate="yes" xml:space="preserve">
          <source>However, &lt;code&gt;Rebindable!(Widget)&lt;/code&gt; does allow reassignment, while otherwise behaving exactly like a &lt;code&gt;const Widget&lt;/code&gt;.</source>
          <target state="translated">그러나 &lt;code&gt;Rebindable!(Widget)&lt;/code&gt; 은 재 할당을 허용 하지만 &lt;code&gt;const Widget&lt;/code&gt; 과 정확히 동일하게 동작합니다 .</target>
        </trans-unit>
        <trans-unit id="39fcf81b03ae2153072256cf5c2ed783812c0162" translate="yes" xml:space="preserve">
          <source>However, if the AA element type is a struct which supports an implicit constructor call from the assigned value, implicit construction is used for setting the AA entry:</source>
          <target state="translated">그러나 AA 요소 유형이 지정된 값에서 내재 된 생성자 호출을 지원하는 구조체 인 경우 내재 구성은 AA 항목을 설정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="be6cc5f771eb95dadab03bad5c4c89972ffb70a4" translate="yes" xml:space="preserve">
          <source>However, in &lt;code&gt;-betterC&lt;/code&gt;&lt;code&gt;assert&lt;/code&gt; expressions don't use Druntime's assert and are directed to &lt;code&gt;assert&lt;/code&gt; of the C runtime library instead.</source>
          <target state="translated">그러나 &lt;code&gt;-betterC&lt;/code&gt; 에서 &lt;code&gt;assert&lt;/code&gt; 표현식은 Druntime의 assert를 사용하지 않으며 대신 C 런타임 라이브러리의 &lt;code&gt;assert&lt;/code&gt; 로 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="5a66b8122994e01e172373073ab6d4fa34b94942" translate="yes" xml:space="preserve">
          <source>However, it should be noted that the time zone information on Windows is frequently less accurate than that in the IANA time zone database, and if someone really wants accurate time zone information, they should use the IANA time zone database files with &lt;a href=&quot;#PosixTimeZone&quot;&gt;&lt;code&gt;PosixTimeZone&lt;/code&gt;&lt;/a&gt; on Windows rather than &lt;a href=&quot;#WindowsTimeZone&quot;&gt;&lt;code&gt;WindowsTimeZone&lt;/code&gt;&lt;/a&gt;, whereas &lt;a href=&quot;#WindowsTimeZone&quot;&gt;&lt;code&gt;WindowsTimeZone&lt;/code&gt;&lt;/a&gt; makes more sense when trying to match what Windows will think the time is in a specific time zone.</source>
          <target state="translated">그러나 Windows의 표준 시간대 정보는 IANA 표준 시간대 데이터베이스의 표준 시간대 정보보다 정확도가 떨어지는 경우가 많으며, 누군가가 정확한 표준 시간대 정보를 원할 경우 Windows의 &lt;a href=&quot;#PosixTimeZone&quot;&gt; &lt;code&gt;PosixTimeZone&lt;/code&gt; &lt;/a&gt; 과 함께 IANA 표준 시간대 데이터베이스 파일을 사용해야합니다 . 보다 &lt;a href=&quot;#WindowsTimeZone&quot;&gt; &lt;code&gt;WindowsTimeZone&lt;/code&gt; &lt;/a&gt; 반면, &lt;a href=&quot;#WindowsTimeZone&quot;&gt; &lt;code&gt;WindowsTimeZone&lt;/code&gt; 이&lt;/a&gt; 더 의미가 Windows가 시간이 특정 시간대에 생각됩니다 일치 할 때.</target>
        </trans-unit>
        <trans-unit id="6fe9389c4ddd121d6493079f489aee81befd5618" translate="yes" xml:space="preserve">
          <source>However, on Windows, it may be the unabbreviated name (e.g. Pacific Daylight Time). Regardless, it is not the same as name.</source>
          <target state="translated">그러나 Windows에서는 약식 이름 (예 : 태평양 일광 절약 시간) 일 수 있습니다. 어쨌든 이름과 같지 않습니다.</target>
        </trans-unit>
        <trans-unit id="47c13d8e213a10f9001fd45644c1b3afeb68823d" translate="yes" xml:space="preserve">
          <source>However, on Windows, it may be the unabbreviated name (e.g. Pacific Standard Time). Regardless, it is not the same as name.</source>
          <target state="translated">그러나 Windows에서는 약식 이름 (예 : 태평양 표준시) 일 수 있습니다. 어쨌든 이름과 같지 않습니다.</target>
        </trans-unit>
        <trans-unit id="eff8dd0f2d633371467a00fc8759aea595ab2872" translate="yes" xml:space="preserve">
          <source>However, when doing overload resolution, the functions in the base class are not considered:</source>
          <target state="translated">그러나 과부하 해결을 수행 할 때 기본 클래스의 함수는 고려되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="599b7a863c6a59d1092f07e1710589a8785bdb8d" translate="yes" xml:space="preserve">
          <source>Human readable string representing the IPv4 address in dotted-decimal form.</source>
          <target state="translated">점으로 구분 된 십진수 형식으로 IPv4 주소를 나타내는 사람이 읽을 수있는 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="aff39bc2ec043587101457aaa3ae19023826875e" translate="yes" xml:space="preserve">
          <source>Human readable string representing the IPv4 port.</source>
          <target state="translated">IPv4 포트를 나타내는 사람이 읽을 수있는 문자열.</target>
        </trans-unit>
        <trans-unit id="a79746cad8ecf9d33b60d8dd5347136a9d85ef98" translate="yes" xml:space="preserve">
          <source>Human readable string representing this address.</source>
          <target state="translated">이 주소를 나타내는 사람이 읽을 수있는 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="4c4d996a690c3ac43662d610a18221ccc97faec3" translate="yes" xml:space="preserve">
          <source>Hyphen</source>
          <target state="translated">Hyphen</target>
        </trans-unit>
        <trans-unit id="ca73ab65568cd125c2d27a22bbd9e863c10b675d" translate="yes" xml:space="preserve">
          <source>I</source>
          <target state="translated">I</target>
        </trans-unit>
        <trans-unit id="47af55839c3e9c9ba933349c6295cd1ce082a6a3" translate="yes" xml:space="preserve">
          <source>I &lt;code&gt;im&lt;/code&gt;</source>
          <target state="translated">나는 &lt;code&gt;im&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="84ff080e0a1bf2c778d5efdc523acd4678a5928f" translate="yes" xml:space="preserve">
          <source>I &lt;code&gt;sizes&lt;/code&gt;</source>
          <target state="translated">나는 &lt;code&gt;sizes&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d4ce4e386de11613809ef416e70170284dffb219" translate="yes" xml:space="preserve">
          <source>I &lt;code&gt;startingIndex&lt;/code&gt;</source>
          <target state="translated">색인 &lt;code&gt;startingIndex&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3df1df26aa4ea931d9e988f62da215ed0c3e81a7" translate="yes" xml:space="preserve">
          <source>I came, I coded, I crashed.</source>
          <target state="translated">내가 와서 코딩하고 충돌했습니다.</target>
        </trans-unit>
        <trans-unit id="81cb37800b131d16bca390e388601790ff6f313b" translate="yes" xml:space="preserve">
          <source>I.e. is it a single return statement or some compound statement that unconditionally hits a return statement.</source>
          <target state="translated">즉, 단일 반환 문이거나 무조건 반환 문에 도달하는 복합 문입니다.</target>
        </trans-unit>
        <trans-unit id="d8212950b3ac05f1c5deaff0d3a32ce51c051e7f" translate="yes" xml:space="preserve">
          <source>I/O operation successful</source>
          <target state="translated">I / O 작업 성공</target>
        </trans-unit>
        <trans-unit id="a07107356f25616c07b6fd35ca4ce30f409251c5" translate="yes" xml:space="preserve">
          <source>IBM Advanced Interactive eXecutive OS</source>
          <target state="translated">IBM Advanced Interactive eXecutive OS</target>
        </trans-unit>
        <trans-unit id="7e73f4b459341f6552e0a60723ed4f4fb582c963" translate="yes" xml:space="preserve">
          <source>IDS_Binary_Operator</source>
          <target state="translated">IDS_Binary_Operator</target>
        </trans-unit>
        <trans-unit id="dfddbbc74d0d43db63cde2a6e1024f6ba8221fff" translate="yes" xml:space="preserve">
          <source>IDS_Trinary_Operator</source>
          <target state="translated">IDS_Trinary_Operator</target>
        </trans-unit>
        <trans-unit id="0a50f9983af5839dd0d0dc6f249331d57b64db6f" translate="yes" xml:space="preserve">
          <source>ID_Continue</source>
          <target state="translated">ID_Continue</target>
        </trans-unit>
        <trans-unit id="92936d6f1e8f3e471e6f43d46a9887af5d007bd8" translate="yes" xml:space="preserve">
          <source>ID_Start</source>
          <target state="translated">ID_Start</target>
        </trans-unit>
        <trans-unit id="3f4e414c32b3902ba3f69c8b82e07f90e3313525" translate="yes" xml:space="preserve">
          <source>IEEE 754 floating point arithmetic can set several flags based on what happened with a computation:</source>
          <target state="translated">IEEE 754 부동 소수점 산술은 계산 결과에 따라 몇 가지 플래그를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca31149be1b5f9a497eaee503fda4915c7e1c829" translate="yes" xml:space="preserve">
          <source>IEEE 754 floating point arithmetic includes the ability to set 4 different rounding modes. These are accessible via the functions in &lt;code&gt;core.stdc.fenv&lt;/code&gt;.</source>
          <target state="translated">IEEE 754 부동 소수점 산술에는 4 가지 다른 반올림 모드를 설정하는 기능이 포함되어 있습니다. 이들은 &lt;code&gt;core.stdc.fenv&lt;/code&gt; 의 기능을 통해 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c9fbff470ecc71dad6d33f5eeaccc83f4e863050" translate="yes" xml:space="preserve">
          <source>IEEE exception status flags ('sticky bits')</source>
          <target state="translated">IEEE 예외 상태 플래그 ( '스티커 비트')</target>
        </trans-unit>
        <trans-unit id="a2584841fe85abc74e15db0f23c9cdba2dd8ab2a" translate="yes" xml:space="preserve">
          <source>IEEE hardware exceptions. By default, all exceptions are masked (disabled).</source>
          <target state="translated">IEEE 하드웨어 예외. 기본적으로 모든 예외는 마스킹 (비활성화)됩니다.</target>
        </trans-unit>
        <trans-unit id="b9e2d958b9ca41f87ae15ec8c35999c50ae4ff8c" translate="yes" xml:space="preserve">
          <source>IEEE rounding modes. The default mode is roundToNearest.</source>
          <target state="translated">IEEE 반올림 모드. 기본 모드는 roundToNearest입니다.</target>
        </trans-unit>
        <trans-unit id="7d81343ef8eab15b8d8f8c68c7c8bdb404ed88bb" translate="yes" xml:space="preserve">
          <source>ILS &lt;strong id=&quot;inlineStatusStmt&quot;&gt;inlineStatusStmt&lt;/strong&gt;;</source>
          <target state="translated">ILS &lt;strong id=&quot;inlineStatusStmt&quot;&gt;inlineStatusStmt&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="362fa36f30a060b9e1fcf247cb78ff4ce49924f2" translate="yes" xml:space="preserve">
          <source>IMP</source>
          <target state="translated">IMP</target>
        </trans-unit>
        <trans-unit id="bdc4004339f8557d5a75257afe0bb8aef0ebaaba" translate="yes" xml:space="preserve">
          <source>IP multicast hops</source>
          <target state="translated">IP 멀티 캐스트 홉</target>
        </trans-unit>
        <trans-unit id="20fe7e463770b20399ece7b586c1bbb5d3def572" translate="yes" xml:space="preserve">
          <source>IP multicast interface</source>
          <target state="translated">IP 멀티 캐스트 인터페이스</target>
        </trans-unit>
        <trans-unit id="7279e4b3160656f1f51a778df4e83b92cb83cf30" translate="yes" xml:space="preserve">
          <source>IP multicast loopback</source>
          <target state="translated">IP 멀티 캐스트 루프백</target>
        </trans-unit>
        <trans-unit id="9ebd1fbe7ba3cf5bdc775290d0d686e15bf4c0b2" translate="yes" xml:space="preserve">
          <source>IP unicast hop limit</source>
          <target state="translated">IP 유니 캐스트 홉 제한</target>
        </trans-unit>
        <trans-unit id="cc01b492cee0acdf48f0b298c26fa47256bd3faf" translate="yes" xml:space="preserve">
          <source>IPA Extensions</source>
          <target state="translated">IPA 확장</target>
        </trans-unit>
        <trans-unit id="80570baac1433d8da38eb560349f85ffa3c24938" translate="yes" xml:space="preserve">
          <source>IPv6 address ends with a single colon</source>
          <target state="translated">IPv6 주소는 단일 콜론으로 끝납니다</target>
        </trans-unit>
        <trans-unit id="f971f61e6734e2eb397d8944032e3b5547c71b4c" translate="yes" xml:space="preserve">
          <source>IPv6 address starts with a single colon</source>
          <target state="translated">IPv6 주소는 단일 콜론으로 시작</target>
        </trans-unit>
        <trans-unit id="ffeae36229b4084ab3f5431d5a5e2894acff57f8" translate="yes" xml:space="preserve">
          <source>IPv6-enabled</source>
          <target state="translated">IPv6-enabled</target>
        </trans-unit>
        <trans-unit id="ae9887477b5a4dc86ce15b0c56db938ec92c9140" translate="yes" xml:space="preserve">
          <source>IRState* &lt;code&gt;irs&lt;/code&gt;</source>
          <target state="translated">IRState * &lt;code&gt;irs&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="445867d9c88cb9ec795d4d1edb4358f7f32ed23d" translate="yes" xml:space="preserve">
          <source>ISO 8601</source>
          <target state="translated">ISO 8601</target>
        </trans-unit>
        <trans-unit id="0f3e173e17d8fbdbf144076143d8cd16c3b60805" translate="yes" xml:space="preserve">
          <source>ISO Week Date</source>
          <target state="translated">ISO 주일</target>
        </trans-unit>
        <trans-unit id="6edb4ac9bcba71ad7ccb4ee02897a84fda819a4e" translate="yes" xml:space="preserve">
          <source>ISO/IEC 9899:1999 (E)</source>
          <target state="translated">ISO / IEC 9899 : 1999 (E)</target>
        </trans-unit>
        <trans-unit id="8e40d146e834aa0554ad9d258a39d303ac74b95c" translate="yes" xml:space="preserve">
          <source>ISO/IEC 9899:1999 (E)  These are the various functions called by the assert() macro. They are all noreturn functions, although D doesn't have a specific attribute for that.</source>
          <target state="translated">ISO / IEC 9899 : 1999 (E) assert () 매크로가 호출하는 다양한 함수입니다. D에는 특정 속성이 없지만 모두 반환 기능입니다.</target>
        </trans-unit>
        <trans-unit id="79c91cb6efbe5dfcc03f77ea0bf59ceecfb03a1b" translate="yes" xml:space="preserve">
          <source>Iain Buclaw</source>
          <target state="translated">이아 인 부 클로</target>
        </trans-unit>
        <trans-unit id="a61268b8e652624d626d166308f20560b1d3aa63" translate="yes" xml:space="preserve">
          <source>Id::max or Id::min</source>
          <target state="translated">Id :: max 또는 Id :: min</target>
        </trans-unit>
        <trans-unit id="06b6ace8ca3f18249e8ba4ea9090c0f34564ce1c" translate="yes" xml:space="preserve">
          <source>Identifier</source>
          <target state="translated">Identifier</target>
        </trans-unit>
        <trans-unit id="d884429135c14548b3e978b368447365cb96cfc8" translate="yes" xml:space="preserve">
          <source>Identifier (inside Identifier.idPool) with deterministic name based on the source location.</source>
          <target state="translated">소스 위치를 기반으로 결정적인 이름을 가진 식별자 (Identifier.idPool 내부)</target>
        </trans-unit>
        <trans-unit id="d39412a656d9c3c7bf8a3a174965f8e76b9c6aae" translate="yes" xml:space="preserve">
          <source>Identifier : NonVoidInitializer</source>
          <target state="translated">식별자 : NonVoidInitializer</target>
        </trans-unit>
        <trans-unit id="2ea823871928966eb34d2d6331730d76f54cfc52" translate="yes" xml:space="preserve">
          <source>Identifier &lt;code&gt;id&lt;/code&gt;</source>
          <target state="translated">식별자 &lt;code&gt;id&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fd812024edf80fc26687c86baab342484d1cca2a" translate="yes" xml:space="preserve">
          <source>Identifier &lt;code&gt;ident&lt;/code&gt;</source>
          <target state="translated">식별자 &lt;code&gt;ident&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f032313123f1ffabc6636b37a2cdfb763957f48d" translate="yes" xml:space="preserve">
          <source>Identifier &lt;code&gt;module_&lt;/code&gt;</source>
          <target state="translated">식별자 &lt;code&gt;module_&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0ff20fb48822c4ece471eaa71420a8e3f17752e0" translate="yes" xml:space="preserve">
          <source>Identifier &lt;strong id=&quot;identifier&quot;&gt;identifier&lt;/strong&gt;;</source>
          <target state="translated">식별자 &lt;strong id=&quot;identifier&quot;&gt;식별자&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="964e8904f66adfee7e7841e9b8d4ec24e389fed4" translate="yes" xml:space="preserve">
          <source>Identifier Emphasis</source>
          <target state="translated">식별자 강조</target>
        </trans-unit>
        <trans-unit id="57fd2f9988cc1bead6d88fdd99fa28550daa5071" translate="yes" xml:space="preserve">
          <source>Identifier required for this condition to pass. If &lt;code&gt;null&lt;/code&gt;, this conditiion will use an integer level.</source>
          <target state="translated">이 조건을 통과하려면 식별자가 필요합니다. 경우 &lt;code&gt;null&lt;/code&gt; 이 conditiion는 정수 수준을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="72a03d37bdb5a52d9cfa01295909001833684faa" translate="yes" xml:space="preserve">
          <source>Identifier value (e.g. &lt;code&gt;Id.unitTest&lt;/code&gt;) or &lt;code&gt;TOK.identifier&lt;/code&gt;</source>
          <target state="translated">식별자 값 (예 : &lt;code&gt;Id.unitTest&lt;/code&gt; ) 또는 &lt;code&gt;TOK.identifier&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="22dcd4202be0468eb915e08817484731c04ef629" translate="yes" xml:space="preserve">
          <source>IdentifierList</source>
          <target state="translated">IdentifierList</target>
        </trans-unit>
        <trans-unit id="649d2864df18704de32e689e69e63f2483e8b76e" translate="yes" xml:space="preserve">
          <source>Identifiers</source>
          <target state="translated">Identifiers</target>
        </trans-unit>
        <trans-unit id="29849b8a9887214097873771c1ada1e4a2b26c67" translate="yes" xml:space="preserve">
          <source>Identifiers in documentation comments that are function parameters or are names that are in scope at the associated declaration are emphasized in the output. This emphasis can take the form of italics, boldface, a hyperlink, etc. How it is emphasized depends on what it is</source>
          <target state="translated">함수 매개 변수이거나 연관된 선언의 범위에 속하는 이름 인 문서 주석의 식별자는 출력에서 ​​강조됩니다. 이 강조는 이탤릭체, 볼드체, 하이퍼 링크 등의 형태를 취할 수 있습니다. 강조되는 방법은 그 의미에 따라 다릅니다</target>
        </trans-unit>
        <trans-unit id="ee26ed57025d5c31d0bf47a619bdb084494918ff" translate="yes" xml:space="preserve">
          <source>Identifiers start with a letter, &lt;code&gt;_&lt;/code&gt;, or universal alpha, and are followed by any number of letters, &lt;code&gt;_&lt;/code&gt;, digits, or universal alphas. Universal alphas are as defined in ISO/IEC 9899:1999(E) Appendix D of the C99 Standard. Identifiers can be arbitrarily long, and are case sensitive.</source>
          <target state="translated">식별자는 문자 &lt;code&gt;_&lt;/code&gt; 또는 유니버설 알파로 시작하고 그 뒤에 여러 문자, &lt;code&gt;_&lt;/code&gt; , 숫자 또는 유니버설 알파 가옵니다 . 범용 알파는 C99 표준의 ISO / IEC 9899 : 1999 (E) 부록 D에 정의되어 있습니다. 식별자는 임의로 길 수 있으며 대소 문자를 구분합니다.</target>
        </trans-unit>
        <trans-unit id="745651339d520944f46b951509355e65410d85d8" translate="yes" xml:space="preserve">
          <source>Identifiers* &lt;code&gt;ids&lt;/code&gt;</source>
          <target state="translated">식별자 * &lt;code&gt;ids&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8bce0759953389b7f6673a7b1dcdcbe2f5adafd6" translate="yes" xml:space="preserve">
          <source>Identifiers* &lt;code&gt;pkg_identifiers&lt;/code&gt;</source>
          <target state="translated">식별자 * &lt;code&gt;pkg_identifiers&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fd196121fbac89b149b3c74f08384f1bdda01148" translate="yes" xml:space="preserve">
          <source>Identify Statement types with this enum rather than virtual functions.</source>
          <target state="translated">가상 함수가 아닌이 열거 형으로 명령문 유형을 식별하십시오.</target>
        </trans-unit>
        <trans-unit id="897cc900af9b1d4567cf3ac949c0ce028e5b29c4" translate="yes" xml:space="preserve">
          <source>Identify the characteristics of the host CPU, providing information about cache sizes and assembly optimisation hints. This module is provided primarily for assembly language programmers.</source>
          <target state="translated">캐시 크기 및 어셈블리 최적화 힌트에 대한 정보를 제공하여 호스트 CPU의 특성을 식별하십시오. 이 모듈은 주로 어셈블리 언어 프로그래머를 위해 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="294c861b2aa613142591a5192af15c07f9d87cde" translate="yes" xml:space="preserve">
          <source>Identify the compiler used and its various features.</source>
          <target state="translated">사용 된 컴파일러와 다양한 기능을 식별하십시오.</target>
        </trans-unit>
        <trans-unit id="2adbbf9ddb856b5eee69eb90a8ddc235f490d75b" translate="yes" xml:space="preserve">
          <source>Identify whether a variable is defined in the environment.</source>
          <target state="translated">환경에 변수가 정의되어 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="560e8754d1a43d2889127379ce8941035430acdf" translate="yes" xml:space="preserve">
          <source>Identity Assignment Overload</source>
          <target state="translated">아이디 할당 과부하</target>
        </trans-unit>
        <trans-unit id="feaad94f17d0151c7ee9d808da8437d06bd6ced9" translate="yes" xml:space="preserve">
          <source>Identity Expressions</source>
          <target state="translated">신원 표현</target>
        </trans-unit>
        <trans-unit id="3541f48427fcdd81e30c7c16278c379163644459" translate="yes" xml:space="preserve">
          <source>Ideographic</source>
          <target state="translated">Ideographic</target>
        </trans-unit>
        <trans-unit id="5b6b53689a3fc635c459675544040944bd74d306" translate="yes" xml:space="preserve">
          <source>Ideographic Description Characters</source>
          <target state="translated">표의 문자 설명</target>
        </trans-unit>
        <trans-unit id="250ad5161fad3e8519e80733a4a75b5049da3f8e" translate="yes" xml:space="preserve">
          <source>Idiomatic Use of &lt;code&gt;std.experimental.allocator&lt;/code&gt;</source>
          <target state="translated">의 관용적 사용 &lt;code&gt;std.experimental.allocator&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="751c68a3471b1c791efaee0a8e7c24ea0c266efd" translate="yes" xml:space="preserve">
          <source>If</source>
          <target state="translated">If</target>
        </trans-unit>
        <trans-unit id="828467146cd8af7a4600851262e42a7b8fdfff46" translate="yes" xml:space="preserve">
          <source>If !is null, elements[] can be sparse and basis is used for the &quot;default&quot; element value. In other words, non-null elements[i] overrides this 'basis' value.</source>
          <target state="translated">!가 null 인 경우 elements []는 희소 할 수 있으며 &quot;default&quot;요소 값에 기본이 사용됩니다. 다시 말해, 널이 아닌 요소 [i]는이 '기본'값보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="9ddd459237f2459c44b509144a91e81da646bb40" translate="yes" xml:space="preserve">
          <source>If 'e' is a tree of commas, returns the rightmost expression by stripping off it from the tree. The remained part of the tree is returned via e0. Otherwise 'e' is directly returned and e0 is set to NULL.</source>
          <target state="translated">'e'가 쉼표의 트리이면 트리에서 제거하여 가장 오른쪽 표현식을 반환합니다. 트리의 나머지 부분은 e0을 통해 반환됩니다. 그렇지 않으면 'e'가 직접 리턴되고 e0이 NULL로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="1b4dc8c105f5a3f750e979db674fe11913e62d44" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;std_range_primitives#ElementType&quot;&gt;&lt;code&gt;std.range.primitives.ElementType&lt;/code&gt;&lt;/a&gt;!R is a floating-point type and &lt;code&gt;R&lt;/code&gt; is a &lt;a href=&quot;std_range_primitives#isRandomAccessRange&quot;&gt;random-access range&lt;/a&gt; with length and slicing, then &lt;code&gt;sum&lt;/code&gt; uses the &lt;a href=&quot;http://en.wikipedia.org/wiki/Pairwise_summation&quot;&gt;pairwise summation&lt;/a&gt; algorithm.</source>
          <target state="translated">경우 &lt;a href=&quot;std_range_primitives#ElementType&quot;&gt; &lt;code&gt;std.range.primitives.ElementType&lt;/code&gt; &lt;/a&gt; ! R 부동 소수점 타입이고, &lt;code&gt;R&lt;/code&gt; 은 A는 &lt;a href=&quot;std_range_primitives#isRandomAccessRange&quot;&gt;랜덤 액세스 범위&lt;/a&gt; 길이로 슬라이싱하고 &lt;code&gt;sum&lt;/code&gt; 용도 &lt;a href=&quot;http://en.wikipedia.org/wiki/Pairwise_summation&quot;&gt;페어 합계&lt;/a&gt; 알고리즘.</target>
        </trans-unit>
        <trans-unit id="5461d4fe41b7c975dcc4f74fcf29adecaffabc9a" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;std_range_primitives#ElementType&quot;&gt;&lt;code&gt;std.range.primitives.ElementType&lt;/code&gt;&lt;/a&gt;!R is a floating-point type and &lt;code&gt;R&lt;/code&gt; is a &lt;a href=&quot;std_range_primitives#isRandomAccessRange&quot;&gt;random-access range&lt;/a&gt; with length and slicing, then &lt;code&gt;sum&lt;/code&gt; uses the &lt;a href=&quot;https://en.wikipedia.org/wiki/Pairwise_summation&quot;&gt;pairwise summation&lt;/a&gt; algorithm.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3c45083751ac69c2e8e598d9798f65c4de37c86" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;!!value&lt;/code&gt; is true, &lt;code&gt;value&lt;/code&gt; is returned. Otherwise, &lt;code&gt;new WindowsException(GetLastError(), msg)&lt;/code&gt; is thrown. &lt;code&gt;WindowsException&lt;/code&gt; assumes that the last operation set &lt;code&gt;GetLastError()&lt;/code&gt; appropriately.</source>
          <target state="translated">경우 &lt;code&gt;!!value&lt;/code&gt; 참, &lt;code&gt;value&lt;/code&gt; 반환됩니다. 그렇지 않으면 &lt;code&gt;new WindowsException(GetLastError(), msg)&lt;/code&gt; 이 발생합니다. &lt;code&gt;WindowsException&lt;/code&gt; 은 마지막 작업이 &lt;code&gt;GetLastError()&lt;/code&gt; 적절하게 설정했다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="8df9d33ad5bc28652f3433433542fda31081bb55" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;!isInfinite!Source&lt;/code&gt; and &lt;code&gt;source.walkLength&lt;/code&gt; is not evenly divisible by &lt;code&gt;chunkSize&lt;/code&gt;, the back element of this range will contain fewer than &lt;code&gt;chunkSize&lt;/code&gt; elements.</source>
          <target state="translated">경우 &lt;code&gt;!isInfinite!Source&lt;/code&gt; 와 &lt;code&gt;source.walkLength&lt;/code&gt; 가 고르게 아닙니다 의해 나눌 &lt;code&gt;chunkSize&lt;/code&gt; 이 범위의 뒷면 요소는보다 적은 포함 &lt;code&gt;chunkSize&lt;/code&gt; 요소.</target>
        </trans-unit>
        <trans-unit id="da45e2d8d90136b7f84f13e1858fb6ece371b4b0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;!value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;value&lt;/code&gt; is returned. Otherwise, &lt;code&gt;new E(msg, file, line)&lt;/code&gt; is thrown. Or if &lt;code&gt;E&lt;/code&gt; doesn't take a message and can be constructed with &lt;code&gt;new E(file, line)&lt;/code&gt;, then &lt;code&gt;new E(file, line)&lt;/code&gt; will be thrown.</source>
          <target state="translated">경우 &lt;code&gt;!value&lt;/code&gt; 입니다 &lt;code&gt;false&lt;/code&gt; , &lt;code&gt;value&lt;/code&gt; 반환됩니다. 그렇지 않으면 &lt;code&gt;new E(msg, file, line)&lt;/code&gt; 가 발생합니다. 경우 또는 &lt;code&gt;E&lt;/code&gt; 는 메시지를하지 않고로 구성 할 수 있습니다 &lt;code&gt;new E(file, line)&lt;/code&gt; , 다음 &lt;code&gt;new E(file, line)&lt;/code&gt; 슬로우됩니다.</target>
        </trans-unit>
        <trans-unit id="9ae58cb23b72d887da98d9fdd1704ba37b0874fc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;@live&lt;/code&gt; functions call non-&lt;code&gt;@live&lt;/code&gt; functions, those called functions are expected to present an &lt;code&gt;@live&lt;/code&gt; compatible interface, although it is not checked. if non-&lt;code&gt;@live&lt;/code&gt; functions call &lt;code&gt;@live&lt;/code&gt; functions, arguments passed are expected to follow &lt;code&gt;@live&lt;/code&gt; conventions.</source>
          <target state="translated">경우 &lt;code&gt;@live&lt;/code&gt; 기능이 아닌 전화 &lt;code&gt;@live&lt;/code&gt; 기능을, 그 호출되는 함수는 제시 할 것으로 예상된다 &lt;code&gt;@live&lt;/code&gt; 이 확인되지는 않지만, 호환 인터페이스를. 비 경우 &lt;code&gt;@live&lt;/code&gt; 함수를 호출 &lt;code&gt;@live&lt;/code&gt; 기능을, 전달 된 인수가 따를 것으로 예상된다 &lt;code&gt;@live&lt;/code&gt; 규칙을.</target>
        </trans-unit>
        <trans-unit id="e70bac81fdcc8ee63f8a6ffecb44cdbcf2f794c7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; has no state, the resulting object is allocated in static shared storage.</source>
          <target state="translated">경우 &lt;code&gt;A&lt;/code&gt; 는 상태가 없으나, 생성 된 객체는 정적 공유 저장 영역에 할당된다.</target>
        </trans-unit>
        <trans-unit id="7b2c6010fe0ff7fc814ba13aa84690947c8cb83d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; has state and is copyable, the result will &lt;a href=&quot;std_algorithm_mutation#move&quot;&gt;&lt;code&gt;std.algorithm.mutation.move&lt;/code&gt;&lt;/a&gt; the supplied allocator &lt;code&gt;A a&lt;/code&gt; within. The result itself is allocated in its own statically-typed allocator.</source>
          <target state="translated">경우 &lt;code&gt;A&lt;/code&gt; 는 상태를 갖고있다 복사 가능한 결과는 것이다 &lt;a href=&quot;std_algorithm_mutation#move&quot;&gt; &lt;code&gt;std.algorithm.mutation.move&lt;/code&gt; &lt;/a&gt; 제공된 할당 자 &lt;code&gt;A a&lt;/code&gt; 내의한다. 결과 자체는 정적으로 유형이 지정된 할당 자에 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="e90491f805af73197e670ba7dcdbdea4f3f9187b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; has state and is not copyable, the result will move the passed-in argument into the result. The result itself is allocated in its own statically-typed allocator.</source>
          <target state="translated">경우 &lt;code&gt;A&lt;/code&gt; 가 상태를 가지고 있으며, 복사 가능한 아니라, 결과는 결과에 전달 된 인수를 이동합니다. 결과 자체는 정적으로 유형이 지정된 할당 자에 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="8e3921430ef3c9cb639e4397d8b838ecfe391c50" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; has state, the result will &lt;a href=&quot;std_algorithm_mutation#move&quot;&gt;&lt;code&gt;std.algorithm.mutation.move&lt;/code&gt;&lt;/a&gt; the supplied allocator &lt;code&gt;A a&lt;/code&gt; within. The result itself is allocated in its own statically-typed allocator.</source>
          <target state="translated">경우 &lt;code&gt;A&lt;/code&gt; 는 상태를 가지며, 그 결과는 것이다 &lt;a href=&quot;std_algorithm_mutation#move&quot;&gt; &lt;code&gt;std.algorithm.mutation.move&lt;/code&gt; &lt;/a&gt; 제공된 할당 자 &lt;code&gt;A a&lt;/code&gt; 내의한다. 결과 자체는 정적으로 유형이 지정된 할당 자에 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="85c9db39cbb0a223dde8b65577a816ac4ae74ca1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Allocator&lt;/code&gt; implements &lt;code&gt;owns&lt;/code&gt;, forwards to it. Otherwise, returns &lt;code&gt;Ternary.unknown&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;Allocator&lt;/code&gt; 구현이 &lt;code&gt;owns&lt;/code&gt; 그것에, 앞으로. 그렇지 않으면 &lt;code&gt;Ternary.unknown&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="602c75c69645dadebf41e326ef28dced33652078" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;BookkeepingAllocator&lt;/code&gt; is not &lt;code&gt;NullAllocator&lt;/code&gt;, &lt;code&gt;bkalloc&lt;/code&gt; is defined and accessible.</source>
          <target state="translated">경우 &lt;code&gt;BookkeepingAllocator&lt;/code&gt; 가 아닌 &lt;code&gt;NullAllocator&lt;/code&gt; , &lt;code&gt;bkalloc&lt;/code&gt; 는 정의에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e61003ea748193c575ad061853d1dd56eb5e4c1d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ElementType!R&lt;/code&gt; is a floating-point type and &lt;code&gt;R&lt;/code&gt; is a finite input range (but not a random-access range with slicing), then &lt;code&gt;sum&lt;/code&gt; uses the &lt;a href=&quot;http://en.wikipedia.org/wiki/Kahan_summation&quot;&gt;Kahan summation&lt;/a&gt; algorithm.</source>
          <target state="translated">경우 &lt;code&gt;ElementType!R&lt;/code&gt; 부동 소수점 타입이고, &lt;code&gt;R&lt;/code&gt; 은 한정된 입력 범위 (그러나 슬라이싱과 랜덤 액세스 범위)이며, 다음 &lt;code&gt;sum&lt;/code&gt; 용도 &lt;a href=&quot;http://en.wikipedia.org/wiki/Kahan_summation&quot;&gt;Kahan 합계&lt;/a&gt; 알고리즘.</target>
        </trans-unit>
        <trans-unit id="fc27324f1313ac32b98b4d9a0fcd3f12a5ee0a27" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ElementType!R&lt;/code&gt; is a floating-point type and &lt;code&gt;R&lt;/code&gt; is a finite input range (but not a random-access range with slicing), then &lt;code&gt;sum&lt;/code&gt; uses the &lt;a href=&quot;https://en.wikipedia.org/wiki/Kahan_summation&quot;&gt;Kahan summation&lt;/a&gt; algorithm.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e00af2edb93d47ac443e7418f444a801ea32bd2d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FreeList&lt;/code&gt; has been instantiated with &lt;code&gt;maxSize == chooseAtRuntime&lt;/code&gt;, then the &lt;code&gt;max&lt;/code&gt; property is writable. Setting it must precede any allocation.</source>
          <target state="translated">경우 &lt;code&gt;FreeList&lt;/code&gt; 인스턴스화 된 &lt;code&gt;maxSize == chooseAtRuntime&lt;/code&gt; 후 &lt;code&gt;max&lt;/code&gt; 속성은 쓰기 가능합니다. 할당하기 전에 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="619bff2f62db09894cc368f16063c71698b3e91a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FreeList&lt;/code&gt; has been instantiated with &lt;code&gt;minSize == chooseAtRuntime&lt;/code&gt;, then the &lt;code&gt;min&lt;/code&gt; property is writable. Setting it must precede any allocation.</source>
          <target state="translated">경우 &lt;code&gt;FreeList&lt;/code&gt; 인스턴스화 된 &lt;code&gt;minSize == chooseAtRuntime&lt;/code&gt; 후 &lt;code&gt;min&lt;/code&gt; 속성 쓸 것이다. 할당하기 전에 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="614802dd9535195f4c34d795221ff4407109b94d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Hook&lt;/code&gt; defines &lt;code&gt;hookOpOpAssign&lt;/code&gt;, &lt;code&gt;opOpAssign&lt;/code&gt; forwards to &lt;code&gt;hook.hookOpOpAssign!op(payload, rhs)&lt;/code&gt;, where &lt;code&gt;payload&lt;/code&gt; is a reference to the internally held data so the hook can change it.</source>
          <target state="translated">경우 &lt;code&gt;Hook&lt;/code&gt; 정의 &lt;code&gt;hookOpOpAssign&lt;/code&gt; , &lt;code&gt;opOpAssign&lt;/code&gt; 을 에게 전달 &lt;code&gt;hook.hookOpOpAssign!op(payload, rhs)&lt;/code&gt; , &lt;code&gt;payload&lt;/code&gt; 후크를 변경할 수 있도록 내부에 유지 된 데이터에 대한 참조이다.</target>
        </trans-unit>
        <trans-unit id="6213f7b3e2cf0b3c2b2e856da1c03c2c3603a41e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Hook&lt;/code&gt; does not define &lt;code&gt;hookOpBinary&lt;/code&gt; but defines &lt;code&gt;onOverflow&lt;/code&gt;, &lt;code&gt;opBinary&lt;/code&gt; forwards to &lt;code&gt;hook.onOverflow!op(get, rhs)&lt;/code&gt; in case an overflow occurs.</source>
          <target state="translated">경우 &lt;code&gt;Hook&lt;/code&gt; 정의하지 않는 &lt;code&gt;hookOpBinary&lt;/code&gt; 하지만 정의를 &lt;code&gt;onOverflow&lt;/code&gt; , &lt;code&gt;opBinary&lt;/code&gt; 에 전달 &lt;code&gt;hook.onOverflow!op(get, rhs)&lt;/code&gt; 경우는 오버 플로우가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="48a7fb4afe12c2822acfff866c271812d59b89d4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Hook&lt;/code&gt; does not define &lt;code&gt;hookOpUnary&lt;/code&gt; but defines &lt;code&gt;onOverflow&lt;/code&gt;, &lt;code&gt;opUnary&lt;/code&gt; forwards to &lt;code&gt;hook.onOverflow!op(get)&lt;/code&gt; in case an overflow occurs. For &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt;, the payload is assigned from the result of the call to &lt;code&gt;onOverflow&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;Hook&lt;/code&gt; 정의하지 않는 &lt;code&gt;hookOpUnary&lt;/code&gt; 하지만 정의를 &lt;code&gt;onOverflow&lt;/code&gt; , &lt;code&gt;opUnary&lt;/code&gt; 에 전달 &lt;code&gt;hook.onOverflow!op(get)&lt;/code&gt; 경우는 오버 플로우가 발생합니다. 들어 &lt;code&gt;++&lt;/code&gt; 와 &lt;code&gt;--&lt;/code&gt; , 페이로드에 대한 호출의 결과로부터 할당 &lt;code&gt;onOverflow&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="10cd8aa857d486ec2d02cef4465f8ceb45e4e90d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ParentAllocator&lt;/code&gt; holds state, &lt;code&gt;parent&lt;/code&gt; is a public member of type &lt;code&gt;KRRegion&lt;/code&gt;. Otherwise, &lt;code&gt;parent&lt;/code&gt; is an &lt;code&gt;alias&lt;/code&gt; for &lt;code&gt;ParentAllocator.instance&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;ParentAllocator&lt;/code&gt; 가 상태를 보유하고, &lt;code&gt;parent&lt;/code&gt; 형의 공개 구성원 &lt;code&gt;KRRegion&lt;/code&gt; . 그렇지 않으면 &lt;code&gt;parent&lt;/code&gt; 는 &lt;code&gt;ParentAllocator.instance&lt;/code&gt; 의 &lt;code&gt;alias&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="3bbccd514894e82c4ce13569d09888036cf3359f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ParentAllocator&lt;/code&gt; is &lt;a href=&quot;std_experimental_allocator_building_blocks_null_allocator#NullAllocator&quot;&gt;&lt;code&gt;NullAllocator&lt;/code&gt;&lt;/a&gt;, only the constructor taking &lt;code&gt;data&lt;/code&gt; is defined and the user is responsible for freeing &lt;code&gt;data&lt;/code&gt; if desired.</source>
          <target state="translated">경우 &lt;code&gt;ParentAllocator&lt;/code&gt; 가 있다 &lt;a href=&quot;std_experimental_allocator_building_blocks_null_allocator#NullAllocator&quot;&gt; &lt;code&gt;NullAllocator&lt;/code&gt; &lt;/a&gt; 복용에만 생성자 &lt;code&gt;data&lt;/code&gt; 정의하고 사용자가 자유롭게에 대한 책임이다 &lt;code&gt;data&lt;/code&gt; 원하는 경우.</target>
        </trans-unit>
        <trans-unit id="d42312f5e4b477adba48781c375b173d6250fd1d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ParentAllocator&lt;/code&gt; is different from &lt;a href=&quot;std_experimental_allocator_building_blocks_null_allocator#NullAllocator&quot;&gt;&lt;code&gt;NullAllocator&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;Region&lt;/code&gt; deallocates the chunk of memory during destruction.</source>
          <target state="translated">경우 &lt;code&gt;ParentAllocator&lt;/code&gt; 이 다른 &lt;a href=&quot;std_experimental_allocator_building_blocks_null_allocator#NullAllocator&quot;&gt; &lt;code&gt;NullAllocator&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;Region&lt;/code&gt; 파괴 동안 메모리 청크를 할당 해제합니다.</target>
        </trans-unit>
        <trans-unit id="9a65e34991edf1fabbde944025e9467eaa28acfa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ParentAllocator&lt;/code&gt; is stateful, &lt;code&gt;parent&lt;/code&gt; is a property giving access to an &lt;code&gt;AffixAllocator!ParentAllocator&lt;/code&gt;. Otherwise, &lt;code&gt;parent&lt;/code&gt; is an alias for &lt;code&gt;AffixAllocator!ParentAllocator.instance&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;ParentAllocator&lt;/code&gt; 은 상태이며, &lt;code&gt;parent&lt;/code&gt; 에 대한 액세스 제공하는 속성입니다 &lt;code&gt;AffixAllocator!ParentAllocator&lt;/code&gt; . 그렇지 않으면 &lt;code&gt;parent&lt;/code&gt; 는 &lt;code&gt;AffixAllocator!ParentAllocator.instance&lt;/code&gt; 의 별명입니다 .</target>
        </trans-unit>
        <trans-unit id="43d333c4fd79ece4dce7180ff004a1dd304cfda4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Prefix&lt;/code&gt; is &lt;code&gt;void&lt;/code&gt;, the alignment is that of the parent. Otherwise, the alignment is the same as the &lt;code&gt;Prefix&lt;/code&gt;'s alignment.</source>
          <target state="translated">경우 &lt;code&gt;Prefix&lt;/code&gt; 이다 &lt;code&gt;void&lt;/code&gt; , 정렬은 부모의입니다. 그렇지 않으면 정렬은 &lt;code&gt;Prefix&lt;/code&gt; 정렬과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="6ef958a14b28e8a87e35d39d726513cf1a24e3ab" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Prefix&lt;/code&gt; is not &lt;code&gt;void&lt;/code&gt;, &lt;code&gt;Allocator&lt;/code&gt; must guarantee an alignment at least as large as &lt;code&gt;Prefix.alignof&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;Prefix&lt;/code&gt; 없는 &lt;code&gt;void&lt;/code&gt; , &lt;code&gt;Allocator&lt;/code&gt; 큰로서 적어도 정렬을 보장해야한다 &lt;code&gt;Prefix.alignof&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4bde56d414db390f6de687beeb6a7de19e32b07b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;S&lt;/code&gt; defines a destructor, the generated code for &lt;code&gt;opAssign&lt;/code&gt; is:</source>
          <target state="translated">경우 &lt;code&gt;S&lt;/code&gt; 는 소멸자를 정의에 대해 생성 된 코드 &lt;code&gt;opAssign&lt;/code&gt; 가 있습니다 :</target>
        </trans-unit>
        <trans-unit id="8fa12abad24500172f1e1f4de478a1e097e94f32" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;S&lt;/code&gt; does not have a postblit or a destructor, but contains at least one field that defines an &lt;code&gt;opAssign&lt;/code&gt; function (which is not disabled), then the body will make member-wise assignments:</source>
          <target state="translated">경우 &lt;code&gt;S&lt;/code&gt; 가 postblit 또는 소멸자를 가지고 있지만 정의 적어도 하나 개의 필드 포함되지 않습니다 &lt;code&gt;opAssign&lt;/code&gt; 기능 (비활성화하지 않은), 그 몸은 회원이 많다는 할당을 만들 것입니다 :</target>
        </trans-unit>
        <trans-unit id="135d5e0bd9ac5cff9f359e01e49ee96d18ba1175" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;S&lt;/code&gt; has a disabled destructor or at least one field that has a disabled &lt;code&gt;opAssign&lt;/code&gt;, &lt;code&gt;S.opAssign&lt;/code&gt; is going to be generated, but marked with &lt;code&gt;@disable&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;S&lt;/code&gt; 가 비활성화되어있는 장애 또는 소멸자 적어도 하나 개의 필드를 갖는다 &lt;code&gt;opAssign&lt;/code&gt; 을 , &lt;code&gt;S.opAssign&lt;/code&gt; 가 발생 될 예정이지만 표시되어 &lt;code&gt;@disable&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e5d3671bcdce32a3ae79160f07ed6d9617aa8c77" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Source&lt;/code&gt; has structural conformance with the &lt;code&gt;interface&lt;/code&gt;&lt;code&gt;Targets&lt;/code&gt;, wrap creates an internal wrapper class which inherits &lt;code&gt;Targets&lt;/code&gt; and wraps the &lt;code&gt;src&lt;/code&gt; object, then returns it.</source>
          <target state="translated">경우 &lt;code&gt;Source&lt;/code&gt; 와 구조적 적합성을 가지고 &lt;code&gt;interface&lt;/code&gt; &lt;code&gt;Targets&lt;/code&gt; , 랩 상속 내부 래퍼 클래스 생성 &lt;code&gt;Targets&lt;/code&gt; 과 랩 &lt;code&gt;src&lt;/code&gt; 다음을 반환 개체를.</target>
        </trans-unit>
        <trans-unit id="a6a1c6b133b0871dee66034a379d92385c6acfa0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Source&lt;/code&gt; is a forward range, the resulting range will be forward ranges as well. Otherwise, the resulting chunks will be input ranges consuming the same input: iterating over &lt;code&gt;front&lt;/code&gt; will shrink the chunk such that subsequent invocations of &lt;code&gt;front&lt;/code&gt; will no longer return the full chunk, and calling &lt;code&gt;popFront&lt;/code&gt; on the outer range will invalidate any lingering references to previous values of &lt;code&gt;front&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;Source&lt;/code&gt; 순방향 범위는, 얻어지는 범위뿐만 아니라 앞으로의 범위 일 것이다. 그렇지 않으면 결과 청크는 동일한 입력을 소비하는 입력 범위가됩니다. &lt;code&gt;front&lt;/code&gt; 를 반복 하면 청크가 축소되어 &lt;code&gt;front&lt;/code&gt; 후속 호출 이 더 이상 전체 청크를 반환하지 않으며 외부 범위에서 &lt;code&gt;popFront&lt;/code&gt; 를 호출 하면 이전 값에 대한 모든 참조가 무효화됩니다. 의 &lt;code&gt;front&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="68e4c36f3a209b42eda6036b89cfd912aefdf8d2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;StopWatch.init&lt;/code&gt; is used, then the constructed StopWatch isn't running (and can't be, since no constructor ran).</source>
          <target state="translated">경우 &lt;code&gt;StopWatch.init&lt;/code&gt; 가 사용되며, 다음은 스톱워치가 실행되고 있지 (없이 생성자 실행 된 이후, 수 없습니다) 건설했다.</target>
        </trans-unit>
        <trans-unit id="8fa16aaee056c365a9ba1b96bbf4c7ab3e0c7909" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Store&lt;/code&gt; is a range, the &lt;code&gt;BinaryHeap&lt;/code&gt; cannot grow beyond the size of that range. If &lt;code&gt;Store&lt;/code&gt; is a container that supports &lt;code&gt;insertBack&lt;/code&gt;, the &lt;code&gt;BinaryHeap&lt;/code&gt; may grow by adding elements to the container.</source>
          <target state="translated">경우 &lt;code&gt;Store&lt;/code&gt; 범위되면, &lt;code&gt;BinaryHeap&lt;/code&gt; 그 범위의 크기를 초과 할 수 없습니다. &lt;code&gt;Store&lt;/code&gt; 가 &lt;code&gt;insertBack&lt;/code&gt; 을 지원하는 컨테이너 인 경우 컨테이너 에 요소를 추가 하여 &lt;code&gt;BinaryHeap&lt;/code&gt; 이 커질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dbe0360bc543f33ed0b90fcff8d9687e9b9ea633" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a class type, returns a reference to the created &lt;code&gt;T&lt;/code&gt; object. Otherwise, returns a &lt;code&gt;T*&lt;/code&gt; pointing to the created object. In all cases, returns &lt;code&gt;null&lt;/code&gt; if allocation failed.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 가 클래스 타입이며, 생성에 대한 참조를 반환 &lt;code&gt;T&lt;/code&gt; 의 객체를. 그렇지 않으면 생성 된 객체를 가리키는 &lt;code&gt;T*&lt;/code&gt; 반환 합니다. 모든 경우에 할당에 실패하면 &lt;code&gt;null&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="85b009305a8588231d9cf9c49742c5425d7c6707" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a nested struct, the context pointer in &lt;code&gt;T.init&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 가 중첩 된 구조체이며, 상황에 맞는 포인터 &lt;code&gt;T.init&lt;/code&gt; 는 이다 &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="86a83fbe1dd6e8e6329df1be326be31fbac7542c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a struct which has &lt;code&gt;@disable this();&lt;/code&gt;, &lt;code&gt;T.init&lt;/code&gt; might return a logically incorrect object.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 가 갖는 구조체이다 &lt;code&gt;@disable this();&lt;/code&gt; , &lt;code&gt;T.init&lt;/code&gt; 은 논리적으로 잘못된 개체를 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="28ecbbbd57ec70df9468c10b69230725191bde07" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a struct with a destructor or postblit defined, source is reset to its &lt;code&gt;.init&lt;/code&gt; value after it is moved into target, otherwise it is left unchanged.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 가 소멸자 또는 포스트 블릿이 정의 된 구조체 인 경우 소스는 대상으로 이동 한 후 &lt;code&gt;.init&lt;/code&gt; 값으로 재설정되고 , 그렇지 않으면 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="be0ddbf38059d4859dc637f9816765cfecd51bd9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a value type, then &lt;code&gt;Unique!T&lt;/code&gt; will be implemented as a reference to a &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 가 값 형식이고, 다음 &lt;code&gt;Unique!T&lt;/code&gt; A와 참조로 구현 될 것입니다 &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3ad884b639da3b067a89fc2f9254b6e884145e3b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an inner class whose &lt;code&gt;outer&lt;/code&gt; field can be used to access an instance of the enclosing class, then &lt;code&gt;Args&lt;/code&gt; must not be empty, and the first member of it must be a valid initializer for that &lt;code&gt;outer&lt;/code&gt; field. Correct initialization of this field is essential to access members of the outer class inside &lt;code&gt;T&lt;/code&gt; methods.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 는 그 내부 클래스 &lt;code&gt;outer&lt;/code&gt; 필드를 둘러싸는 클래스의 인스턴스에 액세스하는 데 사용될 수는 다음 &lt;code&gt;Args&lt;/code&gt; 비어 있지 않아야하고 그것의 제 1 부재에는 해당하는 유효 초기화 있어야 &lt;code&gt;outer&lt;/code&gt; 필드. 이 필드의 올바른 초기화는 &lt;code&gt;T&lt;/code&gt; 메소드 내부의 외부 클래스 멤버에 액세스하는 데 필수적 입니다.</target>
        </trans-unit>
        <trans-unit id="5e5dca16a0b08e551a0873d6f42ddf6d816c0620" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt;'s constructor throws, deallocates the allocated memory and propagates the exception.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 의 생성자가 발생, 할당 된 메모리 할당을 취소하고 예외를 전파합니다.</target>
        </trans-unit>
        <trans-unit id="f9ccf6d42185874390122acb61e0fffade4a1d7e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;U&lt;/code&gt; is also an instance of &lt;code&gt;Checked&lt;/code&gt;, both hooks (left- and right-hand side) are introspected for the method &lt;code&gt;hookOpCmp&lt;/code&gt;. If both define it, priority is given to the left-hand side.</source>
          <target state="translated">경우 &lt;code&gt;U&lt;/code&gt; 가 도의 인스턴스 &lt;code&gt;Checked&lt;/code&gt; 양쪽 후크 (왼쪽 및 오른쪽)을위한 방법 크션된다 &lt;code&gt;hookOpCmp&lt;/code&gt; . 둘 다 정의하면 왼쪽에 우선 순위가 부여됩니다.</target>
        </trans-unit>
        <trans-unit id="f714d4a1a2b46c6585bd14b3632f61dc774fe527" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;U&lt;/code&gt; is also an instance of &lt;code&gt;Checked&lt;/code&gt;, both hooks (left- and right-hand side) are introspected for the method &lt;code&gt;hookOpEquals&lt;/code&gt;. If both define it, priority is given to the left-hand side.</source>
          <target state="translated">경우 &lt;code&gt;U&lt;/code&gt; 가 도의 인스턴스 &lt;code&gt;Checked&lt;/code&gt; 양쪽 후크 (왼쪽 및 오른쪽)을위한 방법 크션된다 &lt;code&gt;hookOpEquals&lt;/code&gt; . 둘 다 정의하면 왼쪽에 우선 순위가 부여됩니다.</target>
        </trans-unit>
        <trans-unit id="6530603e838c2a2e64b1bcfb9217be83aec2dafc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Yes.checkDns&lt;/code&gt; then a DNS check for MX records will be made</source>
          <target state="translated">예 &lt;code&gt;Yes.checkDns&lt;/code&gt; 이면 MX 레코드에 대한 DNS 확인이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="a1992ec3ad4038c0370a2f08b90896545a010903" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Yes.pipeOnPop&lt;/code&gt;, simply iterating the range without ever calling &lt;code&gt;front&lt;/code&gt; is enough to have &lt;code&gt;tee&lt;/code&gt; mirror elements to &lt;code&gt;outputRange&lt;/code&gt; (or, respectively, &lt;code&gt;fun&lt;/code&gt;). If &lt;code&gt;No.pipeOnPop&lt;/code&gt;, only elements for which &lt;code&gt;front&lt;/code&gt; does get called will be also sent to &lt;code&gt;outputRange&lt;/code&gt;/&lt;code&gt;fun&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;Yes.pipeOnPop&lt;/code&gt; , 단순히 적 호출하지 않고 범위를 반복 &lt;code&gt;front&lt;/code&gt; 이 충분하다 &lt;code&gt;tee&lt;/code&gt; 로 미러 요소 &lt;code&gt;outputRange&lt;/code&gt; (각각 또는, &lt;code&gt;fun&lt;/code&gt; ). &lt;code&gt;No.pipeOnPop&lt;/code&gt; 인 경우 &lt;code&gt;front&lt;/code&gt; 가 호출 되는 요소 만 &lt;code&gt;outputRange&lt;/code&gt; / &lt;code&gt;fun&lt;/code&gt; 으로 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="7a50176d4624d41b95b9071257e16a7702021f98" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Yes.pipeOnPop&lt;/code&gt;, simply iterating the range without ever calling &lt;code&gt;front&lt;/code&gt; is enough to have &lt;code&gt;tee&lt;/code&gt; mirror elements to &lt;code&gt;outputRange&lt;/code&gt; (or, respectively, &lt;code&gt;fun&lt;/code&gt;). Note that each &lt;code&gt;popFront()&lt;/code&gt; call will mirror the old &lt;code&gt;front&lt;/code&gt; value, not the new one. This means that the last value will not be forwarded if the range isn't iterated until empty. If &lt;code&gt;No.pipeOnPop&lt;/code&gt;, only elements for which &lt;code&gt;front&lt;/code&gt; does get called will be also sent to &lt;code&gt;outputRange&lt;/code&gt;/&lt;code&gt;fun&lt;/code&gt;. If &lt;code&gt;front&lt;/code&gt; is called twice for the same element, it will still be sent only once. If this caching is undesired, consider using &lt;a href=&quot;std_algorithm_iteration#map&quot;&gt;&lt;code&gt;std.algorithm.iteration.map&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">경우 &lt;code&gt;Yes.pipeOnPop&lt;/code&gt; , 단순히 적 호출하지 않고 범위를 반복 &lt;code&gt;front&lt;/code&gt; 이 충분하다 &lt;code&gt;tee&lt;/code&gt; 로 미러 요소 &lt;code&gt;outputRange&lt;/code&gt; (각각 또는, &lt;code&gt;fun&lt;/code&gt; ). 각 &lt;code&gt;popFront()&lt;/code&gt; 호출은 새 값이 아닌 이전 &lt;code&gt;front&lt;/code&gt; 값을 미러링합니다 . 즉, 범위가 비어있을 때까지 반복되지 않으면 마지막 값이 전달되지 않습니다. 경우 &lt;code&gt;No.pipeOnPop&lt;/code&gt; 는 ,있는 요소 만 &lt;code&gt;front&lt;/code&gt; 전화를받을 않습니다도 전송됩니다 &lt;code&gt;outputRange&lt;/code&gt; / &lt;code&gt;fun&lt;/code&gt; . 만약 &lt;code&gt;front&lt;/code&gt; 동일한 요소에 대해 두 번 호출되지만 여전히 한 번만 전송됩니다. 이 캐싱이 바람직하지 않은 경우 &lt;a href=&quot;std_algorithm_iteration#map&quot;&gt; &lt;code&gt;std.algorithm.iteration.map&lt;/code&gt; 을&lt;/a&gt; 대신 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="6b44ae6759ea792f0bca17c48004575c328a9fdc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a = &quot;abcde&quot;&lt;/code&gt;, then &lt;code&gt;findSkip(a, &quot;x&quot;)&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt; and leaves &lt;code&gt;a&lt;/code&gt; unchanged, whereas &lt;code&gt;findSkip(a, &quot;c&quot;)&lt;/code&gt; advances &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;&quot;de&quot;&lt;/code&gt; and returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;a = &quot;abcde&quot;&lt;/code&gt; 다음 &lt;code&gt;findSkip(a, &quot;x&quot;)&lt;/code&gt; 반환 &lt;code&gt;false&lt;/code&gt; 과 잎 , 변경을하는 반면 &lt;code&gt;findSkip(a, &quot;c&quot;)&lt;/code&gt; 진보 &lt;code&gt;a&lt;/code&gt; 에 &lt;code&gt;&quot;de&quot;&lt;/code&gt; 반환 &lt;code&gt;true&lt;/code&gt; . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="22d1d40c86b33d24346ec7f18b6caa5014b1c725" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a = [1, 2, 3]&lt;/code&gt; and &lt;code&gt;b = [4, 5, 6, 7]&lt;/code&gt;, &lt;code&gt;bringToFront(a, b)&lt;/code&gt; leaves &lt;code&gt;a = [4, 5, 6]&lt;/code&gt; and &lt;code&gt;b = [7, 1, 2, 3]&lt;/code&gt;.</source>
          <target state="translated">하면 &lt;code&gt;a = [1, 2, 3]&lt;/code&gt; 및 &lt;code&gt;b = [4, 5, 6, 7]&lt;/code&gt; , &lt;code&gt;bringToFront(a, b)&lt;/code&gt; 나뭇잎 &lt;code&gt;a = [4, 5, 6]&lt;/code&gt; 및 &lt;code&gt;b = [7, 1, 2, 3]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="161672661d076244bfa4e1cb23db5cb7cee3f0b9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a = [1, 2, 3]&lt;/code&gt;, &lt;code&gt;reverse(a)&lt;/code&gt; changes it to &lt;code&gt;[3, 2, 1]&lt;/code&gt;.</source>
          <target state="translated">하면 &lt;code&gt;a = [1, 2, 3]&lt;/code&gt; , &lt;code&gt;reverse(a)&lt;/code&gt; 로 변경 &lt;code&gt;[3, 2, 1]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6c20592a36a578c54537352b677f5ac5e2a4bd22" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a = [1.2, 3.4]&lt;/code&gt;, then &lt;code&gt;initializeAll(a)&lt;/code&gt; leaves &lt;code&gt;a = [double.init, double.init]&lt;/code&gt;.</source>
          <target state="translated">하면 &lt;code&gt;a = [1.2, 3.4]&lt;/code&gt; , 다음 &lt;code&gt;initializeAll(a)&lt;/code&gt; 나뭇잎 &lt;code&gt;a = [double.init, double.init]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3f19fe74876068eb9761e0ed018d3efe050a2dc6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a = [10, 20, 30]&lt;/code&gt; and &lt;code&gt;b = [40, 6, 15]&lt;/code&gt;, then &lt;code&gt;completeSort(a, b)&lt;/code&gt; leaves &lt;code&gt;a = [6, 10, 15]&lt;/code&gt; and &lt;code&gt;b = [20, 30, 40]&lt;/code&gt;. The range &lt;code&gt;a&lt;/code&gt; must be sorted prior to the call, and as a result the combination &lt;code&gt;&lt;a href=&quot;std_range#chain&quot;&gt;std.range.chain&lt;/a&gt;(a, b)&lt;/code&gt; is sorted.</source>
          <target state="translated">하면 &lt;code&gt;a = [10, 20, 30]&lt;/code&gt; 및 &lt;code&gt;b = [40, 6, 15]&lt;/code&gt; 다음 &lt;code&gt;completeSort(a, b)&lt;/code&gt; 나뭇잎 &lt;code&gt;a = [6, 10, 15]&lt;/code&gt; 및 &lt;code&gt;b = [20, 30, 40]&lt;/code&gt; . 범위 &lt;code&gt;a&lt;/code&gt; 는 통화 전에 정렬되어야하며 그 결과 &lt;code&gt;&lt;a href=&quot;std_range#chain&quot;&gt;std.range.chain&lt;/a&gt;(a, b)&lt;/code&gt; 조합 이 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="8653b5c90f101e5bb8cf18c8696bdaa4b97980b3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a = [5, 4, 3, 2, 1]&lt;/code&gt;, then &lt;code&gt;partialSort(a, 3)&lt;/code&gt; leaves &lt;code&gt;a[0 .. 3] = [1, 2, 3]&lt;/code&gt;. The other elements of &lt;code&gt;a&lt;/code&gt; are left in an unspecified order.</source>
          <target state="translated">하면 &lt;code&gt;a = [5, 4, 3, 2, 1]&lt;/code&gt; 다음, &lt;code&gt;partialSort(a, 3)&lt;/code&gt; 잎 &lt;code&gt;a[0 .. 3] = [1, 2, 3]&lt;/code&gt; . 의 다른 원소 &lt;code&gt;a&lt;/code&gt; 불특정 위해 남겨진다.</target>
        </trans-unit>
        <trans-unit id="761844ca385c58407529b15b7f0264a9fdc0b35e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;allowDuplicates&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, then inserting the same element more than once continues to add more elements. If it is &lt;code&gt;false&lt;/code&gt;, duplicate elements are ignored on insertion. If duplicates are allowed, then new elements are inserted after all existing duplicate elements.</source>
          <target state="translated">&lt;code&gt;allowDuplicates&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 로 설정된 경우 동일한 요소를 두 번 이상 삽입하면 요소가 계속 추가됩니다. &lt;code&gt;false&lt;/code&gt; 인 경우 삽입시 중복 요소가 무시됩니다. 중복이 허용되면 기존의 모든 중복 요소 뒤에 새 요소가 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="42df331db67fcac4570e8d97255c06bf51fcef31" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arr.length &amp;lt; delta&lt;/code&gt;, does nothing and returns &lt;code&gt;false&lt;/code&gt;. Otherwise, destroys the last &lt;code&gt;arr.length - delta&lt;/code&gt; elements in the array and then reallocates the array's buffer. If reallocation fails, fills the array with default-initialized data.</source>
          <target state="translated">&lt;code&gt;arr.length &amp;lt; delta&lt;/code&gt; 인 경우 아무 작업도 수행하지 않고 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 . 그렇지 않으면 배열 의 마지막 &lt;code&gt;arr.length - delta&lt;/code&gt; 요소를 삭제 한 다음 배열의 버퍼를 재 할당합니다. 재 할당이 실패하면 기본 초기화 데이터로 배열을 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="73774d72a77acb4ae5cc4817197c7e3cc39e3e8b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;array.length &amp;lt; delta&lt;/code&gt;, does nothing and returns &lt;code&gt;false&lt;/code&gt;. Otherwise, destroys the last &lt;code&gt;array.length - delta&lt;/code&gt; elements in the array and then reallocates the array's buffer. If reallocation fails, fills the array with default-initialized data.</source>
          <target state="translated">&lt;code&gt;array.length &amp;lt; delta&lt;/code&gt; 인 경우 아무 작업도 수행하지 않고 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 . 그렇지 않으면 배열 의 마지막 &lt;code&gt;array.length - delta&lt;/code&gt; 요소를 삭제 한 다음 배열의 버퍼를 재 할당합니다. 재 할당이 실패하면 기본 초기화 데이터로 배열을 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="7b4fa4088c1f332dc1cc2c07bd6dcf7ba46787dc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;b is null&lt;/code&gt;, does nothing and returns &lt;code&gt;true&lt;/code&gt;. Otherwise, deallocates memory previously allocated with this allocator and returns &lt;code&gt;true&lt;/code&gt; if successful, &lt;code&gt;false&lt;/code&gt; otherwise. An implementation that would not support deallocation (i.e. would always return &lt;code&gt;false&lt;/code&gt; should not define this primitive at all.)</source>
          <target state="translated">경우 &lt;code&gt;b is null&lt;/code&gt; , 아무것도 반환하지 않습니다 &lt;code&gt;true&lt;/code&gt; . 그렇지 않으면, 할당 해제 메모리는 이전에이 할당 반환 할당 &lt;code&gt;true&lt;/code&gt; 성공하는 경우, &lt;code&gt;false&lt;/code&gt; 그렇지. 할당 해제를 지원하지 않는 구현 (즉, 항상 &lt;code&gt;false&lt;/code&gt; 를 리턴 하는 경우이 기본 요소를 전혀 정의하지 않아야 함)</target>
        </trans-unit>
        <trans-unit id="8bae244a830c8d1176da79e2579d3599e88c12f8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ba&lt;/code&gt; is zero (the default) the attributes of the existing memory will be used for an allocation. If &lt;code&gt;ba&lt;/code&gt; is not zero and no new memory is allocated, the bits in ba will replace those of the current memory block.</source>
          <target state="translated">경우 &lt;code&gt;ba&lt;/code&gt; 제로 (기본값)는 기존 메모리의 속성은 할당에 사용됩니다. &lt;code&gt;ba&lt;/code&gt; 가 0이 아니고 새로운 메모리가 할당되지 않으면 ba 의 비트는 현재 메모리 블록의 비트를 대체합니다.</target>
        </trans-unit>
        <trans-unit id="221a7c0321e1759235e9e5a40274abe6cabee406" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;block.length&lt;/code&gt; is within &lt;code&gt;[min, max]&lt;/code&gt; or if the free list is unchecked (&lt;code&gt;minSize == 0 &amp;amp;&amp;amp; maxSize == size_t.max&lt;/code&gt;), then inserts the block at the front of the free list. For all others, forwards to &lt;code&gt; parent.deallocate&lt;/code&gt; if &lt;code&gt;Parent.deallocate&lt;/code&gt; is defined.</source>
          <target state="translated">경우 &lt;code&gt;block.length&lt;/code&gt; 가 내 &lt;code&gt;[min, max]&lt;/code&gt; 또는 프리리스트가 선택하지 않은 경우 ( &lt;code&gt;minSize == 0 &amp;amp;&amp;amp; maxSize == size_t.max&lt;/code&gt; ) 다음 프리리스트의 선두 블록을 삽입한다. 모든 다른 사람들을 위해, 전달하는 &lt;code&gt; parent.deallocate&lt;/code&gt; 경우 &lt;code&gt;Parent.deallocate&lt;/code&gt; 가 정의된다.</target>
        </trans-unit>
        <trans-unit id="5e4b98282d9ecdaaa0277f0ab4f62ad8d1b53af5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;blockSize == chooseAtRuntime&lt;/code&gt;, &lt;code&gt;BitmappedBlock&lt;/code&gt; offers a read/write property &lt;code&gt;blockSize&lt;/code&gt;. It must be set before any use of the allocator. Otherwise (i.e. &lt;code&gt;theBlockSize&lt;/code&gt; is a legit constant), &lt;code&gt;blockSize&lt;/code&gt; is an alias for &lt;code&gt;theBlockSize&lt;/code&gt;. Whether constant or variable, must also be a multiple of &lt;code&gt;alignment&lt;/code&gt;. This constraint is &lt;code&gt;assert&lt;/code&gt;ed statically and dynamically.</source>
          <target state="translated">경우 &lt;code&gt;blockSize == chooseAtRuntime&lt;/code&gt; , &lt;code&gt;BitmappedBlock&lt;/code&gt; 은 읽기 / 쓰기 속성 제공 &lt;code&gt;blockSize&lt;/code&gt; . 할당자를 사용하기 전에 설정해야합니다. 그렇지 않으면 (즉, &lt;code&gt;theBlockSize&lt;/code&gt; 는 합법적 인 상수), &lt;code&gt;blockSize&lt;/code&gt; 별칭입니다 &lt;code&gt;theBlockSize&lt;/code&gt; 은 . 상수이든 변수이든 &lt;code&gt;alignment&lt;/code&gt; 의 배수 여야합니다 . 이 제약 조건은 정적으로 동적으로 &lt;code&gt;assert&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="f93a5a60f8514085265f3aa9ca6972ee5e3faff9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;blockSize == chooseAtRuntime&lt;/code&gt;, &lt;code&gt;SharedBitmappedBlock&lt;/code&gt; offers a read/write property &lt;code&gt;blockSize&lt;/code&gt;. It must be set before any use of the allocator. Otherwise (i.e. &lt;code&gt;theBlockSize&lt;/code&gt; is a legit constant), &lt;code&gt;blockSize&lt;/code&gt; is an alias for &lt;code&gt;theBlockSize&lt;/code&gt;. Whether constant or variable, must also be a multiple of &lt;code&gt;alignment&lt;/code&gt;. This constraint is &lt;code&gt;assert&lt;/code&gt;ed statically and dynamically.</source>
          <target state="translated">경우 &lt;code&gt;blockSize == chooseAtRuntime&lt;/code&gt; , &lt;code&gt;SharedBitmappedBlock&lt;/code&gt; 은 읽기 / 쓰기 속성 제공 &lt;code&gt;blockSize&lt;/code&gt; . 할당자를 사용하기 전에 설정해야합니다. 그렇지 않으면 (즉, &lt;code&gt;theBlockSize&lt;/code&gt; 는 합법적 인 상수), &lt;code&gt;blockSize&lt;/code&gt; 별칭입니다 &lt;code&gt;theBlockSize&lt;/code&gt; 은 . 상수이든 변수이든 &lt;code&gt;alignment&lt;/code&gt; 의 배수 여야합니다 . 이 제약 조건은 정적으로 동적으로 &lt;code&gt;assert&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="8e23237ade60446568cde90bc631b8dba6e68c5d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is a Unicode lowercase &lt;a href=&quot;#Character&quot;&gt;character&lt;/a&gt;, then its uppercase equivalent is returned. Otherwise &lt;code&gt;c&lt;/code&gt; is returned.</source>
          <target state="translated">경우 &lt;code&gt;c&lt;/code&gt; 유니 코드 소문자입니다 &lt;a href=&quot;#Character&quot;&gt;문자&lt;/a&gt; , 다음의 대문자가 반환됩니다. 그렇지 않으면 &lt;code&gt;c&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="b4c4b1af0ac218e5d7d40db7db18515091e62fd4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is a Unicode uppercase &lt;a href=&quot;#Character&quot;&gt;character&lt;/a&gt;, then its lowercase equivalent is returned. Otherwise &lt;code&gt;c&lt;/code&gt; is returned.</source>
          <target state="translated">경우 &lt;code&gt;c&lt;/code&gt; 유니 코드 대문자 &lt;a href=&quot;#Character&quot;&gt;문자&lt;/a&gt; , 다음의 소문자 상당 반환됩니다. 그렇지 않으면 &lt;code&gt;c&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="9744833e493e9a4deaf2d113274c40f2b544663e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;dir == Direction.fwd&lt;/code&gt;, then a range iterates forward in time, whereas if &lt;code&gt;dir == Direction.bwd&lt;/code&gt;, then it iterates backwards in time. So, if &lt;code&gt;dir == Direction.fwd&lt;/code&gt; then &lt;code&gt;front == interval.begin&lt;/code&gt;, whereas if &lt;code&gt;dir == Direction.bwd&lt;/code&gt; then &lt;code&gt;front == interval.end&lt;/code&gt;. &lt;code&gt;func&lt;/code&gt; must generate a time point going in the proper direction of iteration, or a &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt;&lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt;&lt;/a&gt; will be thrown. So, to iterate forward in time, the time point that &lt;code&gt;func&lt;/code&gt; generates must be later in time than the one passed to it. If it's either identical or earlier in time, then a &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt;&lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt;&lt;/a&gt; will be thrown. To iterate backwards, then the generated time point must be before the time point which was passed in.</source>
          <target state="translated">&lt;code&gt;dir == Direction.fwd&lt;/code&gt; 인 경우 범위는 시간이 지나면 반복되는 반면 &lt;code&gt;dir == Direction.bwd&lt;/code&gt; 인 경우 시간이 지나면 반복됩니다. 따라서 &lt;code&gt;dir == Direction.fwd&lt;/code&gt; 이면 &lt;code&gt;front == interval.begin&lt;/code&gt; 이고 &lt;code&gt;dir == Direction.bwd&lt;/code&gt; 이면 &lt;code&gt;front == interval.end&lt;/code&gt; 입니다. &lt;code&gt;func&lt;/code&gt; 은 올바른 반복 방향으로 진행하는 시점을 생성해야합니다 . &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt; &lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt; &lt;/a&gt; 이 발생합니다. 따라서 시간을 앞으로 반복 하려면 &lt;code&gt;func&lt;/code&gt; 이 생성 하는 시점이 전달 된 시점보다 늦어 야합니다. 시간이 동일하거나 이전의 경우 &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt; &lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt; &lt;/a&gt;던져 질 것이다. 거꾸로 반복하려면 생성 된 시점이 전달 된 시점 이전이어야합니다.</target>
        </trans-unit>
        <trans-unit id="a610ee5ef0581a49f22c22f37935b0d33a042c3f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;filler&lt;/code&gt; is empty.</source>
          <target state="translated">&lt;code&gt;filler&lt;/code&gt; 가 비어있는 경우 .</target>
        </trans-unit>
        <trans-unit id="59e6f081398b1db2fd694d5b94d19e81b02d48a6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fun&lt;/code&gt; is a &lt;code&gt;string&lt;/code&gt;, a new single parameter function  If &lt;code&gt;fun&lt;/code&gt; is not a &lt;code&gt;string&lt;/code&gt;, an alias to &lt;code&gt;fun&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;fun&lt;/code&gt; A는 &lt;code&gt;string&lt;/code&gt; , 경우 새로운 단일 매개 변수 기능 &lt;code&gt;fun&lt;/code&gt; 아닌 &lt;code&gt;string&lt;/code&gt; , 별칭 &lt;code&gt;fun&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="109bcbee3e25a658c4c9396a1465014de8c69b2c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fun&lt;/code&gt; is not a string, &lt;code&gt;binaryFun&lt;/code&gt; aliases itself away to &lt;code&gt;fun&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;fun&lt;/code&gt; 이 문자열이 아닌 경우 &lt;code&gt;binaryFun&lt;/code&gt; 은 별명을 &lt;code&gt;fun&lt;/code&gt; 로 별칭 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="feeb8b9cc07251142d08e56cda48b8463e68f011" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;hasLength!Range&lt;/code&gt;, simply returns &lt;code&gt;range.length&lt;/code&gt; without checking &lt;code&gt;upTo&lt;/code&gt; (when specified).</source>
          <target state="translated">경우 &lt;code&gt;hasLength!Range&lt;/code&gt; , 단순히 반환 &lt;code&gt;range.length&lt;/code&gt; 을 확인하지 않고 &lt;code&gt;upTo&lt;/code&gt; (지정된 경우).</target>
        </trans-unit>
        <trans-unit id="46b7e88c254c5bba652608bb5aa781949149f305" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;haystack&lt;/code&gt; is a random-access range, all three components of the tuple have the same type as &lt;code&gt;haystack&lt;/code&gt;. Otherwise, &lt;code&gt;haystack&lt;/code&gt; must be a &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward range&lt;/a&gt; and the type of &lt;code&gt;result[0]&lt;/code&gt; and &lt;code&gt;result[1]&lt;/code&gt; is the same as &lt;a href=&quot;std_range#takeExactly&quot;&gt;&lt;code&gt;std.range.takeExactly&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;haystack&lt;/code&gt; 임의의 액세스 범위는, 튜플 모두 세 가지 구성 요소와 동일한 유형이 &lt;code&gt;haystack&lt;/code&gt; . 그렇지 않으면, &lt;code&gt;haystack&lt;/code&gt; 은 &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;포워드 범위&lt;/a&gt; 여야 하고 &lt;code&gt;result[0]&lt;/code&gt; 및 &lt;code&gt;result[1]&lt;/code&gt; 의 유형은 &lt;a href=&quot;std_range#takeExactly&quot;&gt; &lt;code&gt;std.range.takeExactly&lt;/code&gt; &lt;/a&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="3993b4b628968f5e6dd7d41599d550f5e0f99ef4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;impl.alignedAllocate&lt;/code&gt; exists, calls it and returns the result. Otherwise, always returns &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;impl.alignedAllocate&lt;/code&gt; 가 있으면 이를 호출하고 결과를 리턴합니다. 그렇지 않으면 항상 &lt;code&gt;null&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="02ba66810cd0cea189e643c4eeba55ce0d4de3e3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;impl.deallocate&lt;/code&gt; is not defined, returns &lt;code&gt;false&lt;/code&gt;. Otherwise it forwards the call.</source>
          <target state="translated">경우 &lt;code&gt;impl.deallocate&lt;/code&gt; 가 정의되지 않은 반환 &lt;code&gt;false&lt;/code&gt; . 그렇지 않으면 통화를 전달합니다.</target>
        </trans-unit>
        <trans-unit id="48d32ce690c5f4ef93e7705c87fc34b78de3c611" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;input&lt;/code&gt; is a &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward range&lt;/a&gt;, &lt;code&gt;needle&lt;/code&gt; can be a &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward range&lt;/a&gt; too. In this case &lt;code&gt;startsWith!pred(haystack, needle)&lt;/code&gt; is evaluated on each evaluation.</source>
          <target state="translated">경우 &lt;code&gt;input&lt;/code&gt; A는 &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;전진 기어 단은&lt;/a&gt; , &lt;code&gt;needle&lt;/code&gt; 될 수 &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;순방향 범위&lt;/a&gt; 도. 이 경우 &lt;code&gt;startsWith!pred(haystack, needle)&lt;/code&gt; 가 각 평가에서 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="26612f521f443b434c0c471a4bb077313e418fc6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;less&lt;/code&gt; is the less-than operator, which is the default option, then &lt;code&gt;BinaryHeap&lt;/code&gt; defines a so-called max-heap that optimizes extraction of the</source>
          <target state="translated">경우 &lt;code&gt;less&lt;/code&gt; 덜보다 기본 옵션입니다 운영자이며, 다음, &lt;code&gt;BinaryHeap&lt;/code&gt; 의 추출을 최적화하는 소위 최대 힙을 정의</target>
        </trans-unit>
        <trans-unit id="bfc0979cbe401db983c65651eae478d6291e89b3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;lhs != WithNaN.defaultValue!Lhs&lt;/code&gt; and the operator does not overflow, the function returns the same result as the built-in operator. In all other cases, returns &lt;code&gt;WithNaN.defaultValue!(typeof(lhs + rhs))&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;lhs != WithNaN.defaultValue!Lhs&lt;/code&gt; 및 운영자는 오버 플로우, 함수는 내장 연산자와 같은 결과를 반환하지 않습니다. 다른 모든 경우에는 &lt;code&gt;WithNaN.defaultValue!(typeof(lhs + rhs))&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="7cc27af0c815a7e79af80d07be90722649a52810" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;lhs == WithNaN.defaultValue!Lhs&lt;/code&gt;, returns &lt;code&gt;double.init&lt;/code&gt;. Otherwise, has the same semantics as the default comparison.</source>
          <target state="translated">경우 &lt;code&gt;lhs == WithNaN.defaultValue!Lhs&lt;/code&gt; , 반환 &lt;code&gt;double.init&lt;/code&gt; . 그렇지 않으면 기본 비교와 동일한 의미를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="d151dfc3083b5628c51cfe2464aced84ec2e31e0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; reference the same instance, then nothing is done.</source>
          <target state="translated">경우 &lt;code&gt;lhs&lt;/code&gt; 과 &lt;code&gt;rhs&lt;/code&gt; 동일한 인스턴스를 참조하고 아무것도 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1e390340bdf19475ede0638df9c1955fea065de9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;line&lt;/code&gt; has type &lt;code&gt;char[]&lt;/code&gt;, &lt;code&gt;wchar[]&lt;/code&gt;, &lt;code&gt;dchar[]&lt;/code&gt;, the line's content will be reused (overwritten) across reads.</source>
          <target state="translated">경우 &lt;code&gt;line&lt;/code&gt; 형이 &lt;code&gt;char[]&lt;/code&gt; , &lt;code&gt;wchar[]&lt;/code&gt; , &lt;code&gt;dchar[]&lt;/code&gt; , 라인의 내용이 다시 사용됩니다 (덮어 쓰기)를 통해 읽습니다.</target>
        </trans-unit>
        <trans-unit id="98f495eca2d1ec291e5bd0a688459f5f1c82028b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;line&lt;/code&gt; has type &lt;code&gt;immutable(ubyte)[]&lt;/code&gt;, the behavior is similar to case (1), except that no UTF checking is attempted upon input.</source>
          <target state="translated">경우 &lt;code&gt;line&lt;/code&gt; 형 갖는 &lt;code&gt;immutable(ubyte)[]&lt;/code&gt; , 동작은 케이스 (1)과 유사한, 더 UTF 검사가 입력에 시도되지 않은 것을 제외.</target>
        </trans-unit>
        <trans-unit id="1a835fb44628e74f7f9ff451e8b58c089bf38a93" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;line&lt;/code&gt; has type &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;wstring&lt;/code&gt;, or &lt;code&gt;dstring&lt;/code&gt;, a new string of the respective type is allocated every read.</source>
          <target state="translated">경우 &lt;code&gt;line&lt;/code&gt; 타입이 &lt;code&gt;string&lt;/code&gt; , &lt;code&gt;wstring&lt;/code&gt; , 또는 &lt;code&gt;dstring&lt;/code&gt; 을 , 각각의 유형의 새 문자열을 읽을 때마다 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="18e388959a9abaf079dbbac18945110b36067b2b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;line&lt;/code&gt; has type &lt;code&gt;ubyte[]&lt;/code&gt;, the behavior is similar to case (2), except that no UTF checking is attempted upon input.</source>
          <target state="translated">경우 &lt;code&gt;line&lt;/code&gt; 형 갖는다 &lt;code&gt;ubyte[]&lt;/code&gt; , 동작은 케이스 (2)와 유사하다, 더 UTF 검사가 입력에 시도되지 않은 것을 제외.</target>
        </trans-unit>
        <trans-unit id="c61c7e699d18c7312070fee75c860133527ced6d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;main()&lt;/code&gt; or the thread returns normally, (does not throw an exception), the static destructor is added to the list of functions to be called on thread termination.</source>
          <target state="translated">경우 &lt;code&gt;main()&lt;/code&gt; 또는 스레드 반환 일반적으로 (예외를 throw하지 않습니다), 정적 소멸자는 스레드 종료에 호출되는 함수 목록에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="c93fc296f2b731310f3189f9c017eaec2be70e3e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;maxSize == unbounded&lt;/code&gt;, returns &lt;code&gt;parent.goodAllocSize(bytes)&lt;/code&gt;. Otherwise, returns &lt;code&gt;max&lt;/code&gt; for sizes in the interval &lt;code&gt;[min, max]&lt;/code&gt;, and &lt;code&gt;parent.goodAllocSize(bytes)&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;maxSize == unbounded&lt;/code&gt; 인 경우 &lt;code&gt;parent.goodAllocSize(bytes)&lt;/code&gt; 반환합니다 . 그렇지 않은 경우, 반환 &lt;code&gt;max&lt;/code&gt; 간격의 크기 &lt;code&gt;[min, max]&lt;/code&gt; 및 &lt;code&gt;parent.goodAllocSize(bytes)&lt;/code&gt; 그렇지.</target>
        </trans-unit>
        <trans-unit id="27889a42945896ba8e96a2b9190859d044697880" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n &amp;gt;= r.length&lt;/code&gt;, the algorithm has no effect and returns &lt;code&gt;r[0 .. r.length]&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;n &amp;gt;= r.length&lt;/code&gt; 알고리즘은 아무런 효과가 없다 되돌 &lt;code&gt;r[0 .. r.length]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6c001d68799c0a0c1fe4332536339591e3128dd5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n&lt;/code&gt; is eligible for freelisting, returns &lt;code&gt;max&lt;/code&gt;. Otherwise, returns &lt;code&gt;parent.goodAllocSize(n)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; 이 프리리스트에 적합 하면 &lt;code&gt;max&lt;/code&gt; 를 리턴합니다 . 그렇지 않으면 &lt;code&gt;parent.goodAllocSize(n)&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="0fec7ab17fff539f84df945449516192c8415a4a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n&lt;/code&gt; is not defined, an infinite random access range with slicing.  If &lt;code&gt;n&lt;/code&gt; is defined, a random access range with slicing.</source>
          <target state="translated">경우 &lt;code&gt;n&lt;/code&gt; 정의되지 않은, 슬라이싱과 무한 랜덤 액세스 범위. 경우 &lt;code&gt;n&lt;/code&gt; 정의되어, 슬라이싱과 랜덤 액세스 범위.</target>
        </trans-unit>
        <trans-unit id="7f2409b5e5208bcbd4bd9ae5b46439868d522731" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;opCall&lt;/code&gt; is overridden for the struct, and the struct is initialized with a value that is of a different type, then the &lt;code&gt;opCall&lt;/code&gt; operator is called:</source>
          <target state="translated">경우 &lt;code&gt;opCall&lt;/code&gt; 이 구조체에 대해 재정의하고, 구조체가 다른 유형 인 값으로 초기화 한 후 &lt;code&gt;opCall&lt;/code&gt; 의 연산자라고합니다 :</target>
        </trans-unit>
        <trans-unit id="0a8768e44be6ce84df4d8ac63955bf151c1ba410" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;opIndex&lt;/code&gt; is declared with only one argument, the compile-time argument to &lt;code&gt;opDollar&lt;/code&gt; may be omitted. In this case, it is illegal to use &lt;code&gt;$&lt;/code&gt; inside an array indexing expression with more than one argument.</source>
          <target state="translated">경우 &lt;code&gt;opIndex&lt;/code&gt; 는 하나의 인수 선언에 컴파일시 인수 &lt;code&gt;opDollar&lt;/code&gt; 은 생략 될 수있다. 이 경우 둘 이상의 인수가있는 배열 인덱싱 표현식에서 &lt;code&gt;$&lt;/code&gt; 를 사용하는 것은 불법 입니다.</target>
        </trans-unit>
        <trans-unit id="1c029e2e84868e89d9aba168477cd4b281e4a698" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; is a pointer somewhere inside a block allocated with this allocator, &lt;code&gt;result&lt;/code&gt; holds a pointer to the beginning of the allocated block and returns &lt;code&gt;Ternary.yes&lt;/code&gt;. Otherwise, &lt;code&gt;result&lt;/code&gt; holds &lt;code&gt;null&lt;/code&gt; and returns &lt;code&gt;Ternary.no&lt;/code&gt;. If the pointer points immediately after an allocated block, the result is implementation defined.</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; 가이 할당 &lt;code&gt;Ternary.yes&lt;/code&gt; 할당 된 블록 내부의 포인터 인 경우 &lt;code&gt;result&lt;/code&gt; 는 할당 된 블록의 시작에 대한 포인터를 보유하고 Ternary.yes를 리턴합니다 . 그렇지 않으면 &lt;code&gt;result&lt;/code&gt; 는 &lt;code&gt;null&lt;/code&gt; 을 보유하고 &lt;code&gt;Ternary.no&lt;/code&gt; 를 반환합니다 . 포인터가 할당 된 블록 바로 다음을 가리키면 결과가 구현 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="e2eb2629d5b4956bd1542eca4775455139c95a61" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; is a relative directory, return it unaltered.</source>
          <target state="translated">경우 &lt;code&gt;path&lt;/code&gt; 상대 디렉토리, 그것은 변경되지 않은 반환합니다.</target>
        </trans-unit>
        <trans-unit id="702fecc6b0bc34adfafc2cb51d268f4825e76aef" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; is already absolute, return it.</source>
          <target state="translated">경우 &lt;code&gt;path&lt;/code&gt; 이미 절대 그것을 돌려줍니다.</target>
        </trans-unit>
        <trans-unit id="051c5165fdb7f4181c26346b52a8a370bb269c20" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; is empty, return &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; 가 비어 있으면 &lt;code&gt;null&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="de70cd968c35f871aa7f988334ddd5070ebe64cf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; is on the form &lt;code&gt;\\&lt;i&gt;server&lt;/i&gt;\&lt;i&gt;share&lt;/i&gt;\...&lt;/code&gt; (UNC path), &lt;a href=&quot;#isValidFilename&quot;&gt;&lt;code&gt;isValidFilename&lt;/code&gt;&lt;/a&gt; is applied to</source>
          <target state="translated">경우 &lt;code&gt;path&lt;/code&gt; 형태에 &lt;code&gt;\\&lt;i&gt;server&lt;/i&gt;\&lt;i&gt;share&lt;/i&gt;\...&lt;/code&gt; (UNC 경로), &lt;a href=&quot;#isValidFilename&quot;&gt; &lt;code&gt;isValidFilename&lt;/code&gt; 이&lt;/a&gt; 적용됩니다</target>
        </trans-unit>
        <trans-unit id="5ccfc704dde80078077c0681938c9dc1e45235e2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; starts with &lt;code&gt;\\.\&lt;/code&gt; (Win32 device namespace) this function returns &lt;code&gt;false&lt;/code&gt;; such paths are beyond the scope of this module.</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; 가 &lt;code&gt;\\.\&lt;/code&gt; (Win32 장치 네임 스페이스) 로 시작 하면 이 함수는 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 . 이러한 경로는이 모듈의 범위를 벗어납니다.</target>
        </trans-unit>
        <trans-unit id="891daee93beed99df04fb47b76bddba5d0aeec90" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; starts with &lt;code&gt;\\?\&lt;/code&gt; (long UNC path), the only requirement for the rest of the string is that it does not contain the null character.</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; 가 &lt;code&gt;\\?\&lt;/code&gt; (긴 UNC 경로) 로 시작하는 경우 나머지 문자열에 대한 유일한 요구 사항은 null 문자를 포함하지 않는 것입니다.</target>
        </trans-unit>
        <trans-unit id="cf0839c8941b9553277dcc1246fadae5b4af51e5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;postData&lt;/code&gt; is non-null the method will be set to &lt;code&gt;post&lt;/code&gt; for HTTP requests.</source>
          <target state="translated">&lt;code&gt;postData&lt;/code&gt; 가 널이 아닌 경우 메소드는 HTTP 요청에 대해 &lt;code&gt;post&lt;/code&gt; 하도록 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="b45cfaf55131d31d198ea2c44bd484f7f79174d9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pretty&lt;/code&gt; is false no whitespaces are generated. If &lt;code&gt;pretty&lt;/code&gt; is true serialized string is formatted to be human-readable. Set the &lt;a href=&quot;#JSONOptions.specialFloatLiterals&quot;&gt;&lt;code&gt;JSONOptions.specialFloatLiterals&lt;/code&gt;&lt;/a&gt; flag is set in &lt;code&gt;options&lt;/code&gt; to encode NaN/Infinity as strings.</source>
          <target state="translated">&lt;code&gt;pretty&lt;/code&gt; 가 false 이면 공백이 생성되지 않습니다. 경우 &lt;code&gt;pretty&lt;/code&gt; 사실 직렬화 된 문자열은 사람이 읽을 수 있도록 형식이 설정되어 있습니다. 설정 &lt;a href=&quot;#JSONOptions.specialFloatLiterals&quot;&gt; &lt;code&gt;JSONOptions.specialFloatLiterals&lt;/code&gt; 의&lt;/a&gt; 플래그가 설정되어 &lt;code&gt;options&lt;/code&gt; 인코딩 NaN이 / 문자열로 무한대로.</target>
        </trans-unit>
        <trans-unit id="4fe6d0c26964bd6dde3a76798f875b6541f56e6c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;primary&lt;/code&gt; does not own &lt;code&gt;b&lt;/code&gt;, then &lt;code&gt;fallback.reallocate(b, newSize)&lt;/code&gt; is attempted. If that fails, an attempt is made to move the allocation from &lt;code&gt;fallback&lt;/code&gt; to &lt;code&gt;primary&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;primary&lt;/code&gt; 소유하지 않는 &lt;code&gt;b&lt;/code&gt; 다음, &lt;code&gt;fallback.reallocate(b, newSize)&lt;/code&gt; 시도한다. 실패하면 할당을 &lt;code&gt;fallback&lt;/code&gt; 에서 &lt;code&gt;primary&lt;/code&gt; 으로 이동하려고 시도 합니다.</target>
        </trans-unit>
        <trans-unit id="45d84a0c7a2f66706678e328dd9e74e78023bd34" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;printf&lt;/code&gt;-style logging is needed add a &lt;b&gt;f&lt;/b&gt; to the logging call, such as &lt;code&gt;myLogger.infof(&quot;Hello %s&quot;, &quot;world&quot;);&lt;/code&gt; or &lt;code&gt;fatalf(&quot;errno %d&quot;, 1337)&lt;/code&gt;. The additional &lt;b&gt;f&lt;/b&gt; appended to the function name enables &lt;code&gt;printf&lt;/code&gt;-style logging for all combinations of explicit &lt;code&gt;LogLevel&lt;/code&gt; and conditional logging functions and methods.</source>
          <target state="translated">&lt;code&gt;printf&lt;/code&gt; 스타일 로깅이 필요한 경우 &lt;code&gt;myLogger.infof(&quot;Hello %s&quot;, &quot;world&quot;);&lt;/code&gt; 와 같은 로깅 호출에 &lt;b&gt;f&lt;/b&gt; 를 추가하십시오 . 또는 &lt;code&gt;fatalf(&quot;errno %d&quot;, 1337)&lt;/code&gt; 입니다. 함수 이름에 추가 된 &lt;b&gt;f&lt;/b&gt; 는 명시 적 &lt;code&gt;LogLevel&lt;/code&gt; 및 조건부 로깅 함수 및 메소드 의 모든 조합에 대해 &lt;code&gt;printf&lt;/code&gt; 스타일 로깅을 가능하게 합니다.</target>
        </trans-unit>
        <trans-unit id="c809d18303614396b533b1264943fb0bf373af22" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;r&lt;/code&gt; contains equivalent elements, multiple permutations of &lt;code&gt;r&lt;/code&gt; satisfy these constraints. In such cases, &lt;code&gt;pivotPartition&lt;/code&gt; attempts to distribute equivalent elements fairly to the left and right of &lt;code&gt;k&lt;/code&gt; such that &lt;code&gt;k&lt;/code&gt; stays close to &lt;code&gt;r.length / 2&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;r&lt;/code&gt; 은 해당 요소를 포함, 여러 순열 &lt;code&gt;r&lt;/code&gt; 은 이러한 제약 조건을 만족시킨다. 이러한 경우 &lt;code&gt;pivotPartition&lt;/code&gt; 은 &lt;code&gt;k&lt;/code&gt; 가 &lt;code&gt;r.length / 2&lt;/code&gt; 가깝도록 &lt;code&gt;k&lt;/code&gt; 의 왼쪽과 오른쪽에 동등한 요소를 균등하게 분배하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="23935d946a100a97c3e455c30306a633f7b98438" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;r&lt;/code&gt; has a length, then this is &amp;Omicron;(&lt;code&gt;1&lt;/code&gt;). Otherwise, it's &amp;Omicron;(&lt;code&gt;r.length&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;r&lt;/code&gt; 의 길이가 있으면 &amp;Omicron; ( &lt;code&gt;1&lt;/code&gt; )입니다. 그렇지 않으면 &amp;Omicron; ( &lt;code&gt;r.length&lt;/code&gt; )입니다.</target>
        </trans-unit>
        <trans-unit id="f163286db8bb098fc5cc4073249e55f06a301b9e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;r&lt;/code&gt; is a string with Unicode characters in it, &lt;code&gt;padLeft&lt;/code&gt; follows D's rules about length for strings, which is not the number of characters, or graphemes, but instead the number of encoding units. If you want to treat each grapheme as only one encoding unit long, then call &lt;a href=&quot;std_uni#byGrapheme&quot;&gt;&lt;code&gt;std.uni.byGrapheme&lt;/code&gt;&lt;/a&gt; before calling this function.</source>
          <target state="translated">&lt;code&gt;r&lt;/code&gt; 이 유니 코드 문자가 포함 된 문자열 인 경우 &lt;code&gt;padLeft&lt;/code&gt; 는 문자열 길이에 대한 D의 규칙을 따릅니다. 이는 문자 수 또는 그래 핀 이 아니라 대신 인코딩 단위 수입니다. 각 &lt;a href=&quot;std_uni#byGrapheme&quot;&gt; &lt;code&gt;std.uni.byGrapheme&lt;/code&gt; &lt;/a&gt; 를 하나의 인코딩 단위로만 처리하려면 이 함수를 호출하기 전에 std.uni.byGrapheme 을 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="6a927ae2914fb825262976485c0cc9304c3da3c5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;r&lt;/code&gt; is not an auto-decodable string (i.e. a narrow string or a user-defined type that implicits converts to a string type), then &lt;code&gt;r&lt;/code&gt; is returned.  Otherwise, &lt;code&gt;r&lt;/code&gt; is converted to its corresponding string type (if it's not already a string) and wrapped in a random-access range where the element encoding type of the string (its code unit) is the element type of the range, and that range returned. The range has slicing.  If &lt;code&gt;r&lt;/code&gt; is quirky enough to be a struct or class which is an input range of characters on its own (i.e. it has the input range API as member functions),</source>
          <target state="translated">&lt;code&gt;r&lt;/code&gt; 이 자동 디코딩 가능 문자열이 아닌 경우 (예 : 좁은 문자열 또는 암시 적을 문자열 유형으로 변환하는 사용자 정의 유형) &lt;code&gt;r&lt;/code&gt; 이 반환됩니다. 그렇지 않으면 &lt;code&gt;r&lt;/code&gt; 은 해당 문자열 유형으로 변환되고 (아직 문자열이 아닌 경우) 문자열의 요소 인코딩 유형 (코드 단위)이 범위의 요소 유형 및 해당 범위의 임의 액세스 범위로 랩핑됩니다. 돌아 왔습니다. 범위는 슬라이싱이 있습니다. &lt;code&gt;r&lt;/code&gt; 이 그 자체로 문자의 입력 범위 인 구조체 또는 클래스가 될 정도로 기발한 경우 (즉, 입력 범위 API를 멤버 함수로 사용)</target>
        </trans-unit>
        <trans-unit id="df6a47c8f433360081103c7b545791ca9cd35f93" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;range&lt;/code&gt; does not have length, and &lt;code&gt;popFront&lt;/code&gt; is called when &lt;code&gt;front.index == Enumerator.max&lt;/code&gt;, the index will overflow and continue from &lt;code&gt;Enumerator.min&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;range&lt;/code&gt; 길이를 가지고 있지 않으며, &lt;code&gt;popFront&lt;/code&gt; 이 때 호출되는 &lt;code&gt;front.index == Enumerator.max&lt;/code&gt; , 인덱스가 오버플에서 계속 &lt;code&gt;Enumerator.min&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5e2389187db9ad1c90dc2cdb963a735557c21c35" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;range&lt;/code&gt; has length, then it is an error to pass a value for &lt;code&gt;start&lt;/code&gt; so that &lt;code&gt;start + range.length&lt;/code&gt; is bigger than &lt;code&gt;Enumerator.max&lt;/code&gt;, thus it is ensured that overflow cannot happen.</source>
          <target state="translated">경우 &lt;code&gt;range&lt;/code&gt; 길이가, 다음이 값을 전달하면 오류가 &lt;code&gt;start&lt;/code&gt; 되도록 &lt;code&gt;start + range.length&lt;/code&gt; 보다 큰 &lt;code&gt;Enumerator.max&lt;/code&gt; 따라서는 오버 플로우가 발생하지 않는지를 확인한다.</target>
        </trans-unit>
        <trans-unit id="111a596bfe5993b016245842df9ecb465a3674d7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rhs != WithNaN.defaultValue!Rhs&lt;/code&gt; and the operator does not overflow, the function returns the same result as the built-in operator. In all other cases, returns &lt;code&gt;WithNaN.defaultValue!(typeof(lhs + rhs))&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;rhs != WithNaN.defaultValue!Rhs&lt;/code&gt; 및 운영자는 오버 플로우, 함수는 내장 연산자와 같은 결과를 반환하지 않습니다. 다른 모든 경우에는 &lt;code&gt;WithNaN.defaultValue!(typeof(lhs + rhs))&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="f5536ec979292168bf217723d15877e765427904" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rhs&lt;/code&gt; is &lt;code&gt;WithNaN.defaultValue!Rhs&lt;/code&gt;, returns &lt;code&gt;WithNaN.defaultValue!Lhs&lt;/code&gt;. Otherwise, returns &lt;code&gt;cast(Lhs) rhs&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;rhs&lt;/code&gt; 있다 &lt;code&gt;WithNaN.defaultValue!Rhs&lt;/code&gt; , 반환 &lt;code&gt;WithNaN.defaultValue!Lhs&lt;/code&gt; . 그렇지 않으면 &lt;code&gt;cast(Lhs) rhs&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="6ede40fbc0f7d83884db066a6386fc8a519d5ed8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s == 0&lt;/code&gt;, the call may return any empty slice (including &lt;code&gt;null&lt;/code&gt;). Otherwise, the call allocates &lt;code&gt;s&lt;/code&gt; bytes of memory and returns the allocated block, or &lt;code&gt;null&lt;/code&gt; if the request could not be satisfied.</source>
          <target state="translated">경우 &lt;code&gt;s == 0&lt;/code&gt; , 전화는 (를 포함하여 빈 슬라이스 반환 할 수 있습니다 &lt;code&gt;null&lt;/code&gt; ). 그렇지 않으면 호출은 &lt;code&gt;s&lt;/code&gt; 바이트의 메모리를 할당하고 할당 된 블록을 리턴하거나 요청을 충족시킬 수없는 경우 &lt;code&gt;null&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="9eadce3ccc140e91f7b505d0328ee8cc176eeac6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s == SwapStrategy.unstable &amp;amp;&amp;amp; isRandomAccessRange!Range &amp;amp;&amp;amp; hasLength!Range &amp;amp;&amp;amp; hasLvalueElements!Range&lt;/code&gt;, then elements are moved from the end of the range into the slots to be filled. In this case, the absolute minimum of moves is performed.</source>
          <target state="translated">경우 &lt;code&gt;s == SwapStrategy.unstable &amp;amp;&amp;amp; isRandomAccessRange!Range &amp;amp;&amp;amp; hasLength!Range &amp;amp;&amp;amp; hasLvalueElements!Range&lt;/code&gt; 슬롯이 채워 져야으로 다음 요소 범위의 단부로부터 이동된다. 이 경우 절대 최소 이동이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="8bbc6063db8df4c25b1d7ab2586ea771801923fb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a function template, i.e. the only member of a template and that member is a function, return that template.</source>
          <target state="translated">경우 &lt;code&gt;s&lt;/code&gt; 함수 템플릿, 즉 템플릿의 유일한 멤버와 그 멤버 함수, 해당 템플릿을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ac063e0ae979bd086a87ed636e906eb9690bf4e1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;str&lt;/code&gt; ends with &lt;code&gt;delimiter&lt;/code&gt;, then &lt;code&gt;str&lt;/code&gt; is returned without &lt;code&gt;delimiter&lt;/code&gt; on its end. If it &lt;code&gt;str&lt;/code&gt; does</source>
          <target state="translated">경우 &lt;code&gt;str&lt;/code&gt; 과 끝 &lt;code&gt;delimiter&lt;/code&gt; 한 후 &lt;code&gt;str&lt;/code&gt; 없이 반환 &lt;code&gt;delimiter&lt;/code&gt; 의 끝. 이 경우 &lt;code&gt;str&lt;/code&gt; 않습니다</target>
        </trans-unit>
        <trans-unit id="9a851969ac104167dbde2b6f580e63232a655ac8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;str&lt;/code&gt; starts with &lt;code&gt;delimiter&lt;/code&gt;, then the part of &lt;code&gt;str&lt;/code&gt; following &lt;code&gt;delimiter&lt;/code&gt; is returned. If &lt;code&gt;str&lt;/code&gt; does</source>
          <target state="translated">경우 &lt;code&gt;str&lt;/code&gt; 시작 &lt;code&gt;delimiter&lt;/code&gt; , 다음의 부분 &lt;code&gt;str&lt;/code&gt; 을 다음 &lt;code&gt;delimiter&lt;/code&gt; 반환됩니다. 경우 &lt;code&gt;str&lt;/code&gt; 않습니다</target>
        </trans-unit>
        <trans-unit id="4978f696ceefb2aa4374b5f4ce674343dc8b0fed" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sz&lt;/code&gt; is zero, the memory referenced by p will be deallocated as if by a call to &lt;code&gt;free&lt;/code&gt;. If &lt;code&gt;p&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, new memory will be allocated via &lt;code&gt;malloc&lt;/code&gt;. If &lt;code&gt;p&lt;/code&gt; is pointing to memory not allocated from the GC or to the interior of an allocated memory block, no operation is performed and null is returned.</source>
          <target state="translated">경우 &lt;code&gt;sz&lt;/code&gt; 제로, P에 의해 참조되는 메모리의 호출에 의해 것처럼 해제 될 것입니다 &lt;code&gt;free&lt;/code&gt; . &lt;code&gt;p&lt;/code&gt; 가 &lt;code&gt;null&lt;/code&gt; 인 경우 , &lt;code&gt;malloc&lt;/code&gt; 을 통해 새 메모리가 할당됩니다 . &lt;code&gt;p&lt;/code&gt; 가 GC로부터 할당되지 않은 메모리를 가리 키거나 할당 된 메모리 블록의 내부를 가리키는 경우 , 어떠한 동작도 수행되지 않고 널이 리턴된다.</target>
        </trans-unit>
        <trans-unit id="b756c4e80a3354d029916e71e883d1d288090aff" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ticksPerSec&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;, then then &lt;code&gt;TickDuration&lt;/code&gt; failed to get the value of &lt;code&gt;ticksPerSec&lt;/code&gt; on the current system, and &lt;code&gt;TickDuration&lt;/code&gt; is not going to work. That would be highly abnormal though.</source>
          <target state="translated">경우 &lt;code&gt;ticksPerSec&lt;/code&gt; 가 있다 &lt;code&gt;0&lt;/code&gt; , 다음 다음 &lt;code&gt;TickDuration&lt;/code&gt; 은 값 가져 오지 못했습니다 &lt;code&gt;ticksPerSec&lt;/code&gt; 현재 시스템에, 그리고 &lt;code&gt;TickDuration&lt;/code&gt; 는 작업에 갈 수 없습니다. 그래도 매우 비정상적입니다.</target>
        </trans-unit>
        <trans-unit id="0a174cf4ab1d67c6c049d75173bd4c15d10ca6f9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;timeval.tv_sec&lt;/code&gt; is int, and the result can't fit in an int, then the closest value that can be held in 32 bits will be used for &lt;code&gt;tv_sec&lt;/code&gt;. (so &lt;code&gt;int.max&lt;/code&gt; if it goes over and &lt;code&gt;int.min&lt;/code&gt; if it goes under).</source>
          <target state="translated">경우 &lt;code&gt;timeval.tv_sec&lt;/code&gt; 는 int이며, 그 결과는 INT에 맞지 않을 수 있으며, 그 다음 32 비트에 유지 될 수있는 가장 가까운 값을 사용한다 &lt;code&gt;tv_sec&lt;/code&gt; 가 . (따라서 &lt;code&gt;int.max&lt;/code&gt; , &lt;code&gt;int.min&lt;/code&gt; 지면 int.min ).</target>
        </trans-unit>
        <trans-unit id="b737bf16441ab6f2f4b4d91936f54afa2de4c527" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;toHash&lt;/code&gt; must consistently be the same value when &lt;code&gt;opEquals&lt;/code&gt; returns true. In other words, two objects that are considered equal should always have the same hash value. Otherwise, undefined behavior will result.</source>
          <target state="translated">경우 &lt;code&gt;toHash&lt;/code&gt; 이 때 지속적으로 같은 값이어야합니다 &lt;code&gt;opEquals&lt;/code&gt; 는 true를 돌려줍니다. 즉, 동일한 것으로 간주되는 두 객체는 ​​항상 동일한 해시 값을 가져야합니다. 그렇지 않으면 정의되지 않은 동작이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="46b829bd712225872ea6d9fe14e82ebf07db56c2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;toHash&lt;/code&gt; must consistently be the same value when &lt;code&gt;opEquals&lt;/code&gt; returns true. In other words, two structs that are considered equal should always have the same hash value. Otherwise, undefined behavior will result.</source>
          <target state="translated">경우 &lt;code&gt;toHash&lt;/code&gt; 이 때 지속적으로 같은 값이어야합니다 &lt;code&gt;opEquals&lt;/code&gt; 는 true를 돌려줍니다. 다시 말해, 동일한 것으로 간주되는 두 개의 구조체는 항상 동일한 해시 값을 가져야합니다. 그렇지 않으면 정의되지 않은 동작이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="bdd34bf58210d81d6b36b3924a3e5089f87b29e6" translate="yes" xml:space="preserve">
          <source>If B to A conversion is convariant that requires offseet adjusting, all return statements should be adjusted to return expressions typed A.</source>
          <target state="translated">B에서 A 로의 변환이 오프 시트 조정을 필요로하는 불변 인 경우, 모든 리턴 문은 A 유형의 표현식을 리턴하도록 조정되어야합니다.</target>
        </trans-unit>
        <trans-unit id="5f616405142623769cdbbf978f769d6bf8291c51" translate="yes" xml:space="preserve">
          <source>If JSON value is null, then operator initializes it with object and then sets &lt;code&gt;value&lt;/code&gt; for it.</source>
          <target state="translated">JSON 값이 null이면 연산자는 객체로 &lt;code&gt;value&lt;/code&gt; 을 초기화 한 다음 값 을 설정 합니다.</target>
        </trans-unit>
        <trans-unit id="b3d334f3b16094aef354285c2c419452a7b589ea" translate="yes" xml:space="preserve">
          <source>If Source is a &lt;code&gt;struct&lt;/code&gt; then wrapping/unwrapping will create a copy; it is not possible to affect the original &lt;code&gt;struct&lt;/code&gt; through the wrapper.</source>
          <target state="translated">Source가 &lt;code&gt;struct&lt;/code&gt; 라면 랩핑 / 언 래핑은 복사본을 생성합니다. 랩퍼를 통해 원래 &lt;code&gt;struct&lt;/code&gt; 에 영향을 줄 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="2e8ce4614eba95d281d33d622683800da451bb90" translate="yes" xml:space="preserve">
          <source>If Statement</source>
          <target state="translated">If 문</target>
        </trans-unit>
        <trans-unit id="dd4a3f3a81119e68ec01207d19a926cbd1e5f669" translate="yes" xml:space="preserve">
          <source>If Targets has only one entry and Source is a class which explicitly implements it, wrap simply returns src upcasted to &lt;code&gt;Targets[0]&lt;/code&gt;.</source>
          <target state="translated">Targets에 항목이 하나만 있고 Source가 명시 적으로 구현하는 클래스 인 경우 wrap은 &lt;code&gt;Targets[0]&lt;/code&gt; 업 캐스트 된 src를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="562d6a085d036935dc458e97eb2b83b32b781d44" translate="yes" xml:space="preserve">
          <source>If a</source>
          <target state="translated">만약</target>
        </trans-unit>
        <trans-unit id="38354ffb09e774c4e1e6d7b1ae1d349a56902b44" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;declaration#StructInitializer&quot;&gt;&lt;i&gt;StructInitializer&lt;/i&gt;&lt;/a&gt; is supplied, the fields are initialized by the &lt;a href=&quot;declaration#StructMemberInitializer&quot;&gt;&lt;i&gt;StructMemberInitializer&lt;/i&gt;&lt;/a&gt; syntax.</source>
          <target state="translated">경우 &lt;a href=&quot;declaration#StructInitializer&quot;&gt;&lt;i&gt;StructInitializer가&lt;/i&gt;&lt;/a&gt; 공급되고, 필드는 초기화된다 &lt;a href=&quot;declaration#StructMemberInitializer&quot;&gt;&lt;i&gt;StructMemberInitializer의&lt;/i&gt;&lt;/a&gt; 구문.</target>
        </trans-unit>
        <trans-unit id="d74a8d147475df621b5e8ac9d1c6cc1de44dcbfd" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;union S&lt;/code&gt; has fields that define a copy constructor, whenever an object of type &lt;code&gt;S&lt;/code&gt; is initialized by copy, an error will be issued. The same rule applies to overlapped fields (anonymous unions).</source>
          <target state="translated">경우 &lt;code&gt;union S&lt;/code&gt; 복사 생성자를 정의하는 필드가, 형의 객체 때마다 &lt;code&gt;S&lt;/code&gt; 가 사본 초기화 오류가 발행됩니다. 겹친 필드 (익명 공용체)에도 동일한 규칙이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="82eb1a8a8a78d51182899822b5022de27e60420b" translate="yes" xml:space="preserve">
          <source>If a and b are both class objects, then the expression is rewritten as:</source>
          <target state="translated">a와 b가 모두 클래스 객체이면 표현식은 다음과 같이 다시 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="5e7e375e1c7dad6e65f441c0e60a25b131f8701e" translate="yes" xml:space="preserve">
          <source>If a cast to a floating-point type is requested and &lt;code&gt;Hook&lt;/code&gt; defines &lt;code&gt;onBadCast&lt;/code&gt;, the cast is verified by ensuring &lt;code&gt;get == cast(T) U(get)&lt;/code&gt;. If that is not &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;hook.onBadCast!U(get)&lt;/code&gt; is returned.</source>
          <target state="translated">부동 소수점 유형으로 의 캐스트가 요청되고 &lt;code&gt;Hook&lt;/code&gt; 가 &lt;code&gt;onBadCast&lt;/code&gt; 를 정의 하는 경우 &lt;code&gt;get == cast(T) U(get)&lt;/code&gt; 확인하여 캐스트를 확인합니다 . 그가 아닌 경우 &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;hook.onBadCast!U(get)&lt;/code&gt; 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="214d150104c62cbd9a8df607ea8c5c4b3837548b" translate="yes" xml:space="preserve">
          <source>If a cast to an integral type is requested and &lt;code&gt;Hook&lt;/code&gt; defines &lt;code&gt;onBadCast&lt;/code&gt;, the cast is verified by ensuring &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;cast(U) get&lt;/code&gt; are the same arithmetic number. (Note that &lt;code&gt;int(-1)&lt;/code&gt; and &lt;code&gt;uint(1)&lt;/code&gt; are different values arithmetically although they have the same bitwise representation and compare equal by language rules.) If the numbers are not arithmetically equal, &lt;code&gt;hook.onBadCast!U(get)&lt;/code&gt; is returned.</source>
          <target state="translated">정수 유형으로의 캐스트가 요청되고 &lt;code&gt;Hook&lt;/code&gt; 이 &lt;code&gt;onBadCast&lt;/code&gt; 를 정의 하는 경우 &lt;code&gt;get&lt;/code&gt; 및 &lt;code&gt;cast(U) get&lt;/code&gt; 이 동일한 산술 번호 인지 확인하여 캐스트를 확인합니다 . (참고 &lt;code&gt;int(-1)&lt;/code&gt; 와 &lt;code&gt;uint(1)&lt;/code&gt; 은 동일한 비트 표현이 언어 규칙에 따라 동일한 비교합니다. 산술적으로하지만 다른 값이다) 숫자가 산술적으로 동일하지 않을 경우, &lt;code&gt;hook.onBadCast!U(get)&lt;/code&gt; 반환 .</target>
        </trans-unit>
        <trans-unit id="f50b34e635f5b3d69730e335c13e613f658b1407" translate="yes" xml:space="preserve">
          <source>If a choice's return type is void, the choice must throw an exception, unless all the choices are void. In that case, castSwitch itself will return void.</source>
          <target state="translated">선택의 반환 유형이 void 인 경우 모든 선택이 void가 아닌 한 선택은 예외를 발생시켜야합니다. 이 경우 castSwitch 자체는 void를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fb6d0d046ebbfc4f31bb86cf82620af737d82d69" translate="yes" xml:space="preserve">
          <source>If a constructor's code contains a delegate constructor call, all possible execution paths through the constructor must make exactly one delegate constructor call:</source>
          <target state="translated">생성자의 코드에 델리게이트 생성자 호출이 포함 된 경우 생성자를 통한 모든 가능한 실행 경로는 정확히 하나의 델리게이트 생성자 호출을 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="289f1bcf6286485bf50554692831db27b58239e4" translate="yes" xml:space="preserve">
          <source>If a constructor's code contains a delegating constructor call, all possible execution paths through the constructor must make exactly one delegating constructor call:</source>
          <target state="translated">생성자의 코드에 위임 생성자 호출이 포함 된 경우 생성자를 통해 가능한 모든 실행 경로는 정확히 하나의 위임 생성자를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="74c7db79dd1c4bbec318c1afec835bd55146cddb" translate="yes" xml:space="preserve">
          <source>If a copy constructor is defined, implicit calls to it will be inserted in the following situations:</source>
          <target state="translated">복사 생성자가 정의되면 다음과 같은 상황에서 암시 적 호출이 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="3a4c5302b387be4ef4923c3da45ea70ef8244969" translate="yes" xml:space="preserve">
          <source>If a declaration is followed by a documented unittest, the code in the unittest will be inserted in the &lt;b&gt;example&lt;/b&gt; section of the declaration:</source>
          <target state="translated">선언 뒤에 문서화 된 unittest가 오는 경우 unittest의 코드 가 선언 의 &lt;b&gt;예제&lt;/b&gt; 섹션에 삽입됩니다 .</target>
        </trans-unit>
        <trans-unit id="994d2a230df4885735f193cf875a7c34425353d8" translate="yes" xml:space="preserve">
          <source>If a declaration starts with a</source>
          <target state="translated">선언이</target>
        </trans-unit>
        <trans-unit id="5abfec0c9b70a28afdd54a250553e480e8e7f188" translate="yes" xml:space="preserve">
          <source>If a delegate is passed, the safety and purity of this function are inferred from &lt;code&gt;Dg&lt;/code&gt;'s safety and purity.</source>
          <target state="translated">델리게이트가 통과되면이 기능 의 안전성과 순도 는 &lt;code&gt;Dg&lt;/code&gt; 의 안전성과 순도 에서 유추됩니다 .</target>
        </trans-unit>
        <trans-unit id="ea319443f8c57e701d411ba01a8cc3309299df11" translate="yes" xml:space="preserve">
          <source>If a delegate that accepts a &lt;a href=&quot;std_variant#Variant&quot;&gt;&lt;code&gt;std.variant.Variant&lt;/code&gt;&lt;/a&gt; is included as the last argument to &lt;code&gt;receive&lt;/code&gt;, it will match any message that was not matched by an earlier delegate. If more than one argument is sent, the &lt;code&gt;Variant&lt;/code&gt; will contain a &lt;a href=&quot;std_typecons#Tuple&quot;&gt;&lt;code&gt;std.typecons.Tuple&lt;/code&gt;&lt;/a&gt; of all values sent.</source>
          <target state="translated">&lt;a href=&quot;std_variant#Variant&quot;&gt; &lt;code&gt;std.variant.Variant&lt;/code&gt; &lt;/a&gt; 를 허용하는 대리자 가 &lt;code&gt;receive&lt;/code&gt; 의 마지막 인수로 포함 되면 이전 대리자와 일치하지 않은 모든 메시지와 일치합니다. 둘 이상의 인수가 전송되면 &lt;code&gt;Variant&lt;/code&gt; 에 전송 된 모든 값 의 &lt;a href=&quot;std_typecons#Tuple&quot;&gt; &lt;code&gt;std.typecons.Tuple&lt;/code&gt; &lt;/a&gt; 이 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="7c6073aed324734814b1c5af997eb904b7a1d366" translate="yes" xml:space="preserve">
          <source>If a delegate that accepts a &lt;a href=&quot;std_variant#Variant&quot;&gt;&lt;code&gt;std.variant.Variant&lt;/code&gt;&lt;/a&gt; is included as the last argument, it will match any message that was not matched by an earlier delegate. If more than one argument is sent, the &lt;code&gt;Variant&lt;/code&gt; will contain a &lt;a href=&quot;std_typecons#Tuple&quot;&gt;&lt;code&gt;std.typecons.Tuple&lt;/code&gt;&lt;/a&gt; of all values sent.</source>
          <target state="translated">&lt;a href=&quot;std_variant#Variant&quot;&gt; &lt;code&gt;std.variant.Variant&lt;/code&gt; &lt;/a&gt; 를 허용하는 대리자 가 마지막 인수로 포함 된 경우 이전 대리자와 일치하지 않은 모든 메시지와 일치합니다. 둘 이상의 인수가 전송되면 &lt;code&gt;Variant&lt;/code&gt; 에는 전송 된 모든 값 의 &lt;a href=&quot;std_typecons#Tuple&quot;&gt; &lt;code&gt;std.typecons.Tuple&lt;/code&gt; &lt;/a&gt; 이 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="6772ca1fa3a50c56b1e2254d50cd48e0b56364df" translate="yes" xml:space="preserve">
          <source>If a delegating constructor is not called, a call to the base class's default constructor is issued.</source>
          <target state="translated">위임 생성자가 호출되지 않으면 기본 클래스의 기본 생성자에 대한 호출이 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="881137e036e5d861dacc5e49c7e5ec6d46042221" translate="yes" xml:space="preserve">
          <source>If a derived class overrides a base class member function with diferrent &lt;a href=&quot;#FunctionAttributes&quot;&gt;&lt;i&gt;FunctionAttributes&lt;/i&gt;&lt;/a&gt;, the missing attributes will be automatically compensated by the compiler.</source>
          <target state="translated">파생 클래스가 다른 &lt;a href=&quot;#FunctionAttributes&quot;&gt;&lt;i&gt;FunctionAttributes&lt;/i&gt;&lt;/a&gt; 로 기본 클래스 멤버 함수를 재정의하는 경우 누락 된 속성이 컴파일러에 의해 자동으로 보상됩니다.</target>
        </trans-unit>
        <trans-unit id="9133da665b338dc9f2d280b762259fd2a4cf7d31" translate="yes" xml:space="preserve">
          <source>If a derived class overrides a base class member function with different &lt;a href=&quot;#FunctionAttributes&quot;&gt;&lt;i&gt;FunctionAttributes&lt;/i&gt;&lt;/a&gt;, the missing attributes will be automatically compensated by the compiler.</source>
          <target state="translated">파생 클래스가 다른 &lt;a href=&quot;#FunctionAttributes&quot;&gt;&lt;i&gt;FunctionAttributes&lt;/i&gt;&lt;/a&gt; 로 기본 클래스 멤버 함수를 재정의하는 경우 누락 된 특성은 컴파일러에 의해 자동으로 보상됩니다.</target>
        </trans-unit>
        <trans-unit id="b01bf1413dae9a84ffd106c13e7efc616299cc07" translate="yes" xml:space="preserve">
          <source>If a documentation comment for a declaration consists only of the identifier &lt;code&gt;ditto&lt;/code&gt; then the documentation comment for the previous declaration at the same declaration scope is applied to this declaration as well.</source>
          <target state="translated">선언에 대한 문서 주석이 식별자 &lt;code&gt;ditto&lt;/code&gt; 로만 구성된 경우 동일한 선언 범위에서 이전 선언에 대한 문서 주석이이 선언에도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="3415ea6dfee5691668c1c8232a3e5910eb9c73a0" translate="yes" xml:space="preserve">
          <source>If a field's type has disabled default construction, then it must be initialized in the constructor.</source>
          <target state="translated">필드 유형이 기본 생성을 비활성화 한 경우 생성자에서 초기화해야합니다.</target>
        </trans-unit>
        <trans-unit id="d8f6fa7fc0afa2680299befa1345222924cf9276" translate="yes" xml:space="preserve">
          <source>If a floating literal has a &lt;b&gt;.&lt;/b&gt; and a type suffix, at least one digit must be in-between:</source>
          <target state="translated">부동 문자가있는 경우 &lt;b&gt;. &lt;/b&gt;유형 접미사, 하나 이상의 숫자가 중간에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="3a19adb71ebefd9a28ba0c9b27281e67156dc538" translate="yes" xml:space="preserve">
          <source>If a floating literal is followed by &lt;b&gt;i&lt;/b&gt;, then it is an</source>
          <target state="translated">부동 리터럴 뒤에 &lt;b&gt;i&lt;/b&gt; 가 오는 경우</target>
        </trans-unit>
        <trans-unit id="8d8575d274fd6277028e0c2b41501d26b560a2c4" translate="yes" xml:space="preserve">
          <source>If a function attempts to test itself for those attributes, then the function is inferred as not having those attributes.</source>
          <target state="translated">함수가 해당 속성에 대한 자체 테스트를 시도하면 해당 속성이없는 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="a4a6cb5bd72ee43c0b82dda81af5fd129c286fde" translate="yes" xml:space="preserve">
          <source>If a function call passes no explicit argument, i.e. it would syntactically use &lt;code&gt;()&lt;/code&gt;, then these parentheses may be omitted, similar to a getter invocation of a &lt;a href=&quot;#property-functions&quot;&gt;property function&lt;/a&gt;.</source>
          <target state="translated">함수 호출이 명시 적 인수를 전달하지 않으면 (즉, 구문 적으로 &lt;code&gt;()&lt;/code&gt; 사용 ) , 이러한 괄호는 &lt;a href=&quot;#property-functions&quot;&gt;속성 함수&lt;/a&gt; 의 getter 호출과 유사하게 생략 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3e7b8dc0678edabe73fefcc44809c2cbac6174ce" translate="yes" xml:space="preserve">
          <source>If a function in a derived class overrides a function from its super class, then only one of the &lt;code&gt;in&lt;/code&gt; contracts of the function and its base functions must be satisfied. Overriding functions then becomes a process of</source>
          <target state="translated">파생 클래스에서 함수는 슈퍼 클래스의 함수의 다음 단 하나의 오버라이드 (override)하는 경우 &lt;code&gt;in&lt;/code&gt; 함수의 계약을하고 그것의 기본 기능을 만족해야합니다. 함수를 재정의하면</target>
        </trans-unit>
        <trans-unit id="833166b5c67f31578b3c0dc74c8f4637740cb9ae" translate="yes" xml:space="preserve">
          <source>If a function returns a delegate or function pointer, the parantheses are required if the returned value is to be called.</source>
          <target state="translated">함수가 대리자 또는 함수 포인터를 반환하는 경우 반환 된 값을 호출하려면 패러 틴이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="3fb0c821f0139e65cc3fa8dd141873150a7b34b1" translate="yes" xml:space="preserve">
          <source>If a function returns a delegate or function pointer, the parentheses are required if the returned value is to be called.</source>
          <target state="translated">함수가 대리자 또는 함수 포인터를 반환하는 경우 반환 된 값을 호출하려면 괄호가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="a1d31581f409e137dd612d786dd84ed15f076e6f" translate="yes" xml:space="preserve">
          <source>If a function with an untyped parameter is specified, this function is called when the variant contains a type that does not match any other function. This can be used to apply the same function across multiple possible types. Exactly one generic function is allowed.</source>
          <target state="translated">형식화되지 않은 매개 변수가있는 함수가 지정된 경우 변형에 다른 함수와 일치하지 않는 형식이 포함 된 경우이 함수가 호출됩니다. 여러 가능한 유형에 동일한 기능을 적용하는 데 사용할 수 있습니다. 정확히 하나의 일반 기능이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="a87b66dd6db50119dfebfdc41112382fe6b81c05" translate="yes" xml:space="preserve">
          <source>If a function without parameters is specified, this function is called when &lt;code&gt;variant&lt;/code&gt; doesn't hold a value. Exactly one parameter-less function is allowed.</source>
          <target state="translated">매개 변수가없는 함수가 지정된 경우 &lt;code&gt;variant&lt;/code&gt; 이 값을 보유하지 않으면 이 함수가 호출됩니다 . 정확히 하나의 매개 변수없는 기능이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="834aeb00a2af9d1c11ab80f05c9f251ecfe858eb" translate="yes" xml:space="preserve">
          <source>If a legacy boolean returning custom handler is used, &lt;code&gt;false&lt;/code&gt; maps to &lt;code&gt;UnitTestResult.fail&lt;/code&gt;, and &lt;code&gt;true&lt;/code&gt; maps to &lt;code&gt;UnitTestResult.pass&lt;/code&gt;. This was the original behavior of the unit testing system.</source>
          <target state="translated">레거시 부울 리턴 사용자 정의 핸들러를 사용하는 경우 &lt;code&gt;false&lt;/code&gt; 는 &lt;code&gt;UnitTestResult.fail&lt;/code&gt; 에 맵핑 되고 &lt;code&gt;true&lt;/code&gt; 는 &lt;code&gt;UnitTestResult.pass&lt;/code&gt; 에 맵핑됩니다 . 이것이 단위 테스트 시스템의 원래 동작이었습니다.</target>
        </trans-unit>
        <trans-unit id="82b2fe9ee0ea82740e7dc777c9a1e9340bcda42d" translate="yes" xml:space="preserve">
          <source>If a library routine cannot handle the Typedef type, you can use the &lt;code&gt;TypedefType&lt;/code&gt; template to extract the type which the Typedef wraps.</source>
          <target state="translated">라이브러리 루틴이 &lt;code&gt;TypedefType&lt;/code&gt; 유형을 처리 할 수없는 경우 TypedefType 템플리트를 사용하여 Typedef가 랩핑하는 유형을 추출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6017cad6474bb7ce228682e278fda385b81e533f" translate="yes" xml:space="preserve">
          <source>If a memory object has only one pointer to it, that pointer is the</source>
          <target state="translated">메모리 개체에 포인터가 하나만있는 경우 해당 포인터는</target>
        </trans-unit>
        <trans-unit id="4aba4b8ca7c725b8d06f470a62c86a1bda5b271f" translate="yes" xml:space="preserve">
          <source>If a mixin has an</source>
          <target state="translated">믹스 인에</target>
        </trans-unit>
        <trans-unit id="016a5428498ce2567043077b67b52a004f09c60b" translate="yes" xml:space="preserve">
          <source>If a module C imports modules A and B, any modifications to B will not silently change code in C that is dependent on A.</source>
          <target state="translated">모듈 C가 모듈 A와 B를 가져 오는 경우 B를 수정해도 A에 종속 된 C의 코드는 자동으로 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c291b53fa8bebca9657457c0dc4a5986d2a7e4df" translate="yes" xml:space="preserve">
          <source>If a nested class has the &lt;code&gt;static&lt;/code&gt; attribute, then it can not access variables of the enclosing scope that are local to the stack or need a &lt;code&gt;this&lt;/code&gt; reference:</source>
          <target state="translated">중첩 된 클래스에 &lt;code&gt;static&lt;/code&gt; 속성이있는 경우 스택에 로컬이거나 &lt;code&gt;this&lt;/code&gt; 참조 가 필요한 둘러싸는 범위의 변수에 액세스 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="f84ff68027db236d1e6d7027fe7c21486026d4f8" translate="yes" xml:space="preserve">
          <source>If a nested class has the &lt;code&gt;static&lt;/code&gt; attribute, then it can not access variables of the enclosing scope that are local to the stack or need a &lt;code&gt;this&lt;/code&gt;:</source>
          <target state="translated">중첩 된 클래스가있는 경우 &lt;code&gt;static&lt;/code&gt; 속성을, 다음은 스택에 로컬 또는 바깥 쪽 범위의 액세스 변수는 필요없는 &lt;code&gt;this&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="384ca96bef7bf27444107f5f4fec2bea50635462" translate="yes" xml:space="preserve">
          <source>If a new scope is desired for each expansion, use another set of braces:</source>
          <target state="translated">각 확장에 대해 새 범위가 필요한 경우 다른 중괄호 세트를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="56c79f57d1a50238baec29c9e84fb38c7b1202da" translate="yes" xml:space="preserve">
          <source>If a option is required, not passing it will result in an error</source>
          <target state="translated">옵션이 필요한 경우 전달하지 않으면 오류가 발생합니다</target>
        </trans-unit>
        <trans-unit id="149e6d9194089a56d26c5e902cbd9179de1d63bd" translate="yes" xml:space="preserve">
          <source>If a parameter-less function is specified it is called when either &lt;code&gt;variant&lt;/code&gt; doesn't hold a value or holds a type which isn't handled by the visiting functions.</source>
          <target state="translated">매개 변수가없는 함수가 지정되면 &lt;code&gt;variant&lt;/code&gt; 이 값을 보유하지 않거나 방문 함수가 처리하지 않는 유형을 보유 할 때 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="7beb51fb64caa2734e6c937b4e1f891bde552887" translate="yes" xml:space="preserve">
          <source>If a pointer contains a</source>
          <target state="translated">포인터에</target>
        </trans-unit>
        <trans-unit id="54a6b6d625a26fd15e5bed961a528f1a4d8c8d83" translate="yes" xml:space="preserve">
          <source>If a property function has no parameters, it works as a getter. If has exactly one parameter, it works as a setter.</source>
          <target state="translated">속성 함수에 매개 변수가 없으면 게터로 작동합니다. 정확히 하나의 매개 변수가 있으면 세터로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="bd63b3bb30889f251334a86eb473db6c340d3649" translate="yes" xml:space="preserve">
          <source>If a protocol name is omitted, any protocol will be matched.</source>
          <target state="translated">프로토콜 이름을 생략하면 모든 프로토콜이 일치합니다.</target>
        </trans-unit>
        <trans-unit id="bc8ed891e7a0d7d840793ac113f827ba325b777c" translate="yes" xml:space="preserve">
          <source>If a range returned by &lt;code&gt;map&lt;/code&gt; or &lt;code&gt;asyncBuf&lt;/code&gt; is used as an input to &lt;code&gt;map&lt;/code&gt;, then as an optimization the copying from the output buffer of the first range to the input buffer of the second range is elided, even though the ranges returned by &lt;code&gt;map&lt;/code&gt; and &lt;code&gt;asyncBuf&lt;/code&gt; are non-random access ranges. This means that the &lt;code&gt;bufSize&lt;/code&gt; parameter passed to the current call to &lt;code&gt;map&lt;/code&gt; will be ignored and the size of the buffer will be the buffer size of &lt;code&gt;source&lt;/code&gt;.</source>
          <target state="translated">범위에 의해 반환되는 경우 &lt;code&gt;map&lt;/code&gt; 또는 &lt;code&gt;asyncBuf&lt;/code&gt; 는 입력을하도록 사용되는 &lt;code&gt;map&lt;/code&gt; 범위에 의해 반환되는 경우에도, 그 다음 두 번째 범위의 입력 버퍼에 제 1 범위의 출력 버퍼로 복사 최적화로 생략되어 &lt;code&gt;map&lt;/code&gt; 및 &lt;code&gt;asyncBuf&lt;/code&gt; 비 랜덤 액세스 범위입니다. 이는 현재 &lt;code&gt;map&lt;/code&gt; 호출에 전달 된 &lt;code&gt;bufSize&lt;/code&gt; 매개 변수 가 무시되고 버퍼 크기가 &lt;code&gt;source&lt;/code&gt; 의 버퍼 크기가됨을 의미 합니다 .</target>
        </trans-unit>
        <trans-unit id="b1a76bf15d9ef796c131b625f04b8d1b48403d73" translate="yes" xml:space="preserve">
          <source>If a slice operator appears as the left-hand side of an assignment expression, and the type of the right-hand side is the same as the element type of the left-hand side, then the array contents of the left-hand side are set to the right-hand side.</source>
          <target state="translated">슬라이스 연산자가 대입 식의 왼쪽으로 나타나고 오른쪽의 유형이 왼쪽의 요소 유형과 동일하면 왼쪽의 배열 내용은 다음과 같습니다. 오른쪽으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="290e0c5d88ccb110cac619050e0670bb23f215bd" translate="yes" xml:space="preserve">
          <source>If a strongly pure function throws an exception or an error, the assumptions related to memoization and references do not carry to the thrown exception.</source>
          <target state="translated">강력하게 순수한 함수가 예외 또는 오류를 발생시키는 경우 메모 및 참조와 관련된 가정은 예외를 전달하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b78555ca8d430d27e26cbbff76c2b38ef65ebc11" translate="yes" xml:space="preserve">
          <source>If a struct constructor is annotated with &lt;code&gt;@disable&lt;/code&gt; and has an empty &lt;a href=&quot;function#ParameterList&quot;&gt;&lt;i&gt;ParameterList&lt;/i&gt;&lt;/a&gt;, the struct has disabled default construction. The only way it can be constructed is via a call to another constructor with a non-empty</source>
          <target state="translated">구조체 생성자에 &lt;code&gt;@disable&lt;/code&gt; 주석이 달려 있고 &lt;a href=&quot;function#ParameterList&quot;&gt;&lt;i&gt;ParameterList&lt;/i&gt;&lt;/a&gt; 가 비어 있으면 구조체는 기본 생성을 비활성화 한 것입니다. 생성 할 수있는 유일한 방법은 비어 있지 않은 다른 생성자를 호출하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="b3a5f4c5b0a3ecfb344535d097fbd6472ec3aaaf" translate="yes" xml:space="preserve">
          <source>If a subexpression of an expression throws an exception, all temporaries created up to the evaluation of that subexpression will be destroyed per the rules above. No destructor calls will be issued for temporaries not yet constructed.</source>
          <target state="translated">표현식의 하위 표현식에서 예외가 발생하면 해당 하위 표현식의 평가까지 작성된 모든 임시는 위의 규칙에 따라 삭제됩니다. 아직 구성되지 않은 임시 항목에 대해서는 소멸자 호출이 발행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c750c9691a6ca511a5908ab0fae040fe6ae197ae" translate="yes" xml:space="preserve">
          <source>If a template argument matches a specialized template parameter, the argument is mangled with prefix &lt;b&gt;H&lt;/b&gt;.</source>
          <target state="translated">템플리트 인수가 특수한 템플리트 매개 변수와 일치하면 인수는 접 두부 &lt;b&gt;H&lt;/b&gt; 로 맹 글링됩니다 .</target>
        </trans-unit>
        <trans-unit id="537fb8313b9340d6a7720624890b667ceaf5eabd" translate="yes" xml:space="preserve">
          <source>If a template contains members whose name is the same as the template identifier and if the type or the parameters type of these members include at least all the template parameters then these members are assumed to be referred to in a template instantiation:</source>
          <target state="translated">템플리트에 이름이 템플리트 ID와 동일한 멤버를 포함하고 이러한 멤버의 유형 또는 매개 변수 유형에 최소한 모든 템플리트 매개 변수가 포함 된 경우 이러한 멤버는 템플리트 인스턴스화에서 참조되는 것으로 가정됩니다.</target>
        </trans-unit>
        <trans-unit id="89c78b76971977e3949d885ca70ed72b7e954c2c" translate="yes" xml:space="preserve">
          <source>If a template contains members whose name is the same as the template identifier then these members are assumed to be referred to in a template instantiation:</source>
          <target state="translated">템플릿에 템플릿 식별자와 이름이 같은 멤버가 포함 된 경우 이러한 멤버는 템플릿 인스턴스화에서 참조되는 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="cae6a5dbef8ce07c71db2a20a8cd25a725a5d57c" translate="yes" xml:space="preserve">
          <source>If a template declares exactly one member, and that member is a class with the same name as the template (see &lt;a href=&quot;#implicit_template_properties&quot;&gt;Eponymous Templates&lt;/a&gt;:)</source>
          <target state="translated">템플릿이 정확히 하나의 멤버를 선언하고 해당 멤버가 템플릿과 이름이 같은 클래스 인 경우 ( &lt;a href=&quot;#implicit_template_properties&quot;&gt;Eponymous Templates&lt;/a&gt; 참조 :)</target>
        </trans-unit>
        <trans-unit id="6e940bc97403a68b4bd6fcc2185065a84be4a8ef" translate="yes" xml:space="preserve">
          <source>If a template declares exactly one member, and that member is a class with the same name as the template:</source>
          <target state="translated">템플릿이 정확히 하나의 멤버를 선언하고 해당 멤버가 템플릿과 이름이 같은 클래스 인 경우 :</target>
        </trans-unit>
        <trans-unit id="7228f16c50b7195b2939cb5fdb81b9ec5f38dc52" translate="yes" xml:space="preserve">
          <source>If a template declares exactly one member, and that member is a function with the same name as the template, it is a function template declaration. Alternatively, a function template declaration is a function declaration with a &lt;a href=&quot;#TemplateParameterList&quot;&gt;&lt;i&gt;TemplateParameterList&lt;/i&gt;&lt;/a&gt; immediately preceding the &lt;a href=&quot;function#Parameters&quot;&gt;&lt;i&gt;Parameters&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">템플리트가 정확히 하나의 멤버를 선언하고 해당 멤버가 템플리트와 동일한 이름의 함수 인 경우 함수 템플리트 선언입니다. 또는 함수 템플릿 선언은 &lt;a href=&quot;function#Parameters&quot;&gt;&lt;i&gt;Parameters&lt;/i&gt;&lt;/a&gt; 바로 앞에 &lt;a href=&quot;#TemplateParameterList&quot;&gt;&lt;i&gt;TemplateParameterList&lt;/i&gt;&lt;/a&gt; 가있는 함수 선언입니다 .&lt;i&gt;&lt;/i&gt;</target>
        </trans-unit>
        <trans-unit id="7f02f572072804182d7734d7a928006f6d805f14" translate="yes" xml:space="preserve">
          <source>If a template has a &lt;a href=&quot;#aliasparameters&quot;&gt;template alias parameter&lt;/a&gt;, and is instantiated with a local symbol, the instantiated function will implicitly become nested in order to access runtime data of the given local symbol.</source>
          <target state="translated">템플릿에 &lt;a href=&quot;#aliasparameters&quot;&gt;템플릿 별칭 매개 변수&lt;/a&gt; 가 있고 로컬 심볼로 인스턴스화 된 경우 인스턴스화 된 함수는 내재적으로 중첩되어 지정된 로컬 심볼의 런타임 데이터에 액세스합니다.</target>
        </trans-unit>
        <trans-unit id="996438a9f4c88ad530df79801ff8b03c0e475abe" translate="yes" xml:space="preserve">
          <source>If a template is declared in aggregate or function local scope, the instantiated functions will implicitly capture the context of the enclosing scope.</source>
          <target state="translated">템플릿이 집계 또는 함수 로컬 범위로 선언 된 경우 인스턴스화 된 함수는 내포 범위의 컨텍스트를 암시 적으로 캡처합니다.</target>
        </trans-unit>
        <trans-unit id="449794f5173b1c91e0c8a9e969999efee1d1266f" translate="yes" xml:space="preserve">
          <source>If a variable has a scope destructor call, return call for it. Otherwise, return NULL.</source>
          <target state="translated">변수에 범위 소멸자 호출이 있으면이를 호출하십시오. 그렇지 않으면 NULL을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e7d0ce5000213342db830246324bf60d4a0dcc21" translate="yes" xml:space="preserve">
          <source>If after all the type arguments are examined, there are any type parameters left with no type assigned, they are assigned types corresponding to the template argument in the same position in the</source>
          <target state="translated">모든 유형 인수를 검사 한 후 유형이 지정되지 않은 유형 매개 변수가 남아있는 경우 템플릿 매개 변수에 해당하는 유형 매개 변수가</target>
        </trans-unit>
        <trans-unit id="8425958e6e0e9a1c94e548c8eed6685e1c97af18" translate="yes" xml:space="preserve">
          <source>If aliased to the same object or both null =&amp;gt; equal</source>
          <target state="translated">같은 객체 또는 둘 다 null =&amp;gt; 같으면 별칭</target>
        </trans-unit>
        <trans-unit id="201815c4325a8fddf0539c89b74ba96e4169f933" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;auto&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;auto&lt;/code&gt; 이라면</target>
        </trans-unit>
        <trans-unit id="5aa6bbb7d06b0bd7ec69b77758d95900b4054089" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;enum&lt;/code&gt; is used as type, the random variate is drawn with equal probability from any of the possible values of the enum &lt;code&gt;E&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;enum&lt;/code&gt; 이 유형으로 사용되는 경우 임의 변형은 열거 형 &lt;code&gt;E&lt;/code&gt; 의 가능한 값 중 하나와 동일한 확률로 그려집니다 .</target>
        </trans-unit>
        <trans-unit id="168c9f0755c4bd4e21cdb3d96a893ad7470eff57" translate="yes" xml:space="preserve">
          <source>If an aggregate declaration defines an &lt;code&gt;opCmp&lt;/code&gt; or &lt;code&gt;opEquals&lt;/code&gt; method, it will take precedence to that of the aliased this member. Note that, unlike an &lt;code&gt;opCmp&lt;/code&gt; method, an &lt;code&gt;opEquals&lt;/code&gt; method is implicitly defined for a &lt;code&gt;struct&lt;/code&gt; declaration if a user defined one isn't provided; this means that if the aliased this member &lt;code&gt;opEquals&lt;/code&gt; is preferred it should be explicitly defined:</source>
          <target state="translated">집계 선언이 &lt;code&gt;opCmp&lt;/code&gt; 또는 &lt;code&gt;opEquals&lt;/code&gt; 메소드를 정의하는 경우 별명을 가진이 멤버의 메소드보다 우선합니다. &lt;code&gt;opCmp&lt;/code&gt; 메소드 와 달리 , &lt;code&gt;opEquals&lt;/code&gt; 메소드는 사용자 정의 선언이 제공되지 않은 경우 &lt;code&gt;struct&lt;/code&gt; 선언에 대해 암시 적으로 정의 됩니다. 이는 별명으로이 멤버 &lt;code&gt;opEquals&lt;/code&gt; 가 선호되는 경우 명시 적으로 정의되어야 함을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="2cf56dfdcc6eee095fd25bd060be3e831d6148d4" translate="yes" xml:space="preserve">
          <source>If an append must reallocate a slice with no possibility of extension, then &lt;code&gt;0&lt;/code&gt; is returned. This happens when the slice references a static array, or if another slice references elements past the end of the current slice.</source>
          <target state="translated">추가가 확장 가능성없이 슬라이스를 재 할당해야하는 경우 &lt;code&gt;0&lt;/code&gt; 이 반환됩니다. 슬라이스가 정적 배열을 참조하거나 다른 슬라이스가 현재 슬라이스의 끝을지나 요소를 참조하는 경우에 발생합니다.</target>
        </trans-unit>
        <trans-unit id="fbeff861e7616c530bb5c083257a7ef08f727eef" translate="yes" xml:space="preserve">
          <source>If an application needs to do its own processing of whichever arguments &lt;code&gt;getopt&lt;/code&gt; did not understand, it can pass the &lt;code&gt;std.getopt.config.passThrough&lt;/code&gt; directive to &lt;code&gt;getopt&lt;/code&gt;:</source>
          <target state="translated">애플리케이션이 &lt;code&gt;getopt&lt;/code&gt; 가 이해하지 못한 인수에 대해 자체 처리를 수행 &lt;code&gt;std.getopt.config.passThrough&lt;/code&gt; 경우 std.getopt.config.passThrough 지시문을 &lt;code&gt;getopt&lt;/code&gt; 에 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="eaf53aac4b71af8424769f45a7b82ff0df7d317c" translate="yes" xml:space="preserve">
          <source>If an enum has as a base type one of the types in the left column, it is converted to the type in the right column.</source>
          <target state="translated">열거 형이 기본 유형으로 왼쪽 열의 유형 중 하나 인 경우 오른쪽 열의 유형으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="3c064315a80e4366fd87dbfa8b9a5125e74f88b6" translate="yes" xml:space="preserve">
          <source>If an error occurs during the compilation of your program, the use of overloads and overrides needs to be reexamined in the relevant classes.</source>
          <target state="translated">프로그램을 컴파일하는 동안 오류가 발생하면 관련 클래스에서 오버로드 및 재정의 사용을 다시 검토해야합니다.</target>
        </trans-unit>
        <trans-unit id="a2623dd123c39f9f457825f03bd99064fa3431f1" translate="yes" xml:space="preserve">
          <source>If an exception is raised in the</source>
          <target state="translated">에서 예외가 발생하면</target>
        </trans-unit>
        <trans-unit id="180043ac16b1a016937b09456574733627d6647e" translate="yes" xml:space="preserve">
          <source>If an exception is thrown but it has an empty message, then &lt;code&gt;emptyExceptionMsg&lt;/code&gt; is returned.</source>
          <target state="translated">예외가 발생했지만 빈 메시지가 있으면 &lt;code&gt;emptyExceptionMsg&lt;/code&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="eb4162f43906e6c9a7e64e7ecdf711ae4fd96612" translate="yes" xml:space="preserve">
          <source>If an identical type to &lt;code&gt;type&lt;/code&gt; is in &lt;code&gt;type.stringtable&lt;/code&gt;, return the latter one. Otherwise, add it to &lt;code&gt;type.stringtable&lt;/code&gt;. Some types don't get merged and are returned as-is.</source>
          <target state="translated">에 동일한 입력하면 &lt;code&gt;type&lt;/code&gt; 에 &lt;code&gt;type.stringtable&lt;/code&gt; , 후자를 반환한다. 그렇지 않으면 &lt;code&gt;type.stringtable&lt;/code&gt; 에 추가하십시오 . 일부 유형은 병합되지 않고 그대로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="2efd485ddee09f5b6939ce6531c2909633020004" translate="yes" xml:space="preserve">
          <source>If an identity assignment overload is required and does not exist, an identity assignment overload function of the type &lt;code&gt;ref S opAssign(ref S)&lt;/code&gt; will be automatically generated.</source>
          <target state="translated">ID 할당 과부하가 필요하지만 존재하지 않는 경우 &lt;code&gt;ref S opAssign(ref S)&lt;/code&gt; 유형의 ID 할당 과부하 기능 이 자동으로 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="5e5e3f00360d5b8852208ee3415dc3a1a01f6dc8" translate="yes" xml:space="preserve">
          <source>If an implicit conversion is disallowed by the table, an &lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;Expression&lt;/i&gt;&lt;/a&gt; may be converted if:</source>
          <target state="translated">테이블에서 내재적 변환을 허용하지 않는 경우 다음과 같은 경우 &lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;표현식&lt;/i&gt;&lt;/a&gt; 이 변환 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9520036db9c2c3cb7627c2cb880cb288fe8ee7ee" translate="yes" xml:space="preserve">
          <source>If an index expression can be rewritten using &lt;code&gt;opIndexAssign&lt;/code&gt; or &lt;code&gt;opIndexOpAssign&lt;/code&gt;, those are preferred over &lt;code&gt;opIndex&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;opIndexAssign&lt;/code&gt; 또는 &lt;code&gt;opIndexOpAssign&lt;/code&gt; 을 사용하여 인덱스 표현식을 다시 작성할 수 있으면 opIndex 보다 선호 &lt;code&gt;opIndex&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="74d0247eb6c576e08ded3f7c08dff25cd606da70" translate="yes" xml:space="preserve">
          <source>If an interface has &lt;code&gt;const&lt;/code&gt; or &lt;code&gt;immutable&lt;/code&gt; storage class, then all members of the interface are &lt;code&gt;const&lt;/code&gt; or &lt;code&gt;immutable&lt;/code&gt;. This storage class is not inherited.</source>
          <target state="translated">인터페이스에 &lt;code&gt;const&lt;/code&gt; 또는 &lt;code&gt;immutable&lt;/code&gt; 스토리지 클래스가있는 경우 인터페이스의 모든 멤버는 &lt;code&gt;const&lt;/code&gt; 또는 &lt;code&gt;immutable&lt;/code&gt; 입니다. 이 스토리지 클래스는 상속되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7e7381c9bb35e9f77c152ce0763035229030f128" translate="yes" xml:space="preserve">
          <source>If an option is bound to a numeric type, a number is expected as the next option, or right within the option separated with an &quot;=&quot; sign:</source>
          <target state="translated">옵션이 숫자 유형에 바인딩 된 경우 숫자는 다음 옵션으로 표시되거나 옵션 내에서 &quot;=&quot;기호로 구분됩니다.</target>
        </trans-unit>
        <trans-unit id="e1388310610be9143f93d5757e5dd370de55e952" translate="yes" xml:space="preserve">
          <source>If an option is bound to a string, a string is expected as the next option, or right within the option separated with an &quot;=&quot; sign:</source>
          <target state="translated">옵션이 문자열에 바인딩 된 경우 다음 옵션으로 문자열이 표시되거나 옵션 내에서 &quot;=&quot;기호로 구분됩니다.</target>
        </trans-unit>
        <trans-unit id="cd9d52ae8827e5578c6e463b4801745d426f4b79" translate="yes" xml:space="preserve">
          <source>If an option is bound to an array, a new element is appended to the array each time the option occurs:</source>
          <target state="translated">옵션이 배열에 바인딩 된 경우 옵션이 발생할 때마다 새 요소가 배열에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="d7c493c513172131987de31a463653700c8dc123" translate="yes" xml:space="preserve">
          <source>If an option is bound to an associative array, a string of the form &quot;name=value&quot; is expected as the next option, or right within the option separated with an &quot;=&quot; sign:</source>
          <target state="translated">옵션이 연관 배열에 바인드 된 경우, &quot;name = value&quot;형식의 문자열은 다음 옵션으로 예상되거나 옵션 내에서 &quot;=&quot;기호로 구분됩니다.</target>
        </trans-unit>
        <trans-unit id="b6f632caf5c4044e09e5739104d63549a3fc0c34" translate="yes" xml:space="preserve">
          <source>If an option is bound to an enum, an enum symbol as a string is expected as the next option, or right within the option separated with an &quot;=&quot; sign:</source>
          <target state="translated">옵션이 열거 형에 바인딩 된 경우 다음 옵션으로 문자열로 열거 형 기호가 표시되거나 옵션 내에서 &quot;=&quot;기호로 구분됩니다.</target>
        </trans-unit>
        <trans-unit id="7c32990bfc4d36bb0abf0d415d84bd3e023f0845" translate="yes" xml:space="preserve">
          <source>If an option name has a &quot;+&quot; suffix and is bound to a numeric type, then the option's value tracks the number of times the option occurred on the command line:</source>
          <target state="translated">옵션 이름에 &quot;+&quot;접미사가 있고 숫자 유형에 바인딩 된 경우 옵션 값은 명령 행에서 옵션이 발생한 횟수를 추적합니다.</target>
        </trans-unit>
        <trans-unit id="3bc9e305061e747e54d09f33e1d219d952240a58" translate="yes" xml:space="preserve">
          <source>If an option string is followed by another string, this string serves as a description for this option. The &lt;code&gt;getopt&lt;/code&gt; function returns a struct of type &lt;code&gt;GetoptResult&lt;/code&gt;. This return value contains information about all passed options as well a &lt;code&gt;bool GetoptResult.helpWanted&lt;/code&gt; flag indicating whether information about these options was requested. The &lt;code&gt;getopt&lt;/code&gt; function always adds an option for &lt;code&gt;--help|-h&lt;/code&gt; to set the flag if the option is seen on the command line.</source>
          <target state="translated">옵션 문자열 뒤에 다른 문자열이 오는 경우이 문자열은이 옵션에 대한 설명으로 사용됩니다. &lt;code&gt;getopt&lt;/code&gt; 는의 기능은 타입의 구조체를 반환 &lt;code&gt;GetoptResult&lt;/code&gt; 을 . 이 반환 값에는 전달 된 모든 옵션 에 대한 정보와 이러한 옵션에 대한 정보가 요청되었는지 여부를 나타내는 &lt;code&gt;bool GetoptResult.helpWanted&lt;/code&gt; 플래그가 포함됩니다. &lt;code&gt;getopt&lt;/code&gt; 에의 함수는 항상을위한 옵션이 추가 &lt;code&gt;--help|-h&lt;/code&gt; 옵션이 명령 행에서 볼 경우 플래그를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="cecb4b7cfecf63467f6f4623b6ecf01515e03ef4" translate="yes" xml:space="preserve">
          <source>If any &lt;code&gt;TaskPool&lt;/code&gt; with non-daemon threads is active, either &lt;code&gt;stop&lt;/code&gt; or &lt;code&gt;finish&lt;/code&gt; must be called on it before the program can terminate.</source>
          <target state="translated">비 데몬 스레드가 있는 &lt;code&gt;TaskPool&lt;/code&gt; 이 활성화 된 경우 프로그램을 종료하기 전에 &lt;code&gt;stop&lt;/code&gt; 또는 &lt;code&gt;finish&lt;/code&gt; 를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="2442edf64b05fed93875352de9ddef61974e4dcd" translate="yes" xml:space="preserve">
          <source>If any fields have disabled default construction, struct default construction is also disabled.</source>
          <target state="translated">필드가 기본 생성을 비활성화 한 경우 구조체 기본 생성도 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="a14ab7622e0f011a987d4940247d86d91424d5c2" translate="yes" xml:space="preserve">
          <source>If any fields have disabled default construction, the struct default construction is also disabled.</source>
          <target state="translated">필드에서 기본 생성을 비활성화 한 경우 struct 기본 생성도 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="11956d46948d1d13d7ee53327bbd180ff0d5d12d" translate="yes" xml:space="preserve">
          <source>If any of &lt;code&gt;lead&lt;/code&gt; and &lt;code&gt;vowel&lt;/code&gt; are not a valid hangul jamo of the respective &lt;a href=&quot;#Character&quot;&gt;character&lt;/a&gt; class returns dchar.init.</source>
          <target state="translated">&lt;code&gt;lead&lt;/code&gt; 와 &lt;code&gt;vowel&lt;/code&gt; 중 하나라도 해당 &lt;a href=&quot;#Character&quot;&gt;문자&lt;/a&gt; 클래스 의 유효한 한글 jamo가 아닌 경우 dchar.init를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="643424aa2159c0dc971a85e93b28f54bc425b055" translate="yes" xml:space="preserve">
          <source>If any of the arguments in the &lt;a href=&quot;#ArgumentList&quot;&gt;&lt;i&gt;ArgumentList&lt;/i&gt;&lt;/a&gt; are a</source>
          <target state="translated">&lt;a href=&quot;#ArgumentList&quot;&gt;&lt;i&gt;ArgumentList&lt;/i&gt;&lt;/a&gt; 의 &lt;i&gt;인수&lt;/i&gt; 중 하나가</target>
        </trans-unit>
        <trans-unit id="3744bc315bbcad378bdb3ff87a3b9de7d402fea7" translate="yes" xml:space="preserve">
          <source>If any of the checks fail, a compile error will occur.</source>
          <target state="translated">검사가 실패하면 컴파일 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="def10a047da7cb724c42b1f59da46ab76ef31dc6" translate="yes" xml:space="preserve">
          <source>If any of the keys or values in the</source>
          <target state="translated">키 또는 값이</target>
        </trans-unit>
        <trans-unit id="41bc7edc68b18e54f236d3ac39e824893010bd91" translate="yes" xml:space="preserve">
          <source>If applying the above rules does not result in exactly one type for each template parameter, then it is an error.</source>
          <target state="translated">위의 규칙을 적용해도 각 템플릿 매개 변수에 대해 정확히 하나의 유형이되지 않으면 오류입니다.</target>
        </trans-unit>
        <trans-unit id="a7c844c173ee0a673d9ab2e503851d6c710a834c" translate="yes" xml:space="preserve">
          <source>If assertions are enabled and &lt;code&gt;toRange&lt;/code&gt; has been called, then this WorkerLocalStorage instance is no longer worker-local and an assertion failure will result when calling this method. This is not checked when assertions are disabled for performance reasons.</source>
          <target state="translated">어설 션이 활성화되고 &lt;code&gt;toRange&lt;/code&gt; 가 호출 된 경우이 WorkerLocalStorage 인스턴스는 더 이상 작업자 로컬이 아니므로이 메서드를 호출 할 때 어설 션 오류가 발생합니다. 성능상의 이유로 어설 션이 비활성화 된 경우에는 확인되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2a4c7b046cde0bb5e12a60d5ebe77f7e562208f5" translate="yes" xml:space="preserve">
          <source>If at least one of the arguments is NaN, the result is an unspecified value.</source>
          <target state="translated">인수 중 하나 이상이 NaN이면 결과는 지정되지 않은 값입니다.</target>
        </trans-unit>
        <trans-unit id="825f4197814b0d68b55040d1d95ed5fec00d9458" translate="yes" xml:space="preserve">
          <source>If at least one of the arguments is NaN, the result is an unspecified value. See &lt;a href=&quot;std_algorithm_searching#maxElement&quot;&gt;&lt;code&gt;std.algorithm.searching.maxElement&lt;/code&gt;&lt;/a&gt; for examples on how to cope with NaNs.</source>
          <target state="translated">인수 중 하나 이상이 NaN이면 결과는 지정되지 않은 값입니다. NaN에 대처하는 방법에 대한 예제는 &lt;a href=&quot;std_algorithm_searching#maxElement&quot;&gt; &lt;code&gt;std.algorithm.searching.maxElement&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="51eb056f1717f5d30ca42a509337be76f7a52798" translate="yes" xml:space="preserve">
          <source>If at least one of the arguments is NaN, the result is an unspecified value. See &lt;a href=&quot;std_algorithm_searching#minElement&quot;&gt;&lt;code&gt;std.algorithm.searching.minElement&lt;/code&gt;&lt;/a&gt; for examples on how to cope with NaNs.</source>
          <target state="translated">인수 중 하나 이상이 NaN이면 결과는 지정되지 않은 값입니다. NaN에 대처하는 방법에 대한 예제는 &lt;a href=&quot;std_algorithm_searching#minElement&quot;&gt; &lt;code&gt;std.algorithm.searching.minElement&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="df118ef438600490adb83de4d6beaa35bff251d8" translate="yes" xml:space="preserve">
          <source>If at least one of the ranges is a multiset, then all occurences of a duplicate element are taken into account. The result is equivalent to merging all input ranges and picking the highest &lt;code&gt;tgt.length&lt;/code&gt;, weight-based ranking elements.</source>
          <target state="translated">범위 중 하나 이상이 다중 집합 인 경우 중복 요소의 모든 발생이 고려됩니다. 결과는 모든 입력 범위를 병합하고 가장 높은 &lt;code&gt;tgt.length&lt;/code&gt; 가중치 기반 순위 요소를 선택하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="4519d0d5950e5356f4f13b61a821ffce61eda0b3" translate="yes" xml:space="preserve">
          <source>If authentication or redirections are done then the status will be for the last response received.</source>
          <target state="translated">인증 또는 리디렉션이 수행되면 마지막으로받은 응답의 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="cd6490598a4d93059510177bb453af0037be62bb" translate="yes" xml:space="preserve">
          <source>If autodecoding is turned off, then this is equivalent to duplicating the array.</source>
          <target state="translated">자동 디코딩이 꺼져있는 경우 이는 어레이를 복제하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="742bd1e8cf3c2f25ee274ec3880df5cf7f721969" translate="yes" xml:space="preserve">
          <source>If autodecoding is turned on (default), then they are handled as a separate overload.</source>
          <target state="translated">자동 디코딩이 켜져 있으면 (기본값) 별도의 오버로드로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="0a0246e59acc96ca671df31d602e303fc5a3e9ab" translate="yes" xml:space="preserve">
          <source>If blocking argument is true, wait for all worker threads to terminate before returning. This option might be used in applications where task results are never consumed-- e.g. when &lt;code&gt;TaskPool&lt;/code&gt; is employed as a rudimentary scheduler for tasks which communicate by means other than return values.</source>
          <target state="translated">blocking 인수가 true이면 모든 작업자 스레드가 종료 될 때까지 기다렸다가 반환합니다. 이 옵션은 작업 결과가 절대 사용되지 않는 응용 프로그램에서 사용될 수 있습니다 (예 : &lt;code&gt;TaskPool&lt;/code&gt; 이 반환 값 이외의 수단으로 통신하는 작업의 기초 스케줄러로 사용되는 경우).</target>
        </trans-unit>
        <trans-unit id="7479ca1ded9e48be6a8e038bc9b2488efa665f70" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;Primary&lt;/code&gt; and &lt;code&gt;Fallback&lt;/code&gt; are stateless, &lt;code&gt;FallbackAllocator&lt;/code&gt; defines a static instance called &lt;code&gt;instance&lt;/code&gt;.</source>
          <target state="translated">두 경우 &lt;code&gt;Primary&lt;/code&gt; 및 &lt;code&gt;Fallback&lt;/code&gt; 비 상태이며, &lt;code&gt;FallbackAllocator&lt;/code&gt; 는 라는 정적 인스턴스 정의 &lt;code&gt;instance&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9ec43df7b50b565bd7b1219f8c1f3ab8b182ffb2" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are integers (may be constant-folded), the slice expression can be converted to a static array type &lt;code&gt;T[b - a]&lt;/code&gt;.</source>
          <target state="translated">두 경우 및 &lt;code&gt;b&lt;/code&gt; 는 정수이다 (일정한 절첩 될 수있다), 슬라이스 발현 정적 배열 형식으로 변환 할 수 &lt;code&gt;T[b - a]&lt;/code&gt; . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0deff799fed4758452aa1b15f9e2a5541bd46d3e" translate="yes" xml:space="preserve">
          <source>If both a template with a sequence parameter and a template without a sequence parameter exactly match a template instantiation, the template without a</source>
          <target state="translated">시퀀스 매개 변수가있는 템플릿과 시퀀스 매개 변수가없는 템플릿이 모두 템플릿 인스턴스화와 정확히 일치하면</target>
        </trans-unit>
        <trans-unit id="220f653add85effdd5e512619500f4b49743b534" translate="yes" xml:space="preserve">
          <source>If both allocators are &lt;code&gt;shared&lt;/code&gt;, the &lt;code&gt;Segregator&lt;/code&gt; will also offer &lt;code&gt;shared&lt;/code&gt; methods.</source>
          <target state="translated">두 할당자가 모두 &lt;code&gt;shared&lt;/code&gt; 되면 &lt;code&gt;Segregator&lt;/code&gt; 는 &lt;code&gt;shared&lt;/code&gt; 방법 도 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="69639385682c3a994448b82bd2bb7cf46189be9b" translate="yes" xml:space="preserve">
          <source>If both are signed or both are unsigned, the smaller type is converted to the larger.</source>
          <target state="translated">둘 다 부호가 있거나 둘 다 부호가없는 경우 더 작은 유형이 더 큰 유형으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="05fb2e935ce549269270c5d42145fc9b4f07b7f4" translate="yes" xml:space="preserve">
          <source>If both are the same type, no more conversions are done.</source>
          <target state="translated">둘 다 동일한 유형이면 더 이상 변환이 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="05dd5c60a4e9b82d4adbecb6f4127f3d732ab860" translate="yes" xml:space="preserve">
          <source>If both arguments are ranges of L-values of the same type then &lt;code&gt;SetSymmetricDifference&lt;/code&gt; will also be a range of L-values of that type.</source>
          <target state="translated">두 인수가 모두 같은 유형의 L 값 범위 인 경우 &lt;code&gt;SetSymmetricDifference&lt;/code&gt; 도 해당 유형의 L 값 범위가됩니다.</target>
        </trans-unit>
        <trans-unit id="f20cc499ea7bfd3b9b5a7bc116d95b44ec6d1e4b" translate="yes" xml:space="preserve">
          <source>If both operands are of integral types and an overflow or underflow occurs in the computation, wrapping will happen. For example, &lt;code&gt;uint.max + 1 == uint.min&lt;/code&gt;, &lt;code&gt;uint.min - 1 == uint.max&lt;/code&gt;, &lt;code&gt;int.max + 1 == int.min&lt;/code&gt;, and &lt;code&gt;int.min - 1 == int.max&lt;/code&gt;.</source>
          <target state="translated">두 피연산자가 정수 유형이고 계산에서 오버플로 또는 언더 플로가 발생하면 래핑이 발생합니다. 예를 들어 &lt;code&gt;uint.max + 1 == uint.min&lt;/code&gt; , &lt;code&gt;uint.min - 1 == uint.max&lt;/code&gt; , &lt;code&gt;int.max + 1 == int.min&lt;/code&gt; , &lt;code&gt;int.min - 1 == int.max&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a1166af836d0ff22ec8996cf90c0ca104ddf9187" translate="yes" xml:space="preserve">
          <source>If both operands are of integral types and an overflow or underflow occurs in the computation, wrapping will happen. That is, &lt;code&gt;uint.max + 1 == uint.min&lt;/code&gt; and &lt;code&gt;uint.min - 1 == uint.max&lt;/code&gt;.</source>
          <target state="translated">두 피연산자가 모두 정수 유형이고 계산에서 오버플로 또는 언더 플로가 발생하면 줄 바꿈이 발생합니다. 즉, &lt;code&gt;uint.max + 1 == uint.min&lt;/code&gt; 및 &lt;code&gt;uint.min - 1 == uint.max&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="88c921254e07ee3d3550bb0c4328e00c73dbba70" translate="yes" xml:space="preserve">
          <source>If both operands are pointers, and the operator is &lt;code&gt;+&lt;/code&gt;, then it is illegal.</source>
          <target state="translated">두 피연산자가 모두 포인터이고 연산자가 &lt;code&gt;+&lt;/code&gt; 인 경우 잘못된 것입니다.</target>
        </trans-unit>
        <trans-unit id="d175863c948db7d84910700658bc03bfa12bed2a" translate="yes" xml:space="preserve">
          <source>If both operands are pointers, and the operator is &lt;code&gt;-&lt;/code&gt;, the pointers are subtracted and the result is divided by the size of the type pointed to by the operands. In this calculation the assumed size of &lt;code&gt;void&lt;/code&gt; is one byte. It is an error if the pointers point to different types. The type of the result is &lt;code&gt;ptrdiff_t&lt;/code&gt;.</source>
          <target state="translated">두 피연산자가 모두 포인터이고 연산자가 &lt;code&gt;-&lt;/code&gt; 인 경우 포인터는 빼고 결과는 피연산자가 가리키는 유형의 크기로 나뉩니다. 이 계산에서 &lt;code&gt;void&lt;/code&gt; 의 가정 된 크기 는 1 바이트입니다. 포인터가 다른 유형을 가리키는 경우 오류입니다. 결과 유형은 &lt;code&gt;ptrdiff_t&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d1abf720abea123f60d5888992d6209534bf4e09" translate="yes" xml:space="preserve">
          <source>If both ranges are finite, then one must be (at least) a &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward range&lt;/a&gt; and the other an &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt;.</source>
          <target state="translated">두 범위가 모두 유한 한 경우 하나는 &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;전방 범위&lt;/a&gt; 이고 다른 하나는 &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;입력 범위&lt;/a&gt; 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="cb5178f6f33c9b3fe021f6007cd182ded54b74f7" translate="yes" xml:space="preserve">
          <source>If both ranges are infinite, then both must be forward ranges.</source>
          <target state="translated">두 범위가 모두 무한대이면 모두 전방 범위 여야합니다.</target>
        </trans-unit>
        <trans-unit id="09621590d3975cfd09fe2c0811ba26754a5cdd9d" translate="yes" xml:space="preserve">
          <source>If both ranges are sets (without duplicated elements), the resulting range is going to be a set. If at least one of the ranges is a multiset, the number of occurences of an element &lt;code&gt;x&lt;/code&gt; in the resulting range is &lt;code&gt;abs(a-b)&lt;/code&gt; where &lt;code&gt;a&lt;/code&gt; is the number of occurences of &lt;code&gt;x&lt;/code&gt; in &lt;code&gt;r1&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; is the number of occurences of &lt;code&gt;x&lt;/code&gt; in &lt;code&gt;r2&lt;/code&gt;, and &lt;code&gt;abs&lt;/code&gt; is the absolute value.</source>
          <target state="translated">두 범위가 모두 설정되면 (중복 요소 없음) 결과 범위가 설정됩니다. 범위 중 적어도 하나는 멀티 세트 인 경우, 소자의 발행 수의 수 &lt;code&gt;x&lt;/code&gt; 얻어진 범위 인 &lt;code&gt;abs(a-b)&lt;/code&gt; &lt;code&gt;a&lt;/code&gt; 의 발행 수의 개수 &lt;code&gt;x&lt;/code&gt; 의 &lt;code&gt;r1&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; 의 발행 수의 수이고 &lt;code&gt;x&lt;/code&gt; 의 &lt;code&gt;r2&lt;/code&gt; 및 &lt;code&gt;abs&lt;/code&gt; 절대 값이다.</target>
        </trans-unit>
        <trans-unit id="c3cd520fd113fc0ea9747b7e4b22c4c42d0b39c5" translate="yes" xml:space="preserve">
          <source>If both ranges have a length member, this function is &amp;Omicron;(&lt;code&gt;1&lt;/code&gt;). Otherwise, this function is &amp;Omicron;(&lt;code&gt;min(r1.length, r2.length)&lt;/code&gt;).</source>
          <target state="translated">두 범위 모두 길이 멤버가있는 경우이 함수는 &amp;Omicron; ( &lt;code&gt;1&lt;/code&gt; )입니다. 그렇지 않으면이 함수는 &amp;Omicron; ( &lt;code&gt;min(r1.length, r2.length)&lt;/code&gt; )입니다.</target>
        </trans-unit>
        <trans-unit id="077a8fbc08834027e3db2ad54352fdf64c6364ae" translate="yes" xml:space="preserve">
          <source>If both x and n are 0, the result is 1. If n is negative, an integer divide error will occur at runtime, regardless of the value of x.</source>
          <target state="translated">x와 n이 모두 0이면 결과는 1입니다. n이 음수이면 x 값에 관계없이 런타임에 정수 나누기 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d8d58e2935a54be899c1932e2430b1d836d6854b" translate="yes" xml:space="preserve">
          <source>If break is followed by</source>
          <target state="translated">break 다음에</target>
        </trans-unit>
        <trans-unit id="133ff22691958b87ce955cf38fc2654641e5c95a" translate="yes" xml:space="preserve">
          <source>If class invariant checking is turned on, the class invariant is called at the end of the constructor.</source>
          <target state="translated">클래스 불변 검사가 설정되어 있으면 생성자 끝에서 클래스 불변이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="2873dd219021490e067fcdc56ae6ce69a60f4696" translate="yes" xml:space="preserve">
          <source>If code detects an error like &quot;out of memory,&quot; then an Error is thrown with a message saying &quot;Out of memory&quot;. The function call stack is unwound, looking for a handler for the Error. &lt;a href=&quot;statement#TryStatement&quot;&gt;Finally blocks&lt;/a&gt; are executed as the stack is unwound. If an error handler is found, execution resumes there. If not, the default Error handler is run, which displays the message and terminates the program.</source>
          <target state="translated">코드가 &quot;메모리 부족&quot;과 같은 오류를 감지하면 &quot;메모리 부족&quot;이라는 메시지와 함께 오류가 발생합니다. 함수 호출 스택이 풀리고 오류에 대한 핸들러를 찾습니다. &lt;a href=&quot;statement#TryStatement&quot;&gt;마지막으로&lt;/a&gt; 스택이 풀릴 때 블록 이 실행됩니다. 오류 처리기가 발견되면 실행이 다시 시작됩니다. 그렇지 않으면 기본 오류 핸들러가 실행되어 메시지를 표시하고 프로그램을 종료합니다.</target>
        </trans-unit>
        <trans-unit id="026a3ed1741bfc55e99518c871b70d4250291a91" translate="yes" xml:space="preserve">
          <source>If continue is followed by</source>
          <target state="translated">계속이 이어지면</target>
        </trans-unit>
        <trans-unit id="6422eca509193d7e5c40c75cbc0a1df0e38709f1" translate="yes" xml:space="preserve">
          <source>If defined and &lt;code&gt;hookOpCast&lt;/code&gt; is</source>
          <target state="translated">정의되고 &lt;code&gt;hookOpCast&lt;/code&gt; 가</target>
        </trans-unit>
        <trans-unit id="5a7e95bb168b15f4a8bcb2b5cf99f8ea675a9dca" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;Hook.defaultValue!T&lt;/code&gt; is used as the default initializer of the payload.</source>
          <target state="translated">정의 된 경우 &lt;code&gt;Hook.defaultValue!T&lt;/code&gt; 가 페이로드의 기본 이니셜 라이저로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="03019d524f44be31cdffd6208c1acffd47d8953d" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;Hook.max!T&lt;/code&gt; is used as the maximum value of the payload.</source>
          <target state="translated">정의 된 경우 &lt;code&gt;Hook.max!T&lt;/code&gt; 가 페이로드의 최대 값으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f5bf55bfa3966b60e1868595f8913387e32b50a0" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;Hook.min!T&lt;/code&gt; is used as the minimum value of the payload.</source>
          <target state="translated">정의 된 경우 &lt;code&gt;Hook.min!T&lt;/code&gt; 가 페이로드의 최소값으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c860109476dd6e83e225430bc70cc535b0742b87" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;hook.hookOpBinary!op(get, rhs)&lt;/code&gt; (where &lt;code&gt;op&lt;/code&gt; is the operator symbol and &lt;code&gt;rhs&lt;/code&gt; is the right-hand side operand) is forwarded to unconditionally for binary operators &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;%&lt;/code&gt;, &lt;code&gt;^^&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">정의 된 경우 &lt;code&gt;hook.hookOpBinary!op(get, rhs)&lt;/code&gt; (여기서 &lt;code&gt;op&lt;/code&gt; 는 연산자 기호이고 &lt;code&gt;rhs&lt;/code&gt; 는 오른쪽 피연산자 임)는 이항 연산자 &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;/&lt;/code&gt; , &lt;code&gt;%&lt;/code&gt; , &lt;code&gt;^^&lt;/code&gt; 에 무조건 전달됩니다 . &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;|&lt;/code&gt; , &lt;code&gt;^&lt;/code&gt; , &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="22acb3135b0d52c02522e9bda0aa4a9ab72a1f15" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;hook.hookOpBinaryRight!op(lhs, get)&lt;/code&gt; (where &lt;code&gt;op&lt;/code&gt; is the operator symbol and &lt;code&gt;lhs&lt;/code&gt; is the left-hand side operand) is forwarded to unconditionally for binary operators &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;%&lt;/code&gt;, &lt;code&gt;^^&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">정의 된 경우 &lt;code&gt;hook.hookOpBinaryRight!op(lhs, get)&lt;/code&gt; (여기서 &lt;code&gt;op&lt;/code&gt; 는 연산자 기호이고 &lt;code&gt;lhs&lt;/code&gt; 는 왼쪽 피연산자 임)는 이진 연산자 &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;/&lt;/code&gt; , &lt;code&gt;%&lt;/code&gt; , &lt;code&gt;^^&lt;/code&gt; 에 무조건 전달됩니다 . &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;|&lt;/code&gt; , &lt;code&gt;^&lt;/code&gt; , &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="22f903c768577a0e387a7661822b3ab6e9ea3a27" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;hook.hookOpCast!U(get)&lt;/code&gt; is forwarded to unconditionally when the payload is to be cast to type &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">정의 된 경우, payload가 &lt;code&gt;U&lt;/code&gt; 유형으로 캐스트 될 때 &lt;code&gt;hook.hookOpCast!U(get)&lt;/code&gt; 이 무조건 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="d39d077b66c222df35757287877d0f5e2f125e3c" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;hook.hookOpCmp(get, rhs)&lt;/code&gt; is forwarded to unconditionally when the payload is compared for ordering against value &lt;code&gt;rhs&lt;/code&gt; of integral, floating point, or Boolean type.</source>
          <target state="translated">정의 경우, &lt;code&gt;hook.hookOpCmp(get, rhs)&lt;/code&gt; 페이로드는 값에 대한 순서를 비교한다 무조건 때 전달됩니다 &lt;code&gt;rhs&lt;/code&gt; 적분, 부동 소수점 또는 부울 유형입니다.</target>
        </trans-unit>
        <trans-unit id="61710dc38aff3803efddd69b40c8a0d534e524ab" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;hook.hookOpEquals(get, rhs)&lt;/code&gt; is forwarded to unconditionally when the payload is compared for equality against value &lt;code&gt;rhs&lt;/code&gt; of integral, floating point, or Boolean type.</source>
          <target state="translated">정의 된 경우, payload가 정수, 부동 소수점 또는 부울 유형의 값 &lt;code&gt;rhs&lt;/code&gt; 와 동일한 지 비교할 때 &lt;code&gt;hook.hookOpEquals(get, rhs)&lt;/code&gt; 가 무조건 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="78db295a6db30c78e28bbcb362075d3be4e0b84f" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;hook.hookOpOpAssign!op(payload, rhs)&lt;/code&gt; (where &lt;code&gt;op&lt;/code&gt; is the operator symbol and &lt;code&gt;rhs&lt;/code&gt; is the right-hand side operand) is forwarded to unconditionally for binary operators &lt;code&gt;+=&lt;/code&gt;, &lt;code&gt;-=&lt;/code&gt;, &lt;code&gt;*=&lt;/code&gt;, &lt;code&gt;/=&lt;/code&gt;, &lt;code&gt;%=&lt;/code&gt;, &lt;code&gt;^^=&lt;/code&gt;, &lt;code&gt;&amp;amp;=&lt;/code&gt;, &lt;code&gt;|=&lt;/code&gt;, &lt;code&gt;^=&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt;, and &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;=&lt;/code&gt;.</source>
          <target state="translated">정의 된 경우 &lt;code&gt;hook.hookOpOpAssign!op(payload, rhs)&lt;/code&gt; (여기서 &lt;code&gt;op&lt;/code&gt; 는 연산자 기호이고 &lt;code&gt;rhs&lt;/code&gt; 는 오른쪽 피연산자 임)는 2 진 연산자 &lt;code&gt;+=&lt;/code&gt; , &lt;code&gt;-=&lt;/code&gt; , &lt;code&gt;*=&lt;/code&gt; , &lt;code&gt;/=&lt;/code&gt; , &lt;code&gt;%=&lt;/code&gt; 에 무조건 전달됩니다. = , &lt;code&gt;^^=&lt;/code&gt; , &lt;code&gt;&amp;amp;=&lt;/code&gt; , &lt;code&gt;|=&lt;/code&gt; , &lt;code&gt;^=&lt;/code&gt; , &lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; 및 &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;=&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="52c14604f1c472b8a4a8bbea3e846c210307c64e" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;hook.hookOpUnary!op(get)&lt;/code&gt; (where &lt;code&gt;op&lt;/code&gt; is the operator symbol) is forwarded to for unary operators &lt;code&gt;-&lt;/code&gt; and &lt;code&gt;~&lt;/code&gt;. In addition, for unary operators &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt;, &lt;code&gt;hook.hookOpUnary!op(payload)&lt;/code&gt; is called, where &lt;code&gt;payload&lt;/code&gt; is a reference to the value wrapped by &lt;code&gt;Checked&lt;/code&gt; so the hook can change it.</source>
          <target state="translated">정의 경우 &lt;code&gt;hook.hookOpUnary!op(get)&lt;/code&gt; (여기서 &lt;code&gt;op&lt;/code&gt; 운영자의 상징이다) 단항 연산자에 대한 전달됩니다 &lt;code&gt;-&lt;/code&gt; 와 &lt;code&gt;~&lt;/code&gt; . 또한 단항 연산자 &lt;code&gt;++&lt;/code&gt; 및 &lt;code&gt;--&lt;/code&gt; 경우 &lt;code&gt;hook.hookOpUnary!op(payload)&lt;/code&gt; 가 호출됩니다. 여기서 &lt;code&gt;payload&lt;/code&gt; 는 &lt;code&gt;Checked&lt;/code&gt; 로 래핑 된 값에 대한 참조 이므로 후크가이를 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2297e50d0b2beb4cdd48e76ba56a839dcb04ab78" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;hook.hookToHash(payload)&lt;/code&gt; (where &lt;code&gt;payload&lt;/code&gt; is a reference to the value wrapped by Checked) is forwarded to when &lt;code&gt;toHash&lt;/code&gt; is called on a Checked type. Custom hashing can be implemented in a &lt;code&gt;Hook&lt;/code&gt;, otherwise the built-in hashing is used.</source>
          <target state="translated">정의 된 경우, &lt;code&gt;hook.hookToHash(payload)&lt;/code&gt; ( &lt;code&gt;payload&lt;/code&gt; 는 Checked에 의해 랩핑 된 값에 대한 참조 임)는 &lt;code&gt;toHash&lt;/code&gt; 가 Checked 유형에서 호출 될 때 전달됩니다 . 사용자 정의 해싱은 &lt;code&gt;Hook&lt;/code&gt; 에서 구현 될 수 있으며 , 그렇지 않으면 내장 해싱이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="33310de24a417af9692c142b1ec271b4bb06c9e6" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;hook.onLowerBound(value, bound)&lt;/code&gt; (where &lt;code&gt;value&lt;/code&gt; is the value being assigned) is forwarded to when the result of binary operators &lt;code&gt;+=&lt;/code&gt;, &lt;code&gt;-=&lt;/code&gt;, &lt;code&gt;*=&lt;/code&gt;, &lt;code&gt;/=&lt;/code&gt;, &lt;code&gt;%=&lt;/code&gt;, &lt;code&gt;^^=&lt;/code&gt;, &lt;code&gt;&amp;amp;=&lt;/code&gt;, &lt;code&gt;|=&lt;/code&gt;, &lt;code&gt;^=&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt;, and &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;=&lt;/code&gt; is smaller than the smallest value representable by &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">정의하면 &lt;code&gt;hook.onLowerBound(value, bound)&lt;/code&gt; (단, &lt;code&gt;value&lt;/code&gt; 때 이진 연산자의 결과로 전달되는 값이 할당되는) &lt;code&gt;+=&lt;/code&gt; , &lt;code&gt;-=&lt;/code&gt; , &lt;code&gt;*=&lt;/code&gt; , &lt;code&gt;/=&lt;/code&gt; , &lt;code&gt;%=&lt;/code&gt; , &lt;code&gt;^^=&lt;/code&gt; , &lt;code&gt;&amp;amp;=&lt;/code&gt; , &lt;code&gt;|=&lt;/code&gt; , &lt;code&gt;^=&lt;/code&gt; , &lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; 및 &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;=&lt;/code&gt; 은 &lt;code&gt;T&lt;/code&gt; 로 표시 할 수있는 가장 작은 값보다 작습니다 .</target>
        </trans-unit>
        <trans-unit id="ab6931e0e7ba4cd85c003adc62fe48bb16dad0a7" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;hook.onOverflow!op(get)&lt;/code&gt; is forwarded to for unary operators that overflow but only if &lt;code&gt;hookOpUnary&lt;/code&gt; is not defined. Unary &lt;code&gt;~&lt;/code&gt; does not overflow; unary &lt;code&gt;-&lt;/code&gt; overflows only when the most negative value of a signed type is negated, and the result of the hook call is returned. When the increment or decrement operators overflow, the payload is assigned the result of &lt;code&gt;hook.onOverflow!op(get)&lt;/code&gt;. When a binary operator overflows, the result of &lt;code&gt;hook.onOverflow!op(get, rhs)&lt;/code&gt; is returned, but only if &lt;code&gt;Hook&lt;/code&gt; does not define &lt;code&gt;hookOpBinary&lt;/code&gt;.</source>
          <target state="translated">정의 된 경우 &lt;code&gt;hook.onOverflow!op(get)&lt;/code&gt; 은 오버플로되는 단항 연산자에 대해 전달되지만 &lt;code&gt;hookOpUnary&lt;/code&gt; 가 정의되지 않은 경우에만 전달 됩니다. 단항 &lt;code&gt;~&lt;/code&gt; 오버플로하지 않습니다; 단항 &lt;code&gt;-&lt;/code&gt; 부호있는 유형의 가장 음수 값이 무시되고 후크 호출 결과가 리턴되는 경우에만 오버 플로우됩니다. 증가 또는 감소 연산자가 오버 플로우되면 페이로드에 &lt;code&gt;hook.onOverflow!op(get)&lt;/code&gt; 의 결과가 할당됩니다 . 이진 연산자가 오버플로되면 &lt;code&gt;hook.onOverflow!op(get, rhs)&lt;/code&gt; 의 결과 가 반환되지만 &lt;code&gt;Hook&lt;/code&gt; 가 &lt;code&gt;hookOpBinary&lt;/code&gt; 를 정의하지 않은 경우에만 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="908a2f8c24579c24ba178c54fd857b4b41ae78ef" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;hook.onUpperBound(value, bound)&lt;/code&gt; (where &lt;code&gt;value&lt;/code&gt; is the value being assigned) is forwarded to when the result of binary operators &lt;code&gt;+=&lt;/code&gt;, &lt;code&gt;-=&lt;/code&gt;, &lt;code&gt;*=&lt;/code&gt;, &lt;code&gt;/=&lt;/code&gt;, &lt;code&gt;%=&lt;/code&gt;, &lt;code&gt;^^=&lt;/code&gt;, &lt;code&gt;&amp;amp;=&lt;/code&gt;, &lt;code&gt;|=&lt;/code&gt;, &lt;code&gt;^=&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt;, and &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;=&lt;/code&gt; is larger than the largest value representable by &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">정의하면 &lt;code&gt;hook.onUpperBound(value, bound)&lt;/code&gt; (단, &lt;code&gt;value&lt;/code&gt; 때 이진 연산자의 결과로 전달되는 값이 할당되는) &lt;code&gt;+=&lt;/code&gt; , &lt;code&gt;-=&lt;/code&gt; , &lt;code&gt;*=&lt;/code&gt; , &lt;code&gt;/=&lt;/code&gt; , &lt;code&gt;%=&lt;/code&gt; , &lt;code&gt;^^=&lt;/code&gt; , &lt;code&gt;&amp;amp;=&lt;/code&gt; , &lt;code&gt;|=&lt;/code&gt; , &lt;code&gt;^=&lt;/code&gt; , &lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; 및 &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;=&lt;/code&gt; 은 &lt;code&gt;T&lt;/code&gt; 로 표시 할 수있는 가장 큰 값보다 큽니다 .</target>
        </trans-unit>
        <trans-unit id="4d3755f1788c95f9d9709ea3791ec92f2804e77a" translate="yes" xml:space="preserve">
          <source>If e is a SliceExp, constant fold it.</source>
          <target state="translated">e가 SliceExp이면 일정하게 접습니다.</target>
        </trans-unit>
        <trans-unit id="4e157bdef2847bcd47c86d8616eb969d0de41200" translate="yes" xml:space="preserve">
          <source>If e1 is a property function (template), resolve it.</source>
          <target state="translated">e1이 특성 함수 (서식 파일) 인 경우 해결하십시오.</target>
        </trans-unit>
        <trans-unit id="fe36cf6a431bba3d0f0866cfcc1c8bfbdb70659d" translate="yes" xml:space="preserve">
          <source>If either is null =&amp;gt; non-equal</source>
          <target state="translated">둘 중 하나가 null =&amp;gt; 같지 않은 경우</target>
        </trans-unit>
        <trans-unit id="51547fe82011becc25f7663a54c1c79b37b3b626" translate="yes" xml:space="preserve">
          <source>If either operand is &lt;code&gt;real&lt;/code&gt;, the other operand is converted to &lt;code&gt;real&lt;/code&gt;.</source>
          <target state="translated">피연산자 중 하나가 &lt;code&gt;real&lt;/code&gt; 인 경우 다른 피연산자는 &lt;code&gt;real&lt;/code&gt; 로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="2c828619435ec0d80d0eb291888f4070be2665b9" translate="yes" xml:space="preserve">
          <source>If either operand is a floating point type, the other is implicitly converted to floating point and they are brought to a common type via the &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;Usual Arithmetic Conversions&lt;/a&gt;.</source>
          <target state="translated">피연산자 중 하나가 부동 소수점 유형 인 경우, 다른 피연산자는 내재적으로 부동 소수점으로 변환되고 &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;일반적인 산술 변환을&lt;/a&gt; 통해 공통 유형으로 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="19204c26120415c2143a5e03cf2be7f558db1190" translate="yes" xml:space="preserve">
          <source>If either the second or third expressions are of type &lt;code&gt;void&lt;/code&gt;, then the resulting type is &lt;code&gt;void&lt;/code&gt;. Otherwise, the second and third expressions are implicitly converted to a common type which becomes the result type of the conditional expression.</source>
          <target state="translated">두 번째 또는 세 번째 표현식이 &lt;code&gt;void&lt;/code&gt; 유형 인 경우 결과 유형은 &lt;code&gt;void&lt;/code&gt; 입니다. 그렇지 않으면, 두 번째 및 세 번째 표현식이 내재적으로 공통 유형으로 변환되어 조건식의 결과 유형이됩니다.</target>
        </trans-unit>
        <trans-unit id="653d0a49e3e776a2dacb4a126f5f7199b157c776" translate="yes" xml:space="preserve">
          <source>If expression can be tested for true or false, returns the modified expression. Otherwise returns ErrorExp.</source>
          <target state="translated">expression을 true 또는 false로 테스트 할 수 있으면 수정 된 표현식을 리턴합니다. 그렇지 않으면 ErrorExp를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b36e87ad6619937152cb1864f5c28a8d82857aaf" translate="yes" xml:space="preserve">
          <source>If expression is shared, check that we can access it. Give error message if not.</source>
          <target state="translated">expression이 공유되면 액세스 할 수 있는지 확인하십시오. 그렇지 않은 경우 오류 메시지를 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="b903eb11d9ca574de1d125b6a0ddd43ec7f26143" translate="yes" xml:space="preserve">
          <source>If flag &lt;code&gt;KeepTerminator&lt;/code&gt; is set to &lt;code&gt;KeepTerminator.yes&lt;/code&gt;, then the delimiter is included in the strings returned.</source>
          <target state="translated">플래그 경우 &lt;code&gt;KeepTerminator&lt;/code&gt; 이 설정되어 &lt;code&gt;KeepTerminator.yes&lt;/code&gt; , 다음 구분 기호 반환 된 문자열에 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="235b8759d68e4d6c00eac4cd7371849cd3084978" translate="yes" xml:space="preserve">
          <source>If found, return list entry that it is, else null.</source>
          <target state="translated">발견되면 목록 항목을 리턴하고 그렇지 않으면 널을 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="a226618dbb0d64b00416429ba20f88cb6f590b46" translate="yes" xml:space="preserve">
          <source>If func ever generates a time point greater than or equal to the current &lt;code&gt;front&lt;/code&gt; of the range, then a &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt;&lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">FUNC 적 시점보다 크거나 동일한 전류 생성하면 &lt;code&gt;front&lt;/code&gt; 범위를 다음 &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt; &lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt; 가&lt;/a&gt; 발생한다.</target>
        </trans-unit>
        <trans-unit id="6bcd1b67b2b6132e6574059a063d80b5509091a8" translate="yes" xml:space="preserve">
          <source>If func ever generates a time point greater than or equal to the current &lt;code&gt;front&lt;/code&gt; of the range, then a &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt;&lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt;&lt;/a&gt; will be thrown. The range will be empty and iteration complete when func generates a time point equal to or less than the &lt;code&gt;begin&lt;/code&gt; of the interval.</source>
          <target state="translated">FUNC 적 시점보다 크거나 동일한 전류 생성하면 &lt;code&gt;front&lt;/code&gt; 범위를 다음 &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt; &lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt; 가&lt;/a&gt; 발생한다. func 이 간격 &lt;code&gt;begin&lt;/code&gt; 과 같거나 적은 시점을 생성하면 범위가 비어 있고 반복이 완료됩니다 .</target>
        </trans-unit>
        <trans-unit id="eefd5cc7fe1ca2c7b897d183dc4a05399326e46f" translate="yes" xml:space="preserve">
          <source>If func ever generates a time point less than or equal to the current &lt;code&gt;front&lt;/code&gt; of the range, then a &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt;&lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">func이 현재 범위 의 현재 &lt;code&gt;front&lt;/code&gt; 보다 작거나 같은 시점을 생성 하면 &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt; &lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt; &lt;/a&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c66509b1e052bea9e9d5481b7761f6c20d3b371f" translate="yes" xml:space="preserve">
          <source>If func ever generates a time point less than or equal to the current &lt;code&gt;front&lt;/code&gt; of the range, then a &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt;&lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt;&lt;/a&gt; will be thrown. The range will be empty and iteration complete when func generates a time point equal to or beyond the &lt;code&gt;end&lt;/code&gt; of the interval.</source>
          <target state="translated">func이 현재 범위 의 현재 &lt;code&gt;front&lt;/code&gt; 보다 작거나 같은 시점을 생성 하면 &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt; &lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt; &lt;/a&gt; 이 발생합니다. func 이 간격 &lt;code&gt;end&lt;/code&gt; 이상의 시간 지점을 생성하면 범위가 비어 있고 반복이 완료됩니다 .</target>
        </trans-unit>
        <trans-unit id="74f0c5b3f5f366de0c8aea12cba32b6bdb7a7e22" translate="yes" xml:space="preserve">
          <source>If func retains state which changes as it is called, then some algorithms will not work correctly, because the range's &lt;code&gt;save&lt;/code&gt; will have failed to have really saved the range's state. To avoid such bugs, don't pass a delegate which is not logically pure to &lt;code&gt;fwdRange&lt;/code&gt;. If func is given the same time point with two different calls, it must return the same result both times.  Of course, none of the functions in this module have this problem, so it's only relevant for custom delegates.</source>
          <target state="translated">func이 호출 될 때 변경되는 상태를 유지하면 범위 &lt;code&gt;save&lt;/code&gt; 이 실제로 범위 상태를 저장하지 못하기 때문에 일부 알고리즘이 올바르게 작동하지 않습니다 . 이러한 버그를 피하려면 &lt;code&gt;fwdRange&lt;/code&gt; 에 논리적으로 순수하지 않은 델리게이트를 전달하지 마십시오 . func에 두 개의 다른 호출로 동일한 시점이 부여되면 동일한 결과를 두 번 반환해야합니다. 물론이 모듈의 어떤 기능도이 문제를 가지고 있지 않으므로 사용자 지정 대리자에게만 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="082731789aa3a0c2389877b2540dad5fb393fea2" translate="yes" xml:space="preserve">
          <source>If func retains state which changes as it is called, then some algorithms will not work correctly, because the range's &lt;code&gt;save&lt;/code&gt; will have failed to have really saved the range's state. To avoid such bugs, don't pass a delegate which is not logically pure to &lt;code&gt;fwdRange&lt;/code&gt;. If func is given the same time point with two different calls, it must return the same result both times.  Of course, none of the functions in this module have this problem, so it's only relevant if when creating a custom delegate.</source>
          <target state="translated">func이 호출 될 때 변경되는 상태를 유지하면 범위 &lt;code&gt;save&lt;/code&gt; 이 실제로 범위 상태를 저장하지 못하기 때문에 일부 알고리즘이 올바르게 작동하지 않습니다 . 이러한 버그를 피하려면 &lt;code&gt;fwdRange&lt;/code&gt; 에 논리적으로 순수하지 않은 델리게이트를 전달하지 마십시오 . func에 두 개의 다른 호출로 동일한 시점이 부여되면 동일한 결과를 두 번 반환해야합니다. 물론이 모듈의 어떤 기능도이 문제를 가지고 있지 않으므로 사용자 지정 대리자를 만들 때만 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="811cb1951d7eca66363f0ab4a25ab0f68bd6c804" translate="yes" xml:space="preserve">
          <source>If function a function in a base class, return that base class.</source>
          <target state="translated">기본 클래스에서 함수가 함수이면 해당 기본 클래스를 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="3a618122aa9fe1978f9e550b5f42d584977ec33d" translate="yes" xml:space="preserve">
          <source>If in a quoted field any quote by itself, not at the end of a field, will end processing for that field.</source>
          <target state="translated">따옴표로 묶은 필드에 필드의 끝이 아닌 그 자체로 따옴표가 있으면 해당 필드에 대한 처리가 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="fc45bb57ad39df4d2be393733ec74789f2ef7133" translate="yes" xml:space="preserve">
          <source>If instantiated with &lt;code&gt;No.multiblock&lt;/code&gt;, it performs a search for the first zero bit in the bitmap and sets it.</source>
          <target state="translated">&lt;code&gt;No.multiblock&lt;/code&gt; 으로 인스턴스화 되면 비트 맵에서 첫 번째 0 비트를 검색하여 설정합니다.</target>
        </trans-unit>
        <trans-unit id="7b0f6cec4d5ea8c58428ba7c40e99097b7cb2322" translate="yes" xml:space="preserve">
          <source>If isNested() returns true, isThis() should return false, unless the function needs a dual-context pointer.</source>
          <target state="translated">isNested ()가 true를 반환하면 함수에 이중 컨텍스트 포인터가 필요하지 않으면 isThis ()는 false를 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="b4d04375110c3b3230b38eb2d9c5c313ab9a4587" translate="yes" xml:space="preserve">
          <source>If it is &lt;code&gt;false&lt;/code&gt;, then the third expression is evaluated, and its result is the result of the conditional expression.</source>
          <target state="translated">이 경우 &lt;code&gt;false&lt;/code&gt; 후 제 발현을 평가하고 그 결과는 조건식의 결과이다.</target>
        </trans-unit>
        <trans-unit id="ba0ab9ea37044a2e2b630f8489bf8ed0e516e703" translate="yes" xml:space="preserve">
          <source>If it is &lt;code&gt;true&lt;/code&gt;, then the second expression is evaluated, and its result is the result of the conditional expression.</source>
          <target state="translated">이 경우 &lt;code&gt;true&lt;/code&gt; 하고 상기 제 표현식을 평가하고 그 결과는 조건식의 결과이다.</target>
        </trans-unit>
        <trans-unit id="828463bf31c6d8c05164e51833a7bd26ece74f35" translate="yes" xml:space="preserve">
          <source>If it is desirable to persist a &lt;code&gt;Unique!T&lt;/code&gt; outside of its original scope, then it can be transferred. The transfer can be explicit, by calling &lt;code&gt;release&lt;/code&gt;, or implicit, when returning Unique from a function. The resource &lt;code&gt;T&lt;/code&gt; can be a polymorphic class object or instance of an interface, in which case Unique behaves polymorphically too.</source>
          <target state="translated">&lt;code&gt;Unique!T&lt;/code&gt; 원래 범위 밖에서 유지하는 것이 바람직한 경우 전송할 수 있습니다. 함수에서 Unique를 반환 할 때 &lt;code&gt;release&lt;/code&gt; 를 호출하여 암시 적으로 명시 적으로 전송할 수 있습니다 . 자원 &lt;code&gt;T&lt;/code&gt; 는 다형성 클래스 객체 또는 인터페이스의 인스턴스 일 수 있으며,이 경우 고유는 다형성으로도 작동합니다.</target>
        </trans-unit>
        <trans-unit id="1a1dc588bc158cc467f4127355a3912b746c621f" translate="yes" xml:space="preserve">
          <source>If just type T is given and no variable v, then the catch clause is still executed.</source>
          <target state="translated">유형 T 만 제공되고 변수 v가없는 경우 catch 절이 계속 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="f71f926a6db933017567619e75df00dc6712f06e" translate="yes" xml:space="preserve">
          <source>If multiple templates with the same</source>
          <target state="translated">동일한 템플릿이 여러 개인 경우</target>
        </trans-unit>
        <trans-unit id="35c6c44f6f67de6c4c0a779716275c68fe8b37b2" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;delimiter&lt;/code&gt; is given, then one trailing &lt;code&gt;'\r'&lt;/code&gt;, &lt;code&gt;'\n'&lt;/code&gt;, &lt;code&gt;&quot;\r\n&quot;&lt;/code&gt;, &lt;code&gt;'\f'&lt;/code&gt;, &lt;code&gt;'\v'&lt;/code&gt;, &lt;a href=&quot;std_uni#lineSep&quot;&gt;&lt;code&gt;std.uni.lineSep&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;std_uni#paraSep&quot;&gt;&lt;code&gt;std.uni.paraSep&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;std_uni#nelSep&quot;&gt;&lt;code&gt;std.uni.nelSep&lt;/code&gt;&lt;/a&gt; is removed from the end of &lt;code&gt;str&lt;/code&gt;. If &lt;code&gt;str&lt;/code&gt; does not end with any of those characters, then it is returned unchanged.</source>
          <target state="translated">&lt;code&gt;delimiter&lt;/code&gt; 를 지정 하지 않으면 하나의 후행 &lt;code&gt;'\r'&lt;/code&gt; , &lt;code&gt;'\n'&lt;/code&gt; , &lt;code&gt;&quot;\r\n&quot;&lt;/code&gt; , &lt;code&gt;'\f'&lt;/code&gt; , &lt;code&gt;'\v'&lt;/code&gt; , &lt;a href=&quot;std_uni#lineSep&quot;&gt; &lt;code&gt;std.uni.lineSep&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;std_uni#paraSep&quot;&gt; &lt;code&gt;std.uni.paraSep&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;std_uni#nelSep&quot;&gt; &lt;code&gt;std.uni.nelSep&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;str&lt;/code&gt; 의 끝에서 제거됩니다 . 경우 &lt;code&gt;str&lt;/code&gt; 그 모든 문자로 끝나지 않고, 다음은 변경되지 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="2b0411e822ff9871e75f5fe6e95c3d0518b1b309" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;needle&lt;/code&gt; is provided, &lt;code&gt;pred(haystack.front)&lt;/code&gt; will be evaluated on each element of the input range.</source>
          <target state="translated">&lt;code&gt;needle&lt;/code&gt; 이 제공 되지 않으면 입력 범위의 각 요소 에서 &lt;code&gt;pred(haystack.front)&lt;/code&gt; 가 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="69633a75862efb516486b64d796be076d86f4c19" translate="yes" xml:space="preserve">
          <source>If no call to constructors via &lt;code&gt;this&lt;/code&gt; or &lt;code&gt;super&lt;/code&gt; appear in a constructor, and the base class has a constructor, a call to &lt;code&gt;super()&lt;/code&gt; is inserted at the beginning of the constructor.</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; 또는 &lt;code&gt;super&lt;/code&gt; 를 통한 생성자 호출이 생성자에 나타나지 않고 기본 클래스에 생성자가있는 경우 생성자 시작 부분에 &lt;code&gt;super()&lt;/code&gt; 호출 이 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="a6ba6c3c787fc12e247d6c67731ac7ae3ae18393" translate="yes" xml:space="preserve">
          <source>If no calls to a delegating constructor or &lt;code&gt;super&lt;/code&gt; appear in a constructor, and the base class has a nullary constructor, a call to &lt;code&gt;super()&lt;/code&gt; is inserted at the beginning of the constructor. If that base class has a constructor that requires arguments and no nullary constructor, a matching call to &lt;code&gt;super&lt;/code&gt; is required.</source>
          <target state="translated">위임 생성자 또는 &lt;code&gt;super&lt;/code&gt; 에 대한 호출이 생성자에 나타나지 않고 기본 클래스에 nullary 생성자가있는 경우 &lt;code&gt;super()&lt;/code&gt; 대한 호출 이 생성자 시작 부분에 삽입됩니다. 해당 기본 클래스에 인수가 필요한 생성자가 있고 nullary 생성자 가없는 경우 &lt;code&gt;super&lt;/code&gt; 에 대한 일치 호출 이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="08c68d59ef2b4bb11a75a62d44b96024d217f2ea" translate="yes" xml:space="preserve">
          <source>If no catch handlers are there for the errors, then the program gracefully exits through the default error handler with an appropriate message.</source>
          <target state="translated">오류에 대한 catch 핸들러가없는 경우 프로그램은 적절한 메시지와 함께 기본 오류 핸들러를 정상적으로 종료합니다.</target>
        </trans-unit>
        <trans-unit id="a3f4b45154d7d5df5948f5742dc5af04d95c91df" translate="yes" xml:space="preserve">
          <source>If no cycles are found, the ctors and tlsctors are replaced with the ones generated by this algorithm to preserve the old incorrect ordering behavior.</source>
          <target state="translated">사이클을 찾지 못하면 ctor와 tlsctor가이 알고리즘에 의해 생성 된 것으로 대체되어 이전의 잘못된 순서 동작을 유지합니다.</target>
        </trans-unit>
        <trans-unit id="fd69e84bfca07a56902d7641663496f5b667fb84" translate="yes" xml:space="preserve">
          <source>If no data is available and the main thread access the range it will block until data becomes available. An exception to this is the &lt;code&gt;wait(Duration)&lt;/code&gt; method on the &lt;a href=&quot;#ChunkInputRange&quot;&gt;&lt;code&gt;ChunkInputRange&lt;/code&gt;&lt;/a&gt;. This method will wait at maximum for the specified duration and return true if data is available.</source>
          <target state="translated">사용 가능한 데이터가없고 주 스레드가 해당 범위에 액세스하면 데이터를 사용할 수있을 때까지 범위가 차단됩니다. &lt;a href=&quot;#ChunkInputRange&quot;&gt; &lt;code&gt;ChunkInputRange&lt;/code&gt; &lt;/a&gt; 의 &lt;code&gt;wait(Duration)&lt;/code&gt; 메소드는 예외 입니다. 이 메소드는 지정된 지속 시간 동안 최대 대기하며 데이터가 사용 가능한 경우 true를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="b37f49606e8cab3bb492c893e69c1a2e75dd1924" translate="yes" xml:space="preserve">
          <source>If no data is available and the main thread accesses the range it will block until data becomes available. An exception to this is the &lt;code&gt;wait(Duration)&lt;/code&gt; method on the &lt;a href=&quot;#LineInputRange&quot;&gt;&lt;code&gt;LineInputRange&lt;/code&gt;&lt;/a&gt;. This method will wait at maximum for the specified duration and return true if data is available.</source>
          <target state="translated">사용 가능한 데이터가없고 메인 스레드가 범위에 액세스하면 데이터를 사용할 수있을 때까지 차단됩니다. 이에 대한 예외 는 &lt;a href=&quot;#LineInputRange&quot;&gt; &lt;code&gt;LineInputRange&lt;/code&gt; &lt;/a&gt; 의 &lt;code&gt;wait(Duration)&lt;/code&gt; 메소드입니다 . 이 메소드는 지정된 지속 시간 동안 최대 대기하며 데이터가 사용 가능한 경우 true를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="dee768fdd957e908ee906de5d9f09ab3f15a2b74" translate="yes" xml:space="preserve">
          <source>If no explicit seed is provided, the first element of each work unit is used as a seed. For the final reduction, the result from the first work unit is used as the seed.</source>
          <target state="translated">명시적인 시드가 제공되지 않으면 각 작업 단위의 첫 번째 요소가 시드로 사용됩니다. 최종 축소를 위해 첫 번째 작업 단위의 결과가 시드로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b9beba693b6541f5c4a623aa8005a14a8c088860" translate="yes" xml:space="preserve">
          <source>If no function to call is specified, &lt;code&gt;each&lt;/code&gt; defaults to doing nothing but consuming the entire range. &lt;code&gt;r.front&lt;/code&gt; will be evaluated, but that can be avoided by specifying a lambda with a &lt;code&gt;lazy&lt;/code&gt; parameter.</source>
          <target state="translated">호출 할 함수가 지정되지 않은 경우 &lt;code&gt;each&lt;/code&gt; 기본적으로 전체 범위를 소비하는 것 외에는 아무것도하지 않습니다. &lt;code&gt;r.front&lt;/code&gt; 는 평가되지만 &lt;code&gt;lazy&lt;/code&gt; 매개 변수 로 람다를 지정하면 피할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7b0e9e2df565b7ef14de5d370ee2e7f5508ed495" translate="yes" xml:space="preserve">
          <source>If no needle is provided, the &lt;code&gt;haystack&lt;/code&gt; is advanced as long as &lt;code&gt;pred&lt;/code&gt; evaluates to &lt;code&gt;true&lt;/code&gt;. Similarly, the haystack is positioned so as &lt;code&gt;pred&lt;/code&gt; evaluates to &lt;code&gt;false&lt;/code&gt; for &lt;code&gt;haystack.front&lt;/code&gt;.</source>
          <target state="translated">바늘이 제공되지 않으면 &lt;code&gt;pred&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 로 평가되는 한 &lt;code&gt;haystack&lt;/code&gt; 가 전진 합니다 . 마찬가지로 haystack은 &lt;code&gt;haystack.front&lt;/code&gt; 에 대해 &lt;code&gt;pred&lt;/code&gt; 가 &lt;code&gt;false&lt;/code&gt; 로 평가 되도록 배치됩니다 .</target>
        </trans-unit>
        <trans-unit id="8015dc4a71527e3287d7f4a1a1531193efdd9ebe" translate="yes" xml:space="preserve">
          <source>If no random number generator is passed to &lt;code&gt;randomCover&lt;/code&gt;, the thread-global RNG rndGen will be used internally.</source>
          <target state="translated">난수 생성기가 &lt;code&gt;randomCover&lt;/code&gt; 로 전달되지 않으면 스레드 글로벌 RNG rndGen이 내부적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ec48dd4e26e9c9b7bb1bba08590ef49f6e8b00b5" translate="yes" xml:space="preserve">
          <source>If no separator is passed, the  predicate &lt;code&gt;isTerminator&lt;/code&gt; decides whether to accept an element of &lt;code&gt;r&lt;/code&gt;.</source>
          <target state="translated">분리자가 전달되지 않으면 술어 &lt;code&gt;isTerminator&lt;/code&gt; 는 &lt;code&gt;r&lt;/code&gt; 의 요소를 승인할지 여부를 결정합니다 .</target>
        </trans-unit>
        <trans-unit id="4f27eb4bbcd5d830894d40b205272557d1b8c1c3" translate="yes" xml:space="preserve">
          <source>If no unittest custom handlers are registered, the following algorithm is executed (the behavior can be affected by the &lt;code&gt;--DRT-testmode&lt;/code&gt; switch below):</source>
          <target state="translated">unittest 사용자 지정 처리기가 등록되지 않은 경우 다음 알고리즘이 실행됩니다 (동작은 아래 의 &lt;code&gt;--DRT-testmode&lt;/code&gt; 스위치 의 영향을받을 수 있음 ).</target>
        </trans-unit>
        <trans-unit id="d5a9c9c4272e471499a4566ff40a97f218d487f9" translate="yes" xml:space="preserve">
          <source>If no unittest custom handlers are registered, the following algorithm is executed (the behavior can be affected by the &lt;code&gt;--DRT-testmode&lt;/code&gt; switch below): 1. Run all unit tests, tracking tests executed and passes. For each that fails, print the stack trace, and continue. 2. If there are no failures, set the summarize flag to false, and the runMain flag to true. 3. If there are failures, set the summarize flag to true, and the runMain flag to false.</source>
          <target state="translated">unittest 사용자 정의 핸들러가 등록되지 않은 경우 다음 알고리즘이 실행됩니다 ( 아래 의 &lt;code&gt;--DRT-testmode&lt;/code&gt; 스위치 가 동작에 영향을 줄 수 있음 ). 1. 모든 단위 테스트를 실행하고 실행 된 테스트를 추적하고 통과합니다. 실패한 각각에 대해 스택 추적을 인쇄하고 계속하십시오. 2. 실패가 없으면 요약 플래그를 false로 설정하고 runMain 플래그를 true로 설정하십시오. 3. 실패가 있으면 요약 플래그를 true로 설정하고 runMain 플래그를 false로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="8e742609c87c27dd7441a0c05820a232e71bfca1" translate="yes" xml:space="preserve">
          <source>If no unittests were present, set summarize to false, and runMain to true.</source>
          <target state="translated">unittest가 없으면 summary를 false로 설정하고 runMain을 true로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="fe70a6ffb1eaff978d001d003d35769a95cf2acb" translate="yes" xml:space="preserve">
          <source>If non-zero, prefix result with 0x (0X).</source>
          <target state="translated">0이 아닌 경우 접두사 결과는 0x (0X)입니다.</target>
        </trans-unit>
        <trans-unit id="bb201c468fcb1936a1cc835ca2cb32dd5d97a148" translate="yes" xml:space="preserve">
          <source>If none of the case expressions match, and there is a default statement, the default statement is transferred to.</source>
          <target state="translated">대소 문자 표현식이 일치하지 않고 기본 명령문이있는 경우 기본 명령문이 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="ab5f1042c0495e282ce28b3b52048c3700563975" translate="yes" xml:space="preserve">
          <source>If none of the choice matches, a &lt;code&gt;SwitchError&lt;/code&gt; will be thrown. &lt;code&gt;SwitchError&lt;/code&gt; will also be thrown if not all the choices are void and a void choice was executed without throwing anything.</source>
          <target state="translated">일치하는 선택이 &lt;code&gt;SwitchError&lt;/code&gt; 가 발생합니다. 모든 선택이 무효가 아니고 아무것도 던지지 않고 무효 선택이 실행 된 경우에도 &lt;code&gt;SwitchError&lt;/code&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3ed3959f15bba3be1a16efa6393b19ce9aeff019" translate="yes" xml:space="preserve">
          <source>If not specified, the</source>
          <target state="translated">지정하지 않으면</target>
        </trans-unit>
        <trans-unit id="fe9db14bd961ccfeeb8601ee73a6483367ad2a6a" translate="yes" xml:space="preserve">
          <source>If one is a better match than the other, or one compiles and the other does not, the first is selected.</source>
          <target state="translated">하나가 다른 것보다 더 잘 일치하거나 하나가 컴파일되고 다른 하나가 컴파일되지 않으면 첫 번째가 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="6dedca9993144f5a2bfb52216f61891e811d98ea" translate="yes" xml:space="preserve">
          <source>If one of the arguments is a &lt;code&gt;NaN&lt;/code&gt;, the other is returned.</source>
          <target state="translated">인수 중 하나가 &lt;code&gt;NaN&lt;/code&gt; 이면 다른 하나가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="38f309363d54cf09070c11d4dd142dc6d8bfb60d" translate="yes" xml:space="preserve">
          <source>If one of the arguments is a NaN, the other is returned.</source>
          <target state="translated">인수 중 하나가 NaN이면 다른 인수가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="f22c395490cca8ea1c81135fd8838b0c5b0afefa" translate="yes" xml:space="preserve">
          <source>If one of the numbers is an integral and the other is a floating-point number, &lt;code&gt;hookOpEquals(x, y)&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; if and only if the integral can be converted exactly (without approximation) to the floating-point number. This is in order to preserve transitivity of equality: if &lt;code&gt; hookOpEquals(x, y)&lt;/code&gt; and &lt;code&gt;hookOpEquals(y, z)&lt;/code&gt; then &lt;code&gt;hookOpEquals(y, z)&lt;/code&gt;, in case &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt; are a mix of integral and floating-point numbers.</source>
          <target state="translated">숫자 중 하나가 정수이고 다른 하나가 부동 소수점 숫자 인 경우 &lt;code&gt;hookOpEquals(x, y)&lt;/code&gt; 는 적분을 부동 소수점 숫자로 정확하게 (근사없이) 변환 할 수있는 경우에만 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 . 이는 등가의 전이성을 보존하기위한 것입니다. 만약 &lt;code&gt; hookOpEquals(x, y)&lt;/code&gt; 및 &lt;code&gt;hookOpEquals(y, z)&lt;/code&gt; 이면 &lt;code&gt;hookOpEquals(y, z)&lt;/code&gt; 이면 &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; , &lt;code&gt;z&lt;/code&gt; 는 정수와 부동 소수점 숫자의 혼합입니다 .</target>
        </trans-unit>
        <trans-unit id="47e27965329d106e5c510ac4b7c35d3cf65701ae" translate="yes" xml:space="preserve">
          <source>If one of the numbers is an integral and the other is a floating-point number, &lt;code&gt;hookOpEquals(x, y)&lt;/code&gt; returns a floating-point number that is &lt;code&gt;-1&lt;/code&gt; if &lt;code&gt;x &amp;lt; y&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt; if &lt;code&gt;x == y&lt;/code&gt;, &lt;code&gt;1&lt;/code&gt; if &lt;code&gt;x &amp;gt; y&lt;/code&gt;, and &lt;code&gt;NaN&lt;/code&gt; if the floating-point number is &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">숫자 중 하나가 일체형이고, 다른 하나는 부동 소수이면 &lt;code&gt;hookOpEquals(x, y)&lt;/code&gt; 있는 부동 소수점 수를 반환 &lt;code&gt;-1&lt;/code&gt; 경우, &lt;code&gt;x &amp;lt; y&lt;/code&gt; , &lt;code&gt;0&lt;/code&gt; 의 경우 &lt;code&gt;x == y&lt;/code&gt; , &lt;code&gt;1&lt;/code&gt; 의 경우 &lt;code&gt;x &amp;gt; y&lt;/code&gt; 및 &lt;code&gt;NaN&lt;/code&gt; 이는 부동 소수점 수는이면 &lt;code&gt;NaN&lt;/code&gt; 이 .</target>
        </trans-unit>
        <trans-unit id="4188be61c77849339804ae3977d382498bd8812e" translate="yes" xml:space="preserve">
          <source>If one operand is an enum and the other is the base type of that enum, the result is the base type.</source>
          <target state="translated">한 피연산자가 열거 형이고 다른 피연산자가 해당 열거 형의 기본 유형 인 경우 결과는 기본 유형입니다.</target>
        </trans-unit>
        <trans-unit id="422f2e869457e9aec8090f25e67e71da6e5ae6e8" translate="yes" xml:space="preserve">
          <source>If one or both of the operand types is an enum after undergoing the above conversions, the result type is:</source>
          <target state="translated">위 변환을 수행 한 후 피연산자 유형 중 하나 또는 둘 다가 열거 형이면 결과 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="34b4e760890c5916b5f472cf9ec3f9d946f615cd" translate="yes" xml:space="preserve">
          <source>If one or both operands are floating point, then a floating point comparison is performed.</source>
          <target state="translated">피연산자 중 하나 또는 둘 모두가 부동 소수점이면 부동 소수점 비교가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="f34527129f419587a7b124534783120be01591c6" translate="yes" xml:space="preserve">
          <source>If one range is infinite and the other finite, then the finite range must be a forward range, and the infinite range can be an input range.</source>
          <target state="translated">한 범위가 무한대이고 다른 범위가 유한 한 경우 유한 범위는 순방향 범위 여야하고 무한 범위는 입력 범위 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1493b0ab4b81a5a5d799727a74239f7ced24db39" translate="yes" xml:space="preserve">
          <source>If only one range is offered to &lt;code&gt;Chain&lt;/code&gt; or &lt;code&gt;chain&lt;/code&gt;, the &lt;code&gt;Chain&lt;/code&gt; type exits the picture by aliasing itself directly to that range's type.</source>
          <target state="translated">하나의 범위 만 &lt;code&gt;Chain&lt;/code&gt; 또는 &lt;code&gt;chain&lt;/code&gt; 에 제공되는 경우 &lt;code&gt;Chain&lt;/code&gt; 유형은 해당 범위의 유형에 직접 별명을 지정하여 그림을 종료합니다.</target>
        </trans-unit>
        <trans-unit id="4f4dfc7af6d318725cd2bb6acc7371848e22877c" translate="yes" xml:space="preserve">
          <source>If only one type is passed, then an array of that type. Otherwise, an array of &lt;a href=&quot;std_typecons#Tuple&quot;&gt;&lt;code&gt;std.typecons.Tuple&lt;/code&gt;&lt;/a&gt;s.</source>
          <target state="translated">하나의 유형 만 전달되면 해당 유형의 배열입니다. 그렇지 않으면 &lt;a href=&quot;std_typecons#Tuple&quot;&gt; &lt;code&gt;std.typecons.Tuple&lt;/code&gt; &lt;/a&gt; 의 배열입니다 .</target>
        </trans-unit>
        <trans-unit id="f80a4ee1709480a885baa729f38d366951608f11" translate="yes" xml:space="preserve">
          <source>If operands are integral types</source>
          <target state="translated">피연산자가 정수 유형 인 경우</target>
        </trans-unit>
        <trans-unit id="c17f6322872f795083ddb63a91c502026d7f7e3d" translate="yes" xml:space="preserve">
          <source>If overlapping is required, use &lt;a href=&quot;https://dlang.org/phobos/std_algorithm_mutation.html#copy&quot;&gt;&lt;code&gt;std.algorithm.mutation.copy&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">겹치는 것이 필요한 경우 &lt;a href=&quot;https://dlang.org/phobos/std_algorithm_mutation.html#copy&quot;&gt; &lt;code&gt;std.algorithm.mutation.copy&lt;/code&gt; 를&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="dcfac2e8846ad57a33a3bc26acae8df77dfcdb25" translate="yes" xml:space="preserve">
          <source>If overridding &lt;code&gt;Object.opEquals()&lt;/code&gt; for classes, the class member function signature should look like:</source>
          <target state="translated">클래스에 대해 &lt;code&gt;Object.opEquals()&lt;/code&gt; 를 재정의하는 경우 클래스 멤버 함수 서명은 다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="d70cff54f302f2d4a422baa59aebb43764d5cd42" translate="yes" xml:space="preserve">
          <source>If overriding &lt;code&gt;Object.opCmp()&lt;/code&gt; for classes, the class member function signature should look like:</source>
          <target state="translated">클래스에 대해 &lt;code&gt;Object.opCmp()&lt;/code&gt; 를 재정의하는 경우 클래스 멤버 함수 서명은 다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="3e09a8be6b9d197eccbe61876283b5ca6720c550" translate="yes" xml:space="preserve">
          <source>If p is null, no operation is performed.</source>
          <target state="translated">p가 널이면 조작이 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="352e9b1490dbc9b0a48acbedafe6ae17ff5f3152" translate="yes" xml:space="preserve">
          <source>If paramsym is null a new ScopeDsymbol is used in place of paramsym.</source>
          <target state="translated">paramsym이 null 인 경우 새로운 ScopeDsymbol이 paramsym 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0167129cd52bf73eb27d8ebdabfdbade4013fad0" translate="yes" xml:space="preserve">
          <source>If passed in a range of code points, returns a range with equivalent capabilities.</source>
          <target state="translated">코드 포인트 범위로 전달되면 동등한 기능을 가진 범위를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="15542b3779f094229ad4949cf6c05be1fd8cee3c" translate="yes" xml:space="preserve">
          <source>If pointers to D garbage collector allocated memory are passed to C functions, it's critical to ensure that that memory will not be collected by the garbage collector before the C function is done with it. This is accomplished by:</source>
          <target state="translated">D 가비지 콜렉터 할당 메모리에 대한 포인터가 C 함수로 전달되는 경우 C 함수를 수행하기 전에 가비지 콜렉터가 메모리를 수집하지 않도록하는 것이 중요합니다. 이것은 다음에 의해 달성됩니다.</target>
        </trans-unit>
        <trans-unit id="0dd282293b2dd30b59ba588f24339bbfcbc55f38" translate="yes" xml:space="preserve">
          <source>If pointers to memory allocated on the D garbage collector heap are passed to C++ functions, it's critical to ensure that the referenced memory will not be collected by the D garbage collector before the C++ function is done with it. This is accomplished by:</source>
          <target state="translated">D 가비지 콜렉터 힙에 할당 된 메모리에 대한 포인터가 C ++ 함수로 전달되는 경우 C ++ 함수를 사용하기 전에 참조 된 메모리가 D 가비지 콜렉터에 의해 수집되지 않도록하는 것이 중요합니다. 이것은 다음에 의해 달성됩니다.</target>
        </trans-unit>
        <trans-unit id="0fae4029daa6372cee7e8e40ab986342b94efc26" translate="yes" xml:space="preserve">
          <source>If possible, convert array initializer to associative array initializer.</source>
          <target state="translated">가능하면 배열 이니셜 라이저를 연관 배열 이니셜 라이저로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="917024e995f1fa2c71d6754ac363cc3314dc229d" translate="yes" xml:space="preserve">
          <source>If present, the</source>
          <target state="translated">있는 경우</target>
        </trans-unit>
        <trans-unit id="0b88da18898e09a28c0b2bdc7b134ad9a375efc5" translate="yes" xml:space="preserve">
          <source>If range is a range of bytes, an &lt;code&gt;Encoder&lt;/code&gt; that iterates over the bytes of the corresponding Base64 encoding.  If range is a range of ranges of bytes, an &lt;code&gt;Encoder&lt;/code&gt; that iterates over the Base64 encoded strings of each element of the range.  In both cases, the returned &lt;code&gt;Encoder&lt;/code&gt; will be a &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward range&lt;/a&gt; if the given &lt;code&gt;range&lt;/code&gt; is at least a forward range, otherwise it will be only an input range.</source>
          <target state="translated">range가 바이트 범위 인 경우 해당 Base64 인코딩의 바이트를 반복 하는 &lt;code&gt;Encoder&lt;/code&gt; 입니다. range가 바이트 범위의 범위 인 경우 범위 의 각 요소에서 Base64로 인코딩 된 문자열을 반복 하는 &lt;code&gt;Encoder&lt;/code&gt; 입니다. 두 경우 모두, 주어진 &lt;code&gt;range&lt;/code&gt; 가 최소한 &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;전방 범위&lt;/a&gt; 이면 반환 된 &lt;code&gt;Encoder&lt;/code&gt; 는 전방 범위 가되고, 그렇지 않으면 입력 범위 만됩니다.</target>
        </trans-unit>
        <trans-unit id="8fcc566f870dfdc11f9cf5642881af956a3edafb" translate="yes" xml:space="preserve">
          <source>If range is a range of characters, a &lt;code&gt;Decoder&lt;/code&gt; that iterates over the bytes of the corresponding Base64 decoding.  If range is a range of ranges of characters, a &lt;code&gt;Decoder&lt;/code&gt; that iterates over the decoded strings corresponding to each element of the range. In this case, the length of each subrange must be a multiple of 4; the returned decoder does not keep track of Base64 decoding state across subrange boundaries.  In both cases, the returned &lt;code&gt;Decoder&lt;/code&gt; will be a &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward range&lt;/a&gt; if the given &lt;code&gt;range&lt;/code&gt; is at least a forward range, otherwise it will be only an input range.  If the input data contains characters not found in the base alphabet of the current Base64 encoding scheme, the returned range may throw a &lt;code&gt;Base64Exception&lt;/code&gt;.</source>
          <target state="translated">range가 문자 범위 인 경우 해당 Base64 디코딩의 바이트를 반복 하는 &lt;code&gt;Decoder&lt;/code&gt; 입니다. range가 문자 범위의 범위 인 경우 범위의 각 요소에 해당하는 디코딩 된 문자열을 반복 하는 &lt;code&gt;Decoder&lt;/code&gt; 입니다. 이 경우 각 하위 범위의 길이는 4의 배수 여야합니다. 반환 된 디코더는 하위 범위 경계에 걸쳐 Base64 디코딩 상태를 추적하지 않습니다. 두 경우 모두, 주어진 &lt;code&gt;range&lt;/code&gt; 가 최소한 &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;전방 범위&lt;/a&gt; 이면 반환 된 &lt;code&gt;Decoder&lt;/code&gt; 는 전방 범위 가되고, 그렇지 않으면 입력 범위 만됩니다. 입력 데이터에 현재 Base64 인코딩 체계의 기본 알파벳에서 찾을 수없는 문자가 포함되어 있으면 반환 된 범위에서 &lt;code&gt;Base64Exception&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2b6eb7ddfbf5a47c6c6af2b15e78fb247a252fb4" translate="yes" xml:space="preserve">
          <source>If same exact type =&amp;gt; one call to method opEquals</source>
          <target state="translated">동일한 정확한 유형 =&amp;gt; opEquals 메소드를 한 번 호출하면</target>
        </trans-unit>
        <trans-unit id="89afd532fed79af758875995d860db76e2e127dd" translate="yes" xml:space="preserve">
          <source>If set at runtime, &lt;code&gt;min&lt;/code&gt; and/or &lt;code&gt;max&lt;/code&gt; must be initialized appropriately.</source>
          <target state="translated">런타임에 설정된 경우 &lt;code&gt;min&lt;/code&gt; 및 / 또는 &lt;code&gt;max&lt;/code&gt; 를 적절히 초기화해야합니다.</target>
        </trans-unit>
        <trans-unit id="7d613cefcf14fab9fa1cdf592c4b64df5fd4a02e" translate="yes" xml:space="preserve">
          <source>If set at runtime, &lt;code&gt;min&lt;/code&gt; and/or &lt;code&gt;max&lt;/code&gt; must be initialized appropriately. The block must have been allocated with this freelist, and no dynamic changing of &lt;code&gt;min&lt;/code&gt; or &lt;code&gt;max&lt;/code&gt; is allowed to occur between allocation and deallocation.</source>
          <target state="translated">런타임에 설정된 경우 &lt;code&gt;min&lt;/code&gt; 및 / 또는 &lt;code&gt;max&lt;/code&gt; 를 적절히 초기화해야합니다. 이 프리리스트로 블록을 할당해야 하며 할당과 할당 해제간에 &lt;code&gt;min&lt;/code&gt; 또는 &lt;code&gt;max&lt;/code&gt; 의 동적 변경이 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="12dba39acb6108d02380b6b46f58548fdd12a457" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;AllowDayOverflow.no&lt;/code&gt;, then day overflow is not allowed.</source>
          <target state="translated">&lt;code&gt;AllowDayOverflow.no&lt;/code&gt; 로 설정하면 day overflow가 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0c05e2e8281e59d8e307dc66be3d2cc276d8fa30" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;AutoStart.no&lt;/code&gt;, then the StopWatch is not started when it is constructed.</source>
          <target state="translated">&lt;code&gt;AutoStart.no&lt;/code&gt; 로 설정 하면 StopWatch가 구성 될 때 시작되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d6add4cf35e8c50b2af6d41b382ebe3f7e3e974a" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;AutoStart.no&lt;/code&gt;, then the stopwatch is not started when it is constructed.</source>
          <target state="translated">&lt;code&gt;AutoStart.no&lt;/code&gt; 로 설정 하면 스톱워치가 구성 될 때 시작되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e084739a519921a28023083912a24037cae39c78" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;CheckDns.no&lt;/code&gt;, isEmail does not perform DNS checking.</source>
          <target state="translated">&lt;code&gt;CheckDns.no&lt;/code&gt; 로 설정하면 isEmail 은 DNS 확인을 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0e1f47a96e002fe723252c695ba57f0bd6e6ab0f" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;OpenRight.yes&lt;/code&gt;, then the interval is open to the right (last element is not included).</source>
          <target state="translated">&lt;code&gt;OpenRight.yes&lt;/code&gt; 로 설정 하면 간격이 오른쪽으로 열립니다 (마지막 요소는 포함되지 않음).</target>
        </trans-unit>
        <trans-unit id="37becabb79a088b28ac5682f3e5ecf44b42c3e44" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;PopFirst.no&lt;/code&gt;, then popFront is not called before returning the range.</source>
          <target state="translated">&lt;code&gt;PopFirst.no&lt;/code&gt; 로 설정 하면 범위를 반환하기 전에 popFront가 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c46457e61c98538473682050d8870e6910707094" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;SortOutput.no&lt;/code&gt;, the output should not be sorted.</source>
          <target state="translated">&lt;code&gt;SortOutput.no&lt;/code&gt; 로 설정 되면 출력을 정렬하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="00965390f3dcb757da046e66cf3e12ece6325eda" translate="yes" xml:space="preserve">
          <source>If set, 0 is the only allowed &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754-1985#Denormalized_numbers&quot;&gt; IEEE754 denormalized&lt;/a&gt; number. Requires allowDenorm and storeNormalized.</source>
          <target state="translated">설정된 경우 0은 &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754-1985#Denormalized_numbers&quot;&gt;IEEE754 비정규 화 된&lt;/a&gt; 숫자 만 허용 됩니다. allowDenorm 및 storeNormalized가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="61485b68856bc9bc475231ad8439460508956a5d" translate="yes" xml:space="preserve">
          <source>If set, select an exponent bias such that max_exp = 1. i.e. so that the maximum value is &amp;gt;= 1.0 and &amp;lt; 2.0. Ignored if the exponent bias is manually specified.</source>
          <target state="translated">설정된 경우 max_exp = 1과 같은 지수 바이어스를 선택합니다. 즉, 최대 값이&amp;gt; = 1.0 및 &amp;lt;2.0이되도록합니다. 지수 바이어스가 수동으로 지정되면 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="b15a8a24ac3c0abdda604fa6be697872fed5e457" translate="yes" xml:space="preserve">
          <source>If set, unsigned custom floats are assumed to be negative.</source>
          <target state="translated">설정하면 부호없는 사용자 지정 부동 소수점은 음수로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="96c1d18878474b954f19c1048ca19bc4cc441ff0" translate="yes" xml:space="preserve">
          <source>If size dependencies are inevitable, put a &lt;code&gt;static assert&lt;/code&gt; in the code to verify it:</source>
          <target state="translated">크기 의존성이 불가피한 경우 코드에 &lt;code&gt;static assert&lt;/code&gt; 을 추가하여 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="c4932da89fb63071147ad73f57504dc48f8f86d2" translate="yes" xml:space="preserve">
          <source>If some of these fields is not NULL, it is a pointer to b_data.</source>
          <target state="translated">이러한 필드 중 일부가 NULL이 아닌 경우 b_data에 대한 포인터입니다.</target>
        </trans-unit>
        <trans-unit id="bf8032a0e0aff5e21ec9404228bec256c45b8757" translate="yes" xml:space="preserve">
          <source>If source has internal pointers that point to itself and doesn't define opPostMove, it cannot be moved, and will trigger an assertion failure.</source>
          <target state="translated">소스에 자체를 가리키는 내부 포인터가 있고 opPostMove를 정의하지 않으면 이동할 수 없으며 어설 션 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c4372423a2292ca511a5a4c383dba5ab95bc4f7d" translate="yes" xml:space="preserve">
          <source>If source has internal pointers that point to itself, it cannot be moved, and will trigger an assertion failure.</source>
          <target state="translated">소스에 자체를 가리키는 내부 포인터가 있으면 이동할 수 없으며 어설 션 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b61714985a37455e4a9923539bc1db8640864a65" translate="yes" xml:space="preserve">
          <source>If splitting a string on whitespace and token compression is desired, consider using &lt;code&gt;splitter&lt;/code&gt; without specifying a separator.</source>
          <target state="translated">공백에서 문자열을 분할하고 토큰 압축을 원하는 경우 구분 기호를 지정하지 않고 &lt;code&gt;splitter&lt;/code&gt; 를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="05b6ffe797342cf0d1028469f63301e251d90fab" translate="yes" xml:space="preserve">
          <source>If splitting of data transfer is enabled this callback is called after download of an individual chunk finished. Note! After this callback was set then it have to be called FOR ALL chunks. Even if downloading of this chunk was skipped in CHUNK_BGN_FUNC. This is the reason why we don't need &quot;transfer_info&quot; parameter in this callback and we are not interested in &quot;remains&quot; parameter too.</source>
          <target state="translated">데이터 전송 분할이 활성화 된 경우 개별 청크 다운로드가 완료된 후이 콜백이 호출됩니다. 노트! 이 콜백이 설정되면 FOR ALL 청크를 호출해야합니다. CHUNK_BGN_FUNC에서이 청크 다운로드를 건너 뛰어도 마찬가지입니다. 이것이이 콜백에 &quot;transfer_info&quot;매개 변수가 필요하지 않은 이유이며 &quot;remains&quot;매개 변수에도 관심이 없습니다.</target>
        </trans-unit>
        <trans-unit id="42671fc7da4232343c7b0b928fc5d03d90a644e7" translate="yes" xml:space="preserve">
          <source>If statements provide simple conditional execution of statements.</source>
          <target state="translated">명령문이 간단한 조건부 명령문 실행을 제공하는 경우</target>
        </trans-unit>
        <trans-unit id="9c00c0869eed3767fe39aeae02ecce87d06c6f2e" translate="yes" xml:space="preserve">
          <source>If struct constructor is annotated with &lt;code&gt;@disable&lt;/code&gt; and has an empty &lt;a href=&quot;function#ParameterList&quot;&gt;&lt;i&gt;ParameterList&lt;/i&gt;&lt;/a&gt;, the struct has disabled default construction. The only way it can be constructed is via a call to another constructor with a non-empty</source>
          <target state="translated">구조체 생성자에 &lt;code&gt;@disable&lt;/code&gt; 로 주석이 달고 비어있는 &lt;a href=&quot;function#ParameterList&quot;&gt;&lt;i&gt;ParameterList&lt;/i&gt;&lt;/a&gt; 가 있으면 구조체가 기본 생성을 비활성화 한 것입니다. 그것을 만들 수있는 유일한 방법은 비어 있지 않은 다른 생성자를 호출하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="944569416617efaa7082cf853e519ff0670f8407" translate="yes" xml:space="preserve">
          <source>If struct invariant checking is turned on, the struct invariant is called at the end of the constructor.</source>
          <target state="translated">구조체 불변 검사가 켜져 있으면 생성자 끝에서 구조체 불변이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="d7768f4c2da4924ba7acf617ca9aea18a8c9c30c" translate="yes" xml:space="preserve">
          <source>If structs declare an &lt;code&gt;opCmp&lt;/code&gt; member function, it should have the following form:</source>
          <target state="translated">구조체가 &lt;code&gt;opCmp&lt;/code&gt; 멤버 함수를 선언 하면 다음과 같은 형식이어야합니다.</target>
        </trans-unit>
        <trans-unit id="3992d8b7bb5105984cffe3cb78e47194ffe3ff8f" translate="yes" xml:space="preserve">
          <source>If structs declare an &lt;code&gt;opEquals&lt;/code&gt; member function for the identity comparison, it could have several forms, such as:</source>
          <target state="translated">구조체 가 아이덴티티 비교를 위해 &lt;code&gt;opEquals&lt;/code&gt; 멤버 함수를 선언하면 다음과 같은 여러 형식이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a998ede0b415c72a4f5c3800b4d3a122980f04c1" translate="yes" xml:space="preserve">
          <source>If such a match occurs, the inout is considered the common qualifier of the matched qualifiers. If more than two parameters exist, the common qualifier calculation is recursively applied.</source>
          <target state="translated">이러한 일치가 발생하면 입력은 일치 된 한정자의 공통 한정자로 간주됩니다. 둘 이상의 매개 변수가 존재하면 공통 규정 자 계산이 반복적으로 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="b30b7b06cd1e2f9ae926af9377511bb1cde4d9ab" translate="yes" xml:space="preserve">
          <source>If such an</source>
          <target state="translated">그런 경우</target>
        </trans-unit>
        <trans-unit id="a7624c537a3b1ba34be043fd5ddb463081b0a9fb" translate="yes" xml:space="preserve">
          <source>If template type parameters match the literal expressions on function arguments, the deduced types may consider narrowing conversions of them.</source>
          <target state="translated">템플릿 형식 매개 변수가 함수 인수의 리터럴 식과 일치하면 추론 된 형식의 변환이 좁아 질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d9b7696c9777c3fdef5f5f1690ef14ee23382d9" translate="yes" xml:space="preserve">
          <source>If the</source>
          <target state="translated">만약</target>
        </trans-unit>
        <trans-unit id="47a53d62849ea833a758681edda290d5ad91413e" translate="yes" xml:space="preserve">
          <source>If the .d source file starts with the string &quot;Ddoc&quot; then it is treated as general purpose documentation, not as a D code source file. From immediately after the &quot;Ddoc&quot; string to the end of the file or any &quot;Macros:&quot; section forms the document. No automatic highlighting is done to that text, other than highlighting of D code embedded between lines delineated with --- lines. Only macro processing is done.</source>
          <target state="translated">.d 소스 파일이 &quot;Ddoc&quot;문자열로 시작하면 D 코드 소스 파일이 아니라 범용 문서로 취급됩니다. &quot;Ddoc&quot;문자열 바로 다음부터 파일 끝까지 또는 &quot;Macros :&quot;섹션이 문서를 형성합니다. --- 행으로 구분 된 행 사이에 포함 된 D 코드를 강조 표시하는 것 외에는 해당 텍스트에 대한 자동 강조 표시가 수행되지 않습니다. 매크로 처리 만 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="e8532e48c96c60a7608facfeb4a22eb5b3d9e1d6" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#Condition&quot;&gt;&lt;i&gt;Condition&lt;/i&gt;&lt;/a&gt; is satisfied, then the following</source>
          <target state="translated">는 IF &lt;a href=&quot;#Condition&quot;&gt;&lt;i&gt;조건이&lt;/i&gt;&lt;/a&gt; 만족하고 다음</target>
        </trans-unit>
        <trans-unit id="e2fc51761f652cbfa928ace68e58f12bef9531f7" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#Config.newEnv&quot;&gt;&lt;code&gt;Config.newEnv&lt;/code&gt;&lt;/a&gt; flag is set in &lt;code&gt;config&lt;/code&gt;, the child process will</source>
          <target state="translated">는 IF &lt;a href=&quot;#Config.newEnv&quot;&gt; &lt;code&gt;Config.newEnv&lt;/code&gt; 의&lt;/a&gt; 플래그가 설정됩니다 &lt;code&gt;config&lt;/code&gt; , 자식 프로세스는 것입니다</target>
        </trans-unit>
        <trans-unit id="43745bb1dee3dc73e7455be8ec08aff260e3ec47" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#TemplateArgument&quot;&gt;&lt;i&gt;TemplateArgument&lt;/i&gt;&lt;/a&gt; is one token long, the parentheses can be omitted:</source>
          <target state="translated">는 IF &lt;a href=&quot;#TemplateArgument&quot;&gt;&lt;i&gt;TemplateArgument가&lt;/i&gt;&lt;/a&gt; 긴 하나의 토큰, 괄호는 생략 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="2d0280ee3bb99762171b658bd8c55f327440c8eb" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;class#ParameterList&quot;&gt;&lt;i&gt;ParameterList&lt;/i&gt;&lt;/a&gt; is empty, the struct instance is default initialized.</source>
          <target state="translated">는 IF &lt;a href=&quot;class#ParameterList&quot;&gt;&lt;i&gt;parameterList에이&lt;/i&gt;&lt;/a&gt; 비어 구조체 인스턴스는 기본적으로 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="91aa0bb3a56c8d252e49de956e4900b6178db3ed" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;function#ParameterList&quot;&gt;&lt;i&gt;ParameterList&lt;/i&gt;&lt;/a&gt; is empty, the struct instance is default initialized.</source>
          <target state="translated">는 IF &lt;a href=&quot;function#ParameterList&quot;&gt;&lt;i&gt;parameterList에이&lt;/i&gt;&lt;/a&gt; 비어 구조체 인스턴스는 기본적으로 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="2d70e00070ad7d208c2b59d3486718a575bd6f03" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;BitmappedBlock&lt;/code&gt; object is empty (has no active allocation), allocates all memory within and returns a slice to it. Otherwise, returns &lt;code&gt;null&lt;/code&gt; (i.e. no attempt is made to allocate the largest available block).</source>
          <target state="translated">는 IF &lt;code&gt;BitmappedBlock&lt;/code&gt; 의 객체 (활성 할당이 없습니다) 비어 내의 모든 메모리를 할당하고 여기에 조각을 반환합니다. 그렇지 않으면 &lt;code&gt;null&lt;/code&gt; 을 반환합니다 (즉 , 사용 가능한 가장 큰 블록을 할당하려고 시도하지 않음).</target>
        </trans-unit>
        <trans-unit id="f5b1d7f6d0725050ed31d8d5e2a2f42a77b9308e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;FileLogger&lt;/code&gt; is managing the &lt;code&gt;File&lt;/code&gt; it logs to, this method will return a reference to this File.</source>
          <target state="translated">는 IF &lt;code&gt;FileLogger&lt;/code&gt; 이 전무되어 &lt;code&gt;File&lt;/code&gt; 이 로그를,이 방법은이 파일에 대한 참조를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e82d2c358fbac5f6db431228cfdc4ab90afaecba" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;FileLogger&lt;/code&gt; was constructed with a filename, this method returns this filename. Otherwise an empty &lt;code&gt;string&lt;/code&gt; is returned.</source>
          <target state="translated">경우 &lt;code&gt;FileLogger&lt;/code&gt; 이 파일 이름으로 구성되었으며,이 방법은이 파일 이름을 반환합니다. 그렇지 않으면 빈 &lt;code&gt;string&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="09e9a0c0fb2463234ac2c4886cea6f7201a979f8" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;SharedBitmappedBlock&lt;/code&gt; object is empty (has no active allocation), allocates all memory within and returns a slice to it. Otherwise, returns &lt;code&gt;null&lt;/code&gt; (i.e. no attempt is made to allocate the largest available block).</source>
          <target state="translated">는 IF &lt;code&gt;SharedBitmappedBlock&lt;/code&gt; 의 객체 (활성 할당이 없습니다) 비어 내의 모든 메모리를 할당하고 여기에 조각을 반환합니다. 그렇지 않으면 &lt;code&gt;null&lt;/code&gt; 을 반환합니다 (즉 , 사용 가능한 가장 큰 블록을 할당하려고 시도하지 않음).</target>
        </trans-unit>
        <trans-unit id="a85af50c42d4408aee171ffd99bd37d80c84bfad" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Task&lt;/code&gt; isn't started yet, execute it in the current thread. If it's done, return its return value, if any. If it's in progress, busy spin until it's done, then return the return value. If it threw an exception, rethrow that exception.</source>
          <target state="translated">경우 &lt;code&gt;Task&lt;/code&gt; 아직 시작되지 않고, 현재의 thread를 실행합니다. 완료되면 리턴 값을 리턴하십시오 (있는 경우). 진행 중이면 완료 될 때까지 사용 중 회전 한 다음 반환 값을 반환합니다. 예외가 발생하면 해당 예외를 다시 발생 시키십시오.</target>
        </trans-unit>
        <trans-unit id="1bd6a82f193fead01ba830becd3c29303a62f4f9" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Task&lt;/code&gt; isn't started yet, execute it in the current thread. If it's done, return its return value, if any. If it's in progress, wait on a condition variable. If it threw an exception, rethrow that exception.</source>
          <target state="translated">경우 &lt;code&gt;Task&lt;/code&gt; 아직 시작되지 않고, 현재의 thread를 실행합니다. 완료되면 리턴 값을 리턴하십시오 (있는 경우). 진행중인 경우 조건 변수를 기다립니다. 예외가 발생하면 해당 예외를 다시 발생 시키십시오.</target>
        </trans-unit>
        <trans-unit id="9e212700918e7fcce26dacfc8ea0fc78cc9f1eec" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;VariantN&lt;/code&gt; contains an (associative) array, returns the length of that array. Otherwise, throws an exception.</source>
          <target state="translated">&lt;code&gt;VariantN&lt;/code&gt; 에 (연관) 배열이 포함 된 경우 해당 배열의 길이를 반환합니다. 그렇지 않으면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="aaf923f5ee1964878af77ace59cc74c4aeed3ea4" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;VariantN&lt;/code&gt; contains an array, applies &lt;code&gt;dg&lt;/code&gt; to each element of the array in turn. Otherwise, throws an exception.</source>
          <target state="translated">경우] &lt;code&gt;VariantN&lt;/code&gt; 이 배열을 포함 적용 &lt;code&gt;dg&lt;/code&gt; 차례로 배열의 각 요소에 관한 것이다. 그렇지 않으면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8cc269de3091c4d2c19acd44245d56ff558f7c59" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;VariantN&lt;/code&gt; object holds a value of the</source>
          <target state="translated">는 IF &lt;code&gt;VariantN&lt;/code&gt; 의 객체의 값을 보유</target>
        </trans-unit>
        <trans-unit id="4b1509a50bbf3491d84d8a56c0c8990227dbda5d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;[ ]&lt;/code&gt; form is used, the slice is of the entire array.</source>
          <target state="translated">경우] &lt;code&gt;[ ]&lt;/code&gt; 형태를 사용하는, 슬라이스 전체 배열이다.</target>
        </trans-unit>
        <trans-unit id="5bc0d1d6fc33510ec1a8451afec85b978d105f76" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;format&lt;/code&gt; argument is a string literal, it is verified to be a valid format string per the C99 Standard. If the &lt;code&gt;format&lt;/code&gt; parameter is followed by &lt;code&gt;...&lt;/code&gt;, the number and types of the variadic arguments are checked against the format string.</source>
          <target state="translated">경우 &lt;code&gt;format&lt;/code&gt; 인수가 문자열 리터럴, C99 표준에 따라 유효한 형식 문자열로 확인됩니다. &lt;code&gt;format&lt;/code&gt; 매개 변수 뒤에 &lt;code&gt;...&lt;/code&gt; 가 있으면 가변 인수의 수와 유형이 형식 문자열에 대해 확인됩니다.</target>
        </trans-unit>
        <trans-unit id="cc574f8cb39cc53c71da6e74a5ec0da4813bcc04" translate="yes" xml:space="preserve">
          <source>If the CURLOPT_INFILE is used, this can be used to inform libcurl about how large the file being sent really is. That allows better error checking and better verifies that the upload was successful. -1 means unknown size.</source>
          <target state="translated">CURLOPT_INFILE을 사용하는 경우, 전송되는 파일의 실제 크기를 libcurl에 알리는 데 사용할 수 있습니다. 이를 통해 더 나은 오류 검사가 가능하고 업로드가 성공했는지 더 잘 확인할 수 있습니다. -1은 알 수없는 크기를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="05e890b0ac7f150cc9383bbef3319acbe1eb47b0" translate="yes" xml:space="preserve">
          <source>If the UDA is a type, then any UDAs of the same type on the symbol will match. If the UDA is a template for a type, then any UDA which is an instantiation of that template will match. And if the UDA is a value, then any UDAs on the symbol which are equal to that value will match.</source>
          <target state="translated">UDA가 유형 인 경우 기호에서 동일한 유형의 UDA가 일치합니다. UDA가 유형의 템플리트 인 경우 해당 템플리트의 인스턴스화 인 UDA가 일치합니다. UDA가 값이면 해당 값과 같은 기호의 UDA가 일치합니다.</target>
        </trans-unit>
        <trans-unit id="d6829c7076e9b081aaeb04fb4efe46caee211bea" translate="yes" xml:space="preserve">
          <source>If the [EBP] is omitted, it is assumed for local variables. If &lt;code&gt;naked&lt;/code&gt; is used, this no longer holds.</source>
          <target state="translated">[EBP]를 생략하면 지역 변수로 간주됩니다. 경우 &lt;code&gt;naked&lt;/code&gt; 사용이 더 이상 보유하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1517a4666732a9b97017b3d1661df1ab091b7335" translate="yes" xml:space="preserve">
          <source>If the aggregate expression is a sequence, there can be one or two iteration symbols declared. If one, then the symbol is an</source>
          <target state="translated">집계 표현식이 시퀀스 인 경우 하나 또는 두 개의 반복 기호가 선언 될 수 있습니다. 하나 인 경우 기호는</target>
        </trans-unit>
        <trans-unit id="d74660278291ee85d1999a22558014f3ea28fb7a" translate="yes" xml:space="preserve">
          <source>If the aggregate expression is a static or dynamic array of &lt;code&gt;char&lt;/code&gt;s, &lt;code&gt;wchar&lt;/code&gt;s, or &lt;code&gt;dchar&lt;/code&gt;s, then the</source>
          <target state="translated">집계 표현식이 &lt;code&gt;char&lt;/code&gt; , &lt;code&gt;wchar&lt;/code&gt; 또는 &lt;code&gt;dchar&lt;/code&gt; 의 정적 또는 동적 배열 인 경우</target>
        </trans-unit>
        <trans-unit id="cbeacb125fa68a379271d564591b63d8e90e22ef" translate="yes" xml:space="preserve">
          <source>If the aggregate expression is a struct or class object, but the &lt;code&gt;opApply&lt;/code&gt; for &lt;code&gt;foreach&lt;/code&gt;, or &lt;code&gt;opApplyReverse&lt;/code&gt;&lt;code&gt;foreach_reverse&lt;/code&gt; do not exist, then iteration over struct and class objects can be done with range primitives. For &lt;code&gt;foreach&lt;/code&gt;, this means the following properties and methods must be defined:</source>
          <target state="translated">집계 식 구조체 또는 클래스 객체이지만, 경우 &lt;code&gt;opApply&lt;/code&gt; 에 대한 &lt;code&gt;foreach&lt;/code&gt; 는 , 또는 &lt;code&gt;opApplyReverse&lt;/code&gt; 이 &lt;code&gt;foreach_reverse&lt;/code&gt; 존재하지 않는, 다음 반복을 통해 구조체와 클래스 개체가 범위 프리미티브 수행 할 수 있습니다. 들어 &lt;code&gt;foreach&lt;/code&gt; 문 이 다음과 같은 속성과 메서드를 정의해야합니다 의미합니다 :</target>
        </trans-unit>
        <trans-unit id="2fc73ce3aaae537f6f799c049d4ae92b1b9bca9f" translate="yes" xml:space="preserve">
          <source>If the aggregate expression is a struct or class object, the &lt;code&gt;foreach&lt;/code&gt; is defined by the special &lt;span id=&quot;opApply&quot;&gt;&lt;code&gt;opApply&lt;/code&gt;&lt;/span&gt; member function, and the &lt;code&gt;foreach_reverse&lt;/code&gt; behavior is defined by the special &lt;span id=&quot;opApplyReverse&quot;&gt;&lt;code&gt;opApplyReverse&lt;/code&gt;&lt;/span&gt; member function. These functions have the type:</source>
          <target state="translated">집계 표현식이 구조체 또는 클래스 객체 인 경우 &lt;code&gt;foreach&lt;/code&gt; 는 특수한 &lt;span id=&quot;opApply&quot;&gt; &lt;code&gt;opApply&lt;/code&gt; &lt;/span&gt; 멤버 함수 로 정의되고 &lt;code&gt;foreach_reverse&lt;/code&gt; 동작은 특수한 &lt;span id=&quot;opApplyReverse&quot;&gt; &lt;code&gt;opApplyReverse&lt;/code&gt; &lt;/span&gt; 멤버 함수로 정의됩니다 . 이러한 기능은 다음과 같은 유형을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="a964bd4ba66b1238ba3df838bc73bf80b6db0380" translate="yes" xml:space="preserve">
          <source>If the aggregate expression is an associative array, there can be one or two variables declared. If one, then the variable is said to be the</source>
          <target state="translated">집계 표현식이 연관 배열 인 경우 하나 또는 두 개의 변수가 선언 될 수 있습니다. 하나 인 경우 변수는</target>
        </trans-unit>
        <trans-unit id="28f986b7b478a6b80712dcbe7082b7d096f58800" translate="yes" xml:space="preserve">
          <source>If the aggregate is a static or dynamic array, there can be one or two variables declared. If one, then the variable is said to be the</source>
          <target state="translated">집계가 정적 또는 동적 배열 인 경우 하나 또는 두 개의 변수가 선언 될 수 있습니다. 하나 인 경우 변수는</target>
        </trans-unit>
        <trans-unit id="dae323352e29801474e63b5dca9b04c0df39a8b3" translate="yes" xml:space="preserve">
          <source>If the argument is a CommaExp, set a flag to prevent deprecation messages</source>
          <target state="translated">인수가 CommaExp 인 경우 사용 중단 메시지가 표시되지 않도록 플래그를 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="fd923c5e6b5ba5db493474258e601c811cb53b07" translate="yes" xml:space="preserve">
          <source>If the argument is omitted, it means default construction of the scalar type:</source>
          <target state="translated">인수가 생략되면 스칼라 유형의 기본 구성을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="c2b4ef88a634d75ab4162e14992b099e340c974e" translate="yes" xml:space="preserve">
          <source>If the arguments are all either types that are abstract classes, or expressions that are typed as abstract classes, then &lt;code&gt;true&lt;/code&gt; is returned. Otherwise, &lt;code&gt;false&lt;/code&gt; is returned. If there are no arguments, &lt;code&gt;false&lt;/code&gt; is returned.</source>
          <target state="translated">인수가 모두 추상 클래스 인 유형이거나 추상 클래스로 입력 된 표현식 인 경우 &lt;code&gt;true&lt;/code&gt; 가 리턴됩니다. 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 가 반환됩니다. 인수가 없으면 &lt;code&gt;false&lt;/code&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="870a7ff26a7a40d5a235f7261d71e7076bce3fa8" translate="yes" xml:space="preserve">
          <source>If the arguments are all either types that are arithmetic types, or expressions that are typed as arithmetic types, then &lt;code&gt;true&lt;/code&gt; is returned. Otherwise, &lt;code&gt;false&lt;/code&gt; is returned. If there are no arguments, &lt;code&gt;false&lt;/code&gt; is returned.</source>
          <target state="translated">인수가 모두 산술 유형 인 유형이거나 산술 유형으로 입력 된 표현식 인 경우 &lt;code&gt;true&lt;/code&gt; 가 리턴됩니다. 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 가 반환됩니다. 인수가 없으면 &lt;code&gt;false&lt;/code&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="c1199d0a51996844d05cb8716b18ac074abdf063" translate="yes" xml:space="preserve">
          <source>If the assigned value type is &lt;b&gt;not&lt;/b&gt; equivalent with the AA element type, the expression could invoke operator overloading with normal indexing access:</source>
          <target state="translated">지정된 값 유형이 AA 요소 유형과 동일 &lt;b&gt;하지 않은&lt;/b&gt; 경우 표현식은 일반 색인 작성 액세스로 연산자 오버로드를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4c8c8da96483d4e6d105c51e4ab4887f9f8b55b" translate="yes" xml:space="preserve">
          <source>If the assigned value type is equivalent with the AA element type:</source>
          <target state="translated">지정된 값 유형이 AA 요소 유형과 동일한 경우 :</target>
        </trans-unit>
        <trans-unit id="39dbd0d9fed3f956fc2681e5931d3927843d2a46" translate="yes" xml:space="preserve">
          <source>If the bounds check in &lt;code&gt;@system&lt;/code&gt; or &lt;code&gt;@trusted&lt;/code&gt; code is disabled, the code correctness must still be guaranteed by the code author.</source>
          <target state="translated">&lt;code&gt;@system&lt;/code&gt; 또는 &lt;code&gt;@trusted&lt;/code&gt; 코드 에서 범위 검사를 사용하지 않으면 코드 작성자가 코드 정확성을 보장해야합니다.</target>
        </trans-unit>
        <trans-unit id="cc1e679f124dc90842ff4979e66ede34a74890c6" translate="yes" xml:space="preserve">
          <source>If the callback doesn't take any arguments, the callback is invoked whenever the option is seen.</source>
          <target state="translated">콜백이 인수를 취하지 않으면 옵션이 표시 될 때마다 콜백이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="3289fcddad88ae1df9d116fd88b6c6dc79afe870" translate="yes" xml:space="preserve">
          <source>If the callback takes one string argument, the option string (without the leading dash(es)) is passed to the callback. After that, the option string is considered handled and removed from the options array.</source>
          <target state="translated">콜백에 하나의 문자열 인수가 있으면 옵션 문자열 (앞의 대시없이)이 콜백으로 전달됩니다. 그 후, 옵션 문자열은 처리 된 것으로 간주되고 옵션 배열에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="dad4f3623ab08f61a1b3d8228c7e7a46ecb84bd7" translate="yes" xml:space="preserve">
          <source>If the callback takes two string arguments, the option string is handled as an option with one argument, and parsed accordingly. The option and its value are passed to the callback. After that, whatever was passed to the callback is considered handled and removed from the list.</source>
          <target state="translated">콜백에 두 개의 문자열 인수가 사용되면 옵션 문자열이 하나의 인수로 옵션으로 처리되고 그에 따라 구문 분석됩니다. 옵션과 해당 값이 콜백으로 전달됩니다. 그 후, 콜백으로 전달 된 것은 처리되고 목록에서 제거 된 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="8d6fa53ba31aeabc61edb3bbeab4d2e35828294c" translate="yes" xml:space="preserve">
          <source>If the caller is a Fiber and is not a Generator, this function will call scheduler.yield() or Fiber.yield(), as appropriate.</source>
          <target state="translated">호출자가 파이버이고 생성자가 아닌 경우이 함수는 적절하게 scheduler.yield () 또는 Fiber.yield ()를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="7fba3a81af609825439d1523a354f0ef5c6b4ecb" translate="yes" xml:space="preserve">
          <source>If the caller is a scheduled Fiber, this yields execution to another scheduled Fiber.</source>
          <target state="translated">호출자가 예약 된 파이버 인 경우 다른 예약 된 파이버를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="682966fbc9a5573324e201e13b7ba309d84a4edb" translate="yes" xml:space="preserve">
          <source>If the capacity is increased, one should assume that all iterators to the elements are invalidated.</source>
          <target state="translated">용량이 증가하면 요소에 대한 모든 반복자가 무효화된다고 가정해야합니다.</target>
        </trans-unit>
        <trans-unit id="881b45b7bdf985b220e8cd0369c0c1827fe806d8" translate="yes" xml:space="preserve">
          <source>If the chunk of memory managed is large, it may be desirable to switch management to free list from the beginning. That way, memory may be used in a more compact manner than region mode. To force free list mode, call &lt;code&gt;switchToFreeList&lt;/code&gt; shortly after construction or when deemed appropriate.</source>
          <target state="translated">관리되는 메모리 청크가 큰 경우 관리를 처음부터 사용 가능 목록으로 전환하는 것이 바람직 할 수 있습니다. 이러한 방식으로, 메모리는 영역 모드보다 더 컴팩트 한 방식으로 사용될 수있다. 사용 가능리스트 모드를 강제 실행하려면 &lt;code&gt;switchToFreeList&lt;/code&gt; 직후 또는 적절하다고 간주되는 경우 switchToFreeList를 호출 하십시오 .</target>
        </trans-unit>
        <trans-unit id="9ac8dd371ddada3a7fc0d5f27220ac56194a508b" translate="yes" xml:space="preserve">
          <source>If the connection proceeds too quickly then need to slow it down</source>
          <target state="translated">연결이 너무 빨리 진행되면 속도를 늦춰야합니다</target>
        </trans-unit>
        <trans-unit id="a0e6b5ba02714528b40c08b339b490154681d034" translate="yes" xml:space="preserve">
          <source>If the constructor can create a unique object (e.g. if it is &lt;code&gt;pure&lt;/code&gt;), the object can be implicitly convertible to any qualifiers.</source>
          <target state="translated">생성자가 고유 한 객체를 생성 할 수있는 경우 (예 : &lt;code&gt;pure&lt;/code&gt; 객체) 객체를 한정자로 암시 적으로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf0cf6c28f3156b6b4f9788d5978b63c0c05e84c" translate="yes" xml:space="preserve">
          <source>If the constructor can create a unique object (i.e. if it is &lt;code&gt;pure&lt;/code&gt;), the object is implicitly convertible to any qualifiers.</source>
          <target state="translated">생성자가 고유 한 객체를 생성 할 수있는 경우 (즉 , &lt;code&gt;pure&lt;/code&gt; ) 객체는 암시 적으로 모든 한정자로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="52c26c14a7e4c3281fb4736e2032dbcd78185dac" translate="yes" xml:space="preserve">
          <source>If the current count is equal to zero, return. Otherwise, atomically decrement the count by one and return true.</source>
          <target state="translated">현재 카운트가 0과 같으면 반환합니다. 그렇지 않으면, 원자 적으로 카운트를 1 씩 감소시키고 true를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="50c1fec6baa7c97f9c101593b09fc41307d590d7" translate="yes" xml:space="preserve">
          <source>If the declaration is disabled but inside a disabled function, returns &lt;code&gt;true&lt;/code&gt; but do not issue an error message.</source>
          <target state="translated">선언이 비활성화되었지만 비활성화 된 함수 내에 있으면 &lt;code&gt;true&lt;/code&gt; 를 반환 하지만 오류 메시지는 표시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="553971eeba92d7bd581f90194d8554493054062d" translate="yes" xml:space="preserve">
          <source>If the default value for a parameter is given, all following parameters must also have default values.</source>
          <target state="translated">매개 변수의 기본값이 제공되면 다음의 모든 매개 변수에도 기본값이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="aefb0c84385cb6665755448be70c3bf176cad1d9" translate="yes" xml:space="preserve">
          <source>If the delimiter is an identifier, the identifier must be immediately followed by a newline, and the matching delimiter is the same identifier starting at the beginning of the line:</source>
          <target state="translated">분리 문자가 식별자 인 경우 식별자 바로 뒤에 개행 문자가 와야하며 일치하는 분리 문자는 행의 시작 부분에서 시작하는 동일한 식별자입니다.</target>
        </trans-unit>
        <trans-unit id="76a3cf7d70aa80e5130f9aadda4aeef632729f66" translate="yes" xml:space="preserve">
          <source>If the delimiter is an identifier, the identifier must be immediately followed by a newline, and the matching delimiter must be the same identifier starting at the beginning of the line:</source>
          <target state="translated">구분자가 식별자 인 경우 식별자 바로 뒤에 줄 바꿈이 와야하며 일치하는 구분 기호는 줄의 시작 부분에서 시작하는 동일한 식별자 여야합니다.</target>
        </trans-unit>
        <trans-unit id="367e2c9e3e9e32edd1905a00926130379051ac02" translate="yes" xml:space="preserve">
          <source>If the documentation of a member function of a container takes a parameter of type &lt;code&gt;Range&lt;/code&gt;, then it refers to the primary range type of this container. Oftentimes &lt;code&gt;Take!Range&lt;/code&gt; will be used, in which case the range refers to a span of the elements in the container. Arguments to these parameters &lt;b&gt;must&lt;/b&gt; be obtained from the same container instance as the one being worked with. It is important to note that many generic range algorithms return the same range type as their input range.</source>
          <target state="translated">컨테이너의 멤버 함수에 대한 문서가 &lt;code&gt;Range&lt;/code&gt; 유형의 매개 변수 를 사용하는 경우이 컨테이너의 기본 범위 유형을 참조합니다. 종종 &lt;code&gt;Take!Range&lt;/code&gt; 가 사용되며,이 경우 범위는 컨테이너에있는 요소의 범위를 나타냅니다. 이러한 매개 변수에 인수 &lt;b&gt;해야한다&lt;/b&gt; 하나 개의 존재가 함께 일 같은 컨테이너 인스턴스에서 얻을 수. 많은 일반 범위 알고리즘은 입력 범위와 동일한 범위 유형을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="568a7fe362541b12ed21809dd85fad3122bbc2f4" translate="yes" xml:space="preserve">
          <source>If the download receives less than &quot;low speed limit&quot; bytes/second during &quot;low speed time&quot; seconds, the operations is aborted. You could i.e if you have a pretty high speed connection, abort if it is less than 2000 bytes/sec during 20 seconds.</source>
          <target state="translated">&quot;저속 시간&quot;초 동안 다운로드가 &quot;저속 한계&quot;바이트 / 초 미만을 수신하면 작업이 중단됩니다. 예를 들어 초고속 연결이있는 경우 20 초 동안 2000 바이트 / 초 미만이면 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="3a1f560a07b490771cc9fc4811b46461cd585b36" translate="yes" xml:space="preserve">
          <source>If the email address is valid or not.</source>
          <target state="translated">이메일 주소가 유효한지 아닌지.</target>
        </trans-unit>
        <trans-unit id="4f3a54e2dd01849ed176b274b08fe7067255fdd1" translate="yes" xml:space="preserve">
          <source>If the enum</source>
          <target state="translated">열거 형의 경우</target>
        </trans-unit>
        <trans-unit id="c1aaeeb72f410c4e6aff61a784ecba88ce60daf3" translate="yes" xml:space="preserve">
          <source>If the expression evaluates to false the functions are never inlined, otherwise they are always inlined.</source>
          <target state="translated">표현식이 false로 평가되면 함수가 인라인되지 않고 그렇지 않으면 항상 인라인됩니다.</target>
        </trans-unit>
        <trans-unit id="657b7adb8cca95e26ff1d78ccaa8357b99612950" translate="yes" xml:space="preserve">
          <source>If the expression is a &lt;a href=&quot;function#property-functions&quot;&gt; Property Function&lt;/a&gt;, &lt;code&gt;typeof&lt;/code&gt; gives its return type.</source>
          <target state="translated">표현식이 &lt;a href=&quot;function#property-functions&quot;&gt;특성 함수 인&lt;/a&gt; 경우 &lt;code&gt;typeof&lt;/code&gt; 는 리턴 유형을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="bbff4334fd247c00a1664b1a8294a75098385c7e" translate="yes" xml:space="preserve">
          <source>If the extended unittest handler is registered, this function returns the result from that handler directly.</source>
          <target state="translated">확장 단위 테스트 핸들러가 등록 된 경우이 함수는 해당 핸들러의 결과를 직접 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="638ef19a4eda5122a3e4b7247816dfcd0c978607" translate="yes" xml:space="preserve">
          <source>If the extension is empty, this function is equivalent to &lt;a href=&quot;#stripExtension&quot;&gt;&lt;code&gt;stripExtension&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">확장명이 비어 있으면이 함수는 &lt;a href=&quot;#stripExtension&quot;&gt; &lt;code&gt;stripExtension&lt;/code&gt; &lt;/a&gt; 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="7ef335ccbfb3536483e3c42f2775a824af19d172" translate="yes" xml:space="preserve">
          <source>If the field is initialized on one path, it must be initialized on all paths.</source>
          <target state="translated">필드가 한 경로에서 초기화되면 모든 경로에서 초기화되어야합니다.</target>
        </trans-unit>
        <trans-unit id="837d5b133d0941d97e1586686594739710856b45" translate="yes" xml:space="preserve">
          <source>If the field type has an &lt;a href=&quot;operatoroverloading#assignment&quot;&gt;&lt;code&gt;opAssign&lt;/code&gt;&lt;/a&gt; method, it will not be used for initialization.</source>
          <target state="translated">필드 유형에 &lt;a href=&quot;operatoroverloading#assignment&quot;&gt; &lt;code&gt;opAssign&lt;/code&gt; &lt;/a&gt; 메소드 가 있으면 초기화에 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ced70cd3f9cbddd52606f9834678b1724238171b" translate="yes" xml:space="preserve">
          <source>If the field type is not mutable, multiple initialization will be rejected.</source>
          <target state="translated">필드 유형을 변경할 수없는 경우 여러 초기화가 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="03c48cf052ea3dedbdf6ccc3c7e899b230bc6471" translate="yes" xml:space="preserve">
          <source>If the file is not opened, returns &lt;code&gt;true&lt;/code&gt;. Otherwise, returns &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/ferror.html&quot;&gt;ferror&lt;/a&gt; for the file handle.</source>
          <target state="translated">파일이 열리지 않으면 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 . 그렇지 않으면 파일 핸들에 대한 &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/ferror.html&quot;&gt;ferror&lt;/a&gt; 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="8450d7a55bd53dbebae5b57df534f9be1005db67" translate="yes" xml:space="preserve">
          <source>If the file is not opened, succeeds vacuously. Otherwise, returns &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/clearerr.html&quot;&gt;clearerr&lt;/a&gt; for the file handle.</source>
          <target state="translated">파일이 열리지 않으면 애매하게 성공합니다. 그렇지 않으면 파일 핸들에 대해 &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/clearerr.html&quot;&gt;clearerr&lt;/a&gt; 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="094342c021e1489a63abd256ccc39489b9dd3b66" translate="yes" xml:space="preserve">
          <source>If the file name of a module is an invalid module name (e.g. &lt;code&gt;foo-bar.d&lt;/code&gt;), you may use a module declaration to set a valid module name:</source>
          <target state="translated">모듈의 파일 이름이 잘못된 모듈 이름 (예 : &lt;code&gt;foo-bar.d&lt;/code&gt; ) 인 경우 모듈 선언을 사용하여 유효한 모듈 이름을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="af6d8edab76ddfaae7837345a33fd73f250c8a9f" translate="yes" xml:space="preserve">
          <source>If the file was unopened, succeeds vacuously. Otherwise closes the file (by calling &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/fclose.html&quot;&gt;fclose&lt;/a&gt;), throwing on error. Even if an exception is thrown, afterwards the &lt;code&gt;File&lt;/code&gt; object is empty. This is different from &lt;code&gt;detach&lt;/code&gt; in that it always closes the file; consequently, all other &lt;code&gt;File&lt;/code&gt; objects referring to the same handle will see a closed file henceforth.</source>
          <target state="translated">파일이 열리지 않으면 애매하게 성공합니다. 그렇지 않으면 ( &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/fclose.html&quot;&gt;fclose&lt;/a&gt; 호출하여) 파일을 닫고 오류가 발생합니다. 예외가 발생하더라도 나중에 &lt;code&gt;File&lt;/code&gt; 객체는 비어 있습니다. 이것은 항상 파일을 닫는다는 점 에서 &lt;code&gt;detach&lt;/code&gt; 과 다릅니다 . 결과적으로 동일한 핸들을 참조하는 다른 모든 &lt;code&gt;File&lt;/code&gt; 객체는 닫힌 파일을 보게됩니다.</target>
        </trans-unit>
        <trans-unit id="527ef94b697e67dac9fb104fb0ef24982a4b2044" translate="yes" xml:space="preserve">
          <source>If the filename already has an extension, it is replaced. If not, the extension is simply appended to the filename. Including a leading dot in &lt;code&gt;ext&lt;/code&gt; is optional.</source>
          <target state="translated">파일 이름에 이미 확장자가 있으면 대체됩니다. 그렇지 않은 경우 확장명은 단순히 파일 이름에 추가됩니다. &lt;code&gt;ext&lt;/code&gt; 에 선행 점을 포함시키는 것은 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="9ba4ff05c5a39476e966f563ceda94938de67867" translate="yes" xml:space="preserve">
          <source>If the first</source>
          <target state="translated">처음이라면</target>
        </trans-unit>
        <trans-unit id="fdc87c8a8b7093e7a7ff0e6b20593048b93bffda" translate="yes" xml:space="preserve">
          <source>If the first line starts with &quot;#!&quot;, then that line is ignored.</source>
          <target state="translated">첫 번째 줄이 &quot;#!&quot;로 시작하면 해당 줄은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="0759e4efe42fd76d83650d76ffb9cbdc81cfccae" translate="yes" xml:space="preserve">
          <source>If the first lookup isn't successful, a second one is performed on imports. In the second lookup phase inherited scopes are ignored. This includes the scope of base classes and interfaces (in this example, &lt;code&gt;BaseClass&lt;/code&gt;'s imports would be ignored), as well as imports in mixed-in &lt;code&gt;template&lt;/code&gt;.</source>
          <target state="translated">첫 번째 조회가 성공하지 못하면 두 번째 조회가 가져 오기에서 수행됩니다. 두 번째 조회 단계에서는 상속 된 범위가 무시됩니다. 여기에는 기본 클래스 및 인터페이스의 범위 (이 예에서는 &lt;code&gt;BaseClass&lt;/code&gt; 의 가져 오기가 무시 됨)와 혼합 &lt;code&gt;template&lt;/code&gt; 가져 오기가 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="f743b99432834f349face5005529142050d8a895" translate="yes" xml:space="preserve">
          <source>If the first lookup wasn't successful, a second one is performed on imports. In the second lookup phase inherited scopes are ignored. This includes scope of base classes and interface (in this example, &lt;code&gt;BaseClass&lt;/code&gt;'s imports would be ignored), as well as imports in mixed-in &lt;code&gt;template&lt;/code&gt;.</source>
          <target state="translated">첫 번째 조회가 실패한 경우 가져 오기에서 두 번째 조회가 수행됩니다. 두 번째 조회 단계에서는 상속 된 범위가 무시됩니다. 여기에는 기본 클래스 및 인터페이스의 범위 (이 예제에서는 &lt;code&gt;BaseClass&lt;/code&gt; 의 가져 오기는 무시 됨)와 혼합 &lt;code&gt;template&lt;/code&gt; 가져 오기가 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="4653edc731431a9f55f3a9c2f7b1ee0500507aaf" translate="yes" xml:space="preserve">
          <source>If the floating-point rounding mode is changed within a function, it must be restored before the function exits. If this rule is violated (for example, by the use of inline asm), the rounding mode used for subsequent calculations is undefined.</source>
          <target state="translated">함수 내에서 부동 소수점 반올림 모드가 변경되면 함수가 종료되기 전에 복원해야합니다. 이 규칙을 위반하면 (예 : 인라인 asm 사용) 후속 계산에 사용되는 반올림 모드가 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="06665db726ed2b3db8e693b6a8e9e8220aa3c936" translate="yes" xml:space="preserve">
          <source>If the format string is fixed, passing it as a template parameter checks the type correctness of the parameters at compile-time. This also can result in better performance.</source>
          <target state="translated">형식 문자열이 고정 된 경우이를 템플리트 매개 변수로 전달하면 컴파일시 매개 변수의 유형 정확성을 검사합니다. 또한 성능이 향상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f41ef8f8cc465c8df198d14584ea0805a3861563" translate="yes" xml:space="preserve">
          <source>If the fractional part of x is exactly 0.5, the return value is rounded away from zero.</source>
          <target state="translated">x의 소수 부분이 정확히 0.5이면 반환 값은 0에서 반올림됩니다.</target>
        </trans-unit>
        <trans-unit id="6a44050dca10920a151c58d6983c48f0ef88a105" translate="yes" xml:space="preserve">
          <source>If the function is passed in string form, the state has name &lt;code&gt;&quot;a&quot;&lt;/code&gt; and the zero-based index in the recurrence has name &lt;code&gt;&quot;n&quot;&lt;/code&gt;. The given string must return the desired value for &lt;code&gt;a[n]&lt;/code&gt; given &lt;code&gt;a[n - 1]&lt;/code&gt;, &lt;code&gt;a[n - 2]&lt;/code&gt;, &lt;code&gt;a[n - 3]&lt;/code&gt;,..., &lt;code&gt;a[n - stateSize]&lt;/code&gt;. The state size is dictated by the number of arguments passed to the call to &lt;code&gt;recurrence&lt;/code&gt;. The &lt;code&gt;Recurrence&lt;/code&gt; struct itself takes care of managing the recurrence's state and shifting it appropriately.</source>
          <target state="translated">함수가 문자열 형식으로 전달되면 상태의 이름은 &lt;code&gt;&quot;a&quot;&lt;/code&gt; 이고 반복의 0부터 시작하는 인덱스의 이름은 &lt;code&gt;&quot;n&quot;&lt;/code&gt; 입니다. 주어진 문자열에 대해 원하는 값을 반환해야 &lt;code&gt;a[n]&lt;/code&gt; 소정 &lt;code&gt;a[n - 1]&lt;/code&gt; , &lt;code&gt;a[n - 2]&lt;/code&gt; , &lt;code&gt;a[n - 3]&lt;/code&gt; , ..., &lt;code&gt;a[n - stateSize]&lt;/code&gt; . 상태 크기는 &lt;code&gt;recurrence&lt;/code&gt; 호출에 전달 된 인수 수에 의해 결정됩니다 . &lt;code&gt;Recurrence&lt;/code&gt; 자체가 재발의 상태를 관리하고 적절하게 이동을 담당 구조체.</target>
        </trans-unit>
        <trans-unit id="3c67c2406f3c735811702f591ea611c2970cdc93" translate="yes" xml:space="preserve">
          <source>If the function returns &lt;code&gt;void&lt;/code&gt;, and the first parameter is &lt;code&gt;ref&lt;/code&gt; or &lt;code&gt;out&lt;/code&gt;, then all subsequent &lt;code&gt;return ref&lt;/code&gt; parameters are considered as being assigned to the first parameter for lifetime checking. The &lt;code&gt;this&lt;/code&gt; reference parameter to a struct non-static member function is considered the first parameter.</source>
          <target state="translated">함수가 &lt;code&gt;void&lt;/code&gt; 를 리턴 하고 첫 번째 매개 변수가 &lt;code&gt;ref&lt;/code&gt; 또는 &lt;code&gt;out&lt;/code&gt; 이면, 모든 후속 &lt;code&gt;return ref&lt;/code&gt; 매개 변수는 수명 점검을 위해 첫 번째 매개 변수에 지정된 것으로 간주됩니다. 구조체 비 정적 멤버 함수에 대한 &lt;code&gt;this&lt;/code&gt; 참조 매개 변수는 첫 번째 매개 변수로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="e2f91af04048a7f2df150e8629c6506bcf13c494" translate="yes" xml:space="preserve">
          <source>If the generated copy constructor fails to type check, it will receive the &lt;code&gt;@disable&lt;/code&gt; attribute.</source>
          <target state="translated">생성 된 사본 생성자가 유형 점검에 실패하면 &lt;code&gt;@disable&lt;/code&gt; 속성 을 수신 합니다.</target>
        </trans-unit>
        <trans-unit id="8b1f1e5a2ec324dd58e7c90d671571002b1fff9a" translate="yes" xml:space="preserve">
          <source>If the generated time point is ever passed the edge of the range in the proper direction, then the edge of that range will be used instead. So, if iterating forward, and the generated time point is past the interval's &lt;code&gt;end&lt;/code&gt;, then &lt;code&gt;front&lt;/code&gt; becomes &lt;code&gt;end&lt;/code&gt;. If iterating backwards, and the generated time point is before &lt;code&gt;begin&lt;/code&gt;, then &lt;code&gt;front&lt;/code&gt; becomes &lt;code&gt;begin&lt;/code&gt;. In either case, the range would then be empty.</source>
          <target state="translated">생성 된 시점이 범위의 가장자리를 올바른 방향으로 통과하면 해당 범위의 가장자리가 대신 사용됩니다. 앞으로 반복하고, 생성 된 시점이 간격의 지났다면, &lt;code&gt;end&lt;/code&gt; 후 &lt;code&gt;front&lt;/code&gt; 된다 &lt;code&gt;end&lt;/code&gt; . 뒤로 반복하고 생성 된 시점이 &lt;code&gt;begin&lt;/code&gt; 하기 전 이면 &lt;code&gt;front&lt;/code&gt; 가 &lt;code&gt;begin&lt;/code&gt; . 두 경우 모두 범위가 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="f99397fa61eb34180bac28883c2e71092de6779b" translate="yes" xml:space="preserve">
          <source>If the given file is a symbolic link, then this returns the attributes of the symbolic link itself rather than file that it points to. If the given file is</source>
          <target state="translated">주어진 파일이 심볼릭 링크 인 경우 파일이 아닌 심볼릭 링크 자체의 속성을 반환합니다. 주어진 파일이</target>
        </trans-unit>
        <trans-unit id="a8dd80adc35b72f7e72590ec9517794124fe146d" translate="yes" xml:space="preserve">
          <source>If the given header contains columns not found in the input they will be ignored.</source>
          <target state="translated">주어진 헤더에 입력에서 찾을 수없는 열이 포함되어 있으면 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="6c1edb4f30ef72dc654568216fa979bf98fad63c" translate="yes" xml:space="preserve">
          <source>If the given header does not match the order in the input, the content will return as it is found in the input.</source>
          <target state="translated">주어진 헤더가 입력 순서와 일치하지 않으면 입력에서 찾은 내용이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="02a682f7846fb30dcf203d60bc7b6d3c76c4aec4" translate="yes" xml:space="preserve">
          <source>If the heap has room to grow, inserts &lt;code&gt;value&lt;/code&gt; into the store and returns &lt;code&gt;true&lt;/code&gt;. Otherwise, if &lt;code&gt;less(value, front)&lt;/code&gt;, calls &lt;code&gt;replaceFront(value)&lt;/code&gt; and returns again &lt;code&gt;true&lt;/code&gt;. Otherwise, leaves the heap unaffected and returns &lt;code&gt;false&lt;/code&gt;. This method is useful in scenarios where the smallest &lt;code&gt;k&lt;/code&gt; elements of a set of candidates must be collected.</source>
          <target state="translated">힙에 여유 공간이 있으면 &lt;code&gt;value&lt;/code&gt; 을 저장소에 삽입 하고 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 . 그렇지 않으면 &lt;code&gt;less(value, front)&lt;/code&gt; 경우 &lt;code&gt;replaceFront(value)&lt;/code&gt; 호출 하고 다시 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 . 그렇지 않으면 힙에 영향을 미치지 않고 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 . 이 방법은 후보 집합의 가장 작은 &lt;code&gt;k&lt;/code&gt; 요소를 수집해야하는 시나리오에서 유용 합니다.</target>
        </trans-unit>
        <trans-unit id="44b5028eff915a424d2f05a190933f50e1ca6cdc" translate="yes" xml:space="preserve">
          <source>If the indexing key already exists in the AA, the setting runs normal assignment.</source>
          <target state="translated">AA에 인덱싱 키가 이미 있으면 설정이 정상 할당을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="ed75ab58ae875098848f819360947f45ce239d60" translate="yes" xml:space="preserve">
          <source>If the indexing key does not yet exist in AA, a new AA entry will be allocated, and it will be initialized with the assigned value.</source>
          <target state="translated">인덱싱 키가 AA에 아직 없으면 새 AA 항목이 할당되고 할당 된 값으로 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="e8855e5c687d575ac4df58472c04fb490240846e" translate="yes" xml:space="preserve">
          <source>If the infinite-precision result fits in the result type, return it and do not touch &lt;code&gt;overflow&lt;/code&gt;</source>
          <target state="translated">무한 정밀도 결과가 결과 유형에 맞는 경우 반환하고 &lt;code&gt;overflow&lt;/code&gt; 만지지 마십시오.</target>
        </trans-unit>
        <trans-unit id="4845dcdf1de3a2fc72f78227d54d29b17278e722" translate="yes" xml:space="preserve">
          <source>If the initializer is not present, the immutable can be initialized from the corresponding constructor:</source>
          <target state="translated">이니셜 라이저가 없으면 해당 생성자에서 불변을 초기화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b6a08857ba6ae055c6d0992d75eba874a7e5568d" translate="yes" xml:space="preserve">
          <source>If the input array is already valid, this function returns the original, otherwise it constructs a new array by replacing all illegal sequences with the encoding scheme's replacement sequence.</source>
          <target state="translated">입력 배열이 이미 유효한 경우이 함수는 원본을 반환하고, 그렇지 않으면 모든 잘못된 시퀀스를 인코딩 체계의 교체 시퀀스로 교체하여 새 배열을 구성합니다.</target>
        </trans-unit>
        <trans-unit id="8c989250d06df7a1e7f52d0b71ed6e2b6ea2a097" translate="yes" xml:space="preserve">
          <source>If the input string is already valid, this function returns the original, otherwise it constructs a new string by replacing all illegal code unit sequences with the encoding's replacement character, Invalid sequences will be replaced with the Unicode replacement character (U+FFFD) if the character repertoire contains it, otherwise invalid sequences will be replaced with '?'.</source>
          <target state="translated">입력 문자열이 이미 유효한 경우이 함수는 원본을 반환합니다. 그렇지 않으면 모든 잘못된 코드 단위 시퀀스를 인코딩의 대체 문자로 바꾸어 새 문자열을 생성합니다. 잘못된 문자열은 문자 레퍼토리에 포함되어 있지 않으면 유효하지 않은 시퀀스는 '?'로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="c3178232393693733f89474a2be2c7d87e890b8d" translate="yes" xml:space="preserve">
          <source>If the instance &lt;code&gt;toString&lt;/code&gt; has overridden &lt;code&gt;Object.toString&lt;/code&gt;, it is used.</source>
          <target state="translated">&lt;code&gt;toString&lt;/code&gt; 인스턴스 가 &lt;code&gt;Object.toString&lt;/code&gt; 을 대체 한 경우 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3bbc396d6905590778769668af1612cc2bc09090" translate="yes" xml:space="preserve">
          <source>If the invariant does not hold, then the program enters an invalid state.</source>
          <target state="translated">고정이 유지되지 않으면 프로그램은 유효하지 않은 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="29f830d3a5bba4e064a4eb84cc7502640a0b8dc9" translate="yes" xml:space="preserve">
          <source>If the last template parameter in the</source>
          <target state="translated">의 마지막 템플릿 매개 변수가</target>
        </trans-unit>
        <trans-unit id="88a26f48b106a357207e0f09ddece2a679970e48" translate="yes" xml:space="preserve">
          <source>If the last template parameter is set to &lt;code&gt;No.multiblock&lt;/code&gt;, the allocator will only serve allocations which require at most &lt;code&gt;theBlockSize&lt;/code&gt;. The &lt;code&gt;BitmappedBlock&lt;/code&gt; has a specialized implementation for single-block allocations which allows for greater performance, at the cost of not being able to allocate more than one block at a time.</source>
          <target state="translated">마지막 템플릿 매개 변수가 &lt;code&gt;No.multiblock&lt;/code&gt; 으로 설정 되면 할당자는 최대 &lt;code&gt;theBlockSize&lt;/code&gt; 를 요구하는 할당 만 제공 합니다. &lt;code&gt;BitmappedBlock&lt;/code&gt; 는 한 번에 두 개 이상의 블록을 할당 할 수없는 비용에 큰 성능을 가능하게 단일 블록 할당에 대한 전문 구현을 가지고있다.</target>
        </trans-unit>
        <trans-unit id="b95587a219c8d062823f53f5bd2f1a123f7f69f2" translate="yes" xml:space="preserve">
          <source>If the left and right operands are of the same struct type, and the struct type has a &lt;a href=&quot;struct#Postblit&quot;&gt;&lt;i&gt;Postblit&lt;/i&gt;&lt;/a&gt;, then the copy operation is as described in &lt;a href=&quot;struct#struct-postblit&quot;&gt;Struct Postblit&lt;/a&gt;.</source>
          <target state="translated">왼쪽과 오른쪽 피연산자가 동일한 구조체 유형이고 구조체 유형에 &lt;a href=&quot;struct#Postblit&quot;&gt;&lt;i&gt;Postblit이 있으면&lt;/i&gt;&lt;/a&gt; 복사 작업은 &lt;a href=&quot;struct#struct-postblit&quot;&gt;Struct Postblit에&lt;/a&gt; 설명 된 대로 입니다.</target>
        </trans-unit>
        <trans-unit id="78b1fe866d2fc25a11cfe13642305ae4d6350c6d" translate="yes" xml:space="preserve">
          <source>If the left hand side of an</source>
          <target state="translated">왼쪽의</target>
        </trans-unit>
        <trans-unit id="eb414c8d10d773bd339d18bd7ab37e8cf26592ba" translate="yes" xml:space="preserve">
          <source>If the left hand side of an assignment is a slice operation on a struct or class instance, it can be overloaded by implementing an &lt;code&gt;opIndexAssign&lt;/code&gt; member function that takes the return value of the &lt;code&gt;opSlice&lt;/code&gt; function as parameter(s). Expressions of the form &lt;code&gt;a[&lt;/code&gt;</source>
          <target state="translated">할당의 왼쪽이 구조체 또는 클래스 인스턴스에서 슬라이스 작업 인 경우 &lt;code&gt;opSlice&lt;/code&gt; 함수 의 반환 값을 매개 변수로 사용 하는 &lt;code&gt;opIndexAssign&lt;/code&gt; 멤버 함수를 구현하여 오버로드 할 수 있습니다 . 형태 &lt;code&gt;a[&lt;/code&gt; 표현</target>
        </trans-unit>
        <trans-unit id="a4e9f1b74401fc4cc6670aa5c593952f4aacceb0" translate="yes" xml:space="preserve">
          <source>If the left hand side of an assignment is an index operation on a struct or class instance, it can be overloaded by providing an &lt;code&gt;opIndexAssign&lt;/code&gt; member function. Expressions of the form &lt;code&gt;a[&lt;/code&gt;</source>
          <target state="translated">할당의 왼쪽이 구조체 또는 클래스 인스턴스에서 인덱스 작업 인 경우 &lt;code&gt;opIndexAssign&lt;/code&gt; 멤버 함수를 제공하여 오버로드 할 수 있습니다 . 형태 &lt;code&gt;a[&lt;/code&gt; 표현</target>
        </trans-unit>
        <trans-unit id="d8a73a5f2389d0e22c2833822feb34b34d4eccd0" translate="yes" xml:space="preserve">
          <source>If the left operand is &lt;code&gt;false&lt;/code&gt;, then the right operand is evaluated. If the result type of the</source>
          <target state="translated">왼쪽 피연산자가 &lt;code&gt;false&lt;/code&gt; 인 경우 오른쪽 피연산자가 평가됩니다. 결과 유형이</target>
        </trans-unit>
        <trans-unit id="60ea3d064b90b5b8a778e152eace4b2f3ae90eb9" translate="yes" xml:space="preserve">
          <source>If the left operand is &lt;code&gt;true&lt;/code&gt;, then the right operand is evaluated. If the result type of the</source>
          <target state="translated">왼쪽 피연산자가 &lt;code&gt;true&lt;/code&gt; 이면 오른쪽 피연산자가 평가됩니다. 결과 유형이</target>
        </trans-unit>
        <trans-unit id="019b690c1822d6ef391c3b9bd7b26426c5f16db7" translate="yes" xml:space="preserve">
          <source>If the left operand, converted to type &lt;code&gt;bool&lt;/code&gt;, evaluates to &lt;code&gt;false&lt;/code&gt;, then the right operand is not evaluated. If the result type of the</source>
          <target state="translated">&lt;code&gt;bool&lt;/code&gt; 유형으로 변환 된 왼쪽 피연산자 가 &lt;code&gt;false&lt;/code&gt; 로 평가 되면 오른쪽 피연산자가 평가되지 않습니다. 결과 유형이</target>
        </trans-unit>
        <trans-unit id="553371891fa4522412ee1e69cce9e04315ec8432" translate="yes" xml:space="preserve">
          <source>If the left operand, converted to type &lt;code&gt;bool&lt;/code&gt;, evaluates to &lt;code&gt;true&lt;/code&gt;, then the right operand is not evaluated. If the result type of the</source>
          <target state="translated">&lt;code&gt;bool&lt;/code&gt; 유형으로 변환 된 왼쪽 피연산자 가 &lt;code&gt;true&lt;/code&gt; 로 평가 되면 오른쪽 피연산자가 평가되지 않습니다. 결과 유형이</target>
        </trans-unit>
        <trans-unit id="3b4965e0366e4348265d324ef6cafd070f7970a9" translate="yes" xml:space="preserve">
          <source>If the lock is held by another caller, the method returns. Otherwise, the lock is acquired if it is not already held, and then the internal counter is incremented by one.</source>
          <target state="translated">다른 호출자가 잠금을 보유하면 메소드가 리턴합니다. 그렇지 않으면 잠금이 아직 보유되지 않은 경우 잠금이 획득되고 내부 카운터는 1 씩 증가합니다.</target>
        </trans-unit>
        <trans-unit id="55629f3e58b1ed6b51915672626c91dce13adbf6" translate="yes" xml:space="preserve">
          <source>If the lvalue is a static array or a slice, the behavior is as described in &lt;a href=&quot;array#array-copying&quot;&gt;Array Copying&lt;/a&gt; and &lt;a href=&quot;array#array-setting&quot;&gt;Array Setting&lt;/a&gt;.</source>
          <target state="translated">lvalue가 정적 배열 또는 슬라이스 인 경우 동작은 &lt;a href=&quot;array#array-copying&quot;&gt;배열 복사&lt;/a&gt; 및 &lt;a href=&quot;array#array-setting&quot;&gt;배열 설정에&lt;/a&gt; 설명 된대로입니다 .</target>
        </trans-unit>
        <trans-unit id="9eeb3d42a4d163cc9ef2cce9f7a4d552e700ff44" translate="yes" xml:space="preserve">
          <source>If the lvalue is a user-defined property, the behavior is as described in &lt;a href=&quot;function#property-functions&quot;&gt;Property Functions&lt;/a&gt;.</source>
          <target state="translated">lvalue가 사용자 정의 특성 인 경우 동작은 &lt;a href=&quot;function#property-functions&quot;&gt;특성 함수에&lt;/a&gt; 설명 된대로입니다 .</target>
        </trans-unit>
        <trans-unit id="1e946590fb7a5bc10633af10a8d9500f37b24a5e" translate="yes" xml:space="preserve">
          <source>If the lvalue is the &lt;code&gt;.length&lt;/code&gt; property of a dynamic array, the behavior is as described in &lt;a href=&quot;array#resize&quot;&gt;Setting Dynamic Array Length&lt;/a&gt;.</source>
          <target state="translated">lvalue가 동적 배열 의 &lt;code&gt;.length&lt;/code&gt; 속성 인 경우 동작은 &lt;a href=&quot;array#resize&quot;&gt;동적 배열 길이 설정에&lt;/a&gt; 설명 된대로입니다 .</target>
        </trans-unit>
        <trans-unit id="dbdda788f4cd04313acf31a5b41902468d969a5d" translate="yes" xml:space="preserve">
          <source>If the member is a class or struct, undefined lookups will be forwarded to the</source>
          <target state="translated">멤버가 클래스 또는 구조체 인 경우 정의되지 않은 조회는</target>
        </trans-unit>
        <trans-unit id="c199908c7f62621c91cf713b59d48d772db7abde" translate="yes" xml:space="preserve">
          <source>If the modifier &lt;code&gt;'d'&lt;/code&gt; is present, then the number of characters in &lt;code&gt;to&lt;/code&gt; may be only &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;1&lt;/code&gt;.  If the modifier &lt;code&gt;'d'&lt;/code&gt; is</source>
          <target state="translated">개질제 경우 &lt;code&gt;'d'&lt;/code&gt; 존재하고있는 문자의 수 &lt;code&gt;to&lt;/code&gt; 전용 될 수 &lt;code&gt;0&lt;/code&gt; 또는 &lt;code&gt;1&lt;/code&gt; . 수정 자 &lt;code&gt;'d'&lt;/code&gt; 가</target>
        </trans-unit>
        <trans-unit id="f37f897b787b41e685e34c136ea8c1b433cab685" translate="yes" xml:space="preserve">
          <source>If the need is to remove some elements in the range but the order of the remaining elements does not have to be preserved, you may want to pass &lt;code&gt;SwapStrategy.unstable&lt;/code&gt; to &lt;code&gt;remove&lt;/code&gt;.</source>
          <target state="translated">범위에서 일부 요소를 제거해야하지만 나머지 요소의 순서를 유지하지 않아도되는 경우 &lt;code&gt;SwapStrategy.unstable&lt;/code&gt; 을 전달 하여 &lt;code&gt;remove&lt;/code&gt; 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="03a264184d81bbe95136e2edec953acc73c6e493" translate="yes" xml:space="preserve">
          <source>If the new array length is longer, the remainder is filled out with the default initializer.</source>
          <target state="translated">새 배열 길이가 더 길면 나머지는 기본 이니셜 라이저로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="e4175ca1068588312ee2e22b72b62b8fd2ed5c5b" translate="yes" xml:space="preserve">
          <source>If the only pointer to an object is held outside of these areas, then the collector will miss it and free the memory.</source>
          <target state="translated">객체에 대한 유일한 포인터가이 영역 밖에 있으면 콜렉터는이를 놓치고 메모리를 비 웁니다.</target>
        </trans-unit>
        <trans-unit id="4717846b29b0f5d911b4b2433c06faa02839af64" translate="yes" xml:space="preserve">
          <source>If the operands are integral values, the &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;Usual Arithmetic Conversions&lt;/a&gt; are applied to bring them to a common type before comparison. Equality is defined as the bit patterns of the common type match exactly.</source>
          <target state="translated">피연산자가 정수 값인 경우 &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;일반적인 산술 변환&lt;/a&gt; 을 적용하여 비교 전에 공통 유형으로 가져옵니다. 평등은 공통 유형의 비트 패턴이 정확히 일치하는 것으로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="47f360c49b94c4c07ce9dc61c5e3af5635a7a2ca" translate="yes" xml:space="preserve">
          <source>If the operands are of integral types, they undergo the &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;Usual Arithmetic Conversions&lt;/a&gt;, and then are brought to a common type using the &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;Usual Arithmetic Conversions&lt;/a&gt;.</source>
          <target state="translated">피연산자가 정수형의 경우, 그들은 받아야 &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;일반적인 산술 변환을&lt;/a&gt; 사용하여 일반적인 유형으로하게된다 다음과 &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;일반적인 산술 변환을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="84b7a8c85c49e4f67e102545e92d61c9c7d7721a" translate="yes" xml:space="preserve">
          <source>If the operands are pointers, equality is defined as the bit patterns of the operands match exactly.</source>
          <target state="translated">피연산자가 포인터 인 경우 피연산자의 비트 패턴이 정확히 일치하므로 동등성이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="d6d2f3784c99d4e2535bc4e5ff87e942828bc905" translate="yes" xml:space="preserve">
          <source>If the operands are the same type, the result will be of that type.</source>
          <target state="translated">피연산자가 동일한 유형이면 결과는 해당 유형이됩니다.</target>
        </trans-unit>
        <trans-unit id="5b2963819db13f5d2cdfe8c71bec58c53fd098f3" translate="yes" xml:space="preserve">
          <source>If the operands are the same type, the result will be the that type.</source>
          <target state="translated">피연산자가 동일한 유형이면 결과는 해당 유형이됩니다.</target>
        </trans-unit>
        <trans-unit id="b17e0053bf5ffe1d2e67cd6799c427ff52f64545" translate="yes" xml:space="preserve">
          <source>If the operands of an associative operator + or * are floating point values, the expression is not reordered.</source>
          <target state="translated">연관 연산자 + 또는 *의 피연산자가 부동 소수점 값이면 표현식의 순서가 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1ff3f829adb0f4d6d8dd5ae222b510bf5f3ff104" translate="yes" xml:space="preserve">
          <source>If the operation would lead to an over/underflow, this function will return &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">작업으로 인해 오버플로 / 언더 플로가 발생하면이 함수는 &lt;code&gt;0&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="988a22885dd9a150d46126a78cb644539f3b1a37" translate="yes" xml:space="preserve">
          <source>If the operator is &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt;, and the first operand is a pointer, and the second is an integral type, the resulting type is the type of the first operand, and the resulting value is the pointer plus (or minus) the second operand multiplied by the size of the type pointed to by the first operand.</source>
          <target state="translated">연산자가 &lt;code&gt;+&lt;/code&gt; 또는 &lt;code&gt;-&lt;/code&gt; 이고 첫 번째 피연산자가 포인터이고 두 번째 피연산자가 정수 유형 인 경우 결과 유형은 첫 번째 피연산자의 유형이고 결과 값은 포인터에 두 번째 피연산자를 더한 (또는 빼기)입니다. 첫 번째 피연산자가 가리키는 유형의 크기를 곱한 값입니다.</target>
        </trans-unit>
        <trans-unit id="34ffd24d69741e93233760376d587038f7e6c1e1" translate="yes" xml:space="preserve">
          <source>If the operator is &lt;code&gt;=&lt;/code&gt; then it is simple assignment. The right operand is implicitly converted to the type of the left operand, and assigned to it.</source>
          <target state="translated">연산자가 &lt;code&gt;=&lt;/code&gt; 이면 간단한 할당입니다. 오른쪽 피연산자는 암시 적으로 왼쪽 피연산자의 유형으로 변환되어 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="fd1b71b4b4c55aa30d89d8186ad8ca957d4c8944" translate="yes" xml:space="preserve">
          <source>If the optional second</source>
          <target state="translated">옵션 인 경우 두 번째</target>
        </trans-unit>
        <trans-unit id="c5921859078b177e6c63e26fb0f1ad26714bef56" translate="yes" xml:space="preserve">
          <source>If the parent allocator &lt;code&gt;Allocator&lt;/code&gt; is stateful, an instance of it is stored as a member. Otherwise, &lt;code&gt;AffixAllocator&lt;/code&gt; uses &lt;code&gt;Allocator.instance&lt;/code&gt;. In either case, the name &lt;code&gt;_parent&lt;/code&gt; is uniformly used for accessing the parent allocator.</source>
          <target state="translated">상위 할당 자 &lt;code&gt;Allocator&lt;/code&gt; 상태 저장 인 경우 해당 인스턴스는 멤버로 저장됩니다. 그렇지 않으면 &lt;code&gt;AffixAllocator&lt;/code&gt; 는 &lt;code&gt;Allocator.instance&lt;/code&gt; 를 사용합니다 . 두 경우 모두 &lt;code&gt;_parent&lt;/code&gt; 라는 이름 은 상위 할당 자에 액세스하는 데 균일하게 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="af9326a4bd5d7cb5b11db287f31708f748f7ca2d" translate="yes" xml:space="preserve">
          <source>If the passed buffer is not the last allocation, then &lt;code&gt;delta&lt;/code&gt; can be at most the number of bytes left on the last page. Otherwise, we can expand the last allocation until the end of the virtual address range.</source>
          <target state="translated">전달 된 버퍼가 마지막 할당이 아닌 경우 &lt;code&gt;delta&lt;/code&gt; 는 최대 마지막 페이지에 남은 바이트 수일 수 있습니다. 그렇지 않으면 가상 주소 범위가 끝날 때까지 마지막 할당을 확장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e540ec8736760fd165d128b0a1be1fa92246d1c7" translate="yes" xml:space="preserve">
          <source>If the process associated with &lt;code&gt;pid&lt;/code&gt; has already terminated, &lt;code&gt;tryWait&lt;/code&gt; has the exact same effect as &lt;code&gt;wait&lt;/code&gt;. In this case, it returns a tuple where the &lt;code&gt;terminated&lt;/code&gt; field is set to &lt;code&gt;true&lt;/code&gt; and the &lt;code&gt;status&lt;/code&gt; field has the same interpretation as the return value of &lt;code&gt;wait&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pid&lt;/code&gt; 와 관련된 프로세스 가 이미 종료 된 경우 &lt;code&gt;tryWait&lt;/code&gt; 는 &lt;code&gt;wait&lt;/code&gt; 와 동일한 효과를 갖습니다 . 이 경우, 튜플 반환 &lt;code&gt;terminated&lt;/code&gt; 필드가 설정되어 &lt;code&gt;true&lt;/code&gt; 과 &lt;code&gt;status&lt;/code&gt; 필드의 반환 값과 같은 해석이 &lt;code&gt;wait&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0cc712808d5442951029c772a2016b0fbaebf6a3" translate="yes" xml:space="preserve">
          <source>If the process has</source>
          <target state="translated">프로세스가</target>
        </trans-unit>
        <trans-unit id="8a1cda6113d7bf95379f37d69fe6660204f54b65" translate="yes" xml:space="preserve">
          <source>If the process has already terminated, this function returns directly. The exit code is cached, so that if wait() is called multiple times on the same &lt;a href=&quot;#Pid&quot;&gt;&lt;code&gt;Pid&lt;/code&gt;&lt;/a&gt; it will always return the same value.</source>
          <target state="translated">프로세스가 이미 종료 된 경우이 함수는 직접 리턴합니다. 종료 코드가 캐시되므로 동일한 &lt;a href=&quot;#Pid&quot;&gt; &lt;code&gt;Pid&lt;/code&gt; &lt;/a&gt; 에서 wait ()가 여러 번 호출 되면 항상 동일한 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="04681d73e96e38582bd8e0a705f2c67039e3da37" translate="yes" xml:space="preserve">
          <source>If the process is terminated by a signal, the &lt;code&gt;status&lt;/code&gt; field of the return value will contain a negative number whose absolute value is the signal number. (See &lt;a href=&quot;#wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; for details.)</source>
          <target state="translated">프로세스가 신호에 의해 종료되면, 리턴 값 의 &lt;code&gt;status&lt;/code&gt; 필드는 절대 값이 신호 번호 인 음수를 포함합니다. (자세한 내용은 &lt;a href=&quot;#wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="2cb4ce468479df22f5efb3ab328110646f8f6c12" translate="yes" xml:space="preserve">
          <source>If the process is terminated by a signal, this function returns a negative number whose absolute value is the signal number. Since POSIX restricts normal exit codes to the range 0-255, a negative return value will always indicate termination by signal. Signal codes are defined in the &lt;code&gt;core.sys.posix.signal&lt;/code&gt; module (which corresponds to the &lt;code&gt;signal.h&lt;/code&gt; POSIX header).</source>
          <target state="translated">프로세스가 신호에 의해 종료되면이 함수는 절대 값이 신호 번호 인 음수를 반환합니다. POSIX는 일반 종료 코드를 0-255 범위로 제한하기 때문에 음수 리턴 값은 항상 신호에 의한 종료를 나타냅니다. 신호 코드는 &lt;code&gt;core.sys.posix.signal&lt;/code&gt; 모듈 ( &lt;code&gt;signal.h&lt;/code&gt; POSIX 헤더에 해당)에 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="55d51d320c375e52c1f5d554f57416c612f36789" translate="yes" xml:space="preserve">
          <source>If the range is already the lexicographically greatest even permutation, it is permuted back to the least even permutation and false is returned. Otherwise, true is returned, and the range is modified in-place to be the lexicographically next even permutation.</source>
          <target state="translated">범위가 사전 순으로 가장 큰 짝수 순열 인 경우, 최소 짝수 순열로 다시 순열되고 false가 리턴됩니다. 그렇지 않으면 true가 리턴되고 범위가 사 전적으로 다음 순열로 수정됩니다.</target>
        </trans-unit>
        <trans-unit id="b6341c08a4c104d5a17945be30a12feeaa49cdba" translate="yes" xml:space="preserve">
          <source>If the range is currently the lexicographically greatest permutation, it is permuted back to the least permutation and false is returned. Otherwise, true is returned. One can thus generate all permutations of a range by sorting it according to &lt;code&gt;less&lt;/code&gt;, which produces the lexicographically least permutation, and then calling nextPermutation until it returns false. This is guaranteed to generate all distinct permutations of the range exactly once. If there are</source>
          <target state="translated">범위가 현재 사 전적으로 가장 큰 순열 인 경우, 최소 순열로 다시 순열되고 false가 리턴됩니다. 그렇지 않으면 true가 리턴됩니다. 따라서 범위에 대한 모든 순열은 &lt;code&gt;less&lt;/code&gt; 에 따라 정렬 하여 사전 순으로 최소 순열을 생성 한 다음 false를 리턴 할 때까지 nextPermutation을 호출 하여 범위의 모든 순열을 생성 할 수 있습니다 . 이것은 범위의 모든 뚜렷한 순열을 정확히 한 번만 생성하도록 보장됩니다. 만일 거기에</target>
        </trans-unit>
        <trans-unit id="3c682555e85edc7cea0e0b4d1aeb80e941ac4580" translate="yes" xml:space="preserve">
          <source>If the range runs out before &lt;code&gt;n&lt;/code&gt; elements, &lt;code&gt;take&lt;/code&gt; simply returns the entire range (unlike &lt;a href=&quot;#takeExactly&quot;&gt;&lt;code&gt;takeExactly&lt;/code&gt;&lt;/a&gt;, which will cause an assertion failure if the range ends prematurely):</source>
          <target state="translated">범위가 &lt;code&gt;n&lt;/code&gt; 개의 요소 보다 앞에 있으면 &lt;code&gt;take&lt;/code&gt; 는 전체 범위를 반환합니다 ( &lt;a href=&quot;#takeExactly&quot;&gt; &lt;code&gt;takeExactly&lt;/code&gt; &lt;/a&gt; 와 달리 범위가 조기에 종료되면 어설 션 오류가 발생 함).</target>
        </trans-unit>
        <trans-unit id="0bfb47486948f76918fc7de4a55b72efe69b4181" translate="yes" xml:space="preserve">
          <source>If the ranges are strings, &lt;code&gt;cmp&lt;/code&gt; performs UTF decoding appropriately and compares the ranges one code point at a time.</source>
          <target state="translated">범위가 문자열 인 경우 &lt;code&gt;cmp&lt;/code&gt; 는 UTF 디코딩을 적절하게 수행하고 한 번에 한 코드 포인트 씩 범위를 비교합니다.</target>
        </trans-unit>
        <trans-unit id="ea41ed6834ee0093fe72c06e40f7dc343689c14c" translate="yes" xml:space="preserve">
          <source>If the restrictions above are met, the following copy constructor is generated:</source>
          <target state="translated">위의 제한이 충족되면 다음과 같은 복사 생성자가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="7f1cd9d3b49d8a1f62d192e4c5f4c5d296e6ef4a" translate="yes" xml:space="preserve">
          <source>If the return type is int, and the result can't fit in an int, then the closest value that can be held in 32 bits will be used (so &lt;code&gt;int.max&lt;/code&gt; if it goes over and &lt;code&gt;int.min&lt;/code&gt; if it goes under). However, no attempt is made to deal with integer overflow if the return type is long.</source>
          <target state="translated">반환 유형이 int이고 결과가 int에 맞지 않으면 32 비트로 보유 할 수있는 가장 가까운 값이 사용됩니다 (따라서 &lt;code&gt;int.max&lt;/code&gt; , 넘어 가면 &lt;code&gt;int.min&lt;/code&gt; ). . 그러나 리턴 유형이 긴 경우 정수 오버 플로우를 처리하려고 시도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dd2f2570182620b9927043173b24e489663dd5b6" translate="yes" xml:space="preserve">
          <source>If the return value is not equal to x, the FE_INEXACT exception is raised.</source>
          <target state="translated">반환 값이 x와 같지 않으면 FE_INEXACT 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d430fac68e42265828ef3bb0905404a148953d53" translate="yes" xml:space="preserve">
          <source>If the right-hand side is also a Checked but with a different hook or underlying type, the hook and underlying type of this Checked takes precedence.</source>
          <target state="translated">오른쪽도 Checked이지만 다른 후크 또는 기본 유형 인 경우이 Checked의 후크 및 기본 유형이 우선합니다.</target>
        </trans-unit>
        <trans-unit id="decd65c423494fe4dd1111ea2c9da5871cfb6a35" translate="yes" xml:space="preserve">
          <source>If the second argument's length is less than that of the range indexed, an exception is thrown.</source>
          <target state="translated">두 번째 인수의 길이가 색인화 된 범위의 길이보다 작 으면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="09c0c3ad5616d292e80fb1d35bad8dff429d7620" translate="yes" xml:space="preserve">
          <source>If the second character of &lt;code&gt;path&lt;/code&gt; is a colon (&lt;code&gt;':'&lt;/code&gt;), the first character is interpreted as a drive letter, and must be in the range A-Z (case insensitive).</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; 의 두 번째 문자 가 콜론 ( &lt;code&gt;':'&lt;/code&gt; ) 인 경우 첫 번째 문자는 드라이브 문자로 해석되며 AZ (대소 문자 구분) 범위에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="c8d361e2ea8510e2f9b6eea1c593f762c25ea047" translate="yes" xml:space="preserve">
          <source>If the second operand is a pointer, and the first is an integral type, and the operator is &lt;code&gt;+&lt;/code&gt;, the operands are reversed and the pointer arithmetic just described is applied.</source>
          <target state="translated">두 번째 피연산자가 포인터이고 첫 번째 피연산자가 정수 유형이고 연산자가 &lt;code&gt;+&lt;/code&gt; 인 경우 피연산자가 반전되고 방금 설명한 포인터 산술이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="32b0c9d866faa45199f7035225674aa790902392" translate="yes" xml:space="preserve">
          <source>If the sequence ending at &lt;code&gt;startIdx&lt;/code&gt; does not represent a well formed codepoint, then a &lt;a href=&quot;std_utf#UTFException&quot;&gt;&lt;code&gt;std.utf.UTFException&lt;/code&gt;&lt;/a&gt; may be thrown.  &lt;code&gt;cs&lt;/code&gt; indicates whether the comparisons are case sensitive.</source>
          <target state="translated">&lt;code&gt;startIdx&lt;/code&gt; 로 끝나는 시퀀스 가 올바르게 구성된 코드 포인트를 나타내지 않으면 &lt;a href=&quot;std_utf#UTFException&quot;&gt; &lt;code&gt;std.utf.UTFException&lt;/code&gt; 이&lt;/a&gt; 발생할 수 있습니다. &lt;code&gt;cs&lt;/code&gt; 는 비교가 대소 문자를 구분하는지 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a37342eba6058b3aa514ecc3e65805a0fa7ec8d8" translate="yes" xml:space="preserve">
          <source>If the sequence is a</source>
          <target state="translated">시퀀스가</target>
        </trans-unit>
        <trans-unit id="6e3f474a691ae0e04c816db20a8a1ee2782164f2" translate="yes" xml:space="preserve">
          <source>If the sequence starting at &lt;code&gt;startIdx&lt;/code&gt; does not represent a well formed codepoint, then a &lt;a href=&quot;std_utf#UTFException&quot;&gt;&lt;code&gt;std.utf.UTFException&lt;/code&gt;&lt;/a&gt; may be thrown.</source>
          <target state="translated">&lt;code&gt;startIdx&lt;/code&gt; 에서 시작하는 시퀀스 가 올바르게 구성된 코드 포인트를 나타내지 않으면 &lt;a href=&quot;std_utf#UTFException&quot;&gt; &lt;code&gt;std.utf.UTFException&lt;/code&gt; 이&lt;/a&gt; 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ca37c345a633b86c3f0a8d6f14512c0f7890283" translate="yes" xml:space="preserve">
          <source>If the sign bit is set (that is, it's 'negative'), NAN is less than any number; if the sign bit is not set (it is 'positive'), NAN is greater than any number;</source>
          <target state="translated">부호 비트가 설정되면 (즉, '음수') NAN은 임의의 수보다 작습니다. 부호 비트가 설정되지 않은 경우 ( '긍정') NAN은 임의의 수보다 큽니다.</target>
        </trans-unit>
        <trans-unit id="ad31a32f0506299a66cf84413a7632e943786b66" translate="yes" xml:space="preserve">
          <source>If the signed type is larger than the unsigned type, the unsigned type is converted to the signed type.</source>
          <target state="translated">서명 된 유형이 서명되지 않은 유형보다 크면 서명되지 않은 유형이 서명 된 유형으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="e9a551f8b9f105f8f42e469f990b7c6973a86a1b" translate="yes" xml:space="preserve">
          <source>If the slice bounds can be known at compile time, the slice expression is implicitly convertible to an lvalue of static array. For example:</source>
          <target state="translated">컴파일시 슬라이스 경계를 ​​알 수있는 경우 슬라이스 식은 암시 적으로 lvalue의 정적 배열로 변환 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6ad59f15848db49d072bd8cb912bde77ae2b6ed6" translate="yes" xml:space="preserve">
          <source>If the source file does not start with a BOM, then the first character must be less than or equal to U+0000007F.</source>
          <target state="translated">소스 파일이 BOM으로 시작하지 않으면 첫 번째 문자는 U + 0000007F보다 작거나 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="b27e4bb1c5315e54c4ca57d01e83f479ac84dbd7" translate="yes" xml:space="preserve">
          <source>If the string data is UTF-8 and can be accessed directly, return a pointer to it. Do not assume a terminating 0.</source>
          <target state="translated">문자열 데이터가 UTF-8이고 직접 액세스 할 수 있으면 포인터를 리턴하십시오. 종료 0을 가정하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="5f0ad93f155cd5ae6b24670f9767f5398de5e539" translate="yes" xml:space="preserve">
          <source>If the string does not contain an ampersand, the original will be returned.</source>
          <target state="translated">문자열에 앰퍼샌드가 포함되어 있지 않으면 원본이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="1aa7c7c38f043029163560616539bec8cc7f49c1" translate="yes" xml:space="preserve">
          <source>If the string is not a legitimate IPv4 address, &lt;code&gt;ADDR_NONE&lt;/code&gt; is returned.</source>
          <target state="translated">문자열이 정당한 IPv4 주소가 아닌 경우 &lt;code&gt;ADDR_NONE&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="b15b906e5c8636437606a7baf9615fdd3533eb67" translate="yes" xml:space="preserve">
          <source>If the string is not modified, the original will be returned.</source>
          <target state="translated">문자열을 수정하지 않으면 원본이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="52f9a3df378000710aaee65a7a54a47ac2ca66c0" translate="yes" xml:space="preserve">
          <source>If the struct defines a &lt;b&gt;toString()&lt;/b&gt; method the result is the string returned from this function. Otherwise the result is StructName(field&lt;sub&gt;0&lt;/sub&gt;, field&lt;sub&gt;1&lt;/sub&gt;, ...) where field&lt;sub&gt;n&lt;/sub&gt; is the nth element formatted with the default format.</source>
          <target state="translated">구조체가 &lt;b&gt;toString ()&lt;/b&gt; 메서드를 정의 하면 결과는이 함수에서 반환 된 문자열입니다. 그렇지 않으면 결과는 StructName (field &lt;sub&gt;0&lt;/sub&gt; , field &lt;sub&gt;1&lt;/sub&gt; , ...)입니다. 여기서 필드 &lt;sub&gt;n&lt;/sub&gt; 은 기본 형식으로 형식이 지정된 n 번째 요소입니다.</target>
        </trans-unit>
        <trans-unit id="479988510a7f9556e5fa41c90de2fc0cc635572b" translate="yes" xml:space="preserve">
          <source>If the switch &lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;Expression&lt;/i&gt;&lt;/a&gt; is of enum type, all the enum members must appear in the &lt;a href=&quot;#CaseStatement&quot;&gt;&lt;i&gt;CaseStatement&lt;/i&gt;&lt;/a&gt;s.</source>
          <target state="translated">스위치 &lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;Expression&lt;/i&gt;&lt;/a&gt; 이 열거 형인 경우 모든 열거 형 멤버가 &lt;a href=&quot;#CaseStatement&quot;&gt;&lt;i&gt;CaseStatement에 나타나야&lt;/i&gt;&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="392ee3a5c086f39b17e3a3bb06e7ae5f17a147b6" translate="yes" xml:space="preserve">
          <source>If the switch &lt;code&gt;--DRT-testmode&lt;/code&gt; is passed to the executable, it can have one of 3 values:</source>
          <target state="translated">&lt;code&gt;--DRT-testmode&lt;/code&gt; 스위치 가 실행 파일에 전달되면 다음 세 가지 값 중 하나를 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a0154ff095266436fcdfa44d46155c17b50639bb" translate="yes" xml:space="preserve">
          <source>If the switch &lt;code&gt;--DRT-testmode&lt;/code&gt; is passed to the executable, it can have one of 3 values: 1. &quot;run-main&quot;: even if unit tests are run (and all pass), main is still run. This is currently the default. 2. &quot;test-or-main&quot;: any unit tests present will cause the program to summarize the results and exit regardless of the result. This will be the default in 2.080. 3. &quot;test-only&quot;, the runtime will always summarize and never run main, even if no tests are present.</source>
          <target state="translated">스위치 &lt;code&gt;--DRT-testmode&lt;/code&gt; 가 실행 파일로 전달되면 3 가지 값 중 하나를 가질 수 있습니다. 1. &quot;run-main&quot;: 단위 테스트가 실행되고 모든 패스가 실행 되더라도 main이 여전히 실행됩니다. 이것이 현재 기본값입니다. &quot;test-or-main&quot;: 존재하는 모든 유닛 테스트는 프로그램이 결과를 요약하고 결과에 관계없이 종료되게합니다. 이것이 2.080의 기본값입니다. 3. &quot;테스트 전용&quot;인 경우, 테스트가 존재하지 않더라도 런타임은 항상 요약하고 메인을 실행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cefab3eab3f045d8e153ce4eb6c35b376eb78553" translate="yes" xml:space="preserve">
          <source>If the thread hasn't been started yet, returns &lt;a href=&quot;#ThreadID&quot;&gt;&lt;code&gt;ThreadID&lt;/code&gt;&lt;/a&gt;&lt;code&gt;.init&lt;/code&gt;. Otherwise, returns the result of &lt;code&gt;GetCurrentThreadId&lt;/code&gt; on Windows, and &lt;code&gt;pthread_self&lt;/code&gt; on POSIX.  The value is unique for the current process.</source>
          <target state="translated">스레드가 아직 시작되지 않은 경우 &lt;a href=&quot;#ThreadID&quot;&gt; &lt;code&gt;ThreadID&lt;/code&gt; &lt;/a&gt; &lt;code&gt;.init&lt;/code&gt; 를 리턴합니다 . 그렇지 않으면 Windows에서는 &lt;code&gt;GetCurrentThreadId&lt;/code&gt; , POSIX 에서는 &lt;code&gt;pthread_self&lt;/code&gt; 의 결과를 반환합니다 . 이 값은 현재 프로세스에 고유합니다.</target>
        </trans-unit>
        <trans-unit id="6c09982745040566b9680ca05a80be2c692c0e01" translate="yes" xml:space="preserve">
          <source>If the time zone is &lt;code&gt;&quot;-0000&quot;&lt;/code&gt; (or considered to be equivalent to &lt;code&gt;&quot;-0000&quot;&lt;/code&gt; by section 4.3 of the spec), a &lt;a href=&quot;std_datetime_timezone#SimpleTimeZone&quot;&gt;&lt;code&gt;std.datetime.timezone.SimpleTimeZone&lt;/code&gt;&lt;/a&gt; with a utc offset of &lt;code&gt;0&lt;/code&gt; is used rather than &lt;a href=&quot;std_datetime_timezone#UTC&quot;&gt;&lt;code&gt;std.datetime.timezone.UTC&lt;/code&gt;&lt;/a&gt;, whereas &lt;code&gt;&quot;+0000&quot;&lt;/code&gt; uses &lt;a href=&quot;std_datetime_timezone#UTC&quot;&gt;&lt;code&gt;std.datetime.timezone.UTC&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">시간대가 &lt;code&gt;&quot;-0000&quot;&lt;/code&gt; (또는 사양의 섹션 4.3 에서 &lt;code&gt;&quot;-0000&quot;&lt;/code&gt; 과 동등한 것으로 간주 됨 ) 인 경우 &lt;a href=&quot;std_datetime_timezone#SimpleTimeZone&quot;&gt; &lt;code&gt;std.datetime.timezone.SimpleTimeZone&lt;/code&gt; &lt;/a&gt; 대신 utc 오프셋이 &lt;code&gt;0&lt;/code&gt; 인&lt;a href=&quot;std_datetime_timezone#UTC&quot;&gt; &lt;code&gt;std.datetime.timezone.UTC&lt;/code&gt; &lt;/a&gt; 이 사용됩니다 . timezone.UTC , &lt;code&gt;&quot;+0000&quot;&lt;/code&gt; 은 &lt;a href=&quot;std_datetime_timezone#UTC&quot;&gt; &lt;code&gt;std.datetime.timezone.UTC&lt;/code&gt; 를&lt;/a&gt; 사용 합니다 .</target>
        </trans-unit>
        <trans-unit id="3134e4dcc33577153221f4543bd47086f16438e4" translate="yes" xml:space="preserve">
          <source>If the two arguments are both lambda functions (or aliases to lambda functions), then they are compared for equality. For the comparison to be computed correctly, the following conditions must be met for both lambda functions:</source>
          <target state="translated">두 인수가 모두 람다 함수 (또는 람다 함수의 별명) 인 경우 동등성을 비교합니다. 비교가 올바르게 계산 되려면 두 람다 함수 모두에 대해 다음 조건이 충족되어야합니다.</target>
        </trans-unit>
        <trans-unit id="73a39971fe15042884479dfdbb241d4da31bea94" translate="yes" xml:space="preserve">
          <source>If the two arguments are expressions made up of literals or enums that evaluate to the same value, true is returned.</source>
          <target state="translated">두 인수가 동일한 값으로 평가되는 리터럴 또는 열거로 구성된 표현식 인 경우 true가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="de4732a957b75ea4620f562388e09ef879657bc9" translate="yes" xml:space="preserve">
          <source>If the two arguments are tuples then &lt;code&gt;isSame&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; if the two tuples, after expansion, have the same length and if each pair of nth argument respects the constraints previously specified.</source>
          <target state="translated">두 인수가 튜플이면 확장 후 두 튜플의 길이가 같고 n 번째 인수의 각 쌍이 이전에 지정된 제약 조건 을 &lt;code&gt;isSame&lt;/code&gt; 하면 isSame 은 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="a4473404d01a76d50b04f7848135307a27ac80f3" translate="yes" xml:space="preserve">
          <source>If the two operands are different enums, the result is the closest base type common to both. A base type being closer means there is a shorter sequence of conversions to base type to get there from the original type.</source>
          <target state="translated">두 피연산자가 서로 다른 열거 형이면 결과는 둘 다에 가장 가까운 기본 유형입니다. 기본 유형이 더 가깝다는 것은 기본 유형으로 변환하기 위해 기본 유형으로 변환하는 시퀀스가 ​​짧다는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="7903bedffa68e879ccc58bd5af9a496c7c800c23" translate="yes" xml:space="preserve">
          <source>If the two ranges are different kinds of UTF code unit (&lt;code&gt;char&lt;/code&gt;, &lt;code&gt;wchar&lt;/code&gt;, or &lt;code&gt;dchar&lt;/code&gt;), then the arrays are compared using UTF decoding to avoid accidentally integer-promoting units.</source>
          <target state="translated">두 범위가 서로 다른 종류의 UTF 코드 단위 ( &lt;code&gt;char&lt;/code&gt; , &lt;code&gt;wchar&lt;/code&gt; 또는 &lt;code&gt;dchar&lt;/code&gt; ) 인 경우 실수로 정수 승격 단위를 방지하기 위해 UTF 디코딩을 사용하여 배열을 비교합니다.</target>
        </trans-unit>
        <trans-unit id="b866fed7529b50ec607a768135519745618bce85" translate="yes" xml:space="preserve">
          <source>If the type is a class or struct, returns the symbol for it, else null.</source>
          <target state="translated">유형이 클래스 또는 구조체이면 해당 기호를 반환하고, 그렇지 않으면 null을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9cf47ab4617bfcf6525f2e55361b003e49f6a33c" translate="yes" xml:space="preserve">
          <source>If the type of a function literal can be uniquely determined from its context, the parameter type inference is possible.</source>
          <target state="translated">함수 리터럴의 유형을 컨텍스트에서 고유하게 판별 할 수 있으면 매개 변수 유형 유추가 가능합니다.</target>
        </trans-unit>
        <trans-unit id="bd9e26eaa127a0681e40e687c51d18388c1cb11f" translate="yes" xml:space="preserve">
          <source>If the type specialization is dependent on a type parameter, the type of that parameter is set to be the corresponding part of the type argument.</source>
          <target state="translated">유형 특수화가 유형 매개 변수에 종속되는 경우 해당 매개 변수의 유형은 유형 인수의 해당 부분으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="c38cd0e42755b32d0615eb6b41299ea06a9e9a58" translate="yes" xml:space="preserve">
          <source>If the union defines a &lt;b&gt;toString()&lt;/b&gt; method the result is the string returned from this function. Otherwise the result is the name of the union, without its contents.</source>
          <target state="translated">공용체가 &lt;b&gt;toString ()&lt;/b&gt; 메소드를 정의 하면 결과는이 함수에서 리턴 된 문자열입니다. 그렇지 않으면 결과는 내용이없는 조합의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="5b79753b6512691a7580a1aa8dec230051399447" translate="yes" xml:space="preserve">
          <source>If the union is larger than the first field, the remaining bits are set to 0.</source>
          <target state="translated">공용체가 첫 번째 필드보다 큰 경우 나머지 비트는 0으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="47d795dfceba0f8eb2492f885994a47e15c6743a" translate="yes" xml:space="preserve">
          <source>If the union is larger than the initialized field, the remaining bits are set to 0.</source>
          <target state="translated">공용체가 초기화 된 필드보다 큰 경우 나머지 비트는 0으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="c1ceb76e55274ade5913babacd57bf4f1cb70312" translate="yes" xml:space="preserve">
          <source>If the user-provided size is zero or the user-provided buffer is empty, throws an &lt;code&gt;Exception&lt;/code&gt;. In case of an I/O error throws &lt;code&gt;StdioException&lt;/code&gt;.</source>
          <target state="translated">사용자 제공 크기가 0이거나 사용자 제공 버퍼가 비어 있으면 &lt;code&gt;Exception&lt;/code&gt; 이 발생 합니다. I / O 오류가 발생 &lt;code&gt;StdioException&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="cc7558759f1a8352a99aba9fedf7f766fc85394c" translate="yes" xml:space="preserve">
          <source>If the variable does not exist, it will be created. If it already exists, it will be overwritten.</source>
          <target state="translated">변수가 존재하지 않으면 작성됩니다. 이미 존재하는 경우 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="1eb649b3e71267d6372924b026c8a8d1534bf07a" translate="yes" xml:space="preserve">
          <source>If the variable isn't in the environment, this function returns successfully without doing anything.</source>
          <target state="translated">변수가 환경에 없으면이 함수는 아무 것도하지 않고 성공적으로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d13d09fdf461257eb1bc31ba932d5204cebf3e15" translate="yes" xml:space="preserve">
          <source>If the variadic parameter is an array of delegates with no parameters:</source>
          <target state="translated">variadic 매개 변수가 매개 변수가없는 대리자 배열 인 경우 :</target>
        </trans-unit>
        <trans-unit id="a4c2f19305902bafa0ffed68f37389b9cbdc3d33" translate="yes" xml:space="preserve">
          <source>If there are fewer arguments supplied in the</source>
          <target state="translated">제공되는 인수가 더 적은 경우</target>
        </trans-unit>
        <trans-unit id="137908701928a250c21674b47c9c08664cb6489d" translate="yes" xml:space="preserve">
          <source>If there are multiple</source>
          <target state="translated">여러 개가있는 경우</target>
        </trans-unit>
        <trans-unit id="9d520e5d39ca368a2b272ce1cc53485c938b54ac" translate="yes" xml:space="preserve">
          <source>If there are multiple &lt;code&gt;return ref&lt;/code&gt; parameters, the lifetime of the return value is the smallest lifetime of the corresponding arguments.</source>
          <target state="translated">&lt;code&gt;return ref&lt;/code&gt; 매개 변수 가 여러 개인 경우 리턴 값의 수명은 해당 인수의 수명이 가장 짧습니다.</target>
        </trans-unit>
        <trans-unit id="e237e9fe68b8078484793ae54d1c1e4290772666" translate="yes" xml:space="preserve">
          <source>If there are multiple UDAs in scope for a declaration, they are concatenated:</source>
          <target state="translated">선언 범위에 여러 UDA가있는 경우 다음과 같이 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="d33b5562bbab16d600772bb0c4e960b31c667c22" translate="yes" xml:space="preserve">
          <source>If there are multiple pragma inlines in a function, the lexically last one takes effect.</source>
          <target state="translated">함수에 여러 개의 pragma 인라인이 있으면 어휘 적으로 마지막 인라인이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="c4b327a5dc42638f7be9041ec07ceb89c1cacdad" translate="yes" xml:space="preserve">
          <source>If there are no arguments, the result is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">인수가 없으면 결과는 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b4600b295ae3596b41be4670d227eb72326970dd" translate="yes" xml:space="preserve">
          <source>If there are no user-defined attributes for the symbol, an empty tuple is returned. The expression tuple can be turned into a manipulatable tuple:</source>
          <target state="translated">심볼에 대한 사용자 정의 속성이 없으면 빈 튜플이 반환됩니다. 튜플 표현은 조작 가능한 튜플로 바뀔 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e49abc2a9f1f1c709edab2a411a4d0eb933f0f8e" translate="yes" xml:space="preserve">
          <source>If there are two symbols declared, the first is the</source>
          <target state="translated">두 개의 기호가 선언 된 경우 첫 번째 기호는</target>
        </trans-unit>
        <trans-unit id="3df841c41211bfc9016bcff2ddd45752571711df" translate="yes" xml:space="preserve">
          <source>If there is a &lt;code&gt;new (&lt;/code&gt;&lt;a href=&quot;#ArgumentList&quot;&gt;&lt;i&gt;ArgumentList&lt;/i&gt;&lt;/a&gt;&lt;code&gt;)&lt;/code&gt;, then those arguments are passed to the class or struct specific &lt;a href=&quot;class#allocators&quot;&gt;allocator function&lt;/a&gt; after the size argument.</source>
          <target state="translated">&lt;code&gt;new (&lt;/code&gt; &lt;a href=&quot;#ArgumentList&quot;&gt;&lt;i&gt;ArgumentList&lt;/i&gt;&lt;/a&gt; &lt;code&gt;)&lt;/code&gt; 이 있으면 해당 인수는 size 인수 다음에 클래스 또는 구조체 특정 &lt;a href=&quot;class#allocators&quot;&gt;할당 자 함수로&lt;/a&gt; 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="4a441171bce481c9de8d817376b233adfcdc1d3d" translate="yes" xml:space="preserve">
          <source>If there is a constructor defined for the class, the constructor matching the argument list is called.</source>
          <target state="translated">클래스에 대해 생성자가 정의되어 있으면 인수 목록과 일치하는 생성자가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="2b9a54f4a31088d1176dc7dd4ca3c5a15fce19ea" translate="yes" xml:space="preserve">
          <source>If there is a constructor defined for the struct, the constructor matching the argument list is called.</source>
          <target state="translated">구조체에 대해 생성자가 정의되어 있으면 인수 목록과 일치하는 생성자가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="6070235a5fc84c6102f81ad3d99d47f62b8d7355" translate="yes" xml:space="preserve">
          <source>If there is an &lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;Expression&lt;/i&gt;&lt;/a&gt;, it must evaluate to either an Object or an instance of an</source>
          <target state="translated">&lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;Expression&lt;/i&gt;&lt;/a&gt; 이 있으면 Object 또는 Object의 인스턴스로 평가해야합니다.</target>
        </trans-unit>
        <trans-unit id="5a13d6eff463d638a1f16cd2e1b1291d41f27d35" translate="yes" xml:space="preserve">
          <source>If there is an out postcondition (see &lt;a href=&quot;contracts&quot;&gt;Contract Programming&lt;/a&gt;), that postcondition is executed after the &lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;Expression&lt;/i&gt;&lt;/a&gt; is evaluated and before the function actually returns.</source>
          <target state="translated">사후 조건이없는 경우 ( &lt;a href=&quot;contracts&quot;&gt;계약 프로그래밍&lt;/a&gt; 참조 ) 해당 사후 조건은 &lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;표현식&lt;/i&gt;&lt;/a&gt; 이 평가 된 후 함수가 실제로 리턴되기 전에 실행 됩니다.</target>
        </trans-unit>
        <trans-unit id="f306e547fcde96fa296d39ba4173abf9b358bd47" translate="yes" xml:space="preserve">
          <source>If there is more than one &lt;code&gt;scope&lt;/code&gt; variable going out of scope at the same point, then the destructors are called in the reverse order that the variables were constructed.</source>
          <target state="translated">같은 지점에서 범위를 &lt;code&gt;scope&lt;/code&gt; 변수 가 둘 이상 있으면 소멸자는 변수가 구성된 순서와 반대로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="f9d4b8b7f08b3f6307ae69aa1e6c9c14710481c3" translate="yes" xml:space="preserve">
          <source>If there is no &lt;a href=&quot;expression#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression&lt;/i&gt;&lt;/a&gt; and it is not the first</source>
          <target state="translated">&lt;a href=&quot;expression#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression&lt;/i&gt;&lt;/a&gt; 이없고 처음이 아닌 경우</target>
        </trans-unit>
        <trans-unit id="b034aafdece95219928b4d5ae1779c324d51f861" translate="yes" xml:space="preserve">
          <source>If there is no constructor for a class, but there is a constructor for the base class, a default constructor is implicitly generated with the form:</source>
          <target state="translated">클래스의 생성자가 없지만 기본 클래스의 생성자가있는 경우 기본 생성자는 다음 형식으로 내재적으로 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="8a089796c9cda4645dac5b38c15d592eebc4d1ab" translate="yes" xml:space="preserve">
          <source>If there is no default return expression and the predicate does not yield true with any test expression - &lt;code&gt;SwitchError&lt;/code&gt; is thrown. &lt;code&gt;SwitchError&lt;/code&gt; is also thrown if a void return expression was executed without throwing anything.</source>
          <target state="translated">기본 리턴 표현식이없고 테스트 표현식에서 술어가 true를 생성하지 않으면 &lt;code&gt;SwitchError&lt;/code&gt; 가 발생합니다. 아무것도 리턴하지 않고 void 리턴 표현식이 실행 된 경우에도 &lt;code&gt;SwitchError&lt;/code&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9c729a22e9cf50dfda75e0983406587bf80017e7" translate="yes" xml:space="preserve">
          <source>If there is no documentation comment for a declaration, that declaration may not appear in the output. To ensure it does appear in the output, put an empty declaration comment for it.</source>
          <target state="translated">선언에 대한 문서 주석이 없으면 해당 선언이 출력에 나타나지 않을 수 있습니다. 출력에 표시되도록하려면 빈 선언 주석을 넣으십시오.</target>
        </trans-unit>
        <trans-unit id="6fce9903fe99732c7b1d983701bee8c33b687b65" translate="yes" xml:space="preserve">
          <source>If there is no time zone in the string, then &lt;a href=&quot;std_datetime_timezone#LocalTime&quot;&gt;&lt;code&gt;std.datetime.timezone.LocalTime&lt;/code&gt;&lt;/a&gt; is used. If the time zone is &quot;Z&quot;, then &lt;code&gt;UTC&lt;/code&gt; is used. Otherwise, a &lt;a href=&quot;std_datetime_timezone#SimpleTimeZone&quot;&gt;&lt;code&gt;std.datetime.timezone.SimpleTimeZone&lt;/code&gt;&lt;/a&gt; which corresponds to the given offset from UTC is used. To get the returned &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; to be a particular time zone, pass in that time zone and the &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; to be returned will be converted to that time zone (though it will still be read in as whatever time zone is in its string).</source>
          <target state="translated">문자열에 시간대가 없으면 &lt;a href=&quot;std_datetime_timezone#LocalTime&quot;&gt; &lt;code&gt;std.datetime.timezone.LocalTime&lt;/code&gt; &lt;/a&gt; 이 사용됩니다. 시간대가 &quot;Z&quot;이면 &lt;code&gt;UTC&lt;/code&gt; 가 사용됩니다. 그렇지 않으면 UTC로부터 주어진 오프셋에 해당 하는 &lt;a href=&quot;std_datetime_timezone#SimpleTimeZone&quot;&gt; &lt;code&gt;std.datetime.timezone.SimpleTimeZone&lt;/code&gt; &lt;/a&gt; 이 사용됩니다. 반환 된 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; 을 특정 시간대 로 가져 오려면 해당 시간대를 전달 하면 반환 할 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; 이 해당 시간대로 변환됩니다 (문자열에 시간대가 있더라도 그대로 읽습니다).</target>
        </trans-unit>
        <trans-unit id="ecb767820c42d2c1eeab40ca9731a8e9ce9ec854" translate="yes" xml:space="preserve">
          <source>If there is no type specialization for the parameter, the type of the parameter is set to the template argument.</source>
          <target state="translated">매개 변수에 대한 유형 전문화가없는 경우 매개 변수 유형이 템플리트 인수로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="333c6091877decb710b52473531fc9677d023463" translate="yes" xml:space="preserve">
          <source>If there is only one member of an anonymous enum, the &lt;code&gt;{ }&lt;/code&gt; can be omitted. Gramatically speaking, this is an &lt;a href=&quot;declaration#AutoDeclaration&quot;&gt;&lt;i&gt;AutoDeclaration&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">익명 열거 형의 멤버가 하나만 있으면 &lt;code&gt;{ }&lt;/code&gt; 을 생략 할 수 있습니다. &lt;a href=&quot;declaration#AutoDeclaration&quot;&gt;&lt;i&gt;문법적으로&lt;/i&gt;&lt;/a&gt; 말하면, 이것은 &lt;i&gt;AutoDeclaration&lt;/i&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="81c7998e55322be143bbc65f832d80e17d966603" translate="yes" xml:space="preserve">
          <source>If there's no handler for a particular error, it is handled by the runtime library default handler. If an error is ignored, it is because the programmer specifically added code to ignore an error, which presumably means it was intentional.</source>
          <target state="translated">특정 오류에 대한 핸들러가없는 경우 런타임 라이브러리 기본 핸들러에 의해 처리됩니다. 오류가 무시되면 프로그래머가 오류를 무시하기 위해 코드를 구체적으로 추가했기 때문일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1504a8955edcaca212d8f1b4743a707d2ef9fdb6" translate="yes" xml:space="preserve">
          <source>If these constraints aren't fulfilled, the function is considered incomparable and &lt;code&gt;isSame&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">이러한 제약 조건이 충족되지 않으면 함수는 비교할 수없는 것으로 간주되고 &lt;code&gt;isSame&lt;/code&gt; 은 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="b28035cefdbe2f2deeefc61501ea02f89e4a353d" translate="yes" xml:space="preserve">
          <source>If they are both null, then they are equal. If one is null and the other is not, then they are not equal. If they are both non-null, then they are equal if their values are equal.</source>
          <target state="translated">둘 다 null이면 동일합니다. 하나가 널이고 다른 하나가 다르면 같지 않습니다. 둘 다 널이 아닌 경우 값이 같으면 동일합니다.</target>
        </trans-unit>
        <trans-unit id="4662c9e57a2220461566af34d1a71bfb063d8fd6" translate="yes" xml:space="preserve">
          <source>If they compare equal, return 0 else value returned by fp.</source>
          <target state="translated">동일하게 비교하면 0을 리턴하고 그렇지 않으면 fp가 리턴 한 값을 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="489bf198a6a75e62f83ca7fe9ee2482aa193539d" translate="yes" xml:space="preserve">
          <source>If they have range interface, formatted as input range.</source>
          <target state="translated">범위 인터페이스가있는 경우 입력 범위로 형식화됩니다.</target>
        </trans-unit>
        <trans-unit id="a2e48f2bb2a2bc86917d71f83c2b5a6ff9f995c9" translate="yes" xml:space="preserve">
          <source>If they have the same ptrs, return 1 else 0.</source>
          <target state="translated">그것들이 동일한 ptr을 가지고 있다면 1을 리턴하고 그렇지 않으면 0을 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="2bac3ec55e8f026836fad11da1a5ea396ba6c7f1" translate="yes" xml:space="preserve">
          <source>If this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;'s time zone is &lt;a href=&quot;std_datetime_timezone#LocalTime&quot;&gt;&lt;code&gt;std.datetime.timezone.LocalTime&lt;/code&gt;&lt;/a&gt;, then TZ is empty. If its time zone is &lt;code&gt;UTC&lt;/code&gt;, then it is &quot;Z&quot;. Otherwise, it is the offset from UTC (e.g. +0100 or -0700). Note that the offset from UTC is</source>
          <target state="translated">이 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; 의 시간대가 &lt;a href=&quot;std_datetime_timezone#LocalTime&quot;&gt; &lt;code&gt;std.datetime.timezone.LocalTime&lt;/code&gt; &lt;/a&gt; 인 경우 TZ는 비어 있습니다. 시간대가 &lt;code&gt;UTC&lt;/code&gt; 이면 &quot;Z&quot;입니다. 그렇지 않으면 UTC와의 오프셋입니다 (예 : +0100 또는 -0700). UTC로부터의 오프셋은</target>
        </trans-unit>
        <trans-unit id="2c514f7eb520c6d91b2201391b00ffde6396be0d" translate="yes" xml:space="preserve">
          <source>If this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;'s time zone is &lt;a href=&quot;std_datetime_timezone#LocalTime&quot;&gt;&lt;code&gt;std.datetime.timezone.LocalTime&lt;/code&gt;&lt;/a&gt;, then TZ is empty. If its time zone is &lt;code&gt;UTC&lt;/code&gt;, then it is &quot;Z&quot;. Otherwise, it is the offset from UTC (e.g. +01:00 or -07:00). Note that the offset from UTC is</source>
          <target state="translated">이 &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; 의 시간대가 &lt;a href=&quot;std_datetime_timezone#LocalTime&quot;&gt; &lt;code&gt;std.datetime.timezone.LocalTime&lt;/code&gt; &lt;/a&gt; 인 경우 TZ는 비어 있습니다. 시간대가 &lt;code&gt;UTC&lt;/code&gt; 이면 &quot;Z&quot;입니다. 그렇지 않으면 UTC와의 오프셋입니다 (예 : +01 : 00 또는 -07 : 00). UTC로부터의 오프셋은</target>
        </trans-unit>
        <trans-unit id="59b4585a3a599edf4de86352eceb935135d14f4b" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Nullable&lt;/code&gt; wraps a type that already has a null value (such as a pointer), and that null value is not given for &lt;code&gt;nullValue&lt;/code&gt;, then assigning the null value to this &lt;code&gt;Nullable&lt;/code&gt; is no different than assigning any other value of type &lt;code&gt;T&lt;/code&gt;, and the resulting code will look very strange. It is strongly recommended that this be avoided by using &lt;code&gt;T&lt;/code&gt;'s &quot;built in&quot; null value for &lt;code&gt;nullValue&lt;/code&gt;.</source>
          <target state="translated">이 경우 &lt;code&gt;Nullable&lt;/code&gt; 이미 (예를 들면 포인터와 같은)는 NULL 값을 가지고있는 형태를 래핑하고 NULL 값이 주어되지 &lt;code&gt;nullValue&lt;/code&gt; 후 이에 NULL 값 할당 &lt;code&gt;Nullable&lt;/code&gt; 입력 한 임의의 다른 값이 할당 다르지 않다 &lt;code&gt;T&lt;/code&gt; 는 한 결과 코드는 매우 이상하게 보일 것입니다. &lt;code&gt;nullValue&lt;/code&gt; 에 &lt;code&gt;T&lt;/code&gt; 의 &quot;built in&quot;null 값을 사용하여이를 피하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="bacbc660925702039182b51b563933523f30696f" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Nullable&lt;/code&gt; wraps a type that already has a null value (such as a pointer), then assigning the null value to this &lt;code&gt;Nullable&lt;/code&gt; is no different than assigning any other value of type &lt;code&gt;T&lt;/code&gt;, and the resulting code will look very strange. It is strongly recommended that this be avoided by instead using the version of &lt;code&gt;Nullable&lt;/code&gt; that takes an additional &lt;code&gt;nullValue&lt;/code&gt; template argument.</source>
          <target state="translated">이 &lt;code&gt;Nullable&lt;/code&gt; 이 이미 널값을 갖는 유형 (예 : 포인터)을 랩핑하는 경우 널값 을이 &lt;code&gt;Nullable&lt;/code&gt; 에 지정하는 것은 &lt;code&gt;T&lt;/code&gt; 유형의 다른 값을 지정하는 것과 다르지 않으며 결과 코드는 매우 이상하게 보입니다. 추가적인 &lt;code&gt;nullValue&lt;/code&gt; 템플릿 인수 를 취하는 &lt;code&gt;Nullable&lt;/code&gt; 버전을 대신 사용하여이를 피하는 것이 좋습니다 .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
