<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="d">
    <body>
      <group id="d">
        <trans-unit id="7febe77abd33adf57e913bf0a4a63eb358541f75" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Task&lt;/code&gt; was not started yet, execute it in the current thread. If it is finished, return its result. If it is in progress, execute any other &lt;code&gt;Task&lt;/code&gt; from the &lt;code&gt;TaskPool&lt;/code&gt; instance that this &lt;code&gt;Task&lt;/code&gt; was submitted to until this one is finished. If it threw an exception, rethrow that exception. If no other tasks are available or this &lt;code&gt;Task&lt;/code&gt; was executed using &lt;code&gt;executeInNewThread&lt;/code&gt;, wait on a condition variable.</source>
          <target state="translated">이 &lt;code&gt;Task&lt;/code&gt; 이 아직 시작되지 않은 경우 현재 스레드에서 실행하십시오. 완료되면 결과를 반환하십시오. 진행중인 경우이 &lt;code&gt;Task&lt;/code&gt; 이 완료 될 때까지이 작업 이 제출 된 &lt;code&gt;TaskPool&lt;/code&gt; 인스턴스 에서 다른 &lt;code&gt;Task&lt;/code&gt; 을 실행하십시오 . 예외가 발생하면 해당 예외를 다시 발생 시키십시오. 사용 가능한 다른 작업이 &lt;code&gt;executeInNewThread&lt;/code&gt; &lt;code&gt;Task&lt;/code&gt; 이 executeInNewThread를 사용하여 실행 된 경우 조건 변수를 기다립니다.</target>
        </trans-unit>
        <trans-unit id="02c1e520b882980c80752c1365bf55b4375ba858" translate="yes" xml:space="preserve">
          <source>If this declaration is compliant with any particular standard, the description of it goes here.</source>
          <target state="translated">이 선언이 특정 표준을 준수하는 경우 여기에 대한 설명이 있습니다.</target>
        </trans-unit>
        <trans-unit id="13a2f9d3fe709668a2bc4c5dc3f8ab6e710fca1e" translate="yes" xml:space="preserve">
          <source>If this is a reference, dereference it.</source>
          <target state="translated">이것이 참조 인 경우 참조 해제하십시오.</target>
        </trans-unit>
        <trans-unit id="4f2c995ebc62fdd08dead47122c9bc13fad7a76d" translate="yes" xml:space="preserve">
          <source>If this is a shell around another type, get that other type.</source>
          <target state="translated">다른 유형의 쉘이라면 다른 유형을 얻으십시오.</target>
        </trans-unit>
        <trans-unit id="b5dc509f5b8b27fb2d7cf6170c77f1c20cada7e8" translate="yes" xml:space="preserve">
          <source>If this is a type of something, return that something.</source>
          <target state="translated">이것이 일종의 무언가라면, 그 무언가를 돌려주십시오.</target>
        </trans-unit>
        <trans-unit id="78983652ba5d9285bc5419929ba9f7e7d2014654" translate="yes" xml:space="preserve">
          <source>If this is a type of static array, return its base element type.</source>
          <target state="translated">이것이 정적 배열 유형 인 경우 기본 요소 유형을 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="11053146fa2d89a0863002bf2113f6a22908ad90" translate="yes" xml:space="preserve">
          <source>If this lock is not already held by the caller, the lock is acquired, then the internal counter is incremented by one.</source>
          <target state="translated">이 잠금이 호출자가 아직 보유하지 않은 경우 잠금이 획득되고 내부 카운터는 1 씩 증가합니다.</target>
        </trans-unit>
        <trans-unit id="7f2c76fc93c2cea506533b01d671704af3859af8" translate="yes" xml:space="preserve">
          <source>If this statement has code that needs to run in a finally clause at the end of the current scope, return that code in the form of a Statement.</source>
          <target state="translated">이 명령문에 현재 범위의 끝에 finally 절에서 실행해야하는 코드가 있으면 해당 코드를 Statement 형식으로 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="0515fd6aa93cc22acea186af17b617bb6900cccc" translate="yes" xml:space="preserve">
          <source>If this symbol is really an alias for another, return that other. If needed, semantic() is invoked due to resolve forward reference.</source>
          <target state="translated">이 기호가 실제로 다른 기호 인 경우 다른 기호를 반환하십시오. 필요한 경우, 순방향 참조를 해결하기 위해 semantic ()이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="0d671d5e8525a56282bf3d43e4b2c8ef0fff443b" translate="yes" xml:space="preserve">
          <source>If two &lt;code&gt;Checked&lt;/code&gt; instances are involved in a binary operation and both define &lt;code&gt;hookOpBinary&lt;/code&gt;, the left-hand side hook has priority. If both define &lt;code&gt;onOverflow&lt;/code&gt;, a compile-time error occurs.</source>
          <target state="translated">2 개의 &lt;code&gt;Checked&lt;/code&gt; 인스턴스가 2 진 조작에 관여하고 둘 다 &lt;code&gt;hookOpBinary&lt;/code&gt; 를 정의 하는 경우 왼쪽 후크가 우선합니다. 둘 다 &lt;code&gt;onOverflow&lt;/code&gt; 를 정의 하면 컴파일 타임 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="000877fa3e86af7fe8754c0a2ea9639fca32104e" translate="yes" xml:space="preserve">
          <source>If two different mixins are put in the same scope, and each define a declaration with the same name, there is an ambiguity error when the declaration is referenced:</source>
          <target state="translated">서로 다른 두 믹스 인이 동일한 범위에 배치되고 각각 동일한 이름으로 선언을 정의하면 선언이 참조 될 때 모호한 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a3bad367e89a048e204fc75a01e068c90ffc4712" translate="yes" xml:space="preserve">
          <source>If two or more functions have the same match level, then</source>
          <target state="translated">둘 이상의 기능이 동일한 일치 수준을 갖는 경우</target>
        </trans-unit>
        <trans-unit id="329ee511107dbe6e7abc063f46dd137916ba7624" translate="yes" xml:space="preserve">
          <source>If unit tests are not enabled, the implementation is not required to check the &lt;a href=&quot;#UnitTest&quot;&gt;&lt;i&gt;UnitTest&lt;/i&gt;&lt;/a&gt; for syntactic or semantic correctness. This is to reduce the compile time impact of larger unit test sections. The tokens must still be valid, and the implementation can merely count &lt;code&gt;{&lt;/code&gt; and &lt;code&gt;}&lt;/code&gt; tokens to find the end of the &lt;a href=&quot;#UnitTest&quot;&gt;&lt;i&gt;UnitTest&lt;/i&gt;&lt;/a&gt;'s &lt;a href=&quot;statement#BlockStatement&quot;&gt;&lt;i&gt;BlockStatement&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">단위 테스트를 사용하지 않으면 구문 또는 의미의 정확성을 위해 &lt;a href=&quot;#UnitTest&quot;&gt;&lt;i&gt;UnitTest&lt;/i&gt;&lt;/a&gt; 를 검사 할 필요가 없습니다 . 이는 더 큰 단위 테스트 섹션의 컴파일 시간 영향을 줄이기위한 것입니다. 토큰은 여전히 ​​유효해야하며 구현시 &lt;code&gt;{&lt;/code&gt; 및 &lt;code&gt;}&lt;/code&gt; 토큰 만 계산 하여 &lt;a href=&quot;#UnitTest&quot;&gt;&lt;i&gt;UnitTest&lt;/i&gt;&lt;/a&gt; 의 &lt;a href=&quot;statement#BlockStatement&quot;&gt;&lt;i&gt;BlockStatement&lt;/i&gt;&lt;/a&gt; 끝을 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9627f657eafec4f6faa68074956b9ef2912cb7d7" translate="yes" xml:space="preserve">
          <source>If variable has a const initializer, return that initializer.</source>
          <target state="translated">변수에 const 이니셜 라이저가 있으면 해당 이니셜 라이저를 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="efa87bbfad2d81b3124f9c28a0c2e92ac37d7e01" translate="yes" xml:space="preserve">
          <source>If variable has a constant expression initializer, get it. Otherwise, return null.</source>
          <target state="translated">변수에 상수 표현식 이니셜 라이저가 있으면 가져옵니다. 그렇지 않으면 null을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="129f6b693e38ba5e18679007098a9df7fc61bc3f" translate="yes" xml:space="preserve">
          <source>If vector extensions are implemented, the &lt;a href=&quot;version#PredefinedVersions&quot;&gt;version identifier&lt;/a&gt;&lt;code&gt;D_SIMD&lt;/code&gt; is set.</source>
          <target state="translated">벡터 확장이 구현되면 &lt;a href=&quot;version#PredefinedVersions&quot;&gt;버전 식별자 &lt;/a&gt; &lt;code&gt;D_SIMD&lt;/code&gt; 가 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="adbc7bef2337da263c5a713fbb0e840af6633adb" translate="yes" xml:space="preserve">
          <source>If we want the value of this expression, but do not want to call the destructor on it.</source>
          <target state="translated">이 표현식의 값을 원하지만 소멸자를 호출하지 않으려는 경우.</target>
        </trans-unit>
        <trans-unit id="ec18bd660a5b36aeac802e90948287ace69121eb" translate="yes" xml:space="preserve">
          <source>If x is 0 and n is negative, the result is the same as the result of a division by zero.</source>
          <target state="translated">x가 0이고 n이 음수이면 결과는 0으로 나눈 결과와 같습니다.</target>
        </trans-unit>
        <trans-unit id="79988e7c16e0dced67dee802d9bdb6de78ec6132" translate="yes" xml:space="preserve">
          <source>If x is not a special value, the result is the same as &lt;code&gt;cast(int) logb(x)&lt;/code&gt;.</source>
          <target state="translated">x가 특별한 값이 아닌 경우 결과는 &lt;code&gt;cast(int) logb(x)&lt;/code&gt; 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="bffad47163601102b19e67fa92a8c3feda0166ec" translate="yes" xml:space="preserve">
          <source>If x is subnormal, it is treated as if it were normalized. For a positive, finite x:</source>
          <target state="translated">x가 비정규 인 경우 정규화 된 것처럼 처리됩니다. 양의 유한 x의 경우 :</target>
        </trans-unit>
        <trans-unit id="92c403e0084ea037260c41da9c4c7e544a7d2d08" translate="yes" xml:space="preserve">
          <source>If y &amp;gt; x, the result will be the next largest floating-point value; if y &amp;lt; x, the result will be the next smallest value. If x == y, the result is y.</source>
          <target state="translated">y&amp;gt; x 인 경우 결과는 다음으로 가장 큰 부동 소수점 값이됩니다. y &amp;lt;x이면 결과는 다음으로 가장 작은 값이됩니다. x == y이면 결과는 y입니다.</target>
        </trans-unit>
        <trans-unit id="9dc7acb3598875395fe18b41fd6f909c4555485e" translate="yes" xml:space="preserve">
          <source>If y &amp;gt; x, the result will be the next largest floating-point value; if y &amp;lt; x, the result will be the next smallest value. If x == y, the result is y. If x or y is a NaN, the result is a NaN.</source>
          <target state="translated">y&amp;gt; x이면 결과는 다음으로 큰 부동 소수점 값이됩니다. y &amp;lt;x이면 결과는 다음으로 작은 값이됩니다. x == y이면 결과는 y입니다. x 또는 y가 NaN이면 결과는 NaN입니다.</target>
        </trans-unit>
        <trans-unit id="51868f820cebc5e3c544468e6d407c4bd6b45485" translate="yes" xml:space="preserve">
          <source>If you have a small buffer you can use &lt;a href=&quot;#compress&quot;&gt;&lt;code&gt;compress&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#uncompress&quot;&gt;&lt;code&gt;uncompress&lt;/code&gt;&lt;/a&gt; directly.</source>
          <target state="translated">작은 버퍼가 있으면 &lt;a href=&quot;#compress&quot;&gt; &lt;code&gt;compress&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#uncompress&quot;&gt; &lt;code&gt;uncompress&lt;/code&gt; &lt;/a&gt; 직접 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b65e14bf08e45286eb114c69d33e8aa407bf4bbd" translate="yes" xml:space="preserve">
          <source>If you omit &lt;code&gt;Rhs&lt;/code&gt;, &lt;code&gt;isAssignable&lt;/code&gt; will check identity assignable of &lt;code&gt;Lhs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Rhs&lt;/code&gt; 를 생략 하면 &lt;code&gt;isAssignable&lt;/code&gt; 은 &lt;code&gt;Lhs&lt;/code&gt; 에 할당 가능한 ID를 확인 합니다.</target>
        </trans-unit>
        <trans-unit id="14961e1fccbf1736d47a52df390592d594e9109a" translate="yes" xml:space="preserve">
          <source>If you select &lt;code&gt;precise&lt;/code&gt; as the garbage collector via the options above, type information will be used to identify actual or possible pointers or references within heap allocated data objects. Non-pointer data will not be interpreted as a reference to other memory as a &quot;false pointer&quot;. The collector has to make pessimistic assumptions if a memory slot can contain both a pointer or an integer value, it will still be scanned (e.g. in a &lt;code&gt;union&lt;/code&gt;).</source>
          <target state="translated">위의 옵션을 통해 가비지 수집기로 &lt;code&gt;precise&lt;/code&gt; 선택하면 형식 정보를 사용하여 힙 할당 데이터 개체 내에서 실제 또는 가능한 포인터 또는 참조를 식별합니다. 포인터가 아닌 데이터는 다른 메모리에 대한 참조로 &quot;거짓 포인터&quot;로 해석되지 않습니다. 콜렉터는 메모리 슬롯에 포인터 또는 정수 값이 모두 포함될 수있는 경우 비관적 인 가정을 수행해야하지만 여전히 스캔됩니다 (예 : &lt;code&gt;union&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="cbade680aa6ce4b2eee3b550013b504b2359a76c" translate="yes" xml:space="preserve">
          <source>If you use the GC memory functions from &lt;code&gt;core.memory&lt;/code&gt;, and plan to use it for data with a mixture of pointers and non-pointer data you should pass the TypeInfo of your allocated struct, class or type as the optional parameter. The default &lt;code&gt;null&lt;/code&gt; is interpreted as memory that might contain pointers everywhere.</source>
          <target state="translated">&lt;code&gt;core.memory&lt;/code&gt; 의 GC 메모리 함수 를 사용하고 포인터와 비 포인터 데이터가 혼합 된 데이터에 사용하려는 경우 할당 된 구조체, 클래스 또는 유형의 TypeInfo를 선택적 매개 변수로 전달해야합니다. 기본 &lt;code&gt;null&lt;/code&gt; 은 어디에서나 포인터를 포함 할 수있는 메모리로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="14f517123cdd1f4b658824c0835eb8cdf537909f" translate="yes" xml:space="preserve">
          <source>If you want to get NaN as a result if a NaN is present in the range, you can use &lt;a href=&quot;std.algorithm_iteration#fold&quot;&gt;&lt;code&gt;std.algorithm.iteration.fold&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;std_math#isNaN&quot;&gt;&lt;code&gt;std.math.isNaN&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">NaN이 범위에있는 경우 결과로 NaN을 얻으려면 &lt;a href=&quot;std.algorithm_iteration#fold&quot;&gt; &lt;code&gt;std.algorithm.iteration.fold&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;std_math#isNaN&quot;&gt; &lt;code&gt;std.math.isNaN&lt;/code&gt; 을&lt;/a&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0c8308d29073b832847e261fe8f0df371b23a239" translate="yes" xml:space="preserve">
          <source>If you want to ignore NaNs, you can use &lt;a href=&quot;std_algorithm_iteration#filter&quot;&gt;&lt;code&gt;std.algorithm.iteration.filter&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;std_math#isNaN&quot;&gt;&lt;code&gt;std.math.isNaN&lt;/code&gt;&lt;/a&gt; to remove them, before applying minElement. Add a suitable seed, to avoid error messages if all elements are NaNs:</source>
          <target state="translated">NaN을 무시하려면 &lt;a href=&quot;std_algorithm_iteration#filter&quot;&gt; &lt;code&gt;std.algorithm.iteration.filter&lt;/code&gt; &lt;/a&gt; 를 적용하기 전에 std.algorithm.iteration.filter 및 &lt;a href=&quot;std_math#isNaN&quot;&gt; &lt;code&gt;std.math.isNaN&lt;/code&gt; &lt;/a&gt; 을 사용 하여 제거 할 수 있습니다 . 모든 요소가 NaN 인 경우 오류 메시지를 방지하려면 적절한 시드를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="50a53d6760e4f33109326a6a1af782ed05797935" translate="yes" xml:space="preserve">
          <source>If:</source>
          <target state="translated">If:</target>
        </trans-unit>
        <trans-unit id="b2403005179997fdecfad41d075986e0dccac0e9" translate="yes" xml:space="preserve">
          <source>IfStatement</source>
          <target state="translated">IfStatement</target>
        </trans-unit>
        <trans-unit id="859704f6d767666630d7b805196cab9e15bc787d" translate="yes" xml:space="preserve">
          <source>IgnoreXXXX</source>
          <target state="translated">IgnoreXXXX</target>
        </trans-unit>
        <trans-unit id="78eb97c1d35a57cc7692fed2d6ffb3818790b0e0" translate="yes" xml:space="preserve">
          <source>Ignored mismatches are:</source>
          <target state="translated">무시 된 불일치는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ba5ba167a98858b40c030856aa4aacb94b020392" translate="yes" xml:space="preserve">
          <source>Ignores C-style / D-style variadic arguments.</source>
          <target state="translated">C 스타일 / D 스타일 가변성 인수를 무시합니다.</target>
        </trans-unit>
        <trans-unit id="09e871c98fef3b901a775def173e4126aaf73b42" translate="yes" xml:space="preserve">
          <source>Images</source>
          <target state="translated">Images</target>
        </trans-unit>
        <trans-unit id="ed701420e7f5e55b19ea82ee452968a59b8615ea" translate="yes" xml:space="preserve">
          <source>Images have the same form as reference or inline links, but add an exclamation point &lt;code&gt;!&lt;/code&gt; before the initial square bracket. What would be the link text in a normal link is used as the image's alt text.</source>
          <target state="translated">이미지는 참조 또는 인라인 링크와 동일한 형식이지만 느낌표를 추가하십시오 &lt;code&gt;!&lt;/code&gt; 초기 대괄호 앞에. 일반 링크에서 링크 텍스트는 이미지의 대체 텍스트로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="da8a47e84bd95dd590801199a512c81712152ddc" translate="yes" xml:space="preserve">
          <source>Immediately after the range argument, an optional work unit size argument may be provided. Work units as used by &lt;code&gt;amap&lt;/code&gt; are identical to those defined for parallel foreach. If no work unit size is provided, the default work unit size is used.</source>
          <target state="translated">범위 인수 직후에 선택적 작업 단위 크기 인수가 제공 될 수 있습니다. &lt;code&gt;amap&lt;/code&gt; 사용 된 작업 단위는 병렬 foreach에 대해 정의 된 것과 동일합니다. 작업 단위 크기가 제공되지 않으면 기본 작업 단위 크기가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="79fa62caeafe3bd4c17315583aef1c8a23c5d46e" translate="yes" xml:space="preserve">
          <source>Immediately drop any connections and release socket resources. The &lt;code&gt;Socket&lt;/code&gt; object is no longer usable after &lt;code&gt;close&lt;/code&gt;. Calling &lt;code&gt;shutdown&lt;/code&gt; before &lt;code&gt;close&lt;/code&gt; is recommended for connection-oriented sockets.</source>
          <target state="translated">즉시 연결을 끊고 소켓 리소스를 해제하십시오. &lt;code&gt;Socket&lt;/code&gt; 객체는 더 이상 후 사용할 수 없다 &lt;code&gt;close&lt;/code&gt; . 연결 지향 소켓의 경우 &lt;code&gt;close&lt;/code&gt; 전에 호출 &lt;code&gt;shutdown&lt;/code&gt; 를 권장합니다.</target>
        </trans-unit>
        <trans-unit id="1473effc3e4965950f77d9acee523d95bdbf4b42" translate="yes" xml:space="preserve">
          <source>Immutability is transitive, meaning it applies to anything that can be referenced from the immutable type:</source>
          <target state="translated">불변성은 전 이적이며 불변 유형에서 참조 할 수있는 모든 것에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="a3901c3fc3cbd4dda7d4b5cdbdfb146ab629c087" translate="yes" xml:space="preserve">
          <source>Immutable Member Functions</source>
          <target state="translated">불변 멤버 함수</target>
        </trans-unit>
        <trans-unit id="31b83cfa7707372a1c66b40c2bffbc19a9e85eb7" translate="yes" xml:space="preserve">
          <source>Immutable Storage Class</source>
          <target state="translated">불변 스토리지 클래스</target>
        </trans-unit>
        <trans-unit id="bad427b56d48a9c0418ac178e3b7e5501dbeffb2" translate="yes" xml:space="preserve">
          <source>Immutable Type</source>
          <target state="translated">불변 유형</target>
        </trans-unit>
        <trans-unit id="7a41b36410af31e02780ae8ef8f795b4c7e5c218" translate="yes" xml:space="preserve">
          <source>Immutable associative arrays are often desirable, but sometimes initialization must be done at runtime. This can be achieved with a constructor (static constructor depending on scope), a buffer associative array and &lt;code&gt;assumeUnique&lt;/code&gt;:</source>
          <target state="translated">불변의 연관 배열이 종종 바람직하지만 때로는 런타임에 초기화를 수행해야합니다. 이것은 생성자 (범위에 따라 정적 생성자), 버퍼 연관 배열 및 &lt;code&gt;assumeUnique&lt;/code&gt; 로 달성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1060492cd68308e42ab0d863274ead4d94e73c72" translate="yes" xml:space="preserve">
          <source>Immutable declarations can appear as lvalues, i.e. they can have their address taken, and occupy storage.</source>
          <target state="translated">변경 불가능한 선언은 lvalue로 표시 될 수 있습니다. 즉, 주소를 가져오고 스토리지를 차지할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="97deddbfb05296e5d5f6c89e8255f2cf73fed0f1" translate="yes" xml:space="preserve">
          <source>Immutable member functions are guaranteed that the object and anything referred to by the &lt;code&gt;this&lt;/code&gt; reference is immutable. They are declared as:</source>
          <target state="translated">불변 멤버 함수는 &lt;code&gt;this&lt;/code&gt; 참조에서 참조 하는 객체와 무엇이든 불변임을 보장합니다 . 그들은 다음과 같이 선언됩니다.</target>
        </trans-unit>
        <trans-unit id="fab70056c0a3ce1186e48366f6111f2b7210dc49" translate="yes" xml:space="preserve">
          <source>Immutable memory locations</source>
          <target state="translated">불변 메모리 위치</target>
        </trans-unit>
        <trans-unit id="7ca47511da5cd25a571e0550ee9181f060e3ad8e" translate="yes" xml:space="preserve">
          <source>Immutable used as a storage class is equivalent to using immutable as a type qualifier for the entire type of a declaration:</source>
          <target state="translated">스토리지 클래스로 사용되는 변경 불가능은 선언의 전체 유형에 대해 유형 한정자로 변경 불가능을 사용하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8cc79f379fb076727af30671cff8e81a7a78ac8f" translate="yes" xml:space="preserve">
          <source>Imperial Aramaic</source>
          <target state="translated">임페리얼 아람어</target>
        </trans-unit>
        <trans-unit id="f115c5f2dd3a1366bda08a49baad63fd02afde98" translate="yes" xml:space="preserve">
          <source>Imperial_Aramaic</source>
          <target state="translated">Imperial_Aramaic</target>
        </trans-unit>
        <trans-unit id="015f00e67a839cb58bb4f25641353bc270b1dc50" translate="yes" xml:space="preserve">
          <source>Impl* &lt;strong id=&quot;_d_assocarrayliteralTX&quot;&gt;_d_assocarrayliteralTX&lt;/strong&gt;(const TypeInfo_AssociativeArray ti, void[] keys, void[] vals);</source>
          <target state="translated">IMPL * &lt;strong id=&quot;_d_assocarrayliteralTX&quot;&gt;_d_assocarrayliteralTX&lt;/strong&gt; (CONST TypeInfo_AssociativeArray TI 무효 [] 키 무효 [] 발스);</target>
        </trans-unit>
        <trans-unit id="00b783520a8a2fbc5645a580ba36a3a286254053" translate="yes" xml:space="preserve">
          <source>Implementation Details</source>
          <target state="translated">구현 세부 사항</target>
        </trans-unit>
        <trans-unit id="4bd31434dd702d78584ad36682fd4ce02cbe35f9" translate="yes" xml:space="preserve">
          <source>Implementation helpers</source>
          <target state="translated">구현 도우미</target>
        </trans-unit>
        <trans-unit id="cdc8095e33689a7350a694bb991dc5449ed4cc80" translate="yes" xml:space="preserve">
          <source>Implementation note: Many vector operations are expected to take advantage of any vector math instructions available on the target computer.</source>
          <target state="translated">구현 노트 : 많은 벡터 연산은 대상 컴퓨터에서 사용 가능한 벡터 수학 명령을 활용할 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="4f7fc9a2d05fa0c5c4b7879d385797376ea8299d" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;code&gt;IAllocator&lt;/code&gt; using &lt;code&gt;Allocator&lt;/code&gt;. This adapts a statically-built allocator type to &lt;code&gt;IAllocator&lt;/code&gt; that is directly usable by non-templated code.</source>
          <target state="translated">구현 &lt;code&gt;IAllocator&lt;/code&gt; 사용하여 &lt;code&gt;Allocator&lt;/code&gt; . 이는 정적으로 빌드 된 할당 자 유형을 템플릿이 아닌 코드에서 직접 사용할 수있는 &lt;code&gt;IAllocator&lt;/code&gt; 에 적용 합니다.</target>
        </trans-unit>
        <trans-unit id="fafacd0c4afbb4ff4bf1edadf17fafe457e3c87e" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;code&gt;ISharedAllocator&lt;/code&gt; using &lt;code&gt;Allocator&lt;/code&gt;. This adapts a statically-built, shareable across threads, allocator type to &lt;code&gt;ISharedAllocator&lt;/code&gt; that is directly usable by non-templated code.</source>
          <target state="translated">구현 &lt;code&gt;ISharedAllocator&lt;/code&gt; 사용하여 &lt;code&gt;Allocator&lt;/code&gt; . 이것은 정적으로 구축되고 스레드에서 공유 가능한 할당 자 유형을 템플릿이 아닌 코드에서 직접 사용할 수있는 &lt;code&gt;ISharedAllocator&lt;/code&gt; 에 적용 합니다.</target>
        </trans-unit>
        <trans-unit id="bcbaffe82dd8f12aeaf4d1ff9d3011fef84404a6" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;code&gt;_d_arrayappendT&lt;/code&gt; and &lt;code&gt;_d_arrayappendTTrace&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;_d_arrayappendT&lt;/code&gt; 및 &lt;code&gt;_d_arrayappendTTrace&lt;/code&gt; 구현</target>
        </trans-unit>
        <trans-unit id="b10e497f26133fe54aedbc1b0186f76a3533b685" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;code&gt;_d_arrayappendcTX&lt;/code&gt; and &lt;code&gt;_d_arrayappendcTXTrace&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;_d_arrayappendcTX&lt;/code&gt; 및 &lt;code&gt;_d_arrayappendcTXTrace&lt;/code&gt; 의 구현</target>
        </trans-unit>
        <trans-unit id="7db4a8478e7cad025fd1104c777c36390076d0e1" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;code&gt;_d_arraycatnTX&lt;/code&gt; and &lt;code&gt;_d_arraycatnTXTrace&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;_d_arraycatnTX&lt;/code&gt; 및 &lt;code&gt;_d_arraycatnTXTrace&lt;/code&gt; 의 구현</target>
        </trans-unit>
        <trans-unit id="8abbaa69f0e232671973ab5e6491f136e6a29871" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;code&gt;_d_arraysetlengthT&lt;/code&gt; and &lt;code&gt;_d_arraysetlengthTTrace&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;_d_arraysetlengthT&lt;/code&gt; 및 &lt;code&gt;_d_arraysetlengthTTrace&lt;/code&gt; 의 구현</target>
        </trans-unit>
        <trans-unit id="6f9ad487b035fc97c0af04b8b66abb8578971a5f" translate="yes" xml:space="preserve">
          <source>Implementation of a &lt;a href=&quot;https://en.wikipedia.org/wiki/Red%E2%80%93black_tree&quot;&gt; red-black tree&lt;/a&gt; container.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Red%E2%80%93black_tree&quot;&gt;레드-블랙 트리&lt;/a&gt; 컨테이너의 구현 .</target>
        </trans-unit>
        <trans-unit id="8e7df8ae1e56f997a5b65b6b6877c23f0d64f3a3" translate="yes" xml:space="preserve">
          <source>Implementation of alloca() standard C routine.</source>
          <target state="translated">alloca () 표준 C 루틴 구현.</target>
        </trans-unit>
        <trans-unit id="1784dc78d2b897ccf07f36701bfc5665f7a4b791" translate="yes" xml:space="preserve">
          <source>Implementation of array assignment support routines.</source>
          <target state="translated">배열 할당 지원 루틴 구현</target>
        </trans-unit>
        <trans-unit id="a39c70c382be4565515493d462dbbec04eaf7781" translate="yes" xml:space="preserve">
          <source>Implementation of array copy support routines.</source>
          <target state="translated">어레이 복사 지원 루틴 구현</target>
        </trans-unit>
        <trans-unit id="0bdc6417eff40a113a2fe81fc65ab41a4dcaba32" translate="yes" xml:space="preserve">
          <source>Implementation of associative arrays.</source>
          <target state="translated">연관 배열의 구현.</target>
        </trans-unit>
        <trans-unit id="07784c9ff6fc80ea8be9db66531869c595761785" translate="yes" xml:space="preserve">
          <source>Implementation of code coverage analyzer.</source>
          <target state="translated">코드 커버리지 분석기 구현</target>
        </trans-unit>
        <trans-unit id="fad1778f18239a1620ff2a279ed8dce89c92aba4" translate="yes" xml:space="preserve">
          <source>Implementation of dynamic array property support routines.</source>
          <target state="translated">동적 배열 속성 지원 루틴 구현</target>
        </trans-unit>
        <trans-unit id="1c44b949de0c9066379af30ba926638e5089c3a0" translate="yes" xml:space="preserve">
          <source>Implementation of exception handling support routines for Win32.</source>
          <target state="translated">Win32에 대한 예외 처리 지원 루틴 구현</target>
        </trans-unit>
        <trans-unit id="7d3ce3a8f354f9946b2098d37781419df42c1fa9" translate="yes" xml:space="preserve">
          <source>Implementation of exception handling support routines.</source>
          <target state="translated">예외 처리 지원 루틴 구현</target>
        </trans-unit>
        <trans-unit id="4262710c1f4443ad04091f6eaee82248c8735a23" translate="yes" xml:space="preserve">
          <source>Implementation of invariant support routines.</source>
          <target state="translated">변하지 않는 지원 루틴의 구현.</target>
        </trans-unit>
        <trans-unit id="3dad8ae42692f0a5067da5335623cc0faae36caa" translate="yes" xml:space="preserve">
          <source>Implementation of standard Base64 encoding.</source>
          <target state="translated">표준 Base64 인코딩 구현.</target>
        </trans-unit>
        <trans-unit id="8bb4407a3328a42063117ac1cd37abce98147582" translate="yes" xml:space="preserve">
          <source>Implementation of support routines for synchronized blocks.</source>
          <target state="translated">동기화 된 블록에 대한 지원 루틴 구현.</target>
        </trans-unit>
        <trans-unit id="36a7e10f19e92847926357311b55d0e017f473ef" translate="yes" xml:space="preserve">
          <source>Implementations are free to assume that GC pointers are only stored on word boundaries. Unaligned pointers may be ignored entirely.</source>
          <target state="translated">구현에서는 GC 포인터가 단어 경계에만 저장되어 있다고 가정 할 수 있습니다. 정렬되지 않은 포인터는 완전히 무시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a8c2ed8c7bf790ca62a6ccc79e874d26201eb456" translate="yes" xml:space="preserve">
          <source>Implementations are free to run collections at any point. It is, however, recommendable to only do so when an allocation attempt happens and there is insufficient memory available.</source>
          <target state="translated">구현은 언제든지 컬렉션을 자유롭게 실행할 수 있습니다. 그러나 할당 시도가 발생하고 사용 가능한 메모리가 부족한 경우에만 수행하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="7bedeb01a44e9992494ae61fc2e61ab874f0844b" translate="yes" xml:space="preserve">
          <source>Implementations are free to scan the non-root heap in a precise manner, so that fields of types like &lt;code&gt;float&lt;/code&gt; will not be considered relevant when scanning the heap. Thus, casting a GC pointer to an integral type (e.g. &lt;code&gt;size_t&lt;/code&gt;) and storing it in a field of that type inside the GC heap may mean that it will not be recognized if the memory block was allocated with precise type info or with the &lt;code&gt;GC.BlkAttr.&lt;a href=&quot;#NO_SCAN&quot;&gt;NO_SCAN&lt;/a&gt;&lt;/code&gt; attribute.</source>
          <target state="translated">구현은 루트가 아닌 힙을 정확하게 스캔 할 수 있으므로 &lt;code&gt;float&lt;/code&gt; 와 같은 유형의 필드 는 힙을 스캔 할 때 관련성이없는 것으로 간주됩니다. 따라서 GC 포인터를 정수 유형 (예 : &lt;code&gt;size_t&lt;/code&gt; )으로 캐스트 하고 GC 힙 내부에서 해당 유형의 필드에 저장하면 메모리 블록에 정확한 유형 정보 또는 &lt;code&gt;GC.BlkAttr.&lt;a href=&quot;#NO_SCAN&quot;&gt;NO_SCAN&lt;/a&gt;&lt;/code&gt; 가 할당 된 경우 인식되지 않을 수 있습니다 . BlkAttr. NO_SCAN 속성.</target>
        </trans-unit>
        <trans-unit id="3fe2d13e1a38447a1ccf3bcf63459da389a3bd8d" translate="yes" xml:space="preserve">
          <source>Implementations may restrict the file name in order to avoid directory traversal security vulnerabilities. A possible restriction might be to disallow any path components in the file name.</source>
          <target state="translated">디렉토리 순회 보안 취약점을 피하기 위해 구현시 파일 이름이 제한 될 수 있습니다. 파일 이름에 경로 구성 요소를 허용하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="41da860cb79fe7312e55548bf43ef9ac07ff278f" translate="yes" xml:space="preserve">
          <source>Implementations must diagnose an error for unrecognized</source>
          <target state="translated">구현시 인식되지 않는 오류를 진단해야합니다.</target>
        </trans-unit>
        <trans-unit id="007c721ddd0f22de039d1ec5d207cce979d8d6f0" translate="yes" xml:space="preserve">
          <source>Implementations must support interior pointers. That is, if the only reference to a GC-managed memory block points into the middle of the block rather than the beginning (for example), the GC must consider the memory block live. The exception to this rule is when a memory block is allocated with the &lt;code&gt;GC.BlkAttr.&lt;a href=&quot;#NO_INTERIOR&quot;&gt;NO_INTERIOR&lt;/a&gt;&lt;/code&gt; attribute; it is the user's responsibility to make sure such memory blocks have a proper pointer to them when they should be considered live.</source>
          <target state="translated">구현은 내부 포인터를 지원해야합니다. 즉, GC 관리 메모리 블록에 대한 유일한 참조가 시작이 아닌 블록의 중간을 가리키는 경우 (예 :) GC는 메모리 블록을 라이브로 간주해야합니다. 이 규칙의 예외는 메모리 블록이 &lt;code&gt;GC.BlkAttr.&lt;a href=&quot;#NO_INTERIOR&quot;&gt;NO_INTERIOR&lt;/a&gt;&lt;/code&gt; 로 할당 된 경우 입니다. NO_INTERIOR 속성; 그러한 메모리 블록이 실시간으로 간주 될 때 해당 메모리 블록에 대한 적절한 포인터를 갖는 것은 사용자의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="db108dbc2de097787f6ddeb0832f02909642f907" translate="yes" xml:space="preserve">
          <source>Implementations of D on different architectures, however, are free to innovate upon the memory model, function call/return conventions, argument passing conventions, etc.</source>
          <target state="translated">그러나 다른 아키텍처에서 D를 구현하면 메모리 모델, 함수 호출 / 반환 규칙, 인수 전달 규칙 등을 자유롭게 혁신 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7a03fc44da9f306060241398ee57db5f3a7d7aa" translate="yes" xml:space="preserve">
          <source>Implemented using &lt;code&gt;pthread_mutex&lt;/code&gt; and &lt;code&gt;pthread_condition&lt;/code&gt; on Posix and &lt;code&gt;CreateEvent&lt;/code&gt; and &lt;code&gt;SetEvent&lt;/code&gt; on Windows.</source>
          <target state="translated">Posix에서 &lt;code&gt;pthread_mutex&lt;/code&gt; 및 &lt;code&gt;pthread_condition&lt;/code&gt; 을 사용 하고 Windows에서 &lt;code&gt;CreateEvent&lt;/code&gt; 및 &lt;code&gt;SetEvent&lt;/code&gt; 를 사용하여 구현 되었습니다.</target>
        </trans-unit>
        <trans-unit id="9e4c63b7ecbb7ff73a2154a224607de77b4347f8" translate="yes" xml:space="preserve">
          <source>Implemented using &lt;code&gt;pthread_mutex&lt;/code&gt; on Posix and &lt;code&gt;CRITICAL_SECTION&lt;/code&gt; on Windows.</source>
          <target state="translated">Posix에서 &lt;code&gt;pthread_mutex&lt;/code&gt; 를 사용 하고 Windows에서 &lt;code&gt;CRITICAL_SECTION&lt;/code&gt; 을 사용하여 구현했습니다 .</target>
        </trans-unit>
        <trans-unit id="cf9e08c7271694a3ffd216903295953184c6b554" translate="yes" xml:space="preserve">
          <source>Implementing a Scheduler allows the concurrency mechanism used by this module to be customized according to different needs. By default, a call to spawn will create a new kernel thread that executes the supplied routine and terminates when finished. But it is possible to create Schedulers that reuse threads, that multiplex Fibers (coroutines) across a single thread, or any number of other approaches. By making the choice of Scheduler a user-level option, std.concurrency may be used for far more types of application than if this behavior were predefined.</source>
          <target state="translated">스케줄러를 구현하면이 모듈에서 사용하는 동시성 메커니즘을 다양한 요구에 따라 사용자 정의 할 수 있습니다. 기본적으로 스폰을 호출하면 제공된 루틴을 실행하고 완료되면 종료되는 새 커널 스레드가 작성됩니다. 그러나 스레드를 재사용하는 스케줄러, 단일 스레드에서 멀티 플렉스 파이버 (코 루틴) 또는 기타 여러 가지 접근 방식을 작성할 수 있습니다. 스케줄러를 사용자 레벨 옵션으로 선택하면 std.concurrency는이 동작이 사전 정의 된 것보다 훨씬 더 많은 유형의 응용 프로그램에 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b264d3336b750c35148a8818568f62fa13927441" translate="yes" xml:space="preserve">
          <source>Implements 3-way comparisons of &lt;code&gt;BigInt&lt;/code&gt; with &lt;code&gt;BigInt&lt;/code&gt; or &lt;code&gt;BigInt&lt;/code&gt; with built-in integers.</source>
          <target state="translated">의 구현은 3 방향 비교 &lt;code&gt;BigInt&lt;/code&gt; 과 &lt;code&gt;BigInt&lt;/code&gt; 또는 &lt;code&gt;BigInt&lt;/code&gt; 내장의 정수를.</target>
        </trans-unit>
        <trans-unit id="743a0f20b096bcb05c253ba31f822dbd89e201db" translate="yes" xml:space="preserve">
          <source>Implements 3-way comparisons of &lt;code&gt;BigInt&lt;/code&gt; with &lt;code&gt;BigInt&lt;/code&gt; or &lt;code&gt;BigInt&lt;/code&gt; with built-in numeric types.</source>
          <target state="translated">의 구현은 3 방향 비교 &lt;code&gt;BigInt&lt;/code&gt; 과 &lt;code&gt;BigInt&lt;/code&gt; 또는 &lt;code&gt;BigInt&lt;/code&gt; 내장의 숫자 유형.</target>
        </trans-unit>
        <trans-unit id="ff4e8dcbc761da7358b8c9aa098a3c08bb0a396c" translate="yes" xml:space="preserve">
          <source>Implements &lt;code&gt;BigInt&lt;/code&gt; equality test with other &lt;code&gt;BigInt&lt;/code&gt;'s and built-in integer types.</source>
          <target state="translated">다른 &lt;code&gt;BigInt&lt;/code&gt; 및 내장 정수 유형으로 &lt;code&gt;BigInt&lt;/code&gt; 동등성 테스트를 구현 합니다.</target>
        </trans-unit>
        <trans-unit id="e054a06d7d946c45c195d9bbf3b1556b4724d8bb" translate="yes" xml:space="preserve">
          <source>Implements &lt;code&gt;BigInt&lt;/code&gt; equality test with other &lt;code&gt;BigInt&lt;/code&gt;'s and built-in numeric types.</source>
          <target state="translated">다른 &lt;code&gt;BigInt&lt;/code&gt; 및 내장 숫자 유형으로 &lt;code&gt;BigInt&lt;/code&gt; 동등성 테스트를 구현 합니다.</target>
        </trans-unit>
        <trans-unit id="7ca26966771a4b63b83cfa749d58cb4c74bd1074" translate="yes" xml:space="preserve">
          <source>Implements &lt;code&gt;BigInt&lt;/code&gt; unary operators.</source>
          <target state="translated">&lt;code&gt;BigInt&lt;/code&gt; 단항 연산자를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="6a3cb51c99d7f39233c1830869fb1b564b310297" translate="yes" xml:space="preserve">
          <source>Implements a &quot;tee&quot; style pipe, wrapping an input range so that elements of the range can be passed to a provided function or &lt;a href=&quot;#OutputRange&quot;&gt;&lt;code&gt;OutputRange&lt;/code&gt;&lt;/a&gt; as they are iterated over. This is useful for printing out intermediate values in a long chain of range code, performing some operation with side-effects on each call to &lt;code&gt;front&lt;/code&gt; or &lt;code&gt;popFront&lt;/code&gt;, or diverting the elements of a range into an auxiliary &lt;a href=&quot;#OutputRange&quot;&gt;&lt;code&gt;OutputRange&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&quot;tee&quot;스타일 파이프를 구현하여 입력 범위를 감싸서 범위의 요소 가 반복되는 동안 제공된 함수 또는 &lt;a href=&quot;#OutputRange&quot;&gt; &lt;code&gt;OutputRange&lt;/code&gt; 에&lt;/a&gt; 전달 될 수 있도록 합니다. 이는 긴 범위의 체인 코드에서 중간 값을 인쇄 하거나 , &lt;code&gt;front&lt;/code&gt; 또는 &lt;code&gt;popFront&lt;/code&gt; 를 호출 할 때마다 부작용으로 일부 작업을 수행 하거나 , 범위의 요소를 보조 &lt;a href=&quot;#OutputRange&quot;&gt; &lt;code&gt;OutputRange&lt;/code&gt; &lt;/a&gt; 로 전환하는 데 유용 합니다.</target>
        </trans-unit>
        <trans-unit id="edd807624e1eff53b60fc0fdcb84a1a01a914908" translate="yes" xml:space="preserve">
          <source>Implements a &lt;a href=&quot;http://en.wikipedia.org/wiki/Binary_heap&quot;&gt;binary heap&lt;/a&gt; container on top of a given random-access range type (usually &lt;code&gt;T[]&lt;/code&gt;) or a random-access container type (usually &lt;code&gt;Array!T&lt;/code&gt;). The documentation of &lt;code&gt;BinaryHeap&lt;/code&gt; will refer to the underlying range or container as the</source>
          <target state="translated">지정된 임의 액세스 범위 유형 (일반적으로 &lt;code&gt;T[]&lt;/code&gt; ) 또는 임의 액세스 컨테이너 유형 (일반적으로 &lt;code&gt;Array!T&lt;/code&gt; ) 위에 &lt;a href=&quot;http://en.wikipedia.org/wiki/Binary_heap&quot;&gt;이진 힙&lt;/a&gt; 컨테이너를 구현합니다 . &lt;code&gt;BinaryHeap&lt;/code&gt; 의 문서는 기본 범위 또는 컨테이너를</target>
        </trans-unit>
        <trans-unit id="82fd6f5782d0c35176812025a3c5512d4a3f76e8" translate="yes" xml:space="preserve">
          <source>Implements a &lt;a href=&quot;https://en.wikipedia.org/wiki/Binary_heap&quot;&gt;binary heap&lt;/a&gt; container on top of a given random-access range type (usually &lt;code&gt;T[]&lt;/code&gt;) or a random-access container type (usually &lt;code&gt;Array!T&lt;/code&gt;). The documentation of &lt;code&gt;BinaryHeap&lt;/code&gt; will refer to the underlying range or container as the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="826e19cc42c27271edbc14035290489f9b886abe" translate="yes" xml:space="preserve">
          <source>Implements a doubly-linked list.</source>
          <target state="translated">이중 연결 목록을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="6c4a9e8241b5f111ea434df2fe96c036c8c94979" translate="yes" xml:space="preserve">
          <source>Implements a narrowing remainder operation with built-in integer types.</source>
          <target state="translated">내장 정수 유형으로 좁히는 나머지 연산을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="27ed74a2d7c34a4b3c0b18b681929b4fe9236374" translate="yes" xml:space="preserve">
          <source>Implements a parallel foreach loop over a range. This works by implicitly creating and submitting one &lt;code&gt;Task&lt;/code&gt; to the &lt;code&gt;TaskPool&lt;/code&gt; for each worker thread. A work unit is a set of consecutive elements of &lt;code&gt;range&lt;/code&gt; to be processed by a worker thread between communication with any other thread. The number of elements processed per work unit is controlled by the &lt;code&gt;workUnitSize&lt;/code&gt; parameter. Smaller work units provide better load balancing, but larger work units avoid the overhead of communicating with other threads frequently to fetch the next work unit. Large work units also avoid false sharing in cases where the range is being modified. The less time a single iteration of the loop takes, the larger &lt;code&gt;workUnitSize&lt;/code&gt; should be. For very expensive loop bodies, &lt;code&gt;workUnitSize&lt;/code&gt; should be 1. An overload that chooses a default work unit size is also available.</source>
          <target state="translated">범위에 대해 병렬 foreach 루프를 구현합니다. 이것은 각 작업자 스레드에 대해 하나의 &lt;code&gt;Task&lt;/code&gt; 을 암시 적으로 생성 하여 &lt;code&gt;TaskPool&lt;/code&gt; 에 제출함으로써 작동 합니다. 작업 단위는 다른 스레드와의 통신 사이에 작업자 스레드가 처리 할 &lt;code&gt;range&lt;/code&gt; 의 연속 요소 집합입니다 . 작업 단위당 처리되는 요소 수는 &lt;code&gt;workUnitSize&lt;/code&gt; 매개 변수에 의해 제어됩니다 . 작은 작업 단위는 더 나은로드 밸런싱을 제공하지만 더 큰 작업 단위는 다음 작업 단위를 페치하기 위해 다른 스레드와 자주 통신하는 오버 헤드를 피합니다. 또한 큰 작업 단위는 범위를 수정하는 경우 허위 공유를 피합니다. 루프의 단일 반복에 걸리는 시간이 짧을수록 더 큰 &lt;code&gt;workUnitSize&lt;/code&gt; 해야한다. 매우 비싼 루프 바디의 경우 &lt;code&gt;workUnitSize&lt;/code&gt; 는 1이어야합니다. 기본 작업 단위 크기를 선택하는 과부하도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="826fe4a31de6fc5bfd32223112c616b546ef30ea" translate="yes" xml:space="preserve">
          <source>Implements a simple and fast singly-linked list. It can be used as a stack.</source>
          <target state="translated">간단하고 빠른 단일 연결 목록을 구현합니다. 스택으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e7f8a9f41236aa959250c83a21042416cfb7001" translate="yes" xml:space="preserve">
          <source>Implements an output range that appends data to an array. This is recommended over &lt;code&gt;array ~= data&lt;/code&gt; when appending many elements because it is more efficient. &lt;code&gt;Appender&lt;/code&gt; maintains its own array metadata locally, so it can avoid global locking for each append where &lt;a href=&quot;#capacity&quot;&gt;&lt;code&gt;capacity&lt;/code&gt;&lt;/a&gt; is non-zero.</source>
          <target state="translated">데이터를 배열에 추가하는 출력 범위를 구현합니다. 많은 요소를 추가 할 때 &lt;code&gt;array ~= data&lt;/code&gt; 보다 효율적이므로 권장 됩니다. &lt;code&gt;Appender&lt;/code&gt; 는 자체 배열 메타 데이터를 로컬로 유지하므로 &lt;a href=&quot;#capacity&quot;&gt; &lt;code&gt;capacity&lt;/code&gt; &lt;/a&gt; 이 0이 아닌 각 추가에 대한 전역 잠금을 피할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="eb1006ae1765bc7db00ba2578ee369f0e577a7bc" translate="yes" xml:space="preserve">
          <source>Implements assignment operators from built-in integers of the form &lt;code&gt;BigInt op= integer&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;BigInt op= integer&lt;/code&gt; 형식의 내장 정수에서 대입 연산자를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="a6bf741a9ca55b772fcf287918db9b994810ba0a" translate="yes" xml:space="preserve">
          <source>Implements assignment operators of the form &lt;code&gt;BigInt op= BigInt&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;BigInt op= BigInt&lt;/code&gt; 형식의 대입 연산자를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="e1ea709e7bbd408cd7bf94a6f215f7f14ae10aa2" translate="yes" xml:space="preserve">
          <source>Implements binary operators between &lt;code&gt;BigInt&lt;/code&gt;'s and built-in integers.</source>
          <target state="translated">&lt;code&gt;BigInt&lt;/code&gt; 와 내장 정수 사이에 이진 연산자를 구현 합니다.</target>
        </trans-unit>
        <trans-unit id="df47e55b92aed2a9c5b877779b4fc9382af7ea1f" translate="yes" xml:space="preserve">
          <source>Implements binary operators between &lt;code&gt;BigInt&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;BigInt&lt;/code&gt; 사이에 이진 연산자를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="c38b2eea1063f17593adb5371b20a04e888bc589" translate="yes" xml:space="preserve">
          <source>Implements casting to &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;bool&lt;/code&gt; 캐스팅을 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="6ee42dc119af151bac3c17e9bd85af0bb4e977a1" translate="yes" xml:space="preserve">
          <source>Implements casting to floating point types.</source>
          <target state="translated">부동 소수점 형식으로 캐스팅을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="612c7a1e4ee8aa3a5eb36e62f5d1886edb7c32a6" translate="yes" xml:space="preserve">
          <source>Implements casting to integer types.</source>
          <target state="translated">정수 유형으로 캐스트를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="d027822363fbfc370a577e3a5cc7b4b903013cad" translate="yes" xml:space="preserve">
          <source>Implements casting to/from qualified &lt;code&gt;BigInt&lt;/code&gt;'s.</source>
          <target state="translated">적격 &lt;code&gt;BigInt&lt;/code&gt; 와의 캐스트를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="ff4cc4fdb32d0e79c9536f6d66d8396bbf61c41a" translate="yes" xml:space="preserve">
          <source>Implements common functionality for StaticForeachDeclaration and StaticForeachStatement This performs the necessary lowerings before dmd.statementsem.makeTupleForeach can be used to expand the corresponding &lt;code&gt;static foreach&lt;/code&gt; declaration or statement.</source>
          <target state="translated">StaticForeachDeclaration 및 StaticForeachStatement에 대한 공통 기능 구현 이는 dmd.statementsem.makeTupleForeach를 사용하여 해당 &lt;code&gt;static foreach&lt;/code&gt; 선언 또는 명령문 을 확장하기 전에 필요한 낮추기를 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="33e291a05be91fd5868ef9b486e72f36172b61e4" translate="yes" xml:space="preserve">
          <source>Implements functionality to read Comma Separated Values and its variants from an &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; of &lt;code&gt;dchar&lt;/code&gt;.</source>
          <target state="translated">콤마를 읽는 기능은 이물질의 값과 그 변형을 구분 &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;입력 범위&lt;/a&gt; 의 &lt;code&gt;dchar&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e78fb12359a92b10736f7ddffd604a688feb1037" translate="yes" xml:space="preserve">
          <source>Implements logging facilities.</source>
          <target state="translated">로깅 기능을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="1c9526ff0c5c9d17f08ea2d94e25202e075b8278" translate="yes" xml:space="preserve">
          <source>Implements low-level time primitives.</source>
          <target state="translated">저수준 시간 프리미티브를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="f10aa3fdc814d436934036f8b3d2932b2c1a116c" translate="yes" xml:space="preserve">
          <source>Implements mixin types.</source>
          <target state="translated">믹스 인 유형을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="5720cf3a68f9171f96627020e4e3f8a88a48971a" translate="yes" xml:space="preserve">
          <source>Implements operators with built-in integers on the left-hand side and &lt;code&gt;BigInt&lt;/code&gt; on the right-hand side.</source>
          <target state="translated">왼쪽에 내장 정수 가 있고 오른쪽에 &lt;code&gt;BigInt&lt;/code&gt; 가있는 연산자를 구현 합니다.</target>
        </trans-unit>
        <trans-unit id="7e5de803b2338c86b3532da481b13f228f6a981e" translate="yes" xml:space="preserve">
          <source>Implements routines related to exceptions.</source>
          <target state="translated">예외와 관련된 루틴을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="f320bc582113b4cafa3cdb495549c72756dd174e" translate="yes" xml:space="preserve">
          <source>Implements saturation for operators &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt; (unary and binary), &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;%&lt;/code&gt;, &lt;code&gt;^^&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">연산자 &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;-&lt;/code&gt; (단항 및 이진), &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;/&lt;/code&gt; , &lt;code&gt;%&lt;/code&gt; , &lt;code&gt;^^&lt;/code&gt; , &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;|&lt;/code&gt; , &lt;code&gt;^&lt;/code&gt; , &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="12ddcd2c7713838aaff094e0d8442224022b567f" translate="yes" xml:space="preserve">
          <source>Implements saturation for operators &lt;code&gt;+=&lt;/code&gt;, &lt;code&gt;-=&lt;/code&gt;, &lt;code&gt;*=&lt;/code&gt;, &lt;code&gt;/=&lt;/code&gt;, &lt;code&gt;%=&lt;/code&gt;, &lt;code&gt;^^=&lt;/code&gt;, &lt;code&gt;&amp;amp;=&lt;/code&gt;, &lt;code&gt;|=&lt;/code&gt;, &lt;code&gt;^=&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt;, and &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;=&lt;/code&gt;. This hook is called if the result of the binary operation does not fit in &lt;code&gt;Lhs&lt;/code&gt; without loss of information or a change in sign.</source>
          <target state="translated">연산자 &lt;code&gt;+=&lt;/code&gt; , &lt;code&gt;-=&lt;/code&gt; , &lt;code&gt;*=&lt;/code&gt; , &lt;code&gt;/=&lt;/code&gt; , &lt;code&gt;%=&lt;/code&gt; , &lt;code&gt;^^=&lt;/code&gt; , &lt;code&gt;&amp;amp;=&lt;/code&gt; , &lt;code&gt;|=&lt;/code&gt; , &lt;code&gt;^=&lt;/code&gt; , &lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;=&lt;/code&gt; 연산자의 채도를 구현 합니다. 이진 연산 결과 가 정보 손실이나 부호 변경없이 &lt;code&gt;Lhs&lt;/code&gt; 에 맞지 않으면이 후크가 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="be45676fa18a18d1d8737b834959d03a5f13376c" translate="yes" xml:space="preserve">
          <source>Implements the 'common' IEEE CRC32 variant (LSB-first order, Initial value uint.max, complement result)</source>
          <target state="translated">'공통'IEEE CRC32 변형 (LSB-first order, 초기 값 uint.max, 보완 결과) 구현</target>
        </trans-unit>
        <trans-unit id="c54fb55bf997400be69c40f0614b3e9b7db9616f" translate="yes" xml:space="preserve">
          <source>Implements the &lt;a href=&quot;http://tinyurl.com/2zb9yr&quot;&gt;secant method&lt;/a&gt; for finding a root of the function &lt;code&gt;fun&lt;/code&gt; starting from points &lt;code&gt;[xn_1, x_n]&lt;/code&gt; (ideally close to the root). &lt;code&gt;Num&lt;/code&gt; may be &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, or &lt;code&gt;real&lt;/code&gt;.</source>
          <target state="translated">점 &lt;code&gt;[xn_1, x_n]&lt;/code&gt; (이상적으로 근에 가까운) 에서 시작 하여 함수 &lt;code&gt;fun&lt;/code&gt; 의 근을 찾기위한 &lt;a href=&quot;http://tinyurl.com/2zb9yr&quot;&gt;시컨트 방법&lt;/a&gt; 을 구현합니다 . &lt;code&gt;Num&lt;/code&gt; 은 &lt;code&gt;float&lt;/code&gt; , &lt;code&gt;double&lt;/code&gt; 또는 &lt;code&gt;real&lt;/code&gt; 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a9047078944a221ccd3278b953c5e78834fbb9df" translate="yes" xml:space="preserve">
          <source>Implements the &lt;a href=&quot;https://tinyurl.com/2zb9yr&quot;&gt;secant method&lt;/a&gt; for finding a root of the function &lt;code&gt;fun&lt;/code&gt; starting from points &lt;code&gt;[xn_1, x_n]&lt;/code&gt; (ideally close to the root). &lt;code&gt;Num&lt;/code&gt; may be &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, or &lt;code&gt;real&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b80a316e588d021f8c65a6036707b88ad521159" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;OutputRange&lt;/code&gt; interface for all types E and wraps the &lt;code&gt;put&lt;/code&gt; method for each type &lt;code&gt;E&lt;/code&gt; in a virtual function.</source>
          <target state="translated">모든 유형 E에 대해 &lt;code&gt;OutputRange&lt;/code&gt; 인터페이스를 구현하고 각 유형 &lt;code&gt;E&lt;/code&gt; 에 대한 &lt;code&gt;put&lt;/code&gt; 메소드를 가상 함수로 랩핑합니다 .</target>
        </trans-unit>
        <trans-unit id="09d37307ce6ae6ae1585ab5db7a54050805cc742" translate="yes" xml:space="preserve">
          <source>Implements the MurmurHash3 functions. You can specify the &lt;code&gt;size&lt;/code&gt; of the hash in bit. For 128 bit hashes you can specify whether to optimize for 32 or 64 bit architectures. If you don't specify the &lt;code&gt;opt&lt;/code&gt; value it will select the fastest version of the host platform.</source>
          <target state="translated">MurmurHash3 기능을 구현합니다. 해시 의 &lt;code&gt;size&lt;/code&gt; 를 비트 단위 로 지정할 수 있습니다 . 128 비트 해시의 경우 32 비트 또는 64 비트 아키텍처에 대한 최적화 여부를 지정할 수 있습니다. &lt;code&gt;opt&lt;/code&gt; 값을 지정하지 않으면 가장 빠른 버전의 호스트 플랫폼이 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="7ab18d84fa65349ea46fc1a23e6ee0555763f6a9" translate="yes" xml:space="preserve">
          <source>Implements the foreach &lt;code&gt;opApply&lt;/code&gt; interface for json arrays.</source>
          <target state="translated">json 배열을위한 foreach &lt;code&gt;opApply&lt;/code&gt; 인터페이스를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="45e448d8088d50f1f95bb79e479da8d5a8f8521b" translate="yes" xml:space="preserve">
          <source>Implements the foreach &lt;code&gt;opApply&lt;/code&gt; interface for json objects.</source>
          <target state="translated">json 객체를위한 foreach &lt;code&gt;opApply&lt;/code&gt; 인터페이스를 구현 합니다.</target>
        </trans-unit>
        <trans-unit id="c7b156318387d032d75e77a645f93fbb91cfe8d1" translate="yes" xml:space="preserve">
          <source>Implements the higher order filter function. The predicate is passed to &lt;a href=&quot;std_functional#unaryFun&quot;&gt;&lt;code&gt;std.functional.unaryFun&lt;/code&gt;&lt;/a&gt;, and can either accept a string, or any callable that can be executed via &lt;code&gt;pred(element)&lt;/code&gt;.</source>
          <target state="translated">고차 필터 기능을 구현합니다. 술어는 &lt;a href=&quot;std_functional#unaryFun&quot;&gt; &lt;code&gt;std.functional.unaryFun&lt;/code&gt; 에&lt;/a&gt; 전달되며 문자열 또는 &lt;code&gt;pred(element)&lt;/code&gt; 를 통해 실행할 수있는 호출 가능 항목을 승인 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="881b721a1385bc8ef11d90c4f0aac7e1c9f98dea" translate="yes" xml:space="preserve">
          <source>Implements the homonym function (also known as &lt;code&gt;accumulate&lt;/code&gt;, &lt;code&gt;compress&lt;/code&gt;, &lt;code&gt;inject&lt;/code&gt;, or &lt;code&gt;foldl&lt;/code&gt;) present in various programming languages of functional flavor.</source>
          <target state="translated">구현 동음 이의어 기능 (라고도 &lt;code&gt;accumulate&lt;/code&gt; , &lt;code&gt;compress&lt;/code&gt; , &lt;code&gt;inject&lt;/code&gt; 또는 &lt;code&gt;foldl&lt;/code&gt; 기능성 맛 다양한 프로그래밍 언어)이 존재한다.</target>
        </trans-unit>
        <trans-unit id="2de496f11d0a61e3ec35b13526a647a0eda0aa53" translate="yes" xml:space="preserve">
          <source>Implements the homonym function (also known as &lt;code&gt;accumulate&lt;/code&gt;, &lt;code&gt;compress&lt;/code&gt;, &lt;code&gt;inject&lt;/code&gt;, or &lt;code&gt;foldl&lt;/code&gt;) present in various programming languages of functional flavor. The call &lt;code&gt;fold!(fun)(range, seed)&lt;/code&gt; first assigns &lt;code&gt;seed&lt;/code&gt; to an internal variable &lt;code&gt;result&lt;/code&gt;, also called the accumulator. Then, for each element &lt;code&gt;x&lt;/code&gt; in &lt;code&gt;range&lt;/code&gt;, &lt;code&gt;result = fun(result, x)&lt;/code&gt; gets evaluated. Finally, &lt;code&gt;result&lt;/code&gt; is returned. The one-argument version &lt;code&gt;fold!(fun)(range)&lt;/code&gt; works similarly, but it uses the first element of the range as the seed (the range must be non-empty).</source>
          <target state="translated">구현 동음 이의어 기능 (라고도 &lt;code&gt;accumulate&lt;/code&gt; , &lt;code&gt;compress&lt;/code&gt; , &lt;code&gt;inject&lt;/code&gt; 또는 &lt;code&gt;foldl&lt;/code&gt; 기능성 맛 다양한 프로그래밍 언어)이 존재한다. 콜 &lt;code&gt;fold!(fun)(range, seed)&lt;/code&gt; 먼저 &lt;code&gt;seed&lt;/code&gt; 를 내부 변수 &lt;code&gt;result&lt;/code&gt; 에 할당 합니다 (누산기라고도 함). 그리고, 각각의 요소에 대한 &lt;code&gt;x&lt;/code&gt; 의 &lt;code&gt;range&lt;/code&gt; , &lt;code&gt;result = fun(result, x)&lt;/code&gt; 평가를 얻는다. 마지막으로 &lt;code&gt;result&lt;/code&gt; 가 반환됩니다. 1 인수 버전 &lt;code&gt;fold!(fun)(range)&lt;/code&gt; 도 비슷하게 작동하지만 범위의 첫 번째 요소를 시드로 사용합니다 (범위는 비어 있지 않아야 함).</target>
        </trans-unit>
        <trans-unit id="3a102abac10f402f998c7a93f6d1ecbc38ae5d29" translate="yes" xml:space="preserve">
          <source>Implements the homonym function (also known as &lt;code&gt;accumulate&lt;/code&gt;, &lt;code&gt;compress&lt;/code&gt;, &lt;code&gt;inject&lt;/code&gt;, or &lt;code&gt;foldl&lt;/code&gt;) present in various programming languages of functional flavor. There is also &lt;a href=&quot;#fold&quot;&gt;&lt;code&gt;fold&lt;/code&gt;&lt;/a&gt; which does the same thing but with the opposite parameter order. The call &lt;code&gt;reduce!(fun)(seed, range)&lt;/code&gt; first assigns &lt;code&gt;seed&lt;/code&gt; to an internal variable &lt;code&gt;result&lt;/code&gt;, also called the accumulator. Then, for each element &lt;code&gt;x&lt;/code&gt; in &lt;code&gt;range&lt;/code&gt;, &lt;code&gt;result = fun(result, x)&lt;/code&gt; gets evaluated. Finally, &lt;code&gt;result&lt;/code&gt; is returned. The one-argument version &lt;code&gt;reduce!(fun)(range)&lt;/code&gt; works similarly, but it uses the first element of the range as the seed (the range must be non-empty).</source>
          <target state="translated">구현 동음 이의어 기능 (라고도 &lt;code&gt;accumulate&lt;/code&gt; , &lt;code&gt;compress&lt;/code&gt; , &lt;code&gt;inject&lt;/code&gt; 또는 &lt;code&gt;foldl&lt;/code&gt; 기능성 맛 다양한 프로그래밍 언어)이 존재한다. 매개 변수 순서가 반대이지만 동일한 작업을 수행하는 &lt;a href=&quot;#fold&quot;&gt; &lt;code&gt;fold&lt;/code&gt; &lt;/a&gt; 도 있습니다 . 이 호출은 &lt;code&gt;reduce!(fun)(seed, range)&lt;/code&gt; 첫 양수인의 &lt;code&gt;seed&lt;/code&gt; 내부 변수에 &lt;code&gt;result&lt;/code&gt; 도 축적했다. 그리고, 각각의 요소에 대한 &lt;code&gt;x&lt;/code&gt; 의 &lt;code&gt;range&lt;/code&gt; , &lt;code&gt;result = fun(result, x)&lt;/code&gt; 평가를 얻는다. 마지막으로 &lt;code&gt;result&lt;/code&gt; 가 반환됩니다. 1 인수 버전 &lt;code&gt;reduce!(fun)(range)&lt;/code&gt; 비슷하게 작동하지만 범위의 첫 번째 요소를 시드로 사용합니다 (범위가 비어 있지 않아야 함).</target>
        </trans-unit>
        <trans-unit id="d222f5f35083b3fe479ec859b88f2b5c2d29bc99" translate="yes" xml:space="preserve">
          <source>Implements the homonym function (also known as &lt;code&gt;transform&lt;/code&gt;) present in many languages of functional flavor. The call &lt;code&gt;map!(fun)(range)&lt;/code&gt; returns a range of which elements are obtained by applying &lt;code&gt;fun(a)&lt;/code&gt; left to right for all elements &lt;code&gt;a&lt;/code&gt; in &lt;code&gt;range&lt;/code&gt;. The original ranges are not changed. Evaluation is done lazily.</source>
          <target state="translated">여러 언어의 기능적 풍미에 있는 homonym 함수 ( &lt;code&gt;transform&lt;/code&gt; 이라고도 함)를 구현합니다 . 호출 &lt;code&gt;map!(fun)(range)&lt;/code&gt; 요소를 적용하여 얻을 수있는 범위를 반환 &lt;code&gt;fun(a)&lt;/code&gt; 모든 요소를 왼쪽에서 오른쪽으로 의 &lt;code&gt;range&lt;/code&gt; . 원래 범위는 변경되지 않습니다. 평가는 느리게 수행됩니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="38aa73eed2ebaa6990e6725195bf642f0bb7894e" translate="yes" xml:space="preserve">
          <source>Implements the most derived interface that &lt;code&gt;R&lt;/code&gt; works with and wraps all relevant range primitives in virtual functions. If &lt;code&gt;R&lt;/code&gt; is already derived from the &lt;code&gt;InputRange&lt;/code&gt; interface, aliases itself away.</source>
          <target state="translated">&lt;code&gt;R&lt;/code&gt; 이 작동 하는 가장 파생 된 인터페이스를 구현하고 모든 관련 범위 프리미티브를 가상 함수로 래핑합니다. &lt;code&gt;R&lt;/code&gt; 이 이미 &lt;code&gt;InputRange&lt;/code&gt; 인터페이스 에서 파생 된 경우 별명 자체가 사라집니다.</target>
        </trans-unit>
        <trans-unit id="0aed3bb7204f0f1333835ef5bde3ef0b25325996" translate="yes" xml:space="preserve">
          <source>Implements the range interface primitive &lt;code&gt;back&lt;/code&gt; for built-in arrays. Due to the fact that nonmember functions can be called with the first argument using the dot notation, &lt;code&gt;array.back&lt;/code&gt; is equivalent to &lt;code&gt;back(array)&lt;/code&gt;. For &lt;a href=&quot;http://dlang.org/glossary.html#narrow%20strings&quot;&gt;narrow strings&lt;/a&gt;, &lt;code&gt;back&lt;/code&gt; automatically returns the last &lt;a href=&quot;http://dlang.org/glossary.html#code%20point&quot;&gt;code point&lt;/a&gt; as a &lt;code&gt;dchar&lt;/code&gt;.</source>
          <target state="translated">내장 배열에 대한 범위 인터페이스 기본 요소를 &lt;code&gt;back&lt;/code&gt; 구현합니다 . 점 표기법을 사용하여 첫 번째 인수로 비 멤버 함수를 호출 할 수 있기 때문에 &lt;code&gt;array.back&lt;/code&gt; 은 &lt;code&gt;back(array)&lt;/code&gt; 와 같습니다 . 들어 &lt;a href=&quot;http://dlang.org/glossary.html#narrow%20strings&quot;&gt;좁은 문자열&lt;/a&gt; , &lt;code&gt;back&lt;/code&gt; 자동으로 마지막 반환 &lt;a href=&quot;http://dlang.org/glossary.html#code%20point&quot;&gt;코드 포인트&lt;/a&gt; A와 &lt;code&gt;dchar&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="04e6ed7d224c97fa3d71d473444b0b69a64c7f19" translate="yes" xml:space="preserve">
          <source>Implements the range interface primitive &lt;code&gt;back&lt;/code&gt; for built-in arrays. Due to the fact that nonmember functions can be called with the first argument using the dot notation, &lt;code&gt;array.back&lt;/code&gt; is equivalent to &lt;code&gt;back(array)&lt;/code&gt;. For &lt;a href=&quot;https://dlang.org/glossary.html#narrow%20strings&quot;&gt;narrow strings&lt;/a&gt;, &lt;code&gt;back&lt;/code&gt; automatically returns the last &lt;a href=&quot;https://dlang.org/glossary.html#code%20point&quot;&gt;code point&lt;/a&gt; as a &lt;code&gt;dchar&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b532541671d15b35cef77598c086f1da87e05be3" translate="yes" xml:space="preserve">
          <source>Implements the range interface primitive &lt;code&gt;empty&lt;/code&gt; for types that obey &lt;a href=&quot;#hasLength&quot;&gt;&lt;code&gt;hasLength&lt;/code&gt;&lt;/a&gt; property and for narrow strings. Due to the fact that nonmember functions can be called with the first argument using the dot notation, &lt;code&gt;a.empty&lt;/code&gt; is equivalent to &lt;code&gt;empty(a)&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#hasLength&quot;&gt; &lt;code&gt;hasLength&lt;/code&gt; &lt;/a&gt; 특성 을 준수하는 유형 및 좁은 문자열에 대해 범위 인터페이스 기본 요소 &lt;code&gt;empty&lt;/code&gt; 을 구현합니다 . 점 표기법을 사용하여 첫 번째 인수로 비 멤버 함수를 호출 할 수 있기 때문에 &lt;code&gt;a.empty&lt;/code&gt; 는 &lt;code&gt;empty(a)&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="62d00f3658d0160b41b82721ed86515030421a62" translate="yes" xml:space="preserve">
          <source>Implements the range interface primitive &lt;code&gt;front&lt;/code&gt; for built-in arrays. Due to the fact that nonmember functions can be called with the first argument using the dot notation, &lt;code&gt;array.front&lt;/code&gt; is equivalent to &lt;code&gt;front(array)&lt;/code&gt;. For &lt;a href=&quot;http://dlang.org/glossary.html#narrow%20strings&quot;&gt;narrow strings&lt;/a&gt;, &lt;code&gt;front&lt;/code&gt; automatically returns the first &lt;a href=&quot;http://dlang.org/glossary.html#code%20point&quot;&gt;code point&lt;/a&gt; as a &lt;code&gt;dchar&lt;/code&gt;.</source>
          <target state="translated">내장 어레이에 대한 레인지 인터페이스 프리미티브 &lt;code&gt;front&lt;/code&gt; 를 구현합니다 . 점 표기법을 사용하여 첫 번째 인수로 비 멤버 함수를 호출 할 수 있기 때문에 &lt;code&gt;array.front&lt;/code&gt; 는 &lt;code&gt;front(array)&lt;/code&gt; 와 같습니다 . 들어 &lt;a href=&quot;http://dlang.org/glossary.html#narrow%20strings&quot;&gt;좁은 문자열&lt;/a&gt; , &lt;code&gt;front&lt;/code&gt; 자동으로 첫 번째 반환 &lt;a href=&quot;http://dlang.org/glossary.html#code%20point&quot;&gt;코드 포인트&lt;/a&gt; A와 &lt;code&gt;dchar&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="965c0093a92de4542d32370a4d3fa23242b5017a" translate="yes" xml:space="preserve">
          <source>Implements the range interface primitive &lt;code&gt;front&lt;/code&gt; for built-in arrays. Due to the fact that nonmember functions can be called with the first argument using the dot notation, &lt;code&gt;array.front&lt;/code&gt; is equivalent to &lt;code&gt;front(array)&lt;/code&gt;. For &lt;a href=&quot;https://dlang.org/glossary.html#narrow%20strings&quot;&gt;narrow strings&lt;/a&gt;, &lt;code&gt;front&lt;/code&gt; automatically returns the first &lt;a href=&quot;https://dlang.org/glossary.html#code%20point&quot;&gt;code point&lt;/a&gt; as a &lt;code&gt;dchar&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1778775edc47d955b8410b9303b511a8ed36740" translate="yes" xml:space="preserve">
          <source>Implements the range interface primitive &lt;code&gt;popBack&lt;/code&gt; for built-in arrays. Due to the fact that nonmember functions can be called with the first argument using the dot notation, &lt;code&gt;array.popBack&lt;/code&gt; is equivalent to &lt;code&gt;popBack(array)&lt;/code&gt;. For &lt;a href=&quot;http://dlang.org/glossary.html#narrow%20strings&quot;&gt;narrow strings&lt;/a&gt;, &lt;code&gt;popFront&lt;/code&gt; automatically eliminates the last &lt;a href=&quot;http://dlang.org/glossary.html#code%20point&quot;&gt;code point&lt;/a&gt;.</source>
          <target state="translated">내장 배열에 대한 범위 인터페이스 기본 &lt;code&gt;popBack&lt;/code&gt; 을 구현합니다 . 점 표기법을 사용하여 첫 번째 인수로 비 멤버 함수를 호출 할 수 있기 때문에 &lt;code&gt;array.popBack&lt;/code&gt; 은 &lt;code&gt;popBack(array)&lt;/code&gt; 와 같습니다 . 들어 &lt;a href=&quot;http://dlang.org/glossary.html#narrow%20strings&quot;&gt;좁은 문자열&lt;/a&gt; , &lt;code&gt;popFront&lt;/code&gt; 은 자동으로 마지막 제거 &lt;a href=&quot;http://dlang.org/glossary.html#code%20point&quot;&gt;코드 포인트를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6b8902da56133009b92907454b74120bba0eac39" translate="yes" xml:space="preserve">
          <source>Implements the range interface primitive &lt;code&gt;popBack&lt;/code&gt; for built-in arrays. Due to the fact that nonmember functions can be called with the first argument using the dot notation, &lt;code&gt;array.popBack&lt;/code&gt; is equivalent to &lt;code&gt;popBack(array)&lt;/code&gt;. For &lt;a href=&quot;https://dlang.org/glossary.html#narrow%20strings&quot;&gt;narrow strings&lt;/a&gt;, &lt;code&gt;popFront&lt;/code&gt; automatically eliminates the last &lt;a href=&quot;https://dlang.org/glossary.html#code%20point&quot;&gt;code point&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32e1749a7e79cab97db7229f8dfe1c2b12d27951" translate="yes" xml:space="preserve">
          <source>Implements the range interface primitive &lt;code&gt;popFront&lt;/code&gt; for built-in arrays. Due to the fact that nonmember functions can be called with the first argument using the dot notation, &lt;code&gt;array.popFront&lt;/code&gt; is equivalent to &lt;code&gt;popFront(array)&lt;/code&gt;. For &lt;a href=&quot;http://dlang.org/glossary.html#narrow%20strings&quot;&gt;narrow strings&lt;/a&gt;, &lt;code&gt;popFront&lt;/code&gt; automatically advances to the next code point.</source>
          <target state="translated">내장 배열에 대한 범위 인터페이스 기본 &lt;code&gt;popFront&lt;/code&gt; 를 구현합니다 . 점 표기법을 사용하여 첫 번째 인수로 비 멤버 함수를 호출 할 수 있기 때문에 &lt;code&gt;array.popFront&lt;/code&gt; 는 &lt;code&gt;popFront(array)&lt;/code&gt; 와 같습니다 . 들어 &lt;a href=&quot;http://dlang.org/glossary.html#narrow%20strings&quot;&gt;좁은 문자열&lt;/a&gt; , &lt;code&gt;popFront&lt;/code&gt; 은 자동으로 다음 코드 포인트로 진행한다.</target>
        </trans-unit>
        <trans-unit id="d0432029053f0f67a296502b07d3c4bf1192688a" translate="yes" xml:space="preserve">
          <source>Implements the range interface primitive &lt;code&gt;popFront&lt;/code&gt; for built-in arrays. Due to the fact that nonmember functions can be called with the first argument using the dot notation, &lt;code&gt;array.popFront&lt;/code&gt; is equivalent to &lt;code&gt;popFront(array)&lt;/code&gt;. For &lt;a href=&quot;https://dlang.org/glossary.html#narrow%20strings&quot;&gt;narrow strings&lt;/a&gt;, &lt;code&gt;popFront&lt;/code&gt; automatically advances to the next code point.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75f6fe2cdac67a27b3428234729f0d9dae7b1837" translate="yes" xml:space="preserve">
          <source>Implements the range interface primitive &lt;code&gt;save&lt;/code&gt; for built-in arrays. Due to the fact that nonmember functions can be called with the first argument using the dot notation, &lt;code&gt;array.save&lt;/code&gt; is equivalent to &lt;code&gt;save(array)&lt;/code&gt;. The function does not duplicate the content of the array, it simply returns its argument.</source>
          <target state="translated">내장 어레이에 대한 범위 인터페이스 기본 &lt;code&gt;save&lt;/code&gt; 을 구현합니다 . 점 표기법을 사용하여 첫 번째 인수로 비 멤버 함수를 호출 할 수 있기 때문에 &lt;code&gt;array.save&lt;/code&gt; 는 &lt;code&gt;save(array)&lt;/code&gt; 와 같습니다 . 이 함수는 배열의 내용을 복제하지 않고 단순히 인수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="06c2dee18ee47dea8267fe70942f5db5533167e2" translate="yes" xml:space="preserve">
          <source>Implicit Base Class Construction</source>
          <target state="translated">암시 적 기본 클래스 생성</target>
        </trans-unit>
        <trans-unit id="03be7c6392b5500acdd65ba4a7628363c1860d1b" translate="yes" xml:space="preserve">
          <source>Implicit Conversion of Reference Types</source>
          <target state="translated">참조 유형의 암시 적 변환</target>
        </trans-unit>
        <trans-unit id="65a63aa075b83c2fd9eb74a28a95e05ff02e65a6" translate="yes" xml:space="preserve">
          <source>Implicit Conversions</source>
          <target state="translated">암시 적 변환</target>
        </trans-unit>
        <trans-unit id="ef12fa614b38d413fd2518958b3a056d17777c92" translate="yes" xml:space="preserve">
          <source>Implicit Copy Constructors</source>
          <target state="translated">암시 적 복사 생성자</target>
        </trans-unit>
        <trans-unit id="625a5d30e95ccd8e77f05af4dd624ce180fd702c" translate="yes" xml:space="preserve">
          <source>Implicit Nesting</source>
          <target state="translated">암시 적 중첩</target>
        </trans-unit>
        <trans-unit id="341437e8c6d229adb9641f4f980b4bd232dec666" translate="yes" xml:space="preserve">
          <source>Implicit Qualifier Conversions</source>
          <target state="translated">암시 적 한정자 변환</target>
        </trans-unit>
        <trans-unit id="e71105f02c13309129677ece5605a0283f9f1fad" translate="yes" xml:space="preserve">
          <source>Implicit Type Inference</source>
          <target state="translated">암시 적 유형 추론</target>
        </trans-unit>
        <trans-unit id="849cfc1637b33ec7b03284c956943ea3a6ee1ec6" translate="yes" xml:space="preserve">
          <source>Implicit conversions are used to automatically convert types as required.</source>
          <target state="translated">암시 적 변환은 필요에 따라 유형을 자동으로 변환하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="16ca50dfa8d5e344f045161409c8efa6033ef01d" translate="yes" xml:space="preserve">
          <source>Implicitly calls &lt;code&gt;toJSON&lt;/code&gt; on this JSONValue, like &lt;code&gt;toString&lt;/code&gt;, but also passes</source>
          <target state="translated">암시 적으로 호출 &lt;code&gt;toJSON&lt;/code&gt; 을 같은이 JSONValue에 &lt;code&gt;toString&lt;/code&gt; 뿐만 아니라 전달</target>
        </trans-unit>
        <trans-unit id="61b604cd0d4af75ee155d0f29fe03ab209cdf393" translate="yes" xml:space="preserve">
          <source>Implicitly calls &lt;code&gt;toJSON&lt;/code&gt; on this JSONValue.</source>
          <target state="translated">암시 적으로 호출 &lt;code&gt;toJSON&lt;/code&gt; 을 이 JSONValue에.</target>
        </trans-unit>
        <trans-unit id="fe09202f421258205fc0af0f7cc90ba8af70d44d" translate="yes" xml:space="preserve">
          <source>Import Declaration</source>
          <target state="translated">수입 신고</target>
        </trans-unit>
        <trans-unit id="07b4de4b6291e3b54e69fe2f2020c76048ffb706" translate="yes" xml:space="preserve">
          <source>Import Expressions</source>
          <target state="translated">식 가져 오기</target>
        </trans-unit>
        <trans-unit id="9633d9e6ebf62f84de8d5fc4824a9ee44e1f1708" translate="yes" xml:space="preserve">
          <source>Import declarations may be used at any scope. For example:</source>
          <target state="translated">수입 신고는 모든 범위에서 사용될 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e0559377cfba6b8aed12863122b1b2dcc118cb64" translate="yes" xml:space="preserve">
          <source>ImportDeclaration</source>
          <target state="translated">ImportDeclaration</target>
        </trans-unit>
        <trans-unit id="015ce9a6eb4a1d7698028975a16c0fe2ee6d7aa2" translate="yes" xml:space="preserve">
          <source>Improve behavior of allocators sensitive to allocation sizes, such as &lt;code&gt;FreeList&lt;/code&gt; and &lt;code&gt;FreeTree&lt;/code&gt;. Rounding allocation requests up makes for smaller free lists/trees at the cost of slack memory (internal fragmentation).</source>
          <target state="translated">&lt;code&gt;FreeList&lt;/code&gt; 및 &lt;code&gt;FreeTree&lt;/code&gt; 와 같은 할당 크기에 민감한 할당 자의 동작을 향상시킵니다 . 반올림 할당 요청은 여유 메모리 (내부 조각화)를 희생시키면서 더 작은 여유 목록 / 트리를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="aef36502d67b0520654deb764dd055a7e905cfdd" translate="yes" xml:space="preserve">
          <source>In</source>
          <target state="translated">In</target>
        </trans-unit>
        <trans-unit id="dcd96af0868ef4c663e6ad3dcef261c5095893f1" translate="yes" xml:space="preserve">
          <source>In C, arrays are passed to functions as pointers even if the function prototype says its an array. In D, static arrays are passed by value, not by reference. Thus, the function prototype must be adjusted to match what C expects.</source>
          <target state="translated">C에서는 함수 프로토 타입에 배열이 있다고해도 배열은 포인터로 함수에 전달됩니다. D에서 정적 배열은 참조가 아닌 값으로 전달됩니다. 따라서 함수 프로토 타입은 C가 기대하는 것과 일치하도록 조정해야합니다.</target>
        </trans-unit>
        <trans-unit id="fb107b811fc18be0d73632390771a7270ede12ef" translate="yes" xml:space="preserve">
          <source>In Expressions</source>
          <target state="translated">식에서</target>
        </trans-unit>
        <trans-unit id="98ab2686a50e4805c42c072cadd55e7f182ad96a" translate="yes" xml:space="preserve">
          <source>In a Windows DLL, if this function is called via DllMain with argument DLL_PROCESS_DETACH, the thread is terminated forcefully without proper cleanup as a deadlock would happen otherwise.</source>
          <target state="translated">Windows DLL에서이 함수가 DLL_PROCESS_DETACH 인수와 함께 DllMain을 통해 호출되면 교착 상태가 발생할 수 있으므로 적절한 정리없이 스레드가 강제 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="31b5ad319495b8bf3a1c002a8507f2abf1208f6d" translate="yes" xml:space="preserve">
          <source>In a constructor body, if a delegate constructor is called, all field assignments are considered assignments. Otherwise, the first instance of field assignment is its initialization, and assignments of the form &lt;code&gt;field = expression&lt;/code&gt; are treated as equivalent to &lt;code&gt;typeof(field)(expression)&lt;/code&gt;. The values of fields may be read before initialization or construction with a delegate constructor.</source>
          <target state="translated">생성자 본문에서 델리게이트 생성자가 호출되면 모든 필드 할당이 할당으로 간주됩니다. 그렇지 않은 경우 필드 할당의 첫 번째 인스턴스는 초기화이며 &lt;code&gt;field = expression&lt;/code&gt; 형식의 할당은 &lt;code&gt;typeof(field)(expression)&lt;/code&gt; 과 동일하게 처리됩니다 . 델리게이트 생성자를 사용하여 초기화 또는 구성하기 전에 필드 값을 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="82d94abd1d805c86540567d8cc1718b097222bf0" translate="yes" xml:space="preserve">
          <source>In a constructor body, if a delegating constructor is called, all field assignments are considered assignments. Otherwise, the first instance of field assignment is its initialization, and assignments of the form &lt;code&gt;field = expression&lt;/code&gt; are treated as equivalent to &lt;code&gt;typeof(field)(expression)&lt;/code&gt;. The values of fields may be read before initialization or construction with a delegating constructor.</source>
          <target state="translated">생성자 본문에서 위임 생성자가 호출되면 모든 필드 할당이 할당으로 간주됩니다. 그렇지 않으면 필드 할당의 첫 번째 인스턴스는 초기화이고 &lt;code&gt;field = expression&lt;/code&gt; 형식의 할당은 &lt;code&gt;typeof(field)(expression)&lt;/code&gt; 와 동일하게 처리됩니다 . 위임 생성자를 사용하여 초기화 또는 생성 전에 필드 값을 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="58b4b4504d8850da0fbabfc52a3239ec3b0e0a33" translate="yes" xml:space="preserve">
          <source>In a constructor body, the first instance of field assignment is its initialization.</source>
          <target state="translated">생성자 본문에서 필드 할당의 첫 번째 인스턴스는 초기화입니다.</target>
        </trans-unit>
        <trans-unit id="3c66c503e379c4155d015b11fbc1dc5940286649" translate="yes" xml:space="preserve">
          <source>In a declaration declaring multiple symbols, all the declarations must be of the same type:</source>
          <target state="translated">여러 기호를 선언하는 선언에서 모든 선언은 동일한 유형이어야합니다.</target>
        </trans-unit>
        <trans-unit id="9e9fe9946b014b42fb5205022b5c12ede51b25c5" translate="yes" xml:space="preserve">
          <source>In a typical application, you might also want to consider using a non-blocking socket instead of setting a timeout on a blocking one.</source>
          <target state="translated">일반적인 응용 프로그램에서는 차단 소켓에 시간 초과를 설정하는 대신 비 차단 소켓 사용을 고려할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="190918005b49f5fd22012e2b51e50c26bb8bb06b" translate="yes" xml:space="preserve">
          <source>In addition to &lt;a href=&quot;#Variant&quot;&gt;&lt;code&gt;Variant&lt;/code&gt;&lt;/a&gt;, this module also defines the &lt;a href=&quot;#Algebraic&quot;&gt;&lt;code&gt;Algebraic&lt;/code&gt;&lt;/a&gt; type constructor. Unlike &lt;code&gt;Variant&lt;/code&gt;, &lt;code&gt;Algebraic&lt;/code&gt; only allows a finite set of types, which are specified in the instantiation (e.g. &lt;code&gt;Algebraic!(int, string)&lt;/code&gt; may only hold an &lt;code&gt;int&lt;/code&gt; or a &lt;code&gt;string&lt;/code&gt;).</source>
          <target state="translated">외에 &lt;a href=&quot;#Variant&quot;&gt; &lt;code&gt;Variant&lt;/code&gt; &lt;/a&gt; ,이 모듈은 정의 &lt;a href=&quot;#Algebraic&quot;&gt; &lt;code&gt;Algebraic&lt;/code&gt; &lt;/a&gt; 형 생성자를. 달리 &lt;code&gt;Variant&lt;/code&gt; , &lt;code&gt;Algebraic&lt;/code&gt; 단지 인스턴스에 지정된 유형의 유한 집합 (예 : 수 &lt;code&gt;Algebraic!(int, string)&lt;/code&gt; 만 보유 할 수 &lt;code&gt;int&lt;/code&gt; 또는 &lt;code&gt;string&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="bd56298f652baf17103962e16813e3a6aed52cf4" translate="yes" xml:space="preserve">
          <source>In addition to convenience, these functions are slightly more efficient than manually creating an Fft object for a single use, as the Fft object is deterministically destroyed before these functions return.</source>
          <target state="translated">편의성 외에도 이러한 기능은 반환하기 전에 Fft 개체가 결정적으로 파괴되므로 일회용으로 Fft 개체를 수동으로 만드는 것보다 약간 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="570c956c4c6e2dbde87f61ff5e2c49153a8df2e6" translate="yes" xml:space="preserve">
          <source>In addition to random number generators, this module features distributions, which skew a generator's output statistical distribution in various ways. So far the uniform distribution for integers and real numbers have been implemented.</source>
          <target state="translated">난수 생성기 외에도이 모듈은 분포를 특징으로하며 다양한 방식으로 생성기의 출력 통계 분포를 왜곡합니다. 지금까지 정수와 실수에 대한 균일 분포가 구현되었습니다.</target>
        </trans-unit>
        <trans-unit id="5295840dbe23153fe2e689d001aa6ebadfba5f26" translate="yes" xml:space="preserve">
          <source>In addition, --DRT-gcopt=help will show the list of options and their current settings.</source>
          <target state="translated">또한 --DRT-gcopt = help는 옵션 목록과 현재 설정을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="b2fcea4fb949d2ee554c72114c12b58084a4d18d" translate="yes" xml:space="preserve">
          <source>In addition, the data &lt;code&gt;callerSize&lt;/code&gt;, &lt;code&gt;callerModule&lt;/code&gt;, &lt;code&gt;callerFile&lt;/code&gt;, &lt;code&gt;callerLine&lt;/code&gt;, and &lt;code&gt;callerTime&lt;/code&gt; is associated with each specific allocation. This data prefixes each allocation.</source>
          <target state="translated">또한 데이터 &lt;code&gt;callerSize&lt;/code&gt; , &lt;code&gt;callerModule&lt;/code&gt; , &lt;code&gt;callerFile&lt;/code&gt; , &lt;code&gt;callerLine&lt;/code&gt; 및 &lt;code&gt;callerTime&lt;/code&gt; 은 각 특정 할당과 연관됩니다. 이 데이터는 각 할당의 접두사입니다.</target>
        </trans-unit>
        <trans-unit id="8bb9d27fa1cfa7a17c0f438e8ee45a8ac856bdb5" translate="yes" xml:space="preserve">
          <source>In algorithms partitioning ranges in two, preserve relative ordering of elements only to the left of the partition point.</source>
          <target state="translated">알고리즘 분할 범위는 2로, 분할 지점의 왼쪽에만 요소의 상대적 순서를 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="a4c7a53fdd584b663429b65ac4f17edc28d07354" translate="yes" xml:space="preserve">
          <source>In all cases the function returns the built-in result of &lt;code&gt;lhs == rhs&lt;/code&gt;.</source>
          <target state="translated">모든 경우에 함수는 내장 결과 &lt;code&gt;lhs == rhs&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="a66898347b51f7c1d0527a1edb8a6b3cf367a27a" translate="yes" xml:space="preserve">
          <source>In all cases, a two-symbols versions is also accepted, in which case the first symbol (of integral type, e.g. &lt;code&gt;ulong&lt;/code&gt; or &lt;code&gt;uint&lt;/code&gt;) tracks the zero-based number of the current line.</source>
          <target state="translated">모든 경우에 두 개의 기호 버전도 허용되며,이 경우 첫 번째 기호 (예 : &lt;code&gt;ulong&lt;/code&gt; 또는 &lt;code&gt;uint&lt;/code&gt; )는 현재 행의 0부터 시작하는 숫자를 추적합니다.</target>
        </trans-unit>
        <trans-unit id="fb219f6585d8061af3f052a290762bb948e1e8d6" translate="yes" xml:space="preserve">
          <source>In all cases, returns &lt;code&gt;lhs &amp;lt; rhs ? -1 : lhs &amp;gt; rhs&lt;/code&gt;. The result is not autocorrected in case of an erroneous comparison.</source>
          <target state="translated">모든 경우에 &lt;code&gt;lhs &amp;lt; rhs ? -1 : lhs &amp;gt; rhs&lt;/code&gt; . 잘못된 비교의 경우 결과가 자동 수정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cb4bca7a9dd4559557c8f7c4ee56255838258c7f" translate="yes" xml:space="preserve">
          <source>In all cases, the concatenation of the returned ranges spans the entire &lt;code&gt;haystack&lt;/code&gt;.</source>
          <target state="translated">모든 경우에, 반환 된 범위의 연결은 전체 &lt;code&gt;haystack&lt;/code&gt; 에 걸쳐 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fac8533d039fb2ca10f37bea36476dc0de1df00b" translate="yes" xml:space="preserve">
          <source>In all other cases, a simple element by element addition is done.</source>
          <target state="translated">다른 모든 경우에는 요소 별 간단한 요소 추가가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="394148797f50691adb9a270f990a5eaca722863e" translate="yes" xml:space="preserve">
          <source>In all other cases, the built-in behavior is carried out.</source>
          <target state="translated">다른 모든 경우에는 내장 동작이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="b68e1d58907e07140ccd3efadbc43c332f170e2d" translate="yes" xml:space="preserve">
          <source>In all other respects this function works just like &lt;code&gt;spawnProcess&lt;/code&gt;. Please refer to the &lt;a href=&quot;#spawnProcess&quot;&gt;&lt;code&gt;spawnProcess&lt;/code&gt;&lt;/a&gt; documentation for descriptions of the other function parameters, the return value and any exceptions that may be thrown.</source>
          <target state="translated">다른 모든 측면에서이 함수는 &lt;code&gt;spawnProcess&lt;/code&gt; 처럼 작동합니다 . 다른 함수 매개 변수, 반환 값 및 발생할 수있는 예외에 대한 설명은 &lt;a href=&quot;#spawnProcess&quot;&gt; &lt;code&gt;spawnProcess&lt;/code&gt; &lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1cc108da5c2c3788f98a6edf95e1a63a36afb311" translate="yes" xml:space="preserve">
          <source>In all string literal forms, an &lt;a href=&quot;#EndOfLine&quot;&gt;&lt;i&gt;EndOfLine&lt;/i&gt;&lt;/a&gt; is regarded as a single &lt;code&gt;\n&lt;/code&gt; character.</source>
          <target state="translated">모든 문자열 리터럴 형식에서 &lt;a href=&quot;#EndOfLine&quot;&gt;&lt;i&gt;EndOfLine&lt;/i&gt;&lt;/a&gt; 은 단일 &lt;code&gt;\n&lt;/code&gt; 문자 로 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="60b9a383afd7a0fd8bdda37a3d66b0a2bbb686e7" translate="yes" xml:space="preserve">
          <source>In all the other respects, these methods are like any other methods. They can be static, have different linkages, have their address taken, etc.</source>
          <target state="translated">다른 모든 측면에서 이러한 방법은 다른 방법과 같습니다. 정적 일 수 있고, 서로 다른 링크가 있거나, 주소를 가져갈 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4560285d4cfc645e0ef24ee3db5890ff1443ed09" translate="yes" xml:space="preserve">
          <source>In both C++ and D, if a struct has zero fields, the struct still has a size of 1 byte. But, in C++ if the struct with zero fields is used as a base struct, its size is zero (called the &lt;a href=&quot;https://en.cppreference.com/w/cpp/language/ebo&quot;&gt;Empty Base Optimization&lt;/a&gt;). There are two methods for emulating this behavior in D. The first forwards references to a function returning a faked reference to the base:</source>
          <target state="translated">C ++ 및 D에서 구조체에 필드가 0 인 경우 구조체의 크기는 여전히 1 바이트입니다. 그러나 C ++에서 필드가 0 인 구조체가 기본 구조체로 사용되면 크기는 0입니다 ( &lt;a href=&quot;https://en.cppreference.com/w/cpp/language/ebo&quot;&gt;Empty Base Optimization&lt;/a&gt; ). D에는이 동작을 에뮬레이트하는 두 가지 방법이 있습니다. 첫 번째는베이스에 대한 가짜 참조를 반환하는 함수에 대한 참조를 전달합니다.</target>
        </trans-unit>
        <trans-unit id="b076421b0fbcae191c5dc3ef2368683aca391393" translate="yes" xml:space="preserve">
          <source>In case of a compound format specifier starting with &lt;code&gt; &quot;%(&quot;&lt;/code&gt; and ending with &lt;code&gt;&quot;%)&quot;&lt;/code&gt;, &lt;code&gt;_nested&lt;/code&gt; contains the string contained within the two separators.</source>
          <target state="translated">복합 형식 지정자의 경우로 시작 &lt;code&gt; &quot;%(&quot;&lt;/code&gt; 와 함께 종료 &lt;code&gt;&quot;%)&quot;&lt;/code&gt; , &lt;code&gt;_nested&lt;/code&gt; 가 두 세퍼레이터에 포함 된 문자열을 포함한다.</target>
        </trans-unit>
        <trans-unit id="b3a4dc18e455dc36e9fd73a88e062b9df8c0d722" translate="yes" xml:space="preserve">
          <source>In case of a compound format specifier, &lt;code&gt;_sep&lt;/code&gt; contains the string positioning after &lt;code&gt;&quot;%|&quot;&lt;/code&gt;. &lt;code&gt;sep is null&lt;/code&gt; means no separator else &lt;code&gt;sep.empty&lt;/code&gt; means 0 length separator.</source>
          <target state="translated">복합 형식 지정자의 경우 &lt;code&gt;_sep&lt;/code&gt; 는 &lt;code&gt;&quot;%|&quot;&lt;/code&gt; 뒤에 문자열 위치를 포함합니다. . &lt;code&gt;sep is null&lt;/code&gt; 경우 구분 기호가 &lt;code&gt;sep.empty&lt;/code&gt; 는 0 길이 구분 기호를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="c172129354e9ba73756e23e6e1f6e0e605a52cb9" translate="yes" xml:space="preserve">
          <source>In case of a log message with &lt;code&gt;LogLevel.fatal&lt;/code&gt; nothing will happen.</source>
          <target state="translated">&lt;code&gt;LogLevel.fatal&lt;/code&gt; 이있는 로그 메시지의 경우 아무 일도 일어나지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3ebef375cea9cd0eca25afb26b6d5c11eab7f3f0" translate="yes" xml:space="preserve">
          <source>In case of an I/O error, an &lt;code&gt;StdioException&lt;/code&gt; is thrown.</source>
          <target state="translated">I / O 오류 가 발생 하면 &lt;code&gt;StdioException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="39a07628e75ba54420c0ee35d2d7947fae3e6e95" translate="yes" xml:space="preserve">
          <source>In case of an I/O error, throws an &lt;a href=&quot;#StdioException&quot;&gt;&lt;code&gt;StdioException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">I / O 오류가 발생하면 &lt;a href=&quot;#StdioException&quot;&gt; &lt;code&gt;StdioException&lt;/code&gt; 이 발생&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="6c94ce1719c011e5c08b47d8a880eaa8ed1ab504" translate="yes" xml:space="preserve">
          <source>In case of an I/O error, throws an &lt;code&gt;StdioException&lt;/code&gt;.</source>
          <target state="translated">I / O 오류가 발생하면 &lt;code&gt;StdioException&lt;/code&gt; 이 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="072442afd2ab0da30ef9131acbdaeefa3c16749b" translate="yes" xml:space="preserve">
          <source>In case you want to only enable bundling for some of the parameters, bundling can be turned off with &lt;code&gt;std.getopt.config.noBundling&lt;/code&gt;.</source>
          <target state="translated">일부 매개 변수에 대해서만 번들링을 사용하려는 경우 &lt;code&gt;std.getopt.config.noBundling&lt;/code&gt; 을 사용하여 번들링을 해제 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="01d85046192eeac78a5da365dc7670fdea8d6e86" translate="yes" xml:space="preserve">
          <source>In cases where producing the replacement is the ultimate goal &lt;a href=&quot;#replaceFirstInto&quot;&gt;&lt;code&gt;replaceFirstInto&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#replaceAllInto&quot;&gt;&lt;code&gt;replaceAllInto&lt;/code&gt;&lt;/a&gt; could come in handy as functions that avoid allocations even for replacement.</source>
          <target state="translated">교체 생산이 궁극적 인 목표 인 경우 &lt;a href=&quot;#replaceFirstInto&quot;&gt; &lt;code&gt;replaceFirstInto&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#replaceAllInto&quot;&gt; &lt;code&gt;replaceAllInto&lt;/code&gt; &lt;/a&gt; 는 교체에도 할당을 피하는 기능으로 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e6177e81e2c8557108ce3bebc0ad228b2a46f372" translate="yes" xml:space="preserve">
          <source>In cases where the operand size is ambiguous, as in:</source>
          <target state="translated">다음과 같이 피연산자 크기가 모호한 경우 :</target>
        </trans-unit>
        <trans-unit id="a7faf0c1f2db2bcd1f30944e523bc6e5d4329044" translate="yes" xml:space="preserve">
          <source>In cases where the string in question is already normalized, it is returned unmodified and no memory allocation happens.</source>
          <target state="translated">해당 문자열이 이미 정규화 된 경우 수정되지 않은 상태로 반환되고 메모리 할당이 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b91258a55b8ef08cfea19b1e402c52c62c5ef260" translate="yes" xml:space="preserve">
          <source>In debug mode &lt;code&gt;AssertError&lt;/code&gt;, when the result is not a well-formed UTF string.</source>
          <target state="translated">디버그 모드 &lt;code&gt;AssertError&lt;/code&gt; 에서 결과가 올바른 형식의 UTF 문자열이 아닐 때.</target>
        </trans-unit>
        <trans-unit id="7c2d083ad99e82982be1c8520585485c563982d6" translate="yes" xml:space="preserve">
          <source>In detail, &lt;code&gt;__delete(x)&lt;/code&gt; returns with no effect if &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;. Otherwise, it performs the following actions in sequence:</source>
          <target state="translated">구체적으로, &lt;code&gt;x&lt;/code&gt; 가 &lt;code&gt;null&lt;/code&gt; 이면 &lt;code&gt;__delete(x)&lt;/code&gt; 는 아무런 영향을 미치지 않습니다 . 그렇지 않으면 다음 조치를 순서대로 수행합니다.</target>
        </trans-unit>
        <trans-unit id="1a253df89cf875b96f6b0b99a704c14478bd5687" translate="yes" xml:space="preserve">
          <source>In effect &lt;code&gt;takeOne(r)&lt;/code&gt; is somewhat equivalent to &lt;code&gt;take(r, 1)&lt;/code&gt; but in certain interfaces it is important to know statically that the range may only have at most one element.</source>
          <target state="translated">실제로 &lt;code&gt;takeOne(r)&lt;/code&gt; 은 &lt;code&gt;take(r, 1)&lt;/code&gt; 과 다소 동일 하지만 특정 인터페이스에서는 범위에 최대 하나의 요소 만있을 수 있다는 것을 정적으로 아는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="c7e90e95cc2e5d025786e563cb98d86e57f261c9" translate="yes" xml:space="preserve">
          <source>In either case, the content of the buffer is reused across calls. That means &lt;code&gt;front&lt;/code&gt; will not persist after &lt;code&gt;popFront&lt;/code&gt; is called, so if retention is needed, the caller must copy its contents (e.g. by calling &lt;code&gt;buffer.dup&lt;/code&gt;).  In the example above, &lt;code&gt;buffer.length&lt;/code&gt; is 4096 for all iterations, except for the last one, in which case &lt;code&gt;buffer.length&lt;/code&gt; may be less than 4096 (but always greater than zero).  With the mentioned limitations, &lt;code&gt;byChunk&lt;/code&gt; works with any algorithm compatible with input ranges.</source>
          <target state="translated">두 경우 모두 버퍼의 내용이 모든 호출에서 재사용됩니다. 즉 , &lt;code&gt;popFront&lt;/code&gt; 를 호출 한 후에 는 &lt;code&gt;front&lt;/code&gt; 가 유지되지 않으므로 보존이 필요한 경우 호출자는 내용을 복사해야합니다 (예 : &lt;code&gt;buffer.dup&lt;/code&gt; 호출 ). 위의 예에서 &lt;code&gt;buffer.length&lt;/code&gt; 는 마지막 반복을 제외하고 모든 반복에 대해 4096입니다.이 경우 &lt;code&gt;buffer.length&lt;/code&gt; 는 4096보다 작을 수 있지만 항상 0보다 큽니다. 언급 된 제한 사항으로 &lt;code&gt;byChunk&lt;/code&gt; 는 입력 범위와 호환되는 모든 알고리즘에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="8ec7633257f9bdb307965ba1607259244c489e1d" translate="yes" xml:space="preserve">
          <source>In free list mode, &lt;code&gt;KRRegion&lt;/code&gt; embeds a free blocks list onto the chunk of memory. The free list is circular, coalesced, and sorted by address at all times. Allocations and deallocations take time proportional to the number of previously deallocated blocks. (In practice the cost may be lower, e.g. if memory is deallocated in reverse order of allocation, all operations take constant time.) Memory utilization is good (small control structure and no per-allocation overhead). The disadvantages of freelist mode include proneness to fragmentation, a minimum allocation size of two words, and linear worst-case allocation and deallocation times.</source>
          <target state="translated">자유 목록 모드에서 &lt;code&gt;KRRegion&lt;/code&gt; 은 사용 가능한 차단 목록을 메모리 청크에 포함시킵니다. 무료 목록은 항상 원형, 통합 및 주소별로 정렬됩니다. 할당 및 할당 해제는 이전에 할당 해제 된 블록 수에 비례하여 시간이 걸립니다. (실제로 메모리 할당이 역순으로 할당 해제되는 경우 비용이 낮아질 수 있습니다. 모든 작업은 일정한 시간이 걸립니다.) 메모리 사용률이 양호합니다 (소규모 제어 구조 및 할당 당 오버 헤드가 없음). 프리리스트 모드의 단점은 조각화가 발생하기 쉽고, 최소 2 워드의 할당 크기, 선형 최악의 할당 및 할당 해제 시간입니다.</target>
        </trans-unit>
        <trans-unit id="cdf7807c516e1443dffb3bd59e60f6a917c9df07" translate="yes" xml:space="preserve">
          <source>In function scopes, imported symbols only become visible after the import declaration lexically appears in the function body. In other words, imported symbols at function scope cannot be forward referenced.</source>
          <target state="translated">함수 범위에서 가져온 기호는 함수 본문에 사전 선언이 사전에 표시된 후에 만 ​​표시됩니다. 즉, 기능 범위에서 가져온 기호는 앞으로 참조 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c0383119e4652a168035af7434f3705bce886b19" translate="yes" xml:space="preserve">
          <source>In functional programming languages this is typically called &lt;code&gt;scan&lt;/code&gt;, &lt;code&gt;scanl&lt;/code&gt;, &lt;code&gt;scanLeft&lt;/code&gt; or &lt;code&gt;reductions&lt;/code&gt;.</source>
          <target state="translated">기능적 프로그래밍 언어에서는 일반적으로 &lt;code&gt;scan&lt;/code&gt; , &lt;code&gt;scanl&lt;/code&gt; , &lt;code&gt;scanLeft&lt;/code&gt; 또는 &lt;code&gt;reductions&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="8fb398e80e5a7daebe5fe79cc756231990bf0b4c" translate="yes" xml:space="preserve">
          <source>In general one should always wait for child processes to terminate before exiting the parent process unless the process was spawned as detached (that was spawned with &lt;code&gt;Config.detached&lt;/code&gt; flag). Otherwise, they may become &quot;&lt;a href=&quot;http://en.wikipedia.org/wiki/Zombie_process&quot;&gt;zombies&lt;/a&gt;&quot; &amp;ndash; processes that are defunct, yet still occupy a slot in the OS process table. You should not and must not wait for detached processes, since you don't own them.</source>
          <target state="translated">일반적으로 프로세스가 분리 된 것으로 생성되지 않은 경우 ( &lt;code&gt;Config.detached&lt;/code&gt; 플래그 로 생성 된 경우) 상위 프로세스를 종료하기 전에 항상 하위 프로세스가 종료 될 때까지 기다려야합니다 . 그렇지 않으면 &quot; &lt;a href=&quot;http://en.wikipedia.org/wiki/Zombie_process&quot;&gt;좀비&lt;/a&gt; &quot; 가 될 수 있습니다.이 프로세스는 사용되지 않지만 여전히 OS 프로세스 테이블의 슬롯을 차지합니다. 분리 된 프로세스는 소유하지 않기 때문에 분리해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="e54833d60e63718b11cbb8a51d7312998978bd02" translate="yes" xml:space="preserve">
          <source>In general one should always wait for child processes to terminate before exiting the parent process unless the process was spawned as detached (that was spawned with &lt;code&gt;Config.detached&lt;/code&gt; flag). Otherwise, they may become &quot;&lt;a href=&quot;https://en.wikipedia.org/wiki/Zombie_process&quot;&gt;zombies&lt;/a&gt;&quot; &amp;ndash; processes that are defunct, yet still occupy a slot in the OS process table. You should not and must not wait for detached processes, since you don't own them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a9fd3d1c20814161b33ee0afa7c06fcf185414e" translate="yes" xml:space="preserve">
          <source>In general periodically 'reseeding' a PRNG does not improve its quality and in some cases may harm it. For an extreme example the Mersenne Twister has &lt;code&gt;2 ^^ 19937 - 1&lt;/code&gt; distinct states but after &lt;code&gt;seed(uint)&lt;/code&gt; is called it can only be in one of &lt;code&gt;2 ^^ 32&lt;/code&gt; distinct states regardless of how excellent the source of entropy is.</source>
          <target state="translated">일반적으로 PRNG는 정기적으로 '재배포'하여 품질을 향상시키지 않으며 경우에 따라 해를 입힐 수 있습니다. 극단적 인 예를 들어 Mersenne Twister는 &lt;code&gt;2 ^^ 19937 - 1&lt;/code&gt; 별개의 상태를 갖지만 &lt;code&gt;seed(uint)&lt;/code&gt; 가 호출 된 후 엔트로피 소스의 우수성에 관계없이 &lt;code&gt;2 ^^ 32&lt;/code&gt; 별개의 상태 중 하나에 만있을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fc32a5290aa168583cf02dd9b13039ee5589d851" translate="yes" xml:space="preserve">
          <source>In general, the functions in this module assume that the input paths are well-formed. (That is, they should not contain invalid characters, they should follow the file system's path format, etc.) The result of calling a function on an ill-formed path is undefined. When there is a chance that a path or a file name is invalid (for instance, when it has been input by the user), it may sometimes be desirable to use the &lt;a href=&quot;#isValidFilename&quot;&gt;&lt;code&gt;isValidFilename&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#isValidPath&quot;&gt;&lt;code&gt;isValidPath&lt;/code&gt;&lt;/a&gt; functions to check this.</source>
          <target state="translated">일반적으로이 모듈의 기능은 입력 경로가 올바른 것으로 가정합니다. (즉, 유효하지 않은 문자를 포함해서는 안되며 파일 시스템의 경로 형식 등을 따라야합니다.) 잘못된 형식의 경로에서 함수를 호출 한 결과는 정의되지 않습니다. 경로 또는 파일 이름이 유효하지 않은 경우 (예 : 사용자가 입력 한 경우) &lt;a href=&quot;#isValidFilename&quot;&gt; &lt;code&gt;isValidFilename&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#isValidPath&quot;&gt; &lt;code&gt;isValidPath&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 이를 확인 하는 것이 바람직 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7566506eebd3c530fd7b49f9458b9e3829cd9289" translate="yes" xml:space="preserve">
          <source>In many cases, calls to sizeof() can't be used directly for getting data type sizes since cross compiling is supported and would end up using the host sizes rather than the target sizes.</source>
          <target state="translated">대부분의 경우 크로스 컴파일이 지원되고 대상 크기가 아닌 호스트 크기를 사용하므로 sizeof () 호출은 데이터 유형 크기를 가져 오는 데 직접 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="35dd64591779170e8008d349dad053c6fa8f2446" translate="yes" xml:space="preserve">
          <source>In nested</source>
          <target state="translated">중첩</target>
        </trans-unit>
        <trans-unit id="8575ac5b58d78f8ffa7cfeed41b65f5b48950967" translate="yes" xml:space="preserve">
          <source>In older versions of Phobos, it used to be possible to write:</source>
          <target state="translated">이전 버전의 Phobo에서는 다음과 같이 쓸 수있었습니다.</target>
        </trans-unit>
        <trans-unit id="2e095fc6159a0d37540c3fe665eef32c69ad9690" translate="yes" xml:space="preserve">
          <source>In order for the data to be processed the &lt;code&gt;LogLevel&lt;/code&gt; of the &lt;code&gt;Logger&lt;/code&gt; must be greater or equal to the global &lt;code&gt;LogLevel&lt;/code&gt;.</source>
          <target state="translated">데이터를 처리 하려면 &lt;code&gt;Logger&lt;/code&gt; 의 &lt;code&gt;LogLevel&lt;/code&gt; 이 글로벌 &lt;code&gt;LogLevel&lt;/code&gt; 보다 크거나 같아야합니다 .</target>
        </trans-unit>
        <trans-unit id="60952b4bdab4bfb5f5a8d1d83bb07430530eeffe" translate="yes" xml:space="preserve">
          <source>In order for the data to be processed the &lt;code&gt;LogLevel&lt;/code&gt; of the &lt;code&gt;sharedLog&lt;/code&gt; must be greater or equal to the &lt;code&gt;defaultLogLevel&lt;/code&gt; add the condition passed must be &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">데이터를 처리하려면 &lt;code&gt;sharedLog&lt;/code&gt; 의 &lt;code&gt;LogLevel&lt;/code&gt; 이 &lt;code&gt;defaultLogLevel&lt;/code&gt; 보다 크거나 같아야하며 전달 된 조건이 &lt;code&gt;true&lt;/code&gt; 여야 합니다 .</target>
        </trans-unit>
        <trans-unit id="8e11fddcd19d6f16f616c57c6e260430b0f9d9a4" translate="yes" xml:space="preserve">
          <source>In order for the data to be processed the &lt;code&gt;LogLevel&lt;/code&gt; of the &lt;code&gt;sharedLog&lt;/code&gt; must be greater or equal to the &lt;code&gt;defaultLogLevel&lt;/code&gt;.</source>
          <target state="translated">데이터를 처리 하려면 &lt;code&gt;sharedLog&lt;/code&gt; 의 &lt;code&gt;LogLevel&lt;/code&gt; 이 &lt;code&gt;defaultLogLevel&lt;/code&gt; 보다 크거나 같아야합니다 .</target>
        </trans-unit>
        <trans-unit id="9f8c65e46c163f6fc77fddc2b9a77d78f4961ef7" translate="yes" xml:space="preserve">
          <source>In order for the data to be processed the &lt;code&gt;LogLevel&lt;/code&gt; of the log call must be greater or equal to the &lt;code&gt;LogLevel&lt;/code&gt; of the &lt;code&gt;sharedLog&lt;/code&gt; and the &lt;code&gt;defaultLogLevel&lt;/code&gt; additionally the condition passed must be &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">데이터의 순서대로 처리 할 &lt;code&gt;LogLevel&lt;/code&gt; 에 커야 로그 통화를하거나 동일 &lt;code&gt;LogLevel&lt;/code&gt; 에 의 &lt;code&gt;sharedLog&lt;/code&gt; 및 &lt;code&gt;defaultLogLevel&lt;/code&gt; 별도로 전달 상태이어야 &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ed49a17d9874b268342f0db2f71435916af05001" translate="yes" xml:space="preserve">
          <source>In order for the data to be processed the &lt;code&gt;LogLevel&lt;/code&gt; of the log call must be greater or equal to the &lt;code&gt;LogLevel&lt;/code&gt; of the &lt;code&gt;sharedLog&lt;/code&gt; and the &lt;code&gt;defaultLogLevel&lt;/code&gt;.</source>
          <target state="translated">데이터의 순서대로 처리 할 &lt;code&gt;LogLevel&lt;/code&gt; 에 커야 로그 통화를하거나 동일 &lt;code&gt;LogLevel&lt;/code&gt; 에 의 &lt;code&gt;sharedLog&lt;/code&gt; 및 &lt;code&gt;defaultLogLevel&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6c93e7b85e99ec02f5d168562dae2b831dda8259" translate="yes" xml:space="preserve">
          <source>In order for the data to be processed the &lt;code&gt;LogLevel&lt;/code&gt; of the log call must be greater or equal to the &lt;code&gt;LogLevel&lt;/code&gt; of the &lt;code&gt;sharedLog&lt;/code&gt;.</source>
          <target state="translated">데이터의 순서대로 처리 할 &lt;code&gt;LogLevel&lt;/code&gt; 에 커야 로그 통화를하거나 동일 &lt;code&gt;LogLevel&lt;/code&gt; 에 의 &lt;code&gt;sharedLog&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9f87139f757185970527b89c7ad28046b560c58f" translate="yes" xml:space="preserve">
          <source>In order for the data to be processed the &lt;code&gt;LogLevel&lt;/code&gt; of the log call must be greater or equal to the &lt;code&gt;defaultLogLevel&lt;/code&gt; additionally the condition passed must be &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">데이터를 처리하려면 로그 호출 의 &lt;code&gt;LogLevel&lt;/code&gt; 이 &lt;code&gt;defaultLogLevel&lt;/code&gt; 보다 크거나 같아야하며, 추가로 전달 된 조건은 &lt;code&gt;true&lt;/code&gt; 여야 합니다 .</target>
        </trans-unit>
        <trans-unit id="a54f9edb0000f15c332443c24f6eb668c55c8501" translate="yes" xml:space="preserve">
          <source>In order for the data to be processed the &lt;code&gt;LogLevel&lt;/code&gt; of the log call must be greater or equal to the &lt;code&gt;defaultLogLevel&lt;/code&gt;.</source>
          <target state="translated">데이터를 처리 하려면 로그 호출 의 &lt;code&gt;LogLevel&lt;/code&gt; 이 &lt;code&gt;defaultLogLevel&lt;/code&gt; 보다 크거나 같아야합니다 .</target>
        </trans-unit>
        <trans-unit id="14b107fabc6c81ab2222b96dfa0c1ecd6dfba19f" translate="yes" xml:space="preserve">
          <source>In order for the data to be processed, the &lt;code&gt;LogLevel&lt;/code&gt; of the log call must be greater or equal to the &lt;code&gt;LogLevel&lt;/code&gt; of the &lt;code&gt;sharedLog&lt;/code&gt; and the &lt;code&gt;defaultLogLevel&lt;/code&gt;; additionally the condition passed must be &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">데이터가 처리되도록, &lt;code&gt;LogLevel&lt;/code&gt; 에 로그 호출은 커야하거나 동일 &lt;code&gt;LogLevel&lt;/code&gt; 에 의 &lt;code&gt;sharedLog&lt;/code&gt; 및 &lt;code&gt;defaultLogLevel&lt;/code&gt; ; 또한 전달 된 조건이 &lt;code&gt;true&lt;/code&gt; 여야 합니다 .</target>
        </trans-unit>
        <trans-unit id="7bb3ac7d5c9d6c962a9241e9025396626aa9beb6" translate="yes" xml:space="preserve">
          <source>In order for the resulting log message to be logged the &lt;code&gt;LogLevel&lt;/code&gt; must be greater or equal than the &lt;code&gt;LogLevel&lt;/code&gt; of the &lt;code&gt;sharedLog&lt;/code&gt; and must be greater or equal than the global &lt;code&gt;LogLevel&lt;/code&gt;. Additionally the &lt;code&gt;LogLevel&lt;/code&gt; must be greater or equal than the &lt;code&gt;LogLevel&lt;/code&gt; of the &lt;code&gt;stdSharedLogger&lt;/code&gt;.</source>
          <target state="translated">결과 로그 메시지를 기록하려면 &lt;code&gt;LogLevel&lt;/code&gt; 이 &lt;code&gt;sharedLog&lt;/code&gt; 의 &lt;code&gt;LogLevel&lt;/code&gt; 보다 크거나 같아야하며 전역 &lt;code&gt;LogLevel&lt;/code&gt; 보다 크거나 같아야합니다 . 추가적으로 &lt;code&gt;LogLevel&lt;/code&gt; 에이 클 수 또는보다 동일해야합니다 &lt;code&gt;LogLevel&lt;/code&gt; 에 의 &lt;code&gt;stdSharedLogger&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="79abe30476f4ca10a8c01c609e3f868cb8a10f27" translate="yes" xml:space="preserve">
          <source>In order for the resulting log message to be logged the &lt;code&gt;LogLevel&lt;/code&gt; must be greater or equal than the &lt;code&gt;LogLevel&lt;/code&gt; of the &lt;code&gt;stdThreadLocalLog&lt;/code&gt; and must be greater or equal than the global &lt;code&gt;LogLevel&lt;/code&gt;. Additionally the &lt;code&gt;LogLevel&lt;/code&gt; must be greater or equal than the &lt;code&gt;LogLevel&lt;/code&gt; of the &lt;code&gt;stdSharedLogger&lt;/code&gt;. If a condition is given, it must evaluate to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">결과 로그 메시지를 기록하려면 &lt;code&gt;LogLevel&lt;/code&gt; 이 &lt;code&gt;stdThreadLocalLog&lt;/code&gt; 의 &lt;code&gt;LogLevel&lt;/code&gt; 보다 크거나 같아야하며 전역 &lt;code&gt;LogLevel&lt;/code&gt; 보다 크거나 같아야합니다 . 추가적으로 &lt;code&gt;LogLevel&lt;/code&gt; 에이 클 수 또는보다 동일해야합니다 &lt;code&gt;LogLevel&lt;/code&gt; 에 의 &lt;code&gt;stdSharedLogger&lt;/code&gt; . 조건이 제공되면 &lt;code&gt;true&lt;/code&gt; 로 평가해야 합니다 .</target>
        </trans-unit>
        <trans-unit id="18e494163438a3079c18b40fa80b56a34c4d5c22" translate="yes" xml:space="preserve">
          <source>In order for the resulting log message to be logged the &lt;code&gt;LogLevel&lt;/code&gt; must be greater or equal than the &lt;code&gt;LogLevel&lt;/code&gt; of the used &lt;code&gt;Logger&lt;/code&gt; and must be greater or equal than the global &lt;code&gt;LogLevel&lt;/code&gt; additionally the condition passed must be &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">결과 로그 메시지 순서로 기록 될 &lt;code&gt;LogLevel&lt;/code&gt; 에가 크거나 같해야 &lt;code&gt;LogLevel&lt;/code&gt; 에 사용한의 &lt;code&gt;Logger&lt;/code&gt; 및 크거나 같 글로벌해야 &lt;code&gt;LogLevel&lt;/code&gt; 에 부가 조건이 있어야 통과 &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a2b84c1fc96a4a1e141069ab63dfce487512e519" translate="yes" xml:space="preserve">
          <source>In order for the resulting log message to be logged the &lt;code&gt;LogLevel&lt;/code&gt; must be greater or equal than the &lt;code&gt;LogLevel&lt;/code&gt; of the used &lt;code&gt;Logger&lt;/code&gt; and must be greater or equal than the global &lt;code&gt;LogLevel&lt;/code&gt; additionally the passed condition must be &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">결과 로그 메시지 순서로 기록 될 &lt;code&gt;LogLevel&lt;/code&gt; 에가 크거나 같해야 &lt;code&gt;LogLevel&lt;/code&gt; 에 사용한의 &lt;code&gt;Logger&lt;/code&gt; 및 커야 또는 글로벌 같 &lt;code&gt;LogLevel&lt;/code&gt; 에 별도로 전달 상태이어야 &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6c8530a345a9b66847038330015135156125389c" translate="yes" xml:space="preserve">
          <source>In order for the resulting log message to be logged the &lt;code&gt;LogLevel&lt;/code&gt; must be greater or equal than the &lt;code&gt;LogLevel&lt;/code&gt; of the used &lt;code&gt;Logger&lt;/code&gt; and must be greater or equal than the global &lt;code&gt;LogLevel&lt;/code&gt; and the condition must be &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">결과 로그 메시지를 기록하려면 &lt;code&gt;LogLevel&lt;/code&gt; 이 사용 된 &lt;code&gt;Logger&lt;/code&gt; 의 &lt;code&gt;LogLevel&lt;/code&gt; 보다 크거나 같아야하며 전역 &lt;code&gt;LogLevel&lt;/code&gt; 보다 크거나 같아야 하며 조건이 &lt;code&gt;true&lt;/code&gt; 여야 합니다 .</target>
        </trans-unit>
        <trans-unit id="20b9f3f3bdcf58be250caee88b15a55353fecc84" translate="yes" xml:space="preserve">
          <source>In order for the resulting log message to be logged the &lt;code&gt;LogLevel&lt;/code&gt; must be greater or equal than the &lt;code&gt;LogLevel&lt;/code&gt; of the used &lt;code&gt;Logger&lt;/code&gt; and must be greater or equal than the global &lt;code&gt;LogLevel&lt;/code&gt;.</source>
          <target state="translated">결과 로그 메시지를 기록하려면 &lt;code&gt;LogLevel&lt;/code&gt; 이 사용 된 &lt;code&gt;Logger&lt;/code&gt; 의 &lt;code&gt;LogLevel&lt;/code&gt; 보다 크거나 같아야하며 전역 &lt;code&gt;LogLevel&lt;/code&gt; 보다 크거나 같아야합니다 .</target>
        </trans-unit>
        <trans-unit id="41a290703568517f05854f40487a48abaf094d9a" translate="yes" xml:space="preserve">
          <source>In order for the resulting log message to be logged the &lt;code&gt;LogLevel&lt;/code&gt; of the used &lt;code&gt;Logger&lt;/code&gt; must be greater or equal than the global &lt;code&gt;LogLevel&lt;/code&gt; and the condition must be &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">결과 로그 메시지가 기록 되려면 사용 된 &lt;code&gt;Logger&lt;/code&gt; 의 &lt;code&gt;LogLevel&lt;/code&gt; 이 전역 &lt;code&gt;LogLevel&lt;/code&gt; 보다 크거나 같아야 하며 조건이 &lt;code&gt;true&lt;/code&gt; 여야 합니다 .</target>
        </trans-unit>
        <trans-unit id="61c93a13b86326686a55e702c7620856cee5be12" translate="yes" xml:space="preserve">
          <source>In order for the resulting log message to be logged the &lt;code&gt;LogLevel&lt;/code&gt; of the used &lt;code&gt;Logger&lt;/code&gt; must be greater or equal than the global &lt;code&gt;LogLevel&lt;/code&gt;.</source>
          <target state="translated">결과 로그 메시지를 기록 하려면 사용 된 &lt;code&gt;Logger&lt;/code&gt; 의 &lt;code&gt;LogLevel&lt;/code&gt; 이 전역 &lt;code&gt;LogLevel&lt;/code&gt; 보다 크거나 같아야합니다 .</target>
        </trans-unit>
        <trans-unit id="9091984c8dee40a3793a920b8fc726ff3fb2b605" translate="yes" xml:space="preserve">
          <source>In order to be usable as an allocator, a type should implement the following methods with their respective semantics. Only &lt;code&gt;alignment&lt;/code&gt; and &lt;code&gt;allocate&lt;/code&gt; are required. If any of the other methods is missing, the allocator is assumed to not have that capability (for example some allocators do not offer manual deallocation of memory). Allocators should NOT implement unsupported methods to always fail. For example, an allocator that lacks the capability to implement &lt;code&gt;alignedAllocate&lt;/code&gt; should not define it at all (as opposed to defining it to always return &lt;code&gt;null&lt;/code&gt; or throw an exception). The missing implementation statically informs other components about the allocator's capabilities and allows them to make design decisions accordingly.</source>
          <target state="translated">할당 자로 사용할 수 있으려면 형식이 각각의 의미와 함께 다음 방법을 구현해야합니다. 만 &lt;code&gt;alignment&lt;/code&gt; 및 &lt;code&gt;allocate&lt;/code&gt; 해야합니다. 다른 방법 중 하나라도 누락 된 경우 할당자는 해당 기능이없는 것으로 간주됩니다 (예 : 일부 할당자는 수동 메모리 할당 해제를 제공하지 않음). 할당자는 항상 실패하도록 지원되지 않는 메소드를 구현해서는 안됩니다. 예를 들어, &lt;code&gt;alignedAllocate&lt;/code&gt; 를 구현할 수있는 할당자가없는 할당자는 항상 &lt;code&gt;null&lt;/code&gt; 하거나 예외를 발생 시키 도록 정의하는 것과 달리이를 정의해서는 안됩니다 . 누락 된 구현은 다른 구성 요소에 할당 자의 기능을 정적으로 알리고 그에 따라 디자인 결정을 내릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6dda110f1f25b5663505eb11f44cd82e44a8c31d" translate="yes" xml:space="preserve">
          <source>In order to determine if an object &lt;code&gt;o&lt;/code&gt; is an instance of a class &lt;code&gt;B&lt;/code&gt; use a cast:</source>
          <target state="translated">객체 &lt;code&gt;o&lt;/code&gt; 가 클래스 &lt;code&gt;B&lt;/code&gt; 의 인스턴스 인지 확인하려면 캐스트를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="1e18ff30e3740b378cdaf28cc4934f896ccbee30" translate="yes" xml:space="preserve">
          <source>In order to disable logging at compile time, pass &lt;code&gt;StdLoggerDisableLogging&lt;/code&gt; as a version argument to the &lt;code&gt;D&lt;/code&gt; compiler when compiling your program code. This will disable all logging functionality. Specific &lt;code&gt;LogLevel&lt;/code&gt; can be disabled at compile time as well. In order to disable logging with the &lt;code&gt;trace&lt;/code&gt;&lt;code&gt;LogLevel&lt;/code&gt; pass &lt;code&gt;StdLoggerDisableTrace&lt;/code&gt; as a version. The following table shows which version statement disables which &lt;code&gt;LogLevel&lt;/code&gt;.</source>
          <target state="translated">컴파일시 로깅을 비활성화하려면 프로그램 코드를 컴파일 할 때 &lt;code&gt;StdLoggerDisableLogging&lt;/code&gt; 을 버전 컴파일러로 &lt;code&gt;D&lt;/code&gt; 컴파일러에 전달 하십시오. 모든 로깅 기능이 비활성화됩니다. 컴파일시 특정 &lt;code&gt;LogLevel&lt;/code&gt; 을 비활성화 할 수도 있습니다. &lt;code&gt;trace&lt;/code&gt; &lt;code&gt;LogLevel&lt;/code&gt; 을 사용하여 로깅을 사용하지 않으 &lt;code&gt;StdLoggerDisableTrace&lt;/code&gt; 를 버전으로 전달 하십시오 . 다음 표는 어떤 버전 문이 어떤 &lt;code&gt;LogLevel&lt;/code&gt; 을 비활성화하는지 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="a77a52d87761074b435f02e38ba4ed22e517df1c" translate="yes" xml:space="preserve">
          <source>In order to do put the length at the front, we have to provide 16 bytes buffer space in case the block has to be aligned properly. In x86, certain SSE instructions will only work if the data is 16-byte aligned. In addition, we need the sentinel byte to prevent accidental pointers to the next block. Because of the extra overhead, we only do this for page size and above, where the overhead is minimal compared to the block size.</source>
          <target state="translated">길이를 앞에 두려면 블록을 올바르게 정렬해야하는 경우 16 바이트의 버퍼 공간을 제공해야합니다. x86에서 특정 SSE 명령어는 데이터가 16 바이트로 정렬 된 경우에만 작동합니다. 또한 우연히 다음 블록에 대한 포인터를 방지하기 위해 센티넬 바이트가 필요합니다. 여분의 오버 헤드로 인해 페이지 크기 이상에 대해서만이 작업을 수행하며, 블록 크기에 비해 오버 헤드가 최소화됩니다.</target>
        </trans-unit>
        <trans-unit id="0cc93ffa6b67fa20835799cad3635970d48f4206" translate="yes" xml:space="preserve">
          <source>In order to work, &lt;code&gt;FallbackAllocator&lt;/code&gt; requires that &lt;code&gt;Primary&lt;/code&gt; defines the &lt;code&gt;owns&lt;/code&gt; method. This is needed in order to decide which allocator was responsible for a given allocation.</source>
          <target state="translated">&lt;code&gt;FallbackAllocator&lt;/code&gt; 가 작동 하려면 &lt;code&gt;Primary&lt;/code&gt; 가 &lt;code&gt;owns&lt;/code&gt; 메소드를 정의 해야합니다 . 이것은 주어진 할당을 담당 한 할당자를 결정하기 위해 필요합니다.</target>
        </trans-unit>
        <trans-unit id="3cb2dd17fb05bd389b6b34ea2ea85ffe8dc6328a" translate="yes" xml:space="preserve">
          <source>In other words, casting literal expression will change the literal type.</source>
          <target state="translated">즉, 리터럴 표현식을 캐스팅하면 리터럴 유형이 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="675933f346891ba4fb04a779eea3dd5e21b2c0bb" translate="yes" xml:space="preserve">
          <source>In previous versions of Phobos, this was known as &lt;code&gt;TypeTuple&lt;/code&gt;.</source>
          <target state="translated">이전 버전의 &lt;code&gt;TypeTuple&lt;/code&gt; 에서는이 유형을 TypeTuple 이라고했습니다 .</target>
        </trans-unit>
        <trans-unit id="26154800831f1a5ff6a19e1167b2ddcacfdb1c76" translate="yes" xml:space="preserve">
          <source>In principle, only thrown objects derived from this class are safe to catch inside a &lt;code&gt;catch&lt;/code&gt; block. Thrown objects not derived from Exception represent runtime errors that should not be caught, as certain runtime guarantees may not hold, making it unsafe to continue program execution.</source>
          <target state="translated">원칙적으로이 클래스에서 파생 된 객체 만 &lt;code&gt;catch&lt;/code&gt; 블록 내부에서 안전하게 잡을 수 있습니다. 예외에서 파생되지 않은 throw 된 객체는 특정 런타임 보장이 유지되지 않아 프로그램 실행을 계속하는 것이 안전하지 않으므로 잡히지 않아야하는 런타임 오류를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="0b93464d0fbabeded10a475db02ab91f9147bd5b" translate="yes" xml:space="preserve">
          <source>In principle, this is the name of the local time zone. However, this always returns the empty string. This is because time zones cannot be uniquely identified by the attributes given by the OS (such as the &lt;code&gt;stdName&lt;/code&gt; and &lt;code&gt;dstName&lt;/code&gt;), and neither Posix systems nor Windows systems provide an easy way to get the TZ Database name of the local time zone.</source>
          <target state="translated">원칙적으로 이것은 현지 시간대의 이름입니다. 그러나 항상 빈 문자열을 반환합니다. 표준 시간대는 OS에서 제공 한 속성 (예 : &lt;code&gt;stdName&lt;/code&gt; 및 &lt;code&gt;dstName&lt;/code&gt; ) 으로 고유하게 식별 할 수 없으며 Posix 시스템과 Windows 시스템이 로컬 시간대의 TZ 데이터베이스 이름을 쉽게 얻을 수있는 방법을 제공하지 않기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="0b9fb0301ede6ae1f71c55d50ab376078de554f8" translate="yes" xml:space="preserve">
          <source>In single line mode matches any character. Otherwise it matches any character except '\n' and '\r'.</source>
          <target state="translated">한 줄 모드에서는 모든 문자와 일치합니다. 그렇지 않으면 '\ n'및 '\ r'을 제외한 모든 문자와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="77c1db69e3f99eb322088fa8127b36e0134ab790" translate="yes" xml:space="preserve">
          <source>In some date calculations, adding months or years can cause the date to fall on a day of the month which is not valid (e.g. February 29th 2001 or June 31st 2000). If overflow is allowed (as is the default), then the month will be incremented accordingly (so, February 29th 2001 would become March 1st 2001, and June 31st 2000 would become July 1st 2000). If overflow is not allowed, then the day will be adjusted to the last valid day in that month (so, February 29th 2001 would become February 28th 2001 and June 31st 2000 would become June 30th 2000).</source>
          <target state="translated">일부 날짜 계산에서 월 또는 연도를 추가하면 날짜가 유효하지 않은 날짜에 떨어질 수 있습니다 (예 : 2001 년 2 월 29 일 또는 2000 년 6 월 31 일). 오버플로가 허용되면 (기본값으로) 월이 증가합니다 (2001 년 2 월 29 일은 2001 년 3 월 1 일이되고 2000 년 6 월 31 일은 2000 년 7 월 1 일이됩니다). 오버플로가 허용되지 않으면 날짜는 해당 월의 마지막 유효 날짜로 조정됩니다 (2001 년 2 월 29 일은 2001 년 2 월 28 일이되고 2000 년 6 월 31 일은 2000 년 6 월 30 일이됩니다).</target>
        </trans-unit>
        <trans-unit id="0f7765db47c238a56000c8a0537e8a769de4649d" translate="yes" xml:space="preserve">
          <source>In std.datetime, it is also used as the result of various arithmetic operations on time points.</source>
          <target state="translated">std.datetime에서는 시점에 대한 다양한 산술 연산의 결과로도 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9d8f072b0ee81fd114d71e25f9472d419503fd30" translate="yes" xml:space="preserve">
          <source>In the above situations the errors do not contain line numbers because the errors are regarding generated code.</source>
          <target state="translated">위의 상황에서 오류는 생성 된 코드와 관련되므로 오류에 줄 번호가 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="83c0d2545855dad1e2136f8a2d0797213523dbd3" translate="yes" xml:space="preserve">
          <source>In the case above, the element at slot &lt;code&gt;1&lt;/code&gt; is removed, but replaced with the last element of the range. Taking advantage of the relaxation of the stability requirement, &lt;code&gt;remove&lt;/code&gt; moved elements from the end of the array over the slots to be removed. This way there is less data movement to be done which improves the execution time of the function.</source>
          <target state="translated">위의 경우 슬롯 &lt;code&gt;1&lt;/code&gt; 의 요소 는 제거되지만 범위의 마지막 요소로 대체됩니다. 안정성 요구 사항 완화를 활용 하여 어레이 끝에서 &lt;code&gt;remove&lt;/code&gt; 할 슬롯 위로 이동 된 요소를 제거하십시오. 이러한 방식으로 수행되는 데이터 이동이 줄어들어 기능의 실행 시간이 향상됩니다.</target>
        </trans-unit>
        <trans-unit id="d1310273f42b4567d006ba733761bffcc94a7323" translate="yes" xml:space="preserve">
          <source>In the case of multisets, considering that element &lt;code&gt;a&lt;/code&gt; appears &lt;code&gt;x&lt;/code&gt; times in &lt;code&gt;r1&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; times and &lt;code&gt;r2&lt;/code&gt;, the number of occurences of &lt;code&gt;a&lt;/code&gt; in the resulting range is going to be &lt;code&gt;x-y&lt;/code&gt; if x &amp;gt; y or 0 otherwise.</source>
          <target state="translated">다중 집합의 경우 요소 &lt;code&gt;a&lt;/code&gt; 가 &lt;code&gt;r1&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;r2&lt;/code&gt; 에 x 번 나타나는 것을 고려할 때 결과 범위에서 &lt;code&gt;a&lt;/code&gt; 의 발생 횟수는 x&amp;gt; y 또는 0이면 &lt;code&gt;x-y&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="574341dd05f59907247dd44e449ed7bd5386146b" translate="yes" xml:space="preserve">
          <source>In the case of multisets, the range with the minimum number of occurences of a given element, propagates the number of occurences of this element to the resulting range.</source>
          <target state="translated">다중 집합의 경우, 주어진 요소의 발생 수가 최소 인 범위는이 요소의 발생 횟수를 결과 범위로 전파합니다.</target>
        </trans-unit>
        <trans-unit id="c31bb38a42ef0f5a89fce05942de3e9a5d76ab7c" translate="yes" xml:space="preserve">
          <source>In the case of the monotonic time, &lt;a href=&quot;#MonoTimeImpl&quot;&gt;&lt;code&gt;MonoTimeImpl&lt;/code&gt;&lt;/a&gt; is templatized on &lt;code&gt;ClockType&lt;/code&gt;, whereas with &lt;code&gt;std.datetime.Clock.currTime&lt;/code&gt;, its a runtime argument, since in the case of the monotonic time, the type of the clock affects the resolution of a &lt;a href=&quot;#MonoTimeImpl&quot;&gt;&lt;code&gt;MonoTimeImpl&lt;/code&gt;&lt;/a&gt; object, whereas with &lt;a href=&quot;std_datetime#SysTime&quot;&gt;&lt;code&gt;std.datetime.SysTime&lt;/code&gt;&lt;/a&gt;, its resolution is always hecto-nanoseconds regardless of the source of the time.</source>
          <target state="translated">단조 시간의 경우 &lt;a href=&quot;#MonoTimeImpl&quot;&gt; &lt;code&gt;MonoTimeImpl&lt;/code&gt; &lt;/a&gt; 은 &lt;code&gt;ClockType&lt;/code&gt; 에서 템플릿 화되는 반면 &lt;code&gt;std.datetime.Clock.currTime&lt;/code&gt; 에서는 런타임 인수입니다. 단조 시간의 경우 클럭 유형이 &lt;a href=&quot;#MonoTimeImpl&quot;&gt; &lt;code&gt;MonoTimeImpl&lt;/code&gt; &lt;/a&gt; 객체 의 해상도에 영향을 미치기 때문에 와 반면 &lt;a href=&quot;std_datetime#SysTime&quot;&gt; &lt;code&gt;std.datetime.SysTime&lt;/code&gt; &lt;/a&gt; , 그 해상도는 항상 시간에 관계없이 소스의 헥토 - 나노초.</target>
        </trans-unit>
        <trans-unit id="48d19d43ba624ca8d4f15f601b46da39df170632" translate="yes" xml:space="preserve">
          <source>In the corresponding D code, &lt;code&gt;foo&lt;/code&gt; is declared as having C++ linkage and function calling conventions:</source>
          <target state="translated">해당 D 코드에서 &lt;code&gt;foo&lt;/code&gt; 는 C ++ 연결 및 함수 호출 규칙이있는 것으로 선언됩니다.</target>
        </trans-unit>
        <trans-unit id="c2859b376d9322070e57e0df9e0b545f1ad11ef9" translate="yes" xml:space="preserve">
          <source>In the current function, we are calling 'this' function. 1. Check to see if the current function can call 'this' function, issue error if not. 2. If the current function is not the parent of 'this' function, then add the current function to the list of siblings of 'this' function. 3. If the current function is a literal, and it's accessing an uplevel scope, then mark it as a delegate. Returns true if error occurs.</source>
          <target state="translated">현재 함수에서 'this'함수를 호출합니다. 1. 현재 함수가 'this'함수를 호출 할 수 있는지 확인하십시오. 그렇지 않으면 오류를 발행하십시오. 2. 현재 기능이 'this'기능의 부모가 아닌 경우 현재 기능을 'this'기능의 형제 목록에 추가하십시오. 3. 현재 함수가 리터럴이고 상위 범위에 액세스하는 경우이를 델리게이트로 표시하십시오. 오류가 발생하면 true를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="27341e1e33d3f1a9c524981309a60954fc820a69" translate="yes" xml:space="preserve">
          <source>In the example above, &quot;--foo&quot; and &quot;--bar&quot; are recognized, but &quot;--Foo&quot;, &quot;--Bar&quot;, &quot;--FOo&quot;, &quot;--bAr&quot;, etc. are rejected. The directive is active until the end of &lt;code&gt;getopt&lt;/code&gt;, or until the converse directive &lt;code&gt;caseInsensitive&lt;/code&gt; is encountered:</source>
          <target state="translated">위의 예에서 &quot;--foo&quot;및 &quot;--bar&quot;는 인식되지만 &quot;--Foo&quot;, &quot;--Bar&quot;, &quot;--FOo&quot;, &quot;--bAr&quot;등은 거부됩니다. 지시문은 &lt;code&gt;getopt&lt;/code&gt; 끝까지 또는 converse 지시문 &lt;code&gt;caseInsensitive&lt;/code&gt; 가 발견 될 때까지 활성화 됩니다.</target>
        </trans-unit>
        <trans-unit id="7dcfec5a000e233202dfdaec8aa04adf1d224016" translate="yes" xml:space="preserve">
          <source>In the first form, they are enclosed between &lt;code&gt;r&quot;&lt;/code&gt; and &lt;code&gt;&quot;&lt;/code&gt;. All characters between the &lt;code&gt;r&quot;&lt;/code&gt; and &lt;code&gt;&quot;&lt;/code&gt; are part of the string. There are no escape sequences inside wysiwyg strings.</source>
          <target state="translated">첫 번째 형식에서는 &lt;code&gt;r&quot;&lt;/code&gt; 과 &lt;code&gt;&quot;&lt;/code&gt; 로 묶여 있습니다. &lt;code&gt;r&quot;&lt;/code&gt; 과 &lt;code&gt;&quot;&lt;/code&gt; 사이의 모든 문자 는 문자열의 일부입니다. wysiwyg 문자열에는 이스케이프 시퀀스가 ​​없습니다.</target>
        </trans-unit>
        <trans-unit id="4dfbc2e24539434e62842bac389911ff9852ba28" translate="yes" xml:space="preserve">
          <source>In the graph above, any directed path is a legal implicit conversion. No other qualifier combinations than the ones shown is valid. If a directed path exists between two sets of qualifiers, the types thus qualified are called &lt;a href=&quot;http://dlang.org/glossary.html#qualifier-convertible&quot;&gt;qualifier-convertible&lt;/a&gt;. The same information is shown below in tabular format:</source>
          <target state="translated">위의 그래프에서 모든 지정 경로는 유효한 암시 적 변환입니다. 표시된 것 이외의 다른 한정자 조합은 유효하지 않습니다. 두 세트의 규정 자 사이에 지정 경로가 존재하면 규정 된 유형을 &lt;a href=&quot;http://dlang.org/glossary.html#qualifier-convertible&quot;&gt;규정 자 변환 가능&lt;/a&gt; 이라고 합니다. 동일한 정보가 아래 표 형식으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="548184d81c8367496889a62c80302a94556ca090" translate="yes" xml:space="preserve">
          <source>In the graph above, any directed path is a legal implicit conversion. No other qualifier combinations than the ones shown is valid. If a directed path exists between two sets of qualifiers, the types thus qualified are called &lt;a href=&quot;https://dlang.org/glossary.html#qualifier-convertible&quot;&gt;qualifier-convertible&lt;/a&gt;. The same information is shown below in tabular format:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02f036d56e5b0f17d6cada283807ab6e4a45c16d" translate="yes" xml:space="preserve">
          <source>In the second step, path components are compared using &lt;code&gt;filenameCmp!cs&lt;/code&gt;, where &lt;code&gt;cs&lt;/code&gt; is an optional template parameter determining whether the comparison is case sensitive or not. See the &lt;a href=&quot;#filenameCmp&quot;&gt;&lt;code&gt;filenameCmp&lt;/code&gt;&lt;/a&gt; documentation for details.</source>
          <target state="translated">두 번째 단계에서 &lt;code&gt;filenameCmp!cs&lt;/code&gt; 사용하여 경로 구성 요소를 비교합니다 . 여기서 &lt;code&gt;cs&lt;/code&gt; 는 비교가 대소 문자를 구분하는지 여부를 결정하는 선택적 템플리트 매개 변수입니다. 자세한 내용은 &lt;a href=&quot;#filenameCmp&quot;&gt; &lt;code&gt;filenameCmp&lt;/code&gt; &lt;/a&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e25b68a7396b82d8e5f58fe981088b3bb4f8c195" translate="yes" xml:space="preserve">
          <source>In the special case where only a single function is provided (&lt;code&gt;F.length == 1&lt;/code&gt;), adjoin simply aliases to the single passed function (&lt;code&gt;F[0]&lt;/code&gt;).</source>
          <target state="translated">단일 함수 만 제공되는 특수한 경우 ( &lt;code&gt;F.length == 1&lt;/code&gt; ), 전달 된 단일 함수 ( &lt;code&gt;F[0]&lt;/code&gt; )에 간단히 별칭을 붙 입니다.</target>
        </trans-unit>
        <trans-unit id="0d9fe9a61d26a09ceb6b95fd6ad82498884dadd5" translate="yes" xml:space="preserve">
          <source>In the table below, the &lt;b&gt;exact alias&lt;/b&gt;es are types of exactly the specified number of bits. The &lt;b&gt;at least alias&lt;/b&gt;es are at least the specified number of bits large, and can be larger. The &lt;b&gt;fast alias&lt;/b&gt;es are the fastest integral type supported by the processor that is at least as wide as the specified number of bits.</source>
          <target state="translated">아래 표에서 &lt;b&gt;정확한 별칭&lt;/b&gt; 은 정확히 지정된 비트 수의 유형입니다. &lt;b&gt;적어도 별명&lt;/b&gt; ES 적어도 큰 지정된 비트 수 있으며, 클 수있다. &lt;b&gt;빠른 별명&lt;/b&gt; ES는 지정된 비트 수가 적어도 같은 폭이며, 상기 프로세서에 의해 지원되는 빠른 일체형이다.</target>
        </trans-unit>
        <trans-unit id="2b57bd98576c6b47e51f692ed2880671dfdcaf21" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;myAllocator&lt;/code&gt; does not obey the &lt;code&gt;IAllocator&lt;/code&gt; interface, but implements its primitives so it can work with &lt;code&gt;makeArray&lt;/code&gt; by means of duck typing.  One important thing to note about this setup is that statically-typed assembled allocators are almost always faster than allocators that go through &lt;code&gt;IAllocator&lt;/code&gt;. An important rule of thumb is: &quot;assemble allocator first, adapt to &lt;code&gt;IAllocator&lt;/code&gt; after&quot;. A good allocator implements intricate logic by means of template assembly, and gets wrapped with &lt;code&gt;IAllocator&lt;/code&gt; (usually by means of &lt;a href=&quot;#allocatorObject&quot;&gt;&lt;code&gt;allocatorObject&lt;/code&gt;&lt;/a&gt;) only once, at client level.</source>
          <target state="translated">이 경우 &lt;code&gt;myAllocator&lt;/code&gt; 는 &lt;code&gt;IAllocator&lt;/code&gt; 인터페이스를 따르지 않지만 기본을 구현하므로 오리 입력을 통해 &lt;code&gt;makeArray&lt;/code&gt; 로 작업 할 수 있습니다 . 이 설정에 대해 주목해야 할 중요한 사항 중 하나는 정적 형식의 어셈블러 할당자가 &lt;code&gt;IAllocator&lt;/code&gt; 를 거치는 할당 자보다 거의 항상 빠르다는 것 입니다. 중요한 경험 법칙은 &quot;할당자를 먼저 조립하고 이후 에 &lt;code&gt;IAllocator&lt;/code&gt; 에 적응 &quot;입니다. 좋은 할당자는 템플릿 어셈블리를 통해 복잡한 논리를 구현 하고 클라이언트 수준에서 &lt;code&gt;IAllocator&lt;/code&gt; (일반적으로 &lt;a href=&quot;#allocatorObject&quot;&gt; &lt;code&gt;allocatorObject&lt;/code&gt; 를 통해&lt;/a&gt; )로 한 번만 래핑 됩니다.</target>
        </trans-unit>
        <trans-unit id="0dbb9df98ee1772b091a23269b418c611c6689cc" translate="yes" xml:space="preserve">
          <source>In this case, the slots at positions 1, 3, 4, and 9 are removed from the array.</source>
          <target state="translated">이 경우 위치 1, 3, 4 및 9의 슬롯이 어레이에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="abbca933ccd59e3aed3eca6e5f8800c940d98fda" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;input&lt;/code&gt; will only be read and no reference to it will be kept around, while &lt;code&gt;count&lt;/code&gt; will be read and written to, and &lt;code&gt;errno&lt;/code&gt; will be set to a value from within the function. This approach gives a semantic meaning to the parameters and allows the compiler to potentially optimize the generated code.</source>
          <target state="translated">이 예에서 &lt;code&gt;input&lt;/code&gt; 은 읽기 전용이며 이에 대한 참조는 유지되지 않지만 &lt;code&gt;count&lt;/code&gt; 는 읽고 기록되며 &lt;code&gt;errno&lt;/code&gt; 는 함수 내에서 값으로 설정됩니다. 이 접근법은 매개 변수에 의미 론적 의미를 부여하고 컴파일러가 생성 된 코드를 잠재적으로 최적화 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="4ea7dd88fb0b01ff371e8dd1a464cf7603046447" translate="yes" xml:space="preserve">
          <source>In this example, the argument &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt; gets bind to &lt;code&gt;input&lt;/code&gt;, &lt;code&gt;a&lt;/code&gt; gets bind to &lt;code&gt;count&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; to &lt;code&gt;errno&lt;/code&gt;.</source>
          <target state="translated">이 예에서는 인수 &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt; 에 바인드를 얻을 &lt;code&gt;input&lt;/code&gt; , &lt;code&gt;a&lt;/code&gt; 바인딩 얻을 수 &lt;code&gt;count&lt;/code&gt; 및 &lt;code&gt;b&lt;/code&gt; 에 &lt;code&gt;errno&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="5961fb400c229a03dfc935fa996c5fe8fc78fdb9" translate="yes" xml:space="preserve">
          <source>In this implementation both arguments must be positive. The integral is evaluated by either a power series or continued fraction expansion, depending on the relative values of a and x.</source>
          <target state="translated">이 구현에서 두 인수 모두 긍정적이어야합니다. 적분은 a와 x의 상대 값에 따라 거듭 제곱 또는 연속 분수 확장으로 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="bd2e85eebf3596f12832975a35b8c3545510433f" translate="yes" xml:space="preserve">
          <source>In this situation, the assignemnts are actual assign expressions (&lt;code&gt;opAssign&lt;/code&gt; is used if defined).</source>
          <target state="translated">이 상황에서 assignemnts는 실제 assign 표현식입니다 ( &lt;code&gt;opAssign&lt;/code&gt; 정의 된 경우 opAssign 이 사용됨).</target>
        </trans-unit>
        <trans-unit id="cecc30a8b51b4071bb5efaef87b2c1dec1a96284" translate="yes" xml:space="preserve">
          <source>In this table &quot;doPut&quot; is a method that places &lt;code&gt;e&lt;/code&gt; into &lt;code&gt;r&lt;/code&gt;, using the correct primitive: &lt;code&gt;r.put(e)&lt;/code&gt; if &lt;code&gt;R&lt;/code&gt; defines &lt;code&gt;put&lt;/code&gt;, &lt;code&gt;r.front = e&lt;/code&gt; if &lt;code&gt;r&lt;/code&gt; is an input range (followed by &lt;code&gt;r.popFront()&lt;/code&gt;), or &lt;code&gt;r(e)&lt;/code&gt; otherwise.</source>
          <target state="translated">이 표에서 &quot;doPut&quot;은 올바른 기본 요소를 사용하여 &lt;code&gt;e&lt;/code&gt; 를 &lt;code&gt;r&lt;/code&gt; 에 배치하는 방법입니다 . &lt;code&gt;R&lt;/code&gt; 이 &lt;code&gt;put&lt;/code&gt; 을 정의 하면 &lt;code&gt;r.put(e)&lt;/code&gt; , &lt;code&gt;r&lt;/code&gt; 이 입력 범위 인 경우 &lt;code&gt;r.front = e&lt;/code&gt; ( &lt;code&gt;r.popFront()&lt;/code&gt; ), 그렇지 않으면 &lt;code&gt;r(e)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="02a8b5c14dc9548c1a490e9d5960a9feca99259a" translate="yes" xml:space="preserve">
          <source>In this way a struct or class object can behave as if it were a function.</source>
          <target state="translated">이런 식으로 구조체 나 클래스 객체는 마치 함수 인 것처럼 동작 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="17982ced0afda199d35d40c9d0672932dd55162a" translate="yes" xml:space="preserve">
          <source>In this way a struct or class object can behave as if it were an array.</source>
          <target state="translated">이런 식으로 구조체 나 클래스 객체는 마치 마치 배열 인 것처럼 동작 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="86f8f90c18dbc0f9d343ef02fb0a4cd117e4553c" translate="yes" xml:space="preserve">
          <source>In user code. This class also provides means to add version identifier to the list of global (cross module) identifiers.</source>
          <target state="translated">사용자 코드에서. 이 클래스는 또한 글로벌 (크로스 모듈) 식별자 목록에 버전 식별자를 추가하는 수단을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="bdee4d1acbdd89d7f24aebad7aeee092188b3727" translate="yes" xml:space="preserve">
          <source>In, Out and Inheritance</source>
          <target state="translated">인, 아웃 및 상속</target>
        </trans-unit>
        <trans-unit id="783253f63cea9c514d69689860a1ae050327457b" translate="yes" xml:space="preserve">
          <source>In-order Pentium (Pentium1, PMMX, Atom)</source>
          <target state="translated">주문형 펜티엄 (Pentium1, PMMX, Atom)</target>
        </trans-unit>
        <trans-unit id="7d5a97d89ad4a3be9582069b3310a6d0aee11430" translate="yes" xml:space="preserve">
          <source>InExpression</source>
          <target state="translated">InExpression</target>
        </trans-unit>
        <trans-unit id="6b952134a590c37c3cd245f783f0cab0b35e154b" translate="yes" xml:space="preserve">
          <source>Include all of the &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_floating_point&quot;&gt;IEEE754&lt;/a&gt; options.</source>
          <target state="translated">모든 &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_floating_point&quot;&gt;IEEE754&lt;/a&gt; 포함 옵션을 .</target>
        </trans-unit>
        <trans-unit id="21d63116a735028b1065c53175a7201eb75a690c" translate="yes" xml:space="preserve">
          <source>Include none of the above options.</source>
          <target state="translated">위의 옵션을 포함하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="7fb47f835a97695060fa50d3d9efcf9e0fff9c84" translate="yes" xml:space="preserve">
          <source>Includes &lt;code&gt;&quot;hnsecs&quot;&lt;/code&gt; (hecto-nanoseconds (100 ns)), &lt;code&gt;&quot;usecs&quot;&lt;/code&gt; (microseconds), &lt;code&gt;&quot;msecs&quot;&lt;/code&gt; (milliseconds), &lt;code&gt;&quot;seconds&quot;&lt;/code&gt;, &lt;code&gt;&quot;minutes&quot;&lt;/code&gt;, &lt;code&gt;&quot;hours&quot;&lt;/code&gt;, &lt;code&gt;&quot;days&quot;&lt;/code&gt;, &lt;code&gt;&quot;weeks&quot;&lt;/code&gt;, &lt;code&gt;&quot;months&quot;&lt;/code&gt;, and &lt;code&gt;&quot;years&quot;&lt;/code&gt;</source>
          <target state="translated">포함 &lt;code&gt;&quot;hnsecs&quot;&lt;/code&gt; (헥토 - 나노초 (100 NS)), &lt;code&gt;&quot;usecs&quot;&lt;/code&gt; (마이크로 초), &lt;code&gt;&quot;msecs&quot;&lt;/code&gt; (밀리 초), &lt;code&gt;&quot;seconds&quot;&lt;/code&gt; , &lt;code&gt;&quot;minutes&quot;&lt;/code&gt; , &lt;code&gt;&quot;hours&quot;&lt;/code&gt; , &lt;code&gt;&quot;days&quot;&lt;/code&gt; , &lt;code&gt;&quot;weeks&quot;&lt;/code&gt; , &lt;code&gt;&quot;months&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;years&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="660485a4ef4f2ea299a5049e5e7f68faa3ac9dd9" translate="yes" xml:space="preserve">
          <source>Includes characters a, b, c, ..., z.</source>
          <target state="translated">문자 a, b, c, ..., z를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="e622b4457bdf3ceb03f6cf725fab2a67de905818" translate="yes" xml:space="preserve">
          <source>Incomplete beta integral</source>
          <target state="translated">불완전한 베타 통합</target>
        </trans-unit>
        <trans-unit id="861a53fcf5c388edd7cf46ce6d95a43e95f0e787" translate="yes" xml:space="preserve">
          <source>Incomplete gamma integral and its complement</source>
          <target state="translated">불완전한 감마 적분 및 보완</target>
        </trans-unit>
        <trans-unit id="2f08d5bb658237cd92aa5a4432cb1cfef1a4c7b1" translate="yes" xml:space="preserve">
          <source>Incorporate &lt;code&gt;element_count&lt;/code&gt; and finalizes the hash.</source>
          <target state="translated">&lt;code&gt;element_count&lt;/code&gt; 통합 하고 해시를 마무리합니다.</target>
        </trans-unit>
        <trans-unit id="d8c996a9761aab171974108da093507dfd302c9b" translate="yes" xml:space="preserve">
          <source>Increases the reference count of the concrete class that implements this interface.</source>
          <target state="translated">이 인터페이스를 구현하는 구체적 클래스의 참조 횟수를 증가시킵니다.</target>
        </trans-unit>
        <trans-unit id="d12f1fabbb58a9af82666365bdf1d6e784f1a197" translate="yes" xml:space="preserve">
          <source>Increment</source>
          <target state="translated">Increment</target>
        </trans-unit>
        <trans-unit id="6179063ceb022e0b005a77ad50121ce42a8f12e0" translate="yes" xml:space="preserve">
          <source>Incremental options.</source>
          <target state="translated">증분 옵션.</target>
        </trans-unit>
        <trans-unit id="84205e80c2673222d26cbdde35ee1f4333d1b71b" translate="yes" xml:space="preserve">
          <source>Increments &lt;code&gt;numOwns&lt;/code&gt; (per instance and and per call) and forwards to &lt;code&gt; parent.owns(b)&lt;/code&gt;.</source>
          <target state="translated">증분 &lt;code&gt;numOwns&lt;/code&gt; (예 : 당 및 당 통화) 및 전달에 &lt;code&gt; parent.owns(b)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ddaf57d4b4048098b5dfe8043020c47a13b32e0a" translate="yes" xml:space="preserve">
          <source>Independent of the parameter this Logger will never log a message.</source>
          <target state="translated">매개 변수와 상관없이이 로거는 메시지를 기록하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c2df9b932637fe9d32a0f16da1c11873398f873d" translate="yes" xml:space="preserve">
          <source>Index</source>
          <target state="translated">Index</target>
        </trans-unit>
        <trans-unit id="699dc9f4598bf2c18561d09ccbeb25728c70494b" translate="yes" xml:space="preserve">
          <source>Index Assignment Operator Overloading</source>
          <target state="translated">인덱스 할당 연산자 오버로딩</target>
        </trans-unit>
        <trans-unit id="71c97279cf83fc58467572ececa55bdae6e798a5" translate="yes" xml:space="preserve">
          <source>Index Expressions</source>
          <target state="translated">인덱스 표현식</target>
        </trans-unit>
        <trans-unit id="d1893a899240a1b591d897768bc60814a476fa87" translate="yes" xml:space="preserve">
          <source>Index Name NULL</source>
          <target state="translated">인덱스 이름 NULL</target>
        </trans-unit>
        <trans-unit id="e71ed4c87a94b38c5cecf345cf992053ca3a47d3" translate="yes" xml:space="preserve">
          <source>Index Name Table Name</source>
          <target state="translated">인덱스 이름 테이블 이름</target>
        </trans-unit>
        <trans-unit id="96c319248a56deb59ef179cae4ae3f7a3c92eca2" translate="yes" xml:space="preserve">
          <source>Index Of A Parameter With A Given Name</source>
          <target state="translated">주어진 이름을 가진 매개 변수의 색인</target>
        </trans-unit>
        <trans-unit id="bfb09c98cfaf2d55de0462489f758021e1b3f471" translate="yes" xml:space="preserve">
          <source>Index Op Assignment Operator Overloading</source>
          <target state="translated">인덱스 연산 할당 연산자 오버로딩</target>
        </trans-unit>
        <trans-unit id="49fe544cd53fba1ec8f72994e8cce9d496cf27f3" translate="yes" xml:space="preserve">
          <source>Index Operator Overloading</source>
          <target state="translated">인덱스 연산자 오버로딩</target>
        </trans-unit>
        <trans-unit id="a3b9e1c8a8784dafb7f4615ab228a307d1e4a762" translate="yes" xml:space="preserve">
          <source>Index of the argument for positional parameters, from &lt;code&gt;1&lt;/code&gt; to &lt;code&gt;ubyte.max&lt;/code&gt;. (&lt;code&gt;0&lt;/code&gt; means not used).</source>
          <target state="translated">위치 매개 변수의 인수 색인 ( &lt;code&gt;1&lt;/code&gt; - &lt;code&gt;ubyte.max&lt;/code&gt; ) . ( &lt;code&gt;0&lt;/code&gt; 수단이 사용되지 않음).</target>
        </trans-unit>
        <trans-unit id="c34e327ac8e45e062b5805d3beb7a3e4caec8300" translate="yes" xml:space="preserve">
          <source>Index of the last argument for positional parameter range, from &lt;code&gt;1&lt;/code&gt; to &lt;code&gt;ubyte.max&lt;/code&gt;. (&lt;code&gt;0&lt;/code&gt; means not used).</source>
          <target state="translated">위치 매개 변수 범위의 마지막 인수 색인 ( &lt;code&gt;1&lt;/code&gt; - &lt;code&gt;ubyte.max&lt;/code&gt; ) . ( &lt;code&gt;0&lt;/code&gt; 수단이 사용되지 않음).</target>
        </trans-unit>
        <trans-unit id="235d469a267eec1b21cb41bd835ec761b3be5b4a" translate="yes" xml:space="preserve">
          <source>Index of the maximal element of a range. &lt;code&gt;maxElement([3, 4, 1, 2])&lt;/code&gt; returns &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">범위의 최대 요소의 인덱스입니다. &lt;code&gt;maxElement([3, 4, 1, 2])&lt;/code&gt; 는 &lt;code&gt;1&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="25975946b5389d6cd4927c54b6079d61210dbf05" translate="yes" xml:space="preserve">
          <source>Index of the minimal element of a range. &lt;code&gt;minElement([3, 4, 1, 2])&lt;/code&gt; returns &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="translated">범위의 최소 요소의 인덱스입니다. &lt;code&gt;minElement([3, 4, 1, 2])&lt;/code&gt; 는 &lt;code&gt;2&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="71356bb2f5e6c2c37298a92b0fcb4df5af1fdc19" translate="yes" xml:space="preserve">
          <source>Index value to set.</source>
          <target state="translated">설정할 인덱스 값입니다.</target>
        </trans-unit>
        <trans-unit id="a04ef38d2ddc39bb1db51cbf56276c8f962441c1" translate="yes" xml:space="preserve">
          <source>IndexExpression</source>
          <target state="translated">IndexExpression</target>
        </trans-unit>
        <trans-unit id="3b15c071f8f2a9b03d20f13f4ee4fa47f96aaf8d" translate="yes" xml:space="preserve">
          <source>Indexed!(Source, Indices) &lt;strong id=&quot;indexed&quot;&gt;indexed&lt;/strong&gt;(Source, Indices)(Source source, Indices indices);</source>
          <target state="translated">인덱스! (소스, 인덱스) &lt;strong id=&quot;indexed&quot;&gt;인덱스&lt;/strong&gt; (소스, 인덱스) (소스 소스, 인덱스 인덱스);</target>
        </trans-unit>
        <trans-unit id="9951861c21df18489a5872209655d6f9039b5e2a" translate="yes" xml:space="preserve">
          <source>Indexing</source>
          <target state="translated">Indexing</target>
        </trans-unit>
        <trans-unit id="76508adf7decca48f64672d4079c15326fbc39f8" translate="yes" xml:space="preserve">
          <source>Indexing and slicing operations. Provided only if &lt;code&gt;hasSlicing!Source&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">인덱싱 및 슬라이싱 작업. &lt;code&gt;hasSlicing!Source&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 인 경우에만 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="74036ccb3b85a0419f22323e1fac3915c3caf378" translate="yes" xml:space="preserve">
          <source>Indexing operators yielding or modifyng the value at the specified index.</source>
          <target state="translated">인덱싱 연산자는 지정된 인덱스에서 값을 생성하거나 수정합니다.</target>
        </trans-unit>
        <trans-unit id="6d2692938b71d76efadfb2cea1bb4a83352f988a" translate="yes" xml:space="preserve">
          <source>Indexing, slicing and bidirectional operations and range primitives. Provided only if &lt;code&gt;hasSlicing!Source&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">인덱싱, 슬라이싱 및 양방향 작업 및 범위 프리미티브 &lt;code&gt;hasSlicing!Source&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 인 경우에만 제공 .</target>
        </trans-unit>
        <trans-unit id="f85958353bf4bfb31d66cc4f95a9358b5bedf1c3" translate="yes" xml:space="preserve">
          <source>Indicates a direction in time. One example of its use is &lt;a href=&quot;#Interval&quot;&gt;&lt;code&gt;Interval&lt;/code&gt;&lt;/a&gt;'s &lt;a href=&quot;#expand&quot;&gt;&lt;code&gt;expand&lt;/code&gt;&lt;/a&gt; function which uses it to indicate whether the interval should be expanded backwards (into the past), forwards (into the future), or both.</source>
          <target state="translated">시간 방향을 나타냅니다. 그 사용의 한 예는 &lt;a href=&quot;#Interval&quot;&gt; &lt;code&gt;Interval&lt;/code&gt; &lt;/a&gt; 뒤로 (과거로), 앞으로 (앞으로) 또는 둘 다로 확장해야하는지 여부를 표시하는 데 사용하는 Interval 의 &lt;a href=&quot;#expand&quot;&gt; &lt;code&gt;expand&lt;/code&gt; &lt;/a&gt; 기능입니다.</target>
        </trans-unit>
        <trans-unit id="89b0fbd07a7b5dbf8da4ba701f1805d8565d86bb" translate="yes" xml:space="preserve">
          <source>Indicates if a nested aggregate prevents or not a function to be inlined. It's used to compute the cost but also to avoid a copy of the aggregate while the inliner processes.</source>
          <target state="translated">중첩 집계가 함수의 인라인을 방해하는지 여부를 나타냅니다. 비용을 계산하는 데 사용되지만 인라이너가 처리하는 동안 집계 사본을 피하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a10ebf2fd0a4ff0f019e4879f48fae2f4e5a0b0d" translate="yes" xml:space="preserve">
          <source>Indicates that the managed memory space be minimized by returning free physical memory to the operating system. The amount of free memory returned depends on the allocator design and on program behavior.</source>
          <target state="translated">사용 가능한 실제 메모리를 운영 체제로 리턴하여 관리 메모리 공간을 최소화 함을 나타냅니다. 반환되는 사용 가능한 메모리 양은 할당 자 디자인 및 프로그램 동작에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="4ec109e112fc6bfd6a9d0109f56e7e7967df8488" translate="yes" xml:space="preserve">
          <source>Indicates the checking state of various contracts.</source>
          <target state="translated">다양한 계약의 점검 상태를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="cb18c8046fd7efef0dda1d752fd5c6ff22b02f5d" translate="yes" xml:space="preserve">
          <source>Indicates the kind of scan being performed by &lt;code&gt;thread_scanAllType&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;thread_scanAllType&lt;/code&gt; 이 수행하는 스캔 종류를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="8f13413a46338bc9d77efe386dd1970d9c61578f" translate="yes" xml:space="preserve">
          <source>Indicates the type of a &lt;code&gt;JSONValue&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;JSONValue&lt;/code&gt; 의 유형을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="ee35c8aada8a6aa7b7217bd768effeae4d28769f" translate="yes" xml:space="preserve">
          <source>Indicates whether &lt;code&gt;T&lt;/code&gt; is a file handle, i.e. the type is implicitly convertable to &lt;a href=&quot;#File&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt; or a pointer to a &lt;a href=&quot;core_stdc_stdio#FILE&quot;&gt;&lt;code&gt;core.stdc.stdio.FILE&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 가 파일 핸들 인지 여부를 나타냅니다 . 즉, 형식이 암시 적으로 &lt;a href=&quot;#File&quot;&gt; &lt;code&gt;File&lt;/code&gt; 로 변환 가능&lt;/a&gt; 하거나 &lt;a href=&quot;core_stdc_stdio#FILE&quot;&gt; &lt;code&gt;core.stdc.stdio.FILE&lt;/code&gt; 에&lt;/a&gt; 대한 포인터 입니다.</target>
        </trans-unit>
        <trans-unit id="16f0af9200309c4bcede9c6bd76aa0d14467a310" translate="yes" xml:space="preserve">
          <source>Indicates whether an address has been marked by the GC.</source>
          <target state="translated">주소가 GC에 의해 표시되었는지 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c7fabc24fed84961bce8996fe0ecd1e5cdad5e83" translate="yes" xml:space="preserve">
          <source>Indicates whether the comparisons are case sensitive.</source>
          <target state="translated">비교가 대소 문자를 구분하는지 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f7d28431fd9c9c5871085a5497dc7e6e1e0cf415" translate="yes" xml:space="preserve">
          <source>Indicates which contracts should be checked or not.</source>
          <target state="translated">점검해야 할 계약을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="4243a1f947d3219fb4149e60971ece346868e5f0" translate="yes" xml:space="preserve">
          <source>Individual characters (&lt;code&gt;char, &lt;/code&gt;wchar&lt;code&gt;, or &lt;/code&gt;dchar`) are formatted as Unicode characters with &lt;code&gt;%s&lt;/code&gt; and as integers with integral-specific format specs.</source>
          <target state="translated">개별 문자 ( &lt;code&gt;char, &lt;/code&gt; wchar &lt;code&gt;, or &lt;/code&gt; dchar`)는 &lt;code&gt;%s&lt;/code&gt; 유니 코드 문자로 , 정수에 특정한 형식 스펙이있는 정수로 형식이 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="29597351771a3ef19075a67f20ee90c6ad63bea0" translate="yes" xml:space="preserve">
          <source>Individual characters are compared using &lt;code&gt;filenameCharCmp!cs&lt;/code&gt;, where &lt;code&gt;cs&lt;/code&gt; is an optional template parameter determining whether the comparison is case sensitive or not.</source>
          <target state="translated">&lt;code&gt;filenameCharCmp!cs&lt;/code&gt; 사용하여 개별 문자를 비교합니다 . 여기서 &lt;code&gt;cs&lt;/code&gt; 는 비교가 대소 문자를 구분하는지 여부를 결정하는 선택적 템플리트 매개 변수입니다.</target>
        </trans-unit>
        <trans-unit id="49226687980b9cd956057b7a38e24b4e2409b256" translate="yes" xml:space="preserve">
          <source>Individual characters are compared using &lt;code&gt;filenameCharCmp!cs&lt;/code&gt;, where &lt;code&gt;cs&lt;/code&gt; is an optional template parameter determining whether the comparison is case sensitive or not. See the &lt;a href=&quot;#filenameCharCmp&quot;&gt;&lt;code&gt;filenameCharCmp&lt;/code&gt;&lt;/a&gt; documentation for details.</source>
          <target state="translated">&lt;code&gt;filenameCharCmp!cs&lt;/code&gt; 사용하여 개별 문자를 비교합니다 . 여기서 &lt;code&gt;cs&lt;/code&gt; 는 비교가 대소 문자를 구분하는지 여부를 결정하는 선택적 템플리트 매개 변수입니다. 자세한 내용은 &lt;a href=&quot;#filenameCharCmp&quot;&gt; &lt;code&gt;filenameCharCmp&lt;/code&gt; &lt;/a&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e1f361f1f9ae5992659047882bc5221a903aebb0" translate="yes" xml:space="preserve">
          <source>Individual field in the Ctor with information about its callees and location.</source>
          <target state="translated">수신자 및 위치에 대한 정보가있는 Ctor의 개별 필드입니다.</target>
        </trans-unit>
        <trans-unit id="2112ae8639e7801d8cfbbdd81cd2583bb2a4a9cd" translate="yes" xml:space="preserve">
          <source>Individual tests are specified in the unit test using &lt;a href=&quot;expression#AssertExpression&quot;&gt;AssertExpressions&lt;/a&gt;. Unlike</source>
          <target state="translated">개별 테스트는 &lt;a href=&quot;expression#AssertExpression&quot;&gt;AssertExpressions를&lt;/a&gt; 사용하여 단위 테스트에서 지정됩니다 . 같지 않은</target>
        </trans-unit>
        <trans-unit id="a1c45f8b0cd8cbcf6f1e93b6a635fb2a38dc40f6" translate="yes" xml:space="preserve">
          <source>Inequality is defined as the logical negation of equality.</source>
          <target state="translated">불평등은 평등의 논리적 부정으로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="65b109f015e153776d80b153da2023fd8d163d9f" translate="yes" xml:space="preserve">
          <source>Infinite ranges are compatible, provided the parameter &lt;code&gt;upTo&lt;/code&gt; is specified, in which case the implementation simply returns upTo.</source>
          <target state="translated">&lt;code&gt;upTo&lt;/code&gt; 매개 변수 가 지정되면 무한 범위가 호환되며, 이 경우 구현은 단순히 upTo를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="cc80f798db63ecb0ec11198be5af2b60c15e0345" translate="yes" xml:space="preserve">
          <source>Infinite ranges with slicing support must return an instance of &lt;a href=&quot;std_range#Take&quot;&gt;&lt;code&gt;std.range.Take&lt;/code&gt;&lt;/a&gt; when sliced with a specific lower and upper bound (see &lt;a href=&quot;std_range_primitives#hasSlicing&quot;&gt;&lt;code&gt;std.range.primitives.hasSlicing&lt;/code&gt;&lt;/a&gt;); &lt;code&gt;handle&lt;/code&gt; deals with this by &lt;code&gt;take&lt;/code&gt;ing 0 from the return value of the handler function and returning that when an exception is caught.</source>
          <target state="translated">슬라이싱을 지원하는 무한 범위는 &lt;a href=&quot;std_range#Take&quot;&gt; &lt;code&gt;std.range.Take&lt;/code&gt; &lt;/a&gt; 의 인스턴스를 반환해야합니다 . 특정 하한 및 상한으로 슬라이스 할 때 &lt;a href=&quot;std_range_primitives#hasSlicing&quot;&gt; &lt;code&gt;std.range.primitives.hasSlicing&lt;/code&gt; &lt;/a&gt; ( std.range.primitives.hasSlicing 참조 ). &lt;code&gt;handle&lt;/code&gt; 하여이와 거래를 &lt;code&gt;take&lt;/code&gt; 핸들러 함수의 반환 값에서 0 보내고 예외가 잡힌 때 반환.</target>
        </trans-unit>
        <trans-unit id="27d9e5c1d05febee114a9f9e51dbec3780887c9a" translate="yes" xml:space="preserve">
          <source>Infiniteness of the wrapped range is not propagated.  Length is not propagated in the case of non-random access ranges.</source>
          <target state="translated">랩핑 된 범위의 무한대는 전파되지 않습니다. 비 랜덤 액세스 범위의 경우 길이가 전파되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="193bbd547918874dedb7a8a3d593f29b74828e01" translate="yes" xml:space="preserve">
          <source>Info on a file, similar to what you'd get from stat on a POSIX system.</source>
          <target state="translated">POSIX 시스템의 stat에서 얻은 것과 유사한 파일에 대한 정보.</target>
        </trans-unit>
        <trans-unit id="266086404e3edd52081be68722aa77ff6a65cf70" translate="yes" xml:space="preserve">
          <source>Info on a file, similar to what you'd get from stat on a Posix system.</source>
          <target state="translated">Posix 시스템의 통계에서 얻는 것과 유사한 파일 정보.</target>
        </trans-unit>
        <trans-unit id="cd1b541e2d202e9ed7863df5d539d80a14d92db1" translate="yes" xml:space="preserve">
          <source>Information about an interface. When an object is accessed via an interface, an Interface* appears as the first entry in its vtbl.</source>
          <target state="translated">인터페이스에 대한 정보. 인터페이스를 통해 객체에 액세스하면 Interface *가 vtbl의 첫 번째 항목으로 나타납니다.</target>
        </trans-unit>
        <trans-unit id="cea2e687310e3b71b249c28a49288e9fd3bfa210" translate="yes" xml:space="preserve">
          <source>Information about an option.</source>
          <target state="translated">옵션에 대한 정보.</target>
        </trans-unit>
        <trans-unit id="e073c50eee2c368b573895c98fb35595e9133239" translate="yes" xml:space="preserve">
          <source>Information about errors should be logged with this level.</source>
          <target state="translated">오류에 대한 정보는이 수준으로 기록해야합니다.</target>
        </trans-unit>
        <trans-unit id="928345681d20aa3d2b01bea36a816d52c33a48de" translate="yes" xml:space="preserve">
          <source>Information about the dynamic type of the class</source>
          <target state="translated">클래스의 동적 유형에 대한 정보</target>
        </trans-unit>
        <trans-unit id="dc5ebb2696c4fafd1bdd1b19b9d403757258f4ad" translate="yes" xml:space="preserve">
          <source>Information about the error.</source>
          <target state="translated">오류에 대한 정보.</target>
        </trans-unit>
        <trans-unit id="b7329bd16608fcee8af0c9e3dcd5b29f7f17343f" translate="yes" xml:space="preserve">
          <source>Information about the target operating system, environment, and CPU.</source>
          <target state="translated">대상 운영 체제, 환경 및 CPU에 대한 정보</target>
        </trans-unit>
        <trans-unit id="ceccba3653730142ed262183682108d6a4b114f3" translate="yes" xml:space="preserve">
          <source>Information gathered about externally defined template member functions, member data, and member classes.</source>
          <target state="translated">외부 적으로 정의 된 템플릿 멤버 함수, 멤버 데이터 및 멤버 클래스에 대한 정보가 수집되었습니다.</target>
        </trans-unit>
        <trans-unit id="908b94b8c3e2309d82de3bc12b0083b2f0550dd4" translate="yes" xml:space="preserve">
          <source>Information gathered about nested class friends.</source>
          <target state="translated">중첩 된 클래스 친구에 대한 정보가 수집되었습니다.</target>
        </trans-unit>
        <trans-unit id="7a43d043ba9567583c6e384e6e0ac879da254eab" translate="yes" xml:space="preserve">
          <source>Information gathered about nested explicit specializations.</source>
          <target state="translated">중첩 된 명시 적 전문화에 대한 정보가 수집되었습니다.</target>
        </trans-unit>
        <trans-unit id="464dcc7e55ca0baa3461154f3221489d53fa204b" translate="yes" xml:space="preserve">
          <source>Information gathered about primary member template explicit specialization.</source>
          <target state="translated">기본 멤버 템플릿 명시 적 전문화에 대한 정보가 수집되었습니다.</target>
        </trans-unit>
        <trans-unit id="8bc70f913f6ebe36fcb59b26b1c9b07d1f380466" translate="yes" xml:space="preserve">
          <source>Information regarding the allocated memory block or BlkInfo.init on error.</source>
          <target state="translated">할당 된 메모리 블록 또는 오류시 BlkInfo.init에 관한 정보.</target>
        </trans-unit>
        <trans-unit id="1675fcfc1cf455d10d63328190309be0fe262d03" translate="yes" xml:space="preserve">
          <source>Information regarding the memory block referenced by p or BlkInfo.init on error.</source>
          <target state="translated">오류시 p 또는 BlkInfo.init가 참조하는 메모리 블록에 관한 정보.</target>
        </trans-unit>
        <trans-unit id="58823af05ebe1ba3ff034e5ec492dcbd5b2f86cc" translate="yes" xml:space="preserve">
          <source>Inherited</source>
          <target state="translated">Inherited</target>
        </trans-unit>
        <trans-unit id="fcb1ddc45496d5bd9bbb1d0e3e24a58c56f33281" translate="yes" xml:space="preserve">
          <source>Initial value</source>
          <target state="translated">초기 값</target>
        </trans-unit>
        <trans-unit id="97e0f0f5459c7f9a8a0eadb6d21739e1c19dd524" translate="yes" xml:space="preserve">
          <source>Initial_Punctuation</source>
          <target state="translated">Initial_Punctuation</target>
        </trans-unit>
        <trans-unit id="e3e40f7638a489f11f1de06365e82209954d82d0" translate="yes" xml:space="preserve">
          <source>Initialization hook, called FROM each thread. No assumptions about module initialization state should be made.</source>
          <target state="translated">각 스레드에서 FROM이라고하는 초기화 후크. 모듈 초기화 상태에 대한 가정은 없어야합니다.</target>
        </trans-unit>
        <trans-unit id="a459dff3012da591453989e5860a6fd825f63ce3" translate="yes" xml:space="preserve">
          <source>Initialize</source>
          <target state="translated">Initialize</target>
        </trans-unit>
        <trans-unit id="7bf3e06594405eb1afbafdd083622d687011597a" translate="yes" xml:space="preserve">
          <source>Initialize The SQLite Library</source>
          <target state="translated">SQLite 라이브러리 초기화</target>
        </trans-unit>
        <trans-unit id="748256c78e345ebbc504f121b03e80be2a80bbca" translate="yes" xml:space="preserve">
          <source>Initialize a TOK.cantExpression Expression.</source>
          <target state="translated">TOK.cantExpression 표현식을 초기화하십시오.</target>
        </trans-unit>
        <trans-unit id="e6d6bffc11d0689a05cff44169b6e949eafbef76" translate="yes" xml:space="preserve">
          <source>Initialize ap. parmn should be the last named parameter.</source>
          <target state="translated">ap를 초기화합니다. parmn은 마지막으로 명명 된 매개 변수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="27911a1150c0c1d2144b25e270682254f6dac63a" translate="yes" xml:space="preserve">
          <source>Initialize config variables.</source>
          <target state="translated">구성 변수를 초기화하십시오.</target>
        </trans-unit>
        <trans-unit id="cbe2f6d3df93f8e15ce05f5a1f98cda2b20db74a" translate="yes" xml:space="preserve">
          <source>Initialize druntime. If a C program wishes to call D code, and there's no D main(), then it must call rt_init() and rt_term().</source>
          <target state="translated">druntime을 초기화하십시오. C 프로그램이 D 코드를 호출하려고하고 D main ()이 없으면 rt_init () 및 rt_term ()을 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="8eb8be79e89fc0c011f24c39ee8771af00f563f7" translate="yes" xml:space="preserve">
          <source>Initialize for inferring the attributes of this function.</source>
          <target state="translated">이 함수의 속성을 유추하기 위해 초기화하십시오.</target>
        </trans-unit>
        <trans-unit id="f721b948f9c83247c02645e5eb12893bfb899d86" translate="yes" xml:space="preserve">
          <source>Initialize list package.</source>
          <target state="translated">목록 패키지를 초기화하십시오.</target>
        </trans-unit>
        <trans-unit id="de4ea7df574920c39fb3c6bd0386ce6a9cd8fd5d" translate="yes" xml:space="preserve">
          <source>Initialize the Objective-C string using a C string.</source>
          <target state="translated">C 문자열을 사용하여 Objective-C 문자열을 초기화하십시오.</target>
        </trans-unit>
        <trans-unit id="ef4109d3528796628f6b2a0029715405248a578e" translate="yes" xml:space="preserve">
          <source>Initialize the Target</source>
          <target state="translated">대상 초기화</target>
        </trans-unit>
        <trans-unit id="0980ce942938201d58c731edfd7b47e45dd9efe7" translate="yes" xml:space="preserve">
          <source>Initialize the dual-context array with the context pointers.</source>
          <target state="translated">컨텍스트 포인터를 사용하여 이중 컨텍스트 배열을 초기화하십시오.</target>
        </trans-unit>
        <trans-unit id="8e023ffe90e1164684f46dc5edc97859a5680a5f" translate="yes" xml:space="preserve">
          <source>Initialize the hidden aggregate member, vthis, with the context pointer.</source>
          <target state="translated">컨텍스트 포인터를 사용하여 숨겨진 집계 멤버 vthis를 초기화하십시오.</target>
        </trans-unit>
        <trans-unit id="59c6a3b95f9730ad20a9c9db67ee73fd2a6949c4" translate="yes" xml:space="preserve">
          <source>Initialize the instance by creating a working curl handle.</source>
          <target state="translated">작업 컬 핸들을 만들어 인스턴스를 초기화하십시오.</target>
        </trans-unit>
        <trans-unit id="1a30f56d1770a9dcc7fd0bb681a1c06b14ad9d91" translate="yes" xml:space="preserve">
          <source>Initialize the memory allocator</source>
          <target state="translated">메모리 할당 기 초기화</target>
        </trans-unit>
        <trans-unit id="494a02556f310d47be7c5338d8f5523416a42a2e" translate="yes" xml:space="preserve">
          <source>Initialize with a message and an error code.</source>
          <target state="translated">메시지와 오류 코드로 초기화하십시오.</target>
        </trans-unit>
        <trans-unit id="0c55ba13e2bd9dbfd35641ebe93792c6061e39cd" translate="yes" xml:space="preserve">
          <source>Initializer</source>
          <target state="translated">Initializer</target>
        </trans-unit>
        <trans-unit id="51bf015ae2898049c8dda3ee0d3b48d0b0503aac" translate="yes" xml:space="preserve">
          <source>Initializer &lt;code&gt;init&lt;/code&gt;</source>
          <target state="translated">이니셜 라이저 &lt;code&gt;init&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2b1d1b30aa70eb127392afc002aaf56ef13eddf1" translate="yes" xml:space="preserve">
          <source>Initializer &lt;code&gt;inx&lt;/code&gt;</source>
          <target state="translated">이니셜 라이저 &lt;code&gt;inx&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="376a8ae3746f3bef7e7c198b9b11401e24b7d25c" translate="yes" xml:space="preserve">
          <source>Initializer &lt;strong id=&quot;inferType&quot;&gt;inferType&lt;/strong&gt;(Initializer init, Scope* sc);</source>
          <target state="translated">이니셜 &lt;strong id=&quot;inferType&quot;&gt;라이저 유인형&lt;/strong&gt; (Initializer init, Scope * sc);</target>
        </trans-unit>
        <trans-unit id="d8d2abfa30e5c4556b8e2c9d2dc62e742af966eb" translate="yes" xml:space="preserve">
          <source>Initializer &lt;strong id=&quot;initializerSemantic&quot;&gt;initializerSemantic&lt;/strong&gt;(Initializer init, Scope* sc, Type t, NeedInterpret needInterpret);</source>
          <target state="translated">이니셜 &lt;strong id=&quot;initializerSemantic&quot;&gt;라이저 이니셜 라이저&lt;/strong&gt; 시맨틱 (Initializer init, Scope * sc, Type t, NeedInterpret needInterpret);</target>
        </trans-unit>
        <trans-unit id="88abdada1a9385d97517a707f4ab8a5f5a3e696d" translate="yes" xml:space="preserve">
          <source>Initializer &lt;strong id=&quot;syntaxCopy&quot;&gt;syntaxCopy&lt;/strong&gt;(Initializer inx);</source>
          <target state="translated">이니셜 &lt;strong id=&quot;syntaxCopy&quot;&gt;라이저 구문 복사&lt;/strong&gt; ( Initializer &lt;strong id=&quot;syntaxCopy&quot;&gt;inx&lt;/strong&gt; );</target>
        </trans-unit>
        <trans-unit id="c33131a57d387e740aae854652440535c3dd0652" translate="yes" xml:space="preserve">
          <source>Initializer AST node</source>
          <target state="translated">이니셜 라이저 AST 노드</target>
        </trans-unit>
        <trans-unit id="14b021ae9bb3f976f77030248590d743674ec1b8" translate="yes" xml:space="preserve">
          <source>Initializer AST to copy</source>
          <target state="translated">복사 할 이니셜 라이저 AST</target>
        </trans-unit>
        <trans-unit id="3121cafc28fbd2cff06107236c3142ae39ff3c9a" translate="yes" xml:space="preserve">
          <source>Initializes a &lt;code&gt;RefCounted&lt;/code&gt; with &lt;code&gt;val&lt;/code&gt;. The template parameter &lt;code&gt;T&lt;/code&gt; of &lt;code&gt;RefCounted&lt;/code&gt; is inferred from &lt;code&gt;val&lt;/code&gt;. This function can be used to move non-copyable values to the heap. It also disables the &lt;code&gt;autoInit&lt;/code&gt; option of &lt;code&gt;RefCounted&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;val&lt;/code&gt; 로 &lt;code&gt;RefCounted&lt;/code&gt; 를 초기화합니다 . &lt;code&gt;RefCounted&lt;/code&gt; 의 템플릿 매개 변수 &lt;code&gt;T&lt;/code&gt; 는 &lt;code&gt;val&lt;/code&gt; 에서 유추됩니다 . 이 기능은 복사 할 수없는 값을 힙으로 이동하는 데 사용할 수 있습니다. 또한 비활성화 &lt;code&gt;autoInit&lt;/code&gt; 의 의 옵션 &lt;code&gt;RefCounted&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="5840e1604b436855e9916e7392a48763951eabf0" translate="yes" xml:space="preserve">
          <source>Initializes a barrier object which releases threads in groups of limit in size.</source>
          <target state="translated">크기 제한 그룹에서 스레드를 해제하는 배리어 객체를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="e7d8f005a4914e6f92d821d5b224a6bd9e5c292c" translate="yes" xml:space="preserve">
          <source>Initializes a condition object which is associated with the supplied mutex object.</source>
          <target state="translated">제공된 뮤텍스 개체와 관련된 조건 개체를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="2e831c2f248c0c0989af9f49fabed81c26839fd7" translate="yes" xml:space="preserve">
          <source>Initializes a fiber object which is associated with a dynamic D function.</source>
          <target state="translated">동적 D 기능과 관련된 광섬유 객체를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="af50363b8f7b4155835b77141de6a5c61fdd71a0" translate="yes" xml:space="preserve">
          <source>Initializes a fiber object which is associated with a static D function.</source>
          <target state="translated">정적 D 함수와 관련된 광섬유 객체를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="45f928a2b81b560a0de6c9239785399cedf0251c" translate="yes" xml:space="preserve">
          <source>Initializes a generator object which is associated with a dynamic D function. The function will be called once to prepare the range for iteration.</source>
          <target state="translated">동적 D 함수와 관련된 생성기 객체를 초기화합니다. 반복 범위를 준비하기 위해 함수가 한 번 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="d0a92e3c77360cd0a21c46127be86aca1b90b608" translate="yes" xml:space="preserve">
          <source>Initializes a generator object which is associated with a static D function. The function will be called once to prepare the range for iteration.</source>
          <target state="translated">정적 D 함수와 관련된 생성기 객체를 초기화합니다. 반복 범위를 준비하기 위해 함수가 한 번 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="d3728c381d3549c70b43d294cf94f34b914968b0" translate="yes" xml:space="preserve">
          <source>Initializes a mutex object and sets it as the monitor for &lt;code&gt;obj&lt;/code&gt;.</source>
          <target state="translated">에 대한 모니터와 같은 뮤텍스 개체 및 설정을 초기화 &lt;code&gt;obj&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3a70c8975cc02255930db5c1532e070f13d983d9" translate="yes" xml:space="preserve">
          <source>Initializes a mutex object.</source>
          <target state="translated">뮤텍스 개체를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="dc21cd96d7c298b730677d5fadf1f39d6fcdc2a3" translate="yes" xml:space="preserve">
          <source>Initializes a read/write mutex object with the supplied policy.</source>
          <target state="translated">제공된 정책으로 읽기 / 쓰기 뮤텍스 개체를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="1bf7bde2d0e1b4605f5fcc7cecf50b8041c0ee33" translate="yes" xml:space="preserve">
          <source>Initializes a read/write mutex reader proxy object.</source>
          <target state="translated">읽기 / 쓰기 뮤텍스 리더 프록시 객체를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="cac251d6ab6ce4228fd76b8f664aca1fdce466aa" translate="yes" xml:space="preserve">
          <source>Initializes a read/write mutex writer proxy object.</source>
          <target state="translated">읽기 / 쓰기 뮤텍스 라이터 프록시 객체를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="e9c3d0e482ee4665047c01099490677dcee2bdf1" translate="yes" xml:space="preserve">
          <source>Initializes a semaphore object with the specified initial count.</source>
          <target state="translated">지정된 초기 카운트로 세마포어 객체를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="b08f976531720c8d331b9fd2fe472f259a01f7f8" translate="yes" xml:space="preserve">
          <source>Initializes a thread object which is associated with a dynamic D function.</source>
          <target state="translated">동적 D 함수와 관련된 스레드 객체를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="6feddfb754d931f52971603d63763097e08f646e" translate="yes" xml:space="preserve">
          <source>Initializes a thread object which is associated with a static D function.</source>
          <target state="translated">정적 D 함수와 관련된 스레드 개체를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="02e85d0a8c0d02c068e1d5736a1954b12b36920b" translate="yes" xml:space="preserve">
          <source>Initializes all elements of &lt;code&gt;range&lt;/code&gt; with their &lt;code&gt;.init&lt;/code&gt; value. Assumes that the elements of the range are uninitialized.</source>
          <target state="translated">의 모든 요소를 초기화 &lt;code&gt;range&lt;/code&gt; 자신과 &lt;code&gt;.init&lt;/code&gt; 의 값입니다. 범위의 요소가 초기화되지 않은 것으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="472c952e25298d18516b57e8e37279e00d61a5fe" translate="yes" xml:space="preserve">
          <source>Initializes an event object. Does nothing if the event is already initialized.</source>
          <target state="translated">이벤트 객체를 초기화합니다. 이벤트가 이미 초기화 된 경우 아무 작업도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="eaf4287ba6b011331efecfcdf502db022ed8e9d5" translate="yes" xml:space="preserve">
          <source>Initializes each element of &lt;code&gt;range&lt;/code&gt; with &lt;code&gt;value&lt;/code&gt;. Assumes that the elements of the range are uninitialized. This is of interest for structs that define copy constructors (for all other types, &lt;a href=&quot;#fill&quot;&gt;&lt;code&gt;fill&lt;/code&gt;&lt;/a&gt; and uninitializedFill are equivalent).</source>
          <target state="translated">&lt;code&gt;range&lt;/code&gt; 의 각 요소 를 &lt;code&gt;value&lt;/code&gt; 로 초기화합니다 . 범위의 요소가 초기화되지 않은 것으로 가정합니다. 이것은 복사 생성자를 정의하는 구조체에 중요합니다 (다른 모든 유형의 경우 &lt;a href=&quot;#fill&quot;&gt; &lt;code&gt;fill&lt;/code&gt; &lt;/a&gt; 및 uninitializedFill은 동일 함).</target>
        </trans-unit>
        <trans-unit id="fc7f0006265d50c993eca80b0dee1e88b813e83a" translate="yes" xml:space="preserve">
          <source>Initializes the Symbol s with the contents of the exception handler table.</source>
          <target state="translated">예외 처리기 테이블의 내용으로 Symbol을 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="ce7db86ae90730cf95765268d14c3efeca306d1a" translate="yes" xml:space="preserve">
          <source>Initializes the digest.</source>
          <target state="translated">다이제스트를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="7cc4cbbc423778a9b3a1d152d6911455078c9956" translate="yes" xml:space="preserve">
          <source>Initializes the runtime. This call is to be used in instances where the standard program initialization process is not executed. This is most often in shared libraries or in libraries linked to a C program. If the runtime was already successfully initialized this returns true. Each call to initialize must be paired by a call to &lt;a href=&quot;#terminate&quot;&gt;&lt;code&gt;terminate&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">런타임을 초기화합니다. 이 호출은 표준 프로그램 초기화 프로세스가 실행되지 않는 경우에 사용됩니다. 이것은 대부분 공유 라이브러리 또는 C 프로그램에 연결된 라이브러리에 있습니다. 런타임이 이미 초기화 된 경우 true를 리턴합니다. 초기화 할 각 호출은 &lt;a href=&quot;#terminate&quot;&gt; &lt;code&gt;terminate&lt;/code&gt; &lt;/a&gt; 호출과 쌍을 이루어야합니다 .</target>
        </trans-unit>
        <trans-unit id="fd011618a7d780c02099be5bb857d574a889ced4" translate="yes" xml:space="preserve">
          <source>Initializes the thread module. This function must be called by the garbage collector on startup and before any other thread routines are called.</source>
          <target state="translated">스레드 모듈을 초기화합니다. 이 함수는 시작시 및 다른 스레드 루틴을 호출하기 전에 가비지 콜렉터가 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="f7bf172cc09f5d408e5dbadd459ffc810fa40735" translate="yes" xml:space="preserve">
          <source>Initializes this object.</source>
          <target state="translated">이 객체를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="330d0782e4b98319bc9e2fabb58b097370cccd48" translate="yes" xml:space="preserve">
          <source>Initializes var with the lazy init value in a thread-safe manner.</source>
          <target state="translated">스레드 안전 방식으로 lazy init 값으로 var을 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="357baf1e97067fcd6c5956ff04a8aafd59f2e20c" translate="yes" xml:space="preserve">
          <source>Initializing a field more than once is an error:</source>
          <target state="translated">필드를 두 번 이상 초기화하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7b6a85ba00f40263892051680251fc88efc22b1f" translate="yes" xml:space="preserve">
          <source>Initially, &lt;code&gt;KRRegion&lt;/code&gt; starts in &quot;region&quot; mode: allocations are served from the memory chunk in a region fashion. Thus, as long as there is enough memory left, &lt;code&gt;KRRegion.allocate&lt;/code&gt; has the performance profile of a region allocator. Deallocation inserts (in &amp;Omicron;(&lt;code&gt;1&lt;/code&gt;) time) the deallocated blocks in an unstructured freelist, which is not read in region mode.</source>
          <target state="translated">&lt;code&gt;KRRegion&lt;/code&gt; 은 처음 에 &quot;지역&quot;모드에서 시작합니다. 할당은 지역 방식으로 메모리 청크에서 제공됩니다. 따라서 충분한 메모리가 남아있는 한 &lt;code&gt;KRRegion.allocate&lt;/code&gt; 는 region 할당 자의 성능 프로파일을 갖습니다. 할당 해제 는 할당 해제 된 블록을 구조화되지 않은 프리리스트에 삽입하고 (0 ( &lt;code&gt;1&lt;/code&gt; ) 시간) 지역 모드에서 읽지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6bcf5b308aa4ed1bdc1fe48856a7ba75e0842648" translate="yes" xml:space="preserve">
          <source>Initiate a search for all non-overlapping matches to the pattern &lt;code&gt;re&lt;/code&gt; in the given &lt;code&gt;input&lt;/code&gt;. The result is a lazy range of matches generated as they are encountered in the input going left to right.</source>
          <target state="translated">주어진 &lt;code&gt;input&lt;/code&gt; 에서 &lt;code&gt;re&lt;/code&gt; 패턴과 일치하지 않는 모든 일치 항목에 대한 검색을 시작합니다 . 결과는 왼쪽에서 오른쪽으로 진행되는 입력에서 발생할 때 발생하는 게으른 범위의 일치입니다.</target>
        </trans-unit>
        <trans-unit id="39a92c1c48ec637efb7a0a17e58b57967f5754ea" translate="yes" xml:space="preserve">
          <source>Initiate the shutdown</source>
          <target state="translated">종료 시작</target>
        </trans-unit>
        <trans-unit id="505f260038380736b5ec292da3beb645bc7a02ab" translate="yes" xml:space="preserve">
          <source>Inline Assembler</source>
          <target state="translated">인라인 어셈블러</target>
        </trans-unit>
        <trans-unit id="e8c0903b87db76a205d27b465bff8acf36d3a3fc" translate="yes" xml:space="preserve">
          <source>Inline Code</source>
          <target state="translated">인라인 코드</target>
        </trans-unit>
        <trans-unit id="b60019f47df04ae92897fa912c6748a6013313fa" translate="yes" xml:space="preserve">
          <source>Inline Functions</source>
          <target state="translated">인라인 함수</target>
        </trans-unit>
        <trans-unit id="0e581275df3e295be9dbef35d1d241b50ed09352" translate="yes" xml:space="preserve">
          <source>Inline Links</source>
          <target state="translated">인라인 링크</target>
        </trans-unit>
        <trans-unit id="e928c83ba27af9a3e30934913f4f5025c9156467" translate="yes" xml:space="preserve">
          <source>Inline Status</source>
          <target state="translated">인라인 상태</target>
        </trans-unit>
        <trans-unit id="2a9bcb6f0852ea225d7f231f321da701f1352c4f" translate="yes" xml:space="preserve">
          <source>Inline assembler can be used to access hardware directly:</source>
          <target state="translated">인라인 어셈블러를 사용하여 하드웨어에 직접 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="79759f20677d34f63a3ad16ca748c0357029c9ef" translate="yes" xml:space="preserve">
          <source>Inline assembler implementation for DMD.</source>
          <target state="translated">DMD에 대한 인라인 어셈블러 구현</target>
        </trans-unit>
        <trans-unit id="8bb9331db9f6ba0e169e23c73a72b91ef379fcfb" translate="yes" xml:space="preserve">
          <source>Inline assembler is supported with the asm statement:</source>
          <target state="translated">인라인 어셈블러는 asm 문에서 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="30bd67072a99e7f0e67136dac69a9f97d8fe06e6" translate="yes" xml:space="preserve">
          <source>Inline code can be written between backtick characters (`), similarly to the syntax used on GitHub, Reddit, Stack Overflow, and other websites. Both the opening and closing ` character must appear on the same line to trigger this behavior.</source>
          <target state="translated">GitHub, Reddit, Stack Overflow 및 기타 웹 사이트에서 사용되는 구문과 유사하게 백틱 문자 (`) 사이에 인라인 코드를 작성할 수 있습니다. 이 동작을 시작하려면 시작 및 끝`문자가 모두 같은 줄에 나타나야합니다.</target>
        </trans-unit>
        <trans-unit id="3a0d3f2169904e16efc469dbb314be7e91a83d62" translate="yes" xml:space="preserve">
          <source>Inline-style links enclose link text in square brackets and the link URL in parentheses. Like reference links, the URL may optionally be followed by title text wrapped in single or double quotes, or in parentheses:</source>
          <target state="translated">인라인 스타일 링크는 링크 텍스트를 대괄호로 묶고 링크 URL은 괄호로 묶습니다. 참조 링크와 마찬가지로 URL 뒤에 선택적으로 작은 따옴표 나 큰 따옴표 또는 괄호로 묶인 제목 텍스트가 올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="59987901b798d3774e680b1f2e942cf43901da46" translate="yes" xml:space="preserve">
          <source>InlineAsmStatement &lt;code&gt;s&lt;/code&gt;</source>
          <target state="translated">InlineAsmStatement &lt;code&gt;s&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="78d80e54409073effd7ab616e62a68493fee350d" translate="yes" xml:space="preserve">
          <source>Inout Functions</source>
          <target state="translated">인아웃 기능</target>
        </trans-unit>
        <trans-unit id="e8e7165f5b963e02cdaf54a8eb17befc2421e96a" translate="yes" xml:space="preserve">
          <source>Inout types can be implicitly converted to const or inout const, but to nothing else. Other types cannot be implicitly converted to inout. Casting to or from inout is not allowed in @safe functions.</source>
          <target state="translated">입력 유형은 암시 적으로 const 또는 inout const로 변환 할 수 있지만 다른 것은 없습니다. 다른 유형은 암시 적으로 inout으로 변환 할 수 없습니다. @safe 함수에서는 inout으로 캐스팅하거나 inout에서 캐스팅 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b568d47f2e244743b1fd7472db836ef9769c21f8" translate="yes" xml:space="preserve">
          <source>Input</source>
          <target state="translated">Input</target>
        </trans-unit>
        <trans-unit id="16ca749420dd58126c1f3f4ccf95ce2fc49387c9" translate="yes" xml:space="preserve">
          <source>Input array.</source>
          <target state="translated">입력 배열.</target>
        </trans-unit>
        <trans-unit id="805a8fb36fe255b6fb65ad6afc87bb5c87d77739" translate="yes" xml:space="preserve">
          <source>Input range primitives.</source>
          <target state="translated">입력 범위 프리미티브.</target>
        </trans-unit>
        <trans-unit id="2b5a3aca97f7c0ee924c45da0b642efd3933bcec" translate="yes" xml:space="preserve">
          <source>Input range primitives. Always present.</source>
          <target state="translated">입력 범위 프리미티브. 항상 존재합니다.</target>
        </trans-unit>
        <trans-unit id="3ea0015c09b13077d49706cf98824e19781f5a6d" translate="yes" xml:space="preserve">
          <source>InputRange &lt;code&gt;front&lt;/code&gt;</source>
          <target state="translated">입력 범위 &lt;code&gt;front&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ea0417fdf24ea467e5d4948e4d2f763b6a7eef2b" translate="yes" xml:space="preserve">
          <source>InputRange &lt;code&gt;haystack&lt;/code&gt;</source>
          <target state="translated">InputRange &lt;code&gt;haystack&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="263a897da5a7d45d98fac35624cdf4deb7cf4411" translate="yes" xml:space="preserve">
          <source>InputRange &lt;code&gt;input&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;input&lt;/code&gt; 범위 입력</target>
        </trans-unit>
        <trans-unit id="c8a5a20feb07807120b419370d56d0cc41af44e6" translate="yes" xml:space="preserve">
          <source>InputRange &lt;code&gt;seq&lt;/code&gt;</source>
          <target state="translated">InputRange &lt;code&gt;seq&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="76ac91ede8a06926e9fd7701df246ece786ebf98" translate="yes" xml:space="preserve">
          <source>InputRange &lt;strong id=&quot;find&quot;&gt;find&lt;/strong&gt;(alias pred = &quot;a == b&quot;, InputRange, Element)(InputRange haystack, scope Element needle)</source>
          <target state="translated">InputRange &lt;strong id=&quot;find&quot;&gt;find&lt;/strong&gt; (별칭 pred = &quot;a == b&quot;, InputRange, Element) (InputRange 건초 더미, 스코프 요소 바늘)</target>
        </trans-unit>
        <trans-unit id="62294650ad3440bbcc9dfa642f50ca9b106dfc41" translate="yes" xml:space="preserve">
          <source>InputRange &lt;strong id=&quot;find&quot;&gt;find&lt;/strong&gt;(alias pred, InputRange)(InputRange haystack)</source>
          <target state="translated">InputRange &lt;strong id=&quot;find&quot;&gt;find&lt;/strong&gt; (별칭 pred, InputRange) (InputRange haystack)</target>
        </trans-unit>
        <trans-unit id="cd55b74bf8e8c901c82e7777b6c9deb713ab8571" translate="yes" xml:space="preserve">
          <source>InputRange &lt;strong id=&quot;findAmong&quot;&gt;findAmong&lt;/strong&gt;(alias pred = &quot;a == b&quot;, InputRange, ForwardRange)(InputRange seq, ForwardRange choices)</source>
          <target state="translated">InputRange &lt;strong id=&quot;findAmong&quot;&gt;findAmong&lt;/strong&gt; (별칭 : &lt;strong id=&quot;findAmong&quot;&gt;prea&lt;/strong&gt; = &quot;a == b&quot;, InputRange, ForwardRange) (InputRange seq, ForwardRange 선택)</target>
        </trans-unit>
        <trans-unit id="215e5e329de1e54df130b5fa8c6b834e564f901b" translate="yes" xml:space="preserve">
          <source>InputRange1 &lt;code&gt;r1&lt;/code&gt;</source>
          <target state="translated">입력 범위 1 &lt;code&gt;r1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="249ee449e0f4478b44dc1191e22438bd70e851a5" translate="yes" xml:space="preserve">
          <source>InputRange1 &lt;code&gt;src&lt;/code&gt;</source>
          <target state="translated">입력 범위 1 &lt;code&gt;src&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c677621d3536f932357d78e1812f103084e329df" translate="yes" xml:space="preserve">
          <source>InputRange2 &lt;code&gt;r2&lt;/code&gt;</source>
          <target state="translated">입력 범위 2 &lt;code&gt;r2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="71bdacf44f1217f068320302c2f0ee3826890d58" translate="yes" xml:space="preserve">
          <source>InputRange2 &lt;code&gt;tgt&lt;/code&gt;</source>
          <target state="translated">InputRange2 &lt;code&gt;tgt&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="26853b5826e342866783ec6125630078fcc1a0ef" translate="yes" xml:space="preserve">
          <source>InputRange2 &lt;strong id=&quot;moveAll&quot;&gt;moveAll&lt;/strong&gt;(InputRange1, InputRange2)(InputRange1 src, InputRange2 tgt)</source>
          <target state="translated">InputRange2 &lt;strong id=&quot;moveAll&quot;&gt;moveAll&lt;/strong&gt; (InputRange1, InputRange2) (InputRange1 src, InputRange2 tgt)</target>
        </trans-unit>
        <trans-unit id="a6d9a6e40c7583de17b5334cea373d1a6f012a01" translate="yes" xml:space="preserve">
          <source>InputRangeObject!R &lt;strong id=&quot;inputRangeObject&quot;&gt;inputRangeObject&lt;/strong&gt;(R)(R range)</source>
          <target state="translated">InputRangeObject! R &lt;strong id=&quot;inputRangeObject&quot;&gt;inputRangeObject&lt;/strong&gt; (R) (R 범위)</target>
        </trans-unit>
        <trans-unit id="54690a68ec01cec2015c43085af22e3b7ee1fd11" translate="yes" xml:space="preserve">
          <source>Inscriptional Pahlavi</source>
          <target state="translated">비문 팔라 비</target>
        </trans-unit>
        <trans-unit id="fef5264f6a30e6dcae96d08ee848ad4b86a2a3a3" translate="yes" xml:space="preserve">
          <source>Inscriptional Parthian</source>
          <target state="translated">비문 파르티아 어</target>
        </trans-unit>
        <trans-unit id="7e7e7b17b20df161139e8ef284689d406182e357" translate="yes" xml:space="preserve">
          <source>Inscriptional_Pahlavi</source>
          <target state="translated">Inscriptional_Pahlavi</target>
        </trans-unit>
        <trans-unit id="c38bdc08ad33b7372f9f91847cd5f574862ccea5" translate="yes" xml:space="preserve">
          <source>Inscriptional_Parthian</source>
          <target state="translated">Inscriptional_Parthian</target>
        </trans-unit>
        <trans-unit id="3c215b42cade3b7a8b98554cb505256252393b54" translate="yes" xml:space="preserve">
          <source>Insert a backtick</source>
          <target state="translated">백틱 삽입</target>
        </trans-unit>
        <trans-unit id="138a4c6393efa857920b23a60fdca2a6694f91d0" translate="yes" xml:space="preserve">
          <source>Insert a dollar sign</source>
          <target state="translated">달러 기호 삽입</target>
        </trans-unit>
        <trans-unit id="cecb3ad08db064401b3027bd8bdfecfd625474f6" translate="yes" xml:space="preserve">
          <source>Insert a left parenthesis</source>
          <target state="translated">왼쪽 괄호 삽입</target>
        </trans-unit>
        <trans-unit id="cbdb76fffabdf5eb3b5ae5b2ff4c5c2a9ba7b666" translate="yes" xml:space="preserve">
          <source>Insert a line feed (newline)</source>
          <target state="translated">줄 바꿈 삽입 (줄 바꿈)</target>
        </trans-unit>
        <trans-unit id="c0306b572d5a694e3a6dd42bca0200f018f85238" translate="yes" xml:space="preserve">
          <source>Insert a range of elements in the container. Note that this does not invalidate any ranges currently iterating the container.</source>
          <target state="translated">컨테이너에 다양한 요소를 삽입하십시오. 현재 컨테이너를 반복하는 범위는 무효화되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1a917cf9fad45f42c5f9d737b6e96f9575d41832" translate="yes" xml:space="preserve">
          <source>Insert a right parenthesis</source>
          <target state="translated">오른쪽 괄호 삽입</target>
        </trans-unit>
        <trans-unit id="327083c1ff82497e1f646caa621a2ae2d82389b4" translate="yes" xml:space="preserve">
          <source>Insert a single element in the container. Note that this does not invalidate any ranges currently iterating the container.</source>
          <target state="translated">컨테이너에 단일 요소를 삽입하십시오. 현재 컨테이너를 반복하는 범위는 무효화되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="42c8592347a2b25e78dc2c81426ea39331669868" translate="yes" xml:space="preserve">
          <source>Insert current item from the source into the target.</source>
          <target state="translated">소스에서 대상으로 현재 항목을 삽입하십시오.</target>
        </trans-unit>
        <trans-unit id="d776dcf131b9f5a24feff6fc21b29e6dcf5da88f" translate="yes" xml:space="preserve">
          <source>Insert finally block calls when doing a goto from inside a try block to outside. Done after blocks are generated because then we know all the edges of the graph, but before the Bpred's are computed. Only for EH_DWARF exception unwinding.</source>
          <target state="translated">try 블록 내부에서 외부로 이동을 수행 할 때 finally 블록 호출을 삽입하십시오. 블록이 생성 된 후 그래프의 모든 가장자리를 알고 있지만 Bpred가 계산되기 전에 완료되었습니다. EH_DWARF 예외 풀기에만 해당됩니다.</target>
        </trans-unit>
        <trans-unit id="5471bf7c7cfa66ea6e595c4758d088cf1cff366e" translate="yes" xml:space="preserve">
          <source>Insert gotos to finally blocks when doing a return or goto from inside a try block to outside. Done after blocks are generated because then we know all the edges of the graph, but before the Bpred's are computed. Only for functions with no exception handling. Very similar to insertFinallyBlockCalls().</source>
          <target state="translated">try 블록 내부에서 외부로 돌아가거나 goto 할 때 gotos를 finally 블록에 삽입하십시오. 블록이 생성 된 후 그래프의 모든 가장자리를 알고 있지만 Bpred가 계산되기 전에 완료되었습니다. 예외 처리가없는 기능에만 해당됩니다. insertFinallyBlockCalls ()와 매우 유사합니다.</target>
        </trans-unit>
        <trans-unit id="dac79eb40ab7303630f93c4973c9239f694c7c19" translate="yes" xml:space="preserve">
          <source>Insert item into list at nth position.</source>
          <target state="translated">n 번째 위치에 항목을 목록에 삽입하십시오.</target>
        </trans-unit>
        <trans-unit id="e157f7049edabd9484326a29b8f9b52a72eaeb25" translate="yes" xml:space="preserve">
          <source>Inserted in place of invalid UTF sequences.</source>
          <target state="translated">유효하지 않은 UTF 시퀀스 대신 삽입되었습니다.</target>
        </trans-unit>
        <trans-unit id="143f825d20ba520107ed764caaeba3c49e097300" translate="yes" xml:space="preserve">
          <source>Inserting if not present</source>
          <target state="translated">없는 경우 삽입</target>
        </trans-unit>
        <trans-unit id="30a6615838d01663d72779532f25d77de2451cfa" translate="yes" xml:space="preserve">
          <source>Insertion failed because database is full</source>
          <target state="translated">데이터베이스가 가득 차서 삽입 실패</target>
        </trans-unit>
        <trans-unit id="20cdd78769ce43b7cb858f988154e98a6f228025" translate="yes" xml:space="preserve">
          <source>Insertion of array bounds checking code at runtime may be turned off with a compiler switch &lt;a href=&quot;https://dlang.org/dmd.html#switch-boundscheck&quot;&gt;&lt;code&gt;-boundscheck&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">런타임시 배열 범위 검사 코드 삽입은 컴파일러 switch- &lt;a href=&quot;https://dlang.org/dmd.html#switch-boundscheck&quot;&gt; &lt;code&gt;-boundscheck&lt;/code&gt; &lt;/a&gt; 사용하여 해제 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4bdc47adb0591faa30b8ba1f2040d211a501160c" translate="yes" xml:space="preserve">
          <source>Insertion of array bounds checking code at runtime should be turned on and off with a compile time switch.</source>
          <target state="translated">런타임시 배열 범위 검사 코드 삽입은 컴파일 타임 스위치를 사용하여 켜고 꺼야합니다.</target>
        </trans-unit>
        <trans-unit id="0fe401e132558c29c269b7fd6cffd6a1dc02d7db" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;stuff&lt;/code&gt; (which must be an input range or any number of implicitly convertible items) in &lt;code&gt;array&lt;/code&gt; at position &lt;code&gt;pos&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pos&lt;/code&gt; 위치의 &lt;code&gt;array&lt;/code&gt; 에 &lt;code&gt;stuff&lt;/code&gt; (입력 범위 또는 암묵적으로 변환 가능한 임의의 수의 항목이어야 함)을 삽입합니다 .</target>
        </trans-unit>
        <trans-unit id="ccbf9d19e58cf1e67a852d50890252788f63b174" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;stuff&lt;/code&gt; after range &lt;code&gt;r&lt;/code&gt;, which must be a non-empty range previously extracted from this container.</source>
          <target state="translated">삽입은 &lt;code&gt;stuff&lt;/code&gt; 범위 후 &lt;code&gt;r&lt;/code&gt; 이전에이 컨테이너에서 추출한 비어 있지 않은 범위에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="bbcf5a5de0747fda77b1e1e1643549b4e06e5bb8" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;stuff&lt;/code&gt; after range &lt;code&gt;r&lt;/code&gt;, which must be a range previously extracted from this container. Given that all ranges for a list end at the end of the list, this function essentially appends to the list and uses &lt;code&gt;r&lt;/code&gt; as a potentially fast way to reach the last node in the list. Ideally &lt;code&gt;r&lt;/code&gt; is positioned near or at the last element of the list.</source>
          <target state="translated">범위 &lt;code&gt;r&lt;/code&gt; 뒤에 &lt;code&gt;stuff&lt;/code&gt; 을 삽입합니다 .이 컨테이너는 이전에이 컨테이너에서 추출 된 범위 여야합니다. 리스트의 모든 범위가리스트의 끝에서 끝나는 것을 감안할 때,이 함수는 본질적으로리스트에 추가하고 &lt;code&gt;r&lt;/code&gt; 을 리스트 의 마지막 노드에 도달 할 수있는 빠른 방법으로 사용합니다. 이상적으로 &lt;code&gt;r&lt;/code&gt; 은 목록의 마지막 요소 근처 또는 마지막 요소에 위치합니다.</target>
        </trans-unit>
        <trans-unit id="6f06bb00c64490bdfd0684d68ce1e50ed8931cf5" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;stuff&lt;/code&gt; before, after, or instead range &lt;code&gt;r&lt;/code&gt;, which must be a valid range previously extracted from this array. &lt;code&gt;stuff&lt;/code&gt; can be a value convertible to &lt;code&gt;T&lt;/code&gt; or a range of objects convertible to &lt;code&gt;T&lt;/code&gt;. Both stable and non-stable version behave the same and guarantee that ranges iterating over the array are never invalidated.</source>
          <target state="translated">인서트 &lt;code&gt;stuff&lt;/code&gt; 전후, 또는 대신 범위 &lt;code&gt;r&lt;/code&gt; 이전이 어레이로부터 추출 된 유효 범위이어야. &lt;code&gt;stuff&lt;/code&gt; 는 &lt;code&gt;T&lt;/code&gt; 로 변환 가능한 값 이거나 &lt;code&gt;T&lt;/code&gt; 로 변환 가능한 객체 범위 일 수 있습니다 . 안정 버전과 비 안정 버전은 모두 동일하게 작동하며 어레이에서 반복되는 범위가 무효화되지 않도록 보장합니다.</target>
        </trans-unit>
        <trans-unit id="f08fcf4de04b5d69b89946f0b954703523fa90fc" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;stuff&lt;/code&gt; before, after, or instead range &lt;code&gt;r&lt;/code&gt;, which must be a valid range previously extracted from this array. &lt;code&gt;stuff&lt;/code&gt; can be a value convertible to &lt;code&gt;bool&lt;/code&gt; or a range of objects convertible to &lt;code&gt;bool&lt;/code&gt;. Both stable and non-stable version behave the same and guarantee that ranges iterating over the array are never invalidated.</source>
          <target state="translated">인서트 &lt;code&gt;stuff&lt;/code&gt; 전후, 또는 대신 범위 &lt;code&gt;r&lt;/code&gt; 이전이 어레이로부터 추출 된 유효 범위이어야. &lt;code&gt;stuff&lt;/code&gt; 에 변환 가능한 값이 될 수 &lt;code&gt;bool&lt;/code&gt; 로 하거나 전환 개체의 범위 &lt;code&gt;bool&lt;/code&gt; . 안정 버전과 비 안정 버전은 모두 동일하게 작동하며 어레이에서 반복되는 범위가 무효화되지 않도록 보장합니다.</target>
        </trans-unit>
        <trans-unit id="dcb7963cdc25fdee24c788729e6be8dd4f7e3c27" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;stuff&lt;/code&gt; to the front of the container. &lt;code&gt;stuff&lt;/code&gt; can be a value convertible to &lt;code&gt;T&lt;/code&gt; or a range of objects convertible to &lt;code&gt;T&lt;/code&gt;. The stable version behaves the same, but guarantees that ranges iterating over the container are never invalidated.</source>
          <target state="translated">컨테이너 앞에 &lt;code&gt;stuff&lt;/code&gt; 을 넣 습니다 . &lt;code&gt;stuff&lt;/code&gt; 는 &lt;code&gt;T&lt;/code&gt; 로 변환 가능한 값 이거나 &lt;code&gt;T&lt;/code&gt; 로 변환 가능한 객체 범위 일 수 있습니다 . 안정적인 버전은 동일하게 작동하지만 컨테이너를 반복하는 범위가 무효화되지 않도록 보장합니다.</target>
        </trans-unit>
        <trans-unit id="70b0bd082af545b88841219b95946def84b1bde5" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;stuff&lt;/code&gt; to the front/back of the container. &lt;code&gt;stuff&lt;/code&gt; can be a value convertible to &lt;code&gt;T&lt;/code&gt; or a range of objects convertible to &lt;code&gt;T&lt;/code&gt;. The stable version behaves the same, but guarantees that ranges iterating over the container are never invalidated.</source>
          <target state="translated">삽입은 &lt;code&gt;stuff&lt;/code&gt; 다시 용기 / 전면. &lt;code&gt;stuff&lt;/code&gt; 는 &lt;code&gt;T&lt;/code&gt; 로 변환 가능한 값 이거나 &lt;code&gt;T&lt;/code&gt; 로 변환 가능한 객체 범위 일 수 있습니다 . 안정적인 버전은 동일하게 작동하지만 컨테이너를 반복하는 범위가 무효화되지 않도록 보장합니다.</target>
        </trans-unit>
        <trans-unit id="98d4bdcdc44b42cf7f92f1b1fa3789c2aceb532f" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;v&lt;/code&gt; at the back of &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;c&lt;/code&gt; 뒤에 &lt;code&gt;v&lt;/code&gt; 를 삽입합니다 .</target>
        </trans-unit>
        <trans-unit id="314547f0dd75063020e998c66bb1c080e7cc353d" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;v&lt;/code&gt; at the front of &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;c&lt;/code&gt; 앞에 &lt;code&gt;v&lt;/code&gt; 를 삽입합니다 .</target>
        </trans-unit>
        <trans-unit id="9b4118de001ef07d96ca9dc875bb736525602b3c" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;value&lt;/code&gt; into the store. If the underlying store is a range and &lt;code&gt;length == capacity&lt;/code&gt;, throws an exception.</source>
          <target state="translated">상점에 &lt;code&gt;value&lt;/code&gt; 를 삽입합니다 . 기본 저장소가 range and &lt;code&gt;length == capacity&lt;/code&gt; 인 경우 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7a861229c3ddec4f67c4aba3fc949701aaf45a21" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;x&lt;/code&gt; in &lt;code&gt;c&lt;/code&gt; at a position (or positions) chosen by &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">삽입물 &lt;code&gt;x&lt;/code&gt; 에서 &lt;code&gt;c&lt;/code&gt; 가 선택된 위치 (또는 위치)에 &lt;code&gt;c&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="804f9143c06ffa0aedcfc5172722337eadf6df16" translate="yes" xml:space="preserve">
          <source>Inserts a blank line.</source>
          <target state="translated">빈 줄을 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="7a0447d3d52b9161fad5aa788df5312d0c9f70f2" translate="yes" xml:space="preserve">
          <source>Inserts a comment in the output.</source>
          <target state="translated">출력에 주석을 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="7a683c9546bcec22da2c836a994b3f342b2d3aa0" translate="yes" xml:space="preserve">
          <source>Inserts a full load/store memory fence (on platforms that need it). This ensures that all loads and stores before a call to this function are executed before any loads and stores after the call.</source>
          <target state="translated">전체로드 / 저장 메모리 펜스를 삽입합니다 (필요한 플랫폼에서). 이를 통해이 기능에 대한 호출 이전의 모든로드 및 저장이 호출 후로드 및 저장 전에 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="a94c7ccab5212d83d09585607543df4cd0d7b0e8" translate="yes" xml:space="preserve">
          <source>Inserts a separator between overloads of a given name.</source>
          <target state="translated">주어진 이름의 과부하 사이에 구분 기호를 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="aa15c23194538bcbb65217c20c49d6e178298d1b" translate="yes" xml:space="preserve">
          <source>Inserts inline code.</source>
          <target state="translated">인라인 코드를 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="be7c29e597d6483bb5cc792a0734c8430284107e" translate="yes" xml:space="preserve">
          <source>Inserts into an existing array at a given position.</source>
          <target state="translated">주어진 위치에서 기존 배열에 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="b2e6a38a54ba983c83824eb96e11fa99e1fb236e" translate="yes" xml:space="preserve">
          <source>Inserts the separator symbols ',' every</source>
          <target state="translated">구분 기호 ','마다 삽입</target>
        </trans-unit>
        <trans-unit id="801258f3c2858353c18f16295039e48c4b8fb913" translate="yes" xml:space="preserve">
          <source>Inserts the specified elements at the back of the array. &lt;code&gt;stuff&lt;/code&gt; can be a value convertible to &lt;code&gt;T&lt;/code&gt; or a range of objects convertible to &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">지정된 요소를 배열의 뒷면에 삽입합니다. &lt;code&gt;stuff&lt;/code&gt; 는 &lt;code&gt;T&lt;/code&gt; 로 변환 가능한 값 이거나 &lt;code&gt;T&lt;/code&gt; 로 변환 가능한 객체 범위 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="14cde1bdd1549aef1d369341e6d66efc2807a4bc" translate="yes" xml:space="preserve">
          <source>Inserts the specified elements at the back of the array. &lt;code&gt;stuff&lt;/code&gt; can be a value convertible to &lt;code&gt;bool&lt;/code&gt; or a range of objects convertible to &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">지정된 요소를 배열의 뒷면에 삽입합니다. &lt;code&gt;stuff&lt;/code&gt; 에 변환 가능한 값이 될 수 &lt;code&gt;bool&lt;/code&gt; 로 하거나 전환 개체의 범위 &lt;code&gt;bool&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1d605a6236091ada3048879c73c926d0efb2298d" translate="yes" xml:space="preserve">
          <source>Inside a compound format specifier, strings and characters are escaped automatically. To avoid this behavior, add &lt;b&gt;'-'&lt;/b&gt; flag to &lt;code&gt;&quot;%(&quot;&lt;/code&gt;.</source>
          <target state="translated">복합 형식 지정자 내에서 문자열과 문자는 자동으로 이스케이프됩니다. 이 동작을 피하려면 &lt;b&gt;'-'&lt;/b&gt; 플래그를 &lt;code&gt;&quot;%(&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aa6dfe54274ed1710b82f903b6abd73713a2f05a" translate="yes" xml:space="preserve">
          <source>Instance Variables</source>
          <target state="translated">인스턴스 변수</target>
        </trans-unit>
        <trans-unit id="6dcf70f56aa9632f46bb219a5e2ab80717bd81f1" translate="yes" xml:space="preserve">
          <source>Instance shared by all callers.</source>
          <target state="translated">모든 발신자가 공유 한 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="1d560aaea91ff74c40b9ba925224eb2e9cab5714" translate="yes" xml:space="preserve">
          <source>Instances of class objects are created with a &lt;a href=&quot;expression#NewExpression&quot;&gt;&lt;i&gt;NewExpression&lt;/i&gt;&lt;/a&gt;:</source>
          <target state="translated">클래스 객체의 인스턴스는 &lt;a href=&quot;expression#NewExpression&quot;&gt;&lt;i&gt;NewExpression&lt;/i&gt;&lt;/a&gt; 으로 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="0e15b22639879009392385cbbbd0e07778e511d1" translate="yes" xml:space="preserve">
          <source>Instances of this object are constructed via calls to &lt;code&gt;regex&lt;/code&gt;. This is an intended form for caching and storage of frequently used regular expressions.</source>
          <target state="translated">이 객체의 인스턴스는 &lt;code&gt;regex&lt;/code&gt; 호출을 통해 구성됩니다 . 이것은 자주 사용되는 정규식을 캐싱하고 저장하기위한 형식입니다.</target>
        </trans-unit>
        <trans-unit id="9c373dca3c1b04cc6629e642fffbe62b3a9fe4e5" translate="yes" xml:space="preserve">
          <source>Instantiate a new &lt;code&gt;DebugCondition&lt;/code&gt;</source>
          <target state="translated">새로운 &lt;code&gt;DebugCondition&lt;/code&gt; 인스턴스화</target>
        </trans-unit>
        <trans-unit id="3822674a7468f752517c5bf52d226dd0137e7bff" translate="yes" xml:space="preserve">
          <source>Instantiate a new &lt;code&gt;VersionCondition&lt;/code&gt;</source>
          <target state="translated">새 &lt;code&gt;VersionCondition&lt;/code&gt; 인스턴스화</target>
        </trans-unit>
        <trans-unit id="152f1a2b9d65da1e9f82b24f153f213ef690987a" translate="yes" xml:space="preserve">
          <source>Instantiates the given template with the given parameters.</source>
          <target state="translated">주어진 매개 변수로 주어진 템플리트를 인스턴스화합니다.</target>
        </trans-unit>
        <trans-unit id="4a327f215e80d73f8ee4464a28c7b7c009445a31" translate="yes" xml:space="preserve">
          <source>Instantiation Scope</source>
          <target state="translated">인스턴스화 범위</target>
        </trans-unit>
        <trans-unit id="93486e626687f1b1676b1b49e1fd6518a0b454b0" translate="yes" xml:space="preserve">
          <source>Instantiation information</source>
          <target state="translated">인스턴스화 정보</target>
        </trans-unit>
        <trans-unit id="dac2b060e0095872817c2470eb8b53d6b6180adb" translate="yes" xml:space="preserve">
          <source>Instatiates a new function call expression</source>
          <target state="translated">새로운 함수 호출 표현식을 나타냅니다</target>
        </trans-unit>
        <trans-unit id="10f4428424192063dd20e3361c36aa4d16de843c" translate="yes" xml:space="preserve">
          <source>Instead:</source>
          <target state="translated">Instead:</target>
        </trans-unit>
        <trans-unit id="a0905dbb5b366516614f7115449ef89eac51f289" translate="yes" xml:space="preserve">
          <source>Instruct libcurl to not use any signal/alarm handlers, even when using timeouts. This option is useful for multi-threaded applications. See libcurl-the-guide for more background information.</source>
          <target state="translated">타임 아웃을 사용할 때도 libcurl이 신호 / 알람 핸들러를 사용하지 않도록 지시하십시오. 이 옵션은 다중 스레드 응용 프로그램에 유용합니다. 자세한 배경 정보는 libcurl-the-guide를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="93df39339f21a04f493609200c104dc46ba84fa9" translate="yes" xml:space="preserve">
          <source>Instruct libcurl to use a smaller receive buffer</source>
          <target state="translated">더 작은 수신 버퍼를 사용하도록 libcurl에 지시</target>
        </trans-unit>
        <trans-unit id="4e856d175354403c672463be1daf8914ce0f2b64" translate="yes" xml:space="preserve">
          <source>Instruct the thread module, when initialized, to use a different set of signals besides SIGUSR1 and SIGUSR2 for suspension and resumption of threads. This function should be called at most once, prior to thread_init(). This function is Posix-only.</source>
          <target state="translated">스레드 모듈이 초기화되면 스레드의 일시 중단 및 재개를 위해 SIGUSR1 및 SIGUSR2 이외의 다른 신호 세트를 사용하도록 지시하십시오. 이 함수는 thread_init () 이전에 최대 한 번 호출되어야합니다. 이 기능은 Posix 전용입니다.</target>
        </trans-unit>
        <trans-unit id="343c620df1e3c7f2cdd388f70e9f17931e72b6e0" translate="yes" xml:space="preserve">
          <source>Instructions are selected from the target architecture to implement the semantics of the program. The typical result will be an object file suitable for input to a linker.</source>
          <target state="translated">프로그램의 의미를 구현하기 위해 대상 아키텍처에서 명령어를 선택합니다. 일반적인 결과는 링커에 대한 입력에 적합한 개체 파일입니다.</target>
        </trans-unit>
        <trans-unit id="ea729c0363a2bc9c76992c1a2e2bf3e5220ecc9e" translate="yes" xml:space="preserve">
          <source>Instructions are selected from the target architecture to implement the semantics of the program. The typical result will be an object file, suitable for input to a linker.</source>
          <target state="translated">프로그램의 의미를 구현하기 위해 대상 아키텍처에서 명령이 선택됩니다. 일반적인 결과는 링커에 입력하기에 적합한 객체 파일입니다.</target>
        </trans-unit>
        <trans-unit id="0b8c19f21525eb789fb435ee348ba111db6200af" translate="yes" xml:space="preserve">
          <source>Int &lt;code&gt;n&lt;/code&gt;</source>
          <target state="translated">Int &lt;code&gt;n&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="492ad7a25e9093c89a88ab9eae0481a3d6d480b5" translate="yes" xml:space="preserve">
          <source>IntRange &lt;strong id=&quot;getIntRange&quot;&gt;getIntRange&lt;/strong&gt;(Expression e);</source>
          <target state="translated">IntRange &lt;strong id=&quot;getIntRange&quot;&gt;getIntRange&lt;/strong&gt; (식 e);</target>
        </trans-unit>
        <trans-unit id="562d27265f4183bba6926e62be0c6ce57f7e2097" translate="yes" xml:space="preserve">
          <source>Integer Literals</source>
          <target state="translated">정수 리터럴</target>
        </trans-unit>
        <trans-unit id="bd777b837ba4f419f4b02435e27128be81023ef2" translate="yes" xml:space="preserve">
          <source>Integer Promotions</source>
          <target state="translated">정수 프로모션</target>
        </trans-unit>
        <trans-unit id="9568ecb6786424f8ca136701942b4f686fc642d2" translate="yes" xml:space="preserve">
          <source>Integer Promotions are conversions of the following types:</source>
          <target state="translated">정수 프로모션은 다음 유형의 변환입니다.</target>
        </trans-unit>
        <trans-unit id="db47076f1ac16cea001c1edc5817f57fa5127f93" translate="yes" xml:space="preserve">
          <source>Integer Whole Number: (byte, ubyte, short, ushort, int, uint, long, and ulong) ['+'|'-']digit(s)[U|L|UL]</source>
          <target state="translated">정수 정수 : (바이트, ubyte, short, ushort, int, uint, long 및 ulong) [ '+'| '-'] 자리수 [U | L | UL]</target>
        </trans-unit>
        <trans-unit id="2c1da0fff670105eb87d89c45a8168527ceeec25" translate="yes" xml:space="preserve">
          <source>Integer comparison operators</source>
          <target state="translated">정수 비교 연산자</target>
        </trans-unit>
        <trans-unit id="b5ccca1ae24a500cd1c22e7e4ca7606c1848c22a" translate="yes" xml:space="preserve">
          <source>Integer comparisons</source>
          <target state="translated">정수 비교</target>
        </trans-unit>
        <trans-unit id="343b406e188c4782bf6c33cf9f047756fbc9ecb9" translate="yes" xml:space="preserve">
          <source>Integer comparisons happen when both operands are integral types.</source>
          <target state="translated">두 피연산자가 모두 정수 유형 인 경우 정수 비교가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="adcbb9dbe2818c1f42e7e40cd4eb69ffc2847624" translate="yes" xml:space="preserve">
          <source>Integer values cannot be implicitly converted to another type that cannot represent the integer bit pattern after integral promotion. For example:</source>
          <target state="translated">정수 값은 정수 승격 후 정수 비트 패턴을 나타낼 수없는 다른 유형으로 암시 적으로 변환 될 수 없습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2745c9287a60962527a82479b71c8fcdcdfee9b5" translate="yes" xml:space="preserve">
          <source>IntegerExp &lt;strong id=&quot;literal&quot;&gt;literal&lt;/strong&gt;(int v)();</source>
          <target state="translated">IntegerExp &lt;strong id=&quot;literal&quot;&gt;리터럴&lt;/strong&gt; (int v) ();</target>
        </trans-unit>
        <trans-unit id="9ef2cfdc220f6cdcf3fe63e63ff8a17f54977fca" translate="yes" xml:space="preserve">
          <source>IntegerExpression</source>
          <target state="translated">IntegerExpression</target>
        </trans-unit>
        <trans-unit id="17c52e79fc66bb6ecd61f1fe24bcec43e30c42c1" translate="yes" xml:space="preserve">
          <source>IntegerLiteral</source>
          <target state="translated">IntegerLiteral</target>
        </trans-unit>
        <trans-unit id="36d10f6bb46fb8657ec9f18b1e3a960789ae3c76" translate="yes" xml:space="preserve">
          <source>Integers (that may be constant-folded).</source>
          <target state="translated">정수 (정수로 접힐 수 있음).</target>
        </trans-unit>
        <trans-unit id="f69d4a47975b227c4173e0f25508229d914b2ec7" translate="yes" xml:space="preserve">
          <source>Integers and floating point values can be implicitly converted to their vector equivalents:</source>
          <target state="translated">정수 및 부동 소수점 값은 암시 적으로 벡터와 동등한 것으로 변환 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="85eae330c4b91b44cc2722cee1dc4a35c6511dee" translate="yes" xml:space="preserve">
          <source>Integers can be immediately followed by one &amp;lsquo;L&amp;rsquo; or one of &amp;lsquo;u&amp;rsquo; or &amp;lsquo;U&amp;rsquo; or both. Note that there is no &amp;lsquo;l&amp;rsquo; suffix.</source>
          <target state="translated">정수 바로 뒤에 하나의 'L'또는 'u'또는 'U'중 하나 또는 둘 다가 올 수 있습니다. 'l'접미사가 없습니다.</target>
        </trans-unit>
        <trans-unit id="78c49e8c1cc448a9049ab277bc8754ecd4237b78" translate="yes" xml:space="preserve">
          <source>Integers can be specified in decimal, binary, or hexadecimal.</source>
          <target state="translated">정수는 10 진수, 2 진수 또는 16 진수로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c9a0e4fb0cc2adedee60f3111a26afca3f7a640" translate="yes" xml:space="preserve">
          <source>Integers can have embedded &amp;lsquo;_&amp;rsquo; characters to improve readability, and which are ignored.</source>
          <target state="translated">정수는 가독성을 높이기 위해 '_'문자를 포함 할 수 있으며 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="2f0a498505f60eef0691bff5f687040cecb8e8a2" translate="yes" xml:space="preserve">
          <source>Integers can have embedded &amp;lsquo;_&amp;rsquo; characters, which are ignored.</source>
          <target state="translated">정수는 '_'문자를 포함 할 수 있으며 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="e97fd09a5e159320944c7a6e53ff8dac7ae91693" translate="yes" xml:space="preserve">
          <source>Integral arithmetic operators operate on fixed width types. Results that are not representable in those fixed widths are silently truncated to fit. This module offers integral arithmetic primitives that produce the same results, but set an 'overflow' flag when such truncation occurs. The setting is sticky, meaning that numerous operations can be cascaded and then the flag need only be checked at the end. Whether the operation is signed or unsigned is indicated by an 's' or 'u' suffix, respectively. While this could be achieved without such suffixes by using overloading on the signedness of the types, the suffix makes it clear which is happening without needing to examine the types.</source>
          <target state="translated">정수 산술 연산자는 고정 너비 유형에서 작동합니다. 고정 너비로 ​​표현할 수없는 결과는 자동으로 잘립니다. 이 모듈은 동일한 결과를 생성하지만 이러한 잘림이 발생할 때 '오버플로'플래그를 설정하는 필수 산술 기본 형식을 제공합니다. 이 설정은 고정적이므로 여러 작업을 캐스케이드 할 수 있으며 마지막에 플래그 만 확인하면됩니다. 작업의 서명 여부는 각각 's'또는 'u'접미사로 표시됩니다. 이러한 유형의 부호에 과부하를 사용하여 이러한 접미사없이이를 달성 할 수 있지만, 접미사는 유형을 조사 할 필요없이 발생하는 부분을 명확하게합니다.</target>
        </trans-unit>
        <trans-unit id="6c054c378c65fd28ca92392142534a3f43340caf" translate="yes" xml:space="preserve">
          <source>Integral ranges</source>
          <target state="translated">적분 범위</target>
        </trans-unit>
        <trans-unit id="3c327fe3bc8ca1ef616b394085c0f88695904ee8" translate="yes" xml:space="preserve">
          <source>Integral types will remain the same sizes between 32 and 64 bit code.</source>
          <target state="translated">정수 유형은 32 비트와 64 비트 코드 사이에서 동일한 크기로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="58ee21eb085c257d8a08439c9aa7bd9d6570255b" translate="yes" xml:space="preserve">
          <source>Integrals</source>
          <target state="translated">Integrals</target>
        </trans-unit>
        <trans-unit id="304d073445766b9e99ba6213d6788d69fbbe285d" translate="yes" xml:space="preserve">
          <source>Integrals are formatted like &lt;a href=&quot;core_stdc_stdio#printf&quot;&gt;&lt;code&gt;core.stdc.stdio.printf&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">적분은 &lt;a href=&quot;core_stdc_stdio#printf&quot;&gt; &lt;code&gt;core.stdc.stdio.printf&lt;/code&gt; &lt;/a&gt; 와 같은 형식 입니다.</target>
        </trans-unit>
        <trans-unit id="20aeee70fc77c214f263c77b05117e3b20686b33" translate="yes" xml:space="preserve">
          <source>Intel Atom 230/330 (family 6, model 0x1C) is an in-order core.</source>
          <target state="translated">Intel Atom 230/330 (패밀리 6, 모델 0x1C)은 주문형 코어입니다.</target>
        </trans-unit>
        <trans-unit id="25a734a01cad152ff48222d53e7362444f3ac6cd" translate="yes" xml:space="preserve">
          <source>Intel NetBurst (Pentium 4, Pentium D).</source>
          <target state="translated">Intel NetBurst (Pentium 4, Pentium D).</target>
        </trans-unit>
        <trans-unit id="40d218fe001ffffff82fbf964a99f28c6e816245" translate="yes" xml:space="preserve">
          <source>Intel P6 (PentiumPro, PII, PIII, PM, Core, Core2).</source>
          <target state="translated">Intel P6 (PentiumPro, PII, PIII, PM, Core, Core2).</target>
        </trans-unit>
        <trans-unit id="ffc1549d5dca52e99aa4ab17a1e6e08f96cd5245" translate="yes" xml:space="preserve">
          <source>Intel and AMD 32-bit processors</source>
          <target state="translated">인텔 및 AMD 32 비트 프로세서</target>
        </trans-unit>
        <trans-unit id="3eaebee622e08211c80a68d4d6c79b54e2adb573" translate="yes" xml:space="preserve">
          <source>Intel and AMD 64-bit processors</source>
          <target state="translated">인텔 및 AMD 64 비트 프로세서</target>
        </trans-unit>
        <trans-unit id="d9d20cde548a0781b6cf33434f83eb6eb5ef95f8" translate="yes" xml:space="preserve">
          <source>Intended as the range equivalent of the Unix &lt;a href=&quot;http://en.wikipedia.org/wiki/Tail_%28Unix%29&quot;&gt;tail&lt;/a&gt; utility. When the length of &lt;code&gt;range&lt;/code&gt; is less than or equal to &lt;code&gt;_n&lt;/code&gt;, &lt;code&gt;range&lt;/code&gt; is returned as-is.</source>
          <target state="translated">유닉스 &lt;a href=&quot;http://en.wikipedia.org/wiki/Tail_%28Unix%29&quot;&gt;테일&lt;/a&gt; 유틸리티 와 동등한 범위로 사용됩니다. &lt;code&gt;range&lt;/code&gt; 의 길이 가 &lt;code&gt;_n&lt;/code&gt; 보다 작거나 같은 경우 &lt;code&gt;range&lt;/code&gt; 는 그대로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="d224c894bee5fb2e1d81dcb4e00203734abe5099" translate="yes" xml:space="preserve">
          <source>Intended as the range equivalent of the Unix &lt;a href=&quot;https://en.wikipedia.org/wiki/Tail_%28Unix%29&quot;&gt;tail&lt;/a&gt; utility. When the length of &lt;code&gt;range&lt;/code&gt; is less than or equal to &lt;code&gt;_n&lt;/code&gt;, &lt;code&gt;range&lt;/code&gt; is returned as-is.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b4db7ef1fa23cfb5e115a2a2c89d46a6a2ebc4a" translate="yes" xml:space="preserve">
          <source>Interface</source>
          <target state="translated">Interface</target>
        </trans-unit>
        <trans-unit id="d88c1e8acf6c80eddca147502d3048d176708e8b" translate="yes" xml:space="preserve">
          <source>Interface for a bidirectional range of type &lt;code&gt;E&lt;/code&gt;.</source>
          <target state="translated">유형 &lt;code&gt;E&lt;/code&gt; 의 양방향 범위에 대한 인터페이스 .</target>
        </trans-unit>
        <trans-unit id="d0e1da15b0eee348c354776c7e919fb0b891bd0d" translate="yes" xml:space="preserve">
          <source>Interface for a finite random access range of type &lt;code&gt;E&lt;/code&gt;.</source>
          <target state="translated">유형 &lt;code&gt;E&lt;/code&gt; 의 유한 랜덤 액세스 범위에 대한 인터페이스 .</target>
        </trans-unit>
        <trans-unit id="7a634a284850ac6bc64c6899e29c994e3e0d76a1" translate="yes" xml:space="preserve">
          <source>Interface for a forward range of type &lt;code&gt;E&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;E&lt;/code&gt; 타입의 순방향 범위를위한 인터페이스 .</target>
        </trans-unit>
        <trans-unit id="9a821a67cbe42a25dc97be41d2bf278fa2b3f8d9" translate="yes" xml:space="preserve">
          <source>Interface for an infinite random access range of type &lt;code&gt;E&lt;/code&gt;.</source>
          <target state="translated">유형 &lt;code&gt;E&lt;/code&gt; 의 무한 랜덤 액세스 범위에 대한 인터페이스 .</target>
        </trans-unit>
        <trans-unit id="c9d0cf57e850156d9f049479c7169bad62b9af52" translate="yes" xml:space="preserve">
          <source>Interface for an output range of type &lt;code&gt;E&lt;/code&gt;. Usage is similar to the &lt;code&gt;InputRange&lt;/code&gt; interface and descendants.</source>
          <target state="translated">유형 &lt;code&gt;E&lt;/code&gt; 의 출력 범위에 대한 인터페이스입니다 . 사용법은 &lt;code&gt;InputRange&lt;/code&gt; 인터페이스 및 하위 항목과 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="9460943add2d33f93432076ae984835cefe527f7" translate="yes" xml:space="preserve">
          <source>Interface for diagnostic reporting.</source>
          <target state="translated">진단보고를위한 인터페이스.</target>
        </trans-unit>
        <trans-unit id="3a1df4ab19b1c423cdf62882763fa74c4af37e82" translate="yes" xml:space="preserve">
          <source>Interface member functions can have contracts even though there is no body for the function. The contracts are inherited by any class member function that implements that interface member function.</source>
          <target state="translated">인터페이스 멤버 함수는 함수에 대한 본문이 없더라도 계약을 가질 수 있습니다. 계약은 해당 인터페이스 멤버 함수를 구현하는 모든 클래스 멤버 함수에 의해 상속됩니다.</target>
        </trans-unit>
        <trans-unit id="f3be3896196c198c957ce4d700b0918b399182de" translate="yes" xml:space="preserve">
          <source>Interface to C++</source>
          <target state="translated">C ++ 인터페이스</target>
        </trans-unit>
        <trans-unit id="d7b35a8578bedf4b2033b8a1d3efb36b51c26426" translate="yes" xml:space="preserve">
          <source>Interface to ODBC C library.</source>
          <target state="translated">ODBC C 라이브러리에 대한 인터페이스.</target>
        </trans-unit>
        <trans-unit id="621522c8d929097b62eb853aff27378218dcc932" translate="yes" xml:space="preserve">
          <source>Interface to OS-specific allocators that support specifying alignment: &lt;a href=&quot;http://man7.org/linux/man-pages/man3/posix_memalign.3.html&quot;&gt;&lt;code&gt;posix_memalign&lt;/code&gt;&lt;/a&gt; on Posix and &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/fs9stz4e(v=vs.80).aspx&quot;&gt;&lt;code&gt;__aligned_xxx&lt;/code&gt;&lt;/a&gt; on Windows.</source>
          <target state="translated">정렬 지정을 지원하는 OS 별 할당 자에 대한 인터페이스 : Posix의 &lt;a href=&quot;http://man7.org/linux/man-pages/man3/posix_memalign.3.html&quot;&gt; &lt;code&gt;posix_memalign&lt;/code&gt; &lt;/a&gt; 및 Windows의 &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/fs9stz4e(v=vs.80).aspx&quot;&gt; &lt;code&gt;__aligned_xxx&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c9356162c9758a6025c5564cd31dbf1d408652c7" translate="yes" xml:space="preserve">
          <source>Interface to OS-specific allocators that support specifying alignment: &lt;a href=&quot;http://man7.org/linux/man-pages/man3/posix_memalign.3.html&quot;&gt;&lt;code&gt;posix_memalign&lt;/code&gt;&lt;/a&gt; on Posix and &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/fs9stz4e(v=vs.80).aspx&quot;&gt;&lt;code&gt;__aligned_xxx&lt;/code&gt;&lt;/a&gt; on Windows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da8580df0429b0473e5e3791367530334b73829e" translate="yes" xml:space="preserve">
          <source>Interface to SQLite C library.</source>
          <target state="translated">SQLite C 라이브러리에 대한 인터페이스</target>
        </trans-unit>
        <trans-unit id="7de306419630810feb8071066cf5e31bb55e01fb" translate="yes" xml:space="preserve">
          <source>Interface to libcurl C library.</source>
          <target state="translated">libcurl C 라이브러리에 대한 인터페이스</target>
        </trans-unit>
        <trans-unit id="f42fa13806030306bbca72d2c1d02ced3c60299a" translate="yes" xml:space="preserve">
          <source>Interface to the C linked list type.</source>
          <target state="translated">C 연결리스트 유형에 대한 인터페이스.</target>
        </trans-unit>
        <trans-unit id="e3744c2b6a83f2ded743b60e48109853d6af0029" translate="yes" xml:space="preserve">
          <source>Interface to zlib C library.</source>
          <target state="translated">zlib C 라이브러리에 대한 인터페이스.</target>
        </trans-unit>
        <trans-unit id="0e4b1bcf55c79cee225ecf64df995188b37f85a9" translate="yes" xml:space="preserve">
          <source>Interface[] &lt;strong id=&quot;interfaces&quot;&gt;interfaces&lt;/strong&gt;;</source>
          <target state="translated">인터페이스 [] &lt;strong id=&quot;interfaces&quot;&gt;인터페이스&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="b356313f979923fc829adb909098ed26a5a01aff" translate="yes" xml:space="preserve">
          <source>Interfaces</source>
          <target state="translated">Interfaces</target>
        </trans-unit>
        <trans-unit id="87ef706c8b2c0856ee57ff234b67b63ee3440c74" translate="yes" xml:space="preserve">
          <source>Interfaces can be inherited and functions overridden:</source>
          <target state="translated">인터페이스를 상속하고 함수를 재정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c38dbc7db84c5be19893f9ea37a5e4e03b244d7" translate="yes" xml:space="preserve">
          <source>Interfaces can be reimplemented in derived classes:</source>
          <target state="translated">파생 클래스에서 인터페이스를 다시 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c369ab8b0d4a9f58e24c8d22b04e27527c78058" translate="yes" xml:space="preserve">
          <source>Interfaces can have function templates in the members. All instantiated functions are implicitly &lt;code&gt;final&lt;/code&gt;.</source>
          <target state="translated">인터페이스는 멤버에 함수 템플릿을 가질 수 있습니다. 모든 인스턴스화 된 함수는 암시 적으로 &lt;code&gt;final&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="bdf123e52e487e317a85601aa2c062c8ae21bd83" translate="yes" xml:space="preserve">
          <source>Interfaces cannot derive from classes; only from other interfaces. Classes cannot derive from an interface multiple times.</source>
          <target state="translated">인터페이스는 클래스에서 파생 될 수 없습니다. 다른 인터페이스에서만. 클래스는 인터페이스에서 여러 번 파생 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="233b20e42a18eec431d3cd18cbd18fa45bf5e124" translate="yes" xml:space="preserve">
          <source>Interfaces describe a list of functions that a class that inherits from the interface must implement. A class that implements an interface can be converted to a reference to that interface.</source>
          <target state="translated">인터페이스는 인터페이스에서 상속 된 클래스가 구현해야하는 함수 목록을 설명합니다. 인터페이스를 구현하는 클래스는 해당 인터페이스에 대한 참조로 변환 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c99b66b1687d267b80c156d483b9207e87aa2612" translate="yes" xml:space="preserve">
          <source>Interfaces to extend FTS5.</source>
          <target state="translated">FTS5를 확장하기위한 인터페이스.</target>
        </trans-unit>
        <trans-unit id="737865cc9d40029ada2522214f2743a9901cb1cf" translate="yes" xml:space="preserve">
          <source>Interfaces with Contracts</source>
          <target state="translated">계약과의 인터페이스</target>
        </trans-unit>
        <trans-unit id="772a604c8c3d9a084a30e26beb308940804e19fb" translate="yes" xml:space="preserve">
          <source>Interfacing Garbage Collected Objects With Foreign Code</source>
          <target state="translated">가비지 수집 된 객체와 외부 코드의 인터페이스</target>
        </trans-unit>
        <trans-unit id="acbc7801b292b22fd84bb969c2c0f9ee879becf9" translate="yes" xml:space="preserve">
          <source>Interfacing to C</source>
          <target state="translated">C와 인터페이스</target>
        </trans-unit>
        <trans-unit id="00b1220db63301a90c567b7096023b21f5a7b981" translate="yes" xml:space="preserve">
          <source>Interfacing to C++</source>
          <target state="translated">C ++와 인터페이스</target>
        </trans-unit>
        <trans-unit id="3f32265411f24516436989da79a8b9c2fd589ebb" translate="yes" xml:space="preserve">
          <source>Interfacing to Objective-C</source>
          <target state="translated">Objective-C와 인터페이스</target>
        </trans-unit>
        <trans-unit id="e66a4ffa477a1f7eb282b4a707de158b622e6eab" translate="yes" xml:space="preserve">
          <source>Interfacing with C++</source>
          <target state="translated">C ++와 인터페이스</target>
        </trans-unit>
        <trans-unit id="bbe037479f31c550dbeec51a4592f398993011e6" translate="yes" xml:space="preserve">
          <source>Internal attributes. Bit 1 is set, if the member is apparently in binary format and bit 2 is set, if each record is preceded by the length of the record.</source>
          <target state="translated">내부 속성. 멤버가 분명히 2 진 형식이고 비트 2가 설정된 경우 비트 1이 설정되고 각 레코드 앞에 레코드 길이가 오면 비트 1이 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="63d3004e718ad2e15676793a202fef50196ce165" translate="yes" xml:space="preserve">
          <source>Internal logic error in SQLite</source>
          <target state="translated">SQLite의 내부 논리 오류</target>
        </trans-unit>
        <trans-unit id="d5242b6068ce3aa3e94925e147e46c817b1e87d1" translate="yes" xml:space="preserve">
          <source>Internal use only</source>
          <target state="translated">내부 전용</target>
        </trans-unit>
        <trans-unit id="dcfe56ee50b5246e8fc3d1efd71bcc80c9c2cbd3" translate="yes" xml:space="preserve">
          <source>International Domain Names support</source>
          <target state="translated">국제 도메인 이름 지원</target>
        </trans-unit>
        <trans-unit id="1c9eb8fe39b663da62bd55d532bbc1d6dc4480d5" translate="yes" xml:space="preserve">
          <source>Internet Control Message Protocol</source>
          <target state="translated">인터넷 제어 메시지 프로토콜</target>
        </trans-unit>
        <trans-unit id="4f4f826bb57cdd671bbd6bb81ae23885f0d13165" translate="yes" xml:space="preserve">
          <source>Internet Control Message Protocol level</source>
          <target state="translated">인터넷 제어 메시지 프로토콜 수준</target>
        </trans-unit>
        <trans-unit id="1eadf3559d5760f57d825a20ef7a765cc6fff6a8" translate="yes" xml:space="preserve">
          <source>Internet Group Management Protocol</source>
          <target state="translated">인터넷 그룹 관리 프로토콜</target>
        </trans-unit>
        <trans-unit id="486a00bfbd24a5012797e69fc29110b48c224e56" translate="yes" xml:space="preserve">
          <source>Internet Group Management Protocol level</source>
          <target state="translated">인터넷 그룹 관리 프로토콜 수준</target>
        </trans-unit>
        <trans-unit id="ccfc6a40d215b229ecf5eb8e225cff288aef8d60" translate="yes" xml:space="preserve">
          <source>Internet Protocol version 4</source>
          <target state="translated">인터넷 프로토콜 버전 4</target>
        </trans-unit>
        <trans-unit id="8f31285e4d3c0d1160715ca496686f163954b9a4" translate="yes" xml:space="preserve">
          <source>Internet Protocol version 4 level</source>
          <target state="translated">인터넷 프로토콜 버전 4 레벨</target>
        </trans-unit>
        <trans-unit id="8b3f601b89a80177e18ecc46b747bb6d436f1059" translate="yes" xml:space="preserve">
          <source>Internet Protocol version 6</source>
          <target state="translated">인터넷 프로토콜 버전 6</target>
        </trans-unit>
        <trans-unit id="a1072e310be98411b8cd11656cb7bff695706b85" translate="yes" xml:space="preserve">
          <source>Internet Protocol version 6 level</source>
          <target state="translated">인터넷 프로토콜 버전 6 레벨</target>
        </trans-unit>
        <trans-unit id="93cc60f22833d45c27c517bcc4c0654c96515575" translate="yes" xml:space="preserve">
          <source>Interprets variadic argument list &lt;code&gt;args&lt;/code&gt;, formats them according to &lt;code&gt;fmt&lt;/code&gt;, and sends the resulting characters to &lt;code&gt;w&lt;/code&gt;. The encoding of the output is the same as &lt;code&gt;Char&lt;/code&gt;. The type &lt;code&gt;Writer&lt;/code&gt; must satisfy &lt;code&gt;&lt;a href=&quot;std_range_primitives#isOutputRange&quot;&gt;std.range.primitives.isOutputRange&lt;/a&gt;!(Writer, Char)&lt;/code&gt;.</source>
          <target state="translated">variadic argument list &lt;code&gt;args&lt;/code&gt; 를 해석 하고 &lt;code&gt;fmt&lt;/code&gt; 에 따라 형식화 한 다음 결과 문자를 &lt;code&gt;w&lt;/code&gt; 로 보냅니다 . 출력의 인코딩은 &lt;code&gt;Char&lt;/code&gt; 와 동일합니다 . &lt;code&gt;Writer&lt;/code&gt; 유형 은 &lt;code&gt;&lt;a href=&quot;std_range_primitives#isOutputRange&quot;&gt;std.range.primitives.isOutputRange&lt;/a&gt;!(Writer, Char)&lt;/code&gt; 충족해야합니다 .</target>
        </trans-unit>
        <trans-unit id="1215cbe2c98ef14d7aa50ec46f17432a95774205" translate="yes" xml:space="preserve">
          <source>Interrupt A Long-Running Query</source>
          <target state="translated">장기 실행 쿼리 중단</target>
        </trans-unit>
        <trans-unit id="3d60c3309aeba9fb9a2d2efeac2160bd862157e8" translate="yes" xml:space="preserve">
          <source>Interval &lt;code&gt;interval&lt;/code&gt;</source>
          <target state="translated">간격 &lt;code&gt;interval&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d6fe01334021f703c84b5da0607e6be23e76dade" translate="yes" xml:space="preserve">
          <source>Interval &lt;code&gt;rhs&lt;/code&gt;</source>
          <target state="translated">간격 &lt;code&gt;rhs&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9b5f0564cad1e60053ec849638012d9696df2ed9" translate="yes" xml:space="preserve">
          <source>Interval option specifier for &lt;code&gt;until&lt;/code&gt; (below) and others.</source>
          <target state="translated">&lt;code&gt;until&lt;/code&gt; (아래) 및 기타에 대한 간격 옵션 지정자 .</target>
        </trans-unit>
        <trans-unit id="52111c85baee81db8b2b3521d90bcf690e303a6e" translate="yes" xml:space="preserve">
          <source>Interval!TP &lt;code&gt;interval&lt;/code&gt;</source>
          <target state="translated">간격! TP &lt;code&gt;interval&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b37eedf146eb2ebd5bc1c25708b31f56d1fc371d" translate="yes" xml:space="preserve">
          <source>IntervalRange &lt;code&gt;rhs&lt;/code&gt;</source>
          <target state="translated">IntervalRange &lt;code&gt;rhs&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="607b0ac46a2df5a924b307d562abd8e57ec9ce2f" translate="yes" xml:space="preserve">
          <source>Intervals and Ranges of Time</source>
          <target state="translated">간격과 시간 범위</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="1fb7463147331b617ca5303fd1b3438ad66cc4fc" translate="yes" xml:space="preserve">
          <source>Introduction to std.datetime</source>
          <target state="translated">std.datetime 소개</target>
        </trans-unit>
        <trans-unit id="b3b4d20d3dfe4ef78d0bf43a93aa7f57bae176c5" translate="yes" xml:space="preserve">
          <source>Introspection</source>
          <target state="translated">Introspection</target>
        </trans-unit>
        <trans-unit id="a20a3e7ab504a9565c6aedca53d4fdbe5513a566" translate="yes" xml:space="preserve">
          <source>Invalid State</source>
          <target state="translated">잘못된 상태</target>
        </trans-unit>
        <trans-unit id="a1bff97e3a0d9f8589413296b0f1e0569f71930c" translate="yes" xml:space="preserve">
          <source>Invalid file name.</source>
          <target state="translated">잘못된 파일 이름.</target>
        </trans-unit>
        <trans-unit id="a6eb263d63885ee3d552ee7aff55324ad0e9ead4" translate="yes" xml:space="preserve">
          <source>Invalidates when this Grapheme leaves the scope, attempts to use it then would lead to memory corruption.</source>
          <target state="translated">이 Grapheme이 범위를 벗어나면 무효화되고이를 사용하려고하면 메모리 손상이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3c6f0311284e9216efb54d8e9865ea4fdb6fb5cc" translate="yes" xml:space="preserve">
          <source>Invariant blocks should contain &lt;code&gt;assert&lt;/code&gt; expressions, and should throw &lt;code&gt;AssertError&lt;/code&gt;s when they fail. Since DMD version 2.081.0, invariants can also be written as expression statements, with &lt;code&gt;assert&lt;/code&gt; implied:</source>
          <target state="translated">불변 블록은 &lt;code&gt;assert&lt;/code&gt; 표현식을 포함 해야하며 실패 할 때 &lt;code&gt;AssertError&lt;/code&gt; 를 발생 시켜야합니다 . 와 DMD 버전 2.081.0 때문에, 불변 또한, 표현의 문장과 같이 쓸 수있다 &lt;code&gt;assert&lt;/code&gt; 암시 :</target>
        </trans-unit>
        <trans-unit id="1601557f501dcc1665159d7c25e7f800b4c4d376" translate="yes" xml:space="preserve">
          <source>Invariant checks.</source>
          <target state="translated">불변 점검.</target>
        </trans-unit>
        <trans-unit id="3390616cafac7ff314d6aadaf20e48034cbb3314" translate="yes" xml:space="preserve">
          <source>Invariants</source>
          <target state="translated">Invariants</target>
        </trans-unit>
        <trans-unit id="aaafc5af09fec54c46e5ca35204284fae32a4ed8" translate="yes" xml:space="preserve">
          <source>Invariants are implicitly &lt;code&gt;const&lt;/code&gt;.</source>
          <target state="translated">불변은 암묵적으로 &lt;code&gt;const&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="552014b091503ffa5bb90ba68ad234e50e75c24c" translate="yes" xml:space="preserve">
          <source>Invariants are used to specify characteristics of a class or struct that must always be true (except while executing a member function). For example, a class representing a date might have an invariant that the day must be 1..31 and the hour must be 0..23:</source>
          <target state="translated">변수는 항상 참이어야하는 클래스 또는 구조체의 특성을 지정하는 데 사용됩니다 (멤버 함수를 실행하는 동안 제외). 예를 들어, 날짜를 나타내는 클래스는 날짜가 1..31이어야하고 시간이 0..23이어야한다는 변함이 없을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d6016fe71d03226948598f177a7e24383a6ccfb" translate="yes" xml:space="preserve">
          <source>Inverse FFT that allows a user-supplied buffer to be provided. The buffer must be a random access range with slicing, and its elements must be some complex-like type.</source>
          <target state="translated">사용자 제공 버퍼를 제공 할 수있는 역 FFT. 버퍼는 슬라이싱이있는 임의의 액세스 범위 여야하며 해당 요소는 복잡한 유형이어야합니다.</target>
        </trans-unit>
        <trans-unit id="8f589f4c2f971c6116b057e5c215d537ca7cb43e" translate="yes" xml:space="preserve">
          <source>Inverse of Normal distribution function</source>
          <target state="translated">정규 분포 함수의 역</target>
        </trans-unit>
        <trans-unit id="eef79ffda3ceb35fae03bd8ea406fdd1ab0607fb" translate="yes" xml:space="preserve">
          <source>Inverse of Standard normal distribution function</source>
          <target state="translated">표준 정규 분포의 역함수</target>
        </trans-unit>
        <trans-unit id="c03358c4f54ce52294e142183e933b46fcb8b9f4" translate="yes" xml:space="preserve">
          <source>Inverse of complemented incomplete gamma integral</source>
          <target state="translated">보완 된 불완전한 감마 적분의 역수</target>
        </trans-unit>
        <trans-unit id="9bc72f0d8f316fcee653be902a9618f6a8a72f2c" translate="yes" xml:space="preserve">
          <source>Inverse of incomplete beta integral</source>
          <target state="translated">불완전한 베타 적분의 역수</target>
        </trans-unit>
        <trans-unit id="5f54f70c78f3db6ca340241c50fe53fee043bc4b" translate="yes" xml:space="preserve">
          <source>Inverse of the Log Minus Digamma function</source>
          <target state="translated">로그 마이너스 디 감마 함수의 역함수</target>
        </trans-unit>
        <trans-unit id="8f85e13b0d42fd1b4a5a865686a2d49695460bb5" translate="yes" xml:space="preserve">
          <source>Invoking the program with &quot;--output=myfile.txt --output=yourfile.txt&quot; or &quot;--output myfile.txt --output yourfile.txt&quot; will set &lt;code&gt;outputFiles&lt;/code&gt; to &lt;code&gt;[ &quot;myfile.txt&quot;, &quot;yourfile.txt&quot; ]&lt;/code&gt;.  Alternatively you can set &lt;a href=&quot;#arraySep&quot;&gt;&lt;code&gt;arraySep&lt;/code&gt;&lt;/a&gt; as the element separator:</source>
          <target state="translated">&quot;--output = myfile.txt --output = yourfile.txt&quot;또는 &quot;--output myfile.txt --output yourfile.txt&quot;로 프로그램을 호출하면 &lt;code&gt;outputFiles&lt;/code&gt; 가 &lt;code&gt;[ &quot;myfile.txt&quot;, &quot;yourfile.txt&quot; ]&lt;/code&gt; 설정됩니다. &quot;] . 또는 &lt;a href=&quot;#arraySep&quot;&gt; &lt;code&gt;arraySep&lt;/code&gt; &lt;/a&gt; 를 요소 구분 기호로 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="046f12a723835d1e4a1306bab5174447eb70771f" translate="yes" xml:space="preserve">
          <source>Invoking the program with &quot;--output=myfile.txt --output=yourfile.txt&quot; or &quot;--output myfile.txt --output yourfile.txt&quot; will set &lt;code&gt;outputFiles&lt;/code&gt; to &lt;code&gt;[ &quot;myfile.txt&quot;, &quot;yourfile.txt&quot; ]&lt;/code&gt;.  Alternatively you can set &lt;a href=&quot;#arraySep&quot;&gt;&lt;code&gt;arraySep&lt;/code&gt;&lt;/a&gt; to allow multiple elements in one parameter.</source>
          <target state="translated">&quot;--output = myfile.txt --output = yourfile.txt&quot;또는 &quot;--output myfile.txt --output yourfile.txt&quot;로 프로그램을 호출하면 &lt;code&gt;outputFiles&lt;/code&gt; 가 &lt;code&gt;[ &quot;myfile.txt&quot;, &quot;yourfile.txt&quot; ]&lt;/code&gt; 설정됩니다. &quot;] . 또는 하나의 매개 변수에 여러 요소를 허용하도록 &lt;a href=&quot;#arraySep&quot;&gt; &lt;code&gt;arraySep&lt;/code&gt; &lt;/a&gt; 를 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e1d20fac3714b4db9127e8efa778c74b54cd4e0b" translate="yes" xml:space="preserve">
          <source>Invoking the program with &quot;--output=myfile.txt&quot; or &quot;--output myfile.txt&quot; will set &lt;code&gt;outputFile&lt;/code&gt; to &quot;myfile.txt&quot;. If you want to pass a string containing spaces, you need to use the quoting that is appropriate to your shell, e.g. --output='my file.txt'.</source>
          <target state="translated">&quot;--output = myfile.txt&quot;또는 &quot;--output myfile.txt&quot;로 프로그램을 호출하면 &lt;code&gt;outputFile&lt;/code&gt; 이 &quot;myfile.txt&quot;로 설정됩니다. 공백이 포함 된 문자열을 전달하려면 쉘에 적합한 따옴표를 사용해야합니다 (예 : --output = 'my file.txt').</target>
        </trans-unit>
        <trans-unit id="93d64dcdad645b5a71f4e6d58798c14d358623b2" translate="yes" xml:space="preserve">
          <source>Invoking the program with &quot;--paranoid --paranoid --paranoid&quot; will set &lt;code&gt; paranoid&lt;/code&gt; to 3. Note that an incremental option never expects a parameter, e.g., in the command line &quot;--paranoid 42 --paranoid&quot;, the &quot;42&quot; does not set &lt;code&gt;paranoid&lt;/code&gt; to 42; instead, &lt;code&gt;paranoid&lt;/code&gt; is set to 2 and &quot;42&quot; is not considered as part of the normal program arguments.</source>
          <target state="translated">&quot;--paranoid --paranoid --paranoid&quot;로 프로그램을 호출하면 &lt;code&gt; paranoid&lt;/code&gt; 이 3으로 설정됩니다 . 증분 옵션은 매개 변수를 예상하지 않습니다. 예를 들어 명령 행 &quot;--paranoid 42 --paranoid&quot;, &quot;42 &quot;는 &lt;code&gt;paranoid&lt;/code&gt; 을 42로 설정하지 않습니다 . 대신, &lt;code&gt;paranoid&lt;/code&gt; 은 2로 설정되고 &quot;42&quot;는 정상적인 프로그램 인수의 일부로 간주되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8b6eaac5b877b952f6bcf72430619aedf647b1a8" translate="yes" xml:space="preserve">
          <source>Invoking the program with e.g. &quot;--tune=alpha=0.5 --tune beta=0.6&quot; will set &lt;code&gt;tuningParms&lt;/code&gt; to [ &quot;alpha&quot; : 0.5, &quot;beta&quot; : 0.6 ].  Alternatively you can set &lt;a href=&quot;#arraySep&quot;&gt;&lt;code&gt;arraySep&lt;/code&gt;&lt;/a&gt; as the element separator:</source>
          <target state="translated">예를 들어 &quot;--tune = alpha = 0.5 --tune beta = 0.6&quot;으로 프로그램을 호출하면 &lt;code&gt;tuningParms&lt;/code&gt; 가 [ &quot;alpha&quot;: 0.5, &quot;beta&quot;: 0.6]으로 설정됩니다. 또는 &lt;a href=&quot;#arraySep&quot;&gt; &lt;code&gt;arraySep&lt;/code&gt; &lt;/a&gt; 를 요소 구분 기호로 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a51b807dff53b59ce17fa8ba3b4efb7c37298356" translate="yes" xml:space="preserve">
          <source>Is 'this' a pointer to a static array holding two contexts.</source>
          <target state="translated">'this'는 두 컨텍스트를 보유하는 정적 배열에 대한 포인터입니다.</target>
        </trans-unit>
        <trans-unit id="d4f04607ce8bc35a535f2eafaf232f2ae5e08636" translate="yes" xml:space="preserve">
          <source>Is 3DNow prefetch supported?</source>
          <target state="translated">3DNow 프리 페치가 지원됩니까?</target>
        </trans-unit>
        <trans-unit id="c1091b8fd8404cafbdd2e1da298b3c08898531c9" translate="yes" xml:space="preserve">
          <source>Is &lt;code&gt;From&lt;/code&gt; implicitly convertible to &lt;code&gt;To&lt;/code&gt;?</source>
          <target state="translated">가 &lt;code&gt;From&lt;/code&gt; 로 전환 암시 적 &lt;code&gt;To&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="6527c515f699697a6d232a689619fd938ee60f0e" translate="yes" xml:space="preserve">
          <source>Is AES supported</source>
          <target state="translated">AES 지원</target>
        </trans-unit>
        <trans-unit id="a8cd9e904825556bf96828e0f6d502417a5ff971" translate="yes" xml:space="preserve">
          <source>Is AMD 3DNOW Ext supported?</source>
          <target state="translated">AMD 3DNOW Ext가 지원됩니까?</target>
        </trans-unit>
        <trans-unit id="cefb7da98db99e806ecf4f9d16aa97f479cb52ce" translate="yes" xml:space="preserve">
          <source>Is AMD 3DNOW supported?</source>
          <target state="translated">AMD 3DNOW가 지원됩니까?</target>
        </trans-unit>
        <trans-unit id="3467fc8e189fda3cf33326fc0d09e8bdf079f9fb" translate="yes" xml:space="preserve">
          <source>Is AVX supported</source>
          <target state="translated">AVX가 지원됩니까</target>
        </trans-unit>
        <trans-unit id="780bb1bc188e3b5539f81c0d650a1e7ddcd84502" translate="yes" xml:space="preserve">
          <source>Is AVX2 supported</source>
          <target state="translated">AVX2 지원</target>
        </trans-unit>
        <trans-unit id="930e8f6c9f8db481832b42bf5d22e519ab0e0ba7" translate="yes" xml:space="preserve">
          <source>Is Dsymbol a variable that contains pointers?</source>
          <target state="translated">Dsymbol은 포인터를 포함하는 변수입니까?</target>
        </trans-unit>
        <trans-unit id="f393ec53178029468d90ccfedc6fdafe870ef6c6" translate="yes" xml:space="preserve">
          <source>Is FMA supported</source>
          <target state="translated">FMA 지원</target>
        </trans-unit>
        <trans-unit id="926d3c2bb40647642867740cf289a55c2684c607" translate="yes" xml:space="preserve">
          <source>Is FP16C supported</source>
          <target state="translated">FP16C가 지원됩니까</target>
        </trans-unit>
        <trans-unit id="a75e00d20bd98c427350c031bd2576f677c9bc19" translate="yes" xml:space="preserve">
          <source>Is HLE (hardware lock elision) supported</source>
          <target state="translated">HLE (하드웨어 잠금 제거)가 지원됩니까?</target>
        </trans-unit>
        <trans-unit id="5c63067c0b3183b5f4abc564381bb25d3d1231a7" translate="yes" xml:space="preserve">
          <source>Is LZCNT supported?</source>
          <target state="translated">LZCNT가 지원됩니까?</target>
        </trans-unit>
        <trans-unit id="80343d68528e1f0d53f3a2e549cd71634470e6e5" translate="yes" xml:space="preserve">
          <source>Is MMX supported?</source>
          <target state="translated">MMX가 지원됩니까?</target>
        </trans-unit>
        <trans-unit id="114c091c0c22495cd9a32fec40491702ce24f441" translate="yes" xml:space="preserve">
          <source>Is POPCNT supported?</source>
          <target state="translated">POPCNT가 지원됩니까?</target>
        </trans-unit>
        <trans-unit id="092c9f81639a5605a53fbcf69c7be6aa88dbd446" translate="yes" xml:space="preserve">
          <source>Is RTM (restricted transactional memory) supported</source>
          <target state="translated">RTM (제한된 트랜잭션 메모리)이 지원됩니까?</target>
        </trans-unit>
        <trans-unit id="24109cfc7f69bcaf97712b43c58ddf2b22ea3c9a" translate="yes" xml:space="preserve">
          <source>Is SHA supported</source>
          <target state="translated">SHA 지원</target>
        </trans-unit>
        <trans-unit id="3511bb1b8685cb3d3a378cd1f674c89a05416048" translate="yes" xml:space="preserve">
          <source>Is SSE supported?</source>
          <target state="translated">SSE가 지원됩니까?</target>
        </trans-unit>
        <trans-unit id="d33bcfafec9efc7ddbbfe4306ce2e227725bf3cf" translate="yes" xml:space="preserve">
          <source>Is SSE2 supported?</source>
          <target state="translated">SSE2가 지원됩니까?</target>
        </trans-unit>
        <trans-unit id="2b949ad5258cac339f8f205f2bc83cc9e9a30c77" translate="yes" xml:space="preserve">
          <source>Is SSE3 supported?</source>
          <target state="translated">SSE3가 지원됩니까?</target>
        </trans-unit>
        <trans-unit id="56ee911e8f809a3ad52a479f6bd11d4cb88c2a3b" translate="yes" xml:space="preserve">
          <source>Is SSE4.1 supported?</source>
          <target state="translated">SSE4.1이 지원됩니까?</target>
        </trans-unit>
        <trans-unit id="799b3ec53e6f94a6529a4281676d281ef3e42b2d" translate="yes" xml:space="preserve">
          <source>Is SSE4.2 supported?</source>
          <target state="translated">SSE4.2가 지원됩니까?</target>
        </trans-unit>
        <trans-unit id="a2be34e3269af3486a23b7806de85c13596ee981" translate="yes" xml:space="preserve">
          <source>Is SSE4a supported?</source>
          <target state="translated">SSE4a가 지원됩니까?</target>
        </trans-unit>
        <trans-unit id="529c14236ce5d57c81f18ee3d3a4955d0294b830" translate="yes" xml:space="preserve">
          <source>Is SSSE3 supported?</source>
          <target state="translated">SSSE3가 지원됩니까?</target>
        </trans-unit>
        <trans-unit id="404210ae982e5f7c6d767bb288604a99c837412d" translate="yes" xml:space="preserve">
          <source>Is SYSENTER/SYSEXIT supported?</source>
          <target state="translated">SYSENTER / SYSEXIT가 지원됩니까?</target>
        </trans-unit>
        <trans-unit id="450d6103658425cd9504ee4df7c88ea3022b9390" translate="yes" xml:space="preserve">
          <source>Is VEX-Encoded AES supported</source>
          <target state="translated">VEX 인코딩 AES 지원</target>
        </trans-unit>
        <trans-unit id="090d249f369062f8bff47b9ddec54f12692fd4a6" translate="yes" xml:space="preserve">
          <source>Is cmov supported?</source>
          <target state="translated">cmov가 지원됩니까?</target>
        </trans-unit>
        <trans-unit id="4682b61ccc8c6c8dc42bb1758c22ede1faa7aa70" translate="yes" xml:space="preserve">
          <source>Is cmpxchg8b supported?</source>
          <target state="translated">cmpxchg8b가 지원됩니까?</target>
        </trans-unit>
        <trans-unit id="4c79a0ed65f9de836b7df77c8ebe47ee651df5f2" translate="yes" xml:space="preserve">
          <source>Is fxsave/fxrstor supported?</source>
          <target state="translated">fxsave / fxrstor가 지원됩니까?</target>
        </trans-unit>
        <trans-unit id="10bf6a2965400ad25296374bbb8440c96335239a" translate="yes" xml:space="preserve">
          <source>Is hyperthreading supported?</source>
          <target state="translated">하이퍼 스레딩이 지원됩니까?</target>
        </trans-unit>
        <trans-unit id="a5f2a790fe86ca51a7f46c97943c8a348c7f5979" translate="yes" xml:space="preserve">
          <source>Is pclmulqdq supported</source>
          <target state="translated">pclmulqdq가 지원됩니까?</target>
        </trans-unit>
        <trans-unit id="2a6a47b81fa80057015751ef0056cd96c0603472" translate="yes" xml:space="preserve">
          <source>Is rdrand supported</source>
          <target state="translated">드 랜드 지원</target>
        </trans-unit>
        <trans-unit id="6f50c3df0513611496a720e7e34cdb66b04a1e3a" translate="yes" xml:space="preserve">
          <source>Is rdseed supported</source>
          <target state="translated">rdseed 지원</target>
        </trans-unit>
        <trans-unit id="1b5795edb49e0d328ee0397e5dce20a3f8b369c8" translate="yes" xml:space="preserve">
          <source>Is rdtsc supported?</source>
          <target state="translated">rdtsc가 지원됩니까?</target>
        </trans-unit>
        <trans-unit id="dfd22e079be218467567ed6e211af022226073d8" translate="yes" xml:space="preserve">
          <source>Is the binary representation of x identical to y?</source>
          <target state="translated">x의 이진 표현은 y와 동일합니까?</target>
        </trans-unit>
        <trans-unit id="a87a317711c3473ef594a6e7226a2007eeb63603" translate="yes" xml:space="preserve">
          <source>Is this Object an error?</source>
          <target state="translated">이 개체가 오류입니까?</target>
        </trans-unit>
        <trans-unit id="c56d42e2850dbb730db38fb3fb842af85b06b699" translate="yes" xml:space="preserve">
          <source>Is this an IA64 (Itanium) processor?</source>
          <target state="translated">이 프로세서는 IA64 (Itanium) 프로세서입니까?</target>
        </trans-unit>
        <trans-unit id="590cbb39e0a9b8c9390941a2aa58bbc453391eef" translate="yes" xml:space="preserve">
          <source>Is this an Intel64 or AMD 64?</source>
          <target state="translated">이것이 Intel64 또는 AMD 64입니까?</target>
        </trans-unit>
        <trans-unit id="d0d49c2fad2d9f63ec74430d77ec2053e17a49b3" translate="yes" xml:space="preserve">
          <source>Is vpclmulqdq supported</source>
          <target state="translated">vpclmulqdq가 지원됩니까?</target>
        </trans-unit>
        <trans-unit id="08035875f56e0a7aaa6e8c7ee6e9504e25d6cf00" translate="yes" xml:space="preserve">
          <source>IsExpression</source>
          <target state="translated">IsExpression</target>
        </trans-unit>
        <trans-unit id="eee32f816f5a7cde2bef5f55991e6f12cf112eeb" translate="yes" xml:space="preserve">
          <source>IsExpression can evaluate the specified type speculatively, and even if it instantiates any symbols, they are normally unnecessary for the final executable. However, if those symbols leak to the actual code, compiler should remark them as non-speculative to generate their code and link to the final executable.</source>
          <target state="translated">IsExpression은 지정된 형식을 추측 적으로 평가할 수 있으며, 기호를 인스턴스화하더라도 최종 실행 파일에는 일반적으로 필요하지 않습니다. 그러나 이러한 기호가 실제 코드로 누출되는 경우 컴파일러는 코드를 생성하고 최종 실행 파일에 연결하기 위해 비추 론적이라고 표시해야합니다.</target>
        </trans-unit>
        <trans-unit id="49ab23d851863d880110f3e4fecbd30226e2ce4e" translate="yes" xml:space="preserve">
          <source>IsMarkedDg &lt;code&gt;isMarked&lt;/code&gt;</source>
          <target state="translated">IsMarkedDg &lt;code&gt;isMarked&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cb1dcbf5199bd4639373c8360fb756c6fa15a754" translate="yes" xml:space="preserve">
          <source>Issue an error if an attempt to call a disabled method is made</source>
          <target state="translated">비활성화 된 메서드를 호출하려고하면 오류가 발생합니다</target>
        </trans-unit>
        <trans-unit id="4d017c10e9874a730f28063522651ca1ebea765b" translate="yes" xml:space="preserve">
          <source>Issuer certificate</source>
          <target state="translated">발급자 인증서</target>
        </trans-unit>
        <trans-unit id="4fe343344c692492a360f8a89fee5b22e51d1c7a" translate="yes" xml:space="preserve">
          <source>Issuing individual checked operations is flexible and efficient but often tedious. The &lt;a href=&quot;#Checked&quot;&gt;&lt;code&gt;Checked&lt;/code&gt;&lt;/a&gt; facility offers encapsulated integral wrappers that do all checking internally and have configurable behavior upon erroneous results. For example, &lt;code&gt;Checked!int&lt;/code&gt; is a type that behaves like &lt;code&gt;int&lt;/code&gt; but aborts execution immediately whenever involved in an operation that produces the arithmetically wrong result. The accompanying convenience function &lt;a href=&quot;#checked&quot;&gt;&lt;code&gt;checked&lt;/code&gt;&lt;/a&gt; uses type deduction to convert a value &lt;code&gt;x&lt;/code&gt; of integral type &lt;code&gt;T&lt;/code&gt; to &lt;code&gt;Checked!T&lt;/code&gt; by means of &lt;code&gt;checked(x)&lt;/code&gt;. For example:</source>
          <target state="translated">개별 점검 작업을 수행하는 것은 유연하고 효율적이지만 종종 지루합니다. &lt;a href=&quot;#Checked&quot;&gt; &lt;code&gt;Checked&lt;/code&gt; &lt;/a&gt; 시설의 제공은 내부적으로 모든 검사를하고 잘못된 결과에 따라 구성 동작을 통합 래퍼를 캡슐화. 예를 들어, &lt;code&gt;Checked!int&lt;/code&gt; 같은 동작하는지 유형입니다 &lt;code&gt;int&lt;/code&gt; 하지만 중단 및 실행이 즉시마다 산술적으로 잘못된 결과를 생성하는 작업에 참여는. 첨부 편의 기능 &lt;a href=&quot;#checked&quot;&gt; &lt;code&gt;checked&lt;/code&gt; &lt;/a&gt; 값으로 변환하는 데 사용하는 형태 공제 &lt;code&gt;x&lt;/code&gt; 일체형의 &lt;code&gt;T&lt;/code&gt; 를 로 &lt;code&gt;Checked!T&lt;/code&gt; 에 의해 &lt;code&gt;checked(x)&lt;/code&gt; . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b6e2e0208dac0f7f4751f05b1125349dc8d7c5b3" translate="yes" xml:space="preserve">
          <source>It advances the input to the position following the conversion.</source>
          <target state="translated">변환 후의 위치로 입력을 진행시킵니다.</target>
        </trans-unit>
        <trans-unit id="46166dd58ab2730e4524ad59d57d2593327727bb" translate="yes" xml:space="preserve">
          <source>It also provides a faster, low level API working with data of size &lt;code&gt;Element.sizeof&lt;/code&gt;:</source>
          <target state="translated">또한 &lt;code&gt;Element.sizeof&lt;/code&gt; 크기의 데이터로 작업하는 더 빠르고 낮은 수준의 API를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="6d3cceeb2328306e2f02f11a51f27695f47f4e9b" translate="yes" xml:space="preserve">
          <source>It also provides number of templates that test for various range capabilities:</source>
          <target state="translated">또한 다양한 범위의 기능을 테스트하는 많은 템플릿을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="5bbf72a08a99011dd111dd6ad452e903cd2d15d9" translate="yes" xml:space="preserve">
          <source>It also works with &lt;code&gt;@property&lt;/code&gt; functions:</source>
          <target state="translated">&lt;code&gt;@property&lt;/code&gt; 함수 와도 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="388df630c47cc2e867f2d3350d1778d5f83b482f" translate="yes" xml:space="preserve">
          <source>It can be used to conditionally compile declarations, not just statements.</source>
          <target state="translated">명령문뿐만 아니라 선언을 조건부로 컴파일하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a01fcab203354384dc4d73ca3e1bd07777c3122" translate="yes" xml:space="preserve">
          <source>It can only be used once in a method declaration</source>
          <target state="translated">메소드 선언에서 한 번만 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="0dae2f02f995eb1175253988c98f27cbe75176d3" translate="yes" xml:space="preserve">
          <source>It cannot be attached to a method or constructor that is a template</source>
          <target state="translated">템플리트 인 메소드 또는 생성자에 첨부 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="0bbe25588da1b447488b6253a7ca8c0b345decd4" translate="yes" xml:space="preserve">
          <source>It cannot be the argument to &lt;a href=&quot;https://dlang.org/phobos/object.html#destroy&quot;&gt;&lt;code&gt;destroy&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://dlang.org/phobos/object.html#destroy&quot;&gt; &lt;code&gt;destroy&lt;/code&gt; &lt;/a&gt; 하는 주장이 될 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="8b94459fe2cd15aac6dbdf1ba866c322026a497f" translate="yes" xml:space="preserve">
          <source>It defines the bidirectional and forward range primitives for arrays: &lt;a href=&quot;#empty&quot;&gt;&lt;code&gt;empty&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#front&quot;&gt;&lt;code&gt;front&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#back&quot;&gt;&lt;code&gt;back&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#popFront&quot;&gt;&lt;code&gt;popFront&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#popBack&quot;&gt;&lt;code&gt;popBack&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#save&quot;&gt;&lt;code&gt;save&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">배열의 양방향 및 순방향 범위 기본 요소를 정의합니다 ( &lt;a href=&quot;#empty&quot;&gt; &lt;code&gt;empty&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#front&quot;&gt; &lt;code&gt;front&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#back&quot;&gt; &lt;code&gt;back&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#popFront&quot;&gt; &lt;code&gt;popFront&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#popBack&quot;&gt; &lt;code&gt;popBack&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#save&quot;&gt; &lt;code&gt;save&lt;/code&gt; )&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="65ecf79245a02b6d2395f79fbb54723afe4759a9" translate="yes" xml:space="preserve">
          <source>It derives from the interface &lt;code&gt;core.stdc.windows.com.IUnknown&lt;/code&gt;.</source>
          <target state="translated">인터페이스 &lt;code&gt;core.stdc.windows.com.IUnknown&lt;/code&gt; 인터페이스에서 파생됩니다 .</target>
        </trans-unit>
        <trans-unit id="b7a236332866cc1e66837407aa52f7caefef2e68" translate="yes" xml:space="preserve">
          <source>It does keep: live connections, the Session ID cache, the DNS cache and the cookies.</source>
          <target state="translated">라이브 연결, 세션 ID 캐시, DNS 캐시 및 쿠키를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="ab575c8162460ca1f250ddf0805e589cdd4d4f98" translate="yes" xml:space="preserve">
          <source>It does not exhibit undefined behavior for any input. It returns either a valid pointer, which is safe, or &lt;code&gt;null&lt;/code&gt; which is also safe. It returns a pointer to a fresh allocation, so it cannot introduce any unsafe aliasing.</source>
          <target state="translated">입력에 대해 정의되지 않은 동작을 나타내지 않습니다. 안전한 유효한 포인터 또는 안전한 &lt;code&gt;null&lt;/code&gt; 을 반환합니다 . 새로운 할당에 대한 포인터를 반환하므로 안전하지 않은 앨리어싱을 도입 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="dd4fef0b32a7281d59a31a40d6f87fe5bfa58814" translate="yes" xml:space="preserve">
          <source>It does not introduce a new scope even if &lt;code&gt;{ }&lt;/code&gt; are used for conditionally compiled statements.</source>
          <target state="translated">&lt;code&gt;{ }&lt;/code&gt; 가 조건부 컴파일 된 명령문에 사용 되더라도 새로운 범위를 도입하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="a5f6a69aa258b6687ed9d04070e059ea5562bf0a" translate="yes" xml:space="preserve">
          <source>It does not repeat information that the compiler already knows from parsing the code.</source>
          <target state="translated">컴파일러가 코드 구문 분석에서 이미 알고있는 정보는 반복하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7398e9c5d59f69e46f788c84807092237aa5e4d5" translate="yes" xml:space="preserve">
          <source>It does not throw if it could not convert the entire input.</source>
          <target state="translated">전체 입력을 변환 할 수없는 경우 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2873a218fbe5af0054d62beddeb0e65fcfb61635" translate="yes" xml:space="preserve">
          <source>It doesn't rely on embedded HTML, as such will impede extraction and formatting for other purposes.</source>
          <target state="translated">임베디드 HTML에 의존하지 않으므로 다른 목적으로 추출 및 서식을 방해 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a1aba479bf876b78d7763f04b36ad2a837b806ed" translate="yes" xml:space="preserve">
          <source>It eliminates the need for IDL (interface description language) as a separate language.</source>
          <target state="translated">별도의 언어로 IDL (인터페이스 설명 언어)이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9be52d2dd0c55abff440ef5dc05f4f1413d2dc2c" translate="yes" xml:space="preserve">
          <source>It fits in EAX.</source>
          <target state="translated">EAX에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="5c9e2828459632652d41e10b6eaced3e8290b5c9" translate="yes" xml:space="preserve">
          <source>It indicates if a statement does transfer control to another block. A block is a sequence of statements enclosed in { }</source>
          <target state="translated">명령문이 제어를 다른 블록으로 전송하는지 여부를 나타냅니다. 블록은 {}로 묶인 일련의 명령문입니다.</target>
        </trans-unit>
        <trans-unit id="b4f712b66715ddaa764c3d26a22ac83adf4c4dc7" translate="yes" xml:space="preserve">
          <source>It is acceptable for an implementation to store bit flags into pointer values and GC-managed memory blocks, so long as such a trick is not visible to the application. In practice, this means that only a stop-the-world collector can do this.</source>
          <target state="translated">구현에서 비트 플래그를 포인터 값과 GC 관리 메모리 블록에 저장하는 것은 허용되지만, 그러한 트릭이 응용 프로그램에 표시되지 않는 한 가능합니다. 실제로 이는 세계 일류 수집가 만이이를 수행 할 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="6213c9975eabd46633dd5a1abb7787690a6d9654" translate="yes" xml:space="preserve">
          <source>It is also possible to &lt;code&gt;override&lt;/code&gt; the three methods &lt;code&gt;beginLogMsg&lt;/code&gt;, &lt;code&gt;logMsgPart&lt;/code&gt; and &lt;code&gt;finishLogMsg&lt;/code&gt; together, this option gives more flexibility.</source>
          <target state="translated">&lt;code&gt;beginLogMsg&lt;/code&gt; , &lt;code&gt;logMsgPart&lt;/code&gt; 및 &lt;code&gt;finishLogMsg&lt;/code&gt; 세 가지 메소드 를 &lt;code&gt;override&lt;/code&gt; 쓸 수도 있습니다.이 옵션을 사용하면 유연성이 향상됩니다.</target>
        </trans-unit>
        <trans-unit id="62c19d777ce9c9b0fe6e64b8266c59dbe78a3247" translate="yes" xml:space="preserve">
          <source>It is also possible to indirectly interface with C++ code, either through a &lt;a href=&quot;interfacetoc&quot;&gt;C interface&lt;/a&gt; or a COM interface.</source>
          <target state="translated">&lt;a href=&quot;interfacetoc&quot;&gt;C 인터페이스&lt;/a&gt; 또는 COM 인터페이스를 통해 C ++ 코드와 간접적으로 인터페이스 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d898d765860a5d45edda7c7ed8509568c1f68566" translate="yes" xml:space="preserve">
          <source>It is an error if &lt;a href=&quot;expression#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression&lt;/i&gt;&lt;/a&gt; cannot be implicitly converted to a boolean type or if it cannot be evaluated at compile time.</source>
          <target state="translated">&lt;a href=&quot;expression#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression&lt;/i&gt;&lt;/a&gt; 을 내재적으로 부울 유형으로 변환 할 수 없거나 컴파일시 평가할 수없는 경우 오류 입니다.</target>
        </trans-unit>
        <trans-unit id="86e5855ead30ccc2c8c56869cbcf6e5f74be6875" translate="yes" xml:space="preserve">
          <source>It is an error if any</source>
          <target state="translated">있다면 오류입니다</target>
        </trans-unit>
        <trans-unit id="a81c091005be4792f067f57e1989fc7c8d13b625" translate="yes" xml:space="preserve">
          <source>It is an error to compare objects if one is &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">객체가 &lt;code&gt;null&lt;/code&gt; 인 경우 객체를 비교하는 것은 오류 입니다.</target>
        </trans-unit>
        <trans-unit id="50b2fd8434663e2c4ccea539ac2a01804fab3bbd" translate="yes" xml:space="preserve">
          <source>It is an error to declare a local variable that hides another local variable in the same function:</source>
          <target state="translated">동일한 함수에서 다른 로컬 변수를 숨기는 로컬 변수를 선언하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="deced31ce7ffb700a549b08afe6a6138a69db040" translate="yes" xml:space="preserve">
          <source>It is an error to have a local variable and a label with the same name.</source>
          <target state="translated">로컬 변수와 이름이 같은 레이블을 갖는 것은 오류입니다.</target>
        </trans-unit>
        <trans-unit id="b508914e98b3adb1d20ab50fa10434c25d029458" translate="yes" xml:space="preserve">
          <source>It is an error to have one operand be signed and the other unsigned for a &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;=&lt;/code&gt; expression. Use casts to make both operands signed or both operands unsigned.</source>
          <target state="translated">하나의 피연산자가 서명되고 다른 피연산자는 &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;code&gt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;&amp;gt;&lt;/code&gt; &lt;code&gt;=&lt;/code&gt; 표현식에 대해 부호가없는 것은 오류 입니다. 캐스트를 사용하여 두 피연산자 모두 또는 부호없는 피연산자를 모두 부호없이 만드십시오.</target>
        </trans-unit>
        <trans-unit id="f0e09315dbb83014f54364159107933f95171232" translate="yes" xml:space="preserve">
          <source>It is an error to index an array with an index that is less than 0 or greater than or equal to the array length. If an index is out of bounds, a RangeError exception is raised if detected at runtime, and an error if detected at compile time. A program may not rely on array bounds checking happening, for example, the following program is incorrect:</source>
          <target state="translated">배열 길이가 0보다 작거나 같은 인덱스를 사용하여 배열을 인덱싱하는 것은 오류입니다. 인덱스가 범위를 벗어난 경우 런타임에 감지되면 RangeError 예외가 발생하고 컴파일 타임에 감지되면 오류가 발생합니다. 프로그램이 발생하는 배열 범위 검사에 의존하지 않을 수 있습니다 (예 : 다음 프로그램이 올바르지 않음).</target>
        </trans-unit>
        <trans-unit id="f64a85acc1469fbd56318c719228c9c1fe16bf9c" translate="yes" xml:space="preserve">
          <source>It is an error to return the address of or a reference to a local variable.</source>
          <target state="translated">로컬 변수의 주소 또는 참조를 반환하는 것은 오류입니다.</target>
        </trans-unit>
        <trans-unit id="b4576fb929afa6bbf00d340772ed152adcae3cb1" translate="yes" xml:space="preserve">
          <source>It is an error to use a local variable without first assigning it a value. The implementation may not always be able to detect these cases. Other language compilers sometimes issue a warning for this, but since it is always a bug, it should be an error.</source>
          <target state="translated">먼저 값을 할당하지 않고 지역 변수를 사용하는 것은 오류입니다. 구현시 항상 이러한 경우를 감지하지 못할 수도 있습니다. 다른 언어 컴파일러는 때때로 이것에 대해 경고를하지만, 항상 버그이기 때문에 오류가되어야합니다.</target>
        </trans-unit>
        <trans-unit id="1caf8aa0590016aadf8cff449e680fd2d8713321" translate="yes" xml:space="preserve">
          <source>It is defined to be exactly the reverse order that static construction was performed in. Static destructors for individual modules will only be run if the corresponding static constructor successfully completed.</source>
          <target state="translated">정적 구성이 수행 된 순서와 정확히 반대로 정의됩니다. 개별 모듈의 정적 소멸자는 해당 정적 생성자가 성공적으로 완료된 경우에만 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="2c2f3bba7f5994912f6b95d05cb1814084516245" translate="yes" xml:space="preserve">
          <source>It is easy to make the error handling source code look good.</source>
          <target state="translated">오류 처리 소스 코드를보기 좋게 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d6ed05c87a248603343b54bb16aa1fab9bfe8f53" translate="yes" xml:space="preserve">
          <source>It is here to allow the deprecated behavior from the original algorithm until people have fixed their code.</source>
          <target state="translated">사람들이 코드를 고칠 때까지 원래 알고리즘에서 더 이상 사용되지 않는 동작을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="401996678962e7e20129e6958a7d5a0d314109af" translate="yes" xml:space="preserve">
          <source>It is illegal for a</source>
          <target state="translated">불법입니다</target>
        </trans-unit>
        <trans-unit id="37d2d71b2b05147b31590276dc23d6c43bb3d76c" translate="yes" xml:space="preserve">
          <source>It is illegal for constructors to mutually call each other.</source>
          <target state="translated">생성자가 서로를 호출하는 것은 불법입니다.</target>
        </trans-unit>
        <trans-unit id="2b7e7cafd673ed4d2e6ef523c1c9b32587567990" translate="yes" xml:space="preserve">
          <source>It is illegal to forward reference a debug specification:</source>
          <target state="translated">디버그 사양을 전달 참조하는 것은 불법입니다.</target>
        </trans-unit>
        <trans-unit id="f53c060570ada118f69ba3973c4ac1d18651ca16" translate="yes" xml:space="preserve">
          <source>It is illegal to refer to &lt;code&gt;this&lt;/code&gt; implicitly or explicitly prior to making a delegate constructor call.</source>
          <target state="translated">델리게이트 생성자 호출을하기 전에 &lt;code&gt;this&lt;/code&gt; 암시 적으로 또는 명시 적으로 언급하는 것은 불법 입니다.</target>
        </trans-unit>
        <trans-unit id="c3a1d31a8a612fca4298b4ba24a642e4106f58bc" translate="yes" xml:space="preserve">
          <source>It is illegal to refer to &lt;code&gt;this&lt;/code&gt; implicitly or explicitly prior to making a delegating constructor call.</source>
          <target state="translated">위임 생성자를 호출하기 전에 &lt;code&gt;this&lt;/code&gt; 암시 적으로 또는 명시 적으로 참조하는 것은 불법 입니다.</target>
        </trans-unit>
        <trans-unit id="c179728399bb4a33e4e07c739bc7e79b3958a176" translate="yes" xml:space="preserve">
          <source>It is implemented as a compiler intrinsic.</source>
          <target state="translated">컴파일러 내장으로 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="335e107a42af5a98628c149f6e1b4ca0b49e01e5" translate="yes" xml:space="preserve">
          <source>It is important to make sure that, if &lt;code&gt;opApply&lt;/code&gt; catches any exceptions, that those exceptions did not originate from the delegate passed to</source>
          <target state="translated">&lt;code&gt;opApply&lt;/code&gt; 가 예외를 발견하면 해당 예외가 전달 된 대리자에서 시작되지 않았 는지 확인하는 것이 중요 합니다.</target>
        </trans-unit>
        <trans-unit id="79663ac4e329be90782f60edf1e6177dca459550" translate="yes" xml:space="preserve">
          <source>It is important to note that as the resultant range is evaluated lazily, in the case of the version of &lt;code&gt;tee&lt;/code&gt; that takes a function, the function will not actually be executed until the range is &quot;walked&quot; using functions that evaluate ranges, such as &lt;a href=&quot;std_array#array&quot;&gt;&lt;code&gt;std.array.array&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;std_algorithm_iteration#fold&quot;&gt;&lt;code&gt;std.algorithm.iteration.fold&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">결과 범위가 느리게 평가 되므로 함수를 사용하는 &lt;code&gt;tee&lt;/code&gt; 버전의 경우 &lt;a href=&quot;std_array#array&quot;&gt; &lt;code&gt;std.array.array&lt;/code&gt; &lt;/a&gt; 와 같은 범위를 평가하는 함수를 사용하여 범위를 &quot;걸을&quot;때까지 함수가 실제로 실행되지 않습니다. .array.array 또는 &lt;a href=&quot;std_algorithm_iteration#fold&quot;&gt; &lt;code&gt;std.algorithm.iteration.fold&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cd820e0e37cf31d63e1d31e908c7138e4dab72e2" translate="yes" xml:space="preserve">
          <source>It is important to use the right version identifier for the right purpose. For example, use the vendor identifier when using a vendor specific feature. Use the operating system identifier when using an operating system specific feature, etc.</source>
          <target state="translated">올바른 목적으로 올바른 버전 식별자를 사용하는 것이 중요합니다. 예를 들어 공급 업체별 기능을 사용할 때는 공급 업체 식별자를 사용하십시오. 운영 체제 별 기능 등을 사용할 때는 운영 체제 식별자를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f2a8e8ef94cccc304c27c70467bf612cabf2c765" translate="yes" xml:space="preserve">
          <source>It is inevitable that the D language will evolve over time. Therefore, the version identifier namespace beginning with &quot;D_&quot; is reserved for identifiers indicating D language specification or new feature conformance. Further, all identifiers derived from the ones listed above by appending any character(s) are reserved. This means that e.g. &lt;code&gt;ARM_foo&lt;/code&gt; and &lt;code&gt;Windows_bar&lt;/code&gt; are reserved while &lt;code&gt;foo_ARM&lt;/code&gt; and &lt;code&gt;bar_Windows&lt;/code&gt; are not.</source>
          <target state="translated">D 언어가 시간이 지남에 따라 진화한다는 것은 불가피합니다. 따라서 &quot;D_&quot;로 시작하는 버전 식별자 네임 스페이스는 D 언어 사양 또는 새로운 기능 준수를 나타내는 식별자 용으로 예약되어 있습니다. 또한, 임의의 문자 (들)를 추가함으로써 상기 열거 된 것으로부터 유도 된 모든 식별자는 예약되어있다. 즉, 예를 들어 &lt;code&gt;ARM_foo&lt;/code&gt; 및 &lt;code&gt;Windows_bar&lt;/code&gt; 는 예약되어 있지만 &lt;code&gt;foo_ARM&lt;/code&gt; 및 &lt;code&gt;bar_Windows&lt;/code&gt; 는 예약되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="87b18dd6b84ff4211bbe466a6c57cc9ae711b259" translate="yes" xml:space="preserve">
          <source>It is lowered to:</source>
          <target state="translated">다음과 같이 낮아집니다.</target>
        </trans-unit>
        <trans-unit id="f91d0be00faa70d257f22e2edf4d36bee26e53e0" translate="yes" xml:space="preserve">
          <source>It is not a 3 byte struct.</source>
          <target state="translated">3 바이트 구조체가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="168bb789a8929c7fb4c3b7215efb1856903be685" translate="yes" xml:space="preserve">
          <source>It is not a floating point type.</source>
          <target state="translated">부동 소수점 유형이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="19fdb6fcd666a00fa90a8ed40bb00013c2391043" translate="yes" xml:space="preserve">
          <source>It is not always obvious when the GC allocates memory, which in turn can trigger a collection, so the program can pause unexpectedly.</source>
          <target state="translated">GC가 메모리를 할당 할 때 항상 분명하지는 않으며, 이로 인해 콜렉션이 트리거 될 수 있으므로 프로그램이 예기치 않게 일시 정지 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7cac6b46e927506f607254cff1ed6929147fa588" translate="yes" xml:space="preserve">
          <source>It is not an error if the return type does not contain any indirections.</source>
          <target state="translated">리턴 유형에 간접 지시 사항이없는 경우 오류가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="981cc7a3cecab94e0dd1f8ddc96a87527d95e530" translate="yes" xml:space="preserve">
          <source>It is not necessary to do this inside a code section, or if the special character is not immediately followed by a # or a letter.</source>
          <target state="translated">코드 섹션 내에서 또는 특수 문자 바로 뒤에 # 또는 문자가 오는 경우에는이 작업을 수행 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="6319193259ecd329b1ff6f0a8e1c2a9fd8f24dd7" translate="yes" xml:space="preserve">
          <source>It is not possible to have both &lt;code&gt;return ref&lt;/code&gt; and &lt;code&gt;return scope&lt;/code&gt; semantics for the same parameter.</source>
          <target state="translated">동일한 매개 변수에 대해 &lt;code&gt;return ref&lt;/code&gt; 및 &lt;code&gt;return scope&lt;/code&gt; 시맨틱을 둘 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="e23f668bad211d08e2c969e706fb24d5b0e785ca" translate="yes" xml:space="preserve">
          <source>It is not possible to rename a file across different mount points or drives. On POSIX, the operation is atomic. That means, if &lt;code&gt;to&lt;/code&gt; already exists there will be no time period during the operation where &lt;code&gt;to&lt;/code&gt; is missing. See &lt;a href=&quot;http://man7.org/linux/man-pages/man2/rename.2.html&quot;&gt;manpage for rename&lt;/a&gt; for more details.</source>
          <target state="translated">다른 마운트 지점이나 드라이브에서 파일 이름을 바꿀 수 없습니다. POSIX에서 작업은 원자 적입니다. 그 말, 경우 &lt;code&gt;to&lt;/code&gt; 이미 작동시에는 시간이 없을 것입니다 존재 &lt;code&gt;to&lt;/code&gt; 없습니다. 자세한 내용 &lt;a href=&quot;http://man7.org/linux/man-pages/man2/rename.2.html&quot;&gt;은 이름 변경에&lt;/a&gt; 대한 맨 페이지를 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="443f05c094b69d1507e35079eeb79f6782e9920f" translate="yes" xml:space="preserve">
          <source>It is often necessary to deprecate a feature in a library, yet retain it for backwards compatibility. Such declarations can be marked as &lt;code&gt;deprecated&lt;/code&gt;, which means that the compiler can be instructed to produce an error if any code refers to deprecated declarations:</source>
          <target state="translated">라이브러리에서 기능을 폐기해야하지만 이전 버전과의 호환성을 위해 유지해야합니다. 이러한 선언은 &lt;code&gt;deprecated&lt;/code&gt; 로 표시 될 수 있습니다. 즉, 코드에서 사용되지 않는 선언을 참조하는 경우 컴파일러에서 오류를 생성하도록 지시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="899360132ed9309c950103047c7e2c814b318ec0" translate="yes" xml:space="preserve">
          <source>It is similar to &lt;a href=&quot;#byLine&quot;&gt;&lt;code&gt;byLine&lt;/code&gt;&lt;/a&gt; and uses &lt;a href=&quot;std_format#formattedRead&quot;&gt;format&lt;/a&gt; under the hood.</source>
          <target state="translated">&lt;a href=&quot;#byLine&quot;&gt; &lt;code&gt;byLine&lt;/code&gt; &lt;/a&gt; 과 유사 하며 후드 아래에서 &lt;a href=&quot;std_format#formattedRead&quot;&gt;형식&lt;/a&gt; 을 사용 합니다 .</target>
        </trans-unit>
        <trans-unit id="717aec823e7fb6c544e08d1714d73ef54e5ff0b7" translate="yes" xml:space="preserve">
          <source>It is sometimes useful to get or set the 16 bytes of a UUID directly.</source>
          <target state="translated">UUID의 16 바이트를 직접 가져 오거나 설정하는 것이 유용한 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="d9604c47d97361773acea3965fa6498d863d32be" translate="yes" xml:space="preserve">
          <source>It is standardized - consistent usage makes it more useful.</source>
          <target state="translated">표준화되어 있으며 일관된 사용으로보다 유용합니다.</target>
        </trans-unit>
        <trans-unit id="0ea1205f3456f768018243f6d5512a314f402d18" translate="yes" xml:space="preserve">
          <source>It is straightforward to link C functions and libraries into D programs. But linking D functions and libraries into C programs is not straightforward.</source>
          <target state="translated">C 함수와 라이브러리를 D 프로그램에 연결하는 것은 간단합니다. 그러나 D 함수와 라이브러리를 C 프로그램에 연결하는 것은 간단하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="700ae48bba8932b3ce97ed7ab816d7e993a4eec8" translate="yes" xml:space="preserve">
          <source>It is therefore recommended to always construct containers using &lt;a href=&quot;std_container_util#make&quot;&gt;&lt;code&gt;std.container.util.make&lt;/code&gt;&lt;/a&gt;.  This is in fact necessary to put containers into another container. For example, to construct an &lt;code&gt;Array&lt;/code&gt; of ten empty &lt;code&gt;Array&lt;/code&gt;s, use the following that calls &lt;code&gt;make&lt;/code&gt; ten times.</source>
          <target state="translated">따라서 항상 &lt;a href=&quot;std_container_util#make&quot;&gt; &lt;code&gt;std.container.util.make&lt;/code&gt; 를&lt;/a&gt; 사용하여 컨테이너를 구성하는 것이 좋습니다 . 이것은 실제로 컨테이너를 다른 컨테이너에 넣는 데 필요합니다. 예를 들어, 구성하는 &lt;code&gt;Array&lt;/code&gt; 열 빈의 &lt;code&gt;Array&lt;/code&gt; ,의를 호출하는 다음 사용 &lt;code&gt;make&lt;/code&gt; 열 번.</target>
        </trans-unit>
        <trans-unit id="c0f045f8d032f9691206ca37e7e3ca551f6091bd" translate="yes" xml:space="preserve">
          <source>It is used when representing a duration of time - such as how long to sleep with &lt;a href=&quot;core_thread#Thread.sleep&quot;&gt;&lt;code&gt;core.thread.Thread.sleep&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;core_thread#Thread.sleep&quot;&gt; &lt;code&gt;core.thread.Thread.sleep&lt;/code&gt; &lt;/a&gt; 과 같은 잠자기 시간과 같은 지속 시간을 나타낼 때 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="4ee87bcd4e29687a5da201987c5dfb2a1c883353" translate="yes" xml:space="preserve">
          <source>It is useful for system programming and interfacing with C/C++, for example to allow for initialization of the runtime when loading a DSO, or as a simple replacement for &lt;code&gt;shared static this&lt;/code&gt; in &lt;a href=&quot;betterc&quot;&gt;betterC mode&lt;/a&gt;.</source>
          <target state="translated">시스템 프로그래밍 및 C / C ++와의 인터페이스에 유용합니다. 예를 들어 DSO를로드 할 때 런타임 초기화를 허용하거나 &lt;a href=&quot;betterc&quot;&gt;betterC 모드&lt;/a&gt; 에서 &lt;code&gt;shared static this&lt;/code&gt; 를 간단하게 대체 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d17dae53faa2b792c553146cb98e6c93618b8a4c" translate="yes" xml:space="preserve">
          <source>It looks good as embedded documentation, not just after it is extracted and processed.</source>
          <target state="translated">압축을 풀고 처리 한 직후가 아니라 내장 문서처럼보기 좋습니다.</target>
        </trans-unit>
        <trans-unit id="2f3af10aa872e5f155c2078162ede3e60918478c" translate="yes" xml:space="preserve">
          <source>It may seem like too small of a difference in time for the attacker to notice, but security researchers have shown that differences as small as &lt;a href=&quot;http://www.cs.rice.edu/~dwallach/pub/crosby-timing2009.pdf&quot;&gt; 20&amp;micro;s can be reliably distinguished&lt;/a&gt; even with network inconsistencies.</source>
          <target state="translated">공격자가 알아 차리는 데 시간 차이가 너무 작은 것처럼 보이지만 보안 연구원들은 네트워크 불일치에서도 &lt;a href=&quot;http://www.cs.rice.edu/~dwallach/pub/crosby-timing2009.pdf&quot;&gt;20&amp;micro;s&lt;/a&gt; 정도의 작은 차이를 확실하게 구별 할 수 있음 을 보여주었습니다 .</target>
        </trans-unit>
        <trans-unit id="e6bd568b36725af76c85e86c49755d1465281c06" translate="yes" xml:space="preserve">
          <source>It must be evaluatable at compile time.</source>
          <target state="translated">컴파일 타임에 평가할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="69ae13c3dc07d0583f5f9b4087b39b94ed079ad6" translate="yes" xml:space="preserve">
          <source>It must use the same tokens as the D language uses.</source>
          <target state="translated">D 언어와 동일한 토큰을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="849081081f66a4a05cbf4ef99fbb6b7ad19734c6" translate="yes" xml:space="preserve">
          <source>It only works with character ranges as input.</source>
          <target state="translated">문자 범위에서만 입력으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="26c52ead977622939ef1b1062f122f932ed614a0" translate="yes" xml:space="preserve">
          <source>It provides access to various aspects of the module. It is not generated for betterC.</source>
          <target state="translated">모듈의 다양한 측면에 대한 액세스를 제공합니다. betterC에 대해서는 생성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f97c61fa3add53b120631d892e86b2c2046852a3" translate="yes" xml:space="preserve">
          <source>It provides basic range functionality by defining several templates for testing whether a given object is a range, and what kind of range it is:</source>
          <target state="translated">주어진 객체가 범위인지, 그리고 어떤 종류의 범위인지 테스트하기 위해 몇 가지 템플릿을 정의하여 기본 범위 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="ad6aacf59fb942f6e1cdc563ab119d5d18d3e55f" translate="yes" xml:space="preserve">
          <source>It provides more information to the compiler, enabling more error checking and possibly better code generation.</source>
          <target state="translated">컴파일러에 더 많은 정보를 제공하여 더 많은 오류 검사 및 코드 생성 가능성을 높일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ba24c42088804a0d4be1a3309025dbeb98b12af" translate="yes" xml:space="preserve">
          <source>It should be possible for the user to use Doxygen or other documentation extractor if desired.</source>
          <target state="translated">원하는 경우 사용자가 Doxygen 또는 기타 문서 추출기를 사용할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="093b315d1b92cd8c4da60adb8a7239b6a8739b1d" translate="yes" xml:space="preserve">
          <source>It should look and feel different from code, so it won't be visually confused with code.</source>
          <target state="translated">코드와 모양과 느낌이 다르므로 코드와 시각적으로 혼동되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ab78acfffc9bf5190ce6cb7b40dbee5c908a5208" translate="yes" xml:space="preserve">
          <source>It takes the input by reference. (This means that rvalues - such as string literals - are not accepted: use &lt;code&gt;to&lt;/code&gt; instead.)</source>
          <target state="translated">참조로 입력을받습니다. (이 방법은 우변 있음 - 이러한 문자열 리터럴로는 - 허용되지 않습니다 : 사용 &lt;code&gt;to&lt;/code&gt; 대신.)</target>
        </trans-unit>
        <trans-unit id="e10cbd22ba1e750ba124936549407411b37b8cea" translate="yes" xml:space="preserve">
          <source>It takes three forms:</source>
          <target state="translated">세 가지 형태가 있습니다.</target>
        </trans-unit>
        <trans-unit id="86760b7be00c051b6d56dcf51cea817312c47f73" translate="yes" xml:space="preserve">
          <source>It takes two forms:</source>
          <target state="translated">두 가지 형태가 있습니다.</target>
        </trans-unit>
        <trans-unit id="050370d910aa58f3109ec31e86d6b4499d187cdf" translate="yes" xml:space="preserve">
          <source>It uses well defined standard rules of property name lookup. This includes fuzzy matching of names, so that 'White_Space', 'white-SpAce' and 'whitespace' are all considered equal and yield the same set of white space &lt;a href=&quot;#Character&quot;&gt;characters&lt;/a&gt;.</source>
          <target state="translated">잘 정의 된 속성 이름 조회 표준 규칙을 사용합니다. 여기에는 이름의 퍼지 일치가 포함되므로 'White_Space', 'white-SpAce'및 'whitespace'는 모두 동일하게 간주되며 동일한 공백 &lt;a href=&quot;#Character&quot;&gt;문자&lt;/a&gt; 세트를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="93a7b2f1dac61a8d7598e3760cd8188b02968b69" translate="yes" xml:space="preserve">
          <source>It will be a &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward range&lt;/a&gt; if the underlying data source is at least a forward range.</source>
          <target state="translated">그것은 것이다 &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;전방 영역&lt;/a&gt; 내부 데이터 소스는 적어도 전진 레인지이면.</target>
        </trans-unit>
        <trans-unit id="bd4418738e6a8629325161d7af1adb0f490b4209" translate="yes" xml:space="preserve">
          <source>It will not detect attempts to dereference &lt;code&gt;null&lt;/code&gt; pointers or possibly &lt;code&gt;null&lt;/code&gt; pointers. This is unworkable because there is no current method of annotating a type as a non-&lt;code&gt;null&lt;/code&gt; pointer.</source>
          <target state="translated">그것은 역 참조 시도 검색하지 않습니다 &lt;code&gt;null&lt;/code&gt; 포인터 또는 아마도 &lt;code&gt;null&lt;/code&gt; 포인터를. 현재 유형을 &lt;code&gt;null&lt;/code&gt; 이 아닌 포인터 로 주석 처리하는 방법이 없기 때문에 이것은 작동하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="5ade996eab3bb94cd2a7d5f8def981c1ae053558" translate="yes" xml:space="preserve">
          <source>It's also possible to &lt;code&gt;put&lt;/code&gt; any width strings or characters into narrow strings -- put does the conversion for you.  Note that putting the same width character as the target buffer type is &lt;code&gt;nothrow&lt;/code&gt;, but transcoding can throw a &lt;a href=&quot;std_utf#UTFException&quot;&gt;&lt;code&gt;std.utf.UTFException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">그것은 수도 &lt;code&gt;put&lt;/code&gt; 좁은 문자열로 어떤 폭 문자열이나 문자 - 풋은 당신을 위해 변환을 수행합니다. 주 목표 버퍼 유형으로 같은 폭 문자를 넣어하는 것을 &lt;code&gt;nothrow&lt;/code&gt; 하지만 트랜스 코딩이 던질 수 &lt;a href=&quot;std_utf#UTFException&quot;&gt; &lt;code&gt;std.utf.UTFException&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="15967cde9e56b07a7f1c26d7a69e1a075aff9a00" translate="yes" xml:space="preserve">
          <source>It's based on existing D comment forms, so it is completely independent of parsers only interested in D code.</source>
          <target state="translated">기존 D 주석 양식을 기반으로하므로 D 코드에만 관심있는 파서와 완전히 독립적입니다.</target>
        </trans-unit>
        <trans-unit id="df30e895e5cea990b692a026e7012b1b8ed9990f" translate="yes" xml:space="preserve">
          <source>It's easy and natural to write, i.e. minimal reliance on &amp;lt;tags&amp;gt; and other clumsy forms one would never see in a finished document.</source>
          <target state="translated">작성하기 쉽고 자연 스럽습니다. 즉, &amp;lt;tags&amp;gt; 및 완성 된 문서에서는 결코 볼 수없는 다른 서투른 형태에 대한 최소한의 의존입니다.</target>
        </trans-unit>
        <trans-unit id="90363d2d1fd187921f9df756c4f8841ea45cbd8c" translate="yes" xml:space="preserve">
          <source>It's good software engineering practice to minimize gratuitous portability problems in the code. Techniques to minimize potential portability problems are:</source>
          <target state="translated">코드에서 불필요한 이식성 문제를 최소화하는 것은 좋은 소프트웨어 엔지니어링 사례입니다. 잠재적 인 이식성 문제를 최소화하는 기술은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="676010a0cf026e4e46adb9fc97725347e3cf4b56" translate="yes" xml:space="preserve">
          <source>It's illegal to move a class instance even if you are sure there are no pointers to it. As such, it is illegal to move a scoped object.</source>
          <target state="translated">포인터가없는 경우에도 클래스 인스턴스를 이동하는 것은 불법입니다. 따라서 범위가 지정된 개체를 이동하는 것은 불법입니다.</target>
        </trans-unit>
        <trans-unit id="1d0ecd13133638bfea893649adf9f413f5146027" translate="yes" xml:space="preserve">
          <source>It's illegal to shift by the same or more bits than the size of the quantity being shifted:</source>
          <target state="translated">시프트되는 수량의 크기와 같거나 더 많은 비트만큼 시프트하는 것은 불법입니다.</target>
        </trans-unit>
        <trans-unit id="b5899aa25cbeb84be446d7f611f383682e9adef5" translate="yes" xml:space="preserve">
          <source>It's impossible to know from CommaExp.semantic if the result will be used, hence when there is a result (type != void), a deprecation message is always emitted. However, some construct can produce a result but won't use it (ExpStatement and for loop increment). Those should call this function to prevent unwanted deprecations to be emitted.</source>
          <target state="translated">결과가 사용되는지 CommaExp.semantic에서 알 수 없으므로 결과가 (type! = void) 있으면 사용 중단 메시지가 항상 생성됩니다. 그러나 일부 구문은 결과를 생성 할 수 있지만 사용하지는 않습니다 (ExpStatement 및 for for 루프 증가). 원하지 않는 지원 중단이 발생하지 않도록이 기능을 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="87a902f7796c154f6adbb449196d8425bb687de6" translate="yes" xml:space="preserve">
          <source>It's not allowed to mark an overridden method with the attributes &lt;a href=&quot;attribute#disable&quot;&gt;&lt;code&gt;@disable&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;attribute#deprecated&quot;&gt;&lt;code&gt;deprecated&lt;/code&gt;&lt;/a&gt;. To stop the compilation or to output the deprecation message, the compiler must be able to determine the target of the call, which can't be guaranteed when it is virtual.</source>
          <target state="translated">&lt;a href=&quot;attribute#disable&quot;&gt; &lt;code&gt;@disable&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;attribute#deprecated&quot;&gt; &lt;code&gt;deprecated&lt;/code&gt; &lt;/a&gt; 속성으로 재정의 된 메소드를 표시 할 수 없습니다 . 컴파일을 중지하거나 더 이상 사용되지 않는 메시지를 출력하려면 컴파일러가 호출 대상을 확인할 수 있어야합니다. 호출 대상은 가상 일 때는 보장 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="06a4ac5a76e9f0b9bdc8fd8bfd509f3b58e40c69" translate="yes" xml:space="preserve">
          <source>It's not possible to create a Duration of months or years, because the variable number of days in a month or year makes it impossible to convert between months or years and smaller units without a specific date. So, nothing uses &lt;code&gt;Duration&lt;/code&gt;s when dealing with months or years. Rather, functions specific to months and years are defined. For instance, &lt;a href=&quot;std_datetime#Date&quot;&gt;&lt;code&gt;std.datetime.Date&lt;/code&gt;&lt;/a&gt; has &lt;code&gt;add!&quot;years&quot;&lt;/code&gt; and &lt;code&gt;add!&quot;months&quot;&lt;/code&gt; for adding years and months rather than creating a Duration of years or months and adding that to a &lt;a href=&quot;std_datetime#Date&quot;&gt;&lt;code&gt;std.datetime.Date&lt;/code&gt;&lt;/a&gt;. But Duration is used when dealing with weeks or smaller.</source>
          <target state="translated">월 또는 연도의 가변 일수가 특정 날짜없이 월 또는 연 단위와 더 작은 단위로 변환 할 수 없기 때문에 기간 또는 월을 생성 할 수 없습니다. 따라서 몇 달 또는 몇 년을 다룰 때 &lt;code&gt;Duration&lt;/code&gt; 은 사용하지 않습니다 . 오히려, 월과 연도에 특정한 기능이 정의됩니다. 예를 들어 &lt;a href=&quot;std_datetime#Date&quot;&gt; &lt;code&gt;std.datetime.Date&lt;/code&gt; &lt;/a&gt; 에는 기간 또는 월을 작성하고 &lt;a href=&quot;std_datetime#Date&quot;&gt; &lt;code&gt;std.datetime.Date&lt;/code&gt; 에&lt;/a&gt; 추가하는 대신 연도 및 월을 추가하기 위해 &lt;code&gt;add!&quot;years&quot;&lt;/code&gt; 및 &lt;code&gt;add!&quot;months&quot;&lt;/code&gt; 가 추가 되었습니다 . 그러나 기간은 몇 주 이하를 다룰 때 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f254fe5e637e0412db399e1267f254c7da7a7960" translate="yes" xml:space="preserve">
          <source>It's not recommended to rely on the template parameters or the exact type of a current &lt;a href=&quot;#Code%20point&quot;&gt;code point&lt;/a&gt; set in &lt;code&gt;std.uni&lt;/code&gt;. The type and parameters may change when the standard allocators design is finalized. Use &lt;a href=&quot;#isCodepointSet&quot;&gt;&lt;code&gt;isCodepointSet&lt;/code&gt;&lt;/a&gt; with templates or just stick with the default alias &lt;a href=&quot;#CodepointSet&quot;&gt;&lt;code&gt;CodepointSet&lt;/code&gt;&lt;/a&gt; throughout the whole code base.</source>
          <target state="translated">&lt;code&gt;std.uni&lt;/code&gt; 에 설정된 현재 &lt;a href=&quot;#Code%20point&quot;&gt;코드 포인트&lt;/a&gt; 의 정확한 유형 또는 템플릿 매개 변수에 의존하지 않는 것이 좋습니다 . 표준 할당 자 설계가 완료되면 유형 및 매개 변수가 변경 될 수 있습니다. 사용 &lt;a href=&quot;#isCodepointSet&quot;&gt; &lt;code&gt;isCodepointSet&lt;/code&gt; &lt;/a&gt; 템플릿을하거나 별칭 기본에 충실 &lt;a href=&quot;#CodepointSet&quot;&gt; &lt;code&gt;CodepointSet&lt;/code&gt; &lt;/a&gt; 전체 코드베이스에 걸쳐.</target>
        </trans-unit>
        <trans-unit id="e42f2c0ae3ac2dbd97c749238e72a4938f4cb57d" translate="yes" xml:space="preserve">
          <source>It's possible that, due to greater use of temporaries and common subexpressions, optimized code may produce a more accurate answer than unoptimized code.</source>
          <target state="translated">임시 및 공통 하위 표현식을 많이 사용하기 때문에 최적화 된 코드가 최적화되지 않은 코드보다 더 정확한 답변을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="26bfc917d4c2808b47a0c439b2041bcf1d3ffe79" translate="yes" xml:space="preserve">
          <source>It's primarily of use when &lt;code&gt;MonoTime.ticksPerSecond&lt;/code&gt; is greater than hecto-nanosecond resolution, and an application needs a higher precision than hecto-nanoceconds.</source>
          <target state="translated">&lt;code&gt;MonoTime.ticksPerSecond&lt;/code&gt; 가 hecto -nanosecond 해상도보다 클 때 응용 프로그램이 hecto-nanoceconds보다 높은 정밀도를 요구할 때 주로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="7493d4e3c56b61b05894f6661cfb0cba6fef7966" translate="yes" xml:space="preserve">
          <source>It's primarily used as the time zone in the result of &lt;a href=&quot;std_datetime_systime#SysTime&quot;&gt;&lt;code&gt;std.datetime.systime.SysTime&lt;/code&gt;&lt;/a&gt;'s &lt;code&gt;fromISOString&lt;/code&gt;, &lt;code&gt;fromISOExtString&lt;/code&gt;, and &lt;code&gt;fromSimpleString&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;std_datetime_systime#SysTime&quot;&gt; &lt;code&gt;std.datetime.systime.SysTime&lt;/code&gt; &lt;/a&gt; 의 &lt;code&gt;fromISOString&lt;/code&gt; , &lt;code&gt;fromISOExtString&lt;/code&gt; 및 &lt;code&gt;fromSimpleString&lt;/code&gt; 의 결과에서 시간대로 주로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="5ddbad8c19d68bb5a701a60afd8d7c7541591bb5" translate="yes" xml:space="preserve">
          <source>It's recognized that an application may need further enhancements and extensions, such as less commonly known algorithms, or tailoring existing ones for region specific needs. To help users with building any extra functionality beyond the core primitives, the module provides:</source>
          <target state="translated">응용 프로그램에 덜 일반적으로 알려진 알고리즘이나 지역별 요구에 맞게 기존 알고리즘을 조정하는 등의 추가 개선 및 확장이 필요할 수 있습니다. 사용자는 핵심 기본 요소 이외의 추가 기능을 구축 할 수 있도록 다음과 같은 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="68d3d6d38586ab9e2cf36ecb94fa00a82cfe0680" translate="yes" xml:space="preserve">
          <source>It's the same as &lt;code&gt;TickDuration(0)&lt;/code&gt;, but it's provided to be consistent with &lt;code&gt;Duration&lt;/code&gt; and &lt;code&gt;FracSec&lt;/code&gt;, which provide &lt;code&gt;zero&lt;/code&gt; properties.</source>
          <target state="translated">&lt;code&gt;TickDuration(0)&lt;/code&gt; 과 동일 하지만 속성이 &lt;code&gt;zero&lt;/code&gt; &lt;code&gt;Duration&lt;/code&gt; 및 &lt;code&gt;FracSec&lt;/code&gt; 과 일치 하도록 제공 됩니다 .</target>
        </trans-unit>
        <trans-unit id="ea921a8a04c239de3776a66ccc556b8d1fa02438" translate="yes" xml:space="preserve">
          <source>It's the same as &lt;code&gt;TickDuration(0)&lt;/code&gt;, but it's provided to be consistent with &lt;code&gt;Duration&lt;/code&gt;, which provides a &lt;code&gt;zero&lt;/code&gt; property.</source>
          <target state="translated">&lt;code&gt;TickDuration(0)&lt;/code&gt; 과 동일 하지만 &lt;code&gt;zero&lt;/code&gt; 속성 을 제공하는 &lt;code&gt;Duration&lt;/code&gt; 과 일치하도록 제공 됩니다.</target>
        </trans-unit>
        <trans-unit id="e5fa71e6d58d5d0fca114db8f0a8c3a287da2aef" translate="yes" xml:space="preserve">
          <source>Itanium C++ ABI: Exception Handling ($Revision: 1.22 $)</source>
          <target state="translated">Itanium C ++ ABI : 예외 처리 ($ Revision : 1.22 $)</target>
        </trans-unit>
        <trans-unit id="9b3710c74713ad73b6fee6faa68d7c7089a3d821" translate="yes" xml:space="preserve">
          <source>Item in list for member initializer.</source>
          <target state="translated">멤버 이니셜 라이저 목록의 항목입니다.</target>
        </trans-unit>
        <trans-unit id="967e0f2ba10fa14510c5c3967d8f30ed26175886" translate="yes" xml:space="preserve">
          <source>Item[] &lt;strong id=&quot;items&quot;&gt;items&lt;/strong&gt;;</source>
          <target state="translated">아이템 [] &lt;strong id=&quot;items&quot;&gt;아이템&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="bdc6a863777ef0dc2df1c117cbf561a6833206f4" translate="yes" xml:space="preserve">
          <source>Items to be read.</source>
          <target state="translated">읽을 항목.</target>
        </trans-unit>
        <trans-unit id="e3250ae0a20fa67a451aa0b4b6775210b20451c3" translate="yes" xml:space="preserve">
          <source>Items to write.</source>
          <target state="translated">쓸 아이템.</target>
        </trans-unit>
        <trans-unit id="7547deafe5aeaac079d28f1f346ec148fba5a3b0" translate="yes" xml:space="preserve">
          <source>Iterate a range of char, wchar, or dchars by code unit.</source>
          <target state="translated">코드 단위로 char, wchar 또는 dchars 범위를 반복하십시오.</target>
        </trans-unit>
        <trans-unit id="b1704652b324c3acc4164b27ffcc4b641b7725a9" translate="yes" xml:space="preserve">
          <source>Iterate a string by &lt;a href=&quot;#Grapheme&quot;&gt;&lt;code&gt;Grapheme&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#Grapheme&quot;&gt; &lt;code&gt;Grapheme&lt;/code&gt; &lt;/a&gt; 으로 문자열을 반복하십시오 .</target>
        </trans-unit>
        <trans-unit id="6d5051ba4123d61c812f79621e111e7a827233fe" translate="yes" xml:space="preserve">
          <source>Iterate an &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; of characters by char type &lt;code&gt;C&lt;/code&gt; by encoding the elements of the range.</source>
          <target state="translated">&lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;범위&lt;/a&gt; 의 요소를 인코딩하여 문자 유형 &lt;code&gt;C&lt;/code&gt; 로 문자 의 입력 범위 를 반복 하십시오.</target>
        </trans-unit>
        <trans-unit id="2bcec762ed6378cddf8fe09a083a3077c9a309f0" translate="yes" xml:space="preserve">
          <source>Iterate an &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; of characters by char, wchar, or dchar. These aliases simply forward to &lt;a href=&quot;#byUTF&quot;&gt;&lt;code&gt;byUTF&lt;/code&gt;&lt;/a&gt; with the corresponding C argument.</source>
          <target state="translated">char, wchar 또는 dchar로 문자 의 &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;입력 범위&lt;/a&gt; 를 반복하십시오 . 이 별명 은 해당 C 인수와 함께 &lt;a href=&quot;#byUTF&quot;&gt; &lt;code&gt;byUTF&lt;/code&gt; &lt;/a&gt; 로 간단히 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="a3f29e0c66209fcd4d3a0e0f7bfe84443ed9bfc8" translate="yes" xml:space="preserve">
          <source>Iterate multiple ranges in lockstep using a &lt;code&gt;foreach&lt;/code&gt; loop. In contrast to &lt;a href=&quot;#zip&quot;&gt;&lt;code&gt;zip&lt;/code&gt;&lt;/a&gt; it allows reference access to its elements. If only a single range is passed in, the &lt;code&gt;Lockstep&lt;/code&gt; aliases itself away. If the ranges are of different lengths and &lt;code&gt;s&lt;/code&gt; == &lt;code&gt;StoppingPolicy.shortest&lt;/code&gt; stop after the shortest range is empty. If the ranges are of different lengths and &lt;code&gt;s&lt;/code&gt; == &lt;code&gt;StoppingPolicy.requireSameLength&lt;/code&gt;, throw an exception. &lt;code&gt;s&lt;/code&gt; may not be &lt;code&gt;StoppingPolicy.longest&lt;/code&gt;, and passing this will throw an exception.</source>
          <target state="translated">&lt;code&gt;foreach&lt;/code&gt; 루프를 사용하여 잠금 단계에서 여러 범위를 반복하십시오 . &lt;a href=&quot;#zip&quot;&gt; &lt;code&gt;zip&lt;/code&gt; &lt;/a&gt; 과 달리 요소에 대한 참조 액세스를 허용합니다. 단일 범위 만 전달되면 &lt;code&gt;Lockstep&lt;/code&gt; 별명 자체가 사라집니다. 범위의 길이가 다르고 &lt;code&gt;s&lt;/code&gt; == &lt;code&gt;StoppingPolicy.shortest&lt;/code&gt; 가 가장 짧은 범위가 비어있는 후 중지 합니다. 범위의 길이가 다르고 &lt;code&gt;s&lt;/code&gt; == &lt;code&gt;StoppingPolicy.requireSameLength&lt;/code&gt; 인 경우 예외를 발생시킵니다. &lt;code&gt;s&lt;/code&gt; 는 &lt;code&gt;StoppingPolicy.longest&lt;/code&gt; 가 아닐 수 있으며 이를 전달하면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="46f6cb646c6843f945d7da582e76018151566d41" translate="yes" xml:space="preserve">
          <source>Iterate over &lt;code&gt;range&lt;/code&gt; with an attached index variable.</source>
          <target state="translated">첨부 된 색인 변수를 사용하여 &lt;code&gt;range&lt;/code&gt; 를 반복 하십시오.</target>
        </trans-unit>
        <trans-unit id="a6544d2b6a21967203cbbbbf85d9c93956a308c9" translate="yes" xml:space="preserve">
          <source>Iterate over all module infos.</source>
          <target state="translated">모든 모듈 정보를 반복합니다.</target>
        </trans-unit>
        <trans-unit id="c6f1ecb57816d0f8ab8895d96ff555e6c40017b4" translate="yes" xml:space="preserve">
          <source>Iterate over ranges with windows</source>
          <target state="translated">창으로 범위를 반복</target>
        </trans-unit>
        <trans-unit id="0923c68159586a48770eb5eb395cea146e0dc546" translate="yes" xml:space="preserve">
          <source>Iterate several ranges in lockstep. The element type is a proxy tuple that allows accessing the current element in the &lt;code&gt;n&lt;/code&gt;th range by using &lt;code&gt;e[n]&lt;/code&gt;.</source>
          <target state="translated">잠금 단계에서 여러 범위를 반복하십시오. 요소 유형은 &lt;code&gt;e[n]&lt;/code&gt; 을 사용하여 &lt;code&gt;n&lt;/code&gt; 번째 범위 의 현재 요소에 액세스 할 수있는 프록시 튜플입니다 .</target>
        </trans-unit>
        <trans-unit id="cba848f6a93f568e8e0ff6bcad21ff094359be43" translate="yes" xml:space="preserve">
          <source>Iterate this dsymbol or members of this scoped dsymbol, then call &lt;code&gt;fp&lt;/code&gt; with the found symbol and &lt;code&gt;param&lt;/code&gt;.</source>
          <target state="translated">이 dsymbol 또는이 범위가 지정된 dsymbol의 멤버를 반복 한 다음 찾은 기호 및 &lt;code&gt;param&lt;/code&gt; 을 사용하여 &lt;code&gt;fp&lt;/code&gt; 를 호출 하십시오 .</target>
        </trans-unit>
        <trans-unit id="396a4c4a83adbfe93e36ca56c3db62aa4de33668" translate="yes" xml:space="preserve">
          <source>Iterates</source>
          <target state="translated">Iterates</target>
        </trans-unit>
        <trans-unit id="4c7657311c0985cf818bd71ba4e38315b188c160" translate="yes" xml:space="preserve">
          <source>Iterates a bidirectional range backwards.</source>
          <target state="translated">양방향 범위를 거꾸로 반복합니다.</target>
        </trans-unit>
        <trans-unit id="81014f52c564f4b2a0a23cd199c9b45c770f9142" translate="yes" xml:space="preserve">
          <source>Iterates a bidirectional range backwards. The original range can be accessed by using the &lt;code&gt;source&lt;/code&gt; property. Applying retro twice to the same range yields the original range.</source>
          <target state="translated">양방향 범위를 거꾸로 반복합니다. &lt;code&gt;source&lt;/code&gt; 속성 을 사용하여 원래 범위에 액세스 할 수 있습니다 . 같은 범위에 레트로를 두 번 적용하면 원래 범위가됩니다.</target>
        </trans-unit>
        <trans-unit id="031fd6a3f37b8f60999d9b1f8c51e96e07a5e012" translate="yes" xml:space="preserve">
          <source>Iterates a random-access range starting from a given point and progressively extending left and right from that point. If no initial point is given, iteration starts from the middle of the range. Iteration spans the entire range.</source>
          <target state="translated">주어진 지점에서 시작하여 해당 지점에서 왼쪽과 오른쪽으로 점진적으로 확장되는 임의 액세스 범위를 반복합니다. 초기 점이 주어지지 않으면 범위의 중간부터 반복이 시작됩니다. 반복은 전체 범위에 걸쳐 있습니다.</target>
        </trans-unit>
        <trans-unit id="6155d3dc4b918ca7ad16f0811ad5e79c02bd03b2" translate="yes" xml:space="preserve">
          <source>Iterates a range with an attached index variable.</source>
          <target state="translated">첨부 된 인덱스 변수를 사용하여 범위를 반복합니다.</target>
        </trans-unit>
        <trans-unit id="be520983ead745fdd9048145abd61e2d2031ef35" translate="yes" xml:space="preserve">
          <source>Iterates a range with stride</source>
          <target state="translated">보폭으로 범위를 반복</target>
        </trans-unit>
        <trans-unit id="0e3057ecac253c49baed9d03893907ec2f577311" translate="yes" xml:space="preserve">
          <source>Iterates over the unique elements in a range, which is assumed sorted.</source>
          <target state="translated">범위 내에서 고유 한 요소를 반복하며 정렬 된 것으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="e9d7e5b017841d823f90dd8b859e306591765919" translate="yes" xml:space="preserve">
          <source>Iterates range &lt;code&gt;r&lt;/code&gt; with stride &lt;code&gt;n&lt;/code&gt;. If the range is a random-access range, moves by indexing into the range; otherwise, moves by successive calls to &lt;code&gt;popFront&lt;/code&gt;. Applying stride twice to the same range results in a stride with a step that is the product of the two applications. It is an error for &lt;code&gt;n&lt;/code&gt; to be 0.</source>
          <target state="translated">stride &lt;code&gt;n&lt;/code&gt; 으로 &lt;code&gt;r&lt;/code&gt; 범위를 반복합니다 . 범위가 랜덤 액세스 범위 인 경우 범위로 색인화하여 이동합니다. 그렇지 않으면, &lt;code&gt;popFront&lt;/code&gt; 를 연속적으로 호출하여 이동 합니다. 보폭을 같은 범위에 두 번 적용하면 두 적용의 곱인 스텝이 보폭이됩니다. &lt;code&gt;n&lt;/code&gt; 이 0 인 것은 오류입니다 .</target>
        </trans-unit>
        <trans-unit id="41c0b28ede291ea7f7566d122e863aa0f535dcba" translate="yes" xml:space="preserve">
          <source>Iterates the passed arguments and return the maximum value.</source>
          <target state="translated">전달 된 인수를 반복하고 최대 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="47523bd72a1e5bbe72f324aa44a743f2339e194c" translate="yes" xml:space="preserve">
          <source>Iterates the passed arguments and returns the maximum value.</source>
          <target state="translated">전달 된 인수를 반복하고 최대 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7d1e12925acc4cdc52d701ccd76ee602a77fe86f" translate="yes" xml:space="preserve">
          <source>Iterates the passed arguments and returns the minimum value.</source>
          <target state="translated">전달 된 인수를 반복하고 최소값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6f9bb1a3e40031f0788544f6e843a3b9b81f2f50" translate="yes" xml:space="preserve">
          <source>Iterates the passed range and returns the maximal element. A custom mapping function can be passed to &lt;code&gt;map&lt;/code&gt;. In other languages this is sometimes called &lt;code&gt;argmax&lt;/code&gt;.</source>
          <target state="translated">전달 된 범위를 반복하고 최대 요소를 반환합니다. 사용자 정의 맵핑 기능을 &lt;code&gt;map&lt;/code&gt; 에 전달할 수 있습니다 . 다른 언어에서는 이것을 때때로 &lt;code&gt;argmax&lt;/code&gt; 라고 합니다 .</target>
        </trans-unit>
        <trans-unit id="5c4dd3d0ca41dc586c0601f5460e0bdf217d07ef" translate="yes" xml:space="preserve">
          <source>Iterates the passed range and returns the minimal element. A custom mapping function can be passed to &lt;code&gt;map&lt;/code&gt;. In other languages this is sometimes called &lt;code&gt;argmin&lt;/code&gt;.</source>
          <target state="translated">전달 된 범위를 반복하고 최소 요소를 반환합니다. 사용자 정의 맵핑 기능을 &lt;code&gt;map&lt;/code&gt; 에 전달할 수 있습니다 . 다른 언어에서는 이것을 때때로 &lt;code&gt;argmin&lt;/code&gt; 이라고 합니다 .</target>
        </trans-unit>
        <trans-unit id="ac5030d77c55effd0702acc270731f6b899947c4" translate="yes" xml:space="preserve">
          <source>Iterates through a file a chunk at a time by using &lt;code&gt;foreach&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;foreach&lt;/code&gt; 를 사용하여 한 번에 청크를 파일을 반복합니다 .</target>
        </trans-unit>
        <trans-unit id="bda215d2193432c1605c2f94eab1dd86c59fc050" translate="yes" xml:space="preserve">
          <source>Iterates through the lines of a file by using &lt;code&gt;foreach&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;foreach&lt;/code&gt; 를 사용하여 파일 행을 반복합니다 .</target>
        </trans-unit>
        <trans-unit id="00eca5d46e200a01deae26dbfef918eb9a307e2e" translate="yes" xml:space="preserve">
          <source>Iterating over &lt;code&gt;Lockstep&lt;/code&gt; in reverse and with an index is only possible when &lt;code&gt;s&lt;/code&gt; == &lt;code&gt;StoppingPolicy.requireSameLength&lt;/code&gt;, in order to preserve indexes. If an attempt is made at iterating in reverse when &lt;code&gt;s&lt;/code&gt; == &lt;code&gt;StoppingPolicy.shortest&lt;/code&gt;, an exception will be thrown.</source>
          <target state="translated">인덱스 를 유지하기 위해 &lt;code&gt;s&lt;/code&gt; == &lt;code&gt;StoppingPolicy.requireSameLength&lt;/code&gt; 인 경우에만 &lt;code&gt;Lockstep&lt;/code&gt; 를 반대로 반복 하고 인덱스를 사용하여 반복 할 수 있습니다 . &lt;code&gt;s&lt;/code&gt; == &lt;code&gt;StoppingPolicy.shortest&lt;/code&gt; 일 때 역순으로 반복을 시도 하면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="18905aab409cadb5b72681a650ec99001cb221e0" translate="yes" xml:space="preserve">
          <source>Iteration</source>
          <target state="translated">Iteration</target>
        </trans-unit>
        <trans-unit id="7ab9c33240f90c018e5301ec386d9a17da67f57b" translate="yes" xml:space="preserve">
          <source>Iteratively joins all tracked threads. This function will block add, remove, and opApply until it completes.</source>
          <target state="translated">모든 추적 된 스레드를 반복적으로 결합합니다. 이 기능은 완료 될 때까지 추가, 제거 및 opApply를 차단합니다.</target>
        </trans-unit>
        <trans-unit id="ac5dbd0b8592025504a68619b35e97d48ae39f52" translate="yes" xml:space="preserve">
          <source>JSON type enumeration</source>
          <target state="translated">JSON 유형 열거</target>
        </trans-unit>
        <trans-unit id="37261b1315c409df97253a04fdcad2ac04e9f2e5" translate="yes" xml:space="preserve">
          <source>JSON value node</source>
          <target state="translated">JSON 값 노드</target>
        </trans-unit>
        <trans-unit id="19b9988b5b0ebaf897665e22703721b63cd55e3f" translate="yes" xml:space="preserve">
          <source>JSONOptions &lt;code&gt;options&lt;/code&gt;</source>
          <target state="translated">JSONOptions &lt;code&gt;options&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="77047b2f2f7a1f46f4f773acebc94e1704d45d0a" translate="yes" xml:space="preserve">
          <source>JSONValue</source>
          <target state="translated">JSONValue</target>
        </trans-unit>
        <trans-unit id="6a908d3132e3f4771380420780f724bcb99aa35b" translate="yes" xml:space="preserve">
          <source>JSONValue &lt;strong id=&quot;parseJSON&quot;&gt;parseJSON&lt;/strong&gt;(T)(T json, JSONOptions options)</source>
          <target state="translated">JSONValue &lt;strong id=&quot;parseJSON&quot;&gt;구문&lt;/strong&gt; 분석 &lt;strong id=&quot;parseJSON&quot;&gt;JSON&lt;/strong&gt; (T) (T json, JSONOptions 옵션)</target>
        </trans-unit>
        <trans-unit id="ad2cc87635827ce36358659faec53896c2ffd9d7" translate="yes" xml:space="preserve">
          <source>JSONValue &lt;strong id=&quot;parseJSON&quot;&gt;parseJSON&lt;/strong&gt;(T)(T json, int maxDepth = -1, JSONOptions options = JSONOptions.none)</source>
          <target state="translated">JSONValue &lt;strong id=&quot;parseJSON&quot;&gt;구문&lt;/strong&gt; 분석 &lt;strong id=&quot;parseJSON&quot;&gt;JSON&lt;/strong&gt; (T) (T json, int maxDepth = -1, JSONOptions 옵션 = JSONOptions.none)</target>
        </trans-unit>
        <trans-unit id="75fe8ccb746c12e5fc2263d91bcd2e2c2a1c8f7e" translate="yes" xml:space="preserve">
          <source>Jacob Carlborg</source>
          <target state="translated">제이콥 칼 보그</target>
        </trans-unit>
        <trans-unit id="6e25ce2240148f400ce62910a8b1efe74e2c9a0e" translate="yes" xml:space="preserve">
          <source>Janice Caron</source>
          <target state="translated">제니스 카론</target>
        </trans-unit>
        <trans-unit id="7596e768bfc7370245a658fe8f76d22204852664" translate="yes" xml:space="preserve">
          <source>Java's &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/javadoc/index.html&quot;&gt;Javadoc&lt;/a&gt;, probably the most well-known</source>
          <target state="translated">아마도 가장 잘 알려진 Java의 &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/javadoc/index.html&quot;&gt;Javadoc&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="94e850a9fa9f98700106bfba6b5849640ea65567" translate="yes" xml:space="preserve">
          <source>JavaScript Object Notation</source>
          <target state="translated">자바 스크립트 객체 표기법</target>
        </trans-unit>
        <trans-unit id="4d3bb51ea74dbb54d8ffaf04425ff843127f10a5" translate="yes" xml:space="preserve">
          <source>Javanese</source>
          <target state="translated">Javanese</target>
        </trans-unit>
        <trans-unit id="5094055d2217aa7321a9d7bed6ee4d5794505c17" translate="yes" xml:space="preserve">
          <source>Jeremie Pelletier, David Herberth</source>
          <target state="translated">제레미 펠티에, 데이비드 허버트</target>
        </trans-unit>
        <trans-unit id="44f434a971d725063d7a2953337c698c7bac2ba2" translate="yes" xml:space="preserve">
          <source>Jesse Phillips</source>
          <target state="translated">제시 필립스</target>
        </trans-unit>
        <trans-unit id="8d398e7a2e7966fc969106c70e0482f689337c66" translate="yes" xml:space="preserve">
          <source>Johannes Pfau</source>
          <target state="translated">요하네스 파우</target>
        </trans-unit>
        <trans-unit id="f46447d52bfcc376c589171fb6036cd3ae4a5810" translate="yes" xml:space="preserve">
          <source>Join a couple of functions into one that executes the original functions one after the other, using one function's result for the next function's argument.</source>
          <target state="translated">다음 함수의 인수에 대해 하나의 함수 결과를 사용하여 원래 함수를 차례대로 실행하는 두 함수를 하나의 함수로 결합하십시오.</target>
        </trans-unit>
        <trans-unit id="0d0c43aa8867e08f397e43a619a1f600ed8f6361" translate="yes" xml:space="preserve">
          <source>Join_Control</source>
          <target state="translated">Join_Control</target>
        </trans-unit>
        <trans-unit id="dcb5bf332c4e4981c7768b8555ac3e4b7690dc4e" translate="yes" xml:space="preserve">
          <source>Joins a couple of functions into one that executes the original functions independently and returns a tuple with all the results.</source>
          <target state="translated">원래 함수를 독립적으로 실행하고 모든 결과와 함께 튜플을 반환하는 함수 두 개를 하나로 결합합니다.</target>
        </trans-unit>
        <trans-unit id="aefc3c1587d67e993c50c46acea53d9b977ae451" translate="yes" xml:space="preserve">
          <source>Joins all non-daemon threads that are currently running. This is done by performing successive scans through the thread list until a scan consists of only daemon threads.</source>
          <target state="translated">현재 실행중인 모든 비 데몬 스레드를 결합합니다. 스캔이 디먼 스레드로만 구성 될 때까지 스레드 목록을 통해 연속 스캔을 수행하면됩니다.</target>
        </trans-unit>
        <trans-unit id="8bc86f684db60d70140fe1419b4325b73f7613a4" translate="yes" xml:space="preserve">
          <source>Jonas Drewsen. Some of the SMTP code contributed by Jimmy Cao.</source>
          <target state="translated">조나스 드류 센. Jimmy Cao가 제공 한 SMTP 코드 중 일부</target>
        </trans-unit>
        <trans-unit id="2792f94184c6127be37b21bcdd8b46ecd91706c9" translate="yes" xml:space="preserve">
          <source>Jonathan M Davis</source>
          <target state="translated">조나단 M 데이비스</target>
        </trans-unit>
        <trans-unit id="0729735c2be61b7d083c7452b2591194f6b9f3e4" translate="yes" xml:space="preserve">
          <source>Jonathan M. Davis &lt;a href=&quot;http://dconf.org/2015/talks/davis.html&quot;&gt;&lt;i&gt;Introduction to Ranges&lt;/i&gt;&lt;/a&gt; talk at DConf 2015 a vivid introduction from its core constructs to practical advice.</source>
          <target state="translated">조나단 M. 데이비스 &lt;a href=&quot;http://dconf.org/2015/talks/davis.html&quot;&gt;&lt;i&gt;산맥 소개&lt;/i&gt;&lt;/a&gt; 는 DConf 2015에서 핵심 구성부터 실질적인 조언까지 생생하게 소개합니다.</target>
        </trans-unit>
        <trans-unit id="97dbaf8e8c4490a101cf7e3f174555f70aa1c17b" translate="yes" xml:space="preserve">
          <source>JsonFieldFlags &lt;strong id=&quot;tryParseJsonField&quot;&gt;tryParseJsonField&lt;/strong&gt;(const(char)* fieldName);</source>
          <target state="translated">JsonFieldFlags &lt;strong id=&quot;tryParseJsonField&quot;&gt;tryParseJsonField&lt;/strong&gt; (const (char) * fieldName);</target>
        </trans-unit>
        <trans-unit id="2d8f6d6417b503e6fc00ddf97fea18ebdd19b03b" translate="yes" xml:space="preserve">
          <source>JsonFieldFlags.none on error, otherwise the JsonFieldFlags value corresponding to the given fieldName.</source>
          <target state="translated">오류 발생시 JsonFieldFlags.none, 그렇지 않은 경우 지정된 fieldName에 해당하는 JsonFieldFlags 값</target>
        </trans-unit>
        <trans-unit id="7426cf06bbe68f4942c2dee1dc1e5f14aacfb8fe" translate="yes" xml:space="preserve">
          <source>Julius C'ster</source>
          <target state="translated">줄리어스 씨스 터</target>
        </trans-unit>
        <trans-unit id="36a42ea8673555a38d9845c5a7215a17263890c6" translate="yes" xml:space="preserve">
          <source>Just like &lt;code&gt;Nullable!T&lt;/code&gt;, except that the null state is defined as a particular value. For example, &lt;code&gt;Nullable!(uint, uint.max)&lt;/code&gt; is an &lt;code&gt;uint&lt;/code&gt; that sets aside the value &lt;code&gt;uint.max&lt;/code&gt; to denote a null state. &lt;code&gt;Nullable!(T, nullValue)&lt;/code&gt; is more storage-efficient than &lt;code&gt;Nullable!T&lt;/code&gt; because it does not need to store an extra &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">null 상태가 특정 값으로 정의된다는 점을 제외하고 &lt;code&gt;Nullable!T&lt;/code&gt; 와 같습니다 . 예를 들어 &lt;code&gt;Nullable!(uint, uint.max)&lt;/code&gt; 은 &lt;code&gt;uint.max&lt;/code&gt; 값을 따로 설정 하여 null 상태를 나타내는 &lt;code&gt;uint&lt;/code&gt; 입니다 . &lt;code&gt;Nullable!(T, nullValue)&lt;/code&gt; 은 추가 &lt;code&gt;bool&lt;/code&gt; 을 저장할 필요가 없으므로 &lt;code&gt;Nullable!T&lt;/code&gt; 보다 저장 효율성이 높습니다 .</target>
        </trans-unit>
        <trans-unit id="ec9772fef62cdea0720dce405193ab48cbc57ed2" translate="yes" xml:space="preserve">
          <source>Just like &lt;code&gt;Nullable!T&lt;/code&gt;, except that the object refers to a value sitting elsewhere in memory. This makes assignments overwrite the initially assigned value. Internally &lt;code&gt;NullableRef!T&lt;/code&gt; only stores a pointer to &lt;code&gt;T&lt;/code&gt; (i.e., &lt;code&gt;Nullable!T.sizeof == (T*).sizeof&lt;/code&gt;).</source>
          <target state="translated">객체가 메모리의 다른 곳에 앉아있는 값을 참조한다는 점을 제외하고 &lt;code&gt;Nullable!T&lt;/code&gt; 와 같습니다 . 이렇게하면 할당이 처음 할당 된 값을 덮어 씁니다. 내부적으로 &lt;code&gt;NullableRef!T&lt;/code&gt; 단지에 대한 포인터를 저장 &lt;code&gt;T&lt;/code&gt; (즉, &lt;code&gt;Nullable!T.sizeof == (T*).sizeof&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="63ea9136dd991394515bab1b8623b9c1fd950655" translate="yes" xml:space="preserve">
          <source>Just one &lt;a href=&quot;lex#Identifier&quot;&gt;&lt;i&gt;Identifier&lt;/i&gt;&lt;/a&gt; is rewritten to &lt;a href=&quot;function#Parameters&quot;&gt;&lt;i&gt;Parameters&lt;/i&gt;&lt;/a&gt;:</source>
          <target state="translated">하나의 &lt;a href=&quot;lex#Identifier&quot;&gt;&lt;i&gt;식별자&lt;/i&gt;&lt;/a&gt; 만 &lt;a href=&quot;function#Parameters&quot;&gt;&lt;i&gt;Parameters&lt;/i&gt;&lt;/a&gt; 로 다시 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="89f6b4c092b16dc6948f25e1798098f47a9883d5" translate="yes" xml:space="preserve">
          <source>Just the range to fold over; or the range and one seed per function; or the range, one seed per function, and the work unit size</source>
          <target state="translated">접을 수있는 범위; 또는 기능 당 범위 및 하나의 시드; 범위, 기능 당 하나의 시드 및 작업 단위 크기</target>
        </trans-unit>
        <trans-unit id="95821b707963ae42f0cd8570a73c7a770a76a918" translate="yes" xml:space="preserve">
          <source>K &lt;code&gt;key&lt;/code&gt;</source>
          <target state="translated">K &lt;code&gt;key&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="07f366da6fc6a861cbc87352b22ef074419fcb3a" translate="yes" xml:space="preserve">
          <source>Kai Nacke</source>
          <target state="translated">카이 나케</target>
        </trans-unit>
        <trans-unit id="35515824c39939c254cd4490c2c2aadbc065186f" translate="yes" xml:space="preserve">
          <source>Kai Nacke, Johannes Pfau, Nick Sabalausky</source>
          <target state="translated">카이 나케, 요하네스 푸우, 닉 사발 라우 스키</target>
        </trans-unit>
        <trans-unit id="ae170b17bf57b2dd3f07fcd95b9f2bb7e3b26355" translate="yes" xml:space="preserve">
          <source>Kaithi</source>
          <target state="translated">Kaithi</target>
        </trans-unit>
        <trans-unit id="557d6bd7caa0a06ffe47eadcbd352ca5b993f101" translate="yes" xml:space="preserve">
          <source>Kana Supplement</source>
          <target state="translated">가나 보충</target>
        </trans-unit>
        <trans-unit id="5c52b04b182fe59c46dbb680a685e8fae4abc9e4" translate="yes" xml:space="preserve">
          <source>Kanbun</source>
          <target state="translated">Kanbun</target>
        </trans-unit>
        <trans-unit id="765d8f89f8bd937afa34d37a8dd5511726f71e6c" translate="yes" xml:space="preserve">
          <source>Kangxi Radicals</source>
          <target state="translated">강서 급진파</target>
        </trans-unit>
        <trans-unit id="c3ed665577f91f82c451742a0c8875950d42b19f" translate="yes" xml:space="preserve">
          <source>Kannada</source>
          <target state="translated">Kannada</target>
        </trans-unit>
        <trans-unit id="26f11d685b82331f6a7c0ef049098224fd15a035" translate="yes" xml:space="preserve">
          <source>Karatsuba multiplication</source>
          <target state="translated">가라 쓰바 곱셈</target>
        </trans-unit>
        <trans-unit id="6842e5a778887793f59acc2ef5454c8c1ea0e92d" translate="yes" xml:space="preserve">
          <source>Katakana</source>
          <target state="translated">Katakana</target>
        </trans-unit>
        <trans-unit id="d1397b6fcf2a880567c752fd0440900ff604ccd3" translate="yes" xml:space="preserve">
          <source>Katakana Phonetic Extensions</source>
          <target state="translated">가타카나 발음 확장</target>
        </trans-unit>
        <trans-unit id="3dd63971d3f2b16b51633181c1aec91223d8af19" translate="yes" xml:space="preserve">
          <source>Kayah Li</source>
          <target state="translated">카야 리</target>
        </trans-unit>
        <trans-unit id="75ee154fd513c399937f6b79a87ebbade8c7cadd" translate="yes" xml:space="preserve">
          <source>Kayah_Li</source>
          <target state="translated">Kayah_Li</target>
        </trans-unit>
        <trans-unit id="d74eee745944f149824eb2fa0740f7f9e756246b" translate="yes" xml:space="preserve">
          <source>Keep for backward binary compatibility. This function can be removed in the future.</source>
          <target state="translated">이진 호환성을 유지하십시오. 이 기능은 나중에 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cefeb94879a4163ffc965d759c646922a56c39b1" translate="yes" xml:space="preserve">
          <source>Keep track of how often rt_init/rt_term were called.</source>
          <target state="translated">rt_init / rt_term이 얼마나 자주 호출되었는지 추적하십시오.</target>
        </trans-unit>
        <trans-unit id="36d88bb75bee3164971007d202183f35b6295316" translate="yes" xml:space="preserve">
          <source>KeepTerminator &lt;code&gt;keepTerminator&lt;/code&gt;</source>
          <target state="translated">KeepTerminator &lt;code&gt;keepTerminator&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9b4ac1ddd1c0236182fe28a432626c97133b74ac" translate="yes" xml:space="preserve">
          <source>Kenji Hara</source>
          <target state="translated">켄지하라</target>
        </trans-unit>
        <trans-unit id="74687127fcc3dc7bb5e761b8900f3a700141e5bf" translate="yes" xml:space="preserve">
          <source>KeyType</source>
          <target state="translated">KeyType</target>
        </trans-unit>
        <trans-unit id="1d89254a2bc78c1ff41c2f6767a0e00ee126b3bf" translate="yes" xml:space="preserve">
          <source>KeyValuePairs</source>
          <target state="translated">KeyValuePairs</target>
        </trans-unit>
        <trans-unit id="729e53c8eb86a949f666878c598d23f93a3545d7" translate="yes" xml:space="preserve">
          <source>Keys &lt;code&gt;keys&lt;/code&gt;</source>
          <target state="translated">키 &lt;code&gt;keys&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="26f0271fc4a5ffcc2bb5f4dbe3a1fa04013275ee" translate="yes" xml:space="preserve">
          <source>Keys are implementation defined, allowing relevant data for exotic targets. A reliable subset exists which are always available:</source>
          <target state="translated">키는 구현이 정의되어있어 이국적인 대상에 대한 관련 데이터를 허용합니다. 항상 사용 가능한 안정적인 하위 집합이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f530db58b3e5088dc7412c6d2298ba3f8456bdeb" translate="yes" xml:space="preserve">
          <source>Keywords</source>
          <target state="translated">Keywords</target>
        </trans-unit>
        <trans-unit id="0abd7895cc895899e75b610526a33fbc51c32818" translate="yes" xml:space="preserve">
          <source>Keywords are reserved identifiers.</source>
          <target state="translated">키워드는 예약 된 식별자입니다.</target>
        </trans-unit>
        <trans-unit id="b6336831bbeb983ca82f9d4a77612af9bca7a91d" translate="yes" xml:space="preserve">
          <source>Kharoshthi</source>
          <target state="translated">Kharoshthi</target>
        </trans-unit>
        <trans-unit id="3db4bac2e32c1fd4c51c4ffc01f1ab523d35aa5f" translate="yes" xml:space="preserve">
          <source>Khmer</source>
          <target state="translated">Khmer</target>
        </trans-unit>
        <trans-unit id="8518bf9eb37b463a80281371ecf2cd1e0405096e" translate="yes" xml:space="preserve">
          <source>Khmer Symbols</source>
          <target state="translated">크메르어 기호</target>
        </trans-unit>
        <trans-unit id="1f207bb143ebf53a96f07da496ea625fd1ed3952" translate="yes" xml:space="preserve">
          <source>Kinds</source>
          <target state="translated">Kinds</target>
        </trans-unit>
        <trans-unit id="e86af5625d0fba3382c4196e55640871e3d19f3f" translate="yes" xml:space="preserve">
          <source>Kinds of Arrays</source>
          <target state="translated">배열의 종류</target>
        </trans-unit>
        <trans-unit id="63244e6f2aedb0bb8ad7366c81f1da96cdb83a3b" translate="yes" xml:space="preserve">
          <source>Klass</source>
          <target state="translated">Klass</target>
        </trans-unit>
        <trans-unit id="d160e0986aca4714714a16f29ec605af90be704d" translate="yes" xml:space="preserve">
          <source>L</source>
          <target state="translated">L</target>
        </trans-unit>
        <trans-unit id="a10f36f142913e26ae0e6f93a728d8bb0b212cf5" translate="yes" xml:space="preserve">
          <source>L &lt;code&gt;lhs&lt;/code&gt;</source>
          <target state="translated">L &lt;code&gt;lhs&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4f01127b628fe96840398c36b4cd22d12c73d39f" translate="yes" xml:space="preserve">
          <source>LDC (LLVM D Compiler) is the compiler</source>
          <target state="translated">LDC (LLVM D 컴파일러)는 컴파일러입니다</target>
        </trans-unit>
        <trans-unit id="e59266bac956daa5032ba200109e96e1c5b1a2c0" translate="yes" xml:space="preserve">
          <source>LIBCURL_VERSION</source>
          <target state="translated">LIBCURL_VERSION</target>
        </trans-unit>
        <trans-unit id="ae21ee5993e6bb593834d6149c93b819f0663a8b" translate="yes" xml:space="preserve">
          <source>LIBCURL_VERSION_NUM</source>
          <target state="translated">LIBCURL_VERSION_NUM</target>
        </trans-unit>
        <trans-unit id="71ca01cf1a00a026c01e4f77e52bb217888eded6" translate="yes" xml:space="preserve">
          <source>LINK &lt;strong id=&quot;systemLinkage&quot;&gt;systemLinkage&lt;/strong&gt;();</source>
          <target state="translated">링크 시스템 &lt;strong id=&quot;systemLinkage&quot;&gt;연동&lt;/strong&gt; ();</target>
        </trans-unit>
        <trans-unit id="52700257cb800485676caed33f23e22b22745155" translate="yes" xml:space="preserve">
          <source>LLVM D Compiler (LDC)</source>
          <target state="translated">LLVM D 컴파일러 (LDC)</target>
        </trans-unit>
        <trans-unit id="447562b9012012a2aca5d204bad70095bfe8f420" translate="yes" xml:space="preserve">
          <source>LOOSE</source>
          <target state="translated">LOOSE</target>
        </trans-unit>
        <trans-unit id="a09b13dff976fe20f239fab7a59a35bde98835e6" translate="yes" xml:space="preserve">
          <source>LV</source>
          <target state="translated">LV</target>
        </trans-unit>
        <trans-unit id="33b636a601b7a02911b25e76cda4a549a1d9ebd1" translate="yes" xml:space="preserve">
          <source>LVT</source>
          <target state="translated">LVT</target>
        </trans-unit>
        <trans-unit id="15d9300627a09b46f74a6b87395d2a7f3411cc88" translate="yes" xml:space="preserve">
          <source>LVT_Syllable</source>
          <target state="translated">LVT_Syllable</target>
        </trans-unit>
        <trans-unit id="2cfbfa4fc186833e1d17b39a6ed4758a215c22ac" translate="yes" xml:space="preserve">
          <source>LV_Syllable</source>
          <target state="translated">LV_Syllable</target>
        </trans-unit>
        <trans-unit id="ba218d1261bfead2f97e926079c3ae7568071bf0" translate="yes" xml:space="preserve">
          <source>Label* &lt;code&gt;label&lt;/code&gt;</source>
          <target state="translated">라벨 * &lt;code&gt;label&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2b86e48b918e6b8af7eaccee49db2cecb08b3997" translate="yes" xml:space="preserve">
          <source>Label** &lt;strong id=&quot;lookupLabel&quot;&gt;lookupLabel&lt;/strong&gt;(Statement s);</source>
          <target state="translated">레이블 ** &lt;strong id=&quot;lookupLabel&quot;&gt;lookupLabel&lt;/strong&gt; ( &lt;strong id=&quot;lookupLabel&quot;&gt;States&lt;/strong&gt; s);</target>
        </trans-unit>
        <trans-unit id="2fc1ef0d8a8c6fb5a183e6dd4055bf2e2a000b0f" translate="yes" xml:space="preserve">
          <source>LabelDsymbol &lt;strong id=&quot;returnLabel&quot;&gt;returnLabel&lt;/strong&gt;;</source>
          <target state="translated">LabelDsymbol &lt;strong id=&quot;returnLabel&quot;&gt;returnLabel&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="57a27a2a11471faebdb082dca955aba4bf532df9" translate="yes" xml:space="preserve">
          <source>Labeled Statements</source>
          <target state="translated">레이블이있는 진술</target>
        </trans-unit>
        <trans-unit id="2228985493d9e43e461c7be5525529248735ad9c" translate="yes" xml:space="preserve">
          <source>Labels</source>
          <target state="translated">Labels</target>
        </trans-unit>
        <trans-unit id="55e451de0e70b249932cac7139c9b15e9f160538" translate="yes" xml:space="preserve">
          <source>Labels are in a name space independent of declarations, variables, types, etc. Even so, labels cannot have the same name as local declarations. The label name space is the body of the function they appear in. Label name spaces do not nest, i.e. a label inside a block statement is accessible from outside that block.</source>
          <target state="translated">레이블은 선언, 변수, 유형 등과 독립적으로 네임 스페이스에 있습니다. 그럼에도 불구하고 레이블은 로컬 선언과 동일한 이름을 가질 수 없습니다. 레이블 네임 스페이스는 표시되는 함수의 본문입니다. 레이블 네임 스페이스는 중첩되지 않습니다. 즉, 블록 명령문 내부의 레이블은 해당 블록 외부에서 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a1475fce73eed0441ef9a6cf5dea0d92a68de5f" translate="yes" xml:space="preserve">
          <source>Labels are in a separate scope, one per function.</source>
          <target state="translated">레이블은 기능별로 하나씩 별도의 범위에 있습니다.</target>
        </trans-unit>
        <trans-unit id="ab80f546ab7aedd542b6f7cf9ec336e3c5a2f337" translate="yes" xml:space="preserve">
          <source>Labels in one function cannot be referenced from another function.</source>
          <target state="translated">한 함수의 레이블은 다른 함수에서 참조 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1a3a859b8543db93b9d21e22a679ffb2ca537eef" translate="yes" xml:space="preserve">
          <source>Laboriously construct a C wrapper around the C++ code.</source>
          <target state="translated">C ++ 코드를 중심으로 C 래퍼를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="cab09d9adb98c17169fd258e9b9f83a3876c4fd1" translate="yes" xml:space="preserve">
          <source>Lambda</source>
          <target state="translated">Lambda</target>
        </trans-unit>
        <trans-unit id="ba9dfe5041cd205445df5b843e8a9dc628256415" translate="yes" xml:space="preserve">
          <source>Lambdas</source>
          <target state="translated">Lambdas</target>
        </trans-unit>
        <trans-unit id="d0a6871f11875319701fa244442052fe3b8ba59b" translate="yes" xml:space="preserve">
          <source>Language changes listed by -revert</source>
          <target state="translated">-revert로 나열된 언어 변경</target>
        </trans-unit>
        <trans-unit id="1086e1889ddc903c34fd68e5851b7ef08f6a0c1a" translate="yes" xml:space="preserve">
          <source>Language changes listed by -transition=id</source>
          <target state="translated">-transition = id로 나열된 언어 변경</target>
        </trans-unit>
        <trans-unit id="489e3618a7be2c6a60858c53fd8bf2fdf36a41ff" translate="yes" xml:space="preserve">
          <source>Language previews listed by -preview</source>
          <target state="translated">-미리보기로 나열된 언어 미리보기</target>
        </trans-unit>
        <trans-unit id="c1439807deac3e6c9290cfd97415a4b15f4ba6c8" translate="yes" xml:space="preserve">
          <source>Lao</source>
          <target state="translated">Lao</target>
        </trans-unit>
        <trans-unit id="4ff311dd115963220443dbbe7f3cdc78b24cc17c" translate="yes" xml:space="preserve">
          <source>Largest &lt;code&gt;Duration&lt;/code&gt; possible.</source>
          <target state="translated">가능한 최대 &lt;code&gt;Duration&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="441940b44967219249673ac5a62264158b9767e7" translate="yes" xml:space="preserve">
          <source>Largest &lt;code&gt;MonoTime&lt;/code&gt; possible.</source>
          <target state="translated">가능한 최대 &lt;code&gt;MonoTime&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="775739b719ae1c33d45f0da7e4f74abc764e3ce2" translate="yes" xml:space="preserve">
          <source>Largest &lt;code&gt;TickDuration&lt;/code&gt; possible.</source>
          <target state="translated">최대 &lt;code&gt;TickDuration&lt;/code&gt; 이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="b80bfda35a980fed60097a392642bb35e7679260" translate="yes" xml:space="preserve">
          <source>Largest DBCONFIG</source>
          <target state="translated">가장 큰 DBCONFIG</target>
        </trans-unit>
        <trans-unit id="2699f309b0e83a90516b2f64196c054cec645528" translate="yes" xml:space="preserve">
          <source>Largest TESTCTRL</source>
          <target state="translated">가장 큰 TESTCTRL</target>
        </trans-unit>
        <trans-unit id="d9729c92038f752df4b88f1ce2cbf7fb4e98a3ff" translate="yes" xml:space="preserve">
          <source>Largest defined DBSTATUS</source>
          <target state="translated">가장 큰 정의 된 DBSTATUS</target>
        </trans-unit>
        <trans-unit id="4c5c4d623a7cc3fc731087c84c38ecf11ad36ff3" translate="yes" xml:space="preserve">
          <source>Largest enum member value</source>
          <target state="translated">가장 큰 열거 형 멤버 값</target>
        </trans-unit>
        <trans-unit id="143fb511beaf582b174d9c4ff5835a52b94bef09" translate="yes" xml:space="preserve">
          <source>Largest generated value.</source>
          <target state="translated">가장 큰 생성 값.</target>
        </trans-unit>
        <trans-unit id="031d120afc0f880f2e336a65b6264b1061756f53" translate="yes" xml:space="preserve">
          <source>Largest value of enum</source>
          <target state="translated">열거 형의 가장 큰 가치</target>
        </trans-unit>
        <trans-unit id="5e59d0b67e13689490707955441acfa15678fa32" translate="yes" xml:space="preserve">
          <source>Lars Tandle Kyllingstad, &lt;a href=&quot;http://digitalmars.com&quot;&gt;Walter Bright&lt;/a&gt;, Grzegorz Adam Hankiewicz, Thomas K&amp;uuml;hne, &lt;a href=&quot;http://erdani.org&quot;&gt;Andrei Alexandrescu&lt;/a&gt;</source>
          <target state="translated">Lars Tandle Kyllingstad, &lt;a href=&quot;http://digitalmars.com&quot;&gt;Walter Bright&lt;/a&gt; , Grzegorz Adam Hankiewicz, Thomas K&amp;uuml;hne, &lt;a href=&quot;http://erdani.org&quot;&gt;안드레이 알렉산더&lt;/a&gt; 스쿠</target>
        </trans-unit>
        <trans-unit id="e48d65b433854a00aa3b58538c5d44f7ce276d66" translate="yes" xml:space="preserve">
          <source>Lars Tandle Kyllingstad, Don Clugston</source>
          <target state="translated">Lars Tandle Kyllingstad, 돈 크러 스턴</target>
        </trans-unit>
        <trans-unit id="07235ffa8a70d2e51e9570c942d05e5b5851a313" translate="yes" xml:space="preserve">
          <source>Last Insert Rowid</source>
          <target state="translated">마지막 삽입 Rowid</target>
        </trans-unit>
        <trans-unit id="0763072f970fe33cb40f56a506a18430c6e430bb" translate="yes" xml:space="preserve">
          <source>Last but not least, a desired string sorting order differs by culture and language and is usually nothing like code point for code point comparison. The natural order of strings is obtained by applying &lt;a href=&quot;http://www.unicode.org/reports/tr10/&quot;&gt;the Unicode collation algorithm&lt;/a&gt; that should be implemented in the standard library.</source>
          <target state="translated">마지막으로, 원하는 문자열 정렬 순서는 문화와 언어에 따라 다르며 일반적으로 코드 포인트 비교를위한 코드 포인트와는 다릅니다. 문자열의 자연스러운 순서 는 표준 라이브러리에서 구현해야하는 &lt;a href=&quot;http://www.unicode.org/reports/tr10/&quot;&gt;유니 코드 데이터 정렬 알고리즘&lt;/a&gt; 을 적용 하여 얻습니다 .</target>
        </trans-unit>
        <trans-unit id="aadec2eace052a02b089f2f7686af59be3523b4f" translate="yes" xml:space="preserve">
          <source>Last but not least, a desired string sorting order differs by culture and language and is usually nothing like code point for code point comparison. The natural order of strings is obtained by applying &lt;a href=&quot;https://www.unicode.org/reports/tr10/&quot;&gt;the Unicode collation algorithm&lt;/a&gt; that should be implemented in the standard library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc6d1acb7397d0e5f9098c07f2c7d3aac9936d0e" translate="yes" xml:space="preserve">
          <source>LastExp</source>
          <target state="translated">LastExp</target>
        </trans-unit>
        <trans-unit id="e376b71fe7dd3dc385eba80f693a4c2924d5853c" translate="yes" xml:space="preserve">
          <source>Lastly, &lt;code&gt;x&lt;/code&gt; is set to &lt;code&gt;null&lt;/code&gt;. Any attempt to read or write the freed memory via other references will result in undefined behavior.</source>
          <target state="translated">마지막으로 &lt;code&gt;x&lt;/code&gt; 는 &lt;code&gt;null&lt;/code&gt; 로 설정됩니다 . 다른 참조를 통해 해제 된 메모리를 읽거나 쓰려고하면 정의되지 않은 동작이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9bde795b72be44b343c829314d764282997de688" translate="yes" xml:space="preserve">
          <source>Latin</source>
          <target state="translated">Latin</target>
        </trans-unit>
        <trans-unit id="82571d399af24c495758fdf2aafee5df861943f9" translate="yes" xml:space="preserve">
          <source>Latin Extended Additional</source>
          <target state="translated">라틴 확장 추가</target>
        </trans-unit>
        <trans-unit id="76afa1e916dcce2f445fbbe44abc694adfadc217" translate="yes" xml:space="preserve">
          <source>Latin Extended-A</source>
          <target state="translated">라틴어 확장 -A</target>
        </trans-unit>
        <trans-unit id="c4bc78ee217699a4bb7436be239e087264930a51" translate="yes" xml:space="preserve">
          <source>Latin Extended-B</source>
          <target state="translated">라틴어 확장 -B</target>
        </trans-unit>
        <trans-unit id="204b4ebb9b53ee3348fc9e967c0acfd748bea9b0" translate="yes" xml:space="preserve">
          <source>Latin Extended-C</source>
          <target state="translated">라틴어 확장 -C</target>
        </trans-unit>
        <trans-unit id="fbd8786d3fb197f080f06774e92557923807eec5" translate="yes" xml:space="preserve">
          <source>Latin Extended-D</source>
          <target state="translated">라틴어 확장 -D</target>
        </trans-unit>
        <trans-unit id="7f209e08d16789fe763be5b66fed5e229156bc03" translate="yes" xml:space="preserve">
          <source>Latin-1 (ISO-8859-1) Entities</source>
          <target state="translated">라틴 -1 (ISO-8859-1) 엔티티</target>
        </trans-unit>
        <trans-unit id="f76f4a63a6de1f8fde56d0d52b8de3cc7681c7c6" translate="yes" xml:space="preserve">
          <source>Latin-1 Supplement</source>
          <target state="translated">라틴 -1 보충</target>
        </trans-unit>
        <trans-unit id="ee2650a3acdca161fdd647691bd5c1914bdc316d" translate="yes" xml:space="preserve">
          <source>Layered Structure</source>
          <target state="translated">계층 구조</target>
        </trans-unit>
        <trans-unit id="bfa939b4bde1628cdf49d14c2332ebb064d40ef2" translate="yes" xml:space="preserve">
          <source>Lazily computes all permutations of &lt;code&gt;r&lt;/code&gt; using &lt;a href=&quot;http://en.wikipedia.org/wiki/Heap%27s_algorithm&quot;&gt;Heap's algorithm&lt;/a&gt;.</source>
          <target state="translated">지연 &lt;a href=&quot;http://en.wikipedia.org/wiki/Heap%27s_algorithm&quot;&gt;알고리즘을&lt;/a&gt; 사용하여 &lt;code&gt;r&lt;/code&gt; 의 모든 순열을 지연 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="75b4611db0af61b2d0003032b2047ac487e89a4c" translate="yes" xml:space="preserve">
          <source>Lazily computes all permutations of &lt;code&gt;r&lt;/code&gt; using &lt;a href=&quot;https://en.wikipedia.org/wiki/Heap%27s_algorithm&quot;&gt;Heap's algorithm&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e2c1f0beaadd3254feecabea06e88d4b79b02dc" translate="yes" xml:space="preserve">
          <source>Lazily computes all permutations using Heap's algorithm.</source>
          <target state="translated">지연 알고리즘을 사용하여 모든 순열을 지연 계산합니다.</target>
        </trans-unit>
        <trans-unit id="107096b86eaeda16b3e3830aeea022c0ee83280a" translate="yes" xml:space="preserve">
          <source>Lazily computes the Cartesian product of two or more ranges. The product is a range of tuples of elements from each respective range.</source>
          <target state="translated">Lazily는 두 개 이상의 범위의 카티 전 곱을 계산합니다. 제품은 각 범위에서 요소의 튜플 범위입니다.</target>
        </trans-unit>
        <trans-unit id="5ccd41e6fdf7bb2cc2caeff24d6524d188618f62" translate="yes" xml:space="preserve">
          <source>Lazily computes the difference of &lt;code&gt;r1&lt;/code&gt; and &lt;code&gt;r2&lt;/code&gt;. The two ranges are assumed to be sorted by &lt;code&gt;less&lt;/code&gt;. The element types of the two ranges must have a common type.</source>
          <target state="translated">지연은 &lt;code&gt;r1&lt;/code&gt; 과 &lt;code&gt;r2&lt;/code&gt; 의 차이를 계산합니다 . 두 범위는 &lt;code&gt;less&lt;/code&gt; 정렬 된 것으로 가정합니다 . 두 범위의 요소 유형은 공통 유형이어야합니다.</target>
        </trans-unit>
        <trans-unit id="11620253bf7b271db7d14cf8cdf8bc0f4e54e75c" translate="yes" xml:space="preserve">
          <source>Lazily computes the intersection of two or more &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input ranges&lt;/a&gt;&lt;code&gt;ranges&lt;/code&gt;. The ranges are assumed to be sorted by &lt;code&gt;less&lt;/code&gt;. The element types of the ranges must have a common type.</source>
          <target state="translated">두 개 이상의 &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;입력 범위 &lt;/a&gt; &lt;code&gt;ranges&lt;/code&gt; 의 교집합을 지연 계산합니다 . 범위는 &lt;code&gt;less&lt;/code&gt; 정렬 된 것으로 가정합니다 . 범위의 요소 유형은 공통 유형이어야합니다.</target>
        </trans-unit>
        <trans-unit id="bcbe3c8fe89d00240758248fe29948f389fe9d2c" translate="yes" xml:space="preserve">
          <source>Lazily computes the intersection of two or more sorted ranges.</source>
          <target state="translated">Lazily는 둘 이상의 정렬 된 범위의 교집합을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="e56317731f2e65960db359b60cd199fb81c6c36a" translate="yes" xml:space="preserve">
          <source>Lazily computes the set difference of two or more sorted ranges.</source>
          <target state="translated">두 개 이상의 정렬 된 범위의 차이를 지연 계산합니다.</target>
        </trans-unit>
        <trans-unit id="a7dc174d1b393408f652f2ee4cdbe7ec73d58a98" translate="yes" xml:space="preserve">
          <source>Lazily computes the symmetric difference of &lt;code&gt;r1&lt;/code&gt; and &lt;code&gt;r2&lt;/code&gt;, i.e. the elements that are present in exactly one of &lt;code&gt;r1&lt;/code&gt; and &lt;code&gt;r2&lt;/code&gt;. The two ranges are assumed to be sorted by &lt;code&gt;less&lt;/code&gt;, and the output is also sorted by &lt;code&gt;less&lt;/code&gt;. The element types of the two ranges must have a common type.</source>
          <target state="translated">&lt;code&gt;r1&lt;/code&gt; 과 &lt;code&gt;r2&lt;/code&gt; 의 대칭 차이 , 즉 &lt;code&gt;r1&lt;/code&gt; 과 &lt;code&gt;r2&lt;/code&gt; 중 정확히 하나에 존재하는 요소를 지연 계산합니다 . 두 범위는 &lt;code&gt;less&lt;/code&gt; 정렬 된 것으로 가정되고 출력도 &lt;code&gt;less&lt;/code&gt; 정렬됩니다 . 두 범위의 요소 유형은 공통 유형이어야합니다.</target>
        </trans-unit>
        <trans-unit id="0a833e31b29c15d5d10ff03efb2b971994c72b99" translate="yes" xml:space="preserve">
          <source>Lazily computes the symmetric set difference of two or more sorted ranges.</source>
          <target state="translated">두 개 이상의 정렬 된 범위의 대칭 집합 차이를 지연 계산합니다.</target>
        </trans-unit>
        <trans-unit id="f5e63bd3d07f55a5748e5c534c9595eca39053b0" translate="yes" xml:space="preserve">
          <source>Lazily generate identifier for template instance. This is because 75% of the ident's are never needed.</source>
          <target state="translated">템플릿 인스턴스의 식별자를 느리게 생성합니다. 아이덴티티의 75 %가 필요하지 않기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="3bb485042cec806e50ef44dfce159b1476065631" translate="yes" xml:space="preserve">
          <source>Lazily initializes the scope to forward to.</source>
          <target state="translated">전달할 범위를 느리게 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="a262d4d77393c41d08604edd8fd36f4b129d8a3e" translate="yes" xml:space="preserve">
          <source>Lazily iterates &lt;code&gt;range&lt;/code&gt; until the element &lt;code&gt;e&lt;/code&gt; for which &lt;code&gt;pred(e, sentinel)&lt;/code&gt; is true.</source>
          <target state="translated">느리게 반복이 &lt;code&gt;range&lt;/code&gt; 소자까지 &lt;code&gt;e&lt;/code&gt; 용은 &lt;code&gt;pred(e, sentinel)&lt;/code&gt; 사실이다.</target>
        </trans-unit>
        <trans-unit id="37fa2575de04d25ca5f4a9acbfb7307d51258f3c" translate="yes" xml:space="preserve">
          <source>Lazily iterates a range until a specific value is found.</source>
          <target state="translated">특정 값을 찾을 때까지 범위를 느리게 반복합니다.</target>
        </trans-unit>
        <trans-unit id="855e8fb90512662d24bc8780e84a525e1cbb91c5" translate="yes" xml:space="preserve">
          <source>Lazily iterates unique consecutive elements of the given range (functionality akin to the &lt;a href=&quot;http://wikipedia.org/wiki/Uniq&quot;&gt;uniq&lt;/a&gt; system utility). Equivalence of elements is assessed by using the predicate &lt;code&gt;pred&lt;/code&gt;, by default &lt;code&gt;&quot;a == b&quot;&lt;/code&gt;. The predicate is passed to &lt;a href=&quot;std_functional#binaryFun&quot;&gt;&lt;code&gt;std.functional.binaryFun&lt;/code&gt;&lt;/a&gt;, and can either accept a string, or any callable that can be executed via &lt;code&gt;pred(element, element)&lt;/code&gt;. If the given range is bidirectional, &lt;code&gt;uniq&lt;/code&gt; also yields a &lt;a href=&quot;std_range_primitives#isBidirectionalRange&quot;&gt;bidirectional range&lt;/a&gt;.</source>
          <target state="translated">주어진 범위 ( &lt;a href=&quot;http://wikipedia.org/wiki/Uniq&quot;&gt;uniq&lt;/a&gt; 시스템 유틸리티 와 유사한 기능)의 고유 한 연속 요소를 느리게 반복합니다 . 술어 &lt;code&gt;pred&lt;/code&gt; 를 사용하여 요소의 동등성을 평가 합니다 (기본적으로 &lt;code&gt;&quot;a == b&quot;&lt;/code&gt; . 술어는 &lt;a href=&quot;std_functional#binaryFun&quot;&gt; &lt;code&gt;std.functional.binaryFun&lt;/code&gt; 에&lt;/a&gt; 전달되며 문자열 또는 &lt;code&gt;pred(element, element)&lt;/code&gt; 를 통해 실행할 수있는 호출 가능 항목을 승인 할 수 있습니다 . 주어진 범위가 양방향 인 경우, &lt;code&gt;uniq&lt;/code&gt; 은 또한 &lt;a href=&quot;std_range_primitives#isBidirectionalRange&quot;&gt;양방향 범위를&lt;/a&gt; 산출합니다 .</target>
        </trans-unit>
        <trans-unit id="6086e7590a240520d4f4f94a7c9427ead7374d42" translate="yes" xml:space="preserve">
          <source>Lazily iterates unique consecutive elements of the given range (functionality akin to the &lt;a href=&quot;https://wikipedia.org/wiki/Uniq&quot;&gt;uniq&lt;/a&gt; system utility). Equivalence of elements is assessed by using the predicate &lt;code&gt;pred&lt;/code&gt;, by default &lt;code&gt;&quot;a == b&quot;&lt;/code&gt;. The predicate is passed to &lt;a href=&quot;std_functional#binaryFun&quot;&gt;&lt;code&gt;std.functional.binaryFun&lt;/code&gt;&lt;/a&gt;, and can either accept a string, or any callable that can be executed via &lt;code&gt;pred(element, element)&lt;/code&gt;. If the given range is bidirectional, &lt;code&gt;uniq&lt;/code&gt; also yields a &lt;a href=&quot;std_range_primitives#isBidirectionalRange&quot;&gt;bidirectional range&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcd4c05189e44a024d61096cebf8a9000f337938" translate="yes" xml:space="preserve">
          <source>Lazily joins a range of ranges with a separator. The separator itself is a range. If a separator is not provided, then the ranges are joined directly without anything in between them (often called &lt;code&gt;flatten&lt;/code&gt; in other languages).</source>
          <target state="translated">범위의 범위를 구분 기호로 느리게 결합합니다. 구분자 자체는 범위입니다. 구분 기호가 제공되지 않으면 범위는 그 사이에 아무 것도없이 직접 결합됩니다 (종종 다른 언어 에서는 &lt;code&gt;flatten&lt;/code&gt; 이라고 함 ).</target>
        </trans-unit>
        <trans-unit id="78adbed58b69c14bab88204b103552a98acd8b88" translate="yes" xml:space="preserve">
          <source>Lazily merges two or more sorted ranges.</source>
          <target state="translated">둘 이상의 정렬 된 범위를 느리게 병합합니다.</target>
        </trans-unit>
        <trans-unit id="3f0c45896cd5857d56956a33e01c9a444f7528d6" translate="yes" xml:space="preserve">
          <source>Lazily pads a range to a specified length by adding a given element to the back of the range.</source>
          <target state="translated">범위 뒤에 지정된 요소를 추가하여 범위를 지정된 길이로 느리게 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="f494ee73f56475d2a1f3930ddb0e80428caf8a76" translate="yes" xml:space="preserve">
          <source>Lazily splits a range by a separator.</source>
          <target state="translated">범위를 구분 기호로 느리게 분할합니다.</target>
        </trans-unit>
        <trans-unit id="c63f40da4727f29b6b1fb052d750dd95793056b6" translate="yes" xml:space="preserve">
          <source>Lazily splits a range using an element or range as a separator. Separator ranges can be any narrow string type or sliceable range type.</source>
          <target state="translated">요소 또는 범위를 구분 기호로 사용하여 범위를 느리게 분할합니다. 구분자 범위는 좁은 문자열 유형 또는 슬라이스 가능한 범위 유형일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ccf00e916575e9b3f08279417e858a27e23af9d" translate="yes" xml:space="preserve">
          <source>Lazily splits the character-based range &lt;code&gt;s&lt;/code&gt; into words, using whitespace as the delimiter.</source>
          <target state="translated">느리게 문자 기반의 분할 범위 &lt;code&gt;s&lt;/code&gt; 구분자로 공백을 사용하여, 단어로.</target>
        </trans-unit>
        <trans-unit id="3389a918428772f39da31b4076e337a04baf8333" translate="yes" xml:space="preserve">
          <source>Lazily takes only up to &lt;code&gt;n&lt;/code&gt; elements of a range. This is particularly useful when using with infinite ranges.</source>
          <target state="translated">Lazily는 범위의 최대 &lt;code&gt;n&lt;/code&gt; 개 요소 만 취합니다 . 무한 범위와 함께 사용할 때 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="36687985b7156a39c23148c62ffcfbac01df34ce" translate="yes" xml:space="preserve">
          <source>Lazily transform a range of &lt;a href=&quot;#Grapheme&quot;&gt;&lt;code&gt;Grapheme&lt;/code&gt;&lt;/a&gt;s to a range of code points.</source>
          <target state="translated">&lt;a href=&quot;#Grapheme&quot;&gt; &lt;code&gt;Grapheme&lt;/code&gt; &lt;/a&gt; 범위를 코드 포인트 범위로 느리게 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="bd36508e59e756caeb78e5c935ff99c61bf50c57" translate="yes" xml:space="preserve">
          <source>Lazy Parameters</source>
          <target state="translated">게으른 매개 변수</target>
        </trans-unit>
        <trans-unit id="9e98a803d8a3de17d9dde40743f7d0b0ef000790" translate="yes" xml:space="preserve">
          <source>Lazy Variadic Functions</source>
          <target state="translated">게으른 가변 함수</target>
        </trans-unit>
        <trans-unit id="4ee0307b3a4c3fedfc4c2c80cb3303a1c9f1efd0" translate="yes" xml:space="preserve">
          <source>Lazy decode</source>
          <target state="translated">지연 디코딩</target>
        </trans-unit>
        <trans-unit id="7734c6545eb4a90529d63e3a31cfe3c2fc1ac09d" translate="yes" xml:space="preserve">
          <source>Lazy parameters are currently, too restrictively, inferred by DMD to always throw even though they don't need to be. This makes it impossible to currently mark &lt;code&gt;either&lt;/code&gt; as &lt;code&gt;nothrow&lt;/code&gt;. See issue at &lt;a href=&quot;https://issues.dlang.org/show_bug.cgi?id=12647&quot;&gt;Bugzilla 12647&lt;/a&gt;.</source>
          <target state="translated">게으른 매개 변수는 현재 너무 제한적으로 DMD에 의해 추론 될 필요는 없지만 항상 던지기 위해 유추됩니다. 이로 인해 현재 &lt;code&gt;nothrow&lt;/code&gt; 로 표시 &lt;code&gt;either&lt;/code&gt; 수 없습니다 . &lt;a href=&quot;https://issues.dlang.org/show_bug.cgi?id=12647&quot;&gt;Bugzilla 12647의&lt;/a&gt; 문제를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f441e891a2a053fe381539b6eb7726b9bda63c2c" translate="yes" xml:space="preserve">
          <source>Lazy parameters are not considered.</source>
          <target state="translated">지연 매개 변수는 고려되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="071289bb363736afa36a31dce99701fd42dd4a6b" translate="yes" xml:space="preserve">
          <source>Lazy range which is the concatenation of r1, r2 and ranges with path separators. The resulting element type is that of r1.</source>
          <target state="translated">게으른 범위는 r1, r2의 연결이며 경로 구분 기호와 범위입니다. 결과 요소 유형은 r1의 요소 유형입니다.</target>
        </trans-unit>
        <trans-unit id="de2d83046e13537c5df1729e5a3946298fa16c44" translate="yes" xml:space="preserve">
          <source>Leading separators, trailing separators, or no separators.</source>
          <target state="translated">선행 분리기, 후행 분리기 또는 분리기가 없습니다.</target>
        </trans-unit>
        <trans-unit id="38895ec4492ad75a4a86c9ace4229f7786f0b3e2" translate="yes" xml:space="preserve">
          <source>Leading_Jamo</source>
          <target state="translated">Leading_Jamo</target>
        </trans-unit>
        <trans-unit id="fd94160d0aa2ea752c72468cd1b2add9485192dc" translate="yes" xml:space="preserve">
          <source>Leaving a pointer to it in the static data segment, as the garbage collector will scan the static data segment.</source>
          <target state="translated">가비지 콜렉터가 정적 데이터 세그먼트를 스캔하므로 정적 데이터 세그먼트에서 포인터를 그대로 둡니다.</target>
        </trans-unit>
        <trans-unit id="cfc4be551f2905e6978237e7d77f437233291957" translate="yes" xml:space="preserve">
          <source>Leaving a pointer to it on the stack (as a parameter or automatic variable), as the garbage collector will scan the stack.</source>
          <target state="translated">가비지 콜렉터가 스택을 스캔하므로 스택에 포인터를 매개 변수 또는 자동 변수로 두십시오.</target>
        </trans-unit>
        <trans-unit id="378514d607275e8ee888d65cae8f24d7c6f45b02" translate="yes" xml:space="preserve">
          <source>Left bound of initial range of &lt;code&gt;f&lt;/code&gt; known to contain the root.</source>
          <target state="translated">루트를 포함하는 것으로 알려진 초기 범위 &lt;code&gt;f&lt;/code&gt; 의 왼쪽 경계 .</target>
        </trans-unit>
        <trans-unit id="bfaa1709061a514729de6e5c8f858f0bf2d27571" translate="yes" xml:space="preserve">
          <source>Left bound of initial range of f known to contain the minimum.</source>
          <target state="translated">최소값을 포함하는 것으로 알려진 초기 범위 f의 왼쪽 경계.</target>
        </trans-unit>
        <trans-unit id="7a57a5cca8f620ef653afa4677312603d0eb35a4" translate="yes" xml:space="preserve">
          <source>Left justify &lt;code&gt;s&lt;/code&gt; in a field &lt;code&gt;width&lt;/code&gt; characters wide. &lt;code&gt;fillChar&lt;/code&gt; is the character that will be used to fill up the space in the field that &lt;code&gt;s&lt;/code&gt; doesn't fill.</source>
          <target state="translated">왼쪽 정당화 &lt;code&gt;s&lt;/code&gt; 필드에서 &lt;code&gt;width&lt;/code&gt; 넓은 문자. &lt;code&gt;fillChar&lt;/code&gt; 는 그 분야에서 공간을 채우기 위해 사용되는 문자 &lt;code&gt;s&lt;/code&gt; 기입하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e252b9f8988cde95614457fcc99883dd09f1324a" translate="yes" xml:space="preserve">
          <source>Left justify the result in the field. It overrides any 0 flag.</source>
          <target state="translated">필드에서 결과를 왼쪽으로 맞 춥니 다. 0 플래그를 대체합니다.</target>
        </trans-unit>
        <trans-unit id="bf867e91cd944e7c2c4d6696d9a4bdcaa30b2078" translate="yes" xml:space="preserve">
          <source>Legacy module unit test handler</source>
          <target state="translated">레거시 모듈 유닛 테스트 핸들러</target>
        </trans-unit>
        <trans-unit id="71c39ee5d287555af96dcd575a5c855e58330dd8" translate="yes" xml:space="preserve">
          <source>Lego-like pieces that can be used to assemble application-specific allocators. The real allocation smarts are occurring at this level. This layer is of interest to advanced applications that want to configure their own allocators. A good illustration of typical uses of these building blocks is module &lt;a href=&quot;std_experimental_allocator_showcase&quot;&gt;&lt;code&gt;std.experimental.allocator.showcase&lt;/code&gt;&lt;/a&gt; which defines a collection of frequently- used preassembled allocator objects. The implementation and documentation entry point is &lt;a href=&quot;std_experimental_allocator_building_blocks&quot;&gt;&lt;code&gt;std.experimental.allocator.building_blocks&lt;/code&gt;&lt;/a&gt;. By design, the primitives of the static interface have the same signatures as the &lt;a href=&quot;#IAllocator&quot;&gt;&lt;code&gt;IAllocator&lt;/code&gt;&lt;/a&gt; primitives but are for the most part optional and driven by static introspection. The parameterized class &lt;a href=&quot;#CAllocatorImpl&quot;&gt;&lt;code&gt;CAllocatorImpl&lt;/code&gt;&lt;/a&gt; offers an immediate and useful means to package a static low-level allocator into an implementation of &lt;a href=&quot;#IAllocator&quot;&gt;&lt;code&gt;IAllocator&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">응용 프로그램 별 할당자를 조립하는 데 사용할 수있는 레고와 같은 조각. 실제 할당 스마트는이 수준에서 발생합니다. 이 계층은 자체 할당자를 구성하려는 고급 응용 프로그램에 관심이 있습니다. 이러한 빌딩 블록의 일반적인 사용에 대한 좋은 예는 &lt;a href=&quot;std_experimental_allocator_showcase&quot;&gt; &lt;code&gt;std.experimental.allocator.showcase&lt;/code&gt; &lt;/a&gt; 모듈입니다.이 모듈 은 자주 사용되는 사전 조립 된 할당 자 객체의 모음을 정의합니다. 구현 및 문서 진입 점은 &lt;a href=&quot;std_experimental_allocator_building_blocks&quot;&gt; &lt;code&gt;std.experimental.allocator.building_blocks&lt;/code&gt; &lt;/a&gt; 입니다. 설계 상 정적 인터페이스의 프리미티브는 &lt;a href=&quot;#IAllocator&quot;&gt; &lt;code&gt;IAllocator&lt;/code&gt; &lt;/a&gt; 프리미티브 와 동일한 시그니처를 갖지만 대부분 선택적이며 정적 인트로 스펙 션에 의해 구동됩니다. 매개 변수화 된 클래스 &lt;a href=&quot;#CAllocatorImpl&quot;&gt; &lt;code&gt;CAllocatorImpl&lt;/code&gt; &lt;/a&gt;정적 저수준 할당자를 &lt;a href=&quot;#IAllocator&quot;&gt; &lt;code&gt;IAllocator&lt;/code&gt; &lt;/a&gt; 구현으로 패키지화 하는 즉각적이고 유용한 수단을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="3bade34ecbc5d996b2f301ebd4ba689e81c7c9ea" translate="yes" xml:space="preserve">
          <source>Length</source>
          <target state="translated">Length</target>
        </trans-unit>
        <trans-unit id="548a74b725f624c9fdb6b48fe948844ad4ba15cf" translate="yes" xml:space="preserve">
          <source>Length &amp;amp; Index</source>
          <target state="translated">길이 및 색인</target>
        </trans-unit>
        <trans-unit id="a8a261464d376ab7ec4d0aff6dd2a8ddccaf2ea4" translate="yes" xml:space="preserve">
          <source>Length of the source array.</source>
          <target state="translated">소스 배열의 길이입니다.</target>
        </trans-unit>
        <trans-unit id="fa58f0cd5f0d162bcdd0bb8e1a9f9fab638355f0" translate="yes" xml:space="preserve">
          <source>Length. Only if &lt;code&gt;hasLength!Source&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;</source>
          <target state="translated">길이. &lt;code&gt;hasLength!Source&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 인 경우에만</target>
        </trans-unit>
        <trans-unit id="2932c65a2b38d62eb561a2ad9e13e95ab6d5d8aa" translate="yes" xml:space="preserve">
          <source>Lepcha</source>
          <target state="translated">Lepcha</target>
        </trans-unit>
        <trans-unit id="89c036bdcb0bbedc59d932a4fa7bc23acfe0d446" translate="yes" xml:space="preserve">
          <source>Let the application define a custom write method for RTP data</source>
          <target state="translated">애플리케이션이 RTP 데이터에 대한 사용자 정의 쓰기 방법을 정의하도록합니다.</target>
        </trans-unit>
        <trans-unit id="937ea74e8f69c6f2d7124bc18246f8a660b1dec7" translate="yes" xml:space="preserve">
          <source>Let the application define custom chunk data pointer</source>
          <target state="translated">응용 프로그램이 사용자 지정 청크 데이터 포인터를 정의하도록합니다.</target>
        </trans-unit>
        <trans-unit id="5e0bcf64b358e91eb969a7948fad248efcb9751a" translate="yes" xml:space="preserve">
          <source>Let the server initiate the shutdown</source>
          <target state="translated">서버가 종료를 시작하게하십시오</target>
        </trans-unit>
        <trans-unit id="a89a34ec4663e88cca1a7e3de00a3e3430d08014" translate="yes" xml:space="preserve">
          <source>Let's consider the file is ASCII encoded with LF EOL. In general case we should use</source>
          <target state="translated">파일이 LF EOL로 ASCII 인코딩 된 것으로 가정하십시오. 일반적으로 우리는 사용해야합니다</target>
        </trans-unit>
        <trans-unit id="d07a72b4d32963582b6eae7916f61a4b8e60a331" translate="yes" xml:space="preserve">
          <source>Let's first make some observations and assumptions about errors:</source>
          <target state="translated">먼저 오류에 대한 몇 가지 관찰과 가정을하겠습니다.</target>
        </trans-unit>
        <trans-unit id="ee14050617b7b58e17aabccd61c241ccdafc6379" translate="yes" xml:space="preserve">
          <source>Letter</source>
          <target state="translated">Letter</target>
        </trans-unit>
        <trans-unit id="9396bf9200a37a33be1f189b9b3f63cbfdb0cb05" translate="yes" xml:space="preserve">
          <source>Letter case specifier.</source>
          <target state="translated">대소 문자 구분자.</target>
        </trans-unit>
        <trans-unit id="8ec2ddae534f2e9f786626d1461f045b3ea7a132" translate="yes" xml:space="preserve">
          <source>Letter_Number</source>
          <target state="translated">Letter_Number</target>
        </trans-unit>
        <trans-unit id="cfcd1e23ef9e122ab3fba825014a84415f49edb0" translate="yes" xml:space="preserve">
          <source>Letterlike Symbols</source>
          <target state="translated">글자 모양의 기호</target>
        </trans-unit>
        <trans-unit id="4ed7dbd610162ec2a8bbd97befecda7912a54468" translate="yes" xml:space="preserve">
          <source>Level 1 is fastest and the most memory hungry (a bit array).</source>
          <target state="translated">레벨 1이 가장 빠르며 메모리 사용량이 가장 많습니다 (비트 배열).</target>
        </trans-unit>
        <trans-unit id="fc694144a5b7ef693cb1ee99fd99fa168f951953" translate="yes" xml:space="preserve">
          <source>Level 4 is the slowest and has the smallest footprint.</source>
          <target state="translated">레벨 4가 가장 느리고 발자국이 가장 작습니다.</target>
        </trans-unit>
        <trans-unit id="75bac2861cadd9b0f5864b4833944f933a0bf887" translate="yes" xml:space="preserve">
          <source>Level 4 stays very practical (being faster and more predictable) compared to using direct lookup on the &lt;code&gt;set&lt;/code&gt; itself.</source>
          <target state="translated">레벨 4는 &lt;code&gt;set&lt;/code&gt; 자체 에서 직접 조회를 사용하는 것에 비해 매우 실용적입니다 (보다 빠르고 예측 가능) .</target>
        </trans-unit>
        <trans-unit id="8ad20abdb83c4a21d224a891c2b7c7c494f6fcf2" translate="yes" xml:space="preserve">
          <source>Lexical</source>
          <target state="translated">Lexical</target>
        </trans-unit>
        <trans-unit id="476ef6248b6dd64f9ad5670dee5d53dccca0f8e8" translate="yes" xml:space="preserve">
          <source>Lexical - documentation comments are identified and attached to tokens.</source>
          <target state="translated">어휘-문서 주석이 식별되어 토큰에 첨부됩니다.</target>
        </trans-unit>
        <trans-unit id="b605249a5e48b6c693e6ec1b2b1e13428184994b" translate="yes" xml:space="preserve">
          <source>Lexical Syntax</source>
          <target state="translated">어휘 구문</target>
        </trans-unit>
        <trans-unit id="6b297fc7c475ea0278237a59c66e5996eac30867" translate="yes" xml:space="preserve">
          <source>Lhs</source>
          <target state="translated">Lhs</target>
        </trans-unit>
        <trans-unit id="fc8137f8a9e13c5b635a4ba40e4e3901d90fcbaa" translate="yes" xml:space="preserve">
          <source>Lhs &lt;code&gt;lhs&lt;/code&gt;</source>
          <target state="translated">Lhs &lt;code&gt;lhs&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8bdc1af0abe67308adf385d7cdcceabf9cb6ab55" translate="yes" xml:space="preserve">
          <source>Lhs &lt;strong id=&quot;hookOpCast&quot;&gt;hookOpCast&lt;/strong&gt;(Lhs, Rhs)(Rhs rhs);</source>
          <target state="translated">Lhs &lt;strong id=&quot;hookOpCast&quot;&gt;hookOpCast&lt;/strong&gt; (Lhs, Rhs) (Rhs rhs);</target>
        </trans-unit>
        <trans-unit id="e40077902f44f1b09ccb2459863a81b02022efb2" translate="yes" xml:space="preserve">
          <source>Lhs &lt;strong id=&quot;onLowerBound&quot;&gt;onLowerBound&lt;/strong&gt;(Rhs, T)(Rhs rhs, T bound);</source>
          <target state="translated">Lhs &lt;strong id=&quot;onLowerBound&quot;&gt;onLowerBound&lt;/strong&gt; (Rhs, T) (Rhs rhs, T 경계);</target>
        </trans-unit>
        <trans-unit id="df063bf53c8e8cb3fd9aa4249d1fa6357775527c" translate="yes" xml:space="preserve">
          <source>Library used incorrectly</source>
          <target state="translated">라이브러리가 잘못 사용되었습니다</target>
        </trans-unit>
        <trans-unit id="de13bf1ab0b419f34cb1b3b43e094c84009a42db" translate="yes" xml:space="preserve">
          <source>License:</source>
          <target state="translated">License:</target>
        </trans-unit>
        <trans-unit id="a50ab4cf4ccadacece6a685a96a8d2bf5b03f087" translate="yes" xml:space="preserve">
          <source>Licensed under the Boost License 1.0.</source>
          <target state="translated">Boost License 1.0에 따라 라이센스가 부여되었습니다.</target>
        </trans-unit>
        <trans-unit id="ee1ab8e4255c8f881c480d8d54bca4a8a2c24209" translate="yes" xml:space="preserve">
          <source>Lifetime Management</source>
          <target state="translated">평생 관리</target>
        </trans-unit>
        <trans-unit id="e353dd7cee6d59762b4ca39b60327e65283ae7b3" translate="yes" xml:space="preserve">
          <source>Lifetime of Temporaries</source>
          <target state="translated">일시적인 일생</target>
        </trans-unit>
        <trans-unit id="ec6b2b953ecf8f329d7e04b783de42bfc3652a53" translate="yes" xml:space="preserve">
          <source>Lifetimes</source>
          <target state="translated">Lifetimes</target>
        </trans-unit>
        <trans-unit id="4d7185d6c7e3e5b1495e2c640489530ecb9b7900" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#ReplaceType&quot;&gt;&lt;code&gt;ReplaceType&lt;/code&gt;&lt;/a&gt;, but does not perform replacement in types for which &lt;code&gt;pred&lt;/code&gt; evaluates to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#ReplaceType&quot;&gt; &lt;code&gt;ReplaceType&lt;/code&gt; &lt;/a&gt; 과 유사 하지만 &lt;code&gt;pred&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 로 평가 되는 유형에서는 교체를 수행하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="ae0e0fae4102ad20e6be08ef2f2f1156324f621f" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#safe-functions&quot;&gt;safe functions&lt;/a&gt;, trusted functions have &lt;a href=&quot;#safe-interfaces&quot;&gt;safe interfaces&lt;/a&gt;. Unlike safe functions, this is not enforced by restrictions on the function body. Instead, it is the responsibility of the programmer to ensure that the interface of a trusted function is safe.</source>
          <target state="translated">&lt;a href=&quot;#safe-functions&quot;&gt;안전한 함수&lt;/a&gt; 와 마찬가지로 신뢰할 수있는 함수에는 &lt;a href=&quot;#safe-interfaces&quot;&gt;안전한 인터페이스가&lt;/a&gt; 있습니다. 안전한 함수와 달리 이것은 함수 본문에 대한 제한으로 시행되지 않습니다. 대신 신뢰할 수있는 기능의 인터페이스가 안전한지 확인하는 것은 프로그래머의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="bd33998b0ace4c944f0efc3096535b923482d5ba" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#soundexer&quot;&gt;&lt;code&gt;soundexer&lt;/code&gt;&lt;/a&gt;, but with different parameters and return value.</source>
          <target state="translated">&lt;a href=&quot;#soundexer&quot;&gt; &lt;code&gt;soundexer&lt;/code&gt; &lt;/a&gt; 와 비슷 하지만 매개 변수와 반환 값이 다릅니다.</target>
        </trans-unit>
        <trans-unit id="2606b35e5c6c0f3c9d736f7c373c8b55857520eb" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;contains&lt;/code&gt;, but the value is specified before the range.</source>
          <target state="translated">등 &lt;code&gt;contains&lt;/code&gt; 있지만, 값의 범위 전에 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="2b288cc6cc51f7928ab9ad8fe1740aac1c58fab0" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;isSorted&lt;/code&gt;, returns &lt;code&gt;true&lt;/code&gt; if the given &lt;code&gt;values&lt;/code&gt; are ordered according to the comparison operation &lt;code&gt;less&lt;/code&gt;. Unlike &lt;code&gt;isSorted&lt;/code&gt;, takes values directly instead of structured in a range.</source>
          <target state="translated">&lt;code&gt;isSorted&lt;/code&gt; 와 마찬가지로 주어진 &lt;code&gt;values&lt;/code&gt; 이 비교 연산 &lt;code&gt;less&lt;/code&gt; 에 따라 정렬 되면 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 . &lt;code&gt;isSorted&lt;/code&gt; 와 달리 범위 내에서 구조화되는 대신 직접 값을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="50325585f34ee66ce178dbad88dde192b85ee604" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;take&lt;/code&gt;, but assumes the given range actually has</source>
          <target state="translated">마찬가지로 &lt;code&gt;take&lt;/code&gt; 있지만, 주어진 범위가 실제로 가지고 가정</target>
        </trans-unit>
        <trans-unit id="e27a10d2aabce008faa1b8b7ac1f936d6cc25877" translate="yes" xml:space="preserve">
          <source>Like aggregates and functions, manifest constant and variable declarations can have template parameters, providing there is an &lt;a href=&quot;declaration#Initializer&quot;&gt;&lt;i&gt;Initializer&lt;/i&gt;&lt;/a&gt;:</source>
          <target state="translated">집계 및 함수와 마찬가지로 매니페스트 상수 및 변수 선언은 &lt;a href=&quot;declaration#Initializer&quot;&gt;&lt;i&gt;Initializer&lt;/i&gt;&lt;/a&gt; 가있는 경우 템플릿 매개 변수를 가질 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bbdaeb1b36bc514e26a308358d8185b3a8585d1b" translate="yes" xml:space="preserve">
          <source>Like bodies of &lt;a href=&quot;#ConditionalDeclaration&quot;&gt;&lt;i&gt;ConditionalDeclaration&lt;/i&gt;&lt;/a&gt;s, a &lt;code&gt;static foreach&lt;/code&gt; body does not introduce a new scope. Therefore, it can be used to generate declarations:</source>
          <target state="translated">&lt;a href=&quot;#ConditionalDeclaration&quot;&gt;&lt;i&gt;ConditionalDeclaration&lt;/i&gt;&lt;/a&gt; 의 본문과 마찬가지로 &lt;code&gt;static foreach&lt;/code&gt; 본문에는 새로운 범위가 도입되지 않습니다. 따라서 선언을 생성하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="596f012fcab74c7f7a0fbb5751d3954bb4881d08" translate="yes" xml:space="preserve">
          <source>Like findBestMatch, iterate possible template candidates, but just looks only the necessity of type inference.</source>
          <target state="translated">findBestMatch와 마찬가지로 가능한 템플릿 후보를 반복하지만 형식 유추의 필요성 만 보입니다.</target>
        </trans-unit>
        <trans-unit id="8d23b1454364b12f21ad47d5ebb3ea9cdcdf0bab" translate="yes" xml:space="preserve">
          <source>Like in &lt;a href=&quot;#replaceFirst&quot;&gt;&lt;code&gt;replaceFirst&lt;/code&gt;&lt;/a&gt; family of functions there is an overload for the substitution guided by the &lt;code&gt;format&lt;/code&gt; string and the one with the user defined callback.</source>
          <target state="translated">&lt;a href=&quot;#replaceFirst&quot;&gt; &lt;code&gt;replaceFirst&lt;/code&gt; &lt;/a&gt; 함수 계열 에서와 같이 &lt;code&gt;format&lt;/code&gt; 문자열과 사용자 정의 콜백이 있는 대체 문자열에 의해 대체되는 과부하가 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc66fa44d8868ee404a0494db572ba397dd68bd7" translate="yes" xml:space="preserve">
          <source>Like most parsers, it consumes its argument. This means:</source>
          <target state="translated">대부분의 파서와 마찬가지로 인수를 사용합니다. 이것은 다음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="45079d6fbbbd7e92a8db7a1ac24f7a5f82b14899" translate="yes" xml:space="preserve">
          <source>Like xoff(), but returns handle with which to patch 'offset' value.</source>
          <target state="translated">xoff ()와 비슷하지만 'offset'값을 패치 할 핸들을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2e7f519163cff0e363c25131c1b51c316fcca76a" translate="yes" xml:space="preserve">
          <source>Likewise, declare a boolean &lt;code&gt;rt_envvars_enabled&lt;/code&gt; to enable configuration via the environment variable &lt;code&gt;DRT_GCOPT&lt;/code&gt;:</source>
          <target state="translated">마찬가지로 환경 변수 &lt;code&gt;DRT_GCOPT&lt;/code&gt; 를 통해 구성을 가능하게하려면 부울 &lt;code&gt;rt_envvars_enabled&lt;/code&gt; 를 선언하십시오 .</target>
        </trans-unit>
        <trans-unit id="05ceb7325c8a826b5f89f8751e8a978ab3c8670c" translate="yes" xml:space="preserve">
          <source>Likewise, declare a boolean rt_envvars_enabled to enable configuration via the environment variable &lt;code&gt;DRT_&lt;/code&gt; followed by the option name, e.g. &lt;code&gt;DRT_GCOPT&lt;/code&gt;:</source>
          <target state="translated">마찬가지로, 부울 환경 변수를 통해 구성을 가능하게 rt_envvars_enabled 선언한다 &lt;code&gt;DRT_&lt;/code&gt; 는 옵션 이름 다음에, 예를 들어 &lt;code&gt;DRT_GCOPT&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0be788e5cd03f159b54ca8ea573d4290d5478fb0" translate="yes" xml:space="preserve">
          <source>Limbu</source>
          <target state="translated">Limbu</target>
        </trans-unit>
        <trans-unit id="a7c04c64ed3f2a9374590c76c50d3b7f1b18e3da" translate="yes" xml:space="preserve">
          <source>Limitations</source>
          <target state="translated">Limitations</target>
        </trans-unit>
        <trans-unit id="f0b7d22c2b2095983184f3f1451012e2dda7ffbe" translate="yes" xml:space="preserve">
          <source>Limited function template instantiation for using fd.leastAsSpecialized()</source>
          <target state="translated">fd.leastAsSpecialized () 사용을위한 제한된 함수 템플릿 인스턴스화</target>
        </trans-unit>
        <trans-unit id="575a8a2e7f326685ced3cd6e4c6b6e3bf22c896a" translate="yes" xml:space="preserve">
          <source>Limiting a program to this subset of runtime features is useful when targeting constrained environments where the use of such features is not practical or possible.</source>
          <target state="translated">프로그램을 이러한 런타임 기능의 하위 집합으로 제한하면 이러한 기능을 사용할 수 없거나 제한된 환경을 대상으로하는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="94b2ecf33206fff8253255f672c5f85e4a9fb00a" translate="yes" xml:space="preserve">
          <source>Limits &amp;amp; machine dependent stuff.</source>
          <target state="translated">한계 및 기계 의존 물.</target>
        </trans-unit>
        <trans-unit id="79a87925d2fef04b39fdff35de5098824ce21fe8" translate="yes" xml:space="preserve">
          <source>Line comments terminate at the end of the line.</source>
          <target state="translated">줄 설명은 줄 끝에서 끝납니다.</target>
        </trans-unit>
        <trans-unit id="7f39a27437a342a87766f7dbc95e14bd677b6b05" translate="yes" xml:space="preserve">
          <source>Line inside of &lt;code&gt;file&lt;/code&gt; that called &lt;code&gt;_d_HookTraceImpl&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;_d_HookTraceImpl&lt;/code&gt; 이라는 &lt;code&gt;file&lt;/code&gt; 내부 줄</target>
        </trans-unit>
        <trans-unit id="9f11a4e0ac04365ef99741245ab0220d1dcbe4cc" translate="yes" xml:space="preserve">
          <source>Line number at which parse failure occurred</source>
          <target state="translated">구문 분석 실패가 발생한 행 번호</target>
        </trans-unit>
        <trans-unit id="cafda09317daae42601c48fe90d8c9c7a0d5763e" translate="yes" xml:space="preserve">
          <source>Line separator (&lt;code&gt;'\n'&lt;/code&gt; by default).</source>
          <target state="translated">줄 구분 기호 ( 기본적으로 &lt;code&gt;'\n'&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="9062ccfc4d55904c6dc14247f7eba3c693cbc576" translate="yes" xml:space="preserve">
          <source>Line separator (&lt;code&gt;'\n'&lt;/code&gt; by default). Use &lt;a href=&quot;std_ascii#newline&quot;&gt;&lt;code&gt;std.ascii.newline&lt;/code&gt;&lt;/a&gt; for portability (unless the file was opened in text mode).</source>
          <target state="translated">줄 구분 기호 ( 기본적으로 &lt;code&gt;'\n'&lt;/code&gt; ). 파일을 텍스트 모드로 열지 않은 경우 이식성을 위해 &lt;a href=&quot;std_ascii#newline&quot;&gt; &lt;code&gt;std.ascii.newline&lt;/code&gt; &lt;/a&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="562e54a009e2e7477315da16ad031e93fffe67de" translate="yes" xml:space="preserve">
          <source>Line terminator (by default, &lt;code&gt;'\n'&lt;/code&gt;).</source>
          <target state="translated">줄 종결 자 (기본적으로 &lt;code&gt;'\n'&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="94351b3bdac97b327954428ec91bd94c19cb0065" translate="yes" xml:space="preserve">
          <source>Line terminator (by default, &lt;code&gt;'\n'&lt;/code&gt;). Use &lt;a href=&quot;std_ascii#newline&quot;&gt;&lt;code&gt;std.ascii.newline&lt;/code&gt;&lt;/a&gt; for portability (unless the file was opened in text mode).</source>
          <target state="translated">줄 종결 자 (기본적으로 &lt;code&gt;'\n'&lt;/code&gt; ) 파일을 텍스트 모드로 열지 않은 경우 이식성을 위해 &lt;a href=&quot;std_ascii#newline&quot;&gt; &lt;code&gt;std.ascii.newline&lt;/code&gt; &lt;/a&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="5a4bacbb1e223a3267919fd0799232ddbd34aa37" translate="yes" xml:space="preserve">
          <source>Line_Separator</source>
          <target state="translated">Line_Separator</target>
        </trans-unit>
        <trans-unit id="e7df5d5ce001a36983b9d9236abbf093184cc21e" translate="yes" xml:space="preserve">
          <source>Linear B Ideograms</source>
          <target state="translated">선형 B 이데 오 그램</target>
        </trans-unit>
        <trans-unit id="3725027407be653f4f6f73e1060fa298f81067d5" translate="yes" xml:space="preserve">
          <source>Linear B Syllabary</source>
          <target state="translated">선형 B 실라 바리</target>
        </trans-unit>
        <trans-unit id="4aec3d1c77926be5858da9de4639f131c32b6290" translate="yes" xml:space="preserve">
          <source>Linear Congruential Engines</source>
          <target state="translated">선형 합동 엔진</target>
        </trans-unit>
        <trans-unit id="2c0ea1ac864923255fd78db23ede4ab7573a54c1" translate="yes" xml:space="preserve">
          <source>Linear Congruential generator.</source>
          <target state="translated">선형 합동 발생기.</target>
        </trans-unit>
        <trans-unit id="3835d6a4986ea73e86742e9a7f3ef9b58c7dcb04" translate="yes" xml:space="preserve">
          <source>Linear_B</source>
          <target state="translated">Linear_B</target>
        </trans-unit>
        <trans-unit id="f9c093b4e3f67b0f50e7c549106bb82a8bb17374" translate="yes" xml:space="preserve">
          <source>Lines of text that directly follow a quoted line are considered part of the quote:</source>
          <target state="translated">인용 된 줄 바로 다음에 나오는 텍스트 줄은 인용의 일부로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="33ffd5e6d3f1a75027023ae7e4429a6fa5fe0802" translate="yes" xml:space="preserve">
          <source>Linger information for use with SocketOption.LINGER.</source>
          <target state="translated">SocketOption.LINGER와 함께 사용하기위한 링거 정보.</target>
        </trans-unit>
        <trans-unit id="6efcfa4383191737a4fd58b78fbbf6afc2429322" translate="yes" xml:space="preserve">
          <source>Linger on close if unsent data is present</source>
          <target state="translated">보내지 않은 데이터가있는 경우 닫힘</target>
        </trans-unit>
        <trans-unit id="aa29d5efd34035837a47ccdc40b4c4e6e767dff3" translate="yes" xml:space="preserve">
          <source>Linger time.</source>
          <target state="translated">웃음 시간.</target>
        </trans-unit>
        <trans-unit id="c07936d974c4dc9cedda3fb3c4619d6d1e2130c2" translate="yes" xml:space="preserve">
          <source>Linkage Attribute</source>
          <target state="translated">연계 속성</target>
        </trans-unit>
        <trans-unit id="5d5a19b223d7bf77f8ce49dd34f4ecf21571d14e" translate="yes" xml:space="preserve">
          <source>LinkageType</source>
          <target state="translated">LinkageType</target>
        </trans-unit>
        <trans-unit id="f89598da16ee5888741184d17b4b7e6268f1f50e" translate="yes" xml:space="preserve">
          <source>Linker directives are only supported for MS-COFF output.</source>
          <target state="translated">링커 지시문은 MS-COFF 출력에만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="014bcd654c60d5250fad2123b073b9c0ac3340f6" translate="yes" xml:space="preserve">
          <source>Links</source>
          <target state="translated">Links</target>
        </trans-unit>
        <trans-unit id="f14f99e5af534b7ca9839de375475b98445e0f1b" translate="yes" xml:space="preserve">
          <source>Links to D documentation generators</source>
          <target state="translated">D 문서 생성기 링크</target>
        </trans-unit>
        <trans-unit id="83ad8510bbd3f22363d068e1c96f82fd0fcccd31" translate="yes" xml:space="preserve">
          <source>Linux</source>
          <target state="translated">Linux</target>
        </trans-unit>
        <trans-unit id="609a0fb2d74c6bd2b8aaca86410e249f1dbed0f8" translate="yes" xml:space="preserve">
          <source>Linux also supports an abstract address namespace, in which addresses are independent of the file system. A socket address is abstract iff &lt;code&gt;path&lt;/code&gt; starts with a null byte (&lt;code&gt;'\0'&lt;/code&gt;). Null bytes in other positions of an abstract address are allowed and have no special meaning.</source>
          <target state="translated">Linux는 주소가 파일 시스템과 독립적 인 추상 주소 네임 스페이스도 지원합니다. 소켓 주소는 &lt;code&gt;path&lt;/code&gt; 가 널 바이트 ( &lt;code&gt;'\0'&lt;/code&gt; ) 로 시작하는 경우 추상 입니다. 추상 주소의 다른 위치에있는 널 바이트는 허용되며 특별한 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="79f9578b547044b5676affbe3022bba5ca82f0a9" translate="yes" xml:space="preserve">
          <source>Linux, FreeBSD and OS X</source>
          <target state="translated">리눅스, FreeBSD 및 OS X</target>
        </trans-unit>
        <trans-unit id="053354be10bdf27de5999e46f82f09929ff8e8ba" translate="yes" xml:space="preserve">
          <source>Linux,OpenBSD,Solaris-Only</source>
          <target state="translated">Linux,OpenBSD,Solaris-Only</target>
        </trans-unit>
        <trans-unit id="d5716bdcdebf98cda6d6ad1eefe71dfeb870afa8" translate="yes" xml:space="preserve">
          <source>Linux,OpenBSD-Only</source>
          <target state="translated">Linux,OpenBSD-Only</target>
        </trans-unit>
        <trans-unit id="5c60e74c7c3bd1691653556adba9eac9ee819b43" translate="yes" xml:space="preserve">
          <source>Linux-Only</source>
          <target state="translated">Linux-Only</target>
        </trans-unit>
        <trans-unit id="659c4d46f392b5779315d4148506c9ae066a3900" translate="yes" xml:space="preserve">
          <source>List is a complete package of functions to deal with singly linked lists of pointers or integers.</source>
          <target state="translated">List는 단독으로 링크 된 포인터 또는 정수 목록을 처리하는 완전한 기능 패키지입니다.</target>
        </trans-unit>
        <trans-unit id="2169dc30c9f5d1a288648fed4339b09f7a36c11c" translate="yes" xml:space="preserve">
          <source>List items can include content like new paragraphs, headings, embedded code, or child list items. Simply indent the content to match the indent of the text after the list symbol:</source>
          <target state="translated">목록 항목에는 새 단락, 제목, 포함 된 코드 또는 자식 목록 항목과 같은 내용이 포함될 수 있습니다. 목록 기호 뒤의 텍스트 들여 쓰기와 일치하도록 내용을 들여 쓰기 만하면됩니다.</target>
        </trans-unit>
        <trans-unit id="5b80c969520195f49a23d681c7e470ffeb2f8e58" translate="yes" xml:space="preserve">
          <source>List of Time Zones</source>
          <target state="translated">시간대 목록</target>
        </trans-unit>
        <trans-unit id="47f0d42b5eabb30594dcebf877a48158279b594c" translate="yes" xml:space="preserve">
          <source>List of non-inherited methods.</source>
          <target state="translated">상속되지 않은 메소드 목록</target>
        </trans-unit>
        <trans-unit id="58d70697d21566547884eb0d25632b01c5aa1e1d" translate="yes" xml:space="preserve">
          <source>List of other symbols and URLs to related items.</source>
          <target state="translated">관련 항목에 대한 다른 기호 및 URL 목록</target>
        </trans-unit>
        <trans-unit id="c518fb067439705f3ff5fa5b4a62b9be3afa31ae" translate="yes" xml:space="preserve">
          <source>Listen</source>
          <target state="translated">Listen</target>
        </trans-unit>
        <trans-unit id="a6d4e1cf6d50aec9a81f8621becb65e0c7bff808" translate="yes" xml:space="preserve">
          <source>Listen for an incoming connection. &lt;code&gt;bind&lt;/code&gt; must be called before you can &lt;code&gt;listen&lt;/code&gt;. The &lt;code&gt;backlog&lt;/code&gt; is a request of how many pending incoming connections are queued until &lt;code&gt;accept&lt;/code&gt;ed.</source>
          <target state="translated">들어오는 연결을 듣습니다. &lt;code&gt;listen&lt;/code&gt; 전에 &lt;code&gt;bind&lt;/code&gt; 를 호출해야합니다 . &lt;code&gt;backlog&lt;/code&gt; 그는 &lt;code&gt;accept&lt;/code&gt; 될 때까지 대기중인 수신 연결 수에 대한 요청입니다 .</target>
        </trans-unit>
        <trans-unit id="57c9502a7d7d48fd4a86b45fefb2b163491c3ae1" translate="yes" xml:space="preserve">
          <source>Lists</source>
          <target state="translated">Lists</target>
        </trans-unit>
        <trans-unit id="b1c9beb2cd4d7b1946bcd4731626c18eb9ca18ed" translate="yes" xml:space="preserve">
          <source>Lists any known bugs.</source>
          <target state="translated">알려진 버그를 나열합니다.</target>
        </trans-unit>
        <trans-unit id="2b60e4e3728775ac5fb1376234a7439665441c9c" translate="yes" xml:space="preserve">
          <source>Lists exceptions thrown and under what circumstances they are thrown.</source>
          <target state="translated">발생 된 예외와 발생 된 상황을 나열합니다.</target>
        </trans-unit>
        <trans-unit id="fb8d3829a5b09c1f096a8c468af41889c5c3afa6" translate="yes" xml:space="preserve">
          <source>Lists the author(s) of the declaration.</source>
          <target state="translated">선언의 작성자를 나열합니다.</target>
        </trans-unit>
        <trans-unit id="a5b64a6325e7fd542159a3c84889b713d8f57a43" translate="yes" xml:space="preserve">
          <source>Lisu</source>
          <target state="translated">Lisu</target>
        </trans-unit>
        <trans-unit id="cbb1daff2df9ed745e8c2f602eb168c31d37c723" translate="yes" xml:space="preserve">
          <source>Literal backslash:</source>
          <target state="translated">리터럴 백 슬래시 :</target>
        </trans-unit>
        <trans-unit id="1eed1a889b6fdc57925d393d26612d90c4362fd7" translate="yes" xml:space="preserve">
          <source>Literal backslash: &lt;code&gt;\&lt;/code&gt;</source>
          <target state="translated">리터럴 백 슬래시 : &lt;code&gt;\&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="379a53a04ce7502b5938fbcc362e60ac11c2521f" translate="yes" xml:space="preserve">
          <source>Literal double-quote: &lt;code&gt;&quot;&lt;/code&gt;</source>
          <target state="translated">리터럴 큰 따옴표 : &lt;code&gt;&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="62a779e4049ed74f81ccd9b4787d528847e87647" translate="yes" xml:space="preserve">
          <source>Literal question mark: &lt;code&gt;?&lt;/code&gt;</source>
          <target state="translated">리터럴 물음표 : &lt;code&gt;?&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b7496c0677fb192ed8cf7df54298bd439105963f" translate="yes" xml:space="preserve">
          <source>Literal single-quote: &lt;code&gt;'&lt;/code&gt;</source>
          <target state="translated">리터럴 작은 따옴표 : &lt;code&gt;'&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c7ba7dcf662374aafe652b03d75cb8f6024519d9" translate="yes" xml:space="preserve">
          <source>Literals</source>
          <target state="translated">Literals</target>
        </trans-unit>
        <trans-unit id="4f2ba44c3be0c8a5d7a4cbc08264bfdf2061b1ea" translate="yes" xml:space="preserve">
          <source>Literals do not match &lt;code&gt;ref&lt;/code&gt; or &lt;code&gt;out&lt;/code&gt; parameters.</source>
          <target state="translated">리터럴은 &lt;code&gt;ref&lt;/code&gt; 또는 &lt;code&gt;out&lt;/code&gt; 매개 변수 와 일치하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="131c60cf3a2f25a830939a99e6f47031b880a38c" translate="yes" xml:space="preserve">
          <source>Little endian byte order</source>
          <target state="translated">리틀 엔디안 바이트 순서</target>
        </trans-unit>
        <trans-unit id="b0a1256f2ee331aeacbc004b22444b172a7f4623" translate="yes" xml:space="preserve">
          <source>Live Functions</source>
          <target state="translated">라이브 기능</target>
        </trans-unit>
        <trans-unit id="91575e88330ca0a393b09df24c2f9572b830580f" translate="yes" xml:space="preserve">
          <source>Ll</source>
          <target state="translated">Ll</target>
        </trans-unit>
        <trans-unit id="aea4161c704cbae70375999c4bfe2ae3b29ed465" translate="yes" xml:space="preserve">
          <source>Lm</source>
          <target state="translated">Lm</target>
        </trans-unit>
        <trans-unit id="bb5cf318ffa3931019af265b70dc5e1329293274" translate="yes" xml:space="preserve">
          <source>Lo</source>
          <target state="translated">Lo</target>
        </trans-unit>
        <trans-unit id="c1fd24450afa2a8ca3ccb54f712f70e15f33b7ed" translate="yes" xml:space="preserve">
          <source>Load An Extension</source>
          <target state="translated">확장로드</target>
        </trans-unit>
        <trans-unit id="fdd8edd214a1cae7f44b10e45c660af957f2b328" translate="yes" xml:space="preserve">
          <source>Load this module.</source>
          <target state="translated">이 모듈을로드하십시오.</target>
        </trans-unit>
        <trans-unit id="80b5c5da98b56af5e41eefd69e7fa8b2a9b575bf" translate="yes" xml:space="preserve">
          <source>Load unaligned vector from address. This is a compiler intrinsic.</source>
          <target state="translated">주소에서 정렬되지 않은 벡터를로드합니다. 이것은 컴파일러 고유의 것입니다.</target>
        </trans-unit>
        <trans-unit id="494260ec047bea19460fac6ca8324736557ff1c6" translate="yes" xml:space="preserve">
          <source>Loadable Extension Thunk</source>
          <target state="translated">로드 가능한 확장 기능</target>
        </trans-unit>
        <trans-unit id="8e0a262d18ece63c9f981e3d7fa4031b25837d39" translate="yes" xml:space="preserve">
          <source>Loads 'val' from memory and returns it. The memory barrier specified by 'ms' is applied to the operation, which is fully sequenced by default. Valid memory orders are MemoryOrder.raw, MemoryOrder.acq, and MemoryOrder.seq.</source>
          <target state="translated">메모리에서 'val'을로드하고 반환합니다. 'ms'로 지정된 메모리 배리어는 작업에 적용되며 기본적으로 완전히 순서가 지정됩니다. 유효한 메모리 순서는 MemoryOrder.raw, MemoryOrder.acq 및 MemoryOrder.seq입니다.</target>
        </trans-unit>
        <trans-unit id="7d13b1375e4f7756b923fbdcc4876658d18b6a55" translate="yes" xml:space="preserve">
          <source>Loads the source buffer from the given read result into &lt;code&gt;this.srcBuffer&lt;/code&gt;.</source>
          <target state="translated">지정된 읽기 결과에서 소스 버퍼를 &lt;code&gt;this.srcBuffer&lt;/code&gt; 로 로드 합니다.</target>
        </trans-unit>
        <trans-unit id="f476477ef22d4251d73a1d30ca07cf1a34cf5284" translate="yes" xml:space="preserve">
          <source>Loc &lt;code&gt;loc&lt;/code&gt;</source>
          <target state="translated">Loc &lt;code&gt;loc&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="77785440d50120aa4076ce82e0ec9ab3821b96ba" translate="yes" xml:space="preserve">
          <source>Loc &lt;strong id=&quot;endloc&quot;&gt;endloc&lt;/strong&gt;;</source>
          <target state="translated">Loc &lt;strong id=&quot;endloc&quot;&gt;endloc&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="a9aae3f07ee9e73ec7a53299b4ed9cc98dfe9890" translate="yes" xml:space="preserve">
          <source>Loc &lt;strong id=&quot;loc&quot;&gt;loc&lt;/strong&gt;;</source>
          <target state="translated">Loc &lt;strong id=&quot;loc&quot;&gt;loc&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="9e7bda6f355468bf77617112c233388cb6f50302" translate="yes" xml:space="preserve">
          <source>Local Static Variables</source>
          <target state="translated">지역 정적 변수</target>
        </trans-unit>
        <trans-unit id="ff5148d6cff2251fbb44fa24ac71e87831f6949a" translate="yes" xml:space="preserve">
          <source>Local Variables</source>
          <target state="translated">지역 변수</target>
        </trans-unit>
        <trans-unit id="5545f9d00ac24df06f6380d708b888c2531d70c7" translate="yes" xml:space="preserve">
          <source>Local communication</source>
          <target state="translated">지역 커뮤니케이션</target>
        </trans-unit>
        <trans-unit id="ac3f517d85e8ae01e24937891c726f4900fea00c" translate="yes" xml:space="preserve">
          <source>Local data (i.e. CompileCtfeFunction*) for module dinterpret</source>
          <target state="translated">모듈 해석에 대한 로컬 데이터 (예 : CompileCtfeFunction *)</target>
        </trans-unit>
        <trans-unit id="9fb1bb63dc564bca6c7a5e9e93d9c43b4a80c6ce" translate="yes" xml:space="preserve">
          <source>Local endpoint &lt;code&gt;Address&lt;/code&gt;.</source>
          <target state="translated">로컬 엔드 포인트 &lt;code&gt;Address&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e9f3aff2a7b7305a6652f831edf8db6d7016ee1e" translate="yes" xml:space="preserve">
          <source>Local names</source>
          <target state="translated">현지 이름</target>
        </trans-unit>
        <trans-unit id="be6a7350c875b8c9d9ccbb7b7de839744ca0d05e" translate="yes" xml:space="preserve">
          <source>Local port number to bind the socket to</source>
          <target state="translated">소켓을 바인딩 할 로컬 포트 ​​번호</target>
        </trans-unit>
        <trans-unit id="e6b918332efc4d2c7cdd3b68e4cf1785c7f99f6d" translate="yes" xml:space="preserve">
          <source>Local sections on the stack</source>
          <target state="translated">스택의 로컬 섹션</target>
        </trans-unit>
        <trans-unit id="a27f49b6ed675d7b78f3cdf3fe5896202b1d4d8a" translate="yes" xml:space="preserve">
          <source>Local variables in functions can be declared as static or &lt;code&gt;__gshared&lt;/code&gt; in which case they are statically allocated rather than being allocated on the stack. As such, their value persists beyond the exit of the function.</source>
          <target state="translated">함수의 지역 변수는 static 또는 &lt;code&gt;__gshared&lt;/code&gt; 로 선언 될 수 있으며이 경우 스택에 할당되지 않고 정적으로 할당됩니다. 따라서 해당 값은 함수 종료 이후에도 지속됩니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
