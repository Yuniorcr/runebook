<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="d">
    <body>
      <group id="d">
        <trans-unit id="d60a34babb78e25baf9b8dca57cc7a6a57f9a62c" translate="yes" xml:space="preserve">
          <source>Locates a dynamic library with the supplied library name and dynamically loads it into the caller's address space. If the library contains a D runtime it will be integrated with the current runtime.</source>
          <target state="translated">제공된 라이브러리 이름으로 동적 라이브러리를 찾아 호출자의 주소 공간에 동적으로로드합니다. 라이브러리에 D 런타임이 포함되어 있으면 현재 런타임과 통합됩니다.</target>
        </trans-unit>
        <trans-unit id="4aacb69957ad5cddfad921cdf6c0106c5bee9a10" translate="yes" xml:space="preserve">
          <source>Location information of the call</source>
          <target state="translated">통화 위치 정보</target>
        </trans-unit>
        <trans-unit id="73ff6861f35f866aec7aeeb578457a4566a437cd" translate="yes" xml:space="preserve">
          <source>Location of deprecation</source>
          <target state="translated">지원 중단 위치</target>
        </trans-unit>
        <trans-unit id="57b91c66877cf6b374fbb1200642748e28d59b53" translate="yes" xml:space="preserve">
          <source>Location of error</source>
          <target state="translated">오류의 위치</target>
        </trans-unit>
        <trans-unit id="4fc6c901a903b2735a7904abeb7a095eb0c123e1" translate="yes" xml:space="preserve">
          <source>Location of the deprecation</source>
          <target state="translated">지원 중단 위치</target>
        </trans-unit>
        <trans-unit id="a6401740004452bbcf66d3042a6f5de680dddeba" translate="yes" xml:space="preserve">
          <source>Location of warning</source>
          <target state="translated">경고의 위치</target>
        </trans-unit>
        <trans-unit id="4b59a58b9ea59e25faf234bc5204489fb27642f9" translate="yes" xml:space="preserve">
          <source>Locks are not inherited by child processes.</source>
          <target state="translated">하위 프로세스는 잠금을 상속하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3a33487e1736bf9e6609b67ba3b4f3dff1091e2f" translate="yes" xml:space="preserve">
          <source>Locks created using &lt;code&gt;lock&lt;/code&gt; and &lt;code&gt;tryLock&lt;/code&gt; have the following properties:</source>
          <target state="translated">&lt;code&gt;lock&lt;/code&gt; 및 &lt;code&gt;tryLock&lt;/code&gt; 을 사용하여 작성된 잠금 에는 다음 특성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="1078bb655a08aae4699ba7fac16a102730785485" translate="yes" xml:space="preserve">
          <source>Locks the specified file segment. If the file segment is already locked by another process, waits until the existing lock is released. If both &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;length&lt;/code&gt; are zero, the entire file is locked.</source>
          <target state="translated">지정된 파일 세그먼트를 잠급니다. 다른 프로세스에서 파일 세그먼트를 이미 잠근 경우 기존 잠금이 해제 될 때까지 기다립니다. 두 경우 &lt;code&gt;start&lt;/code&gt; 과 &lt;code&gt;length&lt;/code&gt; 제로이며, 전체 파일이 잠겨 있습니다.</target>
        </trans-unit>
        <trans-unit id="4fdb3aa6c3fd683c9aaf2374307211453b556f8d" translate="yes" xml:space="preserve">
          <source>Lockstep!Ranges &lt;strong id=&quot;lockstep&quot;&gt;lockstep&lt;/strong&gt;(Ranges...)(Ranges ranges)</source>
          <target state="translated">&lt;strong id=&quot;lockstep&quot;&gt;락 스텝&lt;/strong&gt; ! 범위 &lt;strong id=&quot;lockstep&quot;&gt;락 스텝&lt;/strong&gt; (범위 ...) (범위 범위)</target>
        </trans-unit>
        <trans-unit id="39496871de00ee058f37e6cbb0be193e3214e5e3" translate="yes" xml:space="preserve">
          <source>Lockstep!Ranges &lt;strong id=&quot;lockstep&quot;&gt;lockstep&lt;/strong&gt;(Ranges...)(Ranges ranges, StoppingPolicy s)</source>
          <target state="translated">Lockstep! Ranges &lt;strong id=&quot;lockstep&quot;&gt;lockstep&lt;/strong&gt; (Ranges ...) (범위 범위, StoppingPolicy s)</target>
        </trans-unit>
        <trans-unit id="fad1f4632354649775fa0e5d50b9164b567e59f6" translate="yes" xml:space="preserve">
          <source>Log Minus Digamma function</source>
          <target state="translated">마이너스 디 감마 로그 함수</target>
        </trans-unit>
        <trans-unit id="2a6fa3a2602f79946a73d76e4d612ad28acdfb88" translate="yes" xml:space="preserve">
          <source>Log messages that describe fatal errors should use this level.</source>
          <target state="translated">치명적인 오류를 설명하는 로그 메시지는이 수준을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="9945a7ae687a5abee282c11e943964628be93a09" translate="yes" xml:space="preserve">
          <source>Log the string to stderr, this will print something like this in the terminal:</source>
          <target state="translated">문자열을 stderr에 기록하면 터미널에서 다음과 같이 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="02b7320cd2ebcb2d92d9355bfdee38ca004f34cb" translate="yes" xml:space="preserve">
          <source>LogEntry &lt;code&gt;payload&lt;/code&gt;</source>
          <target state="translated">LogEntry &lt;code&gt;payload&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="34c61f0216de15bd2af4a77e158df88206381def" translate="yes" xml:space="preserve">
          <source>LogEntry is a aggregation combining all information associated with a log message. This aggregation will be passed to the method writeLogMsg.</source>
          <target state="translated">LogEntry는 로그 메시지와 관련된 모든 정보를 결합한 집계입니다. 이 집계는 writeLogMsg 메소드로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="74c012ac32756bbfd453a39643d2591c98930a80" translate="yes" xml:space="preserve">
          <source>LogLevel</source>
          <target state="translated">LogLevel</target>
        </trans-unit>
        <trans-unit id="46823fbe7f7dbcfd76f32da557302d10d151cb8a" translate="yes" xml:space="preserve">
          <source>LogLevel &lt;code&gt;ll&lt;/code&gt;</source>
          <target state="translated">LogLevel &lt;code&gt;ll&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="02c5d167afffbb7dbf4712fabfc250b90a1311bc" translate="yes" xml:space="preserve">
          <source>LogLevel &lt;code&gt;lv&lt;/code&gt;</source>
          <target state="translated">LogLevel &lt;code&gt;lv&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ecc9d7efba9afc89574f5d3bf86e3d7baaac302b" translate="yes" xml:space="preserve">
          <source>LogLevel &lt;strong id=&quot;logLevel&quot;&gt;logLevel&lt;/strong&gt;;</source>
          <target state="translated">LogLevel &lt;strong id=&quot;logLevel&quot;&gt;logLevel&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="4ed40fc6e5a5852438d7391404942ae2521d7f56" translate="yes" xml:space="preserve">
          <source>Logger &lt;code&gt;newLogger&lt;/code&gt;</source>
          <target state="translated">로거 &lt;code&gt;newLogger&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="28189bc68fa5c89294fb2f918a4e83d73a420934" translate="yes" xml:space="preserve">
          <source>Logger &lt;strong id=&quot;logger&quot;&gt;logger&lt;/strong&gt;;</source>
          <target state="translated">로거 &lt;strong id=&quot;logger&quot;&gt;로거&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="84c998ac72938ace2c01090c22dde31485e70020" translate="yes" xml:space="preserve">
          <source>Logging Fundamentals</source>
          <target state="translated">로깅 기본 사항</target>
        </trans-unit>
        <trans-unit id="ff5d5c519f4c3bb77429911d9e4777ff8d9f0131" translate="yes" xml:space="preserve">
          <source>Logical negation</source>
          <target state="translated">논리적 부정</target>
        </trans-unit>
        <trans-unit id="92491dfcf77a677e2579a8fdd5849bc43c91a9a3" translate="yes" xml:space="preserve">
          <source>Logical_Order_Exception</source>
          <target state="translated">Logical_Order_Exception</target>
        </trans-unit>
        <trans-unit id="70560736acb9ecf186c4fe18c6fbf72b37079b60" translate="yes" xml:space="preserve">
          <source>Logs a part of the log message.</source>
          <target state="translated">로그 메시지의 일부를 기록합니다.</target>
        </trans-unit>
        <trans-unit id="375bd085e65737a7ace18bd867e945918a24086b" translate="yes" xml:space="preserve">
          <source>Long form</source>
          <target state="translated">긴 형태</target>
        </trans-unit>
        <trans-unit id="ff41efc01d76dc10a97a12c09a243b0ca354e0cf" translate="yes" xml:space="preserve">
          <source>Look 2 tokens ahead at value.</source>
          <target state="translated">가치에 앞서 두 개의 토큰을 살펴보십시오.</target>
        </trans-unit>
        <trans-unit id="afc94f6c3a556315eed1cb174ad15bb185dcbc4f" translate="yes" xml:space="preserve">
          <source>Look ahead at next token's value.</source>
          <target state="translated">다음 토큰의 가치를 미리보십시오.</target>
        </trans-unit>
        <trans-unit id="5622d20c099b662e6a0a373dd68292f6a0ba3406" translate="yes" xml:space="preserve">
          <source>Look at all the variables in this function that are referenced by nested functions, and determine if a closure needs to be created for them.</source>
          <target state="translated">중첩 함수에서 참조하는이 함수의 모든 변수를보고 클로저를 작성해야하는지 판별하십시오.</target>
        </trans-unit>
        <trans-unit id="654b5c9229aa50c7d6a646cb9a83a6131f5de84e" translate="yes" xml:space="preserve">
          <source>Look at the chain of inflight exceptions and pick the class type that'll be looked for in catch clauses.</source>
          <target state="translated">기내 예외 체인을보고 catch 절에서 찾을 클래스 유형을 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="70c9a19c6fcf57b59739caeb1b4f8d412200e169" translate="yes" xml:space="preserve">
          <source>Look for GC-allocations</source>
          <target state="translated">GC 할당 찾기</target>
        </trans-unit>
        <trans-unit id="20561c6b5a8c54db867f0cd788574c6f1aaba303" translate="yes" xml:space="preserve">
          <source>Look for bugs in constructing types.</source>
          <target state="translated">타입을 구성 할 때 버그를 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="d1a79a1301c397a748fd769d70432ac6b93cb4bc" translate="yes" xml:space="preserve">
          <source>Look for constructor declaration.</source>
          <target state="translated">생성자 선언을 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="55662975ec462a6b77f0e621733ca4e99a96109f" translate="yes" xml:space="preserve">
          <source>Look for member of the form: const(MemberInfo)[] getMembers(string); Returns NULL if not found</source>
          <target state="translated">다음 형식의 멤버를 찾으십시오. const (MemberInfo) [] getMembers (string); 찾을 수 없으면 NULL을 반환</target>
        </trans-unit>
        <trans-unit id="a5ecbeff661b0c09d7052aed23032d114c945947" translate="yes" xml:space="preserve">
          <source>Look for references to variables in a scope enclosing the new function literal.</source>
          <target state="translated">새 함수 리터럴을 포함하는 범위의 변수에 대한 참조를 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="dca0eb22e1b34ba0a7ee58c95403fe1142a825cc" translate="yes" xml:space="preserve">
          <source>Look up classType in Action Table.</source>
          <target state="translated">조치 테이블에서 classType을 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="bf6f8e6a744477193839c88af310acdab947187c" translate="yes" xml:space="preserve">
          <source>Look up identifier in symbol table.</source>
          <target state="translated">심볼 테이블에서 식별자를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="6b1faf6e7e2ade4943d73b78287350be64b06d22" translate="yes" xml:space="preserve">
          <source>Looks for correct spelling. Currently only looks a 'distance' of one from the seed[]. This does an exhaustive search, so can potentially be very slow.</source>
          <target state="translated">올바른 철자를 찾습니다. 현재는 씨앗에서 하나의 '거리'만 보인다 []. 이것은 철저한 검색을 수행하므로 잠재적으로 매우 느릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7ba5beab41b9fc718625eff0ab12ec104ab4ac0" translate="yes" xml:space="preserve">
          <source>Looks for undefined identifier s to see if it might be undefined because an import was not specified. Not meant to be a comprehensive list of names in each module, just the most common ones.</source>
          <target state="translated">가져 오기가 지정되지 않아 정의되지 않은 식별자를 찾아 정의되지 않은 식별자를 찾습니다. 각 모듈의 포괄적 인 이름 목록이 아니라 가장 일반적인 이름입니다.</target>
        </trans-unit>
        <trans-unit id="b8a0d0e70a93b9315eed33e543f65f34ea9905b6" translate="yes" xml:space="preserve">
          <source>Looks up &lt;code&gt;key&lt;/code&gt;; if it exists applies the &lt;code&gt;update&lt;/code&gt; delegate else evaluates the &lt;code&gt;create&lt;/code&gt; delegate and adds it to the associative array</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 찾습니다 . 존재하는 경우 &lt;code&gt;update&lt;/code&gt; 델리게이트 가 적용되며, 그렇지 않으면 &lt;code&gt;create&lt;/code&gt; 델리게이트를 평가 하여 연관 배열에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="f04ca992dc16f517e75024c08b7ac020854cbc1a" translate="yes" xml:space="preserve">
          <source>Looks up &lt;code&gt;key&lt;/code&gt;; if it exists returns corresponding value else evaluates &lt;code&gt;value&lt;/code&gt;, adds it to the associative array and returns it.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 찾습니다 . 그 밖의 값을 평가하여 대응 복귀 있으면 &lt;code&gt;value&lt;/code&gt; 상기 연관 배열 복귀 그것을 추가한다.</target>
        </trans-unit>
        <trans-unit id="c6a8bc0d3f8751a41d3178fa2ecd99ad6f8c6478" translate="yes" xml:space="preserve">
          <source>Looks up &lt;code&gt;key&lt;/code&gt;; if it exists returns corresponding value else evaluates and returns &lt;code&gt;defVal&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 찾습니다 . 존재하는 경우 해당 값을 반환하고 그렇지 않으면 &lt;code&gt;defVal&lt;/code&gt; 을 평가하고 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="dd483a2f65cbf5a83a8c5f6ad516313d73801935" translate="yes" xml:space="preserve">
          <source>Looks up key; if it exists applies the update callable else evaluates the create callable and adds it to the associative array</source>
          <target state="translated">키를 찾습니다. 존재하는 경우 업데이트 호출 가능을 적용하고 그렇지 않으면 호출 가능 생성 작성을 평가하여 연관 배열에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="be2ee07f892035b2ec1c706668252bc84555ddb4" translate="yes" xml:space="preserve">
          <source>Looks up key; if it exists returns corresponding value else evaluates and returns defaultValue.</source>
          <target state="translated">키를 찾습니다. 존재하는 경우 해당 값을 반환하고 그렇지 않으면 defaultValue를 평가하고 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1875c1f85b6a7543e96c3d340bf104b96893e8d2" translate="yes" xml:space="preserve">
          <source>Looks up key; if it exists returns corresponding value else evaluates value, adds it to the associative array and returns it.</source>
          <target state="translated">키를 찾습니다. 존재하는 경우 해당 값을 리턴하고 그렇지 않으면 값을 평가하여 연관 배열에 추가 한 후 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="2cc04a00b4346a66399ef51dd8da620552ded35a" translate="yes" xml:space="preserve">
          <source>Lookup *pkey in aa. Called only from implementation of (aa[key]) expressions when value is mutable.</source>
          <target state="translated">조회 * pkey aa. 값이 변경 가능한 경우 (aa [key]) 표현식 구현에서만 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="5acb595c30bd73abf9112d17b6787c68f70f18a1" translate="yes" xml:space="preserve">
          <source>Lookup *pkey in aa. Called only from implementation of (aa[key]) expressions when value is not mutable.</source>
          <target state="translated">조회 * pkey aa. 값을 변경할 수없는 경우 (aa [key]) 표현식 구현에서만 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="791d64d6dd1c9c7807ef99641d73b8a3fa427ce6" translate="yes" xml:space="preserve">
          <source>Lookup *pkey in aa. Called only from implementation of (key in aa) expressions.</source>
          <target state="translated">조회 * pkey aa. (key in aa) 표현식의 구현에서만 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="2d5714819469c13b59fdfd000487590810a7c91a" translate="yes" xml:space="preserve">
          <source>Lookup *pkey in aa. Called only from implementation of require</source>
          <target state="translated">조회 * pkey aa. require 구현에서만 호출</target>
        </trans-unit>
        <trans-unit id="488171ff26cd71419d21a0a9adfd632513f34bae" translate="yes" xml:space="preserve">
          <source>Lookup named submatch.</source>
          <target state="translated">이름이 일치하지 않는 조회.</target>
        </trans-unit>
        <trans-unit id="1b640962460641e4c30f8b4a0277ba5e6244fda9" translate="yes" xml:space="preserve">
          <source>Loop over the chain of Throwables.</source>
          <target state="translated">Throwable 체인을 반복합니다.</target>
        </trans-unit>
        <trans-unit id="1a1cf7f9d7a7fa0e0c2b6385a443cec04154dd41" translate="yes" xml:space="preserve">
          <source>Low Surrogates</source>
          <target state="translated">낮은 대리모</target>
        </trans-unit>
        <trans-unit id="48523acb4bcd854d9aa1ea2802e3b41bb7296532" translate="yes" xml:space="preserve">
          <source>Low level</source>
          <target state="translated">저수준</target>
        </trans-unit>
        <trans-unit id="b40b74c86ad687d5579e947e3f92577b31a5eda2" translate="yes" xml:space="preserve">
          <source>Low level bit manipulation.</source>
          <target state="translated">낮은 수준의 비트 조작.</target>
        </trans-unit>
        <trans-unit id="f2e86eaa57ddf3a17dd614f833e423ebc213f8c4" translate="yes" xml:space="preserve">
          <source>Low level messaging API for threads.</source>
          <target state="translated">스레드를위한 저수준 메시징 API.</target>
        </trans-unit>
        <trans-unit id="dcbca8259d75e252eae0048dd86f40340f8d0cd8" translate="yes" xml:space="preserve">
          <source>Low-Level Control Of Database Files</source>
          <target state="translated">데이터베이스 파일의 저수준 제어</target>
        </trans-unit>
        <trans-unit id="89f7441b4ba65a8bf1a560585634d07db89e7fca" translate="yes" xml:space="preserve">
          <source>Low-level process creation</source>
          <target state="translated">저수준 프로세스 생성</target>
        </trans-unit>
        <trans-unit id="2bd438fab42ba2532b308f2c0479c2cede33e8d9" translate="yes" xml:space="preserve">
          <source>Lower case letters</source>
          <target state="translated">소문자</target>
        </trans-unit>
        <trans-unit id="3011ca9e161c4e7602061857963040cfcefd24e6" translate="yes" xml:space="preserve">
          <source>Lower level control over parsing CSV</source>
          <target state="translated">CSV 구문 분석에 대한 하위 레벨 제어</target>
        </trans-unit>
        <trans-unit id="b563fa15108a7c5ade041259f86d89b7a18d8930" translate="yes" xml:space="preserve">
          <source>Lowercase</source>
          <target state="translated">Lowercase</target>
        </trans-unit>
        <trans-unit id="abf8ce4a5f4a2b06b346bb8ef9b168681a52fab2" translate="yes" xml:space="preserve">
          <source>Lowercase_Letter</source>
          <target state="translated">Lowercase_Letter</target>
        </trans-unit>
        <trans-unit id="b7c7ce791998816ed0e71e16db0d586762b3248a" translate="yes" xml:space="preserve">
          <source>Lowest generated value (&lt;code&gt;1&lt;/code&gt; if &lt;code&gt;c == 0&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt; otherwise).</source>
          <target state="translated">최저 생성 된 값 ( &lt;code&gt;1&lt;/code&gt; 경우 &lt;code&gt;c == 0&lt;/code&gt; , &lt;code&gt;0&lt;/code&gt; , 그렇지).</target>
        </trans-unit>
        <trans-unit id="65a7ee0f0dd9333831b9dc305ef620113ec1e149" translate="yes" xml:space="preserve">
          <source>Lowest possible assignable &lt;code&gt;LogLevel&lt;/code&gt;.</source>
          <target state="translated">할당 가능한 가장 낮은 &lt;code&gt;LogLevel&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cdd31e29a8533fa78639eaa1635910fd1573da09" translate="yes" xml:space="preserve">
          <source>LsdaResult</source>
          <target state="translated">LsdaResult</target>
        </trans-unit>
        <trans-unit id="93a7e558e0aeedd54f6dee5a37efe3afb6f4c131" translate="yes" xml:space="preserve">
          <source>LsdaResult &lt;strong id=&quot;scanLSDA&quot;&gt;scanLSDA&lt;/strong&gt;(const(ubyte)* lsda, _Unwind_Ptr ip, _Unwind_Exception_Class exceptionClass, bool cleanupsOnly, bool preferHandler, _Unwind_Exception* exceptionObject, out _Unwind_Ptr landingPad, out int handler);</source>
          <target state="translated">LsdaResult &lt;strong id=&quot;scanLSDA&quot;&gt;scanLSDA&lt;/strong&gt; (const (ubyte) * lsda, _Unwind_Ptr ip, _Unwind_Exception_Class exceptionClass, bool cleanupsOnly, bool preferHandler, _Unwind_Exception * exceptionObject, out _Unwind_Ptr 랜딩 패드, out int 핸들러);</target>
        </trans-unit>
        <trans-unit id="f41a055096fba2f5ebbddc8916d81727739dbdb3" translate="yes" xml:space="preserve">
          <source>Lt</source>
          <target state="translated">Lt</target>
        </trans-unit>
        <trans-unit id="eef6ef9869ba818327c7d9505b56279d719e493a" translate="yes" xml:space="preserve">
          <source>Lu</source>
          <target state="translated">Lu</target>
        </trans-unit>
        <trans-unit id="717f61ff64cc1d6b73a3c57e533103b3f6a567a9" translate="yes" xml:space="preserve">
          <source>LwrExpression</source>
          <target state="translated">LwrExpression</target>
        </trans-unit>
        <trans-unit id="f9156a05ab3755f6c7a6aab965a12bc73fd9cc2c" translate="yes" xml:space="preserve">
          <source>Lycian</source>
          <target state="translated">Lycian</target>
        </trans-unit>
        <trans-unit id="253fa34d4b816ad16ebad60a0945ef037709d0b8" translate="yes" xml:space="preserve">
          <source>Lydian</source>
          <target state="translated">Lydian</target>
        </trans-unit>
        <trans-unit id="c63ae6dd4fc9f9dda66970e827d13f7c73fe841c" translate="yes" xml:space="preserve">
          <source>M</source>
          <target state="translated">M</target>
        </trans-unit>
        <trans-unit id="b6d557e553638176bbc7442ef35ab7cffd41c1e4" translate="yes" xml:space="preserve">
          <source>MATCH &lt;strong id=&quot;callMatch&quot;&gt;callMatch&lt;/strong&gt;(Type tthis, Expression[] args, int flag = 0, const(char)** pMessage = null, Scope* sc = null);</source>
          <target state="translated">MATCH &lt;strong id=&quot;callMatch&quot;&gt;callMatch&lt;/strong&gt; (유형 tthis, Expression [] 인수, int 플래그 = 0, const (char) ** pMessage = null, Scope * sc = null);</target>
        </trans-unit>
        <trans-unit id="63c0d0982dd717fe106c7dfaf4dbef053e569f37" translate="yes" xml:space="preserve">
          <source>MATCH &lt;strong id=&quot;constConv&quot;&gt;constConv&lt;/strong&gt;(Type to);</source>
          <target state="translated">MATCH &lt;strong id=&quot;constConv&quot;&gt;constConv&lt;/strong&gt; (유형);</target>
        </trans-unit>
        <trans-unit id="7189716dd2570ff5122c43fe6e3e0126d15533a1" translate="yes" xml:space="preserve">
          <source>MATCH &lt;strong id=&quot;deduceFunctionTemplateMatch&quot;&gt;deduceFunctionTemplateMatch&lt;/strong&gt;(TemplateInstance ti, Scope* sc, ref FuncDeclaration fd, Type tthis, Expressions* fargs);</source>
          <target state="translated">MATCH &lt;strong id=&quot;deduceFunctionTemplateMatch&quot;&gt;deduceFunctionTemplateMatch&lt;/strong&gt; (TemplateInstance ti, Scope * sc, ref FuncDeclaration fd, 타입 tthis, Expressions * fargs);</target>
        </trans-unit>
        <trans-unit id="8f902d50b36da53875defe35cdfd37c8db415308" translate="yes" xml:space="preserve">
          <source>MATCH &lt;strong id=&quot;implicitConvTo&quot;&gt;implicitConvTo&lt;/strong&gt;(Expression e, Type t);</source>
          <target state="translated">&lt;strong id=&quot;implicitConvTo&quot;&gt;implicitConvTo&lt;/strong&gt; 일치 (표현식 e, 유형 t);</target>
        </trans-unit>
        <trans-unit id="17f9b85399cd8eacf845a08f0ddd5c81dc4efaaf" translate="yes" xml:space="preserve">
          <source>MATCH &lt;strong id=&quot;implicitConvTo&quot;&gt;implicitConvTo&lt;/strong&gt;(Type to);</source>
          <target state="translated">MATCH &lt;strong id=&quot;implicitConvTo&quot;&gt;implicitConvTo&lt;/strong&gt; (유형);</target>
        </trans-unit>
        <trans-unit id="01016d25cb7f7307f5c30d54b28b7e62898ef0f4" translate="yes" xml:space="preserve">
          <source>MATCH &lt;strong id=&quot;leastAsSpecialized&quot;&gt;leastAsSpecialized&lt;/strong&gt;(Scope* sc, TemplateDeclaration td2, Expressions* fargs);</source>
          <target state="translated">MATCH &lt;strong id=&quot;leastAsSpecialized&quot;&gt;leastAsSpecialized&lt;/strong&gt; (Scope * sc, TemplateDeclaration td2, Expressions * fargs);</target>
        </trans-unit>
        <trans-unit id="918dc11643797c59c58daf42cb0ca1d4a73b4d76" translate="yes" xml:space="preserve">
          <source>MATCH &lt;strong id=&quot;matchArg&quot;&gt;matchArg&lt;/strong&gt;(TemplateParameter tp, Loc instLoc, Scope* sc, Objects* tiargs, size_t i, TemplateParameters* parameters, Objects* dedtypes, Declaration* psparam);</source>
          <target state="translated">MATCH &lt;strong id=&quot;matchArg&quot;&gt;matchArg&lt;/strong&gt; (TemplateParameter tp, Loc instLoc, Scope * sc, Objects * tiargs, size_t i, TemplateParameters * parameters, Objects * dedtypes, Declaration * psparam);</target>
        </trans-unit>
        <trans-unit id="f9fa496f162d5b1d5225ec4710970983096606da" translate="yes" xml:space="preserve">
          <source>MATCH &lt;strong id=&quot;matchWithInstance&quot;&gt;matchWithInstance&lt;/strong&gt;(Scope* sc, TemplateInstance ti, Objects* dedtypes, Expressions* fargs, int flag);</source>
          <target state="translated">MATCH &lt;strong id=&quot;matchWithInstance&quot;&gt;matchWithInstance&lt;/strong&gt; (Scope * sc, TemplateInstance ti, Objects * dedtypes, Expressions * fargs, int flag);</target>
        </trans-unit>
        <trans-unit id="5843e5e021e20b605f42acd4c88a16a007841d32" translate="yes" xml:space="preserve">
          <source>MATCH.exact 'this' == 'to' MATCH.constant 'to' is const MATCH.nomatch conversion to mutable or invariant</source>
          <target state="translated">MATCH.exact 'this'== 'to'MATCH.constant 'to'는 const MATCH.nomatch를 가변 또는 불변으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="03d0a50e82b0494ec2b0ced95d0effb00b5a4de8" translate="yes" xml:space="preserve">
          <source>MATCH.nomatch, MATCH.convert, MATCH.constant, MATCH.exact</source>
          <target state="translated">MATCH.Nomatch, MATCH.convert, MATCH.constant, MATCH.exact</target>
        </trans-unit>
        <trans-unit id="eceb0459a5cb4578982ccd6ce7529eeed14e4cab" translate="yes" xml:space="preserve">
          <source>MATCHxxxx</source>
          <target state="translated">MATCHxxxx</target>
        </trans-unit>
        <trans-unit id="a5f71adafc8958cac2aa5aebe8cd541186115a14" translate="yes" xml:space="preserve">
          <source>MIME type of the data, for example, &quot;text/plain&quot; or &quot;application/octet-stream&quot;. See also: &lt;a href=&quot;http://en.wikipedia.org/wiki/Internet_media_type&quot;&gt; Internet media type&lt;/a&gt; on Wikipedia.</source>
          <target state="translated">데이터의 MIME 유형 (예 : &quot;text / plain&quot;또는 &quot;application / octet-stream&quot;) Wikipedia의 &lt;a href=&quot;http://en.wikipedia.org/wiki/Internet_media_type&quot;&gt;인터넷 미디어 유형&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b5be81ad54ab3ef72831f1a96e4ca1f8be777013" translate="yes" xml:space="preserve">
          <source>MIME type of the data, for example, &quot;text/plain&quot; or &quot;application/octet-stream&quot;. See also: &lt;a href=&quot;https://en.wikipedia.org/wiki/Internet_media_type&quot;&gt; Internet media type&lt;/a&gt; on Wikipedia.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d4631fbf4689affb8ff105bbf8ac5b78adddcd3" translate="yes" xml:space="preserve">
          <source>ML-style functional exception handling. Runs the supplied expression and returns its result. If the expression throws a &lt;code&gt;Throwable&lt;/code&gt;, runs the supplied error handler instead and return its result. The error handler's type must be the same as the expression's type.</source>
          <target state="translated">ML 스타일의 기능적 예외 처리. 제공된 표현식을 실행하고 결과를 리턴합니다. 식이 &lt;code&gt;Throwable&lt;/code&gt; 을 던지면 제공된 오류 처리기를 대신 실행하고 결과를 반환합니다. 오류 처리기 유형은 표현식 유형과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="33379ede9c84ed9d3104a88adf47b86b54d3c4fa" translate="yes" xml:space="preserve">
          <source>MOD &lt;code&gt;mod&lt;/code&gt;</source>
          <target state="translated">MOD &lt;code&gt;mod&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="701271424e18847db6f579468d2cd5078329cdaa" translate="yes" xml:space="preserve">
          <source>MOD &lt;strong id=&quot;deduceWild&quot;&gt;deduceWild&lt;/strong&gt;(Type t, bool isRef);</source>
          <target state="translated">MOD &lt;strong id=&quot;deduceWild&quot;&gt;deduceWild&lt;/strong&gt; (타입 t, bool isRef);</target>
        </trans-unit>
        <trans-unit id="76b10e3dcb4a133c7bb6262af258f9831130f8e8" translate="yes" xml:space="preserve">
          <source>MOD bits</source>
          <target state="translated">MOD 비트</target>
        </trans-unit>
        <trans-unit id="84cc32aac369a52d44f13e6b163b25f342633b78" translate="yes" xml:space="preserve">
          <source>MSVC allocates on default initialisation in debug, which can't be modelled by D &lt;code&gt;struct&lt;/code&gt;</source>
          <target state="translated">MSVC는 디버그에서 기본 초기화를 할당하며 D &lt;code&gt;struct&lt;/code&gt; 로는 모델링 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b48af28979910507a72300805b16b39786c09205" translate="yes" xml:space="preserve">
          <source>Mac OS X</source>
          <target state="translated">맥 OS X</target>
        </trans-unit>
        <trans-unit id="bb5fc92b2d874256f372cac5c2a5b3a773e873c8" translate="yes" xml:space="preserve">
          <source>Macro Definitions Generated by Ddoc</source>
          <target state="translated">Ddoc에 의해 생성 된 매크로 정의</target>
        </trans-unit>
        <trans-unit id="f267b7710be73b007f894278ea6b282b0c3b62d8" translate="yes" xml:space="preserve">
          <source>Macro Definitions from .ddoc Files on the Command Line</source>
          <target state="translated">명령 줄에서 .ddoc 파일의 매크로 정의</target>
        </trans-unit>
        <trans-unit id="b244d94b9e3687038ccb11df99431228edef706c" translate="yes" xml:space="preserve">
          <source>Macro Definitions from &lt;code&gt;sc.ini&lt;/code&gt;'s DDOCFILE</source>
          <target state="translated">&lt;code&gt;sc.ini&lt;/code&gt; 의 DDOCFILE 에서 매크로 정의</target>
        </trans-unit>
        <trans-unit id="d9287b4f065fa8285b646a8b8eb23fd987c1ed50" translate="yes" xml:space="preserve">
          <source>Macro and Escape text substitution is performed to produce the final result.</source>
          <target state="translated">매크로 및 이스케이프 텍스트 대체가 최종 결과를 생성하기 위해 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="0342437ac2c198171fe2e3235a577c880ee3a26d" translate="yes" xml:space="preserve">
          <source>Macro definitions come from the following sources, in the specified order:</source>
          <target state="translated">매크로 정의는 지정된 순서로 다음 소스에서 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="64c2f043d46921aa3d0d7e83b419b8b713824341" translate="yes" xml:space="preserve">
          <source>Macro names beginning with &quot;D_&quot; and &quot;DDOC_&quot; are reserved.</source>
          <target state="translated">&quot;D_&quot;및 &quot;DDOC_&quot;로 시작하는 매크로 이름은 예약되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="5300aeedfdbb4e7dc6ac9411b36bf223f7cb19b1" translate="yes" xml:space="preserve">
          <source>Macro redefinitions replace previous definitions of the same name. This means that the sequence of macro definitions from the various sources forms a hierarchy.</source>
          <target state="translated">매크로 재정의는 동일한 이름의 이전 정의를 대체합니다. 이는 다양한 소스의 매크로 정의 시퀀스가 ​​계층 구조를 형성 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="899bd694d29ace1be956ab35177075021977560b" translate="yes" xml:space="preserve">
          <source>Macros</source>
          <target state="translated">Macros</target>
        </trans-unit>
        <trans-unit id="ab4342746df71224401959d238150c1f6538a7c1" translate="yes" xml:space="preserve">
          <source>Macros can have arguments. Any text from the end of the identifier to the closing &amp;lsquo;)&amp;rsquo; is the &amp;amp;dollar;0 argument. A &amp;amp;dollar;0 in the replacement text is replaced with the argument text. If there are commas in the argument text, &amp;amp;dollar;1 will represent the argument text up to the first comma, &amp;amp;dollar;2 from the first comma to the second comma, etc., up to &amp;amp;dollar;9. &amp;amp;dollar;+ represents the text from the first comma to the closing &amp;lsquo;)&amp;rsquo;. The argument text can contain nested parentheses, &quot;&quot; or '' strings, &lt;code&gt;&amp;lt;&lt;/code&gt;&lt;code&gt;!--&lt;/code&gt;&lt;code&gt;...&lt;/code&gt;&lt;code&gt;--&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt; comments, or tags. If stray, unnested parentheses are used, they can be &lt;a href=&quot;#punctuation_escapes&quot;&gt;backslash-escaped&lt;/a&gt;: &lt;code&gt;\(&lt;/code&gt; or &lt;code&gt;\)&lt;/code&gt;.</source>
          <target state="translated">매크로는 인수를 가질 수 있습니다. 식별자의 끝에서 닫는 ')'까지의 모든 텍스트는 &amp;amp; dollar; 0 인수입니다. 대체 텍스트의 &amp;amp; 0은 인수 텍스트로 바뀝니다. 인수 텍스트에 쉼표가있는 경우 &amp;amp; 1은 첫 번째 쉼표까지의 인수 텍스트를 나타내고, 첫 번째 쉼표에서 두 번째 쉼표 등과 같은 최대 2 개의 인수 텍스트를 나타내는 최대 $ 9입니다. +는 첫 번째 쉼표에서 닫는 ')'까지의 텍스트를 나타냅니다. 인수 텍스트가 중첩 된 괄호를 포함 할 수 있습니다 &quot;&quot;또는 ''문자열 &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;code&gt;!--&lt;/code&gt; &lt;code&gt;...&lt;/code&gt; &lt;code&gt;--&lt;/code&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; 의견 또는 태그입니다. 길잃은, 중첩되지 괄호를 사용하는 경우, 그들은 할 수 있습니다 &lt;a href=&quot;#punctuation_escapes&quot;&gt;백 슬래시 이스케이프&lt;/a&gt; : &lt;code&gt;\(&lt;/code&gt; 또는 &lt;code&gt;\)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a3c3c4c2ccfe8372f6cd2e069e3461d5720e2dc7" translate="yes" xml:space="preserve">
          <source>Macros to ease generating code modregrm: generate mod reg r/m field modregxrm: reg could be R8..R15 modregrmx: rm could be R8..R15 modregxrmx: reg or rm could be R8..R15</source>
          <target state="translated">코드 regregrm 생성을 용이하게하는 매크로 : mod reg 생성 r / m 필드 modregxrm : reg는 R8..R15 일 수 있습니다. mod15는 rm 일 수 있습니다. R15 modregxrmx : reg 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b01d69d3c594ccd1f39b3609dda80d687b27a74" translate="yes" xml:space="preserve">
          <source>Mahjong Tiles</source>
          <target state="translated">마작 타일</target>
        </trans-unit>
        <trans-unit id="415d5e06ca564fdf93a52865ce8d28f3a5acb8bf" translate="yes" xml:space="preserve">
          <source>Main date types</source>
          <target state="translated">주요 날짜 유형</target>
        </trans-unit>
        <trans-unit id="66e415faddc4e0d878f47329f905001f0f264f9c" translate="yes" xml:space="preserve">
          <source>Main functionality</source>
          <target state="translated">주요 기능</target>
        </trans-unit>
        <trans-unit id="89997588a647b351fb1614fbf191614c691cf9dc" translate="yes" xml:space="preserve">
          <source>Main types</source>
          <target state="translated">주요 유형</target>
        </trans-unit>
        <trans-unit id="be35592b858c062b5b0300f1bbcabf23cb933bac" translate="yes" xml:space="preserve">
          <source>Mainly just a placeholder</source>
          <target state="translated">주로 자리 표시 자</target>
        </trans-unit>
        <trans-unit id="6c880a7e58cb5a48462791228162b04b3cb63f18" translate="yes" xml:space="preserve">
          <source>Mainly just a placeholder of Package, Module, Nspace, and TemplateInstance (including TemplateMixin)</source>
          <target state="translated">주로 Package, Module, Nspace 및 TemplateInstance (TemplateMixin 포함)의 자리 표시 자</target>
        </trans-unit>
        <trans-unit id="6709119b1651a47a086b7f828dc2d3ff1312b000" translate="yes" xml:space="preserve">
          <source>Maintain another reference to that same data in another thread that the GC does know about.</source>
          <target state="translated">GC가 알고있는 다른 스레드에서 동일한 데이터에 대한 다른 참조를 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="e4472e37b338e67a89fd1b5d36c98992fe68aa60" translate="yes" xml:space="preserve">
          <source>Major HTTP version ie. 1 in HTTP/1.0.</source>
          <target state="translated">주요 HTTP 버전. HTTP / 1.0에서 1입니다.</target>
        </trans-unit>
        <trans-unit id="a94431ee22f05f141107f9355ed3127d0f0c4d5a" translate="yes" xml:space="preserve">
          <source>Make</source>
          <target state="translated">Make</target>
        </trans-unit>
        <trans-unit id="3ba97147877901fcf3ccf5fc1131336b182b7b33" translate="yes" xml:space="preserve">
          <source>Make a common block for s.</source>
          <target state="translated">s에 대한 공통 블록을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="26c580c3818b547739a9a7bd7a4237654b2d0833" translate="yes" xml:space="preserve">
          <source>Make a copy of ap.</source>
          <target state="translated">ap의 사본을 만드십시오.</target>
        </trans-unit>
        <trans-unit id="6bfea7cf8f1b26e91c42e125bf884c70d3ad164a" translate="yes" xml:space="preserve">
          <source>Make a dual-context container for use as a &lt;code&gt;this&lt;/code&gt; argument.</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; 인수 로 사용하기 위해 이중 컨텍스트 컨테이너를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="1abfcba754e1c0302a58d5e32f10b1091f1ebe7e" translate="yes" xml:space="preserve">
          <source>Make a new directory &lt;code&gt;pathname&lt;/code&gt;.</source>
          <target state="translated">새 디렉토리 &lt;code&gt;pathname&lt;/code&gt; 만드십시오 .</target>
        </trans-unit>
        <trans-unit id="c1a6e13f0addb5f5646c2abd0cb0b65b975d7ea4" translate="yes" xml:space="preserve">
          <source>Make a specific point in time in the New York timezone</source>
          <target state="translated">뉴욕 시간대에서 특정 시점 만들기</target>
        </trans-unit>
        <trans-unit id="b3f8f13ef7892bd05bbf45497a5da917ae81e2c9" translate="yes" xml:space="preserve">
          <source>Make directory and all parent directories as needed.</source>
          <target state="translated">필요에 따라 디렉토리 및 모든 상위 디렉토리를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="6da7393f911740ab04336b2af60f186b865c60f5" translate="yes" xml:space="preserve">
          <source>Make sure that the runtime hook &lt;code&gt;id&lt;/code&gt; exists.</source>
          <target state="translated">런타임 후크 &lt;code&gt;id&lt;/code&gt; 가 존재 하는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="525e5a74e45c1668b80e6f1f69958698da6f4d6e" translate="yes" xml:space="preserve">
          <source>Make the next option a required option</source>
          <target state="translated">다음 옵션을 필수 옵션으로 설정</target>
        </trans-unit>
        <trans-unit id="a77836e1ee565bdbac321b50fccddb3229a3e1a6" translate="yes" xml:space="preserve">
          <source>Make type mutable.</source>
          <target state="translated">유형을 변경 가능하게 만드십시오.</target>
        </trans-unit>
        <trans-unit id="4605f2e5776569eac7f1701721da7c9b10116ccc" translate="yes" xml:space="preserve">
          <source>Make type unshared. 0 =&amp;gt; 0 const =&amp;gt; const immutable =&amp;gt; immutable shared =&amp;gt; 0 shared const =&amp;gt; const wild =&amp;gt; wild wild const =&amp;gt; wild const shared wild =&amp;gt; wild shared wild const =&amp;gt; wild const</source>
          <target state="translated">유형을 공유하지 마십시오. 0 =&amp;gt; 0 const =&amp;gt; const immutable =&amp;gt; immutable shared =&amp;gt; 0 shared const =&amp;gt; const wild =&amp;gt; wild wild const =&amp;gt; wild const shared wild =&amp;gt; wild shared wild const =&amp;gt; wild const</target>
        </trans-unit>
        <trans-unit id="9e6b91f833a3dc15ae3a2a05397995784c41e6ab" translate="yes" xml:space="preserve">
          <source>Makes a copy of the given array on newly allocated memory.</source>
          <target state="translated">새로 할당 된 메모리에 지정된 배열의 복사본을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="5dcc70498836fb07f79353bc8ef2dfbc632b1248" translate="yes" xml:space="preserve">
          <source>Makes a null-terminated copy of the given string on newly allocated memory. The null-terminator won't be part of the returned string slice. It will be at position &lt;code&gt;n&lt;/code&gt; where &lt;code&gt;n&lt;/code&gt; is the length of the input string.</source>
          <target state="translated">새로 할당 된 메모리에서 주어진 문자열의 Null 종료 복사본을 만듭니다. 널 종료자는 리턴 된 문자열 슬라이스의 일부가 아닙니다. 이 위치에있을 것이다 &lt;code&gt;n&lt;/code&gt; 여기서, &lt;code&gt;n&lt;/code&gt; 입력 스트링의 길이이다.</target>
        </trans-unit>
        <trans-unit id="c56fa23eba2ab1fc971b9c8c2bace5681b9baed6" translate="yes" xml:space="preserve">
          <source>Makes sure the payload was properly initialized. Such a call is typically inserted before using the payload.</source>
          <target state="translated">페이로드가 올바르게 초기화되었는지 확인하십시오. 이러한 호출은 일반적으로 페이로드를 사용하기 전에 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="cdf9329928a453eb7ea93527766dc15a786af057" translate="yes" xml:space="preserve">
          <source>Making a copy of the data using &lt;a href=&quot;https://dlang.org/phobos/std_experimental_allocator.html&quot;&gt;&lt;code&gt;std.experimental.allocator&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;core.stdc.stdlib.malloc&lt;/code&gt; and passing the copy instead.</source>
          <target state="translated">&lt;a href=&quot;https://dlang.org/phobos/std_experimental_allocator.html&quot;&gt; &lt;code&gt;std.experimental.allocator&lt;/code&gt; &lt;/a&gt; 또는 &lt;code&gt;core.stdc.stdlib.malloc&lt;/code&gt; 을 사용하여 데이터 사본을 작성하고 대신 사본을 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="d4347a59dcc14e96dcb9203070618e3dae91bd4b" translate="yes" xml:space="preserve">
          <source>Making a copy of the data using core.stdc.stdlib.malloc() and passing the copy instead.</source>
          <target state="translated">core.stdc.stdlib.malloc ()을 사용하여 데이터 사본을 작성하고 대신 사본을 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="c730df3afaaac142f305e8f798eca241f12abf9f" translate="yes" xml:space="preserve">
          <source>Malayalam</source>
          <target state="translated">Malayalam</target>
        </trans-unit>
        <trans-unit id="ae60c0645f8b0ef8bf786de73f43479ecba0ff5d" translate="yes" xml:space="preserve">
          <source>Manage flow analysis for constructors.</source>
          <target state="translated">생성자에 대한 흐름 분석을 관리합니다.</target>
        </trans-unit>
        <trans-unit id="63617cfe427854e42387ca5fb2dd42a8d02042c4" translate="yes" xml:space="preserve">
          <source>Mandaic</source>
          <target state="translated">Mandaic</target>
        </trans-unit>
        <trans-unit id="dc3a58f069313e89dc8f96321457748a4819acb0" translate="yes" xml:space="preserve">
          <source>Mangle function signatures ('this' qualifier, and parameter types) to check conflicts in function overloads. It's different from fd.type.deco. For example, fd.type.deco would be null if fd is an auto function.</source>
          <target state="translated">함수 오버로드의 충돌을 확인하기 위해 함수 서명 ( 'this'한정자 및 매개 변수 유형)을 엉망으로 만듭니다. fd.type.deco와 다릅니다. 예를 들어 fd가 자동 함수 인 경우 fd.type.deco는 null입니다.</target>
        </trans-unit>
        <trans-unit id="ced58ad2f9818afd78e1b67efec7988d477fb723" translate="yes" xml:space="preserve">
          <source>Mangle the given symbol for C++ ABI.</source>
          <target state="translated">주어진 C ++ ABI 심볼을 엉망으로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="5f2b13060b64fd11b1052222629bef3facad8f88" translate="yes" xml:space="preserve">
          <source>Mangles a D function.</source>
          <target state="translated">D 함수를 엉망으로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="a34594bca42d9e54bcfa5ae318f82eb8738df791" translate="yes" xml:space="preserve">
          <source>Mangles a D symbol.</source>
          <target state="translated">D 기호를 엉킨 다.</target>
        </trans-unit>
        <trans-unit id="148f8cf1414dcfee88fdea6836cf667aec741ed3" translate="yes" xml:space="preserve">
          <source>Mangling refers to how a symbol is represented in text form in the generated object file. &lt;code&gt;.mangleof&lt;/code&gt; returns a string literal of the representation of the type or symbol it is applied to. The mangling of types and symbols with D linkage is defined by &lt;a href=&quot;abi#name_mangling&quot;&gt;Name Mangling&lt;/a&gt;.</source>
          <target state="translated">Mangling은 생성 된 객체 파일에서 심볼이 텍스트 형식으로 표시되는 방식을 나타냅니다. &lt;code&gt;.mangleof&lt;/code&gt; 는 적용되는 유형 또는 기호의 표현에 대한 문자열 리터럴을 리턴합니다. D 연결을 사용하는 유형 및 기호의 조작은 &lt;a href=&quot;abi#name_mangling&quot;&gt;Name Mangling에&lt;/a&gt; 의해 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="1fe7f3349feabe9c89e0c56bcd790f4f6db52a02" translate="yes" xml:space="preserve">
          <source>Manifest Constants</source>
          <target state="translated">매니페스트 상수</target>
        </trans-unit>
        <trans-unit id="dbbdf8dc2eb670e040ba223dcb25ad582879b9f4" translate="yes" xml:space="preserve">
          <source>Manifest constants are not lvalues, meaning their address cannot be taken. They exist only in the memory of the compiler.</source>
          <target state="translated">매니페스트 상수는 lvalue가 아니므로 주소를 가져올 수 없습니다. 그것들은 컴파일러의 메모리에만 존재합니다.</target>
        </trans-unit>
        <trans-unit id="a6bd23ae5d1ad3b51438e4d31cc4052a69e2527b" translate="yes" xml:space="preserve">
          <source>Manipulate builtin arrays.</source>
          <target state="translated">내장 배열을 조작합니다.</target>
        </trans-unit>
        <trans-unit id="b3d27b0d4934910380362c1298dce9010e6bd996" translate="yes" xml:space="preserve">
          <source>Manipulate files and directories.</source>
          <target state="translated">파일과 디렉토리를 조작하십시오.</target>
        </trans-unit>
        <trans-unit id="c5b5a6b88c43d3a6c6daa4ed63f323e6a3048a07" translate="yes" xml:space="preserve">
          <source>Manipulate strings that represent filesystem paths.</source>
          <target state="translated">파일 시스템 경로를 나타내는 문자열을 조작하십시오.</target>
        </trans-unit>
        <trans-unit id="3e4d28d389556bd825a440f859d3401675a6c5c2" translate="yes" xml:space="preserve">
          <source>Manipulates environment variables using an associative-array-like interface.</source>
          <target state="translated">연관 배열 형 인터페이스를 사용하여 환경 변수를 조작합니다.</target>
        </trans-unit>
        <trans-unit id="a0c12fb39a6a73583409d354fb81a52d9a2e0a56" translate="yes" xml:space="preserve">
          <source>Manu Evans</source>
          <target state="translated">마누 에반스</target>
        </trans-unit>
        <trans-unit id="a747304ebc9a5c399ecad10827e0d5fb3537bd7f" translate="yes" xml:space="preserve">
          <source>Manual D main (for druntime initialization), which forwards to &lt;code&gt;tryMain&lt;/code&gt;.</source>
          <target state="translated">, 전달에 (druntime 초기화에 대한) 수동 D의 주요 &lt;code&gt;tryMain&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4fbeb16d0215c18c2ad3b7f92b0e101cadbbba80" translate="yes" xml:space="preserve">
          <source>Manually initialize the client RTSP CSeq for this handle</source>
          <target state="translated">이 핸들에 대한 클라이언트 RTSP CSeq를 수동으로 초기화</target>
        </trans-unit>
        <trans-unit id="0297a4524810d6d4a3159e7c6f28143e0ac281d1" translate="yes" xml:space="preserve">
          <source>Manually initialize the server RTSP CSeq for this handle</source>
          <target state="translated">이 핸들에 대한 서버 RTSP CSeq를 수동으로 초기화</target>
        </trans-unit>
        <trans-unit id="1dcb8e75d7969bc3abd2e7c3effeca48107c2001" translate="yes" xml:space="preserve">
          <source>Many aggregate range operations turn out to be solved with &lt;code&gt;reduce&lt;/code&gt; quickly and easily. The example below illustrates &lt;code&gt;reduce&lt;/code&gt;'s remarkable power and flexibility.</source>
          <target state="translated">많은 집계 범위 작업이 빠르고 쉽게 &lt;code&gt;reduce&lt;/code&gt; 해결되는 것으로 나타났습니다 . 아래 예제는 놀라운 성능과 유연성을 보여 &lt;code&gt;reduce&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fc2ca31ee175eeb6b7d2fc289d02204152e17221" translate="yes" xml:space="preserve">
          <source>Many array operations, also known as vector operations, can be expressed at a high level rather than as a loop. For example, the loop:</source>
          <target state="translated">벡터 연산이라고도하는 많은 배열 연산을 루프가 아니라 높은 수준으로 표현할 수 있습니다. 예를 들어, 루프 :</target>
        </trans-unit>
        <trans-unit id="a74103b79f7a383e8126d38c82beb9f82d879e84" translate="yes" xml:space="preserve">
          <source>Many functions in this package are parameterized with a &lt;a href=&quot;http://dlang.org/glossary.html#predicate&quot;&gt;predicate&lt;/a&gt;. The predicate may be any suitable callable type (a function, a delegate, a &lt;a href=&quot;http://dlang.org/glossary.html#functor&quot;&gt;functor&lt;/a&gt;, or a lambda), or a compile-time string. The string may consist of &lt;b&gt;any&lt;/b&gt; legal D expression that uses the symbol &lt;code&gt;a&lt;/code&gt; (for unary functions) or the symbols &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; (for binary functions). These names will NOT interfere with other homonym symbols in user code because they are evaluated in a different context. The default for all binary comparison predicates is &lt;code&gt;&quot;a == b&quot;&lt;/code&gt; for unordered operations and &lt;code&gt;&quot;a &amp;lt; b&quot;&lt;/code&gt; for ordered operations.</source>
          <target state="translated">이 패키지의 많은 함수는 &lt;a href=&quot;http://dlang.org/glossary.html#predicate&quot;&gt;술어&lt;/a&gt; 로 매개 변수화됩니다 . 술어는 적절한 호출 가능한 유형 (함수, 대리자, &lt;a href=&quot;http://dlang.org/glossary.html#functor&quot;&gt;functor&lt;/a&gt; 또는 람다) 또는 컴파일 타임 문자열 일 수 있습니다. 문자열로 구성 될 수 &lt;b&gt;있는&lt;/b&gt; 심볼 사용 법적 D 발현 &lt;code&gt;a&lt;/code&gt; (단항 기능) 또는 심볼 및 &lt;code&gt;b&lt;/code&gt; (진 기능). 이 이름은 다른 컨텍스트에서 평가되기 때문에 사용자 코드의 다른 동음 기호를 방해하지 않습니다. 모든 이진 비교 술어의 기본값은 정렬되지 않은 조작의 경우 &lt;code&gt;&quot;a == b&quot;&lt;/code&gt; 이고 정렬 된 조작의 경우 &lt;code&gt;&quot;a &amp;lt; b&quot;&lt;/code&gt; 입니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c99204bbe1e16c2b6a44386014dff7862bca1f80" translate="yes" xml:space="preserve">
          <source>Many functions in this package are parameterized with a &lt;a href=&quot;https://dlang.org/glossary.html#predicate&quot;&gt;predicate&lt;/a&gt;. The predicate may be any suitable callable type (a function, a delegate, a &lt;a href=&quot;https://dlang.org/glossary.html#functor&quot;&gt;functor&lt;/a&gt;, or a lambda), or a compile-time string. The string may consist of &lt;b&gt;any&lt;/b&gt; legal D expression that uses the symbol &lt;code&gt;a&lt;/code&gt; (for unary functions) or the symbols &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; (for binary functions). These names will NOT interfere with other homonym symbols in user code because they are evaluated in a different context. The default for all binary comparison predicates is &lt;code&gt;&quot;a == b&quot;&lt;/code&gt; for unordered operations and &lt;code&gt;&quot;a &amp;lt; b&quot;&lt;/code&gt; for ordered operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dca517d4d22249072adc31efed00eaae12a4434" translate="yes" xml:space="preserve">
          <source>Many languages overload the + operator to mean concatenation. This confusingly leads to, does:</source>
          <target state="translated">많은 언어는 연결을 의미하기 위해 + 연산자를 오버로드합니다. 이 혼란스러운 결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0e9603791fcc610a28e818534a769f77b36897c4" translate="yes" xml:space="preserve">
          <source>Many more functions will be added to this module. The naming convention for the distribution functions (gammaIncomplete, etc) is not yet finalized and will probably change.</source>
          <target state="translated">이 모듈에는 더 많은 기능이 추가 될 것입니다. 분포 함수 (gammaIncomplete 등)의 명명 규칙은 아직 확정되지 않았으며 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b3c0f640962fe45a5bb8aa72a2bf3ed127a738c" translate="yes" xml:space="preserve">
          <source>Map (higher-order function)</source>
          <target state="translated">맵 (고차 함수)</target>
        </trans-unit>
        <trans-unit id="d023b2e06ae9ecd57655e63d888c6a38d365c1c2" translate="yes" xml:space="preserve">
          <source>Mapping of a byte sequence to &lt;b&gt;Byte Order Mark (BOM)&lt;/b&gt;</source>
          <target state="translated">바이트 순서를 &lt;b&gt;바이트 순서 표시 (BOM)에&lt;/b&gt; 맵핑&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="31e9697d43a1a66f2e45db652019fb9a6216df22" translate="yes" xml:space="preserve">
          <source>Mark</source>
          <target state="translated">Mark</target>
        </trans-unit>
        <trans-unit id="6ffcc0a259f655515f96cc8b2d001cfa106d6adf" translate="yes" xml:space="preserve">
          <source>Mark the operand as will never be dereferenced, which is useful info for @safe checks. Do before semantic() on operands rewrites them.</source>
          <target state="translated">@safe 점검에 유용한 정보 인 피연산자를 역 참조되지 않도록 표시하십시오. 피연산자의 semantic ()이 다시 쓰기 전에 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="7b1aaf9a9b88a6df8d74ea8b9437f9bf9b28ca98" translate="yes" xml:space="preserve">
          <source>Mark the operands as will never be dereferenced, which is useful info for @safe checks. Do before semantic() on operands rewrites them.</source>
          <target state="translated">피연산자를 역 참조되지 않도록 표시합니다. 이는 @safe 검사에 유용한 정보입니다. 피연산자의 semantic ()이 다시 쓰기 전에 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="6502c1ba20a549a34759225baf0e5d40999bf988" translate="yes" xml:space="preserve">
          <source>Mark this as a Rng</source>
          <target state="translated">이것을 Rng로 표시</target>
        </trans-unit>
        <trans-unit id="2bf4fa7c0956cb1fdd3ecbee1e7ce54d5a6bb263" translate="yes" xml:space="preserve">
          <source>Mark variable v as modified if it is inside a constructor that var is a field in.</source>
          <target state="translated">var가 필드 인 생성자 내에 있으면 변수 v를 수정 된 것으로 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="9a6792841b7a25d5643379e908c8ab22105dfa68" translate="yes" xml:space="preserve">
          <source>Marked as &lt;code&gt;@system&lt;/code&gt; to discourage casual use of it.</source>
          <target state="translated">일상적인 사용을 막기 위해 &lt;code&gt;@system&lt;/code&gt; 으로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="43791f7af0838eabc46d0824572db10f91b02285" translate="yes" xml:space="preserve">
          <source>Martin Kinkelin</source>
          <target state="translated">마틴 킨 켈린</target>
        </trans-unit>
        <trans-unit id="5637a4a34d1c67892335f2ad5244cdfa55d85c6d" translate="yes" xml:space="preserve">
          <source>Martin Nowak</source>
          <target state="translated">마틴 노박</target>
        </trans-unit>
        <trans-unit id="634e2099c6e661c76d0ed1209ae09cbdd335ffa4" translate="yes" xml:space="preserve">
          <source>Martin Nowak, Walter Bright, &lt;a href=&quot;http://www.digitalmars.com&quot;&gt;http://www.digitalmars.com&lt;/a&gt;</source>
          <target state="translated">Martin Nowak, Walter Bright, &lt;a href=&quot;http://www.digitalmars.com&quot;&gt;http://www.digitalmars.com&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cd5bb36f0c221e6191a45e9c1239a0ef757bb11e" translate="yes" xml:space="preserve">
          <source>Masahiro Nakagawa, Daniel Murphy (Single value Encoder and Decoder)</source>
          <target state="translated">나카가와 마사히로, 다니엘 머피 (단일 인코더 및 디코더)</target>
        </trans-unit>
        <trans-unit id="3b4d8cf3890734f4fadb4d37ea781cb0ac9e5158" translate="yes" xml:space="preserve">
          <source>Masks for register pairs. Note that index registers are always LSWs. This is for the convenience of implementing far pointers.</source>
          <target state="translated">레지스터 쌍용 마스크. 인덱스 레지스터는 항상 LSW입니다. 이것은 멀리 포인터를 구현할 때 편리합니다.</target>
        </trans-unit>
        <trans-unit id="40deae84f1abfc7e207419de3291a71df137054a" translate="yes" xml:space="preserve">
          <source>Master list of D compiler vendors.</source>
          <target state="translated">D 컴파일러 공급 업체의 마스터 목록.</target>
        </trans-unit>
        <trans-unit id="bdbdc9dc0b30e98355e6da908f27cfdf0b692c8d" translate="yes" xml:space="preserve">
          <source>Match function arguments against a specific template function.</source>
          <target state="translated">함수 인수를 특정 템플릿 함수와 일치시킵니다.</target>
        </trans-unit>
        <trans-unit id="c3be1112e4fade99753f0a12ea4510c5118cf76f" translate="yes" xml:space="preserve">
          <source>Match position rather than character</source>
          <target state="translated">캐릭터가 아닌 위치 일치</target>
        </trans-unit>
        <trans-unit id="c6689129157a0cd7e210456aa61647929d8c6a12" translate="yes" xml:space="preserve">
          <source>Match single characters</source>
          <target state="translated">단일 문자와 일치</target>
        </trans-unit>
        <trans-unit id="148aa05679c67c07ca0b45d24720b741e8965e9e" translate="yes" xml:space="preserve">
          <source>Match to a particular TemplateParameter.</source>
          <target state="translated">특정 TemplateParameter와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="d67f60e052c647bc8e8157aba95edd1135747518" translate="yes" xml:space="preserve">
          <source>Match. If the codepoint is found in the set then range &lt;code&gt;inp&lt;/code&gt; is advanced by its size in &lt;a href=&quot;#Code%20unit&quot;&gt;code units&lt;/a&gt;, otherwise the range is not modifed.</source>
          <target state="translated">시합. 코드 포인트가 세트에서 발견되면 범위 &lt;code&gt;inp&lt;/code&gt; 의 크기가 &lt;a href=&quot;#Code%20unit&quot;&gt;코드 단위로 증가합니다&lt;/a&gt; . 그렇지 않으면 범위가 수정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="376518d2ef13168fcac562d64282005ad23bc928" translate="yes" xml:space="preserve">
          <source>MatchAccumulator &lt;code&gt;m&lt;/code&gt;</source>
          <target state="translated">매치 어큐뮬레이터 &lt;code&gt;m&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bb15661c397d61fb56d9df6a184e4fb0749edfcf" translate="yes" xml:space="preserve">
          <source>Matches 0 or more instances of any character.</source>
          <target state="translated">모든 문자의 0 개 이상의 인스턴스와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="1b9ff915f17d527a366476bc5fa2efc5bd3344df" translate="yes" xml:space="preserve">
          <source>Matches \ character.</source>
          <target state="translated">\ 문자와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="d260610c825342c8a67d6079303a94f547805d4d" translate="yes" xml:space="preserve">
          <source>Matches a carriage return character.</source>
          <target state="translated">캐리지 리턴 문자와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="3d4ef72de0c62fe37341c3d09484f217488c5b53" translate="yes" xml:space="preserve">
          <source>Matches a character that belongs to the Unicode PropertyName set. Single letter abbreviations can be used without surrounding {,}.</source>
          <target state="translated">유니 코드 PropertyName 세트에 속하는 문자를 찾습니다. 단일 문자 약어는 {,}를 둘러싸 지 않고 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="93f07d191bb83f6c2008b9d72fa87801f16649a3" translate="yes" xml:space="preserve">
          <source>Matches a character that does not belong to the Unicode PropertyName set. Single letter abbreviations can be used without surrounding {,}.</source>
          <target state="translated">유니 코드 PropertyName 세트에 속하지 않는 문자와 일치합니다. 단일 문자 약어는 {,}를 둘러싸 지 않고 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="566d7f7e38c4f32d92f952f44e41d0f5e20341c0" translate="yes" xml:space="preserve">
          <source>Matches a character with hexadecimal value of XX.</source>
          <target state="translated">16 진수 값이 XX 인 문자를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="f8e9580dd531ce650e18ada33bfae29a8575ead2" translate="yes" xml:space="preserve">
          <source>Matches a character with hexadecimal value of XXXX.</source>
          <target state="translated">16 진수 값이 XXXX 인 문자를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="38acb7b15bf078182213f163b848e68097571ebb" translate="yes" xml:space="preserve">
          <source>Matches a character with hexadecimal value of YYYYYY.</source>
          <target state="translated">16 진수 값이 YYYYYY 인 문자를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="4b5eb461f7e32007ad36804786e028b3b6d3dc0b" translate="yes" xml:space="preserve">
          <source>Matches a formfeed character.</source>
          <target state="translated">용지 공급 문자와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="77e95872193cd47012e519a74ae3e1c87ca38f7d" translate="yes" xml:space="preserve">
          <source>Matches a linefeed character.</source>
          <target state="translated">줄 바꿈 문자와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="3e897b344e0757fd41067b191889c5addfadb41f" translate="yes" xml:space="preserve">
          <source>Matches a pattern against a path.</source>
          <target state="translated">경로와 패턴을 일치시킵니다.</target>
        </trans-unit>
        <trans-unit id="d66a7d7700d7a95eb1d2874bde9effcf95c0d4ea" translate="yes" xml:space="preserve">
          <source>Matches a single character that belongs to this character class.</source>
          <target state="translated">이 문자 클래스에 속하는 단일 문자와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="83324b7e2c1bc20326ff487b5840c55c39dc6197" translate="yes" xml:space="preserve">
          <source>Matches a single character that does &lt;em&gt;not&lt;/em&gt; belong to this character class.</source>
          <target state="translated">이 문자 클래스에 속하지 &lt;em&gt;않는&lt;/em&gt; 단일 문자와 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="cab02f886f635ace9cbacc9188ee8abb79f5d542" translate="yes" xml:space="preserve">
          <source>Matches a tab character.</source>
          <target state="translated">탭 문자와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="e236db248100ae3fd28caffc37fe9c48f80f9bb6" translate="yes" xml:space="preserve">
          <source>Matches a vertical tab character.</source>
          <target state="translated">세로 탭 문자와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="9e6b2c792fd634e9622e84bef86fbd0a77a6417b" translate="yes" xml:space="preserve">
          <source>Matches any Unicode digit.</source>
          <target state="translated">모든 유니 코드 숫자와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="8fa150f9ecc4530d1ba9af253009cc3456029976" translate="yes" xml:space="preserve">
          <source>Matches any character except Unicode digits.</source>
          <target state="translated">유니 코드 숫자를 제외한 모든 문자와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="5d5fafcbb22ed76de0bbd720f8c34d2e0299c44a" translate="yes" xml:space="preserve">
          <source>Matches any character except ones in Cyrillic &lt;em&gt;script&lt;/em&gt;.</source>
          <target state="translated">키릴에서 제외한 모든 문자와 일치 &lt;em&gt;스크립트&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="924bc1a5b59a3dce4f3c80cc62dab13e152ebb85" translate="yes" xml:space="preserve">
          <source>Matches any character except ones in the BasicLatin Unicode &lt;em&gt;block&lt;/em&gt;.</source>
          <target state="translated">BasicLatin Unicode &lt;em&gt;블록&lt;/em&gt; 의 문자를 제외한 모든 문자와 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="6021ff274bc8c771ce0e596bb4aaa530db0a929a" translate="yes" xml:space="preserve">
          <source>Matches any character except those recognized as</source>
          <target state="translated">로 인식되는 문자를 제외한 모든 문자와 일치</target>
        </trans-unit>
        <trans-unit id="d45f9d47fbc3385960d4045204b8fa2e386214d5" translate="yes" xml:space="preserve">
          <source>Matches any character that is part of Cyrillic &lt;em&gt;script&lt;/em&gt;.</source>
          <target state="translated">키릴 문자 &lt;em&gt;스크립트의&lt;/em&gt; 일부인 모든 문자와 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="d03c91729f38a9723ae90c15a2197e33622f23ef" translate="yes" xml:space="preserve">
          <source>Matches any character that is part of the BasicLatin Unicode &lt;em&gt;block&lt;/em&gt;.</source>
          <target state="translated">BasicLatin Unicode &lt;em&gt;블록의&lt;/em&gt; 일부인 모든 문자와 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="fb574dadab1447a560dffc656e147119382698b5" translate="yes" xml:space="preserve">
          <source>Matches any non-word character.</source>
          <target state="translated">비 단어 문자와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="3403b0fa145ced1d792923f6d49e5db2d7819435" translate="yes" xml:space="preserve">
          <source>Matches any word character (note: this includes numbers).</source>
          <target state="translated">모든 단어 문자와 일치합니다 (참고 : 숫자 포함).</target>
        </trans-unit>
        <trans-unit id="80da2f0135b2a31162fa38adfbd74f0e45d4aeea" translate="yes" xml:space="preserve">
          <source>Matches at the begining of input or line (in multiline mode).</source>
          <target state="translated">입력 또는 라인 시작시 일치합니다 (여러 줄 모드에서).</target>
        </trans-unit>
        <trans-unit id="22405e45d9f4b57fd785c56e62bdefc784bbacad" translate="yes" xml:space="preserve">
          <source>Matches at the end of input or line (in multiline mode).</source>
          <target state="translated">입력 또는 라인 끝에서 일치합니다 (여러 줄 모드에서).</target>
        </trans-unit>
        <trans-unit id="9e52d31b85e40923acff9955825d7752c6e3d5f3" translate="yes" xml:space="preserve">
          <source>Matches at word boundary.</source>
          <target state="translated">단어 경계에서 일치합니다.</target>
        </trans-unit>
        <trans-unit id="577bd19069cccb78c878150d0873c8b87bf7a56a" translate="yes" xml:space="preserve">
          <source>Matches either of the specified strings.</source>
          <target state="translated">지정된 문자열 중 하나와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="7032474b5acce6809313391bc66533e639b25d58" translate="yes" xml:space="preserve">
          <source>Matches exactly one instance of any character.</source>
          <target state="translated">모든 문자의 정확히 하나의 인스턴스와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="36a44fb433346fca4b9bc3c5d901586ff1246b65" translate="yes" xml:space="preserve">
          <source>Matches named subexpression regex labeling it with name 'name'. When referring to a matched portion of text, names work like aliases in addition to direct numbers.</source>
          <target state="translated">이름이 'name'인 레이블이 붙은 하위 표현식 정규 표현식과 일치합니다. 일치하는 텍스트 부분을 참조 할 때 이름은 직접 숫자 외에 별명처럼 작동합니다.</target>
        </trans-unit>
        <trans-unit id="00d1e608ef75a418f8d7948d0b6823e3bc89b904" translate="yes" xml:space="preserve">
          <source>Matches one instance of any character that appears between the brackets.</source>
          <target state="translated">대괄호 사이에 나타나는 모든 문자의 한 인스턴스와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="f1226391146d3924b763eb9ef0e5cf228cb4de36" translate="yes" xml:space="preserve">
          <source>Matches one instance of any character that does not appear between the brackets after the exclamation mark.</source>
          <target state="translated">느낌표 다음에 대괄호 사이에 표시되지 않는 문자의 한 인스턴스와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="988aaf14193608b4daf8a5deb48eaea59a3dcec1" translate="yes" xml:space="preserve">
          <source>Matches previous character/subexpression 0 or more times. Greedy version - tries as many times as possible.</source>
          <target state="translated">이전 문자 / 부 표현식을 0 번 이상 일치시킵니다. 욕심 버전-가능한 한 많은 시도.</target>
        </trans-unit>
        <trans-unit id="dc5890e4e43176bad35bb66bd98239c5e9dce6e5" translate="yes" xml:space="preserve">
          <source>Matches previous character/subexpression 0 or more times. Lazy version - stops as early as possible.</source>
          <target state="translated">이전 문자 / 부 표현식을 0 번 이상 일치시킵니다. 게으른 버전-가능한 빨리 중지합니다.</target>
        </trans-unit>
        <trans-unit id="7057e108d200837d3f3e3900e17b1ad6f500a9ff" translate="yes" xml:space="preserve">
          <source>Matches previous character/subexpression 1 or more times. Greedy version - tries as many times as possible.</source>
          <target state="translated">이전 문자 / 부 표현식을 1 회 이상 일치시킵니다. 욕심 버전-가능한 한 많은 시도.</target>
        </trans-unit>
        <trans-unit id="3452a18b749bc5cf311ba5e68ced61439cf96c5b" translate="yes" xml:space="preserve">
          <source>Matches previous character/subexpression 1 or more times. Lazy version - stops as early as possible.</source>
          <target state="translated">이전 문자 / 부 표현식을 1 회 이상 일치시킵니다. 게으른 버전-가능한 빨리 중지합니다.</target>
        </trans-unit>
        <trans-unit id="2ffd12f9ff030816a3d8b080af1d2850b99b06d2" translate="yes" xml:space="preserve">
          <source>Matches previous character/subexpression exactly n times.</source>
          <target state="translated">이전 문자 / 부 표현식을 정확히 n 번 일치시킵니다.</target>
        </trans-unit>
        <trans-unit id="e30e49830de16035498306cf102e3cf0560e438f" translate="yes" xml:space="preserve">
          <source>Matches previous character/subexpression n times or more. Greedy version - tries as many times as possible.</source>
          <target state="translated">이전 문자 / 부 표현식을 n 번 이상 일치시킵니다. 욕심 버전-가능한 한 많은 시도.</target>
        </trans-unit>
        <trans-unit id="559dc120300f9b03ed2c4d11de66b47f805dff5b" translate="yes" xml:space="preserve">
          <source>Matches previous character/subexpression n times or more. Lazy version - stops as early as possible.</source>
          <target state="translated">이전 문자 / 부 표현식을 n 번 이상 일치시킵니다. 게으른 버전-가능한 빨리 중지합니다.</target>
        </trans-unit>
        <trans-unit id="718cd66ef291724dca1b1655e4689eb3f6e7962c" translate="yes" xml:space="preserve">
          <source>Matches previous character/subexpression n to m times. Greedy version - tries as many times as possible, but no more than m times.</source>
          <target state="translated">이전 문자 / 부 표현식 n과 m 배를 일치시킵니다. 욕심 버전-가능한 한 여러 번 시도하지만 m 번 이상 시도하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="c8c46caef3efc96dcf2d80650ac81f7704565b52" translate="yes" xml:space="preserve">
          <source>Matches previous character/subexpression n to m times. Lazy version - stops as early as possible, but no less then n times.</source>
          <target state="translated">이전 문자 / 부 표현식 n과 m 배를 일치시킵니다. 게으른 버전-가능한 한 빨리 중지하지만 n 배 이상입니다.</target>
        </trans-unit>
        <trans-unit id="55fad56791bcac5e8467a93ff520f840617fad9a" translate="yes" xml:space="preserve">
          <source>Matches subexpression A, or failing that, matches B.</source>
          <target state="translated">하위 표현식 A와 일치하거나 실패하면 B와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="0152891decac3dd1755184ed1399dcc0dad87f92" translate="yes" xml:space="preserve">
          <source>Matches subexpression regex, &lt;em&gt;not&lt;/em&gt; saving matched portion of text. Useful to speed up matching.</source>
          <target state="translated">일치 하는 텍스트 부분을 저장 &lt;em&gt;하지 않고&lt;/em&gt; 하위 표현식 정규식 과 일치합니다. 일치 속도를 높이는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="eb8c9711322ff24a78ef813a8c7d9cf871d789fe" translate="yes" xml:space="preserve">
          <source>Matches subexpression regex, saving matched portion of text for later retrieval.</source>
          <target state="translated">하위 표현식 정규식과 일치하여 나중에 검색 할 수 있도록 일치하는 텍스트 부분을 저장합니다.</target>
        </trans-unit>
        <trans-unit id="6601b3118fcc0e244e360384257b8e903b4ea7f8" translate="yes" xml:space="preserve">
          <source>Matches the character c itself.</source>
          <target state="translated">문자 c 자체와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="8c3dc8c9444ac4e63e48c719abc51544ef470a8f" translate="yes" xml:space="preserve">
          <source>Matches the character itself.</source>
          <target state="translated">캐릭터 자체와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="4cecc7435bfa871d524952f5bff148bdc2b51957" translate="yes" xml:space="preserve">
          <source>Matches the control character corresponding to letter C</source>
          <target state="translated">문자 C에 해당하는 제어 문자와 일치</target>
        </trans-unit>
        <trans-unit id="abd6e41a9323e0a9e48fa76b6daf09b0566eaa14" translate="yes" xml:space="preserve">
          <source>Matches when &lt;em&gt;not&lt;/em&gt; at word boundary.</source>
          <target state="translated">단어 경계에 &lt;em&gt;없을&lt;/em&gt; 때 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="c97355716d3d517fe5e4d25c561b4a081f053fef" translate="yes" xml:space="preserve">
          <source>Matches whitespace, same as \p{White_Space}.</source>
          <target state="translated">\ p {White_Space}와 같은 공백과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="5150558ec125a3f4852d898bf9fb73076c3ddf80" translate="yes" xml:space="preserve">
          <source>Matching</source>
          <target state="translated">Matching</target>
        </trans-unit>
        <trans-unit id="3edf0df49942da6d11a1a217e4d3af4a5a8e64f2" translate="yes" xml:space="preserve">
          <source>Math</source>
          <target state="translated">Math</target>
        </trans-unit>
        <trans-unit id="593ab8a4827c0f6a24bb66511456c27b983c3d36" translate="yes" xml:space="preserve">
          <source>Math notation</source>
          <target state="translated">수학 표기법</target>
        </trans-unit>
        <trans-unit id="cf36f25f0559cb79154e20b8ea575a6b21bd026f" translate="yes" xml:space="preserve">
          <source>Math_Symbol</source>
          <target state="translated">Math_Symbol</target>
        </trans-unit>
        <trans-unit id="6a2f1fef8d0b8728fe438f495de2e1ae827aab61" translate="yes" xml:space="preserve">
          <source>Mathematical Alphanumeric Symbols</source>
          <target state="translated">수학 영숫자 기호</target>
        </trans-unit>
        <trans-unit id="0a46c733f98e0b91d3ba8029a4593062b6eca0a2" translate="yes" xml:space="preserve">
          <source>Mathematical Operators</source>
          <target state="translated">수학 연산자</target>
        </trans-unit>
        <trans-unit id="9d3f9c0127bce6fc83c843d0dd0b886857f901b2" translate="yes" xml:space="preserve">
          <source>Mathematical Special Functions</source>
          <target state="translated">수학 특수 함수</target>
        </trans-unit>
        <trans-unit id="303c3bfeb0c566d68c9cf9bc9d6feb84cfa3e99a" translate="yes" xml:space="preserve">
          <source>Mathematically,</source>
          <target state="translated">Mathematically,</target>
        </trans-unit>
        <trans-unit id="e75225470130f13024b089d576a9938f9308ab12" translate="yes" xml:space="preserve">
          <source>Mathematically, acosh(x) = log(x + sqrt( x*x - 1))</source>
          <target state="translated">수학적으로 acosh (x) = log (x + sqrt (x * x-1))</target>
        </trans-unit>
        <trans-unit id="502c0bcf3d4b5cef68953c91b886223b99eb3579" translate="yes" xml:space="preserve">
          <source>Mathematically, atanh(x) = log( (1+x)/(1-x) ) / 2</source>
          <target state="translated">수학적으로 atanh (x) = log ((1 + x) / (1-x)) / 2</target>
        </trans-unit>
        <trans-unit id="354081ac0eaf5ecbff2a21240af5c85107f9d3b8" translate="yes" xml:space="preserve">
          <source>Mathematically, if z.re &amp;gt; 0 then &amp;Gamma;(z) = &lt;em&gt;&amp;int;&lt;sub&gt;&lt;small&gt;0&lt;/small&gt;&lt;/sub&gt;&lt;sup&gt;&amp;infin;&lt;/sup&gt;&lt;/em&gt; t&lt;sup&gt;z-1&lt;/sup&gt;e&lt;sup&gt;-t&lt;/sup&gt; dt</source>
          <target state="translated">수학적으로 z.re&amp;gt; 0이면 &amp;Gamma; (z) = &lt;em&gt;&amp;int; &lt;sub&gt;&lt;small&gt;0&lt;/small&gt;&lt;/sub&gt;&lt;sup&gt; &amp;infin;&lt;/sup&gt;&lt;/em&gt; t &lt;sup&gt;z-1&lt;/sup&gt; e &lt;sup&gt;-t&lt;/sup&gt; dt</target>
        </trans-unit>
        <trans-unit id="d0b76b554e18654fc7afe37a2d36ca2278c9a0bd" translate="yes" xml:space="preserve">
          <source>Max amount of cached alive connections</source>
          <target state="translated">캐시 된 활성 연결의 최대량</target>
        </trans-unit>
        <trans-unit id="d5b26c0e81e6d1a04cf9525857321ed542c48ef8" translate="yes" xml:space="preserve">
          <source>MaxType!T &lt;strong id=&quot;max&quot;&gt;max&lt;/strong&gt;(T...)(T args)</source>
          <target state="translated">MaxType! T &lt;strong id=&quot;max&quot;&gt;max&lt;/strong&gt; (T ...) (T 인수)</target>
        </trans-unit>
        <trans-unit id="0dd9def42e4e971e29f54b75773752e9cfc0c934" translate="yes" xml:space="preserve">
          <source>Maximum absolute difference. Defaults to &lt;code&gt;1e-5&lt;/code&gt;.</source>
          <target state="translated">최대 절대 차이. 기본값은 &lt;code&gt;1e-5&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="326a29117722fa8006df72d4c88aedadb99f0cb3" translate="yes" xml:space="preserve">
          <source>Maximum absolute difference. This is mainly usefull for comparing values to zero. Setting to 0.0 disables this check. Defaults to &lt;code&gt;0.0&lt;/code&gt;.</source>
          <target state="translated">최대 절대 차이. 이것은 주로 값을 0과 비교하는 데 유용합니다. 0.0으로 설정하면이 검사가 비활성화됩니다. 기본값은 &lt;code&gt;0.0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d56970a7b8384e9f042aab9b74e42a459be282be" translate="yes" xml:space="preserve">
          <source>Maximum absolute difference. This is mainly usefull for comparing values to zero. Setting to 0.0 disables this check. Defaults to &lt;code&gt;1e-5&lt;/code&gt;.</source>
          <target state="translated">최대 절대 차이. 이것은 주로 값을 0과 비교하는 데 유용합니다. 0.0으로 설정하면이 검사가 비활성화됩니다. 기본값은 &lt;code&gt;1e-5&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="24c4e73a22344551fbaade4415de482e307dcb08" translate="yes" xml:space="preserve">
          <source>Maximum allowable difference relative to &lt;code&gt;reference&lt;/code&gt;. Setting to 0.0 disables this check. Defaults to &lt;code&gt;1e-2&lt;/code&gt;.</source>
          <target state="translated">기준에 &lt;code&gt;reference&lt;/code&gt; 최대 허용 차이 . 0.0으로 설정하면이 검사가 비활성화됩니다. 기본값은 &lt;code&gt;1e-2&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2b7b018d266ff7216df8a5bed74f6143c9da1187" translate="yes" xml:space="preserve">
          <source>Maximum allowable difference relative to &lt;code&gt;rhs&lt;/code&gt;. Defaults to &lt;code&gt;1e-2&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;rhs&lt;/code&gt; 에 대한 최대 허용 차이 . 기본값은 &lt;code&gt;1e-2&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="57095b317cfa496d705b2b231f6572a19bbf4841" translate="yes" xml:space="preserve">
          <source>Maximum allowable relative difference. Setting to 0.0 disables this check. Default depends on the type of &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt;: It is approximately half the number of decimal digits of precision of the smaller type.</source>
          <target state="translated">최대 허용 상대 차이. 0.0으로 설정하면이 검사가 비활성화됩니다. 기본값은 &lt;code&gt;lhs&lt;/code&gt; 및 &lt;code&gt;rhs&lt;/code&gt; 유형에 따라 다릅니다 . 더 작은 유형의 정밀도 소수 자릿수의 약 절반입니다.</target>
        </trans-unit>
        <trans-unit id="173bf02e3e5d647f57619cdb3f8fe81ffcb9080f" translate="yes" xml:space="preserve">
          <source>Maximum number of http redirects to follow</source>
          <target state="translated">따라야 할 최대 HTTP 리디렉션 수</target>
        </trans-unit>
        <trans-unit id="549e94c2379df9e88c8b21145c9bed436b888bf9" translate="yes" xml:space="preserve">
          <source>Maximum size eligible for freelisting. Construction with this parameter is defined only if &lt;code&gt;maxSize == chooseAtRuntime&lt;/code&gt; or &lt;code&gt;maxSize == unbounded&lt;/code&gt;.</source>
          <target state="translated">프리리스트에 적합한 최대 크기. 이 매개 변수를 사용한 구성은 &lt;code&gt;maxSize == chooseAtRuntime&lt;/code&gt; 또는 &lt;code&gt;maxSize == unbounded&lt;/code&gt; 경우에만 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="5bc432c657fe4144bd45d936698c166acecd18fa" translate="yes" xml:space="preserve">
          <source>Maximum xShmLock index</source>
          <target state="translated">최대 xShmLock 색인</target>
        </trans-unit>
        <trans-unit id="a5294666cf7ca1197c10f2f70f693b65ba9f87b8" translate="yes" xml:space="preserve">
          <source>May differ from &lt;a href=&quot;#year&quot;&gt;&lt;code&gt;year&lt;/code&gt;&lt;/a&gt; between 28 December and 4 January.</source>
          <target state="translated">12 월 28 일 에서 &lt;a href=&quot;#year&quot;&gt; &lt;code&gt;year&lt;/code&gt; &lt;/a&gt; 월 4 일 사이의 해와 다를 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a70fc4b531788cfa4bd3091286f5c9f6c8385cb7" translate="yes" xml:space="preserve">
          <source>May throw a &lt;code&gt;UTFException&lt;/code&gt; if &lt;code&gt;str[index]&lt;/code&gt; is not one past the end of a valid UTF sequence.</source>
          <target state="translated">던져 수 &lt;code&gt;UTFException&lt;/code&gt; 을 경우 &lt;code&gt;str[index]&lt;/code&gt; 유효한 UTF 시퀀스의 끝을지나 아니다.</target>
        </trans-unit>
        <trans-unit id="e5fa0097c5f6c3d6966b6fd938ee6ef58844d1cb" translate="yes" xml:space="preserve">
          <source>May throw a &lt;code&gt;UTFException&lt;/code&gt; if &lt;code&gt;str[index]&lt;/code&gt; is not the start of a valid UTF sequence.</source>
          <target state="translated">던져 수 &lt;code&gt;UTFException&lt;/code&gt; 을 경우 &lt;code&gt;str[index]&lt;/code&gt; 유효한 UTF 시퀀스의 시작이 아니다.</target>
        </trans-unit>
        <trans-unit id="4cf2cc5419330915ceb88f803da616df3e656fb1" translate="yes" xml:space="preserve">
          <source>Mc</source>
          <target state="translated">Mc</target>
        </trans-unit>
        <trans-unit id="94563ec383e29aa3743abd9b337b2e084fb199fb" translate="yes" xml:space="preserve">
          <source>Me</source>
          <target state="translated">Me</target>
        </trans-unit>
        <trans-unit id="236346d53333e28078765d761ee605b09c5c66e1" translate="yes" xml:space="preserve">
          <source>Meaning:</source>
          <target state="translated">Meaning:</target>
        </trans-unit>
        <trans-unit id="ae0a51f3f8c1bd633457792e73d95ebdfb47fabe" translate="yes" xml:space="preserve">
          <source>Measure a time in milliseconds, microseconds, or nanoseconds</source>
          <target state="translated">밀리 초, 마이크로 초 또는 나노초 단위의 시간 측정</target>
        </trans-unit>
        <trans-unit id="5a8ad743c5f100acd20d0277cefb86b571133693" translate="yes" xml:space="preserve">
          <source>Measures the maximum bytes allocated over the time. This is useful for dimensioning allocators.</source>
          <target state="translated">시간에 따라 할당 된 최대 바이트를 측정합니다. 할당자를 치수를 재는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="ebcd785babc414ca5f7b40b1e241144407a1963a" translate="yes" xml:space="preserve">
          <source>Measures the sum of extra bytes allocated beyond the bytes requested, i.e. the &lt;a href=&quot;http://goo.gl/YoKffF&quot;&gt;internal fragmentation&lt;/a&gt;. This is the current effective number of slack bytes, and it goes up and down with time.</source>
          <target state="translated">요청 된 바이트를 초과하여 할당 된 여분의 바이트, 즉 &lt;a href=&quot;http://goo.gl/YoKffF&quot;&gt;내부 조각화&lt;/a&gt; 의 합계를 측정합니다 . 이것은 현재 유효 슬랙 바이트 수이며 시간이 지남에 따라 증가 및 감소합니다.</target>
        </trans-unit>
        <trans-unit id="5298876653b824c667d42cc5591260aac52d1362" translate="yes" xml:space="preserve">
          <source>Measures the sum of extra bytes allocated beyond the bytes requested, i.e. the &lt;a href=&quot;https://goo.gl/YoKffF&quot;&gt;internal fragmentation&lt;/a&gt;. This is the current effective number of slack bytes, and it goes up and down with time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3428bf3e3bb069070bf76af2715fdc04ab1cc564" translate="yes" xml:space="preserve">
          <source>Meetei Mayek</source>
          <target state="translated">Meetei Mayek</target>
        </trans-unit>
        <trans-unit id="c29a4366fb08674ddc833d9c2d648bc22d81049a" translate="yes" xml:space="preserve">
          <source>Meetei Mayek Extensions</source>
          <target state="translated">Meetei Mayek 확장</target>
        </trans-unit>
        <trans-unit id="a66ec7d3e2375014d1ffe12adf1704c1f323a128" translate="yes" xml:space="preserve">
          <source>Meetei_Mayek</source>
          <target state="translated">Meetei_Mayek</target>
        </trans-unit>
        <trans-unit id="13754495aca84346deb594b0d23bc4d086989ee4" translate="yes" xml:space="preserve">
          <source>Member Functions</source>
          <target state="translated">멤버 함수</target>
        </trans-unit>
        <trans-unit id="0910b8592e88e63cf46fd5f933f9a07965dd736a" translate="yes" xml:space="preserve">
          <source>Member Functions (a.k.a. Methods)</source>
          <target state="translated">멤버 함수 (일명 메서드)</target>
        </trans-unit>
        <trans-unit id="019a4c7b4ab7db0b7225cbe8eaee02aa570d3b44" translate="yes" xml:space="preserve">
          <source>Member fields of a synchronized class cannot be public:</source>
          <target state="translated">동기화 된 클래스의 멤버 필드는 공용 일 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d04f0e51c5452147e13f2fc623076db7f9982260" translate="yes" xml:space="preserve">
          <source>Member functions declared as abstract can still have function bodies. This is so that even though they must be overridden, they can still provide &amp;lsquo;base class functionality&amp;rsquo;, e.g. through &lt;code&gt;super.foo()&lt;/code&gt; in a derived class. Note that the class is still abstract and cannot be instantiated directly.</source>
          <target state="translated">abstract로 선언 된 멤버 함수에는 여전히 함수 본문이있을 수 있습니다. 따라서 재정의해야하더라도 파생 클래스의 &lt;code&gt;super.foo()&lt;/code&gt; 을 통해 '기본 클래스 기능'을 계속 제공 할 수 있습니다 . 클래스는 여전히 추상적이며 직접 인스턴스화 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="94bc1832afe1d646c790e7dacf415889c81edee1" translate="yes" xml:space="preserve">
          <source>Member functions of non-synchronized classes can be individually marked as synchronized.</source>
          <target state="translated">동기화되지 않은 클래스의 멤버 함수는 개별적으로 동기화 된 것으로 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a4bd789ee2475a604bf6ff4993b3e6cecd51772" translate="yes" xml:space="preserve">
          <source>Member functions which are &lt;code&gt;private&lt;/code&gt; or &lt;code&gt;package&lt;/code&gt; are never virtual, and hence cannot be overridden.</source>
          <target state="translated">&lt;code&gt;private&lt;/code&gt; 또는 &lt;code&gt;package&lt;/code&gt; 멤버 함수 는 결코 가상적이지 않으므로 재정의 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="4011f1f1ed250e6e35afd37eaa3106784a7610ca" translate="yes" xml:space="preserve">
          <source>Member functions with Objective-C linkage have an additional hidden, anonymous, parameter which is the selector the function was called with.</source>
          <target state="translated">Objective-C 연결이있는 멤버 함수에는 함수가 호출 된 선택자인 추가 숨겨진 익명 매개 변수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="730bfd462ce7ea2565aafe9ffe8c9ce0ab84dc5f" translate="yes" xml:space="preserve">
          <source>Member functions with the Objective-C linkage has an additional hidden, anonymous, parameter which is the selector the function was called with.</source>
          <target state="translated">Objective-C 연계가있는 멤버 함수에는 함수가 호출 된 선택기 인 추가 숨겨진 익명 매개 변수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b4cee7f1b1fb6a636414a18e51281d77ef7373e" translate="yes" xml:space="preserve">
          <source>Member functions, constructors, destructors, operating overloading, etc.</source>
          <target state="translated">멤버 함수, 생성자, 소멸자, 운영 과부하 등</target>
        </trans-unit>
        <trans-unit id="75c82559a505947763aebe88eed8911e94db5f71" translate="yes" xml:space="preserve">
          <source>Member names not found in a class or struct can be forwarded to a template function named &lt;code&gt;opDispatch&lt;/code&gt; for resolution.</source>
          <target state="translated">클래스 나 구조체에없는 멤버 이름 은 해결을 위해 &lt;code&gt;opDispatch&lt;/code&gt; 라는 템플릿 함수로 전달 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="380b024ed26a6ddc44f49ea617bc4dc47f59b8b6" translate="yes" xml:space="preserve">
          <source>Member template functions cannot be virtual and hence cannot be overridden.</source>
          <target state="translated">멤버 템플릿 기능은 가상 일 수 없으므로 재정의 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="15c228569a3dd4d2d440fdfdc1b2145ae78b2fc2" translate="yes" xml:space="preserve">
          <source>Member to be added.</source>
          <target state="translated">추가 할 멤버입니다.</target>
        </trans-unit>
        <trans-unit id="b43b3bbfea09de9d05623bd67c78ee32f29363bf" translate="yes" xml:space="preserve">
          <source>Member to be decompressed.</source>
          <target state="translated">압축 해제 할 멤버입니다.</target>
        </trans-unit>
        <trans-unit id="163de5e5dca3c7f3fd0faaa10cb4eb20478c931c" translate="yes" xml:space="preserve">
          <source>Member to be deleted.</source>
          <target state="translated">삭제할 멤버입니다.</target>
        </trans-unit>
        <trans-unit id="1cb449c1126609b4b41e1d87f65f0d7cd19b49b9" translate="yes" xml:space="preserve">
          <source>Members</source>
          <target state="translated">Members</target>
        </trans-unit>
        <trans-unit id="d8ffb4f7a80ae39a133b7a5a35dbf287204e2686" translate="yes" xml:space="preserve">
          <source>Members of a base class can be accessed by prepending the name of the base class followed by a dot:</source>
          <target state="translated">기본 클래스 이름 앞에 점을 붙여 기본 클래스의 멤버에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="38b88ba291aedc801f0cf1ace141ae388b9947cc" translate="yes" xml:space="preserve">
          <source>Memory Allocation</source>
          <target state="translated">메모리 할당</target>
        </trans-unit>
        <trans-unit id="57b0394c856fac60e784f92bcfff68951cf81266" translate="yes" xml:space="preserve">
          <source>Memory Allocation Routines</source>
          <target state="translated">메모리 할당 루틴</target>
        </trans-unit>
        <trans-unit id="3a30329db6460c4ed15bebe4d427af9052e6678f" translate="yes" xml:space="preserve">
          <source>Memory Allocation Subsystem</source>
          <target state="translated">메모리 할당 서브 시스템</target>
        </trans-unit>
        <trans-unit id="f5bd12480983914d8406751d31133ba86381302d" translate="yes" xml:space="preserve">
          <source>Memory Allocator Statistics</source>
          <target state="translated">메모리 할당 자 통계</target>
        </trans-unit>
        <trans-unit id="e0efdce50032a40b3a3914e5fc8bfa6cd4288bb5" translate="yes" xml:space="preserve">
          <source>Memory Management</source>
          <target state="translated">메모리 관리</target>
        </trans-unit>
        <trans-unit id="a1bf368dfa41af6966ac27794caf5006abecc398" translate="yes" xml:space="preserve">
          <source>Memory Model</source>
          <target state="translated">메모리 모델</target>
        </trans-unit>
        <trans-unit id="5de1129facae4051e8fdee7abb0f38e9a1213e56" translate="yes" xml:space="preserve">
          <source>Memory Safety</source>
          <target state="translated">메모리 안전</target>
        </trans-unit>
        <trans-unit id="b61b70edbe3a97caa2ecb5ac100b7aca209a1cba" translate="yes" xml:space="preserve">
          <source>Memory allocation</source>
          <target state="translated">메모리 할당</target>
        </trans-unit>
        <trans-unit id="ecdbc7f2417ef638487194e74177e17fd205af0b" translate="yes" xml:space="preserve">
          <source>Memory allocation function</source>
          <target state="translated">메모리 할당 기능</target>
        </trans-unit>
        <trans-unit id="0957c4cd1e00be649fec851480b4b7928614288b" translate="yes" xml:space="preserve">
          <source>Memory locations come in three groups:</source>
          <target state="translated">메모리 위치는 세 그룹으로 나뉩니다.</target>
        </trans-unit>
        <trans-unit id="ac799873aaaeaed7f28a8dcd45e4b44ea97f1ebf" translate="yes" xml:space="preserve">
          <source>Memory safety does not imply that code is portable, uses only sound programming practices, is free of byte order dependencies, or other bugs. It is focussed only on eliminating memory corruption possibilities.</source>
          <target state="translated">메모리 안전은 코드가 이식 가능하다는 것을 의미하지 않으며, 사운드 프로그래밍 방식 만 사용하고, 바이트 순서 의존성 또는 기타 버그가 없습니다. 메모리 손상 가능성을 제거하는 데에만 중점을 둡니다.</target>
        </trans-unit>
        <trans-unit id="8745e9a708aba0d2943782621706fd0939c4d32e" translate="yes" xml:space="preserve">
          <source>Memory safety protections</source>
          <target state="translated">메모리 안전 보호</target>
        </trans-unit>
        <trans-unit id="e7c6afbb979807b3801d17fed1c71c2877b27c2e" translate="yes" xml:space="preserve">
          <source>Memory usage is 8 bytes per each contiguous interval in a set. The value semantics are achieved by using the &lt;a href=&quot;http://en.wikipedia.org/wiki/Copy-on-write&quot;&gt;COW&lt;/a&gt; technique and thus it's not safe to cast this type to shared.</source>
          <target state="translated">메모리 사용량은 한 세트의 각 연속 간격 당 8 바이트입니다. 값 의미론은 &lt;a href=&quot;http://en.wikipedia.org/wiki/Copy-on-write&quot;&gt;COW&lt;/a&gt; 기술 을 사용하여 달성 되므로이 유형을 공유로 캐스트하는 것은 안전하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f0d68fb312f0cf7a4cf5c7166cdac6ab17b52452" translate="yes" xml:space="preserve">
          <source>Memory usage is 8 bytes per each contiguous interval in a set. The value semantics are achieved by using the &lt;a href=&quot;https://en.wikipedia.org/wiki/Copy-on-write&quot;&gt;COW&lt;/a&gt; technique and thus it's not safe to cast this type to shared.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b41ea4fb6a604fb88f6b0c86c204fa450c81da1" translate="yes" xml:space="preserve">
          <source>Memory-Safe-D-Spec</source>
          <target state="translated">Memory-Safe-D-Spec</target>
        </trans-unit>
        <trans-unit id="c247f5fb6586475135ee70daab74580914c6fb6b" translate="yes" xml:space="preserve">
          <source>Memory-safe code &lt;a href=&quot;function#function-safety&quot;&gt;cannot use certain language features&lt;/a&gt;, such as:</source>
          <target state="translated">메모리 안전 코드 &lt;a href=&quot;function#function-safety&quot;&gt;는&lt;/a&gt; 다음과 같은 특정 언어 기능을 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="473d96fd623e27fc2d73e66bac82fb8aa418af0a" translate="yes" xml:space="preserve">
          <source>Merge &lt;code&gt;b&lt;/code&gt; flow analysis results into &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;b&lt;/code&gt; 흐름 분석 결과를 &lt;code&gt;a&lt;/code&gt; 로 병합 합니다 .</target>
        </trans-unit>
        <trans-unit id="96ca7f2df1a2bb46a631ddf55db0107e8a0f6dcf" translate="yes" xml:space="preserve">
          <source>Merge function attributes pure, nothrow, @safe, @nogc, and @disable from f into s1.</source>
          <target state="translated">f에서 s1로 pure, nothrow, @safe, @nogc 및 @disable 함수 속성 병합</target>
        </trans-unit>
        <trans-unit id="18b4df384210c098ee9c1e6e0d3d8ee231c3a119" translate="yes" xml:space="preserve">
          <source>Merge into this function the 'in' contracts of all it overrides. 'in's are OR'd together, i.e. only one of them needs to pass.</source>
          <target state="translated">이 함수로 오버라이드 된 모든 'in'계약을 병합하십시오. '에'는 함께 OR입니다. 즉, 그들 중 하나만 통과하면됩니다.</target>
        </trans-unit>
        <trans-unit id="e39e3795a7731eaa4793023cc894fafa2b4ab3fe" translate="yes" xml:space="preserve">
          <source>Merge into this function the 'out' contracts of all it overrides. 'out's are AND'd together, i.e. all of them need to pass.</source>
          <target state="translated">이 기능을 '오버'계약보다 우선합니다. 'out 's는 AND이며, 즉 모두 통과해야합니다.</target>
        </trans-unit>
        <trans-unit id="02db82771755ecdf0b22312c3b847d054cdfe1f4" translate="yes" xml:space="preserve">
          <source>Merge mod bits to form common mod.</source>
          <target state="translated">모드 비트를 병합하여 공통 모드를 형성하십시오.</target>
        </trans-unit>
        <trans-unit id="c109861e51d1c86a02e432754a712c3fe0fa9fd9" translate="yes" xml:space="preserve">
          <source>Merge multiple sorted ranges &lt;code&gt;rs&lt;/code&gt; with less-than predicate function &lt;code&gt;pred&lt;/code&gt; into one single sorted output range containing the sorted union of the elements of inputs. Duplicates are not eliminated, meaning that the total number of elements in the output is the sum of all elements in the ranges passed to it; the &lt;code&gt;length&lt;/code&gt; member is offered if all inputs also have &lt;code&gt;length&lt;/code&gt;. The element types of all the inputs must have a common type &lt;code&gt;CommonType&lt;/code&gt;.</source>
          <target state="translated">병합은 여러 범위의 정렬 &lt;code&gt;rs&lt;/code&gt; 보다 작음 술어 기능 &lt;code&gt;pred&lt;/code&gt; 입력 요소들의 정렬 된 조합을 포함하는 하나 개의 정렬 된 출력 범위로. 중복이 제거되지 않습니다. 즉, 출력의 총 요소 수는 전달 된 범위에있는 모든 요소의 합계입니다. &lt;code&gt;length&lt;/code&gt; 모든 입력도있는 경우 회원이 제공됩니다 &lt;code&gt;length&lt;/code&gt; . 모든 입력의 요소 유형에는 공통 유형 &lt;code&gt;CommonType&lt;/code&gt; 이 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="0e1d499c82c414943f5481100c85ef8982e1adc8" translate="yes" xml:space="preserve">
          <source>Merge!(less, Rs) &lt;strong id=&quot;merge&quot;&gt;merge&lt;/strong&gt;(alias less = &quot;a &amp;lt; b&quot;, Rs...)(Rs rs)</source>
          <target state="translated">병합! (덜, Rs) &lt;strong id=&quot;merge&quot;&gt;병합&lt;/strong&gt; (별칭 = &quot;a &amp;lt;b&quot;, Rs ...) (Rs rs)</target>
        </trans-unit>
        <trans-unit id="ecd689f30483b3176616a4f345aa11ac1af0123e" translate="yes" xml:space="preserve">
          <source>Merges a range of sorted ranges.</source>
          <target state="translated">정렬 된 범위의 범위를 병합합니다.</target>
        </trans-unit>
        <trans-unit id="3ee86161e1a8c504c0b3ad79f0b486e252c299a5" translate="yes" xml:space="preserve">
          <source>Merges multiple sets. The input sets are passed as a range of ranges and each is assumed to be sorted by &lt;code&gt;less&lt;/code&gt;. Computation is done lazily, one union element at a time. The complexity of one &lt;code&gt;popFront&lt;/code&gt; operation is &amp;Omicron;(&lt;code&gt;log(ror.length)&lt;/code&gt;). However, the length of &lt;code&gt;ror&lt;/code&gt; decreases as ranges in it are exhausted, so the complexity of a full pass through &lt;code&gt;MultiwayMerge&lt;/code&gt; is dependent on the distribution of the lengths of ranges contained within &lt;code&gt;ror&lt;/code&gt;. If all ranges have the same length &lt;code&gt;n&lt;/code&gt; (worst case scenario), the complexity of a full pass through &lt;code&gt;MultiwayMerge&lt;/code&gt; is &amp;Omicron;(&lt;code&gt;n * ror.length * log(ror.length)&lt;/code&gt;), i.e., &lt;code&gt;log(ror.length)&lt;/code&gt; times worse than just spanning all ranges in turn. The output comes sorted (unstably) by &lt;code&gt;less&lt;/code&gt;.</source>
          <target state="translated">여러 세트를 병합합니다. 입력 세트는 범위의 범위로 전달되며 각각은 &lt;code&gt;less&lt;/code&gt; 정렬 된 것으로 가정됩니다 . 계산은 한 번에 하나의 공용체 요소로 느리게 수행됩니다. 하나의 &lt;code&gt;popFront&lt;/code&gt; 연산 의 복잡도 는 &amp;Omicron; ( &lt;code&gt;log(ror.length)&lt;/code&gt; )입니다. 그러나 범위가 소진되면 &lt;code&gt;ror&lt;/code&gt; 의 길이가 감소하므로 &lt;code&gt;MultiwayMerge&lt;/code&gt; 를 통한 전체 패스의 복잡성은 &lt;code&gt;ror&lt;/code&gt; 에 포함 된 범위의 길이 분포에 따라 달라집니다 . 모든 범위가 같은 길이있는 경우 &lt;code&gt;n&lt;/code&gt; (최악의 경우)을 통해 전체 과정의 복잡성 &lt;code&gt;MultiwayMerge&lt;/code&gt; 이 &amp;Omicron;이다 ( &lt;code&gt;n * ror.length * log(ror.length)&lt;/code&gt; ), 즉, &lt;code&gt;log(ror.length)&lt;/code&gt; 모든 범위를 차례로 확장하는 것보다 log (ror.length) 시간이 더 나쁩니다. 출력은 &lt;code&gt;less&lt;/code&gt; 로 (안정적으로) 정렬됩니다 .</target>
        </trans-unit>
        <trans-unit id="c45302b65966374aac57034c7b9f57e0b5ffd393" translate="yes" xml:space="preserve">
          <source>Meroitic Cursive</source>
          <target state="translated">Meroitic 필기체</target>
        </trans-unit>
        <trans-unit id="0dfb86cb098d5f5d08325cb7f5549fffa8c54aa5" translate="yes" xml:space="preserve">
          <source>Meroitic Hieroglyphs</source>
          <target state="translated">Meroitic 상형 문자</target>
        </trans-unit>
        <trans-unit id="fad43e700acf724fbc03a57e905d1e33999d5a95" translate="yes" xml:space="preserve">
          <source>Meroitic_Cursive</source>
          <target state="translated">Meroitic_Cursive</target>
        </trans-unit>
        <trans-unit id="16256e81ed15ae584494444b4607752969d09a87" translate="yes" xml:space="preserve">
          <source>Meroitic_Hieroglyphs</source>
          <target state="translated">Meroitic_Hieroglyphs</target>
        </trans-unit>
        <trans-unit id="441df2997a0bdfabc9155cb3f1b9eb0bfcd1b8d7" translate="yes" xml:space="preserve">
          <source>Mersenne Twister Engines</source>
          <target state="translated">메르 센 트위스터 엔진</target>
        </trans-unit>
        <trans-unit id="e35d33912d5bd7fc92d12ad758d85ef83755b678" translate="yes" xml:space="preserve">
          <source>Message describing the error.</source>
          <target state="translated">오류를 설명하는 메시지입니다.</target>
        </trans-unit>
        <trans-unit id="e5f4b8e2eaa86c20a211c5730b176738e052b5df" translate="yes" xml:space="preserve">
          <source>Message logging is a common approach to expose runtime information of a program. Logging should be easy, but also flexible and powerful, therefore &lt;code&gt;D&lt;/code&gt; provides a standard interface for logging.  The easiest way to create a log message is to write:</source>
          <target state="translated">메시지 로깅은 프로그램의 런타임 정보를 노출하는 일반적인 방법입니다. 로깅은 쉽고 유연하고 강력해야하므로 &lt;code&gt;D&lt;/code&gt; 는 로깅을위한 표준 인터페이스를 제공합니다. 로그 메시지를 작성하는 가장 쉬운 방법은 다음과 같이 작성하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="1a14b3e6b388251b68ea9615ecf15beddb585962" translate="yes" xml:space="preserve">
          <source>Messages are logged if the &lt;code&gt;LogLevel&lt;/code&gt; of the log message is greater than or equal to the &lt;code&gt;LogLevel&lt;/code&gt; of the used &lt;code&gt;Logger&lt;/code&gt; and additionally if the &lt;code&gt;LogLevel&lt;/code&gt; of the log message is greater than or equal to the global &lt;code&gt;LogLevel&lt;/code&gt;. If a condition is passed into the log call, this condition must be true.  The global &lt;code&gt;LogLevel&lt;/code&gt; is accessible by using &lt;code&gt;globalLogLevel&lt;/code&gt;. To assign a &lt;code&gt;LogLevel&lt;/code&gt; of a &lt;code&gt;Logger&lt;/code&gt; use the &lt;code&gt;logLevel&lt;/code&gt; property of the logger.</source>
          <target state="translated">경우 생성 메시지가 기록된다 &lt;code&gt;LogLevel&lt;/code&gt; 에 로그 메시지가 또는는 동일한보다 큰 &lt;code&gt;LogLevel&lt;/code&gt; 에 사용한의 &lt;code&gt;Logger&lt;/code&gt; 및 부가 경우 &lt;code&gt;LogLevel&lt;/code&gt; 에 로그 메시지가 글로벌 같거나보다 큰 &lt;code&gt;LogLevel&lt;/code&gt; 에 . 조건이 로그 호출로 전달되면이 조건은 true 여야합니다. &lt;code&gt;globalLogLevel&lt;/code&gt; 을 사용하여 글로벌 &lt;code&gt;LogLevel&lt;/code&gt; 에 액세스 할 수 있습니다 . 지정하려면 &lt;code&gt;LogLevel&lt;/code&gt; 에 의 &lt;code&gt;Logger&lt;/code&gt; 사용 &lt;code&gt;logLevel&lt;/code&gt; 로거의 특성을.</target>
        </trans-unit>
        <trans-unit id="674200f0791d0391b26e7ab0cb61f591c00e9006" translate="yes" xml:space="preserve">
          <source>Messages that inform about critical errors should be logged with this level.</source>
          <target state="translated">중대한 오류를 알리는 메시지는이 수준으로 기록해야합니다.</target>
        </trans-unit>
        <trans-unit id="3b1389e0e832a05337d6ccb31e50ea1425ca91a8" translate="yes" xml:space="preserve">
          <source>Method name</source>
          <target state="translated">방법 이름</target>
        </trans-unit>
        <trans-unit id="5432728a99110699123ab292c79d8929b4a93cff" translate="yes" xml:space="preserve">
          <source>Method name to call.</source>
          <target state="translated">호출 할 메소드 이름.</target>
        </trans-unit>
        <trans-unit id="c33db9381eac351f01f1ebcace4d045842265eb0" translate="yes" xml:space="preserve">
          <source>Methods of a final class are &lt;code&gt;final&lt;/code&gt; by default.</source>
          <target state="translated">final 클래스의 메소드는 기본적으로 &lt;code&gt;final&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="536a2a35026e0b6a919478b3ed257a839d2e1750" translate="yes" xml:space="preserve">
          <source>Methods returning &lt;code&gt;Ternary&lt;/code&gt; return &lt;code&gt;Ternary.yes&lt;/code&gt; upon success, &lt;code&gt;Ternary.no&lt;/code&gt; upon failure, and &lt;code&gt;Ternary.unknown&lt;/code&gt; if the primitive is not implemented by the allocator instance.</source>
          <target state="translated">반환 방법 &lt;code&gt;Ternary&lt;/code&gt; 반환 &lt;code&gt;Ternary.yes&lt;/code&gt; 성공에 따라, &lt;code&gt;Ternary.no&lt;/code&gt; 을 실패시와 &lt;code&gt;Ternary.unknown&lt;/code&gt; 은 원시적 인 경우 할당 인스턴스에 의해 구현되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cc7e0e02c16756d9acee15cd9d7a7473daeb068d" translate="yes" xml:space="preserve">
          <source>Miao</source>
          <target state="translated">Miao</target>
        </trans-unit>
        <trans-unit id="4014a3a1206afc2fb8f2e5f9f2071d7a3abf5198" translate="yes" xml:space="preserve">
          <source>Microsoft 32 bit Windows systems</source>
          <target state="translated">Microsoft 32 비트 Windows 시스템</target>
        </trans-unit>
        <trans-unit id="b6f7d07f6d0d4d6ca14a809acf6053a583de57a5" translate="yes" xml:space="preserve">
          <source>Microsoft 32-bit Windows systems</source>
          <target state="translated">Microsoft 32 비트 Windows 시스템</target>
        </trans-unit>
        <trans-unit id="0a7f8a6a3c059af73acb9cd574b05b2a9543c4ad" translate="yes" xml:space="preserve">
          <source>Microsoft 64 bit Windows systems</source>
          <target state="translated">Microsoft 64 비트 Windows 시스템</target>
        </trans-unit>
        <trans-unit id="ac72b2ac11f991f699272cc1db01bb25e6d51711" translate="yes" xml:space="preserve">
          <source>Microsoft 64-bit Windows systems</source>
          <target state="translated">Microsoft 64 비트 Windows 시스템</target>
        </trans-unit>
        <trans-unit id="ed82c6f8a58bc49b4d9060c4f66fdffc94ae06da" translate="yes" xml:space="preserve">
          <source>Microsoft C runtime</source>
          <target state="translated">Microsoft C 런타임</target>
        </trans-unit>
        <trans-unit id="ebd6d05a731e12a86c8b4e80bc60f72f287734f6" translate="yes" xml:space="preserve">
          <source>Microsoft COFF object file format</source>
          <target state="translated">Microsoft COFF 오브젝트 파일 형식</target>
        </trans-unit>
        <trans-unit id="c16c96e5cb2017286d8a64c25450e71226f0000b" translate="yes" xml:space="preserve">
          <source>Microsoft Corporation backward compatibility</source>
          <target state="translated">Microsoft Corporation 이전 버전과의 호환성</target>
        </trans-unit>
        <trans-unit id="7a650ad47d922de9a3c42b429d96b1e405df1b9b" translate="yes" xml:space="preserve">
          <source>Microsoft Cpp runtime</source>
          <target state="translated">Microsoft Cpp 런타임</target>
        </trans-unit>
        <trans-unit id="9bde9e716692327663fd157039cda187ce1ee7df" translate="yes" xml:space="preserve">
          <source>Microsoft Windows systems</source>
          <target state="translated">Microsoft Windows 시스템</target>
        </trans-unit>
        <trans-unit id="eecec507337963babdc80d1f001447bcfa1ad938" translate="yes" xml:space="preserve">
          <source>Mike Cote, John Micco and &lt;a href=&quot;http://www.digitalmars.com&quot;&gt;Walter Bright&lt;/a&gt;</source>
          <target state="translated">마이크 코트, 존 미코, &lt;a href=&quot;http://www.digitalmars.com&quot;&gt;월터 브라이트&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ce0263fbd5d81126a5accf38c2a8cfa720a38f5f" translate="yes" xml:space="preserve">
          <source>Mike Cote, John Micco, &lt;a href=&quot;http://www.digitalmars.com&quot;&gt;Walter Bright&lt;/a&gt;,</source>
          <target state="translated">마이크 코트, 존 미코, &lt;a href=&quot;http://www.digitalmars.com&quot;&gt;월터 브라이트&lt;/a&gt; ,</target>
        </trans-unit>
        <trans-unit id="646bada43bacb04d883be0a800cf55c1bff27489" translate="yes" xml:space="preserve">
          <source>MinType!T &lt;strong id=&quot;min&quot;&gt;min&lt;/strong&gt;(T...)(T args)</source>
          <target state="translated">MinType! T &lt;strong id=&quot;min&quot;&gt;min&lt;/strong&gt; (T ...) (T args)</target>
        </trans-unit>
        <trans-unit id="96619c2744574ba83e062f07794a4bce5e184561" translate="yes" xml:space="preserve">
          <source>Minimum global level this condition needs to pass. Only used if &lt;code&gt;ident&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">이 조건을 통과해야하는 최소 전역 수준. &lt;code&gt;ident&lt;/code&gt; 가 &lt;code&gt;null&lt;/code&gt; 인 경우에만 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="72ac10aa985b72fc878006245095a438f4afd28d" translate="yes" xml:space="preserve">
          <source>Minimum number of input bytes to process</source>
          <target state="translated">처리 할 최소 입력 바이트 수</target>
        </trans-unit>
        <trans-unit id="23735bdebe5dd753b2eecb3ee5464f912043405c" translate="yes" xml:space="preserve">
          <source>Minimum number of output bytes to process</source>
          <target state="translated">처리 할 최소 출력 바이트 수</target>
        </trans-unit>
        <trans-unit id="7520451067e6f7c0bfa18e9bfe94463900128da6" translate="yes" xml:space="preserve">
          <source>Minimum size eligible for freelisting. Construction with this parameter is defined only if &lt;code&gt;minSize == chooseAtRuntime&lt;/code&gt;. If this condition is met and no &lt;code&gt;min&lt;/code&gt; parameter is present, &lt;code&gt;min&lt;/code&gt; is initialized with &lt;code&gt;max&lt;/code&gt;.</source>
          <target state="translated">프리리스트에 적합한 최소 크기. 이 매개 변수를 사용한 구성은 &lt;code&gt;minSize == chooseAtRuntime&lt;/code&gt; 경우에만 정의됩니다 . 이 조건이 충족되는 경우 어떠한 &lt;code&gt;min&lt;/code&gt; 파라미터가 존재하지 않는, &lt;code&gt;min&lt;/code&gt; 로 초기화 &lt;code&gt;max&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0fbfeb63cedecc26008c4032bda53482f765205a" translate="yes" xml:space="preserve">
          <source>Minimum width, default &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">최소 너비, 기본값은 &lt;code&gt;0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b86e7a6a020ac76991cd6c26e23328074d134a16" translate="yes" xml:space="preserve">
          <source>Minor HTTP version ie. 0 in HTTP/1.0.</source>
          <target state="translated">작은 HTTP 버전 즉. HTTP / 1.0에서는 0입니다.</target>
        </trans-unit>
        <trans-unit id="ef8cde8759f0faa5c37800217783e19162b32772" translate="yes" xml:space="preserve">
          <source>Minor differences can be handled by constant defined in a system specific import, and then using that constant in an</source>
          <target state="translated">시스템 별 가져 오기에 정의 된 상수에 의해 작은 차이를 처리 한 다음 해당 상수를</target>
        </trans-unit>
        <trans-unit id="276eb814fa83eb8650d994da85c3e0fe04f261ce" translate="yes" xml:space="preserve">
          <source>Minute of the hour [0 - 60).</source>
          <target state="translated">시간 분 [0-60).</target>
        </trans-unit>
        <trans-unit id="6fe63922288d3720f67a6b936f7e7d8469da7b2c" translate="yes" xml:space="preserve">
          <source>Minutes past the current hour.</source>
          <target state="translated">현재 시간을 지난 분.</target>
        </trans-unit>
        <trans-unit id="9eb18cc6cb54a3c25688822c68aea8834585db05" translate="yes" xml:space="preserve">
          <source>Minutes past the hour.</source>
          <target state="translated">시간이 지 났어요</target>
        </trans-unit>
        <trans-unit id="9fcc2a870494a945127b62192effb291451b3f6c" translate="yes" xml:space="preserve">
          <source>Misaligned pointers may be used if the underlying hardware supports them &lt;b&gt;and&lt;/b&gt; the pointer is never used to point into the GC heap.</source>
          <target state="translated">잘못 정렬 된 포인터는 그 기본 하드웨어가 지원하는 경우 사용할 수 있습니다 &lt;b&gt;및&lt;/b&gt; 포인터는 GC 힙에 포인트로 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0a893ece8e469a3ca3d935c49f41d08d04b75ecc" translate="yes" xml:space="preserve">
          <source>Misc</source>
          <target state="translated">Misc</target>
        </trans-unit>
        <trans-unit id="5f2cbd107037ed23248e5058a7a64cd6bae05468" translate="yes" xml:space="preserve">
          <source>Miscellaneous</source>
          <target state="translated">Miscellaneous</target>
        </trans-unit>
        <trans-unit id="541cc60b15fef5f9a0d86353e83aac8f8978605b" translate="yes" xml:space="preserve">
          <source>Miscellaneous Mathematical Symbols-A</source>
          <target state="translated">기타 수학 기호 -A</target>
        </trans-unit>
        <trans-unit id="11779b66b9fb2d0a37251ee4317a6797b1ced04b" translate="yes" xml:space="preserve">
          <source>Miscellaneous Mathematical Symbols-B</source>
          <target state="translated">기타 수학 기호 -B</target>
        </trans-unit>
        <trans-unit id="a5ae444d30ca53b5d78b290b90087547ee9d3bad" translate="yes" xml:space="preserve">
          <source>Miscellaneous Symbols</source>
          <target state="translated">기타 기호</target>
        </trans-unit>
        <trans-unit id="d40df653d33c1970b2f4ff4a287cf2530bc9a141" translate="yes" xml:space="preserve">
          <source>Miscellaneous Symbols And Pictographs</source>
          <target state="translated">기타 기호 및 상형</target>
        </trans-unit>
        <trans-unit id="cc7c226cc2dbc1d256d3a82995b8efaa4183a299" translate="yes" xml:space="preserve">
          <source>Miscellaneous Symbols and Arrows</source>
          <target state="translated">기타 기호 및 화살표</target>
        </trans-unit>
        <trans-unit id="b4173dcb7119b89bcf0b405aae468ee1b3ada77b" translate="yes" xml:space="preserve">
          <source>Miscellaneous Technical</source>
          <target state="translated">기타 기술</target>
        </trans-unit>
        <trans-unit id="91b6cb48d150ba0933d7fc6f4df7440a745c169f" translate="yes" xml:space="preserve">
          <source>Mismatched arguments and formats result in a &lt;code&gt; FormatException&lt;/code&gt; being thrown.</source>
          <target state="translated">일치하지 않는 인수 및 형식으로 인해 &lt;code&gt; FormatException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9f4313428de55c91dd490c268154ae445becae4a" translate="yes" xml:space="preserve">
          <source>Mixin Declaration</source>
          <target state="translated">믹스 인 선언</target>
        </trans-unit>
        <trans-unit id="970c2320d1bfe8e77dd4e7dd5bb34d2e4ac013f5" translate="yes" xml:space="preserve">
          <source>Mixin Expressions</source>
          <target state="translated">믹스 인 표현</target>
        </trans-unit>
        <trans-unit id="05c3d721d13b6e356ee3eef96ba0569377ee567e" translate="yes" xml:space="preserve">
          <source>Mixin Scope</source>
          <target state="translated">믹스 인 범위</target>
        </trans-unit>
        <trans-unit id="4ca673828825e6fb0a1c7aa7b3baac8a4415fa74" translate="yes" xml:space="preserve">
          <source>Mixin Statement</source>
          <target state="translated">믹스 인 진술</target>
        </trans-unit>
        <trans-unit id="a55840005f5cf42b3920857662d4a3179c53e14d" translate="yes" xml:space="preserve">
          <source>Mixin declarations, like: mixin(&quot;int x&quot;); &lt;a href=&quot;https://dlang.org/spec/module.html#mixin-declaration&quot;&gt;https://dlang.org/spec/module.html#mixin-declaration&lt;/a&gt;</source>
          <target state="translated">다음과 같은 믹스 인 선언 : mixin ( &quot;int x&quot;); &lt;a href=&quot;https://dlang.org/spec/module.html#mixin-declaration&quot;&gt;https://dlang.org/spec/module.html#mixin-declaration&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1246e35b912ba38445c7ecaa8bf8ad7a769360a5" translate="yes" xml:space="preserve">
          <source>Mixin to create a signal within a class object.</source>
          <target state="translated">믹스하여 클래스 객체 내에 신호를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="47620c2433a5ab559d0c8a5a645ecf0ac1a65079" translate="yes" xml:space="preserve">
          <source>MixinTemplateName</source>
          <target state="translated">MixinTemplateName</target>
        </trans-unit>
        <trans-unit id="a80a20f619b719e7320185da056d428905f0e3b9" translate="yes" xml:space="preserve">
          <source>Mixing Memory Pools</source>
          <target state="translated">메모리 풀 혼합</target>
        </trans-unit>
        <trans-unit id="ef39b028b40565a8271f3d2ef7d30563984e8bc1" translate="yes" xml:space="preserve">
          <source>Mixing memory management strategies (GC + manual memory management) can be tricky, hence removing D's GC from the equation may be worthwhile sometimes.</source>
          <target state="translated">혼합 메모리 관리 전략 (GC + 수동 메모리 관리)은 까다로울 수 있으므로 방정식에서 D의 GC를 제거하는 것이 때때로 가치가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="602c1de155aef24628d7038834874c6fffc0b6fa" translate="yes" xml:space="preserve">
          <source>Mixing struct constructors and &lt;code&gt;static opCall&lt;/code&gt; is not allowed.</source>
          <target state="translated">구조체 생성자와 &lt;code&gt;static opCall&lt;/code&gt; 혼합 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d4103da3e3d11e8682ca7214516c5066dddbce1b" translate="yes" xml:space="preserve">
          <source>Mixins are evaluated in the scope of where they appear, not the scope of the template declaration:</source>
          <target state="translated">믹스 인은 템플릿 선언의 범위가 아니라 표시되는 범위에서 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="c2e7f916aaa9cd501280e6c15b4f67cd1691d8dc" translate="yes" xml:space="preserve">
          <source>Mixins can add virtual functions to a class:</source>
          <target state="translated">믹스 인은 클래스에 가상 함수를 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f55b2564a92bcf6859a24f6ce115142e96f27a3d" translate="yes" xml:space="preserve">
          <source>Mixins can be parameterized:</source>
          <target state="translated">믹스 인은 파라미터 화 될 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="0e0cc6d6a4019a943d3fb16059acca448a091f6c" translate="yes" xml:space="preserve">
          <source>Mixins can parameterize symbols using alias parameters:</source>
          <target state="translated">믹스 인은 별칭 파라미터를 사용하여 심볼을 파라미터화할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d3456e398172f180f8497d1149d800d0157031d" translate="yes" xml:space="preserve">
          <source>MmFile objects control the memory mapped file resource.</source>
          <target state="translated">MmFile 객체는 메모리 매핑 된 파일 리소스를 제어합니다.</target>
        </trans-unit>
        <trans-unit id="35175076c72c31fd517a5a9c6d72204f71d15dc7" translate="yes" xml:space="preserve">
          <source>Mn</source>
          <target state="translated">Mn</target>
        </trans-unit>
        <trans-unit id="d92d632ad70c36fb1672c13251c63eac88e413a9" translate="yes" xml:space="preserve">
          <source>Mode &lt;code&gt;mode&lt;/code&gt;</source>
          <target state="translated">모드 &lt;code&gt;mode&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="88822b475ea7dae25ac66418498e7b0921c4b86a" translate="yes" xml:space="preserve">
          <source>Mode &lt;strong id=&quot;mode&quot;&gt;mode&lt;/strong&gt;();</source>
          <target state="translated">모드 &lt;strong id=&quot;mode&quot;&gt;모드&lt;/strong&gt; ();</target>
        </trans-unit>
        <trans-unit id="a0f130d655b96fb098a22c25e359b43327c97c9e" translate="yes" xml:space="preserve">
          <source>Mode to associate with this File. The mode has the same semantics semantics as in the C standard library &lt;a href=&quot;http://cplusplus.com/reference/cstdio/fopen/&quot;&gt;fdopen&lt;/a&gt; function, and must be compatible with &lt;code&gt;fd&lt;/code&gt;.</source>
          <target state="translated">이 파일과 연결할 모드입니다. 모드는 C 표준 라이브러리 &lt;a href=&quot;http://cplusplus.com/reference/cstdio/fopen/&quot;&gt;fdopen&lt;/a&gt; 함수에서와 동일한 의미론을 가지며 &lt;code&gt;fd&lt;/code&gt; 와 호환되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="5c58c26e6b83749e7dad65a9fe45675deb95b104" translate="yes" xml:space="preserve">
          <source>Mode to use for decoding.</source>
          <target state="translated">디코딩에 사용할 모드입니다.</target>
        </trans-unit>
        <trans-unit id="bf450e500975a036b6274b77d63a23a31754d542" translate="yes" xml:space="preserve">
          <source>Modern Features?</source>
          <target state="translated">현대적인 특징?</target>
        </trans-unit>
        <trans-unit id="9836b361a7d6a40632b395085dcbd7a2727fe256" translate="yes" xml:space="preserve">
          <source>Modern Formatted Writing</source>
          <target state="translated">현대 형식의 글쓰기</target>
        </trans-unit>
        <trans-unit id="4bd2738f029c8a83162857e80150020a1b8efa00" translate="yes" xml:space="preserve">
          <source>Modifiable &lt;strong id=&quot;checkModifiable&quot;&gt;checkModifiable&lt;/strong&gt;(Scope* sc, int flag = 0);</source>
          <target state="translated">수정 가능한 &lt;strong id=&quot;checkModifiable&quot;&gt;checkModifiable&lt;/strong&gt; (Scope * sc, int 플래그 = 0);</target>
        </trans-unit>
        <trans-unit id="08b349ac1c097b91fcbd83115613e840381fbc40" translate="yes" xml:space="preserve">
          <source>Modifiable.yes or Modifiable.initialization</source>
          <target state="translated">Modifiable.yes 또는 Modifiable.initialization</target>
        </trans-unit>
        <trans-unit id="e1a38da29f4d24e5a1f0e3b0d0a11f0ec65a4ef0" translate="yes" xml:space="preserve">
          <source>Modification of pointer values.</source>
          <target state="translated">포인터 값 수정.</target>
        </trans-unit>
        <trans-unit id="f260e757cec75096bc3eefbfb1c4a14720832017" translate="yes" xml:space="preserve">
          <source>Modifier</source>
          <target state="translated">Modifier</target>
        </trans-unit>
        <trans-unit id="c28e47f6044e41ff0471e331bc5947f7ad950346" translate="yes" xml:space="preserve">
          <source>Modifier Tone Letters</source>
          <target state="translated">수정 자 톤 문자</target>
        </trans-unit>
        <trans-unit id="8346f1ccfc1c83e1327c9516f54835e7836ddef2" translate="yes" xml:space="preserve">
          <source>Modifier_Letter</source>
          <target state="translated">Modifier_Letter</target>
        </trans-unit>
        <trans-unit id="31a38c9c5af3c6a38d76df500b9d21534d32817b" translate="yes" xml:space="preserve">
          <source>Modifier_Symbol</source>
          <target state="translated">Modifier_Symbol</target>
        </trans-unit>
        <trans-unit id="3a7ea294bf33134dce4b142b8b7182de29b978b2" translate="yes" xml:space="preserve">
          <source>Modifiers</source>
          <target state="translated">Modifiers</target>
        </trans-unit>
        <trans-unit id="9fe408e12dc6ee8d44c87b38b82ff435c397a441" translate="yes" xml:space="preserve">
          <source>Modify</source>
          <target state="translated">Modify</target>
        </trans-unit>
        <trans-unit id="e7532a054e72ed2b2ee923a9b28bf5cd38743380" translate="yes" xml:space="preserve">
          <source>Modify all expression type of return statements to tret.</source>
          <target state="translated">모든 표현식 유형의 리턴 명령문을 tret로 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="b8ff02892916ff59f7fbd4e617fccd01f6bca576" translate="yes" xml:space="preserve">
          <source>Module</source>
          <target state="translated">Module</target>
        </trans-unit>
        <trans-unit id="6658e9ce5ba737387d02a8c5def43fd4cf55b431" translate="yes" xml:space="preserve">
          <source>Module &lt;code&gt;m&lt;/code&gt;</source>
          <target state="translated">모듈 &lt;code&gt;m&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="937ba920fb486031428c2fad0ad46f6224397871" translate="yes" xml:space="preserve">
          <source>Module &lt;code&gt;mod&lt;/code&gt;</source>
          <target state="translated">모듈 &lt;code&gt;mod&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="53369c001691b815ca3a05eecd1682d09a8470cd" translate="yes" xml:space="preserve">
          <source>Module &lt;strong id=&quot;entrypoint&quot;&gt;entrypoint&lt;/strong&gt;;</source>
          <target state="translated">모듈 &lt;strong id=&quot;entrypoint&quot;&gt;진입 점&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="c8bf8cd6d1bd90507075fdd4361174c0fa37286c" translate="yes" xml:space="preserve">
          <source>Module &lt;strong id=&quot;importedFrom&quot;&gt;importedFrom&lt;/strong&gt;;</source>
          <target state="translated">&lt;strong id=&quot;importedFrom&quot;&gt;수입&lt;/strong&gt; 모듈 ;</target>
        </trans-unit>
        <trans-unit id="ff53f93875f0242523e6c98ab579d326f23c343e" translate="yes" xml:space="preserve">
          <source>Module &lt;strong id=&quot;parse&quot;&gt;parse&lt;/strong&gt;();</source>
          <target state="translated">모듈 &lt;strong id=&quot;parse&quot;&gt;파싱&lt;/strong&gt; ();</target>
        </trans-unit>
        <trans-unit id="512a40abc1493f140d5c39a8e2d19f624b504462" translate="yes" xml:space="preserve">
          <source>Module &lt;strong id=&quot;parse&quot;&gt;parse&lt;/strong&gt;(AST)(DiagnosticReporter diagnosticReporter);</source>
          <target state="translated">모듈 &lt;strong id=&quot;parse&quot;&gt;파싱&lt;/strong&gt; (AST) (DiagnosticReporter diagnosticReporter);</target>
        </trans-unit>
        <trans-unit id="c79df9fc0acbd8cd2ea949b87e97fb853b994bf3" translate="yes" xml:space="preserve">
          <source>Module &lt;strong id=&quot;rootHasMain&quot;&gt;rootHasMain&lt;/strong&gt;;</source>
          <target state="translated">모듈 &lt;strong id=&quot;rootHasMain&quot;&gt;rootHasMain&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="b60388160a0e83135f7049a2a65562bf3b5b53e0" translate="yes" xml:space="preserve">
          <source>Module Declaration</source>
          <target state="translated">모듈 선언</target>
        </trans-unit>
        <trans-unit id="fd27d97553a2a8a4d766210d868e6015f60e1ae7" translate="yes" xml:space="preserve">
          <source>Module Initialization and Termination</source>
          <target state="translated">모듈 초기화 및 종료</target>
        </trans-unit>
        <trans-unit id="ca4ce7b8e6017ea6f7141a9e94c2ffc705fd320b" translate="yes" xml:space="preserve">
          <source>Module Scope Operator</source>
          <target state="translated">모듈 범위 연산자</target>
        </trans-unit>
        <trans-unit id="6483f83ef8550752d7a2e299c6b850018ec74cd5" translate="yes" xml:space="preserve">
          <source>Module constructor and destructor routines.</source>
          <target state="translated">모듈 생성자와 소멸자 루틴.</target>
        </trans-unit>
        <trans-unit id="2d4c60ff894bd0aa405d27e42fcae8268f876f90" translate="yes" xml:space="preserve">
          <source>Module containing core time functionality, such as &lt;a href=&quot;#Duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; (which represents a duration of time) or &lt;a href=&quot;#MonoTime&quot;&gt;&lt;code&gt;MonoTime&lt;/code&gt;&lt;/a&gt; (which represents a timestamp of the system's monotonic clock).</source>
          <target state="translated">&lt;a href=&quot;#Duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt; ( 지속 시간 을 나타냄) 또는 &lt;a href=&quot;#MonoTime&quot;&gt; &lt;code&gt;MonoTime&lt;/code&gt; &lt;/a&gt; (시스템의 단조로운 시계의 시간 소인을 나타냄 ) 과 같은 핵심 시간 기능을 포함하는 모듈 .</target>
        </trans-unit>
        <trans-unit id="0a81435755ae74b4d015fcd51a7cfdac0b3182d8" translate="yes" xml:space="preserve">
          <source>Module containing some basic benchmarking and timing functionality.</source>
          <target state="translated">기본적인 벤치마킹 및 타이밍 기능을 포함하는 모듈.</target>
        </trans-unit>
        <trans-unit id="a0a8a168e341b16dc8158618161a129b9b407119" translate="yes" xml:space="preserve">
          <source>Module in which the D main is</source>
          <target state="translated">D 메인이있는 모듈</target>
        </trans-unit>
        <trans-unit id="58b8208bcfdac835bd589f0a0f394caee9130541" translate="yes" xml:space="preserve">
          <source>Module names</source>
          <target state="translated">모듈 이름</target>
        </trans-unit>
        <trans-unit id="70899daeefb999b373eb42fec0ee19192cad4996" translate="yes" xml:space="preserve">
          <source>Module symbols can be imported.</source>
          <target state="translated">모듈 기호를 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a2b694f1832151dfbd90f5a6a709070e10c8d5ee" translate="yes" xml:space="preserve">
          <source>Module this node belongs to</source>
          <target state="translated">이 노드가 속한 모듈</target>
        </trans-unit>
        <trans-unit id="fa098333373ac1a458273e0aff013b55525016b7" translate="yes" xml:space="preserve">
          <source>Module unit test handler</source>
          <target state="translated">모듈 유닛 테스트 핸들러</target>
        </trans-unit>
        <trans-unit id="8e4dbc79efde2a2b6f620f3e85fc1dec81fe54f7" translate="yes" xml:space="preserve">
          <source>ModuleDeclaration</source>
          <target state="translated">ModuleDeclaration</target>
        </trans-unit>
        <trans-unit id="1d70436f71331e7691f5e4a6575b7798509f7215" translate="yes" xml:space="preserve">
          <source>ModuleFullyQualifiedName</source>
          <target state="translated">ModuleFullyQualifiedName</target>
        </trans-unit>
        <trans-unit id="04e9462c0ff02bb9032b92abd45881a3c7e15fb7" translate="yes" xml:space="preserve">
          <source>Modules</source>
          <target state="translated">Modules</target>
        </trans-unit>
        <trans-unit id="cb6c75d384ba2ee83daf2876f5a399b7c1f0f1fe" translate="yes" xml:space="preserve">
          <source>Modules &lt;strong id=&quot;createModules&quot;&gt;createModules&lt;/strong&gt;(ref Strings files, ref Strings libmodules);</source>
          <target state="translated">모듈 &lt;strong id=&quot;createModules&quot;&gt;createModules&lt;/strong&gt; (참조 문자열 파일, 참조 문자열 libmodules);</target>
        </trans-unit>
        <trans-unit id="3da6e793084964d8a57e69c238db9dd58256809c" translate="yes" xml:space="preserve">
          <source>Modules are always compiled at global scope, and are unaffected by surrounding attributes or other modifiers.</source>
          <target state="translated">모듈은 항상 전역 범위에서 컴파일되며 주변 속성 또는 기타 수정 자의 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ee05c4b1bd6be476eb53ca950de0eb4c248b18b7" translate="yes" xml:space="preserve">
          <source>Modules automatically provide a namespace scope for their contents. Modules superficially resemble classes, but differ in that:</source>
          <target state="translated">모듈은 내용에 대한 네임 스페이스 범위를 자동으로 제공합니다. 모듈은 표면적으로 클래스와 비슷하지만 다음과는 다릅니다.</target>
        </trans-unit>
        <trans-unit id="b416e3eb463a331e85667194c836c015f4d354e1" translate="yes" xml:space="preserve">
          <source>Modules can be grouped together in hierarchies called</source>
          <target state="translated">모듈을 계층 구조로 그룹화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3e78263eed2a0541f7c20a04b773beb7d10b627d" translate="yes" xml:space="preserve">
          <source>Modules do not inherit, they have no super modules, etc.</source>
          <target state="translated">모듈은 상속받지 않으며 수퍼 모듈 등이 없습니다.</target>
        </trans-unit>
        <trans-unit id="fe99ae5c5906ceceb6d714060f49ed25dbefbd27" translate="yes" xml:space="preserve">
          <source>Modules have a one-to-one correspondence with source files. The module name is, by default, the file name with the path and extension stripped off, and can be set explicitly with the module declaration.</source>
          <target state="translated">모듈은 소스 파일과 일대일로 대응됩니다. 기본적으로 모듈 이름은 경로와 확장명이 제거 된 파일 이름이며 모듈 선언으로 명시 적으로 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="077b9b7259692d5a93f09beb6ff63b63184c5793" translate="yes" xml:space="preserve">
          <source>Modules offer several guarantees:</source>
          <target state="translated">모듈은 몇 가지 보증을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="58a0f28806f53fd75308c3f2a793267cf1428ae8" translate="yes" xml:space="preserve">
          <source>Modulus</source>
          <target state="translated">Modulus</target>
        </trans-unit>
        <trans-unit id="c3bdbab40a4be4ac1b8eb1ccb2dbb2eaf8ed480f" translate="yes" xml:space="preserve">
          <source>Mongolian</source>
          <target state="translated">Mongolian</target>
        </trans-unit>
        <trans-unit id="1c76a58fbf51dcfb4f86986f8351b250a767af1c" translate="yes" xml:space="preserve">
          <source>MonoTimeImpl &lt;strong id=&quot;max&quot;&gt;max&lt;/strong&gt;();</source>
          <target state="translated">MonoTimeImpl &lt;strong id=&quot;max&quot;&gt;최대&lt;/strong&gt; ();</target>
        </trans-unit>
        <trans-unit id="75204b25a4143c50617e7f536fd89fa5538edf26" translate="yes" xml:space="preserve">
          <source>MonoTimeImpl &lt;strong id=&quot;min&quot;&gt;min&lt;/strong&gt;();</source>
          <target state="translated">MonoTimeImpl &lt;strong id=&quot;min&quot;&gt;분&lt;/strong&gt; ();</target>
        </trans-unit>
        <trans-unit id="fee0ee10984bd3ac7bbdf08b79f3b112f28e5f09" translate="yes" xml:space="preserve">
          <source>MonoTimeImpl &lt;strong id=&quot;zero&quot;&gt;zero&lt;/strong&gt;();</source>
          <target state="translated">MonoTimeImpl &lt;strong id=&quot;zero&quot;&gt;0&lt;/strong&gt; ();</target>
        </trans-unit>
        <trans-unit id="eede0f12587dd7beec0a1e43ee87fff438df01b9" translate="yes" xml:space="preserve">
          <source>Month &lt;code&gt;month&lt;/code&gt;</source>
          <target state="translated">월 &lt;code&gt;month&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="770498cc7209865e7142aee60b35cd4ef1a665ec" translate="yes" xml:space="preserve">
          <source>Month of a Gregorian Year.</source>
          <target state="translated">그레고리력의 달.</target>
        </trans-unit>
        <trans-unit id="a982879f5e351a31dc81a576cd9f499ed195b9ca" translate="yes" xml:space="preserve">
          <source>Month of the year (January is 1).</source>
          <target state="translated">올해의 달 (1 월은 1)</target>
        </trans-unit>
        <trans-unit id="267248d9e2a350a08fb014509dd997369fd505b0" translate="yes" xml:space="preserve">
          <source>More precisely, an expression of the form &lt;code&gt;arr[&lt;/code&gt;</source>
          <target state="translated">보다 정확하게는 &lt;code&gt;arr[&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="51359e07cc3dafc35c2e930e5c6893f3b29a6a3e" translate="yes" xml:space="preserve">
          <source>More than one qualifier may apply to a type. The order of application is irrelevant, for example given an unqualified type &lt;code&gt;T&lt;/code&gt;, &lt;code&gt;const shared T&lt;/code&gt; and &lt;code&gt;shared const T&lt;/code&gt; are the same type. For that reason, this document depicts qualifier combinations without parentheses unless necessary and in alphabetic order.</source>
          <target state="translated">유형에 둘 이상의 규정자가 적용될 수 있습니다. 적용 순서는, 예를 들면 비정규 형 주어진 무관 &lt;code&gt;T&lt;/code&gt; , &lt;code&gt;const shared T&lt;/code&gt; 및 &lt;code&gt;shared const T&lt;/code&gt; 동일한 유형이있다. 따라서이 문서는 필요하지 않고 알파벳 순서로 괄호없이 한정자 조합을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="6b91b6e5e4417fbf29a4b247eba962d491f1a192" translate="yes" xml:space="preserve">
          <source>Most Objective-C code is bundled in something called a &quot;Framework&quot;. This is basically a regular directory, with the &lt;code&gt;.framework&lt;/code&gt; extension and a specific directory layout. A framework contains a dynamic library, all public header files and any resources (images, sounds and so on) required by the framework.</source>
          <target state="translated">대부분의 Objective-C 코드는 &quot;프레임 워크&quot;로 묶여 있습니다. 이것은 기본적으로 일반 디렉토리이며 &lt;code&gt;.framework&lt;/code&gt; 확장자와 특정 디렉토리 레이아웃입니다. 프레임 워크에는 동적 라이브러리, 모든 공용 헤더 파일 및 프레임 워크에 필요한 모든 리소스 (이미지, 사운드 등)가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="bfb12bc22804b44b167d93aec3f3c70407b2e35d" translate="yes" xml:space="preserve">
          <source>Most functions do not perform any memory allocations, and if a string is returned, it is usually a slice of an input string. If a function allocates, this is explicitly mentioned in the documentation.</source>
          <target state="translated">대부분의 함수는 메모리 할당을 수행하지 않으며 문자열이 반환되면 일반적으로 입력 문자열의 한 조각입니다. 함수가 할당되면 설명서에 명시 적으로 언급되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="774795e055d4e2dccab7943b620741f1d26bed50" translate="yes" xml:space="preserve">
          <source>Most negative &lt;code&gt;Duration&lt;/code&gt; possible.</source>
          <target state="translated">가능한 가장 부정적인 &lt;code&gt;Duration&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="581c4c1b8a2332d611ce4416497bc282ce6dfdaa" translate="yes" xml:space="preserve">
          <source>Most negative &lt;code&gt;MonoTime&lt;/code&gt; possible.</source>
          <target state="translated">가장 부정적인 &lt;code&gt;MonoTime&lt;/code&gt; 가능.</target>
        </trans-unit>
        <trans-unit id="ddbd3dbc157ec8539b793dbad7b600adfc5f9e59" translate="yes" xml:space="preserve">
          <source>Most negative &lt;code&gt;TickDuration&lt;/code&gt; possible.</source>
          <target state="translated">가장 부정적인 &lt;code&gt;TickDuration&lt;/code&gt; 이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="1009e1ed86d39d0ca096eb1687471230fd67e3f4" translate="yes" xml:space="preserve">
          <source>Most numbers are ordered naturally.</source>
          <target state="translated">대부분의 숫자는 자연스럽게 주문됩니다.</target>
        </trans-unit>
        <trans-unit id="4def053b3d04f0dae2fabbf052a1fa8bb609014a" translate="yes" xml:space="preserve">
          <source>Most of the functionality in this module is not available on iOS, tvOS and watchOS. The only functions available on those platforms are: &lt;a href=&quot;#environment&quot;&gt;&lt;code&gt;environment&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#thisProcessID&quot;&gt;&lt;code&gt;thisProcessID&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#thisThreadID&quot;&gt;&lt;code&gt;thisThreadID&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 모듈의 대부분의 기능은 iOS, tvOS 및 watchOS에서 사용할 수 없습니다. 이러한 플랫폼에서 사용할 수있는 유일한 함수는 &lt;a href=&quot;#environment&quot;&gt; &lt;code&gt;environment&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#thisProcessID&quot;&gt; &lt;code&gt;thisProcessID&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#thisThreadID&quot;&gt; &lt;code&gt;thisThreadID&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4812af24b14425f80ec6fa5d4117b8b760e8ef9a" translate="yes" xml:space="preserve">
          <source>Most of the logic to implement scoped pointers and scoped references is here.</source>
          <target state="translated">범위가 지정된 포인터 및 범위가 지정된 참조를 구현하는 대부분의 논리가 여기에 있습니다.</target>
        </trans-unit>
        <trans-unit id="c833ba71d68fc55966f6e1456e6db2fd0300c96d" translate="yes" xml:space="preserve">
          <source>Most programs should not use the coarse clock, exactly because it's less precise, and most programs don't need to get the time often enough to care, but for those rare programs that need to get the time extremely frequently (e.g. hundreds of thousands of times a second) but don't care about high precision, the coarse clock might be appropriate.</source>
          <target state="translated">대부분의 프로그램은 정확하지 않기 때문에 대략적인 시계를 사용해서는 안되며, 대부분의 프로그램은 시간을 자주 돌봐야 할 필요는 없지만 시간을 매우 자주 가져야하는 드문 프로그램 (예 : 수십만 초 정도) 그러나 높은 정밀도에 신경 쓰지 않으면 거친 시계가 적합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa1b6e1a33d26c83c47eddc206c5ac1e624e5155" translate="yes" xml:space="preserve">
          <source>Most programs should not use this directly, but it's exposed for those few programs that need it.</source>
          <target state="translated">대부분의 프로그램은 이것을 직접 사용해서는 안되지만, 필요한 몇 가지 프로그램에 노출되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e894652e8d984064189391f996d60397e2a48ec" translate="yes" xml:space="preserve">
          <source>Move a BLOB Handle to a New Row</source>
          <target state="translated">BLOB 핸들을 새 행으로 이동</target>
        </trans-unit>
        <trans-unit id="add02f8fc89679f014286c95aa282291626003eb" translate="yes" xml:space="preserve">
          <source>Moves &lt;code&gt;source&lt;/code&gt; into &lt;code&gt;target&lt;/code&gt;, via a destructive copy when necessary.</source>
          <target state="translated">필요한 경우 파괴적 사본을 통해 &lt;code&gt;source&lt;/code&gt; 를 &lt;code&gt;target&lt;/code&gt; 으로 이동 합니다.</target>
        </trans-unit>
        <trans-unit id="16a236d46c92b4a5ca559f8a89c2b3c577b168e0" translate="yes" xml:space="preserve">
          <source>Moves all elements from one range to another.</source>
          <target state="translated">모든 요소를 ​​한 범위에서 다른 범위로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="8479b9f61cb11354afd2e1600228140ad6b9d6dc" translate="yes" xml:space="preserve">
          <source>Moves as many elements as possible from one range to another.</source>
          <target state="translated">한 범위에서 다른 범위로 가능한 많은 요소를 이동합니다.</target>
        </trans-unit>
        <trans-unit id="960405f6c4b3aa5de72b116119525712115be474" translate="yes" xml:space="preserve">
          <source>Moves element at index &lt;code&gt;i&lt;/code&gt; of &lt;code&gt;r&lt;/code&gt; out and returns it. Leaves &lt;code&gt; r[i]&lt;/code&gt; in a destroyable state that does not allocate any resources (usually equal to its &lt;code&gt;.init&lt;/code&gt; value).</source>
          <target state="translated">인덱스에서 이동 요소 &lt;code&gt;i&lt;/code&gt; 의 &lt;code&gt;r&lt;/code&gt; 밖으로 돌아갑니다 그것. 잎은 &lt;code&gt; r[i]&lt;/code&gt; 어떤 자원을 할당하지 않는 파괴 할 상태 (일반적으로는 동일 &lt;code&gt;.init&lt;/code&gt; 의 값).</target>
        </trans-unit>
        <trans-unit id="78ea6259d5295d73b4c9b122251d954bd3288ccc" translate="yes" xml:space="preserve">
          <source>Moves out the back.</source>
          <target state="translated">뒤로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="e8dbe19673ddfdfe7531306a22cbece7e08fa915" translate="yes" xml:space="preserve">
          <source>Moves out the front.</source>
          <target state="translated">앞쪽으로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="21464138e9b7b84f1e21b5677eb4772e282fc223" translate="yes" xml:space="preserve">
          <source>Moves the back of &lt;code&gt;r&lt;/code&gt; out and returns it. Leaves &lt;code&gt;r.back&lt;/code&gt; in a destroyable state that does not allocate any resources (usually equal to its &lt;code&gt;.init&lt;/code&gt; value).</source>
          <target state="translated">&lt;code&gt;r&lt;/code&gt; 의 뒤로 이동하여 리턴합니다. 잎은 &lt;code&gt;r.back&lt;/code&gt; (보통 그와 같은 모든 자원을 할당하지 않는 파괴 할 상태에 &lt;code&gt;.init&lt;/code&gt; 의 값).</target>
        </trans-unit>
        <trans-unit id="89199b203d67cc4472b5a42c11f218296b0fa959" translate="yes" xml:space="preserve">
          <source>Moves the front of &lt;code&gt;r&lt;/code&gt; out and returns it. Leaves &lt;code&gt;r.front&lt;/code&gt; in a destroyable state that does not allocate any resources (usually equal to its &lt;code&gt;.init&lt;/code&gt; value).</source>
          <target state="translated">&lt;code&gt;r&lt;/code&gt; 의 앞을 이동하여 리턴합니다. 잎은 &lt;code&gt;r.front&lt;/code&gt; (보통 그와 같은 모든 자원을 할당하지 않는 파괴 할 상태에 &lt;code&gt;.init&lt;/code&gt; 의 값).</target>
        </trans-unit>
        <trans-unit id="22eb7096554b6e74868e7d16970a1dc126973c23" translate="yes" xml:space="preserve">
          <source>Much of the D documentation itself is generated this way, including this page. Such documentation is marked at the bottom as being generated by Ddoc.</source>
          <target state="translated">이 페이지를 포함하여 많은 D 문서 자체가 이런 식으로 생성됩니다. 이러한 문서는 하단에 Ddoc에 의해 생성 된 것으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="d60ee27cc756708ec2d1a2d75f87ef3c6b16e014" translate="yes" xml:space="preserve">
          <source>Mul Expressions</source>
          <target state="translated">뮬 식</target>
        </trans-unit>
        <trans-unit id="7e13b5b1d94de82bc38c31c61776089164a0d74c" translate="yes" xml:space="preserve">
          <source>Mul expressions for floating point operands are not associative.</source>
          <target state="translated">부동 소수점 피연산자에 대한 뮬 표현식은 연관성이 없습니다.</target>
        </trans-unit>
        <trans-unit id="bf7dc9a1dd03ca0b5671d66051467ce10dce0721" translate="yes" xml:space="preserve">
          <source>Multi-disk zips not supported.</source>
          <target state="translated">다중 디스크 zip은 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="098b25f016e7cee3aeb46b0951ffba8ca7a4aba9" translate="yes" xml:space="preserve">
          <source>Multi-line mode, match ^, $ on start and end line separators as well as start and end of input.</source>
          <target state="translated">멀티 라인 모드, 시작 및 끝 라인 구분 기호에서 ^, $, 입력 시작 및 끝과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="7df91ee85cfe006da084d6eec2205103d82b62a7" translate="yes" xml:space="preserve">
          <source>MultiLogger logs to multiple &lt;code&gt;Logger&lt;/code&gt;. The &lt;code&gt;Logger&lt;/code&gt;s are stored in an &lt;code&gt;Logger[]&lt;/code&gt; in their order of insertion.</source>
          <target state="translated">MultiLogger는 여러 &lt;code&gt;Logger&lt;/code&gt; 에 로그합니다 . &lt;code&gt;Logger&lt;/code&gt; (S)가 저장되는 &lt;code&gt;Logger[]&lt;/code&gt; 의 삽입 순서이다.</target>
        </trans-unit>
        <trans-unit id="740922ac20ba9136af0a0a62b3c2c734d9f20fc6" translate="yes" xml:space="preserve">
          <source>Multiple</source>
          <target state="translated">Multiple</target>
        </trans-unit>
        <trans-unit id="29e590b1115ee1a9a48191676c1dd3a4d12cb97a" translate="yes" xml:space="preserve">
          <source>Multiple functions can be passed to &lt;code&gt;map&lt;/code&gt;. In that case, the element type of &lt;code&gt;map&lt;/code&gt; is a tuple containing one element for each function.</source>
          <target state="translated">여러 함수를 &lt;code&gt;map&lt;/code&gt; 에 전달할 수 있습니다 . 이 경우 &lt;code&gt;map&lt;/code&gt; 의 요소 유형은 각 함수마다 하나의 요소를 포함하는 튜플입니다.</target>
        </trans-unit>
        <trans-unit id="abca3b636846e1599131fb30115e7624fb04c581" translate="yes" xml:space="preserve">
          <source>Multiple identifiers in the</source>
          <target state="translated">의 여러 식별자</target>
        </trans-unit>
        <trans-unit id="02d184893da2dc41280aed339b733b86a1d5d7d9" translate="yes" xml:space="preserve">
          <source>Multiple indices can be passed into &lt;code&gt;remove&lt;/code&gt;. In that case, elements at the respective indices are all removed. The indices must be passed in increasing order, otherwise an exception occurs.</source>
          <target state="translated">여러 개의 인덱스를 &lt;code&gt;remove&lt;/code&gt; 에 전달할 수 있습니다 . 이 경우 각 인덱스의 요소가 모두 제거됩니다. 인덱스는 오름차순으로 전달되어야하며, 그렇지 않으면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="ad9e29f23e6c577c3330b7f72495b39a5263c9d7" translate="yes" xml:space="preserve">
          <source>Multiple instantiations of a</source>
          <target state="translated">여러 인스턴스화</target>
        </trans-unit>
        <trans-unit id="440d1a8a232140baee2e245b3e53c432fe0e99fc" translate="yes" xml:space="preserve">
          <source>Multiple substitutes</source>
          <target state="translated">여러 대용품</target>
        </trans-unit>
        <trans-unit id="d488fe5f5a2700bbcfa9a073ec3ff1f6ecfd5b57" translate="yes" xml:space="preserve">
          <source>Multiplies an integral value and a &lt;code&gt;Duration&lt;/code&gt;.</source>
          <target state="translated">정수 값과 &lt;code&gt;Duration&lt;/code&gt; 을 곱합니다 .</target>
        </trans-unit>
        <trans-unit id="56a0e7e79948bc24fcfd6b23d109776c18e4bdf1" translate="yes" xml:space="preserve">
          <source>Multiplies or divides the duration by an integer value.</source>
          <target state="translated">기간을 정수 값으로 곱하거나 나눕니다.</target>
        </trans-unit>
        <trans-unit id="0954814fc4bb5f73545aacc2e2398a5d8549c662" translate="yes" xml:space="preserve">
          <source>Multiplies/Divides the duration by an integer value as well as assigning the result to this &lt;code&gt;Duration&lt;/code&gt;.</source>
          <target state="translated">지속 시간을 정수 값으로 나누고 결과를이 &lt;code&gt;Duration&lt;/code&gt; 에 할당합니다 .</target>
        </trans-unit>
        <trans-unit id="b7cc0cb1ca5c98043347b03c80d00881ef4f41c9" translate="yes" xml:space="preserve">
          <source>Multiply two complex floating point numbers, x and y.</source>
          <target state="translated">두 개의 복잡한 부동 소수점 숫자 x와 y를 곱하십시오.</target>
        </trans-unit>
        <trans-unit id="7c62087494680c6ab390a67b385387fc2371ff36" translate="yes" xml:space="preserve">
          <source>Multiply two signed integers, checking for overflow.</source>
          <target state="translated">오버플로를 확인하여 부호있는 정수 두 개를 곱하십시오.</target>
        </trans-unit>
        <trans-unit id="5ace69a7d289fcbc18bab280e6a93de8a21ddc54" translate="yes" xml:space="preserve">
          <source>Multiply two unsigned integers, checking for overflow (aka carry).</source>
          <target state="translated">오버 플로우 (일명 캐리)를 확인하면서 부호없는 정수 두 개를 곱하십시오.</target>
        </trans-unit>
        <trans-unit id="5880acb922eaf637f5fe6ee51c64bbc5576e150e" translate="yes" xml:space="preserve">
          <source>MultiwayMerge!(less, RangeOfRanges) &lt;strong id=&quot;multiwayMerge&quot;&gt;multiwayMerge&lt;/strong&gt;(alias less = &quot;a &amp;lt; b&quot;, RangeOfRanges)(RangeOfRanges ror);</source>
          <target state="translated">MultiwayMerge! (덜, RangeOfRanges) &lt;strong id=&quot;multiwayMerge&quot;&gt;multiwayMerge&lt;/strong&gt; (별칭 = &quot;a &amp;lt;b&quot;, RangeOfRanges) (RangeOfRanges ror);</target>
        </trans-unit>
        <trans-unit id="efa03890066c23a8b19ca12948a9e10fceae838f" translate="yes" xml:space="preserve">
          <source>MurmurHash3 comes in three flavors, listed in increasing order of throughput:</source>
          <target state="translated">MurmurHash3는 처리량의 증가 순서에 따라 세 가지 맛으로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="4f19edd3144a2656247fe56232af4c5408c8b7ee" translate="yes" xml:space="preserve">
          <source>Musical Symbols</source>
          <target state="translated">뮤지컬 기호</target>
        </trans-unit>
        <trans-unit id="13bcc5c25bae00735d267b69807a37eb90d90472" translate="yes" xml:space="preserve">
          <source>Mutation</source>
          <target state="translated">Mutation</target>
        </trans-unit>
        <trans-unit id="c0b02d18cf57f54fa894db9640ab1fdf261c7702" translate="yes" xml:space="preserve">
          <source>Mutex &lt;code&gt;m&lt;/code&gt;</source>
          <target state="translated">뮤텍스 &lt;code&gt;m&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cc7eaf9d7996275cabd58454896268bb0c4057bf" translate="yes" xml:space="preserve">
          <source>Mutex &lt;code&gt;mutex&lt;/code&gt;</source>
          <target state="translated">뮤텍스 &lt;code&gt;mutex&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ee9066f4d731d8a141c6e684743ee9a9527de8b6" translate="yes" xml:space="preserve">
          <source>Mutex Handle</source>
          <target state="translated">뮤텍스 핸들</target>
        </trans-unit>
        <trans-unit id="9f117864c1709baa2c76d7b2cfa8d17c9f1bfe11" translate="yes" xml:space="preserve">
          <source>Mutex Methods Object</source>
          <target state="translated">뮤텍스 메소드 객체</target>
        </trans-unit>
        <trans-unit id="9ca067080a430d66f997055e5f2d644e22736a96" translate="yes" xml:space="preserve">
          <source>Mutex Verification Routines</source>
          <target state="translated">뮤텍스 검증 루틴</target>
        </trans-unit>
        <trans-unit id="7703eaffd0654744dd25ed0b2c8483a972228de2" translate="yes" xml:space="preserve">
          <source>Mutex for mutually exclusive access.</source>
          <target state="translated">상호 배타적 액세스를위한 뮤텍스.</target>
        </trans-unit>
        <trans-unit id="82f2c9599c5c14be2ce92b9de958cb57db81b38f" translate="yes" xml:space="preserve">
          <source>Mutexes</source>
          <target state="translated">Mutexes</target>
        </trans-unit>
        <trans-unit id="928b7c48a60ad93b81bc3bee9d274c5f2aed9ad3" translate="yes" xml:space="preserve">
          <source>Myanmar</source>
          <target state="translated">Myanmar</target>
        </trans-unit>
        <trans-unit id="355376d91cd047a2d8fdca64b43c804618ed3101" translate="yes" xml:space="preserve">
          <source>Myanmar Extended-A</source>
          <target state="translated">미얀마 확장 -A</target>
        </trans-unit>
        <trans-unit id="b51a60734da64be0e618bacbea2865a8a7dcd669" translate="yes" xml:space="preserve">
          <source>N</source>
          <target state="translated">N</target>
        </trans-unit>
        <trans-unit id="de9d4243b85d288bbb9d4e29d9b8114613e21d53" translate="yes" xml:space="preserve">
          <source>N-ary predicate that reverses the order of arguments, e.g., given &lt;code&gt;pred(a, b, c)&lt;/code&gt;, returns &lt;code&gt;pred(c, b, a)&lt;/code&gt;.</source>
          <target state="translated">예를 들어 주어진 &lt;code&gt;pred(a, b, c)&lt;/code&gt; 와 같이 인수의 순서를 반대로하는 N-ary 술어 는 &lt;code&gt;pred(c, b, a)&lt;/code&gt; 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="a9d371451b6909ac85117130b9153a96499a362c" translate="yes" xml:space="preserve">
          <source>NAME</source>
          <target state="translated">NAME</target>
        </trans-unit>
        <trans-unit id="d82a19a46f2f7da0f84cb56740a41e0148eda5c1" translate="yes" xml:space="preserve">
          <source>NAN</source>
          <target state="translated">NAN</target>
        </trans-unit>
        <trans-unit id="e2f31d8d8e29c1c65e1a03cf1b1495f55b89828e" translate="yes" xml:space="preserve">
          <source>NANs of the same sign are ordered by the payload ('negative' ones - in reverse order).</source>
          <target state="translated">동일한 부호의 NAN은 페이로드에 의해 주문됩니다 ( '음수'-반대 순서).</target>
        </trans-unit>
        <trans-unit id="5d468ae642bb247a8e01e4ff6b3d5521a502f435" translate="yes" xml:space="preserve">
          <source>NANs of the same sign are ordered by the payload.</source>
          <target state="translated">페이로드에서 동일한 부호의 NAN을 주문합니다.</target>
        </trans-unit>
        <trans-unit id="3d4b99ee66548ff50c18139181185129923f01ff" translate="yes" xml:space="preserve">
          <source>NCS backward compatibility</source>
          <target state="translated">NCS 이전 버전과의 호환성</target>
        </trans-unit>
        <trans-unit id="f32955bf4c7fd11cc57b3ad4ab0172c20d35e0aa" translate="yes" xml:space="preserve">
          <source>NDP[8] &lt;strong id=&quot;_8087elems&quot;&gt;_8087elems&lt;/strong&gt;;</source>
          <target state="translated">NDP [8] &lt;strong id=&quot;_8087elems&quot;&gt;_8087elems&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="dc1bfb052f62695e8afc872dbacb4c070b0c10e5" translate="yes" xml:space="preserve">
          <source>NEWREG</source>
          <target state="translated">NEWREG</target>
        </trans-unit>
        <trans-unit id="8e64e5eebed2a307131d496e00360f4a910e75dc" translate="yes" xml:space="preserve">
          <source>NKo</source>
          <target state="translated">NKo</target>
        </trans-unit>
        <trans-unit id="965befa21e77d9af06a32a773577d2548bb3c644" translate="yes" xml:space="preserve">
          <source>NL line feed, new line</source>
          <target state="translated">NL 줄 바꿈, 줄 바꿈</target>
        </trans-unit>
        <trans-unit id="8ac00a7e70abeeaf254830eb6d9428e78c8d7ef4" translate="yes" xml:space="preserve">
          <source>NN</source>
          <target state="translated">NN</target>
        </trans-unit>
        <trans-unit id="81baa761ece464984c4726ca74944a94c4dca7bc" translate="yes" xml:space="preserve">
          <source>NO LONGER USED</source>
          <target state="translated">더 이상 사용하지 않음</target>
        </trans-unit>
        <trans-unit id="0654a028e5aea48c8fbb09871b8f397a186c883b" translate="yes" xml:space="preserve">
          <source>NONE</source>
          <target state="translated">NONE</target>
        </trans-unit>
        <trans-unit id="556cfa38702a7b11d3a265b69b1a1f579954c6ad" translate="yes" xml:space="preserve">
          <source>NOT USED</source>
          <target state="translated">사용하지 않음</target>
        </trans-unit>
        <trans-unit id="a8ad860c15810cce0e7beac1c91da3ab2cb22c47" translate="yes" xml:space="preserve">
          <source>NOTE</source>
          <target state="translated">NOTE</target>
        </trans-unit>
        <trans-unit id="22f6c302a991a23878dc1d3fd193f165c6d7378d" translate="yes" xml:space="preserve">
          <source>NOTE 2:</source>
          <target state="translated">노트 2:</target>
        </trans-unit>
        <trans-unit id="92dfb30e422cabeb6b909c9930e19e573ebc5371" translate="yes" xml:space="preserve">
          <source>NOTE: &lt;code&gt;delete&lt;/code&gt; has been deprecated. Instead, please use &lt;a href=&quot;https://dlang.org/phobos/object.html#destroy&quot;&gt;&lt;code&gt;destroy&lt;/code&gt;&lt;/a&gt; if feasible, or &lt;a href=&quot;https://dlang.org/phobos/core_memory.html#__delete&quot;&gt;&lt;code&gt;core.memory.__delete&lt;/code&gt;&lt;/a&gt; as a last resort.</source>
          <target state="translated">참고 : &lt;code&gt;delete&lt;/code&gt; 가 더 이상 사용되지 않습니다. 대신, 가능한 경우 &lt;a href=&quot;https://dlang.org/phobos/object.html#destroy&quot;&gt; &lt;code&gt;destroy&lt;/code&gt; &lt;/a&gt; 를 사용 하거나 , 최후의 수단으로 &lt;a href=&quot;https://dlang.org/phobos/core_memory.html#__delete&quot;&gt; &lt;code&gt;core.memory.__delete&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="41627eab8a13abe6cd0a95719c7b5b2435940124" translate="yes" xml:space="preserve">
          <source>NOTE: Not yet implemented.</source>
          <target state="translated">참고 : 아직 구현되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="a142d11fd8e1893f7241ef23da3ac42b73c007c2" translate="yes" xml:space="preserve">
          <source>NP form feed, new page</source>
          <target state="translated">NP 양식 피드, 새 페이지</target>
        </trans-unit>
        <trans-unit id="026eac853e081a2793439a30ef3a00433e26f261" translate="yes" xml:space="preserve">
          <source>NTLM</source>
          <target state="translated">NTLM</target>
        </trans-unit>
        <trans-unit id="b9b6768f79f1577e799b1efce766e4e8e86e2dd4" translate="yes" xml:space="preserve">
          <source>NTLM auth is supported</source>
          <target state="translated">NTLM 인증이 지원됩니다</target>
        </trans-unit>
        <trans-unit id="c9515fcc91e92808d85b39d93f92900ad927ccb8" translate="yes" xml:space="preserve">
          <source>NULL Function Name</source>
          <target state="translated">NULL 함수 이름</target>
        </trans-unit>
        <trans-unit id="fe1cc67b4afd83bc08c13bcd7b64a2b5b268c52b" translate="yes" xml:space="preserve">
          <source>NULL NULL</source>
          <target state="translated">NULL NULL</target>
        </trans-unit>
        <trans-unit id="c87d41aff24ba6f4ec554d24dce699e7d1692a05" translate="yes" xml:space="preserve">
          <source>NULL file not found !=NULL mem.xmalloc'd file name</source>
          <target state="translated">NULL 파일을 찾을 수 없습니다! = NULL mem.xmalloc'd 파일 이름</target>
        </trans-unit>
        <trans-unit id="9eaa2cbecdcbd2183d8b68e5b96e784ce915bf78" translate="yes" xml:space="preserve">
          <source>NaN value</source>
          <target state="translated">NaN 값</target>
        </trans-unit>
        <trans-unit id="709a23220f2c3d64d1e1d6d18c4d5280f8d82fca" translate="yes" xml:space="preserve">
          <source>Name</source>
          <target state="translated">Name</target>
        </trans-unit>
        <trans-unit id="b86ccc3e7cba86e65ae5df758ab1c57554830621" translate="yes" xml:space="preserve">
          <source>Name Mangling</source>
          <target state="translated">이름 맹 글링</target>
        </trans-unit>
        <trans-unit id="daa5b774be0bfcbd2e2835e6bd0980fb6e06778a" translate="yes" xml:space="preserve">
          <source>Name Of A Host Parameter</source>
          <target state="translated">호스트 매개 변수 이름</target>
        </trans-unit>
        <trans-unit id="cb9e33f6b09bb7fe5d38a783b74c6905b2f43077" translate="yes" xml:space="preserve">
          <source>Name Of The Folder Holding Database Files</source>
          <target state="translated">데이터베이스 파일을 보유한 폴더의 이름</target>
        </trans-unit>
        <trans-unit id="7749c218b18b42cbe27f3f870da40b8d3d708ba1" translate="yes" xml:space="preserve">
          <source>Name Of The Folder Holding Temporary Files</source>
          <target state="translated">임시 파일을 보유한 폴더의 이름</target>
        </trans-unit>
        <trans-unit id="e59df65314daa841d45f5a3e14ba76e2f9e9c8c1" translate="yes" xml:space="preserve">
          <source>Name of file for which the error occurred.</source>
          <target state="translated">오류가 발생한 파일의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="d559607a1a6446ab7620756e13a0b5f234bf2473" translate="yes" xml:space="preserve">
          <source>Name of production rule which failed to parse, or specific error message</source>
          <target state="translated">구문 분석하지 못한 프로덕션 규칙 이름 또는 특정 오류 메시지</target>
        </trans-unit>
        <trans-unit id="e31cbabb3f72b2a73875e1063140161450989ac1" translate="yes" xml:space="preserve">
          <source>Name of proxy to use.</source>
          <target state="translated">사용할 프록시 이름.</target>
        </trans-unit>
        <trans-unit id="4743065d5c24dea8c1049fa1ad276414cb966a5e" translate="yes" xml:space="preserve">
          <source>Name of symbol to test that resides in &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 에있는 테스트 할 기호의 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="926beea7a204b67e08849a9f0f8baf4eade0c1be" translate="yes" xml:space="preserve">
          <source>Name of this class.</source>
          <target state="translated">이 클래스의 이름</target>
        </trans-unit>
        <trans-unit id="5bd20c9269fc21e28a5ca023c75d67f561fd2907" translate="yes" xml:space="preserve">
          <source>Name string is a URL</source>
          <target state="translated">이름 문자열은 URL입니다</target>
        </trans-unit>
        <trans-unit id="3e9d951df5185dacb50ff8e872d8f60652b3003f" translate="yes" xml:space="preserve">
          <source>Name string is a fully-qualified domain name</source>
          <target state="translated">이름 문자열은 정규화 된 도메인 이름입니다.</target>
        </trans-unit>
        <trans-unit id="0ec414128b6f1f85f67f2bea1a748a95de4410a8" translate="yes" xml:space="preserve">
          <source>Name string is an ISO OID</source>
          <target state="translated">이름 문자열은 ISO OID입니다</target>
        </trans-unit>
        <trans-unit id="f9b19d50c25b3743eb4adeadeaa3e5a0ab484c83" translate="yes" xml:space="preserve">
          <source>Name string is an X.500 DN (in DER or a text output format)</source>
          <target state="translated">이름 문자열은 X.500 DN입니다 (DER 또는 텍스트 출력 형식).</target>
        </trans-unit>
        <trans-unit id="5d41d633c54bc35ed0b102d16a59c09042d7e6f8" translate="yes" xml:space="preserve">
          <source>Name to append to path</source>
          <target state="translated">경로에 추가 할 이름</target>
        </trans-unit>
        <trans-unit id="57e44b2dd9241e59e5da1fe5cf27cc5a6f2a79e1" translate="yes" xml:space="preserve">
          <source>Named Character Entities</source>
          <target state="translated">명명 된 캐릭터 엔티티</target>
        </trans-unit>
        <trans-unit id="61a5eb217e7e482d8acfda053982ce228847a019" translate="yes" xml:space="preserve">
          <source>Named Enum Properties</source>
          <target state="translated">명명 된 열거 형 속성</target>
        </trans-unit>
        <trans-unit id="0f9a079f7fd37c78ad2d46952b2843d67f7e8c61" translate="yes" xml:space="preserve">
          <source>Named Enums</source>
          <target state="translated">명명 된 열거 형</target>
        </trans-unit>
        <trans-unit id="3880787f5865cac8472d36131fe148caae5fca26" translate="yes" xml:space="preserve">
          <source>Named character entity from the HTML5 specification. See &lt;a href=&quot;entity#NamedCharacterEntity&quot;&gt;&lt;i&gt;NamedCharacterEntity&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">HTML5 사양의 명명 된 문자 엔터티 &lt;a href=&quot;entity#NamedCharacterEntity&quot;&gt;&lt;i&gt;NamedCharacterEntity를&lt;/i&gt;&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="198f570fd56ceba05fedca92bb0332df23db79b7" translate="yes" xml:space="preserve">
          <source>Named character entity from the HTML5 specification. These names begin with &lt;code&gt;&amp;amp;&lt;/code&gt; and end with &lt;code&gt;;&lt;/code&gt;</source>
          <target state="translated">HTML5 사양에서 명명 된 문자 엔티티입니다. 이 이름은 &lt;code&gt;&amp;amp;&lt;/code&gt; 로 시작 하고 &lt;code&gt;;&lt;/code&gt; 로 끝납니다 .</target>
        </trans-unit>
        <trans-unit id="67bbc13122b700cc80fcad9791161657d846a9cd" translate="yes" xml:space="preserve">
          <source>Named enum members may not have individual</source>
          <target state="translated">명명 된 열거 형 멤버에는 개인이 없을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="680bdf9cb66385985bc0370016c9c0b2510bfa40" translate="yes" xml:space="preserve">
          <source>Named enums are used to declare related constants and group them by giving them a unique type. The &lt;a href=&quot;#EnumMembers&quot;&gt;&lt;i&gt;EnumMembers&lt;/i&gt;&lt;/a&gt; are declared in the scope of the named enum. The named enum declares a new type, and all the</source>
          <target state="translated">명명 된 열거 형은 관련 상수를 선언하고 고유 한 유형을 부여하여 그룹화하는 데 사용됩니다. &lt;a href=&quot;#EnumMembers&quot;&gt;&lt;i&gt;EnumMembers은&lt;/i&gt;&lt;/a&gt; 명명 된 열거 형의 범위에 선언되어있다. 명명 된 열거 형은 새로운 유형을 선언하며</target>
        </trans-unit>
        <trans-unit id="80e6a3723926ccc64d8cb3caf791cfc7436d9eeb" translate="yes" xml:space="preserve">
          <source>Named sections follow the</source>
          <target state="translated">명명 된 섹션은</target>
        </trans-unit>
        <trans-unit id="7572bcf7df65774ff78b8059cf1d76bfd458d709" translate="yes" xml:space="preserve">
          <source>Named subexpressions, with Python syntax.</source>
          <target state="translated">파이썬 구문을 사용한 명명 된 하위 표현식.</target>
        </trans-unit>
        <trans-unit id="2b7c08c3ab75f37e2da656c1aab228f5f3a793b1" translate="yes" xml:space="preserve">
          <source>Names</source>
          <target state="translated">Names</target>
        </trans-unit>
        <trans-unit id="18279a42718c13f69852b27bda71bca286baf482" translate="yes" xml:space="preserve">
          <source>Namespace identifier resolved during semantic.</source>
          <target state="translated">시맨틱 중에 네임 스페이스 식별자가 해결되었습니다.</target>
        </trans-unit>
        <trans-unit id="16eb70d8d96eda3f848bd01fad9c8740968e54df" translate="yes" xml:space="preserve">
          <source>Namespaces create a new named scope that is imported into its enclosing scope.</source>
          <target state="translated">네임 스페이스는 엔 클로징 범위로 가져 오는 새로운 명명 된 범위를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="f1ac1397736e022a1d1f2150f9efcc470a2f2b26" translate="yes" xml:space="preserve">
          <source>Narrow strings are handled as a special case in an overload.</source>
          <target state="translated">좁은 문자열은 과부하에서 특별한 경우로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="8e62ebb952ce8cd996872d7384f0690928fe12f3" translate="yes" xml:space="preserve">
          <source>Narrow strings are handled as follows:</source>
          <target state="translated">좁은 문자열은 다음과 같이 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="d1baa0f5a64eb81bc7adf3575d07ce443439b75e" translate="yes" xml:space="preserve">
          <source>Narrows down the search for sets of &lt;a href=&quot;#Code%20point&quot;&gt;code points&lt;/a&gt; to all Unicode blocks.</source>
          <target state="translated">&lt;a href=&quot;#Code%20point&quot;&gt;코드 포인트&lt;/a&gt; 검색 을 모든 유니 코드 블록으로 좁 힙니다 .</target>
        </trans-unit>
        <trans-unit id="972986128033c9c5a0fa48b5cba6b81b431ea5b8" translate="yes" xml:space="preserve">
          <source>Narrows down the search for sets of &lt;a href=&quot;#Code%20point&quot;&gt;code points&lt;/a&gt; to all Unicode scripts.</source>
          <target state="translated">&lt;a href=&quot;#Code%20point&quot;&gt;코드&lt;/a&gt; 세트 검색 범위를 좁혀 모든 유니 코드 스크립트를 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="a0d5df10c5743ed78b049b016736baea220da828" translate="yes" xml:space="preserve">
          <source>Natural logarithm of the gamma function, &amp;Gamma;(x)</source>
          <target state="translated">감마 함수의 자연 로그, &amp;Gamma; (x)</target>
        </trans-unit>
        <trans-unit id="9af04929dbb837f665a10a968e5ddf32830b2b68" translate="yes" xml:space="preserve">
          <source>Nd</source>
          <target state="translated">Nd</target>
        </trans-unit>
        <trans-unit id="5ff045772783a219420ce41451947dd63b0d24fc" translate="yes" xml:space="preserve">
          <source>Nearly the full language remains available. Highlights include:</source>
          <target state="translated">거의 모든 언어를 사용할 수 있습니다. 주요 내용은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d19f92de109ac46a4d1496b1a25770fce9bf58d9" translate="yes" xml:space="preserve">
          <source>NeedInterpret &lt;code&gt;needInterpret&lt;/code&gt;</source>
          <target state="translated">NeedInterpret 필요 &lt;code&gt;needInterpret&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="75fa110366f333fd5bab311830e3dde315a57f85" translate="yes" xml:space="preserve">
          <source>Needles &lt;code&gt;needles&lt;/code&gt;</source>
          <target state="translated">바늘 &lt;code&gt;needles&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6ca161e3cc3002c027a2393428d0e306fbbaf695" translate="yes" xml:space="preserve">
          <source>Needles &lt;code&gt;withOneOfThese&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;withOneOfThese&lt;/code&gt; 바늘</target>
        </trans-unit>
        <trans-unit id="252cb1c005cf9e2d7b10d76452dacceef651591d" translate="yes" xml:space="preserve">
          <source>Needs to be run after all arguments parsing (command line, DFLAGS environment variable and config file) in order to add final flags (such as &lt;code&gt;X86_64&lt;/code&gt; or the &lt;code&gt;CRuntime&lt;/code&gt; used).</source>
          <target state="translated">최종 플래그 (예 : &lt;code&gt;X86_64&lt;/code&gt; 또는 사용 된 &lt;code&gt;CRuntime&lt;/code&gt; ) 를 추가하려면 모든 인수 구문 분석 (명령 행, DFLAGS 환경 변수 및 구성 파일) 후에 실행해야합니다 .</target>
        </trans-unit>
        <trans-unit id="773b47405b1ade5cb7def242c625aee9a0503c8c" translate="yes" xml:space="preserve">
          <source>NegExp, UAddExp, or ComExp which is revised per rules</source>
          <target state="translated">규칙에 따라 수정 된 NegExp, UAddExp 또는 ComExp</target>
        </trans-unit>
        <trans-unit id="86ed584de044b5671abdde74aefb4ce336bc1352" translate="yes" xml:space="preserve">
          <source>NegInfInterval &lt;code&gt;interval&lt;/code&gt;</source>
          <target state="translated">NegInfInterval &lt;code&gt;interval&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5d37436b24a16d602498d52710fab24c4c0728fb" translate="yes" xml:space="preserve">
          <source>NegInfInterval &lt;code&gt;rhs&lt;/code&gt;</source>
          <target state="translated">NegInfInterval &lt;code&gt;rhs&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="06abdfa680cc88d985771cbd0b3ca58828a2c451" translate="yes" xml:space="preserve">
          <source>NegInfInterval!TP &lt;code&gt;interval&lt;/code&gt;</source>
          <target state="translated">NegInfInterval! TP &lt;code&gt;interval&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6035d6e362cc58462f47d6189969232e8adefdb5" translate="yes" xml:space="preserve">
          <source>NegInfIntervalRange &lt;code&gt;rhs&lt;/code&gt;</source>
          <target state="translated">NegInfIntervalRange &lt;code&gt;rhs&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6b509d53b6c53336b97c7a2d0d8fd0931d01cf01" translate="yes" xml:space="preserve">
          <source>Negate an integer.</source>
          <target state="translated">정수를 부정하십시오.</target>
        </trans-unit>
        <trans-unit id="d65959b6815872890e463de3dd8c9f108e73ed07" translate="yes" xml:space="preserve">
          <source>Negates predicate &lt;code&gt;pred&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pred&lt;/code&gt; predicates를 무효화합니다 .</target>
        </trans-unit>
        <trans-unit id="b2be9e5f14286a848786e1067cc531abff2e5a28" translate="yes" xml:space="preserve">
          <source>Negates the passed template predicate.</source>
          <target state="translated">전달 된 템플리트 술어를 무효화합니다.</target>
        </trans-unit>
        <trans-unit id="377568a17aa50c7d08c08a483a0eaa6ac8ab5550" translate="yes" xml:space="preserve">
          <source>Negative acknowledge</source>
          <target state="translated">부정적인 인정</target>
        </trans-unit>
        <trans-unit id="2daad810c80df74440602a7aceea31f882914c35" translate="yes" xml:space="preserve">
          <source>Negotiate auth support</source>
          <target state="translated">인증 지원 협상</target>
        </trans-unit>
        <trans-unit id="a29c776e4dbfe3a513f9eff63083ad09174aeb63" translate="yes" xml:space="preserve">
          <source>Neither of the above postblits is defined for structs that don't define &lt;code&gt;this(this)&lt;/code&gt; and don't have fields that transitively define it. If a struct does not define a postblit (implicit or explicit) but defines functions that use the same name/signature as the internally generated postblits, the compiler is able to identify that the functions are not actual postblits and does not insert calls to them when the struct is copied. Example:</source>
          <target state="translated">위의 포스트 블릿 중 어느 것도 &lt;code&gt;this(this)&lt;/code&gt; 정의하지 않고 이것을 전 이적으로 정의하는 필드가없는 구조체에 대해 정의 되지 않았습니다. 구조체가 포스트 블릿 (암시 적 또는 명시 적)을 정의하지 않지만 내부적으로 생성 된 포스트 블릿과 동일한 이름 / 서명을 사용하는 함수를 정의하는 경우 컴파일러는 함수가 실제 포스트 블릿이 아니며 호출 할 때 함수를 삽입하지 않는 것을 식별 할 수 있습니다 구조체가 복사됩니다. 예:</target>
        </trans-unit>
        <trans-unit id="fbdc670d6c3fa0c3348a1095041949b891ee8b90" translate="yes" xml:space="preserve">
          <source>Neither part of the address may begin with a dot</source>
          <target state="translated">주소의 어느 부분도 점으로 시작할 수 없습니다</target>
        </trans-unit>
        <trans-unit id="adecc7ca86d9dceca1b8a8af2434d1f53d82528b" translate="yes" xml:space="preserve">
          <source>Neither part of the address may end with a dot</source>
          <target state="translated">주소의 어느 부분도 점으로 끝날 수 없습니다</target>
        </trans-unit>
        <trans-unit id="c7aed298b0805dc753e9e811fcc17786fa078e4f" translate="yes" xml:space="preserve">
          <source>Neither the</source>
          <target state="translated">어느 쪽도</target>
        </trans-unit>
        <trans-unit id="d54ff6b0bd3497e2fc52575cdc71b5c7d66565ca" translate="yes" xml:space="preserve">
          <source>Neither the type of the &lt;code&gt;return ref&lt;/code&gt; parameter(s) nor the type of the return value is considered when determining the lifetime of the return value.</source>
          <target state="translated">어느 쪽의 형태 &lt;code&gt;return ref&lt;/code&gt; 반환 값의 수명을 결정할 때, 매개 변수 (들) 나 리턴 값의 타입이 고려되지 않는다.</target>
        </trans-unit>
        <trans-unit id="01b40ef9e87e1aa8159c98216ddccbf41a39cea4" translate="yes" xml:space="preserve">
          <source>Nested Classes</source>
          <target state="translated">중첩 클래스</target>
        </trans-unit>
        <trans-unit id="6ceba4234e15aa5ab2bd2d8b94c4dcba7693959f" translate="yes" xml:space="preserve">
          <source>Nested Functions</source>
          <target state="translated">중첩 함수</target>
        </trans-unit>
        <trans-unit id="bc233cc472db43781bf227ced2be0151fbaa6765" translate="yes" xml:space="preserve">
          <source>Nested Structs</source>
          <target state="translated">중첩 구조</target>
        </trans-unit>
        <trans-unit id="18abd9c388e5b52a8ab76caf29e0af466e0fc751" translate="yes" xml:space="preserve">
          <source>Nested Templates</source>
          <target state="translated">중첩 템플릿</target>
        </trans-unit>
        <trans-unit id="d7b8bd3fd9842e6b5f5443071f6160290a2688fd" translate="yes" xml:space="preserve">
          <source>Nested functions always have the D function linkage type.</source>
          <target state="translated">중첩 함수는 항상 D 함수 연결 유형을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="59b742f5047d7f2f070cdc497bf94356170baca1" translate="yes" xml:space="preserve">
          <source>Nested functions can be accessed only if the name is in scope.</source>
          <target state="translated">이름이 범위 내에있는 경우에만 중첩 함수에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="687841a342e2af7eaa9fb5771e49ff2ecd7c7c55" translate="yes" xml:space="preserve">
          <source>Nested functions cannot be overloaded.</source>
          <target state="translated">중첩 함수는 오버로드 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="de56879ae392c0f410b6a4803a848b74acc25efa" translate="yes" xml:space="preserve">
          <source>Nested functions have access to the variables and other symbols defined by the lexically enclosing function. This access includes both the ability to read and write them.</source>
          <target state="translated">중첩 함수는 어휘로 묶는 함수에 의해 정의 된 변수 및 기타 기호에 액세스 할 수 있습니다. 이 액세스에는 읽고 쓰는 기능이 모두 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="81d040d8cbecb1f3ea6ea11fdae7060537a65415" translate="yes" xml:space="preserve">
          <source>Nested functions, nested structs, delegates and lambdas</source>
          <target state="translated">중첩 함수, 중첩 구조체, 델리게이트 및 람다</target>
        </trans-unit>
        <trans-unit id="e58fbc07285bd7225d930bd7dd9f892a522af9f6" translate="yes" xml:space="preserve">
          <source>Nested structs/classes cannot be created.</source>
          <target state="translated">중첩 된 구조체 / 클래스를 만들 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="84758e8ed7fb7e044ecd7ee4b8be21ee953041d9" translate="yes" xml:space="preserve">
          <source>Nesting Delimiters</source>
          <target state="translated">중첩 구분 기호</target>
        </trans-unit>
        <trans-unit id="2a8e9132760d41d72a6889c4990ba4d0970d98d7" translate="yes" xml:space="preserve">
          <source>Nesting block comments can span multiple lines and can nest.</source>
          <target state="translated">중첩 블록 주석은 여러 줄에 걸쳐있을 수 있으며 중첩 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3e9e1f6f189ff8e4d505c81b54a796d5e66a2542" translate="yes" xml:space="preserve">
          <source>NetBSD</source>
          <target state="translated">NetBSD</target>
        </trans-unit>
        <trans-unit id="f72e37a825c66ec1f9c150b1cff07ef3b471399e" translate="yes" xml:space="preserve">
          <source>Networking client functionality as provided by &lt;a href=&quot;http://curl.haxx.se/libcurl&quot;&gt;libcurl&lt;/a&gt;. The libcurl library must be installed on the system in order to use this module.</source>
          <target state="translated">에 의해 제공되는 네트워킹 클라이언트 기능 &lt;a href=&quot;http://curl.haxx.se/libcurl&quot;&gt;libcurl에&lt;/a&gt; . 이 모듈을 사용하려면 libcurl 라이브러리가 시스템에 설치되어 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="e07c1b233bf2440188ff428deff04d4597d15a98" translate="yes" xml:space="preserve">
          <source>Networking client functionality as provided by &lt;a href=&quot;https://curl.haxx.se/libcurl&quot;&gt;libcurl&lt;/a&gt;. The libcurl library must be installed on the system in order to use this module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="581aefeada059f802da1d583ea93e3161c11eedd" translate="yes" xml:space="preserve">
          <source>Networking client functionality as provided by libcurl.</source>
          <target state="translated">libcurl에서 제공하는 네트워킹 클라이언트 기능</target>
        </trans-unit>
        <trans-unit id="ebe07da3dd45bd0d24ce7337762bb47dbdca8703" translate="yes" xml:space="preserve">
          <source>Never defined; used to just disable a section of code</source>
          <target state="translated">절대 정의되지 않았습니다. 코드 섹션을 비활성화하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="bbdcd23a18b9ea161014043c83bf82b0c775856d" translate="yes" xml:space="preserve">
          <source>Never do checking</source>
          <target state="translated">확인하지 마십시오</target>
        </trans-unit>
        <trans-unit id="0fc947765f94c215d01465bd1d5f3c6b067a780d" translate="yes" xml:space="preserve">
          <source>New Expressions</source>
          <target state="translated">새로운 표현</target>
        </trans-unit>
        <trans-unit id="814ede89739aeda2dd2ef09f7a84f1a31b54f537" translate="yes" xml:space="preserve">
          <source>New Tai Lue</source>
          <target state="translated">뉴타 이루</target>
        </trans-unit>
        <trans-unit id="00ca8599d50ec8f4a491f84862a1372294230642" translate="yes" xml:space="preserve">
          <source>New thread with anonymous function</source>
          <target state="translated">익명의 기능을 가진 새로운 스레드</target>
        </trans-unit>
        <trans-unit id="4730a25585b21bc83b2fb6fd8c21ccef35173c07" translate="yes" xml:space="preserve">
          <source>NewAnonClassExpression</source>
          <target state="translated">NewAnonClassExpression</target>
        </trans-unit>
        <trans-unit id="aeae939b51fa073aeb7c50b858bfbe0a984f939c" translate="yes" xml:space="preserve">
          <source>NewExpression</source>
          <target state="translated">NewExpression</target>
        </trans-unit>
        <trans-unit id="47cc38a5f6affc6fd9f8a8683e76dfafa574aed8" translate="yes" xml:space="preserve">
          <source>New_Tai_Lue</source>
          <target state="translated">New_Tai_Lue</target>
        </trans-unit>
        <trans-unit id="406e5a30366bef1c2bdc60eb13855fbae99b6877" translate="yes" xml:space="preserve">
          <source>Newline sequence for this system.</source>
          <target state="translated">이 시스템의 개행 순서.</target>
        </trans-unit>
        <trans-unit id="73452a97f008435fbe0f0b3d0ee3f1a418dddd2c" translate="yes" xml:space="preserve">
          <source>Newly created temporary variable.</source>
          <target state="translated">새로 작성된 임시 변수.</target>
        </trans-unit>
        <trans-unit id="e302c64310a9ca244fa110a87de65f2e1a592e89" translate="yes" xml:space="preserve">
          <source>Newton iterations or interval halving is used.</source>
          <target state="translated">뉴턴 반복 또는 구간 절반이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ddc9b12c0e2ac408af04a6464da02c9fab4fbf61" translate="yes" xml:space="preserve">
          <source>Next, if the</source>
          <target state="translated">다음으로</target>
        </trans-unit>
        <trans-unit id="55674258a28777513c3ee8a1247d68d39b7e5128" translate="yes" xml:space="preserve">
          <source>Nko</source>
          <target state="translated">Nko</target>
        </trans-unit>
        <trans-unit id="4dd2d83410062286116bfd3474723788ce66b385" translate="yes" xml:space="preserve">
          <source>Nl</source>
          <target state="translated">Nl</target>
        </trans-unit>
        <trans-unit id="816c52fd2bdd94a63cd0944823a6c0aa9384c103" translate="yes" xml:space="preserve">
          <source>No</source>
          <target state="translated">No</target>
        </trans-unit>
        <trans-unit id="d53788aa816acff93069d1b59d3bb9bffba09d17" translate="yes" xml:space="preserve">
          <source>No &lt;a href=&quot;#CaseRangeStatement&quot;&gt;&lt;i&gt;CaseRangeStatement&lt;/i&gt;&lt;/a&gt;s are allowed.</source>
          <target state="translated">아니 &lt;a href=&quot;#CaseRangeStatement&quot;&gt;&lt;i&gt;CaseRangeStatement를&lt;/i&gt;&lt;/a&gt; 들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5df4eb877482a34133026cdb08bb53e2da2f886c" translate="yes" xml:space="preserve">
          <source>No &lt;a href=&quot;#DefaultStatement&quot;&gt;&lt;i&gt;DefaultStatement&lt;/i&gt;&lt;/a&gt; is allowed.</source>
          <target state="translated">&lt;a href=&quot;#DefaultStatement&quot;&gt;&lt;i&gt;DefaultStatement&lt;/i&gt;&lt;/a&gt; 는 허용 되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8c0f12b769823d7fd1937e52e1988a020c1b079c" translate="yes" xml:space="preserve">
          <source>No Documentation</source>
          <target state="translated">문서가 없습니다</target>
        </trans-unit>
        <trans-unit id="b083b669fe03ec7d0a1f3bf704ff111420546cb5" translate="yes" xml:space="preserve">
          <source>No argument types are composed of inout types.</source>
          <target state="translated">인수 유형은 입력 유형으로 구성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="05a28f52a1c146ef4b20ec452938cfe8a22f2f90" translate="yes" xml:space="preserve">
          <source>No attributes set.</source>
          <target state="translated">속성이 설정되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="f1563df863c77d6e7fa91961ad8c317b0e5242ee" translate="yes" xml:space="preserve">
          <source>No casting from a pointer type to any type other than &lt;code&gt;void*&lt;/code&gt;.</source>
          <target state="translated">포인터 유형에서 &lt;code&gt;void*&lt;/code&gt; 이외의 유형으로 캐스트하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="d2b719c294a008242eab778b0415eda49646fa7f" translate="yes" xml:space="preserve">
          <source>No casting from a pointer type to any type with pointers other than &lt;code&gt;void*&lt;/code&gt;.</source>
          <target state="translated">포인터 유형에서 &lt;code&gt;void*&lt;/code&gt; 이외의 포인터를 사용하는 유형으로 캐스팅하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="e4eccf0778d2081320adaf4c9dc6b743373b86ae" translate="yes" xml:space="preserve">
          <source>No casting from any non-pointer type to a pointer type.</source>
          <target state="translated">포인터가 아닌 유형에서 포인터 유형으로 캐스트하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5c470bb022340ab631092bbc23badd4bdd7c168d" translate="yes" xml:space="preserve">
          <source>No catching of exceptions that are not derived from &lt;code&gt;class Exception&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;class Exception&lt;/code&gt; 에서 파생되지 않은 예외를 catch하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="fbac8274a33fb459b7645c36c3607643d6b98cfe" translate="yes" xml:space="preserve">
          <source>No compression, just archiving</source>
          <target state="translated">압축 없음, 보관 만</target>
        </trans-unit>
        <trans-unit id="4188ccd2e11d8b82f2d752d935628af0f778934d" translate="yes" xml:space="preserve">
          <source>No compression, just archiving.</source>
          <target state="translated">압축하지 않고 보관 만합니다.</target>
        </trans-unit>
        <trans-unit id="6579f4713f1ca4f2cacddaf325e194df56d72c76" translate="yes" xml:space="preserve">
          <source>No documentation is generated for the following constructs, even if they have a documentation comment:</source>
          <target state="translated">다음과 같은 구문에 대해서는 문서 주석이 있어도 문서가 생성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c5f9dc057bfe284b0c9c0f7b4ca23ad4c81ff2b1" translate="yes" xml:space="preserve">
          <source>No errors get inadvertently ignored.</source>
          <target state="translated">실수로 오류가 무시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="50aeb67eaf0b0cda9c958bef425109300bb895b8" translate="yes" xml:space="preserve">
          <source>No exceptions are thrown due to incorrect CSV.</source>
          <target state="translated">잘못된 CSV로 인해 예외가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dc51393e7f92e68cd01f568a57bc078ab0b1db70" translate="yes" xml:space="preserve">
          <source>No explicit casting of immutable objects to mutable.</source>
          <target state="translated">변경 불가능한 오브젝트를 변경 가능으로 명시 적으로 캐스트하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e4d9d68fd7f6457d876881ca9bddb464171be02d" translate="yes" xml:space="preserve">
          <source>No explicit casting of mutable objects to immutable.</source>
          <target state="translated">불변으로 변경 가능한 객체를 명시 적으로 캐스팅하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="775074d6faaec2b5829ecb6995107bffdb44ed81" translate="yes" xml:space="preserve">
          <source>No explicit casting of shared objects to thread local.</source>
          <target state="translated">스레드 로컬로 공유 객체를 명시 적으로 캐스팅하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0117ad0eedc8f9fbd21fb52bc04392fa4d19b224" translate="yes" xml:space="preserve">
          <source>No explicit casting of thread local objects to shared.</source>
          <target state="translated">공유 할 스레드 로컬 오브젝트를 명시 적으로 캐스팅하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ea0b61f64bab381eec1afb06029d67d731142c75" translate="yes" xml:space="preserve">
          <source>No immutables</source>
          <target state="translated">불변 없음</target>
        </trans-unit>
        <trans-unit id="c1cfcdaf8da9814719d81beadb47a10db90d633b" translate="yes" xml:space="preserve">
          <source>No longer used</source>
          <target state="translated">더 이상 사용하지 않음</target>
        </trans-unit>
        <trans-unit id="f2b30c37a539bfa2c82d0314aa5de0494ad94e1d" translate="yes" xml:space="preserve">
          <source>No longer used, kept as alias to Regex for backwards compatibility.</source>
          <target state="translated">더 이상 사용되지 않으며 이전 버전과의 호환성을 위해 Regex의 별칭으로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="00ef7d44f74673ea0171f0ade11b4f235bf2603b" translate="yes" xml:space="preserve">
          <source>No new scope is introduced, even if the</source>
          <target state="translated">새로운 범위가 도입되지 않더라도</target>
        </trans-unit>
        <trans-unit id="f181ddb7a18d67a4be3a457ae7b06e8eba4e6364" translate="yes" xml:space="preserve">
          <source>No pointer arithmetic (including pointer indexing).</source>
          <target state="translated">포인터 산술이 없습니다 (포인터 인덱싱 포함).</target>
        </trans-unit>
        <trans-unit id="e48360ebcff22ce8f91aabe6500b37ca86c8ef0e" translate="yes" xml:space="preserve">
          <source>No taking the address of a local variable or function parameter.</source>
          <target state="translated">로컬 변수 또는 함수 매개 변수의 주소를 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="16d169fc62706e94837dca4e7304ed543a25d932" translate="yes" xml:space="preserve">
          <source>No-GC Functions</source>
          <target state="translated">비 GC 기능</target>
        </trans-unit>
        <trans-unit id="12e519130ae384b81c85660c8490969df2fb8431" translate="yes" xml:space="preserve">
          <source>No-GC functions are functions marked with the &lt;code&gt;@nogc&lt;/code&gt; attribute. Those functions do not allocate memory on the GC heap, through the following language features:</source>
          <target state="translated">비 GC 기능은 &lt;code&gt;@nogc&lt;/code&gt; 속성으로 표시된 기능 입니다. 이러한 함수는 다음 언어 기능을 통해 GC 힙에 메모리를 할당하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0c64e8cc83777da3ceeb6f24324ae0cad20ddc48" translate="yes" xml:space="preserve">
          <source>No-GC functions cannot be closures.</source>
          <target state="translated">비 GC 기능은 클로저가 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e71ecc7f1b6436e6f38e1a5ba5a26ba864e8984e" translate="yes" xml:space="preserve">
          <source>No-GC functions cannot call functions that are not &lt;code&gt;@nogc&lt;/code&gt;.</source>
          <target state="translated">비 GC 함수는 &lt;code&gt;@nogc&lt;/code&gt; 가 아닌 함수를 호출 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="ea249cedbd757dbfa8a8d6da523734c90b706a5c" translate="yes" xml:space="preserve">
          <source>No-op.</source>
          <target state="translated">No-op.</target>
        </trans-unit>
        <trans-unit id="1f9e31c476e79b885710c0e54c00dae29e759873" translate="yes" xml:space="preserve">
          <source>No-seed version. The first element of &lt;code&gt;r&lt;/code&gt; is used as the seed's value.</source>
          <target state="translated">씨앗 없음 버전. &lt;code&gt;r&lt;/code&gt; 의 첫 번째 요소 는 시드 값으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2d2d6976f81cfe20333afbe24adc3861a20e45ae" translate="yes" xml:space="preserve">
          <source>No-seed version. The first element of &lt;code&gt;r&lt;/code&gt; is used as the seed's value. For each function &lt;code&gt;f&lt;/code&gt; in &lt;code&gt;fun&lt;/code&gt;, the corresponding seed type &lt;code&gt;S&lt;/code&gt; is &lt;code&gt;Unqual!(typeof(f(e, e)))&lt;/code&gt;, where &lt;code&gt;e&lt;/code&gt; is an element of &lt;code&gt;r&lt;/code&gt;: &lt;code&gt;ElementType!R&lt;/code&gt;. Once &lt;code&gt;S&lt;/code&gt; has been determined, then &lt;code&gt;S s = e;&lt;/code&gt; and &lt;code&gt;s = f(s, e);&lt;/code&gt; must both be legal.</source>
          <target state="translated">씨앗 없음 버전. &lt;code&gt;r&lt;/code&gt; 의 첫 번째 요소 는 시드 값으로 사용됩니다. &lt;code&gt;fun&lt;/code&gt; 의 각 함수 &lt;code&gt;f&lt;/code&gt; 에 대해 해당 시드 유형 &lt;code&gt;S&lt;/code&gt; 는 &lt;code&gt;Unqual!(typeof(f(e, e)))&lt;/code&gt; . 여기서 &lt;code&gt;e&lt;/code&gt; 는 &lt;code&gt;r&lt;/code&gt; : &lt;code&gt;ElementType!R&lt;/code&gt; 의 요소입니다 . &lt;code&gt;S&lt;/code&gt; 가 결정 되면 , &lt;code&gt;S s = e;&lt;/code&gt; 그리고 &lt;code&gt;s = f(s, e);&lt;/code&gt; 둘 다 합법적이어야합니다.</target>
        </trans-unit>
        <trans-unit id="b0f4acc87a789952bfc1b197631323f519961850" translate="yes" xml:space="preserve">
          <source>Node to represent a version condition</source>
          <target state="translated">버전 조건을 나타내는 노드</target>
        </trans-unit>
        <trans-unit id="b467c97e1e04e6dfe215b8ccc5a464d40fdfc31c" translate="yes" xml:space="preserve">
          <source>Nominally the result is the desired value of the cast operation, which will be forwarded as the result of the cast. For &lt;code&gt;Abort&lt;/code&gt;, the function never returns because it aborts the program.</source>
          <target state="translated">명목상 결과는 원하는 캐스트 연산 값이며 캐스트 결과로 전달됩니다. 들어 &lt;code&gt;Abort&lt;/code&gt; 이 프로그램을 중단하기 때문에,이 함수는 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="11768937dad6c4d6650b30ee482657c917bafca3" translate="yes" xml:space="preserve">
          <source>Nominally the result is the desired value of the cast operation, which will be forwarded as the result of the cast. For &lt;code&gt;Throw&lt;/code&gt;, the function never returns because it throws an exception.</source>
          <target state="translated">명목상 결과는 원하는 캐스트 연산 값이며 캐스트 결과로 전달됩니다. 들어 &lt;code&gt;Throw&lt;/code&gt; 예외를 발생하기 때문에,이 함수는 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1b2c041885adf1fc88ecec500a0190e9f4cf26cd" translate="yes" xml:space="preserve">
          <source>Nominally the result is the desired value of the operator, which will be forwarded as result. For &lt;code&gt;Abort&lt;/code&gt;, the function never returns because it aborts the program.</source>
          <target state="translated">명목상 결과는 원하는 연산자 값이며 결과로 전달됩니다. 들어 &lt;code&gt;Abort&lt;/code&gt; 이 프로그램을 중단하기 때문에,이 함수는 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="058f4352276fbd832056c1654d0a5c83818f3abd" translate="yes" xml:space="preserve">
          <source>Nominally the result is the desired value of the operator, which will be forwarded as result. For &lt;code&gt;Throw&lt;/code&gt;, the function never returns because it throws an exception.</source>
          <target state="translated">명목상 결과는 원하는 연산자 값이며 결과로 전달됩니다. 들어 &lt;code&gt;Throw&lt;/code&gt; 예외를 발생하기 때문에,이 함수는 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="95ff8049ae0af803b72d929b70cdc7bd1428c808" translate="yes" xml:space="preserve">
          <source>Nominally the result is the desired value of the operator, which will be forwarded as result. For &lt;code&gt;Throw&lt;/code&gt;, the function never returns because it throws.</source>
          <target state="translated">명목상 결과는 원하는 연산자 값이며 결과로 전달됩니다. 들어 &lt;code&gt;Throw&lt;/code&gt; 가 발생하기 때문에,이 함수는 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7f89b59a9068926b546bf9dc745b7cf2ad0322d0" translate="yes" xml:space="preserve">
          <source>Non-IEEE 128 bit Big-endian 'doubledouble' (eg PowerPC) has partial support</source>
          <target state="translated">비 IEEE 128 비트 Big-endian 'doubledouble'(예 : PowerPC)은 부분적으로 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="a25c683f08b05e969df911e0d059e27354f7cc6b" translate="yes" xml:space="preserve">
          <source>Non-Lexical Lifetimes</source>
          <target state="translated">비언어적 일생</target>
        </trans-unit>
        <trans-unit id="d8c2f7e6bb1f6c3ecbf603f6f600b23e9b51b8c3" translate="yes" xml:space="preserve">
          <source>Non-Standard Format Specifiers</source>
          <target state="translated">비표준 형식 지정자</target>
        </trans-unit>
        <trans-unit id="eb9b3d80259432deefe50b3b3a447de9bae6df57" translate="yes" xml:space="preserve">
          <source>Non-Standard format specifiers will be rejected by the compiler. Since the checking is only done for formats as string literals, non-Standard ones can be used:</source>
          <target state="translated">비표준 형식 지정자는 컴파일러에서 거부됩니다. 검사는 문자열 리터럴 형식에 대해서만 수행되므로 비표준 형식을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="81fddc68dfa81833c1f14ca92fdbdf8790a22085" translate="yes" xml:space="preserve">
          <source>Non-allocating forward range option: &amp;Omicron;(&lt;code&gt;n^2&lt;/code&gt;) Non-allocating forward range option with custom &lt;code&gt;pred&lt;/code&gt;: &amp;Omicron;(&lt;code&gt;n^2&lt;/code&gt;) Allocating forward range option: amortized &amp;Omicron;(&lt;code&gt;r1.length&lt;/code&gt;) + &amp;Omicron;(&lt;code&gt;r2.length&lt;/code&gt;)</source>
          <target state="translated">비 할당 포워드 범위 옵션 : &amp;Omicron; ( &lt;code&gt;n^2&lt;/code&gt; ) 사용자 정의 &lt;code&gt;pred&lt;/code&gt; 를 사용한 비 할당 포워드 범위 옵션 : &amp;Omicron; ( &lt;code&gt;n^2&lt;/code&gt; ) 포워드 범위 할당 옵션 : 상각 &amp;Omicron; ( &lt;code&gt;r1.length&lt;/code&gt; ) + &amp;Omicron; ( &lt;code&gt;r2.length&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="a578c05b9c2826b19b96d5e16a0ceb9b0ece04e0" translate="yes" xml:space="preserve">
          <source>Non-copyable structs can still be moved:</source>
          <target state="translated">복사 할 수없는 구조체는 여전히 이동할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a1e5ae49f7fbd3b1306db6c5fe5107b5dbc51c5" translate="yes" xml:space="preserve">
          <source>Non-forward input ranges are supported, but with limited semantics.</source>
          <target state="translated">전달이 아닌 입력 범위가 지원되지만 의미가 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="9d73b158c3cbb9c0c20029958a34f23570ec9b1c" translate="yes" xml:space="preserve">
          <source>Non-portable casts (eg, from &lt;code&gt;int[]&lt;/code&gt; to &lt;code&gt;float[]&lt;/code&gt;), including casts which depend on endianness, are not permitted. Casts between signed and unsigned types are permitted</source>
          <target state="translated">엔디안에 의존하는 캐스트를 포함하여 이식 불가능한 캐스트 (예 : &lt;code&gt;int[]&lt;/code&gt; 에서 &lt;code&gt;float[]&lt;/code&gt; )는 허용되지 않습니다. 서명 된 유형과 서명되지 않은 유형 사이의 캐스트는 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="61e065b3de2ba702e71857963714ee2de3918409" translate="yes" xml:space="preserve">
          <source>Non-recoverable errors (such as assert failures) do not throw exceptions; instead, they end interpretation immediately.</source>
          <target state="translated">복구 할 수없는 오류 (예 : 어설 션 오류)는 예외를 발생시키지 않습니다. 대신에 그들은 즉시 해석을 끝냅니다.</target>
        </trans-unit>
        <trans-unit id="d74bfb7bba1e55d60fe9becbe7df81d0fef5ea9e" translate="yes" xml:space="preserve">
          <source>Non-shared static constructors and destructors are run whenever threads are created or destroyed, including the main thread.</source>
          <target state="translated">비공유 정적 생성자와 소멸자는 주 스레드를 포함하여 스레드가 작성되거나 소멸 될 때마다 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="c605ebf3ce46a504feb4b640239e7ba60285c122" translate="yes" xml:space="preserve">
          <source>Non-shared static constructors and destructors are used to initialize and terminate thread local data.</source>
          <target state="translated">비공유 정적 생성자와 소멸자는 스레드 로컬 데이터를 초기화하고 종료하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d96909cc07f8b70370f0c23c993424d8363fc715" translate="yes" xml:space="preserve">
          <source>Non-static &lt;a href=&quot;#nested&quot;&gt;function-nested D structs&lt;/a&gt;, which access the context of their enclosing scope, have an extra field.</source>
          <target state="translated">비-정적 &lt;a href=&quot;#nested&quot;&gt;함수 중첩 D 구조체&lt;/a&gt; 는 엔 클로징 범위의 컨텍스트에 액세스하며 추가 필드를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="b3b2dbc478b4150312eab6be4bc6d5c0decce954" translate="yes" xml:space="preserve">
          <source>Non-static member functions can have, in addition to the usual &lt;a href=&quot;function#FunctionAttribute&quot;&gt;&lt;i&gt;FunctionAttribute&lt;/i&gt;&lt;/a&gt;s, the attributes &lt;code&gt;const&lt;/code&gt;, &lt;code&gt;immutable&lt;/code&gt;, &lt;code&gt;shared&lt;/code&gt;, or &lt;code&gt;inout&lt;/code&gt;. These attributes apply to the hidden</source>
          <target state="translated">비 정적 멤버 함수에는 일반적인 &lt;a href=&quot;function#FunctionAttribute&quot;&gt;&lt;i&gt;FunctionAttribute&lt;/i&gt;&lt;/a&gt; 외에도 &lt;code&gt;const&lt;/code&gt; , &lt;code&gt;immutable&lt;/code&gt; , &lt;code&gt;shared&lt;/code&gt; 또는 &lt;code&gt;inout&lt;/code&gt; 속성 이있을 수 있습니다 . 이러한 속성은 숨겨진</target>
        </trans-unit>
        <trans-unit id="f0fad86bcaafddf030802679290bc8c2fee402a9" translate="yes" xml:space="preserve">
          <source>Non-static member functions have an extra hidden parameter called</source>
          <target state="translated">비 정적 멤버 함수에는</target>
        </trans-unit>
        <trans-unit id="7a196514d4f0d0eafb3a4cd25af29fefa694ba14" translate="yes" xml:space="preserve">
          <source>Non-static member functions or static member functions with &lt;code&gt;Objective-C&lt;/code&gt; linkage have an extra hidden parameter called</source>
          <target state="translated">정적이 아닌 멤버 함수 또는 &lt;code&gt;Objective-C&lt;/code&gt; 링크가있는 정적 멤버 함수 에는 추가 숨겨진 매개 변수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="f3b4db56d91106facfca56b48e63a8bae5d8e3b2" translate="yes" xml:space="preserve">
          <source>Non-static nested classes work by containing an extra hidden member (called the context pointer) that is the frame pointer of the enclosing function if it is nested inside a function, or the &lt;code&gt;this&lt;/code&gt; of the enclosing class's instance if it is nested inside a class.</source>
          <target state="translated">비 정적 중첩 클래스가 함수 내부에 중첩되어있는 경우를 둘러싸는 함수의 프레임 포인터이다 (컨텍스트 포인터라고 함) 추가 숨겨진 부재 또는 함유 작동 &lt;code&gt;this&lt;/code&gt; 클로징 클래스의 인스턴스가 클래스 내에 중첩되어있는 경우를 .</target>
        </trans-unit>
        <trans-unit id="5548014eb4de34224028b093eceb44e9d96d089f" translate="yes" xml:space="preserve">
          <source>Non-static nested classes work by containing an extra hidden member (called the context pointer) that is the frame pointer of the enclosing function if it is nested inside a function, or the &lt;code&gt;this&lt;/code&gt; reference of the enclosing class's instance if it is nested inside a class.</source>
          <target state="translated">비 정적 중첩 클래스가 함수 내부에 중첩되어있는 경우를 둘러싸는 함수의 프레임 포인터이다 (컨텍스트 포인터라고 함) 추가 숨겨진 부재 또는 함유 작동 &lt;code&gt;this&lt;/code&gt; 그 중첩 내부 A는 경우 클로징 클래스의 인스턴스의 참조 수업.</target>
        </trans-unit>
        <trans-unit id="3ea89d244aa398e61a240d02e563d9e920cc1cfb" translate="yes" xml:space="preserve">
          <source>Non-zero value means to use the global dns cache</source>
          <target state="translated">0이 아닌 값은 전역 DNS 캐시를 사용함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="1aafcdc0be4becd732b9a3ad04759d113484d426" translate="yes" xml:space="preserve">
          <source>NonEmptyStatement</source>
          <target state="translated">NonEmptyStatement</target>
        </trans-unit>
        <trans-unit id="d42bc2090abcd86d6431b50ed9070e084b02b130" translate="yes" xml:space="preserve">
          <source>NonVoidInitializer</source>
          <target state="translated">NonVoidInitializer</target>
        </trans-unit>
        <trans-unit id="1179ca48470076675d205adcff73d6d61f15f34a" translate="yes" xml:space="preserve">
          <source>Noncharacter_Code_Point</source>
          <target state="translated">Noncharacter_Code_Point</target>
        </trans-unit>
        <trans-unit id="36dc33e9395aef9881b08cdb0dd1daef6114c736" translate="yes" xml:space="preserve">
          <source>Nonspacing_Mark</source>
          <target state="translated">Nonspacing_Mark</target>
        </trans-unit>
        <trans-unit id="429802f981d76022956f28768dab516f8772bd42" translate="yes" xml:space="preserve">
          <source>Nonstandard function that minimizes the memory usage of the freelist by freeing each element in turn. Defined only if &lt;code&gt;ParentAllocator&lt;/code&gt; defines &lt;code&gt;deallocate&lt;/code&gt;.</source>
          <target state="translated">각 요소를 차례로 해제하여 자유 목록의 메모리 사용을 최소화하는 비표준 기능. &lt;code&gt;ParentAllocator&lt;/code&gt; 가 &lt;code&gt;deallocate&lt;/code&gt; 를 정의한 경우에만 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="57b001c8ba41b4ad340a0d783255e54cfd3c3bce" translate="yes" xml:space="preserve">
          <source>Nonstandard function that minimizes the memory usage of the freelist by freeing each element in turn. Defined only if &lt;code&gt;ParentAllocator&lt;/code&gt; defines &lt;code&gt;deallocate&lt;/code&gt;. &lt;code&gt;FreeList!(0, unbounded)&lt;/code&gt; does not have this function.</source>
          <target state="translated">각 요소를 차례로 해제하여 자유 목록의 메모리 사용을 최소화하는 비표준 기능. &lt;code&gt;ParentAllocator&lt;/code&gt; 가 &lt;code&gt;deallocate&lt;/code&gt; 를 정의한 경우에만 정의됩니다 . &lt;code&gt;FreeList!(0, unbounded)&lt;/code&gt; 에는이 기능이 없습니다.</target>
        </trans-unit>
        <trans-unit id="e3b494dd74c014fe5ba2aa220f7424fbd28b5b50" translate="yes" xml:space="preserve">
          <source>Nonstandard function that returns the bytes available for allocation.</source>
          <target state="translated">할당에 사용 가능한 바이트를 반환하는 비표준 함수.</target>
        </trans-unit>
        <trans-unit id="1b4df24b03c214a98bd7860dd19d472f2804640a" translate="yes" xml:space="preserve">
          <source>Nonstandard property that returns bytes available for allocation.</source>
          <target state="translated">할당에 사용 가능한 바이트를 반환하는 비표준 속성입니다.</target>
        </trans-unit>
        <trans-unit id="3412d111007fbeb4dae75cdce13533138e69acc1" translate="yes" xml:space="preserve">
          <source>Nonzero for on.</source>
          <target state="translated">에 0이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="46931da5935530c974e152c2caa633195ab79b11" translate="yes" xml:space="preserve">
          <source>Normal distribution function.</source>
          <target state="translated">정규 분포 함수.</target>
        </trans-unit>
        <trans-unit id="b8c54e5e1e867a54e9d75697c450f4be835f910e" translate="yes" xml:space="preserve">
          <source>Normalization</source>
          <target state="translated">Normalization</target>
        </trans-unit>
        <trans-unit id="80b6124577fc42c3b7c1e6bbf615255e8605397d" translate="yes" xml:space="preserve">
          <source>Normalization Form C (NFC): The canonical composition of the &lt;a href=&quot;#Canonical%20decomposition&quot;&gt;canonical decomposition&lt;/a&gt; of a coded character sequence.</source>
          <target state="translated">정규화 형태 C (NFC) : 코딩 된 문자 서열 의 &lt;a href=&quot;#Canonical%20decomposition&quot;&gt;표준 분해&lt;/a&gt; 의 표준 구성 .</target>
        </trans-unit>
        <trans-unit id="0418119af85721c4087c8e6f6b3159c547d399f2" translate="yes" xml:space="preserve">
          <source>Normalization Form D (NFD): The &lt;a href=&quot;#Canonical%20decomposition&quot;&gt; canonical decomposition&lt;/a&gt; of a character sequence.</source>
          <target state="translated">정규화 형식 D (NFD) : 문자 시퀀스 의 &lt;a href=&quot;#Canonical%20decomposition&quot;&gt;정식 분해&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="138b8bb2fbf469c965274f2588f5cf860f8e57f2" translate="yes" xml:space="preserve">
          <source>Normalization Form KC (NFKC): The canonical composition of the &lt;a href=&quot;#Compatibility%20decomposition&quot;&gt; compatibility decomposition&lt;/a&gt; of a character sequence</source>
          <target state="translated">정규화 형식 KC (NFKC) : 문자 시퀀스 의 &lt;a href=&quot;#Compatibility%20decomposition&quot;&gt;호환성 분해&lt;/a&gt; 에 대한 표준 구성</target>
        </trans-unit>
        <trans-unit id="031a463d0092b90e5f527a2e15b37690c30120f9" translate="yes" xml:space="preserve">
          <source>Normalization Form KD (NFKD): The &lt;a href=&quot;#Compatibility%20decomposition&quot;&gt; compatibility decomposition&lt;/a&gt; of a character sequence.</source>
          <target state="translated">정규화 형식 KD (NFKD) : 문자 시퀀스 의 &lt;a href=&quot;#Compatibility%20decomposition&quot;&gt;호환성 분해&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9fc9758024af9fe044b26fa95babda5e385e2a92" translate="yes" xml:space="preserve">
          <source>Normalize a path by resolving current/parent directory symbols (&lt;code&gt;&quot;.&quot;&lt;/code&gt; and &lt;code&gt;&quot;..&quot;&lt;/code&gt;) and removing superfluous directory separators. It will return &quot;.&quot; if the path leads to the starting directory. On Windows, slashes are replaced with backslashes.</source>
          <target state="translated">현재 / 부모 디렉토리 기호 ( &lt;code&gt;&quot;.&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;..&quot;&lt;/code&gt; )를 해결하고 불필요한 디렉토리 구분 기호를 제거 하여 경로를 정규화하십시오 . &quot;.&quot;를 반환합니다. 경로가 시작 디렉토리로 연결되는 경우 Windows에서 슬래시는 백 슬래시로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="8001671105bf59f11468e49232cdcf7930cadfe8" translate="yes" xml:space="preserve">
          <source>Normalize path by turning forward slashes into backslashes</source>
          <target state="translated">슬래시를 백 슬래시로 전환하여 경로 정규화</target>
        </trans-unit>
        <trans-unit id="9e6f99e9fe995a304393f1d99580068a9cbfde06" translate="yes" xml:space="preserve">
          <source>Normalizes values in &lt;code&gt;range&lt;/code&gt; by multiplying each element with a number chosen such that values sum up to &lt;code&gt;sum&lt;/code&gt;. If elements in &lt;code&gt;range&lt;/code&gt; sum to zero, assigns &lt;code&gt;sum / range.length&lt;/code&gt; to all. Normalization makes sense only if all elements in &lt;code&gt;range&lt;/code&gt; are positive. &lt;code&gt;normalize&lt;/code&gt; assumes that is the case without checking it.</source>
          <target state="translated">정규화 값의 &lt;code&gt;range&lt;/code&gt; 값에 합산되도록 선택 번호와 각 요소 곱하여 &lt;code&gt;sum&lt;/code&gt; . &lt;code&gt;range&lt;/code&gt; 요소 합계가 0이면 &lt;code&gt;sum / range.length&lt;/code&gt; 를 모두에 할당 합니다. &lt;code&gt;range&lt;/code&gt; 내의 모든 요소 가 양수인 경우에만 정규화가 의미 가 있습니다. &lt;code&gt;normalize&lt;/code&gt; 는이를 확인하지 않은 경우라고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="661d479c1dc56a2c85105c1a989fb99e1258f06c" translate="yes" xml:space="preserve">
          <source>Normally it is not necessary to do this manually, as &lt;a href=&quot;std_stdio#File&quot;&gt;&lt;code&gt;std.stdio.File&lt;/code&gt;&lt;/a&gt; objects are automatically closed when there are no more references to them.</source>
          <target state="translated">&lt;a href=&quot;std_stdio#File&quot;&gt; &lt;code&gt;std.stdio.File&lt;/code&gt; &lt;/a&gt; 오브젝트는 더 이상 참조가 없으면 자동으로 닫히 므로 일반적으로 수동으로 수행 할 필요 는 없습니다.</target>
        </trans-unit>
        <trans-unit id="adfa9c0b301a56712a5c4c9dfdc57e862274cd5a" translate="yes" xml:space="preserve">
          <source>Normally the entire range is iterated. If partial iteration (early stopping) is desired, &lt;code&gt;fun&lt;/code&gt; needs to return a value of type &lt;a href=&quot;std_typecons#Flag&quot;&gt;&lt;code&gt;std.typecons.Flag&lt;/code&gt;&lt;/a&gt;&lt;code&gt;!&quot;each&quot;&lt;/code&gt; (&lt;code&gt;Yes.each&lt;/code&gt; to continue iteration, or &lt;code&gt;No.each&lt;/code&gt; to stop iteration).</source>
          <target state="translated">일반적으로 전체 범위가 반복됩니다. 부분 반복 (초기 중지)이 필요한 경우, &lt;code&gt;fun&lt;/code&gt; 는 &lt;a href=&quot;std_typecons#Flag&quot;&gt; &lt;code&gt;std.typecons.Flag&lt;/code&gt; &lt;/a&gt; &lt;code&gt;!&quot;each&quot;&lt;/code&gt; 유형의 값을 리턴해야합니다 ( &lt;code&gt;Yes.each&lt;/code&gt; 반복을 계속하려면 각각 또는 반복을 중지하려면 &lt;code&gt;No.each&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="29618eee34797a5a2f7a6b8c7471e6891e8c6f72" translate="yes" xml:space="preserve">
          <source>Normally this will be a representation of some substitution character, such as U+FFFD or '?'.</source>
          <target state="translated">일반적으로 이것은 U + FFFD 또는 '?'와 같은 대체 문자를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="616330b39a091db71ac93a24fa21496f28c24b0e" translate="yes" xml:space="preserve">
          <source>Normally, all threads other than the collector thread must be halted while the collection is in progress.</source>
          <target state="translated">일반적으로 수집이 진행되는 동안 수집기 스레드 이외의 모든 스레드를 중지해야합니다.</target>
        </trans-unit>
        <trans-unit id="d2cdadd59c9faa6f566843af471118acedd006a9" translate="yes" xml:space="preserve">
          <source>Normally, variables are initialized either with an explicit &lt;a href=&quot;#Initializer&quot;&gt;&lt;i&gt;Initializer&lt;/i&gt;&lt;/a&gt; or are set to the default value for the type of the variable. If the</source>
          <target state="translated">일반적으로 변수는 명시 적 &lt;a href=&quot;#Initializer&quot;&gt;&lt;i&gt;이니셜 라이저로 초기화&lt;/i&gt;&lt;/a&gt; 되거나 변수 유형의 기본값으로 설정됩니다. 만약</target>
        </trans-unit>
        <trans-unit id="b33c1ae2bc162cf47c63d7dd7001c6d16ef1d3ab" translate="yes" xml:space="preserve">
          <source>Not &lt;code&gt;null&lt;/code&gt; iff the &lt;code&gt;static foreach&lt;/code&gt; is over a range. Exactly one of the &lt;code&gt;aggrefe&lt;/code&gt; and &lt;code&gt;rangefe&lt;/code&gt; fields is not null. See &lt;code&gt;aggrfe&lt;/code&gt; field for more details.</source>
          <target state="translated">아니 &lt;code&gt;null&lt;/code&gt; IFF &lt;code&gt;static foreach&lt;/code&gt; 범위에 걸쳐있다. &lt;code&gt;aggrefe&lt;/code&gt; 및 &lt;code&gt;rangefe&lt;/code&gt; 필드 중 하나가 널이 아닙니다. 자세한 내용은 &lt;code&gt;aggrfe&lt;/code&gt; 필드를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="53a3a9472c8c6ede9ddff52aba2954163c06cc47" translate="yes" xml:space="preserve">
          <source>Not &lt;code&gt;null&lt;/code&gt; iff the &lt;code&gt;static foreach&lt;/code&gt; is over an aggregate. In this case, it contains the corresponding ForeachStatement. For StaticForeachDeclaration, the body is &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;static foreach&lt;/code&gt; 가 집계를 초과하는 경우 &lt;code&gt;null&lt;/code&gt; 이 아닙니다 . 이 경우 해당 ForeachStatement가 포함됩니다. StaticForeachDeclaration의 경우 본문은 &lt;code&gt;null&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="97057bfa10cf793926cfd87b11566cdc01e1cb3c" translate="yes" xml:space="preserve">
          <source>Not all NFS implementations correctly implement file locking.</source>
          <target state="translated">모든 NFS 구현이 파일 잠금을 올바르게 구현하는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="01a3e29cd96b83aac5cafcd85558e38b6683f44f" translate="yes" xml:space="preserve">
          <source>Not currently implemented - rounds twice.</source>
          <target state="translated">현재 구현되지 않음-두 번 반올림합니다.</target>
        </trans-unit>
        <trans-unit id="8c8eaa281c14ceaa91826c9250d9cfd83ad9d40f" translate="yes" xml:space="preserve">
          <source>Not everything can be directly aliased. An alias cannot be declared of - for example - a literal:</source>
          <target state="translated">모든 것이 직접 별칭을 지정할 수있는 것은 아닙니다. 별명은 예를 들어 리터럴로 선언 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="4fb931cd85c14975fa02ea3e36a9938b47df2d71" translate="yes" xml:space="preserve">
          <source>Not implemented for Microsoft C Runtime</source>
          <target state="translated">Microsoft C 런타임에 구현되지 않음</target>
        </trans-unit>
        <trans-unit id="d1cd7a5726d3f1a764ca2fc961231d11bd265912" translate="yes" xml:space="preserve">
          <source>Not only functions, but also instantiated class and struct types can become nested via implicitly captured context.</source>
          <target state="translated">함수뿐만 아니라 인스턴스화 된 클래스 및 구조체 유형도 암시 적으로 캡처 된 컨텍스트를 통해 중첩 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="370f69da05a7f1c2f2916dfb7540ce12b5251753" translate="yes" xml:space="preserve">
          <source>Not sequenced. Corresponds to &lt;a href=&quot;https://llvm.org/docs/Atomics.html#monotonic&quot;&gt;LLVM AtomicOrdering.Monotonic&lt;/a&gt; and C++11/C11 &lt;code&gt;memory_order_relaxed&lt;/code&gt;.</source>
          <target state="translated">시퀀싱되지 않았습니다. 에 해당하는 &lt;a href=&quot;https://llvm.org/docs/Atomics.html#monotonic&quot;&gt;LLVM AtomicOrdering.Monotonic&lt;/a&gt; 및 C ++ (11) / C11은 &lt;code&gt;memory_order_relaxed&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="72a8611375e3228ee97719b4aa70e9a3728d46c5" translate="yes" xml:space="preserve">
          <source>Not used</source>
          <target state="translated">미사용</target>
        </trans-unit>
        <trans-unit id="82ecf8fc619ffac944a052c932297b27a382324f" translate="yes" xml:space="preserve">
          <source>Notably absent from the list of overloaded unary operators is the ! logical negation operator. More obscurely absent is a unary operator to convert to a bool result. Instead, these are covered by a rewrite to:</source>
          <target state="translated">오버로드 된 단항 연산자 목록에없는 것은 주목할 만하다. 논리적 부정 연산자. 더 모호한 결석은 부울 결과로 변환하는 단항 연산자입니다. 대신, 이것들은 다음과 같이 다시 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="2c924e3088204ee77ba681f72be3444357932fca" translate="yes" xml:space="preserve">
          <source>Note</source>
          <target state="translated">Note</target>
        </trans-unit>
        <trans-unit id="d0ac0232e6dce0f6fe6e5dd1148acf7178ea46fa" translate="yes" xml:space="preserve">
          <source>Note how in the above example, the constructor is not bindable and is instead disabled on the D side; an alternative would be to reimplement the constructor in D. See the &lt;a href=&quot;cpp_interface#lifetime-management&quot;&gt;section below on lifetime management&lt;/a&gt; for more information.</source>
          <target state="translated">위 예제에서 생성자가 바인딩 가능하지 않고 D 측에서 어떻게 비활성화되어 있는지 확인하십시오. 대안은 D에서 생성자를 다시 구현하는 것입니다. 자세한 내용은 &lt;a href=&quot;cpp_interface#lifetime-management&quot;&gt;아래의 수명 관리 섹션&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d63d9fe9d0db7f9d24974a2fa9eef608eb74e8f0" translate="yes" xml:space="preserve">
          <source>Note how the gaps in matching are simply ignored, for example (&lt;code&gt;&quot;Hello&quot;, &quot;new&quot;&lt;/code&gt;) is deemed as good a match as (&lt;code&gt;&quot;new&quot;, &quot;world&quot;&lt;/code&gt;). This may be too permissive for some applications. To eliminate gapped matches entirely, use &lt;code&gt;lambda = 0&lt;/code&gt;:</source>
          <target state="translated">예를 들어 ( &lt;code&gt;&quot;Hello&quot;, &quot;new&quot;&lt;/code&gt; )와 같이 일치하는 간격이 단순히 무시 되는 방식은 ( &lt;code&gt;&quot;new&quot;, &quot;world&quot;&lt;/code&gt; ) 만큼 일치하는 것으로 간주됩니다 . 일부 응용 프로그램에서는이 기능이 너무 관대 할 수 있습니다. 갭 일치를 완전히 제거하려면 &lt;code&gt;lambda = 0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a1e8204a558e9a55cf2fa37f85f947f27510f23e" translate="yes" xml:space="preserve">
          <source>Note however that you need to mark the &lt;b&gt;mixin&lt;/b&gt; line with at least a minimal (i.e. just &lt;b&gt;///&lt;/b&gt;) DDoc comment if you want the mixed-in constructors to be documented in the newly created Exception subclass.</source>
          <target state="translated">그러나 &lt;b&gt;믹스 인&lt;/b&gt; 생성자를 새로 작성된 Exception 서브 클래스에 문서화 하려면 &lt;b&gt;믹스 인&lt;/b&gt; 행을 최소한 최소 (예 : &lt;b&gt;///&lt;/b&gt; ) DDoc 주석으로 표시해야합니다.</target>
        </trans-unit>
        <trans-unit id="49782e4f0e6f78442cd5999d6960bb6410f594b1" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;Expression&lt;/i&gt;&lt;/a&gt; only gets evaluated once and is not copied. The with statement does not change what &lt;code&gt;this&lt;/code&gt; or &lt;code&gt;super&lt;/code&gt; refer to.</source>
          <target state="translated">참고 &lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;표현은&lt;/i&gt;&lt;/a&gt; 한 번만 평가됩니다 및 복사되지 않습니다. with 문은 &lt;code&gt;this&lt;/code&gt; 또는 &lt;code&gt;super&lt;/code&gt; 가 참조하는 내용을 변경하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="e4659f73d3ae58eed0197c3a42a85e74bfb19d3b" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;SpanMode.breadth&lt;/code&gt; will not result in all directory members occurring before any subdirectory members, i.e. it is not true &lt;a href=&quot;https://en.wikipedia.org/wiki/Tree_traversal#Breadth-first_search&quot;&gt; breadth-first traversal&lt;/a&gt;.</source>
          <target state="translated">참고 &lt;code&gt;SpanMode.breadth&lt;/code&gt; 는 모든 하위 디렉토리 회원 전에 발생한 모든 디렉토리 회원 발생하지 않습니다, 그것은 사실이 아니다 즉 &lt;a href=&quot;https://en.wikipedia.org/wiki/Tree_traversal#Breadth-first_search&quot;&gt;폭 우선 탐색&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="42e0aef8adc72b9023bfd746db5bfa57d6852029" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;extern(C)&lt;/code&gt; can be provided for all types of declarations, including &lt;code&gt;struct&lt;/code&gt; or &lt;code&gt;class&lt;/code&gt;, even though there is no corresponding match on the &lt;code&gt;C&lt;/code&gt; side. In that case, the attribute is ignored. This behavior applies for nested functions and nested variables as well. However, for &lt;code&gt;static&lt;/code&gt; member methods and &lt;code&gt;static&lt;/code&gt; nested functions, adding &lt;code&gt;extern(C)&lt;/code&gt; will change the calling convention, but not the mangling.</source>
          <target state="translated">참고 &lt;code&gt;extern(C)&lt;/code&gt; 포함 선언의 모든 유형, 제공 될 수있다 &lt;code&gt;struct&lt;/code&gt; 또는 &lt;code&gt;class&lt;/code&gt; 상의 해당하는 일치하는 항목이없는 경우에도, &lt;code&gt;C&lt;/code&gt; 의 측면. 이 경우 속성이 무시됩니다. 이 동작은 중첩 함수 및 중첩 변수에도 적용됩니다. 그러나 &lt;code&gt;static&lt;/code&gt; 멤버 메서드 및 &lt;code&gt;static&lt;/code&gt; 중첩 함수의 경우 &lt;code&gt;extern(C)&lt;/code&gt; 추가 하면 호출 규칙이 변경되지만 mangling은 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c694f9520df240fcfb4f1d45e61d464f651b858d" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;length&lt;/code&gt; is an optional primitive as no range must implement it. Some ranges do not store their length explicitly, some cannot compute it without actually exhausting the range (e.g. socket streams), and some other ranges may be infinite.</source>
          <target state="translated">참고 &lt;code&gt;length&lt;/code&gt; 더 범위를 구현하지해야하기 때문에 선택 원시적이다. 일부 범위는 명시 적으로 길이를 저장하지 않고 일부는 실제로 범위를 소진하지 않으면 범위를 계산할 수 없으며 (예 : 소켓 스트림) 일부 범위는 무한 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1985cc6351c47a8eb8f5d167c16f6d5887181cf3" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;make&lt;/code&gt; can infer the element type from the given arguments.</source>
          <target state="translated">참고 &lt;code&gt;make&lt;/code&gt; 지정된 인수에서 요소 유형을 추론 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d177ff7ae98932b810bf22e27225c171a711978" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;opCast&lt;/code&gt; is only ever used with an explicit &lt;code&gt;cast&lt;/code&gt; expression, except in the case of boolean operations (see next section)</source>
          <target state="translated">참고 &lt;code&gt;opCast&lt;/code&gt; 은 오직 명시 적으로 사용되는 &lt;code&gt;cast&lt;/code&gt; 표현, 부울 연산의 경우를 제외하고 (다음 섹션 참조)</target>
        </trans-unit>
        <trans-unit id="0819f08e5482b36a26eff5fe36779d0358954a41" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;opCmp&lt;/code&gt; is only used for the inequality operators; expressions like &lt;code&gt;a == b&lt;/code&gt; always uses &lt;code&gt;opEquals&lt;/code&gt;. If &lt;code&gt;opCmp&lt;/code&gt; is defined but &lt;code&gt;opEquals&lt;/code&gt; isn't, the compiler will supply a default version of &lt;code&gt;opEquals&lt;/code&gt; that performs member-wise comparison. If this member-wise comparison is not consistent with the user-defined &lt;code&gt;opCmp&lt;/code&gt;, then it is up to the programmer to supply an appropriate version of &lt;code&gt;opEquals&lt;/code&gt;. Otherwise, inequalities like &lt;code&gt;a &amp;lt;= b&lt;/code&gt; will behave inconsistently with equalities like &lt;code&gt;a == b&lt;/code&gt;.</source>
          <target state="translated">참고 &lt;code&gt;opCmp&lt;/code&gt; 은 단지 불평등 운영자에 사용됩니다; &lt;code&gt;a == b&lt;/code&gt; 와 같은 표현식은 항상 &lt;code&gt;opEquals&lt;/code&gt; 를 사용합니다 . 경우 &lt;code&gt;opCmp&lt;/code&gt; 가 정의되어 있지만 &lt;code&gt;opEquals&lt;/code&gt; 가 아니라, 컴파일러의 기본 버전 공급한다 &lt;code&gt;opEquals&lt;/code&gt; 그 수행의 멤버 현명한 비교. 이 멤버 별 비교가 사용자 정의 &lt;code&gt;opCmp&lt;/code&gt; 와 일치하지 않으면 적절한 버전의 &lt;code&gt;opEquals&lt;/code&gt; 를 제공하는 것은 프로그래머의 몫 입니다. 그렇지 않으면 &lt;code&gt;a &amp;lt;= b&lt;/code&gt; 와 같은 불평등 은 &lt;code&gt;a == b&lt;/code&gt; 와 같은 평등과 일치하지 않게 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="1bdba074265129732a88d63db9be3f0813532fc0" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;opDollar!i&lt;/code&gt; is only evaluated once for each &lt;code&gt;i&lt;/code&gt; where &lt;code&gt;$&lt;/code&gt; occurs in the corresponding position in the indexing operation. Thus, an expression like &lt;code&gt;arr[$-sqrt($), 0, $-1]&lt;/code&gt; has the effect of:</source>
          <target state="translated">참고 &lt;code&gt;opDollar!i&lt;/code&gt; 각 번씩 평가 &lt;code&gt;i&lt;/code&gt; &lt;code&gt;$&lt;/code&gt; 는 인덱싱 동작에 대응하는 위치에 발생한다. 따라서 &lt;code&gt;arr[$-sqrt($), 0, $-1]&lt;/code&gt; 과 같은 표현식은 다음과 같은 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="d28a332cf4afd40dd7792fd4da1375ef4f81f0a1" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;opIn&lt;/code&gt; and &lt;code&gt;opIn_r&lt;/code&gt; have been deprecated in favor of &lt;code&gt;opBinary!&quot;in&quot;&lt;/code&gt; and &lt;code&gt;opBinaryRight!&quot;in&quot;&lt;/code&gt; respectively.</source>
          <target state="translated">참고 &lt;code&gt;opIn&lt;/code&gt; 및 &lt;code&gt;opIn_r&lt;/code&gt; 가 찬성 사용되지 않습니다 &lt;code&gt;opBinary!&quot;in&quot;&lt;/code&gt; 와 &lt;code&gt;opBinaryRight!&quot;in&quot;&lt;/code&gt; 각각.</target>
        </trans-unit>
        <trans-unit id="9fe998aedd3f2332b372e13ad892064966a05a40" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;p[0 .. sz]&lt;/code&gt; is treated as an opaque range of memory assumed to be suitably managed by the caller. In particular, if p points into a GC-managed memory block, addRange does</source>
          <target state="translated">유의 &lt;code&gt;p[0 .. sz]&lt;/code&gt; 메모리 불투명 범위가 적절 호출자에 의해 관리된다고 가정으로 처리된다. 특히 p가 GC 관리 메모리 블록을 가리키는 경우 addRange는</target>
        </trans-unit>
        <trans-unit id="446697cde3fce65ea1af249f991e067ee7a7126c" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;remove&lt;/code&gt; does not change the length of the original range directly; instead, it returns the shortened range. If its return value is not assigned to the original range, the original range will retain its original length, though its contents will have changed:</source>
          <target state="translated">참고 &lt;code&gt;remove&lt;/code&gt; 직접 원래 범위의 길이를 변경하지 않는다; 대신 단축 된 범위를 반환합니다. 반환 값이 원래 범위에 할당되지 않은 경우 원래 범위는 원래 길이를 유지하지만 내용은 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="bd79b3c280c7d264b68b6cb7886d544b94d51de2" translate="yes" xml:space="preserve">
          <source>Note that DDoc comments may embed raw HTML, including &amp;lt;script&amp;gt; tags. Be careful when publishing or distributing rendered DDoc HTML generated from untrusted sources, as this may allow &lt;a href=&quot;https://en.wikipedia.org/wiki/Cross-site_scripting&quot;&gt; cross-site scripting&lt;/a&gt;.</source>
          <target state="translated">DDoc 주석은 &amp;lt;script&amp;gt; 태그를 포함하여 원시 HTML을 포함 할 수 있습니다. 신뢰할 수없는 소스에서 생성 된 렌더링 된 DDoc HTML을 게시하거나 배포 할 때 &lt;a href=&quot;https://en.wikipedia.org/wiki/Cross-site_scripting&quot;&gt;교차 사이트 스크립팅&lt;/a&gt; 이 허용 될 수 있으므로주의 하십시오 .</target>
        </trans-unit>
        <trans-unit id="0036754838cdb2ff3f71827ebae24962a2f81ac6" translate="yes" xml:space="preserve">
          <source>Note that a lone &lt;code&gt;extern&lt;/code&gt; declaration is used as a &lt;a href=&quot;declaration#extern&quot;&gt;storage class&lt;/a&gt;.</source>
          <target state="translated">혼자 참고 &lt;code&gt;extern&lt;/code&gt; 선언이로 사용되는 &lt;a href=&quot;declaration#extern&quot;&gt;저장 클래스&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d2f839e70486c3b3c3b2b7c5e6ccf35d0c885cd8" translate="yes" xml:space="preserve">
          <source>Note that all instantiations used in D code must be provided by linking to C++ object code or shared libraries containing the instantiations.</source>
          <target state="translated">D 코드에 사용 된 모든 인스턴스화는 인스턴스화를 포함하는 C ++ 오브젝트 코드 또는 공유 라이브러리에 링크하여 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="115633c56a2153ab4afb3286ea8d9b5f88ac33a5" translate="yes" xml:space="preserve">
          <source>Note that any &lt;a href=&quot;expression#FunctionLiteral&quot;&gt;&lt;i&gt;FunctionLiteral&lt;/i&gt;&lt;/a&gt; should be inlined when used in its declaration scope.</source>
          <target state="translated">선언 범위에서 사용될 때는 모든 &lt;a href=&quot;expression#FunctionLiteral&quot;&gt;&lt;i&gt;FunctionLiteral&lt;/i&gt;&lt;/a&gt; 이 인라인되어야합니다.</target>
        </trans-unit>
        <trans-unit id="912ae4118da5ae88c104ee54cbc7ed752a73a626" translate="yes" xml:space="preserve">
          <source>Note that because &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; does not currently support having a second value of 60 (as is sometimes done for leap seconds), if the date-time value does have a value of 60 for the seconds, it is treated as 59.</source>
          <target state="translated">&lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; 은 현재 두 번째 값 60 (가끔 윤초)을 지원하지 않기 때문에 날짜-시간 값의 초 값이 60 초이면 59로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="f6dc1eb334587071e774c1938dbe1cdce303845a" translate="yes" xml:space="preserve">
          <source>Note that built-in comparison operators operate on a &lt;a href=&quot;http://www.unicode.org/glossary/#code_unit&quot;&gt;code unit&lt;/a&gt; basis. The end result for valid strings is the same as that of &lt;a href=&quot;http://www.unicode.org/glossary/#code_point&quot;&gt;code point&lt;/a&gt; for &lt;a href=&quot;http://www.unicode.org/glossary/#code_point&quot;&gt;code point&lt;/a&gt; comparison as long as both strings are in the same &lt;a href=&quot;http://www.unicode.org/glossary/#normalization_form&quot;&gt;normalization form&lt;/a&gt;. Since normalization is a costly operation not suitable for language primitives it's assumed to be enforced by the user.</source>
          <target state="translated">내장 비교 연산자는 &lt;a href=&quot;http://www.unicode.org/glossary/#code_unit&quot;&gt;코드 단위&lt;/a&gt; 로 작동 합니다. 유효한 문자열에 대한 최종 결과는 동일하다 &lt;a href=&quot;http://www.unicode.org/glossary/#code_point&quot;&gt;코드 포인트&lt;/a&gt; 에 대한 &lt;a href=&quot;http://www.unicode.org/glossary/#code_point&quot;&gt;코드 포인트&lt;/a&gt; 만큼 모두 동일한 문자열에 비교로 &lt;a href=&quot;http://www.unicode.org/glossary/#normalization_form&quot;&gt;정규화 양식&lt;/a&gt; . 정규화는 언어 프리미티브에 적합하지 않은 비용이 많이 드는 작업이므로 사용자가 시행하는 것으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="249f6e17d1e87bfaf6fdd908c03dcfa20ff04194" translate="yes" xml:space="preserve">
          <source>Note that built-in comparison operators operate on a &lt;a href=&quot;https://www.unicode.org/glossary/#code_unit&quot;&gt;code unit&lt;/a&gt; basis. The end result for valid strings is the same as that of &lt;a href=&quot;https://www.unicode.org/glossary/#code_point&quot;&gt;code point&lt;/a&gt; for &lt;a href=&quot;https://www.unicode.org/glossary/#code_point&quot;&gt;code point&lt;/a&gt; comparison as long as both strings are in the same &lt;a href=&quot;https://www.unicode.org/glossary/#normalization_form&quot;&gt;normalization form&lt;/a&gt;. Since normalization is a costly operation not suitable for language primitives it's assumed to be enforced by the user.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b28b1e383cdef82230e59abe072f131bbfb679e" translate="yes" xml:space="preserve">
          <source>Note that by default an import expression will not compile unless you pass one or more paths via the &lt;b&gt;-J&lt;/b&gt; switch. This tells the compiler where it should look for the files to import. This is a security feature.</source>
          <target state="translated">기본적으로 가져 오기 표현식은 &lt;b&gt;-J&lt;/b&gt; 스위치 를 통해 하나 이상의 경로를 전달하지 않으면 컴파일되지 않습니다 . 이것은 가져올 파일을 찾아야하는 곳을 컴파일러에 알려줍니다. 이것은 보안 기능입니다.</target>
        </trans-unit>
        <trans-unit id="f443bcce9cbaf4b849f4fec4e4d01fac263bc259" translate="yes" xml:space="preserve">
          <source>Note that casting away a const qualifier and then mutating is undefined behavior, too, even when the referenced data is mutable. This is so that compilers and programmers can make assumptions based on const alone. For example, here it may be assumed that &lt;code&gt;f&lt;/code&gt; does not alter &lt;code&gt;x&lt;/code&gt;:</source>
          <target state="translated">const 한정자를 캐스트 한 다음 변경하는 것은 참조 된 데이터가 변경 가능한 경우에도 정의되지 않은 동작입니다. 이는 컴파일러와 프로그래머가 const 만 기반으로 가정 할 수 있도록하기위한 것입니다. 예를 들어, 여기서 &lt;code&gt;f&lt;/code&gt; 는 &lt;code&gt;x&lt;/code&gt; 를 변경하지 않는 것으로 가정 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a47b32f03830e6e76bd154f4549ffa1d22b1729d" translate="yes" xml:space="preserve">
          <source>Note that dimensions and indices appear in opposite orders. Dimensions in the &lt;a href=&quot;#declarations&quot;&gt;declaration&lt;/a&gt; are read right to left whereas indices are read left to right:</source>
          <target state="translated">치수와 색인은 반대 순서로 나타납니다. &lt;a href=&quot;#declarations&quot;&gt;선언의&lt;/a&gt; 차원은 오른쪽에서 왼쪽으로, 인덱스는 왼쪽에서 오른쪽으로 읽습니다.</target>
        </trans-unit>
        <trans-unit id="51822d7a0b3604134aaf4375e4432a320cf932bc" translate="yes" xml:space="preserve">
          <source>Note that directory separators and dots don't stop a meta-character from matching further portions of the path.</source>
          <target state="translated">디렉토리 구분 기호와 점은 메타 문자가 경로의 추가 부분과 일치하는 것을 막지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8e6cafb39971b4ab5ce4fa0e09eee1340357d767" translate="yes" xml:space="preserve">
          <source>Note that hypot(x, y), hypot(y, x) and hypot(x, -y) are equivalent.</source>
          <target state="translated">hypot (x, y), hypot (y, x) 및 hypot (x, -y)는 동일합니다.</target>
        </trans-unit>
        <trans-unit id="7d64153396681f56405a98e9a94c523f4293a81b" translate="yes" xml:space="preserve">
          <source>Note that if day overflow is allowed, and the date with the adjusted year/month overflows the number of days in the new month, then the month will be incremented by one, and the day set to the number of days overflowed. (e.g. if the day were 31 and the new month were June, then the month would be incremented to July, and the new day would be 1). If day overflow is not allowed, then the day will be set to the last valid day in the month (e.g. June 31st would become June 30th).</source>
          <target state="translated">일 오버플로가 허용되고 조정 된 연도 / 월이있는 날짜가 새 달의 일 수에 오버플로되면 월이 1 씩 증가하고 일이 오버플로 된 일 수로 설정됩니다. (예 : 날짜가 31 일이고 새 달이 6 월인 경우 해당 월은 7 월로 증가하고 새 날짜는 1이됩니다). 하루 오버플로가 허용되지 않으면 날짜는 해당 월의 마지막 유효 날짜로 설정됩니다 (예 : 6 월 31 일은 6 월 30 일이됩니다).</target>
        </trans-unit>
        <trans-unit id="ad6965a043b0f438ffed7d142808cac0176fe172" translate="yes" xml:space="preserve">
          <source>Note that if either end of the pipe has been passed to a child process, it will only be closed in the parent process. (What happens in the child process is platform dependent.)</source>
          <target state="translated">파이프의 한쪽 끝이 하위 프로세스로 전달 된 경우 상위 프로세스에서만 닫힙니다. 자식 프로세스에서 발생하는 일은 플랫폼에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="641b8bad6eb393e831a191963ea178efc311a8dd" translate="yes" xml:space="preserve">
          <source>Note that if iterating forward, &lt;code&gt;add!&quot;years&quot;()&lt;/code&gt; is called on the given time point, then &lt;code&gt;add!&quot;months&quot;()&lt;/code&gt;, and finally the duration is added to it. However, if iterating backwards, the duration is added first, then &lt;code&gt;add!&quot;months&quot;()&lt;/code&gt; is called, and finally &lt;code&gt;add!&quot;years&quot;()&lt;/code&gt; is called. That way, going backwards generates close to the same time points that iterating forward does, but since adding years and months is not entirely reversible (due to possible day overflow, regardless of whether &lt;code&gt;AllowDayOverflow.yes&lt;/code&gt; or &lt;code&gt;AllowDayOverflow.no&lt;/code&gt; is used), it can't be guaranteed that iterating backwards will give the same time points as iterating forward would have (even assuming that the end of the range is a time point which would be returned by the delegate when iterating forward from &lt;code&gt;begin&lt;/code&gt;).</source>
          <target state="translated">앞으로 반복하는 경우 주어진 시점에 &lt;code&gt;add!&quot;years&quot;()&lt;/code&gt; 를 호출 한 다음 &lt;code&gt;add!&quot;months&quot;()&lt;/code&gt; 를 추가 하고 마지막으로 지속 시간이 추가됩니다. 그러나 거꾸로 반복하면 기간이 먼저 추가 된 다음 &lt;code&gt;add!&quot;months&quot;()&lt;/code&gt; 가 호출되고 마지막으로 &lt;code&gt;add!&quot;years&quot;()&lt;/code&gt; 가 호출됩니다. 이렇게하면 뒤로 이동하면 앞으로 반복되는 시점과 거의 비슷한 시점이 생성되지만 &lt;code&gt;AllowDayOverflow.yes&lt;/code&gt; 또는 &lt;code&gt;AllowDayOverflow.no&lt;/code&gt; 에 관계없이 가능한 일 오버플로로 인해 연도 및 월을 추가하는 것이 완전히 되돌릴 수 없기 때문에거꾸로 반복하면 앞으로 반복되는 것과 동일한 시점을 제공한다고 보장 할 수 없습니다 (범위의 끝이 &lt;code&gt;begin&lt;/code&gt; 부터 앞으로 반복 할 때 델리게이트가 반환하는 시점이라고 가정하더라도 ) .</target>
        </trans-unit>
        <trans-unit id="9e24d541ab43dc77168136d6d96c2ec6d9cd50de" translate="yes" xml:space="preserve">
          <source>Note that if the extended unit test handler is set, this handler will be ignored.</source>
          <target state="translated">확장 단위 테스트 핸들러가 설정된 경우이 핸들러는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="09f09d5fb056a58012c263581462eef772037e06" translate="yes" xml:space="preserve">
          <source>Note that if you pass a &lt;code&gt;File&lt;/code&gt; object that is</source>
          <target state="translated">&lt;code&gt;File&lt;/code&gt; 객체를 전달하면</target>
        </trans-unit>
        <trans-unit id="ae86af4bef5c6e75e79e1cb92f184299576a6121" translate="yes" xml:space="preserve">
          <source>Note that in UTF-32, a code unit is a code point and is represented by the D &lt;code&gt;dchar&lt;/code&gt; type.</source>
          <target state="translated">UTF-32에서 코드 단위는 코드 포인트이며 D &lt;code&gt;dchar&lt;/code&gt; 유형으로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="b8fbb5eacdc4154a5078a8de39a2ed8fa4ea03d3" translate="yes" xml:space="preserve">
          <source>Note that in all cases, &lt;code&gt;arr&lt;/code&gt; is only evaluated once. Thus, an expression like &lt;code&gt;getArray()[1, 2..3, $-1]=c&lt;/code&gt; has the effect of:</source>
          <target state="translated">모든 경우에 &lt;code&gt;arr&lt;/code&gt; 은 한 번만 평가됩니다. 따라서 &lt;code&gt;getArray()[1, 2..3, $-1]=c&lt;/code&gt; 와 같은 표현식은 다음과 같은 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e006ced4b4958bf488f02e8e58d1bf92ac15c8b1" translate="yes" xml:space="preserve">
          <source>Note that in the above example the documentation comment uses the /++ ... +/ form so that /* ... */ can be used inside the code section.</source>
          <target state="translated">위 예제에서 문서 주석은 / ++ ... + / 형식을 사용하므로 코드 섹션 내에서 / * ... * /를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="13e74cc91272ec9b2bfdce2ef0b3c810ab9c9367" translate="yes" xml:space="preserve">
          <source>Note that in this example, the first &lt;code&gt;wait&lt;/code&gt; call will have no effect if the process has already terminated by the time &lt;code&gt;tryWait&lt;/code&gt; is called. In the opposite case, however, the &lt;code&gt;scope&lt;/code&gt; statement ensures that we always wait for the process if it hasn't terminated by the time we reach the end of the scope.</source>
          <target state="translated">이 예제에서 &lt;code&gt;tryWait&lt;/code&gt; 가 호출 될 &lt;code&gt;wait&lt;/code&gt; 프로세스가 이미 종료 된 경우 첫 번째 대기 호출은 적용되지 않습니다 . 그러나 반대의 경우, &lt;code&gt;scope&lt;/code&gt; 문은 범위의 끝에 도달 할 때까지 프로세스가 종료되지 않은 경우 항상 프로세스를 기다립니다.</target>
        </trans-unit>
        <trans-unit id="80bddd1ea633b51a86fe0e551b1923914b6691c0" translate="yes" xml:space="preserve">
          <source>Note that less should produce a strict ordering. That is, for two unequal elements &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;less(a, b) == !less(b, a)&lt;/code&gt;. &lt;code&gt;less(a, a)&lt;/code&gt; should always equal &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">덜 엄격한 순서로 생산해야합니다. 즉, 두 개의 같지 않은 요소 &lt;code&gt;a&lt;/code&gt; 및 &lt;code&gt;b&lt;/code&gt; 의 경우 &lt;code&gt;less(a, b) == !less(b, a)&lt;/code&gt; 입니다. &lt;code&gt;less(a, a)&lt;/code&gt; 는 항상 &lt;code&gt;false&lt;/code&gt; 와 같아야 합니다.</target>
        </trans-unit>
        <trans-unit id="70bbeb274fea359aae2d040c8c2296e15c498ac2" translate="yes" xml:space="preserve">
          <source>Note that like all conversions in std.datetime, this is a truncating conversion.</source>
          <target state="translated">std.datetime의 모든 변환과 마찬가지로 절단 변환입니다.</target>
        </trans-unit>
        <trans-unit id="44035a71fb744a3041456ec9cbdeceb03e62e357" translate="yes" xml:space="preserve">
          <source>Note that many file systems do not update the access time for files (generally for performance reasons), so there's a good chance that &lt;code&gt;timeLastAccessed&lt;/code&gt; will return the same value as &lt;code&gt;timeLastModified&lt;/code&gt;.</source>
          <target state="translated">많은 파일 시스템이 (일반적으로 성능상의 이유로) 파일의 액세스 시간을 업데이트하지 않으므로 &lt;code&gt;timeLastAccessed&lt;/code&gt; 가 timeLastModified 와 동일한 값을 반환 할 가능성이 &lt;code&gt;timeLastModified&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="36dba645f22a44df55465946f776825de4b8109a" translate="yes" xml:space="preserve">
          <source>Note that merely declaring &lt;code&gt;opCall&lt;/code&gt; automatically disables &lt;a href=&quot;struct#StructLiteral&quot;&gt;struct literal&lt;/a&gt; syntax. To avoid the limitation, you need to also declare a &lt;a href=&quot;struct#Struct-Constructor&quot;&gt;constructor&lt;/a&gt; so that it takes priority over &lt;code&gt;opCall&lt;/code&gt; in &lt;code&gt;Type(...)&lt;/code&gt; syntax.</source>
          <target state="translated">&lt;code&gt;opCall&lt;/code&gt; 을 선언 하면 &lt;a href=&quot;struct#StructLiteral&quot;&gt;구조체 리터럴&lt;/a&gt; 구문이 자동으로 비활성화됩니다 . 제한을 피하려면 &lt;code&gt;Type(...)&lt;/code&gt; 구문 에서 &lt;code&gt;opCall&lt;/code&gt; 보다 우선 순위를 갖도록 &lt;a href=&quot;struct#Struct-Constructor&quot;&gt;생성자를&lt;/a&gt; 선언해야 합니다.</target>
        </trans-unit>
        <trans-unit id="c19df3c7c698492518d32c4e38e6a62e58e238c9" translate="yes" xml:space="preserve">
          <source>Note that on Windows, both the backslash (&lt;code&gt;\&lt;/code&gt;) and the slash (&lt;code&gt;/&lt;/code&gt;) are in principle valid directory separators. This module treats them both on equal footing, but in cases where a</source>
          <target state="translated">Windows에서 백 슬래시 ( &lt;code&gt;\&lt;/code&gt; )와 슬래시 ( &lt;code&gt;/&lt;/code&gt; )는 원칙적으로 유효한 디렉토리 구분 기호입니다. 이 모듈은 둘 다 동일한 기반으로 처리하지만</target>
        </trans-unit>
        <trans-unit id="f0f97f096be5401c7d3f862a606a79cf1362201a" translate="yes" xml:space="preserve">
          <source>Note that only positive numbers can be integer powers of two. This function always return &lt;code&gt;false&lt;/code&gt; if &lt;code&gt;x&lt;/code&gt; is negative or zero.</source>
          <target state="translated">양수 만 2의 정수 제곱이 될 수 있습니다. 이 함수 는 &lt;code&gt;x&lt;/code&gt; 가 음수이거나 0 이면 항상 &lt;code&gt;false&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="eda6c02b923a2ed1d7a7c278f61d78d88a3639e6" translate="yes" xml:space="preserve">
          <source>Note that since scripts and blocks overlap the usual trick to disambiguate is used - to get a block use &lt;code&gt;unicode.InBlockName&lt;/code&gt;, to search a script use &lt;code&gt;unicode.ScriptName&lt;/code&gt;.</source>
          <target state="translated">스크립트와 블록이 겹치므로 일반적으로 명확하게하는 트릭이 사용됩니다. 블록을 사용하려면 &lt;code&gt;unicode.InBlockName&lt;/code&gt; 을 사용하고 스크립트를 검색하려면 &lt;code&gt;unicode.ScriptName&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="22cc19be60608f85b4e4dfefb9bd5fe35fe1487b" translate="yes" xml:space="preserve">
          <source>Note that some attributes can be inferred. For example:</source>
          <target state="translated">일부 속성은 유추 될 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f18ac40c792f74fb305df69994445a32bfe7fcb9" translate="yes" xml:space="preserve">
          <source>Note that the &quot;mode&quot; parameter can be one of DecodeMode.NONE (do not decode), DecodeMode.LOOSE (decode, but ignore errors), or DecodeMode.STRICT (decode, and throw a DecodeException in the event of an error).</source>
          <target state="translated">&quot;mode&quot;매개 변수는 DecodeMode.NONE (디코딩하지 않음), DecodeMode.LOOSE (디코딩하지만 오류 무시) 또는 DecodeMode.STRICT (디코딩 및 오류 발생시 DecodeException 발생) 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b273c3d2c6f44162b3727ab0ea7ead816fe1384c" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;extern (C++, &lt;/code&gt;ns&lt;code&gt;)&lt;/code&gt; linkage attribute affects only the ABI (name mangling and calling convention) of these declarations. Importing them follows the usual &lt;a href=&quot;spec/module&quot;&gt;D module import semantics&lt;/a&gt;.</source>
          <target state="translated">있습니다 &lt;code&gt;extern (C++, &lt;/code&gt; NS &lt;code&gt;)&lt;/code&gt; 연결 속성이 선언 만 ABI (이름 맹 글링 및 호출 규칙을)에 영향을 미친다. 가져 오기는 일반적인 &lt;a href=&quot;spec/module&quot;&gt;D 모듈 가져 오기 의미를&lt;/a&gt; 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="c9454f9715d5041deb694a9a0e0b28ae86a7f41f" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;strip&lt;/code&gt; and &lt;code&gt;stripRight&lt;/code&gt; functions require the range to be a &lt;a href=&quot;#BidirectionalRange&quot;&gt;&lt;code&gt;BidirectionalRange&lt;/code&gt;&lt;/a&gt; range.</source>
          <target state="translated">있습니다 &lt;code&gt;strip&lt;/code&gt; 과 &lt;code&gt;stripRight&lt;/code&gt; 기능의 범위를 필요는 할 수 &lt;a href=&quot;#BidirectionalRange&quot;&gt; &lt;code&gt;BidirectionalRange&lt;/code&gt; 의&lt;/a&gt; 범위.</target>
        </trans-unit>
        <trans-unit id="105b64c754d996e053dd0d505eb33e6917a0a7c3" translate="yes" xml:space="preserve">
          <source>Note that the above restrictions apply only to expressions which are actually executed. For example:</source>
          <target state="translated">위의 제한 사항은 실제로 실행되는 식에만 적용됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c1a0644d2f3551c55090ce3b1a4bb396a6220a01" translate="yes" xml:space="preserve">
          <source>Note that the file attributes on Windows and POSIX systems are completely different. On Windows, they're what is returned by &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/aa364944(v=vs.85).aspx&quot;&gt; GetFileAttributes&lt;/a&gt;, whereas on POSIX systems, they're the &lt;code&gt;st_mode&lt;/code&gt; value which is part of the &lt;code&gt;stat struct&lt;/code&gt; gotten by calling the &lt;a href=&quot;http://en.wikipedia.org/wiki/Stat_%28Unix%29&quot;&gt;&lt;code&gt;stat&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">Windows 및 POSIX 시스템의 파일 속성은 완전히 다릅니다. Windows에서는 &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/aa364944(v=vs.85).aspx&quot;&gt;GetFileAttributes&lt;/a&gt; 에 의해 반환되는 반면 POSIX 시스템에서는 &lt;a href=&quot;http://en.wikipedia.org/wiki/Stat_%28Unix%29&quot;&gt; &lt;code&gt;stat&lt;/code&gt; &lt;/a&gt; 함수 를 호출하여 얻은 &lt;code&gt;stat struct&lt;/code&gt; 일부인 &lt;code&gt;st_mode&lt;/code&gt; 값입니다 .</target>
        </trans-unit>
        <trans-unit id="46c55fbb6b7eceb962d249400baa96d299fa72d9" translate="yes" xml:space="preserve">
          <source>Note that the file attributes on Windows and POSIX systems are completely different. On Windows, they're what is returned by &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/aa364944(v=vs.85).aspx&quot;&gt; GetFileAttributes&lt;/a&gt;, whereas on POSIX systems, they're the &lt;code&gt;st_mode&lt;/code&gt; value which is part of the &lt;code&gt;stat struct&lt;/code&gt; gotten by calling the &lt;a href=&quot;https://en.wikipedia.org/wiki/Stat_%28Unix%29&quot;&gt;&lt;code&gt;stat&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="801e5cbcd36f40a4077d34bcc94b269428800929" translate="yes" xml:space="preserve">
          <source>Note that the file attributes on Windows and POSIX systems are completely different. On, Windows, they're what is returned by &lt;code&gt;GetFileAttributes&lt;/code&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/aa364944(v=vs.85).aspx&quot;&gt;GetFileAttributes&lt;/a&gt; Whereas, an POSIX systems, they're the &lt;code&gt;st_mode&lt;/code&gt; value which is part of the &lt;code&gt;stat&lt;/code&gt; struct gotten by calling &lt;code&gt;stat&lt;/code&gt;.</source>
          <target state="translated">Windows 및 POSIX 시스템의 파일 속성은 완전히 다릅니다. 윈도우,에, 그들은에 의해 반환되는 어떤 것 &lt;code&gt;GetFileAttributes&lt;/code&gt; 와의&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/aa364944(v=vs.85).aspx&quot;&gt;GetFileAttributes와&lt;/a&gt; POSIX 시스템, 반면에, 그들이있어 &lt;code&gt;st_mode&lt;/code&gt; 의 일부 값 &lt;code&gt;stat&lt;/code&gt; 호출하여받은 구조체 &lt;code&gt;stat&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b2144602c7490f494217ef98db15e23f7acd7351" translate="yes" xml:space="preserve">
          <source>Note that the file attributes on Windows and POSIX systems are completely different. On, Windows, they're what is returned by &lt;code&gt;GetFileAttributes&lt;/code&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/aa364944(v=vs.85).aspx&quot;&gt;GetFileAttributes&lt;/a&gt; Whereas, an POSIX systems, they're the &lt;code&gt;st_mode&lt;/code&gt; value which is part of the &lt;code&gt;stat&lt;/code&gt; struct gotten by calling &lt;code&gt;stat&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f56ed4aac2dbf1ced449f72f5d0793404a040ac" translate="yes" xml:space="preserve">
          <source>Note that the file attributes on Windows and Posix systems are completely different. On Windows, they're what is returned by &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/aa364944(v=vs.85).aspx&quot;&gt; GetFileAttributes&lt;/a&gt;, whereas on Posix systems, they're the &lt;code&gt;st_mode&lt;/code&gt; value which is part of the &lt;code&gt;stat struct&lt;/code&gt; gotten by calling the &lt;a href=&quot;http://en.wikipedia.org/wiki/Stat_%28Unix%29&quot;&gt;&lt;code&gt;stat&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">Windows 및 Posix 시스템의 파일 속성은 완전히 다릅니다. Windows에서는 &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/aa364944(v=vs.85).aspx&quot;&gt;GetFileAttributes&lt;/a&gt; 가 반환하는 반면 Posix 시스템에서는 &lt;a href=&quot;http://en.wikipedia.org/wiki/Stat_%28Unix%29&quot;&gt; &lt;code&gt;stat&lt;/code&gt; &lt;/a&gt; 함수 를 호출하여 얻은 &lt;code&gt;stat struct&lt;/code&gt; 일부인 &lt;code&gt;st_mode&lt;/code&gt; 값입니다 .</target>
        </trans-unit>
        <trans-unit id="58b3a122bcf863a6e06a86f361dfc75dff88483d" translate="yes" xml:space="preserve">
          <source>Note that the file attributes on Windows and Posix systems are completely different. On, Windows, they're what is returned by &lt;code&gt;GetFileAttributes&lt;/code&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/aa364944(v=vs.85).aspx&quot;&gt;GetFileAttributes&lt;/a&gt; Whereas, an Posix systems, they're the &lt;code&gt;st_mode&lt;/code&gt; value which is part of the &lt;code&gt;stat&lt;/code&gt; struct gotten by calling &lt;code&gt;stat&lt;/code&gt;.</source>
          <target state="translated">Windows 및 Posix 시스템의 파일 속성은 완전히 다릅니다. 윈도우,에, 그들은에 의해 반환되는 어떤 것 &lt;code&gt;GetFileAttributes&lt;/code&gt; 와의&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/aa364944(v=vs.85).aspx&quot;&gt;GetFileAttributes와&lt;/a&gt; POSIX 시스템, 반면에, 그들이있어 &lt;code&gt;st_mode&lt;/code&gt; 의 일부 값 &lt;code&gt;stat&lt;/code&gt; 호출하여받은 구조체 &lt;code&gt;stat&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ac0d5de26025de020503b24834bbc1e01d074910" translate="yes" xml:space="preserve">
          <source>Note that the number of days in the months or how far into the month either &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; is is irrelevant. It is the difference in the month property combined with the difference in years * 12. So, for instance, December 31st and January 1st are one month apart just as December 1st and January 31st are one month apart.</source>
          <target state="translated">월의 &lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 수 또는 날짜 와 월의 거리는 관련이 없습니다. 월 속성과 연도 * 12의 차이를 합한 것입니다. 예를 들어, 12 월 31 일과 1 월 1 일은 12 월 1 일과 1 월 31 일이 1 개월 간격 인 것처럼 1 개월 간격입니다.</target>
        </trans-unit>
        <trans-unit id="3b7532f9c55c33a0ea3ab36928dfa00325e43b78" translate="yes" xml:space="preserve">
          <source>Note that the number of days in the months or how far into the month either date is is irrelevant. It is the difference in the month property combined with the difference in years * 12. So, for instance, December 31st and January 1st are one month apart just as December 1st and January 31st are one month apart.</source>
          <target state="translated">월의 일 수 또는 어느 한 달의 날짜와는 관계가 없습니다. 월 속성과 연도 * 12의 차이를 합한 것입니다. 예를 들어, 12 월 31 일과 1 월 1 일은 12 월 1 일과 1 월 31 일이 1 개월 간격 인 것처럼 1 개월 간격입니다.</target>
        </trans-unit>
        <trans-unit id="7def91aa85d70e11e052a5c942f5159d4bbd2f46" translate="yes" xml:space="preserve">
          <source>Note that the number of digits in the fractional seconds varies with the number of fractional seconds. It's a maximum of 7 (which would be hnsecs), but only has as many as are necessary to hold the correct value (so no trailing zeroes), and if there are no fractional seconds, then there is no decimal point.</source>
          <target state="translated">분수 초의 자릿수는 분수 초의 수에 따라 다릅니다. 최대 7 (hnsecs)이지만 올바른 값을 유지하는 데 필요한만큼만 (따라서 0이 없음) 소수 자릿수가없는 경우 소수점이 없습니다.</target>
        </trans-unit>
        <trans-unit id="ed9272ebf234b02f1f0545ae76356a3b0ec23a8c" translate="yes" xml:space="preserve">
          <source>Note that the parameter to &lt;code&gt;opEquals&lt;/code&gt; is of type &lt;code&gt;Object&lt;/code&gt;, not the type of the class in which it is defined.</source>
          <target state="translated">의 파라미터합니다 &lt;code&gt;opEquals&lt;/code&gt; 는 타입이다 &lt;code&gt;Object&lt;/code&gt; ,이 정의 된 클래스의하지 유형.</target>
        </trans-unit>
        <trans-unit id="3bcdcd90f9f0d2f4085e68b75a145415970ef1fe" translate="yes" xml:space="preserve">
          <source>Note that the parameter to the generated &lt;code&gt;opAssign&lt;/code&gt; is passed by value, which means that the postblit is going to be called (if it is defined) in both of the above situations before entering the body of &lt;code&gt;opAssign&lt;/code&gt;. The assignments in the above generated function bodies are blit expressions, so they can be regarded as &lt;code&gt;memcpy&lt;/code&gt;s (&lt;code&gt;opAssign&lt;/code&gt; is not called as this will result in an infinite recursion; the postblit is not called because it has already been called when the parameter was passed by value).</source>
          <target state="translated">상기 생성 된 파라미터에 유의 &lt;code&gt;opAssign&lt;/code&gt; 가 (이 정의되어있는 경우) postblit은 본문에 들어가기 전에 상기 상황 모두에 호출 할 것이라는 것을 의미하는 값에 의해 전달된다 &lt;code&gt;opAssign&lt;/code&gt; 를 . 위에서 생성 된 함수 본문의 할당은 블리트 표현식이므로 &lt;code&gt;memcpy&lt;/code&gt; 로 간주 될 수 있습니다 ( &lt;code&gt;opAssign&lt;/code&gt; 은 무한 재귀를 초래하므로 호출되지 않습니다. postblit은 매개 변수가 전달 될 때 이미 호출 되었기 때문에 호출되지 않습니다) 값으로).</target>
        </trans-unit>
        <trans-unit id="cfca2dafa198ccff289d808ee6e617972ea3da55" translate="yes" xml:space="preserve">
          <source>Note that the precision of StopWatch differs from system to system. It is impossible for it to be the same for all systems, since the precision of the system clock and other system-dependent and situation-dependent factors (such as the overhead of a context switch between threads) varies from system to system and can affect StopWatch's accuracy.</source>
          <target state="translated">StopWatch의 정밀도는 시스템마다 다릅니다. 시스템 클럭의 정밀도 및 시스템 종속 및 상황 종속 요인 (예 : 스레드 간 컨텍스트 전환 오버 헤드와 같은)이 시스템마다 다르고 영향을 줄 수 있기 때문에 모든 시스템에서 동일하지는 않습니다. 스톱워치의 정확성.</target>
        </trans-unit>
        <trans-unit id="013108e934bb36b82a19ea994bcf87182beae597" translate="yes" xml:space="preserve">
          <source>Note that the result is always mutable even if the original type was const or immutable. In order to retain the constness, use &lt;a href=&quot;std_traits#Signed&quot;&gt;&lt;code&gt;std.traits.Signed&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">원래 유형이 const이거나 불변 인 경우에도 결과는 항상 변경 가능합니다. 불일치를 유지하려면 std.traits.Signed를 사용 &lt;a href=&quot;std_traits#Signed&quot;&gt; &lt;code&gt;std.traits.Signed&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b9fc2a3abef27f02d267911870b28cef9c5fce9d" translate="yes" xml:space="preserve">
          <source>Note that the result is always mutable even if the original type was const or immutable. In order to retain the constness, use &lt;a href=&quot;std_traits#Unsigned&quot;&gt;&lt;code&gt;std.traits.Unsigned&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">원래 유형이 const이거나 불변 인 경우에도 결과는 항상 변경 가능합니다. 불변성을 유지하려면 std.traits.Unsigned를 사용 &lt;a href=&quot;std_traits#Unsigned&quot;&gt; &lt;code&gt;std.traits.Unsigned&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="97a6bd409b0edfaeec19001e1e4b496e335537bd" translate="yes" xml:space="preserve">
          <source>Note that the template mixin is evaluated in the context of its instantiation, not declaration. If this is a problem, the template mixin can use local imports, or have the member functions forward to the actual functions.</source>
          <target state="translated">템플릿 믹스 인은 선언이 아닌 인스턴스화의 맥락에서 평가됩니다. 이것이 문제인 경우, 템플리트 믹스 인은 로컬 가져 오기를 사용하거나 멤버 함수를 실제 함수로 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="90520f60d5001fa0deb6ccd61eaac980e05c6894" translate="yes" xml:space="preserve">
          <source>Note that the time zone is ignored. Only the internal std times (which are in UTC) are compared.</source>
          <target state="translated">시간대는 무시됩니다. 내부 표준시 (UTC 기준) 만 비교됩니다.</target>
        </trans-unit>
        <trans-unit id="347830fe2dab68c08b8a8c382421a6b59d1a9414" translate="yes" xml:space="preserve">
          <source>Note that there is no trailing &lt;code&gt;;&lt;/code&gt; after the closing &lt;code&gt;}&lt;/code&gt; of the class definition. It is also not possible to declare a variable var like:</source>
          <target state="translated">후행은 없습니다 &lt;code&gt;;&lt;/code&gt; 클래스 정의를 닫은 후 &lt;code&gt;}&lt;/code&gt; . 변수 var를 다음과 같이 선언 할 수도 없습니다.</target>
        </trans-unit>
        <trans-unit id="e2ce7a1307c873540e8c4568f17f9cb7d94fa592" translate="yes" xml:space="preserve">
          <source>Note that these specialized summing algorithms execute more primitive operations than vanilla summation. Therefore, if in certain cases maximum speed is required at expense of precision, one can use &lt;code&gt;fold!((a, b) =&amp;gt; a + b)(r, 0)&lt;/code&gt;, which is not specialized for summation.</source>
          <target state="translated">이러한 특수 합산 알고리즘은 바닐라 합산보다 더 많은 원시 연산을 실행합니다. 따라서 특정 경우 정밀도를 희생하여 최대 속도가 필요한 경우 &lt;code&gt;fold!((a, b) =&amp;gt; a + b)(r, 0)&lt;/code&gt; 있으며 이는 합산에 특화되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="66ceba8ad81e64e59b5bf6adfb9a8515853d4ada" translate="yes" xml:space="preserve">
          <source>Note that this class, like &lt;code&gt;Nspace&lt;/code&gt;, matches only one identifier part of a namespace. For the namespace &lt;code&gt;&quot;foo::bar&quot;&lt;/code&gt;, the will be a &lt;code&gt;CPPNamespaceDeclaration&lt;/code&gt; with its &lt;code&gt;ident&lt;/code&gt; set to &lt;code&gt;&quot;bar&quot;&lt;/code&gt;, and its &lt;code&gt;namespace&lt;/code&gt; field pointing to another &lt;code&gt;CPPNamespaceDeclaration&lt;/code&gt; with its &lt;code&gt;ident&lt;/code&gt; set to &lt;code&gt;&quot;foo&quot;&lt;/code&gt;.</source>
          <target state="translated">이 클래스는 &lt;code&gt;Nspace&lt;/code&gt; 와 마찬가지로 네임 스페이스의 한 식별자 부분과 만 일치합니다. 네임 스페이스를 들어 &lt;code&gt;&quot;foo::bar&quot;&lt;/code&gt; 는이 될 것입니다 &lt;code&gt;CPPNamespaceDeclaration&lt;/code&gt; 그와 &lt;code&gt;ident&lt;/code&gt; 로 설정 &lt;code&gt;&quot;bar&quot;&lt;/code&gt; , 그 &lt;code&gt;namespace&lt;/code&gt; 다른 필드를 가리키는 &lt;code&gt;CPPNamespaceDeclaration&lt;/code&gt; 그와 &lt;code&gt;ident&lt;/code&gt; 로 설정 &lt;code&gt;&quot;foo&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c21c11195a0d1c7a31fd4780e9a08c186e540bb2" translate="yes" xml:space="preserve">
          <source>Note that this function can be used in conjunction with logGamma(x) to evaluate gamma for very large values of x.</source>
          <target state="translated">이 함수는 logGamma (x)와 함께 사용하여 x의 매우 큰 값에 대한 감마를 평가할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0bf2881edd5d472dbfdc4275277886cc17c5a866" translate="yes" xml:space="preserve">
          <source>Note that this function does not resolve symbolic links.</source>
          <target state="translated">이 기능은 심볼릭 링크를 해결하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="21e585872c0d53f25db7173b27751038000ea37f" translate="yes" xml:space="preserve">
          <source>Note that this includes the non-character code points U+FFFE and U+FFFF, since these are valid code points (even though they are not valid characters).</source>
          <target state="translated">여기에는 문자가 아닌 코드 포인트 U + FFFE 및 U + FFFF가 포함됩니다 (유효 문자는 아니지만).</target>
        </trans-unit>
        <trans-unit id="9e54e3f648dff697f15989171e1f17afab1f263c" translate="yes" xml:space="preserve">
          <source>Note that unary &lt;code&gt;-&lt;/code&gt; is considered to overflow if &lt;code&gt;T&lt;/code&gt; is a signed integral of 32 or 64 bits and is equal to the most negative value. This is because that value has no positive negation.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 가 32 또는 64 비트의 부호있는 정수이고 가장 음의 값과 같으면 단항 &lt;code&gt;-&lt;/code&gt; 가 오버플로 된 것으로 간주됩니다 . 그 가치에는 긍정적 인 부정이 없기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="e22da1f09943bc1bd2194eb52462e47725243938" translate="yes" xml:space="preserve">
          <source>Note that using immutable on the left hand side of a method does not apply to the return type:</source>
          <target state="translated">메소드의 왼쪽에서 불변을 사용하는 것은 리턴 유형에 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="918640f380644b341ffcec2196c90d882dd46a65" translate="yes" xml:space="preserve">
          <source>Note that using the &lt;code&gt;~user&lt;/code&gt; syntax may give different values from just &lt;code&gt;~&lt;/code&gt; if the environment variable doesn't match the value stored in the user database.</source>
          <target state="translated">&lt;code&gt;~user&lt;/code&gt; 구문 을 사용하면 환경 변수가 사용자 데이터베이스에 저장된 값과 일치하지 않으면 &lt;code&gt;~&lt;/code&gt; 와 다른 값이 제공 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d08e2d88ab7d380019dd445d33fece11f314cccc" translate="yes" xml:space="preserve">
          <source>Note that when &lt;code&gt;const&lt;/code&gt; and &lt;code&gt;immutable&lt;/code&gt; are used to explicitly qualify a postblit as in &lt;code&gt;this(this) const immutable;&lt;/code&gt; or &lt;code&gt;const immutable this(this);&lt;/code&gt; - the order in which the qualifiers are declared does not matter - the compiler generates a conflicting attribute error, however declaring the struct as &lt;code&gt;const&lt;/code&gt;/&lt;code&gt;immutable&lt;/code&gt; and the postblit as &lt;code&gt;immutable&lt;/code&gt;/&lt;code&gt;const&lt;/code&gt; achieves the effect of applying both qualifiers to the postblit. In both cases the postblit is qualified with the more restrictive qualifier, which is &lt;code&gt;immutable&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; 와 &lt;code&gt;immutable&lt;/code&gt; 을 사용하여 &lt;code&gt;this(this) const immutable;&lt;/code&gt; 에서와 같이 postblit을 명시 적으로 규정 할 때주의하십시오 . 또는 &lt;code&gt;const immutable this(this);&lt;/code&gt; -한정자가 선언되는 순서는 중요하지 않습니다-컴파일러는 충돌하는 속성 오류를 생성하지만 구조체를 &lt;code&gt;const&lt;/code&gt; / &lt;code&gt;immutable&lt;/code&gt; 로 선언 하고 postblit을 &lt;code&gt;immutable&lt;/code&gt; / &lt;code&gt;const&lt;/code&gt; 로 선언하면 두 한정자를 포스트 블릿에 적용하는 효과를 얻습니다. 두 경우 postblit은 더 제한 규정과 자격 &lt;code&gt;immutable&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="db6f486afc782e7d8d40d6176273ffd0a92d6589" translate="yes" xml:space="preserve">
          <source>Note that when rolling msecs, usecs or hnsecs, they all add up to a second. So, for example, rolling 1000 msecs is exactly the same as rolling 100,000 usecs.</source>
          <target state="translated">msecs, usecs 또는 hnsecs를 롤링 할 때 모두 1 초가 걸립니다. 예를 들어 1000msec 롤링은 100,000 회 롤링과 정확히 동일합니다.</target>
        </trans-unit>
        <trans-unit id="72c082db4e1807b855106dcd51e06ae543e5a663" translate="yes" xml:space="preserve">
          <source>Note that while &lt;code&gt;collectException&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;collectException&lt;/code&gt; 동안</target>
        </trans-unit>
        <trans-unit id="a633cde16fe0b35262b02b2b40dcd83110f14198" translate="yes" xml:space="preserve">
          <source>Note that while &lt;code&gt;collectExceptionMsg&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;collectExceptionMsg&lt;/code&gt; 동안</target>
        </trans-unit>
        <trans-unit id="fb0030eca3940263d99b92bc47097ce8c0e84a35" translate="yes" xml:space="preserve">
          <source>Note that your function will be called for both start tags and empty tags. That is, we make no distinction between &amp;lt;br&amp;gt;&amp;lt;/br&amp;gt; and &amp;lt;br/&amp;gt;.</source>
          <target state="translated">시작 태그와 빈 태그 모두에 대해 함수가 호출됩니다. 즉, &amp;lt;br&amp;gt; &amp;lt;/br&amp;gt;와 &amp;lt;br/&amp;gt;를 구분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9b9f74a3e01b56fbe0b6285c40c17c1416f204c3" translate="yes" xml:space="preserve">
          <source>Note that, currently, foreach (c:codePoints(s)) is superior to foreach (c;s) in that the latter will fall over on encountering U+FFFF.</source>
          <target state="translated">현재, foreach (c : codePoints)는 foreach (c; s)보다 U + FFFF 발생시 넘어집니다.</target>
        </trans-unit>
        <trans-unit id="1b30eb201d301a49862249a5a39c27627b493d38" translate="yes" xml:space="preserve">
          <source>Note that, since &lt;code&gt;functions&lt;/code&gt; are assumed to be associative, additional optimizations are made to the serial portion of the reduction algorithm. These take advantage of the instruction level parallelism of modern CPUs, in addition to the thread-level parallelism that the rest of this module exploits. This can lead to better than linear speedups relative to &lt;a href=&quot;std_algorithm_iteration#reduce&quot;&gt;&lt;code&gt;std.algorithm.iteration.reduce&lt;/code&gt;&lt;/a&gt;, especially for fine-grained benchmarks like dot products.</source>
          <target state="translated">때문에, 그 주 &lt;code&gt;functions&lt;/code&gt; 연관 것으로 가정 추가적인 최적화가 감소 알고리즘의 일련 부로 이루어진다. 이것들은이 모듈의 나머지가 이용하는 스레드 레벨 병렬 처리 외에 최신 CPU의 명령어 레벨 병렬 처리를 이용합니다. 이는 특히 도트 제품과 같은 세분화 된 벤치 마크 에서 &lt;a href=&quot;std_algorithm_iteration#reduce&quot;&gt; &lt;code&gt;std.algorithm.iteration.reduce&lt;/code&gt; 에&lt;/a&gt; 비해 선형 속도 향상보다 더 우수 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3b050c108011d5c83aae9e488ace3162ed4d3888" translate="yes" xml:space="preserve">
          <source>Note the double asterisks in the example above. This is because the list is inside a documentation comment that is delimited with asterisks, so the initial asterisk is considered part of the documentation comment, not a list item. This is even true when other lines don't start with an asterisk:</source>
          <target state="translated">위의 예에서 이중 별표에 유의하십시오. 이는 목록이 별표로 구분 된 설명서 주석 안에 있기 때문에 초기 별표는 목록 항목이 아니라 설명서 주석의 일부로 간주되기 때문입니다. 다른 줄이 별표로 시작하지 않는 경우에도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="77a42fc96213541cea82021eba50295b8b065cb7" translate="yes" xml:space="preserve">
          <source>Note there is also LARGE version which adds large file support for platforms which have larger off_t sizes. See MAXFILESIZE_LARGE below.</source>
          <target state="translated">off_t 크기가 더 큰 플랫폼에 대해 큰 파일 지원을 추가하는 LARGE 버전도 있습니다. 아래 MAXFILESIZE_LARGE를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="14c50f05b7dc80a74871bb2afa89104fae9ab95b" translate="yes" xml:space="preserve">
          <source>Note there is also a LARGE version of this key which uses off_t types, allowing for large file offsets on platforms which use larger-than-32-bit off_t's. Look below for RESUME_FROM_LARGE.</source>
          <target state="translated">off_t 유형을 사용하는이 키에는 LARGE 버전도 있으며 32 비트보다 큰 off_t를 사용하는 플랫폼에서 큰 파일 오프셋을 허용합니다. RESUME_FROM_LARGE는 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="83423c198b6099edba08f185f940042d5dba3b79" translate="yes" xml:space="preserve">
          <source>Note:</source>
          <target state="translated">Note:</target>
        </trans-unit>
        <trans-unit id="474b920eed351c384de7672326f5263e20997572" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;static opCall&lt;/code&gt; can be used to simulate struct constructors with no arguments, but this is not recommended practice. Instead, the preferred solution is to use a factory function to create struct instances.</source>
          <target state="translated">참고 : &lt;code&gt;static opCall&lt;/code&gt; 을 사용하여 인수없이 구조체 생성자를 시뮬레이션 할 수 있지만 권장되지는 않습니다. 대신 선호되는 솔루션은 팩토리 함수를 사용하여 구조체 인스턴스를 만드는 것입니다.</target>
        </trans-unit>
        <trans-unit id="b6757b7ec836c02379870ff926a56d3f1c2de6cf" translate="yes" xml:space="preserve">
          <source>Note: Although the definition is straightforward, a few subtleties exist related to function literals. In the statement &lt;code&gt;return (() =&amp;gt; x + f())() * g();&lt;/code&gt;, the full expression of &lt;code&gt;f()&lt;/code&gt; is &lt;code&gt;x + f()&lt;/code&gt;, not the expression passed to &lt;code&gt;return&lt;/code&gt;. This is because the parent of &lt;code&gt;x + f()&lt;/code&gt; has function literal type, not expression type.</source>
          <target state="translated">참고 : 정의는 간단하지만 함수 리터럴과 관련된 몇 가지 미묘한 점이 있습니다. 명령문에서 &lt;code&gt;return (() =&amp;gt; x + f())() * g();&lt;/code&gt; &lt;code&gt;f()&lt;/code&gt; 의 전체 표현식 은 &lt;code&gt;x + f()&lt;/code&gt; 이며 &lt;code&gt;return&lt;/code&gt; 에 전달 된 표현식이 아닙니다 . &lt;code&gt;x + f()&lt;/code&gt; 의 부모는 표현식 유형이 아닌 함수 리터럴 유형을 가지고 있기 때문 입니다.</target>
        </trans-unit>
        <trans-unit id="8786381c9a210d5e82b40aa9d7e16a168f4d8ef9" translate="yes" xml:space="preserve">
          <source>Note: An intuition behind these rules is that destructors of temporaries are deferred to the end of full expression and in reverse order of construction, with the exception that the right-hand side of &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt; are considered their own full expressions even when part of larger expressions.</source>
          <target state="translated">참고 :이 규칙의 직관은 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 및 &lt;code&gt;||&lt;/code&gt; 큰 표현의 일부 일지라도 자신의 완전한 표현으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="aa74ddd8151c0e8c6ba91a90babe4e4a7f4d559e" translate="yes" xml:space="preserve">
          <source>Note: Hex Strings are &lt;b&gt;deprecated&lt;/b&gt;. Please use &lt;a href=&quot;https://dlang.org/phobos/std_conv.html#hexString&quot;&gt;&lt;code&gt;std.conv.hexString&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">참고 : 16 진 문자열은 &lt;b&gt;더 이상 사용되지 않습니다&lt;/b&gt; . 사용하십시오 &lt;a href=&quot;https://dlang.org/phobos/std_conv.html#hexString&quot;&gt; &lt;code&gt;std.conv.hexString&lt;/code&gt; 을&lt;/a&gt; 대신.</target>
        </trans-unit>
        <trans-unit id="ab44e664d0fb73e17b2d788f273100f8a9756fcb" translate="yes" xml:space="preserve">
          <source>Note: Rvalues include all literals, special value keywords such as &lt;code&gt;__FILE__&lt;/code&gt; and &lt;code&gt;__LINE__&lt;/code&gt;, &lt;code&gt;enum&lt;/code&gt; values, and the result of expressions not defined as lvalues above.</source>
          <target state="translated">참고 : Rvalue에는 모든 리터럴, &lt;code&gt;__FILE__&lt;/code&gt; 및 &lt;code&gt;__LINE__&lt;/code&gt; 과 같은 특수 값 키워드 , &lt;code&gt;enum&lt;/code&gt; 값 및 lvalue로 정의되지 않은 표현식의 결과가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="065a513243cfbfb6ba132105f812e5a75641d676" translate="yes" xml:space="preserve">
          <source>Note: The &lt;code&gt;return&lt;/code&gt; attribute is currently only enforced by &lt;code&gt;dmd&lt;/code&gt; when the &lt;code&gt;-dip25&lt;/code&gt; switch is passed.</source>
          <target state="translated">참고 : &lt;code&gt;return&lt;/code&gt; 속성은 현재 &lt;code&gt;-dip25&lt;/code&gt; 스위치가 전달 될 때 &lt;code&gt;dmd&lt;/code&gt; 에 의해서만 시행됩니다 .</target>
        </trans-unit>
        <trans-unit id="93747fb439b767f7416b2ece9f49c1ec18c64ad0" translate="yes" xml:space="preserve">
          <source>Note: The ternary expression</source>
          <target state="translated">참고 : 삼항식</target>
        </trans-unit>
        <trans-unit id="ee4e59bed66f02dc6f460df8e2185e7345a20b4e" translate="yes" xml:space="preserve">
          <source>Note: for 32 bit gcc, it's &lt;code&gt;long long&lt;/code&gt; instead of &lt;code&gt;long&lt;/code&gt;.</source>
          <target state="translated">참고 : 32 비트 gcc의 경우 &lt;code&gt;long long&lt;/code&gt; 대신 &lt;code&gt;long&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="3f5230b128c9da8ca00898450d16b6f3d9dd7622" translate="yes" xml:space="preserve">
          <source>Notes to implementors</source>
          <target state="translated">구현 자 주</target>
        </trans-unit>
        <trans-unit id="f7c7e2b89a99758727779c65c16d4c60e658ae08" translate="yes" xml:space="preserve">
          <source>Notes to users</source>
          <target state="translated">사용자 참고 사항</target>
        </trans-unit>
        <trans-unit id="011fcd843da8c529c1fa3883c7f45aba859be2bf" translate="yes" xml:space="preserve">
          <source>Nothrow Functions</source>
          <target state="translated">노스로 기능</target>
        </trans-unit>
        <trans-unit id="bd69d0c378869da8300879aa2418a7369c07459a" translate="yes" xml:space="preserve">
          <source>Nothrow functions are covariant with throwing ones.</source>
          <target state="translated">Nothrow 함수는 던지는 함수와 공변량입니다.</target>
        </trans-unit>
        <trans-unit id="621c7bb048303809630a2eae2cfb3587611e1c2f" translate="yes" xml:space="preserve">
          <source>Nothrow functions can only throw exceptions derived from class</source>
          <target state="translated">Nothrow 함수는 클래스에서 파생 된 예외 만 throw 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a581796a24d10c48d25cf2bf5de6850099d5228" translate="yes" xml:space="preserve">
          <source>Notice that neither example accesses the line data returned by &lt;code&gt;front&lt;/code&gt; after the corresponding &lt;code&gt;popFront&lt;/code&gt; call is made (because the contents may well have changed).</source>
          <target state="translated">해당 &lt;code&gt;popFront&lt;/code&gt; 호출이 수행 된 후 (예 : 내용이 변경되었을 수 있기 때문에) &lt;code&gt;front&lt;/code&gt; 반환 된 행 데이터에 액세스하는 예는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="dcd4250a12512a2c398c7fe01f5bc68a926da35d" translate="yes" xml:space="preserve">
          <source>Notice that several callbacks can be done for each call to &lt;code&gt;perform()&lt;/code&gt; due to redirections.</source>
          <target state="translated">리디렉션으로 인해 각 호출에 대해 여러 개의 콜백을 수행 할 수 있습니다 &lt;code&gt;perform()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7c222c11980679caccf67c7a85849f0e950edc28" translate="yes" xml:space="preserve">
          <source>Notifies all waiters.</source>
          <target state="translated">모든 웨이터에게 알립니다.</target>
        </trans-unit>
        <trans-unit id="cbc750275e7d97cd8c120ef91be05291f0103743" translate="yes" xml:space="preserve">
          <source>Notifies one waiter.</source>
          <target state="translated">한 명의 웨이터에게 알립니다.</target>
        </trans-unit>
        <trans-unit id="b94b032502f2f9d495a4f02e02f68111a39d131a" translate="yes" xml:space="preserve">
          <source>Novell IPX</source>
          <target state="translated">노벨 IPX</target>
        </trans-unit>
        <trans-unit id="109085beaaa80ac89858b283a64f7c75d7e5bb12" translate="yes" xml:space="preserve">
          <source>Null</source>
          <target state="translated">Null</target>
        </trans-unit>
        <trans-unit id="447e3998fb0128904fe3329e53a4e7a27cefac16" translate="yes" xml:space="preserve">
          <source>Null values</source>
          <target state="translated">널값</target>
        </trans-unit>
        <trans-unit id="dec14193294f19de7c47f5a56980f3295c70ec10" translate="yes" xml:space="preserve">
          <source>Null-terminated string representing parameters.</source>
          <target state="translated">매개 변수를 나타내는 널 종료 문자열.</target>
        </trans-unit>
        <trans-unit id="1804c90829b7f01abfd49841af3caae85ad51299" translate="yes" xml:space="preserve">
          <source>Nullable</source>
          <target state="translated">Nullable</target>
        </trans-unit>
        <trans-unit id="8a24e40402207b8b70cc14eba1867548ac1b09e9" translate="yes" xml:space="preserve">
          <source>Num</source>
          <target state="translated">Num</target>
        </trans-unit>
        <trans-unit id="227a24a3e4141a9ac40b8fdf7fd5c2ffacf8d89f" translate="yes" xml:space="preserve">
          <source>Num &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">숫자 &lt;code&gt;x&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d7588782f3d53157aff69b1bffa0181c62154c99" translate="yes" xml:space="preserve">
          <source>Num[] &lt;code&gt;proportions&lt;/code&gt;</source>
          <target state="translated">숫자 [] &lt;code&gt;proportions&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b7baa1d40c4ea29afc9098732bffee2a861a6c44" translate="yes" xml:space="preserve">
          <source>Number</source>
          <target state="translated">Number</target>
        </trans-unit>
        <trans-unit id="dd451df143db1883131677d43c7f1a93144a6224" translate="yes" xml:space="preserve">
          <source>Number Forms</source>
          <target state="translated">숫자 양식</target>
        </trans-unit>
        <trans-unit id="eb0f5a21c19313cdefd12cf556538964ec1b60c1" translate="yes" xml:space="preserve">
          <source>Number Of Columns In A Result Set</source>
          <target state="translated">결과 집합의 열 수</target>
        </trans-unit>
        <trans-unit id="29a85c89c3b665d61a62026778cb1a84d89e00ac" translate="yes" xml:space="preserve">
          <source>Number Of SQL Parameters</source>
          <target state="translated">SQL 매개 변수 수</target>
        </trans-unit>
        <trans-unit id="a22e9e0b736b63398e30b2dc8f5160ec0610321d" translate="yes" xml:space="preserve">
          <source>Number of &lt;a href=&quot;#Code%20point&quot;&gt;code points&lt;/a&gt; in this set</source>
          <target state="translated">이 세트 의 &lt;a href=&quot;#Code%20point&quot;&gt;코드 포인트&lt;/a&gt; 수</target>
        </trans-unit>
        <trans-unit id="e026d4caea1fcabe0afc5bce1ec527601e891b24" translate="yes" xml:space="preserve">
          <source>Number of ArchiveMembers in the directory.</source>
          <target state="translated">디렉토리의 ArchiveMembers 수입니다.</target>
        </trans-unit>
        <trans-unit id="dced2e36ae14ec7a69ee28b0add25c818b2b4655" translate="yes" xml:space="preserve">
          <source>Number of additional microseconds.</source>
          <target state="translated">추가 마이크로 초 수</target>
        </trans-unit>
        <trans-unit id="0d2fad8cfb1c2fbe8652c823ff48cfedc04bfb72" translate="yes" xml:space="preserve">
          <source>Number of bits in each size_t</source>
          <target state="translated">각 size_t의 비트 수</target>
        </trans-unit>
        <trans-unit id="a93803f4135c13b69cc5979ce910aec164759875" translate="yes" xml:space="preserve">
          <source>Number of bits in the &lt;code&gt;BitArray&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;BitArray&lt;/code&gt; 의 비트 수입니다 .</target>
        </trans-unit>
        <trans-unit id="07597dee353e144af76fdefb2c5ac5332f4fcf87" translate="yes" xml:space="preserve">
          <source>Number of bits to be mapped from the source array, i.e. length of the created &lt;code&gt;BitArray&lt;/code&gt;.</source>
          <target state="translated">소스 배열에서 매핑 할 비트 수, 즉 생성 된 &lt;code&gt;BitArray&lt;/code&gt; 의 길이입니다 .</target>
        </trans-unit>
        <trans-unit id="65c610ddbb8967f4ab1b1f258ae1d73dd7fc506f" translate="yes" xml:space="preserve">
          <source>Number of bytes read into the cache when a cache miss occurs.</source>
          <target state="translated">캐시 누락이 발생할 때 캐시로 읽은 바이트 수입니다.</target>
        </trans-unit>
        <trans-unit id="93e4ee2802912bc9542ff03c865140e0975aff48" translate="yes" xml:space="preserve">
          <source>Number of columns in a result set</source>
          <target state="translated">결과 집합의 열 수</target>
        </trans-unit>
        <trans-unit id="bf960b6a4005bb2d8ceff632ab3a6e2d4f800bfc" translate="yes" xml:space="preserve">
          <source>Number of digits printed between separators.</source>
          <target state="translated">구분 기호 사이에 인쇄 된 자릿수입니다.</target>
        </trans-unit>
        <trans-unit id="014bdfb1fc4a2ab03418a68a5de4668cdfda5a8c" translate="yes" xml:space="preserve">
          <source>Number of elements to increment on each iteration. Can't be &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">각 반복에서 증분 할 요소 수 &lt;code&gt;0&lt;/code&gt; 일 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="b3cc33728b84226726cec7ea6692b1f2ec781dcd" translate="yes" xml:space="preserve">
          <source>Number of entries in aConstraint</source>
          <target state="translated">제약 조건의 항목 수</target>
        </trans-unit>
        <trans-unit id="ce0515ee85716ef2446a29c50ffe921e9b963466" translate="yes" xml:space="preserve">
          <source>Number of errors diagnosed</source>
          <target state="translated">진단 된 오류 수</target>
        </trans-unit>
        <trans-unit id="e24daa30f457f98d16ad81a8cd1b686a780b57bc" translate="yes" xml:space="preserve">
          <source>Number of matches in this object.</source>
          <target state="translated">이 개체의 일치 횟수</target>
        </trans-unit>
        <trans-unit id="1dac03e71ace427dad9e6b7ffe2927de0a46070f" translate="yes" xml:space="preserve">
          <source>Number of modules passed the unittests</source>
          <target state="translated">단위 테스트를 통과 한 모듈 수</target>
        </trans-unit>
        <trans-unit id="eede2a1147dee400c67d4557443a83e95e2ed490" translate="yes" xml:space="preserve">
          <source>Number of modules which were tested</source>
          <target state="translated">테스트 된 모듈 수</target>
        </trans-unit>
        <trans-unit id="7438e82b6c23c1a6a50ced05d87fbc419c638058" translate="yes" xml:space="preserve">
          <source>Number of pattern matched counting, where 1 - the first pattern. Returns 0 on no match.</source>
          <target state="translated">계산 된 패턴 일치 횟수 (여기서 1-첫 번째 패턴) 일치하지 않으면 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="922cca92f6321c3aaf3d76ca4f48884a73b7acfb" translate="yes" xml:space="preserve">
          <source>Number of ports to try, including the first one set with LOCALPORT. Thus, setting it to 1 will make no additional attempts but the first.</source>
          <target state="translated">LOCALPORT로 설정된 첫 번째 포트를 포함하여 시도 할 포트 수 따라서 1로 설정하면 첫 번째 시도 외에 추가 시도가 없습니다.</target>
        </trans-unit>
        <trans-unit id="d04f19934163f0381d14164007519a392b8483aa" translate="yes" xml:space="preserve">
          <source>Number of seconds between when successive keep-alive packets are sent if no acknowledgement is received.</source>
          <target state="translated">승인이 수신되지 않은 경우 연속 연결 유지 패킷이 전송 될 때까지의 시간 (초)입니다.</target>
        </trans-unit>
        <trans-unit id="0bc72a7cc11fac0901c32b98ed01a772c919d228" translate="yes" xml:space="preserve">
          <source>Number of seconds with no activity until the first keep-alive packet is sent.</source>
          <target state="translated">첫 번째 연결 유지 패킷이 전송 될 때까지 활동이없는 시간 (초)입니다.</target>
        </trans-unit>
        <trans-unit id="8dbf01ad892fef3cbce4edb89d69f81c5f0de924" translate="yes" xml:space="preserve">
          <source>Number of seconds.</source>
          <target state="translated">초</target>
        </trans-unit>
        <trans-unit id="c214b9bdd41903556e087fe149c81c976a0f4498" translate="yes" xml:space="preserve">
          <source>Number of significant &lt;code&gt;uint&lt;/code&gt;s which are used in storing this number. The absolute value of this &lt;code&gt;BigInt&lt;/code&gt; is always &amp;lt; 2&lt;sup&gt;32*uintLength&lt;/sup&gt;</source>
          <target state="translated">이 수를 저장하는 데 사용되는 유효 &lt;code&gt;uint&lt;/code&gt; 수입니다. 이 &lt;code&gt;BigInt&lt;/code&gt; 의 절대 값 은 항상 &amp;lt;2 &lt;sup&gt;32 * uintLength입니다.&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="4bdce26619426ae548a19f521bd66b45e9ee23da" translate="yes" xml:space="preserve">
          <source>Number of significant &lt;code&gt;ulong&lt;/code&gt;s which are used in storing this number. The absolute value of this &lt;code&gt;BigInt&lt;/code&gt; is always &amp;lt; 2&lt;sup&gt;64*ulongLength&lt;/sup&gt;</source>
          <target state="translated">이 수를 저장하는 데 사용되는 유효 &lt;code&gt;ulong&lt;/code&gt; 수입니다. 이 &lt;code&gt;BigInt&lt;/code&gt; 의 절대 값 은 항상 &amp;lt;2 &lt;sup&gt;64 * ulongLength입니다.&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="64b3ecb75c4dfda2a446b2f4f3b2871ac03979f3" translate="yes" xml:space="preserve">
          <source>Number of terms in the ORDER BY clause</source>
          <target state="translated">ORDER BY 절의 용어 수</target>
        </trans-unit>
        <trans-unit id="ef9279ba4d5abd3b54baf0ba9c7ff343e2d5a039" translate="yes" xml:space="preserve">
          <source>Number of the disk, where the central directory starts.</source>
          <target state="translated">중앙 디렉토리가 시작되는 디스크 번호.</target>
        </trans-unit>
        <trans-unit id="ad086bd903ef281a8b19c4693c7769037ca0462e" translate="yes" xml:space="preserve">
          <source>Number of this disk.</source>
          <target state="translated">이 디스크의 수입니다.</target>
        </trans-unit>
        <trans-unit id="5888fcbbf39aff14a132b0aa33a185d58c5a3831" translate="yes" xml:space="preserve">
          <source>Number of warnings diagnosed</source>
          <target state="translated">진단 된 경고 수</target>
        </trans-unit>
        <trans-unit id="561f30d62b1a6200b9732c30482b0463610d0115" translate="yes" xml:space="preserve">
          <source>Number of ways of associativity, eg:</source>
          <target state="translated">연관성 방법의 수, 예 :</target>
        </trans-unit>
        <trans-unit id="cd3b1b068542b26d45d6b3ef969ff75d18222dc4" translate="yes" xml:space="preserve">
          <source>Number used to identify the index</source>
          <target state="translated">색인을 식별하는 데 사용되는 번호</target>
        </trans-unit>
        <trans-unit id="c25ed4b26440772f57732268d4988021acc7b988" translate="yes" xml:space="preserve">
          <source>Numbering of both row and col start at one and corresponds to the location in the file rather than any specified header. Special consideration should be made when there is failure to match the header see &lt;a href=&quot;#%20HeaderMismatchException&quot;&gt;&lt;code&gt; HeaderMismatchException&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">행과 열의 번호는 한 번에 시작하며 지정된 헤더가 아닌 파일의 위치에 해당합니다. 헤더와 일치하지 않는 경우 특별히 고려해야합니다 . 자세한 내용 은 &lt;a href=&quot;#%20HeaderMismatchException&quot;&gt; &lt;code&gt; HeaderMismatchException&lt;/code&gt; &lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="043b9f0681a8dd4b8f64327c866f7055557d443c" translate="yes" xml:space="preserve">
          <source>Numbers in back references are encoded with base 26 by upper case letters &lt;b&gt;A&lt;/b&gt; - &lt;b&gt;Z&lt;/b&gt; for higher digits but lower case letters &lt;b&gt;a&lt;/b&gt; - &lt;b&gt;z&lt;/b&gt; for the last digit.</source>
          <target state="translated">역 참조의 숫자는 높은 자릿수의 경우 대문자 &lt;b&gt;A&lt;/b&gt; - &lt;b&gt;Z&lt;/b&gt; , 마지막 숫자의 경우 소문자 &lt;b&gt;a&lt;/b&gt; - &lt;b&gt;z&lt;/b&gt; 로 밑수 26으로 인코딩됩니다 .</target>
        </trans-unit>
        <trans-unit id="30a62380404b3b267a5c4e21b5e111455d09031e" translate="yes" xml:space="preserve">
          <source>Numeric</source>
          <target state="translated">Numeric</target>
        </trans-unit>
        <trans-unit id="7fcd839a0c3a9bfde44006032939e1a31c5868bc" translate="yes" xml:space="preserve">
          <source>Numeric options.</source>
          <target state="translated">숫자 옵션.</target>
        </trans-unit>
        <trans-unit id="270e362a8583599d25044ab02934c1f0544031a5" translate="yes" xml:space="preserve">
          <source>O(n) Exactly &lt;code&gt;n - 1&lt;/code&gt; comparisons are needed.</source>
          <target state="translated">O (n) 정확히 &lt;code&gt;n - 1&lt;/code&gt; 비교가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="8ebce3c4279d1345740690ecbe2cb5d8468c3d5b" translate="yes" xml:space="preserve">
          <source>ODBC API Reference on MSN Online</source>
          <target state="translated">MSN Online의 ODBC API 참조</target>
        </trans-unit>
        <trans-unit id="8b5eff42232707634349636f92675ea68779d3cd" translate="yes" xml:space="preserve">
          <source>OEM</source>
          <target state="translated">OEM</target>
        </trans-unit>
        <trans-unit id="557b1e3dfa4d6c186eed45510ad708c5febe6794" translate="yes" xml:space="preserve">
          <source>OOP API</source>
          <target state="translated">OOP API</target>
        </trans-unit>
        <trans-unit id="6921936df35e74323acb623a59db8353c959e5ec" translate="yes" xml:space="preserve">
          <source>OOP API CRC32 implementation. See &lt;code&gt;std.digest&lt;/code&gt; for differences between template and OOP API.</source>
          <target state="translated">OOP API CRC32 구현. 템플릿과 OOP API의 차이점에 대해서는 &lt;code&gt;std.digest&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ecc5ce592d40207f7cf51c58cc165c87d26dfe71" translate="yes" xml:space="preserve">
          <source>OOP API CRC64-ECMA implementation. See &lt;code&gt;std.digest.digest&lt;/code&gt; for differences between template and OOP API.</source>
          <target state="translated">OOP API CRC64-ECMA 구현 템플릿과 OOP API의 차이점에 대해서는 &lt;code&gt;std.digest.digest&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2c20805b5dfcc262ae7041b841371e4419085a84" translate="yes" xml:space="preserve">
          <source>OOP API CRC64-ECMA implementation. See &lt;code&gt;std.digest&lt;/code&gt; for differences between template and OOP API.</source>
          <target state="translated">OOP API CRC64-ECMA 구현. 템플릿과 OOP API의 차이점 은 &lt;code&gt;std.digest&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f12b177dd99fc261f8c72b1e0213b2e6e7b80d50" translate="yes" xml:space="preserve">
          <source>OOP API CRC64-ISO implementation. See &lt;code&gt;std.digest.digest&lt;/code&gt; for differences between template and OOP API.</source>
          <target state="translated">OOP API CRC64-ISO 구현 템플릿과 OOP API의 차이점에 대해서는 &lt;code&gt;std.digest.digest&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f91bc29ac78b7bc87fccaec2d6b32d49dd2ac1ca" translate="yes" xml:space="preserve">
          <source>OOP API CRC64-ISO implementation. See &lt;code&gt;std.digest&lt;/code&gt; for differences between template and OOP API.</source>
          <target state="translated">OOP API CRC64-ISO 구현. 템플릿과 OOP API의 차이점 은 &lt;code&gt;std.digest&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4435eff46cba37f8974382bdc1da051288640e06" translate="yes" xml:space="preserve">
          <source>OOP API MD5 implementation. See &lt;code&gt;std.digest&lt;/code&gt; for differences between template and OOP API.</source>
          <target state="translated">OOP API MD5 구현 템플릿과 OOP API의 차이점에 대해서는 &lt;code&gt;std.digest&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f868a309d4075e7e6d29d7ba2d8755b13e54f79b" translate="yes" xml:space="preserve">
          <source>OOP API RIPEMD160 implementation. See &lt;code&gt;std.digest&lt;/code&gt; for differences between template and OOP API.</source>
          <target state="translated">OOP API RIPEMD160 구현. 템플릿과 OOP API의 차이점에 대해서는 &lt;code&gt;std.digest&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c7dfbc3d2d3fbec054ee506d60faed523760f1e0" translate="yes" xml:space="preserve">
          <source>OOP API SHA1 and SHA2 implementations. See &lt;code&gt;std.digest&lt;/code&gt; for differences between template and OOP API.</source>
          <target state="translated">OOP API SHA1 및 SHA2 구현 템플릿과 OOP API의 차이점에 대해서는 &lt;code&gt;std.digest&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="df7ef594df8b60ce4c07238616bdf42e033977bc" translate="yes" xml:space="preserve">
          <source>OPER &lt;code&gt;op&lt;/code&gt;</source>
          <target state="translated">운영 &lt;code&gt;op&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6259a657ea98cbfae3336dd19e405644a8e8c23e" translate="yes" xml:space="preserve">
          <source>OR CSX bits to &lt;code&gt;this&lt;/code&gt;</source>
          <target state="translated">OR CSX는 비트로 &lt;code&gt;this&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7ea1a5ba1dffba576fe0a188bb466f1a65ef5c2d" translate="yes" xml:space="preserve">
          <source>OS Interface File Virtual Methods Object</source>
          <target state="translated">OS 인터페이스 파일 가상 메소드 오브젝트</target>
        </trans-unit>
        <trans-unit id="2fdd9f0dd04e20b2da0185c9864ac62e0fd49b33" translate="yes" xml:space="preserve">
          <source>OS Interface Object</source>
          <target state="translated">OS 인터페이스 객체</target>
        </trans-unit>
        <trans-unit id="e502b880ac4721322e02bb29b5215f15ab6c97e9" translate="yes" xml:space="preserve">
          <source>OS Interface Open File Handle</source>
          <target state="translated">OS 인터페이스 열린 파일 핸들</target>
        </trans-unit>
        <trans-unit id="1c57744725eab7d96ac80db864a93aca09030a50" translate="yes" xml:space="preserve">
          <source>OS Specific Code</source>
          <target state="translated">OS 특정 코드</target>
        </trans-unit>
        <trans-unit id="9954b5cb646af3e1d62f8936ee802e399e164efe" translate="yes" xml:space="preserve">
          <source>OS X</source>
          <target state="translated">OS X</target>
        </trans-unit>
        <trans-unit id="816f2c01635dcd191ef472eb81837ab4764ba659" translate="yes" xml:space="preserve">
          <source>OS error code.</source>
          <target state="translated">OS 오류 코드</target>
        </trans-unit>
        <trans-unit id="c5964b15914a0f20d38705c40412632aaea2180a" translate="yes" xml:space="preserve">
          <source>OS/host/cpu/machine when configured</source>
          <target state="translated">구성시 OS / 호스트 / CPU / 컴퓨터</target>
        </trans-unit>
        <trans-unit id="35acf96a362a15aaca94167666a925df3fe080f1" translate="yes" xml:space="preserve">
          <source>ObjcClassDeclaration &lt;strong id=&quot;objc&quot;&gt;objc&lt;/strong&gt;;</source>
          <target state="translated">ObjcClassDeclaration &lt;strong id=&quot;objc&quot;&gt;objc&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="5e48ba2904324f04728f2234033c5d7007795ec3" translate="yes" xml:space="preserve">
          <source>ObjcSelector* &lt;strong id=&quot;selector&quot;&gt;selector&lt;/strong&gt;;</source>
          <target state="translated">ObjcSelector * &lt;strong id=&quot;selector&quot;&gt;선택기&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="a124d6d00ec7f85d42323b621f494c2cd12184cc" translate="yes" xml:space="preserve">
          <source>Object &lt;code&gt;switchObject&lt;/code&gt;</source>
          <target state="translated">오브젝트 &lt;code&gt;switchObject&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ece8bdfc268974984201b8d682070a5edffce7a2" translate="yes" xml:space="preserve">
          <source>Object &lt;strong id=&quot;_d_newclass&quot;&gt;_d_newclass&lt;/strong&gt;(const ClassInfo ci);</source>
          <target state="translated">객체 &lt;strong id=&quot;_d_newclass&quot;&gt;_d_newclass&lt;/strong&gt; (const ClassInfo ci);</target>
        </trans-unit>
        <trans-unit id="ddc38e05a9ed06d0994faa2bc5bcaf09ff87a879" translate="yes" xml:space="preserve">
          <source>Object &lt;strong id=&quot;_d_toObject&quot;&gt;_d_toObject&lt;/strong&gt;(void* p);</source>
          <target state="translated">Object &lt;strong id=&quot;_d_toObject&quot;&gt;_d_toObject&lt;/strong&gt; (void * p);</target>
        </trans-unit>
        <trans-unit id="9acd850a30238a54eae733b2ef6db2b68124fe1e" translate="yes" xml:space="preserve">
          <source>Object Model</source>
          <target state="translated">개체 모델</target>
        </trans-unit>
        <trans-unit id="732daf7f402fda71346fc5973740764129bee2f3" translate="yes" xml:space="preserve">
          <source>Object Pinning and a Moving Garbage Collector</source>
          <target state="translated">객체 고정 및 이동 가비지 수집기</target>
        </trans-unit>
        <trans-unit id="3ecabb74a2c93b43f3577af0a26092db2efdcfb6" translate="yes" xml:space="preserve">
          <source>Object completely outside of query region</source>
          <target state="translated">쿼리 영역을 완전히 벗어난 개체</target>
        </trans-unit>
        <trans-unit id="6cf94223be079da3fbcb13c64cfc6ed135fdad80" translate="yes" xml:space="preserve">
          <source>Object fully contained within query region</source>
          <target state="translated">쿼리 영역 내에 완전히 포함 된 개체</target>
        </trans-unit>
        <trans-unit id="cb01dc2819651d214c0a4eb512d158aeef9a6b70" translate="yes" xml:space="preserve">
          <source>Object partially overlaps query region</source>
          <target state="translated">개체가 쿼리 영역과 부분적으로 겹칩니다</target>
        </trans-unit>
        <trans-unit id="0ded44e81d1421792f7fc6112d1cfca42b60744c" translate="yes" xml:space="preserve">
          <source>Object representing the entire archive. ZipArchives are collections of ArchiveMembers.</source>
          <target state="translated">전체 아카이브를 나타내는 객체입니다. ZipArchives는 ArchiveMembers의 모음입니다.</target>
        </trans-unit>
        <trans-unit id="ecae80279dd422f8944cb69fbb2f5b597c9f19cc" translate="yes" xml:space="preserve">
          <source>Object to string conversion calls &lt;code&gt;toString&lt;/code&gt; against the object or returns &lt;code&gt;&quot;null&quot;&lt;/code&gt; if the object is null.</source>
          <target state="translated">객체에서 문자열로의 변환 은 객체에 대해 &lt;code&gt;toString&lt;/code&gt; 을 호출 하거나 객체가 null 인 경우 &lt;code&gt;&quot;null&quot;&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="034dc42255fa6bafb6326377d2645e95c07ee389" translate="yes" xml:space="preserve">
          <source>Object to throw</source>
          <target state="translated">던질 물체</target>
        </trans-unit>
        <trans-unit id="b72ead77472cd34b4701daf055c4eb79c6a81e4a" translate="yes" xml:space="preserve">
          <source>Object which contains &lt;a href=&quot;std_stdio#File&quot;&gt;&lt;code&gt;std.stdio.File&lt;/code&gt;&lt;/a&gt; handles that allow communication with a child process through its standard streams.</source>
          <target state="translated">표준 스트림을 통해 자식 프로세스와 통신 할 수있는 &lt;a href=&quot;std_stdio#File&quot;&gt; &lt;code&gt;std.stdio.File&lt;/code&gt; &lt;/a&gt; 핸들 이 포함 된 개체입니다 .</target>
        </trans-unit>
        <trans-unit id="a5f374a039e07f85b267c41c18b5e4564272df79" translate="yes" xml:space="preserve">
          <source>Object-to-object conversions by dynamic casting throw exception when the source is non-null and the target is null.</source>
          <target state="translated">소스가 널이 아니고 대상이 널인 경우 동적 캐스트에 의한 오브젝트 간 변환 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="99e277264a83dccb794e12be27e133211daf2991" translate="yes" xml:space="preserve">
          <source>Objective-C Linkage</source>
          <target state="translated">Objective-C 연계</target>
        </trans-unit>
        <trans-unit id="b0459b002183c075496ce13224dd6546ac66c7e6" translate="yes" xml:space="preserve">
          <source>Objective-C class reference expression.</source>
          <target state="translated">Objective-C 클래스 참조 표현식</target>
        </trans-unit>
        <trans-unit id="54d74c41d0f52e19ffb24eaa1df21cfde1c3609d" translate="yes" xml:space="preserve">
          <source>Objective-C implicit selector parameter</source>
          <target state="translated">Objective-C 암시 적 선택기 매개 변수</target>
        </trans-unit>
        <trans-unit id="ce5a6ea19029f9f5f4b5ed2b2ccb10ccf00b46e5" translate="yes" xml:space="preserve">
          <source>Objective-C linkage</source>
          <target state="translated">Objective-C 연결</target>
        </trans-unit>
        <trans-unit id="215e38e2c0c8e6165a5d19476eb05da7a2d96f1b" translate="yes" xml:space="preserve">
          <source>Objective-C linkage is achieved by attaching the &lt;code&gt;extern (Objective-C)&lt;/code&gt; attribute to a class. Example:</source>
          <target state="translated">Objective-C 연결은 &lt;code&gt;extern (Objective-C)&lt;/code&gt; 속성을 클래스 에 첨부하여 수행됩니다 . 예:</target>
        </trans-unit>
        <trans-unit id="d0b17723f1650f620f6ed1dc84f453d083a59561" translate="yes" xml:space="preserve">
          <source>Objective-C method selector (member function only)</source>
          <target state="translated">Objective-C 메소드 선택기 (멤버 함수 만 해당)</target>
        </trans-unit>
        <trans-unit id="72a83add2c5ede877c10d23f302d3e17accbadab" translate="yes" xml:space="preserve">
          <source>Objects</source>
          <target state="translated">Objects</target>
        </trans-unit>
        <trans-unit id="774388ab695ea7f6fa92eda419b8a4a91ec37650" translate="yes" xml:space="preserve">
          <source>Objects can be composed into a</source>
          <target state="translated">개체는</target>
        </trans-unit>
        <trans-unit id="8b9e450214fb7eb03791dd522d5ab5d9060d4e6c" translate="yes" xml:space="preserve">
          <source>Objects of types &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;wstring&lt;/code&gt;, and &lt;code&gt;dstring&lt;/code&gt; are value types and cannot be mutated element-by-element. For using mutation during building strings, use &lt;code&gt;char[]&lt;/code&gt;, &lt;code&gt;wchar[]&lt;/code&gt;, or &lt;code&gt;dchar[]&lt;/code&gt;. The &lt;code&gt;xxxstring&lt;/code&gt; types are preferable because they don't exhibit undesired aliasing, thus making code more robust.</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; , &lt;code&gt;wstring&lt;/code&gt; 및 &lt;code&gt;dstring&lt;/code&gt; 유형의 오브젝트 는 값 유형이며 요소별로 변경 될 수 없습니다. 문자열을 작성하는 동안 돌연변이를 사용하려면 &lt;code&gt;char[]&lt;/code&gt; , &lt;code&gt;wchar[]&lt;/code&gt; 또는 &lt;code&gt;dchar[]&lt;/code&gt; . &lt;code&gt;xxxstring&lt;/code&gt; 그들은 따라서 코드는 더 강력하고, 원하지 않는 앨리어싱을 나타내지 않기 때문에 유형이 바람직하다.</target>
        </trans-unit>
        <trans-unit id="26fcfe297b1b850d8b9dff28561f4b9b1ce56f00" translate="yes" xml:space="preserve">
          <source>Objects referenced from the data segment never get collected by the gc.</source>
          <target state="translated">데이터 세그먼트에서 참조 된 객체는 gc에 의해 수집되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6a4f0f9bbfc4a160ef93e1d60e94318e4b881b61" translate="yes" xml:space="preserve">
          <source>Objects* &lt;code&gt;tiargs&lt;/code&gt;</source>
          <target state="translated">객체 * &lt;code&gt;tiargs&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ecc00047669613c320e2b8a081aa7c82aa8f91c6" translate="yes" xml:space="preserve">
          <source>Objects* &lt;strong id=&quot;opToArg&quot;&gt;opToArg&lt;/strong&gt;(Scope* sc, TOK op);</source>
          <target state="translated">개체 * &lt;strong id=&quot;opToArg&quot;&gt;opToArg&lt;/strong&gt; (Scope * sc, TOK op);</target>
        </trans-unit>
        <trans-unit id="1cd772265dd23d3a0ed79c300af6b5bbcbce033e" translate="yes" xml:space="preserve">
          <source>Observer pattern</source>
          <target state="translated">관찰자 패턴</target>
        </trans-unit>
        <trans-unit id="f036e380a093cadb7b7384e4b591b8c75c1ba145" translate="yes" xml:space="preserve">
          <source>Obtain Aggregate Function Context</source>
          <target state="translated">집계 함수 컨텍스트 확보</target>
        </trans-unit>
        <trans-unit id="077c26082590279e5f39ea62e9c34ff3f445683c" translate="yes" xml:space="preserve">
          <source>Obtain a textual representation of this InversionList in form of open-right intervals.</source>
          <target state="translated">이 InversionList의 텍스트 표현을 오픈-오른쪽 간격으로 구하십시오.</target>
        </trans-unit>
        <trans-unit id="9955193cbfed75c0d6fc873fae9a5c26061d84dc" translate="yes" xml:space="preserve">
          <source>Obtaining SQL Function Parameter Values</source>
          <target state="translated">SQL 함수 매개 변수 값 얻기</target>
        </trans-unit>
        <trans-unit id="6149db4fff5ac75f11f401b9918f00840c3dba03" translate="yes" xml:space="preserve">
          <source>Obtains a set that is the inversion of this set.</source>
          <target state="translated">이 세트의 반전 인 세트를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="bc3e5f94349cc9f5746dcb1e65b92691d9d6aed1" translate="yes" xml:space="preserve">
          <source>Obtains a subclass of EncodingScheme which is capable of encoding and decoding the named encoding scheme.</source>
          <target state="translated">명명 된 인코딩 체계를 인코딩하고 디코딩 할 수있는 EncodingScheme의 서브 클래스를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="ba7c16645de19d70bbf51df86b8b25f634669237" translate="yes" xml:space="preserve">
          <source>Obtains the next value from the underlying function.</source>
          <target state="translated">기본 함수에서 다음 값을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="10500e54805775e3d661be35724e87f0b1dbc4c9" translate="yes" xml:space="preserve">
          <source>Octal</source>
          <target state="translated">Octal</target>
        </trans-unit>
        <trans-unit id="0daf1c539c30bf40547a057c7075740c9c50e77c" translate="yes" xml:space="preserve">
          <source>Odd numbers, using function in string form:</source>
          <target state="translated">문자열 형식의 함수를 사용하는 홀수 :</target>
        </trans-unit>
        <trans-unit id="1a245d243a2742055ac1b3dfb70948e781eb208b" translate="yes" xml:space="preserve">
          <source>Of course the tuple types can be used to declare things:</source>
          <target state="translated">물론 튜플 형식을 사용하여 내용을 선언 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="62fa90ec5148fa0e0f3ac3986984deff76df1822" translate="yes" xml:space="preserve">
          <source>Of course, the real value of UDAs is to be able to create user-defined types with specific values. Having attribute values of basic types does not scale. The attribute tuples can be manipulated like any other tuple, and can be passed as the argument list to a template.</source>
          <target state="translated">물론 UDA의 실제 가치는 특정 값으로 사용자 정의 유형을 만들 수 있어야합니다. 기본 유형의 속성 값이 있으면 확장되지 않습니다. 속성 튜플은 다른 튜플처럼 조작 할 수 있으며 인수 목록으로 템플릿에 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="11fc1982f3e473014c90d340826a6dd1a575af7b" translate="yes" xml:space="preserve">
          <source>Of course, transformations that would alter side effects are also invalid.</source>
          <target state="translated">물론 부작용을 바꾸는 변형도 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a25b627c05fa6788c3c361e7833cb2ca525e070c" translate="yes" xml:space="preserve">
          <source>Offers all of allocator's memory to the caller, so it's usually defined by fixed-size allocators. If the allocator is currently NOT managing any memory, then &lt;code&gt;allocateAll()&lt;/code&gt; shall allocate and return all memory available to the allocator, and subsequent calls to all allocation primitives should not succeed (e.g. &lt;code&gt;allocate&lt;/code&gt; shall return &lt;code&gt;null&lt;/code&gt; etc). Otherwise, &lt;code&gt;allocateAll&lt;/code&gt; only works on a best-effort basis, and the allocator is allowed to return &lt;code&gt;null&lt;/code&gt; even if does have available memory. Memory allocated with &lt;code&gt;allocateAll&lt;/code&gt; is not otherwise special (e.g. can be reallocated or deallocated with the usual primitives, if defined).</source>
          <target state="translated">모든 할당 자의 메모리를 호출자에게 제공하므로 일반적으로 고정 크기 할당 자에 의해 정의됩니다. 할당자가 현재 메모리를 관리하지 않는 경우, AssignAll &lt;code&gt;allocateAll()&lt;/code&gt; 은 할당 자에게 사용 가능한 모든 메모리를 할당하고 반환해야하며, 모든 할당 프리미티브에 대한 후속 호출은 성공하지 않아야합니다 (예를 들어, &lt;code&gt;allocate&lt;/code&gt; &lt;code&gt;null&lt;/code&gt; 을 반환해야 함 ). 그렇지 않으면, &lt;code&gt;allocateAll&lt;/code&gt; 는 최선의 노력을하는 작동하고, 할당을 반환하도록 허용 &lt;code&gt;null&lt;/code&gt; 사용 가능한 메모리를 가지고있다하더라도합니다. 할당 메모리 &lt;code&gt;allocateAll&lt;/code&gt; 은 (정의 된 경우 예는, 일반적인 원시로 재 할당하거나 해제 할 수 있습니다) 그렇지 않으면 특별하지 않다.</target>
        </trans-unit>
        <trans-unit id="b8e254b5857bb996007e86e42f91a92a6fe49956" translate="yes" xml:space="preserve">
          <source>Offset &lt;code&gt;offset&lt;/code&gt;</source>
          <target state="translated">오프셋 &lt;code&gt;offset&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8e8c6ead4fb6cb7f2c973d4188b3da2d45612843" translate="yes" xml:space="preserve">
          <source>Offset from symbol</source>
          <target state="translated">심볼에서 오프셋</target>
        </trans-unit>
        <trans-unit id="5244f072c2bc40432333ca8bae11450eb7f1cd34" translate="yes" xml:space="preserve">
          <source>Offset in bytes of field from beginning of struct</source>
          <target state="translated">구조체의 시작부터 필드의 바이트 단위 오프셋</target>
        </trans-unit>
        <trans-unit id="8e33b5cfe09a13b536b5161336efb8ad6830ec37" translate="yes" xml:space="preserve">
          <source>Offset is relative to the beginning</source>
          <target state="translated">오프셋은 시작과 관련이 있습니다</target>
        </trans-unit>
        <trans-unit id="99bd2ecc0f5280a8901a4ed0e050abb97a414e2f" translate="yes" xml:space="preserve">
          <source>Offset is relative to the current position</source>
          <target state="translated">오프셋은 현재 위치를 기준으로합니다</target>
        </trans-unit>
        <trans-unit id="c47d1f5c9f6a5ff920bded63466f4748ace14da1" translate="yes" xml:space="preserve">
          <source>Offset is relative to the end</source>
          <target state="translated">오프셋은 끝을 기준으로합니다</target>
        </trans-unit>
        <trans-unit id="b485855fd43092cb4450e8db11b22aad8322f41e" translate="yes" xml:space="preserve">
          <source>Offset of member from start of object</source>
          <target state="translated">객체의 시작부터 멤버의 오프셋</target>
        </trans-unit>
        <trans-unit id="c21c3314a2e6470603bd3c8f84047cb484b50ba5" translate="yes" xml:space="preserve">
          <source>Ogham</source>
          <target state="translated">Ogham</target>
        </trans-unit>
        <trans-unit id="93a70c2b646c1ffdd73eb435b17f35f88e31d121" translate="yes" xml:space="preserve">
          <source>Ok for sqlite3_open_v2()</source>
          <target state="translated">sqlite3_open_v2 () 확인</target>
        </trans-unit>
        <trans-unit id="c6e702e40cc2159bb79f5ccec78973bfdae19eaa" translate="yes" xml:space="preserve">
          <source>Ol Chiki</source>
          <target state="translated">올 치키</target>
        </trans-unit>
        <trans-unit id="5f8e3c9a997d8c6ac6d8e0cee37f365cfccbf2c1" translate="yes" xml:space="preserve">
          <source>Ol_Chiki</source>
          <target state="translated">Ol_Chiki</target>
        </trans-unit>
        <trans-unit id="833ad68a2db2dced5d16ece61a3b16b08ed22e87" translate="yes" xml:space="preserve">
          <source>Old API for replacement, operation depends on flags of pattern &lt;code&gt;re&lt;/code&gt;. With &quot;g&quot; flag it performs the equivalent of &lt;a href=&quot;#replaceAll&quot;&gt;&lt;code&gt;replaceAll&lt;/code&gt;&lt;/a&gt; otherwise it works the same as &lt;a href=&quot;#replaceFirst&quot;&gt;&lt;code&gt;replaceFirst&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">교체를위한 이전 API, 작업은 패턴 &lt;code&gt;re&lt;/code&gt; 의 플래그에 따라 다릅니다 . &quot;g&quot;플래그를 사용하면 &lt;a href=&quot;#replaceAll&quot;&gt; &lt;code&gt;replaceAll&lt;/code&gt; &lt;/a&gt; 과 동등한 기능을 수행합니다. 그렇지 않으면 &lt;a href=&quot;#replaceFirst&quot;&gt; &lt;code&gt;replaceFirst&lt;/code&gt; &lt;/a&gt; 와 동일하게 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="02359709d1a195a0128ca35b8d6f25fc1d92a7a7" translate="yes" xml:space="preserve">
          <source>Old Italic</source>
          <target state="translated">오래된 이탤릭체</target>
        </trans-unit>
        <trans-unit id="f3e69230d34ad29f5b4402e08ffd22711717b552" translate="yes" xml:space="preserve">
          <source>Old Persian</source>
          <target state="translated">올드 페르시아어</target>
        </trans-unit>
        <trans-unit id="7261101e4dfe036338fab16980dc651a26f87786" translate="yes" xml:space="preserve">
          <source>Old South Arabian</source>
          <target state="translated">올드 아라비아</target>
        </trans-unit>
        <trans-unit id="7e504d6f4cf5594ab525495944059dd3ab354803" translate="yes" xml:space="preserve">
          <source>Old Turkic</source>
          <target state="translated">올드 투르크어</target>
        </trans-unit>
        <trans-unit id="6affc5b51d0bdbad1e9ae41385b26f980a6f3eb2" translate="yes" xml:space="preserve">
          <source>Old code can be reused with new code without having to modify the old code to be compatible with new error types.</source>
          <target state="translated">이전 코드는 새로운 오류 유형과 호환되도록 이전 코드를 수정하지 않고도 새 코드와 함께 재사용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e3a00bb450715730bc19d8deeddada5bc22e8d7" translate="yes" xml:space="preserve">
          <source>Old code can decide to catch all errors, or only specific ones, propagating the rest upwards. In any case, there is no more need to correlate error numbers with messages, the correct message is always supplied.</source>
          <target state="translated">오래된 코드는 나머지 오류를 모두 전파하면서 모든 오류 또는 특정 오류 만 포착하기로 결정할 수 있습니다. 어쨌든 오류 번호를 메시지와 더 이상 연관시킬 필요가 없으며 올바른 메시지가 항상 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="d31721795f21dfce26688a7f8239a17ca4259705" translate="yes" xml:space="preserve">
          <source>Old_Italic</source>
          <target state="translated">Old_Italic</target>
        </trans-unit>
        <trans-unit id="40f6b23336b20230fad65810979b94941509719d" translate="yes" xml:space="preserve">
          <source>Old_Persian</source>
          <target state="translated">Old_Persian</target>
        </trans-unit>
        <trans-unit id="338432c6b8828a6dc79884aa878e0a2867c42479" translate="yes" xml:space="preserve">
          <source>Old_South_Arabian</source>
          <target state="translated">Old_South_Arabian</target>
        </trans-unit>
        <trans-unit id="3641abb7a588932eef54e644e9d1dff8f948abbf" translate="yes" xml:space="preserve">
          <source>Old_Turkic</source>
          <target state="translated">Old_Turkic</target>
        </trans-unit>
        <trans-unit id="80b8a312a311fc13e2451870de177f83f79912eb" translate="yes" xml:space="preserve">
          <source>On ARM FPU registers are not saved if druntime was compiled as ARM_SoftFloat. If such a build is used on a ARM_SoftFP system which actually has got a FPU and other libraries are using the FPU registers (other code is compiled as ARM_SoftFP) this can cause problems. Druntime must be compiled as ARM_SoftFP in this case.</source>
          <target state="translated">druntime이 ARM_SoftFloat로 컴파일 된 경우 ARM FPU 레지스터는 저장되지 않습니다. 이러한 빌드가 실제로 FPU가있는 ARM_SoftFP 시스템에서 사용되고 다른 라이브러리가 FPU 레지스터를 사용하는 경우 (다른 코드는 ARM_SoftFP로 컴파일 됨) 문제가 발생할 수 있습니다. 이 경우 Druntime은 ARM_SoftFP로 컴파일되어야합니다.</target>
        </trans-unit>
        <trans-unit id="b5359584dd1684a0f13decf91973ad69920c046f" translate="yes" xml:space="preserve">
          <source>On POSIX systems &lt;code&gt;deallocate&lt;/code&gt; calls &lt;code&gt;mmap&lt;/code&gt; with `MAP_FIXED' a second time to decommit the memory. On Windows, it uses &lt;code&gt;VirtualFree&lt;/code&gt; with &lt;code&gt;MEM_DECOMMIT&lt;/code&gt;.</source>
          <target state="translated">POSIX 시스템 에서 메모리를 언 커밋하기 위해 두 번째로`MAP_FIXED '로 &lt;code&gt;mmap&lt;/code&gt; 호출을 &lt;code&gt;deallocate&lt;/code&gt; 합니다 . Windows에서는 &lt;code&gt;MEM_DECOMMIT&lt;/code&gt; 과 함께 &lt;code&gt;VirtualFree&lt;/code&gt; 를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="45fb7652410851794dc34497cbae11bc3aca67e9" translate="yes" xml:space="preserve">
          <source>On POSIX systems, if &lt;code&gt;attrIsFile&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, that indicates that the file is a regular file (e.g. not a block not device). So, on POSIX systems, it's possible for both &lt;code&gt;attrIsFile&lt;/code&gt; and &lt;code&gt;attrIsDir&lt;/code&gt; to be &lt;code&gt;false&lt;/code&gt; for a particular file (in which case, it's a special file). If a file is a special file, you can use the attributes to check what type of special file it is (see the man page for &lt;code&gt;stat&lt;/code&gt; for more information).</source>
          <target state="translated">POSIX 시스템에서 &lt;code&gt;attrIsFile&lt;/code&gt; 이 &lt;code&gt;true&lt;/code&gt; 이면 파일이 일반 파일 (예 : 장치가 아닌 블록이 아님)임을 나타냅니다. 따라서 POSIX 시스템에서는 특정 파일에 대해 &lt;code&gt;attrIsFile&lt;/code&gt; 및 &lt;code&gt;attrIsDir&lt;/code&gt; 이 모두 &lt;code&gt;false&lt;/code&gt; 일 수 있습니다 (이 경우 특수 파일). 파일이 특수 파일 인 경우 속성을 사용하여 어떤 유형의 특수 파일인지 확인할 수 있습니다 ( 자세한 내용 은 &lt;code&gt;stat&lt;/code&gt; 에 대한 man 페이지 참조 ).</target>
        </trans-unit>
        <trans-unit id="c583b8e40f105624ba78af74e0222ec9e4140f48" translate="yes" xml:space="preserve">
          <source>On POSIX systems, if &lt;code&gt;isFile&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, that indicates that the file is a regular file (e.g. not a block not device). So, on POSIX systems, it's possible for both &lt;code&gt;isFile&lt;/code&gt; and &lt;code&gt;isDir&lt;/code&gt; to be &lt;code&gt;false&lt;/code&gt; for a particular file (in which case, it's a special file). You can use &lt;code&gt;attributes&lt;/code&gt; or &lt;code&gt;statBuf&lt;/code&gt; to get more information about a special file (see the stat man page for more details).</source>
          <target state="translated">POSIX 시스템에서 &lt;code&gt;isFile&lt;/code&gt; 이 &lt;code&gt;true&lt;/code&gt; 이면 파일이 일반 파일 (예 : 장치가 아닌 블록이 아님)임을 나타냅니다. 따라서 POSIX 시스템에서는 특정 파일 (이 경우 특수 파일) 에 대해 &lt;code&gt;isFile&lt;/code&gt; 과 &lt;code&gt;isDir&lt;/code&gt; 이 모두 &lt;code&gt;false&lt;/code&gt; 일 수 있습니다. &lt;code&gt;attributes&lt;/code&gt; 또는 &lt;code&gt;statBuf&lt;/code&gt; 를 사용 하여 특수 파일에 대한 자세한 정보를 얻을 수 있습니다 (자세한 내용은 stat 매뉴얼 페이지 참조).</target>
        </trans-unit>
        <trans-unit id="c4127c0b93826b8086ea6e5620a6ea6c4c3237ed" translate="yes" xml:space="preserve">
          <source>On POSIX systems, if &lt;code&gt;isFile&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, that indicates that the file is a regular file (e.g. not a block not device). So, on POSIX systems, it's possible for both &lt;code&gt;isFile&lt;/code&gt; and &lt;code&gt;isDir&lt;/code&gt; to be &lt;code&gt;false&lt;/code&gt; for a particular file (in which case, it's a special file). You can use &lt;code&gt;getAttributes&lt;/code&gt; to get the attributes to figure out what type of special it is, or you can use &lt;code&gt;DirEntry&lt;/code&gt; to get at its &lt;code&gt;statBuf&lt;/code&gt;, which is the result from &lt;code&gt;stat&lt;/code&gt;. In either case, see the man page for &lt;code&gt;stat&lt;/code&gt; for more information.</source>
          <target state="translated">POSIX 시스템에서 &lt;code&gt;isFile&lt;/code&gt; 이 &lt;code&gt;true&lt;/code&gt; 이면 파일이 일반 파일 (예 : 장치가 아닌 블록이 아님)임을 나타냅니다. 따라서 POSIX 시스템에서는 특정 파일 (이 경우 특수 파일) 에 대해 &lt;code&gt;isFile&lt;/code&gt; 과 &lt;code&gt;isDir&lt;/code&gt; 이 모두 &lt;code&gt;false&lt;/code&gt; 일 수 있습니다. 당신은 사용 &lt;code&gt;getAttributes&lt;/code&gt; 그것이 무엇인지 특별한 유형을 파악하는 속성을 얻기 위해, 또는 당신이 사용할 수있는 &lt;code&gt;DirEntry&lt;/code&gt; 를 자사에서 얻을 수 &lt;code&gt;statBuf&lt;/code&gt; 의 결과이며, &lt;code&gt;stat&lt;/code&gt; . 두 경우 모두 &lt;code&gt;stat&lt;/code&gt; 에 대한 자세한 내용 은 man 페이지 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="fb0133a132ea7a309a8c48c2dd69a00cf667df59" translate="yes" xml:space="preserve">
          <source>On POSIX systems, if the file represented by this &lt;code&gt;DirEntry&lt;/code&gt; is a symbolic link, then &lt;code&gt;linkAttributes&lt;/code&gt; are the attributes of the symbolic link itself. Otherwise, &lt;code&gt;linkAttributes&lt;/code&gt; is identical to &lt;code&gt;attributes&lt;/code&gt;.</source>
          <target state="translated">POSIX 시스템에서이 &lt;code&gt;DirEntry&lt;/code&gt; 가 나타내는 파일이 심볼릭 링크이면 &lt;code&gt;linkAttributes&lt;/code&gt; 는 심볼릭 링크 자체의 속성입니다. 그렇지 않으면 &lt;code&gt;linkAttributes&lt;/code&gt; 는 &lt;code&gt;attributes&lt;/code&gt; 와 동일 합니다 .</target>
        </trans-unit>
        <trans-unit id="f04c1fe2d705f49514bbb88260e20282faf8fb7d" translate="yes" xml:space="preserve">
          <source>On POSIX systems, if the file represented by this &lt;code&gt;DirEntry&lt;/code&gt; is a symbolic link, then attributes are the attributes of the file pointed to by the symbolic link.</source>
          <target state="translated">POSIX 시스템에서이 &lt;code&gt;DirEntry&lt;/code&gt; 가 나타내는 파일이 기호 링크 인 경우 속성은 기호 링크가 가리키는 파일의 속성입니다.</target>
        </trans-unit>
        <trans-unit id="e2e31315830b04ae65da3fad10a7a5040e90772b" translate="yes" xml:space="preserve">
          <source>On POSIX systems, if the given file is a symbolic link, then attributes are the attributes of the file pointed to by the symbolic link.</source>
          <target state="translated">POSIX 시스템에서 주어진 파일이 심볼릭 링크이면 속성은 심볼릭 링크가 가리키는 파일의 속성입니다.</target>
        </trans-unit>
        <trans-unit id="11fb04b0e94adc4b37deadc7deec14c85b8112c4" translate="yes" xml:space="preserve">
          <source>On POSIX systems, the signals SIGUSR1 and SIGUSR2 are reserved by this module for use in the garbage collector implementation. Typically, they will be used to stop and resume other threads when performing a collection, but an implementation may choose not to use this mechanism (or not stop the world at all, in the case of concurrent garbage collectors).</source>
          <target state="translated">POSIX 시스템에서 SIGUSR1 및 SIGUSR2 신호는 가비지 콜렉터 구현에 사용하기 위해이 모듈에 의해 예약됩니다. 일반적으로 컬렉션을 수행 할 때 다른 스레드를 중지하고 다시 시작하는 데 사용되지만 구현시이 메커니즘을 사용하지 않도록 선택할 수 있습니다 (또는 동시 가비지 수집기의 경우에는 절대로 중지하지 않음).</target>
        </trans-unit>
        <trans-unit id="634f31050bfb94bec5bce1f9c660501b7d894e03" translate="yes" xml:space="preserve">
          <source>On POSIX, &lt;code&gt;filename&lt;/code&gt; may not contain a forward slash (&lt;code&gt;'/'&lt;/code&gt;) or the null character (&lt;code&gt;'\0'&lt;/code&gt;).</source>
          <target state="translated">POSIX에서 &lt;code&gt;filename&lt;/code&gt; 은 슬래시 ( &lt;code&gt;'/'&lt;/code&gt; ) 나 널 문자 ( &lt;code&gt;'\0'&lt;/code&gt; )를 포함 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="d0e0b90e35d552ed53d8451ae83171f83caea058" translate="yes" xml:space="preserve">
          <source>On POSIX, &lt;code&gt;userShell&lt;/code&gt; returns the contents of the SHELL environment variable, if it exists and is non-empty. Otherwise, it returns the result of &lt;a href=&quot;#nativeShell&quot;&gt;&lt;code&gt;nativeShell&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">POSIX에서 &lt;code&gt;userShell&lt;/code&gt; 은 SHELL 환경 변수의 내용이 존재하고 비어 있지 않은 경우 내용을 반환합니다. 그렇지 않으면 &lt;a href=&quot;#nativeShell&quot;&gt; &lt;code&gt;nativeShell&lt;/code&gt; &lt;/a&gt; 의 결과를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="4a3691fb3a429f6f16c74dbb648019d4ea541a0d" translate="yes" xml:space="preserve">
          <source>On POSIX, an absolute path starts at the root directory. (In fact, &lt;code&gt;_isAbsolute&lt;/code&gt; is just an alias for &lt;a href=&quot;#isRooted&quot;&gt;&lt;code&gt;isRooted&lt;/code&gt;&lt;/a&gt;.)</source>
          <target state="translated">POSIX에서 절대 경로는 루트 디렉토리에서 시작합니다. 실제로 &lt;code&gt;_isAbsolute&lt;/code&gt; 는 isRooted 의 별칭 &lt;a href=&quot;#isRooted&quot;&gt; &lt;code&gt;isRooted&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9328600ddd5da0c6e6153313212760496891e5c2" translate="yes" xml:space="preserve">
          <source>On POSIX, open &lt;a href=&quot;http://en.wikipedia.org/wiki/File_descriptor&quot;&gt;file descriptors&lt;/a&gt; are by default inherited by the child process. As this may lead to subtle bugs when pipes or multiple threads are involved, &lt;a href=&quot;#spawnProcess&quot;&gt;&lt;code&gt;spawnProcess&lt;/code&gt;&lt;/a&gt; ensures that all file descriptors except the ones that correspond to standard input/output/error are closed in the child process when it starts. Use &lt;code&gt;inheritFDs&lt;/code&gt; to prevent this.</source>
          <target state="translated">POSIX에서 열린 &lt;a href=&quot;http://en.wikipedia.org/wiki/File_descriptor&quot;&gt;파일 디스크립터&lt;/a&gt; 는 기본적으로 하위 프로세스에 의해 상속됩니다. 파이프 나 다중 스레드가 관련된 경우 &lt;a href=&quot;#spawnProcess&quot;&gt; &lt;code&gt;spawnProcess&lt;/code&gt; &lt;/a&gt; 인해 미묘한 버그가 발생할 수 있으므로 spawnProcess 는 표준 입 / 출력 / 오류에 해당하는 것을 제외한 모든 파일 디스크립터가 시작될 때 하위 프로세스에서 닫히도록합니다. 이를 방지 하려면 &lt;code&gt;inheritFDs&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="85747f6e4924674e92ad7453145acc5d65591f4d" translate="yes" xml:space="preserve">
          <source>On POSIX, open &lt;a href=&quot;https://en.wikipedia.org/wiki/File_descriptor&quot;&gt;file descriptors&lt;/a&gt; are by default inherited by the child process. As this may lead to subtle bugs when pipes or multiple threads are involved, &lt;a href=&quot;#spawnProcess&quot;&gt;&lt;code&gt;spawnProcess&lt;/code&gt;&lt;/a&gt; ensures that all file descriptors except the ones that correspond to standard input/output/error are closed in the child process when it starts. Use &lt;code&gt;inheritFDs&lt;/code&gt; to prevent this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b54b1b6297751d78c6140482c90352354099820f" translate="yes" xml:space="preserve">
          <source>On Posix systems, if &lt;code&gt;attrIsFile&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, that indicates that the file is a regular file (e.g. not a block not device). So, on Posix systems, it's possible for both &lt;code&gt;attrIsFile&lt;/code&gt; and &lt;code&gt;attrIsDir&lt;/code&gt; to be &lt;code&gt;false&lt;/code&gt; for a particular file (in which case, it's a special file). If a file is a special file, you can use the attributes to check what type of special file it is (see the man page for &lt;code&gt;stat&lt;/code&gt; for more information).</source>
          <target state="translated">Posix 시스템에서 &lt;code&gt;attrIsFile&lt;/code&gt; 이 &lt;code&gt;true&lt;/code&gt; 인 경우 파일이 일반 파일임을 나타냅니다 (예 : 장치가 아닌 블록이 아님). 따라서 Posix 시스템에서 &lt;code&gt;attrIsFile&lt;/code&gt; 및 &lt;code&gt;attrIsDir&lt;/code&gt; 이 특정 파일에 대해 &lt;code&gt;false&lt;/code&gt; 일 수 있습니다 (이 경우 특수 파일). 파일이 특수 파일 인 경우 속성을 사용하여 파일이 어떤 유형의 특수 파일인지 확인할 수 있습니다 ( 자세한 내용 은 &lt;code&gt;stat&lt;/code&gt; 에 대한 매뉴얼 페이지 참조 ).</target>
        </trans-unit>
        <trans-unit id="a2aa8805027298573b997badd9027bbd45a19fdf" translate="yes" xml:space="preserve">
          <source>On Posix systems, if &lt;code&gt;isFile&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, that indicates that the file is a regular file (e.g. not a block not device). So, on Posix systems, it's possible for both &lt;code&gt;isFile&lt;/code&gt; and &lt;code&gt;isDir&lt;/code&gt; to be &lt;code&gt;false&lt;/code&gt; for a particular file (in which case, it's a special file). You can use &lt;code&gt;attributes&lt;/code&gt; or &lt;code&gt;statBuf&lt;/code&gt; to get more information about a special file (see the stat man page for more details).</source>
          <target state="translated">Posix 시스템에서 &lt;code&gt;isFile&lt;/code&gt; 이 &lt;code&gt;true&lt;/code&gt; 인 경우 파일이 일반 파일임을 나타냅니다 (예 : 장치가 아닌 블록이 아님). 따라서 Posix 시스템에서는 특정 파일 (이 경우 특수 파일) 에 대해 &lt;code&gt;isFile&lt;/code&gt; 과 &lt;code&gt;isDir&lt;/code&gt; 이 모두 &lt;code&gt;false&lt;/code&gt; 일 수 있습니다. &lt;code&gt;attributes&lt;/code&gt; 또는 &lt;code&gt;statBuf&lt;/code&gt; 를 사용 하여 특수 파일에 대한 자세한 정보를 얻을 수 있습니다 (자세한 내용은 stat 매뉴얼 페이지 참조).</target>
        </trans-unit>
        <trans-unit id="7fd705ae13245d54c6aa5a4b39418f4284c68396" translate="yes" xml:space="preserve">
          <source>On Posix systems, if &lt;code&gt;isFile&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, that indicates that the file is a regular file (e.g. not a block not device). So, on Posix systems, it's possible for both &lt;code&gt;isFile&lt;/code&gt; and &lt;code&gt;isDir&lt;/code&gt; to be &lt;code&gt;false&lt;/code&gt; for a particular file (in which case, it's a special file). You can use &lt;code&gt;getAttributes&lt;/code&gt; to get the attributes to figure out what type of special it is, or you can use &lt;code&gt;DirEntry&lt;/code&gt; to get at its &lt;code&gt;statBuf&lt;/code&gt;, which is the result from &lt;code&gt;stat&lt;/code&gt;. In either case, see the man page for &lt;code&gt;stat&lt;/code&gt; for more information.</source>
          <target state="translated">Posix 시스템에서 &lt;code&gt;isFile&lt;/code&gt; 이 &lt;code&gt;true&lt;/code&gt; 인 경우 파일이 일반 파일임을 나타냅니다 (예 : 장치가 아닌 블록이 아님). 따라서 Posix 시스템에서는 특정 파일 (이 경우 특수 파일) 에 대해 &lt;code&gt;isFile&lt;/code&gt; 과 &lt;code&gt;isDir&lt;/code&gt; 이 모두 &lt;code&gt;false&lt;/code&gt; 일 수 있습니다. 당신은 사용 &lt;code&gt;getAttributes&lt;/code&gt; 그것이 무엇인지 특별한 유형을 파악하는 속성을 얻기 위해, 또는 당신이 사용할 수있는 &lt;code&gt;DirEntry&lt;/code&gt; 를 자사에서 얻을 수 &lt;code&gt;statBuf&lt;/code&gt; 의 결과이며, &lt;code&gt;stat&lt;/code&gt; . 두 경우 모두 자세한 내용 은 &lt;code&gt;stat&lt;/code&gt; 매뉴얼 페이지 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b683a2ff2d5b15178674a689248bb8e41c5208aa" translate="yes" xml:space="preserve">
          <source>On Posix systems, if the file represented by this &lt;code&gt;DirEntry&lt;/code&gt; is a symbolic link, then &lt;code&gt;linkAttributes&lt;/code&gt; are the attributes of the symbolic link itself. Otherwise, &lt;code&gt;linkAttributes&lt;/code&gt; is identical to &lt;code&gt;attributes&lt;/code&gt;.</source>
          <target state="translated">Posix 시스템에서이 &lt;code&gt;DirEntry&lt;/code&gt; 로 표시되는 파일이 기호 링크 인 경우 &lt;code&gt;linkAttributes&lt;/code&gt; 는 기호 링크 자체의 속성입니다. 그렇지 않으면 &lt;code&gt;linkAttributes&lt;/code&gt; 는 &lt;code&gt;attributes&lt;/code&gt; 와 동일 합니다 .</target>
        </trans-unit>
        <trans-unit id="ffa58299e8f3542f3a6b4fc5fadc8c5816787d74" translate="yes" xml:space="preserve">
          <source>On Posix systems, if the file represented by this &lt;code&gt;DirEntry&lt;/code&gt; is a symbolic link, then attributes are the attributes of the file pointed to by the symbolic link.</source>
          <target state="translated">Posix 시스템에서이 &lt;code&gt;DirEntry&lt;/code&gt; 로 표시되는 파일이 기호 링크 인 경우 속성은 기호 링크가 가리키는 파일의 속성입니다.</target>
        </trans-unit>
        <trans-unit id="ecc95bd9a69a6a3b0487f7891f64eaab98150bdc" translate="yes" xml:space="preserve">
          <source>On Posix systems, if the given file is a symbolic link, then attributes are the attributes of the file pointed to by the symbolic link.</source>
          <target state="translated">Posix 시스템에서 제공된 파일이 기호 링크 인 경우 속성은 기호 링크가 가리키는 파일의 속성입니다.</target>
        </trans-unit>
        <trans-unit id="636f726f7fefb1663dba5a570f41553d8ae54c00" translate="yes" xml:space="preserve">
          <source>On Windows, &lt;code&gt;QueryPerformanceCounter&lt;/code&gt; is used. On Mac OS X, &lt;code&gt;mach_absolute_time&lt;/code&gt; is used, while on other POSIX systems, &lt;code&gt;clock_gettime&lt;/code&gt; is used.</source>
          <target state="translated">Windows에서는 &lt;code&gt;QueryPerformanceCounter&lt;/code&gt; 가 사용됩니다. Mac OS X에서는 &lt;code&gt;mach_absolute_time&lt;/code&gt; 이 사용되고 다른 POSIX 시스템에서는 &lt;code&gt;clock_gettime&lt;/code&gt; 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4d2300d27b62da0d46cd201ca4d3f5410d7109c6" translate="yes" xml:space="preserve">
          <source>On Windows, &lt;code&gt;QueryPerformanceCounter&lt;/code&gt; is used. On Mac OS X, &lt;code&gt;mach_absolute_time&lt;/code&gt; is used, while on other Posix systems, &lt;code&gt;clock_gettime&lt;/code&gt; is used. If &lt;code&gt;mach_absolute_time&lt;/code&gt; or &lt;code&gt;clock_gettime&lt;/code&gt; is unavailable, then Posix systems use &lt;code&gt;gettimeofday&lt;/code&gt; (the decision is made when &lt;code&gt;TickDuration&lt;/code&gt; is compiled), which unfortunately, is not monotonic, but if &lt;code&gt;mach_absolute_time&lt;/code&gt; and &lt;code&gt;clock_gettime&lt;/code&gt; aren't available, then &lt;code&gt;gettimeofday&lt;/code&gt; is the the best that there is.</source>
          <target state="translated">Windows에서는 &lt;code&gt;QueryPerformanceCounter&lt;/code&gt; 가 사용됩니다. Mac OS X에서는 &lt;code&gt;mach_absolute_time&lt;/code&gt; 이 사용되고 다른 Posix 시스템에서는 &lt;code&gt;clock_gettime&lt;/code&gt; 이 사용됩니다. 경우 &lt;code&gt;mach_absolute_time&lt;/code&gt; 또는 &lt;code&gt;clock_gettime&lt;/code&gt; 사용할 수 없습니다, 다음 POSIX 시스템 사용 &lt;code&gt;gettimeofday&lt;/code&gt; (때 결정이됩니다 &lt;code&gt;TickDuration&lt;/code&gt; 는 불행하게도, 단조 아닌 컴파일),하지만 경우 &lt;code&gt;mach_absolute_time&lt;/code&gt; 및 &lt;code&gt;clock_gettime&lt;/code&gt; 사용할 수 없습니다, 다음 &lt;code&gt;gettimeofday&lt;/code&gt; 이 있다는 최고입니다.</target>
        </trans-unit>
        <trans-unit id="b48a1d53fa4c43afbbe7a02df0466a054d761a29" translate="yes" xml:space="preserve">
          <source>On Windows, &lt;code&gt;linkAttributes&lt;/code&gt; is identical to &lt;code&gt;attributes&lt;/code&gt;. It exists on Windows so that you don't have to special-case code for Windows when dealing with symbolic links.</source>
          <target state="translated">Windows에서 &lt;code&gt;linkAttributes&lt;/code&gt; 는 &lt;code&gt;attributes&lt;/code&gt; 와 동일 합니다 . Windows에 존재하므로 기호 링크를 처리 할 때 Windows 용으로 특수 코드를 작성할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="351080dce35982b0252c23f3a69184cf9d5c3306" translate="yes" xml:space="preserve">
          <source>On Windows, an absolute path starts at the root directory of a specific drive. Hence, it must start with &lt;code&gt;d:\&lt;/code&gt; or &lt;code&gt;d:/&lt;/code&gt;, where &lt;code&gt;d&lt;/code&gt; is the drive letter. Alternatively, it may be a network path, i.e. a path starting with a double (back)slash.</source>
          <target state="translated">Windows에서는 절대 경로가 특정 드라이브의 루트 디렉토리에서 시작합니다. 따라서 &lt;code&gt;d:\&lt;/code&gt; 또는 &lt;code&gt;d:/&lt;/code&gt; 로 시작해야합니다 . 여기서 &lt;code&gt;d&lt;/code&gt; 는 드라이브 문자입니다. 또는 네트워크 경로, 즉 이중 (백) 슬래시로 시작하는 경로 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef889b88d5f8d9f110b38f728621564638f95148" translate="yes" xml:space="preserve">
          <source>On Windows, getLinkAttributes is identical to getAttributes. It exists on Windows so that you don't have to special-case code for Windows when dealing with symbolic links.</source>
          <target state="translated">Windows에서 getLinkAttributes는 getAttributes와 동일합니다. Windows에 존재하므로 기호 링크를 처리 할 때 Windows 용으로 특수 코드를 작성할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="83d56815cf3e0a92c059f5d90df1eac05f0a2d5a" translate="yes" xml:space="preserve">
          <source>On Windows, if a file is not a directory, it's a file. So, either &lt;code&gt;attrIsFile&lt;/code&gt; or &lt;code&gt;attrIsDir&lt;/code&gt; will return &lt;code&gt;true&lt;/code&gt; for the attributes of any given file.</source>
          <target state="translated">Windows에서 파일이 디렉토리가 아닌 경우 파일입니다. 따라서 &lt;code&gt;attrIsFile&lt;/code&gt; 또는 &lt;code&gt;attrIsDir&lt;/code&gt; 은 지정된 파일의 속성에 대해 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="1aab655e5665ce1bcef7e3ab64bb515a54733705" translate="yes" xml:space="preserve">
          <source>On Windows, if a file is not a directory, then it's a file. So, either &lt;code&gt;isFile&lt;/code&gt; or &lt;code&gt;isDir&lt;/code&gt; will return &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Windows에서 파일이 디렉토리가 아닌 경우 파일입니다. 따라서 &lt;code&gt;isFile&lt;/code&gt; 또는 &lt;code&gt;isDir&lt;/code&gt; 은 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="ea0db99b4ebaafbafa1c6111ac04353baf182a15" translate="yes" xml:space="preserve">
          <source>On Windows, if a file is not a directory, then it's a file. So, either &lt;code&gt;isFile&lt;/code&gt; or &lt;code&gt;isDir&lt;/code&gt; will return true for any given file.</source>
          <target state="translated">Windows에서 파일이 디렉토리가 아닌 경우 파일입니다. 따라서 &lt;code&gt;isFile&lt;/code&gt; 또는 &lt;code&gt;isDir&lt;/code&gt; 은 지정된 파일에 대해 true를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fa47af1c2c285a0bc4fbd19f4b9ef76dfda0eeac" translate="yes" xml:space="preserve">
          <source>On Windows, if one of the path segments are rooted, but not absolute (e.g. &lt;code&gt;\foo&lt;/code&gt;), all preceding path segments down to the previous root will be dropped. (See below for an example.)</source>
          <target state="translated">Windows에서 경로 세그먼트 중 하나가 루팅되었지만 절대가 아닌 경우 (예 : &lt;code&gt;\foo&lt;/code&gt; ) 이전 루트까지의 모든 이전 경로 세그먼트가 삭제됩니다. (예는 아래를 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="04bdf7dfecb2b33004ea9f8e5d6767d50c5920f7" translate="yes" xml:space="preserve">
          <source>On Windows, if the child process is a console application, this flag will prevent the creation of a console window. Otherwise, it will be ignored. On POSIX, &lt;code&gt;suppressConsole&lt;/code&gt; has no effect.</source>
          <target state="translated">Windows에서 하위 프로세스가 콘솔 애플리케이션 인 경우이 플래그는 콘솔 창을 작성하지 못하게합니다. 그렇지 않으면 무시됩니다. POSIX에서 &lt;code&gt;suppressConsole&lt;/code&gt; 은 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="aad4687f823a3f85d5221f0d0f2539e9f2c12f2e" translate="yes" xml:space="preserve">
          <source>On Windows, return &lt;code&gt;true&lt;/code&gt; when the file is either a symbolic link or a junction point.</source>
          <target state="translated">Windows 에서 파일이 기호 링크 또는 접합점 인 경우 &lt;code&gt;true&lt;/code&gt; 를 리턴 하십시오.</target>
        </trans-unit>
        <trans-unit id="7b3d24f7c6deac05d17ed8c47b6c79d39c04c3ba" translate="yes" xml:space="preserve">
          <source>On Windows, returns &lt;code&gt;true&lt;/code&gt; when the file is either a symbolic link or a junction point.</source>
          <target state="translated">Windows 에서 파일이 기호 링크 또는 접합점 인 경우 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 .</target>
        </trans-unit>
        <trans-unit id="f9d78f59bff80dcbd1041e4971f0971b9fc3cd58" translate="yes" xml:space="preserve">
          <source>On Windows, some special rules apply:</source>
          <target state="translated">Windows에서는 몇 가지 특수 규칙이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="433c117c547e883a7bdf6c423ef1bcfb810068f6" translate="yes" xml:space="preserve">
          <source>On Windows, the backslash and slash characters (&lt;code&gt;\&lt;/code&gt; and &lt;code&gt;/&lt;/code&gt;) are considered equal.</source>
          <target state="translated">Windows에서 백 슬래시 및 슬래시 문자 ( &lt;code&gt;\&lt;/code&gt; 및 &lt;code&gt;/&lt;/code&gt; )는 동일한 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="4a88c798e54629c5adeb41273aa766dfd9577b5b" translate="yes" xml:space="preserve">
          <source>On Windows, the following criteria must be satisfied (&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/aa365247(v=vs.85).aspx&quot;&gt;source&lt;/a&gt;):</source>
          <target state="translated">Windows에서 다음 기준을 충족해야합니다 ( &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/aa365247(v=vs.85).aspx&quot;&gt;source&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="894bc9534cb0534362111fa17310abe22aaf9de0" translate="yes" xml:space="preserve">
          <source>On Windows, the following criteria must be satisfied (&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/aa365247(v=vs.85).aspx&quot;&gt;source&lt;/a&gt;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9779d7c68a633ae64f68af4b0e5a5c47a042da7" translate="yes" xml:space="preserve">
          <source>On Windows, this function returns the contents of the COMSPEC environment variable, if it exists. Otherwise, it returns the result of &lt;a href=&quot;#nativeShell&quot;&gt;&lt;code&gt;nativeShell&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Windows에서이 함수는 COMSPEC 환경 변수 (있는 경우)의 내용을 리턴합니다. 그렇지 않으면 &lt;a href=&quot;#nativeShell&quot;&gt; &lt;code&gt;nativeShell&lt;/code&gt; &lt;/a&gt; 의 결과를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="79eb2a6d7769617f87ca1be1841f02158f05836a" translate="yes" xml:space="preserve">
          <source>On Windows, this function returns the result of calling the Windows API function &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/windows/desktop/aa364992.aspx&quot;&gt;&lt;code&gt;GetTempPath&lt;/code&gt;&lt;/a&gt;.  On POSIX platforms, it searches through the following list of directories and returns the first one which is found to exist:</source>
          <target state="translated">Windows에서이 함수는 Windows API 함수 &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/windows/desktop/aa364992.aspx&quot;&gt; &lt;code&gt;GetTempPath&lt;/code&gt; &lt;/a&gt; 를 호출 한 결과를 리턴합니다 . POSIX 플랫폼에서 다음 디렉토리 목록을 검색하여 존재하는 첫 번째 디렉토리를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="be6f4f2e6c1a9602cee7f53d250ab48479a080bc" translate="yes" xml:space="preserve">
          <source>On Windows, this function returns the result of calling the Windows API function &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/aa364992.aspx&quot;&gt;&lt;code&gt;GetTempPath&lt;/code&gt;&lt;/a&gt;.  On POSIX platforms, it searches through the following list of directories and returns the first one which is found to exist:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc8accd97298f49fccac8e9aa1187ff12d77a0a0" translate="yes" xml:space="preserve">
          <source>On Windows, this includes both &lt;code&gt;\&lt;/code&gt; and &lt;code&gt;/&lt;/code&gt;. On POSIX, it's just &lt;code&gt;/&lt;/code&gt;.</source>
          <target state="translated">Windows의 경우 &lt;code&gt;\&lt;/code&gt; 및 &lt;code&gt;/&lt;/code&gt; 가 모두 포함됩니다 . POSIX에서는 단지 &lt;code&gt;/&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="275ea90ff2dff3a9dead6ab2157264ecd02c6a5b" translate="yes" xml:space="preserve">
          <source>On Windows, this option has no effect, and any handles which have been explicitly marked as inheritable will always be inherited by the child process.</source>
          <target state="translated">Windows에서는이 옵션이 적용되지 않으며 상속 가능으로 명시 적으로 표시된 핸들은 항상 하위 프로세스에서 상속됩니다.</target>
        </trans-unit>
        <trans-unit id="e85c0978a77279c90b22ae8dd33a1d55444d1a0f" translate="yes" xml:space="preserve">
          <source>On all platforms, &lt;code&gt;tempDir&lt;/code&gt; returns &lt;code&gt;&quot;.&quot;&lt;/code&gt; on failure, representing the current working directory.</source>
          <target state="translated">모든 플랫폼에서 &lt;code&gt;tempDir&lt;/code&gt; 은 &lt;code&gt;&quot;.&quot;&lt;/code&gt; 을 반환합니다 . 실패시 현재 작업 디렉토리를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="8adc4328682a5c7505adf3df0ba7bb17ee427f01" translate="yes" xml:space="preserve">
          <source>On function literals, return type may be modified based on the context type after its semantic3 is done, in FuncExp::implicitCastTo.</source>
          <target state="translated">함수 리터럴에서 반환 유형은 FuncExp :: implicitCastTo에서 시맨틱 3이 완료된 후 컨텍스트 유형에 따라 수정 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a2267eb64b3a3d0bdb354c3d04c12d89c9a317c3" translate="yes" xml:space="preserve">
          <source>On many computers, greater precision operations do not take any longer than lesser precision operations, so it makes numerical sense to use the greatest precision available for internal temporaries. The philosophy is not to dumb down the language to the lowest common hardware denominator, but to enable the exploitation of the best capabilities of target hardware.</source>
          <target state="translated">많은 컴퓨터에서 더 정밀한 작업은 덜 정밀한 작업보다 오래 걸리지 않으므로 내부 임시에 사용할 수있는 최대 정밀도를 사용하는 것이 좋습니다. 철학은 언어를 가장 낮은 공통 하드웨어 분모로 낮추는 것이 아니라 대상 하드웨어의 최상의 기능을 활용할 수 있도록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="53a5882afe52725f67a0137bd88f746ad80234d9" translate="yes" xml:space="preserve">
          <source>On many platforms, catching C++ class objects is supported. Catching C++ objects and D objects cannot both be done in the same</source>
          <target state="translated">많은 플랫폼에서 C ++ 클래스 개체를 잡는 것이 지원됩니다. C ++ 객체와 D 객체를 동시에 잡을 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="b9cd670388212aa6ebdb79e448445941831f1d67" translate="yes" xml:space="preserve">
          <source>On single-core machines, the primitives provided by &lt;code&gt;TaskPool&lt;/code&gt; operate transparently in single-threaded mode.</source>
          <target state="translated">단일 코어 시스템에서 &lt;code&gt;TaskPool&lt;/code&gt; 이 제공하는 프리미티브 는 단일 스레드 모드에서 투명하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="65eeec28a4ec73def9ce753282e4a733d2b218e6" translate="yes" xml:space="preserve">
          <source>On some platforms, modifying environment variables may not be allowed in multi-threaded programs. See e.g. &lt;a href=&quot;https://www.gnu.org/software/libc/manual/html_node/Environment-Access.html#Environment-Access&quot;&gt;glibc&lt;/a&gt;.</source>
          <target state="translated">일부 플랫폼에서는 다중 스레드 프로그램에서 환경 변수 수정이 허용되지 않을 수 있습니다. 예를 들어 &lt;a href=&quot;https://www.gnu.org/software/libc/manual/html_node/Environment-Access.html#Environment-Access&quot;&gt;glibc를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2579191de4bc3eb8840f26a4ccade11d869046e5" translate="yes" xml:space="preserve">
          <source>On success returns the composed LV or LVT hangul syllable.</source>
          <target state="translated">성공하면 작성된 LV 또는 LVT 한글 음절을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1e477d55ecee9b240368d12b85daa6ac9107cc3f" translate="yes" xml:space="preserve">
          <source>On success, the function returns the number of variables filled. This count can match the expected number of readings or fewer, even zero, if a matching failure happens.</source>
          <target state="translated">성공하면 함수는 채워진 변수 수를 반환합니다. 이 횟수는 일치하는 오류가 발생하는 경우 예상 판독 수 이하 또는 심지어 0까지 일치 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9423c42e5e2d607971a466fc971dcc3d4c06beee" translate="yes" xml:space="preserve">
          <source>On systems which do not support a coarser clock, &lt;code&gt;MonoTimeImpl!(ClockType.coarse)&lt;/code&gt; will internally use the same clock as &lt;code&gt;Monotime&lt;/code&gt; does, and &lt;code&gt;Clock.currTime!(ClockType.coarse)&lt;/code&gt; will use the same clock as &lt;code&gt;Clock.currTime&lt;/code&gt;. This is because the coarse clock is doing the same thing as the normal clock (just at lower precision), whereas some of the other clock types (e.g. &lt;code&gt;ClockType.processCPUTime&lt;/code&gt;) mean something fundamentally different. So, treating those as &lt;code&gt;ClockType.normal&lt;/code&gt; on systems where they weren't natively supported would give misleading results.</source>
          <target state="translated">조잡한 시계, 지원하지 않는 시스템에 &lt;code&gt;MonoTimeImpl!(ClockType.coarse)&lt;/code&gt; 로 내부적으로 동일한 클럭을 사용합니다 &lt;code&gt;Monotime&lt;/code&gt; 가 수행하고 &lt;code&gt;Clock.currTime!(ClockType.coarse)&lt;/code&gt; 와 같은 클럭 사용 &lt;code&gt;Clock.currTime&lt;/code&gt; 을 . 이는 대략적인 클럭이 일반 클럭과 동일한 작업을 수행하지만 (낮은 정밀도로) 다른 클럭 유형 (예 : &lt;code&gt;ClockType.processCPUTime&lt;/code&gt; )은 근본적으로 다른 것을 의미하기 때문입니다. 따라서 기본적으로 지원되지 않는 시스템에서 &lt;code&gt;ClockType.normal&lt;/code&gt; 로 처리 하면 오해의 소지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b968233be4d9a26515726f1fa55ef5fc7adc2c1" translate="yes" xml:space="preserve">
          <source>On the other hand, disabling the bounds check in &lt;code&gt;@safe&lt;/code&gt; code will break the guaranteed memory safety by compiler. It's not recommended unless motivated by speed measurements.</source>
          <target state="translated">반면 &lt;code&gt;@safe&lt;/code&gt; 코드 에서 범위 검사를 비활성화하면 컴파일러의 보장 된 메모리 안전성이 손상됩니다. 속도 측정에 의해 동기가 부여되지 않는 한 권장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5686721515d33ea6d5f3f835d28e7583ce16b2b0" translate="yes" xml:space="preserve">
          <source>OnCrowding &lt;code&gt;doThis&lt;/code&gt;</source>
          <target state="translated">OnCrowding &lt;code&gt;doThis&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="136de9961eb08dceeff5dec3d02243e1d4794113" translate="yes" xml:space="preserve">
          <source>Once &lt;a href=&quot;#wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; has been called on the &lt;a href=&quot;#Pid&quot;&gt;&lt;code&gt;Pid&lt;/code&gt;&lt;/a&gt;, this method will return an invalid handle.</source>
          <target state="translated">&lt;a href=&quot;#Pid&quot;&gt; &lt;code&gt;Pid&lt;/code&gt; &lt;/a&gt; 에서 &lt;a href=&quot;#wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; 가 호출 되면 이 메소드는 유효하지 않은 핸들을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="1cdbbf32331fe81da47f44a31f5d3b1a122a8e37" translate="yes" xml:space="preserve">
          <source>Once S has been determined, then &lt;code&gt;S s = e;&lt;/code&gt; and &lt;code&gt;s = f(s, e);&lt;/code&gt; must both be legal.</source>
          <target state="translated">S가 결정되면, &lt;code&gt;S s = e;&lt;/code&gt; 그리고 &lt;code&gt;s = f(s, e);&lt;/code&gt; 둘 다 합법적이어야합니다.</target>
        </trans-unit>
        <trans-unit id="fce1b7cfb7dff703df3fdeab9bc79a1b2ae11a43" translate="yes" xml:space="preserve">
          <source>Once instantiated, the declarations inside the template, called the template members, are in the scope of the</source>
          <target state="translated">인스턴스화되면 템플릿 멤버라는 템플릿 내부의 선언은</target>
        </trans-unit>
        <trans-unit id="f63c93929ae7b3005633933b34e6827b3a5df78e" translate="yes" xml:space="preserve">
          <source>Once slice are used everywhere and &lt;code&gt;\0&lt;/code&gt; is not assumed, this can be turned into a simple slicing.</source>
          <target state="translated">슬라이스가 모든 곳에서 사용되고 &lt;code&gt;\0&lt;/code&gt; 이 가정되지 않으면 이것은 간단한 슬라이싱으로 전환 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="177b7637cfdda24d637e80021941e40011fc4e80" translate="yes" xml:space="preserve">
          <source>Once the chunk is exhausted, the Kernighan-Ritchie allocator allocates another chunk using operating system primitives. For better composability, &lt;code&gt;KRRegion&lt;/code&gt; just gets full (returns &lt;code&gt;null&lt;/code&gt; on new allocation requests). The decision to allocate more blocks is deferred to a higher-level entity. For an example, see the example below using &lt;code&gt;AllocatorList&lt;/code&gt; in conjunction with &lt;code&gt;KRRegion&lt;/code&gt;.</source>
          <target state="translated">청크가 소진되면 Kernighan-Ritchie 할당자는 운영 체제 기본 요소를 사용하여 다른 청크를 할당합니다. 더 나은 컴포지션을 위해 &lt;code&gt;KRRegion&lt;/code&gt; 은 가득 찼습니다 ( 새 할당 요청에서 &lt;code&gt;null&lt;/code&gt; 을 반환 함 ). 더 많은 블록을 할당하기로 한 결정은 상위 수준 엔터티로 연기됩니다. 예를 들어 &lt;code&gt;KRRegion&lt;/code&gt; 과 함께 &lt;code&gt;AllocatorList&lt;/code&gt; 를 사용하는 아래 예를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f58a3a2810943bb8e1377bf6e7c64c4eacbf25ce" translate="yes" xml:space="preserve">
          <source>Once the delegate constructor returns, all fields are considered constructed.</source>
          <target state="translated">델리게이트 생성자가 반환되면 모든 필드가 구성된 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="91e823edbcc801d13e817ea3fe4b7d952fa31c95" translate="yes" xml:space="preserve">
          <source>Once the delegating constructor returns, all fields are considered constructed.</source>
          <target state="translated">위임 생성자가 반환되면 모든 필드가 구성된 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="b11a10ea8965ed2cfd66ad0ada41f8d84d4d8538" translate="yes" xml:space="preserve">
          <source>Once the region cannot serve an &lt;code&gt;allocate&lt;/code&gt; request, &lt;code&gt;KRRegion&lt;/code&gt; switches to &quot;free list&quot; mode. It sorts the list of previously deallocated blocks by address and serves allocation requests off that free list. The allocation and deallocation follow the pattern described by Kernighan and Ritchie.</source>
          <target state="translated">리전이 &lt;code&gt;allocate&lt;/code&gt; 요청을 처리 할 수 없으면 &lt;code&gt;KRRegion&lt;/code&gt; 은 &quot;자유 목록&quot;모드로 전환합니다. 이전에 할당 해제 된 블록 목록을 주소별로 정렬하고 해당 사용 가능 목록에서 할당 요청을 처리합니다. 할당 및 할당 해제는 Kernighan 및 Ritchie가 설명한 패턴을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="ca3be77a39a2b5fa5cbfec1787bdf7c9ae146013" translate="yes" xml:space="preserve">
          <source>One allocation pattern used in multithreaded applications is to share memory across threads, and to deallocate blocks in a different thread than the one that allocated it.</source>
          <target state="translated">다중 스레드 응용 프로그램에서 사용되는 하나의 할당 패턴은 스레드간에 메모리를 공유하고 할당 된 스레드와 다른 스레드에서 블록을 할당 해제하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e48630c4869fa52074205f4f0540ce50688f767d" translate="yes" xml:space="preserve">
          <source>One can also generate the</source>
          <target state="translated">하나는 또한 생성 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="a2aff6d254edcd8887f3a6f1cc2a273d785eb489" translate="yes" xml:space="preserve">
          <source>One can also hash ubyte data piecewise by instanciating a hasher and call the 'put' method.</source>
          <target state="translated">또한 hasher를 설정하고 'put'메소드를 호출하여 ubyte 데이터를 부분적으로 해시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f741df140a81582ebc9d066ceb30b9c0a1abe1d0" translate="yes" xml:space="preserve">
          <source>One can avoid using pointers anyway for most tasks. D provides features rendering most explicit pointer uses obsolete, such as reference objects, dynamic arrays, and garbage collection. Pointers are provided in order to interface successfully with C APIs and for some low level work.</source>
          <target state="translated">어쨌든 대부분의 작업에 포인터를 사용하지 않아도됩니다. D는 참조 객체, 동적 배열 및 가비지 수집과 같이 가장 명시적인 포인터를 사용하지 않는 렌더링 기능을 제공합니다. C API와 성공적으로 인터페이스하고 일부 저수준 작업을 위해 포인터가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="90d544a3f6a256ab611c54b6c404983ee546b81c" translate="yes" xml:space="preserve">
          <source>One can thus generate the even permutations of a range with unique elements by starting with the lexicographically smallest permutation, and repeatedly calling nextEvenPermutation until it returns false.</source>
          <target state="translated">따라서 사 전적으로 가장 작은 순열로 시작하여 false를 반환 할 때까지 nextEvenPermutation을 반복해서 호출하여 고유 한 요소로 범위의 짝수 순열을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="534eda1fa053a01173b27dcb3d6cc652086074b9" translate="yes" xml:space="preserve">
          <source>One important consequence of &lt;code&gt;destroy&lt;/code&gt; is that it will call the destructor of the &lt;code&gt;T&lt;/code&gt; payload. GC-managed references are not guaranteed to be valid during a destructor call, but other members of &lt;code&gt;T&lt;/code&gt;, such as file handles or pointers to &lt;code&gt;malloc&lt;/code&gt; memory, will still be valid during the destructor call. This allows the &lt;code&gt;T&lt;/code&gt; to deallocate or clean up any non-GC resources immediately after the reference count has reached zero.</source>
          <target state="translated">&lt;code&gt;destroy&lt;/code&gt; 중요한 결과 는 &lt;code&gt;T&lt;/code&gt; 페이로드 의 소멸자를 호출한다는 것입니다 . GC 관리 참조는 소멸자 호출 중에는 유효하지 않지만 파일 핸들 또는 &lt;code&gt;malloc&lt;/code&gt; 메모리에 대한 포인터와 같은 &lt;code&gt;T&lt;/code&gt; 의 다른 멤버 는 소멸자 호출 중에도 여전히 유효합니다. 이를 통해 &lt;code&gt;T&lt;/code&gt; 는 참조 카운트가 0에 도달 한 직후 비 GC 리소스를 할당 해제하거나 정리할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d289613b2b905b9b8c968b576d93e4b8155280ac" translate="yes" xml:space="preserve">
          <source>One instantiation is of particular interest: &lt;code&gt;FreeList!(0, unbounded)&lt;/code&gt; puts every deallocation in the freelist, and subsequently serves any allocation from the freelist (if not empty). There is no checking of size matching, which would be incorrect for a freestanding allocator but is both correct and fast when an owning allocator on top of the free list allocator (such as &lt;code&gt;Segregator&lt;/code&gt;) is already in charge of handling size checking.</source>
          <target state="translated">한 가지 인스턴스화가 특히 중요합니다. &lt;code&gt;FreeList!(0, unbounded)&lt;/code&gt; 모든 할당 해제를 사용 가능리스트에 넣은 후 사용 가능리스트로부터 할당을 제공합니다 (비어 있지 않은 경우). 크기 일치 검사는 없습니다. 이는 독립형 할당 자에게는 올바르지 않지만 자유 목록 할당 자 (예 : &lt;code&gt;Segregator&lt;/code&gt; ) 위에있는 소유 할당자가 이미 크기 검사를 처리 하고있을 때 정확하고 빠릅니다 .</target>
        </trans-unit>
        <trans-unit id="b8bb08b9cf98dd6c73c6dc0c7e52247a78ee67c4" translate="yes" xml:space="preserve">
          <source>One of</source>
          <target state="translated">중 하나</target>
        </trans-unit>
        <trans-unit id="6b6f69412e7b5746bc4bc3d10bafa7869eb676ad" translate="yes" xml:space="preserve">
          <source>One of the following UTF BOMs (Byte Order Marks) can be present at the beginning of the source text:</source>
          <target state="translated">소스 텍스트의 시작 부분에 다음 UTF BOM (바이트 순서 표시) 중 하나가 존재할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="187dc51ce92272932644e64e0c07f2ddfef5985d" translate="yes" xml:space="preserve">
          <source>One or more items to search for. Each of &lt;code&gt;needles&lt;/code&gt; must be either comparable to one element in &lt;code&gt;haystack&lt;/code&gt;, or be itself a forward range with elements comparable with elements in &lt;code&gt;haystack&lt;/code&gt;.</source>
          <target state="translated">검색 할 하나 이상의 항목입니다. 각각의 &lt;code&gt;needles&lt;/code&gt; 하나 개의 소자로 하나 필적해야 &lt;code&gt;haystack&lt;/code&gt; , 또는 자체의 요소와 유사한 요소가 전진 기어 될 &lt;code&gt;haystack&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b04f89f4dcaf4692c37fd3a834b169482f64078c" translate="yes" xml:space="preserve">
          <source>One reason a custom &lt;code&gt;opAssign&lt;/code&gt; might be more efficient is if the struct has a reference to a local buffer:</source>
          <target state="translated">커스텀 &lt;code&gt;opAssign&lt;/code&gt; 이 더 효율적인 이유 중 하나 는 구조체에 로컬 버퍼에 대한 참조가있는 경우입니다.</target>
        </trans-unit>
        <trans-unit id="bb45ebddbc06dea87936ffc85870161ed923a01d" translate="yes" xml:space="preserve">
          <source>One solution is to use &lt;code&gt;scope(exit)&lt;/code&gt;:</source>
          <target state="translated">한 가지 해결책은 &lt;code&gt;scope(exit)&lt;/code&gt; 를 사용하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="17f5a4fe2f5c62ecd81776d246b8c0c725190c25" translate="yes" xml:space="preserve">
          <source>One-Step Query Execution Interface</source>
          <target state="translated">원스텝 쿼리 실행 인터페이스</target>
        </trans-unit>
        <trans-unit id="84ecd14ddbadabe468f63832d803f2392f405f33" translate="yes" xml:space="preserve">
          <source>Online Backup API.</source>
          <target state="translated">온라인 백업 API.</target>
        </trans-unit>
        <trans-unit id="df4435ab96f572a5ddc0d0575dab3a2326c426c1" translate="yes" xml:space="preserve">
          <source>Online Backup Object</source>
          <target state="translated">온라인 백업 개체</target>
        </trans-unit>
        <trans-unit id="e405ce24fb1f95bf28e59992555ee4472e0a1bb7" translate="yes" xml:space="preserve">
          <source>Only Zip version 20 formats are supported.</source>
          <target state="translated">Zip 버전 20 형식 만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="5c244cec2fec4515775043a5c26290f2816cde2e" translate="yes" xml:space="preserve">
          <source>Only called from the driver after platform detection, and internally.</source>
          <target state="translated">플랫폼 감지 후 내부적으로 만 드라이버에서 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="ecb587b264a111fa4057abd83cb3c0390dc38177" translate="yes" xml:space="preserve">
          <source>Only called from the driver for &lt;code&gt;-version=Ident&lt;/code&gt; parameters. Will raise an error if the identifier is reserved.</source>
          <target state="translated">드라이버에서 &lt;code&gt;-version=Ident&lt;/code&gt; 매개 변수에 대해서만 호출됩니다 . 식별자가 예약되어 있으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="cce934e34ed04bb926cd8169afbbec8aaf23e272" translate="yes" xml:space="preserve">
          <source>Only defined if &lt;code&gt;hasLength!R&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;hasLength!R&lt;/code&gt; 이 &lt;code&gt;true&lt;/code&gt; 인 경우에만 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="862399b467677fba43c9d502817d5f0b7647d65a" translate="yes" xml:space="preserve">
          <source>Only defined if &lt;code&gt;hasMobileElements!R&lt;/code&gt; and &lt;code&gt;isBidirectionalRange!R&lt;/code&gt; are &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;hasMobileElements!R&lt;/code&gt; 및 &lt;code&gt;isBidirectionalRange!R&lt;/code&gt; 이 &lt;code&gt;true&lt;/code&gt; 인 경우에만 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="1d299cfaa7b726004904048bdbbeff2a23f9537e" translate="yes" xml:space="preserve">
          <source>Only defined if &lt;code&gt;hasMobileElements!R&lt;/code&gt; and &lt;code&gt;isForwardRange!R&lt;/code&gt; are &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;hasMobileElements!R&lt;/code&gt; 및 &lt;code&gt;isForwardRange!R&lt;/code&gt; 이 &lt;code&gt;true&lt;/code&gt; 인 경우에만 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="f0e1549e42e36af6cc4f14382860c43f58ce9d4a" translate="yes" xml:space="preserve">
          <source>Only defined if &lt;code&gt;hasMobileElements!R&lt;/code&gt; and &lt;code&gt;isRandomAccessRange!R&lt;/code&gt; are &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;hasMobileElements!R&lt;/code&gt; 및 isRandomAccessRange &lt;code&gt;isRandomAccessRange!R&lt;/code&gt; 이 &lt;code&gt;true&lt;/code&gt; 인 경우에만 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="fd3e276381109f7d629a5c36b61768f82d6512c0" translate="yes" xml:space="preserve">
          <source>Only defined if &lt;code&gt;hasSlicing!R&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;hasSlicing!R&lt;/code&gt; 이 &lt;code&gt;true&lt;/code&gt; 인 경우에만 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="3d00e6646d856997df194a6a9af40811b56eb10b" translate="yes" xml:space="preserve">
          <source>Only defined if &lt;code&gt;isBidirectionalRange!R&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;isBidirectionalRange!R&lt;/code&gt; 이 &lt;code&gt;true&lt;/code&gt; 인 경우에만 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="dd62d4c49545ff383b28dc672873e780186fe504" translate="yes" xml:space="preserve">
          <source>Only defined if &lt;code&gt;isForwardRange!R&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;isForwardRange!R&lt;/code&gt; 이 &lt;code&gt;true&lt;/code&gt; 인 경우에만 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="9b544462107afa42f4718c874cde66fe7b0ee37b" translate="yes" xml:space="preserve">
          <source>Only defined if &lt;code&gt;isRandomAccesRange!R&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;isRandomAccesRange!R&lt;/code&gt; 이 &lt;code&gt;true&lt;/code&gt; 인 경우에만 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="9236b4e0fe39b6bde2da99e0cff381a33d1b78c9" translate="yes" xml:space="preserve">
          <source>Only do checking in &lt;code&gt;@safe&lt;/code&gt; functions</source>
          <target state="translated">&lt;code&gt;@safe&lt;/code&gt; 함수 에서만 체크인</target>
        </trans-unit>
        <trans-unit id="2a79fded6bf47650a5682e0a8be99f79c6ff2e9c" translate="yes" xml:space="preserve">
          <source>Only one module per file.</source>
          <target state="translated">파일 당 하나의 모듈 만.</target>
        </trans-unit>
        <trans-unit id="129f862b4645a9b5bc42ca61dd870b0c6bcad71c" translate="yes" xml:space="preserve">
          <source>Only spans one directory.</source>
          <target state="translated">하나의 디렉토리에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="df00b3a1891c04db004975eb707f42e43dced5b0" translate="yes" xml:space="preserve">
          <source>Only supports compression modes 0 (no compression) and 8 (deflate).</source>
          <target state="translated">압축 모드 0 (압축 없음) 및 8 (압축) 만 지원합니다.</target>
        </trans-unit>
        <trans-unit id="e57c5241662851c301803a684716b28d4ece2aaf" translate="yes" xml:space="preserve">
          <source>Only the following characters are considered whitespace in XML - space, tab, carriage return and linefeed</source>
          <target state="translated">공백, 탭, 캐리지 리턴 및 줄 바꿈-XML에서 공백으로 간주되는 문자는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9f64b8772cea113059e2d85e8c2f762ed6fbe026" translate="yes" xml:space="preserve">
          <source>Only the option directly following &lt;code&gt;std.getopt.config.required&lt;/code&gt; is required.</source>
          <target state="translated">&lt;code&gt;std.getopt.config.required&lt;/code&gt; 바로 뒤에 오는 옵션 만 필요합니다.</target>
        </trans-unit>
        <trans-unit id="a406a3ee3a63cb5ed2bd5dd188ac986593baee94" translate="yes" xml:space="preserve">
          <source>Only used for numeric, bool, null, char, string, enum and pointer types. Specifies the minimum field width. If the width is a &lt;b&gt;*&lt;/b&gt;, an additional argument of type &lt;b&gt;int&lt;/b&gt;, preceding the actual argument, is taken as the width. If the width is negative, it is as if the &lt;b&gt;-&lt;/b&gt; was given as a</source>
          <target state="translated">숫자, 부울, 널, 문자, 문자열, 열거 형 및 포인터 유형에만 사용됩니다. 최소 필드 너비를 지정합니다. 너비가 &lt;b&gt;*&lt;/b&gt; 이면 실제 인수 앞에있는 &lt;b&gt;int&lt;/b&gt; 유형의 추가 인수가 너비로 간주됩니다. 너비가 음수이면 &lt;b&gt;-&lt;/b&gt; 가</target>
        </trans-unit>
        <trans-unit id="f6005ab5c2001db5a0f58c1bdc79e5b2f49a7e5f" translate="yes" xml:space="preserve">
          <source>Only valid after semantic analysis.</source>
          <target state="translated">의미 분석 후에 만 ​​유효합니다.</target>
        </trans-unit>
        <trans-unit id="56c1872362aaadddaf17d1f0853543a1c5383ad6" translate="yes" xml:space="preserve">
          <source>Only works on Linux</source>
          <target state="translated">Linux에서만 작동</target>
        </trans-unit>
        <trans-unit id="9cbedc3b0f2aeb7733345bed14e006cfa949d8b9" translate="yes" xml:space="preserve">
          <source>Only works well with English names.</source>
          <target state="translated">영어 이름에서만 잘 작동합니다.</target>
        </trans-unit>
        <trans-unit id="46ef769c4a078e6997164d1bdec7d4e9aaa7c5ce" translate="yes" xml:space="preserve">
          <source>Only works with the Digital Mars C Runtime.</source>
          <target state="translated">Digital Mars C 런타임에서만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="d868746314878f673eaeb7cab7885b539498ab59" translate="yes" xml:space="preserve">
          <source>Op Assignment Operator Overloading</source>
          <target state="translated">연산 할당 연산자 오버로드</target>
        </trans-unit>
        <trans-unit id="aa42ddca3527c3262305947b13219762ea1c8d73" translate="yes" xml:space="preserve">
          <source>Opaque AA wrapper</source>
          <target state="translated">불투명 AA 포장지</target>
        </trans-unit>
        <trans-unit id="581bbfacbdf2dcb0762e876472d6d3e3e356f89d" translate="yes" xml:space="preserve">
          <source>Opaque Structs and Unions</source>
          <target state="translated">불투명 구조와 조합</target>
        </trans-unit>
        <trans-unit id="1ad7e0054470d6dbdf375fa4c9c53332e963b6e3" translate="yes" xml:space="preserve">
          <source>Opaque struct and union declarations do not have a &lt;a href=&quot;#AggregateBody&quot;&gt;&lt;i&gt;AggregateBody&lt;/i&gt;&lt;/a&gt;:</source>
          <target state="translated">불투명 구조체 및 공용체 선언에는 &lt;a href=&quot;#AggregateBody&quot;&gt;&lt;i&gt;AggregateBody&lt;/i&gt;&lt;/a&gt; 가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="7524f3aa077afff7785a23fcd72580f55d33ff80" translate="yes" xml:space="preserve">
          <source>Opcodes</source>
          <target state="translated">Opcodes</target>
        </trans-unit>
        <trans-unit id="d145964ace4c15a7eff46c943cbea00eff09f07f" translate="yes" xml:space="preserve">
          <source>Opcodes Supported</source>
          <target state="translated">지원되는 Opcode</target>
        </trans-unit>
        <trans-unit id="313411b9bd1b97b8fcd666d91d350cb8e6bed0d1" translate="yes" xml:space="preserve">
          <source>Open A BLOB For Incremental I/O</source>
          <target state="translated">증분 I / O를위한 BLOB 열기</target>
        </trans-unit>
        <trans-unit id="9a5db6b9f07fe0f6737e3037148bbc246c9b1140" translate="yes" xml:space="preserve">
          <source>Open memory mapped file filename for reading. File is closed when the object instance is deleted.</source>
          <target state="translated">읽을 메모리 매핑 된 파일 파일 이름을 엽니 다. 객체 인스턴스가 삭제되면 파일이 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="28b52b272c32e6d9c6e60e9eb9e62876583fe9a0" translate="yes" xml:space="preserve">
          <source>Open memory mapped file filename in mode. File is closed when the object instance is deleted.</source>
          <target state="translated">모드에서 메모리 매핑 된 파일 파일 이름을 엽니 다. 객체 인스턴스가 삭제되면 파일이 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="db3951317261fd51cb4c1a3e01c4748b4896c421" translate="yes" xml:space="preserve">
          <source>OpenBSD</source>
          <target state="translated">OpenBSD</target>
        </trans-unit>
        <trans-unit id="d864d3a0cba2629540ad6005310a4e1e9f9110a2" translate="yes" xml:space="preserve">
          <source>OpenRight &lt;code&gt;openRight&lt;/code&gt;</source>
          <target state="translated">OpenRight &lt;code&gt;openRight&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4aacf309ba9d8f7213885764ccd6340aa313658b" translate="yes" xml:space="preserve">
          <source>Open_Punctuation</source>
          <target state="translated">Open_Punctuation</target>
        </trans-unit>
        <trans-unit id="f1ba5b2c8dba45952ee1dd4e3e5587becf1e4832" translate="yes" xml:space="preserve">
          <source>Opening A New Database Connection</source>
          <target state="translated">새로운 데이터베이스 연결 열기</target>
        </trans-unit>
        <trans-unit id="8ca64c0c572cb68fa4f2ce914ea9b27b8a345ff6" translate="yes" xml:space="preserve">
          <source>Opens a TCP connection to the given host and port, then returns a File struct with read and write access through the same interface as any other file (meaning writef and the byLine ranges work!).</source>
          <target state="translated">주어진 호스트 및 포트에 대한 TCP 연결을 연 다음 다른 파일과 동일한 인터페이스를 통해 읽기 및 쓰기 액세스 권한이있는 File 구조체를 반환합니다 (writef 및 byLine 범위 작동).</target>
        </trans-unit>
        <trans-unit id="64bfbb68768403159904c1e04d1ec395011c0a93" translate="yes" xml:space="preserve">
          <source>Operand Types</source>
          <target state="translated">피연산자 유형</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
